# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 b9 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-09-19 10:42' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			STORE_0_BANKRUNN: equ $25   ; human readable bank id  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			key_macroroot:  equ chk_stovr - 2       ; root ptr for start of keyboard macro strings  
801f			key_macrolast:  equ key_macroroot - 2   ; last macro defined to aid linked list ptr  
801f			;  
801f			; Macro linked list format  
801f			; key code single byte   
801f			; ptr to next or zero if last in the list  
801f			; zero term string   
801f			  
801f			;keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row1: equ key_macrolast -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
801f			  
801f			debug_umark: equ parse_vector - 6  ; current user mark  
801f			debug_mark: equ debug_umark - 4    ; internal word debug points  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 03 ed				ld hl, display_fb1  
8022 22 bf eb				ld (display_fb_active), hl  
8025			  
8025 cd b1 8a				call clear_display  
8028			  
8028 21 c1 eb				ld hl, display_fb2  
802b 22 bf eb				ld (display_fb_active), hl  
802e			  
802e cd b1 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 a4 ed				ld hl, display_fb0  
8034 22 bf eb				ld (display_fb_active), hl  
8037			  
8037 cd b1 8a				call clear_display  
803a			  
803a			  
803a cd 7b e5				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd 1d e6			call key_init  
8040 cd ad 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd 83 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd d3 8a			call update_display  
8049 cd f0 89			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd b6 8a			call fill_display  
8051 cd d3 8a			call update_display  
8054 cd f0 89			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd b6 8a			call fill_display  
805c cd d3 8a			call update_display  
805f cd f0 89			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd b6 8a			call fill_display  
8067 cd d3 8a			call update_display  
806a cd f0 89			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 26 95			ld de, prom_bootmsg  
8072 cd c3 8a			call str_at_display  
8075 cd d3 8a			call update_display  
8078			  
8078			  
8078 cd f0 89			call delay1s  
807b cd f0 89			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 3b 95			ld de, prom_bootmsg1  
8083 cd c3 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd c3 8a			call str_at_display  
808e			  
808e cd d3 8a			call update_display  
8091 cd f0 89			call delay1s  
8094 cd f0 89			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 5e ee		ld (debug_mark),a  
809c 32 5f ee		ld (debug_mark+1),a  
809f 32 60 ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 61 ee		ld (debug_mark+3),a  
80a7 32 62 ee		ld (debug_umark),a  
80aa			  
80aa c9					ret  
80ab			  
80ab			  
80ab			;bootmsg2:	db "Firmware v0.1",0  
80ab			  
80ab			; a 4x20 lcd  
80ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ab			  
80ab			;if display_cols == 20  
80ab			;	include "firmware_lcd_4x20.asm"  
80ab			;endif  
80ab			  
80ab			;if display_cols == 40  
80ab			;	include "firmware_lcd_4x40.asm"  
80ab			;endif  
80ab			  
80ab			;  
80ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ab			; TODO abstract the bit bang video out interface for dual display  
80ab			; TODO wire video out to tx pin on rc2014 bus  
80ab			  
80ab			; must supply cin, and cin_wait for low level hardware abstraction   
80ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ab			; test scancode  
80ab			  
80ab			;;;;;  
80ab			;;;  
80ab			; Moved out to mini and maxi versions  
80ab			;  
80ab			; include "firmware_key_4x4.asm"  
80ab			; using existing 4 wire x 4 resistor array for input  
80ab			;include "firmware_key_4x10.asm"  
80ab			; need to mod the board for 5 rows due to resistor array  
80ab			;include "firmware_key_5x10.asm"  
80ab			  
80ab			; storage hardware interface  
80ab			  
80ab			; use microchip serial eeprom for storage  
80ab			  
80ab			  
80ab			if STORAGE_SE  
80ab				include "firmware_spi.asm"  
80ab				include "firmware_seeprom.asm"  
80ab			else  
80ab			   ; create some stubs for the labels  
80ab c9			se_readbyte: ret  
80ac c9			se_writebyte: ret  
80ad c9			storage_init: ret  
80ae			  
80ae			endif  
80ae			  
80ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ae			;include "firmware_cf.asm"  
80ae			  
80ae			; load up high level storage hardward abstractions  
80ae			include "firmware_storage.asm"  
80ae			 
80ae			; persisent storage hardware abstraction layer  
80ae			 
80ae			 
80ae			 
80ae			; Block 0 on storage is a config state 
80ae			 
80ae			 
80ae			 
80ae			; TODO add read phy block and write phy block functions 
80ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ae			 
80ae			; Abstraction layer  
80ae			 
80ae			; Logocial block size is same size as physical size - using tape concept 
80ae			 
80ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ae			 
80ae			 
80ae			 
80ae			; Filesystem layout (Logical layout) 
80ae			; 
80ae			; Block 0 - Bank config  
80ae			; 
80ae			;      Byte - 0 file id counter 
80ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ae			;      Byte - 3-20 zero terminated bank label 
80ae			; 
80ae			; Block 1 > File storage 
80ae			; 
80ae			;      Byte 0 file id    - block 0 file details 
80ae			;      Byte 1 block id - block 0 is file  
80ae			;            Byte 2-15 - File name 
80ae			; 
80ae			;       - to end of block data 
80ae			; 
80ae			 
80ae			; Get ID for the file named in pointer held HL 
80ae			; Returns ID in HL = 255 if no file found 
80ae			 
80ae			storage_getid: 
80ae			 
80ae 22 66 ea			ld (store_tmp1), hl 
80b1			 
80b1				if DEBUG_STORESE 
80b1					DMARK "SGI" 
80b1 f5				push af  
80b2 3a c6 80			ld a, (.dmark)  
80b5 32 5e ee			ld (debug_mark),a  
80b8 3a c7 80			ld a, (.dmark+1)  
80bb 32 5f ee			ld (debug_mark+1),a  
80be 3a c8 80			ld a, (.dmark+2)  
80c1 32 60 ee			ld (debug_mark+2),a  
80c4 18 03			jr .pastdmark  
80c6 ..			.dmark: db "SGI"  
80c9 f1			.pastdmark: pop af  
80ca			endm  
# End of macro DMARK
80ca					CALLMONITOR 
80ca cd 6b ee			call debug_vector  
80cd				endm  
# End of macro CALLMONITOR
80cd				endif 
80cd				; get block 0 and set counter for number of files to scan 
80cd			 
80cd cd 35 82			call storage_get_block_0 
80d0			 
80d0 3a 6d ea			ld a, (store_page) 
80d3 47				ld b, a 
80d4			 
80d4				; get extent 0 of each file id 
80d4			 
80d4				if DEBUG_STORESE 
80d4					DMARK "SGc" 
80d4 f5				push af  
80d5 3a e9 80			ld a, (.dmark)  
80d8 32 5e ee			ld (debug_mark),a  
80db 3a ea 80			ld a, (.dmark+1)  
80de 32 5f ee			ld (debug_mark+1),a  
80e1 3a eb 80			ld a, (.dmark+2)  
80e4 32 60 ee			ld (debug_mark+2),a  
80e7 18 03			jr .pastdmark  
80e9 ..			.dmark: db "SGc"  
80ec f1			.pastdmark: pop af  
80ed			endm  
# End of macro DMARK
80ed					CALLMONITOR 
80ed cd 6b ee			call debug_vector  
80f0				endm  
# End of macro CALLMONITOR
80f0				endif 
80f0 60			.getloop:	ld h, b 
80f1 2e 00				ld l, 0 
80f3 c5					push bc 
80f4			 
80f4 11 6d ea				ld de, store_page 
80f7				if DEBUG_STORESE 
80f7					DMARK "SGr" 
80f7 f5				push af  
80f8 3a 0c 81			ld a, (.dmark)  
80fb 32 5e ee			ld (debug_mark),a  
80fe 3a 0d 81			ld a, (.dmark+1)  
8101 32 5f ee			ld (debug_mark+1),a  
8104 3a 0e 81			ld a, (.dmark+2)  
8107 32 60 ee			ld (debug_mark+2),a  
810a 18 03			jr .pastdmark  
810c ..			.dmark: db "SGr"  
810f f1			.pastdmark: pop af  
8110			endm  
# End of macro DMARK
8110					CALLMONITOR 
8110 cd 6b ee			call debug_vector  
8113				endm  
# End of macro CALLMONITOR
8113				endif 
8113 cd d7 86				call storage_read 
8116 cd 04 8d				call ishlzero 
8119 28 2d				jr z, .gap 
811b					 
811b					; have a file name read. Is it one we want. 
811b			 
811b 2a 66 ea				ld hl, (store_tmp1) 
811e 11 70 ea				ld de, store_page+3   ; file name 
8121			 
8121				if DEBUG_STORESE 
8121					DMARK "SGc" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 5e ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 5f ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 60 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGc"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 6b ee			call debug_vector  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d cd 6b 90				call strcmp 
8140 20 06				jr nz, .gap   ; not this one 
8142			 
8142 c1				        pop bc 
8143			 
8143 26 00				ld h, 0 
8145 68					ld l, b 
8146 18 22				jr .getdone 
8148						 
8148			 
8148			 
8148			 
8148			.gap: 
8148				if DEBUG_STORESE 
8148					DMARK "SGg" 
8148 f5				push af  
8149 3a 5d 81			ld a, (.dmark)  
814c 32 5e ee			ld (debug_mark),a  
814f 3a 5e 81			ld a, (.dmark+1)  
8152 32 5f ee			ld (debug_mark+1),a  
8155 3a 5f 81			ld a, (.dmark+2)  
8158 32 60 ee			ld (debug_mark+2),a  
815b 18 03			jr .pastdmark  
815d ..			.dmark: db "SGg"  
8160 f1			.pastdmark: pop af  
8161			endm  
# End of macro DMARK
8161					CALLMONITOR 
8161 cd 6b ee			call debug_vector  
8164				endm  
# End of macro CALLMONITOR
8164				endif 
8164			 
8164 c1					pop bc 
8165 10 89				djnz .getloop 
8167 21 ff 00				ld hl, 255 
816a			.getdone: 
816a			 
816a				if DEBUG_STORESE 
816a					DMARK "SGe" 
816a f5				push af  
816b 3a 7f 81			ld a, (.dmark)  
816e 32 5e ee			ld (debug_mark),a  
8171 3a 80 81			ld a, (.dmark+1)  
8174 32 5f ee			ld (debug_mark+1),a  
8177 3a 81 81			ld a, (.dmark+2)  
817a 32 60 ee			ld (debug_mark+2),a  
817d 18 03			jr .pastdmark  
817f ..			.dmark: db "SGe"  
8182 f1			.pastdmark: pop af  
8183			endm  
# End of macro DMARK
8183					CALLMONITOR 
8183 cd 6b ee			call debug_vector  
8186				endm  
# End of macro CALLMONITOR
8186				endif 
8186			 
8186 c9				ret 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			; Read Block 
8187			; ---------- 
8187			; 
8187			; With current bank 
8187			;  
8187			; Get block number to read 
8187			; Load physical blocks starting at start block into buffer 
8187			 
8187			; de points to buffer to use 
8187			; hl holds logical block number  
8187			 
8187			storage_read_block: 
8187			 
8187				; TODO bank selection 
8187			 
8187				; for each of the physical blocks read it into the buffer 
8187 06 40			ld b, STORE_BLOCK_PHY 
8189			 
8189				if DEBUG_STORESE 
8189 d5					push de 
818a				endif 
818a				 
818a			.rl1:    
818a			 
818a				; read physical block at hl into de 
818a			        ; increment hl and de to next read position on exit 
818a			 
818a e5				push hl 
818b d5				push de	 
818c c5				push bc 
818d			;	if DEBUG_STORESE 
818d			;		push af 
818d			;		ld a, 'R' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d cd ab 80			call se_readbyte 
8190			;	if DEBUG_STORESE 
8190			;		ld a,(spi_portbyte) 
8190			;		ld l, a 
8190			;		push af 
8190			;		ld a, '1' 
8190			;		ld (debug_mark),a 
8190			;		pop af 
8190			;		CALLMONITOR 
8190			;	endif 
8190 c1				pop bc 
8191 d1				pop de 
8192 e1				pop hl 
8193 12				ld (de),a 
8194 23				inc hl 
8195 13				inc de 
8196			 
8196			;	if DEBUG_STORESE 
8196			;		push af 
8196			;		ld a, 'r' 
8196			;		ld (debug_mark),a 
8196			;		pop af 
8196			;		CALLMONITOR 
8196			;	endif 
8196			 
8196 10 f2			djnz .rl1 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SRB" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 5e ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 5f ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 60 ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SRB"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1 d1					pop de 
81b2			; 
81b2			;		push af 
81b2			;		ld a, 'R' 
81b2			;		ld (debug_mark),a 
81b2			;		pop af 
81b2					CALLMONITOR 
81b2 cd 6b ee			call debug_vector  
81b5				endm  
# End of macro CALLMONITOR
81b5				endif 
81b5 c9				ret	 
81b6				 
81b6			 
81b6			; File Size 
81b6			; --------- 
81b6			; 
81b6			;   hl file id 
81b6			; 
81b6			;  returns in hl the number of blocks 
81b6			 
81b6			storage_file_size: 
81b6 5d				ld e, l 
81b7 16 00			ld d, 0 
81b9 21 40 00			ld hl, STORE_BLOCK_PHY 
81bc					if DEBUG_FORTH_WORDS 
81bc						DMARK "SIZ" 
81bc f5				push af  
81bd 3a d1 81			ld a, (.dmark)  
81c0 32 5e ee			ld (debug_mark),a  
81c3 3a d2 81			ld a, (.dmark+1)  
81c6 32 5f ee			ld (debug_mark+1),a  
81c9 3a d3 81			ld a, (.dmark+2)  
81cc 32 60 ee			ld (debug_mark+2),a  
81cf 18 03			jr .pastdmark  
81d1 ..			.dmark: db "SIZ"  
81d4 f1			.pastdmark: pop af  
81d5			endm  
# End of macro DMARK
81d5						CALLMONITOR 
81d5 cd 6b ee			call debug_vector  
81d8				endm  
# End of macro CALLMONITOR
81d8					endif 
81d8 cd b3 84			call storage_findnextid 
81db			 
81db cd 04 8d			call ishlzero 
81de			;	ld a, l 
81de			;	add h 
81de			;	cp 0 
81de c8				ret z			; block not found so EOF 
81df			 
81df 11 6d ea			ld de, store_page 
81e2 cd 87 81			call storage_read_block 
81e5			 
81e5 3a 6f ea			ld a, (store_page+2)	 ; get extent count 
81e8 6f				ld l, a 
81e9 26 00			ld h, 0 
81eb c9			 	ret 
81ec			 
81ec			 
81ec			; Write Block 
81ec			; ----------- 
81ec			; 
81ec			; With current bank 
81ec			;  
81ec			; Get block number to write 
81ec			; Write physical blocks starting at start block from buffer 
81ec			  
81ec			storage_write_block: 
81ec				; TODO bank selection 
81ec			 
81ec				; for each of the physical blocks read it into the buffer 
81ec 06 40			ld b, STORE_BLOCK_PHY 
81ee			 
81ee				if DEBUG_STORESE 
81ee					DMARK "SWB" 
81ee f5				push af  
81ef 3a 03 82			ld a, (.dmark)  
81f2 32 5e ee			ld (debug_mark),a  
81f5 3a 04 82			ld a, (.dmark+1)  
81f8 32 5f ee			ld (debug_mark+1),a  
81fb 3a 05 82			ld a, (.dmark+2)  
81fe 32 60 ee			ld (debug_mark+2),a  
8201 18 03			jr .pastdmark  
8203 ..			.dmark: db "SWB"  
8206 f1			.pastdmark: pop af  
8207			endm  
# End of macro DMARK
8207			 
8207					;push af 
8207					;ld a, 'W' 
8207					;ld (debug_mark),a 
8207					;pop af 
8207					CALLMONITOR 
8207 cd 6b ee			call debug_vector  
820a				endm  
# End of macro CALLMONITOR
820a				endif 
820a			 
820a			; might not be working 
820a			;	call se_writepage 
820a			 
820a			;	ret 
820a			; 
820a			 
820a			 
820a			 
820a			.wl1:    
820a			 
820a				; read physical block at hl into de 
820a			        ; increment hl and de to next read position on exit 
820a			 
820a e5				push hl 
820b d5				push de	 
820c c5				push bc 
820d 1a				ld a,(de) 
820e				;if DEBUG_STORESE 
820e			;		push af 
820e			;		ld a, 'W' 
820e			;		ld (debug_mark),a 
820e			;		pop af 
820e			;		CALLMONITOR 
820e			;	endif 
820e cd ac 80			call se_writebyte 
8211			;	call delay250ms 
8211			;	nop 
8211			;	nop 
8211			;	nop 
8211			;	if DEBUG_STORESE 
8211			;		push af 
8211			;		ld a, 'w' 
8211			;		ld (debug_mark),a 
8211			;		pop af 
8211			;		CALLMONITOR 
8211			;	endif 
8211 c1				pop bc 
8212 d1				pop de 
8213 e1				pop hl 
8214 23				inc hl 
8215 13				inc de 
8216			 
8216			 
8216 10 f2			djnz .wl1 
8218			 
8218				if DEBUG_STORESE 
8218					DMARK "SW2" 
8218 f5				push af  
8219 3a 2d 82			ld a, (.dmark)  
821c 32 5e ee			ld (debug_mark),a  
821f 3a 2e 82			ld a, (.dmark+1)  
8222 32 5f ee			ld (debug_mark+1),a  
8225 3a 2f 82			ld a, (.dmark+2)  
8228 32 60 ee			ld (debug_mark+2),a  
822b 18 03			jr .pastdmark  
822d ..			.dmark: db "SW2"  
8230 f1			.pastdmark: pop af  
8231			endm  
# End of macro DMARK
8231			 
8231					;push af 
8231					;ld a, 'W' 
8231					;ld (debug_mark),a 
8231					;pop af 
8231					CALLMONITOR 
8231 cd 6b ee			call debug_vector  
8234				endm  
# End of macro CALLMONITOR
8234				endif 
8234 c9				ret	 
8235			 
8235			; Init bank 
8235			; --------- 
8235			; 
8235			; With current bank 
8235			; 
8235			; Setup block 0 config 
8235			;     Set 0 file id counter 
8235			;     Set formatted byte pattern 
8235			;     Zero out bank label 
8235			;      
8235			; For every logical block write 0-1 byte as null 
8235			 
8235			storage_get_block_0: 
8235			 
8235				; TODO check presence 
8235			 
8235				; get block 0 config 
8235			 
8235 21 00 00			ld hl, 0 
8238 11 6d ea			ld de, store_page 
823b cd 87 81			call storage_read_block 
823e			 
823e				if DEBUG_STORESE 
823e					DMARK "SB0" 
823e f5				push af  
823f 3a 53 82			ld a, (.dmark)  
8242 32 5e ee			ld (debug_mark),a  
8245 3a 54 82			ld a, (.dmark+1)  
8248 32 5f ee			ld (debug_mark+1),a  
824b 3a 55 82			ld a, (.dmark+2)  
824e 32 60 ee			ld (debug_mark+2),a  
8251 18 03			jr .pastdmark  
8253 ..			.dmark: db "SB0"  
8256 f1			.pastdmark: pop af  
8257			endm  
# End of macro DMARK
8257 11 6d ea				ld de, store_page 
825a			;		push af 
825a			;		ld a, 'i' 
825a			;		ld (debug_mark),a 
825a			;		pop af 
825a					CALLMONITOR 
825a cd 6b ee			call debug_vector  
825d				endm  
# End of macro CALLMONITOR
825d				endif 
825d			 
825d				; is this area formatted? 
825d			 
825d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
825d 2a 6e ea			ld hl, (store_page+1) 
8260 3e 80			ld a,0x80 
8262 bd				cp l 
8263 20 22			jr nz, .ininotformatted 
8265				; do a double check 
8265 3e 27			ld a, 0x27 
8267 bc				cp h 
8268 20 1d			jr nz, .ininotformatted 
826a			 
826a				; formatted then 
826a			 
826a				if DEBUG_STORESE 
826a					DMARK "SB1" 
826a f5				push af  
826b 3a 7f 82			ld a, (.dmark)  
826e 32 5e ee			ld (debug_mark),a  
8271 3a 80 82			ld a, (.dmark+1)  
8274 32 5f ee			ld (debug_mark+1),a  
8277 3a 81 82			ld a, (.dmark+2)  
827a 32 60 ee			ld (debug_mark+2),a  
827d 18 03			jr .pastdmark  
827f ..			.dmark: db "SB1"  
8282 f1			.pastdmark: pop af  
8283			endm  
# End of macro DMARK
8283					;push af 
8283					;ld a, 'I' 
8283					;ld (debug_mark),a 
8283					;pop af 
8283					CALLMONITOR 
8283 cd 6b ee			call debug_vector  
8286				endm  
# End of macro CALLMONITOR
8286				endif 
8286 c9				ret 
8287			 
8287			.ininotformatted: 
8287				; bank not formatted so poke various bits to make sure 
8287			 
8287				if DEBUG_STORESE 
8287					DMARK "SB2" 
8287 f5				push af  
8288 3a 9c 82			ld a, (.dmark)  
828b 32 5e ee			ld (debug_mark),a  
828e 3a 9d 82			ld a, (.dmark+1)  
8291 32 5f ee			ld (debug_mark+1),a  
8294 3a 9e 82			ld a, (.dmark+2)  
8297 32 60 ee			ld (debug_mark+2),a  
829a 18 03			jr .pastdmark  
829c ..			.dmark: db "SB2"  
829f f1			.pastdmark: pop af  
82a0			endm  
# End of macro DMARK
82a0					;push af 
82a0					;ld a, 'f' 
82a0					;ld (debug_mark),a 
82a0					;pop af 
82a0					CALLMONITOR 
82a0 cd 6b ee			call debug_vector  
82a3				endm  
# End of macro CALLMONITOR
82a3				endif 
82a3			 
82a3 cd b4 89			call storage_clear_page 
82a6			 
82a6 21 6d ea			ld hl, store_page 
82a9			;	ld a, 0 
82a9				 
82a9 36 00			ld (hl),0   ; reset file counter 
82ab			 
82ab 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82ae 22 6e ea		 	ld (store_page+1), hl	 
82b1			 
82b1				; set default label 
82b1			 
82b1 21 4a 83			ld hl, .defaultbanklabl 
82b4 11 70 ea		 	ld de, store_page+3 
82b7 01 0f 00			ld bc, 15 
82ba ed b0			ldir 
82bc			 
82bc				; Append the current bank id 
82bc 21 79 ea			ld hl, store_page+3+9 
82bf 3a 52 ea			ld a, (spi_device_id) 
82c2 77				ld (hl), a 
82c3			 
82c3				; save default page 0 
82c3			 
82c3 21 00 00			ld hl, 0 
82c6 11 6d ea			ld de, store_page 
82c9				if DEBUG_STORESE 
82c9					DMARK "SB3" 
82c9 f5				push af  
82ca 3a de 82			ld a, (.dmark)  
82cd 32 5e ee			ld (debug_mark),a  
82d0 3a df 82			ld a, (.dmark+1)  
82d3 32 5f ee			ld (debug_mark+1),a  
82d6 3a e0 82			ld a, (.dmark+2)  
82d9 32 60 ee			ld (debug_mark+2),a  
82dc 18 03			jr .pastdmark  
82de ..			.dmark: db "SB3"  
82e1 f1			.pastdmark: pop af  
82e2			endm  
# End of macro DMARK
82e2			;		push af 
82e2			;		ld a, 'F' 
82e2			;		ld (debug_mark),a 
82e2			;		pop af 
82e2					CALLMONITOR 
82e2 cd 6b ee			call debug_vector  
82e5				endm  
# End of macro CALLMONITOR
82e5				endif 
82e5 cd ec 81			call storage_write_block 
82e8				if DEBUG_STORESE 
82e8					DMARK "SB4" 
82e8 f5				push af  
82e9 3a fd 82			ld a, (.dmark)  
82ec 32 5e ee			ld (debug_mark),a  
82ef 3a fe 82			ld a, (.dmark+1)  
82f2 32 5f ee			ld (debug_mark+1),a  
82f5 3a ff 82			ld a, (.dmark+2)  
82f8 32 60 ee			ld (debug_mark+2),a  
82fb 18 03			jr .pastdmark  
82fd ..			.dmark: db "SB4"  
8300 f1			.pastdmark: pop af  
8301			endm  
# End of macro DMARK
8301			;		push af 
8301			;		ld a, '>' 
8301			;		ld (debug_mark),a 
8301			;		pop af 
8301					CALLMONITOR 
8301 cd 6b ee			call debug_vector  
8304				endm  
# End of macro CALLMONITOR
8304				endif 
8304			 
8304			;	nop 
8304			;	nop 
8304			;	nop 
8304			 
8304				; now set 0 in every page to mark as a free block 
8304			 
8304 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8306 21 40 00			ld hl, STORE_BLOCK_PHY 
8309			 
8309 3e 00		.setmark1:   	ld a,0 
830b e5					push hl 
830c c5					push bc 
830d cd ac 80				call se_writebyte 
8310 3e 0a			ld a, 10 
8312 cd d5 89			call aDelayInMS 
8315 23				inc hl 
8316 cd ac 80				call se_writebyte 
8319 3e 0a			ld a, 10 
831b cd d5 89			call aDelayInMS 
831e 2b				dec hl 
831f c1					pop bc 
8320 e1					pop hl 
8321 3e 40				ld a, STORE_BLOCK_PHY 
8323 cd db 8c				call addatohl 
8326 10 e1				djnz .setmark1 
8328			 
8328 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
832a 3e 00		.setmark2:   	ld a,0 
832c e5					push hl 
832d c5					push bc 
832e cd ac 80				call se_writebyte 
8331 3e 0a			ld a, 10 
8333 cd d5 89			call aDelayInMS 
8336 23				inc hl 
8337 cd ac 80				call se_writebyte 
833a 3e 0a			ld a, 10 
833c cd d5 89			call aDelayInMS 
833f 2b				dec hl 
8340 c1					pop bc 
8341 e1					pop hl 
8342 3e 40				ld a, STORE_BLOCK_PHY 
8344 cd db 8c				call addatohl 
8347 10 e1				djnz .setmark2 
8349			 
8349					 
8349			 
8349			 
8349 c9				ret 
834a			 
834a			 
834a			 
834a			 
834a .. 00		.defaultbanklabl:   db "BankLabel_",0 
8355			 
8355			 
8355			 
8355			; Label Bank 
8355			; ---------- 
8355			; 
8355			; With current bank 
8355			; Read block 0 
8355			; Set label 
8355			; Write block 0 
8355			 
8355			; label str pointer in hl 
8355			 
8355			storage_label:     
8355			 
8355				if DEBUG_STORESE 
8355					DMARK "LBL" 
8355 f5				push af  
8356 3a 6a 83			ld a, (.dmark)  
8359 32 5e ee			ld (debug_mark),a  
835c 3a 6b 83			ld a, (.dmark+1)  
835f 32 5f ee			ld (debug_mark+1),a  
8362 3a 6c 83			ld a, (.dmark+2)  
8365 32 60 ee			ld (debug_mark+2),a  
8368 18 03			jr .pastdmark  
836a ..			.dmark: db "LBL"  
836d f1			.pastdmark: pop af  
836e			endm  
# End of macro DMARK
836e					CALLMONITOR 
836e cd 6b ee			call debug_vector  
8371				endm  
# End of macro CALLMONITOR
8371				endif 
8371			 
8371 e5				push hl 
8372			 
8372 cd 35 82			call storage_get_block_0 
8375			 
8375				; set default label 
8375			 
8375 e1				pop hl 
8376			 
8376 11 70 ea		 	ld de, store_page+3 
8379 01 0f 00			ld bc, 15 
837c				if DEBUG_STORESE 
837c					DMARK "LB3" 
837c f5				push af  
837d 3a 91 83			ld a, (.dmark)  
8380 32 5e ee			ld (debug_mark),a  
8383 3a 92 83			ld a, (.dmark+1)  
8386 32 5f ee			ld (debug_mark+1),a  
8389 3a 93 83			ld a, (.dmark+2)  
838c 32 60 ee			ld (debug_mark+2),a  
838f 18 03			jr .pastdmark  
8391 ..			.dmark: db "LB3"  
8394 f1			.pastdmark: pop af  
8395			endm  
# End of macro DMARK
8395					CALLMONITOR 
8395 cd 6b ee			call debug_vector  
8398				endm  
# End of macro CALLMONITOR
8398				endif 
8398 ed b0			ldir 
839a				; save default page 0 
839a			 
839a 21 00 00			ld hl, 0 
839d 11 6d ea			ld de, store_page 
83a0				if DEBUG_STORESE 
83a0					DMARK "LBW" 
83a0 f5				push af  
83a1 3a b5 83			ld a, (.dmark)  
83a4 32 5e ee			ld (debug_mark),a  
83a7 3a b6 83			ld a, (.dmark+1)  
83aa 32 5f ee			ld (debug_mark+1),a  
83ad 3a b7 83			ld a, (.dmark+2)  
83b0 32 60 ee			ld (debug_mark+2),a  
83b3 18 03			jr .pastdmark  
83b5 ..			.dmark: db "LBW"  
83b8 f1			.pastdmark: pop af  
83b9			endm  
# End of macro DMARK
83b9					CALLMONITOR 
83b9 cd 6b ee			call debug_vector  
83bc				endm  
# End of macro CALLMONITOR
83bc				endif 
83bc cd ec 81			call storage_write_block 
83bf			 
83bf c9				ret 
83c0			 
83c0			 
83c0			 
83c0			; Read Block 0 - Config 
83c0			; --------------------- 
83c0			; 
83c0			; With current bank 
83c0			; Call presence test 
83c0			;    If not present format/init bank  
83c0			; Read block 0  
83c0			;  
83c0			 
83c0			 
83c0			; Dir 
83c0			; --- 
83c0			; 
83c0			; With current bank 
83c0			; Load Block 0 Config 
83c0			; Get max file id number 
83c0			; For each logical block 
83c0			;    Read block read byte 2 
83c0			;      if first block of file 
83c0			;         Display file name 
83c0			;         Display type flags for file 
83c0			;        
83c0			 
83c0			; moving to words as this requires stack control 
83c0			 
83c0			 
83c0			; Delete File 
83c0			; ----------- 
83c0			; 
83c0			; With current bank 
83c0			; 
83c0			; Load Block 0 Config 
83c0			; Get max file id number 
83c0			; For each logical block 
83c0			;    Read block file id 
83c0			;      If first block of file and dont have file id 
83c0			;         if file to delete 
83c0			;         Save file id 
83c0			;         Null file id 
83c0			;         Write this block back 
83c0			;      If file id is one saved 
83c0			;         Null file id 
83c0			;         Write this block back 
83c0			 
83c0			 
83c0			.se_done: 
83c0 e1				pop hl 
83c1 c9				ret 
83c2			 
83c2			storage_erase: 
83c2			 
83c2				; hl contains the file id 
83c2			 
83c2 5d				ld e, l 
83c3 16 00			ld d, 0 
83c5 21 40 00			ld hl, STORE_BLOCK_PHY 
83c8					if DEBUG_FORTH_WORDS 
83c8						DMARK "ERA" 
83c8 f5				push af  
83c9 3a dd 83			ld a, (.dmark)  
83cc 32 5e ee			ld (debug_mark),a  
83cf 3a de 83			ld a, (.dmark+1)  
83d2 32 5f ee			ld (debug_mark+1),a  
83d5 3a df 83			ld a, (.dmark+2)  
83d8 32 60 ee			ld (debug_mark+2),a  
83db 18 03			jr .pastdmark  
83dd ..			.dmark: db "ERA"  
83e0 f1			.pastdmark: pop af  
83e1			endm  
# End of macro DMARK
83e1						CALLMONITOR 
83e1 cd 6b ee			call debug_vector  
83e4				endm  
# End of macro CALLMONITOR
83e4					endif 
83e4 cd b3 84			call storage_findnextid 
83e7 cd 04 8d			call ishlzero 
83ea c8				ret z 
83eb			 
83eb e5				push hl 
83ec			 
83ec				; TODO check file not found 
83ec			 
83ec 11 6d ea			ld de, store_page 
83ef cd 87 81			call storage_read_block 
83f2			 
83f2 cd 04 8d			call ishlzero 
83f5 ca c0 83			jp z,.se_done 
83f8			 
83f8					if DEBUG_FORTH_WORDS 
83f8						DMARK "ER1" 
83f8 f5				push af  
83f9 3a 0d 84			ld a, (.dmark)  
83fc 32 5e ee			ld (debug_mark),a  
83ff 3a 0e 84			ld a, (.dmark+1)  
8402 32 5f ee			ld (debug_mark+1),a  
8405 3a 0f 84			ld a, (.dmark+2)  
8408 32 60 ee			ld (debug_mark+2),a  
840b 18 03			jr .pastdmark  
840d ..			.dmark: db "ER1"  
8410 f1			.pastdmark: pop af  
8411			endm  
# End of macro DMARK
8411						CALLMONITOR 
8411 cd 6b ee			call debug_vector  
8414				endm  
# End of macro CALLMONITOR
8414					endif 
8414 3a 6d ea			ld a, (store_page)	; get file id 
8417 32 61 ea			ld (store_tmpid), a 
841a			 
841a 3a 6f ea			ld a, (store_page+2)    ; get count of extends 
841d 32 60 ea			ld (store_tmpext), a 
8420			 
8420				; wipe file header 
8420			 
8420 e1				pop hl 
8421 3e 00			ld a, 0 
8423 32 6d ea			ld (store_page), a 
8426 32 6e ea			ld (store_page+1),a 
8429 11 6d ea			ld de, store_page 
842c					if DEBUG_FORTH_WORDS 
842c						DMARK "ER2" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 5e ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 5f ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 60 ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "ER2"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445						CALLMONITOR 
8445 cd 6b ee			call debug_vector  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448 cd ec 81			call storage_write_block 
844b			 
844b			 
844b				; wipe file extents 
844b			 
844b 3a 60 ea			ld a, (store_tmpext) 
844e 47				ld b, a 
844f			 
844f			.eraext:	  
844f c5				push bc 
8450			 
8450 21 40 00			ld hl, STORE_BLOCK_PHY 
8453 3a 61 ea			ld a,(store_tmpid) 
8456 5f				ld e, a 
8457 50				ld d, b	 
8458					if DEBUG_FORTH_WORDS 
8458						DMARK "ER3" 
8458 f5				push af  
8459 3a 6d 84			ld a, (.dmark)  
845c 32 5e ee			ld (debug_mark),a  
845f 3a 6e 84			ld a, (.dmark+1)  
8462 32 5f ee			ld (debug_mark+1),a  
8465 3a 6f 84			ld a, (.dmark+2)  
8468 32 60 ee			ld (debug_mark+2),a  
846b 18 03			jr .pastdmark  
846d ..			.dmark: db "ER3"  
8470 f1			.pastdmark: pop af  
8471			endm  
# End of macro DMARK
8471						CALLMONITOR 
8471 cd 6b ee			call debug_vector  
8474				endm  
# End of macro CALLMONITOR
8474					endif 
8474 cd b3 84			call storage_findnextid 
8477 cd 04 8d			call ishlzero 
847a ca c0 83			jp z,.se_done 
847d			 
847d e5				push hl 
847e 11 6d ea			ld de, store_page 
8481 cd 87 81			call storage_read_block 
8484			 
8484				; free block	 
8484			 
8484 3e 00			ld a, 0 
8486 32 6d ea			ld (store_page), a 
8489 32 6e ea			ld (store_page+1),a 
848c 11 6d ea			ld de, store_page 
848f e1				pop hl 
8490					if DEBUG_FORTH_WORDS 
8490						DMARK "ER4" 
8490 f5				push af  
8491 3a a5 84			ld a, (.dmark)  
8494 32 5e ee			ld (debug_mark),a  
8497 3a a6 84			ld a, (.dmark+1)  
849a 32 5f ee			ld (debug_mark+1),a  
849d 3a a7 84			ld a, (.dmark+2)  
84a0 32 60 ee			ld (debug_mark+2),a  
84a3 18 03			jr .pastdmark  
84a5 ..			.dmark: db "ER4"  
84a8 f1			.pastdmark: pop af  
84a9			endm  
# End of macro DMARK
84a9						CALLMONITOR 
84a9 cd 6b ee			call debug_vector  
84ac				endm  
# End of macro CALLMONITOR
84ac					endif 
84ac cd ec 81			call storage_write_block 
84af			 
84af c1				pop bc 
84b0 10 9d			djnz .eraext 
84b2			 
84b2 c9				ret 
84b3			 
84b3			 
84b3			; Find Free Block 
84b3			; --------------- 
84b3			; 
84b3			; With current bank 
84b3			;  
84b3			; From given starting logical block 
84b3			;    Read block  
84b3			;    If no file id 
84b3			;         Return block id 
84b3			 
84b3			 
84b3			; hl starting page number 
84b3			; hl contains free page number or zero if no pages free 
84b3			; e contains the file id to locate 
84b3			; d contains the block number 
84b3			 
84b3			; TODO change to find file id and use zero for free block 
84b3			 
84b3			storage_findnextid: 
84b3			 
84b3				; now locate first 0 page to mark as a free block 
84b3			 
84b3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84b5			;	ld hl, STORE_BLOCK_PHY 
84b5			 
84b5					if DEBUG_FORTH_WORDS 
84b5					DMARK "FNI" 
84b5 f5				push af  
84b6 3a ca 84			ld a, (.dmark)  
84b9 32 5e ee			ld (debug_mark),a  
84bc 3a cb 84			ld a, (.dmark+1)  
84bf 32 5f ee			ld (debug_mark+1),a  
84c2 3a cc 84			ld a, (.dmark+2)  
84c5 32 60 ee			ld (debug_mark+2),a  
84c8 18 03			jr .pastdmark  
84ca ..			.dmark: db "FNI"  
84cd f1			.pastdmark: pop af  
84ce			endm  
# End of macro DMARK
84ce						CALLMONITOR 
84ce cd 6b ee			call debug_vector  
84d1				endm  
# End of macro CALLMONITOR
84d1					endif 
84d1			.ff1:   	 
84d1 e5					push hl 
84d2 c5					push bc 
84d3 d5					push de 
84d4 cd ab 80				call se_readbyte 
84d7 5f					ld e,a 
84d8 23					inc hl 
84d9 cd ab 80				call se_readbyte 
84dc 57					ld d, a 
84dd e1					pop hl 
84de e5					push hl 
84df cd f9 8c				call cmp16 
84e2 28 49				jr z, .fffound 
84e4			 
84e4 d1					pop de 
84e5 c1					pop bc 
84e6 e1					pop hl 
84e7			 
84e7					; is found? 
84e7					;cp e 
84e7					;ret z 
84e7			 
84e7 3e 40				ld a, STORE_BLOCK_PHY 
84e9 cd db 8c				call addatohl 
84ec 10 e3				djnz .ff1 
84ee			 
84ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f0			.ff2:   	 
84f0			 
84f0 e5					push hl 
84f1 c5					push bc 
84f2 d5					push de 
84f3 cd ab 80				call se_readbyte 
84f6 5f					ld e,a 
84f7 23					inc hl 
84f8 cd ab 80				call se_readbyte 
84fb 57					ld d, a 
84fc			 
84fc e1					pop hl 
84fd e5					push hl 
84fe cd f9 8c				call cmp16 
8501 28 2a				jr z, .fffound 
8503			 
8503 d1					pop de 
8504 c1					pop bc 
8505 e1					pop hl 
8506					; is found? 
8506					;cp e 
8506					;ret z 
8506			 
8506 3e 40				ld a, STORE_BLOCK_PHY 
8508 cd db 8c				call addatohl 
850b 10 e3				djnz .ff2 
850d			 
850d			 
850d					if DEBUG_FORTH_WORDS 
850d					DMARK "FN-" 
850d f5				push af  
850e 3a 22 85			ld a, (.dmark)  
8511 32 5e ee			ld (debug_mark),a  
8514 3a 23 85			ld a, (.dmark+1)  
8517 32 5f ee			ld (debug_mark+1),a  
851a 3a 24 85			ld a, (.dmark+2)  
851d 32 60 ee			ld (debug_mark+2),a  
8520 18 03			jr .pastdmark  
8522 ..			.dmark: db "FN-"  
8525 f1			.pastdmark: pop af  
8526			endm  
# End of macro DMARK
8526					;	push af 
8526					;	ld a, 'n' 
8526					;	ld (debug_mark),a 
8526					;	pop af 
8526						CALLMONITOR 
8526 cd 6b ee			call debug_vector  
8529				endm  
# End of macro CALLMONITOR
8529					endif 
8529				; no free marks! 
8529 21 00 00				ld hl, 0 
852c c9				ret 
852d			.fffound: 
852d				 
852d			 
852d d1					pop de 
852e c1					pop bc 
852f e1					pop hl 
8530					if DEBUG_FORTH_WORDS 
8530					DMARK "FNF" 
8530 f5				push af  
8531 3a 45 85			ld a, (.dmark)  
8534 32 5e ee			ld (debug_mark),a  
8537 3a 46 85			ld a, (.dmark+1)  
853a 32 5f ee			ld (debug_mark+1),a  
853d 3a 47 85			ld a, (.dmark+2)  
8540 32 60 ee			ld (debug_mark+2),a  
8543 18 03			jr .pastdmark  
8545 ..			.dmark: db "FNF"  
8548 f1			.pastdmark: pop af  
8549			endm  
# End of macro DMARK
8549					;	push af 
8549					;	ld a, 'n' 
8549					;	ld (debug_mark),a 
8549					;	pop af 
8549						CALLMONITOR 
8549 cd 6b ee			call debug_vector  
854c				endm  
# End of macro CALLMONITOR
854c					endif 
854c c9				ret 
854d			 
854d			 
854d			 
854d			; Free Space 
854d			; ---------- 
854d			; 
854d			; With current bank 
854d			; 
854d			; Set block count to zero 
854d			; Starting with first logical block 
854d			;      Find free block  
854d			;      If block id given, increment block count 
854d			; 
854d			;  
854d			 
854d			 
854d			; hl contains count of free blocks 
854d			 
854d			storage_freeblocks: 
854d			 
854d				; now locate first 0 page to mark as a free block 
854d			 
854d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
854f 21 40 00			ld hl, STORE_BLOCK_PHY 
8552 11 00 00			ld de, 0 
8555			 
8555			.fb1:   	 
8555 e5					push hl 
8556 c5					push bc 
8557 d5					push de 
8558 cd ab 80				call se_readbyte 
855b d1					pop de 
855c c1					pop bc 
855d e1					pop hl 
855e			 
855e					; is free? 
855e			;		cp 0 
855e b7					or a 
855f 20 01				jr nz, .ff1cont 
8561 13					inc de 
8562			 
8562			.ff1cont: 
8562			 
8562			 
8562 3e 40				ld a, STORE_BLOCK_PHY 
8564 cd db 8c				call addatohl 
8567 10 ec				djnz .fb1 
8569			 
8569 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
856b			.fb2:   	 
856b e5					push hl 
856c c5					push bc 
856d d5					push de 
856e cd ab 80				call se_readbyte 
8571 d1					pop de 
8572 c1					pop bc 
8573 e1					pop hl 
8574			 
8574					; is free? 
8574			;		cp 0 
8574 b7					or a 
8575 20 01				jr nz, .ff2cont 
8577 13					inc de 
8578			 
8578			.ff2cont: 
8578			 
8578 3e 40				ld a, STORE_BLOCK_PHY 
857a cd db 8c				call addatohl 
857d 10 ec				djnz .fb2 
857f			 
857f eb				ex de, hl 
8580 c9				ret 
8581			 
8581			; Get File ID 
8581			; ----------- 
8581			; 
8581			; With current bank 
8581			;  
8581			; Load Block 0 Config 
8581			; Get max file id number 
8581			; For each logical block 
8581			;    Read block file id 
8581			;      If first block of file and dont have file id 
8581			;         if file get id and exit 
8581			 
8581			 
8581			 
8581			 
8581			; Create File 
8581			; ----------- 
8581			; 
8581			; With current bank  
8581			; Load Block 0 Config 
8581			; Get max file id number 
8581			; Increment file id number 
8581			; Save Config 
8581			; Find free block 
8581			; Set buffer with file name and file id 
8581			; Write buffer to free block  
8581			 
8581			 
8581			; hl point to file name 
8581			; hl returns file id 
8581			 
8581			; file format: 
8581			; byte 0 - file id 
8581			; byte 1 - extent number 
8581			; byte 2-> data 
8581			 
8581			; format for extent number 0: 
8581			; 
8581			; byte 0 - file id 
8581			; byte 1 - extent 0 
8581			; byte 2 - extent count 
8581			; byte 3 -> file name and meta data 
8581			 
8581			 
8581			storage_create: 
8581				if DEBUG_STORESE 
8581					DMARK "SCR" 
8581 f5				push af  
8582 3a 96 85			ld a, (.dmark)  
8585 32 5e ee			ld (debug_mark),a  
8588 3a 97 85			ld a, (.dmark+1)  
858b 32 5f ee			ld (debug_mark+1),a  
858e 3a 98 85			ld a, (.dmark+2)  
8591 32 60 ee			ld (debug_mark+2),a  
8594 18 03			jr .pastdmark  
8596 ..			.dmark: db "SCR"  
8599 f1			.pastdmark: pop af  
859a			endm  
# End of macro DMARK
859a					CALLMONITOR 
859a cd 6b ee			call debug_vector  
859d				endm  
# End of macro CALLMONITOR
859d				endif 
859d			 
859d e5				push hl		; save file name pointer 
859e			 
859e cd 35 82			call storage_get_block_0 
85a1			 
85a1 3a 6d ea			ld a,(store_page)	; get current file id 
85a4 3c				inc a 
85a5 32 6d ea			ld (store_page),a 
85a8				 
85a8 32 61 ea			ld (store_tmpid),a			; save id 
85ab			 
85ab 21 00 00			ld hl, 0 
85ae 11 6d ea			ld de, store_page 
85b1				if DEBUG_STORESE 
85b1					DMARK "SCw" 
85b1 f5				push af  
85b2 3a c6 85			ld a, (.dmark)  
85b5 32 5e ee			ld (debug_mark),a  
85b8 3a c7 85			ld a, (.dmark+1)  
85bb 32 5f ee			ld (debug_mark+1),a  
85be 3a c8 85			ld a, (.dmark+2)  
85c1 32 60 ee			ld (debug_mark+2),a  
85c4 18 03			jr .pastdmark  
85c6 ..			.dmark: db "SCw"  
85c9 f1			.pastdmark: pop af  
85ca			endm  
# End of macro DMARK
85ca					CALLMONITOR 
85ca cd 6b ee			call debug_vector  
85cd				endm  
# End of macro CALLMONITOR
85cd				endif 
85cd cd ec 81			call storage_write_block	 ; save update 
85d0			 
85d0				if DEBUG_STORESE 
85d0 11 6d ea				ld de, store_page 
85d3					DMARK "SCC" 
85d3 f5				push af  
85d4 3a e8 85			ld a, (.dmark)  
85d7 32 5e ee			ld (debug_mark),a  
85da 3a e9 85			ld a, (.dmark+1)  
85dd 32 5f ee			ld (debug_mark+1),a  
85e0 3a ea 85			ld a, (.dmark+2)  
85e3 32 60 ee			ld (debug_mark+2),a  
85e6 18 03			jr .pastdmark  
85e8 ..			.dmark: db "SCC"  
85eb f1			.pastdmark: pop af  
85ec			endm  
# End of macro DMARK
85ec					CALLMONITOR 
85ec cd 6b ee			call debug_vector  
85ef				endm  
# End of macro CALLMONITOR
85ef				endif 
85ef				;  
85ef				 
85ef 21 40 00			ld hl, STORE_BLOCK_PHY 
85f2 11 00 00			ld de, 0 
85f5 cd b3 84			call storage_findnextid 
85f8			 
85f8 22 58 ea			ld (store_tmppageid), hl    ; save page to use  
85fb			 
85fb				; TODO detect 0 = no spare blocks 
85fb			 
85fb				; hl now contains the free page to use for the file header page 
85fb			 
85fb				if DEBUG_STORESE 
85fb				DMARK "SCF" 
85fb f5				push af  
85fc 3a 10 86			ld a, (.dmark)  
85ff 32 5e ee			ld (debug_mark),a  
8602 3a 11 86			ld a, (.dmark+1)  
8605 32 5f ee			ld (debug_mark+1),a  
8608 3a 12 86			ld a, (.dmark+2)  
860b 32 60 ee			ld (debug_mark+2),a  
860e 18 03			jr .pastdmark  
8610 ..			.dmark: db "SCF"  
8613 f1			.pastdmark: pop af  
8614			endm  
# End of macro DMARK
8614					CALLMONITOR 
8614 cd 6b ee			call debug_vector  
8617				endm  
# End of macro CALLMONITOR
8617				endif 
8617			 
8617 22 58 ea			ld (store_tmppageid), hl 
861a				 
861a 3a 61 ea			ld a,(store_tmpid)    ; get file id 
861d			;	ld a, (store_filecache)			; save to cache 
861d			 
861d 32 6d ea			ld (store_page),a    ; set page id 
8620 3e 00			ld a, 0			 ; extent 0 is file header 
8622 32 6e ea			ld (store_page+1), a   ; set file extent 
8625			 
8625 32 6f ea			ld (store_page+2), a   ; extent count for the file 
8628			 
8628			;	inc hl 		; init block 0 of file 
8628			;	inc hl   		; skip file and extent id 
8628			 ;       ld a, 0 
8628			;	ld (hl),a 
8628			;	ld a, (store_filecache+1)  	; save to cache 
8628			 
8628			;	inc hl    ; file name 
8628				 
8628				 
8628 11 70 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
862b				if DEBUG_STORESE 
862b					DMARK "SCc" 
862b f5				push af  
862c 3a 40 86			ld a, (.dmark)  
862f 32 5e ee			ld (debug_mark),a  
8632 3a 41 86			ld a, (.dmark+1)  
8635 32 5f ee			ld (debug_mark+1),a  
8638 3a 42 86			ld a, (.dmark+2)  
863b 32 60 ee			ld (debug_mark+2),a  
863e 18 03			jr .pastdmark  
8640 ..			.dmark: db "SCc"  
8643 f1			.pastdmark: pop af  
8644			endm  
# End of macro DMARK
8644					CALLMONITOR 
8644 cd 6b ee			call debug_vector  
8647				endm  
# End of macro CALLMONITOR
8647				endif 
8647 e1				pop hl    ; get zero term string 
8648 e5				push hl 
8649 3e 00			ld a, 0 
864b cd 3e 90			call strlent 
864e 23				inc hl   ; cover zero term 
864f 06 00			ld b,0 
8651 4d				ld c,l 
8652 e1				pop hl 
8653				;ex de, hl 
8653				if DEBUG_STORESE 
8653					DMARK "SCa" 
8653 f5				push af  
8654 3a 68 86			ld a, (.dmark)  
8657 32 5e ee			ld (debug_mark),a  
865a 3a 69 86			ld a, (.dmark+1)  
865d 32 5f ee			ld (debug_mark+1),a  
8660 3a 6a 86			ld a, (.dmark+2)  
8663 32 60 ee			ld (debug_mark+2),a  
8666 18 03			jr .pastdmark  
8668 ..			.dmark: db "SCa"  
866b f1			.pastdmark: pop af  
866c			endm  
# End of macro DMARK
866c					;push af 
866c					;ld a, 'a' 
866c					;ld (debug_mark),a 
866c					;pop af 
866c					CALLMONITOR 
866c cd 6b ee			call debug_vector  
866f				endm  
# End of macro CALLMONITOR
866f				endif 
866f ed b0			ldir    ; copy zero term string 
8671				if DEBUG_STORESE 
8671					DMARK "SCA" 
8671 f5				push af  
8672 3a 86 86			ld a, (.dmark)  
8675 32 5e ee			ld (debug_mark),a  
8678 3a 87 86			ld a, (.dmark+1)  
867b 32 5f ee			ld (debug_mark+1),a  
867e 3a 88 86			ld a, (.dmark+2)  
8681 32 60 ee			ld (debug_mark+2),a  
8684 18 03			jr .pastdmark  
8686 ..			.dmark: db "SCA"  
8689 f1			.pastdmark: pop af  
868a			endm  
# End of macro DMARK
868a					CALLMONITOR 
868a cd 6b ee			call debug_vector  
868d				endm  
# End of macro CALLMONITOR
868d				endif 
868d			 
868d				; write file header page 
868d			 
868d 2a 58 ea			ld hl,(store_tmppageid) 
8690 11 6d ea			ld de, store_page 
8693				if DEBUG_STORESE 
8693					DMARK "SCb" 
8693 f5				push af  
8694 3a a8 86			ld a, (.dmark)  
8697 32 5e ee			ld (debug_mark),a  
869a 3a a9 86			ld a, (.dmark+1)  
869d 32 5f ee			ld (debug_mark+1),a  
86a0 3a aa 86			ld a, (.dmark+2)  
86a3 32 60 ee			ld (debug_mark+2),a  
86a6 18 03			jr .pastdmark  
86a8 ..			.dmark: db "SCb"  
86ab f1			.pastdmark: pop af  
86ac			endm  
# End of macro DMARK
86ac					;push af 
86ac					;ld a, 'b' 
86ac					;ld (debug_mark),a 
86ac					;pop af 
86ac					CALLMONITOR 
86ac cd 6b ee			call debug_vector  
86af				endm  
# End of macro CALLMONITOR
86af				endif 
86af cd ec 81			call storage_write_block 
86b2			 
86b2 3a 61 ea			ld a, (store_tmpid) 
86b5 6f				ld l, a 
86b6 26 00			ld h,0 
86b8				if DEBUG_STORESE 
86b8					DMARK "SCz" 
86b8 f5				push af  
86b9 3a cd 86			ld a, (.dmark)  
86bc 32 5e ee			ld (debug_mark),a  
86bf 3a ce 86			ld a, (.dmark+1)  
86c2 32 5f ee			ld (debug_mark+1),a  
86c5 3a cf 86			ld a, (.dmark+2)  
86c8 32 60 ee			ld (debug_mark+2),a  
86cb 18 03			jr .pastdmark  
86cd ..			.dmark: db "SCz"  
86d0 f1			.pastdmark: pop af  
86d1			endm  
# End of macro DMARK
86d1					CALLMONITOR 
86d1 cd 6b ee			call debug_vector  
86d4				endm  
# End of macro CALLMONITOR
86d4				endif 
86d4 c9				ret 
86d5				 
86d5			 
86d5			 
86d5			; 
86d5			; Read File 
86d5			; 
86d5			; h - file id to locate 
86d5			; l - extent to locate 
86d5			; de - pointer to string to read into 
86d5			; 
86d5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d5			 
86d5			.sr_fail: 
86d5 d1				pop de 
86d6 c9				ret 
86d7			 
86d7			storage_read: 
86d7			 
86d7			 
86d7 d5				push de 
86d8			 
86d8			; TODO BUG the above push is it popped before the RET Z? 
86d8			 
86d8			; TODO how to handle multiple part blocks 
86d8			 
86d8				; locate file extent to read 
86d8			 
86d8 5c				ld e, h 
86d9 55				ld d, l 
86da			 
86da			.srext: 
86da 22 6b ea			ld (store_readptr), hl     ; save the current extent to load 
86dd ed 53 69 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86e1			 
86e1 21 40 00			ld hl, STORE_BLOCK_PHY 
86e4				if DEBUG_STORESE 
86e4					DMARK "sre" 
86e4 f5				push af  
86e5 3a f9 86			ld a, (.dmark)  
86e8 32 5e ee			ld (debug_mark),a  
86eb 3a fa 86			ld a, (.dmark+1)  
86ee 32 5f ee			ld (debug_mark+1),a  
86f1 3a fb 86			ld a, (.dmark+2)  
86f4 32 60 ee			ld (debug_mark+2),a  
86f7 18 03			jr .pastdmark  
86f9 ..			.dmark: db "sre"  
86fc f1			.pastdmark: pop af  
86fd			endm  
# End of macro DMARK
86fd					CALLMONITOR 
86fd cd 6b ee			call debug_vector  
8700				endm  
# End of macro CALLMONITOR
8700				endif 
8700 cd b3 84			call storage_findnextid 
8703			 
8703				if DEBUG_STORESE 
8703					DMARK "srf" 
8703 f5				push af  
8704 3a 18 87			ld a, (.dmark)  
8707 32 5e ee			ld (debug_mark),a  
870a 3a 19 87			ld a, (.dmark+1)  
870d 32 5f ee			ld (debug_mark+1),a  
8710 3a 1a 87			ld a, (.dmark+2)  
8713 32 60 ee			ld (debug_mark+2),a  
8716 18 03			jr .pastdmark  
8718 ..			.dmark: db "srf"  
871b f1			.pastdmark: pop af  
871c			endm  
# End of macro DMARK
871c					CALLMONITOR 
871c cd 6b ee			call debug_vector  
871f				endm  
# End of macro CALLMONITOR
871f				endif 
871f cd 04 8d			call ishlzero 
8722			;	ld a, l 
8722			;	add h 
8722			;	cp 0 
8722 28 b1			jr z,.sr_fail			; block not found so EOF 
8724			 
8724				; save current address for use by higher level words etc 
8724			 
8724 22 5e ea			ld (store_openaddr),hl 
8727			 
8727			 
8727				; hl contains page number to load 
8727 d1				pop de   ; get storage 
8728 ed 53 69 ea		ld (store_readbuf), de     ; current buffer to load in to 
872c d5				push de 
872d				if DEBUG_STORESE 
872d					DMARK "srg" 
872d f5				push af  
872e 3a 42 87			ld a, (.dmark)  
8731 32 5e ee			ld (debug_mark),a  
8734 3a 43 87			ld a, (.dmark+1)  
8737 32 5f ee			ld (debug_mark+1),a  
873a 3a 44 87			ld a, (.dmark+2)  
873d 32 60 ee			ld (debug_mark+2),a  
8740 18 03			jr .pastdmark  
8742 ..			.dmark: db "srg"  
8745 f1			.pastdmark: pop af  
8746			endm  
# End of macro DMARK
8746					CALLMONITOR 
8746 cd 6b ee			call debug_vector  
8749				endm  
# End of macro CALLMONITOR
8749				endif 
8749 cd 87 81			call storage_read_block 
874c			 
874c				; if this a continuation read??? 
874c			 
874c 2a 69 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874f			 
874f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8751 cd db 8c			call addatohl 
8754 7e				ld a,(hl) 
8755			;	cp 0 
8755 b7				or a 
8756 28 02			jr z, .markiscont 
8758 3e ff			ld a, 255 
875a			 
875a			.markiscont: 
875a 32 60 ea			ld (store_readcont), a 
875d			 
875d				if DEBUG_STORESE 
875d					DMARK "srC" 
875d f5				push af  
875e 3a 72 87			ld a, (.dmark)  
8761 32 5e ee			ld (debug_mark),a  
8764 3a 73 87			ld a, (.dmark+1)  
8767 32 5f ee			ld (debug_mark+1),a  
876a 3a 74 87			ld a, (.dmark+2)  
876d 32 60 ee			ld (debug_mark+2),a  
8770 18 03			jr .pastdmark  
8772 ..			.dmark: db "srC"  
8775 f1			.pastdmark: pop af  
8776			endm  
# End of macro DMARK
8776					CALLMONITOR 
8776 cd 6b ee			call debug_vector  
8779				endm  
# End of macro CALLMONITOR
8779				endif 
8779				; only short reads enabled 
8779			 
8779 3a 68 ea			ld a, (store_longread) 
877c			;	cp 0 
877c b7				or a 
877d ca 49 88			jp z, .readdone 
8780			 
8780			; TODO if block has no zeros then need to read next block  
8780			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
8780			; check last byte of physical block. 
8780			; if not zero then the next block needs to be loaded 
8780			 
8780			 
8780 2a 69 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8783			 
8783 3e 3f			ld a, STORE_BLOCK_PHY-1 
8785 cd db 8c			call addatohl 
8788				;dec hl 
8788 7e				ld a,(hl) 
8789				if DEBUG_STORESE 
8789					DMARK "sr?" 
8789 f5				push af  
878a 3a 9e 87			ld a, (.dmark)  
878d 32 5e ee			ld (debug_mark),a  
8790 3a 9f 87			ld a, (.dmark+1)  
8793 32 5f ee			ld (debug_mark+1),a  
8796 3a a0 87			ld a, (.dmark+2)  
8799 32 60 ee			ld (debug_mark+2),a  
879c 18 03			jr .pastdmark  
879e ..			.dmark: db "sr?"  
87a1 f1			.pastdmark: pop af  
87a2			endm  
# End of macro DMARK
87a2					CALLMONITOR 
87a2 cd 6b ee			call debug_vector  
87a5				endm  
# End of macro CALLMONITOR
87a5				endif 
87a5			;	cp 0 
87a5 b7				or a 
87a6 ca 49 88			jp z, .readdone 
87a9			 
87a9				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a9			 
87a9 23				inc hl 
87aa			 
87aa 22 69 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ad			 
87ad ed 5b 6b ea		ld de, (store_readptr)     ; save the current extent to load 
87b1			 
87b1 eb				ex de, hl 
87b2			 
87b2				; next ext 
87b2			 
87b2 23				inc hl 
87b3 22 6b ea			ld  (store_readptr), hl     ; save the current extent to load 
87b6			 
87b6				if DEBUG_STORESE 
87b6					DMARK "sF2" 
87b6 f5				push af  
87b7 3a cb 87			ld a, (.dmark)  
87ba 32 5e ee			ld (debug_mark),a  
87bd 3a cc 87			ld a, (.dmark+1)  
87c0 32 5f ee			ld (debug_mark+1),a  
87c3 3a cd 87			ld a, (.dmark+2)  
87c6 32 60 ee			ld (debug_mark+2),a  
87c9 18 03			jr .pastdmark  
87cb ..			.dmark: db "sF2"  
87ce f1			.pastdmark: pop af  
87cf			endm  
# End of macro DMARK
87cf					CALLMONITOR 
87cf cd 6b ee			call debug_vector  
87d2				endm  
# End of macro CALLMONITOR
87d2				endif 
87d2			 
87d2				; get and load block 
87d2			 
87d2 cd b3 84			call storage_findnextid 
87d5			 
87d5				if DEBUG_STORESE 
87d5					DMARK "sf2" 
87d5 f5				push af  
87d6 3a ea 87			ld a, (.dmark)  
87d9 32 5e ee			ld (debug_mark),a  
87dc 3a eb 87			ld a, (.dmark+1)  
87df 32 5f ee			ld (debug_mark+1),a  
87e2 3a ec 87			ld a, (.dmark+2)  
87e5 32 60 ee			ld (debug_mark+2),a  
87e8 18 03			jr .pastdmark  
87ea ..			.dmark: db "sf2"  
87ed f1			.pastdmark: pop af  
87ee			endm  
# End of macro DMARK
87ee					CALLMONITOR 
87ee cd 6b ee			call debug_vector  
87f1				endm  
# End of macro CALLMONITOR
87f1				endif 
87f1 cd 04 8d			call ishlzero 
87f4			;	ld a, l 
87f4			;	add h 
87f4			;	cp 0 
87f4 ca d5 86			jp z,.sr_fail			; block not found so EOF 
87f7				 
87f7				; save current address for use by higher level words etc 
87f7			 
87f7 22 5e ea			ld (store_openaddr),hl 
87fa			 
87fa cd 87 81			call storage_read_block 
87fd			 
87fd				; on a continuation block, we now have the file id and ext in the middle of the block 
87fd				; we need to pull everything back  
87fd			 
87fd ed 5b 69 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
8801 2a 69 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8804 23				inc hl 
8805 23				inc hl     ; skip id and ext 
8806 01 40 00			ld bc, STORE_BLOCK_PHY 
8809				if DEBUG_STORESE 
8809					DMARK "SR<" 
8809 f5				push af  
880a 3a 1e 88			ld a, (.dmark)  
880d 32 5e ee			ld (debug_mark),a  
8810 3a 1f 88			ld a, (.dmark+1)  
8813 32 5f ee			ld (debug_mark+1),a  
8816 3a 20 88			ld a, (.dmark+2)  
8819 32 60 ee			ld (debug_mark+2),a  
881c 18 03			jr .pastdmark  
881e ..			.dmark: db "SR<"  
8821 f1			.pastdmark: pop af  
8822			endm  
# End of macro DMARK
8822					CALLMONITOR 
8822 cd 6b ee			call debug_vector  
8825				endm  
# End of macro CALLMONITOR
8825				endif 
8825 ed b0			ldir     ; copy data 
8827			 
8827				; move the pointer back and pretend we have a full buffer for next recheck 
8827			 
8827 1b				dec de 
8828 1b				dec de 
8829			 
8829			; TODO do pop below now short circuit loop????? 
8829 c1				pop bc     ; get rid of spare de on stack 
882a				if DEBUG_STORESE 
882a					DMARK "SR>" 
882a f5				push af  
882b 3a 3f 88			ld a, (.dmark)  
882e 32 5e ee			ld (debug_mark),a  
8831 3a 40 88			ld a, (.dmark+1)  
8834 32 5f ee			ld (debug_mark+1),a  
8837 3a 41 88			ld a, (.dmark+2)  
883a 32 60 ee			ld (debug_mark+2),a  
883d 18 03			jr .pastdmark  
883f ..			.dmark: db "SR>"  
8842 f1			.pastdmark: pop af  
8843			endm  
# End of macro DMARK
8843					CALLMONITOR 
8843 cd 6b ee			call debug_vector  
8846				endm  
# End of macro CALLMONITOR
8846				endif 
8846 c3 da 86			jp .srext 
8849			 
8849			 
8849			 
8849			 
8849			 
8849			.readdone:		 
8849 e1				pop hl 		 ; return start of data to show as not EOF 
884a 23				inc hl   ; past file id 
884b 23				inc hl   ; past ext 
884c				if DEBUG_STORESE 
884c					DMARK "SRe" 
884c f5				push af  
884d 3a 61 88			ld a, (.dmark)  
8850 32 5e ee			ld (debug_mark),a  
8853 3a 62 88			ld a, (.dmark+1)  
8856 32 5f ee			ld (debug_mark+1),a  
8859 3a 63 88			ld a, (.dmark+2)  
885c 32 60 ee			ld (debug_mark+2),a  
885f 18 03			jr .pastdmark  
8861 ..			.dmark: db "SRe"  
8864 f1			.pastdmark: pop af  
8865			endm  
# End of macro DMARK
8865					CALLMONITOR 
8865 cd 6b ee			call debug_vector  
8868				endm  
# End of macro CALLMONITOR
8868				endif 
8868 c9					ret 
8869			 
8869			 
8869			 
8869			; 
8869			; Append File 
8869			; 
8869			; hl - file id to locate 
8869			; de - pointer to (multi block) string to write 
8869			 
8869			.sa_notfound: 
8869 d1				pop de 
886a c9				ret 
886b			 
886b			 
886b			storage_append: 
886b				; hl -  file id to append to 
886b				; de - string to append 
886b			 
886b d5				push de 
886c				 
886c				if DEBUG_STORESE 
886c					DMARK "AP1" 
886c f5				push af  
886d 3a 81 88			ld a, (.dmark)  
8870 32 5e ee			ld (debug_mark),a  
8873 3a 82 88			ld a, (.dmark+1)  
8876 32 5f ee			ld (debug_mark+1),a  
8879 3a 83 88			ld a, (.dmark+2)  
887c 32 60 ee			ld (debug_mark+2),a  
887f 18 03			jr .pastdmark  
8881 ..			.dmark: db "AP1"  
8884 f1			.pastdmark: pop af  
8885			endm  
# End of macro DMARK
8885					CALLMONITOR 
8885 cd 6b ee			call debug_vector  
8888				endm  
# End of macro CALLMONITOR
8888				endif 
8888			 
8888 7d				ld a, l 
8889 32 61 ea			ld (store_tmpid), a 
888c			 
888c				; get file header  
888c			 
888c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888e 3a 61 ea			ld a, (store_tmpid) 
8891 5f				ld e, a 
8892			 
8892 21 40 00				ld hl, STORE_BLOCK_PHY 
8895 cd b3 84				call storage_findnextid 
8898			 
8898 cd 04 8d			call ishlzero 
889b 28 cc			jr z, .sa_notfound 
889d			 
889d 22 58 ea			ld (store_tmppageid), hl 
88a0			 
88a0				; TODO handle file id not found 
88a0			 
88a0				if DEBUG_STORESE 
88a0					DMARK "AP2" 
88a0 f5				push af  
88a1 3a b5 88			ld a, (.dmark)  
88a4 32 5e ee			ld (debug_mark),a  
88a7 3a b6 88			ld a, (.dmark+1)  
88aa 32 5f ee			ld (debug_mark+1),a  
88ad 3a b7 88			ld a, (.dmark+2)  
88b0 32 60 ee			ld (debug_mark+2),a  
88b3 18 03			jr .pastdmark  
88b5 ..			.dmark: db "AP2"  
88b8 f1			.pastdmark: pop af  
88b9			endm  
# End of macro DMARK
88b9					CALLMONITOR 
88b9 cd 6b ee			call debug_vector  
88bc				endm  
# End of macro CALLMONITOR
88bc				endif 
88bc			 
88bc				; update file extent count 
88bc			 
88bc 11 6d ea			ld de, store_page 
88bf			 
88bf cd 87 81			call storage_read_block 
88c2			 
88c2				if DEBUG_STORESE 
88c2					DMARK "AP3" 
88c2 f5				push af  
88c3 3a d7 88			ld a, (.dmark)  
88c6 32 5e ee			ld (debug_mark),a  
88c9 3a d8 88			ld a, (.dmark+1)  
88cc 32 5f ee			ld (debug_mark+1),a  
88cf 3a d9 88			ld a, (.dmark+2)  
88d2 32 60 ee			ld (debug_mark+2),a  
88d5 18 03			jr .pastdmark  
88d7 ..			.dmark: db "AP3"  
88da f1			.pastdmark: pop af  
88db			endm  
# End of macro DMARK
88db					CALLMONITOR 
88db cd 6b ee			call debug_vector  
88de				endm  
# End of macro CALLMONITOR
88de				endif 
88de			;	ld (store_tmppageid), hl 
88de			 
88de 3a 6f ea			ld a, (store_page+2) 
88e1 3c				inc a 
88e2 32 6f ea			ld (store_page+2), a 
88e5 32 60 ea			ld (store_tmpext), a 
88e8				 
88e8				if DEBUG_STORESE 
88e8					DMARK "AP3" 
88e8 f5				push af  
88e9 3a fd 88			ld a, (.dmark)  
88ec 32 5e ee			ld (debug_mark),a  
88ef 3a fe 88			ld a, (.dmark+1)  
88f2 32 5f ee			ld (debug_mark+1),a  
88f5 3a ff 88			ld a, (.dmark+2)  
88f8 32 60 ee			ld (debug_mark+2),a  
88fb 18 03			jr .pastdmark  
88fd ..			.dmark: db "AP3"  
8900 f1			.pastdmark: pop af  
8901			endm  
# End of macro DMARK
8901					CALLMONITOR 
8901 cd 6b ee			call debug_vector  
8904				endm  
# End of macro CALLMONITOR
8904				endif 
8904 2a 58 ea			ld hl, (store_tmppageid) 
8907 11 6d ea			ld de, store_page 
890a cd ec 81			call storage_write_block 
890d			 
890d				; find free block 
890d			 
890d 11 00 00			ld de, 0			 ; file extent to locate 
8910			 
8910 21 40 00				ld hl, STORE_BLOCK_PHY 
8913 cd b3 84				call storage_findnextid 
8916 cd 04 8d			call ishlzero 
8919 ca 69 88			jp z, .sa_notfound 
891c			 
891c					; TODO handle no space left 
891c					 
891c 22 58 ea				ld (store_tmppageid), hl 
891f			 
891f				if DEBUG_STORESE 
891f					DMARK "AP4" 
891f f5				push af  
8920 3a 34 89			ld a, (.dmark)  
8923 32 5e ee			ld (debug_mark),a  
8926 3a 35 89			ld a, (.dmark+1)  
8929 32 5f ee			ld (debug_mark+1),a  
892c 3a 36 89			ld a, (.dmark+2)  
892f 32 60 ee			ld (debug_mark+2),a  
8932 18 03			jr .pastdmark  
8934 ..			.dmark: db "AP4"  
8937 f1			.pastdmark: pop af  
8938			endm  
# End of macro DMARK
8938					CALLMONITOR 
8938 cd 6b ee			call debug_vector  
893b				endm  
# End of macro CALLMONITOR
893b				endif 
893b					; init the buffer with zeros so we can id if the buffer is full or not 
893b			 
893b e5					push hl 
893c c5					push bc 
893d			 
893d 21 6d ea				ld hl, store_page 
8940 06 40				ld b, STORE_BLOCK_PHY 
8942			;		ld a, 0 
8942 36 00		.zeroblock:	ld (hl), 0 
8944 23					inc hl 
8945 10 fb				djnz .zeroblock 
8947			 
8947 c1					pop bc 
8948 e1					pop hl 
8949			 
8949					; construct block 
8949			 
8949 3a 61 ea				ld a, (store_tmpid) 
894c 32 6d ea				ld (store_page), a   ; file id 
894f 3a 60 ea				ld a, (store_tmpext)   ; extent for this block 
8952 32 6e ea				ld (store_page+1), a 
8955			 
8955 e1					pop hl    ; get string to write 
8956 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8958 11 6f ea				ld de, store_page+2 
895b			 
895b				if DEBUG_STORESE 
895b					DMARK "AP5" 
895b f5				push af  
895c 3a 70 89			ld a, (.dmark)  
895f 32 5e ee			ld (debug_mark),a  
8962 3a 71 89			ld a, (.dmark+1)  
8965 32 5f ee			ld (debug_mark+1),a  
8968 3a 72 89			ld a, (.dmark+2)  
896b 32 60 ee			ld (debug_mark+2),a  
896e 18 03			jr .pastdmark  
8970 ..			.dmark: db "AP5"  
8973 f1			.pastdmark: pop af  
8974			endm  
# End of macro DMARK
8974					CALLMONITOR 
8974 cd 6b ee			call debug_vector  
8977				endm  
# End of macro CALLMONITOR
8977				endif 
8977			 
8977			 
8977			 
8977					; fill buffer with data until end of string or full block 
8977			 
8977 7e			.appd:		ld a, (hl) 
8978 12					ld (de), a 
8979			;		cp 0 
8979 b7					or a 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f7				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 58 ea			ld hl, (store_tmppageid) 
8985 11 6d ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 5e ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 5f ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 60 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6b ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd ec 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9					;cp 0		 ; no, string was fully written 
89a9 b7					or a 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 61 ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 6b 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4			;		ld a,0 
89b4			.src:		ld (hl),0 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4			;	ld a, 0 
89b4				ld (hl),0 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 6d ea			ld hl, store_page 
89ba			;	ld a, 0 
89ba 36 00			ld (hl), 0 
89bc			 
89bc 11 6e ea			ld de, store_page+1 
89bf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c2			 
89c2 ed b0			ldir 
89c4				 
89c4 c1				pop bc 
89c5 d1				pop de 
89c6 e1				pop hl 
89c7 c9				ret 
89c8			 
89c8			; eof 
# End of file firmware_storage.asm
89c8			  
89c8			; support routines for above hardware abstraction layer  
89c8			  
89c8			include "firmware_general.asm"        ; general support functions  
89c8			 
89c8			; word look up 
89c8			 
89c8			; in 
89c8			; a is the index 
89c8			; hl is pointer start of array 
89c8			; 
89c8			; returns 
89c8			; hl to the word 
89c8			; 
89c8			 
89c8			table_lookup:  
89c8 d5					push de 
89c9 eb					ex de, hl 
89ca			 
89ca 6f					ld l, a 
89cb 26 00				ld h, 0 
89cd 29					add hl, hl 
89ce 19					add hl, de 
89cf 7e					ld a, (hl) 
89d0 23					inc hl 
89d1 66					ld h,(hl) 
89d2 6f					ld l, a 
89d3			 
89d3 d1					pop de 
89d4 c9					ret 
89d5			 
89d5			; Delay loops 
89d5			 
89d5			 
89d5			 
89d5			aDelayInMS: 
89d5 c5				push bc 
89d6 47				ld b,a 
89d7			msdelay: 
89d7 c5				push bc 
89d8				 
89d8			 
89d8 01 41 00			ld bc,041h 
89db cd f3 89			call delayloop 
89de c1				pop bc 
89df 05				dec b 
89e0 20 f5			jr nz,msdelay 
89e2			 
89e2			;if CPU_CLOCK_8MHZ 
89e2			;msdelay8: 
89e2			;	push bc 
89e2			;	 
89e2			; 
89e2			;	ld bc,041h 
89e2			;	call delayloop 
89e2			;	pop bc 
89e2			;	dec b 
89e2			;	jr nz,msdelay8 
89e2			;endif 
89e2			 
89e2			 
89e2 c1				pop bc 
89e3 c9				ret 
89e4			 
89e4			 
89e4			delay250ms: 
89e4				;push de 
89e4 01 00 40			ld bc, 04000h 
89e7 c3 f3 89			jp delayloop 
89ea			delay500ms: 
89ea				;push de 
89ea 01 00 80			ld bc, 08000h 
89ed c3 f3 89			jp delayloop 
89f0			delay1s: 
89f0				;push bc 
89f0			   ; Clobbers A, d and e 
89f0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f3			delayloop: 
89f3 c5			    push bc 
89f4			 
89f4			if BASE_CPM 
89f4				ld bc, CPM_DELAY_TUNE 
89f4			.cpmloop: 
89f4				push bc 
89f4			 
89f4			endif 
89f4			 
89f4			 
89f4			 
89f4			delayloopi: 
89f4			;	push bc 
89f4			;.dl: 
89f4 cb 47		    bit     0,a    	; 8 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa e6 ff		    and     255  	; 7 
89fc 0b			    dec     bc      	; 6 
89fd 79			    ld      a,c     	; 4 
89fe b0			    or      b     	; 4 
89ff c2 f4 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a02			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a02				;pop de 
8a02			;pop bc 
8a02			 
8a02			if BASE_CPM 
8a02				pop bc 
8a02				 
8a02			    dec     bc      	; 6 
8a02			    ld      a,c     	; 4 
8a02			    or      b     	; 4 
8a02			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a02				 
8a02			 
8a02			endif 
8a02			;if CPU_CLOCK_8MHZ 
8a02			;    pop bc 
8a02			;    push bc 
8a02			;.dl8: 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    and     255  	; 7 
8a02			;    dec     bc      	; 6 
8a02			;    ld      a,c     	; 4 
8a02			;    or      b     	; 4 
8a02			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a02			;endif 
8a02			 
8a02			;if CPU_CLOCK_10MHZ 
8a02			;    pop bc 
8a02			;    push bc 
8a02			;.dl8: 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    and     255  	; 7 
8a02			;    dec     bc      	; 6 
8a02			;    ld      a,c     	; 4 
8a02			;    or      b     	; 4 
8a02			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a02			;endif 
8a02 c1			    pop bc 
8a03			 
8a03 c9				ret 
8a04			 
8a04			; look for any ldir blank calls and replace with 
8a04			; hl is the start address 
8a04			; b is the number of bytes 
8a04			; a is the char to fill 
8a04			 
8a04			 
8a04			filllen: 
8a04 77				LD (HL),A      ;STORE BYTE 
8a05 23				INC HL      ; BUMP POINTER 
8a06 10 fc			DJNZ   filllen      ;  CONTINUE IF B NOT 0 
8a08 c9				ret 
8a09			 
8a09			; eof 
# End of file firmware_general.asm
8a09			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a09			; display routines that use the physical hardware abstraction layer 
8a09			 
8a09			 
8a09			; Display an activity indicator 
8a09			; Each call returns the new char pointed to in hl 
8a09			 
8a09			active: 
8a09 3a b9 eb			ld a, (display_active) 
8a0c fe 06			cp 6 
8a0e			 
8a0e 20 02			jr nz, .sne 
8a10				; gone past the last one reset sequence 
8a10 3e ff			ld a, 255 
8a12			 
8a12			.sne:   
8a12				; get the next char in seq 
8a12 3c				inc a 
8a13 32 b9 eb			ld (display_active), a 
8a16			 
8a16				; look up the string in the table 
8a16 21 2d 8a			ld hl, actseq 
8a19 cb 27			sla a 
8a1b cd db 8c			call addatohl 
8a1e cd 35 9d			call loadwordinhl 
8a21			 
8a21				; forth will write the to string when pushing so move from rom to ram 
8a21			 
8a21 11 ba eb			ld de, display_active+1 
8a24 01 02 00			ld bc, 2 
8a27 ed b0			ldir 
8a29			 
8a29 21 ba eb			ld hl, display_active+1 
8a2c c9				ret 
8a2d				 
8a2d				 
8a2d			 
8a2d			 
8a2d			;db "|/-\|-\" 
8a2d			 
8a2d			actseq: 
8a2d			 
8a2d 3b 8a		dw spin0 
8a2f 3d 8a		dw spin1 
8a31 3f 8a		dw spin2 
8a33 41 8a		dw spin3 
8a35 3f 8a		dw spin2 
8a37 3d 8a		dw spin1 
8a39 3b 8a		dw spin0 
8a3b			 
8a3b .. 00		spin0: db " ", 0 
8a3d .. 00		spin1: db "-", 0 
8a3f .. 00		spin2: db "+", 0 
8a41 .. 00		spin3: db "#", 0 
8a43			 
8a43			 
8a43			; information window 
8a43			 
8a43			; pass hl with 1st string to display 
8a43			; pass de with 2nd string to display 
8a43			 
8a43			info_panel: 
8a43 e5				push hl 
8a44			 
8a44 2a bf eb			ld hl, (display_fb_active) 
8a47 e5				push hl    ; future de destination 
8a48 21 a4 ed				ld hl, display_fb0 
8a4b 22 bf eb				ld (display_fb_active), hl 
8a4e			 
8a4e			;	call clear_display 
8a4e			 
8a4e				if BASE_CPM 
8a4e				ld a, '.' 
8a4e				else 
8a4e 3e a5			ld a, 165 
8a50				endif 
8a50 cd b6 8a			call fill_display 
8a53			 
8a53			 
8a53 3e 55			ld a, display_row_3 + 5 
8a55 cd c3 8a			call str_at_display 
8a58			 
8a58 e1				pop hl 
8a59 d1				pop de 
8a5a			 
8a5a e5				push hl 
8a5b			 
8a5b			 
8a5b 3e 2d			ld a, display_row_2 + 5 
8a5d cd c3 8a			call str_at_display 
8a60			 
8a60			 
8a60 cd d3 8a			call update_display 
8a63 cd 44 99			call next_page_prompt 
8a66 cd b1 8a			call clear_display 
8a69			 
8a69				 
8a69 21 03 ed				ld hl, display_fb1 
8a6c 22 bf eb				ld (display_fb_active), hl 
8a6f cd d3 8a			call update_display 
8a72			 
8a72 e1				pop hl 
8a73			 
8a73 c9				ret 
8a74			 
8a74			 
8a74			 
8a74			 
8a74			; TODO windowing? 
8a74			 
8a74			; TODO scroll line up 
8a74			 
8a74			scroll_up: 
8a74			 
8a74 e5				push hl 
8a75 d5				push de 
8a76 c5				push bc 
8a77			 
8a77				; get frame buffer  
8a77			 
8a77 2a bf eb			ld hl, (display_fb_active) 
8a7a e5				push hl    ; future de destination 
8a7b			 
8a7b 11 28 00			ld  de, display_cols 
8a7e 19				add hl, de 
8a7f			 
8a7f d1				pop de 
8a80			 
8a80				;ex de, hl 
8a80 01 9f 00			ld bc, display_fb_len -1  
8a83			;if DEBUG_FORTH_WORDS 
8a83			;	DMARK "SCL" 
8a83			;	CALLMONITOR 
8a83			;endif	 
8a83 ed b0			ldir 
8a85			 
8a85				; wipe bottom row 
8a85			 
8a85			 
8a85 2a bf eb			ld hl, (display_fb_active) 
8a88 11 a0 00			ld de, display_cols*display_rows 
8a8b 19				add hl, de 
8a8c 06 28			ld b, display_cols 
8a8e			;	ld a, ' ' 
8a8e			.scwipe: 
8a8e 36 20			ld (hl), ' ' 
8a90 2b				dec hl 
8a91 10 fb			djnz .scwipe 
8a93			 
8a93				;pop hl 
8a93			 
8a93 c1				pop bc 
8a94 d1				pop de 
8a95 e1				pop hl 
8a96			 
8a96 c9				ret 
8a97			 
8a97			 
8a97			;scroll_upo: 
8a97			;	ld de, display_row_1 
8a97			 ;	ld hl, display_row_2 
8a97			;	ld bc, display_cols 
8a97			;	ldir 
8a97			;	ld de, display_row_2 
8a97			 ;	ld hl, display_row_3 
8a97			;	ld bc, display_cols 
8a97			;	ldir 
8a97			;	ld de, display_row_3 
8a97			 ;	ld hl, display_row_4 
8a97			;	ld bc, display_cols 
8a97			;	ldir 
8a97			 
8a97			; TODO clear row 4 
8a97			 
8a97			;	ret 
8a97			 
8a97				 
8a97			scroll_down: 
8a97			 
8a97 e5				push hl 
8a98 d5				push de 
8a99 c5				push bc 
8a9a			 
8a9a				; get frame buffer  
8a9a			 
8a9a 2a bf eb			ld hl, (display_fb_active) 
8a9d			 
8a9d 11 9f 00			ld de, display_fb_len - 1 
8aa0 19				add hl, de 
8aa1			 
8aa1 e5			push hl    ; future de destination 
8aa2			 
8aa2 11 28 00			ld  de, display_cols 
8aa5 ed 52			sbc hl, de 
8aa7			 
8aa7			 
8aa7 d1				pop de 
8aa8			 
8aa8			;	ex de, hl 
8aa8 01 9f 00			ld bc, display_fb_len -1  
8aab			 
8aab			 
8aab				 
8aab			 
8aab ed b0			ldir 
8aad			 
8aad				; wipe bottom row 
8aad			 
8aad			 
8aad			;	ld hl, (display_fb_active) 
8aad			;;	ld de, display_cols*display_rows 
8aad			;;	add hl, de 
8aad			;	ld b, display_cols 
8aad			;	ld a, ' ' 
8aad			;.scwiped: 
8aad			;	ld (hl), a 
8aad			;	dec hl 
8aad			;	djnz .scwiped 
8aad			 
8aad				;pop hl 
8aad			 
8aad c1				pop bc 
8aae d1				pop de 
8aaf e1				pop hl 
8ab0			 
8ab0 c9				ret 
8ab1			;scroll_down: 
8ab1			;	ld de, display_row_4 
8ab1			;	ld hl, display_row_3 
8ab1			;	ld bc, display_cols 
8ab1			;	ldir 
8ab1			;	ld de, display_row_3 
8ab1			; 	ld hl, display_row_2 
8ab1			;	ld bc, display_cols 
8ab1			;	ldir 
8ab1			;	ld de, display_row_2 
8ab1			;	ld hl, display_row_1 
8ab1			;	ld bc, display_cols 
8ab1			;	ldir 
8ab1			;;; TODO clear row 1 
8ab1			;	ret 
8ab1			 
8ab1			 
8ab1			 
8ab1			 
8ab1			 
8ab1			; clear active frame buffer 
8ab1			 
8ab1			clear_display: 
8ab1 3e 20			ld a, ' ' 
8ab3 c3 b6 8a			jp fill_display 
8ab6			 
8ab6			; fill active frame buffer with a char in A 
8ab6			 
8ab6			fill_display: 
8ab6 06 a0			ld b,display_fb_len 
8ab8 2a bf eb			ld hl, (display_fb_active) 
8abb 77			.fd1:	ld (hl),a 
8abc 23				inc hl 
8abd 10 fc			djnz .fd1 
8abf 23				inc hl 
8ac0			;	ld a,0 
8ac0 36 00			ld (hl),0 
8ac2			 
8ac2			 
8ac2 c9				ret 
8ac3			; Write string (DE) at pos (A) to active frame buffer 
8ac3			 
8ac3 2a bf eb		str_at_display:    ld hl,(display_fb_active) 
8ac6 06 00					ld b,0 
8ac8 4f					ld c,a 
8ac9 09					add hl,bc 
8aca 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8acb b7			            OR   A              ;Null terminator? 
8acc c8			            RET  Z              ;Yes, so finished 
8acd 77					ld (hl),a 
8ace 23				inc hl 
8acf 13			            INC  DE             ;Point to next character 
8ad0 18 f8		            JR   .sad1     ;Repeat 
8ad2 c9					ret 
8ad3			 
8ad3			; using current frame buffer write to physical display 
8ad3			 
8ad3			update_display: 
8ad3 e5				push hl 
8ad4 2a bf eb			ld hl, (display_fb_active) 
8ad7 cd 92 e5			call write_display 
8ada e1				pop hl 
8adb c9				ret 
8adc			 
8adc			; TODO scrolling 
8adc			 
8adc			 
8adc			; move cursor right one char 
8adc			cursor_right: 
8adc			 
8adc				; TODO shift right 
8adc				; TODO if beyond max col 
8adc				; TODO       cursor_next_line 
8adc			 
8adc c9				ret 
8add			 
8add			 
8add			cursor_next_line: 
8add				; TODO first char 
8add				; TODO line down 
8add				; TODO if past last row 
8add				; TODO    scroll up 
8add			 
8add c9				ret 
8ade			 
8ade			cursor_left: 
8ade				; TODO shift left 
8ade				; TODO if beyond left  
8ade				; TODO     cursor prev line 
8ade				 
8ade c9				ret 
8adf			 
8adf			cursor_prev_line: 
8adf				; TODO last char 
8adf				; TODO line up 
8adf				; TODO if past first row 
8adf				; TODO   scroll down 
8adf			 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			cout: 
8ae0				; A - char 
8ae0 c9				ret 
8ae1			 
8ae1			 
8ae1			; Display a menu and allow item selection (optional toggle items) 
8ae1			; 
8ae1			; format: 
8ae1			; hl pointer to word array with zero term for items 
8ae1			; e.g.    db item1 
8ae1			;         db .... 
8ae1			;         db 0 
8ae1			; 
8ae1			; a = starting menu item  
8ae1			; 
8ae1			; de = pointer item toggle array   (todo) 
8ae1			; 
8ae1			; returns item selected in a 1-... 
8ae1			; returns 0 if back button pressed 
8ae1			; 
8ae1			; NOTE: Uses system frame buffer to display 
8ae1			; 
8ae1			; LEFT, Q = go back 
8ae1			; RIGHT, SPACE, CR = select 
8ae1			; UP, A - Up 
8ae1			; DOWN, Z - Down 
8ae1			 
8ae1			 
8ae1			 
8ae1			 
8ae1			 
8ae1			menu: 
8ae1			 
8ae1					; keep array pointer 
8ae1			 
8ae1 22 66 ea				ld (store_tmp1), hl 
8ae4 32 64 ea				ld (store_tmp2), a 
8ae7			 
8ae7					; check for key bounce 
8ae7			 
8ae7			if BASE_KEV 
8ae7			 
8ae7			.mbounce:	call cin 
8ae7			;		cp 0 
8ae7					or a 
8ae7					jr nz, .mbounce 
8ae7			endif 
8ae7					; for ease use ex 
8ae7			 
8ae7					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae7 21 a4 ed				ld hl, display_fb0 
8aea 22 bf eb				ld (display_fb_active), hl 
8aed			 
8aed cd b1 8a		.mloop:		call clear_display 
8af0 cd d3 8a				call update_display 
8af3			 
8af3					; draw selection id '>' at 1 
8af3			 
8af3					; init start of list display 
8af3			 
8af3 3e 05				ld a, 5 
8af5 32 62 ea				ld (store_tmp3), a   ; display row count 
8af8 3a 64 ea				ld a,( store_tmp2) 
8afb 32 65 ea				ld (store_tmp2+1), a   ; display item count 
8afe			 
8afe					 
8afe			.mitem:	 
8afe			 
8afe			 
8afe 3a 65 ea				ld a,(store_tmp2+1) 
8b01 6f					ld l, a 
8b02 26 00				ld h, 0 
8b04 29					add hl, hl 
8b05 ed 5b 66 ea			ld de, (store_tmp1) 
8b09 19					add hl, de 
8b0a 7e					ld a, (hl) 
8b0b 23					inc hl 
8b0c 66					ld h,(hl) 
8b0d 6f					ld l, a 
8b0e			 
8b0e cd 04 8d				call ishlzero 
8b11 28 1a				jr z, .mdone 
8b13			 
8b13 eb					ex de, hl 
8b14 3a 62 ea				ld a, (store_tmp3) 
8b17 cd c3 8a				call str_at_display 
8b1a					 
8b1a			 
8b1a					; next item 
8b1a 3a 65 ea				ld a, (store_tmp2+1) 
8b1d 3c					inc a 
8b1e 32 65 ea				ld (store_tmp2+1), a   ; display item count 
8b21			 
8b21			 		; next row 
8b21			 
8b21 3a 62 ea				ld a, (store_tmp3) 
8b24 c6 28				add display_cols 
8b26 32 62 ea				ld (store_tmp3), a 
8b29			 
8b29					; at end of screen? 
8b29			 
8b29 fe 10				cp display_rows*4 
8b2b 20 d1				jr nz, .mitem 
8b2d			 
8b2d			 
8b2d			.mdone: 
8b2d cd 04 8d				call ishlzero 
8b30 28 08				jr z, .nodn 
8b32			 
8b32 3e 78				ld a, display_row_4 
8b34 11 b1 8b				ld de, .mdown 
8b37 cd c3 8a				call str_at_display 
8b3a			 
8b3a					; draw options to fill the screens with active item on line 1 
8b3a					; if current option is 2 or more then display ^ in top 
8b3a			 
8b3a 3a 64 ea		.nodn:		ld a, (store_tmp2) 
8b3d			;		cp 0 
8b3d b7					or a 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 af 8b				ld de, .mup 
8b45 cd c3 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ad 8b				ld de, .msel 
8b4d cd c3 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d3 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 27 e6				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 31				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2d				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 33				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 2f				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2b				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ed 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1c			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 64 ea				ld a, (store_tmp2) 
8b88			;		cp 0 
8b88 b7					or a 
8b89 ca ed 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 64 ea				ld (store_tmp2), a 
8b90 c3 ed 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 64 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 64 ea				ld (store_tmp2), a 
8b9a c3 ed 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 64 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 03 ed				ld hl, display_fb1 
8ba5 22 bf eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d3 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a 9e eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 9e eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 a4 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 a6 eb		        ld hl,LFSRSeed+6 
8bf8 11 a7 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a 98 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 98 eb		    ld (seed1),hl 
8c0e 2a 96 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 96 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a 9c eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 9c eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored and edited directly 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO use LCD cursor? 
8d08			 
8d08			EDIT_V1: equ 0 
8d08			EDIT_V2: equ 1 
8d08			 
8d08			 
8d08			 
8d08			if EDIT_V2 
8d08			input_str: 
8d08			 
8d08 32 57 ee			    	ld (input_at_pos),a      ; save display position to start 
8d0b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d0b 22 5a ee				ld (input_start), hl     ; save ptr to buffer 
8d0e			;		ld a, c 
8d0e			;		call addatohl 
8d0e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d0e 7a					ld a,d 
8d0f 32 59 ee			        ld (input_size), a       ; save length of input area 
8d12 79					ld a, c 
8d13 32 48 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d16 7b					ld a,e 
8d17 32 58 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d1a			 
8d1a			 
8d1a					; add a trailing space to make screen refresh nicer 
8d1a			 
8d1a					;ld hl, (input_start) 
8d1a					;push hl 
8d1a					;ld a, 0 
8d1a					;call strlent 
8d1a					;ld a, l 
8d1a					;pop hl 
8d1a					;call addatohl 
8d1a					;dec hl 
8d1a					;ld a, ' ' 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld a, 0 
8d1a					;ld (hl), a 
8d1a			 
8d1a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d1a					; init cursor shape if not set by the cin routines 
8d1a 21 b4 eb				ld hl, cursor_shape 
8d1d			if BASE_KEV 
8d1d			;		ld a, 255 
8d1d					ld (hl), 255 
8d1d			else 
8d1d					;ld a, '#' 
8d1d 36 23				ld (hl), '#' 
8d1f			endif 
8d1f 23					inc hl 
8d20			;		ld a, 0 
8d20 36 00				ld (hl), 0 
8d22			 
8d22 3e 09				ld a, CUR_BLINK_RATE 
8d24 32 53 ee				ld (input_cur_flash), a 
8d27 3e 01				ld a, 1 
8d29 32 52 ee				ld (input_cur_onoff),a 
8d2c			.inmain:	 
8d2c			 
8d2c cd 4d 8e				call input_disp_ref 
8d2f			 
8d2f					; save current length of string 
8d2f			 
8d2f 2a 5a ee				ld hl, (input_start) 
8d32 3e 00				ld a, 0 
8d34 cd 3e 90				call strlent 
8d37 7d					ld a,l 
8d38 32 4d ee				ld (input_len), a 
8d3b			 
8d3b					;call input_disp_oncur 
8d3b			 
8d3b					; display current state of input buffer 
8d3b			 
8d3b					; clean any backspace chars 
8d3b			 
8d3b 3e 20				ld a, " " 
8d3d 32 b4 e2				ld (scratch),a 
8d40 3e 00				ld a, 0 
8d42 32 b5 e2				ld (scratch+1),a 
8d45 3a 57 ee				ld a,(input_at_pos) 
8d48 85					add l 
8d49 11 b4 e2				ld de, scratch 
8d4c cd c3 8a				call str_at_display 
8d4f			 
8d4f					; pause 1ms 
8d4f			 
8d4f 3e 01				ld a, 1 
8d51 cd d5 89				call aDelayInMS 
8d54			 
8d54			; display cursor if visible on this cycle 
8d54			 
8d54					; dec flash counter 
8d54 3a 53 ee				ld a, (input_cur_flash) 
8d57 3d					dec a 
8d58 32 53 ee				ld (input_cur_flash), a 
8d5b			;		cp 0 
8d5b b7					or a 
8d5c 20 0d				jr nz, .inochgstate 
8d5e			 
8d5e			 
8d5e					; reset on change of state 
8d5e 3e 09				ld a, CUR_BLINK_RATE 
8d60 32 53 ee				ld (input_cur_flash), a 
8d63			 
8d63					; change state 
8d63 3a 52 ee				ld a,(input_cur_onoff) 
8d66 ed 44				neg 
8d68 32 52 ee				ld (input_cur_onoff),a 
8d6b			 
8d6b			 
8d6b			 
8d6b			 
8d6b					; TODO is cursor visible? 
8d6b					; TODO if so then over write the char at curspos pos with the cursor shape 
8d6b			 
8d6b								 
8d6b			 
8d6b			.inochgstate: 
8d6b 3a 52 ee				ld a,(input_cur_onoff) 
8d6e fe ff				cp 255 
8d70 28 0e				jr z, .skipcursor 
8d72 3a 57 ee				ld a, (input_at_pos) 
8d75 47					ld b, a 
8d76 3a 48 ee				ld a, (input_cursor) 
8d79 80					add b 
8d7a 11 b4 eb				ld de, cursor_shape 
8d7d					 
8d7d cd c3 8a				call str_at_display 
8d80			 
8d80			.skipcursor: 
8d80				if DEBUG_INPUTV2 
8d80			 
8d80					ld a,(input_at_pos) 
8d80					ld hl, LFSRSeed 
8d80					call hexout 
8d80					ld a, (input_cursor) 
8d80					ld hl, LFSRSeed+2 
8d80					call hexout 
8d80					ld a,(input_size) 
8d80					ld hl, LFSRSeed+4 
8d80					call hexout 
8d80			 
8d80					ld a,(input_cur_onoff) 
8d80					ld hl, LFSRSeed+6 
8d80					call hexout 
8d80			 
8d80					ld a,(input_cur_flash) 
8d80					ld hl, LFSRSeed+8 
8d80					call hexout 
8d80			 
8d80					ld a,(input_len) 
8d80					ld hl, LFSRSeed+10 
8d80					call hexout 
8d80					ld hl, LFSRSeed+12 
8d80			;		ld a, 0 
8d80					ld (hl),0 
8d80					ld a, display_row_4 
8d80					ld de, LFSRSeed 
8d80					call str_at_display 
8d80				endif 
8d80 cd d3 8a				call update_display 
8d83			 
8d83					; TODO keyboard processing 
8d83			 
8d83			if BASE_CPM 
8d83					call cin_wait 
8d83			else 
8d83 cd 2d e6				call cin    ; _wait 
8d86			endif 
8d86			;		cp 0 
8d86 b7					or a 
8d87 ca 2c 8d				jp z, .inmain 
8d8a			 
8d8a			 
8d8a					; TODO handle macro 
8d8a			 
8d8a			 
8d8a			 
8d8a fe 0b				cp KEY_LEFT    ; cursor left 
8d8c ca 3f 8e				jp z, input_left 
8d8f				 
8d8f fe 0c				cp KEY_RIGHT      ; cursor right 
8d91 ca 46 8e				jp z, input_right 
8d94			 
8d94 fe 0d				cp KEY_CR 
8d96 c8					ret z 
8d97			 
8d97 fe 08				cp KEY_BS 
8d99 ca b1 8e				jp z, input_delchar 
8d9c			 
8d9c fe 06				cp KEY_NEXTWORD 
8d9e ca c5 8d				jp z, input_nxtword 
8da1			 
8da1 fe 07				cp KEY_PREVWORD 
8da3 ca ea 8d				jp z, input_prvword 
8da6			 
8da6 fe 0e				cp KEY_HOME    ; jump to start of line 
8da8 20 08				jr nz, .ikh 
8daa 3e 00				ld a, 0 
8dac 32 48 ee				ld (input_cursor), a 
8daf ca 2c 8d				jp z, .inmain 
8db2			.ikh: 
8db2			 
8db2 fe 0f				cp KEY_END     ; jump to end of line 
8db4 20 09				jr nz, .ike 
8db6 3a 4d ee				ld a, (input_len) 
8db9 32 48 ee				ld (input_cursor),a 
8dbc ca 2c 8d				jp z, .inmain 
8dbf			.ike: 
8dbf fe 05			        cp KEY_UP      ; recall last command 
8dc1 c8					ret z 
8dc2			;jr nz, .irec 
8dc2			; TODO next word 
8dc2			; TODO prev word 
8dc2			;  
8dc2			; 
8dc2			;	ld hl, scratch 
8dc2			;	ld de, os_last_cmd 
8dc2			;	call strcpy 
8dc2			;		jp  .inmain 
8dc2			.irec: 
8dc2			;		jr .instr1 
8dc2			 
8dc2			 
8dc2			 
8dc2					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dc2			 
8dc2			; TODO return if any special keys are given 
8dc2			;		ld l, a 
8dc2			;		ld a, 28 ; KEY_F12   ; 27 
8dc2			;		sub l 
8dc2			;		ret m 
8dc2			;		ld a, l 
8dc2					; if no special key then insert as a char 
8dc2			 
8dc2			 
8dc2			 
8dc2 c3 86 8e				jp input_inschr 
8dc5			 
8dc5				 
8dc5			input_nxtword: 
8dc5				; jump to start next word after the cursor 
8dc5			 
8dc5			.insknwn:	 
8dc5 cd 7c 8e				call input_curptr	 
8dc8 7e					ld a,(hl)	 
8dc9			;		cp 0 
8dc9 b7					or a 
8dca ca 2c 8d				jp z, .inmain    ; end of string 
8dcd			 
8dcd			; if we are on a word, then move off of it 
8dcd			 
8dcd fe 20				cp ' ' 
8dcf 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8dd1 21 48 ee				ld hl, input_cursor 
8dd4 34					inc (hl) 
8dd5 18 ee				jr .insknwn 
8dd7			 
8dd7			.inspace: 
8dd7			 
8dd7 cd 7c 8e				call input_curptr	 
8dda 7e					ld a,(hl)	 
8ddb			;		cp 0 
8ddb b7					or a 
8ddc ca 2c 8d				jp z, .inmain    ; end of string 
8ddf			 
8ddf			; if we are on a word, then move off of it 
8ddf			 
8ddf fe 20				cp ' ' 
8de1 c2 2c 8d				jp nz, .inmain     ; we are on non space so at next word 
8de4 21 48 ee				ld hl, input_cursor 
8de7 34					inc (hl) 
8de8 18 ed				jr .inspace 
8dea			 
8dea			 
8dea			 
8dea			 
8dea			input_prvword: 
8dea				; jump to the start of previous word before the cursor 
8dea			 
8dea			; where are we to start with currently? 
8dea			 
8dea cd 7c 8e				call input_curptr	 
8ded 7e					ld a, (hl) 
8dee fe 20				cp ' ' 
8df0 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8df2			 
8df2			 
8df2			 
8df2			.inskpwn:	 
8df2 3a 48 ee				ld a,(input_cursor) 
8df5			;		cp 0 
8df5 b7					or a 
8df6 ca 2c 8d				jp z, .inmain    ; start of string 
8df9			 
8df9			;if we are on a word, then move off of it 
8df9			 
8df9 cd 7c 8e				call input_curptr	 
8dfc 7e					ld a, (hl) 
8dfd fe 20				cp ' ' 
8dff 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e01					;jp z, .inmain    ; start of string 
8e01 21 48 ee				ld hl, input_cursor 
8e04 35					dec (hl) 
8e05 18 eb				jr .inskpwn 
8e07			.iwstart: 
8e07 21 48 ee				ld hl, input_cursor 
8e0a 34					inc (hl) 
8e0b c3 2c 8d				jp .inmain 
8e0e					 
8e0e			 
8e0e			.inspacep: 
8e0e			 
8e0e					;jp .inmain    ; start of string 
8e0e			 
8e0e			 
8e0e			 
8e0e 3a 48 ee				ld a,(input_cursor) 
8e11			;		cp 0 
8e11 b7					or a 
8e12 ca 2c 8d				jp z, .inmain    ; start of string 
8e15			 
8e15			; if we are on a word, then move off of it 
8e15			 
8e15 cd 7c 8e				call input_curptr	 
8e18 7e					ld a, (hl) 
8e19 fe 20				cp ' ' 
8e1b c2 24 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e1e 21 48 ee				ld hl, input_cursor 
8e21 35					dec (hl) 
8e22 18 ea				jr .inspacep 
8e24			 
8e24			 
8e24			.incharp:	 
8e24					; eat the word to get to the start 
8e24 3a 48 ee				ld a,(input_cursor) 
8e27			;		cp 0 
8e27 b7					or a 
8e28 ca 2c 8d				jp z, .inmain    ; start of string 
8e2b			 
8e2b			; if we are on a word, then move off of it 
8e2b			 
8e2b cd 7c 8e				call input_curptr	 
8e2e 7e					ld a, (hl) 
8e2f fe 20				cp ' ' 
8e31 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e33 21 48 ee				ld hl, input_cursor 
8e36 35					dec (hl) 
8e37 18 eb				jr .incharp 
8e39			.ipwordst: 
8e39					; at space before the prev word so reposition over it 
8e39 21 48 ee				ld hl, input_cursor 
8e3c 34					inc (hl) 
8e3d 18 b3				jr .inskpwn 
8e3f					 
8e3f			 
8e3f			 
8e3f			input_left: 
8e3f				; move cursor left 
8e3f 21 48 ee			ld hl, input_cursor 
8e42 35				dec (hl) 
8e43			;	cp 0 
8e43			;	jp z, .inmain    ; ignore left as at the start of the string 
8e43 c3 2c 8d			jp .inmain 
8e46			 
8e46			input_right: 
8e46				; move cursor right 
8e46				 
8e46				;ld a, (input_size) 
8e46				;ld b, a 
8e46 21 48 ee			ld hl, input_cursor 
8e49 34				inc (hl) 
8e4a				;dec b 
8e4a				;cp 0 
8e4a				;jp z, .inmain   ; ignore as at end of the string buffer 
8e4a				;ld a, b 
8e4a				;inc a 
8e4a				;ld (input_cursor), a 
8e4a c3 2c 8d			jp .inmain 
8e4d			 
8e4d			 
8e4d			 
8e4d			input_disp_ref: 
8e4d				; display the text from start of buffer (ie full refresh) 
8e4d 3a 57 ee			ld a, (input_at_pos) 
8e50 2a 5a ee			ld hl,(input_start) 
8e53 eb				ex de, hl 
8e54 cd c3 8a			call str_at_display  
8e57 c9				ret 
8e58			input_disp_oncur: 
8e58				; display the text from cursor position to end of buffer 
8e58				; TODO position start of string at cursor position on screen 
8e58				; TODO draw from that point on 
8e58 3a 48 ee			ld a, (input_cursor) 
8e5b 47				ld b, a 
8e5c 3a 57 ee			ld a, (input_at_pos) 
8e5f 80				add b 
8e60 48				ld c, b     ; save a 
8e61 78				ld a, b     ; inc string start for cursor 
8e62 2a 5a ee			ld hl,(input_start) 
8e65 cd db 8c			call addatohl 
8e68 eb				ex de, hl 
8e69 79				ld a, c 
8e6a cd c3 8a			call str_at_display  
8e6d c9				ret 
8e6e			 
8e6e			input_nxtw: 
8e6e				; Find next word 
8e6e c9				ret 
8e6f			 
8e6f			input_prvw: 
8e6f				; Find previous word 
8e6f c9				ret 
8e70			 
8e70			input_lenrem:   
8e70				; Calculate the length of string remaining from current cursor 
8e70				; position to end of buffer (exc null term) 
8e70				 
8e70 3a 48 ee			ld a, (input_cursor) 
8e73 4f				ld c, a 
8e74 3a 59 ee			ld a, (input_size) 
8e77 91				sub c 
8e78 06 00			ld b, 0 
8e7a 0d				dec c 
8e7b c9				ret	 
8e7c			 
8e7c			input_curptr: 
8e7c				; calc address of the character under the cursor 
8e7c				 
8e7c 2a 5a ee			ld hl, (input_start) 
8e7f 3a 48 ee			ld a, (input_cursor) 
8e82 cd db 8c			call addatohl 
8e85 c9				ret 
8e86			 
8e86			input_inschr: 
8e86				; Insert char at cursor position 
8e86 f5				push af   ; save char 
8e87				;call input_lenrem    ; get bc length of remaining string 
8e87			 
8e87				 
8e87 cd 7c 8e			call input_curptr 
8e8a			;	ld hl, (input_start) 
8e8a			;	ld a, (input_cursor) 
8e8a			;	call addatohl 
8e8a				;push hl   ; save to come back to 
8e8a			 
8e8a				; shift everything up one to end of buffer 
8e8a			 
8e8a				;push hl 
8e8a				;dec de 
8e8a				;inc de 
8e8a			;	ldir 
8e8a				 
8e8a				;pop hl 
8e8a			 
8e8a				; are we adding to the end of line? 
8e8a			 
8e8a 3a 48 ee			ld a, (input_cursor) 
8e8d 47				ld b, a 
8e8e 3a 4d ee			ld a, (input_len) 
8e91 b8				cp b 
8e92 20 08			jr nz, .insmid   ; no, insert in middle of text 
8e94			 
8e94				; tack on the end of the line 
8e94 f1				pop af 
8e95 77				ld (hl), a   ; save new char 
8e96 23				inc hl 
8e97			;	ld a, 0 
8e97 36 00			ld (hl), 0 
8e99 c3 46 8e			jp input_right 
8e9c				 
8e9c			.insmid: 
8e9c				; hl has insertion point so move everything up one to allow for insertion 
8e9c				;call input_shiftright 
8e9c f1				pop af 
8e9d			 
8e9d			.shufinsmid: 
8e9d 47				ld b, a     ; b contains new char, c prev char at this position  
8e9e 7e				ld a, (hl) 
8e9f			 
8e9f			;	cp 0    ; at end of string need to then dump new char and add term 
8e9f b7				or a 
8ea0 28 07			jr z, .endinsmid 
8ea2 4f				ld c, a 
8ea3 78				ld a, b 
8ea4 77				ld (hl), a 
8ea5 23				inc hl 
8ea6 79				ld a, c 
8ea7 18 f4			jr .shufinsmid 
8ea9				 
8ea9			 
8ea9			 
8ea9			 
8ea9			.endinsmid: 
8ea9 78				ld a, b 
8eaa 77				ld (hl), a 
8eab 23				inc hl 
8eac			;	ld a, 0 
8eac 36 00			ld (hl), 0 
8eae			 
8eae			 
8eae			;	ld (hl), a   ; save new char 
8eae			 
8eae c3 46 8e			jp input_right 
8eb1			 
8eb1			;input_shiftright: 
8eb1			;	; shift text right at cursor, hl has shift start 
8eb1			;	push hl 
8eb1			;	push de 
8eb1			;	push bc 
8eb1			; 
8eb1			; 
8eb1			;	; move to end of string past zero term 
8eb1			;	ld hl,(input_start) 
8eb1			;	ld a, (input_len) 
8eb1			;	call addatohl 
8eb1			;	inc hl 
8eb1			;;	inc hl 
8eb1			;;	inc hl 
8eb1			;	ld a, 0 
8eb1			;	ld (hl), a 
8eb1			;;	dec hl 
8eb1			;	 
8eb1			;;	ld (hl), a 
8eb1			;;	dec hl 
8eb1			; 
8eb1			;	push hl 
8eb1			;	pop de 
8eb1			;	inc de 
8eb1			;	 
8eb1			; 
8eb1			;;	ld hl,(input_start) 
8eb1			;;	ld a, (input_cursor) 
8eb1			;;	call addatohl 
8eb1			; 
8eb1			; 
8eb1			;	; calc how many bytes from cursor pos to end of string we need to shift 
8eb1			;	call input_lenrem    ; get bc length of remaining string 
8eb1			;	;ld a, (input_cursor) 
8eb1			;	;ld c, a 
8eb1			;	ld a, (input_len) 
8eb1			;	cp 2 
8eb1			;	jr z, .iskipzero	 
8eb1			;	;sub c 
8eb1			;	;inc a 
8eb1			;	;ld c, a 
8eb1			;	;ld b, 0 
8eb1			;	inc c 
8eb1			;	inc c 
8eb1			;	; move data 
8eb1			;	lddr 
8eb1			;.iskipzero: 
8eb1			; 
8eb1			;	pop bc 
8eb1			;	pop de 
8eb1			;	pop hl 
8eb1			;	ret	 
8eb1			 
8eb1			input_delchar: 
8eb1				; Delete char at cursor position 
8eb1 cd 70 8e			call input_lenrem    ; get bc length of remaining string 
8eb4 2a 5a ee			ld hl, (input_start) 
8eb7 3a 48 ee			ld a, (input_cursor) 
8eba cd db 8c			call addatohl 
8ebd			 
8ebd e5				push hl 
8ebe d1				pop de 
8ebf 1b				dec de 
8ec0			 
8ec0			.dl:	 
8ec0 ed a0			ldi  
8ec2 7e				ld a, (hl) 
8ec3			;	cp 0 
8ec3 b7				or a 
8ec4 28 02			jr z, .dldone 
8ec6 18 f8			jr .dl 
8ec8			.dldone: 
8ec8 ed a0			ldi 
8eca			 
8eca c3 3f 8e			jp input_left 
8ecd			 
8ecd			 
8ecd			endif 
8ecd			 
8ecd			 
8ecd			 
8ecd			if EDIT_V1 
8ecd			input_str: 
8ecd			 
8ecd				    	ld (input_at_pos),a      ; save display position to start 
8ecd					add c 
8ecd					ld (input_at_cursor),a	; save draw pos of cursor 
8ecd					ld (input_start), hl     ; save ptr to buffer 
8ecd					ld a, c 
8ecd					call addatohl 
8ecd					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ecd					ld a,d 
8ecd				        ld (input_size), a       ; save length of input area 
8ecd					ld a, c 
8ecd					ld (input_cursor),a      ; init cursor start position  
8ecd					ld a,e 
8ecd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ecd					 
8ecd					 
8ecd			 
8ecd			;		ld a,(input_ptr) 
8ecd			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ecd			 
8ecd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ecd					; init cursor shape if not set by the cin routines 
8ecd					ld hl, cursor_shape 
8ecd			if BASE_KEV 
8ecd					ld a, 255 
8ecd			else 
8ecd					ld a, '#' 
8ecd			endif 
8ecd					ld (hl), a 
8ecd					inc hl 
8ecd					ld a, 0 
8ecd					ld (hl), a 
8ecd			 
8ecd					ld a, CUR_BLINK_RATE 
8ecd					ld (input_cur_flash), a 
8ecd					ld a, 1 
8ecd					ld (input_cur_onoff),a 
8ecd			 
8ecd			;	if DEBUG_INPUT 
8ecd			;		push af 
8ecd			;		ld a, 'I' 
8ecd			;		ld (debug_mark),a 
8ecd			;		pop af 
8ecd			;		CALLMONITOR 
8ecd			;	endif 
8ecd			.is1:		; main entry loop 
8ecd			 
8ecd			 
8ecd			 
8ecd					; pause 1ms 
8ecd			 
8ecd					ld a, 1 
8ecd					call aDelayInMS 
8ecd			 
8ecd					; dec flash counter 
8ecd					ld a, (input_cur_flash) 
8ecd					dec a 
8ecd					ld (input_cur_flash), a 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jr nz, .nochgstate 
8ecd			 
8ecd			 
8ecd					; change state 
8ecd					ld a,(input_cur_onoff) 
8ecd					neg 
8ecd					ld (input_cur_onoff),a 
8ecd			 
8ecd			 
8ecd					; reset on change of state 
8ecd					ld a, CUR_BLINK_RATE 
8ecd					ld (input_cur_flash), a 
8ecd			 
8ecd			.nochgstate: 
8ecd					 
8ecd					 
8ecd			 
8ecd					; display cursor  
8ecd			 
8ecd			;		ld hl, (input_start) 
8ecd			;		ld a, (input_cursor) 
8ecd			;		call addatohl 
8ecd			 
8ecd					; get char under cursor and replace with cursor 
8ecd			ld hl, (input_ptr) 
8ecd			;		ld a, (hl) 
8ecd			;		ld (input_under_cursor),a 
8ecd			;		ld a, '_' 
8ecd			;		ld (hl), a 
8ecd			 
8ecd					; display string 
8ecd			 
8ecd					ld de, (input_start) 
8ecd					ld a, (input_at_pos) 
8ecd					call str_at_display 
8ecd			;	        call update_display 
8ecd			 
8ecd					; find place to put the cursor 
8ecd			;		add h 
8ecd			;		ld l, display_row_1 
8ecd			;		sub l 
8ecd			; (input_at_pos) 
8ecd					;ld c, a 
8ecd			;		ld a, (input_cursor) 
8ecd			;		ld l, (input_at_pos) 
8ecd			;		;ld b, h 
8ecd			;		add l 
8ecd			;		ld (input_at_cursor),a 
8ecd					;ld l,h 
8ecd			 
8ecd			;		ld h, 0 
8ecd			;		ld l,(input_at_pos) 
8ecd			;		ld a, (input_cursor) 
8ecd			;		call addatohl 
8ecd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ecd			;		call subafromhl 
8ecd			;		ld a,l 
8ecd			;		ld (input_at_cursor), a 
8ecd			 
8ecd				if DEBUG_INPUT 
8ecd					ld a, (hardware_diag) 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jr z, .skip_input_diag 
8ecd			 
8ecd					ld a,(input_at_pos) 
8ecd					ld hl, LFSRSeed 
8ecd					call hexout 
8ecd					ld a, (input_cursor) 
8ecd					ld hl, LFSRSeed+2 
8ecd					call hexout 
8ecd					ld a,(input_at_cursor) 
8ecd					ld hl, LFSRSeed+4 
8ecd					call hexout 
8ecd			 
8ecd					ld a,(input_cur_onoff) 
8ecd					ld hl, LFSRSeed+6 
8ecd					call hexout 
8ecd			 
8ecd					ld a,(input_cur_flash) 
8ecd					ld hl, LFSRSeed+8 
8ecd					call hexout 
8ecd			 
8ecd					ld a,(input_len) 
8ecd					ld hl, LFSRSeed+10 
8ecd					call hexout 
8ecd					ld hl, LFSRSeed+12 
8ecd					ld a, 0 
8ecd					ld (hl),a 
8ecd					ld a, display_row_4 
8ecd					ld de, LFSRSeed 
8ecd					call str_at_display 
8ecd					.skip_input_diag: 
8ecd				endif 
8ecd			 
8ecd					; decide on if we are showing the cursor this time round 
8ecd			 
8ecd					ld a, (input_cur_onoff) 
8ecd					cp 255 
8ecd					jr z, .skipcur 
8ecd			 
8ecd			 
8ecd					ld a,(input_at_cursor) 
8ecd					ld de, cursor_shape 
8ecd					call str_at_display 
8ecd			 
8ecd					; save length of current input string 
8ecd					ld hl, (input_start) 
8ecd					ld a, 0 
8ecd					call strlent 
8ecd					ld a,l 
8ecd					ld (input_len),a 
8ecd			 
8ecd			.skipcur: 
8ecd			 
8ecd				        call update_display 
8ecd					 
8ecd			 
8ecd			 
8ecd					; wait 
8ecd				 
8ecd					; TODO loop without wait to flash the cursor and char under cursor	 
8ecd					call cin    ; _wait 
8ecd			 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jp z, .is1 
8ecd			 
8ecd					; get ptr to char to input into 
8ecd			 
8ecd					ld c,a 
8ecd					ld hl, (input_start) 
8ecd					ld a, (input_cursor) 
8ecd					call addatohl 
8ecd					ld (input_ptr), hl 
8ecd					ld a,c 
8ecd			 
8ecd					; replace char under cursor 
8ecd			 
8ecd			;		ld hl, (input_ptr) 
8ecd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ecd			;		ld (hl), a 
8ecd			 
8ecd			;	if DEBUG_INPUT 
8ecd			;		push af 
8ecd			;		ld a, 'i' 
8ecd			;		ld (debug_mark),a 
8ecd			;		pop af 
8ecd			;		CALLMONITOR 
8ecd			;	endif 
8ecd					cp KEY_HOME 
8ecd					jr nz, .iske 
8ecd			 
8ecd					ld a, (input_at_pos) 
8ecd					ld (input_at_cursor),a 
8ecd					ld a, 0 
8ecd					ld (input_cursor), a 
8ecd					jp .is1 
8ecd					 
8ecd			.iske:		cp KEY_END 
8ecd					jr nz, .isknw 
8ecd					jp .is1 
8ecd			 
8ecd			.isknw:		cp KEY_NEXTWORD 
8ecd					jr nz, .iskpw 
8ecd			 
8ecd			.isknwm:	ld hl, (input_ptr) 
8ecd					ld a,(hl)	 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jp z, .is1    ; end of string 
8ecd					cp ' ' 
8ecd					jp z, .is1    ; end of word 
8ecd					inc hl 
8ecd					ld (input_ptr), hl 
8ecd					ld a, (input_at_cursor) 
8ecd					inc a 
8ecd					ld (input_at_cursor), a 
8ecd					jr .isknwm 
8ecd			 
8ecd			.iskpw:		cp KEY_PREVWORD 
8ecd					jr nz, .iskl 
8ecd			.iskpwm:	 
8ecd					ld hl, (input_ptr) 
8ecd					ld a,(hl)	 
8ecd			;		cp 0  
8ecd					or a 
8ecd					jp z, .is1    ; end of string 
8ecd					cp ' ' 
8ecd					jp z, .is1    ; end of word 
8ecd					dec hl 
8ecd					ld (input_ptr), hl 
8ecd					ld a, (input_at_cursor) 
8ecd					dec a 
8ecd					ld (input_at_cursor), a 
8ecd					jr .iskpwm 
8ecd			 
8ecd			 
8ecd			.iskl:		cp KEY_LEFT 
8ecd					jr nz, .isk1 
8ecd			 
8ecd					ld a, (input_cursor) 
8ecd			 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jp z, .is1 		; at start of line to ignore  
8ecd			 
8ecd					dec  a 		; TODO check underflow 
8ecd					ld (input_cursor), a 
8ecd			 
8ecd					ld hl, (input_ptr) 
8ecd					dec hl 
8ecd					ld (input_ptr), hl 
8ecd					 
8ecd					ld a, (input_at_cursor) 
8ecd					dec a 
8ecd					ld (input_at_cursor), a 
8ecd			 
8ecd					ld a, 1		; show cursor moving 
8ecd					ld (input_cur_onoff),a 
8ecd					ld a, CUR_BLINK_RATE 
8ecd					ld (input_cur_flash), a 
8ecd			 
8ecd					jp .is1 
8ecd			 
8ecd			.isk1:		cp KEY_RIGHT 
8ecd					jr nz, .isk2 
8ecd			 
8ecd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ecd					ld e,a 
8ecd					ld a, (input_cursor) 
8ecd					cp e 
8ecd					jp z, .is1		; at the end of string so dont go right 
8ecd			 
8ecd					inc  a 		; TODO check overflow 
8ecd					ld (input_cursor), a 
8ecd			 
8ecd					ld a, (input_at_cursor) 
8ecd					inc a 
8ecd					ld (input_at_cursor), a 
8ecd			 
8ecd					ld hl, (input_ptr) 
8ecd					inc hl 
8ecd					ld (input_ptr), hl 
8ecd			 
8ecd					ld a, 1		; show cursor moving 
8ecd					ld (input_cur_onoff),a 
8ecd					ld a, CUR_BLINK_RATE 
8ecd					ld (input_cur_flash), a 
8ecd			 
8ecd					jp .is1 
8ecd			 
8ecd			.isk2:		cp KEY_UP 
8ecd			 
8ecd					jr nz, .isk3 
8ecd			 
8ecd					; swap last command with the current on 
8ecd			 
8ecd					; move cursor to start of string 
8ecd					ld hl, (input_start) 
8ecd					ld (input_ptr), hl 
8ecd			 
8ecd					ld a, (input_at_pos) 
8ecd					ld (input_at_cursor), a 
8ecd			 
8ecd					ld a, 0 
8ecd					ld (input_cursor), a 
8ecd					 
8ecd					; swap input and last command buffers 
8ecd			 
8ecd					ld hl, os_cli_cmd 
8ecd					ld de, os_last_cmd 
8ecd					ld b, 255 
8ecd			.swap1:		ld a, (hl) 
8ecd					ld c,a 
8ecd					ld a, (de) 
8ecd					ld (hl), a 
8ecd					ld a,c 
8ecd					ld (de),a 
8ecd					inc hl 
8ecd					inc de 
8ecd					djnz .swap1 
8ecd			 
8ecd			 
8ecd			 
8ecd			 
8ecd			 
8ecd					jp .is1 
8ecd			 
8ecd			.isk3:		cp KEY_BS 
8ecd					jr nz, .isk4 
8ecd			 
8ecd					ld a, (input_cursor) 
8ecd			 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jp z, .is1 		; at start of line to ignore  
8ecd			 
8ecd					dec  a 		; TODO check underflow 
8ecd					ld (input_cursor), a 
8ecd			 
8ecd					; hl is source 
8ecd					; de needs to be source - 1 
8ecd			 
8ecd			;		ld a, 0 
8ecd			;		dec hl 
8ecd			;		ld (hl), a 
8ecd			 
8ecd					ld hl, (input_ptr) 
8ecd					dec hl 
8ecd					ld (input_ptr), hl 
8ecd			 
8ecd					; shift all data 
8ecd			 
8ecd					push hl 
8ecd					inc hl 
8ecd					pop de 
8ecd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ecd					ld c,a 
8ecd					ld b,0 
8ecd					ldir  
8ecd			 
8ecd			 
8ecd			 
8ecd			 
8ecd					ld a, (input_at_cursor) 
8ecd					dec a 
8ecd					ld (input_at_cursor), a 
8ecd			 
8ecd			 
8ecd					ld a, 1		; show cursor moving 
8ecd					ld (input_cur_onoff),a 
8ecd					ld a, CUR_BLINK_RATE 
8ecd					ld (input_cur_flash), a 
8ecd			 
8ecd					; remove char 
8ecd					ld a, (input_at_cursor) 
8ecd					inc a 
8ecd					ld de,.iblank 
8ecd					call str_at_display 
8ecd			 
8ecd					jp .is1 
8ecd			 
8ecd			.isk4:		cp KEY_CR 
8ecd					jr z, .endinput 
8ecd			 
8ecd					; else add the key press to the end 
8ecd			 
8ecd					ld c, a			; save key pressed 
8ecd			 
8ecd					ld a,(hl)		; get what is currently under char 
8ecd			 
8ecd			;		cp 0			; we are at the end of the string 
8ecd					or a 
8ecd					jr nz, .onchar 
8ecd					 
8ecd					; add a char to the end of the string 
8ecd				 
8ecd					ld (hl),c 
8ecd					inc hl 
8ecd			;		ld a,' ' 
8ecd			;		ld (hl),a 
8ecd			;		inc hl 
8ecd					ld a,0 
8ecd					ld (hl),a 
8ecd					dec hl 
8ecd			 
8ecd					ld a, (input_cursor) 
8ecd					inc a				; TODO check max string length and scroll  
8ecd					ld (input_cursor), a		; inc cursor pos 
8ecd							 
8ecd					ld a, (input_at_cursor) 
8ecd					inc a 
8ecd					ld (input_at_cursor), a 
8ecd			 
8ecd					ld hl, (input_ptr) 
8ecd					inc hl 
8ecd					ld (input_ptr), hl 
8ecd			 
8ecd					ld hl, (input_ptr) 
8ecd					inc hl 
8ecd					ld (input_ptr), hl 
8ecd			;	if DEBUG_INPUT 
8ecd			;		push af 
8ecd			;		ld a, '+' 
8ecd			;		ld (debug_mark),a 
8ecd			;		pop af 
8ecd			;		CALLMONITOR 
8ecd			;	endif 
8ecd					ld a, 1		; show cursor moving 
8ecd					ld (input_cur_onoff),a 
8ecd					ld a, CUR_BLINK_RATE 
8ecd					ld (input_cur_flash), a 
8ecd					jp .is1 
8ecd					 
8ecd			 
8ecd			 
8ecd					; if on a char then insert 
8ecd			.onchar: 
8ecd			 
8ecd					; TODO over flow check: make sure insert does not blow out buffer 
8ecd			 
8ecd					; need to do some maths to use lddr 
8ecd			 
8ecd					push hl   ; save char pos 
8ecd					push bc 
8ecd			 
8ecd					ld hl, (input_start) 
8ecd					ld a, (input_len) 
8ecd					call addatohl  		; end of string 
8ecd					inc hl 
8ecd					inc hl		; past zero term 
8ecd					push hl 
8ecd					inc hl 
8ecd					push hl  
8ecd			 
8ecd								; start and end of lddr set, now how much to move? 
8ecd			 
8ecd							 
8ecd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ecd					ld b,a 
8ecd					ld a,(input_len) 
8ecd					ld e,a 
8ecd					sub b 
8ecd					inc a		;?? 
8ecd					inc a		;?? 
8ecd					inc a		;?? 
8ecd			 
8ecd					ld b,0 
8ecd					ld c,a 
8ecd			 
8ecd				if DEBUG_INPUT 
8ecd					push af 
8ecd					ld a, 'i' 
8ecd					ld (debug_mark),a 
8ecd					pop af 
8ecd			;		CALLMONITOR 
8ecd				endif 
8ecd					pop de 
8ecd					pop hl 
8ecd				if DEBUG_INPUT 
8ecd					push af 
8ecd					ld a, 'I' 
8ecd					ld (debug_mark),a 
8ecd					pop af 
8ecd			;		CALLMONITOR 
8ecd				endif 
8ecd					lddr 
8ecd				 
8ecd			 
8ecd			 
8ecd					; TODO have a key for insert/overwrite mode???? 
8ecd					pop bc 
8ecd					pop hl 
8ecd					ld (hl), c		; otherwise overwrite current char 
8ecd					 
8ecd			 
8ecd			 
8ecd			 
8ecd					ld a, (input_cursor) 
8ecd					inc  a 		; TODO check overflow 
8ecd					ld (input_cursor), a 
8ecd			 
8ecd					ld a, (input_at_cursor) 
8ecd					inc a 
8ecd					ld (input_at_cursor), a 
8ecd			 
8ecd					jp .is1 
8ecd			 
8ecd			.endinput:	; TODO look for end of string 
8ecd			 
8ecd					; add trailing space for end of token 
8ecd			 
8ecd					ld hl, (input_start) 
8ecd					ld a,(input_len) 
8ecd					call addatohl 
8ecd					ld a, ' ' 
8ecd					ld (hl),a 
8ecd					; TODO eof of parse marker 
8ecd			 
8ecd					inc hl 
8ecd					ld a, 0 
8ecd					ld (hl),a 
8ecd			 
8ecd			 
8ecd					ret 
8ecd			 
8ecd			.iblank: db " ",0 
8ecd			 
8ecd			 
8ecd			input_str_prev:	ld (input_at_pos), a 
8ecd					ld (input_start), hl 
8ecd					ld a,1			; add cursor 
8ecd					ld (hl),a 
8ecd					inc hl 
8ecd					ld a,0 
8ecd					ld (hl),a 
8ecd					ld (input_ptr), hl 
8ecd					ld a,d 
8ecd					ld (input_size), a 
8ecd					ld a,0 
8ecd					ld (input_cursor),a 
8ecd			.instr1:	 
8ecd			 
8ecd					; TODO do block cursor 
8ecd					; TODO switch cursor depending on the modifer key 
8ecd			 
8ecd					; update cursor shape change on key hold 
8ecd			 
8ecd					ld hl, (input_ptr) 
8ecd					dec hl 
8ecd					ld a,(cursor_shape) 
8ecd					ld (hl), a 
8ecd			 
8ecd					; display entered text 
8ecd					ld a,(input_at_pos) 
8ecd			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ecd			            	LD   de, (input_start) 
8ecd			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ecd			 
8ecd					call cin 
8ecd			;		cp 0 
8ecd					or a 
8ecd					jr z, .instr1 
8ecd			 
8ecd					; proecess keyboard controls first 
8ecd			 
8ecd					ld hl,(input_ptr) 
8ecd			 
8ecd					cp KEY_CR	 ; pressing enter ends input 
8ecd					jr z, .instrcr 
8ecd			 
8ecd					cp KEY_BS 	; back space 
8ecd					jr nz, .instr2 
8ecd					; process back space 
8ecd			 
8ecd					; TODO stop back space if at start of string 
8ecd					dec hl 
8ecd					dec hl ; to over write cursor 
8ecd					ld a,(cursor_shape) 
8ecd					;ld a,0 
8ecd					ld (hl),a 
8ecd					inc hl 
8ecd					ld a," " 
8ecd					ld (hl),a 
8ecd					ld (input_ptr),hl 
8ecd					 
8ecd			 
8ecd					jr .instr1 
8ecd			 
8ecd			.instr2:	cp KEY_LEFT    ; cursor left 
8ecd					jr nz, .instr3 
8ecd					dec hl 
8ecd					ld (input_ptr),hl 
8ecd					jr .instr1 
8ecd				 
8ecd			.instr3:	cp KEY_RIGHT      ; cursor right 
8ecd					jr nz, .instr4 
8ecd					inc hl 
8ecd					ld (input_ptr),hl 
8ecd					jr .instr1 
8ecd			 
8ecd			.instr4:	cp KEY_HOME    ; jump to start of line 
8ecd					jr nz, .instr5 
8ecd					dec hl 
8ecd					ld (input_ptr),hl 
8ecd					jr .instr1 
8ecd			 
8ecd			.instr5:	cp KEY_END     ; jump to end of line 
8ecd					jr nz, .instr6 
8ecd					dec hl 
8ecd					ld (input_ptr),hl 
8ecd					jr .instr1 
8ecd			.instr6:        cp KEY_UP      ; recall last command 
8ecd					jr nz, .instrnew 
8ecd			 
8ecd				ld hl, scratch 
8ecd				ld de, os_last_cmd 
8ecd				call strcpy 
8ecd					jr .instr1 
8ecd			 
8ecd			 
8ecd			.instrnew:	; no special key pressed to see if we have room to store it 
8ecd			 
8ecd					; TODO do string size test 
8ecd			 
8ecd					dec hl ; to over write cursor 
8ecd					ld (hl),a 
8ecd					inc hl 
8ecd					ld a,(cursor_shape) 
8ecd					ld (hl),a 
8ecd					inc hl 
8ecd					ld a,0 
8ecd					ld (hl),a 
8ecd			 
8ecd					ld (input_ptr),hl 
8ecd					 
8ecd					jr .instr1 
8ecd			.instrcr:	dec hl		; remove cursor 
8ecd					ld a,' '	; TODO add a trailing space for safety 
8ecd					ld (hl),a 
8ecd					inc hl 
8ecd					ld a,0 
8ecd					ld (hl),a 
8ecd			 
8ecd			 
8ecd					; if at end of line scroll up    
8ecd					; TODO detecting only end of line 4 for scroll up  
8ecd			 
8ecd					;ld   
8ecd			 
8ecd					ret 
8ecd			 
8ecd			 
8ecd			endif 
8ecd			; strcpy hl = dest, de source 
8ecd			 
8ecd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8ece b7			            OR   A              ;Null terminator? 
8ecf c8			            RET  Z              ;Yes, so finished 
8ed0 1a					ld a,(de) 
8ed1 77					ld (hl),a 
8ed2 13			            INC  DE             ;Point to next character 
8ed3 23					inc hl 
8ed4 18 f7		            JR   strcpy       ;Repeat 
8ed6 c9					ret 
8ed7			 
8ed7			 
8ed7			; TODO string_at  
8ed7			; pass string which starts with lcd offset address and then null term string 
8ed7			 
8ed7			; TODO string to dec 
8ed7			; TODO string to hex 
8ed7			; TODO byte to string hex 
8ed7			; TODO byte to string dec 
8ed7			 
8ed7			 
8ed7			 
8ed7			; from z80uartmonitor 
8ed7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ed7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ed7			; pass hl for where to put the text 
8ed7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ed7 c5			hexout:	PUSH BC 
8ed8 f5					PUSH AF 
8ed9 47					LD B, A 
8eda					; Upper nybble 
8eda cb 3f				SRL A 
8edc cb 3f				SRL A 
8ede cb 3f				SRL A 
8ee0 cb 3f				SRL A 
8ee2 cd f2 8e				CALL tohex 
8ee5 77					ld (hl),a 
8ee6 23					inc hl	 
8ee7					 
8ee7					; Lower nybble 
8ee7 78					LD A, B 
8ee8 e6 0f				AND 0FH 
8eea cd f2 8e				CALL tohex 
8eed 77					ld (hl),a 
8eee 23					inc hl	 
8eef					 
8eef f1					POP AF 
8ef0 c1					POP BC 
8ef1 c9					RET 
8ef2					 
8ef2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ef2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef2			tohex: 
8ef2 e5					PUSH HL 
8ef3 d5					PUSH DE 
8ef4 16 00				LD D, 0 
8ef6 5f					LD E, A 
8ef7 21 ff 8e				LD HL, .DATA 
8efa 19					ADD HL, DE 
8efb 7e					LD A, (HL) 
8efc d1					POP DE 
8efd e1					POP HL 
8efe c9					RET 
8eff			 
8eff			.DATA: 
8eff 30					DEFB	30h	; 0 
8f00 31					DEFB	31h	; 1 
8f01 32					DEFB	32h	; 2 
8f02 33					DEFB	33h	; 3 
8f03 34					DEFB	34h	; 4 
8f04 35					DEFB	35h	; 5 
8f05 36					DEFB	36h	; 6 
8f06 37					DEFB	37h	; 7 
8f07 38					DEFB	38h	; 8 
8f08 39					DEFB	39h	; 9 
8f09 41					DEFB	41h	; A 
8f0a 42					DEFB	42h	; B 
8f0b 43					DEFB	43h	; C 
8f0c 44					DEFB	44h	; D 
8f0d 45					DEFB	45h	; E 
8f0e 46					DEFB	46h	; F 
8f0f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f0f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f0f			;;    subtract $30, if result > 9 then subtract $7 more 
8f0f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f0f			atohex: 
8f0f d6 30				SUB $30 
8f11 fe 0a				CP 10 
8f13 f8					RET M		; If result negative it was 0-9 so we're done 
8f14 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f16 c9					RET		 
8f17			 
8f17			 
8f17			 
8f17			 
8f17			; Get 2 ASCII characters as hex byte from pointer in hl 
8f17			 
8f17			BYTERD: 
8f17 16 00			LD	D,00h		;Set up 
8f19 cd 21 8f			CALL	HEXCON		;Get byte and convert to hex 
8f1c 87				ADD	A,A		;First nibble so 
8f1d 87				ADD	A,A		;multiply by 16 
8f1e 87				ADD	A,A		; 
8f1f 87				ADD	A,A		; 
8f20 57				LD	D,A		;Save hi nibble in D 
8f21			HEXCON: 
8f21 7e				ld a, (hl)		;Get next chr 
8f22 23				inc hl 
8f23 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f25 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f27 38 02			JR	C,NALPHA	;If so miss next bit 
8f29 d6 07			SUB	007h		;Else convert alpha 
8f2b			NALPHA: 
8f2b b2				OR	D		;Add hi nibble back 
8f2c c9				RET			; 
8f2d			 
8f2d			 
8f2d			; 
8f2d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f2d			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f2d			; characters (0-9a-f) are accepted. 
8f2d			; 
8f2d			;get_word        push    af 
8f2d			;                call    get_byte        ; Get the upper byte 
8f2d			;                ld      h, a 
8f2d			;                call    get_byte        ; Get the lower byte 
8f2d			;                ld      l, a 
8f2d			;                pop     af 
8f2d			;                ret 
8f2d			; 
8f2d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f2d			; the routine get_nibble is used only valid characters are accepted - the  
8f2d			; input routine only accepts characters 0-9a-f. 
8f2d			; 
8f2d c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f2e 7e					ld a,(hl) 
8f2f 23					inc hl 
8f30 cd 55 8f		                call    nibble2val      ; Get upper nibble 
8f33 cb 07		                rlc     a 
8f35 cb 07		                rlc     a 
8f37 cb 07		                rlc     a 
8f39 cb 07		                rlc     a 
8f3b 47			                ld      b, a            ; Save upper four bits 
8f3c 7e					ld a,(hl) 
8f3d cd 55 8f		                call    nibble2val      ; Get lower nibble 
8f40 b0			                or      b               ; Combine both nibbles 
8f41 c1			                pop     bc              ; Restore B (and C) 
8f42 c9			                ret 
8f43			; 
8f43			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f43			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f43			; to the serial line interface. The lower 4 bits of A contain the value of  
8f43			; that particular digit. 
8f43			; 
8f43			;get_nibble      ld a,(hl)           ; Read a character 
8f43			;                call    to_upper        ; Convert to upper case 
8f43			;                call    is_hex          ; Was it a hex digit? 
8f43			;                jr      nc, get_nibble  ; No, get another character 
8f43			 ;               call    nibble2val      ; Convert nibble to value 
8f43			 ;               call    print_nibble 
8f43			 ;               ret 
8f43			; 
8f43			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f43			; A valid hexadecimal digit is denoted by a set C flag. 
8f43			; 
8f43			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f43			;                ret     nc              ; Yes 
8f43			;                cp      '0'             ; Less than '0'? 
8f43			;                jr      nc, is_hex_1    ; No, continue 
8f43			;                ccf                     ; Complement carry (i.e. clear it) 
8f43			;                ret 
8f43			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f43			;                ret     c               ; Yes 
8f43			;                cp      'A'             ; Less than 'A'? 
8f43			;                jr      nc, is_hex_2    ; No, continue 
8f43			;                ccf                     ; Yes - clear carry and return 
8f43			;                ret 
8f43			;is_hex_2        scf                     ; Set carry 
8f43			;                ret 
8f43			; 
8f43			; Convert a single character contained in A to upper case: 
8f43			; 
8f43 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f45 d8			                ret     c 
8f46 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f48 d0			                ret     nc              ; Nothing to do, either 
8f49 e6 5f		                and     $5f             ; Convert to upper case 
8f4b c9			                ret 
8f4c			 
8f4c			 
8f4c			to_lower: 
8f4c			 
8f4c			   ; if char is in [A-Z] make it lower case 
8f4c			 
8f4c			   ; enter : a = char 
8f4c			   ; exit  : a = lower case char 
8f4c			   ; uses  : af 
8f4c			 
8f4c fe 41		   cp 'A' 
8f4e d8			   ret c 
8f4f			    
8f4f fe 5b		   cp 'Z'+1 
8f51 d0			   ret nc 
8f52			    
8f52 f6 20		   or $20 
8f54 c9			   ret 
8f55			 
8f55			; 
8f55			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f55			; corresponding value in A. 
8f55			; 
8f55 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f57 38 02		                jr      c, nibble2val_1 ; Yes 
8f59 d6 07		                sub     7               ; Adjust for A-F 
8f5b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f5d e6 0f		                and     $f              ; Only return lower 4 bits 
8f5f c9			                ret 
8f60			; 
8f60			; Print_nibble prints a single hex nibble which is contained in the lower  
8f60			; four bits of A: 
8f60			; 
8f60			;print_nibble    push    af              ; We won't destroy the contents of A 
8f60			;                and     $f              ; Just in case... 
8f60			;                add     a, '0'             ; If we have a digit we are done here. 
8f60			;                cp      '9' + 1         ; Is the result > 9? 
8f60			;                jr      c, print_nibble_1 
8f60			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f60			;print_nibble_1  call    putc            ; Print the nibble and 
8f60			;                pop     af              ; restore the original value of A 
8f60			;                ret 
8f60			;; 
8f60			;; Send a CR/LF pair: 
8f60			; 
8f60			;crlf            push    af 
8f60			;                ld      a, cr 
8f60			;                call    putc 
8f60			;                ld      a, lf 
8f60			;                call    putc 
8f60			;                pop     af 
8f60			;                ret 
8f60			; 
8f60			; Print_word prints the four hex digits of a word to the serial line. The  
8f60			; word is expected to be in HL. 
8f60			; 
8f60			;print_word      push    hl 
8f60			;                push    af 
8f60			;                ld      a, h 
8f60			;                call    print_byte 
8f60			;                ld      a, l 
8f60			;                call    print_byte 
8f60			;                pop     af 
8f60			;                pop     hl 
8f60			;                ret 
8f60			; 
8f60			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f60			; The byte to be printed is expected to be in A. 
8f60			; 
8f60			;print_byte      push    af              ; Save the contents of the registers 
8f60			;                push    bc 
8f60			;                ld      b, a 
8f60			;                rrca 
8f60			;                rrca 
8f60			;                rrca 
8f60			;                rrca 
8f60			;                call    print_nibble    ; Print high nibble 
8f60			;                ld      a, b 
8f60			;                call    print_nibble    ; Print low nibble 
8f60			;                pop     bc              ; Restore original register contents 
8f60			;                pop     af 
8f60			;                ret 
8f60			 
8f60			 
8f60			 
8f60			 
8f60			 
8f60			fourehexhl:  
8f60 7e				ld a,(hl) 
8f61 cd 0f 8f			call atohex 
8f64 cb 3f				SRL A 
8f66 cb 3f				SRL A 
8f68 cb 3f				SRL A 
8f6a cb 3f				SRL A 
8f6c 47				ld b, a 
8f6d 23				inc hl 
8f6e 7e				ld a,(hl) 
8f6f 23				inc hl 
8f70 cd 0f 8f			call atohex 
8f73 80				add b 
8f74 57				ld d,a 
8f75 7e				ld a,(hl) 
8f76 cd 0f 8f			call atohex 
8f79 cb 3f				SRL A 
8f7b cb 3f				SRL A 
8f7d cb 3f				SRL A 
8f7f cb 3f				SRL A 
8f81 47				ld b, a 
8f82 23				inc hl 
8f83 7e				ld a,(hl) 
8f84 23				inc hl 
8f85 cd 0f 8f			call atohex 
8f88 80				add b 
8f89 5f				ld e, a 
8f8a d5				push de 
8f8b e1				pop hl 
8f8c c9				ret 
8f8d			 
8f8d			; pass hl. returns z set if the byte at hl is a digit 
8f8d			;isdigithl:  
8f8d			;	push bc 
8f8d			;	ld a,(hl) 
8f8d			;	cp ':' 
8f8d			;	jr nc, .isdf 		; > 
8f8d			;	cp '0' 
8f8d			;	jr c, .isdf		; < 
8f8d			; 
8f8d			;	; TODO find a better way to set z 
8f8d			; 
8f8d			;	ld b,a 
8f8d			;	cp b 
8f8d			;	pop bc 
8f8d			;	ret 
8f8d			; 
8f8d			;.isdf:	; not digit so clear z 
8f8d			; 
8f8d			;	; TODO find a better way to unset z 
8f8d			; 
8f8d			;	ld b,a 
8f8d			;	inc b 
8f8d			;	cp b 
8f8d			; 
8f8d			;	pop bc 
8f8d			;	ret 
8f8d				 
8f8d				 
8f8d			 
8f8d			 
8f8d			; pass hl as the four byte address to load 
8f8d			 
8f8d			get_word_hl:  
8f8d e5				push hl 
8f8e cd 2d 8f			call get_byte 
8f91				 
8f91 47				ld b, a 
8f92			 
8f92 e1				pop hl 
8f93 23				inc hl 
8f94 23				inc hl 
8f95			 
8f95			; TODO not able to handle a-f  
8f95 7e				ld a,(hl) 
8f96			;	;cp ':' 
8f96			;	cp 'g' 
8f96			;	jr nc, .single_byte_hl 		; > 
8f96			;	cp 'G' 
8f96			;	jr nc, .single_byte_hl 		; > 
8f96			;	cp '0' 
8f96			;	jr c, .single_byte_hl		; < 
8f96			 
8f96				;call isdigithl 
8f96			;	cp 0 
8f96 b7				or a 
8f97 28 06			jr z, .single_byte_hl 
8f99			 
8f99			.getwhln:   ; hex word so get next byte 
8f99			 
8f99 cd 2d 8f			call get_byte 
8f9c 6f				ld l, a 
8f9d 60				ld h,b 
8f9e c9				ret 
8f9f 68			.single_byte_hl:   ld l,b 
8fa0 26 00				ld h,0 
8fa2 c9					ret 
8fa3			 
8fa3			 
8fa3			 
8fa3			 
8fa3 21 ab 96			ld hl,asc+1 
8fa6			;	ld a, (hl) 
8fa6			;	call nibble2val 
8fa6 cd 2d 8f			call get_byte 
8fa9			 
8fa9			;	call fourehexhl 
8fa9 32 e8 e2			ld (scratch+52),a 
8fac				 
8fac 21 e6 e2			ld hl,scratch+50 
8faf 22 d7 e5			ld (os_cur_ptr),hl 
8fb2			 
8fb2 c9				ret 
8fb3			 
8fb3			 
8fb3			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fb3			 
8fb3			; Decimal Unsigned Version 
8fb3			 
8fb3			;Number in a to decimal ASCII 
8fb3			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fb3			;Example: display a=56 as "056" 
8fb3			;input: a = number 
8fb3			;Output: a=0,value of a in the screen 
8fb3			;destroys af,bc (don't know about hl and de) 
8fb3			DispAToASCII: 
8fb3 0e 9c			ld	c,-100 
8fb5 cd bf 8f			call	.Na1 
8fb8 0e f6			ld	c,-10 
8fba cd bf 8f			call	.Na1 
8fbd 0e ff			ld	c,-1 
8fbf 06 2f		.Na1:	ld	b,'0'-1 
8fc1 04			.Na2:	inc	b 
8fc2 81				add	a,c 
8fc3 38 fc			jr	c,.Na2 
8fc5 91				sub	c		;works as add 100/10/1 
8fc6 f5				push af		;safer than ld c,a 
8fc7 78				ld	a,b		;char is in b 
8fc8			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fc8 f1				pop af		;safer than ld a,c 
8fc9 c9				ret 
8fca			 
8fca			; Decimal Signed Version 
8fca			 
8fca			; DispA 
8fca			; -------------------------------------------------------------- 
8fca			; Converts a signed integer value to a zero-terminated ASCII 
8fca			; string representative of that value (using radix 10). 
8fca			; -------------------------------------------------------------- 
8fca			; INPUTS: 
8fca			;     HL     Value to convert (two's complement integer). 
8fca			;     DE     Base address of string destination. (pointer). 
8fca			; -------------------------------------------------------------- 
8fca			; OUTPUTS: 
8fca			;     None 
8fca			; -------------------------------------------------------------- 
8fca			; REGISTERS/MEMORY DESTROYED 
8fca			; AF HL 
8fca			; -------------------------------------------------------------- 
8fca			 
8fca			;DispHLToASCII: 
8fca			;   push    de 
8fca			;   push    bc 
8fca			; 
8fca			;; Detect sign of HL. 
8fca			;    bit    7, h 
8fca			;    jr     z, ._DoConvert 
8fca			; 
8fca			;; HL is negative. Output '-' to string and negate HL. 
8fca			;    ld     a, '-' 
8fca			;    ld     (de), a 
8fca			;    inc    de 
8fca			; 
8fca			;; Negate HL (using two's complement) 
8fca			;    xor    a 
8fca			;    sub    l 
8fca			;    ld     l, a 
8fca			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fca			;    sbc    a, h 
8fca			;    ld     h, a 
8fca			; 
8fca			;; Convert HL to digit characters 
8fca			;._DoConvert: 
8fca			;    ld     b, 0     ; B will count character length of number 
8fca			;-   ld     a, 10 
8fca			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fca			;    push   af 
8fca			;    inc    b 
8fca			;    ld     a, h 
8fca			;    or     l 
8fca			;    jr     nz, - 
8fca			; 
8fca			;; Retrieve digits from stack 
8fca			;-   pop    af 
8fca			;    or     $30 
8fca			;    ld     (de), a 
8fca			;    inc    de 
8fca			;    djnz   - 
8fca			; 
8fca			;; Terminate string with NULL 
8fca			;    xor    a 
8fca			;    ld     (de), a 
8fca			; 
8fca			;    pop    bc 
8fca			;    pop    de 
8fca			;    ret 
8fca			 
8fca			;Comments 
8fca			; 
8fca			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fca			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fca			;    Note that the output string will not be fixed-width. 
8fca			; 
8fca			;Example Usage 
8fca			; 
8fca			;    ld    hl, -1004 
8fca			;    ld    de, OP1 
8fca			;    call  DispA 
8fca			;    ld    hl, OP1 
8fca			;    syscall  PutS 
8fca			 
8fca			 
8fca			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fca			 
8fca			 
8fca			;Converts an ASCII string to an unsigned 16-bit integer 
8fca			;Quits when it reaches a non-decimal digit 
8fca			 
8fca			string_to_uint16: 
8fca			atoui_16: 
8fca			;Input: 
8fca			;     DE points to the string 
8fca			;Outputs: 
8fca			;     HL is the result 
8fca			;     A is the 8-bit value of the number 
8fca			;     DE points to the byte after the number 
8fca			;Destroys: 
8fca			;     BC 
8fca			;       if the string is non-empty, BC is HL/10 
8fca			;Size:  24 bytes 
8fca			;Speed: 42+d(104+{0,9}) 
8fca			;       d is the number of digits in the number 
8fca			;       max is 640 cycles for a 5 digit number 
8fca			;Assuming no leading zeros: 
8fca			;1 digit:  146cc 
8fca			;2 digit:  250cc 
8fca			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fca			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fca			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fca			;avg: 544.81158447265625cc (544+13297/16384) 
8fca			;=============================================================== 
8fca 21 00 00		  ld hl,0 
8fcd			.u16a: 
8fcd 1a			  ld a,(de) 
8fce d6 30		  sub 30h 
8fd0 fe 0a		  cp 10 
8fd2 d0			  ret nc 
8fd3 13			  inc de 
8fd4 44			  ld b,h 
8fd5 4d			  ld c,l 
8fd6 29			  add hl,hl 
8fd7 29			  add hl,hl 
8fd8 09			  add hl,bc 
8fd9 29			  add hl,hl 
8fda 85			  add a,l 
8fdb 6f			  ld l,a 
8fdc 30 ef		  jr nc,.u16a 
8fde 24			  inc h 
8fdf c3 cd 8f		  jp .u16a 
8fe2			 
8fe2			 
8fe2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe2			 
8fe2			;written by Zeda 
8fe2			;Converts a 16-bit unsigned integer to an ASCII string. 
8fe2			 
8fe2			uitoa_16: 
8fe2			;Input: 
8fe2			;   DE is the number to convert 
8fe2			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fe2			;Output: 
8fe2			;   HL points to the null-terminated ASCII string 
8fe2			;      NOTE: This isn't necessarily the same as the input HL. 
8fe2 d5			  push de 
8fe3 c5			  push bc 
8fe4 f5			  push af 
8fe5 eb			  ex de,hl 
8fe6			 
8fe6 01 f0 d8		  ld bc,-10000 
8fe9 3e 2f		  ld a,'0'-1 
8feb 3c			  inc a 
8fec 09			  add hl,bc  
8fed 38 fc		   jr c,$-2 
8fef 12			  ld (de),a 
8ff0 13			  inc de 
8ff1			 
8ff1 01 e8 03		  ld bc,1000 
8ff4 3e 3a		  ld a,'9'+1 
8ff6 3d			  dec a  
8ff7 09			  add hl,bc  
8ff8 30 fc		   jr nc,$-2 
8ffa 12			  ld (de),a 
8ffb 13			  inc de 
8ffc			 
8ffc 01 9c ff		  ld bc,-100 
8fff 3e 2f		  ld a,'0'-1 
9001 3c			  inc a  
9002 09			  add hl,bc  
9003 38 fc		   jr c,$-2 
9005 12			  ld (de),a 
9006 13			  inc de 
9007			 
9007 7d			  ld a,l 
9008 26 3a		  ld h,'9'+1 
900a 25			  dec h  
900b c6 0a		  add a,10  
900d 30 fb		   jr nc,$-3 
900f c6 30		  add a,'0' 
9011 eb			  ex de,hl 
9012 72			  ld (hl),d 
9013 23			  inc hl 
9014 77			  ld (hl),a 
9015 23			  inc hl 
9016 36 00		  ld (hl),0 
9018			 
9018			;Now strip the leading zeros 
9018 0e fa		  ld c,-6 
901a 09			  add hl,bc 
901b 3e 30		  ld a,'0' 
901d 23			  inc hl  
901e be			  cp (hl)  
901f 28 fc		  jr z,$-2 
9021			 
9021			;Make sure that the string is non-empty! 
9021 7e			  ld a,(hl) 
9022 b7			  or a 
9023 20 01		  jr nz,.atoub 
9025 2b			  dec hl 
9026			.atoub: 
9026			 
9026 f1			  pop af 
9027 c1			  pop bc 
9028 d1			  pop de 
9029 c9			  ret 
902a			 
902a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
902a			 
902a			toUpper: 
902a			;A is the char. 
902a			;If A is a lowercase letter, this sets it to the matching uppercase 
902a			;18cc or 30cc or 41cc 
902a			;avg: 26.75cc 
902a fe 61		  cp 'a' 
902c d8			  ret c 
902d fe 7b		  cp 'z'+1 
902f d0			  ret nc 
9030 d6 20		  sub 'a'-'A' 
9032 c9			  ret 
9033			 
9033			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9033			 
9033			; String Length 
9033			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9033			 
9033			; Get the length of the null-terminated string starting at $8000 hl 
9033			;    LD     HL, $8000 
9033			 
9033			strlenz: 
9033			 
9033 af			    XOR    A               ; Zero is the value we are looking for. 
9034 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9035 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9036			                           ; 65, 536 bytes (the entire addressable memory space). 
9036 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9038			 
9038			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9038 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9039 6f			    LD     L, A             ; number of bytes 
903a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
903c 2b			    DEC    HL              ; Compensate for null. 
903d c9				ret 
903e			 
903e			; Get the length of the A terminated string starting at $8000 hl 
903e			;    LD     HL, $8000 
903e			 
903e			strlent: 
903e			 
903e			                  ; A is the value we are looking for. 
903e 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9040 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9042			                           ; 65, 536 bytes (the entire addressable memory space). 
9042 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9044			 
9044			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9044 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9046 2e 00		    LD     L, 0             ; number of bytes 
9048 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
904a 2b			    DEC    HL              ; Compensate for null. 
904b c9				ret 
904c			 
904c			 
904c			;Comparing Strings 
904c			 
904c			;IN    HL     Address of string1. 
904c			;      DE     Address of string2. 
904c			 
904c			; doc given but wrong??? 
904c			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
904c			;      carry  Set if string1 > string2, reset if string1 <= string2. 
904c			; tested 
904c			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
904c			 
904c			strcmp_old: 
904c e5			    PUSH   HL 
904d d5			    PUSH   DE 
904e			 
904e 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
904f be			    CP     (HL)            ; (want to minimize work). 
9050 38 01		    JR     C, Str1IsBigger 
9052 7e			    LD     A, (HL) 
9053			 
9053			Str1IsBigger: 
9053 4f			    LD     C, A             ; Put length in BC 
9054 06 00		    LD     B, 0 
9056 13			    INC    DE              ; Increment pointers to meat of string. 
9057 23			    INC    HL 
9058			 
9058			CmpLoop: 
9058 1a			    LD     A, (DE)          ; Compare bytes. 
9059 ed a1		    CPI 
905b 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
905d 13			    INC    DE              ; Update pointer. 
905e ea 58 90		    JP     PE, CmpLoop 
9061			 
9061 d1			    POP    DE 
9062 e1			    POP    HL 
9063 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9064 be			    CP     (HL) 
9065 c9			    RET 
9066			 
9066			NoMatch: 
9066 2b			    DEC    HL 
9067 be			    CP     (HL)            ; Compare again to affect carry. 
9068 d1			    POP    DE 
9069 e1			    POP    HL 
906a c9			    RET 
906b			 
906b			;; test strmp 
906b			; 
906b			;ld de, .str1 
906b			;ld hl, .str2 
906b			;call strcmp 
906b			;jr z, .z1 
906b			;;this 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "NZ1" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			;.z1: 
906b			; 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "ZZ1" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			; 
906b			;ld de, .str1 
906b			;ld hl, .str1 
906b			;call strcmp 
906b			;jr z, .z2 
906b			;;this 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "NZ2" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			;.z2: 
906b			; 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "ZZ2" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			; 
906b			;ld de, .str1 
906b			;ld hl, .str2 
906b			;call strcmp 
906b			;jr c, .c1 
906b			; 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "Nc1" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			;.c1: 
906b			;;this 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "cc1" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			; 
906b			;ld de, .str1 
906b			;ld hl, .str1 
906b			;call strcmp 
906b			;jr c, .c2 
906b			;;this 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "Nc2" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			;.c2: 
906b			; 
906b			;	if DEBUG_FORTH_WORDS 
906b			;		DMARK "cc2" 
906b			;		CALLMONITOR 
906b			;	endif 
906b			;	NEXTW 
906b			;.str1:   db "string1",0 
906b			;.str2:   db "string2",0 
906b			 
906b			; only care about direct match or not 
906b			; hl and de strings 
906b			; zero set if the same 
906b			 
906b			strcmp: 
906b 1a				ld a, (de) 
906c be				cp (hl) 
906d 28 02			jr z, .ssame 
906f b7				or a 
9070 c9				ret 
9071			 
9071			.ssame:  
9071			;	cp 0 
9071 b7				or a 
9072 c8				ret z 
9073			 
9073 23				inc hl 
9074 13				inc de 
9075 18 f4			jr strcmp 
9077				 
9077				 
9077			 
9077			;Copyright (c) 2014, Luke Maurits 
9077			;All rights reserved. 
9077			; 
9077			;Redistribution and use in source and binary forms, with or without 
9077			;modification, are permitted provided that the following conditions are met: 
9077			; 
9077			;* Redistributions of source code must retain the above copyright notice, this 
9077			;  list of conditions and the following disclaimer. 
9077			; 
9077			;* Redistributions in binary form must reproduce the above copyright notice, 
9077			;  this list of conditions and the following disclaimer in the documentation 
9077			;  and/or other materials provided with the distribution. 
9077			; 
9077			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9077			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9077			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9077			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9077			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9077			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9077			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9077			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9077			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9077			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9077			 
9077			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9077			 
9077			StrictStrCmp: 
9077				; Load next chars of each string 
9077 1a				ld a, (de) 
9078 47				ld b, a 
9079 7e				ld a, (hl) 
907a				; Compare 
907a b8				cp b 
907b				; Return non-zero if chars don't match 
907b c0				ret nz 
907c				; Check for end of both strings 
907c fe 00			cp "\0" 
907e				; Return if strings have ended 
907e c8				ret z 
907f				; Otherwise, advance to next chars 
907f 23				inc hl 
9080 13				inc de 
9081 18 f4			jr StrictStrCmp 
9083			 
9083			;end 
9083			; eof 
9083			 
9083			 
9083			 
9083			 
9083			 
9083			 
# End of file firmware_strings.asm
9083			include "firmware_memory.asm"   ; malloc and free  
9083			 
9083			if DEBUG_FORTH_MALLOC_HIGH 
9083			.mallocsize: db "Wants malloc >256",0 
9083			.mallocasize: db "MALLOC gives >256",0 
9083			.malloczero: db "MALLOC gives zero",0 
9083			 
9083			malloc_guard_zerolen: 
9083				push hl 
9083				push de 
9083				push af 
9083			 
9083				ld de, 0 
9083			        call cmp16 
9083				jr nz, .lowalloz 
9083			 
9083				push hl 
9083				push de 
9083					ld hl, display_fb0 
9083					ld (display_fb_active), hl 
9083				call clear_display 
9083				ld a, 0 
9083				ld de, .malloczero 
9083				call str_at_display 
9083				call update_display 
9083				call delay1s 
9083				call delay1s 
9083				call bp_on 
9083			;	ld a, 0 
9083			;	ld (os_view_disable), a 
9083			 
9083				pop de 
9083				pop hl 
9083			 
9083				 
9083			 
9083				CALLMONITOR 
9083			.lowalloz: 
9083			 
9083			 
9083				pop af 
9083				pop de 
9083				pop hl 
9083			ret 
9083			 
9083			malloc_guard_entry: 
9083				push hl 
9083				push de 
9083				push af 
9083			 
9083			 	or a      ;clear carry flag 
9083				push hl 
9083				ld de, 255 
9083				sbc hl, de 
9083				jr c, .lowalloc 
9083			 
9083				push de 
9083					ld hl, display_fb0 
9083					ld (display_fb_active), hl 
9083				call clear_display 
9083				ld a, 0 
9083				ld de, .mallocsize 
9083				call str_at_display 
9083				call update_display 
9083				call delay1s 
9083				call delay1s 
9083			;	ld a, 0 
9083			;	ld (os_view_disable), a 
9083				call bp_on 
9083			 
9083				pop de 
9083				pop hl 
9083			 
9083				 
9083			 
9083				CALLMONITOR 
9083				jr .lowdone 
9083			.lowalloc: 
9083			 
9083			 
9083				pop hl 
9083			.lowdone:	pop af 
9083				pop de 
9083				pop hl 
9083			ret 
9083			 
9083			malloc_guard_exit: 
9083				push hl 
9083				push de 
9083				push af 
9083			 
9083			 	or a      ;clear carry flag 
9083				push hl 
9083				ld de, 255 
9083				sbc hl, de 
9083				jr c, .lowallocx 
9083			 
9083				push de 
9083					ld hl, display_fb0 
9083					ld (display_fb_active), hl 
9083				call clear_display 
9083				ld a, 0 
9083				ld de, .mallocasize 
9083				call str_at_display 
9083				call update_display 
9083				call delay1s 
9083				call delay1s 
9083			;	ld a, 0 
9083			;	ld (os_view_disable), a 
9083				call bp_on 
9083				pop de 
9083				pop hl 
9083			 
9083				CALLMONITOR 
9083				jr .lowdonex 
9083			.lowallocx: 
9083			 
9083				pop hl 
9083			.lowdonex:	pop af 
9083				pop de 
9083				pop hl 
9083			ret 
9083			endif 
9083			 
9083			if MALLOC_2 
9083			; Z80 Malloc and Free Functions 
9083			 
9083			; Malloc Function: 
9083			; Input: 
9083			;   HL: Size of block to allocate 
9083			; Output: 
9083			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9083			 
9083			malloc: 
9083				 
9083			if DEBUG_FORTH_MALLOC_HIGH 
9083			call malloc_guard_entry 
9083			endif 
9083			 
9083			 
9083			 
9083			 
9083					if DEBUG_FORTH_MALLOC 
9083						DMARK "mal" 
9083						CALLMONITOR 
9083					endif 
9083			    push af            ; Save AF register 
9083			    ld a, l            ; Load low byte of size into A 
9083			    or h               ; Check if size is zero 
9083			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9083			 
9083			    ; Allocate memory 
9083			    ld hl, (heap_start) ; Load start of heap into HL 
9083					if DEBUG_FORTH_MALLOC 
9083						DMARK "ma1" 
9083						CALLMONITOR 
9083					endif 
9083			    call malloc_internal ; Call internal malloc function 
9083			    pop af             ; Restore AF register 
9083			if DEBUG_FORTH_MALLOC_HIGH 
9083			call malloc_guard_exit 
9083			call malloc_guard_zerolen 
9083			endif 
9083			    ret                ; Return 
9083			 
9083			; Free Function: 
9083			; Input: 
9083			;   HL: Pointer to memory block to free 
9083			; Output: 
9083			;   None 
9083			 
9083			free: 
9083			    push af            ; Save AF register 
9083			    ld a, l            ; Load low byte of pointer into A 
9083			    or h               ; Check if pointer is NULL 
9083			    jp z, free_exit    ; If pointer is NULL, exit 
9083			 
9083			    ; Free memory 
9083			    ld hl, (heap_start) ; Load start of heap into HL 
9083			    call free_internal  ; Call internal free function 
9083			    pop af             ; Restore AF register 
9083			    ret                ; Return 
9083			 
9083			; Internal Malloc Function: 
9083			; Input: 
9083			;   HL: Size of block to allocate 
9083			; Output: 
9083			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9083			 
9083			malloc_internal: 
9083			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9083			    add hl, bc         ; Add management overhead to requested size 
9083			    ex de, hl          ; Save total size in DE, and keep it in HL 
9083					if DEBUG_FORTH_MALLOC 
9083						DMARK "ma2" 
9083						CALLMONITOR 
9083					endif 
9083			 
9083			    ; Search for free memory block 
9083			    ld de, (heap_end)  ; Load end of heap into DE 
9083			    ld bc, 0           ; Initialize counter 
9083			 
9083					if DEBUG_FORTH_MALLOC 
9083						DMARK "ma2" 
9083						CALLMONITOR 
9083					endif 
9083			malloc_search_loop: 
9083			    ; Check if current block is free 
9083			    ld a, (hl)         ; Load current block's status (free or used) 
9083			;    cp 0               ; Compare with zero (free) 
9083				or a 
9083			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9083			 
9083			    ; Check if current block is large enough 
9083			    ld a, (hl+1)       ; Load high byte of block size 
9083			    cp l               ; Compare with low byte of requested size 
9083			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9083			 
9083			    ld a, (hl+2)       ; Load low byte of block size 
9083			    cp h               ; Compare with high byte of requested size 
9083			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9083			 
9083			    ; Mark block as used 
9083			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9083			 
9083			    ; Calculate remaining space in block 
9083			    ld bc, 0           ; Clear BC 
9083			    add hl, bc         ; Increment HL to point to start of data block 
9083			    add hl, de         ; HL = HL + DE (total size) 
9083			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9083			    add hl, bc         ; Add management overhead to start of data block 
9083			 
9083			    ; Save pointer to allocated block in HL 
9083			if DEBUG_FORTH_MALLOC_HIGH 
9083						DMARK "ma5" 
9083			call malloc_guard_exit 
9083			call malloc_guard_zerolen 
9083			endif 
9083			    ret 
9083			 
9083			malloc_skip_block_check: 
9083			    ; Move to the next block 
9083			    ld bc, 3           ; Size of management overhead 
9083			    add hl, bc         ; Move to the next block 
9083			    inc de             ; Increment counter 
9083			 
9083			    ; Check if we have reached the end of heap 
9083			    ld a, e            ; Load low byte of heap end address 
9083			    cp (hl)            ; Compare with low byte of current address 
9083			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9083			    ld a, d            ; Load high byte of heap end address 
9083			;    cp 0               ; Check if it's zero (end of memory) 
9083				or a 
9083			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9083			 
9083			    ; If we reached here, allocation failed 
9083			    xor a              ; Set result to NULL 
9083			if DEBUG_FORTH_MALLOC_HIGH 
9083						DMARK "ma6" 
9083			call malloc_guard_exit 
9083			call malloc_guard_zerolen 
9083			endif 
9083			    ret 
9083			malloc_exit: 
9083			if DEBUG_FORTH_MALLOC_HIGH 
9083						DMARK "ma7" 
9083			call malloc_guard_exit 
9083			call malloc_guard_zerolen 
9083			endif 
9083			    ret 
9083			 
9083			; Internal Free Function: 
9083			; Input: 
9083			;   HL: Pointer to memory block to free 
9083			; Output: 
9083			;   None 
9083			 
9083			free_internal: 
9083			    ld de, (heap_start) ; Load start of heap into DE 
9083			    ld bc, 0            ; Initialize counter 
9083			 
9083			free_search_loop: 
9083			    ; Check if current block contains the pointer 
9083			    ld a, l             ; Load low byte of pointer 
9083			    cp (hl+1)           ; Compare with high byte of current block's address 
9083			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9083			    ld a, h             ; Load high byte of pointer 
9083			    cp (hl+2)           ; Compare with low byte of current block's address 
9083			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9083			 
9083			    ; Mark block as free 
9083			    ld (hl), 0          ; Set status byte to indicate free block 
9083			    ret                 ; Return 
9083			 
9083			free_skip_block_check: 
9083			    ; Move to the next block 
9083			    ld bc, 3            ; Size of management overhead 
9083			    add hl, bc          ; Move to the next block 
9083			    inc de              ; Increment counter 
9083			 
9083			    ; Check if we have reached the end of heap 
9083			    ld a, e             ; Load low byte of heap end address 
9083			    cp (hl)             ; Compare with low byte of current address 
9083			    jr nz, free_search_loop  ; If not equal, continue searching 
9083			    ld a, d             ; Load high byte of heap end address 
9083			;    cp 0                ; Check if it's zero (end of memory) 
9083				or a 
9083			    jr nz, free_search_loop  ; If not zero, continue searching 
9083			 
9083			    ; If we reached here, pointer is not found in heap 
9083			    ret 
9083			 
9083			free_exit: 
9083			    ret                 ; Return 
9083			 
9083			; Define heap start and end addresses 
9083			;heap_start:    .dw 0xC000   ; Start of heap 
9083			;heap_end:      .dw 0xE000   ; End of heap 
9083			 
9083			endif 
9083			 
9083			 
9083			if MALLOC_1 
9083			 
9083			 
9083			 
9083			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9083			 
9083			;moved to firmware.asm 
9083			;heap_start        .equ  0x9000      ; Starting address of heap 
9083			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9083			 
9083			;      .org 0 
9083			;      jp    main 
9083			 
9083			 
9083			;      .org  0x100 
9083			;main: 
9083			;      ld    HL, 0x8100 
9083			;      ld    SP, HL 
9083			; 
9083			;      call  heap_init 
9083			; 
9083			;      ; Make some allocations 
9083			;      ld    HL, 12 
9083			;      call  malloc            ; Allocates 0x9004 
9083			; 
9083			;      ld    HL, 12 
9083			;      call  malloc            ; Allocates 0x9014 
9083			; 
9083			;      ld    HL, 12 
9083			;      call  malloc            ; Allocates 0x9024 
9083			; 
9083			;      ; Free some allocations 
9083			;      ld    HL, 0x9014 
9083			;      call  free 
9083			; 
9083			;      ld    HL, 0x9004 
9083			;      call  free 
9083			; 
9083			;      ld    HL, 0x9024 
9083			;      call  free 
9083			; 
9083			; 
9083			;      halt 
9083			 
9083			 
9083			;------------------------------------------------------------------------------ 
9083			;     heap_init                                                               : 
9083			;                                                                             : 
9083			; Description                                                                 : 
9083			;     Initialise the heap and make it ready for malloc and free operations.   : 
9083			;                                                                             : 
9083			;     The heap is maintained as a linked list, starting with an initial       : 
9083			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9083			;     the first free block in the heap. Each block then points to the next    : 
9083			;     free block within the heap, and the free list ends at the first block   : 
9083			;     with a null pointer to the next free block.                             : 
9083			;                                                                             : 
9083			; Parameters                                                                  : 
9083			;     Inputs are compile-time only. Two defines which specify the starting    : 
9083			;     address of the heap and its size are required, along with a memory      : 
9083			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9083			;     principally stores a pointer to the first free block in the heap.       : 
9083			;                                                                             : 
9083			; Returns                                                                     : 
9083			;     Nothing                                                                 : 
9083			;------------------------------------------------------------------------------ 
9083			heap_init: 
9083 e5			      push  HL 
9084			 
9084			      ; Initialise free list struct 
9084 21 4b e6		      ld    HL, heap_start 
9087 22 46 e6		      ld    (free_list), HL 
908a 21 00 00		      ld    HL, 0 
908d 22 48 e6		      ld    (free_list+2), HL 
9090			 
9090			      ; Insert first free block at bottom of heap, consumes entire heap 
9090 21 8b e2		      ld    HL, heap_start+heap_size-4 
9093 22 4b e6		      ld    (heap_start), HL        ; Next block (end of free list) 
9096 21 40 fc		      ld    HL, heap_size-4 
9099 22 4d e6		      ld    (heap_start+2), HL      ; Block size 
909c			 
909c			      ; Insert end of free list block at top of heap - two null words will 
909c			      ; terminate the free list 
909c 21 00 00		      ld    HL, 0 
909f 22 8d e2		      ld    (heap_start+heap_size-2), HL 
90a2 22 8b e2		      ld    (heap_start+heap_size-4), HL 
90a5			 
90a5 e1			      pop   HL 
90a6			 
90a6 c9			      ret 
90a7			 
90a7			 
90a7			;------------------------------------------------------------------------------ 
90a7			;     malloc                                                                  : 
90a7			;                                                                             : 
90a7			; Description                                                                 : 
90a7			;     Allocates the wanted space from the heap and returns the address of the : 
90a7			;     first useable byte of the allocation.                                   : 
90a7			;                                                                             : 
90a7			;     Allocations can happen in one of two ways:                              : 
90a7			;                                                                             : 
90a7			;     1. A free block may be found which is the exact size wanted. In this    : 
90a7			;        case the block is removed from the free list and retuedn to the      : 
90a7			;        caller.                                                              : 
90a7			;     2. A free block may be found which is larger than the size wanted. In   : 
90a7			;        this case, the larger block is split into two. The first portion of  : 
90a7			;        this block will become the requested space by the malloc call and    : 
90a7			;        is returned to the caller. The second portion becomes a new free     : 
90a7			;        block, and the free list is adjusted to maintain continuity via this : 
90a7			;        newly created block.                                                 : 
90a7			;                                                                             : 
90a7			;     malloc does not set any initial value in the allocated space, the       : 
90a7			;     caller is required to do this as required.                              : 
90a7			;                                                                             : 
90a7			;     This implementation of malloc uses the stack exclusively, and is        : 
90a7			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90a7			;     advisable to disable interrupts before calling malloc, and recommended  : 
90a7			;     to avoid the use of malloc inside ISRs in general.                      : 
90a7			;                                                                             : 
90a7			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90a7			;                                                                             : 
90a7			; Parameters                                                                  : 
90a7			;     HL  Number of bytes wanted                                              : 
90a7			;                                                                             : 
90a7			; Returns                                                                     : 
90a7			;     HL  Address of the first useable byte of the allocation                 : 
90a7			;                                                                             : 
90a7			; Flags                                                                       : 
90a7			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90a7			;                                                                             : 
90a7			; Stack frame                                                                 : 
90a7			;       |             |                                                       : 
90a7			;       +-------------+                                                       : 
90a7			;       |     BC      |                                                       : 
90a7			;       +-------------+                                                       : 
90a7			;       |     DE      |                                                       : 
90a7			;       +-------------+                                                       : 
90a7			;       |     IX      |                                                       : 
90a7			;       +-------------+                                                       : 
90a7			;       |  prev_free  |                                                       : 
90a7			;   +4  +-------------+                                                       : 
90a7			;       |  this_free  |                                                       : 
90a7			;   +2  +-------------+                                                       : 
90a7			;       |  next_free  |                                                       : 
90a7			;   +0  +-------------+                                                       : 
90a7			;       |             |                                                       : 
90a7			;                                                                             : 
90a7			;------------------------------------------------------------------------------ 
90a7			 
90a7			 
90a7			;malloc: 
90a7			; 
90a7			;	SAVESP ON 1 
90a7			; 
90a7			;	call malloc_code 
90a7			; 
90a7			;	CHECKSP ON 1 
90a7			;	ret 
90a7			 
90a7			 
90a7			malloc: 
90a7 c5			      push  BC 
90a8 d5			      push  DE 
90a9 dd e5		      push  IX 
90ab			if DEBUG_FORTH_MALLOC_HIGH 
90ab			call malloc_guard_entry 
90ab			endif 
90ab			 
90ab					if DEBUG_FORTH_MALLOC 
90ab						DMARK "mal" 
90ab						CALLMONITOR 
90ab					endif 
90ab 7c			      ld    A, H                    ; Exit if no space requested 
90ac b5			      or    L 
90ad ca 6c 91		      jp    Z, malloc_early_exit 
90b0			 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			; 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			;inc hl 
90b0			 
90b0			 
90b0			 
90b0			 
90b0					if DEBUG_FORTH_MALLOC 
90b0						DMARK "maA" 
90b0						CALLMONITOR 
90b0					endif 
90b0			      ; Set up stack frame 
90b0 eb			      ex    DE, HL 
90b1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90b4 39			      add   HL, SP 
90b5 f9			      ld    SP, HL 
90b6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90ba dd 39		      add   IX, SP 
90bc			 
90bc			      ; Setup initial state 
90bc 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90bf 19			      add   HL, DE 
90c0			 
90c0 44			      ld    B, H                    ; Move want to BC 
90c1 4d			      ld    C, L 
90c2			 
90c2 21 46 e6		      ld    HL, free_list           ; Store prev_free ptr to stack 
90c5 dd 75 04		      ld    (IX+4), L 
90c8 dd 74 05		      ld    (IX+5), H 
90cb			 
90cb 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90cc 23			      inc   HL 
90cd 56			      ld    D, (HL) 
90ce dd 73 02		      ld    (IX+2), E 
90d1 dd 72 03		      ld    (IX+3), D 
90d4 eb			      ex    DE, HL                  ; this_free ptr into HL 
90d5			 
90d5					if DEBUG_FORTH_MALLOC 
90d5						DMARK "maB" 
90d5						CALLMONITOR 
90d5					endif 
90d5			      ; Loop through free block list to find some space 
90d5			malloc_find_space: 
90d5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90d6 23			      inc   HL 
90d7 56			      ld    D, (HL) 
90d8			 
90d8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90d9 b3			      or    E 
90da ca 66 91		      jp    Z, malloc_no_space 
90dd			 
90dd dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90e0 dd 72 01		      ld    (IX+1), D 
90e3			 
90e3			      ; Does this block have enough space to make the allocation? 
90e3 23			      inc   HL                      ; Load free block size into DE 
90e4 5e			      ld    E, (HL) 
90e5 23			      inc   HL 
90e6 56			      ld    D, (HL) 
90e7			 
90e7 eb			      ex    DE, HL                  ; Check size of block against want 
90e8 b7			      or    A                       ; Ensure carry flag clear 
90e9 ed 42		      sbc   HL, BC 
90eb e5			      push  HL                      ; Store the result for later (new block size) 
90ec			 
90ec ca 3b 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90ef 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
90f1			 
90f1			      ; this_free block is not big enough, setup ptrs to test next free block 
90f1 e1			      pop   HL                      ; Discard previous result 
90f2			 
90f2 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
90f5 dd 66 03		      ld    H, (IX+3) 
90f8 dd 75 04		      ld    (IX+4), L 
90fb dd 74 05		      ld    (IX+5), H 
90fe			 
90fe dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9101 dd 66 01		      ld    H, (IX+1) 
9104 dd 75 02		      ld    (IX+2), L 
9107 dd 74 03		      ld    (IX+3), H 
910a			 
910a					if DEBUG_FORTH_MALLOC 
910a						DMARK "MA>" 
910a						CALLMONITOR 
910a					endif 
910a 18 c9		      jr    malloc_find_space 
910c			 
910c			      ; split a bigger block into two - requested size and remaining size 
910c			malloc_alloc_split: 
910c					if DEBUG_FORTH_MALLOC 
910c						DMARK "MAs" 
910c						CALLMONITOR 
910c					endif 
910c eb			      ex    DE, HL                  ; Calculate address of new free block 
910d 2b			      dec   HL 
910e 2b			      dec   HL 
910f 2b			      dec   HL 
9110 09			      add   HL, BC 
9111			 
9111			      ; Create a new block and point it at next_free 
9111 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9114 dd 56 01		      ld    D, (IX+1) 
9117			 
9117 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9118 23			      inc   HL 
9119 72			      ld    (HL), D 
911a			 
911a d1			      pop   DE                      ; Store size of new block into new block 
911b 23			      inc   HL 
911c 73			      ld    (HL), E 
911d 23			      inc   HL 
911e 72			      ld    (HL), D 
911f			 
911f			      ; Update this_free ptr to point to new block 
911f 2b			      dec   HL 
9120 2b			      dec   HL 
9121 2b			      dec   HL 
9122			 
9122 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9125 dd 56 03		      ld    D, (IX+3) 
9128			 
9128 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
912b dd 74 03		      ld    (IX+3), H 
912e			 
912e			      ; Modify this_free block to be allocation 
912e eb			      ex    DE, HL 
912f af			      xor   A                       ; Null the next block ptr of allocated block 
9130 77			      ld    (HL), A 
9131 23			      inc   HL 
9132 77			      ld    (HL), A 
9133			 
9133 23			      inc   HL                      ; Store want size into allocated block 
9134 71			      ld    (HL), C 
9135 23			      inc   HL 
9136 70			      ld    (HL), B 
9137 23			      inc   HL 
9138 e5			      push  HL                      ; Address of allocation to return 
9139			 
9139 18 19		      jr    malloc_update_links 
913b			 
913b			malloc_alloc_fit: 
913b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
913c			 
913c					if DEBUG_FORTH_MALLOC 
913c						DMARK "MAf" 
913c						CALLMONITOR 
913c					endif 
913c			      ; Modify this_free block to be allocation 
913c eb			      ex    DE, HL 
913d 2b			      dec   HL 
913e 2b			      dec   HL 
913f 2b			      dec   HL 
9140			 
9140 af			      xor   A                       ; Null the next block ptr of allocated block 
9141 77			      ld    (HL), A 
9142 23			      inc   HL 
9143 77			      ld    (HL), A 
9144			 
9144 23			      inc   HL                      ; Store address of allocation to return 
9145 23			      inc   HL 
9146 23			      inc   HL 
9147 e5			      push  HL 
9148			 
9148			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9148 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
914b dd 66 01		      ld    H, (IX+1) 
914e			 
914e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9151 dd 74 03		      ld    (IX+3), H 
9154			 
9154			 
9154			malloc_update_links: 
9154			      ; Update prev_free ptr to point to this_free 
9154 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9157 dd 66 05		      ld    H, (IX+5) 
915a			 
915a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
915d dd 56 03		      ld    D, (IX+3) 
9160			 
9160 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9161 23			      inc   HL 
9162 72			      ld    (HL), D 
9163			 
9163					if DEBUG_FORTH_MALLOC 
9163						DMARK "Mul" 
9163						CALLMONITOR 
9163					endif 
9163			      ; Clear the Z flag to indicate successful allocation 
9163 7a			      ld    A, D 
9164 b3			      or    E 
9165			 
9165 d1			      pop   DE                      ; Address of allocation 
9166					if DEBUG_FORTH_MALLOC 
9166						DMARK "MAu" 
9166						CALLMONITOR 
9166					endif 
9166			 
9166			malloc_no_space: 
9166 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9169 39			      add   HL, SP 
916a f9			      ld    SP, HL 
916b			 
916b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
916c					if DEBUG_FORTH_MALLOC 
916c						DMARK "MAN" 
916c						CALLMONITOR 
916c					endif 
916c			 
916c			malloc_early_exit: 
916c					if DEBUG_FORTH_MALLOC 
916c						DMARK "MAx" 
916c						CALLMONITOR 
916c					endif 
916c dd e1		      pop   IX 
916e d1			      pop   DE 
916f c1			      pop   BC 
9170			 
9170			if DEBUG_FORTH_MALLOC_HIGH 
9170			call malloc_guard_exit 
9170			call malloc_guard_zerolen 
9170			endif 
9170 c9			      ret 
9171			 
9171			 
9171			;------------------------------------------------------------------------------ 
9171			;     free                                                                    : 
9171			;                                                                             : 
9171			; Description                                                                 : 
9171			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9171			;     returned by malloc, otherwise the behaviour is undefined.               : 
9171			;                                                                             : 
9171			;     Where possible, directly adjacent free blocks will be merged together   : 
9171			;     into larger blocks to help ensure that the heap does not become         : 
9171			;     excessively fragmented.                                                 : 
9171			;                                                                             : 
9171			;     free does not clear or set any other value into the freed space, and    : 
9171			;     therefore its contents may be visible through subsequent malloc's. The  : 
9171			;     caller should clear the freed space as required.                        : 
9171			;                                                                             : 
9171			;     This implementation of free uses the stack exclusively, and is          : 
9171			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9171			;     advisable to disable interrupts before calling free, and recommended    : 
9171			;     to avoid the use of free inside ISRs in general.                        : 
9171			;                                                                             : 
9171			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9171			;                                                                             : 
9171			; Parameters                                                                  : 
9171			;     HL  Pointer to address of first byte of allocation to be freed          : 
9171			;                                                                             : 
9171			; Returns                                                                     : 
9171			;     Nothing                                                                 : 
9171			;                                                                             : 
9171			; Stack frame                                                                 : 
9171			;       |             |                                                       : 
9171			;       +-------------+                                                       : 
9171			;       |     BC      |                                                       : 
9171			;       +-------------+                                                       : 
9171			;       |     DE      |                                                       : 
9171			;       +-------------+                                                       : 
9171			;       |     IX      |                                                       : 
9171			;       +-------------+                                                       : 
9171			;       |  prev_free  |                                                       : 
9171			;   +2  +-------------+                                                       : 
9171			;       |  next_free  |                                                       : 
9171			;   +0  +-------------+                                                       : 
9171			;       |             |                                                       : 
9171			;                                                                             : 
9171			;------------------------------------------------------------------------------ 
9171			free: 
9171 c5			      push  BC 
9172 d5			      push  DE 
9173 dd e5		      push  IX 
9175			 
9175 7c			      ld    A, H                    ; Exit if ptr is null 
9176 b5			      or    L 
9177 ca 3b 92		      jp    Z, free_early_exit 
917a			 
917a			      ; Set up stack frame 
917a eb			      ex    DE, HL 
917b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
917e 39			      add   HL, SP 
917f f9			      ld    SP, HL 
9180 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9184 dd 39		      add   IX, SP 
9186			 
9186			      ; The address in HL points to the start of the useable allocated space, 
9186			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9186			      ; address of the block itself. 
9186 eb			      ex    DE, HL 
9187 11 fc ff		      ld    DE, -4 
918a 19			      add   HL, DE 
918b			 
918b			      ; An allocated block must have a null next block pointer in it 
918b 7e			      ld    A, (HL) 
918c 23			      inc   HL 
918d b6			      or    (HL) 
918e c2 36 92		      jp    NZ, free_done 
9191			 
9191 2b			      dec   HL 
9192			 
9192 44			      ld    B, H                    ; Copy HL to BC 
9193 4d			      ld    C, L 
9194			 
9194			      ; Loop through the free list to find the first block with an address 
9194			      ; higher than the block being freed 
9194 21 46 e6		      ld    HL, free_list 
9197			 
9197			free_find_higher_block: 
9197 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9198 23			      inc   HL 
9199 56			      ld    D, (HL) 
919a 2b			      dec   HL 
919b			 
919b dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
919e dd 72 01		      ld    (IX+1), D 
91a1 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91a4 dd 74 03		      ld    (IX+3), H 
91a7			 
91a7 78			      ld    A, B                    ; Check if DE is greater than BC 
91a8 ba			      cp    D                       ; Compare MSB first 
91a9 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91ab 30 04		      jr    NC, free_find_higher_block_skip 
91ad 79			      ld    A, C 
91ae bb			      cp    E                       ; Then compare LSB 
91af 38 08		      jr    C, free_found_higher_block 
91b1			 
91b1			free_find_higher_block_skip: 
91b1 7a			      ld    A, D                    ; Reached the end of the free list? 
91b2 b3			      or    E 
91b3 ca 36 92		      jp    Z, free_done 
91b6			 
91b6 eb			      ex    DE, HL 
91b7			 
91b7 18 de		      jr    free_find_higher_block 
91b9			 
91b9			free_found_higher_block: 
91b9			      ; Insert freed block between prev and next free blocks 
91b9 71			      ld    (HL), C                 ; Point prev free block to freed block 
91ba 23			      inc   HL 
91bb 70			      ld    (HL), B 
91bc			 
91bc 60			      ld    H, B                    ; Point freed block at next free block 
91bd 69			      ld    L, C 
91be 73			      ld    (HL), E 
91bf 23			      inc   HL 
91c0 72			      ld    (HL), D 
91c1			 
91c1			      ; Check if the freed block is adjacent to the next free block 
91c1 23			      inc   HL                      ; Load size of freed block into HL 
91c2 5e			      ld    E, (HL) 
91c3 23			      inc   HL 
91c4 56			      ld    D, (HL) 
91c5 eb			      ex    DE, HL 
91c6			 
91c6 09			      add   HL, BC                  ; Add addr of freed block and its size 
91c7			 
91c7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91ca dd 56 01		      ld    D, (IX+1) 
91cd			 
91cd b7			      or    A                       ; Clear the carry flag 
91ce ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91d0 20 22		      jr    NZ, free_check_adjacent_to_prev 
91d2			 
91d2			      ; Freed block is adjacent to next, merge into one bigger block 
91d2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91d3 5e			      ld    E, (HL) 
91d4 23			      inc   HL 
91d5 56			      ld    D, (HL) 
91d6 e5			      push  HL                      ; Save ptr to next block for later 
91d7			 
91d7 60			      ld    H, B                    ; Store ptr from next block into freed block 
91d8 69			      ld    L, C 
91d9 73			      ld    (HL), E 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc e1			      pop   HL                      ; Restore ptr to next block 
91dd 23			      inc   HL                      ; Load size of next block into DE 
91de 5e			      ld    E, (HL) 
91df 23			      inc   HL 
91e0 56			      ld    D, (HL) 
91e1 d5			      push  DE                      ; Save next block size for later 
91e2			 
91e2 60			      ld    H, B                    ; Load size of freed block into HL 
91e3 69			      ld    L, C 
91e4 23			      inc   HL 
91e5 23			      inc   HL 
91e6 5e			      ld    E, (HL) 
91e7 23			      inc   HL 
91e8 56			      ld    D, (HL) 
91e9 eb			      ex    DE, HL 
91ea			 
91ea d1			      pop   DE                      ; Restore size of next block 
91eb 19			      add   HL, DE                  ; Add sizes of both blocks 
91ec eb			      ex    DE, HL 
91ed			 
91ed 60			      ld    H, B                    ; Store new bigger size into freed block 
91ee 69			      ld    L, C 
91ef 23			      inc   HL 
91f0 23			      inc   HL 
91f1 73			      ld    (HL), E 
91f2 23			      inc   HL 
91f3 72			      ld    (HL), D 
91f4			 
91f4			free_check_adjacent_to_prev: 
91f4			      ; Check if the freed block is adjacent to the prev free block 
91f4 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
91f7 dd 66 03		      ld    H, (IX+3) 
91fa			 
91fa 23			      inc   HL                      ; Size of prev free block into DE 
91fb 23			      inc   HL 
91fc 5e			      ld    E, (HL) 
91fd 23			      inc   HL 
91fe 56			      ld    D, (HL) 
91ff 2b			      dec   HL 
9200 2b			      dec   HL 
9201 2b			      dec   HL 
9202			 
9202 19			      add   HL, DE                  ; Add prev block addr and size 
9203			 
9203 b7			      or    A                       ; Clear the carry flag 
9204 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9206 20 2e		      jr    NZ, free_done 
9208			 
9208			      ; Freed block is adjacent to prev, merge into one bigger block 
9208 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9209 69			      ld    L, C 
920a 5e			      ld    E, (HL) 
920b 23			      inc   HL 
920c 56			      ld    D, (HL) 
920d e5			      push  HL                      ; Save freed block ptr for later 
920e			 
920e dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9211 dd 66 03		      ld    H, (IX+3) 
9214 73			      ld    (HL), E 
9215 23			      inc   HL 
9216 72			      ld    (HL), D 
9217			 
9217 e1			      pop   HL                      ; Restore freed block ptr 
9218 23			      inc   HL                      ; Load size of freed block into DE 
9219 5e			      ld    E, (HL) 
921a 23			      inc   HL 
921b 56			      ld    D, (HL) 
921c d5			      push  DE                      ; Save freed block size for later 
921d			 
921d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
9220 dd 66 03		      ld    H, (IX+3) 
9223 23			      inc   HL 
9224 23			      inc   HL 
9225 5e			      ld    E, (HL) 
9226 23			      inc   HL 
9227 56			      ld    D, (HL) 
9228			 
9228 e1			      pop   HL                      ; Add sizes of both blocks 
9229 19			      add   HL, DE 
922a eb			      ex    DE, HL 
922b			 
922b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
922e dd 66 03		      ld    H, (IX+3) 
9231 23			      inc   HL 
9232 23			      inc   HL 
9233 73			      ld    (HL), E 
9234 23			      inc   HL 
9235 72			      ld    (HL), D 
9236			 
9236			free_done: 
9236 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9239 39			      add   HL, SP 
923a f9			      ld    SP, HL 
923b			 
923b			free_early_exit: 
923b dd e1		      pop   IX 
923d d1			      pop   DE 
923e c1			      pop   BC 
923f			 
923f c9			      ret 
9240			 
9240			; moved to firmware.asm 
9240			; 
9240			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9240			;                  .dw   0 
9240			 
9240			 
9240			endif 
9240			 
9240			 
9240			if MALLOC_3 
9240			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9240			;heap_start        .equ  0x9000      ; Starting address of heap 
9240			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9240			; 
9240			 ;     .org 0 
9240			  ;    jp    main 
9240			; 
9240			; 
9240			 ;     .org  0x100 
9240			;main: 
9240			 ;     ld    HL, 0x8100 
9240			  ;    ld    SP, HL 
9240			; 
9240			;      call  heap_init 
9240			 
9240			      ; Make some allocations 
9240			;      ld    HL, 12 
9240			;      call  malloc            ; Allocates 0x9004 
9240			; 
9240			 ;     ld    HL, 12 
9240			;      call  malloc            ; Allocates 0x9014 
9240			 
9240			;      ld    HL, 12 
9240			;      call  malloc            ; Allocates 0x9024 
9240			 
9240			      ; Free some allocations 
9240			;      ld    HL, 0x9014 
9240			;      call  free 
9240			 
9240			;      ld    HL, 0x9004 
9240			;      call  free 
9240			; 
9240			;      ld    HL, 0x9024 
9240			;      call  free 
9240			 
9240			 
9240			 ;     halt 
9240			 
9240			 
9240			;------------------------------------------------------------------------------ 
9240			;     heap_init                                                               : 
9240			;                                                                             : 
9240			; Description                                                                 : 
9240			;     Initialise the heap and make it ready for malloc and free operations.   : 
9240			;                                                                             : 
9240			;     The heap is maintained as a linked list, starting with an initial       : 
9240			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9240			;     the first free block in the heap. Each block then points to the next    : 
9240			;     free block within the heap, and the free list ends at the first block   : 
9240			;     with a null pointer to the next free block.                             : 
9240			;                                                                             : 
9240			; Parameters                                                                  : 
9240			;     Inputs are compile-time only. Two defines which specify the starting    : 
9240			;     address of the heap and its size are required, along with a memory      : 
9240			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9240			;     principally stores a pointer to the first free block in the heap.       : 
9240			;                                                                             : 
9240			; Returns                                                                     : 
9240			;     Nothing                                                                 : 
9240			;------------------------------------------------------------------------------ 
9240			heap_init: 
9240			      push  HL 
9240			 
9240			      ; Initialise free list struct 
9240			      ld    HL, heap_start 
9240			      ld    (free_list), HL 
9240			      ld    HL, 0 
9240			      ld    (free_list+2), HL 
9240			 
9240			      ; Insert first free block at bottom of heap, consumes entire heap 
9240			      ld    HL, heap_start+heap_size-4 
9240			      ld    (heap_start), HL        ; Next block (end of free list) 
9240			      ld    HL, heap_size-4 
9240			      ld    (heap_start+2), HL      ; Block size 
9240			 
9240			      ; Insert end of free list block at top of heap - two null words will 
9240			      ; terminate the free list 
9240			      ld    HL, 0 
9240			      ld    (heap_start+heap_size-2), HL 
9240			      ld    (heap_start+heap_size-4), HL 
9240			 
9240			      pop   HL 
9240			 
9240			      ret 
9240			 
9240			 
9240			;------------------------------------------------------------------------------ 
9240			;     malloc                                                                  : 
9240			;                                                                             : 
9240			; Description                                                                 : 
9240			;     Allocates the wanted space from the heap and returns the address of the : 
9240			;     first useable byte of the allocation.                                   : 
9240			;                                                                             : 
9240			;     Allocations can happen in one of two ways:                              : 
9240			;                                                                             : 
9240			;     1. A free block may be found which is the exact size wanted. In this    : 
9240			;        case the block is removed from the free list and retuedn to the      : 
9240			;        caller.                                                              : 
9240			;     2. A free block may be found which is larger than the size wanted. In   : 
9240			;        this case, the larger block is split into two. The first portion of  : 
9240			;        this block will become the requested space by the malloc call and    : 
9240			;        is returned to the caller. The second portion becomes a new free     : 
9240			;        block, and the free list is adjusted to maintain continuity via this : 
9240			;        newly created block.                                                 : 
9240			;                                                                             : 
9240			;     malloc does not set any initial value in the allocated space, the       : 
9240			;     caller is required to do this as required.                              : 
9240			;                                                                             : 
9240			;     This implementation of malloc uses the stack exclusively, and is        : 
9240			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9240			;     advisable to disable interrupts before calling malloc, and recommended  : 
9240			;     to avoid the use of malloc inside ISRs in general.                      : 
9240			;                                                                             : 
9240			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9240			;                                                                             : 
9240			; Parameters                                                                  : 
9240			;     HL  Number of bytes wanted                                              : 
9240			;                                                                             : 
9240			; Returns                                                                     : 
9240			;     HL  Address of the first useable byte of the allocation                 : 
9240			;                                                                             : 
9240			; Flags                                                                       : 
9240			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9240			;                                                                             : 
9240			; Stack frame                                                                 : 
9240			;       |             |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |     BC      |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |     DE      |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |     IX      |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |  prev_free  |                                                       : 
9240			;   +4  +-------------+                                                       : 
9240			;       |  this_free  |                                                       : 
9240			;   +2  +-------------+                                                       : 
9240			;       |  next_free  |                                                       : 
9240			;   +0  +-------------+                                                       : 
9240			;       |             |                                                       : 
9240			;                                                                             : 
9240			;------------------------------------------------------------------------------ 
9240			malloc: 
9240			      push  BC 
9240			      push  DE 
9240			      push  IX 
9240			 
9240			      ld    A, H                    ; Exit if no space requested 
9240			      or    L 
9240			      jp    Z, malloc_early_exit 
9240			 
9240			      ; Set up stack frame 
9240			      ex    DE, HL 
9240			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9240			      add   HL, SP 
9240			      ld    SP, HL 
9240			      ld    IX, 0                   ; Use IX as a frame pointer 
9240			      add   IX, SP 
9240			 
9240			      ; Setup initial state 
9240			      ld    HL, 4                   ; want must also include space used by block struct 
9240			      add   HL, DE 
9240			 
9240			      ld    B, H                    ; Move want to BC 
9240			      ld    C, L 
9240			 
9240			      ld    HL, free_list           ; Store prev_free ptr to stack 
9240			      ld    (IX+4), L 
9240			      ld    (IX+5), H 
9240			 
9240			      ld    E, (HL)                 ; Store this_free ptr to stack 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      ld    (IX+2), E 
9240			      ld    (IX+3), D 
9240			      ex    DE, HL                  ; this_free ptr into HL 
9240			 
9240			      ; Loop through free block list to find some space 
9240			malloc_find_space: 
9240			      ld    E, (HL)                 ; Load next_free ptr into DE 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			 
9240			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9240			      or    E 
9240			      jp    Z, malloc_no_space 
9240			 
9240			      ld    (IX+0), E               ; Store next_free ptr to stack 
9240			      ld    (IX+1), D 
9240			 
9240			      ; Does this block have enough space to make the allocation? 
9240			      inc   HL                      ; Load free block size into DE 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			 
9240			      ex    DE, HL                  ; Check size of block against want 
9240			      or    A                       ; Ensure carry flag clear 
9240			      sbc   HL, BC 
9240			      push  HL                      ; Store the result for later (new block size) 
9240			 
9240			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9240			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9240			 
9240			      ; this_free block is not big enough, setup ptrs to test next free block 
9240			      pop   HL                      ; Discard previous result 
9240			 
9240			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9240			      ld    H, (IX+3) 
9240			      ld    (IX+4), L 
9240			      ld    (IX+5), H 
9240			 
9240			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9240			      ld    H, (IX+1) 
9240			      ld    (IX+2), L 
9240			      ld    (IX+3), H 
9240			 
9240			      jr    malloc_find_space 
9240			 
9240			      ; split a bigger block into two - requested size and remaining size 
9240			malloc_alloc_split: 
9240			      ex    DE, HL                  ; Calculate address of new free block 
9240			      dec   HL 
9240			      dec   HL 
9240			      dec   HL 
9240			      add   HL, BC 
9240			 
9240			      ; Create a new block and point it at next_free 
9240			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9240			      ld    D, (IX+1) 
9240			 
9240			      ld    (HL), E                 ; Store next_free ptr into new block 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			      pop   DE                      ; Store size of new block into new block 
9240			      inc   HL 
9240			      ld    (HL), E 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			      ; Update this_free ptr to point to new block 
9240			      dec   HL 
9240			      dec   HL 
9240			      dec   HL 
9240			 
9240			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9240			      ld    D, (IX+3) 
9240			 
9240			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9240			      ld    (IX+3), H 
9240			 
9240			      ; Modify this_free block to be allocation 
9240			      ex    DE, HL 
9240			      xor   A                       ; Null the next block ptr of allocated block 
9240			      ld    (HL), A 
9240			      inc   HL 
9240			      ld    (HL), A 
9240			 
9240			      inc   HL                      ; Store want size into allocated block 
9240			      ld    (HL), C 
9240			      inc   HL 
9240			      ld    (HL), B 
9240			      inc   HL 
9240			      push  HL                      ; Address of allocation to return 
9240			 
9240			      jr    malloc_update_links 
9240			 
9240			malloc_alloc_fit: 
9240			      pop   HL                      ; Dont need new block size, want is exact fit 
9240			 
9240			      ; Modify this_free block to be allocation 
9240			      ex    DE, HL 
9240			      dec   HL 
9240			      dec   HL 
9240			      dec   HL 
9240			 
9240			      xor   A                       ; Null the next block ptr of allocated block 
9240			      ld    (HL), A 
9240			      inc   HL 
9240			      ld    (HL), A 
9240			 
9240			      inc   HL                      ; Store address of allocation to return 
9240			      inc   HL 
9240			      inc   HL 
9240			      push  HL 
9240			 
9240			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9240			      ld    L, (IX+0)               ; next_free to HL 
9240			      ld    H, (IX+1) 
9240			 
9240			      ld    (IX+2), L               ; HL to this_free 
9240			      ld    (IX+3), H 
9240			 
9240			 
9240			malloc_update_links: 
9240			      ; Update prev_free ptr to point to this_free 
9240			      ld    L, (IX+4)               ; prev_free ptr to HL 
9240			      ld    H, (IX+5) 
9240			 
9240			      ld    E, (IX+2)               ; this_free ptr to DE 
9240			      ld    D, (IX+3) 
9240			 
9240			      ld    (HL), E                 ; this_free ptr into prev_free 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			      ; Clear the Z flag to indicate successful allocation 
9240			      ld    A, D 
9240			      or    E 
9240			 
9240			      pop   DE                      ; Address of allocation 
9240			 
9240			malloc_no_space: 
9240			      ld    HL, 6                   ; Clean up stack frame 
9240			      add   HL, SP 
9240			      ld    SP, HL 
9240			 
9240			      ex    DE, HL                  ; Alloc addr into HL for return 
9240			 
9240			malloc_early_exit: 
9240			      pop   IX 
9240			      pop   DE 
9240			      pop   BC 
9240			 
9240			      ret 
9240			 
9240			 
9240			;------------------------------------------------------------------------------ 
9240			;     free                                                                    : 
9240			;                                                                             : 
9240			; Description                                                                 : 
9240			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9240			;     returned by malloc, otherwise the behaviour is undefined.               : 
9240			;                                                                             : 
9240			;     Where possible, directly adjacent free blocks will be merged together   : 
9240			;     into larger blocks to help ensure that the heap does not become         : 
9240			;     excessively fragmented.                                                 : 
9240			;                                                                             : 
9240			;     free does not clear or set any other value into the freed space, and    : 
9240			;     therefore its contents may be visible through subsequent malloc's. The  : 
9240			;     caller should clear the freed space as required.                        : 
9240			;                                                                             : 
9240			;     This implementation of free uses the stack exclusively, and is          : 
9240			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9240			;     advisable to disable interrupts before calling free, and recommended    : 
9240			;     to avoid the use of free inside ISRs in general.                        : 
9240			;                                                                             : 
9240			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9240			;                                                                             : 
9240			; Parameters                                                                  : 
9240			;     HL  Pointer to address of first byte of allocation to be freed          : 
9240			;                                                                             : 
9240			; Returns                                                                     : 
9240			;     Nothing                                                                 : 
9240			;                                                                             : 
9240			; Stack frame                                                                 : 
9240			;       |             |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |     BC      |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |     DE      |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |     IX      |                                                       : 
9240			;       +-------------+                                                       : 
9240			;       |  prev_free  |                                                       : 
9240			;   +2  +-------------+                                                       : 
9240			;       |  next_free  |                                                       : 
9240			;   +0  +-------------+                                                       : 
9240			;       |             |                                                       : 
9240			;                                                                             : 
9240			;------------------------------------------------------------------------------ 
9240			free: 
9240			      push  BC 
9240			      push  DE 
9240			      push  IX 
9240			 
9240			      ld    A, H                    ; Exit if ptr is null 
9240			      or    L 
9240			      jp    Z, free_early_exit 
9240			 
9240			      ; Set up stack frame 
9240			      ex    DE, HL 
9240			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9240			      add   HL, SP 
9240			      ld    SP, HL 
9240			      ld    IX, 0                   ; Use IX as a frame pointer 
9240			      add   IX, SP 
9240			 
9240			      ; The address in HL points to the start of the useable allocated space, 
9240			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9240			      ; address of the block itself. 
9240			      ex    DE, HL 
9240			      ld    DE, -4 
9240			      add   HL, DE 
9240			 
9240			      ; An allocated block must have a null next block pointer in it 
9240			      ld    A, (HL) 
9240			      inc   HL 
9240			      or    (HL) 
9240			      jp    NZ, free_done 
9240			 
9240			      dec   HL 
9240			 
9240			      ld    B, H                    ; Copy HL to BC 
9240			      ld    C, L 
9240			 
9240			      ; Loop through the free list to find the first block with an address 
9240			      ; higher than the block being freed 
9240			      ld    HL, free_list 
9240			 
9240			free_find_higher_block: 
9240			      ld    E, (HL)                 ; Load next ptr from free block 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      dec   HL 
9240			 
9240			      ld    (IX+0), E               ; Save ptr to next free block 
9240			      ld    (IX+1), D 
9240			      ld    (IX+2), L               ; Save ptr to prev free block 
9240			      ld    (IX+3), H 
9240			 
9240			      ld    A, B                    ; Check if DE is greater than BC 
9240			      cp    D                       ; Compare MSB first 
9240			      jr    Z, $+4                  ; MSB the same, compare LSB 
9240			      jr    NC, free_find_higher_block_skip 
9240			      ld    A, C 
9240			      cp    E                       ; Then compare LSB 
9240			      jr    C, free_found_higher_block 
9240			 
9240			free_find_higher_block_skip: 
9240			      ld    A, D                    ; Reached the end of the free list? 
9240			      or    E 
9240			      jp    Z, free_done 
9240			 
9240			      ex    DE, HL 
9240			 
9240			      jr    free_find_higher_block 
9240			 
9240			free_found_higher_block: 
9240			      ; Insert freed block between prev and next free blocks 
9240			      ld    (HL), C                 ; Point prev free block to freed block 
9240			      inc   HL 
9240			      ld    (HL), B 
9240			 
9240			      ld    H, B                    ; Point freed block at next free block 
9240			      ld    L, C 
9240			      ld    (HL), E 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			      ; Check if the freed block is adjacent to the next free block 
9240			      inc   HL                      ; Load size of freed block into HL 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      ex    DE, HL 
9240			 
9240			      add   HL, BC                  ; Add addr of freed block and its size 
9240			 
9240			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9240			      ld    D, (IX+1) 
9240			 
9240			      or    A                       ; Clear the carry flag 
9240			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9240			      jr    NZ, free_check_adjacent_to_prev 
9240			 
9240			      ; Freed block is adjacent to next, merge into one bigger block 
9240			      ex    DE, HL                  ; Load next ptr from next block into DE 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      push  HL                      ; Save ptr to next block for later 
9240			 
9240			      ld    H, B                    ; Store ptr from next block into freed block 
9240			      ld    L, C 
9240			      ld    (HL), E 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			      pop   HL                      ; Restore ptr to next block 
9240			      inc   HL                      ; Load size of next block into DE 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      push  DE                      ; Save next block size for later 
9240			 
9240			      ld    H, B                    ; Load size of freed block into HL 
9240			      ld    L, C 
9240			      inc   HL 
9240			      inc   HL 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      ex    DE, HL 
9240			 
9240			      pop   DE                      ; Restore size of next block 
9240			      add   HL, DE                  ; Add sizes of both blocks 
9240			      ex    DE, HL 
9240			 
9240			      ld    H, B                    ; Store new bigger size into freed block 
9240			      ld    L, C 
9240			      inc   HL 
9240			      inc   HL 
9240			      ld    (HL), E 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			free_check_adjacent_to_prev: 
9240			      ; Check if the freed block is adjacent to the prev free block 
9240			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9240			      ld    H, (IX+3) 
9240			 
9240			      inc   HL                      ; Size of prev free block into DE 
9240			      inc   HL 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      dec   HL 
9240			      dec   HL 
9240			      dec   HL 
9240			 
9240			      add   HL, DE                  ; Add prev block addr and size 
9240			 
9240			      or    A                       ; Clear the carry flag 
9240			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9240			      jr    NZ, free_done 
9240			 
9240			      ; Freed block is adjacent to prev, merge into one bigger block 
9240			      ld    H, B                    ; Load next ptr from freed block into DE 
9240			      ld    L, C 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      push  HL                      ; Save freed block ptr for later 
9240			 
9240			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9240			      ld    H, (IX+3) 
9240			      ld    (HL), E 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			      pop   HL                      ; Restore freed block ptr 
9240			      inc   HL                      ; Load size of freed block into DE 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			      push  DE                      ; Save freed block size for later 
9240			 
9240			      ld    L, (IX+2)               ; Load size of prev block into DE 
9240			      ld    H, (IX+3) 
9240			      inc   HL 
9240			      inc   HL 
9240			      ld    E, (HL) 
9240			      inc   HL 
9240			      ld    D, (HL) 
9240			 
9240			      pop   HL                      ; Add sizes of both blocks 
9240			      add   HL, DE 
9240			      ex    DE, HL 
9240			 
9240			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9240			      ld    H, (IX+3) 
9240			      inc   HL 
9240			      inc   HL 
9240			      ld    (HL), E 
9240			      inc   HL 
9240			      ld    (HL), D 
9240			 
9240			free_done: 
9240			      ld    HL, 4                   ; Clean up stack frame 
9240			      add   HL, SP 
9240			      ld    SP, HL 
9240			 
9240			free_early_exit: 
9240			      pop   IX 
9240			      pop   DE 
9240			      pop   BC 
9240			 
9240			      ret 
9240			 
9240			 
9240			;      .org 0x8000 
9240			; 
9240			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9240			 ;                 .dw   0 
9240			 
9240			endif 
9240			 
9240			 
9240			if MALLOC_4 
9240			 
9240			; My memory allocation code. Very very simple.... 
9240			; allocate space under 250 chars 
9240			 
9240			heap_init: 
9240				; init start of heap as zero 
9240				;  
9240			 
9240				ld hl, heap_start 
9240			;	ld a, 0 
9240				ld (hl), 0      ; empty block 
9240				inc hl 
9240			;	ld a, 0 
9240				ld (hl), 0      ; length of block 
9240				; write end of list 
9240				inc hl 
9240				ld a,(hl) 
9240				inc hl 
9240				ld a,(hl) 
9240				 
9240			 
9240				; init some malloc vars 
9240			 
9240				ld hl, 0 
9240				ld (free_list), hl       ; store last malloc location 
9240			 
9240				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9240			;	ld a, 0 
9240				ld (hl), 0 
9240			 
9240			 
9240				ld hl, heap_start 
9240				;  
9240				  
9240				ret 
9240			 
9240			 
9240			;    free block marker 
9240			;    requested size  
9240			;    pointer to next block 
9240			;    .... 
9240			;    next block marker 
9240			 
9240			 
9240			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9240			; 
9240			 
9240			 
9240			malloc:  
9240				push de 
9240				push bc 
9240				push af 
9240			 
9240				; hl space required 
9240				 
9240				ld c, l    ; hold space   (TODO only a max of 255) 
9240			 
9240			;	inc c     ; TODO BUG need to fix memory leak on push str 
9240			;	inc c 
9240			;	inc c 
9240			;	inc c 
9240			;	inc c 
9240			;	inc c 
9240			;	inc c 
9240			 
9240			 
9240			 
9240				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9240			 
9240				ld a, (free_list+3) 
9240			;	cp 0 
9240				or a 
9240				jr z, .contheap 
9240			 
9240				ld hl, (free_list)     ; get last alloc 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "mrs" 
9240						CALLMONITOR 
9240					endif 
9240				jr .startalloc 
9240			 
9240			.contheap: 
9240				ld hl, heap_start 
9240			 
9240			.startalloc: 
9240			 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "mym" 
9240						CALLMONITOR 
9240					endif 
9240			.findblock: 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "mmf" 
9240						CALLMONITOR 
9240					endif 
9240			 
9240				ld a,(hl)  
9240				; if byte is zero then clear to use 
9240			 
9240			;	cp 0 
9240				or a 
9240				jr z, .foundemptyblock 
9240			 
9240				; if byte is not clear 
9240				;     then byte is offset to next block 
9240			 
9240				inc hl 
9240				ld a, (hl) ; get size 
9240			.nextblock:	inc hl 
9240					ld e, (hl) 
9240					inc hl 
9240					ld d, (hl) 
9240					ex de, hl 
9240			;	inc hl  ; move past the store space 
9240			;	inc hl  ; move past zero index  
9240			 
9240				; TODO detect no more space 
9240			 
9240				push hl 
9240				ld de, heap_end 
9240				call cmp16 
9240				pop hl 
9240				jr nc, .nospace 
9240			 
9240				jr .findblock 
9240			 
9240			.nospace: ld hl, 0 
9240				jp .exit 
9240			 
9240			 
9240			.foundemptyblock:	 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "mme" 
9240						CALLMONITOR 
9240					endif 
9240			 
9240			; TODO has block enough space if reusing??? 
9240			 
9240				;  
9240			 
9240			; see if this block has been previously used 
9240				inc hl 
9240				ld a, (hl) 
9240				dec hl 
9240			;	cp 0 
9240				or a 
9240				jr z, .newblock 
9240			 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "meR" 
9240						CALLMONITOR 
9240					endif 
9240			 
9240			; no reusing previously allocated block 
9240			 
9240			; is it smaller than previously used? 
9240				 
9240				inc hl    ; move to size 
9240				ld a, c 
9240				sub (hl)        ; we want c < (hl) 
9240				dec hl    ; move back to marker 
9240			        jr z, .findblock 
9240			 
9240				; update with the new size which should be lower 
9240			 
9240			        ;inc  hl   ; negate next move. move back to size  
9240			 
9240			.newblock: 
9240				; need to be at marker here 
9240			 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "meN" 
9240						CALLMONITOR 
9240					endif 
9240			 
9240			 
9240				ld a, c 
9240			 
9240				ld (free_list+3), a	 ; flag resume from last malloc  
9240				ld (free_list), hl    ; save out last location 
9240			 
9240			 
9240				;inc a     ; space for length byte 
9240				ld (hl), a     ; save block in use marker 
9240			 
9240				inc hl   ; move to space marker 
9240				ld (hl), a    ; save new space 
9240			 
9240				inc hl   ; move to start of allocated area 
9240				 
9240			;	push hl     ; save where we are - 1  
9240			 
9240			;	inc hl  ; move past zero index  
9240				; skip space to set down new marker 
9240			 
9240				; provide some extra space for now 
9240			 
9240				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9240				inc a 
9240				inc a 
9240			 
9240				push hl   ; save where we are in the node block 
9240			 
9240				call addatohl 
9240			 
9240				; write linked list point 
9240			 
9240				pop de     ; get our node position 
9240				ex de, hl 
9240			 
9240				ld (hl), e 
9240				inc hl 
9240				ld (hl), d 
9240			 
9240				inc hl 
9240			 
9240				; now at start of allocated data so save pointer 
9240			 
9240				push hl 
9240			 
9240				; jump to position of next node and setup empty header in DE 
9240			 
9240				ex de, hl 
9240			 
9240			;	inc hl ; move past end of block 
9240			 
9240			;	ld a, 0 
9240				ld (hl), 0   ; empty marker 
9240				inc hl 
9240				ld (hl), 0   ; size 
9240				inc hl  
9240				ld (hl), 0   ; ptr 
9240				inc hl 
9240				ld (hl), 0   ; ptr 
9240			 
9240			 
9240				pop hl 
9240			 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "mmr" 
9240						CALLMONITOR 
9240					endif 
9240			 
9240			.exit: 
9240				pop af 
9240				pop bc 
9240				pop de  
9240				ret 
9240			 
9240			 
9240			 
9240			 
9240			free:  
9240				push hl 
9240				push af 
9240				; get address in hl 
9240			 
9240					if DEBUG_FORTH_MALLOC_INT 
9240						DMARK "fre" 
9240						CALLMONITOR 
9240					endif 
9240				; data is at hl - move to block count 
9240				dec hl 
9240				dec hl    ; get past pointer 
9240				dec hl 
9240			 
9240				ld a, (hl)    ; need this for a validation check 
9240			 
9240				dec hl    ; move to block marker 
9240			 
9240				; now check that the block count and block marker are the same  
9240			        ; this checks that we are on a malloc node and not random memory 
9240			        ; OK a faint chance this could be a problem but rare - famous last words! 
9240			 
9240				ld c, a 
9240				ld a, (hl)    
9240			 
9240				cp c 
9240				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9240			 
9240				; yes good chance we are on a malloc node 
9240			 
9240			;	ld a, 0      
9240				ld (hl), 0   ; mark as free 
9240			 
9240				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9240			 
9240			.freeignore:  
9240			 
9240				pop af 
9240				pop hl 
9240			 
9240				ret 
9240			 
9240			 
9240			 
9240			endif 
9240			 
9240			; eof 
# End of file firmware_memory.asm
9240			  
9240			; device C  
9240			; Now handled by SPI  
9240			;if SOUND_ENABLE  
9240			;	include "firmware_sound.asm"  
9240			;endif  
9240			  
9240			include "firmware_diags.asm"  
9240			; Hardware diags menu 
9240			 
9240			 
9240			config: 
9240			 
9240 3e 00			ld a, 0 
9242 21 5d 92			ld hl, .configmn 
9245 cd e1 8a			call menu 
9248			 
9248 fe 00			cp 0 
924a c8				ret z 
924b			 
924b			;	cp 1 
924b			;	call z, .savetostore 
924b			 
924b 3d				dec a 
924c			if STARTUP_V1 
924c cc 71 92			call z, .selautoload 
924f			endif 
924f			 
924f			if STARTUP_V2 
924f				call z, .enautoload 
924f			endif 
924f				;cp 2 
924f 3d				dec a 
9250 cc 67 92			call z, .disautoload 
9253			if STARTUP_V2 
9253				dec a 
9253				call z, .selbank 
9253			endif 
9253			;	cp 3 
9253			;	call z, .selbank 
9253			;	cp 3 
9253 3d				dec a 
9254 cc 8f 92			call z, .debug_tog 
9257			;	cp 4 
9257 3d				dec a 
9258 cc 5d 93			call z, .bpsgo 
925b			;	cp 5 
925b			;	call z, hardware_diags 
925b			if STARTUP_V2 
925b			;	cp 5 
925b				dec a 
925b				call z, create_startup 
925b			endif 
925b 18 e3			jr config 
925d			 
925d			.configmn: 
925d			;	dw prom_c3 
925d 4b 95			dw prom_c2 
925f 60 95			dw prom_c2a 
9261			if STARTUP_V2 
9261				dw prom_bsel  
9261			endif 
9261			;	dw prom_c2b 
9261			;	dw prom_c4 
9261 7f 95			dw prom_m4 
9263 9a 95			dw prom_m4b 
9265			;	dw prom_c1 
9265			if STARTUP_V2 
9265				dw prom_c9 
9265			endif 
9265 00 00			dw 0 
9267				 
9267			 
9267			if STARTUP_V2 
9267			.enautoload: 
9267				if STORAGE_SE 
9267				ld a, $fe      ; bit 0 clear 
9267				ld (spi_device), a 
9267			 
9267				call storage_get_block_0 
9267			 
9267				ld a, 1 
9267				ld (store_page+STORE_0_AUTOFILE), a 
9267			 
9267					ld hl, 0 
9267					ld de, store_page 
9267				call storage_write_block	 ; save update 
9267				else 
9267			 
9267				ld hl, prom_notav 
9267				ld de, prom_empty 
9267				call info_panel 
9267				endif 
9267			 
9267			 
9267				ret 
9267			endif 
9267			 
9267			.disautoload: 
9267				if STORAGE_SE 
9267				ld a, $fe      ; bit 0 clear 
9267				ld (spi_device), a 
9267			 
9267				call storage_get_block_0 
9267			 
9267				ld a, 0 
9267				ld (store_page+STORE_0_AUTOFILE), a 
9267			 
9267					ld hl, 0 
9267					ld de, store_page 
9267				call storage_write_block	 ; save update 
9267				else 
9267			 
9267 21 a2 95			ld hl, prom_notav 
926a 11 b8 95			ld de, prom_empty 
926d cd 43 8a			call info_panel 
9270				endif 
9270			 
9270			 
9270 c9				ret 
9271			 
9271			if STARTUP_V1 
9271			 
9271			; Select auto start 
9271			 
9271			.selautoload: 
9271			 
9271				 
9271				if STORAGE_SE 
9271			 
9271					call config_dir 
9271				        ld hl, scratch 
9271					ld a, 0 
9271					call menu 
9271			 
9271					cp 0 
9271					ret z 
9271			 
9271					dec a 
9271			 
9271			 
9271					; locate menu option 
9271			 
9271					ld hl, scratch 
9271					call table_lookup 
9271			 
9271					if DEBUG_FORTH_WORDS 
9271						DMARK "ALl" 
9271						CALLMONITOR 
9271					endif 
9271					; with the pointer to the menu it, the byte following the zero term is the file id 
9271			 
9271					ld a, 0 
9271					ld bc, 50   ; max of bytes to look at 
9271					cpir  
9271			 
9271					if DEBUG_FORTH_WORDS 
9271						DMARK "ALb" 
9271						CALLMONITOR 
9271					endif 
9271					;inc hl 
9271			 
9271					ld a, (hl)   ; file id 
9271					 
9271				        ; save bank and file ids 
9271			 
9271					push af 
9271			 
9271			; TODO need to save to block 0 on bank 1	 
9271			 
9271					call storage_get_block_0 
9271			 
9271					if DEBUG_FORTH_WORDS 
9271						DMARK "AL0" 
9271						CALLMONITOR 
9271					endif 
9271					pop af 
9271			 
9271					ld (store_page+STORE_0_FILERUN),a 
9271					 
9271					; save bank id 
9271			 
9271					ld a,(spi_device) 
9271					ld (store_page+STORE_0_BANKRUN),a 
9271			 
9271					; enable auto run of store file 
9271			 
9271					ld a, 1 
9271					ld (store_page+STORE_0_AUTOFILE),a 
9271			 
9271					; save buffer 
9271			 
9271					ld hl, 0 
9271					ld de, store_page 
9271					if DEBUG_FORTH_WORDS 
9271						DMARK "ALw" 
9271						CALLMONITOR 
9271					endif 
9271				call storage_write_block	 ; save update 
9271			  
9271			 
9271			 
9271			 
9271					ld hl, scratch 
9271					call config_fdir 
9271			 
9271				else 
9271			 
9271 21 a2 95			ld hl, prom_notav 
9274 11 b8 95			ld de, prom_empty 
9277 cd 43 8a			call info_panel 
927a			 
927a				endif 
927a c9				ret 
927b			endif 
927b			 
927b			 
927b			; Select storage bank 
927b			 
927b			.selbank: 
927b			 
927b			if STARTUP_V2 
927b			;	if STORAGE_SE 
927b			;	else 
927b			 
927b				ld hl, prom_banks 
927b				call menu 
927b				cp 0 
927b				ret z 
927b				 
927b				; set the bank number from the result 
927b			 
927b				 
927b					ld c, SPI_CE_HIGH 
927b					ld b, '0'    ; human readable bank number 
927b			 
927b			 
927b					; active low 
927b			 
927b			;		cp 0 
927b					or a 
927b					jr z, .bset 
927b					cp 1 
927b					jr nz, .b2 
927b					res 0, c 
927b					ld b, '1'    ; human readable bank number 
927b			.b2:		cp 2 
927b					jr nz, .b3 
927b					res 1, c 
927b					ld b, '2'    ; human readable bank number 
927b			.b3:		cp 3 
927b					jr nz, .b4 
927b					res 2, c 
927b					ld b, '3'    ; human readable bank number 
927b			.b4:		cp 4 
927b					jr nz, .b5 
927b					res 3, c 
927b					ld b, '4'    ; human readable bank number 
927b			.b5:		cp 5 
927b					jr nz, .bset 
927b					res 4, c 
927b					ld b, '5'    ; human readable bank number 
927b			 
927b			.bset: 
927b			 
927b					ld a, c 
927b			;		ld (spi_device),a 
927b					ld a, b 
927b			;		ld (spi_device_id),a 
927b					push bc 
927b			 
927b					; select bank 1 and load block 0  
927b			 
927b				ld a, $fe      ; bit 0 clear 
927b				ld (spi_device), a 
927b			 
927b				call storage_get_block_0 
927b			 
927b				pop bc 
927b				ld a,c 
927b				ld (store_page+STORE_0_BANKRUN), a 
927b				ld a,b 
927b				ld (store_page+STORE_0_BANKRUNN), a 
927b					ld hl, 0 
927b					ld de, store_page 
927b				call storage_write_block 
927b			 
927b			else 
927b 21 a2 95			ld hl, prom_notav 
927e 11 b8 95			ld de, prom_empty 
9281 cd 43 8a			call info_panel 
9284			;	endif 
9284				 
9284			endif 
9284 c9				ret 
9285			 
9285			if STORAGE_SE 
9285			 
9285			.config_ldir:   
9285				; Load storage bank labels into menu array 
9285			 
9285				 
9285			 
9285			 
9285				ret 
9285			 
9285			 
9285			endif 
9285			 
9285			 
9285			; Save user words to storage 
9285			 
9285			.savetostore: 
9285			 
9285			;	if STORAGE_SE 
9285			; 
9285			;		call config_dir 
9285			;	        ld hl, scratch 
9285			;		ld a, 0 
9285			;		call menu 
9285			;		 
9285			;		ld hl, scratch 
9285			;		call config_fdir 
9285			; 
9285			;	else 
9285			 
9285 21 a2 95			ld hl, prom_notav 
9288 11 b8 95			ld de, prom_empty 
928b cd 43 8a			call info_panel 
928e			 
928e			;	endif 
928e			 
928e c9				ret 
928f			 
928f			if STARTUP_V2 
928f			 
928f			create_startup: 
928f			 
928f				ld a, 0 
928f				ld hl, .crstart 
928f				call menu 
928f			 
928f				cp 0 
928f				ret z 
928f			 
928f				cp 1 
928f				call z, .genlsword 
928f				cp 2 
928f				call z, .genedword 
928f			 
928f				cp 3 
928f				call z, .gendemword 
928f			 
928f				cp 4 
928f				call z, .genutlword 
928f				cp 5 
928f				call z, .genspiword 
928f				cp 6 
928f				call z, .genkeyword 
928f				cp 7 
928f				call z, .gensoundword 
928f				cp 8 
928f				call z, .genhwword 
928f				jr create_startup 
928f			 
928f			.genhwword: 
928f				ld hl, crs_hw 
928f				ld de, .hwworddef 
928f				call .genfile 
928f				ret 
928f			.gensoundword: 
928f				ld hl, crs_sound 
928f				ld de, .soundworddef 
928f				call .genfile 
928f				ret 
928f			.genlsword: 
928f				ld hl, crs_s1 
928f				ld de, .lsworddef 
928f				call .genfile 
928f				ret 
928f			 
928f			.genedword: 
928f				ld de, .edworddef 
928f				ld hl, crs_s2 
928f				call .genfile 
928f				ret 
928f			 
928f			.gendemword: 
928f				ld de, .demoworddef 
928f				ld hl, crs_s3 
928f				call .genfile 
928f				ret 
928f			 
928f			.genutlword: 
928f				ld hl, crs_s4 
928f				ld de, .utilwordef 
928f				call .genfile 
928f				ret 
928f			.genspiword: 
928f				ld hl, crs_s5 
928f				ld de, .spiworddef 
928f				call .genfile 
928f				ret 
928f			.genkeyword: 
928f				ld hl, crs_s6 
928f				ld de, .keyworddef 
928f				call .genfile 
928f				ret 
928f			 
928f			; hl - points to file name 
928f			; de - points to strings to add to file 
928f			 
928f			.genfile: 
928f				push hl 
928f				push de 
928f			 
928f				call clear_display 
928f				ld a, display_row_1 
928f				ld de, .genfiletxt 
928f				call str_at_display 
928f				call update_display 
928f			 
928f				pop de 
928f				pop hl 
928f			 
928f			 
928f				push de 
928f				call storage_create 
928f				; id in hl 
928f				pop de   ; table of strings to add 
928f			 
928f			.genloop: 
928f			 
928f				push hl ; save id for next time around 
928f				push de ; save de for next time around 
928f			 
928f				ex de, hl 
928f				call loadwordinhl 
928f				ex de, hl 
928f			 
928f				; need hl to be the id 
928f				; need de to be the string ptr 
928f				 
928f				call storage_append 
928f			 
928f				pop de 
928f				pop hl 
928f			 
928f				inc de 
928f				inc de 
928f			 
928f				ld a,(de) 
928f				cp 0 
928f				jr nz, .genloop 
928f				inc de 
928f				ld a, (de) 
928f				dec de 
928f				cp 0 
928f				jr nz, .genloop	 
928f			 
928f				ret 
928f			 
928f			.genfiletxt:  db "Creating file...",0 
928f			 
928f			.hwworddef: 
928f				dw test5 
928f				dw test6 
928f				dw test7 
928f				dw test8 
928f				dw test9 
928f				dw test10 
928f				dw 0 
928f			 
928f			.soundworddef: 
928f				dw sound1 
928f				dw sound2 
928f				dw sound3 
928f				dw sound4 
928f				dw sound5 
928f				dw sound6 
928f				dw sound7 
928f				dw sound8 
928f				dw sound9 
928f				dw 0 
928f			 
928f			.utilwordef: 
928f				dw strncpy 
928f				dw type 
928f				dw ztype 
928f				dw tuck 
928f				dw nip 
928f				dw clrstack 
928f				dw longread 
928f				dw start1 
928f				dw start2 
928f			; duplicated 
928f			;	dw start3b 
928f			;	dw start3c 
928f				dw list 
928f				dw 0 
928f			 
928f			.lsworddef: 
928f				dw start3b 
928f				dw 0 
928f			 
928f			.edworddef: 
928f				dw edit1 
928f				dw edit2 
928f				dw edit3 
928f				dw 0 
928f			 
928f			.demoworddef: 
928f				dw game1 
928f				dw game1a 
928f				dw game1b 
928f				dw game1c 
928f				dw game1d 
928f				dw game1s 
928f				dw game1t 
928f				dw game1f 
928f				dw game1z 
928f				dw game1zz 
928f				dw ssv2 
928f				dw ssv3 
928f				dw ssv4 
928f				dw ssv5 
928f				dw ssv1 
928f				dw ssv1cpm	 
928f			;	dw game2b 
928f			;	dw game2bf 
928f			;	dw game2mba 
928f			;	dw game2mbas	 
928f			;	dw game2mbht 
928f			;	dw game2mbms 
928f			;	dw game2mb 
928f			;	dw game3w 
928f			;	dw game3p 
928f			;	dw game3sc 
928f			;	dw game3vsi 
928f			;	dw game3vs 
928f				dw 0 
928f			 
928f			 
928f			.spiworddef: 
928f			 
928f			    dw spi1 
928f			    dw spi2 
928f			    dw spi2b 
928f			    dw spi3 
928f			    dw spi4 
928f			    dw spi5 
928f			    dw spib1 
928f			    dw spib2 
928f			    dw spib3 
928f			    dw spib4 
928f			    dw spib5 
928f			;    dw spi6 
928f			;    dw spi7 
928f			 
928f			;    dw spi8 
928f			;    dw spi9 
928f			;    dw spi10 
928f			    dw 0 
928f			 
928f			.keyworddef: 
928f			 
928f				dw keyup 
928f				dw keydown 
928f				dw keyleft 
928f				dw keyright 
928f				dw 	keyf1 
928f				dw keyf2 
928f				dw keyf3 
928f				dw keyf4 
928f				dw keyf5 
928f				dw keyf6 
928f				dw keyf7 
928f				dw keyf8 
928f				dw keyf9 
928f				dw keyf10 
928f				dw keyf11 
928f				dw keyf12 
928f				dw keytab 
928f				dw keycr 
928f				dw keyhome 
928f				dw keyend 
928f				dw keybs 
928f				dw 0 
928f			 
928f			.crstart: 
928f				dw crs_s1 
928f				dw crs_s2 
928f				dw crs_s3 
928f				dw crs_s4 
928f				dw crs_s5 
928f				dw crs_s6 
928f				dw crs_sound 
928f				dw crs_hw 
928f				dw 0 
928f			 
928f			endif 
928f			 
928f			 
928f			if STORAGE_SE 
928f			 
928f			config_fdir: 
928f				; using the scratch dir go through and release the memory allocated for each string 
928f				 
928f				ld hl, scratch 
928f			.cfdir:	ld e,(hl) 
928f				inc hl 
928f				ld d,(hl) 
928f				inc hl 
928f			 
928f				ex de, hl 
928f				call ishlzero 
928f				ret z     ; return on null pointer 
928f				call free 
928f				ex de, hl 
928f				jr .cfdir 
928f			 
928f			 
928f				ret 
928f			 
928f			 
928f			config_dir: 
928f			 
928f				; for the config menus that need to build a directory of storage call this routine 
928f				; it will construct a menu in scratch to pass to menu 
928f			 
928f				; open storage device 
928f			 
928f				; execute DIR to build a list of files and their ids into scratch in menu format 
928f				; once the menu has finished then will need to call config_fdir to release the strings 
928f				 
928f				; c = number items 
928f			 
928f				 
928f				call storage_get_block_0 
928f			 
928f				ld hl, store_page     ; get current id count 
928f				ld b, (hl) 
928f				ld c, 0    ; count of files   
928f			 
928f			 
928f				ld hl, scratch 
928f				ld (store_tmp2), hl    ; location to poke strings 
928f			 
928f				; check for empty drive 
928f			 
928f				ld a, 0 
928f				cp b 
928f				jp z, .dirdone 
928f			 
928f				 
928f					if DEBUG_FORTH_WORDS 
928f						DMARK "Cdc" 
928f						CALLMONITOR 
928f					endif 
928f			 
928f			 
928f			.diritem:	 
928f				push bc 
928f				; for each of the current ids do a search for them and if found push to stack 
928f			 
928f					ld hl, STORE_BLOCK_PHY 
928f					ld d, 0		 ; look for extent 0 of block id as this contains file name 
928f					ld e,b 
928f			 
928f					call storage_findnextid 
928f			 
928f			 
928f					; if found hl will be non zero 
928f			 
928f					call ishlzero 
928f					jr z, .dirnotfound 
928f			 
928f					; increase count 
928f			 
928f					pop bc	 
928f					inc c 
928f					push bc 
928f					 
928f			 
928f					; get file header and push the file name 
928f			 
928f					ld de, store_page 
928f					call storage_read_block 
928f			 
928f					; push file id to stack 
928f				 
928f					ld a, (store_page) 
928f					ld h, 0 
928f					ld l, a 
928f			 
928f					;call forth_push_numhl 
928f					; TODO store id 
928f			 
928f					push hl 
928f			 
928f					; push extent count to stack  
928f				 
928f					ld hl, store_page+3 
928f			 
928f					; get file name length 
928f			 
928f					call strlenz   
928f			 
928f					inc hl   ; cover zero term 
928f					inc hl  ; stick the id at the end of the area 
928f			 
928f					push hl 
928f					pop bc    ; move length to bc 
928f			 
928f					call malloc 
928f			 
928f					; TODO save malloc area to scratch 
928f			 
928f					ex de, hl 
928f					ld hl, (store_tmp2) 
928f					ld (hl), e 
928f					inc hl 
928f					ld (hl), d 
928f					inc hl 
928f					ld (store_tmp2), hl 
928f			 
928f					 
928f			 
928f					;pop hl   ; get source 
928f			;		ex de, hl    ; swap aronund	 
928f			 
928f					ld hl, store_page+3 
928f					if DEBUG_FORTH_WORDS 
928f						DMARK "CFd" 
928f						CALLMONITOR 
928f					endif 
928f					ldir 
928f			 
928f					; de is past string, move back one and store id 
928f					 
928f					dec de 
928f			 
928f					; store file id 
928f			 
928f					pop hl 
928f					ex de,hl 
928f					ld (hl), e 
928f			 
928f					if DEBUG_FORTH_WORDS 
928f						DMARK "Cdi" 
928f						CALLMONITOR 
928f					endif 
928f					 
928f			.dirnotfound: 
928f					pop bc     
928f					djnz .diritem 
928f				 
928f			.dirdone:	 
928f			 
928f			;		ld a, 0 
928f					ld hl, (store_tmp2) 
928f					ld (hl), 0 
928f					inc hl 
928f					ld (hl), 0 
928f					inc hl 
928f					; push a count of the dir items found 
928f			 
928f			;		ld h, 0 
928f			;		ld l, c 
928f			 
928f				ret 
928f			 
928f			endif 
928f			 
928f			 
928f			; Settings 
928f			; Run  
928f			 
928f			 
928f			 
928f			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
928f			;;hd_menu2:   db "        2: Editor",0   
928f			;hd_menu2:   db "        2: Editor       6: Menu",0   
928f			;hd_menu3:   db "        3: Storage",0 
928f			;hd_menu4:   db "0=quit  4: Debug",0 
928f			;hd_don:     db "ON",0 
928f			;hd_doff:     db "OFF",0 
928f			; 
928f			; 
928f			; 
928f			;hardware_diags_old:       
928f			; 
928f			;.diagmenu: 
928f			;	call clear_display 
928f			;	ld a, display_row_1 
928f			;	ld de, hd_menu1 
928f			;	call str_at_display 
928f			; 
928f			;	ld a, display_row_2 
928f			;	ld de, hd_menu2 
928f			;	call str_at_display 
928f			; 
928f			;	ld a, display_row_3 
928f			;	ld de, hd_menu3 
928f			;	call str_at_display 
928f			; 
928f			;	ld a,  display_row_4 
928f			;	ld de, hd_menu4 
928f			;	call str_at_display 
928f			; 
928f			;	; display debug state 
928f			; 
928f			;	ld de, hd_don 
928f			;	ld a, (os_view_disable) 
928f			;	cp 0 
928f			;	jr z, .distog 
928f			;	ld de, hd_doff 
928f			;.distog: ld a, display_row_4+17 
928f			;	call str_at_display 
928f			; 
928f			;	call update_display 
928f			; 
928f			;	call cin_wait 
928f			; 
928f			; 
928f			; 
928f			;	cp '4' 
928f			;	jr nz, .diagn1 
928f			; 
928f			;	; debug toggle 
928f			; 
928f			;	ld a, (os_view_disable) 
928f			;	ld b, '*' 
928f			;	cp 0 
928f			;	jr z, .debtog 
928f			;	ld b, 0 
928f			;.debtog:	 
928f			;	ld a,b 
928f			;	ld (os_view_disable),a 
928f			; 
928f			;.diagn1: cp '0' 
928f			;	 ret z 
928f			; 
928f			;;	cp '1' 
928f			;;       jp z, matrix	 
928f			;;   TODO keyboard matrix test 
928f			; 
928f			;	cp '2' 
928f			;	jp z, .diagedit 
928f			; 
928f			;;	cp '6' 
928f			;;	jp z, .menutest 
928f			;;if ENABLE_BASIC 
928f			;;	cp '6' 
928f			;;	jp z, basic 
928f			;;endif 
928f			 ; 
928f			;	jp .diagmenu 
928f			; 
928f			; 
928f			;	ret 
928f			 
928f			 
928f			.debug_tog: 
928f 21 b8 92			ld hl, .menudebug 
9292				 
9292			;	ld a, (os_view_disable) 
9292			;	cp '*' 
9292 3a 6b ee			ld a,(debug_vector) 
9295 fe c9			cp $C9   ; RET 
9297 20 04			jr nz,.tdon  
9299 3e 01			ld a, 1 
929b 18 02			jr .tog1 
929d 3e 00		.tdon: ld a, 0 
929f			 
929f			.tog1: 
929f cd e1 8a			call menu 
92a2 fe 00			cp 0 
92a4 c8				ret z 
92a5 fe 01			cp 1    ; disable debug 
92a7 28 04			jr z, .dtog0 
92a9 3e 2a			ld a, '*' 
92ab 18 05			jr .dtogset 
92ad			.dtog0:  
92ad				;ld a, 0 
92ad cd 4b 93			call bp_on 
92b0 18 dd			jr .debug_tog 
92b2			.dtogset:  
92b2				; ld (os_view_disable), a 
92b2 cd 57 93			call bp_off 
92b5 c3 8f 92			jp .debug_tog 
92b8			 
92b8			 
92b8			.menudebug: 
92b8 be 92				dw .m6 
92ba c7 92				dw .m7 
92bc 00 00				dw 0 
92be .. 00		.m6:   db "Debug ON",0 
92c7 .. 00		.m7:   db "Debug OFF",0 
92d1			;hardware_diags:       
92d1			 
92d1			ENABLE_HDIAGS: equ 0 
92d1			 
92d1			if ENABLE_HDIAGS 
92d1			.diagm: 
92d1				ld hl, .menuitems 
92d1				ld a, 0 
92d1				call menu 
92d1			 
92d1			         cp 0 
92d1				 ret z 
92d1			 
92d1				cp 2 
92d1				jp z, .diagedit 
92d1			 
92d1			;	cp '6' 
92d1			;	jp z, .menutest 
92d1			;if ENABLE_BASIC 
92d1			;	cp '6' 
92d1			;	jp z, basic 
92d1			;endif 
92d1			  
92d1				jp .diagm 
92d1			 
92d1				 
92d1			.menuitems:   	dw .m1 
92d1					dw .m2 
92d1					dw .m3 
92d1					dw .m5 
92d1					dw .m5a 
92d1					dw .m5b 
92d1					dw 0 
92d1			 
92d1			 
92d1			.m1:   db "Key Matrix",0 
92d1			.m2:   db "Editor",0 
92d1			.m3:   db "Storage",0 
92d1			.m5:   db "Sound",0 
92d1			.m5a:  db "RAM Test",0 
92d1			.m5b:  db "LCD Test",0 
92d1			 
92d1			 
92d1			; debug editor 
92d1			 
92d1			.diagedit: 
92d1			 
92d1				ld hl, scratch 
92d1			;	ld bc, 250 
92d1			;	ldir 
92d1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92d1			;	ld a, 0 
92d1				ld (hl), 0 
92d1				inc hl 
92d1				ld (hl), 0 
92d1				inc hl 
92d1				ld (hl), 0 
92d1			 
92d1			        call clear_display 
92d1				call update_display 
92d1				;ld a, 1 
92d1				;ld (hardware_diag), a 
92d1			.diloop: 
92d1				ld a, display_row_1 
92d1				ld c, 0 
92d1				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92d1				ld e, 40 
92d1			 
92d1				ld hl, scratch	 
92d1				call input_str 
92d1			 
92d1				ld a, display_row_2 
92d1				ld de, scratch 
92d1				call str_at_display 
92d1				call update_display 
92d1			 
92d1				jp .diloop 
92d1			endif 
92d1			 
92d1			; pass word in hl 
92d1			; a has display location 
92d1			display_word_at: 
92d1 f5				push af 
92d2 e5				push hl 
92d3 7c				ld a,h 
92d4 21 b9 e5			ld hl, os_word_scratch 
92d7 cd d7 8e			call hexout 
92da e1				pop hl 
92db 7d				ld a,l 
92dc 21 bb e5			ld hl, os_word_scratch+2 
92df cd d7 8e			call hexout 
92e2 21 bd e5			ld hl, os_word_scratch+4 
92e5			;	ld a,0 
92e5 36 00			ld (hl),0 
92e7 11 b9 e5			ld de,os_word_scratch 
92ea f1				pop af 
92eb cd c3 8a				call str_at_display 
92ee c9				ret 
92ef			 
92ef			display_ptr_state: 
92ef			 
92ef				; to restore afterwards 
92ef			 
92ef d5				push de 
92f0 c5				push bc 
92f1 e5				push hl 
92f2 f5				push af 
92f3			 
92f3				; for use in here 
92f3			 
92f3			;	push bc 
92f3			;	push de 
92f3			;	push hl 
92f3			;	push af 
92f3			 
92f3 cd b1 8a			call clear_display 
92f6			 
92f6 11 ce 94			ld de, .ptrstate 
92f9 3e 00			ld a, display_row_1 
92fb cd c3 8a			call str_at_display 
92fe			 
92fe				; display debug step 
92fe			 
92fe			 
92fe 11 5e ee			ld de, debug_mark 
9301 3e 26			ld a, display_row_1+display_cols-2 
9303 cd c3 8a			call str_at_display 
9306			 
9306				; display a 
9306 11 d8 94			ld de, .ptrcliptr 
9309 3e 28			ld a, display_row_2 
930b cd c3 8a			call str_at_display 
930e			 
930e f1				pop af 
930f 2a 33 ea			ld hl,(cli_ptr) 
9312 3e 30			ld a, display_row_2+8 
9314 cd d1 92			call display_word_at 
9317			 
9317			 
9317				; display hl 
9317			 
9317			 
9317 11 e0 94			ld de, .ptrclioptr 
931a 3e 32			ld a, display_row_2+10 
931c cd c3 8a			call str_at_display 
931f			; 
931f			;	pop hl 
931f 3e 35			ld a, display_row_2+13 
9321 2a 31 ea			ld hl,(cli_origptr) 
9324 cd d1 92			call display_word_at 
9327			; 
9327			;	 
9327			;	; display de 
9327			 
9327			;	ld de, .regstatede 
9327			;	ld a, display_row_3 
9327			;	call str_at_display 
9327			 
9327			;	pop de 
9327			;	ld h,d 
9327			;	ld l, e 
9327			;	ld a, display_row_3+3 
9327			;	call display_word_at 
9327			 
9327			 
9327				; display bc 
9327			 
9327			;	ld de, .regstatebc 
9327			;	ld a, display_row_3+10 
9327			;	call str_at_display 
9327			 
9327			;	pop bc 
9327			;	ld h,b 
9327			;	ld l, c 
9327			;	ld a, display_row_3+13 
9327			;	call display_word_at 
9327			 
9327			 
9327				; display dsp 
9327			 
9327			;	ld de, .regstatedsp 
9327			;	ld a, display_row_4 
9327			;	call str_at_display 
9327			 
9327				 
9327			;	ld hl,(cli_data_sp) 
9327			;	ld a, display_row_4+4 
9327			;	call display_word_at 
9327			 
9327				; display rsp 
9327			 
9327 11 0f 95			ld de, .regstatersp 
932a 3e 82			ld a, display_row_4+10 
932c cd c3 8a			call str_at_display 
932f			 
932f				 
932f 2a e5 e9			ld hl,(cli_ret_sp) 
9332 3e 86			ld a, display_row_4+14 
9334 cd d1 92			call display_word_at 
9337			 
9337 cd d3 8a			call update_display 
933a			 
933a cd f0 89			call delay1s 
933d cd f0 89			call delay1s 
9340 cd f0 89			call delay1s 
9343			 
9343			 
9343 cd 44 99			call next_page_prompt 
9346			 
9346				; restore  
9346			 
9346 f1				pop af 
9347 e1				pop hl 
9348 c1				pop bc 
9349 d1				pop de 
934a c9				ret 
934b			 
934b			; Update the break point vector so that the user can hook a new routine 
934b			 
934b			bp_on: 
934b 3e c3			ld a, $c3    ; JP 
934d 32 6b ee			ld (debug_vector), a 
9350 21 5d 93			ld hl, break_point_state 
9353 22 6c ee			ld (debug_vector+1), hl 
9356 c9				ret 
9357			 
9357			bp_off: 
9357 3e c9			ld a, $c9    ; RET 
9359 32 6b ee			ld (debug_vector), a 
935c c9				ret 
935d			 
935d			 
935d			break_point_state: 
935d			;	push af 
935d			; 
935d			;	; see if disabled 
935d			; 
935d			;	ld a, (os_view_disable) 
935d			;	cp '*' 
935d			;	jr nz, .bpsgo 
935d			;	pop af 
935d			;	ret 
935d			 
935d			.bpsgo: 
935d			;	pop af 
935d f5				push af 
935e 22 96 e2			ld (os_view_hl), hl 
9361 ed 53 94 e2		ld (os_view_de), de 
9365 ed 43 92 e2		ld (os_view_bc), bc 
9369 e5				push hl 
936a 6f				ld l, a 
936b 26 00			ld h, 0 
936d 22 98 e2			ld (os_view_af),hl 
9370			 
9370 21 a4 ed				ld hl, display_fb0 
9373 22 bf eb				ld (display_fb_active), hl 
9376 e1				pop hl	 
9377			 
9377 3e 31			ld a, '1' 
9379 fe 2a		.bps1:  cp '*' 
937b cc 57 93			call z, bp_off 
937e			;	jr nz, .bps1b 
937e			;	ld (os_view_disable),a 
937e fe 31		.bps1b:  cp '1' 
9380 20 14			jr nz, .bps2 
9382			 
9382				; display reg 
9382			 
9382				 
9382			 
9382 3a 98 e2			ld a, (os_view_af) 
9385 2a 96 e2			ld hl, (os_view_hl) 
9388 ed 5b 94 e2		ld de, (os_view_de) 
938c ed 4b 92 e2		ld bc, (os_view_bc) 
9390 cd 2a 94			call display_reg_state 
9393 c3 16 94			jp .bpschk 
9396			 
9396 fe 32		.bps2:  cp '2' 
9398 20 08			jr nz, .bps3 
939a				 
939a				; display hl 
939a 2a 96 e2			ld hl, (os_view_hl) 
939d cd 14 95			call display_dump_at_hl 
93a0			 
93a0 18 74			jr .bpschk 
93a2			 
93a2 fe 33		.bps3:  cp '3' 
93a4 20 08			jr nz, .bps4 
93a6			 
93a6			        ; display de 
93a6 2a 94 e2			ld hl, (os_view_de) 
93a9 cd 14 95			call display_dump_at_hl 
93ac			 
93ac 18 68			jr .bpschk 
93ae fe 34		.bps4:  cp '4' 
93b0 20 08			jr nz, .bps5 
93b2			 
93b2			        ; display bc 
93b2 2a 92 e2			ld hl, (os_view_bc) 
93b5 cd 14 95			call display_dump_at_hl 
93b8			 
93b8 18 5c			jr .bpschk 
93ba fe 35		.bps5:  cp '5' 
93bc 20 08		        jr nz, .bps7 
93be			 
93be				; display cur ptr 
93be 2a 33 ea			ld hl, (cli_ptr) 
93c1 cd 14 95			call display_dump_at_hl 
93c4			 
93c4 18 50			jr .bpschk 
93c6 fe 36		.bps7:  cp '6' 
93c8 20 08			jr nz, .bps8b 
93ca				 
93ca				; display cur orig ptr 
93ca 2a 31 ea			ld hl, (cli_origptr) 
93cd cd 14 95			call display_dump_at_hl 
93d0 18 44			jr .bpschk 
93d2 fe 37		.bps8b:  cp '7' 
93d4 20 08			jr nz, .bps9 
93d6				 
93d6				; display dsp 
93d6 2a e1 e9			ld hl, (cli_data_sp) 
93d9 cd 14 95			call display_dump_at_hl 
93dc			 
93dc 18 38			jr .bpschk 
93de fe 39		.bps9:  cp '9' 
93e0 20 05			jr nz, .bps8c 
93e2				 
93e2				; display SP 
93e2			;	ld hl, sp 
93e2 cd 14 95			call display_dump_at_hl 
93e5			 
93e5 18 2f			jr .bpschk 
93e7 fe 38		.bps8c:  cp '8' 
93e9 20 08			jr nz, .bps8d 
93eb				 
93eb				; display rsp 
93eb 2a e5 e9			ld hl, (cli_ret_sp) 
93ee cd 14 95			call display_dump_at_hl 
93f1			 
93f1 18 23			jr .bpschk 
93f3 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93f5 20 05			jr nz, .bps8 
93f7 cd 02 97			call monitor 
93fa			 
93fa 18 1a			jr .bpschk 
93fc fe 30		.bps8:  cp '0' 
93fe 20 16			jr nz, .bpschk 
9400			 
9400 21 03 ed				ld hl, display_fb1 
9403 22 bf eb				ld (display_fb_active), hl 
9406 cd d3 8a				call update_display 
9409			 
9409				;ld a, (os_view_af) 
9409 2a 96 e2			ld hl, (os_view_hl) 
940c ed 5b 94 e2		ld de, (os_view_de) 
9410 ed 4b 92 e2		ld bc, (os_view_bc) 
9414 f1				pop af 
9415 c9				ret 
9416			 
9416			.bpschk:   
9416 cd f0 89			call delay1s 
9419 3e 9f		ld a,display_row_4 + display_cols - 1 
941b 11 42 99		        ld de, endprg 
941e cd c3 8a			call str_at_display 
9421 cd d3 8a			call update_display 
9424 cd 27 e6			call cin_wait 
9427			 
9427 c3 79 93			jp .bps1 
942a			 
942a			 
942a			display_reg_state: 
942a			 
942a				; to restore afterwards 
942a			 
942a d5				push de 
942b c5				push bc 
942c e5				push hl 
942d f5				push af 
942e			 
942e				; for use in here 
942e			 
942e c5				push bc 
942f d5				push de 
9430 e5				push hl 
9431 f5				push af 
9432			 
9432 cd b1 8a			call clear_display 
9435			 
9435 11 ea 94			ld de, .regstate 
9438 3e 00			ld a, display_row_1 
943a cd c3 8a			call str_at_display 
943d			 
943d				; display debug step 
943d			 
943d			 
943d 11 5e ee			ld de, debug_mark 
9440 3e 25			ld a, display_row_1+display_cols-3 
9442 cd c3 8a			call str_at_display 
9445			 
9445				; display a 
9445 11 06 95			ld de, .regstatea 
9448 3e 28			ld a, display_row_2 
944a cd c3 8a			call str_at_display 
944d			 
944d e1				pop hl 
944e			;	ld h,0 
944e			;	ld l, a 
944e 3e 2b			ld a, display_row_2+3 
9450 cd d1 92			call display_word_at 
9453			 
9453			 
9453				; display hl 
9453			 
9453			 
9453 11 fa 94			ld de, .regstatehl 
9456 3e 32			ld a, display_row_2+10 
9458 cd c3 8a			call str_at_display 
945b			 
945b e1				pop hl 
945c 3e 35			ld a, display_row_2+13 
945e cd d1 92			call display_word_at 
9461			 
9461				 
9461				; display de 
9461			 
9461 11 fe 94			ld de, .regstatede 
9464 3e 50			ld a, display_row_3 
9466 cd c3 8a			call str_at_display 
9469			 
9469 e1				pop hl 
946a			;	ld h,d 
946a			;	ld l, e 
946a 3e 53			ld a, display_row_3+3 
946c cd d1 92			call display_word_at 
946f			 
946f			 
946f				; display bc 
946f			 
946f 11 02 95			ld de, .regstatebc 
9472 3e 5a			ld a, display_row_3+10 
9474 cd c3 8a			call str_at_display 
9477			 
9477 e1				pop hl 
9478			;	ld h,b 
9478			;	ld l, c 
9478 3e 5d			ld a, display_row_3+13 
947a cd d1 92			call display_word_at 
947d			 
947d			 
947d				; display dsp 
947d			 
947d 11 0a 95			ld de, .regstatedsp 
9480 3e 78			ld a, display_row_4 
9482 cd c3 8a			call str_at_display 
9485			 
9485				 
9485 2a e1 e9			ld hl,(cli_data_sp) 
9488 3e 7c			ld a, display_row_4+4 
948a cd d1 92			call display_word_at 
948d			 
948d				; display rsp 
948d			 
948d 11 0f 95			ld de, .regstatersp 
9490 3e 82			ld a, display_row_4+10 
9492 cd c3 8a			call str_at_display 
9495			 
9495				 
9495 2a e5 e9			ld hl,(cli_ret_sp) 
9498 3e 86			ld a, display_row_4+14 
949a cd d1 92			call display_word_at 
949d			 
949d cd d3 8a			call update_display 
94a0			 
94a0			;	call delay1s 
94a0			;	call delay1s 
94a0			;	call delay1s 
94a0			 
94a0			 
94a0			;	call next_page_prompt 
94a0			 
94a0				; restore  
94a0			 
94a0 f1				pop af 
94a1 e1				pop hl 
94a2 c1				pop bc 
94a3 d1				pop de 
94a4 c9				ret 
94a5			 
94a5 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94b9 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94ce .. 00		.ptrstate:	db "Ptr State",0 
94d8 .. 00		.ptrcliptr:     db "cli_ptr",0 
94e0 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94ea .. 00		.regstate:	db "Reg State (1/0)",0 
94fa .. 00		.regstatehl:	db "HL:",0 
94fe .. 00		.regstatede:	db "DE:",0 
9502 .. 00		.regstatebc:	db "BC:",0 
9506 .. 00		.regstatea:	db "A :",0 
950a .. 00		.regstatedsp:	db "DSP:",0 
950f .. 00		.regstatersp:	db "RSP:",0 
9514			 
9514			display_dump_at_hl: 
9514 e5				push hl 
9515 d5				push de 
9516 c5				push bc 
9517 f5				push af 
9518			 
9518 22 d7 e5			ld (os_cur_ptr),hl	 
951b cd b1 8a			call clear_display 
951e cd 50 98			call dumpcont 
9521			;	call delay1s 
9521			;	call next_page_prompt 
9521			 
9521			 
9521 f1				pop af 
9522 c1				pop bc 
9523 d1				pop de 
9524 e1				pop hl 
9525 c9				ret 
9526			 
9526			;if ENABLE_BASIC 
9526			;	include "nascombasic.asm" 
9526			;	basic: 
9526			;	include "forth/FORTH.ASM" 
9526			;endif 
9526			 
9526			; eof 
9526			 
9526			 
# End of file firmware_diags.asm
9526			  
9526			include "firmware_prompts.asm"  
9526			; Prompts  
9526			 
9526			; boot messages 
9526			 
9526 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
953b .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
954b			 
954b			 
954b			; config menus 
954b			 
954b			;prom_c3: db "Add Dictionary To File",0 
954b			 
954b			if STARTUP_V1 
954b .. 00		prom_c2: db "Select Autoload File",0 
9560 .. 00		prom_c2a: db "Disable Autoload File", 0 
9576			endif 
9576			 
9576			if STARTUP_V2 
9576			prom_c2: db "Enable Autoload Files",0 
9576			prom_c2a: db "Disable Autoload Files", 0 
9576			 
9576			crs_s1: db "*ls-word", 0 
9576			crs_s2: db "*ed-word", 0 
9576			crs_s3: db "*Demo-Games", 0 
9576			crs_s4: db "*Utils", 0 
9576			crs_s5: db "*SPI-Util", 0 
9576			crs_s6: db "*Key-Constants", 0 
9576			crs_sound: db "*Sound-Util", 0 
9576			crs_hw: db "*Hello-World",0 
9576			 
9576			 
9576			 
9576			endif 
9576			;prom_c2b: db "Select Storage Bank",0 
9576 .. 00		prom_c4: db "Settings",0 
957f .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
959a .. 00		prom_m4b:   db "Monitor",0 
95a2			;prom_c1: db "Hardware Diags",0 
95a2			 
95a2			 
95a2			if STARTUP_V2 
95a2			prom_c9: db "Create Startup Files",0 
95a2			prom_bsel: db "Start From Bank...",0 
95a2			prom_bsel1: db "Bank 1",0 
95a2			prom_bsel2: db "Bank 2",0 
95a2			prom_bsel3: db "Bank 3",0 
95a2			prom_bsel4: db "Bank 4",0 
95a2			prom_bsel5: db "Bank 5",0 
95a2			 
95a2			prom_banks: 
95a2				dw prom_bsel1 
95a2				dw prom_bsel2 
95a2				dw prom_bsel3 
95a2				dw prom_bsel4 
95a2				dw prom_bsel5 
95a2				dw 0 
95a2			endif 
95a2			 
95a2 .. 00		prom_notav:    db "Feature not available",0 
95b8 .. 00		prom_empty:    db "",0 
95b9			 
95b9			; eof 
95b9			 
# End of file firmware_prompts.asm
95b9			  
95b9			; eof  
95b9			  
# End of file firmware.asm
95b9			 
95b9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
95b9			;if BASE_KEV  
95b9			;baseram: equ 08000h 
95b9			;endif 
95b9			 
95b9			;if BASE_SC114 
95b9			;baseram:     equ    endofcode 
95b9			;endif 
95b9			 
95b9			 
95b9			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
95b9			 
95b9			; start system 
95b9			 
95b9			coldstart: 
95b9				; set sp 
95b9				; di/ei 
95b9			 
95b9 f3				di 
95ba 31 00 f0			ld sp, tos 
95bd cd 68 e5			call init_nmi 
95c0			;	ei 
95c0			 
95c0				; init spinner 
95c0 3e 00			ld a,0 
95c2 32 b9 eb			ld (display_active), a 
95c5			 
95c5				; disable breakpoint by default 
95c5			 
95c5				;ld a,'*' 
95c5			;	ld a,' ' 
95c5			;	ld (os_view_disable),a 
95c5			 
95c5				; set break point vector as new break point on or off 
95c5 cd 57 93			call bp_off 
95c8			 
95c8			 
95c8				; default the parse vector to just a RET 
95c8 3e c9			ld a, $c9 
95ca 32 68 ee			ld (parse_vector), a 
95cd			 
95cd				; init hardware 
95cd			 
95cd				; init keyboard and screen hardware 
95cd			 
95cd cd 1f 80			call hardware_init 
95d0			 
95d0			 
95d0 cd f0 89			call delay1s 
95d3 3e 58			ld a, display_row_3+8 
95d5 11 03 80			ld de, buildtime 
95d8 cd c3 8a			call str_at_display 
95db cd d3 8a			call update_display 
95de			 
95de cd f0 89			call delay1s 
95e1 cd f0 89			call delay1s 
95e4 cd f0 89			call delay1s 
95e7			 
95e7				; detect if any keys are held down to enable breakpoints at start up 
95e7			 
95e7 cd 2d e6			call cin  
95ea fe 00			cp 0 
95ec 28 03			jr z, .nokeys 
95ee			 
95ee				;call hardware_diags 
95ee cd 40 92			call config 
95f1			 
95f1			;	ld de, .bpen 
95f1			;	ld a, display_row_4 
95f1			;	call str_at_display 
95f1			;	call update_display 
95f1			; 
95f1			;	ld a,0 
95f1			;	ld (os_view_disable),a 
95f1			; 
95f1			;.bpwait: 
95f1			;	call cin 
95f1			;	cp 0 
95f1			;	jr z, .bpwait 
95f1			;	jr .nokeys 
95f1			; 
95f1			; 
95f1			;.bpen:  db "Break points enabled!",0 
95f1			 
95f1			 
95f1			 
95f1			 
95f1			 
95f1			 
95f1			.nokeys: 
95f1			 
95f1			 
95f1				 
95f1			 
95f1			;jp  testkey 
95f1			 
95f1			;call storage_get_block_0 
95f1			; 
95f1			;ld hl, 0 
95f1			;ld de, store_page 
95f1			;call storage_read_block 
95f1			 
95f1				 
95f1			;ld hl, 10 
95f1			;ld de, store_page 
95f1			;call storage_read_block 
95f1			 
95f1			 
95f1			 
95f1			 
95f1			 
95f1			;stop:	nop 
95f1			;	jp stop 
95f1			 
95f1			 
95f1			 
95f1			main: 
95f1 cd b1 8a			call clear_display 
95f4 cd d3 8a			call update_display 
95f7			 
95f7			 
95f7			 
95f7			;	call testlcd 
95f7			 
95f7			 
95f7			 
95f7 cd 7f 9d			call forth_init 
95fa			 
95fa			 
95fa			warmstart: 
95fa cd 55 9d			call forth_warmstart 
95fd			 
95fd				; run startup word load 
95fd			        ; TODO prevent this running at warmstart after crash  
95fd			 
95fd				if STARTUP_ENABLE 
95fd			 
95fd					if STARTUP_V1 
95fd			 
95fd						if STORAGE_SE 
95fd							call forth_autoload 
95fd						endif 
95fd cd b8 e4					call forth_startup 
9600					endif 
9600			 
9600					if STARTUP_V2 
9600			 
9600						if STORAGE_SE 
9600							call forth_autoload 
9600						else 
9600							call forth_startup 
9600						endif 
9600			 
9600			 
9600					endif 
9600			 
9600				endif 
9600			 
9600			warmstart_afterauto: 
9600			 
9600				; show free memory after boot 
9600 11 9d 96			ld de, freeram 
9603 3e 00			ld a, display_row_1 
9605 cd c3 8a			call str_at_display 
9608			 
9608				; get current heap start after loading any uwords 
9608			 
9608				;ld de, (os_last_new_uword) 
9608				;ex de, hl 
9608			 
9608			; Or use heap_size word???? 
9608				;ld hl, heap_end 
9608				;ld hl, heap_size 
9608				;ld de, topusermem 
9608				;ld de, heap_start 
9608 ed 5b 46 e6			ld de, (free_list )      
960c 21 8f e2				ld hl, heap_end 
960f ed 52			sbc hl, de 
9611				;push hl 
9611				;ld a,h	         	 
9611				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9611				;call hexout 
9611			   	;pop hl 
9611			; 
9611			;	ld a,l 
9611			;	ld hl, os_word_scratch+2 
9611			;	call hexout 
9611			;	ld hl, os_word_scratch+4 
9611			;	ld a, 0 
9611			;	ld (hl),a 
9611 eb				ex de, hl 
9612 21 b9 e5			ld hl, os_word_scratch 
9615 cd e2 8f			call uitoa_16 
9618			 
9618			 
9618 11 b9 e5			ld de, os_word_scratch 
961b 3e 0d			ld a, display_row_1 + 13 
961d cd c3 8a			call str_at_display 
9620 cd d3 8a			call update_display 
9623			 
9623			 
9623				;call demo 
9623			 
9623			 
9623				; init scratch input area for cli commands 
9623			 
9623 21 db e5			ld hl, os_cli_cmd 
9626			;	ld a,0 
9626 36 00			ld (hl),0 
9628 23				inc hl 
9629 36 00			ld (hl),0 
962b			 
962b 3e 00			ld a,0 
962d 32 da e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9630			 
9630 32 d7 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9633 32 d8 e5			ld (os_cur_ptr+1),a	 
9636			 
9636 32 b9 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9639 32 ba e5			ld (os_word_scratch+1),a	 
963c				 
963c			 
963c				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
963c 21 db e5			ld hl, os_cli_cmd 
963f			 
963f			;	ld a, 0		 ; init cli input 
963f 36 00			ld (hl), 0 
9641 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9643			cli: 
9643				; show cli prompt 
9643				;push af 
9643				;ld a, 0 
9643				;ld de, prompt 
9643				;call str_at_display 
9643			 
9643				;call update_display 
9643				;pop af 
9643				;inc a 
9643				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9643			 
9643			.lastrecall: 
9643			 
9643 0e 00			ld c, 0 
9645 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9647 1e 28			ld e, 40 
9649			 
9649 21 db e5			ld hl, os_cli_cmd 
964c			 
964c				STACKFRAME OFF $fefe $9f9f 
964c				if DEBUG_STACK_IMB 
964c					if OFF 
964c						exx 
964c						ld de, $fefe 
964c						ld a, d 
964c						ld hl, curframe 
964c						call hexout 
964c						ld a, e 
964c						ld hl, curframe+2 
964c						call hexout 
964c						ld hl, $fefe 
964c						push hl 
964c						ld hl, $9f9f 
964c						push hl 
964c						exx 
964c					endif 
964c				endif 
964c			endm 
# End of macro STACKFRAME
964c			 
964c cd 08 8d			call input_str 
964f			 
964f				STACKFRAMECHK OFF $fefe $9f9f 
964f				if DEBUG_STACK_IMB 
964f					if OFF 
964f						exx 
964f						ld hl, $9f9f 
964f						pop de   ; $9f9f 
964f						call cmp16 
964f						jr nz, .spnosame 
964f						ld hl, $fefe 
964f						pop de   ; $fefe 
964f						call cmp16 
964f						jr z, .spfrsame 
964f						.spnosame: call showsperror 
964f						.spfrsame: nop 
964f						exx 
964f					endif 
964f				endif 
964f			endm 
# End of macro STACKFRAMECHK
964f			 
964f			 
964f				; check to see if last line recall has been requested 
964f			 
964f			if EDIT_V2 
964f fe 05			cp KEY_UP 
9651 20 0f			jr nz, .noexecline 
9653			 
9653 11 db e5			ld de, os_cli_cmd 
9656 21 da e6			ld hl, os_last_cmd 
9659 01 ff 00			ld bc, 255 
965c ed b0			ldir 
965e 3e 00			ld a, 0 
9660 18 e1			jr .lastrecall 
9662			endif 
9662			 
9662			.noexecline: 
9662				; no so exec the line		 
9662			 
9662				; copy input to last command 
9662			 
9662 21 db e5			ld hl, os_cli_cmd 
9665 11 da e6			ld de, os_last_cmd 
9668 01 ff 00			ld bc, 255 
966b ed b0			ldir 
966d			 
966d				; wipe current buffer 
966d			 
966d			;	ld a, 0 
966d			;	ld hl, os_cli_cmd 
966d			;	ld de, os_cli_cmd+1 
966d			;	ld bc, 254 
966d			;	ldir 
966d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
966d			;	call strcpy 
966d			;	ld a, 0 
966d			;	ld (hl), a 
966d			;	inc hl 
966d			;	ld (hl), a 
966d			;	inc hl 
966d			;	ld (hl), a 
966d			 
966d				; switch frame buffer to program  
966d			 
966d 21 03 ed				ld hl, display_fb1 
9670 22 bf eb				ld (display_fb_active), hl 
9673			 
9673			;	nop 
9673				STACKFRAME ON $fbfe $8f9f 
9673				if DEBUG_STACK_IMB 
9673					if ON 
9673						exx 
9673						ld de, $fbfe 
9673						ld a, d 
9673						ld hl, curframe 
9673						call hexout 
9673						ld a, e 
9673						ld hl, curframe+2 
9673						call hexout 
9673						ld hl, $fbfe 
9673						push hl 
9673						ld hl, $8f9f 
9673						push hl 
9673						exx 
9673					endif 
9673				endif 
9673			endm 
# End of macro STACKFRAME
9673				; first time into the parser so pass over the current scratch pad 
9673 21 db e5			ld hl,os_cli_cmd 
9676				; tokenise the entered statement(s) in HL 
9676 cd f5 9d			call forthparse 
9679			        ; exec forth statements in top of return stack 
9679 cd 2d 9e			call forthexec 
967c				;call forthexec_cleanup 
967c			;	call parsenext 
967c			 
967c				STACKFRAMECHK ON $fbfe $8f9f 
967c				if DEBUG_STACK_IMB 
967c					if ON 
967c						exx 
967c						ld hl, $8f9f 
967c						pop de   ; $8f9f 
967c						call cmp16 
967c						jr nz, .spnosame 
967c						ld hl, $fbfe 
967c						pop de   ; $fbfe 
967c						call cmp16 
967c						jr z, .spfrsame 
967c						.spnosame: call showsperror 
967c						.spfrsame: nop 
967c						exx 
967c					endif 
967c				endif 
967c			endm 
# End of macro STACKFRAMECHK
967c				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
967c			 
967c 3e 78			ld a, display_row_4 
967e 11 ae 96			ld de, endprog 
9681			 
9681 cd d3 8a			call update_display		 
9684			 
9684 cd 44 99			call next_page_prompt 
9687			 
9687				; switch frame buffer to cli 
9687			 
9687 21 a4 ed				ld hl, display_fb0 
968a 22 bf eb				ld (display_fb_active), hl 
968d			 
968d			 
968d cd b1 8a		        call clear_display 
9690 cd d3 8a			call update_display		 
9693			 
9693 21 db e5			ld hl, os_cli_cmd 
9696			 
9696			;	ld a, 0		 ; init cli input 
9696 36 00			ld (hl), 0 
9698			 
9698				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9698			 
9698				; now on last line 
9698			 
9698				; TODO scroll screen up 
9698			 
9698				; TODO instead just clear screen and place at top of screen 
9698			 
9698			;	ld a, 0 
9698			;	ld (f_cursor_ptr),a 
9698			 
9698				;call clear_display 
9698				;call update_display 
9698			 
9698				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9698 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
969a c3 43 96			jp cli 
969d			 
969d .. 00		freeram: db "Free bytes: ",0 
96aa ..			asc: db "1A2F" 
96ae .. 00		endprog: db "End prog...",0 
96ba			 
96ba			testenter2:   
96ba 21 e6 e2			ld hl,scratch+50 
96bd 22 d7 e5			ld (os_cur_ptr),hl 
96c0 c3 43 96			jp cli 
96c3			 
96c3			testenter:  
96c3			 
96c3 21 aa 96			ld hl,asc 
96c6			;	ld a,(hl) 
96c6			;	call nibble2val 
96c6 cd 2d 8f			call get_byte 
96c9			 
96c9			 
96c9			;	ld a,(hl) 
96c9			;	call atohex 
96c9			 
96c9			;	call fourehexhl 
96c9 32 e6 e2			ld (scratch+50),a 
96cc			 
96cc			 
96cc			 
96cc 21 ac 96			ld hl,asc+2 
96cf			;	ld a, (hl) 
96cf			;	call nibble2val 
96cf cd 2d 8f			call get_byte 
96d2			 
96d2			;	call fourehexhl 
96d2 32 e8 e2			ld (scratch+52),a 
96d5				 
96d5 21 e6 e2			ld hl,scratch+50 
96d8 22 d7 e5			ld (os_cur_ptr),hl 
96db c3 43 96			jp cli 
96de			 
96de			enter:	 
96de 3a b8 e2			ld a,(scratch+4) 
96e1 fe 00			cp 0 
96e3 28 0c			jr z, .entercont 
96e5				; no, not a null term line so has an address to work out.... 
96e5			 
96e5 21 b6 e2			ld hl,scratch+2 
96e8 cd 8d 8f			call get_word_hl 
96eb			 
96eb 22 d7 e5			ld (os_cur_ptr),hl	 
96ee c3 43 96			jp cli 
96f1			 
96f1			 
96f1			.entercont:  
96f1			 
96f1 21 b6 e2			ld hl, scratch+2 
96f4 cd 2d 8f			call get_byte 
96f7			 
96f7 2a d7 e5		   	ld hl,(os_cur_ptr) 
96fa 77					ld (hl),a 
96fb 23					inc hl 
96fc 22 d7 e5				ld (os_cur_ptr),hl 
96ff				 
96ff			; get byte  
96ff			 
96ff			 
96ff c3 43 96			jp cli 
9702			 
9702			 
9702			; basic monitor support 
9702			 
9702			monitor: 
9702				;  
9702 cd b1 8a			call clear_display 
9705 3e 00			ld a, 0 
9707 11 5b 97			ld de, .monprompt 
970a cd c3 8a			call str_at_display 
970d cd d3 8a			call update_display 
9710			 
9710				; get a monitor command 
9710			 
9710 0e 00			ld c, 0     ; entry at top left 
9712 16 64			ld d, 100   ; max buffer size 
9714 1e 0f			ld e, 15    ; input scroll area 
9716			;	ld a, 0     ; init string 
9716 21 b2 e4			ld hl, os_input 
9719 36 00			ld (hl), 0 
971b 23				inc hl 
971c 36 00			ld (hl), 0 
971e 21 b2 e4			ld hl, os_input 
9721 3e 01			ld a, 1     ; init string 
9723 cd 08 8d			call input_str 
9726			 
9726 cd b1 8a		        call clear_display 
9729 cd d3 8a			call update_display		 
972c			 
972c 3a b2 e4			ld a, (os_input) 
972f cd 2a 90			call toUpper 
9732 fe 48		        cp 'H' 
9734 ca cf 97		        jp z, .monhelp 
9737 fe 44			cp 'D'		; dump 
9739 ca 02 98			jp z, .mondump	 
973c fe 43			cp 'C'		; dump 
973e ca 1c 98			jp z, .moncdump	 
9741 fe 4d			cp 'M'		; dump 
9743 ca 5d 97			jp z, .moneditstart 
9746 fe 55			cp 'U'		; dump 
9748 ca 69 97			jp z, .monedit	 
974b fe 47			cp 'G'		; dump 
974d ca f8 97			jp z, .monjump 
9750 fe 42			cp 'B'		; forth breakpoint 
9752 cc 5d 93			call z, break_point_state 
9755 fe 51			cp 'Q'		; dump 
9757 c8				ret z	 
9758			 
9758			 
9758				; TODO "S" to access symbol by name and not need the address 
9758				; TODO "F" to find a string in memory 
9758			 
9758 c3 02 97			jp monitor 
975b			 
975b .. 00		.monprompt: db ">", 0 
975d			 
975d			.moneditstart: 
975d				; get starting address 
975d			 
975d 21 b4 e4			ld hl,os_input+2 
9760 cd 8d 8f			call get_word_hl 
9763			 
9763 22 d7 e5			ld (os_cur_ptr),hl	 
9766			 
9766 c3 02 97			jp monitor 
9769			 
9769			.monedit: 
9769				; get byte to load 
9769			 
9769 21 b4 e4			ld hl,os_input+2 
976c cd 2d 8f			call get_byte 
976f			 
976f				; get address to update 
976f 2a d7 e5			ld hl, (os_cur_ptr) 
9772			 
9772				; update byte 
9772			 
9772 77				ld (hl), a 
9773			 
9773				; move to next address and save it 
9773			 
9773 23				inc hl 
9774 22 d7 e5			ld (os_cur_ptr),hl	 
9777			 
9777 c3 02 97			jp monitor 
977a			 
977a			 
977a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
978e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
97aa .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
97c8 .. 00		.monhelptext4:  db "Q-Quit",0 
97cf			        
97cf			.monhelp: 
97cf 3e 00			ld a, display_row_1 
97d1 11 7a 97		        ld de, .monhelptext1 
97d4			 
97d4 cd c3 8a			call str_at_display 
97d7 3e 28			ld a, display_row_2 
97d9 11 8e 97		        ld de, .monhelptext2 
97dc					 
97dc cd c3 8a			call str_at_display 
97df 3e 50			ld a, display_row_3 
97e1 11 aa 97		        ld de, .monhelptext3 
97e4					 
97e4 cd c3 8a			call str_at_display 
97e7 3e 78			ld a, display_row_4 
97e9 11 c8 97		        ld de, .monhelptext4 
97ec cd c3 8a			call str_at_display 
97ef			 
97ef cd d3 8a			call update_display		 
97f2			 
97f2 cd 44 99			call next_page_prompt 
97f5 c3 02 97			jp monitor 
97f8			 
97f8			.monjump:    
97f8 21 b4 e4			ld hl,os_input+2 
97fb cd 8d 8f			call get_word_hl 
97fe			 
97fe e9				jp (hl) 
97ff c3 02 97			jp monitor 
9802			 
9802			.mondump:    
9802 21 b4 e4			ld hl,os_input+2 
9805 cd 8d 8f			call get_word_hl 
9808			 
9808 22 d7 e5			ld (os_cur_ptr),hl	 
980b cd 50 98			call dumpcont 
980e 3e 78			ld a, display_row_4 
9810 11 ae 96			ld de, endprog 
9813			 
9813 cd d3 8a			call update_display		 
9816			 
9816 cd 44 99			call next_page_prompt 
9819 c3 02 97			jp monitor 
981c			.moncdump: 
981c cd 50 98			call dumpcont 
981f 3e 78			ld a, display_row_4 
9821 11 ae 96			ld de, endprog 
9824			 
9824 cd d3 8a			call update_display		 
9827			 
9827 cd 44 99			call next_page_prompt 
982a c3 02 97			jp monitor 
982d			 
982d			 
982d			; TODO symbol access  
982d			 
982d			.symbols:     ;; A list of symbols that can be called up  
982d a4 ed			dw display_fb0 
982f .. 00			db "fb0",0  
9833 6d ea		     	dw store_page 
9835 .. 00			db "store_page",0 
9840			 
9840			 
9840			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9840			 
9840 3a b5 e2			ld a,(scratch+1) 
9843 fe 00			cp 0 
9845 28 09			jr z, dumpcont 
9847			 
9847				; no, not a null term line so has an address to work out.... 
9847			 
9847 21 b6 e2			ld hl,scratch+2 
984a cd 8d 8f			call get_word_hl 
984d			 
984d 22 d7 e5			ld (os_cur_ptr),hl	 
9850			 
9850			 
9850			 
9850			dumpcont: 
9850			 
9850				; dump bytes at ptr 
9850			 
9850			 
9850 3e 00			ld a, display_row_1 
9852 2a bf eb			ld hl, (display_fb_active) 
9855 cd db 8c			call addatohl 
9858 cd 80 98			call .dumpbyterow 
985b			 
985b 3e 28			ld a, display_row_2 
985d 2a bf eb			ld hl, (display_fb_active) 
9860 cd db 8c			call addatohl 
9863 cd 80 98			call .dumpbyterow 
9866			 
9866			 
9866 3e 50			ld a, display_row_3 
9868 2a bf eb			ld hl, (display_fb_active) 
986b cd db 8c			call addatohl 
986e cd 80 98			call .dumpbyterow 
9871			 
9871 3e 78			ld a, display_row_4 
9873 2a bf eb			ld hl, (display_fb_active) 
9876 cd db 8c			call addatohl 
9879 cd 80 98			call .dumpbyterow 
987c			 
987c cd d3 8a			call update_display 
987f			;		jp cli 
987f c9				ret 
9880			 
9880			.dumpbyterow: 
9880			 
9880				;push af 
9880			 
9880 e5				push hl 
9881			 
9881				; calc where to poke the ascii 
9881			if display_cols == 20 
9881				ld a, 16 
9881			else 
9881 3e 1f			ld a, 31 
9883			endif 
9883			 
9883 cd db 8c			call addatohl 
9886 22 b9 e5			ld (os_word_scratch),hl  		; save pos for later 
9889			 
9889			 
9889			; display decoding address 
9889 2a d7 e5		   	ld hl,(os_cur_ptr) 
988c			 
988c 7c				ld a,h 
988d e1				pop hl 
988e e5				push hl 
988f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
988f cd d7 8e			call hexout 
9892 2a d7 e5		   	ld hl,(os_cur_ptr) 
9895			 
9895 7d				ld a,l 
9896 e1				pop hl 
9897 23				inc hl 
9898 23				inc hl 
9899 e5				push hl 
989a			;	ld hl, os_word_scratch+2 
989a cd d7 8e			call hexout 
989d e1				pop hl 
989e 23				inc hl 
989f 23				inc hl 
98a0				;ld hl, os_word_scratch+4 
98a0			;	ld a, ':' 
98a0 36 3a			ld (hl),':' 
98a2 23				inc hl 
98a3				;ld a, 0 
98a3				;ld (hl),a 
98a3				;ld de, os_word_scratch 
98a3				;pop af 
98a3				;push af 
98a3			;		ld a, display_row_2 
98a3			;		call str_at_display 
98a3			;		call update_display 
98a3			 
98a3			 
98a3			;pop af 
98a3			;	add 5 
98a3			 
98a3			if display_cols == 20 
98a3				ld b, 4 
98a3			else 
98a3 06 08			ld b, 8 
98a5			endif	 
98a5			 
98a5			.dumpbyte: 
98a5 c5				push bc 
98a6 e5				push hl 
98a7			 
98a7			 
98a7 2a d7 e5		   	ld hl,(os_cur_ptr) 
98aa 7e					ld a,(hl) 
98ab			 
98ab					; poke the ascii to display 
98ab 2a b9 e5				ld hl,(os_word_scratch) 
98ae 77					ld (hl),a 
98af 23					inc hl 
98b0 22 b9 e5				ld (os_word_scratch),hl 
98b3			 
98b3					 
98b3			 
98b3			 
98b3 e1					pop hl 
98b4 e5					push hl 
98b5			 
98b5 cd d7 8e				call hexout 
98b8			 
98b8					 
98b8 2a d7 e5		   	ld hl,(os_cur_ptr) 
98bb 23				inc hl 
98bc 22 d7 e5		   	ld (os_cur_ptr),hl 
98bf			 
98bf e1					pop hl 
98c0 23					inc hl 
98c1 23					inc hl 
98c2 23					inc hl 
98c3			 
98c3			 
98c3			 
98c3					;ld a,0 
98c3					;ld (os_word_scratch+2),a 
98c3					;pop af 
98c3					;push af 
98c3			 
98c3					;ld de, os_word_scratch 
98c3					;call str_at_display 
98c3			;		call update_display 
98c3			;		pop af 
98c3 c1					pop bc 
98c4 c6 03				add 3 
98c6 10 dd			djnz .dumpbyte 
98c8			 
98c8				 
98c8			 
98c8 c9				ret 
98c9			 
98c9			jump:	 
98c9			 
98c9 21 b6 e2			ld hl,scratch+2 
98cc cd 8d 8f			call get_word_hl 
98cf				;ld hl,(scratch+2) 
98cf				;call fourehexhl 
98cf			 
98cf 22 d7 e5			ld (os_cur_ptr),hl	 
98d2			 
98d2 e9				jp (hl) 
98d3			 
98d3			 
98d3			 
98d3			; TODO implement a basic monitor mode to start with 
98d3			 
98d3			 
98d3			 
98d3			 
98d3			 
98d3			 
98d3			 
98d3			 
98d3			 
98d3			; testing and demo code during development 
98d3			 
98d3			 
98d3 .. 00		str1: db "Enter some text...",0 
98e6 .. 00		clear: db "                    ",0 
98fb			 
98fb			demo: 
98fb			 
98fb			 
98fb			 
98fb			;	call update_display 
98fb			 
98fb				; init scratch input area for testing 
98fb 21 b4 e2			ld hl, scratch	 
98fe			;	ld a,0 
98fe 36 00			ld (hl),0 
9900			 
9900			 
9900 3e 28		            LD   A, display_row_2 
9902			;            CALL fLCD_Pos       ;Position cursor to location in A 
9902 11 d3 98		            LD   DE, str1 
9905 cd c3 8a			call str_at_display 
9908			 
9908			;            CALL fLCD_Str       ;Display string pointed to by DE 
9908			cloop:	 
9908 3e 50		            LD   A, display_row_3 
990a			;            CALL fLCD_Pos       ;Position cursor to location in A 
990a 11 e6 98		            LD   DE, clear 
990d			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
990d cd c3 8a				call str_at_display 
9910 3e 78			ld a, display_row_4 
9912 11 40 99			ld de, prompt 
9915			 
9915 cd c3 8a				call str_at_display 
9918 cd d3 8a			call update_display 
991b			 
991b 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
991d 16 0a			ld d, 10 
991f 21 b4 e2			ld hl, scratch	 
9922 cd 08 8d			call input_str 
9925			 
9925			;	call clear_display 
9925			;'	call update_display 
9925			 
9925 3e 00		            LD   A, display_row_1 
9927			;            CALL fLCD_Pos       ;Position cursor to location in A 
9927 11 e6 98		            LD   DE, clear 
992a cd c3 8a				call str_at_display 
992d			;            CALL fLCD_Str       ;Display string pointed to by DE 
992d 3e 00		            LD   A, display_row_1 
992f			;            CALL fLCD_Pos       ;Position cursor to location in A 
992f 11 b4 e2		            LD   DE, scratch 
9932			;            CALL fLCD_Str       ;Display string pointed to by DE 
9932 cd c3 8a				call str_at_display 
9935 cd d3 8a			call update_display 
9938			 
9938			;		ld a,0 
9938 21 b4 e2			ld hl, scratch 
993b 36 00			ld (hl),0 
993d			 
993d			;	nop 
993d c3 08 99			jp cloop 
9940			 
9940			 
9940			 
9940			; OS Prompt 
9940			 
9940 .. 00		prompt: db ">",0 
9942 .. 00		endprg: db "?",0 
9944			 
9944			 
9944			; handy next page prompt 
9944			next_page_prompt: 
9944 e5				push hl 
9945 d5				push de 
9946 f5				push af 
9947 c5				push bc 
9948			 
9948 3e 9f			ld a,display_row_4 + display_cols - 1 
994a 11 42 99		        ld de, endprg 
994d cd c3 8a			call str_at_display 
9950 cd d3 8a			call update_display 
9953 cd 27 e6			call cin_wait 
9956 c1				pop bc 
9957 f1				pop af 
9958 d1				pop de 
9959 e1				pop hl 
995a			 
995a			 
995a c9				ret 
995b			 
995b			 
995b			; forth parser 
995b			 
995b			; My forth kernel 
995b			include "forth_kernel.asm" 
995b			; 
995b			; kernel to the forth OS 
995b			 
995b			DS_TYPE_STR: equ 1     ; string type 
995b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
995b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
995b			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
995b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
995b			 
995b			FORTH_PARSEV1: equ 0 
995b			FORTH_PARSEV2: equ 0 
995b			FORTH_PARSEV3: equ 0 
995b			FORTH_PARSEV4: equ 0 
995b			FORTH_PARSEV5: equ 0 
995b			FORTH_PARSEV6: equ 1 
995b			 
995b			;if FORTH_PARSEV5 
995b			;	FORTH_END_BUFFER: equ 0 
995b			;else 
995b			FORTH_END_BUFFER: equ 127 
995b			;endif 
995b			 
995b			FORTH_TRUE: equ 1 
995b			FORTH_FALSE: equ 0 
995b			 
995b			if FORTH_PARSEV4 
995b			include "forth_stackops.asm" 
995b			endif 
995b			 
995b			if FORTH_PARSEV5 
995b			include "forth_stackopsv5.asm" 
995b			endif 
995b			 
995b			if FORTH_PARSEV6 
995b			include "forth_stackopsv5.asm" 
995b			 
995b			; Stack operations for v5 parser on wards 
995b			; * DATA stack 
995b			; * LOOP stack 
995b			; * RETURN stack 
995b			 
995b			 
995b			 
995b			FORTH_CHK_DSP_UNDER: macro 
995b				push hl 
995b				push de 
995b				ld hl,(cli_data_sp) 
995b				ld de, cli_data_stack 
995b				call cmp16 
995b				jp c, fault_dsp_under 
995b				pop de 
995b				pop hl 
995b				endm 
995b			 
995b			 
995b			FORTH_CHK_RSP_UNDER: macro 
995b				push hl 
995b				push de 
995b				ld hl,(cli_ret_sp) 
995b				ld de, cli_ret_stack 
995b				call cmp16 
995b				jp c, fault_rsp_under 
995b				pop de 
995b				pop hl 
995b				endm 
995b			 
995b			FORTH_CHK_LOOP_UNDER: macro 
995b				push hl 
995b				push de 
995b				ld hl,(cli_loop_sp) 
995b				ld de, cli_loop_stack 
995b				call cmp16 
995b				jp c, fault_loop_under 
995b				pop de 
995b				pop hl 
995b				endm 
995b			 
995b			FORTH_ERR_TOS_NOTSTR: macro 
995b				; TOSO might need more for checks when used 
995b				push af 
995b				ld a,(hl) 
995b				cp DS_TYPE_STR 
995b				jp nz, type_faultn   
995b				pop af 
995b				endm 
995b			 
995b			FORTH_ERR_TOS_NOTNUM: macro 
995b				push af 
995b				ld a,(hl) 
995b				cp DS_TYPE_INUM 
995b				jp nz, type_faultn   
995b				pop af 
995b				endm 
995b			 
995b			 
995b			; increase data stack pointer and save hl to it 
995b				 
995b			FORTH_DSP_NEXT: macro 
995b				call macro_forth_dsp_next 
995b				endm 
995b			 
995b			 
995b			macro_forth_dsp_next: 
995b				if DEBUG_FORTH_STACK_GUARD 
995b cd 90 e2				call check_stacks 
995e				endif 
995e e5				push hl 
995f d5				push de 
9960 eb				ex de,hl 
9961 2a e1 e9			ld hl,(cli_data_sp) 
9964 23				inc hl 
9965 23				inc hl 
9966			 
9966			; PARSEV5 
9966 23				inc hl 
9967 22 e1 e9			ld (cli_data_sp),hl 
996a 73				ld (hl), e 
996b 23				inc hl 
996c 72				ld (hl), d 
996d d1				pop de 
996e e1				pop hl 
996f				if DEBUG_FORTH_STACK_GUARD 
996f cd 90 e2				call check_stacks 
9972				endif 
9972 c9				ret 
9973			 
9973			 
9973			; increase ret stack pointer and save hl to it 
9973				 
9973			FORTH_RSP_NEXT: macro 
9973				call macro_forth_rsp_next 
9973				endm 
9973			 
9973			macro_forth_rsp_next: 
9973				if DEBUG_FORTH_STACK_GUARD 
9973 cd 90 e2				call check_stacks 
9976				endif 
9976 e5				push hl 
9977 d5				push de 
9978 eb				ex de,hl 
9979 2a e5 e9			ld hl,(cli_ret_sp) 
997c 23				inc hl 
997d 23				inc hl 
997e 22 e5 e9			ld (cli_ret_sp),hl 
9981 73				ld (hl), e 
9982 23				inc hl 
9983 72				ld (hl), d 
9984 d1				pop de 
9985 e1				pop hl 
9986				if DEBUG_FORTH_STACK_GUARD 
9986 cd 90 e2				call check_stacks 
9989				endif 
9989 c9				ret 
998a			 
998a			; get current ret stack pointer and save to hl  
998a				 
998a			FORTH_RSP_TOS: macro 
998a				call macro_forth_rsp_tos 
998a				endm 
998a			 
998a			macro_forth_rsp_tos: 
998a				;push de 
998a 2a e5 e9			ld hl,(cli_ret_sp) 
998d cd c5 99			call loadhlptrtohl 
9990				;ld e, (hl) 
9990				;inc hl 
9990				;ld d, (hl) 
9990				;ex de, hl 
9990					if DEBUG_FORTH_WORDS 
9990			;			DMARK "RST" 
9990						CALLMONITOR 
9990 cd 6b ee			call debug_vector  
9993				endm  
# End of macro CALLMONITOR
9993					endif 
9993				;pop de 
9993 c9				ret 
9994			 
9994			; pop ret stack pointer 
9994				 
9994			FORTH_RSP_POP: macro 
9994				call macro_forth_rsp_pop 
9994				endm 
9994			 
9994			 
9994			macro_forth_rsp_pop: 
9994				if DEBUG_FORTH_STACK_GUARD 
9994			;		DMARK "RPP" 
9994 cd 90 e2				call check_stacks 
9997					FORTH_CHK_RSP_UNDER 
9997 e5				push hl 
9998 d5				push de 
9999 2a e5 e9			ld hl,(cli_ret_sp) 
999c 11 9f e9			ld de, cli_ret_stack 
999f cd f9 8c			call cmp16 
99a2 da a7 e3			jp c, fault_rsp_under 
99a5 d1				pop de 
99a6 e1				pop hl 
99a7				endm 
# End of macro FORTH_CHK_RSP_UNDER
99a7				endif 
99a7 e5				push hl 
99a8 2a e5 e9			ld hl,(cli_ret_sp) 
99ab			 
99ab			 
99ab				if FORTH_ENABLE_FREE 
99ab			 
99ab					; get pointer 
99ab			 
99ab					push de 
99ab					push hl 
99ab			 
99ab					ld e, (hl) 
99ab					inc hl 
99ab					ld d, (hl) 
99ab			 
99ab					ex de, hl 
99ab					call free 
99ab			 
99ab					pop hl 
99ab					pop de 
99ab			 
99ab			 
99ab				endif 
99ab			 
99ab			 
99ab 2b				dec hl 
99ac 2b				dec hl 
99ad 22 e5 e9			ld (cli_ret_sp), hl 
99b0				; do stack underflow checks 
99b0 e1				pop hl 
99b1				if DEBUG_FORTH_STACK_GUARD 
99b1 cd 90 e2				call check_stacks 
99b4					FORTH_CHK_RSP_UNDER 
99b4 e5				push hl 
99b5 d5				push de 
99b6 2a e5 e9			ld hl,(cli_ret_sp) 
99b9 11 9f e9			ld de, cli_ret_stack 
99bc cd f9 8c			call cmp16 
99bf da a7 e3			jp c, fault_rsp_under 
99c2 d1				pop de 
99c3 e1				pop hl 
99c4				endm 
# End of macro FORTH_CHK_RSP_UNDER
99c4				endif 
99c4 c9				ret 
99c5			 
99c5			 
99c5			 
99c5			; routine to load word pointed to by hl into hl 
99c5			 
99c5			loadhlptrtohl: 
99c5			 
99c5 d5				push de 
99c6 5e				ld e, (hl) 
99c7 23				inc hl 
99c8 56				ld d, (hl) 
99c9 eb				ex de, hl 
99ca d1				pop de 
99cb			 
99cb c9				ret 
99cc			 
99cc			 
99cc			 
99cc			 
99cc			 
99cc			; push a number held in HL onto the data stack 
99cc			; entry point for pushing a value when already in hl used in function above 
99cc			 
99cc			forth_push_numhl: 
99cc			 
99cc e5				push hl    ; save value to push 
99cd			 
99cd			if DEBUG_FORTH_PUSH 
99cd				; see if disabled 
99cd			 
99cd			 
99cd f5				push af 
99ce 3a 6b ee			ld a,(debug_vector) 
99d1 fe c9			cp $c9   ; ret 
99d3			;	ld a, (os_view_disable) 
99d3			;	cp '*' 
99d3 28 33			jr z, .pskip2 
99d5 e5				push hl 
99d6 e5			push hl 
99d7 cd b1 8a			call clear_display 
99da e1			pop hl 
99db 7c				ld a,h 
99dc 21 b9 e5			ld hl, os_word_scratch 
99df cd d7 8e			call hexout 
99e2 e1				pop hl 
99e3 7d				ld a,l 
99e4 21 bb e5			ld hl, os_word_scratch+2 
99e7 cd d7 8e			call hexout 
99ea			 
99ea 21 bd e5			ld hl, os_word_scratch+4 
99ed			;	ld a,0 
99ed 36 00			ld (hl),0 
99ef 11 b9 e5			ld de,os_word_scratch 
99f2 3e 28				ld a, display_row_2 
99f4 cd c3 8a				call str_at_display 
99f7 11 f1 d2			ld de, .push_num 
99fa 3e 00			ld a, display_row_1 
99fc			 
99fc cd c3 8a				call str_at_display 
99ff			 
99ff			 
99ff cd d3 8a			call update_display 
9a02 cd f0 89			call delay1s 
9a05 cd f0 89			call delay1s 
9a08			.pskip2:  
9a08			 
9a08 f1				pop af 
9a09			endif	 
9a09			 
9a09			 
9a09				FORTH_DSP_NEXT 
9a09 cd 5b 99			call macro_forth_dsp_next 
9a0c				endm 
# End of macro FORTH_DSP_NEXT
9a0c			 
9a0c 2a e1 e9			ld hl, (cli_data_sp) 
9a0f			 
9a0f				; save item type 
9a0f			;	ld a,  DS_TYPE_INUM 
9a0f 36 02			ld (hl), DS_TYPE_INUM 
9a11 23				inc hl 
9a12			 
9a12				; get word off stack 
9a12 d1				pop de 
9a13				;ld a,e 
9a13 73				ld (hl), e 
9a14 23				inc hl 
9a15			;	ld a,d 
9a15 72				ld (hl), d 
9a16			 
9a16			if DEBUG_FORTH_PUSH 
9a16 2b				dec hl 
9a17 2b				dec hl 
9a18 2b				dec hl 
9a19						DMARK "PH5" 
9a19 f5				push af  
9a1a 3a 2e 9a			ld a, (.dmark)  
9a1d 32 5e ee			ld (debug_mark),a  
9a20 3a 2f 9a			ld a, (.dmark+1)  
9a23 32 5f ee			ld (debug_mark+1),a  
9a26 3a 30 9a			ld a, (.dmark+2)  
9a29 32 60 ee			ld (debug_mark+2),a  
9a2c 18 03			jr .pastdmark  
9a2e ..			.dmark: db "PH5"  
9a31 f1			.pastdmark: pop af  
9a32			endm  
# End of macro DMARK
9a32				CALLMONITOR 
9a32 cd 6b ee			call debug_vector  
9a35				endm  
# End of macro CALLMONITOR
9a35			endif	 
9a35			 
9a35 c9				ret 
9a36			 
9a36			 
9a36			; Push a string to stack pointed to by hl 
9a36			 
9a36			forth_push_str: 
9a36			 
9a36			if DEBUG_FORTH_PUSH 
9a36						DMARK "PSQ" 
9a36 f5				push af  
9a37 3a 4b 9a			ld a, (.dmark)  
9a3a 32 5e ee			ld (debug_mark),a  
9a3d 3a 4c 9a			ld a, (.dmark+1)  
9a40 32 5f ee			ld (debug_mark+1),a  
9a43 3a 4d 9a			ld a, (.dmark+2)  
9a46 32 60 ee			ld (debug_mark+2),a  
9a49 18 03			jr .pastdmark  
9a4b ..			.dmark: db "PSQ"  
9a4e f1			.pastdmark: pop af  
9a4f			endm  
# End of macro DMARK
9a4f				CALLMONITOR 
9a4f cd 6b ee			call debug_vector  
9a52				endm  
# End of macro CALLMONITOR
9a52			endif	 
9a52			 
9a52			 
9a52			    
9a52 e5				push hl 
9a53 e5				push hl 
9a54			 
9a54			;	ld a, 0   ; find end of string 
9a54 cd 33 90			call strlenz 
9a57			if DEBUG_FORTH_PUSH 
9a57						DMARK "PQ2" 
9a57 f5				push af  
9a58 3a 6c 9a			ld a, (.dmark)  
9a5b 32 5e ee			ld (debug_mark),a  
9a5e 3a 6d 9a			ld a, (.dmark+1)  
9a61 32 5f ee			ld (debug_mark+1),a  
9a64 3a 6e 9a			ld a, (.dmark+2)  
9a67 32 60 ee			ld (debug_mark+2),a  
9a6a 18 03			jr .pastdmark  
9a6c ..			.dmark: db "PQ2"  
9a6f f1			.pastdmark: pop af  
9a70			endm  
# End of macro DMARK
9a70				CALLMONITOR 
9a70 cd 6b ee			call debug_vector  
9a73				endm  
# End of macro CALLMONITOR
9a73			endif	 
9a73 eb				ex de, hl 
9a74 e1				pop hl   ; get ptr to start of string 
9a75			if DEBUG_FORTH_PUSH 
9a75						DMARK "PQ3" 
9a75 f5				push af  
9a76 3a 8a 9a			ld a, (.dmark)  
9a79 32 5e ee			ld (debug_mark),a  
9a7c 3a 8b 9a			ld a, (.dmark+1)  
9a7f 32 5f ee			ld (debug_mark+1),a  
9a82 3a 8c 9a			ld a, (.dmark+2)  
9a85 32 60 ee			ld (debug_mark+2),a  
9a88 18 03			jr .pastdmark  
9a8a ..			.dmark: db "PQ3"  
9a8d f1			.pastdmark: pop af  
9a8e			endm  
# End of macro DMARK
9a8e				CALLMONITOR 
9a8e cd 6b ee			call debug_vector  
9a91				endm  
# End of macro CALLMONITOR
9a91			endif	 
9a91 19				add hl,de 
9a92			if DEBUG_FORTH_PUSH 
9a92						DMARK "PQE" 
9a92 f5				push af  
9a93 3a a7 9a			ld a, (.dmark)  
9a96 32 5e ee			ld (debug_mark),a  
9a99 3a a8 9a			ld a, (.dmark+1)  
9a9c 32 5f ee			ld (debug_mark+1),a  
9a9f 3a a9 9a			ld a, (.dmark+2)  
9aa2 32 60 ee			ld (debug_mark+2),a  
9aa5 18 03			jr .pastdmark  
9aa7 ..			.dmark: db "PQE"  
9aaa f1			.pastdmark: pop af  
9aab			endm  
# End of macro DMARK
9aab				CALLMONITOR 
9aab cd 6b ee			call debug_vector  
9aae				endm  
# End of macro CALLMONITOR
9aae			endif	 
9aae			 
9aae 2b				dec hl    ; see if there is an optional trailing double quote 
9aaf 7e				ld a,(hl) 
9ab0 fe 22			cp '"' 
9ab2 20 02			jr nz, .strnoq 
9ab4			;	ld a, 0      ; get rid of double quote 
9ab4 36 00			ld (hl), 0 
9ab6 23			.strnoq: inc hl 
9ab7			 
9ab7			;	ld a, 0 
9ab7 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
9ab9			 
9ab9 13				inc de ; add one for the type string 
9aba 13				inc de ; add one for null term??? 
9abb			 
9abb				; tos is get string pointer again 
9abb				; de contains space to allocate 
9abb				 
9abb d5				push de 
9abc			 
9abc eb				ex de, hl 
9abd			 
9abd				;push af 
9abd			 
9abd			if DEBUG_FORTH_PUSH 
9abd						DMARK "PHm" 
9abd f5				push af  
9abe 3a d2 9a			ld a, (.dmark)  
9ac1 32 5e ee			ld (debug_mark),a  
9ac4 3a d3 9a			ld a, (.dmark+1)  
9ac7 32 5f ee			ld (debug_mark+1),a  
9aca 3a d4 9a			ld a, (.dmark+2)  
9acd 32 60 ee			ld (debug_mark+2),a  
9ad0 18 03			jr .pastdmark  
9ad2 ..			.dmark: db "PHm"  
9ad5 f1			.pastdmark: pop af  
9ad6			endm  
# End of macro DMARK
9ad6				CALLMONITOR 
9ad6 cd 6b ee			call debug_vector  
9ad9				endm  
# End of macro CALLMONITOR
9ad9			endif	 
9ad9 cd a7 90			call malloc	; on ret hl now contains allocated memory 
9adc				if DEBUG_FORTH_MALLOC_GUARD 
9adc cc 49 d3				call z,malloc_error 
9adf				endif 
9adf			 
9adf				 
9adf c1				pop bc    ; get length 
9ae0 d1				pop de   ;  get string start    
9ae1			 
9ae1				; hl has destination from malloc 
9ae1			 
9ae1 eb				ex de, hl    ; prep for ldir 
9ae2			 
9ae2 d5				push de   ; save malloc area for DSP later 
9ae3				;push hl   ; save malloc area for DSP later 
9ae3			 
9ae3			if DEBUG_FORTH_PUSH 
9ae3						DMARK "PHc" 
9ae3 f5				push af  
9ae4 3a f8 9a			ld a, (.dmark)  
9ae7 32 5e ee			ld (debug_mark),a  
9aea 3a f9 9a			ld a, (.dmark+1)  
9aed 32 5f ee			ld (debug_mark+1),a  
9af0 3a fa 9a			ld a, (.dmark+2)  
9af3 32 60 ee			ld (debug_mark+2),a  
9af6 18 03			jr .pastdmark  
9af8 ..			.dmark: db "PHc"  
9afb f1			.pastdmark: pop af  
9afc			endm  
# End of macro DMARK
9afc				CALLMONITOR 
9afc cd 6b ee			call debug_vector  
9aff				endm  
# End of macro CALLMONITOR
9aff			endif	 
9aff			 
9aff			 
9aff ed b0			ldir 
9b01			 
9b01			 
9b01				; push malloc to data stack     macro?????  
9b01			 
9b01				FORTH_DSP_NEXT 
9b01 cd 5b 99			call macro_forth_dsp_next 
9b04				endm 
# End of macro FORTH_DSP_NEXT
9b04			 
9b04				; save value and type 
9b04			 
9b04 2a e1 e9			ld hl, (cli_data_sp) 
9b07			 
9b07				; save item type 
9b07			;	ld a,  DS_TYPE_STR 
9b07 36 01			ld (hl), DS_TYPE_STR 
9b09 23				inc hl 
9b0a			 
9b0a				; get malloc word off stack 
9b0a d1				pop de 
9b0b 73				ld (hl), e 
9b0c 23				inc hl 
9b0d 72				ld (hl), d 
9b0e			 
9b0e			 
9b0e			 
9b0e			if DEBUG_FORTH_PUSH 
9b0e 2a e1 e9			ld hl, (cli_data_sp) 
9b11						DMARK "PHS" 
9b11 f5				push af  
9b12 3a 26 9b			ld a, (.dmark)  
9b15 32 5e ee			ld (debug_mark),a  
9b18 3a 27 9b			ld a, (.dmark+1)  
9b1b 32 5f ee			ld (debug_mark+1),a  
9b1e 3a 28 9b			ld a, (.dmark+2)  
9b21 32 60 ee			ld (debug_mark+2),a  
9b24 18 03			jr .pastdmark  
9b26 ..			.dmark: db "PHS"  
9b29 f1			.pastdmark: pop af  
9b2a			endm  
# End of macro DMARK
9b2a				CALLMONITOR 
9b2a cd 6b ee			call debug_vector  
9b2d				endm  
# End of macro CALLMONITOR
9b2d			;	ex de,hl 
9b2d			endif	 
9b2d				; in case of spaces, skip the ptr past the copied string 
9b2d				;pop af 
9b2d				;ld (cli_origptr),hl 
9b2d			 
9b2d c9				ret 
9b2e			 
9b2e			 
9b2e			 
9b2e			; TODO ascii push input onto stack given hl to start of input 
9b2e			 
9b2e			; identify type 
9b2e			; if starts with a " then a string 
9b2e			; otherwise it is a number 
9b2e			;  
9b2e			; if a string 
9b2e			;     scan for ending " to get length of string to malloc for + 1 
9b2e			;     malloc 
9b2e			;     put pointer to string on stack first byte flags as string 
9b2e			; 
9b2e			; else a number 
9b2e			;    look for number format identifier 
9b2e			;    $xx hex 
9b2e			;    %xxxxx bin 
9b2e			;    xxxxx decimal 
9b2e			;    convert number to 16bit word.  
9b2e			;    malloc word + 1 with flag to identiy as num 
9b2e			;    put pointer to number on stack 
9b2e			;   
9b2e			;  
9b2e			  
9b2e			forth_apush: 
9b2e				; kernel push 
9b2e			 
9b2e			if DEBUG_FORTH_PUSH 
9b2e						DMARK "PSH" 
9b2e f5				push af  
9b2f 3a 43 9b			ld a, (.dmark)  
9b32 32 5e ee			ld (debug_mark),a  
9b35 3a 44 9b			ld a, (.dmark+1)  
9b38 32 5f ee			ld (debug_mark+1),a  
9b3b 3a 45 9b			ld a, (.dmark+2)  
9b3e 32 60 ee			ld (debug_mark+2),a  
9b41 18 03			jr .pastdmark  
9b43 ..			.dmark: db "PSH"  
9b46 f1			.pastdmark: pop af  
9b47			endm  
# End of macro DMARK
9b47				CALLMONITOR 
9b47 cd 6b ee			call debug_vector  
9b4a				endm  
# End of macro CALLMONITOR
9b4a			endif	 
9b4a				; identify input type 
9b4a			 
9b4a 7e				ld a,(hl) 
9b4b			 
9b4b fe 23			cp '#' 
9b4d ca 85 9b			jp z, .fapdec 
9b50			 
9b50			 
9b50 fe 22			cp '"' 
9b52 28 0a			jr z, .fapstr 
9b54 fe 24			cp '$' 
9b56 ca 7d 9b			jp z, .faphex 
9b59 fe 25			cp '%' 
9b5b ca 66 9b			jp z, .fapbin 
9b5e			;	cp 'b' 
9b5e			;	jp z, .fabin 
9b5e				; else decimal 
9b5e			 
9b5e				; TODO do decimal conversion 
9b5e				; decimal is stored as a 16bit word 
9b5e			 
9b5e				; by default everything is a string if type is not detected 
9b5e			.fapstr: ; 
9b5e fe 22			cp '"' 
9b60 20 01			jr nz, .strnoqu 
9b62 23				inc hl 
9b63			.strnoqu: 
9b63 c3 36 9a			jp forth_push_str 
9b66			 
9b66			 
9b66			 
9b66			.fapbin:    ; push a binary string.  
9b66 11 00 00			ld de, 0   ; hold a 16bit value 
9b69			 
9b69 23			.fapbinshift:	inc hl  
9b6a 7e				ld a,(hl) 
9b6b			;	cp 0     ; done scanning  
9b6b b7				or a 
9b6c 28 0b			jr z, .fapbdone  	; got it in HL so push  
9b6e			 
9b6e				; left shift de 
9b6e eb				ex de, hl	 
9b6f 29				add hl, hl 
9b70			 
9b70				; is 1 
9b70 fe 31			cp '1' 
9b72 20 02			jr nz, .binzero 
9b74 cb 4d			bit 1, l 
9b76			.binzero: 
9b76 eb				ex de, hl	 ; save current de 
9b77 18 f0			jr .fapbinshift 
9b79			 
9b79			.fapbdone: 
9b79 eb				ex de, hl 
9b7a c3 cc 99			jp forth_push_numhl 
9b7d			 
9b7d			 
9b7d			.faphex:   ; hex is always stored as a 16bit word 
9b7d				; skip number prefix 
9b7d 23				inc hl 
9b7e				; turn ascii into number 
9b7e cd 8d 8f			call get_word_hl	; ret 16bit word in hl 
9b81			 
9b81 c3 cc 99			jp forth_push_numhl 
9b84			 
9b84			;	 nop 
9b84			 
9b84			.fabin:   ; TODO bin conversion 
9b84			 
9b84			 
9b84 c9				ret 
9b85			.fapdec:	 
9b85				; string to dec conversion 
9b85 23				inc hl 
9b86 eb				ex de, hl 
9b87 cd ca 8f			call string_to_uint16 
9b8a c3 cc 99			jp forth_push_numhl 
9b8d c9				ret 
9b8e				 
9b8e			;atoui_16: 
9b8e			 
9b8e			; get either a string ptr or a 16bit word from the data stack 
9b8e			 
9b8e			FORTH_DSP: macro 
9b8e				call macro_forth_dsp 
9b8e				endm 
9b8e			 
9b8e			macro_forth_dsp: 
9b8e				; data stack pointer points to current word on tos 
9b8e			 
9b8e 2a e1 e9			ld hl,(cli_data_sp) 
9b91			 
9b91				if DEBUG_FORTH_PUSH 
9b91						DMARK "DSP" 
9b91 f5				push af  
9b92 3a a6 9b			ld a, (.dmark)  
9b95 32 5e ee			ld (debug_mark),a  
9b98 3a a7 9b			ld a, (.dmark+1)  
9b9b 32 5f ee			ld (debug_mark+1),a  
9b9e 3a a8 9b			ld a, (.dmark+2)  
9ba1 32 60 ee			ld (debug_mark+2),a  
9ba4 18 03			jr .pastdmark  
9ba6 ..			.dmark: db "DSP"  
9ba9 f1			.pastdmark: pop af  
9baa			endm  
# End of macro DMARK
9baa			 
9baa cd 7c d3				call display_data_sp 
9bad				;call break_point_state 
9bad				;rst 030h 
9bad				CALLMONITOR 
9bad cd 6b ee			call debug_vector  
9bb0				endm  
# End of macro CALLMONITOR
9bb0				endif 
9bb0			 
9bb0 c9				ret 
9bb1			 
9bb1			; return hl to start of value on stack 
9bb1			 
9bb1			FORTH_DSP_VALUE: macro 
9bb1				call macro_forth_dsp_value 
9bb1				endm 
9bb1			 
9bb1			macro_forth_dsp_value: 
9bb1			 
9bb1				FORTH_DSP 
9bb1 cd 8e 9b			call macro_forth_dsp 
9bb4				endm 
# End of macro FORTH_DSP
9bb4			 
9bb4 d5				push de 
9bb5			 
9bb5 23				inc hl ; skip type 
9bb6			 
9bb6 5e				ld e, (hl) 
9bb7 23				inc hl 
9bb8 56				ld d, (hl) 
9bb9 eb				ex de,hl  
9bba			 
9bba d1				pop de 
9bbb			 
9bbb c9				ret 
9bbc			 
9bbc			; return hl to start of value to second item on stack 
9bbc			 
9bbc			FORTH_DSP_VALUEM1: macro 
9bbc				call macro_forth_dsp_value_m1 
9bbc				endm 
9bbc			 
9bbc			macro_forth_dsp_value_m1: 
9bbc			 
9bbc				FORTH_DSP 
9bbc cd 8e 9b			call macro_forth_dsp 
9bbf				endm 
# End of macro FORTH_DSP
9bbf			 
9bbf 2b				dec hl 
9bc0 2b				dec hl 
9bc1			;	dec hl 
9bc1			 
9bc1 d5				push de 
9bc2			 
9bc2 5e				ld e, (hl) 
9bc3 23				inc hl 
9bc4 56				ld d, (hl) 
9bc5 eb				ex de,hl  
9bc6			 
9bc6 d1				pop de 
9bc7			 
9bc7 c9				ret 
9bc8			 
9bc8				 
9bc8			 
9bc8			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9bc8			 
9bc8			FORTH_DSP_POP: macro 
9bc8				call macro_forth_dsp_pop 
9bc8				endm 
9bc8			 
9bc8			 
9bc8			; get the tos data type 
9bc8			 
9bc8			FORTH_DSP_TYPE:   macro 
9bc8			 
9bc8				;FORTH_DSP_VALUE 
9bc8				FORTH_DSP 
9bc8				 
9bc8				; hl points to value 
9bc8				; check type 
9bc8			 
9bc8				ld a,(hl) 
9bc8			 
9bc8				endm 
9bc8			 
9bc8			; load the tos value into hl 
9bc8			 
9bc8			 
9bc8			FORTH_DSP_VALUEHL:  macro 
9bc8				call macro_dsp_valuehl 
9bc8				endm 
9bc8			 
9bc8			 
9bc8			 
9bc8			macro_dsp_valuehl: 
9bc8				FORTH_DSP_VALUE 
9bc8 cd b1 9b			call macro_forth_dsp_value 
9bcb				endm 
# End of macro FORTH_DSP_VALUE
9bcb			 
9bcb				;FORTH_ERR_TOS_NOTNUM 
9bcb			 
9bcb				;inc hl   ; skip type id 
9bcb			 
9bcb			;	push de 
9bcb			; 
9bcb			;	ld e, (hl) 
9bcb			;	inc hl 
9bcb			;	ld d, (hl) 
9bcb			;	ex de,hl  
9bcb			 
9bcb			;	pop de 
9bcb			 
9bcb				if DEBUG_FORTH_PUSH 
9bcb						DMARK "DVL" 
9bcb f5				push af  
9bcc 3a e0 9b			ld a, (.dmark)  
9bcf 32 5e ee			ld (debug_mark),a  
9bd2 3a e1 9b			ld a, (.dmark+1)  
9bd5 32 5f ee			ld (debug_mark+1),a  
9bd8 3a e2 9b			ld a, (.dmark+2)  
9bdb 32 60 ee			ld (debug_mark+2),a  
9bde 18 03			jr .pastdmark  
9be0 ..			.dmark: db "DVL"  
9be3 f1			.pastdmark: pop af  
9be4			endm  
# End of macro DMARK
9be4				CALLMONITOR 
9be4 cd 6b ee			call debug_vector  
9be7				endm  
# End of macro CALLMONITOR
9be7				endif 
9be7 c9				ret 
9be8			 
9be8			forth_apushstrhl:      
9be8				; push of string requires use of cli_origptr 
9be8				; bodge use 
9be8			 
9be8				; get current cli_origptr, save, update with temp pointer  
9be8 ed 5b 31 ea		ld de, (cli_origptr) 
9bec 22 31 ea			ld (cli_origptr), hl 
9bef d5				push de 
9bf0 cd 2e 9b			call forth_apush 
9bf3 d1				pop de 
9bf4 ed 53 31 ea		ld (cli_origptr), de 
9bf8 c9			        ret	 
9bf9			 
9bf9			 
9bf9			; increase loop stack pointer and save hl to it 
9bf9				 
9bf9			FORTH_LOOP_NEXT: macro 
9bf9				call macro_forth_loop_next 
9bf9				;nop 
9bf9				endm 
9bf9			 
9bf9			macro_forth_loop_next: 
9bf9				if DEBUG_FORTH_STACK_GUARD 
9bf9 cd 90 e2				call check_stacks 
9bfc				endif 
9bfc e5				push hl 
9bfd d5				push de 
9bfe eb				ex de,hl 
9bff 2a e3 e9			ld hl,(cli_loop_sp) 
9c02 23				inc hl 
9c03 23				inc hl 
9c04					if DEBUG_FORTH_WORDS 
9c04						DMARK "LNX" 
9c04 f5				push af  
9c05 3a 19 9c			ld a, (.dmark)  
9c08 32 5e ee			ld (debug_mark),a  
9c0b 3a 1a 9c			ld a, (.dmark+1)  
9c0e 32 5f ee			ld (debug_mark+1),a  
9c11 3a 1b 9c			ld a, (.dmark+2)  
9c14 32 60 ee			ld (debug_mark+2),a  
9c17 18 03			jr .pastdmark  
9c19 ..			.dmark: db "LNX"  
9c1c f1			.pastdmark: pop af  
9c1d			endm  
# End of macro DMARK
9c1d						CALLMONITOR 
9c1d cd 6b ee			call debug_vector  
9c20				endm  
# End of macro CALLMONITOR
9c20					endif 
9c20 22 e3 e9			ld (cli_loop_sp),hl 
9c23 73				ld (hl), e 
9c24 23				inc hl 
9c25 72				ld (hl), d 
9c26 d1				pop de    ; been reversed so save a swap on restore 
9c27 e1				pop hl 
9c28				if DEBUG_FORTH_STACK_GUARD 
9c28 cd 90 e2				call check_stacks 
9c2b				endif 
9c2b c9				ret 
9c2c			 
9c2c			; get current ret stack pointer and save to hl  
9c2c				 
9c2c			FORTH_LOOP_TOS: macro 
9c2c				call macro_forth_loop_tos 
9c2c				endm 
9c2c			 
9c2c			macro_forth_loop_tos: 
9c2c d5				push de 
9c2d 2a e3 e9			ld hl,(cli_loop_sp) 
9c30 5e				ld e, (hl) 
9c31 23				inc hl 
9c32 56				ld d, (hl) 
9c33 eb				ex de, hl 
9c34 d1				pop de 
9c35 c9				ret 
9c36			 
9c36			; pop loop stack pointer 
9c36				 
9c36			FORTH_LOOP_POP: macro 
9c36				call macro_forth_loop_pop 
9c36				endm 
9c36			 
9c36			 
9c36			macro_forth_loop_pop: 
9c36				if DEBUG_FORTH_STACK_GUARD 
9c36					DMARK "LPP" 
9c36 f5				push af  
9c37 3a 4b 9c			ld a, (.dmark)  
9c3a 32 5e ee			ld (debug_mark),a  
9c3d 3a 4c 9c			ld a, (.dmark+1)  
9c40 32 5f ee			ld (debug_mark+1),a  
9c43 3a 4d 9c			ld a, (.dmark+2)  
9c46 32 60 ee			ld (debug_mark+2),a  
9c49 18 03			jr .pastdmark  
9c4b ..			.dmark: db "LPP"  
9c4e f1			.pastdmark: pop af  
9c4f			endm  
# End of macro DMARK
9c4f cd 90 e2				call check_stacks 
9c52					FORTH_CHK_LOOP_UNDER 
9c52 e5				push hl 
9c53 d5				push de 
9c54 2a e3 e9			ld hl,(cli_loop_sp) 
9c57 11 1d e9			ld de, cli_loop_stack 
9c5a cd f9 8c			call cmp16 
9c5d da ad e3			jp c, fault_loop_under 
9c60 d1				pop de 
9c61 e1				pop hl 
9c62				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c62				endif 
9c62 e5				push hl 
9c63 2a e3 e9			ld hl,(cli_loop_sp) 
9c66 2b				dec hl 
9c67 2b				dec hl 
9c68 22 e3 e9			ld (cli_loop_sp), hl 
9c6b				; TODO do stack underflow checks 
9c6b e1				pop hl 
9c6c				if DEBUG_FORTH_STACK_GUARD 
9c6c cd 90 e2				call check_stacks 
9c6f					FORTH_CHK_LOOP_UNDER 
9c6f e5				push hl 
9c70 d5				push de 
9c71 2a e3 e9			ld hl,(cli_loop_sp) 
9c74 11 1d e9			ld de, cli_loop_stack 
9c77 cd f9 8c			call cmp16 
9c7a da ad e3			jp c, fault_loop_under 
9c7d d1				pop de 
9c7e e1				pop hl 
9c7f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c7f				endif 
9c7f c9				ret 
9c80			 
9c80			macro_forth_dsp_pop: 
9c80			 
9c80 e5				push hl 
9c81			 
9c81				; release malloc data 
9c81			 
9c81				if DEBUG_FORTH_STACK_GUARD 
9c81 cd 90 e2				call check_stacks 
9c84					FORTH_CHK_DSP_UNDER 
9c84 e5				push hl 
9c85 d5				push de 
9c86 2a e1 e9			ld hl,(cli_data_sp) 
9c89 11 1b e8			ld de, cli_data_stack 
9c8c cd f9 8c			call cmp16 
9c8f da a1 e3			jp c, fault_dsp_under 
9c92 d1				pop de 
9c93 e1				pop hl 
9c94				endm 
# End of macro FORTH_CHK_DSP_UNDER
9c94				endif 
9c94				;ld hl,(cli_data_sp) 
9c94			if DEBUG_FORTH_DOT 
9c94				DMARK "DPP" 
9c94 f5				push af  
9c95 3a a9 9c			ld a, (.dmark)  
9c98 32 5e ee			ld (debug_mark),a  
9c9b 3a aa 9c			ld a, (.dmark+1)  
9c9e 32 5f ee			ld (debug_mark+1),a  
9ca1 3a ab 9c			ld a, (.dmark+2)  
9ca4 32 60 ee			ld (debug_mark+2),a  
9ca7 18 03			jr .pastdmark  
9ca9 ..			.dmark: db "DPP"  
9cac f1			.pastdmark: pop af  
9cad			endm  
# End of macro DMARK
9cad				CALLMONITOR 
9cad cd 6b ee			call debug_vector  
9cb0				endm  
# End of macro CALLMONITOR
9cb0			endif	 
9cb0			 
9cb0			 
9cb0			if FORTH_ENABLE_DSPPOPFREE 
9cb0			 
9cb0				FORTH_DSP 
9cb0 cd 8e 9b			call macro_forth_dsp 
9cb3				endm 
# End of macro FORTH_DSP
9cb3			 
9cb3 7e				ld a, (hl) 
9cb4 fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
9cb6 20 22			jr nz, .skippopfree 
9cb8			 
9cb8				FORTH_DSP_VALUEHL 
9cb8 cd c8 9b			call macro_dsp_valuehl 
9cbb				endm 
# End of macro FORTH_DSP_VALUEHL
9cbb			;	nop 
9cbb			if DEBUG_FORTH_DOT 
9cbb				DMARK "DPf" 
9cbb f5				push af  
9cbc 3a d0 9c			ld a, (.dmark)  
9cbf 32 5e ee			ld (debug_mark),a  
9cc2 3a d1 9c			ld a, (.dmark+1)  
9cc5 32 5f ee			ld (debug_mark+1),a  
9cc8 3a d2 9c			ld a, (.dmark+2)  
9ccb 32 60 ee			ld (debug_mark+2),a  
9cce 18 03			jr .pastdmark  
9cd0 ..			.dmark: db "DPf"  
9cd3 f1			.pastdmark: pop af  
9cd4			endm  
# End of macro DMARK
9cd4				CALLMONITOR 
9cd4 cd 6b ee			call debug_vector  
9cd7				endm  
# End of macro CALLMONITOR
9cd7			endif	 
9cd7 cd 71 91			call free 
9cda			.skippopfree: 
9cda				 
9cda			 
9cda			endif 
9cda			 
9cda			if DEBUG_FORTH_DOT_KEY 
9cda				DMARK "DP2" 
9cda				CALLMONITOR 
9cda			endif	 
9cda			 
9cda				; move pointer down 
9cda			 
9cda 2a e1 e9			ld hl,(cli_data_sp) 
9cdd 2b				dec hl 
9cde 2b				dec hl 
9cdf			; PARSEV5 
9cdf 2b				dec hl 
9ce0 22 e1 e9			ld (cli_data_sp), hl 
9ce3			 
9ce3				if DEBUG_FORTH_STACK_GUARD 
9ce3 cd 90 e2				call check_stacks 
9ce6					FORTH_CHK_DSP_UNDER 
9ce6 e5				push hl 
9ce7 d5				push de 
9ce8 2a e1 e9			ld hl,(cli_data_sp) 
9ceb 11 1b e8			ld de, cli_data_stack 
9cee cd f9 8c			call cmp16 
9cf1 da a1 e3			jp c, fault_dsp_under 
9cf4 d1				pop de 
9cf5 e1				pop hl 
9cf6				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cf6				endif 
9cf6			 
9cf6 e1				pop hl 
9cf7			 
9cf7 c9				ret 
9cf8			 
9cf8			getwordathl: 
9cf8				; hl points to an address 
9cf8				; load hl with the word at that address 
9cf8			 
9cf8 d5				push de 
9cf9			 
9cf9 5e				ld e, (hl) 
9cfa 23				inc hl 
9cfb 56				ld d, (hl) 
9cfc eb				ex de, hl 
9cfd			 
9cfd d1				pop de 
9cfe c9				ret 
9cff			 
9cff			 
9cff			; functions to manuplite stack pointers 
9cff			 
9cff			; generate fragment to set hl to be pointer to a stack item 
9cff			 
9cff			FORTH_DSP_PTR: macro  x 
9cff				ld hl,(cli_data_sp) 
9cff				ld de, x * 3 
9cff				sbc hl, de 
9cff				endm 
9cff			 
9cff			 
9cff			 
9cff			; copy point in hl to stack tmp storage slots 1-4 
9cff			hltostack1: 
9cff 11 b1 e2			ld de, os_stack_1  
9d02 c3 2d 9d			jp hltostackmv 
9d05			 
9d05			hltostack2:  
9d05 11 ae e2			ld de, os_stack_2 
9d08 c3 2d 9d			jp hltostackmv 
9d0b			 
9d0b			hltostack3:  
9d0b 11 ab e2			ld de, os_stack_3 
9d0e c3 2d 9d			jp hltostackmv 
9d11			 
9d11			hltostack4:  
9d11 11 a8 e2			ld de, os_stack_4  
9d14 c3 2d 9d			jp hltostackmv 
9d17			 
9d17			; copy to point in hl from stack tmp storage slots 1-4 
9d17			hlfromstack1: 
9d17 11 b1 e2			ld de, os_stack_1 
9d1a c3 2c 9d			jp hlfromsttackmv 
9d1d			 
9d1d			hlfromstack2:  
9d1d 11 ae e2			ld de, os_stack_2 
9d20 c3 2c 9d			jp hlfromsttackmv 
9d23			 
9d23			hlfromstack3:  
9d23 11 ab e2			ld de, os_stack_3 
9d26 c3 2c 9d			jp hlfromsttackmv 
9d29			 
9d29			hlfromstack4:  
9d29 11 a8 e2			ld de, os_stack_4 
9d2c			 
9d2c			hlfromsttackmv: 
9d2c eb				ex de, hl 
9d2d			 
9d2d			hltostackmv: 
9d2d			 
9d2d				; do stack move 
9d2d c5				push bc 
9d2e 01 03 00			ld bc, 3 
9d31 ed b0			ldir  
9d33 c1				pop bc	 
9d34 c9				ret 
9d35			 
9d35			; eof 
9d35			 
# End of file forth_stackopsv5.asm
9d35			endif 
9d35			loadwordinhl:	 
9d35			 
9d35 d5				push de 
9d36			 
9d36 5e				ld e, (hl) 
9d37 23				inc hl 
9d38 56				ld d, (hl) 
9d39 eb				ex de,hl  
9d3a			 
9d3a d1				pop de 
9d3b			 
9d3b c9				ret 
9d3c			 
9d3c			user_word_eol:  
9d3c				; hl contains the pointer to where to create a linked list item from the end 
9d3c				; of the user dict to continue on at the system word dict 
9d3c				 
9d3c				; poke the stub of the word list linked list to repoint to rom words 
9d3c			 
9d3c				; stub format 
9d3c				; db   word id 
9d3c				; dw    link to next word 
9d3c			        ; db char length of token 
9d3c				; db string + 0 term 
9d3c				; db exec code....  
9d3c			 
9d3c			;	ld a, WORD_SYS_ROOT     ; root word 
9d3c 36 00			ld (hl), WORD_SYS_ROOT		; word id 
9d3e 23				inc hl 
9d3f			 
9d3f 11 e8 9e			ld de, sysdict 
9d42 73				ld (hl), e		; next word link ie system dict 
9d43 23				inc hl 
9d44 72				ld (hl), d		; next word link ie system dict 
9d45 23				inc hl	 
9d46			 
9d46			;	ld (hl), sysdict		; next word link ie system dict 
9d46			;	inc hl 
9d46			;	inc hl 
9d46			 
9d46			;	inc hl 
9d46			;	inc hl 
9d46			 
9d46			;	ld a, 2			; word length is 0 
9d46 36 02			ld (hl), 2 
9d48 23				inc hl 
9d49			 
9d49			;	ld a, '~'			; word length is 0 
9d49 36 7e			ld (hl), '~' 
9d4b 23				inc hl 
9d4c			;	ld a, 0			; save empty word 
9d4c 36 00			ld (hl), 0 
9d4e			 
9d4e c9				ret 
9d4f			 
9d4f				 
9d4f			 
9d4f			forthexec_cleanup: 
9d4f				FORTH_RSP_POP 
9d4f cd 94 99			call macro_forth_rsp_pop 
9d52				endm 
# End of macro FORTH_RSP_POP
9d52 c9				ret 
9d53			 
9d53			forth_call_hl: 
9d53				; taking hl 
9d53 e5				push hl 
9d54 c9				ret 
9d55			 
9d55			; this is called to reset Forth system but keep existing uwords etc 
9d55			 
9d55			forth_warmstart: 
9d55				; setup stack over/under flow checks 
9d55				if DEBUG_FORTH_STACK_GUARD 
9d55 cd 76 e2				call chk_stk_init 
9d58				endif 
9d58			 
9d58				; init stack pointers  - * these stacks go upwards *  
9d58 21 9f e9			ld hl, cli_ret_stack 
9d5b 22 e5 e9			ld (cli_ret_sp), hl	 
9d5e				; set bottom of stack 
9d5e			;	ld a,0 
9d5e 36 00			ld (hl),0 
9d60 23				inc hl 
9d61 36 00			ld (hl),0 
9d63			 
9d63 21 1b e8			ld hl, cli_data_stack 
9d66 22 e1 e9			ld (cli_data_sp), hl	 
9d69				; set bottom of stack 
9d69			;	ld a,0 
9d69 36 00			ld (hl),0 
9d6b 23				inc hl 
9d6c 36 00			ld (hl),0 
9d6e			 
9d6e 21 1d e9			ld hl, cli_loop_stack 
9d71 22 e3 e9			ld (cli_loop_sp), hl	 
9d74				; set bottom of stack 
9d74			;	ld a,0 
9d74 36 00			ld (hl),0 
9d76 23				inc hl 
9d77 36 00			ld (hl),0 
9d79			 
9d79				; init extent of current open file 
9d79			 
9d79 3e 00			ld a, 0 
9d7b 32 5d ea			ld (store_openext), a 
9d7e			 
9d7e c9				ret 
9d7f			 
9d7f			 
9d7f			 
9d7f			; Cold Start - this is called to setup the whole Forth system 
9d7f			 
9d7f			forth_init: 
9d7f			 
9d7f				; setup stack over/under flow checks 
9d7f			 
9d7f			;	if DEBUG_FORTH_STACK_GUARD 
9d7f			;		call chk_stk_init 
9d7f			;	endif 
9d7f			 
9d7f				; enable auto display updates (slow.....) 
9d7f			 
9d7f 3e 01			ld a, 1 
9d81 32 2f ea			ld (cli_autodisplay), a 
9d84			 
9d84				; if storage is in use disable long reads for now 
9d84 3e 00			ld a, 0 
9d86 32 68 ea			ld (store_longread), a 
9d89			 
9d89			 
9d89				; show start up screen 
9d89			 
9d89 cd b1 8a			call clear_display 
9d8c			 
9d8c 3e 00			ld a,0 
9d8e 32 51 ea			ld (f_cursor_ptr), a 
9d91			 
9d91				; set start of word list in start of ram - for use when creating user words 
9d91			 
9d91 21 3c e6			ld hl, baseram 
9d94 22 b1 e5			ld (os_last_new_uword), hl 
9d97 cd 3c 9d			call user_word_eol 
9d9a				 
9d9a			;		call display_data_sp 
9d9a			;		call next_page_prompt 
9d9a			 
9d9a			 
9d9a			 
9d9a			 
9d9a c9				ret 
9d9b			 
9d9b .. 00		.bootforth: db " Forth Kernel Init ",0 
9daf			 
9daf			; TODO push to stack 
9daf			 
9daf			;  
9daf			 
9daf			if FORTH_PARSEV2 
9daf			 
9daf			 
9daf				include "forth_parserv2.asm" 
9daf			 
9daf			endif 
9daf			 
9daf			 
9daf			; parse cli version 1 
9daf			 
9daf			if FORTH_PARSEV1 
9daf			 
9daf			 
9daf			 
9daf			      include "forth_parserv1.asm" 
9daf			endif 
9daf				 
9daf			if FORTH_PARSEV3 
9daf			      include "forth_parserv3.asm" 
9daf				include "forth_wordsv3.asm" 
9daf			endif 
9daf			 
9daf			if FORTH_PARSEV4 
9daf			      include "forth_parserv4.asm" 
9daf				include "forth_wordsv4.asm" 
9daf			endif 
9daf			 
9daf			if FORTH_PARSEV5 
9daf			      include "forth_parserv5.asm" 
9daf				include "forth_wordsv4.asm" 
9daf			endif 
9daf			 
9daf			if FORTH_PARSEV6 
9daf			      include "forth_parserv6.asm" 
9daf			 
9daf			 
9daf			; A better parser without using malloc and string copies all over the place.  
9daf			; Exec in situ should be faster 
9daf			 
9daf			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9daf			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9daf			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9daf			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9daf			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9daf			WORD_SYS_END: equ 0   ; Opcode for all user words 
9daf			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9daf			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9daf			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9daf			 
9daf			; Core word preamble macro 
9daf			 
9daf			CWHEAD:   macro nxtword opcode lit len opflags 
9daf				db WORD_SYS_CORE+opcode             
9daf				; internal op code number 
9daf				dw nxtword            
9daf				; link to next dict word block 
9daf				db len + 1 
9daf				; literal length of dict word inc zero term 
9daf				db lit,0              
9daf				; literal dict word 
9daf			        ; TODO db opflags        
9daf				endm 
9daf			 
9daf			 
9daf			NEXTW: macro  
9daf				call parse_vector 
9daf				jp macro_next 
9daf				endm 
9daf			 
9daf			macro_next: 
9daf			if DEBUG_FORTH_PARSE_EXEC 
9daf				DMARK "NXT" 
9daf				CALLMONITOR 
9daf			endif	 
9daf			;	inc hl  ; skip token null term  
9daf ed 4b 33 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9db3 ed 5b 31 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9db7 2a b5 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9dba			if DEBUG_FORTH_PARSE_EXEC 
9dba				DMARK "}AA" 
9dba				CALLMONITOR 
9dba			endif	 
9dba c3 9f 9e			jp execnext 
9dbd				;jp exec1 
9dbd			       
9dbd			 
9dbd			 
9dbd			; Another go at the parser to compile  
9dbd			 
9dbd			 
9dbd			; TODO rework parser to change all of the string words to byte tokens 
9dbd			; TODO do a search for  
9dbd			 
9dbd			; TODO first run normal parser to zero term sections 
9dbd			; TODO for each word do a token look up to get the op code 
9dbd			; TODO need some means to flag to the exec that this is a byte code form    
9dbd			 
9dbd			 
9dbd			forthcompile: 
9dbd			 
9dbd			; 
9dbd			; line parse: 
9dbd			;       parse raw input buffer 
9dbd			;       tokenise the words 
9dbd			;       malloc new copy (for looping etc) 
9dbd			;       copy to malloc + current pc in line to start of string and add line term 
9dbd			;       save on new rsp 
9dbd			; 
9dbd			 
9dbd			; hl to point to the line to tokenise 
9dbd			 
9dbd			;	push hl 
9dbd 22 b5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9dc0			 
9dc0			;	ld a,0		; string term on input 
9dc0			;	call strlent 
9dc0			 
9dc0			;	ld (os_tok_len), hl	 ; save string length 
9dc0			 
9dc0			;if DEBUG_FORTH_TOK 
9dc0			;	ex de,hl		 
9dc0			;endif 
9dc0			 
9dc0			;	pop hl 		; get back string pointer 
9dc0			 
9dc0			if DEBUG_FORTH_TOK 
9dc0						DMARK "TOc" 
9dc0				CALLMONITOR 
9dc0			endif 
9dc0 7e			.cptoken2:    ld a,(hl) 
9dc1 23				inc hl 
9dc2 fe 7f			cp FORTH_END_BUFFER 
9dc4 28 26			jr z, .cptokendone2 
9dc6			;	cp 0 
9dc6 b7				or a 
9dc7 28 23			jr z, .cptokendone2 
9dc9 fe 22			cp '"' 
9dcb 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9dcd fe 20			cp ' ' 
9dcf 20 ef			jr nz,  .cptoken2 
9dd1			 
9dd1			; TODO consume comments held between ( and ) 
9dd1			 
9dd1				; we have a space so change to zero term for dict match later 
9dd1 2b				dec hl 
9dd2			;	ld a,0 
9dd2 36 00			ld (hl), 0 
9dd4 23				inc hl 
9dd5 18 e9			jr .cptoken2 
9dd7				 
9dd7			 
9dd7			.cptokenstr2: 
9dd7				; skip all white space until either eol (because forgot to term) or end double quote 
9dd7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9dd7				;inc hl ; skip current double quote 
9dd7 7e				ld a,(hl) 
9dd8 23				inc hl 
9dd9 fe 22			cp '"' 
9ddb 28 e3			jr z, .cptoken2 
9ddd fe 7f			cp FORTH_END_BUFFER 
9ddf 28 0b			jr z, .cptokendone2 
9de1			;	cp 0 
9de1 b7				or a 
9de2 28 08			jr z, .cptokendone2 
9de4 fe 20			cp ' ' 
9de6 28 02			jr z, .cptmp2 
9de8 18 ed			jr .cptokenstr2 
9dea			 
9dea			.cptmp2:	; we have a space so change to zero term for dict match later 
9dea				;dec hl 
9dea				;ld a,"-"	; TODO remove this when working 
9dea				;ld (hl), a 
9dea				;inc hl 
9dea 18 eb			jr .cptokenstr2 
9dec			 
9dec			.cptokendone2: 
9dec				;inc hl 
9dec			;	ld a, FORTH_END_BUFFER 
9dec 36 7f			ld (hl),FORTH_END_BUFFER 
9dee			;	inc hl 
9dee			;	ld a, '!' 
9dee			;	ld (hl),a 
9dee			 
9dee 2a b5 e5			ld hl,(os_tok_ptr) 
9df1			         
9df1			if DEBUG_FORTH_TOK 
9df1						DMARK "Tc1" 
9df1				CALLMONITOR 
9df1			endif 
9df1			 
9df1				; push exec string to top of return stack 
9df1				FORTH_RSP_NEXT 
9df1 cd 73 99			call macro_forth_rsp_next 
9df4				endm 
# End of macro FORTH_RSP_NEXT
9df4 c9				ret 
9df5			 
9df5			; Another go at the parser need to simplify the process 
9df5			 
9df5			forthparse: 
9df5			 
9df5			; 
9df5			; line parse: 
9df5			;       parse raw input buffer 
9df5			;       tokenise the words 
9df5			;       malloc new copy (for looping etc) 
9df5			;       copy to malloc + current pc in line to start of string and add line term 
9df5			;       save on new rsp 
9df5			; 
9df5			 
9df5			; hl to point to the line to tokenise 
9df5			 
9df5			;	push hl 
9df5 22 b5 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9df8			 
9df8			;	ld a,0		; string term on input 
9df8			;	call strlent 
9df8			 
9df8			;	ld (os_tok_len), hl	 ; save string length 
9df8			 
9df8			;if DEBUG_FORTH_TOK 
9df8			;	ex de,hl		 
9df8			;endif 
9df8			 
9df8			;	pop hl 		; get back string pointer 
9df8			 
9df8			if DEBUG_FORTH_TOK 
9df8						DMARK "TOK" 
9df8				CALLMONITOR 
9df8			endif 
9df8 7e			.ptoken2:    ld a,(hl) 
9df9 23				inc hl 
9dfa fe 7f			cp FORTH_END_BUFFER 
9dfc 28 26			jr z, .ptokendone2 
9dfe			;	cp 0 
9dfe b7				or a 
9dff 28 23			jr z, .ptokendone2 
9e01 fe 22			cp '"' 
9e03 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e05 fe 20			cp ' ' 
9e07 20 ef			jr nz,  .ptoken2 
9e09			 
9e09			; TODO consume comments held between ( and ) 
9e09			 
9e09				; we have a space so change to zero term for dict match later 
9e09 2b				dec hl 
9e0a			;	ld a,0 
9e0a 36 00			ld (hl), 0 
9e0c 23				inc hl 
9e0d 18 e9			jr .ptoken2 
9e0f				 
9e0f			 
9e0f			.ptokenstr2: 
9e0f				; skip all white space until either eol (because forgot to term) or end double quote 
9e0f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e0f				;inc hl ; skip current double quote 
9e0f 7e				ld a,(hl) 
9e10 23				inc hl 
9e11 fe 22			cp '"' 
9e13 28 e3			jr z, .ptoken2 
9e15 fe 7f			cp FORTH_END_BUFFER 
9e17 28 0b			jr z, .ptokendone2 
9e19			;	cp 0 
9e19 b7				or a 
9e1a 28 08			jr z, .ptokendone2 
9e1c fe 20			cp ' ' 
9e1e 28 02			jr z, .ptmp2 
9e20 18 ed			jr .ptokenstr2 
9e22			 
9e22			.ptmp2:	; we have a space so change to zero term for dict match later 
9e22				;dec hl 
9e22				;ld a,"-"	; TODO remove this when working 
9e22				;ld (hl), a 
9e22				;inc hl 
9e22 18 eb			jr .ptokenstr2 
9e24			 
9e24			.ptokendone2: 
9e24				;inc hl 
9e24			;	ld a, FORTH_END_BUFFER 
9e24 36 7f			ld (hl),FORTH_END_BUFFER 
9e26			;	inc hl 
9e26			;	ld a, '!' 
9e26			;	ld (hl),a 
9e26			 
9e26 2a b5 e5			ld hl,(os_tok_ptr) 
9e29			         
9e29			if DEBUG_FORTH_TOK 
9e29						DMARK "TK1" 
9e29				CALLMONITOR 
9e29			endif 
9e29			 
9e29				; push exec string to top of return stack 
9e29				FORTH_RSP_NEXT 
9e29 cd 73 99			call macro_forth_rsp_next 
9e2c				endm 
# End of macro FORTH_RSP_NEXT
9e2c c9				ret 
9e2d			 
9e2d			; 
9e2d			;	; malloc size + buffer pointer + if is loop flag 
9e2d			;	ld hl,(os_tok_len) 		 ; get string length 
9e2d			; 
9e2d			;	ld a,l 
9e2d			; 
9e2d			;	cp 0			; we dont want to use a null string 
9e2d			;	ret z 
9e2d			; 
9e2d			;;	add 3    ; prefix malloc with buffer for current word ptr 
9e2d			; 
9e2d			;	add 5     ; TODO when certain not over writing memory remove 
9e2d			; 
9e2d			;		 
9e2d			; 
9e2d			;if DEBUG_FORTH_TOK 
9e2d			;			DMARK "TKE" 
9e2d			;	CALLMONITOR 
9e2d			;endif 
9e2d			; 
9e2d			;	ld l,a 
9e2d			;	ld h,0 
9e2d			;;	push hl   ; save required space for the copy later 
9e2d			;	call malloc 
9e2d			;if DEBUG_FORTH_TOK 
9e2d			;			DMARK "TKM" 
9e2d			;	CALLMONITOR 
9e2d			;endif 
9e2d			;	if DEBUG_FORTH_MALLOC_GUARD 
9e2d			;		push af 
9e2d			;		call ishlzero 
9e2d			;;		ld a, l 
9e2d			;;		add h 
9e2d			;;		cp 0 
9e2d			;		pop af 
9e2d			;		 
9e2d			;		call z,malloc_error 
9e2d			;	endif 
9e2d			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9e2d			; 
9e2d			; 
9e2d			;if DEBUG_FORTH_TOK 
9e2d			;			DMARK "TKR" 
9e2d			;	CALLMONITOR 
9e2d			;endif 
9e2d			; 
9e2d			;	FORTH_RSP_NEXT 
9e2d			; 
9e2d			;	;inc hl	 ; go past current buffer pointer 
9e2d			;	;inc hl 
9e2d			;	;inc hl   ; and past if loop flag 
9e2d			;		; TODO Need to set flag  
9e2d			; 
9e2d			;	 
9e2d			;	 
9e2d			;	ex de,hl	; malloc is dest 
9e2d			;	ld hl, (os_tok_len) 
9e2d			;;	pop bc 
9e2d			;	ld c, l                
9e2d			;	ld b,0 
9e2d			;	ld hl, (os_tok_ptr) 
9e2d			; 
9e2d			;if DEBUG_FORTH_TOK 
9e2d			;			DMARK "TKT" 
9e2d			;	CALLMONITOR 
9e2d			;endif 
9e2d			; 
9e2d			;	; do str cpy 
9e2d			; 
9e2d			;	ldir      ; copy byte in hl to de 
9e2d			; 
9e2d			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9e2d			; 
9e2d			;if DEBUG_FORTH_TOK 
9e2d			; 
9e2d			;			DMARK "TKY" 
9e2d			;	CALLMONITOR 
9e2d			;endif 
9e2d			;	;ld a,0 
9e2d			;	;ld a,FORTH_END_BUFFER 
9e2d			;	ex de, hl 
9e2d			;	;dec hl			 ; go back over the space delim at the end of word 
9e2d			;	;ld (hl),a 
9e2d			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9e2d			;	ld a,FORTH_END_BUFFER 
9e2d			;	ld (hl),a 
9e2d			;	inc hl 
9e2d			;	ld a,FORTH_END_BUFFER 
9e2d			;	ld (hl),a 
9e2d			; 
9e2d			;	; init the malloc area data 
9e2d			;	; set pc for in current area 
9e2d			;	;ld hl, (os_tok_malloc) 
9e2d			;	;inc hl 
9e2d			;	;inc hl 
9e2d			;	;inc hl 
9e2d			;	;ex de,hl 
9e2d			;	;ld hl, (os_tok_malloc) 
9e2d			;	;ld (hl),e 
9e2d			;	;inc hl 
9e2d			;	;ld (hl),d 
9e2d			; 
9e2d			; 
9e2d			;	ld hl,(os_tok_malloc) 
9e2d			;if DEBUG_FORTH_PARSE_KEY 
9e2d			;			DMARK "TKU" 
9e2d			;	CALLMONITOR 
9e2d			;endif 
9e2d			; 
9e2d			;	ret 
9e2d			 
9e2d			forthexec: 
9e2d			 
9e2d			; line exec: 
9e2d			; forth parser 
9e2d			 
9e2d			; 
9e2d			;       get current exec line on rsp 
9e2d			 
9e2d				FORTH_RSP_TOS 
9e2d cd 8a 99			call macro_forth_rsp_tos 
9e30				endm 
# End of macro FORTH_RSP_TOS
9e30			 
9e30			;       restore current pc - hl points to malloc of data 
9e30			 
9e30				;ld e, (hl) 
9e30				;inc hl 
9e30				;ld d, (hl) 
9e30				;ex de,hl 
9e30			 
9e30			 
9e30			exec1: 
9e30 22 b5 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
9e33			 
9e33				; copy our PC to working vars  
9e33 22 33 ea			ld (cli_ptr), hl                    ; here 
9e36 22 31 ea			ld (cli_origptr), hl                ; here 
9e39			 
9e39 7e				ld a,(hl)                           ; here make hl be the ram ptr 
9e3a fe 7f			cp FORTH_END_BUFFER 
9e3c c8				ret z 
9e3d			 
9e3d				; skip any nulls 
9e3d			 
9e3d			;	cp 0 
9e3d b7				or a 
9e3e 20 03			jr nz, .execword 
9e40 23				inc hl 
9e41 18 ed			jr exec1 
9e43			 
9e43			 
9e43			.execword: 
9e43			 
9e43			 
9e43			 
9e43			if DEBUG_FORTH_PARSE_EXEC 
9e43						DMARK "KYQ" 
9e43				CALLMONITOR 
9e43			endif 
9e43			;       while at start of word: 
9e43			; get start of dict (in user area first) 
9e43			 
9e43 21 3c e6		ld hl, baseram 
9e46			;ld hl, sysdict 
9e46 22 35 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
9e49			;           match word at pc 
9e49			;           exec word 
9e49			;           or push to dsp 
9e49			;           forward to next token 
9e49			;           if line term pop rsp and exit 
9e49			;        
9e49			 
9e49			if DEBUG_FORTH_PARSE_EXEC 
9e49						DMARK "KYq" 
9e49				CALLMONITOR 
9e49			endif 
9e49			 
9e49			; 
9e49			; word comp 
9e49			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9e49			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9e49			;    move to start of word  
9e49			;    compare word to cli_token 
9e49			 
9e49			.execpnword:	; HL at start of a word in the dictionary to check 
9e49			 
9e49 2a 35 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
9e4c			 
9e4c cd e1 9e			call forth_tok_next 
9e4f			; tok next end here 
9e4f 22 35 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9e52 eb				ex de, hl 
9e53			 
9e53			 
9e53				; save the pointer of the current token - 1 to check against 
9e53				 
9e53 22 39 ea			ld (cli_token), hl   
9e56				; TODO maybe remove below save if no debug 
9e56				; save token string ptr for any debug later 
9e56 23				inc hl  
9e57 22 3b ea			ld (cli_origtoken), hl 
9e5a 2b				dec hl 
9e5b				; save pointer to the start of the next dictionay word 
9e5b 7e				ld a,(hl)   ; get string length 
9e5c			;	ld b,a 
9e5c			;.execpnwordinc:  
9e5c			;	inc hl 
9e5c			;	djnz .execpnwordinc 
9e5c 06 00			ld b, 0 
9e5e 4f				ld c, a 
9e5f 09				add hl, bc 
9e60 22 37 ea			ld (cli_execword), hl      ; save start of this words code 
9e63			 
9e63				; now check the word token against the string being parsed 
9e63			 
9e63 2a 39 ea			ld hl,(cli_token) 
9e66 23				inc hl     ; skip string length (use zero term instead to end) 
9e67				;ld (cli_token), hl 
9e67			 
9e67			.execpnchar:    ; compare char between token and string to parse 
9e67			 
9e67			 
9e67				;ld hl, (cli_token)     ; the dict word  
9e67 ed 5b 33 ea		ld de, (cli_ptr)     ; cli to parse 
9e6b			 
9e6b			 
9e6b			.execpncharl:    ; compare char between token and string to parse (loop) 
9e6b			 
9e6b 1a				ld a,(de) 
9e6c cd 2a 90			call toUpper 		; make sure the input string matches case 
9e6f be				cp (hl) 
9e70			 
9e70 c2 88 9e			jp nz, .execpnskipword	 ; no match so move to next word 
9e73				 
9e73			;    if same 
9e73			;       scan for string terms 0 for token and 32 for input 
9e73 46				ld b,(hl) 
9e74 80				add b			 
9e75 23				inc hl 
9e76 13				inc de 
9e77 b7				or a 
9e78			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9e78							; TODO need to make sure last word in zero term string is accounted for 
9e78 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
9e7a			 
9e7a			 
9e7a				; at end of both strings so both are exact match 
9e7a			 
9e7a			;       skip ptr for next word 
9e7a			 
9e7a 2a 33 ea			ld hl,(cli_ptr) 	; at input string term 
9e7d 23				inc hl			 ; at next char 
9e7e 22 33 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9e81 22 31 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9e84				 
9e84				 
9e84			 
9e84			 
9e84			 
9e84			;       exec code block 
9e84			if DEBUG_FORTH_JP 
9e84				call clear_display 
9e84				call update_display 
9e84				call delay1s 
9e84				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e84				ld a,h 
9e84				ld hl, os_word_scratch 
9e84				call hexout 
9e84				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e84				ld a,l 
9e84				ld hl, os_word_scratch+2 
9e84				call hexout 
9e84				ld hl, os_word_scratch+4 
9e84			;	ld a,0 
9e84				ld (hl),0 
9e84				ld de,os_word_scratch 
9e84				call str_at_display 
9e84					ld a, display_row_2 
9e84					call str_at_display 
9e84				ld de, (cli_origtoken) 
9e84				ld a, display_row_1+10 
9e84					call str_at_display 
9e84			 
9e84				ld a,display_row_1 
9e84				ld de, .foundword 
9e84				ld a, display_row_3 
9e84				call str_at_display 
9e84				call update_display 
9e84				call delay1s 
9e84				call delay1s 
9e84				call delay1s 
9e84			endif 
9e84			 
9e84			if DEBUG_FORTH_PARSE_EXEC 
9e84						DMARK "KYj" 
9e84			endif 
9e84				; TODO save the word pointer in this exec 
9e84			 
9e84 2a 37 ea			ld hl,(cli_execword) 
9e87 e9				jp (hl) 
9e88			 
9e88			 
9e88			;    if not same 
9e88			;	scan for zero term 
9e88			;	get ptr for next word 
9e88			;	goto word comp 
9e88			 
9e88			.execpnskipword:	; get pointer to next word 
9e88 2a 35 ea			ld hl,(cli_nextword) 
9e8b			 
9e8b 7e				ld a,(hl) 
9e8c fe 00			cp WORD_SYS_END 
9e8e			;	cp 0 
9e8e 28 09			jr z, .execendofdict			 ; at end of words 
9e90			 
9e90			if DEBUG_FORTH_PARSE_EXEC 
9e90						DMARK "KY4" 
9e90			endif 
9e90			if DEBUG_FORTH_PARSE_EXEC 
9e90			 
9e90				; see if disabled 
9e90			 
9e90			;	ld a, (os_view_disable) 
9e90			;	cp '*' 
9e90				ld a,(debug_vector) 
9e90				cp $c9   ; RET 
9e90				jr z, .noskip 
9e90			 
9e90			 
9e90				ld de, .nowordfound 
9e90				ld a, display_row_3 
9e90				call str_at_display 
9e90				call update_display 
9e90				ld a, 100 
9e90				call aDelayInMS 
9e90				 
9e90				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e90					call delay250ms 
9e90				endif 
9e90			.noskip:  
9e90			 
9e90			endif	 
9e90			 
9e90 2a 31 ea			ld hl,(cli_origptr) 
9e93 22 33 ea			ld (cli_ptr),hl 
9e96			 
9e96			if DEBUG_FORTH_PARSE_EXEC 
9e96						DMARK "KY5" 
9e96			endif 
9e96 c3 49 9e			jp .execpnword			; else go to next word 
9e99			 
9e99			.execendofdict:  
9e99			 
9e99			if DEBUG_FORTH_PARSE_EXEC 
9e99						DMARK "KYe" 
9e99			endif 
9e99			if DEBUG_FORTH_PARSE_EXEC 
9e99				; see if disabled 
9e99			 
9e99			;	ld a, (os_view_disable) 
9e99			;	cp '*' 
9e99				ld a,(debug_vector) 
9e99				cp $c9   ; ret 
9e99				jr z, .ispskip 
9e99			 
9e99				call clear_display 
9e99				call update_display 
9e99				call delay1s 
9e99				ld de, (cli_origptr) 
9e99				ld a, display_row_1 
9e99				call str_at_display 
9e99				 
9e99				ld de, .enddict 
9e99				ld a, display_row_3 
9e99				call str_at_display 
9e99				call update_display 
9e99				ld a, 100 
9e99				call aDelayInMS 
9e99				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e99				call delay1s 
9e99				call delay1s 
9e99				call delay1s 
9e99				endif 
9e99			.ispskip:  
9e99				 
9e99			endif	 
9e99			 
9e99			 
9e99			 
9e99				; if the word is not a keyword then must be a literal so push it to stack 
9e99			 
9e99			; push token to stack to end of word 
9e99			 
9e99				STACKFRAME ON $1efe $2f9f 
9e99				if DEBUG_STACK_IMB 
9e99					if ON 
9e99						exx 
9e99						ld de, $1efe 
9e99						ld a, d 
9e99						ld hl, curframe 
9e99						call hexout 
9e99						ld a, e 
9e99						ld hl, curframe+2 
9e99						call hexout 
9e99						ld hl, $1efe 
9e99						push hl 
9e99						ld hl, $2f9f 
9e99						push hl 
9e99						exx 
9e99					endif 
9e99				endif 
9e99			endm 
# End of macro STACKFRAME
9e99			 
9e99 2a b5 e5		ld hl,(os_tok_ptr) 
9e9c cd 2e 9b		call forth_apush 
9e9f			 
9e9f				STACKFRAMECHK ON $1efe $2f9f 
9e9f				if DEBUG_STACK_IMB 
9e9f					if ON 
9e9f						exx 
9e9f						ld hl, $2f9f 
9e9f						pop de   ; $2f9f 
9e9f						call cmp16 
9e9f						jr nz, .spnosame 
9e9f						ld hl, $1efe 
9e9f						pop de   ; $1efe 
9e9f						call cmp16 
9e9f						jr z, .spfrsame 
9e9f						.spnosame: call showsperror 
9e9f						.spfrsame: nop 
9e9f						exx 
9e9f					endif 
9e9f				endif 
9e9f			endm 
# End of macro STACKFRAMECHK
9e9f			 
9e9f			execnext: 
9e9f			 
9e9f			if DEBUG_FORTH_PARSE_EXEC 
9e9f						DMARK "KY>" 
9e9f			endif 
9e9f			; move past token to next word 
9e9f			 
9e9f 2a b5 e5		ld hl, (os_tok_ptr) 
9ea2 3e 00		ld a, 0 
9ea4 01 ff 00		ld bc, 255     ; input buffer size 
9ea7 ed b1		cpir 
9ea9			 
9ea9			if DEBUG_FORTH_PARSE_EXEC 
9ea9						DMARK "KY!" 
9ea9				CALLMONITOR 
9ea9			endif	 
9ea9			; TODO this might place hl on the null, so will need to forward on??? 
9ea9			;inc hl   ; see if this gets onto the next item 
9ea9			 
9ea9			 
9ea9			; TODO pass a pointer to the buffer to push 
9ea9			; TODO call function to push 
9ea9			 
9ea9			; look for end of input 
9ea9			 
9ea9			;inc hl 
9ea9			;ld a,(hl) 
9ea9			;cp FORTH_END_BUFFER 
9ea9			;ret z 
9ea9			 
9ea9			 
9ea9 c3 30 9e		jp exec1 
9eac			 
9eac			 
9eac			 
9eac			 
9eac			 
9eac			 
9eac			 
9eac			 
9eac			 
9eac			findnexttok: 
9eac			 
9eac				; hl is pointer to move 
9eac				; de is the token to locate 
9eac			 
9eac					if DEBUG_FORTH 
9eac						DMARK "NTK" 
9eac						CALLMONITOR 
9eac					endif 
9eac d5				push de 
9ead			 
9ead			.fnt1:	 
9ead				; find first char of token to locate 
9ead			 
9ead 1a				ld a, (de) 
9eae 4f				ld c,a 
9eaf 7e				ld a,(hl) 
9eb0 cd 2a 90			call toUpper 
9eb3					if DEBUG_FORTH 
9eb3						DMARK "NT1" 
9eb3						CALLMONITOR 
9eb3					endif 
9eb3 b9				cp c 
9eb4			 
9eb4 28 03			jr z, .fnt2cmpmorefirst	 
9eb6			 
9eb6				; first char not found move to next char 
9eb6			 
9eb6 23				inc hl 
9eb7 18 f4			jr .fnt1 
9eb9			 
9eb9			.fnt2cmpmorefirst:	 
9eb9				; first char of token found.  
9eb9			 
9eb9 e5				push hl     ; save start of token just in case it is the right one 
9eba d9				exx 
9ebb e1				pop hl        ; save it to hl' 
9ebc d9				exx 
9ebd			 
9ebd			 
9ebd			.fnt2cmpmore:	 
9ebd				; compare the rest 
9ebd				 
9ebd 23				inc hl 
9ebe 13				inc de 
9ebf				 
9ebf 1a				ld a, (de) 
9ec0 4f				ld c,a 
9ec1 7e				ld a,(hl) 
9ec2 cd 2a 90			call toUpper 
9ec5			 
9ec5					if DEBUG_FORTH 
9ec5						DMARK "NT2" 
9ec5						CALLMONITOR 
9ec5					endif 
9ec5				; c has the token to find char 
9ec5				; a has the mem to scan char 
9ec5			 
9ec5 b9				cp c 
9ec6 28 04			jr z,.fntmatch1 
9ec8			 
9ec8				; they are not the same 
9ec8			 
9ec8					if DEBUG_FORTH 
9ec8						DMARK "NT3" 
9ec8						CALLMONITOR 
9ec8					endif 
9ec8 d1				pop de	; reset de token to look for 
9ec9 d5				push de 
9eca 18 e1			jr .fnt1 
9ecc				 
9ecc			.fntmatch1: 
9ecc			 
9ecc				; is the same char a null which means we might have a full hit? 
9ecc					if DEBUG_FORTH 
9ecc						DMARK "NT4" 
9ecc						CALLMONITOR 
9ecc					endif 
9ecc			 
9ecc			;	cp 0 
9ecc b7				or a 
9ecd 28 0b			jr z, .fntmatchyes 
9ecf			 
9ecf				; are we at the end of the token to find? 
9ecf			 
9ecf					if DEBUG_FORTH 
9ecf						DMARK "NT5" 
9ecf						CALLMONITOR 
9ecf					endif 
9ecf 3e 00			ld a, 0 
9ed1 b9				cp c 
9ed2			 
9ed2 c2 bd 9e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9ed5			 
9ed5					if DEBUG_FORTH 
9ed5						DMARK "NT6" 
9ed5						CALLMONITOR 
9ed5					endif 
9ed5				; token to find is exhusted but no match to stream 
9ed5			 
9ed5				; restore tok pointer and continue on 
9ed5 d1				pop de 
9ed6 d5				push de 
9ed7 c3 ad 9e			jp .fnt1 
9eda			 
9eda			 
9eda			.fntmatchyes: 
9eda			 
9eda				; hl now contains the end of the found token 
9eda			 
9eda				; get rid of saved token pointer to find 
9eda			 
9eda d1				pop de 
9edb			 
9edb					if DEBUG_FORTH 
9edb						DMARK "NT9" 
9edb						CALLMONITOR 
9edb					endif 
9edb			 
9edb				; hl will be on the null term so forward on 
9edb			 
9edb				; get back the saved start of the token 
9edb			 
9edb d9				exx 
9edc e5				push hl     ; save start of token just in case it is the right one 
9edd d9				exx 
9ede e1				pop hl        ; save it to hl 
9edf			 
9edf c9				ret 
9ee0			 
9ee0			 
9ee0			; LIST needs to find a specific token   
9ee0			; FORGET needs to find a spefici token 
9ee0			 
9ee0			; SAVE needs to find all tokens by flag 
9ee0			; WORDS just needs to scan through all  by flag 
9ee0			; UWORDS needs to scan through all by flag 
9ee0			 
9ee0			 
9ee0			; given hl as pointer to start of dict look up string 
9ee0			; return hl as pointer to start of word block 
9ee0			; or 0 if not found 
9ee0			 
9ee0			forth_find_tok: 
9ee0 c9				ret 
9ee1			 
9ee1			; given hl as pointer to dict structure 
9ee1			; move to the next dict block structure 
9ee1			 
9ee1			forth_tok_next: 
9ee1				; hl now points to the address of the next word pointer  
9ee1				; TODO skip compiled symbol for now 
9ee1			;	push de 
9ee1 23				inc hl 
9ee2 5e				ld e, (hl) 
9ee3 23				inc hl 
9ee4 56				ld d, (hl) 
9ee5 23				inc hl 
9ee6			 
9ee6 eb				ex de,hl 
9ee7			if DEBUG_FORTH_PARSE_NEXTWORD 
9ee7				push bc 
9ee7				ld bc, (cli_nextword) 
9ee7						DMARK "NXW" 
9ee7				CALLMONITOR 
9ee7				pop bc 
9ee7			endif 
9ee7			;	pop de	 
9ee7 c9				ret 
9ee8			 
9ee8			 
9ee8			 
9ee8			; eof 
# End of file forth_parserv6.asm
9ee8				include "forth_wordsv4.asm" 
9ee8			 
9ee8			; the core word dictionary v4 
9ee8			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9ee8			 
9ee8			; this is a linked list for each of the system words used 
9ee8			; user defined words will follow the same format but will be in ram 
9ee8			 
9ee8			 
9ee8			; 
9ee8			; 
9ee8			; define linked list: 
9ee8			; 
9ee8			; 1. compiled byte op code 
9ee8			; 2. len of text word 
9ee8			; 3. text word 
9ee8			; 4. ptr to next dictionary word 
9ee8			; 5. asm, calls etc for the word 
9ee8			; 
9ee8			;  if 1 == 0 then last word in dict  
9ee8			;   
9ee8			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9ee8			;  
9ee8			;  
9ee8			; create basic standard set of words 
9ee8			; 
9ee8			;  
9ee8			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9ee8			; 2DUP 2DROP 2SWAP  
9ee8			; @ C@ - get byte  
9ee8			; ! C! - store byte 
9ee8			; 0< true if less than zero 
9ee8			; 0= true if zero 
9ee8			; < >  
9ee8			; = true if same 
9ee8			; variables 
9ee8			 
9ee8			 
9ee8			; Hardware specific words I may need 
9ee8			; 
9ee8			; IN OUT  
9ee8			; calls to key util functions 
9ee8			; calls to hardward abstraction stuff 
9ee8			; easy control of frame buffers and lcd i/o 
9ee8			; keyboard  
9ee8			 
9ee8			 
9ee8			;DICT: macro 
9ee8			; op_code, len, word, next 
9ee8			;    word: 
9ee8			;    db op_code 
9ee8			;    ds word zero term 
9ee8			;    dw next 
9ee8			;    endm 
9ee8			 
9ee8			 
9ee8			 
9ee8			 
9ee8			; op code 1 is a flag for user define words which are to be handled differently 
9ee8			 
9ee8			 
9ee8			; 
9ee8			; 
9ee8			;    TODO on entry to a word this should be the expected environment 
9ee8			;    hl - tos value if number then held, if string this is the ptr 
9ee8			;    de -  
9ee8			 
9ee8			 
9ee8			; opcode ranges 
9ee8			; 0 - end of word dict 
9ee8			; 255 - user define words 
9ee8			 
9ee8			sysdict: 
9ee8			include "forth_opcodes.asm" 
9ee8			; op codes for forth keywords 
9ee8			 
9ee8			; Changing use of opcodes to flag is the word exists in compiled form or not.  
9ee8			; This provides a means to compile uwords if required for higher performance 
9ee8			; by avoiding the use of the keyword parser and just jumping directly to the code 
9ee8			; Actually there is already a flag for if the code exists as binary thinking about it... 
9ee8			 
9ee8			 
9ee8			 
9ee8			 
9ee8			 
9ee8			; free to use code 0  
9ee8				OPCODE_HEAP: equ  1 
9ee8				OPCODE_EXEC: equ 2 
9ee8				OPCODE_DUP: equ 3 
9ee8				OPCODE_SWAP: equ 4 
9ee8				OPCODE_COLN: equ 5 
9ee8				OPCODE_SCOLN: equ 6 
9ee8				OPCODE_DROP: equ 7 
9ee8				OPCODE_DUP2: equ 8 
9ee8				OPCODE_DROP2: equ 9 
9ee8				OPCODE_SWAP2: equ 10 
9ee8				OPCODE_AT: equ 11 
9ee8				OPCODE_CAT: equ 12 
9ee8				OPCODE_BANG: equ 13 
9ee8				OPCODE_CBANG: equ 14 
9ee8				OPCODE_SCALL: equ 15 
9ee8				OPCODE_DEPTH: equ 16 
9ee8				OPCODE_OVER: equ 17 
9ee8				OPCODE_PAUSE: equ 18 
9ee8				OPCODE_PAUSES: equ 19 
9ee8				OPCODE_ROT: equ 20 
9ee8			;free to reuse	OPCODE_WORDS: equ 21 
9ee8			        OPCODE_NOT: equ 21 
9ee8				OPCODE_UWORDS: equ 22 
9ee8				OPCODE_BP: equ 23 
9ee8				OPCODE_MONITOR: equ 24  
9ee8				OPCODE_MALLOC: equ 25 
9ee8				OPCODE_FREE: equ 26 
9ee8				OPCODE_LIST: equ 27 
9ee8				OPCODE_FORGET: equ 28 
9ee8				OPCODE_NOP: equ 29 
9ee8				OPCODE_COMO: equ 30 
9ee8				OPCODE_COMC: equ 31 
9ee8			;free to reuse	OPCODE_ENDCORE: equ 32 
9ee8				OPCODE_AFTERSOUND: equ 33 
9ee8				OPCODE_GP2: equ 34 
9ee8				OPCODE_GP3: equ 35 
9ee8				OPCODE_GP4: equ 36 
9ee8				OPCODE_SIN: equ 37 
9ee8				OPCODE_SOUT: equ 38 
9ee8				OPCODE_SPIO: equ 39 
9ee8				OPCODE_SPICEH: equ 40 
9ee8				OPCODE_SPIOb: equ 41 
9ee8				OPCODE_SPII: equ 42 
9ee8				OPCODE_SESEL: equ 43 
9ee8				OPCODE_CARTDEV: equ 44 
9ee8			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9ee8				OPCODE_FB: equ 46 
9ee8				OPCODE_EMIT: equ 47 
9ee8				OPCODE_DOTH: equ 48 
9ee8				OPCODE_DOTF: equ 49 
9ee8				OPCODE_DOT: equ 50 
9ee8				OPCODE_CLS: equ 51 
9ee8				OPCODE_DRAW: equ 52 
9ee8				OPCODE_DUMP: equ 53 
9ee8				OPCODE_CDUMP: equ 54 
9ee8				OPCODE_DAT: equ 55 
9ee8				OPCODE_HOME: equ 56 
9ee8				OPCODE_SPACE: equ 57 
9ee8				OPCODE_SPACES: equ 58 
9ee8				OPCODE_SCROLL: equ 59 
9ee8				OPCODE_ATQ: equ 60 
9ee8				OPCODE_AUTODSP: equ 61 
9ee8				OPCODE_MENU: equ 62 
9ee8			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9ee8				OPCODE_THEN: equ 64 
9ee8				OPCODE_ELSE: equ 65 
9ee8				OPCODE_DO: equ 66 
9ee8				OPCODE_LOOP: equ 67 
9ee8				OPCODE_I: equ 68 
9ee8				OPCODE_DLOOP: equ 69  
9ee8				OPCODE_REPEAT: equ 70  
9ee8				OPCODE_UNTIL: equ 71 
9ee8				OPCODE_ENDFLOW: equ 72 
9ee8				OPCODE_WAITK: equ 73 
9ee8				OPCODE_ACCEPT: equ 74 
9ee8				OPCODE_EDIT: equ 75 
9ee8			;free to reuse	OPCODE_ENDKEY: equ 76 
9ee8				OPCODE_LZERO: equ 77 
9ee8				OPCODE_TZERO: equ 78 
9ee8				OPCODE_LESS: equ 79 
9ee8				OPCODE_GT: equ 80 
9ee8				OPCODE_EQUAL: equ 81  
9ee8			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9ee8				OPCODE_NEG: equ 83 
9ee8				OPCODE_DIV: equ 84 
9ee8				OPCODE_MUL: equ 85 
9ee8				OPCODE_MIN: equ 86 
9ee8				OPCODE_MAX: equ 87 
9ee8				OPCODE_RND16: equ 88 
9ee8				OPCODE_RND8: equ 89 
9ee8				OPCODE_RND: equ 90 
9ee8			;free to reuse	OPCODE_ENDMATHS: equ 91  
9ee8				OPCODE_BYNAME: equ 92 
9ee8				OPCODE_DIR: equ 93 
9ee8				OPCODE_SAVE: equ 94 
9ee8				OPCODE_LOAD: equ 95 
9ee8				OPCODE_BSAVE: equ 96 
9ee8				OPCODE_BLOAD: equ 97 
9ee8				OPCODE_SEO: equ 98  
9ee8				OPCODE_SEI: equ 99 
9ee8				OPCODE_SFREE: equ 100 
9ee8				OPCODE_SIZE: equ 101 
9ee8				OPCODE_CREATE: equ 102 
9ee8				OPCODE_APPEND: equ 103 
9ee8				OPCODE_SDEL: equ 104 
9ee8				OPCODE_OPEN: equ 105 
9ee8				OPCODE_READ: equ 106 
9ee8				OPCODE_EOF: equ 106 
9ee8				OPCODE_FORMAT: equ 107 
9ee8				OPCODE_LABEL: equ 108 
9ee8				OPCODE_LABELS: equ 109 
9ee8			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9ee8				OPCODE_UPPER: equ 111 
9ee8				OPCODE_LOWER: equ 112 
9ee8				OPCODE_SUBSTR: equ 113 
9ee8				OPCODE_LEFT: equ 114 
9ee8				OPCODE_RIGHT: equ 115 
9ee8				OPCODE_STR2NUM: equ 116 
9ee8				OPCODE_NUM2STR: equ 117 
9ee8				OPCODE_CONCAT: equ 118 
9ee8				OPCODE_FIND: equ 119 
9ee8				OPCODE_LEN: equ 120 
9ee8				OPCODE_CHAR: equ 121 
9ee8			; free to reuse	OPCODE_STRLEN: equ 122 
9ee8			; free to reuse	OPCODE_ENDSTR: equ 123 
9ee8				OPCODE_V0S: equ 124 
9ee8				OPCODE_V0Q: equ 125 
9ee8				OPCODE_V1S: equ 126 
9ee8				OPCODE_V1Q: equ 127 
9ee8				OPCODE_V2S: equ 128 
9ee8				OPCODE_V2Q: equ 129 
9ee8				OPCODE_V3S: equ 130 
9ee8				OPCODE_V3Q: equ 131 
9ee8			;free to reuse	OPCODE_END: equ 132 
9ee8				OPCODE_ZDUP: equ 133 
9ee8			 
9ee8			; eof 
# End of file forth_opcodes.asm
9ee8			 
9ee8			include "forth_words_core.asm" 
9ee8			 
9ee8			; | ## Core Words 
9ee8			 
9ee8			;if MALLOC_4 
9ee8			 
9ee8			.HEAP: 
9ee8			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9ee8 15				db WORD_SYS_CORE+OPCODE_HEAP             
9ee9 2a 9f			dw .EXEC            
9eeb 05				db 4 + 1 
9eec .. 00			db "HEAP",0              
9ef1				endm 
# End of macro CWHEAD
9ef1			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9ef1			; | | u1 - Current number of bytes in the heap 
9ef1			; | | u2 - Remaining bytes left on the heap 
9ef1			; | |  
9ef1			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9ef1			 
9ef1			 
9ef1				if DEBUG_FORTH_WORDS_KEY 
9ef1					DMARK "HEP" 
9ef1 f5				push af  
9ef2 3a 06 9f			ld a, (.dmark)  
9ef5 32 5e ee			ld (debug_mark),a  
9ef8 3a 07 9f			ld a, (.dmark+1)  
9efb 32 5f ee			ld (debug_mark+1),a  
9efe 3a 08 9f			ld a, (.dmark+2)  
9f01 32 60 ee			ld (debug_mark+2),a  
9f04 18 03			jr .pastdmark  
9f06 ..			.dmark: db "HEP"  
9f09 f1			.pastdmark: pop af  
9f0a			endm  
# End of macro DMARK
9f0a					CALLMONITOR 
9f0a cd 6b ee			call debug_vector  
9f0d				endm  
# End of macro CALLMONITOR
9f0d				endif 
9f0d 2a 46 e6			ld hl, (free_list )      
9f10 11 4b e6			ld de, heap_start 
9f13			 
9f13 ed 52			sbc hl, de  
9f15			 
9f15 cd cc 99			call forth_push_numhl 
9f18			 
9f18			 
9f18 ed 5b 46 e6		ld de, (free_list )      
9f1c 21 8f e2			ld hl, heap_end 
9f1f			 
9f1f ed 52			sbc hl, de 
9f21			 
9f21 cd cc 99			call forth_push_numhl 
9f24				 
9f24			 
9f24				 
9f24			 
9f24			 
9f24			 
9f24				NEXTW 
9f24 cd 68 ee			call parse_vector 
9f27 c3 af 9d			jp macro_next 
9f2a				endm 
# End of macro NEXTW
9f2a			;endif 
9f2a			 
9f2a			.EXEC: 
9f2a			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9f2a			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9f2a			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9f2a			;; > > 
9f2a			;; > >   
9f2a			;	STACKFRAME OFF $5efe $5f9f 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS_KEY 
9f2a			;			DMARK "EXE" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			; 
9f2a			;	FORTH_DSP_VALUEHL 
9f2a			; 
9f2a			;	FORTH_DSP_POP 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX1" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;;	ld e,(hl) 
9f2a			;;	inc hl 
9f2a			;;	ld d,(hl) 
9f2a			;;	ex de,hl 
9f2a			; 
9f2a			;;		if DEBUG_FORTH_WORDS 
9f2a			;;			DMARK "EX2" 
9f2a			;;			CALLMONITOR 
9f2a			;;		endif 
9f2a			;	push hl 
9f2a			; 
9f2a			;	;ld a, 0 
9f2a			;	;ld a, FORTH_END_BUFFER 
9f2a			;	call strlenz 
9f2a			;	inc hl   ; include zero term to copy 
9f2a			;	inc hl   ; include term 
9f2a			;	inc hl   ; include term 
9f2a			;	ld b,0 
9f2a			;	ld c,l 
9f2a			;	pop hl 
9f2a			;	ld de, execscratch 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX3" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	ldir 
9f2a			; 
9f2a			; 
9f2a			;	ld hl, execscratch 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EXe" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			; 
9f2a			;	call forthparse 
9f2a			;	call forthexec 
9f2a			;;	call forthexec_cleanup 
9f2a			;;	call forthparse 
9f2a			;;	call forthexec 
9f2a			; 
9f2a			;	STACKFRAMECHK OFF $5efe $5f9f 
9f2a			; 
9f2a			;	; an immediate word so no need to process any more words 
9f2a			;	ret 
9f2a			;	NEXTW 
9f2a			 
9f2a			; dead code - old version  
9f2a			;	FORTH_RSP_NEXT 
9f2a			 
9f2a			;  
9f2a			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f2a			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f2a			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f2a			;	push hl 
9f2a			;	push de 
9f2a			;	push bc 
9f2a			; 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS_KEY 
9f2a			;			DMARK "EXR" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			; 
9f2a			; 
9f2a			; 
9f2a			;	;v5 FORTH_DSP_VALUE 
9f2a			;	FORTH_DSP_VALUEHL 
9f2a			; 
9f2a			;	; TODO do string type checks 
9f2a			; 
9f2a			;;v5	inc hl   ; skip type 
9f2a			; 
9f2a			;	push hl  ; source code  
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX1" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	ld a, 0 
9f2a			;	call strlent 
9f2a			; 
9f2a			;	inc hl 
9f2a			;	inc hl 
9f2a			;	inc hl 
9f2a			;	inc hl 
9f2a			; 
9f2a			;	push hl    ; size 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX2" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	call malloc 
9f2a			; 
9f2a			;	ex de, hl    ; de now contains malloc area 
9f2a			;	pop bc   	; get byte count 
9f2a			;	pop hl      ; get string to copy 
9f2a			; 
9f2a			;	push de     ; save malloc for free later 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX3" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	ldir       ; duplicate string 
9f2a			; 
9f2a			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9f2a			;	 
9f2a			;	; TODO fix the parse would be better than this...  
9f2a			;	ex de, hl 
9f2a			;	dec hl 
9f2a			;	ld a, 0 
9f2a			;	ld (hl), a 
9f2a			;	dec hl 
9f2a			;	ld a, ' ' 
9f2a			;	ld (hl), a 
9f2a			;	dec hl 
9f2a			;	ld (hl), a 
9f2a			; 
9f2a			;	dec hl 
9f2a			;	ld (hl), a 
9f2a			; 
9f2a			; 
9f2a			;	FORTH_DSP_POP  
9f2a			; 
9f2a			;	pop hl     
9f2a			;	push hl    ; save malloc area 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX4" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			; 
9f2a			;	call forthparse 
9f2a			;	call forthexec 
9f2a			;	 
9f2a			;	pop hl 
9f2a			;	if DEBUG_FORTH_WORDS 
9f2a			;		DMARK "EX5" 
9f2a			;		CALLMONITOR 
9f2a			;	endif 
9f2a			; 
9f2a			;	if FORTH_ENABLE_FREE 
9f2a			;	call free 
9f2a			;	endif 
9f2a			; 
9f2a			;	if DEBUG_FORTH_WORDS 
9f2a			;		DMARK "EX6" 
9f2a			;		CALLMONITOR 
9f2a			;	endif 
9f2a			; 
9f2a			;	pop bc 
9f2a			;	pop de 
9f2a			;	pop hl 
9f2a			;;	FORTH_RSP_POP	  
9f2a			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9f2a			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9f2a			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9f2a			; 
9f2a			;	if DEBUG_FORTH_WORDS 
9f2a			;		DMARK "EX7" 
9f2a			;		CALLMONITOR 
9f2a			;	endif 
9f2a			;	NEXTW 
9f2a			 
9f2a			;.STKEXEC: 
9f2a			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9f2a			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9f2a			; 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS_KEY 
9f2a			;			DMARK "STX" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			; 
9f2a			;	FORTH_DSP_VALUEHL 
9f2a			; 
9f2a			;	ld (store_tmp1), hl    ; count 
9f2a			; 
9f2a			;	FORTH_DSP_POP 
9f2a			;.stkexec1: 
9f2a			;	ld hl, (store_tmp1)   ; count 
9f2a			;	ld a, 0 
9f2a			;	cp l 
9f2a			;	ret z 
9f2a			; 
9f2a			;	dec hl 
9f2a			;	ld (store_tmp1), hl    ; count 
9f2a			;	 
9f2a			;	FORTH_DSP_VALUEHL 
9f2a			;	push hl 
9f2a			;	 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EXp" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	FORTH_DSP_POP 
9f2a			; 
9f2a			;	call strlenz 
9f2a			;	inc hl   ; include zero term to copy 
9f2a			;	inc hl   ; include zero term to copy 
9f2a			;	inc hl   ; include zero term to copy 
9f2a			;	ld b,0 
9f2a			;	ld c,l 
9f2a			;	pop hl 
9f2a			;	ld de, execscratch 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EX3" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	ldir 
9f2a			; 
9f2a			; 
9f2a			;	ld hl, execscratch 
9f2a			; 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EXP" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			; 
9f2a			;	call forthparse 
9f2a			;	ld hl, execscratch 
9f2a			;		if DEBUG_FORTH_WORDS 
9f2a			;			DMARK "EXx" 
9f2a			;			CALLMONITOR 
9f2a			;		endif 
9f2a			;	call forthexec 
9f2a			; 
9f2a			;	jp .stkexec1 
9f2a			; 
9f2a			;	ret 
9f2a			 
9f2a			 
9f2a			.DUP: 
9f2a			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9f2a 17				db WORD_SYS_CORE+OPCODE_DUP             
9f2b a6 9f			dw .ZDUP            
9f2d 04				db 3 + 1 
9f2e .. 00			db "DUP",0              
9f32				endm 
# End of macro CWHEAD
9f32			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9f32			; | | >[!NOTE] 
9f32			; | | > If the duplicated item is a string it is safely duplicated 
9f32			 
9f32				if DEBUG_FORTH_WORDS_KEY 
9f32					DMARK "DUP" 
9f32 f5				push af  
9f33 3a 47 9f			ld a, (.dmark)  
9f36 32 5e ee			ld (debug_mark),a  
9f39 3a 48 9f			ld a, (.dmark+1)  
9f3c 32 5f ee			ld (debug_mark+1),a  
9f3f 3a 49 9f			ld a, (.dmark+2)  
9f42 32 60 ee			ld (debug_mark+2),a  
9f45 18 03			jr .pastdmark  
9f47 ..			.dmark: db "DUP"  
9f4a f1			.pastdmark: pop af  
9f4b			endm  
# End of macro DMARK
9f4b					CALLMONITOR 
9f4b cd 6b ee			call debug_vector  
9f4e				endm  
# End of macro CALLMONITOR
9f4e				endif 
9f4e			 
9f4e				FORTH_DSP 
9f4e cd 8e 9b			call macro_forth_dsp 
9f51				endm 
# End of macro FORTH_DSP
9f51			 
9f51 7e				ld a, (HL) 
9f52 fe 01			cp DS_TYPE_STR 
9f54 20 28			jr nz, .dupinum 
9f56			 
9f56				; push another string 
9f56			 
9f56				FORTH_DSP_VALUEHL     		 
9f56 cd c8 9b			call macro_dsp_valuehl 
9f59				endm 
# End of macro FORTH_DSP_VALUEHL
9f59			 
9f59			if DEBUG_FORTH_WORDS 
9f59				DMARK "DUs" 
9f59 f5				push af  
9f5a 3a 6e 9f			ld a, (.dmark)  
9f5d 32 5e ee			ld (debug_mark),a  
9f60 3a 6f 9f			ld a, (.dmark+1)  
9f63 32 5f ee			ld (debug_mark+1),a  
9f66 3a 70 9f			ld a, (.dmark+2)  
9f69 32 60 ee			ld (debug_mark+2),a  
9f6c 18 03			jr .pastdmark  
9f6e ..			.dmark: db "DUs"  
9f71 f1			.pastdmark: pop af  
9f72			endm  
# End of macro DMARK
9f72				CALLMONITOR 
9f72 cd 6b ee			call debug_vector  
9f75				endm  
# End of macro CALLMONITOR
9f75			endif 
9f75 cd 36 9a			call forth_push_str 
9f78			 
9f78				NEXTW 
9f78 cd 68 ee			call parse_vector 
9f7b c3 af 9d			jp macro_next 
9f7e				endm 
# End of macro NEXTW
9f7e			 
9f7e			 
9f7e			.dupinum: 
9f7e				 
9f7e			 
9f7e			 
9f7e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f7e cd c8 9b			call macro_dsp_valuehl 
9f81				endm 
# End of macro FORTH_DSP_VALUEHL
9f81			 
9f81			; TODO add floating point number detection 
9f81			 
9f81			if DEBUG_FORTH_WORDS 
9f81				DMARK "DUi" 
9f81 f5				push af  
9f82 3a 96 9f			ld a, (.dmark)  
9f85 32 5e ee			ld (debug_mark),a  
9f88 3a 97 9f			ld a, (.dmark+1)  
9f8b 32 5f ee			ld (debug_mark+1),a  
9f8e 3a 98 9f			ld a, (.dmark+2)  
9f91 32 60 ee			ld (debug_mark+2),a  
9f94 18 03			jr .pastdmark  
9f96 ..			.dmark: db "DUi"  
9f99 f1			.pastdmark: pop af  
9f9a			endm  
# End of macro DMARK
9f9a				CALLMONITOR 
9f9a cd 6b ee			call debug_vector  
9f9d				endm  
# End of macro CALLMONITOR
9f9d			endif 
9f9d			 
9f9d cd cc 99			call forth_push_numhl 
9fa0				NEXTW 
9fa0 cd 68 ee			call parse_vector 
9fa3 c3 af 9d			jp macro_next 
9fa6				endm 
# End of macro NEXTW
9fa6			.ZDUP: 
9fa6			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9fa6 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fa7 e0 9f			dw .DMRK            
9fa9 05				db 4 + 1 
9faa .. 00			db "?DUP",0              
9faf				endm 
# End of macro CWHEAD
9faf			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
9faf			; | | >[!NOTE] 
9faf			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
9faf			 
9faf				if DEBUG_FORTH_WORDS_KEY 
9faf					DMARK "qDU" 
9faf f5				push af  
9fb0 3a c4 9f			ld a, (.dmark)  
9fb3 32 5e ee			ld (debug_mark),a  
9fb6 3a c5 9f			ld a, (.dmark+1)  
9fb9 32 5f ee			ld (debug_mark+1),a  
9fbc 3a c6 9f			ld a, (.dmark+2)  
9fbf 32 60 ee			ld (debug_mark+2),a  
9fc2 18 03			jr .pastdmark  
9fc4 ..			.dmark: db "qDU"  
9fc7 f1			.pastdmark: pop af  
9fc8			endm  
# End of macro DMARK
9fc8					CALLMONITOR 
9fc8 cd 6b ee			call debug_vector  
9fcb				endm  
# End of macro CALLMONITOR
9fcb				endif 
9fcb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fcb cd c8 9b			call macro_dsp_valuehl 
9fce				endm 
# End of macro FORTH_DSP_VALUEHL
9fce			 
9fce e5				push hl 
9fcf			 
9fcf				; is it a zero? 
9fcf			 
9fcf 3e 00			ld a, 0 
9fd1 84				add h 
9fd2 85				add l 
9fd3			 
9fd3 e1				pop hl 
9fd4			 
9fd4			;	cp 0 
9fd4 b7				or a 
9fd5 28 03			jr z, .dup2orig 
9fd7			 
9fd7			 
9fd7 cd cc 99			call forth_push_numhl 
9fda			 
9fda			 
9fda			; TODO add floating point number detection 
9fda			 
9fda			.dup2orig: 
9fda			 
9fda				NEXTW 
9fda cd 68 ee			call parse_vector 
9fdd c3 af 9d			jp macro_next 
9fe0				endm 
# End of macro NEXTW
9fe0			.DMRK: 
9fe0			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
9fe0 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fe1 20 a0			dw .LSHIFT            
9fe3 06				db 5 + 1 
9fe4 .. 00			db "DMARK",0              
9fea				endm 
# End of macro CWHEAD
9fea			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
9fea			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
9fea				if DEBUG_FORTH_WORDS_KEY 
9fea					DMARK "DMK" 
9fea f5				push af  
9feb 3a ff 9f			ld a, (.dmark)  
9fee 32 5e ee			ld (debug_mark),a  
9ff1 3a 00 a0			ld a, (.dmark+1)  
9ff4 32 5f ee			ld (debug_mark+1),a  
9ff7 3a 01 a0			ld a, (.dmark+2)  
9ffa 32 60 ee			ld (debug_mark+2),a  
9ffd 18 03			jr .pastdmark  
9fff ..			.dmark: db "DMK"  
a002 f1			.pastdmark: pop af  
a003			endm  
# End of macro DMARK
a003					CALLMONITOR 
a003 cd 6b ee			call debug_vector  
a006				endm  
# End of macro CALLMONITOR
a006				endif 
a006				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a006 cd c8 9b			call macro_dsp_valuehl 
a009				endm 
# End of macro FORTH_DSP_VALUEHL
a009			 
a009 7e				ld a, (hl) 
a00a 32 5e ee			ld (debug_mark),a 
a00d 23				inc hl 
a00e 7e				ld a, (hl) 
a00f 32 5f ee			ld (debug_mark+1),a 
a012 23				inc hl 
a013 7e				ld a, (hl) 
a014 32 60 ee			ld (debug_mark+2),a 
a017			 
a017			 
a017				FORTH_DSP_POP 
a017 cd 80 9c			call macro_forth_dsp_pop 
a01a				endm 
# End of macro FORTH_DSP_POP
a01a				NEXTW 
a01a cd 68 ee			call parse_vector 
a01d c3 af 9d			jp macro_next 
a020				endm 
# End of macro NEXTW
a020			.LSHIFT: 
a020			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
a020 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a021 57 a0			dw .RSHIFT            
a023 07				db 6 + 1 
a024 .. 00			db "LSHIFT",0              
a02b				endm 
# End of macro CWHEAD
a02b			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
a02b				if DEBUG_FORTH_WORDS_KEY 
a02b					DMARK "LSH" 
a02b f5				push af  
a02c 3a 40 a0			ld a, (.dmark)  
a02f 32 5e ee			ld (debug_mark),a  
a032 3a 41 a0			ld a, (.dmark+1)  
a035 32 5f ee			ld (debug_mark+1),a  
a038 3a 42 a0			ld a, (.dmark+2)  
a03b 32 60 ee			ld (debug_mark+2),a  
a03e 18 03			jr .pastdmark  
a040 ..			.dmark: db "LSH"  
a043 f1			.pastdmark: pop af  
a044			endm  
# End of macro DMARK
a044					CALLMONITOR 
a044 cd 6b ee			call debug_vector  
a047				endm  
# End of macro CALLMONITOR
a047				endif 
a047				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a047 cd c8 9b			call macro_dsp_valuehl 
a04a				endm 
# End of macro FORTH_DSP_VALUEHL
a04a				FORTH_DSP_POP 
a04a cd 80 9c			call macro_forth_dsp_pop 
a04d				endm 
# End of macro FORTH_DSP_POP
a04d			 
a04d 29				add hl, hl 
a04e cd cc 99			call forth_push_numhl 
a051				NEXTW 
a051 cd 68 ee			call parse_vector 
a054 c3 af 9d			jp macro_next 
a057				endm 
# End of macro NEXTW
a057			.RSHIFT: 
a057			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
a057 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a058 91 a0			dw .SWAP            
a05a 07				db 6 + 1 
a05b .. 00			db "RSHIFT",0              
a062				endm 
# End of macro CWHEAD
a062			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
a062				if DEBUG_FORTH_WORDS_KEY 
a062					DMARK "RSH" 
a062 f5				push af  
a063 3a 77 a0			ld a, (.dmark)  
a066 32 5e ee			ld (debug_mark),a  
a069 3a 78 a0			ld a, (.dmark+1)  
a06c 32 5f ee			ld (debug_mark+1),a  
a06f 3a 79 a0			ld a, (.dmark+2)  
a072 32 60 ee			ld (debug_mark+2),a  
a075 18 03			jr .pastdmark  
a077 ..			.dmark: db "RSH"  
a07a f1			.pastdmark: pop af  
a07b			endm  
# End of macro DMARK
a07b					CALLMONITOR 
a07b cd 6b ee			call debug_vector  
a07e				endm  
# End of macro CALLMONITOR
a07e				endif 
a07e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a07e cd c8 9b			call macro_dsp_valuehl 
a081				endm 
# End of macro FORTH_DSP_VALUEHL
a081				FORTH_DSP_POP 
a081 cd 80 9c			call macro_forth_dsp_pop 
a084				endm 
# End of macro FORTH_DSP_POP
a084 cb 3c			srl h 
a086 cb 1d			rr l 
a088 cd cc 99			call forth_push_numhl 
a08b				NEXTW 
a08b cd 68 ee			call parse_vector 
a08e c3 af 9d			jp macro_next 
a091				endm 
# End of macro NEXTW
a091			.SWAP: 
a091			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a091 18				db WORD_SYS_CORE+OPCODE_SWAP             
a092 e8 a0			dw .COLN            
a094 05				db 4 + 1 
a095 .. 00			db "SWAP",0              
a09a				endm 
# End of macro CWHEAD
a09a			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a09a				if DEBUG_FORTH_WORDS_KEY 
a09a					DMARK "SWP" 
a09a f5				push af  
a09b 3a af a0			ld a, (.dmark)  
a09e 32 5e ee			ld (debug_mark),a  
a0a1 3a b0 a0			ld a, (.dmark+1)  
a0a4 32 5f ee			ld (debug_mark+1),a  
a0a7 3a b1 a0			ld a, (.dmark+2)  
a0aa 32 60 ee			ld (debug_mark+2),a  
a0ad 18 03			jr .pastdmark  
a0af ..			.dmark: db "SWP"  
a0b2 f1			.pastdmark: pop af  
a0b3			endm  
# End of macro DMARK
a0b3					CALLMONITOR 
a0b3 cd 6b ee			call debug_vector  
a0b6				endm  
# End of macro CALLMONITOR
a0b6				endif 
a0b6			 
a0b6			; DONE Use os stack swap memory 
a0b6			 
a0b6				FORTH_DSP_PTR 0     ; TOS 
a0b6 2a e1 e9			ld hl,(cli_data_sp) 
a0b9 11 00 00			ld de, 0 * 3 
a0bc ed 52			sbc hl, de 
a0be				endm 
# End of macro FORTH_DSP_PTR
a0be cd ff 9c			call hltostack1 
a0c1			  
a0c1				FORTH_DSP_PTR 1     ; TOS 
a0c1 2a e1 e9			ld hl,(cli_data_sp) 
a0c4 11 03 00			ld de, 1 * 3 
a0c7 ed 52			sbc hl, de 
a0c9				endm 
# End of macro FORTH_DSP_PTR
a0c9 cd 05 9d			call hltostack2 
a0cc			 
a0cc				FORTH_DSP_PTR 0     ; TOS 
a0cc 2a e1 e9			ld hl,(cli_data_sp) 
a0cf 11 00 00			ld de, 0 * 3 
a0d2 ed 52			sbc hl, de 
a0d4				endm 
# End of macro FORTH_DSP_PTR
a0d4 cd 1d 9d			call hlfromstack2 
a0d7			 
a0d7				FORTH_DSP_PTR 1     ; TOS 
a0d7 2a e1 e9			ld hl,(cli_data_sp) 
a0da 11 03 00			ld de, 1 * 3 
a0dd ed 52			sbc hl, de 
a0df				endm 
# End of macro FORTH_DSP_PTR
a0df cd 17 9d			call hlfromstack1 
a0e2			;	FORTH_DSP_VALUEHL 
a0e2			;	push hl     ; w2 
a0e2			; 
a0e2			;	FORTH_DSP_POP 
a0e2			; 
a0e2			;	FORTH_DSP_VALUEHL 
a0e2			; 
a0e2			;	FORTH_DSP_POP 
a0e2			; 
a0e2			;	pop de     ; w2	, hl = w1 
a0e2			; 
a0e2			;	ex de, hl 
a0e2			;	push de 
a0e2			; 
a0e2			;	call forth_push_numhl 
a0e2			; 
a0e2			;	pop hl 
a0e2			; 
a0e2			;	call forth_push_numhl 
a0e2				 
a0e2			 
a0e2				NEXTW 
a0e2 cd 68 ee			call parse_vector 
a0e5 c3 af 9d			jp macro_next 
a0e8				endm 
# End of macro NEXTW
a0e8			.COLN: 
a0e8			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0e8 19				db WORD_SYS_CORE+OPCODE_COLN             
a0e9 73 a2			dw .SCOLN            
a0eb 02				db 1 + 1 
a0ec .. 00			db ":",0              
a0ee				endm 
# End of macro CWHEAD
a0ee			; | : ( -- )         Create new word | DONE 
a0ee			 
a0ee				if DEBUG_FORTH_WORDS_KEY 
a0ee					DMARK "CLN" 
a0ee f5				push af  
a0ef 3a 03 a1			ld a, (.dmark)  
a0f2 32 5e ee			ld (debug_mark),a  
a0f5 3a 04 a1			ld a, (.dmark+1)  
a0f8 32 5f ee			ld (debug_mark+1),a  
a0fb 3a 05 a1			ld a, (.dmark+2)  
a0fe 32 60 ee			ld (debug_mark+2),a  
a101 18 03			jr .pastdmark  
a103 ..			.dmark: db "CLN"  
a106 f1			.pastdmark: pop af  
a107			endm  
# End of macro DMARK
a107					CALLMONITOR 
a107 cd 6b ee			call debug_vector  
a10a				endm  
# End of macro CALLMONITOR
a10a				endif 
a10a			STACKFRAME OFF $8efe $989f 
a10a				if DEBUG_STACK_IMB 
a10a					if OFF 
a10a						exx 
a10a						ld de, $8efe 
a10a						ld a, d 
a10a						ld hl, curframe 
a10a						call hexout 
a10a						ld a, e 
a10a						ld hl, curframe+2 
a10a						call hexout 
a10a						ld hl, $8efe 
a10a						push hl 
a10a						ld hl, $989f 
a10a						push hl 
a10a						exx 
a10a					endif 
a10a				endif 
a10a			endm 
# End of macro STACKFRAME
a10a			; get parser buffer length  of new word 
a10a			 
a10a			 
a10a			 
a10a				; move tok past this to start of name defintition 
a10a				; TODO get word to define 
a10a				; TODO Move past word token 
a10a				; TODO get length of string up to the ';' 
a10a			 
a10a 2a b5 e5		ld hl, (os_tok_ptr) 
a10d 23			inc hl 
a10e 23			inc hl 
a10f			 
a10f 3e 3b		ld a, ';' 
a111 cd 3e 90		call strlent 
a114			 
a114 7d			ld a,l 
a115 32 a4 e2		ld (os_new_parse_len), a 
a118			 
a118			 
a118			if DEBUG_FORTH_UWORD 
a118 ed 5b b5 e5	ld de, (os_tok_ptr) 
a11c					DMARK ":01" 
a11c f5				push af  
a11d 3a 31 a1			ld a, (.dmark)  
a120 32 5e ee			ld (debug_mark),a  
a123 3a 32 a1			ld a, (.dmark+1)  
a126 32 5f ee			ld (debug_mark+1),a  
a129 3a 33 a1			ld a, (.dmark+2)  
a12c 32 60 ee			ld (debug_mark+2),a  
a12f 18 03			jr .pastdmark  
a131 ..			.dmark: db ":01"  
a134 f1			.pastdmark: pop af  
a135			endm  
# End of macro DMARK
a135			CALLMONITOR 
a135 cd 6b ee			call debug_vector  
a138				endm  
# End of macro CALLMONITOR
a138			endif 
a138			 
a138			; 
a138			;  new word memory layout: 
a138			;  
a138			;    : adg 6666 ;  
a138			; 
a138			;    db   1     ; user defined word  
a138 23			inc hl    
a139			;    dw   sysdict 
a139 23			inc hl 
a13a 23			inc hl 
a13b			;    db <word len>+1 (for null) 
a13b 23			inc hl 
a13c			;    db .... <word> 
a13c			; 
a13c			 
a13c 23			inc hl    ; some extras for the word preamble before the above 
a13d 23			inc hl 
a13e 23			inc hl 
a13f 23			inc hl 
a140 23			inc hl 
a141 23			inc hl 
a142 23			inc hl  
a143 23			inc hl 
a144 23			inc hl 
a145 23			inc hl 
a146 23			inc hl 
a147 23			inc hl 
a148 23			inc hl 
a149 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a14a			;       exec word buffer 
a14a			;	<ptr word>   
a14a 23			inc hl 
a14b 23			inc hl 
a14c			;       <word list><null term> 7F final term 
a14c			 
a14c			 
a14c			if DEBUG_FORTH_UWORD 
a14c					DMARK ":02" 
a14c f5				push af  
a14d 3a 61 a1			ld a, (.dmark)  
a150 32 5e ee			ld (debug_mark),a  
a153 3a 62 a1			ld a, (.dmark+1)  
a156 32 5f ee			ld (debug_mark+1),a  
a159 3a 63 a1			ld a, (.dmark+2)  
a15c 32 60 ee			ld (debug_mark+2),a  
a15f 18 03			jr .pastdmark  
a161 ..			.dmark: db ":02"  
a164 f1			.pastdmark: pop af  
a165			endm  
# End of macro DMARK
a165			CALLMONITOR 
a165 cd 6b ee			call debug_vector  
a168				endm  
# End of macro CALLMONITOR
a168			endif 
a168			 
a168			 
a168				; malloc the size 
a168			 
a168 cd a7 90			call malloc 
a16b 22 a6 e2			ld (os_new_malloc), hl     ; save malloc start 
a16e			 
a16e			;    db   1     ; user defined word  
a16e			;	ld a, WORD_SYS_UWORD  
a16e 36 01			ld (hl), WORD_SYS_UWORD 
a170			 
a170 23			inc hl    
a171			;    dw   sysdict 
a171 11 e8 9e		ld de, sysdict       ; continue on with the scan to the system dict 
a174 73			ld (hl), e 
a175 23			inc hl 
a176 72			ld (hl), d 
a177 23			inc hl 
a178			 
a178			 
a178			;    Setup dict word 
a178			 
a178 23			inc hl 
a179 22 a0 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a17c			 
a17c			; 1. get length of dict word 
a17c			 
a17c			 
a17c 2a b5 e5		ld hl, (os_tok_ptr) 
a17f 23			inc hl 
a180 23			inc hl    ; position to start of dict word 
a181 3e 00		ld a, 0 
a183 cd 3e 90		call strlent 
a186			 
a186			 
a186 23			inc hl    ; to include null??? 
a187			 
a187			; write length of dict word 
a187			 
a187 ed 5b a0 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a18b 1b			dec de 
a18c eb			ex de, hl 
a18d 73			ld (hl), e 
a18e eb			ex de, hl 
a18f			 
a18f			 
a18f			 
a18f			; copy  
a18f 4d			ld c, l 
a190 06 00		ld b, 0 
a192 ed 5b a0 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a196 2a b5 e5		ld hl, (os_tok_ptr) 
a199 23			inc hl 
a19a 23			inc hl    ; position to start of dict word 
a19b			 
a19b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a19b			 
a19b			; TODO need to convert word to upper case 
a19b			 
a19b			ucasetok:	 
a19b 7e			ld a,(hl) 
a19c cd 2a 90		call toUpper 
a19f 77			ld (hl),a 
a1a0 ed a0		ldi 
a1a2 f2 9b a1		jp p, ucasetok 
a1a5			 
a1a5			 
a1a5			 
a1a5			; de now points to start of where the word body code should be placed 
a1a5 ed 53 a0 e2	ld (os_new_work_ptr), de 
a1a9			; hl now points to the words to throw at forthexec which needs to be copied 
a1a9 22 9e e2		ld (os_new_src_ptr), hl 
a1ac			 
a1ac			; TODO add 'call to forthexec' 
a1ac			 
a1ac			if DEBUG_FORTH_UWORD 
a1ac c5			push bc 
a1ad ed 4b a6 e2	ld bc, (os_new_malloc) 
a1b1					DMARK ":0x" 
a1b1 f5				push af  
a1b2 3a c6 a1			ld a, (.dmark)  
a1b5 32 5e ee			ld (debug_mark),a  
a1b8 3a c7 a1			ld a, (.dmark+1)  
a1bb 32 5f ee			ld (debug_mark+1),a  
a1be 3a c8 a1			ld a, (.dmark+2)  
a1c1 32 60 ee			ld (debug_mark+2),a  
a1c4 18 03			jr .pastdmark  
a1c6 ..			.dmark: db ":0x"  
a1c9 f1			.pastdmark: pop af  
a1ca			endm  
# End of macro DMARK
a1ca			CALLMONITOR 
a1ca cd 6b ee			call debug_vector  
a1cd				endm  
# End of macro CALLMONITOR
a1cd c1			pop bc 
a1ce			endif 
a1ce			 
a1ce			 
a1ce			; create word preamble which should be: 
a1ce			 
a1ce			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1ce			 
a1ce			;    ld hl, <word code> 
a1ce			;    jp user_exec 
a1ce			;    <word code bytes> 
a1ce			 
a1ce			 
a1ce			;	inc de     ; TODO ??? or are we already past the word's null 
a1ce eb			ex de, hl 
a1cf			 
a1cf 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1d1			 
a1d1 23			inc hl 
a1d2 22 9a e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1d5 23			inc hl 
a1d6			 
a1d6 23			inc hl 
a1d7 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1d9			 
a1d9 01 77 d2		ld bc, user_exec 
a1dc 23			inc hl 
a1dd 71			ld (hl), c     ; poke address of user_exec 
a1de 23			inc hl 
a1df 70			ld (hl), b     
a1e0			; 
a1e0			;	inc hl 
a1e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1e0			; 
a1e0			; 
a1e0			;	ld bc, macro_forth_rsp_next 
a1e0			;	inc hl 
a1e0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1e0			;	inc hl 
a1e0			;	ld (hl), b     
a1e0			; 
a1e0			;	inc hl 
a1e0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1e0			; 
a1e0			; 
a1e0			;	inc hl 
a1e0			;	ld bc, forthexec 
a1e0			;	ld (hl), c     ; poke address of forthexec 
a1e0			;	inc hl 
a1e0			;	ld (hl), b      
a1e0			; 
a1e0			;	inc hl 
a1e0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1e0			; 
a1e0			;	ld bc, user_dict_next 
a1e0			;	inc hl 
a1e0			;	ld (hl), c     ; poke address of forthexec 
a1e0			;	inc hl 
a1e0			;	ld (hl), b      
a1e0			 
a1e0			; hl is now where we need to copy the word byte data to save this 
a1e0			 
a1e0 23			inc hl 
a1e1 22 9c e2		ld (os_new_exec), hl 
a1e4			 
a1e4			; copy definition 
a1e4			 
a1e4 eb			ex de, hl 
a1e5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1e5			;	inc de    ; skip the PC for this parse 
a1e5 3a a4 e2		ld a, (os_new_parse_len) 
a1e8 4f			ld c, a 
a1e9 06 00		ld b, 0 
a1eb ed b0		ldir		 ; copy defintion 
a1ed			 
a1ed			 
a1ed			; poke the address of where the new word bytes live for forthexec 
a1ed			 
a1ed 2a 9a e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1f0			 
a1f0 ed 5b 9c e2	ld de, (os_new_exec)      
a1f4			 
a1f4 73			ld (hl), e 
a1f5 23			inc hl 
a1f6 72			ld (hl), d 
a1f7			 
a1f7				; TODO copy last user dict word next link to this word 
a1f7				; TODO update last user dict word to point to this word 
a1f7			; 
a1f7			; hl f923 de 812a ; bc 811a 
a1f7			 
a1f7			if DEBUG_FORTH_UWORD 
a1f7 c5			push bc 
a1f8 ed 4b a6 e2	ld bc, (os_new_malloc) 
a1fc					DMARK ":0A" 
a1fc f5				push af  
a1fd 3a 11 a2			ld a, (.dmark)  
a200 32 5e ee			ld (debug_mark),a  
a203 3a 12 a2			ld a, (.dmark+1)  
a206 32 5f ee			ld (debug_mark+1),a  
a209 3a 13 a2			ld a, (.dmark+2)  
a20c 32 60 ee			ld (debug_mark+2),a  
a20f 18 03			jr .pastdmark  
a211 ..			.dmark: db ":0A"  
a214 f1			.pastdmark: pop af  
a215			endm  
# End of macro DMARK
a215			CALLMONITOR 
a215 cd 6b ee			call debug_vector  
a218				endm  
# End of macro CALLMONITOR
a218 c1			pop bc 
a219			endif 
a219			if DEBUG_FORTH_UWORD 
a219 c5			push bc 
a21a ed 4b a6 e2	ld bc, (os_new_malloc) 
a21e 03			inc bc 
a21f 03			inc bc 
a220 03			inc bc 
a221 03			inc bc 
a222 03			inc bc 
a223 03			inc bc 
a224 03			inc bc 
a225 03			inc bc 
a226			 
a226					DMARK ":0B" 
a226 f5				push af  
a227 3a 3b a2			ld a, (.dmark)  
a22a 32 5e ee			ld (debug_mark),a  
a22d 3a 3c a2			ld a, (.dmark+1)  
a230 32 5f ee			ld (debug_mark+1),a  
a233 3a 3d a2			ld a, (.dmark+2)  
a236 32 60 ee			ld (debug_mark+2),a  
a239 18 03			jr .pastdmark  
a23b ..			.dmark: db ":0B"  
a23e f1			.pastdmark: pop af  
a23f			endm  
# End of macro DMARK
a23f			CALLMONITOR 
a23f cd 6b ee			call debug_vector  
a242				endm  
# End of macro CALLMONITOR
a242 c1			pop bc 
a243			endif 
a243			 
a243			; update word dict linked list for new word 
a243			 
a243			 
a243 2a b1 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a246 23			inc hl     ; move to next work linked list ptr 
a247			 
a247 ed 5b a6 e2	ld de, (os_new_malloc)		 ; new next word 
a24b 73			ld (hl), e 
a24c 23			inc hl 
a24d 72			ld (hl), d 
a24e			 
a24e			if DEBUG_FORTH_UWORD 
a24e ed 4b b1 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a252			endif 
a252			 
a252 ed 53 b1 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a256			 
a256			 
a256			if DEBUG_FORTH_UWORD 
a256					DMARK ":0+" 
a256 f5				push af  
a257 3a 6b a2			ld a, (.dmark)  
a25a 32 5e ee			ld (debug_mark),a  
a25d 3a 6c a2			ld a, (.dmark+1)  
a260 32 5f ee			ld (debug_mark+1),a  
a263 3a 6d a2			ld a, (.dmark+2)  
a266 32 60 ee			ld (debug_mark+2),a  
a269 18 03			jr .pastdmark  
a26b ..			.dmark: db ":0+"  
a26e f1			.pastdmark: pop af  
a26f			endm  
# End of macro DMARK
a26f			CALLMONITOR 
a26f cd 6b ee			call debug_vector  
a272				endm  
# End of macro CALLMONITOR
a272			endif 
a272			 
a272			STACKFRAMECHK OFF $8efe $989f 
a272				if DEBUG_STACK_IMB 
a272					if OFF 
a272						exx 
a272						ld hl, $989f 
a272						pop de   ; $989f 
a272						call cmp16 
a272						jr nz, .spnosame 
a272						ld hl, $8efe 
a272						pop de   ; $8efe 
a272						call cmp16 
a272						jr z, .spfrsame 
a272						.spnosame: call showsperror 
a272						.spfrsame: nop 
a272						exx 
a272					endif 
a272				endif 
a272			endm 
# End of macro STACKFRAMECHK
a272			 
a272 c9			ret    ; dont process any remaining parser tokens as they form new word 
a273			 
a273			 
a273			 
a273			 
a273			;		NEXT 
a273			.SCOLN: 
a273			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a273 06			db OPCODE_SCOLN 
a274 c2 a2		dw .DROP 
a276 02			db 2 
a277 .. 00		db ";",0           
a279			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a279				if DEBUG_FORTH_WORDS_KEY 
a279					DMARK "SCN" 
a279 f5				push af  
a27a 3a 8e a2			ld a, (.dmark)  
a27d 32 5e ee			ld (debug_mark),a  
a280 3a 8f a2			ld a, (.dmark+1)  
a283 32 5f ee			ld (debug_mark+1),a  
a286 3a 90 a2			ld a, (.dmark+2)  
a289 32 60 ee			ld (debug_mark+2),a  
a28c 18 03			jr .pastdmark  
a28e ..			.dmark: db "SCN"  
a291 f1			.pastdmark: pop af  
a292			endm  
# End of macro DMARK
a292					CALLMONITOR 
a292 cd 6b ee			call debug_vector  
a295				endm  
# End of macro CALLMONITOR
a295				endif 
a295				FORTH_RSP_TOS 
a295 cd 8a 99			call macro_forth_rsp_tos 
a298				endm 
# End of macro FORTH_RSP_TOS
a298 e5				push hl 
a299				FORTH_RSP_POP 
a299 cd 94 99			call macro_forth_rsp_pop 
a29c				endm 
# End of macro FORTH_RSP_POP
a29c e1				pop hl 
a29d			;		ex de,hl 
a29d 22 b5 e5			ld (os_tok_ptr),hl 
a2a0			 
a2a0			if DEBUG_FORTH_UWORD 
a2a0					DMARK "SCL" 
a2a0 f5				push af  
a2a1 3a b5 a2			ld a, (.dmark)  
a2a4 32 5e ee			ld (debug_mark),a  
a2a7 3a b6 a2			ld a, (.dmark+1)  
a2aa 32 5f ee			ld (debug_mark+1),a  
a2ad 3a b7 a2			ld a, (.dmark+2)  
a2b0 32 60 ee			ld (debug_mark+2),a  
a2b3 18 03			jr .pastdmark  
a2b5 ..			.dmark: db "SCL"  
a2b8 f1			.pastdmark: pop af  
a2b9			endm  
# End of macro DMARK
a2b9			CALLMONITOR 
a2b9 cd 6b ee			call debug_vector  
a2bc				endm  
# End of macro CALLMONITOR
a2bc			endif 
a2bc				NEXTW 
a2bc cd 68 ee			call parse_vector 
a2bf c3 af 9d			jp macro_next 
a2c2				endm 
# End of macro NEXTW
a2c2			 
a2c2			.DROP: 
a2c2			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2c2 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2c3 f0 a2			dw .DUP2            
a2c5 05				db 4 + 1 
a2c6 .. 00			db "DROP",0              
a2cb				endm 
# End of macro CWHEAD
a2cb			; | DROP ( w -- )   drop the TOS item   | DONE 
a2cb				if DEBUG_FORTH_WORDS_KEY 
a2cb					DMARK "DRP" 
a2cb f5				push af  
a2cc 3a e0 a2			ld a, (.dmark)  
a2cf 32 5e ee			ld (debug_mark),a  
a2d2 3a e1 a2			ld a, (.dmark+1)  
a2d5 32 5f ee			ld (debug_mark+1),a  
a2d8 3a e2 a2			ld a, (.dmark+2)  
a2db 32 60 ee			ld (debug_mark+2),a  
a2de 18 03			jr .pastdmark  
a2e0 ..			.dmark: db "DRP"  
a2e3 f1			.pastdmark: pop af  
a2e4			endm  
# End of macro DMARK
a2e4					CALLMONITOR 
a2e4 cd 6b ee			call debug_vector  
a2e7				endm  
# End of macro CALLMONITOR
a2e7				endif 
a2e7				FORTH_DSP_POP 
a2e7 cd 80 9c			call macro_forth_dsp_pop 
a2ea				endm 
# End of macro FORTH_DSP_POP
a2ea				NEXTW 
a2ea cd 68 ee			call parse_vector 
a2ed c3 af 9d			jp macro_next 
a2f0				endm 
# End of macro NEXTW
a2f0			.DUP2: 
a2f0			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2f0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2f1 38 a3			dw .DROP2            
a2f3 05				db 4 + 1 
a2f4 .. 00			db "2DUP",0              
a2f9				endm 
# End of macro CWHEAD
a2f9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
a2f9			; | | >[!NOTE] 
a2f9			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
a2f9				if DEBUG_FORTH_WORDS_KEY 
a2f9					DMARK "2DU" 
a2f9 f5				push af  
a2fa 3a 0e a3			ld a, (.dmark)  
a2fd 32 5e ee			ld (debug_mark),a  
a300 3a 0f a3			ld a, (.dmark+1)  
a303 32 5f ee			ld (debug_mark+1),a  
a306 3a 10 a3			ld a, (.dmark+2)  
a309 32 60 ee			ld (debug_mark+2),a  
a30c 18 03			jr .pastdmark  
a30e ..			.dmark: db "2DU"  
a311 f1			.pastdmark: pop af  
a312			endm  
# End of macro DMARK
a312					CALLMONITOR 
a312 cd 6b ee			call debug_vector  
a315				endm  
# End of macro CALLMONITOR
a315				endif 
a315				FORTH_DSP_VALUEHL 
a315 cd c8 9b			call macro_dsp_valuehl 
a318				endm 
# End of macro FORTH_DSP_VALUEHL
a318 e5				push hl      ; 2 
a319			 
a319				FORTH_DSP_POP 
a319 cd 80 9c			call macro_forth_dsp_pop 
a31c				endm 
# End of macro FORTH_DSP_POP
a31c				 
a31c				FORTH_DSP_VALUEHL 
a31c cd c8 9b			call macro_dsp_valuehl 
a31f				endm 
# End of macro FORTH_DSP_VALUEHL
a31f			;		push hl      ; 1 
a31f			 
a31f				FORTH_DSP_POP 
a31f cd 80 9c			call macro_forth_dsp_pop 
a322				endm 
# End of macro FORTH_DSP_POP
a322			 
a322			;		pop hl       ; 1 
a322 d1				pop de       ; 2 
a323			 
a323 cd cc 99			call forth_push_numhl 
a326 eb				ex de, hl 
a327 cd cc 99			call forth_push_numhl 
a32a			 
a32a				 
a32a eb				ex de, hl 
a32b			 
a32b cd cc 99			call forth_push_numhl 
a32e eb				ex de, hl 
a32f cd cc 99			call forth_push_numhl 
a332			 
a332			 
a332				NEXTW 
a332 cd 68 ee			call parse_vector 
a335 c3 af 9d			jp macro_next 
a338				endm 
# End of macro NEXTW
a338			.DROP2: 
a338			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a338 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a339 6a a3			dw .PICK            
a33b 06				db 5 + 1 
a33c .. 00			db "2DROP",0              
a342				endm 
# End of macro CWHEAD
a342			; | 2DROP ( w w -- )    Double drop | DONE 
a342				if DEBUG_FORTH_WORDS_KEY 
a342					DMARK "2DR" 
a342 f5				push af  
a343 3a 57 a3			ld a, (.dmark)  
a346 32 5e ee			ld (debug_mark),a  
a349 3a 58 a3			ld a, (.dmark+1)  
a34c 32 5f ee			ld (debug_mark+1),a  
a34f 3a 59 a3			ld a, (.dmark+2)  
a352 32 60 ee			ld (debug_mark+2),a  
a355 18 03			jr .pastdmark  
a357 ..			.dmark: db "2DR"  
a35a f1			.pastdmark: pop af  
a35b			endm  
# End of macro DMARK
a35b					CALLMONITOR 
a35b cd 6b ee			call debug_vector  
a35e				endm  
# End of macro CALLMONITOR
a35e				endif 
a35e				FORTH_DSP_POP 
a35e cd 80 9c			call macro_forth_dsp_pop 
a361				endm 
# End of macro FORTH_DSP_POP
a361				FORTH_DSP_POP 
a361 cd 80 9c			call macro_forth_dsp_pop 
a364				endm 
# End of macro FORTH_DSP_POP
a364				NEXTW 
a364 cd 68 ee			call parse_vector 
a367 c3 af 9d			jp macro_next 
a36a				endm 
# End of macro NEXTW
a36a			.PICK: 
a36a			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
a36a 77				db WORD_SYS_CORE+99             
a36b 07 a4			dw .SWAP2            
a36d 05				db 4 + 1 
a36e .. 00			db "PICK",0              
a373				endm 
# End of macro CWHEAD
a373			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
a373			; | | >[!NOTE] 
a373			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
a373				if DEBUG_FORTH_WORDS_KEY 
a373					DMARK "PIK" 
a373 f5				push af  
a374 3a 88 a3			ld a, (.dmark)  
a377 32 5e ee			ld (debug_mark),a  
a37a 3a 89 a3			ld a, (.dmark+1)  
a37d 32 5f ee			ld (debug_mark+1),a  
a380 3a 8a a3			ld a, (.dmark+2)  
a383 32 60 ee			ld (debug_mark+2),a  
a386 18 03			jr .pastdmark  
a388 ..			.dmark: db "PIK"  
a38b f1			.pastdmark: pop af  
a38c			endm  
# End of macro DMARK
a38c					CALLMONITOR 
a38c cd 6b ee			call debug_vector  
a38f				endm  
# End of macro CALLMONITOR
a38f				endif 
a38f			 
a38f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a38f cd c8 9b			call macro_dsp_valuehl 
a392				endm 
# End of macro FORTH_DSP_VALUEHL
a392				 
a392				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a392 cd 80 9c			call macro_forth_dsp_pop 
a395				endm 
# End of macro FORTH_DSP_POP
a395			 
a395				; init from TOS 
a395 e5				push hl 
a396				FORTH_DSP 
a396 cd 8e 9b			call macro_forth_dsp 
a399				endm 
# End of macro FORTH_DSP
a399			;	ld hl, cli_data_sp 
a399				if DEBUG_FORTH_WORDS 
a399					DMARK "PK1" 
a399 f5				push af  
a39a 3a ae a3			ld a, (.dmark)  
a39d 32 5e ee			ld (debug_mark),a  
a3a0 3a af a3			ld a, (.dmark+1)  
a3a3 32 5f ee			ld (debug_mark+1),a  
a3a6 3a b0 a3			ld a, (.dmark+2)  
a3a9 32 60 ee			ld (debug_mark+2),a  
a3ac 18 03			jr .pastdmark  
a3ae ..			.dmark: db "PK1"  
a3b1 f1			.pastdmark: pop af  
a3b2			endm  
# End of macro DMARK
a3b2					CALLMONITOR 
a3b2 cd 6b ee			call debug_vector  
a3b5				endm  
# End of macro CALLMONITOR
a3b5				endif 
a3b5 c1				pop bc 
a3b6 41				ld b,c 
a3b7 3e 00			ld a, 0 
a3b9 b8				cp b 
a3ba 28 21			jr z, .pdone	 
a3bc			.pkl: 
a3bc 2b				dec hl 
a3bd 2b				dec hl 
a3be 2b				dec hl 
a3bf			 
a3bf				if DEBUG_FORTH_WORDS 
a3bf					DMARK "PKl" 
a3bf f5				push af  
a3c0 3a d4 a3			ld a, (.dmark)  
a3c3 32 5e ee			ld (debug_mark),a  
a3c6 3a d5 a3			ld a, (.dmark+1)  
a3c9 32 5f ee			ld (debug_mark+1),a  
a3cc 3a d6 a3			ld a, (.dmark+2)  
a3cf 32 60 ee			ld (debug_mark+2),a  
a3d2 18 03			jr .pastdmark  
a3d4 ..			.dmark: db "PKl"  
a3d7 f1			.pastdmark: pop af  
a3d8			endm  
# End of macro DMARK
a3d8					CALLMONITOR 
a3d8 cd 6b ee			call debug_vector  
a3db				endm  
# End of macro CALLMONITOR
a3db				endif 
a3db 10 df			djnz .pkl 
a3dd			.pdone: 
a3dd				 
a3dd				; TODO do type check with correct push 
a3dd			 
a3dd 23				inc hl 
a3de				;call loadwordinhl 
a3de 5e				ld e, (hl) 
a3df 23				inc hl 
a3e0 56				ld d, (hl) 
a3e1 eb				ex de,hl 
a3e2				if DEBUG_FORTH_WORDS 
a3e2					DMARK "PKp" 
a3e2 f5				push af  
a3e3 3a f7 a3			ld a, (.dmark)  
a3e6 32 5e ee			ld (debug_mark),a  
a3e9 3a f8 a3			ld a, (.dmark+1)  
a3ec 32 5f ee			ld (debug_mark+1),a  
a3ef 3a f9 a3			ld a, (.dmark+2)  
a3f2 32 60 ee			ld (debug_mark+2),a  
a3f5 18 03			jr .pastdmark  
a3f7 ..			.dmark: db "PKp"  
a3fa f1			.pastdmark: pop af  
a3fb			endm  
# End of macro DMARK
a3fb					CALLMONITOR 
a3fb cd 6b ee			call debug_vector  
a3fe				endm  
# End of macro CALLMONITOR
a3fe				endif 
a3fe cd cc 99			call forth_push_numhl 
a401			 
a401				NEXTW 
a401 cd 68 ee			call parse_vector 
a404 c3 af 9d			jp macro_next 
a407				endm 
# End of macro NEXTW
a407			.SWAP2: 
a407			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a407 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a408 8b a4			dw .AT            
a40a 06				db 5 + 1 
a40b .. 00			db "2SWAP",0              
a411				endm 
# End of macro CWHEAD
a411			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
a411				if DEBUG_FORTH_WORDS_KEY 
a411					DMARK "2SW" 
a411 f5				push af  
a412 3a 26 a4			ld a, (.dmark)  
a415 32 5e ee			ld (debug_mark),a  
a418 3a 27 a4			ld a, (.dmark+1)  
a41b 32 5f ee			ld (debug_mark+1),a  
a41e 3a 28 a4			ld a, (.dmark+2)  
a421 32 60 ee			ld (debug_mark+2),a  
a424 18 03			jr .pastdmark  
a426 ..			.dmark: db "2SW"  
a429 f1			.pastdmark: pop af  
a42a			endm  
# End of macro DMARK
a42a					CALLMONITOR 
a42a cd 6b ee			call debug_vector  
a42d				endm  
# End of macro CALLMONITOR
a42d				endif 
a42d			; TODO Use os stack swap memory 
a42d			 
a42d				FORTH_DSP_PTR 0     ; TOS    w4 
a42d 2a e1 e9			ld hl,(cli_data_sp) 
a430 11 00 00			ld de, 0 * 3 
a433 ed 52			sbc hl, de 
a435				endm 
# End of macro FORTH_DSP_PTR
a435 cd ff 9c			call hltostack1 
a438			  
a438				FORTH_DSP_PTR 1     ; TOS    w3 
a438 2a e1 e9			ld hl,(cli_data_sp) 
a43b 11 03 00			ld de, 1 * 3 
a43e ed 52			sbc hl, de 
a440				endm 
# End of macro FORTH_DSP_PTR
a440 cd 05 9d			call hltostack2 
a443			 
a443			 
a443			 
a443				FORTH_DSP_PTR 2     ; TOS    w2 
a443 2a e1 e9			ld hl,(cli_data_sp) 
a446 11 06 00			ld de, 2 * 3 
a449 ed 52			sbc hl, de 
a44b				endm 
# End of macro FORTH_DSP_PTR
a44b cd 0b 9d			call hltostack3 
a44e			 
a44e				FORTH_DSP_PTR 3     ; TOS   w1 
a44e 2a e1 e9			ld hl,(cli_data_sp) 
a451 11 09 00			ld de, 3 * 3 
a454 ed 52			sbc hl, de 
a456				endm 
# End of macro FORTH_DSP_PTR
a456 cd 11 9d			call hltostack4 
a459			 
a459			 
a459			 
a459			 
a459				FORTH_DSP_PTR 0     ; TOS 
a459 2a e1 e9			ld hl,(cli_data_sp) 
a45c 11 00 00			ld de, 0 * 3 
a45f ed 52			sbc hl, de 
a461				endm 
# End of macro FORTH_DSP_PTR
a461 cd 23 9d			call hlfromstack3 
a464			 
a464				FORTH_DSP_PTR 1     ; TOS 
a464 2a e1 e9			ld hl,(cli_data_sp) 
a467 11 03 00			ld de, 1 * 3 
a46a ed 52			sbc hl, de 
a46c				endm 
# End of macro FORTH_DSP_PTR
a46c cd 29 9d			call hlfromstack4 
a46f			 
a46f			 
a46f			 
a46f				FORTH_DSP_PTR 2     ; TOS 
a46f 2a e1 e9			ld hl,(cli_data_sp) 
a472 11 06 00			ld de, 2 * 3 
a475 ed 52			sbc hl, de 
a477				endm 
# End of macro FORTH_DSP_PTR
a477 cd 17 9d			call hlfromstack1 
a47a			 
a47a				FORTH_DSP_PTR 3     ; TOS 
a47a 2a e1 e9			ld hl,(cli_data_sp) 
a47d 11 09 00			ld de, 3 * 3 
a480 ed 52			sbc hl, de 
a482				endm 
# End of macro FORTH_DSP_PTR
a482 cd 1d 9d			call hlfromstack2 
a485			 
a485				NEXTW 
a485 cd 68 ee			call parse_vector 
a488 c3 af 9d			jp macro_next 
a48b				endm 
# End of macro NEXTW
a48b			.AT: 
a48b			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a48b 1f				db WORD_SYS_CORE+OPCODE_AT             
a48c c0 a4			dw .CAT            
a48e 02				db 1 + 1 
a48f .. 00			db "@",0              
a491				endm 
# End of macro CWHEAD
a491			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a491			 
a491				if DEBUG_FORTH_WORDS_KEY 
a491					DMARK "AT." 
a491 f5				push af  
a492 3a a6 a4			ld a, (.dmark)  
a495 32 5e ee			ld (debug_mark),a  
a498 3a a7 a4			ld a, (.dmark+1)  
a49b 32 5f ee			ld (debug_mark+1),a  
a49e 3a a8 a4			ld a, (.dmark+2)  
a4a1 32 60 ee			ld (debug_mark+2),a  
a4a4 18 03			jr .pastdmark  
a4a6 ..			.dmark: db "AT."  
a4a9 f1			.pastdmark: pop af  
a4aa			endm  
# End of macro DMARK
a4aa					CALLMONITOR 
a4aa cd 6b ee			call debug_vector  
a4ad				endm  
# End of macro CALLMONITOR
a4ad				endif 
a4ad			.getbyteat:	 
a4ad				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4ad cd c8 9b			call macro_dsp_valuehl 
a4b0				endm 
# End of macro FORTH_DSP_VALUEHL
a4b0				 
a4b0			;		push hl 
a4b0			 
a4b0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4b0 cd 80 9c			call macro_forth_dsp_pop 
a4b3				endm 
# End of macro FORTH_DSP_POP
a4b3			 
a4b3			;		pop hl 
a4b3			 
a4b3 7e				ld a, (hl) 
a4b4			 
a4b4 6f				ld l, a 
a4b5 26 00			ld h, 0 
a4b7 cd cc 99			call forth_push_numhl 
a4ba			 
a4ba				NEXTW 
a4ba cd 68 ee			call parse_vector 
a4bd c3 af 9d			jp macro_next 
a4c0				endm 
# End of macro NEXTW
a4c0			.CAT: 
a4c0			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a4c0 20				db WORD_SYS_CORE+OPCODE_CAT             
a4c1 ec a4			dw .BANG            
a4c3 03				db 2 + 1 
a4c4 .. 00			db "C@",0              
a4c7				endm 
# End of macro CWHEAD
a4c7			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a4c7				if DEBUG_FORTH_WORDS_KEY 
a4c7					DMARK "CAA" 
a4c7 f5				push af  
a4c8 3a dc a4			ld a, (.dmark)  
a4cb 32 5e ee			ld (debug_mark),a  
a4ce 3a dd a4			ld a, (.dmark+1)  
a4d1 32 5f ee			ld (debug_mark+1),a  
a4d4 3a de a4			ld a, (.dmark+2)  
a4d7 32 60 ee			ld (debug_mark+2),a  
a4da 18 03			jr .pastdmark  
a4dc ..			.dmark: db "CAA"  
a4df f1			.pastdmark: pop af  
a4e0			endm  
# End of macro DMARK
a4e0					CALLMONITOR 
a4e0 cd 6b ee			call debug_vector  
a4e3				endm  
# End of macro CALLMONITOR
a4e3				endif 
a4e3 c3 ad a4			jp .getbyteat 
a4e6				NEXTW 
a4e6 cd 68 ee			call parse_vector 
a4e9 c3 af 9d			jp macro_next 
a4ec				endm 
# End of macro NEXTW
a4ec			.BANG: 
a4ec			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a4ec 21				db WORD_SYS_CORE+OPCODE_BANG             
a4ed 25 a5			dw .CBANG            
a4ef 02				db 1 + 1 
a4f0 .. 00			db "!",0              
a4f2				endm 
# End of macro CWHEAD
a4f2			; | ! ( x w -- ) Store x at address w      | DONE 
a4f2				if DEBUG_FORTH_WORDS_KEY 
a4f2					DMARK "BNG" 
a4f2 f5				push af  
a4f3 3a 07 a5			ld a, (.dmark)  
a4f6 32 5e ee			ld (debug_mark),a  
a4f9 3a 08 a5			ld a, (.dmark+1)  
a4fc 32 5f ee			ld (debug_mark+1),a  
a4ff 3a 09 a5			ld a, (.dmark+2)  
a502 32 60 ee			ld (debug_mark+2),a  
a505 18 03			jr .pastdmark  
a507 ..			.dmark: db "BNG"  
a50a f1			.pastdmark: pop af  
a50b			endm  
# End of macro DMARK
a50b					CALLMONITOR 
a50b cd 6b ee			call debug_vector  
a50e				endm  
# End of macro CALLMONITOR
a50e				endif 
a50e			 
a50e			.storebyteat:		 
a50e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a50e cd c8 9b			call macro_dsp_valuehl 
a511				endm 
# End of macro FORTH_DSP_VALUEHL
a511				 
a511 e5				push hl 
a512			 
a512				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a512 cd 80 9c			call macro_forth_dsp_pop 
a515				endm 
# End of macro FORTH_DSP_POP
a515			 
a515				; get byte to poke 
a515			 
a515				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a515 cd c8 9b			call macro_dsp_valuehl 
a518				endm 
# End of macro FORTH_DSP_VALUEHL
a518 e5				push hl 
a519			 
a519			 
a519				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a519 cd 80 9c			call macro_forth_dsp_pop 
a51c				endm 
# End of macro FORTH_DSP_POP
a51c			 
a51c			 
a51c d1				pop de 
a51d e1				pop hl 
a51e			 
a51e 73				ld (hl),e 
a51f			 
a51f			 
a51f				NEXTW 
a51f cd 68 ee			call parse_vector 
a522 c3 af 9d			jp macro_next 
a525				endm 
# End of macro NEXTW
a525			.CBANG: 
a525			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a525 22				db WORD_SYS_CORE+OPCODE_CBANG             
a526 51 a5			dw .SCALL            
a528 03				db 2 + 1 
a529 .. 00			db "C!",0              
a52c				endm 
# End of macro CWHEAD
a52c			; | C!  ( x w -- ) Store x at address w  | DONE 
a52c				if DEBUG_FORTH_WORDS_KEY 
a52c					DMARK "CBA" 
a52c f5				push af  
a52d 3a 41 a5			ld a, (.dmark)  
a530 32 5e ee			ld (debug_mark),a  
a533 3a 42 a5			ld a, (.dmark+1)  
a536 32 5f ee			ld (debug_mark+1),a  
a539 3a 43 a5			ld a, (.dmark+2)  
a53c 32 60 ee			ld (debug_mark+2),a  
a53f 18 03			jr .pastdmark  
a541 ..			.dmark: db "CBA"  
a544 f1			.pastdmark: pop af  
a545			endm  
# End of macro DMARK
a545					CALLMONITOR 
a545 cd 6b ee			call debug_vector  
a548				endm  
# End of macro CALLMONITOR
a548				endif 
a548 c3 0e a5			jp .storebyteat 
a54b				NEXTW 
a54b cd 68 ee			call parse_vector 
a54e c3 af 9d			jp macro_next 
a551				endm 
# End of macro NEXTW
a551			.SCALL: 
a551			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a551 23				db WORD_SYS_CORE+OPCODE_SCALL             
a552 88 a5			dw .DEPTH            
a554 05				db 4 + 1 
a555 .. 00			db "CALL",0              
a55a				endm 
# End of macro CWHEAD
a55a			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a55a				if DEBUG_FORTH_WORDS_KEY 
a55a					DMARK "CLL" 
a55a f5				push af  
a55b 3a 6f a5			ld a, (.dmark)  
a55e 32 5e ee			ld (debug_mark),a  
a561 3a 70 a5			ld a, (.dmark+1)  
a564 32 5f ee			ld (debug_mark+1),a  
a567 3a 71 a5			ld a, (.dmark+2)  
a56a 32 60 ee			ld (debug_mark+2),a  
a56d 18 03			jr .pastdmark  
a56f ..			.dmark: db "CLL"  
a572 f1			.pastdmark: pop af  
a573			endm  
# End of macro DMARK
a573					CALLMONITOR 
a573 cd 6b ee			call debug_vector  
a576				endm  
# End of macro CALLMONITOR
a576				endif 
a576			 
a576				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a576 cd c8 9b			call macro_dsp_valuehl 
a579				endm 
# End of macro FORTH_DSP_VALUEHL
a579			 
a579			;		push hl 
a579			 
a579				; destroy value TOS 
a579			 
a579				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a579 cd 80 9c			call macro_forth_dsp_pop 
a57c				endm 
# End of macro FORTH_DSP_POP
a57c			 
a57c					 
a57c			;		pop hl 
a57c			 
a57c				; how to do a call with hl???? save SP? 
a57c cd 53 9d			call forth_call_hl 
a57f			 
a57f			 
a57f				; TODO push value back onto stack for another op etc 
a57f			 
a57f cd cc 99			call forth_push_numhl 
a582				NEXTW 
a582 cd 68 ee			call parse_vector 
a585 c3 af 9d			jp macro_next 
a588				endm 
# End of macro NEXTW
a588			.DEPTH: 
a588			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a588 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a589 c8 a5			dw .OVER            
a58b 06				db 5 + 1 
a58c .. 00			db "DEPTH",0              
a592				endm 
# End of macro CWHEAD
a592			; | DEPTH ( -- u ) Push count of stack | DONE 
a592				; take current TOS and remove from base value div by two to get count 
a592				if DEBUG_FORTH_WORDS_KEY 
a592					DMARK "DEP" 
a592 f5				push af  
a593 3a a7 a5			ld a, (.dmark)  
a596 32 5e ee			ld (debug_mark),a  
a599 3a a8 a5			ld a, (.dmark+1)  
a59c 32 5f ee			ld (debug_mark+1),a  
a59f 3a a9 a5			ld a, (.dmark+2)  
a5a2 32 60 ee			ld (debug_mark+2),a  
a5a5 18 03			jr .pastdmark  
a5a7 ..			.dmark: db "DEP"  
a5aa f1			.pastdmark: pop af  
a5ab			endm  
# End of macro DMARK
a5ab					CALLMONITOR 
a5ab cd 6b ee			call debug_vector  
a5ae				endm  
# End of macro CALLMONITOR
a5ae				endif 
a5ae			 
a5ae			 
a5ae 2a e1 e9		ld hl, (cli_data_sp) 
a5b1 11 1b e8		ld de, cli_data_stack 
a5b4 ed 52		sbc hl,de 
a5b6			 
a5b6			; div by size of stack item 
a5b6			 
a5b6 5d			ld e,l 
a5b7 0e 03		ld c, 3 
a5b9 cd 6b 8c		call Div8 
a5bc			 
a5bc 6f			ld l,a 
a5bd 26 00		ld h,0 
a5bf			 
a5bf			;srl h 
a5bf			;rr l 
a5bf			 
a5bf cd cc 99			call forth_push_numhl 
a5c2				NEXTW 
a5c2 cd 68 ee			call parse_vector 
a5c5 c3 af 9d			jp macro_next 
a5c8				endm 
# End of macro NEXTW
a5c8			.OVER: 
a5c8			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a5c8 42				db WORD_SYS_CORE+46             
a5c9 18 a6			dw .PAUSE            
a5cb 05				db 4 + 1 
a5cc .. 00			db "OVER",0              
a5d1				endm 
# End of macro CWHEAD
a5d1			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a5d1			; | | >[!NOTE] 
a5d1			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
a5d1				if DEBUG_FORTH_WORDS_KEY 
a5d1					DMARK "OVR" 
a5d1 f5				push af  
a5d2 3a e6 a5			ld a, (.dmark)  
a5d5 32 5e ee			ld (debug_mark),a  
a5d8 3a e7 a5			ld a, (.dmark+1)  
a5db 32 5f ee			ld (debug_mark+1),a  
a5de 3a e8 a5			ld a, (.dmark+2)  
a5e1 32 60 ee			ld (debug_mark+2),a  
a5e4 18 03			jr .pastdmark  
a5e6 ..			.dmark: db "OVR"  
a5e9 f1			.pastdmark: pop af  
a5ea			endm  
# End of macro DMARK
a5ea					CALLMONITOR 
a5ea cd 6b ee			call debug_vector  
a5ed				endm  
# End of macro CALLMONITOR
a5ed				endif 
a5ed			 
a5ed			; TODO Use os stack swap memory 
a5ed			 
a5ed				; work out what type we are looking at 
a5ed			 
a5ed				FORTH_DSP_PTR 1 
a5ed 2a e1 e9			ld hl,(cli_data_sp) 
a5f0 11 03 00			ld de, 1 * 3 
a5f3 ed 52			sbc hl, de 
a5f5				endm 
# End of macro FORTH_DSP_PTR
a5f5			 
a5f5 7e				ld a, (hl) 
a5f6				 
a5f6 f5				push af 
a5f7				; whatever the type lets get the pointer or word 
a5f7 23				inc hl 
a5f8			;; 
a5f8			 
a5f8				; type check now to decide on how to push  
a5f8			 
a5f8 cd 35 9d			call loadwordinhl 
a5fb f1				pop af 
a5fc fe 01			cp DS_TYPE_STR 
a5fe 28 09			jr z, .ovstr 
a600			 
a600				; we have a numeric so load the word and push 
a600			;	ld e, (hl) 
a600			;	inc hl 
a600			;	ld d, (hl) 
a600			;	ex de, hl 
a600 cd cc 99			call forth_push_numhl 
a603				NEXTW 
a603 cd 68 ee			call parse_vector 
a606 c3 af 9d			jp macro_next 
a609				endm 
# End of macro NEXTW
a609			 
a609			.ovstr: 
a609				; ok, a string so get the pointer and push as a string 
a609			 
a609			;	call loadwordinhl 
a609 cd 36 9a			call forth_push_str 
a60c				NEXTW 
a60c cd 68 ee			call parse_vector 
a60f c3 af 9d			jp macro_next 
a612				endm 
# End of macro NEXTW
a612			 
a612			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a612			;	push hl    ; n2 
a612			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a612			; 
a612			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a612			;	push hl    ; n1 
a612			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a612			; 
a612			;	pop de     ; n1 
a612			;	pop hl     ; n2 
a612			; 
a612			;	push de 
a612			;	push hl 
a612			;	push de 
a612			 
a612				; push back  
a612			 
a612			;	pop hl 
a612			;	call forth_push_numhl 
a612			;	pop hl 
a612			;	call forth_push_numhl 
a612			;	pop hl 
a612			;	call forth_push_numhl 
a612				NEXTW 
a612 cd 68 ee			call parse_vector 
a615 c3 af 9d			jp macro_next 
a618				endm 
# End of macro NEXTW
a618			 
a618			.PAUSE: 
a618			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a618 43				db WORD_SYS_CORE+47             
a619 50 a6			dw .PAUSES            
a61b 08				db 7 + 1 
a61c .. 00			db "PAUSEMS",0              
a624				endm 
# End of macro CWHEAD
a624			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a624				if DEBUG_FORTH_WORDS_KEY 
a624					DMARK "PMS" 
a624 f5				push af  
a625 3a 39 a6			ld a, (.dmark)  
a628 32 5e ee			ld (debug_mark),a  
a62b 3a 3a a6			ld a, (.dmark+1)  
a62e 32 5f ee			ld (debug_mark+1),a  
a631 3a 3b a6			ld a, (.dmark+2)  
a634 32 60 ee			ld (debug_mark+2),a  
a637 18 03			jr .pastdmark  
a639 ..			.dmark: db "PMS"  
a63c f1			.pastdmark: pop af  
a63d			endm  
# End of macro DMARK
a63d					CALLMONITOR 
a63d cd 6b ee			call debug_vector  
a640				endm  
# End of macro CALLMONITOR
a640				endif 
a640				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a640 cd c8 9b			call macro_dsp_valuehl 
a643				endm 
# End of macro FORTH_DSP_VALUEHL
a643			;		push hl    ; n2 
a643				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a643 cd 80 9c			call macro_forth_dsp_pop 
a646				endm 
# End of macro FORTH_DSP_POP
a646			;		pop hl 
a646			 
a646 7d				ld a, l 
a647 cd d5 89			call aDelayInMS 
a64a			       NEXTW 
a64a cd 68 ee			call parse_vector 
a64d c3 af 9d			jp macro_next 
a650				endm 
# End of macro NEXTW
a650			.PAUSES:  
a650			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a650 44				db WORD_SYS_CORE+48             
a651 c2 a6			dw .ROT            
a653 06				db 5 + 1 
a654 .. 00			db "PAUSE",0              
a65a				endm 
# End of macro CWHEAD
a65a			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a65a				if DEBUG_FORTH_WORDS_KEY 
a65a					DMARK "PAU" 
a65a f5				push af  
a65b 3a 6f a6			ld a, (.dmark)  
a65e 32 5e ee			ld (debug_mark),a  
a661 3a 70 a6			ld a, (.dmark+1)  
a664 32 5f ee			ld (debug_mark+1),a  
a667 3a 71 a6			ld a, (.dmark+2)  
a66a 32 60 ee			ld (debug_mark+2),a  
a66d 18 03			jr .pastdmark  
a66f ..			.dmark: db "PAU"  
a672 f1			.pastdmark: pop af  
a673			endm  
# End of macro DMARK
a673					CALLMONITOR 
a673 cd 6b ee			call debug_vector  
a676				endm  
# End of macro CALLMONITOR
a676				endif 
a676				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a676 cd c8 9b			call macro_dsp_valuehl 
a679				endm 
# End of macro FORTH_DSP_VALUEHL
a679			;		push hl    ; n2 
a679				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a679 cd 80 9c			call macro_forth_dsp_pop 
a67c				endm 
# End of macro FORTH_DSP_POP
a67c			;		pop hl 
a67c 45				ld b, l 
a67d				if DEBUG_FORTH_WORDS 
a67d					DMARK "PAU" 
a67d f5				push af  
a67e 3a 92 a6			ld a, (.dmark)  
a681 32 5e ee			ld (debug_mark),a  
a684 3a 93 a6			ld a, (.dmark+1)  
a687 32 5f ee			ld (debug_mark+1),a  
a68a 3a 94 a6			ld a, (.dmark+2)  
a68d 32 60 ee			ld (debug_mark+2),a  
a690 18 03			jr .pastdmark  
a692 ..			.dmark: db "PAU"  
a695 f1			.pastdmark: pop af  
a696			endm  
# End of macro DMARK
a696					CALLMONITOR 
a696 cd 6b ee			call debug_vector  
a699				endm  
# End of macro CALLMONITOR
a699				endif 
a699 c5			.pauses1:	push bc 
a69a cd f0 89			call delay1s 
a69d c1				pop bc 
a69e				if DEBUG_FORTH_WORDS 
a69e					DMARK "PA1" 
a69e f5				push af  
a69f 3a b3 a6			ld a, (.dmark)  
a6a2 32 5e ee			ld (debug_mark),a  
a6a5 3a b4 a6			ld a, (.dmark+1)  
a6a8 32 5f ee			ld (debug_mark+1),a  
a6ab 3a b5 a6			ld a, (.dmark+2)  
a6ae 32 60 ee			ld (debug_mark+2),a  
a6b1 18 03			jr .pastdmark  
a6b3 ..			.dmark: db "PA1"  
a6b6 f1			.pastdmark: pop af  
a6b7			endm  
# End of macro DMARK
a6b7					CALLMONITOR 
a6b7 cd 6b ee			call debug_vector  
a6ba				endm  
# End of macro CALLMONITOR
a6ba				endif 
a6ba 10 dd			djnz .pauses1 
a6bc			 
a6bc			       NEXTW 
a6bc cd 68 ee			call parse_vector 
a6bf c3 af 9d			jp macro_next 
a6c2				endm 
# End of macro NEXTW
a6c2			.ROT: 
a6c2			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a6c2 45				db WORD_SYS_CORE+49             
a6c3 2e a7			dw .UWORDS            
a6c5 04				db 3 + 1 
a6c6 .. 00			db "ROT",0              
a6ca				endm 
# End of macro CWHEAD
a6ca			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a6ca				if DEBUG_FORTH_WORDS_KEY 
a6ca					DMARK "ROT" 
a6ca f5				push af  
a6cb 3a df a6			ld a, (.dmark)  
a6ce 32 5e ee			ld (debug_mark),a  
a6d1 3a e0 a6			ld a, (.dmark+1)  
a6d4 32 5f ee			ld (debug_mark+1),a  
a6d7 3a e1 a6			ld a, (.dmark+2)  
a6da 32 60 ee			ld (debug_mark+2),a  
a6dd 18 03			jr .pastdmark  
a6df ..			.dmark: db "ROT"  
a6e2 f1			.pastdmark: pop af  
a6e3			endm  
# End of macro DMARK
a6e3					CALLMONITOR 
a6e3 cd 6b ee			call debug_vector  
a6e6				endm  
# End of macro CALLMONITOR
a6e6				endif 
a6e6			 
a6e6			; DONE Use os stack swap memory 
a6e6			 
a6e6				FORTH_DSP_PTR 0     ; u3 
a6e6 2a e1 e9			ld hl,(cli_data_sp) 
a6e9 11 00 00			ld de, 0 * 3 
a6ec ed 52			sbc hl, de 
a6ee				endm 
# End of macro FORTH_DSP_PTR
a6ee cd ff 9c			call hltostack1     
a6f1			  
a6f1				FORTH_DSP_PTR 1     ; u2 
a6f1 2a e1 e9			ld hl,(cli_data_sp) 
a6f4 11 03 00			ld de, 1 * 3 
a6f7 ed 52			sbc hl, de 
a6f9				endm 
# End of macro FORTH_DSP_PTR
a6f9 cd 05 9d			call hltostack2      
a6fc			 
a6fc				FORTH_DSP_PTR 2     ; u1 
a6fc 2a e1 e9			ld hl,(cli_data_sp) 
a6ff 11 06 00			ld de, 2 * 3 
a702 ed 52			sbc hl, de 
a704				endm 
# End of macro FORTH_DSP_PTR
a704 cd 0b 9d			call hltostack3 
a707			 
a707			 
a707				FORTH_DSP_PTR 0     ;  
a707 2a e1 e9			ld hl,(cli_data_sp) 
a70a 11 00 00			ld de, 0 * 3 
a70d ed 52			sbc hl, de 
a70f				endm 
# End of macro FORTH_DSP_PTR
a70f cd 23 9d			call hlfromstack3 
a712			 
a712				FORTH_DSP_PTR 1     ; TOS 
a712 2a e1 e9			ld hl,(cli_data_sp) 
a715 11 03 00			ld de, 1 * 3 
a718 ed 52			sbc hl, de 
a71a				endm 
# End of macro FORTH_DSP_PTR
a71a cd 17 9d			call hlfromstack1 
a71d			 
a71d				FORTH_DSP_PTR 2     ; TOS 
a71d 2a e1 e9			ld hl,(cli_data_sp) 
a720 11 06 00			ld de, 2 * 3 
a723 ed 52			sbc hl, de 
a725				endm 
# End of macro FORTH_DSP_PTR
a725 cd 1d 9d			call hlfromstack2 
a728			 
a728			 
a728			;	FORTH_DSP_VALUEHL 
a728			;	push hl    ; u3  
a728			; 
a728			;	FORTH_DSP_POP 
a728			; 
a728			;	FORTH_DSP_VALUEHL 
a728			;	push hl     ; u2 
a728			; 
a728			;	FORTH_DSP_POP 
a728			; 
a728			;	FORTH_DSP_VALUEHL 
a728			;	push hl     ; u1 
a728			; 
a728			;	FORTH_DSP_POP 
a728			; 
a728			;	pop bc      ; u1 
a728			;	pop hl      ; u2 
a728			;	pop de      ; u3 
a728			; 
a728			; 
a728			;	push bc 
a728			;	push de 
a728			;	push hl 
a728			; 
a728			; 
a728			;	pop hl 
a728			;	call forth_push_numhl 
a728			; 
a728			;	pop hl 
a728			;	call forth_push_numhl 
a728			; 
a728			;	pop hl 
a728			;	call forth_push_numhl 
a728				 
a728			 
a728			 
a728			 
a728			 
a728			 
a728			       NEXTW 
a728 cd 68 ee			call parse_vector 
a72b c3 af 9d			jp macro_next 
a72e				endm 
# End of macro NEXTW
a72e			 
a72e			.UWORDS: 
a72e			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a72e 50				db WORD_SYS_CORE+60             
a72f f3 a7			dw .BP            
a731 07				db 6 + 1 
a732 .. 00			db "UWORDS",0              
a739				endm 
# End of macro CWHEAD
a739			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a739			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a739			; | | Following the count are the individual words. 
a739			; | | 
a739			; | | e.g. UWORDS 
a739			; | | BOX DIRLIST 2 
a739			; | |  
a739			; | | Can be used to save the words to storage via: 
a739			; | | UWORDS $01 DO $01 APPEND LOOP 
a739			if DEBUG_FORTH_WORDS_KEY 
a739				DMARK "UWR" 
a739 f5				push af  
a73a 3a 4e a7			ld a, (.dmark)  
a73d 32 5e ee			ld (debug_mark),a  
a740 3a 4f a7			ld a, (.dmark+1)  
a743 32 5f ee			ld (debug_mark+1),a  
a746 3a 50 a7			ld a, (.dmark+2)  
a749 32 60 ee			ld (debug_mark+2),a  
a74c 18 03			jr .pastdmark  
a74e ..			.dmark: db "UWR"  
a751 f1			.pastdmark: pop af  
a752			endm  
# End of macro DMARK
a752				CALLMONITOR 
a752 cd 6b ee			call debug_vector  
a755				endm  
# End of macro CALLMONITOR
a755			endif 
a755 21 3c e6			ld hl, baseram 
a758				;ld hl, baseusermem 
a758 01 00 00			ld bc, 0    ; start a counter 
a75b			 
a75b			; skip dict stub 
a75b			 
a75b cd e1 9e			call forth_tok_next 
a75e			 
a75e			 
a75e			; while we have words to look for 
a75e			 
a75e 7e			.douscan:	ld a, (hl)      
a75f			if DEBUG_FORTH_WORDS 
a75f				DMARK "UWs" 
a75f f5				push af  
a760 3a 74 a7			ld a, (.dmark)  
a763 32 5e ee			ld (debug_mark),a  
a766 3a 75 a7			ld a, (.dmark+1)  
a769 32 5f ee			ld (debug_mark+1),a  
a76c 3a 76 a7			ld a, (.dmark+2)  
a76f 32 60 ee			ld (debug_mark+2),a  
a772 18 03			jr .pastdmark  
a774 ..			.dmark: db "UWs"  
a777 f1			.pastdmark: pop af  
a778			endm  
# End of macro DMARK
a778				CALLMONITOR 
a778 cd 6b ee			call debug_vector  
a77b				endm  
# End of macro CALLMONITOR
a77b			endif 
a77b fe 00			cp WORD_SYS_END 
a77d 28 4d			jr z, .udone 
a77f fe 01			cp WORD_SYS_UWORD 
a781 20 44			jr nz, .nuword 
a783			 
a783			if DEBUG_FORTH_WORDS 
a783				DMARK "UWu" 
a783 f5				push af  
a784 3a 98 a7			ld a, (.dmark)  
a787 32 5e ee			ld (debug_mark),a  
a78a 3a 99 a7			ld a, (.dmark+1)  
a78d 32 5f ee			ld (debug_mark+1),a  
a790 3a 9a a7			ld a, (.dmark+2)  
a793 32 60 ee			ld (debug_mark+2),a  
a796 18 03			jr .pastdmark  
a798 ..			.dmark: db "UWu"  
a79b f1			.pastdmark: pop af  
a79c			endm  
# End of macro DMARK
a79c				CALLMONITOR 
a79c cd 6b ee			call debug_vector  
a79f				endm  
# End of macro CALLMONITOR
a79f			endif 
a79f				; we have a uword so push its name to the stack 
a79f			 
a79f e5				push hl  ; save so we can move to next dict block 
a7a0			 
a7a0				; skip opcode 
a7a0 23				inc hl  
a7a1				; skip next ptr 
a7a1 23				inc hl  
a7a2 23				inc hl 
a7a3				; skip len 
a7a3 23				inc hl 
a7a4			if DEBUG_FORTH_WORDS 
a7a4				DMARK "UWt" 
a7a4 f5				push af  
a7a5 3a b9 a7			ld a, (.dmark)  
a7a8 32 5e ee			ld (debug_mark),a  
a7ab 3a ba a7			ld a, (.dmark+1)  
a7ae 32 5f ee			ld (debug_mark+1),a  
a7b1 3a bb a7			ld a, (.dmark+2)  
a7b4 32 60 ee			ld (debug_mark+2),a  
a7b7 18 03			jr .pastdmark  
a7b9 ..			.dmark: db "UWt"  
a7bc f1			.pastdmark: pop af  
a7bd			endm  
# End of macro DMARK
a7bd				CALLMONITOR 
a7bd cd 6b ee			call debug_vector  
a7c0				endm  
# End of macro CALLMONITOR
a7c0			endif 
a7c0 03				inc bc 
a7c1			 
a7c1 c5				push bc 
a7c2 cd 36 9a			call forth_push_str 
a7c5 c1				pop bc 
a7c6			 
a7c6 e1				pop hl 	 
a7c7			 
a7c7 cd e1 9e		.nuword:	call forth_tok_next 
a7ca 18 92			jr .douscan  
a7cc			 
a7cc			.udone:		 ; push count of uwords found 
a7cc c5				push bc 
a7cd e1				pop hl 
a7ce			 
a7ce			if DEBUG_FORTH_WORDS 
a7ce				DMARK "UWc" 
a7ce f5				push af  
a7cf 3a e3 a7			ld a, (.dmark)  
a7d2 32 5e ee			ld (debug_mark),a  
a7d5 3a e4 a7			ld a, (.dmark+1)  
a7d8 32 5f ee			ld (debug_mark+1),a  
a7db 3a e5 a7			ld a, (.dmark+2)  
a7de 32 60 ee			ld (debug_mark+2),a  
a7e1 18 03			jr .pastdmark  
a7e3 ..			.dmark: db "UWc"  
a7e6 f1			.pastdmark: pop af  
a7e7			endm  
# End of macro DMARK
a7e7				CALLMONITOR 
a7e7 cd 6b ee			call debug_vector  
a7ea				endm  
# End of macro CALLMONITOR
a7ea			endif 
a7ea cd cc 99			call forth_push_numhl 
a7ed			 
a7ed			 
a7ed			       NEXTW 
a7ed cd 68 ee			call parse_vector 
a7f0 c3 af 9d			jp macro_next 
a7f3				endm 
# End of macro NEXTW
a7f3			 
a7f3			.BP: 
a7f3			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a7f3 54				db WORD_SYS_CORE+64             
a7f4 33 a8			dw .MONITOR            
a7f6 03				db 2 + 1 
a7f7 .. 00			db "BP",0              
a7fa				endm 
# End of macro CWHEAD
a7fa			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a7fa			; | | $00 Will enable the break points within specific code paths 
a7fa			; | | $01 Will disable break points 
a7fa			; | |  
a7fa			; | | By default break points are off. Either the above can be used to enable them 
a7fa			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a7fa			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a7fa			; | | can disable break points. Exiting will then continue boot process. 
a7fa				; get byte count 
a7fa				if DEBUG_FORTH_WORDS_KEY 
a7fa					DMARK "BP." 
a7fa f5				push af  
a7fb 3a 0f a8			ld a, (.dmark)  
a7fe 32 5e ee			ld (debug_mark),a  
a801 3a 10 a8			ld a, (.dmark+1)  
a804 32 5f ee			ld (debug_mark+1),a  
a807 3a 11 a8			ld a, (.dmark+2)  
a80a 32 60 ee			ld (debug_mark+2),a  
a80d 18 03			jr .pastdmark  
a80f ..			.dmark: db "BP."  
a812 f1			.pastdmark: pop af  
a813			endm  
# End of macro DMARK
a813					CALLMONITOR 
a813 cd 6b ee			call debug_vector  
a816				endm  
# End of macro CALLMONITOR
a816				endif 
a816			 
a816				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a816 cd c8 9b			call macro_dsp_valuehl 
a819				endm 
# End of macro FORTH_DSP_VALUEHL
a819			 
a819			;		push hl 
a819			 
a819				; destroy value TOS 
a819			 
a819				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a819 cd 80 9c			call macro_forth_dsp_pop 
a81c				endm 
# End of macro FORTH_DSP_POP
a81c			 
a81c			;		pop hl 
a81c			 
a81c 3e 00			ld a,0 
a81e bd				cp l 
a81f 28 09			jr z, .bpset 
a821			;		ld a, '*' 
a821 cd 57 93			call bp_off 
a824				NEXTW 
a824 cd 68 ee			call parse_vector 
a827 c3 af 9d			jp macro_next 
a82a				endm 
# End of macro NEXTW
a82a			 
a82a			.bpset:	 
a82a				;	ld (os_view_disable), a 
a82a cd 4b 93			call bp_on 
a82d			 
a82d			 
a82d				NEXTW 
a82d cd 68 ee			call parse_vector 
a830 c3 af 9d			jp macro_next 
a833				endm 
# End of macro NEXTW
a833			 
a833			 
a833			.MONITOR: 
a833			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a833 55				db WORD_SYS_CORE+65             
a834 67 a8			dw .MALLOC            
a836 08				db 7 + 1 
a837 .. 00			db "MONITOR",0              
a83f				endm 
# End of macro CWHEAD
a83f			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a83f			; | | At start the current various registers will be displayed with contents. 
a83f			; | | Top right corner will show the most recent debug marker seen. 
a83f			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a83f			; | | and the return stack pointer (RSP). 
a83f			; | | Pressing: 
a83f			; | |  
a83f			; | |    1 - Initial screen 
a83f			; | |  
a83f			; | |    2 - Display a data dump of HL 
a83f			; | |  
a83f			; | |    3 - Display a data dump of DE 
a83f			; | |  
a83f			; | |    4 - Display a data dump of BC 
a83f			; | |  
a83f			; | |    5 - Display a data dump of HL 
a83f			; | |  
a83f			; | |    6 - Display a data dump of DSP 
a83f			; | |  
a83f			; | |    7 - Display a data dump of RSP 
a83f			; | |  
a83f			; | |    8 - Display a data dump of what is at DSP 
a83f			; | |  
a83f			; | |    9 - Display a data dump of what is at RSP 
a83f			; | |  
a83f			; | |    0 - Exit monitor and continue running. This will also enable break points 
a83f			; | |  
a83f			; | |    * - Disable break points 
a83f			; | |  
a83f			; | |    # - Enter traditional monitor mode 
a83f			; | |  
a83f			; | | 
a83f			; | | Monitor Mode 
a83f			; | | ------------ 
a83f			; | | A prompt of '>' will be shown for various commands: 
a83f			; | |  
a83f			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a83f			; | |  
a83f			; | |    C - Continue display a data dump from the last set address 
a83f			; | |  
a83f			; | |    M xxxx - Set start of memory edit at address xx 
a83f			; | |  
a83f			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a83f			; | |  
a83f			; | |    G xxxx - Exec code at specific address 
a83f			; | |  
a83f			; | |    Q - Return to previous 
a83f				if DEBUG_FORTH_WORDS_KEY 
a83f					DMARK "MON" 
a83f f5				push af  
a840 3a 54 a8			ld a, (.dmark)  
a843 32 5e ee			ld (debug_mark),a  
a846 3a 55 a8			ld a, (.dmark+1)  
a849 32 5f ee			ld (debug_mark+1),a  
a84c 3a 56 a8			ld a, (.dmark+2)  
a84f 32 60 ee			ld (debug_mark+2),a  
a852 18 03			jr .pastdmark  
a854 ..			.dmark: db "MON"  
a857 f1			.pastdmark: pop af  
a858			endm  
# End of macro DMARK
a858					CALLMONITOR 
a858 cd 6b ee			call debug_vector  
a85b				endm  
# End of macro CALLMONITOR
a85b				endif 
a85b			;		ld a, 0 
a85b			;		ld (os_view_disable), a 
a85b cd 4b 93			call bp_on 
a85e			 
a85e				CALLMONITOR 
a85e cd 6b ee			call debug_vector  
a861				endm  
# End of macro CALLMONITOR
a861			 
a861			;	call monitor 
a861			 
a861				NEXTW 
a861 cd 68 ee			call parse_vector 
a864 c3 af 9d			jp macro_next 
a867				endm 
# End of macro NEXTW
a867			 
a867			 
a867			.MALLOC: 
a867			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a867 56				db WORD_SYS_CORE+66             
a868 90 a8			dw .MALLOC2            
a86a 06				db 5 + 1 
a86b .. 00			db "ALLOT",0              
a871				endm 
# End of macro CWHEAD
a871			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a871				if DEBUG_FORTH_WORDS_KEY 
a871					DMARK "ALL" 
a871 f5				push af  
a872 3a 86 a8			ld a, (.dmark)  
a875 32 5e ee			ld (debug_mark),a  
a878 3a 87 a8			ld a, (.dmark+1)  
a87b 32 5f ee			ld (debug_mark+1),a  
a87e 3a 88 a8			ld a, (.dmark+2)  
a881 32 60 ee			ld (debug_mark+2),a  
a884 18 03			jr .pastdmark  
a886 ..			.dmark: db "ALL"  
a889 f1			.pastdmark: pop af  
a88a			endm  
# End of macro DMARK
a88a					CALLMONITOR 
a88a cd 6b ee			call debug_vector  
a88d				endm  
# End of macro CALLMONITOR
a88d				endif 
a88d c3 b7 a8			jp .mallocc 
a890			.MALLOC2: 
a890			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a890 56				db WORD_SYS_CORE+66             
a891 d1 a8			dw .FREE            
a893 07				db 6 + 1 
a894 .. 00			db "MALLOC",0              
a89b				endm 
# End of macro CWHEAD
a89b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a89b				; get byte count 
a89b				if DEBUG_FORTH_WORDS_KEY 
a89b					DMARK "MAL" 
a89b f5				push af  
a89c 3a b0 a8			ld a, (.dmark)  
a89f 32 5e ee			ld (debug_mark),a  
a8a2 3a b1 a8			ld a, (.dmark+1)  
a8a5 32 5f ee			ld (debug_mark+1),a  
a8a8 3a b2 a8			ld a, (.dmark+2)  
a8ab 32 60 ee			ld (debug_mark+2),a  
a8ae 18 03			jr .pastdmark  
a8b0 ..			.dmark: db "MAL"  
a8b3 f1			.pastdmark: pop af  
a8b4			endm  
# End of macro DMARK
a8b4					CALLMONITOR 
a8b4 cd 6b ee			call debug_vector  
a8b7				endm  
# End of macro CALLMONITOR
a8b7				endif 
a8b7			.mallocc: 
a8b7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8b7 cd c8 9b			call macro_dsp_valuehl 
a8ba				endm 
# End of macro FORTH_DSP_VALUEHL
a8ba			 
a8ba			;		push hl 
a8ba			 
a8ba				; destroy value TOS 
a8ba			 
a8ba				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8ba cd 80 9c			call macro_forth_dsp_pop 
a8bd				endm 
# End of macro FORTH_DSP_POP
a8bd			 
a8bd			;		pop hl 
a8bd cd a7 90			call malloc 
a8c0			if DEBUG_FORTH_MALLOC_GUARD 
a8c0 f5				push af 
a8c1 cd 04 8d			call ishlzero 
a8c4			;		ld a, l 
a8c4			;		add h 
a8c4			;		cp 0 
a8c4 f1				pop af 
a8c5				 
a8c5 cc 49 d3			call z,malloc_error 
a8c8			endif 
a8c8			 
a8c8 cd cc 99			call forth_push_numhl 
a8cb				NEXTW 
a8cb cd 68 ee			call parse_vector 
a8ce c3 af 9d			jp macro_next 
a8d1				endm 
# End of macro NEXTW
a8d1			 
a8d1			.FREE: 
a8d1			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
a8d1 57				db WORD_SYS_CORE+67             
a8d2 05 a9			dw .UPTR            
a8d4 05				db 4 + 1 
a8d5 .. 00			db "FREE",0              
a8da				endm 
# End of macro CWHEAD
a8da			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a8da				if DEBUG_FORTH_WORDS_KEY 
a8da					DMARK "FRE" 
a8da f5				push af  
a8db 3a ef a8			ld a, (.dmark)  
a8de 32 5e ee			ld (debug_mark),a  
a8e1 3a f0 a8			ld a, (.dmark+1)  
a8e4 32 5f ee			ld (debug_mark+1),a  
a8e7 3a f1 a8			ld a, (.dmark+2)  
a8ea 32 60 ee			ld (debug_mark+2),a  
a8ed 18 03			jr .pastdmark  
a8ef ..			.dmark: db "FRE"  
a8f2 f1			.pastdmark: pop af  
a8f3			endm  
# End of macro DMARK
a8f3					CALLMONITOR 
a8f3 cd 6b ee			call debug_vector  
a8f6				endm  
# End of macro CALLMONITOR
a8f6				endif 
a8f6				; get address 
a8f6			 
a8f6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8f6 cd c8 9b			call macro_dsp_valuehl 
a8f9				endm 
# End of macro FORTH_DSP_VALUEHL
a8f9			 
a8f9			;		push hl 
a8f9			 
a8f9				; destroy value TOS 
a8f9			 
a8f9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8f9 cd 80 9c			call macro_forth_dsp_pop 
a8fc				endm 
# End of macro FORTH_DSP_POP
a8fc			 
a8fc			;		pop hl 
a8fc			if FORTH_ENABLE_MALLOCFREE 
a8fc cd 71 91			call free 
a8ff			endif 
a8ff				NEXTW 
a8ff cd 68 ee			call parse_vector 
a902 c3 af 9d			jp macro_next 
a905				endm 
# End of macro NEXTW
a905			.UPTR: 
a905			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
a905 57				db WORD_SYS_CORE+67             
a906 0b aa			dw .LIST            
a908 05				db 4 + 1 
a909 .. 00			db "UPTR",0              
a90e				endm 
# End of macro CWHEAD
a90e			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
a90e				if DEBUG_FORTH_WORDS_KEY 
a90e					DMARK "UPT" 
a90e f5				push af  
a90f 3a 23 a9			ld a, (.dmark)  
a912 32 5e ee			ld (debug_mark),a  
a915 3a 24 a9			ld a, (.dmark+1)  
a918 32 5f ee			ld (debug_mark+1),a  
a91b 3a 25 a9			ld a, (.dmark+2)  
a91e 32 60 ee			ld (debug_mark+2),a  
a921 18 03			jr .pastdmark  
a923 ..			.dmark: db "UPT"  
a926 f1			.pastdmark: pop af  
a927			endm  
# End of macro DMARK
a927					CALLMONITOR 
a927 cd 6b ee			call debug_vector  
a92a				endm  
# End of macro CALLMONITOR
a92a				endif 
a92a				FORTH_DSP_VALUEHL 
a92a cd c8 9b			call macro_dsp_valuehl 
a92d				endm 
# End of macro FORTH_DSP_VALUEHL
a92d			 
a92d e5				push hl 
a92e				FORTH_DSP_POP 
a92e cd 80 9c			call macro_forth_dsp_pop 
a931				endm 
# End of macro FORTH_DSP_POP
a931 c1				pop bc 
a932			 
a932			 
a932				; Get ptr to the word we need to look up 
a932			 
a932			;		FORTH_DSP_VALUEHL 
a932				;v5 FORTH_DSP_VALUE 
a932			; TODO type check 
a932			;		inc hl    ; Skip type check  
a932			;		push hl 
a932			;		ex de, hl    ; put into DE 
a932			 
a932			 
a932 21 3c e6			ld hl, baseram 
a935				;ld hl, baseusermem 
a935			 
a935 e5			push hl   ; sacreifical push 
a936			 
a936			.uldouscanm: 
a936 e1			pop hl 
a937			.uldouscan: 
a937			if DEBUG_FORTH_WORDS 
a937				DMARK "LSs" 
a937 f5				push af  
a938 3a 4c a9			ld a, (.dmark)  
a93b 32 5e ee			ld (debug_mark),a  
a93e 3a 4d a9			ld a, (.dmark+1)  
a941 32 5f ee			ld (debug_mark+1),a  
a944 3a 4e a9			ld a, (.dmark+2)  
a947 32 60 ee			ld (debug_mark+2),a  
a94a 18 03			jr .pastdmark  
a94c ..			.dmark: db "LSs"  
a94f f1			.pastdmark: pop af  
a950			endm  
# End of macro DMARK
a950				CALLMONITOR 
a950 cd 6b ee			call debug_vector  
a953				endm  
# End of macro CALLMONITOR
a953			endif 
a953			; skip dict stub 
a953 cd e1 9e			call forth_tok_next 
a956			 
a956			 
a956			; while we have words to look for 
a956			 
a956 7e			ld a, (hl)      
a957			if DEBUG_FORTH_WORDS 
a957				DMARK "LSk" 
a957 f5				push af  
a958 3a 6c a9			ld a, (.dmark)  
a95b 32 5e ee			ld (debug_mark),a  
a95e 3a 6d a9			ld a, (.dmark+1)  
a961 32 5f ee			ld (debug_mark+1),a  
a964 3a 6e a9			ld a, (.dmark+2)  
a967 32 60 ee			ld (debug_mark+2),a  
a96a 18 03			jr .pastdmark  
a96c ..			.dmark: db "LSk"  
a96f f1			.pastdmark: pop af  
a970			endm  
# End of macro DMARK
a970				CALLMONITOR 
a970 cd 6b ee			call debug_vector  
a973				endm  
# End of macro CALLMONITOR
a973			endif 
a973				;cp WORD_SYS_END 
a973				;jp z, .lunotfound 
a973			 
a973					; if we hit non uwords then gone too far 
a973 fe 01				cp WORD_SYS_UWORD 
a975 c2 02 aa				jp nz, .ulunotfound 
a978			 
a978				if DEBUG_FORTH_WORDS 
a978					DMARK "LSu" 
a978 f5				push af  
a979 3a 8d a9			ld a, (.dmark)  
a97c 32 5e ee			ld (debug_mark),a  
a97f 3a 8e a9			ld a, (.dmark+1)  
a982 32 5f ee			ld (debug_mark+1),a  
a985 3a 8f a9			ld a, (.dmark+2)  
a988 32 60 ee			ld (debug_mark+2),a  
a98b 18 03			jr .pastdmark  
a98d ..			.dmark: db "LSu"  
a990 f1			.pastdmark: pop af  
a991			endm  
# End of macro DMARK
a991					CALLMONITOR 
a991 cd 6b ee			call debug_vector  
a994				endm  
# End of macro CALLMONITOR
a994				endif 
a994			 
a994					; found a uword but is it the one we want... 
a994			 
a994 c5					push bc     ; uword to find is on bc 
a995 d1					pop de 
a996			 
a996 e5					push hl  ; to save the ptr 
a997			 
a997					; skip opcode 
a997 23					inc hl  
a998					; skip next ptr 
a998 23					inc hl  
a999 23					inc hl 
a99a					; skip len 
a99a 23					inc hl 
a99b			 
a99b				if DEBUG_FORTH_WORDS 
a99b					DMARK "LSc" 
a99b f5				push af  
a99c 3a b0 a9			ld a, (.dmark)  
a99f 32 5e ee			ld (debug_mark),a  
a9a2 3a b1 a9			ld a, (.dmark+1)  
a9a5 32 5f ee			ld (debug_mark+1),a  
a9a8 3a b2 a9			ld a, (.dmark+2)  
a9ab 32 60 ee			ld (debug_mark+2),a  
a9ae 18 03			jr .pastdmark  
a9b0 ..			.dmark: db "LSc"  
a9b3 f1			.pastdmark: pop af  
a9b4			endm  
# End of macro DMARK
a9b4					CALLMONITOR 
a9b4 cd 6b ee			call debug_vector  
a9b7				endm  
# End of macro CALLMONITOR
a9b7				endif 
a9b7			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a9b7			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a9b7			; Nope that has gone the other way. It needs to be exact not on first zero 
a9b7			;		call strcmp 
a9b7 c5					push bc 
a9b8 cd 77 90				call StrictStrCmp 
a9bb c1					pop bc 
a9bc c2 36 a9				jp nz, .uldouscanm 
a9bf				 
a9bf			 
a9bf			 
a9bf					; we have a uword so push its name to the stack 
a9bf			 
a9bf			;	   	push hl  ; save so we can move to next dict block 
a9bf e1			pop hl 
a9c0			 
a9c0				if DEBUG_FORTH_WORDS 
a9c0					DMARK "LSm" 
a9c0 f5				push af  
a9c1 3a d5 a9			ld a, (.dmark)  
a9c4 32 5e ee			ld (debug_mark),a  
a9c7 3a d6 a9			ld a, (.dmark+1)  
a9ca 32 5f ee			ld (debug_mark+1),a  
a9cd 3a d7 a9			ld a, (.dmark+2)  
a9d0 32 60 ee			ld (debug_mark+2),a  
a9d3 18 03			jr .pastdmark  
a9d5 ..			.dmark: db "LSm"  
a9d8 f1			.pastdmark: pop af  
a9d9			endm  
# End of macro DMARK
a9d9					CALLMONITOR 
a9d9 cd 6b ee			call debug_vector  
a9dc				endm  
# End of macro CALLMONITOR
a9dc				endif 
a9dc			 
a9dc					; skip opcode 
a9dc 23					inc hl  
a9dd					; skip next ptr 
a9dd 23					inc hl  
a9de 23					inc hl 
a9df					; skip len 
a9df 7e					ld a, (hl)   ; save length to add 
a9e0				if DEBUG_FORTH_WORDS 
a9e0					DMARK "LS2" 
a9e0 f5				push af  
a9e1 3a f5 a9			ld a, (.dmark)  
a9e4 32 5e ee			ld (debug_mark),a  
a9e7 3a f6 a9			ld a, (.dmark+1)  
a9ea 32 5f ee			ld (debug_mark+1),a  
a9ed 3a f7 a9			ld a, (.dmark+2)  
a9f0 32 60 ee			ld (debug_mark+2),a  
a9f3 18 03			jr .pastdmark  
a9f5 ..			.dmark: db "LS2"  
a9f8 f1			.pastdmark: pop af  
a9f9			endm  
# End of macro DMARK
a9f9					CALLMONITOR 
a9f9 cd 6b ee			call debug_vector  
a9fc				endm  
# End of macro CALLMONITOR
a9fc				endif 
a9fc			 
a9fc				; skip zero term and other uword defs to position right at the exec code 
a9fc 06 04			ld b, 4 
a9fe 80				add a,b 
a9ff			 
a9ff cd db 8c			call addatohl 
aa02					; save this location 
aa02				 
aa02			.ulunotfound: 
aa02 cd cc 99			call forth_push_numhl 
aa05						 
aa05				NEXTW 
aa05 cd 68 ee			call parse_vector 
aa08 c3 af 9d			jp macro_next 
aa0b				endm 
# End of macro NEXTW
aa0b			.LIST: 
aa0b			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
aa0b 5c				db WORD_SYS_CORE+72             
aa0c 0d ac			dw .FORGET            
aa0e 05				db 4 + 1 
aa0f .. 00			db "LIST",0              
aa14				endm 
# End of macro CWHEAD
aa14			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
aa14			; | | The quoted word must be in upper case. 
aa14			if DEBUG_FORTH_WORDS_KEY 
aa14				DMARK "LST" 
aa14 f5				push af  
aa15 3a 29 aa			ld a, (.dmark)  
aa18 32 5e ee			ld (debug_mark),a  
aa1b 3a 2a aa			ld a, (.dmark+1)  
aa1e 32 5f ee			ld (debug_mark+1),a  
aa21 3a 2b aa			ld a, (.dmark+2)  
aa24 32 60 ee			ld (debug_mark+2),a  
aa27 18 03			jr .pastdmark  
aa29 ..			.dmark: db "LST"  
aa2c f1			.pastdmark: pop af  
aa2d			endm  
# End of macro DMARK
aa2d				CALLMONITOR 
aa2d cd 6b ee			call debug_vector  
aa30				endm  
# End of macro CALLMONITOR
aa30			endif 
aa30			 
aa30				FORTH_DSP_VALUEHL 
aa30 cd c8 9b			call macro_dsp_valuehl 
aa33				endm 
# End of macro FORTH_DSP_VALUEHL
aa33			 
aa33 e5				push hl 
aa34				FORTH_DSP_POP 
aa34 cd 80 9c			call macro_forth_dsp_pop 
aa37				endm 
# End of macro FORTH_DSP_POP
aa37 c1				pop bc 
aa38			 
aa38			; Start format of scratch string 
aa38			 
aa38 21 b4 e2			ld hl, scratch 
aa3b			 
aa3b			;	ld a, ':' 
aa3b 36 3a			ld (hl),':' 
aa3d 23				inc hl 
aa3e			;	ld a, ' ' 
aa3e 36 20			ld (hl), ' ' 
aa40			 
aa40				; Get ptr to the word we need to look up 
aa40			 
aa40			;		FORTH_DSP_VALUEHL 
aa40				;v5 FORTH_DSP_VALUE 
aa40			; TODO type check 
aa40			;		inc hl    ; Skip type check  
aa40			;		push hl 
aa40			;		ex de, hl    ; put into DE 
aa40			 
aa40			 
aa40 21 3c e6			ld hl, baseram 
aa43				;ld hl, baseusermem 
aa43			 
aa43 e5			push hl   ; sacreifical push 
aa44			 
aa44			.ldouscanm: 
aa44 e1			pop hl 
aa45			.ldouscan: 
aa45			if DEBUG_FORTH_WORDS 
aa45				DMARK "LSs" 
aa45 f5				push af  
aa46 3a 5a aa			ld a, (.dmark)  
aa49 32 5e ee			ld (debug_mark),a  
aa4c 3a 5b aa			ld a, (.dmark+1)  
aa4f 32 5f ee			ld (debug_mark+1),a  
aa52 3a 5c aa			ld a, (.dmark+2)  
aa55 32 60 ee			ld (debug_mark+2),a  
aa58 18 03			jr .pastdmark  
aa5a ..			.dmark: db "LSs"  
aa5d f1			.pastdmark: pop af  
aa5e			endm  
# End of macro DMARK
aa5e				CALLMONITOR 
aa5e cd 6b ee			call debug_vector  
aa61				endm  
# End of macro CALLMONITOR
aa61			endif 
aa61			; skip dict stub 
aa61 cd e1 9e			call forth_tok_next 
aa64			 
aa64			 
aa64			; while we have words to look for 
aa64			 
aa64 7e			ld a, (hl)      
aa65			if DEBUG_FORTH_WORDS 
aa65				DMARK "LSk" 
aa65 f5				push af  
aa66 3a 7a aa			ld a, (.dmark)  
aa69 32 5e ee			ld (debug_mark),a  
aa6c 3a 7b aa			ld a, (.dmark+1)  
aa6f 32 5f ee			ld (debug_mark+1),a  
aa72 3a 7c aa			ld a, (.dmark+2)  
aa75 32 60 ee			ld (debug_mark+2),a  
aa78 18 03			jr .pastdmark  
aa7a ..			.dmark: db "LSk"  
aa7d f1			.pastdmark: pop af  
aa7e			endm  
# End of macro DMARK
aa7e				CALLMONITOR 
aa7e cd 6b ee			call debug_vector  
aa81				endm  
# End of macro CALLMONITOR
aa81			endif 
aa81				;cp WORD_SYS_END 
aa81				;jp z, .lunotfound 
aa81			 
aa81					; if we hit non uwords then gone too far 
aa81 fe 01				cp WORD_SYS_UWORD 
aa83 c2 c0 ab				jp nz, .lunotfound 
aa86			 
aa86				if DEBUG_FORTH_WORDS 
aa86					DMARK "LSu" 
aa86 f5				push af  
aa87 3a 9b aa			ld a, (.dmark)  
aa8a 32 5e ee			ld (debug_mark),a  
aa8d 3a 9c aa			ld a, (.dmark+1)  
aa90 32 5f ee			ld (debug_mark+1),a  
aa93 3a 9d aa			ld a, (.dmark+2)  
aa96 32 60 ee			ld (debug_mark+2),a  
aa99 18 03			jr .pastdmark  
aa9b ..			.dmark: db "LSu"  
aa9e f1			.pastdmark: pop af  
aa9f			endm  
# End of macro DMARK
aa9f					CALLMONITOR 
aa9f cd 6b ee			call debug_vector  
aaa2				endm  
# End of macro CALLMONITOR
aaa2				endif 
aaa2			 
aaa2					; found a uword but is it the one we want... 
aaa2			 
aaa2 c5					push bc     ; uword to find is on bc 
aaa3 d1					pop de 
aaa4			 
aaa4 e5					push hl  ; to save the ptr 
aaa5			 
aaa5					; skip opcode 
aaa5 23					inc hl  
aaa6					; skip next ptr 
aaa6 23					inc hl  
aaa7 23					inc hl 
aaa8					; skip len 
aaa8 23					inc hl 
aaa9			 
aaa9				if DEBUG_FORTH_WORDS 
aaa9					DMARK "LSc" 
aaa9 f5				push af  
aaaa 3a be aa			ld a, (.dmark)  
aaad 32 5e ee			ld (debug_mark),a  
aab0 3a bf aa			ld a, (.dmark+1)  
aab3 32 5f ee			ld (debug_mark+1),a  
aab6 3a c0 aa			ld a, (.dmark+2)  
aab9 32 60 ee			ld (debug_mark+2),a  
aabc 18 03			jr .pastdmark  
aabe ..			.dmark: db "LSc"  
aac1 f1			.pastdmark: pop af  
aac2			endm  
# End of macro DMARK
aac2					CALLMONITOR 
aac2 cd 6b ee			call debug_vector  
aac5				endm  
# End of macro CALLMONITOR
aac5				endif 
aac5			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
aac5			; ie. If WOO is defined first and then WO. Couldnt list WO. 
aac5			; Nope that has gone the other way. It needs to be exact not on first zero 
aac5			;		call strcmp 
aac5 c5					push bc 
aac6 cd 77 90				call StrictStrCmp 
aac9 c1					pop bc 
aaca c2 44 aa				jp nz, .ldouscanm 
aacd				 
aacd			 
aacd			 
aacd					; we have a uword so push its name to the stack 
aacd			 
aacd			;	   	push hl  ; save so we can move to next dict block 
aacd e1			pop hl 
aace			 
aace				if DEBUG_FORTH_WORDS 
aace					DMARK "LSm" 
aace f5				push af  
aacf 3a e3 aa			ld a, (.dmark)  
aad2 32 5e ee			ld (debug_mark),a  
aad5 3a e4 aa			ld a, (.dmark+1)  
aad8 32 5f ee			ld (debug_mark+1),a  
aadb 3a e5 aa			ld a, (.dmark+2)  
aade 32 60 ee			ld (debug_mark+2),a  
aae1 18 03			jr .pastdmark  
aae3 ..			.dmark: db "LSm"  
aae6 f1			.pastdmark: pop af  
aae7			endm  
# End of macro DMARK
aae7					CALLMONITOR 
aae7 cd 6b ee			call debug_vector  
aaea				endm  
# End of macro CALLMONITOR
aaea				endif 
aaea			 
aaea					; skip opcode 
aaea 23					inc hl  
aaeb					; skip next ptr 
aaeb 23					inc hl  
aaec 23					inc hl 
aaed					; skip len 
aaed 7e					ld a, (hl)   ; save length to add 
aaee				if DEBUG_FORTH_WORDS 
aaee					DMARK "LS2" 
aaee f5				push af  
aaef 3a 03 ab			ld a, (.dmark)  
aaf2 32 5e ee			ld (debug_mark),a  
aaf5 3a 04 ab			ld a, (.dmark+1)  
aaf8 32 5f ee			ld (debug_mark+1),a  
aafb 3a 05 ab			ld a, (.dmark+2)  
aafe 32 60 ee			ld (debug_mark+2),a  
ab01 18 03			jr .pastdmark  
ab03 ..			.dmark: db "LS2"  
ab06 f1			.pastdmark: pop af  
ab07			endm  
# End of macro DMARK
ab07					CALLMONITOR 
ab07 cd 6b ee			call debug_vector  
ab0a				endm  
# End of macro CALLMONITOR
ab0a				endif 
ab0a			 
ab0a					; save this location 
ab0a				 
ab0a e5					push hl 
ab0b			 
ab0b 23					inc hl 
ab0c 11 b6 e2				ld de, scratch+2 
ab0f 4f					ld c, a 
ab10 06 00				ld b, 0 
ab12			 
ab12				if DEBUG_FORTH_WORDS 
ab12					DMARK "LSn" 
ab12 f5				push af  
ab13 3a 27 ab			ld a, (.dmark)  
ab16 32 5e ee			ld (debug_mark),a  
ab19 3a 28 ab			ld a, (.dmark+1)  
ab1c 32 5f ee			ld (debug_mark+1),a  
ab1f 3a 29 ab			ld a, (.dmark+2)  
ab22 32 60 ee			ld (debug_mark+2),a  
ab25 18 03			jr .pastdmark  
ab27 ..			.dmark: db "LSn"  
ab2a f1			.pastdmark: pop af  
ab2b			endm  
# End of macro DMARK
ab2b					CALLMONITOR 
ab2b cd 6b ee			call debug_vector  
ab2e				endm  
# End of macro CALLMONITOR
ab2e				endif 
ab2e			 
ab2e					; copy uword name to scratch 
ab2e			 
ab2e			;		ldir 
ab2e			.licplw:	; copy uword name to scratch converting to lower case as we go 
ab2e ed a0				ldi 
ab30 1b					dec de 
ab31 1a					ld a, (de) 
ab32 cd 4c 8f				call to_lower 
ab35 12					ld (de),a 
ab36 13					inc de 
ab37 3e 00				ld a, 0 
ab39 b9					cp c 
ab3a 20 f2				jr nz, .licplw 
ab3c			 
ab3c			 
ab3c			 
ab3c 1b					dec de 
ab3d 3e 20				ld a, ' '    ; change null to space 
ab3f 12					ld (de), a 
ab40			 
ab40 13					inc de 
ab41			 
ab41 d5					push de 
ab42 c1					pop bc     ; move scratch pointer to end of word name and save it 
ab43			 
ab43 e1					pop hl 
ab44 7e					ld a, (hl) 
ab45					;inc hl 
ab45					; skip word string 
ab45 cd db 8c				call addatohl 
ab48			 
ab48 23					inc hl 
ab49			 
ab49				if DEBUG_FORTH_WORDS 
ab49					DMARK "LS3" 
ab49 f5				push af  
ab4a 3a 5e ab			ld a, (.dmark)  
ab4d 32 5e ee			ld (debug_mark),a  
ab50 3a 5f ab			ld a, (.dmark+1)  
ab53 32 5f ee			ld (debug_mark+1),a  
ab56 3a 60 ab			ld a, (.dmark+2)  
ab59 32 60 ee			ld (debug_mark+2),a  
ab5c 18 03			jr .pastdmark  
ab5e ..			.dmark: db "LS3"  
ab61 f1			.pastdmark: pop af  
ab62			endm  
# End of macro DMARK
ab62					CALLMONITOR 
ab62 cd 6b ee			call debug_vector  
ab65				endm  
# End of macro CALLMONITOR
ab65				endif 
ab65					; should now be at the start of the machine code to setup the eval of the uword 
ab65					; now locate the ptr to the string defintion 
ab65			 
ab65					; skip ld hl, 
ab65					; then load the ptr 
ab65			; TODO use get from hl ptr 
ab65 23					inc hl 
ab66 5e					ld e, (hl) 
ab67 23					inc hl 
ab68 56					ld d, (hl) 
ab69 eb					ex de, hl 
ab6a			 
ab6a			 
ab6a				if DEBUG_FORTH_WORDS 
ab6a					DMARK "LSt" 
ab6a f5				push af  
ab6b 3a 7f ab			ld a, (.dmark)  
ab6e 32 5e ee			ld (debug_mark),a  
ab71 3a 80 ab			ld a, (.dmark+1)  
ab74 32 5f ee			ld (debug_mark+1),a  
ab77 3a 81 ab			ld a, (.dmark+2)  
ab7a 32 60 ee			ld (debug_mark+2),a  
ab7d 18 03			jr .pastdmark  
ab7f ..			.dmark: db "LSt"  
ab82 f1			.pastdmark: pop af  
ab83			endm  
# End of macro DMARK
ab83					CALLMONITOR 
ab83 cd 6b ee			call debug_vector  
ab86				endm  
# End of macro CALLMONITOR
ab86				endif 
ab86			 
ab86			; cant push right now due to tokenised strings  
ab86			 
ab86			; get the destination of where to copy this definition to. 
ab86			 
ab86 c5					push bc 
ab87 d1					pop de 
ab88			 
ab88 7e			.listl:         ld a,(hl) 
ab89			;		cp 0 
ab89 b7					or a 
ab8a 28 09				jr z, .lreplsp     ; replace zero with space 
ab8c					;cp FORTH_END_BUFFER 
ab8c fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
ab8e 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
ab90				 
ab90					; just copy this char as is then 
ab90			 
ab90 12					ld (de), a 
ab91			 
ab91 23			.listnxt:	inc hl 
ab92 13					inc de 
ab93 18 f3				jr .listl 
ab95			 
ab95 3e 20		.lreplsp:	ld a,' ' 
ab97 12					ld (de), a 
ab98 18 f7				jr .listnxt 
ab9a			 
ab9a			; close up uword def 
ab9a			 
ab9a			.listdone: 
ab9a 12					ld (de), a 
ab9b 13					inc de 
ab9c 3e 00				ld a, 0 
ab9e 12					ld (de), a 
ab9f			 
ab9f			; now have def so clean up and push to stack 
ab9f			 
ab9f 21 b4 e2				ld hl, scratch 
aba2				if DEBUG_FORTH_WORDS 
aba2					DMARK "Ltp" 
aba2 f5				push af  
aba3 3a b7 ab			ld a, (.dmark)  
aba6 32 5e ee			ld (debug_mark),a  
aba9 3a b8 ab			ld a, (.dmark+1)  
abac 32 5f ee			ld (debug_mark+1),a  
abaf 3a b9 ab			ld a, (.dmark+2)  
abb2 32 60 ee			ld (debug_mark+2),a  
abb5 18 03			jr .pastdmark  
abb7 ..			.dmark: db "Ltp"  
abba f1			.pastdmark: pop af  
abbb			endm  
# End of macro DMARK
abbb					CALLMONITOR 
abbb cd 6b ee			call debug_vector  
abbe				endm  
# End of macro CALLMONITOR
abbe				endif 
abbe			 
abbe 18 22			jr .listpush 
abc0			 
abc0			;.lnuword:	pop hl 
abc0			;		call forth_tok_next 
abc0			;		jp .ldouscan  
abc0			 
abc0			.lunotfound:		  
abc0			 
abc0				if DEBUG_FORTH_WORDS 
abc0					DMARK "LSn" 
abc0 f5				push af  
abc1 3a d5 ab			ld a, (.dmark)  
abc4 32 5e ee			ld (debug_mark),a  
abc7 3a d6 ab			ld a, (.dmark+1)  
abca 32 5f ee			ld (debug_mark+1),a  
abcd 3a d7 ab			ld a, (.dmark+2)  
abd0 32 60 ee			ld (debug_mark+2),a  
abd3 18 03			jr .pastdmark  
abd5 ..			.dmark: db "LSn"  
abd8 f1			.pastdmark: pop af  
abd9			endm  
# End of macro DMARK
abd9					CALLMONITOR 
abd9 cd 6b ee			call debug_vector  
abdc				endm  
# End of macro CALLMONITOR
abdc				endif 
abdc			 
abdc					 
abdc			;		FORTH_DSP_POP 
abdc			;		ld hl, .luno 
abdc			 
abdc					NEXTW			 
abdc cd 68 ee			call parse_vector 
abdf c3 af 9d			jp macro_next 
abe2				endm 
# End of macro NEXTW
abe2			 
abe2			.listpush: 
abe2				if DEBUG_FORTH_WORDS 
abe2					DMARK "LS>" 
abe2 f5				push af  
abe3 3a f7 ab			ld a, (.dmark)  
abe6 32 5e ee			ld (debug_mark),a  
abe9 3a f8 ab			ld a, (.dmark+1)  
abec 32 5f ee			ld (debug_mark+1),a  
abef 3a f9 ab			ld a, (.dmark+2)  
abf2 32 60 ee			ld (debug_mark+2),a  
abf5 18 03			jr .pastdmark  
abf7 ..			.dmark: db "LS>"  
abfa f1			.pastdmark: pop af  
abfb			endm  
# End of macro DMARK
abfb					CALLMONITOR 
abfb cd 6b ee			call debug_vector  
abfe				endm  
# End of macro CALLMONITOR
abfe				endif 
abfe cd 36 9a				call forth_push_str 
ac01			 
ac01			 
ac01			 
ac01					NEXTW 
ac01 cd 68 ee			call parse_vector 
ac04 c3 af 9d			jp macro_next 
ac07				endm 
# End of macro NEXTW
ac07			 
ac07			;.luno:    db "Word not found",0 
ac07			 
ac07			 
ac07			 
ac07			 
ac07			 
ac07			;		push hl   ; save pointer to start of uword def string 
ac07			; 
ac07			;; look for FORTH_EOL_LINE 
ac07			;		ld a, FORTH_END_BUFFER 
ac07			;		call strlent 
ac07			; 
ac07			;		inc hl		 ; space for coln def 
ac07			;		inc hl 
ac07			;		inc hl          ; space for terms 
ac07			;		inc hl 
ac07			; 
ac07			;		ld a, 20   ; TODO get actual length 
ac07			;		call addatohl    ; include a random amount of room for the uword name 
ac07			; 
ac07			;		 
ac07			;	if DEBUG_FORTH_WORDS 
ac07			;		DMARK "Lt1" 
ac07			;		CALLMONITOR 
ac07			;	endif 
ac07			;		 
ac07			; 
ac07			;; malloc space for the string because we cant change it 
ac07			; 
ac07			;		call malloc 
ac07			;	if DEBUG_FORTH_MALLOC_GUARD 
ac07			;		push af 
ac07			;		call ishlzero 
ac07			;		pop af 
ac07			;		 
ac07			;		call z,malloc_error 
ac07			;	endif 
ac07			; 
ac07			;	if DEBUG_FORTH_WORDS 
ac07			;		DMARK "Lt2" 
ac07			;		CALLMONITOR 
ac07			;	endif 
ac07			;		pop de 
ac07			;		push hl    ; push the malloc to release later 
ac07			;		push hl   ;  push back a copy for the later stack push 
ac07			;		 
ac07			;; copy the string swapping out the zero terms for spaces 
ac07			; 
ac07			;		; de has our source 
ac07			;		; hl has our dest 
ac07			; 
ac07			;; add the coln def 
ac07			; 
ac07			;		ld a, ':' 
ac07			;		ld (hl), a 
ac07			;		inc hl 
ac07			;		ld a, ' ' 
ac07			;		ld (hl), a 
ac07			;		inc hl 
ac07			; 
ac07			;; add the uname word 
ac07			;		push de   ; save our string for now 
ac07			;		ex de, hl 
ac07			; 
ac07			;		FORTH_DSP_VALUE 
ac07			;		;v5 FORTH_DSP_VALUE 
ac07			; 
ac07			;		inc hl   ; skip type but we know by now this is OK 
ac07			; 
ac07			;.luword:	ld a,(hl) 
ac07			;		cp 0 
ac07			;		jr z, .luword2 
ac07			;		ld (de), a 
ac07			;		inc de 
ac07			;		inc hl 
ac07			;		jr .luword 
ac07			; 
ac07			;.luword2:	ld a, ' ' 
ac07			;		ld (de), a 
ac07			;;		inc hl 
ac07			;;		inc de 
ac07			;;		ld (de), a 
ac07			;;		inc hl 
ac07			;		inc de 
ac07			; 
ac07			;		ex de, hl 
ac07			;		pop de 
ac07			;		 
ac07			;		 
ac07			; 
ac07			;; detoken that string and copy it 
ac07			; 
ac07			;	if DEBUG_FORTH_WORDS 
ac07			;		DMARK "Lt2" 
ac07			;		CALLMONITOR 
ac07			;	endif 
ac07			;.ldetok:	ld a, (de) 
ac07			;		cp FORTH_END_BUFFER 
ac07			;		jr z, .ldetokend 
ac07			;		; swap out any zero term for space 
ac07			;		cp 0 
ac07			;		jr nz, .ldetoknext 
ac07			;		ld a, ' ' 
ac07			; 
ac07			;	if DEBUG_FORTH_WORDS 
ac07			;		DMARK "LtS" 
ac07			;		CALLMONITOR 
ac07			;	endif 
ac07			;.ldetoknext:	ld (hl), a 
ac07			;		inc de 
ac07			;		inc hl 
ac07			;		jr .ldetok 
ac07			; 
ac07			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ac07			;		ld (hl), a  
ac07			; 
ac07			;; free that temp malloc 
ac07			; 
ac07			;		pop hl    
ac07			; 
ac07			;	if DEBUG_FORTH_WORDS 
ac07			;		DMARK "Lt4" 
ac07			;		CALLMONITOR 
ac07			;	endif 
ac07			;		call forth_apushstrhl 
ac07			; 
ac07			;		; get rid of temp malloc area 
ac07			; 
ac07			;		pop hl 
ac07			;		call free 
ac07			; 
ac07			;		jr .ludone 
ac07			; 
ac07			;.lnuword:	pop hl 
ac07			;		call forth_tok_next 
ac07			;		jp .ldouscan  
ac07			; 
ac07			;.ludone:		 pop hl 
ac07			; 
ac07					NEXTW 
ac07 cd 68 ee			call parse_vector 
ac0a c3 af 9d			jp macro_next 
ac0d				endm 
# End of macro NEXTW
ac0d			 
ac0d			.FORGET: 
ac0d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ac0d 5d				db WORD_SYS_CORE+73             
ac0e 88 ac			dw .NOP            
ac10 07				db 6 + 1 
ac11 .. 00			db "FORGET",0              
ac18				endm 
# End of macro CWHEAD
ac18			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ac18			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ac18			; | |  
ac18			; | | e.g. "MORE" forget 
ac18					if DEBUG_FORTH_WORDS_KEY 
ac18						DMARK "FRG" 
ac18 f5				push af  
ac19 3a 2d ac			ld a, (.dmark)  
ac1c 32 5e ee			ld (debug_mark),a  
ac1f 3a 2e ac			ld a, (.dmark+1)  
ac22 32 5f ee			ld (debug_mark+1),a  
ac25 3a 2f ac			ld a, (.dmark+2)  
ac28 32 60 ee			ld (debug_mark+2),a  
ac2b 18 03			jr .pastdmark  
ac2d ..			.dmark: db "FRG"  
ac30 f1			.pastdmark: pop af  
ac31			endm  
# End of macro DMARK
ac31						CALLMONITOR 
ac31 cd 6b ee			call debug_vector  
ac34				endm  
# End of macro CALLMONITOR
ac34					endif 
ac34			 
ac34				; find uword 
ac34			        ; update start of word with "_" 
ac34				; replace uword with deleted flag 
ac34			 
ac34			 
ac34			;	if DEBUG_FORTH_WORDS 
ac34			;		DMARK "FOG" 
ac34			;		CALLMONITOR 
ac34			;	endif 
ac34			 
ac34			 
ac34					; Get ptr to the word we need to look up 
ac34			 
ac34					FORTH_DSP_VALUEHL 
ac34 cd c8 9b			call macro_dsp_valuehl 
ac37				endm 
# End of macro FORTH_DSP_VALUEHL
ac37					;v5 FORTH_DSP_VALUE 
ac37				; TODO type check 
ac37			;		inc hl    ; Skip type check  
ac37 e5					push hl 
ac38 c1					pop bc 
ac39			;		ex de, hl    ; put into DE 
ac39			 
ac39			 
ac39 21 3c e6				ld hl, baseram 
ac3c					;ld hl, baseusermem 
ac3c			 
ac3c				; skip dict stub 
ac3c			;	call forth_tok_next 
ac3c e5			push hl   ; sacreifical push 
ac3d			 
ac3d			.fldouscanm: 
ac3d e1				pop hl 
ac3e			.fldouscan: 
ac3e			;	if DEBUG_FORTH_WORDS 
ac3e			;		DMARK "LSs" 
ac3e			;		CALLMONITOR 
ac3e			;	endif 
ac3e				; skip dict stub 
ac3e cd e1 9e				call forth_tok_next 
ac41			 
ac41			 
ac41			; while we have words to look for 
ac41			 
ac41 7e				ld a, (hl)      
ac42			;	if DEBUG_FORTH_WORDS 
ac42			;		DMARK "LSk" 
ac42			;		CALLMONITOR 
ac42			;	endif 
ac42 fe 00				cp WORD_SYS_END 
ac44 ca 7f ac				jp z, .flunotfound 
ac47 fe 01				cp WORD_SYS_UWORD 
ac49 c2 3e ac				jp nz, .fldouscan 
ac4c			 
ac4c			;	if DEBUG_FORTH_WORDS 
ac4c			;		DMARK "LSu" 
ac4c			;		CALLMONITOR 
ac4c			;	endif 
ac4c			 
ac4c					; found a uword but is it the one we want... 
ac4c			 
ac4c c5					push bc     ; uword to find is on bc 
ac4d d1					pop de 
ac4e			 
ac4e e5					push hl  ; to save the ptr 
ac4f			 
ac4f					; skip opcode 
ac4f 23					inc hl  
ac50					; skip next ptr 
ac50 23					inc hl  
ac51 23					inc hl 
ac52					; skip len 
ac52 23					inc hl 
ac53			 
ac53			;	if DEBUG_FORTH_WORDS 
ac53			;		DMARK "LSc" 
ac53			;		CALLMONITOR 
ac53			;	endif 
ac53 cd 6b 90				call strcmp 
ac56 c2 3d ac				jp nz, .fldouscanm 
ac59			; 
ac59			; 
ac59			;; while we have words to look for 
ac59			; 
ac59			;.fdouscan:	ld a, (hl)      
ac59			;	if DEBUG_FORTH_WORDS 
ac59			;		DMARK "LSs" 
ac59			;		CALLMONITOR 
ac59			;	endif 
ac59			;		cp WORD_SYS_END 
ac59			;		jp z, .fudone 
ac59			;		cp WORD_SYS_UWORD 
ac59			;		jp nz, .fnuword 
ac59			; 
ac59			;	if DEBUG_FORTH_WORDS 
ac59			;		DMARK "FGu" 
ac59			;		CALLMONITOR 
ac59			;	endif 
ac59			; 
ac59			;		; found a uword but is it the one we want... 
ac59			; 
ac59			; 
ac59			;	        pop de   ; get back the dsp name 
ac59			;		push de 
ac59			; 
ac59			;		push hl  ; to save the ptr 
ac59			; 
ac59			;		; skip opcode 
ac59			;		inc hl  
ac59			;		; skip next ptr 
ac59			;		inc hl  
ac59			;		inc hl 
ac59			;		; skip len 
ac59			;		inc hl 
ac59			; 
ac59			;	if DEBUG_FORTH_WORDS 
ac59			;		DMARK "FGc" 
ac59			;		CALLMONITOR 
ac59			;	endif 
ac59			;		call strcmp 
ac59			;		jp nz, .fnuword 
ac59			 
ac59			 
ac59 e1			pop hl 
ac5a			 
ac5a				 
ac5a				if DEBUG_FORTH_WORDS 
ac5a					DMARK "FGm" 
ac5a f5				push af  
ac5b 3a 6f ac			ld a, (.dmark)  
ac5e 32 5e ee			ld (debug_mark),a  
ac61 3a 70 ac			ld a, (.dmark+1)  
ac64 32 5f ee			ld (debug_mark+1),a  
ac67 3a 71 ac			ld a, (.dmark+2)  
ac6a 32 60 ee			ld (debug_mark+2),a  
ac6d 18 03			jr .pastdmark  
ac6f ..			.dmark: db "FGm"  
ac72 f1			.pastdmark: pop af  
ac73			endm  
# End of macro DMARK
ac73					CALLMONITOR 
ac73 cd 6b ee			call debug_vector  
ac76				endm  
# End of macro CALLMONITOR
ac76				endif 
ac76			 
ac76			 
ac76			 
ac76					; we have a uword so push its name to the stack 
ac76			 
ac76			;	   	push hl  ; save so we can move to next dict block 
ac76			;pop hl 
ac76			 
ac76					; update opcode to deleted 
ac76			;		ld a, WORD_SYS_DELETED 
ac76 36 03				ld (hl), WORD_SYS_DELETED 
ac78			 
ac78 23					inc hl  
ac79					; skip next ptr 
ac79 23					inc hl  
ac7a 23					inc hl 
ac7b					; skip len 
ac7b 23					inc hl 
ac7c			 
ac7c					; TODO change parser to skip deleted words but for now mark it out 
ac7c 3e 5f				ld a, "_" 
ac7e 77					ld  (hl),a 
ac7f			 
ac7f			;		jr .fudone 
ac7f			; 
ac7f			;.fnuword:	pop hl 
ac7f			;		call forth_tok_next 
ac7f			;		jp .fdouscan  
ac7f			 
ac7f			.flunotfound:		  
ac7f			 
ac7f			 
ac7f					 
ac7f					FORTH_DSP_POP 
ac7f cd 80 9c			call macro_forth_dsp_pop 
ac82				endm 
# End of macro FORTH_DSP_POP
ac82			;		ld hl, .luno 
ac82			;.fudone:		 pop hl 
ac82					NEXTW 
ac82 cd 68 ee			call parse_vector 
ac85 c3 af 9d			jp macro_next 
ac88				endm 
# End of macro NEXTW
ac88			.NOP: 
ac88				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
ac88 61				db WORD_SYS_CORE+77             
ac89 b2 ac			dw .COMO            
ac8b 04				db 3 + 1 
ac8c .. 00			db "NOP",0              
ac90				endm 
# End of macro CWHEAD
ac90			; | NOP (  --  ) Do nothing | DONE 
ac90					if DEBUG_FORTH_WORDS_KEY 
ac90						DMARK "NOP" 
ac90 f5				push af  
ac91 3a a5 ac			ld a, (.dmark)  
ac94 32 5e ee			ld (debug_mark),a  
ac97 3a a6 ac			ld a, (.dmark+1)  
ac9a 32 5f ee			ld (debug_mark+1),a  
ac9d 3a a7 ac			ld a, (.dmark+2)  
aca0 32 60 ee			ld (debug_mark+2),a  
aca3 18 03			jr .pastdmark  
aca5 ..			.dmark: db "NOP"  
aca8 f1			.pastdmark: pop af  
aca9			endm  
# End of macro DMARK
aca9						CALLMONITOR 
aca9 cd 6b ee			call debug_vector  
acac				endm  
# End of macro CALLMONITOR
acac					endif 
acac				       NEXTW 
acac cd 68 ee			call parse_vector 
acaf c3 af 9d			jp macro_next 
acb2				endm 
# End of macro NEXTW
acb2			.COMO: 
acb2				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
acb2 6e				db WORD_SYS_CORE+90             
acb3 07 ad			dw .COMC            
acb5 02				db 1 + 1 
acb6 .. 00			db "(",0              
acb8				endm 
# End of macro CWHEAD
acb8			; | ( ( -- )  Start of comment | DONE 
acb8			 
acb8			 
acb8 2a b5 e5				ld hl, ( os_tok_ptr) 
acbb 11 ff ac			ld de, .closepar 
acbe					 
acbe					if DEBUG_FORTH_WORDS 
acbe						DMARK ").." 
acbe f5				push af  
acbf 3a d3 ac			ld a, (.dmark)  
acc2 32 5e ee			ld (debug_mark),a  
acc5 3a d4 ac			ld a, (.dmark+1)  
acc8 32 5f ee			ld (debug_mark+1),a  
accb 3a d5 ac			ld a, (.dmark+2)  
acce 32 60 ee			ld (debug_mark+2),a  
acd1 18 03			jr .pastdmark  
acd3 ..			.dmark: db ").."  
acd6 f1			.pastdmark: pop af  
acd7			endm  
# End of macro DMARK
acd7						CALLMONITOR 
acd7 cd 6b ee			call debug_vector  
acda				endm  
# End of macro CALLMONITOR
acda					endif 
acda cd ac 9e			call findnexttok  
acdd			 
acdd					if DEBUG_FORTH_WORDS 
acdd						DMARK "IF5" 
acdd f5				push af  
acde 3a f2 ac			ld a, (.dmark)  
ace1 32 5e ee			ld (debug_mark),a  
ace4 3a f3 ac			ld a, (.dmark+1)  
ace7 32 5f ee			ld (debug_mark+1),a  
acea 3a f4 ac			ld a, (.dmark+2)  
aced 32 60 ee			ld (debug_mark+2),a  
acf0 18 03			jr .pastdmark  
acf2 ..			.dmark: db "IF5"  
acf5 f1			.pastdmark: pop af  
acf6			endm  
# End of macro DMARK
acf6						CALLMONITOR 
acf6 cd 6b ee			call debug_vector  
acf9				endm  
# End of macro CALLMONITOR
acf9					endif 
acf9				; replace below with ) exec using tok_ptr 
acf9 22 b5 e5			ld (os_tok_ptr), hl 
acfc c3 30 9e			jp exec1 
acff			 
acff .. 00			.closepar:   db ")",0 
ad01			 
ad01				       NEXTW 
ad01 cd 68 ee			call parse_vector 
ad04 c3 af 9d			jp macro_next 
ad07				endm 
# End of macro NEXTW
ad07			.COMC: 
ad07				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ad07 6f				db WORD_SYS_CORE+91             
ad08 13 ad			dw .SCRATCH            
ad0a 02				db 1 + 1 
ad0b .. 00			db ")",0              
ad0d				endm 
# End of macro CWHEAD
ad0d			; | ) ( -- )  End of comment |  DONE  
ad0d				       NEXTW 
ad0d cd 68 ee			call parse_vector 
ad10 c3 af 9d			jp macro_next 
ad13				endm 
# End of macro NEXTW
ad13			 
ad13			.SCRATCH: 
ad13				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ad13 6f				db WORD_SYS_CORE+91             
ad14 51 ad			dw .INC            
ad16 08				db 7 + 1 
ad17 .. 00			db "SCRATCH",0              
ad1f				endm 
# End of macro CWHEAD
ad1f			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ad1f			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ad1f			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ad1f			; | |  
ad1f			; | | e.g.    : score $00 scratch ; 
ad1f			; | |  
ad1f			; | | $00 score ! 
ad1f			; | | $01 score +! 
ad1f			; | |  
ad1f			; | | e.g.   : varword $0a scratch ;  
ad1f			; | | 
ad1f			; | | $8000 varword ! 
ad1f					if DEBUG_FORTH_WORDS_KEY 
ad1f						DMARK "SCR" 
ad1f f5				push af  
ad20 3a 34 ad			ld a, (.dmark)  
ad23 32 5e ee			ld (debug_mark),a  
ad26 3a 35 ad			ld a, (.dmark+1)  
ad29 32 5f ee			ld (debug_mark+1),a  
ad2c 3a 36 ad			ld a, (.dmark+2)  
ad2f 32 60 ee			ld (debug_mark+2),a  
ad32 18 03			jr .pastdmark  
ad34 ..			.dmark: db "SCR"  
ad37 f1			.pastdmark: pop af  
ad38			endm  
# End of macro DMARK
ad38						CALLMONITOR 
ad38 cd 6b ee			call debug_vector  
ad3b				endm  
# End of macro CALLMONITOR
ad3b					endif 
ad3b			 
ad3b					FORTH_DSP_VALUEHL 
ad3b cd c8 9b			call macro_dsp_valuehl 
ad3e				endm 
# End of macro FORTH_DSP_VALUEHL
ad3e				 
ad3e					FORTH_DSP_POP 
ad3e cd 80 9c			call macro_forth_dsp_pop 
ad41				endm 
# End of macro FORTH_DSP_POP
ad41			 
ad41 7d					ld a, l 
ad42 21 d9 e7				ld hl, os_var_array 
ad45 cd db 8c				call addatohl 
ad48			 
ad48 cd cc 99				call forth_push_numhl 
ad4b			 
ad4b				       NEXTW 
ad4b cd 68 ee			call parse_vector 
ad4e c3 af 9d			jp macro_next 
ad51				endm 
# End of macro NEXTW
ad51			 
ad51			.INC: 
ad51				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ad51 6f				db WORD_SYS_CORE+91             
ad52 aa ad			dw .DEC            
ad54 03				db 2 + 1 
ad55 .. 00			db "+!",0              
ad58				endm 
# End of macro CWHEAD
ad58			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ad58					if DEBUG_FORTH_WORDS_KEY 
ad58						DMARK "+s_" 
ad58 f5				push af  
ad59 3a 6d ad			ld a, (.dmark)  
ad5c 32 5e ee			ld (debug_mark),a  
ad5f 3a 6e ad			ld a, (.dmark+1)  
ad62 32 5f ee			ld (debug_mark+1),a  
ad65 3a 6f ad			ld a, (.dmark+2)  
ad68 32 60 ee			ld (debug_mark+2),a  
ad6b 18 03			jr .pastdmark  
ad6d ..			.dmark: db "+s_"  
ad70 f1			.pastdmark: pop af  
ad71			endm  
# End of macro DMARK
ad71						CALLMONITOR 
ad71 cd 6b ee			call debug_vector  
ad74				endm  
# End of macro CALLMONITOR
ad74					endif 
ad74			 
ad74					FORTH_DSP_VALUEHL 
ad74 cd c8 9b			call macro_dsp_valuehl 
ad77				endm 
# End of macro FORTH_DSP_VALUEHL
ad77			 
ad77 e5					push hl   ; save address 
ad78			 
ad78					FORTH_DSP_POP 
ad78 cd 80 9c			call macro_forth_dsp_pop 
ad7b				endm 
# End of macro FORTH_DSP_POP
ad7b			 
ad7b					FORTH_DSP_VALUEHL 
ad7b cd c8 9b			call macro_dsp_valuehl 
ad7e				endm 
# End of macro FORTH_DSP_VALUEHL
ad7e			 
ad7e e5					push hl 
ad7f					FORTH_DSP_POP 
ad7f cd 80 9c			call macro_forth_dsp_pop 
ad82				endm 
# End of macro FORTH_DSP_POP
ad82 e1					pop hl 
ad83			 
ad83					; hl contains value to add to byte at a 
ad83				 
ad83 eb					ex de, hl 
ad84			 
ad84 e1					pop hl 
ad85			 
ad85					if DEBUG_FORTH_WORDS 
ad85						DMARK "INC" 
ad85 f5				push af  
ad86 3a 9a ad			ld a, (.dmark)  
ad89 32 5e ee			ld (debug_mark),a  
ad8c 3a 9b ad			ld a, (.dmark+1)  
ad8f 32 5f ee			ld (debug_mark+1),a  
ad92 3a 9c ad			ld a, (.dmark+2)  
ad95 32 60 ee			ld (debug_mark+2),a  
ad98 18 03			jr .pastdmark  
ad9a ..			.dmark: db "INC"  
ad9d f1			.pastdmark: pop af  
ad9e			endm  
# End of macro DMARK
ad9e						CALLMONITOR 
ad9e cd 6b ee			call debug_vector  
ada1				endm  
# End of macro CALLMONITOR
ada1					endif 
ada1			 
ada1 7e					ld a,(hl) 
ada2 83					add e 
ada3 77					ld (hl),a 
ada4			 
ada4			 
ada4			 
ada4				       NEXTW 
ada4 cd 68 ee			call parse_vector 
ada7 c3 af 9d			jp macro_next 
adaa				endm 
# End of macro NEXTW
adaa			 
adaa			.DEC: 
adaa				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
adaa 6f				db WORD_SYS_CORE+91             
adab 01 ae			dw .INC2            
adad 03				db 2 + 1 
adae .. 00			db "-!",0              
adb1				endm 
# End of macro CWHEAD
adb1			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
adb1					if DEBUG_FORTH_WORDS_KEY 
adb1						DMARK "-s_" 
adb1 f5				push af  
adb2 3a c6 ad			ld a, (.dmark)  
adb5 32 5e ee			ld (debug_mark),a  
adb8 3a c7 ad			ld a, (.dmark+1)  
adbb 32 5f ee			ld (debug_mark+1),a  
adbe 3a c8 ad			ld a, (.dmark+2)  
adc1 32 60 ee			ld (debug_mark+2),a  
adc4 18 03			jr .pastdmark  
adc6 ..			.dmark: db "-s_"  
adc9 f1			.pastdmark: pop af  
adca			endm  
# End of macro DMARK
adca						CALLMONITOR 
adca cd 6b ee			call debug_vector  
adcd				endm  
# End of macro CALLMONITOR
adcd					endif 
adcd			 
adcd					FORTH_DSP_VALUEHL 
adcd cd c8 9b			call macro_dsp_valuehl 
add0				endm 
# End of macro FORTH_DSP_VALUEHL
add0			 
add0 e5					push hl   ; save address 
add1			 
add1					FORTH_DSP_POP 
add1 cd 80 9c			call macro_forth_dsp_pop 
add4				endm 
# End of macro FORTH_DSP_POP
add4			 
add4					FORTH_DSP_VALUEHL 
add4 cd c8 9b			call macro_dsp_valuehl 
add7				endm 
# End of macro FORTH_DSP_VALUEHL
add7			 
add7					; hl contains value to add to byte at a 
add7				 
add7 eb					ex de, hl 
add8			 
add8 e1					pop hl 
add9			 
add9					if DEBUG_FORTH_WORDS 
add9						DMARK "DEC" 
add9 f5				push af  
adda 3a ee ad			ld a, (.dmark)  
addd 32 5e ee			ld (debug_mark),a  
ade0 3a ef ad			ld a, (.dmark+1)  
ade3 32 5f ee			ld (debug_mark+1),a  
ade6 3a f0 ad			ld a, (.dmark+2)  
ade9 32 60 ee			ld (debug_mark+2),a  
adec 18 03			jr .pastdmark  
adee ..			.dmark: db "DEC"  
adf1 f1			.pastdmark: pop af  
adf2			endm  
# End of macro DMARK
adf2						CALLMONITOR 
adf2 cd 6b ee			call debug_vector  
adf5				endm  
# End of macro CALLMONITOR
adf5					endif 
adf5			 
adf5 7e					ld a,(hl) 
adf6 93					sub e 
adf7 77					ld (hl),a 
adf8			 
adf8			 
adf8					FORTH_DSP_POP 
adf8 cd 80 9c			call macro_forth_dsp_pop 
adfb				endm 
# End of macro FORTH_DSP_POP
adfb			 
adfb				       NEXTW 
adfb cd 68 ee			call parse_vector 
adfe c3 af 9d			jp macro_next 
ae01				endm 
# End of macro NEXTW
ae01			 
ae01			.INC2: 
ae01				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ae01 6f				db WORD_SYS_CORE+91             
ae02 b1 ae			dw .DEC2            
ae04 04				db 3 + 1 
ae05 .. 00			db "+2!",0              
ae09				endm 
# End of macro CWHEAD
ae09			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ae09			 
ae09					if DEBUG_FORTH_WORDS_KEY 
ae09						DMARK "+2s" 
ae09 f5				push af  
ae0a 3a 1e ae			ld a, (.dmark)  
ae0d 32 5e ee			ld (debug_mark),a  
ae10 3a 1f ae			ld a, (.dmark+1)  
ae13 32 5f ee			ld (debug_mark+1),a  
ae16 3a 20 ae			ld a, (.dmark+2)  
ae19 32 60 ee			ld (debug_mark+2),a  
ae1c 18 03			jr .pastdmark  
ae1e ..			.dmark: db "+2s"  
ae21 f1			.pastdmark: pop af  
ae22			endm  
# End of macro DMARK
ae22						CALLMONITOR 
ae22 cd 6b ee			call debug_vector  
ae25				endm  
# End of macro CALLMONITOR
ae25					endif 
ae25			 
ae25					; Address 
ae25			 
ae25					FORTH_DSP_VALUEHL 
ae25 cd c8 9b			call macro_dsp_valuehl 
ae28				endm 
# End of macro FORTH_DSP_VALUEHL
ae28			 
ae28 e5					push hl    ; save address 
ae29			 
ae29					; load content into de 
ae29			 
ae29 5e					ld e,(hl) 
ae2a 23					inc hl 
ae2b 56					ld d, (hl) 
ae2c			 
ae2c					if DEBUG_FORTH_WORDS 
ae2c						DMARK "+2a" 
ae2c f5				push af  
ae2d 3a 41 ae			ld a, (.dmark)  
ae30 32 5e ee			ld (debug_mark),a  
ae33 3a 42 ae			ld a, (.dmark+1)  
ae36 32 5f ee			ld (debug_mark+1),a  
ae39 3a 43 ae			ld a, (.dmark+2)  
ae3c 32 60 ee			ld (debug_mark+2),a  
ae3f 18 03			jr .pastdmark  
ae41 ..			.dmark: db "+2a"  
ae44 f1			.pastdmark: pop af  
ae45			endm  
# End of macro DMARK
ae45						CALLMONITOR 
ae45 cd 6b ee			call debug_vector  
ae48				endm  
# End of macro CALLMONITOR
ae48					endif 
ae48			 
ae48					FORTH_DSP_POP 
ae48 cd 80 9c			call macro_forth_dsp_pop 
ae4b				endm 
# End of macro FORTH_DSP_POP
ae4b			 
ae4b					; Get value to add 
ae4b			 
ae4b					FORTH_DSP_VALUE 
ae4b cd b1 9b			call macro_forth_dsp_value 
ae4e				endm 
# End of macro FORTH_DSP_VALUE
ae4e			 
ae4e					if DEBUG_FORTH_WORDS 
ae4e						DMARK "+2v" 
ae4e f5				push af  
ae4f 3a 63 ae			ld a, (.dmark)  
ae52 32 5e ee			ld (debug_mark),a  
ae55 3a 64 ae			ld a, (.dmark+1)  
ae58 32 5f ee			ld (debug_mark+1),a  
ae5b 3a 65 ae			ld a, (.dmark+2)  
ae5e 32 60 ee			ld (debug_mark+2),a  
ae61 18 03			jr .pastdmark  
ae63 ..			.dmark: db "+2v"  
ae66 f1			.pastdmark: pop af  
ae67			endm  
# End of macro DMARK
ae67						CALLMONITOR 
ae67 cd 6b ee			call debug_vector  
ae6a				endm  
# End of macro CALLMONITOR
ae6a					endif 
ae6a			 
ae6a 19					add hl, de 
ae6b			 
ae6b					if DEBUG_FORTH_WORDS 
ae6b						DMARK "+2+" 
ae6b f5				push af  
ae6c 3a 80 ae			ld a, (.dmark)  
ae6f 32 5e ee			ld (debug_mark),a  
ae72 3a 81 ae			ld a, (.dmark+1)  
ae75 32 5f ee			ld (debug_mark+1),a  
ae78 3a 82 ae			ld a, (.dmark+2)  
ae7b 32 60 ee			ld (debug_mark+2),a  
ae7e 18 03			jr .pastdmark  
ae80 ..			.dmark: db "+2+"  
ae83 f1			.pastdmark: pop af  
ae84			endm  
# End of macro DMARK
ae84						CALLMONITOR 
ae84 cd 6b ee			call debug_vector  
ae87				endm  
# End of macro CALLMONITOR
ae87					endif 
ae87			 
ae87					; move result to de 
ae87			 
ae87 eb					ex de, hl 
ae88			 
ae88					; Address 
ae88			 
ae88 e1					pop hl 
ae89			 
ae89					; save it back 
ae89			 
ae89 73					ld (hl), e 
ae8a 23					inc hl 
ae8b 72					ld (hl), d 
ae8c			 
ae8c					if DEBUG_FORTH_WORDS 
ae8c						DMARK "+2e" 
ae8c f5				push af  
ae8d 3a a1 ae			ld a, (.dmark)  
ae90 32 5e ee			ld (debug_mark),a  
ae93 3a a2 ae			ld a, (.dmark+1)  
ae96 32 5f ee			ld (debug_mark+1),a  
ae99 3a a3 ae			ld a, (.dmark+2)  
ae9c 32 60 ee			ld (debug_mark+2),a  
ae9f 18 03			jr .pastdmark  
aea1 ..			.dmark: db "+2e"  
aea4 f1			.pastdmark: pop af  
aea5			endm  
# End of macro DMARK
aea5						CALLMONITOR 
aea5 cd 6b ee			call debug_vector  
aea8				endm  
# End of macro CALLMONITOR
aea8					endif 
aea8			 
aea8			 
aea8			 
aea8					FORTH_DSP_POP 
aea8 cd 80 9c			call macro_forth_dsp_pop 
aeab				endm 
# End of macro FORTH_DSP_POP
aeab			 
aeab			 
aeab				       NEXTW 
aeab cd 68 ee			call parse_vector 
aeae c3 af 9d			jp macro_next 
aeb1				endm 
# End of macro NEXTW
aeb1			 
aeb1			.DEC2: 
aeb1				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aeb1 6f				db WORD_SYS_CORE+91             
aeb2 63 af			dw .GET2            
aeb4 04				db 3 + 1 
aeb5 .. 00			db "-2!",0              
aeb9				endm 
# End of macro CWHEAD
aeb9			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aeb9			 
aeb9			 
aeb9					if DEBUG_FORTH_WORDS_KEY 
aeb9						DMARK "-2s" 
aeb9 f5				push af  
aeba 3a ce ae			ld a, (.dmark)  
aebd 32 5e ee			ld (debug_mark),a  
aec0 3a cf ae			ld a, (.dmark+1)  
aec3 32 5f ee			ld (debug_mark+1),a  
aec6 3a d0 ae			ld a, (.dmark+2)  
aec9 32 60 ee			ld (debug_mark+2),a  
aecc 18 03			jr .pastdmark  
aece ..			.dmark: db "-2s"  
aed1 f1			.pastdmark: pop af  
aed2			endm  
# End of macro DMARK
aed2						CALLMONITOR 
aed2 cd 6b ee			call debug_vector  
aed5				endm  
# End of macro CALLMONITOR
aed5					endif 
aed5			 
aed5					; Address 
aed5			 
aed5					FORTH_DSP_VALUEHL 
aed5 cd c8 9b			call macro_dsp_valuehl 
aed8				endm 
# End of macro FORTH_DSP_VALUEHL
aed8			 
aed8 e5					push hl    ; save address 
aed9			 
aed9					; load content into de 
aed9			 
aed9 5e					ld e,(hl) 
aeda 23					inc hl 
aedb 56					ld d, (hl) 
aedc			 
aedc					if DEBUG_FORTH_WORDS 
aedc						DMARK "-2a" 
aedc f5				push af  
aedd 3a f1 ae			ld a, (.dmark)  
aee0 32 5e ee			ld (debug_mark),a  
aee3 3a f2 ae			ld a, (.dmark+1)  
aee6 32 5f ee			ld (debug_mark+1),a  
aee9 3a f3 ae			ld a, (.dmark+2)  
aeec 32 60 ee			ld (debug_mark+2),a  
aeef 18 03			jr .pastdmark  
aef1 ..			.dmark: db "-2a"  
aef4 f1			.pastdmark: pop af  
aef5			endm  
# End of macro DMARK
aef5						CALLMONITOR 
aef5 cd 6b ee			call debug_vector  
aef8				endm  
# End of macro CALLMONITOR
aef8					endif 
aef8			 
aef8					FORTH_DSP_POP 
aef8 cd 80 9c			call macro_forth_dsp_pop 
aefb				endm 
# End of macro FORTH_DSP_POP
aefb			 
aefb					; Get value to remove 
aefb			 
aefb					FORTH_DSP_VALUE 
aefb cd b1 9b			call macro_forth_dsp_value 
aefe				endm 
# End of macro FORTH_DSP_VALUE
aefe			 
aefe					if DEBUG_FORTH_WORDS 
aefe						DMARK "-2v" 
aefe f5				push af  
aeff 3a 13 af			ld a, (.dmark)  
af02 32 5e ee			ld (debug_mark),a  
af05 3a 14 af			ld a, (.dmark+1)  
af08 32 5f ee			ld (debug_mark+1),a  
af0b 3a 15 af			ld a, (.dmark+2)  
af0e 32 60 ee			ld (debug_mark+2),a  
af11 18 03			jr .pastdmark  
af13 ..			.dmark: db "-2v"  
af16 f1			.pastdmark: pop af  
af17			endm  
# End of macro DMARK
af17						CALLMONITOR 
af17 cd 6b ee			call debug_vector  
af1a				endm  
# End of macro CALLMONITOR
af1a					endif 
af1a			 
af1a eb					ex de, hl 
af1b ed 52				sbc hl, de 
af1d			 
af1d					if DEBUG_FORTH_WORDS 
af1d						DMARK "-2d" 
af1d f5				push af  
af1e 3a 32 af			ld a, (.dmark)  
af21 32 5e ee			ld (debug_mark),a  
af24 3a 33 af			ld a, (.dmark+1)  
af27 32 5f ee			ld (debug_mark+1),a  
af2a 3a 34 af			ld a, (.dmark+2)  
af2d 32 60 ee			ld (debug_mark+2),a  
af30 18 03			jr .pastdmark  
af32 ..			.dmark: db "-2d"  
af35 f1			.pastdmark: pop af  
af36			endm  
# End of macro DMARK
af36						CALLMONITOR 
af36 cd 6b ee			call debug_vector  
af39				endm  
# End of macro CALLMONITOR
af39					endif 
af39			 
af39					; move result to de 
af39			 
af39 eb					ex de, hl 
af3a			 
af3a					; Address 
af3a			 
af3a e1					pop hl 
af3b			 
af3b					; save it back 
af3b			 
af3b 73					ld (hl), e 
af3c 23					inc hl 
af3d 72					ld (hl), d 
af3e			 
af3e					if DEBUG_FORTH_WORDS 
af3e						DMARK "-2e" 
af3e f5				push af  
af3f 3a 53 af			ld a, (.dmark)  
af42 32 5e ee			ld (debug_mark),a  
af45 3a 54 af			ld a, (.dmark+1)  
af48 32 5f ee			ld (debug_mark+1),a  
af4b 3a 55 af			ld a, (.dmark+2)  
af4e 32 60 ee			ld (debug_mark+2),a  
af51 18 03			jr .pastdmark  
af53 ..			.dmark: db "-2e"  
af56 f1			.pastdmark: pop af  
af57			endm  
# End of macro DMARK
af57						CALLMONITOR 
af57 cd 6b ee			call debug_vector  
af5a				endm  
# End of macro CALLMONITOR
af5a					endif 
af5a			 
af5a			 
af5a					FORTH_DSP_POP 
af5a cd 80 9c			call macro_forth_dsp_pop 
af5d				endm 
# End of macro FORTH_DSP_POP
af5d			 
af5d			 
af5d			 
af5d				       NEXTW 
af5d cd 68 ee			call parse_vector 
af60 c3 af 9d			jp macro_next 
af63				endm 
# End of macro NEXTW
af63			.GET2: 
af63				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
af63 6f				db WORD_SYS_CORE+91             
af64 9b af			dw .BANG2            
af66 03				db 2 + 1 
af67 .. 00			db "2@",0              
af6a				endm 
# End of macro CWHEAD
af6a			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
af6a					if DEBUG_FORTH_WORDS_KEY 
af6a						DMARK "2A_" 
af6a f5				push af  
af6b 3a 7f af			ld a, (.dmark)  
af6e 32 5e ee			ld (debug_mark),a  
af71 3a 80 af			ld a, (.dmark+1)  
af74 32 5f ee			ld (debug_mark+1),a  
af77 3a 81 af			ld a, (.dmark+2)  
af7a 32 60 ee			ld (debug_mark+2),a  
af7d 18 03			jr .pastdmark  
af7f ..			.dmark: db "2A_"  
af82 f1			.pastdmark: pop af  
af83			endm  
# End of macro DMARK
af83						CALLMONITOR 
af83 cd 6b ee			call debug_vector  
af86				endm  
# End of macro CALLMONITOR
af86					endif 
af86			 
af86					FORTH_DSP_VALUEHL 
af86 cd c8 9b			call macro_dsp_valuehl 
af89				endm 
# End of macro FORTH_DSP_VALUEHL
af89			 
af89 e5					push hl   ; save address 
af8a			 
af8a					FORTH_DSP_POP 
af8a cd 80 9c			call macro_forth_dsp_pop 
af8d				endm 
# End of macro FORTH_DSP_POP
af8d			 
af8d e1					pop hl 
af8e			 
af8e 5e					ld e, (hl) 
af8f 23					inc hl 
af90 56					ld d, (hl) 
af91			 
af91 eb					ex de, hl 
af92			 
af92 cd cc 99				call forth_push_numhl 
af95			 
af95				       NEXTW 
af95 cd 68 ee			call parse_vector 
af98 c3 af 9d			jp macro_next 
af9b				endm 
# End of macro NEXTW
af9b			.BANG2: 
af9b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
af9b 6f				db WORD_SYS_CORE+91             
af9c d6 af			dw .CONFIG            
af9e 03				db 2 + 1 
af9f .. 00			db "2!",0              
afa2				endm 
# End of macro CWHEAD
afa2			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
afa2					if DEBUG_FORTH_WORDS_KEY 
afa2						DMARK "2S_" 
afa2 f5				push af  
afa3 3a b7 af			ld a, (.dmark)  
afa6 32 5e ee			ld (debug_mark),a  
afa9 3a b8 af			ld a, (.dmark+1)  
afac 32 5f ee			ld (debug_mark+1),a  
afaf 3a b9 af			ld a, (.dmark+2)  
afb2 32 60 ee			ld (debug_mark+2),a  
afb5 18 03			jr .pastdmark  
afb7 ..			.dmark: db "2S_"  
afba f1			.pastdmark: pop af  
afbb			endm  
# End of macro DMARK
afbb						CALLMONITOR 
afbb cd 6b ee			call debug_vector  
afbe				endm  
# End of macro CALLMONITOR
afbe					endif 
afbe			 
afbe					FORTH_DSP_VALUEHL 
afbe cd c8 9b			call macro_dsp_valuehl 
afc1				endm 
# End of macro FORTH_DSP_VALUEHL
afc1			 
afc1 e5					push hl   ; save address 
afc2			 
afc2			 
afc2					FORTH_DSP_POP 
afc2 cd 80 9c			call macro_forth_dsp_pop 
afc5				endm 
# End of macro FORTH_DSP_POP
afc5			 
afc5					 
afc5					FORTH_DSP_VALUEHL 
afc5 cd c8 9b			call macro_dsp_valuehl 
afc8				endm 
# End of macro FORTH_DSP_VALUEHL
afc8			 
afc8					FORTH_DSP_POP 
afc8 cd 80 9c			call macro_forth_dsp_pop 
afcb				endm 
# End of macro FORTH_DSP_POP
afcb			 
afcb eb					ex de, hl    ; value now in de 
afcc			 
afcc e1					pop hl 
afcd			 
afcd 73					ld (hl), e 
afce			 
afce 23					inc hl 
afcf			 
afcf 72					ld (hl), d 
afd0			 
afd0			 
afd0				       NEXTW 
afd0 cd 68 ee			call parse_vector 
afd3 c3 af 9d			jp macro_next 
afd6				endm 
# End of macro NEXTW
afd6			.CONFIG: 
afd6				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
afd6 6f				db WORD_SYS_CORE+91             
afd7 ea af			dw .ADTOS            
afd9 07				db 6 + 1 
afda .. 00			db "CONFIG",0              
afe1				endm 
# End of macro CWHEAD
afe1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
afe1			 
afe1 cd 40 92				call config 
afe4					NEXTW 
afe4 cd 68 ee			call parse_vector 
afe7 c3 af 9d			jp macro_next 
afea				endm 
# End of macro NEXTW
afea			 
afea			.ADTOS: 
afea				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
afea 6f				db WORD_SYS_CORE+91             
afeb 03 b0			dw .SBTOS            
afed 03				db 2 + 1 
afee .. 00			db "1+",0              
aff1				endm 
# End of macro CWHEAD
aff1			; | 1+ ( u -- u )  Increment value on TOS | DONE 
aff1			 
aff1					FORTH_DSP_VALUEHL 
aff1 cd c8 9b			call macro_dsp_valuehl 
aff4				endm 
# End of macro FORTH_DSP_VALUEHL
aff4 e5					push hl 
aff5			 
aff5					FORTH_DSP_POP 
aff5 cd 80 9c			call macro_forth_dsp_pop 
aff8				endm 
# End of macro FORTH_DSP_POP
aff8 e1					pop hl 
aff9			 
aff9 23					inc hl 
affa cd cc 99				call forth_push_numhl 
affd					 
affd					NEXTW 
affd cd 68 ee			call parse_vector 
b000 c3 af 9d			jp macro_next 
b003				endm 
# End of macro NEXTW
b003			.SBTOS: 
b003				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
b003 6f				db WORD_SYS_CORE+91             
b004 1c b0			dw .ADSTORE            
b006 03				db 2 + 1 
b007 .. 00			db "1-",0              
b00a				endm 
# End of macro CWHEAD
b00a			; | 1- ( u -- u )  Decrement value on TOS | DONE 
b00a			 
b00a					FORTH_DSP_VALUEHL 
b00a cd c8 9b			call macro_dsp_valuehl 
b00d				endm 
# End of macro FORTH_DSP_VALUEHL
b00d e5					push hl 
b00e			 
b00e					FORTH_DSP_POP 
b00e cd 80 9c			call macro_forth_dsp_pop 
b011				endm 
# End of macro FORTH_DSP_POP
b011 e1					pop hl 
b012			 
b012 2b					dec hl 
b013 cd cc 99				call forth_push_numhl 
b016					 
b016					NEXTW 
b016 cd 68 ee			call parse_vector 
b019 c3 af 9d			jp macro_next 
b01c				endm 
# End of macro NEXTW
b01c			.ADSTORE: 
b01c				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
b01c 6f				db WORD_SYS_CORE+91             
b01d 35 b0			dw .ADWSTORE            
b01f 04				db 3 + 1 
b020 .. 00			db "1+!",0              
b024				endm 
# End of macro CWHEAD
b024			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
b024			 
b024					FORTH_DSP_VALUEHL 
b024 cd c8 9b			call macro_dsp_valuehl 
b027				endm 
# End of macro FORTH_DSP_VALUEHL
b027 e5					push hl 
b028			 
b028					FORTH_DSP_POP 
b028 cd 80 9c			call macro_forth_dsp_pop 
b02b				endm 
# End of macro FORTH_DSP_POP
b02b e1					pop hl 
b02c			 
b02c 7e					ld a, (hl) 
b02d 3c					inc a 
b02e 77					ld (hl), a 
b02f					 
b02f					NEXTW 
b02f cd 68 ee			call parse_vector 
b032 c3 af 9d			jp macro_next 
b035				endm 
# End of macro NEXTW
b035			.ADWSTORE: 
b035				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
b035 6f				db WORD_SYS_CORE+91             
b036 56 b0			dw .SBSTORE            
b038 05				db 4 + 1 
b039 .. 00			db "1+2!",0              
b03e				endm 
# End of macro CWHEAD
b03e			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
b03e			 
b03e					FORTH_DSP_VALUEHL 
b03e cd c8 9b			call macro_dsp_valuehl 
b041				endm 
# End of macro FORTH_DSP_VALUEHL
b041 e5					push hl 
b042			 
b042					FORTH_DSP_POP 
b042 cd 80 9c			call macro_forth_dsp_pop 
b045				endm 
# End of macro FORTH_DSP_POP
b045 e1					pop hl 
b046			 
b046 e5					push hl 
b047			 
b047 cd 35 9d				call loadwordinhl 
b04a 23					inc hl 
b04b			 
b04b d1					pop de 
b04c eb					ex de, hl 
b04d 73					ld (hl), e 
b04e 23					inc hl 
b04f 72					ld (hl), d 
b050					 
b050					NEXTW 
b050 cd 68 ee			call parse_vector 
b053 c3 af 9d			jp macro_next 
b056				endm 
# End of macro NEXTW
b056			.SBSTORE: 
b056				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
b056 6f				db WORD_SYS_CORE+91             
b057 6f b0			dw .SBWSTORE            
b059 04				db 3 + 1 
b05a .. 00			db "1-!",0              
b05e				endm 
# End of macro CWHEAD
b05e			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
b05e			 
b05e					FORTH_DSP_VALUEHL 
b05e cd c8 9b			call macro_dsp_valuehl 
b061				endm 
# End of macro FORTH_DSP_VALUEHL
b061 e5					push hl 
b062			 
b062					FORTH_DSP_POP 
b062 cd 80 9c			call macro_forth_dsp_pop 
b065				endm 
# End of macro FORTH_DSP_POP
b065 e1					pop hl 
b066			 
b066 7e					ld a, (hl) 
b067 3d					dec a 
b068 77					ld (hl), a 
b069					 
b069					NEXTW 
b069 cd 68 ee			call parse_vector 
b06c c3 af 9d			jp macro_next 
b06f				endm 
# End of macro NEXTW
b06f			.SBWSTORE: 
b06f				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
b06f 6f				db WORD_SYS_CORE+91             
b070 90 b0			dw .ENDCORE            
b072 05				db 4 + 1 
b073 .. 00			db "1-2!",0              
b078				endm 
# End of macro CWHEAD
b078			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
b078			 
b078					FORTH_DSP_VALUEHL 
b078 cd c8 9b			call macro_dsp_valuehl 
b07b				endm 
# End of macro FORTH_DSP_VALUEHL
b07b e5					push hl 
b07c			 
b07c					FORTH_DSP_POP 
b07c cd 80 9c			call macro_forth_dsp_pop 
b07f				endm 
# End of macro FORTH_DSP_POP
b07f e1					pop hl 
b080			 
b080 e5					push hl 
b081			 
b081 cd 35 9d				call loadwordinhl 
b084 2b					dec hl 
b085			 
b085 d1					pop de 
b086 eb					ex de, hl 
b087 73					ld (hl), e 
b088 23					inc hl 
b089 72					ld (hl), d 
b08a					 
b08a					NEXTW 
b08a cd 68 ee			call parse_vector 
b08d c3 af 9d			jp macro_next 
b090				endm 
# End of macro NEXTW
b090			.ENDCORE: 
b090			 
b090			; eof 
b090			 
b090			 
# End of file forth_words_core.asm
b090			include "forth_words_flow.asm" 
b090			 
b090			; | ## Program Flow Words 
b090			 
b090			.IF: 
b090				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
b090 1e				db WORD_SYS_CORE+10             
b091 8b b1			dw .THEN            
b093 03				db 2 + 1 
b094 .. 00			db "IF",0              
b097				endm 
# End of macro CWHEAD
b097			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
b097			; | | Note: currently not supporting ELSE or nested IF 
b097			; 
b097					if DEBUG_FORTH_WORDS_KEY 
b097						DMARK "IF." 
b097 f5				push af  
b098 3a ac b0			ld a, (.dmark)  
b09b 32 5e ee			ld (debug_mark),a  
b09e 3a ad b0			ld a, (.dmark+1)  
b0a1 32 5f ee			ld (debug_mark+1),a  
b0a4 3a ae b0			ld a, (.dmark+2)  
b0a7 32 60 ee			ld (debug_mark+2),a  
b0aa 18 03			jr .pastdmark  
b0ac ..			.dmark: db "IF."  
b0af f1			.pastdmark: pop af  
b0b0			endm  
# End of macro DMARK
b0b0						CALLMONITOR 
b0b0 cd 6b ee			call debug_vector  
b0b3				endm  
# End of macro CALLMONITOR
b0b3					endif 
b0b3			; eval TOS 
b0b3			 
b0b3				FORTH_DSP_VALUEHL 
b0b3 cd c8 9b			call macro_dsp_valuehl 
b0b6				endm 
# End of macro FORTH_DSP_VALUEHL
b0b6			 
b0b6			;	push hl 
b0b6				FORTH_DSP_POP 
b0b6 cd 80 9c			call macro_forth_dsp_pop 
b0b9				endm 
# End of macro FORTH_DSP_POP
b0b9			;	pop hl 
b0b9			 
b0b9					if DEBUG_FORTH_WORDS 
b0b9						DMARK "IF1" 
b0b9 f5				push af  
b0ba 3a ce b0			ld a, (.dmark)  
b0bd 32 5e ee			ld (debug_mark),a  
b0c0 3a cf b0			ld a, (.dmark+1)  
b0c3 32 5f ee			ld (debug_mark+1),a  
b0c6 3a d0 b0			ld a, (.dmark+2)  
b0c9 32 60 ee			ld (debug_mark+2),a  
b0cc 18 03			jr .pastdmark  
b0ce ..			.dmark: db "IF1"  
b0d1 f1			.pastdmark: pop af  
b0d2			endm  
# End of macro DMARK
b0d2						CALLMONITOR 
b0d2 cd 6b ee			call debug_vector  
b0d5				endm  
# End of macro CALLMONITOR
b0d5					endif 
b0d5 b7				or a        ; clear carry flag 
b0d6 11 00 00			ld de, 0 
b0d9 eb				ex de,hl 
b0da ed 52			sbc hl, de 
b0dc c2 69 b1			jp nz, .iftrue 
b0df			 
b0df					if DEBUG_FORTH_WORDS 
b0df						DMARK "IF2" 
b0df f5				push af  
b0e0 3a f4 b0			ld a, (.dmark)  
b0e3 32 5e ee			ld (debug_mark),a  
b0e6 3a f5 b0			ld a, (.dmark+1)  
b0e9 32 5f ee			ld (debug_mark+1),a  
b0ec 3a f6 b0			ld a, (.dmark+2)  
b0ef 32 60 ee			ld (debug_mark+2),a  
b0f2 18 03			jr .pastdmark  
b0f4 ..			.dmark: db "IF2"  
b0f7 f1			.pastdmark: pop af  
b0f8			endm  
# End of macro DMARK
b0f8						CALLMONITOR 
b0f8 cd 6b ee			call debug_vector  
b0fb				endm  
# End of macro CALLMONITOR
b0fb					endif 
b0fb			 
b0fb			; if not true then skip to THEN 
b0fb			 
b0fb				; TODO get tok_ptr 
b0fb				; TODO consume toks until we get to THEN 
b0fb			 
b0fb 2a b5 e5			ld hl, (os_tok_ptr) 
b0fe					if DEBUG_FORTH_WORDS 
b0fe						DMARK "IF3" 
b0fe f5				push af  
b0ff 3a 13 b1			ld a, (.dmark)  
b102 32 5e ee			ld (debug_mark),a  
b105 3a 14 b1			ld a, (.dmark+1)  
b108 32 5f ee			ld (debug_mark+1),a  
b10b 3a 15 b1			ld a, (.dmark+2)  
b10e 32 60 ee			ld (debug_mark+2),a  
b111 18 03			jr .pastdmark  
b113 ..			.dmark: db "IF3"  
b116 f1			.pastdmark: pop af  
b117			endm  
# End of macro DMARK
b117						CALLMONITOR 
b117 cd 6b ee			call debug_vector  
b11a				endm  
# End of macro CALLMONITOR
b11a						 
b11a					endif 
b11a 11 64 b1			ld de, .ifthen 
b11d					if DEBUG_FORTH_WORDS 
b11d						DMARK "IF4" 
b11d f5				push af  
b11e 3a 32 b1			ld a, (.dmark)  
b121 32 5e ee			ld (debug_mark),a  
b124 3a 33 b1			ld a, (.dmark+1)  
b127 32 5f ee			ld (debug_mark+1),a  
b12a 3a 34 b1			ld a, (.dmark+2)  
b12d 32 60 ee			ld (debug_mark+2),a  
b130 18 03			jr .pastdmark  
b132 ..			.dmark: db "IF4"  
b135 f1			.pastdmark: pop af  
b136			endm  
# End of macro DMARK
b136						CALLMONITOR 
b136 cd 6b ee			call debug_vector  
b139				endm  
# End of macro CALLMONITOR
b139					endif 
b139 cd ac 9e			call findnexttok  
b13c			 
b13c					if DEBUG_FORTH_WORDS 
b13c						DMARK "IF5" 
b13c f5				push af  
b13d 3a 51 b1			ld a, (.dmark)  
b140 32 5e ee			ld (debug_mark),a  
b143 3a 52 b1			ld a, (.dmark+1)  
b146 32 5f ee			ld (debug_mark+1),a  
b149 3a 53 b1			ld a, (.dmark+2)  
b14c 32 60 ee			ld (debug_mark+2),a  
b14f 18 03			jr .pastdmark  
b151 ..			.dmark: db "IF5"  
b154 f1			.pastdmark: pop af  
b155			endm  
# End of macro DMARK
b155						CALLMONITOR 
b155 cd 6b ee			call debug_vector  
b158				endm  
# End of macro CALLMONITOR
b158					endif 
b158				; TODO replace below with ; exec using tok_ptr 
b158 22 b5 e5			ld (os_tok_ptr), hl 
b15b c3 30 9e			jp exec1 
b15e				NEXTW 
b15e cd 68 ee			call parse_vector 
b161 c3 af 9d			jp macro_next 
b164				endm 
# End of macro NEXTW
b164			 
b164 .. 00		.ifthen:  db "THEN",0 
b169			 
b169			.iftrue:		 
b169				; Exec next words normally 
b169			 
b169				; if true then exec following IF as normal 
b169					if DEBUG_FORTH_WORDS 
b169						DMARK "IFT" 
b169 f5				push af  
b16a 3a 7e b1			ld a, (.dmark)  
b16d 32 5e ee			ld (debug_mark),a  
b170 3a 7f b1			ld a, (.dmark+1)  
b173 32 5f ee			ld (debug_mark+1),a  
b176 3a 80 b1			ld a, (.dmark+2)  
b179 32 60 ee			ld (debug_mark+2),a  
b17c 18 03			jr .pastdmark  
b17e ..			.dmark: db "IFT"  
b181 f1			.pastdmark: pop af  
b182			endm  
# End of macro DMARK
b182						CALLMONITOR 
b182 cd 6b ee			call debug_vector  
b185				endm  
# End of macro CALLMONITOR
b185					endif 
b185			 
b185					NEXTW 
b185 cd 68 ee			call parse_vector 
b188 c3 af 9d			jp macro_next 
b18b				endm 
# End of macro NEXTW
b18b			.THEN: 
b18b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b18b 1f				db WORD_SYS_CORE+11             
b18c b6 b1			dw .ELSE            
b18e 05				db 4 + 1 
b18f .. 00			db "THEN",0              
b194				endm 
# End of macro CWHEAD
b194			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b194					if DEBUG_FORTH_WORDS_KEY 
b194						DMARK "THN" 
b194 f5				push af  
b195 3a a9 b1			ld a, (.dmark)  
b198 32 5e ee			ld (debug_mark),a  
b19b 3a aa b1			ld a, (.dmark+1)  
b19e 32 5f ee			ld (debug_mark+1),a  
b1a1 3a ab b1			ld a, (.dmark+2)  
b1a4 32 60 ee			ld (debug_mark+2),a  
b1a7 18 03			jr .pastdmark  
b1a9 ..			.dmark: db "THN"  
b1ac f1			.pastdmark: pop af  
b1ad			endm  
# End of macro DMARK
b1ad						CALLMONITOR 
b1ad cd 6b ee			call debug_vector  
b1b0				endm  
# End of macro CALLMONITOR
b1b0					endif 
b1b0					NEXTW 
b1b0 cd 68 ee			call parse_vector 
b1b3 c3 af 9d			jp macro_next 
b1b6				endm 
# End of macro NEXTW
b1b6			.ELSE: 
b1b6				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b1b6 20				db WORD_SYS_CORE+12             
b1b7 e1 b1			dw .DO            
b1b9 03				db 2 + 1 
b1ba .. 00			db "ELSE",0              
b1bf				endm 
# End of macro CWHEAD
b1bf			; | ELSE ( -- ) Not supported - does nothing | TODO 
b1bf			 
b1bf					if DEBUG_FORTH_WORDS_KEY 
b1bf						DMARK "ELS" 
b1bf f5				push af  
b1c0 3a d4 b1			ld a, (.dmark)  
b1c3 32 5e ee			ld (debug_mark),a  
b1c6 3a d5 b1			ld a, (.dmark+1)  
b1c9 32 5f ee			ld (debug_mark+1),a  
b1cc 3a d6 b1			ld a, (.dmark+2)  
b1cf 32 60 ee			ld (debug_mark+2),a  
b1d2 18 03			jr .pastdmark  
b1d4 ..			.dmark: db "ELS"  
b1d7 f1			.pastdmark: pop af  
b1d8			endm  
# End of macro DMARK
b1d8						CALLMONITOR 
b1d8 cd 6b ee			call debug_vector  
b1db				endm  
# End of macro CALLMONITOR
b1db					endif 
b1db			 
b1db			 
b1db					NEXTW 
b1db cd 68 ee			call parse_vector 
b1de c3 af 9d			jp macro_next 
b1e1				endm 
# End of macro NEXTW
b1e1			.DO: 
b1e1				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b1e1 21				db WORD_SYS_CORE+13             
b1e2 0b b3			dw .LOOP            
b1e4 03				db 2 + 1 
b1e5 .. 00			db "DO",0              
b1e8				endm 
# End of macro CWHEAD
b1e8			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b1e8			 
b1e8					if DEBUG_FORTH_WORDS_KEY 
b1e8						DMARK "DO." 
b1e8 f5				push af  
b1e9 3a fd b1			ld a, (.dmark)  
b1ec 32 5e ee			ld (debug_mark),a  
b1ef 3a fe b1			ld a, (.dmark+1)  
b1f2 32 5f ee			ld (debug_mark+1),a  
b1f5 3a ff b1			ld a, (.dmark+2)  
b1f8 32 60 ee			ld (debug_mark+2),a  
b1fb 18 03			jr .pastdmark  
b1fd ..			.dmark: db "DO."  
b200 f1			.pastdmark: pop af  
b201			endm  
# End of macro DMARK
b201						CALLMONITOR 
b201 cd 6b ee			call debug_vector  
b204				endm  
# End of macro CALLMONITOR
b204					endif 
b204			;  push pc to rsp stack past the DO 
b204			 
b204 2a b5 e5				ld hl, (os_tok_ptr) 
b207 23					inc hl   ; D 
b208 23					inc hl  ; O 
b209 23					inc hl   ; null 
b20a					if DEBUG_FORTH_WORDS 
b20a						DMARK "DO2" 
b20a f5				push af  
b20b 3a 1f b2			ld a, (.dmark)  
b20e 32 5e ee			ld (debug_mark),a  
b211 3a 20 b2			ld a, (.dmark+1)  
b214 32 5f ee			ld (debug_mark+1),a  
b217 3a 21 b2			ld a, (.dmark+2)  
b21a 32 60 ee			ld (debug_mark+2),a  
b21d 18 03			jr .pastdmark  
b21f ..			.dmark: db "DO2"  
b222 f1			.pastdmark: pop af  
b223			endm  
# End of macro DMARK
b223						CALLMONITOR 
b223 cd 6b ee			call debug_vector  
b226				endm  
# End of macro CALLMONITOR
b226					endif 
b226					FORTH_RSP_NEXT 
b226 cd 73 99			call macro_forth_rsp_next 
b229				endm 
# End of macro FORTH_RSP_NEXT
b229					if DEBUG_FORTH_WORDS 
b229						DMARK "DO3" 
b229 f5				push af  
b22a 3a 3e b2			ld a, (.dmark)  
b22d 32 5e ee			ld (debug_mark),a  
b230 3a 3f b2			ld a, (.dmark+1)  
b233 32 5f ee			ld (debug_mark+1),a  
b236 3a 40 b2			ld a, (.dmark+2)  
b239 32 60 ee			ld (debug_mark+2),a  
b23c 18 03			jr .pastdmark  
b23e ..			.dmark: db "DO3"  
b241 f1			.pastdmark: pop af  
b242			endm  
# End of macro DMARK
b242						CALLMONITOR 
b242 cd 6b ee			call debug_vector  
b245				endm  
# End of macro CALLMONITOR
b245					endif 
b245			 
b245					;if DEBUG_FORTH_WORDS 
b245				;		push hl 
b245			;		endif  
b245			 
b245			; get counters from data stack 
b245			 
b245			 
b245					FORTH_DSP_VALUEHL 
b245 cd c8 9b			call macro_dsp_valuehl 
b248				endm 
# End of macro FORTH_DSP_VALUEHL
b248 e5					push hl		 ; hl now has starting counter which needs to be tos 
b249			 
b249					if DEBUG_FORTH_WORDS 
b249						DMARK "DO4" 
b249 f5				push af  
b24a 3a 5e b2			ld a, (.dmark)  
b24d 32 5e ee			ld (debug_mark),a  
b250 3a 5f b2			ld a, (.dmark+1)  
b253 32 5f ee			ld (debug_mark+1),a  
b256 3a 60 b2			ld a, (.dmark+2)  
b259 32 60 ee			ld (debug_mark+2),a  
b25c 18 03			jr .pastdmark  
b25e ..			.dmark: db "DO4"  
b261 f1			.pastdmark: pop af  
b262			endm  
# End of macro DMARK
b262						CALLMONITOR 
b262 cd 6b ee			call debug_vector  
b265				endm  
# End of macro CALLMONITOR
b265					endif 
b265					FORTH_DSP_POP 
b265 cd 80 9c			call macro_forth_dsp_pop 
b268				endm 
# End of macro FORTH_DSP_POP
b268			 
b268					if DEBUG_FORTH_WORDS 
b268						DMARK "DO5" 
b268 f5				push af  
b269 3a 7d b2			ld a, (.dmark)  
b26c 32 5e ee			ld (debug_mark),a  
b26f 3a 7e b2			ld a, (.dmark+1)  
b272 32 5f ee			ld (debug_mark+1),a  
b275 3a 7f b2			ld a, (.dmark+2)  
b278 32 60 ee			ld (debug_mark+2),a  
b27b 18 03			jr .pastdmark  
b27d ..			.dmark: db "DO5"  
b280 f1			.pastdmark: pop af  
b281			endm  
# End of macro DMARK
b281						CALLMONITOR 
b281 cd 6b ee			call debug_vector  
b284				endm  
# End of macro CALLMONITOR
b284					endif 
b284			 
b284					FORTH_DSP_VALUEHL 
b284 cd c8 9b			call macro_dsp_valuehl 
b287				endm 
# End of macro FORTH_DSP_VALUEHL
b287			;		push hl		 ; hl now has starting limit counter 
b287			 
b287					if DEBUG_FORTH_WORDS 
b287						DMARK "DO6" 
b287 f5				push af  
b288 3a 9c b2			ld a, (.dmark)  
b28b 32 5e ee			ld (debug_mark),a  
b28e 3a 9d b2			ld a, (.dmark+1)  
b291 32 5f ee			ld (debug_mark+1),a  
b294 3a 9e b2			ld a, (.dmark+2)  
b297 32 60 ee			ld (debug_mark+2),a  
b29a 18 03			jr .pastdmark  
b29c ..			.dmark: db "DO6"  
b29f f1			.pastdmark: pop af  
b2a0			endm  
# End of macro DMARK
b2a0						CALLMONITOR 
b2a0 cd 6b ee			call debug_vector  
b2a3				endm  
# End of macro CALLMONITOR
b2a3					endif 
b2a3					FORTH_DSP_POP 
b2a3 cd 80 9c			call macro_forth_dsp_pop 
b2a6				endm 
# End of macro FORTH_DSP_POP
b2a6			 
b2a6			; put counters on the loop stack 
b2a6			 
b2a6			;		pop hl			 ; limit counter 
b2a6 d1					pop de			; start counter 
b2a7			 
b2a7					; push limit counter 
b2a7			 
b2a7					if DEBUG_FORTH_WORDS 
b2a7						DMARK "DO7" 
b2a7 f5				push af  
b2a8 3a bc b2			ld a, (.dmark)  
b2ab 32 5e ee			ld (debug_mark),a  
b2ae 3a bd b2			ld a, (.dmark+1)  
b2b1 32 5f ee			ld (debug_mark+1),a  
b2b4 3a be b2			ld a, (.dmark+2)  
b2b7 32 60 ee			ld (debug_mark+2),a  
b2ba 18 03			jr .pastdmark  
b2bc ..			.dmark: db "DO7"  
b2bf f1			.pastdmark: pop af  
b2c0			endm  
# End of macro DMARK
b2c0						CALLMONITOR 
b2c0 cd 6b ee			call debug_vector  
b2c3				endm  
# End of macro CALLMONITOR
b2c3					endif 
b2c3					FORTH_LOOP_NEXT 
b2c3 cd f9 9b			call macro_forth_loop_next 
b2c6				endm 
# End of macro FORTH_LOOP_NEXT
b2c6			 
b2c6					; push start counter 
b2c6			 
b2c6 eb					ex de, hl 
b2c7					if DEBUG_FORTH_WORDS 
b2c7						DMARK "DO7" 
b2c7 f5				push af  
b2c8 3a dc b2			ld a, (.dmark)  
b2cb 32 5e ee			ld (debug_mark),a  
b2ce 3a dd b2			ld a, (.dmark+1)  
b2d1 32 5f ee			ld (debug_mark+1),a  
b2d4 3a de b2			ld a, (.dmark+2)  
b2d7 32 60 ee			ld (debug_mark+2),a  
b2da 18 03			jr .pastdmark  
b2dc ..			.dmark: db "DO7"  
b2df f1			.pastdmark: pop af  
b2e0			endm  
# End of macro DMARK
b2e0						CALLMONITOR 
b2e0 cd 6b ee			call debug_vector  
b2e3				endm  
# End of macro CALLMONITOR
b2e3					endif 
b2e3					FORTH_LOOP_NEXT 
b2e3 cd f9 9b			call macro_forth_loop_next 
b2e6				endm 
# End of macro FORTH_LOOP_NEXT
b2e6			 
b2e6			 
b2e6					; init first round of I counter 
b2e6			 
b2e6 22 d9 e5				ld (os_current_i), hl 
b2e9			 
b2e9					if DEBUG_FORTH_WORDS 
b2e9						DMARK "DO8" 
b2e9 f5				push af  
b2ea 3a fe b2			ld a, (.dmark)  
b2ed 32 5e ee			ld (debug_mark),a  
b2f0 3a ff b2			ld a, (.dmark+1)  
b2f3 32 5f ee			ld (debug_mark+1),a  
b2f6 3a 00 b3			ld a, (.dmark+2)  
b2f9 32 60 ee			ld (debug_mark+2),a  
b2fc 18 03			jr .pastdmark  
b2fe ..			.dmark: db "DO8"  
b301 f1			.pastdmark: pop af  
b302			endm  
# End of macro DMARK
b302						CALLMONITOR 
b302 cd 6b ee			call debug_vector  
b305				endm  
# End of macro CALLMONITOR
b305					endif 
b305			 
b305					NEXTW 
b305 cd 68 ee			call parse_vector 
b308 c3 af 9d			jp macro_next 
b30b				endm 
# End of macro NEXTW
b30b			.LOOP: 
b30b				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b30b 22				db WORD_SYS_CORE+14             
b30c 29 b4			dw .I            
b30e 05				db 4 + 1 
b30f .. 00			db "LOOP",0              
b314				endm 
# End of macro CWHEAD
b314			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b314			 
b314				; pop tos as current loop count to hl 
b314			 
b314				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b314			 
b314				FORTH_LOOP_TOS 
b314 cd 2c 9c			call macro_forth_loop_tos 
b317				endm 
# End of macro FORTH_LOOP_TOS
b317 e5				push hl 
b318			 
b318					if DEBUG_FORTH_WORDS_KEY 
b318						DMARK "LOP" 
b318 f5				push af  
b319 3a 2d b3			ld a, (.dmark)  
b31c 32 5e ee			ld (debug_mark),a  
b31f 3a 2e b3			ld a, (.dmark+1)  
b322 32 5f ee			ld (debug_mark+1),a  
b325 3a 2f b3			ld a, (.dmark+2)  
b328 32 60 ee			ld (debug_mark+2),a  
b32b 18 03			jr .pastdmark  
b32d ..			.dmark: db "LOP"  
b330 f1			.pastdmark: pop af  
b331			endm  
# End of macro DMARK
b331						CALLMONITOR 
b331 cd 6b ee			call debug_vector  
b334				endm  
# End of macro CALLMONITOR
b334					endif 
b334				; next item on the stack is the limit. get it 
b334			 
b334			 
b334				FORTH_LOOP_POP 
b334 cd 36 9c			call macro_forth_loop_pop 
b337				endm 
# End of macro FORTH_LOOP_POP
b337			 
b337				FORTH_LOOP_TOS 
b337 cd 2c 9c			call macro_forth_loop_tos 
b33a				endm 
# End of macro FORTH_LOOP_TOS
b33a			 
b33a d1				pop de		 ; de = i, hl = limit 
b33b			 
b33b					if DEBUG_FORTH_WORDS 
b33b						DMARK "LP1" 
b33b f5				push af  
b33c 3a 50 b3			ld a, (.dmark)  
b33f 32 5e ee			ld (debug_mark),a  
b342 3a 51 b3			ld a, (.dmark+1)  
b345 32 5f ee			ld (debug_mark+1),a  
b348 3a 52 b3			ld a, (.dmark+2)  
b34b 32 60 ee			ld (debug_mark+2),a  
b34e 18 03			jr .pastdmark  
b350 ..			.dmark: db "LP1"  
b353 f1			.pastdmark: pop af  
b354			endm  
# End of macro DMARK
b354						CALLMONITOR 
b354 cd 6b ee			call debug_vector  
b357				endm  
# End of macro CALLMONITOR
b357					endif 
b357			 
b357				; go back to previous word 
b357			 
b357 d5				push de    ; save I for inc later 
b358			 
b358			 
b358				; get limit 
b358				;  is I at limit? 
b358			 
b358			 
b358					if DEBUG_FORTH_WORDS 
b358						DMARK "LP1" 
b358 f5				push af  
b359 3a 6d b3			ld a, (.dmark)  
b35c 32 5e ee			ld (debug_mark),a  
b35f 3a 6e b3			ld a, (.dmark+1)  
b362 32 5f ee			ld (debug_mark+1),a  
b365 3a 6f b3			ld a, (.dmark+2)  
b368 32 60 ee			ld (debug_mark+2),a  
b36b 18 03			jr .pastdmark  
b36d ..			.dmark: db "LP1"  
b370 f1			.pastdmark: pop af  
b371			endm  
# End of macro DMARK
b371						CALLMONITOR 
b371 cd 6b ee			call debug_vector  
b374				endm  
# End of macro CALLMONITOR
b374					endif 
b374			 
b374 ed 52			sbc hl, de 
b376			 
b376			 
b376				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b376			 
b376 20 29				jr nz, .loopnotdone 
b378			 
b378 e1				pop hl   ; get rid of saved I 
b379				FORTH_LOOP_POP     ; get rid of limit 
b379 cd 36 9c			call macro_forth_loop_pop 
b37c				endm 
# End of macro FORTH_LOOP_POP
b37c			 
b37c				FORTH_RSP_POP     ; get rid of DO ptr 
b37c cd 94 99			call macro_forth_rsp_pop 
b37f				endm 
# End of macro FORTH_RSP_POP
b37f			 
b37f			if DEBUG_FORTH_WORDS 
b37f						DMARK "LP>" 
b37f f5				push af  
b380 3a 94 b3			ld a, (.dmark)  
b383 32 5e ee			ld (debug_mark),a  
b386 3a 95 b3			ld a, (.dmark+1)  
b389 32 5f ee			ld (debug_mark+1),a  
b38c 3a 96 b3			ld a, (.dmark+2)  
b38f 32 60 ee			ld (debug_mark+2),a  
b392 18 03			jr .pastdmark  
b394 ..			.dmark: db "LP>"  
b397 f1			.pastdmark: pop af  
b398			endm  
# End of macro DMARK
b398				CALLMONITOR 
b398 cd 6b ee			call debug_vector  
b39b				endm  
# End of macro CALLMONITOR
b39b			endif 
b39b			 
b39b					NEXTW 
b39b cd 68 ee			call parse_vector 
b39e c3 af 9d			jp macro_next 
b3a1				endm 
# End of macro NEXTW
b3a1				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3a1			 
b3a1			.loopnotdone: 
b3a1			 
b3a1 e1				pop hl    ; get I 
b3a2 23				inc hl 
b3a3			 
b3a3			   	; save new I 
b3a3			 
b3a3			 
b3a3					; set I counter 
b3a3			 
b3a3 22 d9 e5				ld (os_current_i), hl 
b3a6			 
b3a6					if DEBUG_FORTH_WORDS 
b3a6						DMARK "LPN" 
b3a6 f5				push af  
b3a7 3a bb b3			ld a, (.dmark)  
b3aa 32 5e ee			ld (debug_mark),a  
b3ad 3a bc b3			ld a, (.dmark+1)  
b3b0 32 5f ee			ld (debug_mark+1),a  
b3b3 3a bd b3			ld a, (.dmark+2)  
b3b6 32 60 ee			ld (debug_mark+2),a  
b3b9 18 03			jr .pastdmark  
b3bb ..			.dmark: db "LPN"  
b3be f1			.pastdmark: pop af  
b3bf			endm  
# End of macro DMARK
b3bf					CALLMONITOR 
b3bf cd 6b ee			call debug_vector  
b3c2				endm  
# End of macro CALLMONITOR
b3c2					endif 
b3c2					 
b3c2				FORTH_LOOP_NEXT 
b3c2 cd f9 9b			call macro_forth_loop_next 
b3c5				endm 
# End of macro FORTH_LOOP_NEXT
b3c5			 
b3c5			 
b3c5					if DEBUG_FORTH_WORDS 
b3c5 eb						ex de,hl 
b3c6					endif 
b3c6			 
b3c6			;	; get DO ptr 
b3c6			; 
b3c6					if DEBUG_FORTH_WORDS 
b3c6						DMARK "LP7" 
b3c6 f5				push af  
b3c7 3a db b3			ld a, (.dmark)  
b3ca 32 5e ee			ld (debug_mark),a  
b3cd 3a dc b3			ld a, (.dmark+1)  
b3d0 32 5f ee			ld (debug_mark+1),a  
b3d3 3a dd b3			ld a, (.dmark+2)  
b3d6 32 60 ee			ld (debug_mark+2),a  
b3d9 18 03			jr .pastdmark  
b3db ..			.dmark: db "LP7"  
b3de f1			.pastdmark: pop af  
b3df			endm  
# End of macro DMARK
b3df					CALLMONITOR 
b3df cd 6b ee			call debug_vector  
b3e2				endm  
# End of macro CALLMONITOR
b3e2					endif 
b3e2				FORTH_RSP_TOS 
b3e2 cd 8a 99			call macro_forth_rsp_tos 
b3e5				endm 
# End of macro FORTH_RSP_TOS
b3e5			 
b3e5					if DEBUG_FORTH_WORDS 
b3e5						DMARK "LP8" 
b3e5 f5				push af  
b3e6 3a fa b3			ld a, (.dmark)  
b3e9 32 5e ee			ld (debug_mark),a  
b3ec 3a fb b3			ld a, (.dmark+1)  
b3ef 32 5f ee			ld (debug_mark+1),a  
b3f2 3a fc b3			ld a, (.dmark+2)  
b3f5 32 60 ee			ld (debug_mark+2),a  
b3f8 18 03			jr .pastdmark  
b3fa ..			.dmark: db "LP8"  
b3fd f1			.pastdmark: pop af  
b3fe			endm  
# End of macro DMARK
b3fe					CALLMONITOR 
b3fe cd 6b ee			call debug_vector  
b401				endm  
# End of macro CALLMONITOR
b401					endif 
b401				;push hl 
b401			 
b401				; not going to DO any more 
b401				; get rid of the RSP pointer as DO will add it back in 
b401				;FORTH_RSP_POP 
b401				;pop hl 
b401			 
b401				;ld hl,(cli_ret_sp) 
b401				;ld e, (hl) 
b401				;inc hl 
b401				;ld d, (hl) 
b401				;ex de,hl 
b401 22 b5 e5			ld (os_tok_ptr), hl 
b404					if DEBUG_FORTH_WORDS 
b404						DMARK "LP<" 
b404 f5				push af  
b405 3a 19 b4			ld a, (.dmark)  
b408 32 5e ee			ld (debug_mark),a  
b40b 3a 1a b4			ld a, (.dmark+1)  
b40e 32 5f ee			ld (debug_mark+1),a  
b411 3a 1b b4			ld a, (.dmark+2)  
b414 32 60 ee			ld (debug_mark+2),a  
b417 18 03			jr .pastdmark  
b419 ..			.dmark: db "LP<"  
b41c f1			.pastdmark: pop af  
b41d			endm  
# End of macro DMARK
b41d					CALLMONITOR 
b41d cd 6b ee			call debug_vector  
b420				endm  
# End of macro CALLMONITOR
b420				endif 
b420 c3 30 9e			jp exec1 
b423			 
b423					 
b423			 
b423			 
b423					NEXTW 
b423 cd 68 ee			call parse_vector 
b426 c3 af 9d			jp macro_next 
b429				endm 
# End of macro NEXTW
b429			.I:  
b429			 
b429				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b429 5e				db WORD_SYS_CORE+74             
b42a 57 b4			dw .DLOOP            
b42c 02				db 1 + 1 
b42d .. 00			db "I",0              
b42f				endm 
# End of macro CWHEAD
b42f			; | I ( -- ) Current loop counter | DONE 
b42f					if DEBUG_FORTH_WORDS_KEY 
b42f						DMARK "I.." 
b42f f5				push af  
b430 3a 44 b4			ld a, (.dmark)  
b433 32 5e ee			ld (debug_mark),a  
b436 3a 45 b4			ld a, (.dmark+1)  
b439 32 5f ee			ld (debug_mark+1),a  
b43c 3a 46 b4			ld a, (.dmark+2)  
b43f 32 60 ee			ld (debug_mark+2),a  
b442 18 03			jr .pastdmark  
b444 ..			.dmark: db "I.."  
b447 f1			.pastdmark: pop af  
b448			endm  
# End of macro DMARK
b448						CALLMONITOR 
b448 cd 6b ee			call debug_vector  
b44b				endm  
# End of macro CALLMONITOR
b44b					endif 
b44b			 
b44b 2a d9 e5				ld hl,(os_current_i) 
b44e cd cc 99				call forth_push_numhl 
b451			 
b451					NEXTW 
b451 cd 68 ee			call parse_vector 
b454 c3 af 9d			jp macro_next 
b457				endm 
# End of macro NEXTW
b457			.DLOOP: 
b457				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b457 5f				db WORD_SYS_CORE+75             
b458 3e b5			dw .REPEAT            
b45a 06				db 5 + 1 
b45b .. 00			db "-LOOP",0              
b461				endm 
# End of macro CWHEAD
b461			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b461				; pop tos as current loop count to hl 
b461					if DEBUG_FORTH_WORDS_KEY 
b461						DMARK "-LP" 
b461 f5				push af  
b462 3a 76 b4			ld a, (.dmark)  
b465 32 5e ee			ld (debug_mark),a  
b468 3a 77 b4			ld a, (.dmark+1)  
b46b 32 5f ee			ld (debug_mark+1),a  
b46e 3a 78 b4			ld a, (.dmark+2)  
b471 32 60 ee			ld (debug_mark+2),a  
b474 18 03			jr .pastdmark  
b476 ..			.dmark: db "-LP"  
b479 f1			.pastdmark: pop af  
b47a			endm  
# End of macro DMARK
b47a						CALLMONITOR 
b47a cd 6b ee			call debug_vector  
b47d				endm  
# End of macro CALLMONITOR
b47d					endif 
b47d			 
b47d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b47d			 
b47d				FORTH_LOOP_TOS 
b47d cd 2c 9c			call macro_forth_loop_tos 
b480				endm 
# End of macro FORTH_LOOP_TOS
b480 e5				push hl 
b481			 
b481					if DEBUG_FORTH_WORDS 
b481						DMARK "-LP" 
b481 f5				push af  
b482 3a 96 b4			ld a, (.dmark)  
b485 32 5e ee			ld (debug_mark),a  
b488 3a 97 b4			ld a, (.dmark+1)  
b48b 32 5f ee			ld (debug_mark+1),a  
b48e 3a 98 b4			ld a, (.dmark+2)  
b491 32 60 ee			ld (debug_mark+2),a  
b494 18 03			jr .pastdmark  
b496 ..			.dmark: db "-LP"  
b499 f1			.pastdmark: pop af  
b49a			endm  
# End of macro DMARK
b49a						CALLMONITOR 
b49a cd 6b ee			call debug_vector  
b49d				endm  
# End of macro CALLMONITOR
b49d					endif 
b49d				; next item on the stack is the limit. get it 
b49d			 
b49d			 
b49d				FORTH_LOOP_POP 
b49d cd 36 9c			call macro_forth_loop_pop 
b4a0				endm 
# End of macro FORTH_LOOP_POP
b4a0			 
b4a0				FORTH_LOOP_TOS 
b4a0 cd 2c 9c			call macro_forth_loop_tos 
b4a3				endm 
# End of macro FORTH_LOOP_TOS
b4a3			 
b4a3 d1				pop de		 ; de = i, hl = limit 
b4a4			 
b4a4					if DEBUG_FORTH_WORDS 
b4a4						DMARK "-L1" 
b4a4 f5				push af  
b4a5 3a b9 b4			ld a, (.dmark)  
b4a8 32 5e ee			ld (debug_mark),a  
b4ab 3a ba b4			ld a, (.dmark+1)  
b4ae 32 5f ee			ld (debug_mark+1),a  
b4b1 3a bb b4			ld a, (.dmark+2)  
b4b4 32 60 ee			ld (debug_mark+2),a  
b4b7 18 03			jr .pastdmark  
b4b9 ..			.dmark: db "-L1"  
b4bc f1			.pastdmark: pop af  
b4bd			endm  
# End of macro DMARK
b4bd						CALLMONITOR 
b4bd cd 6b ee			call debug_vector  
b4c0				endm  
# End of macro CALLMONITOR
b4c0					endif 
b4c0			 
b4c0				; go back to previous word 
b4c0			 
b4c0 d5				push de    ; save I for inc later 
b4c1			 
b4c1			 
b4c1				; get limit 
b4c1				;  is I at limit? 
b4c1			 
b4c1			 
b4c1					if DEBUG_FORTH_WORDS 
b4c1						DMARK "-L1" 
b4c1 f5				push af  
b4c2 3a d6 b4			ld a, (.dmark)  
b4c5 32 5e ee			ld (debug_mark),a  
b4c8 3a d7 b4			ld a, (.dmark+1)  
b4cb 32 5f ee			ld (debug_mark+1),a  
b4ce 3a d8 b4			ld a, (.dmark+2)  
b4d1 32 60 ee			ld (debug_mark+2),a  
b4d4 18 03			jr .pastdmark  
b4d6 ..			.dmark: db "-L1"  
b4d9 f1			.pastdmark: pop af  
b4da			endm  
# End of macro DMARK
b4da						CALLMONITOR 
b4da cd 6b ee			call debug_vector  
b4dd				endm  
# End of macro CALLMONITOR
b4dd					endif 
b4dd			 
b4dd ed 52			sbc hl, de 
b4df			 
b4df			 
b4df				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b4df			 
b4df 20 29				jr nz, .mloopnotdone 
b4e1			 
b4e1 e1				pop hl   ; get rid of saved I 
b4e2				FORTH_LOOP_POP     ; get rid of limit 
b4e2 cd 36 9c			call macro_forth_loop_pop 
b4e5				endm 
# End of macro FORTH_LOOP_POP
b4e5			 
b4e5				FORTH_RSP_POP     ; get rid of DO ptr 
b4e5 cd 94 99			call macro_forth_rsp_pop 
b4e8				endm 
# End of macro FORTH_RSP_POP
b4e8			 
b4e8			if DEBUG_FORTH_WORDS 
b4e8						DMARK "-L>" 
b4e8 f5				push af  
b4e9 3a fd b4			ld a, (.dmark)  
b4ec 32 5e ee			ld (debug_mark),a  
b4ef 3a fe b4			ld a, (.dmark+1)  
b4f2 32 5f ee			ld (debug_mark+1),a  
b4f5 3a ff b4			ld a, (.dmark+2)  
b4f8 32 60 ee			ld (debug_mark+2),a  
b4fb 18 03			jr .pastdmark  
b4fd ..			.dmark: db "-L>"  
b500 f1			.pastdmark: pop af  
b501			endm  
# End of macro DMARK
b501				CALLMONITOR 
b501 cd 6b ee			call debug_vector  
b504				endm  
# End of macro CALLMONITOR
b504			endif 
b504			 
b504					NEXTW 
b504 cd 68 ee			call parse_vector 
b507 c3 af 9d			jp macro_next 
b50a				endm 
# End of macro NEXTW
b50a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b50a			 
b50a			.mloopnotdone: 
b50a			 
b50a e1				pop hl    ; get I 
b50b 2b				dec hl 
b50c			 
b50c			   	; save new I 
b50c			 
b50c			 
b50c					; set I counter 
b50c			 
b50c 22 d9 e5				ld (os_current_i), hl 
b50f			 
b50f					 
b50f				FORTH_LOOP_NEXT 
b50f cd f9 9b			call macro_forth_loop_next 
b512				endm 
# End of macro FORTH_LOOP_NEXT
b512			 
b512			 
b512					if DEBUG_FORTH_WORDS 
b512 eb						ex de,hl 
b513					endif 
b513			 
b513			;	; get DO ptr 
b513			; 
b513				FORTH_RSP_TOS 
b513 cd 8a 99			call macro_forth_rsp_tos 
b516				endm 
# End of macro FORTH_RSP_TOS
b516			 
b516				;push hl 
b516			 
b516				; not going to DO any more 
b516				; get rid of the RSP pointer as DO will add it back in 
b516				;FORTH_RSP_POP 
b516				;pop hl 
b516			 
b516			 
b516 22 b5 e5			ld (os_tok_ptr), hl 
b519					if DEBUG_FORTH_WORDS 
b519						DMARK "-L<" 
b519 f5				push af  
b51a 3a 2e b5			ld a, (.dmark)  
b51d 32 5e ee			ld (debug_mark),a  
b520 3a 2f b5			ld a, (.dmark+1)  
b523 32 5f ee			ld (debug_mark+1),a  
b526 3a 30 b5			ld a, (.dmark+2)  
b529 32 60 ee			ld (debug_mark+2),a  
b52c 18 03			jr .pastdmark  
b52e ..			.dmark: db "-L<"  
b531 f1			.pastdmark: pop af  
b532			endm  
# End of macro DMARK
b532					CALLMONITOR 
b532 cd 6b ee			call debug_vector  
b535				endm  
# End of macro CALLMONITOR
b535				endif 
b535 c3 30 9e			jp exec1 
b538			 
b538					 
b538			 
b538			 
b538			 
b538				NEXTW 
b538 cd 68 ee			call parse_vector 
b53b c3 af 9d			jp macro_next 
b53e				endm 
# End of macro NEXTW
b53e			 
b53e			 
b53e			 
b53e			 
b53e			.REPEAT: 
b53e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b53e 71				db WORD_SYS_CORE+93             
b53f 94 b5			dw .UNTIL            
b541 06				db 5 + 1 
b542 .. 00			db "REPEAT",0              
b549				endm 
# End of macro CWHEAD
b549			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b549			;  push pc to rsp stack past the REPEAT 
b549					if DEBUG_FORTH_WORDS_KEY 
b549						DMARK "REP" 
b549 f5				push af  
b54a 3a 5e b5			ld a, (.dmark)  
b54d 32 5e ee			ld (debug_mark),a  
b550 3a 5f b5			ld a, (.dmark+1)  
b553 32 5f ee			ld (debug_mark+1),a  
b556 3a 60 b5			ld a, (.dmark+2)  
b559 32 60 ee			ld (debug_mark+2),a  
b55c 18 03			jr .pastdmark  
b55e ..			.dmark: db "REP"  
b561 f1			.pastdmark: pop af  
b562			endm  
# End of macro DMARK
b562						CALLMONITOR 
b562 cd 6b ee			call debug_vector  
b565				endm  
# End of macro CALLMONITOR
b565					endif 
b565			 
b565 2a b5 e5				ld hl, (os_tok_ptr) 
b568 23					inc hl   ; R 
b569 23					inc hl  ; E 
b56a 23					inc hl   ; P 
b56b 23					inc hl   ; E 
b56c 23					inc hl   ; A 
b56d 23					inc hl   ; T 
b56e 23					inc hl   ; zero 
b56f					FORTH_RSP_NEXT 
b56f cd 73 99			call macro_forth_rsp_next 
b572				endm 
# End of macro FORTH_RSP_NEXT
b572			 
b572			 
b572					if DEBUG_FORTH_WORDS 
b572						DMARK "REP" 
b572 f5				push af  
b573 3a 87 b5			ld a, (.dmark)  
b576 32 5e ee			ld (debug_mark),a  
b579 3a 88 b5			ld a, (.dmark+1)  
b57c 32 5f ee			ld (debug_mark+1),a  
b57f 3a 89 b5			ld a, (.dmark+2)  
b582 32 60 ee			ld (debug_mark+2),a  
b585 18 03			jr .pastdmark  
b587 ..			.dmark: db "REP"  
b58a f1			.pastdmark: pop af  
b58b			endm  
# End of macro DMARK
b58b						;pop bc    ; TODO BUG ?????? what is this for???? 
b58b						CALLMONITOR 
b58b cd 6b ee			call debug_vector  
b58e				endm  
# End of macro CALLMONITOR
b58e					endif 
b58e			 
b58e					NEXTW 
b58e cd 68 ee			call parse_vector 
b591 c3 af 9d			jp macro_next 
b594				endm 
# End of macro NEXTW
b594			;	       NEXTW 
b594			 
b594			.UNTIL: 
b594				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b594 72				db WORD_SYS_CORE+94             
b595 31 b6			dw .ENDFLOW            
b597 06				db 5 + 1 
b598 .. 00			db "UNTIL",0              
b59e				endm 
# End of macro CWHEAD
b59e			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b59e			 
b59e				; pop tos as check 
b59e			 
b59e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b59e			 
b59e				FORTH_DSP_VALUEHL 
b59e cd c8 9b			call macro_dsp_valuehl 
b5a1				endm 
# End of macro FORTH_DSP_VALUEHL
b5a1			 
b5a1					if DEBUG_FORTH_WORDS_KEY 
b5a1						DMARK "UNT" 
b5a1 f5				push af  
b5a2 3a b6 b5			ld a, (.dmark)  
b5a5 32 5e ee			ld (debug_mark),a  
b5a8 3a b7 b5			ld a, (.dmark+1)  
b5ab 32 5f ee			ld (debug_mark+1),a  
b5ae 3a b8 b5			ld a, (.dmark+2)  
b5b1 32 60 ee			ld (debug_mark+2),a  
b5b4 18 03			jr .pastdmark  
b5b6 ..			.dmark: db "UNT"  
b5b9 f1			.pastdmark: pop af  
b5ba			endm  
# End of macro DMARK
b5ba						CALLMONITOR 
b5ba cd 6b ee			call debug_vector  
b5bd				endm  
# End of macro CALLMONITOR
b5bd					endif 
b5bd			 
b5bd			;	push hl 
b5bd				FORTH_DSP_POP 
b5bd cd 80 9c			call macro_forth_dsp_pop 
b5c0				endm 
# End of macro FORTH_DSP_POP
b5c0			 
b5c0			;	pop hl 
b5c0			 
b5c0				; test if true 
b5c0			 
b5c0 cd 04 8d			call ishlzero 
b5c3			;	ld a,l 
b5c3			;	add h 
b5c3			; 
b5c3			;	cp 0 
b5c3			 
b5c3 20 41			jr nz, .untilnotdone 
b5c5			 
b5c5					if DEBUG_FORTH_WORDS 
b5c5						DMARK "UNf" 
b5c5 f5				push af  
b5c6 3a da b5			ld a, (.dmark)  
b5c9 32 5e ee			ld (debug_mark),a  
b5cc 3a db b5			ld a, (.dmark+1)  
b5cf 32 5f ee			ld (debug_mark+1),a  
b5d2 3a dc b5			ld a, (.dmark+2)  
b5d5 32 60 ee			ld (debug_mark+2),a  
b5d8 18 03			jr .pastdmark  
b5da ..			.dmark: db "UNf"  
b5dd f1			.pastdmark: pop af  
b5de			endm  
# End of macro DMARK
b5de						CALLMONITOR 
b5de cd 6b ee			call debug_vector  
b5e1				endm  
# End of macro CALLMONITOR
b5e1					endif 
b5e1			 
b5e1			 
b5e1			 
b5e1				FORTH_RSP_POP     ; get rid of DO ptr 
b5e1 cd 94 99			call macro_forth_rsp_pop 
b5e4				endm 
# End of macro FORTH_RSP_POP
b5e4			 
b5e4			if DEBUG_FORTH_WORDS 
b5e4						DMARK "UN>" 
b5e4 f5				push af  
b5e5 3a f9 b5			ld a, (.dmark)  
b5e8 32 5e ee			ld (debug_mark),a  
b5eb 3a fa b5			ld a, (.dmark+1)  
b5ee 32 5f ee			ld (debug_mark+1),a  
b5f1 3a fb b5			ld a, (.dmark+2)  
b5f4 32 60 ee			ld (debug_mark+2),a  
b5f7 18 03			jr .pastdmark  
b5f9 ..			.dmark: db "UN>"  
b5fc f1			.pastdmark: pop af  
b5fd			endm  
# End of macro DMARK
b5fd				CALLMONITOR 
b5fd cd 6b ee			call debug_vector  
b600				endm  
# End of macro CALLMONITOR
b600			endif 
b600			 
b600					NEXTW 
b600 cd 68 ee			call parse_vector 
b603 c3 af 9d			jp macro_next 
b606				endm 
# End of macro NEXTW
b606				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b606			 
b606			.untilnotdone: 
b606			 
b606			 
b606			;	; get DO ptr 
b606			; 
b606				FORTH_RSP_TOS 
b606 cd 8a 99			call macro_forth_rsp_tos 
b609				endm 
# End of macro FORTH_RSP_TOS
b609			 
b609				;push hl 
b609			 
b609				; not going to DO any more 
b609				; get rid of the RSP pointer as DO will add it back in 
b609				;FORTH_RSP_POP 
b609				;pop hl 
b609			 
b609			 
b609 22 b5 e5			ld (os_tok_ptr), hl 
b60c					if DEBUG_FORTH_WORDS 
b60c						DMARK "UN<" 
b60c f5				push af  
b60d 3a 21 b6			ld a, (.dmark)  
b610 32 5e ee			ld (debug_mark),a  
b613 3a 22 b6			ld a, (.dmark+1)  
b616 32 5f ee			ld (debug_mark+1),a  
b619 3a 23 b6			ld a, (.dmark+2)  
b61c 32 60 ee			ld (debug_mark+2),a  
b61f 18 03			jr .pastdmark  
b621 ..			.dmark: db "UN<"  
b624 f1			.pastdmark: pop af  
b625			endm  
# End of macro DMARK
b625					CALLMONITOR 
b625 cd 6b ee			call debug_vector  
b628				endm  
# End of macro CALLMONITOR
b628				endif 
b628 c3 30 9e			jp exec1 
b62b			 
b62b					 
b62b			 
b62b			 
b62b					NEXTW 
b62b cd 68 ee			call parse_vector 
b62e c3 af 9d			jp macro_next 
b631				endm 
# End of macro NEXTW
b631			 
b631			 
b631			.ENDFLOW: 
b631			 
b631			; eof 
b631			 
# End of file forth_words_flow.asm
b631			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b631			include "forth_words_logic.asm" 
b631			 
b631			; | ## Logic Words 
b631			 
b631			.NOT: 
b631				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b631 2d				db WORD_SYS_CORE+25             
b632 7f b6			dw .IS            
b634 04				db 3 + 1 
b635 .. 00			db "NOT",0              
b639				endm 
# End of macro CWHEAD
b639			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b639					if DEBUG_FORTH_WORDS_KEY 
b639						DMARK "NOT" 
b639 f5				push af  
b63a 3a 4e b6			ld a, (.dmark)  
b63d 32 5e ee			ld (debug_mark),a  
b640 3a 4f b6			ld a, (.dmark+1)  
b643 32 5f ee			ld (debug_mark+1),a  
b646 3a 50 b6			ld a, (.dmark+2)  
b649 32 60 ee			ld (debug_mark+2),a  
b64c 18 03			jr .pastdmark  
b64e ..			.dmark: db "NOT"  
b651 f1			.pastdmark: pop af  
b652			endm  
# End of macro DMARK
b652						CALLMONITOR 
b652 cd 6b ee			call debug_vector  
b655				endm  
# End of macro CALLMONITOR
b655					endif 
b655					FORTH_DSP 
b655 cd 8e 9b			call macro_forth_dsp 
b658				endm 
# End of macro FORTH_DSP
b658 7e					ld a,(hl)	; get type of value on TOS 
b659 fe 02				cp DS_TYPE_INUM  
b65b 28 06				jr z, .noti 
b65d					NEXTW 
b65d cd 68 ee			call parse_vector 
b660 c3 af 9d			jp macro_next 
b663				endm 
# End of macro NEXTW
b663			.noti:          FORTH_DSP_VALUEHL 
b663 cd c8 9b			call macro_dsp_valuehl 
b666				endm 
# End of macro FORTH_DSP_VALUEHL
b666			;		push hl 
b666					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b666 cd 80 9c			call macro_forth_dsp_pop 
b669				endm 
# End of macro FORTH_DSP_POP
b669			;		pop hl 
b669 3e 00				ld a,0 
b66b bd					cp l 
b66c 28 04				jr z, .not2t 
b66e 2e 00				ld l, 0 
b670 18 02				jr .notip 
b672			 
b672 2e ff		.not2t:		ld l, 255 
b674			 
b674 26 00		.notip:		ld h, 0	 
b676			 
b676 cd cc 99				call forth_push_numhl 
b679					NEXTW 
b679 cd 68 ee			call parse_vector 
b67c c3 af 9d			jp macro_next 
b67f				endm 
# End of macro NEXTW
b67f			 
b67f			.IS: 
b67f				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
b67f 2d				db WORD_SYS_CORE+25             
b680 c3 b6			dw .LZERO            
b682 08				db 7 + 1 
b683 .. 00			db "COMPARE",0              
b68b				endm 
# End of macro CWHEAD
b68b			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
b68b					if DEBUG_FORTH_WORDS_KEY 
b68b						DMARK "CMP" 
b68b f5				push af  
b68c 3a a0 b6			ld a, (.dmark)  
b68f 32 5e ee			ld (debug_mark),a  
b692 3a a1 b6			ld a, (.dmark+1)  
b695 32 5f ee			ld (debug_mark+1),a  
b698 3a a2 b6			ld a, (.dmark+2)  
b69b 32 60 ee			ld (debug_mark+2),a  
b69e 18 03			jr .pastdmark  
b6a0 ..			.dmark: db "CMP"  
b6a3 f1			.pastdmark: pop af  
b6a4			endm  
# End of macro DMARK
b6a4						CALLMONITOR 
b6a4 cd 6b ee			call debug_vector  
b6a7				endm  
# End of macro CALLMONITOR
b6a7					endif 
b6a7			 
b6a7					FORTH_DSP_VALUEHL 
b6a7 cd c8 9b			call macro_dsp_valuehl 
b6aa				endm 
# End of macro FORTH_DSP_VALUEHL
b6aa			 
b6aa e5					push hl 
b6ab			 
b6ab					FORTH_DSP_VALUEM1 
b6ab cd bc 9b			call macro_forth_dsp_value_m1 
b6ae				endm 
# End of macro FORTH_DSP_VALUEM1
b6ae			 
b6ae d1					pop de 
b6af			 
b6af					; got pointers to both. Now check. 
b6af			 
b6af cd 6b 90				call strcmp 
b6b2				 
b6b2 26 00				ld h, 0 
b6b4 2e 00				ld l, 0 
b6b6 20 02				jr nz, .compnsame 
b6b8 2e 01				ld l, 1	 
b6ba			.compnsame: 
b6ba cd cc 99				call forth_push_numhl 
b6bd			 
b6bd					NEXTW 
b6bd cd 68 ee			call parse_vector 
b6c0 c3 af 9d			jp macro_next 
b6c3				endm 
# End of macro NEXTW
b6c3			.LZERO: 
b6c3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b6c3 2d				db WORD_SYS_CORE+25             
b6c4 d0 b6			dw .TZERO            
b6c6 03				db 2 + 1 
b6c7 .. 00			db "0<",0              
b6ca				endm 
# End of macro CWHEAD
b6ca			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b6ca					NEXTW 
b6ca cd 68 ee			call parse_vector 
b6cd c3 af 9d			jp macro_next 
b6d0				endm 
# End of macro NEXTW
b6d0			.TZERO: 
b6d0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b6d0 2e				db WORD_SYS_CORE+26             
b6d1 1a b7			dw .LESS            
b6d3 03				db 2 + 1 
b6d4 .. 00			db "0=",0              
b6d7				endm 
# End of macro CWHEAD
b6d7			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b6d7				; TODO add floating point number detection 
b6d7					;v5 FORTH_DSP_VALUE 
b6d7					if DEBUG_FORTH_WORDS_KEY 
b6d7						DMARK "0=." 
b6d7 f5				push af  
b6d8 3a ec b6			ld a, (.dmark)  
b6db 32 5e ee			ld (debug_mark),a  
b6de 3a ed b6			ld a, (.dmark+1)  
b6e1 32 5f ee			ld (debug_mark+1),a  
b6e4 3a ee b6			ld a, (.dmark+2)  
b6e7 32 60 ee			ld (debug_mark+2),a  
b6ea 18 03			jr .pastdmark  
b6ec ..			.dmark: db "0=."  
b6ef f1			.pastdmark: pop af  
b6f0			endm  
# End of macro DMARK
b6f0						CALLMONITOR 
b6f0 cd 6b ee			call debug_vector  
b6f3				endm  
# End of macro CALLMONITOR
b6f3					endif 
b6f3					FORTH_DSP 
b6f3 cd 8e 9b			call macro_forth_dsp 
b6f6				endm 
# End of macro FORTH_DSP
b6f6 7e					ld a,(hl)	; get type of value on TOS 
b6f7 fe 02				cp DS_TYPE_INUM  
b6f9 28 00				jr z, .tz_inum 
b6fb			 
b6fb				if FORTH_ENABLE_FLOATMATH 
b6fb					jr .tz_done 
b6fb			 
b6fb				endif 
b6fb					 
b6fb			 
b6fb			.tz_inum: 
b6fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6fb cd c8 9b			call macro_dsp_valuehl 
b6fe				endm 
# End of macro FORTH_DSP_VALUEHL
b6fe			 
b6fe			;		push hl 
b6fe			 
b6fe					; destroy value TOS 
b6fe			 
b6fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fe cd 80 9c			call macro_forth_dsp_pop 
b701				endm 
# End of macro FORTH_DSP_POP
b701			 
b701			;		pop hl 
b701			 
b701 3e 00				ld a,0 
b703			 
b703 bd					cp l 
b704 20 08				jr nz, .tz_notzero 
b706			 
b706 bc					cp h 
b707			 
b707 20 05				jr nz, .tz_notzero 
b709			 
b709			 
b709 21 01 00				ld hl, FORTH_TRUE 
b70c 18 03				jr .tz_done 
b70e			 
b70e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b711			 
b711					; push value back onto stack for another op etc 
b711			 
b711			.tz_done: 
b711 cd cc 99				call forth_push_numhl 
b714			 
b714					NEXTW 
b714 cd 68 ee			call parse_vector 
b717 c3 af 9d			jp macro_next 
b71a				endm 
# End of macro NEXTW
b71a			.LESS: 
b71a				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b71a 2f				db WORD_SYS_CORE+27             
b71b 86 b7			dw .GT            
b71d 02				db 1 + 1 
b71e .. 00			db "<",0              
b720				endm 
# End of macro CWHEAD
b720			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b720				; TODO add floating point number detection 
b720					if DEBUG_FORTH_WORDS_KEY 
b720						DMARK "LES" 
b720 f5				push af  
b721 3a 35 b7			ld a, (.dmark)  
b724 32 5e ee			ld (debug_mark),a  
b727 3a 36 b7			ld a, (.dmark+1)  
b72a 32 5f ee			ld (debug_mark+1),a  
b72d 3a 37 b7			ld a, (.dmark+2)  
b730 32 60 ee			ld (debug_mark+2),a  
b733 18 03			jr .pastdmark  
b735 ..			.dmark: db "LES"  
b738 f1			.pastdmark: pop af  
b739			endm  
# End of macro DMARK
b739						CALLMONITOR 
b739 cd 6b ee			call debug_vector  
b73c				endm  
# End of macro CALLMONITOR
b73c					endif 
b73c					FORTH_DSP 
b73c cd 8e 9b			call macro_forth_dsp 
b73f				endm 
# End of macro FORTH_DSP
b73f					;v5 FORTH_DSP_VALUE 
b73f 7e					ld a,(hl)	; get type of value on TOS 
b740 fe 02				cp DS_TYPE_INUM  
b742 28 00				jr z, .less_inum 
b744			 
b744				if FORTH_ENABLE_FLOATMATH 
b744					jr .less_done 
b744			 
b744				endif 
b744					 
b744			 
b744			.less_inum: 
b744					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b744 cd c8 9b			call macro_dsp_valuehl 
b747				endm 
# End of macro FORTH_DSP_VALUEHL
b747			 
b747 e5					push hl  ; u2 
b748			 
b748					; destroy value TOS 
b748			 
b748					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b748 cd 80 9c			call macro_forth_dsp_pop 
b74b				endm 
# End of macro FORTH_DSP_POP
b74b			 
b74b			 
b74b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b74b cd c8 9b			call macro_dsp_valuehl 
b74e				endm 
# End of macro FORTH_DSP_VALUEHL
b74e			 
b74e e5					push hl    ; u1 
b74f			 
b74f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b74f cd 80 9c			call macro_forth_dsp_pop 
b752				endm 
# End of macro FORTH_DSP_POP
b752			 
b752			 
b752 b7			 or a      ;clear carry flag 
b753 01 00 00		 ld bc, FORTH_FALSE 
b756 e1			  pop hl    ; u1 
b757 d1			  pop de    ; u2 
b758 ed 52		  sbc hl,de 
b75a 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b75c			 
b75c 01 01 00		 ld bc, FORTH_TRUE 
b75f			.lscont:  
b75f c5					push bc 
b760 e1					pop hl 
b761			 
b761					if DEBUG_FORTH_WORDS 
b761						DMARK "LT1" 
b761 f5				push af  
b762 3a 76 b7			ld a, (.dmark)  
b765 32 5e ee			ld (debug_mark),a  
b768 3a 77 b7			ld a, (.dmark+1)  
b76b 32 5f ee			ld (debug_mark+1),a  
b76e 3a 78 b7			ld a, (.dmark+2)  
b771 32 60 ee			ld (debug_mark+2),a  
b774 18 03			jr .pastdmark  
b776 ..			.dmark: db "LT1"  
b779 f1			.pastdmark: pop af  
b77a			endm  
# End of macro DMARK
b77a						CALLMONITOR 
b77a cd 6b ee			call debug_vector  
b77d				endm  
# End of macro CALLMONITOR
b77d					endif 
b77d cd cc 99				call forth_push_numhl 
b780			 
b780					NEXTW 
b780 cd 68 ee			call parse_vector 
b783 c3 af 9d			jp macro_next 
b786				endm 
# End of macro NEXTW
b786			.GT: 
b786				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b786 30				db WORD_SYS_CORE+28             
b787 f2 b7			dw .EQUAL            
b789 02				db 1 + 1 
b78a .. 00			db ">",0              
b78c				endm 
# End of macro CWHEAD
b78c			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b78c				; TODO add floating point number detection 
b78c					if DEBUG_FORTH_WORDS_KEY 
b78c						DMARK "GRT" 
b78c f5				push af  
b78d 3a a1 b7			ld a, (.dmark)  
b790 32 5e ee			ld (debug_mark),a  
b793 3a a2 b7			ld a, (.dmark+1)  
b796 32 5f ee			ld (debug_mark+1),a  
b799 3a a3 b7			ld a, (.dmark+2)  
b79c 32 60 ee			ld (debug_mark+2),a  
b79f 18 03			jr .pastdmark  
b7a1 ..			.dmark: db "GRT"  
b7a4 f1			.pastdmark: pop af  
b7a5			endm  
# End of macro DMARK
b7a5						CALLMONITOR 
b7a5 cd 6b ee			call debug_vector  
b7a8				endm  
# End of macro CALLMONITOR
b7a8					endif 
b7a8					FORTH_DSP 
b7a8 cd 8e 9b			call macro_forth_dsp 
b7ab				endm 
# End of macro FORTH_DSP
b7ab					;FORTH_DSP_VALUE 
b7ab 7e					ld a,(hl)	; get type of value on TOS 
b7ac fe 02				cp DS_TYPE_INUM  
b7ae 28 00				jr z, .gt_inum 
b7b0			 
b7b0				if FORTH_ENABLE_FLOATMATH 
b7b0					jr .gt_done 
b7b0			 
b7b0				endif 
b7b0					 
b7b0			 
b7b0			.gt_inum: 
b7b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7b0 cd c8 9b			call macro_dsp_valuehl 
b7b3				endm 
# End of macro FORTH_DSP_VALUEHL
b7b3			 
b7b3 e5					push hl  ; u2 
b7b4			 
b7b4					; destroy value TOS 
b7b4			 
b7b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7b4 cd 80 9c			call macro_forth_dsp_pop 
b7b7				endm 
# End of macro FORTH_DSP_POP
b7b7			 
b7b7			 
b7b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7b7 cd c8 9b			call macro_dsp_valuehl 
b7ba				endm 
# End of macro FORTH_DSP_VALUEHL
b7ba			 
b7ba e5					push hl    ; u1 
b7bb			 
b7bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7bb cd 80 9c			call macro_forth_dsp_pop 
b7be				endm 
# End of macro FORTH_DSP_POP
b7be			 
b7be			 
b7be b7			 or a      ;clear carry flag 
b7bf 01 00 00		 ld bc, FORTH_FALSE 
b7c2 e1			  pop hl    ; u1 
b7c3 d1			  pop de    ; u2 
b7c4 ed 52		  sbc hl,de 
b7c6 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b7c8			 
b7c8 01 01 00		 ld bc, FORTH_TRUE 
b7cb			.gtcont:  
b7cb c5					push bc 
b7cc e1					pop hl 
b7cd			 
b7cd					if DEBUG_FORTH_WORDS 
b7cd						DMARK "GT1" 
b7cd f5				push af  
b7ce 3a e2 b7			ld a, (.dmark)  
b7d1 32 5e ee			ld (debug_mark),a  
b7d4 3a e3 b7			ld a, (.dmark+1)  
b7d7 32 5f ee			ld (debug_mark+1),a  
b7da 3a e4 b7			ld a, (.dmark+2)  
b7dd 32 60 ee			ld (debug_mark+2),a  
b7e0 18 03			jr .pastdmark  
b7e2 ..			.dmark: db "GT1"  
b7e5 f1			.pastdmark: pop af  
b7e6			endm  
# End of macro DMARK
b7e6						CALLMONITOR 
b7e6 cd 6b ee			call debug_vector  
b7e9				endm  
# End of macro CALLMONITOR
b7e9					endif 
b7e9 cd cc 99				call forth_push_numhl 
b7ec			 
b7ec					NEXTW 
b7ec cd 68 ee			call parse_vector 
b7ef c3 af 9d			jp macro_next 
b7f2				endm 
# End of macro NEXTW
b7f2			.EQUAL: 
b7f2				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b7f2 31				db WORD_SYS_CORE+29             
b7f3 60 b8			dw .ENDLOGIC            
b7f5 02				db 1 + 1 
b7f6 .. 00			db "=",0              
b7f8				endm 
# End of macro CWHEAD
b7f8			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b7f8				; TODO add floating point number detection 
b7f8					if DEBUG_FORTH_WORDS_KEY 
b7f8						DMARK "EQ." 
b7f8 f5				push af  
b7f9 3a 0d b8			ld a, (.dmark)  
b7fc 32 5e ee			ld (debug_mark),a  
b7ff 3a 0e b8			ld a, (.dmark+1)  
b802 32 5f ee			ld (debug_mark+1),a  
b805 3a 0f b8			ld a, (.dmark+2)  
b808 32 60 ee			ld (debug_mark+2),a  
b80b 18 03			jr .pastdmark  
b80d ..			.dmark: db "EQ."  
b810 f1			.pastdmark: pop af  
b811			endm  
# End of macro DMARK
b811						CALLMONITOR 
b811 cd 6b ee			call debug_vector  
b814				endm  
# End of macro CALLMONITOR
b814					endif 
b814					FORTH_DSP 
b814 cd 8e 9b			call macro_forth_dsp 
b817				endm 
# End of macro FORTH_DSP
b817					;v5 FORTH_DSP_VALUE 
b817 7e					ld a,(hl)	; get type of value on TOS 
b818 fe 02				cp DS_TYPE_INUM  
b81a 28 00				jr z, .eq_inum 
b81c			 
b81c				if FORTH_ENABLE_FLOATMATH 
b81c					jr .eq_done 
b81c			 
b81c				endif 
b81c					 
b81c			 
b81c			.eq_inum: 
b81c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b81c cd c8 9b			call macro_dsp_valuehl 
b81f				endm 
# End of macro FORTH_DSP_VALUEHL
b81f			 
b81f e5					push hl 
b820			 
b820					; destroy value TOS 
b820			 
b820					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b820 cd 80 9c			call macro_forth_dsp_pop 
b823				endm 
# End of macro FORTH_DSP_POP
b823			 
b823			 
b823					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b823 cd c8 9b			call macro_dsp_valuehl 
b826				endm 
# End of macro FORTH_DSP_VALUEHL
b826			 
b826					; one value on hl get other one back 
b826			 
b826 e5					push hl 
b827			 
b827					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b827 cd 80 9c			call macro_forth_dsp_pop 
b82a				endm 
# End of macro FORTH_DSP_POP
b82a			 
b82a 0e 00				ld c, FORTH_FALSE 
b82c			 
b82c e1					pop hl 
b82d d1					pop de 
b82e			 
b82e 7b					ld a, e 
b82f bd					cp l 
b830			 
b830 20 06				jr nz, .eq_done 
b832			 
b832 7a					ld a, d 
b833 bc					cp h 
b834			 
b834 20 02				jr nz, .eq_done 
b836			 
b836 0e 01				ld c, FORTH_TRUE 
b838					 
b838			 
b838			 
b838			.eq_done: 
b838			 
b838					; TODO push value back onto stack for another op etc 
b838			 
b838 26 00				ld h, 0 
b83a 69					ld l, c 
b83b					if DEBUG_FORTH_WORDS 
b83b						DMARK "EQ1" 
b83b f5				push af  
b83c 3a 50 b8			ld a, (.dmark)  
b83f 32 5e ee			ld (debug_mark),a  
b842 3a 51 b8			ld a, (.dmark+1)  
b845 32 5f ee			ld (debug_mark+1),a  
b848 3a 52 b8			ld a, (.dmark+2)  
b84b 32 60 ee			ld (debug_mark+2),a  
b84e 18 03			jr .pastdmark  
b850 ..			.dmark: db "EQ1"  
b853 f1			.pastdmark: pop af  
b854			endm  
# End of macro DMARK
b854						CALLMONITOR 
b854 cd 6b ee			call debug_vector  
b857				endm  
# End of macro CALLMONITOR
b857					endif 
b857 cd cc 99				call forth_push_numhl 
b85a			 
b85a					NEXTW 
b85a cd 68 ee			call parse_vector 
b85d c3 af 9d			jp macro_next 
b860				endm 
# End of macro NEXTW
b860			 
b860			 
b860			.ENDLOGIC: 
b860			; eof 
b860			 
b860			 
# End of file forth_words_logic.asm
b860			include "forth_words_maths.asm" 
b860			 
b860			; | ## Maths Words 
b860			 
b860			.PLUS:	 
b860				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b860 15				db WORD_SYS_CORE+1             
b861 c4 b8			dw .NEG            
b863 02				db 1 + 1 
b864 .. 00			db "+",0              
b866				endm 
# End of macro CWHEAD
b866			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b866					if DEBUG_FORTH_WORDS_KEY 
b866						DMARK "PLU" 
b866 f5				push af  
b867 3a 7b b8			ld a, (.dmark)  
b86a 32 5e ee			ld (debug_mark),a  
b86d 3a 7c b8			ld a, (.dmark+1)  
b870 32 5f ee			ld (debug_mark+1),a  
b873 3a 7d b8			ld a, (.dmark+2)  
b876 32 60 ee			ld (debug_mark+2),a  
b879 18 03			jr .pastdmark  
b87b ..			.dmark: db "PLU"  
b87e f1			.pastdmark: pop af  
b87f			endm  
# End of macro DMARK
b87f						CALLMONITOR 
b87f cd 6b ee			call debug_vector  
b882				endm  
# End of macro CALLMONITOR
b882					endif 
b882					; add top two values and push back result 
b882			 
b882					;for v5 FORTH_DSP_VALUE 
b882					FORTH_DSP 
b882 cd 8e 9b			call macro_forth_dsp 
b885				endm 
# End of macro FORTH_DSP
b885 7e					ld a,(hl)	; get type of value on TOS 
b886 fe 02				cp DS_TYPE_INUM  
b888 28 06				jr z, .dot_inum 
b88a			 
b88a					NEXTW 
b88a cd 68 ee			call parse_vector 
b88d c3 af 9d			jp macro_next 
b890				endm 
# End of macro NEXTW
b890			 
b890			; float maths 
b890			 
b890				if FORTH_ENABLE_FLOATMATH 
b890						inc hl      ; now at start of numeric as string 
b890			 
b890					if DEBUG_FORTH_MATHS 
b890						DMARK "ADD" 
b890				CALLMONITOR 
b890					endif 
b890			 
b890					;ld ix, hl 
b890					call CON 
b890			 
b890			 
b890					push hl 
b890					 
b890					 
b890			 
b890						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b890			 
b890					; get next number 
b890			 
b890						FORTH_DSP_VALUE 
b890			 
b890						inc hl      ; now at start of numeric as string 
b890			 
b890					;ld ix, hl 
b890					call CON 
b890			 
b890					push hl 
b890			 
b890			 
b890						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b890			 
b890						; TODO do add 
b890			 
b890						call IADD 
b890			 
b890						; TODO get result back as ascii 
b890			 
b890						; TODO push result  
b890			 
b890			 
b890			 
b890						jr .dot_done 
b890				endif 
b890			 
b890			.dot_inum: 
b890			 
b890			 
b890					if DEBUG_FORTH_DOT 
b890						DMARK "+IT" 
b890 f5				push af  
b891 3a a5 b8			ld a, (.dmark)  
b894 32 5e ee			ld (debug_mark),a  
b897 3a a6 b8			ld a, (.dmark+1)  
b89a 32 5f ee			ld (debug_mark+1),a  
b89d 3a a7 b8			ld a, (.dmark+2)  
b8a0 32 60 ee			ld (debug_mark+2),a  
b8a3 18 03			jr .pastdmark  
b8a5 ..			.dmark: db "+IT"  
b8a8 f1			.pastdmark: pop af  
b8a9			endm  
# End of macro DMARK
b8a9				CALLMONITOR 
b8a9 cd 6b ee			call debug_vector  
b8ac				endm  
# End of macro CALLMONITOR
b8ac					endif 
b8ac			 
b8ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8ac cd c8 9b			call macro_dsp_valuehl 
b8af				endm 
# End of macro FORTH_DSP_VALUEHL
b8af			 
b8af				; TODO add floating point number detection 
b8af			 
b8af e5					push hl 
b8b0			 
b8b0					; destroy value TOS 
b8b0			 
b8b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8b0 cd 80 9c			call macro_forth_dsp_pop 
b8b3				endm 
# End of macro FORTH_DSP_POP
b8b3			 
b8b3			 
b8b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8b3 cd c8 9b			call macro_dsp_valuehl 
b8b6				endm 
# End of macro FORTH_DSP_VALUEHL
b8b6			 
b8b6					; one value on hl get other one back 
b8b6			 
b8b6 d1					pop de 
b8b7			 
b8b7					; do the add 
b8b7			 
b8b7 19					add hl,de 
b8b8			 
b8b8					; save it 
b8b8			 
b8b8			;		push hl	 
b8b8			 
b8b8					; 
b8b8			 
b8b8					; destroy value TOS 
b8b8			 
b8b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8b8 cd 80 9c			call macro_forth_dsp_pop 
b8bb				endm 
# End of macro FORTH_DSP_POP
b8bb			 
b8bb					; TODO push value back onto stack for another op etc 
b8bb			 
b8bb			;		pop hl 
b8bb			 
b8bb			.dot_done: 
b8bb cd cc 99				call forth_push_numhl 
b8be			 
b8be					NEXTW 
b8be cd 68 ee			call parse_vector 
b8c1 c3 af 9d			jp macro_next 
b8c4				endm 
# End of macro NEXTW
b8c4			.NEG: 
b8c4			 
b8c4				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b8c4 17				db WORD_SYS_CORE+3             
b8c5 0d b9			dw .DIV            
b8c7 02				db 1 + 1 
b8c8 .. 00			db "-",0              
b8ca				endm 
# End of macro CWHEAD
b8ca			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b8ca					if DEBUG_FORTH_WORDS_KEY 
b8ca						DMARK "SUB" 
b8ca f5				push af  
b8cb 3a df b8			ld a, (.dmark)  
b8ce 32 5e ee			ld (debug_mark),a  
b8d1 3a e0 b8			ld a, (.dmark+1)  
b8d4 32 5f ee			ld (debug_mark+1),a  
b8d7 3a e1 b8			ld a, (.dmark+2)  
b8da 32 60 ee			ld (debug_mark+2),a  
b8dd 18 03			jr .pastdmark  
b8df ..			.dmark: db "SUB"  
b8e2 f1			.pastdmark: pop af  
b8e3			endm  
# End of macro DMARK
b8e3						CALLMONITOR 
b8e3 cd 6b ee			call debug_vector  
b8e6				endm  
# End of macro CALLMONITOR
b8e6					endif 
b8e6			 
b8e6			 
b8e6				; TODO add floating point number detection 
b8e6					; v5 FORTH_DSP_VALUE 
b8e6					FORTH_DSP 
b8e6 cd 8e 9b			call macro_forth_dsp 
b8e9				endm 
# End of macro FORTH_DSP
b8e9 7e					ld a,(hl)	; get type of value on TOS 
b8ea fe 02				cp DS_TYPE_INUM  
b8ec 28 06				jr z, .neg_inum 
b8ee			 
b8ee					NEXTW 
b8ee cd 68 ee			call parse_vector 
b8f1 c3 af 9d			jp macro_next 
b8f4				endm 
# End of macro NEXTW
b8f4			 
b8f4			; float maths 
b8f4			 
b8f4				if FORTH_ENABLE_FLOATMATH 
b8f4					jr .neg_done 
b8f4			 
b8f4				endif 
b8f4					 
b8f4			 
b8f4			.neg_inum: 
b8f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8f4 cd c8 9b			call macro_dsp_valuehl 
b8f7				endm 
# End of macro FORTH_DSP_VALUEHL
b8f7			 
b8f7 e5					push hl 
b8f8			 
b8f8					; destroy value TOS 
b8f8			 
b8f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8f8 cd 80 9c			call macro_forth_dsp_pop 
b8fb				endm 
# End of macro FORTH_DSP_POP
b8fb			 
b8fb			 
b8fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8fb cd c8 9b			call macro_dsp_valuehl 
b8fe				endm 
# End of macro FORTH_DSP_VALUEHL
b8fe			 
b8fe					; one value on hl get other one back 
b8fe			 
b8fe d1					pop de 
b8ff			 
b8ff					; do the sub 
b8ff			;		ex de, hl 
b8ff			 
b8ff ed 52				sbc hl,de 
b901			 
b901					; save it 
b901			 
b901			;		push hl	 
b901			 
b901					; 
b901			 
b901					; destroy value TOS 
b901			 
b901					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b901 cd 80 9c			call macro_forth_dsp_pop 
b904				endm 
# End of macro FORTH_DSP_POP
b904			 
b904					; TODO push value back onto stack for another op etc 
b904			 
b904			;		pop hl 
b904			 
b904 cd cc 99				call forth_push_numhl 
b907			.neg_done: 
b907			 
b907					NEXTW 
b907 cd 68 ee			call parse_vector 
b90a c3 af 9d			jp macro_next 
b90d				endm 
# End of macro NEXTW
b90d			.DIV: 
b90d				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b90d 18				db WORD_SYS_CORE+4             
b90e 60 b9			dw .MUL            
b910 02				db 1 + 1 
b911 .. 00			db "/",0              
b913				endm 
# End of macro CWHEAD
b913			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b913					if DEBUG_FORTH_WORDS_KEY 
b913						DMARK "DIV" 
b913 f5				push af  
b914 3a 28 b9			ld a, (.dmark)  
b917 32 5e ee			ld (debug_mark),a  
b91a 3a 29 b9			ld a, (.dmark+1)  
b91d 32 5f ee			ld (debug_mark+1),a  
b920 3a 2a b9			ld a, (.dmark+2)  
b923 32 60 ee			ld (debug_mark+2),a  
b926 18 03			jr .pastdmark  
b928 ..			.dmark: db "DIV"  
b92b f1			.pastdmark: pop af  
b92c			endm  
# End of macro DMARK
b92c						CALLMONITOR 
b92c cd 6b ee			call debug_vector  
b92f				endm  
# End of macro CALLMONITOR
b92f					endif 
b92f				; TODO add floating point number detection 
b92f					; v5 FORTH_DSP_VALUE 
b92f					FORTH_DSP 
b92f cd 8e 9b			call macro_forth_dsp 
b932				endm 
# End of macro FORTH_DSP
b932 7e					ld a,(hl)	; get type of value on TOS 
b933 fe 02				cp DS_TYPE_INUM  
b935 28 06				jr z, .div_inum 
b937			 
b937				if FORTH_ENABLE_FLOATMATH 
b937					jr .div_done 
b937			 
b937				endif 
b937					NEXTW 
b937 cd 68 ee			call parse_vector 
b93a c3 af 9d			jp macro_next 
b93d				endm 
# End of macro NEXTW
b93d			.div_inum: 
b93d			 
b93d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b93d cd c8 9b			call macro_dsp_valuehl 
b940				endm 
# End of macro FORTH_DSP_VALUEHL
b940			 
b940 e5					push hl    ; to go to bc 
b941			 
b941					; destroy value TOS 
b941			 
b941					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b941 cd 80 9c			call macro_forth_dsp_pop 
b944				endm 
# End of macro FORTH_DSP_POP
b944			 
b944			 
b944					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b944 cd c8 9b			call macro_dsp_valuehl 
b947				endm 
# End of macro FORTH_DSP_VALUEHL
b947			 
b947					; hl to go to de 
b947			 
b947 e5					push hl 
b948			 
b948 c1					pop bc 
b949 d1					pop de		 
b94a			 
b94a			 
b94a					if DEBUG_FORTH_MATHS 
b94a						DMARK "DIV" 
b94a				CALLMONITOR 
b94a					endif 
b94a					; one value on hl but move to a get other one back 
b94a			 
b94a			        
b94a cd 38 8c			call Div16 
b94d			 
b94d			;	push af	 
b94d e5				push hl 
b94e c5				push bc 
b94f			 
b94f					if DEBUG_FORTH_MATHS 
b94f						DMARK "DI1" 
b94f				CALLMONITOR 
b94f					endif 
b94f			 
b94f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b94f cd 80 9c			call macro_forth_dsp_pop 
b952				endm 
# End of macro FORTH_DSP_POP
b952			 
b952			 
b952			 
b952 e1					pop hl    ; result 
b953			 
b953 cd cc 99				call forth_push_numhl 
b956			 
b956 e1					pop hl    ; reminder 
b957			;		ld h,0 
b957			;		ld l,d 
b957			 
b957 cd cc 99				call forth_push_numhl 
b95a			.div_done: 
b95a					NEXTW 
b95a cd 68 ee			call parse_vector 
b95d c3 af 9d			jp macro_next 
b960				endm 
# End of macro NEXTW
b960			.MUL: 
b960				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b960 19				db WORD_SYS_CORE+5             
b961 ab b9			dw .MIN            
b963 02				db 1 + 1 
b964 .. 00			db "*",0              
b966				endm 
# End of macro CWHEAD
b966			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b966				; TODO add floating point number detection 
b966					if DEBUG_FORTH_WORDS_KEY 
b966						DMARK "MUL" 
b966 f5				push af  
b967 3a 7b b9			ld a, (.dmark)  
b96a 32 5e ee			ld (debug_mark),a  
b96d 3a 7c b9			ld a, (.dmark+1)  
b970 32 5f ee			ld (debug_mark+1),a  
b973 3a 7d b9			ld a, (.dmark+2)  
b976 32 60 ee			ld (debug_mark+2),a  
b979 18 03			jr .pastdmark  
b97b ..			.dmark: db "MUL"  
b97e f1			.pastdmark: pop af  
b97f			endm  
# End of macro DMARK
b97f						CALLMONITOR 
b97f cd 6b ee			call debug_vector  
b982				endm  
# End of macro CALLMONITOR
b982					endif 
b982					FORTH_DSP 
b982 cd 8e 9b			call macro_forth_dsp 
b985				endm 
# End of macro FORTH_DSP
b985					; v5 FORTH_DSP_VALUE 
b985 7e					ld a,(hl)	; get type of value on TOS 
b986 fe 02				cp DS_TYPE_INUM  
b988 28 06				jr z, .mul_inum 
b98a			 
b98a				if FORTH_ENABLE_FLOATMATH 
b98a					jr .mul_done 
b98a			 
b98a				endif 
b98a			 
b98a					NEXTW 
b98a cd 68 ee			call parse_vector 
b98d c3 af 9d			jp macro_next 
b990				endm 
# End of macro NEXTW
b990			.mul_inum:	 
b990			 
b990					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b990 cd c8 9b			call macro_dsp_valuehl 
b993				endm 
# End of macro FORTH_DSP_VALUEHL
b993			 
b993 e5					push hl 
b994			 
b994					; destroy value TOS 
b994			 
b994					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b994 cd 80 9c			call macro_forth_dsp_pop 
b997				endm 
# End of macro FORTH_DSP_POP
b997			 
b997			 
b997					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b997 cd c8 9b			call macro_dsp_valuehl 
b99a				endm 
# End of macro FORTH_DSP_VALUEHL
b99a			 
b99a					; one value on hl but move to a get other one back 
b99a			 
b99a 7d					ld a, l 
b99b			 
b99b d1					pop de 
b99c			 
b99c					; do the mull 
b99c			;		ex de, hl 
b99c			 
b99c cd 5e 8c				call Mult16 
b99f					; save it 
b99f			 
b99f			;		push hl	 
b99f			 
b99f					; 
b99f			 
b99f					; destroy value TOS 
b99f			 
b99f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b99f cd 80 9c			call macro_forth_dsp_pop 
b9a2				endm 
# End of macro FORTH_DSP_POP
b9a2			 
b9a2					; TODO push value back onto stack for another op etc 
b9a2			 
b9a2			;		pop hl 
b9a2			 
b9a2 cd cc 99				call forth_push_numhl 
b9a5			 
b9a5			.mul_done: 
b9a5					NEXTW 
b9a5 cd 68 ee			call parse_vector 
b9a8 c3 af 9d			jp macro_next 
b9ab				endm 
# End of macro NEXTW
b9ab			 
b9ab			 
b9ab			 
b9ab			 
b9ab			.MIN: 
b9ab				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b9ab 49				db WORD_SYS_CORE+53             
b9ac 32 ba			dw .MAX            
b9ae 04				db 3 + 1 
b9af .. 00			db "MIN",0              
b9b3				endm 
# End of macro CWHEAD
b9b3			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b9b3					if DEBUG_FORTH_WORDS_KEY 
b9b3						DMARK "MIN" 
b9b3 f5				push af  
b9b4 3a c8 b9			ld a, (.dmark)  
b9b7 32 5e ee			ld (debug_mark),a  
b9ba 3a c9 b9			ld a, (.dmark+1)  
b9bd 32 5f ee			ld (debug_mark+1),a  
b9c0 3a ca b9			ld a, (.dmark+2)  
b9c3 32 60 ee			ld (debug_mark+2),a  
b9c6 18 03			jr .pastdmark  
b9c8 ..			.dmark: db "MIN"  
b9cb f1			.pastdmark: pop af  
b9cc			endm  
# End of macro DMARK
b9cc						CALLMONITOR 
b9cc cd 6b ee			call debug_vector  
b9cf				endm  
# End of macro CALLMONITOR
b9cf					endif 
b9cf					; get u2 
b9cf			 
b9cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9cf cd c8 9b			call macro_dsp_valuehl 
b9d2				endm 
# End of macro FORTH_DSP_VALUEHL
b9d2			 
b9d2 e5					push hl   ; u2 
b9d3			 
b9d3					; destroy value TOS 
b9d3			 
b9d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9d3 cd 80 9c			call macro_forth_dsp_pop 
b9d6				endm 
# End of macro FORTH_DSP_POP
b9d6			 
b9d6					; get u1 
b9d6			 
b9d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9d6 cd c8 9b			call macro_dsp_valuehl 
b9d9				endm 
# End of macro FORTH_DSP_VALUEHL
b9d9			 
b9d9 e5					push hl  ; u1 
b9da			 
b9da					; destroy value TOS 
b9da			 
b9da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9da cd 80 9c			call macro_forth_dsp_pop 
b9dd				endm 
# End of macro FORTH_DSP_POP
b9dd			 
b9dd b7			 or a      ;clear carry flag 
b9de e1			  pop hl    ; u1 
b9df d1			  pop de    ; u2 
b9e0 e5				push hl   ; saved in case hl is lowest 
b9e1 ed 52		  sbc hl,de 
b9e3 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b9e5			 
b9e5 e1				pop hl 
b9e6					if DEBUG_FORTH_WORDS 
b9e6						DMARK "MIN" 
b9e6 f5				push af  
b9e7 3a fb b9			ld a, (.dmark)  
b9ea 32 5e ee			ld (debug_mark),a  
b9ed 3a fc b9			ld a, (.dmark+1)  
b9f0 32 5f ee			ld (debug_mark+1),a  
b9f3 3a fd b9			ld a, (.dmark+2)  
b9f6 32 60 ee			ld (debug_mark+2),a  
b9f9 18 03			jr .pastdmark  
b9fb ..			.dmark: db "MIN"  
b9fe f1			.pastdmark: pop af  
b9ff			endm  
# End of macro DMARK
b9ff						CALLMONITOR 
b9ff cd 6b ee			call debug_vector  
ba02				endm  
# End of macro CALLMONITOR
ba02					endif 
ba02 cd cc 99				call forth_push_numhl 
ba05			 
ba05				       NEXTW 
ba05 cd 68 ee			call parse_vector 
ba08 c3 af 9d			jp macro_next 
ba0b				endm 
# End of macro NEXTW
ba0b			 
ba0b			.mincont:  
ba0b c1				pop bc   ; tidy up 
ba0c eb				ex de , hl  
ba0d					if DEBUG_FORTH_WORDS 
ba0d						DMARK "MI1" 
ba0d f5				push af  
ba0e 3a 22 ba			ld a, (.dmark)  
ba11 32 5e ee			ld (debug_mark),a  
ba14 3a 23 ba			ld a, (.dmark+1)  
ba17 32 5f ee			ld (debug_mark+1),a  
ba1a 3a 24 ba			ld a, (.dmark+2)  
ba1d 32 60 ee			ld (debug_mark+2),a  
ba20 18 03			jr .pastdmark  
ba22 ..			.dmark: db "MI1"  
ba25 f1			.pastdmark: pop af  
ba26			endm  
# End of macro DMARK
ba26						CALLMONITOR 
ba26 cd 6b ee			call debug_vector  
ba29				endm  
# End of macro CALLMONITOR
ba29					endif 
ba29 cd cc 99				call forth_push_numhl 
ba2c			 
ba2c				       NEXTW 
ba2c cd 68 ee			call parse_vector 
ba2f c3 af 9d			jp macro_next 
ba32				endm 
# End of macro NEXTW
ba32			.MAX: 
ba32				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
ba32 4a				db WORD_SYS_CORE+54             
ba33 b9 ba			dw .RND16            
ba35 04				db 3 + 1 
ba36 .. 00			db "MAX",0              
ba3a				endm 
# End of macro CWHEAD
ba3a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
ba3a					if DEBUG_FORTH_WORDS_KEY 
ba3a						DMARK "MAX" 
ba3a f5				push af  
ba3b 3a 4f ba			ld a, (.dmark)  
ba3e 32 5e ee			ld (debug_mark),a  
ba41 3a 50 ba			ld a, (.dmark+1)  
ba44 32 5f ee			ld (debug_mark+1),a  
ba47 3a 51 ba			ld a, (.dmark+2)  
ba4a 32 60 ee			ld (debug_mark+2),a  
ba4d 18 03			jr .pastdmark  
ba4f ..			.dmark: db "MAX"  
ba52 f1			.pastdmark: pop af  
ba53			endm  
# End of macro DMARK
ba53						CALLMONITOR 
ba53 cd 6b ee			call debug_vector  
ba56				endm  
# End of macro CALLMONITOR
ba56					endif 
ba56					; get u2 
ba56			 
ba56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba56 cd c8 9b			call macro_dsp_valuehl 
ba59				endm 
# End of macro FORTH_DSP_VALUEHL
ba59			 
ba59 e5					push hl   ; u2 
ba5a			 
ba5a					; destroy value TOS 
ba5a			 
ba5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba5a cd 80 9c			call macro_forth_dsp_pop 
ba5d				endm 
# End of macro FORTH_DSP_POP
ba5d			 
ba5d					; get u1 
ba5d			 
ba5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba5d cd c8 9b			call macro_dsp_valuehl 
ba60				endm 
# End of macro FORTH_DSP_VALUEHL
ba60			 
ba60 e5					push hl  ; u1 
ba61			 
ba61					; destroy value TOS 
ba61			 
ba61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba61 cd 80 9c			call macro_forth_dsp_pop 
ba64				endm 
# End of macro FORTH_DSP_POP
ba64			 
ba64 b7			 or a      ;clear carry flag 
ba65 e1			  pop hl    ; u1 
ba66 d1			  pop de    ; u2 
ba67 e5				push hl   ; saved in case hl is lowest 
ba68 ed 52		  sbc hl,de 
ba6a 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
ba6c			 
ba6c e1				pop hl 
ba6d					if DEBUG_FORTH_WORDS 
ba6d						DMARK "MAX" 
ba6d f5				push af  
ba6e 3a 82 ba			ld a, (.dmark)  
ba71 32 5e ee			ld (debug_mark),a  
ba74 3a 83 ba			ld a, (.dmark+1)  
ba77 32 5f ee			ld (debug_mark+1),a  
ba7a 3a 84 ba			ld a, (.dmark+2)  
ba7d 32 60 ee			ld (debug_mark+2),a  
ba80 18 03			jr .pastdmark  
ba82 ..			.dmark: db "MAX"  
ba85 f1			.pastdmark: pop af  
ba86			endm  
# End of macro DMARK
ba86						CALLMONITOR 
ba86 cd 6b ee			call debug_vector  
ba89				endm  
# End of macro CALLMONITOR
ba89					endif 
ba89 cd cc 99				call forth_push_numhl 
ba8c			 
ba8c				       NEXTW 
ba8c cd 68 ee			call parse_vector 
ba8f c3 af 9d			jp macro_next 
ba92				endm 
# End of macro NEXTW
ba92			 
ba92			.maxcont:  
ba92 c1				pop bc   ; tidy up 
ba93 eb				ex de , hl  
ba94					if DEBUG_FORTH_WORDS 
ba94						DMARK "MA1" 
ba94 f5				push af  
ba95 3a a9 ba			ld a, (.dmark)  
ba98 32 5e ee			ld (debug_mark),a  
ba9b 3a aa ba			ld a, (.dmark+1)  
ba9e 32 5f ee			ld (debug_mark+1),a  
baa1 3a ab ba			ld a, (.dmark+2)  
baa4 32 60 ee			ld (debug_mark+2),a  
baa7 18 03			jr .pastdmark  
baa9 ..			.dmark: db "MA1"  
baac f1			.pastdmark: pop af  
baad			endm  
# End of macro DMARK
baad						CALLMONITOR 
baad cd 6b ee			call debug_vector  
bab0				endm  
# End of macro CALLMONITOR
bab0					endif 
bab0 cd cc 99				call forth_push_numhl 
bab3				       NEXTW 
bab3 cd 68 ee			call parse_vector 
bab6 c3 af 9d			jp macro_next 
bab9				endm 
# End of macro NEXTW
bab9			 
bab9			.RND16: 
bab9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
bab9 4e				db WORD_SYS_CORE+58             
baba eb ba			dw .RND8            
babc 06				db 5 + 1 
babd .. 00			db "RND16",0              
bac3				endm 
# End of macro CWHEAD
bac3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
bac3					if DEBUG_FORTH_WORDS_KEY 
bac3						DMARK "R16" 
bac3 f5				push af  
bac4 3a d8 ba			ld a, (.dmark)  
bac7 32 5e ee			ld (debug_mark),a  
baca 3a d9 ba			ld a, (.dmark+1)  
bacd 32 5f ee			ld (debug_mark+1),a  
bad0 3a da ba			ld a, (.dmark+2)  
bad3 32 60 ee			ld (debug_mark+2),a  
bad6 18 03			jr .pastdmark  
bad8 ..			.dmark: db "R16"  
badb f1			.pastdmark: pop af  
badc			endm  
# End of macro DMARK
badc						CALLMONITOR 
badc cd 6b ee			call debug_vector  
badf				endm  
# End of macro CALLMONITOR
badf					endif 
badf cd 02 8c				call prng16  
bae2 cd cc 99				call forth_push_numhl 
bae5				       NEXTW 
bae5 cd 68 ee			call parse_vector 
bae8 c3 af 9d			jp macro_next 
baeb				endm 
# End of macro NEXTW
baeb			.RND8: 
baeb				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
baeb 60				db WORD_SYS_CORE+76             
baec 23 bb			dw .RND            
baee 05				db 4 + 1 
baef .. 00			db "RND8",0              
baf4				endm 
# End of macro CWHEAD
baf4			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
baf4					if DEBUG_FORTH_WORDS_KEY 
baf4						DMARK "RN8" 
baf4 f5				push af  
baf5 3a 09 bb			ld a, (.dmark)  
baf8 32 5e ee			ld (debug_mark),a  
bafb 3a 0a bb			ld a, (.dmark+1)  
bafe 32 5f ee			ld (debug_mark+1),a  
bb01 3a 0b bb			ld a, (.dmark+2)  
bb04 32 60 ee			ld (debug_mark+2),a  
bb07 18 03			jr .pastdmark  
bb09 ..			.dmark: db "RN8"  
bb0c f1			.pastdmark: pop af  
bb0d			endm  
# End of macro DMARK
bb0d						CALLMONITOR 
bb0d cd 6b ee			call debug_vector  
bb10				endm  
# End of macro CALLMONITOR
bb10					endif 
bb10 2a 9c eb				ld hl,(xrandc) 
bb13 23					inc hl 
bb14 cd 1c 8c				call xrnd 
bb17 6f					ld l,a	 
bb18 26 00				ld h,0 
bb1a cd cc 99				call forth_push_numhl 
bb1d				       NEXTW 
bb1d cd 68 ee			call parse_vector 
bb20 c3 af 9d			jp macro_next 
bb23				endm 
# End of macro NEXTW
bb23			.RND: 
bb23				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
bb23 60				db WORD_SYS_CORE+76             
bb24 2c bc			dw .ENDMATHS            
bb26 04				db 3 + 1 
bb27 .. 00			db "RND",0              
bb2b				endm 
# End of macro CWHEAD
bb2b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
bb2b			 
bb2b					if DEBUG_FORTH_WORDS_KEY 
bb2b						DMARK "RND" 
bb2b f5				push af  
bb2c 3a 40 bb			ld a, (.dmark)  
bb2f 32 5e ee			ld (debug_mark),a  
bb32 3a 41 bb			ld a, (.dmark+1)  
bb35 32 5f ee			ld (debug_mark+1),a  
bb38 3a 42 bb			ld a, (.dmark+2)  
bb3b 32 60 ee			ld (debug_mark+2),a  
bb3e 18 03			jr .pastdmark  
bb40 ..			.dmark: db "RND"  
bb43 f1			.pastdmark: pop af  
bb44			endm  
# End of macro DMARK
bb44						CALLMONITOR 
bb44 cd 6b ee			call debug_vector  
bb47				endm  
# End of macro CALLMONITOR
bb47					endif 
bb47					 
bb47					FORTH_DSP_VALUEHL    ; upper range 
bb47 cd c8 9b			call macro_dsp_valuehl 
bb4a				endm 
# End of macro FORTH_DSP_VALUEHL
bb4a			 
bb4a 22 a0 eb				ld (LFSRSeed), hl	 
bb4d			 
bb4d					if DEBUG_FORTH_WORDS 
bb4d						DMARK "RN1" 
bb4d f5				push af  
bb4e 3a 62 bb			ld a, (.dmark)  
bb51 32 5e ee			ld (debug_mark),a  
bb54 3a 63 bb			ld a, (.dmark+1)  
bb57 32 5f ee			ld (debug_mark+1),a  
bb5a 3a 64 bb			ld a, (.dmark+2)  
bb5d 32 60 ee			ld (debug_mark+2),a  
bb60 18 03			jr .pastdmark  
bb62 ..			.dmark: db "RN1"  
bb65 f1			.pastdmark: pop af  
bb66			endm  
# End of macro DMARK
bb66						CALLMONITOR 
bb66 cd 6b ee			call debug_vector  
bb69				endm  
# End of macro CALLMONITOR
bb69					endif 
bb69					FORTH_DSP_POP 
bb69 cd 80 9c			call macro_forth_dsp_pop 
bb6c				endm 
# End of macro FORTH_DSP_POP
bb6c			 
bb6c					FORTH_DSP_VALUEHL    ; low range 
bb6c cd c8 9b			call macro_dsp_valuehl 
bb6f				endm 
# End of macro FORTH_DSP_VALUEHL
bb6f			 
bb6f					if DEBUG_FORTH_WORDS 
bb6f						DMARK "RN2" 
bb6f f5				push af  
bb70 3a 84 bb			ld a, (.dmark)  
bb73 32 5e ee			ld (debug_mark),a  
bb76 3a 85 bb			ld a, (.dmark+1)  
bb79 32 5f ee			ld (debug_mark+1),a  
bb7c 3a 86 bb			ld a, (.dmark+2)  
bb7f 32 60 ee			ld (debug_mark+2),a  
bb82 18 03			jr .pastdmark  
bb84 ..			.dmark: db "RN2"  
bb87 f1			.pastdmark: pop af  
bb88			endm  
# End of macro DMARK
bb88						CALLMONITOR 
bb88 cd 6b ee			call debug_vector  
bb8b				endm  
# End of macro CALLMONITOR
bb8b					endif 
bb8b 22 a2 eb				ld (LFSRSeed+2), hl 
bb8e			 
bb8e					FORTH_DSP_POP 
bb8e cd 80 9c			call macro_forth_dsp_pop 
bb91				endm 
# End of macro FORTH_DSP_POP
bb91			 
bb91 e5					push hl 
bb92			 
bb92 e1			.inrange:	pop hl 
bb93 cd 02 8c				call prng16  
bb96					if DEBUG_FORTH_WORDS 
bb96						DMARK "RN3" 
bb96 f5				push af  
bb97 3a ab bb			ld a, (.dmark)  
bb9a 32 5e ee			ld (debug_mark),a  
bb9d 3a ac bb			ld a, (.dmark+1)  
bba0 32 5f ee			ld (debug_mark+1),a  
bba3 3a ad bb			ld a, (.dmark+2)  
bba6 32 60 ee			ld (debug_mark+2),a  
bba9 18 03			jr .pastdmark  
bbab ..			.dmark: db "RN3"  
bbae f1			.pastdmark: pop af  
bbaf			endm  
# End of macro DMARK
bbaf						CALLMONITOR 
bbaf cd 6b ee			call debug_vector  
bbb2				endm  
# End of macro CALLMONITOR
bbb2					endif 
bbb2					 
bbb2					; if the range is 8bit knock out the high byte 
bbb2			 
bbb2 ed 5b a0 eb			ld de, (LFSRSeed)     ; check high level 
bbb6			 
bbb6 3e 00				ld a, 0 
bbb8 ba					cp d  
bbb9 20 1e				jr nz, .hirange 
bbbb 26 00				ld h, 0   ; knock it down to 8bit 
bbbd			 
bbbd					if DEBUG_FORTH_WORDS 
bbbd						DMARK "RNk" 
bbbd f5				push af  
bbbe 3a d2 bb			ld a, (.dmark)  
bbc1 32 5e ee			ld (debug_mark),a  
bbc4 3a d3 bb			ld a, (.dmark+1)  
bbc7 32 5f ee			ld (debug_mark+1),a  
bbca 3a d4 bb			ld a, (.dmark+2)  
bbcd 32 60 ee			ld (debug_mark+2),a  
bbd0 18 03			jr .pastdmark  
bbd2 ..			.dmark: db "RNk"  
bbd5 f1			.pastdmark: pop af  
bbd6			endm  
# End of macro DMARK
bbd6						CALLMONITOR 
bbd6 cd 6b ee			call debug_vector  
bbd9				endm  
# End of macro CALLMONITOR
bbd9					endif 
bbd9			.hirange:   
bbd9 e5					push hl  
bbda b7					or a  
bbdb ed 52		                sbc hl, de 
bbdd			 
bbdd					;call cmp16 
bbdd			 
bbdd 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
bbdf e1					pop hl 
bbe0 e5					push hl 
bbe1			 
bbe1					if DEBUG_FORTH_WORDS 
bbe1						DMARK "RN4" 
bbe1 f5				push af  
bbe2 3a f6 bb			ld a, (.dmark)  
bbe5 32 5e ee			ld (debug_mark),a  
bbe8 3a f7 bb			ld a, (.dmark+1)  
bbeb 32 5f ee			ld (debug_mark+1),a  
bbee 3a f8 bb			ld a, (.dmark+2)  
bbf1 32 60 ee			ld (debug_mark+2),a  
bbf4 18 03			jr .pastdmark  
bbf6 ..			.dmark: db "RN4"  
bbf9 f1			.pastdmark: pop af  
bbfa			endm  
# End of macro DMARK
bbfa						CALLMONITOR 
bbfa cd 6b ee			call debug_vector  
bbfd				endm  
# End of macro CALLMONITOR
bbfd					endif 
bbfd ed 5b a2 eb			ld de, (LFSRSeed+2)   ; check low range 
bc01					;call cmp16 
bc01				 
bc01 b7					or a  
bc02 ed 52		                sbc hl, de 
bc04 38 8c				jr c, .inrange 
bc06			 
bc06 e1					pop hl 
bc07					 
bc07					if DEBUG_FORTH_WORDS 
bc07						DMARK "RNd" 
bc07 f5				push af  
bc08 3a 1c bc			ld a, (.dmark)  
bc0b 32 5e ee			ld (debug_mark),a  
bc0e 3a 1d bc			ld a, (.dmark+1)  
bc11 32 5f ee			ld (debug_mark+1),a  
bc14 3a 1e bc			ld a, (.dmark+2)  
bc17 32 60 ee			ld (debug_mark+2),a  
bc1a 18 03			jr .pastdmark  
bc1c ..			.dmark: db "RNd"  
bc1f f1			.pastdmark: pop af  
bc20			endm  
# End of macro DMARK
bc20						CALLMONITOR 
bc20 cd 6b ee			call debug_vector  
bc23				endm  
# End of macro CALLMONITOR
bc23					endif 
bc23			 
bc23			 
bc23 cd cc 99				call forth_push_numhl 
bc26				       NEXTW 
bc26 cd 68 ee			call parse_vector 
bc29 c3 af 9d			jp macro_next 
bc2c				endm 
# End of macro NEXTW
bc2c			 
bc2c			.ENDMATHS: 
bc2c			 
bc2c			; eof 
bc2c			 
# End of file forth_words_maths.asm
bc2c			include "forth_words_display.asm" 
bc2c			 
bc2c			; | ## Display Words 
bc2c			 
bc2c			.ACT: 
bc2c			 
bc2c				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
bc2c 62				db WORD_SYS_CORE+78             
bc2d 7b bc			dw .INFO            
bc2f 07				db 6 + 1 
bc30 .. 00			db "ACTIVE",0              
bc37				endm 
# End of macro CWHEAD
bc37			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bc37			;  
bc37			; | | To display a pulsing activity indicator in a processing loop do this... 
bc37			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bc37			 
bc37					if DEBUG_FORTH_WORDS_KEY 
bc37						DMARK "ACT" 
bc37 f5				push af  
bc38 3a 4c bc			ld a, (.dmark)  
bc3b 32 5e ee			ld (debug_mark),a  
bc3e 3a 4d bc			ld a, (.dmark+1)  
bc41 32 5f ee			ld (debug_mark+1),a  
bc44 3a 4e bc			ld a, (.dmark+2)  
bc47 32 60 ee			ld (debug_mark+2),a  
bc4a 18 03			jr .pastdmark  
bc4c ..			.dmark: db "ACT"  
bc4f f1			.pastdmark: pop af  
bc50			endm  
# End of macro DMARK
bc50						CALLMONITOR 
bc50 cd 6b ee			call debug_vector  
bc53				endm  
# End of macro CALLMONITOR
bc53					endif 
bc53 cd 09 8a				call active 
bc56					if DEBUG_FORTH_WORDS 
bc56						DMARK "ACp" 
bc56 f5				push af  
bc57 3a 6b bc			ld a, (.dmark)  
bc5a 32 5e ee			ld (debug_mark),a  
bc5d 3a 6c bc			ld a, (.dmark+1)  
bc60 32 5f ee			ld (debug_mark+1),a  
bc63 3a 6d bc			ld a, (.dmark+2)  
bc66 32 60 ee			ld (debug_mark+2),a  
bc69 18 03			jr .pastdmark  
bc6b ..			.dmark: db "ACp"  
bc6e f1			.pastdmark: pop af  
bc6f			endm  
# End of macro DMARK
bc6f						CALLMONITOR 
bc6f cd 6b ee			call debug_vector  
bc72				endm  
# End of macro CALLMONITOR
bc72					endif 
bc72 cd 36 9a				call forth_push_str 
bc75			 
bc75					NEXTW 
bc75 cd 68 ee			call parse_vector 
bc78 c3 af 9d			jp macro_next 
bc7b				endm 
# End of macro NEXTW
bc7b			.INFO: 
bc7b			 
bc7b				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bc7b 62				db WORD_SYS_CORE+78             
bc7c 9b bc			dw .ATP            
bc7e 05				db 4 + 1 
bc7f .. 00			db "INFO",0              
bc84				endm 
# End of macro CWHEAD
bc84			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bc84					FORTH_DSP_VALUEHL 
bc84 cd c8 9b			call macro_dsp_valuehl 
bc87				endm 
# End of macro FORTH_DSP_VALUEHL
bc87			 
bc87					FORTH_DSP_POP 
bc87 cd 80 9c			call macro_forth_dsp_pop 
bc8a				endm 
# End of macro FORTH_DSP_POP
bc8a			 
bc8a e5					push hl 
bc8b			 
bc8b					FORTH_DSP_VALUEHL 
bc8b cd c8 9b			call macro_dsp_valuehl 
bc8e				endm 
# End of macro FORTH_DSP_VALUEHL
bc8e			 
bc8e					FORTH_DSP_POP 
bc8e cd 80 9c			call macro_forth_dsp_pop 
bc91				endm 
# End of macro FORTH_DSP_POP
bc91			 
bc91 d1					pop de 
bc92			 
bc92 cd 43 8a				call info_panel 
bc95			 
bc95			 
bc95					NEXTW 
bc95 cd 68 ee			call parse_vector 
bc98 c3 af 9d			jp macro_next 
bc9b				endm 
# End of macro NEXTW
bc9b			.ATP: 
bc9b				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bc9b 62				db WORD_SYS_CORE+78             
bc9c 15 bd			dw .FB            
bc9e 04				db 3 + 1 
bc9f .. 00			db "AT?",0              
bca3				endm 
# End of macro CWHEAD
bca3			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bca3					if DEBUG_FORTH_WORDS_KEY 
bca3						DMARK "AT?" 
bca3 f5				push af  
bca4 3a b8 bc			ld a, (.dmark)  
bca7 32 5e ee			ld (debug_mark),a  
bcaa 3a b9 bc			ld a, (.dmark+1)  
bcad 32 5f ee			ld (debug_mark+1),a  
bcb0 3a ba bc			ld a, (.dmark+2)  
bcb3 32 60 ee			ld (debug_mark+2),a  
bcb6 18 03			jr .pastdmark  
bcb8 ..			.dmark: db "AT?"  
bcbb f1			.pastdmark: pop af  
bcbc			endm  
# End of macro DMARK
bcbc						CALLMONITOR 
bcbc cd 6b ee			call debug_vector  
bcbf				endm  
# End of macro CALLMONITOR
bcbf					endif 
bcbf 3a 51 ea				ld a, (f_cursor_ptr) 
bcc2			 
bcc2			if DEBUG_FORTH_WORDS 
bcc2				DMARK "AT?" 
bcc2 f5				push af  
bcc3 3a d7 bc			ld a, (.dmark)  
bcc6 32 5e ee			ld (debug_mark),a  
bcc9 3a d8 bc			ld a, (.dmark+1)  
bccc 32 5f ee			ld (debug_mark+1),a  
bccf 3a d9 bc			ld a, (.dmark+2)  
bcd2 32 60 ee			ld (debug_mark+2),a  
bcd5 18 03			jr .pastdmark  
bcd7 ..			.dmark: db "AT?"  
bcda f1			.pastdmark: pop af  
bcdb			endm  
# End of macro DMARK
bcdb				CALLMONITOR 
bcdb cd 6b ee			call debug_vector  
bcde				endm  
# End of macro CALLMONITOR
bcde			endif	 
bcde					; count the number of rows 
bcde			 
bcde 06 00				ld b, 0 
bce0 4f			.atpr:		ld c, a    ; save in case we go below zero 
bce1 d6 28				sub display_cols 
bce3 f2 e9 bc				jp p, .atprunder 
bce6 04					inc b 
bce7 18 f7				jr .atpr 
bce9			.atprunder:	 
bce9			if DEBUG_FORTH_WORDS 
bce9				DMARK "A?2" 
bce9 f5				push af  
bcea 3a fe bc			ld a, (.dmark)  
bced 32 5e ee			ld (debug_mark),a  
bcf0 3a ff bc			ld a, (.dmark+1)  
bcf3 32 5f ee			ld (debug_mark+1),a  
bcf6 3a 00 bd			ld a, (.dmark+2)  
bcf9 32 60 ee			ld (debug_mark+2),a  
bcfc 18 03			jr .pastdmark  
bcfe ..			.dmark: db "A?2"  
bd01 f1			.pastdmark: pop af  
bd02			endm  
# End of macro DMARK
bd02				CALLMONITOR 
bd02 cd 6b ee			call debug_vector  
bd05				endm  
# End of macro CALLMONITOR
bd05			endif	 
bd05 26 00				ld h, 0 
bd07 69					ld l, c 
bd08 cd cc 99				call forth_push_numhl 
bd0b 68					ld l, b  
bd0c cd cc 99				call forth_push_numhl 
bd0f			 
bd0f			 
bd0f				NEXTW 
bd0f cd 68 ee			call parse_vector 
bd12 c3 af 9d			jp macro_next 
bd15				endm 
# End of macro NEXTW
bd15			 
bd15			.FB: 
bd15				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bd15 1b				db WORD_SYS_CORE+7             
bd16 66 bd			dw .EMIT            
bd18 03				db 2 + 1 
bd19 .. 00			db "FB",0              
bd1c				endm 
# End of macro CWHEAD
bd1c			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bd1c			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bd1c			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bd1c			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bd1c					if DEBUG_FORTH_WORDS_KEY 
bd1c						DMARK "FB." 
bd1c f5				push af  
bd1d 3a 31 bd			ld a, (.dmark)  
bd20 32 5e ee			ld (debug_mark),a  
bd23 3a 32 bd			ld a, (.dmark+1)  
bd26 32 5f ee			ld (debug_mark+1),a  
bd29 3a 33 bd			ld a, (.dmark+2)  
bd2c 32 60 ee			ld (debug_mark+2),a  
bd2f 18 03			jr .pastdmark  
bd31 ..			.dmark: db "FB."  
bd34 f1			.pastdmark: pop af  
bd35			endm  
# End of macro DMARK
bd35						CALLMONITOR 
bd35 cd 6b ee			call debug_vector  
bd38				endm  
# End of macro CALLMONITOR
bd38					endif 
bd38			 
bd38					FORTH_DSP_VALUEHL 
bd38 cd c8 9b			call macro_dsp_valuehl 
bd3b				endm 
# End of macro FORTH_DSP_VALUEHL
bd3b			 
bd3b 7d					ld a, l 
bd3c fe 01				cp 1 
bd3e 20 05				jr nz, .fbn1 
bd40 21 03 ed				ld hl, display_fb1 
bd43 18 15				jr .fbset 
bd45 fe 02		.fbn1:		cp 2 
bd47 20 05				jr nz, .fbn2 
bd49 21 c1 eb				ld hl, display_fb2 
bd4c 18 0c				jr .fbset 
bd4e fe 03		.fbn2:		cp 3 
bd50 20 05				jr nz, .fbn3 
bd52 21 62 ec				ld hl, display_fb3 
bd55 18 03				jr .fbset 
bd57			.fbn3:		 ; if invalid number select first 
bd57 21 03 ed				ld hl, display_fb1 
bd5a 22 bf eb		.fbset:		ld (display_fb_active), hl 
bd5d			 
bd5d					FORTH_DSP_POP 
bd5d cd 80 9c			call macro_forth_dsp_pop 
bd60				endm 
# End of macro FORTH_DSP_POP
bd60			 
bd60					NEXTW 
bd60 cd 68 ee			call parse_vector 
bd63 c3 af 9d			jp macro_next 
bd66				endm 
# End of macro NEXTW
bd66			 
bd66			 
bd66			.EMIT: 
bd66				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bd66 1b				db WORD_SYS_CORE+7             
bd67 b9 bd			dw .DOTH            
bd69 05				db 4 + 1 
bd6a .. 00			db "EMIT",0              
bd6f				endm 
# End of macro CWHEAD
bd6f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bd6f					; get value off TOS and display it 
bd6f			 
bd6f					if DEBUG_FORTH_WORDS_KEY 
bd6f						DMARK "EMT" 
bd6f f5				push af  
bd70 3a 84 bd			ld a, (.dmark)  
bd73 32 5e ee			ld (debug_mark),a  
bd76 3a 85 bd			ld a, (.dmark+1)  
bd79 32 5f ee			ld (debug_mark+1),a  
bd7c 3a 86 bd			ld a, (.dmark+2)  
bd7f 32 60 ee			ld (debug_mark+2),a  
bd82 18 03			jr .pastdmark  
bd84 ..			.dmark: db "EMT"  
bd87 f1			.pastdmark: pop af  
bd88			endm  
# End of macro DMARK
bd88						CALLMONITOR 
bd88 cd 6b ee			call debug_vector  
bd8b				endm  
# End of macro CALLMONITOR
bd8b					endif 
bd8b			 
bd8b					FORTH_DSP_VALUEHL 
bd8b cd c8 9b			call macro_dsp_valuehl 
bd8e				endm 
# End of macro FORTH_DSP_VALUEHL
bd8e			 
bd8e 7d					ld a,l 
bd8f			 
bd8f					; TODO write to display 
bd8f			 
bd8f 32 b2 e4				ld (os_input), a 
bd92 3e 00				ld a, 0 
bd94 32 b3 e4				ld (os_input+1), a 
bd97					 
bd97 3a 51 ea				ld a, (f_cursor_ptr) 
bd9a 11 b2 e4				ld de, os_input 
bd9d cd c3 8a				call str_at_display 
bda0			 
bda0			 
bda0 3a 2f ea				ld a,(cli_autodisplay) 
bda3			;		cp 0 
bda3 b7					or a 
bda4 28 03				jr z, .enoupdate 
bda6 cd d3 8a						call update_display 
bda9					.enoupdate: 
bda9			 
bda9 3a 51 ea				ld a, (f_cursor_ptr) 
bdac 3c					inc a 
bdad 32 51 ea				ld (f_cursor_ptr), a   ; save new pos 
bdb0			 
bdb0			 
bdb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdb0 cd 80 9c			call macro_forth_dsp_pop 
bdb3				endm 
# End of macro FORTH_DSP_POP
bdb3			  
bdb3			 
bdb3					NEXTW 
bdb3 cd 68 ee			call parse_vector 
bdb6 c3 af 9d			jp macro_next 
bdb9				endm 
# End of macro NEXTW
bdb9			.DOTH: 
bdb9				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bdb9 1c				db WORD_SYS_CORE+8             
bdba ec bd			dw .DOTF            
bdbc 03				db 2 + 1 
bdbd .. 00			db ".-",0              
bdc0				endm 
# End of macro CWHEAD
bdc0			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bdc0					; get value off TOS and display it 
bdc0					if DEBUG_FORTH_WORDS_KEY 
bdc0						DMARK "DTD" 
bdc0 f5				push af  
bdc1 3a d5 bd			ld a, (.dmark)  
bdc4 32 5e ee			ld (debug_mark),a  
bdc7 3a d6 bd			ld a, (.dmark+1)  
bdca 32 5f ee			ld (debug_mark+1),a  
bdcd 3a d7 bd			ld a, (.dmark+2)  
bdd0 32 60 ee			ld (debug_mark+2),a  
bdd3 18 03			jr .pastdmark  
bdd5 ..			.dmark: db "DTD"  
bdd8 f1			.pastdmark: pop af  
bdd9			endm  
# End of macro DMARK
bdd9						CALLMONITOR 
bdd9 cd 6b ee			call debug_vector  
bddc				endm  
# End of macro CALLMONITOR
bddc					endif 
bddc 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bdde 3e 00			ld a, 0 
bde0 32 30 ea			ld (cli_mvdot), a 
bde3 c3 46 be			jp .dotgo 
bde6				NEXTW 
bde6 cd 68 ee			call parse_vector 
bde9 c3 af 9d			jp macro_next 
bdec				endm 
# End of macro NEXTW
bdec			.DOTF: 
bdec				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bdec 1c				db WORD_SYS_CORE+8             
bded 1d be			dw .DOT            
bdef 03				db 2 + 1 
bdf0 .. 00			db ".>",0              
bdf3				endm 
# End of macro CWHEAD
bdf3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bdf3					; get value off TOS and display it 
bdf3			        ; TODO BUG adds extra spaces 
bdf3			        ; TODO BUG handle numerics? 
bdf3					if DEBUG_FORTH_WORDS_KEY 
bdf3						DMARK "DTC" 
bdf3 f5				push af  
bdf4 3a 08 be			ld a, (.dmark)  
bdf7 32 5e ee			ld (debug_mark),a  
bdfa 3a 09 be			ld a, (.dmark+1)  
bdfd 32 5f ee			ld (debug_mark+1),a  
be00 3a 0a be			ld a, (.dmark+2)  
be03 32 60 ee			ld (debug_mark+2),a  
be06 18 03			jr .pastdmark  
be08 ..			.dmark: db "DTC"  
be0b f1			.pastdmark: pop af  
be0c			endm  
# End of macro DMARK
be0c						CALLMONITOR 
be0c cd 6b ee			call debug_vector  
be0f				endm  
# End of macro CALLMONITOR
be0f					endif 
be0f 3e 01			ld a, 1 
be11 32 30 ea			ld (cli_mvdot), a 
be14 c3 46 be			jp .dotgo 
be17				NEXTW 
be17 cd 68 ee			call parse_vector 
be1a c3 af 9d			jp macro_next 
be1d				endm 
# End of macro NEXTW
be1d			 
be1d			.DOT: 
be1d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
be1d 1c				db WORD_SYS_CORE+8             
be1e f8 bf			dw .CLS            
be20 02				db 1 + 1 
be21 .. 00			db ".",0              
be23				endm 
# End of macro CWHEAD
be23			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
be23					; get value off TOS and display it 
be23			 
be23					if DEBUG_FORTH_WORDS_KEY 
be23						DMARK "DOT" 
be23 f5				push af  
be24 3a 38 be			ld a, (.dmark)  
be27 32 5e ee			ld (debug_mark),a  
be2a 3a 39 be			ld a, (.dmark+1)  
be2d 32 5f ee			ld (debug_mark+1),a  
be30 3a 3a be			ld a, (.dmark+2)  
be33 32 60 ee			ld (debug_mark+2),a  
be36 18 03			jr .pastdmark  
be38 ..			.dmark: db "DOT"  
be3b f1			.pastdmark: pop af  
be3c			endm  
# End of macro DMARK
be3c						CALLMONITOR 
be3c cd 6b ee			call debug_vector  
be3f				endm  
# End of macro CALLMONITOR
be3f					endif 
be3f 3e 00			ld a, 0 
be41 32 30 ea			ld (cli_mvdot), a 
be44 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
be46				 
be46			 
be46			.dotgo: 
be46			 
be46			; move up type to on stack for parserv5 
be46					FORTH_DSP 
be46 cd 8e 9b			call macro_forth_dsp 
be49				endm 
# End of macro FORTH_DSP
be49				;FORTH_DSP_VALUE  
be49			 
be49			if DEBUG_FORTH_DOT 
be49				DMARK "DOT" 
be49 f5				push af  
be4a 3a 5e be			ld a, (.dmark)  
be4d 32 5e ee			ld (debug_mark),a  
be50 3a 5f be			ld a, (.dmark+1)  
be53 32 5f ee			ld (debug_mark+1),a  
be56 3a 60 be			ld a, (.dmark+2)  
be59 32 60 ee			ld (debug_mark+2),a  
be5c 18 03			jr .pastdmark  
be5e ..			.dmark: db "DOT"  
be61 f1			.pastdmark: pop af  
be62			endm  
# End of macro DMARK
be62				CALLMONITOR 
be62 cd 6b ee			call debug_vector  
be65				endm  
# End of macro CALLMONITOR
be65			endif	 
be65			;		.print: 
be65			 
be65 7e				ld a,(hl)  ; work out what type of value is on the TOS 
be66 23				inc hl   ; position to the actual value 
be67 fe 01			cp DS_TYPE_STR 
be69 20 06			jr nz, .dotnum1  
be6b			 
be6b			; display string 
be6b				FORTH_DSP_VALUE  
be6b cd b1 9b			call macro_forth_dsp_value 
be6e				endm 
# End of macro FORTH_DSP_VALUE
be6e eb				ex de,hl 
be6f 18 49			jr .dotwrite 
be71			 
be71			.dotnum1: 
be71 fe 02			cp DS_TYPE_INUM 
be73 20 44			jr nz, .dotflot 
be75			 
be75			 
be75			; display number 
be75			 
be75			;	push hl 
be75			;	call clear_display 
be75			;	pop hl 
be75			 
be75 5e				ld e, (hl) 
be76 23				inc hl 
be77 56				ld d, (hl) 
be78 21 b4 e2			ld hl, scratch 
be7b			if DEBUG_FORTH_DOT 
be7b				DMARK "DT1" 
be7b f5				push af  
be7c 3a 90 be			ld a, (.dmark)  
be7f 32 5e ee			ld (debug_mark),a  
be82 3a 91 be			ld a, (.dmark+1)  
be85 32 5f ee			ld (debug_mark+1),a  
be88 3a 92 be			ld a, (.dmark+2)  
be8b 32 60 ee			ld (debug_mark+2),a  
be8e 18 03			jr .pastdmark  
be90 ..			.dmark: db "DT1"  
be93 f1			.pastdmark: pop af  
be94			endm  
# End of macro DMARK
be94				CALLMONITOR 
be94 cd 6b ee			call debug_vector  
be97				endm  
# End of macro CALLMONITOR
be97			endif	 
be97			 
be97 cd e2 8f			call uitoa_16 
be9a eb				ex de,hl 
be9b			 
be9b			if DEBUG_FORTH_DOT 
be9b				DMARK "DT2" 
be9b f5				push af  
be9c 3a b0 be			ld a, (.dmark)  
be9f 32 5e ee			ld (debug_mark),a  
bea2 3a b1 be			ld a, (.dmark+1)  
bea5 32 5f ee			ld (debug_mark+1),a  
bea8 3a b2 be			ld a, (.dmark+2)  
beab 32 60 ee			ld (debug_mark+2),a  
beae 18 03			jr .pastdmark  
beb0 ..			.dmark: db "DT2"  
beb3 f1			.pastdmark: pop af  
beb4			endm  
# End of macro DMARK
beb4				CALLMONITOR 
beb4 cd 6b ee			call debug_vector  
beb7				endm  
# End of macro CALLMONITOR
beb7			endif	 
beb7			 
beb7			;	ld de, os_word_scratch 
beb7 18 01			jr .dotwrite 
beb9			 
beb9 00			.dotflot:   nop 
beba			; TODO print floating point number 
beba			 
beba			.dotwrite:		 
beba			 
beba					; if c is set then set all '-' to spaces 
beba					; need to also take into account .>  
beba			 
beba 3e 01				ld a, 1 
bebc b9					cp c 
bebd 20 65				jr nz, .nodashswap 
bebf			 
bebf					; DE has the string to write, working with HL 
bebf			 
bebf 06 ff				ld b, 255 
bec1 d5					push de 
bec2 e1					pop hl 
bec3			 
bec3			if DEBUG_FORTH_DOT 
bec3				DMARK "DT-" 
bec3 f5				push af  
bec4 3a d8 be			ld a, (.dmark)  
bec7 32 5e ee			ld (debug_mark),a  
beca 3a d9 be			ld a, (.dmark+1)  
becd 32 5f ee			ld (debug_mark+1),a  
bed0 3a da be			ld a, (.dmark+2)  
bed3 32 60 ee			ld (debug_mark+2),a  
bed6 18 03			jr .pastdmark  
bed8 ..			.dmark: db "DT-"  
bedb f1			.pastdmark: pop af  
bedc			endm  
# End of macro DMARK
bedc				CALLMONITOR 
bedc cd 6b ee			call debug_vector  
bedf				endm  
# End of macro CALLMONITOR
bedf			endif	 
bedf 7e			.dashscan:	ld a, (hl) 
bee0			;		cp 0 
bee0 b7					or a 
bee1 28 41				jr z, .nodashswap 
bee3 fe 2d				cp '-' 
bee5 20 02				jr nz, .dashskip 
bee7			;		ld a, ' ' 
bee7 36 20				ld (hl), ' ' 
bee9 23			.dashskip:	inc hl 
beea			if DEBUG_FORTH_DOT 
beea				DMARK "D-2" 
beea f5				push af  
beeb 3a ff be			ld a, (.dmark)  
beee 32 5e ee			ld (debug_mark),a  
bef1 3a 00 bf			ld a, (.dmark+1)  
bef4 32 5f ee			ld (debug_mark+1),a  
bef7 3a 01 bf			ld a, (.dmark+2)  
befa 32 60 ee			ld (debug_mark+2),a  
befd 18 03			jr .pastdmark  
beff ..			.dmark: db "D-2"  
bf02 f1			.pastdmark: pop af  
bf03			endm  
# End of macro DMARK
bf03				CALLMONITOR 
bf03 cd 6b ee			call debug_vector  
bf06				endm  
# End of macro CALLMONITOR
bf06			endif	 
bf06 10 d7				djnz .dashscan 
bf08			 
bf08			if DEBUG_FORTH_DOT 
bf08				DMARK "D-1" 
bf08 f5				push af  
bf09 3a 1d bf			ld a, (.dmark)  
bf0c 32 5e ee			ld (debug_mark),a  
bf0f 3a 1e bf			ld a, (.dmark+1)  
bf12 32 5f ee			ld (debug_mark+1),a  
bf15 3a 1f bf			ld a, (.dmark+2)  
bf18 32 60 ee			ld (debug_mark+2),a  
bf1b 18 03			jr .pastdmark  
bf1d ..			.dmark: db "D-1"  
bf20 f1			.pastdmark: pop af  
bf21			endm  
# End of macro DMARK
bf21				CALLMONITOR 
bf21 cd 6b ee			call debug_vector  
bf24				endm  
# End of macro CALLMONITOR
bf24			endif	 
bf24			 
bf24			.nodashswap: 
bf24			 
bf24			if DEBUG_FORTH_DOT 
bf24				DMARK "D-o" 
bf24 f5				push af  
bf25 3a 39 bf			ld a, (.dmark)  
bf28 32 5e ee			ld (debug_mark),a  
bf2b 3a 3a bf			ld a, (.dmark+1)  
bf2e 32 5f ee			ld (debug_mark+1),a  
bf31 3a 3b bf			ld a, (.dmark+2)  
bf34 32 60 ee			ld (debug_mark+2),a  
bf37 18 03			jr .pastdmark  
bf39 ..			.dmark: db "D-o"  
bf3c f1			.pastdmark: pop af  
bf3d			endm  
# End of macro DMARK
bf3d				CALLMONITOR 
bf3d cd 6b ee			call debug_vector  
bf40				endm  
# End of macro CALLMONITOR
bf40			endif	 
bf40			 
bf40 d5					push de   ; save string start in case we need to advance print 
bf41			 
bf41 3a 51 ea				ld a, (f_cursor_ptr) 
bf44 cd c3 8a				call str_at_display 
bf47 3a 2f ea				ld a,(cli_autodisplay) 
bf4a			;		cp 0 
bf4a b7					or a 
bf4b 28 03				jr z, .noupdate 
bf4d cd d3 8a						call update_display 
bf50					.noupdate: 
bf50			 
bf50			 
bf50					; see if we need to advance the print position 
bf50			 
bf50 e1					pop hl   ; get back string 
bf51			;		ex de,hl 
bf51			 
bf51 3a 30 ea				ld a, (cli_mvdot) 
bf54			if DEBUG_FORTH_DOT 
bf54			;		ld e,a 
bf54				DMARK "D>1" 
bf54 f5				push af  
bf55 3a 69 bf			ld a, (.dmark)  
bf58 32 5e ee			ld (debug_mark),a  
bf5b 3a 6a bf			ld a, (.dmark+1)  
bf5e 32 5f ee			ld (debug_mark+1),a  
bf61 3a 6b bf			ld a, (.dmark+2)  
bf64 32 60 ee			ld (debug_mark+2),a  
bf67 18 03			jr .pastdmark  
bf69 ..			.dmark: db "D>1"  
bf6c f1			.pastdmark: pop af  
bf6d			endm  
# End of macro DMARK
bf6d				CALLMONITOR 
bf6d cd 6b ee			call debug_vector  
bf70				endm  
# End of macro CALLMONITOR
bf70			endif	 
bf70			;		cp 0 
bf70 b7					or a 
bf71 28 44				jr z, .noadv 
bf73					; yes, lets advance the print position 
bf73 3e 00				ld a, 0 
bf75 cd 3e 90				call strlent 
bf78			if DEBUG_FORTH_DOT 
bf78				DMARK "D-?" 
bf78 f5				push af  
bf79 3a 8d bf			ld a, (.dmark)  
bf7c 32 5e ee			ld (debug_mark),a  
bf7f 3a 8e bf			ld a, (.dmark+1)  
bf82 32 5f ee			ld (debug_mark+1),a  
bf85 3a 8f bf			ld a, (.dmark+2)  
bf88 32 60 ee			ld (debug_mark+2),a  
bf8b 18 03			jr .pastdmark  
bf8d ..			.dmark: db "D-?"  
bf90 f1			.pastdmark: pop af  
bf91			endm  
# End of macro DMARK
bf91				CALLMONITOR 
bf91 cd 6b ee			call debug_vector  
bf94				endm  
# End of macro CALLMONITOR
bf94			endif	 
bf94 3a 51 ea				ld a, (f_cursor_ptr) 
bf97 85					add a,l 
bf98					;call addatohl 
bf98					;ld a, l 
bf98 32 51 ea				ld (f_cursor_ptr), a   ; save new pos 
bf9b			 
bf9b			if DEBUG_FORTH_DOT 
bf9b				DMARK "D->" 
bf9b f5				push af  
bf9c 3a b0 bf			ld a, (.dmark)  
bf9f 32 5e ee			ld (debug_mark),a  
bfa2 3a b1 bf			ld a, (.dmark+1)  
bfa5 32 5f ee			ld (debug_mark+1),a  
bfa8 3a b2 bf			ld a, (.dmark+2)  
bfab 32 60 ee			ld (debug_mark+2),a  
bfae 18 03			jr .pastdmark  
bfb0 ..			.dmark: db "D->"  
bfb3 f1			.pastdmark: pop af  
bfb4			endm  
# End of macro DMARK
bfb4				CALLMONITOR 
bfb4 cd 6b ee			call debug_vector  
bfb7				endm  
# End of macro CALLMONITOR
bfb7			endif	 
bfb7			 
bfb7			.noadv:	 
bfb7			 
bfb7					if DEBUG_FORTH_DOT_WAIT 
bfb7							call next_page_prompt 
bfb7					endif	 
bfb7			; TODO this pop off the stack causes a crash. i dont know why 
bfb7			 
bfb7			 
bfb7			if DEBUG_FORTH_DOT 
bfb7				DMARK "DTh" 
bfb7 f5				push af  
bfb8 3a cc bf			ld a, (.dmark)  
bfbb 32 5e ee			ld (debug_mark),a  
bfbe 3a cd bf			ld a, (.dmark+1)  
bfc1 32 5f ee			ld (debug_mark+1),a  
bfc4 3a ce bf			ld a, (.dmark+2)  
bfc7 32 60 ee			ld (debug_mark+2),a  
bfca 18 03			jr .pastdmark  
bfcc ..			.dmark: db "DTh"  
bfcf f1			.pastdmark: pop af  
bfd0			endm  
# End of macro DMARK
bfd0				CALLMONITOR 
bfd0 cd 6b ee			call debug_vector  
bfd3				endm  
# End of macro CALLMONITOR
bfd3			endif	 
bfd3			 
bfd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfd3 cd 80 9c			call macro_forth_dsp_pop 
bfd6				endm 
# End of macro FORTH_DSP_POP
bfd6			 
bfd6			if DEBUG_FORTH_DOT 
bfd6				DMARK "DTi" 
bfd6 f5				push af  
bfd7 3a eb bf			ld a, (.dmark)  
bfda 32 5e ee			ld (debug_mark),a  
bfdd 3a ec bf			ld a, (.dmark+1)  
bfe0 32 5f ee			ld (debug_mark+1),a  
bfe3 3a ed bf			ld a, (.dmark+2)  
bfe6 32 60 ee			ld (debug_mark+2),a  
bfe9 18 03			jr .pastdmark  
bfeb ..			.dmark: db "DTi"  
bfee f1			.pastdmark: pop af  
bfef			endm  
# End of macro DMARK
bfef				CALLMONITOR 
bfef cd 6b ee			call debug_vector  
bff2				endm  
# End of macro CALLMONITOR
bff2			endif	 
bff2			 
bff2			 
bff2					NEXTW 
bff2 cd 68 ee			call parse_vector 
bff5 c3 af 9d			jp macro_next 
bff8				endm 
# End of macro NEXTW
bff8			 
bff8			.CLS: 
bff8				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bff8 35				db WORD_SYS_CORE+33             
bff9 28 c0			dw .DRAW            
bffb 04				db 3 + 1 
bffc .. 00			db "CLS",0              
c000				endm 
# End of macro CWHEAD
c000			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
c000					if DEBUG_FORTH_WORDS_KEY 
c000						DMARK "CLS" 
c000 f5				push af  
c001 3a 15 c0			ld a, (.dmark)  
c004 32 5e ee			ld (debug_mark),a  
c007 3a 16 c0			ld a, (.dmark+1)  
c00a 32 5f ee			ld (debug_mark+1),a  
c00d 3a 17 c0			ld a, (.dmark+2)  
c010 32 60 ee			ld (debug_mark+2),a  
c013 18 03			jr .pastdmark  
c015 ..			.dmark: db "CLS"  
c018 f1			.pastdmark: pop af  
c019			endm  
# End of macro DMARK
c019						CALLMONITOR 
c019 cd 6b ee			call debug_vector  
c01c				endm  
# End of macro CALLMONITOR
c01c					endif 
c01c cd b1 8a				call clear_display 
c01f c3 42 c1				jp .home		; and home cursor 
c022					NEXTW 
c022 cd 68 ee			call parse_vector 
c025 c3 af 9d			jp macro_next 
c028				endm 
# End of macro NEXTW
c028			 
c028			.DRAW: 
c028				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
c028 36				db WORD_SYS_CORE+34             
c029 56 c0			dw .DUMP            
c02b 05				db 4 + 1 
c02c .. 00			db "DRAW",0              
c031				endm 
# End of macro CWHEAD
c031			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
c031					if DEBUG_FORTH_WORDS_KEY 
c031						DMARK "DRW" 
c031 f5				push af  
c032 3a 46 c0			ld a, (.dmark)  
c035 32 5e ee			ld (debug_mark),a  
c038 3a 47 c0			ld a, (.dmark+1)  
c03b 32 5f ee			ld (debug_mark+1),a  
c03e 3a 48 c0			ld a, (.dmark+2)  
c041 32 60 ee			ld (debug_mark+2),a  
c044 18 03			jr .pastdmark  
c046 ..			.dmark: db "DRW"  
c049 f1			.pastdmark: pop af  
c04a			endm  
# End of macro DMARK
c04a						CALLMONITOR 
c04a cd 6b ee			call debug_vector  
c04d				endm  
# End of macro CALLMONITOR
c04d					endif 
c04d cd d3 8a				call update_display 
c050					NEXTW 
c050 cd 68 ee			call parse_vector 
c053 c3 af 9d			jp macro_next 
c056				endm 
# End of macro NEXTW
c056			 
c056			.DUMP: 
c056				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
c056 37				db WORD_SYS_CORE+35             
c057 91 c0			dw .CDUMP            
c059 05				db 4 + 1 
c05a .. 00			db "DUMP",0              
c05f				endm 
# End of macro CWHEAD
c05f			; | DUMP ( x -- ) With address x display dump   | DONE 
c05f			; TODO pop address to use off of the stack 
c05f					if DEBUG_FORTH_WORDS_KEY 
c05f						DMARK "DUM" 
c05f f5				push af  
c060 3a 74 c0			ld a, (.dmark)  
c063 32 5e ee			ld (debug_mark),a  
c066 3a 75 c0			ld a, (.dmark+1)  
c069 32 5f ee			ld (debug_mark+1),a  
c06c 3a 76 c0			ld a, (.dmark+2)  
c06f 32 60 ee			ld (debug_mark+2),a  
c072 18 03			jr .pastdmark  
c074 ..			.dmark: db "DUM"  
c077 f1			.pastdmark: pop af  
c078			endm  
# End of macro DMARK
c078						CALLMONITOR 
c078 cd 6b ee			call debug_vector  
c07b				endm  
# End of macro CALLMONITOR
c07b					endif 
c07b cd b1 8a				call clear_display 
c07e			 
c07e					; get address 
c07e			 
c07e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c07e cd c8 9b			call macro_dsp_valuehl 
c081				endm 
# End of macro FORTH_DSP_VALUEHL
c081				 
c081					; save it for cdump 
c081			 
c081 22 d7 e5				ld (os_cur_ptr),hl 
c084			 
c084					; destroy value TOS 
c084			 
c084					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c084 cd 80 9c			call macro_forth_dsp_pop 
c087				endm 
# End of macro FORTH_DSP_POP
c087			 
c087 cd 50 98				call dumpcont	; skip old style of param parsing	 
c08a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
c08b					NEXTW 
c08b cd 68 ee			call parse_vector 
c08e c3 af 9d			jp macro_next 
c091				endm 
# End of macro NEXTW
c091			.CDUMP: 
c091				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
c091 38				db WORD_SYS_CORE+36             
c092 c4 c0			dw .DAT            
c094 06				db 5 + 1 
c095 .. 00			db "CDUMP",0              
c09b				endm 
# End of macro CWHEAD
c09b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
c09b					if DEBUG_FORTH_WORDS_KEY 
c09b						DMARK "CDP" 
c09b f5				push af  
c09c 3a b0 c0			ld a, (.dmark)  
c09f 32 5e ee			ld (debug_mark),a  
c0a2 3a b1 c0			ld a, (.dmark+1)  
c0a5 32 5f ee			ld (debug_mark+1),a  
c0a8 3a b2 c0			ld a, (.dmark+2)  
c0ab 32 60 ee			ld (debug_mark+2),a  
c0ae 18 03			jr .pastdmark  
c0b0 ..			.dmark: db "CDP"  
c0b3 f1			.pastdmark: pop af  
c0b4			endm  
# End of macro DMARK
c0b4						CALLMONITOR 
c0b4 cd 6b ee			call debug_vector  
c0b7				endm  
# End of macro CALLMONITOR
c0b7					endif 
c0b7 cd b1 8a				call clear_display 
c0ba cd 50 98				call dumpcont	 
c0bd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
c0be					NEXTW 
c0be cd 68 ee			call parse_vector 
c0c1 c3 af 9d			jp macro_next 
c0c4				endm 
# End of macro NEXTW
c0c4			 
c0c4			 
c0c4			 
c0c4			 
c0c4			.DAT: 
c0c4				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
c0c4 3d				db WORD_SYS_CORE+41             
c0c5 1d c1			dw .HOME            
c0c7 03				db 2 + 1 
c0c8 .. 00			db "AT",0              
c0cb				endm 
# End of macro CWHEAD
c0cb			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
c0cb					if DEBUG_FORTH_WORDS_KEY 
c0cb						DMARK "AT." 
c0cb f5				push af  
c0cc 3a e0 c0			ld a, (.dmark)  
c0cf 32 5e ee			ld (debug_mark),a  
c0d2 3a e1 c0			ld a, (.dmark+1)  
c0d5 32 5f ee			ld (debug_mark+1),a  
c0d8 3a e2 c0			ld a, (.dmark+2)  
c0db 32 60 ee			ld (debug_mark+2),a  
c0de 18 03			jr .pastdmark  
c0e0 ..			.dmark: db "AT."  
c0e3 f1			.pastdmark: pop af  
c0e4			endm  
# End of macro DMARK
c0e4						CALLMONITOR 
c0e4 cd 6b ee			call debug_vector  
c0e7				endm  
# End of macro CALLMONITOR
c0e7					endif 
c0e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c0e7 cd c8 9b			call macro_dsp_valuehl 
c0ea				endm 
# End of macro FORTH_DSP_VALUEHL
c0ea			 
c0ea			 
c0ea					; TODO save cursor row 
c0ea 7d					ld a,l 
c0eb fe 02				cp 2 
c0ed 20 04				jr nz, .crow3 
c0ef 3e 28				ld a, display_row_2 
c0f1 18 12				jr .ccol1 
c0f3 fe 03		.crow3:		cp 3 
c0f5 20 04				jr nz, .crow4 
c0f7 3e 50				ld a, display_row_3 
c0f9 18 0a				jr .ccol1 
c0fb fe 04		.crow4:		cp 4 
c0fd 20 04				jr nz, .crow1 
c0ff 3e 78				ld a, display_row_4 
c101 18 02				jr .ccol1 
c103 3e 00		.crow1:		ld a,display_row_1 
c105 f5			.ccol1:		push af			; got row offset 
c106 6f					ld l,a 
c107 26 00				ld h,0 
c109					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c109 cd 80 9c			call macro_forth_dsp_pop 
c10c				endm 
# End of macro FORTH_DSP_POP
c10c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c10c cd c8 9b			call macro_dsp_valuehl 
c10f				endm 
# End of macro FORTH_DSP_VALUEHL
c10f					; TODO save cursor col 
c10f f1					pop af 
c110 85					add l		; add col offset 
c111 32 51 ea				ld (f_cursor_ptr), a 
c114					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c114 cd 80 9c			call macro_forth_dsp_pop 
c117				endm 
# End of macro FORTH_DSP_POP
c117			 
c117					; calculate  
c117			 
c117					NEXTW 
c117 cd 68 ee			call parse_vector 
c11a c3 af 9d			jp macro_next 
c11d				endm 
# End of macro NEXTW
c11d			 
c11d			 
c11d			.HOME: 
c11d				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
c11d 41				db WORD_SYS_CORE+45             
c11e 4d c1			dw .CR            
c120 05				db 4 + 1 
c121 .. 00			db "HOME",0              
c126				endm 
# End of macro CWHEAD
c126			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
c126					if DEBUG_FORTH_WORDS_KEY 
c126						DMARK "HOM" 
c126 f5				push af  
c127 3a 3b c1			ld a, (.dmark)  
c12a 32 5e ee			ld (debug_mark),a  
c12d 3a 3c c1			ld a, (.dmark+1)  
c130 32 5f ee			ld (debug_mark+1),a  
c133 3a 3d c1			ld a, (.dmark+2)  
c136 32 60 ee			ld (debug_mark+2),a  
c139 18 03			jr .pastdmark  
c13b ..			.dmark: db "HOM"  
c13e f1			.pastdmark: pop af  
c13f			endm  
# End of macro DMARK
c13f						CALLMONITOR 
c13f cd 6b ee			call debug_vector  
c142				endm  
# End of macro CALLMONITOR
c142					endif 
c142 3e 00		.home:		ld a, 0		; and home cursor 
c144 32 51 ea				ld (f_cursor_ptr), a 
c147					NEXTW 
c147 cd 68 ee			call parse_vector 
c14a c3 af 9d			jp macro_next 
c14d				endm 
# End of macro NEXTW
c14d			 
c14d			 
c14d			.CR: 
c14d				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
c14d 46				db WORD_SYS_CORE+50             
c14e 8b c1			dw .SPACE            
c150 03				db 2 + 1 
c151 .. 00			db "CR",0              
c154				endm 
# End of macro CWHEAD
c154			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
c154					if DEBUG_FORTH_WORDS_KEY 
c154						DMARK "CR." 
c154 f5				push af  
c155 3a 69 c1			ld a, (.dmark)  
c158 32 5e ee			ld (debug_mark),a  
c15b 3a 6a c1			ld a, (.dmark+1)  
c15e 32 5f ee			ld (debug_mark+1),a  
c161 3a 6b c1			ld a, (.dmark+2)  
c164 32 60 ee			ld (debug_mark+2),a  
c167 18 03			jr .pastdmark  
c169 ..			.dmark: db "CR."  
c16c f1			.pastdmark: pop af  
c16d			endm  
# End of macro DMARK
c16d						CALLMONITOR 
c16d cd 6b ee			call debug_vector  
c170				endm  
# End of macro CALLMONITOR
c170					endif 
c170 3e 0d				ld a, 13 
c172 32 b4 e2				ld (scratch),a 
c175 3e 0a				ld a, 10 
c177 32 b5 e2				ld (scratch+1),a 
c17a 3e 00				ld a, 0 
c17c 32 b6 e2				ld (scratch+2),a 
c17f 21 b4 e2				ld hl, scratch 
c182 cd 36 9a				call forth_push_str 
c185					 
c185				       NEXTW 
c185 cd 68 ee			call parse_vector 
c188 c3 af 9d			jp macro_next 
c18b				endm 
# End of macro NEXTW
c18b			.SPACE: 
c18b				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c18b 46				db WORD_SYS_CORE+50             
c18c c4 c1			dw .SPACES            
c18e 03				db 2 + 1 
c18f .. 00			db "BL",0              
c192				endm 
# End of macro CWHEAD
c192			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c192					if DEBUG_FORTH_WORDS_KEY 
c192						DMARK "BL." 
c192 f5				push af  
c193 3a a7 c1			ld a, (.dmark)  
c196 32 5e ee			ld (debug_mark),a  
c199 3a a8 c1			ld a, (.dmark+1)  
c19c 32 5f ee			ld (debug_mark+1),a  
c19f 3a a9 c1			ld a, (.dmark+2)  
c1a2 32 60 ee			ld (debug_mark+2),a  
c1a5 18 03			jr .pastdmark  
c1a7 ..			.dmark: db "BL."  
c1aa f1			.pastdmark: pop af  
c1ab			endm  
# End of macro DMARK
c1ab						CALLMONITOR 
c1ab cd 6b ee			call debug_vector  
c1ae				endm  
# End of macro CALLMONITOR
c1ae					endif 
c1ae 3e 20				ld a, " " 
c1b0 32 b4 e2				ld (scratch),a 
c1b3 3e 00				ld a, 0 
c1b5 32 b5 e2				ld (scratch+1),a 
c1b8 21 b4 e2				ld hl, scratch 
c1bb cd 36 9a				call forth_push_str 
c1be					 
c1be				       NEXTW 
c1be cd 68 ee			call parse_vector 
c1c1 c3 af 9d			jp macro_next 
c1c4				endm 
# End of macro NEXTW
c1c4			 
c1c4			;.blstr: db " ", 0 
c1c4			 
c1c4			.SPACES: 
c1c4				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c1c4 47				db WORD_SYS_CORE+51             
c1c5 60 c2			dw .SCROLL            
c1c7 07				db 6 + 1 
c1c8 .. 00			db "SPACES",0              
c1cf				endm 
# End of macro CWHEAD
c1cf			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c1cf					if DEBUG_FORTH_WORDS_KEY 
c1cf						DMARK "SPS" 
c1cf f5				push af  
c1d0 3a e4 c1			ld a, (.dmark)  
c1d3 32 5e ee			ld (debug_mark),a  
c1d6 3a e5 c1			ld a, (.dmark+1)  
c1d9 32 5f ee			ld (debug_mark+1),a  
c1dc 3a e6 c1			ld a, (.dmark+2)  
c1df 32 60 ee			ld (debug_mark+2),a  
c1e2 18 03			jr .pastdmark  
c1e4 ..			.dmark: db "SPS"  
c1e7 f1			.pastdmark: pop af  
c1e8			endm  
# End of macro DMARK
c1e8						CALLMONITOR 
c1e8 cd 6b ee			call debug_vector  
c1eb				endm  
# End of macro CALLMONITOR
c1eb					endif 
c1eb			 
c1eb			 
c1eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1eb cd c8 9b			call macro_dsp_valuehl 
c1ee				endm 
# End of macro FORTH_DSP_VALUEHL
c1ee			 
c1ee e5					push hl    ; u 
c1ef					if DEBUG_FORTH_WORDS 
c1ef						DMARK "SPA" 
c1ef f5				push af  
c1f0 3a 04 c2			ld a, (.dmark)  
c1f3 32 5e ee			ld (debug_mark),a  
c1f6 3a 05 c2			ld a, (.dmark+1)  
c1f9 32 5f ee			ld (debug_mark+1),a  
c1fc 3a 06 c2			ld a, (.dmark+2)  
c1ff 32 60 ee			ld (debug_mark+2),a  
c202 18 03			jr .pastdmark  
c204 ..			.dmark: db "SPA"  
c207 f1			.pastdmark: pop af  
c208			endm  
# End of macro DMARK
c208						CALLMONITOR 
c208 cd 6b ee			call debug_vector  
c20b				endm  
# End of macro CALLMONITOR
c20b					endif 
c20b			 
c20b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c20b cd 80 9c			call macro_forth_dsp_pop 
c20e				endm 
# End of macro FORTH_DSP_POP
c20e e1					pop hl 
c20f 0e 00				ld c, 0 
c211 45					ld b, l 
c212 21 b4 e2				ld hl, scratch  
c215			 
c215					if DEBUG_FORTH_WORDS 
c215						DMARK "SP2" 
c215 f5				push af  
c216 3a 2a c2			ld a, (.dmark)  
c219 32 5e ee			ld (debug_mark),a  
c21c 3a 2b c2			ld a, (.dmark+1)  
c21f 32 5f ee			ld (debug_mark+1),a  
c222 3a 2c c2			ld a, (.dmark+2)  
c225 32 60 ee			ld (debug_mark+2),a  
c228 18 03			jr .pastdmark  
c22a ..			.dmark: db "SP2"  
c22d f1			.pastdmark: pop af  
c22e			endm  
# End of macro DMARK
c22e						CALLMONITOR 
c22e cd 6b ee			call debug_vector  
c231				endm  
# End of macro CALLMONITOR
c231					endif 
c231			;		ld a, ' ' 
c231			.spaces1:	 
c231 36 20				ld (hl),' ' 
c233 23					inc hl 
c234					 
c234 10 fb				djnz .spaces1 
c236			;		ld a,0 
c236 36 00				ld (hl),0 
c238 21 b4 e2				ld hl, scratch 
c23b					if DEBUG_FORTH_WORDS 
c23b						DMARK "SP3" 
c23b f5				push af  
c23c 3a 50 c2			ld a, (.dmark)  
c23f 32 5e ee			ld (debug_mark),a  
c242 3a 51 c2			ld a, (.dmark+1)  
c245 32 5f ee			ld (debug_mark+1),a  
c248 3a 52 c2			ld a, (.dmark+2)  
c24b 32 60 ee			ld (debug_mark+2),a  
c24e 18 03			jr .pastdmark  
c250 ..			.dmark: db "SP3"  
c253 f1			.pastdmark: pop af  
c254			endm  
# End of macro DMARK
c254						CALLMONITOR 
c254 cd 6b ee			call debug_vector  
c257				endm  
# End of macro CALLMONITOR
c257					endif 
c257 cd 36 9a				call forth_push_str 
c25a			 
c25a				       NEXTW 
c25a cd 68 ee			call parse_vector 
c25d c3 af 9d			jp macro_next 
c260				endm 
# End of macro NEXTW
c260			 
c260			 
c260			 
c260			.SCROLL: 
c260				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c260 53				db WORD_SYS_CORE+63             
c261 90 c2			dw .SCROLLD            
c263 07				db 6 + 1 
c264 .. 00			db "SCROLL",0              
c26b				endm 
# End of macro CWHEAD
c26b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c26b					if DEBUG_FORTH_WORDS_KEY 
c26b						DMARK "SCR" 
c26b f5				push af  
c26c 3a 80 c2			ld a, (.dmark)  
c26f 32 5e ee			ld (debug_mark),a  
c272 3a 81 c2			ld a, (.dmark+1)  
c275 32 5f ee			ld (debug_mark+1),a  
c278 3a 82 c2			ld a, (.dmark+2)  
c27b 32 60 ee			ld (debug_mark+2),a  
c27e 18 03			jr .pastdmark  
c280 ..			.dmark: db "SCR"  
c283 f1			.pastdmark: pop af  
c284			endm  
# End of macro DMARK
c284						CALLMONITOR 
c284 cd 6b ee			call debug_vector  
c287				endm  
# End of macro CALLMONITOR
c287					endif 
c287			 
c287 cd 74 8a			call scroll_up 
c28a			;	call update_display 
c28a			 
c28a					NEXTW 
c28a cd 68 ee			call parse_vector 
c28d c3 af 9d			jp macro_next 
c290				endm 
# End of macro NEXTW
c290			 
c290			 
c290			 
c290			;		; get dir 
c290			; 
c290			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c290			; 
c290			;		push hl 
c290			; 
c290			;		; destroy value TOS 
c290			; 
c290			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c290			; 
c290			;		; get count 
c290			; 
c290			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c290			; 
c290			;		push hl 
c290			; 
c290			;		; destroy value TOS 
c290			; 
c290			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c290			; 
c290			;		; one value on hl get other one back 
c290			; 
c290			;		pop bc    ; count 
c290			; 
c290			;		pop de   ; dir 
c290			; 
c290			; 
c290			;		ld b, c 
c290			; 
c290			;.scrolldir:     push bc 
c290			;		push de 
c290			; 
c290			;		ld a, 0 
c290			;		cp e 
c290			;		jr z, .scrollup  
c290			;		call scroll_down 
c290			;		jr .scrollnext 
c290			;.scrollup:	call scroll_up 
c290			; 
c290			;		 
c290			;.scrollnext: 
c290			;		pop de 
c290			;		pop bc 
c290			;		djnz .scrolldir 
c290			; 
c290			; 
c290			; 
c290			; 
c290			; 
c290			;		NEXTW 
c290			 
c290			.SCROLLD: 
c290				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c290 53				db WORD_SYS_CORE+63             
c291 c1 c2			dw .ATQ            
c293 08				db 7 + 1 
c294 .. 00			db "SCROLLD",0              
c29c				endm 
# End of macro CWHEAD
c29c			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c29c					if DEBUG_FORTH_WORDS_KEY 
c29c						DMARK "SCD" 
c29c f5				push af  
c29d 3a b1 c2			ld a, (.dmark)  
c2a0 32 5e ee			ld (debug_mark),a  
c2a3 3a b2 c2			ld a, (.dmark+1)  
c2a6 32 5f ee			ld (debug_mark+1),a  
c2a9 3a b3 c2			ld a, (.dmark+2)  
c2ac 32 60 ee			ld (debug_mark+2),a  
c2af 18 03			jr .pastdmark  
c2b1 ..			.dmark: db "SCD"  
c2b4 f1			.pastdmark: pop af  
c2b5			endm  
# End of macro DMARK
c2b5						CALLMONITOR 
c2b5 cd 6b ee			call debug_vector  
c2b8				endm  
# End of macro CALLMONITOR
c2b8					endif 
c2b8			 
c2b8 cd 97 8a			call scroll_down 
c2bb			;	call update_display 
c2bb			 
c2bb					NEXTW 
c2bb cd 68 ee			call parse_vector 
c2be c3 af 9d			jp macro_next 
c2c1				endm 
# End of macro NEXTW
c2c1			 
c2c1			 
c2c1			.ATQ: 
c2c1				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c2c1 62				db WORD_SYS_CORE+78             
c2c2 22 c3			dw .AUTODSP            
c2c4 04				db 3 + 1 
c2c5 .. 00			db "AT@",0              
c2c9				endm 
# End of macro CWHEAD
c2c9			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c2c9					if DEBUG_FORTH_WORDS_KEY 
c2c9						DMARK "ATA" 
c2c9 f5				push af  
c2ca 3a de c2			ld a, (.dmark)  
c2cd 32 5e ee			ld (debug_mark),a  
c2d0 3a df c2			ld a, (.dmark+1)  
c2d3 32 5f ee			ld (debug_mark+1),a  
c2d6 3a e0 c2			ld a, (.dmark+2)  
c2d9 32 60 ee			ld (debug_mark+2),a  
c2dc 18 03			jr .pastdmark  
c2de ..			.dmark: db "ATA"  
c2e1 f1			.pastdmark: pop af  
c2e2			endm  
# End of macro DMARK
c2e2						CALLMONITOR 
c2e2 cd 6b ee			call debug_vector  
c2e5				endm  
# End of macro CALLMONITOR
c2e5					endif 
c2e5			 
c2e5			 
c2e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2e5 cd c8 9b			call macro_dsp_valuehl 
c2e8				endm 
# End of macro FORTH_DSP_VALUEHL
c2e8			 
c2e8					; TODO save cursor row 
c2e8 7d					ld a,l 
c2e9 fe 02				cp 2 
c2eb 20 04				jr nz, .crow3aq 
c2ed 3e 28				ld a, display_row_2 
c2ef 18 12				jr .ccol1aq 
c2f1 fe 03		.crow3aq:		cp 3 
c2f3 20 04				jr nz, .crow4aq 
c2f5 3e 50				ld a, display_row_3 
c2f7 18 0a				jr .ccol1aq 
c2f9 fe 04		.crow4aq:		cp 4 
c2fb 20 04				jr nz, .crow1aq 
c2fd 3e 78				ld a, display_row_4 
c2ff 18 02				jr .ccol1aq 
c301 3e 00		.crow1aq:		ld a,display_row_1 
c303 f5			.ccol1aq:		push af			; got row offset 
c304 6f					ld l,a 
c305 26 00				ld h,0 
c307					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c307 cd 80 9c			call macro_forth_dsp_pop 
c30a				endm 
# End of macro FORTH_DSP_POP
c30a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c30a cd c8 9b			call macro_dsp_valuehl 
c30d				endm 
# End of macro FORTH_DSP_VALUEHL
c30d					; TODO save cursor col 
c30d f1					pop af 
c30e 85					add l		; add col offset 
c30f			 
c30f					; add current frame buffer address 
c30f 2a bf eb				ld hl, (display_fb_active) 
c312 cd db 8c				call addatohl 
c315			 
c315			 
c315			 
c315			 
c315					; get char frame buffer location offset in hl 
c315			 
c315 7e					ld a,(hl) 
c316 26 00				ld h, 0 
c318 6f					ld l, a 
c319			 
c319 cd cc 99				call forth_push_numhl 
c31c			 
c31c			 
c31c					NEXTW 
c31c cd 68 ee			call parse_vector 
c31f c3 af 9d			jp macro_next 
c322				endm 
# End of macro NEXTW
c322			 
c322			.AUTODSP: 
c322				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c322 63				db WORD_SYS_CORE+79             
c323 3b c3			dw .MENU            
c325 05				db 4 + 1 
c326 .. 00			db "ADSP",0              
c32b				endm 
# End of macro CWHEAD
c32b			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c32b			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c32b			 
c32b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c32b cd c8 9b			call macro_dsp_valuehl 
c32e				endm 
# End of macro FORTH_DSP_VALUEHL
c32e			 
c32e			;		push hl 
c32e			 
c32e					; destroy value TOS 
c32e			 
c32e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c32e cd 80 9c			call macro_forth_dsp_pop 
c331				endm 
# End of macro FORTH_DSP_POP
c331			 
c331			;		pop hl 
c331			 
c331 7d					ld a,l 
c332 32 2f ea				ld (cli_autodisplay), a 
c335				       NEXTW 
c335 cd 68 ee			call parse_vector 
c338 c3 af 9d			jp macro_next 
c33b				endm 
# End of macro NEXTW
c33b			 
c33b			.MENU: 
c33b				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c33b 70				db WORD_SYS_CORE+92             
c33c e7 c3			dw .ENDDISPLAY            
c33e 05				db 4 + 1 
c33f .. 00			db "MENU",0              
c344				endm 
# End of macro CWHEAD
c344			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c344			 
c344			;		; get number of items on the stack 
c344			; 
c344				 
c344					FORTH_DSP_VALUEHL 
c344 cd c8 9b			call macro_dsp_valuehl 
c347				endm 
# End of macro FORTH_DSP_VALUEHL
c347				 
c347					if DEBUG_FORTH_WORDS_KEY 
c347						DMARK "MNU" 
c347 f5				push af  
c348 3a 5c c3			ld a, (.dmark)  
c34b 32 5e ee			ld (debug_mark),a  
c34e 3a 5d c3			ld a, (.dmark+1)  
c351 32 5f ee			ld (debug_mark+1),a  
c354 3a 5e c3			ld a, (.dmark+2)  
c357 32 60 ee			ld (debug_mark+2),a  
c35a 18 03			jr .pastdmark  
c35c ..			.dmark: db "MNU"  
c35f f1			.pastdmark: pop af  
c360			endm  
# End of macro DMARK
c360						CALLMONITOR 
c360 cd 6b ee			call debug_vector  
c363				endm  
# End of macro CALLMONITOR
c363					endif 
c363			 
c363 45					ld b, l	 
c364 05					dec b 
c365			 
c365					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c365 cd 80 9c			call macro_forth_dsp_pop 
c368				endm 
# End of macro FORTH_DSP_POP
c368			 
c368			 
c368					; go directly through the stack to pluck out the string pointers and build an array 
c368			 
c368			;		FORTH_DSP 
c368			 
c368					; hl contains top most stack item 
c368				 
c368 11 b4 e2				ld de, scratch 
c36b			 
c36b			.mbuild: 
c36b			 
c36b					FORTH_DSP_VALUEHL 
c36b cd c8 9b			call macro_dsp_valuehl 
c36e				endm 
# End of macro FORTH_DSP_VALUEHL
c36e			 
c36e					if DEBUG_FORTH_WORDS 
c36e						DMARK "MN3" 
c36e f5				push af  
c36f 3a 83 c3			ld a, (.dmark)  
c372 32 5e ee			ld (debug_mark),a  
c375 3a 84 c3			ld a, (.dmark+1)  
c378 32 5f ee			ld (debug_mark+1),a  
c37b 3a 85 c3			ld a, (.dmark+2)  
c37e 32 60 ee			ld (debug_mark+2),a  
c381 18 03			jr .pastdmark  
c383 ..			.dmark: db "MN3"  
c386 f1			.pastdmark: pop af  
c387			endm  
# End of macro DMARK
c387						CALLMONITOR 
c387 cd 6b ee			call debug_vector  
c38a				endm  
# End of macro CALLMONITOR
c38a					endif 
c38a eb					ex de, hl 
c38b 73					ld (hl), e 
c38c 23					inc hl 
c38d 72					ld (hl), d 
c38e 23					inc hl 
c38f eb					ex de, hl 
c390			 
c390					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c390 cd 80 9c			call macro_forth_dsp_pop 
c393				endm 
# End of macro FORTH_DSP_POP
c393			 
c393 10 d6				djnz .mbuild 
c395			 
c395					; done add term 
c395			 
c395 eb					ex de, hl 
c396 36 00				ld (hl), 0 
c398 23					inc hl 
c399 36 00				ld (hl), 0 
c39b			 
c39b				 
c39b					 
c39b 21 b4 e2				ld hl, scratch 
c39e			 
c39e					if DEBUG_FORTH_WORDS 
c39e						DMARK "MNx" 
c39e f5				push af  
c39f 3a b3 c3			ld a, (.dmark)  
c3a2 32 5e ee			ld (debug_mark),a  
c3a5 3a b4 c3			ld a, (.dmark+1)  
c3a8 32 5f ee			ld (debug_mark+1),a  
c3ab 3a b5 c3			ld a, (.dmark+2)  
c3ae 32 60 ee			ld (debug_mark+2),a  
c3b1 18 03			jr .pastdmark  
c3b3 ..			.dmark: db "MNx"  
c3b6 f1			.pastdmark: pop af  
c3b7			endm  
# End of macro DMARK
c3b7						CALLMONITOR 
c3b7 cd 6b ee			call debug_vector  
c3ba				endm  
# End of macro CALLMONITOR
c3ba					endif 
c3ba			 
c3ba			 
c3ba			 
c3ba 3e 00				ld a, 0 
c3bc cd e1 8a				call menu 
c3bf			 
c3bf			 
c3bf 6f					ld l, a 
c3c0 26 00				ld h, 0 
c3c2			 
c3c2					if DEBUG_FORTH_WORDS 
c3c2						DMARK "MNr" 
c3c2 f5				push af  
c3c3 3a d7 c3			ld a, (.dmark)  
c3c6 32 5e ee			ld (debug_mark),a  
c3c9 3a d8 c3			ld a, (.dmark+1)  
c3cc 32 5f ee			ld (debug_mark+1),a  
c3cf 3a d9 c3			ld a, (.dmark+2)  
c3d2 32 60 ee			ld (debug_mark+2),a  
c3d5 18 03			jr .pastdmark  
c3d7 ..			.dmark: db "MNr"  
c3da f1			.pastdmark: pop af  
c3db			endm  
# End of macro DMARK
c3db						CALLMONITOR 
c3db cd 6b ee			call debug_vector  
c3de				endm  
# End of macro CALLMONITOR
c3de					endif 
c3de			 
c3de cd cc 99				call forth_push_numhl 
c3e1			 
c3e1			 
c3e1			 
c3e1			 
c3e1				       NEXTW 
c3e1 cd 68 ee			call parse_vector 
c3e4 c3 af 9d			jp macro_next 
c3e7				endm 
# End of macro NEXTW
c3e7			 
c3e7			 
c3e7			.ENDDISPLAY: 
c3e7			 
c3e7			; eof 
# End of file forth_words_display.asm
c3e7			include "forth_words_str.asm" 
c3e7			 
c3e7			; | ## String Words 
c3e7			 
c3e7			.CONST: 
c3e7				 
c3e7				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
c3e7 48				db WORD_SYS_CORE+52             
c3e8 fc c3			dw .MOVE            
c3ea 06				db 5 + 1 
c3eb .. 00			db "CONST",0              
c3f1				endm 
# End of macro CWHEAD
c3f1			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
c3f1					FORTH_DSP 
c3f1 cd 8e 9b			call macro_forth_dsp 
c3f4				endm 
# End of macro FORTH_DSP
c3f4 36 04				ld (hl), DS_TYPE_CONST 
c3f6					NEXTW 
c3f6 cd 68 ee			call parse_vector 
c3f9 c3 af 9d			jp macro_next 
c3fc				endm 
# End of macro NEXTW
c3fc			 
c3fc			.MOVE:   
c3fc			 
c3fc				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
c3fc 48				db WORD_SYS_CORE+52             
c3fd 23 c4			dw .ZMOVE            
c3ff 05				db 4 + 1 
c400 .. 00			db "MOVE",0              
c405				endm 
# End of macro CWHEAD
c405			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
c405			 
c405					FORTH_DSP_VALUEHL 
c405 cd c8 9b			call macro_dsp_valuehl 
c408				endm 
# End of macro FORTH_DSP_VALUEHL
c408 e5					push hl    ; push count 
c409			 
c409					FORTH_DSP_POP 
c409 cd 80 9c			call macro_forth_dsp_pop 
c40c				endm 
# End of macro FORTH_DSP_POP
c40c			 
c40c					FORTH_DSP_VALUEHL 
c40c cd c8 9b			call macro_dsp_valuehl 
c40f				endm 
# End of macro FORTH_DSP_VALUEHL
c40f e5					push hl    ; dest 
c410			 
c410					FORTH_DSP_POP 
c410 cd 80 9c			call macro_forth_dsp_pop 
c413				endm 
# End of macro FORTH_DSP_POP
c413			 
c413					FORTH_DSP_VALUEHL 
c413 cd c8 9b			call macro_dsp_valuehl 
c416				endm 
# End of macro FORTH_DSP_VALUEHL
c416			 
c416					FORTH_DSP_POP 
c416 cd 80 9c			call macro_forth_dsp_pop 
c419				endm 
# End of macro FORTH_DSP_POP
c419			 
c419 d1					pop de 
c41a c1					pop bc 
c41b				 
c41b ed b0				ldir 
c41d				NEXTW 
c41d cd 68 ee			call parse_vector 
c420 c3 af 9d			jp macro_next 
c423				endm 
# End of macro NEXTW
c423			.ZMOVE:   
c423			 
c423				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
c423 48				db WORD_SYS_CORE+52             
c424 4c c4			dw .TABLE            
c426 06				db 5 + 1 
c427 .. 00			db "ZMOVE",0              
c42d				endm 
# End of macro CWHEAD
c42d					 
c42d			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
c42d			; | | Ensure you have enough space! 
c42d			 
c42d			 
c42d					FORTH_DSP_VALUEHL 
c42d cd c8 9b			call macro_dsp_valuehl 
c430				endm 
# End of macro FORTH_DSP_VALUEHL
c430 e5					push hl    ; dest 
c431			 
c431					FORTH_DSP_POP 
c431 cd 80 9c			call macro_forth_dsp_pop 
c434				endm 
# End of macro FORTH_DSP_POP
c434			 
c434					FORTH_DSP_VALUEHL 
c434 cd c8 9b			call macro_dsp_valuehl 
c437				endm 
# End of macro FORTH_DSP_VALUEHL
c437			 
c437					FORTH_DSP_POP 
c437 cd 80 9c			call macro_forth_dsp_pop 
c43a				endm 
# End of macro FORTH_DSP_POP
c43a			 
c43a d1					pop de 
c43b			 
c43b 01 ff 00				ld bc, 255 
c43e ed a0		.zmovel:	ldi 
c440 2b					dec hl 
c441 7e					ld a,(hl) 
c442 23					inc hl 
c443 b7					or a  
c444 20 f8				jr nz, .zmovel    
c446					 
c446			 
c446				NEXTW 
c446 cd 68 ee			call parse_vector 
c449 c3 af 9d			jp macro_next 
c44c				endm 
# End of macro NEXTW
c44c			 
c44c			.TABLE:   
c44c			 
c44c				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
c44c 48				db WORD_SYS_CORE+52             
c44d b1 c4			dw .SPLIT            
c44f 06				db 5 + 1 
c450 .. 00			db "TABLE",0              
c456				endm 
# End of macro CWHEAD
c456					 
c456			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
c456			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
c456			; | | in any kind of lookup or iteration.  
c456			; | | Last item in the array will be a zero pointer for ease of iteration 
c456			 
c456			 
c456				; get the count of strings 
c456			 
c456					FORTH_DSP_VALUEHL 
c456 cd c8 9b			call macro_dsp_valuehl 
c459				endm 
# End of macro FORTH_DSP_VALUEHL
c459			 
c459					FORTH_DSP_POP 
c459 cd 80 9c			call macro_forth_dsp_pop 
c45c				endm 
# End of macro FORTH_DSP_POP
c45c			 
c45c				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
c45c			 
c45c					; l contains count 
c45c			 
c45c 7d					ld a,l 
c45d 32 b4 e2				ld (scratch), a     ; save it for the loading loop 
c460			 
c460 2c					inc l  ; for zero pointer 
c461 eb					ex de, hl 
c462 3e 02				ld a, 2 
c464 cd 5e 8c				call Mult16 
c467			 
c467					; hl is the size of block to allocate 
c467			 
c467 cd a7 90				call malloc 
c46a				if DEBUG_FORTH_MALLOC_GUARD 
c46a cc 49 d3				call z,malloc_error 
c46d				endif 
c46d					; hl is the pointer to the array block 
c46d						 
c46d 22 b5 e2				ld (scratch+1), hl    ; save the base for later push to stack 
c470 22 b7 e2				ld (scratch+3), hl    ; save the base for current string to push 
c473			 
c473 3a b4 e2				ld a, (scratch) 
c476 47					ld b, a 
c477			 
c477				; for each string 
c477			 
c477			.tablelop: 
c477			 
c477 c5					push bc 
c478			 
c478				;     get string pointer 
c478			 
c478					FORTH_DSP_VALUEHL 
c478 cd c8 9b			call macro_dsp_valuehl 
c47b				endm 
# End of macro FORTH_DSP_VALUEHL
c47b			 
c47b e5					push hl 
c47c			 
c47c				;     get string length 
c47c			 
c47c 3e 00				ld a,0 
c47e cd 3e 90				call strlent 
c481			 
c481 23					inc hl 
c482 e5					push hl 
c483			 
c483				;     allocate string length 
c483			 
c483 cd a7 90				call malloc 
c486			 
c486			        ;     copy string to block 
c486			 
c486 c1					pop bc 
c487 eb					ex de, hl 
c488 e1					pop hl 
c489 d5					push de 
c48a			 
c48a ed b0				ldir 
c48c			 
c48c			 
c48c			        ;     add pointer to string to array block 
c48c			 
c48c 2a b7 e2				ld hl, (scratch+3)    ; save the base for current string to push 
c48f			 
c48f d1					pop de     ; the pointer to the newly copied string to add to the array 
c490 73					ld (hl), e 
c491 23					inc hl 
c492 72					ld (hl), d	 
c493 23					inc hl 
c494				 
c494 22 b7 e2				ld (scratch+3), hl    ; save the base for current string to push 
c497			 
c497					FORTH_DSP_POP 
c497 cd 80 9c			call macro_forth_dsp_pop 
c49a				endm 
# End of macro FORTH_DSP_POP
c49a			 
c49a c1					pop bc 
c49b 10 da				djnz .tablelop 
c49d			 
c49d			        ;  push array block pointer 
c49d			 
c49d 2a b7 e2				ld hl, (scratch+3)    ; save the base for current string to push 
c4a0 36 00				ld (hl), 0 
c4a2 23					inc hl 
c4a3 36 00				ld (hl), 0 
c4a5			 
c4a5			 
c4a5				 
c4a5 2a b5 e2				ld hl, (scratch+1)    ; save the base for current string to push 
c4a8 cd cc 99				call forth_push_numhl 
c4ab			 
c4ab				NEXTW 
c4ab cd 68 ee			call parse_vector 
c4ae c3 af 9d			jp macro_next 
c4b1				endm 
# End of macro NEXTW
c4b1			 
c4b1			.SPLIT:   
c4b1			 
c4b1				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
c4b1 48				db WORD_SYS_CORE+52             
c4b2 a8 c5			dw .PTR            
c4b4 06				db 5 + 1 
c4b5 .. 00			db "SPLIT",0              
c4bb				endm 
# End of macro CWHEAD
c4bb			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
c4bb					if DEBUG_FORTH_WORDS_KEY 
c4bb						DMARK "SPT" 
c4bb f5				push af  
c4bc 3a d0 c4			ld a, (.dmark)  
c4bf 32 5e ee			ld (debug_mark),a  
c4c2 3a d1 c4			ld a, (.dmark+1)  
c4c5 32 5f ee			ld (debug_mark+1),a  
c4c8 3a d2 c4			ld a, (.dmark+2)  
c4cb 32 60 ee			ld (debug_mark+2),a  
c4ce 18 03			jr .pastdmark  
c4d0 ..			.dmark: db "SPT"  
c4d3 f1			.pastdmark: pop af  
c4d4			endm  
# End of macro DMARK
c4d4						CALLMONITOR 
c4d4 cd 6b ee			call debug_vector  
c4d7				endm  
# End of macro CALLMONITOR
c4d7					endif 
c4d7			 
c4d7					; get delim 
c4d7					FORTH_DSP_VALUEHL 
c4d7 cd c8 9b			call macro_dsp_valuehl 
c4da				endm 
# End of macro FORTH_DSP_VALUEHL
c4da			 
c4da					FORTH_DSP_POP 
c4da cd 80 9c			call macro_forth_dsp_pop 
c4dd				endm 
# End of macro FORTH_DSP_POP
c4dd					 
c4dd			 
c4dd 45					ld b, l    ; move delim to b 
c4de 0e 01				ld c, 1   ; count of poritions 
c4e0			 
c4e0 c5					push bc 
c4e1			 
c4e1					if DEBUG_FORTH_WORDS 
c4e1						DMARK "SPa" 
c4e1 f5				push af  
c4e2 3a f6 c4			ld a, (.dmark)  
c4e5 32 5e ee			ld (debug_mark),a  
c4e8 3a f7 c4			ld a, (.dmark+1)  
c4eb 32 5f ee			ld (debug_mark+1),a  
c4ee 3a f8 c4			ld a, (.dmark+2)  
c4f1 32 60 ee			ld (debug_mark+2),a  
c4f4 18 03			jr .pastdmark  
c4f6 ..			.dmark: db "SPa"  
c4f9 f1			.pastdmark: pop af  
c4fa			endm  
# End of macro DMARK
c4fa						CALLMONITOR 
c4fa cd 6b ee			call debug_vector  
c4fd				endm  
# End of macro CALLMONITOR
c4fd					endif 
c4fd					; get pointer to string to chop up 
c4fd					FORTH_DSP_VALUEHL 
c4fd cd c8 9b			call macro_dsp_valuehl 
c500				endm 
# End of macro FORTH_DSP_VALUEHL
c500			 
c500			;		push hl 
c500 11 b4 e2				ld de, scratch 
c503			.spllop: 
c503 c1					pop bc 
c504 c5					push bc 
c505			;		pop hl 
c505					if DEBUG_FORTH_WORDS 
c505						DMARK "SPl" 
c505 f5				push af  
c506 3a 1a c5			ld a, (.dmark)  
c509 32 5e ee			ld (debug_mark),a  
c50c 3a 1b c5			ld a, (.dmark+1)  
c50f 32 5f ee			ld (debug_mark+1),a  
c512 3a 1c c5			ld a, (.dmark+2)  
c515 32 60 ee			ld (debug_mark+2),a  
c518 18 03			jr .pastdmark  
c51a ..			.dmark: db "SPl"  
c51d f1			.pastdmark: pop af  
c51e			endm  
# End of macro DMARK
c51e						CALLMONITOR 
c51e cd 6b ee			call debug_vector  
c521				endm  
# End of macro CALLMONITOR
c521					endif 
c521 7e					ld a, (hl) 
c522 b8					cp b 
c523 28 07				jr z, .splnxt 
c525			;		cp 0 
c525 b7					or a 
c526 28 34				jr z, .splend 
c528 ed a0				ldi 
c52a 18 d7				jr .spllop 
c52c			 
c52c					; hit dlim 
c52c			 
c52c			.splnxt: 
c52c					if DEBUG_FORTH_WORDS 
c52c						DMARK "SPx" 
c52c f5				push af  
c52d 3a 41 c5			ld a, (.dmark)  
c530 32 5e ee			ld (debug_mark),a  
c533 3a 42 c5			ld a, (.dmark+1)  
c536 32 5f ee			ld (debug_mark+1),a  
c539 3a 43 c5			ld a, (.dmark+2)  
c53c 32 60 ee			ld (debug_mark+2),a  
c53f 18 03			jr .pastdmark  
c541 ..			.dmark: db "SPx"  
c544 f1			.pastdmark: pop af  
c545			endm  
# End of macro DMARK
c545						CALLMONITOR 
c545 cd 6b ee			call debug_vector  
c548				endm  
# End of macro CALLMONITOR
c548					endif 
c548 3e 00				ld a, 0 
c54a 12					ld (de), a 
c54b					;ex de, hl 
c54b e5					push hl 
c54c 21 b4 e2				ld hl, scratch 
c54f cd 36 9a				call forth_push_str 
c552 e1					pop hl 
c553					;ex de, hl 
c553 23					inc hl 
c554 c1					pop bc 
c555 0c					inc c 
c556 c5					push bc 
c557 11 b4 e2				ld de, scratch 
c55a 18 a7				jr .spllop 
c55c			 
c55c			.splend:		 
c55c					if DEBUG_FORTH_WORDS 
c55c						DMARK "SPe" 
c55c f5				push af  
c55d 3a 71 c5			ld a, (.dmark)  
c560 32 5e ee			ld (debug_mark),a  
c563 3a 72 c5			ld a, (.dmark+1)  
c566 32 5f ee			ld (debug_mark+1),a  
c569 3a 73 c5			ld a, (.dmark+2)  
c56c 32 60 ee			ld (debug_mark+2),a  
c56f 18 03			jr .pastdmark  
c571 ..			.dmark: db "SPe"  
c574 f1			.pastdmark: pop af  
c575			endm  
# End of macro DMARK
c575						CALLMONITOR 
c575 cd 6b ee			call debug_vector  
c578				endm  
# End of macro CALLMONITOR
c578					endif 
c578 12					ld (de), a 
c579 eb					ex de, hl 
c57a			;		push hl 
c57a 21 b4 e2				ld hl, scratch 
c57d cd 36 9a				call forth_push_str 
c580					 
c580					if DEBUG_FORTH_WORDS 
c580						DMARK "SPc" 
c580 f5				push af  
c581 3a 95 c5			ld a, (.dmark)  
c584 32 5e ee			ld (debug_mark),a  
c587 3a 96 c5			ld a, (.dmark+1)  
c58a 32 5f ee			ld (debug_mark+1),a  
c58d 3a 97 c5			ld a, (.dmark+2)  
c590 32 60 ee			ld (debug_mark+2),a  
c593 18 03			jr .pastdmark  
c595 ..			.dmark: db "SPc"  
c598 f1			.pastdmark: pop af  
c599			endm  
# End of macro DMARK
c599						CALLMONITOR 
c599 cd 6b ee			call debug_vector  
c59c				endm  
# End of macro CALLMONITOR
c59c					endif 
c59c			 
c59c e1					pop hl    ; get counter from bc which has been push 
c59d 26 00				ld h, 0 
c59f			;		ld l, c 
c59f cd cc 99				call forth_push_numhl 
c5a2			 
c5a2			 
c5a2				NEXTW 
c5a2 cd 68 ee			call parse_vector 
c5a5 c3 af 9d			jp macro_next 
c5a8				endm 
# End of macro NEXTW
c5a8			.PTR:   
c5a8			 
c5a8				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c5a8 48				db WORD_SYS_CORE+52             
c5a9 d8 c5			dw .STYPE            
c5ab 04				db 3 + 1 
c5ac .. 00			db "PTR",0              
c5b0				endm 
# End of macro CWHEAD
c5b0			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c5b0			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c5b0			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c5b0			 
c5b0					if DEBUG_FORTH_WORDS_KEY 
c5b0						DMARK "PTR" 
c5b0 f5				push af  
c5b1 3a c5 c5			ld a, (.dmark)  
c5b4 32 5e ee			ld (debug_mark),a  
c5b7 3a c6 c5			ld a, (.dmark+1)  
c5ba 32 5f ee			ld (debug_mark+1),a  
c5bd 3a c7 c5			ld a, (.dmark+2)  
c5c0 32 60 ee			ld (debug_mark+2),a  
c5c3 18 03			jr .pastdmark  
c5c5 ..			.dmark: db "PTR"  
c5c8 f1			.pastdmark: pop af  
c5c9			endm  
# End of macro DMARK
c5c9						CALLMONITOR 
c5c9 cd 6b ee			call debug_vector  
c5cc				endm  
# End of macro CALLMONITOR
c5cc					endif 
c5cc					FORTH_DSP_VALUEHL 
c5cc cd c8 9b			call macro_dsp_valuehl 
c5cf				endm 
# End of macro FORTH_DSP_VALUEHL
c5cf cd cc 99				call forth_push_numhl 
c5d2			 
c5d2			 
c5d2					NEXTW 
c5d2 cd 68 ee			call parse_vector 
c5d5 c3 af 9d			jp macro_next 
c5d8				endm 
# End of macro NEXTW
c5d8			.STYPE: 
c5d8				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c5d8 48				db WORD_SYS_CORE+52             
c5d9 35 c6			dw .UPPER            
c5db 06				db 5 + 1 
c5dc .. 00			db "STYPE",0              
c5e2				endm 
# End of macro CWHEAD
c5e2			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
c5e2			; | | 's' string or 'i' integer or 'c' const 
c5e2					if DEBUG_FORTH_WORDS_KEY 
c5e2						DMARK "STY" 
c5e2 f5				push af  
c5e3 3a f7 c5			ld a, (.dmark)  
c5e6 32 5e ee			ld (debug_mark),a  
c5e9 3a f8 c5			ld a, (.dmark+1)  
c5ec 32 5f ee			ld (debug_mark+1),a  
c5ef 3a f9 c5			ld a, (.dmark+2)  
c5f2 32 60 ee			ld (debug_mark+2),a  
c5f5 18 03			jr .pastdmark  
c5f7 ..			.dmark: db "STY"  
c5fa f1			.pastdmark: pop af  
c5fb			endm  
# End of macro DMARK
c5fb						CALLMONITOR 
c5fb cd 6b ee			call debug_vector  
c5fe				endm  
# End of macro CALLMONITOR
c5fe					endif 
c5fe					FORTH_DSP 
c5fe cd 8e 9b			call macro_forth_dsp 
c601				endm 
# End of macro FORTH_DSP
c601					;v5 FORTH_DSP_VALUE 
c601			 
c601 7e					ld a, (hl) 
c602			 
c602 f5					push af 
c603			 
c603			; Dont destroy TOS		FORTH_DSP_POP 
c603			 
c603 f1					pop af 
c604			 
c604 fe 01				cp DS_TYPE_STR 
c606 28 12				jr z, .typestr 
c608 fe 04				cp DS_TYPE_CONST 
c60a 28 09				jr z, .typeconst 
c60c			 
c60c fe 02				cp DS_TYPE_INUM 
c60e 28 0f				jr z, .typeinum 
c610			 
c610 21 33 c6				ld hl, .tna 
c613 18 0f				jr .tpush 
c615			 
c615 21 2f c6		.typeconst:	ld hl, .tconst 
c618 18 0a				jr .tpush 
c61a 21 2d c6		.typestr:	ld hl, .tstr 
c61d 18 05				jr .tpush 
c61f 21 31 c6		.typeinum:	ld hl, .tinum 
c622 18 00				jr .tpush 
c624			 
c624			.tpush: 
c624			 
c624 cd 36 9a				call forth_push_str 
c627			 
c627					NEXTW 
c627 cd 68 ee			call parse_vector 
c62a c3 af 9d			jp macro_next 
c62d				endm 
# End of macro NEXTW
c62d .. 00		.tstr:	db "s",0 
c62f .. 00		.tconst:	db "c",0 
c631 .. 00		.tinum:  db "i",0 
c633 .. 00		.tna:   db "?", 0 
c635			 
c635			 
c635			.UPPER: 
c635				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c635 48				db WORD_SYS_CORE+52             
c636 72 c6			dw .LOWER            
c638 06				db 5 + 1 
c639 .. 00			db "UPPER",0              
c63f				endm 
# End of macro CWHEAD
c63f			; | UPPER ( s -- s ) Upper case string s  | DONE 
c63f					if DEBUG_FORTH_WORDS_KEY 
c63f						DMARK "UPR" 
c63f f5				push af  
c640 3a 54 c6			ld a, (.dmark)  
c643 32 5e ee			ld (debug_mark),a  
c646 3a 55 c6			ld a, (.dmark+1)  
c649 32 5f ee			ld (debug_mark+1),a  
c64c 3a 56 c6			ld a, (.dmark+2)  
c64f 32 60 ee			ld (debug_mark+2),a  
c652 18 03			jr .pastdmark  
c654 ..			.dmark: db "UPR"  
c657 f1			.pastdmark: pop af  
c658			endm  
# End of macro DMARK
c658						CALLMONITOR 
c658 cd 6b ee			call debug_vector  
c65b				endm  
# End of macro CALLMONITOR
c65b					endif 
c65b			 
c65b					FORTH_DSP 
c65b cd 8e 9b			call macro_forth_dsp 
c65e				endm 
# End of macro FORTH_DSP
c65e					 
c65e			; TODO check is string type 
c65e			 
c65e					FORTH_DSP_VALUEHL 
c65e cd c8 9b			call macro_dsp_valuehl 
c661				endm 
# End of macro FORTH_DSP_VALUEHL
c661			; get pointer to string in hl 
c661			 
c661 7e			.toup:		ld a, (hl) 
c662			;		cp 0 
c662 b7					or a 
c663 28 07				jr z, .toupdone 
c665			 
c665 cd 43 8f				call to_upper 
c668			 
c668 77					ld (hl), a 
c669 23					inc hl 
c66a 18 f5				jr .toup 
c66c			 
c66c					 
c66c			 
c66c			 
c66c			; for each char convert to upper 
c66c					 
c66c			.toupdone: 
c66c			 
c66c			 
c66c					NEXTW 
c66c cd 68 ee			call parse_vector 
c66f c3 af 9d			jp macro_next 
c672				endm 
# End of macro NEXTW
c672			.LOWER: 
c672				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c672 48				db WORD_SYS_CORE+52             
c673 af c6			dw .TCASE            
c675 06				db 5 + 1 
c676 .. 00			db "LOWER",0              
c67c				endm 
# End of macro CWHEAD
c67c			; | LOWER ( s -- s ) Lower case string s  | DONE 
c67c					if DEBUG_FORTH_WORDS_KEY 
c67c						DMARK "LWR" 
c67c f5				push af  
c67d 3a 91 c6			ld a, (.dmark)  
c680 32 5e ee			ld (debug_mark),a  
c683 3a 92 c6			ld a, (.dmark+1)  
c686 32 5f ee			ld (debug_mark+1),a  
c689 3a 93 c6			ld a, (.dmark+2)  
c68c 32 60 ee			ld (debug_mark+2),a  
c68f 18 03			jr .pastdmark  
c691 ..			.dmark: db "LWR"  
c694 f1			.pastdmark: pop af  
c695			endm  
# End of macro DMARK
c695						CALLMONITOR 
c695 cd 6b ee			call debug_vector  
c698				endm  
# End of macro CALLMONITOR
c698					endif 
c698			 
c698					FORTH_DSP 
c698 cd 8e 9b			call macro_forth_dsp 
c69b				endm 
# End of macro FORTH_DSP
c69b					 
c69b			; TODO check is string type 
c69b			 
c69b					FORTH_DSP_VALUEHL 
c69b cd c8 9b			call macro_dsp_valuehl 
c69e				endm 
# End of macro FORTH_DSP_VALUEHL
c69e			; get pointer to string in hl 
c69e			 
c69e 7e			.tolow:		ld a, (hl) 
c69f			;		cp 0 
c69f b7					or a 
c6a0 28 07				jr z, .tolowdone 
c6a2			 
c6a2 cd 4c 8f				call to_lower 
c6a5			 
c6a5 77					ld (hl), a 
c6a6 23					inc hl 
c6a7 18 f5				jr .tolow 
c6a9			 
c6a9					 
c6a9			 
c6a9			 
c6a9			; for each char convert to low 
c6a9					 
c6a9			.tolowdone: 
c6a9					NEXTW 
c6a9 cd 68 ee			call parse_vector 
c6ac c3 af 9d			jp macro_next 
c6af				endm 
# End of macro NEXTW
c6af			.TCASE: 
c6af				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c6af 48				db WORD_SYS_CORE+52             
c6b0 e6 c7			dw .SUBSTR            
c6b2 06				db 5 + 1 
c6b3 .. 00			db "TCASE",0              
c6b9				endm 
# End of macro CWHEAD
c6b9			; | TCASE ( s -- s ) Title case string s  | DONE 
c6b9					if DEBUG_FORTH_WORDS_KEY 
c6b9						DMARK "TCS" 
c6b9 f5				push af  
c6ba 3a ce c6			ld a, (.dmark)  
c6bd 32 5e ee			ld (debug_mark),a  
c6c0 3a cf c6			ld a, (.dmark+1)  
c6c3 32 5f ee			ld (debug_mark+1),a  
c6c6 3a d0 c6			ld a, (.dmark+2)  
c6c9 32 60 ee			ld (debug_mark+2),a  
c6cc 18 03			jr .pastdmark  
c6ce ..			.dmark: db "TCS"  
c6d1 f1			.pastdmark: pop af  
c6d2			endm  
# End of macro DMARK
c6d2						CALLMONITOR 
c6d2 cd 6b ee			call debug_vector  
c6d5				endm  
# End of macro CALLMONITOR
c6d5					endif 
c6d5			 
c6d5					FORTH_DSP 
c6d5 cd 8e 9b			call macro_forth_dsp 
c6d8				endm 
# End of macro FORTH_DSP
c6d8					 
c6d8			; TODO check is string type 
c6d8			 
c6d8					FORTH_DSP_VALUEHL 
c6d8 cd c8 9b			call macro_dsp_valuehl 
c6db				endm 
# End of macro FORTH_DSP_VALUEHL
c6db			; get pointer to string in hl 
c6db			 
c6db					if DEBUG_FORTH_WORDS 
c6db						DMARK "TC1" 
c6db f5				push af  
c6dc 3a f0 c6			ld a, (.dmark)  
c6df 32 5e ee			ld (debug_mark),a  
c6e2 3a f1 c6			ld a, (.dmark+1)  
c6e5 32 5f ee			ld (debug_mark+1),a  
c6e8 3a f2 c6			ld a, (.dmark+2)  
c6eb 32 60 ee			ld (debug_mark+2),a  
c6ee 18 03			jr .pastdmark  
c6f0 ..			.dmark: db "TC1"  
c6f3 f1			.pastdmark: pop af  
c6f4			endm  
# End of macro DMARK
c6f4						CALLMONITOR 
c6f4 cd 6b ee			call debug_vector  
c6f7				endm  
# End of macro CALLMONITOR
c6f7					endif 
c6f7			 
c6f7					; first time in turn to upper case first char 
c6f7			 
c6f7 7e					ld a, (hl) 
c6f8 c3 81 c7				jp .totsiptou 
c6fb			 
c6fb			 
c6fb 7e			.tot:		ld a, (hl) 
c6fc			;		cp 0 
c6fc b7					or a 
c6fd ca c4 c7				jp z, .totdone 
c700			 
c700					if DEBUG_FORTH_WORDS 
c700						DMARK "TC2" 
c700 f5				push af  
c701 3a 15 c7			ld a, (.dmark)  
c704 32 5e ee			ld (debug_mark),a  
c707 3a 16 c7			ld a, (.dmark+1)  
c70a 32 5f ee			ld (debug_mark+1),a  
c70d 3a 17 c7			ld a, (.dmark+2)  
c710 32 60 ee			ld (debug_mark+2),a  
c713 18 03			jr .pastdmark  
c715 ..			.dmark: db "TC2"  
c718 f1			.pastdmark: pop af  
c719			endm  
# End of macro DMARK
c719						CALLMONITOR 
c719 cd 6b ee			call debug_vector  
c71c				endm  
# End of macro CALLMONITOR
c71c					endif 
c71c					; check to see if current char is a space 
c71c			 
c71c fe 20				cp ' ' 
c71e 28 21				jr z, .totsp 
c720 cd 4c 8f				call to_lower 
c723					if DEBUG_FORTH_WORDS 
c723						DMARK "TC3" 
c723 f5				push af  
c724 3a 38 c7			ld a, (.dmark)  
c727 32 5e ee			ld (debug_mark),a  
c72a 3a 39 c7			ld a, (.dmark+1)  
c72d 32 5f ee			ld (debug_mark+1),a  
c730 3a 3a c7			ld a, (.dmark+2)  
c733 32 60 ee			ld (debug_mark+2),a  
c736 18 03			jr .pastdmark  
c738 ..			.dmark: db "TC3"  
c73b f1			.pastdmark: pop af  
c73c			endm  
# End of macro DMARK
c73c						CALLMONITOR 
c73c cd 6b ee			call debug_vector  
c73f				endm  
# End of macro CALLMONITOR
c73f					endif 
c73f 18 62				jr .totnxt 
c741			 
c741			.totsp:         ; on a space, find next char which should be upper 
c741			 
c741					if DEBUG_FORTH_WORDS 
c741						DMARK "TC4" 
c741 f5				push af  
c742 3a 56 c7			ld a, (.dmark)  
c745 32 5e ee			ld (debug_mark),a  
c748 3a 57 c7			ld a, (.dmark+1)  
c74b 32 5f ee			ld (debug_mark+1),a  
c74e 3a 58 c7			ld a, (.dmark+2)  
c751 32 60 ee			ld (debug_mark+2),a  
c754 18 03			jr .pastdmark  
c756 ..			.dmark: db "TC4"  
c759 f1			.pastdmark: pop af  
c75a			endm  
# End of macro DMARK
c75a						CALLMONITOR 
c75a cd 6b ee			call debug_vector  
c75d				endm  
# End of macro CALLMONITOR
c75d					endif 
c75d					;; 
c75d			 
c75d fe 20				cp ' ' 
c75f 20 20				jr nz, .totsiptou 
c761 23					inc hl 
c762 7e					ld a, (hl) 
c763					if DEBUG_FORTH_WORDS 
c763						DMARK "TC5" 
c763 f5				push af  
c764 3a 78 c7			ld a, (.dmark)  
c767 32 5e ee			ld (debug_mark),a  
c76a 3a 79 c7			ld a, (.dmark+1)  
c76d 32 5f ee			ld (debug_mark+1),a  
c770 3a 7a c7			ld a, (.dmark+2)  
c773 32 60 ee			ld (debug_mark+2),a  
c776 18 03			jr .pastdmark  
c778 ..			.dmark: db "TC5"  
c77b f1			.pastdmark: pop af  
c77c			endm  
# End of macro DMARK
c77c						CALLMONITOR 
c77c cd 6b ee			call debug_vector  
c77f				endm  
# End of macro CALLMONITOR
c77f					endif 
c77f 18 c0				jr .totsp 
c781			.totsiptou:     
c781					;cp 0 
c781 b7					or a 
c782 28 40				jr z, .totdone 
c784					; not space and not zero term so upper case it 
c784 cd 43 8f				call to_upper 
c787			 
c787					if DEBUG_FORTH_WORDS 
c787						DMARK "TC6" 
c787 f5				push af  
c788 3a 9c c7			ld a, (.dmark)  
c78b 32 5e ee			ld (debug_mark),a  
c78e 3a 9d c7			ld a, (.dmark+1)  
c791 32 5f ee			ld (debug_mark+1),a  
c794 3a 9e c7			ld a, (.dmark+2)  
c797 32 60 ee			ld (debug_mark+2),a  
c79a 18 03			jr .pastdmark  
c79c ..			.dmark: db "TC6"  
c79f f1			.pastdmark: pop af  
c7a0			endm  
# End of macro DMARK
c7a0						CALLMONITOR 
c7a0 cd 6b ee			call debug_vector  
c7a3				endm  
# End of macro CALLMONITOR
c7a3					endif 
c7a3			 
c7a3			 
c7a3			.totnxt: 
c7a3			 
c7a3 77					ld (hl), a 
c7a4 23					inc hl 
c7a5					if DEBUG_FORTH_WORDS 
c7a5						DMARK "TC7" 
c7a5 f5				push af  
c7a6 3a ba c7			ld a, (.dmark)  
c7a9 32 5e ee			ld (debug_mark),a  
c7ac 3a bb c7			ld a, (.dmark+1)  
c7af 32 5f ee			ld (debug_mark+1),a  
c7b2 3a bc c7			ld a, (.dmark+2)  
c7b5 32 60 ee			ld (debug_mark+2),a  
c7b8 18 03			jr .pastdmark  
c7ba ..			.dmark: db "TC7"  
c7bd f1			.pastdmark: pop af  
c7be			endm  
# End of macro DMARK
c7be						CALLMONITOR 
c7be cd 6b ee			call debug_vector  
c7c1				endm  
# End of macro CALLMONITOR
c7c1					endif 
c7c1 c3 fb c6				jp .tot 
c7c4			 
c7c4					 
c7c4			 
c7c4			 
c7c4			; for each char convert to low 
c7c4					 
c7c4			.totdone: 
c7c4					if DEBUG_FORTH_WORDS 
c7c4						DMARK "TCd" 
c7c4 f5				push af  
c7c5 3a d9 c7			ld a, (.dmark)  
c7c8 32 5e ee			ld (debug_mark),a  
c7cb 3a da c7			ld a, (.dmark+1)  
c7ce 32 5f ee			ld (debug_mark+1),a  
c7d1 3a db c7			ld a, (.dmark+2)  
c7d4 32 60 ee			ld (debug_mark+2),a  
c7d7 18 03			jr .pastdmark  
c7d9 ..			.dmark: db "TCd"  
c7dc f1			.pastdmark: pop af  
c7dd			endm  
# End of macro DMARK
c7dd						CALLMONITOR 
c7dd cd 6b ee			call debug_vector  
c7e0				endm  
# End of macro CALLMONITOR
c7e0					endif 
c7e0					NEXTW 
c7e0 cd 68 ee			call parse_vector 
c7e3 c3 af 9d			jp macro_next 
c7e6				endm 
# End of macro NEXTW
c7e6			 
c7e6			.SUBSTR: 
c7e6				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c7e6 48				db WORD_SYS_CORE+52             
c7e7 46 c8			dw .LEFT            
c7e9 07				db 6 + 1 
c7ea .. 00			db "SUBSTR",0              
c7f1				endm 
# End of macro CWHEAD
c7f1			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c7f1			 
c7f1					if DEBUG_FORTH_WORDS_KEY 
c7f1						DMARK "SST" 
c7f1 f5				push af  
c7f2 3a 06 c8			ld a, (.dmark)  
c7f5 32 5e ee			ld (debug_mark),a  
c7f8 3a 07 c8			ld a, (.dmark+1)  
c7fb 32 5f ee			ld (debug_mark+1),a  
c7fe 3a 08 c8			ld a, (.dmark+2)  
c801 32 60 ee			ld (debug_mark+2),a  
c804 18 03			jr .pastdmark  
c806 ..			.dmark: db "SST"  
c809 f1			.pastdmark: pop af  
c80a			endm  
# End of macro DMARK
c80a						CALLMONITOR 
c80a cd 6b ee			call debug_vector  
c80d				endm  
# End of macro CALLMONITOR
c80d					endif 
c80d			; TODO check string type 
c80d					FORTH_DSP_VALUEHL 
c80d cd c8 9b			call macro_dsp_valuehl 
c810				endm 
# End of macro FORTH_DSP_VALUEHL
c810			 
c810 e5					push hl      ; string length 
c811			 
c811					FORTH_DSP_POP 
c811 cd 80 9c			call macro_forth_dsp_pop 
c814				endm 
# End of macro FORTH_DSP_POP
c814			 
c814					FORTH_DSP_VALUEHL 
c814 cd c8 9b			call macro_dsp_valuehl 
c817				endm 
# End of macro FORTH_DSP_VALUEHL
c817			 
c817 e5					push hl     ; start char 
c818			 
c818					FORTH_DSP_POP 
c818 cd 80 9c			call macro_forth_dsp_pop 
c81b				endm 
# End of macro FORTH_DSP_POP
c81b			 
c81b			 
c81b					FORTH_DSP_VALUE 
c81b cd b1 9b			call macro_forth_dsp_value 
c81e				endm 
# End of macro FORTH_DSP_VALUE
c81e			 
c81e d1					pop de    ; get start post offset 
c81f			 
c81f 19					add hl, de    ; starting offset 
c820			 
c820 c1					pop bc 
c821 c5					push bc      ; grab size of string 
c822			 
c822 e5					push hl    ; save string start  
c823			 
c823 26 00				ld h, 0 
c825 69					ld l, c 
c826 23					inc hl 
c827 23					inc hl 
c828			 
c828 cd a7 90				call malloc 
c82b				if DEBUG_FORTH_MALLOC_GUARD 
c82b cc 49 d3				call z,malloc_error 
c82e				endif 
c82e			 
c82e eb					ex de, hl      ; save malloc area for string copy 
c82f e1					pop hl    ; get back source 
c830 c1					pop bc    ; get length of string back 
c831			 
c831 d5					push de    ; save malloc area for after we push 
c832 ed b0				ldir     ; copy substr 
c834			 
c834			 
c834 eb					ex de, hl 
c835			;		ld a, 0 
c835 36 00				ld (hl), 0   ; term substr 
c837			 
c837					 
c837 e1					pop hl    ; get malloc so we can push it 
c838 e5					push hl   ; save so we can free it afterwards 
c839			 
c839 cd 36 9a				call forth_push_str 
c83c			 
c83c e1					pop hl 
c83d cd 71 91				call free 
c840			 
c840					 
c840					 
c840			 
c840			 
c840					NEXTW 
c840 cd 68 ee			call parse_vector 
c843 c3 af 9d			jp macro_next 
c846				endm 
# End of macro NEXTW
c846			 
c846			.LEFT: 
c846				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c846 48				db WORD_SYS_CORE+52             
c847 8a c8			dw .RIGHT            
c849 05				db 4 + 1 
c84a .. 00			db "LEFT",0              
c84f				endm 
# End of macro CWHEAD
c84f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
c84f					if DEBUG_FORTH_WORDS_KEY 
c84f						DMARK "LEF" 
c84f f5				push af  
c850 3a 64 c8			ld a, (.dmark)  
c853 32 5e ee			ld (debug_mark),a  
c856 3a 65 c8			ld a, (.dmark+1)  
c859 32 5f ee			ld (debug_mark+1),a  
c85c 3a 66 c8			ld a, (.dmark+2)  
c85f 32 60 ee			ld (debug_mark+2),a  
c862 18 03			jr .pastdmark  
c864 ..			.dmark: db "LEF"  
c867 f1			.pastdmark: pop af  
c868			endm  
# End of macro DMARK
c868						CALLMONITOR 
c868 cd 6b ee			call debug_vector  
c86b				endm  
# End of macro CALLMONITOR
c86b					endif 
c86b			 
c86b					 
c86b			; TODO check string type 
c86b					FORTH_DSP_VALUEHL 
c86b cd c8 9b			call macro_dsp_valuehl 
c86e				endm 
# End of macro FORTH_DSP_VALUEHL
c86e			 
c86e e5					push hl      ; string length 
c86f			 
c86f					FORTH_DSP_POP 
c86f cd 80 9c			call macro_forth_dsp_pop 
c872				endm 
# End of macro FORTH_DSP_POP
c872			 
c872					FORTH_DSP_VALUEHL 
c872 cd c8 9b			call macro_dsp_valuehl 
c875				endm 
# End of macro FORTH_DSP_VALUEHL
c875			 
c875 c1					pop bc 
c876			 
c876 11 b4 e2				ld de, scratch 
c879 ed b0				ldir 
c87b 3e 00				ld a, 0 
c87d 12					ld (de), a 
c87e					 
c87e 21 b4 e2				ld hl, scratch 
c881 cd 36 9a				call forth_push_str 
c884			 
c884					NEXTW 
c884 cd 68 ee			call parse_vector 
c887 c3 af 9d			jp macro_next 
c88a				endm 
# End of macro NEXTW
c88a			.RIGHT: 
c88a				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c88a 48				db WORD_SYS_CORE+52             
c88b 4b c9			dw .STR2NUM            
c88d 06				db 5 + 1 
c88e .. 00			db "RIGHT",0              
c894				endm 
# End of macro CWHEAD
c894			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
c894					if DEBUG_FORTH_WORDS_KEY 
c894						DMARK "RIG" 
c894 f5				push af  
c895 3a a9 c8			ld a, (.dmark)  
c898 32 5e ee			ld (debug_mark),a  
c89b 3a aa c8			ld a, (.dmark+1)  
c89e 32 5f ee			ld (debug_mark+1),a  
c8a1 3a ab c8			ld a, (.dmark+2)  
c8a4 32 60 ee			ld (debug_mark+2),a  
c8a7 18 03			jr .pastdmark  
c8a9 ..			.dmark: db "RIG"  
c8ac f1			.pastdmark: pop af  
c8ad			endm  
# End of macro DMARK
c8ad						CALLMONITOR 
c8ad cd 6b ee			call debug_vector  
c8b0				endm  
# End of macro CALLMONITOR
c8b0					endif 
c8b0			 
c8b0			; TODO check string type 
c8b0					FORTH_DSP_VALUEHL 
c8b0 cd c8 9b			call macro_dsp_valuehl 
c8b3				endm 
# End of macro FORTH_DSP_VALUEHL
c8b3			 
c8b3 e5					push hl      ; string length 
c8b4			 
c8b4					FORTH_DSP_POP 
c8b4 cd 80 9c			call macro_forth_dsp_pop 
c8b7				endm 
# End of macro FORTH_DSP_POP
c8b7			 
c8b7					FORTH_DSP_VALUEHL 
c8b7 cd c8 9b			call macro_dsp_valuehl 
c8ba				endm 
# End of macro FORTH_DSP_VALUEHL
c8ba			 
c8ba					if DEBUG_FORTH_WORDS 
c8ba						DMARK "RI1" 
c8ba f5				push af  
c8bb 3a cf c8			ld a, (.dmark)  
c8be 32 5e ee			ld (debug_mark),a  
c8c1 3a d0 c8			ld a, (.dmark+1)  
c8c4 32 5f ee			ld (debug_mark+1),a  
c8c7 3a d1 c8			ld a, (.dmark+2)  
c8ca 32 60 ee			ld (debug_mark+2),a  
c8cd 18 03			jr .pastdmark  
c8cf ..			.dmark: db "RI1"  
c8d2 f1			.pastdmark: pop af  
c8d3			endm  
# End of macro DMARK
c8d3						CALLMONITOR 
c8d3 cd 6b ee			call debug_vector  
c8d6				endm  
# End of macro CALLMONITOR
c8d6					endif 
c8d6					; from the pointer to string get to the end of string 
c8d6			 
c8d6 01 ff 00				ld bc, 255 
c8d9 3e 00				ld a, 0 
c8db ed b1				cpir 
c8dd 2b					dec hl 
c8de			 
c8de					;  
c8de			 
c8de					if DEBUG_FORTH_WORDS 
c8de						DMARK "RI2" 
c8de f5				push af  
c8df 3a f3 c8			ld a, (.dmark)  
c8e2 32 5e ee			ld (debug_mark),a  
c8e5 3a f4 c8			ld a, (.dmark+1)  
c8e8 32 5f ee			ld (debug_mark+1),a  
c8eb 3a f5 c8			ld a, (.dmark+2)  
c8ee 32 60 ee			ld (debug_mark+2),a  
c8f1 18 03			jr .pastdmark  
c8f3 ..			.dmark: db "RI2"  
c8f6 f1			.pastdmark: pop af  
c8f7			endm  
# End of macro DMARK
c8f7						CALLMONITOR 
c8f7 cd 6b ee			call debug_vector  
c8fa				endm  
# End of macro CALLMONITOR
c8fa					endif 
c8fa			 
c8fa c1					pop bc    ;  length of string to copy 
c8fb			 
c8fb 79					ld a, c 
c8fc eb					ex de, hl 
c8fd 21 b4 e2				ld hl, scratch  
c900 cd db 8c				call addatohl 
c903			 
c903 eb					ex de, hl 
c904			 
c904					if DEBUG_FORTH_WORDS 
c904						DMARK "RI3" 
c904 f5				push af  
c905 3a 19 c9			ld a, (.dmark)  
c908 32 5e ee			ld (debug_mark),a  
c90b 3a 1a c9			ld a, (.dmark+1)  
c90e 32 5f ee			ld (debug_mark+1),a  
c911 3a 1b c9			ld a, (.dmark+2)  
c914 32 60 ee			ld (debug_mark+2),a  
c917 18 03			jr .pastdmark  
c919 ..			.dmark: db "RI3"  
c91c f1			.pastdmark: pop af  
c91d			endm  
# End of macro DMARK
c91d						CALLMONITOR 
c91d cd 6b ee			call debug_vector  
c920				endm  
# End of macro CALLMONITOR
c920					endif 
c920			 
c920 03					inc bc 
c921 ed b8				lddr 
c923					 
c923 21 b4 e2				ld hl, scratch 
c926					if DEBUG_FORTH_WORDS 
c926						DMARK "RI4" 
c926 f5				push af  
c927 3a 3b c9			ld a, (.dmark)  
c92a 32 5e ee			ld (debug_mark),a  
c92d 3a 3c c9			ld a, (.dmark+1)  
c930 32 5f ee			ld (debug_mark+1),a  
c933 3a 3d c9			ld a, (.dmark+2)  
c936 32 60 ee			ld (debug_mark+2),a  
c939 18 03			jr .pastdmark  
c93b ..			.dmark: db "RI4"  
c93e f1			.pastdmark: pop af  
c93f			endm  
# End of macro DMARK
c93f						CALLMONITOR 
c93f cd 6b ee			call debug_vector  
c942				endm  
# End of macro CALLMONITOR
c942					endif 
c942 cd 36 9a				call forth_push_str 
c945			 
c945			 
c945					NEXTW 
c945 cd 68 ee			call parse_vector 
c948 c3 af 9d			jp macro_next 
c94b				endm 
# End of macro NEXTW
c94b			 
c94b			 
c94b			.STR2NUM: 
c94b				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c94b 48				db WORD_SYS_CORE+52             
c94c da c9			dw .NUM2STR            
c94e 08				db 7 + 1 
c94f .. 00			db "STR2NUM",0              
c957				endm 
# End of macro CWHEAD
c957			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c957			 
c957			 
c957			; TODO STR type check to do 
c957					if DEBUG_FORTH_WORDS_KEY 
c957						DMARK "S2N" 
c957 f5				push af  
c958 3a 6c c9			ld a, (.dmark)  
c95b 32 5e ee			ld (debug_mark),a  
c95e 3a 6d c9			ld a, (.dmark+1)  
c961 32 5f ee			ld (debug_mark+1),a  
c964 3a 6e c9			ld a, (.dmark+2)  
c967 32 60 ee			ld (debug_mark+2),a  
c96a 18 03			jr .pastdmark  
c96c ..			.dmark: db "S2N"  
c96f f1			.pastdmark: pop af  
c970			endm  
# End of macro DMARK
c970						CALLMONITOR 
c970 cd 6b ee			call debug_vector  
c973				endm  
# End of macro CALLMONITOR
c973					endif 
c973			 
c973					;FORTH_DSP 
c973					FORTH_DSP_VALUE 
c973 cd b1 9b			call macro_forth_dsp_value 
c976				endm 
# End of macro FORTH_DSP_VALUE
c976					;inc hl 
c976			 
c976 eb					ex de, hl 
c977					if DEBUG_FORTH_WORDS 
c977						DMARK "S2a" 
c977 f5				push af  
c978 3a 8c c9			ld a, (.dmark)  
c97b 32 5e ee			ld (debug_mark),a  
c97e 3a 8d c9			ld a, (.dmark+1)  
c981 32 5f ee			ld (debug_mark+1),a  
c984 3a 8e c9			ld a, (.dmark+2)  
c987 32 60 ee			ld (debug_mark+2),a  
c98a 18 03			jr .pastdmark  
c98c ..			.dmark: db "S2a"  
c98f f1			.pastdmark: pop af  
c990			endm  
# End of macro DMARK
c990						CALLMONITOR 
c990 cd 6b ee			call debug_vector  
c993				endm  
# End of macro CALLMONITOR
c993					endif 
c993 cd ca 8f				call string_to_uint16 
c996			 
c996					if DEBUG_FORTH_WORDS 
c996						DMARK "S2b" 
c996 f5				push af  
c997 3a ab c9			ld a, (.dmark)  
c99a 32 5e ee			ld (debug_mark),a  
c99d 3a ac c9			ld a, (.dmark+1)  
c9a0 32 5f ee			ld (debug_mark+1),a  
c9a3 3a ad c9			ld a, (.dmark+2)  
c9a6 32 60 ee			ld (debug_mark+2),a  
c9a9 18 03			jr .pastdmark  
c9ab ..			.dmark: db "S2b"  
c9ae f1			.pastdmark: pop af  
c9af			endm  
# End of macro DMARK
c9af						CALLMONITOR 
c9af cd 6b ee			call debug_vector  
c9b2				endm  
# End of macro CALLMONITOR
c9b2					endif 
c9b2			;		push hl 
c9b2					FORTH_DSP_POP 
c9b2 cd 80 9c			call macro_forth_dsp_pop 
c9b5				endm 
# End of macro FORTH_DSP_POP
c9b5			;		pop hl 
c9b5					 
c9b5					if DEBUG_FORTH_WORDS 
c9b5						DMARK "S2b" 
c9b5 f5				push af  
c9b6 3a ca c9			ld a, (.dmark)  
c9b9 32 5e ee			ld (debug_mark),a  
c9bc 3a cb c9			ld a, (.dmark+1)  
c9bf 32 5f ee			ld (debug_mark+1),a  
c9c2 3a cc c9			ld a, (.dmark+2)  
c9c5 32 60 ee			ld (debug_mark+2),a  
c9c8 18 03			jr .pastdmark  
c9ca ..			.dmark: db "S2b"  
c9cd f1			.pastdmark: pop af  
c9ce			endm  
# End of macro DMARK
c9ce						CALLMONITOR 
c9ce cd 6b ee			call debug_vector  
c9d1				endm  
# End of macro CALLMONITOR
c9d1					endif 
c9d1 cd cc 99				call forth_push_numhl	 
c9d4			 
c9d4				 
c9d4				       NEXTW 
c9d4 cd 68 ee			call parse_vector 
c9d7 c3 af 9d			jp macro_next 
c9da				endm 
# End of macro NEXTW
c9da			.NUM2STR: 
c9da				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c9da 48				db WORD_SYS_CORE+52             
c9db 6f ca			dw .CONCAT            
c9dd 08				db 7 + 1 
c9de .. 00			db "NUM2STR",0              
c9e6				endm 
# End of macro CWHEAD
c9e6			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
c9e6			 
c9e6			;		; malloc a string to target 
c9e6			;		ld hl, 10     ; TODO max string size should be fine 
c9e6			;		call malloc 
c9e6			;		push hl    ; save malloc location 
c9e6			; 
c9e6			; 
c9e6			;; TODO check int type 
c9e6					if DEBUG_FORTH_WORDS_KEY 
c9e6						DMARK "N2S" 
c9e6 f5				push af  
c9e7 3a fb c9			ld a, (.dmark)  
c9ea 32 5e ee			ld (debug_mark),a  
c9ed 3a fc c9			ld a, (.dmark+1)  
c9f0 32 5f ee			ld (debug_mark+1),a  
c9f3 3a fd c9			ld a, (.dmark+2)  
c9f6 32 60 ee			ld (debug_mark+2),a  
c9f9 18 03			jr .pastdmark  
c9fb ..			.dmark: db "N2S"  
c9fe f1			.pastdmark: pop af  
c9ff			endm  
# End of macro DMARK
c9ff						CALLMONITOR 
c9ff cd 6b ee			call debug_vector  
ca02				endm  
# End of macro CALLMONITOR
ca02					endif 
ca02			 
ca02					FORTH_DSP_VALUEHL 
ca02 cd c8 9b			call macro_dsp_valuehl 
ca05				endm 
# End of macro FORTH_DSP_VALUEHL
ca05			 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "NS1" 
ca05 f5				push af  
ca06 3a 1a ca			ld a, (.dmark)  
ca09 32 5e ee			ld (debug_mark),a  
ca0c 3a 1b ca			ld a, (.dmark+1)  
ca0f 32 5f ee			ld (debug_mark+1),a  
ca12 3a 1c ca			ld a, (.dmark+2)  
ca15 32 60 ee			ld (debug_mark+2),a  
ca18 18 03			jr .pastdmark  
ca1a ..			.dmark: db "NS1"  
ca1d f1			.pastdmark: pop af  
ca1e			endm  
# End of macro DMARK
ca1e						CALLMONITOR 
ca1e cd 6b ee			call debug_vector  
ca21				endm  
# End of macro CALLMONITOR
ca21					endif 
ca21					FORTH_DSP_POP 
ca21 cd 80 9c			call macro_forth_dsp_pop 
ca24				endm 
# End of macro FORTH_DSP_POP
ca24			 
ca24 eb					ex de, hl 
ca25 21 b4 e2				ld hl, scratch 
ca28					if DEBUG_FORTH_WORDS 
ca28						DMARK "NS2" 
ca28 f5				push af  
ca29 3a 3d ca			ld a, (.dmark)  
ca2c 32 5e ee			ld (debug_mark),a  
ca2f 3a 3e ca			ld a, (.dmark+1)  
ca32 32 5f ee			ld (debug_mark+1),a  
ca35 3a 3f ca			ld a, (.dmark+2)  
ca38 32 60 ee			ld (debug_mark+2),a  
ca3b 18 03			jr .pastdmark  
ca3d ..			.dmark: db "NS2"  
ca40 f1			.pastdmark: pop af  
ca41			endm  
# End of macro DMARK
ca41						CALLMONITOR 
ca41 cd 6b ee			call debug_vector  
ca44				endm  
# End of macro CALLMONITOR
ca44					endif 
ca44 cd e2 8f				call uitoa_16 
ca47 21 b4 e2				ld hl, scratch 
ca4a					if DEBUG_FORTH_WORDS 
ca4a						DMARK "NS3" 
ca4a f5				push af  
ca4b 3a 5f ca			ld a, (.dmark)  
ca4e 32 5e ee			ld (debug_mark),a  
ca51 3a 60 ca			ld a, (.dmark+1)  
ca54 32 5f ee			ld (debug_mark+1),a  
ca57 3a 61 ca			ld a, (.dmark+2)  
ca5a 32 60 ee			ld (debug_mark+2),a  
ca5d 18 03			jr .pastdmark  
ca5f ..			.dmark: db "NS3"  
ca62 f1			.pastdmark: pop af  
ca63			endm  
# End of macro DMARK
ca63						CALLMONITOR 
ca63 cd 6b ee			call debug_vector  
ca66				endm  
# End of macro CALLMONITOR
ca66					endif 
ca66 cd 36 9a				call forth_push_str 
ca69			;		ld a, l 
ca69			;		call DispAToASCII   
ca69			;;TODO need to chage above call to dump into string 
ca69			; 
ca69			; 
ca69			 
ca69				       NEXTW 
ca69 cd 68 ee			call parse_vector 
ca6c c3 af 9d			jp macro_next 
ca6f				endm 
# End of macro NEXTW
ca6f			 
ca6f			.CONCAT: 
ca6f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
ca6f 48				db WORD_SYS_CORE+52             
ca70 25 cb			dw .FIND            
ca72 07				db 6 + 1 
ca73 .. 00			db "CONCAT",0              
ca7a				endm 
# End of macro CWHEAD
ca7a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
ca7a			 
ca7a			; TODO check string type 
ca7a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
ca7a			 
ca7a					if DEBUG_FORTH_WORDS_KEY 
ca7a						DMARK "CON" 
ca7a f5				push af  
ca7b 3a 8f ca			ld a, (.dmark)  
ca7e 32 5e ee			ld (debug_mark),a  
ca81 3a 90 ca			ld a, (.dmark+1)  
ca84 32 5f ee			ld (debug_mark+1),a  
ca87 3a 91 ca			ld a, (.dmark+2)  
ca8a 32 60 ee			ld (debug_mark+2),a  
ca8d 18 03			jr .pastdmark  
ca8f ..			.dmark: db "CON"  
ca92 f1			.pastdmark: pop af  
ca93			endm  
# End of macro DMARK
ca93						CALLMONITOR 
ca93 cd 6b ee			call debug_vector  
ca96				endm  
# End of macro CALLMONITOR
ca96					endif 
ca96			 
ca96			 
ca96					FORTH_DSP_VALUE 
ca96 cd b1 9b			call macro_forth_dsp_value 
ca99				endm 
# End of macro FORTH_DSP_VALUE
ca99 e5					push hl   ; s2 
ca9a			 
ca9a					FORTH_DSP_POP 
ca9a cd 80 9c			call macro_forth_dsp_pop 
ca9d				endm 
# End of macro FORTH_DSP_POP
ca9d			 
ca9d					FORTH_DSP_VALUE 
ca9d cd b1 9b			call macro_forth_dsp_value 
caa0				endm 
# End of macro FORTH_DSP_VALUE
caa0			 
caa0 e5					push hl   ; s1 
caa1			 
caa1					FORTH_DSP_POP 
caa1 cd 80 9c			call macro_forth_dsp_pop 
caa4				endm 
# End of macro FORTH_DSP_POP
caa4					 
caa4			 
caa4					; copy s1 
caa4			 
caa4				 
caa4					; save ptr 
caa4 e1					pop hl  
caa5 e5					push hl 
caa6 3e 00				ld a, 0 
caa8 cd 3e 90				call strlent 
caab					;inc hl    ; zer0 
caab 06 00				ld b, 0 
caad 4d					ld c, l 
caae e1					pop hl		 
caaf 11 b4 e2				ld de, scratch	 
cab2					if DEBUG_FORTH_WORDS 
cab2						DMARK "CO1" 
cab2 f5				push af  
cab3 3a c7 ca			ld a, (.dmark)  
cab6 32 5e ee			ld (debug_mark),a  
cab9 3a c8 ca			ld a, (.dmark+1)  
cabc 32 5f ee			ld (debug_mark+1),a  
cabf 3a c9 ca			ld a, (.dmark+2)  
cac2 32 60 ee			ld (debug_mark+2),a  
cac5 18 03			jr .pastdmark  
cac7 ..			.dmark: db "CO1"  
caca f1			.pastdmark: pop af  
cacb			endm  
# End of macro DMARK
cacb						CALLMONITOR 
cacb cd 6b ee			call debug_vector  
cace				endm  
# End of macro CALLMONITOR
cace					endif 
cace ed b0				ldir 
cad0			 
cad0 e1					pop hl 
cad1 e5					push hl 
cad2 d5					push de 
cad3			 
cad3			 
cad3 3e 00				ld a, 0 
cad5 cd 3e 90				call strlent 
cad8 23					inc hl    ; zer0 
cad9 23					inc hl 
cada 06 00				ld b, 0 
cadc 4d					ld c, l 
cadd d1					pop de 
cade e1					pop hl		 
cadf					if DEBUG_FORTH_WORDS 
cadf						DMARK "CO2" 
cadf f5				push af  
cae0 3a f4 ca			ld a, (.dmark)  
cae3 32 5e ee			ld (debug_mark),a  
cae6 3a f5 ca			ld a, (.dmark+1)  
cae9 32 5f ee			ld (debug_mark+1),a  
caec 3a f6 ca			ld a, (.dmark+2)  
caef 32 60 ee			ld (debug_mark+2),a  
caf2 18 03			jr .pastdmark  
caf4 ..			.dmark: db "CO2"  
caf7 f1			.pastdmark: pop af  
caf8			endm  
# End of macro DMARK
caf8						CALLMONITOR 
caf8 cd 6b ee			call debug_vector  
cafb				endm  
# End of macro CALLMONITOR
cafb					endif 
cafb ed b0				ldir 
cafd			 
cafd			 
cafd			 
cafd 21 b4 e2				ld hl, scratch 
cb00					if DEBUG_FORTH_WORDS 
cb00						DMARK "CO5" 
cb00 f5				push af  
cb01 3a 15 cb			ld a, (.dmark)  
cb04 32 5e ee			ld (debug_mark),a  
cb07 3a 16 cb			ld a, (.dmark+1)  
cb0a 32 5f ee			ld (debug_mark+1),a  
cb0d 3a 17 cb			ld a, (.dmark+2)  
cb10 32 60 ee			ld (debug_mark+2),a  
cb13 18 03			jr .pastdmark  
cb15 ..			.dmark: db "CO5"  
cb18 f1			.pastdmark: pop af  
cb19			endm  
# End of macro DMARK
cb19						CALLMONITOR 
cb19 cd 6b ee			call debug_vector  
cb1c				endm  
# End of macro CALLMONITOR
cb1c					endif 
cb1c			 
cb1c cd 36 9a				call forth_push_str 
cb1f			 
cb1f			 
cb1f			 
cb1f			 
cb1f				       NEXTW 
cb1f cd 68 ee			call parse_vector 
cb22 c3 af 9d			jp macro_next 
cb25				endm 
# End of macro NEXTW
cb25			 
cb25			 
cb25			.FIND: 
cb25				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
cb25 4b				db WORD_SYS_CORE+55             
cb26 e5 cb			dw .LEN            
cb28 05				db 4 + 1 
cb29 .. 00			db "FIND",0              
cb2e				endm 
# End of macro CWHEAD
cb2e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
cb2e			 
cb2e					if DEBUG_FORTH_WORDS_KEY 
cb2e						DMARK "FND" 
cb2e f5				push af  
cb2f 3a 43 cb			ld a, (.dmark)  
cb32 32 5e ee			ld (debug_mark),a  
cb35 3a 44 cb			ld a, (.dmark+1)  
cb38 32 5f ee			ld (debug_mark+1),a  
cb3b 3a 45 cb			ld a, (.dmark+2)  
cb3e 32 60 ee			ld (debug_mark+2),a  
cb41 18 03			jr .pastdmark  
cb43 ..			.dmark: db "FND"  
cb46 f1			.pastdmark: pop af  
cb47			endm  
# End of macro DMARK
cb47						CALLMONITOR 
cb47 cd 6b ee			call debug_vector  
cb4a				endm  
# End of macro CALLMONITOR
cb4a					endif 
cb4a			 
cb4a			; TODO check string type 
cb4a					FORTH_DSP_VALUE 
cb4a cd b1 9b			call macro_forth_dsp_value 
cb4d				endm 
# End of macro FORTH_DSP_VALUE
cb4d			 
cb4d e5					push hl    
cb4e 7e					ld a,(hl)    ; char to find   
cb4f			; TODO change char to substr 
cb4f			 
cb4f f5					push af 
cb50					 
cb50			 
cb50			 
cb50					if DEBUG_FORTH_WORDS 
cb50						DMARK "FN1" 
cb50 f5				push af  
cb51 3a 65 cb			ld a, (.dmark)  
cb54 32 5e ee			ld (debug_mark),a  
cb57 3a 66 cb			ld a, (.dmark+1)  
cb5a 32 5f ee			ld (debug_mark+1),a  
cb5d 3a 67 cb			ld a, (.dmark+2)  
cb60 32 60 ee			ld (debug_mark+2),a  
cb63 18 03			jr .pastdmark  
cb65 ..			.dmark: db "FN1"  
cb68 f1			.pastdmark: pop af  
cb69			endm  
# End of macro DMARK
cb69						CALLMONITOR 
cb69 cd 6b ee			call debug_vector  
cb6c				endm  
# End of macro CALLMONITOR
cb6c					endif 
cb6c			 
cb6c					FORTH_DSP_POP 
cb6c cd 80 9c			call macro_forth_dsp_pop 
cb6f				endm 
# End of macro FORTH_DSP_POP
cb6f			 
cb6f					; string to search 
cb6f			 
cb6f					FORTH_DSP_VALUE 
cb6f cd b1 9b			call macro_forth_dsp_value 
cb72				endm 
# End of macro FORTH_DSP_VALUE
cb72			 
cb72 d1					pop de  ; d is char to find  
cb73			 
cb73					if DEBUG_FORTH_WORDS 
cb73						DMARK "FN2" 
cb73 f5				push af  
cb74 3a 88 cb			ld a, (.dmark)  
cb77 32 5e ee			ld (debug_mark),a  
cb7a 3a 89 cb			ld a, (.dmark+1)  
cb7d 32 5f ee			ld (debug_mark+1),a  
cb80 3a 8a cb			ld a, (.dmark+2)  
cb83 32 60 ee			ld (debug_mark+2),a  
cb86 18 03			jr .pastdmark  
cb88 ..			.dmark: db "FN2"  
cb8b f1			.pastdmark: pop af  
cb8c			endm  
# End of macro DMARK
cb8c						CALLMONITOR 
cb8c cd 6b ee			call debug_vector  
cb8f				endm  
# End of macro CALLMONITOR
cb8f					endif 
cb8f					 
cb8f 01 00 00				ld bc, 0 
cb92 7e			.findchar:      ld a,(hl) 
cb93			;		cp 0   		 
cb93 b7					or a 
cb94 28 27				jr z, .finddone     
cb96 ba					cp d 
cb97 28 20				jr z, .foundchar 
cb99 03					inc bc 
cb9a 23					inc hl 
cb9b					if DEBUG_FORTH_WORDS 
cb9b						DMARK "FN3" 
cb9b f5				push af  
cb9c 3a b0 cb			ld a, (.dmark)  
cb9f 32 5e ee			ld (debug_mark),a  
cba2 3a b1 cb			ld a, (.dmark+1)  
cba5 32 5f ee			ld (debug_mark+1),a  
cba8 3a b2 cb			ld a, (.dmark+2)  
cbab 32 60 ee			ld (debug_mark+2),a  
cbae 18 03			jr .pastdmark  
cbb0 ..			.dmark: db "FN3"  
cbb3 f1			.pastdmark: pop af  
cbb4			endm  
# End of macro DMARK
cbb4						CALLMONITOR 
cbb4 cd 6b ee			call debug_vector  
cbb7				endm  
# End of macro CALLMONITOR
cbb7					endif 
cbb7 18 d9				jr .findchar 
cbb9			 
cbb9			 
cbb9 c5			.foundchar:	push bc 
cbba e1					pop hl 
cbbb 18 03				jr .findexit 
cbbd			 
cbbd			 
cbbd							 
cbbd			 
cbbd			.finddone:     ; got to end of string with no find 
cbbd 21 00 00				ld hl, 0 
cbc0			.findexit: 
cbc0			 
cbc0					if DEBUG_FORTH_WORDS 
cbc0						DMARK "FNd" 
cbc0 f5				push af  
cbc1 3a d5 cb			ld a, (.dmark)  
cbc4 32 5e ee			ld (debug_mark),a  
cbc7 3a d6 cb			ld a, (.dmark+1)  
cbca 32 5f ee			ld (debug_mark+1),a  
cbcd 3a d7 cb			ld a, (.dmark+2)  
cbd0 32 60 ee			ld (debug_mark+2),a  
cbd3 18 03			jr .pastdmark  
cbd5 ..			.dmark: db "FNd"  
cbd8 f1			.pastdmark: pop af  
cbd9			endm  
# End of macro DMARK
cbd9						CALLMONITOR 
cbd9 cd 6b ee			call debug_vector  
cbdc				endm  
# End of macro CALLMONITOR
cbdc					endif 
cbdc cd cc 99			call forth_push_numhl 
cbdf			 
cbdf				       NEXTW 
cbdf cd 68 ee			call parse_vector 
cbe2 c3 af 9d			jp macro_next 
cbe5				endm 
# End of macro NEXTW
cbe5			 
cbe5			.LEN: 
cbe5				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
cbe5 4c				db WORD_SYS_CORE+56             
cbe6 52 cc			dw .ASC            
cbe8 06				db 5 + 1 
cbe9 .. 00			db "COUNT",0              
cbef				endm 
# End of macro CWHEAD
cbef			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
cbef			 
cbef					if DEBUG_FORTH_WORDS_KEY 
cbef						DMARK "CNT" 
cbef f5				push af  
cbf0 3a 04 cc			ld a, (.dmark)  
cbf3 32 5e ee			ld (debug_mark),a  
cbf6 3a 05 cc			ld a, (.dmark+1)  
cbf9 32 5f ee			ld (debug_mark+1),a  
cbfc 3a 06 cc			ld a, (.dmark+2)  
cbff 32 60 ee			ld (debug_mark+2),a  
cc02 18 03			jr .pastdmark  
cc04 ..			.dmark: db "CNT"  
cc07 f1			.pastdmark: pop af  
cc08			endm  
# End of macro DMARK
cc08						CALLMONITOR 
cc08 cd 6b ee			call debug_vector  
cc0b				endm  
# End of macro CALLMONITOR
cc0b					endif 
cc0b			; TODO check string type 
cc0b					FORTH_DSP_VALUE 
cc0b cd b1 9b			call macro_forth_dsp_value 
cc0e				endm 
# End of macro FORTH_DSP_VALUE
cc0e			 
cc0e			 
cc0e					if DEBUG_FORTH_WORDS 
cc0e						DMARK "CN?" 
cc0e f5				push af  
cc0f 3a 23 cc			ld a, (.dmark)  
cc12 32 5e ee			ld (debug_mark),a  
cc15 3a 24 cc			ld a, (.dmark+1)  
cc18 32 5f ee			ld (debug_mark+1),a  
cc1b 3a 25 cc			ld a, (.dmark+2)  
cc1e 32 60 ee			ld (debug_mark+2),a  
cc21 18 03			jr .pastdmark  
cc23 ..			.dmark: db "CN?"  
cc26 f1			.pastdmark: pop af  
cc27			endm  
# End of macro DMARK
cc27						CALLMONITOR 
cc27 cd 6b ee			call debug_vector  
cc2a				endm  
# End of macro CALLMONITOR
cc2a					endif 
cc2a cd 33 90				call strlenz 
cc2d					if DEBUG_FORTH_WORDS 
cc2d						DMARK "CNl" 
cc2d f5				push af  
cc2e 3a 42 cc			ld a, (.dmark)  
cc31 32 5e ee			ld (debug_mark),a  
cc34 3a 43 cc			ld a, (.dmark+1)  
cc37 32 5f ee			ld (debug_mark+1),a  
cc3a 3a 44 cc			ld a, (.dmark+2)  
cc3d 32 60 ee			ld (debug_mark+2),a  
cc40 18 03			jr .pastdmark  
cc42 ..			.dmark: db "CNl"  
cc45 f1			.pastdmark: pop af  
cc46			endm  
# End of macro DMARK
cc46						CALLMONITOR 
cc46 cd 6b ee			call debug_vector  
cc49				endm  
# End of macro CALLMONITOR
cc49					endif 
cc49			 
cc49 cd cc 99				call forth_push_numhl 
cc4c			 
cc4c			 
cc4c			 
cc4c				       NEXTW 
cc4c cd 68 ee			call parse_vector 
cc4f c3 af 9d			jp macro_next 
cc52				endm 
# End of macro NEXTW
cc52			.ASC: 
cc52				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
cc52 4d				db WORD_SYS_CORE+57             
cc53 c3 cc			dw .CHR            
cc55 04				db 3 + 1 
cc56 .. 00			db "ASC",0              
cc5a				endm 
# End of macro CWHEAD
cc5a			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
cc5a					if DEBUG_FORTH_WORDS_KEY 
cc5a						DMARK "ASC" 
cc5a f5				push af  
cc5b 3a 6f cc			ld a, (.dmark)  
cc5e 32 5e ee			ld (debug_mark),a  
cc61 3a 70 cc			ld a, (.dmark+1)  
cc64 32 5f ee			ld (debug_mark+1),a  
cc67 3a 71 cc			ld a, (.dmark+2)  
cc6a 32 60 ee			ld (debug_mark+2),a  
cc6d 18 03			jr .pastdmark  
cc6f ..			.dmark: db "ASC"  
cc72 f1			.pastdmark: pop af  
cc73			endm  
# End of macro DMARK
cc73						CALLMONITOR 
cc73 cd 6b ee			call debug_vector  
cc76				endm  
# End of macro CALLMONITOR
cc76					endif 
cc76					FORTH_DSP_VALUE 
cc76 cd b1 9b			call macro_forth_dsp_value 
cc79				endm 
# End of macro FORTH_DSP_VALUE
cc79					;v5 FORTH_DSP_VALUE 
cc79			;		inc hl      ; now at start of numeric as string 
cc79			 
cc79 e5					push hl 
cc7a			 
cc7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc7a cd 80 9c			call macro_forth_dsp_pop 
cc7d				endm 
# End of macro FORTH_DSP_POP
cc7d			 
cc7d e1					pop hl 
cc7e			 
cc7e					if DEBUG_FORTH_WORDS 
cc7e						DMARK "AS1" 
cc7e f5				push af  
cc7f 3a 93 cc			ld a, (.dmark)  
cc82 32 5e ee			ld (debug_mark),a  
cc85 3a 94 cc			ld a, (.dmark+1)  
cc88 32 5f ee			ld (debug_mark+1),a  
cc8b 3a 95 cc			ld a, (.dmark+2)  
cc8e 32 60 ee			ld (debug_mark+2),a  
cc91 18 03			jr .pastdmark  
cc93 ..			.dmark: db "AS1"  
cc96 f1			.pastdmark: pop af  
cc97			endm  
# End of macro DMARK
cc97						CALLMONITOR 
cc97 cd 6b ee			call debug_vector  
cc9a				endm  
# End of macro CALLMONITOR
cc9a					endif 
cc9a					; push the content of a onto the stack as a value 
cc9a			 
cc9a 7e					ld a,(hl)   ; get char 
cc9b 26 00				ld h,0 
cc9d 6f					ld l,a 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "AS2" 
cc9e f5				push af  
cc9f 3a b3 cc			ld a, (.dmark)  
cca2 32 5e ee			ld (debug_mark),a  
cca5 3a b4 cc			ld a, (.dmark+1)  
cca8 32 5f ee			ld (debug_mark+1),a  
ccab 3a b5 cc			ld a, (.dmark+2)  
ccae 32 60 ee			ld (debug_mark+2),a  
ccb1 18 03			jr .pastdmark  
ccb3 ..			.dmark: db "AS2"  
ccb6 f1			.pastdmark: pop af  
ccb7			endm  
# End of macro DMARK
ccb7						CALLMONITOR 
ccb7 cd 6b ee			call debug_vector  
ccba				endm  
# End of macro CALLMONITOR
ccba					endif 
ccba cd cc 99				call forth_push_numhl 
ccbd			 
ccbd				       NEXTW 
ccbd cd 68 ee			call parse_vector 
ccc0 c3 af 9d			jp macro_next 
ccc3				endm 
# End of macro NEXTW
ccc3			 
ccc3			.CHR: 
ccc3				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
ccc3 4d				db WORD_SYS_CORE+57             
ccc4 02 cd			dw .ENDSTR            
ccc6 04				db 3 + 1 
ccc7 .. 00			db "CHR",0              
cccb				endm 
# End of macro CWHEAD
cccb			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
cccb					if DEBUG_FORTH_WORDS_KEY 
cccb						DMARK "CHR" 
cccb f5				push af  
cccc 3a e0 cc			ld a, (.dmark)  
cccf 32 5e ee			ld (debug_mark),a  
ccd2 3a e1 cc			ld a, (.dmark+1)  
ccd5 32 5f ee			ld (debug_mark+1),a  
ccd8 3a e2 cc			ld a, (.dmark+2)  
ccdb 32 60 ee			ld (debug_mark+2),a  
ccde 18 03			jr .pastdmark  
cce0 ..			.dmark: db "CHR"  
cce3 f1			.pastdmark: pop af  
cce4			endm  
# End of macro DMARK
cce4						CALLMONITOR 
cce4 cd 6b ee			call debug_vector  
cce7				endm  
# End of macro CALLMONITOR
cce7					endif 
cce7					FORTH_DSP_VALUEHL 
cce7 cd c8 9b			call macro_dsp_valuehl 
ccea				endm 
# End of macro FORTH_DSP_VALUEHL
ccea			 
ccea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ccea cd 80 9c			call macro_forth_dsp_pop 
cced				endm 
# End of macro FORTH_DSP_POP
cced			 
cced					; save asci byte as a zero term string and push string 
cced			 
cced 7d					ld a,l 
ccee 32 b4 e2				ld (scratch), a 
ccf1			 
ccf1 3e 00				ld a, 0 
ccf3 32 b5 e2				ld (scratch+1), a 
ccf6			 
ccf6 21 b4 e2				ld hl, scratch 
ccf9 cd 36 9a				call forth_push_str 
ccfc			 
ccfc			 
ccfc				       NEXTW 
ccfc cd 68 ee			call parse_vector 
ccff c3 af 9d			jp macro_next 
cd02				endm 
# End of macro NEXTW
cd02			 
cd02			 
cd02			 
cd02			 
cd02			.ENDSTR: 
cd02			; eof 
cd02			 
# End of file forth_words_str.asm
cd02			include "forth_words_key.asm" 
cd02			 
cd02			; | ## Keyboard Words 
cd02			 
cd02			.MACRO: 
cd02			 
cd02				CWHEAD .KEY 42 "MACRO" 5 WORD_FLAG_CODE 
cd02 3e				db WORD_SYS_CORE+42             
cd03 2e cd			dw .KEY            
cd05 06				db 5 + 1 
cd06 .. 00			db "MACRO",0              
cd0c				endm 
# End of macro CWHEAD
cd0c			; | MACRO ( s u -- ) Maps a string s against a key code u for use in the editor functions (CLI/EDIT/ACCEPT)  | TODO 
cd0c			 
cd0c					if DEBUG_FORTH_WORDS_KEY 
cd0c						DMARK "MAC" 
cd0c f5				push af  
cd0d 3a 21 cd			ld a, (.dmark)  
cd10 32 5e ee			ld (debug_mark),a  
cd13 3a 22 cd			ld a, (.dmark+1)  
cd16 32 5f ee			ld (debug_mark+1),a  
cd19 3a 23 cd			ld a, (.dmark+2)  
cd1c 32 60 ee			ld (debug_mark+2),a  
cd1f 18 03			jr .pastdmark  
cd21 ..			.dmark: db "MAC"  
cd24 f1			.pastdmark: pop af  
cd25			endm  
# End of macro DMARK
cd25						CALLMONITOR 
cd25 cd 6b ee			call debug_vector  
cd28				endm  
# End of macro CALLMONITOR
cd28					endif 
cd28			 
cd28					; get key code 
cd28					; calc string length 
cd28					; malloc string size 
cd28					; copy string 
cd28					; patch keyboard scan 
cd28			 
cd28					; maintain a linked list?  
cd28					; need a structure for root of key mappings 
cd28					; hold last defined macro so that link can be made to the next one 
cd28					; key_macroroot   is the first one 
cd28					; key_macrolast is location of the last macro defined 
cd28			 
cd28			 
cd28					NEXTW 
cd28 cd 68 ee			call parse_vector 
cd2b c3 af 9d			jp macro_next 
cd2e				endm 
# End of macro NEXTW
cd2e			 
cd2e			.KEY: 
cd2e				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
cd2e 3e				db WORD_SYS_CORE+42             
cd2f 61 cd			dw .KEYDB            
cd31 04				db 3 + 1 
cd32 .. 00			db "KEY",0              
cd36				endm 
# End of macro CWHEAD
cd36			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
cd36			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cd36			; | | Can use something like this to process: 
cd36			; | | > repeat active . key ?dup if emit then #1 until  
cd36			 
cd36					if DEBUG_FORTH_WORDS_KEY 
cd36						DMARK "KEY" 
cd36 f5				push af  
cd37 3a 4b cd			ld a, (.dmark)  
cd3a 32 5e ee			ld (debug_mark),a  
cd3d 3a 4c cd			ld a, (.dmark+1)  
cd40 32 5f ee			ld (debug_mark+1),a  
cd43 3a 4d cd			ld a, (.dmark+2)  
cd46 32 60 ee			ld (debug_mark+2),a  
cd49 18 03			jr .pastdmark  
cd4b ..			.dmark: db "KEY"  
cd4e f1			.pastdmark: pop af  
cd4f			endm  
# End of macro DMARK
cd4f						CALLMONITOR 
cd4f cd 6b ee			call debug_vector  
cd52				endm  
# End of macro CALLMONITOR
cd52					endif 
cd52			; TODO currently waits 
cd52 cd 2d e6				call cinndb 
cd55					;call cin_wait 
cd55 6f					ld l, a 
cd56 26 00				ld h, 0 
cd58 cd cc 99				call forth_push_numhl 
cd5b					NEXTW 
cd5b cd 68 ee			call parse_vector 
cd5e c3 af 9d			jp macro_next 
cd61				endm 
# End of macro NEXTW
cd61			.KEYDB: 
cd61				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
cd61 3e				db WORD_SYS_CORE+42             
cd62 96 cd			dw .WAITK            
cd64 06				db 5 + 1 
cd65 .. 00			db "KEYDB",0              
cd6b				endm 
# End of macro CWHEAD
cd6b			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
cd6b			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cd6b			; | | Can use something like this to process: 
cd6b			; | | > repeat active . key ?dup if emit then #1 until  
cd6b			 
cd6b					if DEBUG_FORTH_WORDS_KEY 
cd6b						DMARK "KEB" 
cd6b f5				push af  
cd6c 3a 80 cd			ld a, (.dmark)  
cd6f 32 5e ee			ld (debug_mark),a  
cd72 3a 81 cd			ld a, (.dmark+1)  
cd75 32 5f ee			ld (debug_mark+1),a  
cd78 3a 82 cd			ld a, (.dmark+2)  
cd7b 32 60 ee			ld (debug_mark+2),a  
cd7e 18 03			jr .pastdmark  
cd80 ..			.dmark: db "KEB"  
cd83 f1			.pastdmark: pop af  
cd84			endm  
# End of macro DMARK
cd84						CALLMONITOR 
cd84 cd 6b ee			call debug_vector  
cd87				endm  
# End of macro CALLMONITOR
cd87					endif 
cd87			; TODO currently waits 
cd87 cd 2d e6				call cin 
cd8a					;call cin_wait 
cd8a 6f					ld l, a 
cd8b 26 00				ld h, 0 
cd8d cd cc 99				call forth_push_numhl 
cd90					NEXTW 
cd90 cd 68 ee			call parse_vector 
cd93 c3 af 9d			jp macro_next 
cd96				endm 
# End of macro NEXTW
cd96			.WAITK: 
cd96				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
cd96 3f				db WORD_SYS_CORE+43             
cd97 cb cd			dw .ACCEPT            
cd99 06				db 5 + 1 
cd9a .. 00			db "WAITK",0              
cda0				endm 
# End of macro CWHEAD
cda0			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
cda0					if DEBUG_FORTH_WORDS_KEY 
cda0						DMARK "WAI" 
cda0 f5				push af  
cda1 3a b5 cd			ld a, (.dmark)  
cda4 32 5e ee			ld (debug_mark),a  
cda7 3a b6 cd			ld a, (.dmark+1)  
cdaa 32 5f ee			ld (debug_mark+1),a  
cdad 3a b7 cd			ld a, (.dmark+2)  
cdb0 32 60 ee			ld (debug_mark+2),a  
cdb3 18 03			jr .pastdmark  
cdb5 ..			.dmark: db "WAI"  
cdb8 f1			.pastdmark: pop af  
cdb9			endm  
# End of macro DMARK
cdb9						CALLMONITOR 
cdb9 cd 6b ee			call debug_vector  
cdbc				endm  
# End of macro CALLMONITOR
cdbc					endif 
cdbc cd 27 e6				call cin_wait 
cdbf 6f					ld l, a 
cdc0 26 00				ld h, 0 
cdc2 cd cc 99				call forth_push_numhl 
cdc5					NEXTW 
cdc5 cd 68 ee			call parse_vector 
cdc8 c3 af 9d			jp macro_next 
cdcb				endm 
# End of macro NEXTW
cdcb			.ACCEPT: 
cdcb				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
cdcb 40				db WORD_SYS_CORE+44             
cdcc 2b ce			dw .EDIT            
cdce 07				db 6 + 1 
cdcf .. 00			db "ACCEPT",0              
cdd6				endm 
# End of macro CWHEAD
cdd6			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
cdd6					; TODO crashes on push 
cdd6					if DEBUG_FORTH_WORDS_KEY 
cdd6						DMARK "ACC" 
cdd6 f5				push af  
cdd7 3a eb cd			ld a, (.dmark)  
cdda 32 5e ee			ld (debug_mark),a  
cddd 3a ec cd			ld a, (.dmark+1)  
cde0 32 5f ee			ld (debug_mark+1),a  
cde3 3a ed cd			ld a, (.dmark+2)  
cde6 32 60 ee			ld (debug_mark+2),a  
cde9 18 03			jr .pastdmark  
cdeb ..			.dmark: db "ACC"  
cdee f1			.pastdmark: pop af  
cdef			endm  
# End of macro DMARK
cdef						CALLMONITOR 
cdef cd 6b ee			call debug_vector  
cdf2				endm  
# End of macro CALLMONITOR
cdf2					endif 
cdf2 21 b2 e4				ld hl, os_input 
cdf5			;		ld a, 0 
cdf5 36 00				ld (hl),0 
cdf7 3a 51 ea				ld a,(f_cursor_ptr) 
cdfa 16 64				ld d, 100 
cdfc 0e 00				ld c, 0 
cdfe 1e 28				ld e, 40 
ce00 cd 08 8d				call input_str 
ce03					; TODO perhaps do a type check and wrap in quotes if not a number 
ce03 21 b2 e4				ld hl, os_input 
ce06					if DEBUG_FORTH_WORDS 
ce06						DMARK "AC1" 
ce06 f5				push af  
ce07 3a 1b ce			ld a, (.dmark)  
ce0a 32 5e ee			ld (debug_mark),a  
ce0d 3a 1c ce			ld a, (.dmark+1)  
ce10 32 5f ee			ld (debug_mark+1),a  
ce13 3a 1d ce			ld a, (.dmark+2)  
ce16 32 60 ee			ld (debug_mark+2),a  
ce19 18 03			jr .pastdmark  
ce1b ..			.dmark: db "AC1"  
ce1e f1			.pastdmark: pop af  
ce1f			endm  
# End of macro DMARK
ce1f						CALLMONITOR 
ce1f cd 6b ee			call debug_vector  
ce22				endm  
# End of macro CALLMONITOR
ce22					endif 
ce22 cd 36 9a				call forth_push_str 
ce25					NEXTW 
ce25 cd 68 ee			call parse_vector 
ce28 c3 af 9d			jp macro_next 
ce2b				endm 
# End of macro NEXTW
ce2b			 
ce2b			.EDIT: 
ce2b				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
ce2b 40				db WORD_SYS_CORE+44             
ce2c d0 ce			dw .DEDIT            
ce2e 05				db 4 + 1 
ce2f .. 00			db "EDIT",0              
ce34				endm 
# End of macro CWHEAD
ce34			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
ce34			 
ce34					; TODO does not copy from stack 
ce34					if DEBUG_FORTH_WORDS_KEY 
ce34						DMARK "EDT" 
ce34 f5				push af  
ce35 3a 49 ce			ld a, (.dmark)  
ce38 32 5e ee			ld (debug_mark),a  
ce3b 3a 4a ce			ld a, (.dmark+1)  
ce3e 32 5f ee			ld (debug_mark+1),a  
ce41 3a 4b ce			ld a, (.dmark+2)  
ce44 32 60 ee			ld (debug_mark+2),a  
ce47 18 03			jr .pastdmark  
ce49 ..			.dmark: db "EDT"  
ce4c f1			.pastdmark: pop af  
ce4d			endm  
# End of macro DMARK
ce4d						CALLMONITOR 
ce4d cd 6b ee			call debug_vector  
ce50				endm  
# End of macro CALLMONITOR
ce50					endif 
ce50			 
ce50					;FORTH_DSP 
ce50					FORTH_DSP_VALUEHL 
ce50 cd c8 9b			call macro_dsp_valuehl 
ce53				endm 
# End of macro FORTH_DSP_VALUEHL
ce53			;		inc hl    ; TODO do type check 
ce53			 
ce53			;		call get_word_hl 
ce53 e5					push hl 
ce54					if DEBUG_FORTH_WORDS 
ce54						DMARK "EDp" 
ce54 f5				push af  
ce55 3a 69 ce			ld a, (.dmark)  
ce58 32 5e ee			ld (debug_mark),a  
ce5b 3a 6a ce			ld a, (.dmark+1)  
ce5e 32 5f ee			ld (debug_mark+1),a  
ce61 3a 6b ce			ld a, (.dmark+2)  
ce64 32 60 ee			ld (debug_mark+2),a  
ce67 18 03			jr .pastdmark  
ce69 ..			.dmark: db "EDp"  
ce6c f1			.pastdmark: pop af  
ce6d			endm  
# End of macro DMARK
ce6d						CALLMONITOR 
ce6d cd 6b ee			call debug_vector  
ce70				endm  
# End of macro CALLMONITOR
ce70					endif 
ce70				;	ld a, 0 
ce70 cd 33 90				call strlenz 
ce73 23					inc hl 
ce74			 
ce74 06 00				ld b, 0 
ce76 4d					ld c, l 
ce77			 
ce77 e1					pop hl 
ce78 11 b2 e4				ld de, os_input 
ce7b					if DEBUG_FORTH_WORDS_KEY 
ce7b						DMARK "EDc" 
ce7b f5				push af  
ce7c 3a 90 ce			ld a, (.dmark)  
ce7f 32 5e ee			ld (debug_mark),a  
ce82 3a 91 ce			ld a, (.dmark+1)  
ce85 32 5f ee			ld (debug_mark+1),a  
ce88 3a 92 ce			ld a, (.dmark+2)  
ce8b 32 60 ee			ld (debug_mark+2),a  
ce8e 18 03			jr .pastdmark  
ce90 ..			.dmark: db "EDc"  
ce93 f1			.pastdmark: pop af  
ce94			endm  
# End of macro DMARK
ce94						CALLMONITOR 
ce94 cd 6b ee			call debug_vector  
ce97				endm  
# End of macro CALLMONITOR
ce97					endif 
ce97 ed b0				ldir 
ce99			 
ce99			 
ce99 21 b2 e4				ld hl, os_input 
ce9c					;ld a, 0 
ce9c					;ld (hl),a 
ce9c 3a 51 ea				ld a,(f_cursor_ptr) 
ce9f 16 64				ld d, 100 
cea1 0e 00				ld c, 0 
cea3 1e 28				ld e, 40 
cea5 cd 08 8d				call input_str 
cea8					; TODO perhaps do a type check and wrap in quotes if not a number 
cea8 21 b2 e4				ld hl, os_input 
ceab					if DEBUG_FORTH_WORDS 
ceab						DMARK "ED1" 
ceab f5				push af  
ceac 3a c0 ce			ld a, (.dmark)  
ceaf 32 5e ee			ld (debug_mark),a  
ceb2 3a c1 ce			ld a, (.dmark+1)  
ceb5 32 5f ee			ld (debug_mark+1),a  
ceb8 3a c2 ce			ld a, (.dmark+2)  
cebb 32 60 ee			ld (debug_mark+2),a  
cebe 18 03			jr .pastdmark  
cec0 ..			.dmark: db "ED1"  
cec3 f1			.pastdmark: pop af  
cec4			endm  
# End of macro DMARK
cec4						CALLMONITOR 
cec4 cd 6b ee			call debug_vector  
cec7				endm  
# End of macro CALLMONITOR
cec7					endif 
cec7 cd 36 9a				call forth_push_str 
ceca					NEXTW 
ceca cd 68 ee			call parse_vector 
cecd c3 af 9d			jp macro_next 
ced0				endm 
# End of macro NEXTW
ced0			 
ced0			.DEDIT: 
ced0				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
ced0 40				db WORD_SYS_CORE+44             
ced1 35 cf			dw .ENDKEY            
ced3 06				db 5 + 1 
ced4 .. 00			db "DEDIT",0              
ceda				endm 
# End of macro CWHEAD
ceda			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
ceda			 
ceda					; TODO does not copy from stack 
ceda					if DEBUG_FORTH_WORDS_KEY 
ceda						DMARK "DED" 
ceda f5				push af  
cedb 3a ef ce			ld a, (.dmark)  
cede 32 5e ee			ld (debug_mark),a  
cee1 3a f0 ce			ld a, (.dmark+1)  
cee4 32 5f ee			ld (debug_mark+1),a  
cee7 3a f1 ce			ld a, (.dmark+2)  
ceea 32 60 ee			ld (debug_mark+2),a  
ceed 18 03			jr .pastdmark  
ceef ..			.dmark: db "DED"  
cef2 f1			.pastdmark: pop af  
cef3			endm  
# End of macro DMARK
cef3						CALLMONITOR 
cef3 cd 6b ee			call debug_vector  
cef6				endm  
# End of macro CALLMONITOR
cef6					endif 
cef6			 
cef6					;FORTH_DSP 
cef6					FORTH_DSP_VALUEHL 
cef6 cd c8 9b			call macro_dsp_valuehl 
cef9				endm 
# End of macro FORTH_DSP_VALUEHL
cef9			;		inc hl    ; TODO do type check 
cef9			 
cef9			;		call get_word_hl 
cef9 e5					push hl 
cefa e5					push hl 
cefb					FORTH_DSP_POP 
cefb cd 80 9c			call macro_forth_dsp_pop 
cefe				endm 
# End of macro FORTH_DSP_POP
cefe e1					pop hl 
ceff					if DEBUG_FORTH_WORDS 
ceff						DMARK "EDp" 
ceff f5				push af  
cf00 3a 14 cf			ld a, (.dmark)  
cf03 32 5e ee			ld (debug_mark),a  
cf06 3a 15 cf			ld a, (.dmark+1)  
cf09 32 5f ee			ld (debug_mark+1),a  
cf0c 3a 16 cf			ld a, (.dmark+2)  
cf0f 32 60 ee			ld (debug_mark+2),a  
cf12 18 03			jr .pastdmark  
cf14 ..			.dmark: db "EDp"  
cf17 f1			.pastdmark: pop af  
cf18			endm  
# End of macro DMARK
cf18						CALLMONITOR 
cf18 cd 6b ee			call debug_vector  
cf1b				endm  
# End of macro CALLMONITOR
cf1b					endif 
cf1b				;	ld a, 0 
cf1b cd 33 90				call strlenz 
cf1e 23					inc hl 
cf1f			 
cf1f 06 00				ld b, 0 
cf21 4d					ld c, l 
cf22			 
cf22 e1					pop hl 
cf23			 
cf23					;ld a, 0 
cf23					;ld (hl),a 
cf23 3a 51 ea				ld a,(f_cursor_ptr) 
cf26 16 64				ld d, 100 
cf28 0e 00				ld c, 0 
cf2a 1e 28				ld e, 40 
cf2c cd 08 8d				call input_str 
cf2f					; TODO perhaps do a type check and wrap in quotes if not a number 
cf2f					NEXTW 
cf2f cd 68 ee			call parse_vector 
cf32 c3 af 9d			jp macro_next 
cf35				endm 
# End of macro NEXTW
cf35			 
cf35			 
cf35			.ENDKEY: 
cf35			; eof 
cf35			 
# End of file forth_words_key.asm
cf35			include "forth_words_const.asm" 
cf35			 
cf35			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
cf35			 
cf35			 
cf35			.SPITIME: 
cf35				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
cf35 77				db WORD_SYS_CORE+99             
cf36 4d cf			dw .VA            
cf38 08				db 7 + 1 
cf39 .. 00			db "SPITIME",0              
cf41				endm 
# End of macro CWHEAD
cf41			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
cf41			; 
cf41			; | | If using BANK devices then leave as is. 
cf41			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
cf41			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
cf41			 
cf41 21 57 ea				ld hl, spi_clktime  
cf44 cd cc 99				call forth_push_numhl 
cf47			 
cf47					NEXTW 
cf47 cd 68 ee			call parse_vector 
cf4a c3 af 9d			jp macro_next 
cf4d				endm 
# End of macro NEXTW
cf4d			 
cf4d			 
cf4d			.VA: 
cf4d				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
cf4d 77				db WORD_SYS_CORE+99             
cf4e 60 cf			dw .SYMBOL            
cf50 03				db 2 + 1 
cf51 .. 00			db "VA",0              
cf54				endm 
# End of macro CWHEAD
cf54			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
cf54 21 1b ea				ld hl, cli_var_array 
cf57 cd cc 99				call forth_push_numhl 
cf5a			 
cf5a					NEXTW 
cf5a cd 68 ee			call parse_vector 
cf5d c3 af 9d			jp macro_next 
cf60				endm 
# End of macro NEXTW
cf60			 
cf60			.SYMBOL: 
cf60				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
cf60 77				db WORD_SYS_CORE+99             
cf61 6f d0			dw .ENDCONST            
cf63 07				db 6 + 1 
cf64 .. 00			db "SYMBOL",0              
cf6b				endm 
# End of macro CWHEAD
cf6b			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
cf6b			; | 
cf6b			; | | The value is the number reference and the final address is pushed to stack 
cf6b			 
cf6b			; | | ``` 
cf6b			; | | dw sym_table 
cf6b			; | | dw nmi_vector 
cf6b			; | | dw cli_autodisplay 
cf6b			; | | dw cli_data_sp 
cf6b			; | | dw cli_data_stack 
cf6b			; | | dw cli_loop_sp 
cf6b			; | | dw cli_loop_stack 
cf6b			; | | dw cli_var_array 
cf6b			; | | dw cursor_col 
cf6b			; | | dw cursor_ptr 
cf6b			; | | ; 10 
cf6b			; | | dw cursor_row 
cf6b			; | | dw debug_mark 
cf6b			; | | dw display_fb0 
cf6b			; | | dw display_fb1 
cf6b			; | | dw display_fb2 
cf6b			; | | dw display_fb3 
cf6b			; | | dw display_fb_active 
cf6b			; | | dw execscratch 
cf6b			; | | dw f_cursor_ptr 
cf6b			; | | dw hardware_word 
cf6b			; | | ;20 
cf6b			; | | dw input_at_cursor 
cf6b			; | | dw input_at_pos 
cf6b			; | | dw input_cur_flash 
cf6b			; | | dw input_cur_onoff 
cf6b			; | | dw input_cursor 
cf6b			; | | dw input_display_size 
cf6b			; | | dw input_len 
cf6b			; | | dw input_ptr 
cf6b			; | | dw input_size 
cf6b			; | | dw input_start 
cf6b			; | | ; 30 
cf6b			; | | dw input_str 
cf6b			; | | dw input_under_cursor 
cf6b			; | | dw os_cli_cmd 
cf6b			; | | dw os_cur_ptr 
cf6b			; | | dw os_current_i 
cf6b			; | | dw os_input 
cf6b			; | | dw os_last_cmd 
cf6b			; | | dw os_last_new_uword 
cf6b			; | | dw debug_vector 
cf6b			; | | dw os_view_hl 
cf6b			; | | ;40 
cf6b			; | | dw os_word_scratch 
cf6b			; | | dw portbctl 
cf6b			; | | dw portbdata 
cf6b			; | | dw spi_cartdev 
cf6b			; | | dw spi_cartdev2 
cf6b			; | | dw spi_clktime 
cf6b			; | | dw spi_device 
cf6b			; | | dw spi_device_id 
cf6b			; | | dw spi_portbyte 
cf6b			; | | dw stackstore 
cf6b			; | | ; 50 
cf6b			; | | if STORAGE_SE 
cf6b			; | | dw storage_actl 
cf6b			; | | dw storage_adata 
cf6b			; | | else 
cf6b			; | | dw 0 
cf6b			; | | dw 0 
cf6b			; | | endif 
cf6b			; | | dw storage_append 
cf6b			; | | if STORAGE_SE 
cf6b			; | | dw storage_bctl 
cf6b			; | | else 
cf6b			; | | dw 0 
cf6b			; | | endif 
cf6b			; | | dw store_bank_active 
cf6b			; | | dw store_filecache 
cf6b			; | | dw store_longread 
cf6b			; | | dw store_openaddr 
cf6b			; | | dw store_openext 
cf6b			; | | dw store_openmaxext 
cf6b			; | | ; 60 
cf6b			; | | dw store_page 
cf6b			; | | dw store_readbuf 
cf6b			; | | dw store_readcont 
cf6b			; | | dw store_readptr 
cf6b			; | | dw store_tmpext 
cf6b			; | | dw store_tmpid 
cf6b			; | | dw store_tmppageid 
cf6b			; | | dw malloc 
cf6b			; | | dw free 
cf6b			; | | dw cin 
cf6b			; | | ; 70 
cf6b			; | | dw cin_wait 
cf6b			; | | dw forth_push_numhl 
cf6b			; | | dw forth_push_str 
cf6b			; | | dw parse_vector 
cf6b			; | | ``` 
cf6b			 
cf6b					if DEBUG_FORTH_WORDS_KEY 
cf6b						DMARK "SYM" 
cf6b f5				push af  
cf6c 3a 80 cf			ld a, (.dmark)  
cf6f 32 5e ee			ld (debug_mark),a  
cf72 3a 81 cf			ld a, (.dmark+1)  
cf75 32 5f ee			ld (debug_mark+1),a  
cf78 3a 82 cf			ld a, (.dmark+2)  
cf7b 32 60 ee			ld (debug_mark+2),a  
cf7e 18 03			jr .pastdmark  
cf80 ..			.dmark: db "SYM"  
cf83 f1			.pastdmark: pop af  
cf84			endm  
# End of macro DMARK
cf84						CALLMONITOR 
cf84 cd 6b ee			call debug_vector  
cf87				endm  
# End of macro CALLMONITOR
cf87					endif 
cf87			 
cf87					FORTH_DSP_VALUEHL 
cf87 cd c8 9b			call macro_dsp_valuehl 
cf8a				endm 
# End of macro FORTH_DSP_VALUEHL
cf8a			 
cf8a 7d					ld a, l     
cf8b			 
cf8b			 
cf8b					if DEBUG_FORTH_WORDS 
cf8b						DMARK "SY1" 
cf8b f5				push af  
cf8c 3a a0 cf			ld a, (.dmark)  
cf8f 32 5e ee			ld (debug_mark),a  
cf92 3a a1 cf			ld a, (.dmark+1)  
cf95 32 5f ee			ld (debug_mark+1),a  
cf98 3a a2 cf			ld a, (.dmark+2)  
cf9b 32 60 ee			ld (debug_mark+2),a  
cf9e 18 03			jr .pastdmark  
cfa0 ..			.dmark: db "SY1"  
cfa3 f1			.pastdmark: pop af  
cfa4			endm  
# End of macro DMARK
cfa4						CALLMONITOR 
cfa4 cd 6b ee			call debug_vector  
cfa7				endm  
# End of macro CALLMONITOR
cfa7					endif 
cfa7					 
cfa7 f5					push af	 
cfa8					FORTH_DSP_POP 
cfa8 cd 80 9c			call macro_forth_dsp_pop 
cfab				endm 
# End of macro FORTH_DSP_POP
cfab f1					pop af 
cfac			 
cfac cb 27				sla a  
cfae				 
cfae					 
cfae					if DEBUG_FORTH_WORDS 
cfae						DMARK "SY" 
cfae f5				push af  
cfaf 3a c3 cf			ld a, (.dmark)  
cfb2 32 5e ee			ld (debug_mark),a  
cfb5 3a c4 cf			ld a, (.dmark+1)  
cfb8 32 5f ee			ld (debug_mark+1),a  
cfbb 3a c5 cf			ld a, (.dmark+2)  
cfbe 32 60 ee			ld (debug_mark+2),a  
cfc1 18 02			jr .pastdmark  
cfc3 ..			.dmark: db "SY"  
cfc5 f1			.pastdmark: pop af  
cfc6			endm  
# End of macro DMARK
cfc6						CALLMONITOR 
cfc6 cd 6b ee			call debug_vector  
cfc9				endm  
# End of macro CALLMONITOR
cfc9					endif 
cfc9			 
cfc9 21 db cf				ld hl, sym_table 
cfcc cd db 8c				call addatohl 
cfcf cd 35 9d				call loadwordinhl 
cfd2 cd cc 99				call forth_push_numhl 
cfd5			 
cfd5			 
cfd5				       NEXTW 
cfd5 cd 68 ee			call parse_vector 
cfd8 c3 af 9d			jp macro_next 
cfdb				endm 
# End of macro NEXTW
cfdb			 
cfdb			sym_table: 
cfdb			 
cfdb			; 0 
cfdb db cf		dw sym_table 
cfdd 6e ee		dw nmi_vector 
cfdf 2f ea		dw cli_autodisplay 
cfe1 e1 e9		dw cli_data_sp 
cfe3 1b e8		dw cli_data_stack 
cfe5 e3 e9		dw cli_loop_sp 
cfe7 1d e9		dw cli_loop_stack 
cfe9 1b ea		dw cli_var_array 
cfeb b8 eb		dw cursor_col 
cfed b6 eb		dw cursor_ptr 
cfef			; 10 
cfef b7 eb		dw cursor_row 
cff1 5e ee		dw debug_mark 
cff3 a4 ed		dw display_fb0 
cff5 03 ed		dw display_fb1 
cff7 c1 eb		dw display_fb2 
cff9 62 ec		dw display_fb3 
cffb bf eb		dw display_fb_active 
cffd b3 e3		dw execscratch 
cfff 51 ea		dw f_cursor_ptr 
d001 71 ee		dw hardware_word 
d003			;20 
d003 55 ee		dw input_at_cursor 
d005 57 ee		dw input_at_pos 
d007 53 ee		dw input_cur_flash 
d009 52 ee		dw input_cur_onoff 
d00b 48 ee		dw input_cursor 
d00d 58 ee		dw input_display_size 
d00f 4d ee		dw input_len 
d011 5c ee		dw input_ptr 
d013 59 ee		dw input_size 
d015 5a ee		dw input_start 
d017			; 30 
d017 08 8d		dw input_str 
d019 56 ee		dw input_under_cursor 
d01b db e5		dw os_cli_cmd 
d01d d7 e5		dw os_cur_ptr 
d01f d9 e5		dw os_current_i 
d021 b2 e4		dw os_input 
d023 da e6		dw os_last_cmd 
d025 b1 e5		dw os_last_new_uword 
d027 6b ee		dw debug_vector 
d029 96 e2		dw os_view_hl 
d02b			;40 
d02b b9 e5		dw os_word_scratch 
d02d c3 00		dw portbctl 
d02f c1 00		dw portbdata 
d031 56 ea		dw spi_cartdev 
d033 55 ea		dw spi_cartdev2 
d035 57 ea		dw spi_clktime 
d037 53 ea		dw spi_device 
d039 52 ea		dw spi_device_id 
d03b 54 ea		dw spi_portbyte 
d03d 9a eb		dw stackstore 
d03f			; 50 
d03f			if STORAGE_SE 
d03f			dw storage_actl 
d03f			dw storage_adata 
d03f			else 
d03f 00 00		dw 0 
d041 00 00		dw 0 
d043			endif 
d043 6b 88		dw storage_append 
d045			if STORAGE_SE 
d045			dw storage_bctl 
d045			else 
d045 00 00		dw 0 
d047			endif 
d047 86 eb		dw store_bank_active 
d049 5a ea		dw store_filecache 
d04b 68 ea		dw store_longread 
d04d 5e ea		dw store_openaddr 
d04f 5d ea		dw store_openext 
d051 5c ea		dw store_openmaxext 
d053			; 60 
d053 6d ea		dw store_page 
d055 69 ea		dw store_readbuf 
d057 60 ea		dw store_readcont 
d059 6b ea		dw store_readptr 
d05b 60 ea		dw store_tmpext 
d05d 61 ea		dw store_tmpid 
d05f 58 ea		dw store_tmppageid 
d061 a7 90		dw malloc 
d063 71 91		dw free 
d065 2d e6		dw cin 
d067			; 70 
d067 27 e6		dw cin_wait 
d069 cc 99		dw forth_push_numhl 
d06b 36 9a		dw forth_push_str 
d06d 68 ee		dw parse_vector 
d06f			 
d06f			.ENDCONST: 
d06f			 
d06f			; eof 
d06f			 
d06f			 
# End of file forth_words_const.asm
d06f			 
d06f			if STORAGE_SE 
d06f			   	include "forth_words_storage.asm" 
d06f			endif 
d06f				include "forth_words_device.asm" 
d06f			; Device related words 
d06f			 
d06f			; | ## Device Words 
d06f			 
d06f			;if SOUND_ENABLE 
d06f			;.NOTE: 
d06f			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
d06f			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
d06f			;		if DEBUG_FORTH_WORDS_KEY 
d06f			;			DMARK "NTE" 
d06f			;			CALLMONITOR 
d06f			;		endif 
d06f			; 
d06f			;	 
d06f			; 
d06f			;		NEXTW 
d06f			;.AFTERSOUND: 
d06f			;endif 
d06f			 
d06f			 
d06f			USE_GPIO: equ 0 
d06f			 
d06f			if USE_GPIO 
d06f			.GP1: 
d06f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
d06f			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
d06f					NEXTW 
d06f			.GP2: 
d06f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
d06f			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
d06f			 
d06f					NEXTW 
d06f			 
d06f			.GP3: 
d06f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
d06f			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
d06f			 
d06f					NEXTW 
d06f			 
d06f			.GP4: 
d06f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
d06f			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
d06f			 
d06f					NEXTW 
d06f			.SIN: 
d06f			 
d06f			 
d06f			endif 
d06f			 
d06f			 
d06f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
d06f 33				db WORD_SYS_CORE+31             
d070 a7 d0			dw .SOUT            
d072 03				db 2 + 1 
d073 .. 00			db "IN",0              
d076				endm 
# End of macro CWHEAD
d076			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
d076					if DEBUG_FORTH_WORDS_KEY 
d076						DMARK "IN." 
d076 f5				push af  
d077 3a 8b d0			ld a, (.dmark)  
d07a 32 5e ee			ld (debug_mark),a  
d07d 3a 8c d0			ld a, (.dmark+1)  
d080 32 5f ee			ld (debug_mark+1),a  
d083 3a 8d d0			ld a, (.dmark+2)  
d086 32 60 ee			ld (debug_mark+2),a  
d089 18 03			jr .pastdmark  
d08b ..			.dmark: db "IN."  
d08e f1			.pastdmark: pop af  
d08f			endm  
# End of macro DMARK
d08f						CALLMONITOR 
d08f cd 6b ee			call debug_vector  
d092				endm  
# End of macro CALLMONITOR
d092					endif 
d092					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d092 cd c8 9b			call macro_dsp_valuehl 
d095				endm 
# End of macro FORTH_DSP_VALUEHL
d095			 
d095 e5					push hl 
d096			 
d096					; destroy value TOS 
d096			 
d096					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d096 cd 80 9c			call macro_forth_dsp_pop 
d099				endm 
# End of macro FORTH_DSP_POP
d099			 
d099					; one value on hl get other one back 
d099			 
d099 c1					pop bc 
d09a			 
d09a					; do the sub 
d09a			;		ex de, hl 
d09a			 
d09a ed 68				in l,(c) 
d09c			 
d09c					; save it 
d09c			 
d09c 26 00				ld h,0 
d09e			 
d09e					; TODO push value back onto stack for another op etc 
d09e			 
d09e cd cc 99				call forth_push_numhl 
d0a1					NEXTW 
d0a1 cd 68 ee			call parse_vector 
d0a4 c3 af 9d			jp macro_next 
d0a7				endm 
# End of macro NEXTW
d0a7			.SOUT: 
d0a7				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
d0a7 34				db WORD_SYS_CORE+32             
d0a8 fd d0			dw .SPIO            
d0aa 04				db 3 + 1 
d0ab .. 00			db "OUT",0              
d0af				endm 
# End of macro CWHEAD
d0af			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
d0af					if DEBUG_FORTH_WORDS_KEY 
d0af						DMARK "OUT" 
d0af f5				push af  
d0b0 3a c4 d0			ld a, (.dmark)  
d0b3 32 5e ee			ld (debug_mark),a  
d0b6 3a c5 d0			ld a, (.dmark+1)  
d0b9 32 5f ee			ld (debug_mark+1),a  
d0bc 3a c6 d0			ld a, (.dmark+2)  
d0bf 32 60 ee			ld (debug_mark+2),a  
d0c2 18 03			jr .pastdmark  
d0c4 ..			.dmark: db "OUT"  
d0c7 f1			.pastdmark: pop af  
d0c8			endm  
# End of macro DMARK
d0c8						CALLMONITOR 
d0c8 cd 6b ee			call debug_vector  
d0cb				endm  
# End of macro CALLMONITOR
d0cb					endif 
d0cb			 
d0cb					; get port 
d0cb			 
d0cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0cb cd c8 9b			call macro_dsp_valuehl 
d0ce				endm 
# End of macro FORTH_DSP_VALUEHL
d0ce			 
d0ce e5					push hl 
d0cf			 
d0cf					; destroy value TOS 
d0cf			 
d0cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0cf cd 80 9c			call macro_forth_dsp_pop 
d0d2				endm 
# End of macro FORTH_DSP_POP
d0d2			 
d0d2					; get byte to send 
d0d2			 
d0d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0d2 cd c8 9b			call macro_dsp_valuehl 
d0d5				endm 
# End of macro FORTH_DSP_VALUEHL
d0d5			 
d0d5			;		push hl 
d0d5			 
d0d5					; destroy value TOS 
d0d5			 
d0d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0d5 cd 80 9c			call macro_forth_dsp_pop 
d0d8				endm 
# End of macro FORTH_DSP_POP
d0d8			 
d0d8					; one value on hl get other one back 
d0d8			 
d0d8			;		pop hl 
d0d8			 
d0d8 c1					pop bc 
d0d9			 
d0d9					if DEBUG_FORTH_WORDS 
d0d9						DMARK "OUT" 
d0d9 f5				push af  
d0da 3a ee d0			ld a, (.dmark)  
d0dd 32 5e ee			ld (debug_mark),a  
d0e0 3a ef d0			ld a, (.dmark+1)  
d0e3 32 5f ee			ld (debug_mark+1),a  
d0e6 3a f0 d0			ld a, (.dmark+2)  
d0e9 32 60 ee			ld (debug_mark+2),a  
d0ec 18 03			jr .pastdmark  
d0ee ..			.dmark: db "OUT"  
d0f1 f1			.pastdmark: pop af  
d0f2			endm  
# End of macro DMARK
d0f2						CALLMONITOR 
d0f2 cd 6b ee			call debug_vector  
d0f5				endm  
# End of macro CALLMONITOR
d0f5					endif 
d0f5			 
d0f5 ed 69				out (c), l 
d0f7			 
d0f7					NEXTW 
d0f7 cd 68 ee			call parse_vector 
d0fa c3 af 9d			jp macro_next 
d0fd				endm 
# End of macro NEXTW
d0fd			 
d0fd			 
d0fd			.SPIO: 
d0fd			 
d0fd			if STORAGE_SE 
d0fd				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
d0fd			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
d0fd			 
d0fd					call spi_ce_low 
d0fd			    NEXTW 
d0fd			 
d0fd			.SPICEH: 
d0fd				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
d0fd			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
d0fd			 
d0fd					call spi_ce_high 
d0fd			    NEXTW 
d0fd			 
d0fd			 
d0fd			.SPIOb: 
d0fd			 
d0fd				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
d0fd			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
d0fd			 
d0fd					if DEBUG_FORTH_WORDS_KEY 
d0fd						DMARK "SPo" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd					; get port 
d0fd			 
d0fd			 
d0fd					; get byte to send 
d0fd			 
d0fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0fd			 
d0fd			;		push hl    ; u1  
d0fd			 
d0fd					; destroy value TOS 
d0fd			 
d0fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0fd			 
d0fd					; one value on hl get other one back 
d0fd			 
d0fd			;		pop hl   ; u2 - addr 
d0fd			 
d0fd					; TODO Send SPI byte 
d0fd			 
d0fd			;		push hl 
d0fd			;		call spi_ce_low 
d0fd			;		pop hl 
d0fd					ld a, l 
d0fd					call spi_send_byte 
d0fd			;		call spi_ce_high 
d0fd			 
d0fd					NEXTW 
d0fd			 
d0fd			.SPII: 
d0fd				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
d0fd			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
d0fd					if DEBUG_FORTH_WORDS_KEY 
d0fd						DMARK "SPi" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			 
d0fd					; TODO Get SPI byte 
d0fd			 
d0fd					call spi_read_byte 
d0fd			 
d0fd					if DEBUG_FORTH_WORDS 
d0fd						DMARK "Si2" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd					ld h, 0 
d0fd					ld l, a 
d0fd					if DEBUG_FORTH_WORDS 
d0fd						DMARK "Si3" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd					call forth_push_numhl 
d0fd			 
d0fd					NEXTW 
d0fd			 
d0fd			 
d0fd			 
d0fd			.SESEL: 
d0fd				CWHEAD .SESELS 82 "BANK?" 5 WORD_FLAG_CODE 
d0fd			; | BANK? ( -- u ) Reports on the serial EEPROM Bank Device at bank address u1 1-5.  | DONE 
d0fd			; | | Zero is disabled storage. 
d0fd					if DEBUG_FORTH_WORDS_KEY 
d0fd						DMARK "BN?" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd					ld a, (spi_device_id) 
d0fd					sub '0' 
d0fd					ld h, 0 
d0fd					ld l, a 
d0fd					call forth_push_numhl 
d0fd					NEXTW 
d0fd			.SESELS: 
d0fd				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
d0fd			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
d0fd			; | | Set to zero to disable storage. 
d0fd					if DEBUG_FORTH_WORDS_KEY 
d0fd						DMARK "BNK" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			 
d0fd					ld a, 255 
d0fd					ld (spi_cartdev), a 
d0fd			 
d0fd					; get bank 
d0fd			 
d0fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0fd			 
d0fd			;		push hl 
d0fd			 
d0fd					; destroy value TOS 
d0fd			 
d0fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0fd			 
d0fd					; one value on hl get other one back 
d0fd			 
d0fd			;		pop hl 
d0fd			 
d0fd			 
d0fd					ld c, SPI_CE_HIGH 
d0fd					ld b, '0'    ; human readable bank number 
d0fd			 
d0fd					ld a, l 
d0fd			 
d0fd					if DEBUG_FORTH_WORDS 
d0fd						DMARK "BNK" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			 
d0fd					; active low 
d0fd			 
d0fd			;		cp 0 
d0fd					or a 
d0fd					jr z, .bset 
d0fd					cp 1 
d0fd					jr nz, .b2 
d0fd					res 0, c 
d0fd					ld b, '1'    ; human readable bank number 
d0fd			.b2:		cp 2 
d0fd					jr nz, .b3 
d0fd					res 1, c 
d0fd					ld b, '2'    ; human readable bank number 
d0fd			.b3:		cp 3 
d0fd					jr nz, .b4 
d0fd					res 2, c 
d0fd					ld b, '3'    ; human readable bank number 
d0fd			.b4:		cp 4 
d0fd					jr nz, .b5 
d0fd					res 3, c 
d0fd					ld b, '4'    ; human readable bank number 
d0fd			.b5:		cp 5 
d0fd					jr nz, .bset 
d0fd					res 4, c 
d0fd					ld b, '5'    ; human readable bank number 
d0fd			 
d0fd			.bset: 
d0fd					ld a, c 
d0fd					ld (spi_device),a 
d0fd					ld a, b 
d0fd					ld (spi_device_id),a 
d0fd					if DEBUG_FORTH_WORDS 
d0fd						DMARK "BN2" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			 
d0fd					; set default SPI clk pulse time as disabled for BANK use 
d0fd			 
d0fd					ld a, 0 
d0fd					ld (spi_clktime), a 
d0fd			 
d0fd					NEXTW 
d0fd			 
d0fd			.CARTDEV: 
d0fd				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
d0fd			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
d0fd			; | | Set to zero to disable devices. 
d0fd					if DEBUG_FORTH_WORDS_KEY 
d0fd						DMARK "CDV" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			 
d0fd					; disable se storage bank selection 
d0fd			 
d0fd					ld a, SPI_CE_HIGH		; ce high 
d0fd					ld (spi_device), a 
d0fd			 
d0fd					; get bank 
d0fd			 
d0fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0fd			 
d0fd			;		push hl 
d0fd			 
d0fd					; destroy value TOS 
d0fd			 
d0fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0fd			 
d0fd					; one value on hl get other one back 
d0fd			 
d0fd			;		pop hl 
d0fd			 
d0fd					; active low 
d0fd			 
d0fd					ld c, 255 
d0fd			 
d0fd					ld a, l 
d0fd					if DEBUG_FORTH_WORDS 
d0fd						DMARK "CDV" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			;		cp 0 
d0fd					or a 
d0fd					jr z, .cset 
d0fd					cp 1 
d0fd					jr nz, .c2 
d0fd					res 0, c 
d0fd			.c2:		cp 2 
d0fd					jr nz, .c3 
d0fd					res 1, c 
d0fd			.c3:		cp 3 
d0fd					jr nz, .c4 
d0fd					res 2, c 
d0fd			.c4:		cp 4 
d0fd					jr nz, .c5 
d0fd					res 3, c 
d0fd			.c5:		cp 5 
d0fd					jr nz, .c6 
d0fd					res 4, c 
d0fd			.c6:		cp 6 
d0fd					jr nz, .c7 
d0fd					res 5, c 
d0fd			.c7:		cp 7 
d0fd					jr nz, .c8 
d0fd					res 6, c 
d0fd			.c8:		cp 8 
d0fd					jr nz, .cset 
d0fd					res 7, c 
d0fd			.cset:		ld a, c 
d0fd					ld (spi_cartdev),a 
d0fd			 
d0fd					if DEBUG_FORTH_WORDS 
d0fd						DMARK "CD2" 
d0fd						CALLMONITOR 
d0fd					endif 
d0fd			 
d0fd					; set default SPI clk pulse time as 10ms for CARTDEV use 
d0fd			 
d0fd					ld a, $0a 
d0fd					ld (spi_clktime), a 
d0fd					NEXTW 
d0fd			endif 
d0fd			 
d0fd			.ENDDEVICE: 
d0fd			; eof 
d0fd			 
# End of file forth_words_device.asm
d0fd			 
d0fd			; var handler 
d0fd			 
d0fd			 
d0fd			.VARS: 
d0fd				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
d0fd 77				db WORD_SYS_CORE+99             
d0fe b1 d1			dw .V0            
d100 04				db 3 + 1 
d101 .. 00			db "VAR",0              
d105				endm 
# End of macro CWHEAD
d105			; | VAR ( u1 -- )  Get the address of the (word) variable referenced on TOS  | DONE 
d105			; | 
d105			; | | The variable name should consist of a single letter (a-z). e.g. "a" 
d105			; | |  
d105			; | | e.g. 
d105			; | |         #30 a var ! 
d105			; | |         a var @ . 
d105			; | |   
d105			; | |     Displays the number 30 
d105			; | | 
d105			; | | Each variable pointer is a word so can use for any words that use that:  
d105			; | |  
d105			; | | e.g. 
d105			; | |  
d105			; | |         #30 a var 2! 
d105			; | |         a var 2@ . 
d105			; | |   
d105			; | |     Displays the number 30 
d105			; | |  
d105			; | | > [!NOTE]  
d105			; ! | > If a full string is passed then only the first char is looked at 
d105			; | | > Any other char could exceed bounds checks!  
d105			; | | > 
d105			; | | > Each variable location follows the previous. Watch you don't clobber any others. 
d105			 
d105					if DEBUG_FORTH_WORDS_KEY 
d105						DMARK "VAR" 
d105 f5				push af  
d106 3a 1a d1			ld a, (.dmark)  
d109 32 5e ee			ld (debug_mark),a  
d10c 3a 1b d1			ld a, (.dmark+1)  
d10f 32 5f ee			ld (debug_mark+1),a  
d112 3a 1c d1			ld a, (.dmark+2)  
d115 32 60 ee			ld (debug_mark+2),a  
d118 18 03			jr .pastdmark  
d11a ..			.dmark: db "VAR"  
d11d f1			.pastdmark: pop af  
d11e			endm  
# End of macro DMARK
d11e						CALLMONITOR 
d11e cd 6b ee			call debug_vector  
d121				endm  
# End of macro CALLMONITOR
d121					endif 
d121			 
d121					FORTH_DSP_VALUEHL 
d121 cd c8 9b			call macro_dsp_valuehl 
d124				endm 
# End of macro FORTH_DSP_VALUEHL
d124			 
d124 7e					ld a, (hl)    ; get first char on of the string 
d125			 
d125			 
d125					if DEBUG_FORTH_WORDS 
d125						DMARK "VR1" 
d125 f5				push af  
d126 3a 3a d1			ld a, (.dmark)  
d129 32 5e ee			ld (debug_mark),a  
d12c 3a 3b d1			ld a, (.dmark+1)  
d12f 32 5f ee			ld (debug_mark+1),a  
d132 3a 3c d1			ld a, (.dmark+2)  
d135 32 60 ee			ld (debug_mark+2),a  
d138 18 03			jr .pastdmark  
d13a ..			.dmark: db "VR1"  
d13d f1			.pastdmark: pop af  
d13e			endm  
# End of macro DMARK
d13e						CALLMONITOR 
d13e cd 6b ee			call debug_vector  
d141				endm  
# End of macro CALLMONITOR
d141					endif 
d141					 
d141 f5					push af	 
d142					FORTH_DSP_POP 
d142 cd 80 9c			call macro_forth_dsp_pop 
d145				endm 
# End of macro FORTH_DSP_POP
d145 f1					pop af 
d146			 
d146					; convert to upper 
d146			 
d146 cd 43 8f				call to_upper 
d149					if DEBUG_FORTH_WORDS 
d149						DMARK "Vaa" 
d149 f5				push af  
d14a 3a 5e d1			ld a, (.dmark)  
d14d 32 5e ee			ld (debug_mark),a  
d150 3a 5f d1			ld a, (.dmark+1)  
d153 32 5f ee			ld (debug_mark+1),a  
d156 3a 60 d1			ld a, (.dmark+2)  
d159 32 60 ee			ld (debug_mark+2),a  
d15c 18 03			jr .pastdmark  
d15e ..			.dmark: db "Vaa"  
d161 f1			.pastdmark: pop af  
d162			endm  
# End of macro DMARK
d162						CALLMONITOR 
d162 cd 6b ee			call debug_vector  
d165				endm  
# End of macro CALLMONITOR
d165					endif 
d165 06 41				ld b, 'A' 
d167 90					sub b			; set offset 
d168					if DEBUG_FORTH_WORDS 
d168						DMARK "Vbb" 
d168 f5				push af  
d169 3a 7d d1			ld a, (.dmark)  
d16c 32 5e ee			ld (debug_mark),a  
d16f 3a 7e d1			ld a, (.dmark+1)  
d172 32 5f ee			ld (debug_mark+1),a  
d175 3a 7f d1			ld a, (.dmark+2)  
d178 32 60 ee			ld (debug_mark+2),a  
d17b 18 03			jr .pastdmark  
d17d ..			.dmark: db "Vbb"  
d180 f1			.pastdmark: pop af  
d181			endm  
# End of macro DMARK
d181						CALLMONITOR 
d181 cd 6b ee			call debug_vector  
d184				endm  
# End of macro CALLMONITOR
d184					endif 
d184 cb 27				sla a  
d186				 
d186					 
d186					if DEBUG_FORTH_WORDS 
d186						DMARK "VR2" 
d186 f5				push af  
d187 3a 9b d1			ld a, (.dmark)  
d18a 32 5e ee			ld (debug_mark),a  
d18d 3a 9c d1			ld a, (.dmark+1)  
d190 32 5f ee			ld (debug_mark+1),a  
d193 3a 9d d1			ld a, (.dmark+2)  
d196 32 60 ee			ld (debug_mark+2),a  
d199 18 03			jr .pastdmark  
d19b ..			.dmark: db "VR2"  
d19e f1			.pastdmark: pop af  
d19f			endm  
# End of macro DMARK
d19f						CALLMONITOR 
d19f cd 6b ee			call debug_vector  
d1a2				endm  
# End of macro CALLMONITOR
d1a2					endif 
d1a2			 
d1a2 21 e7 e9				ld hl, cli_var_array2 
d1a5 cd db 8c				call addatohl 
d1a8 cd cc 99				call forth_push_numhl 
d1ab			 
d1ab			 
d1ab				       NEXTW 
d1ab cd 68 ee			call parse_vector 
d1ae c3 af 9d			jp macro_next 
d1b1				endm 
# End of macro NEXTW
d1b1			.V0: 
d1b1				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
d1b1 78				db WORD_SYS_CORE+100             
d1b2 cc d1			dw .V0Q            
d1b4 04				db 3 + 1 
d1b5 .. 00			db "V0!",0              
d1b9				endm 
# End of macro CWHEAD
d1b9			;| V0! ( u1 -- )  Store value to v0  | DONE 
d1b9			 
d1b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d1b9 cd c8 9b			call macro_dsp_valuehl 
d1bc				endm 
# End of macro FORTH_DSP_VALUEHL
d1bc			 
d1bc 11 1b ea				ld de, cli_var_array 
d1bf			 
d1bf eb					ex de, hl 
d1c0 73					ld (hl), e 
d1c1 23					inc hl 
d1c2 72					ld (hl), d 
d1c3			 
d1c3					; destroy value TOS 
d1c3			 
d1c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d1c3 cd 80 9c			call macro_forth_dsp_pop 
d1c6				endm 
# End of macro FORTH_DSP_POP
d1c6			 
d1c6				       NEXTW 
d1c6 cd 68 ee			call parse_vector 
d1c9 c3 af 9d			jp macro_next 
d1cc				endm 
# End of macro NEXTW
d1cc			.V0Q: 
d1cc				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
d1cc 79				db WORD_SYS_CORE+101             
d1cd e0 d1			dw .V1S            
d1cf 04				db 3 + 1 
d1d0 .. 00			db "V0@",0              
d1d4				endm 
# End of macro CWHEAD
d1d4			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
d1d4 2a 1b ea				ld hl, (cli_var_array) 
d1d7 cd cc 99				call forth_push_numhl 
d1da			 
d1da				       NEXTW 
d1da cd 68 ee			call parse_vector 
d1dd c3 af 9d			jp macro_next 
d1e0				endm 
# End of macro NEXTW
d1e0			.V1S: 
d1e0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
d1e0 7a				db WORD_SYS_CORE+102             
d1e1 fb d1			dw .V1Q            
d1e3 04				db 3 + 1 
d1e4 .. 00			db "V1!",0              
d1e8				endm 
# End of macro CWHEAD
d1e8			;| V1! ( u1 -- )  Store value to v1 | DONE 
d1e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d1e8 cd c8 9b			call macro_dsp_valuehl 
d1eb				endm 
# End of macro FORTH_DSP_VALUEHL
d1eb			 
d1eb 11 1d ea				ld de, cli_var_array+2 
d1ee				 
d1ee eb					ex de, hl 
d1ef 73					ld (hl), e 
d1f0 23					inc hl 
d1f1 72					ld (hl), d 
d1f2			 
d1f2					; destroy value TOS 
d1f2			 
d1f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d1f2 cd 80 9c			call macro_forth_dsp_pop 
d1f5				endm 
# End of macro FORTH_DSP_POP
d1f5				       NEXTW 
d1f5 cd 68 ee			call parse_vector 
d1f8 c3 af 9d			jp macro_next 
d1fb				endm 
# End of macro NEXTW
d1fb			.V1Q: 
d1fb				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
d1fb 7b				db WORD_SYS_CORE+103             
d1fc 0f d2			dw .V2S            
d1fe 04				db 3 + 1 
d1ff .. 00			db "V1@",0              
d203				endm 
# End of macro CWHEAD
d203			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
d203 2a 1d ea				ld hl, (cli_var_array+2) 
d206 cd cc 99				call forth_push_numhl 
d209				       NEXTW 
d209 cd 68 ee			call parse_vector 
d20c c3 af 9d			jp macro_next 
d20f				endm 
# End of macro NEXTW
d20f			.V2S: 
d20f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
d20f 7c				db WORD_SYS_CORE+104             
d210 2a d2			dw .V2Q            
d212 04				db 3 + 1 
d213 .. 00			db "V2!",0              
d217				endm 
# End of macro CWHEAD
d217			;| V2! ( u1 -- )  Store value to v2 | DONE 
d217					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d217 cd c8 9b			call macro_dsp_valuehl 
d21a				endm 
# End of macro FORTH_DSP_VALUEHL
d21a			 
d21a 11 1f ea				ld de, cli_var_array+4 
d21d				 
d21d eb					ex de, hl 
d21e 73					ld (hl), e 
d21f 23					inc hl 
d220 72					ld (hl), d 
d221			 
d221					; destroy value TOS 
d221			 
d221					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d221 cd 80 9c			call macro_forth_dsp_pop 
d224				endm 
# End of macro FORTH_DSP_POP
d224				       NEXTW 
d224 cd 68 ee			call parse_vector 
d227 c3 af 9d			jp macro_next 
d22a				endm 
# End of macro NEXTW
d22a			.V2Q: 
d22a				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
d22a 7d				db WORD_SYS_CORE+105             
d22b 3e d2			dw .V3S            
d22d 04				db 3 + 1 
d22e .. 00			db "V2@",0              
d232				endm 
# End of macro CWHEAD
d232			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
d232 2a 1f ea				ld hl, (cli_var_array+4) 
d235 cd cc 99				call forth_push_numhl 
d238				       NEXTW 
d238 cd 68 ee			call parse_vector 
d23b c3 af 9d			jp macro_next 
d23e				endm 
# End of macro NEXTW
d23e			.V3S: 
d23e				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
d23e 7c				db WORD_SYS_CORE+104             
d23f 59 d2			dw .V3Q            
d241 04				db 3 + 1 
d242 .. 00			db "V3!",0              
d246				endm 
# End of macro CWHEAD
d246			;| V3! ( u1 -- )  Store value to v3 | DONE 
d246					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d246 cd c8 9b			call macro_dsp_valuehl 
d249				endm 
# End of macro FORTH_DSP_VALUEHL
d249			 
d249 11 21 ea				ld de, cli_var_array+6 
d24c				 
d24c eb					ex de, hl 
d24d 73					ld (hl), e 
d24e 23					inc hl 
d24f 72					ld (hl), d 
d250			 
d250					; destroy value TOS 
d250			 
d250					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d250 cd 80 9c			call macro_forth_dsp_pop 
d253				endm 
# End of macro FORTH_DSP_POP
d253				       NEXTW 
d253 cd 68 ee			call parse_vector 
d256 c3 af 9d			jp macro_next 
d259				endm 
# End of macro NEXTW
d259			.V3Q: 
d259				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
d259 7d				db WORD_SYS_CORE+105             
d25a 6d d2			dw .END            
d25c 04				db 3 + 1 
d25d .. 00			db "V3@",0              
d261				endm 
# End of macro CWHEAD
d261			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
d261 2a 21 ea				ld hl, (cli_var_array+6) 
d264 cd cc 99				call forth_push_numhl 
d267				       NEXTW 
d267 cd 68 ee			call parse_vector 
d26a c3 af 9d			jp macro_next 
d26d				endm 
# End of macro NEXTW
d26d			 
d26d			 
d26d			 
d26d			 
d26d			 
d26d			; end of dict marker 
d26d			 
d26d 00			.END:    db WORD_SYS_END 
d26e 00 00			dw 0 
d270 00				db 0 
d271			 
d271			; use to jp here for user dict words to save on macro expansion  
d271			 
d271			user_dict_next: 
d271				NEXTW 
d271 cd 68 ee			call parse_vector 
d274 c3 af 9d			jp macro_next 
d277				endm 
# End of macro NEXTW
d277			 
d277			 
d277			user_exec: 
d277				;    ld hl, <word code> 
d277				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
d277				;    call forthexec 
d277				;    jp user_dict_next   (NEXT) 
d277			        ;    <word code bytes> 
d277 eb				ex de, hl 
d278 2a b5 e5			ld hl,(os_tok_ptr) 
d27b				 
d27b				FORTH_RSP_NEXT 
d27b cd 73 99			call macro_forth_rsp_next 
d27e				endm 
# End of macro FORTH_RSP_NEXT
d27e			 
d27e			if DEBUG_FORTH_UWORD 
d27e						DMARK "UEX" 
d27e f5				push af  
d27f 3a 93 d2			ld a, (.dmark)  
d282 32 5e ee			ld (debug_mark),a  
d285 3a 94 d2			ld a, (.dmark+1)  
d288 32 5f ee			ld (debug_mark+1),a  
d28b 3a 95 d2			ld a, (.dmark+2)  
d28e 32 60 ee			ld (debug_mark+2),a  
d291 18 03			jr .pastdmark  
d293 ..			.dmark: db "UEX"  
d296 f1			.pastdmark: pop af  
d297			endm  
# End of macro DMARK
d297				CALLMONITOR 
d297 cd 6b ee			call debug_vector  
d29a				endm  
# End of macro CALLMONITOR
d29a			endif 
d29a			 
d29a			 
d29a			 
d29a eb				ex de, hl 
d29b 22 b5 e5			ld (os_tok_ptr), hl 
d29e				 
d29e				; Don't use next - Skips the first word in uword. 
d29e			 
d29e c3 30 9e			jp exec1 
d2a1			;	NEXT 
d2a1			 
d2a1			 
d2a1			; eof 
# End of file forth_wordsv4.asm
d2a1			endif 
d2a1			;;;;;;;;;;;;;; Debug code 
d2a1			 
d2a1			 
d2a1			;if DEBUG_FORTH_PARSE 
d2a1 .. 00		.nowordfound: db "No match",0 
d2aa .. 00		.compword:	db "Comparing word ",0 
d2ba .. 00		.nextwordat:	db "Next word at",0 
d2c7 .. 00		.charmatch:	db "Char match",0 
d2d2			;endif 
d2d2			if DEBUG_FORTH_JP 
d2d2			.foundword:	db "Word match. Exec..",0 
d2d2			endif 
d2d2			;if DEBUG_FORTH_PUSH 
d2d2 .. 00		.enddict:	db "Dict end. Push.",0 
d2e2 .. 00		.push_str:	db "Pushing string",0 
d2f1 .. 00		.push_num:	db "Pushing number",0 
d300 .. 00		.data_sp:	db "SP:",0 
d304 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
d316 .. 00		.wordinde:	db "Word in DE (3/0):",0 
d328 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
d33a			;endif 
d33a			;if DEBUG_FORTH_MALLOC 
d33a .. 00		.push_malloc:	db "Malloc address",0 
d349			;endif 
d349			 
d349			 
d349			 
d349			; display malloc address and current data stack pointer  
d349			 
d349			malloc_error: 
d349 d5				push de 
d34a f5				push af 
d34b e5				push hl 
d34c cd b1 8a			call clear_display 
d34f 11 6f d3			ld de, .mallocerr 
d352 3e 00			ld a,0 
d354			;	ld de,os_word_scratch 
d354 cd c3 8a			call str_at_display 
d357 3e 11			ld a, display_row_1+17 
d359 11 5e ee			ld de, debug_mark 
d35c cd c3 8a			call str_at_display 
d35f cd d3 8a			call update_display 
d362				;call break_point_state 
d362 cd 27 e6			call cin_wait 
d365			 
d365			;	ld a, ' ' 
d365			;	ld (os_view_disable), a 
d365 cd 4b 93			call bp_on 
d368 e1				pop hl 
d369 f1				pop af 
d36a d1				pop de	 
d36b				CALLMONITOR 
d36b cd 6b ee			call debug_vector  
d36e				endm  
# End of macro CALLMONITOR
d36e c9				ret 
d36f			 
d36f .. 00		.mallocerr: 	db "Malloc Error",0 
d37c			;if DEBUG_FORTH_PUSH 
d37c			display_data_sp: 
d37c f5				push af 
d37d			 
d37d				; see if disabled 
d37d			 
d37d			 
d37d 3a 6b ee			ld a, (debug_vector) 
d380 fe c9			cp $C9  ; RET 
d382				;ld a, (os_view_disable) 
d382				;cp '*' 
d382 28 65			jr z, .skipdsp 
d384			 
d384 e5				push hl 
d385 e5				push hl 
d386 e5			push hl 
d387 cd b1 8a			call clear_display 
d38a e1			pop hl 
d38b 7c				ld a,h 
d38c 21 b9 e5			ld hl, os_word_scratch 
d38f cd d7 8e			call hexout 
d392 e1				pop hl 
d393 7d				ld a,l 
d394 21 bb e5			ld hl, os_word_scratch+2 
d397 cd d7 8e			call hexout 
d39a 21 bd e5			ld hl, os_word_scratch+4 
d39d			;	ld a,0 
d39d 36 00			ld (hl),0 
d39f 11 b9 e5			ld de,os_word_scratch 
d3a2 3e 28				ld a, display_row_2 
d3a4 cd c3 8a				call str_at_display 
d3a7 11 04 d3			ld de, .wordinhl 
d3aa 3e 00			ld a, display_row_1 
d3ac			 
d3ac cd c3 8a				call str_at_display 
d3af 11 5e ee			ld de, debug_mark 
d3b2 3e 11			ld a, display_row_1+17 
d3b4			 
d3b4 cd c3 8a				call str_at_display 
d3b7			 
d3b7				; display current data stack pointer 
d3b7 11 00 d3			ld de,.data_sp 
d3ba 3e 30				ld a, display_row_2 + 8 
d3bc cd c3 8a				call str_at_display 
d3bf			 
d3bf 2a e1 e9			ld hl,(cli_data_sp) 
d3c2 e5				push hl 
d3c3 7c				ld a,h 
d3c4 21 b9 e5			ld hl, os_word_scratch 
d3c7 cd d7 8e			call hexout 
d3ca e1				pop hl 
d3cb 7d				ld a,l 
d3cc 21 bb e5			ld hl, os_word_scratch+2 
d3cf cd d7 8e			call hexout 
d3d2 21 bd e5			ld hl, os_word_scratch+4 
d3d5			;	ld a,0 
d3d5 36 00			ld (hl),0 
d3d7 11 b9 e5			ld de,os_word_scratch 
d3da 3e 33				ld a, display_row_2 + 11 
d3dc cd c3 8a				call str_at_display 
d3df			 
d3df			 
d3df cd d3 8a			call update_display 
d3e2 cd f0 89			call delay1s 
d3e5 cd f0 89			call delay1s 
d3e8 e1				pop hl 
d3e9			.skipdsp: 
d3e9 f1				pop af 
d3ea c9				ret 
d3eb			 
d3eb			display_data_malloc: 
d3eb			 
d3eb f5				push af 
d3ec e5				push hl 
d3ed e5				push hl 
d3ee e5			push hl 
d3ef cd b1 8a			call clear_display 
d3f2 e1			pop hl 
d3f3 7c				ld a,h 
d3f4 21 b9 e5			ld hl, os_word_scratch 
d3f7 cd d7 8e			call hexout 
d3fa e1				pop hl 
d3fb 7d				ld a,l 
d3fc 21 bb e5			ld hl, os_word_scratch+2 
d3ff cd d7 8e			call hexout 
d402 21 bd e5			ld hl, os_word_scratch+4 
d405			;	ld a,0 
d405 36 00			ld (hl),0 
d407 11 b9 e5			ld de,os_word_scratch 
d40a 3e 28				ld a, display_row_2 
d40c cd c3 8a				call str_at_display 
d40f 11 3a d3			ld de, .push_malloc 
d412 3e 00			ld a, display_row_1 
d414			 
d414 cd c3 8a				call str_at_display 
d417			 
d417				; display current data stack pointer 
d417 11 00 d3			ld de,.data_sp 
d41a 3e 30				ld a, display_row_2 + 8 
d41c cd c3 8a				call str_at_display 
d41f			 
d41f 2a e1 e9			ld hl,(cli_data_sp) 
d422 e5				push hl 
d423 7c				ld a,h 
d424 21 b9 e5			ld hl, os_word_scratch 
d427 cd d7 8e			call hexout 
d42a e1				pop hl 
d42b 7d				ld a,l 
d42c 21 bb e5			ld hl, os_word_scratch+2 
d42f cd d7 8e			call hexout 
d432 21 bd e5			ld hl, os_word_scratch+4 
d435			;	ld a,0 
d435 36 00			ld (hl),0 
d437 11 b9 e5			ld de,os_word_scratch 
d43a 3e 33				ld a, display_row_2 + 11 
d43c cd c3 8a				call str_at_display 
d43f			 
d43f cd d3 8a			call update_display 
d442 cd f0 89			call delay1s 
d445 cd f0 89			call delay1s 
d448 e1				pop hl 
d449 f1				pop af 
d44a c9				ret 
d44b			;endif 
d44b			 
d44b			include "forth_autostart.asm" 
d44b			; list of commands to perform at system start up 
d44b			 
d44b			startcmds: 
d44b			;	dw test11 
d44b			;	dw test12 
d44b			;	dw test13 
d44b			;	dw test14 
d44b			;	dw test15 
d44b			;	dw test16 
d44b			;	dw test17 
d44b			;	dw ifthtest1 
d44b			;	dw ifthtest2 
d44b			;	dw ifthtest3 
d44b			;	dw mmtest1 
d44b			;	dw mmtest2 
d44b			;	dw mmtest3 
d44b			;	dw mmtest4 
d44b			;	dw mmtest5 
d44b			;	dw mmtest6 
d44b			;	dw iftest1 
d44b			;	dw iftest2 
d44b			;	dw iftest3 
d44b			;	dw looptest1 
d44b			;	dw looptest2 
d44b			;	dw test1 
d44b			;	dw test2 
d44b			;	dw test3 
d44b			;	dw test4 
d44b			;	dw game2r 
d44b			;	dw game2b1 
d44b			;	dw game2b2 
d44b			 
d44b				; start up words that are actually useful 
d44b			 
d44b			;    dw spi1 
d44b			;    dw spi2 
d44b			;    dw spi3 
d44b			;    dw spi4 
d44b			;    dw spi5 
d44b			;    dw spi6 
d44b			;    dw spi7 
d44b			; 
d44b			;    dw spi8 
d44b			;    dw spi9 
d44b			;    dw spi10 
d44b			 
d44b			; file editor 
d44b			;	dw edit1 
d44b			;	dw edit2 
d44b			;	dw edit3 
d44b			 
d44b			;	dw longread 
d44b c0 d9			dw clrstack 
d44d f4 d9			dw type 
d44f 19 da			dw ztype 
d451 c0 db			dw nip 
d453 ad db			dw tuck 
d455			;	dw stest 
d455 50 da			dw strncpy 
d457 d2 db			dw list 
d459 b1 da			dw start1 
d45b c1 da			dw start2 
d45d			;	dw start3 
d45d			;	dw start3b 
d45d			;	dw start3c 
d45d			 
d45d				; (unit) testing words 
d45d			 
d45d			;	dw mtesta 
d45d			;	dw mtestb 
d45d			;	dw mtestc 
d45d			;	dw mtestd 
d45d			;	dw mteste 
d45d			 
d45d				; demo/game words 
d45d			 
d45d			;        dw game3w 
d45d			;        dw game3p 
d45d			;        dw game3sc 
d45d			;        dw game3vsi 
d45d			;        dw game3vs 
d45d				 
d45d			;	dw game2b 
d45d			;	dw game2bf 
d45d			;	dw game2mba 
d45d			;	dw game2mbas 
d45d			;	dw game2mb 
d45d			 
d45d 03 de			dw game1 
d45f 14 de			dw game1a 
d461 76 de			dw game1b 
d463 ab de			dw game1c 
d465 e1 de			dw game1d 
d467 12 df			dw game1s 
d469 26 df			dw game1t 
d46b 3b df			dw game1f 
d46d 6f df			dw game1z 
d46f b3 df			dw game1zz 
d471			 
d471 3c dc			dw test5 
d473 74 dc			dw test6 
d475 ac dc			dw test7 
d477 c0 dc			dw test8 
d479 ec dc			dw test9 
d47b 02 dd			dw test10 
d47d				 
d47d 8a e0		        dw ssv5 
d47f 6e e0		        dw ssv4 
d481 52 e0		        dw ssv3 
d483 1c e0		        dw ssv2 
d485 a3 e0		        dw ssv1 
d487 eb e0		        dw ssv1cpm 
d489			;	dw keyup 
d489			;	dw keydown 
d489			;	dw keyleft 
d489			;	dw keyright 
d489			;	dw 	keyf1 
d489			;	dw keyf2 
d489			;	dw keyf3 
d489			;	dw keyf4 
d489			;	dw keyf5 
d489			;	dw keyf6 
d489			;	dw keyf7 
d489			;	dw keyf8 
d489			;	dw keyf9 
d489			;	dw keyf10 
d489			;	dw keyf11 
d489			;	dw keyf12 
d489			;	dw keytab 
d489			;	dw keycr 
d489			;	dw keyhome 
d489			;	dw keyend 
d489			;	dw keybs 
d489 00 00			db 0, 0	 
d48b			 
d48b			 
d48b			; File Editor 
d48b			 
d48b			; ( id - ) use 'e' to edit the displayed line 
d48b .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
d4ac .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d4e1			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d4e1 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d519			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d519			 
d519			; SPI Net support words 
d519			 
d519			; v0! = node to send to 
d519			; ( str count - ) 
d519 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d572			 
d572			; spiputc ( char node - ) 
d572 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d5a6			; spiputc ( u node - ) 
d5a6 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d5d4			 
d5d4			; spigetc ( - n ) 
d5d4 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d5fd			 
d5fd			; getnode ( - n ) 
d5fd .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d62a			 
d62a			; ( str node - )  
d62a .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d690			; store string ( str i - ) 
d690			 
d690			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d690 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d6e5			 
d6e5			; get string ( addr i -  )    TO FIX 
d6e5			 
d6e5 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d73d			 
d73d			 
d73d			; user word backup 
d73d			; ubie 
d73d			; ubiall 
d73d			 
d73d .. 00		spib1: db ": UBIALL $01 do cls ptr count type list cr concat count soctype 2drop loop ;",0 
d78a .. 00		spib2: db ": UBIE $01 do cls ptr count type waitk $79 = if list cr concat count soctype drop then 2drop loop ;", 0 
d7ee .. 00		spib3: db ": SPISTRZ ptr count $00 do dup i + @ spio $01 pause loop ;",0 
d829 .. 00		spib4: db ": SOCCON spicel $22 spio spistrz ;",0 
d84c .. 00		spib5: db ": SOCTYPE spiceh spicel $00 do dup i + @ $20 spio spio loop ;",0 
d88a			 
d88a			 
d88a			; NETCHAT (TODO) 
d88a			; Program to allow two nodes to chat with eachother 
d88a			; 
d88a			; v0 - target node 
d88a			;  
d88a			; accept input at 0,0 
d88a			; if input is string send spitype to target node 
d88a			; starting at row 2,0 , while spigetchr is not zero ->  
d88a			; 
d88a			; 
d88a			; TODO add paging of get request 
d88a			 
d88a			; ( node - ) 
d88a .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d8a9 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d901 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d979			 
d979			 
d979			; Long read of currently open file 
d979 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d9c0			 
d9c0			; clear stack  
d9c0			 
d9c0 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d9f4			 
d9f4			; type ( addr count - ) 
d9f4 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
da19 .. 00		ztype:     db ": ztype repeat dup @ emit #1 + dup @ #0 = not until ; ", 0 
da50			 
da50			; some direct memory words 
da50			; strncpy ( len t f -- t ) 
da50			 
da50 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
dab1			 
dab1 .. 00		start1:     	db ": bpon $00 bp ;",0 
dac1 .. 00		start2:     	db ": bpoff $01 bp ;",0 
dad2 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
db4d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
dbad			 
dbad .. 00		tuck:         db ": tuck swap over ;", 0 
dbc0 .. 00		nip:         db ": nip swap drop ;", 0 
dbd2			 
dbd2			; a handy word to list items on the stack 
dbd2			 
dbd2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
dc3c			 
dc3c			 
dc3c			; test stack  
dc3c			; rnd8 stest 
dc3c			 
dc3c			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
dc3c			 
dc3c			; random malloc and free cycles 
dc3c			 
dc3c			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
dc3c			 
dc3c			; fixed malloc and free cycles 
dc3c			 
dc3c			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
dc3c			 
dc3c			; fixed double string push and drop cycle  
dc3c			 
dc3c			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
dc3c			 
dc3c			; consistent fixed string push and drop cycle  
dc3c			 
dc3c			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
dc3c			 
dc3c			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
dc3c			 
dc3c			;test1:		db ": aa 1 2 3 ;", 0 
dc3c			;test2:     	db "111 aa 888 999",0 
dc3c			;test3:     	db ": bb 77 ;",0 
dc3c			;test4:     	db "$02 $01 do i . loop bb",0 
dc3c			 
dc3c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
dc74 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
dcac .. 00		test7:     	db ": box hline vline ;",0 
dcc0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
dcec .. 00		test9:     	db ": sw $01 adsp world ;",0 
dd02 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
dd27			;test11:     	db "hello create .",0 
dd27			;test12:     	db "hello2 create .",0 
dd27			 
dd27			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
dd27			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
dd27			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
dd27			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
dd27			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
dd27			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
dd27			 
dd27			;iftest1:     	db "$0001 IF cls .",0 
dd27			;iftest2:     	db "$0000 IF cls .",0 
dd27			;iftest3:     	db "$0002 $0003 - IF cls .",0 
dd27			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
dd27			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
dd27			 
dd27			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
dd27			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
dd27			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
dd27			 
dd27			 
dd27 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
dd4b .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
dd7b .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
dda0 .. 00		sound4: db ": cha $00 ; ",0 
ddad .. 00		sound5: db ": chb $20 ; ",0 
ddba .. 00		sound6: db ": chc $40 ; ",0 
ddc7 .. 00		sound7: db ": chd $60 ; ",0 
ddd4 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
ddec .. 00		sound9: db ": cvol $90 + + note ; ", 0 
de03			 
de03			 
de03			 
de03			 
de03			; a small guess the number game 
de03			 
de03 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
de14 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
de76			 
de76 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
deab .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
dee1 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
df12 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
df26 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
df3b .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
df6f .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dfb3			 
dfb3			; Using 'ga' save a high score across multiple runs using external storage 
dfb3			 
dfb3 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
e01c			 
e01c			 
e01c			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
e01c			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
e01c			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
e01c			 
e01c			; simple screen saver to test code memory reuse to destruction 
e01c			 
e01c .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
e052 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
e06e .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
e08a .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
e0a3 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
e0eb .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
e142			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
e142			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
e142			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
e142			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
e142			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
e142			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
e142			 
e142			 
e142			 
e142			; minesweeper/battleship finding game 
e142			; draws a game board of random ship/mine positions 
e142			; user enters coords to see if it hits on 
e142			; game ends when all are hit 
e142			; when hit or miss says how many may be in the area 
e142			 
e142			; setup the game board and then hide it 
e142			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
e142			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
e142			;; prompt for where to target 
e142			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
e142			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
e142			;; TODO see if the entered coords hits or misses pushes char hit of miss 
e142			;game2mbht:      db ": mbckht nop ;",0 
e142			;game2mbms:      db ": mbcms nop ;",0 
e142			; TODO how many might be near by 
e142			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
e142			 
e142			; Game 3 
e142			 
e142			; Vert scroller ski game - avoid the trees! 
e142			 
e142			; v0 score (ie turns) 
e142			; v1 player pos 
e142			; v2 left wall 
e142			; v3 right wall 
e142			 
e142			; Draw side walls randomly 
e142			 
e142			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
e142			 
e142			; Draw player 
e142			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
e142			 
e142			; TODO Get Key 
e142			 
e142			; TODO Move left right 
e142			 
e142			; scroll and move walls a bit 
e142			 
e142			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
e142			 
e142			; main game loop 
e142			 
e142			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
e142			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
e142			 
e142			; key board defs 
e142			 
e142 .. 00		keyup:       db ": keyup $05 ;",0 
e150 .. 00		keydown:       db ": keydown $0a ;",0 
e160 .. 00		keyleft:       db ": keyleft $0b ;",0 
e170 .. 00		keyright:       db ": keyright $0c ;",0 
e181 .. 00		keyf1:       db ": keyf1 $10 ;",0 
e18f .. 00		keyf2:       db ": keyf2 $11 ;",0 
e19d .. 00		keyf3:       db ": keyf3 $12 ;",0 
e1ab .. 00		keyf4:       db ": keyf4 $13 ;",0 
e1b9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
e1c7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
e1d5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
e1e3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
e1f1 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e1ff .. 00		keyf10:       db ": keyf10 $19 ;",0 
e20e .. 00		keyf11:       db ": keyf11 $1a ;",0 
e21d .. 00		keyf12:       db ": keyf12 $1b ;",0 
e22c			 
e22c .. 00		keytab:       db ": keytab $09 ;",0 
e23b .. 00		keycr:       db ": keycr $0d ;",0 
e249 .. 00		keyhome:       db ": keyhome $0e ;",0 
e259 .. 00		keyend:       db ": keyend $0f ;",0 
e268 .. 00		keybs:       db ": keybs $08 ;",0 
e276			 
e276			   
e276			 
e276			 
e276			 
e276			; eof 
# End of file forth_autostart.asm
e276			 
e276			 
e276			 
e276			; stack over and underflow checks 
e276			 
e276			; init the words to detect the under/overflow 
e276			 
e276			chk_stk_init: 
e276				; a vague random number to check so we dont get any "lucky" hits 
e276 3e 2d			ld a, 45 
e278 6f				ld l, a 
e279 00				nop 
e27a 3e 17			ld a, 23 
e27c 67				ld h, a 
e27d			 
e27d 22 90 e2			ld (chk_word), hl     ; the word we need to check against 
e280			 
e280			;	ld (chk_stund), hl	; stack points.... 
e280 22 00 ef			ld (chk_stovr), hl 
e283 22 df e9			ld (chk_ret_und), hl 
e286 22 9d e9			ld (chk_ret_ovr), hl 
e289 22 1b e9			ld (chk_loop_ovr), hl 
e28c 22 19 e8			ld (chk_data_ovr), hl 
e28f c9				ret 
e290				 
e290			check_stacks: 
e290				; check all stack words 
e290			 
e290 e5				push hl 
e291 d5				push de 
e292			 
e292			;	ld de,(chk_word) 
e292			;	ld hl, (chk_stund)	; stack points.... 
e292			;	if DEBUG_STK_FAULT 
e292			;		DMARK "FAa" 
e292			;		CALLMONITOR 
e292			;	endif 
e292			;	call cmp16 
e292			;	jp z, .chk_faulta 
e292			; 
e292			;	ld de, sfaultsu 
e292			;	jp .chk_fault 
e292			 
e292 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e295 ed 5b 90 e2		ld de,(chk_word) 
e299				if DEBUG_STK_FAULT 
e299					DMARK "FAb" 
e299					CALLMONITOR 
e299				endif 
e299 cd f9 8c			call cmp16 
e29c 28 06			jr z, .chk_fault1 
e29e 11 42 e3			ld de, sfaultso 
e2a1 c3 f3 e2			jp .chk_fault 
e2a4			.chk_fault1:  
e2a4 2a df e9			ld hl, (chk_ret_und) 
e2a7 ed 5b 90 e2		ld de,(chk_word) 
e2ab				if DEBUG_STK_FAULT 
e2ab					DMARK "FAU" 
e2ab					CALLMONITOR 
e2ab				endif 
e2ab cd f9 8c			call cmp16 
e2ae ca b7 e2			jp z, .chk_fault2 
e2b1 11 52 e3			ld de, sfaultru 
e2b4 c3 f3 e2			jp .chk_fault 
e2b7			.chk_fault2:  
e2b7 2a 9d e9			ld hl, (chk_ret_ovr) 
e2ba ed 5b 90 e2		ld de,(chk_word) 
e2be				if DEBUG_STK_FAULT 
e2be					DMARK "FA1" 
e2be					CALLMONITOR 
e2be				endif 
e2be cd f9 8c			call cmp16 
e2c1 ca ca e2			jp z, .chk_fault3 
e2c4 11 60 e3			ld de, sfaultro 
e2c7 c3 f3 e2			jp .chk_fault 
e2ca			.chk_fault3:  
e2ca 2a 1b e9			ld hl, (chk_loop_ovr) 
e2cd ed 5b 90 e2		ld de,(chk_word) 
e2d1				if DEBUG_STK_FAULT 
e2d1					DMARK "FA2" 
e2d1					CALLMONITOR 
e2d1				endif 
e2d1 cd f9 8c			call cmp16 
e2d4 ca dd e2			jp z, .chk_fault4 
e2d7 11 7a e3			ld de, sfaultlo 
e2da c3 f3 e2			jp .chk_fault 
e2dd			.chk_fault4:  
e2dd 2a 19 e8			ld hl, (chk_data_ovr) 
e2e0 ed 5b 90 e2		ld de,(chk_word) 
e2e4				if DEBUG_STK_FAULT 
e2e4					DMARK "FA3" 
e2e4					CALLMONITOR 
e2e4				endif 
e2e4 cd f9 8c			call cmp16 
e2e7 ca f0 e2			jp z, .chk_fault5 
e2ea 11 94 e3			ld de, sfaultdo 
e2ed c3 f3 e2			jp .chk_fault 
e2f0			 
e2f0			 
e2f0			.chk_fault5:  
e2f0 d1				pop de 
e2f1 e1				pop hl 
e2f2			 
e2f2 c9				ret 
e2f3			 
e2f3 cd b1 8a		.chk_fault: 	call clear_display 
e2f6 3e 28				ld a, display_row_2 
e2f8 cd c3 8a				call str_at_display 
e2fb 11 24 e3				   ld de, .stackfault 
e2fe 3e 00				ld a, display_row_1 
e300 cd c3 8a				call str_at_display 
e303 11 5e ee				    ld de, debug_mark 
e306 3e 11				ld a, display_row_1+17 
e308 cd c3 8a				call str_at_display 
e30b cd d3 8a				call update_display 
e30e			 
e30e				; prompt before entering montior for investigating issue 
e30e			 
e30e 3e 78			ld a, display_row_4 
e310 11 ae 96			ld de, endprog 
e313			 
e313 cd d3 8a			call update_display		 
e316			 
e316 cd 44 99			call next_page_prompt 
e319			 
e319 d1				pop de 
e31a e1				pop hl 
e31b cd 02 97				call monitor 
e31e cd 55 9d				call forth_warmstart 
e321 c3 00 96				jp warmstart_afterauto 
e324					;jp 0 
e324					;halt 
e324			 
e324			 
e324			 
e324 .. 00		.stackfault: 	db "Stack fault:",0 
e331			 
e331 .. 00		sfaultsu: 	db	"Stack under flow",0 
e342 .. 00		sfaultso: 	db	"Stack over flow",0 
e352 .. 00		sfaultru:	db "RTS underflow",0 
e360 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e37a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e394 .. 00		sfaultdo:	db "DTS overflow", 0 
e3a1			 
e3a1			 
e3a1			fault_dsp_under: 
e3a1 11 b3 e3			ld de, .dsp_under 
e3a4 c3 69 e4			jp .show_fault 
e3a7			 
e3a7			fault_rsp_under: 
e3a7 11 c1 e3			ld de, .rsp_under 
e3aa c3 69 e4			jp .show_fault 
e3ad			fault_loop_under: 
e3ad 11 cf e3			ld de, .loop_under 
e3b0 c3 69 e4			jp .show_fault 
e3b3			 
e3b3 .. 00		.dsp_under: db "DSP Underflow",0 
e3c1 .. 00		.rsp_under: db "RSP Underflow",0 
e3cf .. 00		.loop_under: db "LOOP Underflow",0 
e3de			 
e3de			 
e3de d5			type_faultn: 	push de 
e3df e5					push hl 
e3e0 cd b1 8a				call clear_display 
e3e3 11 0d e4				   ld de, .typefaultn 
e3e6 3e 00				ld a, display_row_1 
e3e8 cd c3 8a				call str_at_display 
e3eb 11 5e ee				    ld de, debug_mark 
e3ee 3e 11				ld a, display_row_1+17 
e3f0 cd c3 8a				call str_at_display 
e3f3 cd d3 8a				call update_display 
e3f6			 
e3f6				; prompt before entering montior for investigating issue 
e3f6			 
e3f6 3e 78			ld a, display_row_4 
e3f8 11 ae 96			ld de, endprog 
e3fb			 
e3fb cd d3 8a			call update_display		 
e3fe			 
e3fe cd 44 99			call next_page_prompt 
e401			 
e401 e5					push hl 
e402 d5					push de 
e403 cd 02 97				call monitor 
e406 cd 55 9d				call forth_warmstart 
e409 c3 00 96				jp warmstart_afterauto 
e40c 76					halt 
e40d			 
e40d			 
e40d .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e424			 
e424 d5			type_faults: 	push de 
e425 e5					push hl 
e426 cd b1 8a				call clear_display 
e429 11 52 e4				   ld de, .typefaults 
e42c 3e 00				ld a, display_row_1 
e42e cd c3 8a				call str_at_display 
e431 11 5e ee				    ld de, debug_mark 
e434 3e 11				ld a, display_row_1+17 
e436 cd c3 8a				call str_at_display 
e439 cd d3 8a				call update_display 
e43c			 
e43c				; prompt before entering montior for investigating issue 
e43c			 
e43c 3e 78			ld a, display_row_4 
e43e 11 ae 96			ld de, endprog 
e441			 
e441 cd d3 8a			call update_display		 
e444			 
e444 cd 44 99			call next_page_prompt 
e447			 
e447 e1					pop hl 
e448 d1					pop de 
e449 cd 02 97				call monitor 
e44c cd 55 9d				call forth_warmstart 
e44f c3 00 96				jp warmstart_afterauto 
e452			 
e452			 
e452 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e469			 
e469			.show_fault: 	 
e469 d5					push de 
e46a cd b1 8a				call clear_display 
e46d d1					pop de 
e46e 3e 00				ld a, display_row_1 
e470 cd c3 8a				call str_at_display 
e473 11 5e ee				    ld de, debug_mark 
e476 3e 11				ld a, display_row_1+17 
e478 cd c3 8a				call str_at_display 
e47b cd d3 8a				call update_display 
e47e			 
e47e				; prompt before entering montior for investigating issue 
e47e			 
e47e 3e 78			ld a, display_row_4 
e480 11 ae 96			ld de, endprog 
e483			 
e483 cd d3 8a			call update_display		 
e486			 
e486 cd 44 99			call next_page_prompt 
e489			 
e489 e1					pop hl 
e48a d1					pop de 
e48b cd 02 97				call monitor 
e48e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e48e			; TODO Make optional fault restart to cli or warm boot? 
e48e					;jp warmstart 
e48e c3 43 96				jp cli 
e491 76					halt 
e492			 
e492			 
e492			; handle the auto run of code from files in storage 
e492			 
e492			 
e492			include "forth_startup.asm" 
e492			; Which startup method to use? 
e492			; 
e492			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e492			; followed by loading of a list of scripts in eeprom 
e492			 
e492			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e492			; from eeprom 
e492			 
e492			; Select with define in main stubs 
e492			 
e492			if STARTUP_V1 
e492				include "forth_startupv1.asm" 
e492			; Startup script loading version 1 
e492			 
e492			; If SE storage is available first stage is to use the selected file 
e492			; then go through the eeprom list 
e492			 
e492 .. 00		sprompt1: db "Startup load...",0 
e4a2 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e4b8			 
e4b8			 
e4b8			 
e4b8			 
e4b8			forth_startup: 
e4b8 21 4b d4			ld hl, startcmds 
e4bb 3e 00			ld a, 0 
e4bd 32 da e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e4c0			 
e4c0 e5			.start1:	push hl 
e4c1 cd b1 8a			call clear_display 
e4c4 11 92 e4			ld de, sprompt1 
e4c7 3e 00		        ld a, display_row_1 
e4c9 cd c3 8a			call str_at_display 
e4cc 11 a2 e4			ld de, sprompt2 
e4cf 3e 28		        ld a, display_row_2 
e4d1 cd c3 8a			call str_at_display 
e4d4 e1				pop hl 
e4d5 e5				push hl 
e4d6 5e				ld e,(hl) 
e4d7 23				inc hl 
e4d8 56				ld d,(hl) 
e4d9 3e 50		        ld a, display_row_3 
e4db cd c3 8a			call str_at_display 
e4de cd d3 8a			call update_display 
e4e1			 
e4e1			 
e4e1 3a da e6			ld a, (os_last_cmd) 
e4e4 fe 00			cp 0 
e4e6 28 05			jr z, .startprompt 
e4e8 cd e4 89			call delay250ms 
e4eb 18 24			jr .startdo 
e4ed				 
e4ed				 
e4ed			 
e4ed			.startprompt: 
e4ed			 
e4ed 3e 9f			ld a,display_row_4 + display_cols - 1 
e4ef 11 42 99		        ld de, endprg 
e4f2 cd c3 8a			call str_at_display 
e4f5 cd d3 8a			call update_display 
e4f8 cd f0 89			call delay1s 
e4fb cd 27 e6			call cin_wait 
e4fe						 
e4fe fe 2a			cp '*' 
e500 28 5e			jr z, .startupend1 
e502 fe 23			cp '#' 
e504 20 07			jr nz, .startno 
e506 3e 01			ld a, 1 
e508 32 da e6			ld (os_last_cmd),a 
e50b 18 04			jr .startdo 
e50d fe 31		.startno:	cp '1' 
e50f 28 3a			jr z,.startnxt  
e511			 
e511				; exec startup line 
e511			.startdo:	 
e511 e1				pop hl 
e512 e5				push hl 
e513				 
e513 5e				ld e,(hl) 
e514 23				inc hl 
e515 56				ld d,(hl) 
e516 eb				ex de,hl 
e517			 
e517 e5				push hl 
e518			 
e518 3e 00			ld a, 0 
e51a				;ld a, FORTH_END_BUFFER 
e51a cd 3e 90			call strlent 
e51d 23				inc hl   ; include zero term to copy 
e51e 06 00			ld b,0 
e520 4d				ld c,l 
e521 e1				pop hl 
e522 11 b4 e2			ld de, scratch 
e525 ed b0			ldir 
e527			 
e527			 
e527 21 b4 e2			ld hl, scratch 
e52a cd f5 9d			call forthparse 
e52d cd 2d 9e			call forthexec 
e530 cd 4f 9d			call forthexec_cleanup 
e533			 
e533 3e 78			ld a, display_row_4 
e535 11 ae 96			ld de, endprog 
e538			 
e538 cd d3 8a			call update_display		 
e53b			 
e53b 3a da e6			ld a, (os_last_cmd) 
e53e fe 00			cp 0 
e540 20 09			jr nz, .startnxt 
e542 cd 44 99			call next_page_prompt 
e545 cd b1 8a		        call clear_display 
e548 cd d3 8a			call update_display		 
e54b			 
e54b				; move onto next startup line? 
e54b			.startnxt: 
e54b			 
e54b cd e4 89			call delay250ms 
e54e e1				pop hl 
e54f			 
e54f 23				inc hl 
e550 23				inc hl 
e551			 
e551 e5				push hl 
e552 5e				ld e, (hl) 
e553 23				inc hl 
e554 56				ld d, (hl) 
e555 e1				pop hl 
e556				; TODO replace 0 test 
e556			 
e556 eb				ex de, hl 
e557 cd 04 8d			call ishlzero 
e55a			;	ld a,e 
e55a			;	add d 
e55a			;	cp 0    ; any left to do? 
e55a eb				ex de, hl 
e55b c2 c0 e4			jp nz, .start1 
e55e 18 01			jr .startupend 
e560			 
e560 e1			.startupend1: pop hl 
e561			.startupend: 
e561			 
e561 cd b1 8a			call clear_display 
e564 cd d3 8a			call update_display 
e567 c9				ret 
e568			if STORAGE_SE 
e568			 
e568			sprompt3: db "Loading from start-up file?:",0 
e568			sprompt4: db "(Y=Any key/N=No)",0 
e568			 
e568			 
e568			forth_autoload: 
e568			 
e568				; load block 0 of store 1 
e568				 
e568				ld a, $fe      ; bit 0 clear 
e568				ld (spi_device), a 
e568			 
e568				call storage_get_block_0 
e568			 
e568				ld a, (store_page+STORE_0_AUTOFILE) 
e568			 
e568				cp 0 
e568				ret z     ; auto start not enabled 
e568			 
e568				call clear_display 
e568			 
e568				; set bank 
e568			 
e568					ld a, (store_page+STORE_0_BANKRUN) 
e568					ld (spi_device), a 
e568			 
e568				; get file id to load from and get the file name to display 
e568			 
e568					ld a, (store_page+STORE_0_FILERUN) 
e568			 
e568					ld l, 0 
e568					ld h, a 
e568					ld de, store_page 
e568			 
e568					if DEBUG_FORTH_WORDS 
e568						DMARK "ASp" 
e568						CALLMONITOR 
e568					endif 
e568					call storage_read 
e568			 
e568					if DEBUG_FORTH_WORDS 
e568						DMARK "ASr" 
e568						CALLMONITOR 
e568					endif 
e568			 
e568					call ishlzero 
e568					ret z             ; file not found 
e568			 
e568					ld a, display_row_2 + 10 
e568					ld de, store_page+3 
e568					call str_at_display 
e568				 
e568			; 
e568			 
e568				ld a, display_row_1+5 
e568				ld de, sprompt3 
e568				call str_at_display 
e568				ld a, display_row_3+15 
e568				ld de, sprompt4 
e568				call str_at_display 
e568			 
e568				call update_display 
e568			 
e568				call cin_wait 
e568				cp 'n' 
e568				ret z 
e568				cp 'N' 
e568				ret z 
e568			 
e568				call delay1s 
e568			 
e568				ld a, (store_page+2) 
e568				ld (store_openmaxext), a    ; save count of ext 
e568				ld a, 1  
e568				ld (store_openext), a    ; save count of ext 
e568			 
e568			.autof:  
e568				ld l , a 
e568				 
e568				ld a, (store_page) 
e568				ld h, a	 
e568				ld de, store_page 
e568					if DEBUG_FORTH_WORDS 
e568						DMARK "ASl" 
e568						CALLMONITOR 
e568					endif 
e568					call storage_read 
e568				call ishlzero 
e568				ret z 
e568			;	jr z, .autoend 
e568			 
e568					if DEBUG_FORTH_WORDS 
e568						DMARK "ASc" 
e568						CALLMONITOR 
e568					endif 
e568				ld de, store_page+2 
e568				ld a, display_row_4 
e568				call str_at_display 
e568			 
e568				call update_display 
e568				call delay250ms 
e568			 
e568			 
e568			 
e568				ld hl, store_page+2 
e568				call forthparse 
e568				call forthexec 
e568				call forthexec_cleanup 
e568			 
e568				 
e568				ld a, (store_openext) 
e568				inc a 
e568				ld (store_openext), a    ; save count of ext 
e568			 
e568				jr .autof 
e568			;.autofdone: 
e568			; 
e568			;		if DEBUG_FORTH_WORDS 
e568			;			DMARK "ASx" 
e568			;			CALLMONITOR 
e568			;		endif 
e568			;;	call clear_display 
e568			;	ret 
e568			 
e568			 
e568			 
e568			endif 
# End of file forth_startupv1.asm
e568			endif 
e568			if STARTUP_V2 
e568				include "forth_startupv2.asm" 
e568			endif 
e568			 
# End of file forth_startup.asm
e568			 
e568			; eof 
# End of file forth_kernel.asm
e568			;include "nascombasic.asm" 
e568			;include "basicZ80.asm" 
e568			 
e568			 
e568			 
e568			; find out where the code ends if loaded into RAM (for SC114) 
e568			;endofcode:  
e568			;	nop 
e568			 
e568			 
e568			; jump to nmi vector 
e568			 
e568			init_nmi: 
e568 3e c9			ld a, $c9   ; RET 
e56a 32 6e ee			ld (nmi_vector), a 
e56d c9				ret 
e56e			nmi: 
e56e e5				push hl 
e56f d5				push de 
e570 c5				push bc 
e571 f5				push af 
e572 cd 6e ee			call nmi_vector 
e575 f5				push af 
e576 c5				push bc 
e577 d5				push de 
e578 e5				push hl 
e579 ed 4d			reti 
e57b			 
e57b			 
e57b			; eof 
e57b			 
# End of file main.asm
e57b			;include "firmware_lcd_4x40.asm" 
e57b			;;include "firmware_lcd_4x20.asm" 
e57b			include "firmware_serial_display.asm" 
e57b			 
e57b			; Serial display interface for SC114 
e57b			 
e57b			 
e57b			display_row_1: equ 0 
e57b			display_row_2: equ display_row_1+display_cols 
e57b			display_row_3: equ display_row_2 + display_cols 
e57b			display_row_4: equ display_row_3 + display_cols 
e57b			 
e57b			kLCDWidth:  EQU display_cols             ;Width in characters 
e57b			kLCD_Line1: EQU 0x00  
e57b			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e57b			; E1 
e57b			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e57b			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e57b			 
e57b			lcd_init: 
e57b				; no init as handled by the SCM bios 
e57b c9				ret 
e57c			 
e57c			 
e57c			; low level functions for direct screen writes 
e57c			 
e57c			; output char at pos? 
e57c			fLCD_Str: 
e57c			        ;out (SC114_SIO_1_OUT),a 
e57c c5				push bc 
e57d 0e 02			ld c, $02 
e57f f7				rst $30 
e580 c1				pop bc 
e581 c9				ret 
e582			 
e582			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e582			fLCD_Pos: 
e582				; use ASCII escape to position 
e582			        ;out (SC114_SIO_1_OUT),a 
e582 c5				push bc 
e583 0e 02			ld c, $02 
e585 f7				rst $30 
e586 c1				pop bc 
e587			 
e587 c9				ret 
e588			 
e588			; output char at pos 
e588			fLCD_Data: 
e588			      ;  out (SC114_SIO_1_OUT),a 
e588 c5				push bc 
e589 0e 02			ld c, $02 
e58b f7				rst $30 
e58c c1				pop bc 
e58d			 
e58d c9				ret 
e58e			 
e58e			; ascii cls  
e58e			 
e58e 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e592			 
e592			; write the frame buffer given in hl to hardware  
e592			write_display: 
e592			 
e592			API: equ 0 
e592			 
e592			if API 
e592				push bc 
e592				ld b, 4 
e592			 
e592			        ld (display_write_tmp), hl 	  
e592			 
e592				; clear and home cursor 
e592			 
e592				ld c, 6 
e592				ld de, .cls 
e592				rst $30 
e592			 
e592			 
e592			.writeln: 
e592			 
e592				ld de, (display_write_tmp) 
e592				ld c, 6 
e592				rst $30 
e592				ld c, 7 
e592				rst $30 
e592			 
e592				ld hl, (display_write_tmp) 
e592				ld de, display_cols 
e592				add hl,de 
e592				ld (display_write_tmp),hl 
e592			 
e592				djnz  .writeln 
e592			 
e592				pop bc 
e592			 
e592			 
e592				ret 
e592			endif 
e592 e5				push hl 
e593 c5				push bc 
e594 d5				push de 
e595			 
e595			;	ld c, 2 
e595			;	;ld de, .cls 
e595			;	ld a, 27 
e595			;	rst $30 
e595			;	ld c, 2 
e595			;	;ld de, .cls 
e595			;	ld a, '[' 
e595			;	rst $30 
e595			; 
e595			;	ld c, 2 
e595			;	;ld de, .cls 
e595			;	ld a, 'H' 
e595			;	rst $30 
e595			; 
e595			 
e595 0e 02			ld c, 2 
e597				;ld de, .cls 
e597 3e 1b			ld a, 27 
e599 f7				rst $30 
e59a			 
e59a			 
e59a 0e 02			ld c, 2 
e59c				;ld de, .cls 
e59c 3e 5b			ld a, '[' 
e59e f7				rst $30 
e59f 0e 02			ld c, 2 
e5a1				;ld de, .cls 
e5a1 3e 32			ld a, '2' 
e5a3 f7				rst $30 
e5a4 0e 02			ld c, 2 
e5a6				;ld de, .cls 
e5a6 3e 4a			ld a, 'J' 
e5a8 f7				rst $30 
e5a9 d1				pop de 
e5aa c1				pop bc 
e5ab e1				pop hl 
e5ac			 
e5ac			 
e5ac 22 bc eb		        ld (display_write_tmp), hl 	  
e5af 3e 00			ld a, kLCD_Line1 
e5b1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e5b1 06 28			ld b, display_cols 
e5b3 ed 5b bc eb		ld de, (display_write_tmp) 
e5b7 cd 15 e6			call write_len_string 
e5ba				 
e5ba			 
e5ba e5			push hl 
e5bb d5			push de 
e5bc c5			push bc 
e5bd 0e 07			ld c, 7 
e5bf f7				rst $30 
e5c0 c1			pop bc 
e5c1 d1			pop de 
e5c2 e1			pop hl 
e5c3			 
e5c3				 
e5c3 2a bc eb			ld hl, (display_write_tmp) 
e5c6 11 28 00			ld de, display_cols 
e5c9 19				add hl,de 
e5ca 22 bc eb			ld (display_write_tmp),hl 
e5cd			 
e5cd				 
e5cd 3e 28			ld a, kLCD_Line2 
e5cf			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e5cf 06 28			ld b, display_cols 
e5d1 ed 5b bc eb		ld de, (display_write_tmp) 
e5d5 cd 15 e6			call write_len_string 
e5d8				 
e5d8 2a bc eb			ld hl, (display_write_tmp) 
e5db 11 28 00			ld de, display_cols 
e5de 19				add hl,de 
e5df 22 bc eb			ld (display_write_tmp),hl 
e5e2			 
e5e2 e5			push hl 
e5e3 d5			push de 
e5e4 c5			push bc 
e5e5 0e 07			ld c, 7 
e5e7 f7				rst $30 
e5e8 c1			pop bc 
e5e9 d1			pop de 
e5ea e1			pop hl 
e5eb			 
e5eb				 
e5eb 3e 50			ld a, kLCD_Line3 
e5ed			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e5ed 06 28			ld b, display_cols 
e5ef ed 5b bc eb		ld de, (display_write_tmp) 
e5f3 cd 15 e6			call write_len_string 
e5f6				 
e5f6 2a bc eb			ld hl, (display_write_tmp) 
e5f9 11 28 00			ld de, display_cols 
e5fc 19				add hl,de 
e5fd 22 bc eb			ld (display_write_tmp),hl 
e600			 
e600 e5			push hl 
e601 d5			push de 
e602 c5			push bc 
e603 0e 07			ld c, 7 
e605 f7				rst $30 
e606 c1			pop bc 
e607 d1			pop de 
e608 e1			pop hl 
e609			 
e609				 
e609 3e 78			ld a, kLCD_Line4 
e60b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e60b 06 28			ld b, display_cols 
e60d ed 5b bc eb		ld de, (display_write_tmp) 
e611 cd 15 e6			call write_len_string 
e614 c9					ret 
e615			 
e615			 
e615				; write out a fixed length string given in b from de 
e615			 
e615 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e616 cd 88 e5		            CALL fLCD_Data      ;Write character to display 
e619 13				inc de 
e61a 10 f9			djnz write_len_string 
e61c c9				ret 
e61d			 
e61d			 
e61d			; eof 
# End of file firmware_serial_display.asm
e61d			;include "firmware_key_5x10.asm" 
e61d			;;include "firmware_key_4x10.asm" 
e61d			include "firmware_key_serial.asm" 
e61d			; Serial keyboard interface for SC114 
e61d			 
e61d			key_init: 
e61d				; init keyboard macro pointers 
e61d 21 00 00			ld hl, 0 
e620 22 fe ee			ld (key_macroroot), hl 
e623 22 fc ee			ld (key_macrolast), hl 
e626				; no init as handled by the SCM bios 
e626 c9				ret 
e627			 
e627			 
e627			cin_wait: 
e627			;	ld a, 0 
e627			;	ret 
e627			 
e627				;in a,(SC114_SIO_1_IN) 
e627			        ; Use SCM API to get from whatever console device we are using 
e627 c5				push bc 
e628 0e 01			ld c, $01 
e62a f7				rst $30 
e62b c1				pop bc 
e62c c9				ret 
e62d			 
e62d			cinndb: 	 
e62d			cin: 
e62d			 
e62d			 
e62d c5				push bc 
e62e			 
e62e				; any key waiting to process? 
e62e 0e 03			ld c, $03 
e630 f7				rst $30 
e631 28 05			jr z, .cin_skip 
e633			 
e633				; yep, get it 
e633			 
e633 0e 01			ld c, $01 
e635 f7				rst $30 
e636 c1				pop bc 
e637 c9				ret 
e638			.cin_skip: 
e638 3e 00			ld a, 0 
e63a c1				pop bc 
e63b c9				ret 
e63c			 
e63c			 
e63c			 
e63c			 
# End of file firmware_key_serial.asm
e63c			endofcode:  
e63c			baseram:  
e63c 00				nop 
e63d			 
e63d			heap_start: equ baseram+15  ; Starting address of heap 
e63d			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e63d			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e63d			;VDU:  EQU     endofcode           ; BASIC Work space 
e63d			; eof 
e63d			 
# End of file os_mega_sc114.asm
e63d
