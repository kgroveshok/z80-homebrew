# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 ef 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd d5 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd d5 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd d5 0a				call clear_display  
0023			  
0023			  
0023 cd 89 66				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 20 69			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd ac 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 69 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd f8 0a			call update_display  
0035 cd 55 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd da 0a			call fill_display  
003d cd f8 0a			call update_display  
0040 cd 55 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd da 0a			call fill_display  
0048 cd f8 0a			call update_display  
004b cd 55 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd da 0a			call fill_display  
0053 cd f8 0a			call update_display  
0056 cd 55 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd e8 0a			call str_at_display  
0061 cd f8 0a			call update_display  
0064			  
0064			  
0064 cd 55 0a			call delay1s  
0067 cd 55 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd e8 0a			call str_at_display  
0072 cd f8 0a			call update_display  
0075 cd 55 0a			call delay1s  
0078 cd 55 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 3a 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 3a 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd c0 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 19 17			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 19 17			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 2d 06			call storage_findnextid 
0360			 
0360 cd 32 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 19 17			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 19 17			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 19 17			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 19 17			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 19 17			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 18 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 19 17			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 19 17			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 3a 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 3a 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 09 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 3a 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 3a 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 09 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 19 17			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 19 17			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 19 17			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 19 17			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 2d 06			call storage_findnextid 
0571			 
0571 e5				push hl 
0572			 
0572				; TODO check file not found 
0572			 
0572 11 62 f8			ld de, store_page 
0575 cd 0c 03			call storage_read_block 
0578			 
0578					if DEBUG_FORTH_WORDS 
0578						DMARK "ER1" 
0578 f5				push af  
0579 3a 8d 05			ld a, (.dmark)  
057c 32 77 fb			ld (debug_mark),a  
057f 3a 8e 05			ld a, (.dmark+1)  
0582 32 78 fb			ld (debug_mark+1),a  
0585 3a 8f 05			ld a, (.dmark+2)  
0588 32 79 fb			ld (debug_mark+2),a  
058b 18 03			jr .pastdmark  
058d ..			.dmark: db "ER1"  
0590 f1			.pastdmark: pop af  
0591			endm  
# End of macro DMARK
0591						CALLMONITOR 
0591 cd 19 17			call break_point_state  
0594				endm  
# End of macro CALLMONITOR
0594					endif 
0594 3a 62 f8			ld a, (store_page)	; get file id 
0597 32 5b f8			ld (store_tmpid), a 
059a			 
059a 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
059d 32 5a f8			ld (store_tmpext), a 
05a0			 
05a0				; wipe file header 
05a0			 
05a0 e1				pop hl 
05a1 3e 00			ld a, 0 
05a3 32 62 f8			ld (store_page), a 
05a6 32 63 f8			ld (store_page+1),a 
05a9 11 62 f8			ld de, store_page 
05ac					if DEBUG_FORTH_WORDS 
05ac						DMARK "ER2" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 77 fb			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 78 fb			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 79 fb			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "ER2"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5						CALLMONITOR 
05c5 cd 19 17			call break_point_state  
05c8				endm  
# End of macro CALLMONITOR
05c8					endif 
05c8 cd 71 03			call storage_write_block 
05cb			 
05cb			 
05cb				; wipe file extents 
05cb			 
05cb 3a 5a f8			ld a, (store_tmpext) 
05ce 47				ld b, a 
05cf			 
05cf			.eraext:	  
05cf c5				push bc 
05d0			 
05d0 21 40 00			ld hl, STORE_BLOCK_PHY 
05d3 3a 5b f8			ld a,(store_tmpid) 
05d6 5f				ld e, a 
05d7 50				ld d, b	 
05d8					if DEBUG_FORTH_WORDS 
05d8						DMARK "ER3" 
05d8 f5				push af  
05d9 3a ed 05			ld a, (.dmark)  
05dc 32 77 fb			ld (debug_mark),a  
05df 3a ee 05			ld a, (.dmark+1)  
05e2 32 78 fb			ld (debug_mark+1),a  
05e5 3a ef 05			ld a, (.dmark+2)  
05e8 32 79 fb			ld (debug_mark+2),a  
05eb 18 03			jr .pastdmark  
05ed ..			.dmark: db "ER3"  
05f0 f1			.pastdmark: pop af  
05f1			endm  
# End of macro DMARK
05f1						CALLMONITOR 
05f1 cd 19 17			call break_point_state  
05f4				endm  
# End of macro CALLMONITOR
05f4					endif 
05f4 cd 2d 06			call storage_findnextid 
05f7			 
05f7 e5				push hl 
05f8 11 62 f8			ld de, store_page 
05fb cd 0c 03			call storage_read_block 
05fe			 
05fe				; free block	 
05fe			 
05fe 3e 00			ld a, 0 
0600 32 62 f8			ld (store_page), a 
0603 32 63 f8			ld (store_page+1),a 
0606 11 62 f8			ld de, store_page 
0609 e1				pop hl 
060a					if DEBUG_FORTH_WORDS 
060a						DMARK "ER4" 
060a f5				push af  
060b 3a 1f 06			ld a, (.dmark)  
060e 32 77 fb			ld (debug_mark),a  
0611 3a 20 06			ld a, (.dmark+1)  
0614 32 78 fb			ld (debug_mark+1),a  
0617 3a 21 06			ld a, (.dmark+2)  
061a 32 79 fb			ld (debug_mark+2),a  
061d 18 03			jr .pastdmark  
061f ..			.dmark: db "ER4"  
0622 f1			.pastdmark: pop af  
0623			endm  
# End of macro DMARK
0623						CALLMONITOR 
0623 cd 19 17			call break_point_state  
0626				endm  
# End of macro CALLMONITOR
0626					endif 
0626 cd 71 03			call storage_write_block 
0629			 
0629 c1				pop bc 
062a 10 a3			djnz .eraext 
062c			 
062c c9				ret 
062d			 
062d			 
062d			; Find Free Block 
062d			; --------------- 
062d			; 
062d			; With current bank 
062d			;  
062d			; From given starting logical block 
062d			;    Read block  
062d			;    If no file id 
062d			;         Return block id 
062d			 
062d			 
062d			; hl starting page number 
062d			; hl contains free page number or zero if no pages free 
062d			; e contains the file id to locate 
062d			; d contains the block number 
062d			 
062d			; TODO change to find file id and use zero for free block 
062d			 
062d			storage_findnextid: 
062d			 
062d				; now locate first 0 page to mark as a free block 
062d			 
062d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062f			;	ld hl, STORE_BLOCK_PHY 
062f			 
062f					if DEBUG_FORTH_WORDS 
062f					DMARK "FNI" 
062f f5				push af  
0630 3a 44 06			ld a, (.dmark)  
0633 32 77 fb			ld (debug_mark),a  
0636 3a 45 06			ld a, (.dmark+1)  
0639 32 78 fb			ld (debug_mark+1),a  
063c 3a 46 06			ld a, (.dmark+2)  
063f 32 79 fb			ld (debug_mark+2),a  
0642 18 03			jr .pastdmark  
0644 ..			.dmark: db "FNI"  
0647 f1			.pastdmark: pop af  
0648			endm  
# End of macro DMARK
0648						CALLMONITOR 
0648 cd 19 17			call break_point_state  
064b				endm  
# End of macro CALLMONITOR
064b					endif 
064b			.ff1:   	 
064b e5					push hl 
064c c5					push bc 
064d d5					push de 
064e cd 8c 02				call se_readbyte 
0651 5f					ld e,a 
0652 23					inc hl 
0653 cd 8c 02				call se_readbyte 
0656 57					ld d, a 
0657 e1					pop hl 
0658 e5					push hl 
0659 cd 27 0d				call cmp16 
065c 28 49				jr z, .fffound 
065e			 
065e d1					pop de 
065f c1					pop bc 
0660 e1					pop hl 
0661			 
0661					; is found? 
0661					;cp e 
0661					;ret z 
0661			 
0661 3e 40				ld a, STORE_BLOCK_PHY 
0663 cd 09 0d				call addatohl 
0666 10 e3				djnz .ff1 
0668			 
0668 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066a			.ff2:   	 
066a			 
066a e5					push hl 
066b c5					push bc 
066c d5					push de 
066d cd 8c 02				call se_readbyte 
0670 5f					ld e,a 
0671 23					inc hl 
0672 cd 8c 02				call se_readbyte 
0675 57					ld d, a 
0676			 
0676 e1					pop hl 
0677 e5					push hl 
0678 cd 27 0d				call cmp16 
067b 28 2a				jr z, .fffound 
067d			 
067d d1					pop de 
067e c1					pop bc 
067f e1					pop hl 
0680					; is found? 
0680					;cp e 
0680					;ret z 
0680			 
0680 3e 40				ld a, STORE_BLOCK_PHY 
0682 cd 09 0d				call addatohl 
0685 10 e3				djnz .ff2 
0687			 
0687			 
0687					if DEBUG_FORTH_WORDS 
0687					DMARK "FN-" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 77 fb			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 78 fb			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 79 fb			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "FN-"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					;	push af 
06a0					;	ld a, 'n' 
06a0					;	ld (debug_mark),a 
06a0					;	pop af 
06a0						CALLMONITOR 
06a0 cd 19 17			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3					endif 
06a3				; no free marks! 
06a3 21 00 00				ld hl, 0 
06a6 c9				ret 
06a7			.fffound: 
06a7				 
06a7			 
06a7 d1					pop de 
06a8 c1					pop bc 
06a9 e1					pop hl 
06aa					if DEBUG_FORTH_WORDS 
06aa					DMARK "FNF" 
06aa f5				push af  
06ab 3a bf 06			ld a, (.dmark)  
06ae 32 77 fb			ld (debug_mark),a  
06b1 3a c0 06			ld a, (.dmark+1)  
06b4 32 78 fb			ld (debug_mark+1),a  
06b7 3a c1 06			ld a, (.dmark+2)  
06ba 32 79 fb			ld (debug_mark+2),a  
06bd 18 03			jr .pastdmark  
06bf ..			.dmark: db "FNF"  
06c2 f1			.pastdmark: pop af  
06c3			endm  
# End of macro DMARK
06c3					;	push af 
06c3					;	ld a, 'n' 
06c3					;	ld (debug_mark),a 
06c3					;	pop af 
06c3						CALLMONITOR 
06c3 cd 19 17			call break_point_state  
06c6				endm  
# End of macro CALLMONITOR
06c6					endif 
06c6 c9				ret 
06c7			 
06c7			 
06c7			 
06c7			; Free Space 
06c7			; ---------- 
06c7			; 
06c7			; With current bank 
06c7			; 
06c7			; Set block count to zero 
06c7			; Starting with first logical block 
06c7			;      Find free block  
06c7			;      If block id given, increment block count 
06c7			; 
06c7			;  
06c7			 
06c7			 
06c7			; hl contains count of free blocks 
06c7			 
06c7			storage_freeblocks: 
06c7			 
06c7				; now locate first 0 page to mark as a free block 
06c7			 
06c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c9 21 40 00			ld hl, STORE_BLOCK_PHY 
06cc 11 00 00			ld de, 0 
06cf			 
06cf			.fb1:   	 
06cf e5					push hl 
06d0 c5					push bc 
06d1 d5					push de 
06d2 cd 8c 02				call se_readbyte 
06d5 d1					pop de 
06d6 c1					pop bc 
06d7 e1					pop hl 
06d8			 
06d8					; is free? 
06d8 fe 00				cp 0 
06da 20 01				jr nz, .ff1cont 
06dc 13					inc de 
06dd			 
06dd			.ff1cont: 
06dd			 
06dd			 
06dd 3e 40				ld a, STORE_BLOCK_PHY 
06df cd 09 0d				call addatohl 
06e2 10 eb				djnz .fb1 
06e4			 
06e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e6			.fb2:   	 
06e6 e5					push hl 
06e7 c5					push bc 
06e8 d5					push de 
06e9 cd 8c 02				call se_readbyte 
06ec d1					pop de 
06ed c1					pop bc 
06ee e1					pop hl 
06ef			 
06ef					; is free? 
06ef fe 00				cp 0 
06f1 20 01				jr nz, .ff2cont 
06f3 13					inc de 
06f4			 
06f4			.ff2cont: 
06f4			 
06f4 3e 40				ld a, STORE_BLOCK_PHY 
06f6 cd 09 0d				call addatohl 
06f9 10 eb				djnz .fb2 
06fb			 
06fb eb				ex de, hl 
06fc c9				ret 
06fd			 
06fd			; Get File ID 
06fd			; ----------- 
06fd			; 
06fd			; With current bank 
06fd			;  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; For each logical block 
06fd			;    Read block file id 
06fd			;      If first block of file and dont have file id 
06fd			;         if file get id and exit 
06fd			 
06fd			 
06fd			 
06fd			 
06fd			; Create File 
06fd			; ----------- 
06fd			; 
06fd			; With current bank  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; Increment file id number 
06fd			; Save Config 
06fd			; Find free block 
06fd			; Set buffer with file name and file id 
06fd			; Write buffer to free block  
06fd			 
06fd			 
06fd			; hl point to file name 
06fd			; hl returns file id 
06fd			 
06fd			; file format: 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent number 
06fd			; byte 2-> data 
06fd			 
06fd			; format for extent number 0: 
06fd			; 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent 0 
06fd			; byte 2 - extent count 
06fd			; byte 3 -> file name and meta data 
06fd			 
06fd			 
06fd			storage_create: 
06fd				if DEBUG_STORESE 
06fd					DMARK "SCR" 
06fd f5				push af  
06fe 3a 12 07			ld a, (.dmark)  
0701 32 77 fb			ld (debug_mark),a  
0704 3a 13 07			ld a, (.dmark+1)  
0707 32 78 fb			ld (debug_mark+1),a  
070a 3a 14 07			ld a, (.dmark+2)  
070d 32 79 fb			ld (debug_mark+2),a  
0710 18 03			jr .pastdmark  
0712 ..			.dmark: db "SCR"  
0715 f1			.pastdmark: pop af  
0716			endm  
# End of macro DMARK
0716					CALLMONITOR 
0716 cd 19 17			call break_point_state  
0719				endm  
# End of macro CALLMONITOR
0719				endif 
0719			 
0719 e5				push hl		; save file name pointer 
071a			 
071a cd bd 03			call storage_get_block_0 
071d			 
071d 3a 62 f8			ld a,(store_page)	; get current file id 
0720 3c				inc a 
0721 32 62 f8			ld (store_page),a 
0724				 
0724 32 5b f8			ld (store_tmpid),a			; save id 
0727			 
0727 21 00 00			ld hl, 0 
072a 11 62 f8			ld de, store_page 
072d				if DEBUG_STORESE 
072d					DMARK "SCw" 
072d f5				push af  
072e 3a 42 07			ld a, (.dmark)  
0731 32 77 fb			ld (debug_mark),a  
0734 3a 43 07			ld a, (.dmark+1)  
0737 32 78 fb			ld (debug_mark+1),a  
073a 3a 44 07			ld a, (.dmark+2)  
073d 32 79 fb			ld (debug_mark+2),a  
0740 18 03			jr .pastdmark  
0742 ..			.dmark: db "SCw"  
0745 f1			.pastdmark: pop af  
0746			endm  
# End of macro DMARK
0746					CALLMONITOR 
0746 cd 19 17			call break_point_state  
0749				endm  
# End of macro CALLMONITOR
0749				endif 
0749 cd 71 03			call storage_write_block	 ; save update 
074c			 
074c				if DEBUG_STORESE 
074c 11 62 f8				ld de, store_page 
074f					DMARK "SCC" 
074f f5				push af  
0750 3a 64 07			ld a, (.dmark)  
0753 32 77 fb			ld (debug_mark),a  
0756 3a 65 07			ld a, (.dmark+1)  
0759 32 78 fb			ld (debug_mark+1),a  
075c 3a 66 07			ld a, (.dmark+2)  
075f 32 79 fb			ld (debug_mark+2),a  
0762 18 03			jr .pastdmark  
0764 ..			.dmark: db "SCC"  
0767 f1			.pastdmark: pop af  
0768			endm  
# End of macro DMARK
0768					CALLMONITOR 
0768 cd 19 17			call break_point_state  
076b				endm  
# End of macro CALLMONITOR
076b				endif 
076b				;  
076b				 
076b 21 40 00			ld hl, STORE_BLOCK_PHY 
076e 11 00 00			ld de, 0 
0771 cd 2d 06			call storage_findnextid 
0774			 
0774 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
0777			 
0777				; TODO detect 0 = no spare blocks 
0777			 
0777				; hl now contains the free page to use for the file header page 
0777			 
0777				if DEBUG_STORESE 
0777				DMARK "SCF" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 77 fb			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 78 fb			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 79 fb			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCF"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 19 17			call break_point_state  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793 22 4c f8			ld (store_tmppageid), hl 
0796				 
0796 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0799			;	ld a, (store_filecache)			; save to cache 
0799			 
0799 32 62 f8			ld (store_page),a    ; set page id 
079c 3e 00			ld a, 0			 ; extent 0 is file header 
079e 32 63 f8			ld (store_page+1), a   ; set file extent 
07a1			 
07a1 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a4			 
07a4			;	inc hl 		; init block 0 of file 
07a4			;	inc hl   		; skip file and extent id 
07a4			 ;       ld a, 0 
07a4			;	ld (hl),a 
07a4			;	ld a, (store_filecache+1)  	; save to cache 
07a4			 
07a4			;	inc hl    ; file name 
07a4				 
07a4				 
07a4 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a7				if DEBUG_STORESE 
07a7					DMARK "SCc" 
07a7 f5				push af  
07a8 3a bc 07			ld a, (.dmark)  
07ab 32 77 fb			ld (debug_mark),a  
07ae 3a bd 07			ld a, (.dmark+1)  
07b1 32 78 fb			ld (debug_mark+1),a  
07b4 3a be 07			ld a, (.dmark+2)  
07b7 32 79 fb			ld (debug_mark+2),a  
07ba 18 03			jr .pastdmark  
07bc ..			.dmark: db "SCc"  
07bf f1			.pastdmark: pop af  
07c0			endm  
# End of macro DMARK
07c0					CALLMONITOR 
07c0 cd 19 17			call break_point_state  
07c3				endm  
# End of macro CALLMONITOR
07c3				endif 
07c3 e1				pop hl    ; get zero term string 
07c4 e5				push hl 
07c5 3e 00			ld a, 0 
07c7 cd 72 11			call strlent 
07ca 23				inc hl   ; cover zero term 
07cb 06 00			ld b,0 
07cd 4d				ld c,l 
07ce e1				pop hl 
07cf				;ex de, hl 
07cf				if DEBUG_STORESE 
07cf					DMARK "SCa" 
07cf f5				push af  
07d0 3a e4 07			ld a, (.dmark)  
07d3 32 77 fb			ld (debug_mark),a  
07d6 3a e5 07			ld a, (.dmark+1)  
07d9 32 78 fb			ld (debug_mark+1),a  
07dc 3a e6 07			ld a, (.dmark+2)  
07df 32 79 fb			ld (debug_mark+2),a  
07e2 18 03			jr .pastdmark  
07e4 ..			.dmark: db "SCa"  
07e7 f1			.pastdmark: pop af  
07e8			endm  
# End of macro DMARK
07e8					;push af 
07e8					;ld a, 'a' 
07e8					;ld (debug_mark),a 
07e8					;pop af 
07e8					CALLMONITOR 
07e8 cd 19 17			call break_point_state  
07eb				endm  
# End of macro CALLMONITOR
07eb				endif 
07eb ed b0			ldir    ; copy zero term string 
07ed				if DEBUG_STORESE 
07ed					DMARK "SCA" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 77 fb			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 78 fb			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 79 fb			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "SCA"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 19 17			call break_point_state  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809			 
0809				; write file header page 
0809			 
0809 2a 4c f8			ld hl,(store_tmppageid) 
080c 11 62 f8			ld de, store_page 
080f				if DEBUG_STORESE 
080f					DMARK "SCb" 
080f f5				push af  
0810 3a 24 08			ld a, (.dmark)  
0813 32 77 fb			ld (debug_mark),a  
0816 3a 25 08			ld a, (.dmark+1)  
0819 32 78 fb			ld (debug_mark+1),a  
081c 3a 26 08			ld a, (.dmark+2)  
081f 32 79 fb			ld (debug_mark+2),a  
0822 18 03			jr .pastdmark  
0824 ..			.dmark: db "SCb"  
0827 f1			.pastdmark: pop af  
0828			endm  
# End of macro DMARK
0828					;push af 
0828					;ld a, 'b' 
0828					;ld (debug_mark),a 
0828					;pop af 
0828					CALLMONITOR 
0828 cd 19 17			call break_point_state  
082b				endm  
# End of macro CALLMONITOR
082b				endif 
082b cd 71 03			call storage_write_block 
082e			 
082e 3a 5b f8			ld a, (store_tmpid) 
0831 6f				ld l, a 
0832 26 00			ld h,0 
0834				if DEBUG_STORESE 
0834					DMARK "SCz" 
0834 f5				push af  
0835 3a 49 08			ld a, (.dmark)  
0838 32 77 fb			ld (debug_mark),a  
083b 3a 4a 08			ld a, (.dmark+1)  
083e 32 78 fb			ld (debug_mark+1),a  
0841 3a 4b 08			ld a, (.dmark+2)  
0844 32 79 fb			ld (debug_mark+2),a  
0847 18 03			jr .pastdmark  
0849 ..			.dmark: db "SCz"  
084c f1			.pastdmark: pop af  
084d			endm  
# End of macro DMARK
084d					CALLMONITOR 
084d cd 19 17			call break_point_state  
0850				endm  
# End of macro CALLMONITOR
0850				endif 
0850 c9				ret 
0851				 
0851			 
0851			 
0851			; 
0851			; Read File 
0851			; 
0851			; h - file id to locate 
0851			; l - extent to locate 
0851			; de - pointer to string to read into 
0851			; 
0851			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0851			storage_read: 
0851 d5				push de 
0852			 
0852			; TODO BUG the above push is it popped before the RET Z? 
0852			 
0852			; TODO how to handle multiple part blocks 
0852			 
0852				; locate file extent to read 
0852			 
0852 5c				ld e, h 
0853 55				ld d, l 
0854 21 40 00			ld hl, STORE_BLOCK_PHY 
0857				if DEBUG_STORESE 
0857					DMARK "SRE" 
0857 f5				push af  
0858 3a 6c 08			ld a, (.dmark)  
085b 32 77 fb			ld (debug_mark),a  
085e 3a 6d 08			ld a, (.dmark+1)  
0861 32 78 fb			ld (debug_mark+1),a  
0864 3a 6e 08			ld a, (.dmark+2)  
0867 32 79 fb			ld (debug_mark+2),a  
086a 18 03			jr .pastdmark  
086c ..			.dmark: db "SRE"  
086f f1			.pastdmark: pop af  
0870			endm  
# End of macro DMARK
0870					CALLMONITOR 
0870 cd 19 17			call break_point_state  
0873				endm  
# End of macro CALLMONITOR
0873				endif 
0873 cd 2d 06			call storage_findnextid 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "SRf" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 77 fb			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 78 fb			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 79 fb			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "SRf"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 19 17			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892 cd 32 0d			call ishlzero 
0895			;	ld a, l 
0895			;	add h 
0895			;	cp 0 
0895 c8				ret z			; block not found so EOF 
0896			 
0896				; hl contains page number to load 
0896 d1				pop de   ; get storage 
0897 d5				push de 
0898				if DEBUG_STORESE 
0898					DMARK "SRg" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 77 fb			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 78 fb			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 79 fb			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SRg"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd 19 17			call break_point_state  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd 0c 03			call storage_read_block 
08b7			 
08b7			 
08b7			; TODO if block has no zeros then need to read next block  
08b7			 
08b7			 
08b7					 
08b7 e1				pop hl 		 ; return start of data to show as not EOF 
08b8 23				inc hl   ; past file id 
08b9 23				inc hl   ; past ext 
08ba				if DEBUG_STORESE 
08ba					DMARK "SRe" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 77 fb			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 78 fb			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 79 fb			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SRe"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd 19 17			call break_point_state  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6 c9					ret 
08d7			 
08d7			 
08d7			 
08d7			; 
08d7			; Append File 
08d7			; 
08d7			; hl - file id to locate 
08d7			; de - pointer to (multi block) string to write 
08d7			 
08d7			 
08d7			storage_append: 
08d7				; hl -  file id to append to 
08d7				; de - string to append 
08d7			 
08d7 d5				push de 
08d8				 
08d8				if DEBUG_STORESE 
08d8					DMARK "AP1" 
08d8 f5				push af  
08d9 3a ed 08			ld a, (.dmark)  
08dc 32 77 fb			ld (debug_mark),a  
08df 3a ee 08			ld a, (.dmark+1)  
08e2 32 78 fb			ld (debug_mark+1),a  
08e5 3a ef 08			ld a, (.dmark+2)  
08e8 32 79 fb			ld (debug_mark+2),a  
08eb 18 03			jr .pastdmark  
08ed ..			.dmark: db "AP1"  
08f0 f1			.pastdmark: pop af  
08f1			endm  
# End of macro DMARK
08f1					CALLMONITOR 
08f1 cd 19 17			call break_point_state  
08f4				endm  
# End of macro CALLMONITOR
08f4				endif 
08f4			 
08f4 7d				ld a, l 
08f5 32 5b f8			ld (store_tmpid), a 
08f8			 
08f8				; get file header  
08f8			 
08f8 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fa 3a 5b f8			ld a, (store_tmpid) 
08fd 5f				ld e, a 
08fe			 
08fe 21 40 00				ld hl, STORE_BLOCK_PHY 
0901 cd 2d 06				call storage_findnextid 
0904			 
0904 22 4c f8			ld (store_tmppageid), hl 
0907			 
0907				; TODO handle file id not found 
0907			 
0907				if DEBUG_STORESE 
0907					DMARK "AP2" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 77 fb			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 78 fb			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 79 fb			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "AP2"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 19 17			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923			 
0923				; update file extent count 
0923			 
0923 11 62 f8			ld de, store_page 
0926			 
0926 cd 0c 03			call storage_read_block 
0929			 
0929				if DEBUG_STORESE 
0929					DMARK "AP3" 
0929 f5				push af  
092a 3a 3e 09			ld a, (.dmark)  
092d 32 77 fb			ld (debug_mark),a  
0930 3a 3f 09			ld a, (.dmark+1)  
0933 32 78 fb			ld (debug_mark+1),a  
0936 3a 40 09			ld a, (.dmark+2)  
0939 32 79 fb			ld (debug_mark+2),a  
093c 18 03			jr .pastdmark  
093e ..			.dmark: db "AP3"  
0941 f1			.pastdmark: pop af  
0942			endm  
# End of macro DMARK
0942					CALLMONITOR 
0942 cd 19 17			call break_point_state  
0945				endm  
# End of macro CALLMONITOR
0945				endif 
0945			;	ld (store_tmppageid), hl 
0945			 
0945 3a 64 f8			ld a, (store_page+2) 
0948 3c				inc a 
0949 32 64 f8			ld (store_page+2), a 
094c 32 5a f8			ld (store_tmpext), a 
094f				 
094f				if DEBUG_STORESE 
094f					DMARK "AP3" 
094f f5				push af  
0950 3a 64 09			ld a, (.dmark)  
0953 32 77 fb			ld (debug_mark),a  
0956 3a 65 09			ld a, (.dmark+1)  
0959 32 78 fb			ld (debug_mark+1),a  
095c 3a 66 09			ld a, (.dmark+2)  
095f 32 79 fb			ld (debug_mark+2),a  
0962 18 03			jr .pastdmark  
0964 ..			.dmark: db "AP3"  
0967 f1			.pastdmark: pop af  
0968			endm  
# End of macro DMARK
0968					CALLMONITOR 
0968 cd 19 17			call break_point_state  
096b				endm  
# End of macro CALLMONITOR
096b				endif 
096b 2a 4c f8			ld hl, (store_tmppageid) 
096e 11 62 f8			ld de, store_page 
0971 cd 71 03			call storage_write_block 
0974			 
0974				; find free block 
0974			 
0974 11 00 00			ld de, 0			 ; file extent to locate 
0977			 
0977 21 40 00				ld hl, STORE_BLOCK_PHY 
097a cd 2d 06				call storage_findnextid 
097d			 
097d					; TODO handle no space left 
097d					 
097d 22 4c f8				ld (store_tmppageid), hl 
0980			 
0980				if DEBUG_STORESE 
0980					DMARK "AP4" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 77 fb			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 78 fb			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 79 fb			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "AP4"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd 19 17			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c					; init the buffer with zeros so we can id if the buffer is full or not 
099c			 
099c e5					push hl 
099d c5					push bc 
099e			 
099e 21 62 f8				ld hl, store_page 
09a1 06 40				ld b, STORE_BLOCK_PHY 
09a3 3e 00				ld a, 0 
09a5 77			.zeroblock:	ld (hl), a 
09a6 23					inc hl 
09a7 10 fc				djnz .zeroblock 
09a9			 
09a9 c1					pop bc 
09aa e1					pop hl 
09ab			 
09ab					; construct block 
09ab			 
09ab 3a 5b f8				ld a, (store_tmpid) 
09ae 32 62 f8				ld (store_page), a   ; file id 
09b1 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09b4 32 63 f8				ld (store_page+1), a 
09b7			 
09b7 e1					pop hl    ; get string to write 
09b8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ba 11 64 f8				ld de, store_page+2 
09bd			 
09bd				if DEBUG_STORESE 
09bd					DMARK "AP5" 
09bd f5				push af  
09be 3a d2 09			ld a, (.dmark)  
09c1 32 77 fb			ld (debug_mark),a  
09c4 3a d3 09			ld a, (.dmark+1)  
09c7 32 78 fb			ld (debug_mark+1),a  
09ca 3a d4 09			ld a, (.dmark+2)  
09cd 32 79 fb			ld (debug_mark+2),a  
09d0 18 03			jr .pastdmark  
09d2 ..			.dmark: db "AP5"  
09d5 f1			.pastdmark: pop af  
09d6			endm  
# End of macro DMARK
09d6					CALLMONITOR 
09d6 cd 19 17			call break_point_state  
09d9				endm  
# End of macro CALLMONITOR
09d9				endif 
09d9			 
09d9			 
09d9			 
09d9					; fill buffer with data until end of string or full block 
09d9			 
09d9 7e			.appd:		ld a, (hl) 
09da 12					ld (de), a 
09db fe 00				cp 0 
09dd 28 04				jr z, .appdone 
09df 23					inc hl 
09e0 13					inc de 
09e1 10 f6				djnz .appd 
09e3			 
09e3 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e4 f5					push af   		; save last byte dumped 
09e5			 
09e5			 
09e5 2a 4c f8			ld hl, (store_tmppageid) 
09e8 11 62 f8			ld de, store_page 
09eb				if DEBUG_STORESE 
09eb					DMARK "AP6" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 77 fb			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 78 fb			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 79 fb			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "AP6"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 19 17			call break_point_state  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd 71 03				call storage_write_block 
0a0a			 
0a0a			 
0a0a				; was that a full block of data written? 
0a0a				; any more to write out? 
0a0a			 
0a0a				; if yes then set vars and jump to start of function again 
0a0a			 
0a0a f1					pop af 
0a0b d1					pop de 
0a0c			 
0a0c fe 00				cp 0		 ; no, string was fully written 
0a0e c8					ret z 
0a0f			 
0a0f					; setup vars for next cycle 
0a0f			 
0a0f 3a 5b f8				ld a, (store_tmpid) 
0a12 6f					ld l, a 
0a13 26 00				ld h, 0 
0a15			 
0a15 c3 d7 08			 	jp storage_append	 ; yes, need to write out some more 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			if DEBUG_STORECF 
0a18			storageput:	 
0a18					ret 
0a18			storageread: 
0a18					ld hl, store_page 
0a18					ld b, 200 
0a18					ld a,0 
0a18			.src:		ld (hl),a 
0a18					inc hl 
0a18					djnz .src 
0a18					 
0a18			 
0a18					ld de, 0 
0a18					ld bc, 1 
0a18					ld hl, store_page 
0a18					call cfRead 
0a18			 
0a18				call cfGetError 
0a18				ld hl,scratch 
0a18				call hexout 
0a18				ld hl, scratch+2 
0a18				ld a, 0 
0a18				ld (hl),a 
0a18				ld de, scratch 
0a18				ld a,display_row_1 
0a18				call str_at_display 
0a18				call update_display 
0a18			 
0a18					ld hl, store_page 
0a18					ld (os_cur_ptr),hl 
0a18			 
0a18					ret 
0a18			endif 
0a18			 
0a18			 
0a18			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a18			 
0a18			storage_clear_page: 
0a18 e5				push hl 
0a19 d5				push de 
0a1a c5				push bc 
0a1b 21 62 f8			ld hl, store_page 
0a1e 3e 00			ld a, 0 
0a20 77				ld (hl), a 
0a21			 
0a21 11 63 f8			ld de, store_page+1 
0a24 01 40 00			ld bc, STORE_BLOCK_PHY 
0a27			 
0a27 ed b0			ldir 
0a29				 
0a29 c1				pop bc 
0a2a d1				pop de 
0a2b e1				pop hl 
0a2c c9				ret 
0a2d			 
0a2d			; eof 
# End of file firmware_storage.asm
0a2d			  
0a2d			; support routines for above hardware abstraction layer  
0a2d			  
0a2d			include "firmware_general.asm"        ; general support functions  
0a2d			 
0a2d			; word look up 
0a2d			 
0a2d			; in 
0a2d			; a is the index 
0a2d			; hl is pointer start of array 
0a2d			; 
0a2d			; returns 
0a2d			; hl to the word 
0a2d			; 
0a2d			 
0a2d			table_lookup:  
0a2d d5					push de 
0a2e eb					ex de, hl 
0a2f			 
0a2f 6f					ld l, a 
0a30 26 00				ld h, 0 
0a32 29					add hl, hl 
0a33 19					add hl, de 
0a34 7e					ld a, (hl) 
0a35 23					inc hl 
0a36 66					ld h,(hl) 
0a37 6f					ld l, a 
0a38			 
0a38 d1					pop de 
0a39 c9					ret 
0a3a			 
0a3a			; Delay loops 
0a3a			 
0a3a			 
0a3a			 
0a3a			aDelayInMS: 
0a3a c5				push bc 
0a3b 47				ld b,a 
0a3c			msdelay: 
0a3c c5				push bc 
0a3d				 
0a3d			 
0a3d 01 41 00			ld bc,041h 
0a40 cd 58 0a			call delayloop 
0a43 c1				pop bc 
0a44 05				dec b 
0a45 20 f5			jr nz,msdelay 
0a47			 
0a47			;if CPU_CLOCK_8MHZ 
0a47			;msdelay8: 
0a47			;	push bc 
0a47			;	 
0a47			; 
0a47			;	ld bc,041h 
0a47			;	call delayloop 
0a47			;	pop bc 
0a47			;	dec b 
0a47			;	jr nz,msdelay8 
0a47			;endif 
0a47			 
0a47			 
0a47 c1				pop bc 
0a48 c9				ret 
0a49			 
0a49			 
0a49			delay250ms: 
0a49				;push de 
0a49 01 00 40			ld bc, 04000h 
0a4c c3 58 0a			jp delayloop 
0a4f			delay500ms: 
0a4f				;push de 
0a4f 01 00 80			ld bc, 08000h 
0a52 c3 58 0a			jp delayloop 
0a55			delay1s: 
0a55				;push bc 
0a55			   ; Clobbers A, d and e 
0a55 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a58			delayloop: 
0a58 c5			    push bc 
0a59			 
0a59			if BASE_CPM 
0a59				ld bc, CPM_DELAY_TUNE 
0a59			.cpmloop: 
0a59				push bc 
0a59			 
0a59			endif 
0a59			 
0a59			 
0a59			 
0a59			delayloopi: 
0a59			;	push bc 
0a59			;.dl: 
0a59 cb 47		    bit     0,a    	; 8 
0a5b cb 47		    bit     0,a    	; 8 
0a5d cb 47		    bit     0,a    	; 8 
0a5f e6 ff		    and     255  	; 7 
0a61 0b			    dec     bc      	; 6 
0a62 79			    ld      a,c     	; 4 
0a63 b0			    or      b     	; 4 
0a64 c2 59 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a67			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a67				;pop de 
0a67			;pop bc 
0a67			 
0a67			if BASE_CPM 
0a67				pop bc 
0a67				 
0a67			    dec     bc      	; 6 
0a67			    ld      a,c     	; 4 
0a67			    or      b     	; 4 
0a67			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a67				 
0a67			 
0a67			endif 
0a67			;if CPU_CLOCK_8MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67			 
0a67			;if CPU_CLOCK_10MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67 c1			    pop bc 
0a68			 
0a68 c9				ret 
0a69			 
0a69			 
0a69			 
0a69			; eof 
# End of file firmware_general.asm
0a69			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a69			; display routines that use the physical hardware abstraction layer 
0a69			 
0a69			 
0a69			; information window 
0a69			 
0a69			; pass hl with 1st string to display 
0a69			; pass de with 2nd string to display 
0a69			 
0a69			info_panel: 
0a69 e5				push hl 
0a6a			 
0a6a 2a d8 f8			ld hl, (display_fb_active) 
0a6d e5				push hl    ; future de destination 
0a6e 21 bd fa				ld hl, display_fb0 
0a71 22 d8 f8				ld (display_fb_active), hl 
0a74			 
0a74 cd d5 0a			call clear_display 
0a77			 
0a77			 
0a77 3e 55			ld a, display_row_3 + 5 
0a79 cd e8 0a			call str_at_display 
0a7c			 
0a7c e1				pop hl 
0a7d d1				pop de 
0a7e			 
0a7e e5				push hl 
0a7f			 
0a7f			 
0a7f 3e 2d			ld a, display_row_2 + 5 
0a81 cd e8 0a			call str_at_display 
0a84			 
0a84			 
0a84 cd f8 0a			call update_display 
0a87 cd 21 1c			call next_page_prompt 
0a8a cd d5 0a			call clear_display 
0a8d			 
0a8d				 
0a8d 21 1c fa				ld hl, display_fb1 
0a90 22 d8 f8				ld (display_fb_active), hl 
0a93 cd f8 0a			call update_display 
0a96			 
0a96			 
0a96 c9				ret 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			; TODO windowing? 
0a97			 
0a97			; TODO scroll line up 
0a97			 
0a97			scroll_up: 
0a97			 
0a97 e5				push hl 
0a98 d5				push de 
0a99 c5				push bc 
0a9a			 
0a9a				; get frame buffer  
0a9a			 
0a9a 2a d8 f8			ld hl, (display_fb_active) 
0a9d e5				push hl    ; future de destination 
0a9e			 
0a9e 11 28 00			ld  de, display_cols 
0aa1 19				add hl, de 
0aa2			 
0aa2 d1				pop de 
0aa3			 
0aa3				;ex de, hl 
0aa3 01 9f 00			ld bc, display_fb_len -1  
0aa6			;if DEBUG_FORTH_WORDS 
0aa6			;	DMARK "SCL" 
0aa6			;	CALLMONITOR 
0aa6			;endif	 
0aa6 ed b0			ldir 
0aa8			 
0aa8				; wipe bottom row 
0aa8			 
0aa8			 
0aa8 2a d8 f8			ld hl, (display_fb_active) 
0aab 11 a0 00			ld de, display_cols*display_rows 
0aae 19				add hl, de 
0aaf 06 28			ld b, display_cols 
0ab1 3e 20			ld a, ' ' 
0ab3			.scwipe: 
0ab3 77				ld (hl), a 
0ab4 2b				dec hl 
0ab5 10 fc			djnz .scwipe 
0ab7			 
0ab7				;pop hl 
0ab7			 
0ab7 c1				pop bc 
0ab8 d1				pop de 
0ab9 e1				pop hl 
0aba			 
0aba c9				ret 
0abb			 
0abb			 
0abb			;scroll_upo: 
0abb			;	ld de, display_row_1 
0abb			 ;	ld hl, display_row_2 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_2 
0abb			 ;	ld hl, display_row_3 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_3 
0abb			 ;	ld hl, display_row_4 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			 
0abb			; TODO clear row 4 
0abb			 
0abb			;	ret 
0abb			 
0abb				 
0abb			scroll_down: 
0abb			 
0abb e5				push hl 
0abc d5				push de 
0abd c5				push bc 
0abe			 
0abe				; get frame buffer  
0abe			 
0abe 2a d8 f8			ld hl, (display_fb_active) 
0ac1			 
0ac1 11 9f 00			ld de, display_fb_len - 1 
0ac4 19				add hl, de 
0ac5			 
0ac5 e5			push hl    ; future de destination 
0ac6			 
0ac6 11 28 00			ld  de, display_cols 
0ac9 ed 52			sbc hl, de 
0acb			 
0acb			 
0acb d1				pop de 
0acc			 
0acc			;	ex de, hl 
0acc 01 9f 00			ld bc, display_fb_len -1  
0acf			 
0acf			 
0acf				 
0acf			 
0acf ed b0			ldir 
0ad1			 
0ad1				; wipe bottom row 
0ad1			 
0ad1			 
0ad1			;	ld hl, (display_fb_active) 
0ad1			;;	ld de, display_cols*display_rows 
0ad1			;;	add hl, de 
0ad1			;	ld b, display_cols 
0ad1			;	ld a, ' ' 
0ad1			;.scwiped: 
0ad1			;	ld (hl), a 
0ad1			;	dec hl 
0ad1			;	djnz .scwiped 
0ad1			 
0ad1				;pop hl 
0ad1			 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4			 
0ad4 c9				ret 
0ad5			;scroll_down: 
0ad5			;	ld de, display_row_4 
0ad5			;	ld hl, display_row_3 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_3 
0ad5			; 	ld hl, display_row_2 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_2 
0ad5			;	ld hl, display_row_1 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;;; TODO clear row 1 
0ad5			;	ret 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			; clear active frame buffer 
0ad5			 
0ad5			clear_display: 
0ad5 3e 20			ld a, ' ' 
0ad7 c3 da 0a			jp fill_display 
0ada			 
0ada			; fill active frame buffer with a char in A 
0ada			 
0ada			fill_display: 
0ada 06 a0			ld b,display_fb_len 
0adc 2a d8 f8			ld hl, (display_fb_active) 
0adf 77			.fd1:	ld (hl),a 
0ae0 23				inc hl 
0ae1 10 fc			djnz .fd1 
0ae3 23				inc hl 
0ae4 3e 00			ld a,0 
0ae6 77				ld (hl),a 
0ae7			 
0ae7			 
0ae7 c9				ret 
0ae8			; Write string (DE) at pos (A) to active frame buffer 
0ae8			 
0ae8 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aeb 06 00					ld b,0 
0aed 4f					ld c,a 
0aee 09					add hl,bc 
0aef 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0af0 b7			            OR   A              ;Null terminator? 
0af1 c8			            RET  Z              ;Yes, so finished 
0af2 77					ld (hl),a 
0af3 23				inc hl 
0af4 13			            INC  DE             ;Point to next character 
0af5 18 f8		            JR   .sad1     ;Repeat 
0af7 c9					ret 
0af8			 
0af8			; using current frame buffer write to physical display 
0af8			 
0af8			update_display: 
0af8 e5				push hl 
0af9 2a d8 f8			ld hl, (display_fb_active) 
0afc cd b5 66			call write_display 
0aff e1				pop hl 
0b00 c9				ret 
0b01			 
0b01			; TODO scrolling 
0b01			 
0b01			 
0b01			; move cursor right one char 
0b01			cursor_right: 
0b01			 
0b01				; TODO shift right 
0b01				; TODO if beyond max col 
0b01				; TODO       cursor_next_line 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cursor_next_line: 
0b02				; TODO first char 
0b02				; TODO line down 
0b02				; TODO if past last row 
0b02				; TODO    scroll up 
0b02			 
0b02 c9				ret 
0b03			 
0b03			cursor_left: 
0b03				; TODO shift left 
0b03				; TODO if beyond left  
0b03				; TODO     cursor prev line 
0b03				 
0b03 c9				ret 
0b04			 
0b04			cursor_prev_line: 
0b04				; TODO last char 
0b04				; TODO line up 
0b04				; TODO if past first row 
0b04				; TODO   scroll down 
0b04			 
0b04 c9				ret 
0b05			 
0b05			 
0b05			cout: 
0b05				; A - char 
0b05 c9				ret 
0b06			 
0b06			 
0b06			; Display a menu and allow item selection (optional toggle items) 
0b06			; 
0b06			; format: 
0b06			; hl pointer to word array with zero term for items 
0b06			; e.g.    db item1 
0b06			;         db .... 
0b06			;         db 0 
0b06			; 
0b06			; a = starting menu item  
0b06			; 
0b06			; de = pointer item toggle array   (todo) 
0b06			; 
0b06			; returns item selected in a 1-... 
0b06			; returns 0 if back button pressed 
0b06			; 
0b06			; NOTE: Uses system frame buffer to display 
0b06			; 
0b06			; LEFT, Q = go back 
0b06			; RIGHT, SPACE, CR = select 
0b06			; UP, A - Up 
0b06			; DOWN, Z - Down 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			menu: 
0b06			 
0b06					; keep array pointer 
0b06			 
0b06 22 60 f8				ld (store_tmp1), hl 
0b09 32 5e f8				ld (store_tmp2), a 
0b0c			 
0b0c					; check for key bounce 
0b0c			 
0b0c			if BASE_KEV 
0b0c			 
0b0c cd 00 6a		.mbounce:	call cin 
0b0f fe 00				cp 0 
0b11 20 f9				jr nz, .mbounce 
0b13			endif 
0b13					; for ease use ex 
0b13			 
0b13					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b13 21 bd fa				ld hl, display_fb0 
0b16 22 d8 f8				ld (display_fb_active), hl 
0b19			 
0b19 cd d5 0a		.mloop:		call clear_display 
0b1c cd f8 0a				call update_display 
0b1f			 
0b1f					; draw selection id '>' at 1 
0b1f			 
0b1f					; init start of list display 
0b1f			 
0b1f 3e 05				ld a, 5 
0b21 32 5c f8				ld (store_tmp3), a   ; display row count 
0b24 3a 5e f8				ld a,( store_tmp2) 
0b27 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b2a			 
0b2a					 
0b2a			.mitem:	 
0b2a			 
0b2a			 
0b2a 3a 5f f8				ld a,(store_tmp2+1) 
0b2d 6f					ld l, a 
0b2e 26 00				ld h, 0 
0b30 29					add hl, hl 
0b31 ed 5b 60 f8			ld de, (store_tmp1) 
0b35 19					add hl, de 
0b36 7e					ld a, (hl) 
0b37 23					inc hl 
0b38 66					ld h,(hl) 
0b39 6f					ld l, a 
0b3a			 
0b3a cd 32 0d				call ishlzero 
0b3d 28 1a				jr z, .mdone 
0b3f			 
0b3f eb					ex de, hl 
0b40 3a 5c f8				ld a, (store_tmp3) 
0b43 cd e8 0a				call str_at_display 
0b46					 
0b46			 
0b46					; next item 
0b46 3a 5f f8				ld a, (store_tmp2+1) 
0b49 3c					inc a 
0b4a 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b4d			 
0b4d			 		; next row 
0b4d			 
0b4d 3a 5c f8				ld a, (store_tmp3) 
0b50 c6 28				add display_cols 
0b52 32 5c f8				ld (store_tmp3), a 
0b55			 
0b55					; at end of screen? 
0b55			 
0b55 fe 10				cp display_rows*4 
0b57 20 d1				jr nz, .mitem 
0b59			 
0b59			 
0b59			.mdone: 
0b59 cd 32 0d				call ishlzero 
0b5c 28 08				jr z, .nodn 
0b5e			 
0b5e 3e 78				ld a, display_row_4 
0b60 11 df 0b				ld de, .mdown 
0b63 cd e8 0a				call str_at_display 
0b66			 
0b66					; draw options to fill the screens with active item on line 1 
0b66					; if current option is 2 or more then display ^ in top 
0b66			 
0b66 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b69 fe 00				cp 0 
0b6b 28 08				jr z, .noup 
0b6d			 
0b6d 3e 00				ld a, 0 
0b6f 11 dd 0b				ld de, .mup 
0b72 cd e8 0a				call str_at_display 
0b75			 
0b75 3e 02		.noup:		ld a, 2 
0b77 11 db 0b				ld de, .msel 
0b7a cd e8 0a				call str_at_display 
0b7d			 
0b7d					; if current option + 1 is not null then display V in bottom 
0b7d					; get key 
0b7d cd f8 0a				call update_display 
0b80			 
0b80			 
0b80					; handle key 
0b80			 
0b80 cd ef 69				call cin_wait 
0b83			 
0b83 fe 05				cp KEY_UP 
0b85 28 2b				jr z, .mgoup 
0b87 fe 61				cp 'a' 
0b89 28 27				jr z, .mgoup 
0b8b fe 0a				cp KEY_DOWN 
0b8d 28 32				jr z, .mgod 
0b8f fe 7a				cp 'z' 
0b91 28 2e				jr z, .mgod 
0b93 fe 20				cp ' ' 
0b95 28 34				jr z, .goend 
0b97 fe 0c				cp KEY_RIGHT 
0b99 28 30				jr z, .goend 
0b9b fe 0d				cp KEY_CR 
0b9d 28 2c				jr z, .goend 
0b9f fe 71				cp 'q' 
0ba1 28 0b				jr z, .goback 
0ba3			 
0ba3 fe 0b				cp KEY_LEFT 
0ba5 28 07				jr z, .goback 
0ba7 fe 08				cp KEY_BS 
0ba9 28 03				jr z, .goback 
0bab c3 19 0b				jp .mloop 
0bae			 
0bae			.goback: 
0bae 3e 00			ld a, 0 
0bb0 18 1d			jr .goend2 
0bb2			 
0bb2				; move up one 
0bb2			.mgoup: 
0bb2 3a 5e f8				ld a, (store_tmp2) 
0bb5 fe 00				cp 0 
0bb7 ca 19 0b				jp z, .mloop 
0bba 3d					dec a 
0bbb 32 5e f8				ld (store_tmp2), a 
0bbe c3 19 0b				jp .mloop 
0bc1			 
0bc1				; move down one 
0bc1			.mgod: 
0bc1 3a 5e f8				ld a, (store_tmp2) 
0bc4 3c					inc a 
0bc5 32 5e f8				ld (store_tmp2), a 
0bc8 c3 19 0b				jp .mloop 
0bcb			 
0bcb			 
0bcb			.goend: 
0bcb					; get selected item number 
0bcb			 
0bcb 3a 5e f8				ld a, (store_tmp2) 
0bce 3c					inc a 
0bcf			 
0bcf			.goend2: 
0bcf f5					push af 
0bd0			 
0bd0					; restore active fb 
0bd0					; TODO BUG assumes fb1 
0bd0			 
0bd0 21 1c fa				ld hl, display_fb1 
0bd3 22 d8 f8				ld (display_fb_active), hl 
0bd6			 
0bd6					; restore main regs 
0bd6			 
0bd6			 
0bd6 cd f8 0a				call update_display 
0bd9			 
0bd9 f1					pop af 
0bda			 
0bda c9				ret 
0bdb			 
0bdb .. 00		.msel:   db ">",0 
0bdd .. 00		.mup:   db "^",0 
0bdf .. 00		.mdown:   db "v",0 
0be1			 
0be1			 
0be1			; eof 
0be1			 
# End of file firmware_display.asm
0be1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0be1			; random number generators 
0be1			 
0be1			 
0be1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0be1			 
0be1			 
0be1			;-----> Generate a random number 
0be1			; output a=answer 0<=a<=255 
0be1			; all registers are preserved except: af 
0be1			random: 
0be1 e5			        push    hl 
0be2 d5			        push    de 
0be3 2a ba f8		        ld      hl,(randData) 
0be6 ed 5f		        ld      a,r 
0be8 57			        ld      d,a 
0be9 5e			        ld      e,(hl) 
0bea 19			        add     hl,de 
0beb 85			        add     a,l 
0bec ac			        xor     h 
0bed 22 ba f8		        ld      (randData),hl 
0bf0 d1			        pop     de 
0bf1 e1			        pop     hl 
0bf2 c9			        ret 
0bf3			 
0bf3			 
0bf3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf3			 
0bf3			 
0bf3			 
0bf3			;------LFSR------ 
0bf3			;James Montelongo 
0bf3			;optimized by Spencer Putt 
0bf3			;out: 
0bf3			; a = 8 bit random number 
0bf3			RandLFSR: 
0bf3 21 c0 f8		        ld hl,LFSRSeed+4 
0bf6 5e			        ld e,(hl) 
0bf7 23			        inc hl 
0bf8 56			        ld d,(hl) 
0bf9 23			        inc hl 
0bfa 4e			        ld c,(hl) 
0bfb 23			        inc hl 
0bfc 7e			        ld a,(hl) 
0bfd 47			        ld b,a 
0bfe cb 13		        rl e  
0c00 cb 12			rl d 
0c02 cb 11		        rl c  
0c04 17				rla 
0c05 cb 13		        rl e  
0c07 cb 12			rl d 
0c09 cb 11		        rl c  
0c0b 17				rla 
0c0c cb 13		        rl e  
0c0e cb 12			rl d 
0c10 cb 11		        rl c  
0c12 17				rla 
0c13 67			        ld h,a 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 cb 11		        rl c  
0c1a 17				rla 
0c1b a8			        xor b 
0c1c cb 13		        rl e  
0c1e cb 12			rl d 
0c20 ac			        xor h 
0c21 a9			        xor c 
0c22 aa			        xor d 
0c23 21 c2 f8		        ld hl,LFSRSeed+6 
0c26 11 c3 f8		        ld de,LFSRSeed+7 
0c29 01 07 00		        ld bc,7 
0c2c ed b8		        lddr 
0c2e 12			        ld (de),a 
0c2f c9			        ret 
0c30			 
0c30			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c30			 
0c30			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c30			 
0c30			 
0c30			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c30			 
0c30			prng16: 
0c30			;Inputs: 
0c30			;   (seed1) contains a 16-bit seed value 
0c30			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c30			;Outputs: 
0c30			;   HL is the result 
0c30			;   BC is the result of the LCG, so not that great of quality 
0c30			;   DE is preserved 
0c30			;Destroys: 
0c30			;   AF 
0c30			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c30			;160cc 
0c30			;26 bytes 
0c30 2a b4 f8		    ld hl,(seed1) 
0c33 44			    ld b,h 
0c34 4d			    ld c,l 
0c35 29			    add hl,hl 
0c36 29			    add hl,hl 
0c37 2c			    inc l 
0c38 09			    add hl,bc 
0c39 22 b4 f8		    ld (seed1),hl 
0c3c 2a b2 f8		    ld hl,(seed2) 
0c3f 29			    add hl,hl 
0c40 9f			    sbc a,a 
0c41 e6 2d		    and %00101101 
0c43 ad			    xor l 
0c44 6f			    ld l,a 
0c45 22 b2 f8		    ld (seed2),hl 
0c48 09			    add hl,bc 
0c49 c9			    ret 
0c4a			 
0c4a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c4a			 
0c4a			rand32: 
0c4a			;Inputs: 
0c4a			;   (seed1_0) holds the lower 16 bits of the first seed 
0c4a			;   (seed1_1) holds the upper 16 bits of the first seed 
0c4a			;   (seed2_0) holds the lower 16 bits of the second seed 
0c4a			;   (seed2_1) holds the upper 16 bits of the second seed 
0c4a			;   **NOTE: seed2 must be non-zero 
0c4a			;Outputs: 
0c4a			;   HL is the result 
0c4a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c4a			;Destroys: 
0c4a			;   AF 
0c4a			;Tested and passes all CAcert tests 
0c4a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c4a			;it has a period of 18,446,744,069,414,584,320 
0c4a			;roughly 18.4 quintillion. 
0c4a			;LFSR taps: 0,2,6,7  = 11000101 
0c4a			;291cc 
0c4a			;seed1_0=$+1 
0c4a			;    ld hl,12345 
0c4a			;seed1_1=$+1 
0c4a			;    ld de,6789 
0c4a			;    ld b,h 
0c4a			;    ld c,l 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    inc l 
0c4a			;    add hl,bc 
0c4a			;    ld (seed1_0),hl 
0c4a			;    ld hl,(seed1_1) 
0c4a			;    adc hl,de 
0c4a			;    ld (seed1_1),hl 
0c4a			;    ex de,hl 
0c4a			;seed2_0=$+1 
0c4a			;    ld hl,9876 
0c4a			;seed2_1=$+1 
0c4a			;    ld bc,54321 
0c4a			;    add hl,hl \ rl c \ rl b 
0c4a			;    ld (seed2_1),bc 
0c4a			;    sbc a,a 
0c4a			;    and %11000101 
0c4a			;    xor l 
0c4a			;    ld l,a 
0c4a			;    ld (seed2_0),hl 
0c4a			;    ex de,hl 
0c4a			;    add hl,bc 
0c4a			;    ret 
0c4a			; 
0c4a			 
0c4a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c4a			; 20 bytes, 86 cycles (excluding ret) 
0c4a			 
0c4a			; returns   hl = pseudorandom number 
0c4a			; corrupts   a 
0c4a			 
0c4a			; generates 16-bit pseudorandom numbers with a period of 65535 
0c4a			; using the xorshift method: 
0c4a			 
0c4a			; hl ^= hl << 7 
0c4a			; hl ^= hl >> 9 
0c4a			; hl ^= hl << 8 
0c4a			 
0c4a			; some alternative shift triplets which also perform well are: 
0c4a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c4a			 
0c4a			;  org 32768 
0c4a			 
0c4a			xrnd: 
0c4a 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c4d 3e 00		  ld a,0 
0c4f bd			  cp l 
0c50 20 02		  jr nz, .xrnd1 
0c52 2e 01		  ld l, 1 
0c54			.xrnd1: 
0c54			 
0c54 7c			  ld a,h 
0c55 1f			  rra 
0c56 7d			  ld a,l 
0c57 1f			  rra 
0c58 ac			  xor h 
0c59 67			  ld h,a 
0c5a 7d			  ld a,l 
0c5b 1f			  rra 
0c5c 7c			  ld a,h 
0c5d 1f			  rra 
0c5e ad			  xor l 
0c5f 6f			  ld l,a 
0c60 ac			  xor h 
0c61 67			  ld h,a 
0c62			 
0c62 22 b8 f8		  ld (xrandc),hl 
0c65			 
0c65 c9			  ret 
0c66			;  
0c66			 
0c66			 
0c66			;;;; int maths 
0c66			 
0c66			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c66			; Divide 16-bit values (with 16-bit result) 
0c66			; In: Divide BC by divider DE 
0c66			; Out: BC = result, HL = rest 
0c66			; 
0c66			Div16: 
0c66 21 00 00		    ld hl,0 
0c69 78			    ld a,b 
0c6a 06 08		    ld b,8 
0c6c			Div16_Loop1: 
0c6c 17			    rla 
0c6d ed 6a		    adc hl,hl 
0c6f ed 52		    sbc hl,de 
0c71 30 01		    jr nc,Div16_NoAdd1 
0c73 19			    add hl,de 
0c74			Div16_NoAdd1: 
0c74 10 f6		    djnz Div16_Loop1 
0c76 17			    rla 
0c77 2f			    cpl 
0c78 47			    ld b,a 
0c79 79			    ld a,c 
0c7a 48			    ld c,b 
0c7b 06 08		    ld b,8 
0c7d			Div16_Loop2: 
0c7d 17			    rla 
0c7e ed 6a		    adc hl,hl 
0c80 ed 52		    sbc hl,de 
0c82 30 01		    jr nc,Div16_NoAdd2 
0c84 19			    add hl,de 
0c85			Div16_NoAdd2: 
0c85 10 f6		    djnz Div16_Loop2 
0c87 17			    rla 
0c88 2f			    cpl 
0c89 41			    ld b,c 
0c8a 4f			    ld c,a 
0c8b c9			ret 
0c8c			 
0c8c			 
0c8c			;http://z80-heaven.wikidot.com/math 
0c8c			; 
0c8c			;Inputs: 
0c8c			;     DE and A are factors 
0c8c			;Outputs: 
0c8c			;     A is not changed 
0c8c			;     B is 0 
0c8c			;     C is not changed 
0c8c			;     DE is not changed 
0c8c			;     HL is the product 
0c8c			;Time: 
0c8c			;     342+6x 
0c8c			; 
0c8c			Mult16: 
0c8c			 
0c8c 06 08		     ld b,8          ;7           7 
0c8e 21 00 00		     ld hl,0         ;10         10 
0c91 29			       add hl,hl     ;11*8       88 
0c92 07			       rlca          ;4*8        32 
0c93 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c95 19			         add hl,de   ;--         -- 
0c96 10 f9		       djnz $-5      ;13*7+8     99 
0c98 c9			ret 
0c99			 
0c99			; 
0c99			; Square root of 16-bit value 
0c99			; In:  HL = value 
0c99			; Out:  D = result (rounded down) 
0c99			; 
0c99			;Sqr16: 
0c99			;    ld de,#0040 
0c99			;    ld a,l 
0c99			;    ld l,h 
0c99			;    ld h,d 
0c99			;    or a 
0c99			;    ld b,8 
0c99			;Sqr16_Loop: 
0c99			;    sbc hl,de 
0c99			;    jr nc,Sqr16_Skip 
0c99			;    add hl,de 
0c99			;Sqr16_Skip: 
0c99			;    ccf 
0c99			;    rl d 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    djnz Sqr16_Loop 
0c99			;    ret 
0c99			; 
0c99			; 
0c99			; Divide 8-bit values 
0c99			; In: Divide E by divider C 
0c99			; Out: A = result, B = rest 
0c99			; 
0c99			Div8: 
0c99 af			    xor a 
0c9a 06 08		    ld b,8 
0c9c			Div8_Loop: 
0c9c cb 13		    rl e 
0c9e 17			    rla 
0c9f 91			    sub c 
0ca0 30 01		    jr nc,Div8_NoAdd 
0ca2 81			    add a,c 
0ca3			Div8_NoAdd: 
0ca3 10 f7		    djnz Div8_Loop 
0ca5 47			    ld b,a 
0ca6 7b			    ld a,e 
0ca7 17			    rla 
0ca8 2f			    cpl 
0ca9 c9			    ret 
0caa			 
0caa			; 
0caa			; Multiply 8-bit value with a 16-bit value (unrolled) 
0caa			; In: Multiply A with DE 
0caa			; Out: HL = result 
0caa			; 
0caa			Mult12U: 
0caa 2e 00		    ld l,0 
0cac 87			    add a,a 
0cad 30 01		    jr nc,Mult12U_NoAdd0 
0caf 19			    add hl,de 
0cb0			Mult12U_NoAdd0: 
0cb0 29			    add hl,hl 
0cb1 87			    add a,a 
0cb2 30 01		    jr nc,Mult12U_NoAdd1 
0cb4 19			    add hl,de 
0cb5			Mult12U_NoAdd1: 
0cb5 29			    add hl,hl 
0cb6 87			    add a,a 
0cb7 30 01		    jr nc,Mult12U_NoAdd2 
0cb9 19			    add hl,de 
0cba			Mult12U_NoAdd2: 
0cba 29			    add hl,hl 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd3 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd3: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd4 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd4: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd5 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd5: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd6 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd6: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 d0			    ret nc 
0cd1 19			    add hl,de 
0cd2 c9			    ret 
0cd3			 
0cd3			; 
0cd3			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd3			; In: Multiply A with DE 
0cd3			;      Put lowest value in A for most efficient calculation 
0cd3			; Out: HL = result 
0cd3			; 
0cd3			Mult12R: 
0cd3 21 00 00		    ld hl,0 
0cd6			Mult12R_Loop: 
0cd6 cb 3f		    srl a 
0cd8 30 01		    jr nc,Mult12R_NoAdd 
0cda 19			    add hl,de 
0cdb			Mult12R_NoAdd: 
0cdb cb 23		    sla e 
0cdd cb 12		    rl d 
0cdf b7			    or a 
0ce0 c2 d6 0c		    jp nz,Mult12R_Loop 
0ce3 c9			    ret 
0ce4			 
0ce4			; 
0ce4			; Multiply 16-bit values (with 32-bit result) 
0ce4			; In: Multiply BC with DE 
0ce4			; Out: BCHL = result 
0ce4			; 
0ce4			Mult32: 
0ce4 79			    ld a,c 
0ce5 48			    ld c,b 
0ce6 21 00 00		    ld hl,0 
0ce9 06 10		    ld b,16 
0ceb			Mult32_Loop: 
0ceb 29			    add hl,hl 
0cec 17			    rla 
0ced cb 11		    rl c 
0cef 30 07		    jr nc,Mult32_NoAdd 
0cf1 19			    add hl,de 
0cf2 ce 00		    adc a,0 
0cf4 d2 f8 0c		    jp nc,Mult32_NoAdd 
0cf7 0c			    inc c 
0cf8			Mult32_NoAdd: 
0cf8 10 f1		    djnz Mult32_Loop 
0cfa 41			    ld b,c 
0cfb 4f			    ld c,a 
0cfc c9			    ret 
0cfd			 
0cfd			 
0cfd			 
0cfd			; 
0cfd			; Multiply 8-bit values 
0cfd			; In:  Multiply H with E 
0cfd			; Out: HL = result 
0cfd			; 
0cfd			Mult8: 
0cfd 16 00		    ld d,0 
0cff 6a			    ld l,d 
0d00 06 08		    ld b,8 
0d02			Mult8_Loop: 
0d02 29			    add hl,hl 
0d03 30 01		    jr nc,Mult8_NoAdd 
0d05 19			    add hl,de 
0d06			Mult8_NoAdd: 
0d06 10 fa		    djnz Mult8_Loop 
0d08 c9			    ret 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			;;http://z80-heaven.wikidot.com/math 
0d09			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d09			; 
0d09			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d09			;     ld a,16        ;7 
0d09			;     ld hl,0        ;10 
0d09			;     jp $+5         ;10 
0d09			;.DivLoop: 
0d09			;       add hl,bc    ;-- 
0d09			;       dec a        ;64 
0d09			;       jr z,.DivLoopEnd        ;86 
0d09			; 
0d09			;       sla e        ;128 
0d09			;       rl d         ;128 
0d09			;       adc hl,hl    ;240 
0d09			;       sbc hl,bc    ;240 
0d09			;       jr nc,.DivLoop ;23|21 
0d09			;       inc e        ;-- 
0d09			;       jp .DivLoop+1 
0d09			; 
0d09			;.DivLoopEnd: 
0d09			 
0d09			;HL_Div_C: 
0d09			;Inputs: 
0d09			;     HL is the numerator 
0d09			;     C is the denominator 
0d09			;Outputs: 
0d09			;     A is the remainder 
0d09			;     B is 0 
0d09			;     C is not changed 
0d09			;     DE is not changed 
0d09			;     HL is the quotient 
0d09			; 
0d09			;       ld b,16 
0d09			;       xor a 
0d09			;         add hl,hl 
0d09			;         rla 
0d09			;         cp c 
0d09			;         jr c,$+4 
0d09			;           inc l 
0d09			;           sub c 
0d09			;         djnz $-7 
0d09			 
0d09			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d09			 
0d09			addatohl: 
0d09 85			    add   a, l    ; A = A+L 
0d0a 6f			    ld    l, a    ; L = A+L 
0d0b 8c			    adc   a, h    ; A = A+L+H+carry 
0d0c 95			    sub   l       ; A = H+carry 
0d0d 67			    ld    h, a    ; H = H+carry 
0d0e c9			ret 
0d0f			 
0d0f			addatode: 
0d0f 83			    add   a, e    ; A = A+L 
0d10 5f			    ld    e, a    ; L = A+L 
0d11 8a			    adc   a, d    ; A = A+L+H+carry 
0d12 93			    sub   e       ; A = H+carry 
0d13 57			    ld    d, a    ; H = H+carry 
0d14 c9			ret 
0d15			 
0d15			 
0d15			addatobc: 
0d15 81			    add   a, c    ; A = A+L 
0d16 4f			    ld    c, a    ; L = A+L 
0d17 88			    adc   a, b    ; A = A+L+H+carry 
0d18 91			    sub   c       ; A = H+carry 
0d19 47			    ld    b, a    ; H = H+carry 
0d1a c9			ret 
0d1b			 
0d1b			subafromhl: 
0d1b			   ; If A=0 do nothing 
0d1b			    ; Otherwise flip A's sign. Since 
0d1b			    ; the upper byte becomes -1, also 
0d1b			    ; substract 1 from H. 
0d1b ed 44		    neg 
0d1d ca 26 0d		    jp    z, Skip 
0d20 25			    dec   h 
0d21			     
0d21			    ; Now add the low byte as usual 
0d21			    ; Two's complement takes care of 
0d21			    ; ensuring the result is correct 
0d21 85			    add   a, l 
0d22 6f			    ld    l, a 
0d23 8c			    adc   a, h 
0d24 95			    sub   l 
0d25 67			    ld    h, a 
0d26			Skip: 
0d26 c9				ret 
0d27			 
0d27			 
0d27			; compare hl and de 
0d27			; returns:  
0d27			; if hl = de, z=1, s=0, c0=0 
0d27			; if hl > de, z=0, s=0, c=0 
0d27			; if hl < de, z=0, s=1, c=1 
0d27			cmp16:	 
0d27 b7				or a 
0d28 ed 52			sbc hl,de 
0d2a e0				ret po 
0d2b 7c				ld a,h 
0d2c 1f				rra 
0d2d ee 40			xor 01000000B 
0d2f 37				scf 
0d30 8f				adc a,a 
0d31 c9				ret 
0d32			 
0d32			 
0d32			; test if hl contains zero   - A is destroyed 
0d32			 
0d32			ishlzero:    
0d32 b7				or a     ; reset flags 
0d33 7c				ld a, h 
0d34 b5				or l        	 
0d35			 
0d35 c9				ret 
0d36			 
0d36			 
0d36			 
0d36			 
0d36			if FORTH_ENABLE_FLOATMATH 
0d36			;include "float/bbcmath.z80" 
0d36			include "float/lpfpcalc.asm" 
0d36			endif 
0d36			 
0d36			 
0d36			; eof 
0d36			 
# End of file firmware_maths.asm
0d36			include "firmware_strings.asm"   ; string handling  
0d36			 
0d36			 
0d36			; TODO string len 
0d36			; input text string, end on cr with zero term 
0d36			; a offset into frame buffer to start prompt 
0d36			; d is max length 
0d36			; e is display size TODO 
0d36			; c is current cursor position 
0d36			; hl is ptr to where string will be stored 
0d36			 
0d36			 
0d36			; TODO check limit of buffer for new inserts 
0d36			; TODO check insert does not push beyond buffer 
0d36			; TODO scroll in a limited display area 
0d36			; TODO scroll whole screen on page wrap 
0d36			 
0d36			 
0d36			; TODO handle KEY_PREVWORD 
0d36			; TODO handle KEY_NEXTWORD 
0d36			; TODO handle KEY_HOME 
0d36			; TODO handle KEY_END 
0d36			; TODO use LCD cursor? 
0d36			 
0d36 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d39 81					add c 
0d3a 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3d 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d40 79					ld a, c 
0d41 cd 09 0d				call addatohl 
0d44 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d47 7a					ld a,d 
0d48 32 72 fb			        ld (input_size), a       ; save length of input area 
0d4b 79					ld a, c 
0d4c 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d4f 7b					ld a,e 
0d50 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d53					 
0d53					 
0d53			 
0d53			;		ld a,(input_ptr) 
0d53			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d53			 
0d53			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d53					; init cursor shape if not set by the cin routines 
0d53 21 d0 f8				ld hl, cursor_shape 
0d56 3e ff				ld a, 255 
0d58 77					ld (hl), a 
0d59 23					inc hl 
0d5a 3e 00				ld a, 0 
0d5c 77					ld (hl), a 
0d5d			 
0d5d 3e 0f				ld a, CUR_BLINK_RATE 
0d5f 32 6c fb				ld (input_cur_flash), a 
0d62 3e 01				ld a, 1 
0d64 32 6b fb				ld (input_cur_onoff),a 
0d67			 
0d67			;	if DEBUG_INPUT 
0d67			;		push af 
0d67			;		ld a, 'I' 
0d67			;		ld (debug_mark),a 
0d67			;		pop af 
0d67			;		CALLMONITOR 
0d67			;	endif 
0d67			.is1:		; main entry loop 
0d67			 
0d67			 
0d67			 
0d67					; pause 1ms 
0d67			 
0d67 3e 01				ld a, 1 
0d69 cd 3a 0a				call aDelayInMS 
0d6c			 
0d6c					; dec flash counter 
0d6c 3a 6c fb				ld a, (input_cur_flash) 
0d6f 3d					dec a 
0d70 32 6c fb				ld (input_cur_flash), a 
0d73 fe 00				cp 0 
0d75 20 0d				jr nz, .nochgstate 
0d77			 
0d77			 
0d77					; change state 
0d77 3a 6b fb				ld a,(input_cur_onoff) 
0d7a ed 44				neg 
0d7c 32 6b fb				ld (input_cur_onoff),a 
0d7f			 
0d7f			 
0d7f					; reset on change of state 
0d7f 3e 0f				ld a, CUR_BLINK_RATE 
0d81 32 6c fb				ld (input_cur_flash), a 
0d84			 
0d84			.nochgstate: 
0d84					 
0d84					 
0d84			 
0d84					; display cursor  
0d84			 
0d84			;		ld hl, (input_start) 
0d84			;		ld a, (input_cursor) 
0d84			;		call addatohl 
0d84			 
0d84					; get char under cursor and replace with cursor 
0d84 2a 75 fb		ld hl, (input_ptr) 
0d87			;		ld a, (hl) 
0d87			;		ld (input_under_cursor),a 
0d87			;		ld a, '_' 
0d87			;		ld (hl), a 
0d87			 
0d87					; display string 
0d87			 
0d87 ed 5b 73 fb			ld de, (input_start) 
0d8b 3a 70 fb				ld a, (input_at_pos) 
0d8e cd e8 0a				call str_at_display 
0d91			;	        call update_display 
0d91			 
0d91					; find place to put the cursor 
0d91			;		add h 
0d91			;		ld l, display_row_1 
0d91			;		sub l 
0d91			; (input_at_pos) 
0d91					;ld c, a 
0d91			;		ld a, (input_cursor) 
0d91			;		ld l, (input_at_pos) 
0d91			;		;ld b, h 
0d91			;		add l 
0d91			;		ld (input_at_cursor),a 
0d91					;ld l,h 
0d91			 
0d91			;		ld h, 0 
0d91			;		ld l,(input_at_pos) 
0d91			;		ld a, (input_cursor) 
0d91			;		call addatohl 
0d91			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d91			;		call subafromhl 
0d91			;		ld a,l 
0d91			;		ld (input_at_cursor), a 
0d91			 
0d91				if DEBUG_INPUT 
0d91					ld a, (hardware_diag) 
0d91					cp 0 
0d91					jr z, .skip_input_diag 
0d91			 
0d91					ld a,(input_at_pos) 
0d91					ld hl, LFSRSeed 
0d91					call hexout 
0d91					ld a, (input_cursor) 
0d91					ld hl, LFSRSeed+2 
0d91					call hexout 
0d91					ld a,(input_at_cursor) 
0d91					ld hl, LFSRSeed+4 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_onoff) 
0d91					ld hl, LFSRSeed+6 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_flash) 
0d91					ld hl, LFSRSeed+8 
0d91					call hexout 
0d91			 
0d91					ld a,(input_len) 
0d91					ld hl, LFSRSeed+10 
0d91					call hexout 
0d91					ld hl, LFSRSeed+12 
0d91					ld a, 0 
0d91					ld (hl),a 
0d91					ld a, display_row_4 
0d91					ld de, LFSRSeed 
0d91					call str_at_display 
0d91					.skip_input_diag: 
0d91				endif 
0d91			 
0d91					; decide on if we are showing the cursor this time round 
0d91			 
0d91 3a 6b fb				ld a, (input_cur_onoff) 
0d94 fe ff				cp 255 
0d96 28 13				jr z, .skipcur 
0d98			 
0d98			 
0d98 3a 6e fb				ld a,(input_at_cursor) 
0d9b 11 d0 f8				ld de, cursor_shape 
0d9e cd e8 0a				call str_at_display 
0da1			 
0da1					; save length of current input string 
0da1 2a 73 fb				ld hl, (input_start) 
0da4 cd 67 11				call strlenz 
0da7 7d					ld a,l 
0da8 32 66 fb				ld (input_len),a 
0dab			 
0dab			.skipcur: 
0dab			 
0dab cd f8 0a			        call update_display 
0dae					 
0dae			 
0dae			 
0dae					; wait 
0dae				 
0dae					; TODO loop without wait to flash the cursor and char under cursor	 
0dae cd 00 6a				call cin    ; _wait 
0db1			 
0db1 fe 00				cp 0 
0db3 ca 67 0d				jp z, .is1 
0db6			 
0db6					; get ptr to char to input into 
0db6			 
0db6 4f					ld c,a 
0db7 2a 73 fb				ld hl, (input_start) 
0dba 3a 61 fb				ld a, (input_cursor) 
0dbd cd 09 0d				call addatohl 
0dc0 22 75 fb				ld (input_ptr), hl 
0dc3 79					ld a,c 
0dc4			 
0dc4					; replace char under cursor 
0dc4			 
0dc4			;		ld hl, (input_ptr) 
0dc4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc4			;		ld (hl), a 
0dc4			 
0dc4			;	if DEBUG_INPUT 
0dc4			;		push af 
0dc4			;		ld a, 'i' 
0dc4			;		ld (debug_mark),a 
0dc4			;		pop af 
0dc4			;		CALLMONITOR 
0dc4			;	endif 
0dc4 fe 0e				cp KEY_HOME 
0dc6 20 0e				jr nz, .iske 
0dc8			 
0dc8 3a 70 fb				ld a, (input_at_pos) 
0dcb 32 6e fb				ld (input_at_cursor),a 
0dce 3e 00				ld a, 0 
0dd0 32 61 fb				ld (input_cursor), a 
0dd3 c3 67 0d				jp .is1 
0dd6					 
0dd6 fe 0f		.iske:		cp KEY_END 
0dd8 20 03				jr nz, .isknw 
0dda c3 67 0d				jp .is1 
0ddd			 
0ddd fe 06		.isknw:		cp KEY_NEXTWORD 
0ddf 20 1b				jr nz, .iskpw 
0de1			 
0de1 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0de4 7e					ld a,(hl)	 
0de5 fe 00				cp 0 
0de7 ca 67 0d				jp z, .is1    ; end of string 
0dea fe 20				cp ' ' 
0dec ca 67 0d				jp z, .is1    ; end of word 
0def 23					inc hl 
0df0 22 75 fb				ld (input_ptr), hl 
0df3 3a 6e fb				ld a, (input_at_cursor) 
0df6 3c					inc a 
0df7 32 6e fb				ld (input_at_cursor), a 
0dfa 18 e5				jr .isknwm 
0dfc			 
0dfc fe 07		.iskpw:		cp KEY_PREVWORD 
0dfe 20 1b				jr nz, .iskl 
0e00			.iskpwm:	 
0e00 2a 75 fb				ld hl, (input_ptr) 
0e03 7e					ld a,(hl)	 
0e04 fe 00				cp 0  
0e06 ca 67 0d				jp z, .is1    ; end of string 
0e09 fe 20				cp ' ' 
0e0b ca 67 0d				jp z, .is1    ; end of word 
0e0e 2b					dec hl 
0e0f 22 75 fb				ld (input_ptr), hl 
0e12 3a 6e fb				ld a, (input_at_cursor) 
0e15 3d					dec a 
0e16 32 6e fb				ld (input_at_cursor), a 
0e19 18 e5				jr .iskpwm 
0e1b			 
0e1b			 
0e1b fe 0b		.iskl:		cp KEY_LEFT 
0e1d 20 27				jr nz, .isk1 
0e1f			 
0e1f 3a 61 fb				ld a, (input_cursor) 
0e22			 
0e22 fe 00				cp 0 
0e24 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0e27			 
0e27 3d					dec  a 		; TODO check underflow 
0e28 32 61 fb				ld (input_cursor), a 
0e2b			 
0e2b 2a 75 fb				ld hl, (input_ptr) 
0e2e 2b					dec hl 
0e2f 22 75 fb				ld (input_ptr), hl 
0e32					 
0e32 3a 6e fb				ld a, (input_at_cursor) 
0e35 3d					dec a 
0e36 32 6e fb				ld (input_at_cursor), a 
0e39			 
0e39 3e 01				ld a, 1		; show cursor moving 
0e3b 32 6b fb				ld (input_cur_onoff),a 
0e3e 3e 0f				ld a, CUR_BLINK_RATE 
0e40 32 6c fb				ld (input_cur_flash), a 
0e43			 
0e43 c3 67 0d				jp .is1 
0e46			 
0e46 fe 0c		.isk1:		cp KEY_RIGHT 
0e48 20 2a				jr nz, .isk2 
0e4a			 
0e4a 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4d 5f					ld e,a 
0e4e 3a 61 fb				ld a, (input_cursor) 
0e51 bb					cp e 
0e52 ca 67 0d				jp z, .is1		; at the end of string so dont go right 
0e55			 
0e55 3c					inc  a 		; TODO check overflow 
0e56 32 61 fb				ld (input_cursor), a 
0e59			 
0e59 3a 6e fb				ld a, (input_at_cursor) 
0e5c 3c					inc a 
0e5d 32 6e fb				ld (input_at_cursor), a 
0e60			 
0e60 2a 75 fb				ld hl, (input_ptr) 
0e63 23					inc hl 
0e64 22 75 fb				ld (input_ptr), hl 
0e67			 
0e67 3e 01				ld a, 1		; show cursor moving 
0e69 32 6b fb				ld (input_cur_onoff),a 
0e6c 3e 0f				ld a, CUR_BLINK_RATE 
0e6e 32 6c fb				ld (input_cur_flash), a 
0e71			 
0e71 c3 67 0d				jp .is1 
0e74			 
0e74 fe 05		.isk2:		cp KEY_UP 
0e76			 
0e76 20 26				jr nz, .isk3 
0e78			 
0e78					; swap last command with the current on 
0e78			 
0e78					; move cursor to start of string 
0e78 2a 73 fb				ld hl, (input_start) 
0e7b 22 75 fb				ld (input_ptr), hl 
0e7e			 
0e7e 3a 70 fb				ld a, (input_at_pos) 
0e81 32 6e fb				ld (input_at_cursor), a 
0e84			 
0e84 3e 00				ld a, 0 
0e86 32 61 fb				ld (input_cursor), a 
0e89					 
0e89					; swap input and last command buffers 
0e89			 
0e89 21 44 f1				ld hl, os_cli_cmd 
0e8c 11 43 f2				ld de, os_last_cmd 
0e8f 06 ff				ld b, 255 
0e91 7e			.swap1:		ld a, (hl) 
0e92 4f					ld c,a 
0e93 1a					ld a, (de) 
0e94 77					ld (hl), a 
0e95 79					ld a,c 
0e96 12					ld (de),a 
0e97 23					inc hl 
0e98 13					inc de 
0e99 10 f6				djnz .swap1 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b c3 67 0d				jp .is1 
0e9e			 
0e9e fe 08		.isk3:		cp KEY_BS 
0ea0 20 3c				jr nz, .isk4 
0ea2			 
0ea2 3a 61 fb				ld a, (input_cursor) 
0ea5			 
0ea5 fe 00				cp 0 
0ea7 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0eaa			 
0eaa 3d					dec  a 		; TODO check underflow 
0eab 32 61 fb				ld (input_cursor), a 
0eae			 
0eae					; hl is source 
0eae					; de needs to be source - 1 
0eae			 
0eae			;		ld a, 0 
0eae			;		dec hl 
0eae			;		ld (hl), a 
0eae			 
0eae 2a 75 fb				ld hl, (input_ptr) 
0eb1 2b					dec hl 
0eb2 22 75 fb				ld (input_ptr), hl 
0eb5			 
0eb5					; shift all data 
0eb5			 
0eb5 e5					push hl 
0eb6 23					inc hl 
0eb7 d1					pop de 
0eb8 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ebb 4f					ld c,a 
0ebc 06 00				ld b,0 
0ebe ed b0				ldir  
0ec0			 
0ec0			 
0ec0			 
0ec0			 
0ec0 3a 6e fb				ld a, (input_at_cursor) 
0ec3 3d					dec a 
0ec4 32 6e fb				ld (input_at_cursor), a 
0ec7			 
0ec7			 
0ec7 3e 01				ld a, 1		; show cursor moving 
0ec9 32 6b fb				ld (input_cur_onoff),a 
0ecc 3e 0f				ld a, CUR_BLINK_RATE 
0ece 32 6c fb				ld (input_cur_flash), a 
0ed1			 
0ed1					; remove char 
0ed1 3a 6e fb				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 11 5f 0f				ld de,.iblank 
0ed8 cd e8 0a				call str_at_display 
0edb			 
0edb c3 67 0d				jp .is1 
0ede			 
0ede fe 0d		.isk4:		cp KEY_CR 
0ee0 28 6c				jr z, .endinput 
0ee2			 
0ee2					; else add the key press to the end 
0ee2			 
0ee2 4f					ld c, a			; save key pressed 
0ee3			 
0ee3 7e					ld a,(hl)		; get what is currently under char 
0ee4			 
0ee4 fe 00				cp 0			; we are at the end of the string 
0ee6 20 2f				jr nz, .onchar 
0ee8					 
0ee8					; add a char to the end of the string 
0ee8				 
0ee8 71					ld (hl),c 
0ee9 23					inc hl 
0eea			;		ld a,' ' 
0eea			;		ld (hl),a 
0eea			;		inc hl 
0eea 3e 00				ld a,0 
0eec 77					ld (hl),a 
0eed 2b					dec hl 
0eee			 
0eee 3a 61 fb				ld a, (input_cursor) 
0ef1 3c					inc a				; TODO check max string length and scroll  
0ef2 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0ef5							 
0ef5 3a 6e fb				ld a, (input_at_cursor) 
0ef8 3c					inc a 
0ef9 32 6e fb				ld (input_at_cursor), a 
0efc			 
0efc 2a 75 fb				ld hl, (input_ptr) 
0eff 23					inc hl 
0f00 22 75 fb				ld (input_ptr), hl 
0f03			 
0f03 2a 75 fb				ld hl, (input_ptr) 
0f06 23					inc hl 
0f07 22 75 fb				ld (input_ptr), hl 
0f0a			;	if DEBUG_INPUT 
0f0a			;		push af 
0f0a			;		ld a, '+' 
0f0a			;		ld (debug_mark),a 
0f0a			;		pop af 
0f0a			;		CALLMONITOR 
0f0a			;	endif 
0f0a 3e 01				ld a, 1		; show cursor moving 
0f0c 32 6b fb				ld (input_cur_onoff),a 
0f0f 3e 0f				ld a, CUR_BLINK_RATE 
0f11 32 6c fb				ld (input_cur_flash), a 
0f14 c3 67 0d				jp .is1 
0f17					 
0f17			 
0f17			 
0f17					; if on a char then insert 
0f17			.onchar: 
0f17			 
0f17					; TODO over flow check: make sure insert does not blow out buffer 
0f17			 
0f17					; need to do some maths to use lddr 
0f17			 
0f17 e5					push hl   ; save char pos 
0f18 c5					push bc 
0f19			 
0f19 2a 73 fb				ld hl, (input_start) 
0f1c 3a 66 fb				ld a, (input_len) 
0f1f cd 09 0d				call addatohl  		; end of string 
0f22 23					inc hl 
0f23 23					inc hl		; past zero term 
0f24 e5					push hl 
0f25 23					inc hl 
0f26 e5					push hl  
0f27			 
0f27								; start and end of lddr set, now how much to move? 
0f27			 
0f27							 
0f27 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f2a 47					ld b,a 
0f2b 3a 66 fb				ld a,(input_len) 
0f2e 5f					ld e,a 
0f2f 90					sub b 
0f30 3c					inc a		;?? 
0f31 3c					inc a		;?? 
0f32 3c					inc a		;?? 
0f33			 
0f33 06 00				ld b,0 
0f35 4f					ld c,a 
0f36			 
0f36				if DEBUG_INPUT 
0f36					push af 
0f36					ld a, 'i' 
0f36					ld (debug_mark),a 
0f36					pop af 
0f36			;		CALLMONITOR 
0f36				endif 
0f36 d1					pop de 
0f37 e1					pop hl 
0f38				if DEBUG_INPUT 
0f38					push af 
0f38					ld a, 'I' 
0f38					ld (debug_mark),a 
0f38					pop af 
0f38			;		CALLMONITOR 
0f38				endif 
0f38 ed b8				lddr 
0f3a				 
0f3a			 
0f3a			 
0f3a					; TODO have a key for insert/overwrite mode???? 
0f3a c1					pop bc 
0f3b e1					pop hl 
0f3c 71					ld (hl), c		; otherwise overwrite current char 
0f3d					 
0f3d			 
0f3d			 
0f3d			 
0f3d 3a 61 fb				ld a, (input_cursor) 
0f40 3c					inc  a 		; TODO check overflow 
0f41 32 61 fb				ld (input_cursor), a 
0f44			 
0f44 3a 6e fb				ld a, (input_at_cursor) 
0f47 3c					inc a 
0f48 32 6e fb				ld (input_at_cursor), a 
0f4b			 
0f4b c3 67 0d				jp .is1 
0f4e			 
0f4e			.endinput:	; TODO look for end of string 
0f4e			 
0f4e					; add trailing space for end of token 
0f4e			 
0f4e 2a 73 fb				ld hl, (input_start) 
0f51 3a 66 fb				ld a,(input_len) 
0f54 cd 09 0d				call addatohl 
0f57 3e 20				ld a, ' ' 
0f59 77					ld (hl),a 
0f5a					; TODO eof of parse marker 
0f5a			 
0f5a 23					inc hl 
0f5b 3e 00				ld a, 0 
0f5d 77					ld (hl),a 
0f5e			 
0f5e			 
0f5e c9					ret 
0f5f			 
0f5f .. 00		.iblank: db " ",0 
0f61			 
0f61			 
0f61 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f64 22 73 fb				ld (input_start), hl 
0f67 3e 01				ld a,1			; add cursor 
0f69 77					ld (hl),a 
0f6a 23					inc hl 
0f6b 3e 00				ld a,0 
0f6d 77					ld (hl),a 
0f6e 22 75 fb				ld (input_ptr), hl 
0f71 7a					ld a,d 
0f72 32 72 fb				ld (input_size), a 
0f75 3e 00				ld a,0 
0f77 32 61 fb				ld (input_cursor),a 
0f7a			.instr1:	 
0f7a			 
0f7a					; TODO do block cursor 
0f7a					; TODO switch cursor depending on the modifer key 
0f7a			 
0f7a					; update cursor shape change on key hold 
0f7a			 
0f7a 2a 75 fb				ld hl, (input_ptr) 
0f7d 2b					dec hl 
0f7e 3a d0 f8				ld a,(cursor_shape) 
0f81 77					ld (hl), a 
0f82			 
0f82					; display entered text 
0f82 3a 70 fb				ld a,(input_at_pos) 
0f85 cd c4 67		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f88 ed 5b 73 fb	            	LD   de, (input_start) 
0f8c cd e6 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8f			 
0f8f cd 00 6a				call cin 
0f92 fe 00				cp 0 
0f94 28 e4				jr z, .instr1 
0f96			 
0f96					; proecess keyboard controls first 
0f96			 
0f96 2a 75 fb				ld hl,(input_ptr) 
0f99			 
0f99 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f9b 28 5a				jr z, .instrcr 
0f9d			 
0f9d fe 08				cp KEY_BS 	; back space 
0f9f 20 0f				jr nz, .instr2 
0fa1					; process back space 
0fa1			 
0fa1					; TODO stop back space if at start of string 
0fa1 2b					dec hl 
0fa2 2b					dec hl ; to over write cursor 
0fa3 3a d0 f8				ld a,(cursor_shape) 
0fa6					;ld a,0 
0fa6 77					ld (hl),a 
0fa7 23					inc hl 
0fa8 3e 20				ld a," " 
0faa 77					ld (hl),a 
0fab 22 75 fb				ld (input_ptr),hl 
0fae					 
0fae			 
0fae 18 ca				jr .instr1 
0fb0			 
0fb0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fb2 20 06				jr nz, .instr3 
0fb4 2b					dec hl 
0fb5 22 75 fb				ld (input_ptr),hl 
0fb8 18 c0				jr .instr1 
0fba				 
0fba fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fbc 20 06				jr nz, .instr4 
0fbe 23					inc hl 
0fbf 22 75 fb				ld (input_ptr),hl 
0fc2 18 b6				jr .instr1 
0fc4			 
0fc4 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc6 20 06				jr nz, .instr5 
0fc8 2b					dec hl 
0fc9 22 75 fb				ld (input_ptr),hl 
0fcc 18 ac				jr .instr1 
0fce			 
0fce fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fd0 20 06				jr nz, .instr6 
0fd2 2b					dec hl 
0fd3 22 75 fb				ld (input_ptr),hl 
0fd6 18 a2				jr .instr1 
0fd8 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fda 20 0b				jr nz, .instrnew 
0fdc			 
0fdc 21 1d ee			ld hl, scratch 
0fdf 11 43 f2			ld de, os_last_cmd 
0fe2 cd 00 10			call strcpy 
0fe5 18 93				jr .instr1 
0fe7			 
0fe7			 
0fe7			.instrnew:	; no special key pressed to see if we have room to store it 
0fe7			 
0fe7					; TODO do string size test 
0fe7			 
0fe7 2b					dec hl ; to over write cursor 
0fe8 77					ld (hl),a 
0fe9 23					inc hl 
0fea 3a d0 f8				ld a,(cursor_shape) 
0fed 77					ld (hl),a 
0fee 23					inc hl 
0fef 3e 00				ld a,0 
0ff1 77					ld (hl),a 
0ff2			 
0ff2 22 75 fb				ld (input_ptr),hl 
0ff5					 
0ff5 18 83				jr .instr1 
0ff7 2b			.instrcr:	dec hl		; remove cursor 
0ff8 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ffa 77					ld (hl),a 
0ffb 23					inc hl 
0ffc 3e 00				ld a,0 
0ffe 77					ld (hl),a 
0fff			 
0fff			 
0fff					; if at end of line scroll up    
0fff					; TODO detecting only end of line 4 for scroll up  
0fff			 
0fff					;ld   
0fff			 
0fff c9					ret 
1000			 
1000			 
1000			; strcpy hl = dest, de source 
1000			 
1000 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1001 b7			            OR   A              ;Null terminator? 
1002 c8			            RET  Z              ;Yes, so finished 
1003 1a					ld a,(de) 
1004 77					ld (hl),a 
1005 13			            INC  DE             ;Point to next character 
1006 23					inc hl 
1007 18 f7		            JR   strcpy       ;Repeat 
1009 c9					ret 
100a			 
100a			 
100a			; TODO string_at  
100a			; pass string which starts with lcd offset address and then null term string 
100a			 
100a			; TODO string to dec 
100a			; TODO string to hex 
100a			; TODO byte to string hex 
100a			; TODO byte to string dec 
100a			 
100a			 
100a			 
100a			; from z80uartmonitor 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
100a			; pass hl for where to put the text 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a c5			hexout:	PUSH BC 
100b f5					PUSH AF 
100c 47					LD B, A 
100d					; Upper nybble 
100d cb 3f				SRL A 
100f cb 3f				SRL A 
1011 cb 3f				SRL A 
1013 cb 3f				SRL A 
1015 cd 25 10				CALL tohex 
1018 77					ld (hl),a 
1019 23					inc hl	 
101a					 
101a					; Lower nybble 
101a 78					LD A, B 
101b e6 0f				AND 0FH 
101d cd 25 10				CALL tohex 
1020 77					ld (hl),a 
1021 23					inc hl	 
1022					 
1022 f1					POP AF 
1023 c1					POP BC 
1024 c9					RET 
1025					 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			tohex: 
1025 e5					PUSH HL 
1026 d5					PUSH DE 
1027 16 00				LD D, 0 
1029 5f					LD E, A 
102a 21 32 10				LD HL, .DATA 
102d 19					ADD HL, DE 
102e 7e					LD A, (HL) 
102f d1					POP DE 
1030 e1					POP HL 
1031 c9					RET 
1032			 
1032			.DATA: 
1032 30					DEFB	30h	; 0 
1033 31					DEFB	31h	; 1 
1034 32					DEFB	32h	; 2 
1035 33					DEFB	33h	; 3 
1036 34					DEFB	34h	; 4 
1037 35					DEFB	35h	; 5 
1038 36					DEFB	36h	; 6 
1039 37					DEFB	37h	; 7 
103a 38					DEFB	38h	; 8 
103b 39					DEFB	39h	; 9 
103c 41					DEFB	41h	; A 
103d 42					DEFB	42h	; B 
103e 43					DEFB	43h	; C 
103f 44					DEFB	44h	; D 
1040 45					DEFB	45h	; E 
1041 46					DEFB	46h	; F 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1042			;;    subtract $30, if result > 9 then subtract $7 more 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			atohex: 
1042 d6 30				SUB $30 
1044 fe 0a				CP 10 
1046 f8					RET M		; If result negative it was 0-9 so we're done 
1047 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1049 c9					RET		 
104a			 
104a			 
104a			 
104a			 
104a			; Get 2 ASCII characters as hex byte from pointer in hl 
104a			 
104a			BYTERD: 
104a 16 00			LD	D,00h		;Set up 
104c cd 54 10			CALL	HEXCON		;Get byte and convert to hex 
104f 87				ADD	A,A		;First nibble so 
1050 87				ADD	A,A		;multiply by 16 
1051 87				ADD	A,A		; 
1052 87				ADD	A,A		; 
1053 57				LD	D,A		;Save hi nibble in D 
1054			HEXCON: 
1054 7e				ld a, (hl)		;Get next chr 
1055 23				inc hl 
1056 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1058 fe 0a			CP	00Ah		;Is it 0-9 ? 
105a 38 02			JR	C,NALPHA	;If so miss next bit 
105c d6 07			SUB	007h		;Else convert alpha 
105e			NALPHA: 
105e b2				OR	D		;Add hi nibble back 
105f c9				RET			; 
1060			 
1060			 
1060			; 
1060			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1060			; Since the routines get_byte and therefore get_nibble are called, only valid 
1060			; characters (0-9a-f) are accepted. 
1060			; 
1060			;get_word        push    af 
1060			;                call    get_byte        ; Get the upper byte 
1060			;                ld      h, a 
1060			;                call    get_byte        ; Get the lower byte 
1060			;                ld      l, a 
1060			;                pop     af 
1060			;                ret 
1060			; 
1060			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1060			; the routine get_nibble is used only valid characters are accepted - the  
1060			; input routine only accepts characters 0-9a-f. 
1060			; 
1060 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1061 7e					ld a,(hl) 
1062 23					inc hl 
1063 cd 88 10		                call    nibble2val      ; Get upper nibble 
1066 cb 07		                rlc     a 
1068 cb 07		                rlc     a 
106a cb 07		                rlc     a 
106c cb 07		                rlc     a 
106e 47			                ld      b, a            ; Save upper four bits 
106f 7e					ld a,(hl) 
1070 cd 88 10		                call    nibble2val      ; Get lower nibble 
1073 b0			                or      b               ; Combine both nibbles 
1074 c1			                pop     bc              ; Restore B (and C) 
1075 c9			                ret 
1076			; 
1076			; Get a hexadecimal digit from the serial line. This routine blocks until 
1076			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1076			; to the serial line interface. The lower 4 bits of A contain the value of  
1076			; that particular digit. 
1076			; 
1076			;get_nibble      ld a,(hl)           ; Read a character 
1076			;                call    to_upper        ; Convert to upper case 
1076			;                call    is_hex          ; Was it a hex digit? 
1076			;                jr      nc, get_nibble  ; No, get another character 
1076			 ;               call    nibble2val      ; Convert nibble to value 
1076			 ;               call    print_nibble 
1076			 ;               ret 
1076			; 
1076			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1076			; A valid hexadecimal digit is denoted by a set C flag. 
1076			; 
1076			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1076			;                ret     nc              ; Yes 
1076			;                cp      '0'             ; Less than '0'? 
1076			;                jr      nc, is_hex_1    ; No, continue 
1076			;                ccf                     ; Complement carry (i.e. clear it) 
1076			;                ret 
1076			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1076			;                ret     c               ; Yes 
1076			;                cp      'A'             ; Less than 'A'? 
1076			;                jr      nc, is_hex_2    ; No, continue 
1076			;                ccf                     ; Yes - clear carry and return 
1076			;                ret 
1076			;is_hex_2        scf                     ; Set carry 
1076			;                ret 
1076			; 
1076			; Convert a single character contained in A to upper case: 
1076			; 
1076 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1078 d8			                ret     c 
1079 fe 7b		                cp      'z' + 1         ; > 'z'? 
107b d0			                ret     nc              ; Nothing to do, either 
107c e6 5f		                and     $5f             ; Convert to upper case 
107e c9			                ret 
107f			 
107f			 
107f			to_lower: 
107f			 
107f			   ; if char is in [A-Z] make it lower case 
107f			 
107f			   ; enter : a = char 
107f			   ; exit  : a = lower case char 
107f			   ; uses  : af 
107f			 
107f fe 41		   cp 'A' 
1081 d8			   ret c 
1082			    
1082 fe 5b		   cp 'Z'+1 
1084 d0			   ret nc 
1085			    
1085 f6 20		   or $20 
1087 c9			   ret 
1088			 
1088			; 
1088			; Expects a hexadecimal digit (upper case!) in A and returns the 
1088			; corresponding value in A. 
1088			; 
1088 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
108a 38 02		                jr      c, nibble2val_1 ; Yes 
108c d6 07		                sub     7               ; Adjust for A-F 
108e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1090 e6 0f		                and     $f              ; Only return lower 4 bits 
1092 c9			                ret 
1093			; 
1093			; Print_nibble prints a single hex nibble which is contained in the lower  
1093			; four bits of A: 
1093			; 
1093			;print_nibble    push    af              ; We won't destroy the contents of A 
1093			;                and     $f              ; Just in case... 
1093			;                add     a, '0'             ; If we have a digit we are done here. 
1093			;                cp      '9' + 1         ; Is the result > 9? 
1093			;                jr      c, print_nibble_1 
1093			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1093			;print_nibble_1  call    putc            ; Print the nibble and 
1093			;                pop     af              ; restore the original value of A 
1093			;                ret 
1093			;; 
1093			;; Send a CR/LF pair: 
1093			; 
1093			;crlf            push    af 
1093			;                ld      a, cr 
1093			;                call    putc 
1093			;                ld      a, lf 
1093			;                call    putc 
1093			;                pop     af 
1093			;                ret 
1093			; 
1093			; Print_word prints the four hex digits of a word to the serial line. The  
1093			; word is expected to be in HL. 
1093			; 
1093			;print_word      push    hl 
1093			;                push    af 
1093			;                ld      a, h 
1093			;                call    print_byte 
1093			;                ld      a, l 
1093			;                call    print_byte 
1093			;                pop     af 
1093			;                pop     hl 
1093			;                ret 
1093			; 
1093			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1093			; The byte to be printed is expected to be in A. 
1093			; 
1093			;print_byte      push    af              ; Save the contents of the registers 
1093			;                push    bc 
1093			;                ld      b, a 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                call    print_nibble    ; Print high nibble 
1093			;                ld      a, b 
1093			;                call    print_nibble    ; Print low nibble 
1093			;                pop     bc              ; Restore original register contents 
1093			;                pop     af 
1093			;                ret 
1093			 
1093			 
1093			 
1093			 
1093			 
1093			fourehexhl:  
1093 7e				ld a,(hl) 
1094 cd 42 10			call atohex 
1097 cb 3f				SRL A 
1099 cb 3f				SRL A 
109b cb 3f				SRL A 
109d cb 3f				SRL A 
109f 47				ld b, a 
10a0 23				inc hl 
10a1 7e				ld a,(hl) 
10a2 23				inc hl 
10a3 cd 42 10			call atohex 
10a6 80				add b 
10a7 57				ld d,a 
10a8 7e				ld a,(hl) 
10a9 cd 42 10			call atohex 
10ac cb 3f				SRL A 
10ae cb 3f				SRL A 
10b0 cb 3f				SRL A 
10b2 cb 3f				SRL A 
10b4 47				ld b, a 
10b5 23				inc hl 
10b6 7e				ld a,(hl) 
10b7 23				inc hl 
10b8 cd 42 10			call atohex 
10bb 80				add b 
10bc 5f				ld e, a 
10bd d5				push de 
10be e1				pop hl 
10bf c9				ret 
10c0			 
10c0			; pass hl. returns z set if the byte at hl is a digit 
10c0			;isdigithl:  
10c0			;	push bc 
10c0			;	ld a,(hl) 
10c0			;	cp ':' 
10c0			;	jr nc, .isdf 		; > 
10c0			;	cp '0' 
10c0			;	jr c, .isdf		; < 
10c0			; 
10c0			;	; TODO find a better way to set z 
10c0			; 
10c0			;	ld b,a 
10c0			;	cp b 
10c0			;	pop bc 
10c0			;	ret 
10c0			; 
10c0			;.isdf:	; not digit so clear z 
10c0			; 
10c0			;	; TODO find a better way to unset z 
10c0			; 
10c0			;	ld b,a 
10c0			;	inc b 
10c0			;	cp b 
10c0			; 
10c0			;	pop bc 
10c0			;	ret 
10c0				 
10c0				 
10c0			 
10c0			 
10c0			; pass hl as the four byte address to load 
10c0			 
10c0			get_word_hl:  
10c0 e5				push hl 
10c1 cd 60 10			call get_byte 
10c4				 
10c4 47				ld b, a 
10c5			 
10c5 e1				pop hl 
10c6 23				inc hl 
10c7 23				inc hl 
10c8			 
10c8			; TODO not able to handle a-f  
10c8 7e				ld a,(hl) 
10c9			;	;cp ':' 
10c9			;	cp 'g' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp 'G' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp '0' 
10c9			;	jr c, .single_byte_hl		; < 
10c9			 
10c9				;call isdigithl 
10c9 fe 00			cp 0 
10cb 28 06			jr z, .single_byte_hl 
10cd			 
10cd			.getwhln:   ; hex word so get next byte 
10cd			 
10cd cd 60 10			call get_byte 
10d0 6f				ld l, a 
10d1 60				ld h,b 
10d2 c9				ret 
10d3 68			.single_byte_hl:   ld l,b 
10d4 26 00				ld h,0 
10d6 c9					ret 
10d7			 
10d7			 
10d7			 
10d7			 
10d7 21 c0 19			ld hl,asc+1 
10da			;	ld a, (hl) 
10da			;	call nibble2val 
10da cd 60 10			call get_byte 
10dd			 
10dd			;	call fourehexhl 
10dd 32 51 ee			ld (scratch+52),a 
10e0				 
10e0 21 4f ee			ld hl,scratch+50 
10e3 22 40 f1			ld (os_cur_ptr),hl 
10e6			 
10e6 c9				ret 
10e7			 
10e7			 
10e7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e7			 
10e7			; Decimal Unsigned Version 
10e7			 
10e7			;Number in a to decimal ASCII 
10e7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e7			;Example: display a=56 as "056" 
10e7			;input: a = number 
10e7			;Output: a=0,value of a in the screen 
10e7			;destroys af,bc (don't know about hl and de) 
10e7			DispAToASCII: 
10e7 0e 9c			ld	c,-100 
10e9 cd f3 10			call	.Na1 
10ec 0e f6			ld	c,-10 
10ee cd f3 10			call	.Na1 
10f1 0e ff			ld	c,-1 
10f3 06 2f		.Na1:	ld	b,'0'-1 
10f5 04			.Na2:	inc	b 
10f6 81				add	a,c 
10f7 38 fc			jr	c,.Na2 
10f9 91				sub	c		;works as add 100/10/1 
10fa f5				push af		;safer than ld c,a 
10fb 78				ld	a,b		;char is in b 
10fc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10fc f1				pop af		;safer than ld a,c 
10fd c9				ret 
10fe			 
10fe			; Decimal Signed Version 
10fe			 
10fe			; DispA 
10fe			; -------------------------------------------------------------- 
10fe			; Converts a signed integer value to a zero-terminated ASCII 
10fe			; string representative of that value (using radix 10). 
10fe			; -------------------------------------------------------------- 
10fe			; INPUTS: 
10fe			;     HL     Value to convert (two's complement integer). 
10fe			;     DE     Base address of string destination. (pointer). 
10fe			; -------------------------------------------------------------- 
10fe			; OUTPUTS: 
10fe			;     None 
10fe			; -------------------------------------------------------------- 
10fe			; REGISTERS/MEMORY DESTROYED 
10fe			; AF HL 
10fe			; -------------------------------------------------------------- 
10fe			 
10fe			;DispHLToASCII: 
10fe			;   push    de 
10fe			;   push    bc 
10fe			; 
10fe			;; Detect sign of HL. 
10fe			;    bit    7, h 
10fe			;    jr     z, ._DoConvert 
10fe			; 
10fe			;; HL is negative. Output '-' to string and negate HL. 
10fe			;    ld     a, '-' 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			; 
10fe			;; Negate HL (using two's complement) 
10fe			;    xor    a 
10fe			;    sub    l 
10fe			;    ld     l, a 
10fe			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fe			;    sbc    a, h 
10fe			;    ld     h, a 
10fe			; 
10fe			;; Convert HL to digit characters 
10fe			;._DoConvert: 
10fe			;    ld     b, 0     ; B will count character length of number 
10fe			;-   ld     a, 10 
10fe			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fe			;    push   af 
10fe			;    inc    b 
10fe			;    ld     a, h 
10fe			;    or     l 
10fe			;    jr     nz, - 
10fe			; 
10fe			;; Retrieve digits from stack 
10fe			;-   pop    af 
10fe			;    or     $30 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			;    djnz   - 
10fe			; 
10fe			;; Terminate string with NULL 
10fe			;    xor    a 
10fe			;    ld     (de), a 
10fe			; 
10fe			;    pop    bc 
10fe			;    pop    de 
10fe			;    ret 
10fe			 
10fe			;Comments 
10fe			; 
10fe			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fe			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fe			;    Note that the output string will not be fixed-width. 
10fe			; 
10fe			;Example Usage 
10fe			; 
10fe			;    ld    hl, -1004 
10fe			;    ld    de, OP1 
10fe			;    call  DispA 
10fe			;    ld    hl, OP1 
10fe			;    syscall  PutS 
10fe			 
10fe			 
10fe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fe			 
10fe			 
10fe			;Converts an ASCII string to an unsigned 16-bit integer 
10fe			;Quits when it reaches a non-decimal digit 
10fe			 
10fe			string_to_uint16: 
10fe			atoui_16: 
10fe			;Input: 
10fe			;     DE points to the string 
10fe			;Outputs: 
10fe			;     HL is the result 
10fe			;     A is the 8-bit value of the number 
10fe			;     DE points to the byte after the number 
10fe			;Destroys: 
10fe			;     BC 
10fe			;       if the string is non-empty, BC is HL/10 
10fe			;Size:  24 bytes 
10fe			;Speed: 42+d(104+{0,9}) 
10fe			;       d is the number of digits in the number 
10fe			;       max is 640 cycles for a 5 digit number 
10fe			;Assuming no leading zeros: 
10fe			;1 digit:  146cc 
10fe			;2 digit:  250cc 
10fe			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fe			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fe			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fe			;avg: 544.81158447265625cc (544+13297/16384) 
10fe			;=============================================================== 
10fe 21 00 00		  ld hl,0 
1101			.u16a: 
1101 1a			  ld a,(de) 
1102 d6 30		  sub 30h 
1104 fe 0a		  cp 10 
1106 d0			  ret nc 
1107 13			  inc de 
1108 44			  ld b,h 
1109 4d			  ld c,l 
110a 29			  add hl,hl 
110b 29			  add hl,hl 
110c 09			  add hl,bc 
110d 29			  add hl,hl 
110e 85			  add a,l 
110f 6f			  ld l,a 
1110 30 ef		  jr nc,.u16a 
1112 24			  inc h 
1113 c3 01 11		  jp .u16a 
1116			 
1116			 
1116			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1116			 
1116			;written by Zeda 
1116			;Converts a 16-bit unsigned integer to an ASCII string. 
1116			 
1116			uitoa_16: 
1116			;Input: 
1116			;   DE is the number to convert 
1116			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1116			;Output: 
1116			;   HL points to the null-terminated ASCII string 
1116			;      NOTE: This isn't necessarily the same as the input HL. 
1116 d5			  push de 
1117 c5			  push bc 
1118 f5			  push af 
1119 eb			  ex de,hl 
111a			 
111a 01 f0 d8		  ld bc,-10000 
111d 3e 2f		  ld a,'0'-1 
111f 3c			  inc a 
1120 09			  add hl,bc  
1121 38 fc		   jr c,$-2 
1123 12			  ld (de),a 
1124 13			  inc de 
1125			 
1125 01 e8 03		  ld bc,1000 
1128 3e 3a		  ld a,'9'+1 
112a 3d			  dec a  
112b 09			  add hl,bc  
112c 30 fc		   jr nc,$-2 
112e 12			  ld (de),a 
112f 13			  inc de 
1130			 
1130 01 9c ff		  ld bc,-100 
1133 3e 2f		  ld a,'0'-1 
1135 3c			  inc a  
1136 09			  add hl,bc  
1137 38 fc		   jr c,$-2 
1139 12			  ld (de),a 
113a 13			  inc de 
113b			 
113b 7d			  ld a,l 
113c 26 3a		  ld h,'9'+1 
113e 25			  dec h  
113f c6 0a		  add a,10  
1141 30 fb		   jr nc,$-3 
1143 c6 30		  add a,'0' 
1145 eb			  ex de,hl 
1146 72			  ld (hl),d 
1147 23			  inc hl 
1148 77			  ld (hl),a 
1149 23			  inc hl 
114a 36 00		  ld (hl),0 
114c			 
114c			;Now strip the leading zeros 
114c 0e fa		  ld c,-6 
114e 09			  add hl,bc 
114f 3e 30		  ld a,'0' 
1151 23			  inc hl  
1152 be			  cp (hl)  
1153 28 fc		  jr z,$-2 
1155			 
1155			;Make sure that the string is non-empty! 
1155 7e			  ld a,(hl) 
1156 b7			  or a 
1157 20 01		  jr nz,.atoub 
1159 2b			  dec hl 
115a			.atoub: 
115a			 
115a f1			  pop af 
115b c1			  pop bc 
115c d1			  pop de 
115d c9			  ret 
115e			 
115e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115e			 
115e			toUpper: 
115e			;A is the char. 
115e			;If A is a lowercase letter, this sets it to the matching uppercase 
115e			;18cc or 30cc or 41cc 
115e			;avg: 26.75cc 
115e fe 61		  cp 'a' 
1160 d8			  ret c 
1161 fe 7b		  cp 'z'+1 
1163 d0			  ret nc 
1164 d6 20		  sub 'a'-'A' 
1166 c9			  ret 
1167			 
1167			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1167			 
1167			; String Length 
1167			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1167			 
1167			; Get the length of the null-terminated string starting at $8000 hl 
1167			;    LD     HL, $8000 
1167			 
1167			strlenz: 
1167			 
1167 af			    XOR    A               ; Zero is the value we are looking for. 
1168 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1169 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116d 6f			    LD     L, A             ; number of bytes 
116e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1170 2b			    DEC    HL              ; Compensate for null. 
1171 c9				ret 
1172			 
1172			; Get the length of the A terminated string starting at $8000 hl 
1172			;    LD     HL, $8000 
1172			 
1172			strlent: 
1172			 
1172			                  ; A is the value we are looking for. 
1172 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1174 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1176			                           ; 65, 536 bytes (the entire addressable memory space). 
1176 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1178			 
1178			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1178 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
117a 2e 00		    LD     L, 0             ; number of bytes 
117c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117e 2b			    DEC    HL              ; Compensate for null. 
117f c9				ret 
1180			 
1180			 
1180			;Comparing Strings 
1180			 
1180			;IN    HL     Address of string1. 
1180			;      DE     Address of string2. 
1180			 
1180			; doc given but wrong??? 
1180			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1180			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1180			; tested 
1180			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1180			 
1180			strcmp_old: 
1180 e5			    PUSH   HL 
1181 d5			    PUSH   DE 
1182			 
1182 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1183 be			    CP     (HL)            ; (want to minimize work). 
1184 38 01		    JR     C, Str1IsBigger 
1186 7e			    LD     A, (HL) 
1187			 
1187			Str1IsBigger: 
1187 4f			    LD     C, A             ; Put length in BC 
1188 06 00		    LD     B, 0 
118a 13			    INC    DE              ; Increment pointers to meat of string. 
118b 23			    INC    HL 
118c			 
118c			CmpLoop: 
118c 1a			    LD     A, (DE)          ; Compare bytes. 
118d ed a1		    CPI 
118f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1191 13			    INC    DE              ; Update pointer. 
1192 ea 8c 11		    JP     PE, CmpLoop 
1195			 
1195 d1			    POP    DE 
1196 e1			    POP    HL 
1197 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1198 be			    CP     (HL) 
1199 c9			    RET 
119a			 
119a			NoMatch: 
119a 2b			    DEC    HL 
119b be			    CP     (HL)            ; Compare again to affect carry. 
119c d1			    POP    DE 
119d e1			    POP    HL 
119e c9			    RET 
119f			 
119f			;; test strmp 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr z, .z1 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z1: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr z, .z2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr c, .c1 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c1: 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr c, .c2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;	NEXTW 
119f			;.str1:   db "string1",0 
119f			;.str2:   db "string2",0 
119f			 
119f			; only care about direct match or not 
119f			; hl and de strings 
119f			; zero set if the same 
119f			 
119f			strcmp: 
119f 1a				ld a, (de) 
11a0 be				cp (hl) 
11a1 28 02			jr z, .ssame 
11a3 b7				or a 
11a4 c9				ret 
11a5			 
11a5			.ssame:  
11a5 fe 00			cp 0 
11a7 c8				ret z 
11a8			 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f3			jr strcmp 
11ac				 
11ac				 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 0e 80		      ld    HL, heap_start 
11b0 22 0a 80		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 0c 80		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 ff ed		      ld    HL, heap_start+heap_size-4 
11bc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 f1 6d		      ld    HL, heap_size-4 
11c2 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11cb 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 0a 80		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			if SOUND_ENABLE  
1369				include "firmware_sound.asm"  
1369			; Sound abstraction layer 
1369			 
1369			; support different sound chips through common interface 
1369			 
1369			SOUND_DEVICE_AY: equ 0 
1369			 
1369			SOUND_DEVICE: equ Device_A 
1369			 
1369			 
1369			 
1369			if SOUND_DEVICE_AY 
1369				include "firmware_sound_ay38910.asm" 
1369			else 
1369				include "firmware_sound_sn76489an.asm" 
1369			 
1369			; Device support for SN76489AN sound chip 
1369			 
1369			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1369			; http://danceswithferrets.org/geekblog/?p=93 
1369			; https://www.smspower.org/Development/SN76489 
1369			 
1369			; D0 [ 3] 
1369			; D1 [ 2] 
1369			; D2 [ 1] 
1369			; D3 [15] 
1369			; D4 [13] 
1369			; D5 [12] 
1369			; D6 [11] 
1369			; D7 [10] 
1369			; /WE [ 5] 
1369			; CLK [14] 
1369			; /OE [ 6] 
1369			; AUDIO [ 7] 
1369			; GND 8 
1369			; +5 16 
1369			; 
1369			 
1369			; Write sequence: 
1369			; CE low 
1369			; Data bus 
1369			; WE low then high 
1369			; 32 clock cycles / 8ns write time at 4mhz 
1369			; 
1369			; https://github.com/jblang/SN76489 
1369			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1369			; Tried: 
1369			; 
1369			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1369			; 
1369			; Connected WE to OR too 
1369			;  
1369			; That enabled the clock when required 
1369			; However still random bus corruption. Need further investigation 
1369			 
1369			 
1369			SOUND_LATCH: equ 10000000B 
1369			SOUND_DATA: equ 0B 
1369			SOUND_CH0:  equ 0B    ; Tone 
1369			SOUND_CH1: equ 0100000B        ; Tone 
1369			SOUND_CH2: equ 1000000B   ; Tone 
1369			SOUND_CH3: equ 1100000B    ; Noise 
1369			SOUND_VOL: equ 10000B 
1369			SOUND_TONE: equ 0B 
1369			 
1369			 
1369			sound_init: 
1369 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
136b cd 80 13			call note_send_byte 
136e 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1370 cd 80 13			call note_send_byte 
1373 cd 49 0a			call delay250ms 
1376 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1378 cd 80 13			call note_send_byte 
137b cd 49 0a			call delay250ms 
137e c9				ret 
137f			 
137f			; Play a note 
137f			; h = note 
137f			; l = duration 
137f			; a = channel 
137f			 
137f			 
137f			;  frequ = clock / ( 2 x reg valu x 32 )  
137f			 
137f			note:  
137f				 
137f			 
137f c9				ret 
1380			 
1380			note_send_byte: 
1380				; byte in a 
1380			 
1380				; we high 
1380 d3 40			out (Device_B), a 
1382			;	ld a, 1 
1382			;	call aDelayInMS 
1382 00				nop  
1383 00				nop  
1384 00				nop  
1385 00				nop  
1386				; we low 
1386 d3 40			out (Device_B), a 
1388			;	ld a, 1 
1388			;	call aDelayInMS 
1388 00				nop  
1389 00				nop  
138a 00				nop  
138b 00				nop  
138c				; we high 
138c d3 40			out (Device_B), a 
138e			;	ld a, 1 
138e			;	call aDelayInMS 
138e 00				nop  
138f 00				nop  
1390 00				nop  
1391 00				nop  
1392			 
1392			 
1392 c9				ret 
1393			 
1393			;void SilenceAllChannels() 
1393			;{ 
1393			;  SendByte(0x9f); 
1393			;  SendByte(0xbf); 
1393			;  SendByte(0xdf); 
1393			;  SendByte(0xff); 
1393			;} 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound_sn76489an.asm
1393			endif 
1393			 
1393			 
1393			; Abstraction entry points 
1393			 
1393			; init  
1393			 
1393			; sound_init in specific hardware files 
1393			 
1393			; Play a note 
1393			; h = note 
1393			; l = duration 
1393			; a = channel 
1393			 
1393			;note:     
1393			;	ret 
1393			 
1393			 
1393			 
1393			 
1393			; eof 
1393			 
# End of file firmware_sound.asm
1393			endif  
1393			  
1393			include "firmware_diags.asm"  
1393			; Hardware diags menu 
1393			 
1393			 
1393			config: 
1393			 
1393 3e 00			ld a, 0 
1395 21 be 13			ld hl, .configmn 
1398 cd 06 0b			call menu 
139b			 
139b fe 00			cp 0 
139d c8				ret z 
139e			 
139e fe 01			cp 1 
13a0 cc 00 15			call z, .savetostore 
13a3			 
13a3 fe 02			cp 2 
13a5 cc 4e 14			call z, .selautoload 
13a8 fe 03			cp 3 
13aa cc fe 14			call z, .selbank 
13ad fe 05			cp 5 
13af cc db 15			call z, .debug_tog 
13b2 fe 06			cp 6 
13b4 cc 23 17			call z, .bpsgo 
13b7 fe 07			cp 7 
13b9 cc 01 16			call z, hardware_diags 
13bc			 
13bc 18 d5			jr config 
13be			 
13be			.configmn: 
13be ce 13			dw .c3 
13c0 ea 13			dw .c2 
13c2 ff 13			dw .c2b 
13c4 13 14			dw .c4 
13c6 1c 14			dw .m4 
13c8 37 14			dw .m4b 
13ca 3f 14			dw .c1 
13cc 00 00			dw 0 
13ce				 
13ce			 
13ce .. 00		.c3: db "Add User Dictionary To File",0 
13ea .. 00		.c2: db "Select Autoload File",0 
13ff .. 00		.c2b: db "Select Storage Bank",0 
1413 .. 00		.c4: db "Settings",0 
141c .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1437 .. 00		.m4b:   db "Monitor",0 
143f .. 00		.c1: db "Hardware Diags",0 
144e			 
144e			 
144e			 
144e			; Select auto start 
144e			 
144e			.selautoload: 
144e			 
144e				 
144e				if STORAGE_SE 
144e			 
144e cd 25 15				call config_dir 
1451 21 1d ee			        ld hl, scratch 
1454 3e 00				ld a, 0 
1456 cd 06 0b				call menu 
1459			 
1459 fe 00				cp 0 
145b c8					ret z 
145c			 
145c 3d					dec a 
145d			 
145d			 
145d					; locate menu option 
145d			 
145d 21 1d ee				ld hl, scratch 
1460 cd 2d 0a				call table_lookup 
1463			 
1463					if DEBUG_FORTH_WORDS 
1463						DMARK "ALl" 
1463 f5				push af  
1464 3a 78 14			ld a, (.dmark)  
1467 32 77 fb			ld (debug_mark),a  
146a 3a 79 14			ld a, (.dmark+1)  
146d 32 78 fb			ld (debug_mark+1),a  
1470 3a 7a 14			ld a, (.dmark+2)  
1473 32 79 fb			ld (debug_mark+2),a  
1476 18 03			jr .pastdmark  
1478 ..			.dmark: db "ALl"  
147b f1			.pastdmark: pop af  
147c			endm  
# End of macro DMARK
147c						CALLMONITOR 
147c cd 19 17			call break_point_state  
147f				endm  
# End of macro CALLMONITOR
147f					endif 
147f					; with the pointer to the menu it, the byte following the zero term is the file id 
147f			 
147f 3e 00				ld a, 0 
1481 01 32 00				ld bc, 50   ; max of bytes to look at 
1484 ed b1				cpir  
1486			 
1486					if DEBUG_FORTH_WORDS 
1486						DMARK "ALb" 
1486 f5				push af  
1487 3a 9b 14			ld a, (.dmark)  
148a 32 77 fb			ld (debug_mark),a  
148d 3a 9c 14			ld a, (.dmark+1)  
1490 32 78 fb			ld (debug_mark+1),a  
1493 3a 9d 14			ld a, (.dmark+2)  
1496 32 79 fb			ld (debug_mark+2),a  
1499 18 03			jr .pastdmark  
149b ..			.dmark: db "ALb"  
149e f1			.pastdmark: pop af  
149f			endm  
# End of macro DMARK
149f						CALLMONITOR 
149f cd 19 17			call break_point_state  
14a2				endm  
# End of macro CALLMONITOR
14a2					endif 
14a2					;inc hl 
14a2			 
14a2 7e					ld a, (hl)   ; file id 
14a3					 
14a3				        ; save bank and file ids 
14a3			 
14a3 f5					push af 
14a4			 
14a4			; TODO need to save to block 0 on bank 1	 
14a4			 
14a4 cd bd 03				call storage_get_block_0 
14a7			 
14a7					if DEBUG_FORTH_WORDS 
14a7						DMARK "AL0" 
14a7 f5				push af  
14a8 3a bc 14			ld a, (.dmark)  
14ab 32 77 fb			ld (debug_mark),a  
14ae 3a bd 14			ld a, (.dmark+1)  
14b1 32 78 fb			ld (debug_mark+1),a  
14b4 3a be 14			ld a, (.dmark+2)  
14b7 32 79 fb			ld (debug_mark+2),a  
14ba 18 03			jr .pastdmark  
14bc ..			.dmark: db "AL0"  
14bf f1			.pastdmark: pop af  
14c0			endm  
# End of macro DMARK
14c0						CALLMONITOR 
14c0 cd 19 17			call break_point_state  
14c3				endm  
# End of macro CALLMONITOR
14c3					endif 
14c3 f1					pop af 
14c4			 
14c4 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
14c7					 
14c7					; save bank id 
14c7			 
14c7 3a 48 f8				ld a,(spi_device) 
14ca 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
14cd			 
14cd					; enable auto run of store file 
14cd			 
14cd 3e 01				ld a, 1 
14cf 32 83 f8				ld (store_page+STORE_0_AUTOFILE),a 
14d2			 
14d2					; save buffer 
14d2			 
14d2 21 00 00				ld hl, 0 
14d5 11 62 f8				ld de, store_page 
14d8					if DEBUG_FORTH_WORDS 
14d8						DMARK "ALw" 
14d8 f5				push af  
14d9 3a ed 14			ld a, (.dmark)  
14dc 32 77 fb			ld (debug_mark),a  
14df 3a ee 14			ld a, (.dmark+1)  
14e2 32 78 fb			ld (debug_mark+1),a  
14e5 3a ef 14			ld a, (.dmark+2)  
14e8 32 79 fb			ld (debug_mark+2),a  
14eb 18 03			jr .pastdmark  
14ed ..			.dmark: db "ALw"  
14f0 f1			.pastdmark: pop af  
14f1			endm  
# End of macro DMARK
14f1						CALLMONITOR 
14f1 cd 19 17			call break_point_state  
14f4				endm  
# End of macro CALLMONITOR
14f4					endif 
14f4 cd 71 03			call storage_write_block	 ; save update 
14f7			  
14f7			 
14f7			 
14f7			 
14f7 21 1d ee				ld hl, scratch 
14fa cd 12 15				call config_fdir 
14fd			 
14fd			 
14fd				endif 
14fd c9				ret 
14fe			 
14fe			 
14fe			 
14fe			; Select storage bank 
14fe			 
14fe			.selbank: 
14fe			 
14fe				if STORAGE_SE 
14fe				endif 
14fe				 
14fe c9				ret 
14ff			 
14ff			if STORAGE_SE 
14ff			 
14ff			.config_ldir:   
14ff				; Load storage bank labels into menu array 
14ff			 
14ff				 
14ff			 
14ff			 
14ff c9				ret 
1500			 
1500			 
1500			endif 
1500			 
1500			 
1500			; Save user words to storage 
1500			 
1500			.savetostore: 
1500			 
1500				if STORAGE_SE 
1500			 
1500 cd 25 15				call config_dir 
1503 21 1d ee			        ld hl, scratch 
1506 3e 00				ld a, 0 
1508 cd 06 0b				call menu 
150b					 
150b 21 1d ee				ld hl, scratch 
150e cd 12 15				call config_fdir 
1511			 
1511			 
1511				endif 
1511			 
1511 c9				ret 
1512			 
1512			 
1512			 
1512			if STORAGE_SE 
1512			 
1512			config_fdir: 
1512				; using the scratch dir go through and release the memory allocated for each string 
1512				 
1512 21 1d ee			ld hl, scratch 
1515 5e			.cfdir:	ld e,(hl) 
1516 23				inc hl 
1517 56				ld d,(hl) 
1518 23				inc hl 
1519			 
1519 eb				ex de, hl 
151a cd 32 0d			call ishlzero 
151d c8				ret z     ; return on null pointer 
151e cd 9a 12			call free 
1521 eb				ex de, hl 
1522 18 f1			jr .cfdir 
1524			 
1524			 
1524 c9				ret 
1525			 
1525			 
1525			config_dir: 
1525			 
1525				; for the config menus that need to build a directory of storage call this routine 
1525				; it will construct a menu in scratch to pass to menu 
1525			 
1525				; open storage device 
1525			 
1525				; execute DIR to build a list of files and their ids into scratch in menu format 
1525				; once the menu has finished then will need to call config_fdir to release the strings 
1525				 
1525				; c = number items 
1525			 
1525				 
1525 cd bd 03			call storage_get_block_0 
1528			 
1528 21 62 f8			ld hl, store_page     ; get current id count 
152b 46				ld b, (hl) 
152c 0e 00			ld c, 0    ; count of files   
152e			 
152e			 
152e 21 1d ee			ld hl, scratch 
1531 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
1534			 
1534				; check for empty drive 
1534			 
1534 3e 00			ld a, 0 
1536 b8				cp b 
1537 ca d1 15			jp z, .dirdone 
153a			 
153a				 
153a					if DEBUG_FORTH_WORDS 
153a						DMARK "Cdc" 
153a f5				push af  
153b 3a 4f 15			ld a, (.dmark)  
153e 32 77 fb			ld (debug_mark),a  
1541 3a 50 15			ld a, (.dmark+1)  
1544 32 78 fb			ld (debug_mark+1),a  
1547 3a 51 15			ld a, (.dmark+2)  
154a 32 79 fb			ld (debug_mark+2),a  
154d 18 03			jr .pastdmark  
154f ..			.dmark: db "Cdc"  
1552 f1			.pastdmark: pop af  
1553			endm  
# End of macro DMARK
1553						CALLMONITOR 
1553 cd 19 17			call break_point_state  
1556				endm  
# End of macro CALLMONITOR
1556					endif 
1556			 
1556			 
1556			.diritem:	 
1556 c5				push bc 
1557				; for each of the current ids do a search for them and if found push to stack 
1557			 
1557 21 40 00				ld hl, STORE_BLOCK_PHY 
155a 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
155c 58					ld e,b 
155d			 
155d cd 2d 06				call storage_findnextid 
1560			 
1560			 
1560					; if found hl will be non zero 
1560			 
1560 cd 32 0d				call ishlzero 
1563 28 69				jr z, .dirnotfound 
1565			 
1565					; increase count 
1565			 
1565 c1					pop bc	 
1566 0c					inc c 
1567 c5					push bc 
1568					 
1568			 
1568					; get file header and push the file name 
1568			 
1568 11 62 f8				ld de, store_page 
156b cd 0c 03				call storage_read_block 
156e			 
156e					; push file id to stack 
156e				 
156e 3a 62 f8				ld a, (store_page) 
1571 26 00				ld h, 0 
1573 6f					ld l, a 
1574			 
1574					;call forth_push_numhl 
1574					; TODO store id 
1574			 
1574 e5					push hl 
1575			 
1575					; push extent count to stack  
1575				 
1575 21 65 f8				ld hl, store_page+3 
1578			 
1578					; get file name length 
1578			 
1578 cd 67 11				call strlenz   
157b			 
157b 23					inc hl   ; cover zero term 
157c 23					inc hl  ; stick the id at the end of the area 
157d			 
157d e5					push hl 
157e c1					pop bc    ; move length to bc 
157f			 
157f cd d0 11				call malloc 
1582			 
1582					; TODO save malloc area to scratch 
1582			 
1582 eb					ex de, hl 
1583 2a 5e f8				ld hl, (store_tmp2) 
1586 73					ld (hl), e 
1587 23					inc hl 
1588 72					ld (hl), d 
1589 23					inc hl 
158a 22 5e f8				ld (store_tmp2), hl 
158d			 
158d					 
158d			 
158d					;pop hl   ; get source 
158d			;		ex de, hl    ; swap aronund	 
158d			 
158d 21 65 f8				ld hl, store_page+3 
1590					if DEBUG_FORTH_WORDS 
1590						DMARK "CFd" 
1590 f5				push af  
1591 3a a5 15			ld a, (.dmark)  
1594 32 77 fb			ld (debug_mark),a  
1597 3a a6 15			ld a, (.dmark+1)  
159a 32 78 fb			ld (debug_mark+1),a  
159d 3a a7 15			ld a, (.dmark+2)  
15a0 32 79 fb			ld (debug_mark+2),a  
15a3 18 03			jr .pastdmark  
15a5 ..			.dmark: db "CFd"  
15a8 f1			.pastdmark: pop af  
15a9			endm  
# End of macro DMARK
15a9						CALLMONITOR 
15a9 cd 19 17			call break_point_state  
15ac				endm  
# End of macro CALLMONITOR
15ac					endif 
15ac ed b0				ldir 
15ae			 
15ae					; de is past string, move back one and store id 
15ae					 
15ae 1b					dec de 
15af			 
15af					; store file id 
15af			 
15af e1					pop hl 
15b0 eb					ex de,hl 
15b1 73					ld (hl), e 
15b2			 
15b2					if DEBUG_FORTH_WORDS 
15b2						DMARK "Cdi" 
15b2 f5				push af  
15b3 3a c7 15			ld a, (.dmark)  
15b6 32 77 fb			ld (debug_mark),a  
15b9 3a c8 15			ld a, (.dmark+1)  
15bc 32 78 fb			ld (debug_mark+1),a  
15bf 3a c9 15			ld a, (.dmark+2)  
15c2 32 79 fb			ld (debug_mark+2),a  
15c5 18 03			jr .pastdmark  
15c7 ..			.dmark: db "Cdi"  
15ca f1			.pastdmark: pop af  
15cb			endm  
# End of macro DMARK
15cb						CALLMONITOR 
15cb cd 19 17			call break_point_state  
15ce				endm  
# End of macro CALLMONITOR
15ce					endif 
15ce					 
15ce			.dirnotfound: 
15ce c1					pop bc     
15cf 10 85				djnz .diritem 
15d1				 
15d1			.dirdone:	 
15d1			 
15d1 3e 00				ld a, 0 
15d3 2a 5e f8				ld hl, (store_tmp2) 
15d6 77					ld (hl), a 
15d7 23					inc hl 
15d8 77					ld (hl), a 
15d9 23					inc hl 
15da					; push a count of the dir items found 
15da			 
15da			;		ld h, 0 
15da			;		ld l, c 
15da			 
15da c9				ret 
15db			 
15db			endif 
15db			 
15db			 
15db			; Settings 
15db			; Run  
15db			 
15db			 
15db			 
15db			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
15db			;;hd_menu2:   db "        2: Editor",0   
15db			;hd_menu2:   db "        2: Editor       6: Menu",0   
15db			;hd_menu3:   db "        3: Storage",0 
15db			;hd_menu4:   db "0=quit  4: Debug",0 
15db			;hd_don:     db "ON",0 
15db			;hd_doff:     db "OFF",0 
15db			; 
15db			; 
15db			; 
15db			;hardware_diags_old:       
15db			; 
15db			;.diagmenu: 
15db			;	call clear_display 
15db			;	ld a, display_row_1 
15db			;	ld de, hd_menu1 
15db			;	call str_at_display 
15db			; 
15db			;	ld a, display_row_2 
15db			;	ld de, hd_menu2 
15db			;	call str_at_display 
15db			; 
15db			;	ld a, display_row_3 
15db			;	ld de, hd_menu3 
15db			;	call str_at_display 
15db			; 
15db			;	ld a,  display_row_4 
15db			;	ld de, hd_menu4 
15db			;	call str_at_display 
15db			; 
15db			;	; display debug state 
15db			; 
15db			;	ld de, hd_don 
15db			;	ld a, (os_view_disable) 
15db			;	cp 0 
15db			;	jr z, .distog 
15db			;	ld de, hd_doff 
15db			;.distog: ld a, display_row_4+17 
15db			;	call str_at_display 
15db			; 
15db			;	call update_display 
15db			; 
15db			;	call cin_wait 
15db			; 
15db			; 
15db			; 
15db			;	cp '4' 
15db			;	jr nz, .diagn1 
15db			; 
15db			;	; debug toggle 
15db			; 
15db			;	ld a, (os_view_disable) 
15db			;	ld b, '*' 
15db			;	cp 0 
15db			;	jr z, .debtog 
15db			;	ld b, 0 
15db			;.debtog:	 
15db			;	ld a,b 
15db			;	ld (os_view_disable),a 
15db			; 
15db			;.diagn1: cp '0' 
15db			;	 ret z 
15db			; 
15db			;;	cp '1' 
15db			;;       jp z, matrix	 
15db			;;   TODO keyboard matrix test 
15db			; 
15db			;	cp '2' 
15db			;	jp z, .diagedit 
15db			; 
15db			;;	cp '6' 
15db			;;	jp z, .menutest 
15db			;;if ENABLE_BASIC 
15db			;;	cp '6' 
15db			;;	jp z, basic 
15db			;;endif 
15db			 ; 
15db			;	jp .diagmenu 
15db			; 
15db			; 
15db			;	ret 
15db			 
15db			 
15db			.debug_tog: 
15db 21 22 16			ld hl, .menudebug 
15de				 
15de 3a 0e ee			ld a, (os_view_disable) 
15e1 fe 2a			cp '*' 
15e3 20 04			jr nz,.tdon  
15e5 3e 01			ld a, 1 
15e7 18 02			jr .tog1 
15e9 3e 00		.tdon: ld a, 0 
15eb			 
15eb			.tog1: 
15eb cd 06 0b			call menu 
15ee fe 00			cp 0 
15f0 c8				ret z 
15f1 fe 01			cp 1    ; disable debug 
15f3 28 04			jr z, .dtog0 
15f5 3e 2a			ld a, '*' 
15f7 18 02			jr .dtogset 
15f9 3e 00		.dtog0: ld a, 0 
15fb 32 0e ee		.dtogset:  ld (os_view_disable), a 
15fe c3 db 15			jp .debug_tog 
1601			 
1601			 
1601			hardware_diags:       
1601			 
1601			.diagm: 
1601 21 14 16			ld hl, .menuitems 
1604 3e 00			ld a, 0 
1606 cd 06 0b			call menu 
1609			 
1609 fe 00		         cp 0 
160b c8				 ret z 
160c			 
160c fe 02			cp 2 
160e ca 6d 16			jp z, .diagedit 
1611			 
1611			;	cp '6' 
1611			;	jp z, .menutest 
1611			;if ENABLE_BASIC 
1611			;	cp '6' 
1611			;	jp z, basic 
1611			;endif 
1611			  
1611 c3 01 16			jp .diagm 
1614			 
1614				 
1614 28 16		.menuitems:   	dw .m1 
1616 33 16				dw .m2 
1618 3a 16				dw .m3 
161a 42 16				dw .m5 
161c 48 16				dw .m5a 
161e 51 16				dw .m5b 
1620 00 00				dw 0 
1622			 
1622			.menudebug: 
1622 5a 16				dw .m6 
1624 63 16				dw .m7 
1626 00 00				dw 0 
1628			 
1628 .. 00		.m1:   db "Key Matrix",0 
1633 .. 00		.m2:   db "Editor",0 
163a .. 00		.m3:   db "Storage",0 
1642 .. 00		.m5:   db "Sound",0 
1648 .. 00		.m5a:  db "RAM Test",0 
1651 .. 00		.m5b:  db "LCD Test",0 
165a			 
165a .. 00		.m6:   db "Debug ON",0 
1663 .. 00		.m7:   db "Debug OFF",0 
166d			 
166d			; debug editor 
166d			 
166d			.diagedit: 
166d			 
166d 21 1d ee			ld hl, scratch 
1670			;	ld bc, 250 
1670			;	ldir 
1670				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1670 3e 00			ld a, 0 
1672 77				ld (hl), a 
1673 23				inc hl 
1674 77				ld (hl), a 
1675 23				inc hl 
1676 77				ld (hl), a 
1677			 
1677 cd d5 0a		        call clear_display 
167a cd f8 0a			call update_display 
167d 3e 01			ld a, 1 
167f 32 7d fb			ld (hardware_diag), a 
1682			.diloop: 
1682 3e 00			ld a, display_row_1 
1684 0e 00			ld c, 0 
1686 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1688 1e 28			ld e, 40 
168a			 
168a 21 1d ee			ld hl, scratch	 
168d cd 36 0d			call input_str 
1690			 
1690 3e 28			ld a, display_row_2 
1692 11 1d ee			ld de, scratch 
1695 cd e8 0a			call str_at_display 
1698 cd f8 0a			call update_display 
169b			 
169b c3 82 16			jp .diloop 
169e			 
169e			 
169e			; pass word in hl 
169e			; a has display location 
169e			display_word_at: 
169e f5				push af 
169f e5				push hl 
16a0 7c				ld a,h 
16a1 21 22 f1			ld hl, os_word_scratch 
16a4 cd 0a 10			call hexout 
16a7 e1				pop hl 
16a8 7d				ld a,l 
16a9 21 24 f1			ld hl, os_word_scratch+2 
16ac cd 0a 10			call hexout 
16af 21 26 f1			ld hl, os_word_scratch+4 
16b2 3e 00			ld a,0 
16b4 77				ld (hl),a 
16b5 11 22 f1			ld de,os_word_scratch 
16b8 f1				pop af 
16b9 cd e8 0a				call str_at_display 
16bc c9				ret 
16bd			 
16bd			display_ptr_state: 
16bd			 
16bd				; to restore afterwards 
16bd			 
16bd d5				push de 
16be c5				push bc 
16bf e5				push hl 
16c0 f5				push af 
16c1			 
16c1				; for use in here 
16c1			 
16c1			;	push bc 
16c1			;	push de 
16c1			;	push hl 
16c1			;	push af 
16c1			 
16c1 cd d5 0a			call clear_display 
16c4			 
16c4 11 97 18			ld de, .ptrstate 
16c7 3e 00			ld a, display_row_1 
16c9 cd e8 0a			call str_at_display 
16cc			 
16cc				; display debug step 
16cc			 
16cc			 
16cc 11 77 fb			ld de, debug_mark 
16cf 3e 26			ld a, display_row_1+display_cols-2 
16d1 cd e8 0a			call str_at_display 
16d4			 
16d4				; display a 
16d4 11 a1 18			ld de, .ptrcliptr 
16d7 3e 28			ld a, display_row_2 
16d9 cd e8 0a			call str_at_display 
16dc			 
16dc f1				pop af 
16dd 2a 28 f8			ld hl,(cli_ptr) 
16e0 3e 30			ld a, display_row_2+8 
16e2 cd 9e 16			call display_word_at 
16e5			 
16e5			 
16e5				; display hl 
16e5			 
16e5			 
16e5 11 a9 18			ld de, .ptrclioptr 
16e8 3e 32			ld a, display_row_2+10 
16ea cd e8 0a			call str_at_display 
16ed			; 
16ed			;	pop hl 
16ed 3e 35			ld a, display_row_2+13 
16ef 2a 26 f8			ld hl,(cli_origptr) 
16f2 cd 9e 16			call display_word_at 
16f5			; 
16f5			;	 
16f5			;	; display de 
16f5			 
16f5			;	ld de, .regstatede 
16f5			;	ld a, display_row_3 
16f5			;	call str_at_display 
16f5			 
16f5			;	pop de 
16f5			;	ld h,d 
16f5			;	ld l, e 
16f5			;	ld a, display_row_3+3 
16f5			;	call display_word_at 
16f5			 
16f5			 
16f5				; display bc 
16f5			 
16f5			;	ld de, .regstatebc 
16f5			;	ld a, display_row_3+10 
16f5			;	call str_at_display 
16f5			 
16f5			;	pop bc 
16f5			;	ld h,b 
16f5			;	ld l, c 
16f5			;	ld a, display_row_3+13 
16f5			;	call display_word_at 
16f5			 
16f5			 
16f5				; display dsp 
16f5			 
16f5			;	ld de, .regstatedsp 
16f5			;	ld a, display_row_4 
16f5			;	call str_at_display 
16f5			 
16f5				 
16f5			;	ld hl,(cli_data_sp) 
16f5			;	ld a, display_row_4+4 
16f5			;	call display_word_at 
16f5			 
16f5				; display rsp 
16f5			 
16f5 11 d8 18			ld de, .regstatersp 
16f8 3e 82			ld a, display_row_4+10 
16fa cd e8 0a			call str_at_display 
16fd			 
16fd				 
16fd 2a 0e f8			ld hl,(cli_ret_sp) 
1700 3e 86			ld a, display_row_4+14 
1702 cd 9e 16			call display_word_at 
1705			 
1705 cd f8 0a			call update_display 
1708			 
1708 cd 55 0a			call delay1s 
170b cd 55 0a			call delay1s 
170e cd 55 0a			call delay1s 
1711			 
1711			 
1711 cd 21 1c			call next_page_prompt 
1714			 
1714				; restore  
1714			 
1714 f1				pop af 
1715 e1				pop hl 
1716 c1				pop bc 
1717 d1				pop de 
1718 c9				ret 
1719			 
1719			break_point_state: 
1719 f5				push af 
171a			 
171a				; see if disabled 
171a			 
171a 3a 0e ee			ld a, (os_view_disable) 
171d fe 2a			cp '*' 
171f 20 02			jr nz, .bpsgo 
1721 f1				pop af 
1722 c9				ret 
1723			 
1723			.bpsgo: 
1723 f1				pop af 
1724 f5				push af 
1725 22 0a ee			ld (os_view_hl), hl 
1728 ed 53 08 ee		ld (os_view_de), de 
172c ed 43 06 ee		ld (os_view_bc), bc 
1730 e5				push hl 
1731 6f				ld l, a 
1732 26 00			ld h, 0 
1734 22 0c ee			ld (os_view_af),hl 
1737			 
1737 21 bd fa				ld hl, display_fb0 
173a 22 d8 f8				ld (display_fb_active), hl 
173d e1				pop hl	 
173e			 
173e 3e 31			ld a, '1' 
1740 fe 2a		.bps1:  cp '*' 
1742 20 03			jr nz, .bps1b 
1744 32 0e ee			ld (os_view_disable),a 
1747 fe 31		.bps1b:  cp '1' 
1749 20 14			jr nz, .bps2 
174b			 
174b				; display reg 
174b			 
174b				 
174b			 
174b 3a 0c ee			ld a, (os_view_af) 
174e 2a 0a ee			ld hl, (os_view_hl) 
1751 ed 5b 08 ee		ld de, (os_view_de) 
1755 ed 4b 06 ee		ld bc, (os_view_bc) 
1759 cd f3 17			call display_reg_state 
175c c3 df 17			jp .bpschk 
175f			 
175f fe 32		.bps2:  cp '2' 
1761 20 08			jr nz, .bps3 
1763				 
1763				; display hl 
1763 2a 0a ee			ld hl, (os_view_hl) 
1766 cd dd 18			call display_dump_at_hl 
1769			 
1769 18 74			jr .bpschk 
176b			 
176b fe 33		.bps3:  cp '3' 
176d 20 08			jr nz, .bps4 
176f			 
176f			        ; display de 
176f 2a 08 ee			ld hl, (os_view_de) 
1772 cd dd 18			call display_dump_at_hl 
1775			 
1775 18 68			jr .bpschk 
1777 fe 34		.bps4:  cp '4' 
1779 20 08			jr nz, .bps5 
177b			 
177b			        ; display bc 
177b 2a 06 ee			ld hl, (os_view_bc) 
177e cd dd 18			call display_dump_at_hl 
1781			 
1781 18 5c			jr .bpschk 
1783 fe 35		.bps5:  cp '5' 
1785 20 08		        jr nz, .bps7 
1787			 
1787				; display cur ptr 
1787 2a 28 f8			ld hl, (cli_ptr) 
178a cd dd 18			call display_dump_at_hl 
178d			 
178d 18 50			jr .bpschk 
178f fe 36		.bps7:  cp '6' 
1791 20 08			jr nz, .bps8b 
1793				 
1793				; display cur orig ptr 
1793 2a 26 f8			ld hl, (cli_origptr) 
1796 cd dd 18			call display_dump_at_hl 
1799 18 44			jr .bpschk 
179b fe 37		.bps8b:  cp '7' 
179d 20 08			jr nz, .bps9 
179f				 
179f				; display dsp 
179f 2a 0a f8			ld hl, (cli_data_sp) 
17a2 cd dd 18			call display_dump_at_hl 
17a5			 
17a5 18 38			jr .bpschk 
17a7 fe 39		.bps9:  cp '9' 
17a9 20 05			jr nz, .bps8c 
17ab				 
17ab				; display SP 
17ab			;	ld hl, sp 
17ab cd dd 18			call display_dump_at_hl 
17ae			 
17ae 18 2f			jr .bpschk 
17b0 fe 38		.bps8c:  cp '8' 
17b2 20 08			jr nz, .bps8d 
17b4				 
17b4				; display rsp 
17b4 2a 0e f8			ld hl, (cli_ret_sp) 
17b7 cd dd 18			call display_dump_at_hl 
17ba			 
17ba 18 23			jr .bpschk 
17bc fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17be 20 05			jr nz, .bps8 
17c0 cd 17 1a			call monitor 
17c3			 
17c3 18 1a			jr .bpschk 
17c5 fe 30		.bps8:  cp '0' 
17c7 20 16			jr nz, .bpschk 
17c9			 
17c9 21 1c fa				ld hl, display_fb1 
17cc 22 d8 f8				ld (display_fb_active), hl 
17cf cd f8 0a				call update_display 
17d2			 
17d2				;ld a, (os_view_af) 
17d2 2a 0a ee			ld hl, (os_view_hl) 
17d5 ed 5b 08 ee		ld de, (os_view_de) 
17d9 ed 4b 06 ee		ld bc, (os_view_bc) 
17dd f1				pop af 
17de c9				ret 
17df			 
17df			.bpschk:   
17df cd 55 0a			call delay1s 
17e2 3e 9f		ld a,display_row_4 + display_cols - 1 
17e4 11 1f 1c		        ld de, endprg 
17e7 cd e8 0a			call str_at_display 
17ea cd f8 0a			call update_display 
17ed cd ef 69			call cin_wait 
17f0			 
17f0 c3 40 17			jp .bps1 
17f3			 
17f3			 
17f3			display_reg_state: 
17f3			 
17f3				; to restore afterwards 
17f3			 
17f3 d5				push de 
17f4 c5				push bc 
17f5 e5				push hl 
17f6 f5				push af 
17f7			 
17f7				; for use in here 
17f7			 
17f7 c5				push bc 
17f8 d5				push de 
17f9 e5				push hl 
17fa f5				push af 
17fb			 
17fb cd d5 0a			call clear_display 
17fe			 
17fe 11 b3 18			ld de, .regstate 
1801 3e 00			ld a, display_row_1 
1803 cd e8 0a			call str_at_display 
1806			 
1806				; display debug step 
1806			 
1806			 
1806 11 77 fb			ld de, debug_mark 
1809 3e 25			ld a, display_row_1+display_cols-3 
180b cd e8 0a			call str_at_display 
180e			 
180e				; display a 
180e 11 cf 18			ld de, .regstatea 
1811 3e 28			ld a, display_row_2 
1813 cd e8 0a			call str_at_display 
1816			 
1816 e1				pop hl 
1817			;	ld h,0 
1817			;	ld l, a 
1817 3e 2b			ld a, display_row_2+3 
1819 cd 9e 16			call display_word_at 
181c			 
181c			 
181c				; display hl 
181c			 
181c			 
181c 11 c3 18			ld de, .regstatehl 
181f 3e 32			ld a, display_row_2+10 
1821 cd e8 0a			call str_at_display 
1824			 
1824 e1				pop hl 
1825 3e 35			ld a, display_row_2+13 
1827 cd 9e 16			call display_word_at 
182a			 
182a				 
182a				; display de 
182a			 
182a 11 c7 18			ld de, .regstatede 
182d 3e 50			ld a, display_row_3 
182f cd e8 0a			call str_at_display 
1832			 
1832 e1				pop hl 
1833			;	ld h,d 
1833			;	ld l, e 
1833 3e 53			ld a, display_row_3+3 
1835 cd 9e 16			call display_word_at 
1838			 
1838			 
1838				; display bc 
1838			 
1838 11 cb 18			ld de, .regstatebc 
183b 3e 5a			ld a, display_row_3+10 
183d cd e8 0a			call str_at_display 
1840			 
1840 e1				pop hl 
1841			;	ld h,b 
1841			;	ld l, c 
1841 3e 5d			ld a, display_row_3+13 
1843 cd 9e 16			call display_word_at 
1846			 
1846			 
1846				; display dsp 
1846			 
1846 11 d3 18			ld de, .regstatedsp 
1849 3e 78			ld a, display_row_4 
184b cd e8 0a			call str_at_display 
184e			 
184e				 
184e 2a 0a f8			ld hl,(cli_data_sp) 
1851 3e 7c			ld a, display_row_4+4 
1853 cd 9e 16			call display_word_at 
1856			 
1856				; display rsp 
1856			 
1856 11 d8 18			ld de, .regstatersp 
1859 3e 82			ld a, display_row_4+10 
185b cd e8 0a			call str_at_display 
185e			 
185e				 
185e 2a 0e f8			ld hl,(cli_ret_sp) 
1861 3e 86			ld a, display_row_4+14 
1863 cd 9e 16			call display_word_at 
1866			 
1866 cd f8 0a			call update_display 
1869			 
1869			;	call delay1s 
1869			;	call delay1s 
1869			;	call delay1s 
1869			 
1869			 
1869			;	call next_page_prompt 
1869			 
1869				; restore  
1869			 
1869 f1				pop af 
186a e1				pop hl 
186b c1				pop bc 
186c d1				pop de 
186d c9				ret 
186e			 
186e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1882 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1897 .. 00		.ptrstate:	db "Ptr State",0 
18a1 .. 00		.ptrcliptr:     db "cli_ptr",0 
18a9 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18b3 .. 00		.regstate:	db "Reg State (1/0)",0 
18c3 .. 00		.regstatehl:	db "HL:",0 
18c7 .. 00		.regstatede:	db "DE:",0 
18cb .. 00		.regstatebc:	db "BC:",0 
18cf .. 00		.regstatea:	db "A :",0 
18d3 .. 00		.regstatedsp:	db "DSP:",0 
18d8 .. 00		.regstatersp:	db "RSP:",0 
18dd			 
18dd			display_dump_at_hl: 
18dd e5				push hl 
18de d5				push de 
18df c5				push bc 
18e0 f5				push af 
18e1			 
18e1 22 40 f1			ld (os_cur_ptr),hl	 
18e4 cd d5 0a			call clear_display 
18e7 cd 29 1b			call dumpcont 
18ea			;	call delay1s 
18ea			;	call next_page_prompt 
18ea			 
18ea			 
18ea f1				pop af 
18eb c1				pop bc 
18ec d1				pop de 
18ed e1				pop hl 
18ee c9				ret 
18ef			 
18ef			;if ENABLE_BASIC 
18ef			;	include "nascombasic.asm" 
18ef			;	basic: 
18ef			;	include "forth/FORTH.ASM" 
18ef			;endif 
18ef			 
18ef			; eof 
18ef			 
18ef			 
# End of file firmware_diags.asm
18ef			  
18ef			  
18ef			  
18ef			  
18ef			; eof  
18ef			  
# End of file firmware.asm
18ef			 
18ef			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
18ef			;if BASE_KEV  
18ef			;baseram: equ 08000h 
18ef			;endif 
18ef			 
18ef			;if BASE_SC114 
18ef			;baseram:     equ    endofcode 
18ef			;endif 
18ef			 
18ef			 
18ef			; start system 
18ef			 
18ef			coldstart: 
18ef				; set sp 
18ef				; di/ei 
18ef			 
18ef f3				di 
18f0 31 fd ff			ld sp, tos 
18f3			;	ei 
18f3			 
18f3			 
18f3				; disable breakpoint by default 
18f3			 
18f3 3e 2a			ld a,'*' 
18f5 32 0e ee			ld (os_view_disable),a 
18f8			 
18f8				; init hardware 
18f8			 
18f8				; init keyboard and screen hardware 
18f8			 
18f8 cd 03 00			call hardware_init 
18fb			 
18fb			 
18fb				; detect if any keys are held down to enable breakpoints at start up 
18fb			 
18fb cd 00 6a			call cin  
18fe fe 00			cp 0 
1900 28 03			jr z, .nokeys 
1902			 
1902				;call hardware_diags 
1902 cd 93 13			call config 
1905			 
1905			;	ld de, .bpen 
1905			;	ld a, display_row_4 
1905			;	call str_at_display 
1905			;	call update_display 
1905			; 
1905			;	ld a,0 
1905			;	ld (os_view_disable),a 
1905			; 
1905			;.bpwait: 
1905			;	call cin 
1905			;	cp 0 
1905			;	jr z, .bpwait 
1905			;	jr .nokeys 
1905			; 
1905			; 
1905			;.bpen:  db "Break points enabled!",0 
1905			 
1905			 
1905			 
1905			 
1905			 
1905			 
1905			.nokeys: 
1905			 
1905			 
1905				 
1905			 
1905			;jp  testkey 
1905			 
1905			;call storage_get_block_0 
1905			; 
1905			;ld hl, 0 
1905			;ld de, store_page 
1905			;call storage_read_block 
1905			 
1905				 
1905			;ld hl, 10 
1905			;ld de, store_page 
1905			;call storage_read_block 
1905			 
1905			 
1905			 
1905			 
1905			 
1905			;stop:	nop 
1905			;	jp stop 
1905			 
1905			 
1905			 
1905			main: 
1905 cd d5 0a			call clear_display 
1908 cd f8 0a			call update_display 
190b			 
190b			 
190b			 
190b			;	call testlcd 
190b			 
190b			 
190b			 
190b cd e7 1f			call forth_init 
190e			 
190e			 
190e			warmstart: 
190e cd bd 1f			call forth_warmstart 
1911			 
1911				; run startup word load 
1911			        ; TODO prevent this running at warmstart after crash  
1911			 
1911				if STARTUP_ENABLE 
1911 cd 9d 62				call forth_startup 
1914			 
1914					if STORAGE_SE 
1914 cd 8e 65					call forth_autoload 
1917					endif 
1917			 
1917				endif 
1917			 
1917				; show free memory after boot 
1917 11 b1 19			ld de, freeram 
191a 3e 00			ld a, display_row_1 
191c cd e8 0a			call str_at_display 
191f			 
191f			; Or use heap_size word???? 
191f 21 03 ee			ld hl, heap_end 
1922 11 0e 80			ld de, heap_start 
1925 ed 52			sbc hl, de 
1927 e5				push hl 
1928 7c				ld a,h	         	 
1929 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
192c cd 0a 10			call hexout 
192f e1			   	pop hl 
1930			 
1930 7d				ld a,l 
1931 21 24 f1			ld hl, os_word_scratch+2 
1934 cd 0a 10			call hexout 
1937 21 26 f1			ld hl, os_word_scratch+4 
193a 3e 00			ld a, 0 
193c 77				ld (hl),a 
193d 11 22 f1			ld de, os_word_scratch 
1940 3e 0d			ld a, display_row_1 + 13 
1942 cd e8 0a			call str_at_display 
1945 cd f8 0a			call update_display 
1948			 
1948			 
1948				;call demo 
1948			 
1948			 
1948				; init scratch input area for cli commands 
1948			 
1948 21 44 f1			ld hl, os_cli_cmd 
194b 3e 00			ld a,0 
194d 77				ld (hl),a 
194e 23				inc hl 
194f 77				ld (hl),a 
1950			 
1950 3e 00			ld a,0 
1952 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1955			 
1955 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1958 32 41 f1			ld (os_cur_ptr+1),a	 
195b			 
195b 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
195e 32 23 f1			ld (os_word_scratch+1),a	 
1961				 
1961			 
1961				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1961 21 44 f1			ld hl, os_cli_cmd 
1964			 
1964 3e 00			ld a, 0		 ; init cli input 
1966 77				ld (hl), a 
1967 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1969			cli: 
1969				; show cli prompt 
1969				;push af 
1969				;ld a, 0 
1969				;ld de, prompt 
1969				;call str_at_display 
1969			 
1969				;call update_display 
1969				;pop af 
1969				;inc a 
1969				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1969 0e 00			ld c, 0 
196b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
196d 1e 28			ld e, 40 
196f			 
196f 21 44 f1			ld hl, os_cli_cmd 
1972			 
1972				STACKFRAME OFF $fefe $9f9f 
1972				if DEBUG_STACK_IMB 
1972					if OFF 
1972						exx 
1972						ld de, $fefe 
1972						ld a, d 
1972						ld hl, curframe 
1972						call hexout 
1972						ld a, e 
1972						ld hl, curframe+2 
1972						call hexout 
1972						ld hl, $fefe 
1972						push hl 
1972						ld hl, $9f9f 
1972						push hl 
1972						exx 
1972					endif 
1972				endif 
1972			endm 
# End of macro STACKFRAME
1972			 
1972 cd 36 0d			call input_str 
1975			 
1975				STACKFRAMECHK OFF $fefe $9f9f 
1975				if DEBUG_STACK_IMB 
1975					if OFF 
1975						exx 
1975						ld hl, $9f9f 
1975						pop de   ; $9f9f 
1975						call cmp16 
1975						jr nz, .spnosame 
1975						ld hl, $fefe 
1975						pop de   ; $fefe 
1975						call cmp16 
1975						jr z, .spfrsame 
1975						.spnosame: call showsperror 
1975						.spfrsame: nop 
1975						exx 
1975					endif 
1975				endif 
1975			endm 
# End of macro STACKFRAMECHK
1975			 
1975				; copy input to last command 
1975			 
1975 21 44 f1			ld hl, os_cli_cmd 
1978 11 43 f2			ld de, os_last_cmd 
197b 01 ff 00			ld bc, 255 
197e ed b0			ldir 
1980			 
1980				; wipe current buffer 
1980			 
1980			;	ld a, 0 
1980			;	ld hl, os_cli_cmd 
1980			;	ld de, os_cli_cmd+1 
1980			;	ld bc, 254 
1980			;	ldir 
1980				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1980			;	call strcpy 
1980			;	ld a, 0 
1980			;	ld (hl), a 
1980			;	inc hl 
1980			;	ld (hl), a 
1980			;	inc hl 
1980			;	ld (hl), a 
1980			 
1980				; switch frame buffer to program  
1980			 
1980 21 1c fa				ld hl, display_fb1 
1983 22 d8 f8				ld (display_fb_active), hl 
1986			 
1986			;	nop 
1986				STACKFRAME ON $fbfe $8f9f 
1986				if DEBUG_STACK_IMB 
1986					if ON 
1986						exx 
1986						ld de, $fbfe 
1986						ld a, d 
1986						ld hl, curframe 
1986						call hexout 
1986						ld a, e 
1986						ld hl, curframe+2 
1986						call hexout 
1986						ld hl, $fbfe 
1986						push hl 
1986						ld hl, $8f9f 
1986						push hl 
1986						exx 
1986					endif 
1986				endif 
1986			endm 
# End of macro STACKFRAME
1986				; first time into the parser so pass over the current scratch pad 
1986 21 44 f1			ld hl,os_cli_cmd 
1989				; tokenise the entered statement(s) in HL 
1989 cd 60 20			call forthparse 
198c			        ; exec forth statements in top of return stack 
198c cd a0 20			call forthexec 
198f				;call forthexec_cleanup 
198f			;	call parsenext 
198f			 
198f				STACKFRAMECHK ON $fbfe $8f9f 
198f				if DEBUG_STACK_IMB 
198f					if ON 
198f						exx 
198f						ld hl, $8f9f 
198f						pop de   ; $8f9f 
198f						call cmp16 
198f						jr nz, .spnosame 
198f						ld hl, $fbfe 
198f						pop de   ; $fbfe 
198f						call cmp16 
198f						jr z, .spfrsame 
198f						.spnosame: call showsperror 
198f						.spfrsame: nop 
198f						exx 
198f					endif 
198f				endif 
198f			endm 
# End of macro STACKFRAMECHK
198f				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
198f			 
198f 3e 78			ld a, display_row_4 
1991 11 c3 19			ld de, endprog 
1994			 
1994 cd f8 0a			call update_display		 
1997			 
1997 cd 21 1c			call next_page_prompt 
199a			 
199a				; switch frame buffer to cli 
199a			 
199a 21 bd fa				ld hl, display_fb0 
199d 22 d8 f8				ld (display_fb_active), hl 
19a0			 
19a0			 
19a0 cd d5 0a		        call clear_display 
19a3 cd f8 0a			call update_display		 
19a6			 
19a6 21 44 f1			ld hl, os_cli_cmd 
19a9			 
19a9 3e 00			ld a, 0		 ; init cli input 
19ab 77				ld (hl), a 
19ac			 
19ac				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19ac			 
19ac				; now on last line 
19ac			 
19ac				; TODO scroll screen up 
19ac			 
19ac				; TODO instead just clear screen and place at top of screen 
19ac			 
19ac			;	ld a, 0 
19ac			;	ld (f_cursor_ptr),a 
19ac			 
19ac				;call clear_display 
19ac				;call update_display 
19ac			 
19ac				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19ac 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19ae c3 69 19			jp cli 
19b1			 
19b1 .. 00		freeram: db "Free bytes: $",0 
19bf ..			asc: db "1A2F" 
19c3 .. 00		endprog: db "End prog...",0 
19cf			 
19cf			testenter2:   
19cf 21 4f ee			ld hl,scratch+50 
19d2 22 40 f1			ld (os_cur_ptr),hl 
19d5 c3 69 19			jp cli 
19d8			 
19d8			testenter:  
19d8			 
19d8 21 bf 19			ld hl,asc 
19db			;	ld a,(hl) 
19db			;	call nibble2val 
19db cd 60 10			call get_byte 
19de			 
19de			 
19de			;	ld a,(hl) 
19de			;	call atohex 
19de			 
19de			;	call fourehexhl 
19de 32 4f ee			ld (scratch+50),a 
19e1			 
19e1			 
19e1			 
19e1 21 c1 19			ld hl,asc+2 
19e4			;	ld a, (hl) 
19e4			;	call nibble2val 
19e4 cd 60 10			call get_byte 
19e7			 
19e7			;	call fourehexhl 
19e7 32 51 ee			ld (scratch+52),a 
19ea				 
19ea 21 4f ee			ld hl,scratch+50 
19ed 22 40 f1			ld (os_cur_ptr),hl 
19f0 c3 69 19			jp cli 
19f3			 
19f3			enter:	 
19f3 3a 21 ee			ld a,(scratch+4) 
19f6 fe 00			cp 0 
19f8 28 0c			jr z, .entercont 
19fa				; no, not a null term line so has an address to work out.... 
19fa			 
19fa 21 1f ee			ld hl,scratch+2 
19fd cd c0 10			call get_word_hl 
1a00			 
1a00 22 40 f1			ld (os_cur_ptr),hl	 
1a03 c3 69 19			jp cli 
1a06			 
1a06			 
1a06			.entercont:  
1a06			 
1a06 21 1f ee			ld hl, scratch+2 
1a09 cd 60 10			call get_byte 
1a0c			 
1a0c 2a 40 f1		   	ld hl,(os_cur_ptr) 
1a0f 77					ld (hl),a 
1a10 23					inc hl 
1a11 22 40 f1				ld (os_cur_ptr),hl 
1a14				 
1a14			; get byte  
1a14			 
1a14			 
1a14 c3 69 19			jp cli 
1a17			 
1a17			 
1a17			; basic monitor support 
1a17			 
1a17			monitor: 
1a17				;  
1a17 cd d5 0a			call clear_display 
1a1a 3e 00			ld a, 0 
1a1c 11 64 1a			ld de, .monprompt 
1a1f cd e8 0a			call str_at_display 
1a22 cd f8 0a			call update_display 
1a25			 
1a25				; get a monitor command 
1a25			 
1a25 0e 00			ld c, 0     ; entry at top left 
1a27 16 64			ld d, 100   ; max buffer size 
1a29 1e 0f			ld e, 15    ; input scroll area 
1a2b 3e 00			ld a, 0     ; init string 
1a2d 21 1b f0			ld hl, os_input 
1a30 77				ld (hl), a 
1a31 23				inc hl 
1a32 77				ld (hl), a 
1a33 21 1b f0			ld hl, os_input 
1a36 3e 01			ld a, 1     ; init string 
1a38 cd 36 0d			call input_str 
1a3b			 
1a3b cd d5 0a		        call clear_display 
1a3e cd f8 0a			call update_display		 
1a41			 
1a41 3a 1b f0			ld a, (os_input) 
1a44 cd 5e 11			call toUpper 
1a47 fe 48		        cp 'H' 
1a49 28 6f		        jr z, .monhelp 
1a4b fe 44			cp 'D'		; dump 
1a4d ca db 1a			jp z, .mondump	 
1a50 fe 43			cp 'C'		; dump 
1a52 ca f5 1a			jp z, .moncdump	 
1a55 fe 4d			cp 'M'		; dump 
1a57 ca 66 1a			jp z, .moneditstart 
1a5a fe 55			cp 'U'		; dump 
1a5c 28 14			jr z, .monedit	 
1a5e fe 51			cp 'Q'		; dump 
1a60 c8				ret z	 
1a61			 
1a61			 
1a61				; TODO "S" to access symbol by name and not need the address 
1a61				; TODO "F" to find a string in memory 
1a61			 
1a61 c3 17 1a			jp monitor 
1a64			 
1a64 .. 00		.monprompt: db ">", 0 
1a66			 
1a66			.moneditstart: 
1a66				; get starting address 
1a66			 
1a66 21 1d f0			ld hl,os_input+2 
1a69 cd c0 10			call get_word_hl 
1a6c			 
1a6c 22 40 f1			ld (os_cur_ptr),hl	 
1a6f			 
1a6f c3 17 1a			jp monitor 
1a72			 
1a72			.monedit: 
1a72				; get byte to load 
1a72			 
1a72 21 1d f0			ld hl,os_input+2 
1a75 cd 60 10			call get_byte 
1a78			 
1a78				; get address to update 
1a78 2a 40 f1			ld hl, (os_cur_ptr) 
1a7b			 
1a7b				; update byte 
1a7b			 
1a7b 77				ld (hl), a 
1a7c			 
1a7c				; move to next address and save it 
1a7c			 
1a7c 23				inc hl 
1a7d 22 40 f1			ld (os_cur_ptr),hl	 
1a80			 
1a80 c3 17 1a			jp monitor 
1a83			 
1a83			 
1a83 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a97 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ab3 .. 00		.monhelptext3:  db "Q-Quit",0 
1aba			        
1aba			.monhelp: 
1aba 3e 00			ld a, display_row_1 
1abc 11 83 1a		        ld de, .monhelptext1 
1abf			 
1abf cd e8 0a			call str_at_display 
1ac2 3e 28			ld a, display_row_2 
1ac4 11 97 1a		        ld de, .monhelptext2 
1ac7					 
1ac7 cd e8 0a			call str_at_display 
1aca 3e 50			ld a, display_row_3 
1acc 11 b3 1a		        ld de, .monhelptext3 
1acf					 
1acf cd e8 0a			call str_at_display 
1ad2 cd f8 0a			call update_display		 
1ad5			 
1ad5 cd 21 1c			call next_page_prompt 
1ad8 c3 17 1a			jp monitor 
1adb			 
1adb			.mondump:    
1adb 21 1d f0			ld hl,os_input+2 
1ade cd c0 10			call get_word_hl 
1ae1			 
1ae1 22 40 f1			ld (os_cur_ptr),hl	 
1ae4 cd 29 1b			call dumpcont 
1ae7 3e 78			ld a, display_row_4 
1ae9 11 c3 19			ld de, endprog 
1aec			 
1aec cd f8 0a			call update_display		 
1aef			 
1aef cd 21 1c			call next_page_prompt 
1af2 c3 17 1a			jp monitor 
1af5			.moncdump: 
1af5 cd 29 1b			call dumpcont 
1af8 3e 78			ld a, display_row_4 
1afa 11 c3 19			ld de, endprog 
1afd			 
1afd cd f8 0a			call update_display		 
1b00			 
1b00 cd 21 1c			call next_page_prompt 
1b03 c3 17 1a			jp monitor 
1b06			 
1b06			 
1b06			; TODO symbol access  
1b06			 
1b06			.symbols:     ;; A list of symbols that can be called up  
1b06 bd fa			dw display_fb0 
1b08 .. 00			db "fb0",0  
1b0c 62 f8		     	dw store_page 
1b0e .. 00			db "store_page",0 
1b19			 
1b19			 
1b19			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b19			 
1b19 3a 1e ee			ld a,(scratch+1) 
1b1c fe 00			cp 0 
1b1e 28 09			jr z, dumpcont 
1b20			 
1b20				; no, not a null term line so has an address to work out.... 
1b20			 
1b20 21 1f ee			ld hl,scratch+2 
1b23 cd c0 10			call get_word_hl 
1b26			 
1b26 22 40 f1			ld (os_cur_ptr),hl	 
1b29			 
1b29			 
1b29			 
1b29			dumpcont: 
1b29			 
1b29				; dump bytes at ptr 
1b29			 
1b29			 
1b29 3e 00			ld a, display_row_1 
1b2b 2a d8 f8			ld hl, (display_fb_active) 
1b2e cd 09 0d			call addatohl 
1b31 cd 59 1b			call .dumpbyterow 
1b34			 
1b34 3e 28			ld a, display_row_2 
1b36 2a d8 f8			ld hl, (display_fb_active) 
1b39 cd 09 0d			call addatohl 
1b3c cd 59 1b			call .dumpbyterow 
1b3f			 
1b3f			 
1b3f 3e 50			ld a, display_row_3 
1b41 2a d8 f8			ld hl, (display_fb_active) 
1b44 cd 09 0d			call addatohl 
1b47 cd 59 1b			call .dumpbyterow 
1b4a			 
1b4a 3e 78			ld a, display_row_4 
1b4c 2a d8 f8			ld hl, (display_fb_active) 
1b4f cd 09 0d			call addatohl 
1b52 cd 59 1b			call .dumpbyterow 
1b55			 
1b55 cd f8 0a			call update_display 
1b58			;		jp cli 
1b58 c9				ret 
1b59			 
1b59			.dumpbyterow: 
1b59			 
1b59				;push af 
1b59			 
1b59 e5				push hl 
1b5a			 
1b5a				; calc where to poke the ascii 
1b5a			if display_cols == 20 
1b5a				ld a, 16 
1b5a			else 
1b5a 3e 1f			ld a, 31 
1b5c			endif 
1b5c			 
1b5c cd 09 0d			call addatohl 
1b5f 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1b62			 
1b62			 
1b62			; display decoding address 
1b62 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b65			 
1b65 7c				ld a,h 
1b66 e1				pop hl 
1b67 e5				push hl 
1b68			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b68 cd 0a 10			call hexout 
1b6b 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b6e			 
1b6e 7d				ld a,l 
1b6f e1				pop hl 
1b70 23				inc hl 
1b71 23				inc hl 
1b72 e5				push hl 
1b73			;	ld hl, os_word_scratch+2 
1b73 cd 0a 10			call hexout 
1b76 e1				pop hl 
1b77 23				inc hl 
1b78 23				inc hl 
1b79				;ld hl, os_word_scratch+4 
1b79 3e 3a			ld a, ':' 
1b7b 77				ld (hl),a 
1b7c 23				inc hl 
1b7d				;ld a, 0 
1b7d				;ld (hl),a 
1b7d				;ld de, os_word_scratch 
1b7d				;pop af 
1b7d				;push af 
1b7d			;		ld a, display_row_2 
1b7d			;		call str_at_display 
1b7d			;		call update_display 
1b7d			 
1b7d			 
1b7d			;pop af 
1b7d			;	add 5 
1b7d			 
1b7d			if display_cols == 20 
1b7d				ld b, 4 
1b7d			else 
1b7d 06 08			ld b, 8 
1b7f			endif	 
1b7f			 
1b7f			.dumpbyte: 
1b7f c5				push bc 
1b80 e5				push hl 
1b81			 
1b81			 
1b81 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b84 7e					ld a,(hl) 
1b85			 
1b85					; poke the ascii to display 
1b85 2a 22 f1				ld hl,(os_word_scratch) 
1b88 77					ld (hl),a 
1b89 23					inc hl 
1b8a 22 22 f1				ld (os_word_scratch),hl 
1b8d			 
1b8d					 
1b8d			 
1b8d			 
1b8d e1					pop hl 
1b8e e5					push hl 
1b8f			 
1b8f cd 0a 10				call hexout 
1b92			 
1b92					 
1b92 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b95 23				inc hl 
1b96 22 40 f1		   	ld (os_cur_ptr),hl 
1b99			 
1b99 e1					pop hl 
1b9a 23					inc hl 
1b9b 23					inc hl 
1b9c 23					inc hl 
1b9d			 
1b9d			 
1b9d			 
1b9d					;ld a,0 
1b9d					;ld (os_word_scratch+2),a 
1b9d					;pop af 
1b9d					;push af 
1b9d			 
1b9d					;ld de, os_word_scratch 
1b9d					;call str_at_display 
1b9d			;		call update_display 
1b9d			;		pop af 
1b9d c1					pop bc 
1b9e c6 03				add 3 
1ba0 10 dd			djnz .dumpbyte 
1ba2			 
1ba2				 
1ba2			 
1ba2 c9				ret 
1ba3			 
1ba3			jump:	 
1ba3			 
1ba3 21 1f ee			ld hl,scratch+2 
1ba6 cd c0 10			call get_word_hl 
1ba9				;ld hl,(scratch+2) 
1ba9				;call fourehexhl 
1ba9			 
1ba9 22 40 f1			ld (os_cur_ptr),hl	 
1bac			 
1bac e9				jp (hl) 
1bad			 
1bad			 
1bad			 
1bad			; TODO implement a basic monitor mode to start with 
1bad			 
1bad			 
1bad			 
1bad			 
1bad			 
1bad			 
1bad			 
1bad			 
1bad			 
1bad			; testing and demo code during development 
1bad			 
1bad			 
1bad .. 00		str1: db "Enter some text...",0 
1bc0 .. 00		clear: db "                    ",0 
1bd5			 
1bd5			demo: 
1bd5			 
1bd5			 
1bd5			 
1bd5			;	call update_display 
1bd5			 
1bd5				; init scratch input area for testing 
1bd5 21 1d ee			ld hl, scratch	 
1bd8 3e 00			ld a,0 
1bda 77				ld (hl),a 
1bdb			 
1bdb			 
1bdb 3e 28		            LD   A, display_row_2 
1bdd			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bdd 11 ad 1b		            LD   DE, str1 
1be0 cd e8 0a			call str_at_display 
1be3			 
1be3			;            CALL fLCD_Str       ;Display string pointed to by DE 
1be3			cloop:	 
1be3 3e 50		            LD   A, display_row_3 
1be5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1be5 11 c0 1b		            LD   DE, clear 
1be8			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1be8 cd e8 0a				call str_at_display 
1beb 3e 78			ld a, display_row_4 
1bed 11 1d 1c			ld de, prompt 
1bf0			 
1bf0 cd e8 0a				call str_at_display 
1bf3 cd f8 0a			call update_display 
1bf6			 
1bf6 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bf8 16 0a			ld d, 10 
1bfa 21 1d ee			ld hl, scratch	 
1bfd cd 36 0d			call input_str 
1c00			 
1c00			;	call clear_display 
1c00			;'	call update_display 
1c00			 
1c00 3e 00		            LD   A, display_row_1 
1c02			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c02 11 c0 1b		            LD   DE, clear 
1c05 cd e8 0a				call str_at_display 
1c08			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c08 3e 00		            LD   A, display_row_1 
1c0a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c0a 11 1d ee		            LD   DE, scratch 
1c0d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c0d cd e8 0a				call str_at_display 
1c10 cd f8 0a			call update_display 
1c13			 
1c13 3e 00				ld a,0 
1c15 21 1d ee			ld hl, scratch 
1c18 77				ld (hl),a 
1c19			 
1c19 00				nop 
1c1a c3 e3 1b			jp cloop 
1c1d			 
1c1d			 
1c1d			 
1c1d			; OS Prompt 
1c1d			 
1c1d .. 00		prompt: db ">",0 
1c1f .. 00		endprg: db "?",0 
1c21			 
1c21			 
1c21			; handy next page prompt 
1c21			next_page_prompt: 
1c21 e5				push hl 
1c22 d5				push de 
1c23 f5				push af 
1c24 c5				push bc 
1c25			 
1c25 3e 9f			ld a,display_row_4 + display_cols - 1 
1c27 11 1f 1c		        ld de, endprg 
1c2a cd e8 0a			call str_at_display 
1c2d cd f8 0a			call update_display 
1c30 cd ef 69			call cin_wait 
1c33 c1				pop bc 
1c34 f1				pop af 
1c35 d1				pop de 
1c36 e1				pop hl 
1c37			 
1c37			 
1c37 c9				ret 
1c38			 
1c38			 
1c38			; forth parser 
1c38			 
1c38			; My forth kernel 
1c38			include "forth_kernel.asm" 
1c38			; 
1c38			; kernel to the forth OS 
1c38			 
1c38			DS_TYPE_STR: equ 1     ; string type 
1c38			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c38			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c38			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c38			 
1c38			FORTH_PARSEV1: equ 0 
1c38			FORTH_PARSEV2: equ 0 
1c38			FORTH_PARSEV3: equ 0 
1c38			FORTH_PARSEV4: equ 0 
1c38			FORTH_PARSEV5: equ 1 
1c38			 
1c38			;if FORTH_PARSEV5 
1c38			;	FORTH_END_BUFFER: equ 0 
1c38			;else 
1c38			FORTH_END_BUFFER: equ 127 
1c38			;endif 
1c38			 
1c38			FORTH_TRUE: equ 1 
1c38			FORTH_FALSE: equ 0 
1c38			 
1c38			if FORTH_PARSEV4 
1c38			include "forth_stackops.asm" 
1c38			endif 
1c38			 
1c38			if FORTH_PARSEV5 
1c38			include "forth_stackopsv5.asm" 
1c38			 
1c38			; Stack operations for v5 parser on wards 
1c38			; * DATA stack 
1c38			; * LOOP stack 
1c38			; * RETURN stack 
1c38			 
1c38			 
1c38			 
1c38			FORTH_CHK_DSP_UNDER: macro 
1c38				push hl 
1c38				push de 
1c38				ld hl,(cli_data_sp) 
1c38				ld de, cli_data_stack 
1c38				call cmp16 
1c38				jp c, fault_dsp_under 
1c38				pop de 
1c38				pop hl 
1c38				endm 
1c38			 
1c38			 
1c38			FORTH_CHK_RSP_UNDER: macro 
1c38				push hl 
1c38				push de 
1c38				ld hl,(cli_ret_sp) 
1c38				ld de, cli_ret_stack 
1c38				call cmp16 
1c38				jp c, fault_rsp_under 
1c38				pop de 
1c38				pop hl 
1c38				endm 
1c38			 
1c38			FORTH_CHK_LOOP_UNDER: macro 
1c38				push hl 
1c38				push de 
1c38				ld hl,(cli_loop_sp) 
1c38				ld de, cli_loop_stack 
1c38				call cmp16 
1c38				jp c, fault_loop_under 
1c38				pop de 
1c38				pop hl 
1c38				endm 
1c38			 
1c38			FORTH_ERR_TOS_NOTSTR: macro 
1c38				; TOSO might need more for checks when used 
1c38				push af 
1c38				ld a,(hl) 
1c38				cp DS_TYPE_STR 
1c38				jp nz, type_faultn   
1c38				pop af 
1c38				endm 
1c38			 
1c38			FORTH_ERR_TOS_NOTNUM: macro 
1c38				push af 
1c38				ld a,(hl) 
1c38				cp DS_TYPE_INUM 
1c38				jp nz, type_faultn   
1c38				pop af 
1c38				endm 
1c38			 
1c38			 
1c38			; increase data stack pointer and save hl to it 
1c38				 
1c38			FORTH_DSP_NEXT: macro 
1c38				call macro_forth_dsp_next 
1c38				endm 
1c38			 
1c38			 
1c38			macro_forth_dsp_next: 
1c38				if DEBUG_FORTH_STACK_GUARD 
1c38 cd 67 63				call check_stacks 
1c3b				endif 
1c3b e5				push hl 
1c3c d5				push de 
1c3d eb				ex de,hl 
1c3e 2a 0a f8			ld hl,(cli_data_sp) 
1c41 23				inc hl 
1c42 23				inc hl 
1c43			 
1c43			; PARSEV5 
1c43 23				inc hl 
1c44 22 0a f8			ld (cli_data_sp),hl 
1c47 73				ld (hl), e 
1c48 23				inc hl 
1c49 72				ld (hl), d 
1c4a d1				pop de 
1c4b e1				pop hl 
1c4c				if DEBUG_FORTH_STACK_GUARD 
1c4c cd 67 63				call check_stacks 
1c4f				endif 
1c4f c9				ret 
1c50			 
1c50			 
1c50			; increase ret stack pointer and save hl to it 
1c50				 
1c50			FORTH_RSP_NEXT: macro 
1c50				call macro_forth_rsp_next 
1c50				endm 
1c50			 
1c50			macro_forth_rsp_next: 
1c50				if DEBUG_FORTH_STACK_GUARD 
1c50 cd 67 63				call check_stacks 
1c53				endif 
1c53 e5				push hl 
1c54 d5				push de 
1c55 eb				ex de,hl 
1c56 2a 0e f8			ld hl,(cli_ret_sp) 
1c59 23				inc hl 
1c5a 23				inc hl 
1c5b 22 0e f8			ld (cli_ret_sp),hl 
1c5e 73				ld (hl), e 
1c5f 23				inc hl 
1c60 72				ld (hl), d 
1c61 d1				pop de 
1c62 e1				pop hl 
1c63				if DEBUG_FORTH_STACK_GUARD 
1c63 cd 67 63				call check_stacks 
1c66				endif 
1c66 c9				ret 
1c67			 
1c67			; get current ret stack pointer and save to hl  
1c67				 
1c67			FORTH_RSP_TOS: macro 
1c67				call macro_forth_rsp_tos 
1c67				endm 
1c67			 
1c67			macro_forth_rsp_tos: 
1c67				;push de 
1c67 2a 0e f8			ld hl,(cli_ret_sp) 
1c6a cd a2 1c			call loadhlptrtohl 
1c6d				;ld e, (hl) 
1c6d				;inc hl 
1c6d				;ld d, (hl) 
1c6d				;ex de, hl 
1c6d					if DEBUG_FORTH_WORDS 
1c6d			;			DMARK "RST" 
1c6d						CALLMONITOR 
1c6d cd 19 17			call break_point_state  
1c70				endm  
# End of macro CALLMONITOR
1c70					endif 
1c70				;pop de 
1c70 c9				ret 
1c71			 
1c71			; pop ret stack pointer 
1c71				 
1c71			FORTH_RSP_POP: macro 
1c71				call macro_forth_rsp_pop 
1c71				endm 
1c71			 
1c71			 
1c71			macro_forth_rsp_pop: 
1c71				if DEBUG_FORTH_STACK_GUARD 
1c71			;		DMARK "RPP" 
1c71 cd 67 63				call check_stacks 
1c74					FORTH_CHK_RSP_UNDER 
1c74 e5				push hl 
1c75 d5				push de 
1c76 2a 0e f8			ld hl,(cli_ret_sp) 
1c79 11 88 f7			ld de, cli_ret_stack 
1c7c cd 27 0d			call cmp16 
1c7f da 7b 64			jp c, fault_rsp_under 
1c82 d1				pop de 
1c83 e1				pop hl 
1c84				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c84				endif 
1c84 e5				push hl 
1c85 2a 0e f8			ld hl,(cli_ret_sp) 
1c88			 
1c88			 
1c88				if FORTH_ENABLE_FREE 
1c88			 
1c88					; get pointer 
1c88			 
1c88					push de 
1c88					push hl 
1c88			 
1c88					ld e, (hl) 
1c88					inc hl 
1c88					ld d, (hl) 
1c88			 
1c88					ex de, hl 
1c88					call free 
1c88			 
1c88					pop hl 
1c88					pop de 
1c88			 
1c88			 
1c88				endif 
1c88			 
1c88			 
1c88 2b				dec hl 
1c89 2b				dec hl 
1c8a 22 0e f8			ld (cli_ret_sp), hl 
1c8d				; do stack underflow checks 
1c8d e1				pop hl 
1c8e				if DEBUG_FORTH_STACK_GUARD 
1c8e cd 67 63				call check_stacks 
1c91					FORTH_CHK_RSP_UNDER 
1c91 e5				push hl 
1c92 d5				push de 
1c93 2a 0e f8			ld hl,(cli_ret_sp) 
1c96 11 88 f7			ld de, cli_ret_stack 
1c99 cd 27 0d			call cmp16 
1c9c da 7b 64			jp c, fault_rsp_under 
1c9f d1				pop de 
1ca0 e1				pop hl 
1ca1				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ca1				endif 
1ca1 c9				ret 
1ca2			 
1ca2			 
1ca2			 
1ca2			; routine to load word pointed to by hl into hl 
1ca2			 
1ca2			loadhlptrtohl: 
1ca2			 
1ca2 d5				push de 
1ca3 5e				ld e, (hl) 
1ca4 23				inc hl 
1ca5 56				ld d, (hl) 
1ca6 eb				ex de, hl 
1ca7 d1				pop de 
1ca8			 
1ca8 c9				ret 
1ca9			 
1ca9			 
1ca9			 
1ca9			 
1ca9			 
1ca9			; push a number held in HL onto the data stack 
1ca9			; entry point for pushing a value when already in hl used in function above 
1ca9			 
1ca9			forth_push_numhl: 
1ca9			 
1ca9 e5				push hl    ; save value to push 
1caa			 
1caa			if DEBUG_FORTH_PUSH 
1caa				; see if disabled 
1caa			 
1caa			 
1caa f5				push af 
1cab 3a 0e ee			ld a, (os_view_disable) 
1cae fe 2a			cp '*' 
1cb0 28 34			jr z, .pskip2 
1cb2 e5				push hl 
1cb3 e5			push hl 
1cb4 cd d5 0a			call clear_display 
1cb7 e1			pop hl 
1cb8 7c				ld a,h 
1cb9 21 22 f1			ld hl, os_word_scratch 
1cbc cd 0a 10			call hexout 
1cbf e1				pop hl 
1cc0 7d				ld a,l 
1cc1 21 24 f1			ld hl, os_word_scratch+2 
1cc4 cd 0a 10			call hexout 
1cc7			 
1cc7 21 26 f1			ld hl, os_word_scratch+4 
1cca 3e 00			ld a,0 
1ccc 77				ld (hl),a 
1ccd 11 22 f1			ld de,os_word_scratch 
1cd0 3e 28				ld a, display_row_2 
1cd2 cd e8 0a				call str_at_display 
1cd5 11 75 52			ld de, .push_num 
1cd8 3e 00			ld a, display_row_1 
1cda			 
1cda cd e8 0a				call str_at_display 
1cdd			 
1cdd			 
1cdd cd f8 0a			call update_display 
1ce0 cd 55 0a			call delay1s 
1ce3 cd 55 0a			call delay1s 
1ce6			.pskip2:  
1ce6			 
1ce6 f1				pop af 
1ce7			endif	 
1ce7			 
1ce7			 
1ce7				FORTH_DSP_NEXT 
1ce7 cd 38 1c			call macro_forth_dsp_next 
1cea				endm 
# End of macro FORTH_DSP_NEXT
1cea			 
1cea 2a 0a f8			ld hl, (cli_data_sp) 
1ced			 
1ced				; save item type 
1ced 3e 02			ld a,  DS_TYPE_INUM 
1cef 77				ld (hl), a 
1cf0 23				inc hl 
1cf1			 
1cf1				; get word off stack 
1cf1 d1				pop de 
1cf2 7b				ld a,e 
1cf3 77				ld (hl), a 
1cf4 23				inc hl 
1cf5 7a				ld a,d 
1cf6 77				ld (hl), a 
1cf7			 
1cf7			if DEBUG_FORTH_PUSH 
1cf7 2b				dec hl 
1cf8 2b				dec hl 
1cf9 2b				dec hl 
1cfa						DMARK "PH5" 
1cfa f5				push af  
1cfb 3a 0f 1d			ld a, (.dmark)  
1cfe 32 77 fb			ld (debug_mark),a  
1d01 3a 10 1d			ld a, (.dmark+1)  
1d04 32 78 fb			ld (debug_mark+1),a  
1d07 3a 11 1d			ld a, (.dmark+2)  
1d0a 32 79 fb			ld (debug_mark+2),a  
1d0d 18 03			jr .pastdmark  
1d0f ..			.dmark: db "PH5"  
1d12 f1			.pastdmark: pop af  
1d13			endm  
# End of macro DMARK
1d13				CALLMONITOR 
1d13 cd 19 17			call break_point_state  
1d16				endm  
# End of macro CALLMONITOR
1d16			endif	 
1d16			 
1d16 c9				ret 
1d17			 
1d17			 
1d17			; Push a string to stack pointed to by hl 
1d17			 
1d17			forth_push_str: 
1d17			 
1d17			if DEBUG_FORTH_PUSH 
1d17						DMARK "PSQ" 
1d17 f5				push af  
1d18 3a 2c 1d			ld a, (.dmark)  
1d1b 32 77 fb			ld (debug_mark),a  
1d1e 3a 2d 1d			ld a, (.dmark+1)  
1d21 32 78 fb			ld (debug_mark+1),a  
1d24 3a 2e 1d			ld a, (.dmark+2)  
1d27 32 79 fb			ld (debug_mark+2),a  
1d2a 18 03			jr .pastdmark  
1d2c ..			.dmark: db "PSQ"  
1d2f f1			.pastdmark: pop af  
1d30			endm  
# End of macro DMARK
1d30				CALLMONITOR 
1d30 cd 19 17			call break_point_state  
1d33				endm  
# End of macro CALLMONITOR
1d33			endif	 
1d33			    
1d33 e5				push hl 
1d34 e5				push hl 
1d35			 
1d35			;	ld a, 0   ; find end of string 
1d35 cd 67 11			call strlenz 
1d38			if DEBUG_FORTH_PUSH 
1d38						DMARK "PQ2" 
1d38 f5				push af  
1d39 3a 4d 1d			ld a, (.dmark)  
1d3c 32 77 fb			ld (debug_mark),a  
1d3f 3a 4e 1d			ld a, (.dmark+1)  
1d42 32 78 fb			ld (debug_mark+1),a  
1d45 3a 4f 1d			ld a, (.dmark+2)  
1d48 32 79 fb			ld (debug_mark+2),a  
1d4b 18 03			jr .pastdmark  
1d4d ..			.dmark: db "PQ2"  
1d50 f1			.pastdmark: pop af  
1d51			endm  
# End of macro DMARK
1d51				CALLMONITOR 
1d51 cd 19 17			call break_point_state  
1d54				endm  
# End of macro CALLMONITOR
1d54			endif	 
1d54 eb				ex de, hl 
1d55 e1				pop hl   ; get ptr to start of string 
1d56			if DEBUG_FORTH_PUSH 
1d56						DMARK "PQ3" 
1d56 f5				push af  
1d57 3a 6b 1d			ld a, (.dmark)  
1d5a 32 77 fb			ld (debug_mark),a  
1d5d 3a 6c 1d			ld a, (.dmark+1)  
1d60 32 78 fb			ld (debug_mark+1),a  
1d63 3a 6d 1d			ld a, (.dmark+2)  
1d66 32 79 fb			ld (debug_mark+2),a  
1d69 18 03			jr .pastdmark  
1d6b ..			.dmark: db "PQ3"  
1d6e f1			.pastdmark: pop af  
1d6f			endm  
# End of macro DMARK
1d6f				CALLMONITOR 
1d6f cd 19 17			call break_point_state  
1d72				endm  
# End of macro CALLMONITOR
1d72			endif	 
1d72 19				add hl,de 
1d73			if DEBUG_FORTH_PUSH 
1d73						DMARK "PQE" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 77 fb			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 78 fb			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 79 fb			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "PQE"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c				CALLMONITOR 
1d8c cd 19 17			call break_point_state  
1d8f				endm  
# End of macro CALLMONITOR
1d8f			endif	 
1d8f			 
1d8f 2b				dec hl    ; see if there is an optional trailing double quote 
1d90 7e				ld a,(hl) 
1d91 fe 22			cp '"' 
1d93 20 03			jr nz, .strnoq 
1d95 3e 00			ld a, 0      ; get rid of double quote 
1d97 77				ld (hl), a 
1d98 23			.strnoq: inc hl 
1d99			 
1d99 3e 00			ld a, 0 
1d9b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d9c			 
1d9c 13				inc de ; add one for the type string 
1d9d 13				inc de ; add one for null term??? 
1d9e			 
1d9e				; tos is get string pointer again 
1d9e				; de contains space to allocate 
1d9e				 
1d9e d5				push de 
1d9f			 
1d9f eb				ex de, hl 
1da0			 
1da0				;push af 
1da0			 
1da0			if DEBUG_FORTH_PUSH 
1da0						DMARK "PHm" 
1da0 f5				push af  
1da1 3a b5 1d			ld a, (.dmark)  
1da4 32 77 fb			ld (debug_mark),a  
1da7 3a b6 1d			ld a, (.dmark+1)  
1daa 32 78 fb			ld (debug_mark+1),a  
1dad 3a b7 1d			ld a, (.dmark+2)  
1db0 32 79 fb			ld (debug_mark+2),a  
1db3 18 03			jr .pastdmark  
1db5 ..			.dmark: db "PHm"  
1db8 f1			.pastdmark: pop af  
1db9			endm  
# End of macro DMARK
1db9				CALLMONITOR 
1db9 cd 19 17			call break_point_state  
1dbc				endm  
# End of macro CALLMONITOR
1dbc			endif	 
1dbc cd d0 11			call malloc	; on ret hl now contains allocated memory 
1dbf				if DEBUG_FORTH_MALLOC_GUARD 
1dbf cc cd 52				call z,malloc_error 
1dc2				endif 
1dc2			 
1dc2				 
1dc2 c1				pop bc    ; get length 
1dc3 d1				pop de   ;  get string start    
1dc4			 
1dc4				; hl has destination from malloc 
1dc4			 
1dc4 eb				ex de, hl    ; prep for ldir 
1dc5			 
1dc5 d5				push de   ; save malloc area for DSP later 
1dc6				;push hl   ; save malloc area for DSP later 
1dc6			 
1dc6			if DEBUG_FORTH_PUSH 
1dc6						DMARK "PHc" 
1dc6 f5				push af  
1dc7 3a db 1d			ld a, (.dmark)  
1dca 32 77 fb			ld (debug_mark),a  
1dcd 3a dc 1d			ld a, (.dmark+1)  
1dd0 32 78 fb			ld (debug_mark+1),a  
1dd3 3a dd 1d			ld a, (.dmark+2)  
1dd6 32 79 fb			ld (debug_mark+2),a  
1dd9 18 03			jr .pastdmark  
1ddb ..			.dmark: db "PHc"  
1dde f1			.pastdmark: pop af  
1ddf			endm  
# End of macro DMARK
1ddf				CALLMONITOR 
1ddf cd 19 17			call break_point_state  
1de2				endm  
# End of macro CALLMONITOR
1de2			endif	 
1de2			 
1de2			 
1de2 ed b0			ldir 
1de4			 
1de4			 
1de4				; push malloc to data stack     macro?????  
1de4			 
1de4				FORTH_DSP_NEXT 
1de4 cd 38 1c			call macro_forth_dsp_next 
1de7				endm 
# End of macro FORTH_DSP_NEXT
1de7			 
1de7				; save value and type 
1de7			 
1de7 2a 0a f8			ld hl, (cli_data_sp) 
1dea			 
1dea				; save item type 
1dea 3e 01			ld a,  DS_TYPE_STR 
1dec 77				ld (hl), a 
1ded 23				inc hl 
1dee			 
1dee				; get malloc word off stack 
1dee d1				pop de 
1def 73				ld (hl), e 
1df0 23				inc hl 
1df1 72				ld (hl), d 
1df2			 
1df2			 
1df2			 
1df2			if DEBUG_FORTH_PUSH 
1df2 2a 0a f8			ld hl, (cli_data_sp) 
1df5						DMARK "PHS" 
1df5 f5				push af  
1df6 3a 0a 1e			ld a, (.dmark)  
1df9 32 77 fb			ld (debug_mark),a  
1dfc 3a 0b 1e			ld a, (.dmark+1)  
1dff 32 78 fb			ld (debug_mark+1),a  
1e02 3a 0c 1e			ld a, (.dmark+2)  
1e05 32 79 fb			ld (debug_mark+2),a  
1e08 18 03			jr .pastdmark  
1e0a ..			.dmark: db "PHS"  
1e0d f1			.pastdmark: pop af  
1e0e			endm  
# End of macro DMARK
1e0e				CALLMONITOR 
1e0e cd 19 17			call break_point_state  
1e11				endm  
# End of macro CALLMONITOR
1e11			;	ex de,hl 
1e11			endif	 
1e11				; in case of spaces, skip the ptr past the copied string 
1e11				;pop af 
1e11				;ld (cli_origptr),hl 
1e11			 
1e11 c9				ret 
1e12			 
1e12			 
1e12			 
1e12			; TODO ascii push input onto stack given hl to start of input 
1e12			 
1e12			; identify type 
1e12			; if starts with a " then a string 
1e12			; otherwise it is a number 
1e12			;  
1e12			; if a string 
1e12			;     scan for ending " to get length of string to malloc for + 1 
1e12			;     malloc 
1e12			;     put pointer to string on stack first byte flags as string 
1e12			; 
1e12			; else a number 
1e12			;    look for number format identifier 
1e12			;    $xx hex 
1e12			;    %xxxxx bin 
1e12			;    xxxxx decimal 
1e12			;    convert number to 16bit word.  
1e12			;    malloc word + 1 with flag to identiy as num 
1e12			;    put pointer to number on stack 
1e12			;   
1e12			;  
1e12			  
1e12			forth_apush: 
1e12				; kernel push 
1e12			 
1e12			if DEBUG_FORTH_PUSH 
1e12						DMARK "PSH" 
1e12 f5				push af  
1e13 3a 27 1e			ld a, (.dmark)  
1e16 32 77 fb			ld (debug_mark),a  
1e19 3a 28 1e			ld a, (.dmark+1)  
1e1c 32 78 fb			ld (debug_mark+1),a  
1e1f 3a 29 1e			ld a, (.dmark+2)  
1e22 32 79 fb			ld (debug_mark+2),a  
1e25 18 03			jr .pastdmark  
1e27 ..			.dmark: db "PSH"  
1e2a f1			.pastdmark: pop af  
1e2b			endm  
# End of macro DMARK
1e2b				CALLMONITOR 
1e2b cd 19 17			call break_point_state  
1e2e				endm  
# End of macro CALLMONITOR
1e2e			endif	 
1e2e				; identify input type 
1e2e			 
1e2e 7e				ld a,(hl) 
1e2f fe 22			cp '"' 
1e31 28 0a			jr z, .fapstr 
1e33 fe 24			cp '$' 
1e35 ca 5d 1e			jp z, .faphex 
1e38 fe 25			cp '%' 
1e3a ca 45 1e			jp z, .fapbin 
1e3d			;	cp 'b' 
1e3d			;	jp z, .fabin 
1e3d				; else decimal 
1e3d			 
1e3d				; TODO do decimal conversion 
1e3d				; decimal is stored as a 16bit word 
1e3d			 
1e3d				; by default everything is a string if type is not detected 
1e3d			.fapstr: ; 
1e3d fe 22			cp '"' 
1e3f 20 01			jr nz, .strnoqu 
1e41 23				inc hl 
1e42			.strnoqu: 
1e42 c3 17 1d			jp forth_push_str 
1e45			 
1e45			 
1e45			 
1e45			.fapbin:    ; push a binary string.  
1e45 11 00 00			ld de, 0   ; hold a 16bit value 
1e48			 
1e48 23			.fapbinshift:	inc hl  
1e49 7e				ld a,(hl) 
1e4a fe 00			cp 0     ; done scanning  
1e4c 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e4e			 
1e4e				; left shift de 
1e4e eb				ex de, hl	 
1e4f 29				add hl, hl 
1e50			 
1e50				; is 1 
1e50 fe 31			cp '1' 
1e52 20 02			jr nz, .binzero 
1e54 cb 4d			bit 1, l 
1e56			.binzero: 
1e56 eb				ex de, hl	 ; save current de 
1e57 18 ef			jr .fapbinshift 
1e59			 
1e59			.fapbdone: 
1e59 eb				ex de, hl 
1e5a c3 a9 1c			jp forth_push_numhl 
1e5d			 
1e5d			 
1e5d			.faphex:   ; hex is always stored as a 16bit word 
1e5d				; skip number prefix 
1e5d 23				inc hl 
1e5e				; turn ascii into number 
1e5e cd c0 10			call get_word_hl	; ret 16bit word in hl 
1e61			 
1e61 c3 a9 1c			jp forth_push_numhl 
1e64			 
1e64 00				 nop 
1e65			 
1e65			.fabin:   ; TODO bin conversion 
1e65			 
1e65			 
1e65 c9				ret 
1e66			 
1e66			 
1e66			; get either a string ptr or a 16bit word from the data stack 
1e66			 
1e66			FORTH_DSP: macro 
1e66				call macro_forth_dsp 
1e66				endm 
1e66			 
1e66			macro_forth_dsp: 
1e66				; data stack pointer points to current word on tos 
1e66			 
1e66 2a 0a f8			ld hl,(cli_data_sp) 
1e69			 
1e69				if DEBUG_FORTH_PUSH 
1e69						DMARK "DSP" 
1e69 f5				push af  
1e6a 3a 7e 1e			ld a, (.dmark)  
1e6d 32 77 fb			ld (debug_mark),a  
1e70 3a 7f 1e			ld a, (.dmark+1)  
1e73 32 78 fb			ld (debug_mark+1),a  
1e76 3a 80 1e			ld a, (.dmark+2)  
1e79 32 79 fb			ld (debug_mark+2),a  
1e7c 18 03			jr .pastdmark  
1e7e ..			.dmark: db "DSP"  
1e81 f1			.pastdmark: pop af  
1e82			endm  
# End of macro DMARK
1e82			 
1e82 cd 02 53				call display_data_sp 
1e85				;call break_point_state 
1e85				;rst 030h 
1e85				CALLMONITOR 
1e85 cd 19 17			call break_point_state  
1e88				endm  
# End of macro CALLMONITOR
1e88				endif 
1e88			 
1e88 c9				ret 
1e89			 
1e89			; return hl to start of value on stack 
1e89			 
1e89			FORTH_DSP_VALUE: macro 
1e89				call macro_forth_dsp_value 
1e89				endm 
1e89			 
1e89			macro_forth_dsp_value: 
1e89			 
1e89				FORTH_DSP 
1e89 cd 66 1e			call macro_forth_dsp 
1e8c				endm 
# End of macro FORTH_DSP
1e8c			 
1e8c d5				push de 
1e8d			 
1e8d 23				inc hl ; skip type 
1e8e			 
1e8e 5e				ld e, (hl) 
1e8f 23				inc hl 
1e90 56				ld d, (hl) 
1e91 eb				ex de,hl  
1e92			 
1e92 d1				pop de 
1e93			 
1e93 c9				ret 
1e94			 
1e94			; return hl to start of value to second item on stack 
1e94			 
1e94			FORTH_DSP_VALUEM1: macro 
1e94				call macro_forth_dsp_value_m1 
1e94				endm 
1e94			 
1e94			macro_forth_dsp_value_m1: 
1e94			 
1e94				FORTH_DSP 
1e94 cd 66 1e			call macro_forth_dsp 
1e97				endm 
# End of macro FORTH_DSP
1e97			 
1e97 2b				dec hl 
1e98 2b				dec hl 
1e99			;	dec hl 
1e99			 
1e99 d5				push de 
1e9a			 
1e9a 5e				ld e, (hl) 
1e9b 23				inc hl 
1e9c 56				ld d, (hl) 
1e9d eb				ex de,hl  
1e9e			 
1e9e d1				pop de 
1e9f			 
1e9f c9				ret 
1ea0			 
1ea0				 
1ea0			 
1ea0			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ea0			 
1ea0			FORTH_DSP_POP: macro 
1ea0				call macro_forth_dsp_pop 
1ea0				endm 
1ea0			 
1ea0			 
1ea0			; get the tos data type 
1ea0			 
1ea0			FORTH_DSP_TYPE:   macro 
1ea0			 
1ea0				;FORTH_DSP_VALUE 
1ea0				FORTH_DSP 
1ea0				 
1ea0				; hl points to value 
1ea0				; check type 
1ea0			 
1ea0				ld a,(hl) 
1ea0			 
1ea0				endm 
1ea0			 
1ea0			; load the tos value into hl 
1ea0			 
1ea0			 
1ea0			FORTH_DSP_VALUEHL:  macro 
1ea0				call macro_dsp_valuehl 
1ea0				endm 
1ea0			 
1ea0			 
1ea0			 
1ea0			macro_dsp_valuehl: 
1ea0				FORTH_DSP_VALUE 
1ea0 cd 89 1e			call macro_forth_dsp_value 
1ea3				endm 
# End of macro FORTH_DSP_VALUE
1ea3			 
1ea3				;FORTH_ERR_TOS_NOTNUM 
1ea3			 
1ea3				;inc hl   ; skip type id 
1ea3			 
1ea3			;	push de 
1ea3			; 
1ea3			;	ld e, (hl) 
1ea3			;	inc hl 
1ea3			;	ld d, (hl) 
1ea3			;	ex de,hl  
1ea3			 
1ea3			;	pop de 
1ea3			 
1ea3				if DEBUG_FORTH_PUSH 
1ea3						DMARK "DVL" 
1ea3 f5				push af  
1ea4 3a b8 1e			ld a, (.dmark)  
1ea7 32 77 fb			ld (debug_mark),a  
1eaa 3a b9 1e			ld a, (.dmark+1)  
1ead 32 78 fb			ld (debug_mark+1),a  
1eb0 3a ba 1e			ld a, (.dmark+2)  
1eb3 32 79 fb			ld (debug_mark+2),a  
1eb6 18 03			jr .pastdmark  
1eb8 ..			.dmark: db "DVL"  
1ebb f1			.pastdmark: pop af  
1ebc			endm  
# End of macro DMARK
1ebc				CALLMONITOR 
1ebc cd 19 17			call break_point_state  
1ebf				endm  
# End of macro CALLMONITOR
1ebf				endif 
1ebf c9				ret 
1ec0			 
1ec0			forth_apushstrhl:      
1ec0				; push of string requires use of cli_origptr 
1ec0				; bodge use 
1ec0			 
1ec0				; get current cli_origptr, save, update with temp pointer  
1ec0 ed 5b 26 f8		ld de, (cli_origptr) 
1ec4 22 26 f8			ld (cli_origptr), hl 
1ec7 d5				push de 
1ec8 cd 12 1e			call forth_apush 
1ecb d1				pop de 
1ecc ed 53 26 f8		ld (cli_origptr), de 
1ed0 c9			        ret	 
1ed1			 
1ed1			 
1ed1			; increase loop stack pointer and save hl to it 
1ed1				 
1ed1			FORTH_LOOP_NEXT: macro 
1ed1				call macro_forth_loop_next 
1ed1				;nop 
1ed1				endm 
1ed1			 
1ed1			macro_forth_loop_next: 
1ed1				if DEBUG_FORTH_STACK_GUARD 
1ed1 cd 67 63				call check_stacks 
1ed4				endif 
1ed4 e5				push hl 
1ed5 d5				push de 
1ed6 eb				ex de,hl 
1ed7 2a 0c f8			ld hl,(cli_loop_sp) 
1eda 23				inc hl 
1edb 23				inc hl 
1edc					if DEBUG_FORTH_WORDS 
1edc						DMARK "LNX" 
1edc f5				push af  
1edd 3a f1 1e			ld a, (.dmark)  
1ee0 32 77 fb			ld (debug_mark),a  
1ee3 3a f2 1e			ld a, (.dmark+1)  
1ee6 32 78 fb			ld (debug_mark+1),a  
1ee9 3a f3 1e			ld a, (.dmark+2)  
1eec 32 79 fb			ld (debug_mark+2),a  
1eef 18 03			jr .pastdmark  
1ef1 ..			.dmark: db "LNX"  
1ef4 f1			.pastdmark: pop af  
1ef5			endm  
# End of macro DMARK
1ef5						CALLMONITOR 
1ef5 cd 19 17			call break_point_state  
1ef8				endm  
# End of macro CALLMONITOR
1ef8					endif 
1ef8 22 0c f8			ld (cli_loop_sp),hl 
1efb 73				ld (hl), e 
1efc 23				inc hl 
1efd 72				ld (hl), d 
1efe d1				pop de    ; been reversed so save a swap on restore 
1eff e1				pop hl 
1f00				if DEBUG_FORTH_STACK_GUARD 
1f00 cd 67 63				call check_stacks 
1f03				endif 
1f03 c9				ret 
1f04			 
1f04			; get current ret stack pointer and save to hl  
1f04				 
1f04			FORTH_LOOP_TOS: macro 
1f04				call macro_forth_loop_tos 
1f04				endm 
1f04			 
1f04			macro_forth_loop_tos: 
1f04 d5				push de 
1f05 2a 0c f8			ld hl,(cli_loop_sp) 
1f08 5e				ld e, (hl) 
1f09 23				inc hl 
1f0a 56				ld d, (hl) 
1f0b eb				ex de, hl 
1f0c d1				pop de 
1f0d c9				ret 
1f0e			 
1f0e			; pop loop stack pointer 
1f0e				 
1f0e			FORTH_LOOP_POP: macro 
1f0e				call macro_forth_loop_pop 
1f0e				endm 
1f0e			 
1f0e			 
1f0e			macro_forth_loop_pop: 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e					DMARK "LPP" 
1f0e f5				push af  
1f0f 3a 23 1f			ld a, (.dmark)  
1f12 32 77 fb			ld (debug_mark),a  
1f15 3a 24 1f			ld a, (.dmark+1)  
1f18 32 78 fb			ld (debug_mark+1),a  
1f1b 3a 25 1f			ld a, (.dmark+2)  
1f1e 32 79 fb			ld (debug_mark+2),a  
1f21 18 03			jr .pastdmark  
1f23 ..			.dmark: db "LPP"  
1f26 f1			.pastdmark: pop af  
1f27			endm  
# End of macro DMARK
1f27 cd 67 63				call check_stacks 
1f2a					FORTH_CHK_LOOP_UNDER 
1f2a e5				push hl 
1f2b d5				push de 
1f2c 2a 0c f8			ld hl,(cli_loop_sp) 
1f2f 11 86 f5			ld de, cli_loop_stack 
1f32 cd 27 0d			call cmp16 
1f35 da 81 64			jp c, fault_loop_under 
1f38 d1				pop de 
1f39 e1				pop hl 
1f3a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f3a				endif 
1f3a e5				push hl 
1f3b 2a 0c f8			ld hl,(cli_loop_sp) 
1f3e 2b				dec hl 
1f3f 2b				dec hl 
1f40 22 0c f8			ld (cli_loop_sp), hl 
1f43				; TODO do stack underflow checks 
1f43 e1				pop hl 
1f44				if DEBUG_FORTH_STACK_GUARD 
1f44 cd 67 63				call check_stacks 
1f47					FORTH_CHK_LOOP_UNDER 
1f47 e5				push hl 
1f48 d5				push de 
1f49 2a 0c f8			ld hl,(cli_loop_sp) 
1f4c 11 86 f5			ld de, cli_loop_stack 
1f4f cd 27 0d			call cmp16 
1f52 da 81 64			jp c, fault_loop_under 
1f55 d1				pop de 
1f56 e1				pop hl 
1f57				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f57				endif 
1f57 c9				ret 
1f58			 
1f58			macro_forth_dsp_pop: 
1f58			 
1f58 e5				push hl 
1f59			 
1f59				; release malloc data 
1f59			 
1f59				if DEBUG_FORTH_STACK_GUARD 
1f59 cd 67 63				call check_stacks 
1f5c					FORTH_CHK_DSP_UNDER 
1f5c e5				push hl 
1f5d d5				push de 
1f5e 2a 0a f8			ld hl,(cli_data_sp) 
1f61 11 84 f3			ld de, cli_data_stack 
1f64 cd 27 0d			call cmp16 
1f67 da 75 64			jp c, fault_dsp_under 
1f6a d1				pop de 
1f6b e1				pop hl 
1f6c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6c				endif 
1f6c				;ld hl,(cli_data_sp) 
1f6c			if DEBUG_FORTH_DOT 
1f6c				DMARK "DPP" 
1f6c				CALLMONITOR 
1f6c			endif	 
1f6c			 
1f6c			 
1f6c			if FORTH_ENABLE_DSPPOPFREE 
1f6c			 
1f6c				FORTH_DSP 
1f6c cd 66 1e			call macro_forth_dsp 
1f6f				endm 
# End of macro FORTH_DSP
1f6f			 
1f6f 7e				ld a, (hl) 
1f70 fe 01			cp DS_TYPE_STR 
1f72 20 07			jr nz, .skippopfree 
1f74			 
1f74				FORTH_DSP_VALUEHL 
1f74 cd a0 1e			call macro_dsp_valuehl 
1f77				endm 
# End of macro FORTH_DSP_VALUEHL
1f77 00				nop 
1f78			if DEBUG_FORTH_DOT 
1f78				DMARK "DPf" 
1f78				CALLMONITOR 
1f78			endif	 
1f78 cd 9a 12			call free 
1f7b			.skippopfree: 
1f7b				 
1f7b			 
1f7b			endif 
1f7b			 
1f7b			if DEBUG_FORTH_DOT_KEY 
1f7b				DMARK "DP2" 
1f7b				CALLMONITOR 
1f7b			endif	 
1f7b			 
1f7b				; move pointer down 
1f7b			 
1f7b 2a 0a f8			ld hl,(cli_data_sp) 
1f7e 2b				dec hl 
1f7f 2b				dec hl 
1f80			; PARSEV5 
1f80 2b				dec hl 
1f81 22 0a f8			ld (cli_data_sp), hl 
1f84			 
1f84				if DEBUG_FORTH_STACK_GUARD 
1f84 cd 67 63				call check_stacks 
1f87					FORTH_CHK_DSP_UNDER 
1f87 e5				push hl 
1f88 d5				push de 
1f89 2a 0a f8			ld hl,(cli_data_sp) 
1f8c 11 84 f3			ld de, cli_data_stack 
1f8f cd 27 0d			call cmp16 
1f92 da 75 64			jp c, fault_dsp_under 
1f95 d1				pop de 
1f96 e1				pop hl 
1f97				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f97				endif 
1f97			 
1f97 e1				pop hl 
1f98			 
1f98 c9				ret 
1f99			 
1f99			getwordathl: 
1f99				; hl points to an address 
1f99				; load hl with the word at that address 
1f99			 
1f99 d5				push de 
1f9a			 
1f9a 5e				ld e, (hl) 
1f9b 23				inc hl 
1f9c 56				ld d, (hl) 
1f9d eb				ex de, hl 
1f9e			 
1f9e d1				pop de 
1f9f c9				ret 
1fa0			 
1fa0			 
1fa0			 
1fa0			 
1fa0			 
1fa0			; eof 
1fa0			 
# End of file forth_stackopsv5.asm
1fa0			endif 
1fa0			 
1fa0			user_word_eol:  
1fa0				; hl contains the pointer to where to create a linked list item from the end 
1fa0				; of the user dict to continue on at the system word dict 
1fa0				 
1fa0				; poke the stub of the word list linked list to repoint to rom words 
1fa0			 
1fa0				; stub format 
1fa0				; db   word id 
1fa0				; dw    link to next word 
1fa0			        ; db char length of token 
1fa0				; db string + 0 term 
1fa0				; db exec code....  
1fa0			 
1fa0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fa2 77				ld (hl), a		; word id 
1fa3 23				inc hl 
1fa4			 
1fa4 11 6a 21			ld de, sysdict 
1fa7 73				ld (hl), e		; next word link ie system dict 
1fa8 23				inc hl 
1fa9 72				ld (hl), d		; next word link ie system dict 
1faa 23				inc hl	 
1fab			 
1fab			;	ld (hl), sysdict		; next word link ie system dict 
1fab			;	inc hl 
1fab			;	inc hl 
1fab			 
1fab			;	inc hl 
1fab			;	inc hl 
1fab			 
1fab 3e 02			ld a, 2			; word length is 0 
1fad 77				ld (hl), a	 
1fae 23				inc hl 
1faf			 
1faf 3e 7e			ld a, '~'			; word length is 0 
1fb1 77				ld (hl), a	 
1fb2 23				inc hl 
1fb3 3e 00			ld a, 0			; save empty word 
1fb5 77				ld (hl), a 
1fb6			 
1fb6 c9				ret 
1fb7			 
1fb7				 
1fb7			 
1fb7			forthexec_cleanup: 
1fb7				FORTH_RSP_POP 
1fb7 cd 71 1c			call macro_forth_rsp_pop 
1fba				endm 
# End of macro FORTH_RSP_POP
1fba c9				ret 
1fbb			 
1fbb			forth_call_hl: 
1fbb				; taking hl 
1fbb e5				push hl 
1fbc c9				ret 
1fbd			 
1fbd			; this is called to reset Forth system but keep existing uwords etc 
1fbd			 
1fbd			forth_warmstart: 
1fbd				; setup stack over/under flow checks 
1fbd				if DEBUG_FORTH_STACK_GUARD 
1fbd cd 4d 63				call chk_stk_init 
1fc0				endif 
1fc0			 
1fc0				; init stack pointers  - * these stacks go upwards *  
1fc0 21 88 f7			ld hl, cli_ret_stack 
1fc3 22 0e f8			ld (cli_ret_sp), hl	 
1fc6				; set bottom of stack 
1fc6 3e 00			ld a,0 
1fc8 77				ld (hl),a 
1fc9 23				inc hl 
1fca 77				ld (hl),a 
1fcb			 
1fcb 21 84 f3			ld hl, cli_data_stack 
1fce 22 0a f8			ld (cli_data_sp), hl	 
1fd1				; set bottom of stack 
1fd1 3e 00			ld a,0 
1fd3 77				ld (hl),a 
1fd4 23				inc hl 
1fd5 77				ld (hl),a 
1fd6			 
1fd6 21 86 f5			ld hl, cli_loop_stack 
1fd9 22 0c f8			ld (cli_loop_sp), hl	 
1fdc				; set bottom of stack 
1fdc 3e 00			ld a,0 
1fde 77				ld (hl),a 
1fdf 23				inc hl 
1fe0 77				ld (hl),a 
1fe1			 
1fe1				; init extent of current open file 
1fe1			 
1fe1 3e 00			ld a, 0 
1fe3 32 59 f8			ld (store_openext), a 
1fe6			 
1fe6 c9				ret 
1fe7			 
1fe7			 
1fe7			; Cold Start - this is called to setup the whole Forth system 
1fe7			 
1fe7			forth_init: 
1fe7			 
1fe7				; setup stack over/under flow checks 
1fe7			 
1fe7			;	if DEBUG_FORTH_STACK_GUARD 
1fe7			;		call chk_stk_init 
1fe7			;	endif 
1fe7			 
1fe7				; enable auto display updates (slow.....) 
1fe7			 
1fe7 3e 01			ld a, 1 
1fe9 32 24 f8			ld (cli_autodisplay), a 
1fec			 
1fec			 
1fec			 
1fec				; show start up screen 
1fec			 
1fec cd d5 0a			call clear_display 
1fef			 
1fef 3e 00			ld a,0 
1ff1 32 46 f8			ld (f_cursor_ptr), a 
1ff4			 
1ff4				; set start of word list in start of ram - for use when creating user words 
1ff4			 
1ff4 21 00 80			ld hl, baseram 
1ff7 22 1a f1			ld (os_last_new_uword), hl 
1ffa cd a0 1f			call user_word_eol 
1ffd				 
1ffd			;		call display_data_sp 
1ffd			;		call next_page_prompt 
1ffd			 
1ffd			 
1ffd			 
1ffd			 
1ffd c9				ret 
1ffe			 
1ffe .. 00		.bootforth: db " Forth Kernel Init ",0 
2012			 
2012			; TODO push to stack 
2012			 
2012			;  
2012			 
2012			if FORTH_PARSEV2 
2012			 
2012			 
2012				include "forth_parserv2.asm" 
2012			 
2012			endif 
2012			 
2012			 
2012			; parse cli version 1 
2012			 
2012			if FORTH_PARSEV1 
2012			 
2012			 
2012			 
2012			      include "forth_parserv1.asm" 
2012			endif 
2012				 
2012			if FORTH_PARSEV3 
2012			 
2012			 
2012			 
2012			      include "forth_parserv3.asm" 
2012				include "forth_wordsv3.asm" 
2012			endif 
2012			 
2012			if FORTH_PARSEV4 
2012			 
2012			 
2012			 
2012			      include "forth_parserv4.asm" 
2012				include "forth_wordsv4.asm" 
2012			endif 
2012			 
2012			if FORTH_PARSEV5 
2012			 
2012			 
2012			 
2012			      include "forth_parserv5.asm" 
2012			 
2012			 
2012			; A better parser without using malloc and string copies all over the place.  
2012			; Exec in situ should be faster 
2012			 
2012			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2012			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2012			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2012			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2012			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2012			WORD_SYS_END: equ 0   ; Opcode for all user words 
2012			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2012			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2012			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2012			 
2012			; Core word preamble macro 
2012			 
2012			CWHEAD:   macro nxtword opcode lit len opflags 
2012				db WORD_SYS_CORE+opcode             
2012				; internal op code number 
2012				dw nxtword            
2012				; link to next dict word block 
2012				db len + 1 
2012				; literal length of dict word inc zero term 
2012				db lit,0              
2012				; literal dict word 
2012			        ; TODO db opflags        
2012				endm 
2012			 
2012			 
2012			NEXTW: macro  
2012				jp macro_next 
2012				endm 
2012			 
2012			macro_next: 
2012			if DEBUG_FORTH_PARSE_KEY 
2012				DMARK "NXT" 
2012				CALLMONITOR 
2012			endif	 
2012			;	inc hl  ; skip token null term  
2012 ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2016 ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
201a 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
201d			if DEBUG_FORTH_PARSE_KEY 
201d				DMARK "}AA" 
201d				CALLMONITOR 
201d			endif	 
201d c3 20 21			jp execnext 
2020				;jp exec1 
2020			       
2020			 
2020			 
2020			; Another go at the parser to compile  
2020			 
2020			 
2020			; TODO rework parser to change all of the string words to byte tokens 
2020			; TODO do a search for  
2020			 
2020			; TODO first run normal parser to zero term sections 
2020			; TODO for each word do a token look up to get the op code 
2020			; TODO need some means to flag to the exec that this is a byte code form    
2020			 
2020			 
2020			forthcompile: 
2020			 
2020			; 
2020			; line parse: 
2020			;       parse raw input buffer 
2020			;       tokenise the words 
2020			;       malloc new copy (for looping etc) 
2020			;       copy to malloc + current pc in line to start of string and add line term 
2020			;       save on new rsp 
2020			; 
2020			 
2020			; hl to point to the line to tokenise 
2020			 
2020			;	push hl 
2020 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2023			 
2023			;	ld a,0		; string term on input 
2023			;	call strlent 
2023			 
2023			;	ld (os_tok_len), hl	 ; save string length 
2023			 
2023			;if DEBUG_FORTH_TOK 
2023			;	ex de,hl		 
2023			;endif 
2023			 
2023			;	pop hl 		; get back string pointer 
2023			 
2023			if DEBUG_FORTH_TOK 
2023						DMARK "TOc" 
2023				CALLMONITOR 
2023			endif 
2023 7e			.cptoken2:    ld a,(hl) 
2024 23				inc hl 
2025 fe 7f			cp FORTH_END_BUFFER 
2027 28 29			jr z, .cptokendone2 
2029 fe 00			cp 0 
202b 28 25			jr z, .cptokendone2 
202d fe 22			cp '"' 
202f 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2031 fe 20			cp ' ' 
2033 20 ee			jr nz,  .cptoken2 
2035			 
2035			; TODO consume comments held between ( and ) 
2035			 
2035				; we have a space so change to zero term for dict match later 
2035 2b				dec hl 
2036 3e 00			ld a,0 
2038 77				ld (hl), a 
2039 23				inc hl 
203a 18 e7			jr .cptoken2 
203c				 
203c			 
203c			.cptokenstr2: 
203c				; skip all white space until either eol (because forgot to term) or end double quote 
203c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
203c				;inc hl ; skip current double quote 
203c 7e				ld a,(hl) 
203d 23				inc hl 
203e fe 22			cp '"' 
2040 28 e1			jr z, .cptoken2 
2042 fe 7f			cp FORTH_END_BUFFER 
2044 28 0c			jr z, .cptokendone2 
2046 fe 00			cp 0 
2048 28 08			jr z, .cptokendone2 
204a fe 20			cp ' ' 
204c 28 02			jr z, .cptmp2 
204e 18 ec			jr .cptokenstr2 
2050			 
2050			.cptmp2:	; we have a space so change to zero term for dict match later 
2050				;dec hl 
2050				;ld a,"-"	; TODO remove this when working 
2050				;ld (hl), a 
2050				;inc hl 
2050 18 ea			jr .cptokenstr2 
2052			 
2052			.cptokendone2: 
2052				;inc hl 
2052 3e 7f			ld a, FORTH_END_BUFFER 
2054 77				ld (hl),a 
2055 23				inc hl 
2056 3e 21			ld a, '!' 
2058 77				ld (hl),a 
2059			 
2059 2a 1e f1			ld hl,(os_tok_ptr) 
205c			         
205c			if DEBUG_FORTH_TOK 
205c						DMARK "Tc1" 
205c				CALLMONITOR 
205c			endif 
205c			 
205c				; push exec string to top of return stack 
205c				FORTH_RSP_NEXT 
205c cd 50 1c			call macro_forth_rsp_next 
205f				endm 
# End of macro FORTH_RSP_NEXT
205f c9				ret 
2060			 
2060			; Another go at the parser need to simplify the process 
2060			 
2060			forthparse: 
2060			 
2060			; 
2060			; line parse: 
2060			;       parse raw input buffer 
2060			;       tokenise the words 
2060			;       malloc new copy (for looping etc) 
2060			;       copy to malloc + current pc in line to start of string and add line term 
2060			;       save on new rsp 
2060			; 
2060			 
2060			; hl to point to the line to tokenise 
2060			 
2060			;	push hl 
2060 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2063			 
2063			;	ld a,0		; string term on input 
2063			;	call strlent 
2063			 
2063			;	ld (os_tok_len), hl	 ; save string length 
2063			 
2063			;if DEBUG_FORTH_TOK 
2063			;	ex de,hl		 
2063			;endif 
2063			 
2063			;	pop hl 		; get back string pointer 
2063			 
2063			if DEBUG_FORTH_TOK 
2063						DMARK "TOK" 
2063				CALLMONITOR 
2063			endif 
2063 7e			.ptoken2:    ld a,(hl) 
2064 23				inc hl 
2065 fe 7f			cp FORTH_END_BUFFER 
2067 28 29			jr z, .ptokendone2 
2069 fe 00			cp 0 
206b 28 25			jr z, .ptokendone2 
206d fe 22			cp '"' 
206f 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2071 fe 20			cp ' ' 
2073 20 ee			jr nz,  .ptoken2 
2075			 
2075			; TODO consume comments held between ( and ) 
2075			 
2075				; we have a space so change to zero term for dict match later 
2075 2b				dec hl 
2076 3e 00			ld a,0 
2078 77				ld (hl), a 
2079 23				inc hl 
207a 18 e7			jr .ptoken2 
207c				 
207c			 
207c			.ptokenstr2: 
207c				; skip all white space until either eol (because forgot to term) or end double quote 
207c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
207c				;inc hl ; skip current double quote 
207c 7e				ld a,(hl) 
207d 23				inc hl 
207e fe 22			cp '"' 
2080 28 e1			jr z, .ptoken2 
2082 fe 7f			cp FORTH_END_BUFFER 
2084 28 0c			jr z, .ptokendone2 
2086 fe 00			cp 0 
2088 28 08			jr z, .ptokendone2 
208a fe 20			cp ' ' 
208c 28 02			jr z, .ptmp2 
208e 18 ec			jr .ptokenstr2 
2090			 
2090			.ptmp2:	; we have a space so change to zero term for dict match later 
2090				;dec hl 
2090				;ld a,"-"	; TODO remove this when working 
2090				;ld (hl), a 
2090				;inc hl 
2090 18 ea			jr .ptokenstr2 
2092			 
2092			.ptokendone2: 
2092				;inc hl 
2092 3e 7f			ld a, FORTH_END_BUFFER 
2094 77				ld (hl),a 
2095 23				inc hl 
2096 3e 21			ld a, '!' 
2098 77				ld (hl),a 
2099			 
2099 2a 1e f1			ld hl,(os_tok_ptr) 
209c			         
209c			if DEBUG_FORTH_TOK 
209c						DMARK "TK1" 
209c				CALLMONITOR 
209c			endif 
209c			 
209c				; push exec string to top of return stack 
209c				FORTH_RSP_NEXT 
209c cd 50 1c			call macro_forth_rsp_next 
209f				endm 
# End of macro FORTH_RSP_NEXT
209f c9				ret 
20a0			 
20a0			; 
20a0			;	; malloc size + buffer pointer + if is loop flag 
20a0			;	ld hl,(os_tok_len) 		 ; get string length 
20a0			; 
20a0			;	ld a,l 
20a0			; 
20a0			;	cp 0			; we dont want to use a null string 
20a0			;	ret z 
20a0			; 
20a0			;;	add 3    ; prefix malloc with buffer for current word ptr 
20a0			; 
20a0			;	add 5     ; TODO when certain not over writing memory remove 
20a0			; 
20a0			;		 
20a0			; 
20a0			;if DEBUG_FORTH_TOK 
20a0			;			DMARK "TKE" 
20a0			;	CALLMONITOR 
20a0			;endif 
20a0			; 
20a0			;	ld l,a 
20a0			;	ld h,0 
20a0			;;	push hl   ; save required space for the copy later 
20a0			;	call malloc 
20a0			;if DEBUG_FORTH_TOK 
20a0			;			DMARK "TKM" 
20a0			;	CALLMONITOR 
20a0			;endif 
20a0			;	if DEBUG_FORTH_MALLOC_GUARD 
20a0			;		push af 
20a0			;		call ishlzero 
20a0			;;		ld a, l 
20a0			;;		add h 
20a0			;;		cp 0 
20a0			;		pop af 
20a0			;		 
20a0			;		call z,malloc_error 
20a0			;	endif 
20a0			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20a0			; 
20a0			; 
20a0			;if DEBUG_FORTH_TOK 
20a0			;			DMARK "TKR" 
20a0			;	CALLMONITOR 
20a0			;endif 
20a0			; 
20a0			;	FORTH_RSP_NEXT 
20a0			; 
20a0			;	;inc hl	 ; go past current buffer pointer 
20a0			;	;inc hl 
20a0			;	;inc hl   ; and past if loop flag 
20a0			;		; TODO Need to set flag  
20a0			; 
20a0			;	 
20a0			;	 
20a0			;	ex de,hl	; malloc is dest 
20a0			;	ld hl, (os_tok_len) 
20a0			;;	pop bc 
20a0			;	ld c, l                
20a0			;	ld b,0 
20a0			;	ld hl, (os_tok_ptr) 
20a0			; 
20a0			;if DEBUG_FORTH_TOK 
20a0			;			DMARK "TKT" 
20a0			;	CALLMONITOR 
20a0			;endif 
20a0			; 
20a0			;	; do str cpy 
20a0			; 
20a0			;	ldir      ; copy byte in hl to de 
20a0			; 
20a0			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20a0			; 
20a0			;if DEBUG_FORTH_TOK 
20a0			; 
20a0			;			DMARK "TKY" 
20a0			;	CALLMONITOR 
20a0			;endif 
20a0			;	;ld a,0 
20a0			;	;ld a,FORTH_END_BUFFER 
20a0			;	ex de, hl 
20a0			;	;dec hl			 ; go back over the space delim at the end of word 
20a0			;	;ld (hl),a 
20a0			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20a0			;	ld a,FORTH_END_BUFFER 
20a0			;	ld (hl),a 
20a0			;	inc hl 
20a0			;	ld a,FORTH_END_BUFFER 
20a0			;	ld (hl),a 
20a0			; 
20a0			;	; init the malloc area data 
20a0			;	; set pc for in current area 
20a0			;	;ld hl, (os_tok_malloc) 
20a0			;	;inc hl 
20a0			;	;inc hl 
20a0			;	;inc hl 
20a0			;	;ex de,hl 
20a0			;	;ld hl, (os_tok_malloc) 
20a0			;	;ld (hl),e 
20a0			;	;inc hl 
20a0			;	;ld (hl),d 
20a0			; 
20a0			; 
20a0			;	ld hl,(os_tok_malloc) 
20a0			;if DEBUG_FORTH_PARSE_KEY 
20a0			;			DMARK "TKU" 
20a0			;	CALLMONITOR 
20a0			;endif 
20a0			; 
20a0			;	ret 
20a0			 
20a0			forthexec: 
20a0			 
20a0			; line exec: 
20a0			; forth parser 
20a0			 
20a0			; 
20a0			;       get current exec line on rsp 
20a0			 
20a0				FORTH_RSP_TOS 
20a0 cd 67 1c			call macro_forth_rsp_tos 
20a3				endm 
# End of macro FORTH_RSP_TOS
20a3			 
20a3			;       restore current pc - hl points to malloc of data 
20a3			 
20a3				;ld e, (hl) 
20a3				;inc hl 
20a3				;ld d, (hl) 
20a3				;ex de,hl 
20a3			 
20a3			 
20a3			exec1: 
20a3 22 1e f1			ld (os_tok_ptr), hl 
20a6			 
20a6				; copy our PC to working vars  
20a6 22 28 f8			ld (cli_ptr), hl 
20a9 22 26 f8			ld (cli_origptr), hl 
20ac			 
20ac 7e				ld a,(hl) 
20ad fe 7f			cp FORTH_END_BUFFER 
20af c8				ret z 
20b0			 
20b0				; skip any nulls 
20b0			 
20b0 fe 00			cp 0 
20b2 20 03			jr nz, .execword 
20b4 23				inc hl 
20b5 18 ec			jr exec1 
20b7			 
20b7			 
20b7			.execword: 
20b7			 
20b7			 
20b7			 
20b7			if DEBUG_FORTH_PARSE_KEY 
20b7						DMARK "KYQ" 
20b7				CALLMONITOR 
20b7			endif 
20b7			;       while at start of word: 
20b7			; get start of dict (in user area first) 
20b7			 
20b7 21 00 80		ld hl, baseram 
20ba			;ld hl, sysdict 
20ba 22 2a f8		ld (cli_nextword),hl 
20bd			;           match word at pc 
20bd			;           exec word 
20bd			;           or push to dsp 
20bd			;           forward to next token 
20bd			;           if line term pop rsp and exit 
20bd			;        
20bd			 
20bd			if DEBUG_FORTH_PARSE_KEY 
20bd						DMARK "KYq" 
20bd				CALLMONITOR 
20bd			endif 
20bd			 
20bd			; 
20bd			; word comp 
20bd			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20bd			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20bd			;    move to start of word  
20bd			;    compare word to cli_token 
20bd			 
20bd			.execpnword:	; HL at start of a word in the dictionary to check 
20bd			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20bd			;	ld (cli_ptr), hl 
20bd			 
20bd 2a 2a f8			ld hl,(cli_nextword) 
20c0			 
20c0 cd 63 21			call forth_tok_next 
20c3			; tok next start here 
20c3			;	; TODO skip compiled symbol for now 
20c3			;	inc hl 
20c3			; 
20c3			;	; save pointer to next word 
20c3			; 
20c3			;	; hl now points to the address of the next word pointer  
20c3			;	ld e, (hl) 
20c3			;	inc hl 
20c3			;	ld d, (hl) 
20c3			;	inc l 
20c3			; 
20c3			;	ex de,hl 
20c3			;if DEBUG_FORTH_PARSE_NEXTWORD 
20c3			;	push bc 
20c3			;	ld bc, (cli_nextword) 
20c3			;			DMARK "NXW" 
20c3			;	CALLMONITOR 
20c3			;	pop bc 
20c3			;endif 
20c3			; tok next end here 
20c3 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
20c6 eb				ex de, hl 
20c7			 
20c7			 
20c7				; save the pointer of the current token - 1 to check against 
20c7				 
20c7 22 2e f8			ld (cli_token), hl   
20ca				; TODO maybe remove below save if no debug 
20ca				; save token string ptr for any debug later 
20ca 23				inc hl  
20cb 22 30 f8			ld (cli_origtoken), hl 
20ce 2b				dec hl 
20cf				; save pointer to the start of the next dictionay word 
20cf 7e				ld a,(hl)   ; get string length 
20d0 47				ld b,a 
20d1			.execpnwordinc:  
20d1 23				inc hl 
20d2 10 fd			djnz .execpnwordinc 
20d4 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
20d7			 
20d7				; now check the word token against the string being parsed 
20d7			 
20d7 2a 2e f8			ld hl,(cli_token) 
20da 23				inc hl     ; skip string length (use zero term instead to end) 
20db 22 2e f8			ld (cli_token), hl 
20de			 
20de			if DEBUG_FORTH_PARSE_KEY 
20de						DMARK "KY2" 
20de			endif 
20de			if DEBUG_FORTH_PARSE_EXEC 
20de				; see if disabled 
20de			 
20de				ld a, (os_view_disable) 
20de				cp '*' 
20de				jr z, .skip 
20de			 
20de				push hl 
20de				push hl 
20de				call clear_display 
20de				ld de, .compword 
20de				ld a, display_row_1 
20de				call str_at_display 
20de				pop de 
20de				ld a, display_row_2 
20de				call str_at_display 
20de				ld hl,(cli_ptr) 
20de				ld a,(hl) 
20de			        ld hl, os_word_scratch 
20de				ld (hl),a 
20de				ld a,0 
20de				inc hl 
20de				ld (hl),a 	 
20de				ld de, os_word_scratch 
20de				ld a, display_row_2+10 
20de				call str_at_display 
20de				call update_display 
20de				ld a, 100 
20de				call aDelayInMS 
20de				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20de				call delay250ms 
20de				endif 
20de				pop hl 
20de			.skip:  
20de			endif	 
20de			.execpnchar:    ; compare char between token and string to parse 
20de			 
20de			if DEBUG_FORTH_PARSE_KEY 
20de						DMARK "Ky3" 
20de			endif 
20de			if DEBUG_FORTH_PARSE_EXEC 
20de				; see if disabled 
20de			 
20de				ld a, (os_view_disable) 
20de				cp '*' 
20de				jr z, .skip2 
20de			 
20de			;	call clear_display 
20de			ld hl,(cli_token) 
20de			ld a,(hl) 
20de			ld (os_word_scratch),a 
20de				ld hl,(cli_ptr) 
20de			ld a,(hl) 
20de				ld (os_word_scratch+1),a 
20de				ld a,0 
20de				ld (os_word_scratch+2),a 
20de				ld de,os_word_scratch 
20de				ld a,display_row_4 
20de				call str_at_display 
20de				call update_display 
20de			.skip2:  
20de			endif 
20de 2a 2e f8			ld hl,(cli_token) 
20e1 7e				ld a, (hl)	 ; char in word token 
20e2 23				inc hl 		; move to next char 
20e3 22 2e f8			ld (cli_token), hl ; and save it 
20e6 47				ld b,a 
20e7			 
20e7 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
20ea 7e				ld a,(hl) 
20eb 23				inc hl 
20ec 22 28 f8			ld (cli_ptr), hl		; move to next char 
20ef cd 5e 11			call toUpper 		; make sure the input string matches case 
20f2			 
20f2			if DEBUG_FORTH_PARSE 
20f2			endif 
20f2			 
20f2				; input stream end of token is a space so get rid of it 
20f2			 
20f2			;	cp ' ' 
20f2			;	jr nz, .pnskipspace 
20f2			; 
20f2			;	ld a, 0		; make same term as word token term 
20f2			; 
20f2			;.pnskipspace: 
20f2			 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "KY7" 
20f2			endif 
20f2 b8				cp b 
20f3 c2 09 21			jp nz, .execpnskipword	 ; no match so move to next word 
20f6				 
20f6			;    if same 
20f6			;       scan for string terms 0 for token and 32 for input 
20f6			 
20f6				 
20f6			if DEBUG_FORTH_PARSE_KEY 
20f6						DMARK "KY8" 
20f6			endif 
20f6			 
20f6 80				add b			 
20f7 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20f9							; TODO need to make sure last word in zero term string is accounted for 
20f9 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20fb			 
20fb			 
20fb				; at end of both strings so both are exact match 
20fb			 
20fb			;       skip ptr for next word 
20fb			 
20fb 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
20fe 23				inc hl			 ; at next char 
20ff 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
2102 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2105				 
2105				 
2105			if DEBUG_FORTH_PARSE_KEY 
2105						DMARK "KY3" 
2105			endif 
2105			 
2105			 
2105			 
2105			;       exec code block 
2105			if DEBUG_FORTH_JP 
2105				call clear_display 
2105				call update_display 
2105				call delay1s 
2105				ld hl, (cli_execword)     ; save for next check if no match on this word 
2105				ld a,h 
2105				ld hl, os_word_scratch 
2105				call hexout 
2105				ld hl, (cli_execword)     ; save for next check if no match on this word 
2105				ld a,l 
2105				ld hl, os_word_scratch+2 
2105				call hexout 
2105				ld hl, os_word_scratch+4 
2105				ld a,0 
2105				ld (hl),a 
2105				ld de,os_word_scratch 
2105				call str_at_display 
2105					ld a, display_row_2 
2105					call str_at_display 
2105				ld de, (cli_origtoken) 
2105				ld a, display_row_1+10 
2105					call str_at_display 
2105			 
2105				ld a,display_row_1 
2105				ld de, .foundword 
2105				ld a, display_row_3 
2105				call str_at_display 
2105				call update_display 
2105				call delay1s 
2105				call delay1s 
2105				call delay1s 
2105			endif 
2105			 
2105			if DEBUG_FORTH_PARSE_KEY 
2105						DMARK "KYj" 
2105			endif 
2105				; TODO save the word pointer in this exec 
2105			 
2105 2a 2c f8			ld hl,(cli_execword) 
2108 e9				jp (hl) 
2109			 
2109			 
2109			;    if not same 
2109			;	scan for zero term 
2109			;	get ptr for next word 
2109			;	goto word comp 
2109			 
2109			.execpnskipword:	; get pointer to next word 
2109 2a 2a f8			ld hl,(cli_nextword) 
210c			 
210c 7e				ld a,(hl) 
210d fe 00			cp WORD_SYS_END 
210f			;	cp 0 
210f 28 09			jr z, .execendofdict			 ; at end of words 
2111			 
2111			if DEBUG_FORTH_PARSE_KEY 
2111						DMARK "KY4" 
2111			endif 
2111			if DEBUG_FORTH_PARSE_EXEC 
2111			 
2111				; see if disabled 
2111			 
2111				ld a, (os_view_disable) 
2111				cp '*' 
2111				jr z, .noskip 
2111			 
2111			 
2111				ld de, .nowordfound 
2111				ld a, display_row_3 
2111				call str_at_display 
2111				call update_display 
2111				ld a, 100 
2111				call aDelayInMS 
2111				 
2111				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2111					call delay250ms 
2111				endif 
2111			.noskip:  
2111			 
2111			endif	 
2111			 
2111 2a 26 f8			ld hl,(cli_origptr) 
2114 22 28 f8			ld (cli_ptr),hl 
2117			 
2117			if DEBUG_FORTH_PARSE_KEY 
2117						DMARK "KY5" 
2117			endif 
2117 c3 bd 20			jp .execpnword			; else go to next word 
211a			 
211a			.execendofdict:  
211a			 
211a			if DEBUG_FORTH_PARSE_KEY 
211a						DMARK "KYe" 
211a			endif 
211a			if DEBUG_FORTH_PARSE_EXEC 
211a				; see if disabled 
211a			 
211a				ld a, (os_view_disable) 
211a				cp '*' 
211a				jr z, .ispskip 
211a			 
211a				call clear_display 
211a				call update_display 
211a				call delay1s 
211a				ld de, (cli_origptr) 
211a				ld a, display_row_1 
211a				call str_at_display 
211a				 
211a				ld de, .enddict 
211a				ld a, display_row_3 
211a				call str_at_display 
211a				call update_display 
211a				ld a, 100 
211a				call aDelayInMS 
211a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
211a				call delay1s 
211a				call delay1s 
211a				call delay1s 
211a				endif 
211a			.ispskip:  
211a				 
211a			endif	 
211a			 
211a			 
211a			 
211a				; if the word is not a keyword then must be a literal so push it to stack 
211a			 
211a			; push token to stack to end of word 
211a			 
211a				STACKFRAME ON $1efe $2f9f 
211a				if DEBUG_STACK_IMB 
211a					if ON 
211a						exx 
211a						ld de, $1efe 
211a						ld a, d 
211a						ld hl, curframe 
211a						call hexout 
211a						ld a, e 
211a						ld hl, curframe+2 
211a						call hexout 
211a						ld hl, $1efe 
211a						push hl 
211a						ld hl, $2f9f 
211a						push hl 
211a						exx 
211a					endif 
211a				endif 
211a			endm 
# End of macro STACKFRAME
211a			 
211a 2a 1e f1		ld hl,(os_tok_ptr) 
211d cd 12 1e		call forth_apush 
2120			 
2120				STACKFRAMECHK ON $1efe $2f9f 
2120				if DEBUG_STACK_IMB 
2120					if ON 
2120						exx 
2120						ld hl, $2f9f 
2120						pop de   ; $2f9f 
2120						call cmp16 
2120						jr nz, .spnosame 
2120						ld hl, $1efe 
2120						pop de   ; $1efe 
2120						call cmp16 
2120						jr z, .spfrsame 
2120						.spnosame: call showsperror 
2120						.spfrsame: nop 
2120						exx 
2120					endif 
2120				endif 
2120			endm 
# End of macro STACKFRAMECHK
2120			 
2120			execnext: 
2120			 
2120			if DEBUG_FORTH_PARSE_KEY 
2120						DMARK "KY>" 
2120			endif 
2120			; move past token to next word 
2120			 
2120 2a 1e f1		ld hl, (os_tok_ptr) 
2123 3e 00		ld a, 0 
2125 01 ff 00		ld bc, 255     ; input buffer size 
2128 ed b1		cpir 
212a			 
212a			if DEBUG_FORTH_PARSE_KEY 
212a						DMARK "KY!" 
212a				CALLMONITOR 
212a			endif	 
212a			; TODO this might place hl on the null, so will need to forward on??? 
212a			;inc hl   ; see if this gets onto the next item 
212a			 
212a			 
212a			; TODO pass a pointer to the buffer to push 
212a			; TODO call function to push 
212a			 
212a			; look for end of input 
212a			 
212a			;inc hl 
212a			;ld a,(hl) 
212a			;cp FORTH_END_BUFFER 
212a			;ret z 
212a			 
212a			 
212a c3 a3 20		jp exec1 
212d			 
212d			 
212d			 
212d			 
212d			 
212d			 
212d			 
212d			 
212d			 
212d			findnexttok: 
212d			 
212d				; hl is pointer to move 
212d				; de is the token to locate 
212d			 
212d					if DEBUG_FORTH 
212d						DMARK "NTK" 
212d						CALLMONITOR 
212d					endif 
212d d5				push de 
212e			 
212e			.fnt1:	 
212e				; find first char of token to locate 
212e			 
212e 1a				ld a, (de) 
212f 4f				ld c,a 
2130 7e				ld a,(hl) 
2131 cd 5e 11			call toUpper 
2134					if DEBUG_FORTH 
2134						DMARK "NT1" 
2134						CALLMONITOR 
2134					endif 
2134 b9				cp c 
2135			 
2135 28 03			jr z, .fnt2cmpmorefirst	 
2137			 
2137				; first char not found move to next char 
2137			 
2137 23				inc hl 
2138 18 f4			jr .fnt1 
213a			 
213a			.fnt2cmpmorefirst:	 
213a				; first char of token found.  
213a			 
213a e5				push hl     ; save start of token just in case it is the right one 
213b d9				exx 
213c e1				pop hl        ; save it to hl' 
213d d9				exx 
213e			 
213e			 
213e			.fnt2cmpmore:	 
213e				; compare the rest 
213e				 
213e 23				inc hl 
213f 13				inc de 
2140				 
2140 1a				ld a, (de) 
2141 4f				ld c,a 
2142 7e				ld a,(hl) 
2143 cd 5e 11			call toUpper 
2146			 
2146					if DEBUG_FORTH 
2146						DMARK "NT2" 
2146						CALLMONITOR 
2146					endif 
2146				; c has the token to find char 
2146				; a has the mem to scan char 
2146			 
2146 b9				cp c 
2147 28 04			jr z,.fntmatch1 
2149			 
2149				; they are not the same 
2149			 
2149					if DEBUG_FORTH 
2149						DMARK "NT3" 
2149						CALLMONITOR 
2149					endif 
2149 d1				pop de	; reset de token to look for 
214a d5				push de 
214b 18 e1			jr .fnt1 
214d				 
214d			.fntmatch1: 
214d			 
214d				; is the same char a null which means we might have a full hit? 
214d					if DEBUG_FORTH 
214d						DMARK "NT4" 
214d						CALLMONITOR 
214d					endif 
214d			 
214d fe 00			cp 0 
214f 28 0b			jr z, .fntmatchyes 
2151			 
2151				; are we at the end of the token to find? 
2151			 
2151					if DEBUG_FORTH 
2151						DMARK "NT5" 
2151						CALLMONITOR 
2151					endif 
2151 3e 00			ld a, 0 
2153 b9				cp c 
2154			 
2154 c2 3e 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2157			 
2157					if DEBUG_FORTH 
2157						DMARK "NT6" 
2157						CALLMONITOR 
2157					endif 
2157				; token to find is exhusted but no match to stream 
2157			 
2157				; restore tok pointer and continue on 
2157 d1				pop de 
2158 d5				push de 
2159 c3 2e 21			jp .fnt1 
215c			 
215c			 
215c			.fntmatchyes: 
215c			 
215c				; hl now contains the end of the found token 
215c			 
215c				; get rid of saved token pointer to find 
215c			 
215c d1				pop de 
215d			 
215d					if DEBUG_FORTH 
215d						DMARK "NT9" 
215d						CALLMONITOR 
215d					endif 
215d			 
215d				; hl will be on the null term so forward on 
215d			 
215d				; get back the saved start of the token 
215d			 
215d d9				exx 
215e e5				push hl     ; save start of token just in case it is the right one 
215f d9				exx 
2160 e1				pop hl        ; save it to hl 
2161			 
2161 c9				ret 
2162			 
2162			 
2162			; LIST needs to find a specific token   
2162			; FORGET needs to find a spefici token 
2162			 
2162			; SAVE needs to find all tokens by flag 
2162			; WORDS just needs to scan through all  by flag 
2162			; UWORDS needs to scan through all by flag 
2162			 
2162			 
2162			; given hl as pointer to start of dict look up string 
2162			; return hl as pointer to start of word block 
2162			; or 0 if not found 
2162			 
2162			forth_find_tok: 
2162 c9				ret 
2163			 
2163			; given hl as pointer to dict structure 
2163			; move to the next dict block structure 
2163			 
2163			forth_tok_next: 
2163				; hl now points to the address of the next word pointer  
2163				; TODO skip compiled symbol for now 
2163			;	push de 
2163 23				inc hl 
2164 5e				ld e, (hl) 
2165 23				inc hl 
2166 56				ld d, (hl) 
2167 23				inc hl 
2168			 
2168 eb				ex de,hl 
2169			if DEBUG_FORTH_PARSE_NEXTWORD 
2169				push bc 
2169				ld bc, (cli_nextword) 
2169						DMARK "NXW" 
2169				CALLMONITOR 
2169				pop bc 
2169			endif 
2169			;	pop de	 
2169 c9				ret 
216a			 
216a			 
216a			 
216a			; eof 
# End of file forth_parserv5.asm
216a				include "forth_wordsv4.asm" 
216a			 
216a			; the core word dictionary v4 
216a			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
216a			 
216a			; this is a linked list for each of the system words used 
216a			; user defined words will follow the same format but will be in ram 
216a			 
216a			 
216a			; 
216a			; 
216a			; define linked list: 
216a			; 
216a			; 1. compiled byte op code 
216a			; 2. len of text word 
216a			; 3. text word 
216a			; 4. ptr to next dictionary word 
216a			; 5. asm, calls etc for the word 
216a			; 
216a			;  if 1 == 0 then last word in dict  
216a			;   
216a			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
216a			;  
216a			;  
216a			; create basic standard set of words 
216a			; 
216a			;  
216a			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
216a			; 2DUP 2DROP 2SWAP  
216a			; @ C@ - get byte  
216a			; ! C! - store byte 
216a			; 0< true if less than zero 
216a			; 0= true if zero 
216a			; < >  
216a			; = true if same 
216a			; variables 
216a			 
216a			 
216a			; Hardware specific words I may need 
216a			; 
216a			; IN OUT  
216a			; calls to key util functions 
216a			; calls to hardward abstraction stuff 
216a			; easy control of frame buffers and lcd i/o 
216a			; keyboard  
216a			 
216a			 
216a			;DICT: macro 
216a			; op_code, len, word, next 
216a			;    word: 
216a			;    db op_code 
216a			;    ds word zero term 
216a			;    dw next 
216a			;    endm 
216a			 
216a			 
216a			 
216a			 
216a			; op code 1 is a flag for user define words which are to be handled differently 
216a			 
216a			 
216a			; 
216a			; 
216a			;    TODO on entry to a word this should be the expected environment 
216a			;    hl - tos value if number then held, if string this is the ptr 
216a			;    de -  
216a			 
216a			 
216a			; opcode ranges 
216a			; 0 - end of word dict 
216a			; 255 - user define words 
216a			 
216a			sysdict: 
216a			include "forth_opcodes.asm" 
216a			; op codes for forth keywords 
216a			; free to use code 0  
216a				OPCODE_HEAP: equ  1 
216a				OPCODE_EXEC: equ 2 
216a				OPCODE_DUP: equ 3 
216a				OPCODE_SWAP: equ 4 
216a				OPCODE_COLN: equ 5 
216a				OPCODE_SCOLN: equ 6 
216a				OPCODE_DROP: equ 7 
216a				OPCODE_DUP2: equ 8 
216a				OPCODE_DROP2: equ 9 
216a				OPCODE_SWAP2: equ 10 
216a				OPCODE_AT: equ 11 
216a				OPCODE_CAT: equ 12 
216a				OPCODE_BANG: equ 13 
216a				OPCODE_CBANG: equ 14 
216a				OPCODE_SCALL: equ 15 
216a				OPCODE_DEPTH: equ 16 
216a				OPCODE_OVER: equ 17 
216a				OPCODE_PAUSE: equ 18 
216a				OPCODE_PAUSES: equ 19 
216a				OPCODE_ROT: equ 20 
216a			;free to reuse	OPCODE_WORDS: equ 21 
216a			        OPCODE_NOT: equ 21 
216a				OPCODE_UWORDS: equ 22 
216a				OPCODE_BP: equ 23 
216a				OPCODE_MONITOR: equ 24  
216a				OPCODE_MALLOC: equ 25 
216a				OPCODE_FREE: equ 26 
216a				OPCODE_LIST: equ 27 
216a				OPCODE_FORGET: equ 28 
216a				OPCODE_NOP: equ 29 
216a				OPCODE_COMO: equ 30 
216a				OPCODE_COMC: equ 31 
216a			;free to reuse	OPCODE_ENDCORE: equ 32 
216a				OPCODE_AFTERSOUND: equ 33 
216a				OPCODE_GP2: equ 34 
216a				OPCODE_GP3: equ 35 
216a				OPCODE_GP4: equ 36 
216a				OPCODE_SIN: equ 37 
216a				OPCODE_SOUT: equ 38 
216a				OPCODE_SPIO: equ 39 
216a				OPCODE_SPICEH: equ 40 
216a				OPCODE_SPIOb: equ 41 
216a				OPCODE_SPII: equ 42 
216a				OPCODE_SESEL: equ 43 
216a				OPCODE_CARTDEV: equ 44 
216a			; free to reuse	OPCODE_ENDDEVICE: equ 45 
216a				OPCODE_FB: equ 46 
216a				OPCODE_EMIT: equ 47 
216a				OPCODE_DOTH: equ 48 
216a				OPCODE_DOTF: equ 49 
216a				OPCODE_DOT: equ 50 
216a				OPCODE_CLS: equ 51 
216a				OPCODE_DRAW: equ 52 
216a				OPCODE_DUMP: equ 53 
216a				OPCODE_CDUMP: equ 54 
216a				OPCODE_DAT: equ 55 
216a				OPCODE_HOME: equ 56 
216a				OPCODE_SPACE: equ 57 
216a				OPCODE_SPACES: equ 58 
216a				OPCODE_SCROLL: equ 59 
216a				OPCODE_ATQ: equ 60 
216a				OPCODE_AUTODSP: equ 61 
216a				OPCODE_MENU: equ 62 
216a			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
216a				OPCODE_THEN: equ 64 
216a				OPCODE_ELSE: equ 65 
216a				OPCODE_DO: equ 66 
216a				OPCODE_LOOP: equ 67 
216a				OPCODE_I: equ 68 
216a				OPCODE_DLOOP: equ 69  
216a				OPCODE_REPEAT: equ 70  
216a				OPCODE_UNTIL: equ 71 
216a				OPCODE_ENDFLOW: equ 72 
216a				OPCODE_WAITK: equ 73 
216a				OPCODE_ACCEPT: equ 74 
216a				OPCODE_EDIT: equ 75 
216a			;free to reuse	OPCODE_ENDKEY: equ 76 
216a				OPCODE_LZERO: equ 77 
216a				OPCODE_TZERO: equ 78 
216a				OPCODE_LESS: equ 79 
216a				OPCODE_GT: equ 80 
216a				OPCODE_EQUAL: equ 81  
216a			;free to reuse	OPCODE_ENDLOGIC: equ 82 
216a				OPCODE_NEG: equ 83 
216a				OPCODE_DIV: equ 84 
216a				OPCODE_MUL: equ 85 
216a				OPCODE_MIN: equ 86 
216a				OPCODE_MAX: equ 87 
216a				OPCODE_RND16: equ 88 
216a				OPCODE_RND8: equ 89 
216a				OPCODE_RND: equ 90 
216a			;free to reuse	OPCODE_ENDMATHS: equ 91  
216a				OPCODE_BYNAME: equ 92 
216a				OPCODE_DIR: equ 93 
216a				OPCODE_SAVE: equ 94 
216a				OPCODE_LOAD: equ 95 
216a				OPCODE_BSAVE: equ 96 
216a				OPCODE_BLOAD: equ 97 
216a				OPCODE_SEO: equ 98  
216a				OPCODE_SEI: equ 99 
216a				OPCODE_SFREE: equ 100 
216a				OPCODE_SIZE: equ 101 
216a				OPCODE_CREATE: equ 102 
216a				OPCODE_APPEND: equ 103 
216a				OPCODE_SDEL: equ 104 
216a				OPCODE_OPEN: equ 105 
216a				OPCODE_READ: equ 106 
216a				OPCODE_EOF: equ 106 
216a				OPCODE_FORMAT: equ 107 
216a				OPCODE_LABEL: equ 108 
216a				OPCODE_LABELS: equ 109 
216a			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
216a				OPCODE_UPPER: equ 111 
216a				OPCODE_LOWER: equ 112 
216a				OPCODE_SUBSTR: equ 113 
216a				OPCODE_LEFT: equ 114 
216a				OPCODE_RIGHT: equ 115 
216a				OPCODE_STR2NUM: equ 116 
216a				OPCODE_NUM2STR: equ 117 
216a				OPCODE_CONCAT: equ 118 
216a				OPCODE_FIND: equ 119 
216a				OPCODE_LEN: equ 120 
216a				OPCODE_CHAR: equ 121 
216a			; free to reuse	OPCODE_STRLEN: equ 122 
216a			; free to reuse	OPCODE_ENDSTR: equ 123 
216a				OPCODE_V0S: equ 124 
216a				OPCODE_V0Q: equ 125 
216a				OPCODE_V1S: equ 126 
216a				OPCODE_V1Q: equ 127 
216a				OPCODE_V2S: equ 128 
216a				OPCODE_V2Q: equ 129 
216a				OPCODE_V3S: equ 130 
216a				OPCODE_V3Q: equ 131 
216a			;free to reuse	OPCODE_END: equ 132 
216a				OPCODE_ZDUP: equ 133 
216a			 
216a			; eof 
# End of file forth_opcodes.asm
216a			 
216a			include "forth_words_core.asm" 
216a			 
216a			; | ## Core Words 
216a			 
216a			;if MALLOC_4 
216a			 
216a			.HEAP: 
216a				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
216a 15				db WORD_SYS_CORE+OPCODE_HEAP             
216b a9 21			dw .EXEC            
216d 05				db 4 + 1 
216e .. 00			db "HEAP",0              
2173				endm 
# End of macro CWHEAD
2173			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2173			; | | u1 - Current number of bytes in the heap 
2173			; | | u2 - Remaining bytes left on the heap 
2173			; | |  
2173			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2173			 
2173			 
2173					if DEBUG_FORTH_WORDS_KEY 
2173						DMARK "HEP" 
2173 f5				push af  
2174 3a 88 21			ld a, (.dmark)  
2177 32 77 fb			ld (debug_mark),a  
217a 3a 89 21			ld a, (.dmark+1)  
217d 32 78 fb			ld (debug_mark+1),a  
2180 3a 8a 21			ld a, (.dmark+2)  
2183 32 79 fb			ld (debug_mark+2),a  
2186 18 03			jr .pastdmark  
2188 ..			.dmark: db "HEP"  
218b f1			.pastdmark: pop af  
218c			endm  
# End of macro DMARK
218c						CALLMONITOR 
218c cd 19 17			call break_point_state  
218f				endm  
# End of macro CALLMONITOR
218f					endif 
218f 2a 0a 80				ld hl, (free_list )      
2192 11 0e 80				ld de, heap_start 
2195			 
2195 ed 52				sbc hl, de  
2197			 
2197 cd a9 1c				call forth_push_numhl 
219a			 
219a			 
219a ed 5b 0a 80			ld de, (free_list )      
219e 21 03 ee				ld hl, heap_end 
21a1			 
21a1 ed 52				sbc hl, de 
21a3			 
21a3 cd a9 1c				call forth_push_numhl 
21a6					 
21a6			 
21a6					 
21a6			 
21a6			 
21a6			 
21a6					NEXTW 
21a6 c3 12 20			jp macro_next 
21a9				endm 
# End of macro NEXTW
21a9			;endif 
21a9			 
21a9			.EXEC: 
21a9				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21a9 16				db WORD_SYS_CORE+OPCODE_EXEC             
21aa 45 22			dw .STKEXEC            
21ac 05				db 4 + 1 
21ad .. 00			db "EXEC",0              
21b2				endm 
# End of macro CWHEAD
21b2			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
21b2			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21b2			; | | 
21b2			; | |   
21b2				STACKFRAME OFF $5efe $5f9f 
21b2				if DEBUG_STACK_IMB 
21b2					if OFF 
21b2						exx 
21b2						ld de, $5efe 
21b2						ld a, d 
21b2						ld hl, curframe 
21b2						call hexout 
21b2						ld a, e 
21b2						ld hl, curframe+2 
21b2						call hexout 
21b2						ld hl, $5efe 
21b2						push hl 
21b2						ld hl, $5f9f 
21b2						push hl 
21b2						exx 
21b2					endif 
21b2				endif 
21b2			endm 
# End of macro STACKFRAME
21b2			 
21b2					if DEBUG_FORTH_WORDS_KEY 
21b2						DMARK "EXE" 
21b2 f5				push af  
21b3 3a c7 21			ld a, (.dmark)  
21b6 32 77 fb			ld (debug_mark),a  
21b9 3a c8 21			ld a, (.dmark+1)  
21bc 32 78 fb			ld (debug_mark+1),a  
21bf 3a c9 21			ld a, (.dmark+2)  
21c2 32 79 fb			ld (debug_mark+2),a  
21c5 18 03			jr .pastdmark  
21c7 ..			.dmark: db "EXE"  
21ca f1			.pastdmark: pop af  
21cb			endm  
# End of macro DMARK
21cb						CALLMONITOR 
21cb cd 19 17			call break_point_state  
21ce				endm  
# End of macro CALLMONITOR
21ce					endif 
21ce			 
21ce				FORTH_DSP_VALUEHL 
21ce cd a0 1e			call macro_dsp_valuehl 
21d1				endm 
# End of macro FORTH_DSP_VALUEHL
21d1			 
21d1				FORTH_DSP_POP 
21d1 cd 58 1f			call macro_forth_dsp_pop 
21d4				endm 
# End of macro FORTH_DSP_POP
21d4			 
21d4					if DEBUG_FORTH_WORDS 
21d4						DMARK "EX1" 
21d4 f5				push af  
21d5 3a e9 21			ld a, (.dmark)  
21d8 32 77 fb			ld (debug_mark),a  
21db 3a ea 21			ld a, (.dmark+1)  
21de 32 78 fb			ld (debug_mark+1),a  
21e1 3a eb 21			ld a, (.dmark+2)  
21e4 32 79 fb			ld (debug_mark+2),a  
21e7 18 03			jr .pastdmark  
21e9 ..			.dmark: db "EX1"  
21ec f1			.pastdmark: pop af  
21ed			endm  
# End of macro DMARK
21ed						CALLMONITOR 
21ed cd 19 17			call break_point_state  
21f0				endm  
# End of macro CALLMONITOR
21f0					endif 
21f0			;	ld e,(hl) 
21f0			;	inc hl 
21f0			;	ld d,(hl) 
21f0			;	ex de,hl 
21f0			 
21f0			;		if DEBUG_FORTH_WORDS 
21f0			;			DMARK "EX2" 
21f0			;			CALLMONITOR 
21f0			;		endif 
21f0 e5				push hl 
21f1			 
21f1				;ld a, 0 
21f1				;ld a, FORTH_END_BUFFER 
21f1 cd 67 11			call strlenz 
21f4 23				inc hl   ; include zero term to copy 
21f5 23				inc hl   ; include term 
21f6 23				inc hl   ; include term 
21f7 06 00			ld b,0 
21f9 4d				ld c,l 
21fa e1				pop hl 
21fb 11 1c ef			ld de, execscratch 
21fe					if DEBUG_FORTH_WORDS 
21fe						DMARK "EX3" 
21fe f5				push af  
21ff 3a 13 22			ld a, (.dmark)  
2202 32 77 fb			ld (debug_mark),a  
2205 3a 14 22			ld a, (.dmark+1)  
2208 32 78 fb			ld (debug_mark+1),a  
220b 3a 15 22			ld a, (.dmark+2)  
220e 32 79 fb			ld (debug_mark+2),a  
2211 18 03			jr .pastdmark  
2213 ..			.dmark: db "EX3"  
2216 f1			.pastdmark: pop af  
2217			endm  
# End of macro DMARK
2217						CALLMONITOR 
2217 cd 19 17			call break_point_state  
221a				endm  
# End of macro CALLMONITOR
221a					endif 
221a ed b0			ldir 
221c			 
221c			 
221c 21 1c ef			ld hl, execscratch 
221f			 
221f					if DEBUG_FORTH_WORDS 
221f						DMARK "EXe" 
221f f5				push af  
2220 3a 34 22			ld a, (.dmark)  
2223 32 77 fb			ld (debug_mark),a  
2226 3a 35 22			ld a, (.dmark+1)  
2229 32 78 fb			ld (debug_mark+1),a  
222c 3a 36 22			ld a, (.dmark+2)  
222f 32 79 fb			ld (debug_mark+2),a  
2232 18 03			jr .pastdmark  
2234 ..			.dmark: db "EXe"  
2237 f1			.pastdmark: pop af  
2238			endm  
# End of macro DMARK
2238						CALLMONITOR 
2238 cd 19 17			call break_point_state  
223b				endm  
# End of macro CALLMONITOR
223b					endif 
223b			 
223b cd 60 20			call forthparse 
223e cd a0 20			call forthexec 
2241			;	call forthexec_cleanup 
2241			;	call forthparse 
2241			;	call forthexec 
2241			 
2241				STACKFRAMECHK OFF $5efe $5f9f 
2241				if DEBUG_STACK_IMB 
2241					if OFF 
2241						exx 
2241						ld hl, $5f9f 
2241						pop de   ; $5f9f 
2241						call cmp16 
2241						jr nz, .spnosame 
2241						ld hl, $5efe 
2241						pop de   ; $5efe 
2241						call cmp16 
2241						jr z, .spfrsame 
2241						.spnosame: call showsperror 
2241						.spfrsame: nop 
2241						exx 
2241					endif 
2241				endif 
2241			endm 
# End of macro STACKFRAMECHK
2241			 
2241				; an immediate word so no need to process any more words 
2241 c9				ret 
2242				NEXTW 
2242 c3 12 20			jp macro_next 
2245				endm 
# End of macro NEXTW
2245			 
2245			; dead code - old version  
2245			;	FORTH_RSP_NEXT 
2245			 
2245			;  
2245			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2245			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2245			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2245			;	push hl 
2245			;	push de 
2245			;	push bc 
2245			; 
2245			; 
2245			;		if DEBUG_FORTH_WORDS_KEY 
2245			;			DMARK "EXR" 
2245			;			CALLMONITOR 
2245			;		endif 
2245			; 
2245			; 
2245			; 
2245			;	;v5 FORTH_DSP_VALUE 
2245			;	FORTH_DSP_VALUEHL 
2245			; 
2245			;	; TODO do string type checks 
2245			; 
2245			;;v5	inc hl   ; skip type 
2245			; 
2245			;	push hl  ; source code  
2245			;		if DEBUG_FORTH_WORDS 
2245			;			DMARK "EX1" 
2245			;			CALLMONITOR 
2245			;		endif 
2245			;	ld a, 0 
2245			;	call strlent 
2245			; 
2245			;	inc hl 
2245			;	inc hl 
2245			;	inc hl 
2245			;	inc hl 
2245			; 
2245			;	push hl    ; size 
2245			; 
2245			;		if DEBUG_FORTH_WORDS 
2245			;			DMARK "EX2" 
2245			;			CALLMONITOR 
2245			;		endif 
2245			;	call malloc 
2245			; 
2245			;	ex de, hl    ; de now contains malloc area 
2245			;	pop bc   	; get byte count 
2245			;	pop hl      ; get string to copy 
2245			; 
2245			;	push de     ; save malloc for free later 
2245			; 
2245			;		if DEBUG_FORTH_WORDS 
2245			;			DMARK "EX3" 
2245			;			CALLMONITOR 
2245			;		endif 
2245			;	ldir       ; duplicate string 
2245			; 
2245			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2245			;	 
2245			;	; TODO fix the parse would be better than this...  
2245			;	ex de, hl 
2245			;	dec hl 
2245			;	ld a, 0 
2245			;	ld (hl), a 
2245			;	dec hl 
2245			;	ld a, ' ' 
2245			;	ld (hl), a 
2245			;	dec hl 
2245			;	ld (hl), a 
2245			; 
2245			;	dec hl 
2245			;	ld (hl), a 
2245			; 
2245			; 
2245			;	FORTH_DSP_POP  
2245			; 
2245			;	pop hl     
2245			;	push hl    ; save malloc area 
2245			; 
2245			;		if DEBUG_FORTH_WORDS 
2245			;			DMARK "EX4" 
2245			;			CALLMONITOR 
2245			;		endif 
2245			; 
2245			;	call forthparse 
2245			;	call forthexec 
2245			;	 
2245			;	pop hl 
2245			;	if DEBUG_FORTH_WORDS 
2245			;		DMARK "EX5" 
2245			;		CALLMONITOR 
2245			;	endif 
2245			; 
2245			;	if FORTH_ENABLE_FREE 
2245			;	call free 
2245			;	endif 
2245			; 
2245			;	if DEBUG_FORTH_WORDS 
2245			;		DMARK "EX6" 
2245			;		CALLMONITOR 
2245			;	endif 
2245			; 
2245			;	pop bc 
2245			;	pop de 
2245			;	pop hl 
2245			;;	FORTH_RSP_POP	  
2245			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2245			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2245			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2245			; 
2245			;	if DEBUG_FORTH_WORDS 
2245			;		DMARK "EX7" 
2245			;		CALLMONITOR 
2245			;	endif 
2245			;	NEXTW 
2245			 
2245			.STKEXEC: 
2245				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2245 3f				db WORD_SYS_CORE+43             
2246 8d 23			dw .ZDUP            
2248 08				db 7 + 1 
2249 .. 00			db "STKEXEC",0              
2251				endm 
# End of macro CWHEAD
2251			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
2251			 
2251			 
2251					if DEBUG_FORTH_WORDS_KEY 
2251						DMARK "STX" 
2251 f5				push af  
2252 3a 66 22			ld a, (.dmark)  
2255 32 77 fb			ld (debug_mark),a  
2258 3a 67 22			ld a, (.dmark+1)  
225b 32 78 fb			ld (debug_mark+1),a  
225e 3a 68 22			ld a, (.dmark+2)  
2261 32 79 fb			ld (debug_mark+2),a  
2264 18 03			jr .pastdmark  
2266 ..			.dmark: db "STX"  
2269 f1			.pastdmark: pop af  
226a			endm  
# End of macro DMARK
226a						CALLMONITOR 
226a cd 19 17			call break_point_state  
226d				endm  
# End of macro CALLMONITOR
226d					endif 
226d			 
226d				FORTH_DSP_VALUEHL 
226d cd a0 1e			call macro_dsp_valuehl 
2270				endm 
# End of macro FORTH_DSP_VALUEHL
2270			 
2270 22 60 f8			ld (store_tmp1), hl    ; count 
2273			 
2273				FORTH_DSP_POP 
2273 cd 58 1f			call macro_forth_dsp_pop 
2276				endm 
# End of macro FORTH_DSP_POP
2276			.stkexec1: 
2276 2a 60 f8			ld hl, (store_tmp1)   ; count 
2279 3e 00			ld a, 0 
227b bd				cp l 
227c c8				ret z 
227d			 
227d 2b				dec hl 
227e 22 60 f8			ld (store_tmp1), hl    ; count 
2281				 
2281				FORTH_DSP_VALUEHL 
2281 cd a0 1e			call macro_dsp_valuehl 
2284				endm 
# End of macro FORTH_DSP_VALUEHL
2284 e5				push hl 
2285				 
2285					if DEBUG_FORTH_WORDS 
2285						DMARK "EXp" 
2285 f5				push af  
2286 3a 9a 22			ld a, (.dmark)  
2289 32 77 fb			ld (debug_mark),a  
228c 3a 9b 22			ld a, (.dmark+1)  
228f 32 78 fb			ld (debug_mark+1),a  
2292 3a 9c 22			ld a, (.dmark+2)  
2295 32 79 fb			ld (debug_mark+2),a  
2298 18 03			jr .pastdmark  
229a ..			.dmark: db "EXp"  
229d f1			.pastdmark: pop af  
229e			endm  
# End of macro DMARK
229e						CALLMONITOR 
229e cd 19 17			call break_point_state  
22a1				endm  
# End of macro CALLMONITOR
22a1					endif 
22a1				FORTH_DSP_POP 
22a1 cd 58 1f			call macro_forth_dsp_pop 
22a4				endm 
# End of macro FORTH_DSP_POP
22a4			 
22a4 cd 67 11			call strlenz 
22a7 23				inc hl   ; include zero term to copy 
22a8 23				inc hl   ; include zero term to copy 
22a9 23				inc hl   ; include zero term to copy 
22aa 06 00			ld b,0 
22ac 4d				ld c,l 
22ad e1				pop hl 
22ae 11 1c ef			ld de, execscratch 
22b1					if DEBUG_FORTH_WORDS 
22b1						DMARK "EX3" 
22b1 f5				push af  
22b2 3a c6 22			ld a, (.dmark)  
22b5 32 77 fb			ld (debug_mark),a  
22b8 3a c7 22			ld a, (.dmark+1)  
22bb 32 78 fb			ld (debug_mark+1),a  
22be 3a c8 22			ld a, (.dmark+2)  
22c1 32 79 fb			ld (debug_mark+2),a  
22c4 18 03			jr .pastdmark  
22c6 ..			.dmark: db "EX3"  
22c9 f1			.pastdmark: pop af  
22ca			endm  
# End of macro DMARK
22ca						CALLMONITOR 
22ca cd 19 17			call break_point_state  
22cd				endm  
# End of macro CALLMONITOR
22cd					endif 
22cd ed b0			ldir 
22cf			 
22cf			 
22cf 21 1c ef			ld hl, execscratch 
22d2			 
22d2					if DEBUG_FORTH_WORDS 
22d2						DMARK "EXP" 
22d2 f5				push af  
22d3 3a e7 22			ld a, (.dmark)  
22d6 32 77 fb			ld (debug_mark),a  
22d9 3a e8 22			ld a, (.dmark+1)  
22dc 32 78 fb			ld (debug_mark+1),a  
22df 3a e9 22			ld a, (.dmark+2)  
22e2 32 79 fb			ld (debug_mark+2),a  
22e5 18 03			jr .pastdmark  
22e7 ..			.dmark: db "EXP"  
22ea f1			.pastdmark: pop af  
22eb			endm  
# End of macro DMARK
22eb						CALLMONITOR 
22eb cd 19 17			call break_point_state  
22ee				endm  
# End of macro CALLMONITOR
22ee					endif 
22ee			 
22ee cd 60 20			call forthparse 
22f1 21 1c ef			ld hl, execscratch 
22f4					if DEBUG_FORTH_WORDS 
22f4						DMARK "EXx" 
22f4 f5				push af  
22f5 3a 09 23			ld a, (.dmark)  
22f8 32 77 fb			ld (debug_mark),a  
22fb 3a 0a 23			ld a, (.dmark+1)  
22fe 32 78 fb			ld (debug_mark+1),a  
2301 3a 0b 23			ld a, (.dmark+2)  
2304 32 79 fb			ld (debug_mark+2),a  
2307 18 03			jr .pastdmark  
2309 ..			.dmark: db "EXx"  
230c f1			.pastdmark: pop af  
230d			endm  
# End of macro DMARK
230d						CALLMONITOR 
230d cd 19 17			call break_point_state  
2310				endm  
# End of macro CALLMONITOR
2310					endif 
2310 cd a0 20			call forthexec 
2313			 
2313 c3 76 22			jp .stkexec1 
2316			 
2316 c9				ret 
2317			 
2317			 
2317			.DUP: 
2317				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2317 17				db WORD_SYS_CORE+OPCODE_DUP             
2318 8d 23			dw .ZDUP            
231a 04				db 3 + 1 
231b .. 00			db "DUP",0              
231f				endm 
# End of macro CWHEAD
231f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
231f			 
231f					if DEBUG_FORTH_WORDS_KEY 
231f						DMARK "DUP" 
231f f5				push af  
2320 3a 34 23			ld a, (.dmark)  
2323 32 77 fb			ld (debug_mark),a  
2326 3a 35 23			ld a, (.dmark+1)  
2329 32 78 fb			ld (debug_mark+1),a  
232c 3a 36 23			ld a, (.dmark+2)  
232f 32 79 fb			ld (debug_mark+2),a  
2332 18 03			jr .pastdmark  
2334 ..			.dmark: db "DUP"  
2337 f1			.pastdmark: pop af  
2338			endm  
# End of macro DMARK
2338						CALLMONITOR 
2338 cd 19 17			call break_point_state  
233b				endm  
# End of macro CALLMONITOR
233b					endif 
233b			 
233b					FORTH_DSP 
233b cd 66 1e			call macro_forth_dsp 
233e				endm 
# End of macro FORTH_DSP
233e			 
233e 7e					ld a, (HL) 
233f fe 01				cp DS_TYPE_STR 
2341 20 25				jr nz, .dupinum 
2343			 
2343					; push another string 
2343			 
2343					FORTH_DSP_VALUEHL     		 
2343 cd a0 1e			call macro_dsp_valuehl 
2346				endm 
# End of macro FORTH_DSP_VALUEHL
2346			 
2346				if DEBUG_FORTH_WORDS 
2346					DMARK "DUs" 
2346 f5				push af  
2347 3a 5b 23			ld a, (.dmark)  
234a 32 77 fb			ld (debug_mark),a  
234d 3a 5c 23			ld a, (.dmark+1)  
2350 32 78 fb			ld (debug_mark+1),a  
2353 3a 5d 23			ld a, (.dmark+2)  
2356 32 79 fb			ld (debug_mark+2),a  
2359 18 03			jr .pastdmark  
235b ..			.dmark: db "DUs"  
235e f1			.pastdmark: pop af  
235f			endm  
# End of macro DMARK
235f					CALLMONITOR 
235f cd 19 17			call break_point_state  
2362				endm  
# End of macro CALLMONITOR
2362				endif 
2362 cd 17 1d				call forth_push_str 
2365			 
2365					NEXTW 
2365 c3 12 20			jp macro_next 
2368				endm 
# End of macro NEXTW
2368			 
2368			 
2368			.dupinum: 
2368					 
2368			 
2368			 
2368					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2368 cd a0 1e			call macro_dsp_valuehl 
236b				endm 
# End of macro FORTH_DSP_VALUEHL
236b			 
236b				; TODO add floating point number detection 
236b			 
236b				if DEBUG_FORTH_WORDS 
236b					DMARK "DUi" 
236b f5				push af  
236c 3a 80 23			ld a, (.dmark)  
236f 32 77 fb			ld (debug_mark),a  
2372 3a 81 23			ld a, (.dmark+1)  
2375 32 78 fb			ld (debug_mark+1),a  
2378 3a 82 23			ld a, (.dmark+2)  
237b 32 79 fb			ld (debug_mark+2),a  
237e 18 03			jr .pastdmark  
2380 ..			.dmark: db "DUi"  
2383 f1			.pastdmark: pop af  
2384			endm  
# End of macro DMARK
2384					CALLMONITOR 
2384 cd 19 17			call break_point_state  
2387				endm  
# End of macro CALLMONITOR
2387				endif 
2387			 
2387 cd a9 1c				call forth_push_numhl 
238a					NEXTW 
238a c3 12 20			jp macro_next 
238d				endm 
# End of macro NEXTW
238d			.ZDUP: 
238d				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
238d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
238e c5 23			dw .SWAP            
2390 05				db 4 + 1 
2391 .. 00			db "?DUP",0              
2396				endm 
# End of macro CWHEAD
2396			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2396			 
2396					if DEBUG_FORTH_WORDS_KEY 
2396						DMARK "qDU" 
2396 f5				push af  
2397 3a ab 23			ld a, (.dmark)  
239a 32 77 fb			ld (debug_mark),a  
239d 3a ac 23			ld a, (.dmark+1)  
23a0 32 78 fb			ld (debug_mark+1),a  
23a3 3a ad 23			ld a, (.dmark+2)  
23a6 32 79 fb			ld (debug_mark+2),a  
23a9 18 03			jr .pastdmark  
23ab ..			.dmark: db "qDU"  
23ae f1			.pastdmark: pop af  
23af			endm  
# End of macro DMARK
23af						CALLMONITOR 
23af cd 19 17			call break_point_state  
23b2				endm  
# End of macro CALLMONITOR
23b2					endif 
23b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23b2 cd a0 1e			call macro_dsp_valuehl 
23b5				endm 
# End of macro FORTH_DSP_VALUEHL
23b5			 
23b5 e5					push hl 
23b6			 
23b6					; is it a zero? 
23b6			 
23b6 3e 00				ld a, 0 
23b8 84					add h 
23b9 85					add l 
23ba			 
23ba e1					pop hl 
23bb			 
23bb fe 00				cp 0 
23bd 28 03				jr z, .dup2orig 
23bf			 
23bf			 
23bf cd a9 1c				call forth_push_numhl 
23c2			 
23c2			 
23c2				; TODO add floating point number detection 
23c2			 
23c2			.dup2orig: 
23c2			 
23c2					NEXTW 
23c2 c3 12 20			jp macro_next 
23c5				endm 
# End of macro NEXTW
23c5			.SWAP: 
23c5				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
23c5 18				db WORD_SYS_CORE+OPCODE_SWAP             
23c6 04 24			dw .COLN            
23c8 05				db 4 + 1 
23c9 .. 00			db "SWAP",0              
23ce				endm 
# End of macro CWHEAD
23ce			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
23ce					if DEBUG_FORTH_WORDS_KEY 
23ce						DMARK "SWP" 
23ce f5				push af  
23cf 3a e3 23			ld a, (.dmark)  
23d2 32 77 fb			ld (debug_mark),a  
23d5 3a e4 23			ld a, (.dmark+1)  
23d8 32 78 fb			ld (debug_mark+1),a  
23db 3a e5 23			ld a, (.dmark+2)  
23de 32 79 fb			ld (debug_mark+2),a  
23e1 18 03			jr .pastdmark  
23e3 ..			.dmark: db "SWP"  
23e6 f1			.pastdmark: pop af  
23e7			endm  
# End of macro DMARK
23e7						CALLMONITOR 
23e7 cd 19 17			call break_point_state  
23ea				endm  
# End of macro CALLMONITOR
23ea					endif 
23ea			 
23ea					FORTH_DSP_VALUEHL 
23ea cd a0 1e			call macro_dsp_valuehl 
23ed				endm 
# End of macro FORTH_DSP_VALUEHL
23ed e5					push hl     ; w2 
23ee			 
23ee					FORTH_DSP_POP 
23ee cd 58 1f			call macro_forth_dsp_pop 
23f1				endm 
# End of macro FORTH_DSP_POP
23f1			 
23f1					FORTH_DSP_VALUEHL 
23f1 cd a0 1e			call macro_dsp_valuehl 
23f4				endm 
# End of macro FORTH_DSP_VALUEHL
23f4			 
23f4					FORTH_DSP_POP 
23f4 cd 58 1f			call macro_forth_dsp_pop 
23f7				endm 
# End of macro FORTH_DSP_POP
23f7			 
23f7 d1					pop de     ; w2	, hl = w1 
23f8			 
23f8 eb					ex de, hl 
23f9 d5					push de 
23fa			 
23fa cd a9 1c				call forth_push_numhl 
23fd			 
23fd e1					pop hl 
23fe			 
23fe cd a9 1c				call forth_push_numhl 
2401					 
2401			 
2401					NEXTW 
2401 c3 12 20			jp macro_next 
2404				endm 
# End of macro NEXTW
2404			.COLN: 
2404				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2404 19				db WORD_SYS_CORE+OPCODE_COLN             
2405 90 25			dw .SCOLN            
2407 02				db 1 + 1 
2408 .. 00			db ":",0              
240a				endm 
# End of macro CWHEAD
240a			; | : ( -- )         Create new word | DONE 
240a			 
240a					if DEBUG_FORTH_WORDS_KEY 
240a						DMARK "CLN" 
240a f5				push af  
240b 3a 1f 24			ld a, (.dmark)  
240e 32 77 fb			ld (debug_mark),a  
2411 3a 20 24			ld a, (.dmark+1)  
2414 32 78 fb			ld (debug_mark+1),a  
2417 3a 21 24			ld a, (.dmark+2)  
241a 32 79 fb			ld (debug_mark+2),a  
241d 18 03			jr .pastdmark  
241f ..			.dmark: db "CLN"  
2422 f1			.pastdmark: pop af  
2423			endm  
# End of macro DMARK
2423						CALLMONITOR 
2423 cd 19 17			call break_point_state  
2426				endm  
# End of macro CALLMONITOR
2426					endif 
2426				STACKFRAME OFF $8efe $989f 
2426				if DEBUG_STACK_IMB 
2426					if OFF 
2426						exx 
2426						ld de, $8efe 
2426						ld a, d 
2426						ld hl, curframe 
2426						call hexout 
2426						ld a, e 
2426						ld hl, curframe+2 
2426						call hexout 
2426						ld hl, $8efe 
2426						push hl 
2426						ld hl, $989f 
2426						push hl 
2426						exx 
2426					endif 
2426				endif 
2426			endm 
# End of macro STACKFRAME
2426				; get parser buffer length  of new word 
2426			 
2426				 
2426			 
2426					; move tok past this to start of name defintition 
2426					; TODO get word to define 
2426					; TODO Move past word token 
2426					; TODO get length of string up to the ';' 
2426			 
2426 2a 1e f1			ld hl, (os_tok_ptr) 
2429 23				inc hl 
242a 23				inc hl 
242b			 
242b 3e 3b			ld a, ';' 
242d cd 72 11			call strlent 
2430			 
2430 7d				ld a,l 
2431 32 19 ee			ld (os_new_parse_len), a 
2434			 
2434			 
2434			if DEBUG_FORTH_UWORD 
2434 ed 5b 1e f1		ld de, (os_tok_ptr) 
2438						DMARK ":01" 
2438 f5				push af  
2439 3a 4d 24			ld a, (.dmark)  
243c 32 77 fb			ld (debug_mark),a  
243f 3a 4e 24			ld a, (.dmark+1)  
2442 32 78 fb			ld (debug_mark+1),a  
2445 3a 4f 24			ld a, (.dmark+2)  
2448 32 79 fb			ld (debug_mark+2),a  
244b 18 03			jr .pastdmark  
244d ..			.dmark: db ":01"  
2450 f1			.pastdmark: pop af  
2451			endm  
# End of macro DMARK
2451				CALLMONITOR 
2451 cd 19 17			call break_point_state  
2454				endm  
# End of macro CALLMONITOR
2454			endif 
2454			 
2454			; 
2454			;  new word memory layout: 
2454			;  
2454			;    : adg 6666 ;  
2454			; 
2454			;    db   1     ; user defined word  
2454 23				inc hl    
2455			;    dw   sysdict 
2455 23				inc hl 
2456 23				inc hl 
2457			;    db <word len>+1 (for null) 
2457 23				inc hl 
2458			;    db .... <word> 
2458			; 
2458			 
2458 23				inc hl    ; some extras for the word preamble before the above 
2459 23				inc hl 
245a 23				inc hl 
245b 23				inc hl 
245c 23				inc hl 
245d 23				inc hl 
245e 23				inc hl  
245f 23				inc hl 
2460 23				inc hl 
2461 23				inc hl 
2462 23				inc hl 
2463 23				inc hl 
2464 23				inc hl 
2465 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2466			;       exec word buffer 
2466			;	<ptr word>   
2466 23				inc hl 
2467 23				inc hl 
2468			;       <word list><null term> 7F final term 
2468			 
2468			 
2468			if DEBUG_FORTH_UWORD 
2468						DMARK ":02" 
2468 f5				push af  
2469 3a 7d 24			ld a, (.dmark)  
246c 32 77 fb			ld (debug_mark),a  
246f 3a 7e 24			ld a, (.dmark+1)  
2472 32 78 fb			ld (debug_mark+1),a  
2475 3a 7f 24			ld a, (.dmark+2)  
2478 32 79 fb			ld (debug_mark+2),a  
247b 18 03			jr .pastdmark  
247d ..			.dmark: db ":02"  
2480 f1			.pastdmark: pop af  
2481			endm  
# End of macro DMARK
2481				CALLMONITOR 
2481 cd 19 17			call break_point_state  
2484				endm  
# End of macro CALLMONITOR
2484			endif 
2484			 
2484				 
2484					; malloc the size 
2484			 
2484 cd d0 11				call malloc 
2487 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
248a			 
248a			;    db   1     ; user defined word  
248a 3e 01				ld a, WORD_SYS_UWORD  
248c 77					ld (hl), a 
248d				 
248d 23				inc hl    
248e			;    dw   sysdict 
248e 11 6a 21			ld de, sysdict       ; continue on with the scan to the system dict 
2491 73				ld (hl), e 
2492 23				inc hl 
2493 72				ld (hl), d 
2494 23				inc hl 
2495			 
2495			 
2495			;    Setup dict word 
2495			 
2495 23				inc hl 
2496 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
2499			 
2499				; 1. get length of dict word 
2499			 
2499			 
2499 2a 1e f1			ld hl, (os_tok_ptr) 
249c 23				inc hl 
249d 23				inc hl    ; position to start of dict word 
249e 3e 00			ld a, 0 
24a0 cd 72 11			call strlent 
24a3			 
24a3			 
24a3 23				inc hl    ; to include null??? 
24a4			 
24a4				; write length of dict word 
24a4			 
24a4 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
24a8 1b				dec de 
24a9 eb				ex de, hl 
24aa 73				ld (hl), e 
24ab eb				ex de, hl 
24ac			 
24ac				 
24ac			 
24ac				; copy  
24ac 4d				ld c, l 
24ad 06 00			ld b, 0 
24af ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
24b3 2a 1e f1			ld hl, (os_tok_ptr) 
24b6 23				inc hl 
24b7 23				inc hl    ; position to start of dict word 
24b8				 
24b8			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
24b8				 
24b8				; TODO need to convert word to upper case 
24b8			 
24b8			ucasetok:	 
24b8 7e				ld a,(hl) 
24b9 cd 5e 11			call toUpper 
24bc 77				ld (hl),a 
24bd ed a0			ldi 
24bf f2 b8 24		 	jp p, ucasetok 
24c2			 
24c2			 
24c2			 
24c2				; de now points to start of where the word body code should be placed 
24c2 ed 53 15 ee		ld (os_new_work_ptr), de 
24c6				; hl now points to the words to throw at forthexec which needs to be copied 
24c6 22 13 ee			ld (os_new_src_ptr), hl 
24c9			 
24c9				; TODO add 'call to forthexec' 
24c9			 
24c9			if DEBUG_FORTH_UWORD 
24c9 c5				push bc 
24ca ed 4b 1b ee		ld bc, (os_new_malloc) 
24ce						DMARK ":0x" 
24ce f5				push af  
24cf 3a e3 24			ld a, (.dmark)  
24d2 32 77 fb			ld (debug_mark),a  
24d5 3a e4 24			ld a, (.dmark+1)  
24d8 32 78 fb			ld (debug_mark+1),a  
24db 3a e5 24			ld a, (.dmark+2)  
24de 32 79 fb			ld (debug_mark+2),a  
24e1 18 03			jr .pastdmark  
24e3 ..			.dmark: db ":0x"  
24e6 f1			.pastdmark: pop af  
24e7			endm  
# End of macro DMARK
24e7				CALLMONITOR 
24e7 cd 19 17			call break_point_state  
24ea				endm  
# End of macro CALLMONITOR
24ea c1				pop bc 
24eb			endif 
24eb			 
24eb			 
24eb				; create word preamble which should be: 
24eb			 
24eb			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
24eb			 
24eb				;    ld hl, <word code> 
24eb				;    jp user_exec 
24eb			        ;    <word code bytes> 
24eb			 
24eb			 
24eb			;	inc de     ; TODO ??? or are we already past the word's null 
24eb eb				ex de, hl 
24ec			 
24ec 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
24ee			 
24ee 23				inc hl 
24ef 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
24f2 23				inc hl 
24f3			 
24f3 23				inc hl 
24f4 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
24f6			 
24f6 01 fb 51			ld bc, user_exec 
24f9 23				inc hl 
24fa 71				ld (hl), c     ; poke address of user_exec 
24fb 23				inc hl 
24fc 70				ld (hl), b     
24fd			 ; 
24fd			;	inc hl 
24fd			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24fd			; 
24fd			; 
24fd			;	ld bc, macro_forth_rsp_next 
24fd			;	inc hl 
24fd			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
24fd			;	inc hl 
24fd			;	ld (hl), b     
24fd			 ; 
24fd			;	inc hl 
24fd			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24fd			; 
24fd			; 
24fd			;	inc hl 
24fd			;	ld bc, forthexec 
24fd			;	ld (hl), c     ; poke address of forthexec 
24fd			;	inc hl 
24fd			;	ld (hl), b      
24fd			; 
24fd			;	inc hl 
24fd			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
24fd			; 
24fd			;	ld bc, user_dict_next 
24fd			;	inc hl 
24fd			;	ld (hl), c     ; poke address of forthexec 
24fd			;	inc hl 
24fd			;	ld (hl), b      
24fd			 
24fd				; hl is now where we need to copy the word byte data to save this 
24fd			 
24fd 23				inc hl 
24fe 22 11 ee			ld (os_new_exec), hl 
2501				 
2501				; copy definition 
2501			 
2501 eb				ex de, hl 
2502			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2502			;	inc de    ; skip the PC for this parse 
2502 3a 19 ee			ld a, (os_new_parse_len) 
2505 4f				ld c, a 
2506 06 00			ld b, 0 
2508 ed b0			ldir		 ; copy defintion 
250a			 
250a			 
250a				; poke the address of where the new word bytes live for forthexec 
250a			 
250a 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
250d			 
250d ed 5b 11 ee		ld de, (os_new_exec)      
2511				 
2511 73				ld (hl), e 
2512 23				inc hl 
2513 72				ld (hl), d 
2514			 
2514					; TODO copy last user dict word next link to this word 
2514					; TODO update last user dict word to point to this word 
2514			; 
2514			; hl f923 de 812a ; bc 811a 
2514			 
2514			if DEBUG_FORTH_UWORD 
2514 c5				push bc 
2515 ed 4b 1b ee		ld bc, (os_new_malloc) 
2519						DMARK ":0A" 
2519 f5				push af  
251a 3a 2e 25			ld a, (.dmark)  
251d 32 77 fb			ld (debug_mark),a  
2520 3a 2f 25			ld a, (.dmark+1)  
2523 32 78 fb			ld (debug_mark+1),a  
2526 3a 30 25			ld a, (.dmark+2)  
2529 32 79 fb			ld (debug_mark+2),a  
252c 18 03			jr .pastdmark  
252e ..			.dmark: db ":0A"  
2531 f1			.pastdmark: pop af  
2532			endm  
# End of macro DMARK
2532				CALLMONITOR 
2532 cd 19 17			call break_point_state  
2535				endm  
# End of macro CALLMONITOR
2535 c1				pop bc 
2536			endif 
2536			if DEBUG_FORTH_UWORD 
2536 c5				push bc 
2537 ed 4b 1b ee		ld bc, (os_new_malloc) 
253b 03				inc bc 
253c 03				inc bc 
253d 03				inc bc 
253e 03				inc bc 
253f 03				inc bc 
2540 03				inc bc 
2541 03				inc bc 
2542 03				inc bc 
2543			 
2543						DMARK ":0B" 
2543 f5				push af  
2544 3a 58 25			ld a, (.dmark)  
2547 32 77 fb			ld (debug_mark),a  
254a 3a 59 25			ld a, (.dmark+1)  
254d 32 78 fb			ld (debug_mark+1),a  
2550 3a 5a 25			ld a, (.dmark+2)  
2553 32 79 fb			ld (debug_mark+2),a  
2556 18 03			jr .pastdmark  
2558 ..			.dmark: db ":0B"  
255b f1			.pastdmark: pop af  
255c			endm  
# End of macro DMARK
255c				CALLMONITOR 
255c cd 19 17			call break_point_state  
255f				endm  
# End of macro CALLMONITOR
255f c1				pop bc 
2560			endif 
2560			 
2560			; update word dict linked list for new word 
2560			 
2560			 
2560 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2563 23			inc hl     ; move to next work linked list ptr 
2564			 
2564 ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
2568 73			ld (hl), e 
2569 23			inc hl 
256a 72			ld (hl), d 
256b			 
256b			if DEBUG_FORTH_UWORD 
256b ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
256f			endif 
256f			 
256f ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2573			 
2573			 
2573			if DEBUG_FORTH_UWORD 
2573						DMARK ":0+" 
2573 f5				push af  
2574 3a 88 25			ld a, (.dmark)  
2577 32 77 fb			ld (debug_mark),a  
257a 3a 89 25			ld a, (.dmark+1)  
257d 32 78 fb			ld (debug_mark+1),a  
2580 3a 8a 25			ld a, (.dmark+2)  
2583 32 79 fb			ld (debug_mark+2),a  
2586 18 03			jr .pastdmark  
2588 ..			.dmark: db ":0+"  
258b f1			.pastdmark: pop af  
258c			endm  
# End of macro DMARK
258c				CALLMONITOR 
258c cd 19 17			call break_point_state  
258f				endm  
# End of macro CALLMONITOR
258f			endif 
258f			 
258f				STACKFRAMECHK OFF $8efe $989f 
258f				if DEBUG_STACK_IMB 
258f					if OFF 
258f						exx 
258f						ld hl, $989f 
258f						pop de   ; $989f 
258f						call cmp16 
258f						jr nz, .spnosame 
258f						ld hl, $8efe 
258f						pop de   ; $8efe 
258f						call cmp16 
258f						jr z, .spfrsame 
258f						.spnosame: call showsperror 
258f						.spfrsame: nop 
258f						exx 
258f					endif 
258f				endif 
258f			endm 
# End of macro STACKFRAMECHK
258f			 
258f c9			ret    ; dont process any remaining parser tokens as they form new word 
2590			 
2590			 
2590			 
2590			 
2590			;		NEXT 
2590			.SCOLN: 
2590			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2590 06				db OPCODE_SCOLN 
2591 dc 25			dw .DROP 
2593 02				db 2 
2594 .. 00			db ";",0           
2596			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2596					if DEBUG_FORTH_WORDS_KEY 
2596						DMARK "SCN" 
2596 f5				push af  
2597 3a ab 25			ld a, (.dmark)  
259a 32 77 fb			ld (debug_mark),a  
259d 3a ac 25			ld a, (.dmark+1)  
25a0 32 78 fb			ld (debug_mark+1),a  
25a3 3a ad 25			ld a, (.dmark+2)  
25a6 32 79 fb			ld (debug_mark+2),a  
25a9 18 03			jr .pastdmark  
25ab ..			.dmark: db "SCN"  
25ae f1			.pastdmark: pop af  
25af			endm  
# End of macro DMARK
25af						CALLMONITOR 
25af cd 19 17			call break_point_state  
25b2				endm  
# End of macro CALLMONITOR
25b2					endif 
25b2					FORTH_RSP_TOS 
25b2 cd 67 1c			call macro_forth_rsp_tos 
25b5				endm 
# End of macro FORTH_RSP_TOS
25b5 e5					push hl 
25b6					FORTH_RSP_POP 
25b6 cd 71 1c			call macro_forth_rsp_pop 
25b9				endm 
# End of macro FORTH_RSP_POP
25b9 e1					pop hl 
25ba			;		ex de,hl 
25ba 22 1e f1				ld (os_tok_ptr),hl 
25bd			 
25bd			if DEBUG_FORTH_UWORD 
25bd						DMARK "SCL" 
25bd f5				push af  
25be 3a d2 25			ld a, (.dmark)  
25c1 32 77 fb			ld (debug_mark),a  
25c4 3a d3 25			ld a, (.dmark+1)  
25c7 32 78 fb			ld (debug_mark+1),a  
25ca 3a d4 25			ld a, (.dmark+2)  
25cd 32 79 fb			ld (debug_mark+2),a  
25d0 18 03			jr .pastdmark  
25d2 ..			.dmark: db "SCL"  
25d5 f1			.pastdmark: pop af  
25d6			endm  
# End of macro DMARK
25d6				CALLMONITOR 
25d6 cd 19 17			call break_point_state  
25d9				endm  
# End of macro CALLMONITOR
25d9			endif 
25d9					NEXTW 
25d9 c3 12 20			jp macro_next 
25dc				endm 
# End of macro NEXTW
25dc			 
25dc			.DROP: 
25dc				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
25dc 1b				db WORD_SYS_CORE+OPCODE_DROP             
25dd 07 26			dw .DUP2            
25df 05				db 4 + 1 
25e0 .. 00			db "DROP",0              
25e5				endm 
# End of macro CWHEAD
25e5			; | DROP ( w -- )   drop the TOS item   | DONE 
25e5					if DEBUG_FORTH_WORDS_KEY 
25e5						DMARK "DRP" 
25e5 f5				push af  
25e6 3a fa 25			ld a, (.dmark)  
25e9 32 77 fb			ld (debug_mark),a  
25ec 3a fb 25			ld a, (.dmark+1)  
25ef 32 78 fb			ld (debug_mark+1),a  
25f2 3a fc 25			ld a, (.dmark+2)  
25f5 32 79 fb			ld (debug_mark+2),a  
25f8 18 03			jr .pastdmark  
25fa ..			.dmark: db "DRP"  
25fd f1			.pastdmark: pop af  
25fe			endm  
# End of macro DMARK
25fe						CALLMONITOR 
25fe cd 19 17			call break_point_state  
2601				endm  
# End of macro CALLMONITOR
2601					endif 
2601					FORTH_DSP_POP 
2601 cd 58 1f			call macro_forth_dsp_pop 
2604				endm 
# End of macro FORTH_DSP_POP
2604					NEXTW 
2604 c3 12 20			jp macro_next 
2607				endm 
# End of macro NEXTW
2607			.DUP2: 
2607				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2607 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2608 4c 26			dw .DROP2            
260a 05				db 4 + 1 
260b .. 00			db "2DUP",0              
2610				endm 
# End of macro CWHEAD
2610			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2610					if DEBUG_FORTH_WORDS_KEY 
2610						DMARK "2DU" 
2610 f5				push af  
2611 3a 25 26			ld a, (.dmark)  
2614 32 77 fb			ld (debug_mark),a  
2617 3a 26 26			ld a, (.dmark+1)  
261a 32 78 fb			ld (debug_mark+1),a  
261d 3a 27 26			ld a, (.dmark+2)  
2620 32 79 fb			ld (debug_mark+2),a  
2623 18 03			jr .pastdmark  
2625 ..			.dmark: db "2DU"  
2628 f1			.pastdmark: pop af  
2629			endm  
# End of macro DMARK
2629						CALLMONITOR 
2629 cd 19 17			call break_point_state  
262c				endm  
# End of macro CALLMONITOR
262c					endif 
262c					FORTH_DSP_VALUEHL 
262c cd a0 1e			call macro_dsp_valuehl 
262f				endm 
# End of macro FORTH_DSP_VALUEHL
262f e5					push hl      ; 2 
2630			 
2630					FORTH_DSP_POP 
2630 cd 58 1f			call macro_forth_dsp_pop 
2633				endm 
# End of macro FORTH_DSP_POP
2633					 
2633					FORTH_DSP_VALUEHL 
2633 cd a0 1e			call macro_dsp_valuehl 
2636				endm 
# End of macro FORTH_DSP_VALUEHL
2636			;		push hl      ; 1 
2636			 
2636					FORTH_DSP_POP 
2636 cd 58 1f			call macro_forth_dsp_pop 
2639				endm 
# End of macro FORTH_DSP_POP
2639			 
2639			;		pop hl       ; 1 
2639 d1					pop de       ; 2 
263a			 
263a cd a9 1c				call forth_push_numhl 
263d eb					ex de, hl 
263e cd a9 1c				call forth_push_numhl 
2641			 
2641					 
2641 eb					ex de, hl 
2642			 
2642 cd a9 1c				call forth_push_numhl 
2645 eb					ex de, hl 
2646 cd a9 1c				call forth_push_numhl 
2649			 
2649			 
2649					NEXTW 
2649 c3 12 20			jp macro_next 
264c				endm 
# End of macro NEXTW
264c			.DROP2: 
264c				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
264c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
264d 7b 26			dw .SWAP2            
264f 06				db 5 + 1 
2650 .. 00			db "2DROP",0              
2656				endm 
# End of macro CWHEAD
2656			; | 2DROP ( w w -- )    Double drop | DONE 
2656					if DEBUG_FORTH_WORDS_KEY 
2656						DMARK "2DR" 
2656 f5				push af  
2657 3a 6b 26			ld a, (.dmark)  
265a 32 77 fb			ld (debug_mark),a  
265d 3a 6c 26			ld a, (.dmark+1)  
2660 32 78 fb			ld (debug_mark+1),a  
2663 3a 6d 26			ld a, (.dmark+2)  
2666 32 79 fb			ld (debug_mark+2),a  
2669 18 03			jr .pastdmark  
266b ..			.dmark: db "2DR"  
266e f1			.pastdmark: pop af  
266f			endm  
# End of macro DMARK
266f						CALLMONITOR 
266f cd 19 17			call break_point_state  
2672				endm  
# End of macro CALLMONITOR
2672					endif 
2672					FORTH_DSP_POP 
2672 cd 58 1f			call macro_forth_dsp_pop 
2675				endm 
# End of macro FORTH_DSP_POP
2675					FORTH_DSP_POP 
2675 cd 58 1f			call macro_forth_dsp_pop 
2678				endm 
# End of macro FORTH_DSP_POP
2678					NEXTW 
2678 c3 12 20			jp macro_next 
267b				endm 
# End of macro NEXTW
267b			.SWAP2: 
267b				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
267b 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
267c a4 26			dw .AT            
267e 06				db 5 + 1 
267f .. 00			db "2SWAP",0              
2685				endm 
# End of macro CWHEAD
2685			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2685					if DEBUG_FORTH_WORDS_KEY 
2685						DMARK "2SW" 
2685 f5				push af  
2686 3a 9a 26			ld a, (.dmark)  
2689 32 77 fb			ld (debug_mark),a  
268c 3a 9b 26			ld a, (.dmark+1)  
268f 32 78 fb			ld (debug_mark+1),a  
2692 3a 9c 26			ld a, (.dmark+2)  
2695 32 79 fb			ld (debug_mark+2),a  
2698 18 03			jr .pastdmark  
269a ..			.dmark: db "2SW"  
269d f1			.pastdmark: pop af  
269e			endm  
# End of macro DMARK
269e						CALLMONITOR 
269e cd 19 17			call break_point_state  
26a1				endm  
# End of macro CALLMONITOR
26a1					endif 
26a1					NEXTW 
26a1 c3 12 20			jp macro_next 
26a4				endm 
# End of macro NEXTW
26a4			.AT: 
26a4				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
26a4 1f				db WORD_SYS_CORE+OPCODE_AT             
26a5 d6 26			dw .CAT            
26a7 02				db 1 + 1 
26a8 .. 00			db "@",0              
26aa				endm 
# End of macro CWHEAD
26aa			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
26aa			 
26aa					if DEBUG_FORTH_WORDS_KEY 
26aa						DMARK "AT." 
26aa f5				push af  
26ab 3a bf 26			ld a, (.dmark)  
26ae 32 77 fb			ld (debug_mark),a  
26b1 3a c0 26			ld a, (.dmark+1)  
26b4 32 78 fb			ld (debug_mark+1),a  
26b7 3a c1 26			ld a, (.dmark+2)  
26ba 32 79 fb			ld (debug_mark+2),a  
26bd 18 03			jr .pastdmark  
26bf ..			.dmark: db "AT."  
26c2 f1			.pastdmark: pop af  
26c3			endm  
# End of macro DMARK
26c3						CALLMONITOR 
26c3 cd 19 17			call break_point_state  
26c6				endm  
# End of macro CALLMONITOR
26c6					endif 
26c6			.getbyteat:	 
26c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c6 cd a0 1e			call macro_dsp_valuehl 
26c9				endm 
# End of macro FORTH_DSP_VALUEHL
26c9					 
26c9			;		push hl 
26c9				 
26c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c9 cd 58 1f			call macro_forth_dsp_pop 
26cc				endm 
# End of macro FORTH_DSP_POP
26cc			 
26cc			;		pop hl 
26cc			 
26cc 7e					ld a, (hl) 
26cd			 
26cd 6f					ld l, a 
26ce 26 00				ld h, 0 
26d0 cd a9 1c				call forth_push_numhl 
26d3			 
26d3					NEXTW 
26d3 c3 12 20			jp macro_next 
26d6				endm 
# End of macro NEXTW
26d6			.CAT: 
26d6				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
26d6 20				db WORD_SYS_CORE+OPCODE_CAT             
26d7 ff 26			dw .BANG            
26d9 03				db 2 + 1 
26da .. 00			db "C@",0              
26dd				endm 
# End of macro CWHEAD
26dd			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
26dd					if DEBUG_FORTH_WORDS_KEY 
26dd						DMARK "CAA" 
26dd f5				push af  
26de 3a f2 26			ld a, (.dmark)  
26e1 32 77 fb			ld (debug_mark),a  
26e4 3a f3 26			ld a, (.dmark+1)  
26e7 32 78 fb			ld (debug_mark+1),a  
26ea 3a f4 26			ld a, (.dmark+2)  
26ed 32 79 fb			ld (debug_mark+2),a  
26f0 18 03			jr .pastdmark  
26f2 ..			.dmark: db "CAA"  
26f5 f1			.pastdmark: pop af  
26f6			endm  
# End of macro DMARK
26f6						CALLMONITOR 
26f6 cd 19 17			call break_point_state  
26f9				endm  
# End of macro CALLMONITOR
26f9					endif 
26f9 c3 c6 26				jp .getbyteat 
26fc					NEXTW 
26fc c3 12 20			jp macro_next 
26ff				endm 
# End of macro NEXTW
26ff			.BANG: 
26ff				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
26ff 21				db WORD_SYS_CORE+OPCODE_BANG             
2700 35 27			dw .CBANG            
2702 02				db 1 + 1 
2703 .. 00			db "!",0              
2705				endm 
# End of macro CWHEAD
2705			; | ! ( x w -- ) Store x at address w      | DONE 
2705					if DEBUG_FORTH_WORDS_KEY 
2705						DMARK "BNG" 
2705 f5				push af  
2706 3a 1a 27			ld a, (.dmark)  
2709 32 77 fb			ld (debug_mark),a  
270c 3a 1b 27			ld a, (.dmark+1)  
270f 32 78 fb			ld (debug_mark+1),a  
2712 3a 1c 27			ld a, (.dmark+2)  
2715 32 79 fb			ld (debug_mark+2),a  
2718 18 03			jr .pastdmark  
271a ..			.dmark: db "BNG"  
271d f1			.pastdmark: pop af  
271e			endm  
# End of macro DMARK
271e						CALLMONITOR 
271e cd 19 17			call break_point_state  
2721				endm  
# End of macro CALLMONITOR
2721					endif 
2721			 
2721			.storebyteat:		 
2721					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2721 cd a0 1e			call macro_dsp_valuehl 
2724				endm 
# End of macro FORTH_DSP_VALUEHL
2724					 
2724 e5					push hl 
2725				 
2725					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2725 cd 58 1f			call macro_forth_dsp_pop 
2728				endm 
# End of macro FORTH_DSP_POP
2728			 
2728					; get byte to poke 
2728			 
2728					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2728 cd a0 1e			call macro_dsp_valuehl 
272b				endm 
# End of macro FORTH_DSP_VALUEHL
272b e5					push hl 
272c			 
272c			 
272c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
272c cd 58 1f			call macro_forth_dsp_pop 
272f				endm 
# End of macro FORTH_DSP_POP
272f			 
272f			 
272f d1					pop de 
2730 e1					pop hl 
2731			 
2731 73					ld (hl),e 
2732			 
2732			 
2732					NEXTW 
2732 c3 12 20			jp macro_next 
2735				endm 
# End of macro NEXTW
2735			.CBANG: 
2735				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2735 22				db WORD_SYS_CORE+OPCODE_CBANG             
2736 5e 27			dw .SCALL            
2738 03				db 2 + 1 
2739 .. 00			db "C!",0              
273c				endm 
# End of macro CWHEAD
273c			; | C!  ( x w -- ) Store x at address w  | DONE 
273c					if DEBUG_FORTH_WORDS_KEY 
273c						DMARK "CBA" 
273c f5				push af  
273d 3a 51 27			ld a, (.dmark)  
2740 32 77 fb			ld (debug_mark),a  
2743 3a 52 27			ld a, (.dmark+1)  
2746 32 78 fb			ld (debug_mark+1),a  
2749 3a 53 27			ld a, (.dmark+2)  
274c 32 79 fb			ld (debug_mark+2),a  
274f 18 03			jr .pastdmark  
2751 ..			.dmark: db "CBA"  
2754 f1			.pastdmark: pop af  
2755			endm  
# End of macro DMARK
2755						CALLMONITOR 
2755 cd 19 17			call break_point_state  
2758				endm  
# End of macro CALLMONITOR
2758					endif 
2758 c3 21 27				jp .storebyteat 
275b					NEXTW 
275b c3 12 20			jp macro_next 
275e				endm 
# End of macro NEXTW
275e			.SCALL: 
275e				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
275e 23				db WORD_SYS_CORE+OPCODE_SCALL             
275f 92 27			dw .DEPTH            
2761 05				db 4 + 1 
2762 .. 00			db "CALL",0              
2767				endm 
# End of macro CWHEAD
2767			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2767					if DEBUG_FORTH_WORDS_KEY 
2767						DMARK "CLL" 
2767 f5				push af  
2768 3a 7c 27			ld a, (.dmark)  
276b 32 77 fb			ld (debug_mark),a  
276e 3a 7d 27			ld a, (.dmark+1)  
2771 32 78 fb			ld (debug_mark+1),a  
2774 3a 7e 27			ld a, (.dmark+2)  
2777 32 79 fb			ld (debug_mark+2),a  
277a 18 03			jr .pastdmark  
277c ..			.dmark: db "CLL"  
277f f1			.pastdmark: pop af  
2780			endm  
# End of macro DMARK
2780						CALLMONITOR 
2780 cd 19 17			call break_point_state  
2783				endm  
# End of macro CALLMONITOR
2783					endif 
2783			 
2783					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2783 cd a0 1e			call macro_dsp_valuehl 
2786				endm 
# End of macro FORTH_DSP_VALUEHL
2786			 
2786			;		push hl 
2786			 
2786					; destroy value TOS 
2786			 
2786					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2786 cd 58 1f			call macro_forth_dsp_pop 
2789				endm 
# End of macro FORTH_DSP_POP
2789			 
2789						 
2789			;		pop hl 
2789			 
2789					; how to do a call with hl???? save SP? 
2789 cd bb 1f				call forth_call_hl 
278c			 
278c			 
278c					; TODO push value back onto stack for another op etc 
278c			 
278c cd a9 1c				call forth_push_numhl 
278f					NEXTW 
278f c3 12 20			jp macro_next 
2792				endm 
# End of macro NEXTW
2792			.DEPTH: 
2792				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2792 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2793 cf 27			dw .OVER            
2795 06				db 5 + 1 
2796 .. 00			db "DEPTH",0              
279c				endm 
# End of macro CWHEAD
279c			; | DEPTH ( -- u ) Push count of stack | DONE 
279c					; take current TOS and remove from base value div by two to get count 
279c					if DEBUG_FORTH_WORDS_KEY 
279c						DMARK "DEP" 
279c f5				push af  
279d 3a b1 27			ld a, (.dmark)  
27a0 32 77 fb			ld (debug_mark),a  
27a3 3a b2 27			ld a, (.dmark+1)  
27a6 32 78 fb			ld (debug_mark+1),a  
27a9 3a b3 27			ld a, (.dmark+2)  
27ac 32 79 fb			ld (debug_mark+2),a  
27af 18 03			jr .pastdmark  
27b1 ..			.dmark: db "DEP"  
27b4 f1			.pastdmark: pop af  
27b5			endm  
# End of macro DMARK
27b5						CALLMONITOR 
27b5 cd 19 17			call break_point_state  
27b8				endm  
# End of macro CALLMONITOR
27b8					endif 
27b8			 
27b8			 
27b8 2a 0a f8			ld hl, (cli_data_sp) 
27bb 11 84 f3			ld de, cli_data_stack 
27be ed 52			sbc hl,de 
27c0				 
27c0				; div by size of stack item 
27c0			 
27c0 5d				ld e,l 
27c1 0e 03			ld c, 3 
27c3 cd 99 0c			call Div8 
27c6			 
27c6 6f				ld l,a 
27c7 26 00			ld h,0 
27c9			 
27c9				;srl h 
27c9				;rr l 
27c9			 
27c9 cd a9 1c				call forth_push_numhl 
27cc					NEXTW 
27cc c3 12 20			jp macro_next 
27cf				endm 
# End of macro NEXTW
27cf			.OVER: 
27cf				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
27cf 42				db WORD_SYS_CORE+46             
27d0 16 28			dw .PAUSE            
27d2 05				db 4 + 1 
27d3 .. 00			db "OVER",0              
27d8				endm 
# End of macro CWHEAD
27d8			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
27d8					if DEBUG_FORTH_WORDS_KEY 
27d8						DMARK "OVR" 
27d8 f5				push af  
27d9 3a ed 27			ld a, (.dmark)  
27dc 32 77 fb			ld (debug_mark),a  
27df 3a ee 27			ld a, (.dmark+1)  
27e2 32 78 fb			ld (debug_mark+1),a  
27e5 3a ef 27			ld a, (.dmark+2)  
27e8 32 79 fb			ld (debug_mark+2),a  
27eb 18 03			jr .pastdmark  
27ed ..			.dmark: db "OVR"  
27f0 f1			.pastdmark: pop af  
27f1			endm  
# End of macro DMARK
27f1						CALLMONITOR 
27f1 cd 19 17			call break_point_state  
27f4				endm  
# End of macro CALLMONITOR
27f4					endif 
27f4			 
27f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27f4 cd a0 1e			call macro_dsp_valuehl 
27f7				endm 
# End of macro FORTH_DSP_VALUEHL
27f7 e5					push hl    ; n2 
27f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27f8 cd 58 1f			call macro_forth_dsp_pop 
27fb				endm 
# End of macro FORTH_DSP_POP
27fb			 
27fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27fb cd a0 1e			call macro_dsp_valuehl 
27fe				endm 
# End of macro FORTH_DSP_VALUEHL
27fe e5					push hl    ; n1 
27ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ff cd 58 1f			call macro_forth_dsp_pop 
2802				endm 
# End of macro FORTH_DSP_POP
2802			 
2802 d1					pop de     ; n1 
2803 e1					pop hl     ; n2 
2804			 
2804 d5					push de 
2805 e5					push hl 
2806 d5					push de 
2807			 
2807					; push back  
2807			 
2807 e1					pop hl 
2808 cd a9 1c				call forth_push_numhl 
280b e1					pop hl 
280c cd a9 1c				call forth_push_numhl 
280f e1					pop hl 
2810 cd a9 1c				call forth_push_numhl 
2813					NEXTW 
2813 c3 12 20			jp macro_next 
2816				endm 
# End of macro NEXTW
2816			 
2816			.PAUSE: 
2816				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2816 43				db WORD_SYS_CORE+47             
2817 4b 28			dw .PAUSES            
2819 08				db 7 + 1 
281a .. 00			db "PAUSEMS",0              
2822				endm 
# End of macro CWHEAD
2822			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2822					if DEBUG_FORTH_WORDS_KEY 
2822						DMARK "PMS" 
2822 f5				push af  
2823 3a 37 28			ld a, (.dmark)  
2826 32 77 fb			ld (debug_mark),a  
2829 3a 38 28			ld a, (.dmark+1)  
282c 32 78 fb			ld (debug_mark+1),a  
282f 3a 39 28			ld a, (.dmark+2)  
2832 32 79 fb			ld (debug_mark+2),a  
2835 18 03			jr .pastdmark  
2837 ..			.dmark: db "PMS"  
283a f1			.pastdmark: pop af  
283b			endm  
# End of macro DMARK
283b						CALLMONITOR 
283b cd 19 17			call break_point_state  
283e				endm  
# End of macro CALLMONITOR
283e					endif 
283e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
283e cd a0 1e			call macro_dsp_valuehl 
2841				endm 
# End of macro FORTH_DSP_VALUEHL
2841			;		push hl    ; n2 
2841					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2841 cd 58 1f			call macro_forth_dsp_pop 
2844				endm 
# End of macro FORTH_DSP_POP
2844			;		pop hl 
2844			 
2844 7d					ld a, l 
2845 cd 3a 0a				call aDelayInMS 
2848				       NEXTW 
2848 c3 12 20			jp macro_next 
284b				endm 
# End of macro NEXTW
284b			.PAUSES:  
284b				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
284b 44				db WORD_SYS_CORE+48             
284c ba 28			dw .ROT            
284e 06				db 5 + 1 
284f .. 00			db "PAUSE",0              
2855				endm 
# End of macro CWHEAD
2855			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2855					if DEBUG_FORTH_WORDS_KEY 
2855						DMARK "PAU" 
2855 f5				push af  
2856 3a 6a 28			ld a, (.dmark)  
2859 32 77 fb			ld (debug_mark),a  
285c 3a 6b 28			ld a, (.dmark+1)  
285f 32 78 fb			ld (debug_mark+1),a  
2862 3a 6c 28			ld a, (.dmark+2)  
2865 32 79 fb			ld (debug_mark+2),a  
2868 18 03			jr .pastdmark  
286a ..			.dmark: db "PAU"  
286d f1			.pastdmark: pop af  
286e			endm  
# End of macro DMARK
286e						CALLMONITOR 
286e cd 19 17			call break_point_state  
2871				endm  
# End of macro CALLMONITOR
2871					endif 
2871					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2871 cd a0 1e			call macro_dsp_valuehl 
2874				endm 
# End of macro FORTH_DSP_VALUEHL
2874			;		push hl    ; n2 
2874					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2874 cd 58 1f			call macro_forth_dsp_pop 
2877				endm 
# End of macro FORTH_DSP_POP
2877			;		pop hl 
2877 45					ld b, l 
2878					if DEBUG_FORTH_WORDS 
2878						DMARK "PAU" 
2878 f5				push af  
2879 3a 8d 28			ld a, (.dmark)  
287c 32 77 fb			ld (debug_mark),a  
287f 3a 8e 28			ld a, (.dmark+1)  
2882 32 78 fb			ld (debug_mark+1),a  
2885 3a 8f 28			ld a, (.dmark+2)  
2888 32 79 fb			ld (debug_mark+2),a  
288b 18 03			jr .pastdmark  
288d ..			.dmark: db "PAU"  
2890 f1			.pastdmark: pop af  
2891			endm  
# End of macro DMARK
2891						CALLMONITOR 
2891 cd 19 17			call break_point_state  
2894				endm  
# End of macro CALLMONITOR
2894					endif 
2894 c5			.pauses1:	push bc 
2895 cd 55 0a				call delay1s 
2898 c1					pop bc 
2899					if DEBUG_FORTH_WORDS 
2899						DMARK "PA1" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 77 fb			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 78 fb			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 79 fb			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "PA1"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2						CALLMONITOR 
28b2 cd 19 17			call break_point_state  
28b5				endm  
# End of macro CALLMONITOR
28b5					endif 
28b5 10 dd				djnz .pauses1 
28b7			 
28b7				       NEXTW 
28b7 c3 12 20			jp macro_next 
28ba				endm 
# End of macro NEXTW
28ba			.ROT: 
28ba				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
28ba 45				db WORD_SYS_CORE+49             
28bb 08 29			dw .UWORDS            
28bd 04				db 3 + 1 
28be .. 00			db "ROT",0              
28c2				endm 
# End of macro CWHEAD
28c2			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
28c2					if DEBUG_FORTH_WORDS_KEY 
28c2						DMARK "ROT" 
28c2 f5				push af  
28c3 3a d7 28			ld a, (.dmark)  
28c6 32 77 fb			ld (debug_mark),a  
28c9 3a d8 28			ld a, (.dmark+1)  
28cc 32 78 fb			ld (debug_mark+1),a  
28cf 3a d9 28			ld a, (.dmark+2)  
28d2 32 79 fb			ld (debug_mark+2),a  
28d5 18 03			jr .pastdmark  
28d7 ..			.dmark: db "ROT"  
28da f1			.pastdmark: pop af  
28db			endm  
# End of macro DMARK
28db						CALLMONITOR 
28db cd 19 17			call break_point_state  
28de				endm  
# End of macro CALLMONITOR
28de					endif 
28de			 
28de					FORTH_DSP_VALUEHL 
28de cd a0 1e			call macro_dsp_valuehl 
28e1				endm 
# End of macro FORTH_DSP_VALUEHL
28e1 e5					push hl    ; u3  
28e2			 
28e2					FORTH_DSP_POP 
28e2 cd 58 1f			call macro_forth_dsp_pop 
28e5				endm 
# End of macro FORTH_DSP_POP
28e5			   
28e5					FORTH_DSP_VALUEHL 
28e5 cd a0 1e			call macro_dsp_valuehl 
28e8				endm 
# End of macro FORTH_DSP_VALUEHL
28e8 e5					push hl     ; u2 
28e9			 
28e9					FORTH_DSP_POP 
28e9 cd 58 1f			call macro_forth_dsp_pop 
28ec				endm 
# End of macro FORTH_DSP_POP
28ec			 
28ec					FORTH_DSP_VALUEHL 
28ec cd a0 1e			call macro_dsp_valuehl 
28ef				endm 
# End of macro FORTH_DSP_VALUEHL
28ef e5					push hl     ; u1 
28f0			 
28f0					FORTH_DSP_POP 
28f0 cd 58 1f			call macro_forth_dsp_pop 
28f3				endm 
# End of macro FORTH_DSP_POP
28f3			 
28f3 c1					pop bc      ; u1 
28f4 e1					pop hl      ; u2 
28f5 d1					pop de      ; u3 
28f6			 
28f6			 
28f6 c5					push bc 
28f7 d5					push de 
28f8 e5					push hl 
28f9			 
28f9			 
28f9 e1					pop hl 
28fa cd a9 1c				call forth_push_numhl 
28fd			 
28fd e1					pop hl 
28fe cd a9 1c				call forth_push_numhl 
2901			 
2901 e1					pop hl 
2902 cd a9 1c				call forth_push_numhl 
2905					 
2905			 
2905			 
2905			 
2905			 
2905			 
2905				       NEXTW 
2905 c3 12 20			jp macro_next 
2908				endm 
# End of macro NEXTW
2908			 
2908			.UWORDS: 
2908				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2908 50				db WORD_SYS_CORE+60             
2909 ca 29			dw .BP            
290b 07				db 6 + 1 
290c .. 00			db "UWORDS",0              
2913				endm 
# End of macro CWHEAD
2913			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2913			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2913			; | | Following the count are the individual words. 
2913			; | | 
2913			; | | e.g. UWORDS 
2913			; | | BOX DIRLIST 2 
2913			; | |  
2913			; | | Can be used to save the words to storage via: 
2913			; | | UWORDS $01 DO $01 APPEND LOOP 
2913				if DEBUG_FORTH_WORDS_KEY 
2913					DMARK "UWR" 
2913 f5				push af  
2914 3a 28 29			ld a, (.dmark)  
2917 32 77 fb			ld (debug_mark),a  
291a 3a 29 29			ld a, (.dmark+1)  
291d 32 78 fb			ld (debug_mark+1),a  
2920 3a 2a 29			ld a, (.dmark+2)  
2923 32 79 fb			ld (debug_mark+2),a  
2926 18 03			jr .pastdmark  
2928 ..			.dmark: db "UWR"  
292b f1			.pastdmark: pop af  
292c			endm  
# End of macro DMARK
292c					CALLMONITOR 
292c cd 19 17			call break_point_state  
292f				endm  
# End of macro CALLMONITOR
292f				endif 
292f 21 00 80				ld hl, baseram 
2932					;ld hl, baseusermem 
2932 01 00 00				ld bc, 0    ; start a counter 
2935			 
2935				; skip dict stub 
2935			 
2935 cd 63 21				call forth_tok_next 
2938			 
2938			 
2938			; while we have words to look for 
2938			 
2938 7e			.douscan:	ld a, (hl)      
2939				if DEBUG_FORTH_WORDS 
2939					DMARK "UWs" 
2939 f5				push af  
293a 3a 4e 29			ld a, (.dmark)  
293d 32 77 fb			ld (debug_mark),a  
2940 3a 4f 29			ld a, (.dmark+1)  
2943 32 78 fb			ld (debug_mark+1),a  
2946 3a 50 29			ld a, (.dmark+2)  
2949 32 79 fb			ld (debug_mark+2),a  
294c 18 03			jr .pastdmark  
294e ..			.dmark: db "UWs"  
2951 f1			.pastdmark: pop af  
2952			endm  
# End of macro DMARK
2952					CALLMONITOR 
2952 cd 19 17			call break_point_state  
2955				endm  
# End of macro CALLMONITOR
2955				endif 
2955 fe 00				cp WORD_SYS_END 
2957 28 4d				jr z, .udone 
2959 fe 01				cp WORD_SYS_UWORD 
295b 20 44				jr nz, .nuword 
295d			 
295d				if DEBUG_FORTH_WORDS 
295d					DMARK "UWu" 
295d f5				push af  
295e 3a 72 29			ld a, (.dmark)  
2961 32 77 fb			ld (debug_mark),a  
2964 3a 73 29			ld a, (.dmark+1)  
2967 32 78 fb			ld (debug_mark+1),a  
296a 3a 74 29			ld a, (.dmark+2)  
296d 32 79 fb			ld (debug_mark+2),a  
2970 18 03			jr .pastdmark  
2972 ..			.dmark: db "UWu"  
2975 f1			.pastdmark: pop af  
2976			endm  
# End of macro DMARK
2976					CALLMONITOR 
2976 cd 19 17			call break_point_state  
2979				endm  
# End of macro CALLMONITOR
2979				endif 
2979					; we have a uword so push its name to the stack 
2979			 
2979 e5				   	push hl  ; save so we can move to next dict block 
297a			 
297a					; skip opcode 
297a 23					inc hl  
297b					; skip next ptr 
297b 23					inc hl  
297c 23					inc hl 
297d					; skip len 
297d 23					inc hl 
297e				if DEBUG_FORTH_WORDS 
297e					DMARK "UWt" 
297e f5				push af  
297f 3a 93 29			ld a, (.dmark)  
2982 32 77 fb			ld (debug_mark),a  
2985 3a 94 29			ld a, (.dmark+1)  
2988 32 78 fb			ld (debug_mark+1),a  
298b 3a 95 29			ld a, (.dmark+2)  
298e 32 79 fb			ld (debug_mark+2),a  
2991 18 03			jr .pastdmark  
2993 ..			.dmark: db "UWt"  
2996 f1			.pastdmark: pop af  
2997			endm  
# End of macro DMARK
2997					CALLMONITOR 
2997 cd 19 17			call break_point_state  
299a				endm  
# End of macro CALLMONITOR
299a				endif 
299a 03					inc bc 
299b			 
299b c5					push bc 
299c cd 17 1d				call forth_push_str 
299f c1					pop bc 
29a0			 
29a0 e1					pop hl 	 
29a1			 
29a1 cd 63 21		.nuword:	call forth_tok_next 
29a4 18 92				jr .douscan  
29a6			 
29a6			.udone:		 ; push count of uwords found 
29a6 c5					push bc 
29a7 e1					pop hl 
29a8			 
29a8				if DEBUG_FORTH_WORDS 
29a8					DMARK "UWc" 
29a8 f5				push af  
29a9 3a bd 29			ld a, (.dmark)  
29ac 32 77 fb			ld (debug_mark),a  
29af 3a be 29			ld a, (.dmark+1)  
29b2 32 78 fb			ld (debug_mark+1),a  
29b5 3a bf 29			ld a, (.dmark+2)  
29b8 32 79 fb			ld (debug_mark+2),a  
29bb 18 03			jr .pastdmark  
29bd ..			.dmark: db "UWc"  
29c0 f1			.pastdmark: pop af  
29c1			endm  
# End of macro DMARK
29c1					CALLMONITOR 
29c1 cd 19 17			call break_point_state  
29c4				endm  
# End of macro CALLMONITOR
29c4				endif 
29c4 cd a9 1c				call forth_push_numhl 
29c7			 
29c7			 
29c7				       NEXTW 
29c7 c3 12 20			jp macro_next 
29ca				endm 
# End of macro NEXTW
29ca			 
29ca			.BP: 
29ca				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
29ca 54				db WORD_SYS_CORE+64             
29cb 00 2a			dw .MONITOR            
29cd 03				db 2 + 1 
29ce .. 00			db "BP",0              
29d1				endm 
# End of macro CWHEAD
29d1			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
29d1			; | | $00 Will enable the break points within specific code paths 
29d1			; | | $01 Will disable break points 
29d1			; | |  
29d1			; | | By default break points are off. Either the above can be used to enable them 
29d1			; | | or if a key is held down during start up the spashscreen will appear to freeze 
29d1			; | | and on release of the pressed key a message will be disaplayed to notify 
29d1			; | | that break points are enabled. Pressing any key will then continue boot process. 
29d1					; get byte count 
29d1					if DEBUG_FORTH_WORDS_KEY 
29d1						DMARK "BP." 
29d1 f5				push af  
29d2 3a e6 29			ld a, (.dmark)  
29d5 32 77 fb			ld (debug_mark),a  
29d8 3a e7 29			ld a, (.dmark+1)  
29db 32 78 fb			ld (debug_mark+1),a  
29de 3a e8 29			ld a, (.dmark+2)  
29e1 32 79 fb			ld (debug_mark+2),a  
29e4 18 03			jr .pastdmark  
29e6 ..			.dmark: db "BP."  
29e9 f1			.pastdmark: pop af  
29ea			endm  
# End of macro DMARK
29ea						CALLMONITOR 
29ea cd 19 17			call break_point_state  
29ed				endm  
# End of macro CALLMONITOR
29ed					endif 
29ed			 
29ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29ed cd a0 1e			call macro_dsp_valuehl 
29f0				endm 
# End of macro FORTH_DSP_VALUEHL
29f0			 
29f0			;		push hl 
29f0			 
29f0					; destroy value TOS 
29f0			 
29f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29f0 cd 58 1f			call macro_forth_dsp_pop 
29f3				endm 
# End of macro FORTH_DSP_POP
29f3			 
29f3			;		pop hl 
29f3			 
29f3 3e 00				ld a,0 
29f5 bd					cp l 
29f6 28 02				jr z, .bpset 
29f8 3e 2a				ld a, '*' 
29fa			 
29fa 32 0e ee		.bpset:		ld (os_view_disable), a 
29fd			 
29fd			 
29fd					NEXTW 
29fd c3 12 20			jp macro_next 
2a00				endm 
# End of macro NEXTW
2a00			 
2a00			 
2a00			.MONITOR: 
2a00				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2a00 55				db WORD_SYS_CORE+65             
2a01 33 2a			dw .MALLOC            
2a03 08				db 7 + 1 
2a04 .. 00			db "MONITOR",0              
2a0c				endm 
# End of macro CWHEAD
2a0c			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2a0c			; | | At start the current various registers will be displayed with contents. 
2a0c			; | | Top right corner will show the most recent debug marker seen. 
2a0c			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2a0c			; | | and the return stack pointer (RSP). 
2a0c			; | | Pressing: 
2a0c			; | |    1 - Initial screen 
2a0c			; | |    2 - Display a data dump of HL 
2a0c			; | |    3 - Display a data dump of DE 
2a0c			; | |    4 - Display a data dump of BC 
2a0c			; | |    5 - Display a data dump of HL 
2a0c			; | |    6 - Display a data dump of DSP 
2a0c			; | |    7 - Display a data dump of RSP 
2a0c			; | |    8 - Display a data dump of what is at DSP 
2a0c			; | |    9 - Display a data dump of what is at RSP 
2a0c			; | |    0 - Exit monitor and continue running. This will also enable break points 
2a0c			; | |    * - Disable break points 
2a0c			; | |    # - Enter traditional monitor mode 
2a0c			; | | 
2a0c			; | | Monitor Mode 
2a0c			; | | ------------ 
2a0c			; | | A prompt of '>' will be shown for various commands: 
2a0c			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2a0c			; | |    C - Continue display a data dump from the last set address 
2a0c			; | |    M xxxx - Set start of memory edit at address xx 
2a0c			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2a0c			; | |    Q - Return to previous 
2a0c					if DEBUG_FORTH_WORDS_KEY 
2a0c						DMARK "MON" 
2a0c f5				push af  
2a0d 3a 21 2a			ld a, (.dmark)  
2a10 32 77 fb			ld (debug_mark),a  
2a13 3a 22 2a			ld a, (.dmark+1)  
2a16 32 78 fb			ld (debug_mark+1),a  
2a19 3a 23 2a			ld a, (.dmark+2)  
2a1c 32 79 fb			ld (debug_mark+2),a  
2a1f 18 03			jr .pastdmark  
2a21 ..			.dmark: db "MON"  
2a24 f1			.pastdmark: pop af  
2a25			endm  
# End of macro DMARK
2a25						CALLMONITOR 
2a25 cd 19 17			call break_point_state  
2a28				endm  
# End of macro CALLMONITOR
2a28					endif 
2a28 3e 00				ld a, 0 
2a2a 32 0e ee				ld (os_view_disable), a 
2a2d			 
2a2d					CALLMONITOR 
2a2d cd 19 17			call break_point_state  
2a30				endm  
# End of macro CALLMONITOR
2a30			 
2a30			;	call monitor 
2a30			 
2a30					NEXTW 
2a30 c3 12 20			jp macro_next 
2a33				endm 
# End of macro NEXTW
2a33			 
2a33			 
2a33			.MALLOC: 
2a33				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2a33 56				db WORD_SYS_CORE+66             
2a34 5c 2a			dw .MALLOC2            
2a36 06				db 5 + 1 
2a37 .. 00			db "ALLOT",0              
2a3d				endm 
# End of macro CWHEAD
2a3d			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a3d					if DEBUG_FORTH_WORDS_KEY 
2a3d						DMARK "ALL" 
2a3d f5				push af  
2a3e 3a 52 2a			ld a, (.dmark)  
2a41 32 77 fb			ld (debug_mark),a  
2a44 3a 53 2a			ld a, (.dmark+1)  
2a47 32 78 fb			ld (debug_mark+1),a  
2a4a 3a 54 2a			ld a, (.dmark+2)  
2a4d 32 79 fb			ld (debug_mark+2),a  
2a50 18 03			jr .pastdmark  
2a52 ..			.dmark: db "ALL"  
2a55 f1			.pastdmark: pop af  
2a56			endm  
# End of macro DMARK
2a56						CALLMONITOR 
2a56 cd 19 17			call break_point_state  
2a59				endm  
# End of macro CALLMONITOR
2a59					endif 
2a59 c3 83 2a				jp .mallocc 
2a5c			.MALLOC2: 
2a5c				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a5c 56				db WORD_SYS_CORE+66             
2a5d 9a 2a			dw .FREE            
2a5f 07				db 6 + 1 
2a60 .. 00			db "MALLOC",0              
2a67				endm 
# End of macro CWHEAD
2a67			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a67					; get byte count 
2a67					if DEBUG_FORTH_WORDS_KEY 
2a67						DMARK "MAL" 
2a67 f5				push af  
2a68 3a 7c 2a			ld a, (.dmark)  
2a6b 32 77 fb			ld (debug_mark),a  
2a6e 3a 7d 2a			ld a, (.dmark+1)  
2a71 32 78 fb			ld (debug_mark+1),a  
2a74 3a 7e 2a			ld a, (.dmark+2)  
2a77 32 79 fb			ld (debug_mark+2),a  
2a7a 18 03			jr .pastdmark  
2a7c ..			.dmark: db "MAL"  
2a7f f1			.pastdmark: pop af  
2a80			endm  
# End of macro DMARK
2a80						CALLMONITOR 
2a80 cd 19 17			call break_point_state  
2a83				endm  
# End of macro CALLMONITOR
2a83					endif 
2a83			.mallocc: 
2a83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a83 cd a0 1e			call macro_dsp_valuehl 
2a86				endm 
# End of macro FORTH_DSP_VALUEHL
2a86			 
2a86			;		push hl 
2a86			 
2a86					; destroy value TOS 
2a86			 
2a86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a86 cd 58 1f			call macro_forth_dsp_pop 
2a89				endm 
# End of macro FORTH_DSP_POP
2a89			 
2a89			;		pop hl 
2a89 cd d0 11				call malloc 
2a8c				if DEBUG_FORTH_MALLOC_GUARD 
2a8c f5					push af 
2a8d cd 32 0d				call ishlzero 
2a90			;		ld a, l 
2a90			;		add h 
2a90			;		cp 0 
2a90 f1					pop af 
2a91					 
2a91 cc cd 52				call z,malloc_error 
2a94				endif 
2a94			 
2a94 cd a9 1c				call forth_push_numhl 
2a97					NEXTW 
2a97 c3 12 20			jp macro_next 
2a9a				endm 
# End of macro NEXTW
2a9a			 
2a9a			.FREE: 
2a9a				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a9a 57				db WORD_SYS_CORE+67             
2a9b cb 2a			dw .LIST            
2a9d 05				db 4 + 1 
2a9e .. 00			db "FREE",0              
2aa3				endm 
# End of macro CWHEAD
2aa3			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2aa3					if DEBUG_FORTH_WORDS_KEY 
2aa3						DMARK "FRE" 
2aa3 f5				push af  
2aa4 3a b8 2a			ld a, (.dmark)  
2aa7 32 77 fb			ld (debug_mark),a  
2aaa 3a b9 2a			ld a, (.dmark+1)  
2aad 32 78 fb			ld (debug_mark+1),a  
2ab0 3a ba 2a			ld a, (.dmark+2)  
2ab3 32 79 fb			ld (debug_mark+2),a  
2ab6 18 03			jr .pastdmark  
2ab8 ..			.dmark: db "FRE"  
2abb f1			.pastdmark: pop af  
2abc			endm  
# End of macro DMARK
2abc						CALLMONITOR 
2abc cd 19 17			call break_point_state  
2abf				endm  
# End of macro CALLMONITOR
2abf					endif 
2abf					; get address 
2abf			 
2abf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2abf cd a0 1e			call macro_dsp_valuehl 
2ac2				endm 
# End of macro FORTH_DSP_VALUEHL
2ac2			 
2ac2			;		push hl 
2ac2			 
2ac2					; destroy value TOS 
2ac2			 
2ac2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ac2 cd 58 1f			call macro_forth_dsp_pop 
2ac5				endm 
# End of macro FORTH_DSP_POP
2ac5			 
2ac5			;		pop hl 
2ac5			if FORTH_ENABLE_MALLOCFREE 
2ac5 cd 9a 12				call free 
2ac8			endif 
2ac8					NEXTW 
2ac8 c3 12 20			jp macro_next 
2acb				endm 
# End of macro NEXTW
2acb			.LIST: 
2acb				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2acb 5c				db WORD_SYS_CORE+72             
2acc 8e 2c			dw .FORGET            
2ace 05				db 4 + 1 
2acf .. 00			db "LIST",0              
2ad4				endm 
# End of macro CWHEAD
2ad4			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2ad4			; | | The quoted word must be in upper case. 
2ad4				if DEBUG_FORTH_WORDS_KEY 
2ad4					DMARK "LST" 
2ad4 f5				push af  
2ad5 3a e9 2a			ld a, (.dmark)  
2ad8 32 77 fb			ld (debug_mark),a  
2adb 3a ea 2a			ld a, (.dmark+1)  
2ade 32 78 fb			ld (debug_mark+1),a  
2ae1 3a eb 2a			ld a, (.dmark+2)  
2ae4 32 79 fb			ld (debug_mark+2),a  
2ae7 18 03			jr .pastdmark  
2ae9 ..			.dmark: db "LST"  
2aec f1			.pastdmark: pop af  
2aed			endm  
# End of macro DMARK
2aed					CALLMONITOR 
2aed cd 19 17			call break_point_state  
2af0				endm  
# End of macro CALLMONITOR
2af0				endif 
2af0			 
2af0					FORTH_DSP_VALUEHL 
2af0 cd a0 1e			call macro_dsp_valuehl 
2af3				endm 
# End of macro FORTH_DSP_VALUEHL
2af3			 
2af3 e5					push hl 
2af4 c1					pop bc 
2af5			 
2af5			; Start format of scratch string 
2af5			 
2af5 21 1d ee				ld hl, scratch 
2af8			 
2af8 3e 3a				ld a, ':' 
2afa 77					ld (hl),a 
2afb 23					inc hl 
2afc 3e 20				ld a, ' ' 
2afe 77					ld (hl), a 
2aff			 
2aff					; Get ptr to the word we need to look up 
2aff			 
2aff			;		FORTH_DSP_VALUEHL 
2aff					;v5 FORTH_DSP_VALUE 
2aff				; TODO type check 
2aff			;		inc hl    ; Skip type check  
2aff			;		push hl 
2aff			;		ex de, hl    ; put into DE 
2aff			 
2aff			 
2aff 21 00 80				ld hl, baseram 
2b02					;ld hl, baseusermem 
2b02			 
2b02 e5			push hl   ; sacreifical push 
2b03			 
2b03			.ldouscanm: 
2b03 e1				pop hl 
2b04			.ldouscan: 
2b04				if DEBUG_FORTH_WORDS 
2b04					DMARK "LSs" 
2b04 f5				push af  
2b05 3a 19 2b			ld a, (.dmark)  
2b08 32 77 fb			ld (debug_mark),a  
2b0b 3a 1a 2b			ld a, (.dmark+1)  
2b0e 32 78 fb			ld (debug_mark+1),a  
2b11 3a 1b 2b			ld a, (.dmark+2)  
2b14 32 79 fb			ld (debug_mark+2),a  
2b17 18 03			jr .pastdmark  
2b19 ..			.dmark: db "LSs"  
2b1c f1			.pastdmark: pop af  
2b1d			endm  
# End of macro DMARK
2b1d					CALLMONITOR 
2b1d cd 19 17			call break_point_state  
2b20				endm  
# End of macro CALLMONITOR
2b20				endif 
2b20				; skip dict stub 
2b20 cd 63 21				call forth_tok_next 
2b23			 
2b23			 
2b23			; while we have words to look for 
2b23			 
2b23 7e				ld a, (hl)      
2b24				if DEBUG_FORTH_WORDS 
2b24					DMARK "LSk" 
2b24 f5				push af  
2b25 3a 39 2b			ld a, (.dmark)  
2b28 32 77 fb			ld (debug_mark),a  
2b2b 3a 3a 2b			ld a, (.dmark+1)  
2b2e 32 78 fb			ld (debug_mark+1),a  
2b31 3a 3b 2b			ld a, (.dmark+2)  
2b34 32 79 fb			ld (debug_mark+2),a  
2b37 18 03			jr .pastdmark  
2b39 ..			.dmark: db "LSk"  
2b3c f1			.pastdmark: pop af  
2b3d			endm  
# End of macro DMARK
2b3d					CALLMONITOR 
2b3d cd 19 17			call break_point_state  
2b40				endm  
# End of macro CALLMONITOR
2b40				endif 
2b40 fe 00				cp WORD_SYS_END 
2b42 ca 75 2c				jp z, .lunotfound 
2b45 fe 01				cp WORD_SYS_UWORD 
2b47 c2 04 2b				jp nz, .ldouscan 
2b4a			 
2b4a				if DEBUG_FORTH_WORDS 
2b4a					DMARK "LSu" 
2b4a f5				push af  
2b4b 3a 5f 2b			ld a, (.dmark)  
2b4e 32 77 fb			ld (debug_mark),a  
2b51 3a 60 2b			ld a, (.dmark+1)  
2b54 32 78 fb			ld (debug_mark+1),a  
2b57 3a 61 2b			ld a, (.dmark+2)  
2b5a 32 79 fb			ld (debug_mark+2),a  
2b5d 18 03			jr .pastdmark  
2b5f ..			.dmark: db "LSu"  
2b62 f1			.pastdmark: pop af  
2b63			endm  
# End of macro DMARK
2b63					CALLMONITOR 
2b63 cd 19 17			call break_point_state  
2b66				endm  
# End of macro CALLMONITOR
2b66				endif 
2b66			 
2b66					; found a uword but is it the one we want... 
2b66			 
2b66 c5					push bc     ; uword to find is on bc 
2b67 d1					pop de 
2b68			 
2b68 e5					push hl  ; to save the ptr 
2b69			 
2b69					; skip opcode 
2b69 23					inc hl  
2b6a					; skip next ptr 
2b6a 23					inc hl  
2b6b 23					inc hl 
2b6c					; skip len 
2b6c 23					inc hl 
2b6d			 
2b6d				if DEBUG_FORTH_WORDS 
2b6d					DMARK "LSc" 
2b6d f5				push af  
2b6e 3a 82 2b			ld a, (.dmark)  
2b71 32 77 fb			ld (debug_mark),a  
2b74 3a 83 2b			ld a, (.dmark+1)  
2b77 32 78 fb			ld (debug_mark+1),a  
2b7a 3a 84 2b			ld a, (.dmark+2)  
2b7d 32 79 fb			ld (debug_mark+2),a  
2b80 18 03			jr .pastdmark  
2b82 ..			.dmark: db "LSc"  
2b85 f1			.pastdmark: pop af  
2b86			endm  
# End of macro DMARK
2b86					CALLMONITOR 
2b86 cd 19 17			call break_point_state  
2b89				endm  
# End of macro CALLMONITOR
2b89				endif 
2b89 cd 9f 11				call strcmp 
2b8c c2 03 2b				jp nz, .ldouscanm 
2b8f				 
2b8f			 
2b8f			 
2b8f					; we have a uword so push its name to the stack 
2b8f			 
2b8f			;	   	push hl  ; save so we can move to next dict block 
2b8f e1			pop hl 
2b90			 
2b90				if DEBUG_FORTH_WORDS 
2b90					DMARK "LSm" 
2b90 f5				push af  
2b91 3a a5 2b			ld a, (.dmark)  
2b94 32 77 fb			ld (debug_mark),a  
2b97 3a a6 2b			ld a, (.dmark+1)  
2b9a 32 78 fb			ld (debug_mark+1),a  
2b9d 3a a7 2b			ld a, (.dmark+2)  
2ba0 32 79 fb			ld (debug_mark+2),a  
2ba3 18 03			jr .pastdmark  
2ba5 ..			.dmark: db "LSm"  
2ba8 f1			.pastdmark: pop af  
2ba9			endm  
# End of macro DMARK
2ba9					CALLMONITOR 
2ba9 cd 19 17			call break_point_state  
2bac				endm  
# End of macro CALLMONITOR
2bac				endif 
2bac			 
2bac					; skip opcode 
2bac 23					inc hl  
2bad					; skip next ptr 
2bad 23					inc hl  
2bae 23					inc hl 
2baf					; skip len 
2baf 7e					ld a, (hl)   ; save length to add 
2bb0				if DEBUG_FORTH_WORDS 
2bb0					DMARK "LS2" 
2bb0 f5				push af  
2bb1 3a c5 2b			ld a, (.dmark)  
2bb4 32 77 fb			ld (debug_mark),a  
2bb7 3a c6 2b			ld a, (.dmark+1)  
2bba 32 78 fb			ld (debug_mark+1),a  
2bbd 3a c7 2b			ld a, (.dmark+2)  
2bc0 32 79 fb			ld (debug_mark+2),a  
2bc3 18 03			jr .pastdmark  
2bc5 ..			.dmark: db "LS2"  
2bc8 f1			.pastdmark: pop af  
2bc9			endm  
# End of macro DMARK
2bc9					CALLMONITOR 
2bc9 cd 19 17			call break_point_state  
2bcc				endm  
# End of macro CALLMONITOR
2bcc				endif 
2bcc			 
2bcc					; save this location 
2bcc				 
2bcc e5					push hl 
2bcd			 
2bcd 23					inc hl 
2bce 11 1f ee				ld de, scratch+2 
2bd1 4f					ld c, a 
2bd2 06 00				ld b, 0 
2bd4			 
2bd4				if DEBUG_FORTH_WORDS 
2bd4					DMARK "LSn" 
2bd4 f5				push af  
2bd5 3a e9 2b			ld a, (.dmark)  
2bd8 32 77 fb			ld (debug_mark),a  
2bdb 3a ea 2b			ld a, (.dmark+1)  
2bde 32 78 fb			ld (debug_mark+1),a  
2be1 3a eb 2b			ld a, (.dmark+2)  
2be4 32 79 fb			ld (debug_mark+2),a  
2be7 18 03			jr .pastdmark  
2be9 ..			.dmark: db "LSn"  
2bec f1			.pastdmark: pop af  
2bed			endm  
# End of macro DMARK
2bed					CALLMONITOR 
2bed cd 19 17			call break_point_state  
2bf0				endm  
# End of macro CALLMONITOR
2bf0				endif 
2bf0			 
2bf0					; copy uword name to scratch 
2bf0			 
2bf0 ed b0				ldir 
2bf2			 
2bf2 1b					dec de 
2bf3 3e 20				ld a, ' '    ; change null to space 
2bf5 12					ld (de), a 
2bf6			 
2bf6 13					inc de 
2bf7			 
2bf7 d5					push de 
2bf8 c1					pop bc     ; move scratch pointer to end of word name and save it 
2bf9			 
2bf9 e1					pop hl 
2bfa 7e					ld a, (hl) 
2bfb					;inc hl 
2bfb					; skip word string 
2bfb cd 09 0d				call addatohl 
2bfe			 
2bfe 23					inc hl 
2bff			 
2bff				if DEBUG_FORTH_WORDS 
2bff					DMARK "LS3" 
2bff f5				push af  
2c00 3a 14 2c			ld a, (.dmark)  
2c03 32 77 fb			ld (debug_mark),a  
2c06 3a 15 2c			ld a, (.dmark+1)  
2c09 32 78 fb			ld (debug_mark+1),a  
2c0c 3a 16 2c			ld a, (.dmark+2)  
2c0f 32 79 fb			ld (debug_mark+2),a  
2c12 18 03			jr .pastdmark  
2c14 ..			.dmark: db "LS3"  
2c17 f1			.pastdmark: pop af  
2c18			endm  
# End of macro DMARK
2c18					CALLMONITOR 
2c18 cd 19 17			call break_point_state  
2c1b				endm  
# End of macro CALLMONITOR
2c1b				endif 
2c1b					; should now be at the start of the machine code to setup the eval of the uword 
2c1b					; now locate the ptr to the string defintion 
2c1b			 
2c1b					; skip ld hl, 
2c1b					; then load the ptr 
2c1b			 
2c1b 23					inc hl 
2c1c 5e					ld e, (hl) 
2c1d 23					inc hl 
2c1e 56					ld d, (hl) 
2c1f eb					ex de, hl 
2c20			 
2c20			 
2c20				if DEBUG_FORTH_WORDS 
2c20					DMARK "LSt" 
2c20 f5				push af  
2c21 3a 35 2c			ld a, (.dmark)  
2c24 32 77 fb			ld (debug_mark),a  
2c27 3a 36 2c			ld a, (.dmark+1)  
2c2a 32 78 fb			ld (debug_mark+1),a  
2c2d 3a 37 2c			ld a, (.dmark+2)  
2c30 32 79 fb			ld (debug_mark+2),a  
2c33 18 03			jr .pastdmark  
2c35 ..			.dmark: db "LSt"  
2c38 f1			.pastdmark: pop af  
2c39			endm  
# End of macro DMARK
2c39					CALLMONITOR 
2c39 cd 19 17			call break_point_state  
2c3c				endm  
# End of macro CALLMONITOR
2c3c				endif 
2c3c			 
2c3c			; cant push right now due to tokenised strings  
2c3c			 
2c3c			; get the destination of where to copy this definition to. 
2c3c			 
2c3c c5					push bc 
2c3d d1					pop de 
2c3e			 
2c3e 7e			.listl:         ld a,(hl) 
2c3f fe 00				cp 0 
2c41 28 09				jr z, .lreplsp     ; replace zero with space 
2c43 fe 7f				cp FORTH_END_BUFFER 
2c45 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c47				 
2c47					; just copy this char as is then 
2c47			 
2c47 12					ld (de), a 
2c48			 
2c48 23			.listnxt:	inc hl 
2c49 13					inc de 
2c4a 18 f2				jr .listl 
2c4c			 
2c4c 3e 20		.lreplsp:	ld a,' ' 
2c4e 12					ld (de), a 
2c4f 18 f7				jr .listnxt 
2c51			 
2c51			; close up uword def 
2c51			 
2c51			.listdone: 
2c51 3e 00				ld a, 0 
2c53 12					ld (de), a 
2c54			 
2c54			; now have def so clean up and push to stack 
2c54			 
2c54 21 1d ee				ld hl, scratch 
2c57				if DEBUG_FORTH_WORDS 
2c57					DMARK "Ltp" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 77 fb			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 78 fb			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 79 fb			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "Ltp"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70					CALLMONITOR 
2c70 cd 19 17			call break_point_state  
2c73				endm  
# End of macro CALLMONITOR
2c73				endif 
2c73			 
2c73 18 06			jr .listpush 
2c75			 
2c75			;.lnuword:	pop hl 
2c75			;		call forth_tok_next 
2c75			;		jp .ldouscan  
2c75			 
2c75			.lunotfound:		  
2c75			 
2c75			 
2c75					 
2c75					FORTH_DSP_POP 
2c75 cd 58 1f			call macro_forth_dsp_pop 
2c78				endm 
# End of macro FORTH_DSP_POP
2c78 21 81 2c				ld hl, .luno 
2c7b						 
2c7b			 
2c7b			.listpush: 
2c7b cd 17 1d				call forth_push_str 
2c7e			 
2c7e			 
2c7e			 
2c7e					NEXTW 
2c7e c3 12 20			jp macro_next 
2c81				endm 
# End of macro NEXTW
2c81			 
2c81 .. 00		.luno:    db "Not found",0 
2c8b			 
2c8b			 
2c8b			 
2c8b			 
2c8b			 
2c8b			;		push hl   ; save pointer to start of uword def string 
2c8b			; 
2c8b			;; look for FORTH_EOL_LINE 
2c8b			;		ld a, FORTH_END_BUFFER 
2c8b			;		call strlent 
2c8b			; 
2c8b			;		inc hl		 ; space for coln def 
2c8b			;		inc hl 
2c8b			;		inc hl          ; space for terms 
2c8b			;		inc hl 
2c8b			; 
2c8b			;		ld a, 20   ; TODO get actual length 
2c8b			;		call addatohl    ; include a random amount of room for the uword name 
2c8b			; 
2c8b			;		 
2c8b			;	if DEBUG_FORTH_WORDS 
2c8b			;		DMARK "Lt1" 
2c8b			;		CALLMONITOR 
2c8b			;	endif 
2c8b			;		 
2c8b			; 
2c8b			;; malloc space for the string because we cant change it 
2c8b			; 
2c8b			;		call malloc 
2c8b			;	if DEBUG_FORTH_MALLOC_GUARD 
2c8b			;		push af 
2c8b			;		call ishlzero 
2c8b			;		pop af 
2c8b			;		 
2c8b			;		call z,malloc_error 
2c8b			;	endif 
2c8b			; 
2c8b			;	if DEBUG_FORTH_WORDS 
2c8b			;		DMARK "Lt2" 
2c8b			;		CALLMONITOR 
2c8b			;	endif 
2c8b			;		pop de 
2c8b			;		push hl    ; push the malloc to release later 
2c8b			;		push hl   ;  push back a copy for the later stack push 
2c8b			;		 
2c8b			;; copy the string swapping out the zero terms for spaces 
2c8b			; 
2c8b			;		; de has our source 
2c8b			;		; hl has our dest 
2c8b			; 
2c8b			;; add the coln def 
2c8b			; 
2c8b			;		ld a, ':' 
2c8b			;		ld (hl), a 
2c8b			;		inc hl 
2c8b			;		ld a, ' ' 
2c8b			;		ld (hl), a 
2c8b			;		inc hl 
2c8b			; 
2c8b			;; add the uname word 
2c8b			;		push de   ; save our string for now 
2c8b			;		ex de, hl 
2c8b			; 
2c8b			;		FORTH_DSP_VALUE 
2c8b			;		;v5 FORTH_DSP_VALUE 
2c8b			; 
2c8b			;		inc hl   ; skip type but we know by now this is OK 
2c8b			; 
2c8b			;.luword:	ld a,(hl) 
2c8b			;		cp 0 
2c8b			;		jr z, .luword2 
2c8b			;		ld (de), a 
2c8b			;		inc de 
2c8b			;		inc hl 
2c8b			;		jr .luword 
2c8b			; 
2c8b			;.luword2:	ld a, ' ' 
2c8b			;		ld (de), a 
2c8b			;;		inc hl 
2c8b			;;		inc de 
2c8b			;;		ld (de), a 
2c8b			;;		inc hl 
2c8b			;		inc de 
2c8b			; 
2c8b			;		ex de, hl 
2c8b			;		pop de 
2c8b			;		 
2c8b			;		 
2c8b			; 
2c8b			;; detoken that string and copy it 
2c8b			; 
2c8b			;	if DEBUG_FORTH_WORDS 
2c8b			;		DMARK "Lt2" 
2c8b			;		CALLMONITOR 
2c8b			;	endif 
2c8b			;.ldetok:	ld a, (de) 
2c8b			;		cp FORTH_END_BUFFER 
2c8b			;		jr z, .ldetokend 
2c8b			;		; swap out any zero term for space 
2c8b			;		cp 0 
2c8b			;		jr nz, .ldetoknext 
2c8b			;		ld a, ' ' 
2c8b			; 
2c8b			;	if DEBUG_FORTH_WORDS 
2c8b			;		DMARK "LtS" 
2c8b			;		CALLMONITOR 
2c8b			;	endif 
2c8b			;.ldetoknext:	ld (hl), a 
2c8b			;		inc de 
2c8b			;		inc hl 
2c8b			;		jr .ldetok 
2c8b			; 
2c8b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c8b			;		ld (hl), a  
2c8b			; 
2c8b			;; free that temp malloc 
2c8b			; 
2c8b			;		pop hl    
2c8b			; 
2c8b			;	if DEBUG_FORTH_WORDS 
2c8b			;		DMARK "Lt4" 
2c8b			;		CALLMONITOR 
2c8b			;	endif 
2c8b			;		call forth_apushstrhl 
2c8b			; 
2c8b			;		; get rid of temp malloc area 
2c8b			; 
2c8b			;		pop hl 
2c8b			;		call free 
2c8b			; 
2c8b			;		jr .ludone 
2c8b			; 
2c8b			;.lnuword:	pop hl 
2c8b			;		call forth_tok_next 
2c8b			;		jp .ldouscan  
2c8b			; 
2c8b			;.ludone:		 pop hl 
2c8b			; 
2c8b					NEXTW 
2c8b c3 12 20			jp macro_next 
2c8e				endm 
# End of macro NEXTW
2c8e			 
2c8e			.FORGET: 
2c8e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c8e 5d				db WORD_SYS_CORE+73             
2c8f 07 2d			dw .NOP            
2c91 07				db 6 + 1 
2c92 .. 00			db "FORGET",0              
2c99				endm 
# End of macro CWHEAD
2c99			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c99			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c99			; | |  
2c99			; | | e.g. "MORE" forget 
2c99					if DEBUG_FORTH_WORDS_KEY 
2c99						DMARK "FRG" 
2c99 f5				push af  
2c9a 3a ae 2c			ld a, (.dmark)  
2c9d 32 77 fb			ld (debug_mark),a  
2ca0 3a af 2c			ld a, (.dmark+1)  
2ca3 32 78 fb			ld (debug_mark+1),a  
2ca6 3a b0 2c			ld a, (.dmark+2)  
2ca9 32 79 fb			ld (debug_mark+2),a  
2cac 18 03			jr .pastdmark  
2cae ..			.dmark: db "FRG"  
2cb1 f1			.pastdmark: pop af  
2cb2			endm  
# End of macro DMARK
2cb2						CALLMONITOR 
2cb2 cd 19 17			call break_point_state  
2cb5				endm  
# End of macro CALLMONITOR
2cb5					endif 
2cb5			 
2cb5				; find uword 
2cb5			        ; update start of word with "_" 
2cb5				; replace uword with deleted flag 
2cb5			 
2cb5			 
2cb5			;	if DEBUG_FORTH_WORDS 
2cb5			;		DMARK "FOG" 
2cb5			;		CALLMONITOR 
2cb5			;	endif 
2cb5			 
2cb5			 
2cb5					; Get ptr to the word we need to look up 
2cb5			 
2cb5					FORTH_DSP_VALUEHL 
2cb5 cd a0 1e			call macro_dsp_valuehl 
2cb8				endm 
# End of macro FORTH_DSP_VALUEHL
2cb8					;v5 FORTH_DSP_VALUE 
2cb8				; TODO type check 
2cb8			;		inc hl    ; Skip type check  
2cb8 e5					push hl 
2cb9 c1					pop bc 
2cba			;		ex de, hl    ; put into DE 
2cba			 
2cba			 
2cba 21 00 80				ld hl, baseram 
2cbd					;ld hl, baseusermem 
2cbd			 
2cbd				; skip dict stub 
2cbd			;	call forth_tok_next 
2cbd e5			push hl   ; sacreifical push 
2cbe			 
2cbe			.fldouscanm: 
2cbe e1				pop hl 
2cbf			.fldouscan: 
2cbf			;	if DEBUG_FORTH_WORDS 
2cbf			;		DMARK "LSs" 
2cbf			;		CALLMONITOR 
2cbf			;	endif 
2cbf				; skip dict stub 
2cbf cd 63 21				call forth_tok_next 
2cc2			 
2cc2			 
2cc2			; while we have words to look for 
2cc2			 
2cc2 7e				ld a, (hl)      
2cc3			;	if DEBUG_FORTH_WORDS 
2cc3			;		DMARK "LSk" 
2cc3			;		CALLMONITOR 
2cc3			;	endif 
2cc3 fe 00				cp WORD_SYS_END 
2cc5 ca 01 2d				jp z, .flunotfound 
2cc8 fe 01				cp WORD_SYS_UWORD 
2cca c2 bf 2c				jp nz, .fldouscan 
2ccd			 
2ccd			;	if DEBUG_FORTH_WORDS 
2ccd			;		DMARK "LSu" 
2ccd			;		CALLMONITOR 
2ccd			;	endif 
2ccd			 
2ccd					; found a uword but is it the one we want... 
2ccd			 
2ccd c5					push bc     ; uword to find is on bc 
2cce d1					pop de 
2ccf			 
2ccf e5					push hl  ; to save the ptr 
2cd0			 
2cd0					; skip opcode 
2cd0 23					inc hl  
2cd1					; skip next ptr 
2cd1 23					inc hl  
2cd2 23					inc hl 
2cd3					; skip len 
2cd3 23					inc hl 
2cd4			 
2cd4			;	if DEBUG_FORTH_WORDS 
2cd4			;		DMARK "LSc" 
2cd4			;		CALLMONITOR 
2cd4			;	endif 
2cd4 cd 9f 11				call strcmp 
2cd7 c2 be 2c				jp nz, .fldouscanm 
2cda			; 
2cda			; 
2cda			;; while we have words to look for 
2cda			; 
2cda			;.fdouscan:	ld a, (hl)      
2cda			;	if DEBUG_FORTH_WORDS 
2cda			;		DMARK "LSs" 
2cda			;		CALLMONITOR 
2cda			;	endif 
2cda			;		cp WORD_SYS_END 
2cda			;		jp z, .fudone 
2cda			;		cp WORD_SYS_UWORD 
2cda			;		jp nz, .fnuword 
2cda			; 
2cda			;	if DEBUG_FORTH_WORDS 
2cda			;		DMARK "FGu" 
2cda			;		CALLMONITOR 
2cda			;	endif 
2cda			; 
2cda			;		; found a uword but is it the one we want... 
2cda			; 
2cda			; 
2cda			;	        pop de   ; get back the dsp name 
2cda			;		push de 
2cda			; 
2cda			;		push hl  ; to save the ptr 
2cda			; 
2cda			;		; skip opcode 
2cda			;		inc hl  
2cda			;		; skip next ptr 
2cda			;		inc hl  
2cda			;		inc hl 
2cda			;		; skip len 
2cda			;		inc hl 
2cda			; 
2cda			;	if DEBUG_FORTH_WORDS 
2cda			;		DMARK "FGc" 
2cda			;		CALLMONITOR 
2cda			;	endif 
2cda			;		call strcmp 
2cda			;		jp nz, .fnuword 
2cda			 
2cda			 
2cda e1			pop hl 
2cdb			 
2cdb				 
2cdb				if DEBUG_FORTH_WORDS 
2cdb					DMARK "FGm" 
2cdb f5				push af  
2cdc 3a f0 2c			ld a, (.dmark)  
2cdf 32 77 fb			ld (debug_mark),a  
2ce2 3a f1 2c			ld a, (.dmark+1)  
2ce5 32 78 fb			ld (debug_mark+1),a  
2ce8 3a f2 2c			ld a, (.dmark+2)  
2ceb 32 79 fb			ld (debug_mark+2),a  
2cee 18 03			jr .pastdmark  
2cf0 ..			.dmark: db "FGm"  
2cf3 f1			.pastdmark: pop af  
2cf4			endm  
# End of macro DMARK
2cf4					CALLMONITOR 
2cf4 cd 19 17			call break_point_state  
2cf7				endm  
# End of macro CALLMONITOR
2cf7				endif 
2cf7			 
2cf7			 
2cf7			 
2cf7					; we have a uword so push its name to the stack 
2cf7			 
2cf7			;	   	push hl  ; save so we can move to next dict block 
2cf7			;pop hl 
2cf7			 
2cf7					; update opcode to deleted 
2cf7 3e 03				ld a, WORD_SYS_DELETED 
2cf9 77					ld (hl), a 
2cfa			 
2cfa 23					inc hl  
2cfb					; skip next ptr 
2cfb 23					inc hl  
2cfc 23					inc hl 
2cfd					; skip len 
2cfd 23					inc hl 
2cfe			 
2cfe					; TODO change parser to skip deleted words but for now mark it out 
2cfe 3e 5f				ld a, "_" 
2d00 77					ld  (hl),a 
2d01			 
2d01			;		jr .fudone 
2d01			; 
2d01			;.fnuword:	pop hl 
2d01			;		call forth_tok_next 
2d01			;		jp .fdouscan  
2d01			 
2d01			.flunotfound:		  
2d01			 
2d01			 
2d01					 
2d01					FORTH_DSP_POP 
2d01 cd 58 1f			call macro_forth_dsp_pop 
2d04				endm 
# End of macro FORTH_DSP_POP
2d04			;		ld hl, .luno 
2d04			;.fudone:		 pop hl 
2d04					NEXTW 
2d04 c3 12 20			jp macro_next 
2d07				endm 
# End of macro NEXTW
2d07			.NOP: 
2d07				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2d07 61				db WORD_SYS_CORE+77             
2d08 2e 2d			dw .COMO            
2d0a 04				db 3 + 1 
2d0b .. 00			db "NOP",0              
2d0f				endm 
# End of macro CWHEAD
2d0f			; | NOP (  --  ) Do nothing | DONE 
2d0f					if DEBUG_FORTH_WORDS_KEY 
2d0f						DMARK "NOP" 
2d0f f5				push af  
2d10 3a 24 2d			ld a, (.dmark)  
2d13 32 77 fb			ld (debug_mark),a  
2d16 3a 25 2d			ld a, (.dmark+1)  
2d19 32 78 fb			ld (debug_mark+1),a  
2d1c 3a 26 2d			ld a, (.dmark+2)  
2d1f 32 79 fb			ld (debug_mark+2),a  
2d22 18 03			jr .pastdmark  
2d24 ..			.dmark: db "NOP"  
2d27 f1			.pastdmark: pop af  
2d28			endm  
# End of macro DMARK
2d28						CALLMONITOR 
2d28 cd 19 17			call break_point_state  
2d2b				endm  
# End of macro CALLMONITOR
2d2b					endif 
2d2b				       NEXTW 
2d2b c3 12 20			jp macro_next 
2d2e				endm 
# End of macro NEXTW
2d2e			.COMO: 
2d2e				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2d2e 6e				db WORD_SYS_CORE+90             
2d2f 80 2d			dw .COMC            
2d31 02				db 1 + 1 
2d32 .. 00			db "(",0              
2d34				endm 
# End of macro CWHEAD
2d34			; | ( ( -- )  Start of comment | DONE 
2d34			 
2d34			 
2d34 2a 1e f1				ld hl, ( os_tok_ptr) 
2d37 11 7b 2d			ld de, .closepar 
2d3a					 
2d3a					if DEBUG_FORTH_WORDS 
2d3a						DMARK ").." 
2d3a f5				push af  
2d3b 3a 4f 2d			ld a, (.dmark)  
2d3e 32 77 fb			ld (debug_mark),a  
2d41 3a 50 2d			ld a, (.dmark+1)  
2d44 32 78 fb			ld (debug_mark+1),a  
2d47 3a 51 2d			ld a, (.dmark+2)  
2d4a 32 79 fb			ld (debug_mark+2),a  
2d4d 18 03			jr .pastdmark  
2d4f ..			.dmark: db ").."  
2d52 f1			.pastdmark: pop af  
2d53			endm  
# End of macro DMARK
2d53						CALLMONITOR 
2d53 cd 19 17			call break_point_state  
2d56				endm  
# End of macro CALLMONITOR
2d56					endif 
2d56 cd 2d 21			call findnexttok  
2d59			 
2d59					if DEBUG_FORTH_WORDS 
2d59						DMARK "IF5" 
2d59 f5				push af  
2d5a 3a 6e 2d			ld a, (.dmark)  
2d5d 32 77 fb			ld (debug_mark),a  
2d60 3a 6f 2d			ld a, (.dmark+1)  
2d63 32 78 fb			ld (debug_mark+1),a  
2d66 3a 70 2d			ld a, (.dmark+2)  
2d69 32 79 fb			ld (debug_mark+2),a  
2d6c 18 03			jr .pastdmark  
2d6e ..			.dmark: db "IF5"  
2d71 f1			.pastdmark: pop af  
2d72			endm  
# End of macro DMARK
2d72						CALLMONITOR 
2d72 cd 19 17			call break_point_state  
2d75				endm  
# End of macro CALLMONITOR
2d75					endif 
2d75				; replace below with ) exec using tok_ptr 
2d75 22 1e f1			ld (os_tok_ptr), hl 
2d78 c3 a3 20			jp exec1 
2d7b			 
2d7b .. 00			.closepar:   db ")",0 
2d7d			 
2d7d				       NEXTW 
2d7d c3 12 20			jp macro_next 
2d80				endm 
# End of macro NEXTW
2d80			.COMC: 
2d80				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d80 6f				db WORD_SYS_CORE+91             
2d81 89 2d			dw .SCRATCH            
2d83 02				db 1 + 1 
2d84 .. 00			db ")",0              
2d86				endm 
# End of macro CWHEAD
2d86			; | ) ( -- )  End of comment |  DONE  
2d86				       NEXTW 
2d86 c3 12 20			jp macro_next 
2d89				endm 
# End of macro NEXTW
2d89			 
2d89			.SCRATCH: 
2d89				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d89 6f				db WORD_SYS_CORE+91             
2d8a c4 2d			dw .INC            
2d8c 08				db 7 + 1 
2d8d .. 00			db "SCRATCH",0              
2d95				endm 
# End of macro CWHEAD
2d95			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d95			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d95			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d95			; | |  
2d95			; | | e.g.    : score $00 scratch ; 
2d95			; | |  
2d95			; | | $00 score ! 
2d95			; | | $01 score +! 
2d95			; | |  
2d95			; | | e.g.   : varword $0a scratch ;  
2d95			; | | 
2d95			; | | $8000 varword ! 
2d95					if DEBUG_FORTH_WORDS_KEY 
2d95						DMARK "SCR" 
2d95 f5				push af  
2d96 3a aa 2d			ld a, (.dmark)  
2d99 32 77 fb			ld (debug_mark),a  
2d9c 3a ab 2d			ld a, (.dmark+1)  
2d9f 32 78 fb			ld (debug_mark+1),a  
2da2 3a ac 2d			ld a, (.dmark+2)  
2da5 32 79 fb			ld (debug_mark+2),a  
2da8 18 03			jr .pastdmark  
2daa ..			.dmark: db "SCR"  
2dad f1			.pastdmark: pop af  
2dae			endm  
# End of macro DMARK
2dae						CALLMONITOR 
2dae cd 19 17			call break_point_state  
2db1				endm  
# End of macro CALLMONITOR
2db1					endif 
2db1			 
2db1					FORTH_DSP_VALUEHL 
2db1 cd a0 1e			call macro_dsp_valuehl 
2db4				endm 
# End of macro FORTH_DSP_VALUEHL
2db4				 
2db4					FORTH_DSP_POP 
2db4 cd 58 1f			call macro_forth_dsp_pop 
2db7				endm 
# End of macro FORTH_DSP_POP
2db7			 
2db7 7d					ld a, l 
2db8 21 42 f3				ld hl, os_var_array 
2dbb cd 09 0d				call addatohl 
2dbe			 
2dbe cd a9 1c				call forth_push_numhl 
2dc1			 
2dc1				       NEXTW 
2dc1 c3 12 20			jp macro_next 
2dc4				endm 
# End of macro NEXTW
2dc4			 
2dc4			.INC: 
2dc4				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2dc4 6f				db WORD_SYS_CORE+91             
2dc5 18 2e			dw .DEC            
2dc7 03				db 2 + 1 
2dc8 .. 00			db "+!",0              
2dcb				endm 
# End of macro CWHEAD
2dcb			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2dcb					if DEBUG_FORTH_WORDS_KEY 
2dcb						DMARK "+s_" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 77 fb			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 78 fb			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 79 fb			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "+s_"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4						CALLMONITOR 
2de4 cd 19 17			call break_point_state  
2de7				endm  
# End of macro CALLMONITOR
2de7					endif 
2de7			 
2de7					FORTH_DSP_VALUEHL 
2de7 cd a0 1e			call macro_dsp_valuehl 
2dea				endm 
# End of macro FORTH_DSP_VALUEHL
2dea			 
2dea e5					push hl   ; save address 
2deb			 
2deb					FORTH_DSP_POP 
2deb cd 58 1f			call macro_forth_dsp_pop 
2dee				endm 
# End of macro FORTH_DSP_POP
2dee			 
2dee					FORTH_DSP_VALUEHL 
2dee cd a0 1e			call macro_dsp_valuehl 
2df1				endm 
# End of macro FORTH_DSP_VALUEHL
2df1			 
2df1					FORTH_DSP_POP 
2df1 cd 58 1f			call macro_forth_dsp_pop 
2df4				endm 
# End of macro FORTH_DSP_POP
2df4			 
2df4					; hl contains value to add to byte at a 
2df4				 
2df4 eb					ex de, hl 
2df5			 
2df5 e1					pop hl 
2df6			 
2df6					if DEBUG_FORTH_WORDS 
2df6						DMARK "INC" 
2df6 f5				push af  
2df7 3a 0b 2e			ld a, (.dmark)  
2dfa 32 77 fb			ld (debug_mark),a  
2dfd 3a 0c 2e			ld a, (.dmark+1)  
2e00 32 78 fb			ld (debug_mark+1),a  
2e03 3a 0d 2e			ld a, (.dmark+2)  
2e06 32 79 fb			ld (debug_mark+2),a  
2e09 18 03			jr .pastdmark  
2e0b ..			.dmark: db "INC"  
2e0e f1			.pastdmark: pop af  
2e0f			endm  
# End of macro DMARK
2e0f						CALLMONITOR 
2e0f cd 19 17			call break_point_state  
2e12				endm  
# End of macro CALLMONITOR
2e12					endif 
2e12			 
2e12 7e					ld a,(hl) 
2e13 83					add e 
2e14 77					ld (hl),a 
2e15			 
2e15			 
2e15			 
2e15				       NEXTW 
2e15 c3 12 20			jp macro_next 
2e18				endm 
# End of macro NEXTW
2e18			 
2e18			.DEC: 
2e18				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2e18 6f				db WORD_SYS_CORE+91             
2e19 69 2e			dw .INC2            
2e1b 03				db 2 + 1 
2e1c .. 00			db "-!",0              
2e1f				endm 
# End of macro CWHEAD
2e1f			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2e1f					if DEBUG_FORTH_WORDS_KEY 
2e1f						DMARK "-s_" 
2e1f f5				push af  
2e20 3a 34 2e			ld a, (.dmark)  
2e23 32 77 fb			ld (debug_mark),a  
2e26 3a 35 2e			ld a, (.dmark+1)  
2e29 32 78 fb			ld (debug_mark+1),a  
2e2c 3a 36 2e			ld a, (.dmark+2)  
2e2f 32 79 fb			ld (debug_mark+2),a  
2e32 18 03			jr .pastdmark  
2e34 ..			.dmark: db "-s_"  
2e37 f1			.pastdmark: pop af  
2e38			endm  
# End of macro DMARK
2e38						CALLMONITOR 
2e38 cd 19 17			call break_point_state  
2e3b				endm  
# End of macro CALLMONITOR
2e3b					endif 
2e3b			 
2e3b					FORTH_DSP_VALUEHL 
2e3b cd a0 1e			call macro_dsp_valuehl 
2e3e				endm 
# End of macro FORTH_DSP_VALUEHL
2e3e			 
2e3e e5					push hl   ; save address 
2e3f			 
2e3f					FORTH_DSP_POP 
2e3f cd 58 1f			call macro_forth_dsp_pop 
2e42				endm 
# End of macro FORTH_DSP_POP
2e42			 
2e42					FORTH_DSP_VALUEHL 
2e42 cd a0 1e			call macro_dsp_valuehl 
2e45				endm 
# End of macro FORTH_DSP_VALUEHL
2e45			 
2e45					; hl contains value to add to byte at a 
2e45				 
2e45 eb					ex de, hl 
2e46			 
2e46 e1					pop hl 
2e47			 
2e47					if DEBUG_FORTH_WORDS 
2e47						DMARK "DEC" 
2e47 f5				push af  
2e48 3a 5c 2e			ld a, (.dmark)  
2e4b 32 77 fb			ld (debug_mark),a  
2e4e 3a 5d 2e			ld a, (.dmark+1)  
2e51 32 78 fb			ld (debug_mark+1),a  
2e54 3a 5e 2e			ld a, (.dmark+2)  
2e57 32 79 fb			ld (debug_mark+2),a  
2e5a 18 03			jr .pastdmark  
2e5c ..			.dmark: db "DEC"  
2e5f f1			.pastdmark: pop af  
2e60			endm  
# End of macro DMARK
2e60						CALLMONITOR 
2e60 cd 19 17			call break_point_state  
2e63				endm  
# End of macro CALLMONITOR
2e63					endif 
2e63			 
2e63 7e					ld a,(hl) 
2e64 93					sub e 
2e65 77					ld (hl),a 
2e66			 
2e66			 
2e66			 
2e66				       NEXTW 
2e66 c3 12 20			jp macro_next 
2e69				endm 
# End of macro NEXTW
2e69			 
2e69			.INC2: 
2e69				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e69 6f				db WORD_SYS_CORE+91             
2e6a 13 2f			dw .DEC2            
2e6c 04				db 3 + 1 
2e6d .. 00			db "+2!",0              
2e71				endm 
# End of macro CWHEAD
2e71			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e71			 
2e71					if DEBUG_FORTH_WORDS_KEY 
2e71						DMARK "+2s" 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 77 fb			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 78 fb			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 79 fb			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "+2s"  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a						CALLMONITOR 
2e8a cd 19 17			call break_point_state  
2e8d				endm  
# End of macro CALLMONITOR
2e8d					endif 
2e8d			 
2e8d					; Address 
2e8d			 
2e8d					FORTH_DSP_VALUEHL 
2e8d cd a0 1e			call macro_dsp_valuehl 
2e90				endm 
# End of macro FORTH_DSP_VALUEHL
2e90			 
2e90 e5					push hl    ; save address 
2e91			 
2e91					; load content into de 
2e91			 
2e91 5e					ld e,(hl) 
2e92 23					inc hl 
2e93 56					ld d, (hl) 
2e94			 
2e94					if DEBUG_FORTH_WORDS 
2e94						DMARK "+2a" 
2e94 f5				push af  
2e95 3a a9 2e			ld a, (.dmark)  
2e98 32 77 fb			ld (debug_mark),a  
2e9b 3a aa 2e			ld a, (.dmark+1)  
2e9e 32 78 fb			ld (debug_mark+1),a  
2ea1 3a ab 2e			ld a, (.dmark+2)  
2ea4 32 79 fb			ld (debug_mark+2),a  
2ea7 18 03			jr .pastdmark  
2ea9 ..			.dmark: db "+2a"  
2eac f1			.pastdmark: pop af  
2ead			endm  
# End of macro DMARK
2ead						CALLMONITOR 
2ead cd 19 17			call break_point_state  
2eb0				endm  
# End of macro CALLMONITOR
2eb0					endif 
2eb0			 
2eb0					FORTH_DSP_POP 
2eb0 cd 58 1f			call macro_forth_dsp_pop 
2eb3				endm 
# End of macro FORTH_DSP_POP
2eb3			 
2eb3					; Get value to add 
2eb3			 
2eb3					FORTH_DSP_VALUE 
2eb3 cd 89 1e			call macro_forth_dsp_value 
2eb6				endm 
# End of macro FORTH_DSP_VALUE
2eb6			 
2eb6					if DEBUG_FORTH_WORDS 
2eb6						DMARK "+2v" 
2eb6 f5				push af  
2eb7 3a cb 2e			ld a, (.dmark)  
2eba 32 77 fb			ld (debug_mark),a  
2ebd 3a cc 2e			ld a, (.dmark+1)  
2ec0 32 78 fb			ld (debug_mark+1),a  
2ec3 3a cd 2e			ld a, (.dmark+2)  
2ec6 32 79 fb			ld (debug_mark+2),a  
2ec9 18 03			jr .pastdmark  
2ecb ..			.dmark: db "+2v"  
2ece f1			.pastdmark: pop af  
2ecf			endm  
# End of macro DMARK
2ecf						CALLMONITOR 
2ecf cd 19 17			call break_point_state  
2ed2				endm  
# End of macro CALLMONITOR
2ed2					endif 
2ed2			 
2ed2 19					add hl, de 
2ed3			 
2ed3					if DEBUG_FORTH_WORDS 
2ed3						DMARK "+2+" 
2ed3 f5				push af  
2ed4 3a e8 2e			ld a, (.dmark)  
2ed7 32 77 fb			ld (debug_mark),a  
2eda 3a e9 2e			ld a, (.dmark+1)  
2edd 32 78 fb			ld (debug_mark+1),a  
2ee0 3a ea 2e			ld a, (.dmark+2)  
2ee3 32 79 fb			ld (debug_mark+2),a  
2ee6 18 03			jr .pastdmark  
2ee8 ..			.dmark: db "+2+"  
2eeb f1			.pastdmark: pop af  
2eec			endm  
# End of macro DMARK
2eec						CALLMONITOR 
2eec cd 19 17			call break_point_state  
2eef				endm  
# End of macro CALLMONITOR
2eef					endif 
2eef			 
2eef					; move result to de 
2eef			 
2eef eb					ex de, hl 
2ef0			 
2ef0					; Address 
2ef0			 
2ef0 e1					pop hl 
2ef1			 
2ef1					; save it back 
2ef1			 
2ef1 73					ld (hl), e 
2ef2 23					inc hl 
2ef3 72					ld (hl), d 
2ef4			 
2ef4					if DEBUG_FORTH_WORDS 
2ef4						DMARK "+2e" 
2ef4 f5				push af  
2ef5 3a 09 2f			ld a, (.dmark)  
2ef8 32 77 fb			ld (debug_mark),a  
2efb 3a 0a 2f			ld a, (.dmark+1)  
2efe 32 78 fb			ld (debug_mark+1),a  
2f01 3a 0b 2f			ld a, (.dmark+2)  
2f04 32 79 fb			ld (debug_mark+2),a  
2f07 18 03			jr .pastdmark  
2f09 ..			.dmark: db "+2e"  
2f0c f1			.pastdmark: pop af  
2f0d			endm  
# End of macro DMARK
2f0d						CALLMONITOR 
2f0d cd 19 17			call break_point_state  
2f10				endm  
# End of macro CALLMONITOR
2f10					endif 
2f10			 
2f10			 
2f10			 
2f10			 
2f10			 
2f10				       NEXTW 
2f10 c3 12 20			jp macro_next 
2f13				endm 
# End of macro NEXTW
2f13			 
2f13			.DEC2: 
2f13				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2f13 6f				db WORD_SYS_CORE+91             
2f14 bf 2f			dw .GET2            
2f16 04				db 3 + 1 
2f17 .. 00			db "-2!",0              
2f1b				endm 
# End of macro CWHEAD
2f1b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2f1b			 
2f1b			 
2f1b					if DEBUG_FORTH_WORDS_KEY 
2f1b						DMARK "-2s" 
2f1b f5				push af  
2f1c 3a 30 2f			ld a, (.dmark)  
2f1f 32 77 fb			ld (debug_mark),a  
2f22 3a 31 2f			ld a, (.dmark+1)  
2f25 32 78 fb			ld (debug_mark+1),a  
2f28 3a 32 2f			ld a, (.dmark+2)  
2f2b 32 79 fb			ld (debug_mark+2),a  
2f2e 18 03			jr .pastdmark  
2f30 ..			.dmark: db "-2s"  
2f33 f1			.pastdmark: pop af  
2f34			endm  
# End of macro DMARK
2f34						CALLMONITOR 
2f34 cd 19 17			call break_point_state  
2f37				endm  
# End of macro CALLMONITOR
2f37					endif 
2f37			 
2f37					; Address 
2f37			 
2f37					FORTH_DSP_VALUEHL 
2f37 cd a0 1e			call macro_dsp_valuehl 
2f3a				endm 
# End of macro FORTH_DSP_VALUEHL
2f3a			 
2f3a e5					push hl    ; save address 
2f3b			 
2f3b					; load content into de 
2f3b			 
2f3b 5e					ld e,(hl) 
2f3c 23					inc hl 
2f3d 56					ld d, (hl) 
2f3e			 
2f3e					if DEBUG_FORTH_WORDS 
2f3e						DMARK "-2a" 
2f3e f5				push af  
2f3f 3a 53 2f			ld a, (.dmark)  
2f42 32 77 fb			ld (debug_mark),a  
2f45 3a 54 2f			ld a, (.dmark+1)  
2f48 32 78 fb			ld (debug_mark+1),a  
2f4b 3a 55 2f			ld a, (.dmark+2)  
2f4e 32 79 fb			ld (debug_mark+2),a  
2f51 18 03			jr .pastdmark  
2f53 ..			.dmark: db "-2a"  
2f56 f1			.pastdmark: pop af  
2f57			endm  
# End of macro DMARK
2f57						CALLMONITOR 
2f57 cd 19 17			call break_point_state  
2f5a				endm  
# End of macro CALLMONITOR
2f5a					endif 
2f5a			 
2f5a					FORTH_DSP_POP 
2f5a cd 58 1f			call macro_forth_dsp_pop 
2f5d				endm 
# End of macro FORTH_DSP_POP
2f5d			 
2f5d					; Get value to remove 
2f5d			 
2f5d					FORTH_DSP_VALUE 
2f5d cd 89 1e			call macro_forth_dsp_value 
2f60				endm 
# End of macro FORTH_DSP_VALUE
2f60			 
2f60					if DEBUG_FORTH_WORDS 
2f60						DMARK "-2v" 
2f60 f5				push af  
2f61 3a 75 2f			ld a, (.dmark)  
2f64 32 77 fb			ld (debug_mark),a  
2f67 3a 76 2f			ld a, (.dmark+1)  
2f6a 32 78 fb			ld (debug_mark+1),a  
2f6d 3a 77 2f			ld a, (.dmark+2)  
2f70 32 79 fb			ld (debug_mark+2),a  
2f73 18 03			jr .pastdmark  
2f75 ..			.dmark: db "-2v"  
2f78 f1			.pastdmark: pop af  
2f79			endm  
# End of macro DMARK
2f79						CALLMONITOR 
2f79 cd 19 17			call break_point_state  
2f7c				endm  
# End of macro CALLMONITOR
2f7c					endif 
2f7c			 
2f7c eb					ex de, hl 
2f7d ed 52				sbc hl, de 
2f7f			 
2f7f					if DEBUG_FORTH_WORDS 
2f7f						DMARK "-2d" 
2f7f f5				push af  
2f80 3a 94 2f			ld a, (.dmark)  
2f83 32 77 fb			ld (debug_mark),a  
2f86 3a 95 2f			ld a, (.dmark+1)  
2f89 32 78 fb			ld (debug_mark+1),a  
2f8c 3a 96 2f			ld a, (.dmark+2)  
2f8f 32 79 fb			ld (debug_mark+2),a  
2f92 18 03			jr .pastdmark  
2f94 ..			.dmark: db "-2d"  
2f97 f1			.pastdmark: pop af  
2f98			endm  
# End of macro DMARK
2f98						CALLMONITOR 
2f98 cd 19 17			call break_point_state  
2f9b				endm  
# End of macro CALLMONITOR
2f9b					endif 
2f9b			 
2f9b					; move result to de 
2f9b			 
2f9b eb					ex de, hl 
2f9c			 
2f9c					; Address 
2f9c			 
2f9c e1					pop hl 
2f9d			 
2f9d					; save it back 
2f9d			 
2f9d 73					ld (hl), e 
2f9e 23					inc hl 
2f9f 72					ld (hl), d 
2fa0			 
2fa0					if DEBUG_FORTH_WORDS 
2fa0						DMARK "-2e" 
2fa0 f5				push af  
2fa1 3a b5 2f			ld a, (.dmark)  
2fa4 32 77 fb			ld (debug_mark),a  
2fa7 3a b6 2f			ld a, (.dmark+1)  
2faa 32 78 fb			ld (debug_mark+1),a  
2fad 3a b7 2f			ld a, (.dmark+2)  
2fb0 32 79 fb			ld (debug_mark+2),a  
2fb3 18 03			jr .pastdmark  
2fb5 ..			.dmark: db "-2e"  
2fb8 f1			.pastdmark: pop af  
2fb9			endm  
# End of macro DMARK
2fb9						CALLMONITOR 
2fb9 cd 19 17			call break_point_state  
2fbc				endm  
# End of macro CALLMONITOR
2fbc					endif 
2fbc			 
2fbc			 
2fbc			 
2fbc			 
2fbc			 
2fbc				       NEXTW 
2fbc c3 12 20			jp macro_next 
2fbf				endm 
# End of macro NEXTW
2fbf			.GET2: 
2fbf				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2fbf 6f				db WORD_SYS_CORE+91             
2fc0 ef 2f			dw .BANG2            
2fc2 03				db 2 + 1 
2fc3 .. 00			db "2@",0              
2fc6				endm 
# End of macro CWHEAD
2fc6			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2fc6					if DEBUG_FORTH_WORDS_KEY 
2fc6						DMARK "2A_" 
2fc6 f5				push af  
2fc7 3a db 2f			ld a, (.dmark)  
2fca 32 77 fb			ld (debug_mark),a  
2fcd 3a dc 2f			ld a, (.dmark+1)  
2fd0 32 78 fb			ld (debug_mark+1),a  
2fd3 3a dd 2f			ld a, (.dmark+2)  
2fd6 32 79 fb			ld (debug_mark+2),a  
2fd9 18 03			jr .pastdmark  
2fdb ..			.dmark: db "2A_"  
2fde f1			.pastdmark: pop af  
2fdf			endm  
# End of macro DMARK
2fdf						CALLMONITOR 
2fdf cd 19 17			call break_point_state  
2fe2				endm  
# End of macro CALLMONITOR
2fe2					endif 
2fe2			 
2fe2					FORTH_DSP_VALUEHL 
2fe2 cd a0 1e			call macro_dsp_valuehl 
2fe5				endm 
# End of macro FORTH_DSP_VALUEHL
2fe5			 
2fe5 5e					ld e, (hl) 
2fe6 23					inc hl 
2fe7 56					ld d, (hl) 
2fe8			 
2fe8 eb					ex de, hl 
2fe9			 
2fe9 cd a9 1c				call forth_push_numhl 
2fec			 
2fec				       NEXTW 
2fec c3 12 20			jp macro_next 
2fef				endm 
# End of macro NEXTW
2fef			.BANG2: 
2fef				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2fef 6f				db WORD_SYS_CORE+91             
2ff0 27 30			dw .CONFIG            
2ff2 03				db 2 + 1 
2ff3 .. 00			db "2!",0              
2ff6				endm 
# End of macro CWHEAD
2ff6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ff6					if DEBUG_FORTH_WORDS_KEY 
2ff6						DMARK "2S_" 
2ff6 f5				push af  
2ff7 3a 0b 30			ld a, (.dmark)  
2ffa 32 77 fb			ld (debug_mark),a  
2ffd 3a 0c 30			ld a, (.dmark+1)  
3000 32 78 fb			ld (debug_mark+1),a  
3003 3a 0d 30			ld a, (.dmark+2)  
3006 32 79 fb			ld (debug_mark+2),a  
3009 18 03			jr .pastdmark  
300b ..			.dmark: db "2S_"  
300e f1			.pastdmark: pop af  
300f			endm  
# End of macro DMARK
300f						CALLMONITOR 
300f cd 19 17			call break_point_state  
3012				endm  
# End of macro CALLMONITOR
3012					endif 
3012			 
3012					FORTH_DSP_VALUEHL 
3012 cd a0 1e			call macro_dsp_valuehl 
3015				endm 
# End of macro FORTH_DSP_VALUEHL
3015			 
3015 e5					push hl   ; save address 
3016			 
3016			 
3016					FORTH_DSP_POP 
3016 cd 58 1f			call macro_forth_dsp_pop 
3019				endm 
# End of macro FORTH_DSP_POP
3019			 
3019					 
3019					FORTH_DSP_VALUEHL 
3019 cd a0 1e			call macro_dsp_valuehl 
301c				endm 
# End of macro FORTH_DSP_VALUEHL
301c			 
301c					FORTH_DSP_POP 
301c cd 58 1f			call macro_forth_dsp_pop 
301f				endm 
# End of macro FORTH_DSP_POP
301f			 
301f eb					ex de, hl    ; value now in de 
3020			 
3020 e1					pop hl 
3021			 
3021 73					ld (hl), e 
3022			 
3022 23					inc hl 
3023			 
3023 72					ld (hl), d 
3024			 
3024			 
3024				       NEXTW 
3024 c3 12 20			jp macro_next 
3027				endm 
# End of macro NEXTW
3027			.CONFIG: 
3027				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3027 6f				db WORD_SYS_CORE+91             
3028 38 30			dw .ENDCORE            
302a 07				db 6 + 1 
302b .. 00			db "CONFIG",0              
3032				endm 
# End of macro CWHEAD
3032			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
3032			 
3032 cd 93 13				call config 
3035					NEXTW 
3035 c3 12 20			jp macro_next 
3038				endm 
# End of macro NEXTW
3038			.ENDCORE: 
3038			 
3038			; eof 
3038			 
3038			 
# End of file forth_words_core.asm
3038			include "forth_words_flow.asm" 
3038			 
3038			; | ## Program Flow Words 
3038			 
3038			.IF: 
3038				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3038 1e				db WORD_SYS_CORE+10             
3039 2d 31			dw .THEN            
303b 03				db 2 + 1 
303c .. 00			db "IF",0              
303f				endm 
# End of macro CWHEAD
303f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
303f			; 
303f					if DEBUG_FORTH_WORDS_KEY 
303f						DMARK "IF." 
303f f5				push af  
3040 3a 54 30			ld a, (.dmark)  
3043 32 77 fb			ld (debug_mark),a  
3046 3a 55 30			ld a, (.dmark+1)  
3049 32 78 fb			ld (debug_mark+1),a  
304c 3a 56 30			ld a, (.dmark+2)  
304f 32 79 fb			ld (debug_mark+2),a  
3052 18 03			jr .pastdmark  
3054 ..			.dmark: db "IF."  
3057 f1			.pastdmark: pop af  
3058			endm  
# End of macro DMARK
3058						CALLMONITOR 
3058 cd 19 17			call break_point_state  
305b				endm  
# End of macro CALLMONITOR
305b					endif 
305b			; eval TOS 
305b			 
305b				FORTH_DSP_VALUEHL 
305b cd a0 1e			call macro_dsp_valuehl 
305e				endm 
# End of macro FORTH_DSP_VALUEHL
305e			 
305e			;	push hl 
305e				FORTH_DSP_POP 
305e cd 58 1f			call macro_forth_dsp_pop 
3061				endm 
# End of macro FORTH_DSP_POP
3061			;	pop hl 
3061			 
3061					if DEBUG_FORTH_WORDS 
3061						DMARK "IF1" 
3061 f5				push af  
3062 3a 76 30			ld a, (.dmark)  
3065 32 77 fb			ld (debug_mark),a  
3068 3a 77 30			ld a, (.dmark+1)  
306b 32 78 fb			ld (debug_mark+1),a  
306e 3a 78 30			ld a, (.dmark+2)  
3071 32 79 fb			ld (debug_mark+2),a  
3074 18 03			jr .pastdmark  
3076 ..			.dmark: db "IF1"  
3079 f1			.pastdmark: pop af  
307a			endm  
# End of macro DMARK
307a						CALLMONITOR 
307a cd 19 17			call break_point_state  
307d				endm  
# End of macro CALLMONITOR
307d					endif 
307d b7				or a        ; clear carry flag 
307e 11 00 00			ld de, 0 
3081 eb				ex de,hl 
3082 ed 52			sbc hl, de 
3084 c2 0e 31			jp nz, .iftrue 
3087			 
3087					if DEBUG_FORTH_WORDS 
3087						DMARK "IF2" 
3087 f5				push af  
3088 3a 9c 30			ld a, (.dmark)  
308b 32 77 fb			ld (debug_mark),a  
308e 3a 9d 30			ld a, (.dmark+1)  
3091 32 78 fb			ld (debug_mark+1),a  
3094 3a 9e 30			ld a, (.dmark+2)  
3097 32 79 fb			ld (debug_mark+2),a  
309a 18 03			jr .pastdmark  
309c ..			.dmark: db "IF2"  
309f f1			.pastdmark: pop af  
30a0			endm  
# End of macro DMARK
30a0						CALLMONITOR 
30a0 cd 19 17			call break_point_state  
30a3				endm  
# End of macro CALLMONITOR
30a3					endif 
30a3			 
30a3			; if not true then skip to THEN 
30a3			 
30a3				; TODO get tok_ptr 
30a3				; TODO consume toks until we get to THEN 
30a3			 
30a3 2a 1e f1			ld hl, (os_tok_ptr) 
30a6					if DEBUG_FORTH_WORDS 
30a6						DMARK "IF3" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 77 fb			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 78 fb			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 79 fb			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "IF3"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf						CALLMONITOR 
30bf cd 19 17			call break_point_state  
30c2				endm  
# End of macro CALLMONITOR
30c2						 
30c2					endif 
30c2 11 09 31			ld de, .ifthen 
30c5					if DEBUG_FORTH_WORDS 
30c5						DMARK "IF4" 
30c5 f5				push af  
30c6 3a da 30			ld a, (.dmark)  
30c9 32 77 fb			ld (debug_mark),a  
30cc 3a db 30			ld a, (.dmark+1)  
30cf 32 78 fb			ld (debug_mark+1),a  
30d2 3a dc 30			ld a, (.dmark+2)  
30d5 32 79 fb			ld (debug_mark+2),a  
30d8 18 03			jr .pastdmark  
30da ..			.dmark: db "IF4"  
30dd f1			.pastdmark: pop af  
30de			endm  
# End of macro DMARK
30de						CALLMONITOR 
30de cd 19 17			call break_point_state  
30e1				endm  
# End of macro CALLMONITOR
30e1					endif 
30e1 cd 2d 21			call findnexttok  
30e4			 
30e4					if DEBUG_FORTH_WORDS 
30e4						DMARK "IF5" 
30e4 f5				push af  
30e5 3a f9 30			ld a, (.dmark)  
30e8 32 77 fb			ld (debug_mark),a  
30eb 3a fa 30			ld a, (.dmark+1)  
30ee 32 78 fb			ld (debug_mark+1),a  
30f1 3a fb 30			ld a, (.dmark+2)  
30f4 32 79 fb			ld (debug_mark+2),a  
30f7 18 03			jr .pastdmark  
30f9 ..			.dmark: db "IF5"  
30fc f1			.pastdmark: pop af  
30fd			endm  
# End of macro DMARK
30fd						CALLMONITOR 
30fd cd 19 17			call break_point_state  
3100				endm  
# End of macro CALLMONITOR
3100					endif 
3100				; TODO replace below with ; exec using tok_ptr 
3100 22 1e f1			ld (os_tok_ptr), hl 
3103 c3 a3 20			jp exec1 
3106				NEXTW 
3106 c3 12 20			jp macro_next 
3109				endm 
# End of macro NEXTW
3109			 
3109 .. 00		.ifthen:  db "THEN",0 
310e			 
310e			.iftrue:		 
310e				; Exec next words normally 
310e			 
310e				; if true then exec following IF as normal 
310e					if DEBUG_FORTH_WORDS 
310e						DMARK "IFT" 
310e f5				push af  
310f 3a 23 31			ld a, (.dmark)  
3112 32 77 fb			ld (debug_mark),a  
3115 3a 24 31			ld a, (.dmark+1)  
3118 32 78 fb			ld (debug_mark+1),a  
311b 3a 25 31			ld a, (.dmark+2)  
311e 32 79 fb			ld (debug_mark+2),a  
3121 18 03			jr .pastdmark  
3123 ..			.dmark: db "IFT"  
3126 f1			.pastdmark: pop af  
3127			endm  
# End of macro DMARK
3127						CALLMONITOR 
3127 cd 19 17			call break_point_state  
312a				endm  
# End of macro CALLMONITOR
312a					endif 
312a			 
312a					NEXTW 
312a c3 12 20			jp macro_next 
312d				endm 
# End of macro NEXTW
312d			.THEN: 
312d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
312d 1f				db WORD_SYS_CORE+11             
312e 55 31			dw .ELSE            
3130 05				db 4 + 1 
3131 .. 00			db "THEN",0              
3136				endm 
# End of macro CWHEAD
3136			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3136					if DEBUG_FORTH_WORDS_KEY 
3136						DMARK "THN" 
3136 f5				push af  
3137 3a 4b 31			ld a, (.dmark)  
313a 32 77 fb			ld (debug_mark),a  
313d 3a 4c 31			ld a, (.dmark+1)  
3140 32 78 fb			ld (debug_mark+1),a  
3143 3a 4d 31			ld a, (.dmark+2)  
3146 32 79 fb			ld (debug_mark+2),a  
3149 18 03			jr .pastdmark  
314b ..			.dmark: db "THN"  
314e f1			.pastdmark: pop af  
314f			endm  
# End of macro DMARK
314f						CALLMONITOR 
314f cd 19 17			call break_point_state  
3152				endm  
# End of macro CALLMONITOR
3152					endif 
3152					NEXTW 
3152 c3 12 20			jp macro_next 
3155				endm 
# End of macro NEXTW
3155			.ELSE: 
3155				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3155 20				db WORD_SYS_CORE+12             
3156 7d 31			dw .DO            
3158 03				db 2 + 1 
3159 .. 00			db "ELSE",0              
315e				endm 
# End of macro CWHEAD
315e			; | ELSE ( -- ) Not supported - does nothing | TODO 
315e			 
315e					if DEBUG_FORTH_WORDS_KEY 
315e						DMARK "ELS" 
315e f5				push af  
315f 3a 73 31			ld a, (.dmark)  
3162 32 77 fb			ld (debug_mark),a  
3165 3a 74 31			ld a, (.dmark+1)  
3168 32 78 fb			ld (debug_mark+1),a  
316b 3a 75 31			ld a, (.dmark+2)  
316e 32 79 fb			ld (debug_mark+2),a  
3171 18 03			jr .pastdmark  
3173 ..			.dmark: db "ELS"  
3176 f1			.pastdmark: pop af  
3177			endm  
# End of macro DMARK
3177						CALLMONITOR 
3177 cd 19 17			call break_point_state  
317a				endm  
# End of macro CALLMONITOR
317a					endif 
317a			 
317a			 
317a					NEXTW 
317a c3 12 20			jp macro_next 
317d				endm 
# End of macro NEXTW
317d			.DO: 
317d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
317d 21				db WORD_SYS_CORE+13             
317e a4 32			dw .LOOP            
3180 03				db 2 + 1 
3181 .. 00			db "DO",0              
3184				endm 
# End of macro CWHEAD
3184			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3184			 
3184					if DEBUG_FORTH_WORDS_KEY 
3184						DMARK "DO." 
3184 f5				push af  
3185 3a 99 31			ld a, (.dmark)  
3188 32 77 fb			ld (debug_mark),a  
318b 3a 9a 31			ld a, (.dmark+1)  
318e 32 78 fb			ld (debug_mark+1),a  
3191 3a 9b 31			ld a, (.dmark+2)  
3194 32 79 fb			ld (debug_mark+2),a  
3197 18 03			jr .pastdmark  
3199 ..			.dmark: db "DO."  
319c f1			.pastdmark: pop af  
319d			endm  
# End of macro DMARK
319d						CALLMONITOR 
319d cd 19 17			call break_point_state  
31a0				endm  
# End of macro CALLMONITOR
31a0					endif 
31a0			;  push pc to rsp stack past the DO 
31a0			 
31a0 2a 1e f1				ld hl, (os_tok_ptr) 
31a3 23					inc hl   ; D 
31a4 23					inc hl  ; O 
31a5 23					inc hl   ; null 
31a6					if DEBUG_FORTH_WORDS 
31a6						DMARK "DO2" 
31a6 f5				push af  
31a7 3a bb 31			ld a, (.dmark)  
31aa 32 77 fb			ld (debug_mark),a  
31ad 3a bc 31			ld a, (.dmark+1)  
31b0 32 78 fb			ld (debug_mark+1),a  
31b3 3a bd 31			ld a, (.dmark+2)  
31b6 32 79 fb			ld (debug_mark+2),a  
31b9 18 03			jr .pastdmark  
31bb ..			.dmark: db "DO2"  
31be f1			.pastdmark: pop af  
31bf			endm  
# End of macro DMARK
31bf						CALLMONITOR 
31bf cd 19 17			call break_point_state  
31c2				endm  
# End of macro CALLMONITOR
31c2					endif 
31c2					FORTH_RSP_NEXT 
31c2 cd 50 1c			call macro_forth_rsp_next 
31c5				endm 
# End of macro FORTH_RSP_NEXT
31c5					if DEBUG_FORTH_WORDS 
31c5						DMARK "DO3" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 77 fb			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 78 fb			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 79 fb			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "DO3"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de						CALLMONITOR 
31de cd 19 17			call break_point_state  
31e1				endm  
# End of macro CALLMONITOR
31e1					endif 
31e1			 
31e1					;if DEBUG_FORTH_WORDS 
31e1				;		push hl 
31e1			;		endif  
31e1			 
31e1			; get counters from data stack 
31e1			 
31e1			 
31e1					FORTH_DSP_VALUEHL 
31e1 cd a0 1e			call macro_dsp_valuehl 
31e4				endm 
# End of macro FORTH_DSP_VALUEHL
31e4 e5					push hl		 ; hl now has starting counter which needs to be tos 
31e5			 
31e5					if DEBUG_FORTH_WORDS 
31e5						DMARK "DO4" 
31e5 f5				push af  
31e6 3a fa 31			ld a, (.dmark)  
31e9 32 77 fb			ld (debug_mark),a  
31ec 3a fb 31			ld a, (.dmark+1)  
31ef 32 78 fb			ld (debug_mark+1),a  
31f2 3a fc 31			ld a, (.dmark+2)  
31f5 32 79 fb			ld (debug_mark+2),a  
31f8 18 03			jr .pastdmark  
31fa ..			.dmark: db "DO4"  
31fd f1			.pastdmark: pop af  
31fe			endm  
# End of macro DMARK
31fe						CALLMONITOR 
31fe cd 19 17			call break_point_state  
3201				endm  
# End of macro CALLMONITOR
3201					endif 
3201					FORTH_DSP_POP 
3201 cd 58 1f			call macro_forth_dsp_pop 
3204				endm 
# End of macro FORTH_DSP_POP
3204			 
3204					if DEBUG_FORTH_WORDS 
3204						DMARK "DO5" 
3204 f5				push af  
3205 3a 19 32			ld a, (.dmark)  
3208 32 77 fb			ld (debug_mark),a  
320b 3a 1a 32			ld a, (.dmark+1)  
320e 32 78 fb			ld (debug_mark+1),a  
3211 3a 1b 32			ld a, (.dmark+2)  
3214 32 79 fb			ld (debug_mark+2),a  
3217 18 03			jr .pastdmark  
3219 ..			.dmark: db "DO5"  
321c f1			.pastdmark: pop af  
321d			endm  
# End of macro DMARK
321d						CALLMONITOR 
321d cd 19 17			call break_point_state  
3220				endm  
# End of macro CALLMONITOR
3220					endif 
3220			 
3220					FORTH_DSP_VALUEHL 
3220 cd a0 1e			call macro_dsp_valuehl 
3223				endm 
# End of macro FORTH_DSP_VALUEHL
3223			;		push hl		 ; hl now has starting limit counter 
3223			 
3223					if DEBUG_FORTH_WORDS 
3223						DMARK "DO6" 
3223 f5				push af  
3224 3a 38 32			ld a, (.dmark)  
3227 32 77 fb			ld (debug_mark),a  
322a 3a 39 32			ld a, (.dmark+1)  
322d 32 78 fb			ld (debug_mark+1),a  
3230 3a 3a 32			ld a, (.dmark+2)  
3233 32 79 fb			ld (debug_mark+2),a  
3236 18 03			jr .pastdmark  
3238 ..			.dmark: db "DO6"  
323b f1			.pastdmark: pop af  
323c			endm  
# End of macro DMARK
323c						CALLMONITOR 
323c cd 19 17			call break_point_state  
323f				endm  
# End of macro CALLMONITOR
323f					endif 
323f					FORTH_DSP_POP 
323f cd 58 1f			call macro_forth_dsp_pop 
3242				endm 
# End of macro FORTH_DSP_POP
3242			 
3242			; put counters on the loop stack 
3242			 
3242			;		pop hl			 ; limit counter 
3242 d1					pop de			; start counter 
3243			 
3243					; push limit counter 
3243			 
3243					if DEBUG_FORTH_WORDS 
3243						DMARK "DO7" 
3243 f5				push af  
3244 3a 58 32			ld a, (.dmark)  
3247 32 77 fb			ld (debug_mark),a  
324a 3a 59 32			ld a, (.dmark+1)  
324d 32 78 fb			ld (debug_mark+1),a  
3250 3a 5a 32			ld a, (.dmark+2)  
3253 32 79 fb			ld (debug_mark+2),a  
3256 18 03			jr .pastdmark  
3258 ..			.dmark: db "DO7"  
325b f1			.pastdmark: pop af  
325c			endm  
# End of macro DMARK
325c						CALLMONITOR 
325c cd 19 17			call break_point_state  
325f				endm  
# End of macro CALLMONITOR
325f					endif 
325f					FORTH_LOOP_NEXT 
325f cd d1 1e			call macro_forth_loop_next 
3262				endm 
# End of macro FORTH_LOOP_NEXT
3262			 
3262					; push start counter 
3262			 
3262 eb					ex de, hl 
3263					if DEBUG_FORTH_WORDS 
3263						DMARK "DO7" 
3263 f5				push af  
3264 3a 78 32			ld a, (.dmark)  
3267 32 77 fb			ld (debug_mark),a  
326a 3a 79 32			ld a, (.dmark+1)  
326d 32 78 fb			ld (debug_mark+1),a  
3270 3a 7a 32			ld a, (.dmark+2)  
3273 32 79 fb			ld (debug_mark+2),a  
3276 18 03			jr .pastdmark  
3278 ..			.dmark: db "DO7"  
327b f1			.pastdmark: pop af  
327c			endm  
# End of macro DMARK
327c						CALLMONITOR 
327c cd 19 17			call break_point_state  
327f				endm  
# End of macro CALLMONITOR
327f					endif 
327f					FORTH_LOOP_NEXT 
327f cd d1 1e			call macro_forth_loop_next 
3282				endm 
# End of macro FORTH_LOOP_NEXT
3282			 
3282			 
3282					; init first round of I counter 
3282			 
3282 22 42 f1				ld (os_current_i), hl 
3285			 
3285					if DEBUG_FORTH_WORDS 
3285						DMARK "DO8" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 77 fb			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 78 fb			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 79 fb			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "DO8"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e						CALLMONITOR 
329e cd 19 17			call break_point_state  
32a1				endm  
# End of macro CALLMONITOR
32a1					endif 
32a1			 
32a1					NEXTW 
32a1 c3 12 20			jp macro_next 
32a4				endm 
# End of macro NEXTW
32a4			.LOOP: 
32a4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
32a4 22				db WORD_SYS_CORE+14             
32a5 bc 33			dw .I            
32a7 05				db 4 + 1 
32a8 .. 00			db "LOOP",0              
32ad				endm 
# End of macro CWHEAD
32ad			; | LOOP ( -- ) Increment and test loop counter  | DONE 
32ad			 
32ad				; pop tos as current loop count to hl 
32ad			 
32ad				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32ad			 
32ad				FORTH_LOOP_TOS 
32ad cd 04 1f			call macro_forth_loop_tos 
32b0				endm 
# End of macro FORTH_LOOP_TOS
32b0 e5				push hl 
32b1			 
32b1					if DEBUG_FORTH_WORDS_KEY 
32b1						DMARK "LOP" 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 77 fb			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 78 fb			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 79 fb			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db "LOP"  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd 19 17			call break_point_state  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd				; next item on the stack is the limit. get it 
32cd			 
32cd			 
32cd				FORTH_LOOP_POP 
32cd cd 0e 1f			call macro_forth_loop_pop 
32d0				endm 
# End of macro FORTH_LOOP_POP
32d0			 
32d0				FORTH_LOOP_TOS 
32d0 cd 04 1f			call macro_forth_loop_tos 
32d3				endm 
# End of macro FORTH_LOOP_TOS
32d3			 
32d3 d1				pop de		 ; de = i, hl = limit 
32d4			 
32d4					if DEBUG_FORTH_WORDS 
32d4						DMARK "LP1" 
32d4 f5				push af  
32d5 3a e9 32			ld a, (.dmark)  
32d8 32 77 fb			ld (debug_mark),a  
32db 3a ea 32			ld a, (.dmark+1)  
32de 32 78 fb			ld (debug_mark+1),a  
32e1 3a eb 32			ld a, (.dmark+2)  
32e4 32 79 fb			ld (debug_mark+2),a  
32e7 18 03			jr .pastdmark  
32e9 ..			.dmark: db "LP1"  
32ec f1			.pastdmark: pop af  
32ed			endm  
# End of macro DMARK
32ed						CALLMONITOR 
32ed cd 19 17			call break_point_state  
32f0				endm  
# End of macro CALLMONITOR
32f0					endif 
32f0			 
32f0				; go back to previous word 
32f0			 
32f0 d5				push de    ; save I for inc later 
32f1			 
32f1			 
32f1				; get limit 
32f1				;  is I at limit? 
32f1			 
32f1			 
32f1					if DEBUG_FORTH_WORDS 
32f1						DMARK "LP1" 
32f1 f5				push af  
32f2 3a 06 33			ld a, (.dmark)  
32f5 32 77 fb			ld (debug_mark),a  
32f8 3a 07 33			ld a, (.dmark+1)  
32fb 32 78 fb			ld (debug_mark+1),a  
32fe 3a 08 33			ld a, (.dmark+2)  
3301 32 79 fb			ld (debug_mark+2),a  
3304 18 03			jr .pastdmark  
3306 ..			.dmark: db "LP1"  
3309 f1			.pastdmark: pop af  
330a			endm  
# End of macro DMARK
330a						CALLMONITOR 
330a cd 19 17			call break_point_state  
330d				endm  
# End of macro CALLMONITOR
330d					endif 
330d			 
330d ed 52			sbc hl, de 
330f			 
330f			 
330f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
330f			 
330f 20 26				jr nz, .loopnotdone 
3311			 
3311 e1				pop hl   ; get rid of saved I 
3312				FORTH_LOOP_POP     ; get rid of limit 
3312 cd 0e 1f			call macro_forth_loop_pop 
3315				endm 
# End of macro FORTH_LOOP_POP
3315			 
3315				FORTH_RSP_POP     ; get rid of DO ptr 
3315 cd 71 1c			call macro_forth_rsp_pop 
3318				endm 
# End of macro FORTH_RSP_POP
3318			 
3318			if DEBUG_FORTH_WORDS 
3318						DMARK "LP>" 
3318 f5				push af  
3319 3a 2d 33			ld a, (.dmark)  
331c 32 77 fb			ld (debug_mark),a  
331f 3a 2e 33			ld a, (.dmark+1)  
3322 32 78 fb			ld (debug_mark+1),a  
3325 3a 2f 33			ld a, (.dmark+2)  
3328 32 79 fb			ld (debug_mark+2),a  
332b 18 03			jr .pastdmark  
332d ..			.dmark: db "LP>"  
3330 f1			.pastdmark: pop af  
3331			endm  
# End of macro DMARK
3331				CALLMONITOR 
3331 cd 19 17			call break_point_state  
3334				endm  
# End of macro CALLMONITOR
3334			endif 
3334			 
3334					NEXTW 
3334 c3 12 20			jp macro_next 
3337				endm 
# End of macro NEXTW
3337				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3337			 
3337			.loopnotdone: 
3337			 
3337 e1				pop hl    ; get I 
3338 23				inc hl 
3339			 
3339			   	; save new I 
3339			 
3339			 
3339					; set I counter 
3339			 
3339 22 42 f1				ld (os_current_i), hl 
333c			 
333c					if DEBUG_FORTH_WORDS 
333c						DMARK "LPN" 
333c f5				push af  
333d 3a 51 33			ld a, (.dmark)  
3340 32 77 fb			ld (debug_mark),a  
3343 3a 52 33			ld a, (.dmark+1)  
3346 32 78 fb			ld (debug_mark+1),a  
3349 3a 53 33			ld a, (.dmark+2)  
334c 32 79 fb			ld (debug_mark+2),a  
334f 18 03			jr .pastdmark  
3351 ..			.dmark: db "LPN"  
3354 f1			.pastdmark: pop af  
3355			endm  
# End of macro DMARK
3355					CALLMONITOR 
3355 cd 19 17			call break_point_state  
3358				endm  
# End of macro CALLMONITOR
3358					endif 
3358					 
3358				FORTH_LOOP_NEXT 
3358 cd d1 1e			call macro_forth_loop_next 
335b				endm 
# End of macro FORTH_LOOP_NEXT
335b			 
335b			 
335b					if DEBUG_FORTH_WORDS 
335b eb						ex de,hl 
335c					endif 
335c			 
335c			;	; get DO ptr 
335c			; 
335c					if DEBUG_FORTH_WORDS 
335c						DMARK "LP7" 
335c f5				push af  
335d 3a 71 33			ld a, (.dmark)  
3360 32 77 fb			ld (debug_mark),a  
3363 3a 72 33			ld a, (.dmark+1)  
3366 32 78 fb			ld (debug_mark+1),a  
3369 3a 73 33			ld a, (.dmark+2)  
336c 32 79 fb			ld (debug_mark+2),a  
336f 18 03			jr .pastdmark  
3371 ..			.dmark: db "LP7"  
3374 f1			.pastdmark: pop af  
3375			endm  
# End of macro DMARK
3375					CALLMONITOR 
3375 cd 19 17			call break_point_state  
3378				endm  
# End of macro CALLMONITOR
3378					endif 
3378				FORTH_RSP_TOS 
3378 cd 67 1c			call macro_forth_rsp_tos 
337b				endm 
# End of macro FORTH_RSP_TOS
337b			 
337b					if DEBUG_FORTH_WORDS 
337b						DMARK "LP8" 
337b f5				push af  
337c 3a 90 33			ld a, (.dmark)  
337f 32 77 fb			ld (debug_mark),a  
3382 3a 91 33			ld a, (.dmark+1)  
3385 32 78 fb			ld (debug_mark+1),a  
3388 3a 92 33			ld a, (.dmark+2)  
338b 32 79 fb			ld (debug_mark+2),a  
338e 18 03			jr .pastdmark  
3390 ..			.dmark: db "LP8"  
3393 f1			.pastdmark: pop af  
3394			endm  
# End of macro DMARK
3394					CALLMONITOR 
3394 cd 19 17			call break_point_state  
3397				endm  
# End of macro CALLMONITOR
3397					endif 
3397				;push hl 
3397			 
3397				; not going to DO any more 
3397				; get rid of the RSP pointer as DO will add it back in 
3397				;FORTH_RSP_POP 
3397				;pop hl 
3397			 
3397				;ld hl,(cli_ret_sp) 
3397				;ld e, (hl) 
3397				;inc hl 
3397				;ld d, (hl) 
3397				;ex de,hl 
3397 22 1e f1			ld (os_tok_ptr), hl 
339a					if DEBUG_FORTH_WORDS 
339a						DMARK "LP<" 
339a f5				push af  
339b 3a af 33			ld a, (.dmark)  
339e 32 77 fb			ld (debug_mark),a  
33a1 3a b0 33			ld a, (.dmark+1)  
33a4 32 78 fb			ld (debug_mark+1),a  
33a7 3a b1 33			ld a, (.dmark+2)  
33aa 32 79 fb			ld (debug_mark+2),a  
33ad 18 03			jr .pastdmark  
33af ..			.dmark: db "LP<"  
33b2 f1			.pastdmark: pop af  
33b3			endm  
# End of macro DMARK
33b3					CALLMONITOR 
33b3 cd 19 17			call break_point_state  
33b6				endm  
# End of macro CALLMONITOR
33b6				endif 
33b6 c3 a3 20			jp exec1 
33b9			 
33b9					 
33b9			 
33b9			 
33b9					NEXTW 
33b9 c3 12 20			jp macro_next 
33bc				endm 
# End of macro NEXTW
33bc			.I:  
33bc			 
33bc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
33bc 5e				db WORD_SYS_CORE+74             
33bd e7 33			dw .DLOOP            
33bf 02				db 1 + 1 
33c0 .. 00			db "I",0              
33c2				endm 
# End of macro CWHEAD
33c2			; | I ( -- ) Current loop counter | DONE 
33c2					if DEBUG_FORTH_WORDS_KEY 
33c2						DMARK "I.." 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 77 fb			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 78 fb			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 79 fb			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "I.."  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db						CALLMONITOR 
33db cd 19 17			call break_point_state  
33de				endm  
# End of macro CALLMONITOR
33de					endif 
33de			 
33de 2a 42 f1				ld hl,(os_current_i) 
33e1 cd a9 1c				call forth_push_numhl 
33e4			 
33e4					NEXTW 
33e4 c3 12 20			jp macro_next 
33e7				endm 
# End of macro NEXTW
33e7			.DLOOP: 
33e7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
33e7 5f				db WORD_SYS_CORE+75             
33e8 c8 34			dw .REPEAT            
33ea 06				db 5 + 1 
33eb .. 00			db "-LOOP",0              
33f1				endm 
# End of macro CWHEAD
33f1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
33f1				; pop tos as current loop count to hl 
33f1					if DEBUG_FORTH_WORDS_KEY 
33f1						DMARK "-LP" 
33f1 f5				push af  
33f2 3a 06 34			ld a, (.dmark)  
33f5 32 77 fb			ld (debug_mark),a  
33f8 3a 07 34			ld a, (.dmark+1)  
33fb 32 78 fb			ld (debug_mark+1),a  
33fe 3a 08 34			ld a, (.dmark+2)  
3401 32 79 fb			ld (debug_mark+2),a  
3404 18 03			jr .pastdmark  
3406 ..			.dmark: db "-LP"  
3409 f1			.pastdmark: pop af  
340a			endm  
# End of macro DMARK
340a						CALLMONITOR 
340a cd 19 17			call break_point_state  
340d				endm  
# End of macro CALLMONITOR
340d					endif 
340d			 
340d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
340d			 
340d				FORTH_LOOP_TOS 
340d cd 04 1f			call macro_forth_loop_tos 
3410				endm 
# End of macro FORTH_LOOP_TOS
3410 e5				push hl 
3411			 
3411					if DEBUG_FORTH_WORDS 
3411						DMARK "-LP" 
3411 f5				push af  
3412 3a 26 34			ld a, (.dmark)  
3415 32 77 fb			ld (debug_mark),a  
3418 3a 27 34			ld a, (.dmark+1)  
341b 32 78 fb			ld (debug_mark+1),a  
341e 3a 28 34			ld a, (.dmark+2)  
3421 32 79 fb			ld (debug_mark+2),a  
3424 18 03			jr .pastdmark  
3426 ..			.dmark: db "-LP"  
3429 f1			.pastdmark: pop af  
342a			endm  
# End of macro DMARK
342a						CALLMONITOR 
342a cd 19 17			call break_point_state  
342d				endm  
# End of macro CALLMONITOR
342d					endif 
342d				; next item on the stack is the limit. get it 
342d			 
342d			 
342d				FORTH_LOOP_POP 
342d cd 0e 1f			call macro_forth_loop_pop 
3430				endm 
# End of macro FORTH_LOOP_POP
3430			 
3430				FORTH_LOOP_TOS 
3430 cd 04 1f			call macro_forth_loop_tos 
3433				endm 
# End of macro FORTH_LOOP_TOS
3433			 
3433 d1				pop de		 ; de = i, hl = limit 
3434			 
3434					if DEBUG_FORTH_WORDS 
3434						DMARK "-L1" 
3434 f5				push af  
3435 3a 49 34			ld a, (.dmark)  
3438 32 77 fb			ld (debug_mark),a  
343b 3a 4a 34			ld a, (.dmark+1)  
343e 32 78 fb			ld (debug_mark+1),a  
3441 3a 4b 34			ld a, (.dmark+2)  
3444 32 79 fb			ld (debug_mark+2),a  
3447 18 03			jr .pastdmark  
3449 ..			.dmark: db "-L1"  
344c f1			.pastdmark: pop af  
344d			endm  
# End of macro DMARK
344d						CALLMONITOR 
344d cd 19 17			call break_point_state  
3450				endm  
# End of macro CALLMONITOR
3450					endif 
3450			 
3450				; go back to previous word 
3450			 
3450 d5				push de    ; save I for inc later 
3451			 
3451			 
3451				; get limit 
3451				;  is I at limit? 
3451			 
3451			 
3451					if DEBUG_FORTH_WORDS 
3451						DMARK "-L1" 
3451 f5				push af  
3452 3a 66 34			ld a, (.dmark)  
3455 32 77 fb			ld (debug_mark),a  
3458 3a 67 34			ld a, (.dmark+1)  
345b 32 78 fb			ld (debug_mark+1),a  
345e 3a 68 34			ld a, (.dmark+2)  
3461 32 79 fb			ld (debug_mark+2),a  
3464 18 03			jr .pastdmark  
3466 ..			.dmark: db "-L1"  
3469 f1			.pastdmark: pop af  
346a			endm  
# End of macro DMARK
346a						CALLMONITOR 
346a cd 19 17			call break_point_state  
346d				endm  
# End of macro CALLMONITOR
346d					endif 
346d			 
346d ed 52			sbc hl, de 
346f			 
346f			 
346f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
346f			 
346f 20 26				jr nz, .mloopnotdone 
3471			 
3471 e1				pop hl   ; get rid of saved I 
3472				FORTH_LOOP_POP     ; get rid of limit 
3472 cd 0e 1f			call macro_forth_loop_pop 
3475				endm 
# End of macro FORTH_LOOP_POP
3475			 
3475				FORTH_RSP_POP     ; get rid of DO ptr 
3475 cd 71 1c			call macro_forth_rsp_pop 
3478				endm 
# End of macro FORTH_RSP_POP
3478			 
3478			if DEBUG_FORTH_WORDS 
3478						DMARK "-L>" 
3478 f5				push af  
3479 3a 8d 34			ld a, (.dmark)  
347c 32 77 fb			ld (debug_mark),a  
347f 3a 8e 34			ld a, (.dmark+1)  
3482 32 78 fb			ld (debug_mark+1),a  
3485 3a 8f 34			ld a, (.dmark+2)  
3488 32 79 fb			ld (debug_mark+2),a  
348b 18 03			jr .pastdmark  
348d ..			.dmark: db "-L>"  
3490 f1			.pastdmark: pop af  
3491			endm  
# End of macro DMARK
3491				CALLMONITOR 
3491 cd 19 17			call break_point_state  
3494				endm  
# End of macro CALLMONITOR
3494			endif 
3494			 
3494					NEXTW 
3494 c3 12 20			jp macro_next 
3497				endm 
# End of macro NEXTW
3497				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3497			 
3497			.mloopnotdone: 
3497			 
3497 e1				pop hl    ; get I 
3498 2b				dec hl 
3499			 
3499			   	; save new I 
3499			 
3499			 
3499					; set I counter 
3499			 
3499 22 42 f1				ld (os_current_i), hl 
349c			 
349c					 
349c				FORTH_LOOP_NEXT 
349c cd d1 1e			call macro_forth_loop_next 
349f				endm 
# End of macro FORTH_LOOP_NEXT
349f			 
349f			 
349f					if DEBUG_FORTH_WORDS 
349f eb						ex de,hl 
34a0					endif 
34a0			 
34a0			;	; get DO ptr 
34a0			; 
34a0				FORTH_RSP_TOS 
34a0 cd 67 1c			call macro_forth_rsp_tos 
34a3				endm 
# End of macro FORTH_RSP_TOS
34a3			 
34a3				;push hl 
34a3			 
34a3				; not going to DO any more 
34a3				; get rid of the RSP pointer as DO will add it back in 
34a3				;FORTH_RSP_POP 
34a3				;pop hl 
34a3			 
34a3			 
34a3 22 1e f1			ld (os_tok_ptr), hl 
34a6					if DEBUG_FORTH_WORDS 
34a6						DMARK "-L<" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 77 fb			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 78 fb			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 79 fb			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "-L<"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf					CALLMONITOR 
34bf cd 19 17			call break_point_state  
34c2				endm  
# End of macro CALLMONITOR
34c2				endif 
34c2 c3 a3 20			jp exec1 
34c5			 
34c5					 
34c5			 
34c5			 
34c5			 
34c5				NEXTW 
34c5 c3 12 20			jp macro_next 
34c8				endm 
# End of macro NEXTW
34c8			 
34c8			 
34c8			 
34c8			 
34c8			.REPEAT: 
34c8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
34c8 71				db WORD_SYS_CORE+93             
34c9 1b 35			dw .UNTIL            
34cb 06				db 5 + 1 
34cc .. 00			db "REPEAT",0              
34d3				endm 
# End of macro CWHEAD
34d3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
34d3			;  push pc to rsp stack past the REPEAT 
34d3					if DEBUG_FORTH_WORDS_KEY 
34d3						DMARK "REP" 
34d3 f5				push af  
34d4 3a e8 34			ld a, (.dmark)  
34d7 32 77 fb			ld (debug_mark),a  
34da 3a e9 34			ld a, (.dmark+1)  
34dd 32 78 fb			ld (debug_mark+1),a  
34e0 3a ea 34			ld a, (.dmark+2)  
34e3 32 79 fb			ld (debug_mark+2),a  
34e6 18 03			jr .pastdmark  
34e8 ..			.dmark: db "REP"  
34eb f1			.pastdmark: pop af  
34ec			endm  
# End of macro DMARK
34ec						CALLMONITOR 
34ec cd 19 17			call break_point_state  
34ef				endm  
# End of macro CALLMONITOR
34ef					endif 
34ef			 
34ef 2a 1e f1				ld hl, (os_tok_ptr) 
34f2 23					inc hl   ; R 
34f3 23					inc hl  ; E 
34f4 23					inc hl   ; P 
34f5 23					inc hl   ; E 
34f6 23					inc hl   ; A 
34f7 23					inc hl   ; T 
34f8 23					inc hl   ; zero 
34f9					FORTH_RSP_NEXT 
34f9 cd 50 1c			call macro_forth_rsp_next 
34fc				endm 
# End of macro FORTH_RSP_NEXT
34fc			 
34fc			 
34fc					if DEBUG_FORTH_WORDS 
34fc						DMARK "REP" 
34fc f5				push af  
34fd 3a 11 35			ld a, (.dmark)  
3500 32 77 fb			ld (debug_mark),a  
3503 3a 12 35			ld a, (.dmark+1)  
3506 32 78 fb			ld (debug_mark+1),a  
3509 3a 13 35			ld a, (.dmark+2)  
350c 32 79 fb			ld (debug_mark+2),a  
350f 18 03			jr .pastdmark  
3511 ..			.dmark: db "REP"  
3514 f1			.pastdmark: pop af  
3515			endm  
# End of macro DMARK
3515						;pop bc    ; TODO BUG ?????? what is this for???? 
3515						CALLMONITOR 
3515 cd 19 17			call break_point_state  
3518				endm  
# End of macro CALLMONITOR
3518					endif 
3518			 
3518					NEXTW 
3518 c3 12 20			jp macro_next 
351b				endm 
# End of macro NEXTW
351b			;	       NEXTW 
351b			 
351b			.UNTIL: 
351b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
351b 72				db WORD_SYS_CORE+94             
351c b2 35			dw .ENDFLOW            
351e 06				db 5 + 1 
351f .. 00			db "UNTIL",0              
3525				endm 
# End of macro CWHEAD
3525			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3525			 
3525				; pop tos as check 
3525			 
3525				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3525			 
3525				FORTH_DSP_VALUEHL 
3525 cd a0 1e			call macro_dsp_valuehl 
3528				endm 
# End of macro FORTH_DSP_VALUEHL
3528			 
3528					if DEBUG_FORTH_WORDS_KEY 
3528						DMARK "UNT" 
3528 f5				push af  
3529 3a 3d 35			ld a, (.dmark)  
352c 32 77 fb			ld (debug_mark),a  
352f 3a 3e 35			ld a, (.dmark+1)  
3532 32 78 fb			ld (debug_mark+1),a  
3535 3a 3f 35			ld a, (.dmark+2)  
3538 32 79 fb			ld (debug_mark+2),a  
353b 18 03			jr .pastdmark  
353d ..			.dmark: db "UNT"  
3540 f1			.pastdmark: pop af  
3541			endm  
# End of macro DMARK
3541						CALLMONITOR 
3541 cd 19 17			call break_point_state  
3544				endm  
# End of macro CALLMONITOR
3544					endif 
3544			 
3544			;	push hl 
3544				FORTH_DSP_POP 
3544 cd 58 1f			call macro_forth_dsp_pop 
3547				endm 
# End of macro FORTH_DSP_POP
3547			 
3547			;	pop hl 
3547			 
3547				; test if true 
3547			 
3547 cd 32 0d			call ishlzero 
354a			;	ld a,l 
354a			;	add h 
354a			; 
354a			;	cp 0 
354a			 
354a 20 3e			jr nz, .untilnotdone 
354c			 
354c					if DEBUG_FORTH_WORDS 
354c						DMARK "UNf" 
354c f5				push af  
354d 3a 61 35			ld a, (.dmark)  
3550 32 77 fb			ld (debug_mark),a  
3553 3a 62 35			ld a, (.dmark+1)  
3556 32 78 fb			ld (debug_mark+1),a  
3559 3a 63 35			ld a, (.dmark+2)  
355c 32 79 fb			ld (debug_mark+2),a  
355f 18 03			jr .pastdmark  
3561 ..			.dmark: db "UNf"  
3564 f1			.pastdmark: pop af  
3565			endm  
# End of macro DMARK
3565						CALLMONITOR 
3565 cd 19 17			call break_point_state  
3568				endm  
# End of macro CALLMONITOR
3568					endif 
3568			 
3568			 
3568			 
3568				FORTH_RSP_POP     ; get rid of DO ptr 
3568 cd 71 1c			call macro_forth_rsp_pop 
356b				endm 
# End of macro FORTH_RSP_POP
356b			 
356b			if DEBUG_FORTH_WORDS 
356b						DMARK "UN>" 
356b f5				push af  
356c 3a 80 35			ld a, (.dmark)  
356f 32 77 fb			ld (debug_mark),a  
3572 3a 81 35			ld a, (.dmark+1)  
3575 32 78 fb			ld (debug_mark+1),a  
3578 3a 82 35			ld a, (.dmark+2)  
357b 32 79 fb			ld (debug_mark+2),a  
357e 18 03			jr .pastdmark  
3580 ..			.dmark: db "UN>"  
3583 f1			.pastdmark: pop af  
3584			endm  
# End of macro DMARK
3584				CALLMONITOR 
3584 cd 19 17			call break_point_state  
3587				endm  
# End of macro CALLMONITOR
3587			endif 
3587			 
3587					NEXTW 
3587 c3 12 20			jp macro_next 
358a				endm 
# End of macro NEXTW
358a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
358a			 
358a			.untilnotdone: 
358a			 
358a			 
358a			;	; get DO ptr 
358a			; 
358a				FORTH_RSP_TOS 
358a cd 67 1c			call macro_forth_rsp_tos 
358d				endm 
# End of macro FORTH_RSP_TOS
358d			 
358d				;push hl 
358d			 
358d				; not going to DO any more 
358d				; get rid of the RSP pointer as DO will add it back in 
358d				;FORTH_RSP_POP 
358d				;pop hl 
358d			 
358d			 
358d 22 1e f1			ld (os_tok_ptr), hl 
3590					if DEBUG_FORTH_WORDS 
3590						DMARK "UN<" 
3590 f5				push af  
3591 3a a5 35			ld a, (.dmark)  
3594 32 77 fb			ld (debug_mark),a  
3597 3a a6 35			ld a, (.dmark+1)  
359a 32 78 fb			ld (debug_mark+1),a  
359d 3a a7 35			ld a, (.dmark+2)  
35a0 32 79 fb			ld (debug_mark+2),a  
35a3 18 03			jr .pastdmark  
35a5 ..			.dmark: db "UN<"  
35a8 f1			.pastdmark: pop af  
35a9			endm  
# End of macro DMARK
35a9					CALLMONITOR 
35a9 cd 19 17			call break_point_state  
35ac				endm  
# End of macro CALLMONITOR
35ac				endif 
35ac c3 a3 20			jp exec1 
35af			 
35af					 
35af			 
35af			 
35af					NEXTW 
35af c3 12 20			jp macro_next 
35b2				endm 
# End of macro NEXTW
35b2			 
35b2			 
35b2			.ENDFLOW: 
35b2			 
35b2			; eof 
35b2			 
# End of file forth_words_flow.asm
35b2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
35b2			include "forth_words_logic.asm" 
35b2			 
35b2			; | ## Logic Words 
35b2			 
35b2			.NOT: 
35b2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
35b2 2d				db WORD_SYS_CORE+25             
35b3 fa 35			dw .IS            
35b5 04				db 3 + 1 
35b6 .. 00			db "NOT",0              
35ba				endm 
# End of macro CWHEAD
35ba			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
35ba					if DEBUG_FORTH_WORDS_KEY 
35ba						DMARK "NOT" 
35ba f5				push af  
35bb 3a cf 35			ld a, (.dmark)  
35be 32 77 fb			ld (debug_mark),a  
35c1 3a d0 35			ld a, (.dmark+1)  
35c4 32 78 fb			ld (debug_mark+1),a  
35c7 3a d1 35			ld a, (.dmark+2)  
35ca 32 79 fb			ld (debug_mark+2),a  
35cd 18 03			jr .pastdmark  
35cf ..			.dmark: db "NOT"  
35d2 f1			.pastdmark: pop af  
35d3			endm  
# End of macro DMARK
35d3						CALLMONITOR 
35d3 cd 19 17			call break_point_state  
35d6				endm  
# End of macro CALLMONITOR
35d6					endif 
35d6					FORTH_DSP 
35d6 cd 66 1e			call macro_forth_dsp 
35d9				endm 
# End of macro FORTH_DSP
35d9 7e					ld a,(hl)	; get type of value on TOS 
35da fe 02				cp DS_TYPE_INUM  
35dc 28 03				jr z, .noti 
35de					NEXTW 
35de c3 12 20			jp macro_next 
35e1				endm 
# End of macro NEXTW
35e1			.noti:          FORTH_DSP_VALUEHL 
35e1 cd a0 1e			call macro_dsp_valuehl 
35e4				endm 
# End of macro FORTH_DSP_VALUEHL
35e4			;		push hl 
35e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e4 cd 58 1f			call macro_forth_dsp_pop 
35e7				endm 
# End of macro FORTH_DSP_POP
35e7			;		pop hl 
35e7 3e 00				ld a,0 
35e9 bd					cp l 
35ea 28 04				jr z, .not2t 
35ec 2e 00				ld l, 0 
35ee 18 02				jr .notip 
35f0			 
35f0 2e ff		.not2t:		ld l, 255 
35f2			 
35f2 26 00		.notip:		ld h, 0	 
35f4			 
35f4 cd a9 1c				call forth_push_numhl 
35f7					NEXTW 
35f7 c3 12 20			jp macro_next 
35fa				endm 
# End of macro NEXTW
35fa			 
35fa			.IS: 
35fa				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
35fa 2d				db WORD_SYS_CORE+25             
35fb 20 36			dw .LZERO            
35fd 03				db 2 + 1 
35fe .. 00			db "IS",0              
3601				endm 
# End of macro CWHEAD
3601			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3601					if DEBUG_FORTH_WORDS_KEY 
3601						DMARK "IS." 
3601 f5				push af  
3602 3a 16 36			ld a, (.dmark)  
3605 32 77 fb			ld (debug_mark),a  
3608 3a 17 36			ld a, (.dmark+1)  
360b 32 78 fb			ld (debug_mark+1),a  
360e 3a 18 36			ld a, (.dmark+2)  
3611 32 79 fb			ld (debug_mark+2),a  
3614 18 03			jr .pastdmark  
3616 ..			.dmark: db "IS."  
3619 f1			.pastdmark: pop af  
361a			endm  
# End of macro DMARK
361a						CALLMONITOR 
361a cd 19 17			call break_point_state  
361d				endm  
# End of macro CALLMONITOR
361d					endif 
361d					NEXTW 
361d c3 12 20			jp macro_next 
3620				endm 
# End of macro NEXTW
3620			.LZERO: 
3620				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3620 2d				db WORD_SYS_CORE+25             
3621 2a 36			dw .TZERO            
3623 03				db 2 + 1 
3624 .. 00			db "0<",0              
3627				endm 
# End of macro CWHEAD
3627			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3627					NEXTW 
3627 c3 12 20			jp macro_next 
362a				endm 
# End of macro NEXTW
362a			.TZERO: 
362a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
362a 2e				db WORD_SYS_CORE+26             
362b 71 36			dw .LESS            
362d 03				db 2 + 1 
362e .. 00			db "0=",0              
3631				endm 
# End of macro CWHEAD
3631			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3631				; TODO add floating point number detection 
3631					;v5 FORTH_DSP_VALUE 
3631					if DEBUG_FORTH_WORDS_KEY 
3631						DMARK "0=." 
3631 f5				push af  
3632 3a 46 36			ld a, (.dmark)  
3635 32 77 fb			ld (debug_mark),a  
3638 3a 47 36			ld a, (.dmark+1)  
363b 32 78 fb			ld (debug_mark+1),a  
363e 3a 48 36			ld a, (.dmark+2)  
3641 32 79 fb			ld (debug_mark+2),a  
3644 18 03			jr .pastdmark  
3646 ..			.dmark: db "0=."  
3649 f1			.pastdmark: pop af  
364a			endm  
# End of macro DMARK
364a						CALLMONITOR 
364a cd 19 17			call break_point_state  
364d				endm  
# End of macro CALLMONITOR
364d					endif 
364d					FORTH_DSP 
364d cd 66 1e			call macro_forth_dsp 
3650				endm 
# End of macro FORTH_DSP
3650 7e					ld a,(hl)	; get type of value on TOS 
3651 fe 02				cp DS_TYPE_INUM  
3653 28 00				jr z, .tz_inum 
3655			 
3655				if FORTH_ENABLE_FLOATMATH 
3655					jr .tz_done 
3655			 
3655				endif 
3655					 
3655			 
3655			.tz_inum: 
3655					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3655 cd a0 1e			call macro_dsp_valuehl 
3658				endm 
# End of macro FORTH_DSP_VALUEHL
3658			 
3658			;		push hl 
3658			 
3658					; destroy value TOS 
3658			 
3658					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3658 cd 58 1f			call macro_forth_dsp_pop 
365b				endm 
# End of macro FORTH_DSP_POP
365b			 
365b			;		pop hl 
365b			 
365b 3e 00				ld a,0 
365d			 
365d bd					cp l 
365e 20 08				jr nz, .tz_notzero 
3660			 
3660 bc					cp h 
3661			 
3661 20 05				jr nz, .tz_notzero 
3663			 
3663			 
3663 21 01 00				ld hl, FORTH_TRUE 
3666 18 03				jr .tz_done 
3668			 
3668 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
366b			 
366b					; push value back onto stack for another op etc 
366b			 
366b			.tz_done: 
366b cd a9 1c				call forth_push_numhl 
366e			 
366e					NEXTW 
366e c3 12 20			jp macro_next 
3671				endm 
# End of macro NEXTW
3671			.LESS: 
3671				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3671 2f				db WORD_SYS_CORE+27             
3672 da 36			dw .GT            
3674 02				db 1 + 1 
3675 .. 00			db "<",0              
3677				endm 
# End of macro CWHEAD
3677			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3677				; TODO add floating point number detection 
3677					if DEBUG_FORTH_WORDS_KEY 
3677						DMARK "LES" 
3677 f5				push af  
3678 3a 8c 36			ld a, (.dmark)  
367b 32 77 fb			ld (debug_mark),a  
367e 3a 8d 36			ld a, (.dmark+1)  
3681 32 78 fb			ld (debug_mark+1),a  
3684 3a 8e 36			ld a, (.dmark+2)  
3687 32 79 fb			ld (debug_mark+2),a  
368a 18 03			jr .pastdmark  
368c ..			.dmark: db "LES"  
368f f1			.pastdmark: pop af  
3690			endm  
# End of macro DMARK
3690						CALLMONITOR 
3690 cd 19 17			call break_point_state  
3693				endm  
# End of macro CALLMONITOR
3693					endif 
3693					FORTH_DSP 
3693 cd 66 1e			call macro_forth_dsp 
3696				endm 
# End of macro FORTH_DSP
3696					;v5 FORTH_DSP_VALUE 
3696 7e					ld a,(hl)	; get type of value on TOS 
3697 fe 02				cp DS_TYPE_INUM  
3699 28 00				jr z, .less_inum 
369b			 
369b				if FORTH_ENABLE_FLOATMATH 
369b					jr .less_done 
369b			 
369b				endif 
369b					 
369b			 
369b			.less_inum: 
369b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
369b cd a0 1e			call macro_dsp_valuehl 
369e				endm 
# End of macro FORTH_DSP_VALUEHL
369e			 
369e e5					push hl  ; u2 
369f			 
369f					; destroy value TOS 
369f			 
369f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
369f cd 58 1f			call macro_forth_dsp_pop 
36a2				endm 
# End of macro FORTH_DSP_POP
36a2			 
36a2			 
36a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a2 cd a0 1e			call macro_dsp_valuehl 
36a5				endm 
# End of macro FORTH_DSP_VALUEHL
36a5			 
36a5 e5					push hl    ; u1 
36a6			 
36a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a6 cd 58 1f			call macro_forth_dsp_pop 
36a9				endm 
# End of macro FORTH_DSP_POP
36a9			 
36a9			 
36a9 b7			 or a      ;clear carry flag 
36aa 01 00 00		 ld bc, FORTH_FALSE 
36ad e1			  pop hl    ; u1 
36ae d1			  pop de    ; u2 
36af ed 52		  sbc hl,de 
36b1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
36b3			 
36b3 01 01 00		 ld bc, FORTH_TRUE 
36b6			.lscont:  
36b6 c5					push bc 
36b7 e1					pop hl 
36b8			 
36b8					if DEBUG_FORTH_WORDS 
36b8						DMARK "LT1" 
36b8 f5				push af  
36b9 3a cd 36			ld a, (.dmark)  
36bc 32 77 fb			ld (debug_mark),a  
36bf 3a ce 36			ld a, (.dmark+1)  
36c2 32 78 fb			ld (debug_mark+1),a  
36c5 3a cf 36			ld a, (.dmark+2)  
36c8 32 79 fb			ld (debug_mark+2),a  
36cb 18 03			jr .pastdmark  
36cd ..			.dmark: db "LT1"  
36d0 f1			.pastdmark: pop af  
36d1			endm  
# End of macro DMARK
36d1						CALLMONITOR 
36d1 cd 19 17			call break_point_state  
36d4				endm  
# End of macro CALLMONITOR
36d4					endif 
36d4 cd a9 1c				call forth_push_numhl 
36d7			 
36d7					NEXTW 
36d7 c3 12 20			jp macro_next 
36da				endm 
# End of macro NEXTW
36da			.GT: 
36da				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
36da 30				db WORD_SYS_CORE+28             
36db 43 37			dw .EQUAL            
36dd 02				db 1 + 1 
36de .. 00			db ">",0              
36e0				endm 
# End of macro CWHEAD
36e0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
36e0				; TODO add floating point number detection 
36e0					if DEBUG_FORTH_WORDS_KEY 
36e0						DMARK "GRT" 
36e0 f5				push af  
36e1 3a f5 36			ld a, (.dmark)  
36e4 32 77 fb			ld (debug_mark),a  
36e7 3a f6 36			ld a, (.dmark+1)  
36ea 32 78 fb			ld (debug_mark+1),a  
36ed 3a f7 36			ld a, (.dmark+2)  
36f0 32 79 fb			ld (debug_mark+2),a  
36f3 18 03			jr .pastdmark  
36f5 ..			.dmark: db "GRT"  
36f8 f1			.pastdmark: pop af  
36f9			endm  
# End of macro DMARK
36f9						CALLMONITOR 
36f9 cd 19 17			call break_point_state  
36fc				endm  
# End of macro CALLMONITOR
36fc					endif 
36fc					FORTH_DSP 
36fc cd 66 1e			call macro_forth_dsp 
36ff				endm 
# End of macro FORTH_DSP
36ff					;FORTH_DSP_VALUE 
36ff 7e					ld a,(hl)	; get type of value on TOS 
3700 fe 02				cp DS_TYPE_INUM  
3702 28 00				jr z, .gt_inum 
3704			 
3704				if FORTH_ENABLE_FLOATMATH 
3704					jr .gt_done 
3704			 
3704				endif 
3704					 
3704			 
3704			.gt_inum: 
3704					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3704 cd a0 1e			call macro_dsp_valuehl 
3707				endm 
# End of macro FORTH_DSP_VALUEHL
3707			 
3707 e5					push hl  ; u2 
3708			 
3708					; destroy value TOS 
3708			 
3708					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3708 cd 58 1f			call macro_forth_dsp_pop 
370b				endm 
# End of macro FORTH_DSP_POP
370b			 
370b			 
370b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370b cd a0 1e			call macro_dsp_valuehl 
370e				endm 
# End of macro FORTH_DSP_VALUEHL
370e			 
370e e5					push hl    ; u1 
370f			 
370f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370f cd 58 1f			call macro_forth_dsp_pop 
3712				endm 
# End of macro FORTH_DSP_POP
3712			 
3712			 
3712 b7			 or a      ;clear carry flag 
3713 01 00 00		 ld bc, FORTH_FALSE 
3716 e1			  pop hl    ; u1 
3717 d1			  pop de    ; u2 
3718 ed 52		  sbc hl,de 
371a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
371c			 
371c 01 01 00		 ld bc, FORTH_TRUE 
371f			.gtcont:  
371f c5					push bc 
3720 e1					pop hl 
3721			 
3721					if DEBUG_FORTH_WORDS 
3721						DMARK "GT1" 
3721 f5				push af  
3722 3a 36 37			ld a, (.dmark)  
3725 32 77 fb			ld (debug_mark),a  
3728 3a 37 37			ld a, (.dmark+1)  
372b 32 78 fb			ld (debug_mark+1),a  
372e 3a 38 37			ld a, (.dmark+2)  
3731 32 79 fb			ld (debug_mark+2),a  
3734 18 03			jr .pastdmark  
3736 ..			.dmark: db "GT1"  
3739 f1			.pastdmark: pop af  
373a			endm  
# End of macro DMARK
373a						CALLMONITOR 
373a cd 19 17			call break_point_state  
373d				endm  
# End of macro CALLMONITOR
373d					endif 
373d cd a9 1c				call forth_push_numhl 
3740			 
3740					NEXTW 
3740 c3 12 20			jp macro_next 
3743				endm 
# End of macro NEXTW
3743			.EQUAL: 
3743				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3743 31				db WORD_SYS_CORE+29             
3744 ae 37			dw .ENDLOGIC            
3746 02				db 1 + 1 
3747 .. 00			db "=",0              
3749				endm 
# End of macro CWHEAD
3749			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3749				; TODO add floating point number detection 
3749					if DEBUG_FORTH_WORDS_KEY 
3749						DMARK "EQ." 
3749 f5				push af  
374a 3a 5e 37			ld a, (.dmark)  
374d 32 77 fb			ld (debug_mark),a  
3750 3a 5f 37			ld a, (.dmark+1)  
3753 32 78 fb			ld (debug_mark+1),a  
3756 3a 60 37			ld a, (.dmark+2)  
3759 32 79 fb			ld (debug_mark+2),a  
375c 18 03			jr .pastdmark  
375e ..			.dmark: db "EQ."  
3761 f1			.pastdmark: pop af  
3762			endm  
# End of macro DMARK
3762						CALLMONITOR 
3762 cd 19 17			call break_point_state  
3765				endm  
# End of macro CALLMONITOR
3765					endif 
3765					FORTH_DSP 
3765 cd 66 1e			call macro_forth_dsp 
3768				endm 
# End of macro FORTH_DSP
3768					;v5 FORTH_DSP_VALUE 
3768 7e					ld a,(hl)	; get type of value on TOS 
3769 fe 02				cp DS_TYPE_INUM  
376b 28 00				jr z, .eq_inum 
376d			 
376d				if FORTH_ENABLE_FLOATMATH 
376d					jr .eq_done 
376d			 
376d				endif 
376d					 
376d			 
376d			.eq_inum: 
376d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376d cd a0 1e			call macro_dsp_valuehl 
3770				endm 
# End of macro FORTH_DSP_VALUEHL
3770			 
3770 e5					push hl 
3771			 
3771					; destroy value TOS 
3771			 
3771					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3771 cd 58 1f			call macro_forth_dsp_pop 
3774				endm 
# End of macro FORTH_DSP_POP
3774			 
3774			 
3774					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3774 cd a0 1e			call macro_dsp_valuehl 
3777				endm 
# End of macro FORTH_DSP_VALUEHL
3777			 
3777					; one value on hl get other one back 
3777			 
3777 e5					push hl 
3778			 
3778					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3778 cd 58 1f			call macro_forth_dsp_pop 
377b				endm 
# End of macro FORTH_DSP_POP
377b			 
377b 0e 00				ld c, FORTH_FALSE 
377d			 
377d e1					pop hl 
377e d1					pop de 
377f			 
377f 7b					ld a, e 
3780 bd					cp l 
3781			 
3781 20 06				jr nz, .eq_done 
3783			 
3783 7a					ld a, d 
3784 bc					cp h 
3785			 
3785 20 02				jr nz, .eq_done 
3787			 
3787 0e 01				ld c, FORTH_TRUE 
3789					 
3789			 
3789			 
3789			.eq_done: 
3789			 
3789					; TODO push value back onto stack for another op etc 
3789			 
3789 26 00				ld h, 0 
378b 69					ld l, c 
378c					if DEBUG_FORTH_WORDS 
378c						DMARK "EQ1" 
378c f5				push af  
378d 3a a1 37			ld a, (.dmark)  
3790 32 77 fb			ld (debug_mark),a  
3793 3a a2 37			ld a, (.dmark+1)  
3796 32 78 fb			ld (debug_mark+1),a  
3799 3a a3 37			ld a, (.dmark+2)  
379c 32 79 fb			ld (debug_mark+2),a  
379f 18 03			jr .pastdmark  
37a1 ..			.dmark: db "EQ1"  
37a4 f1			.pastdmark: pop af  
37a5			endm  
# End of macro DMARK
37a5						CALLMONITOR 
37a5 cd 19 17			call break_point_state  
37a8				endm  
# End of macro CALLMONITOR
37a8					endif 
37a8 cd a9 1c				call forth_push_numhl 
37ab			 
37ab					NEXTW 
37ab c3 12 20			jp macro_next 
37ae				endm 
# End of macro NEXTW
37ae			 
37ae			 
37ae			.ENDLOGIC: 
37ae			; eof 
37ae			 
37ae			 
# End of file forth_words_logic.asm
37ae			include "forth_words_maths.asm" 
37ae			 
37ae			; | ## Maths Words 
37ae			 
37ae			.PLUS:	 
37ae				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
37ae 15				db WORD_SYS_CORE+1             
37af f0 37			dw .NEG            
37b1 02				db 1 + 1 
37b2 .. 00			db "+",0              
37b4				endm 
# End of macro CWHEAD
37b4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
37b4					if DEBUG_FORTH_WORDS_KEY 
37b4						DMARK "PLU" 
37b4 f5				push af  
37b5 3a c9 37			ld a, (.dmark)  
37b8 32 77 fb			ld (debug_mark),a  
37bb 3a ca 37			ld a, (.dmark+1)  
37be 32 78 fb			ld (debug_mark+1),a  
37c1 3a cb 37			ld a, (.dmark+2)  
37c4 32 79 fb			ld (debug_mark+2),a  
37c7 18 03			jr .pastdmark  
37c9 ..			.dmark: db "PLU"  
37cc f1			.pastdmark: pop af  
37cd			endm  
# End of macro DMARK
37cd						CALLMONITOR 
37cd cd 19 17			call break_point_state  
37d0				endm  
# End of macro CALLMONITOR
37d0					endif 
37d0					; add top two values and push back result 
37d0			 
37d0					;for v5 FORTH_DSP_VALUE 
37d0					FORTH_DSP 
37d0 cd 66 1e			call macro_forth_dsp 
37d3				endm 
# End of macro FORTH_DSP
37d3 7e					ld a,(hl)	; get type of value on TOS 
37d4 fe 02				cp DS_TYPE_INUM  
37d6 28 03				jr z, .dot_inum 
37d8			 
37d8					NEXTW 
37d8 c3 12 20			jp macro_next 
37db				endm 
# End of macro NEXTW
37db			 
37db			; float maths 
37db			 
37db				if FORTH_ENABLE_FLOATMATH 
37db						inc hl      ; now at start of numeric as string 
37db			 
37db					if DEBUG_FORTH_MATHS 
37db						DMARK "ADD" 
37db				CALLMONITOR 
37db					endif 
37db			 
37db					;ld ix, hl 
37db					call CON 
37db			 
37db			 
37db					push hl 
37db					 
37db					 
37db			 
37db						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
37db			 
37db					; get next number 
37db			 
37db						FORTH_DSP_VALUE 
37db			 
37db						inc hl      ; now at start of numeric as string 
37db			 
37db					;ld ix, hl 
37db					call CON 
37db			 
37db					push hl 
37db			 
37db			 
37db						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37db			 
37db						; TODO do add 
37db			 
37db						call IADD 
37db			 
37db						; TODO get result back as ascii 
37db			 
37db						; TODO push result  
37db			 
37db			 
37db			 
37db						jr .dot_done 
37db				endif 
37db			 
37db			.dot_inum: 
37db			 
37db			 
37db					if DEBUG_FORTH_DOT 
37db						DMARK "+IT" 
37db				CALLMONITOR 
37db					endif 
37db			 
37db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37db cd a0 1e			call macro_dsp_valuehl 
37de				endm 
# End of macro FORTH_DSP_VALUEHL
37de			 
37de				; TODO add floating point number detection 
37de			 
37de e5					push hl 
37df			 
37df					; destroy value TOS 
37df			 
37df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37df cd 58 1f			call macro_forth_dsp_pop 
37e2				endm 
# End of macro FORTH_DSP_POP
37e2			 
37e2			 
37e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e2 cd a0 1e			call macro_dsp_valuehl 
37e5				endm 
# End of macro FORTH_DSP_VALUEHL
37e5			 
37e5					; one value on hl get other one back 
37e5			 
37e5 d1					pop de 
37e6			 
37e6					; do the add 
37e6			 
37e6 19					add hl,de 
37e7			 
37e7					; save it 
37e7			 
37e7			;		push hl	 
37e7			 
37e7					; 
37e7			 
37e7					; destroy value TOS 
37e7			 
37e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e7 cd 58 1f			call macro_forth_dsp_pop 
37ea				endm 
# End of macro FORTH_DSP_POP
37ea			 
37ea					; TODO push value back onto stack for another op etc 
37ea			 
37ea			;		pop hl 
37ea			 
37ea			.dot_done: 
37ea cd a9 1c				call forth_push_numhl 
37ed			 
37ed					NEXTW 
37ed c3 12 20			jp macro_next 
37f0				endm 
# End of macro NEXTW
37f0			.NEG: 
37f0			 
37f0				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
37f0 17				db WORD_SYS_CORE+3             
37f1 33 38			dw .DIV            
37f3 02				db 1 + 1 
37f4 .. 00			db "-",0              
37f6				endm 
# End of macro CWHEAD
37f6			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
37f6					if DEBUG_FORTH_WORDS_KEY 
37f6						DMARK "SUB" 
37f6 f5				push af  
37f7 3a 0b 38			ld a, (.dmark)  
37fa 32 77 fb			ld (debug_mark),a  
37fd 3a 0c 38			ld a, (.dmark+1)  
3800 32 78 fb			ld (debug_mark+1),a  
3803 3a 0d 38			ld a, (.dmark+2)  
3806 32 79 fb			ld (debug_mark+2),a  
3809 18 03			jr .pastdmark  
380b ..			.dmark: db "SUB"  
380e f1			.pastdmark: pop af  
380f			endm  
# End of macro DMARK
380f						CALLMONITOR 
380f cd 19 17			call break_point_state  
3812				endm  
# End of macro CALLMONITOR
3812					endif 
3812			 
3812			 
3812				; TODO add floating point number detection 
3812					; v5 FORTH_DSP_VALUE 
3812					FORTH_DSP 
3812 cd 66 1e			call macro_forth_dsp 
3815				endm 
# End of macro FORTH_DSP
3815 7e					ld a,(hl)	; get type of value on TOS 
3816 fe 02				cp DS_TYPE_INUM  
3818 28 03				jr z, .neg_inum 
381a			 
381a					NEXTW 
381a c3 12 20			jp macro_next 
381d				endm 
# End of macro NEXTW
381d			 
381d			; float maths 
381d			 
381d				if FORTH_ENABLE_FLOATMATH 
381d					jr .neg_done 
381d			 
381d				endif 
381d					 
381d			 
381d			.neg_inum: 
381d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381d cd a0 1e			call macro_dsp_valuehl 
3820				endm 
# End of macro FORTH_DSP_VALUEHL
3820			 
3820 e5					push hl 
3821			 
3821					; destroy value TOS 
3821			 
3821					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3821 cd 58 1f			call macro_forth_dsp_pop 
3824				endm 
# End of macro FORTH_DSP_POP
3824			 
3824			 
3824					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3824 cd a0 1e			call macro_dsp_valuehl 
3827				endm 
# End of macro FORTH_DSP_VALUEHL
3827			 
3827					; one value on hl get other one back 
3827			 
3827 d1					pop de 
3828			 
3828					; do the sub 
3828			;		ex de, hl 
3828			 
3828 ed 52				sbc hl,de 
382a			 
382a					; save it 
382a			 
382a			;		push hl	 
382a			 
382a					; 
382a			 
382a					; destroy value TOS 
382a			 
382a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
382a cd 58 1f			call macro_forth_dsp_pop 
382d				endm 
# End of macro FORTH_DSP_POP
382d			 
382d					; TODO push value back onto stack for another op etc 
382d			 
382d			;		pop hl 
382d			 
382d cd a9 1c				call forth_push_numhl 
3830			.neg_done: 
3830			 
3830					NEXTW 
3830 c3 12 20			jp macro_next 
3833				endm 
# End of macro NEXTW
3833			.DIV: 
3833				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3833 18				db WORD_SYS_CORE+4             
3834 80 38			dw .MUL            
3836 02				db 1 + 1 
3837 .. 00			db "/",0              
3839				endm 
# End of macro CWHEAD
3839			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3839					if DEBUG_FORTH_WORDS_KEY 
3839						DMARK "DIV" 
3839 f5				push af  
383a 3a 4e 38			ld a, (.dmark)  
383d 32 77 fb			ld (debug_mark),a  
3840 3a 4f 38			ld a, (.dmark+1)  
3843 32 78 fb			ld (debug_mark+1),a  
3846 3a 50 38			ld a, (.dmark+2)  
3849 32 79 fb			ld (debug_mark+2),a  
384c 18 03			jr .pastdmark  
384e ..			.dmark: db "DIV"  
3851 f1			.pastdmark: pop af  
3852			endm  
# End of macro DMARK
3852						CALLMONITOR 
3852 cd 19 17			call break_point_state  
3855				endm  
# End of macro CALLMONITOR
3855					endif 
3855				; TODO add floating point number detection 
3855					; v5 FORTH_DSP_VALUE 
3855					FORTH_DSP 
3855 cd 66 1e			call macro_forth_dsp 
3858				endm 
# End of macro FORTH_DSP
3858 7e					ld a,(hl)	; get type of value on TOS 
3859 fe 02				cp DS_TYPE_INUM  
385b 28 03				jr z, .div_inum 
385d			 
385d				if FORTH_ENABLE_FLOATMATH 
385d					jr .div_done 
385d			 
385d				endif 
385d					NEXTW 
385d c3 12 20			jp macro_next 
3860				endm 
# End of macro NEXTW
3860			.div_inum: 
3860			 
3860					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3860 cd a0 1e			call macro_dsp_valuehl 
3863				endm 
# End of macro FORTH_DSP_VALUEHL
3863			 
3863 e5					push hl    ; to go to bc 
3864			 
3864					; destroy value TOS 
3864			 
3864					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3864 cd 58 1f			call macro_forth_dsp_pop 
3867				endm 
# End of macro FORTH_DSP_POP
3867			 
3867			 
3867					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3867 cd a0 1e			call macro_dsp_valuehl 
386a				endm 
# End of macro FORTH_DSP_VALUEHL
386a			 
386a					; hl to go to de 
386a			 
386a e5					push hl 
386b			 
386b c1					pop bc 
386c d1					pop de		 
386d			 
386d			 
386d					if DEBUG_FORTH_MATHS 
386d						DMARK "DIV" 
386d				CALLMONITOR 
386d					endif 
386d					; one value on hl but move to a get other one back 
386d			 
386d			        
386d cd 66 0c			call Div16 
3870			 
3870			;	push af	 
3870 e5				push hl 
3871 c5				push bc 
3872			 
3872					if DEBUG_FORTH_MATHS 
3872						DMARK "DI1" 
3872				CALLMONITOR 
3872					endif 
3872			 
3872					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3872 cd 58 1f			call macro_forth_dsp_pop 
3875				endm 
# End of macro FORTH_DSP_POP
3875			 
3875			 
3875			 
3875 e1					pop hl    ; result 
3876			 
3876 cd a9 1c				call forth_push_numhl 
3879			 
3879 e1					pop hl    ; reminder 
387a			;		ld h,0 
387a			;		ld l,d 
387a			 
387a cd a9 1c				call forth_push_numhl 
387d			.div_done: 
387d					NEXTW 
387d c3 12 20			jp macro_next 
3880				endm 
# End of macro NEXTW
3880			.MUL: 
3880				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3880 19				db WORD_SYS_CORE+5             
3881 c5 38			dw .MIN            
3883 02				db 1 + 1 
3884 .. 00			db "*",0              
3886				endm 
# End of macro CWHEAD
3886			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3886				; TODO add floating point number detection 
3886					if DEBUG_FORTH_WORDS_KEY 
3886						DMARK "MUL" 
3886 f5				push af  
3887 3a 9b 38			ld a, (.dmark)  
388a 32 77 fb			ld (debug_mark),a  
388d 3a 9c 38			ld a, (.dmark+1)  
3890 32 78 fb			ld (debug_mark+1),a  
3893 3a 9d 38			ld a, (.dmark+2)  
3896 32 79 fb			ld (debug_mark+2),a  
3899 18 03			jr .pastdmark  
389b ..			.dmark: db "MUL"  
389e f1			.pastdmark: pop af  
389f			endm  
# End of macro DMARK
389f						CALLMONITOR 
389f cd 19 17			call break_point_state  
38a2				endm  
# End of macro CALLMONITOR
38a2					endif 
38a2					FORTH_DSP 
38a2 cd 66 1e			call macro_forth_dsp 
38a5				endm 
# End of macro FORTH_DSP
38a5					; v5 FORTH_DSP_VALUE 
38a5 7e					ld a,(hl)	; get type of value on TOS 
38a6 fe 02				cp DS_TYPE_INUM  
38a8 28 03				jr z, .mul_inum 
38aa			 
38aa				if FORTH_ENABLE_FLOATMATH 
38aa					jr .mul_done 
38aa			 
38aa				endif 
38aa			 
38aa					NEXTW 
38aa c3 12 20			jp macro_next 
38ad				endm 
# End of macro NEXTW
38ad			.mul_inum:	 
38ad			 
38ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ad cd a0 1e			call macro_dsp_valuehl 
38b0				endm 
# End of macro FORTH_DSP_VALUEHL
38b0			 
38b0 e5					push hl 
38b1			 
38b1					; destroy value TOS 
38b1			 
38b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b1 cd 58 1f			call macro_forth_dsp_pop 
38b4				endm 
# End of macro FORTH_DSP_POP
38b4			 
38b4			 
38b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b4 cd a0 1e			call macro_dsp_valuehl 
38b7				endm 
# End of macro FORTH_DSP_VALUEHL
38b7			 
38b7					; one value on hl but move to a get other one back 
38b7			 
38b7 7d					ld a, l 
38b8			 
38b8 d1					pop de 
38b9			 
38b9					; do the mull 
38b9			;		ex de, hl 
38b9			 
38b9 cd 8c 0c				call Mult16 
38bc					; save it 
38bc			 
38bc			;		push hl	 
38bc			 
38bc					; 
38bc			 
38bc					; destroy value TOS 
38bc			 
38bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bc cd 58 1f			call macro_forth_dsp_pop 
38bf				endm 
# End of macro FORTH_DSP_POP
38bf			 
38bf					; TODO push value back onto stack for another op etc 
38bf			 
38bf			;		pop hl 
38bf			 
38bf cd a9 1c				call forth_push_numhl 
38c2			 
38c2			.mul_done: 
38c2					NEXTW 
38c2 c3 12 20			jp macro_next 
38c5				endm 
# End of macro NEXTW
38c5			 
38c5			 
38c5			 
38c5			 
38c5			.MIN: 
38c5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
38c5 49				db WORD_SYS_CORE+53             
38c6 46 39			dw .MAX            
38c8 04				db 3 + 1 
38c9 .. 00			db "MIN",0              
38cd				endm 
# End of macro CWHEAD
38cd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
38cd					if DEBUG_FORTH_WORDS_KEY 
38cd						DMARK "MIN" 
38cd f5				push af  
38ce 3a e2 38			ld a, (.dmark)  
38d1 32 77 fb			ld (debug_mark),a  
38d4 3a e3 38			ld a, (.dmark+1)  
38d7 32 78 fb			ld (debug_mark+1),a  
38da 3a e4 38			ld a, (.dmark+2)  
38dd 32 79 fb			ld (debug_mark+2),a  
38e0 18 03			jr .pastdmark  
38e2 ..			.dmark: db "MIN"  
38e5 f1			.pastdmark: pop af  
38e6			endm  
# End of macro DMARK
38e6						CALLMONITOR 
38e6 cd 19 17			call break_point_state  
38e9				endm  
# End of macro CALLMONITOR
38e9					endif 
38e9					; get u2 
38e9			 
38e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e9 cd a0 1e			call macro_dsp_valuehl 
38ec				endm 
# End of macro FORTH_DSP_VALUEHL
38ec			 
38ec e5					push hl   ; u2 
38ed			 
38ed					; destroy value TOS 
38ed			 
38ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ed cd 58 1f			call macro_forth_dsp_pop 
38f0				endm 
# End of macro FORTH_DSP_POP
38f0			 
38f0					; get u1 
38f0			 
38f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38f0 cd a0 1e			call macro_dsp_valuehl 
38f3				endm 
# End of macro FORTH_DSP_VALUEHL
38f3			 
38f3 e5					push hl  ; u1 
38f4			 
38f4					; destroy value TOS 
38f4			 
38f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f4 cd 58 1f			call macro_forth_dsp_pop 
38f7				endm 
# End of macro FORTH_DSP_POP
38f7			 
38f7 b7			 or a      ;clear carry flag 
38f8 e1			  pop hl    ; u1 
38f9 d1			  pop de    ; u2 
38fa e5				push hl   ; saved in case hl is lowest 
38fb ed 52		  sbc hl,de 
38fd 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
38ff			 
38ff e1				pop hl 
3900					if DEBUG_FORTH_WORDS 
3900						DMARK "MIN" 
3900 f5				push af  
3901 3a 15 39			ld a, (.dmark)  
3904 32 77 fb			ld (debug_mark),a  
3907 3a 16 39			ld a, (.dmark+1)  
390a 32 78 fb			ld (debug_mark+1),a  
390d 3a 17 39			ld a, (.dmark+2)  
3910 32 79 fb			ld (debug_mark+2),a  
3913 18 03			jr .pastdmark  
3915 ..			.dmark: db "MIN"  
3918 f1			.pastdmark: pop af  
3919			endm  
# End of macro DMARK
3919						CALLMONITOR 
3919 cd 19 17			call break_point_state  
391c				endm  
# End of macro CALLMONITOR
391c					endif 
391c cd a9 1c				call forth_push_numhl 
391f			 
391f				       NEXTW 
391f c3 12 20			jp macro_next 
3922				endm 
# End of macro NEXTW
3922			 
3922			.mincont:  
3922 c1				pop bc   ; tidy up 
3923 eb				ex de , hl  
3924					if DEBUG_FORTH_WORDS 
3924						DMARK "MI1" 
3924 f5				push af  
3925 3a 39 39			ld a, (.dmark)  
3928 32 77 fb			ld (debug_mark),a  
392b 3a 3a 39			ld a, (.dmark+1)  
392e 32 78 fb			ld (debug_mark+1),a  
3931 3a 3b 39			ld a, (.dmark+2)  
3934 32 79 fb			ld (debug_mark+2),a  
3937 18 03			jr .pastdmark  
3939 ..			.dmark: db "MI1"  
393c f1			.pastdmark: pop af  
393d			endm  
# End of macro DMARK
393d						CALLMONITOR 
393d cd 19 17			call break_point_state  
3940				endm  
# End of macro CALLMONITOR
3940					endif 
3940 cd a9 1c				call forth_push_numhl 
3943			 
3943				       NEXTW 
3943 c3 12 20			jp macro_next 
3946				endm 
# End of macro NEXTW
3946			.MAX: 
3946				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3946 4a				db WORD_SYS_CORE+54             
3947 c7 39			dw .RND16            
3949 04				db 3 + 1 
394a .. 00			db "MAX",0              
394e				endm 
# End of macro CWHEAD
394e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
394e					if DEBUG_FORTH_WORDS_KEY 
394e						DMARK "MAX" 
394e f5				push af  
394f 3a 63 39			ld a, (.dmark)  
3952 32 77 fb			ld (debug_mark),a  
3955 3a 64 39			ld a, (.dmark+1)  
3958 32 78 fb			ld (debug_mark+1),a  
395b 3a 65 39			ld a, (.dmark+2)  
395e 32 79 fb			ld (debug_mark+2),a  
3961 18 03			jr .pastdmark  
3963 ..			.dmark: db "MAX"  
3966 f1			.pastdmark: pop af  
3967			endm  
# End of macro DMARK
3967						CALLMONITOR 
3967 cd 19 17			call break_point_state  
396a				endm  
# End of macro CALLMONITOR
396a					endif 
396a					; get u2 
396a			 
396a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396a cd a0 1e			call macro_dsp_valuehl 
396d				endm 
# End of macro FORTH_DSP_VALUEHL
396d			 
396d e5					push hl   ; u2 
396e			 
396e					; destroy value TOS 
396e			 
396e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396e cd 58 1f			call macro_forth_dsp_pop 
3971				endm 
# End of macro FORTH_DSP_POP
3971			 
3971					; get u1 
3971			 
3971					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3971 cd a0 1e			call macro_dsp_valuehl 
3974				endm 
# End of macro FORTH_DSP_VALUEHL
3974			 
3974 e5					push hl  ; u1 
3975			 
3975					; destroy value TOS 
3975			 
3975					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3975 cd 58 1f			call macro_forth_dsp_pop 
3978				endm 
# End of macro FORTH_DSP_POP
3978			 
3978 b7			 or a      ;clear carry flag 
3979 e1			  pop hl    ; u1 
397a d1			  pop de    ; u2 
397b e5				push hl   ; saved in case hl is lowest 
397c ed 52		  sbc hl,de 
397e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3980			 
3980 e1				pop hl 
3981					if DEBUG_FORTH_WORDS 
3981						DMARK "MAX" 
3981 f5				push af  
3982 3a 96 39			ld a, (.dmark)  
3985 32 77 fb			ld (debug_mark),a  
3988 3a 97 39			ld a, (.dmark+1)  
398b 32 78 fb			ld (debug_mark+1),a  
398e 3a 98 39			ld a, (.dmark+2)  
3991 32 79 fb			ld (debug_mark+2),a  
3994 18 03			jr .pastdmark  
3996 ..			.dmark: db "MAX"  
3999 f1			.pastdmark: pop af  
399a			endm  
# End of macro DMARK
399a						CALLMONITOR 
399a cd 19 17			call break_point_state  
399d				endm  
# End of macro CALLMONITOR
399d					endif 
399d cd a9 1c				call forth_push_numhl 
39a0			 
39a0				       NEXTW 
39a0 c3 12 20			jp macro_next 
39a3				endm 
# End of macro NEXTW
39a3			 
39a3			.maxcont:  
39a3 c1				pop bc   ; tidy up 
39a4 eb				ex de , hl  
39a5					if DEBUG_FORTH_WORDS 
39a5						DMARK "MA1" 
39a5 f5				push af  
39a6 3a ba 39			ld a, (.dmark)  
39a9 32 77 fb			ld (debug_mark),a  
39ac 3a bb 39			ld a, (.dmark+1)  
39af 32 78 fb			ld (debug_mark+1),a  
39b2 3a bc 39			ld a, (.dmark+2)  
39b5 32 79 fb			ld (debug_mark+2),a  
39b8 18 03			jr .pastdmark  
39ba ..			.dmark: db "MA1"  
39bd f1			.pastdmark: pop af  
39be			endm  
# End of macro DMARK
39be						CALLMONITOR 
39be cd 19 17			call break_point_state  
39c1				endm  
# End of macro CALLMONITOR
39c1					endif 
39c1 cd a9 1c				call forth_push_numhl 
39c4				       NEXTW 
39c4 c3 12 20			jp macro_next 
39c7				endm 
# End of macro NEXTW
39c7			 
39c7			.RND16: 
39c7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
39c7 4e				db WORD_SYS_CORE+58             
39c8 f6 39			dw .RND8            
39ca 06				db 5 + 1 
39cb .. 00			db "RND16",0              
39d1				endm 
# End of macro CWHEAD
39d1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
39d1					if DEBUG_FORTH_WORDS_KEY 
39d1						DMARK "R16" 
39d1 f5				push af  
39d2 3a e6 39			ld a, (.dmark)  
39d5 32 77 fb			ld (debug_mark),a  
39d8 3a e7 39			ld a, (.dmark+1)  
39db 32 78 fb			ld (debug_mark+1),a  
39de 3a e8 39			ld a, (.dmark+2)  
39e1 32 79 fb			ld (debug_mark+2),a  
39e4 18 03			jr .pastdmark  
39e6 ..			.dmark: db "R16"  
39e9 f1			.pastdmark: pop af  
39ea			endm  
# End of macro DMARK
39ea						CALLMONITOR 
39ea cd 19 17			call break_point_state  
39ed				endm  
# End of macro CALLMONITOR
39ed					endif 
39ed cd 30 0c				call prng16  
39f0 cd a9 1c				call forth_push_numhl 
39f3				       NEXTW 
39f3 c3 12 20			jp macro_next 
39f6				endm 
# End of macro NEXTW
39f6			.RND8: 
39f6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
39f6 60				db WORD_SYS_CORE+76             
39f7 2b 3a			dw .RND            
39f9 05				db 4 + 1 
39fa .. 00			db "RND8",0              
39ff				endm 
# End of macro CWHEAD
39ff			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
39ff					if DEBUG_FORTH_WORDS_KEY 
39ff						DMARK "RN8" 
39ff f5				push af  
3a00 3a 14 3a			ld a, (.dmark)  
3a03 32 77 fb			ld (debug_mark),a  
3a06 3a 15 3a			ld a, (.dmark+1)  
3a09 32 78 fb			ld (debug_mark+1),a  
3a0c 3a 16 3a			ld a, (.dmark+2)  
3a0f 32 79 fb			ld (debug_mark+2),a  
3a12 18 03			jr .pastdmark  
3a14 ..			.dmark: db "RN8"  
3a17 f1			.pastdmark: pop af  
3a18			endm  
# End of macro DMARK
3a18						CALLMONITOR 
3a18 cd 19 17			call break_point_state  
3a1b				endm  
# End of macro CALLMONITOR
3a1b					endif 
3a1b 2a b8 f8				ld hl,(xrandc) 
3a1e 23					inc hl 
3a1f cd 4a 0c				call xrnd 
3a22 6f					ld l,a	 
3a23 26 00				ld h,0 
3a25 cd a9 1c				call forth_push_numhl 
3a28				       NEXTW 
3a28 c3 12 20			jp macro_next 
3a2b				endm 
# End of macro NEXTW
3a2b			.RND: 
3a2b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3a2b 60				db WORD_SYS_CORE+76             
3a2c 31 3b			dw .ENDMATHS            
3a2e 04				db 3 + 1 
3a2f .. 00			db "RND",0              
3a33				endm 
# End of macro CWHEAD
3a33			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3a33			 
3a33					if DEBUG_FORTH_WORDS_KEY 
3a33						DMARK "RND" 
3a33 f5				push af  
3a34 3a 48 3a			ld a, (.dmark)  
3a37 32 77 fb			ld (debug_mark),a  
3a3a 3a 49 3a			ld a, (.dmark+1)  
3a3d 32 78 fb			ld (debug_mark+1),a  
3a40 3a 4a 3a			ld a, (.dmark+2)  
3a43 32 79 fb			ld (debug_mark+2),a  
3a46 18 03			jr .pastdmark  
3a48 ..			.dmark: db "RND"  
3a4b f1			.pastdmark: pop af  
3a4c			endm  
# End of macro DMARK
3a4c						CALLMONITOR 
3a4c cd 19 17			call break_point_state  
3a4f				endm  
# End of macro CALLMONITOR
3a4f					endif 
3a4f					 
3a4f					FORTH_DSP_VALUEHL    ; upper range 
3a4f cd a0 1e			call macro_dsp_valuehl 
3a52				endm 
# End of macro FORTH_DSP_VALUEHL
3a52			 
3a52 22 bc f8				ld (LFSRSeed), hl	 
3a55			 
3a55					if DEBUG_FORTH_WORDS 
3a55						DMARK "RN1" 
3a55 f5				push af  
3a56 3a 6a 3a			ld a, (.dmark)  
3a59 32 77 fb			ld (debug_mark),a  
3a5c 3a 6b 3a			ld a, (.dmark+1)  
3a5f 32 78 fb			ld (debug_mark+1),a  
3a62 3a 6c 3a			ld a, (.dmark+2)  
3a65 32 79 fb			ld (debug_mark+2),a  
3a68 18 03			jr .pastdmark  
3a6a ..			.dmark: db "RN1"  
3a6d f1			.pastdmark: pop af  
3a6e			endm  
# End of macro DMARK
3a6e						CALLMONITOR 
3a6e cd 19 17			call break_point_state  
3a71				endm  
# End of macro CALLMONITOR
3a71					endif 
3a71					FORTH_DSP_POP 
3a71 cd 58 1f			call macro_forth_dsp_pop 
3a74				endm 
# End of macro FORTH_DSP_POP
3a74			 
3a74					FORTH_DSP_VALUEHL    ; low range 
3a74 cd a0 1e			call macro_dsp_valuehl 
3a77				endm 
# End of macro FORTH_DSP_VALUEHL
3a77			 
3a77					if DEBUG_FORTH_WORDS 
3a77						DMARK "RN2" 
3a77 f5				push af  
3a78 3a 8c 3a			ld a, (.dmark)  
3a7b 32 77 fb			ld (debug_mark),a  
3a7e 3a 8d 3a			ld a, (.dmark+1)  
3a81 32 78 fb			ld (debug_mark+1),a  
3a84 3a 8e 3a			ld a, (.dmark+2)  
3a87 32 79 fb			ld (debug_mark+2),a  
3a8a 18 03			jr .pastdmark  
3a8c ..			.dmark: db "RN2"  
3a8f f1			.pastdmark: pop af  
3a90			endm  
# End of macro DMARK
3a90						CALLMONITOR 
3a90 cd 19 17			call break_point_state  
3a93				endm  
# End of macro CALLMONITOR
3a93					endif 
3a93 22 be f8				ld (LFSRSeed+2), hl 
3a96			 
3a96					FORTH_DSP_POP 
3a96 cd 58 1f			call macro_forth_dsp_pop 
3a99				endm 
# End of macro FORTH_DSP_POP
3a99			 
3a99 e5					push hl 
3a9a			 
3a9a e1			.inrange:	pop hl 
3a9b cd 30 0c				call prng16  
3a9e					if DEBUG_FORTH_WORDS 
3a9e						DMARK "RN3" 
3a9e f5				push af  
3a9f 3a b3 3a			ld a, (.dmark)  
3aa2 32 77 fb			ld (debug_mark),a  
3aa5 3a b4 3a			ld a, (.dmark+1)  
3aa8 32 78 fb			ld (debug_mark+1),a  
3aab 3a b5 3a			ld a, (.dmark+2)  
3aae 32 79 fb			ld (debug_mark+2),a  
3ab1 18 03			jr .pastdmark  
3ab3 ..			.dmark: db "RN3"  
3ab6 f1			.pastdmark: pop af  
3ab7			endm  
# End of macro DMARK
3ab7						CALLMONITOR 
3ab7 cd 19 17			call break_point_state  
3aba				endm  
# End of macro CALLMONITOR
3aba					endif 
3aba					 
3aba					; if the range is 8bit knock out the high byte 
3aba			 
3aba ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3abe			 
3abe 3e 00				ld a, 0 
3ac0 ba					cp d  
3ac1 20 1e				jr nz, .hirange 
3ac3 26 00				ld h, 0   ; knock it down to 8bit 
3ac5			 
3ac5					if DEBUG_FORTH_WORDS 
3ac5						DMARK "RNk" 
3ac5 f5				push af  
3ac6 3a da 3a			ld a, (.dmark)  
3ac9 32 77 fb			ld (debug_mark),a  
3acc 3a db 3a			ld a, (.dmark+1)  
3acf 32 78 fb			ld (debug_mark+1),a  
3ad2 3a dc 3a			ld a, (.dmark+2)  
3ad5 32 79 fb			ld (debug_mark+2),a  
3ad8 18 03			jr .pastdmark  
3ada ..			.dmark: db "RNk"  
3add f1			.pastdmark: pop af  
3ade			endm  
# End of macro DMARK
3ade						CALLMONITOR 
3ade cd 19 17			call break_point_state  
3ae1				endm  
# End of macro CALLMONITOR
3ae1					endif 
3ae1			.hirange:   
3ae1 e5					push hl  
3ae2 b7					or a  
3ae3 ed 52		                sbc hl, de 
3ae5			 
3ae5					;call cmp16 
3ae5			 
3ae5 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ae7 e1					pop hl 
3ae8 e5					push hl 
3ae9			 
3ae9					if DEBUG_FORTH_WORDS 
3ae9						DMARK "RN4" 
3ae9 f5				push af  
3aea 3a fe 3a			ld a, (.dmark)  
3aed 32 77 fb			ld (debug_mark),a  
3af0 3a ff 3a			ld a, (.dmark+1)  
3af3 32 78 fb			ld (debug_mark+1),a  
3af6 3a 00 3b			ld a, (.dmark+2)  
3af9 32 79 fb			ld (debug_mark+2),a  
3afc 18 03			jr .pastdmark  
3afe ..			.dmark: db "RN4"  
3b01 f1			.pastdmark: pop af  
3b02			endm  
# End of macro DMARK
3b02						CALLMONITOR 
3b02 cd 19 17			call break_point_state  
3b05				endm  
# End of macro CALLMONITOR
3b05					endif 
3b05 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3b09					;call cmp16 
3b09				 
3b09 b7					or a  
3b0a ed 52		                sbc hl, de 
3b0c 38 8c				jr c, .inrange 
3b0e			 
3b0e e1					pop hl 
3b0f					 
3b0f					if DEBUG_FORTH_WORDS 
3b0f						DMARK "RNd" 
3b0f f5				push af  
3b10 3a 24 3b			ld a, (.dmark)  
3b13 32 77 fb			ld (debug_mark),a  
3b16 3a 25 3b			ld a, (.dmark+1)  
3b19 32 78 fb			ld (debug_mark+1),a  
3b1c 3a 26 3b			ld a, (.dmark+2)  
3b1f 32 79 fb			ld (debug_mark+2),a  
3b22 18 03			jr .pastdmark  
3b24 ..			.dmark: db "RNd"  
3b27 f1			.pastdmark: pop af  
3b28			endm  
# End of macro DMARK
3b28						CALLMONITOR 
3b28 cd 19 17			call break_point_state  
3b2b				endm  
# End of macro CALLMONITOR
3b2b					endif 
3b2b			 
3b2b			 
3b2b cd a9 1c				call forth_push_numhl 
3b2e				       NEXTW 
3b2e c3 12 20			jp macro_next 
3b31				endm 
# End of macro NEXTW
3b31			 
3b31			.ENDMATHS: 
3b31			 
3b31			; eof 
3b31			 
# End of file forth_words_maths.asm
3b31			include "forth_words_display.asm" 
3b31			 
3b31			; | ## Display Words 
3b31			 
3b31			.ATP: 
3b31				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b31 62				db WORD_SYS_CORE+78             
3b32 a8 3b			dw .FB            
3b34 04				db 3 + 1 
3b35 .. 00			db "AT?",0              
3b39				endm 
# End of macro CWHEAD
3b39			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b39					if DEBUG_FORTH_WORDS_KEY 
3b39						DMARK "AT?" 
3b39 f5				push af  
3b3a 3a 4e 3b			ld a, (.dmark)  
3b3d 32 77 fb			ld (debug_mark),a  
3b40 3a 4f 3b			ld a, (.dmark+1)  
3b43 32 78 fb			ld (debug_mark+1),a  
3b46 3a 50 3b			ld a, (.dmark+2)  
3b49 32 79 fb			ld (debug_mark+2),a  
3b4c 18 03			jr .pastdmark  
3b4e ..			.dmark: db "AT?"  
3b51 f1			.pastdmark: pop af  
3b52			endm  
# End of macro DMARK
3b52						CALLMONITOR 
3b52 cd 19 17			call break_point_state  
3b55				endm  
# End of macro CALLMONITOR
3b55					endif 
3b55 3a 46 f8				ld a, (f_cursor_ptr) 
3b58			 
3b58			if DEBUG_FORTH_WORDS 
3b58				DMARK "AT?" 
3b58 f5				push af  
3b59 3a 6d 3b			ld a, (.dmark)  
3b5c 32 77 fb			ld (debug_mark),a  
3b5f 3a 6e 3b			ld a, (.dmark+1)  
3b62 32 78 fb			ld (debug_mark+1),a  
3b65 3a 6f 3b			ld a, (.dmark+2)  
3b68 32 79 fb			ld (debug_mark+2),a  
3b6b 18 03			jr .pastdmark  
3b6d ..			.dmark: db "AT?"  
3b70 f1			.pastdmark: pop af  
3b71			endm  
# End of macro DMARK
3b71				CALLMONITOR 
3b71 cd 19 17			call break_point_state  
3b74				endm  
# End of macro CALLMONITOR
3b74			endif	 
3b74					; count the number of rows 
3b74			 
3b74 06 00				ld b, 0 
3b76 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b77 d6 28				sub display_cols 
3b79 f2 7f 3b				jp p, .atprunder 
3b7c 04					inc b 
3b7d 18 f7				jr .atpr 
3b7f			.atprunder:	 
3b7f			if DEBUG_FORTH_WORDS 
3b7f				DMARK "A?2" 
3b7f f5				push af  
3b80 3a 94 3b			ld a, (.dmark)  
3b83 32 77 fb			ld (debug_mark),a  
3b86 3a 95 3b			ld a, (.dmark+1)  
3b89 32 78 fb			ld (debug_mark+1),a  
3b8c 3a 96 3b			ld a, (.dmark+2)  
3b8f 32 79 fb			ld (debug_mark+2),a  
3b92 18 03			jr .pastdmark  
3b94 ..			.dmark: db "A?2"  
3b97 f1			.pastdmark: pop af  
3b98			endm  
# End of macro DMARK
3b98				CALLMONITOR 
3b98 cd 19 17			call break_point_state  
3b9b				endm  
# End of macro CALLMONITOR
3b9b			endif	 
3b9b 26 00				ld h, 0 
3b9d 69					ld l, c 
3b9e cd a9 1c				call forth_push_numhl 
3ba1 68					ld l, b  
3ba2 cd a9 1c				call forth_push_numhl 
3ba5			 
3ba5			 
3ba5				NEXTW 
3ba5 c3 12 20			jp macro_next 
3ba8				endm 
# End of macro NEXTW
3ba8			 
3ba8			.FB: 
3ba8				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ba8 1b				db WORD_SYS_CORE+7             
3ba9 f6 3b			dw .EMIT            
3bab 03				db 2 + 1 
3bac .. 00			db "FB",0              
3baf				endm 
# End of macro CWHEAD
3baf			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3baf			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3baf			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3baf			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3baf					if DEBUG_FORTH_WORDS_KEY 
3baf						DMARK "FB." 
3baf f5				push af  
3bb0 3a c4 3b			ld a, (.dmark)  
3bb3 32 77 fb			ld (debug_mark),a  
3bb6 3a c5 3b			ld a, (.dmark+1)  
3bb9 32 78 fb			ld (debug_mark+1),a  
3bbc 3a c6 3b			ld a, (.dmark+2)  
3bbf 32 79 fb			ld (debug_mark+2),a  
3bc2 18 03			jr .pastdmark  
3bc4 ..			.dmark: db "FB."  
3bc7 f1			.pastdmark: pop af  
3bc8			endm  
# End of macro DMARK
3bc8						CALLMONITOR 
3bc8 cd 19 17			call break_point_state  
3bcb				endm  
# End of macro CALLMONITOR
3bcb					endif 
3bcb			 
3bcb					FORTH_DSP_VALUEHL 
3bcb cd a0 1e			call macro_dsp_valuehl 
3bce				endm 
# End of macro FORTH_DSP_VALUEHL
3bce			 
3bce 7d					ld a, l 
3bcf fe 01				cp 1 
3bd1 20 05				jr nz, .fbn1 
3bd3 21 1c fa				ld hl, display_fb1 
3bd6 18 15				jr .fbset 
3bd8 fe 02		.fbn1:		cp 2 
3bda 20 05				jr nz, .fbn2 
3bdc 21 da f8				ld hl, display_fb2 
3bdf 18 0c				jr .fbset 
3be1 fe 03		.fbn2:		cp 3 
3be3 20 05				jr nz, .fbn3 
3be5 21 7b f9				ld hl, display_fb3 
3be8 18 03				jr .fbset 
3bea			.fbn3:		 ; if invalid number select first 
3bea 21 1c fa				ld hl, display_fb1 
3bed 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3bf0			 
3bf0					FORTH_DSP_POP 
3bf0 cd 58 1f			call macro_forth_dsp_pop 
3bf3				endm 
# End of macro FORTH_DSP_POP
3bf3			 
3bf3					NEXTW 
3bf3 c3 12 20			jp macro_next 
3bf6				endm 
# End of macro NEXTW
3bf6			 
3bf6			 
3bf6			.EMIT: 
3bf6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3bf6 1b				db WORD_SYS_CORE+7             
3bf7 47 3c			dw .DOTH            
3bf9 05				db 4 + 1 
3bfa .. 00			db "EMIT",0              
3bff				endm 
# End of macro CWHEAD
3bff			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3bff					; get value off TOS and display it 
3bff			 
3bff					if DEBUG_FORTH_WORDS_KEY 
3bff						DMARK "EMT" 
3bff f5				push af  
3c00 3a 14 3c			ld a, (.dmark)  
3c03 32 77 fb			ld (debug_mark),a  
3c06 3a 15 3c			ld a, (.dmark+1)  
3c09 32 78 fb			ld (debug_mark+1),a  
3c0c 3a 16 3c			ld a, (.dmark+2)  
3c0f 32 79 fb			ld (debug_mark+2),a  
3c12 18 03			jr .pastdmark  
3c14 ..			.dmark: db "EMT"  
3c17 f1			.pastdmark: pop af  
3c18			endm  
# End of macro DMARK
3c18						CALLMONITOR 
3c18 cd 19 17			call break_point_state  
3c1b				endm  
# End of macro CALLMONITOR
3c1b					endif 
3c1b			 
3c1b					FORTH_DSP_VALUEHL 
3c1b cd a0 1e			call macro_dsp_valuehl 
3c1e				endm 
# End of macro FORTH_DSP_VALUEHL
3c1e			 
3c1e 7d					ld a,l 
3c1f			 
3c1f					; TODO write to display 
3c1f			 
3c1f 32 1b f0				ld (os_input), a 
3c22 3e 00				ld a, 0 
3c24 32 1c f0				ld (os_input+1), a 
3c27					 
3c27 3a 46 f8				ld a, (f_cursor_ptr) 
3c2a 11 1b f0				ld de, os_input 
3c2d cd e8 0a				call str_at_display 
3c30			 
3c30			 
3c30 3a 24 f8				ld a,(cli_autodisplay) 
3c33 fe 00				cp 0 
3c35 28 03				jr z, .enoupdate 
3c37 cd f8 0a						call update_display 
3c3a					.enoupdate: 
3c3a			 
3c3a 3a 46 f8				ld a, (f_cursor_ptr) 
3c3d 3c					inc a 
3c3e 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3c41			 
3c41			 
3c41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c41 cd 58 1f			call macro_forth_dsp_pop 
3c44				endm 
# End of macro FORTH_DSP_POP
3c44			  
3c44			 
3c44					NEXTW 
3c44 c3 12 20			jp macro_next 
3c47				endm 
# End of macro NEXTW
3c47			.DOTH: 
3c47				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c47 1c				db WORD_SYS_CORE+8             
3c48 77 3c			dw .DOTF            
3c4a 03				db 2 + 1 
3c4b .. 00			db ".-",0              
3c4e				endm 
# End of macro CWHEAD
3c4e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c4e					; get value off TOS and display it 
3c4e					if DEBUG_FORTH_WORDS_KEY 
3c4e						DMARK "DTD" 
3c4e f5				push af  
3c4f 3a 63 3c			ld a, (.dmark)  
3c52 32 77 fb			ld (debug_mark),a  
3c55 3a 64 3c			ld a, (.dmark+1)  
3c58 32 78 fb			ld (debug_mark+1),a  
3c5b 3a 65 3c			ld a, (.dmark+2)  
3c5e 32 79 fb			ld (debug_mark+2),a  
3c61 18 03			jr .pastdmark  
3c63 ..			.dmark: db "DTD"  
3c66 f1			.pastdmark: pop af  
3c67			endm  
# End of macro DMARK
3c67						CALLMONITOR 
3c67 cd 19 17			call break_point_state  
3c6a				endm  
# End of macro CALLMONITOR
3c6a					endif 
3c6a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c6c 3e 00			ld a, 0 
3c6e 32 25 f8			ld (cli_mvdot), a 
3c71 c3 ce 3c			jp .dotgo 
3c74				NEXTW 
3c74 c3 12 20			jp macro_next 
3c77				endm 
# End of macro NEXTW
3c77			.DOTF: 
3c77				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c77 1c				db WORD_SYS_CORE+8             
3c78 a5 3c			dw .DOT            
3c7a 03				db 2 + 1 
3c7b .. 00			db ".>",0              
3c7e				endm 
# End of macro CWHEAD
3c7e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c7e					; get value off TOS and display it 
3c7e			        ; TODO BUG adds extra spaces 
3c7e			        ; TODO BUG handle numerics? 
3c7e					if DEBUG_FORTH_WORDS_KEY 
3c7e						DMARK "DTC" 
3c7e f5				push af  
3c7f 3a 93 3c			ld a, (.dmark)  
3c82 32 77 fb			ld (debug_mark),a  
3c85 3a 94 3c			ld a, (.dmark+1)  
3c88 32 78 fb			ld (debug_mark+1),a  
3c8b 3a 95 3c			ld a, (.dmark+2)  
3c8e 32 79 fb			ld (debug_mark+2),a  
3c91 18 03			jr .pastdmark  
3c93 ..			.dmark: db "DTC"  
3c96 f1			.pastdmark: pop af  
3c97			endm  
# End of macro DMARK
3c97						CALLMONITOR 
3c97 cd 19 17			call break_point_state  
3c9a				endm  
# End of macro CALLMONITOR
3c9a					endif 
3c9a 3e 01			ld a, 1 
3c9c 32 25 f8			ld (cli_mvdot), a 
3c9f c3 ce 3c			jp .dotgo 
3ca2				NEXTW 
3ca2 c3 12 20			jp macro_next 
3ca5				endm 
# End of macro NEXTW
3ca5			 
3ca5			.DOT: 
3ca5				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ca5 1c				db WORD_SYS_CORE+8             
3ca6 31 3d			dw .CLS            
3ca8 02				db 1 + 1 
3ca9 .. 00			db ".",0              
3cab				endm 
# End of macro CWHEAD
3cab			        ; | . ( u -- ) Display TOS | DONE 
3cab					; get value off TOS and display it 
3cab			 
3cab					if DEBUG_FORTH_WORDS_KEY 
3cab						DMARK "DOT" 
3cab f5				push af  
3cac 3a c0 3c			ld a, (.dmark)  
3caf 32 77 fb			ld (debug_mark),a  
3cb2 3a c1 3c			ld a, (.dmark+1)  
3cb5 32 78 fb			ld (debug_mark+1),a  
3cb8 3a c2 3c			ld a, (.dmark+2)  
3cbb 32 79 fb			ld (debug_mark+2),a  
3cbe 18 03			jr .pastdmark  
3cc0 ..			.dmark: db "DOT"  
3cc3 f1			.pastdmark: pop af  
3cc4			endm  
# End of macro DMARK
3cc4						CALLMONITOR 
3cc4 cd 19 17			call break_point_state  
3cc7				endm  
# End of macro CALLMONITOR
3cc7					endif 
3cc7 3e 00			ld a, 0 
3cc9 32 25 f8			ld (cli_mvdot), a 
3ccc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3cce				 
3cce			 
3cce			.dotgo: 
3cce			 
3cce			; move up type to on stack for parserv5 
3cce					FORTH_DSP 
3cce cd 66 1e			call macro_forth_dsp 
3cd1				endm 
# End of macro FORTH_DSP
3cd1				;FORTH_DSP_VALUE  
3cd1			 
3cd1			if DEBUG_FORTH_DOT 
3cd1				DMARK "DOT" 
3cd1				CALLMONITOR 
3cd1			endif	 
3cd1			;		.print: 
3cd1			 
3cd1 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3cd2 23				inc hl   ; position to the actual value 
3cd3 fe 01			cp DS_TYPE_STR 
3cd5 20 06			jr nz, .dotnum1  
3cd7			 
3cd7			; display string 
3cd7				FORTH_DSP_VALUE  
3cd7 cd 89 1e			call macro_forth_dsp_value 
3cda				endm 
# End of macro FORTH_DSP_VALUE
3cda eb				ex de,hl 
3cdb 18 11			jr .dotwrite 
3cdd			 
3cdd			.dotnum1: 
3cdd fe 02			cp DS_TYPE_INUM 
3cdf 20 0c			jr nz, .dotflot 
3ce1			 
3ce1			 
3ce1			; display number 
3ce1			 
3ce1			;	push hl 
3ce1			;	call clear_display 
3ce1			;	pop hl 
3ce1			 
3ce1 5e				ld e, (hl) 
3ce2 23				inc hl 
3ce3 56				ld d, (hl) 
3ce4 21 1d ee			ld hl, scratch 
3ce7			if DEBUG_FORTH_DOT 
3ce7				DMARK "DT1" 
3ce7				CALLMONITOR 
3ce7			endif	 
3ce7			 
3ce7 cd 16 11			call uitoa_16 
3cea eb				ex de,hl 
3ceb			 
3ceb			if DEBUG_FORTH_DOT 
3ceb				DMARK "DT2" 
3ceb				CALLMONITOR 
3ceb			endif	 
3ceb			 
3ceb			;	ld de, os_word_scratch 
3ceb 18 01			jr .dotwrite 
3ced			 
3ced 00			.dotflot:   nop 
3cee			; TODO print floating point number 
3cee			 
3cee			.dotwrite:		 
3cee			 
3cee					; if c is set then set all '-' to spaces 
3cee					; need to also take into account .>  
3cee			 
3cee 3e 01				ld a, 1 
3cf0 b9					cp c 
3cf1 20 13				jr nz, .nodashswap 
3cf3			 
3cf3					; DE has the string to write, working with HL 
3cf3			 
3cf3 06 ff				ld b, 255 
3cf5 d5					push de 
3cf6 e1					pop hl 
3cf7			 
3cf7			if DEBUG_FORTH_DOT 
3cf7				DMARK "DT-" 
3cf7				CALLMONITOR 
3cf7			endif	 
3cf7 7e			.dashscan:	ld a, (hl) 
3cf8 fe 00				cp 0 
3cfa 28 0a				jr z, .nodashswap 
3cfc fe 2d				cp '-' 
3cfe 20 03				jr nz, .dashskip 
3d00 3e 20				ld a, ' ' 
3d02 77					ld (hl), a 
3d03 23			.dashskip:	inc hl 
3d04			if DEBUG_FORTH_DOT 
3d04				DMARK "D-2" 
3d04				CALLMONITOR 
3d04			endif	 
3d04 10 f1				djnz .dashscan 
3d06			 
3d06			if DEBUG_FORTH_DOT 
3d06				DMARK "D-1" 
3d06				CALLMONITOR 
3d06			endif	 
3d06			 
3d06			.nodashswap: 
3d06			 
3d06 e5					push hl   ; save string start in case we need to advance print 
3d07			 
3d07 3a 46 f8				ld a, (f_cursor_ptr) 
3d0a cd e8 0a				call str_at_display 
3d0d 3a 24 f8				ld a,(cli_autodisplay) 
3d10 fe 00				cp 0 
3d12 28 03				jr z, .noupdate 
3d14 cd f8 0a						call update_display 
3d17					.noupdate: 
3d17			 
3d17			 
3d17					; see if we need to advance the print position 
3d17			 
3d17 e1					pop hl   ; get back string 
3d18			 
3d18 3a 25 f8				ld a, (cli_mvdot) 
3d1b			if DEBUG_FORTH_DOT 
3d1b					ld e,a 
3d1b				DMARK "D>1" 
3d1b				CALLMONITOR 
3d1b			endif	 
3d1b fe 00				cp 0 
3d1d 28 0c				jr z, .noadv 
3d1f					; yes, lets advance the print position 
3d1f 3e 00				ld a, 0 
3d21 cd 72 11				call strlent 
3d24 3a 46 f8				ld a, (f_cursor_ptr) 
3d27 85					add a,l 
3d28					;call addatohl 
3d28					;ld a, l 
3d28 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3d2b			 
3d2b			if DEBUG_FORTH_DOT 
3d2b				DMARK "D->" 
3d2b				CALLMONITOR 
3d2b			endif	 
3d2b			 
3d2b			.noadv:	 
3d2b			 
3d2b					if DEBUG_FORTH_DOT_WAIT 
3d2b							call next_page_prompt 
3d2b					endif	 
3d2b			; TODO this pop off the stack causes a crash. i dont know why 
3d2b			 
3d2b			 
3d2b			if DEBUG_FORTH_DOT 
3d2b				DMARK "DTh" 
3d2b				CALLMONITOR 
3d2b			endif	 
3d2b			 
3d2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d2b cd 58 1f			call macro_forth_dsp_pop 
3d2e				endm 
# End of macro FORTH_DSP_POP
3d2e			 
3d2e			if DEBUG_FORTH_DOT 
3d2e				DMARK "DTi" 
3d2e				CALLMONITOR 
3d2e			endif	 
3d2e			 
3d2e			 
3d2e					NEXTW 
3d2e c3 12 20			jp macro_next 
3d31				endm 
# End of macro NEXTW
3d31			 
3d31			.CLS: 
3d31				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d31 35				db WORD_SYS_CORE+33             
3d32 5e 3d			dw .DRAW            
3d34 04				db 3 + 1 
3d35 .. 00			db "CLS",0              
3d39				endm 
# End of macro CWHEAD
3d39			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d39					if DEBUG_FORTH_WORDS_KEY 
3d39						DMARK "CLS" 
3d39 f5				push af  
3d3a 3a 4e 3d			ld a, (.dmark)  
3d3d 32 77 fb			ld (debug_mark),a  
3d40 3a 4f 3d			ld a, (.dmark+1)  
3d43 32 78 fb			ld (debug_mark+1),a  
3d46 3a 50 3d			ld a, (.dmark+2)  
3d49 32 79 fb			ld (debug_mark+2),a  
3d4c 18 03			jr .pastdmark  
3d4e ..			.dmark: db "CLS"  
3d51 f1			.pastdmark: pop af  
3d52			endm  
# End of macro DMARK
3d52						CALLMONITOR 
3d52 cd 19 17			call break_point_state  
3d55				endm  
# End of macro CALLMONITOR
3d55					endif 
3d55 cd d5 0a				call clear_display 
3d58 c3 6c 3e				jp .home		; and home cursor 
3d5b					NEXTW 
3d5b c3 12 20			jp macro_next 
3d5e				endm 
# End of macro NEXTW
3d5e			 
3d5e			.DRAW: 
3d5e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d5e 36				db WORD_SYS_CORE+34             
3d5f 89 3d			dw .DUMP            
3d61 05				db 4 + 1 
3d62 .. 00			db "DRAW",0              
3d67				endm 
# End of macro CWHEAD
3d67			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d67					if DEBUG_FORTH_WORDS_KEY 
3d67						DMARK "DRW" 
3d67 f5				push af  
3d68 3a 7c 3d			ld a, (.dmark)  
3d6b 32 77 fb			ld (debug_mark),a  
3d6e 3a 7d 3d			ld a, (.dmark+1)  
3d71 32 78 fb			ld (debug_mark+1),a  
3d74 3a 7e 3d			ld a, (.dmark+2)  
3d77 32 79 fb			ld (debug_mark+2),a  
3d7a 18 03			jr .pastdmark  
3d7c ..			.dmark: db "DRW"  
3d7f f1			.pastdmark: pop af  
3d80			endm  
# End of macro DMARK
3d80						CALLMONITOR 
3d80 cd 19 17			call break_point_state  
3d83				endm  
# End of macro CALLMONITOR
3d83					endif 
3d83 cd f8 0a				call update_display 
3d86					NEXTW 
3d86 c3 12 20			jp macro_next 
3d89				endm 
# End of macro NEXTW
3d89			 
3d89			.DUMP: 
3d89				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d89 37				db WORD_SYS_CORE+35             
3d8a c1 3d			dw .CDUMP            
3d8c 05				db 4 + 1 
3d8d .. 00			db "DUMP",0              
3d92				endm 
# End of macro CWHEAD
3d92			; | DUMP ( x -- ) With address x display dump   | DONE 
3d92			; TODO pop address to use off of the stack 
3d92					if DEBUG_FORTH_WORDS_KEY 
3d92						DMARK "DUM" 
3d92 f5				push af  
3d93 3a a7 3d			ld a, (.dmark)  
3d96 32 77 fb			ld (debug_mark),a  
3d99 3a a8 3d			ld a, (.dmark+1)  
3d9c 32 78 fb			ld (debug_mark+1),a  
3d9f 3a a9 3d			ld a, (.dmark+2)  
3da2 32 79 fb			ld (debug_mark+2),a  
3da5 18 03			jr .pastdmark  
3da7 ..			.dmark: db "DUM"  
3daa f1			.pastdmark: pop af  
3dab			endm  
# End of macro DMARK
3dab						CALLMONITOR 
3dab cd 19 17			call break_point_state  
3dae				endm  
# End of macro CALLMONITOR
3dae					endif 
3dae cd d5 0a				call clear_display 
3db1			 
3db1					; get address 
3db1			 
3db1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3db1 cd a0 1e			call macro_dsp_valuehl 
3db4				endm 
# End of macro FORTH_DSP_VALUEHL
3db4				 
3db4					; save it for cdump 
3db4			 
3db4 22 40 f1				ld (os_cur_ptr),hl 
3db7			 
3db7					; destroy value TOS 
3db7			 
3db7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3db7 cd 58 1f			call macro_forth_dsp_pop 
3dba				endm 
# End of macro FORTH_DSP_POP
3dba			 
3dba cd 29 1b				call dumpcont	; skip old style of param parsing	 
3dbd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3dbe					NEXTW 
3dbe c3 12 20			jp macro_next 
3dc1				endm 
# End of macro NEXTW
3dc1			.CDUMP: 
3dc1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dc1 38				db WORD_SYS_CORE+36             
3dc2 f1 3d			dw .DAT            
3dc4 06				db 5 + 1 
3dc5 .. 00			db "CDUMP",0              
3dcb				endm 
# End of macro CWHEAD
3dcb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3dcb					if DEBUG_FORTH_WORDS_KEY 
3dcb						DMARK "CDP" 
3dcb f5				push af  
3dcc 3a e0 3d			ld a, (.dmark)  
3dcf 32 77 fb			ld (debug_mark),a  
3dd2 3a e1 3d			ld a, (.dmark+1)  
3dd5 32 78 fb			ld (debug_mark+1),a  
3dd8 3a e2 3d			ld a, (.dmark+2)  
3ddb 32 79 fb			ld (debug_mark+2),a  
3dde 18 03			jr .pastdmark  
3de0 ..			.dmark: db "CDP"  
3de3 f1			.pastdmark: pop af  
3de4			endm  
# End of macro DMARK
3de4						CALLMONITOR 
3de4 cd 19 17			call break_point_state  
3de7				endm  
# End of macro CALLMONITOR
3de7					endif 
3de7 cd d5 0a				call clear_display 
3dea cd 29 1b				call dumpcont	 
3ded c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3dee					NEXTW 
3dee c3 12 20			jp macro_next 
3df1				endm 
# End of macro NEXTW
3df1			 
3df1			 
3df1			 
3df1			 
3df1			.DAT: 
3df1				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3df1 3d				db WORD_SYS_CORE+41             
3df2 47 3e			dw .HOME            
3df4 03				db 2 + 1 
3df5 .. 00			db "AT",0              
3df8				endm 
# End of macro CWHEAD
3df8			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3df8					if DEBUG_FORTH_WORDS_KEY 
3df8						DMARK "AT." 
3df8 f5				push af  
3df9 3a 0d 3e			ld a, (.dmark)  
3dfc 32 77 fb			ld (debug_mark),a  
3dff 3a 0e 3e			ld a, (.dmark+1)  
3e02 32 78 fb			ld (debug_mark+1),a  
3e05 3a 0f 3e			ld a, (.dmark+2)  
3e08 32 79 fb			ld (debug_mark+2),a  
3e0b 18 03			jr .pastdmark  
3e0d ..			.dmark: db "AT."  
3e10 f1			.pastdmark: pop af  
3e11			endm  
# End of macro DMARK
3e11						CALLMONITOR 
3e11 cd 19 17			call break_point_state  
3e14				endm  
# End of macro CALLMONITOR
3e14					endif 
3e14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e14 cd a0 1e			call macro_dsp_valuehl 
3e17				endm 
# End of macro FORTH_DSP_VALUEHL
3e17			 
3e17			 
3e17					; TODO save cursor row 
3e17 7d					ld a,l 
3e18 fe 02				cp 2 
3e1a 20 04				jr nz, .crow3 
3e1c 3e 28				ld a, display_row_2 
3e1e 18 12				jr .ccol1 
3e20 fe 03		.crow3:		cp 3 
3e22 20 04				jr nz, .crow4 
3e24 3e 50				ld a, display_row_3 
3e26 18 0a				jr .ccol1 
3e28 fe 04		.crow4:		cp 4 
3e2a 20 04				jr nz, .crow1 
3e2c 3e 78				ld a, display_row_4 
3e2e 18 02				jr .ccol1 
3e30 3e 00		.crow1:		ld a,display_row_1 
3e32 f5			.ccol1:		push af			; got row offset 
3e33 6f					ld l,a 
3e34 26 00				ld h,0 
3e36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e36 cd 58 1f			call macro_forth_dsp_pop 
3e39				endm 
# End of macro FORTH_DSP_POP
3e39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e39 cd a0 1e			call macro_dsp_valuehl 
3e3c				endm 
# End of macro FORTH_DSP_VALUEHL
3e3c					; TODO save cursor col 
3e3c f1					pop af 
3e3d 85					add l		; add col offset 
3e3e 32 46 f8				ld (f_cursor_ptr), a 
3e41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e41 cd 58 1f			call macro_forth_dsp_pop 
3e44				endm 
# End of macro FORTH_DSP_POP
3e44			 
3e44					; calculate  
3e44			 
3e44					NEXTW 
3e44 c3 12 20			jp macro_next 
3e47				endm 
# End of macro NEXTW
3e47			 
3e47			 
3e47			.HOME: 
3e47				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e47 41				db WORD_SYS_CORE+45             
3e48 74 3e			dw .SPACE            
3e4a 05				db 4 + 1 
3e4b .. 00			db "HOME",0              
3e50				endm 
# End of macro CWHEAD
3e50			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e50					if DEBUG_FORTH_WORDS_KEY 
3e50						DMARK "HOM" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 77 fb			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 78 fb			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 79 fb			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "HOM"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd 19 17			call break_point_state  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c 3e 00		.home:		ld a, 0		; and home cursor 
3e6e 32 46 f8				ld (f_cursor_ptr), a 
3e71					NEXTW 
3e71 c3 12 20			jp macro_next 
3e74				endm 
# End of macro NEXTW
3e74			 
3e74			 
3e74			.SPACE: 
3e74				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e74 46				db WORD_SYS_CORE+50             
3e75 a2 3e			dw .SPACES            
3e77 03				db 2 + 1 
3e78 .. 00			db "BL",0              
3e7b				endm 
# End of macro CWHEAD
3e7b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e7b					if DEBUG_FORTH_WORDS_KEY 
3e7b						DMARK "BL." 
3e7b f5				push af  
3e7c 3a 90 3e			ld a, (.dmark)  
3e7f 32 77 fb			ld (debug_mark),a  
3e82 3a 91 3e			ld a, (.dmark+1)  
3e85 32 78 fb			ld (debug_mark+1),a  
3e88 3a 92 3e			ld a, (.dmark+2)  
3e8b 32 79 fb			ld (debug_mark+2),a  
3e8e 18 03			jr .pastdmark  
3e90 ..			.dmark: db "BL."  
3e93 f1			.pastdmark: pop af  
3e94			endm  
# End of macro DMARK
3e94						CALLMONITOR 
3e94 cd 19 17			call break_point_state  
3e97				endm  
# End of macro CALLMONITOR
3e97					endif 
3e97 21 a0 3e				ld hl, .blstr 
3e9a cd 17 1d				call forth_push_str 
3e9d					 
3e9d				       NEXTW 
3e9d c3 12 20			jp macro_next 
3ea0				endm 
# End of macro NEXTW
3ea0			 
3ea0 .. 00		.blstr: db " ", 0 
3ea2			 
3ea2			.SPACES: 
3ea2				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3ea2 47				db WORD_SYS_CORE+51             
3ea3 3d 3f			dw .SCROLL            
3ea5 07				db 6 + 1 
3ea6 .. 00			db "SPACES",0              
3ead				endm 
# End of macro CWHEAD
3ead			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ead					if DEBUG_FORTH_WORDS_KEY 
3ead						DMARK "SPS" 
3ead f5				push af  
3eae 3a c2 3e			ld a, (.dmark)  
3eb1 32 77 fb			ld (debug_mark),a  
3eb4 3a c3 3e			ld a, (.dmark+1)  
3eb7 32 78 fb			ld (debug_mark+1),a  
3eba 3a c4 3e			ld a, (.dmark+2)  
3ebd 32 79 fb			ld (debug_mark+2),a  
3ec0 18 03			jr .pastdmark  
3ec2 ..			.dmark: db "SPS"  
3ec5 f1			.pastdmark: pop af  
3ec6			endm  
# End of macro DMARK
3ec6						CALLMONITOR 
3ec6 cd 19 17			call break_point_state  
3ec9				endm  
# End of macro CALLMONITOR
3ec9					endif 
3ec9			 
3ec9			 
3ec9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec9 cd a0 1e			call macro_dsp_valuehl 
3ecc				endm 
# End of macro FORTH_DSP_VALUEHL
3ecc			 
3ecc			;		push hl    ; u 
3ecc					if DEBUG_FORTH_WORDS 
3ecc						DMARK "SPA" 
3ecc f5				push af  
3ecd 3a e1 3e			ld a, (.dmark)  
3ed0 32 77 fb			ld (debug_mark),a  
3ed3 3a e2 3e			ld a, (.dmark+1)  
3ed6 32 78 fb			ld (debug_mark+1),a  
3ed9 3a e3 3e			ld a, (.dmark+2)  
3edc 32 79 fb			ld (debug_mark+2),a  
3edf 18 03			jr .pastdmark  
3ee1 ..			.dmark: db "SPA"  
3ee4 f1			.pastdmark: pop af  
3ee5			endm  
# End of macro DMARK
3ee5						CALLMONITOR 
3ee5 cd 19 17			call break_point_state  
3ee8				endm  
# End of macro CALLMONITOR
3ee8					endif 
3ee8			 
3ee8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee8 cd 58 1f			call macro_forth_dsp_pop 
3eeb				endm 
# End of macro FORTH_DSP_POP
3eeb			;		pop hl 
3eeb 4d					ld c, l 
3eec 06 00				ld b, 0 
3eee 21 1d ee				ld hl, scratch  
3ef1			 
3ef1					if DEBUG_FORTH_WORDS 
3ef1						DMARK "SP2" 
3ef1 f5				push af  
3ef2 3a 06 3f			ld a, (.dmark)  
3ef5 32 77 fb			ld (debug_mark),a  
3ef8 3a 07 3f			ld a, (.dmark+1)  
3efb 32 78 fb			ld (debug_mark+1),a  
3efe 3a 08 3f			ld a, (.dmark+2)  
3f01 32 79 fb			ld (debug_mark+2),a  
3f04 18 03			jr .pastdmark  
3f06 ..			.dmark: db "SP2"  
3f09 f1			.pastdmark: pop af  
3f0a			endm  
# End of macro DMARK
3f0a						CALLMONITOR 
3f0a cd 19 17			call break_point_state  
3f0d				endm  
# End of macro CALLMONITOR
3f0d					endif 
3f0d 3e 20				ld a, ' ' 
3f0f c5			.spaces1:	push bc 
3f10 77					ld (hl),a 
3f11 23					inc hl 
3f12 c1					pop bc 
3f13 10 fa				djnz .spaces1 
3f15 3e 00				ld a,0 
3f17 77					ld (hl),a 
3f18 21 1d ee				ld hl, scratch 
3f1b					if DEBUG_FORTH_WORDS 
3f1b						DMARK "SP3" 
3f1b f5				push af  
3f1c 3a 30 3f			ld a, (.dmark)  
3f1f 32 77 fb			ld (debug_mark),a  
3f22 3a 31 3f			ld a, (.dmark+1)  
3f25 32 78 fb			ld (debug_mark+1),a  
3f28 3a 32 3f			ld a, (.dmark+2)  
3f2b 32 79 fb			ld (debug_mark+2),a  
3f2e 18 03			jr .pastdmark  
3f30 ..			.dmark: db "SP3"  
3f33 f1			.pastdmark: pop af  
3f34			endm  
# End of macro DMARK
3f34						CALLMONITOR 
3f34 cd 19 17			call break_point_state  
3f37				endm  
# End of macro CALLMONITOR
3f37					endif 
3f37 cd 12 1e				call forth_apush 
3f3a			 
3f3a				       NEXTW 
3f3a c3 12 20			jp macro_next 
3f3d				endm 
# End of macro NEXTW
3f3d			 
3f3d			 
3f3d			 
3f3d			.SCROLL: 
3f3d				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f3d 53				db WORD_SYS_CORE+63             
3f3e 6a 3f			dw .SCROLLD            
3f40 07				db 6 + 1 
3f41 .. 00			db "SCROLL",0              
3f48				endm 
# End of macro CWHEAD
3f48			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f48					if DEBUG_FORTH_WORDS_KEY 
3f48						DMARK "SCR" 
3f48 f5				push af  
3f49 3a 5d 3f			ld a, (.dmark)  
3f4c 32 77 fb			ld (debug_mark),a  
3f4f 3a 5e 3f			ld a, (.dmark+1)  
3f52 32 78 fb			ld (debug_mark+1),a  
3f55 3a 5f 3f			ld a, (.dmark+2)  
3f58 32 79 fb			ld (debug_mark+2),a  
3f5b 18 03			jr .pastdmark  
3f5d ..			.dmark: db "SCR"  
3f60 f1			.pastdmark: pop af  
3f61			endm  
# End of macro DMARK
3f61						CALLMONITOR 
3f61 cd 19 17			call break_point_state  
3f64				endm  
# End of macro CALLMONITOR
3f64					endif 
3f64			 
3f64 cd 97 0a			call scroll_up 
3f67			;	call update_display 
3f67			 
3f67					NEXTW 
3f67 c3 12 20			jp macro_next 
3f6a				endm 
# End of macro NEXTW
3f6a			 
3f6a			 
3f6a			 
3f6a			;		; get dir 
3f6a			; 
3f6a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f6a			; 
3f6a			;		push hl 
3f6a			; 
3f6a			;		; destroy value TOS 
3f6a			; 
3f6a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f6a			; 
3f6a			;		; get count 
3f6a			; 
3f6a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f6a			; 
3f6a			;		push hl 
3f6a			; 
3f6a			;		; destroy value TOS 
3f6a			; 
3f6a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f6a			; 
3f6a			;		; one value on hl get other one back 
3f6a			; 
3f6a			;		pop bc    ; count 
3f6a			; 
3f6a			;		pop de   ; dir 
3f6a			; 
3f6a			; 
3f6a			;		ld b, c 
3f6a			; 
3f6a			;.scrolldir:     push bc 
3f6a			;		push de 
3f6a			; 
3f6a			;		ld a, 0 
3f6a			;		cp e 
3f6a			;		jr z, .scrollup  
3f6a			;		call scroll_down 
3f6a			;		jr .scrollnext 
3f6a			;.scrollup:	call scroll_up 
3f6a			; 
3f6a			;		 
3f6a			;.scrollnext: 
3f6a			;		pop de 
3f6a			;		pop bc 
3f6a			;		djnz .scrolldir 
3f6a			; 
3f6a			; 
3f6a			; 
3f6a			; 
3f6a			; 
3f6a			;		NEXTW 
3f6a			 
3f6a			.SCROLLD: 
3f6a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f6a 53				db WORD_SYS_CORE+63             
3f6b 98 3f			dw .ATQ            
3f6d 08				db 7 + 1 
3f6e .. 00			db "SCROLLD",0              
3f76				endm 
# End of macro CWHEAD
3f76			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f76					if DEBUG_FORTH_WORDS_KEY 
3f76						DMARK "SCD" 
3f76 f5				push af  
3f77 3a 8b 3f			ld a, (.dmark)  
3f7a 32 77 fb			ld (debug_mark),a  
3f7d 3a 8c 3f			ld a, (.dmark+1)  
3f80 32 78 fb			ld (debug_mark+1),a  
3f83 3a 8d 3f			ld a, (.dmark+2)  
3f86 32 79 fb			ld (debug_mark+2),a  
3f89 18 03			jr .pastdmark  
3f8b ..			.dmark: db "SCD"  
3f8e f1			.pastdmark: pop af  
3f8f			endm  
# End of macro DMARK
3f8f						CALLMONITOR 
3f8f cd 19 17			call break_point_state  
3f92				endm  
# End of macro CALLMONITOR
3f92					endif 
3f92			 
3f92 cd bb 0a			call scroll_down 
3f95			;	call update_display 
3f95			 
3f95					NEXTW 
3f95 c3 12 20			jp macro_next 
3f98				endm 
# End of macro NEXTW
3f98			 
3f98			 
3f98			.ATQ: 
3f98				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3f98 62				db WORD_SYS_CORE+78             
3f99 f6 3f			dw .AUTODSP            
3f9b 04				db 3 + 1 
3f9c .. 00			db "AT@",0              
3fa0				endm 
# End of macro CWHEAD
3fa0			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3fa0					if DEBUG_FORTH_WORDS_KEY 
3fa0						DMARK "ATA" 
3fa0 f5				push af  
3fa1 3a b5 3f			ld a, (.dmark)  
3fa4 32 77 fb			ld (debug_mark),a  
3fa7 3a b6 3f			ld a, (.dmark+1)  
3faa 32 78 fb			ld (debug_mark+1),a  
3fad 3a b7 3f			ld a, (.dmark+2)  
3fb0 32 79 fb			ld (debug_mark+2),a  
3fb3 18 03			jr .pastdmark  
3fb5 ..			.dmark: db "ATA"  
3fb8 f1			.pastdmark: pop af  
3fb9			endm  
# End of macro DMARK
3fb9						CALLMONITOR 
3fb9 cd 19 17			call break_point_state  
3fbc				endm  
# End of macro CALLMONITOR
3fbc					endif 
3fbc			 
3fbc			 
3fbc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fbc cd a0 1e			call macro_dsp_valuehl 
3fbf				endm 
# End of macro FORTH_DSP_VALUEHL
3fbf			 
3fbf					; TODO save cursor row 
3fbf 7d					ld a,l 
3fc0 fe 02				cp 2 
3fc2 20 04				jr nz, .crow3aq 
3fc4 3e 28				ld a, display_row_2 
3fc6 18 12				jr .ccol1aq 
3fc8 fe 03		.crow3aq:		cp 3 
3fca 20 04				jr nz, .crow4aq 
3fcc 3e 50				ld a, display_row_3 
3fce 18 0a				jr .ccol1aq 
3fd0 fe 04		.crow4aq:		cp 4 
3fd2 20 04				jr nz, .crow1aq 
3fd4 3e 78				ld a, display_row_4 
3fd6 18 02				jr .ccol1aq 
3fd8 3e 00		.crow1aq:		ld a,display_row_1 
3fda f5			.ccol1aq:		push af			; got row offset 
3fdb 6f					ld l,a 
3fdc 26 00				ld h,0 
3fde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fde cd 58 1f			call macro_forth_dsp_pop 
3fe1				endm 
# End of macro FORTH_DSP_POP
3fe1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe1 cd a0 1e			call macro_dsp_valuehl 
3fe4				endm 
# End of macro FORTH_DSP_VALUEHL
3fe4					; TODO save cursor col 
3fe4 f1					pop af 
3fe5 85					add l		; add col offset 
3fe6			 
3fe6					; add current frame buffer address 
3fe6 2a d8 f8				ld hl, (display_fb_active) 
3fe9 cd 09 0d				call addatohl 
3fec			 
3fec			 
3fec			 
3fec			 
3fec					; get char frame buffer location offset in hl 
3fec			 
3fec 7e					ld a,(hl) 
3fed 26 00				ld h, 0 
3fef 6f					ld l, a 
3ff0			 
3ff0 cd a9 1c				call forth_push_numhl 
3ff3			 
3ff3			 
3ff3					NEXTW 
3ff3 c3 12 20			jp macro_next 
3ff6				endm 
# End of macro NEXTW
3ff6			 
3ff6			.AUTODSP: 
3ff6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ff6 63				db WORD_SYS_CORE+79             
3ff7 0c 40			dw .MENU            
3ff9 05				db 4 + 1 
3ffa .. 00			db "ADSP",0              
3fff				endm 
# End of macro CWHEAD
3fff			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3fff			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3fff			 
3fff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fff cd a0 1e			call macro_dsp_valuehl 
4002				endm 
# End of macro FORTH_DSP_VALUEHL
4002			 
4002			;		push hl 
4002			 
4002					; destroy value TOS 
4002			 
4002					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4002 cd 58 1f			call macro_forth_dsp_pop 
4005				endm 
# End of macro FORTH_DSP_POP
4005			 
4005			;		pop hl 
4005			 
4005 7d					ld a,l 
4006 32 24 f8				ld (cli_autodisplay), a 
4009				       NEXTW 
4009 c3 12 20			jp macro_next 
400c				endm 
# End of macro NEXTW
400c			 
400c			.MENU: 
400c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
400c 70				db WORD_SYS_CORE+92             
400d b5 40			dw .ENDDISPLAY            
400f 05				db 4 + 1 
4010 .. 00			db "MENU",0              
4015				endm 
# End of macro CWHEAD
4015			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4015			 
4015			;		; get number of items on the stack 
4015			; 
4015				 
4015					FORTH_DSP_VALUEHL 
4015 cd a0 1e			call macro_dsp_valuehl 
4018				endm 
# End of macro FORTH_DSP_VALUEHL
4018				 
4018					if DEBUG_FORTH_WORDS_KEY 
4018						DMARK "MNU" 
4018 f5				push af  
4019 3a 2d 40			ld a, (.dmark)  
401c 32 77 fb			ld (debug_mark),a  
401f 3a 2e 40			ld a, (.dmark+1)  
4022 32 78 fb			ld (debug_mark+1),a  
4025 3a 2f 40			ld a, (.dmark+2)  
4028 32 79 fb			ld (debug_mark+2),a  
402b 18 03			jr .pastdmark  
402d ..			.dmark: db "MNU"  
4030 f1			.pastdmark: pop af  
4031			endm  
# End of macro DMARK
4031						CALLMONITOR 
4031 cd 19 17			call break_point_state  
4034				endm  
# End of macro CALLMONITOR
4034					endif 
4034			 
4034 45					ld b, l	 
4035 05					dec b 
4036			 
4036					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4036 cd 58 1f			call macro_forth_dsp_pop 
4039				endm 
# End of macro FORTH_DSP_POP
4039			 
4039			 
4039					; go directly through the stack to pluck out the string pointers and build an array 
4039			 
4039			;		FORTH_DSP 
4039			 
4039					; hl contains top most stack item 
4039				 
4039 11 1d ee				ld de, scratch 
403c			 
403c			.mbuild: 
403c			 
403c					FORTH_DSP_VALUEHL 
403c cd a0 1e			call macro_dsp_valuehl 
403f				endm 
# End of macro FORTH_DSP_VALUEHL
403f			 
403f					if DEBUG_FORTH_WORDS 
403f						DMARK "MN3" 
403f f5				push af  
4040 3a 54 40			ld a, (.dmark)  
4043 32 77 fb			ld (debug_mark),a  
4046 3a 55 40			ld a, (.dmark+1)  
4049 32 78 fb			ld (debug_mark+1),a  
404c 3a 56 40			ld a, (.dmark+2)  
404f 32 79 fb			ld (debug_mark+2),a  
4052 18 03			jr .pastdmark  
4054 ..			.dmark: db "MN3"  
4057 f1			.pastdmark: pop af  
4058			endm  
# End of macro DMARK
4058						CALLMONITOR 
4058 cd 19 17			call break_point_state  
405b				endm  
# End of macro CALLMONITOR
405b					endif 
405b eb					ex de, hl 
405c 73					ld (hl), e 
405d 23					inc hl 
405e 72					ld (hl), d 
405f 23					inc hl 
4060 eb					ex de, hl 
4061			 
4061					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4061 cd 58 1f			call macro_forth_dsp_pop 
4064				endm 
# End of macro FORTH_DSP_POP
4064			 
4064 10 d6				djnz .mbuild 
4066			 
4066					; done add term 
4066			 
4066 eb					ex de, hl 
4067 36 00				ld (hl), 0 
4069 23					inc hl 
406a 36 00				ld (hl), 0 
406c			 
406c				 
406c					 
406c 21 1d ee				ld hl, scratch 
406f			 
406f					if DEBUG_FORTH_WORDS 
406f						DMARK "MNx" 
406f f5				push af  
4070 3a 84 40			ld a, (.dmark)  
4073 32 77 fb			ld (debug_mark),a  
4076 3a 85 40			ld a, (.dmark+1)  
4079 32 78 fb			ld (debug_mark+1),a  
407c 3a 86 40			ld a, (.dmark+2)  
407f 32 79 fb			ld (debug_mark+2),a  
4082 18 03			jr .pastdmark  
4084 ..			.dmark: db "MNx"  
4087 f1			.pastdmark: pop af  
4088			endm  
# End of macro DMARK
4088						CALLMONITOR 
4088 cd 19 17			call break_point_state  
408b				endm  
# End of macro CALLMONITOR
408b					endif 
408b			 
408b			 
408b			 
408b 3e 00				ld a, 0 
408d cd 06 0b				call menu 
4090			 
4090			 
4090 6f					ld l, a 
4091 26 00				ld h, 0 
4093			 
4093					if DEBUG_FORTH_WORDS 
4093						DMARK "MNr" 
4093 f5				push af  
4094 3a a8 40			ld a, (.dmark)  
4097 32 77 fb			ld (debug_mark),a  
409a 3a a9 40			ld a, (.dmark+1)  
409d 32 78 fb			ld (debug_mark+1),a  
40a0 3a aa 40			ld a, (.dmark+2)  
40a3 32 79 fb			ld (debug_mark+2),a  
40a6 18 03			jr .pastdmark  
40a8 ..			.dmark: db "MNr"  
40ab f1			.pastdmark: pop af  
40ac			endm  
# End of macro DMARK
40ac						CALLMONITOR 
40ac cd 19 17			call break_point_state  
40af				endm  
# End of macro CALLMONITOR
40af					endif 
40af			 
40af cd a9 1c				call forth_push_numhl 
40b2			 
40b2			 
40b2			 
40b2			 
40b2				       NEXTW 
40b2 c3 12 20			jp macro_next 
40b5				endm 
# End of macro NEXTW
40b5			 
40b5			 
40b5			.ENDDISPLAY: 
40b5			 
40b5			; eof 
# End of file forth_words_display.asm
40b5			include "forth_words_str.asm" 
40b5			 
40b5			; | ## String Words 
40b5			 
40b5			.PTR:   
40b5			 
40b5				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
40b5 48				db WORD_SYS_CORE+52             
40b6 e2 40			dw .STYPE            
40b8 04				db 3 + 1 
40b9 .. 00			db "PTR",0              
40bd				endm 
# End of macro CWHEAD
40bd			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40bd			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40bd			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40bd			 
40bd					if DEBUG_FORTH_WORDS_KEY 
40bd						DMARK "PTR" 
40bd f5				push af  
40be 3a d2 40			ld a, (.dmark)  
40c1 32 77 fb			ld (debug_mark),a  
40c4 3a d3 40			ld a, (.dmark+1)  
40c7 32 78 fb			ld (debug_mark+1),a  
40ca 3a d4 40			ld a, (.dmark+2)  
40cd 32 79 fb			ld (debug_mark+2),a  
40d0 18 03			jr .pastdmark  
40d2 ..			.dmark: db "PTR"  
40d5 f1			.pastdmark: pop af  
40d6			endm  
# End of macro DMARK
40d6						CALLMONITOR 
40d6 cd 19 17			call break_point_state  
40d9				endm  
# End of macro CALLMONITOR
40d9					endif 
40d9					FORTH_DSP_VALUEHL 
40d9 cd a0 1e			call macro_dsp_valuehl 
40dc				endm 
# End of macro FORTH_DSP_VALUEHL
40dc cd a9 1c				call forth_push_numhl 
40df			 
40df			 
40df					NEXTW 
40df c3 12 20			jp macro_next 
40e2				endm 
# End of macro NEXTW
40e2			.STYPE: 
40e2				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40e2 48				db WORD_SYS_CORE+52             
40e3 31 41			dw .UPPER            
40e5 06				db 5 + 1 
40e6 .. 00			db "STYPE",0              
40ec				endm 
# End of macro CWHEAD
40ec			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40ec					if DEBUG_FORTH_WORDS_KEY 
40ec						DMARK "STY" 
40ec f5				push af  
40ed 3a 01 41			ld a, (.dmark)  
40f0 32 77 fb			ld (debug_mark),a  
40f3 3a 02 41			ld a, (.dmark+1)  
40f6 32 78 fb			ld (debug_mark+1),a  
40f9 3a 03 41			ld a, (.dmark+2)  
40fc 32 79 fb			ld (debug_mark+2),a  
40ff 18 03			jr .pastdmark  
4101 ..			.dmark: db "STY"  
4104 f1			.pastdmark: pop af  
4105			endm  
# End of macro DMARK
4105						CALLMONITOR 
4105 cd 19 17			call break_point_state  
4108				endm  
# End of macro CALLMONITOR
4108					endif 
4108					FORTH_DSP 
4108 cd 66 1e			call macro_forth_dsp 
410b				endm 
# End of macro FORTH_DSP
410b					;v5 FORTH_DSP_VALUE 
410b			 
410b 7e					ld a, (hl) 
410c			 
410c f5					push af 
410d			 
410d			; Dont destroy TOS		FORTH_DSP_POP 
410d			 
410d f1					pop af 
410e			 
410e fe 01				cp DS_TYPE_STR 
4110 28 09				jr z, .typestr 
4112			 
4112 fe 02				cp DS_TYPE_INUM 
4114 28 0a				jr z, .typeinum 
4116			 
4116 21 2f 41				ld hl, .tna 
4119 18 0a				jr .tpush 
411b			 
411b 21 2b 41		.typestr:	ld hl, .tstr 
411e 18 05				jr .tpush 
4120 21 2d 41		.typeinum:	ld hl, .tinum 
4123 18 00				jr .tpush 
4125			 
4125			.tpush: 
4125			 
4125 cd 17 1d				call forth_push_str 
4128			 
4128					NEXTW 
4128 c3 12 20			jp macro_next 
412b				endm 
# End of macro NEXTW
412b .. 00		.tstr:	db "s",0 
412d .. 00		.tinum:  db "i",0 
412f .. 00		.tna:   db "?", 0 
4131			 
4131			 
4131			.UPPER: 
4131				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4131 48				db WORD_SYS_CORE+52             
4132 6c 41			dw .LOWER            
4134 06				db 5 + 1 
4135 .. 00			db "UPPER",0              
413b				endm 
# End of macro CWHEAD
413b			; | UPPER ( s -- s ) Upper case string s  | DONE 
413b					if DEBUG_FORTH_WORDS_KEY 
413b						DMARK "UPR" 
413b f5				push af  
413c 3a 50 41			ld a, (.dmark)  
413f 32 77 fb			ld (debug_mark),a  
4142 3a 51 41			ld a, (.dmark+1)  
4145 32 78 fb			ld (debug_mark+1),a  
4148 3a 52 41			ld a, (.dmark+2)  
414b 32 79 fb			ld (debug_mark+2),a  
414e 18 03			jr .pastdmark  
4150 ..			.dmark: db "UPR"  
4153 f1			.pastdmark: pop af  
4154			endm  
# End of macro DMARK
4154						CALLMONITOR 
4154 cd 19 17			call break_point_state  
4157				endm  
# End of macro CALLMONITOR
4157					endif 
4157			 
4157					FORTH_DSP 
4157 cd 66 1e			call macro_forth_dsp 
415a				endm 
# End of macro FORTH_DSP
415a					 
415a			; TODO check is string type 
415a			 
415a					FORTH_DSP_VALUEHL 
415a cd a0 1e			call macro_dsp_valuehl 
415d				endm 
# End of macro FORTH_DSP_VALUEHL
415d			; get pointer to string in hl 
415d			 
415d 7e			.toup:		ld a, (hl) 
415e fe 00				cp 0 
4160 28 07				jr z, .toupdone 
4162			 
4162 cd 76 10				call to_upper 
4165			 
4165 77					ld (hl), a 
4166 23					inc hl 
4167 18 f4				jr .toup 
4169			 
4169					 
4169			 
4169			 
4169			; for each char convert to upper 
4169					 
4169			.toupdone: 
4169			 
4169			 
4169					NEXTW 
4169 c3 12 20			jp macro_next 
416c				endm 
# End of macro NEXTW
416c			.LOWER: 
416c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
416c 48				db WORD_SYS_CORE+52             
416d a7 41			dw .TCASE            
416f 06				db 5 + 1 
4170 .. 00			db "LOWER",0              
4176				endm 
# End of macro CWHEAD
4176			; | LOWER ( s -- s ) Lower case string s  | DONE 
4176					if DEBUG_FORTH_WORDS_KEY 
4176						DMARK "LWR" 
4176 f5				push af  
4177 3a 8b 41			ld a, (.dmark)  
417a 32 77 fb			ld (debug_mark),a  
417d 3a 8c 41			ld a, (.dmark+1)  
4180 32 78 fb			ld (debug_mark+1),a  
4183 3a 8d 41			ld a, (.dmark+2)  
4186 32 79 fb			ld (debug_mark+2),a  
4189 18 03			jr .pastdmark  
418b ..			.dmark: db "LWR"  
418e f1			.pastdmark: pop af  
418f			endm  
# End of macro DMARK
418f						CALLMONITOR 
418f cd 19 17			call break_point_state  
4192				endm  
# End of macro CALLMONITOR
4192					endif 
4192			 
4192					FORTH_DSP 
4192 cd 66 1e			call macro_forth_dsp 
4195				endm 
# End of macro FORTH_DSP
4195					 
4195			; TODO check is string type 
4195			 
4195					FORTH_DSP_VALUEHL 
4195 cd a0 1e			call macro_dsp_valuehl 
4198				endm 
# End of macro FORTH_DSP_VALUEHL
4198			; get pointer to string in hl 
4198			 
4198 7e			.tolow:		ld a, (hl) 
4199 fe 00				cp 0 
419b 28 07				jr z, .tolowdone 
419d			 
419d cd 7f 10				call to_lower 
41a0			 
41a0 77					ld (hl), a 
41a1 23					inc hl 
41a2 18 f4				jr .tolow 
41a4			 
41a4					 
41a4			 
41a4			 
41a4			; for each char convert to low 
41a4					 
41a4			.tolowdone: 
41a4					NEXTW 
41a4 c3 12 20			jp macro_next 
41a7				endm 
# End of macro NEXTW
41a7			.TCASE: 
41a7				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
41a7 48				db WORD_SYS_CORE+52             
41a8 dd 42			dw .SUBSTR            
41aa 06				db 5 + 1 
41ab .. 00			db "TCASE",0              
41b1				endm 
# End of macro CWHEAD
41b1			; | TCASE ( s -- s ) Title case string s  | DONE 
41b1					if DEBUG_FORTH_WORDS_KEY 
41b1						DMARK "TCS" 
41b1 f5				push af  
41b2 3a c6 41			ld a, (.dmark)  
41b5 32 77 fb			ld (debug_mark),a  
41b8 3a c7 41			ld a, (.dmark+1)  
41bb 32 78 fb			ld (debug_mark+1),a  
41be 3a c8 41			ld a, (.dmark+2)  
41c1 32 79 fb			ld (debug_mark+2),a  
41c4 18 03			jr .pastdmark  
41c6 ..			.dmark: db "TCS"  
41c9 f1			.pastdmark: pop af  
41ca			endm  
# End of macro DMARK
41ca						CALLMONITOR 
41ca cd 19 17			call break_point_state  
41cd				endm  
# End of macro CALLMONITOR
41cd					endif 
41cd			 
41cd					FORTH_DSP 
41cd cd 66 1e			call macro_forth_dsp 
41d0				endm 
# End of macro FORTH_DSP
41d0					 
41d0			; TODO check is string type 
41d0			 
41d0					FORTH_DSP_VALUEHL 
41d0 cd a0 1e			call macro_dsp_valuehl 
41d3				endm 
# End of macro FORTH_DSP_VALUEHL
41d3			; get pointer to string in hl 
41d3			 
41d3					if DEBUG_FORTH_WORDS 
41d3						DMARK "TC1" 
41d3 f5				push af  
41d4 3a e8 41			ld a, (.dmark)  
41d7 32 77 fb			ld (debug_mark),a  
41da 3a e9 41			ld a, (.dmark+1)  
41dd 32 78 fb			ld (debug_mark+1),a  
41e0 3a ea 41			ld a, (.dmark+2)  
41e3 32 79 fb			ld (debug_mark+2),a  
41e6 18 03			jr .pastdmark  
41e8 ..			.dmark: db "TC1"  
41eb f1			.pastdmark: pop af  
41ec			endm  
# End of macro DMARK
41ec						CALLMONITOR 
41ec cd 19 17			call break_point_state  
41ef				endm  
# End of macro CALLMONITOR
41ef					endif 
41ef			 
41ef					; first time in turn to upper case first char 
41ef			 
41ef 7e					ld a, (hl) 
41f0 c3 7a 42				jp .totsiptou 
41f3			 
41f3			 
41f3 7e			.tot:		ld a, (hl) 
41f4 fe 00				cp 0 
41f6 ca be 42				jp z, .totdone 
41f9			 
41f9					if DEBUG_FORTH_WORDS 
41f9						DMARK "TC2" 
41f9 f5				push af  
41fa 3a 0e 42			ld a, (.dmark)  
41fd 32 77 fb			ld (debug_mark),a  
4200 3a 0f 42			ld a, (.dmark+1)  
4203 32 78 fb			ld (debug_mark+1),a  
4206 3a 10 42			ld a, (.dmark+2)  
4209 32 79 fb			ld (debug_mark+2),a  
420c 18 03			jr .pastdmark  
420e ..			.dmark: db "TC2"  
4211 f1			.pastdmark: pop af  
4212			endm  
# End of macro DMARK
4212						CALLMONITOR 
4212 cd 19 17			call break_point_state  
4215				endm  
# End of macro CALLMONITOR
4215					endif 
4215					; check to see if current char is a space 
4215			 
4215 fe 20				cp ' ' 
4217 28 21				jr z, .totsp 
4219 cd 7f 10				call to_lower 
421c					if DEBUG_FORTH_WORDS 
421c						DMARK "TC3" 
421c f5				push af  
421d 3a 31 42			ld a, (.dmark)  
4220 32 77 fb			ld (debug_mark),a  
4223 3a 32 42			ld a, (.dmark+1)  
4226 32 78 fb			ld (debug_mark+1),a  
4229 3a 33 42			ld a, (.dmark+2)  
422c 32 79 fb			ld (debug_mark+2),a  
422f 18 03			jr .pastdmark  
4231 ..			.dmark: db "TC3"  
4234 f1			.pastdmark: pop af  
4235			endm  
# End of macro DMARK
4235						CALLMONITOR 
4235 cd 19 17			call break_point_state  
4238				endm  
# End of macro CALLMONITOR
4238					endif 
4238 18 63				jr .totnxt 
423a			 
423a			.totsp:         ; on a space, find next char which should be upper 
423a			 
423a					if DEBUG_FORTH_WORDS 
423a						DMARK "TC4" 
423a f5				push af  
423b 3a 4f 42			ld a, (.dmark)  
423e 32 77 fb			ld (debug_mark),a  
4241 3a 50 42			ld a, (.dmark+1)  
4244 32 78 fb			ld (debug_mark+1),a  
4247 3a 51 42			ld a, (.dmark+2)  
424a 32 79 fb			ld (debug_mark+2),a  
424d 18 03			jr .pastdmark  
424f ..			.dmark: db "TC4"  
4252 f1			.pastdmark: pop af  
4253			endm  
# End of macro DMARK
4253						CALLMONITOR 
4253 cd 19 17			call break_point_state  
4256				endm  
# End of macro CALLMONITOR
4256					endif 
4256					;; 
4256			 
4256 fe 20				cp ' ' 
4258 20 20				jr nz, .totsiptou 
425a 23					inc hl 
425b 7e					ld a, (hl) 
425c					if DEBUG_FORTH_WORDS 
425c						DMARK "TC5" 
425c f5				push af  
425d 3a 71 42			ld a, (.dmark)  
4260 32 77 fb			ld (debug_mark),a  
4263 3a 72 42			ld a, (.dmark+1)  
4266 32 78 fb			ld (debug_mark+1),a  
4269 3a 73 42			ld a, (.dmark+2)  
426c 32 79 fb			ld (debug_mark+2),a  
426f 18 03			jr .pastdmark  
4271 ..			.dmark: db "TC5"  
4274 f1			.pastdmark: pop af  
4275			endm  
# End of macro DMARK
4275						CALLMONITOR 
4275 cd 19 17			call break_point_state  
4278				endm  
# End of macro CALLMONITOR
4278					endif 
4278 18 c0				jr .totsp 
427a fe 00		.totsiptou:    cp 0 
427c 28 40				jr z, .totdone 
427e					; not space and not zero term so upper case it 
427e cd 76 10				call to_upper 
4281			 
4281					if DEBUG_FORTH_WORDS 
4281						DMARK "TC6" 
4281 f5				push af  
4282 3a 96 42			ld a, (.dmark)  
4285 32 77 fb			ld (debug_mark),a  
4288 3a 97 42			ld a, (.dmark+1)  
428b 32 78 fb			ld (debug_mark+1),a  
428e 3a 98 42			ld a, (.dmark+2)  
4291 32 79 fb			ld (debug_mark+2),a  
4294 18 03			jr .pastdmark  
4296 ..			.dmark: db "TC6"  
4299 f1			.pastdmark: pop af  
429a			endm  
# End of macro DMARK
429a						CALLMONITOR 
429a cd 19 17			call break_point_state  
429d				endm  
# End of macro CALLMONITOR
429d					endif 
429d			 
429d			 
429d			.totnxt: 
429d			 
429d 77					ld (hl), a 
429e 23					inc hl 
429f					if DEBUG_FORTH_WORDS 
429f						DMARK "TC7" 
429f f5				push af  
42a0 3a b4 42			ld a, (.dmark)  
42a3 32 77 fb			ld (debug_mark),a  
42a6 3a b5 42			ld a, (.dmark+1)  
42a9 32 78 fb			ld (debug_mark+1),a  
42ac 3a b6 42			ld a, (.dmark+2)  
42af 32 79 fb			ld (debug_mark+2),a  
42b2 18 03			jr .pastdmark  
42b4 ..			.dmark: db "TC7"  
42b7 f1			.pastdmark: pop af  
42b8			endm  
# End of macro DMARK
42b8						CALLMONITOR 
42b8 cd 19 17			call break_point_state  
42bb				endm  
# End of macro CALLMONITOR
42bb					endif 
42bb c3 f3 41				jp .tot 
42be			 
42be					 
42be			 
42be			 
42be			; for each char convert to low 
42be					 
42be			.totdone: 
42be					if DEBUG_FORTH_WORDS 
42be						DMARK "TCd" 
42be f5				push af  
42bf 3a d3 42			ld a, (.dmark)  
42c2 32 77 fb			ld (debug_mark),a  
42c5 3a d4 42			ld a, (.dmark+1)  
42c8 32 78 fb			ld (debug_mark+1),a  
42cb 3a d5 42			ld a, (.dmark+2)  
42ce 32 79 fb			ld (debug_mark+2),a  
42d1 18 03			jr .pastdmark  
42d3 ..			.dmark: db "TCd"  
42d6 f1			.pastdmark: pop af  
42d7			endm  
# End of macro DMARK
42d7						CALLMONITOR 
42d7 cd 19 17			call break_point_state  
42da				endm  
# End of macro CALLMONITOR
42da					endif 
42da					NEXTW 
42da c3 12 20			jp macro_next 
42dd				endm 
# End of macro NEXTW
42dd			 
42dd			.SUBSTR: 
42dd				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42dd 48				db WORD_SYS_CORE+52             
42de 3b 43			dw .LEFT            
42e0 07				db 6 + 1 
42e1 .. 00			db "SUBSTR",0              
42e8				endm 
# End of macro CWHEAD
42e8			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42e8			 
42e8					if DEBUG_FORTH_WORDS_KEY 
42e8						DMARK "SST" 
42e8 f5				push af  
42e9 3a fd 42			ld a, (.dmark)  
42ec 32 77 fb			ld (debug_mark),a  
42ef 3a fe 42			ld a, (.dmark+1)  
42f2 32 78 fb			ld (debug_mark+1),a  
42f5 3a ff 42			ld a, (.dmark+2)  
42f8 32 79 fb			ld (debug_mark+2),a  
42fb 18 03			jr .pastdmark  
42fd ..			.dmark: db "SST"  
4300 f1			.pastdmark: pop af  
4301			endm  
# End of macro DMARK
4301						CALLMONITOR 
4301 cd 19 17			call break_point_state  
4304				endm  
# End of macro CALLMONITOR
4304					endif 
4304			; TODO check string type 
4304					FORTH_DSP_VALUEHL 
4304 cd a0 1e			call macro_dsp_valuehl 
4307				endm 
# End of macro FORTH_DSP_VALUEHL
4307			 
4307 e5					push hl      ; string length 
4308			 
4308					FORTH_DSP_POP 
4308 cd 58 1f			call macro_forth_dsp_pop 
430b				endm 
# End of macro FORTH_DSP_POP
430b			 
430b					FORTH_DSP_VALUEHL 
430b cd a0 1e			call macro_dsp_valuehl 
430e				endm 
# End of macro FORTH_DSP_VALUEHL
430e			 
430e e5					push hl     ; start char 
430f			 
430f					FORTH_DSP_POP 
430f cd 58 1f			call macro_forth_dsp_pop 
4312				endm 
# End of macro FORTH_DSP_POP
4312			 
4312			 
4312					FORTH_DSP_VALUE 
4312 cd 89 1e			call macro_forth_dsp_value 
4315				endm 
# End of macro FORTH_DSP_VALUE
4315			 
4315 d1					pop de    ; get start post offset 
4316			 
4316 19					add hl, de    ; starting offset 
4317			 
4317 c1					pop bc 
4318 c5					push bc      ; grab size of string 
4319			 
4319 e5					push hl    ; save string start  
431a			 
431a 26 00				ld h, 0 
431c 69					ld l, c 
431d 23					inc hl 
431e 23					inc hl 
431f			 
431f cd d0 11				call malloc 
4322				if DEBUG_FORTH_MALLOC_GUARD 
4322 cc cd 52				call z,malloc_error 
4325				endif 
4325			 
4325 eb					ex de, hl      ; save malloc area for string copy 
4326 e1					pop hl    ; get back source 
4327 c1					pop bc    ; get length of string back 
4328			 
4328 d5					push de    ; save malloc area for after we push 
4329 ed b0				ldir     ; copy substr 
432b			 
432b			 
432b eb					ex de, hl 
432c 3e 00				ld a, 0 
432e 77					ld (hl), a   ; term substr 
432f			 
432f					 
432f e1					pop hl    ; get malloc so we can push it 
4330 e5					push hl   ; save so we can free it afterwards 
4331			 
4331 cd 17 1d				call forth_push_str 
4334			 
4334 e1					pop hl 
4335 cd 9a 12				call free 
4338			 
4338					 
4338					 
4338			 
4338			 
4338					NEXTW 
4338 c3 12 20			jp macro_next 
433b				endm 
# End of macro NEXTW
433b			 
433b			.LEFT: 
433b				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
433b 48				db WORD_SYS_CORE+52             
433c 63 43			dw .RIGHT            
433e 05				db 4 + 1 
433f .. 00			db "LEFT",0              
4344				endm 
# End of macro CWHEAD
4344			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4344					if DEBUG_FORTH_WORDS_KEY 
4344						DMARK "LEF" 
4344 f5				push af  
4345 3a 59 43			ld a, (.dmark)  
4348 32 77 fb			ld (debug_mark),a  
434b 3a 5a 43			ld a, (.dmark+1)  
434e 32 78 fb			ld (debug_mark+1),a  
4351 3a 5b 43			ld a, (.dmark+2)  
4354 32 79 fb			ld (debug_mark+2),a  
4357 18 03			jr .pastdmark  
4359 ..			.dmark: db "LEF"  
435c f1			.pastdmark: pop af  
435d			endm  
# End of macro DMARK
435d						CALLMONITOR 
435d cd 19 17			call break_point_state  
4360				endm  
# End of macro CALLMONITOR
4360					endif 
4360			 
4360					NEXTW 
4360 c3 12 20			jp macro_next 
4363				endm 
# End of macro NEXTW
4363			.RIGHT: 
4363				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4363 48				db WORD_SYS_CORE+52             
4364 8c 43			dw .STR2NUM            
4366 06				db 5 + 1 
4367 .. 00			db "RIGHT",0              
436d				endm 
# End of macro CWHEAD
436d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
436d					if DEBUG_FORTH_WORDS_KEY 
436d						DMARK "RIG" 
436d f5				push af  
436e 3a 82 43			ld a, (.dmark)  
4371 32 77 fb			ld (debug_mark),a  
4374 3a 83 43			ld a, (.dmark+1)  
4377 32 78 fb			ld (debug_mark+1),a  
437a 3a 84 43			ld a, (.dmark+2)  
437d 32 79 fb			ld (debug_mark+2),a  
4380 18 03			jr .pastdmark  
4382 ..			.dmark: db "RIG"  
4385 f1			.pastdmark: pop af  
4386			endm  
# End of macro DMARK
4386						CALLMONITOR 
4386 cd 19 17			call break_point_state  
4389				endm  
# End of macro CALLMONITOR
4389					endif 
4389			 
4389					NEXTW 
4389 c3 12 20			jp macro_next 
438c				endm 
# End of macro NEXTW
438c			 
438c			 
438c			.STR2NUM: 
438c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
438c 48				db WORD_SYS_CORE+52             
438d 18 44			dw .NUM2STR            
438f 08				db 7 + 1 
4390 .. 00			db "STR2NUM",0              
4398				endm 
# End of macro CWHEAD
4398			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4398			 
4398			 
4398			; TODO STR type check to do 
4398					if DEBUG_FORTH_WORDS_KEY 
4398						DMARK "S2N" 
4398 f5				push af  
4399 3a ad 43			ld a, (.dmark)  
439c 32 77 fb			ld (debug_mark),a  
439f 3a ae 43			ld a, (.dmark+1)  
43a2 32 78 fb			ld (debug_mark+1),a  
43a5 3a af 43			ld a, (.dmark+2)  
43a8 32 79 fb			ld (debug_mark+2),a  
43ab 18 03			jr .pastdmark  
43ad ..			.dmark: db "S2N"  
43b0 f1			.pastdmark: pop af  
43b1			endm  
# End of macro DMARK
43b1						CALLMONITOR 
43b1 cd 19 17			call break_point_state  
43b4				endm  
# End of macro CALLMONITOR
43b4					endif 
43b4			 
43b4					;FORTH_DSP 
43b4					FORTH_DSP_VALUE 
43b4 cd 89 1e			call macro_forth_dsp_value 
43b7				endm 
# End of macro FORTH_DSP_VALUE
43b7					;inc hl 
43b7			 
43b7 eb					ex de, hl 
43b8					if DEBUG_FORTH_WORDS 
43b8						DMARK "S2a" 
43b8 f5				push af  
43b9 3a cd 43			ld a, (.dmark)  
43bc 32 77 fb			ld (debug_mark),a  
43bf 3a ce 43			ld a, (.dmark+1)  
43c2 32 78 fb			ld (debug_mark+1),a  
43c5 3a cf 43			ld a, (.dmark+2)  
43c8 32 79 fb			ld (debug_mark+2),a  
43cb 18 03			jr .pastdmark  
43cd ..			.dmark: db "S2a"  
43d0 f1			.pastdmark: pop af  
43d1			endm  
# End of macro DMARK
43d1						CALLMONITOR 
43d1 cd 19 17			call break_point_state  
43d4				endm  
# End of macro CALLMONITOR
43d4					endif 
43d4 cd fe 10				call string_to_uint16 
43d7			 
43d7					if DEBUG_FORTH_WORDS 
43d7						DMARK "S2b" 
43d7 f5				push af  
43d8 3a ec 43			ld a, (.dmark)  
43db 32 77 fb			ld (debug_mark),a  
43de 3a ed 43			ld a, (.dmark+1)  
43e1 32 78 fb			ld (debug_mark+1),a  
43e4 3a ee 43			ld a, (.dmark+2)  
43e7 32 79 fb			ld (debug_mark+2),a  
43ea 18 03			jr .pastdmark  
43ec ..			.dmark: db "S2b"  
43ef f1			.pastdmark: pop af  
43f0			endm  
# End of macro DMARK
43f0						CALLMONITOR 
43f0 cd 19 17			call break_point_state  
43f3				endm  
# End of macro CALLMONITOR
43f3					endif 
43f3			;		push hl 
43f3					FORTH_DSP_POP 
43f3 cd 58 1f			call macro_forth_dsp_pop 
43f6				endm 
# End of macro FORTH_DSP_POP
43f6			;		pop hl 
43f6					 
43f6					if DEBUG_FORTH_WORDS 
43f6						DMARK "S2b" 
43f6 f5				push af  
43f7 3a 0b 44			ld a, (.dmark)  
43fa 32 77 fb			ld (debug_mark),a  
43fd 3a 0c 44			ld a, (.dmark+1)  
4400 32 78 fb			ld (debug_mark+1),a  
4403 3a 0d 44			ld a, (.dmark+2)  
4406 32 79 fb			ld (debug_mark+2),a  
4409 18 03			jr .pastdmark  
440b ..			.dmark: db "S2b"  
440e f1			.pastdmark: pop af  
440f			endm  
# End of macro DMARK
440f						CALLMONITOR 
440f cd 19 17			call break_point_state  
4412				endm  
# End of macro CALLMONITOR
4412					endif 
4412 cd a9 1c				call forth_push_numhl	 
4415			 
4415				 
4415				       NEXTW 
4415 c3 12 20			jp macro_next 
4418				endm 
# End of macro NEXTW
4418			.NUM2STR: 
4418				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4418 48				db WORD_SYS_CORE+52             
4419 27 44			dw .CONCAT            
441b 08				db 7 + 1 
441c .. 00			db "NUM2STR",0              
4424				endm 
# End of macro CWHEAD
4424			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4424			 
4424			;		; malloc a string to target 
4424			;		ld hl, 10     ; TODO max string size should be fine 
4424			;		call malloc 
4424			;		push hl    ; save malloc location 
4424			; 
4424			; 
4424			;; TODO check int type 
4424			;		FORTH_DSP_VALUEHL 
4424			;		ld a, l 
4424			;		call DispAToASCII   
4424			;;TODO need to chage above call to dump into string 
4424			; 
4424			; 
4424			 
4424				       NEXTW 
4424 c3 12 20			jp macro_next 
4427				endm 
# End of macro NEXTW
4427			 
4427			.CONCAT: 
4427				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4427 48				db WORD_SYS_CORE+52             
4428 da 44			dw .FIND            
442a 07				db 6 + 1 
442b .. 00			db "CONCAT",0              
4432				endm 
# End of macro CWHEAD
4432			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4432			 
4432			; TODO check string type 
4432			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4432			 
4432					if DEBUG_FORTH_WORDS_KEY 
4432						DMARK "CON" 
4432 f5				push af  
4433 3a 47 44			ld a, (.dmark)  
4436 32 77 fb			ld (debug_mark),a  
4439 3a 48 44			ld a, (.dmark+1)  
443c 32 78 fb			ld (debug_mark+1),a  
443f 3a 49 44			ld a, (.dmark+2)  
4442 32 79 fb			ld (debug_mark+2),a  
4445 18 03			jr .pastdmark  
4447 ..			.dmark: db "CON"  
444a f1			.pastdmark: pop af  
444b			endm  
# End of macro DMARK
444b						CALLMONITOR 
444b cd 19 17			call break_point_state  
444e				endm  
# End of macro CALLMONITOR
444e					endif 
444e			 
444e			 
444e					FORTH_DSP_VALUE 
444e cd 89 1e			call macro_forth_dsp_value 
4451				endm 
# End of macro FORTH_DSP_VALUE
4451 e5					push hl   ; s2 
4452			 
4452					FORTH_DSP_POP 
4452 cd 58 1f			call macro_forth_dsp_pop 
4455				endm 
# End of macro FORTH_DSP_POP
4455			 
4455					FORTH_DSP_VALUE 
4455 cd 89 1e			call macro_forth_dsp_value 
4458				endm 
# End of macro FORTH_DSP_VALUE
4458			 
4458 e5					push hl   ; s1 
4459			 
4459					FORTH_DSP_POP 
4459 cd 58 1f			call macro_forth_dsp_pop 
445c				endm 
# End of macro FORTH_DSP_POP
445c					 
445c			 
445c					; copy s1 
445c			 
445c				 
445c					; save ptr 
445c e1					pop hl  
445d e5					push hl 
445e 3e 00				ld a, 0 
4460 cd 72 11				call strlent 
4463					;inc hl    ; zer0 
4463 06 00				ld b, 0 
4465 4d					ld c, l 
4466 e1					pop hl		 
4467 11 1d ee				ld de, scratch	 
446a					if DEBUG_FORTH_WORDS 
446a						DMARK "CO1" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 77 fb			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 78 fb			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 79 fb			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "CO1"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483						CALLMONITOR 
4483 cd 19 17			call break_point_state  
4486				endm  
# End of macro CALLMONITOR
4486					endif 
4486 ed b0				ldir 
4488			 
4488 e1					pop hl 
4489 e5					push hl 
448a d5					push de 
448b			 
448b			 
448b 3e 00				ld a, 0 
448d cd 72 11				call strlent 
4490 23					inc hl    ; zer0 
4491 23					inc hl 
4492 06 00				ld b, 0 
4494 4d					ld c, l 
4495 d1					pop de 
4496 e1					pop hl		 
4497					if DEBUG_FORTH_WORDS 
4497						DMARK "CO2" 
4497 f5				push af  
4498 3a ac 44			ld a, (.dmark)  
449b 32 77 fb			ld (debug_mark),a  
449e 3a ad 44			ld a, (.dmark+1)  
44a1 32 78 fb			ld (debug_mark+1),a  
44a4 3a ae 44			ld a, (.dmark+2)  
44a7 32 79 fb			ld (debug_mark+2),a  
44aa 18 03			jr .pastdmark  
44ac ..			.dmark: db "CO2"  
44af f1			.pastdmark: pop af  
44b0			endm  
# End of macro DMARK
44b0						CALLMONITOR 
44b0 cd 19 17			call break_point_state  
44b3				endm  
# End of macro CALLMONITOR
44b3					endif 
44b3 ed b0				ldir 
44b5			 
44b5			 
44b5			 
44b5 21 1d ee				ld hl, scratch 
44b8					if DEBUG_FORTH_WORDS 
44b8						DMARK "CO5" 
44b8 f5				push af  
44b9 3a cd 44			ld a, (.dmark)  
44bc 32 77 fb			ld (debug_mark),a  
44bf 3a ce 44			ld a, (.dmark+1)  
44c2 32 78 fb			ld (debug_mark+1),a  
44c5 3a cf 44			ld a, (.dmark+2)  
44c8 32 79 fb			ld (debug_mark+2),a  
44cb 18 03			jr .pastdmark  
44cd ..			.dmark: db "CO5"  
44d0 f1			.pastdmark: pop af  
44d1			endm  
# End of macro DMARK
44d1						CALLMONITOR 
44d1 cd 19 17			call break_point_state  
44d4				endm  
# End of macro CALLMONITOR
44d4					endif 
44d4			 
44d4 cd 17 1d				call forth_push_str 
44d7			 
44d7			 
44d7			 
44d7			 
44d7				       NEXTW 
44d7 c3 12 20			jp macro_next 
44da				endm 
# End of macro NEXTW
44da			 
44da			 
44da			.FIND: 
44da				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44da 4b				db WORD_SYS_CORE+55             
44db 98 45			dw .LEN            
44dd 05				db 4 + 1 
44de .. 00			db "FIND",0              
44e3				endm 
# End of macro CWHEAD
44e3			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44e3			 
44e3					if DEBUG_FORTH_WORDS_KEY 
44e3						DMARK "FND" 
44e3 f5				push af  
44e4 3a f8 44			ld a, (.dmark)  
44e7 32 77 fb			ld (debug_mark),a  
44ea 3a f9 44			ld a, (.dmark+1)  
44ed 32 78 fb			ld (debug_mark+1),a  
44f0 3a fa 44			ld a, (.dmark+2)  
44f3 32 79 fb			ld (debug_mark+2),a  
44f6 18 03			jr .pastdmark  
44f8 ..			.dmark: db "FND"  
44fb f1			.pastdmark: pop af  
44fc			endm  
# End of macro DMARK
44fc						CALLMONITOR 
44fc cd 19 17			call break_point_state  
44ff				endm  
# End of macro CALLMONITOR
44ff					endif 
44ff			 
44ff			; TODO check string type 
44ff					FORTH_DSP_VALUE 
44ff cd 89 1e			call macro_forth_dsp_value 
4502				endm 
# End of macro FORTH_DSP_VALUE
4502			 
4502 e5					push hl    
4503 7e					ld a,(hl)    ; char to find   
4504			; TODO change char to substr 
4504			 
4504 f5					push af 
4505					 
4505			 
4505			 
4505					if DEBUG_FORTH_WORDS 
4505						DMARK "FN1" 
4505 f5				push af  
4506 3a 1a 45			ld a, (.dmark)  
4509 32 77 fb			ld (debug_mark),a  
450c 3a 1b 45			ld a, (.dmark+1)  
450f 32 78 fb			ld (debug_mark+1),a  
4512 3a 1c 45			ld a, (.dmark+2)  
4515 32 79 fb			ld (debug_mark+2),a  
4518 18 03			jr .pastdmark  
451a ..			.dmark: db "FN1"  
451d f1			.pastdmark: pop af  
451e			endm  
# End of macro DMARK
451e						CALLMONITOR 
451e cd 19 17			call break_point_state  
4521				endm  
# End of macro CALLMONITOR
4521					endif 
4521			 
4521					FORTH_DSP_POP 
4521 cd 58 1f			call macro_forth_dsp_pop 
4524				endm 
# End of macro FORTH_DSP_POP
4524			 
4524					; string to search 
4524			 
4524					FORTH_DSP_VALUE 
4524 cd 89 1e			call macro_forth_dsp_value 
4527				endm 
# End of macro FORTH_DSP_VALUE
4527			 
4527 d1					pop de  ; d is char to find  
4528			 
4528					if DEBUG_FORTH_WORDS 
4528						DMARK "FN2" 
4528 f5				push af  
4529 3a 3d 45			ld a, (.dmark)  
452c 32 77 fb			ld (debug_mark),a  
452f 3a 3e 45			ld a, (.dmark+1)  
4532 32 78 fb			ld (debug_mark+1),a  
4535 3a 3f 45			ld a, (.dmark+2)  
4538 32 79 fb			ld (debug_mark+2),a  
453b 18 03			jr .pastdmark  
453d ..			.dmark: db "FN2"  
4540 f1			.pastdmark: pop af  
4541			endm  
# End of macro DMARK
4541						CALLMONITOR 
4541 cd 19 17			call break_point_state  
4544				endm  
# End of macro CALLMONITOR
4544					endif 
4544					 
4544 01 00 00				ld bc, 0 
4547 7e			.findchar:      ld a,(hl) 
4548 fe 00				cp 0   		 
454a 28 27				jr z, .finddone     
454c ba					cp d 
454d 28 20				jr z, .foundchar 
454f 03					inc bc 
4550 23					inc hl 
4551					if DEBUG_FORTH_WORDS 
4551						DMARK "FN3" 
4551 f5				push af  
4552 3a 66 45			ld a, (.dmark)  
4555 32 77 fb			ld (debug_mark),a  
4558 3a 67 45			ld a, (.dmark+1)  
455b 32 78 fb			ld (debug_mark+1),a  
455e 3a 68 45			ld a, (.dmark+2)  
4561 32 79 fb			ld (debug_mark+2),a  
4564 18 03			jr .pastdmark  
4566 ..			.dmark: db "FN3"  
4569 f1			.pastdmark: pop af  
456a			endm  
# End of macro DMARK
456a						CALLMONITOR 
456a cd 19 17			call break_point_state  
456d				endm  
# End of macro CALLMONITOR
456d					endif 
456d 18 d8				jr .findchar 
456f			 
456f			 
456f c5			.foundchar:	push bc 
4570 e1					pop hl 
4571 18 03				jr .findexit 
4573			 
4573			 
4573							 
4573			 
4573			.finddone:     ; got to end of string with no find 
4573 21 00 00				ld hl, 0 
4576			.findexit: 
4576			 
4576					if DEBUG_FORTH_WORDS 
4576						DMARK "FNd" 
4576 f5				push af  
4577 3a 8b 45			ld a, (.dmark)  
457a 32 77 fb			ld (debug_mark),a  
457d 3a 8c 45			ld a, (.dmark+1)  
4580 32 78 fb			ld (debug_mark+1),a  
4583 3a 8d 45			ld a, (.dmark+2)  
4586 32 79 fb			ld (debug_mark+2),a  
4589 18 03			jr .pastdmark  
458b ..			.dmark: db "FNd"  
458e f1			.pastdmark: pop af  
458f			endm  
# End of macro DMARK
458f						CALLMONITOR 
458f cd 19 17			call break_point_state  
4592				endm  
# End of macro CALLMONITOR
4592					endif 
4592 cd a9 1c			call forth_push_numhl 
4595			 
4595				       NEXTW 
4595 c3 12 20			jp macro_next 
4598				endm 
# End of macro NEXTW
4598			 
4598			.LEN: 
4598				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4598 4c				db WORD_SYS_CORE+56             
4599 cd 45			dw .CHAR            
459b 06				db 5 + 1 
459c .. 00			db "COUNT",0              
45a2				endm 
# End of macro CWHEAD
45a2			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
45a2			 
45a2					if DEBUG_FORTH_WORDS_KEY 
45a2						DMARK "CNT" 
45a2 f5				push af  
45a3 3a b7 45			ld a, (.dmark)  
45a6 32 77 fb			ld (debug_mark),a  
45a9 3a b8 45			ld a, (.dmark+1)  
45ac 32 78 fb			ld (debug_mark+1),a  
45af 3a b9 45			ld a, (.dmark+2)  
45b2 32 79 fb			ld (debug_mark+2),a  
45b5 18 03			jr .pastdmark  
45b7 ..			.dmark: db "CNT"  
45ba f1			.pastdmark: pop af  
45bb			endm  
# End of macro DMARK
45bb						CALLMONITOR 
45bb cd 19 17			call break_point_state  
45be				endm  
# End of macro CALLMONITOR
45be					endif 
45be			; TODO check string type 
45be					FORTH_DSP 
45be cd 66 1e			call macro_forth_dsp 
45c1				endm 
# End of macro FORTH_DSP
45c1					;v5FORTH_DSP_VALUE 
45c1			 
45c1 23					inc hl 
45c2			 
45c2 3e 00				ld a, 0 
45c4 cd 72 11				call strlent 
45c7			 
45c7 cd a9 1c				call forth_push_numhl 
45ca			 
45ca			 
45ca			 
45ca				       NEXTW 
45ca c3 12 20			jp macro_next 
45cd				endm 
# End of macro NEXTW
45cd			.CHAR: 
45cd				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
45cd 4d				db WORD_SYS_CORE+57             
45ce 03 46			dw .ENDSTR            
45d0 05				db 4 + 1 
45d1 .. 00			db "CHAR",0              
45d6				endm 
# End of macro CWHEAD
45d6			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
45d6					if DEBUG_FORTH_WORDS_KEY 
45d6						DMARK "CHR" 
45d6 f5				push af  
45d7 3a eb 45			ld a, (.dmark)  
45da 32 77 fb			ld (debug_mark),a  
45dd 3a ec 45			ld a, (.dmark+1)  
45e0 32 78 fb			ld (debug_mark+1),a  
45e3 3a ed 45			ld a, (.dmark+2)  
45e6 32 79 fb			ld (debug_mark+2),a  
45e9 18 03			jr .pastdmark  
45eb ..			.dmark: db "CHR"  
45ee f1			.pastdmark: pop af  
45ef			endm  
# End of macro DMARK
45ef						CALLMONITOR 
45ef cd 19 17			call break_point_state  
45f2				endm  
# End of macro CALLMONITOR
45f2					endif 
45f2					FORTH_DSP 
45f2 cd 66 1e			call macro_forth_dsp 
45f5				endm 
# End of macro FORTH_DSP
45f5					;v5 FORTH_DSP_VALUE 
45f5 23					inc hl      ; now at start of numeric as string 
45f6			 
45f6			;		push hl 
45f6			 
45f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45f6 cd 58 1f			call macro_forth_dsp_pop 
45f9				endm 
# End of macro FORTH_DSP_POP
45f9			 
45f9			;		pop hl 
45f9			 
45f9					; push the content of a onto the stack as a value 
45f9			 
45f9 7e					ld a,(hl)   ; get char 
45fa 26 00				ld h,0 
45fc 6f					ld l,a 
45fd cd a9 1c				call forth_push_numhl 
4600			 
4600				       NEXTW 
4600 c3 12 20			jp macro_next 
4603				endm 
# End of macro NEXTW
4603			 
4603			 
4603			 
4603			 
4603			.ENDSTR: 
4603			; eof 
4603			 
# End of file forth_words_str.asm
4603			include "forth_words_key.asm" 
4603			 
4603			; | ## Keyboard Words 
4603			 
4603			.KEY: 
4603				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4603 3e				db WORD_SYS_CORE+42             
4604 33 46			dw .WAITK            
4606 04				db 3 + 1 
4607 .. 00			db "KEY",0              
460b				endm 
# End of macro CWHEAD
460b			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
460b			 
460b					if DEBUG_FORTH_WORDS_KEY 
460b						DMARK "KEY" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 77 fb			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 78 fb			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 79 fb			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "KEY"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd 19 17			call break_point_state  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627			; TODO currently waits 
4627 cd 00 6a				call cin 
462a					;call cin_wait 
462a 6f					ld l, a 
462b 26 00				ld h, 0 
462d cd a9 1c				call forth_push_numhl 
4630					NEXTW 
4630 c3 12 20			jp macro_next 
4633				endm 
# End of macro NEXTW
4633			.WAITK: 
4633				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4633 3f				db WORD_SYS_CORE+43             
4634 65 46			dw .ACCEPT            
4636 06				db 5 + 1 
4637 .. 00			db "WAITK",0              
463d				endm 
# End of macro CWHEAD
463d			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
463d					if DEBUG_FORTH_WORDS_KEY 
463d						DMARK "WAI" 
463d f5				push af  
463e 3a 52 46			ld a, (.dmark)  
4641 32 77 fb			ld (debug_mark),a  
4644 3a 53 46			ld a, (.dmark+1)  
4647 32 78 fb			ld (debug_mark+1),a  
464a 3a 54 46			ld a, (.dmark+2)  
464d 32 79 fb			ld (debug_mark+2),a  
4650 18 03			jr .pastdmark  
4652 ..			.dmark: db "WAI"  
4655 f1			.pastdmark: pop af  
4656			endm  
# End of macro DMARK
4656						CALLMONITOR 
4656 cd 19 17			call break_point_state  
4659				endm  
# End of macro CALLMONITOR
4659					endif 
4659 cd ef 69				call cin_wait 
465c 6f					ld l, a 
465d 26 00				ld h, 0 
465f cd a9 1c				call forth_push_numhl 
4662					NEXTW 
4662 c3 12 20			jp macro_next 
4665				endm 
# End of macro NEXTW
4665			.ACCEPT: 
4665				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4665 40				db WORD_SYS_CORE+44             
4666 c3 46			dw .EDIT            
4668 07				db 6 + 1 
4669 .. 00			db "ACCEPT",0              
4670				endm 
# End of macro CWHEAD
4670			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4670					; TODO crashes on push 
4670					if DEBUG_FORTH_WORDS_KEY 
4670						DMARK "ACC" 
4670 f5				push af  
4671 3a 85 46			ld a, (.dmark)  
4674 32 77 fb			ld (debug_mark),a  
4677 3a 86 46			ld a, (.dmark+1)  
467a 32 78 fb			ld (debug_mark+1),a  
467d 3a 87 46			ld a, (.dmark+2)  
4680 32 79 fb			ld (debug_mark+2),a  
4683 18 03			jr .pastdmark  
4685 ..			.dmark: db "ACC"  
4688 f1			.pastdmark: pop af  
4689			endm  
# End of macro DMARK
4689						CALLMONITOR 
4689 cd 19 17			call break_point_state  
468c				endm  
# End of macro CALLMONITOR
468c					endif 
468c 21 1b f0				ld hl, os_input 
468f 3e 00				ld a, 0 
4691 77					ld (hl),a 
4692 3a 46 f8				ld a,(f_cursor_ptr) 
4695 16 64				ld d, 100 
4697 0e 00				ld c, 0 
4699 1e 28				ld e, 40 
469b cd 36 0d				call input_str 
469e					; TODO perhaps do a type check and wrap in quotes if not a number 
469e 21 1b f0				ld hl, os_input 
46a1					if DEBUG_FORTH_WORDS 
46a1						DMARK "AC1" 
46a1 f5				push af  
46a2 3a b6 46			ld a, (.dmark)  
46a5 32 77 fb			ld (debug_mark),a  
46a8 3a b7 46			ld a, (.dmark+1)  
46ab 32 78 fb			ld (debug_mark+1),a  
46ae 3a b8 46			ld a, (.dmark+2)  
46b1 32 79 fb			ld (debug_mark+2),a  
46b4 18 03			jr .pastdmark  
46b6 ..			.dmark: db "AC1"  
46b9 f1			.pastdmark: pop af  
46ba			endm  
# End of macro DMARK
46ba						CALLMONITOR 
46ba cd 19 17			call break_point_state  
46bd				endm  
# End of macro CALLMONITOR
46bd					endif 
46bd cd 17 1d				call forth_push_str 
46c0					NEXTW 
46c0 c3 12 20			jp macro_next 
46c3				endm 
# End of macro NEXTW
46c3			 
46c3			.EDIT: 
46c3				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
46c3 40				db WORD_SYS_CORE+44             
46c4 4c 47			dw .ENDKEY            
46c6 05				db 4 + 1 
46c7 .. 00			db "EDIT",0              
46cc				endm 
# End of macro CWHEAD
46cc			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
46cc			 
46cc					; TODO does not copy from stack 
46cc					if DEBUG_FORTH_WORDS_KEY 
46cc						DMARK "EDT" 
46cc f5				push af  
46cd 3a e1 46			ld a, (.dmark)  
46d0 32 77 fb			ld (debug_mark),a  
46d3 3a e2 46			ld a, (.dmark+1)  
46d6 32 78 fb			ld (debug_mark+1),a  
46d9 3a e3 46			ld a, (.dmark+2)  
46dc 32 79 fb			ld (debug_mark+2),a  
46df 18 03			jr .pastdmark  
46e1 ..			.dmark: db "EDT"  
46e4 f1			.pastdmark: pop af  
46e5			endm  
# End of macro DMARK
46e5						CALLMONITOR 
46e5 cd 19 17			call break_point_state  
46e8				endm  
# End of macro CALLMONITOR
46e8					endif 
46e8			 
46e8					FORTH_DSP 
46e8 cd 66 1e			call macro_forth_dsp 
46eb				endm 
# End of macro FORTH_DSP
46eb					;v5 FORTH_DSP_VALUE 
46eb 23					inc hl    ; TODO do type check 
46ec			 
46ec e5					push hl 
46ed 3e 00				ld a, 0 
46ef cd 72 11				call strlent 
46f2 23					inc hl 
46f3			 
46f3 06 00				ld b, 0 
46f5 4d					ld c, l 
46f6			 
46f6 e1					pop hl 
46f7 11 1b f0				ld de, os_input 
46fa					if DEBUG_FORTH_WORDS_KEY 
46fa						DMARK "EDc" 
46fa f5				push af  
46fb 3a 0f 47			ld a, (.dmark)  
46fe 32 77 fb			ld (debug_mark),a  
4701 3a 10 47			ld a, (.dmark+1)  
4704 32 78 fb			ld (debug_mark+1),a  
4707 3a 11 47			ld a, (.dmark+2)  
470a 32 79 fb			ld (debug_mark+2),a  
470d 18 03			jr .pastdmark  
470f ..			.dmark: db "EDc"  
4712 f1			.pastdmark: pop af  
4713			endm  
# End of macro DMARK
4713						CALLMONITOR 
4713 cd 19 17			call break_point_state  
4716				endm  
# End of macro CALLMONITOR
4716					endif 
4716 ed b0				ldir 
4718			 
4718			 
4718 21 1b f0				ld hl, os_input 
471b					;ld a, 0 
471b					;ld (hl),a 
471b 3a 46 f8				ld a,(f_cursor_ptr) 
471e 16 64				ld d, 100 
4720 0e 00				ld c, 0 
4722 1e 28				ld e, 40 
4724 cd 36 0d				call input_str 
4727					; TODO perhaps do a type check and wrap in quotes if not a number 
4727 21 1b f0				ld hl, os_input 
472a					if DEBUG_FORTH_WORDS 
472a						DMARK "ED1" 
472a f5				push af  
472b 3a 3f 47			ld a, (.dmark)  
472e 32 77 fb			ld (debug_mark),a  
4731 3a 40 47			ld a, (.dmark+1)  
4734 32 78 fb			ld (debug_mark+1),a  
4737 3a 41 47			ld a, (.dmark+2)  
473a 32 79 fb			ld (debug_mark+2),a  
473d 18 03			jr .pastdmark  
473f ..			.dmark: db "ED1"  
4742 f1			.pastdmark: pop af  
4743			endm  
# End of macro DMARK
4743						CALLMONITOR 
4743 cd 19 17			call break_point_state  
4746				endm  
# End of macro CALLMONITOR
4746					endif 
4746 cd 17 1d				call forth_push_str 
4749					NEXTW 
4749 c3 12 20			jp macro_next 
474c				endm 
# End of macro NEXTW
474c			 
474c			 
474c			 
474c			.ENDKEY: 
474c			; eof 
474c			 
# End of file forth_words_key.asm
474c			 
474c			if STORAGE_SE 
474c			   	include "forth_words_storage.asm" 
474c			 
474c			; | ## Fixed Storage Words 
474c			 
474c			 
474c			.BREAD: 
474c			  
474c				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
474c 3a				db WORD_SYS_CORE+38             
474d c5 47			dw .BWRITE            
474f 06				db 5 + 1 
4750 .. 00			db "BREAD",0              
4756				endm 
# End of macro CWHEAD
4756			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4756				 
4756					if DEBUG_FORTH_WORDS_KEY 
4756						DMARK "BRD" 
4756 f5				push af  
4757 3a 6b 47			ld a, (.dmark)  
475a 32 77 fb			ld (debug_mark),a  
475d 3a 6c 47			ld a, (.dmark+1)  
4760 32 78 fb			ld (debug_mark+1),a  
4763 3a 6d 47			ld a, (.dmark+2)  
4766 32 79 fb			ld (debug_mark+2),a  
4769 18 03			jr .pastdmark  
476b ..			.dmark: db "BRD"  
476e f1			.pastdmark: pop af  
476f			endm  
# End of macro DMARK
476f						CALLMONITOR 
476f cd 19 17			call break_point_state  
4772				endm  
# End of macro CALLMONITOR
4772					endif 
4772			 
4772				FORTH_DSP_VALUEHL 
4772 cd a0 1e			call macro_dsp_valuehl 
4775				endm 
# End of macro FORTH_DSP_VALUEHL
4775			 
4775				FORTH_DSP_POP 
4775 cd 58 1f			call macro_forth_dsp_pop 
4778				endm 
# End of macro FORTH_DSP_POP
4778			 
4778				; calc block address 
4778			 
4778 eb				ex de, hl 
4779 3e 40			ld a, STORE_BLOCK_PHY 
477b cd 8c 0c			call Mult16 
477e			 
477e			 
477e 11 62 f8			ld de, store_page 
4781			 
4781					if DEBUG_FORTH_WORDS 
4781						DMARK "BR1" 
4781 f5				push af  
4782 3a 96 47			ld a, (.dmark)  
4785 32 77 fb			ld (debug_mark),a  
4788 3a 97 47			ld a, (.dmark+1)  
478b 32 78 fb			ld (debug_mark+1),a  
478e 3a 98 47			ld a, (.dmark+2)  
4791 32 79 fb			ld (debug_mark+2),a  
4794 18 03			jr .pastdmark  
4796 ..			.dmark: db "BR1"  
4799 f1			.pastdmark: pop af  
479a			endm  
# End of macro DMARK
479a						CALLMONITOR 
479a cd 19 17			call break_point_state  
479d				endm  
# End of macro CALLMONITOR
479d					endif 
479d			 
479d cd 0c 03			call storage_read_block 
47a0			 
47a0 21 64 f8		        ld hl, store_page+2 
47a3					if DEBUG_FORTH_WORDS 
47a3						DMARK "BR2" 
47a3 f5				push af  
47a4 3a b8 47			ld a, (.dmark)  
47a7 32 77 fb			ld (debug_mark),a  
47aa 3a b9 47			ld a, (.dmark+1)  
47ad 32 78 fb			ld (debug_mark+1),a  
47b0 3a ba 47			ld a, (.dmark+2)  
47b3 32 79 fb			ld (debug_mark+2),a  
47b6 18 03			jr .pastdmark  
47b8 ..			.dmark: db "BR2"  
47bb f1			.pastdmark: pop af  
47bc			endm  
# End of macro DMARK
47bc						CALLMONITOR 
47bc cd 19 17			call break_point_state  
47bf				endm  
# End of macro CALLMONITOR
47bf					endif 
47bf cd 17 1d			call forth_push_str 
47c2			 
47c2			 
47c2					NEXTW 
47c2 c3 12 20			jp macro_next 
47c5				endm 
# End of macro NEXTW
47c5			.BWRITE: 
47c5				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
47c5 3a				db WORD_SYS_CORE+38             
47c6 5a 48			dw .BUPD            
47c8 07				db 6 + 1 
47c9 .. 00			db "BWRITE",0              
47d0				endm 
# End of macro CWHEAD
47d0			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
47d0			 
47d0					if DEBUG_FORTH_WORDS_KEY 
47d0						DMARK "BWR" 
47d0 f5				push af  
47d1 3a e5 47			ld a, (.dmark)  
47d4 32 77 fb			ld (debug_mark),a  
47d7 3a e6 47			ld a, (.dmark+1)  
47da 32 78 fb			ld (debug_mark+1),a  
47dd 3a e7 47			ld a, (.dmark+2)  
47e0 32 79 fb			ld (debug_mark+2),a  
47e3 18 03			jr .pastdmark  
47e5 ..			.dmark: db "BWR"  
47e8 f1			.pastdmark: pop af  
47e9			endm  
# End of macro DMARK
47e9						CALLMONITOR 
47e9 cd 19 17			call break_point_state  
47ec				endm  
# End of macro CALLMONITOR
47ec					endif 
47ec			 
47ec				FORTH_DSP_VALUEHL 
47ec cd a0 1e			call macro_dsp_valuehl 
47ef				endm 
# End of macro FORTH_DSP_VALUEHL
47ef			 
47ef				; calc block address 
47ef			 
47ef eb				ex de, hl 
47f0 3e 40			ld a, STORE_BLOCK_PHY 
47f2 cd 8c 0c			call Mult16 
47f5			 
47f5 e5				push hl         ; address 
47f6			 
47f6				FORTH_DSP_POP 
47f6 cd 58 1f			call macro_forth_dsp_pop 
47f9				endm 
# End of macro FORTH_DSP_POP
47f9			 
47f9				FORTH_DSP_VALUEHL 
47f9 cd a0 1e			call macro_dsp_valuehl 
47fc				endm 
# End of macro FORTH_DSP_VALUEHL
47fc			 
47fc				FORTH_DSP_POP 
47fc cd 58 1f			call macro_forth_dsp_pop 
47ff				endm 
# End of macro FORTH_DSP_POP
47ff			 
47ff cd 18 0a			call storage_clear_page 
4802			 
4802				; copy string to store page 
4802			 
4802 e5				push hl     ; save string address 
4803			 
4803 3e 00			ld a, 0 
4805 cd 72 11			call strlent 
4808			 
4808 23				inc hl 
4809			 
4809 4d				ld c, l 
480a 06 00			ld b, 0 
480c			 
480c e1				pop hl 
480d 11 64 f8			ld de, store_page + 2 
4810					if DEBUG_FORTH_WORDS 
4810						DMARK "BW1" 
4810 f5				push af  
4811 3a 25 48			ld a, (.dmark)  
4814 32 77 fb			ld (debug_mark),a  
4817 3a 26 48			ld a, (.dmark+1)  
481a 32 78 fb			ld (debug_mark+1),a  
481d 3a 27 48			ld a, (.dmark+2)  
4820 32 79 fb			ld (debug_mark+2),a  
4823 18 03			jr .pastdmark  
4825 ..			.dmark: db "BW1"  
4828 f1			.pastdmark: pop af  
4829			endm  
# End of macro DMARK
4829						CALLMONITOR 
4829 cd 19 17			call break_point_state  
482c				endm  
# End of macro CALLMONITOR
482c					endif 
482c ed b0			ldir 
482e			 
482e			 
482e				; poke the start of the block with flags to prevent high level file ops hitting the block 
482e			 
482e 21 ff ff			ld hl, $ffff 
4831			 
4831 22 62 f8			ld (store_page), hl	 
4834				 
4834 e1				pop hl    ; get address 
4835 11 62 f8			ld de, store_page 
4838			 
4838					if DEBUG_FORTH_WORDS 
4838						DMARK "BW2" 
4838 f5				push af  
4839 3a 4d 48			ld a, (.dmark)  
483c 32 77 fb			ld (debug_mark),a  
483f 3a 4e 48			ld a, (.dmark+1)  
4842 32 78 fb			ld (debug_mark+1),a  
4845 3a 4f 48			ld a, (.dmark+2)  
4848 32 79 fb			ld (debug_mark+2),a  
484b 18 03			jr .pastdmark  
484d ..			.dmark: db "BW2"  
4850 f1			.pastdmark: pop af  
4851			endm  
# End of macro DMARK
4851						CALLMONITOR 
4851 cd 19 17			call break_point_state  
4854				endm  
# End of macro CALLMONITOR
4854					endif 
4854			 
4854 cd 71 03			call storage_write_block 
4857			 
4857					NEXTW 
4857 c3 12 20			jp macro_next 
485a				endm 
# End of macro NEXTW
485a			 
485a			.BUPD: 
485a				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
485a 3a				db WORD_SYS_CORE+38             
485b b0 48			dw .BYID            
485d 05				db 4 + 1 
485e .. 00			db "BUPD",0              
4863				endm 
# End of macro CWHEAD
4863			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
4863			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4863			; | | or completely different file system structure. 
4863			 
4863					if DEBUG_FORTH_WORDS_KEY 
4863						DMARK "BUD" 
4863 f5				push af  
4864 3a 78 48			ld a, (.dmark)  
4867 32 77 fb			ld (debug_mark),a  
486a 3a 79 48			ld a, (.dmark+1)  
486d 32 78 fb			ld (debug_mark+1),a  
4870 3a 7a 48			ld a, (.dmark+2)  
4873 32 79 fb			ld (debug_mark+2),a  
4876 18 03			jr .pastdmark  
4878 ..			.dmark: db "BUD"  
487b f1			.pastdmark: pop af  
487c			endm  
# End of macro DMARK
487c						CALLMONITOR 
487c cd 19 17			call break_point_state  
487f				endm  
# End of macro CALLMONITOR
487f					endif 
487f			 
487f				FORTH_DSP_VALUEHL 
487f cd a0 1e			call macro_dsp_valuehl 
4882				endm 
# End of macro FORTH_DSP_VALUEHL
4882			 
4882				; calc block address 
4882			 
4882 eb				ex de, hl 
4883 3e 40			ld a, STORE_BLOCK_PHY 
4885 cd 8c 0c			call Mult16 
4888			 
4888				FORTH_DSP_POP 
4888 cd 58 1f			call macro_forth_dsp_pop 
488b				endm 
# End of macro FORTH_DSP_POP
488b			 
488b			 
488b 11 62 f8			ld de, store_page 
488e			 
488e					if DEBUG_FORTH_WORDS 
488e						DMARK "BUe" 
488e f5				push af  
488f 3a a3 48			ld a, (.dmark)  
4892 32 77 fb			ld (debug_mark),a  
4895 3a a4 48			ld a, (.dmark+1)  
4898 32 78 fb			ld (debug_mark+1),a  
489b 3a a5 48			ld a, (.dmark+2)  
489e 32 79 fb			ld (debug_mark+2),a  
48a1 18 03			jr .pastdmark  
48a3 ..			.dmark: db "BUe"  
48a6 f1			.pastdmark: pop af  
48a7			endm  
# End of macro DMARK
48a7						CALLMONITOR 
48a7 cd 19 17			call break_point_state  
48aa				endm  
# End of macro CALLMONITOR
48aa					endif 
48aa			 
48aa cd 71 03			call storage_write_block 
48ad			 
48ad					NEXTW 
48ad c3 12 20			jp macro_next 
48b0				endm 
# End of macro NEXTW
48b0			 
48b0			.BYID: 
48b0			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
48b0			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
48b0			; 
48b0			;		 
48b0			;		if DEBUG_FORTH_WORDS_KEY 
48b0			;			DMARK "BYID" 
48b0			;			CALLMONITOR 
48b0			;		endif 
48b0			; 
48b0			;		; get direct address 
48b0			; 
48b0			;		FORTH_DSP_VALUEHL 
48b0			; 
48b0			;		FORTH_DSP_POP 
48b0			; 
48b0			;	; calc block address 
48b0			; 
48b0			;	ex de, hl 
48b0			;	ld a, STORE_BLOCK_PHY 
48b0			;	call Mult16 
48b0			;	;	do BREAD with number as param 
48b0			;	; push the file name	 
48b0			;	ld de, store_page 
48b0			;	call storage_read_block 
48b0			 ;       ld hl, store_page+2 
48b0			; 
48b0			; 
48b0			;		NEXTW 
48b0			;.BYNAME: 
48b0			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
48b0			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
48b0			;		NEXTW 
48b0			; 
48b0			.DIR: 
48b0				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
48b0 3a				db WORD_SYS_CORE+38             
48b1 b4 49			dw .SAVE            
48b3 04				db 3 + 1 
48b4 .. 00			db "DIR",0              
48b8				endm 
# End of macro CWHEAD
48b8			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
48b8			 
48b8					if DEBUG_FORTH_WORDS_KEY 
48b8						DMARK "DIR" 
48b8 f5				push af  
48b9 3a cd 48			ld a, (.dmark)  
48bc 32 77 fb			ld (debug_mark),a  
48bf 3a ce 48			ld a, (.dmark+1)  
48c2 32 78 fb			ld (debug_mark+1),a  
48c5 3a cf 48			ld a, (.dmark+2)  
48c8 32 79 fb			ld (debug_mark+2),a  
48cb 18 03			jr .pastdmark  
48cd ..			.dmark: db "DIR"  
48d0 f1			.pastdmark: pop af  
48d1			endm  
# End of macro DMARK
48d1						CALLMONITOR 
48d1 cd 19 17			call break_point_state  
48d4				endm  
# End of macro CALLMONITOR
48d4					endif 
48d4 cd bd 03			call storage_get_block_0 
48d7			 
48d7 21 62 f8			ld hl, store_page     ; get current id count 
48da 46				ld b, (hl) 
48db 0e 00			ld c, 0    ; count of files   
48dd					if DEBUG_FORTH_WORDS 
48dd						DMARK "DI1" 
48dd f5				push af  
48de 3a f2 48			ld a, (.dmark)  
48e1 32 77 fb			ld (debug_mark),a  
48e4 3a f3 48			ld a, (.dmark+1)  
48e7 32 78 fb			ld (debug_mark+1),a  
48ea 3a f4 48			ld a, (.dmark+2)  
48ed 32 79 fb			ld (debug_mark+2),a  
48f0 18 03			jr .pastdmark  
48f2 ..			.dmark: db "DI1"  
48f5 f1			.pastdmark: pop af  
48f6			endm  
# End of macro DMARK
48f6						CALLMONITOR 
48f6 cd 19 17			call break_point_state  
48f9				endm  
# End of macro CALLMONITOR
48f9					endif 
48f9			 
48f9				; check for empty drive 
48f9			 
48f9 3e 00			ld a, 0 
48fb b8				cp b 
48fc ca 6a 49			jp z, .dirdone 
48ff			 
48ff				; for each of the current ids do a search for them and if found push to stack 
48ff			 
48ff c5			.diritem:	push bc 
4900 21 40 00				ld hl, STORE_BLOCK_PHY 
4903 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4905 58					ld e,b 
4906			 
4906			;		if DEBUG_FORTH_WORDS 
4906			;			DMARK "DI2" 
4906			;			CALLMONITOR 
4906			;		endif 
4906			 
4906 cd 2d 06				call storage_findnextid 
4909			 
4909			;		if DEBUG_FORTH_WORDS 
4909			;			DMARK "DI3" 
4909			;			CALLMONITOR 
4909			;		endif 
4909			 
4909					; if found hl will be non zero 
4909			 
4909 cd 32 0d				call ishlzero 
490c			;		ld a, l 
490c			;		add h 
490c			; 
490c			;		cp 0 
490c 28 59				jr z, .dirnotfound 
490e			 
490e					; increase count 
490e			 
490e c1					pop bc	 
490f 0c					inc c 
4910 c5					push bc 
4911					 
4911			 
4911					; get file header and push the file name 
4911			 
4911 11 62 f8				ld de, store_page 
4914 cd 0c 03				call storage_read_block 
4917			 
4917					; push file id to stack 
4917				 
4917 3a 62 f8				ld a, (store_page) 
491a 26 00				ld h, 0 
491c 6f					ld l, a 
491d cd a9 1c				call forth_push_numhl 
4920			 
4920					; push extent count to stack  
4920				 
4920 3a 64 f8				ld a, (store_page+2) 
4923 26 00				ld h, 0 
4925 6f					ld l, a 
4926 cd a9 1c				call forth_push_numhl 
4929			 
4929					; push file name 
4929			 
4929 21 65 f8				ld hl, store_page+3 
492c					if DEBUG_FORTH_WORDS 
492c						DMARK "DI5" 
492c f5				push af  
492d 3a 41 49			ld a, (.dmark)  
4930 32 77 fb			ld (debug_mark),a  
4933 3a 42 49			ld a, (.dmark+1)  
4936 32 78 fb			ld (debug_mark+1),a  
4939 3a 43 49			ld a, (.dmark+2)  
493c 32 79 fb			ld (debug_mark+2),a  
493f 18 03			jr .pastdmark  
4941 ..			.dmark: db "DI5"  
4944 f1			.pastdmark: pop af  
4945			endm  
# End of macro DMARK
4945						CALLMONITOR 
4945 cd 19 17			call break_point_state  
4948				endm  
# End of macro CALLMONITOR
4948					endif 
4948 cd 17 1d				call forth_push_str 
494b					if DEBUG_FORTH_WORDS 
494b						DMARK "DI6" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 77 fb			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 78 fb			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 79 fb			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "DI6"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964						CALLMONITOR 
4964 cd 19 17			call break_point_state  
4967				endm  
# End of macro CALLMONITOR
4967					endif 
4967			.dirnotfound: 
4967 c1					pop bc     
4968 10 95				djnz .diritem 
496a				 
496a			.dirdone:	 
496a					if DEBUG_FORTH_WORDS 
496a						DMARK "DI7" 
496a f5				push af  
496b 3a 7f 49			ld a, (.dmark)  
496e 32 77 fb			ld (debug_mark),a  
4971 3a 80 49			ld a, (.dmark+1)  
4974 32 78 fb			ld (debug_mark+1),a  
4977 3a 81 49			ld a, (.dmark+2)  
497a 32 79 fb			ld (debug_mark+2),a  
497d 18 03			jr .pastdmark  
497f ..			.dmark: db "DI7"  
4982 f1			.pastdmark: pop af  
4983			endm  
# End of macro DMARK
4983						CALLMONITOR 
4983 cd 19 17			call break_point_state  
4986				endm  
# End of macro CALLMONITOR
4986					endif 
4986			 
4986					; push a count of the dir items found 
4986			 
4986 26 00				ld h, 0 
4988 69					ld l, c 
4989 cd a9 1c				call forth_push_numhl 
498c			 
498c					; push the bank label 
498c			 
498c cd bd 03				call storage_get_block_0 
498f			 
498f				 
498f 21 65 f8		 		ld hl, store_page+3 
4992			 
4992					if DEBUG_FORTH_WORDS 
4992						DMARK "DI8" 
4992 f5				push af  
4993 3a a7 49			ld a, (.dmark)  
4996 32 77 fb			ld (debug_mark),a  
4999 3a a8 49			ld a, (.dmark+1)  
499c 32 78 fb			ld (debug_mark+1),a  
499f 3a a9 49			ld a, (.dmark+2)  
49a2 32 79 fb			ld (debug_mark+2),a  
49a5 18 03			jr .pastdmark  
49a7 ..			.dmark: db "DI8"  
49aa f1			.pastdmark: pop af  
49ab			endm  
# End of macro DMARK
49ab						CALLMONITOR 
49ab cd 19 17			call break_point_state  
49ae				endm  
# End of macro CALLMONITOR
49ae					endif 
49ae cd 17 1d				call forth_push_str 
49b1			 
49b1			 
49b1				 
49b1					NEXTW 
49b1 c3 12 20			jp macro_next 
49b4				endm 
# End of macro NEXTW
49b4			.SAVE: 
49b4			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
49b4			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
49b4			;		NEXTW 
49b4			;.LOAD: 
49b4			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
49b4			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
49b4			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
49b4			;; > > The LOAD command can not be used in any user words or compound lines. 
49b4			; 
49b4			;		; store_openext use it. If zero it is EOF 
49b4			; 
49b4			;		; read block from current stream id 
49b4			;		; if the block does not contain zero term keep reading blocks until zero found 
49b4			;		; push the block to stack 
49b4			;		; save the block id to stream 
49b4			; 
49b4			; 
49b4			;		FORTH_DSP_VALUEHL 
49b4			; 
49b4			;;		push hl 
49b4			; 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LOA" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;		FORTH_DSP_POP 
49b4			; 
49b4			;;		pop hl 
49b4			; 
49b4			;		ld h, l 
49b4			;		ld l, 0 
49b4			; 
49b4			;		push hl     ; stack holds current file id and extent to work with 
49b4			; 
49b4			; 
49b4			;		ld de, store_page      ; get block zero of file 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LO0" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;		call storage_read 
49b4			; 
49b4			;		ld a, (store_page+2)    ; max extents for this file 
49b4			;		ld  (store_openmaxext),a   ; get our limit 
49b4			; 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LOE" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			; 
49b4			;; TODO dont know why max extents are not present 
49b4			;;		cp 0 
49b4			;;		jp z, .loadeof     ; dont read past eof 
49b4			; 
49b4			;;		ld a, 1   ; start from the head of the file 
49b4			; 
49b4			;.loadline:	pop hl 
49b4			;		inc hl 
49b4			;		ld  a, (store_openmaxext)   ; get our limit 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LOx" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;		inc a 
49b4			;		cp l 
49b4			;		jp z, .loadeof 
49b4			;		push hl    ; save current extent 
49b4			; 
49b4			;		ld de, store_page 
49b4			; 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LO1" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;		call storage_read 
49b4			; 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LO2" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;	call ishlzero 
49b4			;	ld a, l 
49b4			;	add h 
49b4			;	cp 0 
49b4			;	jr z, .loadeof 
49b4			; 
49b4			;	; not eof so hl should point to data to exec 
49b4			; 
49b4			;	; will need to add the FORTH_END_BUFFER flag 
49b4			 ; 
49b4			;	ld hl, store_page+2 
49b4			;	ld bc, 255 
49b4			;	ld a, 0 
49b4			;	cpir 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LOt" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;	dec hl 
49b4			;	ld a, ' ' 
49b4			;	ld (hl), a 
49b4			;	inc hl 
49b4			;	ld (hl), a 
49b4			;	inc hl 
49b4			;	ld (hl), a 
49b4			;	inc hl 
49b4			;	ld a, FORTH_END_BUFFER 
49b4			;	ld (hl), a 
49b4			; 
49b4			;	; TODO handle more than a single block read 
49b4			; 
49b4			; 
49b4			;	ld hl, store_page+2 
49b4			; 
49b4			;	ld (os_tok_ptr), hl 
49b4			; 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LO3" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			; 
49b4			;	call forthparse 
49b4			;	call forthexec 
49b4			;	call forthexec_cleanup 
49b4			; 
49b4			;	; go to next extent 
49b4			; 
49b4			;	; get next block  or mark as eof 
49b4			;	jp .loadline 
49b4			; 
49b4			; 
49b4			; 
49b4			;	       NEXTW 
49b4			;.loadeof:	ld a, 0 
49b4			;		ld (store_openext), a 
49b4			; 
49b4			;	if DEBUG_STORESE 
49b4			;		DMARK "LOF" 
49b4			;		CALLMONITOR 
49b4			;	endif 
49b4			;		ret 
49b4			;		;NEXTW 
49b4			;.BSAVE:   
49b4			; 
49b4			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
49b4			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
49b4			;		NEXTW 
49b4			;.BLOAD: 
49b4			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
49b4			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
49b4			;		NEXTW 
49b4			;;;; counter gap 
49b4			 
49b4			 
49b4			.SEO: 
49b4				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
49b4 64				db WORD_SYS_CORE+80             
49b5 d3 49			dw .SEI            
49b7 04				db 3 + 1 
49b8 .. 00			db "SEO",0              
49bc				endm 
# End of macro CWHEAD
49bc			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
49bc			 
49bc					; get port 
49bc			 
49bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49bc cd a0 1e			call macro_dsp_valuehl 
49bf				endm 
# End of macro FORTH_DSP_VALUEHL
49bf			 
49bf e5					push hl    ; u2 - byte 
49c0			 
49c0					; destroy value TOS 
49c0			 
49c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49c0 cd 58 1f			call macro_forth_dsp_pop 
49c3				endm 
# End of macro FORTH_DSP_POP
49c3			 
49c3					; get byte to send 
49c3			 
49c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49c3 cd a0 1e			call macro_dsp_valuehl 
49c6				endm 
# End of macro FORTH_DSP_VALUEHL
49c6			 
49c6 e5					push hl    ; u1 - addr 
49c7			 
49c7					; destroy value TOS 
49c7			 
49c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49c7 cd 58 1f			call macro_forth_dsp_pop 
49ca				endm 
# End of macro FORTH_DSP_POP
49ca			 
49ca					; one value on hl get other one back 
49ca			 
49ca d1					pop de   ; u1 - byte 
49cb			 
49cb e1					pop hl   ; u2 - addr 
49cc			 
49cc					; TODO Send SPI byte 
49cc			 
49cc			 
49cc 7b					ld a, e 
49cd cd ea 01				call se_writebyte 
49d0			 
49d0					 
49d0			 
49d0					NEXTW 
49d0 c3 12 20			jp macro_next 
49d3				endm 
# End of macro NEXTW
49d3			 
49d3			.SEI: 
49d3				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
49d3 65				db WORD_SYS_CORE+81             
49d4 ed 49			dw .SFREE            
49d6 04				db 3 + 1 
49d7 .. 00			db "SEI",0              
49db				endm 
# End of macro CWHEAD
49db			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
49db			 
49db					; get port 
49db			 
49db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
49db cd a0 1e			call macro_dsp_valuehl 
49de				endm 
# End of macro FORTH_DSP_VALUEHL
49de			 
49de			;		push hl 
49de			 
49de					; destroy value TOS 
49de			 
49de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49de cd 58 1f			call macro_forth_dsp_pop 
49e1				endm 
# End of macro FORTH_DSP_POP
49e1			 
49e1					; one value on hl get other one back 
49e1			 
49e1			;		pop hl 
49e1			 
49e1			 
49e1					; TODO Get SPI byte 
49e1			 
49e1 cd 8c 02				call se_readbyte 
49e4			 
49e4 26 00				ld h, 0 
49e6 6f					ld l, a 
49e7 cd a9 1c				call forth_push_numhl 
49ea			 
49ea					NEXTW 
49ea c3 12 20			jp macro_next 
49ed				endm 
# End of macro NEXTW
49ed			 
49ed			.SFREE: 
49ed				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
49ed 67				db WORD_SYS_CORE+83             
49ee 1c 4a			dw .SIZE            
49f0 06				db 5 + 1 
49f1 .. 00			db "FFREE",0              
49f7				endm 
# End of macro CWHEAD
49f7			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
49f7					if DEBUG_FORTH_WORDS_KEY 
49f7						DMARK "FFR" 
49f7 f5				push af  
49f8 3a 0c 4a			ld a, (.dmark)  
49fb 32 77 fb			ld (debug_mark),a  
49fe 3a 0d 4a			ld a, (.dmark+1)  
4a01 32 78 fb			ld (debug_mark+1),a  
4a04 3a 0e 4a			ld a, (.dmark+2)  
4a07 32 79 fb			ld (debug_mark+2),a  
4a0a 18 03			jr .pastdmark  
4a0c ..			.dmark: db "FFR"  
4a0f f1			.pastdmark: pop af  
4a10			endm  
# End of macro DMARK
4a10						CALLMONITOR 
4a10 cd 19 17			call break_point_state  
4a13				endm  
# End of macro CALLMONITOR
4a13					endif 
4a13			 
4a13 cd c7 06				call storage_freeblocks 
4a16			 
4a16 cd a9 1c				call forth_push_numhl 
4a19			 
4a19				       NEXTW 
4a19 c3 12 20			jp macro_next 
4a1c				endm 
# End of macro NEXTW
4a1c			.SIZE: 
4a1c				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4a1c 67				db WORD_SYS_CORE+83             
4a1d 50 4a			dw .CREATE            
4a1f 05				db 4 + 1 
4a20 .. 00			db "SIZE",0              
4a25				endm 
# End of macro CWHEAD
4a25			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4a25					if DEBUG_FORTH_WORDS_KEY 
4a25						DMARK "SIZ" 
4a25 f5				push af  
4a26 3a 3a 4a			ld a, (.dmark)  
4a29 32 77 fb			ld (debug_mark),a  
4a2c 3a 3b 4a			ld a, (.dmark+1)  
4a2f 32 78 fb			ld (debug_mark+1),a  
4a32 3a 3c 4a			ld a, (.dmark+2)  
4a35 32 79 fb			ld (debug_mark+2),a  
4a38 18 03			jr .pastdmark  
4a3a ..			.dmark: db "SIZ"  
4a3d f1			.pastdmark: pop af  
4a3e			endm  
# End of macro DMARK
4a3e						CALLMONITOR 
4a3e cd 19 17			call break_point_state  
4a41				endm  
# End of macro CALLMONITOR
4a41					endif 
4a41			 
4a41					FORTH_DSP_VALUEHL 
4a41 cd a0 1e			call macro_dsp_valuehl 
4a44				endm 
# End of macro FORTH_DSP_VALUEHL
4a44			;		push hl 
4a44					FORTH_DSP_POP 
4a44 cd 58 1f			call macro_forth_dsp_pop 
4a47				endm 
# End of macro FORTH_DSP_POP
4a47			;		pop hl 
4a47 cd 3b 03				call storage_file_size 
4a4a			 
4a4a cd a9 1c				call forth_push_numhl 
4a4d			  
4a4d			 
4a4d				       NEXTW 
4a4d c3 12 20			jp macro_next 
4a50				endm 
# End of macro NEXTW
4a50			 
4a50			.CREATE: 
4a50				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4a50 68				db WORD_SYS_CORE+84             
4a51 be 4a			dw .APPEND            
4a53 07				db 6 + 1 
4a54 .. 00			db "CREATE",0              
4a5b				endm 
# End of macro CWHEAD
4a5b			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4a5b			; | | e.g.  
4a5b			; | | TestProgram CREATE 
4a5b			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4a5b			; | |  
4a5b			; | | Max file IDs are 255. 
4a5b			; | |  
4a5b					 
4a5b					if DEBUG_FORTH_WORDS_KEY 
4a5b						DMARK "CRT" 
4a5b f5				push af  
4a5c 3a 70 4a			ld a, (.dmark)  
4a5f 32 77 fb			ld (debug_mark),a  
4a62 3a 71 4a			ld a, (.dmark+1)  
4a65 32 78 fb			ld (debug_mark+1),a  
4a68 3a 72 4a			ld a, (.dmark+2)  
4a6b 32 79 fb			ld (debug_mark+2),a  
4a6e 18 03			jr .pastdmark  
4a70 ..			.dmark: db "CRT"  
4a73 f1			.pastdmark: pop af  
4a74			endm  
# End of macro DMARK
4a74						CALLMONITOR 
4a74 cd 19 17			call break_point_state  
4a77				endm  
# End of macro CALLMONITOR
4a77					endif 
4a77			;		call storage_get_block_0 
4a77			 
4a77					; TODO pop hl 
4a77			 
4a77					;v5 FORTH_DSP_VALUE 
4a77					FORTH_DSP_VALUE 
4a77 cd 89 1e			call macro_forth_dsp_value 
4a7a				endm 
# End of macro FORTH_DSP_VALUE
4a7a			 
4a7a				if DEBUG_STORESE 
4a7a					DMARK "CR1" 
4a7a f5				push af  
4a7b 3a 8f 4a			ld a, (.dmark)  
4a7e 32 77 fb			ld (debug_mark),a  
4a81 3a 90 4a			ld a, (.dmark+1)  
4a84 32 78 fb			ld (debug_mark+1),a  
4a87 3a 91 4a			ld a, (.dmark+2)  
4a8a 32 79 fb			ld (debug_mark+2),a  
4a8d 18 03			jr .pastdmark  
4a8f ..			.dmark: db "CR1"  
4a92 f1			.pastdmark: pop af  
4a93			endm  
# End of macro DMARK
4a93					CALLMONITOR 
4a93 cd 19 17			call break_point_state  
4a96				endm  
# End of macro CALLMONITOR
4a96				endif 
4a96			;		push hl 
4a96			;		FORTH_DSP_POP 
4a96			;		pop hl 
4a96			 
4a96			;		inc hl   ; move past the type marker 
4a96			 
4a96 cd fd 06				call storage_create 
4a99			 
4a99				if DEBUG_STORESE 
4a99					DMARK "CT1" 
4a99 f5				push af  
4a9a 3a ae 4a			ld a, (.dmark)  
4a9d 32 77 fb			ld (debug_mark),a  
4aa0 3a af 4a			ld a, (.dmark+1)  
4aa3 32 78 fb			ld (debug_mark+1),a  
4aa6 3a b0 4a			ld a, (.dmark+2)  
4aa9 32 79 fb			ld (debug_mark+2),a  
4aac 18 03			jr .pastdmark  
4aae ..			.dmark: db "CT1"  
4ab1 f1			.pastdmark: pop af  
4ab2			endm  
# End of macro DMARK
4ab2					CALLMONITOR 
4ab2 cd 19 17			call break_point_state  
4ab5				endm  
# End of macro CALLMONITOR
4ab5				endif 
4ab5			;		push hl 
4ab5					FORTH_DSP_POP 
4ab5 cd 58 1f			call macro_forth_dsp_pop 
4ab8				endm 
# End of macro FORTH_DSP_POP
4ab8			;		pop hl 
4ab8					; push file id to stack 
4ab8 cd a9 1c				call forth_push_numhl 
4abb			 
4abb			 
4abb			 
4abb				       NEXTW 
4abb c3 12 20			jp macro_next 
4abe				endm 
# End of macro NEXTW
4abe			 
4abe			.APPEND: 
4abe				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4abe 69				db WORD_SYS_CORE+85             
4abf 4f 4b			dw .SDEL            
4ac1 07				db 6 + 1 
4ac2 .. 00			db "APPEND",0              
4ac9				endm 
# End of macro CWHEAD
4ac9			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4ac9			; | | e.g. 
4ac9			; | | Test CREATE      -> $01 
4ac9			; | | "A string to add to file" $01 APPEND 
4ac9			; | |  
4ac9			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4ac9					if DEBUG_FORTH_WORDS_KEY 
4ac9						DMARK "APP" 
4ac9 f5				push af  
4aca 3a de 4a			ld a, (.dmark)  
4acd 32 77 fb			ld (debug_mark),a  
4ad0 3a df 4a			ld a, (.dmark+1)  
4ad3 32 78 fb			ld (debug_mark+1),a  
4ad6 3a e0 4a			ld a, (.dmark+2)  
4ad9 32 79 fb			ld (debug_mark+2),a  
4adc 18 03			jr .pastdmark  
4ade ..			.dmark: db "APP"  
4ae1 f1			.pastdmark: pop af  
4ae2			endm  
# End of macro DMARK
4ae2						CALLMONITOR 
4ae2 cd 19 17			call break_point_state  
4ae5				endm  
# End of macro CALLMONITOR
4ae5					endif 
4ae5			 
4ae5					FORTH_DSP_VALUEHL 
4ae5 cd a0 1e			call macro_dsp_valuehl 
4ae8				endm 
# End of macro FORTH_DSP_VALUEHL
4ae8 e5					push hl 	; save file id 
4ae9			 
4ae9				if DEBUG_STORESE 
4ae9					DMARK "AP1" 
4ae9 f5				push af  
4aea 3a fe 4a			ld a, (.dmark)  
4aed 32 77 fb			ld (debug_mark),a  
4af0 3a ff 4a			ld a, (.dmark+1)  
4af3 32 78 fb			ld (debug_mark+1),a  
4af6 3a 00 4b			ld a, (.dmark+2)  
4af9 32 79 fb			ld (debug_mark+2),a  
4afc 18 03			jr .pastdmark  
4afe ..			.dmark: db "AP1"  
4b01 f1			.pastdmark: pop af  
4b02			endm  
# End of macro DMARK
4b02					CALLMONITOR 
4b02 cd 19 17			call break_point_state  
4b05				endm  
# End of macro CALLMONITOR
4b05				endif 
4b05					FORTH_DSP_POP 
4b05 cd 58 1f			call macro_forth_dsp_pop 
4b08				endm 
# End of macro FORTH_DSP_POP
4b08			 
4b08					FORTH_DSP_VALUEHL 
4b08 cd a0 1e			call macro_dsp_valuehl 
4b0b				endm 
# End of macro FORTH_DSP_VALUEHL
4b0b					;v5 FORTH_DSP_VALUE 
4b0b e5					push hl 	; save ptr to string to save 
4b0c			 
4b0c				if DEBUG_STORESE 
4b0c					DMARK "AP1" 
4b0c f5				push af  
4b0d 3a 21 4b			ld a, (.dmark)  
4b10 32 77 fb			ld (debug_mark),a  
4b13 3a 22 4b			ld a, (.dmark+1)  
4b16 32 78 fb			ld (debug_mark+1),a  
4b19 3a 23 4b			ld a, (.dmark+2)  
4b1c 32 79 fb			ld (debug_mark+2),a  
4b1f 18 03			jr .pastdmark  
4b21 ..			.dmark: db "AP1"  
4b24 f1			.pastdmark: pop af  
4b25			endm  
# End of macro DMARK
4b25					CALLMONITOR 
4b25 cd 19 17			call break_point_state  
4b28				endm  
# End of macro CALLMONITOR
4b28				endif 
4b28					FORTH_DSP_POP 
4b28 cd 58 1f			call macro_forth_dsp_pop 
4b2b				endm 
# End of macro FORTH_DSP_POP
4b2b			 
4b2b d1					pop de 
4b2c e1					pop hl 
4b2d				if DEBUG_STORESE 
4b2d					DMARK "AP2" 
4b2d f5				push af  
4b2e 3a 42 4b			ld a, (.dmark)  
4b31 32 77 fb			ld (debug_mark),a  
4b34 3a 43 4b			ld a, (.dmark+1)  
4b37 32 78 fb			ld (debug_mark+1),a  
4b3a 3a 44 4b			ld a, (.dmark+2)  
4b3d 32 79 fb			ld (debug_mark+2),a  
4b40 18 03			jr .pastdmark  
4b42 ..			.dmark: db "AP2"  
4b45 f1			.pastdmark: pop af  
4b46			endm  
# End of macro DMARK
4b46					CALLMONITOR 
4b46 cd 19 17			call break_point_state  
4b49				endm  
# End of macro CALLMONITOR
4b49				endif 
4b49					;inc de ; skip var type indicator 
4b49			 
4b49					; TODO how to append numerics???? 
4b49			 
4b49 cd d7 08				call storage_append		 
4b4c			 
4b4c				       NEXTW 
4b4c c3 12 20			jp macro_next 
4b4f				endm 
# End of macro NEXTW
4b4f			.SDEL: 
4b4f				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4b4f 6a				db WORD_SYS_CORE+86             
4b50 9b 4b			dw .OPEN            
4b52 05				db 4 + 1 
4b53 .. 00			db "ERA",0              
4b57				endm 
# End of macro CWHEAD
4b57			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4b57					FORTH_DSP_VALUEHL 
4b57 cd a0 1e			call macro_dsp_valuehl 
4b5a				endm 
# End of macro FORTH_DSP_VALUEHL
4b5a			;		push hl 	; save file id 
4b5a			 
4b5a					if DEBUG_FORTH_WORDS_KEY 
4b5a						DMARK "ERA" 
4b5a f5				push af  
4b5b 3a 6f 4b			ld a, (.dmark)  
4b5e 32 77 fb			ld (debug_mark),a  
4b61 3a 70 4b			ld a, (.dmark+1)  
4b64 32 78 fb			ld (debug_mark+1),a  
4b67 3a 71 4b			ld a, (.dmark+2)  
4b6a 32 79 fb			ld (debug_mark+2),a  
4b6d 18 03			jr .pastdmark  
4b6f ..			.dmark: db "ERA"  
4b72 f1			.pastdmark: pop af  
4b73			endm  
# End of macro DMARK
4b73						CALLMONITOR 
4b73 cd 19 17			call break_point_state  
4b76				endm  
# End of macro CALLMONITOR
4b76					endif 
4b76				if DEBUG_STORESE 
4b76					DMARK "ER1" 
4b76 f5				push af  
4b77 3a 8b 4b			ld a, (.dmark)  
4b7a 32 77 fb			ld (debug_mark),a  
4b7d 3a 8c 4b			ld a, (.dmark+1)  
4b80 32 78 fb			ld (debug_mark+1),a  
4b83 3a 8d 4b			ld a, (.dmark+2)  
4b86 32 79 fb			ld (debug_mark+2),a  
4b89 18 03			jr .pastdmark  
4b8b ..			.dmark: db "ER1"  
4b8e f1			.pastdmark: pop af  
4b8f			endm  
# End of macro DMARK
4b8f					CALLMONITOR 
4b8f cd 19 17			call break_point_state  
4b92				endm  
# End of macro CALLMONITOR
4b92				endif 
4b92					FORTH_DSP_POP 
4b92 cd 58 1f			call macro_forth_dsp_pop 
4b95				endm 
# End of macro FORTH_DSP_POP
4b95			 
4b95			;		pop hl 
4b95			 
4b95 cd 4c 05				call storage_erase 
4b98				       NEXTW 
4b98 c3 12 20			jp macro_next 
4b9b				endm 
# End of macro NEXTW
4b9b			 
4b9b			.OPEN: 
4b9b				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4b9b 6b				db WORD_SYS_CORE+87             
4b9c 22 4c			dw .READ            
4b9e 05				db 4 + 1 
4b9f .. 00			db "OPEN",0              
4ba4				endm 
# End of macro CWHEAD
4ba4			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4ba4			; | | e.g. 
4ba4			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ba4			 
4ba4					if DEBUG_FORTH_WORDS_KEY 
4ba4						DMARK "OPN" 
4ba4 f5				push af  
4ba5 3a b9 4b			ld a, (.dmark)  
4ba8 32 77 fb			ld (debug_mark),a  
4bab 3a ba 4b			ld a, (.dmark+1)  
4bae 32 78 fb			ld (debug_mark+1),a  
4bb1 3a bb 4b			ld a, (.dmark+2)  
4bb4 32 79 fb			ld (debug_mark+2),a  
4bb7 18 03			jr .pastdmark  
4bb9 ..			.dmark: db "OPN"  
4bbc f1			.pastdmark: pop af  
4bbd			endm  
# End of macro DMARK
4bbd						CALLMONITOR 
4bbd cd 19 17			call break_point_state  
4bc0				endm  
# End of macro CALLMONITOR
4bc0					endif 
4bc0					; TODO handle multiple file opens 
4bc0			 
4bc0 3e 01			       	ld a, 1 
4bc2 32 59 f8				ld (store_openext), a 
4bc5			 
4bc5					; get max extents for this file 
4bc5				 
4bc5								 
4bc5					FORTH_DSP_VALUEHL 
4bc5 cd a0 1e			call macro_dsp_valuehl 
4bc8				endm 
# End of macro FORTH_DSP_VALUEHL
4bc8			 
4bc8 65					ld h, l 
4bc9 2e 00				ld l, 0 
4bcb			 
4bcb				if DEBUG_STORESE 
4bcb					DMARK "OPN" 
4bcb f5				push af  
4bcc 3a e0 4b			ld a, (.dmark)  
4bcf 32 77 fb			ld (debug_mark),a  
4bd2 3a e1 4b			ld a, (.dmark+1)  
4bd5 32 78 fb			ld (debug_mark+1),a  
4bd8 3a e2 4b			ld a, (.dmark+2)  
4bdb 32 79 fb			ld (debug_mark+2),a  
4bde 18 03			jr .pastdmark  
4be0 ..			.dmark: db "OPN"  
4be3 f1			.pastdmark: pop af  
4be4			endm  
# End of macro DMARK
4be4					CALLMONITOR 
4be4 cd 19 17			call break_point_state  
4be7				endm  
# End of macro CALLMONITOR
4be7				endif 
4be7			;		push hl 
4be7					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4be7 cd 58 1f			call macro_forth_dsp_pop 
4bea				endm 
# End of macro FORTH_DSP_POP
4bea			;		pop hl 
4bea						 
4bea 11 62 f8				ld de, store_page      ; get block zero of file 
4bed cd 51 08				call storage_read 
4bf0			 
4bf0			 
4bf0 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4bf3 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4bf6					 
4bf6				if DEBUG_STORESE 
4bf6					DMARK "OPx" 
4bf6 f5				push af  
4bf7 3a 0b 4c			ld a, (.dmark)  
4bfa 32 77 fb			ld (debug_mark),a  
4bfd 3a 0c 4c			ld a, (.dmark+1)  
4c00 32 78 fb			ld (debug_mark+1),a  
4c03 3a 0d 4c			ld a, (.dmark+2)  
4c06 32 79 fb			ld (debug_mark+2),a  
4c09 18 03			jr .pastdmark  
4c0b ..			.dmark: db "OPx"  
4c0e f1			.pastdmark: pop af  
4c0f			endm  
# End of macro DMARK
4c0f					CALLMONITOR 
4c0f cd 19 17			call break_point_state  
4c12				endm  
# End of macro CALLMONITOR
4c12				endif 
4c12 fe 00				cp 0 
4c14 20 03				jr nz, .skipopeneof 
4c16					; have opened an empty file 
4c16					 
4c16 32 59 f8				ld (store_openext), a 
4c19			 
4c19			.skipopeneof: 
4c19			 
4c19 6f					ld l, a 
4c1a 26 00				ld h, 0 
4c1c cd a9 1c				call forth_push_numhl 
4c1f			 
4c1f			 
4c1f				       NEXTW 
4c1f c3 12 20			jp macro_next 
4c22				endm 
# End of macro NEXTW
4c22			.READ: 
4c22				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4c22 6c				db WORD_SYS_CORE+88             
4c23 69 4d			dw .EOF            
4c25 05				db 4 + 1 
4c26 .. 00			db "READ",0              
4c2b				endm 
# End of macro CWHEAD
4c2b			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4c2b			; | | e.g. 
4c2b			; | | $01 OPEN $01 DO $01 READ . LOOP 
4c2b			 
4c2b					if DEBUG_FORTH_WORDS_KEY 
4c2b						DMARK "REA" 
4c2b f5				push af  
4c2c 3a 40 4c			ld a, (.dmark)  
4c2f 32 77 fb			ld (debug_mark),a  
4c32 3a 41 4c			ld a, (.dmark+1)  
4c35 32 78 fb			ld (debug_mark+1),a  
4c38 3a 42 4c			ld a, (.dmark+2)  
4c3b 32 79 fb			ld (debug_mark+2),a  
4c3e 18 03			jr .pastdmark  
4c40 ..			.dmark: db "REA"  
4c43 f1			.pastdmark: pop af  
4c44			endm  
# End of macro DMARK
4c44						CALLMONITOR 
4c44 cd 19 17			call break_point_state  
4c47				endm  
# End of macro CALLMONITOR
4c47					endif 
4c47					; store_openext use it. If zero it is EOF 
4c47			 
4c47					; read block from current stream id 
4c47					; if the block does not contain zero term keep reading blocks until zero found 
4c47					; push the block to stack 
4c47					; save the block id to stream 
4c47			 
4c47			 
4c47					FORTH_DSP_VALUEHL 
4c47 cd a0 1e			call macro_dsp_valuehl 
4c4a				endm 
# End of macro FORTH_DSP_VALUEHL
4c4a			 
4c4a			;		push hl 
4c4a			 
4c4a				if DEBUG_STORESE 
4c4a					DMARK "REA" 
4c4a f5				push af  
4c4b 3a 5f 4c			ld a, (.dmark)  
4c4e 32 77 fb			ld (debug_mark),a  
4c51 3a 60 4c			ld a, (.dmark+1)  
4c54 32 78 fb			ld (debug_mark+1),a  
4c57 3a 61 4c			ld a, (.dmark+2)  
4c5a 32 79 fb			ld (debug_mark+2),a  
4c5d 18 03			jr .pastdmark  
4c5f ..			.dmark: db "REA"  
4c62 f1			.pastdmark: pop af  
4c63			endm  
# End of macro DMARK
4c63					CALLMONITOR 
4c63 cd 19 17			call break_point_state  
4c66				endm  
# End of macro CALLMONITOR
4c66				endif 
4c66					FORTH_DSP_POP 
4c66 cd 58 1f			call macro_forth_dsp_pop 
4c69				endm 
# End of macro FORTH_DSP_POP
4c69			 
4c69			;		pop hl 
4c69				 
4c69 65					ld h,l 
4c6a			 
4c6a 3a 59 f8				ld a, (store_openext) 
4c6d 6f					ld l, a 
4c6e					 
4c6e fe 00				cp 0 
4c70 ca 3b 4d				jp z, .ateof     ; dont read past eof 
4c73			 
4c73			 
4c73 11 62 f8				ld de, store_page 
4c76				if DEBUG_STORESE 
4c76					DMARK "RE1" 
4c76 f5				push af  
4c77 3a 8b 4c			ld a, (.dmark)  
4c7a 32 77 fb			ld (debug_mark),a  
4c7d 3a 8c 4c			ld a, (.dmark+1)  
4c80 32 78 fb			ld (debug_mark+1),a  
4c83 3a 8d 4c			ld a, (.dmark+2)  
4c86 32 79 fb			ld (debug_mark+2),a  
4c89 18 03			jr .pastdmark  
4c8b ..			.dmark: db "RE1"  
4c8e f1			.pastdmark: pop af  
4c8f			endm  
# End of macro DMARK
4c8f					CALLMONITOR 
4c8f cd 19 17			call break_point_state  
4c92				endm  
# End of macro CALLMONITOR
4c92				endif 
4c92 cd 51 08				call storage_read 
4c95			 
4c95				if DEBUG_STORESE 
4c95					DMARK "RE2" 
4c95 f5				push af  
4c96 3a aa 4c			ld a, (.dmark)  
4c99 32 77 fb			ld (debug_mark),a  
4c9c 3a ab 4c			ld a, (.dmark+1)  
4c9f 32 78 fb			ld (debug_mark+1),a  
4ca2 3a ac 4c			ld a, (.dmark+2)  
4ca5 32 79 fb			ld (debug_mark+2),a  
4ca8 18 03			jr .pastdmark  
4caa ..			.dmark: db "RE2"  
4cad f1			.pastdmark: pop af  
4cae			endm  
# End of macro DMARK
4cae					CALLMONITOR 
4cae cd 19 17			call break_point_state  
4cb1				endm  
# End of macro CALLMONITOR
4cb1				endif 
4cb1 cd 32 0d			call ishlzero 
4cb4			;	ld a, l 
4cb4			;	add h 
4cb4			;	cp 0 
4cb4 ca 41 4d			jp z, .readeof 
4cb7			 
4cb7				; not eof so hl should point to data to push to stack 
4cb7			 
4cb7				if DEBUG_STORESE 
4cb7					DMARK "RE3" 
4cb7 f5				push af  
4cb8 3a cc 4c			ld a, (.dmark)  
4cbb 32 77 fb			ld (debug_mark),a  
4cbe 3a cd 4c			ld a, (.dmark+1)  
4cc1 32 78 fb			ld (debug_mark+1),a  
4cc4 3a ce 4c			ld a, (.dmark+2)  
4cc7 32 79 fb			ld (debug_mark+2),a  
4cca 18 03			jr .pastdmark  
4ccc ..			.dmark: db "RE3"  
4ccf f1			.pastdmark: pop af  
4cd0			endm  
# End of macro DMARK
4cd0					CALLMONITOR 
4cd0 cd 19 17			call break_point_state  
4cd3				endm  
# End of macro CALLMONITOR
4cd3				endif 
4cd3 cd 17 1d			call forth_push_str 
4cd6			 
4cd6				if DEBUG_STORESE 
4cd6					DMARK "RE4" 
4cd6 f5				push af  
4cd7 3a eb 4c			ld a, (.dmark)  
4cda 32 77 fb			ld (debug_mark),a  
4cdd 3a ec 4c			ld a, (.dmark+1)  
4ce0 32 78 fb			ld (debug_mark+1),a  
4ce3 3a ed 4c			ld a, (.dmark+2)  
4ce6 32 79 fb			ld (debug_mark+2),a  
4ce9 18 03			jr .pastdmark  
4ceb ..			.dmark: db "RE4"  
4cee f1			.pastdmark: pop af  
4cef			endm  
# End of macro DMARK
4cef					CALLMONITOR 
4cef cd 19 17			call break_point_state  
4cf2				endm  
# End of macro CALLMONITOR
4cf2				endif 
4cf2				; get next block  or mark as eof 
4cf2			 
4cf2 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4cf5 4f				ld c, a	 
4cf6 3a 59 f8			ld a, (store_openext) 
4cf9			 
4cf9				if DEBUG_STORESE 
4cf9					DMARK "RE5" 
4cf9 f5				push af  
4cfa 3a 0e 4d			ld a, (.dmark)  
4cfd 32 77 fb			ld (debug_mark),a  
4d00 3a 0f 4d			ld a, (.dmark+1)  
4d03 32 78 fb			ld (debug_mark+1),a  
4d06 3a 10 4d			ld a, (.dmark+2)  
4d09 32 79 fb			ld (debug_mark+2),a  
4d0c 18 03			jr .pastdmark  
4d0e ..			.dmark: db "RE5"  
4d11 f1			.pastdmark: pop af  
4d12			endm  
# End of macro DMARK
4d12					CALLMONITOR 
4d12 cd 19 17			call break_point_state  
4d15				endm  
# End of macro CALLMONITOR
4d15				endif 
4d15 b9				cp c 
4d16 28 29			jr z, .readeof     ; at last extent 
4d18			 
4d18 3c					inc a 
4d19 32 59 f8				ld (store_openext), a 
4d1c			 
4d1c				if DEBUG_STORESE 
4d1c					DMARK "RE6" 
4d1c f5				push af  
4d1d 3a 31 4d			ld a, (.dmark)  
4d20 32 77 fb			ld (debug_mark),a  
4d23 3a 32 4d			ld a, (.dmark+1)  
4d26 32 78 fb			ld (debug_mark+1),a  
4d29 3a 33 4d			ld a, (.dmark+2)  
4d2c 32 79 fb			ld (debug_mark+2),a  
4d2f 18 03			jr .pastdmark  
4d31 ..			.dmark: db "RE6"  
4d34 f1			.pastdmark: pop af  
4d35			endm  
# End of macro DMARK
4d35					CALLMONITOR 
4d35 cd 19 17			call break_point_state  
4d38				endm  
# End of macro CALLMONITOR
4d38				endif 
4d38			 
4d38			 
4d38				       NEXTW 
4d38 c3 12 20			jp macro_next 
4d3b				endm 
# End of macro NEXTW
4d3b			.ateof: 
4d3b 21 65 4d				ld hl, .showeof 
4d3e cd 17 1d				call forth_push_str 
4d41 3e 00		.readeof:	ld a, 0 
4d43 32 59 f8				ld (store_openext), a 
4d46			 
4d46					 
4d46				if DEBUG_STORESE 
4d46					DMARK "REF" 
4d46 f5				push af  
4d47 3a 5b 4d			ld a, (.dmark)  
4d4a 32 77 fb			ld (debug_mark),a  
4d4d 3a 5c 4d			ld a, (.dmark+1)  
4d50 32 78 fb			ld (debug_mark+1),a  
4d53 3a 5d 4d			ld a, (.dmark+2)  
4d56 32 79 fb			ld (debug_mark+2),a  
4d59 18 03			jr .pastdmark  
4d5b ..			.dmark: db "REF"  
4d5e f1			.pastdmark: pop af  
4d5f			endm  
# End of macro DMARK
4d5f					CALLMONITOR 
4d5f cd 19 17			call break_point_state  
4d62				endm  
# End of macro CALLMONITOR
4d62				endif 
4d62				       NEXTW 
4d62 c3 12 20			jp macro_next 
4d65				endm 
# End of macro NEXTW
4d65			 
4d65 .. 00		.showeof:   db "eof", 0 
4d69			 
4d69			 
4d69			.EOF: 
4d69				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4d69 6d				db WORD_SYS_CORE+89             
4d6a aa 4d			dw .FORMAT            
4d6c 04				db 3 + 1 
4d6d .. 00			db "EOF",0              
4d71				endm 
# End of macro CWHEAD
4d71			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4d71			; | | e.g. 
4d71			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4d71					; TODO if current block id for stream is zero then push true else false 
4d71			 
4d71					if DEBUG_FORTH_WORDS_KEY 
4d71						DMARK "EOF" 
4d71 f5				push af  
4d72 3a 86 4d			ld a, (.dmark)  
4d75 32 77 fb			ld (debug_mark),a  
4d78 3a 87 4d			ld a, (.dmark+1)  
4d7b 32 78 fb			ld (debug_mark+1),a  
4d7e 3a 88 4d			ld a, (.dmark+2)  
4d81 32 79 fb			ld (debug_mark+2),a  
4d84 18 03			jr .pastdmark  
4d86 ..			.dmark: db "EOF"  
4d89 f1			.pastdmark: pop af  
4d8a			endm  
# End of macro DMARK
4d8a						CALLMONITOR 
4d8a cd 19 17			call break_point_state  
4d8d				endm  
# End of macro CALLMONITOR
4d8d					endif 
4d8d			 
4d8d					; TODO handlue multiple file streams 
4d8d			 
4d8d					FORTH_DSP_POP     ; for now just get rid of stream id 
4d8d cd 58 1f			call macro_forth_dsp_pop 
4d90				endm 
# End of macro FORTH_DSP_POP
4d90			 
4d90 2e 01				ld l, 1 
4d92 3a 58 f8				ld a, (store_openmaxext) 
4d95 fe 00				cp 0 
4d97 28 09				jr  z, .eofdone   ; empty file 
4d99 3a 59 f8				ld a, (store_openext) 
4d9c fe 00				cp 0 
4d9e 28 02				jr  z, .eofdone 
4da0 2e 00				ld l, 0 
4da2 26 00		.eofdone:	ld h, 0 
4da4 cd a9 1c				call forth_push_numhl 
4da7			 
4da7			 
4da7				       NEXTW 
4da7 c3 12 20			jp macro_next 
4daa				endm 
# End of macro NEXTW
4daa			 
4daa			.FORMAT: 
4daa				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4daa 6d				db WORD_SYS_CORE+89             
4dab fb 4d			dw .LABEL            
4dad 07				db 6 + 1 
4dae .. 00			db "FORMAT",0              
4db5				endm 
# End of macro CWHEAD
4db5			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4db5					; TODO if current block id for stream is zero then push true else false 
4db5				 
4db5				if DEBUG_STORESE 
4db5					DMARK "FOR" 
4db5 f5				push af  
4db6 3a ca 4d			ld a, (.dmark)  
4db9 32 77 fb			ld (debug_mark),a  
4dbc 3a cb 4d			ld a, (.dmark+1)  
4dbf 32 78 fb			ld (debug_mark+1),a  
4dc2 3a cc 4d			ld a, (.dmark+2)  
4dc5 32 79 fb			ld (debug_mark+2),a  
4dc8 18 03			jr .pastdmark  
4dca ..			.dmark: db "FOR"  
4dcd f1			.pastdmark: pop af  
4dce			endm  
# End of macro DMARK
4dce					CALLMONITOR 
4dce cd 19 17			call break_point_state  
4dd1				endm  
# End of macro CALLMONITOR
4dd1				endif 
4dd1					; Wipes the bank check flags to cause a reformat on next block 0 read 
4dd1			 
4dd1 21 01 00				ld hl, 1 
4dd4 3e 00				ld a, 0 
4dd6 cd ea 01				call se_writebyte 
4dd9			 
4dd9				if DEBUG_STORESE 
4dd9					DMARK "FO0" 
4dd9 f5				push af  
4dda 3a ee 4d			ld a, (.dmark)  
4ddd 32 77 fb			ld (debug_mark),a  
4de0 3a ef 4d			ld a, (.dmark+1)  
4de3 32 78 fb			ld (debug_mark+1),a  
4de6 3a f0 4d			ld a, (.dmark+2)  
4de9 32 79 fb			ld (debug_mark+2),a  
4dec 18 03			jr .pastdmark  
4dee ..			.dmark: db "FO0"  
4df1 f1			.pastdmark: pop af  
4df2			endm  
# End of macro DMARK
4df2					CALLMONITOR 
4df2 cd 19 17			call break_point_state  
4df5				endm  
# End of macro CALLMONITOR
4df5				endif 
4df5					; force bank init 
4df5			 
4df5 cd bd 03				call storage_get_block_0 
4df8					 
4df8				       NEXTW 
4df8 c3 12 20			jp macro_next 
4dfb				endm 
# End of macro NEXTW
4dfb			.LABEL: 
4dfb				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4dfb 6d				db WORD_SYS_CORE+89             
4dfc 49 4e			dw .STOREPAGE            
4dfe 06				db 5 + 1 
4dff .. 00			db "LABEL",0              
4e05				endm 
# End of macro CWHEAD
4e05			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4e05					; TODO test to see if bank is selected 
4e05				 
4e05					if DEBUG_FORTH_WORDS_KEY 
4e05						DMARK "LBL" 
4e05 f5				push af  
4e06 3a 1a 4e			ld a, (.dmark)  
4e09 32 77 fb			ld (debug_mark),a  
4e0c 3a 1b 4e			ld a, (.dmark+1)  
4e0f 32 78 fb			ld (debug_mark+1),a  
4e12 3a 1c 4e			ld a, (.dmark+2)  
4e15 32 79 fb			ld (debug_mark+2),a  
4e18 18 03			jr .pastdmark  
4e1a ..			.dmark: db "LBL"  
4e1d f1			.pastdmark: pop af  
4e1e			endm  
# End of macro DMARK
4e1e						CALLMONITOR 
4e1e cd 19 17			call break_point_state  
4e21				endm  
# End of macro CALLMONITOR
4e21					endif 
4e21			;	if DEBUG_STORESE 
4e21			;		DMARK "LBL" 
4e21			;		CALLMONITOR 
4e21			;	endif 
4e21					FORTH_DSP_VALUEHL 
4e21 cd a0 1e			call macro_dsp_valuehl 
4e24				endm 
# End of macro FORTH_DSP_VALUEHL
4e24					;v5FORTH_DSP_VALUE 
4e24					 
4e24			;		push hl 
4e24					FORTH_DSP_POP 
4e24 cd 58 1f			call macro_forth_dsp_pop 
4e27				endm 
# End of macro FORTH_DSP_POP
4e27			;		pop hl 
4e27			 
4e27			;v5		inc hl   ; move past the type marker 
4e27			 
4e27				if DEBUG_STORESE 
4e27					DMARK "LBl" 
4e27 f5				push af  
4e28 3a 3c 4e			ld a, (.dmark)  
4e2b 32 77 fb			ld (debug_mark),a  
4e2e 3a 3d 4e			ld a, (.dmark+1)  
4e31 32 78 fb			ld (debug_mark+1),a  
4e34 3a 3e 4e			ld a, (.dmark+2)  
4e37 32 79 fb			ld (debug_mark+2),a  
4e3a 18 03			jr .pastdmark  
4e3c ..			.dmark: db "LBl"  
4e3f f1			.pastdmark: pop af  
4e40			endm  
# End of macro DMARK
4e40					CALLMONITOR 
4e40 cd 19 17			call break_point_state  
4e43				endm  
# End of macro CALLMONITOR
4e43				endif 
4e43 cd e1 04				call storage_label 
4e46			 
4e46				       NEXTW 
4e46 c3 12 20			jp macro_next 
4e49				endm 
# End of macro NEXTW
4e49			.STOREPAGE: 
4e49				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4e49 6d				db WORD_SYS_CORE+89             
4e4a 7c 4e			dw .LABELS            
4e4c 0a				db 9 + 1 
4e4d .. 00			db "STOREPAGE",0              
4e57				endm 
# End of macro CWHEAD
4e57			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4e57					; TODO test to see if bank is selected 
4e57				 
4e57					if DEBUG_FORTH_WORDS_KEY 
4e57						DMARK "STP" 
4e57 f5				push af  
4e58 3a 6c 4e			ld a, (.dmark)  
4e5b 32 77 fb			ld (debug_mark),a  
4e5e 3a 6d 4e			ld a, (.dmark+1)  
4e61 32 78 fb			ld (debug_mark+1),a  
4e64 3a 6e 4e			ld a, (.dmark+2)  
4e67 32 79 fb			ld (debug_mark+2),a  
4e6a 18 03			jr .pastdmark  
4e6c ..			.dmark: db "STP"  
4e6f f1			.pastdmark: pop af  
4e70			endm  
# End of macro DMARK
4e70						CALLMONITOR 
4e70 cd 19 17			call break_point_state  
4e73				endm  
# End of macro CALLMONITOR
4e73					endif 
4e73			;	if DEBUG_STORESE 
4e73			;		DMARK "STP" 
4e73			;		CALLMONITOR 
4e73			;	endif 
4e73			 
4e73 21 62 f8			ld hl, store_page 
4e76 cd a9 1c			call forth_push_numhl 
4e79			 
4e79			 
4e79				       NEXTW 
4e79 c3 12 20			jp macro_next 
4e7c				endm 
# End of macro NEXTW
4e7c			.LABELS: 
4e7c				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4e7c 6d				db WORD_SYS_CORE+89             
4e7d 06 4f			dw .ENDSTORAGE            
4e7f 07				db 6 + 1 
4e80 .. 00			db "LABELS",0              
4e87				endm 
# End of macro CWHEAD
4e87			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4e87					;  
4e87			 
4e87					; save the current device selected to restore afterwards 
4e87				 
4e87 3a 48 f8				ld a, (spi_device) 
4e8a f5					push af 
4e8b			 
4e8b			 
4e8b					; run through each of the banks 
4e8b			 
4e8b 21 01 00				ld hl, 1 
4e8e cd a9 1c				call forth_push_numhl 
4e91 3e ff				ld a, SPI_CE_HIGH 
4e93 cb 87				res SPI_CE0, a 
4e95 32 48 f8				ld (spi_device), a 
4e98 cd bd 03				call storage_get_block_0 
4e9b 21 65 f8				ld hl, store_page+3 
4e9e cd 17 1d				call forth_push_str 
4ea1			 
4ea1					 
4ea1 21 02 00				ld hl, 2 
4ea4 cd a9 1c				call forth_push_numhl 
4ea7 3e ff				ld a, SPI_CE_HIGH 
4ea9 cb 8f				res SPI_CE1, a 
4eab 32 48 f8				ld (spi_device), a 
4eae cd bd 03				call storage_get_block_0 
4eb1 21 65 f8				ld hl, store_page+3 
4eb4 cd 17 1d				call forth_push_str 
4eb7			 
4eb7					 
4eb7 21 03 00				ld hl, 3 
4eba cd a9 1c				call forth_push_numhl 
4ebd 3e ff				ld a, SPI_CE_HIGH 
4ebf cb 97				res SPI_CE2, a 
4ec1 32 48 f8				ld (spi_device), a 
4ec4 cd bd 03				call storage_get_block_0 
4ec7 21 65 f8				ld hl, store_page+3 
4eca cd 17 1d				call forth_push_str 
4ecd			 
4ecd			 
4ecd 21 04 00				ld hl, 4 
4ed0 cd a9 1c				call forth_push_numhl 
4ed3 3e ff				ld a, SPI_CE_HIGH 
4ed5 cb 9f				res SPI_CE3, a 
4ed7 32 48 f8				ld (spi_device), a 
4eda cd bd 03				call storage_get_block_0 
4edd 21 65 f8				ld hl, store_page+3 
4ee0 cd 17 1d				call forth_push_str 
4ee3			 
4ee3					 
4ee3			 
4ee3 21 05 00				ld hl, 5 
4ee6 cd a9 1c				call forth_push_numhl 
4ee9 3e ff				ld a, SPI_CE_HIGH 
4eeb cb a7				res SPI_CE4, a 
4eed 32 48 f8				ld (spi_device), a 
4ef0 cd bd 03				call storage_get_block_0 
4ef3 21 65 f8				ld hl, store_page+3 
4ef6 cd 17 1d				call forth_push_str 
4ef9			 
4ef9					 
4ef9					; push fixed count of storage devices (on board) for now 
4ef9			 
4ef9 21 05 00				ld hl, 5 
4efc cd a9 1c				call forth_push_numhl 
4eff			 
4eff					; restore selected device  
4eff				 
4eff f1					pop af 
4f00 32 48 f8				ld (spi_device), a 
4f03			 
4f03				       NEXTW 
4f03 c3 12 20			jp macro_next 
4f06				endm 
# End of macro NEXTW
4f06			 
4f06			.ENDSTORAGE: 
4f06			; eof 
# End of file forth_words_storage.asm
4f06			endif 
4f06				include "forth_words_device.asm" 
4f06			; Device related words 
4f06			 
4f06			; | ## Device Words 
4f06			 
4f06			if SOUND_ENABLE 
4f06			.NOTE: 
4f06				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4f06 33				db WORD_SYS_CORE+31             
4f07 2e 4f			dw .AFTERSOUND            
4f09 05				db 4 + 1 
4f0a .. 00			db "NOTE",0              
4f0f				endm 
# End of macro CWHEAD
4f0f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4f0f					if DEBUG_FORTH_WORDS_KEY 
4f0f						DMARK "NTE" 
4f0f f5				push af  
4f10 3a 24 4f			ld a, (.dmark)  
4f13 32 77 fb			ld (debug_mark),a  
4f16 3a 25 4f			ld a, (.dmark+1)  
4f19 32 78 fb			ld (debug_mark+1),a  
4f1c 3a 26 4f			ld a, (.dmark+2)  
4f1f 32 79 fb			ld (debug_mark+2),a  
4f22 18 03			jr .pastdmark  
4f24 ..			.dmark: db "NTE"  
4f27 f1			.pastdmark: pop af  
4f28			endm  
# End of macro DMARK
4f28						CALLMONITOR 
4f28 cd 19 17			call break_point_state  
4f2b				endm  
# End of macro CALLMONITOR
4f2b					endif 
4f2b			 
4f2b				 
4f2b			 
4f2b					NEXTW 
4f2b c3 12 20			jp macro_next 
4f2e				endm 
# End of macro NEXTW
4f2e			.AFTERSOUND: 
4f2e			endif 
4f2e			 
4f2e			 
4f2e			USE_GPIO: equ 0 
4f2e			 
4f2e			if USE_GPIO 
4f2e			.GP1: 
4f2e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4f2e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4f2e					NEXTW 
4f2e			.GP2: 
4f2e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4f2e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4f2e			 
4f2e					NEXTW 
4f2e			 
4f2e			.GP3: 
4f2e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4f2e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4f2e			 
4f2e					NEXTW 
4f2e			 
4f2e			.GP4: 
4f2e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4f2e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4f2e			 
4f2e					NEXTW 
4f2e			.SIN: 
4f2e			 
4f2e			 
4f2e			endif 
4f2e			 
4f2e			 
4f2e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4f2e 33				db WORD_SYS_CORE+31             
4f2f 63 4f			dw .SOUT            
4f31 03				db 2 + 1 
4f32 .. 00			db "IN",0              
4f35				endm 
# End of macro CWHEAD
4f35			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4f35					if DEBUG_FORTH_WORDS_KEY 
4f35						DMARK "IN." 
4f35 f5				push af  
4f36 3a 4a 4f			ld a, (.dmark)  
4f39 32 77 fb			ld (debug_mark),a  
4f3c 3a 4b 4f			ld a, (.dmark+1)  
4f3f 32 78 fb			ld (debug_mark+1),a  
4f42 3a 4c 4f			ld a, (.dmark+2)  
4f45 32 79 fb			ld (debug_mark+2),a  
4f48 18 03			jr .pastdmark  
4f4a ..			.dmark: db "IN."  
4f4d f1			.pastdmark: pop af  
4f4e			endm  
# End of macro DMARK
4f4e						CALLMONITOR 
4f4e cd 19 17			call break_point_state  
4f51				endm  
# End of macro CALLMONITOR
4f51					endif 
4f51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f51 cd a0 1e			call macro_dsp_valuehl 
4f54				endm 
# End of macro FORTH_DSP_VALUEHL
4f54			 
4f54 e5					push hl 
4f55			 
4f55					; destroy value TOS 
4f55			 
4f55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f55 cd 58 1f			call macro_forth_dsp_pop 
4f58				endm 
# End of macro FORTH_DSP_POP
4f58			 
4f58					; one value on hl get other one back 
4f58			 
4f58 c1					pop bc 
4f59			 
4f59					; do the sub 
4f59			;		ex de, hl 
4f59			 
4f59 ed 68				in l,(c) 
4f5b			 
4f5b					; save it 
4f5b			 
4f5b 26 00				ld h,0 
4f5d			 
4f5d					; TODO push value back onto stack for another op etc 
4f5d			 
4f5d cd a9 1c				call forth_push_numhl 
4f60					NEXTW 
4f60 c3 12 20			jp macro_next 
4f63				endm 
# End of macro NEXTW
4f63			.SOUT: 
4f63				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4f63 34				db WORD_SYS_CORE+32             
4f64 b6 4f			dw .SPIO            
4f66 04				db 3 + 1 
4f67 .. 00			db "OUT",0              
4f6b				endm 
# End of macro CWHEAD
4f6b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4f6b					if DEBUG_FORTH_WORDS_KEY 
4f6b						DMARK "OUT" 
4f6b f5				push af  
4f6c 3a 80 4f			ld a, (.dmark)  
4f6f 32 77 fb			ld (debug_mark),a  
4f72 3a 81 4f			ld a, (.dmark+1)  
4f75 32 78 fb			ld (debug_mark+1),a  
4f78 3a 82 4f			ld a, (.dmark+2)  
4f7b 32 79 fb			ld (debug_mark+2),a  
4f7e 18 03			jr .pastdmark  
4f80 ..			.dmark: db "OUT"  
4f83 f1			.pastdmark: pop af  
4f84			endm  
# End of macro DMARK
4f84						CALLMONITOR 
4f84 cd 19 17			call break_point_state  
4f87				endm  
# End of macro CALLMONITOR
4f87					endif 
4f87			 
4f87					; get port 
4f87			 
4f87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f87 cd a0 1e			call macro_dsp_valuehl 
4f8a				endm 
# End of macro FORTH_DSP_VALUEHL
4f8a			 
4f8a e5					push hl 
4f8b			 
4f8b					; destroy value TOS 
4f8b			 
4f8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f8b cd 58 1f			call macro_forth_dsp_pop 
4f8e				endm 
# End of macro FORTH_DSP_POP
4f8e			 
4f8e					; get byte to send 
4f8e			 
4f8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f8e cd a0 1e			call macro_dsp_valuehl 
4f91				endm 
# End of macro FORTH_DSP_VALUEHL
4f91			 
4f91			;		push hl 
4f91			 
4f91					; destroy value TOS 
4f91			 
4f91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f91 cd 58 1f			call macro_forth_dsp_pop 
4f94				endm 
# End of macro FORTH_DSP_POP
4f94			 
4f94					; one value on hl get other one back 
4f94			 
4f94			;		pop hl 
4f94			 
4f94 c1					pop bc 
4f95			 
4f95					if DEBUG_FORTH_WORDS 
4f95						DMARK "OUT" 
4f95 f5				push af  
4f96 3a aa 4f			ld a, (.dmark)  
4f99 32 77 fb			ld (debug_mark),a  
4f9c 3a ab 4f			ld a, (.dmark+1)  
4f9f 32 78 fb			ld (debug_mark+1),a  
4fa2 3a ac 4f			ld a, (.dmark+2)  
4fa5 32 79 fb			ld (debug_mark+2),a  
4fa8 18 03			jr .pastdmark  
4faa ..			.dmark: db "OUT"  
4fad f1			.pastdmark: pop af  
4fae			endm  
# End of macro DMARK
4fae						CALLMONITOR 
4fae cd 19 17			call break_point_state  
4fb1				endm  
# End of macro CALLMONITOR
4fb1					endif 
4fb1			 
4fb1 ed 69				out (c), l 
4fb3			 
4fb3					NEXTW 
4fb3 c3 12 20			jp macro_next 
4fb6				endm 
# End of macro NEXTW
4fb6			 
4fb6			 
4fb6			.SPIO: 
4fb6			 
4fb6			if STORAGE_SE 
4fb6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4fb6 51				db WORD_SYS_CORE+61             
4fb7 c7 4f			dw .SPICEH            
4fb9 07				db 6 + 1 
4fba .. 00			db "SPICEL",0              
4fc1				endm 
# End of macro CWHEAD
4fc1			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4fc1			 
4fc1 cd 98 01				call spi_ce_low 
4fc4			    NEXTW 
4fc4 c3 12 20			jp macro_next 
4fc7				endm 
# End of macro NEXTW
4fc7			 
4fc7			.SPICEH: 
4fc7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4fc7 51				db WORD_SYS_CORE+61             
4fc8 d8 4f			dw .SPIOb            
4fca 07				db 6 + 1 
4fcb .. 00			db "SPICEH",0              
4fd2				endm 
# End of macro CWHEAD
4fd2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4fd2			 
4fd2 cd 87 01				call spi_ce_high 
4fd5			    NEXTW 
4fd5 c3 12 20			jp macro_next 
4fd8				endm 
# End of macro NEXTW
4fd8			 
4fd8			 
4fd8			.SPIOb: 
4fd8			 
4fd8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4fd8 51				db WORD_SYS_CORE+61             
4fd9 ee 4f			dw .SPII            
4fdb 05				db 4 + 1 
4fdc .. 00			db "SPIO",0              
4fe1				endm 
# End of macro CWHEAD
4fe1			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4fe1			 
4fe1					; get port 
4fe1			 
4fe1			 
4fe1					; get byte to send 
4fe1			 
4fe1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fe1 cd a0 1e			call macro_dsp_valuehl 
4fe4				endm 
# End of macro FORTH_DSP_VALUEHL
4fe4			 
4fe4			;		push hl    ; u1  
4fe4			 
4fe4					; destroy value TOS 
4fe4			 
4fe4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fe4 cd 58 1f			call macro_forth_dsp_pop 
4fe7				endm 
# End of macro FORTH_DSP_POP
4fe7			 
4fe7					; one value on hl get other one back 
4fe7			 
4fe7			;		pop hl   ; u2 - addr 
4fe7			 
4fe7					; TODO Send SPI byte 
4fe7			 
4fe7 7d					ld a, l 
4fe8 cd bc 00				call spi_send_byte 
4feb			 
4feb					NEXTW 
4feb c3 12 20			jp macro_next 
4fee				endm 
# End of macro NEXTW
4fee			 
4fee			.SPII: 
4fee				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4fee 52				db WORD_SYS_CORE+62             
4fef 03 50			dw .SESEL            
4ff1 06				db 5 + 1 
4ff2 .. 00			db "SPII",0              
4ff7				endm 
# End of macro CWHEAD
4ff7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ff7			 
4ff7					; TODO Get SPI byte 
4ff7			 
4ff7 cd dd 00				call spi_read_byte 
4ffa			 
4ffa 26 00				ld h, 0 
4ffc 6f					ld l, a 
4ffd cd a9 1c				call forth_push_numhl 
5000			 
5000					NEXTW 
5000 c3 12 20			jp macro_next 
5003				endm 
# End of macro NEXTW
5003			 
5003			 
5003			 
5003			.SESEL: 
5003				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5003 66				db WORD_SYS_CORE+82             
5004 a7 50			dw .CARTDEV            
5006 05				db 4 + 1 
5007 .. 00			db "BANK",0              
500c				endm 
# End of macro CWHEAD
500c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
500c					if DEBUG_FORTH_WORDS_KEY 
500c						DMARK "BNK" 
500c f5				push af  
500d 3a 21 50			ld a, (.dmark)  
5010 32 77 fb			ld (debug_mark),a  
5013 3a 22 50			ld a, (.dmark+1)  
5016 32 78 fb			ld (debug_mark+1),a  
5019 3a 23 50			ld a, (.dmark+2)  
501c 32 79 fb			ld (debug_mark+2),a  
501f 18 03			jr .pastdmark  
5021 ..			.dmark: db "BNK"  
5024 f1			.pastdmark: pop af  
5025			endm  
# End of macro DMARK
5025						CALLMONITOR 
5025 cd 19 17			call break_point_state  
5028				endm  
# End of macro CALLMONITOR
5028					endif 
5028			 
5028 3e ff				ld a, 255 
502a 32 4b f8				ld (spi_cartdev), a 
502d			 
502d					; get bank 
502d			 
502d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
502d cd a0 1e			call macro_dsp_valuehl 
5030				endm 
# End of macro FORTH_DSP_VALUEHL
5030			 
5030			;		push hl 
5030			 
5030					; destroy value TOS 
5030			 
5030					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5030 cd 58 1f			call macro_forth_dsp_pop 
5033				endm 
# End of macro FORTH_DSP_POP
5033			 
5033					; one value on hl get other one back 
5033			 
5033			;		pop hl 
5033			 
5033			 
5033 0e ff				ld c, SPI_CE_HIGH 
5035 06 30				ld b, '0'    ; human readable bank number 
5037			 
5037 7d					ld a, l 
5038			 
5038					if DEBUG_FORTH_WORDS 
5038						DMARK "BNK" 
5038 f5				push af  
5039 3a 4d 50			ld a, (.dmark)  
503c 32 77 fb			ld (debug_mark),a  
503f 3a 4e 50			ld a, (.dmark+1)  
5042 32 78 fb			ld (debug_mark+1),a  
5045 3a 4f 50			ld a, (.dmark+2)  
5048 32 79 fb			ld (debug_mark+2),a  
504b 18 03			jr .pastdmark  
504d ..			.dmark: db "BNK"  
5050 f1			.pastdmark: pop af  
5051			endm  
# End of macro DMARK
5051						CALLMONITOR 
5051 cd 19 17			call break_point_state  
5054				endm  
# End of macro CALLMONITOR
5054					endif 
5054			 
5054					; active low 
5054			 
5054 fe 00				cp 0 
5056 28 28				jr z, .bset 
5058 fe 01				cp 1 
505a 20 04				jr nz, .b2 
505c cb 81				res 0, c 
505e 06 31				ld b, '1'    ; human readable bank number 
5060 fe 02		.b2:		cp 2 
5062 20 04				jr nz, .b3 
5064 cb 89				res 1, c 
5066 06 32				ld b, '2'    ; human readable bank number 
5068 fe 03		.b3:		cp 3 
506a 20 04				jr nz, .b4 
506c cb 91				res 2, c 
506e 06 33				ld b, '3'    ; human readable bank number 
5070 fe 04		.b4:		cp 4 
5072 20 04				jr nz, .b5 
5074 cb 99				res 3, c 
5076 06 34				ld b, '4'    ; human readable bank number 
5078 fe 05		.b5:		cp 5 
507a 20 04				jr nz, .bset 
507c cb a1				res 4, c 
507e 06 35				ld b, '5'    ; human readable bank number 
5080			 
5080			.bset: 
5080 79					ld a, c 
5081 32 48 f8				ld (spi_device),a 
5084 78					ld a, b 
5085 32 47 f8				ld (spi_device_id),a 
5088					if DEBUG_FORTH_WORDS 
5088						DMARK "BN2" 
5088 f5				push af  
5089 3a 9d 50			ld a, (.dmark)  
508c 32 77 fb			ld (debug_mark),a  
508f 3a 9e 50			ld a, (.dmark+1)  
5092 32 78 fb			ld (debug_mark+1),a  
5095 3a 9f 50			ld a, (.dmark+2)  
5098 32 79 fb			ld (debug_mark+2),a  
509b 18 03			jr .pastdmark  
509d ..			.dmark: db "BN2"  
50a0 f1			.pastdmark: pop af  
50a1			endm  
# End of macro DMARK
50a1						CALLMONITOR 
50a1 cd 19 17			call break_point_state  
50a4				endm  
# End of macro CALLMONITOR
50a4					endif 
50a4			 
50a4					NEXTW 
50a4 c3 12 20			jp macro_next 
50a7				endm 
# End of macro NEXTW
50a7			 
50a7			.CARTDEV: 
50a7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
50a7 66				db WORD_SYS_CORE+82             
50a8 50 51			dw .ENDDEVICE            
50aa 08				db 7 + 1 
50ab .. 00			db "CARTDEV",0              
50b3				endm 
# End of macro CWHEAD
50b3			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
50b3					if DEBUG_FORTH_WORDS_KEY 
50b3						DMARK "CDV" 
50b3 f5				push af  
50b4 3a c8 50			ld a, (.dmark)  
50b7 32 77 fb			ld (debug_mark),a  
50ba 3a c9 50			ld a, (.dmark+1)  
50bd 32 78 fb			ld (debug_mark+1),a  
50c0 3a ca 50			ld a, (.dmark+2)  
50c3 32 79 fb			ld (debug_mark+2),a  
50c6 18 03			jr .pastdmark  
50c8 ..			.dmark: db "CDV"  
50cb f1			.pastdmark: pop af  
50cc			endm  
# End of macro DMARK
50cc						CALLMONITOR 
50cc cd 19 17			call break_point_state  
50cf				endm  
# End of macro CALLMONITOR
50cf					endif 
50cf			 
50cf					; disable se storage bank selection 
50cf			 
50cf 3e ff				ld a, SPI_CE_HIGH		; ce high 
50d1 32 48 f8				ld (spi_device), a 
50d4			 
50d4					; get bank 
50d4			 
50d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d4 cd a0 1e			call macro_dsp_valuehl 
50d7				endm 
# End of macro FORTH_DSP_VALUEHL
50d7			 
50d7			;		push hl 
50d7			 
50d7					; destroy value TOS 
50d7			 
50d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50d7 cd 58 1f			call macro_forth_dsp_pop 
50da				endm 
# End of macro FORTH_DSP_POP
50da			 
50da					; one value on hl get other one back 
50da			 
50da			;		pop hl 
50da			 
50da					; active low 
50da			 
50da 0e ff				ld c, 255 
50dc			 
50dc 7d					ld a, l 
50dd					if DEBUG_FORTH_WORDS 
50dd						DMARK "CDV" 
50dd f5				push af  
50de 3a f2 50			ld a, (.dmark)  
50e1 32 77 fb			ld (debug_mark),a  
50e4 3a f3 50			ld a, (.dmark+1)  
50e7 32 78 fb			ld (debug_mark+1),a  
50ea 3a f4 50			ld a, (.dmark+2)  
50ed 32 79 fb			ld (debug_mark+2),a  
50f0 18 03			jr .pastdmark  
50f2 ..			.dmark: db "CDV"  
50f5 f1			.pastdmark: pop af  
50f6			endm  
# End of macro DMARK
50f6						CALLMONITOR 
50f6 cd 19 17			call break_point_state  
50f9				endm  
# End of macro CALLMONITOR
50f9					endif 
50f9 fe 00				cp 0 
50fb 28 30				jr z, .cset 
50fd fe 01				cp 1 
50ff 20 02				jr nz, .c2 
5101 cb 81				res 0, c 
5103 fe 02		.c2:		cp 2 
5105 20 02				jr nz, .c3 
5107 cb 89				res 1, c 
5109 fe 03		.c3:		cp 3 
510b 20 02				jr nz, .c4 
510d cb 91				res 2, c 
510f fe 04		.c4:		cp 4 
5111 20 02				jr nz, .c5 
5113 cb 99				res 3, c 
5115 fe 05		.c5:		cp 5 
5117 20 02				jr nz, .c6 
5119 cb a1				res 4, c 
511b fe 06		.c6:		cp 6 
511d 20 02				jr nz, .c7 
511f cb a9				res 5, c 
5121 fe 07		.c7:		cp 7 
5123 20 02				jr nz, .c8 
5125 cb b1				res 6, c 
5127 fe 08		.c8:		cp 8 
5129 20 02				jr nz, .cset 
512b cb b9				res 7, c 
512d 79			.cset:		ld a, c 
512e 32 4b f8				ld (spi_cartdev),a 
5131			 
5131					if DEBUG_FORTH_WORDS 
5131						DMARK "CD2" 
5131 f5				push af  
5132 3a 46 51			ld a, (.dmark)  
5135 32 77 fb			ld (debug_mark),a  
5138 3a 47 51			ld a, (.dmark+1)  
513b 32 78 fb			ld (debug_mark+1),a  
513e 3a 48 51			ld a, (.dmark+2)  
5141 32 79 fb			ld (debug_mark+2),a  
5144 18 03			jr .pastdmark  
5146 ..			.dmark: db "CD2"  
5149 f1			.pastdmark: pop af  
514a			endm  
# End of macro DMARK
514a						CALLMONITOR 
514a cd 19 17			call break_point_state  
514d				endm  
# End of macro CALLMONITOR
514d					endif 
514d					NEXTW 
514d c3 12 20			jp macro_next 
5150				endm 
# End of macro NEXTW
5150			endif 
5150			 
5150			.ENDDEVICE: 
5150			; eof 
5150			 
# End of file forth_words_device.asm
5150			 
5150			; var handler 
5150			 
5150			 
5150			.VARS: 
5150				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5150 78				db WORD_SYS_CORE+100             
5151 68 51			dw .V0Q            
5153 04				db 3 + 1 
5154 .. 00			db "V0!",0              
5158				endm 
# End of macro CWHEAD
5158			;| V0! ( u1 -- )  Store value to v0  | DONE 
5158			 
5158					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5158 cd a0 1e			call macro_dsp_valuehl 
515b				endm 
# End of macro FORTH_DSP_VALUEHL
515b			 
515b 11 10 f8				ld de, cli_var_array 
515e			 
515e eb					ex de, hl 
515f 73					ld (hl), e 
5160 23					inc hl 
5161 72					ld (hl), d 
5162			 
5162					; destroy value TOS 
5162			 
5162					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5162 cd 58 1f			call macro_forth_dsp_pop 
5165				endm 
# End of macro FORTH_DSP_POP
5165			 
5165				       NEXTW 
5165 c3 12 20			jp macro_next 
5168				endm 
# End of macro NEXTW
5168			.V0Q: 
5168				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5168 79				db WORD_SYS_CORE+101             
5169 79 51			dw .V1S            
516b 04				db 3 + 1 
516c .. 00			db "V0@",0              
5170				endm 
# End of macro CWHEAD
5170			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5170 2a 10 f8				ld hl, (cli_var_array) 
5173 cd a9 1c				call forth_push_numhl 
5176			 
5176				       NEXTW 
5176 c3 12 20			jp macro_next 
5179				endm 
# End of macro NEXTW
5179			.V1S: 
5179				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5179 7a				db WORD_SYS_CORE+102             
517a 91 51			dw .V1Q            
517c 04				db 3 + 1 
517d .. 00			db "V1!",0              
5181				endm 
# End of macro CWHEAD
5181			;| V1! ( u1 -- )  Store value to v1 | DONE 
5181					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5181 cd a0 1e			call macro_dsp_valuehl 
5184				endm 
# End of macro FORTH_DSP_VALUEHL
5184			 
5184 11 12 f8				ld de, cli_var_array+2 
5187				 
5187 eb					ex de, hl 
5188 73					ld (hl), e 
5189 23					inc hl 
518a 72					ld (hl), d 
518b			 
518b					; destroy value TOS 
518b			 
518b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
518b cd 58 1f			call macro_forth_dsp_pop 
518e				endm 
# End of macro FORTH_DSP_POP
518e				       NEXTW 
518e c3 12 20			jp macro_next 
5191				endm 
# End of macro NEXTW
5191			.V1Q: 
5191				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5191 7b				db WORD_SYS_CORE+103             
5192 a2 51			dw .V2S            
5194 04				db 3 + 1 
5195 .. 00			db "V1@",0              
5199				endm 
# End of macro CWHEAD
5199			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5199 2a 12 f8				ld hl, (cli_var_array+2) 
519c cd a9 1c				call forth_push_numhl 
519f				       NEXTW 
519f c3 12 20			jp macro_next 
51a2				endm 
# End of macro NEXTW
51a2			.V2S: 
51a2				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
51a2 7c				db WORD_SYS_CORE+104             
51a3 ba 51			dw .V2Q            
51a5 04				db 3 + 1 
51a6 .. 00			db "V2!",0              
51aa				endm 
# End of macro CWHEAD
51aa			;| V2! ( u1 -- )  Store value to v2 | DONE 
51aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51aa cd a0 1e			call macro_dsp_valuehl 
51ad				endm 
# End of macro FORTH_DSP_VALUEHL
51ad			 
51ad 11 14 f8				ld de, cli_var_array+4 
51b0				 
51b0 eb					ex de, hl 
51b1 73					ld (hl), e 
51b2 23					inc hl 
51b3 72					ld (hl), d 
51b4			 
51b4					; destroy value TOS 
51b4			 
51b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51b4 cd 58 1f			call macro_forth_dsp_pop 
51b7				endm 
# End of macro FORTH_DSP_POP
51b7				       NEXTW 
51b7 c3 12 20			jp macro_next 
51ba				endm 
# End of macro NEXTW
51ba			.V2Q: 
51ba				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
51ba 7d				db WORD_SYS_CORE+105             
51bb cb 51			dw .V3S            
51bd 04				db 3 + 1 
51be .. 00			db "V2@",0              
51c2				endm 
# End of macro CWHEAD
51c2			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
51c2 2a 14 f8				ld hl, (cli_var_array+4) 
51c5 cd a9 1c				call forth_push_numhl 
51c8				       NEXTW 
51c8 c3 12 20			jp macro_next 
51cb				endm 
# End of macro NEXTW
51cb			.V3S: 
51cb				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
51cb 7c				db WORD_SYS_CORE+104             
51cc e3 51			dw .V3Q            
51ce 04				db 3 + 1 
51cf .. 00			db "V3!",0              
51d3				endm 
# End of macro CWHEAD
51d3			;| V3! ( u1 -- )  Store value to v3 | DONE 
51d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51d3 cd a0 1e			call macro_dsp_valuehl 
51d6				endm 
# End of macro FORTH_DSP_VALUEHL
51d6			 
51d6 11 16 f8				ld de, cli_var_array+6 
51d9				 
51d9 eb					ex de, hl 
51da 73					ld (hl), e 
51db 23					inc hl 
51dc 72					ld (hl), d 
51dd			 
51dd					; destroy value TOS 
51dd			 
51dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51dd cd 58 1f			call macro_forth_dsp_pop 
51e0				endm 
# End of macro FORTH_DSP_POP
51e0				       NEXTW 
51e0 c3 12 20			jp macro_next 
51e3				endm 
# End of macro NEXTW
51e3			.V3Q: 
51e3				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
51e3 7d				db WORD_SYS_CORE+105             
51e4 f4 51			dw .END            
51e6 04				db 3 + 1 
51e7 .. 00			db "V3@",0              
51eb				endm 
# End of macro CWHEAD
51eb			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
51eb 2a 16 f8				ld hl, (cli_var_array+6) 
51ee cd a9 1c				call forth_push_numhl 
51f1				       NEXTW 
51f1 c3 12 20			jp macro_next 
51f4				endm 
# End of macro NEXTW
51f4			 
51f4			 
51f4			 
51f4			 
51f4			 
51f4			; end of dict marker 
51f4			 
51f4 00			.END:    db WORD_SYS_END 
51f5 00 00			dw 0 
51f7 00				db 0 
51f8			 
51f8			; use to jp here for user dict words to save on macro expansion  
51f8			 
51f8			user_dict_next: 
51f8				NEXTW 
51f8 c3 12 20			jp macro_next 
51fb				endm 
# End of macro NEXTW
51fb			 
51fb			 
51fb			user_exec: 
51fb				;    ld hl, <word code> 
51fb				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
51fb				;    call forthexec 
51fb				;    jp user_dict_next   (NEXT) 
51fb			        ;    <word code bytes> 
51fb eb				ex de, hl 
51fc 2a 1e f1			ld hl,(os_tok_ptr) 
51ff				 
51ff				FORTH_RSP_NEXT 
51ff cd 50 1c			call macro_forth_rsp_next 
5202				endm 
# End of macro FORTH_RSP_NEXT
5202			 
5202			if DEBUG_FORTH_UWORD 
5202						DMARK "UEX" 
5202 f5				push af  
5203 3a 17 52			ld a, (.dmark)  
5206 32 77 fb			ld (debug_mark),a  
5209 3a 18 52			ld a, (.dmark+1)  
520c 32 78 fb			ld (debug_mark+1),a  
520f 3a 19 52			ld a, (.dmark+2)  
5212 32 79 fb			ld (debug_mark+2),a  
5215 18 03			jr .pastdmark  
5217 ..			.dmark: db "UEX"  
521a f1			.pastdmark: pop af  
521b			endm  
# End of macro DMARK
521b				CALLMONITOR 
521b cd 19 17			call break_point_state  
521e				endm  
# End of macro CALLMONITOR
521e			endif 
521e			 
521e			 
521e			 
521e eb				ex de, hl 
521f 22 1e f1			ld (os_tok_ptr), hl 
5222				 
5222				; Don't use next - Skips the first word in uword. 
5222			 
5222 c3 a3 20			jp exec1 
5225			;	NEXT 
5225			 
5225			 
5225			; eof 
# End of file forth_wordsv4.asm
5225			endif 
5225			;;;;;;;;;;;;;; Debug code 
5225			 
5225			 
5225			;if DEBUG_FORTH_PARSE 
5225 .. 00		.nowordfound: db "No match",0 
522e .. 00		.compword:	db "Comparing word ",0 
523e .. 00		.nextwordat:	db "Next word at",0 
524b .. 00		.charmatch:	db "Char match",0 
5256			;endif 
5256			if DEBUG_FORTH_JP 
5256			.foundword:	db "Word match. Exec..",0 
5256			endif 
5256			;if DEBUG_FORTH_PUSH 
5256 .. 00		.enddict:	db "Dict end. Push.",0 
5266 .. 00		.push_str:	db "Pushing string",0 
5275 .. 00		.push_num:	db "Pushing number",0 
5284 .. 00		.data_sp:	db "SP:",0 
5288 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
529a .. 00		.wordinde:	db "Word in DE (3/0):",0 
52ac .. 00		.wordinbc:	db "Word in BC (4/0):",0 
52be			;endif 
52be			;if DEBUG_FORTH_MALLOC 
52be .. 00		.push_malloc:	db "Malloc address",0 
52cd			;endif 
52cd			 
52cd			 
52cd			 
52cd			; display malloc address and current data stack pointer  
52cd			 
52cd			malloc_error: 
52cd d5				push de 
52ce f5				push af 
52cf e5				push hl 
52d0 cd d5 0a			call clear_display 
52d3 11 f5 52			ld de, .mallocerr 
52d6 3e 00			ld a,0 
52d8			;	ld de,os_word_scratch 
52d8 cd e8 0a			call str_at_display 
52db 3e 11			ld a, display_row_1+17 
52dd 11 77 fb			ld de, debug_mark 
52e0 cd e8 0a			call str_at_display 
52e3 cd f8 0a			call update_display 
52e6				;call break_point_state 
52e6 cd ef 69			call cin_wait 
52e9			 
52e9 3e 20			ld a, ' ' 
52eb 32 0e ee			ld (os_view_disable), a 
52ee e1				pop hl 
52ef f1				pop af 
52f0 d1				pop de	 
52f1				CALLMONITOR 
52f1 cd 19 17			call break_point_state  
52f4				endm  
# End of macro CALLMONITOR
52f4 c9				ret 
52f5			 
52f5 .. 00		.mallocerr: 	db "Malloc Error",0 
5302			;if DEBUG_FORTH_PUSH 
5302			display_data_sp: 
5302 f5				push af 
5303			 
5303				; see if disabled 
5303			 
5303 3a 0e ee			ld a, (os_view_disable) 
5306 fe 2a			cp '*' 
5308 28 67			jr z, .skipdsp 
530a			 
530a e5				push hl 
530b e5				push hl 
530c e5			push hl 
530d cd d5 0a			call clear_display 
5310 e1			pop hl 
5311 7c				ld a,h 
5312 21 22 f1			ld hl, os_word_scratch 
5315 cd 0a 10			call hexout 
5318 e1				pop hl 
5319 7d				ld a,l 
531a 21 24 f1			ld hl, os_word_scratch+2 
531d cd 0a 10			call hexout 
5320 21 26 f1			ld hl, os_word_scratch+4 
5323 3e 00			ld a,0 
5325 77				ld (hl),a 
5326 11 22 f1			ld de,os_word_scratch 
5329 3e 28				ld a, display_row_2 
532b cd e8 0a				call str_at_display 
532e 11 88 52			ld de, .wordinhl 
5331 3e 00			ld a, display_row_1 
5333			 
5333 cd e8 0a				call str_at_display 
5336 11 77 fb			ld de, debug_mark 
5339 3e 11			ld a, display_row_1+17 
533b			 
533b cd e8 0a				call str_at_display 
533e			 
533e				; display current data stack pointer 
533e 11 84 52			ld de,.data_sp 
5341 3e 30				ld a, display_row_2 + 8 
5343 cd e8 0a				call str_at_display 
5346			 
5346 2a 0a f8			ld hl,(cli_data_sp) 
5349 e5				push hl 
534a 7c				ld a,h 
534b 21 22 f1			ld hl, os_word_scratch 
534e cd 0a 10			call hexout 
5351 e1				pop hl 
5352 7d				ld a,l 
5353 21 24 f1			ld hl, os_word_scratch+2 
5356 cd 0a 10			call hexout 
5359 21 26 f1			ld hl, os_word_scratch+4 
535c 3e 00			ld a,0 
535e 77				ld (hl),a 
535f 11 22 f1			ld de,os_word_scratch 
5362 3e 33				ld a, display_row_2 + 11 
5364 cd e8 0a				call str_at_display 
5367			 
5367			 
5367 cd f8 0a			call update_display 
536a cd 55 0a			call delay1s 
536d cd 55 0a			call delay1s 
5370 e1				pop hl 
5371			.skipdsp: 
5371 f1				pop af 
5372 c9				ret 
5373			 
5373			display_data_malloc: 
5373			 
5373 f5				push af 
5374 e5				push hl 
5375 e5				push hl 
5376 e5			push hl 
5377 cd d5 0a			call clear_display 
537a e1			pop hl 
537b 7c				ld a,h 
537c 21 22 f1			ld hl, os_word_scratch 
537f cd 0a 10			call hexout 
5382 e1				pop hl 
5383 7d				ld a,l 
5384 21 24 f1			ld hl, os_word_scratch+2 
5387 cd 0a 10			call hexout 
538a 21 26 f1			ld hl, os_word_scratch+4 
538d 3e 00			ld a,0 
538f 77				ld (hl),a 
5390 11 22 f1			ld de,os_word_scratch 
5393 3e 28				ld a, display_row_2 
5395 cd e8 0a				call str_at_display 
5398 11 be 52			ld de, .push_malloc 
539b 3e 00			ld a, display_row_1 
539d			 
539d cd e8 0a				call str_at_display 
53a0			 
53a0				; display current data stack pointer 
53a0 11 84 52			ld de,.data_sp 
53a3 3e 30				ld a, display_row_2 + 8 
53a5 cd e8 0a				call str_at_display 
53a8			 
53a8 2a 0a f8			ld hl,(cli_data_sp) 
53ab e5				push hl 
53ac 7c				ld a,h 
53ad 21 22 f1			ld hl, os_word_scratch 
53b0 cd 0a 10			call hexout 
53b3 e1				pop hl 
53b4 7d				ld a,l 
53b5 21 24 f1			ld hl, os_word_scratch+2 
53b8 cd 0a 10			call hexout 
53bb 21 26 f1			ld hl, os_word_scratch+4 
53be 3e 00			ld a,0 
53c0 77				ld (hl),a 
53c1 11 22 f1			ld de,os_word_scratch 
53c4 3e 33				ld a, display_row_2 + 11 
53c6 cd e8 0a				call str_at_display 
53c9			 
53c9 cd f8 0a			call update_display 
53cc cd 55 0a			call delay1s 
53cf cd 55 0a			call delay1s 
53d2 e1				pop hl 
53d3 f1				pop af 
53d4 c9				ret 
53d5			;endif 
53d5			 
53d5			include "forth_autostart.asm" 
53d5			; list of commands to perform at system start up 
53d5			 
53d5			startcmds: 
53d5			;	dw test11 
53d5			;	dw test12 
53d5			;	dw test13 
53d5			;	dw test14 
53d5			;	dw test15 
53d5			;	dw test16 
53d5			;	dw test17 
53d5			;	dw ifthtest1 
53d5			;	dw ifthtest2 
53d5			;	dw ifthtest3 
53d5			;	dw mmtest1 
53d5			;	dw mmtest2 
53d5			;	dw mmtest3 
53d5			;	dw mmtest4 
53d5			;	dw mmtest5 
53d5			;	dw mmtest6 
53d5			;	dw iftest1 
53d5			;	dw iftest2 
53d5			;	dw iftest3 
53d5			;	dw looptest1 
53d5			;	dw looptest2 
53d5			;	dw test1 
53d5			;	dw test2 
53d5			;	dw test3 
53d5			;	dw test4 
53d5			;	dw game2r 
53d5			;	dw game2b1 
53d5			;	dw game2b2 
53d5			 
53d5				; start up words that are actually useful 
53d5			 
53d5 33 54			dw clrstack 
53d7 66 54			dw type 
53d9 27 56			dw stest 
53db 8a 54			dw strncpy 
53dd c8 55			dw list 
53df eb 54			dw start1 
53e1 fd 54			dw start2 
53e3			;	dw start3 
53e3 10 55			dw start3b 
53e5 68 55			dw start3c 
53e7			 
53e7				; (unit) testing words 
53e7			 
53e7 9e 56			dw mtesta 
53e9 53 57			dw mtestb 
53eb f6 57			dw mtestc 
53ed ab 58			dw mtestd 
53ef 4f 59			dw mteste 
53f1			 
53f1				; demo/game words 
53f1			 
53f1 5b 60		        dw game3w 
53f3 89 60		        dw game3p 
53f5 a7 60		        dw game3sc 
53f7 d8 60		        dw game3vsi 
53f9 04 61		        dw game3vs 
53fb				 
53fb 4e 5e			dw game2b 
53fd bc 5e			dw game2bf 
53ff 06 5f			dw game2mba 
5401 9c 5f			dw game2mbas 
5403 de 5f			dw game2mb 
5405			 
5405 0f 5b			dw game1 
5407 20 5b			dw game1a 
5409 82 5b			dw game1b 
540b b7 5b			dw game1c 
540d ed 5b			dw game1d 
540f 1e 5c			dw game1s 
5411 32 5c			dw game1t 
5413 47 5c			dw game1f 
5415 7b 5c			dw game1z 
5417 bf 5c			dw game1zz 
5419			 
5419 05 5a			dw test5 
541b 3d 5a			dw test6 
541d 75 5a			dw test7 
541f 89 5a			dw test8 
5421 b5 5a			dw test9 
5423 cb 5a			dw test10 
5425				 
5425 96 5d		        dw ssv5 
5427 7a 5d		        dw ssv4 
5429 5e 5d		        dw ssv3 
542b 28 5d		        dw ssv2 
542d af 5d		        dw ssv1 
542f f7 5d		        dw ssv1cpm 
5431			;	dw keyup 
5431			;	dw keydown 
5431			;	dw keyleft 
5431			;	dw keyright 
5431			;	dw 	keyf1 
5431			;	dw keyf2 
5431			;	dw keyf3 
5431			;	dw keyf4 
5431			;	dw keyf5 
5431			;	dw keyf6 
5431			;	dw keyf7 
5431			;	dw keyf8 
5431			;	dw keyf9 
5431			;	dw keyf10 
5431			;	dw keyf11 
5431			;	dw keyf12 
5431			;	dw keytab 
5431			;	dw keycr 
5431			;	dw keyhome 
5431			;	dw keyend 
5431			;	dw keybs 
5431 00 00			db 0, 0	 
5433			 
5433			 
5433			; clear stack  
5433			 
5433 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5466			 
5466			; type ( addr count - ) 
5466 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
548a			 
548a			; some direct memory words 
548a			; strncpy ( len t f -- t ) 
548a			 
548a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
54eb			 
54eb .. 00		start1:     	db ": bpon $0000 bp ;",0 
54fd .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5510			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5510 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5568 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
55c8			 
55c8			 
55c8			; a handy word to list items on the stack 
55c8			 
55c8 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5627			 
5627			 
5627			; test stack  
5627			; rnd8 stest 
5627			 
5627 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
569e			 
569e			; random malloc and free cycles 
569e			 
569e .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5753			 
5753			; fixed malloc and free cycles 
5753			 
5753 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
57f6			 
57f6			; fixed double string push and drop cycle  
57f6			 
57f6 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
58ab			 
58ab			; consistent fixed string push and drop cycle  
58ab			 
58ab .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
594f			 
594f .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5a05			 
5a05			;test1:		db ": aa 1 2 3 ;", 0 
5a05			;test2:     	db "111 aa 888 999",0 
5a05			;test3:     	db ": bb 77 ;",0 
5a05			;test4:     	db "$02 $01 do i . loop bb",0 
5a05			 
5a05 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5a3d .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5a75 .. 00		test7:     	db ": box hline vline ;",0 
5a89 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5ab5 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5acb .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5af0 .. 00		test11:     	db "hello create .",0 
5aff .. 00		test12:     	db "hello2 create .",0 
5b0f			 
5b0f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5b0f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5b0f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5b0f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5b0f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5b0f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5b0f			 
5b0f			;iftest1:     	db "$0001 IF cls .",0 
5b0f			;iftest2:     	db "$0000 IF cls .",0 
5b0f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5b0f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5b0f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5b0f			 
5b0f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5b0f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5b0f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5b0f			 
5b0f			 
5b0f			 
5b0f			; a small guess the number game 
5b0f			 
5b0f .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5b20 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5b82			 
5b82 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5bb7 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5bed .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5c1e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5c32 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5c47 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5c7b .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5cbf			 
5cbf			; Using 'ga' save a high score across multiple runs using external storage 
5cbf			 
5cbf .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5d28			 
5d28			 
5d28			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5d28			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5d28			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5d28			 
5d28			; simple screen saver to test code memory reuse to destruction 
5d28			 
5d28 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5d5e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5d7a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5d96 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5daf .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5df7 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5e4e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5e4e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5e4e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5e4e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5e4e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5e4e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5e4e			 
5e4e			 
5e4e			 
5e4e			; minesweeper/battleship finding game 
5e4e			; draws a game board of random ship/mine positions 
5e4e			; user enters coords to see if it hits on 
5e4e			; game ends when all are hit 
5e4e			; when hit or miss says how many may be in the area 
5e4e			 
5e4e			; setup the game board and then hide it 
5e4e .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5ebc .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5f06			; prompt for where to target 
5f06 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5f9c .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5fc1			; TODO see if the entered coords hits or misses pushes char hit of miss 
5fc1 .. 00		game2mbht:      db ": mbckht nop ;",0 
5fd0 .. 00		game2mbms:      db ": mbcms nop ;",0 
5fde			; TODO how many might be near by 
5fde .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
605b			 
605b			; Game 3 
605b			 
605b			; Vert scroller ski game - avoid the trees! 
605b			 
605b			; v0 score (ie turns) 
605b			; v1 player pos 
605b			; v2 left wall 
605b			; v3 right wall 
605b			 
605b			; Draw side walls randomly 
605b			 
605b .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6089			 
6089			; Draw player 
6089 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
60a7			 
60a7			; TODO Get Key 
60a7			 
60a7			; TODO Move left right 
60a7			 
60a7			; scroll and move walls a bit 
60a7			 
60a7 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
60d8			 
60d8			; main game loop 
60d8			 
60d8 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6104 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6143			 
6143			; key board defs 
6143			 
6143 .. 00		keyup:       db ": keyup $05 ;",0 
6151 .. 00		keydown:       db ": keydown $0a ;",0 
6161 .. 00		keyleft:       db ": keyleft $0b ;",0 
6171 .. 00		keyright:       db ": keyright $0c ;",0 
6182 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6190 .. 00		keyf2:       db ": keyf2 $11 ;",0 
619e .. 00		keyf3:       db ": keyf3 $12 ;",0 
61ac .. 00		keyf4:       db ": keyf4 $13 ;",0 
61ba .. 00		keyf5:       db ": keyf5 $14 ;",0 
61c8 .. 00		keyf6:       db ": keyf6 $15 ;",0 
61d6 .. 00		keyf7:       db ": keyf7 $16 ;",0 
61e4 .. 00		keyf8:       db ": keyf8 $17 ;",0 
61f2 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6200 .. 00		keyf10:       db ": keyf10 $19 ;",0 
620f .. 00		keyf11:       db ": keyf11 $1a ;",0 
621e .. 00		keyf12:       db ": keyf12 $1b ;",0 
622d			 
622d .. 00		keytab:       db ": keytab $09 ;",0 
623c .. 00		keycr:       db ": keycr $0d ;",0 
624a .. 00		keyhome:       db ": keyhome $0e ;",0 
625a .. 00		keyend:       db ": keyend $0f ;",0 
6269 .. 00		keybs:       db ": keybs $08 ;",0 
6277			 
6277			   
6277			 
6277			 
6277			 
6277			; eof 
# End of file forth_autostart.asm
6277			 
6277 .. 00		sprompt1: db "Startup load...",0 
6287 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
629d			 
629d			 
629d			 
629d			 
629d			forth_startup: 
629d 21 d5 53			ld hl, startcmds 
62a0 3e 00			ld a, 0 
62a2 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
62a5			 
62a5 e5			.start1:	push hl 
62a6 cd d5 0a			call clear_display 
62a9 11 77 62			ld de, sprompt1 
62ac 3e 00		        ld a, display_row_1 
62ae cd e8 0a			call str_at_display 
62b1 11 87 62			ld de, sprompt2 
62b4 3e 28		        ld a, display_row_2 
62b6 cd e8 0a			call str_at_display 
62b9 e1				pop hl 
62ba e5				push hl 
62bb 5e				ld e,(hl) 
62bc 23				inc hl 
62bd 56				ld d,(hl) 
62be 3e 50		        ld a, display_row_3 
62c0 cd e8 0a			call str_at_display 
62c3 cd f8 0a			call update_display 
62c6			 
62c6			 
62c6 3a 43 f2			ld a, (os_last_cmd) 
62c9 fe 00			cp 0 
62cb 28 05			jr z, .startprompt 
62cd cd 49 0a			call delay250ms 
62d0 18 24			jr .startdo 
62d2				 
62d2				 
62d2			 
62d2			.startprompt: 
62d2			 
62d2 3e 9f			ld a,display_row_4 + display_cols - 1 
62d4 11 1f 1c		        ld de, endprg 
62d7 cd e8 0a			call str_at_display 
62da cd f8 0a			call update_display 
62dd cd 55 0a			call delay1s 
62e0 cd ef 69			call cin_wait 
62e3						 
62e3 fe 2a			cp '*' 
62e5 28 5e			jr z, .startupend1 
62e7 fe 23			cp '#' 
62e9 20 07			jr nz, .startno 
62eb 3e 01			ld a, 1 
62ed 32 43 f2			ld (os_last_cmd),a 
62f0 18 04			jr .startdo 
62f2 fe 31		.startno:	cp '1' 
62f4 28 3a			jr z,.startnxt  
62f6			 
62f6				; exec startup line 
62f6			.startdo:	 
62f6 e1				pop hl 
62f7 e5				push hl 
62f8				 
62f8 5e				ld e,(hl) 
62f9 23				inc hl 
62fa 56				ld d,(hl) 
62fb eb				ex de,hl 
62fc			 
62fc e5				push hl 
62fd			 
62fd 3e 00			ld a, 0 
62ff				;ld a, FORTH_END_BUFFER 
62ff cd 72 11			call strlent 
6302 23				inc hl   ; include zero term to copy 
6303 06 00			ld b,0 
6305 4d				ld c,l 
6306 e1				pop hl 
6307 11 1d ee			ld de, scratch 
630a ed b0			ldir 
630c			 
630c			 
630c 21 1d ee			ld hl, scratch 
630f cd 60 20			call forthparse 
6312 cd a0 20			call forthexec 
6315 cd b7 1f			call forthexec_cleanup 
6318			 
6318 3e 78			ld a, display_row_4 
631a 11 c3 19			ld de, endprog 
631d			 
631d cd f8 0a			call update_display		 
6320			 
6320 3a 43 f2			ld a, (os_last_cmd) 
6323 fe 00			cp 0 
6325 20 09			jr nz, .startnxt 
6327 cd 21 1c			call next_page_prompt 
632a cd d5 0a		        call clear_display 
632d cd f8 0a			call update_display		 
6330			 
6330				; move onto next startup line? 
6330			.startnxt: 
6330			 
6330 cd 49 0a			call delay250ms 
6333 e1				pop hl 
6334			 
6334 23				inc hl 
6335 23				inc hl 
6336			 
6336 e5				push hl 
6337 5e				ld e, (hl) 
6338 23				inc hl 
6339 56				ld d, (hl) 
633a e1				pop hl 
633b				; TODO replace 0 test 
633b			 
633b eb				ex de, hl 
633c cd 32 0d			call ishlzero 
633f			;	ld a,e 
633f			;	add d 
633f			;	cp 0    ; any left to do? 
633f eb				ex de, hl 
6340 c2 a5 62			jp nz, .start1 
6343 18 01			jr .startupend 
6345			 
6345 e1			.startupend1: pop hl 
6346			.startupend: 
6346			 
6346 cd d5 0a			call clear_display 
6349 cd f8 0a			call update_display 
634c c9				ret 
634d			 
634d			 
634d			; stack over and underflow checks 
634d			 
634d			; init the words to detect the under/overflow 
634d			 
634d			chk_stk_init: 
634d				; a vague random number to check so we dont get any "lucky" hits 
634d 3e 2d			ld a, 45 
634f 6f				ld l, a 
6350 00				nop 
6351 3e 17			ld a, 23 
6353 67				ld h, a 
6354			 
6354 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
6357			 
6357			;	ld (chk_stund), hl	; stack points.... 
6357 22 fd fb			ld (chk_stovr), hl 
635a 22 08 f8			ld (chk_ret_und), hl 
635d 22 86 f7			ld (chk_ret_ovr), hl 
6360 22 84 f5			ld (chk_loop_ovr), hl 
6363 22 82 f3			ld (chk_data_ovr), hl 
6366 c9				ret 
6367				 
6367			check_stacks: 
6367				; check all stack words 
6367			 
6367 e5				push hl 
6368 d5				push de 
6369			 
6369			;	ld de,(chk_word) 
6369			;	ld hl, (chk_stund)	; stack points.... 
6369			;	if DEBUG_STK_FAULT 
6369			;		DMARK "FAa" 
6369			;		CALLMONITOR 
6369			;	endif 
6369			;	call cmp16 
6369			;	jp z, .chk_faulta 
6369			; 
6369			;	ld de, sfaultsu 
6369			;	jp .chk_fault 
6369			 
6369 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
636c ed 5b 04 ee		ld de,(chk_word) 
6370				if DEBUG_STK_FAULT 
6370					DMARK "FAb" 
6370					CALLMONITOR 
6370				endif 
6370 cd 27 0d			call cmp16 
6373 28 06			jr z, .chk_fault1 
6375 11 16 64			ld de, sfaultso 
6378 c3 ca 63			jp .chk_fault 
637b			.chk_fault1:  
637b 2a 08 f8			ld hl, (chk_ret_und) 
637e ed 5b 04 ee		ld de,(chk_word) 
6382				if DEBUG_STK_FAULT 
6382					DMARK "FAU" 
6382					CALLMONITOR 
6382				endif 
6382 cd 27 0d			call cmp16 
6385 ca 8e 63			jp z, .chk_fault2 
6388 11 26 64			ld de, sfaultru 
638b c3 ca 63			jp .chk_fault 
638e			.chk_fault2:  
638e 2a 86 f7			ld hl, (chk_ret_ovr) 
6391 ed 5b 04 ee		ld de,(chk_word) 
6395				if DEBUG_STK_FAULT 
6395					DMARK "FA1" 
6395					CALLMONITOR 
6395				endif 
6395 cd 27 0d			call cmp16 
6398 ca a1 63			jp z, .chk_fault3 
639b 11 34 64			ld de, sfaultro 
639e c3 ca 63			jp .chk_fault 
63a1			.chk_fault3:  
63a1 2a 84 f5			ld hl, (chk_loop_ovr) 
63a4 ed 5b 04 ee		ld de,(chk_word) 
63a8				if DEBUG_STK_FAULT 
63a8					DMARK "FA2" 
63a8					CALLMONITOR 
63a8				endif 
63a8 cd 27 0d			call cmp16 
63ab ca b4 63			jp z, .chk_fault4 
63ae 11 4e 64			ld de, sfaultlo 
63b1 c3 ca 63			jp .chk_fault 
63b4			.chk_fault4:  
63b4 2a 82 f3			ld hl, (chk_data_ovr) 
63b7 ed 5b 04 ee		ld de,(chk_word) 
63bb				if DEBUG_STK_FAULT 
63bb					DMARK "FA3" 
63bb					CALLMONITOR 
63bb				endif 
63bb cd 27 0d			call cmp16 
63be ca c7 63			jp z, .chk_fault5 
63c1 11 68 64			ld de, sfaultdo 
63c4 c3 ca 63			jp .chk_fault 
63c7			 
63c7			 
63c7			.chk_fault5:  
63c7 d1				pop de 
63c8 e1				pop hl 
63c9			 
63c9 c9				ret 
63ca			 
63ca cd d5 0a		.chk_fault: 	call clear_display 
63cd 3e 28				ld a, display_row_2 
63cf cd e8 0a				call str_at_display 
63d2 11 f8 63				   ld de, .stackfault 
63d5 3e 00				ld a, display_row_1 
63d7 cd e8 0a				call str_at_display 
63da 11 77 fb				    ld de, debug_mark 
63dd 3e 11				ld a, display_row_1+17 
63df cd e8 0a				call str_at_display 
63e2 cd f8 0a				call update_display 
63e5			 
63e5				; prompt before entering montior for investigating issue 
63e5			 
63e5 3e 78			ld a, display_row_4 
63e7 11 c3 19			ld de, endprog 
63ea			 
63ea cd f8 0a			call update_display		 
63ed			 
63ed cd 21 1c			call next_page_prompt 
63f0			 
63f0 d1				pop de 
63f1 e1				pop hl 
63f2 cd 17 1a				call monitor 
63f5 c3 0e 19				jp warmstart 
63f8					;jp 0 
63f8					;halt 
63f8			 
63f8			 
63f8			 
63f8 .. 00		.stackfault: 	db "Stack fault:",0 
6405			 
6405 .. 00		sfaultsu: 	db	"Stack under flow",0 
6416 .. 00		sfaultso: 	db	"Stack over flow",0 
6426 .. 00		sfaultru:	db "RTS underflow",0 
6434 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
644e .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6468 .. 00		sfaultdo:	db "DTS overflow", 0 
6475			 
6475			 
6475			fault_dsp_under: 
6475 11 87 64			ld de, .dsp_under 
6478 c3 37 65			jp .show_fault 
647b			 
647b			fault_rsp_under: 
647b 11 95 64			ld de, .rsp_under 
647e c3 37 65			jp .show_fault 
6481			fault_loop_under: 
6481 11 a3 64			ld de, .loop_under 
6484 c3 37 65			jp .show_fault 
6487			 
6487 .. 00		.dsp_under: db "DSP Underflow",0 
6495 .. 00		.rsp_under: db "RSP Underflow",0 
64a3 .. 00		.loop_under: db "LOOP Underflow",0 
64b2			 
64b2			 
64b2 d5			type_faultn: 	push de 
64b3 e5					push hl 
64b4 cd d5 0a				call clear_display 
64b7 11 de 64				   ld de, .typefaultn 
64ba 3e 00				ld a, display_row_1 
64bc cd e8 0a				call str_at_display 
64bf 11 77 fb				    ld de, debug_mark 
64c2 3e 11				ld a, display_row_1+17 
64c4 cd e8 0a				call str_at_display 
64c7 cd f8 0a				call update_display 
64ca			 
64ca				; prompt before entering montior for investigating issue 
64ca			 
64ca 3e 78			ld a, display_row_4 
64cc 11 c3 19			ld de, endprog 
64cf			 
64cf cd f8 0a			call update_display		 
64d2			 
64d2 cd 21 1c			call next_page_prompt 
64d5			 
64d5 e5					push hl 
64d6 d5					push de 
64d7 cd 17 1a				call monitor 
64da c3 0e 19				jp warmstart 
64dd 76					halt 
64de			 
64de			 
64de .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
64f5			 
64f5 d5			type_faults: 	push de 
64f6 e5					push hl 
64f7 cd d5 0a				call clear_display 
64fa 11 20 65				   ld de, .typefaults 
64fd 3e 00				ld a, display_row_1 
64ff cd e8 0a				call str_at_display 
6502 11 77 fb				    ld de, debug_mark 
6505 3e 11				ld a, display_row_1+17 
6507 cd e8 0a				call str_at_display 
650a cd f8 0a				call update_display 
650d			 
650d				; prompt before entering montior for investigating issue 
650d			 
650d 3e 78			ld a, display_row_4 
650f 11 c3 19			ld de, endprog 
6512			 
6512 cd f8 0a			call update_display		 
6515			 
6515 cd 21 1c			call next_page_prompt 
6518			 
6518 e1					pop hl 
6519 d1					pop de 
651a cd 17 1a				call monitor 
651d c3 0e 19				jp warmstart 
6520			 
6520			 
6520 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6537			 
6537			.show_fault: 	 
6537 d5					push de 
6538 cd d5 0a				call clear_display 
653b d1					pop de 
653c 3e 00				ld a, display_row_1 
653e cd e8 0a				call str_at_display 
6541 11 77 fb				    ld de, debug_mark 
6544 3e 11				ld a, display_row_1+17 
6546 cd e8 0a				call str_at_display 
6549 cd f8 0a				call update_display 
654c			 
654c				; prompt before entering montior for investigating issue 
654c			 
654c 3e 78			ld a, display_row_4 
654e 11 c3 19			ld de, endprog 
6551			 
6551 cd f8 0a			call update_display		 
6554			 
6554 cd 21 1c			call next_page_prompt 
6557			 
6557 e1					pop hl 
6558 d1					pop de 
6559 cd 17 1a				call monitor 
655c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
655c			; TODO Make optional fault restart to cli or warm boot? 
655c					;jp warmstart 
655c c3 69 19				jp cli 
655f 76					halt 
6560			 
6560			; handle the auto run of code from files in storage 
6560			 
6560			 
6560			if STORAGE_SE 
6560			 
6560 .. 00		sprompt3: db "Loading from start-up file?:",0 
657d .. 00		sprompt4: db "(Y=Any key/N=No)",0 
658e			 
658e			 
658e			forth_autoload: 
658e			 
658e				; load block 0 of store 1 
658e				 
658e 3e fe			ld a, $fe      ; bit 0 clear 
6590 32 48 f8			ld (spi_device), a 
6593			 
6593 cd bd 03			call storage_get_block_0 
6596			 
6596 3a 83 f8			ld a, (store_page+STORE_0_AUTOFILE) 
6599			 
6599 fe 00			cp 0 
659b c8				ret z     ; auto start not enabled 
659c			 
659c cd d5 0a			call clear_display 
659f			 
659f				; set bank 
659f			 
659f 3a 85 f8				ld a, (store_page+STORE_0_BANKRUN) 
65a2 32 48 f8				ld (spi_device), a 
65a5			 
65a5				; get file id to load from and get the file name to display 
65a5			 
65a5 3a 86 f8				ld a, (store_page+STORE_0_FILERUN) 
65a8			 
65a8 2e 00				ld l, 0 
65aa 67					ld h, a 
65ab 11 62 f8				ld de, store_page 
65ae			 
65ae					if DEBUG_FORTH_WORDS 
65ae						DMARK "ASp" 
65ae f5				push af  
65af 3a c3 65			ld a, (.dmark)  
65b2 32 77 fb			ld (debug_mark),a  
65b5 3a c4 65			ld a, (.dmark+1)  
65b8 32 78 fb			ld (debug_mark+1),a  
65bb 3a c5 65			ld a, (.dmark+2)  
65be 32 79 fb			ld (debug_mark+2),a  
65c1 18 03			jr .pastdmark  
65c3 ..			.dmark: db "ASp"  
65c6 f1			.pastdmark: pop af  
65c7			endm  
# End of macro DMARK
65c7						CALLMONITOR 
65c7 cd 19 17			call break_point_state  
65ca				endm  
# End of macro CALLMONITOR
65ca					endif 
65ca cd 51 08				call storage_read 
65cd			 
65cd					if DEBUG_FORTH_WORDS 
65cd						DMARK "ASr" 
65cd f5				push af  
65ce 3a e2 65			ld a, (.dmark)  
65d1 32 77 fb			ld (debug_mark),a  
65d4 3a e3 65			ld a, (.dmark+1)  
65d7 32 78 fb			ld (debug_mark+1),a  
65da 3a e4 65			ld a, (.dmark+2)  
65dd 32 79 fb			ld (debug_mark+2),a  
65e0 18 03			jr .pastdmark  
65e2 ..			.dmark: db "ASr"  
65e5 f1			.pastdmark: pop af  
65e6			endm  
# End of macro DMARK
65e6						CALLMONITOR 
65e6 cd 19 17			call break_point_state  
65e9				endm  
# End of macro CALLMONITOR
65e9					endif 
65e9			 
65e9 cd 32 0d				call ishlzero 
65ec c8					ret z             ; file not found 
65ed			 
65ed 3e 32				ld a, display_row_2 + 10 
65ef 11 65 f8				ld de, store_page+3 
65f2 cd e8 0a				call str_at_display 
65f5				 
65f5			; 
65f5			 
65f5 3e 05			ld a, display_row_1+5 
65f7 11 60 65			ld de, sprompt3 
65fa cd e8 0a			call str_at_display 
65fd 3e 5f			ld a, display_row_3+15 
65ff 11 7d 65			ld de, sprompt4 
6602 cd e8 0a			call str_at_display 
6605			 
6605 cd f8 0a			call update_display 
6608			 
6608 cd ef 69			call cin_wait 
660b fe 6e			cp 'n' 
660d c8				ret z 
660e fe 4e			cp 'N' 
6610 c8				ret z 
6611			 
6611 cd 55 0a			call delay1s 
6614			 
6614 3a 64 f8			ld a, (store_page+2) 
6617 32 58 f8			ld (store_openmaxext), a    ; save count of ext 
661a 3e 01			ld a, 1  
661c 32 59 f8			ld (store_openext), a    ; save count of ext 
661f			 
661f			.autof:  
661f 6f				ld l , a 
6620				 
6620 3a 62 f8			ld a, (store_page) 
6623 67				ld h, a	 
6624 11 62 f8			ld de, store_page 
6627					if DEBUG_FORTH_WORDS 
6627						DMARK "ASl" 
6627 f5				push af  
6628 3a 3c 66			ld a, (.dmark)  
662b 32 77 fb			ld (debug_mark),a  
662e 3a 3d 66			ld a, (.dmark+1)  
6631 32 78 fb			ld (debug_mark+1),a  
6634 3a 3e 66			ld a, (.dmark+2)  
6637 32 79 fb			ld (debug_mark+2),a  
663a 18 03			jr .pastdmark  
663c ..			.dmark: db "ASl"  
663f f1			.pastdmark: pop af  
6640			endm  
# End of macro DMARK
6640						CALLMONITOR 
6640 cd 19 17			call break_point_state  
6643				endm  
# End of macro CALLMONITOR
6643					endif 
6643 cd 51 08				call storage_read 
6646 cd 32 0d			call ishlzero 
6649 c8				ret z 
664a			 
664a					if DEBUG_FORTH_WORDS 
664a						DMARK "ASc" 
664a f5				push af  
664b 3a 5f 66			ld a, (.dmark)  
664e 32 77 fb			ld (debug_mark),a  
6651 3a 60 66			ld a, (.dmark+1)  
6654 32 78 fb			ld (debug_mark+1),a  
6657 3a 61 66			ld a, (.dmark+2)  
665a 32 79 fb			ld (debug_mark+2),a  
665d 18 03			jr .pastdmark  
665f ..			.dmark: db "ASc"  
6662 f1			.pastdmark: pop af  
6663			endm  
# End of macro DMARK
6663						CALLMONITOR 
6663 cd 19 17			call break_point_state  
6666				endm  
# End of macro CALLMONITOR
6666					endif 
6666 11 64 f8			ld de, store_page+2 
6669 3e 78			ld a, display_row_4 
666b cd e8 0a			call str_at_display 
666e			 
666e cd f8 0a			call update_display 
6671 cd 49 0a			call delay250ms 
6674			 
6674			 
6674			 
6674 21 64 f8			ld hl, store_page+2 
6677 cd 60 20			call forthparse 
667a cd a0 20			call forthexec 
667d cd b7 1f			call forthexec_cleanup 
6680			 
6680				 
6680 3a 59 f8			ld a, (store_openext) 
6683 3c				inc a 
6684 32 59 f8			ld (store_openext), a    ; save count of ext 
6687			 
6687 18 96			jr .autof 
6689			 
6689			;.autofdone: 
6689			; 
6689			;		if DEBUG_FORTH_WORDS 
6689			;			DMARK "ASx" 
6689			;			CALLMONITOR 
6689			;		endif 
6689			;;	call clear_display 
6689			;	ret 
6689			 
6689			 
6689			 
6689			endif 
6689			 
6689			 
6689			; eof 
# End of file forth_kernel.asm
6689			;include "nascombasic.asm" 
6689			 
6689			 
6689			; find out where the code ends if loaded into RAM (for SC114) 
6689			;endofcode:  
6689			;	nop 
6689			 
6689			 
6689			; eof 
6689			 
# End of file main.asm
6689			include "firmware_lcd_4x40.asm" 
6689			; **********************************************************************  
6689			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6689			; **********************************************************************  
6689			;  
6689			; **  Written as a Small Computer Monitor App  
6689			; **  www.scc.me.uk  
6689			;  
6689			; History  
6689			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6689			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6689			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6689			;  
6689			; **********************************************************************  
6689			;  
6689			; This program is an example of one of the methods of interfacing an   
6689			; alphanumeric LCD module.   
6689			;  
6689			; In this example the display is connected to either a Z80 PIO or a   
6689			; simple 8-bit output port.   
6689			;  
6689			; This interfacing method uses 4-bit data mode and uses time delays  
6689			; rather than polling the display's ready status. As a result the   
6689			; interface only requires 6 simple output lines:  
6689			;   Output bit 0 = not used  
6689			;   Output bit 1 = not used  
6689			;   Output bit 2 = RS         High = data, Low = instruction  
6689			;   Output bit 3 = E          Active high  
6689			;   Output bit 4 = DB4  
6689			;   Output bit 5 = DB5  
6689			;   Output bit 6 = DB6  
6689			;   Output bit 7 = DB7  
6689			; Display's R/W is connected to 0v so it is always in write mode  
6689			;  
6689			; This set up should work with any system supporting the RC2014 bus  
6689			  
6689			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6689			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6689			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6689			;  
6689			; **********************************************************************  
6689			  
6689			; Additonal for 4x40. E1 and E2 instead of just E   
6689			; TODO swipe vidout signal on port a to activate E2  
6689			  
6689			; **********************************************************************  
6689			; **  Constants  
6689			; **********************************************************************  
6689			; LCD constants required by LCD support module  
6689			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6689			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6689			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6689			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6689			; TODO Decide which E is being set  
6689			kLCDWidth:  EQU display_cols             ;Width in characters  
6689			  
6689			; **********************************************************************  
6689			; **  Code library usage  
6689			; **********************************************************************  
6689			  
6689			; send character to current cursor position  
6689			; wraps and/or scrolls screen automatically  
6689			  
6689			  
6689			  
6689			lcd_init:  
6689			  
6689			; SCMonAPI functions used  
6689			  
6689			; Alphanumeric LCD functions used  
6689			; no need to specify specific functions for this module  
6689			  
6689 3e cf		            LD   A, 11001111b  
668b d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
668d 3e 00		            LD   A, 00000000b  
668f d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6691			  
6691			; Initialise alphanumeric LCD module  
6691 3e 00				ld a, 0  
6693 32 d7 f8				ld (display_lcde1e2), a  
6696 cd 17 67		            CALL fLCD_Init      ;Initialise LCD module  
6699 3e 01				ld a, 1  
669b 32 d7 f8				ld (display_lcde1e2), a  
669e cd 17 67		            CALL fLCD_Init      ;Initialise LCD module  
66a1			  
66a1 c9				ret  
66a2			  
66a2			;  
66a2			;;  
66a2			; lcd functions  
66a2			;  
66a2			;  
66a2			  
66a2			; what is at cursor position   
66a2			  
66a2			;get_cursor:	ld de, (cursor_row)   ;  row + col  
66a2			;		call curptr  
66a2			;		ret  
66a2			  
66a2			  
66a2			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
66a2			  
66a2			curptr:  
66a2 c5				push bc  
66a3 21 bd fa			ld hl, display_fb0  
66a6			cpr:	  
66a6				; loop for cursor whole row  
66a6 0e 28			ld c, display_cols  
66a8 23			cpr1:	inc hl  
66a9 0d				dec c  
66aa 20 fc			jr nz, cpr1  
66ac 05				dec b  
66ad 20 f7			jr nz, cpr  
66af			  
66af				; add col	  
66af			  
66af 23			cpr2:	inc hl  
66b0 1d				dec e  
66b1 20 fc			jr nz, cpr2  
66b3			  
66b3 c1				pop bc  
66b4 c9				ret  
66b5				  
66b5			  
66b5			  
66b5			  
66b5			  
66b5			; write the frame buffer given in hl to hardware   
66b5 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
66b8 3e 00			ld a, kLCD_Line1  
66ba cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
66bd 06 28			ld b, display_cols  
66bf ed 5b d5 f8		ld de, (display_write_tmp)  
66c3 cd 0f 67			call write_len_string  
66c6				  
66c6				  
66c6 2a d5 f8			ld hl, (display_write_tmp)  
66c9 11 28 00			ld de, display_cols  
66cc 19				add hl,de  
66cd 22 d5 f8			ld (display_write_tmp),hl  
66d0			  
66d0				  
66d0 3e 28			ld a, kLCD_Line2  
66d2 cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
66d5 06 28			ld b, display_cols  
66d7 ed 5b d5 f8		ld de, (display_write_tmp)  
66db cd 0f 67			call write_len_string  
66de				  
66de 2a d5 f8			ld hl, (display_write_tmp)  
66e1 11 28 00			ld de, display_cols  
66e4 19				add hl,de  
66e5 22 d5 f8			ld (display_write_tmp),hl  
66e8			  
66e8				  
66e8 3e 50			ld a, kLCD_Line3  
66ea cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
66ed 06 28			ld b, display_cols  
66ef ed 5b d5 f8		ld de, (display_write_tmp)  
66f3 cd 0f 67			call write_len_string  
66f6				  
66f6 2a d5 f8			ld hl, (display_write_tmp)  
66f9 11 28 00			ld de, display_cols  
66fc 19				add hl,de  
66fd 22 d5 f8			ld (display_write_tmp),hl  
6700			  
6700				  
6700 3e 78			ld a, kLCD_Line4  
6702 cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6705 06 28			ld b, display_cols  
6707 ed 5b d5 f8		ld de, (display_write_tmp)  
670b cd 0f 67			call write_len_string  
670e c9					ret  
670f				  
670f				; write out a fixed length string given in b from de  
670f			  
670f 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6710 cd 7c 67		            CALL fLCD_Data      ;Write character to display  
6713 13				inc de  
6714 10 f9			djnz write_len_string  
6716 c9				ret  
6717			  
6717			; Some other things to do  
6717			;            LD   A, kLCD_Clear ;Display clear  
6717			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6717			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6717			;            LD   A, kLCD_On     ;Display on with no cursor  
6717			;            ;LD   A, kLCD_Off   ;Display off  
6717			;            CALL fLCD_Inst      ;Send instruction to display  
6717			;  
6717			;  
6717			;            halt  
6717			;  
6717			;  
6717			;MsgHello:   DB  "Hello World!",0  
6717			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6717			  
6717			; Custom characters 5 pixels wide by 8 pixels high  
6717			; Up to 8 custom characters can be defined  
6717			;BitMaps:      
6717			;; Character 0x00 = Battery icon  
6717			;            DB  01110b  
6717			;            DB  11011b  
6717			;            DB  10001b  
6717			;            DB  10001b  
6717			;            DB  11111b  
6717			;            DB  11111b  
6717			;            DB  11111b  
6717			;            DB  11111b  
6717			;; Character 0x01 = Bluetooth icon  
6717			;            DB  01100b  
6717			;            DB  01010b  
6717			;            DB  11100b  
6717			;            DB  01000b  
6717			;            DB  11100b  
6717			;            DB  01010b  
6717			;            DB  01100b  
6717			;            DB  00000b  
6717			;  
6717			  
6717			  
6717			; **********************************************************************  
6717			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6717			; **********************************************************************  
6717			;  
6717			; **  Written as a Small Computer Monitor App   
6717			; **  Version 0.1 SCC 2018-05-16  
6717			; **  www.scc.me.uk  
6717			;  
6717			; **********************************************************************  
6717			;  
6717			; This module provides support for alphanumeric LCD modules using with  
6717			; *  HD44780 (or compatible) controller  
6717			; *  5 x 7 pixel fonts  
6717			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6717			; *  Interface via six digital outputs to the display (see below)  
6717			;  
6717			; LCD module pinout:  
6717			;   1  Vss   0v supply  
6717			;   2  Vdd   5v supply  
6717			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6717			;   4  RS    High = data, Low = instruction  
6717			;   5  R/W   High = Read, Low = Write  
6717			;   6  E     Enable signal (active high)  
6717			;   7  DB0   Data bit 0  
6717			;   8  DB1   Data bit 1  
6717			;   9  DB2   Data bit 2  
6717			;  10  DB3   Data bit 3  
6717			;  11  DB4   Data bit 4  
6717			;  12  DB5   Data bit 5  
6717			;  13  DB6   Data bit 6  
6717			;  14  DB7   Data bit 7  
6717			;  15  A     Backlight anode (+)  
6717			;  16  K     Backlight cathode (-)  
6717			;  
6717			; This interfacing method uses 4-bit data mode and uses time delays  
6717			; rather than polling the display's ready status. As a result the   
6717			; interface only requires 6 simple output lines:  
6717			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6717			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6717			;   LCD DB4 = Microcomputer output port bit 4  
6717			;   LCD DB5 = Microcomputer output port bit 5  
6717			;   LCD DB6 = Microcomputer output port bit 6  
6717			;   LCD DB7 = Microcomputer output port bit 7  
6717			; Display's R/W is connected to 0v so it is always in write mode  
6717			; All 6 connections must be on the same port address <kLCDPrt>  
6717			; This method also allows a decent length of cable from micro to LCD  
6717			;  
6717			; **********************************************************************  
6717			;  
6717			; To include the code for any given function provided by this module,   
6717			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6717			; the parent source file.  
6717			; For example:  #REQUIRES   uHexPrefix  
6717			;  
6717			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6717			; in the parent source file.  
6717			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6717			;  
6717			; These are the function names provided by this module:  
6717			; fLCD_Init                     ;Initialise LCD  
6717			; fLCD_Inst                     ;Send instruction to LCD  
6717			; fLCD_Data                     ;Send data byte to LCD  
6717			; fLCD_Pos                      ;Position cursor  
6717			; fLCD_Str                      ;Display string  
6717			; fLCD_Def                      ;Define custom character  
6717			;  
6717			; **********************************************************************  
6717			;  
6717			; Requires SCMonAPI.asm to also be included in the project  
6717			;  
6717			  
6717			  
6717			; **********************************************************************  
6717			; **  Constants  
6717			; **********************************************************************  
6717			  
6717			; Constants that must be defined externally  
6717			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6717			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6717			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6717			;kLCDWidth: EQU 20             ;Width in characters  
6717			  
6717			; general line offsets in any frame buffer  
6717			  
6717			  
6717			display_row_1: equ 0  
6717			display_row_2: equ display_row_1+display_cols  
6717			display_row_3: equ display_row_2 + display_cols  
6717			display_row_4: equ display_row_3 + display_cols  
6717			;display_row_4_eol:   
6717			  
6717			  
6717			; Cursor position values for the start of each line  
6717			  
6717			; E  
6717			kLCD_Line1: EQU 0x00   
6717			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6717			; E1  
6717			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6717			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6717			  
6717			; Instructions to send as A register to fLCD_Inst  
6717			kLCD_Clear: EQU 00000001b     ;LCD clear  
6717			kLCD_Off:   EQU 00001000b     ;LCD off  
6717			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6717			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6717			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6717			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6717			  
6717			; Constants used by this code module  
6717			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6717			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6717			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6717			  
6717			  
6717			  
6717			; **********************************************************************  
6717			; **  LCD support functions  
6717			; **********************************************************************  
6717			  
6717			; Initialise alphanumeric LCD module  
6717			; LCD control register codes:  
6717			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6717			;   N    0 = 1-line mode       1 = 2-line mode  
6717			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6717			;   D    0 = Display off       1 = Display on  
6717			;   C    0 = Cursor off        1 = Cursor on  
6717			;   B    0 = Blinking off      1 = Blinking on  
6717			;   ID   0 = Decrement mode    1 = Increment mode  
6717			;   SH   0 = Entire shift off  1 = Entire shift on  
6717 3e 28		fLCD_Init:  LD   A, 40  
6719 cd 3e 68		            CALL LCDDelay       ;Delay 40ms after power up  
671c			; For reliable reset set 8-bit mode - 3 times  
671c cd 0e 68		            CALL WrFn8bit       ;Function = 8-bit mode  
671f cd 0e 68		            CALL WrFn8bit       ;Function = 8-bit mode  
6722 cd 0e 68		            CALL WrFn8bit       ;Function = 8-bit mode  
6725			; Set 4-bit mode  
6725 cd 0a 68		            CALL WrFn4bit       ;Function = 4-bit mode  
6728 cd 3c 68		            CALL LCDDelay1      ;Delay 37 us or more  
672b			; Function set  
672b 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
672d cd 40 67		            CALL fLCD_Inst      ;2 line, display on  
6730			; Display On/Off control  
6730 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6732 cd 40 67		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6735			; Display Clear  
6735 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6737 cd 40 67		            CALL fLCD_Inst      ;Clear display  
673a			; Entry mode  
673a 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
673c cd 40 67		            CALL fLCD_Inst      ;Increment mode, shift off  
673f			; Display module now initialised  
673f c9			            RET  
6740			; ok to here  
6740			  
6740			; Write instruction to LCD  
6740			;   On entry: A = Instruction byte to be written  
6740			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6740 f5			fLCD_Inst:  PUSH AF  
6741 f5			            PUSH AF  
6742 cd 54 67		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6745 f1			            POP  AF  
6746 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6747 17			            RLA  
6748 17			            RLA  
6749 17			            RLA  
674a cd 54 67		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
674d 3e 02		            LD   A, 2  
674f cd 3e 68		            CALL LCDDelay       ;Delay 2 ms to complete   
6752 f1			            POP  AF  
6753 c9			            RET  
6754			Wr4bits:   
6754 f5					push af  
6755 3a d7 f8				ld a, (display_lcde1e2)  
6758 fe 00				cp 0     ; e  
675a 20 10				jr nz, .wea2	  
675c f1					pop af  
675d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
675f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6761 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6763 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6765 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6767 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6769 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
676b c9			            RET  
676c f1			.wea2:		pop af  
676d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
676f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6771 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6773 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6775 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6777 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6779 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
677b c9			            RET  
677c			  
677c			  
677c			; Write data to LCD  
677c			;   On entry: A = Data byte to be written  
677c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
677c f5			fLCD_Data:  PUSH AF  
677d f5			            PUSH AF  
677e cd 90 67		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6781 f1			            POP  AF  
6782 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6783 17			            RLA  
6784 17			            RLA  
6785 17			            RLA  
6786 cd 90 67		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6789 3e 96		            LD   A, 150  
678b 3d			Wait:      DEC  A              ;Wait a while to allow data   
678c 20 fd		            JR   NZ, Wait      ;  write to complete  
678e f1			            POP  AF  
678f c9			            RET  
6790			Wr4bitsa:     
6790 f5					push af  
6791 3a d7 f8				ld a, (display_lcde1e2)  
6794 fe 00				cp 0     ; e1  
6796 20 16				jr nz, .we2	  
6798 f1					pop af  
6799 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
679b cb d7		            SET  kLCDBitRS, A  
679d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
679f cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
67a1 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
67a3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
67a5 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
67a7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
67a9 cb 97		            RES  kLCDBitRS, A  
67ab d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
67ad c9			            RET  
67ae f1			.we2:		pop af  
67af e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
67b1 cb d7		            SET  kLCDBitRS, A  
67b3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
67b5 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
67b7 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
67b9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
67bb cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
67bd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
67bf cb 97		            RES  kLCDBitRS, A  
67c1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
67c3 c9			            RET  
67c4			  
67c4			  
67c4			; Position cursor to specified location  
67c4			;   On entry: A = Cursor position  
67c4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
67c4 f5			fLCD_Pos:   PUSH AF  
67c5					; at this point set the E1 or E2 flag depending on position  
67c5			  
67c5 c5					push bc  
67c6			;		push af  
67c6 06 00				ld b, 0  
67c8 4f					ld c, a  
67c9 3e 4f				ld a, kLCD_Line3-1  
67cb b7			 		or a      ;clear carry flag  
67cc 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
67cd 38 04				jr c, .pe1  
67cf			  
67cf					; E selection  
67cf cb 80				res 0, b         ; bit 0 unset e  
67d1			;		pop af    ; before line 3 so recover orig pos  
67d1			;		ld c, a    ; save for poking back  
67d1 18 06				jr .peset	          
67d3			.pe1:          	; E2 selection  
67d3 cb c0				set 0, b         ; bit 0 set e1  
67d5 79					ld a, c  
67d6 de 4f				sbc a, kLCD_Line3-1  
67d8 4f					ld c, a	         ; save caculated offset  
67d9			;		pop af     ; bin this original value now we have calculated form  
67d9			  
67d9			.peset:		; set bit  
67d9 78					ld a, b  
67da 32 d7 f8				ld (display_lcde1e2), a 	  
67dd 79					ld a, c  
67de c1					pop bc  
67df			  
67df f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
67e1 cd 40 67		            CALL fLCD_Inst      ;Write instruction to LCD  
67e4 f1			            POP  AF  
67e5 c9			            RET  
67e6			  
67e6			  
67e6			; Output text string to LCD  
67e6			;   On entry: DE = Pointer to null terminated text string  
67e6			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
67e6 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
67e7 b7			            OR   A              ;Null terminator?  
67e8 c8			            RET  Z              ;Yes, so finished  
67e9 cd 7c 67		            CALL fLCD_Data      ;Write character to display  
67ec 13			            INC  DE             ;Point to next character  
67ed 18 f7		            JR   fLCD_Str       ;Repeat  
67ef c9					ret  
67f0			  
67f0			; Define custom character  
67f0			;   On entry: A = Character number (0 to 7)  
67f0			;             DE = Pointer to character bitmap data  
67f0			;   On exit:  A = Next character number  
67f0			;             DE = Next location following bitmap  
67f0			;             BC HL IX IY I AF' BC' DE' HL' preserved  
67f0			; Character is   
67f0 c5			fLCD_Def:   PUSH BC  
67f1 f5			            PUSH AF  
67f2 07			            RLCA                ;Calculate location  
67f3 07			            RLCA                ;  for bitmap data  
67f4 07			            RLCA                ;  = 8 x CharacterNumber  
67f5 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
67f7 cd 40 67		            CALL fLCD_Inst      ;Write instruction to LCD  
67fa 06 00		            LD   B, 0  
67fc 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
67fd cd 7c 67		            CALL fLCD_Data      ;Write byte to display  
6800 13			            INC  DE             ;Point to next byte  
6801 04			            INC  B              ;Count bytes  
6802 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6804 28 f6		            JR   Z, Loop       ;No, so repeat  
6806 f1			            POP  AF  
6807 3c			            INC  A              ;Increment character number  
6808 c1			            POP  BC  
6809 c9			            RET  
680a			  
680a			  
680a			; **********************************************************************  
680a			; **  Private functions  
680a			; **********************************************************************  
680a			  
680a			; Write function to LCD  
680a			;   On entry: A = Function byte to be written  
680a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
680a 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
680c 18 02		            JR   WrFunc  
680e 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6810 f5			WrFunc:     PUSH AF  
6811 f5					push af  
6812 3a d7 f8				ld a, (display_lcde1e2)  
6815 fe 00				cp 0     ; e1  
6817 20 0f				jr nz, .wfea2	  
6819 f1					pop af  
681a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
681c cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
681e cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6820 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6822 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6824 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6826 18 0d			jr .wfskip  
6828 f1			.wfea2:		pop af  
6829 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
682b cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
682d cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
682f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6831 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6833 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6835 3e 05		.wfskip:            LD  A, 5  
6837 cd 3e 68		            CALL LCDDelay       ;Delay 5 ms to complete  
683a f1			            POP  AF  
683b c9			            RET  
683c			  
683c			  
683c			; Delay in milliseconds  
683c			;   On entry: A = Number of milliseconds delay  
683c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
683c 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
683e d5			LCDDelay:   PUSH DE  
683f 5f			            LD   E, A           ;Delay by 'A' ms  
6840 16 00		            LD   D, 0  
6842 cd 3a 0a		            CALL aDelayInMS  
6845 d1			            POP  DE  
6846 c9			            RET  
6847			  
6847			  
6847			testlcd:  
6847 3e 00			ld a, kLCD_Line1  
6849 cd c4 67			call fLCD_Pos  
684c 06 28			ld b, 40  
684e 11 7c 68			ld de, .ttext1  
6851 cd 0f 67			call write_len_string  
6854			  
6854 3e 28			ld a, kLCD_Line2  
6856 cd c4 67			call fLCD_Pos  
6859 06 28			ld b, 40  
685b 11 a5 68			ld de, .ttext2  
685e cd 0f 67			call write_len_string  
6861 3e 50			ld a, kLCD_Line3  
6863 cd c4 67			call fLCD_Pos  
6866 06 28			ld b, 40  
6868 11 ce 68			ld de, .ttext3  
686b cd 0f 67			call write_len_string  
686e 3e 78			ld a, kLCD_Line4  
6870 cd c4 67			call fLCD_Pos  
6873 06 28			ld b, 40  
6875 11 f7 68			ld de, .ttext4  
6878 cd 0f 67			call write_len_string  
687b			  
687b 76				halt  
687c			  
687c			  
687c .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
68a5 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
68ce .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
68f7 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6920			   
6920			  
6920			  
6920			; eof  
6920			  
# End of file firmware_lcd_4x40.asm
6920			;include "firmware_lcd_4x20.asm" 
6920			include "firmware_key_5x10.asm" 
6920			; 5 x 10 decade counter scanner  
6920			  
6920			  
6920			; TODO do cursor shape change for shift keys  
6920			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6920			  
6920			  
6920			; bit mask for each scan column and row for teing the matrix  
6920			  
6920			  
6920			key_init:  
6920			  
6920			; SCMonAPI functions used  
6920			  
6920			; Alphanumeric LCD functions used  
6920			; no need to specify specific functions for this module  
6920			  
6920			  
6920 3e cf		            LD   A, 11001111b  
6922 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6924			;            LD   A, 00000000b  
6924 3e 1f		            LD   A, 00011111b  
6926 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6928			  
6928			  
6928				; TODO Configure cursor shapes  
6928			  
6928				; Load cursor shapes   
6928 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
692a 11 3a 69		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
692d 06 02		            LD   B, 2           ;Number of characters to define  
692f cd f0 67		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6932 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6934			  
6934 3e 01				ld a, 1  
6936 32 d0 f8			ld (cursor_shape),a  
6939 c9				ret  
693a			  
693a			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
693a			; Up to 8 custom characters can be defined  
693a			.cursor_shapes:      
693a			;; Character 0x00 = Normal  
693a 1f			            DB  11111b  
693b 1f			            DB  11111b  
693c 1f			            DB  11111b  
693d 1f			            DB  11111b  
693e 1f			            DB  11111b  
693f 1f			            DB  11111b  
6940 1f			            DB  11111b  
6941 1f			            DB  11111b  
6942			;; Character 0x01 = Modifier  
6942 1f			            DB  11111b  
6943 1b			            DB  11011b  
6944 1b			            DB  11011b  
6945 1b			            DB  11011b  
6946 1b			            DB  11011b  
6947 1f			            DB  11111b  
6948 1b			            DB  11011b  
6949 1f			            DB  11111b  
694a			  
694a			  
694a			  
694a			  
694a			; Display custom character 0  
694a			;            LD   A, kLCD_Line1+14  
694a			;            CALL fLCD_Pos       ;Position cursor to location in A  
694a			;            LD   A, 0  
694a			;            CALL fLCD_Data      ;Write character in A at cursor  
694a			  
694a			; Display custom character 1  
694a			;            LD   A, kLCD_Line2+14  
694a			;            CALL fLCD_Pos      ;Position cursor to location in A  
694a			;            LD   A, 1  
694a			;            CALL fLCD_Data     ;Write character in A at cursor  
694a			  
694a			; keyboard scanning   
694a			  
694a			; character in from keyboard  
694a			  
694a			; mapping for the pcb layout  
694a			  
694a			.matrix_to_char:  
694a .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6955 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6960 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
696b 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6976 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6981			.matrix_to_shift:  
6981			  
6981 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
698c .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6997 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
69a2 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
69ad .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
69b8			  
69b8			.matrix_to_symbolshift:  
69b8			  
69b8 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
69c3 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
69ce 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
69d9			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
69d9 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
69e4 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
69ef			  
69ef			  
69ef			  
69ef			; mapping for a simple straight through breadboard layout  
69ef			  
69ef			;.matrix_to_char:  
69ef			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
69ef			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
69ef			;		db "asdfghjkl",KEY_CR,0  
69ef			;		db "qwertyuiop",0  
69ef			;		 db "1234567890",0  
69ef			;.matrix_to_shift:  
69ef			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
69ef			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
69ef			;		db "ASDFGHJKL",KEY_CR,0  
69ef			;		db "QWERTYUIOP",0  
69ef			;		 db "!",'"',"#$%^&*()",0  
69ef			;.matrix_to_symbolshift:  
69ef			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
69ef			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
69ef			;		db "_?*fghjk=",KEY_CR,0  
69ef			;		db "-/+*[]{}@#",0  
69ef			;		 db "1234567890",0  
69ef			  
69ef			;.matrix_to_char: db "D#0*C987B654A321"  
69ef			  
69ef			  
69ef				  
69ef			  
69ef			; add cin and cin_wait  
69ef			  
69ef cd 00 6a		cin_wait: 	call cin  
69f2						if DEBUG_KEYCINWAIT  
69f2							push af  
69f2							  
69f2							ld hl,key_repeat_ct  
69f2							ld (hl),a  
69f2							inc hl  
69f2							call hexout  
69f2							ld hl,key_repeat_ct+3  
69f2							ld a,0  
69f2							ld (hl),a  
69f2			  
69f2							    LD   A, kLCD_Line1+11  
69f2							    CALL fLCD_Pos       ;Position cursor to location in A  
69f2							    LD   DE, key_repeat_ct  
69f2							    ;LD   DE, MsgHello  
69f2							    CALL fLCD_Str       ;Display string pointed to by DE  
69f2			  
69f2			  
69f2			  
69f2							pop af  
69f2						endif  
69f2 fe 00			cp 0  
69f4 28 f9			jr z, cin_wait   ; block until key press  
69f6			  
69f6							if DEBUG_KEYCINWAIT  
69f6								push af  
69f6			  
69f6								ld a, 'A'	  
69f6								ld hl,key_repeat_ct  
69f6								ld (hl),a  
69f6								inc hl  
69f6								ld a,0  
69f6								ld (hl),a  
69f6			  
69f6								    LD   A, kLCD_Line2+11  
69f6								    CALL fLCD_Pos       ;Position cursor to location in A  
69f6								    LD   DE, key_repeat_ct  
69f6								    ;LD   DE, MsgHello  
69f6								    CALL fLCD_Str       ;Display string pointed to by DE  
69f6			  
69f6							call delay500ms  
69f6			  
69f6								pop af  
69f6							endif  
69f6 f5				push af   ; save key pressed  
69f7			  
69f7			.cin_wait1:	  
69f7							if DEBUG_KEYCINWAIT  
69f7								push af  
69f7			  
69f7								ld a, 'b'	  
69f7								ld hl,key_repeat_ct  
69f7								ld (hl),a  
69f7								inc hl  
69f7								ld a,0  
69f7								ld (hl),a  
69f7			  
69f7								    LD   A, kLCD_Line2+11  
69f7								    CALL fLCD_Pos       ;Position cursor to location in A  
69f7								    LD   DE, key_repeat_ct  
69f7								    ;LD   DE, MsgHello  
69f7								    CALL fLCD_Str       ;Display string pointed to by DE  
69f7			  
69f7			  
69f7							call delay500ms  
69f7			  
69f7								pop af  
69f7							endif  
69f7			  
69f7 cd 00 6a		call cin  
69fa fe 00			cp 0  
69fc 20 f9			jr nz, .cin_wait1  	; wait for key release  
69fe			if DEBUG_KEYCINWAIT  
69fe				push af  
69fe			  
69fe				ld a, '3'	  
69fe				ld hl,key_repeat_ct  
69fe				ld (hl),a  
69fe				inc hl  
69fe				ld a,0  
69fe				ld (hl),a  
69fe			  
69fe			            LD   A, kLCD_Line2+11  
69fe			            CALL fLCD_Pos       ;Position cursor to location in A  
69fe			            LD   DE, key_repeat_ct  
69fe			            ;LD   DE, MsgHello  
69fe			            CALL fLCD_Str       ;Display string pointed to by DE  
69fe			  
69fe			  
69fe			call delay500ms  
69fe			  
69fe				pop af  
69fe			endif  
69fe			  
69fe f1				pop af   ; get key  
69ff c9				ret  
6a00			  
6a00			  
6a00 cd 14 6a		cin: 	call .mtoc  
6a03			  
6a03			if DEBUG_KEYCIN  
6a03				push af  
6a03				  
6a03				ld hl,key_repeat_ct  
6a03				ld (hl),a  
6a03				inc hl  
6a03				call hexout  
6a03				ld hl,key_repeat_ct+3  
6a03				ld a,0  
6a03				ld (hl),a  
6a03			  
6a03			            LD   A, kLCD_Line3+15  
6a03			            CALL fLCD_Pos       ;Position cursor to location in A  
6a03			            LD   DE, key_repeat_ct  
6a03			            ;LD   DE, MsgHello  
6a03			            CALL fLCD_Str       ;Display string pointed to by DE  
6a03			  
6a03			  
6a03			call delay500ms  
6a03			  
6a03				pop af  
6a03			endif  
6a03			  
6a03			  
6a03				; no key held  
6a03 fe 00			cp 0  
6a05 c8				ret z  
6a06			  
6a06			if DEBUG_KEYCIN  
6a06				push af  
6a06			  
6a06				ld a, '1'	  
6a06				ld hl,key_repeat_ct  
6a06				ld (hl),a  
6a06				inc hl  
6a06				ld a,0  
6a06				ld (hl),a  
6a06			  
6a06			            LD   A, kLCD_Line4+15  
6a06			            CALL fLCD_Pos       ;Position cursor to location in A  
6a06			            LD   DE, key_repeat_ct  
6a06			            ;LD   DE, MsgHello  
6a06			            CALL fLCD_Str       ;Display string pointed to by DE  
6a06			  
6a06			  
6a06			call delay500ms  
6a06			  
6a06				pop af  
6a06			endif  
6a06			  
6a06				; stop key bounce  
6a06			  
6a06 32 88 fb			ld (key_held),a		 ; save it  
6a09 47				ld b, a  
6a0a			  
6a0a c5			.cina1:	push bc  
6a0b			if DEBUG_KEYCIN  
6a0b				push af  
6a0b			  
6a0b				ld hl,key_repeat_ct  
6a0b				inc hl  
6a0b				call hexout  
6a0b				ld hl,key_repeat_ct+3  
6a0b				ld a,0  
6a0b				ld (hl),a  
6a0b				ld hl,key_repeat_ct  
6a0b				ld a, '2'	  
6a0b				ld (hl),a  
6a0b			  
6a0b			            LD   A, kLCD_Line4+15  
6a0b			            CALL fLCD_Pos       ;Position cursor to location in A  
6a0b			            LD   DE, key_repeat_ct  
6a0b			            ;LD   DE, MsgHello  
6a0b			            CALL fLCD_Str       ;Display string pointed to by DE  
6a0b			  
6a0b				pop af  
6a0b			endif  
6a0b cd 14 6a			call .mtoc  
6a0e c1				pop bc  
6a0f b8				cp b  
6a10 28 f8			jr z, .cina1  
6a12 78				ld a,b		  
6a13			if DEBUG_KEYCIN  
6a13				push af  
6a13			  
6a13				ld hl,key_repeat_ct  
6a13				inc hl  
6a13				call hexout  
6a13				ld hl,key_repeat_ct+3  
6a13				ld a,0  
6a13				ld (hl),a  
6a13				ld hl,key_repeat_ct  
6a13				ld a, '3'	  
6a13				ld (hl),a  
6a13			  
6a13			            LD   A, kLCD_Line4+15  
6a13			            CALL fLCD_Pos       ;Position cursor to location in A  
6a13			            LD   DE, key_repeat_ct  
6a13			            ;LD   DE, MsgHello  
6a13			            CALL fLCD_Str       ;Display string pointed to by DE  
6a13			  
6a13				pop af  
6a13			endif  
6a13 c9				ret  
6a14			  
6a14			; detect keyboard modifier key press and apply new overlay to the face key held  
6a14			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6a14			  
6a14			;.cin_map_modifier:   
6a14			;	ld a, (hl)  
6a14			;	and 255  
6a14			;	ret NZ		; modifier key not flagged  
6a14			;  
6a14			;	; get key face  
6a14			;  
6a14			;	ld b,(key_face_held)  
6a14			;  
6a14			;	ld b, key_cols * key_rows  
6a14			;  
6a14			;	push de  
6a14			;	pop hl  
6a14			;  
6a14			;.mmod1: ld a,(hl)   ; get map test  
6a14			;	cp b  
6a14			;	jr z, .mmod2  
6a14			;  
6a14			;  
6a14			;  
6a14			;.mmod2: inc hl    ;   
6a14			;  
6a14			;	  
6a14			;  
6a14			;	  
6a14			;  
6a14			;	ld hl,key_actual_pressed  
6a14			;	ld (hl),a,  
6a14			;	ret  
6a14			  
6a14			; map matrix key held to char on face of key  
6a14			  
6a14			.mtoc:  
6a14			  
6a14			; test decade counter strobes  
6a14			  
6a14			;.decadetest1:  
6a14			  
6a14			; reset counter  
6a14			;ld a, 128  
6a14			;out (portbdata),a  
6a14			  
6a14			  
6a14			;ld b, 5  
6a14			;.dec1:  
6a14			;ld a, 0  
6a14			;out (portbdata),a  
6a14			;call delay1s  
6a14			  
6a14			;ld a, 32  
6a14			;out (portbdata),a  
6a14			;call delay1s  
6a14			;call delay1s  
6a14			;call delay1s  
6a14			;  
6a14			;ld a, 64+32  
6a14			;out (portbdata),a  
6a14			;call delay1s  
6a14			;;djnz .dec1  
6a14			;  
6a14			;jp .decadetest1  
6a14			  
6a14			  
6a14			  
6a14			  
6a14			  
6a14			  
6a14			  
6a14			  
6a14			  
6a14			  
6a14				; scan keyboard matrix and generate raw scan map  
6a14 cd a7 6a			call matrix  
6a17			  
6a17				; reuse c bit 0 left modifer button - ie shift  
6a17			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6a17				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6a17			  
6a17 0e 00			ld c, 0  
6a19			  
6a19				; TODO set flags for modifer key presses   
6a19				; TODO do a search for modifer key...  
6a19			  
6a19				;ld hl,keyscan_table_row4  
6a19 21 e7 fb			ld hl,keyscan_table_row2  
6a1c			  
6a1c 7e				ld a, (hl)  
6a1d fe 23			cp '#'  
6a1f 20 07			jr nz, .nextmodcheck  
6a21 cb c1			set 0, c  
6a23 21 81 69			ld hl, .matrix_to_shift  
6a26 18 21			jr .dokeymap  
6a28				; TODO for now igonre  
6a28			.nextmodcheck:  
6a28 21 dc fb			ld hl,keyscan_table_row3  
6a2b			  
6a2b 7e				ld a, (hl)  
6a2c fe 23			cp '#'  
6a2e 20 07			jr nz, .nextmodcheck2  
6a30 cb c9			set 1, c   
6a32 21 b8 69			ld hl, .matrix_to_symbolshift  
6a35 18 12			jr .dokeymap  
6a37			.nextmodcheck2:  
6a37 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6a3a			  
6a3a 7e				ld a, (hl)  
6a3b fe 23			cp '#'  
6a3d 20 07			jr nz, .donemodcheck  
6a3f cb c9			set 1, c   
6a41 21 81 69			ld hl, .matrix_to_shift  
6a44 18 03			jr .dokeymap  
6a46			  
6a46				; no modifer found so just map to normal keys  
6a46				; get mtoc map matrix to respective keys  
6a46			;	ld hl, .matrix_to_char  
6a46			;	ld hl, .matrix_to_char  
6a46			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6a46			;	ld a, KEY_SHIFT  
6a46			;	call findchar  
6a46			;  
6a46			;	; got offset to key modifer in b  
6a46			;  
6a46			;	ld hl,keyscan_table_row5  
6a46			;  
6a46			;	ld a,b  
6a46			;	call addatohl  
6a46			;	ld a,(hl)  
6a46			;  
6a46			;	cp '#'  
6a46			;	jr nz, .nextmodcheck  
6a46			;	set 0, c  
6a46			;	ld hl, .matrix_to_char  
6a46			;	jr .dokeymap  
6a46			;	; TODO for now igonre  
6a46			;.nextmodcheck:  
6a46			;	ld hl, .matrix_to_symbolshift  
6a46			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6a46			;	ld a, KEY_SYMBOLSHIFT  
6a46			;	call findchar  
6a46			;  
6a46			;  
6a46			;	; got offset to key modifer in b  
6a46			;  
6a46			;	ld hl,keyscan_table_row5  
6a46			;  
6a46			;	ld a,b  
6a46			;	call addatohl  
6a46			;	ld a,(hl)  
6a46			;  
6a46			;	cp '#'  
6a46			;	jr nz, .donemodcheck  
6a46			;	set 1, c   
6a46			;	ld hl, .matrix_to_symbolshift  
6a46			;	jr .dokeymap  
6a46			  
6a46			  
6a46			  
6a46			.donemodcheck:  
6a46				; no modifer found so just map to normal keys  
6a46				; get mtoc map matrix to respective keys  
6a46 21 4a 69			ld hl, .matrix_to_char  
6a49			  
6a49			.dokeymap:  
6a49				;ld (key_fa), c   
6a49 cd 62 6a			call .mapkeys  
6a4c			  
6a4c			  
6a4c			if DEBUG_KEY  
6a4c			  
6a4c			; Display text on first line  
6a4c			            LD   A, kLCD_Line1  
6a4c			            CALL fLCD_Pos       ;Position cursor to location in A  
6a4c			            LD   DE, keyscan_table_row1  
6a4c			            ;LD   DE, MsgHello  
6a4c			            CALL fLCD_Str       ;Display string pointed to by DE  
6a4c			  
6a4c			; Display text on second line  
6a4c			            LD   A, kLCD_Line2  
6a4c			            CALL fLCD_Pos       ;Position cursor to location in A  
6a4c			            LD   DE, keyscan_table_row2  
6a4c			            CALL fLCD_Str       ;Display string pointed to by DE  
6a4c			            LD   A, kLCD_Line3  
6a4c			            CALL fLCD_Pos       ;Position cursor to location in A  
6a4c			            LD   DE, keyscan_table_row3  
6a4c			            CALL fLCD_Str       ;Display string pointed to by DE  
6a4c			            LD   A, kLCD_Line4  
6a4c			            CALL fLCD_Pos       ;Position cursor to location in A  
6a4c			            LD   DE, keyscan_table_row4  
6a4c			            CALL fLCD_Str       ;Display string pointed to by DE  
6a4c			            LD   A, kLCD_Line1+10  
6a4c			            CALL fLCD_Pos       ;Position cursor to location in A  
6a4c			            LD   DE, keyscan_table_row5  
6a4c			            CALL fLCD_Str       ;Display string pointed to by DE  
6a4c			  
6a4c				;call delay250ms  
6a4c			endif  
6a4c			;	jp testkey  
6a4c			  
6a4c			; get first char reported  
6a4c			  
6a4c 21 c6 fb			ld hl,keyscan_table_row5  
6a4f			  
6a4f				;ld b, 46   ; 30 keys to remap + 8 nulls   
6a4f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6a51			.findkey:  
6a51 7e				ld a,(hl)  
6a52 fe 00			cp 0  
6a54 28 04			jr z, .nextkey  
6a56 fe 7e			cp KEY_MATRIX_NO_PRESS  
6a58 20 06			jr nz, .foundkey  
6a5a			.nextkey:  
6a5a 23				inc hl  
6a5b 10 f4			djnz .findkey  
6a5d 3e 00			ld a,0  
6a5f c9				ret  
6a60			.foundkey:  
6a60 7e				ld a,(hl)  
6a61 c9				ret  
6a62				  
6a62			  
6a62			; convert the raw key map given hl for destination key  
6a62			.mapkeys:  
6a62 11 c6 fb			ld de,keyscan_table_row5  
6a65			  
6a65 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6a67			.remap:  
6a67 1a				ld a,(de)  
6a68 fe 23			cp '#'  
6a6a 20 02			jr nz, .remapnext  
6a6c				;CALLMONITOR  
6a6c 7e				ld a,(hl)  
6a6d 12				ld (de),a  
6a6e			  
6a6e			  
6a6e			  
6a6e			.remapnext:  
6a6e 23				inc hl  
6a6f 13				inc de  
6a70 10 f5			djnz .remap  
6a72				  
6a72 c9				ret  
6a73			  
6a73			  
6a73			  
6a73			.mtocold2:  
6a73			  
6a73			;	; flag if key D is held down and remove from reporting  
6a73			;	ld bc, .key_map_fd    
6a73			;	ld hl, keyscan_table  
6a73			;	ld de, key_fd  
6a73			;	call .key_shift_hold  
6a73			;	cp 255  
6a73			;	jr z, .cinmap  
6a73			;	; flag if key C is held down and remove from reporting  
6a73			;	ld bc, .key_map_fc    
6a73			;	ld hl, keyscan_table+key_cols  
6a73			;	ld de, key_fc  
6a73			;	call .key_shift_hold  
6a73			;	cp 255  
6a73			;	jr z, .cinmap  
6a73			;	; flag if key B is held down and remove from reporting  
6a73			;	ld bc, .key_map_fb    
6a73			;	ld hl, keyscan_table+(key_cols*2)  
6a73			;	ld de, key_fb  
6a73			;	call .key_shift_hold  
6a73			;	cp 255  
6a73			;	jr z, .cinmap  
6a73			;	; flag if key A is held down and remove from reporting  
6a73			;	ld bc, .key_map_fa    
6a73			;	ld hl, keyscan_table+(key_cols*3)  
6a73			;	ld de, key_fa  
6a73			;	call .key_shift_hold  
6a73			;	cp 255  
6a73			;	jr z, .cinmap  
6a73			  
6a73 11 4a 69			ld de, .matrix_to_char  
6a76			  
6a76			  
6a76			.cinmap1:   
6a76				if DEBUG_KEY  
6a76			            LD   A, kLCD_Line4  
6a76			            CALL fLCD_Pos       ;Position cursor to location in A  
6a76					push de  
6a76			            LD   DE, keyscan_table  
6a76			            CALL fLCD_Str       ;Display string pointed to by DE  
6a76					pop de  
6a76				endif  
6a76			  
6a76				; scan key matrix table for any held key  
6a76			  
6a76				; de holds either the default matrix or one selected above  
6a76			  
6a76 21 93 fb			ld hl, keyscan_table  
6a79 06 32			ld b,key_cols*key_rows  
6a7b			  
6a7b 7e			.cin11:	ld a,(hl)  
6a7c fe 23			cp '#'  
6a7e 28 08			jr z, .cinhit1  
6a80 23				inc hl  
6a81 13				inc de  
6a82 05				dec b  
6a83 20 f6			jr nz, .cin11  
6a85				; no key found held  
6a85 3e 00			ld a,0  
6a87 c9				ret  
6a88 d5			.cinhit1: push de  
6a89 e1				pop hl  
6a8a 7e				ld a,(hl)  
6a8b c9				ret  
6a8c			  
6a8c			; flag a control key is held   
6a8c			; hl is key pin, de is flag indicator  
6a8c			  
6a8c			.key_shift_hold1:  
6a8c c5				push bc  
6a8d 3e 01			ld a, 1  
6a8f 32 d0 f8			ld (cursor_shape),a  
6a92 06 00			ld b, 0  
6a94 7e				ld a, (hl)  
6a95 fe 2e			cp '.'  
6a97 28 0a			jr z, .key_shift11  
6a99 06 ff			ld b, 255  
6a9b 3e 2b			ld a, '+'    ; hide key from later scans  
6a9d 77				ld (hl),a  
6a9e 3e 02			ld a, 2  
6aa0 32 d0 f8			ld (cursor_shape),a  
6aa3			.key_shift11:  
6aa3				; write flag indicator  
6aa3 78				ld a,b  
6aa4 12				ld (de),a  
6aa5			  
6aa5 d1				pop de    ; de now holds the key map ptr  
6aa6 c9				ret  
6aa7			  
6aa7				  
6aa7			  
6aa7			; scans keyboard matrix and flags key press in memory array	  
6aa7				  
6aa7			matrix:  
6aa7				;call matrix  
6aa7				; TODO optimise the code....  
6aa7			  
6aa7			  
6aa7			;ld hl, keyscan_table_row1  
6aa7			;ld de, keyscan_table_row1+1  
6aa7			;ld bc,46  
6aa7			;ld a,KEY_MATRIX_NO_PRESS  
6aa7			;ldir  
6aa7			  
6aa7			  
6aa7			  
6aa7			; reset counter  
6aa7 3e 80		ld a, 128  
6aa9 d3 c1		out (portbdata),a  
6aab			  
6aab 06 0a		ld b, 10  
6aad 0e 00		ld c, 0       ; current clock toggle  
6aaf			  
6aaf			.colscan:  
6aaf			  
6aaf			; set current column  
6aaf			; disable clock enable and set clock low  
6aaf			  
6aaf			;ld a, 0  
6aaf			;out (portbdata),a  
6aaf			  
6aaf			; For each column scan for switches  
6aaf			  
6aaf c5			push bc  
6ab0 21 89 fb		ld hl, keyscan_scancol  
6ab3 cd bc 6b		call .rowscan  
6ab6 c1			pop bc  
6ab7			  
6ab7			  
6ab7			; get back current column  
6ab7			  
6ab7			; translate the row scan  
6ab7			  
6ab7			;   
6ab7			; row 1  
6ab7			  
6ab7 78			ld a,b  
6ab8			  
6ab8 21 fc fb		LD   hl, keyscan_table_row1+10  
6abb			  
6abb cd 1b 0d		call subafromhl  
6abe			;call addatohl  
6abe			  
6abe 11 89 fb		ld de, keyscan_scancol  
6ac1			  
6ac1 1a			ld a,(de)  
6ac2 77			ld (hl),a  
6ac3			  
6ac3			  
6ac3			  
6ac3			  
6ac3			; row 2  
6ac3			  
6ac3 78			ld a,b  
6ac4			  
6ac4 21 f1 fb		LD   hl, keyscan_table_row2+10  
6ac7			  
6ac7			;call addatohl  
6ac7 cd 1b 0d		call subafromhl  
6aca			  
6aca			  
6aca 11 8a fb		ld de, keyscan_scancol+1  
6acd			  
6acd 1a			ld a,(de)  
6ace 77			ld (hl),a  
6acf			  
6acf			  
6acf			; row 3  
6acf			  
6acf 78			ld a,b  
6ad0			  
6ad0 21 e6 fb		LD   hl, keyscan_table_row3+10  
6ad3			  
6ad3			;call addatohl  
6ad3 cd 1b 0d		call subafromhl  
6ad6			  
6ad6 11 8b fb		ld de, keyscan_scancol+2  
6ad9			  
6ad9 1a			ld a,(de)  
6ada 77			ld (hl),a  
6adb			  
6adb			  
6adb			  
6adb			; row 4  
6adb			  
6adb 78			ld a,b  
6adc			  
6adc 21 db fb		LD   hl, keyscan_table_row4+10  
6adf			  
6adf			;call addatohl  
6adf cd 1b 0d		call subafromhl  
6ae2			  
6ae2 11 8c fb		ld de, keyscan_scancol+3  
6ae5			  
6ae5 1a			ld a,(de)  
6ae6 77			ld (hl),a  
6ae7			  
6ae7			; row 5  
6ae7			  
6ae7 78			ld a,b  
6ae8			  
6ae8 21 d0 fb		LD   hl, keyscan_table_row5+10  
6aeb			  
6aeb			;call addatohl  
6aeb cd 1b 0d		call subafromhl  
6aee			  
6aee 11 8d fb		ld de, keyscan_scancol+4  
6af1			  
6af1 1a			ld a,(de)  
6af2 77			ld (hl),a  
6af3			  
6af3			; handshake next column  
6af3			  
6af3			  
6af3 3e 40		ld a, 64  
6af5 d3 c1		out (portbdata),a  
6af7			  
6af7 3e 00		ld a, 0  
6af9 d3 c1		out (portbdata),a  
6afb			  
6afb			; toggle clk and move to next column  
6afb			;ld a, 64  
6afb			;cp c  
6afb			;  
6afb			;jr z, .coltoglow  
6afb			;ld c, a  
6afb			;jr .coltog  
6afb			;.coltoglow:  
6afb			;ld c, 0  
6afb			;.coltog:  
6afb			;ld a, c  
6afb			;out (portbdata),a  
6afb			  
6afb 10 b2		djnz .colscan  
6afd			  
6afd 3e 0a		ld a,10  
6aff 21 f2 fb		LD   hl, keyscan_table_row1  
6b02 cd 09 0d		call addatohl  
6b05 3e 00		ld a, 0  
6b07 77			ld (hl), a  
6b08			  
6b08			  
6b08 3e 0a		ld a,10  
6b0a 21 e7 fb		LD   hl, keyscan_table_row2  
6b0d cd 09 0d		call addatohl  
6b10 3e 00		ld a, 0  
6b12 77			ld (hl), a  
6b13			  
6b13 3e 0a		ld a,10  
6b15 21 dc fb		LD   hl, keyscan_table_row3  
6b18 cd 09 0d		call addatohl  
6b1b 3e 00		ld a, 0  
6b1d 77			ld (hl), a  
6b1e			  
6b1e 3e 0a		ld a,10  
6b20 21 d1 fb		LD   hl, keyscan_table_row4  
6b23 cd 09 0d		call addatohl  
6b26 3e 00		ld a, 0  
6b28 77			ld (hl), a  
6b29			  
6b29 3e 0a		ld a,10  
6b2b 21 c6 fb		LD   hl, keyscan_table_row5  
6b2e cd 09 0d		call addatohl  
6b31 3e 00		ld a, 0  
6b33 77			ld (hl), a  
6b34			  
6b34			if DEBUG_KEY_MATRIX  
6b34			  
6b34			; Display text on first line  
6b34			            LD   A, kLCD_Line1  
6b34			            CALL fLCD_Pos       ;Position cursor to location in A  
6b34			            LD   DE, keyscan_table_row1  
6b34			            ;LD   DE, MsgHello  
6b34			            CALL fLCD_Str       ;Display string pointed to by DE  
6b34			  
6b34			; Display text on second line  
6b34			            LD   A, kLCD_Line2  
6b34			            CALL fLCD_Pos       ;Position cursor to location in A  
6b34			            LD   DE, keyscan_table_row2  
6b34			            CALL fLCD_Str       ;Display string pointed to by DE  
6b34			            LD   A, kLCD_Line3  
6b34			            CALL fLCD_Pos       ;Position cursor to location in A  
6b34			            LD   DE, keyscan_table_row3  
6b34			            CALL fLCD_Str       ;Display string pointed to by DE  
6b34			            LD   A, kLCD_Line4  
6b34			            CALL fLCD_Pos       ;Position cursor to location in A  
6b34			            LD   DE, keyscan_table_row4  
6b34			            CALL fLCD_Str       ;Display string pointed to by DE  
6b34			            LD   A, kLCD_Line4+10  
6b34			            CALL fLCD_Pos       ;Position cursor to location in A  
6b34			            LD   DE, keyscan_table_row5  
6b34			            CALL fLCD_Str       ;Display string pointed to by DE  
6b34			  
6b34			;call delay250ms  
6b34				jp matrix  
6b34			endif  
6b34 c9			ret  
6b35			  
6b35			; using decade counter....  
6b35			  
6b35			  
6b35			; TODO reset decade counter to start of scan  
6b35			  
6b35			; reset 15  
6b35			; clock 14  
6b35			; ce 13  
6b35			  
6b35			; 1 - q5  
6b35			; 2 - q1  
6b35			; 3 - q0  
6b35			; 4 - q2  
6b35			; 5 - q6  
6b35			; 6 - q7  
6b35			; 7 - q3  
6b35			; 8 - vss  
6b35			; 9 - q8  
6b35			; 10 - q4  
6b35			; 11 - q9  
6b35			; 12 - cout  
6b35			; 16 - vdd  
6b35			  
6b35			; clock      ce       reset     output  
6b35			; 0          x        0         n  
6b35			; x          1        0         n  
6b35			; x          x        1         q0  
6b35			; rising     0        0         n+1  
6b35			; falling    x        0         n  
6b35			; x          rising   0         n  
6b35			; 1          falling  0         x+1  
6b35			;  
6b35			; x = dont care, if n < 5 carry = 1 otherwise 0  
6b35			  
6b35			;   
6b35			; reset   
6b35			; 13=0, 14=0, 15=1 .. 15=0  
6b35			;  
6b35			; handshake line  
6b35			; 14=1.... read line 14=0  
6b35			  
6b35			  
6b35			  
6b35			  
6b35			  
6b35			; TODO hand shake clock for next column scan  
6b35			; TODO detect each row  
6b35			  
6b35			  
6b35			  
6b35			  
6b35			; reset 128  
6b35			; clock 64  
6b35			; ce 32  
6b35			  
6b35			  
6b35			.cyclestart:  
6b35			  
6b35			; reset counter  
6b35 3e 80		ld a, 128  
6b37 d3 c1		out (portbdata),a  
6b39			  
6b39			; loop leds  
6b39 06 0a		ld b,10  
6b3b			  
6b3b			.cycle1:  
6b3b c5			push bc  
6b3c 3e 00		ld a, 0  
6b3e d3 c1		out (portbdata),a  
6b40 cd 49 0a		call delay250ms  
6b43			  
6b43 3e 40		ld a, 64  
6b45 d3 c1		out (portbdata),a  
6b47 cd 49 0a		call delay250ms  
6b4a			  
6b4a 3e 00		ld a, 0  
6b4c d3 c1		out (portbdata),a  
6b4e cd 49 0a		call delay250ms  
6b51			  
6b51 c1			pop bc  
6b52 10 e7		djnz .cycle1  
6b54			  
6b54			  
6b54 18 df		jr .cyclestart  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			; map matrix key held to char on face of key  
6b56			  
6b56			;.mtocold:  
6b56			;  
6b56			;  
6b56			;; reset counter  
6b56			;ld a, 128  
6b56			;out (portbdata),a  
6b56			;  
6b56			;  
6b56			;; scan keyboard row 1  
6b56			;ld a, 0  
6b56			;out (portbdata),a  
6b56			;;ld a, 64  
6b56			;;out (portbdata),a  
6b56			;  
6b56			;  
6b56			;	ld a, 128  
6b56			;	ld hl, keyscan_table  
6b56			;	call .rowscan  
6b56			;  
6b56			;;ld a, 0  
6b56			;;out (portbdata),a  
6b56			;ld a, 64  
6b56			;out (portbdata),a  
6b56			;  
6b56			;	ld a, 64  
6b56			;	ld hl, keyscan_table+key_cols  
6b56			;	call .rowscan  
6b56			;  
6b56			;ld a, 0  
6b56			;out (portbdata),a  
6b56			;;ld a, 64  
6b56			;;out (portbdata),a  
6b56			;	ld a, 32  
6b56			;	ld hl, keyscan_table+(key_cols*2)  
6b56			;	call .rowscan  
6b56			;  
6b56			;  
6b56			;;ld a, 0  
6b56			;;out (portbdata),a  
6b56			;ld a, 64  
6b56			;out (portbdata),a  
6b56			;  
6b56			;	ld a, 16  
6b56			;	ld hl, keyscan_table+(key_cols*3)  
6b56			;	call .rowscan  
6b56			;  
6b56			;  
6b56			;	; flag if key D is held down and remove from reporting  
6b56			;	ld bc, .key_map_fd    
6b56			;	ld hl, keyscan_table  
6b56			;	ld de, key_fd  
6b56			;	call .key_shift_hold  
6b56			;	cp 255  
6b56			;	jr z, .cinmap  
6b56			;	; flag if key C is held down and remove from reporting  
6b56			;	ld bc, .key_map_fc    
6b56			;	ld hl, keyscan_table+key_cols  
6b56			;	ld de, key_fc  
6b56			;	call .key_shift_hold  
6b56			;	cp 255  
6b56			;	jr z, .cinmap  
6b56			;	; flag if key B is held down and remove from reporting  
6b56			;	ld bc, .key_map_fb    
6b56			;	ld hl, keyscan_table+(key_cols*2)  
6b56			;	ld de, key_fb  
6b56			;	call .key_shift_hold  
6b56			;	cp 255  
6b56			;	jr z, .cinmap  
6b56			;	; flag if key A is held down and remove from reporting  
6b56			;	ld bc, .key_map_fa    
6b56			;	ld hl, keyscan_table+(key_cols*3)  
6b56			;	ld de, key_fa  
6b56			;	call .key_shift_hold  
6b56			;	cp 255  
6b56			;	jr z, .cinmap  
6b56			;  
6b56			;	ld de, .matrix_to_char  
6b56			;  
6b56			;  
6b56			;.cinmap:   
6b56			;	if DEBUG_KEY  
6b56			;            LD   A, kLCD_Line4  
6b56			;            CALL fLCD_Pos       ;Position cursor to location in A  
6b56			;		push de  
6b56			;            LD   DE, keyscan_table  
6b56			;            CALL fLCD_Str       ;Display string pointed to by DE  
6b56			;		pop de  
6b56			;	endif  
6b56			  
6b56				; scan key matrix table for any held key  
6b56			  
6b56				; de holds either the default matrix or one selected above  
6b56			  
6b56			;	ld hl, keyscan_table  
6b56			;	ld b,key_cols*key_rows  
6b56			;  
6b56			;.cin1:	ld a,(hl)  
6b56			;	cp '#'  
6b56			;	jr z, .cinhit  
6b56			;	inc hl  
6b56			;	inc de  
6b56			;	dec b  
6b56			;	jr nz, .cin1  
6b56			;	; no key found held  
6b56			;	ld a,0  
6b56			;	ret  
6b56			;.cinhit: push de  
6b56			;	pop hl  
6b56			;	ld a,(hl)  
6b56			;	ret  
6b56			  
6b56			; flag a control key is held   
6b56			; hl is key pin, de is flag indicator  
6b56			  
6b56			;.key_shift_hold:  
6b56			;	push bc  
6b56			;	ld a, 1  
6b56			;	ld (cursor_shape),a  
6b56			;	ld b, 0  
6b56			;	ld a, (hl)  
6b56			;	cp '.'  
6b56			;	jr z, .key_shift1  
6b56			;	ld b, 255  
6b56			;	ld a, '+'    ; hide key from later scans  
6b56			;	ld (hl),a  
6b56			;	ld a, 2  
6b56			;	ld (cursor_shape),a  
6b56			;.key_shift1:  
6b56			;	; write flag indicator  
6b56			;	ld a,b  
6b56			;	ld (de),a  
6b56			;  
6b56			;	pop de    ; de now holds the key map ptr  
6b56			;	ret  
6b56			  
6b56				  
6b56				  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			;	push hl  
6b56			;	push de  
6b56			;	push bc  
6b56			;	call keyscan  
6b56			;	; map key matrix to ascii value of key face  
6b56			;  
6b56			;	ld hl, key_face_map  
6b56			;	ld de, keyscan_table  
6b56			;  
6b56			;	; get how many keys to look at  
6b56			;	ld b, keyscan_table_len  
6b56			;	  
6b56			;  
6b56			;	; at this stage fall out on first key hit  
6b56			;	; TODO handle multiple key press  
6b56			;  
6b56			;map1:	ld a,(hl)  
6b56			;	cp '#'  
6b56			;	jr z, keyhit  
6b56			;	inc hl  
6b56			;	inc de  
6b56			;	dec b  
6b56			;	jr nz, map1  
6b56			;nohit:	ld a, 0  
6b56			;	jr keydone  
6b56			;keyhit: push de  
6b56			;	pop hl  
6b56			;	ld a,(hl)  
6b56			;keydone:  
6b56			;	push bc  
6b56			;	push de  
6b56			; 	push hl  
6b56			;	ret   
6b56			;  
6b56			  
6b56			  
6b56			  
6b56			  
6b56			; scan physical key matrix  
6b56			  
6b56			  
6b56			;keyscan:  
6b56			;  
6b56			;; for each key_row use keyscanr bit mask for out  
6b56			;; then read in for keyscanc bitmask  
6b56			;; save result of row scan to keyscantable  
6b56			;  
6b56			;; scan keyboard row 1  
6b56			;  
6b56			;	ld b, key_rows  
6b56			;	ld hl, key_scanr  
6b56			;	ld de, keyscan_table  
6b56			;  
6b56			;rowloop:  
6b56			;  
6b56			;	ld a,(hl)		; out bit mask to energise keyboard row  
6b56			;	call rowscan  
6b56			;	inc hl  
6b56			;	dec b  
6b56			;	jr nz, rowloop  
6b56			;  
6b56			;	ret  
6b56			;  
6b56			;  
6b56			;; pass a out bitmask, b row number  
6b56			;arowscan:   
6b56			;	push bc  
6b56			;  
6b56			;	ld d, b  
6b56			;  
6b56			;	; calculate buffer location for this row  
6b56			;  
6b56			;	ld hl, keyscan_table	  
6b56			;kbufr:  ld e, key_cols  
6b56			;kbufc:	inc hl  
6b56			;	dec e  
6b56			;	jr nz, kbufc  
6b56			;	dec d  
6b56			;	jr nz, kbufr  
6b56			;  
6b56			;	; energise row and read columns  
6b56			;  
6b56			;	out (portbdata),a  
6b56			;	in a,(portbdata)  
6b56			;	ld c,a  
6b56			;  
6b56			;  
6b56			;	; save buffer loc  
6b56			;  
6b56			;	ld (keybufptr), hl  
6b56			;  
6b56			;	ld hl, key_scanc  
6b56			;	ld d, key_cols  
6b56			;  
6b56			;	; for each column check each bit mask  
6b56			;  
6b56			;colloop:  
6b56			;	  
6b56			;  
6b56			;	; reset flags for the row   
6b56			;  
6b56			;	ld b,'.'  
6b56			;	and (hl)  
6b56			;	jr z, maskskip  
6b56			;	ld b,'#'  
6b56			;maskskip:  
6b56			;	; save  key state  
6b56			;	push hl  
6b56			;	ld hl, (keybufptr)  
6b56			;	ld (hl), b  
6b56			;	inc hl  
6b56			;	ld (keybufptr), hl  
6b56			;  
6b56			;	; move to next bit mask  
6b56			;	pop hl  
6b56			;	inc hl  
6b56			;  
6b56			;	dec d  
6b56			;	jr nz, colloop  
6b56			;  
6b56			;	ret  
6b56			;  
6b56			;  
6b56			;;  
6b56			; lcd functions  
6b56			;  
6b56			;  
6b56			  
6b56			;if DEBUG_KEY_MATRIX  
6b56			  
6b56			; test function to display hardware view of matrix state  
6b56			  
6b56			matrixold:  
6b56			  
6b56			  
6b56			  
6b56			; reset counter  
6b56 3e 80		ld a, 128  
6b58 d3 c1		out (portbdata),a  
6b5a			; scan keyboard row 1  
6b5a 3e 00		ld a, 0  
6b5c d3 c1		out (portbdata),a  
6b5e			;ld a, 64  
6b5e			;out (portbdata),a  
6b5e 3e 80			ld a, 128  
6b60 21 f2 fb			ld hl, keyscan_table_row1  
6b63 cd bc 6b			call .rowscan  
6b66			  
6b66			;ld a, 0  
6b66			;out (portbdata),a  
6b66 3e 40		ld a, 64  
6b68 d3 c1		out (portbdata),a  
6b6a 3e 40			ld a, 64  
6b6c 21 e7 fb			ld hl, keyscan_table_row2  
6b6f cd bc 6b			call .rowscan  
6b72			  
6b72 3e 00		ld a, 0  
6b74 d3 c1		out (portbdata),a  
6b76			;ld a, 64  
6b76			;out (portbdata),a  
6b76 3e 20			ld a, 32  
6b78 21 dc fb			ld hl, keyscan_table_row3  
6b7b cd bc 6b			call .rowscan  
6b7e			  
6b7e			;ld a, 0  
6b7e			;out (portbdata),a  
6b7e 3e 40		ld a, 64  
6b80 d3 c1		out (portbdata),a  
6b82 3e 10			ld a, 16  
6b84 21 d1 fb			ld hl, keyscan_table_row4  
6b87 cd bc 6b			call .rowscan  
6b8a			  
6b8a			; Display text on first line  
6b8a 3e 00		            LD   A, kLCD_Line1  
6b8c cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b8f 11 f2 fb		            LD   DE, keyscan_table_row1  
6b92			            ;LD   DE, MsgHello  
6b92 cd e6 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b95			  
6b95			; Display text on second line  
6b95 3e 28		            LD   A, kLCD_Line2  
6b97 cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b9a 11 e7 fb		            LD   DE, keyscan_table_row2  
6b9d cd e6 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0 3e 50		            LD   A, kLCD_Line3  
6ba2 cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6ba5 11 dc fb		            LD   DE, keyscan_table_row3  
6ba8 cd e6 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6bab 3e 78		            LD   A, kLCD_Line4  
6bad cd c4 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6bb0 11 d1 fb		            LD   DE, keyscan_table_row4  
6bb3 cd e6 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6bb6			  
6bb6 cd 49 0a			call delay250ms  
6bb9 c3 a7 6a			jp matrix  
6bbc			  
6bbc			; pass de as row display flags  
6bbc			.rowscan:   
6bbc			;	out (portbdata),a  
6bbc db c1			in a,(portbdata)  
6bbe 4f				ld c,a  
6bbf				; reset flags for the row   
6bbf 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6bc1 e6 01			and 1  
6bc3 28 02			jr z, .p1on  
6bc5 06 23			ld b,'#'  
6bc7			.p1on:  
6bc7 70				ld (hl), b  
6bc8 23				inc hl  
6bc9			  
6bc9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6bcb 79				ld a,c  
6bcc e6 02			and 2  
6bce			;	bit 0,a  
6bce 28 02			jr z, .p2on  
6bd0 06 23			ld b,'#'  
6bd2			.p2on:  
6bd2 70				ld (hl), b  
6bd3 23				inc hl  
6bd4			;  
6bd4 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6bd6 79				ld a,c  
6bd7 e6 04			and 4  
6bd9			;;	bit 0,a  
6bd9 28 02			jr z, .p3on  
6bdb 06 23			ld b,'#'  
6bdd			.p3on:  
6bdd 70				ld (hl), b  
6bde 23				inc hl  
6bdf			;;  
6bdf 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6be1			;;	bit 0,a  
6be1 79				ld a,c  
6be2 e6 08			and 8  
6be4 28 02			jr z, .p4on  
6be6 06 23			ld b,'#'  
6be8			.p4on:  
6be8 70				ld (hl), b  
6be9 23				inc hl  
6bea			  
6bea 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6bec			;;	bit 0,a  
6bec 79				ld a,c  
6bed e6 10			and 16  
6bef 28 02			jr z, .p5on  
6bf1 06 23			ld b,'#'  
6bf3			.p5on:  
6bf3 70				ld (hl), b  
6bf4 23				inc hl  
6bf5			; zero term  
6bf5 06 00			ld b,0  
6bf7 70				ld (hl), b  
6bf8			  
6bf8 c9			.rscandone: ret  
6bf9			  
6bf9			;addatohl:  
6bf9			;  
6bf9			 ;add   a, l    ; A = A+L  
6bf9			  ;  ld    l, a    ; L = A+L  
6bf9			   ; adc   a, h    ; A = A+L+H+carry  
6bf9			   ; sub   l       ; A = H+carry  
6bf9			   ; ld    h, a    ; H = H+carry  
6bf9			  
6bf9			;ret  
6bf9			; eof  
# End of file firmware_key_5x10.asm
6bf9			;include "firmware_key_4x10.asm" 
6bf9			 
6bf9			heap_size:    equ heap_end - heap_start 
6bf9			;eof 
# End of file os_mega.asm
6bf9
