# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 27 1a			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 offsets for settings  
0003			  
0003			; if set then skip prompt for start up and accept all  
0003			  
0003			STORE_0_QUICKSTART: equ $25  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0003			  
0003			hardware_config: equ key_face_held - 10  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_config - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003				  
0003			  
0003					;ld a, 0  
0003					;ld (hardware_diag), a  
0003			  
0003					; clear all the buffers  
0003			  
0003 21 13 fa				ld hl, display_fb1  
0006 22 cf f8				ld (display_fb_active), hl  
0009			  
0009 cd a9 0b				call clear_display  
000c			  
000c 21 d1 f8				ld hl, display_fb2  
000f 22 cf f8				ld (display_fb_active), hl  
0012			  
0012 cd a9 0b				call clear_display  
0015			  
0015					; init primary frame buffer area  
0015 21 b4 fa				ld hl, display_fb0  
0018 22 cf f8				ld (display_fb_active), hl  
001b			  
001b cd a9 0b				call clear_display  
001e			  
001e			  
001e cd b3 67				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0021			  
0021 cd 4a 6a			call key_init  
0024 cd a2 01			call storage_init  
0027			  
0027				; setup malloc functions  
0027			  
0027				if MALLOC_1  
0027 cd 80 12				call  heap_init  
002a				endif  
002a				if MALLOC_4  
002a					call  heap_init  
002a				endif  
002a			  
002a				; init sound hardware if present  
002a			  
002a				if SOUND_ENABLE  
002a cd 3d 14				call sound_init  
002d				endif  
002d			  
002d				; lcd test sequence  
002d					  
002d cd cc 0b			call update_display  
0030 cd 26 0b			call delay1s  
0033 3e 2b			ld a,'+'  
0035 cd ae 0b			call fill_display  
0038 cd cc 0b			call update_display  
003b cd 26 0b			call delay1s  
003e 3e 2a			ld a,'*'  
0040 cd ae 0b			call fill_display  
0043 cd cc 0b			call update_display  
0046 cd 26 0b			call delay1s  
0049 3e 2d			ld a,'-'  
004b cd ae 0b			call fill_display  
004e cd cc 0b			call update_display  
0051 cd 26 0b			call delay1s  
0054			  
0054			; boot splash screen  
0054			if display_cols == 20	  
0054			        ld a, display_row_1    
0054			else  
0054 3e 0a		        ld a, display_row_1 +10   
0056			endif  
0056 11 5a 19			ld de, prom_bootmsg  
0059 cd bc 0b			call str_at_display  
005c cd cc 0b			call update_display  
005f			  
005f			  
005f cd 26 0b			call delay1s  
0062 cd 26 0b			call delay1s  
0065			if display_cols == 20	  
0065			            LD   A, display_row_3+2  
0065			else  
0065 3e 5c		            LD   A, display_row_3+12  
0067			endif  
0067 11 6f 19			ld de, prom_bootmsg1  
006a cd bc 0b			call str_at_display  
006d cd cc 0b			call update_display  
0070 cd 26 0b			call delay1s  
0073 cd 26 0b			call delay1s  
0076			  
0076			;	ld a, display_row_4+3  
0076			;	ld de, bootmsg2  
0076			;	call str_at_display  
0076			;	call update_display  
0076			;	call delay1s  
0076			;	call delay1s  
0076			  
0076			; debug mark setup  
0076			  
0076 3e 5f		ld a, '_'  
0078 32 6e fb		ld (debug_mark),a  
007b 32 6f fb		ld (debug_mark+1),a  
007e 32 70 fb		ld (debug_mark+2),a  
0081 3e 00		ld a,0  
0083 32 71 fb		ld (debug_mark+3),a  
0086			  
0086 c9					ret  
0087			  
0087			  
0087			;bootmsg2:	db "Firmware v0.1",0  
0087			  
0087			; a 4x20 lcd  
0087			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
0087			  
0087			;if display_cols == 20  
0087			;	include "firmware_lcd_4x20.asm"  
0087			;endif  
0087			  
0087			;if display_cols == 40  
0087			;	include "firmware_lcd_4x40.asm"  
0087			;endif  
0087			  
0087			;  
0087			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
0087			; TODO abstract the bit bang video out interface for dual display  
0087			; TODO wire video out to tx pin on rc2014 bus  
0087			  
0087			; must supply cin, and cin_wait for low level hardware abstraction   
0087			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
0087			; test scancode  
0087			  
0087			;;;;;  
0087			;;;  
0087			; Moved out to mini and maxi versions  
0087			;  
0087			; include "firmware_key_4x4.asm"  
0087			; using existing 4 wire x 4 resistor array for input  
0087			;include "firmware_key_4x10.asm"  
0087			; need to mod the board for 5 rows due to resistor array  
0087			;include "firmware_key_5x10.asm"  
0087			  
0087			; storage hardware interface  
0087			  
0087			; use microchip serial eeprom for storage  
0087			  
0087			  
0087			if STORAGE_SE  
0087				include "firmware_spi.asm"  
0087			; my spi protocol (used by storage) 
0087			 
0087			; SPI pins 
0087			 
0087			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
0087			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
0087			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
0087			 
0087			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
0087			; chip pin 4 gnd 
0087			 
0087			 
0087			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
0087			SPI_CE1: equ 1      ;    port a1 pin 14  
0087			SPI_CE2: equ 2      ;    port a2 pin pin 13 
0087			SPI_CE3: equ 3      ; port    a3 pin pin 12 
0087			SPI_CE4: equ 4      ; port a4     pin 10 
0087			 
0087			; active low AND masks 
0087			 
0087			;SPI_CE0_MASK: equ    255-1 
0087			;SPI_CE1_MASK: equ   255-2 
0087			;SPI_CE2_MASK: equ   255-4 
0087			;SPI_CE3_MASK: equ   255-8 
0087			;SPI_CE4_MASK: equ   255-16 
0087			SPI_CE_HIGH:  equ 255 
0087			 
0087			 
0087			 
0087			 
0087			; TODO store port id for spi device ie dev c 
0087			; TODO store pin for SO 
0087			; TODO store pin for SI 
0087			; TODO store pin for SCLK 
0087			 
0087			; 
0087			 
0087			; ensure that spi bus is in a stable state with default pins  
0087			 
0087			se_stable_spi:   
0087			 
0087				 ; set DI high, CE high , SCLK low 
0087				;ld a, SPI_DI | SPI_CE0 
0087 3e 07			ld a, SPI_DI  
0089 cd 5d 01			call spi_ce_high 
008c d3 80			 out (storage_adata),a 
008e 32 40 f8			ld (spi_portbyte),a 
0091			 
0091				if DEBUG_SPI 
0091					push hl 
0091					ld l, a 
0091					DMARK "SPI" 
0091					CALLMONITOR 
0091					pop hl 
0091				endif 
0091 c9				ret 
0092			 
0092			; byte to send in a 
0092			 
0092			spi_send_byte: 
0092				; save byte to send for bit mask shift out 
0092 4f			        ld c,a 
0093 3a 40 f8			ld a,(spi_portbyte) 
0096				  
0096				; clock out	each bit of the byte msb first 
0096			 
0096 06 08			ld b, 8 
0098			.ssb1: 
0098				; clear so bit  
0098 cb bf			res SPI_DI, a 
009a cb 11			rl c 
009c				; if bit 7 is set then carry is set 
009c 30 02			jr nc, .ssb2 
009e cb ff			set SPI_DI,a 
00a0			.ssb2:  ; output bit to ensure it is stable 
00a0 d3 80			out (storage_adata),a 
00a2 00				nop 
00a3				; clock bit high 
00a3 cb ef			set SPI_SCLK,a 
00a5 d3 80			out (storage_adata),a 
00a7 00				nop 
00a8				; then low 
00a8 cb af			res SPI_SCLK,a 
00aa d3 80			out (storage_adata),a 
00ac 00				nop 
00ad 10 e9			djnz .ssb1 
00af			 
00af 32 40 f8			ld (spi_portbyte),a 
00b2 c9				ret 
00b3			 
00b3			; TODO low level get byte into A on spi 
00b3			 
00b3			spi_read_byte:  
00b3			 
00b3				; save byte to send for bit mask shift out 
00b3 0e 00		    ld c,0 
00b5 3a 40 f8			ld a,(spi_portbyte) 
00b8				  
00b8				; clock out	each bit of the byte msb first 
00b8			 
00b8			 
00b8				; clock bit high 
00b8 cb ef			set SPI_SCLK,a 
00ba d3 80			out (storage_adata),a 
00bc 00				nop 
00bd			 
00bd			    ; read DO  
00bd			 
00bd cb f9		    set 7,c 
00bf db 80			in a,(storage_adata) 
00c1 cb 77		    bit SPI_DO,a 
00c3 20 02		    jr nz, .b7 
00c5 cb b9		    res 7,c 
00c7			.b7: 
00c7				; then low 
00c7 cb af			res SPI_SCLK,a 
00c9 d3 80			out (storage_adata),a 
00cb 00				nop 
00cc			     
00cc			 
00cc				; clock bit high 
00cc cb ef			set SPI_SCLK,a 
00ce d3 80			out (storage_adata),a 
00d0 00				nop 
00d1			 
00d1			    ; read DO  
00d1			 
00d1 cb f1		    set 6,c 
00d3 db 80			in a,(storage_adata) 
00d5 cb 77		    bit SPI_DO,a 
00d7 20 02		    jr nz, .b6 
00d9 cb b1		    res 6,c 
00db			.b6: 
00db				; then low 
00db cb af			res SPI_SCLK,a 
00dd d3 80			out (storage_adata),a 
00df 00				nop 
00e0			 
00e0				; clock bit high 
00e0 cb ef			set SPI_SCLK,a 
00e2 d3 80			out (storage_adata),a 
00e4 00				nop 
00e5			 
00e5			 
00e5			    ; read DO  
00e5			 
00e5 cb e9		    set 5,c 
00e7 db 80			in a,(storage_adata) 
00e9 cb 77		    bit SPI_DO,a 
00eb 20 02		    jr nz, .b5 
00ed cb a9		    res 5,c 
00ef			.b5: 
00ef				; then low 
00ef cb af			res SPI_SCLK,a 
00f1 d3 80			out (storage_adata),a 
00f3 00				nop 
00f4				; clock bit high 
00f4 cb ef			set SPI_SCLK,a 
00f6 d3 80			out (storage_adata),a 
00f8 00				nop 
00f9			 
00f9			    ; read DO  
00f9			 
00f9 cb e1		    set 4,c 
00fb db 80			in a,(storage_adata) 
00fd cb 77		    bit SPI_DO,a 
00ff 20 02		    jr nz, .b4 
0101 cb a1		    res 4,c 
0103			.b4: 
0103				; then low 
0103 cb af			res SPI_SCLK,a 
0105 d3 80			out (storage_adata),a 
0107 00				nop 
0108				; clock bit high 
0108 cb ef			set SPI_SCLK,a 
010a d3 80			out (storage_adata),a 
010c 00				nop 
010d			 
010d			    ; read DO  
010d			 
010d cb d9		    set 3,c 
010f db 80			in a,(storage_adata) 
0111 cb 77		    bit SPI_DO,a 
0113 20 02		    jr nz, .b3 
0115 cb 99		    res 3,c 
0117			.b3: 
0117				; then low 
0117 cb af			res SPI_SCLK,a 
0119 d3 80			out (storage_adata),a 
011b 00				nop 
011c				; clock bit high 
011c cb ef			set SPI_SCLK,a 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121			 
0121			    ; read DO  
0121			 
0121 cb d1		    set 2,c 
0123 db 80			in a,(storage_adata) 
0125 cb 77		    bit SPI_DO,a 
0127 20 02		    jr nz, .b2 
0129 cb 91		    res 2,c 
012b			.b2: 
012b				; then low 
012b cb af			res SPI_SCLK,a 
012d d3 80			out (storage_adata),a 
012f 00				nop 
0130				; clock bit high 
0130 cb ef			set SPI_SCLK,a 
0132 d3 80			out (storage_adata),a 
0134 00				nop 
0135			 
0135			    ; read DO  
0135			 
0135 cb c9		    set 1,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b1 
013d cb 89		    res 1,c 
013f			.b1: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144				; clock bit high 
0144 cb ef			set SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149			 
0149			    ; read DO  
0149			 
0149 cb c1		    set 0,c 
014b db 80			in a,(storage_adata) 
014d cb 77		    bit SPI_DO,a 
014f 20 02		    jr nz, .b0 
0151 cb 81		    res 0,c 
0153			.b0: 
0153				; then low 
0153 cb af			res SPI_SCLK,a 
0155 d3 80			out (storage_adata),a 
0157 00				nop 
0158			 
0158			 
0158 32 40 f8			ld (spi_portbyte),a 
015b			 
015b			    ; return byte 
015b 79			    ld a,c 
015c			 
015c			 
015c c9				ret 
015d			 
015d			 
015d			 
015d			spi_ce_high: 
015d			 
015d				if DEBUG_SPI_HARD_CE0 
015d			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
015d					ret 
015d			 
015d				endif 
015d			 
015d			 
015d f5				push af 
015e			 
015e				; send direct ce to port b 
015e 3e ff			ld a, 255 
0160 d3 81			out (storage_bdata), a 
0162			 
0162 f1				pop af 
0163			 
0163				; for port a that shares with spi lines AND the mask 
0163			  
0163				if DEBUG_SPI 
0163					push hl 
0163					ld h, a 
0163				endif 
0163			;	ld c, SPI_CE_HIGH 
0163			;	and c 
0163 cb c7			set SPI_CE0, a 
0165 cb cf			set SPI_CE1, a 
0167 cb d7			set SPI_CE2, a 
0169 cb df			set SPI_CE3, a 
016b cb e7			set SPI_CE4, a 
016d			 
016d				if DEBUG_SPI 
016d					ld l, a 
016d					DMARK "CEh" 
016d					CALLMONITOR 
016d					pop hl 
016d				endif 
016d c9				ret 
016e			 
016e			 
016e			spi_ce_low: 
016e			 
016e				if DEBUG_SPI_HARD_CE0 
016e			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
016e					ret 
016e			 
016e				endif 
016e			 
016e c5				push bc 
016f f5				push af 
0170			 
0170				; send direct ce to port b 
0170 3a 42 f8			ld a, (spi_cartdev) 
0173 d3 81			out (storage_bdata), a 
0175			 
0175			 
0175			 
0175				; for port a that shares with spi lines AND the mask 
0175			 
0175 3a 3f f8			ld a, (spi_device)  
0178 4f				ld c, a 
0179			 
0179 f1				pop af 
017a			 
017a				; detect CEx 
017a			 
017a				if DEBUG_SPI 
017a					push hl 
017a					ld h, a 
017a				endif 
017a			 
017a cb 41			bit SPI_CE0, c 
017c 20 04			jr nz, .cel1 
017e cb 87			res SPI_CE0, a 
0180 18 1e			jr .celn 
0182			.cel1: 
0182 cb 49			bit SPI_CE1, c 
0184 20 04			jr nz, .cel2 
0186 cb 8f			res SPI_CE1, a 
0188 18 16			jr .celn 
018a			.cel2: 
018a cb 51			bit SPI_CE2, c 
018c 20 04			jr nz, .cel3 
018e cb 97			res SPI_CE2, a 
0190 18 0e			jr .celn 
0192			.cel3: 
0192 cb 59			bit SPI_CE3, c 
0194 20 04			jr nz, .cel4 
0196 cb 9f			res SPI_CE3, a 
0198 18 06			jr .celn 
019a			.cel4: 
019a cb 61			bit SPI_CE4, c 
019c 20 02			jr nz, .celn 
019e cb a7			res SPI_CE4, a 
01a0			.celn: 
01a0			 
01a0			 
01a0			 
01a0			;	add c 
01a0			 
01a0				if DEBUG_SPI 
01a0					ld l, a 
01a0					DMARK "CEl" 
01a0					CALLMONITOR 
01a0					pop hl 
01a0				endif 
01a0 c1				pop bc 
01a1 c9				ret 
01a2			 
01a2			 
01a2			 
01a2			; eof 
01a2			 
01a2			 
01a2			 
01a2			 
01a2			 
# End of file firmware_spi.asm
01a2				include "firmware_seeprom.asm"  
01a2			; 
01a2			; persisent storage interface via microchip serial eeprom 
01a2			 
01a2			; port a pio 2 
01a2			; pa 7 - si 
01a2			; pa 6 - sclk  
01a2			; pa 5 - so 
01a2			; pa 4 - cs 
01a2			; pa 3 - cs 
01a2			; pa 2 - cs 
01a2			; pa 1 - cs 
01a2			; pa 0 - cs 
01a2			; 
01a2			; TODO get block 
01a2			; TODO save block 
01a2			; TODO load file 
01a2			; TODO save file 
01a2			; TODO get dir  
01a2			 
01a2			;  
01a2			storage_adata: equ Device_C    ; device c port a - onboard storage 
01a2			storage_actl: equ Device_C+2     ; device c port a 
01a2			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01a2			storage_bctl: equ Device_C+3     ; device c port b 
01a2			 
01a2			 
01a2			; TODO move these to hardware driver file 
01a2			 
01a2			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01a2			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01a2			; storage bank file system format 
01a2			; 
01a2			; first page of bank: 
01a2			; 	addr 0 - status check 
01a2			;       addr 1 - write protect flag 
01a2			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01a2			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01a2			;         TODO see if scanning whole of for available next file id is fast enough 
01a2			;	addr 4 > zero term string of bank label 
01a2			; 
01a2			;        
01a2			;  
01a2			; first page of any file: 
01a2			;      byte 0 - file id  
01a2			;      byte 1-17 - fixed file name  
01a2			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01a2			; 
01a2			; other pages of any file: 
01a2			;      byte 0 - file id 
01a2			;      byte 1> - file data 
01a2			; 
01a2			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01a2			;  
01a2			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01a2			 
01a2			 
01a2			;storage_so_bit: 5 
01a2			;storage_si_bit: 7 
01a2			;storage_sclk_bit: 6 
01a2			  
01a2			 
01a2			; init storage pio 
01a2			 
01a2			storage_init: 
01a2			 
01a2 3e cf		            LD   A, 11001111b 
01a4 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01a6 3e 00		            LD   A, 00000000b 
01a8 cb f7			set SPI_DO,a 
01aa			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01aa d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01ac			 
01ac 3e cf		            LD   A, 11001111b 
01ae d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01b0 3e 00		            LD   A, 00000000b 
01b2 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01b4			 
01b4				; set all external spi devices off 
01b4 3e 00			ld a, 0 
01b6 32 3f f8			ld (spi_device), a 
01b9 32 42 f8			ld (spi_cartdev), a 
01bc			 
01bc					; ensure the spi bus is in a default stable state 
01bc cd 87 00				call se_stable_spi 
01bf			 
01bf			; TODO scan spi bus and gather which storage banks are present 
01bf			 
01bf			; populate store_bank_active  
01bf			; for each ce line activate and attempt to write first byte of bank and read back 
01bf			; if zero is returned then bank is empty 
01bf			;   
01bf			; 
01bf			 
01bf					; init file extent cache to save on slow reads 
01bf			 
01bf			;	ld hl, store_filecache 
01bf			;	ld de, 0 
01bf			;	ld hl,(de)	 
01bf			 
01bf			 
01bf c9			    ret 
01c0			 
01c0			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01c0			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01c0			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01c0			 
01c0			; INSTRUCTION SET 
01c0			; READ 0000 0011 Read data from memory array beginning at selected address 
01c0			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01c0			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01c0			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01c0			; RDSR 0000 0101 Read STATUS register 
01c0			; WRSR 0000 0001 Write STATUS register 
01c0			; PE 0100 0010 Page Erase – erase one page in memory array 
01c0			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01c0			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01c0			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01c0			 
01c0			; TODO send byte steam for page without setting the address for every single byte 
01c0			; TODO read byte  
01c0			 
01c0			; byte in a 
01c0			; address in hl  
01c0			se_writebyte: 
01c0			        
01c0			    ;   ld c, a 
01c0 f5			        push af 
01c1 e5			        push hl 
01c2			 
01c2			    ; initi write mode 
01c2			    ; 
01c2			    ;CS low 
01c2			 
01c2 3a 40 f8		       ld a,(spi_portbyte) 
01c5 cd 6e 01			call spi_ce_low 
01c8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c8 d3 80		       out (storage_adata),a 
01ca 32 40 f8		       ld (spi_portbyte), a 
01cd			 
01cd			    ;clock out wren instruction 
01cd			 
01cd 3e 06		    ld a, store_wren_ins 
01cf cd 92 00		    call spi_send_byte  
01d2			 
01d2			    ;cs high to enable write latch 
01d2			 
01d2 3a 40 f8		       ld a,(spi_portbyte) 
01d5 cd 5d 01			call spi_ce_high 
01d8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01d8 d3 80		       out (storage_adata),a 
01da 32 40 f8		       ld (spi_portbyte), a 
01dd			 
01dd 00				nop 
01de			    ; 
01de			    ; intial write data 
01de			    ; 
01de			    ; cs low 
01de			     
01de 3a 40 f8		       ld a,(spi_portbyte) 
01e1 cd 6e 01			call spi_ce_low 
01e4			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e4 d3 80		       out (storage_adata),a 
01e6 32 40 f8		       ld (spi_portbyte), a 
01e9			 
01e9			    ; clock out write instruction 
01e9			     
01e9 3e 02		    ld a, store_write_ins  
01eb cd 92 00		    call spi_send_byte  
01ee			 
01ee			    ; clock out address (depending on address size) 
01ee			     
01ee e1			    pop hl 
01ef 7c			    ld a,h    ; address out msb first 
01f0 cd 92 00		    call spi_send_byte  
01f3 7d			    ld a,l 
01f4 cd 92 00		    call spi_send_byte  
01f7			 
01f7			    ; clock out byte(s) for page 
01f7			 
01f7 f1			    pop af 
01f8 cd 92 00		    call spi_send_byte  
01fb			 
01fb			    ; end write with ce high 
01fb 3a 40 f8		       ld a,(spi_portbyte) 
01fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
01fe cd 5d 01			call spi_ce_high 
0201 d3 80		       out (storage_adata),a 
0203 32 40 f8		       ld (spi_portbyte), a 
0206			 
0206				; pause for internal write cycle 
0206 3e 0a			ld a, 10 
0208 cd 0b 0b			call aDelayInMS 
020b c9			    ret 
020c			 
020c			; buffer to write in de 
020c			; address in hl  
020c			se_writepage: 
020c			        
020c			    ;   ld c, a 
020c d5				push de 
020d e5			        push hl 
020e			 
020e			    ; initi write mode 
020e			    ; 
020e			    ;CS low 
020e			 
020e 3a 40 f8		       ld a,(spi_portbyte) 
0211 cd 6e 01			call spi_ce_low 
0214			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214 d3 80		       out (storage_adata),a 
0216 32 40 f8		       ld (spi_portbyte), a 
0219			 
0219			    ;clock out wren instruction 
0219			 
0219 3e 06		    ld a, store_wren_ins 
021b cd 92 00		    call spi_send_byte  
021e			 
021e			    ;cs high to enable write latch 
021e			 
021e 3a 40 f8		       ld a,(spi_portbyte) 
0221 cd 5d 01			call spi_ce_high 
0224			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0224 d3 80		       out (storage_adata),a 
0226 32 40 f8		       ld (spi_portbyte), a 
0229			 
0229 00				nop 
022a			    ; 
022a			    ; intial write data 
022a			    ; 
022a			    ; cs low 
022a			     
022a 3a 40 f8		       ld a,(spi_portbyte) 
022d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022d cd 6e 01			call spi_ce_low 
0230 d3 80		       out (storage_adata),a 
0232 32 40 f8		       ld (spi_portbyte), a 
0235			 
0235			    ; clock out write instruction 
0235			     
0235 3e 02		    ld a, store_write_ins  
0237 cd 92 00		    call spi_send_byte  
023a			 
023a			    ; clock out address (depending on address size) 
023a			     
023a e1			    pop hl 
023b 7c			    ld a,h    ; address out msb first 
023c cd 92 00		    call spi_send_byte  
023f 7d			    ld a,l 
0240 cd 92 00		    call spi_send_byte  
0243			 
0243			    ; clock out byte(s) for page 
0243			 
0243 e1				pop hl 
0244 06 40			ld b, STORE_BLOCK_PHY 
0246			.bytewrite: 
0246			 
0246 7e				ld a,(hl) 
0247 e5			    push hl 
0248 c5				push bc 
0249 cd 92 00		    call spi_send_byte  
024c c1				pop bc 
024d e1				pop hl 
024e			 
024e			    ; end write with ce high 
024e 3a 40 f8		       ld a,(spi_portbyte) 
0251 cd 5d 01			call spi_ce_high 
0254			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0254 d3 80		       out (storage_adata),a 
0256 32 40 f8		       ld (spi_portbyte), a 
0259			 
0259 23				inc hl 
025a 10 ea			djnz .bytewrite 
025c			 
025c				; pause for internal write cycle 
025c 3e 64			ld a, 100 
025e cd 0b 0b			call aDelayInMS 
0261 c9			    ret 
0262			; returns byte in a 
0262			; address in hl  
0262			se_readbyte: 
0262 d5				push de 
0263 c5				push bc 
0264			 
0264			    ;   ld c, a 
0264 e5			        push hl 
0265			 
0265			    ; initi write mode 
0265			    ; 
0265			    ;CS low 
0265			 
0265 3a 40 f8		       ld a,(spi_portbyte) 
0268 cd 6e 01			call spi_ce_low 
026b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
026b d3 80		       out (storage_adata),a 
026d 32 40 f8		       ld (spi_portbyte), a 
0270			 
0270			    ;clock out wren instruction 
0270			 
0270 3e 03		    ld a, store_read_ins 
0272 cd 92 00		    call spi_send_byte  
0275			 
0275			 
0275			    ; clock out address (depending on address size) 
0275			     
0275 e1			    pop hl 
0276 7c			    ld a,h    ; address out msb first 
0277 cd 92 00		    call spi_send_byte  
027a 7d			    ld a,l 
027b cd 92 00		    call spi_send_byte  
027e			 
027e			    ; clock in byte(s) for page 
027e			 
027e cd b3 00		    call spi_read_byte  
0281 f5				push af 
0282			 
0282			    ; end write with ce high 
0282 3a 40 f8		       ld a,(spi_portbyte) 
0285			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0285 cd 5d 01			call spi_ce_high 
0288 d3 80		       out (storage_adata),a 
028a 32 40 f8		       ld (spi_portbyte), a 
028d			 
028d f1				pop af 
028e			 
028e c1				pop bc 
028f d1				pop de 
0290			 
0290 c9			    ret 
0291			 
0291			if DEBUG_STORESE 
0291			 
0291			storageput:  
0291			 
0291			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
0291			 
0291 21 16 ee			ld hl,scratch+2 
0294 cd 94 11			call get_word_hl 
0297			 
0297				; stuff it here for the moment as it will be overwritten later anyway 
0297			 
0297 22 37 f1			ld (os_cur_ptr),hl	 
029a			 
029a			 
029a			; get pointer to start of string 
029a			 
029a 21 1b ee			ld hl, scratch+7 
029d			 
029d			; loop writing char of string to eeprom 
029d			 
029d 7e			.writestr:	ld a,(hl) 
029e fe 00				cp 0 
02a0 28 12				jr z, .wsdone		; done writing 
02a2 e5					push hl 
02a3 2a 37 f1				ld hl,(os_cur_ptr) 
02a6 cd c0 01				call se_writebyte 
02a9			 
02a9 2a 37 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02ac 23					inc hl 
02ad 22 37 f1				ld (os_cur_ptr),hl 
02b0			 
02b0					; restore string pointer and get next char 
02b0			 
02b0 e1					pop hl 
02b1 23					inc hl 
02b2 18 e9				jr .writestr 
02b4			 
02b4			 
02b4			 
02b4			.wsdone: 
02b4			 
02b4			 
02b4			; when done load first page into a buffer  
02b4			 
02b4 21 00 80				ld hl,08000h		; start in ram 
02b7 22 37 f1				ld (os_cur_ptr),hl 
02ba 21 00 00				ld hl, 0		 ; start of page 
02bd 22 3c ee				ld (scratch+40),hl	; hang on to it 
02c0			 
02c0 06 80				ld b, 128		; actually get more then one page 
02c2 c5			.wsload:	push bc 
02c3 2a 3c ee				ld hl,(scratch+40) 
02c6 e5					push hl 
02c7 cd 62 02				call se_readbyte 
02ca			 
02ca					; a now as the byte 
02ca			 
02ca 2a 37 f1				ld hl,(os_cur_ptr) 
02cd 77					ld (hl),a 
02ce					; inc next buffer area 
02ce 23					inc hl 
02cf 22 37 f1				ld (os_cur_ptr),hl 
02d2			 
02d2					; get eeprom position, inc and save for next round 
02d2 e1					pop hl		 
02d3 23					inc hl 
02d4 22 3c ee				ld (scratch+40),hl 
02d7 c1					pop bc 
02d8 10 e8				djnz .wsload 
02da			 
02da			; set 'd' pointer to start of buffer 
02da			 
02da 21 00 80				ld hl,08000h 
02dd 22 37 f1				ld (os_cur_ptr),hl 
02e0			 
02e0			 
02e0 c9			ret 
02e1			 
02e1			 
02e1 c9			storageread: ret 
02e2			 
02e2			 
02e2			 
02e2			 
02e2			 
02e2			 
02e2			endif 
02e2			 
02e2			 
02e2			 
# End of file firmware_seeprom.asm
02e2			else  
02e2			   ; create some stubs for the labels  
02e2			se_readbyte: ret  
02e2			se_writebyte: ret  
02e2			storage_init: ret  
02e2			  
02e2			endif  
02e2			  
02e2			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02e2			;include "firmware_cf.asm"  
02e2			  
02e2			; load up high level storage hardward abstractions  
02e2			include "firmware_storage.asm"  
02e2			 
02e2			; persisent storage hardware abstraction layer  
02e2			 
02e2			 
02e2			 
02e2			; Block 0 on storage is a config state 
02e2			 
02e2			 
02e2			 
02e2			; TODO add read phy block and write phy block functions 
02e2			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02e2			 
02e2			; Abstraction layer  
02e2			 
02e2			; Logocial block size is same size as physical size - using tape concept 
02e2			 
02e2			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02e2			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02e2			 
02e2			 
02e2			 
02e2			; Filesystem layout (Logical layout) 
02e2			; 
02e2			; Block 0 - Bank config  
02e2			; 
02e2			;      Byte - 0 file id counter 
02e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02e2			;      Byte - 3-20 zero terminated bank label 
02e2			; 
02e2			; Block 1 > File storage 
02e2			; 
02e2			;      Byte 0 file id    - block 0 file details 
02e2			;      Byte 1 block id - block 0 is file  
02e2			;            Byte 2-15 - File name 
02e2			; 
02e2			;       - to end of block data 
02e2			; 
02e2			 
02e2			; Get ID for the file named in pointer held HL 
02e2			; Returns ID in HL = 255 if no file found 
02e2			 
02e2			storage_getid: 
02e2			 
02e2 22 57 f8			ld (store_tmp1), hl 
02e5			 
02e5				if DEBUG_STORESE 
02e5					DMARK "SGI" 
02e5 f5				push af  
02e6 3a fa 02			ld a, (.dmark)  
02e9 32 6e fb			ld (debug_mark),a  
02ec 3a fb 02			ld a, (.dmark+1)  
02ef 32 6f fb			ld (debug_mark+1),a  
02f2 3a fc 02			ld a, (.dmark+2)  
02f5 32 70 fb			ld (debug_mark+2),a  
02f8 18 03			jr .pastdmark  
02fa ..			.dmark: db "SGI"  
02fd f1			.pastdmark: pop af  
02fe			endm  
# End of macro DMARK
02fe					CALLMONITOR 
02fe cd 84 17			call break_point_state  
0301				endm  
# End of macro CALLMONITOR
0301				endif 
0301				; get block 0 and set counter for number of files to scan 
0301			 
0301 cd 6c 04			call storage_get_block_0 
0304			 
0304 3a 59 f8			ld a, (store_page) 
0307 47				ld b, a 
0308			 
0308				; get extent 0 of each file id 
0308			 
0308				if DEBUG_STORESE 
0308					DMARK "SGc" 
0308 f5				push af  
0309 3a 1d 03			ld a, (.dmark)  
030c 32 6e fb			ld (debug_mark),a  
030f 3a 1e 03			ld a, (.dmark+1)  
0312 32 6f fb			ld (debug_mark+1),a  
0315 3a 1f 03			ld a, (.dmark+2)  
0318 32 70 fb			ld (debug_mark+2),a  
031b 18 03			jr .pastdmark  
031d ..			.dmark: db "SGc"  
0320 f1			.pastdmark: pop af  
0321			endm  
# End of macro DMARK
0321					CALLMONITOR 
0321 cd 84 17			call break_point_state  
0324				endm  
# End of macro CALLMONITOR
0324				endif 
0324 60			.getloop:	ld h, b 
0325 2e 00				ld l, 0 
0327 c5					push bc 
0328			 
0328 11 59 f8				ld de, store_page 
032b				if DEBUG_STORESE 
032b					DMARK "SGr" 
032b f5				push af  
032c 3a 40 03			ld a, (.dmark)  
032f 32 6e fb			ld (debug_mark),a  
0332 3a 41 03			ld a, (.dmark+1)  
0335 32 6f fb			ld (debug_mark+1),a  
0338 3a 42 03			ld a, (.dmark+2)  
033b 32 70 fb			ld (debug_mark+2),a  
033e 18 03			jr .pastdmark  
0340 ..			.dmark: db "SGr"  
0343 f1			.pastdmark: pop af  
0344			endm  
# End of macro DMARK
0344					CALLMONITOR 
0344 cd 84 17			call break_point_state  
0347				endm  
# End of macro CALLMONITOR
0347				endif 
0347 cd 14 09				call storage_read 
034a cd 06 0e				call ishlzero 
034d 28 2d				jr z, .gap 
034f					 
034f					; have a file name read. Is it one we want. 
034f			 
034f 2a 57 f8				ld hl, (store_tmp1) 
0352 11 5c f8				ld de, store_page+3   ; file name 
0355			 
0355				if DEBUG_STORESE 
0355					DMARK "SGc" 
0355 f5				push af  
0356 3a 6a 03			ld a, (.dmark)  
0359 32 6e fb			ld (debug_mark),a  
035c 3a 6b 03			ld a, (.dmark+1)  
035f 32 6f fb			ld (debug_mark+1),a  
0362 3a 6c 03			ld a, (.dmark+2)  
0365 32 70 fb			ld (debug_mark+2),a  
0368 18 03			jr .pastdmark  
036a ..			.dmark: db "SGc"  
036d f1			.pastdmark: pop af  
036e			endm  
# End of macro DMARK
036e					CALLMONITOR 
036e cd 84 17			call break_point_state  
0371				endm  
# End of macro CALLMONITOR
0371				endif 
0371 cd 73 12				call strcmp 
0374 20 06				jr nz, .gap   ; not this one 
0376			 
0376 c1				        pop bc 
0377			 
0377 26 00				ld h, 0 
0379 68					ld l, b 
037a 18 22				jr .getdone 
037c						 
037c			 
037c			 
037c			 
037c			.gap: 
037c				if DEBUG_STORESE 
037c					DMARK "SGg" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6e fb			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6f fb			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 70 fb			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SGg"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					CALLMONITOR 
0395 cd 84 17			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 c1					pop bc 
0399 10 89				djnz .getloop 
039b 21 ff 00				ld hl, 255 
039e			.getdone: 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGe" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 6e fb			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 6f fb			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 70 fb			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGe"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd 84 17			call break_point_state  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba			 
03ba c9				ret 
03bb			 
03bb			 
03bb			 
03bb			 
03bb			 
03bb			 
03bb			 
03bb			 
03bb			; Read Block 
03bb			; ---------- 
03bb			; 
03bb			; With current bank 
03bb			;  
03bb			; Get block number to read 
03bb			; Load physical blocks starting at start block into buffer 
03bb			 
03bb			; de points to buffer to use 
03bb			; hl holds logical block number  
03bb			 
03bb			storage_read_block: 
03bb			 
03bb				; TODO bank selection 
03bb			 
03bb				; for each of the physical blocks read it into the buffer 
03bb 06 40			ld b, STORE_BLOCK_PHY 
03bd			 
03bd				if DEBUG_STORESE 
03bd d5					push de 
03be				endif 
03be				 
03be			.rl1:    
03be			 
03be				; read physical block at hl into de 
03be			        ; increment hl and de to next read position on exit 
03be			 
03be e5				push hl 
03bf d5				push de	 
03c0 c5				push bc 
03c1			;	if DEBUG_STORESE 
03c1			;		push af 
03c1			;		ld a, 'R' 
03c1			;		ld (debug_mark),a 
03c1			;		pop af 
03c1			;		CALLMONITOR 
03c1			;	endif 
03c1 cd 62 02			call se_readbyte 
03c4			;	if DEBUG_STORESE 
03c4			;		ld a,(spi_portbyte) 
03c4			;		ld l, a 
03c4			;		push af 
03c4			;		ld a, '1' 
03c4			;		ld (debug_mark),a 
03c4			;		pop af 
03c4			;		CALLMONITOR 
03c4			;	endif 
03c4 c1				pop bc 
03c5 d1				pop de 
03c6 e1				pop hl 
03c7 12				ld (de),a 
03c8 23				inc hl 
03c9 13				inc de 
03ca			 
03ca			;	if DEBUG_STORESE 
03ca			;		push af 
03ca			;		ld a, 'r' 
03ca			;		ld (debug_mark),a 
03ca			;		pop af 
03ca			;		CALLMONITOR 
03ca			;	endif 
03ca			 
03ca 10 f2			djnz .rl1 
03cc			 
03cc				if DEBUG_STORESE 
03cc					DMARK "SRB" 
03cc f5				push af  
03cd 3a e1 03			ld a, (.dmark)  
03d0 32 6e fb			ld (debug_mark),a  
03d3 3a e2 03			ld a, (.dmark+1)  
03d6 32 6f fb			ld (debug_mark+1),a  
03d9 3a e3 03			ld a, (.dmark+2)  
03dc 32 70 fb			ld (debug_mark+2),a  
03df 18 03			jr .pastdmark  
03e1 ..			.dmark: db "SRB"  
03e4 f1			.pastdmark: pop af  
03e5			endm  
# End of macro DMARK
03e5 d1					pop de 
03e6			; 
03e6			;		push af 
03e6			;		ld a, 'R' 
03e6			;		ld (debug_mark),a 
03e6			;		pop af 
03e6					CALLMONITOR 
03e6 cd 84 17			call break_point_state  
03e9				endm  
# End of macro CALLMONITOR
03e9				endif 
03e9 c9				ret	 
03ea				 
03ea			 
03ea			; File Size 
03ea			; --------- 
03ea			; 
03ea			;   hl file id 
03ea			; 
03ea			;  returns in hl the number of blocks 
03ea			 
03ea			storage_file_size: 
03ea 5d				ld e, l 
03eb 16 00			ld d, 0 
03ed 21 40 00			ld hl, STORE_BLOCK_PHY 
03f0					if DEBUG_FORTH_WORDS 
03f0						DMARK "SIZ" 
03f0 f5				push af  
03f1 3a 05 04			ld a, (.dmark)  
03f4 32 6e fb			ld (debug_mark),a  
03f7 3a 06 04			ld a, (.dmark+1)  
03fa 32 6f fb			ld (debug_mark+1),a  
03fd 3a 07 04			ld a, (.dmark+2)  
0400 32 70 fb			ld (debug_mark+2),a  
0403 18 03			jr .pastdmark  
0405 ..			.dmark: db "SIZ"  
0408 f1			.pastdmark: pop af  
0409			endm  
# End of macro DMARK
0409						CALLMONITOR 
0409 cd 84 17			call break_point_state  
040c				endm  
# End of macro CALLMONITOR
040c					endif 
040c cd ee 06			call storage_findnextid 
040f			 
040f cd 06 0e			call ishlzero 
0412			;	ld a, l 
0412			;	add h 
0412			;	cp 0 
0412 c8				ret z			; block not found so EOF 
0413			 
0413 11 59 f8			ld de, store_page 
0416 cd bb 03			call storage_read_block 
0419			 
0419 3a 5b f8			ld a, (store_page+2)	 ; get extent count 
041c 6f				ld l, a 
041d 26 00			ld h, 0 
041f c9			 	ret 
0420			 
0420			 
0420			; Write Block 
0420			; ----------- 
0420			; 
0420			; With current bank 
0420			;  
0420			; Get block number to write 
0420			; Write physical blocks starting at start block from buffer 
0420			  
0420			storage_write_block: 
0420				; TODO bank selection 
0420			 
0420				; for each of the physical blocks read it into the buffer 
0420 06 40			ld b, STORE_BLOCK_PHY 
0422			 
0422				if DEBUG_STORESE 
0422					DMARK "SWB" 
0422 f5				push af  
0423 3a 37 04			ld a, (.dmark)  
0426 32 6e fb			ld (debug_mark),a  
0429 3a 38 04			ld a, (.dmark+1)  
042c 32 6f fb			ld (debug_mark+1),a  
042f 3a 39 04			ld a, (.dmark+2)  
0432 32 70 fb			ld (debug_mark+2),a  
0435 18 03			jr .pastdmark  
0437 ..			.dmark: db "SWB"  
043a f1			.pastdmark: pop af  
043b			endm  
# End of macro DMARK
043b			 
043b					;push af 
043b					;ld a, 'W' 
043b					;ld (debug_mark),a 
043b					;pop af 
043b					CALLMONITOR 
043b cd 84 17			call break_point_state  
043e				endm  
# End of macro CALLMONITOR
043e				endif 
043e			 
043e			; might not be working 
043e			;	call se_writepage 
043e			 
043e			;	ret 
043e			; 
043e			 
043e			 
043e			 
043e			.wl1:    
043e			 
043e				; read physical block at hl into de 
043e			        ; increment hl and de to next read position on exit 
043e			 
043e e5				push hl 
043f d5				push de	 
0440 c5				push bc 
0441 1a				ld a,(de) 
0442				;if DEBUG_STORESE 
0442			;		push af 
0442			;		ld a, 'W' 
0442			;		ld (debug_mark),a 
0442			;		pop af 
0442			;		CALLMONITOR 
0442			;	endif 
0442 cd c0 01			call se_writebyte 
0445			;	call delay250ms 
0445 00				nop 
0446 00				nop 
0447 00				nop 
0448			;	if DEBUG_STORESE 
0448			;		push af 
0448			;		ld a, 'w' 
0448			;		ld (debug_mark),a 
0448			;		pop af 
0448			;		CALLMONITOR 
0448			;	endif 
0448 c1				pop bc 
0449 d1				pop de 
044a e1				pop hl 
044b 23				inc hl 
044c 13				inc de 
044d			 
044d			 
044d 10 ef			djnz .wl1 
044f			 
044f				if DEBUG_STORESE 
044f					DMARK "SW2" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 6e fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 6f fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 70 fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SW2"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			 
0468					;push af 
0468					;ld a, 'W' 
0468					;ld (debug_mark),a 
0468					;pop af 
0468					CALLMONITOR 
0468 cd 84 17			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b c9				ret	 
046c			 
046c			; Init bank 
046c			; --------- 
046c			; 
046c			; With current bank 
046c			; 
046c			; Setup block 0 config 
046c			;     Set 0 file id counter 
046c			;     Set formatted byte pattern 
046c			;     Zero out bank label 
046c			;      
046c			; For every logical block write 0-1 byte as null 
046c			 
046c			storage_get_block_0: 
046c			 
046c				; TODO check presence 
046c			 
046c				; get block 0 config 
046c			 
046c 21 00 00			ld hl, 0 
046f 11 59 f8			ld de, store_page 
0472 cd bb 03			call storage_read_block 
0475			 
0475				if DEBUG_STORESE 
0475					DMARK "SB0" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6e fb			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6f fb			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 70 fb			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "SB0"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e 11 59 f8				ld de, store_page 
0491			;		push af 
0491			;		ld a, 'i' 
0491			;		ld (debug_mark),a 
0491			;		pop af 
0491					CALLMONITOR 
0491 cd 84 17			call break_point_state  
0494				endm  
# End of macro CALLMONITOR
0494				endif 
0494			 
0494				; is this area formatted? 
0494			 
0494			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0494 2a 5a f8			ld hl, (store_page+1) 
0497 3e 80			ld a,0x80 
0499 bd				cp l 
049a 20 22			jr nz, .ininotformatted 
049c				; do a double check 
049c 3e 27			ld a, 0x27 
049e bc				cp h 
049f 20 1d			jr nz, .ininotformatted 
04a1			 
04a1				; formatted then 
04a1			 
04a1				if DEBUG_STORESE 
04a1					DMARK "SB1" 
04a1 f5				push af  
04a2 3a b6 04			ld a, (.dmark)  
04a5 32 6e fb			ld (debug_mark),a  
04a8 3a b7 04			ld a, (.dmark+1)  
04ab 32 6f fb			ld (debug_mark+1),a  
04ae 3a b8 04			ld a, (.dmark+2)  
04b1 32 70 fb			ld (debug_mark+2),a  
04b4 18 03			jr .pastdmark  
04b6 ..			.dmark: db "SB1"  
04b9 f1			.pastdmark: pop af  
04ba			endm  
# End of macro DMARK
04ba					;push af 
04ba					;ld a, 'I' 
04ba					;ld (debug_mark),a 
04ba					;pop af 
04ba					CALLMONITOR 
04ba cd 84 17			call break_point_state  
04bd				endm  
# End of macro CALLMONITOR
04bd				endif 
04bd c9				ret 
04be			 
04be			.ininotformatted: 
04be				; bank not formatted so poke various bits to make sure 
04be			 
04be				if DEBUG_STORESE 
04be					DMARK "SB2" 
04be f5				push af  
04bf 3a d3 04			ld a, (.dmark)  
04c2 32 6e fb			ld (debug_mark),a  
04c5 3a d4 04			ld a, (.dmark+1)  
04c8 32 6f fb			ld (debug_mark+1),a  
04cb 3a d5 04			ld a, (.dmark+2)  
04ce 32 70 fb			ld (debug_mark+2),a  
04d1 18 03			jr .pastdmark  
04d3 ..			.dmark: db "SB2"  
04d6 f1			.pastdmark: pop af  
04d7			endm  
# End of macro DMARK
04d7					;push af 
04d7					;ld a, 'f' 
04d7					;ld (debug_mark),a 
04d7					;pop af 
04d7					CALLMONITOR 
04d7 cd 84 17			call break_point_state  
04da				endm  
# End of macro CALLMONITOR
04da				endif 
04da			 
04da cd e9 0a			call storage_clear_page 
04dd			 
04dd 21 59 f8			ld hl, store_page 
04e0 3e 00			ld a, 0 
04e2				 
04e2 77				ld (hl),a   ; reset file counter 
04e3			 
04e3 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04e6 22 5a f8		 	ld (store_page+1), hl	 
04e9			 
04e9				; set default label 
04e9			 
04e9 21 85 05			ld hl, .defaultbanklabl 
04ec 11 5c f8		 	ld de, store_page+3 
04ef 01 0f 00			ld bc, 15 
04f2 ed b0			ldir 
04f4			 
04f4				; Append the current bank id 
04f4 21 65 f8			ld hl, store_page+3+9 
04f7 3a 3e f8			ld a, (spi_device_id) 
04fa 77				ld (hl), a 
04fb			 
04fb				; save default page 0 
04fb			 
04fb 21 00 00			ld hl, 0 
04fe 11 59 f8			ld de, store_page 
0501				if DEBUG_STORESE 
0501					DMARK "SB3" 
0501 f5				push af  
0502 3a 16 05			ld a, (.dmark)  
0505 32 6e fb			ld (debug_mark),a  
0508 3a 17 05			ld a, (.dmark+1)  
050b 32 6f fb			ld (debug_mark+1),a  
050e 3a 18 05			ld a, (.dmark+2)  
0511 32 70 fb			ld (debug_mark+2),a  
0514 18 03			jr .pastdmark  
0516 ..			.dmark: db "SB3"  
0519 f1			.pastdmark: pop af  
051a			endm  
# End of macro DMARK
051a			;		push af 
051a			;		ld a, 'F' 
051a			;		ld (debug_mark),a 
051a			;		pop af 
051a					CALLMONITOR 
051a cd 84 17			call break_point_state  
051d				endm  
# End of macro CALLMONITOR
051d				endif 
051d cd 20 04			call storage_write_block 
0520				if DEBUG_STORESE 
0520					DMARK "SB4" 
0520 f5				push af  
0521 3a 35 05			ld a, (.dmark)  
0524 32 6e fb			ld (debug_mark),a  
0527 3a 36 05			ld a, (.dmark+1)  
052a 32 6f fb			ld (debug_mark+1),a  
052d 3a 37 05			ld a, (.dmark+2)  
0530 32 70 fb			ld (debug_mark+2),a  
0533 18 03			jr .pastdmark  
0535 ..			.dmark: db "SB4"  
0538 f1			.pastdmark: pop af  
0539			endm  
# End of macro DMARK
0539			;		push af 
0539			;		ld a, '>' 
0539			;		ld (debug_mark),a 
0539			;		pop af 
0539					CALLMONITOR 
0539 cd 84 17			call break_point_state  
053c				endm  
# End of macro CALLMONITOR
053c				endif 
053c			 
053c 00				nop 
053d 00				nop 
053e 00				nop 
053f			 
053f				; now set 0 in every page to mark as a free block 
053f			 
053f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0541 21 40 00			ld hl, STORE_BLOCK_PHY 
0544			 
0544 3e 00		.setmark1:   	ld a,0 
0546 e5					push hl 
0547 c5					push bc 
0548 cd c0 01				call se_writebyte 
054b 3e 0a			ld a, 10 
054d cd 0b 0b			call aDelayInMS 
0550 23				inc hl 
0551 cd c0 01				call se_writebyte 
0554 3e 0a			ld a, 10 
0556 cd 0b 0b			call aDelayInMS 
0559 2b				dec hl 
055a c1					pop bc 
055b e1					pop hl 
055c 3e 40				ld a, STORE_BLOCK_PHY 
055e cd dd 0d				call addatohl 
0561 10 e1				djnz .setmark1 
0563			 
0563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0565 3e 00		.setmark2:   	ld a,0 
0567 e5					push hl 
0568 c5					push bc 
0569 cd c0 01				call se_writebyte 
056c 3e 0a			ld a, 10 
056e cd 0b 0b			call aDelayInMS 
0571 23				inc hl 
0572 cd c0 01				call se_writebyte 
0575 3e 0a			ld a, 10 
0577 cd 0b 0b			call aDelayInMS 
057a 2b				dec hl 
057b c1					pop bc 
057c e1					pop hl 
057d 3e 40				ld a, STORE_BLOCK_PHY 
057f cd dd 0d				call addatohl 
0582 10 e1				djnz .setmark2 
0584			 
0584					 
0584			 
0584			 
0584 c9				ret 
0585			 
0585			 
0585			 
0585			 
0585 .. 00		.defaultbanklabl:   db "BankLabel_",0 
0590			 
0590			 
0590			 
0590			; Label Bank 
0590			; ---------- 
0590			; 
0590			; With current bank 
0590			; Read block 0 
0590			; Set label 
0590			; Write block 0 
0590			 
0590			; label str pointer in hl 
0590			 
0590			storage_label:     
0590			 
0590				if DEBUG_STORESE 
0590					DMARK "LBL" 
0590 f5				push af  
0591 3a a5 05			ld a, (.dmark)  
0594 32 6e fb			ld (debug_mark),a  
0597 3a a6 05			ld a, (.dmark+1)  
059a 32 6f fb			ld (debug_mark+1),a  
059d 3a a7 05			ld a, (.dmark+2)  
05a0 32 70 fb			ld (debug_mark+2),a  
05a3 18 03			jr .pastdmark  
05a5 ..			.dmark: db "LBL"  
05a8 f1			.pastdmark: pop af  
05a9			endm  
# End of macro DMARK
05a9					CALLMONITOR 
05a9 cd 84 17			call break_point_state  
05ac				endm  
# End of macro CALLMONITOR
05ac				endif 
05ac			 
05ac e5				push hl 
05ad			 
05ad cd 6c 04			call storage_get_block_0 
05b0			 
05b0				; set default label 
05b0			 
05b0 e1				pop hl 
05b1			 
05b1 11 5c f8		 	ld de, store_page+3 
05b4 01 0f 00			ld bc, 15 
05b7				if DEBUG_STORESE 
05b7					DMARK "LB3" 
05b7 f5				push af  
05b8 3a cc 05			ld a, (.dmark)  
05bb 32 6e fb			ld (debug_mark),a  
05be 3a cd 05			ld a, (.dmark+1)  
05c1 32 6f fb			ld (debug_mark+1),a  
05c4 3a ce 05			ld a, (.dmark+2)  
05c7 32 70 fb			ld (debug_mark+2),a  
05ca 18 03			jr .pastdmark  
05cc ..			.dmark: db "LB3"  
05cf f1			.pastdmark: pop af  
05d0			endm  
# End of macro DMARK
05d0					CALLMONITOR 
05d0 cd 84 17			call break_point_state  
05d3				endm  
# End of macro CALLMONITOR
05d3				endif 
05d3 ed b0			ldir 
05d5				; save default page 0 
05d5			 
05d5 21 00 00			ld hl, 0 
05d8 11 59 f8			ld de, store_page 
05db				if DEBUG_STORESE 
05db					DMARK "LBW" 
05db f5				push af  
05dc 3a f0 05			ld a, (.dmark)  
05df 32 6e fb			ld (debug_mark),a  
05e2 3a f1 05			ld a, (.dmark+1)  
05e5 32 6f fb			ld (debug_mark+1),a  
05e8 3a f2 05			ld a, (.dmark+2)  
05eb 32 70 fb			ld (debug_mark+2),a  
05ee 18 03			jr .pastdmark  
05f0 ..			.dmark: db "LBW"  
05f3 f1			.pastdmark: pop af  
05f4			endm  
# End of macro DMARK
05f4					CALLMONITOR 
05f4 cd 84 17			call break_point_state  
05f7				endm  
# End of macro CALLMONITOR
05f7				endif 
05f7 cd 20 04			call storage_write_block 
05fa			 
05fa c9				ret 
05fb			 
05fb			 
05fb			 
05fb			; Read Block 0 - Config 
05fb			; --------------------- 
05fb			; 
05fb			; With current bank 
05fb			; Call presence test 
05fb			;    If not present format/init bank  
05fb			; Read block 0  
05fb			;  
05fb			 
05fb			 
05fb			; Dir 
05fb			; --- 
05fb			; 
05fb			; With current bank 
05fb			; Load Block 0 Config 
05fb			; Get max file id number 
05fb			; For each logical block 
05fb			;    Read block read byte 2 
05fb			;      if first block of file 
05fb			;         Display file name 
05fb			;         Display type flags for file 
05fb			;        
05fb			 
05fb			; moving to words as this requires stack control 
05fb			 
05fb			 
05fb			; Delete File 
05fb			; ----------- 
05fb			; 
05fb			; With current bank 
05fb			; 
05fb			; Load Block 0 Config 
05fb			; Get max file id number 
05fb			; For each logical block 
05fb			;    Read block file id 
05fb			;      If first block of file and dont have file id 
05fb			;         if file to delete 
05fb			;         Save file id 
05fb			;         Null file id 
05fb			;         Write this block back 
05fb			;      If file id is one saved 
05fb			;         Null file id 
05fb			;         Write this block back 
05fb			 
05fb			 
05fb			.se_done: 
05fb e1				pop hl 
05fc c9				ret 
05fd			 
05fd			storage_erase: 
05fd			 
05fd				; hl contains the file id 
05fd			 
05fd 5d				ld e, l 
05fe 16 00			ld d, 0 
0600 21 40 00			ld hl, STORE_BLOCK_PHY 
0603					if DEBUG_FORTH_WORDS 
0603						DMARK "ERA" 
0603 f5				push af  
0604 3a 18 06			ld a, (.dmark)  
0607 32 6e fb			ld (debug_mark),a  
060a 3a 19 06			ld a, (.dmark+1)  
060d 32 6f fb			ld (debug_mark+1),a  
0610 3a 1a 06			ld a, (.dmark+2)  
0613 32 70 fb			ld (debug_mark+2),a  
0616 18 03			jr .pastdmark  
0618 ..			.dmark: db "ERA"  
061b f1			.pastdmark: pop af  
061c			endm  
# End of macro DMARK
061c						CALLMONITOR 
061c cd 84 17			call break_point_state  
061f				endm  
# End of macro CALLMONITOR
061f					endif 
061f cd ee 06			call storage_findnextid 
0622 cd 06 0e			call ishlzero 
0625 c8				ret z 
0626			 
0626 e5				push hl 
0627			 
0627				; TODO check file not found 
0627			 
0627 11 59 f8			ld de, store_page 
062a cd bb 03			call storage_read_block 
062d			 
062d cd 06 0e			call ishlzero 
0630 ca fb 05			jp z,.se_done 
0633			 
0633					if DEBUG_FORTH_WORDS 
0633						DMARK "ER1" 
0633 f5				push af  
0634 3a 48 06			ld a, (.dmark)  
0637 32 6e fb			ld (debug_mark),a  
063a 3a 49 06			ld a, (.dmark+1)  
063d 32 6f fb			ld (debug_mark+1),a  
0640 3a 4a 06			ld a, (.dmark+2)  
0643 32 70 fb			ld (debug_mark+2),a  
0646 18 03			jr .pastdmark  
0648 ..			.dmark: db "ER1"  
064b f1			.pastdmark: pop af  
064c			endm  
# End of macro DMARK
064c						CALLMONITOR 
064c cd 84 17			call break_point_state  
064f				endm  
# End of macro CALLMONITOR
064f					endif 
064f 3a 59 f8			ld a, (store_page)	; get file id 
0652 32 52 f8			ld (store_tmpid), a 
0655			 
0655 3a 5b f8			ld a, (store_page+2)    ; get count of extends 
0658 32 51 f8			ld (store_tmpext), a 
065b			 
065b				; wipe file header 
065b			 
065b e1				pop hl 
065c 3e 00			ld a, 0 
065e 32 59 f8			ld (store_page), a 
0661 32 5a f8			ld (store_page+1),a 
0664 11 59 f8			ld de, store_page 
0667					if DEBUG_FORTH_WORDS 
0667						DMARK "ER2" 
0667 f5				push af  
0668 3a 7c 06			ld a, (.dmark)  
066b 32 6e fb			ld (debug_mark),a  
066e 3a 7d 06			ld a, (.dmark+1)  
0671 32 6f fb			ld (debug_mark+1),a  
0674 3a 7e 06			ld a, (.dmark+2)  
0677 32 70 fb			ld (debug_mark+2),a  
067a 18 03			jr .pastdmark  
067c ..			.dmark: db "ER2"  
067f f1			.pastdmark: pop af  
0680			endm  
# End of macro DMARK
0680						CALLMONITOR 
0680 cd 84 17			call break_point_state  
0683				endm  
# End of macro CALLMONITOR
0683					endif 
0683 cd 20 04			call storage_write_block 
0686			 
0686			 
0686				; wipe file extents 
0686			 
0686 3a 51 f8			ld a, (store_tmpext) 
0689 47				ld b, a 
068a			 
068a			.eraext:	  
068a c5				push bc 
068b			 
068b 21 40 00			ld hl, STORE_BLOCK_PHY 
068e 3a 52 f8			ld a,(store_tmpid) 
0691 5f				ld e, a 
0692 50				ld d, b	 
0693					if DEBUG_FORTH_WORDS 
0693						DMARK "ER3" 
0693 f5				push af  
0694 3a a8 06			ld a, (.dmark)  
0697 32 6e fb			ld (debug_mark),a  
069a 3a a9 06			ld a, (.dmark+1)  
069d 32 6f fb			ld (debug_mark+1),a  
06a0 3a aa 06			ld a, (.dmark+2)  
06a3 32 70 fb			ld (debug_mark+2),a  
06a6 18 03			jr .pastdmark  
06a8 ..			.dmark: db "ER3"  
06ab f1			.pastdmark: pop af  
06ac			endm  
# End of macro DMARK
06ac						CALLMONITOR 
06ac cd 84 17			call break_point_state  
06af				endm  
# End of macro CALLMONITOR
06af					endif 
06af cd ee 06			call storage_findnextid 
06b2 cd 06 0e			call ishlzero 
06b5 ca fb 05			jp z,.se_done 
06b8			 
06b8 e5				push hl 
06b9 11 59 f8			ld de, store_page 
06bc cd bb 03			call storage_read_block 
06bf			 
06bf				; free block	 
06bf			 
06bf 3e 00			ld a, 0 
06c1 32 59 f8			ld (store_page), a 
06c4 32 5a f8			ld (store_page+1),a 
06c7 11 59 f8			ld de, store_page 
06ca e1				pop hl 
06cb					if DEBUG_FORTH_WORDS 
06cb						DMARK "ER4" 
06cb f5				push af  
06cc 3a e0 06			ld a, (.dmark)  
06cf 32 6e fb			ld (debug_mark),a  
06d2 3a e1 06			ld a, (.dmark+1)  
06d5 32 6f fb			ld (debug_mark+1),a  
06d8 3a e2 06			ld a, (.dmark+2)  
06db 32 70 fb			ld (debug_mark+2),a  
06de 18 03			jr .pastdmark  
06e0 ..			.dmark: db "ER4"  
06e3 f1			.pastdmark: pop af  
06e4			endm  
# End of macro DMARK
06e4						CALLMONITOR 
06e4 cd 84 17			call break_point_state  
06e7				endm  
# End of macro CALLMONITOR
06e7					endif 
06e7 cd 20 04			call storage_write_block 
06ea			 
06ea c1				pop bc 
06eb 10 9d			djnz .eraext 
06ed			 
06ed c9				ret 
06ee			 
06ee			 
06ee			; Find Free Block 
06ee			; --------------- 
06ee			; 
06ee			; With current bank 
06ee			;  
06ee			; From given starting logical block 
06ee			;    Read block  
06ee			;    If no file id 
06ee			;         Return block id 
06ee			 
06ee			 
06ee			; hl starting page number 
06ee			; hl contains free page number or zero if no pages free 
06ee			; e contains the file id to locate 
06ee			; d contains the block number 
06ee			 
06ee			; TODO change to find file id and use zero for free block 
06ee			 
06ee			storage_findnextid: 
06ee			 
06ee				; now locate first 0 page to mark as a free block 
06ee			 
06ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06f0			;	ld hl, STORE_BLOCK_PHY 
06f0			 
06f0					if DEBUG_FORTH_WORDS 
06f0					DMARK "FNI" 
06f0 f5				push af  
06f1 3a 05 07			ld a, (.dmark)  
06f4 32 6e fb			ld (debug_mark),a  
06f7 3a 06 07			ld a, (.dmark+1)  
06fa 32 6f fb			ld (debug_mark+1),a  
06fd 3a 07 07			ld a, (.dmark+2)  
0700 32 70 fb			ld (debug_mark+2),a  
0703 18 03			jr .pastdmark  
0705 ..			.dmark: db "FNI"  
0708 f1			.pastdmark: pop af  
0709			endm  
# End of macro DMARK
0709						CALLMONITOR 
0709 cd 84 17			call break_point_state  
070c				endm  
# End of macro CALLMONITOR
070c					endif 
070c			.ff1:   	 
070c e5					push hl 
070d c5					push bc 
070e d5					push de 
070f cd 62 02				call se_readbyte 
0712 5f					ld e,a 
0713 23					inc hl 
0714 cd 62 02				call se_readbyte 
0717 57					ld d, a 
0718 e1					pop hl 
0719 e5					push hl 
071a cd fb 0d				call cmp16 
071d 28 49				jr z, .fffound 
071f			 
071f d1					pop de 
0720 c1					pop bc 
0721 e1					pop hl 
0722			 
0722					; is found? 
0722					;cp e 
0722					;ret z 
0722			 
0722 3e 40				ld a, STORE_BLOCK_PHY 
0724 cd dd 0d				call addatohl 
0727 10 e3				djnz .ff1 
0729			 
0729 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
072b			.ff2:   	 
072b			 
072b e5					push hl 
072c c5					push bc 
072d d5					push de 
072e cd 62 02				call se_readbyte 
0731 5f					ld e,a 
0732 23					inc hl 
0733 cd 62 02				call se_readbyte 
0736 57					ld d, a 
0737			 
0737 e1					pop hl 
0738 e5					push hl 
0739 cd fb 0d				call cmp16 
073c 28 2a				jr z, .fffound 
073e			 
073e d1					pop de 
073f c1					pop bc 
0740 e1					pop hl 
0741					; is found? 
0741					;cp e 
0741					;ret z 
0741			 
0741 3e 40				ld a, STORE_BLOCK_PHY 
0743 cd dd 0d				call addatohl 
0746 10 e3				djnz .ff2 
0748			 
0748			 
0748					if DEBUG_FORTH_WORDS 
0748					DMARK "FN-" 
0748 f5				push af  
0749 3a 5d 07			ld a, (.dmark)  
074c 32 6e fb			ld (debug_mark),a  
074f 3a 5e 07			ld a, (.dmark+1)  
0752 32 6f fb			ld (debug_mark+1),a  
0755 3a 5f 07			ld a, (.dmark+2)  
0758 32 70 fb			ld (debug_mark+2),a  
075b 18 03			jr .pastdmark  
075d ..			.dmark: db "FN-"  
0760 f1			.pastdmark: pop af  
0761			endm  
# End of macro DMARK
0761					;	push af 
0761					;	ld a, 'n' 
0761					;	ld (debug_mark),a 
0761					;	pop af 
0761						CALLMONITOR 
0761 cd 84 17			call break_point_state  
0764				endm  
# End of macro CALLMONITOR
0764					endif 
0764				; no free marks! 
0764 21 00 00				ld hl, 0 
0767 c9				ret 
0768			.fffound: 
0768				 
0768			 
0768 d1					pop de 
0769 c1					pop bc 
076a e1					pop hl 
076b					if DEBUG_FORTH_WORDS 
076b					DMARK "FNF" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6e fb			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6f fb			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 70 fb			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "FNF"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					;	push af 
0784					;	ld a, 'n' 
0784					;	ld (debug_mark),a 
0784					;	pop af 
0784						CALLMONITOR 
0784 cd 84 17			call break_point_state  
0787				endm  
# End of macro CALLMONITOR
0787					endif 
0787 c9				ret 
0788			 
0788			 
0788			 
0788			; Free Space 
0788			; ---------- 
0788			; 
0788			; With current bank 
0788			; 
0788			; Set block count to zero 
0788			; Starting with first logical block 
0788			;      Find free block  
0788			;      If block id given, increment block count 
0788			; 
0788			;  
0788			 
0788			 
0788			; hl contains count of free blocks 
0788			 
0788			storage_freeblocks: 
0788			 
0788				; now locate first 0 page to mark as a free block 
0788			 
0788 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078a 21 40 00			ld hl, STORE_BLOCK_PHY 
078d 11 00 00			ld de, 0 
0790			 
0790			.fb1:   	 
0790 e5					push hl 
0791 c5					push bc 
0792 d5					push de 
0793 cd 62 02				call se_readbyte 
0796 d1					pop de 
0797 c1					pop bc 
0798 e1					pop hl 
0799			 
0799					; is free? 
0799 fe 00				cp 0 
079b 20 01				jr nz, .ff1cont 
079d 13					inc de 
079e			 
079e			.ff1cont: 
079e			 
079e			 
079e 3e 40				ld a, STORE_BLOCK_PHY 
07a0 cd dd 0d				call addatohl 
07a3 10 eb				djnz .fb1 
07a5			 
07a5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a7			.fb2:   	 
07a7 e5					push hl 
07a8 c5					push bc 
07a9 d5					push de 
07aa cd 62 02				call se_readbyte 
07ad d1					pop de 
07ae c1					pop bc 
07af e1					pop hl 
07b0			 
07b0					; is free? 
07b0 fe 00				cp 0 
07b2 20 01				jr nz, .ff2cont 
07b4 13					inc de 
07b5			 
07b5			.ff2cont: 
07b5			 
07b5 3e 40				ld a, STORE_BLOCK_PHY 
07b7 cd dd 0d				call addatohl 
07ba 10 eb				djnz .fb2 
07bc			 
07bc eb				ex de, hl 
07bd c9				ret 
07be			 
07be			; Get File ID 
07be			; ----------- 
07be			; 
07be			; With current bank 
07be			;  
07be			; Load Block 0 Config 
07be			; Get max file id number 
07be			; For each logical block 
07be			;    Read block file id 
07be			;      If first block of file and dont have file id 
07be			;         if file get id and exit 
07be			 
07be			 
07be			 
07be			 
07be			; Create File 
07be			; ----------- 
07be			; 
07be			; With current bank  
07be			; Load Block 0 Config 
07be			; Get max file id number 
07be			; Increment file id number 
07be			; Save Config 
07be			; Find free block 
07be			; Set buffer with file name and file id 
07be			; Write buffer to free block  
07be			 
07be			 
07be			; hl point to file name 
07be			; hl returns file id 
07be			 
07be			; file format: 
07be			; byte 0 - file id 
07be			; byte 1 - extent number 
07be			; byte 2-> data 
07be			 
07be			; format for extent number 0: 
07be			; 
07be			; byte 0 - file id 
07be			; byte 1 - extent 0 
07be			; byte 2 - extent count 
07be			; byte 3 -> file name and meta data 
07be			 
07be			 
07be			storage_create: 
07be				if DEBUG_STORESE 
07be					DMARK "SCR" 
07be f5				push af  
07bf 3a d3 07			ld a, (.dmark)  
07c2 32 6e fb			ld (debug_mark),a  
07c5 3a d4 07			ld a, (.dmark+1)  
07c8 32 6f fb			ld (debug_mark+1),a  
07cb 3a d5 07			ld a, (.dmark+2)  
07ce 32 70 fb			ld (debug_mark+2),a  
07d1 18 03			jr .pastdmark  
07d3 ..			.dmark: db "SCR"  
07d6 f1			.pastdmark: pop af  
07d7			endm  
# End of macro DMARK
07d7					CALLMONITOR 
07d7 cd 84 17			call break_point_state  
07da				endm  
# End of macro CALLMONITOR
07da				endif 
07da			 
07da e5				push hl		; save file name pointer 
07db			 
07db cd 6c 04			call storage_get_block_0 
07de			 
07de 3a 59 f8			ld a,(store_page)	; get current file id 
07e1 3c				inc a 
07e2 32 59 f8			ld (store_page),a 
07e5				 
07e5 32 52 f8			ld (store_tmpid),a			; save id 
07e8			 
07e8 21 00 00			ld hl, 0 
07eb 11 59 f8			ld de, store_page 
07ee				if DEBUG_STORESE 
07ee					DMARK "SCw" 
07ee f5				push af  
07ef 3a 03 08			ld a, (.dmark)  
07f2 32 6e fb			ld (debug_mark),a  
07f5 3a 04 08			ld a, (.dmark+1)  
07f8 32 6f fb			ld (debug_mark+1),a  
07fb 3a 05 08			ld a, (.dmark+2)  
07fe 32 70 fb			ld (debug_mark+2),a  
0801 18 03			jr .pastdmark  
0803 ..			.dmark: db "SCw"  
0806 f1			.pastdmark: pop af  
0807			endm  
# End of macro DMARK
0807					CALLMONITOR 
0807 cd 84 17			call break_point_state  
080a				endm  
# End of macro CALLMONITOR
080a				endif 
080a cd 20 04			call storage_write_block	 ; save update 
080d			 
080d				if DEBUG_STORESE 
080d 11 59 f8				ld de, store_page 
0810					DMARK "SCC" 
0810 f5				push af  
0811 3a 25 08			ld a, (.dmark)  
0814 32 6e fb			ld (debug_mark),a  
0817 3a 26 08			ld a, (.dmark+1)  
081a 32 6f fb			ld (debug_mark+1),a  
081d 3a 27 08			ld a, (.dmark+2)  
0820 32 70 fb			ld (debug_mark+2),a  
0823 18 03			jr .pastdmark  
0825 ..			.dmark: db "SCC"  
0828 f1			.pastdmark: pop af  
0829			endm  
# End of macro DMARK
0829					CALLMONITOR 
0829 cd 84 17			call break_point_state  
082c				endm  
# End of macro CALLMONITOR
082c				endif 
082c				;  
082c				 
082c 21 40 00			ld hl, STORE_BLOCK_PHY 
082f 11 00 00			ld de, 0 
0832 cd ee 06			call storage_findnextid 
0835			 
0835 22 43 f8			ld (store_tmppageid), hl    ; save page to use  
0838			 
0838				; TODO detect 0 = no spare blocks 
0838			 
0838				; hl now contains the free page to use for the file header page 
0838			 
0838				if DEBUG_STORESE 
0838				DMARK "SCF" 
0838 f5				push af  
0839 3a 4d 08			ld a, (.dmark)  
083c 32 6e fb			ld (debug_mark),a  
083f 3a 4e 08			ld a, (.dmark+1)  
0842 32 6f fb			ld (debug_mark+1),a  
0845 3a 4f 08			ld a, (.dmark+2)  
0848 32 70 fb			ld (debug_mark+2),a  
084b 18 03			jr .pastdmark  
084d ..			.dmark: db "SCF"  
0850 f1			.pastdmark: pop af  
0851			endm  
# End of macro DMARK
0851					CALLMONITOR 
0851 cd 84 17			call break_point_state  
0854				endm  
# End of macro CALLMONITOR
0854				endif 
0854			 
0854 22 43 f8			ld (store_tmppageid), hl 
0857				 
0857 3a 52 f8			ld a,(store_tmpid)    ; get file id 
085a			;	ld a, (store_filecache)			; save to cache 
085a			 
085a 32 59 f8			ld (store_page),a    ; set page id 
085d 3e 00			ld a, 0			 ; extent 0 is file header 
085f 32 5a f8			ld (store_page+1), a   ; set file extent 
0862			 
0862 32 5b f8			ld (store_page+2), a   ; extent count for the file 
0865			 
0865			;	inc hl 		; init block 0 of file 
0865			;	inc hl   		; skip file and extent id 
0865			 ;       ld a, 0 
0865			;	ld (hl),a 
0865			;	ld a, (store_filecache+1)  	; save to cache 
0865			 
0865			;	inc hl    ; file name 
0865				 
0865				 
0865 11 5c f8			ld de, store_page+3    ; get buffer for term string to use as file name 
0868				if DEBUG_STORESE 
0868					DMARK "SCc" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 6e fb			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 6f fb			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 70 fb			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCc"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd 84 17			call break_point_state  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884 e1				pop hl    ; get zero term string 
0885 e5				push hl 
0886 3e 00			ld a, 0 
0888 cd 46 12			call strlent 
088b 23				inc hl   ; cover zero term 
088c 06 00			ld b,0 
088e 4d				ld c,l 
088f e1				pop hl 
0890				;ex de, hl 
0890				if DEBUG_STORESE 
0890					DMARK "SCa" 
0890 f5				push af  
0891 3a a5 08			ld a, (.dmark)  
0894 32 6e fb			ld (debug_mark),a  
0897 3a a6 08			ld a, (.dmark+1)  
089a 32 6f fb			ld (debug_mark+1),a  
089d 3a a7 08			ld a, (.dmark+2)  
08a0 32 70 fb			ld (debug_mark+2),a  
08a3 18 03			jr .pastdmark  
08a5 ..			.dmark: db "SCa"  
08a8 f1			.pastdmark: pop af  
08a9			endm  
# End of macro DMARK
08a9					;push af 
08a9					;ld a, 'a' 
08a9					;ld (debug_mark),a 
08a9					;pop af 
08a9					CALLMONITOR 
08a9 cd 84 17			call break_point_state  
08ac				endm  
# End of macro CALLMONITOR
08ac				endif 
08ac ed b0			ldir    ; copy zero term string 
08ae				if DEBUG_STORESE 
08ae					DMARK "SCA" 
08ae f5				push af  
08af 3a c3 08			ld a, (.dmark)  
08b2 32 6e fb			ld (debug_mark),a  
08b5 3a c4 08			ld a, (.dmark+1)  
08b8 32 6f fb			ld (debug_mark+1),a  
08bb 3a c5 08			ld a, (.dmark+2)  
08be 32 70 fb			ld (debug_mark+2),a  
08c1 18 03			jr .pastdmark  
08c3 ..			.dmark: db "SCA"  
08c6 f1			.pastdmark: pop af  
08c7			endm  
# End of macro DMARK
08c7					CALLMONITOR 
08c7 cd 84 17			call break_point_state  
08ca				endm  
# End of macro CALLMONITOR
08ca				endif 
08ca			 
08ca				; write file header page 
08ca			 
08ca 2a 43 f8			ld hl,(store_tmppageid) 
08cd 11 59 f8			ld de, store_page 
08d0				if DEBUG_STORESE 
08d0					DMARK "SCb" 
08d0 f5				push af  
08d1 3a e5 08			ld a, (.dmark)  
08d4 32 6e fb			ld (debug_mark),a  
08d7 3a e6 08			ld a, (.dmark+1)  
08da 32 6f fb			ld (debug_mark+1),a  
08dd 3a e7 08			ld a, (.dmark+2)  
08e0 32 70 fb			ld (debug_mark+2),a  
08e3 18 03			jr .pastdmark  
08e5 ..			.dmark: db "SCb"  
08e8 f1			.pastdmark: pop af  
08e9			endm  
# End of macro DMARK
08e9					;push af 
08e9					;ld a, 'b' 
08e9					;ld (debug_mark),a 
08e9					;pop af 
08e9					CALLMONITOR 
08e9 cd 84 17			call break_point_state  
08ec				endm  
# End of macro CALLMONITOR
08ec				endif 
08ec cd 20 04			call storage_write_block 
08ef			 
08ef 3a 52 f8			ld a, (store_tmpid) 
08f2 6f				ld l, a 
08f3 26 00			ld h,0 
08f5				if DEBUG_STORESE 
08f5					DMARK "SCz" 
08f5 f5				push af  
08f6 3a 0a 09			ld a, (.dmark)  
08f9 32 6e fb			ld (debug_mark),a  
08fc 3a 0b 09			ld a, (.dmark+1)  
08ff 32 6f fb			ld (debug_mark+1),a  
0902 3a 0c 09			ld a, (.dmark+2)  
0905 32 70 fb			ld (debug_mark+2),a  
0908 18 03			jr .pastdmark  
090a ..			.dmark: db "SCz"  
090d f1			.pastdmark: pop af  
090e			endm  
# End of macro DMARK
090e					CALLMONITOR 
090e cd 84 17			call break_point_state  
0911				endm  
# End of macro CALLMONITOR
0911				endif 
0911 c9				ret 
0912				 
0912			 
0912			 
0912			; 
0912			; Read File 
0912			; 
0912			; h - file id to locate 
0912			; l - extent to locate 
0912			; de - pointer to string to read into 
0912			; 
0912			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0912			 
0912			.sr_fail: 
0912 d1				pop de 
0913 c9				ret 
0914			 
0914			storage_read: 
0914 d5				push de 
0915			 
0915			; TODO BUG the above push is it popped before the RET Z? 
0915			 
0915			; TODO how to handle multiple part blocks 
0915			 
0915				; locate file extent to read 
0915			 
0915 5c				ld e, h 
0916 55				ld d, l 
0917 21 40 00			ld hl, STORE_BLOCK_PHY 
091a				if DEBUG_STORESE 
091a					DMARK "SRE" 
091a f5				push af  
091b 3a 2f 09			ld a, (.dmark)  
091e 32 6e fb			ld (debug_mark),a  
0921 3a 30 09			ld a, (.dmark+1)  
0924 32 6f fb			ld (debug_mark+1),a  
0927 3a 31 09			ld a, (.dmark+2)  
092a 32 70 fb			ld (debug_mark+2),a  
092d 18 03			jr .pastdmark  
092f ..			.dmark: db "SRE"  
0932 f1			.pastdmark: pop af  
0933			endm  
# End of macro DMARK
0933					CALLMONITOR 
0933 cd 84 17			call break_point_state  
0936				endm  
# End of macro CALLMONITOR
0936				endif 
0936 cd ee 06			call storage_findnextid 
0939			 
0939				if DEBUG_STORESE 
0939					DMARK "SRf" 
0939 f5				push af  
093a 3a 4e 09			ld a, (.dmark)  
093d 32 6e fb			ld (debug_mark),a  
0940 3a 4f 09			ld a, (.dmark+1)  
0943 32 6f fb			ld (debug_mark+1),a  
0946 3a 50 09			ld a, (.dmark+2)  
0949 32 70 fb			ld (debug_mark+2),a  
094c 18 03			jr .pastdmark  
094e ..			.dmark: db "SRf"  
0951 f1			.pastdmark: pop af  
0952			endm  
# End of macro DMARK
0952					CALLMONITOR 
0952 cd 84 17			call break_point_state  
0955				endm  
# End of macro CALLMONITOR
0955				endif 
0955 cd 06 0e			call ishlzero 
0958			;	ld a, l 
0958			;	add h 
0958			;	cp 0 
0958 28 b8			jr z,.sr_fail			; block not found so EOF 
095a			 
095a				; hl contains page number to load 
095a d1				pop de   ; get storage 
095b d5				push de 
095c				if DEBUG_STORESE 
095c					DMARK "SRg" 
095c f5				push af  
095d 3a 71 09			ld a, (.dmark)  
0960 32 6e fb			ld (debug_mark),a  
0963 3a 72 09			ld a, (.dmark+1)  
0966 32 6f fb			ld (debug_mark+1),a  
0969 3a 73 09			ld a, (.dmark+2)  
096c 32 70 fb			ld (debug_mark+2),a  
096f 18 03			jr .pastdmark  
0971 ..			.dmark: db "SRg"  
0974 f1			.pastdmark: pop af  
0975			endm  
# End of macro DMARK
0975					CALLMONITOR 
0975 cd 84 17			call break_point_state  
0978				endm  
# End of macro CALLMONITOR
0978				endif 
0978 cd bb 03			call storage_read_block 
097b			 
097b			 
097b			; TODO if block has no zeros then need to read next block  
097b			 
097b			 
097b					 
097b e1				pop hl 		 ; return start of data to show as not EOF 
097c 23				inc hl   ; past file id 
097d 23				inc hl   ; past ext 
097e				if DEBUG_STORESE 
097e					DMARK "SRe" 
097e f5				push af  
097f 3a 93 09			ld a, (.dmark)  
0982 32 6e fb			ld (debug_mark),a  
0985 3a 94 09			ld a, (.dmark+1)  
0988 32 6f fb			ld (debug_mark+1),a  
098b 3a 95 09			ld a, (.dmark+2)  
098e 32 70 fb			ld (debug_mark+2),a  
0991 18 03			jr .pastdmark  
0993 ..			.dmark: db "SRe"  
0996 f1			.pastdmark: pop af  
0997			endm  
# End of macro DMARK
0997					CALLMONITOR 
0997 cd 84 17			call break_point_state  
099a				endm  
# End of macro CALLMONITOR
099a				endif 
099a c9					ret 
099b			 
099b			 
099b			 
099b			; 
099b			; Append File 
099b			; 
099b			; hl - file id to locate 
099b			; de - pointer to (multi block) string to write 
099b			 
099b			.sa_notfound: 
099b d1				pop de 
099c c9				ret 
099d			 
099d			 
099d			storage_append: 
099d				; hl -  file id to append to 
099d				; de - string to append 
099d			 
099d d5				push de 
099e				 
099e				if DEBUG_STORESE 
099e					DMARK "AP1" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6e fb			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6f fb			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 70 fb			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP1"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 84 17			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba 7d				ld a, l 
09bb 32 52 f8			ld (store_tmpid), a 
09be			 
09be				; get file header  
09be			 
09be 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
09c0 3a 52 f8			ld a, (store_tmpid) 
09c3 5f				ld e, a 
09c4			 
09c4 21 40 00				ld hl, STORE_BLOCK_PHY 
09c7 cd ee 06				call storage_findnextid 
09ca			 
09ca cd 06 0e			call ishlzero 
09cd 28 cc			jr z, .sa_notfound 
09cf			 
09cf 22 43 f8			ld (store_tmppageid), hl 
09d2			 
09d2				; TODO handle file id not found 
09d2			 
09d2				if DEBUG_STORESE 
09d2					DMARK "AP2" 
09d2 f5				push af  
09d3 3a e7 09			ld a, (.dmark)  
09d6 32 6e fb			ld (debug_mark),a  
09d9 3a e8 09			ld a, (.dmark+1)  
09dc 32 6f fb			ld (debug_mark+1),a  
09df 3a e9 09			ld a, (.dmark+2)  
09e2 32 70 fb			ld (debug_mark+2),a  
09e5 18 03			jr .pastdmark  
09e7 ..			.dmark: db "AP2"  
09ea f1			.pastdmark: pop af  
09eb			endm  
# End of macro DMARK
09eb					CALLMONITOR 
09eb cd 84 17			call break_point_state  
09ee				endm  
# End of macro CALLMONITOR
09ee				endif 
09ee			 
09ee				; update file extent count 
09ee			 
09ee 11 59 f8			ld de, store_page 
09f1			 
09f1 cd bb 03			call storage_read_block 
09f4			 
09f4				if DEBUG_STORESE 
09f4					DMARK "AP3" 
09f4 f5				push af  
09f5 3a 09 0a			ld a, (.dmark)  
09f8 32 6e fb			ld (debug_mark),a  
09fb 3a 0a 0a			ld a, (.dmark+1)  
09fe 32 6f fb			ld (debug_mark+1),a  
0a01 3a 0b 0a			ld a, (.dmark+2)  
0a04 32 70 fb			ld (debug_mark+2),a  
0a07 18 03			jr .pastdmark  
0a09 ..			.dmark: db "AP3"  
0a0c f1			.pastdmark: pop af  
0a0d			endm  
# End of macro DMARK
0a0d					CALLMONITOR 
0a0d cd 84 17			call break_point_state  
0a10				endm  
# End of macro CALLMONITOR
0a10				endif 
0a10			;	ld (store_tmppageid), hl 
0a10			 
0a10 3a 5b f8			ld a, (store_page+2) 
0a13 3c				inc a 
0a14 32 5b f8			ld (store_page+2), a 
0a17 32 51 f8			ld (store_tmpext), a 
0a1a				 
0a1a				if DEBUG_STORESE 
0a1a					DMARK "AP3" 
0a1a f5				push af  
0a1b 3a 2f 0a			ld a, (.dmark)  
0a1e 32 6e fb			ld (debug_mark),a  
0a21 3a 30 0a			ld a, (.dmark+1)  
0a24 32 6f fb			ld (debug_mark+1),a  
0a27 3a 31 0a			ld a, (.dmark+2)  
0a2a 32 70 fb			ld (debug_mark+2),a  
0a2d 18 03			jr .pastdmark  
0a2f ..			.dmark: db "AP3"  
0a32 f1			.pastdmark: pop af  
0a33			endm  
# End of macro DMARK
0a33					CALLMONITOR 
0a33 cd 84 17			call break_point_state  
0a36				endm  
# End of macro CALLMONITOR
0a36				endif 
0a36 2a 43 f8			ld hl, (store_tmppageid) 
0a39 11 59 f8			ld de, store_page 
0a3c cd 20 04			call storage_write_block 
0a3f			 
0a3f				; find free block 
0a3f			 
0a3f 11 00 00			ld de, 0			 ; file extent to locate 
0a42			 
0a42 21 40 00				ld hl, STORE_BLOCK_PHY 
0a45 cd ee 06				call storage_findnextid 
0a48 cd 06 0e			call ishlzero 
0a4b ca 9b 09			jp z, .sa_notfound 
0a4e			 
0a4e					; TODO handle no space left 
0a4e					 
0a4e 22 43 f8				ld (store_tmppageid), hl 
0a51			 
0a51				if DEBUG_STORESE 
0a51					DMARK "AP4" 
0a51 f5				push af  
0a52 3a 66 0a			ld a, (.dmark)  
0a55 32 6e fb			ld (debug_mark),a  
0a58 3a 67 0a			ld a, (.dmark+1)  
0a5b 32 6f fb			ld (debug_mark+1),a  
0a5e 3a 68 0a			ld a, (.dmark+2)  
0a61 32 70 fb			ld (debug_mark+2),a  
0a64 18 03			jr .pastdmark  
0a66 ..			.dmark: db "AP4"  
0a69 f1			.pastdmark: pop af  
0a6a			endm  
# End of macro DMARK
0a6a					CALLMONITOR 
0a6a cd 84 17			call break_point_state  
0a6d				endm  
# End of macro CALLMONITOR
0a6d				endif 
0a6d					; init the buffer with zeros so we can id if the buffer is full or not 
0a6d			 
0a6d e5					push hl 
0a6e c5					push bc 
0a6f			 
0a6f 21 59 f8				ld hl, store_page 
0a72 06 40				ld b, STORE_BLOCK_PHY 
0a74 3e 00				ld a, 0 
0a76 77			.zeroblock:	ld (hl), a 
0a77 23					inc hl 
0a78 10 fc				djnz .zeroblock 
0a7a			 
0a7a c1					pop bc 
0a7b e1					pop hl 
0a7c			 
0a7c					; construct block 
0a7c			 
0a7c 3a 52 f8				ld a, (store_tmpid) 
0a7f 32 59 f8				ld (store_page), a   ; file id 
0a82 3a 51 f8				ld a, (store_tmpext)   ; extent for this block 
0a85 32 5a f8				ld (store_page+1), a 
0a88			 
0a88 e1					pop hl    ; get string to write 
0a89 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a8b 11 5b f8				ld de, store_page+2 
0a8e			 
0a8e				if DEBUG_STORESE 
0a8e					DMARK "AP5" 
0a8e f5				push af  
0a8f 3a a3 0a			ld a, (.dmark)  
0a92 32 6e fb			ld (debug_mark),a  
0a95 3a a4 0a			ld a, (.dmark+1)  
0a98 32 6f fb			ld (debug_mark+1),a  
0a9b 3a a5 0a			ld a, (.dmark+2)  
0a9e 32 70 fb			ld (debug_mark+2),a  
0aa1 18 03			jr .pastdmark  
0aa3 ..			.dmark: db "AP5"  
0aa6 f1			.pastdmark: pop af  
0aa7			endm  
# End of macro DMARK
0aa7					CALLMONITOR 
0aa7 cd 84 17			call break_point_state  
0aaa				endm  
# End of macro CALLMONITOR
0aaa				endif 
0aaa			 
0aaa			 
0aaa			 
0aaa					; fill buffer with data until end of string or full block 
0aaa			 
0aaa 7e			.appd:		ld a, (hl) 
0aab 12					ld (de), a 
0aac fe 00				cp 0 
0aae 28 04				jr z, .appdone 
0ab0 23					inc hl 
0ab1 13					inc de 
0ab2 10 f6				djnz .appd 
0ab4			 
0ab4 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0ab5 f5					push af   		; save last byte dumped 
0ab6			 
0ab6			 
0ab6 2a 43 f8			ld hl, (store_tmppageid) 
0ab9 11 59 f8			ld de, store_page 
0abc				if DEBUG_STORESE 
0abc					DMARK "AP6" 
0abc f5				push af  
0abd 3a d1 0a			ld a, (.dmark)  
0ac0 32 6e fb			ld (debug_mark),a  
0ac3 3a d2 0a			ld a, (.dmark+1)  
0ac6 32 6f fb			ld (debug_mark+1),a  
0ac9 3a d3 0a			ld a, (.dmark+2)  
0acc 32 70 fb			ld (debug_mark+2),a  
0acf 18 03			jr .pastdmark  
0ad1 ..			.dmark: db "AP6"  
0ad4 f1			.pastdmark: pop af  
0ad5			endm  
# End of macro DMARK
0ad5					CALLMONITOR 
0ad5 cd 84 17			call break_point_state  
0ad8				endm  
# End of macro CALLMONITOR
0ad8				endif 
0ad8 cd 20 04				call storage_write_block 
0adb			 
0adb			 
0adb				; was that a full block of data written? 
0adb				; any more to write out? 
0adb			 
0adb				; if yes then set vars and jump to start of function again 
0adb			 
0adb f1					pop af 
0adc d1					pop de 
0add			 
0add fe 00				cp 0		 ; no, string was fully written 
0adf c8					ret z 
0ae0			 
0ae0					; setup vars for next cycle 
0ae0			 
0ae0 3a 52 f8				ld a, (store_tmpid) 
0ae3 6f					ld l, a 
0ae4 26 00				ld h, 0 
0ae6			 
0ae6 c3 9d 09			 	jp storage_append	 ; yes, need to write out some more 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			 
0ae9			if DEBUG_STORECF 
0ae9			storageput:	 
0ae9					ret 
0ae9			storageread: 
0ae9					ld hl, store_page 
0ae9					ld b, 200 
0ae9					ld a,0 
0ae9			.src:		ld (hl),a 
0ae9					inc hl 
0ae9					djnz .src 
0ae9					 
0ae9			 
0ae9					ld de, 0 
0ae9					ld bc, 1 
0ae9					ld hl, store_page 
0ae9					call cfRead 
0ae9			 
0ae9				call cfGetError 
0ae9				ld hl,scratch 
0ae9				call hexout 
0ae9				ld hl, scratch+2 
0ae9				ld a, 0 
0ae9				ld (hl),a 
0ae9				ld de, scratch 
0ae9				ld a,display_row_1 
0ae9				call str_at_display 
0ae9				call update_display 
0ae9			 
0ae9					ld hl, store_page 
0ae9					ld (os_cur_ptr),hl 
0ae9			 
0ae9					ret 
0ae9			endif 
0ae9			 
0ae9			 
0ae9			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ae9			 
0ae9			storage_clear_page: 
0ae9 e5				push hl 
0aea d5				push de 
0aeb c5				push bc 
0aec 21 59 f8			ld hl, store_page 
0aef 3e 00			ld a, 0 
0af1 77				ld (hl), a 
0af2			 
0af2 11 5a f8			ld de, store_page+1 
0af5 01 40 00			ld bc, STORE_BLOCK_PHY 
0af8			 
0af8 ed b0			ldir 
0afa				 
0afa c1				pop bc 
0afb d1				pop de 
0afc e1				pop hl 
0afd c9				ret 
0afe			 
0afe			; eof 
# End of file firmware_storage.asm
0afe			  
0afe			; support routines for above hardware abstraction layer  
0afe			  
0afe			include "firmware_general.asm"        ; general support functions  
0afe			 
0afe			; word look up 
0afe			 
0afe			; in 
0afe			; a is the index 
0afe			; hl is pointer start of array 
0afe			; 
0afe			; returns 
0afe			; hl to the word 
0afe			; 
0afe			 
0afe			table_lookup:  
0afe d5					push de 
0aff eb					ex de, hl 
0b00			 
0b00 6f					ld l, a 
0b01 26 00				ld h, 0 
0b03 29					add hl, hl 
0b04 19					add hl, de 
0b05 7e					ld a, (hl) 
0b06 23					inc hl 
0b07 66					ld h,(hl) 
0b08 6f					ld l, a 
0b09			 
0b09 d1					pop de 
0b0a c9					ret 
0b0b			 
0b0b			; Delay loops 
0b0b			 
0b0b			 
0b0b			 
0b0b			aDelayInMS: 
0b0b c5				push bc 
0b0c 47				ld b,a 
0b0d			msdelay: 
0b0d c5				push bc 
0b0e				 
0b0e			 
0b0e 01 41 00			ld bc,041h 
0b11 cd 29 0b			call delayloop 
0b14 c1				pop bc 
0b15 05				dec b 
0b16 20 f5			jr nz,msdelay 
0b18			 
0b18			;if CPU_CLOCK_8MHZ 
0b18			;msdelay8: 
0b18			;	push bc 
0b18			;	 
0b18			; 
0b18			;	ld bc,041h 
0b18			;	call delayloop 
0b18			;	pop bc 
0b18			;	dec b 
0b18			;	jr nz,msdelay8 
0b18			;endif 
0b18			 
0b18			 
0b18 c1				pop bc 
0b19 c9				ret 
0b1a			 
0b1a			 
0b1a			delay250ms: 
0b1a				;push de 
0b1a 01 00 40			ld bc, 04000h 
0b1d c3 29 0b			jp delayloop 
0b20			delay500ms: 
0b20				;push de 
0b20 01 00 80			ld bc, 08000h 
0b23 c3 29 0b			jp delayloop 
0b26			delay1s: 
0b26				;push bc 
0b26			   ; Clobbers A, d and e 
0b26 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b29			delayloop: 
0b29 c5			    push bc 
0b2a			 
0b2a			if BASE_CPM 
0b2a				ld bc, CPM_DELAY_TUNE 
0b2a			.cpmloop: 
0b2a				push bc 
0b2a			 
0b2a			endif 
0b2a			 
0b2a			 
0b2a			 
0b2a			delayloopi: 
0b2a			;	push bc 
0b2a			;.dl: 
0b2a cb 47		    bit     0,a    	; 8 
0b2c cb 47		    bit     0,a    	; 8 
0b2e cb 47		    bit     0,a    	; 8 
0b30 e6 ff		    and     255  	; 7 
0b32 0b			    dec     bc      	; 6 
0b33 79			    ld      a,c     	; 4 
0b34 b0			    or      b     	; 4 
0b35 c2 2a 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b38			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b38				;pop de 
0b38			;pop bc 
0b38			 
0b38			if BASE_CPM 
0b38				pop bc 
0b38				 
0b38			    dec     bc      	; 6 
0b38			    ld      a,c     	; 4 
0b38			    or      b     	; 4 
0b38			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b38				 
0b38			 
0b38			endif 
0b38			;if CPU_CLOCK_8MHZ 
0b38			;    pop bc 
0b38			;    push bc 
0b38			;.dl8: 
0b38			;    bit     0,a    	; 8 
0b38			;    bit     0,a    	; 8 
0b38			;    bit     0,a    	; 8 
0b38			;    and     255  	; 7 
0b38			;    dec     bc      	; 6 
0b38			;    ld      a,c     	; 4 
0b38			;    or      b     	; 4 
0b38			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b38			;endif 
0b38			 
0b38			;if CPU_CLOCK_10MHZ 
0b38			;    pop bc 
0b38			;    push bc 
0b38			;.dl8: 
0b38			;    bit     0,a    	; 8 
0b38			;    bit     0,a    	; 8 
0b38			;    bit     0,a    	; 8 
0b38			;    and     255  	; 7 
0b38			;    dec     bc      	; 6 
0b38			;    ld      a,c     	; 4 
0b38			;    or      b     	; 4 
0b38			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b38			;endif 
0b38 c1			    pop bc 
0b39			 
0b39 c9				ret 
0b3a			 
0b3a			 
0b3a			 
0b3a			; eof 
# End of file firmware_general.asm
0b3a			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b3a			; display routines that use the physical hardware abstraction layer 
0b3a			 
0b3a			 
0b3a			; information window 
0b3a			 
0b3a			; pass hl with 1st string to display 
0b3a			; pass de with 2nd string to display 
0b3a			 
0b3a			info_panel: 
0b3a e5				push hl 
0b3b			 
0b3b 2a cf f8			ld hl, (display_fb_active) 
0b3e e5				push hl    ; future de destination 
0b3f 21 b4 fa				ld hl, display_fb0 
0b42 22 cf f8				ld (display_fb_active), hl 
0b45			 
0b45			;	call clear_display 
0b45			 
0b45				if BASE_CPM 
0b45				ld a, '.' 
0b45				else 
0b45 3e a5			ld a, 165 
0b47				endif 
0b47 cd ae 0b			call fill_display 
0b4a			 
0b4a			 
0b4a 3e 55			ld a, display_row_3 + 5 
0b4c cd bc 0b			call str_at_display 
0b4f			 
0b4f e1				pop hl 
0b50 d1				pop de 
0b51			 
0b51 e5				push hl 
0b52			 
0b52			 
0b52 3e 2d			ld a, display_row_2 + 5 
0b54 cd bc 0b			call str_at_display 
0b57			 
0b57			 
0b57 cd cc 0b			call update_display 
0b5a cd 59 1d			call next_page_prompt 
0b5d cd a9 0b			call clear_display 
0b60			 
0b60				 
0b60 21 13 fa				ld hl, display_fb1 
0b63 22 cf f8				ld (display_fb_active), hl 
0b66 cd cc 0b			call update_display 
0b69			 
0b69 e1				pop hl 
0b6a			 
0b6a c9				ret 
0b6b			 
0b6b			 
0b6b			 
0b6b			 
0b6b			; TODO windowing? 
0b6b			 
0b6b			; TODO scroll line up 
0b6b			 
0b6b			scroll_up: 
0b6b			 
0b6b e5				push hl 
0b6c d5				push de 
0b6d c5				push bc 
0b6e			 
0b6e				; get frame buffer  
0b6e			 
0b6e 2a cf f8			ld hl, (display_fb_active) 
0b71 e5				push hl    ; future de destination 
0b72			 
0b72 11 28 00			ld  de, display_cols 
0b75 19				add hl, de 
0b76			 
0b76 d1				pop de 
0b77			 
0b77				;ex de, hl 
0b77 01 9f 00			ld bc, display_fb_len -1  
0b7a			;if DEBUG_FORTH_WORDS 
0b7a			;	DMARK "SCL" 
0b7a			;	CALLMONITOR 
0b7a			;endif	 
0b7a ed b0			ldir 
0b7c			 
0b7c				; wipe bottom row 
0b7c			 
0b7c			 
0b7c 2a cf f8			ld hl, (display_fb_active) 
0b7f 11 a0 00			ld de, display_cols*display_rows 
0b82 19				add hl, de 
0b83 06 28			ld b, display_cols 
0b85 3e 20			ld a, ' ' 
0b87			.scwipe: 
0b87 77				ld (hl), a 
0b88 2b				dec hl 
0b89 10 fc			djnz .scwipe 
0b8b			 
0b8b				;pop hl 
0b8b			 
0b8b c1				pop bc 
0b8c d1				pop de 
0b8d e1				pop hl 
0b8e			 
0b8e c9				ret 
0b8f			 
0b8f			 
0b8f			;scroll_upo: 
0b8f			;	ld de, display_row_1 
0b8f			 ;	ld hl, display_row_2 
0b8f			;	ld bc, display_cols 
0b8f			;	ldir 
0b8f			;	ld de, display_row_2 
0b8f			 ;	ld hl, display_row_3 
0b8f			;	ld bc, display_cols 
0b8f			;	ldir 
0b8f			;	ld de, display_row_3 
0b8f			 ;	ld hl, display_row_4 
0b8f			;	ld bc, display_cols 
0b8f			;	ldir 
0b8f			 
0b8f			; TODO clear row 4 
0b8f			 
0b8f			;	ret 
0b8f			 
0b8f				 
0b8f			scroll_down: 
0b8f			 
0b8f e5				push hl 
0b90 d5				push de 
0b91 c5				push bc 
0b92			 
0b92				; get frame buffer  
0b92			 
0b92 2a cf f8			ld hl, (display_fb_active) 
0b95			 
0b95 11 9f 00			ld de, display_fb_len - 1 
0b98 19				add hl, de 
0b99			 
0b99 e5			push hl    ; future de destination 
0b9a			 
0b9a 11 28 00			ld  de, display_cols 
0b9d ed 52			sbc hl, de 
0b9f			 
0b9f			 
0b9f d1				pop de 
0ba0			 
0ba0			;	ex de, hl 
0ba0 01 9f 00			ld bc, display_fb_len -1  
0ba3			 
0ba3			 
0ba3				 
0ba3			 
0ba3 ed b0			ldir 
0ba5			 
0ba5				; wipe bottom row 
0ba5			 
0ba5			 
0ba5			;	ld hl, (display_fb_active) 
0ba5			;;	ld de, display_cols*display_rows 
0ba5			;;	add hl, de 
0ba5			;	ld b, display_cols 
0ba5			;	ld a, ' ' 
0ba5			;.scwiped: 
0ba5			;	ld (hl), a 
0ba5			;	dec hl 
0ba5			;	djnz .scwiped 
0ba5			 
0ba5				;pop hl 
0ba5			 
0ba5 c1				pop bc 
0ba6 d1				pop de 
0ba7 e1				pop hl 
0ba8			 
0ba8 c9				ret 
0ba9			;scroll_down: 
0ba9			;	ld de, display_row_4 
0ba9			;	ld hl, display_row_3 
0ba9			;	ld bc, display_cols 
0ba9			;	ldir 
0ba9			;	ld de, display_row_3 
0ba9			; 	ld hl, display_row_2 
0ba9			;	ld bc, display_cols 
0ba9			;	ldir 
0ba9			;	ld de, display_row_2 
0ba9			;	ld hl, display_row_1 
0ba9			;	ld bc, display_cols 
0ba9			;	ldir 
0ba9			;;; TODO clear row 1 
0ba9			;	ret 
0ba9			 
0ba9			 
0ba9			 
0ba9			 
0ba9			 
0ba9			; clear active frame buffer 
0ba9			 
0ba9			clear_display: 
0ba9 3e 20			ld a, ' ' 
0bab c3 ae 0b			jp fill_display 
0bae			 
0bae			; fill active frame buffer with a char in A 
0bae			 
0bae			fill_display: 
0bae 06 a0			ld b,display_fb_len 
0bb0 2a cf f8			ld hl, (display_fb_active) 
0bb3 77			.fd1:	ld (hl),a 
0bb4 23				inc hl 
0bb5 10 fc			djnz .fd1 
0bb7 23				inc hl 
0bb8 3e 00			ld a,0 
0bba 77				ld (hl),a 
0bbb			 
0bbb			 
0bbb c9				ret 
0bbc			; Write string (DE) at pos (A) to active frame buffer 
0bbc			 
0bbc 2a cf f8		str_at_display:    ld hl,(display_fb_active) 
0bbf 06 00					ld b,0 
0bc1 4f					ld c,a 
0bc2 09					add hl,bc 
0bc3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bc4 b7			            OR   A              ;Null terminator? 
0bc5 c8			            RET  Z              ;Yes, so finished 
0bc6 77					ld (hl),a 
0bc7 23				inc hl 
0bc8 13			            INC  DE             ;Point to next character 
0bc9 18 f8		            JR   .sad1     ;Repeat 
0bcb c9					ret 
0bcc			 
0bcc			; using current frame buffer write to physical display 
0bcc			 
0bcc			update_display: 
0bcc e5				push hl 
0bcd 2a cf f8			ld hl, (display_fb_active) 
0bd0 cd df 67			call write_display 
0bd3 e1				pop hl 
0bd4 c9				ret 
0bd5			 
0bd5			; TODO scrolling 
0bd5			 
0bd5			 
0bd5			; move cursor right one char 
0bd5			cursor_right: 
0bd5			 
0bd5				; TODO shift right 
0bd5				; TODO if beyond max col 
0bd5				; TODO       cursor_next_line 
0bd5			 
0bd5 c9				ret 
0bd6			 
0bd6			 
0bd6			cursor_next_line: 
0bd6				; TODO first char 
0bd6				; TODO line down 
0bd6				; TODO if past last row 
0bd6				; TODO    scroll up 
0bd6			 
0bd6 c9				ret 
0bd7			 
0bd7			cursor_left: 
0bd7				; TODO shift left 
0bd7				; TODO if beyond left  
0bd7				; TODO     cursor prev line 
0bd7				 
0bd7 c9				ret 
0bd8			 
0bd8			cursor_prev_line: 
0bd8				; TODO last char 
0bd8				; TODO line up 
0bd8				; TODO if past first row 
0bd8				; TODO   scroll down 
0bd8			 
0bd8 c9				ret 
0bd9			 
0bd9			 
0bd9			cout: 
0bd9				; A - char 
0bd9 c9				ret 
0bda			 
0bda			 
0bda			; Display a menu and allow item selection (optional toggle items) 
0bda			; 
0bda			; format: 
0bda			; hl pointer to word array with zero term for items 
0bda			; e.g.    db item1 
0bda			;         db .... 
0bda			;         db 0 
0bda			; 
0bda			; a = starting menu item  
0bda			; 
0bda			; de = pointer item toggle array   (todo) 
0bda			; 
0bda			; returns item selected in a 1-... 
0bda			; returns 0 if back button pressed 
0bda			; 
0bda			; NOTE: Uses system frame buffer to display 
0bda			; 
0bda			; LEFT, Q = go back 
0bda			; RIGHT, SPACE, CR = select 
0bda			; UP, A - Up 
0bda			; DOWN, Z - Down 
0bda			 
0bda			 
0bda			 
0bda			 
0bda			 
0bda			menu: 
0bda			 
0bda					; keep array pointer 
0bda			 
0bda 22 57 f8				ld (store_tmp1), hl 
0bdd 32 55 f8				ld (store_tmp2), a 
0be0			 
0be0					; check for key bounce 
0be0			 
0be0			if BASE_KEV 
0be0			 
0be0 cd 2a 6b		.mbounce:	call cin 
0be3 fe 00				cp 0 
0be5 20 f9				jr nz, .mbounce 
0be7			endif 
0be7					; for ease use ex 
0be7			 
0be7					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0be7 21 b4 fa				ld hl, display_fb0 
0bea 22 cf f8				ld (display_fb_active), hl 
0bed			 
0bed cd a9 0b		.mloop:		call clear_display 
0bf0 cd cc 0b				call update_display 
0bf3			 
0bf3					; draw selection id '>' at 1 
0bf3			 
0bf3					; init start of list display 
0bf3			 
0bf3 3e 05				ld a, 5 
0bf5 32 53 f8				ld (store_tmp3), a   ; display row count 
0bf8 3a 55 f8				ld a,( store_tmp2) 
0bfb 32 56 f8				ld (store_tmp2+1), a   ; display item count 
0bfe			 
0bfe					 
0bfe			.mitem:	 
0bfe			 
0bfe			 
0bfe 3a 56 f8				ld a,(store_tmp2+1) 
0c01 6f					ld l, a 
0c02 26 00				ld h, 0 
0c04 29					add hl, hl 
0c05 ed 5b 57 f8			ld de, (store_tmp1) 
0c09 19					add hl, de 
0c0a 7e					ld a, (hl) 
0c0b 23					inc hl 
0c0c 66					ld h,(hl) 
0c0d 6f					ld l, a 
0c0e			 
0c0e cd 06 0e				call ishlzero 
0c11 28 1a				jr z, .mdone 
0c13			 
0c13 eb					ex de, hl 
0c14 3a 53 f8				ld a, (store_tmp3) 
0c17 cd bc 0b				call str_at_display 
0c1a					 
0c1a			 
0c1a					; next item 
0c1a 3a 56 f8				ld a, (store_tmp2+1) 
0c1d 3c					inc a 
0c1e 32 56 f8				ld (store_tmp2+1), a   ; display item count 
0c21			 
0c21			 		; next row 
0c21			 
0c21 3a 53 f8				ld a, (store_tmp3) 
0c24 c6 28				add display_cols 
0c26 32 53 f8				ld (store_tmp3), a 
0c29			 
0c29					; at end of screen? 
0c29			 
0c29 fe 10				cp display_rows*4 
0c2b 20 d1				jr nz, .mitem 
0c2d			 
0c2d			 
0c2d			.mdone: 
0c2d cd 06 0e				call ishlzero 
0c30 28 08				jr z, .nodn 
0c32			 
0c32 3e 78				ld a, display_row_4 
0c34 11 b3 0c				ld de, .mdown 
0c37 cd bc 0b				call str_at_display 
0c3a			 
0c3a					; draw options to fill the screens with active item on line 1 
0c3a					; if current option is 2 or more then display ^ in top 
0c3a			 
0c3a 3a 55 f8		.nodn:		ld a, (store_tmp2) 
0c3d fe 00				cp 0 
0c3f 28 08				jr z, .noup 
0c41			 
0c41 3e 00				ld a, 0 
0c43 11 b1 0c				ld de, .mup 
0c46 cd bc 0b				call str_at_display 
0c49			 
0c49 3e 02		.noup:		ld a, 2 
0c4b 11 af 0c				ld de, .msel 
0c4e cd bc 0b				call str_at_display 
0c51			 
0c51					; if current option + 1 is not null then display V in bottom 
0c51					; get key 
0c51 cd cc 0b				call update_display 
0c54			 
0c54			 
0c54					; handle key 
0c54			 
0c54 cd 19 6b				call cin_wait 
0c57			 
0c57 fe 05				cp KEY_UP 
0c59 28 2b				jr z, .mgoup 
0c5b fe 61				cp 'a' 
0c5d 28 27				jr z, .mgoup 
0c5f fe 0a				cp KEY_DOWN 
0c61 28 32				jr z, .mgod 
0c63 fe 7a				cp 'z' 
0c65 28 2e				jr z, .mgod 
0c67 fe 20				cp ' ' 
0c69 28 34				jr z, .goend 
0c6b fe 0c				cp KEY_RIGHT 
0c6d 28 30				jr z, .goend 
0c6f fe 0d				cp KEY_CR 
0c71 28 2c				jr z, .goend 
0c73 fe 71				cp 'q' 
0c75 28 0b				jr z, .goback 
0c77			 
0c77 fe 0b				cp KEY_LEFT 
0c79 28 07				jr z, .goback 
0c7b fe 08				cp KEY_BS 
0c7d 28 03				jr z, .goback 
0c7f c3 ed 0b				jp .mloop 
0c82			 
0c82			.goback: 
0c82 3e 00			ld a, 0 
0c84 18 1d			jr .goend2 
0c86			 
0c86				; move up one 
0c86			.mgoup: 
0c86 3a 55 f8				ld a, (store_tmp2) 
0c89 fe 00				cp 0 
0c8b ca ed 0b				jp z, .mloop 
0c8e 3d					dec a 
0c8f 32 55 f8				ld (store_tmp2), a 
0c92 c3 ed 0b				jp .mloop 
0c95			 
0c95				; move down one 
0c95			.mgod: 
0c95 3a 55 f8				ld a, (store_tmp2) 
0c98 3c					inc a 
0c99 32 55 f8				ld (store_tmp2), a 
0c9c c3 ed 0b				jp .mloop 
0c9f			 
0c9f			 
0c9f			.goend: 
0c9f					; get selected item number 
0c9f			 
0c9f 3a 55 f8				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3			 
0ca3			.goend2: 
0ca3 f5					push af 
0ca4			 
0ca4					; restore active fb 
0ca4					; TODO BUG assumes fb1 
0ca4			 
0ca4 21 13 fa				ld hl, display_fb1 
0ca7 22 cf f8				ld (display_fb_active), hl 
0caa			 
0caa					; restore main regs 
0caa			 
0caa			 
0caa cd cc 0b				call update_display 
0cad			 
0cad f1					pop af 
0cae			 
0cae c9				ret 
0caf			 
0caf .. 00		.msel:   db ">",0 
0cb1 .. 00		.mup:   db "^",0 
0cb3 .. 00		.mdown:   db "v",0 
0cb5			 
0cb5			 
0cb5			; eof 
0cb5			 
# End of file firmware_display.asm
0cb5			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cb5			; random number generators 
0cb5			 
0cb5			 
0cb5			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cb5			 
0cb5			 
0cb5			;-----> Generate a random number 
0cb5			; output a=answer 0<=a<=255 
0cb5			; all registers are preserved except: af 
0cb5			random: 
0cb5 e5			        push    hl 
0cb6 d5			        push    de 
0cb7 2a b1 f8		        ld      hl,(randData) 
0cba ed 5f		        ld      a,r 
0cbc 57			        ld      d,a 
0cbd 5e			        ld      e,(hl) 
0cbe 19			        add     hl,de 
0cbf 85			        add     a,l 
0cc0 ac			        xor     h 
0cc1 22 b1 f8		        ld      (randData),hl 
0cc4 d1			        pop     de 
0cc5 e1			        pop     hl 
0cc6 c9			        ret 
0cc7			 
0cc7			 
0cc7			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cc7			 
0cc7			 
0cc7			 
0cc7			;------LFSR------ 
0cc7			;James Montelongo 
0cc7			;optimized by Spencer Putt 
0cc7			;out: 
0cc7			; a = 8 bit random number 
0cc7			RandLFSR: 
0cc7 21 b7 f8		        ld hl,LFSRSeed+4 
0cca 5e			        ld e,(hl) 
0ccb 23			        inc hl 
0ccc 56			        ld d,(hl) 
0ccd 23			        inc hl 
0cce 4e			        ld c,(hl) 
0ccf 23			        inc hl 
0cd0 7e			        ld a,(hl) 
0cd1 47			        ld b,a 
0cd2 cb 13		        rl e  
0cd4 cb 12			rl d 
0cd6 cb 11		        rl c  
0cd8 17				rla 
0cd9 cb 13		        rl e  
0cdb cb 12			rl d 
0cdd cb 11		        rl c  
0cdf 17				rla 
0ce0 cb 13		        rl e  
0ce2 cb 12			rl d 
0ce4 cb 11		        rl c  
0ce6 17				rla 
0ce7 67			        ld h,a 
0ce8 cb 13		        rl e  
0cea cb 12			rl d 
0cec cb 11		        rl c  
0cee 17				rla 
0cef a8			        xor b 
0cf0 cb 13		        rl e  
0cf2 cb 12			rl d 
0cf4 ac			        xor h 
0cf5 a9			        xor c 
0cf6 aa			        xor d 
0cf7 21 b9 f8		        ld hl,LFSRSeed+6 
0cfa 11 ba f8		        ld de,LFSRSeed+7 
0cfd 01 07 00		        ld bc,7 
0d00 ed b8		        lddr 
0d02 12			        ld (de),a 
0d03 c9			        ret 
0d04			 
0d04			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d04			 
0d04			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d04			 
0d04			 
0d04			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d04			 
0d04			prng16: 
0d04			;Inputs: 
0d04			;   (seed1) contains a 16-bit seed value 
0d04			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d04			;Outputs: 
0d04			;   HL is the result 
0d04			;   BC is the result of the LCG, so not that great of quality 
0d04			;   DE is preserved 
0d04			;Destroys: 
0d04			;   AF 
0d04			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d04			;160cc 
0d04			;26 bytes 
0d04 2a ab f8		    ld hl,(seed1) 
0d07 44			    ld b,h 
0d08 4d			    ld c,l 
0d09 29			    add hl,hl 
0d0a 29			    add hl,hl 
0d0b 2c			    inc l 
0d0c 09			    add hl,bc 
0d0d 22 ab f8		    ld (seed1),hl 
0d10 2a a9 f8		    ld hl,(seed2) 
0d13 29			    add hl,hl 
0d14 9f			    sbc a,a 
0d15 e6 2d		    and %00101101 
0d17 ad			    xor l 
0d18 6f			    ld l,a 
0d19 22 a9 f8		    ld (seed2),hl 
0d1c 09			    add hl,bc 
0d1d c9			    ret 
0d1e			 
0d1e			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d1e			 
0d1e			rand32: 
0d1e			;Inputs: 
0d1e			;   (seed1_0) holds the lower 16 bits of the first seed 
0d1e			;   (seed1_1) holds the upper 16 bits of the first seed 
0d1e			;   (seed2_0) holds the lower 16 bits of the second seed 
0d1e			;   (seed2_1) holds the upper 16 bits of the second seed 
0d1e			;   **NOTE: seed2 must be non-zero 
0d1e			;Outputs: 
0d1e			;   HL is the result 
0d1e			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d1e			;Destroys: 
0d1e			;   AF 
0d1e			;Tested and passes all CAcert tests 
0d1e			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d1e			;it has a period of 18,446,744,069,414,584,320 
0d1e			;roughly 18.4 quintillion. 
0d1e			;LFSR taps: 0,2,6,7  = 11000101 
0d1e			;291cc 
0d1e			;seed1_0=$+1 
0d1e			;    ld hl,12345 
0d1e			;seed1_1=$+1 
0d1e			;    ld de,6789 
0d1e			;    ld b,h 
0d1e			;    ld c,l 
0d1e			;    add hl,hl \ rl e \ rl d 
0d1e			;    add hl,hl \ rl e \ rl d 
0d1e			;    inc l 
0d1e			;    add hl,bc 
0d1e			;    ld (seed1_0),hl 
0d1e			;    ld hl,(seed1_1) 
0d1e			;    adc hl,de 
0d1e			;    ld (seed1_1),hl 
0d1e			;    ex de,hl 
0d1e			;seed2_0=$+1 
0d1e			;    ld hl,9876 
0d1e			;seed2_1=$+1 
0d1e			;    ld bc,54321 
0d1e			;    add hl,hl \ rl c \ rl b 
0d1e			;    ld (seed2_1),bc 
0d1e			;    sbc a,a 
0d1e			;    and %11000101 
0d1e			;    xor l 
0d1e			;    ld l,a 
0d1e			;    ld (seed2_0),hl 
0d1e			;    ex de,hl 
0d1e			;    add hl,bc 
0d1e			;    ret 
0d1e			; 
0d1e			 
0d1e			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d1e			; 20 bytes, 86 cycles (excluding ret) 
0d1e			 
0d1e			; returns   hl = pseudorandom number 
0d1e			; corrupts   a 
0d1e			 
0d1e			; generates 16-bit pseudorandom numbers with a period of 65535 
0d1e			; using the xorshift method: 
0d1e			 
0d1e			; hl ^= hl << 7 
0d1e			; hl ^= hl >> 9 
0d1e			; hl ^= hl << 8 
0d1e			 
0d1e			; some alternative shift triplets which also perform well are: 
0d1e			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d1e			 
0d1e			;  org 32768 
0d1e			 
0d1e			xrnd: 
0d1e 2a af f8		  ld hl,(xrandc)       ; seed must not be 0 
0d21 3e 00		  ld a,0 
0d23 bd			  cp l 
0d24 20 02		  jr nz, .xrnd1 
0d26 2e 01		  ld l, 1 
0d28			.xrnd1: 
0d28			 
0d28 7c			  ld a,h 
0d29 1f			  rra 
0d2a 7d			  ld a,l 
0d2b 1f			  rra 
0d2c ac			  xor h 
0d2d 67			  ld h,a 
0d2e 7d			  ld a,l 
0d2f 1f			  rra 
0d30 7c			  ld a,h 
0d31 1f			  rra 
0d32 ad			  xor l 
0d33 6f			  ld l,a 
0d34 ac			  xor h 
0d35 67			  ld h,a 
0d36			 
0d36 22 af f8		  ld (xrandc),hl 
0d39			 
0d39 c9			  ret 
0d3a			;  
0d3a			 
0d3a			 
0d3a			;;;; int maths 
0d3a			 
0d3a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d3a			; Divide 16-bit values (with 16-bit result) 
0d3a			; In: Divide BC by divider DE 
0d3a			; Out: BC = result, HL = rest 
0d3a			; 
0d3a			Div16: 
0d3a 21 00 00		    ld hl,0 
0d3d 78			    ld a,b 
0d3e 06 08		    ld b,8 
0d40			Div16_Loop1: 
0d40 17			    rla 
0d41 ed 6a		    adc hl,hl 
0d43 ed 52		    sbc hl,de 
0d45 30 01		    jr nc,Div16_NoAdd1 
0d47 19			    add hl,de 
0d48			Div16_NoAdd1: 
0d48 10 f6		    djnz Div16_Loop1 
0d4a 17			    rla 
0d4b 2f			    cpl 
0d4c 47			    ld b,a 
0d4d 79			    ld a,c 
0d4e 48			    ld c,b 
0d4f 06 08		    ld b,8 
0d51			Div16_Loop2: 
0d51 17			    rla 
0d52 ed 6a		    adc hl,hl 
0d54 ed 52		    sbc hl,de 
0d56 30 01		    jr nc,Div16_NoAdd2 
0d58 19			    add hl,de 
0d59			Div16_NoAdd2: 
0d59 10 f6		    djnz Div16_Loop2 
0d5b 17			    rla 
0d5c 2f			    cpl 
0d5d 41			    ld b,c 
0d5e 4f			    ld c,a 
0d5f c9			ret 
0d60			 
0d60			 
0d60			;http://z80-heaven.wikidot.com/math 
0d60			; 
0d60			;Inputs: 
0d60			;     DE and A are factors 
0d60			;Outputs: 
0d60			;     A is not changed 
0d60			;     B is 0 
0d60			;     C is not changed 
0d60			;     DE is not changed 
0d60			;     HL is the product 
0d60			;Time: 
0d60			;     342+6x 
0d60			; 
0d60			Mult16: 
0d60			 
0d60 06 08		     ld b,8          ;7           7 
0d62 21 00 00		     ld hl,0         ;10         10 
0d65 29			       add hl,hl     ;11*8       88 
0d66 07			       rlca          ;4*8        32 
0d67 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d69 19			         add hl,de   ;--         -- 
0d6a 10 f9		       djnz $-5      ;13*7+8     99 
0d6c c9			ret 
0d6d			 
0d6d			; 
0d6d			; Square root of 16-bit value 
0d6d			; In:  HL = value 
0d6d			; Out:  D = result (rounded down) 
0d6d			; 
0d6d			;Sqr16: 
0d6d			;    ld de,#0040 
0d6d			;    ld a,l 
0d6d			;    ld l,h 
0d6d			;    ld h,d 
0d6d			;    or a 
0d6d			;    ld b,8 
0d6d			;Sqr16_Loop: 
0d6d			;    sbc hl,de 
0d6d			;    jr nc,Sqr16_Skip 
0d6d			;    add hl,de 
0d6d			;Sqr16_Skip: 
0d6d			;    ccf 
0d6d			;    rl d 
0d6d			;    add a,a 
0d6d			;    adc hl,hl 
0d6d			;    add a,a 
0d6d			;    adc hl,hl 
0d6d			;    djnz Sqr16_Loop 
0d6d			;    ret 
0d6d			; 
0d6d			; 
0d6d			; Divide 8-bit values 
0d6d			; In: Divide E by divider C 
0d6d			; Out: A = result, B = rest 
0d6d			; 
0d6d			Div8: 
0d6d af			    xor a 
0d6e 06 08		    ld b,8 
0d70			Div8_Loop: 
0d70 cb 13		    rl e 
0d72 17			    rla 
0d73 91			    sub c 
0d74 30 01		    jr nc,Div8_NoAdd 
0d76 81			    add a,c 
0d77			Div8_NoAdd: 
0d77 10 f7		    djnz Div8_Loop 
0d79 47			    ld b,a 
0d7a 7b			    ld a,e 
0d7b 17			    rla 
0d7c 2f			    cpl 
0d7d c9			    ret 
0d7e			 
0d7e			; 
0d7e			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d7e			; In: Multiply A with DE 
0d7e			; Out: HL = result 
0d7e			; 
0d7e			Mult12U: 
0d7e 2e 00		    ld l,0 
0d80 87			    add a,a 
0d81 30 01		    jr nc,Mult12U_NoAdd0 
0d83 19			    add hl,de 
0d84			Mult12U_NoAdd0: 
0d84 29			    add hl,hl 
0d85 87			    add a,a 
0d86 30 01		    jr nc,Mult12U_NoAdd1 
0d88 19			    add hl,de 
0d89			Mult12U_NoAdd1: 
0d89 29			    add hl,hl 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd2 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd2: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd3 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd3: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd4 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd4: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd5 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd5: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd6 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd6: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 d0			    ret nc 
0da5 19			    add hl,de 
0da6 c9			    ret 
0da7			 
0da7			; 
0da7			; Multiply 8-bit value with a 16-bit value (right rotating) 
0da7			; In: Multiply A with DE 
0da7			;      Put lowest value in A for most efficient calculation 
0da7			; Out: HL = result 
0da7			; 
0da7			Mult12R: 
0da7 21 00 00		    ld hl,0 
0daa			Mult12R_Loop: 
0daa cb 3f		    srl a 
0dac 30 01		    jr nc,Mult12R_NoAdd 
0dae 19			    add hl,de 
0daf			Mult12R_NoAdd: 
0daf cb 23		    sla e 
0db1 cb 12		    rl d 
0db3 b7			    or a 
0db4 c2 aa 0d		    jp nz,Mult12R_Loop 
0db7 c9			    ret 
0db8			 
0db8			; 
0db8			; Multiply 16-bit values (with 32-bit result) 
0db8			; In: Multiply BC with DE 
0db8			; Out: BCHL = result 
0db8			; 
0db8			Mult32: 
0db8 79			    ld a,c 
0db9 48			    ld c,b 
0dba 21 00 00		    ld hl,0 
0dbd 06 10		    ld b,16 
0dbf			Mult32_Loop: 
0dbf 29			    add hl,hl 
0dc0 17			    rla 
0dc1 cb 11		    rl c 
0dc3 30 07		    jr nc,Mult32_NoAdd 
0dc5 19			    add hl,de 
0dc6 ce 00		    adc a,0 
0dc8 d2 cc 0d		    jp nc,Mult32_NoAdd 
0dcb 0c			    inc c 
0dcc			Mult32_NoAdd: 
0dcc 10 f1		    djnz Mult32_Loop 
0dce 41			    ld b,c 
0dcf 4f			    ld c,a 
0dd0 c9			    ret 
0dd1			 
0dd1			 
0dd1			 
0dd1			; 
0dd1			; Multiply 8-bit values 
0dd1			; In:  Multiply H with E 
0dd1			; Out: HL = result 
0dd1			; 
0dd1			Mult8: 
0dd1 16 00		    ld d,0 
0dd3 6a			    ld l,d 
0dd4 06 08		    ld b,8 
0dd6			Mult8_Loop: 
0dd6 29			    add hl,hl 
0dd7 30 01		    jr nc,Mult8_NoAdd 
0dd9 19			    add hl,de 
0dda			Mult8_NoAdd: 
0dda 10 fa		    djnz Mult8_Loop 
0ddc c9			    ret 
0ddd			 
0ddd			 
0ddd			 
0ddd			 
0ddd			 
0ddd			 
0ddd			 
0ddd			 
0ddd			;;http://z80-heaven.wikidot.com/math 
0ddd			;;This divides DE by BC, storing the result in DE, remainder in HL 
0ddd			; 
0ddd			;DE_Div_BC:          ;1281-2x, x is at most 16 
0ddd			;     ld a,16        ;7 
0ddd			;     ld hl,0        ;10 
0ddd			;     jp $+5         ;10 
0ddd			;.DivLoop: 
0ddd			;       add hl,bc    ;-- 
0ddd			;       dec a        ;64 
0ddd			;       jr z,.DivLoopEnd        ;86 
0ddd			; 
0ddd			;       sla e        ;128 
0ddd			;       rl d         ;128 
0ddd			;       adc hl,hl    ;240 
0ddd			;       sbc hl,bc    ;240 
0ddd			;       jr nc,.DivLoop ;23|21 
0ddd			;       inc e        ;-- 
0ddd			;       jp .DivLoop+1 
0ddd			; 
0ddd			;.DivLoopEnd: 
0ddd			 
0ddd			;HL_Div_C: 
0ddd			;Inputs: 
0ddd			;     HL is the numerator 
0ddd			;     C is the denominator 
0ddd			;Outputs: 
0ddd			;     A is the remainder 
0ddd			;     B is 0 
0ddd			;     C is not changed 
0ddd			;     DE is not changed 
0ddd			;     HL is the quotient 
0ddd			; 
0ddd			;       ld b,16 
0ddd			;       xor a 
0ddd			;         add hl,hl 
0ddd			;         rla 
0ddd			;         cp c 
0ddd			;         jr c,$+4 
0ddd			;           inc l 
0ddd			;           sub c 
0ddd			;         djnz $-7 
0ddd			 
0ddd			; https://plutiedev.com/z80-add-8bit-to-16bit 
0ddd			 
0ddd			addatohl: 
0ddd 85			    add   a, l    ; A = A+L 
0dde 6f			    ld    l, a    ; L = A+L 
0ddf 8c			    adc   a, h    ; A = A+L+H+carry 
0de0 95			    sub   l       ; A = H+carry 
0de1 67			    ld    h, a    ; H = H+carry 
0de2 c9			ret 
0de3			 
0de3			addatode: 
0de3 83			    add   a, e    ; A = A+L 
0de4 5f			    ld    e, a    ; L = A+L 
0de5 8a			    adc   a, d    ; A = A+L+H+carry 
0de6 93			    sub   e       ; A = H+carry 
0de7 57			    ld    d, a    ; H = H+carry 
0de8 c9			ret 
0de9			 
0de9			 
0de9			addatobc: 
0de9 81			    add   a, c    ; A = A+L 
0dea 4f			    ld    c, a    ; L = A+L 
0deb 88			    adc   a, b    ; A = A+L+H+carry 
0dec 91			    sub   c       ; A = H+carry 
0ded 47			    ld    b, a    ; H = H+carry 
0dee c9			ret 
0def			 
0def			subafromhl: 
0def			   ; If A=0 do nothing 
0def			    ; Otherwise flip A's sign. Since 
0def			    ; the upper byte becomes -1, also 
0def			    ; substract 1 from H. 
0def ed 44		    neg 
0df1 ca fa 0d		    jp    z, Skip 
0df4 25			    dec   h 
0df5			     
0df5			    ; Now add the low byte as usual 
0df5			    ; Two's complement takes care of 
0df5			    ; ensuring the result is correct 
0df5 85			    add   a, l 
0df6 6f			    ld    l, a 
0df7 8c			    adc   a, h 
0df8 95			    sub   l 
0df9 67			    ld    h, a 
0dfa			Skip: 
0dfa c9				ret 
0dfb			 
0dfb			 
0dfb			; compare hl and de 
0dfb			; returns:  
0dfb			; if hl = de, z=1, s=0, c0=0 
0dfb			; if hl > de, z=0, s=0, c=0 
0dfb			; if hl < de, z=0, s=1, c=1 
0dfb			cmp16:	 
0dfb b7				or a 
0dfc ed 52			sbc hl,de 
0dfe e0				ret po 
0dff 7c				ld a,h 
0e00 1f				rra 
0e01 ee 40			xor 01000000B 
0e03 37				scf 
0e04 8f				adc a,a 
0e05 c9				ret 
0e06			 
0e06			 
0e06			; test if hl contains zero   - A is destroyed 
0e06			 
0e06			ishlzero:    
0e06 b7				or a     ; reset flags 
0e07 7c				ld a, h 
0e08 b5				or l        	 
0e09			 
0e09 c9				ret 
0e0a			 
0e0a			 
0e0a			 
0e0a			 
0e0a			if FORTH_ENABLE_FLOATMATH 
0e0a			;include "float/bbcmath.z80" 
0e0a			include "float/lpfpcalc.asm" 
0e0a			endif 
0e0a			 
0e0a			 
0e0a			; eof 
0e0a			 
# End of file firmware_maths.asm
0e0a			include "firmware_strings.asm"   ; string handling  
0e0a			 
0e0a			 
0e0a			; TODO string len 
0e0a			; input text string, end on cr with zero term 
0e0a			; a offset into frame buffer to start prompt 
0e0a			; d is max length 
0e0a			; e is display size TODO 
0e0a			; c is current cursor position 
0e0a			; hl is ptr to where string will be stored 
0e0a			 
0e0a			 
0e0a			; TODO check limit of buffer for new inserts 
0e0a			; TODO check insert does not push beyond buffer 
0e0a			; TODO scroll in a limited display area 
0e0a			; TODO scroll whole screen on page wrap 
0e0a			 
0e0a			 
0e0a			; TODO handle KEY_PREVWORD 
0e0a			; TODO handle KEY_NEXTWORD 
0e0a			; TODO handle KEY_HOME 
0e0a			; TODO handle KEY_END 
0e0a			; TODO use LCD cursor? 
0e0a			 
0e0a 32 67 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e0d 81					add c 
0e0e 32 65 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0e11 22 6a fb				ld (input_start), hl     ; save ptr to buffer 
0e14 79					ld a, c 
0e15 cd dd 0d				call addatohl 
0e18 22 6c fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e1b 7a					ld a,d 
0e1c 32 69 fb			        ld (input_size), a       ; save length of input area 
0e1f 79					ld a, c 
0e20 32 58 fb				ld (input_cursor),a      ; init cursor start position  
0e23 7b					ld a,e 
0e24 32 68 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e27					 
0e27					 
0e27			 
0e27			;		ld a,(input_ptr) 
0e27			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e27			 
0e27			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e27					; init cursor shape if not set by the cin routines 
0e27 21 c7 f8				ld hl, cursor_shape 
0e2a 3e ff				ld a, 255 
0e2c 77					ld (hl), a 
0e2d 23					inc hl 
0e2e 3e 00				ld a, 0 
0e30 77					ld (hl), a 
0e31			 
0e31 3e 0f				ld a, CUR_BLINK_RATE 
0e33 32 63 fb				ld (input_cur_flash), a 
0e36 3e 01				ld a, 1 
0e38 32 62 fb				ld (input_cur_onoff),a 
0e3b			 
0e3b			;	if DEBUG_INPUT 
0e3b			;		push af 
0e3b			;		ld a, 'I' 
0e3b			;		ld (debug_mark),a 
0e3b			;		pop af 
0e3b			;		CALLMONITOR 
0e3b			;	endif 
0e3b			.is1:		; main entry loop 
0e3b			 
0e3b			 
0e3b			 
0e3b					; pause 1ms 
0e3b			 
0e3b 3e 01				ld a, 1 
0e3d cd 0b 0b				call aDelayInMS 
0e40			 
0e40					; dec flash counter 
0e40 3a 63 fb				ld a, (input_cur_flash) 
0e43 3d					dec a 
0e44 32 63 fb				ld (input_cur_flash), a 
0e47 fe 00				cp 0 
0e49 20 0d				jr nz, .nochgstate 
0e4b			 
0e4b			 
0e4b					; change state 
0e4b 3a 62 fb				ld a,(input_cur_onoff) 
0e4e ed 44				neg 
0e50 32 62 fb				ld (input_cur_onoff),a 
0e53			 
0e53			 
0e53					; reset on change of state 
0e53 3e 0f				ld a, CUR_BLINK_RATE 
0e55 32 63 fb				ld (input_cur_flash), a 
0e58			 
0e58			.nochgstate: 
0e58					 
0e58					 
0e58			 
0e58					; display cursor  
0e58			 
0e58			;		ld hl, (input_start) 
0e58			;		ld a, (input_cursor) 
0e58			;		call addatohl 
0e58			 
0e58					; get char under cursor and replace with cursor 
0e58 2a 6c fb		ld hl, (input_ptr) 
0e5b			;		ld a, (hl) 
0e5b			;		ld (input_under_cursor),a 
0e5b			;		ld a, '_' 
0e5b			;		ld (hl), a 
0e5b			 
0e5b					; display string 
0e5b			 
0e5b ed 5b 6a fb			ld de, (input_start) 
0e5f 3a 67 fb				ld a, (input_at_pos) 
0e62 cd bc 0b				call str_at_display 
0e65			;	        call update_display 
0e65			 
0e65					; find place to put the cursor 
0e65			;		add h 
0e65			;		ld l, display_row_1 
0e65			;		sub l 
0e65			; (input_at_pos) 
0e65					;ld c, a 
0e65			;		ld a, (input_cursor) 
0e65			;		ld l, (input_at_pos) 
0e65			;		;ld b, h 
0e65			;		add l 
0e65			;		ld (input_at_cursor),a 
0e65					;ld l,h 
0e65			 
0e65			;		ld h, 0 
0e65			;		ld l,(input_at_pos) 
0e65			;		ld a, (input_cursor) 
0e65			;		call addatohl 
0e65			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e65			;		call subafromhl 
0e65			;		ld a,l 
0e65			;		ld (input_at_cursor), a 
0e65			 
0e65				if DEBUG_INPUT 
0e65					ld a, (hardware_diag) 
0e65					cp 0 
0e65					jr z, .skip_input_diag 
0e65			 
0e65					ld a,(input_at_pos) 
0e65					ld hl, LFSRSeed 
0e65					call hexout 
0e65					ld a, (input_cursor) 
0e65					ld hl, LFSRSeed+2 
0e65					call hexout 
0e65					ld a,(input_at_cursor) 
0e65					ld hl, LFSRSeed+4 
0e65					call hexout 
0e65			 
0e65					ld a,(input_cur_onoff) 
0e65					ld hl, LFSRSeed+6 
0e65					call hexout 
0e65			 
0e65					ld a,(input_cur_flash) 
0e65					ld hl, LFSRSeed+8 
0e65					call hexout 
0e65			 
0e65					ld a,(input_len) 
0e65					ld hl, LFSRSeed+10 
0e65					call hexout 
0e65					ld hl, LFSRSeed+12 
0e65					ld a, 0 
0e65					ld (hl),a 
0e65					ld a, display_row_4 
0e65					ld de, LFSRSeed 
0e65					call str_at_display 
0e65					.skip_input_diag: 
0e65				endif 
0e65			 
0e65					; decide on if we are showing the cursor this time round 
0e65			 
0e65 3a 62 fb				ld a, (input_cur_onoff) 
0e68 fe ff				cp 255 
0e6a 28 13				jr z, .skipcur 
0e6c			 
0e6c			 
0e6c 3a 65 fb				ld a,(input_at_cursor) 
0e6f 11 c7 f8				ld de, cursor_shape 
0e72 cd bc 0b				call str_at_display 
0e75			 
0e75					; save length of current input string 
0e75 2a 6a fb				ld hl, (input_start) 
0e78 cd 3b 12				call strlenz 
0e7b 7d					ld a,l 
0e7c 32 5d fb				ld (input_len),a 
0e7f			 
0e7f			.skipcur: 
0e7f			 
0e7f cd cc 0b			        call update_display 
0e82					 
0e82			 
0e82			 
0e82					; wait 
0e82				 
0e82					; TODO loop without wait to flash the cursor and char under cursor	 
0e82 cd 2a 6b				call cin    ; _wait 
0e85			 
0e85 fe 00				cp 0 
0e87 ca 3b 0e				jp z, .is1 
0e8a			 
0e8a					; get ptr to char to input into 
0e8a			 
0e8a 4f					ld c,a 
0e8b 2a 6a fb				ld hl, (input_start) 
0e8e 3a 58 fb				ld a, (input_cursor) 
0e91 cd dd 0d				call addatohl 
0e94 22 6c fb				ld (input_ptr), hl 
0e97 79					ld a,c 
0e98			 
0e98					; replace char under cursor 
0e98			 
0e98			;		ld hl, (input_ptr) 
0e98			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e98			;		ld (hl), a 
0e98			 
0e98			;	if DEBUG_INPUT 
0e98			;		push af 
0e98			;		ld a, 'i' 
0e98			;		ld (debug_mark),a 
0e98			;		pop af 
0e98			;		CALLMONITOR 
0e98			;	endif 
0e98 fe 0e				cp KEY_HOME 
0e9a 20 0e				jr nz, .iske 
0e9c			 
0e9c 3a 67 fb				ld a, (input_at_pos) 
0e9f 32 65 fb				ld (input_at_cursor),a 
0ea2 3e 00				ld a, 0 
0ea4 32 58 fb				ld (input_cursor), a 
0ea7 c3 3b 0e				jp .is1 
0eaa					 
0eaa fe 0f		.iske:		cp KEY_END 
0eac 20 03				jr nz, .isknw 
0eae c3 3b 0e				jp .is1 
0eb1			 
0eb1 fe 06		.isknw:		cp KEY_NEXTWORD 
0eb3 20 1b				jr nz, .iskpw 
0eb5			 
0eb5 2a 6c fb		.isknwm:	ld hl, (input_ptr) 
0eb8 7e					ld a,(hl)	 
0eb9 fe 00				cp 0 
0ebb ca 3b 0e				jp z, .is1    ; end of string 
0ebe fe 20				cp ' ' 
0ec0 ca 3b 0e				jp z, .is1    ; end of word 
0ec3 23					inc hl 
0ec4 22 6c fb				ld (input_ptr), hl 
0ec7 3a 65 fb				ld a, (input_at_cursor) 
0eca 3c					inc a 
0ecb 32 65 fb				ld (input_at_cursor), a 
0ece 18 e5				jr .isknwm 
0ed0			 
0ed0 fe 07		.iskpw:		cp KEY_PREVWORD 
0ed2 20 1b				jr nz, .iskl 
0ed4			.iskpwm:	 
0ed4 2a 6c fb				ld hl, (input_ptr) 
0ed7 7e					ld a,(hl)	 
0ed8 fe 00				cp 0  
0eda ca 3b 0e				jp z, .is1    ; end of string 
0edd fe 20				cp ' ' 
0edf ca 3b 0e				jp z, .is1    ; end of word 
0ee2 2b					dec hl 
0ee3 22 6c fb				ld (input_ptr), hl 
0ee6 3a 65 fb				ld a, (input_at_cursor) 
0ee9 3d					dec a 
0eea 32 65 fb				ld (input_at_cursor), a 
0eed 18 e5				jr .iskpwm 
0eef			 
0eef			 
0eef fe 0b		.iskl:		cp KEY_LEFT 
0ef1 20 27				jr nz, .isk1 
0ef3			 
0ef3 3a 58 fb				ld a, (input_cursor) 
0ef6			 
0ef6 fe 00				cp 0 
0ef8 ca 3b 0e				jp z, .is1 		; at start of line to ignore  
0efb			 
0efb 3d					dec  a 		; TODO check underflow 
0efc 32 58 fb				ld (input_cursor), a 
0eff			 
0eff 2a 6c fb				ld hl, (input_ptr) 
0f02 2b					dec hl 
0f03 22 6c fb				ld (input_ptr), hl 
0f06					 
0f06 3a 65 fb				ld a, (input_at_cursor) 
0f09 3d					dec a 
0f0a 32 65 fb				ld (input_at_cursor), a 
0f0d			 
0f0d 3e 01				ld a, 1		; show cursor moving 
0f0f 32 62 fb				ld (input_cur_onoff),a 
0f12 3e 0f				ld a, CUR_BLINK_RATE 
0f14 32 63 fb				ld (input_cur_flash), a 
0f17			 
0f17 c3 3b 0e				jp .is1 
0f1a			 
0f1a fe 0c		.isk1:		cp KEY_RIGHT 
0f1c 20 2a				jr nz, .isk2 
0f1e			 
0f1e 3a 5d fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f21 5f					ld e,a 
0f22 3a 58 fb				ld a, (input_cursor) 
0f25 bb					cp e 
0f26 ca 3b 0e				jp z, .is1		; at the end of string so dont go right 
0f29			 
0f29 3c					inc  a 		; TODO check overflow 
0f2a 32 58 fb				ld (input_cursor), a 
0f2d			 
0f2d 3a 65 fb				ld a, (input_at_cursor) 
0f30 3c					inc a 
0f31 32 65 fb				ld (input_at_cursor), a 
0f34			 
0f34 2a 6c fb				ld hl, (input_ptr) 
0f37 23					inc hl 
0f38 22 6c fb				ld (input_ptr), hl 
0f3b			 
0f3b 3e 01				ld a, 1		; show cursor moving 
0f3d 32 62 fb				ld (input_cur_onoff),a 
0f40 3e 0f				ld a, CUR_BLINK_RATE 
0f42 32 63 fb				ld (input_cur_flash), a 
0f45			 
0f45 c3 3b 0e				jp .is1 
0f48			 
0f48 fe 05		.isk2:		cp KEY_UP 
0f4a			 
0f4a 20 26				jr nz, .isk3 
0f4c			 
0f4c					; swap last command with the current on 
0f4c			 
0f4c					; move cursor to start of string 
0f4c 2a 6a fb				ld hl, (input_start) 
0f4f 22 6c fb				ld (input_ptr), hl 
0f52			 
0f52 3a 67 fb				ld a, (input_at_pos) 
0f55 32 65 fb				ld (input_at_cursor), a 
0f58			 
0f58 3e 00				ld a, 0 
0f5a 32 58 fb				ld (input_cursor), a 
0f5d					 
0f5d					; swap input and last command buffers 
0f5d			 
0f5d 21 3b f1				ld hl, os_cli_cmd 
0f60 11 3a f2				ld de, os_last_cmd 
0f63 06 ff				ld b, 255 
0f65 7e			.swap1:		ld a, (hl) 
0f66 4f					ld c,a 
0f67 1a					ld a, (de) 
0f68 77					ld (hl), a 
0f69 79					ld a,c 
0f6a 12					ld (de),a 
0f6b 23					inc hl 
0f6c 13					inc de 
0f6d 10 f6				djnz .swap1 
0f6f			 
0f6f			 
0f6f			 
0f6f			 
0f6f			 
0f6f c3 3b 0e				jp .is1 
0f72			 
0f72 fe 08		.isk3:		cp KEY_BS 
0f74 20 3c				jr nz, .isk4 
0f76			 
0f76 3a 58 fb				ld a, (input_cursor) 
0f79			 
0f79 fe 00				cp 0 
0f7b ca 3b 0e				jp z, .is1 		; at start of line to ignore  
0f7e			 
0f7e 3d					dec  a 		; TODO check underflow 
0f7f 32 58 fb				ld (input_cursor), a 
0f82			 
0f82					; hl is source 
0f82					; de needs to be source - 1 
0f82			 
0f82			;		ld a, 0 
0f82			;		dec hl 
0f82			;		ld (hl), a 
0f82			 
0f82 2a 6c fb				ld hl, (input_ptr) 
0f85 2b					dec hl 
0f86 22 6c fb				ld (input_ptr), hl 
0f89			 
0f89					; shift all data 
0f89			 
0f89 e5					push hl 
0f8a 23					inc hl 
0f8b d1					pop de 
0f8c 3a 5d fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f8f 4f					ld c,a 
0f90 06 00				ld b,0 
0f92 ed b0				ldir  
0f94			 
0f94			 
0f94			 
0f94			 
0f94 3a 65 fb				ld a, (input_at_cursor) 
0f97 3d					dec a 
0f98 32 65 fb				ld (input_at_cursor), a 
0f9b			 
0f9b			 
0f9b 3e 01				ld a, 1		; show cursor moving 
0f9d 32 62 fb				ld (input_cur_onoff),a 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fb				ld (input_cur_flash), a 
0fa5			 
0fa5					; remove char 
0fa5 3a 65 fb				ld a, (input_at_cursor) 
0fa8 3c					inc a 
0fa9 11 33 10				ld de,.iblank 
0fac cd bc 0b				call str_at_display 
0faf			 
0faf c3 3b 0e				jp .is1 
0fb2			 
0fb2 fe 0d		.isk4:		cp KEY_CR 
0fb4 28 6c				jr z, .endinput 
0fb6			 
0fb6					; else add the key press to the end 
0fb6			 
0fb6 4f					ld c, a			; save key pressed 
0fb7			 
0fb7 7e					ld a,(hl)		; get what is currently under char 
0fb8			 
0fb8 fe 00				cp 0			; we are at the end of the string 
0fba 20 2f				jr nz, .onchar 
0fbc					 
0fbc					; add a char to the end of the string 
0fbc				 
0fbc 71					ld (hl),c 
0fbd 23					inc hl 
0fbe			;		ld a,' ' 
0fbe			;		ld (hl),a 
0fbe			;		inc hl 
0fbe 3e 00				ld a,0 
0fc0 77					ld (hl),a 
0fc1 2b					dec hl 
0fc2			 
0fc2 3a 58 fb				ld a, (input_cursor) 
0fc5 3c					inc a				; TODO check max string length and scroll  
0fc6 32 58 fb				ld (input_cursor), a		; inc cursor pos 
0fc9							 
0fc9 3a 65 fb				ld a, (input_at_cursor) 
0fcc 3c					inc a 
0fcd 32 65 fb				ld (input_at_cursor), a 
0fd0			 
0fd0 2a 6c fb				ld hl, (input_ptr) 
0fd3 23					inc hl 
0fd4 22 6c fb				ld (input_ptr), hl 
0fd7			 
0fd7 2a 6c fb				ld hl, (input_ptr) 
0fda 23					inc hl 
0fdb 22 6c fb				ld (input_ptr), hl 
0fde			;	if DEBUG_INPUT 
0fde			;		push af 
0fde			;		ld a, '+' 
0fde			;		ld (debug_mark),a 
0fde			;		pop af 
0fde			;		CALLMONITOR 
0fde			;	endif 
0fde 3e 01				ld a, 1		; show cursor moving 
0fe0 32 62 fb				ld (input_cur_onoff),a 
0fe3 3e 0f				ld a, CUR_BLINK_RATE 
0fe5 32 63 fb				ld (input_cur_flash), a 
0fe8 c3 3b 0e				jp .is1 
0feb					 
0feb			 
0feb			 
0feb					; if on a char then insert 
0feb			.onchar: 
0feb			 
0feb					; TODO over flow check: make sure insert does not blow out buffer 
0feb			 
0feb					; need to do some maths to use lddr 
0feb			 
0feb e5					push hl   ; save char pos 
0fec c5					push bc 
0fed			 
0fed 2a 6a fb				ld hl, (input_start) 
0ff0 3a 5d fb				ld a, (input_len) 
0ff3 cd dd 0d				call addatohl  		; end of string 
0ff6 23					inc hl 
0ff7 23					inc hl		; past zero term 
0ff8 e5					push hl 
0ff9 23					inc hl 
0ffa e5					push hl  
0ffb			 
0ffb								; start and end of lddr set, now how much to move? 
0ffb			 
0ffb							 
0ffb 3a 58 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ffe 47					ld b,a 
0fff 3a 5d fb				ld a,(input_len) 
1002 5f					ld e,a 
1003 90					sub b 
1004 3c					inc a		;?? 
1005 3c					inc a		;?? 
1006 3c					inc a		;?? 
1007			 
1007 06 00				ld b,0 
1009 4f					ld c,a 
100a			 
100a				if DEBUG_INPUT 
100a					push af 
100a					ld a, 'i' 
100a					ld (debug_mark),a 
100a					pop af 
100a			;		CALLMONITOR 
100a				endif 
100a d1					pop de 
100b e1					pop hl 
100c				if DEBUG_INPUT 
100c					push af 
100c					ld a, 'I' 
100c					ld (debug_mark),a 
100c					pop af 
100c			;		CALLMONITOR 
100c				endif 
100c ed b8				lddr 
100e				 
100e			 
100e			 
100e					; TODO have a key for insert/overwrite mode???? 
100e c1					pop bc 
100f e1					pop hl 
1010 71					ld (hl), c		; otherwise overwrite current char 
1011					 
1011			 
1011			 
1011			 
1011 3a 58 fb				ld a, (input_cursor) 
1014 3c					inc  a 		; TODO check overflow 
1015 32 58 fb				ld (input_cursor), a 
1018			 
1018 3a 65 fb				ld a, (input_at_cursor) 
101b 3c					inc a 
101c 32 65 fb				ld (input_at_cursor), a 
101f			 
101f c3 3b 0e				jp .is1 
1022			 
1022			.endinput:	; TODO look for end of string 
1022			 
1022					; add trailing space for end of token 
1022			 
1022 2a 6a fb				ld hl, (input_start) 
1025 3a 5d fb				ld a,(input_len) 
1028 cd dd 0d				call addatohl 
102b 3e 20				ld a, ' ' 
102d 77					ld (hl),a 
102e					; TODO eof of parse marker 
102e			 
102e 23					inc hl 
102f 3e 00				ld a, 0 
1031 77					ld (hl),a 
1032			 
1032			 
1032 c9					ret 
1033			 
1033 .. 00		.iblank: db " ",0 
1035			 
1035			 
1035 32 67 fb		input_str_prev:	ld (input_at_pos), a 
1038 22 6a fb				ld (input_start), hl 
103b 3e 01				ld a,1			; add cursor 
103d 77					ld (hl),a 
103e 23					inc hl 
103f 3e 00				ld a,0 
1041 77					ld (hl),a 
1042 22 6c fb				ld (input_ptr), hl 
1045 7a					ld a,d 
1046 32 69 fb				ld (input_size), a 
1049 3e 00				ld a,0 
104b 32 58 fb				ld (input_cursor),a 
104e			.instr1:	 
104e			 
104e					; TODO do block cursor 
104e					; TODO switch cursor depending on the modifer key 
104e			 
104e					; update cursor shape change on key hold 
104e			 
104e 2a 6c fb				ld hl, (input_ptr) 
1051 2b					dec hl 
1052 3a c7 f8				ld a,(cursor_shape) 
1055 77					ld (hl), a 
1056			 
1056					; display entered text 
1056 3a 67 fb				ld a,(input_at_pos) 
1059 cd ee 68		            	CALL fLCD_Pos       ;Position cursor to location in A 
105c ed 5b 6a fb	            	LD   de, (input_start) 
1060 cd 10 69		            	CALL fLCD_Str       ;Display string pointed to by DE 
1063			 
1063 cd 2a 6b				call cin 
1066 fe 00				cp 0 
1068 28 e4				jr z, .instr1 
106a			 
106a					; proecess keyboard controls first 
106a			 
106a 2a 6c fb				ld hl,(input_ptr) 
106d			 
106d fe 0d				cp KEY_CR	 ; pressing enter ends input 
106f 28 5a				jr z, .instrcr 
1071			 
1071 fe 08				cp KEY_BS 	; back space 
1073 20 0f				jr nz, .instr2 
1075					; process back space 
1075			 
1075					; TODO stop back space if at start of string 
1075 2b					dec hl 
1076 2b					dec hl ; to over write cursor 
1077 3a c7 f8				ld a,(cursor_shape) 
107a					;ld a,0 
107a 77					ld (hl),a 
107b 23					inc hl 
107c 3e 20				ld a," " 
107e 77					ld (hl),a 
107f 22 6c fb				ld (input_ptr),hl 
1082					 
1082			 
1082 18 ca				jr .instr1 
1084			 
1084 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1086 20 06				jr nz, .instr3 
1088 2b					dec hl 
1089 22 6c fb				ld (input_ptr),hl 
108c 18 c0				jr .instr1 
108e				 
108e fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1090 20 06				jr nz, .instr4 
1092 23					inc hl 
1093 22 6c fb				ld (input_ptr),hl 
1096 18 b6				jr .instr1 
1098			 
1098 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
109a 20 06				jr nz, .instr5 
109c 2b					dec hl 
109d 22 6c fb				ld (input_ptr),hl 
10a0 18 ac				jr .instr1 
10a2			 
10a2 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10a4 20 06				jr nz, .instr6 
10a6 2b					dec hl 
10a7 22 6c fb				ld (input_ptr),hl 
10aa 18 a2				jr .instr1 
10ac fe 05		.instr6:        cp KEY_UP      ; recall last command 
10ae 20 0b				jr nz, .instrnew 
10b0			 
10b0 21 14 ee			ld hl, scratch 
10b3 11 3a f2			ld de, os_last_cmd 
10b6 cd d4 10			call strcpy 
10b9 18 93				jr .instr1 
10bb			 
10bb			 
10bb			.instrnew:	; no special key pressed to see if we have room to store it 
10bb			 
10bb					; TODO do string size test 
10bb			 
10bb 2b					dec hl ; to over write cursor 
10bc 77					ld (hl),a 
10bd 23					inc hl 
10be 3a c7 f8				ld a,(cursor_shape) 
10c1 77					ld (hl),a 
10c2 23					inc hl 
10c3 3e 00				ld a,0 
10c5 77					ld (hl),a 
10c6			 
10c6 22 6c fb				ld (input_ptr),hl 
10c9					 
10c9 18 83				jr .instr1 
10cb 2b			.instrcr:	dec hl		; remove cursor 
10cc 3e 20				ld a,' '	; TODO add a trailing space for safety 
10ce 77					ld (hl),a 
10cf 23					inc hl 
10d0 3e 00				ld a,0 
10d2 77					ld (hl),a 
10d3			 
10d3			 
10d3					; if at end of line scroll up    
10d3					; TODO detecting only end of line 4 for scroll up  
10d3			 
10d3					;ld   
10d3			 
10d3 c9					ret 
10d4			 
10d4			 
10d4			; strcpy hl = dest, de source 
10d4			 
10d4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10d5 b7			            OR   A              ;Null terminator? 
10d6 c8			            RET  Z              ;Yes, so finished 
10d7 1a					ld a,(de) 
10d8 77					ld (hl),a 
10d9 13			            INC  DE             ;Point to next character 
10da 23					inc hl 
10db 18 f7		            JR   strcpy       ;Repeat 
10dd c9					ret 
10de			 
10de			 
10de			; TODO string_at  
10de			; pass string which starts with lcd offset address and then null term string 
10de			 
10de			; TODO string to dec 
10de			; TODO string to hex 
10de			; TODO byte to string hex 
10de			; TODO byte to string dec 
10de			 
10de			 
10de			 
10de			; from z80uartmonitor 
10de			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10de			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10de			; pass hl for where to put the text 
10de			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10de c5			hexout:	PUSH BC 
10df f5					PUSH AF 
10e0 47					LD B, A 
10e1					; Upper nybble 
10e1 cb 3f				SRL A 
10e3 cb 3f				SRL A 
10e5 cb 3f				SRL A 
10e7 cb 3f				SRL A 
10e9 cd f9 10				CALL tohex 
10ec 77					ld (hl),a 
10ed 23					inc hl	 
10ee					 
10ee					; Lower nybble 
10ee 78					LD A, B 
10ef e6 0f				AND 0FH 
10f1 cd f9 10				CALL tohex 
10f4 77					ld (hl),a 
10f5 23					inc hl	 
10f6					 
10f6 f1					POP AF 
10f7 c1					POP BC 
10f8 c9					RET 
10f9					 
10f9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f9			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
10f9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10f9			tohex: 
10f9 e5					PUSH HL 
10fa d5					PUSH DE 
10fb 16 00				LD D, 0 
10fd 5f					LD E, A 
10fe 21 06 11				LD HL, .DATA 
1101 19					ADD HL, DE 
1102 7e					LD A, (HL) 
1103 d1					POP DE 
1104 e1					POP HL 
1105 c9					RET 
1106			 
1106			.DATA: 
1106 30					DEFB	30h	; 0 
1107 31					DEFB	31h	; 1 
1108 32					DEFB	32h	; 2 
1109 33					DEFB	33h	; 3 
110a 34					DEFB	34h	; 4 
110b 35					DEFB	35h	; 5 
110c 36					DEFB	36h	; 6 
110d 37					DEFB	37h	; 7 
110e 38					DEFB	38h	; 8 
110f 39					DEFB	39h	; 9 
1110 41					DEFB	41h	; A 
1111 42					DEFB	42h	; B 
1112 43					DEFB	43h	; C 
1113 44					DEFB	44h	; D 
1114 45					DEFB	45h	; E 
1115 46					DEFB	46h	; F 
1116			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1116			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1116			;;    subtract $30, if result > 9 then subtract $7 more 
1116			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1116			atohex: 
1116 d6 30				SUB $30 
1118 fe 0a				CP 10 
111a f8					RET M		; If result negative it was 0-9 so we're done 
111b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
111d c9					RET		 
111e			 
111e			 
111e			 
111e			 
111e			; Get 2 ASCII characters as hex byte from pointer in hl 
111e			 
111e			BYTERD: 
111e 16 00			LD	D,00h		;Set up 
1120 cd 28 11			CALL	HEXCON		;Get byte and convert to hex 
1123 87				ADD	A,A		;First nibble so 
1124 87				ADD	A,A		;multiply by 16 
1125 87				ADD	A,A		; 
1126 87				ADD	A,A		; 
1127 57				LD	D,A		;Save hi nibble in D 
1128			HEXCON: 
1128 7e				ld a, (hl)		;Get next chr 
1129 23				inc hl 
112a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
112c fe 0a			CP	00Ah		;Is it 0-9 ? 
112e 38 02			JR	C,NALPHA	;If so miss next bit 
1130 d6 07			SUB	007h		;Else convert alpha 
1132			NALPHA: 
1132 b2				OR	D		;Add hi nibble back 
1133 c9				RET			; 
1134			 
1134			 
1134			; 
1134			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1134			; Since the routines get_byte and therefore get_nibble are called, only valid 
1134			; characters (0-9a-f) are accepted. 
1134			; 
1134			;get_word        push    af 
1134			;                call    get_byte        ; Get the upper byte 
1134			;                ld      h, a 
1134			;                call    get_byte        ; Get the lower byte 
1134			;                ld      l, a 
1134			;                pop     af 
1134			;                ret 
1134			; 
1134			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1134			; the routine get_nibble is used only valid characters are accepted - the  
1134			; input routine only accepts characters 0-9a-f. 
1134			; 
1134 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1135 7e					ld a,(hl) 
1136 23					inc hl 
1137 cd 5c 11		                call    nibble2val      ; Get upper nibble 
113a cb 07		                rlc     a 
113c cb 07		                rlc     a 
113e cb 07		                rlc     a 
1140 cb 07		                rlc     a 
1142 47			                ld      b, a            ; Save upper four bits 
1143 7e					ld a,(hl) 
1144 cd 5c 11		                call    nibble2val      ; Get lower nibble 
1147 b0			                or      b               ; Combine both nibbles 
1148 c1			                pop     bc              ; Restore B (and C) 
1149 c9			                ret 
114a			; 
114a			; Get a hexadecimal digit from the serial line. This routine blocks until 
114a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
114a			; to the serial line interface. The lower 4 bits of A contain the value of  
114a			; that particular digit. 
114a			; 
114a			;get_nibble      ld a,(hl)           ; Read a character 
114a			;                call    to_upper        ; Convert to upper case 
114a			;                call    is_hex          ; Was it a hex digit? 
114a			;                jr      nc, get_nibble  ; No, get another character 
114a			 ;               call    nibble2val      ; Convert nibble to value 
114a			 ;               call    print_nibble 
114a			 ;               ret 
114a			; 
114a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
114a			; A valid hexadecimal digit is denoted by a set C flag. 
114a			; 
114a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
114a			;                ret     nc              ; Yes 
114a			;                cp      '0'             ; Less than '0'? 
114a			;                jr      nc, is_hex_1    ; No, continue 
114a			;                ccf                     ; Complement carry (i.e. clear it) 
114a			;                ret 
114a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
114a			;                ret     c               ; Yes 
114a			;                cp      'A'             ; Less than 'A'? 
114a			;                jr      nc, is_hex_2    ; No, continue 
114a			;                ccf                     ; Yes - clear carry and return 
114a			;                ret 
114a			;is_hex_2        scf                     ; Set carry 
114a			;                ret 
114a			; 
114a			; Convert a single character contained in A to upper case: 
114a			; 
114a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
114c d8			                ret     c 
114d fe 7b		                cp      'z' + 1         ; > 'z'? 
114f d0			                ret     nc              ; Nothing to do, either 
1150 e6 5f		                and     $5f             ; Convert to upper case 
1152 c9			                ret 
1153			 
1153			 
1153			to_lower: 
1153			 
1153			   ; if char is in [A-Z] make it lower case 
1153			 
1153			   ; enter : a = char 
1153			   ; exit  : a = lower case char 
1153			   ; uses  : af 
1153			 
1153 fe 41		   cp 'A' 
1155 d8			   ret c 
1156			    
1156 fe 5b		   cp 'Z'+1 
1158 d0			   ret nc 
1159			    
1159 f6 20		   or $20 
115b c9			   ret 
115c			 
115c			; 
115c			; Expects a hexadecimal digit (upper case!) in A and returns the 
115c			; corresponding value in A. 
115c			; 
115c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
115e 38 02		                jr      c, nibble2val_1 ; Yes 
1160 d6 07		                sub     7               ; Adjust for A-F 
1162 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1164 e6 0f		                and     $f              ; Only return lower 4 bits 
1166 c9			                ret 
1167			; 
1167			; Print_nibble prints a single hex nibble which is contained in the lower  
1167			; four bits of A: 
1167			; 
1167			;print_nibble    push    af              ; We won't destroy the contents of A 
1167			;                and     $f              ; Just in case... 
1167			;                add     a, '0'             ; If we have a digit we are done here. 
1167			;                cp      '9' + 1         ; Is the result > 9? 
1167			;                jr      c, print_nibble_1 
1167			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1167			;print_nibble_1  call    putc            ; Print the nibble and 
1167			;                pop     af              ; restore the original value of A 
1167			;                ret 
1167			;; 
1167			;; Send a CR/LF pair: 
1167			; 
1167			;crlf            push    af 
1167			;                ld      a, cr 
1167			;                call    putc 
1167			;                ld      a, lf 
1167			;                call    putc 
1167			;                pop     af 
1167			;                ret 
1167			; 
1167			; Print_word prints the four hex digits of a word to the serial line. The  
1167			; word is expected to be in HL. 
1167			; 
1167			;print_word      push    hl 
1167			;                push    af 
1167			;                ld      a, h 
1167			;                call    print_byte 
1167			;                ld      a, l 
1167			;                call    print_byte 
1167			;                pop     af 
1167			;                pop     hl 
1167			;                ret 
1167			; 
1167			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1167			; The byte to be printed is expected to be in A. 
1167			; 
1167			;print_byte      push    af              ; Save the contents of the registers 
1167			;                push    bc 
1167			;                ld      b, a 
1167			;                rrca 
1167			;                rrca 
1167			;                rrca 
1167			;                rrca 
1167			;                call    print_nibble    ; Print high nibble 
1167			;                ld      a, b 
1167			;                call    print_nibble    ; Print low nibble 
1167			;                pop     bc              ; Restore original register contents 
1167			;                pop     af 
1167			;                ret 
1167			 
1167			 
1167			 
1167			 
1167			 
1167			fourehexhl:  
1167 7e				ld a,(hl) 
1168 cd 16 11			call atohex 
116b cb 3f				SRL A 
116d cb 3f				SRL A 
116f cb 3f				SRL A 
1171 cb 3f				SRL A 
1173 47				ld b, a 
1174 23				inc hl 
1175 7e				ld a,(hl) 
1176 23				inc hl 
1177 cd 16 11			call atohex 
117a 80				add b 
117b 57				ld d,a 
117c 7e				ld a,(hl) 
117d cd 16 11			call atohex 
1180 cb 3f				SRL A 
1182 cb 3f				SRL A 
1184 cb 3f				SRL A 
1186 cb 3f				SRL A 
1188 47				ld b, a 
1189 23				inc hl 
118a 7e				ld a,(hl) 
118b 23				inc hl 
118c cd 16 11			call atohex 
118f 80				add b 
1190 5f				ld e, a 
1191 d5				push de 
1192 e1				pop hl 
1193 c9				ret 
1194			 
1194			; pass hl. returns z set if the byte at hl is a digit 
1194			;isdigithl:  
1194			;	push bc 
1194			;	ld a,(hl) 
1194			;	cp ':' 
1194			;	jr nc, .isdf 		; > 
1194			;	cp '0' 
1194			;	jr c, .isdf		; < 
1194			; 
1194			;	; TODO find a better way to set z 
1194			; 
1194			;	ld b,a 
1194			;	cp b 
1194			;	pop bc 
1194			;	ret 
1194			; 
1194			;.isdf:	; not digit so clear z 
1194			; 
1194			;	; TODO find a better way to unset z 
1194			; 
1194			;	ld b,a 
1194			;	inc b 
1194			;	cp b 
1194			; 
1194			;	pop bc 
1194			;	ret 
1194				 
1194				 
1194			 
1194			 
1194			; pass hl as the four byte address to load 
1194			 
1194			get_word_hl:  
1194 e5				push hl 
1195 cd 34 11			call get_byte 
1198				 
1198 47				ld b, a 
1199			 
1199 e1				pop hl 
119a 23				inc hl 
119b 23				inc hl 
119c			 
119c			; TODO not able to handle a-f  
119c 7e				ld a,(hl) 
119d			;	;cp ':' 
119d			;	cp 'g' 
119d			;	jr nc, .single_byte_hl 		; > 
119d			;	cp 'G' 
119d			;	jr nc, .single_byte_hl 		; > 
119d			;	cp '0' 
119d			;	jr c, .single_byte_hl		; < 
119d			 
119d				;call isdigithl 
119d fe 00			cp 0 
119f 28 06			jr z, .single_byte_hl 
11a1			 
11a1			.getwhln:   ; hex word so get next byte 
11a1			 
11a1 cd 34 11			call get_byte 
11a4 6f				ld l, a 
11a5 60				ld h,b 
11a6 c9				ret 
11a7 68			.single_byte_hl:   ld l,b 
11a8 26 00				ld h,0 
11aa c9					ret 
11ab			 
11ab			 
11ab			 
11ab			 
11ab 21 f8 1a			ld hl,asc+1 
11ae			;	ld a, (hl) 
11ae			;	call nibble2val 
11ae cd 34 11			call get_byte 
11b1			 
11b1			;	call fourehexhl 
11b1 32 48 ee			ld (scratch+52),a 
11b4				 
11b4 21 46 ee			ld hl,scratch+50 
11b7 22 37 f1			ld (os_cur_ptr),hl 
11ba			 
11ba c9				ret 
11bb			 
11bb			 
11bb			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11bb			 
11bb			; Decimal Unsigned Version 
11bb			 
11bb			;Number in a to decimal ASCII 
11bb			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11bb			;Example: display a=56 as "056" 
11bb			;input: a = number 
11bb			;Output: a=0,value of a in the screen 
11bb			;destroys af,bc (don't know about hl and de) 
11bb			DispAToASCII: 
11bb 0e 9c			ld	c,-100 
11bd cd c7 11			call	.Na1 
11c0 0e f6			ld	c,-10 
11c2 cd c7 11			call	.Na1 
11c5 0e ff			ld	c,-1 
11c7 06 2f		.Na1:	ld	b,'0'-1 
11c9 04			.Na2:	inc	b 
11ca 81				add	a,c 
11cb 38 fc			jr	c,.Na2 
11cd 91				sub	c		;works as add 100/10/1 
11ce f5				push af		;safer than ld c,a 
11cf 78				ld	a,b		;char is in b 
11d0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11d0 f1				pop af		;safer than ld a,c 
11d1 c9				ret 
11d2			 
11d2			; Decimal Signed Version 
11d2			 
11d2			; DispA 
11d2			; -------------------------------------------------------------- 
11d2			; Converts a signed integer value to a zero-terminated ASCII 
11d2			; string representative of that value (using radix 10). 
11d2			; -------------------------------------------------------------- 
11d2			; INPUTS: 
11d2			;     HL     Value to convert (two's complement integer). 
11d2			;     DE     Base address of string destination. (pointer). 
11d2			; -------------------------------------------------------------- 
11d2			; OUTPUTS: 
11d2			;     None 
11d2			; -------------------------------------------------------------- 
11d2			; REGISTERS/MEMORY DESTROYED 
11d2			; AF HL 
11d2			; -------------------------------------------------------------- 
11d2			 
11d2			;DispHLToASCII: 
11d2			;   push    de 
11d2			;   push    bc 
11d2			; 
11d2			;; Detect sign of HL. 
11d2			;    bit    7, h 
11d2			;    jr     z, ._DoConvert 
11d2			; 
11d2			;; HL is negative. Output '-' to string and negate HL. 
11d2			;    ld     a, '-' 
11d2			;    ld     (de), a 
11d2			;    inc    de 
11d2			; 
11d2			;; Negate HL (using two's complement) 
11d2			;    xor    a 
11d2			;    sub    l 
11d2			;    ld     l, a 
11d2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11d2			;    sbc    a, h 
11d2			;    ld     h, a 
11d2			; 
11d2			;; Convert HL to digit characters 
11d2			;._DoConvert: 
11d2			;    ld     b, 0     ; B will count character length of number 
11d2			;-   ld     a, 10 
11d2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11d2			;    push   af 
11d2			;    inc    b 
11d2			;    ld     a, h 
11d2			;    or     l 
11d2			;    jr     nz, - 
11d2			; 
11d2			;; Retrieve digits from stack 
11d2			;-   pop    af 
11d2			;    or     $30 
11d2			;    ld     (de), a 
11d2			;    inc    de 
11d2			;    djnz   - 
11d2			; 
11d2			;; Terminate string with NULL 
11d2			;    xor    a 
11d2			;    ld     (de), a 
11d2			; 
11d2			;    pop    bc 
11d2			;    pop    de 
11d2			;    ret 
11d2			 
11d2			;Comments 
11d2			; 
11d2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11d2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11d2			;    Note that the output string will not be fixed-width. 
11d2			; 
11d2			;Example Usage 
11d2			; 
11d2			;    ld    hl, -1004 
11d2			;    ld    de, OP1 
11d2			;    call  DispA 
11d2			;    ld    hl, OP1 
11d2			;    syscall  PutS 
11d2			 
11d2			 
11d2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11d2			 
11d2			 
11d2			;Converts an ASCII string to an unsigned 16-bit integer 
11d2			;Quits when it reaches a non-decimal digit 
11d2			 
11d2			string_to_uint16: 
11d2			atoui_16: 
11d2			;Input: 
11d2			;     DE points to the string 
11d2			;Outputs: 
11d2			;     HL is the result 
11d2			;     A is the 8-bit value of the number 
11d2			;     DE points to the byte after the number 
11d2			;Destroys: 
11d2			;     BC 
11d2			;       if the string is non-empty, BC is HL/10 
11d2			;Size:  24 bytes 
11d2			;Speed: 42+d(104+{0,9}) 
11d2			;       d is the number of digits in the number 
11d2			;       max is 640 cycles for a 5 digit number 
11d2			;Assuming no leading zeros: 
11d2			;1 digit:  146cc 
11d2			;2 digit:  250cc 
11d2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11d2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11d2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11d2			;avg: 544.81158447265625cc (544+13297/16384) 
11d2			;=============================================================== 
11d2 21 00 00		  ld hl,0 
11d5			.u16a: 
11d5 1a			  ld a,(de) 
11d6 d6 30		  sub 30h 
11d8 fe 0a		  cp 10 
11da d0			  ret nc 
11db 13			  inc de 
11dc 44			  ld b,h 
11dd 4d			  ld c,l 
11de 29			  add hl,hl 
11df 29			  add hl,hl 
11e0 09			  add hl,bc 
11e1 29			  add hl,hl 
11e2 85			  add a,l 
11e3 6f			  ld l,a 
11e4 30 ef		  jr nc,.u16a 
11e6 24			  inc h 
11e7 c3 d5 11		  jp .u16a 
11ea			 
11ea			 
11ea			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11ea			 
11ea			;written by Zeda 
11ea			;Converts a 16-bit unsigned integer to an ASCII string. 
11ea			 
11ea			uitoa_16: 
11ea			;Input: 
11ea			;   DE is the number to convert 
11ea			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11ea			;Output: 
11ea			;   HL points to the null-terminated ASCII string 
11ea			;      NOTE: This isn't necessarily the same as the input HL. 
11ea d5			  push de 
11eb c5			  push bc 
11ec f5			  push af 
11ed eb			  ex de,hl 
11ee			 
11ee 01 f0 d8		  ld bc,-10000 
11f1 3e 2f		  ld a,'0'-1 
11f3 3c			  inc a 
11f4 09			  add hl,bc  
11f5 38 fc		   jr c,$-2 
11f7 12			  ld (de),a 
11f8 13			  inc de 
11f9			 
11f9 01 e8 03		  ld bc,1000 
11fc 3e 3a		  ld a,'9'+1 
11fe 3d			  dec a  
11ff 09			  add hl,bc  
1200 30 fc		   jr nc,$-2 
1202 12			  ld (de),a 
1203 13			  inc de 
1204			 
1204 01 9c ff		  ld bc,-100 
1207 3e 2f		  ld a,'0'-1 
1209 3c			  inc a  
120a 09			  add hl,bc  
120b 38 fc		   jr c,$-2 
120d 12			  ld (de),a 
120e 13			  inc de 
120f			 
120f 7d			  ld a,l 
1210 26 3a		  ld h,'9'+1 
1212 25			  dec h  
1213 c6 0a		  add a,10  
1215 30 fb		   jr nc,$-3 
1217 c6 30		  add a,'0' 
1219 eb			  ex de,hl 
121a 72			  ld (hl),d 
121b 23			  inc hl 
121c 77			  ld (hl),a 
121d 23			  inc hl 
121e 36 00		  ld (hl),0 
1220			 
1220			;Now strip the leading zeros 
1220 0e fa		  ld c,-6 
1222 09			  add hl,bc 
1223 3e 30		  ld a,'0' 
1225 23			  inc hl  
1226 be			  cp (hl)  
1227 28 fc		  jr z,$-2 
1229			 
1229			;Make sure that the string is non-empty! 
1229 7e			  ld a,(hl) 
122a b7			  or a 
122b 20 01		  jr nz,.atoub 
122d 2b			  dec hl 
122e			.atoub: 
122e			 
122e f1			  pop af 
122f c1			  pop bc 
1230 d1			  pop de 
1231 c9			  ret 
1232			 
1232			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1232			 
1232			toUpper: 
1232			;A is the char. 
1232			;If A is a lowercase letter, this sets it to the matching uppercase 
1232			;18cc or 30cc or 41cc 
1232			;avg: 26.75cc 
1232 fe 61		  cp 'a' 
1234 d8			  ret c 
1235 fe 7b		  cp 'z'+1 
1237 d0			  ret nc 
1238 d6 20		  sub 'a'-'A' 
123a c9			  ret 
123b			 
123b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
123b			 
123b			; String Length 
123b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
123b			 
123b			; Get the length of the null-terminated string starting at $8000 hl 
123b			;    LD     HL, $8000 
123b			 
123b			strlenz: 
123b			 
123b af			    XOR    A               ; Zero is the value we are looking for. 
123c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
123d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
123e			                           ; 65, 536 bytes (the entire addressable memory space). 
123e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1240			 
1240			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1240 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1241 6f			    LD     L, A             ; number of bytes 
1242 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1244 2b			    DEC    HL              ; Compensate for null. 
1245 c9				ret 
1246			 
1246			; Get the length of the A terminated string starting at $8000 hl 
1246			;    LD     HL, $8000 
1246			 
1246			strlent: 
1246			 
1246			                  ; A is the value we are looking for. 
1246 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1248 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
124a			                           ; 65, 536 bytes (the entire addressable memory space). 
124a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124c			 
124c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
124e 2e 00		    LD     L, 0             ; number of bytes 
1250 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1252 2b			    DEC    HL              ; Compensate for null. 
1253 c9				ret 
1254			 
1254			 
1254			;Comparing Strings 
1254			 
1254			;IN    HL     Address of string1. 
1254			;      DE     Address of string2. 
1254			 
1254			; doc given but wrong??? 
1254			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1254			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1254			; tested 
1254			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1254			 
1254			strcmp_old: 
1254 e5			    PUSH   HL 
1255 d5			    PUSH   DE 
1256			 
1256 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1257 be			    CP     (HL)            ; (want to minimize work). 
1258 38 01		    JR     C, Str1IsBigger 
125a 7e			    LD     A, (HL) 
125b			 
125b			Str1IsBigger: 
125b 4f			    LD     C, A             ; Put length in BC 
125c 06 00		    LD     B, 0 
125e 13			    INC    DE              ; Increment pointers to meat of string. 
125f 23			    INC    HL 
1260			 
1260			CmpLoop: 
1260 1a			    LD     A, (DE)          ; Compare bytes. 
1261 ed a1		    CPI 
1263 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1265 13			    INC    DE              ; Update pointer. 
1266 ea 60 12		    JP     PE, CmpLoop 
1269			 
1269 d1			    POP    DE 
126a e1			    POP    HL 
126b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
126c be			    CP     (HL) 
126d c9			    RET 
126e			 
126e			NoMatch: 
126e 2b			    DEC    HL 
126f be			    CP     (HL)            ; Compare again to affect carry. 
1270 d1			    POP    DE 
1271 e1			    POP    HL 
1272 c9			    RET 
1273			 
1273			;; test strmp 
1273			; 
1273			;ld de, .str1 
1273			;ld hl, .str2 
1273			;call strcmp 
1273			;jr z, .z1 
1273			;;this 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "NZ1" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			;.z1: 
1273			; 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "ZZ1" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			; 
1273			;ld de, .str1 
1273			;ld hl, .str1 
1273			;call strcmp 
1273			;jr z, .z2 
1273			;;this 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "NZ2" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			;.z2: 
1273			; 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "ZZ2" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			; 
1273			;ld de, .str1 
1273			;ld hl, .str2 
1273			;call strcmp 
1273			;jr c, .c1 
1273			; 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "Nc1" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			;.c1: 
1273			;;this 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "cc1" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			; 
1273			;ld de, .str1 
1273			;ld hl, .str1 
1273			;call strcmp 
1273			;jr c, .c2 
1273			;;this 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "Nc2" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			;.c2: 
1273			; 
1273			;	if DEBUG_FORTH_WORDS 
1273			;		DMARK "cc2" 
1273			;		CALLMONITOR 
1273			;	endif 
1273			;	NEXTW 
1273			;.str1:   db "string1",0 
1273			;.str2:   db "string2",0 
1273			 
1273			; only care about direct match or not 
1273			; hl and de strings 
1273			; zero set if the same 
1273			 
1273			strcmp: 
1273 1a				ld a, (de) 
1274 be				cp (hl) 
1275 28 02			jr z, .ssame 
1277 b7				or a 
1278 c9				ret 
1279			 
1279			.ssame:  
1279 fe 00			cp 0 
127b c8				ret z 
127c			 
127c 23				inc hl 
127d 13				inc de 
127e 18 f3			jr strcmp 
1280				 
1280				 
1280			 
1280			 
1280			 
1280			 
1280			; eof 
1280			 
1280			 
1280			 
1280			 
1280			 
1280			 
# End of file firmware_strings.asm
1280			include "firmware_memory.asm"   ; malloc and free  
1280			 
1280			if DEBUG_FORTH_MALLOC_HIGH 
1280			.mallocsize: db "Wants malloc >256",0 
1280			.mallocasize: db "MALLOC gives >256",0 
1280			.malloczero: db "MALLOC gives zero",0 
1280			 
1280			malloc_guard_zerolen: 
1280				push hl 
1280				push de 
1280				push af 
1280			 
1280				ld de, 0 
1280			        call cmp16 
1280				jr nz, .lowalloz 
1280			 
1280				push hl 
1280				push de 
1280					ld hl, display_fb0 
1280					ld (display_fb_active), hl 
1280				call clear_display 
1280				ld a, 0 
1280				ld de, .malloczero 
1280				call str_at_display 
1280				call update_display 
1280				call delay1s 
1280				call delay1s 
1280				ld a, 0 
1280				ld (os_view_disable), a 
1280			 
1280				pop de 
1280				pop hl 
1280			 
1280				 
1280			 
1280				CALLMONITOR 
1280			.lowalloz: 
1280			 
1280			 
1280				pop af 
1280				pop de 
1280				pop hl 
1280			ret 
1280			 
1280			malloc_guard_entry: 
1280				push hl 
1280				push de 
1280				push af 
1280			 
1280			 	or a      ;clear carry flag 
1280				push hl 
1280				ld de, 255 
1280				sbc hl, de 
1280				jr c, .lowalloc 
1280			 
1280				push de 
1280					ld hl, display_fb0 
1280					ld (display_fb_active), hl 
1280				call clear_display 
1280				ld a, 0 
1280				ld de, .mallocsize 
1280				call str_at_display 
1280				call update_display 
1280				call delay1s 
1280				call delay1s 
1280				ld a, 0 
1280				ld (os_view_disable), a 
1280			 
1280				pop de 
1280				pop hl 
1280			 
1280				 
1280			 
1280				CALLMONITOR 
1280				jr .lowdone 
1280			.lowalloc: 
1280			 
1280			 
1280				pop hl 
1280			.lowdone:	pop af 
1280				pop de 
1280				pop hl 
1280			ret 
1280			 
1280			malloc_guard_exit: 
1280				push hl 
1280				push de 
1280				push af 
1280			 
1280			 	or a      ;clear carry flag 
1280				push hl 
1280				ld de, 255 
1280				sbc hl, de 
1280				jr c, .lowallocx 
1280			 
1280				push de 
1280					ld hl, display_fb0 
1280					ld (display_fb_active), hl 
1280				call clear_display 
1280				ld a, 0 
1280				ld de, .mallocasize 
1280				call str_at_display 
1280				call update_display 
1280				call delay1s 
1280				call delay1s 
1280				ld a, 0 
1280				ld (os_view_disable), a 
1280				pop de 
1280				pop hl 
1280			 
1280				CALLMONITOR 
1280				jr .lowdonex 
1280			.lowallocx: 
1280			 
1280				pop hl 
1280			.lowdonex:	pop af 
1280				pop de 
1280				pop hl 
1280			ret 
1280			endif 
1280			 
1280			if MALLOC_2 
1280			; Z80 Malloc and Free Functions 
1280			 
1280			; Malloc Function: 
1280			; Input: 
1280			;   HL: Size of block to allocate 
1280			; Output: 
1280			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1280			 
1280			malloc: 
1280				 
1280			if DEBUG_FORTH_MALLOC_HIGH 
1280			call malloc_guard_entry 
1280			endif 
1280			 
1280			 
1280			 
1280			 
1280					if DEBUG_FORTH_MALLOC 
1280						DMARK "mal" 
1280						CALLMONITOR 
1280					endif 
1280			    push af            ; Save AF register 
1280			    ld a, l            ; Load low byte of size into A 
1280			    or h               ; Check if size is zero 
1280			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1280			 
1280			    ; Allocate memory 
1280			    ld hl, (heap_start) ; Load start of heap into HL 
1280					if DEBUG_FORTH_MALLOC 
1280						DMARK "ma1" 
1280						CALLMONITOR 
1280					endif 
1280			    call malloc_internal ; Call internal malloc function 
1280			    pop af             ; Restore AF register 
1280			if DEBUG_FORTH_MALLOC_HIGH 
1280			call malloc_guard_exit 
1280			call malloc_guard_zerolen 
1280			endif 
1280			    ret                ; Return 
1280			 
1280			; Free Function: 
1280			; Input: 
1280			;   HL: Pointer to memory block to free 
1280			; Output: 
1280			;   None 
1280			 
1280			free: 
1280			    push af            ; Save AF register 
1280			    ld a, l            ; Load low byte of pointer into A 
1280			    or h               ; Check if pointer is NULL 
1280			    jp z, free_exit    ; If pointer is NULL, exit 
1280			 
1280			    ; Free memory 
1280			    ld hl, (heap_start) ; Load start of heap into HL 
1280			    call free_internal  ; Call internal free function 
1280			    pop af             ; Restore AF register 
1280			    ret                ; Return 
1280			 
1280			; Internal Malloc Function: 
1280			; Input: 
1280			;   HL: Size of block to allocate 
1280			; Output: 
1280			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1280			 
1280			malloc_internal: 
1280			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1280			    add hl, bc         ; Add management overhead to requested size 
1280			    ex de, hl          ; Save total size in DE, and keep it in HL 
1280					if DEBUG_FORTH_MALLOC 
1280						DMARK "ma2" 
1280						CALLMONITOR 
1280					endif 
1280			 
1280			    ; Search for free memory block 
1280			    ld de, (heap_end)  ; Load end of heap into DE 
1280			    ld bc, 0           ; Initialize counter 
1280			 
1280					if DEBUG_FORTH_MALLOC 
1280						DMARK "ma2" 
1280						CALLMONITOR 
1280					endif 
1280			malloc_search_loop: 
1280			    ; Check if current block is free 
1280			    ld a, (hl)         ; Load current block's status (free or used) 
1280			    cp 0               ; Compare with zero (free) 
1280			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1280			 
1280			    ; Check if current block is large enough 
1280			    ld a, (hl+1)       ; Load high byte of block size 
1280			    cp l               ; Compare with low byte of requested size 
1280			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1280			 
1280			    ld a, (hl+2)       ; Load low byte of block size 
1280			    cp h               ; Compare with high byte of requested size 
1280			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1280			 
1280			    ; Mark block as used 
1280			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1280			 
1280			    ; Calculate remaining space in block 
1280			    ld bc, 0           ; Clear BC 
1280			    add hl, bc         ; Increment HL to point to start of data block 
1280			    add hl, de         ; HL = HL + DE (total size) 
1280			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1280			    add hl, bc         ; Add management overhead to start of data block 
1280			 
1280			    ; Save pointer to allocated block in HL 
1280			if DEBUG_FORTH_MALLOC_HIGH 
1280						DMARK "ma5" 
1280			call malloc_guard_exit 
1280			call malloc_guard_zerolen 
1280			endif 
1280			    ret 
1280			 
1280			malloc_skip_block_check: 
1280			    ; Move to the next block 
1280			    ld bc, 3           ; Size of management overhead 
1280			    add hl, bc         ; Move to the next block 
1280			    inc de             ; Increment counter 
1280			 
1280			    ; Check if we have reached the end of heap 
1280			    ld a, e            ; Load low byte of heap end address 
1280			    cp (hl)            ; Compare with low byte of current address 
1280			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1280			    ld a, d            ; Load high byte of heap end address 
1280			    cp 0               ; Check if it's zero (end of memory) 
1280			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1280			 
1280			    ; If we reached here, allocation failed 
1280			    xor a              ; Set result to NULL 
1280			if DEBUG_FORTH_MALLOC_HIGH 
1280						DMARK "ma6" 
1280			call malloc_guard_exit 
1280			call malloc_guard_zerolen 
1280			endif 
1280			    ret 
1280			malloc_exit: 
1280			if DEBUG_FORTH_MALLOC_HIGH 
1280						DMARK "ma7" 
1280			call malloc_guard_exit 
1280			call malloc_guard_zerolen 
1280			endif 
1280			    ret 
1280			 
1280			; Internal Free Function: 
1280			; Input: 
1280			;   HL: Pointer to memory block to free 
1280			; Output: 
1280			;   None 
1280			 
1280			free_internal: 
1280			    ld de, (heap_start) ; Load start of heap into DE 
1280			    ld bc, 0            ; Initialize counter 
1280			 
1280			free_search_loop: 
1280			    ; Check if current block contains the pointer 
1280			    ld a, l             ; Load low byte of pointer 
1280			    cp (hl+1)           ; Compare with high byte of current block's address 
1280			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1280			    ld a, h             ; Load high byte of pointer 
1280			    cp (hl+2)           ; Compare with low byte of current block's address 
1280			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1280			 
1280			    ; Mark block as free 
1280			    ld (hl), 0          ; Set status byte to indicate free block 
1280			    ret                 ; Return 
1280			 
1280			free_skip_block_check: 
1280			    ; Move to the next block 
1280			    ld bc, 3            ; Size of management overhead 
1280			    add hl, bc          ; Move to the next block 
1280			    inc de              ; Increment counter 
1280			 
1280			    ; Check if we have reached the end of heap 
1280			    ld a, e             ; Load low byte of heap end address 
1280			    cp (hl)             ; Compare with low byte of current address 
1280			    jr nz, free_search_loop  ; If not equal, continue searching 
1280			    ld a, d             ; Load high byte of heap end address 
1280			    cp 0                ; Check if it's zero (end of memory) 
1280			    jr nz, free_search_loop  ; If not zero, continue searching 
1280			 
1280			    ; If we reached here, pointer is not found in heap 
1280			    ret 
1280			 
1280			free_exit: 
1280			    ret                 ; Return 
1280			 
1280			; Define heap start and end addresses 
1280			;heap_start:    .dw 0xC000   ; Start of heap 
1280			;heap_end:      .dw 0xE000   ; End of heap 
1280			 
1280			endif 
1280			 
1280			 
1280			if MALLOC_1 
1280			 
1280			 
1280			 
1280			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1280			 
1280			;moved to firmware.asm 
1280			;heap_start        .equ  0x9000      ; Starting address of heap 
1280			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1280			 
1280			;      .org 0 
1280			;      jp    main 
1280			 
1280			 
1280			;      .org  0x100 
1280			;main: 
1280			;      ld    HL, 0x8100 
1280			;      ld    SP, HL 
1280			; 
1280			;      call  heap_init 
1280			; 
1280			;      ; Make some allocations 
1280			;      ld    HL, 12 
1280			;      call  malloc            ; Allocates 0x9004 
1280			; 
1280			;      ld    HL, 12 
1280			;      call  malloc            ; Allocates 0x9014 
1280			; 
1280			;      ld    HL, 12 
1280			;      call  malloc            ; Allocates 0x9024 
1280			; 
1280			;      ; Free some allocations 
1280			;      ld    HL, 0x9014 
1280			;      call  free 
1280			; 
1280			;      ld    HL, 0x9004 
1280			;      call  free 
1280			; 
1280			;      ld    HL, 0x9024 
1280			;      call  free 
1280			; 
1280			; 
1280			;      halt 
1280			 
1280			 
1280			;------------------------------------------------------------------------------ 
1280			;     heap_init                                                               : 
1280			;                                                                             : 
1280			; Description                                                                 : 
1280			;     Initialise the heap and make it ready for malloc and free operations.   : 
1280			;                                                                             : 
1280			;     The heap is maintained as a linked list, starting with an initial       : 
1280			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1280			;     the first free block in the heap. Each block then points to the next    : 
1280			;     free block within the heap, and the free list ends at the first block   : 
1280			;     with a null pointer to the next free block.                             : 
1280			;                                                                             : 
1280			; Parameters                                                                  : 
1280			;     Inputs are compile-time only. Two defines which specify the starting    : 
1280			;     address of the heap and its size are required, along with a memory      : 
1280			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1280			;     principally stores a pointer to the first free block in the heap.       : 
1280			;                                                                             : 
1280			; Returns                                                                     : 
1280			;     Nothing                                                                 : 
1280			;------------------------------------------------------------------------------ 
1280			heap_init: 
1280 e5			      push  HL 
1281			 
1281			      ; Initialise free list struct 
1281 21 0e 80		      ld    HL, heap_start 
1284 22 0a 80		      ld    (free_list), HL 
1287 21 00 00		      ld    HL, 0 
128a 22 0c 80		      ld    (free_list+2), HL 
128d			 
128d			      ; Insert first free block at bottom of heap, consumes entire heap 
128d 21 f6 ed		      ld    HL, heap_start+heap_size-4 
1290 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1293 21 e8 6d		      ld    HL, heap_size-4 
1296 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1299			 
1299			      ; Insert end of free list block at top of heap - two null words will 
1299			      ; terminate the free list 
1299 21 00 00		      ld    HL, 0 
129c 22 f8 ed		      ld    (heap_start+heap_size-2), HL 
129f 22 f6 ed		      ld    (heap_start+heap_size-4), HL 
12a2			 
12a2 e1			      pop   HL 
12a3			 
12a3 c9			      ret 
12a4			 
12a4			 
12a4			;------------------------------------------------------------------------------ 
12a4			;     malloc                                                                  : 
12a4			;                                                                             : 
12a4			; Description                                                                 : 
12a4			;     Allocates the wanted space from the heap and returns the address of the : 
12a4			;     first useable byte of the allocation.                                   : 
12a4			;                                                                             : 
12a4			;     Allocations can happen in one of two ways:                              : 
12a4			;                                                                             : 
12a4			;     1. A free block may be found which is the exact size wanted. In this    : 
12a4			;        case the block is removed from the free list and retuedn to the      : 
12a4			;        caller.                                                              : 
12a4			;     2. A free block may be found which is larger than the size wanted. In   : 
12a4			;        this case, the larger block is split into two. The first portion of  : 
12a4			;        this block will become the requested space by the malloc call and    : 
12a4			;        is returned to the caller. The second portion becomes a new free     : 
12a4			;        block, and the free list is adjusted to maintain continuity via this : 
12a4			;        newly created block.                                                 : 
12a4			;                                                                             : 
12a4			;     malloc does not set any initial value in the allocated space, the       : 
12a4			;     caller is required to do this as required.                              : 
12a4			;                                                                             : 
12a4			;     This implementation of malloc uses the stack exclusively, and is        : 
12a4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12a4			;     advisable to disable interrupts before calling malloc, and recommended  : 
12a4			;     to avoid the use of malloc inside ISRs in general.                      : 
12a4			;                                                                             : 
12a4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12a4			;                                                                             : 
12a4			; Parameters                                                                  : 
12a4			;     HL  Number of bytes wanted                                              : 
12a4			;                                                                             : 
12a4			; Returns                                                                     : 
12a4			;     HL  Address of the first useable byte of the allocation                 : 
12a4			;                                                                             : 
12a4			; Flags                                                                       : 
12a4			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12a4			;                                                                             : 
12a4			; Stack frame                                                                 : 
12a4			;       |             |                                                       : 
12a4			;       +-------------+                                                       : 
12a4			;       |     BC      |                                                       : 
12a4			;       +-------------+                                                       : 
12a4			;       |     DE      |                                                       : 
12a4			;       +-------------+                                                       : 
12a4			;       |     IX      |                                                       : 
12a4			;       +-------------+                                                       : 
12a4			;       |  prev_free  |                                                       : 
12a4			;   +4  +-------------+                                                       : 
12a4			;       |  this_free  |                                                       : 
12a4			;   +2  +-------------+                                                       : 
12a4			;       |  next_free  |                                                       : 
12a4			;   +0  +-------------+                                                       : 
12a4			;       |             |                                                       : 
12a4			;                                                                             : 
12a4			;------------------------------------------------------------------------------ 
12a4			 
12a4			 
12a4			;malloc: 
12a4			; 
12a4			;	SAVESP ON 1 
12a4			; 
12a4			;	call malloc_code 
12a4			; 
12a4			;	CHECKSP ON 1 
12a4			;	ret 
12a4			 
12a4			 
12a4			malloc: 
12a4 c5			      push  BC 
12a5 d5			      push  DE 
12a6 dd e5		      push  IX 
12a8			if DEBUG_FORTH_MALLOC_HIGH 
12a8			call malloc_guard_entry 
12a8			endif 
12a8			 
12a8					if DEBUG_FORTH_MALLOC 
12a8						DMARK "mal" 
12a8						CALLMONITOR 
12a8					endif 
12a8 7c			      ld    A, H                    ; Exit if no space requested 
12a9 b5			      or    L 
12aa ca 69 13		      jp    Z, malloc_early_exit 
12ad			 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			; 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			;inc hl 
12ad			 
12ad			 
12ad			 
12ad			 
12ad					if DEBUG_FORTH_MALLOC 
12ad						DMARK "maA" 
12ad						CALLMONITOR 
12ad					endif 
12ad			      ; Set up stack frame 
12ad eb			      ex    DE, HL 
12ae 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12b1 39			      add   HL, SP 
12b2 f9			      ld    SP, HL 
12b3 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12b7 dd 39		      add   IX, SP 
12b9			 
12b9			      ; Setup initial state 
12b9 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12bc 19			      add   HL, DE 
12bd			 
12bd 44			      ld    B, H                    ; Move want to BC 
12be 4d			      ld    C, L 
12bf			 
12bf 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
12c2 dd 75 04		      ld    (IX+4), L 
12c5 dd 74 05		      ld    (IX+5), H 
12c8			 
12c8 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12c9 23			      inc   HL 
12ca 56			      ld    D, (HL) 
12cb dd 73 02		      ld    (IX+2), E 
12ce dd 72 03		      ld    (IX+3), D 
12d1 eb			      ex    DE, HL                  ; this_free ptr into HL 
12d2			 
12d2					if DEBUG_FORTH_MALLOC 
12d2						DMARK "maB" 
12d2						CALLMONITOR 
12d2					endif 
12d2			      ; Loop through free block list to find some space 
12d2			malloc_find_space: 
12d2 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5			 
12d5 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12d6 b3			      or    E 
12d7 ca 63 13		      jp    Z, malloc_no_space 
12da			 
12da dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12dd dd 72 01		      ld    (IX+1), D 
12e0			 
12e0			      ; Does this block have enough space to make the allocation? 
12e0 23			      inc   HL                      ; Load free block size into DE 
12e1 5e			      ld    E, (HL) 
12e2 23			      inc   HL 
12e3 56			      ld    D, (HL) 
12e4			 
12e4 eb			      ex    DE, HL                  ; Check size of block against want 
12e5 b7			      or    A                       ; Ensure carry flag clear 
12e6 ed 42		      sbc   HL, BC 
12e8 e5			      push  HL                      ; Store the result for later (new block size) 
12e9			 
12e9 ca 38 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12ec 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12ee			 
12ee			      ; this_free block is not big enough, setup ptrs to test next free block 
12ee e1			      pop   HL                      ; Discard previous result 
12ef			 
12ef dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12f2 dd 66 03		      ld    H, (IX+3) 
12f5 dd 75 04		      ld    (IX+4), L 
12f8 dd 74 05		      ld    (IX+5), H 
12fb			 
12fb dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12fe dd 66 01		      ld    H, (IX+1) 
1301 dd 75 02		      ld    (IX+2), L 
1304 dd 74 03		      ld    (IX+3), H 
1307			 
1307					if DEBUG_FORTH_MALLOC 
1307						DMARK "MA>" 
1307						CALLMONITOR 
1307					endif 
1307 18 c9		      jr    malloc_find_space 
1309			 
1309			      ; split a bigger block into two - requested size and remaining size 
1309			malloc_alloc_split: 
1309					if DEBUG_FORTH_MALLOC 
1309						DMARK "MAs" 
1309						CALLMONITOR 
1309					endif 
1309 eb			      ex    DE, HL                  ; Calculate address of new free block 
130a 2b			      dec   HL 
130b 2b			      dec   HL 
130c 2b			      dec   HL 
130d 09			      add   HL, BC 
130e			 
130e			      ; Create a new block and point it at next_free 
130e dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1311 dd 56 01		      ld    D, (IX+1) 
1314			 
1314 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1315 23			      inc   HL 
1316 72			      ld    (HL), D 
1317			 
1317 d1			      pop   DE                      ; Store size of new block into new block 
1318 23			      inc   HL 
1319 73			      ld    (HL), E 
131a 23			      inc   HL 
131b 72			      ld    (HL), D 
131c			 
131c			      ; Update this_free ptr to point to new block 
131c 2b			      dec   HL 
131d 2b			      dec   HL 
131e 2b			      dec   HL 
131f			 
131f dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1322 dd 56 03		      ld    D, (IX+3) 
1325			 
1325 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1328 dd 74 03		      ld    (IX+3), H 
132b			 
132b			      ; Modify this_free block to be allocation 
132b eb			      ex    DE, HL 
132c af			      xor   A                       ; Null the next block ptr of allocated block 
132d 77			      ld    (HL), A 
132e 23			      inc   HL 
132f 77			      ld    (HL), A 
1330			 
1330 23			      inc   HL                      ; Store want size into allocated block 
1331 71			      ld    (HL), C 
1332 23			      inc   HL 
1333 70			      ld    (HL), B 
1334 23			      inc   HL 
1335 e5			      push  HL                      ; Address of allocation to return 
1336			 
1336 18 19		      jr    malloc_update_links 
1338			 
1338			malloc_alloc_fit: 
1338 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1339			 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAf" 
1339						CALLMONITOR 
1339					endif 
1339			      ; Modify this_free block to be allocation 
1339 eb			      ex    DE, HL 
133a 2b			      dec   HL 
133b 2b			      dec   HL 
133c 2b			      dec   HL 
133d			 
133d af			      xor   A                       ; Null the next block ptr of allocated block 
133e 77			      ld    (HL), A 
133f 23			      inc   HL 
1340 77			      ld    (HL), A 
1341			 
1341 23			      inc   HL                      ; Store address of allocation to return 
1342 23			      inc   HL 
1343 23			      inc   HL 
1344 e5			      push  HL 
1345			 
1345			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1345 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1348 dd 66 01		      ld    H, (IX+1) 
134b			 
134b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
134e dd 74 03		      ld    (IX+3), H 
1351			 
1351			 
1351			malloc_update_links: 
1351			      ; Update prev_free ptr to point to this_free 
1351 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1354 dd 66 05		      ld    H, (IX+5) 
1357			 
1357 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
135a dd 56 03		      ld    D, (IX+3) 
135d			 
135d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
135e 23			      inc   HL 
135f 72			      ld    (HL), D 
1360			 
1360					if DEBUG_FORTH_MALLOC 
1360						DMARK "Mul" 
1360						CALLMONITOR 
1360					endif 
1360			      ; Clear the Z flag to indicate successful allocation 
1360 7a			      ld    A, D 
1361 b3			      or    E 
1362			 
1362 d1			      pop   DE                      ; Address of allocation 
1363					if DEBUG_FORTH_MALLOC 
1363						DMARK "MAu" 
1363						CALLMONITOR 
1363					endif 
1363			 
1363			malloc_no_space: 
1363 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1366 39			      add   HL, SP 
1367 f9			      ld    SP, HL 
1368			 
1368 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1369					if DEBUG_FORTH_MALLOC 
1369						DMARK "MAN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			malloc_early_exit: 
1369					if DEBUG_FORTH_MALLOC 
1369						DMARK "MAx" 
1369						CALLMONITOR 
1369					endif 
1369 dd e1		      pop   IX 
136b d1			      pop   DE 
136c c1			      pop   BC 
136d			 
136d			if DEBUG_FORTH_MALLOC_HIGH 
136d			call malloc_guard_exit 
136d			call malloc_guard_zerolen 
136d			endif 
136d c9			      ret 
136e			 
136e			 
136e			;------------------------------------------------------------------------------ 
136e			;     free                                                                    : 
136e			;                                                                             : 
136e			; Description                                                                 : 
136e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
136e			;     returned by malloc, otherwise the behaviour is undefined.               : 
136e			;                                                                             : 
136e			;     Where possible, directly adjacent free blocks will be merged together   : 
136e			;     into larger blocks to help ensure that the heap does not become         : 
136e			;     excessively fragmented.                                                 : 
136e			;                                                                             : 
136e			;     free does not clear or set any other value into the freed space, and    : 
136e			;     therefore its contents may be visible through subsequent malloc's. The  : 
136e			;     caller should clear the freed space as required.                        : 
136e			;                                                                             : 
136e			;     This implementation of free uses the stack exclusively, and is          : 
136e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
136e			;     advisable to disable interrupts before calling free, and recommended    : 
136e			;     to avoid the use of free inside ISRs in general.                        : 
136e			;                                                                             : 
136e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
136e			;                                                                             : 
136e			; Parameters                                                                  : 
136e			;     HL  Pointer to address of first byte of allocation to be freed          : 
136e			;                                                                             : 
136e			; Returns                                                                     : 
136e			;     Nothing                                                                 : 
136e			;                                                                             : 
136e			; Stack frame                                                                 : 
136e			;       |             |                                                       : 
136e			;       +-------------+                                                       : 
136e			;       |     BC      |                                                       : 
136e			;       +-------------+                                                       : 
136e			;       |     DE      |                                                       : 
136e			;       +-------------+                                                       : 
136e			;       |     IX      |                                                       : 
136e			;       +-------------+                                                       : 
136e			;       |  prev_free  |                                                       : 
136e			;   +2  +-------------+                                                       : 
136e			;       |  next_free  |                                                       : 
136e			;   +0  +-------------+                                                       : 
136e			;       |             |                                                       : 
136e			;                                                                             : 
136e			;------------------------------------------------------------------------------ 
136e			free: 
136e c5			      push  BC 
136f d5			      push  DE 
1370 dd e5		      push  IX 
1372			 
1372 7c			      ld    A, H                    ; Exit if ptr is null 
1373 b5			      or    L 
1374 ca 38 14		      jp    Z, free_early_exit 
1377			 
1377			      ; Set up stack frame 
1377 eb			      ex    DE, HL 
1378 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
137b 39			      add   HL, SP 
137c f9			      ld    SP, HL 
137d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1381 dd 39		      add   IX, SP 
1383			 
1383			      ; The address in HL points to the start of the useable allocated space, 
1383			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1383			      ; address of the block itself. 
1383 eb			      ex    DE, HL 
1384 11 fc ff		      ld    DE, -4 
1387 19			      add   HL, DE 
1388			 
1388			      ; An allocated block must have a null next block pointer in it 
1388 7e			      ld    A, (HL) 
1389 23			      inc   HL 
138a b6			      or    (HL) 
138b c2 33 14		      jp    NZ, free_done 
138e			 
138e 2b			      dec   HL 
138f			 
138f 44			      ld    B, H                    ; Copy HL to BC 
1390 4d			      ld    C, L 
1391			 
1391			      ; Loop through the free list to find the first block with an address 
1391			      ; higher than the block being freed 
1391 21 0a 80		      ld    HL, free_list 
1394			 
1394			free_find_higher_block: 
1394 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1395 23			      inc   HL 
1396 56			      ld    D, (HL) 
1397 2b			      dec   HL 
1398			 
1398 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
139b dd 72 01		      ld    (IX+1), D 
139e dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13a1 dd 74 03		      ld    (IX+3), H 
13a4			 
13a4 78			      ld    A, B                    ; Check if DE is greater than BC 
13a5 ba			      cp    D                       ; Compare MSB first 
13a6 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13a8 30 04		      jr    NC, free_find_higher_block_skip 
13aa 79			      ld    A, C 
13ab bb			      cp    E                       ; Then compare LSB 
13ac 38 08		      jr    C, free_found_higher_block 
13ae			 
13ae			free_find_higher_block_skip: 
13ae 7a			      ld    A, D                    ; Reached the end of the free list? 
13af b3			      or    E 
13b0 ca 33 14		      jp    Z, free_done 
13b3			 
13b3 eb			      ex    DE, HL 
13b4			 
13b4 18 de		      jr    free_find_higher_block 
13b6			 
13b6			free_found_higher_block: 
13b6			      ; Insert freed block between prev and next free blocks 
13b6 71			      ld    (HL), C                 ; Point prev free block to freed block 
13b7 23			      inc   HL 
13b8 70			      ld    (HL), B 
13b9			 
13b9 60			      ld    H, B                    ; Point freed block at next free block 
13ba 69			      ld    L, C 
13bb 73			      ld    (HL), E 
13bc 23			      inc   HL 
13bd 72			      ld    (HL), D 
13be			 
13be			      ; Check if the freed block is adjacent to the next free block 
13be 23			      inc   HL                      ; Load size of freed block into HL 
13bf 5e			      ld    E, (HL) 
13c0 23			      inc   HL 
13c1 56			      ld    D, (HL) 
13c2 eb			      ex    DE, HL 
13c3			 
13c3 09			      add   HL, BC                  ; Add addr of freed block and its size 
13c4			 
13c4 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13c7 dd 56 01		      ld    D, (IX+1) 
13ca			 
13ca b7			      or    A                       ; Clear the carry flag 
13cb ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13cd 20 22		      jr    NZ, free_check_adjacent_to_prev 
13cf			 
13cf			      ; Freed block is adjacent to next, merge into one bigger block 
13cf eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13d0 5e			      ld    E, (HL) 
13d1 23			      inc   HL 
13d2 56			      ld    D, (HL) 
13d3 e5			      push  HL                      ; Save ptr to next block for later 
13d4			 
13d4 60			      ld    H, B                    ; Store ptr from next block into freed block 
13d5 69			      ld    L, C 
13d6 73			      ld    (HL), E 
13d7 23			      inc   HL 
13d8 72			      ld    (HL), D 
13d9			 
13d9 e1			      pop   HL                      ; Restore ptr to next block 
13da 23			      inc   HL                      ; Load size of next block into DE 
13db 5e			      ld    E, (HL) 
13dc 23			      inc   HL 
13dd 56			      ld    D, (HL) 
13de d5			      push  DE                      ; Save next block size for later 
13df			 
13df 60			      ld    H, B                    ; Load size of freed block into HL 
13e0 69			      ld    L, C 
13e1 23			      inc   HL 
13e2 23			      inc   HL 
13e3 5e			      ld    E, (HL) 
13e4 23			      inc   HL 
13e5 56			      ld    D, (HL) 
13e6 eb			      ex    DE, HL 
13e7			 
13e7 d1			      pop   DE                      ; Restore size of next block 
13e8 19			      add   HL, DE                  ; Add sizes of both blocks 
13e9 eb			      ex    DE, HL 
13ea			 
13ea 60			      ld    H, B                    ; Store new bigger size into freed block 
13eb 69			      ld    L, C 
13ec 23			      inc   HL 
13ed 23			      inc   HL 
13ee 73			      ld    (HL), E 
13ef 23			      inc   HL 
13f0 72			      ld    (HL), D 
13f1			 
13f1			free_check_adjacent_to_prev: 
13f1			      ; Check if the freed block is adjacent to the prev free block 
13f1 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13f4 dd 66 03		      ld    H, (IX+3) 
13f7			 
13f7 23			      inc   HL                      ; Size of prev free block into DE 
13f8 23			      inc   HL 
13f9 5e			      ld    E, (HL) 
13fa 23			      inc   HL 
13fb 56			      ld    D, (HL) 
13fc 2b			      dec   HL 
13fd 2b			      dec   HL 
13fe 2b			      dec   HL 
13ff			 
13ff 19			      add   HL, DE                  ; Add prev block addr and size 
1400			 
1400 b7			      or    A                       ; Clear the carry flag 
1401 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1403 20 2e		      jr    NZ, free_done 
1405			 
1405			      ; Freed block is adjacent to prev, merge into one bigger block 
1405 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1406 69			      ld    L, C 
1407 5e			      ld    E, (HL) 
1408 23			      inc   HL 
1409 56			      ld    D, (HL) 
140a e5			      push  HL                      ; Save freed block ptr for later 
140b			 
140b dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
140e dd 66 03		      ld    H, (IX+3) 
1411 73			      ld    (HL), E 
1412 23			      inc   HL 
1413 72			      ld    (HL), D 
1414			 
1414 e1			      pop   HL                      ; Restore freed block ptr 
1415 23			      inc   HL                      ; Load size of freed block into DE 
1416 5e			      ld    E, (HL) 
1417 23			      inc   HL 
1418 56			      ld    D, (HL) 
1419 d5			      push  DE                      ; Save freed block size for later 
141a			 
141a dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
141d dd 66 03		      ld    H, (IX+3) 
1420 23			      inc   HL 
1421 23			      inc   HL 
1422 5e			      ld    E, (HL) 
1423 23			      inc   HL 
1424 56			      ld    D, (HL) 
1425			 
1425 e1			      pop   HL                      ; Add sizes of both blocks 
1426 19			      add   HL, DE 
1427 eb			      ex    DE, HL 
1428			 
1428 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
142b dd 66 03		      ld    H, (IX+3) 
142e 23			      inc   HL 
142f 23			      inc   HL 
1430 73			      ld    (HL), E 
1431 23			      inc   HL 
1432 72			      ld    (HL), D 
1433			 
1433			free_done: 
1433 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1436 39			      add   HL, SP 
1437 f9			      ld    SP, HL 
1438			 
1438			free_early_exit: 
1438 dd e1		      pop   IX 
143a d1			      pop   DE 
143b c1			      pop   BC 
143c			 
143c c9			      ret 
143d			 
143d			; moved to firmware.asm 
143d			; 
143d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
143d			;                  .dw   0 
143d			 
143d			 
143d			endif 
143d			 
143d			 
143d			if MALLOC_3 
143d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
143d			;heap_start        .equ  0x9000      ; Starting address of heap 
143d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
143d			; 
143d			 ;     .org 0 
143d			  ;    jp    main 
143d			; 
143d			; 
143d			 ;     .org  0x100 
143d			;main: 
143d			 ;     ld    HL, 0x8100 
143d			  ;    ld    SP, HL 
143d			; 
143d			;      call  heap_init 
143d			 
143d			      ; Make some allocations 
143d			;      ld    HL, 12 
143d			;      call  malloc            ; Allocates 0x9004 
143d			; 
143d			 ;     ld    HL, 12 
143d			;      call  malloc            ; Allocates 0x9014 
143d			 
143d			;      ld    HL, 12 
143d			;      call  malloc            ; Allocates 0x9024 
143d			 
143d			      ; Free some allocations 
143d			;      ld    HL, 0x9014 
143d			;      call  free 
143d			 
143d			;      ld    HL, 0x9004 
143d			;      call  free 
143d			; 
143d			;      ld    HL, 0x9024 
143d			;      call  free 
143d			 
143d			 
143d			 ;     halt 
143d			 
143d			 
143d			;------------------------------------------------------------------------------ 
143d			;     heap_init                                                               : 
143d			;                                                                             : 
143d			; Description                                                                 : 
143d			;     Initialise the heap and make it ready for malloc and free operations.   : 
143d			;                                                                             : 
143d			;     The heap is maintained as a linked list, starting with an initial       : 
143d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
143d			;     the first free block in the heap. Each block then points to the next    : 
143d			;     free block within the heap, and the free list ends at the first block   : 
143d			;     with a null pointer to the next free block.                             : 
143d			;                                                                             : 
143d			; Parameters                                                                  : 
143d			;     Inputs are compile-time only. Two defines which specify the starting    : 
143d			;     address of the heap and its size are required, along with a memory      : 
143d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
143d			;     principally stores a pointer to the first free block in the heap.       : 
143d			;                                                                             : 
143d			; Returns                                                                     : 
143d			;     Nothing                                                                 : 
143d			;------------------------------------------------------------------------------ 
143d			heap_init: 
143d			      push  HL 
143d			 
143d			      ; Initialise free list struct 
143d			      ld    HL, heap_start 
143d			      ld    (free_list), HL 
143d			      ld    HL, 0 
143d			      ld    (free_list+2), HL 
143d			 
143d			      ; Insert first free block at bottom of heap, consumes entire heap 
143d			      ld    HL, heap_start+heap_size-4 
143d			      ld    (heap_start), HL        ; Next block (end of free list) 
143d			      ld    HL, heap_size-4 
143d			      ld    (heap_start+2), HL      ; Block size 
143d			 
143d			      ; Insert end of free list block at top of heap - two null words will 
143d			      ; terminate the free list 
143d			      ld    HL, 0 
143d			      ld    (heap_start+heap_size-2), HL 
143d			      ld    (heap_start+heap_size-4), HL 
143d			 
143d			      pop   HL 
143d			 
143d			      ret 
143d			 
143d			 
143d			;------------------------------------------------------------------------------ 
143d			;     malloc                                                                  : 
143d			;                                                                             : 
143d			; Description                                                                 : 
143d			;     Allocates the wanted space from the heap and returns the address of the : 
143d			;     first useable byte of the allocation.                                   : 
143d			;                                                                             : 
143d			;     Allocations can happen in one of two ways:                              : 
143d			;                                                                             : 
143d			;     1. A free block may be found which is the exact size wanted. In this    : 
143d			;        case the block is removed from the free list and retuedn to the      : 
143d			;        caller.                                                              : 
143d			;     2. A free block may be found which is larger than the size wanted. In   : 
143d			;        this case, the larger block is split into two. The first portion of  : 
143d			;        this block will become the requested space by the malloc call and    : 
143d			;        is returned to the caller. The second portion becomes a new free     : 
143d			;        block, and the free list is adjusted to maintain continuity via this : 
143d			;        newly created block.                                                 : 
143d			;                                                                             : 
143d			;     malloc does not set any initial value in the allocated space, the       : 
143d			;     caller is required to do this as required.                              : 
143d			;                                                                             : 
143d			;     This implementation of malloc uses the stack exclusively, and is        : 
143d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
143d			;     advisable to disable interrupts before calling malloc, and recommended  : 
143d			;     to avoid the use of malloc inside ISRs in general.                      : 
143d			;                                                                             : 
143d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
143d			;                                                                             : 
143d			; Parameters                                                                  : 
143d			;     HL  Number of bytes wanted                                              : 
143d			;                                                                             : 
143d			; Returns                                                                     : 
143d			;     HL  Address of the first useable byte of the allocation                 : 
143d			;                                                                             : 
143d			; Flags                                                                       : 
143d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
143d			;                                                                             : 
143d			; Stack frame                                                                 : 
143d			;       |             |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |     BC      |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |     DE      |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |     IX      |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |  prev_free  |                                                       : 
143d			;   +4  +-------------+                                                       : 
143d			;       |  this_free  |                                                       : 
143d			;   +2  +-------------+                                                       : 
143d			;       |  next_free  |                                                       : 
143d			;   +0  +-------------+                                                       : 
143d			;       |             |                                                       : 
143d			;                                                                             : 
143d			;------------------------------------------------------------------------------ 
143d			malloc: 
143d			      push  BC 
143d			      push  DE 
143d			      push  IX 
143d			 
143d			      ld    A, H                    ; Exit if no space requested 
143d			      or    L 
143d			      jp    Z, malloc_early_exit 
143d			 
143d			      ; Set up stack frame 
143d			      ex    DE, HL 
143d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
143d			      add   HL, SP 
143d			      ld    SP, HL 
143d			      ld    IX, 0                   ; Use IX as a frame pointer 
143d			      add   IX, SP 
143d			 
143d			      ; Setup initial state 
143d			      ld    HL, 4                   ; want must also include space used by block struct 
143d			      add   HL, DE 
143d			 
143d			      ld    B, H                    ; Move want to BC 
143d			      ld    C, L 
143d			 
143d			      ld    HL, free_list           ; Store prev_free ptr to stack 
143d			      ld    (IX+4), L 
143d			      ld    (IX+5), H 
143d			 
143d			      ld    E, (HL)                 ; Store this_free ptr to stack 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      ld    (IX+2), E 
143d			      ld    (IX+3), D 
143d			      ex    DE, HL                  ; this_free ptr into HL 
143d			 
143d			      ; Loop through free block list to find some space 
143d			malloc_find_space: 
143d			      ld    E, (HL)                 ; Load next_free ptr into DE 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			 
143d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
143d			      or    E 
143d			      jp    Z, malloc_no_space 
143d			 
143d			      ld    (IX+0), E               ; Store next_free ptr to stack 
143d			      ld    (IX+1), D 
143d			 
143d			      ; Does this block have enough space to make the allocation? 
143d			      inc   HL                      ; Load free block size into DE 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			 
143d			      ex    DE, HL                  ; Check size of block against want 
143d			      or    A                       ; Ensure carry flag clear 
143d			      sbc   HL, BC 
143d			      push  HL                      ; Store the result for later (new block size) 
143d			 
143d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
143d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
143d			 
143d			      ; this_free block is not big enough, setup ptrs to test next free block 
143d			      pop   HL                      ; Discard previous result 
143d			 
143d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
143d			      ld    H, (IX+3) 
143d			      ld    (IX+4), L 
143d			      ld    (IX+5), H 
143d			 
143d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
143d			      ld    H, (IX+1) 
143d			      ld    (IX+2), L 
143d			      ld    (IX+3), H 
143d			 
143d			      jr    malloc_find_space 
143d			 
143d			      ; split a bigger block into two - requested size and remaining size 
143d			malloc_alloc_split: 
143d			      ex    DE, HL                  ; Calculate address of new free block 
143d			      dec   HL 
143d			      dec   HL 
143d			      dec   HL 
143d			      add   HL, BC 
143d			 
143d			      ; Create a new block and point it at next_free 
143d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
143d			      ld    D, (IX+1) 
143d			 
143d			      ld    (HL), E                 ; Store next_free ptr into new block 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			      pop   DE                      ; Store size of new block into new block 
143d			      inc   HL 
143d			      ld    (HL), E 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			      ; Update this_free ptr to point to new block 
143d			      dec   HL 
143d			      dec   HL 
143d			      dec   HL 
143d			 
143d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
143d			      ld    D, (IX+3) 
143d			 
143d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d			      ld    (IX+3), H 
143d			 
143d			      ; Modify this_free block to be allocation 
143d			      ex    DE, HL 
143d			      xor   A                       ; Null the next block ptr of allocated block 
143d			      ld    (HL), A 
143d			      inc   HL 
143d			      ld    (HL), A 
143d			 
143d			      inc   HL                      ; Store want size into allocated block 
143d			      ld    (HL), C 
143d			      inc   HL 
143d			      ld    (HL), B 
143d			      inc   HL 
143d			      push  HL                      ; Address of allocation to return 
143d			 
143d			      jr    malloc_update_links 
143d			 
143d			malloc_alloc_fit: 
143d			      pop   HL                      ; Dont need new block size, want is exact fit 
143d			 
143d			      ; Modify this_free block to be allocation 
143d			      ex    DE, HL 
143d			      dec   HL 
143d			      dec   HL 
143d			      dec   HL 
143d			 
143d			      xor   A                       ; Null the next block ptr of allocated block 
143d			      ld    (HL), A 
143d			      inc   HL 
143d			      ld    (HL), A 
143d			 
143d			      inc   HL                      ; Store address of allocation to return 
143d			      inc   HL 
143d			      inc   HL 
143d			      push  HL 
143d			 
143d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
143d			      ld    L, (IX+0)               ; next_free to HL 
143d			      ld    H, (IX+1) 
143d			 
143d			      ld    (IX+2), L               ; HL to this_free 
143d			      ld    (IX+3), H 
143d			 
143d			 
143d			malloc_update_links: 
143d			      ; Update prev_free ptr to point to this_free 
143d			      ld    L, (IX+4)               ; prev_free ptr to HL 
143d			      ld    H, (IX+5) 
143d			 
143d			      ld    E, (IX+2)               ; this_free ptr to DE 
143d			      ld    D, (IX+3) 
143d			 
143d			      ld    (HL), E                 ; this_free ptr into prev_free 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			      ; Clear the Z flag to indicate successful allocation 
143d			      ld    A, D 
143d			      or    E 
143d			 
143d			      pop   DE                      ; Address of allocation 
143d			 
143d			malloc_no_space: 
143d			      ld    HL, 6                   ; Clean up stack frame 
143d			      add   HL, SP 
143d			      ld    SP, HL 
143d			 
143d			      ex    DE, HL                  ; Alloc addr into HL for return 
143d			 
143d			malloc_early_exit: 
143d			      pop   IX 
143d			      pop   DE 
143d			      pop   BC 
143d			 
143d			      ret 
143d			 
143d			 
143d			;------------------------------------------------------------------------------ 
143d			;     free                                                                    : 
143d			;                                                                             : 
143d			; Description                                                                 : 
143d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
143d			;     returned by malloc, otherwise the behaviour is undefined.               : 
143d			;                                                                             : 
143d			;     Where possible, directly adjacent free blocks will be merged together   : 
143d			;     into larger blocks to help ensure that the heap does not become         : 
143d			;     excessively fragmented.                                                 : 
143d			;                                                                             : 
143d			;     free does not clear or set any other value into the freed space, and    : 
143d			;     therefore its contents may be visible through subsequent malloc's. The  : 
143d			;     caller should clear the freed space as required.                        : 
143d			;                                                                             : 
143d			;     This implementation of free uses the stack exclusively, and is          : 
143d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
143d			;     advisable to disable interrupts before calling free, and recommended    : 
143d			;     to avoid the use of free inside ISRs in general.                        : 
143d			;                                                                             : 
143d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
143d			;                                                                             : 
143d			; Parameters                                                                  : 
143d			;     HL  Pointer to address of first byte of allocation to be freed          : 
143d			;                                                                             : 
143d			; Returns                                                                     : 
143d			;     Nothing                                                                 : 
143d			;                                                                             : 
143d			; Stack frame                                                                 : 
143d			;       |             |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |     BC      |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |     DE      |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |     IX      |                                                       : 
143d			;       +-------------+                                                       : 
143d			;       |  prev_free  |                                                       : 
143d			;   +2  +-------------+                                                       : 
143d			;       |  next_free  |                                                       : 
143d			;   +0  +-------------+                                                       : 
143d			;       |             |                                                       : 
143d			;                                                                             : 
143d			;------------------------------------------------------------------------------ 
143d			free: 
143d			      push  BC 
143d			      push  DE 
143d			      push  IX 
143d			 
143d			      ld    A, H                    ; Exit if ptr is null 
143d			      or    L 
143d			      jp    Z, free_early_exit 
143d			 
143d			      ; Set up stack frame 
143d			      ex    DE, HL 
143d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
143d			      add   HL, SP 
143d			      ld    SP, HL 
143d			      ld    IX, 0                   ; Use IX as a frame pointer 
143d			      add   IX, SP 
143d			 
143d			      ; The address in HL points to the start of the useable allocated space, 
143d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
143d			      ; address of the block itself. 
143d			      ex    DE, HL 
143d			      ld    DE, -4 
143d			      add   HL, DE 
143d			 
143d			      ; An allocated block must have a null next block pointer in it 
143d			      ld    A, (HL) 
143d			      inc   HL 
143d			      or    (HL) 
143d			      jp    NZ, free_done 
143d			 
143d			      dec   HL 
143d			 
143d			      ld    B, H                    ; Copy HL to BC 
143d			      ld    C, L 
143d			 
143d			      ; Loop through the free list to find the first block with an address 
143d			      ; higher than the block being freed 
143d			      ld    HL, free_list 
143d			 
143d			free_find_higher_block: 
143d			      ld    E, (HL)                 ; Load next ptr from free block 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      dec   HL 
143d			 
143d			      ld    (IX+0), E               ; Save ptr to next free block 
143d			      ld    (IX+1), D 
143d			      ld    (IX+2), L               ; Save ptr to prev free block 
143d			      ld    (IX+3), H 
143d			 
143d			      ld    A, B                    ; Check if DE is greater than BC 
143d			      cp    D                       ; Compare MSB first 
143d			      jr    Z, $+4                  ; MSB the same, compare LSB 
143d			      jr    NC, free_find_higher_block_skip 
143d			      ld    A, C 
143d			      cp    E                       ; Then compare LSB 
143d			      jr    C, free_found_higher_block 
143d			 
143d			free_find_higher_block_skip: 
143d			      ld    A, D                    ; Reached the end of the free list? 
143d			      or    E 
143d			      jp    Z, free_done 
143d			 
143d			      ex    DE, HL 
143d			 
143d			      jr    free_find_higher_block 
143d			 
143d			free_found_higher_block: 
143d			      ; Insert freed block between prev and next free blocks 
143d			      ld    (HL), C                 ; Point prev free block to freed block 
143d			      inc   HL 
143d			      ld    (HL), B 
143d			 
143d			      ld    H, B                    ; Point freed block at next free block 
143d			      ld    L, C 
143d			      ld    (HL), E 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			      ; Check if the freed block is adjacent to the next free block 
143d			      inc   HL                      ; Load size of freed block into HL 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      ex    DE, HL 
143d			 
143d			      add   HL, BC                  ; Add addr of freed block and its size 
143d			 
143d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
143d			      ld    D, (IX+1) 
143d			 
143d			      or    A                       ; Clear the carry flag 
143d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
143d			      jr    NZ, free_check_adjacent_to_prev 
143d			 
143d			      ; Freed block is adjacent to next, merge into one bigger block 
143d			      ex    DE, HL                  ; Load next ptr from next block into DE 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      push  HL                      ; Save ptr to next block for later 
143d			 
143d			      ld    H, B                    ; Store ptr from next block into freed block 
143d			      ld    L, C 
143d			      ld    (HL), E 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			      pop   HL                      ; Restore ptr to next block 
143d			      inc   HL                      ; Load size of next block into DE 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      push  DE                      ; Save next block size for later 
143d			 
143d			      ld    H, B                    ; Load size of freed block into HL 
143d			      ld    L, C 
143d			      inc   HL 
143d			      inc   HL 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      ex    DE, HL 
143d			 
143d			      pop   DE                      ; Restore size of next block 
143d			      add   HL, DE                  ; Add sizes of both blocks 
143d			      ex    DE, HL 
143d			 
143d			      ld    H, B                    ; Store new bigger size into freed block 
143d			      ld    L, C 
143d			      inc   HL 
143d			      inc   HL 
143d			      ld    (HL), E 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			free_check_adjacent_to_prev: 
143d			      ; Check if the freed block is adjacent to the prev free block 
143d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
143d			      ld    H, (IX+3) 
143d			 
143d			      inc   HL                      ; Size of prev free block into DE 
143d			      inc   HL 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      dec   HL 
143d			      dec   HL 
143d			      dec   HL 
143d			 
143d			      add   HL, DE                  ; Add prev block addr and size 
143d			 
143d			      or    A                       ; Clear the carry flag 
143d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
143d			      jr    NZ, free_done 
143d			 
143d			      ; Freed block is adjacent to prev, merge into one bigger block 
143d			      ld    H, B                    ; Load next ptr from freed block into DE 
143d			      ld    L, C 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      push  HL                      ; Save freed block ptr for later 
143d			 
143d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
143d			      ld    H, (IX+3) 
143d			      ld    (HL), E 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			      pop   HL                      ; Restore freed block ptr 
143d			      inc   HL                      ; Load size of freed block into DE 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			      push  DE                      ; Save freed block size for later 
143d			 
143d			      ld    L, (IX+2)               ; Load size of prev block into DE 
143d			      ld    H, (IX+3) 
143d			      inc   HL 
143d			      inc   HL 
143d			      ld    E, (HL) 
143d			      inc   HL 
143d			      ld    D, (HL) 
143d			 
143d			      pop   HL                      ; Add sizes of both blocks 
143d			      add   HL, DE 
143d			      ex    DE, HL 
143d			 
143d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
143d			      ld    H, (IX+3) 
143d			      inc   HL 
143d			      inc   HL 
143d			      ld    (HL), E 
143d			      inc   HL 
143d			      ld    (HL), D 
143d			 
143d			free_done: 
143d			      ld    HL, 4                   ; Clean up stack frame 
143d			      add   HL, SP 
143d			      ld    SP, HL 
143d			 
143d			free_early_exit: 
143d			      pop   IX 
143d			      pop   DE 
143d			      pop   BC 
143d			 
143d			      ret 
143d			 
143d			 
143d			;      .org 0x8000 
143d			; 
143d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
143d			 ;                 .dw   0 
143d			 
143d			endif 
143d			 
143d			 
143d			if MALLOC_4 
143d			 
143d			; My memory allocation code. Very very simple.... 
143d			; allocate space under 250 chars 
143d			 
143d			heap_init: 
143d				; init start of heap as zero 
143d				;  
143d			 
143d				ld hl, heap_start 
143d				ld a, 0 
143d				ld (hl), a      ; empty block 
143d				inc hl 
143d				ld a, 0 
143d				ld (hl), a      ; length of block 
143d				; write end of list 
143d				inc hl 
143d				ld a,(hl) 
143d				inc hl 
143d				ld a,(hl) 
143d				 
143d			 
143d				; init some malloc vars 
143d			 
143d				ld hl, 0 
143d				ld (free_list), hl       ; store last malloc location 
143d			 
143d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
143d				ld a, 0 
143d				ld (hl), a 
143d			 
143d			 
143d				ld hl, heap_start 
143d				;  
143d				  
143d				ret 
143d			 
143d			 
143d			;    free block marker 
143d			;    requested size  
143d			;    pointer to next block 
143d			;    .... 
143d			;    next block marker 
143d			 
143d			 
143d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
143d			; 
143d			 
143d			 
143d			malloc:  
143d				push de 
143d				push bc 
143d				push af 
143d			 
143d				; hl space required 
143d				 
143d				ld c, l    ; hold space   (TODO only a max of 255) 
143d			 
143d			;	inc c     ; TODO BUG need to fix memory leak on push str 
143d			;	inc c 
143d			;	inc c 
143d			;	inc c 
143d			;	inc c 
143d			;	inc c 
143d			;	inc c 
143d			 
143d			 
143d			 
143d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
143d			 
143d				ld a, (free_list+3) 
143d				cp 0 
143d				jr z, .contheap 
143d			 
143d				ld hl, (free_list)     ; get last alloc 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "mrs" 
143d						CALLMONITOR 
143d					endif 
143d				jr .startalloc 
143d			 
143d			.contheap: 
143d				ld hl, heap_start 
143d			 
143d			.startalloc: 
143d			 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "mym" 
143d						CALLMONITOR 
143d					endif 
143d			.findblock: 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "mmf" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d				ld a,(hl)  
143d				; if byte is zero then clear to use 
143d			 
143d				cp 0 
143d				jr z, .foundemptyblock 
143d			 
143d				; if byte is not clear 
143d				;     then byte is offset to next block 
143d			 
143d				inc hl 
143d				ld a, (hl) ; get size 
143d			.nextblock:	inc hl 
143d					ld e, (hl) 
143d					inc hl 
143d					ld d, (hl) 
143d					ex de, hl 
143d			;	inc hl  ; move past the store space 
143d			;	inc hl  ; move past zero index  
143d			 
143d				; TODO detect no more space 
143d			 
143d				push hl 
143d				ld de, heap_end 
143d				call cmp16 
143d				pop hl 
143d				jr nc, .nospace 
143d			 
143d				jr .findblock 
143d			 
143d			.nospace: ld hl, 0 
143d				jp .exit 
143d			 
143d			 
143d			.foundemptyblock:	 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "mme" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			; TODO has block enough space if reusing??? 
143d			 
143d				;  
143d			 
143d			; see if this block has been previously used 
143d				inc hl 
143d				ld a, (hl) 
143d				dec hl 
143d				cp 0 
143d				jr z, .newblock 
143d			 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "meR" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			; no reusing previously allocated block 
143d			 
143d			; is it smaller than previously used? 
143d				 
143d				inc hl    ; move to size 
143d				ld a, c 
143d				sub (hl)        ; we want c < (hl) 
143d				dec hl    ; move back to marker 
143d			        jr z, .findblock 
143d			 
143d				; update with the new size which should be lower 
143d			 
143d			        ;inc  hl   ; negate next move. move back to size  
143d			 
143d			.newblock: 
143d				; need to be at marker here 
143d			 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "meN" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			 
143d				ld a, c 
143d			 
143d				ld (free_list+3), a	 ; flag resume from last malloc  
143d				ld (free_list), hl    ; save out last location 
143d			 
143d			 
143d				;inc a     ; space for length byte 
143d				ld (hl), a     ; save block in use marker 
143d			 
143d				inc hl   ; move to space marker 
143d				ld (hl), a    ; save new space 
143d			 
143d				inc hl   ; move to start of allocated area 
143d				 
143d			;	push hl     ; save where we are - 1  
143d			 
143d			;	inc hl  ; move past zero index  
143d				; skip space to set down new marker 
143d			 
143d				; provide some extra space for now 
143d			 
143d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
143d				inc a 
143d				inc a 
143d			 
143d				push hl   ; save where we are in the node block 
143d			 
143d				call addatohl 
143d			 
143d				; write linked list point 
143d			 
143d				pop de     ; get our node position 
143d				ex de, hl 
143d			 
143d				ld (hl), e 
143d				inc hl 
143d				ld (hl), d 
143d			 
143d				inc hl 
143d			 
143d				; now at start of allocated data so save pointer 
143d			 
143d				push hl 
143d			 
143d				; jump to position of next node and setup empty header in DE 
143d			 
143d				ex de, hl 
143d			 
143d			;	inc hl ; move past end of block 
143d			 
143d				ld a, 0 
143d				ld (hl), a   ; empty marker 
143d				inc hl 
143d				ld (hl), a   ; size 
143d				inc hl  
143d				ld (hl), a   ; ptr 
143d				inc hl 
143d				ld (hl), a   ; ptr 
143d			 
143d			 
143d				pop hl 
143d			 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "mmr" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			.exit: 
143d				pop af 
143d				pop bc 
143d				pop de  
143d				ret 
143d			 
143d			 
143d			 
143d			 
143d			free:  
143d				push hl 
143d				push af 
143d				; get address in hl 
143d			 
143d					if DEBUG_FORTH_MALLOC_INT 
143d						DMARK "fre" 
143d						CALLMONITOR 
143d					endif 
143d				; data is at hl - move to block count 
143d				dec hl 
143d				dec hl    ; get past pointer 
143d				dec hl 
143d			 
143d				ld a, (hl)    ; need this for a validation check 
143d			 
143d				dec hl    ; move to block marker 
143d			 
143d				; now check that the block count and block marker are the same  
143d			        ; this checks that we are on a malloc node and not random memory 
143d			        ; OK a faint chance this could be a problem but rare - famous last words! 
143d			 
143d				ld c, a 
143d				ld a, (hl)    
143d			 
143d				cp c 
143d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
143d			 
143d				; yes good chance we are on a malloc node 
143d			 
143d				ld a, 0      
143d				ld (hl), a   ; mark as free 
143d			 
143d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
143d			 
143d			.freeignore:  
143d			 
143d				pop af 
143d				pop hl 
143d			 
143d				ret 
143d			 
143d			 
143d			 
143d			endif 
143d			 
143d			; eof 
# End of file firmware_memory.asm
143d			  
143d			; device C  
143d			if SOUND_ENABLE  
143d				include "firmware_sound.asm"  
143d			; Sound abstraction layer 
143d			 
143d			; support different sound chips through common interface 
143d			 
143d			SOUND_DEVICE_AY: equ 0 
143d			 
143d			SOUND_DEVICE: equ Device_A 
143d			 
143d			 
143d			 
143d			if SOUND_DEVICE_AY 
143d				include "firmware_sound_ay38910.asm" 
143d			else 
143d				include "firmware_sound_sn76489an.asm" 
143d			 
143d			; Device support for SN76489AN sound chip 
143d			 
143d			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
143d			; http://danceswithferrets.org/geekblog/?p=93 
143d			; https://www.smspower.org/Development/SN76489 
143d			 
143d			; D0 [ 3] 
143d			; D1 [ 2] 
143d			; D2 [ 1] 
143d			; D3 [15] 
143d			; D4 [13] 
143d			; D5 [12] 
143d			; D6 [11] 
143d			; D7 [10] 
143d			; /WE [ 5] 
143d			; CLK [14] 
143d			; /OE [ 6] 
143d			; AUDIO [ 7] 
143d			; GND 8 
143d			; +5 16 
143d			; 
143d			 
143d			; Write sequence: 
143d			; CE low 
143d			; Data bus 
143d			; WE low then high 
143d			; 32 clock cycles / 8ns write time at 4mhz 
143d			; 
143d			; https://github.com/jblang/SN76489 
143d			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
143d			; Tried: 
143d			; 
143d			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
143d			; 
143d			; Connected WE to OR too 
143d			;  
143d			; That enabled the clock when required 
143d			; However still random bus corruption. Need further investigation 
143d			 
143d			 
143d			SOUND_LATCH: equ 10000000B 
143d			SOUND_DATA: equ 0B 
143d			SOUND_CH0:  equ 0B    ; Tone 
143d			SOUND_CH1: equ 0100000B        ; Tone 
143d			SOUND_CH2: equ 1000000B   ; Tone 
143d			SOUND_CH3: equ 1100000B    ; Noise 
143d			SOUND_VOL: equ 10000B 
143d			SOUND_TONE: equ 0B 
143d			 
143d			 
143d			sound_init: 
143d 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
143f cd 54 14			call note_send_byte 
1442 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1444 cd 54 14			call note_send_byte 
1447 cd 1a 0b			call delay250ms 
144a 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
144c cd 54 14			call note_send_byte 
144f cd 1a 0b			call delay250ms 
1452 c9				ret 
1453			 
1453			; Play a note 
1453			; h = note 
1453			; l = duration 
1453			; a = channel 
1453			 
1453			 
1453			;  frequ = clock / ( 2 x reg valu x 32 )  
1453			 
1453			note:  
1453				 
1453			 
1453 c9				ret 
1454			 
1454			note_send_byte: 
1454				; byte in a 
1454			 
1454				; we high 
1454 d3 40			out (Device_B), a 
1456			;	ld a, 1 
1456			;	call aDelayInMS 
1456 00				nop  
1457 00				nop  
1458 00				nop  
1459 00				nop  
145a				; we low 
145a d3 40			out (Device_B), a 
145c			;	ld a, 1 
145c			;	call aDelayInMS 
145c 00				nop  
145d 00				nop  
145e 00				nop  
145f 00				nop  
1460				; we high 
1460 d3 40			out (Device_B), a 
1462			;	ld a, 1 
1462			;	call aDelayInMS 
1462 00				nop  
1463 00				nop  
1464 00				nop  
1465 00				nop  
1466			 
1466			 
1466 c9				ret 
1467			 
1467			;void SilenceAllChannels() 
1467			;{ 
1467			;  SendByte(0x9f); 
1467			;  SendByte(0xbf); 
1467			;  SendByte(0xdf); 
1467			;  SendByte(0xff); 
1467			;} 
1467			 
1467			 
1467			; eof 
1467			 
# End of file firmware_sound_sn76489an.asm
1467			endif 
1467			 
1467			 
1467			; Abstraction entry points 
1467			 
1467			; init  
1467			 
1467			; sound_init in specific hardware files 
1467			 
1467			; Play a note 
1467			; h = note 
1467			; l = duration 
1467			; a = channel 
1467			 
1467			;note:     
1467			;	ret 
1467			 
1467			 
1467			 
1467			 
1467			; eof 
1467			 
# End of file firmware_sound.asm
1467			endif  
1467			  
1467			include "firmware_diags.asm"  
1467			; Hardware diags menu 
1467			 
1467			 
1467			config: 
1467			 
1467 3e 00			ld a, 0 
1469 21 97 14			ld hl, .configmn 
146c cd da 0b			call menu 
146f			 
146f fe 00			cp 0 
1471 c8				ret z 
1472			 
1472 fe 01			cp 1 
1474 cc 70 15			call z, .savetostore 
1477			 
1477 fe 02			cp 2 
1479 cc be 14			call z, .selautoload 
147c fe 03			cp 3 
147e cc a7 14			call z, .disautoload 
1481 fe 04			cp 4 
1483 cc 6e 15			call z, .selbank 
1486 fe 05			cp 5 
1488 cc 4b 16			call z, .debug_tog 
148b fe 06			cp 6 
148d cc 8e 17			call z, .bpsgo 
1490 fe 07			cp 7 
1492 cc 71 16			call z, hardware_diags 
1495			 
1495 18 d0			jr config 
1497			 
1497			.configmn: 
1497 7f 19			dw prom_c3 
1499 96 19			dw prom_c2 
149b ab 19			dw prom_c2a 
149d c1 19			dw prom_c2b 
149f			;	dw prom_c4 
149f de 19			dw prom_m4 
14a1 f9 19			dw prom_m4b 
14a3 01 1a			dw prom_c1 
14a5 00 00			dw 0 
14a7				 
14a7			 
14a7			 
14a7			 
14a7			.disautoload: 
14a7				if STORAGE_SE 
14a7 3e fe			ld a, $fe      ; bit 0 clear 
14a9 32 3f f8			ld (spi_device), a 
14ac			 
14ac cd 6c 04			call storage_get_block_0 
14af			 
14af 3e 00			ld a, 0 
14b1 32 7a f8			ld (store_page+STORE_0_AUTOFILE), a 
14b4			 
14b4 21 00 00				ld hl, 0 
14b7 11 59 f8				ld de, store_page 
14ba cd 20 04			call storage_write_block	 ; save update 
14bd				else 
14bd			 
14bd				ld hl, prom_notav 
14bd				ld de, prom_empty 
14bd				call info_panel 
14bd				endif 
14bd			 
14bd			 
14bd c9				ret 
14be			 
14be			 
14be			 
14be			; Select auto start 
14be			 
14be			.selautoload: 
14be			 
14be				 
14be				if STORAGE_SE 
14be			 
14be cd 95 15				call config_dir 
14c1 21 14 ee			        ld hl, scratch 
14c4 3e 00				ld a, 0 
14c6 cd da 0b				call menu 
14c9			 
14c9 fe 00				cp 0 
14cb c8					ret z 
14cc			 
14cc 3d					dec a 
14cd			 
14cd			 
14cd					; locate menu option 
14cd			 
14cd 21 14 ee				ld hl, scratch 
14d0 cd fe 0a				call table_lookup 
14d3			 
14d3					if DEBUG_FORTH_WORDS 
14d3						DMARK "ALl" 
14d3 f5				push af  
14d4 3a e8 14			ld a, (.dmark)  
14d7 32 6e fb			ld (debug_mark),a  
14da 3a e9 14			ld a, (.dmark+1)  
14dd 32 6f fb			ld (debug_mark+1),a  
14e0 3a ea 14			ld a, (.dmark+2)  
14e3 32 70 fb			ld (debug_mark+2),a  
14e6 18 03			jr .pastdmark  
14e8 ..			.dmark: db "ALl"  
14eb f1			.pastdmark: pop af  
14ec			endm  
# End of macro DMARK
14ec						CALLMONITOR 
14ec cd 84 17			call break_point_state  
14ef				endm  
# End of macro CALLMONITOR
14ef					endif 
14ef					; with the pointer to the menu it, the byte following the zero term is the file id 
14ef			 
14ef 3e 00				ld a, 0 
14f1 01 32 00				ld bc, 50   ; max of bytes to look at 
14f4 ed b1				cpir  
14f6			 
14f6					if DEBUG_FORTH_WORDS 
14f6						DMARK "ALb" 
14f6 f5				push af  
14f7 3a 0b 15			ld a, (.dmark)  
14fa 32 6e fb			ld (debug_mark),a  
14fd 3a 0c 15			ld a, (.dmark+1)  
1500 32 6f fb			ld (debug_mark+1),a  
1503 3a 0d 15			ld a, (.dmark+2)  
1506 32 70 fb			ld (debug_mark+2),a  
1509 18 03			jr .pastdmark  
150b ..			.dmark: db "ALb"  
150e f1			.pastdmark: pop af  
150f			endm  
# End of macro DMARK
150f						CALLMONITOR 
150f cd 84 17			call break_point_state  
1512				endm  
# End of macro CALLMONITOR
1512					endif 
1512					;inc hl 
1512			 
1512 7e					ld a, (hl)   ; file id 
1513					 
1513				        ; save bank and file ids 
1513			 
1513 f5					push af 
1514			 
1514			; TODO need to save to block 0 on bank 1	 
1514			 
1514 cd 6c 04				call storage_get_block_0 
1517			 
1517					if DEBUG_FORTH_WORDS 
1517						DMARK "AL0" 
1517 f5				push af  
1518 3a 2c 15			ld a, (.dmark)  
151b 32 6e fb			ld (debug_mark),a  
151e 3a 2d 15			ld a, (.dmark+1)  
1521 32 6f fb			ld (debug_mark+1),a  
1524 3a 2e 15			ld a, (.dmark+2)  
1527 32 70 fb			ld (debug_mark+2),a  
152a 18 03			jr .pastdmark  
152c ..			.dmark: db "AL0"  
152f f1			.pastdmark: pop af  
1530			endm  
# End of macro DMARK
1530						CALLMONITOR 
1530 cd 84 17			call break_point_state  
1533				endm  
# End of macro CALLMONITOR
1533					endif 
1533 f1					pop af 
1534			 
1534 32 7d f8				ld (store_page+STORE_0_FILERUN),a 
1537					 
1537					; save bank id 
1537			 
1537 3a 3f f8				ld a,(spi_device) 
153a 32 7c f8				ld (store_page+STORE_0_BANKRUN),a 
153d			 
153d					; enable auto run of store file 
153d			 
153d 3e 01				ld a, 1 
153f 32 7a f8				ld (store_page+STORE_0_AUTOFILE),a 
1542			 
1542					; save buffer 
1542			 
1542 21 00 00				ld hl, 0 
1545 11 59 f8				ld de, store_page 
1548					if DEBUG_FORTH_WORDS 
1548						DMARK "ALw" 
1548 f5				push af  
1549 3a 5d 15			ld a, (.dmark)  
154c 32 6e fb			ld (debug_mark),a  
154f 3a 5e 15			ld a, (.dmark+1)  
1552 32 6f fb			ld (debug_mark+1),a  
1555 3a 5f 15			ld a, (.dmark+2)  
1558 32 70 fb			ld (debug_mark+2),a  
155b 18 03			jr .pastdmark  
155d ..			.dmark: db "ALw"  
1560 f1			.pastdmark: pop af  
1561			endm  
# End of macro DMARK
1561						CALLMONITOR 
1561 cd 84 17			call break_point_state  
1564				endm  
# End of macro CALLMONITOR
1564					endif 
1564 cd 20 04			call storage_write_block	 ; save update 
1567			  
1567			 
1567			 
1567			 
1567 21 14 ee				ld hl, scratch 
156a cd 82 15				call config_fdir 
156d			 
156d				else 
156d			 
156d				ld hl, prom_notav 
156d				ld de, prom_empty 
156d				call info_panel 
156d			 
156d				endif 
156d c9				ret 
156e			 
156e			 
156e			 
156e			; Select storage bank 
156e			 
156e			.selbank: 
156e			 
156e				if STORAGE_SE 
156e				else 
156e			 
156e				ld hl, prom_notav 
156e				ld de, prom_empty 
156e				call info_panel 
156e				endif 
156e				 
156e c9				ret 
156f			 
156f			if STORAGE_SE 
156f			 
156f			.config_ldir:   
156f				; Load storage bank labels into menu array 
156f			 
156f				 
156f			 
156f			 
156f c9				ret 
1570			 
1570			 
1570			endif 
1570			 
1570			 
1570			; Save user words to storage 
1570			 
1570			.savetostore: 
1570			 
1570				if STORAGE_SE 
1570			 
1570 cd 95 15				call config_dir 
1573 21 14 ee			        ld hl, scratch 
1576 3e 00				ld a, 0 
1578 cd da 0b				call menu 
157b					 
157b 21 14 ee				ld hl, scratch 
157e cd 82 15				call config_fdir 
1581			 
1581				else 
1581			 
1581				ld hl, prom_notav 
1581				ld de, prom_empty 
1581				call info_panel 
1581			 
1581				endif 
1581			 
1581 c9				ret 
1582			 
1582			 
1582			 
1582			if STORAGE_SE 
1582			 
1582			config_fdir: 
1582				; using the scratch dir go through and release the memory allocated for each string 
1582				 
1582 21 14 ee			ld hl, scratch 
1585 5e			.cfdir:	ld e,(hl) 
1586 23				inc hl 
1587 56				ld d,(hl) 
1588 23				inc hl 
1589			 
1589 eb				ex de, hl 
158a cd 06 0e			call ishlzero 
158d c8				ret z     ; return on null pointer 
158e cd 6e 13			call free 
1591 eb				ex de, hl 
1592 18 f1			jr .cfdir 
1594			 
1594			 
1594 c9				ret 
1595			 
1595			 
1595			config_dir: 
1595			 
1595				; for the config menus that need to build a directory of storage call this routine 
1595				; it will construct a menu in scratch to pass to menu 
1595			 
1595				; open storage device 
1595			 
1595				; execute DIR to build a list of files and their ids into scratch in menu format 
1595				; once the menu has finished then will need to call config_fdir to release the strings 
1595				 
1595				; c = number items 
1595			 
1595				 
1595 cd 6c 04			call storage_get_block_0 
1598			 
1598 21 59 f8			ld hl, store_page     ; get current id count 
159b 46				ld b, (hl) 
159c 0e 00			ld c, 0    ; count of files   
159e			 
159e			 
159e 21 14 ee			ld hl, scratch 
15a1 22 55 f8			ld (store_tmp2), hl    ; location to poke strings 
15a4			 
15a4				; check for empty drive 
15a4			 
15a4 3e 00			ld a, 0 
15a6 b8				cp b 
15a7 ca 41 16			jp z, .dirdone 
15aa			 
15aa				 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "Cdc" 
15aa f5				push af  
15ab 3a bf 15			ld a, (.dmark)  
15ae 32 6e fb			ld (debug_mark),a  
15b1 3a c0 15			ld a, (.dmark+1)  
15b4 32 6f fb			ld (debug_mark+1),a  
15b7 3a c1 15			ld a, (.dmark+2)  
15ba 32 70 fb			ld (debug_mark+2),a  
15bd 18 03			jr .pastdmark  
15bf ..			.dmark: db "Cdc"  
15c2 f1			.pastdmark: pop af  
15c3			endm  
# End of macro DMARK
15c3						CALLMONITOR 
15c3 cd 84 17			call break_point_state  
15c6				endm  
# End of macro CALLMONITOR
15c6					endif 
15c6			 
15c6			 
15c6			.diritem:	 
15c6 c5				push bc 
15c7				; for each of the current ids do a search for them and if found push to stack 
15c7			 
15c7 21 40 00				ld hl, STORE_BLOCK_PHY 
15ca 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
15cc 58					ld e,b 
15cd			 
15cd cd ee 06				call storage_findnextid 
15d0			 
15d0			 
15d0					; if found hl will be non zero 
15d0			 
15d0 cd 06 0e				call ishlzero 
15d3 28 69				jr z, .dirnotfound 
15d5			 
15d5					; increase count 
15d5			 
15d5 c1					pop bc	 
15d6 0c					inc c 
15d7 c5					push bc 
15d8					 
15d8			 
15d8					; get file header and push the file name 
15d8			 
15d8 11 59 f8				ld de, store_page 
15db cd bb 03				call storage_read_block 
15de			 
15de					; push file id to stack 
15de				 
15de 3a 59 f8				ld a, (store_page) 
15e1 26 00				ld h, 0 
15e3 6f					ld l, a 
15e4			 
15e4					;call forth_push_numhl 
15e4					; TODO store id 
15e4			 
15e4 e5					push hl 
15e5			 
15e5					; push extent count to stack  
15e5				 
15e5 21 5c f8				ld hl, store_page+3 
15e8			 
15e8					; get file name length 
15e8			 
15e8 cd 3b 12				call strlenz   
15eb			 
15eb 23					inc hl   ; cover zero term 
15ec 23					inc hl  ; stick the id at the end of the area 
15ed			 
15ed e5					push hl 
15ee c1					pop bc    ; move length to bc 
15ef			 
15ef cd a4 12				call malloc 
15f2			 
15f2					; TODO save malloc area to scratch 
15f2			 
15f2 eb					ex de, hl 
15f3 2a 55 f8				ld hl, (store_tmp2) 
15f6 73					ld (hl), e 
15f7 23					inc hl 
15f8 72					ld (hl), d 
15f9 23					inc hl 
15fa 22 55 f8				ld (store_tmp2), hl 
15fd			 
15fd					 
15fd			 
15fd					;pop hl   ; get source 
15fd			;		ex de, hl    ; swap aronund	 
15fd			 
15fd 21 5c f8				ld hl, store_page+3 
1600					if DEBUG_FORTH_WORDS 
1600						DMARK "CFd" 
1600 f5				push af  
1601 3a 15 16			ld a, (.dmark)  
1604 32 6e fb			ld (debug_mark),a  
1607 3a 16 16			ld a, (.dmark+1)  
160a 32 6f fb			ld (debug_mark+1),a  
160d 3a 17 16			ld a, (.dmark+2)  
1610 32 70 fb			ld (debug_mark+2),a  
1613 18 03			jr .pastdmark  
1615 ..			.dmark: db "CFd"  
1618 f1			.pastdmark: pop af  
1619			endm  
# End of macro DMARK
1619						CALLMONITOR 
1619 cd 84 17			call break_point_state  
161c				endm  
# End of macro CALLMONITOR
161c					endif 
161c ed b0				ldir 
161e			 
161e					; de is past string, move back one and store id 
161e					 
161e 1b					dec de 
161f			 
161f					; store file id 
161f			 
161f e1					pop hl 
1620 eb					ex de,hl 
1621 73					ld (hl), e 
1622			 
1622					if DEBUG_FORTH_WORDS 
1622						DMARK "Cdi" 
1622 f5				push af  
1623 3a 37 16			ld a, (.dmark)  
1626 32 6e fb			ld (debug_mark),a  
1629 3a 38 16			ld a, (.dmark+1)  
162c 32 6f fb			ld (debug_mark+1),a  
162f 3a 39 16			ld a, (.dmark+2)  
1632 32 70 fb			ld (debug_mark+2),a  
1635 18 03			jr .pastdmark  
1637 ..			.dmark: db "Cdi"  
163a f1			.pastdmark: pop af  
163b			endm  
# End of macro DMARK
163b						CALLMONITOR 
163b cd 84 17			call break_point_state  
163e				endm  
# End of macro CALLMONITOR
163e					endif 
163e					 
163e			.dirnotfound: 
163e c1					pop bc     
163f 10 85				djnz .diritem 
1641				 
1641			.dirdone:	 
1641			 
1641 3e 00				ld a, 0 
1643 2a 55 f8				ld hl, (store_tmp2) 
1646 77					ld (hl), a 
1647 23					inc hl 
1648 77					ld (hl), a 
1649 23					inc hl 
164a					; push a count of the dir items found 
164a			 
164a			;		ld h, 0 
164a			;		ld l, c 
164a			 
164a c9				ret 
164b			 
164b			endif 
164b			 
164b			 
164b			; Settings 
164b			; Run  
164b			 
164b			 
164b			 
164b			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
164b			;;hd_menu2:   db "        2: Editor",0   
164b			;hd_menu2:   db "        2: Editor       6: Menu",0   
164b			;hd_menu3:   db "        3: Storage",0 
164b			;hd_menu4:   db "0=quit  4: Debug",0 
164b			;hd_don:     db "ON",0 
164b			;hd_doff:     db "OFF",0 
164b			; 
164b			; 
164b			; 
164b			;hardware_diags_old:       
164b			; 
164b			;.diagmenu: 
164b			;	call clear_display 
164b			;	ld a, display_row_1 
164b			;	ld de, hd_menu1 
164b			;	call str_at_display 
164b			; 
164b			;	ld a, display_row_2 
164b			;	ld de, hd_menu2 
164b			;	call str_at_display 
164b			; 
164b			;	ld a, display_row_3 
164b			;	ld de, hd_menu3 
164b			;	call str_at_display 
164b			; 
164b			;	ld a,  display_row_4 
164b			;	ld de, hd_menu4 
164b			;	call str_at_display 
164b			; 
164b			;	; display debug state 
164b			; 
164b			;	ld de, hd_don 
164b			;	ld a, (os_view_disable) 
164b			;	cp 0 
164b			;	jr z, .distog 
164b			;	ld de, hd_doff 
164b			;.distog: ld a, display_row_4+17 
164b			;	call str_at_display 
164b			; 
164b			;	call update_display 
164b			; 
164b			;	call cin_wait 
164b			; 
164b			; 
164b			; 
164b			;	cp '4' 
164b			;	jr nz, .diagn1 
164b			; 
164b			;	; debug toggle 
164b			; 
164b			;	ld a, (os_view_disable) 
164b			;	ld b, '*' 
164b			;	cp 0 
164b			;	jr z, .debtog 
164b			;	ld b, 0 
164b			;.debtog:	 
164b			;	ld a,b 
164b			;	ld (os_view_disable),a 
164b			; 
164b			;.diagn1: cp '0' 
164b			;	 ret z 
164b			; 
164b			;;	cp '1' 
164b			;;       jp z, matrix	 
164b			;;   TODO keyboard matrix test 
164b			; 
164b			;	cp '2' 
164b			;	jp z, .diagedit 
164b			; 
164b			;;	cp '6' 
164b			;;	jp z, .menutest 
164b			;;if ENABLE_BASIC 
164b			;;	cp '6' 
164b			;;	jp z, basic 
164b			;;endif 
164b			 ; 
164b			;	jp .diagmenu 
164b			; 
164b			; 
164b			;	ret 
164b			 
164b			 
164b			.debug_tog: 
164b 21 92 16			ld hl, .menudebug 
164e				 
164e 3a 05 ee			ld a, (os_view_disable) 
1651 fe 2a			cp '*' 
1653 20 04			jr nz,.tdon  
1655 3e 01			ld a, 1 
1657 18 02			jr .tog1 
1659 3e 00		.tdon: ld a, 0 
165b			 
165b			.tog1: 
165b cd da 0b			call menu 
165e fe 00			cp 0 
1660 c8				ret z 
1661 fe 01			cp 1    ; disable debug 
1663 28 04			jr z, .dtog0 
1665 3e 2a			ld a, '*' 
1667 18 02			jr .dtogset 
1669 3e 00		.dtog0: ld a, 0 
166b 32 05 ee		.dtogset:  ld (os_view_disable), a 
166e c3 4b 16			jp .debug_tog 
1671			 
1671			 
1671			hardware_diags:       
1671			 
1671			.diagm: 
1671 21 84 16			ld hl, .menuitems 
1674 3e 00			ld a, 0 
1676 cd da 0b			call menu 
1679			 
1679 fe 00		         cp 0 
167b c8				 ret z 
167c			 
167c fe 02			cp 2 
167e ca dd 16			jp z, .diagedit 
1681			 
1681			;	cp '6' 
1681			;	jp z, .menutest 
1681			;if ENABLE_BASIC 
1681			;	cp '6' 
1681			;	jp z, basic 
1681			;endif 
1681			  
1681 c3 71 16			jp .diagm 
1684			 
1684				 
1684 98 16		.menuitems:   	dw .m1 
1686 a3 16				dw .m2 
1688 aa 16				dw .m3 
168a b2 16				dw .m5 
168c b8 16				dw .m5a 
168e c1 16				dw .m5b 
1690 00 00				dw 0 
1692			 
1692			.menudebug: 
1692 ca 16				dw .m6 
1694 d3 16				dw .m7 
1696 00 00				dw 0 
1698			 
1698 .. 00		.m1:   db "Key Matrix",0 
16a3 .. 00		.m2:   db "Editor",0 
16aa .. 00		.m3:   db "Storage",0 
16b2 .. 00		.m5:   db "Sound",0 
16b8 .. 00		.m5a:  db "RAM Test",0 
16c1 .. 00		.m5b:  db "LCD Test",0 
16ca			 
16ca .. 00		.m6:   db "Debug ON",0 
16d3 .. 00		.m7:   db "Debug OFF",0 
16dd			 
16dd			; debug editor 
16dd			 
16dd			.diagedit: 
16dd			 
16dd 21 14 ee			ld hl, scratch 
16e0			;	ld bc, 250 
16e0			;	ldir 
16e0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16e0 3e 00			ld a, 0 
16e2 77				ld (hl), a 
16e3 23				inc hl 
16e4 77				ld (hl), a 
16e5 23				inc hl 
16e6 77				ld (hl), a 
16e7			 
16e7 cd a9 0b		        call clear_display 
16ea cd cc 0b			call update_display 
16ed				;ld a, 1 
16ed				;ld (hardware_diag), a 
16ed			.diloop: 
16ed 3e 00			ld a, display_row_1 
16ef 0e 00			ld c, 0 
16f1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16f3 1e 28			ld e, 40 
16f5			 
16f5 21 14 ee			ld hl, scratch	 
16f8 cd 0a 0e			call input_str 
16fb			 
16fb 3e 28			ld a, display_row_2 
16fd 11 14 ee			ld de, scratch 
1700 cd bc 0b			call str_at_display 
1703 cd cc 0b			call update_display 
1706			 
1706 c3 ed 16			jp .diloop 
1709			 
1709			 
1709			; pass word in hl 
1709			; a has display location 
1709			display_word_at: 
1709 f5				push af 
170a e5				push hl 
170b 7c				ld a,h 
170c 21 19 f1			ld hl, os_word_scratch 
170f cd de 10			call hexout 
1712 e1				pop hl 
1713 7d				ld a,l 
1714 21 1b f1			ld hl, os_word_scratch+2 
1717 cd de 10			call hexout 
171a 21 1d f1			ld hl, os_word_scratch+4 
171d 3e 00			ld a,0 
171f 77				ld (hl),a 
1720 11 19 f1			ld de,os_word_scratch 
1723 f1				pop af 
1724 cd bc 0b				call str_at_display 
1727 c9				ret 
1728			 
1728			display_ptr_state: 
1728			 
1728				; to restore afterwards 
1728			 
1728 d5				push de 
1729 c5				push bc 
172a e5				push hl 
172b f5				push af 
172c			 
172c				; for use in here 
172c			 
172c			;	push bc 
172c			;	push de 
172c			;	push hl 
172c			;	push af 
172c			 
172c cd a9 0b			call clear_display 
172f			 
172f 11 02 19			ld de, .ptrstate 
1732 3e 00			ld a, display_row_1 
1734 cd bc 0b			call str_at_display 
1737			 
1737				; display debug step 
1737			 
1737			 
1737 11 6e fb			ld de, debug_mark 
173a 3e 26			ld a, display_row_1+display_cols-2 
173c cd bc 0b			call str_at_display 
173f			 
173f				; display a 
173f 11 0c 19			ld de, .ptrcliptr 
1742 3e 28			ld a, display_row_2 
1744 cd bc 0b			call str_at_display 
1747			 
1747 f1				pop af 
1748 2a 1f f8			ld hl,(cli_ptr) 
174b 3e 30			ld a, display_row_2+8 
174d cd 09 17			call display_word_at 
1750			 
1750			 
1750				; display hl 
1750			 
1750			 
1750 11 14 19			ld de, .ptrclioptr 
1753 3e 32			ld a, display_row_2+10 
1755 cd bc 0b			call str_at_display 
1758			; 
1758			;	pop hl 
1758 3e 35			ld a, display_row_2+13 
175a 2a 1d f8			ld hl,(cli_origptr) 
175d cd 09 17			call display_word_at 
1760			; 
1760			;	 
1760			;	; display de 
1760			 
1760			;	ld de, .regstatede 
1760			;	ld a, display_row_3 
1760			;	call str_at_display 
1760			 
1760			;	pop de 
1760			;	ld h,d 
1760			;	ld l, e 
1760			;	ld a, display_row_3+3 
1760			;	call display_word_at 
1760			 
1760			 
1760				; display bc 
1760			 
1760			;	ld de, .regstatebc 
1760			;	ld a, display_row_3+10 
1760			;	call str_at_display 
1760			 
1760			;	pop bc 
1760			;	ld h,b 
1760			;	ld l, c 
1760			;	ld a, display_row_3+13 
1760			;	call display_word_at 
1760			 
1760			 
1760				; display dsp 
1760			 
1760			;	ld de, .regstatedsp 
1760			;	ld a, display_row_4 
1760			;	call str_at_display 
1760			 
1760				 
1760			;	ld hl,(cli_data_sp) 
1760			;	ld a, display_row_4+4 
1760			;	call display_word_at 
1760			 
1760				; display rsp 
1760			 
1760 11 43 19			ld de, .regstatersp 
1763 3e 82			ld a, display_row_4+10 
1765 cd bc 0b			call str_at_display 
1768			 
1768				 
1768 2a 05 f8			ld hl,(cli_ret_sp) 
176b 3e 86			ld a, display_row_4+14 
176d cd 09 17			call display_word_at 
1770			 
1770 cd cc 0b			call update_display 
1773			 
1773 cd 26 0b			call delay1s 
1776 cd 26 0b			call delay1s 
1779 cd 26 0b			call delay1s 
177c			 
177c			 
177c cd 59 1d			call next_page_prompt 
177f			 
177f				; restore  
177f			 
177f f1				pop af 
1780 e1				pop hl 
1781 c1				pop bc 
1782 d1				pop de 
1783 c9				ret 
1784			 
1784			break_point_state: 
1784 f5				push af 
1785			 
1785				; see if disabled 
1785			 
1785 3a 05 ee			ld a, (os_view_disable) 
1788 fe 2a			cp '*' 
178a 20 02			jr nz, .bpsgo 
178c f1				pop af 
178d c9				ret 
178e			 
178e			.bpsgo: 
178e f1				pop af 
178f f5				push af 
1790 22 01 ee			ld (os_view_hl), hl 
1793 ed 53 ff ed		ld (os_view_de), de 
1797 ed 43 fd ed		ld (os_view_bc), bc 
179b e5				push hl 
179c 6f				ld l, a 
179d 26 00			ld h, 0 
179f 22 03 ee			ld (os_view_af),hl 
17a2			 
17a2 21 b4 fa				ld hl, display_fb0 
17a5 22 cf f8				ld (display_fb_active), hl 
17a8 e1				pop hl	 
17a9			 
17a9 3e 31			ld a, '1' 
17ab fe 2a		.bps1:  cp '*' 
17ad 20 03			jr nz, .bps1b 
17af 32 05 ee			ld (os_view_disable),a 
17b2 fe 31		.bps1b:  cp '1' 
17b4 20 14			jr nz, .bps2 
17b6			 
17b6				; display reg 
17b6			 
17b6				 
17b6			 
17b6 3a 03 ee			ld a, (os_view_af) 
17b9 2a 01 ee			ld hl, (os_view_hl) 
17bc ed 5b ff ed		ld de, (os_view_de) 
17c0 ed 4b fd ed		ld bc, (os_view_bc) 
17c4 cd 5e 18			call display_reg_state 
17c7 c3 4a 18			jp .bpschk 
17ca			 
17ca fe 32		.bps2:  cp '2' 
17cc 20 08			jr nz, .bps3 
17ce				 
17ce				; display hl 
17ce 2a 01 ee			ld hl, (os_view_hl) 
17d1 cd 48 19			call display_dump_at_hl 
17d4			 
17d4 18 74			jr .bpschk 
17d6			 
17d6 fe 33		.bps3:  cp '3' 
17d8 20 08			jr nz, .bps4 
17da			 
17da			        ; display de 
17da 2a ff ed			ld hl, (os_view_de) 
17dd cd 48 19			call display_dump_at_hl 
17e0			 
17e0 18 68			jr .bpschk 
17e2 fe 34		.bps4:  cp '4' 
17e4 20 08			jr nz, .bps5 
17e6			 
17e6			        ; display bc 
17e6 2a fd ed			ld hl, (os_view_bc) 
17e9 cd 48 19			call display_dump_at_hl 
17ec			 
17ec 18 5c			jr .bpschk 
17ee fe 35		.bps5:  cp '5' 
17f0 20 08		        jr nz, .bps7 
17f2			 
17f2				; display cur ptr 
17f2 2a 1f f8			ld hl, (cli_ptr) 
17f5 cd 48 19			call display_dump_at_hl 
17f8			 
17f8 18 50			jr .bpschk 
17fa fe 36		.bps7:  cp '6' 
17fc 20 08			jr nz, .bps8b 
17fe				 
17fe				; display cur orig ptr 
17fe 2a 1d f8			ld hl, (cli_origptr) 
1801 cd 48 19			call display_dump_at_hl 
1804 18 44			jr .bpschk 
1806 fe 37		.bps8b:  cp '7' 
1808 20 08			jr nz, .bps9 
180a				 
180a				; display dsp 
180a 2a 01 f8			ld hl, (cli_data_sp) 
180d cd 48 19			call display_dump_at_hl 
1810			 
1810 18 38			jr .bpschk 
1812 fe 39		.bps9:  cp '9' 
1814 20 05			jr nz, .bps8c 
1816				 
1816				; display SP 
1816			;	ld hl, sp 
1816 cd 48 19			call display_dump_at_hl 
1819			 
1819 18 2f			jr .bpschk 
181b fe 38		.bps8c:  cp '8' 
181d 20 08			jr nz, .bps8d 
181f				 
181f				; display rsp 
181f 2a 05 f8			ld hl, (cli_ret_sp) 
1822 cd 48 19			call display_dump_at_hl 
1825			 
1825 18 23			jr .bpschk 
1827 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1829 20 05			jr nz, .bps8 
182b cd 4f 1b			call monitor 
182e			 
182e 18 1a			jr .bpschk 
1830 fe 30		.bps8:  cp '0' 
1832 20 16			jr nz, .bpschk 
1834			 
1834 21 13 fa				ld hl, display_fb1 
1837 22 cf f8				ld (display_fb_active), hl 
183a cd cc 0b				call update_display 
183d			 
183d				;ld a, (os_view_af) 
183d 2a 01 ee			ld hl, (os_view_hl) 
1840 ed 5b ff ed		ld de, (os_view_de) 
1844 ed 4b fd ed		ld bc, (os_view_bc) 
1848 f1				pop af 
1849 c9				ret 
184a			 
184a			.bpschk:   
184a cd 26 0b			call delay1s 
184d 3e 9f		ld a,display_row_4 + display_cols - 1 
184f 11 57 1d		        ld de, endprg 
1852 cd bc 0b			call str_at_display 
1855 cd cc 0b			call update_display 
1858 cd 19 6b			call cin_wait 
185b			 
185b c3 ab 17			jp .bps1 
185e			 
185e			 
185e			display_reg_state: 
185e			 
185e				; to restore afterwards 
185e			 
185e d5				push de 
185f c5				push bc 
1860 e5				push hl 
1861 f5				push af 
1862			 
1862				; for use in here 
1862			 
1862 c5				push bc 
1863 d5				push de 
1864 e5				push hl 
1865 f5				push af 
1866			 
1866 cd a9 0b			call clear_display 
1869			 
1869 11 1e 19			ld de, .regstate 
186c 3e 00			ld a, display_row_1 
186e cd bc 0b			call str_at_display 
1871			 
1871				; display debug step 
1871			 
1871			 
1871 11 6e fb			ld de, debug_mark 
1874 3e 25			ld a, display_row_1+display_cols-3 
1876 cd bc 0b			call str_at_display 
1879			 
1879				; display a 
1879 11 3a 19			ld de, .regstatea 
187c 3e 28			ld a, display_row_2 
187e cd bc 0b			call str_at_display 
1881			 
1881 e1				pop hl 
1882			;	ld h,0 
1882			;	ld l, a 
1882 3e 2b			ld a, display_row_2+3 
1884 cd 09 17			call display_word_at 
1887			 
1887			 
1887				; display hl 
1887			 
1887			 
1887 11 2e 19			ld de, .regstatehl 
188a 3e 32			ld a, display_row_2+10 
188c cd bc 0b			call str_at_display 
188f			 
188f e1				pop hl 
1890 3e 35			ld a, display_row_2+13 
1892 cd 09 17			call display_word_at 
1895			 
1895				 
1895				; display de 
1895			 
1895 11 32 19			ld de, .regstatede 
1898 3e 50			ld a, display_row_3 
189a cd bc 0b			call str_at_display 
189d			 
189d e1				pop hl 
189e			;	ld h,d 
189e			;	ld l, e 
189e 3e 53			ld a, display_row_3+3 
18a0 cd 09 17			call display_word_at 
18a3			 
18a3			 
18a3				; display bc 
18a3			 
18a3 11 36 19			ld de, .regstatebc 
18a6 3e 5a			ld a, display_row_3+10 
18a8 cd bc 0b			call str_at_display 
18ab			 
18ab e1				pop hl 
18ac			;	ld h,b 
18ac			;	ld l, c 
18ac 3e 5d			ld a, display_row_3+13 
18ae cd 09 17			call display_word_at 
18b1			 
18b1			 
18b1				; display dsp 
18b1			 
18b1 11 3e 19			ld de, .regstatedsp 
18b4 3e 78			ld a, display_row_4 
18b6 cd bc 0b			call str_at_display 
18b9			 
18b9				 
18b9 2a 01 f8			ld hl,(cli_data_sp) 
18bc 3e 7c			ld a, display_row_4+4 
18be cd 09 17			call display_word_at 
18c1			 
18c1				; display rsp 
18c1			 
18c1 11 43 19			ld de, .regstatersp 
18c4 3e 82			ld a, display_row_4+10 
18c6 cd bc 0b			call str_at_display 
18c9			 
18c9				 
18c9 2a 05 f8			ld hl,(cli_ret_sp) 
18cc 3e 86			ld a, display_row_4+14 
18ce cd 09 17			call display_word_at 
18d1			 
18d1 cd cc 0b			call update_display 
18d4			 
18d4			;	call delay1s 
18d4			;	call delay1s 
18d4			;	call delay1s 
18d4			 
18d4			 
18d4			;	call next_page_prompt 
18d4			 
18d4				; restore  
18d4			 
18d4 f1				pop af 
18d5 e1				pop hl 
18d6 c1				pop bc 
18d7 d1				pop de 
18d8 c9				ret 
18d9			 
18d9 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18ed .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1902 .. 00		.ptrstate:	db "Ptr State",0 
190c .. 00		.ptrcliptr:     db "cli_ptr",0 
1914 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
191e .. 00		.regstate:	db "Reg State (1/0)",0 
192e .. 00		.regstatehl:	db "HL:",0 
1932 .. 00		.regstatede:	db "DE:",0 
1936 .. 00		.regstatebc:	db "BC:",0 
193a .. 00		.regstatea:	db "A :",0 
193e .. 00		.regstatedsp:	db "DSP:",0 
1943 .. 00		.regstatersp:	db "RSP:",0 
1948			 
1948			display_dump_at_hl: 
1948 e5				push hl 
1949 d5				push de 
194a c5				push bc 
194b f5				push af 
194c			 
194c 22 37 f1			ld (os_cur_ptr),hl	 
194f cd a9 0b			call clear_display 
1952 cd 61 1c			call dumpcont 
1955			;	call delay1s 
1955			;	call next_page_prompt 
1955			 
1955			 
1955 f1				pop af 
1956 c1				pop bc 
1957 d1				pop de 
1958 e1				pop hl 
1959 c9				ret 
195a			 
195a			;if ENABLE_BASIC 
195a			;	include "nascombasic.asm" 
195a			;	basic: 
195a			;	include "forth/FORTH.ASM" 
195a			;endif 
195a			 
195a			; eof 
195a			 
195a			 
# End of file firmware_diags.asm
195a			  
195a			include "firmware_prompts.asm"  
195a			; Prompts  
195a			 
195a			; boot messages 
195a			 
195a .. 00		prom_bootmsg:	db "z80-homebrew OS v1.5",0 
196f .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
197f			 
197f			 
197f			; config menus 
197f			 
197f .. 00		prom_c3: db "Add Dictionary To File",0 
1996 .. 00		prom_c2: db "Select Autoload File",0 
19ab .. 00		prom_c2a: db "Disable Autoload File", 0 
19c1 .. 00		prom_c2b: db "Select Storage Bank",0 
19d5 .. 00		prom_c4: db "Settings",0 
19de .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
19f9 .. 00		prom_m4b:   db "Monitor",0 
1a01 .. 00		prom_c1: db "Hardware Diags",0 
1a10			 
1a10			 
1a10 .. 00		prom_notav:    db "Feature not available",0 
1a26 .. 00		prom_empty:    db "",0 
1a27			 
1a27			; eof 
1a27			 
# End of file firmware_prompts.asm
1a27			  
1a27			  
1a27			; eof  
1a27			  
# End of file firmware.asm
1a27			 
1a27			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1a27			;if BASE_KEV  
1a27			;baseram: equ 08000h 
1a27			;endif 
1a27			 
1a27			;if BASE_SC114 
1a27			;baseram:     equ    endofcode 
1a27			;endif 
1a27			 
1a27			 
1a27			; start system 
1a27			 
1a27			coldstart: 
1a27				; set sp 
1a27				; di/ei 
1a27			 
1a27 f3				di 
1a28 31 fd ff			ld sp, tos 
1a2b			;	ei 
1a2b			 
1a2b			 
1a2b				; disable breakpoint by default 
1a2b			 
1a2b 3e 2a			ld a,'*' 
1a2d 32 05 ee			ld (os_view_disable),a 
1a30			 
1a30				; init hardware 
1a30			 
1a30				; init keyboard and screen hardware 
1a30			 
1a30 cd 03 00			call hardware_init 
1a33			 
1a33			 
1a33				; detect if any keys are held down to enable breakpoints at start up 
1a33			 
1a33 cd 2a 6b			call cin  
1a36 fe 00			cp 0 
1a38 28 03			jr z, .nokeys 
1a3a			 
1a3a				;call hardware_diags 
1a3a cd 67 14			call config 
1a3d			 
1a3d			;	ld de, .bpen 
1a3d			;	ld a, display_row_4 
1a3d			;	call str_at_display 
1a3d			;	call update_display 
1a3d			; 
1a3d			;	ld a,0 
1a3d			;	ld (os_view_disable),a 
1a3d			; 
1a3d			;.bpwait: 
1a3d			;	call cin 
1a3d			;	cp 0 
1a3d			;	jr z, .bpwait 
1a3d			;	jr .nokeys 
1a3d			; 
1a3d			; 
1a3d			;.bpen:  db "Break points enabled!",0 
1a3d			 
1a3d			 
1a3d			 
1a3d			 
1a3d			 
1a3d			 
1a3d			.nokeys: 
1a3d			 
1a3d			 
1a3d				 
1a3d			 
1a3d			;jp  testkey 
1a3d			 
1a3d			;call storage_get_block_0 
1a3d			; 
1a3d			;ld hl, 0 
1a3d			;ld de, store_page 
1a3d			;call storage_read_block 
1a3d			 
1a3d				 
1a3d			;ld hl, 10 
1a3d			;ld de, store_page 
1a3d			;call storage_read_block 
1a3d			 
1a3d			 
1a3d			 
1a3d			 
1a3d			 
1a3d			;stop:	nop 
1a3d			;	jp stop 
1a3d			 
1a3d			 
1a3d			 
1a3d			main: 
1a3d cd a9 0b			call clear_display 
1a40 cd cc 0b			call update_display 
1a43			 
1a43			 
1a43			 
1a43			;	call testlcd 
1a43			 
1a43			 
1a43			 
1a43 cd 1f 21			call forth_init 
1a46			 
1a46			 
1a46			warmstart: 
1a46 cd f5 20			call forth_warmstart 
1a49			 
1a49				; run startup word load 
1a49			        ; TODO prevent this running at warmstart after crash  
1a49			 
1a49				if STARTUP_ENABLE 
1a49					if STORAGE_SE 
1a49 cd b8 66					call forth_autoload 
1a4c					endif 
1a4c cd c7 63				call forth_startup 
1a4f			 
1a4f			 
1a4f				endif 
1a4f			 
1a4f				; show free memory after boot 
1a4f 11 e9 1a			ld de, freeram 
1a52 3e 00			ld a, display_row_1 
1a54 cd bc 0b			call str_at_display 
1a57			 
1a57			; Or use heap_size word???? 
1a57 21 fa ed			ld hl, heap_end 
1a5a 11 0e 80			ld de, heap_start 
1a5d ed 52			sbc hl, de 
1a5f e5				push hl 
1a60 7c				ld a,h	         	 
1a61 21 19 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a64 cd de 10			call hexout 
1a67 e1			   	pop hl 
1a68			 
1a68 7d				ld a,l 
1a69 21 1b f1			ld hl, os_word_scratch+2 
1a6c cd de 10			call hexout 
1a6f 21 1d f1			ld hl, os_word_scratch+4 
1a72 3e 00			ld a, 0 
1a74 77				ld (hl),a 
1a75 11 19 f1			ld de, os_word_scratch 
1a78 3e 0d			ld a, display_row_1 + 13 
1a7a cd bc 0b			call str_at_display 
1a7d cd cc 0b			call update_display 
1a80			 
1a80			 
1a80				;call demo 
1a80			 
1a80			 
1a80				; init scratch input area for cli commands 
1a80			 
1a80 21 3b f1			ld hl, os_cli_cmd 
1a83 3e 00			ld a,0 
1a85 77				ld (hl),a 
1a86 23				inc hl 
1a87 77				ld (hl),a 
1a88			 
1a88 3e 00			ld a,0 
1a8a 32 3a f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1a8d			 
1a8d 32 37 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1a90 32 38 f1			ld (os_cur_ptr+1),a	 
1a93			 
1a93 32 19 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1a96 32 1a f1			ld (os_word_scratch+1),a	 
1a99				 
1a99			 
1a99				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a99 21 3b f1			ld hl, os_cli_cmd 
1a9c			 
1a9c 3e 00			ld a, 0		 ; init cli input 
1a9e 77				ld (hl), a 
1a9f 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1aa1			cli: 
1aa1				; show cli prompt 
1aa1				;push af 
1aa1				;ld a, 0 
1aa1				;ld de, prompt 
1aa1				;call str_at_display 
1aa1			 
1aa1				;call update_display 
1aa1				;pop af 
1aa1				;inc a 
1aa1				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1aa1 0e 00			ld c, 0 
1aa3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1aa5 1e 28			ld e, 40 
1aa7			 
1aa7 21 3b f1			ld hl, os_cli_cmd 
1aaa			 
1aaa				STACKFRAME OFF $fefe $9f9f 
1aaa				if DEBUG_STACK_IMB 
1aaa					if OFF 
1aaa						exx 
1aaa						ld de, $fefe 
1aaa						ld a, d 
1aaa						ld hl, curframe 
1aaa						call hexout 
1aaa						ld a, e 
1aaa						ld hl, curframe+2 
1aaa						call hexout 
1aaa						ld hl, $fefe 
1aaa						push hl 
1aaa						ld hl, $9f9f 
1aaa						push hl 
1aaa						exx 
1aaa					endif 
1aaa				endif 
1aaa			endm 
# End of macro STACKFRAME
1aaa			 
1aaa cd 0a 0e			call input_str 
1aad			 
1aad				STACKFRAMECHK OFF $fefe $9f9f 
1aad				if DEBUG_STACK_IMB 
1aad					if OFF 
1aad						exx 
1aad						ld hl, $9f9f 
1aad						pop de   ; $9f9f 
1aad						call cmp16 
1aad						jr nz, .spnosame 
1aad						ld hl, $fefe 
1aad						pop de   ; $fefe 
1aad						call cmp16 
1aad						jr z, .spfrsame 
1aad						.spnosame: call showsperror 
1aad						.spfrsame: nop 
1aad						exx 
1aad					endif 
1aad				endif 
1aad			endm 
# End of macro STACKFRAMECHK
1aad			 
1aad				; copy input to last command 
1aad			 
1aad 21 3b f1			ld hl, os_cli_cmd 
1ab0 11 3a f2			ld de, os_last_cmd 
1ab3 01 ff 00			ld bc, 255 
1ab6 ed b0			ldir 
1ab8			 
1ab8				; wipe current buffer 
1ab8			 
1ab8			;	ld a, 0 
1ab8			;	ld hl, os_cli_cmd 
1ab8			;	ld de, os_cli_cmd+1 
1ab8			;	ld bc, 254 
1ab8			;	ldir 
1ab8				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ab8			;	call strcpy 
1ab8			;	ld a, 0 
1ab8			;	ld (hl), a 
1ab8			;	inc hl 
1ab8			;	ld (hl), a 
1ab8			;	inc hl 
1ab8			;	ld (hl), a 
1ab8			 
1ab8				; switch frame buffer to program  
1ab8			 
1ab8 21 13 fa				ld hl, display_fb1 
1abb 22 cf f8				ld (display_fb_active), hl 
1abe			 
1abe			;	nop 
1abe				STACKFRAME ON $fbfe $8f9f 
1abe				if DEBUG_STACK_IMB 
1abe					if ON 
1abe						exx 
1abe						ld de, $fbfe 
1abe						ld a, d 
1abe						ld hl, curframe 
1abe						call hexout 
1abe						ld a, e 
1abe						ld hl, curframe+2 
1abe						call hexout 
1abe						ld hl, $fbfe 
1abe						push hl 
1abe						ld hl, $8f9f 
1abe						push hl 
1abe						exx 
1abe					endif 
1abe				endif 
1abe			endm 
# End of macro STACKFRAME
1abe				; first time into the parser so pass over the current scratch pad 
1abe 21 3b f1			ld hl,os_cli_cmd 
1ac1				; tokenise the entered statement(s) in HL 
1ac1 cd 98 21			call forthparse 
1ac4			        ; exec forth statements in top of return stack 
1ac4 cd d8 21			call forthexec 
1ac7				;call forthexec_cleanup 
1ac7			;	call parsenext 
1ac7			 
1ac7				STACKFRAMECHK ON $fbfe $8f9f 
1ac7				if DEBUG_STACK_IMB 
1ac7					if ON 
1ac7						exx 
1ac7						ld hl, $8f9f 
1ac7						pop de   ; $8f9f 
1ac7						call cmp16 
1ac7						jr nz, .spnosame 
1ac7						ld hl, $fbfe 
1ac7						pop de   ; $fbfe 
1ac7						call cmp16 
1ac7						jr z, .spfrsame 
1ac7						.spnosame: call showsperror 
1ac7						.spfrsame: nop 
1ac7						exx 
1ac7					endif 
1ac7				endif 
1ac7			endm 
# End of macro STACKFRAMECHK
1ac7				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1ac7			 
1ac7 3e 78			ld a, display_row_4 
1ac9 11 fb 1a			ld de, endprog 
1acc			 
1acc cd cc 0b			call update_display		 
1acf			 
1acf cd 59 1d			call next_page_prompt 
1ad2			 
1ad2				; switch frame buffer to cli 
1ad2			 
1ad2 21 b4 fa				ld hl, display_fb0 
1ad5 22 cf f8				ld (display_fb_active), hl 
1ad8			 
1ad8			 
1ad8 cd a9 0b		        call clear_display 
1adb cd cc 0b			call update_display		 
1ade			 
1ade 21 3b f1			ld hl, os_cli_cmd 
1ae1			 
1ae1 3e 00			ld a, 0		 ; init cli input 
1ae3 77				ld (hl), a 
1ae4			 
1ae4				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1ae4			 
1ae4				; now on last line 
1ae4			 
1ae4				; TODO scroll screen up 
1ae4			 
1ae4				; TODO instead just clear screen and place at top of screen 
1ae4			 
1ae4			;	ld a, 0 
1ae4			;	ld (f_cursor_ptr),a 
1ae4			 
1ae4				;call clear_display 
1ae4				;call update_display 
1ae4			 
1ae4				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ae4 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ae6 c3 a1 1a			jp cli 
1ae9			 
1ae9 .. 00		freeram: db "Free bytes: $",0 
1af7 ..			asc: db "1A2F" 
1afb .. 00		endprog: db "End prog...",0 
1b07			 
1b07			testenter2:   
1b07 21 46 ee			ld hl,scratch+50 
1b0a 22 37 f1			ld (os_cur_ptr),hl 
1b0d c3 a1 1a			jp cli 
1b10			 
1b10			testenter:  
1b10			 
1b10 21 f7 1a			ld hl,asc 
1b13			;	ld a,(hl) 
1b13			;	call nibble2val 
1b13 cd 34 11			call get_byte 
1b16			 
1b16			 
1b16			;	ld a,(hl) 
1b16			;	call atohex 
1b16			 
1b16			;	call fourehexhl 
1b16 32 46 ee			ld (scratch+50),a 
1b19			 
1b19			 
1b19			 
1b19 21 f9 1a			ld hl,asc+2 
1b1c			;	ld a, (hl) 
1b1c			;	call nibble2val 
1b1c cd 34 11			call get_byte 
1b1f			 
1b1f			;	call fourehexhl 
1b1f 32 48 ee			ld (scratch+52),a 
1b22				 
1b22 21 46 ee			ld hl,scratch+50 
1b25 22 37 f1			ld (os_cur_ptr),hl 
1b28 c3 a1 1a			jp cli 
1b2b			 
1b2b			enter:	 
1b2b 3a 18 ee			ld a,(scratch+4) 
1b2e fe 00			cp 0 
1b30 28 0c			jr z, .entercont 
1b32				; no, not a null term line so has an address to work out.... 
1b32			 
1b32 21 16 ee			ld hl,scratch+2 
1b35 cd 94 11			call get_word_hl 
1b38			 
1b38 22 37 f1			ld (os_cur_ptr),hl	 
1b3b c3 a1 1a			jp cli 
1b3e			 
1b3e			 
1b3e			.entercont:  
1b3e			 
1b3e 21 16 ee			ld hl, scratch+2 
1b41 cd 34 11			call get_byte 
1b44			 
1b44 2a 37 f1		   	ld hl,(os_cur_ptr) 
1b47 77					ld (hl),a 
1b48 23					inc hl 
1b49 22 37 f1				ld (os_cur_ptr),hl 
1b4c				 
1b4c			; get byte  
1b4c			 
1b4c			 
1b4c c3 a1 1a			jp cli 
1b4f			 
1b4f			 
1b4f			; basic monitor support 
1b4f			 
1b4f			monitor: 
1b4f				;  
1b4f cd a9 0b			call clear_display 
1b52 3e 00			ld a, 0 
1b54 11 9c 1b			ld de, .monprompt 
1b57 cd bc 0b			call str_at_display 
1b5a cd cc 0b			call update_display 
1b5d			 
1b5d				; get a monitor command 
1b5d			 
1b5d 0e 00			ld c, 0     ; entry at top left 
1b5f 16 64			ld d, 100   ; max buffer size 
1b61 1e 0f			ld e, 15    ; input scroll area 
1b63 3e 00			ld a, 0     ; init string 
1b65 21 12 f0			ld hl, os_input 
1b68 77				ld (hl), a 
1b69 23				inc hl 
1b6a 77				ld (hl), a 
1b6b 21 12 f0			ld hl, os_input 
1b6e 3e 01			ld a, 1     ; init string 
1b70 cd 0a 0e			call input_str 
1b73			 
1b73 cd a9 0b		        call clear_display 
1b76 cd cc 0b			call update_display		 
1b79			 
1b79 3a 12 f0			ld a, (os_input) 
1b7c cd 32 12			call toUpper 
1b7f fe 48		        cp 'H' 
1b81 28 6f		        jr z, .monhelp 
1b83 fe 44			cp 'D'		; dump 
1b85 ca 13 1c			jp z, .mondump	 
1b88 fe 43			cp 'C'		; dump 
1b8a ca 2d 1c			jp z, .moncdump	 
1b8d fe 4d			cp 'M'		; dump 
1b8f ca 9e 1b			jp z, .moneditstart 
1b92 fe 55			cp 'U'		; dump 
1b94 28 14			jr z, .monedit	 
1b96 fe 51			cp 'Q'		; dump 
1b98 c8				ret z	 
1b99			 
1b99			 
1b99				; TODO "S" to access symbol by name and not need the address 
1b99				; TODO "F" to find a string in memory 
1b99			 
1b99 c3 4f 1b			jp monitor 
1b9c			 
1b9c .. 00		.monprompt: db ">", 0 
1b9e			 
1b9e			.moneditstart: 
1b9e				; get starting address 
1b9e			 
1b9e 21 14 f0			ld hl,os_input+2 
1ba1 cd 94 11			call get_word_hl 
1ba4			 
1ba4 22 37 f1			ld (os_cur_ptr),hl	 
1ba7			 
1ba7 c3 4f 1b			jp monitor 
1baa			 
1baa			.monedit: 
1baa				; get byte to load 
1baa			 
1baa 21 14 f0			ld hl,os_input+2 
1bad cd 34 11			call get_byte 
1bb0			 
1bb0				; get address to update 
1bb0 2a 37 f1			ld hl, (os_cur_ptr) 
1bb3			 
1bb3				; update byte 
1bb3			 
1bb3 77				ld (hl), a 
1bb4			 
1bb4				; move to next address and save it 
1bb4			 
1bb4 23				inc hl 
1bb5 22 37 f1			ld (os_cur_ptr),hl	 
1bb8			 
1bb8 c3 4f 1b			jp monitor 
1bbb			 
1bbb			 
1bbb .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1bcf .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1beb .. 00		.monhelptext3:  db "Q-Quit",0 
1bf2			        
1bf2			.monhelp: 
1bf2 3e 00			ld a, display_row_1 
1bf4 11 bb 1b		        ld de, .monhelptext1 
1bf7			 
1bf7 cd bc 0b			call str_at_display 
1bfa 3e 28			ld a, display_row_2 
1bfc 11 cf 1b		        ld de, .monhelptext2 
1bff					 
1bff cd bc 0b			call str_at_display 
1c02 3e 50			ld a, display_row_3 
1c04 11 eb 1b		        ld de, .monhelptext3 
1c07					 
1c07 cd bc 0b			call str_at_display 
1c0a cd cc 0b			call update_display		 
1c0d			 
1c0d cd 59 1d			call next_page_prompt 
1c10 c3 4f 1b			jp monitor 
1c13			 
1c13			.mondump:    
1c13 21 14 f0			ld hl,os_input+2 
1c16 cd 94 11			call get_word_hl 
1c19			 
1c19 22 37 f1			ld (os_cur_ptr),hl	 
1c1c cd 61 1c			call dumpcont 
1c1f 3e 78			ld a, display_row_4 
1c21 11 fb 1a			ld de, endprog 
1c24			 
1c24 cd cc 0b			call update_display		 
1c27			 
1c27 cd 59 1d			call next_page_prompt 
1c2a c3 4f 1b			jp monitor 
1c2d			.moncdump: 
1c2d cd 61 1c			call dumpcont 
1c30 3e 78			ld a, display_row_4 
1c32 11 fb 1a			ld de, endprog 
1c35			 
1c35 cd cc 0b			call update_display		 
1c38			 
1c38 cd 59 1d			call next_page_prompt 
1c3b c3 4f 1b			jp monitor 
1c3e			 
1c3e			 
1c3e			; TODO symbol access  
1c3e			 
1c3e			.symbols:     ;; A list of symbols that can be called up  
1c3e b4 fa			dw display_fb0 
1c40 .. 00			db "fb0",0  
1c44 59 f8		     	dw store_page 
1c46 .. 00			db "store_page",0 
1c51			 
1c51			 
1c51			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1c51			 
1c51 3a 15 ee			ld a,(scratch+1) 
1c54 fe 00			cp 0 
1c56 28 09			jr z, dumpcont 
1c58			 
1c58				; no, not a null term line so has an address to work out.... 
1c58			 
1c58 21 16 ee			ld hl,scratch+2 
1c5b cd 94 11			call get_word_hl 
1c5e			 
1c5e 22 37 f1			ld (os_cur_ptr),hl	 
1c61			 
1c61			 
1c61			 
1c61			dumpcont: 
1c61			 
1c61				; dump bytes at ptr 
1c61			 
1c61			 
1c61 3e 00			ld a, display_row_1 
1c63 2a cf f8			ld hl, (display_fb_active) 
1c66 cd dd 0d			call addatohl 
1c69 cd 91 1c			call .dumpbyterow 
1c6c			 
1c6c 3e 28			ld a, display_row_2 
1c6e 2a cf f8			ld hl, (display_fb_active) 
1c71 cd dd 0d			call addatohl 
1c74 cd 91 1c			call .dumpbyterow 
1c77			 
1c77			 
1c77 3e 50			ld a, display_row_3 
1c79 2a cf f8			ld hl, (display_fb_active) 
1c7c cd dd 0d			call addatohl 
1c7f cd 91 1c			call .dumpbyterow 
1c82			 
1c82 3e 78			ld a, display_row_4 
1c84 2a cf f8			ld hl, (display_fb_active) 
1c87 cd dd 0d			call addatohl 
1c8a cd 91 1c			call .dumpbyterow 
1c8d			 
1c8d cd cc 0b			call update_display 
1c90			;		jp cli 
1c90 c9				ret 
1c91			 
1c91			.dumpbyterow: 
1c91			 
1c91				;push af 
1c91			 
1c91 e5				push hl 
1c92			 
1c92				; calc where to poke the ascii 
1c92			if display_cols == 20 
1c92				ld a, 16 
1c92			else 
1c92 3e 1f			ld a, 31 
1c94			endif 
1c94			 
1c94 cd dd 0d			call addatohl 
1c97 22 19 f1			ld (os_word_scratch),hl  		; save pos for later 
1c9a			 
1c9a			 
1c9a			; display decoding address 
1c9a 2a 37 f1		   	ld hl,(os_cur_ptr) 
1c9d			 
1c9d 7c				ld a,h 
1c9e e1				pop hl 
1c9f e5				push hl 
1ca0			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ca0 cd de 10			call hexout 
1ca3 2a 37 f1		   	ld hl,(os_cur_ptr) 
1ca6			 
1ca6 7d				ld a,l 
1ca7 e1				pop hl 
1ca8 23				inc hl 
1ca9 23				inc hl 
1caa e5				push hl 
1cab			;	ld hl, os_word_scratch+2 
1cab cd de 10			call hexout 
1cae e1				pop hl 
1caf 23				inc hl 
1cb0 23				inc hl 
1cb1				;ld hl, os_word_scratch+4 
1cb1 3e 3a			ld a, ':' 
1cb3 77				ld (hl),a 
1cb4 23				inc hl 
1cb5				;ld a, 0 
1cb5				;ld (hl),a 
1cb5				;ld de, os_word_scratch 
1cb5				;pop af 
1cb5				;push af 
1cb5			;		ld a, display_row_2 
1cb5			;		call str_at_display 
1cb5			;		call update_display 
1cb5			 
1cb5			 
1cb5			;pop af 
1cb5			;	add 5 
1cb5			 
1cb5			if display_cols == 20 
1cb5				ld b, 4 
1cb5			else 
1cb5 06 08			ld b, 8 
1cb7			endif	 
1cb7			 
1cb7			.dumpbyte: 
1cb7 c5				push bc 
1cb8 e5				push hl 
1cb9			 
1cb9			 
1cb9 2a 37 f1		   	ld hl,(os_cur_ptr) 
1cbc 7e					ld a,(hl) 
1cbd			 
1cbd					; poke the ascii to display 
1cbd 2a 19 f1				ld hl,(os_word_scratch) 
1cc0 77					ld (hl),a 
1cc1 23					inc hl 
1cc2 22 19 f1				ld (os_word_scratch),hl 
1cc5			 
1cc5					 
1cc5			 
1cc5			 
1cc5 e1					pop hl 
1cc6 e5					push hl 
1cc7			 
1cc7 cd de 10				call hexout 
1cca			 
1cca					 
1cca 2a 37 f1		   	ld hl,(os_cur_ptr) 
1ccd 23				inc hl 
1cce 22 37 f1		   	ld (os_cur_ptr),hl 
1cd1			 
1cd1 e1					pop hl 
1cd2 23					inc hl 
1cd3 23					inc hl 
1cd4 23					inc hl 
1cd5			 
1cd5			 
1cd5			 
1cd5					;ld a,0 
1cd5					;ld (os_word_scratch+2),a 
1cd5					;pop af 
1cd5					;push af 
1cd5			 
1cd5					;ld de, os_word_scratch 
1cd5					;call str_at_display 
1cd5			;		call update_display 
1cd5			;		pop af 
1cd5 c1					pop bc 
1cd6 c6 03				add 3 
1cd8 10 dd			djnz .dumpbyte 
1cda			 
1cda				 
1cda			 
1cda c9				ret 
1cdb			 
1cdb			jump:	 
1cdb			 
1cdb 21 16 ee			ld hl,scratch+2 
1cde cd 94 11			call get_word_hl 
1ce1				;ld hl,(scratch+2) 
1ce1				;call fourehexhl 
1ce1			 
1ce1 22 37 f1			ld (os_cur_ptr),hl	 
1ce4			 
1ce4 e9				jp (hl) 
1ce5			 
1ce5			 
1ce5			 
1ce5			; TODO implement a basic monitor mode to start with 
1ce5			 
1ce5			 
1ce5			 
1ce5			 
1ce5			 
1ce5			 
1ce5			 
1ce5			 
1ce5			 
1ce5			; testing and demo code during development 
1ce5			 
1ce5			 
1ce5 .. 00		str1: db "Enter some text...",0 
1cf8 .. 00		clear: db "                    ",0 
1d0d			 
1d0d			demo: 
1d0d			 
1d0d			 
1d0d			 
1d0d			;	call update_display 
1d0d			 
1d0d				; init scratch input area for testing 
1d0d 21 14 ee			ld hl, scratch	 
1d10 3e 00			ld a,0 
1d12 77				ld (hl),a 
1d13			 
1d13			 
1d13 3e 28		            LD   A, display_row_2 
1d15			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d15 11 e5 1c		            LD   DE, str1 
1d18 cd bc 0b			call str_at_display 
1d1b			 
1d1b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d1b			cloop:	 
1d1b 3e 50		            LD   A, display_row_3 
1d1d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d1d 11 f8 1c		            LD   DE, clear 
1d20			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1d20 cd bc 0b				call str_at_display 
1d23 3e 78			ld a, display_row_4 
1d25 11 55 1d			ld de, prompt 
1d28			 
1d28 cd bc 0b				call str_at_display 
1d2b cd cc 0b			call update_display 
1d2e			 
1d2e 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d30 16 0a			ld d, 10 
1d32 21 14 ee			ld hl, scratch	 
1d35 cd 0a 0e			call input_str 
1d38			 
1d38			;	call clear_display 
1d38			;'	call update_display 
1d38			 
1d38 3e 00		            LD   A, display_row_1 
1d3a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d3a 11 f8 1c		            LD   DE, clear 
1d3d cd bc 0b				call str_at_display 
1d40			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d40 3e 00		            LD   A, display_row_1 
1d42			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d42 11 14 ee		            LD   DE, scratch 
1d45			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d45 cd bc 0b				call str_at_display 
1d48 cd cc 0b			call update_display 
1d4b			 
1d4b 3e 00				ld a,0 
1d4d 21 14 ee			ld hl, scratch 
1d50 77				ld (hl),a 
1d51			 
1d51 00				nop 
1d52 c3 1b 1d			jp cloop 
1d55			 
1d55			 
1d55			 
1d55			; OS Prompt 
1d55			 
1d55 .. 00		prompt: db ">",0 
1d57 .. 00		endprg: db "?",0 
1d59			 
1d59			 
1d59			; handy next page prompt 
1d59			next_page_prompt: 
1d59 e5				push hl 
1d5a d5				push de 
1d5b f5				push af 
1d5c c5				push bc 
1d5d			 
1d5d 3e 9f			ld a,display_row_4 + display_cols - 1 
1d5f 11 57 1d		        ld de, endprg 
1d62 cd bc 0b			call str_at_display 
1d65 cd cc 0b			call update_display 
1d68 cd 19 6b			call cin_wait 
1d6b c1				pop bc 
1d6c f1				pop af 
1d6d d1				pop de 
1d6e e1				pop hl 
1d6f			 
1d6f			 
1d6f c9				ret 
1d70			 
1d70			 
1d70			; forth parser 
1d70			 
1d70			; My forth kernel 
1d70			include "forth_kernel.asm" 
1d70			; 
1d70			; kernel to the forth OS 
1d70			 
1d70			DS_TYPE_STR: equ 1     ; string type 
1d70			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1d70			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1d70			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1d70			 
1d70			FORTH_PARSEV1: equ 0 
1d70			FORTH_PARSEV2: equ 0 
1d70			FORTH_PARSEV3: equ 0 
1d70			FORTH_PARSEV4: equ 0 
1d70			FORTH_PARSEV5: equ 1 
1d70			 
1d70			;if FORTH_PARSEV5 
1d70			;	FORTH_END_BUFFER: equ 0 
1d70			;else 
1d70			FORTH_END_BUFFER: equ 127 
1d70			;endif 
1d70			 
1d70			FORTH_TRUE: equ 1 
1d70			FORTH_FALSE: equ 0 
1d70			 
1d70			if FORTH_PARSEV4 
1d70			include "forth_stackops.asm" 
1d70			endif 
1d70			 
1d70			if FORTH_PARSEV5 
1d70			include "forth_stackopsv5.asm" 
1d70			 
1d70			; Stack operations for v5 parser on wards 
1d70			; * DATA stack 
1d70			; * LOOP stack 
1d70			; * RETURN stack 
1d70			 
1d70			 
1d70			 
1d70			FORTH_CHK_DSP_UNDER: macro 
1d70				push hl 
1d70				push de 
1d70				ld hl,(cli_data_sp) 
1d70				ld de, cli_data_stack 
1d70				call cmp16 
1d70				jp c, fault_dsp_under 
1d70				pop de 
1d70				pop hl 
1d70				endm 
1d70			 
1d70			 
1d70			FORTH_CHK_RSP_UNDER: macro 
1d70				push hl 
1d70				push de 
1d70				ld hl,(cli_ret_sp) 
1d70				ld de, cli_ret_stack 
1d70				call cmp16 
1d70				jp c, fault_rsp_under 
1d70				pop de 
1d70				pop hl 
1d70				endm 
1d70			 
1d70			FORTH_CHK_LOOP_UNDER: macro 
1d70				push hl 
1d70				push de 
1d70				ld hl,(cli_loop_sp) 
1d70				ld de, cli_loop_stack 
1d70				call cmp16 
1d70				jp c, fault_loop_under 
1d70				pop de 
1d70				pop hl 
1d70				endm 
1d70			 
1d70			FORTH_ERR_TOS_NOTSTR: macro 
1d70				; TOSO might need more for checks when used 
1d70				push af 
1d70				ld a,(hl) 
1d70				cp DS_TYPE_STR 
1d70				jp nz, type_faultn   
1d70				pop af 
1d70				endm 
1d70			 
1d70			FORTH_ERR_TOS_NOTNUM: macro 
1d70				push af 
1d70				ld a,(hl) 
1d70				cp DS_TYPE_INUM 
1d70				jp nz, type_faultn   
1d70				pop af 
1d70				endm 
1d70			 
1d70			 
1d70			; increase data stack pointer and save hl to it 
1d70				 
1d70			FORTH_DSP_NEXT: macro 
1d70				call macro_forth_dsp_next 
1d70				endm 
1d70			 
1d70			 
1d70			macro_forth_dsp_next: 
1d70				if DEBUG_FORTH_STACK_GUARD 
1d70 cd 91 64				call check_stacks 
1d73				endif 
1d73 e5				push hl 
1d74 d5				push de 
1d75 eb				ex de,hl 
1d76 2a 01 f8			ld hl,(cli_data_sp) 
1d79 23				inc hl 
1d7a 23				inc hl 
1d7b			 
1d7b			; PARSEV5 
1d7b 23				inc hl 
1d7c 22 01 f8			ld (cli_data_sp),hl 
1d7f 73				ld (hl), e 
1d80 23				inc hl 
1d81 72				ld (hl), d 
1d82 d1				pop de 
1d83 e1				pop hl 
1d84				if DEBUG_FORTH_STACK_GUARD 
1d84 cd 91 64				call check_stacks 
1d87				endif 
1d87 c9				ret 
1d88			 
1d88			 
1d88			; increase ret stack pointer and save hl to it 
1d88				 
1d88			FORTH_RSP_NEXT: macro 
1d88				call macro_forth_rsp_next 
1d88				endm 
1d88			 
1d88			macro_forth_rsp_next: 
1d88				if DEBUG_FORTH_STACK_GUARD 
1d88 cd 91 64				call check_stacks 
1d8b				endif 
1d8b e5				push hl 
1d8c d5				push de 
1d8d eb				ex de,hl 
1d8e 2a 05 f8			ld hl,(cli_ret_sp) 
1d91 23				inc hl 
1d92 23				inc hl 
1d93 22 05 f8			ld (cli_ret_sp),hl 
1d96 73				ld (hl), e 
1d97 23				inc hl 
1d98 72				ld (hl), d 
1d99 d1				pop de 
1d9a e1				pop hl 
1d9b				if DEBUG_FORTH_STACK_GUARD 
1d9b cd 91 64				call check_stacks 
1d9e				endif 
1d9e c9				ret 
1d9f			 
1d9f			; get current ret stack pointer and save to hl  
1d9f				 
1d9f			FORTH_RSP_TOS: macro 
1d9f				call macro_forth_rsp_tos 
1d9f				endm 
1d9f			 
1d9f			macro_forth_rsp_tos: 
1d9f				;push de 
1d9f 2a 05 f8			ld hl,(cli_ret_sp) 
1da2 cd da 1d			call loadhlptrtohl 
1da5				;ld e, (hl) 
1da5				;inc hl 
1da5				;ld d, (hl) 
1da5				;ex de, hl 
1da5					if DEBUG_FORTH_WORDS 
1da5			;			DMARK "RST" 
1da5						CALLMONITOR 
1da5 cd 84 17			call break_point_state  
1da8				endm  
# End of macro CALLMONITOR
1da8					endif 
1da8				;pop de 
1da8 c9				ret 
1da9			 
1da9			; pop ret stack pointer 
1da9				 
1da9			FORTH_RSP_POP: macro 
1da9				call macro_forth_rsp_pop 
1da9				endm 
1da9			 
1da9			 
1da9			macro_forth_rsp_pop: 
1da9				if DEBUG_FORTH_STACK_GUARD 
1da9			;		DMARK "RPP" 
1da9 cd 91 64				call check_stacks 
1dac					FORTH_CHK_RSP_UNDER 
1dac e5				push hl 
1dad d5				push de 
1dae 2a 05 f8			ld hl,(cli_ret_sp) 
1db1 11 7f f7			ld de, cli_ret_stack 
1db4 cd fb 0d			call cmp16 
1db7 da a5 65			jp c, fault_rsp_under 
1dba d1				pop de 
1dbb e1				pop hl 
1dbc				endm 
# End of macro FORTH_CHK_RSP_UNDER
1dbc				endif 
1dbc e5				push hl 
1dbd 2a 05 f8			ld hl,(cli_ret_sp) 
1dc0			 
1dc0			 
1dc0				if FORTH_ENABLE_FREE 
1dc0			 
1dc0					; get pointer 
1dc0			 
1dc0					push de 
1dc0					push hl 
1dc0			 
1dc0					ld e, (hl) 
1dc0					inc hl 
1dc0					ld d, (hl) 
1dc0			 
1dc0					ex de, hl 
1dc0					call free 
1dc0			 
1dc0					pop hl 
1dc0					pop de 
1dc0			 
1dc0			 
1dc0				endif 
1dc0			 
1dc0			 
1dc0 2b				dec hl 
1dc1 2b				dec hl 
1dc2 22 05 f8			ld (cli_ret_sp), hl 
1dc5				; do stack underflow checks 
1dc5 e1				pop hl 
1dc6				if DEBUG_FORTH_STACK_GUARD 
1dc6 cd 91 64				call check_stacks 
1dc9					FORTH_CHK_RSP_UNDER 
1dc9 e5				push hl 
1dca d5				push de 
1dcb 2a 05 f8			ld hl,(cli_ret_sp) 
1dce 11 7f f7			ld de, cli_ret_stack 
1dd1 cd fb 0d			call cmp16 
1dd4 da a5 65			jp c, fault_rsp_under 
1dd7 d1				pop de 
1dd8 e1				pop hl 
1dd9				endm 
# End of macro FORTH_CHK_RSP_UNDER
1dd9				endif 
1dd9 c9				ret 
1dda			 
1dda			 
1dda			 
1dda			; routine to load word pointed to by hl into hl 
1dda			 
1dda			loadhlptrtohl: 
1dda			 
1dda d5				push de 
1ddb 5e				ld e, (hl) 
1ddc 23				inc hl 
1ddd 56				ld d, (hl) 
1dde eb				ex de, hl 
1ddf d1				pop de 
1de0			 
1de0 c9				ret 
1de1			 
1de1			 
1de1			 
1de1			 
1de1			 
1de1			; push a number held in HL onto the data stack 
1de1			; entry point for pushing a value when already in hl used in function above 
1de1			 
1de1			forth_push_numhl: 
1de1			 
1de1 e5				push hl    ; save value to push 
1de2			 
1de2			if DEBUG_FORTH_PUSH 
1de2				; see if disabled 
1de2			 
1de2			 
1de2 f5				push af 
1de3 3a 05 ee			ld a, (os_view_disable) 
1de6 fe 2a			cp '*' 
1de8 28 34			jr z, .pskip2 
1dea e5				push hl 
1deb e5			push hl 
1dec cd a9 0b			call clear_display 
1def e1			pop hl 
1df0 7c				ld a,h 
1df1 21 19 f1			ld hl, os_word_scratch 
1df4 cd de 10			call hexout 
1df7 e1				pop hl 
1df8 7d				ld a,l 
1df9 21 1b f1			ld hl, os_word_scratch+2 
1dfc cd de 10			call hexout 
1dff			 
1dff 21 1d f1			ld hl, os_word_scratch+4 
1e02 3e 00			ld a,0 
1e04 77				ld (hl),a 
1e05 11 19 f1			ld de,os_word_scratch 
1e08 3e 28				ld a, display_row_2 
1e0a cd bc 0b				call str_at_display 
1e0d 11 70 53			ld de, .push_num 
1e10 3e 00			ld a, display_row_1 
1e12			 
1e12 cd bc 0b				call str_at_display 
1e15			 
1e15			 
1e15 cd cc 0b			call update_display 
1e18 cd 26 0b			call delay1s 
1e1b cd 26 0b			call delay1s 
1e1e			.pskip2:  
1e1e			 
1e1e f1				pop af 
1e1f			endif	 
1e1f			 
1e1f			 
1e1f				FORTH_DSP_NEXT 
1e1f cd 70 1d			call macro_forth_dsp_next 
1e22				endm 
# End of macro FORTH_DSP_NEXT
1e22			 
1e22 2a 01 f8			ld hl, (cli_data_sp) 
1e25			 
1e25				; save item type 
1e25 3e 02			ld a,  DS_TYPE_INUM 
1e27 77				ld (hl), a 
1e28 23				inc hl 
1e29			 
1e29				; get word off stack 
1e29 d1				pop de 
1e2a 7b				ld a,e 
1e2b 77				ld (hl), a 
1e2c 23				inc hl 
1e2d 7a				ld a,d 
1e2e 77				ld (hl), a 
1e2f			 
1e2f			if DEBUG_FORTH_PUSH 
1e2f 2b				dec hl 
1e30 2b				dec hl 
1e31 2b				dec hl 
1e32						DMARK "PH5" 
1e32 f5				push af  
1e33 3a 47 1e			ld a, (.dmark)  
1e36 32 6e fb			ld (debug_mark),a  
1e39 3a 48 1e			ld a, (.dmark+1)  
1e3c 32 6f fb			ld (debug_mark+1),a  
1e3f 3a 49 1e			ld a, (.dmark+2)  
1e42 32 70 fb			ld (debug_mark+2),a  
1e45 18 03			jr .pastdmark  
1e47 ..			.dmark: db "PH5"  
1e4a f1			.pastdmark: pop af  
1e4b			endm  
# End of macro DMARK
1e4b				CALLMONITOR 
1e4b cd 84 17			call break_point_state  
1e4e				endm  
# End of macro CALLMONITOR
1e4e			endif	 
1e4e			 
1e4e c9				ret 
1e4f			 
1e4f			 
1e4f			; Push a string to stack pointed to by hl 
1e4f			 
1e4f			forth_push_str: 
1e4f			 
1e4f			if DEBUG_FORTH_PUSH 
1e4f						DMARK "PSQ" 
1e4f f5				push af  
1e50 3a 64 1e			ld a, (.dmark)  
1e53 32 6e fb			ld (debug_mark),a  
1e56 3a 65 1e			ld a, (.dmark+1)  
1e59 32 6f fb			ld (debug_mark+1),a  
1e5c 3a 66 1e			ld a, (.dmark+2)  
1e5f 32 70 fb			ld (debug_mark+2),a  
1e62 18 03			jr .pastdmark  
1e64 ..			.dmark: db "PSQ"  
1e67 f1			.pastdmark: pop af  
1e68			endm  
# End of macro DMARK
1e68				CALLMONITOR 
1e68 cd 84 17			call break_point_state  
1e6b				endm  
# End of macro CALLMONITOR
1e6b			endif	 
1e6b			    
1e6b e5				push hl 
1e6c e5				push hl 
1e6d			 
1e6d			;	ld a, 0   ; find end of string 
1e6d cd 3b 12			call strlenz 
1e70			if DEBUG_FORTH_PUSH 
1e70						DMARK "PQ2" 
1e70 f5				push af  
1e71 3a 85 1e			ld a, (.dmark)  
1e74 32 6e fb			ld (debug_mark),a  
1e77 3a 86 1e			ld a, (.dmark+1)  
1e7a 32 6f fb			ld (debug_mark+1),a  
1e7d 3a 87 1e			ld a, (.dmark+2)  
1e80 32 70 fb			ld (debug_mark+2),a  
1e83 18 03			jr .pastdmark  
1e85 ..			.dmark: db "PQ2"  
1e88 f1			.pastdmark: pop af  
1e89			endm  
# End of macro DMARK
1e89				CALLMONITOR 
1e89 cd 84 17			call break_point_state  
1e8c				endm  
# End of macro CALLMONITOR
1e8c			endif	 
1e8c eb				ex de, hl 
1e8d e1				pop hl   ; get ptr to start of string 
1e8e			if DEBUG_FORTH_PUSH 
1e8e						DMARK "PQ3" 
1e8e f5				push af  
1e8f 3a a3 1e			ld a, (.dmark)  
1e92 32 6e fb			ld (debug_mark),a  
1e95 3a a4 1e			ld a, (.dmark+1)  
1e98 32 6f fb			ld (debug_mark+1),a  
1e9b 3a a5 1e			ld a, (.dmark+2)  
1e9e 32 70 fb			ld (debug_mark+2),a  
1ea1 18 03			jr .pastdmark  
1ea3 ..			.dmark: db "PQ3"  
1ea6 f1			.pastdmark: pop af  
1ea7			endm  
# End of macro DMARK
1ea7				CALLMONITOR 
1ea7 cd 84 17			call break_point_state  
1eaa				endm  
# End of macro CALLMONITOR
1eaa			endif	 
1eaa 19				add hl,de 
1eab			if DEBUG_FORTH_PUSH 
1eab						DMARK "PQE" 
1eab f5				push af  
1eac 3a c0 1e			ld a, (.dmark)  
1eaf 32 6e fb			ld (debug_mark),a  
1eb2 3a c1 1e			ld a, (.dmark+1)  
1eb5 32 6f fb			ld (debug_mark+1),a  
1eb8 3a c2 1e			ld a, (.dmark+2)  
1ebb 32 70 fb			ld (debug_mark+2),a  
1ebe 18 03			jr .pastdmark  
1ec0 ..			.dmark: db "PQE"  
1ec3 f1			.pastdmark: pop af  
1ec4			endm  
# End of macro DMARK
1ec4				CALLMONITOR 
1ec4 cd 84 17			call break_point_state  
1ec7				endm  
# End of macro CALLMONITOR
1ec7			endif	 
1ec7			 
1ec7 2b				dec hl    ; see if there is an optional trailing double quote 
1ec8 7e				ld a,(hl) 
1ec9 fe 22			cp '"' 
1ecb 20 03			jr nz, .strnoq 
1ecd 3e 00			ld a, 0      ; get rid of double quote 
1ecf 77				ld (hl), a 
1ed0 23			.strnoq: inc hl 
1ed1			 
1ed1 3e 00			ld a, 0 
1ed3 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ed4			 
1ed4 13				inc de ; add one for the type string 
1ed5 13				inc de ; add one for null term??? 
1ed6			 
1ed6				; tos is get string pointer again 
1ed6				; de contains space to allocate 
1ed6				 
1ed6 d5				push de 
1ed7			 
1ed7 eb				ex de, hl 
1ed8			 
1ed8				;push af 
1ed8			 
1ed8			if DEBUG_FORTH_PUSH 
1ed8						DMARK "PHm" 
1ed8 f5				push af  
1ed9 3a ed 1e			ld a, (.dmark)  
1edc 32 6e fb			ld (debug_mark),a  
1edf 3a ee 1e			ld a, (.dmark+1)  
1ee2 32 6f fb			ld (debug_mark+1),a  
1ee5 3a ef 1e			ld a, (.dmark+2)  
1ee8 32 70 fb			ld (debug_mark+2),a  
1eeb 18 03			jr .pastdmark  
1eed ..			.dmark: db "PHm"  
1ef0 f1			.pastdmark: pop af  
1ef1			endm  
# End of macro DMARK
1ef1				CALLMONITOR 
1ef1 cd 84 17			call break_point_state  
1ef4				endm  
# End of macro CALLMONITOR
1ef4			endif	 
1ef4 cd a4 12			call malloc	; on ret hl now contains allocated memory 
1ef7				if DEBUG_FORTH_MALLOC_GUARD 
1ef7 cc c8 53				call z,malloc_error 
1efa				endif 
1efa			 
1efa				 
1efa c1				pop bc    ; get length 
1efb d1				pop de   ;  get string start    
1efc			 
1efc				; hl has destination from malloc 
1efc			 
1efc eb				ex de, hl    ; prep for ldir 
1efd			 
1efd d5				push de   ; save malloc area for DSP later 
1efe				;push hl   ; save malloc area for DSP later 
1efe			 
1efe			if DEBUG_FORTH_PUSH 
1efe						DMARK "PHc" 
1efe f5				push af  
1eff 3a 13 1f			ld a, (.dmark)  
1f02 32 6e fb			ld (debug_mark),a  
1f05 3a 14 1f			ld a, (.dmark+1)  
1f08 32 6f fb			ld (debug_mark+1),a  
1f0b 3a 15 1f			ld a, (.dmark+2)  
1f0e 32 70 fb			ld (debug_mark+2),a  
1f11 18 03			jr .pastdmark  
1f13 ..			.dmark: db "PHc"  
1f16 f1			.pastdmark: pop af  
1f17			endm  
# End of macro DMARK
1f17				CALLMONITOR 
1f17 cd 84 17			call break_point_state  
1f1a				endm  
# End of macro CALLMONITOR
1f1a			endif	 
1f1a			 
1f1a			 
1f1a ed b0			ldir 
1f1c			 
1f1c			 
1f1c				; push malloc to data stack     macro?????  
1f1c			 
1f1c				FORTH_DSP_NEXT 
1f1c cd 70 1d			call macro_forth_dsp_next 
1f1f				endm 
# End of macro FORTH_DSP_NEXT
1f1f			 
1f1f				; save value and type 
1f1f			 
1f1f 2a 01 f8			ld hl, (cli_data_sp) 
1f22			 
1f22				; save item type 
1f22 3e 01			ld a,  DS_TYPE_STR 
1f24 77				ld (hl), a 
1f25 23				inc hl 
1f26			 
1f26				; get malloc word off stack 
1f26 d1				pop de 
1f27 73				ld (hl), e 
1f28 23				inc hl 
1f29 72				ld (hl), d 
1f2a			 
1f2a			 
1f2a			 
1f2a			if DEBUG_FORTH_PUSH 
1f2a 2a 01 f8			ld hl, (cli_data_sp) 
1f2d						DMARK "PHS" 
1f2d f5				push af  
1f2e 3a 42 1f			ld a, (.dmark)  
1f31 32 6e fb			ld (debug_mark),a  
1f34 3a 43 1f			ld a, (.dmark+1)  
1f37 32 6f fb			ld (debug_mark+1),a  
1f3a 3a 44 1f			ld a, (.dmark+2)  
1f3d 32 70 fb			ld (debug_mark+2),a  
1f40 18 03			jr .pastdmark  
1f42 ..			.dmark: db "PHS"  
1f45 f1			.pastdmark: pop af  
1f46			endm  
# End of macro DMARK
1f46				CALLMONITOR 
1f46 cd 84 17			call break_point_state  
1f49				endm  
# End of macro CALLMONITOR
1f49			;	ex de,hl 
1f49			endif	 
1f49				; in case of spaces, skip the ptr past the copied string 
1f49				;pop af 
1f49				;ld (cli_origptr),hl 
1f49			 
1f49 c9				ret 
1f4a			 
1f4a			 
1f4a			 
1f4a			; TODO ascii push input onto stack given hl to start of input 
1f4a			 
1f4a			; identify type 
1f4a			; if starts with a " then a string 
1f4a			; otherwise it is a number 
1f4a			;  
1f4a			; if a string 
1f4a			;     scan for ending " to get length of string to malloc for + 1 
1f4a			;     malloc 
1f4a			;     put pointer to string on stack first byte flags as string 
1f4a			; 
1f4a			; else a number 
1f4a			;    look for number format identifier 
1f4a			;    $xx hex 
1f4a			;    %xxxxx bin 
1f4a			;    xxxxx decimal 
1f4a			;    convert number to 16bit word.  
1f4a			;    malloc word + 1 with flag to identiy as num 
1f4a			;    put pointer to number on stack 
1f4a			;   
1f4a			;  
1f4a			  
1f4a			forth_apush: 
1f4a				; kernel push 
1f4a			 
1f4a			if DEBUG_FORTH_PUSH 
1f4a						DMARK "PSH" 
1f4a f5				push af  
1f4b 3a 5f 1f			ld a, (.dmark)  
1f4e 32 6e fb			ld (debug_mark),a  
1f51 3a 60 1f			ld a, (.dmark+1)  
1f54 32 6f fb			ld (debug_mark+1),a  
1f57 3a 61 1f			ld a, (.dmark+2)  
1f5a 32 70 fb			ld (debug_mark+2),a  
1f5d 18 03			jr .pastdmark  
1f5f ..			.dmark: db "PSH"  
1f62 f1			.pastdmark: pop af  
1f63			endm  
# End of macro DMARK
1f63				CALLMONITOR 
1f63 cd 84 17			call break_point_state  
1f66				endm  
# End of macro CALLMONITOR
1f66			endif	 
1f66				; identify input type 
1f66			 
1f66 7e				ld a,(hl) 
1f67 fe 22			cp '"' 
1f69 28 0a			jr z, .fapstr 
1f6b fe 24			cp '$' 
1f6d ca 95 1f			jp z, .faphex 
1f70 fe 25			cp '%' 
1f72 ca 7d 1f			jp z, .fapbin 
1f75			;	cp 'b' 
1f75			;	jp z, .fabin 
1f75				; else decimal 
1f75			 
1f75				; TODO do decimal conversion 
1f75				; decimal is stored as a 16bit word 
1f75			 
1f75				; by default everything is a string if type is not detected 
1f75			.fapstr: ; 
1f75 fe 22			cp '"' 
1f77 20 01			jr nz, .strnoqu 
1f79 23				inc hl 
1f7a			.strnoqu: 
1f7a c3 4f 1e			jp forth_push_str 
1f7d			 
1f7d			 
1f7d			 
1f7d			.fapbin:    ; push a binary string.  
1f7d 11 00 00			ld de, 0   ; hold a 16bit value 
1f80			 
1f80 23			.fapbinshift:	inc hl  
1f81 7e				ld a,(hl) 
1f82 fe 00			cp 0     ; done scanning  
1f84 28 0b			jr z, .fapbdone  	; got it in HL so push  
1f86			 
1f86				; left shift de 
1f86 eb				ex de, hl	 
1f87 29				add hl, hl 
1f88			 
1f88				; is 1 
1f88 fe 31			cp '1' 
1f8a 20 02			jr nz, .binzero 
1f8c cb 4d			bit 1, l 
1f8e			.binzero: 
1f8e eb				ex de, hl	 ; save current de 
1f8f 18 ef			jr .fapbinshift 
1f91			 
1f91			.fapbdone: 
1f91 eb				ex de, hl 
1f92 c3 e1 1d			jp forth_push_numhl 
1f95			 
1f95			 
1f95			.faphex:   ; hex is always stored as a 16bit word 
1f95				; skip number prefix 
1f95 23				inc hl 
1f96				; turn ascii into number 
1f96 cd 94 11			call get_word_hl	; ret 16bit word in hl 
1f99			 
1f99 c3 e1 1d			jp forth_push_numhl 
1f9c			 
1f9c 00				 nop 
1f9d			 
1f9d			.fabin:   ; TODO bin conversion 
1f9d			 
1f9d			 
1f9d c9				ret 
1f9e			 
1f9e			 
1f9e			; get either a string ptr or a 16bit word from the data stack 
1f9e			 
1f9e			FORTH_DSP: macro 
1f9e				call macro_forth_dsp 
1f9e				endm 
1f9e			 
1f9e			macro_forth_dsp: 
1f9e				; data stack pointer points to current word on tos 
1f9e			 
1f9e 2a 01 f8			ld hl,(cli_data_sp) 
1fa1			 
1fa1				if DEBUG_FORTH_PUSH 
1fa1						DMARK "DSP" 
1fa1 f5				push af  
1fa2 3a b6 1f			ld a, (.dmark)  
1fa5 32 6e fb			ld (debug_mark),a  
1fa8 3a b7 1f			ld a, (.dmark+1)  
1fab 32 6f fb			ld (debug_mark+1),a  
1fae 3a b8 1f			ld a, (.dmark+2)  
1fb1 32 70 fb			ld (debug_mark+2),a  
1fb4 18 03			jr .pastdmark  
1fb6 ..			.dmark: db "DSP"  
1fb9 f1			.pastdmark: pop af  
1fba			endm  
# End of macro DMARK
1fba			 
1fba cd fd 53				call display_data_sp 
1fbd				;call break_point_state 
1fbd				;rst 030h 
1fbd				CALLMONITOR 
1fbd cd 84 17			call break_point_state  
1fc0				endm  
# End of macro CALLMONITOR
1fc0				endif 
1fc0			 
1fc0 c9				ret 
1fc1			 
1fc1			; return hl to start of value on stack 
1fc1			 
1fc1			FORTH_DSP_VALUE: macro 
1fc1				call macro_forth_dsp_value 
1fc1				endm 
1fc1			 
1fc1			macro_forth_dsp_value: 
1fc1			 
1fc1				FORTH_DSP 
1fc1 cd 9e 1f			call macro_forth_dsp 
1fc4				endm 
# End of macro FORTH_DSP
1fc4			 
1fc4 d5				push de 
1fc5			 
1fc5 23				inc hl ; skip type 
1fc6			 
1fc6 5e				ld e, (hl) 
1fc7 23				inc hl 
1fc8 56				ld d, (hl) 
1fc9 eb				ex de,hl  
1fca			 
1fca d1				pop de 
1fcb			 
1fcb c9				ret 
1fcc			 
1fcc			; return hl to start of value to second item on stack 
1fcc			 
1fcc			FORTH_DSP_VALUEM1: macro 
1fcc				call macro_forth_dsp_value_m1 
1fcc				endm 
1fcc			 
1fcc			macro_forth_dsp_value_m1: 
1fcc			 
1fcc				FORTH_DSP 
1fcc cd 9e 1f			call macro_forth_dsp 
1fcf				endm 
# End of macro FORTH_DSP
1fcf			 
1fcf 2b				dec hl 
1fd0 2b				dec hl 
1fd1			;	dec hl 
1fd1			 
1fd1 d5				push de 
1fd2			 
1fd2 5e				ld e, (hl) 
1fd3 23				inc hl 
1fd4 56				ld d, (hl) 
1fd5 eb				ex de,hl  
1fd6			 
1fd6 d1				pop de 
1fd7			 
1fd7 c9				ret 
1fd8			 
1fd8				 
1fd8			 
1fd8			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1fd8			 
1fd8			FORTH_DSP_POP: macro 
1fd8				call macro_forth_dsp_pop 
1fd8				endm 
1fd8			 
1fd8			 
1fd8			; get the tos data type 
1fd8			 
1fd8			FORTH_DSP_TYPE:   macro 
1fd8			 
1fd8				;FORTH_DSP_VALUE 
1fd8				FORTH_DSP 
1fd8				 
1fd8				; hl points to value 
1fd8				; check type 
1fd8			 
1fd8				ld a,(hl) 
1fd8			 
1fd8				endm 
1fd8			 
1fd8			; load the tos value into hl 
1fd8			 
1fd8			 
1fd8			FORTH_DSP_VALUEHL:  macro 
1fd8				call macro_dsp_valuehl 
1fd8				endm 
1fd8			 
1fd8			 
1fd8			 
1fd8			macro_dsp_valuehl: 
1fd8				FORTH_DSP_VALUE 
1fd8 cd c1 1f			call macro_forth_dsp_value 
1fdb				endm 
# End of macro FORTH_DSP_VALUE
1fdb			 
1fdb				;FORTH_ERR_TOS_NOTNUM 
1fdb			 
1fdb				;inc hl   ; skip type id 
1fdb			 
1fdb			;	push de 
1fdb			; 
1fdb			;	ld e, (hl) 
1fdb			;	inc hl 
1fdb			;	ld d, (hl) 
1fdb			;	ex de,hl  
1fdb			 
1fdb			;	pop de 
1fdb			 
1fdb				if DEBUG_FORTH_PUSH 
1fdb						DMARK "DVL" 
1fdb f5				push af  
1fdc 3a f0 1f			ld a, (.dmark)  
1fdf 32 6e fb			ld (debug_mark),a  
1fe2 3a f1 1f			ld a, (.dmark+1)  
1fe5 32 6f fb			ld (debug_mark+1),a  
1fe8 3a f2 1f			ld a, (.dmark+2)  
1feb 32 70 fb			ld (debug_mark+2),a  
1fee 18 03			jr .pastdmark  
1ff0 ..			.dmark: db "DVL"  
1ff3 f1			.pastdmark: pop af  
1ff4			endm  
# End of macro DMARK
1ff4				CALLMONITOR 
1ff4 cd 84 17			call break_point_state  
1ff7				endm  
# End of macro CALLMONITOR
1ff7				endif 
1ff7 c9				ret 
1ff8			 
1ff8			forth_apushstrhl:      
1ff8				; push of string requires use of cli_origptr 
1ff8				; bodge use 
1ff8			 
1ff8				; get current cli_origptr, save, update with temp pointer  
1ff8 ed 5b 1d f8		ld de, (cli_origptr) 
1ffc 22 1d f8			ld (cli_origptr), hl 
1fff d5				push de 
2000 cd 4a 1f			call forth_apush 
2003 d1				pop de 
2004 ed 53 1d f8		ld (cli_origptr), de 
2008 c9			        ret	 
2009			 
2009			 
2009			; increase loop stack pointer and save hl to it 
2009				 
2009			FORTH_LOOP_NEXT: macro 
2009				call macro_forth_loop_next 
2009				;nop 
2009				endm 
2009			 
2009			macro_forth_loop_next: 
2009				if DEBUG_FORTH_STACK_GUARD 
2009 cd 91 64				call check_stacks 
200c				endif 
200c e5				push hl 
200d d5				push de 
200e eb				ex de,hl 
200f 2a 03 f8			ld hl,(cli_loop_sp) 
2012 23				inc hl 
2013 23				inc hl 
2014					if DEBUG_FORTH_WORDS 
2014						DMARK "LNX" 
2014 f5				push af  
2015 3a 29 20			ld a, (.dmark)  
2018 32 6e fb			ld (debug_mark),a  
201b 3a 2a 20			ld a, (.dmark+1)  
201e 32 6f fb			ld (debug_mark+1),a  
2021 3a 2b 20			ld a, (.dmark+2)  
2024 32 70 fb			ld (debug_mark+2),a  
2027 18 03			jr .pastdmark  
2029 ..			.dmark: db "LNX"  
202c f1			.pastdmark: pop af  
202d			endm  
# End of macro DMARK
202d						CALLMONITOR 
202d cd 84 17			call break_point_state  
2030				endm  
# End of macro CALLMONITOR
2030					endif 
2030 22 03 f8			ld (cli_loop_sp),hl 
2033 73				ld (hl), e 
2034 23				inc hl 
2035 72				ld (hl), d 
2036 d1				pop de    ; been reversed so save a swap on restore 
2037 e1				pop hl 
2038				if DEBUG_FORTH_STACK_GUARD 
2038 cd 91 64				call check_stacks 
203b				endif 
203b c9				ret 
203c			 
203c			; get current ret stack pointer and save to hl  
203c				 
203c			FORTH_LOOP_TOS: macro 
203c				call macro_forth_loop_tos 
203c				endm 
203c			 
203c			macro_forth_loop_tos: 
203c d5				push de 
203d 2a 03 f8			ld hl,(cli_loop_sp) 
2040 5e				ld e, (hl) 
2041 23				inc hl 
2042 56				ld d, (hl) 
2043 eb				ex de, hl 
2044 d1				pop de 
2045 c9				ret 
2046			 
2046			; pop loop stack pointer 
2046				 
2046			FORTH_LOOP_POP: macro 
2046				call macro_forth_loop_pop 
2046				endm 
2046			 
2046			 
2046			macro_forth_loop_pop: 
2046				if DEBUG_FORTH_STACK_GUARD 
2046					DMARK "LPP" 
2046 f5				push af  
2047 3a 5b 20			ld a, (.dmark)  
204a 32 6e fb			ld (debug_mark),a  
204d 3a 5c 20			ld a, (.dmark+1)  
2050 32 6f fb			ld (debug_mark+1),a  
2053 3a 5d 20			ld a, (.dmark+2)  
2056 32 70 fb			ld (debug_mark+2),a  
2059 18 03			jr .pastdmark  
205b ..			.dmark: db "LPP"  
205e f1			.pastdmark: pop af  
205f			endm  
# End of macro DMARK
205f cd 91 64				call check_stacks 
2062					FORTH_CHK_LOOP_UNDER 
2062 e5				push hl 
2063 d5				push de 
2064 2a 03 f8			ld hl,(cli_loop_sp) 
2067 11 7d f5			ld de, cli_loop_stack 
206a cd fb 0d			call cmp16 
206d da ab 65			jp c, fault_loop_under 
2070 d1				pop de 
2071 e1				pop hl 
2072				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2072				endif 
2072 e5				push hl 
2073 2a 03 f8			ld hl,(cli_loop_sp) 
2076 2b				dec hl 
2077 2b				dec hl 
2078 22 03 f8			ld (cli_loop_sp), hl 
207b				; TODO do stack underflow checks 
207b e1				pop hl 
207c				if DEBUG_FORTH_STACK_GUARD 
207c cd 91 64				call check_stacks 
207f					FORTH_CHK_LOOP_UNDER 
207f e5				push hl 
2080 d5				push de 
2081 2a 03 f8			ld hl,(cli_loop_sp) 
2084 11 7d f5			ld de, cli_loop_stack 
2087 cd fb 0d			call cmp16 
208a da ab 65			jp c, fault_loop_under 
208d d1				pop de 
208e e1				pop hl 
208f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
208f				endif 
208f c9				ret 
2090			 
2090			macro_forth_dsp_pop: 
2090			 
2090 e5				push hl 
2091			 
2091				; release malloc data 
2091			 
2091				if DEBUG_FORTH_STACK_GUARD 
2091 cd 91 64				call check_stacks 
2094					FORTH_CHK_DSP_UNDER 
2094 e5				push hl 
2095 d5				push de 
2096 2a 01 f8			ld hl,(cli_data_sp) 
2099 11 7b f3			ld de, cli_data_stack 
209c cd fb 0d			call cmp16 
209f da 9f 65			jp c, fault_dsp_under 
20a2 d1				pop de 
20a3 e1				pop hl 
20a4				endm 
# End of macro FORTH_CHK_DSP_UNDER
20a4				endif 
20a4				;ld hl,(cli_data_sp) 
20a4			if DEBUG_FORTH_DOT 
20a4				DMARK "DPP" 
20a4				CALLMONITOR 
20a4			endif	 
20a4			 
20a4			 
20a4			if FORTH_ENABLE_DSPPOPFREE 
20a4			 
20a4				FORTH_DSP 
20a4 cd 9e 1f			call macro_forth_dsp 
20a7				endm 
# End of macro FORTH_DSP
20a7			 
20a7 7e				ld a, (hl) 
20a8 fe 01			cp DS_TYPE_STR 
20aa 20 07			jr nz, .skippopfree 
20ac			 
20ac				FORTH_DSP_VALUEHL 
20ac cd d8 1f			call macro_dsp_valuehl 
20af				endm 
# End of macro FORTH_DSP_VALUEHL
20af 00				nop 
20b0			if DEBUG_FORTH_DOT 
20b0				DMARK "DPf" 
20b0				CALLMONITOR 
20b0			endif	 
20b0 cd 6e 13			call free 
20b3			.skippopfree: 
20b3				 
20b3			 
20b3			endif 
20b3			 
20b3			if DEBUG_FORTH_DOT_KEY 
20b3				DMARK "DP2" 
20b3				CALLMONITOR 
20b3			endif	 
20b3			 
20b3				; move pointer down 
20b3			 
20b3 2a 01 f8			ld hl,(cli_data_sp) 
20b6 2b				dec hl 
20b7 2b				dec hl 
20b8			; PARSEV5 
20b8 2b				dec hl 
20b9 22 01 f8			ld (cli_data_sp), hl 
20bc			 
20bc				if DEBUG_FORTH_STACK_GUARD 
20bc cd 91 64				call check_stacks 
20bf					FORTH_CHK_DSP_UNDER 
20bf e5				push hl 
20c0 d5				push de 
20c1 2a 01 f8			ld hl,(cli_data_sp) 
20c4 11 7b f3			ld de, cli_data_stack 
20c7 cd fb 0d			call cmp16 
20ca da 9f 65			jp c, fault_dsp_under 
20cd d1				pop de 
20ce e1				pop hl 
20cf				endm 
# End of macro FORTH_CHK_DSP_UNDER
20cf				endif 
20cf			 
20cf e1				pop hl 
20d0			 
20d0 c9				ret 
20d1			 
20d1			getwordathl: 
20d1				; hl points to an address 
20d1				; load hl with the word at that address 
20d1			 
20d1 d5				push de 
20d2			 
20d2 5e				ld e, (hl) 
20d3 23				inc hl 
20d4 56				ld d, (hl) 
20d5 eb				ex de, hl 
20d6			 
20d6 d1				pop de 
20d7 c9				ret 
20d8			 
20d8			 
20d8			 
20d8			 
20d8			 
20d8			; eof 
20d8			 
# End of file forth_stackopsv5.asm
20d8			endif 
20d8			 
20d8			user_word_eol:  
20d8				; hl contains the pointer to where to create a linked list item from the end 
20d8				; of the user dict to continue on at the system word dict 
20d8				 
20d8				; poke the stub of the word list linked list to repoint to rom words 
20d8			 
20d8				; stub format 
20d8				; db   word id 
20d8				; dw    link to next word 
20d8			        ; db char length of token 
20d8				; db string + 0 term 
20d8				; db exec code....  
20d8			 
20d8 3e 00			ld a, WORD_SYS_ROOT     ; root word 
20da 77				ld (hl), a		; word id 
20db 23				inc hl 
20dc			 
20dc 11 a2 22			ld de, sysdict 
20df 73				ld (hl), e		; next word link ie system dict 
20e0 23				inc hl 
20e1 72				ld (hl), d		; next word link ie system dict 
20e2 23				inc hl	 
20e3			 
20e3			;	ld (hl), sysdict		; next word link ie system dict 
20e3			;	inc hl 
20e3			;	inc hl 
20e3			 
20e3			;	inc hl 
20e3			;	inc hl 
20e3			 
20e3 3e 02			ld a, 2			; word length is 0 
20e5 77				ld (hl), a	 
20e6 23				inc hl 
20e7			 
20e7 3e 7e			ld a, '~'			; word length is 0 
20e9 77				ld (hl), a	 
20ea 23				inc hl 
20eb 3e 00			ld a, 0			; save empty word 
20ed 77				ld (hl), a 
20ee			 
20ee c9				ret 
20ef			 
20ef				 
20ef			 
20ef			forthexec_cleanup: 
20ef				FORTH_RSP_POP 
20ef cd a9 1d			call macro_forth_rsp_pop 
20f2				endm 
# End of macro FORTH_RSP_POP
20f2 c9				ret 
20f3			 
20f3			forth_call_hl: 
20f3				; taking hl 
20f3 e5				push hl 
20f4 c9				ret 
20f5			 
20f5			; this is called to reset Forth system but keep existing uwords etc 
20f5			 
20f5			forth_warmstart: 
20f5				; setup stack over/under flow checks 
20f5				if DEBUG_FORTH_STACK_GUARD 
20f5 cd 77 64				call chk_stk_init 
20f8				endif 
20f8			 
20f8				; init stack pointers  - * these stacks go upwards *  
20f8 21 7f f7			ld hl, cli_ret_stack 
20fb 22 05 f8			ld (cli_ret_sp), hl	 
20fe				; set bottom of stack 
20fe 3e 00			ld a,0 
2100 77				ld (hl),a 
2101 23				inc hl 
2102 77				ld (hl),a 
2103			 
2103 21 7b f3			ld hl, cli_data_stack 
2106 22 01 f8			ld (cli_data_sp), hl	 
2109				; set bottom of stack 
2109 3e 00			ld a,0 
210b 77				ld (hl),a 
210c 23				inc hl 
210d 77				ld (hl),a 
210e			 
210e 21 7d f5			ld hl, cli_loop_stack 
2111 22 03 f8			ld (cli_loop_sp), hl	 
2114				; set bottom of stack 
2114 3e 00			ld a,0 
2116 77				ld (hl),a 
2117 23				inc hl 
2118 77				ld (hl),a 
2119			 
2119				; init extent of current open file 
2119			 
2119 3e 00			ld a, 0 
211b 32 50 f8			ld (store_openext), a 
211e			 
211e c9				ret 
211f			 
211f			 
211f			; Cold Start - this is called to setup the whole Forth system 
211f			 
211f			forth_init: 
211f			 
211f				; setup stack over/under flow checks 
211f			 
211f			;	if DEBUG_FORTH_STACK_GUARD 
211f			;		call chk_stk_init 
211f			;	endif 
211f			 
211f				; enable auto display updates (slow.....) 
211f			 
211f 3e 01			ld a, 1 
2121 32 1b f8			ld (cli_autodisplay), a 
2124			 
2124			 
2124			 
2124				; show start up screen 
2124			 
2124 cd a9 0b			call clear_display 
2127			 
2127 3e 00			ld a,0 
2129 32 3d f8			ld (f_cursor_ptr), a 
212c			 
212c				; set start of word list in start of ram - for use when creating user words 
212c			 
212c 21 00 80			ld hl, baseram 
212f 22 11 f1			ld (os_last_new_uword), hl 
2132 cd d8 20			call user_word_eol 
2135				 
2135			;		call display_data_sp 
2135			;		call next_page_prompt 
2135			 
2135			 
2135			 
2135			 
2135 c9				ret 
2136			 
2136 .. 00		.bootforth: db " Forth Kernel Init ",0 
214a			 
214a			; TODO push to stack 
214a			 
214a			;  
214a			 
214a			if FORTH_PARSEV2 
214a			 
214a			 
214a				include "forth_parserv2.asm" 
214a			 
214a			endif 
214a			 
214a			 
214a			; parse cli version 1 
214a			 
214a			if FORTH_PARSEV1 
214a			 
214a			 
214a			 
214a			      include "forth_parserv1.asm" 
214a			endif 
214a				 
214a			if FORTH_PARSEV3 
214a			 
214a			 
214a			 
214a			      include "forth_parserv3.asm" 
214a				include "forth_wordsv3.asm" 
214a			endif 
214a			 
214a			if FORTH_PARSEV4 
214a			 
214a			 
214a			 
214a			      include "forth_parserv4.asm" 
214a				include "forth_wordsv4.asm" 
214a			endif 
214a			 
214a			if FORTH_PARSEV5 
214a			 
214a			 
214a			 
214a			      include "forth_parserv5.asm" 
214a			 
214a			 
214a			; A better parser without using malloc and string copies all over the place.  
214a			; Exec in situ should be faster 
214a			 
214a			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
214a			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
214a			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
214a			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
214a			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
214a			WORD_SYS_END: equ 0   ; Opcode for all user words 
214a			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
214a			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
214a			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
214a			 
214a			; Core word preamble macro 
214a			 
214a			CWHEAD:   macro nxtword opcode lit len opflags 
214a				db WORD_SYS_CORE+opcode             
214a				; internal op code number 
214a				dw nxtword            
214a				; link to next dict word block 
214a				db len + 1 
214a				; literal length of dict word inc zero term 
214a				db lit,0              
214a				; literal dict word 
214a			        ; TODO db opflags        
214a				endm 
214a			 
214a			 
214a			NEXTW: macro  
214a				jp macro_next 
214a				endm 
214a			 
214a			macro_next: 
214a			if DEBUG_FORTH_PARSE_KEY 
214a				DMARK "NXT" 
214a				CALLMONITOR 
214a			endif	 
214a			;	inc hl  ; skip token null term  
214a ed 4b 1f f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
214e ed 5b 1d f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2152 2a 15 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2155			if DEBUG_FORTH_PARSE_KEY 
2155				DMARK "}AA" 
2155				CALLMONITOR 
2155			endif	 
2155 c3 58 22			jp execnext 
2158				;jp exec1 
2158			       
2158			 
2158			 
2158			; Another go at the parser to compile  
2158			 
2158			 
2158			; TODO rework parser to change all of the string words to byte tokens 
2158			; TODO do a search for  
2158			 
2158			; TODO first run normal parser to zero term sections 
2158			; TODO for each word do a token look up to get the op code 
2158			; TODO need some means to flag to the exec that this is a byte code form    
2158			 
2158			 
2158			forthcompile: 
2158			 
2158			; 
2158			; line parse: 
2158			;       parse raw input buffer 
2158			;       tokenise the words 
2158			;       malloc new copy (for looping etc) 
2158			;       copy to malloc + current pc in line to start of string and add line term 
2158			;       save on new rsp 
2158			; 
2158			 
2158			; hl to point to the line to tokenise 
2158			 
2158			;	push hl 
2158 22 15 f1			ld (os_tok_ptr), hl  ; save ptr to string 
215b			 
215b			;	ld a,0		; string term on input 
215b			;	call strlent 
215b			 
215b			;	ld (os_tok_len), hl	 ; save string length 
215b			 
215b			;if DEBUG_FORTH_TOK 
215b			;	ex de,hl		 
215b			;endif 
215b			 
215b			;	pop hl 		; get back string pointer 
215b			 
215b			if DEBUG_FORTH_TOK 
215b						DMARK "TOc" 
215b				CALLMONITOR 
215b			endif 
215b 7e			.cptoken2:    ld a,(hl) 
215c 23				inc hl 
215d fe 7f			cp FORTH_END_BUFFER 
215f 28 29			jr z, .cptokendone2 
2161 fe 00			cp 0 
2163 28 25			jr z, .cptokendone2 
2165 fe 22			cp '"' 
2167 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2169 fe 20			cp ' ' 
216b 20 ee			jr nz,  .cptoken2 
216d			 
216d			; TODO consume comments held between ( and ) 
216d			 
216d				; we have a space so change to zero term for dict match later 
216d 2b				dec hl 
216e 3e 00			ld a,0 
2170 77				ld (hl), a 
2171 23				inc hl 
2172 18 e7			jr .cptoken2 
2174				 
2174			 
2174			.cptokenstr2: 
2174				; skip all white space until either eol (because forgot to term) or end double quote 
2174			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2174				;inc hl ; skip current double quote 
2174 7e				ld a,(hl) 
2175 23				inc hl 
2176 fe 22			cp '"' 
2178 28 e1			jr z, .cptoken2 
217a fe 7f			cp FORTH_END_BUFFER 
217c 28 0c			jr z, .cptokendone2 
217e fe 00			cp 0 
2180 28 08			jr z, .cptokendone2 
2182 fe 20			cp ' ' 
2184 28 02			jr z, .cptmp2 
2186 18 ec			jr .cptokenstr2 
2188			 
2188			.cptmp2:	; we have a space so change to zero term for dict match later 
2188				;dec hl 
2188				;ld a,"-"	; TODO remove this when working 
2188				;ld (hl), a 
2188				;inc hl 
2188 18 ea			jr .cptokenstr2 
218a			 
218a			.cptokendone2: 
218a				;inc hl 
218a 3e 7f			ld a, FORTH_END_BUFFER 
218c 77				ld (hl),a 
218d 23				inc hl 
218e 3e 21			ld a, '!' 
2190 77				ld (hl),a 
2191			 
2191 2a 15 f1			ld hl,(os_tok_ptr) 
2194			         
2194			if DEBUG_FORTH_TOK 
2194						DMARK "Tc1" 
2194				CALLMONITOR 
2194			endif 
2194			 
2194				; push exec string to top of return stack 
2194				FORTH_RSP_NEXT 
2194 cd 88 1d			call macro_forth_rsp_next 
2197				endm 
# End of macro FORTH_RSP_NEXT
2197 c9				ret 
2198			 
2198			; Another go at the parser need to simplify the process 
2198			 
2198			forthparse: 
2198			 
2198			; 
2198			; line parse: 
2198			;       parse raw input buffer 
2198			;       tokenise the words 
2198			;       malloc new copy (for looping etc) 
2198			;       copy to malloc + current pc in line to start of string and add line term 
2198			;       save on new rsp 
2198			; 
2198			 
2198			; hl to point to the line to tokenise 
2198			 
2198			;	push hl 
2198 22 15 f1			ld (os_tok_ptr), hl  ; save ptr to string 
219b			 
219b			;	ld a,0		; string term on input 
219b			;	call strlent 
219b			 
219b			;	ld (os_tok_len), hl	 ; save string length 
219b			 
219b			;if DEBUG_FORTH_TOK 
219b			;	ex de,hl		 
219b			;endif 
219b			 
219b			;	pop hl 		; get back string pointer 
219b			 
219b			if DEBUG_FORTH_TOK 
219b						DMARK "TOK" 
219b				CALLMONITOR 
219b			endif 
219b 7e			.ptoken2:    ld a,(hl) 
219c 23				inc hl 
219d fe 7f			cp FORTH_END_BUFFER 
219f 28 29			jr z, .ptokendone2 
21a1 fe 00			cp 0 
21a3 28 25			jr z, .ptokendone2 
21a5 fe 22			cp '"' 
21a7 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
21a9 fe 20			cp ' ' 
21ab 20 ee			jr nz,  .ptoken2 
21ad			 
21ad			; TODO consume comments held between ( and ) 
21ad			 
21ad				; we have a space so change to zero term for dict match later 
21ad 2b				dec hl 
21ae 3e 00			ld a,0 
21b0 77				ld (hl), a 
21b1 23				inc hl 
21b2 18 e7			jr .ptoken2 
21b4				 
21b4			 
21b4			.ptokenstr2: 
21b4				; skip all white space until either eol (because forgot to term) or end double quote 
21b4			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
21b4				;inc hl ; skip current double quote 
21b4 7e				ld a,(hl) 
21b5 23				inc hl 
21b6 fe 22			cp '"' 
21b8 28 e1			jr z, .ptoken2 
21ba fe 7f			cp FORTH_END_BUFFER 
21bc 28 0c			jr z, .ptokendone2 
21be fe 00			cp 0 
21c0 28 08			jr z, .ptokendone2 
21c2 fe 20			cp ' ' 
21c4 28 02			jr z, .ptmp2 
21c6 18 ec			jr .ptokenstr2 
21c8			 
21c8			.ptmp2:	; we have a space so change to zero term for dict match later 
21c8				;dec hl 
21c8				;ld a,"-"	; TODO remove this when working 
21c8				;ld (hl), a 
21c8				;inc hl 
21c8 18 ea			jr .ptokenstr2 
21ca			 
21ca			.ptokendone2: 
21ca				;inc hl 
21ca 3e 7f			ld a, FORTH_END_BUFFER 
21cc 77				ld (hl),a 
21cd 23				inc hl 
21ce 3e 21			ld a, '!' 
21d0 77				ld (hl),a 
21d1			 
21d1 2a 15 f1			ld hl,(os_tok_ptr) 
21d4			         
21d4			if DEBUG_FORTH_TOK 
21d4						DMARK "TK1" 
21d4				CALLMONITOR 
21d4			endif 
21d4			 
21d4				; push exec string to top of return stack 
21d4				FORTH_RSP_NEXT 
21d4 cd 88 1d			call macro_forth_rsp_next 
21d7				endm 
# End of macro FORTH_RSP_NEXT
21d7 c9				ret 
21d8			 
21d8			; 
21d8			;	; malloc size + buffer pointer + if is loop flag 
21d8			;	ld hl,(os_tok_len) 		 ; get string length 
21d8			; 
21d8			;	ld a,l 
21d8			; 
21d8			;	cp 0			; we dont want to use a null string 
21d8			;	ret z 
21d8			; 
21d8			;;	add 3    ; prefix malloc with buffer for current word ptr 
21d8			; 
21d8			;	add 5     ; TODO when certain not over writing memory remove 
21d8			; 
21d8			;		 
21d8			; 
21d8			;if DEBUG_FORTH_TOK 
21d8			;			DMARK "TKE" 
21d8			;	CALLMONITOR 
21d8			;endif 
21d8			; 
21d8			;	ld l,a 
21d8			;	ld h,0 
21d8			;;	push hl   ; save required space for the copy later 
21d8			;	call malloc 
21d8			;if DEBUG_FORTH_TOK 
21d8			;			DMARK "TKM" 
21d8			;	CALLMONITOR 
21d8			;endif 
21d8			;	if DEBUG_FORTH_MALLOC_GUARD 
21d8			;		push af 
21d8			;		call ishlzero 
21d8			;;		ld a, l 
21d8			;;		add h 
21d8			;;		cp 0 
21d8			;		pop af 
21d8			;		 
21d8			;		call z,malloc_error 
21d8			;	endif 
21d8			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
21d8			; 
21d8			; 
21d8			;if DEBUG_FORTH_TOK 
21d8			;			DMARK "TKR" 
21d8			;	CALLMONITOR 
21d8			;endif 
21d8			; 
21d8			;	FORTH_RSP_NEXT 
21d8			; 
21d8			;	;inc hl	 ; go past current buffer pointer 
21d8			;	;inc hl 
21d8			;	;inc hl   ; and past if loop flag 
21d8			;		; TODO Need to set flag  
21d8			; 
21d8			;	 
21d8			;	 
21d8			;	ex de,hl	; malloc is dest 
21d8			;	ld hl, (os_tok_len) 
21d8			;;	pop bc 
21d8			;	ld c, l                
21d8			;	ld b,0 
21d8			;	ld hl, (os_tok_ptr) 
21d8			; 
21d8			;if DEBUG_FORTH_TOK 
21d8			;			DMARK "TKT" 
21d8			;	CALLMONITOR 
21d8			;endif 
21d8			; 
21d8			;	; do str cpy 
21d8			; 
21d8			;	ldir      ; copy byte in hl to de 
21d8			; 
21d8			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
21d8			; 
21d8			;if DEBUG_FORTH_TOK 
21d8			; 
21d8			;			DMARK "TKY" 
21d8			;	CALLMONITOR 
21d8			;endif 
21d8			;	;ld a,0 
21d8			;	;ld a,FORTH_END_BUFFER 
21d8			;	ex de, hl 
21d8			;	;dec hl			 ; go back over the space delim at the end of word 
21d8			;	;ld (hl),a 
21d8			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
21d8			;	ld a,FORTH_END_BUFFER 
21d8			;	ld (hl),a 
21d8			;	inc hl 
21d8			;	ld a,FORTH_END_BUFFER 
21d8			;	ld (hl),a 
21d8			; 
21d8			;	; init the malloc area data 
21d8			;	; set pc for in current area 
21d8			;	;ld hl, (os_tok_malloc) 
21d8			;	;inc hl 
21d8			;	;inc hl 
21d8			;	;inc hl 
21d8			;	;ex de,hl 
21d8			;	;ld hl, (os_tok_malloc) 
21d8			;	;ld (hl),e 
21d8			;	;inc hl 
21d8			;	;ld (hl),d 
21d8			; 
21d8			; 
21d8			;	ld hl,(os_tok_malloc) 
21d8			;if DEBUG_FORTH_PARSE_KEY 
21d8			;			DMARK "TKU" 
21d8			;	CALLMONITOR 
21d8			;endif 
21d8			; 
21d8			;	ret 
21d8			 
21d8			forthexec: 
21d8			 
21d8			; line exec: 
21d8			; forth parser 
21d8			 
21d8			; 
21d8			;       get current exec line on rsp 
21d8			 
21d8				FORTH_RSP_TOS 
21d8 cd 9f 1d			call macro_forth_rsp_tos 
21db				endm 
# End of macro FORTH_RSP_TOS
21db			 
21db			;       restore current pc - hl points to malloc of data 
21db			 
21db				;ld e, (hl) 
21db				;inc hl 
21db				;ld d, (hl) 
21db				;ex de,hl 
21db			 
21db			 
21db			exec1: 
21db 22 15 f1			ld (os_tok_ptr), hl 
21de			 
21de				; copy our PC to working vars  
21de 22 1f f8			ld (cli_ptr), hl 
21e1 22 1d f8			ld (cli_origptr), hl 
21e4			 
21e4 7e				ld a,(hl) 
21e5 fe 7f			cp FORTH_END_BUFFER 
21e7 c8				ret z 
21e8			 
21e8				; skip any nulls 
21e8			 
21e8 fe 00			cp 0 
21ea 20 03			jr nz, .execword 
21ec 23				inc hl 
21ed 18 ec			jr exec1 
21ef			 
21ef			 
21ef			.execword: 
21ef			 
21ef			 
21ef			 
21ef			if DEBUG_FORTH_PARSE_KEY 
21ef						DMARK "KYQ" 
21ef				CALLMONITOR 
21ef			endif 
21ef			;       while at start of word: 
21ef			; get start of dict (in user area first) 
21ef			 
21ef 21 00 80		ld hl, baseram 
21f2			;ld hl, sysdict 
21f2 22 21 f8		ld (cli_nextword),hl 
21f5			;           match word at pc 
21f5			;           exec word 
21f5			;           or push to dsp 
21f5			;           forward to next token 
21f5			;           if line term pop rsp and exit 
21f5			;        
21f5			 
21f5			if DEBUG_FORTH_PARSE_KEY 
21f5						DMARK "KYq" 
21f5				CALLMONITOR 
21f5			endif 
21f5			 
21f5			; 
21f5			; word comp 
21f5			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
21f5			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
21f5			;    move to start of word  
21f5			;    compare word to cli_token 
21f5			 
21f5			.execpnword:	; HL at start of a word in the dictionary to check 
21f5			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
21f5			;	ld (cli_ptr), hl 
21f5			 
21f5 2a 21 f8			ld hl,(cli_nextword) 
21f8			 
21f8 cd 9b 22			call forth_tok_next 
21fb			; tok next start here 
21fb			;	; TODO skip compiled symbol for now 
21fb			;	inc hl 
21fb			; 
21fb			;	; save pointer to next word 
21fb			; 
21fb			;	; hl now points to the address of the next word pointer  
21fb			;	ld e, (hl) 
21fb			;	inc hl 
21fb			;	ld d, (hl) 
21fb			;	inc l 
21fb			; 
21fb			;	ex de,hl 
21fb			;if DEBUG_FORTH_PARSE_NEXTWORD 
21fb			;	push bc 
21fb			;	ld bc, (cli_nextword) 
21fb			;			DMARK "NXW" 
21fb			;	CALLMONITOR 
21fb			;	pop bc 
21fb			;endif 
21fb			; tok next end here 
21fb 22 21 f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
21fe eb				ex de, hl 
21ff			 
21ff			 
21ff				; save the pointer of the current token - 1 to check against 
21ff				 
21ff 22 25 f8			ld (cli_token), hl   
2202				; TODO maybe remove below save if no debug 
2202				; save token string ptr for any debug later 
2202 23				inc hl  
2203 22 27 f8			ld (cli_origtoken), hl 
2206 2b				dec hl 
2207				; save pointer to the start of the next dictionay word 
2207 7e				ld a,(hl)   ; get string length 
2208 47				ld b,a 
2209			.execpnwordinc:  
2209 23				inc hl 
220a 10 fd			djnz .execpnwordinc 
220c 22 23 f8			ld (cli_execword), hl      ; save start of this words code 
220f			 
220f				; now check the word token against the string being parsed 
220f			 
220f 2a 25 f8			ld hl,(cli_token) 
2212 23				inc hl     ; skip string length (use zero term instead to end) 
2213 22 25 f8			ld (cli_token), hl 
2216			 
2216			if DEBUG_FORTH_PARSE_KEY 
2216						DMARK "KY2" 
2216			endif 
2216			if DEBUG_FORTH_PARSE_EXEC 
2216				; see if disabled 
2216			 
2216				ld a, (os_view_disable) 
2216				cp '*' 
2216				jr z, .skip 
2216			 
2216				push hl 
2216				push hl 
2216				call clear_display 
2216				ld de, .compword 
2216				ld a, display_row_1 
2216				call str_at_display 
2216				pop de 
2216				ld a, display_row_2 
2216				call str_at_display 
2216				ld hl,(cli_ptr) 
2216				ld a,(hl) 
2216			        ld hl, os_word_scratch 
2216				ld (hl),a 
2216				ld a,0 
2216				inc hl 
2216				ld (hl),a 	 
2216				ld de, os_word_scratch 
2216				ld a, display_row_2+10 
2216				call str_at_display 
2216				call update_display 
2216				ld a, 100 
2216				call aDelayInMS 
2216				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2216				call delay250ms 
2216				endif 
2216				pop hl 
2216			.skip:  
2216			endif	 
2216			.execpnchar:    ; compare char between token and string to parse 
2216			 
2216			if DEBUG_FORTH_PARSE_KEY 
2216						DMARK "Ky3" 
2216			endif 
2216			if DEBUG_FORTH_PARSE_EXEC 
2216				; see if disabled 
2216			 
2216				ld a, (os_view_disable) 
2216				cp '*' 
2216				jr z, .skip2 
2216			 
2216			;	call clear_display 
2216			ld hl,(cli_token) 
2216			ld a,(hl) 
2216			ld (os_word_scratch),a 
2216				ld hl,(cli_ptr) 
2216			ld a,(hl) 
2216				ld (os_word_scratch+1),a 
2216				ld a,0 
2216				ld (os_word_scratch+2),a 
2216				ld de,os_word_scratch 
2216				ld a,display_row_4 
2216				call str_at_display 
2216				call update_display 
2216			.skip2:  
2216			endif 
2216 2a 25 f8			ld hl,(cli_token) 
2219 7e				ld a, (hl)	 ; char in word token 
221a 23				inc hl 		; move to next char 
221b 22 25 f8			ld (cli_token), hl ; and save it 
221e 47				ld b,a 
221f			 
221f 2a 1f f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
2222 7e				ld a,(hl) 
2223 23				inc hl 
2224 22 1f f8			ld (cli_ptr), hl		; move to next char 
2227 cd 32 12			call toUpper 		; make sure the input string matches case 
222a			 
222a			if DEBUG_FORTH_PARSE 
222a			endif 
222a			 
222a				; input stream end of token is a space so get rid of it 
222a			 
222a			;	cp ' ' 
222a			;	jr nz, .pnskipspace 
222a			; 
222a			;	ld a, 0		; make same term as word token term 
222a			; 
222a			;.pnskipspace: 
222a			 
222a			if DEBUG_FORTH_PARSE_KEY 
222a						DMARK "KY7" 
222a			endif 
222a b8				cp b 
222b c2 41 22			jp nz, .execpnskipword	 ; no match so move to next word 
222e				 
222e			;    if same 
222e			;       scan for string terms 0 for token and 32 for input 
222e			 
222e				 
222e			if DEBUG_FORTH_PARSE_KEY 
222e						DMARK "KY8" 
222e			endif 
222e			 
222e 80				add b			 
222f fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2231							; TODO need to make sure last word in zero term string is accounted for 
2231 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2233			 
2233			 
2233				; at end of both strings so both are exact match 
2233			 
2233			;       skip ptr for next word 
2233			 
2233 2a 1f f8			ld hl,(cli_ptr) 	; at input string term 
2236 23				inc hl			 ; at next char 
2237 22 1f f8			ld (cli_ptr), hl     ; save for next round of the parser 
223a 22 1d f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
223d				 
223d				 
223d			if DEBUG_FORTH_PARSE_KEY 
223d						DMARK "KY3" 
223d			endif 
223d			 
223d			 
223d			 
223d			;       exec code block 
223d			if DEBUG_FORTH_JP 
223d				call clear_display 
223d				call update_display 
223d				call delay1s 
223d				ld hl, (cli_execword)     ; save for next check if no match on this word 
223d				ld a,h 
223d				ld hl, os_word_scratch 
223d				call hexout 
223d				ld hl, (cli_execword)     ; save for next check if no match on this word 
223d				ld a,l 
223d				ld hl, os_word_scratch+2 
223d				call hexout 
223d				ld hl, os_word_scratch+4 
223d				ld a,0 
223d				ld (hl),a 
223d				ld de,os_word_scratch 
223d				call str_at_display 
223d					ld a, display_row_2 
223d					call str_at_display 
223d				ld de, (cli_origtoken) 
223d				ld a, display_row_1+10 
223d					call str_at_display 
223d			 
223d				ld a,display_row_1 
223d				ld de, .foundword 
223d				ld a, display_row_3 
223d				call str_at_display 
223d				call update_display 
223d				call delay1s 
223d				call delay1s 
223d				call delay1s 
223d			endif 
223d			 
223d			if DEBUG_FORTH_PARSE_KEY 
223d						DMARK "KYj" 
223d			endif 
223d				; TODO save the word pointer in this exec 
223d			 
223d 2a 23 f8			ld hl,(cli_execword) 
2240 e9				jp (hl) 
2241			 
2241			 
2241			;    if not same 
2241			;	scan for zero term 
2241			;	get ptr for next word 
2241			;	goto word comp 
2241			 
2241			.execpnskipword:	; get pointer to next word 
2241 2a 21 f8			ld hl,(cli_nextword) 
2244			 
2244 7e				ld a,(hl) 
2245 fe 00			cp WORD_SYS_END 
2247			;	cp 0 
2247 28 09			jr z, .execendofdict			 ; at end of words 
2249			 
2249			if DEBUG_FORTH_PARSE_KEY 
2249						DMARK "KY4" 
2249			endif 
2249			if DEBUG_FORTH_PARSE_EXEC 
2249			 
2249				; see if disabled 
2249			 
2249				ld a, (os_view_disable) 
2249				cp '*' 
2249				jr z, .noskip 
2249			 
2249			 
2249				ld de, .nowordfound 
2249				ld a, display_row_3 
2249				call str_at_display 
2249				call update_display 
2249				ld a, 100 
2249				call aDelayInMS 
2249				 
2249				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2249					call delay250ms 
2249				endif 
2249			.noskip:  
2249			 
2249			endif	 
2249			 
2249 2a 1d f8			ld hl,(cli_origptr) 
224c 22 1f f8			ld (cli_ptr),hl 
224f			 
224f			if DEBUG_FORTH_PARSE_KEY 
224f						DMARK "KY5" 
224f			endif 
224f c3 f5 21			jp .execpnword			; else go to next word 
2252			 
2252			.execendofdict:  
2252			 
2252			if DEBUG_FORTH_PARSE_KEY 
2252						DMARK "KYe" 
2252			endif 
2252			if DEBUG_FORTH_PARSE_EXEC 
2252				; see if disabled 
2252			 
2252				ld a, (os_view_disable) 
2252				cp '*' 
2252				jr z, .ispskip 
2252			 
2252				call clear_display 
2252				call update_display 
2252				call delay1s 
2252				ld de, (cli_origptr) 
2252				ld a, display_row_1 
2252				call str_at_display 
2252				 
2252				ld de, .enddict 
2252				ld a, display_row_3 
2252				call str_at_display 
2252				call update_display 
2252				ld a, 100 
2252				call aDelayInMS 
2252				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2252				call delay1s 
2252				call delay1s 
2252				call delay1s 
2252				endif 
2252			.ispskip:  
2252				 
2252			endif	 
2252			 
2252			 
2252			 
2252				; if the word is not a keyword then must be a literal so push it to stack 
2252			 
2252			; push token to stack to end of word 
2252			 
2252				STACKFRAME ON $1efe $2f9f 
2252				if DEBUG_STACK_IMB 
2252					if ON 
2252						exx 
2252						ld de, $1efe 
2252						ld a, d 
2252						ld hl, curframe 
2252						call hexout 
2252						ld a, e 
2252						ld hl, curframe+2 
2252						call hexout 
2252						ld hl, $1efe 
2252						push hl 
2252						ld hl, $2f9f 
2252						push hl 
2252						exx 
2252					endif 
2252				endif 
2252			endm 
# End of macro STACKFRAME
2252			 
2252 2a 15 f1		ld hl,(os_tok_ptr) 
2255 cd 4a 1f		call forth_apush 
2258			 
2258				STACKFRAMECHK ON $1efe $2f9f 
2258				if DEBUG_STACK_IMB 
2258					if ON 
2258						exx 
2258						ld hl, $2f9f 
2258						pop de   ; $2f9f 
2258						call cmp16 
2258						jr nz, .spnosame 
2258						ld hl, $1efe 
2258						pop de   ; $1efe 
2258						call cmp16 
2258						jr z, .spfrsame 
2258						.spnosame: call showsperror 
2258						.spfrsame: nop 
2258						exx 
2258					endif 
2258				endif 
2258			endm 
# End of macro STACKFRAMECHK
2258			 
2258			execnext: 
2258			 
2258			if DEBUG_FORTH_PARSE_KEY 
2258						DMARK "KY>" 
2258			endif 
2258			; move past token to next word 
2258			 
2258 2a 15 f1		ld hl, (os_tok_ptr) 
225b 3e 00		ld a, 0 
225d 01 ff 00		ld bc, 255     ; input buffer size 
2260 ed b1		cpir 
2262			 
2262			if DEBUG_FORTH_PARSE_KEY 
2262						DMARK "KY!" 
2262				CALLMONITOR 
2262			endif	 
2262			; TODO this might place hl on the null, so will need to forward on??? 
2262			;inc hl   ; see if this gets onto the next item 
2262			 
2262			 
2262			; TODO pass a pointer to the buffer to push 
2262			; TODO call function to push 
2262			 
2262			; look for end of input 
2262			 
2262			;inc hl 
2262			;ld a,(hl) 
2262			;cp FORTH_END_BUFFER 
2262			;ret z 
2262			 
2262			 
2262 c3 db 21		jp exec1 
2265			 
2265			 
2265			 
2265			 
2265			 
2265			 
2265			 
2265			 
2265			 
2265			findnexttok: 
2265			 
2265				; hl is pointer to move 
2265				; de is the token to locate 
2265			 
2265					if DEBUG_FORTH 
2265						DMARK "NTK" 
2265						CALLMONITOR 
2265					endif 
2265 d5				push de 
2266			 
2266			.fnt1:	 
2266				; find first char of token to locate 
2266			 
2266 1a				ld a, (de) 
2267 4f				ld c,a 
2268 7e				ld a,(hl) 
2269 cd 32 12			call toUpper 
226c					if DEBUG_FORTH 
226c						DMARK "NT1" 
226c						CALLMONITOR 
226c					endif 
226c b9				cp c 
226d			 
226d 28 03			jr z, .fnt2cmpmorefirst	 
226f			 
226f				; first char not found move to next char 
226f			 
226f 23				inc hl 
2270 18 f4			jr .fnt1 
2272			 
2272			.fnt2cmpmorefirst:	 
2272				; first char of token found.  
2272			 
2272 e5				push hl     ; save start of token just in case it is the right one 
2273 d9				exx 
2274 e1				pop hl        ; save it to hl' 
2275 d9				exx 
2276			 
2276			 
2276			.fnt2cmpmore:	 
2276				; compare the rest 
2276				 
2276 23				inc hl 
2277 13				inc de 
2278				 
2278 1a				ld a, (de) 
2279 4f				ld c,a 
227a 7e				ld a,(hl) 
227b cd 32 12			call toUpper 
227e			 
227e					if DEBUG_FORTH 
227e						DMARK "NT2" 
227e						CALLMONITOR 
227e					endif 
227e				; c has the token to find char 
227e				; a has the mem to scan char 
227e			 
227e b9				cp c 
227f 28 04			jr z,.fntmatch1 
2281			 
2281				; they are not the same 
2281			 
2281					if DEBUG_FORTH 
2281						DMARK "NT3" 
2281						CALLMONITOR 
2281					endif 
2281 d1				pop de	; reset de token to look for 
2282 d5				push de 
2283 18 e1			jr .fnt1 
2285				 
2285			.fntmatch1: 
2285			 
2285				; is the same char a null which means we might have a full hit? 
2285					if DEBUG_FORTH 
2285						DMARK "NT4" 
2285						CALLMONITOR 
2285					endif 
2285			 
2285 fe 00			cp 0 
2287 28 0b			jr z, .fntmatchyes 
2289			 
2289				; are we at the end of the token to find? 
2289			 
2289					if DEBUG_FORTH 
2289						DMARK "NT5" 
2289						CALLMONITOR 
2289					endif 
2289 3e 00			ld a, 0 
228b b9				cp c 
228c			 
228c c2 76 22			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
228f			 
228f					if DEBUG_FORTH 
228f						DMARK "NT6" 
228f						CALLMONITOR 
228f					endif 
228f				; token to find is exhusted but no match to stream 
228f			 
228f				; restore tok pointer and continue on 
228f d1				pop de 
2290 d5				push de 
2291 c3 66 22			jp .fnt1 
2294			 
2294			 
2294			.fntmatchyes: 
2294			 
2294				; hl now contains the end of the found token 
2294			 
2294				; get rid of saved token pointer to find 
2294			 
2294 d1				pop de 
2295			 
2295					if DEBUG_FORTH 
2295						DMARK "NT9" 
2295						CALLMONITOR 
2295					endif 
2295			 
2295				; hl will be on the null term so forward on 
2295			 
2295				; get back the saved start of the token 
2295			 
2295 d9				exx 
2296 e5				push hl     ; save start of token just in case it is the right one 
2297 d9				exx 
2298 e1				pop hl        ; save it to hl 
2299			 
2299 c9				ret 
229a			 
229a			 
229a			; LIST needs to find a specific token   
229a			; FORGET needs to find a spefici token 
229a			 
229a			; SAVE needs to find all tokens by flag 
229a			; WORDS just needs to scan through all  by flag 
229a			; UWORDS needs to scan through all by flag 
229a			 
229a			 
229a			; given hl as pointer to start of dict look up string 
229a			; return hl as pointer to start of word block 
229a			; or 0 if not found 
229a			 
229a			forth_find_tok: 
229a c9				ret 
229b			 
229b			; given hl as pointer to dict structure 
229b			; move to the next dict block structure 
229b			 
229b			forth_tok_next: 
229b				; hl now points to the address of the next word pointer  
229b				; TODO skip compiled symbol for now 
229b			;	push de 
229b 23				inc hl 
229c 5e				ld e, (hl) 
229d 23				inc hl 
229e 56				ld d, (hl) 
229f 23				inc hl 
22a0			 
22a0 eb				ex de,hl 
22a1			if DEBUG_FORTH_PARSE_NEXTWORD 
22a1				push bc 
22a1				ld bc, (cli_nextword) 
22a1						DMARK "NXW" 
22a1				CALLMONITOR 
22a1				pop bc 
22a1			endif 
22a1			;	pop de	 
22a1 c9				ret 
22a2			 
22a2			 
22a2			 
22a2			; eof 
# End of file forth_parserv5.asm
22a2				include "forth_wordsv4.asm" 
22a2			 
22a2			; the core word dictionary v4 
22a2			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
22a2			 
22a2			; this is a linked list for each of the system words used 
22a2			; user defined words will follow the same format but will be in ram 
22a2			 
22a2			 
22a2			; 
22a2			; 
22a2			; define linked list: 
22a2			; 
22a2			; 1. compiled byte op code 
22a2			; 2. len of text word 
22a2			; 3. text word 
22a2			; 4. ptr to next dictionary word 
22a2			; 5. asm, calls etc for the word 
22a2			; 
22a2			;  if 1 == 0 then last word in dict  
22a2			;   
22a2			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
22a2			;  
22a2			;  
22a2			; create basic standard set of words 
22a2			; 
22a2			;  
22a2			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
22a2			; 2DUP 2DROP 2SWAP  
22a2			; @ C@ - get byte  
22a2			; ! C! - store byte 
22a2			; 0< true if less than zero 
22a2			; 0= true if zero 
22a2			; < >  
22a2			; = true if same 
22a2			; variables 
22a2			 
22a2			 
22a2			; Hardware specific words I may need 
22a2			; 
22a2			; IN OUT  
22a2			; calls to key util functions 
22a2			; calls to hardward abstraction stuff 
22a2			; easy control of frame buffers and lcd i/o 
22a2			; keyboard  
22a2			 
22a2			 
22a2			;DICT: macro 
22a2			; op_code, len, word, next 
22a2			;    word: 
22a2			;    db op_code 
22a2			;    ds word zero term 
22a2			;    dw next 
22a2			;    endm 
22a2			 
22a2			 
22a2			 
22a2			 
22a2			; op code 1 is a flag for user define words which are to be handled differently 
22a2			 
22a2			 
22a2			; 
22a2			; 
22a2			;    TODO on entry to a word this should be the expected environment 
22a2			;    hl - tos value if number then held, if string this is the ptr 
22a2			;    de -  
22a2			 
22a2			 
22a2			; opcode ranges 
22a2			; 0 - end of word dict 
22a2			; 255 - user define words 
22a2			 
22a2			sysdict: 
22a2			include "forth_opcodes.asm" 
22a2			; op codes for forth keywords 
22a2			; free to use code 0  
22a2				OPCODE_HEAP: equ  1 
22a2				OPCODE_EXEC: equ 2 
22a2				OPCODE_DUP: equ 3 
22a2				OPCODE_SWAP: equ 4 
22a2				OPCODE_COLN: equ 5 
22a2				OPCODE_SCOLN: equ 6 
22a2				OPCODE_DROP: equ 7 
22a2				OPCODE_DUP2: equ 8 
22a2				OPCODE_DROP2: equ 9 
22a2				OPCODE_SWAP2: equ 10 
22a2				OPCODE_AT: equ 11 
22a2				OPCODE_CAT: equ 12 
22a2				OPCODE_BANG: equ 13 
22a2				OPCODE_CBANG: equ 14 
22a2				OPCODE_SCALL: equ 15 
22a2				OPCODE_DEPTH: equ 16 
22a2				OPCODE_OVER: equ 17 
22a2				OPCODE_PAUSE: equ 18 
22a2				OPCODE_PAUSES: equ 19 
22a2				OPCODE_ROT: equ 20 
22a2			;free to reuse	OPCODE_WORDS: equ 21 
22a2			        OPCODE_NOT: equ 21 
22a2				OPCODE_UWORDS: equ 22 
22a2				OPCODE_BP: equ 23 
22a2				OPCODE_MONITOR: equ 24  
22a2				OPCODE_MALLOC: equ 25 
22a2				OPCODE_FREE: equ 26 
22a2				OPCODE_LIST: equ 27 
22a2				OPCODE_FORGET: equ 28 
22a2				OPCODE_NOP: equ 29 
22a2				OPCODE_COMO: equ 30 
22a2				OPCODE_COMC: equ 31 
22a2			;free to reuse	OPCODE_ENDCORE: equ 32 
22a2				OPCODE_AFTERSOUND: equ 33 
22a2				OPCODE_GP2: equ 34 
22a2				OPCODE_GP3: equ 35 
22a2				OPCODE_GP4: equ 36 
22a2				OPCODE_SIN: equ 37 
22a2				OPCODE_SOUT: equ 38 
22a2				OPCODE_SPIO: equ 39 
22a2				OPCODE_SPICEH: equ 40 
22a2				OPCODE_SPIOb: equ 41 
22a2				OPCODE_SPII: equ 42 
22a2				OPCODE_SESEL: equ 43 
22a2				OPCODE_CARTDEV: equ 44 
22a2			; free to reuse	OPCODE_ENDDEVICE: equ 45 
22a2				OPCODE_FB: equ 46 
22a2				OPCODE_EMIT: equ 47 
22a2				OPCODE_DOTH: equ 48 
22a2				OPCODE_DOTF: equ 49 
22a2				OPCODE_DOT: equ 50 
22a2				OPCODE_CLS: equ 51 
22a2				OPCODE_DRAW: equ 52 
22a2				OPCODE_DUMP: equ 53 
22a2				OPCODE_CDUMP: equ 54 
22a2				OPCODE_DAT: equ 55 
22a2				OPCODE_HOME: equ 56 
22a2				OPCODE_SPACE: equ 57 
22a2				OPCODE_SPACES: equ 58 
22a2				OPCODE_SCROLL: equ 59 
22a2				OPCODE_ATQ: equ 60 
22a2				OPCODE_AUTODSP: equ 61 
22a2				OPCODE_MENU: equ 62 
22a2			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
22a2				OPCODE_THEN: equ 64 
22a2				OPCODE_ELSE: equ 65 
22a2				OPCODE_DO: equ 66 
22a2				OPCODE_LOOP: equ 67 
22a2				OPCODE_I: equ 68 
22a2				OPCODE_DLOOP: equ 69  
22a2				OPCODE_REPEAT: equ 70  
22a2				OPCODE_UNTIL: equ 71 
22a2				OPCODE_ENDFLOW: equ 72 
22a2				OPCODE_WAITK: equ 73 
22a2				OPCODE_ACCEPT: equ 74 
22a2				OPCODE_EDIT: equ 75 
22a2			;free to reuse	OPCODE_ENDKEY: equ 76 
22a2				OPCODE_LZERO: equ 77 
22a2				OPCODE_TZERO: equ 78 
22a2				OPCODE_LESS: equ 79 
22a2				OPCODE_GT: equ 80 
22a2				OPCODE_EQUAL: equ 81  
22a2			;free to reuse	OPCODE_ENDLOGIC: equ 82 
22a2				OPCODE_NEG: equ 83 
22a2				OPCODE_DIV: equ 84 
22a2				OPCODE_MUL: equ 85 
22a2				OPCODE_MIN: equ 86 
22a2				OPCODE_MAX: equ 87 
22a2				OPCODE_RND16: equ 88 
22a2				OPCODE_RND8: equ 89 
22a2				OPCODE_RND: equ 90 
22a2			;free to reuse	OPCODE_ENDMATHS: equ 91  
22a2				OPCODE_BYNAME: equ 92 
22a2				OPCODE_DIR: equ 93 
22a2				OPCODE_SAVE: equ 94 
22a2				OPCODE_LOAD: equ 95 
22a2				OPCODE_BSAVE: equ 96 
22a2				OPCODE_BLOAD: equ 97 
22a2				OPCODE_SEO: equ 98  
22a2				OPCODE_SEI: equ 99 
22a2				OPCODE_SFREE: equ 100 
22a2				OPCODE_SIZE: equ 101 
22a2				OPCODE_CREATE: equ 102 
22a2				OPCODE_APPEND: equ 103 
22a2				OPCODE_SDEL: equ 104 
22a2				OPCODE_OPEN: equ 105 
22a2				OPCODE_READ: equ 106 
22a2				OPCODE_EOF: equ 106 
22a2				OPCODE_FORMAT: equ 107 
22a2				OPCODE_LABEL: equ 108 
22a2				OPCODE_LABELS: equ 109 
22a2			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
22a2				OPCODE_UPPER: equ 111 
22a2				OPCODE_LOWER: equ 112 
22a2				OPCODE_SUBSTR: equ 113 
22a2				OPCODE_LEFT: equ 114 
22a2				OPCODE_RIGHT: equ 115 
22a2				OPCODE_STR2NUM: equ 116 
22a2				OPCODE_NUM2STR: equ 117 
22a2				OPCODE_CONCAT: equ 118 
22a2				OPCODE_FIND: equ 119 
22a2				OPCODE_LEN: equ 120 
22a2				OPCODE_CHAR: equ 121 
22a2			; free to reuse	OPCODE_STRLEN: equ 122 
22a2			; free to reuse	OPCODE_ENDSTR: equ 123 
22a2				OPCODE_V0S: equ 124 
22a2				OPCODE_V0Q: equ 125 
22a2				OPCODE_V1S: equ 126 
22a2				OPCODE_V1Q: equ 127 
22a2				OPCODE_V2S: equ 128 
22a2				OPCODE_V2Q: equ 129 
22a2				OPCODE_V3S: equ 130 
22a2				OPCODE_V3Q: equ 131 
22a2			;free to reuse	OPCODE_END: equ 132 
22a2				OPCODE_ZDUP: equ 133 
22a2			 
22a2			; eof 
# End of file forth_opcodes.asm
22a2			 
22a2			include "forth_words_core.asm" 
22a2			 
22a2			; | ## Core Words 
22a2			 
22a2			;if MALLOC_4 
22a2			 
22a2			.HEAP: 
22a2				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
22a2 15				db WORD_SYS_CORE+OPCODE_HEAP             
22a3 e1 22			dw .EXEC            
22a5 05				db 4 + 1 
22a6 .. 00			db "HEAP",0              
22ab				endm 
# End of macro CWHEAD
22ab			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
22ab			; | | u1 - Current number of bytes in the heap 
22ab			; | | u2 - Remaining bytes left on the heap 
22ab			; | |  
22ab			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
22ab			 
22ab			 
22ab					if DEBUG_FORTH_WORDS_KEY 
22ab						DMARK "HEP" 
22ab f5				push af  
22ac 3a c0 22			ld a, (.dmark)  
22af 32 6e fb			ld (debug_mark),a  
22b2 3a c1 22			ld a, (.dmark+1)  
22b5 32 6f fb			ld (debug_mark+1),a  
22b8 3a c2 22			ld a, (.dmark+2)  
22bb 32 70 fb			ld (debug_mark+2),a  
22be 18 03			jr .pastdmark  
22c0 ..			.dmark: db "HEP"  
22c3 f1			.pastdmark: pop af  
22c4			endm  
# End of macro DMARK
22c4						CALLMONITOR 
22c4 cd 84 17			call break_point_state  
22c7				endm  
# End of macro CALLMONITOR
22c7					endif 
22c7 2a 0a 80				ld hl, (free_list )      
22ca 11 0e 80				ld de, heap_start 
22cd			 
22cd ed 52				sbc hl, de  
22cf			 
22cf cd e1 1d				call forth_push_numhl 
22d2			 
22d2			 
22d2 ed 5b 0a 80			ld de, (free_list )      
22d6 21 fa ed				ld hl, heap_end 
22d9			 
22d9 ed 52				sbc hl, de 
22db			 
22db cd e1 1d				call forth_push_numhl 
22de					 
22de			 
22de					 
22de			 
22de			 
22de			 
22de					NEXTW 
22de c3 4a 21			jp macro_next 
22e1				endm 
# End of macro NEXTW
22e1			;endif 
22e1			 
22e1			.EXEC: 
22e1			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
22e1			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
22e1			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
22e1			;; > > 
22e1			;; > >   
22e1			;	STACKFRAME OFF $5efe $5f9f 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS_KEY 
22e1			;			DMARK "EXE" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			; 
22e1			;	FORTH_DSP_VALUEHL 
22e1			; 
22e1			;	FORTH_DSP_POP 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX1" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;;	ld e,(hl) 
22e1			;;	inc hl 
22e1			;;	ld d,(hl) 
22e1			;;	ex de,hl 
22e1			; 
22e1			;;		if DEBUG_FORTH_WORDS 
22e1			;;			DMARK "EX2" 
22e1			;;			CALLMONITOR 
22e1			;;		endif 
22e1			;	push hl 
22e1			; 
22e1			;	;ld a, 0 
22e1			;	;ld a, FORTH_END_BUFFER 
22e1			;	call strlenz 
22e1			;	inc hl   ; include zero term to copy 
22e1			;	inc hl   ; include term 
22e1			;	inc hl   ; include term 
22e1			;	ld b,0 
22e1			;	ld c,l 
22e1			;	pop hl 
22e1			;	ld de, execscratch 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX3" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	ldir 
22e1			; 
22e1			; 
22e1			;	ld hl, execscratch 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EXe" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			; 
22e1			;	call forthparse 
22e1			;	call forthexec 
22e1			;;	call forthexec_cleanup 
22e1			;;	call forthparse 
22e1			;;	call forthexec 
22e1			; 
22e1			;	STACKFRAMECHK OFF $5efe $5f9f 
22e1			; 
22e1			;	; an immediate word so no need to process any more words 
22e1			;	ret 
22e1			;	NEXTW 
22e1			 
22e1			; dead code - old version  
22e1			;	FORTH_RSP_NEXT 
22e1			 
22e1			;  
22e1			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22e1			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22e1			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22e1			;	push hl 
22e1			;	push de 
22e1			;	push bc 
22e1			; 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS_KEY 
22e1			;			DMARK "EXR" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			; 
22e1			; 
22e1			; 
22e1			;	;v5 FORTH_DSP_VALUE 
22e1			;	FORTH_DSP_VALUEHL 
22e1			; 
22e1			;	; TODO do string type checks 
22e1			; 
22e1			;;v5	inc hl   ; skip type 
22e1			; 
22e1			;	push hl  ; source code  
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX1" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	ld a, 0 
22e1			;	call strlent 
22e1			; 
22e1			;	inc hl 
22e1			;	inc hl 
22e1			;	inc hl 
22e1			;	inc hl 
22e1			; 
22e1			;	push hl    ; size 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX2" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	call malloc 
22e1			; 
22e1			;	ex de, hl    ; de now contains malloc area 
22e1			;	pop bc   	; get byte count 
22e1			;	pop hl      ; get string to copy 
22e1			; 
22e1			;	push de     ; save malloc for free later 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX3" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	ldir       ; duplicate string 
22e1			; 
22e1			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
22e1			;	 
22e1			;	; TODO fix the parse would be better than this...  
22e1			;	ex de, hl 
22e1			;	dec hl 
22e1			;	ld a, 0 
22e1			;	ld (hl), a 
22e1			;	dec hl 
22e1			;	ld a, ' ' 
22e1			;	ld (hl), a 
22e1			;	dec hl 
22e1			;	ld (hl), a 
22e1			; 
22e1			;	dec hl 
22e1			;	ld (hl), a 
22e1			; 
22e1			; 
22e1			;	FORTH_DSP_POP  
22e1			; 
22e1			;	pop hl     
22e1			;	push hl    ; save malloc area 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX4" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			; 
22e1			;	call forthparse 
22e1			;	call forthexec 
22e1			;	 
22e1			;	pop hl 
22e1			;	if DEBUG_FORTH_WORDS 
22e1			;		DMARK "EX5" 
22e1			;		CALLMONITOR 
22e1			;	endif 
22e1			; 
22e1			;	if FORTH_ENABLE_FREE 
22e1			;	call free 
22e1			;	endif 
22e1			; 
22e1			;	if DEBUG_FORTH_WORDS 
22e1			;		DMARK "EX6" 
22e1			;		CALLMONITOR 
22e1			;	endif 
22e1			; 
22e1			;	pop bc 
22e1			;	pop de 
22e1			;	pop hl 
22e1			;;	FORTH_RSP_POP	  
22e1			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
22e1			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
22e1			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
22e1			; 
22e1			;	if DEBUG_FORTH_WORDS 
22e1			;		DMARK "EX7" 
22e1			;		CALLMONITOR 
22e1			;	endif 
22e1			;	NEXTW 
22e1			 
22e1			;.STKEXEC: 
22e1			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
22e1			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
22e1			; 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS_KEY 
22e1			;			DMARK "STX" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			; 
22e1			;	FORTH_DSP_VALUEHL 
22e1			; 
22e1			;	ld (store_tmp1), hl    ; count 
22e1			; 
22e1			;	FORTH_DSP_POP 
22e1			;.stkexec1: 
22e1			;	ld hl, (store_tmp1)   ; count 
22e1			;	ld a, 0 
22e1			;	cp l 
22e1			;	ret z 
22e1			; 
22e1			;	dec hl 
22e1			;	ld (store_tmp1), hl    ; count 
22e1			;	 
22e1			;	FORTH_DSP_VALUEHL 
22e1			;	push hl 
22e1			;	 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EXp" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	FORTH_DSP_POP 
22e1			; 
22e1			;	call strlenz 
22e1			;	inc hl   ; include zero term to copy 
22e1			;	inc hl   ; include zero term to copy 
22e1			;	inc hl   ; include zero term to copy 
22e1			;	ld b,0 
22e1			;	ld c,l 
22e1			;	pop hl 
22e1			;	ld de, execscratch 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EX3" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	ldir 
22e1			; 
22e1			; 
22e1			;	ld hl, execscratch 
22e1			; 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EXP" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			; 
22e1			;	call forthparse 
22e1			;	ld hl, execscratch 
22e1			;		if DEBUG_FORTH_WORDS 
22e1			;			DMARK "EXx" 
22e1			;			CALLMONITOR 
22e1			;		endif 
22e1			;	call forthexec 
22e1			; 
22e1			;	jp .stkexec1 
22e1			; 
22e1			;	ret 
22e1			 
22e1			 
22e1			.DUP: 
22e1				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
22e1 17				db WORD_SYS_CORE+OPCODE_DUP             
22e2 57 23			dw .ZDUP            
22e4 04				db 3 + 1 
22e5 .. 00			db "DUP",0              
22e9				endm 
# End of macro CWHEAD
22e9			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
22e9			 
22e9					if DEBUG_FORTH_WORDS_KEY 
22e9						DMARK "DUP" 
22e9 f5				push af  
22ea 3a fe 22			ld a, (.dmark)  
22ed 32 6e fb			ld (debug_mark),a  
22f0 3a ff 22			ld a, (.dmark+1)  
22f3 32 6f fb			ld (debug_mark+1),a  
22f6 3a 00 23			ld a, (.dmark+2)  
22f9 32 70 fb			ld (debug_mark+2),a  
22fc 18 03			jr .pastdmark  
22fe ..			.dmark: db "DUP"  
2301 f1			.pastdmark: pop af  
2302			endm  
# End of macro DMARK
2302						CALLMONITOR 
2302 cd 84 17			call break_point_state  
2305				endm  
# End of macro CALLMONITOR
2305					endif 
2305			 
2305					FORTH_DSP 
2305 cd 9e 1f			call macro_forth_dsp 
2308				endm 
# End of macro FORTH_DSP
2308			 
2308 7e					ld a, (HL) 
2309 fe 01				cp DS_TYPE_STR 
230b 20 25				jr nz, .dupinum 
230d			 
230d					; push another string 
230d			 
230d					FORTH_DSP_VALUEHL     		 
230d cd d8 1f			call macro_dsp_valuehl 
2310				endm 
# End of macro FORTH_DSP_VALUEHL
2310			 
2310				if DEBUG_FORTH_WORDS 
2310					DMARK "DUs" 
2310 f5				push af  
2311 3a 25 23			ld a, (.dmark)  
2314 32 6e fb			ld (debug_mark),a  
2317 3a 26 23			ld a, (.dmark+1)  
231a 32 6f fb			ld (debug_mark+1),a  
231d 3a 27 23			ld a, (.dmark+2)  
2320 32 70 fb			ld (debug_mark+2),a  
2323 18 03			jr .pastdmark  
2325 ..			.dmark: db "DUs"  
2328 f1			.pastdmark: pop af  
2329			endm  
# End of macro DMARK
2329					CALLMONITOR 
2329 cd 84 17			call break_point_state  
232c				endm  
# End of macro CALLMONITOR
232c				endif 
232c cd 4f 1e				call forth_push_str 
232f			 
232f					NEXTW 
232f c3 4a 21			jp macro_next 
2332				endm 
# End of macro NEXTW
2332			 
2332			 
2332			.dupinum: 
2332					 
2332			 
2332			 
2332					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2332 cd d8 1f			call macro_dsp_valuehl 
2335				endm 
# End of macro FORTH_DSP_VALUEHL
2335			 
2335				; TODO add floating point number detection 
2335			 
2335				if DEBUG_FORTH_WORDS 
2335					DMARK "DUi" 
2335 f5				push af  
2336 3a 4a 23			ld a, (.dmark)  
2339 32 6e fb			ld (debug_mark),a  
233c 3a 4b 23			ld a, (.dmark+1)  
233f 32 6f fb			ld (debug_mark+1),a  
2342 3a 4c 23			ld a, (.dmark+2)  
2345 32 70 fb			ld (debug_mark+2),a  
2348 18 03			jr .pastdmark  
234a ..			.dmark: db "DUi"  
234d f1			.pastdmark: pop af  
234e			endm  
# End of macro DMARK
234e					CALLMONITOR 
234e cd 84 17			call break_point_state  
2351				endm  
# End of macro CALLMONITOR
2351				endif 
2351			 
2351 cd e1 1d				call forth_push_numhl 
2354					NEXTW 
2354 c3 4a 21			jp macro_next 
2357				endm 
# End of macro NEXTW
2357			.ZDUP: 
2357				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2357 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2358 8f 23			dw .SWAP            
235a 05				db 4 + 1 
235b .. 00			db "?DUP",0              
2360				endm 
# End of macro CWHEAD
2360			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2360			 
2360					if DEBUG_FORTH_WORDS_KEY 
2360						DMARK "qDU" 
2360 f5				push af  
2361 3a 75 23			ld a, (.dmark)  
2364 32 6e fb			ld (debug_mark),a  
2367 3a 76 23			ld a, (.dmark+1)  
236a 32 6f fb			ld (debug_mark+1),a  
236d 3a 77 23			ld a, (.dmark+2)  
2370 32 70 fb			ld (debug_mark+2),a  
2373 18 03			jr .pastdmark  
2375 ..			.dmark: db "qDU"  
2378 f1			.pastdmark: pop af  
2379			endm  
# End of macro DMARK
2379						CALLMONITOR 
2379 cd 84 17			call break_point_state  
237c				endm  
# End of macro CALLMONITOR
237c					endif 
237c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
237c cd d8 1f			call macro_dsp_valuehl 
237f				endm 
# End of macro FORTH_DSP_VALUEHL
237f			 
237f e5					push hl 
2380			 
2380					; is it a zero? 
2380			 
2380 3e 00				ld a, 0 
2382 84					add h 
2383 85					add l 
2384			 
2384 e1					pop hl 
2385			 
2385 fe 00				cp 0 
2387 28 03				jr z, .dup2orig 
2389			 
2389			 
2389 cd e1 1d				call forth_push_numhl 
238c			 
238c			 
238c				; TODO add floating point number detection 
238c			 
238c			.dup2orig: 
238c			 
238c					NEXTW 
238c c3 4a 21			jp macro_next 
238f				endm 
# End of macro NEXTW
238f			.SWAP: 
238f				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
238f 18				db WORD_SYS_CORE+OPCODE_SWAP             
2390 ce 23			dw .COLN            
2392 05				db 4 + 1 
2393 .. 00			db "SWAP",0              
2398				endm 
# End of macro CWHEAD
2398			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2398					if DEBUG_FORTH_WORDS_KEY 
2398						DMARK "SWP" 
2398 f5				push af  
2399 3a ad 23			ld a, (.dmark)  
239c 32 6e fb			ld (debug_mark),a  
239f 3a ae 23			ld a, (.dmark+1)  
23a2 32 6f fb			ld (debug_mark+1),a  
23a5 3a af 23			ld a, (.dmark+2)  
23a8 32 70 fb			ld (debug_mark+2),a  
23ab 18 03			jr .pastdmark  
23ad ..			.dmark: db "SWP"  
23b0 f1			.pastdmark: pop af  
23b1			endm  
# End of macro DMARK
23b1						CALLMONITOR 
23b1 cd 84 17			call break_point_state  
23b4				endm  
# End of macro CALLMONITOR
23b4					endif 
23b4			 
23b4					FORTH_DSP_VALUEHL 
23b4 cd d8 1f			call macro_dsp_valuehl 
23b7				endm 
# End of macro FORTH_DSP_VALUEHL
23b7 e5					push hl     ; w2 
23b8			 
23b8					FORTH_DSP_POP 
23b8 cd 90 20			call macro_forth_dsp_pop 
23bb				endm 
# End of macro FORTH_DSP_POP
23bb			 
23bb					FORTH_DSP_VALUEHL 
23bb cd d8 1f			call macro_dsp_valuehl 
23be				endm 
# End of macro FORTH_DSP_VALUEHL
23be			 
23be					FORTH_DSP_POP 
23be cd 90 20			call macro_forth_dsp_pop 
23c1				endm 
# End of macro FORTH_DSP_POP
23c1			 
23c1 d1					pop de     ; w2	, hl = w1 
23c2			 
23c2 eb					ex de, hl 
23c3 d5					push de 
23c4			 
23c4 cd e1 1d				call forth_push_numhl 
23c7			 
23c7 e1					pop hl 
23c8			 
23c8 cd e1 1d				call forth_push_numhl 
23cb					 
23cb			 
23cb					NEXTW 
23cb c3 4a 21			jp macro_next 
23ce				endm 
# End of macro NEXTW
23ce			.COLN: 
23ce				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
23ce 19				db WORD_SYS_CORE+OPCODE_COLN             
23cf 5a 25			dw .SCOLN            
23d1 02				db 1 + 1 
23d2 .. 00			db ":",0              
23d4				endm 
# End of macro CWHEAD
23d4			; | : ( -- )         Create new word | DONE 
23d4			 
23d4					if DEBUG_FORTH_WORDS_KEY 
23d4						DMARK "CLN" 
23d4 f5				push af  
23d5 3a e9 23			ld a, (.dmark)  
23d8 32 6e fb			ld (debug_mark),a  
23db 3a ea 23			ld a, (.dmark+1)  
23de 32 6f fb			ld (debug_mark+1),a  
23e1 3a eb 23			ld a, (.dmark+2)  
23e4 32 70 fb			ld (debug_mark+2),a  
23e7 18 03			jr .pastdmark  
23e9 ..			.dmark: db "CLN"  
23ec f1			.pastdmark: pop af  
23ed			endm  
# End of macro DMARK
23ed						CALLMONITOR 
23ed cd 84 17			call break_point_state  
23f0				endm  
# End of macro CALLMONITOR
23f0					endif 
23f0				STACKFRAME OFF $8efe $989f 
23f0				if DEBUG_STACK_IMB 
23f0					if OFF 
23f0						exx 
23f0						ld de, $8efe 
23f0						ld a, d 
23f0						ld hl, curframe 
23f0						call hexout 
23f0						ld a, e 
23f0						ld hl, curframe+2 
23f0						call hexout 
23f0						ld hl, $8efe 
23f0						push hl 
23f0						ld hl, $989f 
23f0						push hl 
23f0						exx 
23f0					endif 
23f0				endif 
23f0			endm 
# End of macro STACKFRAME
23f0				; get parser buffer length  of new word 
23f0			 
23f0				 
23f0			 
23f0					; move tok past this to start of name defintition 
23f0					; TODO get word to define 
23f0					; TODO Move past word token 
23f0					; TODO get length of string up to the ';' 
23f0			 
23f0 2a 15 f1			ld hl, (os_tok_ptr) 
23f3 23				inc hl 
23f4 23				inc hl 
23f5			 
23f5 3e 3b			ld a, ';' 
23f7 cd 46 12			call strlent 
23fa			 
23fa 7d				ld a,l 
23fb 32 10 ee			ld (os_new_parse_len), a 
23fe			 
23fe			 
23fe			if DEBUG_FORTH_UWORD 
23fe ed 5b 15 f1		ld de, (os_tok_ptr) 
2402						DMARK ":01" 
2402 f5				push af  
2403 3a 17 24			ld a, (.dmark)  
2406 32 6e fb			ld (debug_mark),a  
2409 3a 18 24			ld a, (.dmark+1)  
240c 32 6f fb			ld (debug_mark+1),a  
240f 3a 19 24			ld a, (.dmark+2)  
2412 32 70 fb			ld (debug_mark+2),a  
2415 18 03			jr .pastdmark  
2417 ..			.dmark: db ":01"  
241a f1			.pastdmark: pop af  
241b			endm  
# End of macro DMARK
241b				CALLMONITOR 
241b cd 84 17			call break_point_state  
241e				endm  
# End of macro CALLMONITOR
241e			endif 
241e			 
241e			; 
241e			;  new word memory layout: 
241e			;  
241e			;    : adg 6666 ;  
241e			; 
241e			;    db   1     ; user defined word  
241e 23				inc hl    
241f			;    dw   sysdict 
241f 23				inc hl 
2420 23				inc hl 
2421			;    db <word len>+1 (for null) 
2421 23				inc hl 
2422			;    db .... <word> 
2422			; 
2422			 
2422 23				inc hl    ; some extras for the word preamble before the above 
2423 23				inc hl 
2424 23				inc hl 
2425 23				inc hl 
2426 23				inc hl 
2427 23				inc hl 
2428 23				inc hl  
2429 23				inc hl 
242a 23				inc hl 
242b 23				inc hl 
242c 23				inc hl 
242d 23				inc hl 
242e 23				inc hl 
242f 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2430			;       exec word buffer 
2430			;	<ptr word>   
2430 23				inc hl 
2431 23				inc hl 
2432			;       <word list><null term> 7F final term 
2432			 
2432			 
2432			if DEBUG_FORTH_UWORD 
2432						DMARK ":02" 
2432 f5				push af  
2433 3a 47 24			ld a, (.dmark)  
2436 32 6e fb			ld (debug_mark),a  
2439 3a 48 24			ld a, (.dmark+1)  
243c 32 6f fb			ld (debug_mark+1),a  
243f 3a 49 24			ld a, (.dmark+2)  
2442 32 70 fb			ld (debug_mark+2),a  
2445 18 03			jr .pastdmark  
2447 ..			.dmark: db ":02"  
244a f1			.pastdmark: pop af  
244b			endm  
# End of macro DMARK
244b				CALLMONITOR 
244b cd 84 17			call break_point_state  
244e				endm  
# End of macro CALLMONITOR
244e			endif 
244e			 
244e				 
244e					; malloc the size 
244e			 
244e cd a4 12				call malloc 
2451 22 12 ee				ld (os_new_malloc), hl     ; save malloc start 
2454			 
2454			;    db   1     ; user defined word  
2454 3e 01				ld a, WORD_SYS_UWORD  
2456 77					ld (hl), a 
2457				 
2457 23				inc hl    
2458			;    dw   sysdict 
2458 11 a2 22			ld de, sysdict       ; continue on with the scan to the system dict 
245b 73				ld (hl), e 
245c 23				inc hl 
245d 72				ld (hl), d 
245e 23				inc hl 
245f			 
245f			 
245f			;    Setup dict word 
245f			 
245f 23				inc hl 
2460 22 0c ee			ld (os_new_work_ptr), hl     ; save start of dict word  
2463			 
2463				; 1. get length of dict word 
2463			 
2463			 
2463 2a 15 f1			ld hl, (os_tok_ptr) 
2466 23				inc hl 
2467 23				inc hl    ; position to start of dict word 
2468 3e 00			ld a, 0 
246a cd 46 12			call strlent 
246d			 
246d			 
246d 23				inc hl    ; to include null??? 
246e			 
246e				; write length of dict word 
246e			 
246e ed 5b 0c ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2472 1b				dec de 
2473 eb				ex de, hl 
2474 73				ld (hl), e 
2475 eb				ex de, hl 
2476			 
2476				 
2476			 
2476				; copy  
2476 4d				ld c, l 
2477 06 00			ld b, 0 
2479 ed 5b 0c ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
247d 2a 15 f1			ld hl, (os_tok_ptr) 
2480 23				inc hl 
2481 23				inc hl    ; position to start of dict word 
2482				 
2482			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2482				 
2482				; TODO need to convert word to upper case 
2482			 
2482			ucasetok:	 
2482 7e				ld a,(hl) 
2483 cd 32 12			call toUpper 
2486 77				ld (hl),a 
2487 ed a0			ldi 
2489 f2 82 24		 	jp p, ucasetok 
248c			 
248c			 
248c			 
248c				; de now points to start of where the word body code should be placed 
248c ed 53 0c ee		ld (os_new_work_ptr), de 
2490				; hl now points to the words to throw at forthexec which needs to be copied 
2490 22 0a ee			ld (os_new_src_ptr), hl 
2493			 
2493				; TODO add 'call to forthexec' 
2493			 
2493			if DEBUG_FORTH_UWORD 
2493 c5				push bc 
2494 ed 4b 12 ee		ld bc, (os_new_malloc) 
2498						DMARK ":0x" 
2498 f5				push af  
2499 3a ad 24			ld a, (.dmark)  
249c 32 6e fb			ld (debug_mark),a  
249f 3a ae 24			ld a, (.dmark+1)  
24a2 32 6f fb			ld (debug_mark+1),a  
24a5 3a af 24			ld a, (.dmark+2)  
24a8 32 70 fb			ld (debug_mark+2),a  
24ab 18 03			jr .pastdmark  
24ad ..			.dmark: db ":0x"  
24b0 f1			.pastdmark: pop af  
24b1			endm  
# End of macro DMARK
24b1				CALLMONITOR 
24b1 cd 84 17			call break_point_state  
24b4				endm  
# End of macro CALLMONITOR
24b4 c1				pop bc 
24b5			endif 
24b5			 
24b5			 
24b5				; create word preamble which should be: 
24b5			 
24b5			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
24b5			 
24b5				;    ld hl, <word code> 
24b5				;    jp user_exec 
24b5			        ;    <word code bytes> 
24b5			 
24b5			 
24b5			;	inc de     ; TODO ??? or are we already past the word's null 
24b5 eb				ex de, hl 
24b6			 
24b6 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
24b8			 
24b8 23				inc hl 
24b9 22 06 ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
24bc 23				inc hl 
24bd			 
24bd 23				inc hl 
24be 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
24c0			 
24c0 01 f6 52			ld bc, user_exec 
24c3 23				inc hl 
24c4 71				ld (hl), c     ; poke address of user_exec 
24c5 23				inc hl 
24c6 70				ld (hl), b     
24c7			 ; 
24c7			;	inc hl 
24c7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24c7			; 
24c7			; 
24c7			;	ld bc, macro_forth_rsp_next 
24c7			;	inc hl 
24c7			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
24c7			;	inc hl 
24c7			;	ld (hl), b     
24c7			 ; 
24c7			;	inc hl 
24c7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24c7			; 
24c7			; 
24c7			;	inc hl 
24c7			;	ld bc, forthexec 
24c7			;	ld (hl), c     ; poke address of forthexec 
24c7			;	inc hl 
24c7			;	ld (hl), b      
24c7			; 
24c7			;	inc hl 
24c7			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
24c7			; 
24c7			;	ld bc, user_dict_next 
24c7			;	inc hl 
24c7			;	ld (hl), c     ; poke address of forthexec 
24c7			;	inc hl 
24c7			;	ld (hl), b      
24c7			 
24c7				; hl is now where we need to copy the word byte data to save this 
24c7			 
24c7 23				inc hl 
24c8 22 08 ee			ld (os_new_exec), hl 
24cb				 
24cb				; copy definition 
24cb			 
24cb eb				ex de, hl 
24cc			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
24cc			;	inc de    ; skip the PC for this parse 
24cc 3a 10 ee			ld a, (os_new_parse_len) 
24cf 4f				ld c, a 
24d0 06 00			ld b, 0 
24d2 ed b0			ldir		 ; copy defintion 
24d4			 
24d4			 
24d4				; poke the address of where the new word bytes live for forthexec 
24d4			 
24d4 2a 06 ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
24d7			 
24d7 ed 5b 08 ee		ld de, (os_new_exec)      
24db				 
24db 73				ld (hl), e 
24dc 23				inc hl 
24dd 72				ld (hl), d 
24de			 
24de					; TODO copy last user dict word next link to this word 
24de					; TODO update last user dict word to point to this word 
24de			; 
24de			; hl f923 de 812a ; bc 811a 
24de			 
24de			if DEBUG_FORTH_UWORD 
24de c5				push bc 
24df ed 4b 12 ee		ld bc, (os_new_malloc) 
24e3						DMARK ":0A" 
24e3 f5				push af  
24e4 3a f8 24			ld a, (.dmark)  
24e7 32 6e fb			ld (debug_mark),a  
24ea 3a f9 24			ld a, (.dmark+1)  
24ed 32 6f fb			ld (debug_mark+1),a  
24f0 3a fa 24			ld a, (.dmark+2)  
24f3 32 70 fb			ld (debug_mark+2),a  
24f6 18 03			jr .pastdmark  
24f8 ..			.dmark: db ":0A"  
24fb f1			.pastdmark: pop af  
24fc			endm  
# End of macro DMARK
24fc				CALLMONITOR 
24fc cd 84 17			call break_point_state  
24ff				endm  
# End of macro CALLMONITOR
24ff c1				pop bc 
2500			endif 
2500			if DEBUG_FORTH_UWORD 
2500 c5				push bc 
2501 ed 4b 12 ee		ld bc, (os_new_malloc) 
2505 03				inc bc 
2506 03				inc bc 
2507 03				inc bc 
2508 03				inc bc 
2509 03				inc bc 
250a 03				inc bc 
250b 03				inc bc 
250c 03				inc bc 
250d			 
250d						DMARK ":0B" 
250d f5				push af  
250e 3a 22 25			ld a, (.dmark)  
2511 32 6e fb			ld (debug_mark),a  
2514 3a 23 25			ld a, (.dmark+1)  
2517 32 6f fb			ld (debug_mark+1),a  
251a 3a 24 25			ld a, (.dmark+2)  
251d 32 70 fb			ld (debug_mark+2),a  
2520 18 03			jr .pastdmark  
2522 ..			.dmark: db ":0B"  
2525 f1			.pastdmark: pop af  
2526			endm  
# End of macro DMARK
2526				CALLMONITOR 
2526 cd 84 17			call break_point_state  
2529				endm  
# End of macro CALLMONITOR
2529 c1				pop bc 
252a			endif 
252a			 
252a			; update word dict linked list for new word 
252a			 
252a			 
252a 2a 11 f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
252d 23			inc hl     ; move to next work linked list ptr 
252e			 
252e ed 5b 12 ee	ld de, (os_new_malloc)		 ; new next word 
2532 73			ld (hl), e 
2533 23			inc hl 
2534 72			ld (hl), d 
2535			 
2535			if DEBUG_FORTH_UWORD 
2535 ed 4b 11 f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2539			endif 
2539			 
2539 ed 53 11 f1	ld (os_last_new_uword), de      ; update last new uword ptr 
253d			 
253d			 
253d			if DEBUG_FORTH_UWORD 
253d						DMARK ":0+" 
253d f5				push af  
253e 3a 52 25			ld a, (.dmark)  
2541 32 6e fb			ld (debug_mark),a  
2544 3a 53 25			ld a, (.dmark+1)  
2547 32 6f fb			ld (debug_mark+1),a  
254a 3a 54 25			ld a, (.dmark+2)  
254d 32 70 fb			ld (debug_mark+2),a  
2550 18 03			jr .pastdmark  
2552 ..			.dmark: db ":0+"  
2555 f1			.pastdmark: pop af  
2556			endm  
# End of macro DMARK
2556				CALLMONITOR 
2556 cd 84 17			call break_point_state  
2559				endm  
# End of macro CALLMONITOR
2559			endif 
2559			 
2559				STACKFRAMECHK OFF $8efe $989f 
2559				if DEBUG_STACK_IMB 
2559					if OFF 
2559						exx 
2559						ld hl, $989f 
2559						pop de   ; $989f 
2559						call cmp16 
2559						jr nz, .spnosame 
2559						ld hl, $8efe 
2559						pop de   ; $8efe 
2559						call cmp16 
2559						jr z, .spfrsame 
2559						.spnosame: call showsperror 
2559						.spfrsame: nop 
2559						exx 
2559					endif 
2559				endif 
2559			endm 
# End of macro STACKFRAMECHK
2559			 
2559 c9			ret    ; dont process any remaining parser tokens as they form new word 
255a			 
255a			 
255a			 
255a			 
255a			;		NEXT 
255a			.SCOLN: 
255a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
255a 06				db OPCODE_SCOLN 
255b a6 25			dw .DROP 
255d 02				db 2 
255e .. 00			db ";",0           
2560			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2560					if DEBUG_FORTH_WORDS_KEY 
2560						DMARK "SCN" 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 6e fb			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 6f fb			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 70 fb			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db "SCN"  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579						CALLMONITOR 
2579 cd 84 17			call break_point_state  
257c				endm  
# End of macro CALLMONITOR
257c					endif 
257c					FORTH_RSP_TOS 
257c cd 9f 1d			call macro_forth_rsp_tos 
257f				endm 
# End of macro FORTH_RSP_TOS
257f e5					push hl 
2580					FORTH_RSP_POP 
2580 cd a9 1d			call macro_forth_rsp_pop 
2583				endm 
# End of macro FORTH_RSP_POP
2583 e1					pop hl 
2584			;		ex de,hl 
2584 22 15 f1				ld (os_tok_ptr),hl 
2587			 
2587			if DEBUG_FORTH_UWORD 
2587						DMARK "SCL" 
2587 f5				push af  
2588 3a 9c 25			ld a, (.dmark)  
258b 32 6e fb			ld (debug_mark),a  
258e 3a 9d 25			ld a, (.dmark+1)  
2591 32 6f fb			ld (debug_mark+1),a  
2594 3a 9e 25			ld a, (.dmark+2)  
2597 32 70 fb			ld (debug_mark+2),a  
259a 18 03			jr .pastdmark  
259c ..			.dmark: db "SCL"  
259f f1			.pastdmark: pop af  
25a0			endm  
# End of macro DMARK
25a0				CALLMONITOR 
25a0 cd 84 17			call break_point_state  
25a3				endm  
# End of macro CALLMONITOR
25a3			endif 
25a3					NEXTW 
25a3 c3 4a 21			jp macro_next 
25a6				endm 
# End of macro NEXTW
25a6			 
25a6			.DROP: 
25a6				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
25a6 1b				db WORD_SYS_CORE+OPCODE_DROP             
25a7 d1 25			dw .DUP2            
25a9 05				db 4 + 1 
25aa .. 00			db "DROP",0              
25af				endm 
# End of macro CWHEAD
25af			; | DROP ( w -- )   drop the TOS item   | DONE 
25af					if DEBUG_FORTH_WORDS_KEY 
25af						DMARK "DRP" 
25af f5				push af  
25b0 3a c4 25			ld a, (.dmark)  
25b3 32 6e fb			ld (debug_mark),a  
25b6 3a c5 25			ld a, (.dmark+1)  
25b9 32 6f fb			ld (debug_mark+1),a  
25bc 3a c6 25			ld a, (.dmark+2)  
25bf 32 70 fb			ld (debug_mark+2),a  
25c2 18 03			jr .pastdmark  
25c4 ..			.dmark: db "DRP"  
25c7 f1			.pastdmark: pop af  
25c8			endm  
# End of macro DMARK
25c8						CALLMONITOR 
25c8 cd 84 17			call break_point_state  
25cb				endm  
# End of macro CALLMONITOR
25cb					endif 
25cb					FORTH_DSP_POP 
25cb cd 90 20			call macro_forth_dsp_pop 
25ce				endm 
# End of macro FORTH_DSP_POP
25ce					NEXTW 
25ce c3 4a 21			jp macro_next 
25d1				endm 
# End of macro NEXTW
25d1			.DUP2: 
25d1				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
25d1 1c				db WORD_SYS_CORE+OPCODE_DUP2             
25d2 16 26			dw .DROP2            
25d4 05				db 4 + 1 
25d5 .. 00			db "2DUP",0              
25da				endm 
# End of macro CWHEAD
25da			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
25da					if DEBUG_FORTH_WORDS_KEY 
25da						DMARK "2DU" 
25da f5				push af  
25db 3a ef 25			ld a, (.dmark)  
25de 32 6e fb			ld (debug_mark),a  
25e1 3a f0 25			ld a, (.dmark+1)  
25e4 32 6f fb			ld (debug_mark+1),a  
25e7 3a f1 25			ld a, (.dmark+2)  
25ea 32 70 fb			ld (debug_mark+2),a  
25ed 18 03			jr .pastdmark  
25ef ..			.dmark: db "2DU"  
25f2 f1			.pastdmark: pop af  
25f3			endm  
# End of macro DMARK
25f3						CALLMONITOR 
25f3 cd 84 17			call break_point_state  
25f6				endm  
# End of macro CALLMONITOR
25f6					endif 
25f6					FORTH_DSP_VALUEHL 
25f6 cd d8 1f			call macro_dsp_valuehl 
25f9				endm 
# End of macro FORTH_DSP_VALUEHL
25f9 e5					push hl      ; 2 
25fa			 
25fa					FORTH_DSP_POP 
25fa cd 90 20			call macro_forth_dsp_pop 
25fd				endm 
# End of macro FORTH_DSP_POP
25fd					 
25fd					FORTH_DSP_VALUEHL 
25fd cd d8 1f			call macro_dsp_valuehl 
2600				endm 
# End of macro FORTH_DSP_VALUEHL
2600			;		push hl      ; 1 
2600			 
2600					FORTH_DSP_POP 
2600 cd 90 20			call macro_forth_dsp_pop 
2603				endm 
# End of macro FORTH_DSP_POP
2603			 
2603			;		pop hl       ; 1 
2603 d1					pop de       ; 2 
2604			 
2604 cd e1 1d				call forth_push_numhl 
2607 eb					ex de, hl 
2608 cd e1 1d				call forth_push_numhl 
260b			 
260b					 
260b eb					ex de, hl 
260c			 
260c cd e1 1d				call forth_push_numhl 
260f eb					ex de, hl 
2610 cd e1 1d				call forth_push_numhl 
2613			 
2613			 
2613					NEXTW 
2613 c3 4a 21			jp macro_next 
2616				endm 
# End of macro NEXTW
2616			.DROP2: 
2616				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2616 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2617 45 26			dw .SWAP2            
2619 06				db 5 + 1 
261a .. 00			db "2DROP",0              
2620				endm 
# End of macro CWHEAD
2620			; | 2DROP ( w w -- )    Double drop | DONE 
2620					if DEBUG_FORTH_WORDS_KEY 
2620						DMARK "2DR" 
2620 f5				push af  
2621 3a 35 26			ld a, (.dmark)  
2624 32 6e fb			ld (debug_mark),a  
2627 3a 36 26			ld a, (.dmark+1)  
262a 32 6f fb			ld (debug_mark+1),a  
262d 3a 37 26			ld a, (.dmark+2)  
2630 32 70 fb			ld (debug_mark+2),a  
2633 18 03			jr .pastdmark  
2635 ..			.dmark: db "2DR"  
2638 f1			.pastdmark: pop af  
2639			endm  
# End of macro DMARK
2639						CALLMONITOR 
2639 cd 84 17			call break_point_state  
263c				endm  
# End of macro CALLMONITOR
263c					endif 
263c					FORTH_DSP_POP 
263c cd 90 20			call macro_forth_dsp_pop 
263f				endm 
# End of macro FORTH_DSP_POP
263f					FORTH_DSP_POP 
263f cd 90 20			call macro_forth_dsp_pop 
2642				endm 
# End of macro FORTH_DSP_POP
2642					NEXTW 
2642 c3 4a 21			jp macro_next 
2645				endm 
# End of macro NEXTW
2645			.SWAP2: 
2645				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2645 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2646 6e 26			dw .AT            
2648 06				db 5 + 1 
2649 .. 00			db "2SWAP",0              
264f				endm 
# End of macro CWHEAD
264f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
264f					if DEBUG_FORTH_WORDS_KEY 
264f						DMARK "2SW" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 6e fb			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 6f fb			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 70 fb			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "2SW"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668						CALLMONITOR 
2668 cd 84 17			call break_point_state  
266b				endm  
# End of macro CALLMONITOR
266b					endif 
266b					NEXTW 
266b c3 4a 21			jp macro_next 
266e				endm 
# End of macro NEXTW
266e			.AT: 
266e				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
266e 1f				db WORD_SYS_CORE+OPCODE_AT             
266f a0 26			dw .CAT            
2671 02				db 1 + 1 
2672 .. 00			db "@",0              
2674				endm 
# End of macro CWHEAD
2674			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2674			 
2674					if DEBUG_FORTH_WORDS_KEY 
2674						DMARK "AT." 
2674 f5				push af  
2675 3a 89 26			ld a, (.dmark)  
2678 32 6e fb			ld (debug_mark),a  
267b 3a 8a 26			ld a, (.dmark+1)  
267e 32 6f fb			ld (debug_mark+1),a  
2681 3a 8b 26			ld a, (.dmark+2)  
2684 32 70 fb			ld (debug_mark+2),a  
2687 18 03			jr .pastdmark  
2689 ..			.dmark: db "AT."  
268c f1			.pastdmark: pop af  
268d			endm  
# End of macro DMARK
268d						CALLMONITOR 
268d cd 84 17			call break_point_state  
2690				endm  
# End of macro CALLMONITOR
2690					endif 
2690			.getbyteat:	 
2690					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2690 cd d8 1f			call macro_dsp_valuehl 
2693				endm 
# End of macro FORTH_DSP_VALUEHL
2693					 
2693			;		push hl 
2693				 
2693					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2693 cd 90 20			call macro_forth_dsp_pop 
2696				endm 
# End of macro FORTH_DSP_POP
2696			 
2696			;		pop hl 
2696			 
2696 7e					ld a, (hl) 
2697			 
2697 6f					ld l, a 
2698 26 00				ld h, 0 
269a cd e1 1d				call forth_push_numhl 
269d			 
269d					NEXTW 
269d c3 4a 21			jp macro_next 
26a0				endm 
# End of macro NEXTW
26a0			.CAT: 
26a0				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
26a0 20				db WORD_SYS_CORE+OPCODE_CAT             
26a1 c9 26			dw .BANG            
26a3 03				db 2 + 1 
26a4 .. 00			db "C@",0              
26a7				endm 
# End of macro CWHEAD
26a7			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
26a7					if DEBUG_FORTH_WORDS_KEY 
26a7						DMARK "CAA" 
26a7 f5				push af  
26a8 3a bc 26			ld a, (.dmark)  
26ab 32 6e fb			ld (debug_mark),a  
26ae 3a bd 26			ld a, (.dmark+1)  
26b1 32 6f fb			ld (debug_mark+1),a  
26b4 3a be 26			ld a, (.dmark+2)  
26b7 32 70 fb			ld (debug_mark+2),a  
26ba 18 03			jr .pastdmark  
26bc ..			.dmark: db "CAA"  
26bf f1			.pastdmark: pop af  
26c0			endm  
# End of macro DMARK
26c0						CALLMONITOR 
26c0 cd 84 17			call break_point_state  
26c3				endm  
# End of macro CALLMONITOR
26c3					endif 
26c3 c3 90 26				jp .getbyteat 
26c6					NEXTW 
26c6 c3 4a 21			jp macro_next 
26c9				endm 
# End of macro NEXTW
26c9			.BANG: 
26c9				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
26c9 21				db WORD_SYS_CORE+OPCODE_BANG             
26ca ff 26			dw .CBANG            
26cc 02				db 1 + 1 
26cd .. 00			db "!",0              
26cf				endm 
# End of macro CWHEAD
26cf			; | ! ( x w -- ) Store x at address w      | DONE 
26cf					if DEBUG_FORTH_WORDS_KEY 
26cf						DMARK "BNG" 
26cf f5				push af  
26d0 3a e4 26			ld a, (.dmark)  
26d3 32 6e fb			ld (debug_mark),a  
26d6 3a e5 26			ld a, (.dmark+1)  
26d9 32 6f fb			ld (debug_mark+1),a  
26dc 3a e6 26			ld a, (.dmark+2)  
26df 32 70 fb			ld (debug_mark+2),a  
26e2 18 03			jr .pastdmark  
26e4 ..			.dmark: db "BNG"  
26e7 f1			.pastdmark: pop af  
26e8			endm  
# End of macro DMARK
26e8						CALLMONITOR 
26e8 cd 84 17			call break_point_state  
26eb				endm  
# End of macro CALLMONITOR
26eb					endif 
26eb			 
26eb			.storebyteat:		 
26eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26eb cd d8 1f			call macro_dsp_valuehl 
26ee				endm 
# End of macro FORTH_DSP_VALUEHL
26ee					 
26ee e5					push hl 
26ef				 
26ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ef cd 90 20			call macro_forth_dsp_pop 
26f2				endm 
# End of macro FORTH_DSP_POP
26f2			 
26f2					; get byte to poke 
26f2			 
26f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f2 cd d8 1f			call macro_dsp_valuehl 
26f5				endm 
# End of macro FORTH_DSP_VALUEHL
26f5 e5					push hl 
26f6			 
26f6			 
26f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f6 cd 90 20			call macro_forth_dsp_pop 
26f9				endm 
# End of macro FORTH_DSP_POP
26f9			 
26f9			 
26f9 d1					pop de 
26fa e1					pop hl 
26fb			 
26fb 73					ld (hl),e 
26fc			 
26fc			 
26fc					NEXTW 
26fc c3 4a 21			jp macro_next 
26ff				endm 
# End of macro NEXTW
26ff			.CBANG: 
26ff				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
26ff 22				db WORD_SYS_CORE+OPCODE_CBANG             
2700 28 27			dw .SCALL            
2702 03				db 2 + 1 
2703 .. 00			db "C!",0              
2706				endm 
# End of macro CWHEAD
2706			; | C!  ( x w -- ) Store x at address w  | DONE 
2706					if DEBUG_FORTH_WORDS_KEY 
2706						DMARK "CBA" 
2706 f5				push af  
2707 3a 1b 27			ld a, (.dmark)  
270a 32 6e fb			ld (debug_mark),a  
270d 3a 1c 27			ld a, (.dmark+1)  
2710 32 6f fb			ld (debug_mark+1),a  
2713 3a 1d 27			ld a, (.dmark+2)  
2716 32 70 fb			ld (debug_mark+2),a  
2719 18 03			jr .pastdmark  
271b ..			.dmark: db "CBA"  
271e f1			.pastdmark: pop af  
271f			endm  
# End of macro DMARK
271f						CALLMONITOR 
271f cd 84 17			call break_point_state  
2722				endm  
# End of macro CALLMONITOR
2722					endif 
2722 c3 eb 26				jp .storebyteat 
2725					NEXTW 
2725 c3 4a 21			jp macro_next 
2728				endm 
# End of macro NEXTW
2728			.SCALL: 
2728				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2728 23				db WORD_SYS_CORE+OPCODE_SCALL             
2729 5c 27			dw .DEPTH            
272b 05				db 4 + 1 
272c .. 00			db "CALL",0              
2731				endm 
# End of macro CWHEAD
2731			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2731					if DEBUG_FORTH_WORDS_KEY 
2731						DMARK "CLL" 
2731 f5				push af  
2732 3a 46 27			ld a, (.dmark)  
2735 32 6e fb			ld (debug_mark),a  
2738 3a 47 27			ld a, (.dmark+1)  
273b 32 6f fb			ld (debug_mark+1),a  
273e 3a 48 27			ld a, (.dmark+2)  
2741 32 70 fb			ld (debug_mark+2),a  
2744 18 03			jr .pastdmark  
2746 ..			.dmark: db "CLL"  
2749 f1			.pastdmark: pop af  
274a			endm  
# End of macro DMARK
274a						CALLMONITOR 
274a cd 84 17			call break_point_state  
274d				endm  
# End of macro CALLMONITOR
274d					endif 
274d			 
274d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274d cd d8 1f			call macro_dsp_valuehl 
2750				endm 
# End of macro FORTH_DSP_VALUEHL
2750			 
2750			;		push hl 
2750			 
2750					; destroy value TOS 
2750			 
2750					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2750 cd 90 20			call macro_forth_dsp_pop 
2753				endm 
# End of macro FORTH_DSP_POP
2753			 
2753						 
2753			;		pop hl 
2753			 
2753					; how to do a call with hl???? save SP? 
2753 cd f3 20				call forth_call_hl 
2756			 
2756			 
2756					; TODO push value back onto stack for another op etc 
2756			 
2756 cd e1 1d				call forth_push_numhl 
2759					NEXTW 
2759 c3 4a 21			jp macro_next 
275c				endm 
# End of macro NEXTW
275c			.DEPTH: 
275c				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
275c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
275d 99 27			dw .OVER            
275f 06				db 5 + 1 
2760 .. 00			db "DEPTH",0              
2766				endm 
# End of macro CWHEAD
2766			; | DEPTH ( -- u ) Push count of stack | DONE 
2766					; take current TOS and remove from base value div by two to get count 
2766					if DEBUG_FORTH_WORDS_KEY 
2766						DMARK "DEP" 
2766 f5				push af  
2767 3a 7b 27			ld a, (.dmark)  
276a 32 6e fb			ld (debug_mark),a  
276d 3a 7c 27			ld a, (.dmark+1)  
2770 32 6f fb			ld (debug_mark+1),a  
2773 3a 7d 27			ld a, (.dmark+2)  
2776 32 70 fb			ld (debug_mark+2),a  
2779 18 03			jr .pastdmark  
277b ..			.dmark: db "DEP"  
277e f1			.pastdmark: pop af  
277f			endm  
# End of macro DMARK
277f						CALLMONITOR 
277f cd 84 17			call break_point_state  
2782				endm  
# End of macro CALLMONITOR
2782					endif 
2782			 
2782			 
2782 2a 01 f8			ld hl, (cli_data_sp) 
2785 11 7b f3			ld de, cli_data_stack 
2788 ed 52			sbc hl,de 
278a				 
278a				; div by size of stack item 
278a			 
278a 5d				ld e,l 
278b 0e 03			ld c, 3 
278d cd 6d 0d			call Div8 
2790			 
2790 6f				ld l,a 
2791 26 00			ld h,0 
2793			 
2793				;srl h 
2793				;rr l 
2793			 
2793 cd e1 1d				call forth_push_numhl 
2796					NEXTW 
2796 c3 4a 21			jp macro_next 
2799				endm 
# End of macro NEXTW
2799			.OVER: 
2799				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2799 42				db WORD_SYS_CORE+46             
279a e0 27			dw .PAUSE            
279c 05				db 4 + 1 
279d .. 00			db "OVER",0              
27a2				endm 
# End of macro CWHEAD
27a2			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
27a2					if DEBUG_FORTH_WORDS_KEY 
27a2						DMARK "OVR" 
27a2 f5				push af  
27a3 3a b7 27			ld a, (.dmark)  
27a6 32 6e fb			ld (debug_mark),a  
27a9 3a b8 27			ld a, (.dmark+1)  
27ac 32 6f fb			ld (debug_mark+1),a  
27af 3a b9 27			ld a, (.dmark+2)  
27b2 32 70 fb			ld (debug_mark+2),a  
27b5 18 03			jr .pastdmark  
27b7 ..			.dmark: db "OVR"  
27ba f1			.pastdmark: pop af  
27bb			endm  
# End of macro DMARK
27bb						CALLMONITOR 
27bb cd 84 17			call break_point_state  
27be				endm  
# End of macro CALLMONITOR
27be					endif 
27be			 
27be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27be cd d8 1f			call macro_dsp_valuehl 
27c1				endm 
# End of macro FORTH_DSP_VALUEHL
27c1 e5					push hl    ; n2 
27c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c2 cd 90 20			call macro_forth_dsp_pop 
27c5				endm 
# End of macro FORTH_DSP_POP
27c5			 
27c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c5 cd d8 1f			call macro_dsp_valuehl 
27c8				endm 
# End of macro FORTH_DSP_VALUEHL
27c8 e5					push hl    ; n1 
27c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c9 cd 90 20			call macro_forth_dsp_pop 
27cc				endm 
# End of macro FORTH_DSP_POP
27cc			 
27cc d1					pop de     ; n1 
27cd e1					pop hl     ; n2 
27ce			 
27ce d5					push de 
27cf e5					push hl 
27d0 d5					push de 
27d1			 
27d1					; push back  
27d1			 
27d1 e1					pop hl 
27d2 cd e1 1d				call forth_push_numhl 
27d5 e1					pop hl 
27d6 cd e1 1d				call forth_push_numhl 
27d9 e1					pop hl 
27da cd e1 1d				call forth_push_numhl 
27dd					NEXTW 
27dd c3 4a 21			jp macro_next 
27e0				endm 
# End of macro NEXTW
27e0			 
27e0			.PAUSE: 
27e0				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
27e0 43				db WORD_SYS_CORE+47             
27e1 15 28			dw .PAUSES            
27e3 08				db 7 + 1 
27e4 .. 00			db "PAUSEMS",0              
27ec				endm 
# End of macro CWHEAD
27ec			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
27ec					if DEBUG_FORTH_WORDS_KEY 
27ec						DMARK "PMS" 
27ec f5				push af  
27ed 3a 01 28			ld a, (.dmark)  
27f0 32 6e fb			ld (debug_mark),a  
27f3 3a 02 28			ld a, (.dmark+1)  
27f6 32 6f fb			ld (debug_mark+1),a  
27f9 3a 03 28			ld a, (.dmark+2)  
27fc 32 70 fb			ld (debug_mark+2),a  
27ff 18 03			jr .pastdmark  
2801 ..			.dmark: db "PMS"  
2804 f1			.pastdmark: pop af  
2805			endm  
# End of macro DMARK
2805						CALLMONITOR 
2805 cd 84 17			call break_point_state  
2808				endm  
# End of macro CALLMONITOR
2808					endif 
2808					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2808 cd d8 1f			call macro_dsp_valuehl 
280b				endm 
# End of macro FORTH_DSP_VALUEHL
280b			;		push hl    ; n2 
280b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
280b cd 90 20			call macro_forth_dsp_pop 
280e				endm 
# End of macro FORTH_DSP_POP
280e			;		pop hl 
280e			 
280e 7d					ld a, l 
280f cd 0b 0b				call aDelayInMS 
2812				       NEXTW 
2812 c3 4a 21			jp macro_next 
2815				endm 
# End of macro NEXTW
2815			.PAUSES:  
2815				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2815 44				db WORD_SYS_CORE+48             
2816 84 28			dw .ROT            
2818 06				db 5 + 1 
2819 .. 00			db "PAUSE",0              
281f				endm 
# End of macro CWHEAD
281f			; | PAUSE ( n -- )  Pause for n seconds | DONE 
281f					if DEBUG_FORTH_WORDS_KEY 
281f						DMARK "PAU" 
281f f5				push af  
2820 3a 34 28			ld a, (.dmark)  
2823 32 6e fb			ld (debug_mark),a  
2826 3a 35 28			ld a, (.dmark+1)  
2829 32 6f fb			ld (debug_mark+1),a  
282c 3a 36 28			ld a, (.dmark+2)  
282f 32 70 fb			ld (debug_mark+2),a  
2832 18 03			jr .pastdmark  
2834 ..			.dmark: db "PAU"  
2837 f1			.pastdmark: pop af  
2838			endm  
# End of macro DMARK
2838						CALLMONITOR 
2838 cd 84 17			call break_point_state  
283b				endm  
# End of macro CALLMONITOR
283b					endif 
283b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
283b cd d8 1f			call macro_dsp_valuehl 
283e				endm 
# End of macro FORTH_DSP_VALUEHL
283e			;		push hl    ; n2 
283e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
283e cd 90 20			call macro_forth_dsp_pop 
2841				endm 
# End of macro FORTH_DSP_POP
2841			;		pop hl 
2841 45					ld b, l 
2842					if DEBUG_FORTH_WORDS 
2842						DMARK "PAU" 
2842 f5				push af  
2843 3a 57 28			ld a, (.dmark)  
2846 32 6e fb			ld (debug_mark),a  
2849 3a 58 28			ld a, (.dmark+1)  
284c 32 6f fb			ld (debug_mark+1),a  
284f 3a 59 28			ld a, (.dmark+2)  
2852 32 70 fb			ld (debug_mark+2),a  
2855 18 03			jr .pastdmark  
2857 ..			.dmark: db "PAU"  
285a f1			.pastdmark: pop af  
285b			endm  
# End of macro DMARK
285b						CALLMONITOR 
285b cd 84 17			call break_point_state  
285e				endm  
# End of macro CALLMONITOR
285e					endif 
285e c5			.pauses1:	push bc 
285f cd 26 0b				call delay1s 
2862 c1					pop bc 
2863					if DEBUG_FORTH_WORDS 
2863						DMARK "PA1" 
2863 f5				push af  
2864 3a 78 28			ld a, (.dmark)  
2867 32 6e fb			ld (debug_mark),a  
286a 3a 79 28			ld a, (.dmark+1)  
286d 32 6f fb			ld (debug_mark+1),a  
2870 3a 7a 28			ld a, (.dmark+2)  
2873 32 70 fb			ld (debug_mark+2),a  
2876 18 03			jr .pastdmark  
2878 ..			.dmark: db "PA1"  
287b f1			.pastdmark: pop af  
287c			endm  
# End of macro DMARK
287c						CALLMONITOR 
287c cd 84 17			call break_point_state  
287f				endm  
# End of macro CALLMONITOR
287f					endif 
287f 10 dd				djnz .pauses1 
2881			 
2881				       NEXTW 
2881 c3 4a 21			jp macro_next 
2884				endm 
# End of macro NEXTW
2884			.ROT: 
2884				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2884 45				db WORD_SYS_CORE+49             
2885 d2 28			dw .UWORDS            
2887 04				db 3 + 1 
2888 .. 00			db "ROT",0              
288c				endm 
# End of macro CWHEAD
288c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
288c					if DEBUG_FORTH_WORDS_KEY 
288c						DMARK "ROT" 
288c f5				push af  
288d 3a a1 28			ld a, (.dmark)  
2890 32 6e fb			ld (debug_mark),a  
2893 3a a2 28			ld a, (.dmark+1)  
2896 32 6f fb			ld (debug_mark+1),a  
2899 3a a3 28			ld a, (.dmark+2)  
289c 32 70 fb			ld (debug_mark+2),a  
289f 18 03			jr .pastdmark  
28a1 ..			.dmark: db "ROT"  
28a4 f1			.pastdmark: pop af  
28a5			endm  
# End of macro DMARK
28a5						CALLMONITOR 
28a5 cd 84 17			call break_point_state  
28a8				endm  
# End of macro CALLMONITOR
28a8					endif 
28a8			 
28a8					FORTH_DSP_VALUEHL 
28a8 cd d8 1f			call macro_dsp_valuehl 
28ab				endm 
# End of macro FORTH_DSP_VALUEHL
28ab e5					push hl    ; u3  
28ac			 
28ac					FORTH_DSP_POP 
28ac cd 90 20			call macro_forth_dsp_pop 
28af				endm 
# End of macro FORTH_DSP_POP
28af			   
28af					FORTH_DSP_VALUEHL 
28af cd d8 1f			call macro_dsp_valuehl 
28b2				endm 
# End of macro FORTH_DSP_VALUEHL
28b2 e5					push hl     ; u2 
28b3			 
28b3					FORTH_DSP_POP 
28b3 cd 90 20			call macro_forth_dsp_pop 
28b6				endm 
# End of macro FORTH_DSP_POP
28b6			 
28b6					FORTH_DSP_VALUEHL 
28b6 cd d8 1f			call macro_dsp_valuehl 
28b9				endm 
# End of macro FORTH_DSP_VALUEHL
28b9 e5					push hl     ; u1 
28ba			 
28ba					FORTH_DSP_POP 
28ba cd 90 20			call macro_forth_dsp_pop 
28bd				endm 
# End of macro FORTH_DSP_POP
28bd			 
28bd c1					pop bc      ; u1 
28be e1					pop hl      ; u2 
28bf d1					pop de      ; u3 
28c0			 
28c0			 
28c0 c5					push bc 
28c1 d5					push de 
28c2 e5					push hl 
28c3			 
28c3			 
28c3 e1					pop hl 
28c4 cd e1 1d				call forth_push_numhl 
28c7			 
28c7 e1					pop hl 
28c8 cd e1 1d				call forth_push_numhl 
28cb			 
28cb e1					pop hl 
28cc cd e1 1d				call forth_push_numhl 
28cf					 
28cf			 
28cf			 
28cf			 
28cf			 
28cf			 
28cf				       NEXTW 
28cf c3 4a 21			jp macro_next 
28d2				endm 
# End of macro NEXTW
28d2			 
28d2			.UWORDS: 
28d2				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28d2 50				db WORD_SYS_CORE+60             
28d3 94 29			dw .BP            
28d5 07				db 6 + 1 
28d6 .. 00			db "UWORDS",0              
28dd				endm 
# End of macro CWHEAD
28dd			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
28dd			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
28dd			; | | Following the count are the individual words. 
28dd			; | | 
28dd			; | | e.g. UWORDS 
28dd			; | | BOX DIRLIST 2 
28dd			; | |  
28dd			; | | Can be used to save the words to storage via: 
28dd			; | | UWORDS $01 DO $01 APPEND LOOP 
28dd				if DEBUG_FORTH_WORDS_KEY 
28dd					DMARK "UWR" 
28dd f5				push af  
28de 3a f2 28			ld a, (.dmark)  
28e1 32 6e fb			ld (debug_mark),a  
28e4 3a f3 28			ld a, (.dmark+1)  
28e7 32 6f fb			ld (debug_mark+1),a  
28ea 3a f4 28			ld a, (.dmark+2)  
28ed 32 70 fb			ld (debug_mark+2),a  
28f0 18 03			jr .pastdmark  
28f2 ..			.dmark: db "UWR"  
28f5 f1			.pastdmark: pop af  
28f6			endm  
# End of macro DMARK
28f6					CALLMONITOR 
28f6 cd 84 17			call break_point_state  
28f9				endm  
# End of macro CALLMONITOR
28f9				endif 
28f9 21 00 80				ld hl, baseram 
28fc					;ld hl, baseusermem 
28fc 01 00 00				ld bc, 0    ; start a counter 
28ff			 
28ff				; skip dict stub 
28ff			 
28ff cd 9b 22				call forth_tok_next 
2902			 
2902			 
2902			; while we have words to look for 
2902			 
2902 7e			.douscan:	ld a, (hl)      
2903				if DEBUG_FORTH_WORDS 
2903					DMARK "UWs" 
2903 f5				push af  
2904 3a 18 29			ld a, (.dmark)  
2907 32 6e fb			ld (debug_mark),a  
290a 3a 19 29			ld a, (.dmark+1)  
290d 32 6f fb			ld (debug_mark+1),a  
2910 3a 1a 29			ld a, (.dmark+2)  
2913 32 70 fb			ld (debug_mark+2),a  
2916 18 03			jr .pastdmark  
2918 ..			.dmark: db "UWs"  
291b f1			.pastdmark: pop af  
291c			endm  
# End of macro DMARK
291c					CALLMONITOR 
291c cd 84 17			call break_point_state  
291f				endm  
# End of macro CALLMONITOR
291f				endif 
291f fe 00				cp WORD_SYS_END 
2921 28 4d				jr z, .udone 
2923 fe 01				cp WORD_SYS_UWORD 
2925 20 44				jr nz, .nuword 
2927			 
2927				if DEBUG_FORTH_WORDS 
2927					DMARK "UWu" 
2927 f5				push af  
2928 3a 3c 29			ld a, (.dmark)  
292b 32 6e fb			ld (debug_mark),a  
292e 3a 3d 29			ld a, (.dmark+1)  
2931 32 6f fb			ld (debug_mark+1),a  
2934 3a 3e 29			ld a, (.dmark+2)  
2937 32 70 fb			ld (debug_mark+2),a  
293a 18 03			jr .pastdmark  
293c ..			.dmark: db "UWu"  
293f f1			.pastdmark: pop af  
2940			endm  
# End of macro DMARK
2940					CALLMONITOR 
2940 cd 84 17			call break_point_state  
2943				endm  
# End of macro CALLMONITOR
2943				endif 
2943					; we have a uword so push its name to the stack 
2943			 
2943 e5				   	push hl  ; save so we can move to next dict block 
2944			 
2944					; skip opcode 
2944 23					inc hl  
2945					; skip next ptr 
2945 23					inc hl  
2946 23					inc hl 
2947					; skip len 
2947 23					inc hl 
2948				if DEBUG_FORTH_WORDS 
2948					DMARK "UWt" 
2948 f5				push af  
2949 3a 5d 29			ld a, (.dmark)  
294c 32 6e fb			ld (debug_mark),a  
294f 3a 5e 29			ld a, (.dmark+1)  
2952 32 6f fb			ld (debug_mark+1),a  
2955 3a 5f 29			ld a, (.dmark+2)  
2958 32 70 fb			ld (debug_mark+2),a  
295b 18 03			jr .pastdmark  
295d ..			.dmark: db "UWt"  
2960 f1			.pastdmark: pop af  
2961			endm  
# End of macro DMARK
2961					CALLMONITOR 
2961 cd 84 17			call break_point_state  
2964				endm  
# End of macro CALLMONITOR
2964				endif 
2964 03					inc bc 
2965			 
2965 c5					push bc 
2966 cd 4f 1e				call forth_push_str 
2969 c1					pop bc 
296a			 
296a e1					pop hl 	 
296b			 
296b cd 9b 22		.nuword:	call forth_tok_next 
296e 18 92				jr .douscan  
2970			 
2970			.udone:		 ; push count of uwords found 
2970 c5					push bc 
2971 e1					pop hl 
2972			 
2972				if DEBUG_FORTH_WORDS 
2972					DMARK "UWc" 
2972 f5				push af  
2973 3a 87 29			ld a, (.dmark)  
2976 32 6e fb			ld (debug_mark),a  
2979 3a 88 29			ld a, (.dmark+1)  
297c 32 6f fb			ld (debug_mark+1),a  
297f 3a 89 29			ld a, (.dmark+2)  
2982 32 70 fb			ld (debug_mark+2),a  
2985 18 03			jr .pastdmark  
2987 ..			.dmark: db "UWc"  
298a f1			.pastdmark: pop af  
298b			endm  
# End of macro DMARK
298b					CALLMONITOR 
298b cd 84 17			call break_point_state  
298e				endm  
# End of macro CALLMONITOR
298e				endif 
298e cd e1 1d				call forth_push_numhl 
2991			 
2991			 
2991				       NEXTW 
2991 c3 4a 21			jp macro_next 
2994				endm 
# End of macro NEXTW
2994			 
2994			.BP: 
2994				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2994 54				db WORD_SYS_CORE+64             
2995 ca 29			dw .MONITOR            
2997 03				db 2 + 1 
2998 .. 00			db "BP",0              
299b				endm 
# End of macro CWHEAD
299b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
299b			; | | $00 Will enable the break points within specific code paths 
299b			; | | $01 Will disable break points 
299b			; | |  
299b			; | | By default break points are off. Either the above can be used to enable them 
299b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
299b			; | | and on release of the pressed key a message will be disaplayed to notify 
299b			; | | that break points are enabled. Pressing any key will then continue boot process. 
299b					; get byte count 
299b					if DEBUG_FORTH_WORDS_KEY 
299b						DMARK "BP." 
299b f5				push af  
299c 3a b0 29			ld a, (.dmark)  
299f 32 6e fb			ld (debug_mark),a  
29a2 3a b1 29			ld a, (.dmark+1)  
29a5 32 6f fb			ld (debug_mark+1),a  
29a8 3a b2 29			ld a, (.dmark+2)  
29ab 32 70 fb			ld (debug_mark+2),a  
29ae 18 03			jr .pastdmark  
29b0 ..			.dmark: db "BP."  
29b3 f1			.pastdmark: pop af  
29b4			endm  
# End of macro DMARK
29b4						CALLMONITOR 
29b4 cd 84 17			call break_point_state  
29b7				endm  
# End of macro CALLMONITOR
29b7					endif 
29b7			 
29b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b7 cd d8 1f			call macro_dsp_valuehl 
29ba				endm 
# End of macro FORTH_DSP_VALUEHL
29ba			 
29ba			;		push hl 
29ba			 
29ba					; destroy value TOS 
29ba			 
29ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ba cd 90 20			call macro_forth_dsp_pop 
29bd				endm 
# End of macro FORTH_DSP_POP
29bd			 
29bd			;		pop hl 
29bd			 
29bd 3e 00				ld a,0 
29bf bd					cp l 
29c0 28 02				jr z, .bpset 
29c2 3e 2a				ld a, '*' 
29c4			 
29c4 32 05 ee		.bpset:		ld (os_view_disable), a 
29c7			 
29c7			 
29c7					NEXTW 
29c7 c3 4a 21			jp macro_next 
29ca				endm 
# End of macro NEXTW
29ca			 
29ca			 
29ca			.MONITOR: 
29ca				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
29ca 55				db WORD_SYS_CORE+65             
29cb fd 29			dw .MALLOC            
29cd 08				db 7 + 1 
29ce .. 00			db "MONITOR",0              
29d6				endm 
# End of macro CWHEAD
29d6			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
29d6			; | | At start the current various registers will be displayed with contents. 
29d6			; | | Top right corner will show the most recent debug marker seen. 
29d6			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
29d6			; | | and the return stack pointer (RSP). 
29d6			; | | Pressing: 
29d6			; | |    1 - Initial screen 
29d6			; | |    2 - Display a data dump of HL 
29d6			; | |    3 - Display a data dump of DE 
29d6			; | |    4 - Display a data dump of BC 
29d6			; | |    5 - Display a data dump of HL 
29d6			; | |    6 - Display a data dump of DSP 
29d6			; | |    7 - Display a data dump of RSP 
29d6			; | |    8 - Display a data dump of what is at DSP 
29d6			; | |    9 - Display a data dump of what is at RSP 
29d6			; | |    0 - Exit monitor and continue running. This will also enable break points 
29d6			; | |    * - Disable break points 
29d6			; | |    # - Enter traditional monitor mode 
29d6			; | | 
29d6			; | | Monitor Mode 
29d6			; | | ------------ 
29d6			; | | A prompt of '>' will be shown for various commands: 
29d6			; | |    D xxxx - Display a data dump starting from hex address xxxx 
29d6			; | |    C - Continue display a data dump from the last set address 
29d6			; | |    M xxxx - Set start of memory edit at address xx 
29d6			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
29d6			; | |    Q - Return to previous 
29d6					if DEBUG_FORTH_WORDS_KEY 
29d6						DMARK "MON" 
29d6 f5				push af  
29d7 3a eb 29			ld a, (.dmark)  
29da 32 6e fb			ld (debug_mark),a  
29dd 3a ec 29			ld a, (.dmark+1)  
29e0 32 6f fb			ld (debug_mark+1),a  
29e3 3a ed 29			ld a, (.dmark+2)  
29e6 32 70 fb			ld (debug_mark+2),a  
29e9 18 03			jr .pastdmark  
29eb ..			.dmark: db "MON"  
29ee f1			.pastdmark: pop af  
29ef			endm  
# End of macro DMARK
29ef						CALLMONITOR 
29ef cd 84 17			call break_point_state  
29f2				endm  
# End of macro CALLMONITOR
29f2					endif 
29f2 3e 00				ld a, 0 
29f4 32 05 ee				ld (os_view_disable), a 
29f7			 
29f7					CALLMONITOR 
29f7 cd 84 17			call break_point_state  
29fa				endm  
# End of macro CALLMONITOR
29fa			 
29fa			;	call monitor 
29fa			 
29fa					NEXTW 
29fa c3 4a 21			jp macro_next 
29fd				endm 
# End of macro NEXTW
29fd			 
29fd			 
29fd			.MALLOC: 
29fd				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29fd 56				db WORD_SYS_CORE+66             
29fe 26 2a			dw .MALLOC2            
2a00 06				db 5 + 1 
2a01 .. 00			db "ALLOT",0              
2a07				endm 
# End of macro CWHEAD
2a07			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a07					if DEBUG_FORTH_WORDS_KEY 
2a07						DMARK "ALL" 
2a07 f5				push af  
2a08 3a 1c 2a			ld a, (.dmark)  
2a0b 32 6e fb			ld (debug_mark),a  
2a0e 3a 1d 2a			ld a, (.dmark+1)  
2a11 32 6f fb			ld (debug_mark+1),a  
2a14 3a 1e 2a			ld a, (.dmark+2)  
2a17 32 70 fb			ld (debug_mark+2),a  
2a1a 18 03			jr .pastdmark  
2a1c ..			.dmark: db "ALL"  
2a1f f1			.pastdmark: pop af  
2a20			endm  
# End of macro DMARK
2a20						CALLMONITOR 
2a20 cd 84 17			call break_point_state  
2a23				endm  
# End of macro CALLMONITOR
2a23					endif 
2a23 c3 4d 2a				jp .mallocc 
2a26			.MALLOC2: 
2a26				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a26 56				db WORD_SYS_CORE+66             
2a27 64 2a			dw .FREE            
2a29 07				db 6 + 1 
2a2a .. 00			db "MALLOC",0              
2a31				endm 
# End of macro CWHEAD
2a31			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a31					; get byte count 
2a31					if DEBUG_FORTH_WORDS_KEY 
2a31						DMARK "MAL" 
2a31 f5				push af  
2a32 3a 46 2a			ld a, (.dmark)  
2a35 32 6e fb			ld (debug_mark),a  
2a38 3a 47 2a			ld a, (.dmark+1)  
2a3b 32 6f fb			ld (debug_mark+1),a  
2a3e 3a 48 2a			ld a, (.dmark+2)  
2a41 32 70 fb			ld (debug_mark+2),a  
2a44 18 03			jr .pastdmark  
2a46 ..			.dmark: db "MAL"  
2a49 f1			.pastdmark: pop af  
2a4a			endm  
# End of macro DMARK
2a4a						CALLMONITOR 
2a4a cd 84 17			call break_point_state  
2a4d				endm  
# End of macro CALLMONITOR
2a4d					endif 
2a4d			.mallocc: 
2a4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a4d cd d8 1f			call macro_dsp_valuehl 
2a50				endm 
# End of macro FORTH_DSP_VALUEHL
2a50			 
2a50			;		push hl 
2a50			 
2a50					; destroy value TOS 
2a50			 
2a50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a50 cd 90 20			call macro_forth_dsp_pop 
2a53				endm 
# End of macro FORTH_DSP_POP
2a53			 
2a53			;		pop hl 
2a53 cd a4 12				call malloc 
2a56				if DEBUG_FORTH_MALLOC_GUARD 
2a56 f5					push af 
2a57 cd 06 0e				call ishlzero 
2a5a			;		ld a, l 
2a5a			;		add h 
2a5a			;		cp 0 
2a5a f1					pop af 
2a5b					 
2a5b cc c8 53				call z,malloc_error 
2a5e				endif 
2a5e			 
2a5e cd e1 1d				call forth_push_numhl 
2a61					NEXTW 
2a61 c3 4a 21			jp macro_next 
2a64				endm 
# End of macro NEXTW
2a64			 
2a64			.FREE: 
2a64				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a64 57				db WORD_SYS_CORE+67             
2a65 95 2a			dw .LIST            
2a67 05				db 4 + 1 
2a68 .. 00			db "FREE",0              
2a6d				endm 
# End of macro CWHEAD
2a6d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a6d					if DEBUG_FORTH_WORDS_KEY 
2a6d						DMARK "FRE" 
2a6d f5				push af  
2a6e 3a 82 2a			ld a, (.dmark)  
2a71 32 6e fb			ld (debug_mark),a  
2a74 3a 83 2a			ld a, (.dmark+1)  
2a77 32 6f fb			ld (debug_mark+1),a  
2a7a 3a 84 2a			ld a, (.dmark+2)  
2a7d 32 70 fb			ld (debug_mark+2),a  
2a80 18 03			jr .pastdmark  
2a82 ..			.dmark: db "FRE"  
2a85 f1			.pastdmark: pop af  
2a86			endm  
# End of macro DMARK
2a86						CALLMONITOR 
2a86 cd 84 17			call break_point_state  
2a89				endm  
# End of macro CALLMONITOR
2a89					endif 
2a89					; get address 
2a89			 
2a89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a89 cd d8 1f			call macro_dsp_valuehl 
2a8c				endm 
# End of macro FORTH_DSP_VALUEHL
2a8c			 
2a8c			;		push hl 
2a8c			 
2a8c					; destroy value TOS 
2a8c			 
2a8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a8c cd 90 20			call macro_forth_dsp_pop 
2a8f				endm 
# End of macro FORTH_DSP_POP
2a8f			 
2a8f			;		pop hl 
2a8f			if FORTH_ENABLE_MALLOCFREE 
2a8f cd 6e 13				call free 
2a92			endif 
2a92					NEXTW 
2a92 c3 4a 21			jp macro_next 
2a95				endm 
# End of macro NEXTW
2a95			.LIST: 
2a95				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a95 5c				db WORD_SYS_CORE+72             
2a96 83 2c			dw .FORGET            
2a98 05				db 4 + 1 
2a99 .. 00			db "LIST",0              
2a9e				endm 
# End of macro CWHEAD
2a9e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a9e			; | | The quoted word must be in upper case. 
2a9e				if DEBUG_FORTH_WORDS_KEY 
2a9e					DMARK "LST" 
2a9e f5				push af  
2a9f 3a b3 2a			ld a, (.dmark)  
2aa2 32 6e fb			ld (debug_mark),a  
2aa5 3a b4 2a			ld a, (.dmark+1)  
2aa8 32 6f fb			ld (debug_mark+1),a  
2aab 3a b5 2a			ld a, (.dmark+2)  
2aae 32 70 fb			ld (debug_mark+2),a  
2ab1 18 03			jr .pastdmark  
2ab3 ..			.dmark: db "LST"  
2ab6 f1			.pastdmark: pop af  
2ab7			endm  
# End of macro DMARK
2ab7					CALLMONITOR 
2ab7 cd 84 17			call break_point_state  
2aba				endm  
# End of macro CALLMONITOR
2aba				endif 
2aba			 
2aba					FORTH_DSP_VALUEHL 
2aba cd d8 1f			call macro_dsp_valuehl 
2abd				endm 
# End of macro FORTH_DSP_VALUEHL
2abd			 
2abd e5					push hl 
2abe					FORTH_DSP_POP 
2abe cd 90 20			call macro_forth_dsp_pop 
2ac1				endm 
# End of macro FORTH_DSP_POP
2ac1 c1					pop bc 
2ac2			 
2ac2			; Start format of scratch string 
2ac2			 
2ac2 21 14 ee				ld hl, scratch 
2ac5			 
2ac5 3e 3a				ld a, ':' 
2ac7 77					ld (hl),a 
2ac8 23					inc hl 
2ac9 3e 20				ld a, ' ' 
2acb 77					ld (hl), a 
2acc			 
2acc					; Get ptr to the word we need to look up 
2acc			 
2acc			;		FORTH_DSP_VALUEHL 
2acc					;v5 FORTH_DSP_VALUE 
2acc				; TODO type check 
2acc			;		inc hl    ; Skip type check  
2acc			;		push hl 
2acc			;		ex de, hl    ; put into DE 
2acc			 
2acc			 
2acc 21 00 80				ld hl, baseram 
2acf					;ld hl, baseusermem 
2acf			 
2acf e5			push hl   ; sacreifical push 
2ad0			 
2ad0			.ldouscanm: 
2ad0 e1				pop hl 
2ad1			.ldouscan: 
2ad1				if DEBUG_FORTH_WORDS 
2ad1					DMARK "LSs" 
2ad1 f5				push af  
2ad2 3a e6 2a			ld a, (.dmark)  
2ad5 32 6e fb			ld (debug_mark),a  
2ad8 3a e7 2a			ld a, (.dmark+1)  
2adb 32 6f fb			ld (debug_mark+1),a  
2ade 3a e8 2a			ld a, (.dmark+2)  
2ae1 32 70 fb			ld (debug_mark+2),a  
2ae4 18 03			jr .pastdmark  
2ae6 ..			.dmark: db "LSs"  
2ae9 f1			.pastdmark: pop af  
2aea			endm  
# End of macro DMARK
2aea					CALLMONITOR 
2aea cd 84 17			call break_point_state  
2aed				endm  
# End of macro CALLMONITOR
2aed				endif 
2aed				; skip dict stub 
2aed cd 9b 22				call forth_tok_next 
2af0			 
2af0			 
2af0			; while we have words to look for 
2af0			 
2af0 7e				ld a, (hl)      
2af1				if DEBUG_FORTH_WORDS 
2af1					DMARK "LSk" 
2af1 f5				push af  
2af2 3a 06 2b			ld a, (.dmark)  
2af5 32 6e fb			ld (debug_mark),a  
2af8 3a 07 2b			ld a, (.dmark+1)  
2afb 32 6f fb			ld (debug_mark+1),a  
2afe 3a 08 2b			ld a, (.dmark+2)  
2b01 32 70 fb			ld (debug_mark+2),a  
2b04 18 03			jr .pastdmark  
2b06 ..			.dmark: db "LSk"  
2b09 f1			.pastdmark: pop af  
2b0a			endm  
# End of macro DMARK
2b0a					CALLMONITOR 
2b0a cd 84 17			call break_point_state  
2b0d				endm  
# End of macro CALLMONITOR
2b0d				endif 
2b0d					;cp WORD_SYS_END 
2b0d					;jp z, .lunotfound 
2b0d			 
2b0d					; if we hit non uwords then gone too far 
2b0d fe 01				cp WORD_SYS_UWORD 
2b0f c2 3f 2c				jp nz, .lunotfound 
2b12			 
2b12				if DEBUG_FORTH_WORDS 
2b12					DMARK "LSu" 
2b12 f5				push af  
2b13 3a 27 2b			ld a, (.dmark)  
2b16 32 6e fb			ld (debug_mark),a  
2b19 3a 28 2b			ld a, (.dmark+1)  
2b1c 32 6f fb			ld (debug_mark+1),a  
2b1f 3a 29 2b			ld a, (.dmark+2)  
2b22 32 70 fb			ld (debug_mark+2),a  
2b25 18 03			jr .pastdmark  
2b27 ..			.dmark: db "LSu"  
2b2a f1			.pastdmark: pop af  
2b2b			endm  
# End of macro DMARK
2b2b					CALLMONITOR 
2b2b cd 84 17			call break_point_state  
2b2e				endm  
# End of macro CALLMONITOR
2b2e				endif 
2b2e			 
2b2e					; found a uword but is it the one we want... 
2b2e			 
2b2e c5					push bc     ; uword to find is on bc 
2b2f d1					pop de 
2b30			 
2b30 e5					push hl  ; to save the ptr 
2b31			 
2b31					; skip opcode 
2b31 23					inc hl  
2b32					; skip next ptr 
2b32 23					inc hl  
2b33 23					inc hl 
2b34					; skip len 
2b34 23					inc hl 
2b35			 
2b35				if DEBUG_FORTH_WORDS 
2b35					DMARK "LSc" 
2b35 f5				push af  
2b36 3a 4a 2b			ld a, (.dmark)  
2b39 32 6e fb			ld (debug_mark),a  
2b3c 3a 4b 2b			ld a, (.dmark+1)  
2b3f 32 6f fb			ld (debug_mark+1),a  
2b42 3a 4c 2b			ld a, (.dmark+2)  
2b45 32 70 fb			ld (debug_mark+2),a  
2b48 18 03			jr .pastdmark  
2b4a ..			.dmark: db "LSc"  
2b4d f1			.pastdmark: pop af  
2b4e			endm  
# End of macro DMARK
2b4e					CALLMONITOR 
2b4e cd 84 17			call break_point_state  
2b51				endm  
# End of macro CALLMONITOR
2b51				endif 
2b51 cd 73 12				call strcmp 
2b54 c2 d0 2a				jp nz, .ldouscanm 
2b57				 
2b57			 
2b57			 
2b57					; we have a uword so push its name to the stack 
2b57			 
2b57			;	   	push hl  ; save so we can move to next dict block 
2b57 e1			pop hl 
2b58			 
2b58				if DEBUG_FORTH_WORDS 
2b58					DMARK "LSm" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 6e fb			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 6f fb			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 70 fb			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "LSm"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71					CALLMONITOR 
2b71 cd 84 17			call break_point_state  
2b74				endm  
# End of macro CALLMONITOR
2b74				endif 
2b74			 
2b74					; skip opcode 
2b74 23					inc hl  
2b75					; skip next ptr 
2b75 23					inc hl  
2b76 23					inc hl 
2b77					; skip len 
2b77 7e					ld a, (hl)   ; save length to add 
2b78				if DEBUG_FORTH_WORDS 
2b78					DMARK "LS2" 
2b78 f5				push af  
2b79 3a 8d 2b			ld a, (.dmark)  
2b7c 32 6e fb			ld (debug_mark),a  
2b7f 3a 8e 2b			ld a, (.dmark+1)  
2b82 32 6f fb			ld (debug_mark+1),a  
2b85 3a 8f 2b			ld a, (.dmark+2)  
2b88 32 70 fb			ld (debug_mark+2),a  
2b8b 18 03			jr .pastdmark  
2b8d ..			.dmark: db "LS2"  
2b90 f1			.pastdmark: pop af  
2b91			endm  
# End of macro DMARK
2b91					CALLMONITOR 
2b91 cd 84 17			call break_point_state  
2b94				endm  
# End of macro CALLMONITOR
2b94				endif 
2b94			 
2b94					; save this location 
2b94				 
2b94 e5					push hl 
2b95			 
2b95 23					inc hl 
2b96 11 16 ee				ld de, scratch+2 
2b99 4f					ld c, a 
2b9a 06 00				ld b, 0 
2b9c			 
2b9c				if DEBUG_FORTH_WORDS 
2b9c					DMARK "LSn" 
2b9c f5				push af  
2b9d 3a b1 2b			ld a, (.dmark)  
2ba0 32 6e fb			ld (debug_mark),a  
2ba3 3a b2 2b			ld a, (.dmark+1)  
2ba6 32 6f fb			ld (debug_mark+1),a  
2ba9 3a b3 2b			ld a, (.dmark+2)  
2bac 32 70 fb			ld (debug_mark+2),a  
2baf 18 03			jr .pastdmark  
2bb1 ..			.dmark: db "LSn"  
2bb4 f1			.pastdmark: pop af  
2bb5			endm  
# End of macro DMARK
2bb5					CALLMONITOR 
2bb5 cd 84 17			call break_point_state  
2bb8				endm  
# End of macro CALLMONITOR
2bb8				endif 
2bb8			 
2bb8					; copy uword name to scratch 
2bb8			 
2bb8 ed b0				ldir 
2bba			 
2bba 1b					dec de 
2bbb 3e 20				ld a, ' '    ; change null to space 
2bbd 12					ld (de), a 
2bbe			 
2bbe 13					inc de 
2bbf			 
2bbf d5					push de 
2bc0 c1					pop bc     ; move scratch pointer to end of word name and save it 
2bc1			 
2bc1 e1					pop hl 
2bc2 7e					ld a, (hl) 
2bc3					;inc hl 
2bc3					; skip word string 
2bc3 cd dd 0d				call addatohl 
2bc6			 
2bc6 23					inc hl 
2bc7			 
2bc7				if DEBUG_FORTH_WORDS 
2bc7					DMARK "LS3" 
2bc7 f5				push af  
2bc8 3a dc 2b			ld a, (.dmark)  
2bcb 32 6e fb			ld (debug_mark),a  
2bce 3a dd 2b			ld a, (.dmark+1)  
2bd1 32 6f fb			ld (debug_mark+1),a  
2bd4 3a de 2b			ld a, (.dmark+2)  
2bd7 32 70 fb			ld (debug_mark+2),a  
2bda 18 03			jr .pastdmark  
2bdc ..			.dmark: db "LS3"  
2bdf f1			.pastdmark: pop af  
2be0			endm  
# End of macro DMARK
2be0					CALLMONITOR 
2be0 cd 84 17			call break_point_state  
2be3				endm  
# End of macro CALLMONITOR
2be3				endif 
2be3					; should now be at the start of the machine code to setup the eval of the uword 
2be3					; now locate the ptr to the string defintion 
2be3			 
2be3					; skip ld hl, 
2be3					; then load the ptr 
2be3			; TODO use get from hl ptr 
2be3 23					inc hl 
2be4 5e					ld e, (hl) 
2be5 23					inc hl 
2be6 56					ld d, (hl) 
2be7 eb					ex de, hl 
2be8			 
2be8			 
2be8				if DEBUG_FORTH_WORDS 
2be8					DMARK "LSt" 
2be8 f5				push af  
2be9 3a fd 2b			ld a, (.dmark)  
2bec 32 6e fb			ld (debug_mark),a  
2bef 3a fe 2b			ld a, (.dmark+1)  
2bf2 32 6f fb			ld (debug_mark+1),a  
2bf5 3a ff 2b			ld a, (.dmark+2)  
2bf8 32 70 fb			ld (debug_mark+2),a  
2bfb 18 03			jr .pastdmark  
2bfd ..			.dmark: db "LSt"  
2c00 f1			.pastdmark: pop af  
2c01			endm  
# End of macro DMARK
2c01					CALLMONITOR 
2c01 cd 84 17			call break_point_state  
2c04				endm  
# End of macro CALLMONITOR
2c04				endif 
2c04			 
2c04			; cant push right now due to tokenised strings  
2c04			 
2c04			; get the destination of where to copy this definition to. 
2c04			 
2c04 c5					push bc 
2c05 d1					pop de 
2c06			 
2c06 7e			.listl:         ld a,(hl) 
2c07 fe 00				cp 0 
2c09 28 09				jr z, .lreplsp     ; replace zero with space 
2c0b					;cp FORTH_END_BUFFER 
2c0b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c0d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c0f				 
2c0f					; just copy this char as is then 
2c0f			 
2c0f 12					ld (de), a 
2c10			 
2c10 23			.listnxt:	inc hl 
2c11 13					inc de 
2c12 18 f2				jr .listl 
2c14			 
2c14 3e 20		.lreplsp:	ld a,' ' 
2c16 12					ld (de), a 
2c17 18 f7				jr .listnxt 
2c19			 
2c19			; close up uword def 
2c19			 
2c19			.listdone: 
2c19 12					ld (de), a 
2c1a 13					inc de 
2c1b 3e 00				ld a, 0 
2c1d 12					ld (de), a 
2c1e			 
2c1e			; now have def so clean up and push to stack 
2c1e			 
2c1e 21 14 ee				ld hl, scratch 
2c21				if DEBUG_FORTH_WORDS 
2c21					DMARK "Ltp" 
2c21 f5				push af  
2c22 3a 36 2c			ld a, (.dmark)  
2c25 32 6e fb			ld (debug_mark),a  
2c28 3a 37 2c			ld a, (.dmark+1)  
2c2b 32 6f fb			ld (debug_mark+1),a  
2c2e 3a 38 2c			ld a, (.dmark+2)  
2c31 32 70 fb			ld (debug_mark+2),a  
2c34 18 03			jr .pastdmark  
2c36 ..			.dmark: db "Ltp"  
2c39 f1			.pastdmark: pop af  
2c3a			endm  
# End of macro DMARK
2c3a					CALLMONITOR 
2c3a cd 84 17			call break_point_state  
2c3d				endm  
# End of macro CALLMONITOR
2c3d				endif 
2c3d			 
2c3d 18 1f			jr .listpush 
2c3f			 
2c3f			;.lnuword:	pop hl 
2c3f			;		call forth_tok_next 
2c3f			;		jp .ldouscan  
2c3f			 
2c3f			.lunotfound:		  
2c3f			 
2c3f				if DEBUG_FORTH_WORDS 
2c3f					DMARK "LSn" 
2c3f f5				push af  
2c40 3a 54 2c			ld a, (.dmark)  
2c43 32 6e fb			ld (debug_mark),a  
2c46 3a 55 2c			ld a, (.dmark+1)  
2c49 32 6f fb			ld (debug_mark+1),a  
2c4c 3a 56 2c			ld a, (.dmark+2)  
2c4f 32 70 fb			ld (debug_mark+2),a  
2c52 18 03			jr .pastdmark  
2c54 ..			.dmark: db "LSn"  
2c57 f1			.pastdmark: pop af  
2c58			endm  
# End of macro DMARK
2c58					CALLMONITOR 
2c58 cd 84 17			call break_point_state  
2c5b				endm  
# End of macro CALLMONITOR
2c5b				endif 
2c5b			 
2c5b					 
2c5b			;		FORTH_DSP_POP 
2c5b			;		ld hl, .luno 
2c5b			 
2c5b					NEXTW			 
2c5b c3 4a 21			jp macro_next 
2c5e				endm 
# End of macro NEXTW
2c5e			 
2c5e			.listpush: 
2c5e				if DEBUG_FORTH_WORDS 
2c5e					DMARK "LS>" 
2c5e f5				push af  
2c5f 3a 73 2c			ld a, (.dmark)  
2c62 32 6e fb			ld (debug_mark),a  
2c65 3a 74 2c			ld a, (.dmark+1)  
2c68 32 6f fb			ld (debug_mark+1),a  
2c6b 3a 75 2c			ld a, (.dmark+2)  
2c6e 32 70 fb			ld (debug_mark+2),a  
2c71 18 03			jr .pastdmark  
2c73 ..			.dmark: db "LS>"  
2c76 f1			.pastdmark: pop af  
2c77			endm  
# End of macro DMARK
2c77					CALLMONITOR 
2c77 cd 84 17			call break_point_state  
2c7a				endm  
# End of macro CALLMONITOR
2c7a				endif 
2c7a cd 4f 1e				call forth_push_str 
2c7d			 
2c7d			 
2c7d			 
2c7d					NEXTW 
2c7d c3 4a 21			jp macro_next 
2c80				endm 
# End of macro NEXTW
2c80			 
2c80			;.luno:    db "Word not found",0 
2c80			 
2c80			 
2c80			 
2c80			 
2c80			 
2c80			;		push hl   ; save pointer to start of uword def string 
2c80			; 
2c80			;; look for FORTH_EOL_LINE 
2c80			;		ld a, FORTH_END_BUFFER 
2c80			;		call strlent 
2c80			; 
2c80			;		inc hl		 ; space for coln def 
2c80			;		inc hl 
2c80			;		inc hl          ; space for terms 
2c80			;		inc hl 
2c80			; 
2c80			;		ld a, 20   ; TODO get actual length 
2c80			;		call addatohl    ; include a random amount of room for the uword name 
2c80			; 
2c80			;		 
2c80			;	if DEBUG_FORTH_WORDS 
2c80			;		DMARK "Lt1" 
2c80			;		CALLMONITOR 
2c80			;	endif 
2c80			;		 
2c80			; 
2c80			;; malloc space for the string because we cant change it 
2c80			; 
2c80			;		call malloc 
2c80			;	if DEBUG_FORTH_MALLOC_GUARD 
2c80			;		push af 
2c80			;		call ishlzero 
2c80			;		pop af 
2c80			;		 
2c80			;		call z,malloc_error 
2c80			;	endif 
2c80			; 
2c80			;	if DEBUG_FORTH_WORDS 
2c80			;		DMARK "Lt2" 
2c80			;		CALLMONITOR 
2c80			;	endif 
2c80			;		pop de 
2c80			;		push hl    ; push the malloc to release later 
2c80			;		push hl   ;  push back a copy for the later stack push 
2c80			;		 
2c80			;; copy the string swapping out the zero terms for spaces 
2c80			; 
2c80			;		; de has our source 
2c80			;		; hl has our dest 
2c80			; 
2c80			;; add the coln def 
2c80			; 
2c80			;		ld a, ':' 
2c80			;		ld (hl), a 
2c80			;		inc hl 
2c80			;		ld a, ' ' 
2c80			;		ld (hl), a 
2c80			;		inc hl 
2c80			; 
2c80			;; add the uname word 
2c80			;		push de   ; save our string for now 
2c80			;		ex de, hl 
2c80			; 
2c80			;		FORTH_DSP_VALUE 
2c80			;		;v5 FORTH_DSP_VALUE 
2c80			; 
2c80			;		inc hl   ; skip type but we know by now this is OK 
2c80			; 
2c80			;.luword:	ld a,(hl) 
2c80			;		cp 0 
2c80			;		jr z, .luword2 
2c80			;		ld (de), a 
2c80			;		inc de 
2c80			;		inc hl 
2c80			;		jr .luword 
2c80			; 
2c80			;.luword2:	ld a, ' ' 
2c80			;		ld (de), a 
2c80			;;		inc hl 
2c80			;;		inc de 
2c80			;;		ld (de), a 
2c80			;;		inc hl 
2c80			;		inc de 
2c80			; 
2c80			;		ex de, hl 
2c80			;		pop de 
2c80			;		 
2c80			;		 
2c80			; 
2c80			;; detoken that string and copy it 
2c80			; 
2c80			;	if DEBUG_FORTH_WORDS 
2c80			;		DMARK "Lt2" 
2c80			;		CALLMONITOR 
2c80			;	endif 
2c80			;.ldetok:	ld a, (de) 
2c80			;		cp FORTH_END_BUFFER 
2c80			;		jr z, .ldetokend 
2c80			;		; swap out any zero term for space 
2c80			;		cp 0 
2c80			;		jr nz, .ldetoknext 
2c80			;		ld a, ' ' 
2c80			; 
2c80			;	if DEBUG_FORTH_WORDS 
2c80			;		DMARK "LtS" 
2c80			;		CALLMONITOR 
2c80			;	endif 
2c80			;.ldetoknext:	ld (hl), a 
2c80			;		inc de 
2c80			;		inc hl 
2c80			;		jr .ldetok 
2c80			; 
2c80			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c80			;		ld (hl), a  
2c80			; 
2c80			;; free that temp malloc 
2c80			; 
2c80			;		pop hl    
2c80			; 
2c80			;	if DEBUG_FORTH_WORDS 
2c80			;		DMARK "Lt4" 
2c80			;		CALLMONITOR 
2c80			;	endif 
2c80			;		call forth_apushstrhl 
2c80			; 
2c80			;		; get rid of temp malloc area 
2c80			; 
2c80			;		pop hl 
2c80			;		call free 
2c80			; 
2c80			;		jr .ludone 
2c80			; 
2c80			;.lnuword:	pop hl 
2c80			;		call forth_tok_next 
2c80			;		jp .ldouscan  
2c80			; 
2c80			;.ludone:		 pop hl 
2c80			; 
2c80					NEXTW 
2c80 c3 4a 21			jp macro_next 
2c83				endm 
# End of macro NEXTW
2c83			 
2c83			.FORGET: 
2c83				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c83 5d				db WORD_SYS_CORE+73             
2c84 fc 2c			dw .NOP            
2c86 07				db 6 + 1 
2c87 .. 00			db "FORGET",0              
2c8e				endm 
# End of macro CWHEAD
2c8e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2c8e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2c8e			; | |  
2c8e			; | | e.g. "MORE" forget 
2c8e					if DEBUG_FORTH_WORDS_KEY 
2c8e						DMARK "FRG" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 6e fb			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 6f fb			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 70 fb			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "FRG"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7						CALLMONITOR 
2ca7 cd 84 17			call break_point_state  
2caa				endm  
# End of macro CALLMONITOR
2caa					endif 
2caa			 
2caa				; find uword 
2caa			        ; update start of word with "_" 
2caa				; replace uword with deleted flag 
2caa			 
2caa			 
2caa			;	if DEBUG_FORTH_WORDS 
2caa			;		DMARK "FOG" 
2caa			;		CALLMONITOR 
2caa			;	endif 
2caa			 
2caa			 
2caa					; Get ptr to the word we need to look up 
2caa			 
2caa					FORTH_DSP_VALUEHL 
2caa cd d8 1f			call macro_dsp_valuehl 
2cad				endm 
# End of macro FORTH_DSP_VALUEHL
2cad					;v5 FORTH_DSP_VALUE 
2cad				; TODO type check 
2cad			;		inc hl    ; Skip type check  
2cad e5					push hl 
2cae c1					pop bc 
2caf			;		ex de, hl    ; put into DE 
2caf			 
2caf			 
2caf 21 00 80				ld hl, baseram 
2cb2					;ld hl, baseusermem 
2cb2			 
2cb2				; skip dict stub 
2cb2			;	call forth_tok_next 
2cb2 e5			push hl   ; sacreifical push 
2cb3			 
2cb3			.fldouscanm: 
2cb3 e1				pop hl 
2cb4			.fldouscan: 
2cb4			;	if DEBUG_FORTH_WORDS 
2cb4			;		DMARK "LSs" 
2cb4			;		CALLMONITOR 
2cb4			;	endif 
2cb4				; skip dict stub 
2cb4 cd 9b 22				call forth_tok_next 
2cb7			 
2cb7			 
2cb7			; while we have words to look for 
2cb7			 
2cb7 7e				ld a, (hl)      
2cb8			;	if DEBUG_FORTH_WORDS 
2cb8			;		DMARK "LSk" 
2cb8			;		CALLMONITOR 
2cb8			;	endif 
2cb8 fe 00				cp WORD_SYS_END 
2cba ca f6 2c				jp z, .flunotfound 
2cbd fe 01				cp WORD_SYS_UWORD 
2cbf c2 b4 2c				jp nz, .fldouscan 
2cc2			 
2cc2			;	if DEBUG_FORTH_WORDS 
2cc2			;		DMARK "LSu" 
2cc2			;		CALLMONITOR 
2cc2			;	endif 
2cc2			 
2cc2					; found a uword but is it the one we want... 
2cc2			 
2cc2 c5					push bc     ; uword to find is on bc 
2cc3 d1					pop de 
2cc4			 
2cc4 e5					push hl  ; to save the ptr 
2cc5			 
2cc5					; skip opcode 
2cc5 23					inc hl  
2cc6					; skip next ptr 
2cc6 23					inc hl  
2cc7 23					inc hl 
2cc8					; skip len 
2cc8 23					inc hl 
2cc9			 
2cc9			;	if DEBUG_FORTH_WORDS 
2cc9			;		DMARK "LSc" 
2cc9			;		CALLMONITOR 
2cc9			;	endif 
2cc9 cd 73 12				call strcmp 
2ccc c2 b3 2c				jp nz, .fldouscanm 
2ccf			; 
2ccf			; 
2ccf			;; while we have words to look for 
2ccf			; 
2ccf			;.fdouscan:	ld a, (hl)      
2ccf			;	if DEBUG_FORTH_WORDS 
2ccf			;		DMARK "LSs" 
2ccf			;		CALLMONITOR 
2ccf			;	endif 
2ccf			;		cp WORD_SYS_END 
2ccf			;		jp z, .fudone 
2ccf			;		cp WORD_SYS_UWORD 
2ccf			;		jp nz, .fnuword 
2ccf			; 
2ccf			;	if DEBUG_FORTH_WORDS 
2ccf			;		DMARK "FGu" 
2ccf			;		CALLMONITOR 
2ccf			;	endif 
2ccf			; 
2ccf			;		; found a uword but is it the one we want... 
2ccf			; 
2ccf			; 
2ccf			;	        pop de   ; get back the dsp name 
2ccf			;		push de 
2ccf			; 
2ccf			;		push hl  ; to save the ptr 
2ccf			; 
2ccf			;		; skip opcode 
2ccf			;		inc hl  
2ccf			;		; skip next ptr 
2ccf			;		inc hl  
2ccf			;		inc hl 
2ccf			;		; skip len 
2ccf			;		inc hl 
2ccf			; 
2ccf			;	if DEBUG_FORTH_WORDS 
2ccf			;		DMARK "FGc" 
2ccf			;		CALLMONITOR 
2ccf			;	endif 
2ccf			;		call strcmp 
2ccf			;		jp nz, .fnuword 
2ccf			 
2ccf			 
2ccf e1			pop hl 
2cd0			 
2cd0				 
2cd0				if DEBUG_FORTH_WORDS 
2cd0					DMARK "FGm" 
2cd0 f5				push af  
2cd1 3a e5 2c			ld a, (.dmark)  
2cd4 32 6e fb			ld (debug_mark),a  
2cd7 3a e6 2c			ld a, (.dmark+1)  
2cda 32 6f fb			ld (debug_mark+1),a  
2cdd 3a e7 2c			ld a, (.dmark+2)  
2ce0 32 70 fb			ld (debug_mark+2),a  
2ce3 18 03			jr .pastdmark  
2ce5 ..			.dmark: db "FGm"  
2ce8 f1			.pastdmark: pop af  
2ce9			endm  
# End of macro DMARK
2ce9					CALLMONITOR 
2ce9 cd 84 17			call break_point_state  
2cec				endm  
# End of macro CALLMONITOR
2cec				endif 
2cec			 
2cec			 
2cec			 
2cec					; we have a uword so push its name to the stack 
2cec			 
2cec			;	   	push hl  ; save so we can move to next dict block 
2cec			;pop hl 
2cec			 
2cec					; update opcode to deleted 
2cec 3e 03				ld a, WORD_SYS_DELETED 
2cee 77					ld (hl), a 
2cef			 
2cef 23					inc hl  
2cf0					; skip next ptr 
2cf0 23					inc hl  
2cf1 23					inc hl 
2cf2					; skip len 
2cf2 23					inc hl 
2cf3			 
2cf3					; TODO change parser to skip deleted words but for now mark it out 
2cf3 3e 5f				ld a, "_" 
2cf5 77					ld  (hl),a 
2cf6			 
2cf6			;		jr .fudone 
2cf6			; 
2cf6			;.fnuword:	pop hl 
2cf6			;		call forth_tok_next 
2cf6			;		jp .fdouscan  
2cf6			 
2cf6			.flunotfound:		  
2cf6			 
2cf6			 
2cf6					 
2cf6					FORTH_DSP_POP 
2cf6 cd 90 20			call macro_forth_dsp_pop 
2cf9				endm 
# End of macro FORTH_DSP_POP
2cf9			;		ld hl, .luno 
2cf9			;.fudone:		 pop hl 
2cf9					NEXTW 
2cf9 c3 4a 21			jp macro_next 
2cfc				endm 
# End of macro NEXTW
2cfc			.NOP: 
2cfc				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2cfc 61				db WORD_SYS_CORE+77             
2cfd 23 2d			dw .COMO            
2cff 04				db 3 + 1 
2d00 .. 00			db "NOP",0              
2d04				endm 
# End of macro CWHEAD
2d04			; | NOP (  --  ) Do nothing | DONE 
2d04					if DEBUG_FORTH_WORDS_KEY 
2d04						DMARK "NOP" 
2d04 f5				push af  
2d05 3a 19 2d			ld a, (.dmark)  
2d08 32 6e fb			ld (debug_mark),a  
2d0b 3a 1a 2d			ld a, (.dmark+1)  
2d0e 32 6f fb			ld (debug_mark+1),a  
2d11 3a 1b 2d			ld a, (.dmark+2)  
2d14 32 70 fb			ld (debug_mark+2),a  
2d17 18 03			jr .pastdmark  
2d19 ..			.dmark: db "NOP"  
2d1c f1			.pastdmark: pop af  
2d1d			endm  
# End of macro DMARK
2d1d						CALLMONITOR 
2d1d cd 84 17			call break_point_state  
2d20				endm  
# End of macro CALLMONITOR
2d20					endif 
2d20				       NEXTW 
2d20 c3 4a 21			jp macro_next 
2d23				endm 
# End of macro NEXTW
2d23			.COMO: 
2d23				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2d23 6e				db WORD_SYS_CORE+90             
2d24 75 2d			dw .COMC            
2d26 02				db 1 + 1 
2d27 .. 00			db "(",0              
2d29				endm 
# End of macro CWHEAD
2d29			; | ( ( -- )  Start of comment | DONE 
2d29			 
2d29			 
2d29 2a 15 f1				ld hl, ( os_tok_ptr) 
2d2c 11 70 2d			ld de, .closepar 
2d2f					 
2d2f					if DEBUG_FORTH_WORDS 
2d2f						DMARK ").." 
2d2f f5				push af  
2d30 3a 44 2d			ld a, (.dmark)  
2d33 32 6e fb			ld (debug_mark),a  
2d36 3a 45 2d			ld a, (.dmark+1)  
2d39 32 6f fb			ld (debug_mark+1),a  
2d3c 3a 46 2d			ld a, (.dmark+2)  
2d3f 32 70 fb			ld (debug_mark+2),a  
2d42 18 03			jr .pastdmark  
2d44 ..			.dmark: db ").."  
2d47 f1			.pastdmark: pop af  
2d48			endm  
# End of macro DMARK
2d48						CALLMONITOR 
2d48 cd 84 17			call break_point_state  
2d4b				endm  
# End of macro CALLMONITOR
2d4b					endif 
2d4b cd 65 22			call findnexttok  
2d4e			 
2d4e					if DEBUG_FORTH_WORDS 
2d4e						DMARK "IF5" 
2d4e f5				push af  
2d4f 3a 63 2d			ld a, (.dmark)  
2d52 32 6e fb			ld (debug_mark),a  
2d55 3a 64 2d			ld a, (.dmark+1)  
2d58 32 6f fb			ld (debug_mark+1),a  
2d5b 3a 65 2d			ld a, (.dmark+2)  
2d5e 32 70 fb			ld (debug_mark+2),a  
2d61 18 03			jr .pastdmark  
2d63 ..			.dmark: db "IF5"  
2d66 f1			.pastdmark: pop af  
2d67			endm  
# End of macro DMARK
2d67						CALLMONITOR 
2d67 cd 84 17			call break_point_state  
2d6a				endm  
# End of macro CALLMONITOR
2d6a					endif 
2d6a				; replace below with ) exec using tok_ptr 
2d6a 22 15 f1			ld (os_tok_ptr), hl 
2d6d c3 db 21			jp exec1 
2d70			 
2d70 .. 00			.closepar:   db ")",0 
2d72			 
2d72				       NEXTW 
2d72 c3 4a 21			jp macro_next 
2d75				endm 
# End of macro NEXTW
2d75			.COMC: 
2d75				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d75 6f				db WORD_SYS_CORE+91             
2d76 7e 2d			dw .SCRATCH            
2d78 02				db 1 + 1 
2d79 .. 00			db ")",0              
2d7b				endm 
# End of macro CWHEAD
2d7b			; | ) ( -- )  End of comment |  DONE  
2d7b				       NEXTW 
2d7b c3 4a 21			jp macro_next 
2d7e				endm 
# End of macro NEXTW
2d7e			 
2d7e			.SCRATCH: 
2d7e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d7e 6f				db WORD_SYS_CORE+91             
2d7f b9 2d			dw .INC            
2d81 08				db 7 + 1 
2d82 .. 00			db "SCRATCH",0              
2d8a				endm 
# End of macro CWHEAD
2d8a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2d8a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2d8a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2d8a			; | |  
2d8a			; | | e.g.    : score $00 scratch ; 
2d8a			; | |  
2d8a			; | | $00 score ! 
2d8a			; | | $01 score +! 
2d8a			; | |  
2d8a			; | | e.g.   : varword $0a scratch ;  
2d8a			; | | 
2d8a			; | | $8000 varword ! 
2d8a					if DEBUG_FORTH_WORDS_KEY 
2d8a						DMARK "SCR" 
2d8a f5				push af  
2d8b 3a 9f 2d			ld a, (.dmark)  
2d8e 32 6e fb			ld (debug_mark),a  
2d91 3a a0 2d			ld a, (.dmark+1)  
2d94 32 6f fb			ld (debug_mark+1),a  
2d97 3a a1 2d			ld a, (.dmark+2)  
2d9a 32 70 fb			ld (debug_mark+2),a  
2d9d 18 03			jr .pastdmark  
2d9f ..			.dmark: db "SCR"  
2da2 f1			.pastdmark: pop af  
2da3			endm  
# End of macro DMARK
2da3						CALLMONITOR 
2da3 cd 84 17			call break_point_state  
2da6				endm  
# End of macro CALLMONITOR
2da6					endif 
2da6			 
2da6					FORTH_DSP_VALUEHL 
2da6 cd d8 1f			call macro_dsp_valuehl 
2da9				endm 
# End of macro FORTH_DSP_VALUEHL
2da9				 
2da9					FORTH_DSP_POP 
2da9 cd 90 20			call macro_forth_dsp_pop 
2dac				endm 
# End of macro FORTH_DSP_POP
2dac			 
2dac 7d					ld a, l 
2dad 21 39 f3				ld hl, os_var_array 
2db0 cd dd 0d				call addatohl 
2db3			 
2db3 cd e1 1d				call forth_push_numhl 
2db6			 
2db6				       NEXTW 
2db6 c3 4a 21			jp macro_next 
2db9				endm 
# End of macro NEXTW
2db9			 
2db9			.INC: 
2db9				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2db9 6f				db WORD_SYS_CORE+91             
2dba 0d 2e			dw .DEC            
2dbc 03				db 2 + 1 
2dbd .. 00			db "+!",0              
2dc0				endm 
# End of macro CWHEAD
2dc0			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2dc0					if DEBUG_FORTH_WORDS_KEY 
2dc0						DMARK "+s_" 
2dc0 f5				push af  
2dc1 3a d5 2d			ld a, (.dmark)  
2dc4 32 6e fb			ld (debug_mark),a  
2dc7 3a d6 2d			ld a, (.dmark+1)  
2dca 32 6f fb			ld (debug_mark+1),a  
2dcd 3a d7 2d			ld a, (.dmark+2)  
2dd0 32 70 fb			ld (debug_mark+2),a  
2dd3 18 03			jr .pastdmark  
2dd5 ..			.dmark: db "+s_"  
2dd8 f1			.pastdmark: pop af  
2dd9			endm  
# End of macro DMARK
2dd9						CALLMONITOR 
2dd9 cd 84 17			call break_point_state  
2ddc				endm  
# End of macro CALLMONITOR
2ddc					endif 
2ddc			 
2ddc					FORTH_DSP_VALUEHL 
2ddc cd d8 1f			call macro_dsp_valuehl 
2ddf				endm 
# End of macro FORTH_DSP_VALUEHL
2ddf			 
2ddf e5					push hl   ; save address 
2de0			 
2de0					FORTH_DSP_POP 
2de0 cd 90 20			call macro_forth_dsp_pop 
2de3				endm 
# End of macro FORTH_DSP_POP
2de3			 
2de3					FORTH_DSP_VALUEHL 
2de3 cd d8 1f			call macro_dsp_valuehl 
2de6				endm 
# End of macro FORTH_DSP_VALUEHL
2de6			 
2de6					FORTH_DSP_POP 
2de6 cd 90 20			call macro_forth_dsp_pop 
2de9				endm 
# End of macro FORTH_DSP_POP
2de9			 
2de9					; hl contains value to add to byte at a 
2de9				 
2de9 eb					ex de, hl 
2dea			 
2dea e1					pop hl 
2deb			 
2deb					if DEBUG_FORTH_WORDS 
2deb						DMARK "INC" 
2deb f5				push af  
2dec 3a 00 2e			ld a, (.dmark)  
2def 32 6e fb			ld (debug_mark),a  
2df2 3a 01 2e			ld a, (.dmark+1)  
2df5 32 6f fb			ld (debug_mark+1),a  
2df8 3a 02 2e			ld a, (.dmark+2)  
2dfb 32 70 fb			ld (debug_mark+2),a  
2dfe 18 03			jr .pastdmark  
2e00 ..			.dmark: db "INC"  
2e03 f1			.pastdmark: pop af  
2e04			endm  
# End of macro DMARK
2e04						CALLMONITOR 
2e04 cd 84 17			call break_point_state  
2e07				endm  
# End of macro CALLMONITOR
2e07					endif 
2e07			 
2e07 7e					ld a,(hl) 
2e08 83					add e 
2e09 77					ld (hl),a 
2e0a			 
2e0a			 
2e0a			 
2e0a				       NEXTW 
2e0a c3 4a 21			jp macro_next 
2e0d				endm 
# End of macro NEXTW
2e0d			 
2e0d			.DEC: 
2e0d				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2e0d 6f				db WORD_SYS_CORE+91             
2e0e 5e 2e			dw .INC2            
2e10 03				db 2 + 1 
2e11 .. 00			db "-!",0              
2e14				endm 
# End of macro CWHEAD
2e14			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2e14					if DEBUG_FORTH_WORDS_KEY 
2e14						DMARK "-s_" 
2e14 f5				push af  
2e15 3a 29 2e			ld a, (.dmark)  
2e18 32 6e fb			ld (debug_mark),a  
2e1b 3a 2a 2e			ld a, (.dmark+1)  
2e1e 32 6f fb			ld (debug_mark+1),a  
2e21 3a 2b 2e			ld a, (.dmark+2)  
2e24 32 70 fb			ld (debug_mark+2),a  
2e27 18 03			jr .pastdmark  
2e29 ..			.dmark: db "-s_"  
2e2c f1			.pastdmark: pop af  
2e2d			endm  
# End of macro DMARK
2e2d						CALLMONITOR 
2e2d cd 84 17			call break_point_state  
2e30				endm  
# End of macro CALLMONITOR
2e30					endif 
2e30			 
2e30					FORTH_DSP_VALUEHL 
2e30 cd d8 1f			call macro_dsp_valuehl 
2e33				endm 
# End of macro FORTH_DSP_VALUEHL
2e33			 
2e33 e5					push hl   ; save address 
2e34			 
2e34					FORTH_DSP_POP 
2e34 cd 90 20			call macro_forth_dsp_pop 
2e37				endm 
# End of macro FORTH_DSP_POP
2e37			 
2e37					FORTH_DSP_VALUEHL 
2e37 cd d8 1f			call macro_dsp_valuehl 
2e3a				endm 
# End of macro FORTH_DSP_VALUEHL
2e3a			 
2e3a					; hl contains value to add to byte at a 
2e3a				 
2e3a eb					ex de, hl 
2e3b			 
2e3b e1					pop hl 
2e3c			 
2e3c					if DEBUG_FORTH_WORDS 
2e3c						DMARK "DEC" 
2e3c f5				push af  
2e3d 3a 51 2e			ld a, (.dmark)  
2e40 32 6e fb			ld (debug_mark),a  
2e43 3a 52 2e			ld a, (.dmark+1)  
2e46 32 6f fb			ld (debug_mark+1),a  
2e49 3a 53 2e			ld a, (.dmark+2)  
2e4c 32 70 fb			ld (debug_mark+2),a  
2e4f 18 03			jr .pastdmark  
2e51 ..			.dmark: db "DEC"  
2e54 f1			.pastdmark: pop af  
2e55			endm  
# End of macro DMARK
2e55						CALLMONITOR 
2e55 cd 84 17			call break_point_state  
2e58				endm  
# End of macro CALLMONITOR
2e58					endif 
2e58			 
2e58 7e					ld a,(hl) 
2e59 93					sub e 
2e5a 77					ld (hl),a 
2e5b			 
2e5b			 
2e5b			 
2e5b				       NEXTW 
2e5b c3 4a 21			jp macro_next 
2e5e				endm 
# End of macro NEXTW
2e5e			 
2e5e			.INC2: 
2e5e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e5e 6f				db WORD_SYS_CORE+91             
2e5f 08 2f			dw .DEC2            
2e61 04				db 3 + 1 
2e62 .. 00			db "+2!",0              
2e66				endm 
# End of macro CWHEAD
2e66			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e66			 
2e66					if DEBUG_FORTH_WORDS_KEY 
2e66						DMARK "+2s" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 6e fb			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 6f fb			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 70 fb			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "+2s"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f						CALLMONITOR 
2e7f cd 84 17			call break_point_state  
2e82				endm  
# End of macro CALLMONITOR
2e82					endif 
2e82			 
2e82					; Address 
2e82			 
2e82					FORTH_DSP_VALUEHL 
2e82 cd d8 1f			call macro_dsp_valuehl 
2e85				endm 
# End of macro FORTH_DSP_VALUEHL
2e85			 
2e85 e5					push hl    ; save address 
2e86			 
2e86					; load content into de 
2e86			 
2e86 5e					ld e,(hl) 
2e87 23					inc hl 
2e88 56					ld d, (hl) 
2e89			 
2e89					if DEBUG_FORTH_WORDS 
2e89						DMARK "+2a" 
2e89 f5				push af  
2e8a 3a 9e 2e			ld a, (.dmark)  
2e8d 32 6e fb			ld (debug_mark),a  
2e90 3a 9f 2e			ld a, (.dmark+1)  
2e93 32 6f fb			ld (debug_mark+1),a  
2e96 3a a0 2e			ld a, (.dmark+2)  
2e99 32 70 fb			ld (debug_mark+2),a  
2e9c 18 03			jr .pastdmark  
2e9e ..			.dmark: db "+2a"  
2ea1 f1			.pastdmark: pop af  
2ea2			endm  
# End of macro DMARK
2ea2						CALLMONITOR 
2ea2 cd 84 17			call break_point_state  
2ea5				endm  
# End of macro CALLMONITOR
2ea5					endif 
2ea5			 
2ea5					FORTH_DSP_POP 
2ea5 cd 90 20			call macro_forth_dsp_pop 
2ea8				endm 
# End of macro FORTH_DSP_POP
2ea8			 
2ea8					; Get value to add 
2ea8			 
2ea8					FORTH_DSP_VALUE 
2ea8 cd c1 1f			call macro_forth_dsp_value 
2eab				endm 
# End of macro FORTH_DSP_VALUE
2eab			 
2eab					if DEBUG_FORTH_WORDS 
2eab						DMARK "+2v" 
2eab f5				push af  
2eac 3a c0 2e			ld a, (.dmark)  
2eaf 32 6e fb			ld (debug_mark),a  
2eb2 3a c1 2e			ld a, (.dmark+1)  
2eb5 32 6f fb			ld (debug_mark+1),a  
2eb8 3a c2 2e			ld a, (.dmark+2)  
2ebb 32 70 fb			ld (debug_mark+2),a  
2ebe 18 03			jr .pastdmark  
2ec0 ..			.dmark: db "+2v"  
2ec3 f1			.pastdmark: pop af  
2ec4			endm  
# End of macro DMARK
2ec4						CALLMONITOR 
2ec4 cd 84 17			call break_point_state  
2ec7				endm  
# End of macro CALLMONITOR
2ec7					endif 
2ec7			 
2ec7 19					add hl, de 
2ec8			 
2ec8					if DEBUG_FORTH_WORDS 
2ec8						DMARK "+2+" 
2ec8 f5				push af  
2ec9 3a dd 2e			ld a, (.dmark)  
2ecc 32 6e fb			ld (debug_mark),a  
2ecf 3a de 2e			ld a, (.dmark+1)  
2ed2 32 6f fb			ld (debug_mark+1),a  
2ed5 3a df 2e			ld a, (.dmark+2)  
2ed8 32 70 fb			ld (debug_mark+2),a  
2edb 18 03			jr .pastdmark  
2edd ..			.dmark: db "+2+"  
2ee0 f1			.pastdmark: pop af  
2ee1			endm  
# End of macro DMARK
2ee1						CALLMONITOR 
2ee1 cd 84 17			call break_point_state  
2ee4				endm  
# End of macro CALLMONITOR
2ee4					endif 
2ee4			 
2ee4					; move result to de 
2ee4			 
2ee4 eb					ex de, hl 
2ee5			 
2ee5					; Address 
2ee5			 
2ee5 e1					pop hl 
2ee6			 
2ee6					; save it back 
2ee6			 
2ee6 73					ld (hl), e 
2ee7 23					inc hl 
2ee8 72					ld (hl), d 
2ee9			 
2ee9					if DEBUG_FORTH_WORDS 
2ee9						DMARK "+2e" 
2ee9 f5				push af  
2eea 3a fe 2e			ld a, (.dmark)  
2eed 32 6e fb			ld (debug_mark),a  
2ef0 3a ff 2e			ld a, (.dmark+1)  
2ef3 32 6f fb			ld (debug_mark+1),a  
2ef6 3a 00 2f			ld a, (.dmark+2)  
2ef9 32 70 fb			ld (debug_mark+2),a  
2efc 18 03			jr .pastdmark  
2efe ..			.dmark: db "+2e"  
2f01 f1			.pastdmark: pop af  
2f02			endm  
# End of macro DMARK
2f02						CALLMONITOR 
2f02 cd 84 17			call break_point_state  
2f05				endm  
# End of macro CALLMONITOR
2f05					endif 
2f05			 
2f05			 
2f05			 
2f05			 
2f05			 
2f05				       NEXTW 
2f05 c3 4a 21			jp macro_next 
2f08				endm 
# End of macro NEXTW
2f08			 
2f08			.DEC2: 
2f08				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2f08 6f				db WORD_SYS_CORE+91             
2f09 b4 2f			dw .GET2            
2f0b 04				db 3 + 1 
2f0c .. 00			db "-2!",0              
2f10				endm 
# End of macro CWHEAD
2f10			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2f10			 
2f10			 
2f10					if DEBUG_FORTH_WORDS_KEY 
2f10						DMARK "-2s" 
2f10 f5				push af  
2f11 3a 25 2f			ld a, (.dmark)  
2f14 32 6e fb			ld (debug_mark),a  
2f17 3a 26 2f			ld a, (.dmark+1)  
2f1a 32 6f fb			ld (debug_mark+1),a  
2f1d 3a 27 2f			ld a, (.dmark+2)  
2f20 32 70 fb			ld (debug_mark+2),a  
2f23 18 03			jr .pastdmark  
2f25 ..			.dmark: db "-2s"  
2f28 f1			.pastdmark: pop af  
2f29			endm  
# End of macro DMARK
2f29						CALLMONITOR 
2f29 cd 84 17			call break_point_state  
2f2c				endm  
# End of macro CALLMONITOR
2f2c					endif 
2f2c			 
2f2c					; Address 
2f2c			 
2f2c					FORTH_DSP_VALUEHL 
2f2c cd d8 1f			call macro_dsp_valuehl 
2f2f				endm 
# End of macro FORTH_DSP_VALUEHL
2f2f			 
2f2f e5					push hl    ; save address 
2f30			 
2f30					; load content into de 
2f30			 
2f30 5e					ld e,(hl) 
2f31 23					inc hl 
2f32 56					ld d, (hl) 
2f33			 
2f33					if DEBUG_FORTH_WORDS 
2f33						DMARK "-2a" 
2f33 f5				push af  
2f34 3a 48 2f			ld a, (.dmark)  
2f37 32 6e fb			ld (debug_mark),a  
2f3a 3a 49 2f			ld a, (.dmark+1)  
2f3d 32 6f fb			ld (debug_mark+1),a  
2f40 3a 4a 2f			ld a, (.dmark+2)  
2f43 32 70 fb			ld (debug_mark+2),a  
2f46 18 03			jr .pastdmark  
2f48 ..			.dmark: db "-2a"  
2f4b f1			.pastdmark: pop af  
2f4c			endm  
# End of macro DMARK
2f4c						CALLMONITOR 
2f4c cd 84 17			call break_point_state  
2f4f				endm  
# End of macro CALLMONITOR
2f4f					endif 
2f4f			 
2f4f					FORTH_DSP_POP 
2f4f cd 90 20			call macro_forth_dsp_pop 
2f52				endm 
# End of macro FORTH_DSP_POP
2f52			 
2f52					; Get value to remove 
2f52			 
2f52					FORTH_DSP_VALUE 
2f52 cd c1 1f			call macro_forth_dsp_value 
2f55				endm 
# End of macro FORTH_DSP_VALUE
2f55			 
2f55					if DEBUG_FORTH_WORDS 
2f55						DMARK "-2v" 
2f55 f5				push af  
2f56 3a 6a 2f			ld a, (.dmark)  
2f59 32 6e fb			ld (debug_mark),a  
2f5c 3a 6b 2f			ld a, (.dmark+1)  
2f5f 32 6f fb			ld (debug_mark+1),a  
2f62 3a 6c 2f			ld a, (.dmark+2)  
2f65 32 70 fb			ld (debug_mark+2),a  
2f68 18 03			jr .pastdmark  
2f6a ..			.dmark: db "-2v"  
2f6d f1			.pastdmark: pop af  
2f6e			endm  
# End of macro DMARK
2f6e						CALLMONITOR 
2f6e cd 84 17			call break_point_state  
2f71				endm  
# End of macro CALLMONITOR
2f71					endif 
2f71			 
2f71 eb					ex de, hl 
2f72 ed 52				sbc hl, de 
2f74			 
2f74					if DEBUG_FORTH_WORDS 
2f74						DMARK "-2d" 
2f74 f5				push af  
2f75 3a 89 2f			ld a, (.dmark)  
2f78 32 6e fb			ld (debug_mark),a  
2f7b 3a 8a 2f			ld a, (.dmark+1)  
2f7e 32 6f fb			ld (debug_mark+1),a  
2f81 3a 8b 2f			ld a, (.dmark+2)  
2f84 32 70 fb			ld (debug_mark+2),a  
2f87 18 03			jr .pastdmark  
2f89 ..			.dmark: db "-2d"  
2f8c f1			.pastdmark: pop af  
2f8d			endm  
# End of macro DMARK
2f8d						CALLMONITOR 
2f8d cd 84 17			call break_point_state  
2f90				endm  
# End of macro CALLMONITOR
2f90					endif 
2f90			 
2f90					; move result to de 
2f90			 
2f90 eb					ex de, hl 
2f91			 
2f91					; Address 
2f91			 
2f91 e1					pop hl 
2f92			 
2f92					; save it back 
2f92			 
2f92 73					ld (hl), e 
2f93 23					inc hl 
2f94 72					ld (hl), d 
2f95			 
2f95					if DEBUG_FORTH_WORDS 
2f95						DMARK "-2e" 
2f95 f5				push af  
2f96 3a aa 2f			ld a, (.dmark)  
2f99 32 6e fb			ld (debug_mark),a  
2f9c 3a ab 2f			ld a, (.dmark+1)  
2f9f 32 6f fb			ld (debug_mark+1),a  
2fa2 3a ac 2f			ld a, (.dmark+2)  
2fa5 32 70 fb			ld (debug_mark+2),a  
2fa8 18 03			jr .pastdmark  
2faa ..			.dmark: db "-2e"  
2fad f1			.pastdmark: pop af  
2fae			endm  
# End of macro DMARK
2fae						CALLMONITOR 
2fae cd 84 17			call break_point_state  
2fb1				endm  
# End of macro CALLMONITOR
2fb1					endif 
2fb1			 
2fb1			 
2fb1			 
2fb1			 
2fb1			 
2fb1				       NEXTW 
2fb1 c3 4a 21			jp macro_next 
2fb4				endm 
# End of macro NEXTW
2fb4			.GET2: 
2fb4				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2fb4 6f				db WORD_SYS_CORE+91             
2fb5 e4 2f			dw .BANG2            
2fb7 03				db 2 + 1 
2fb8 .. 00			db "2@",0              
2fbb				endm 
# End of macro CWHEAD
2fbb			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2fbb					if DEBUG_FORTH_WORDS_KEY 
2fbb						DMARK "2A_" 
2fbb f5				push af  
2fbc 3a d0 2f			ld a, (.dmark)  
2fbf 32 6e fb			ld (debug_mark),a  
2fc2 3a d1 2f			ld a, (.dmark+1)  
2fc5 32 6f fb			ld (debug_mark+1),a  
2fc8 3a d2 2f			ld a, (.dmark+2)  
2fcb 32 70 fb			ld (debug_mark+2),a  
2fce 18 03			jr .pastdmark  
2fd0 ..			.dmark: db "2A_"  
2fd3 f1			.pastdmark: pop af  
2fd4			endm  
# End of macro DMARK
2fd4						CALLMONITOR 
2fd4 cd 84 17			call break_point_state  
2fd7				endm  
# End of macro CALLMONITOR
2fd7					endif 
2fd7			 
2fd7					FORTH_DSP_VALUEHL 
2fd7 cd d8 1f			call macro_dsp_valuehl 
2fda				endm 
# End of macro FORTH_DSP_VALUEHL
2fda			 
2fda 5e					ld e, (hl) 
2fdb 23					inc hl 
2fdc 56					ld d, (hl) 
2fdd			 
2fdd eb					ex de, hl 
2fde			 
2fde cd e1 1d				call forth_push_numhl 
2fe1			 
2fe1				       NEXTW 
2fe1 c3 4a 21			jp macro_next 
2fe4				endm 
# End of macro NEXTW
2fe4			.BANG2: 
2fe4				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2fe4 6f				db WORD_SYS_CORE+91             
2fe5 1c 30			dw .CONFIG            
2fe7 03				db 2 + 1 
2fe8 .. 00			db "2!",0              
2feb				endm 
# End of macro CWHEAD
2feb			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2feb					if DEBUG_FORTH_WORDS_KEY 
2feb						DMARK "2S_" 
2feb f5				push af  
2fec 3a 00 30			ld a, (.dmark)  
2fef 32 6e fb			ld (debug_mark),a  
2ff2 3a 01 30			ld a, (.dmark+1)  
2ff5 32 6f fb			ld (debug_mark+1),a  
2ff8 3a 02 30			ld a, (.dmark+2)  
2ffb 32 70 fb			ld (debug_mark+2),a  
2ffe 18 03			jr .pastdmark  
3000 ..			.dmark: db "2S_"  
3003 f1			.pastdmark: pop af  
3004			endm  
# End of macro DMARK
3004						CALLMONITOR 
3004 cd 84 17			call break_point_state  
3007				endm  
# End of macro CALLMONITOR
3007					endif 
3007			 
3007					FORTH_DSP_VALUEHL 
3007 cd d8 1f			call macro_dsp_valuehl 
300a				endm 
# End of macro FORTH_DSP_VALUEHL
300a			 
300a e5					push hl   ; save address 
300b			 
300b			 
300b					FORTH_DSP_POP 
300b cd 90 20			call macro_forth_dsp_pop 
300e				endm 
# End of macro FORTH_DSP_POP
300e			 
300e					 
300e					FORTH_DSP_VALUEHL 
300e cd d8 1f			call macro_dsp_valuehl 
3011				endm 
# End of macro FORTH_DSP_VALUEHL
3011			 
3011					FORTH_DSP_POP 
3011 cd 90 20			call macro_forth_dsp_pop 
3014				endm 
# End of macro FORTH_DSP_POP
3014			 
3014 eb					ex de, hl    ; value now in de 
3015			 
3015 e1					pop hl 
3016			 
3016 73					ld (hl), e 
3017			 
3017 23					inc hl 
3018			 
3018 72					ld (hl), d 
3019			 
3019			 
3019				       NEXTW 
3019 c3 4a 21			jp macro_next 
301c				endm 
# End of macro NEXTW
301c			.CONFIG: 
301c				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
301c 6f				db WORD_SYS_CORE+91             
301d 2d 30			dw .ENDCORE            
301f 07				db 6 + 1 
3020 .. 00			db "CONFIG",0              
3027				endm 
# End of macro CWHEAD
3027			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3027			 
3027 cd 67 14				call config 
302a					NEXTW 
302a c3 4a 21			jp macro_next 
302d				endm 
# End of macro NEXTW
302d			.ENDCORE: 
302d			 
302d			; eof 
302d			 
302d			 
# End of file forth_words_core.asm
302d			include "forth_words_flow.asm" 
302d			 
302d			; | ## Program Flow Words 
302d			 
302d			.IF: 
302d				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
302d 1e				db WORD_SYS_CORE+10             
302e 22 31			dw .THEN            
3030 03				db 2 + 1 
3031 .. 00			db "IF",0              
3034				endm 
# End of macro CWHEAD
3034			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3034			; 
3034					if DEBUG_FORTH_WORDS_KEY 
3034						DMARK "IF." 
3034 f5				push af  
3035 3a 49 30			ld a, (.dmark)  
3038 32 6e fb			ld (debug_mark),a  
303b 3a 4a 30			ld a, (.dmark+1)  
303e 32 6f fb			ld (debug_mark+1),a  
3041 3a 4b 30			ld a, (.dmark+2)  
3044 32 70 fb			ld (debug_mark+2),a  
3047 18 03			jr .pastdmark  
3049 ..			.dmark: db "IF."  
304c f1			.pastdmark: pop af  
304d			endm  
# End of macro DMARK
304d						CALLMONITOR 
304d cd 84 17			call break_point_state  
3050				endm  
# End of macro CALLMONITOR
3050					endif 
3050			; eval TOS 
3050			 
3050				FORTH_DSP_VALUEHL 
3050 cd d8 1f			call macro_dsp_valuehl 
3053				endm 
# End of macro FORTH_DSP_VALUEHL
3053			 
3053			;	push hl 
3053				FORTH_DSP_POP 
3053 cd 90 20			call macro_forth_dsp_pop 
3056				endm 
# End of macro FORTH_DSP_POP
3056			;	pop hl 
3056			 
3056					if DEBUG_FORTH_WORDS 
3056						DMARK "IF1" 
3056 f5				push af  
3057 3a 6b 30			ld a, (.dmark)  
305a 32 6e fb			ld (debug_mark),a  
305d 3a 6c 30			ld a, (.dmark+1)  
3060 32 6f fb			ld (debug_mark+1),a  
3063 3a 6d 30			ld a, (.dmark+2)  
3066 32 70 fb			ld (debug_mark+2),a  
3069 18 03			jr .pastdmark  
306b ..			.dmark: db "IF1"  
306e f1			.pastdmark: pop af  
306f			endm  
# End of macro DMARK
306f						CALLMONITOR 
306f cd 84 17			call break_point_state  
3072				endm  
# End of macro CALLMONITOR
3072					endif 
3072 b7				or a        ; clear carry flag 
3073 11 00 00			ld de, 0 
3076 eb				ex de,hl 
3077 ed 52			sbc hl, de 
3079 c2 03 31			jp nz, .iftrue 
307c			 
307c					if DEBUG_FORTH_WORDS 
307c						DMARK "IF2" 
307c f5				push af  
307d 3a 91 30			ld a, (.dmark)  
3080 32 6e fb			ld (debug_mark),a  
3083 3a 92 30			ld a, (.dmark+1)  
3086 32 6f fb			ld (debug_mark+1),a  
3089 3a 93 30			ld a, (.dmark+2)  
308c 32 70 fb			ld (debug_mark+2),a  
308f 18 03			jr .pastdmark  
3091 ..			.dmark: db "IF2"  
3094 f1			.pastdmark: pop af  
3095			endm  
# End of macro DMARK
3095						CALLMONITOR 
3095 cd 84 17			call break_point_state  
3098				endm  
# End of macro CALLMONITOR
3098					endif 
3098			 
3098			; if not true then skip to THEN 
3098			 
3098				; TODO get tok_ptr 
3098				; TODO consume toks until we get to THEN 
3098			 
3098 2a 15 f1			ld hl, (os_tok_ptr) 
309b					if DEBUG_FORTH_WORDS 
309b						DMARK "IF3" 
309b f5				push af  
309c 3a b0 30			ld a, (.dmark)  
309f 32 6e fb			ld (debug_mark),a  
30a2 3a b1 30			ld a, (.dmark+1)  
30a5 32 6f fb			ld (debug_mark+1),a  
30a8 3a b2 30			ld a, (.dmark+2)  
30ab 32 70 fb			ld (debug_mark+2),a  
30ae 18 03			jr .pastdmark  
30b0 ..			.dmark: db "IF3"  
30b3 f1			.pastdmark: pop af  
30b4			endm  
# End of macro DMARK
30b4						CALLMONITOR 
30b4 cd 84 17			call break_point_state  
30b7				endm  
# End of macro CALLMONITOR
30b7						 
30b7					endif 
30b7 11 fe 30			ld de, .ifthen 
30ba					if DEBUG_FORTH_WORDS 
30ba						DMARK "IF4" 
30ba f5				push af  
30bb 3a cf 30			ld a, (.dmark)  
30be 32 6e fb			ld (debug_mark),a  
30c1 3a d0 30			ld a, (.dmark+1)  
30c4 32 6f fb			ld (debug_mark+1),a  
30c7 3a d1 30			ld a, (.dmark+2)  
30ca 32 70 fb			ld (debug_mark+2),a  
30cd 18 03			jr .pastdmark  
30cf ..			.dmark: db "IF4"  
30d2 f1			.pastdmark: pop af  
30d3			endm  
# End of macro DMARK
30d3						CALLMONITOR 
30d3 cd 84 17			call break_point_state  
30d6				endm  
# End of macro CALLMONITOR
30d6					endif 
30d6 cd 65 22			call findnexttok  
30d9			 
30d9					if DEBUG_FORTH_WORDS 
30d9						DMARK "IF5" 
30d9 f5				push af  
30da 3a ee 30			ld a, (.dmark)  
30dd 32 6e fb			ld (debug_mark),a  
30e0 3a ef 30			ld a, (.dmark+1)  
30e3 32 6f fb			ld (debug_mark+1),a  
30e6 3a f0 30			ld a, (.dmark+2)  
30e9 32 70 fb			ld (debug_mark+2),a  
30ec 18 03			jr .pastdmark  
30ee ..			.dmark: db "IF5"  
30f1 f1			.pastdmark: pop af  
30f2			endm  
# End of macro DMARK
30f2						CALLMONITOR 
30f2 cd 84 17			call break_point_state  
30f5				endm  
# End of macro CALLMONITOR
30f5					endif 
30f5				; TODO replace below with ; exec using tok_ptr 
30f5 22 15 f1			ld (os_tok_ptr), hl 
30f8 c3 db 21			jp exec1 
30fb				NEXTW 
30fb c3 4a 21			jp macro_next 
30fe				endm 
# End of macro NEXTW
30fe			 
30fe .. 00		.ifthen:  db "THEN",0 
3103			 
3103			.iftrue:		 
3103				; Exec next words normally 
3103			 
3103				; if true then exec following IF as normal 
3103					if DEBUG_FORTH_WORDS 
3103						DMARK "IFT" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 6e fb			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 6f fb			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 70 fb			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "IFT"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c						CALLMONITOR 
311c cd 84 17			call break_point_state  
311f				endm  
# End of macro CALLMONITOR
311f					endif 
311f			 
311f					NEXTW 
311f c3 4a 21			jp macro_next 
3122				endm 
# End of macro NEXTW
3122			.THEN: 
3122				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3122 1f				db WORD_SYS_CORE+11             
3123 4a 31			dw .ELSE            
3125 05				db 4 + 1 
3126 .. 00			db "THEN",0              
312b				endm 
# End of macro CWHEAD
312b			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
312b					if DEBUG_FORTH_WORDS_KEY 
312b						DMARK "THN" 
312b f5				push af  
312c 3a 40 31			ld a, (.dmark)  
312f 32 6e fb			ld (debug_mark),a  
3132 3a 41 31			ld a, (.dmark+1)  
3135 32 6f fb			ld (debug_mark+1),a  
3138 3a 42 31			ld a, (.dmark+2)  
313b 32 70 fb			ld (debug_mark+2),a  
313e 18 03			jr .pastdmark  
3140 ..			.dmark: db "THN"  
3143 f1			.pastdmark: pop af  
3144			endm  
# End of macro DMARK
3144						CALLMONITOR 
3144 cd 84 17			call break_point_state  
3147				endm  
# End of macro CALLMONITOR
3147					endif 
3147					NEXTW 
3147 c3 4a 21			jp macro_next 
314a				endm 
# End of macro NEXTW
314a			.ELSE: 
314a				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
314a 20				db WORD_SYS_CORE+12             
314b 72 31			dw .DO            
314d 03				db 2 + 1 
314e .. 00			db "ELSE",0              
3153				endm 
# End of macro CWHEAD
3153			; | ELSE ( -- ) Not supported - does nothing | TODO 
3153			 
3153					if DEBUG_FORTH_WORDS_KEY 
3153						DMARK "ELS" 
3153 f5				push af  
3154 3a 68 31			ld a, (.dmark)  
3157 32 6e fb			ld (debug_mark),a  
315a 3a 69 31			ld a, (.dmark+1)  
315d 32 6f fb			ld (debug_mark+1),a  
3160 3a 6a 31			ld a, (.dmark+2)  
3163 32 70 fb			ld (debug_mark+2),a  
3166 18 03			jr .pastdmark  
3168 ..			.dmark: db "ELS"  
316b f1			.pastdmark: pop af  
316c			endm  
# End of macro DMARK
316c						CALLMONITOR 
316c cd 84 17			call break_point_state  
316f				endm  
# End of macro CALLMONITOR
316f					endif 
316f			 
316f			 
316f					NEXTW 
316f c3 4a 21			jp macro_next 
3172				endm 
# End of macro NEXTW
3172			.DO: 
3172				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3172 21				db WORD_SYS_CORE+13             
3173 99 32			dw .LOOP            
3175 03				db 2 + 1 
3176 .. 00			db "DO",0              
3179				endm 
# End of macro CWHEAD
3179			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3179			 
3179					if DEBUG_FORTH_WORDS_KEY 
3179						DMARK "DO." 
3179 f5				push af  
317a 3a 8e 31			ld a, (.dmark)  
317d 32 6e fb			ld (debug_mark),a  
3180 3a 8f 31			ld a, (.dmark+1)  
3183 32 6f fb			ld (debug_mark+1),a  
3186 3a 90 31			ld a, (.dmark+2)  
3189 32 70 fb			ld (debug_mark+2),a  
318c 18 03			jr .pastdmark  
318e ..			.dmark: db "DO."  
3191 f1			.pastdmark: pop af  
3192			endm  
# End of macro DMARK
3192						CALLMONITOR 
3192 cd 84 17			call break_point_state  
3195				endm  
# End of macro CALLMONITOR
3195					endif 
3195			;  push pc to rsp stack past the DO 
3195			 
3195 2a 15 f1				ld hl, (os_tok_ptr) 
3198 23					inc hl   ; D 
3199 23					inc hl  ; O 
319a 23					inc hl   ; null 
319b					if DEBUG_FORTH_WORDS 
319b						DMARK "DO2" 
319b f5				push af  
319c 3a b0 31			ld a, (.dmark)  
319f 32 6e fb			ld (debug_mark),a  
31a2 3a b1 31			ld a, (.dmark+1)  
31a5 32 6f fb			ld (debug_mark+1),a  
31a8 3a b2 31			ld a, (.dmark+2)  
31ab 32 70 fb			ld (debug_mark+2),a  
31ae 18 03			jr .pastdmark  
31b0 ..			.dmark: db "DO2"  
31b3 f1			.pastdmark: pop af  
31b4			endm  
# End of macro DMARK
31b4						CALLMONITOR 
31b4 cd 84 17			call break_point_state  
31b7				endm  
# End of macro CALLMONITOR
31b7					endif 
31b7					FORTH_RSP_NEXT 
31b7 cd 88 1d			call macro_forth_rsp_next 
31ba				endm 
# End of macro FORTH_RSP_NEXT
31ba					if DEBUG_FORTH_WORDS 
31ba						DMARK "DO3" 
31ba f5				push af  
31bb 3a cf 31			ld a, (.dmark)  
31be 32 6e fb			ld (debug_mark),a  
31c1 3a d0 31			ld a, (.dmark+1)  
31c4 32 6f fb			ld (debug_mark+1),a  
31c7 3a d1 31			ld a, (.dmark+2)  
31ca 32 70 fb			ld (debug_mark+2),a  
31cd 18 03			jr .pastdmark  
31cf ..			.dmark: db "DO3"  
31d2 f1			.pastdmark: pop af  
31d3			endm  
# End of macro DMARK
31d3						CALLMONITOR 
31d3 cd 84 17			call break_point_state  
31d6				endm  
# End of macro CALLMONITOR
31d6					endif 
31d6			 
31d6					;if DEBUG_FORTH_WORDS 
31d6				;		push hl 
31d6			;		endif  
31d6			 
31d6			; get counters from data stack 
31d6			 
31d6			 
31d6					FORTH_DSP_VALUEHL 
31d6 cd d8 1f			call macro_dsp_valuehl 
31d9				endm 
# End of macro FORTH_DSP_VALUEHL
31d9 e5					push hl		 ; hl now has starting counter which needs to be tos 
31da			 
31da					if DEBUG_FORTH_WORDS 
31da						DMARK "DO4" 
31da f5				push af  
31db 3a ef 31			ld a, (.dmark)  
31de 32 6e fb			ld (debug_mark),a  
31e1 3a f0 31			ld a, (.dmark+1)  
31e4 32 6f fb			ld (debug_mark+1),a  
31e7 3a f1 31			ld a, (.dmark+2)  
31ea 32 70 fb			ld (debug_mark+2),a  
31ed 18 03			jr .pastdmark  
31ef ..			.dmark: db "DO4"  
31f2 f1			.pastdmark: pop af  
31f3			endm  
# End of macro DMARK
31f3						CALLMONITOR 
31f3 cd 84 17			call break_point_state  
31f6				endm  
# End of macro CALLMONITOR
31f6					endif 
31f6					FORTH_DSP_POP 
31f6 cd 90 20			call macro_forth_dsp_pop 
31f9				endm 
# End of macro FORTH_DSP_POP
31f9			 
31f9					if DEBUG_FORTH_WORDS 
31f9						DMARK "DO5" 
31f9 f5				push af  
31fa 3a 0e 32			ld a, (.dmark)  
31fd 32 6e fb			ld (debug_mark),a  
3200 3a 0f 32			ld a, (.dmark+1)  
3203 32 6f fb			ld (debug_mark+1),a  
3206 3a 10 32			ld a, (.dmark+2)  
3209 32 70 fb			ld (debug_mark+2),a  
320c 18 03			jr .pastdmark  
320e ..			.dmark: db "DO5"  
3211 f1			.pastdmark: pop af  
3212			endm  
# End of macro DMARK
3212						CALLMONITOR 
3212 cd 84 17			call break_point_state  
3215				endm  
# End of macro CALLMONITOR
3215					endif 
3215			 
3215					FORTH_DSP_VALUEHL 
3215 cd d8 1f			call macro_dsp_valuehl 
3218				endm 
# End of macro FORTH_DSP_VALUEHL
3218			;		push hl		 ; hl now has starting limit counter 
3218			 
3218					if DEBUG_FORTH_WORDS 
3218						DMARK "DO6" 
3218 f5				push af  
3219 3a 2d 32			ld a, (.dmark)  
321c 32 6e fb			ld (debug_mark),a  
321f 3a 2e 32			ld a, (.dmark+1)  
3222 32 6f fb			ld (debug_mark+1),a  
3225 3a 2f 32			ld a, (.dmark+2)  
3228 32 70 fb			ld (debug_mark+2),a  
322b 18 03			jr .pastdmark  
322d ..			.dmark: db "DO6"  
3230 f1			.pastdmark: pop af  
3231			endm  
# End of macro DMARK
3231						CALLMONITOR 
3231 cd 84 17			call break_point_state  
3234				endm  
# End of macro CALLMONITOR
3234					endif 
3234					FORTH_DSP_POP 
3234 cd 90 20			call macro_forth_dsp_pop 
3237				endm 
# End of macro FORTH_DSP_POP
3237			 
3237			; put counters on the loop stack 
3237			 
3237			;		pop hl			 ; limit counter 
3237 d1					pop de			; start counter 
3238			 
3238					; push limit counter 
3238			 
3238					if DEBUG_FORTH_WORDS 
3238						DMARK "DO7" 
3238 f5				push af  
3239 3a 4d 32			ld a, (.dmark)  
323c 32 6e fb			ld (debug_mark),a  
323f 3a 4e 32			ld a, (.dmark+1)  
3242 32 6f fb			ld (debug_mark+1),a  
3245 3a 4f 32			ld a, (.dmark+2)  
3248 32 70 fb			ld (debug_mark+2),a  
324b 18 03			jr .pastdmark  
324d ..			.dmark: db "DO7"  
3250 f1			.pastdmark: pop af  
3251			endm  
# End of macro DMARK
3251						CALLMONITOR 
3251 cd 84 17			call break_point_state  
3254				endm  
# End of macro CALLMONITOR
3254					endif 
3254					FORTH_LOOP_NEXT 
3254 cd 09 20			call macro_forth_loop_next 
3257				endm 
# End of macro FORTH_LOOP_NEXT
3257			 
3257					; push start counter 
3257			 
3257 eb					ex de, hl 
3258					if DEBUG_FORTH_WORDS 
3258						DMARK "DO7" 
3258 f5				push af  
3259 3a 6d 32			ld a, (.dmark)  
325c 32 6e fb			ld (debug_mark),a  
325f 3a 6e 32			ld a, (.dmark+1)  
3262 32 6f fb			ld (debug_mark+1),a  
3265 3a 6f 32			ld a, (.dmark+2)  
3268 32 70 fb			ld (debug_mark+2),a  
326b 18 03			jr .pastdmark  
326d ..			.dmark: db "DO7"  
3270 f1			.pastdmark: pop af  
3271			endm  
# End of macro DMARK
3271						CALLMONITOR 
3271 cd 84 17			call break_point_state  
3274				endm  
# End of macro CALLMONITOR
3274					endif 
3274					FORTH_LOOP_NEXT 
3274 cd 09 20			call macro_forth_loop_next 
3277				endm 
# End of macro FORTH_LOOP_NEXT
3277			 
3277			 
3277					; init first round of I counter 
3277			 
3277 22 39 f1				ld (os_current_i), hl 
327a			 
327a					if DEBUG_FORTH_WORDS 
327a						DMARK "DO8" 
327a f5				push af  
327b 3a 8f 32			ld a, (.dmark)  
327e 32 6e fb			ld (debug_mark),a  
3281 3a 90 32			ld a, (.dmark+1)  
3284 32 6f fb			ld (debug_mark+1),a  
3287 3a 91 32			ld a, (.dmark+2)  
328a 32 70 fb			ld (debug_mark+2),a  
328d 18 03			jr .pastdmark  
328f ..			.dmark: db "DO8"  
3292 f1			.pastdmark: pop af  
3293			endm  
# End of macro DMARK
3293						CALLMONITOR 
3293 cd 84 17			call break_point_state  
3296				endm  
# End of macro CALLMONITOR
3296					endif 
3296			 
3296					NEXTW 
3296 c3 4a 21			jp macro_next 
3299				endm 
# End of macro NEXTW
3299			.LOOP: 
3299				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3299 22				db WORD_SYS_CORE+14             
329a b1 33			dw .I            
329c 05				db 4 + 1 
329d .. 00			db "LOOP",0              
32a2				endm 
# End of macro CWHEAD
32a2			; | LOOP ( -- ) Increment and test loop counter  | DONE 
32a2			 
32a2				; pop tos as current loop count to hl 
32a2			 
32a2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32a2			 
32a2				FORTH_LOOP_TOS 
32a2 cd 3c 20			call macro_forth_loop_tos 
32a5				endm 
# End of macro FORTH_LOOP_TOS
32a5 e5				push hl 
32a6			 
32a6					if DEBUG_FORTH_WORDS_KEY 
32a6						DMARK "LOP" 
32a6 f5				push af  
32a7 3a bb 32			ld a, (.dmark)  
32aa 32 6e fb			ld (debug_mark),a  
32ad 3a bc 32			ld a, (.dmark+1)  
32b0 32 6f fb			ld (debug_mark+1),a  
32b3 3a bd 32			ld a, (.dmark+2)  
32b6 32 70 fb			ld (debug_mark+2),a  
32b9 18 03			jr .pastdmark  
32bb ..			.dmark: db "LOP"  
32be f1			.pastdmark: pop af  
32bf			endm  
# End of macro DMARK
32bf						CALLMONITOR 
32bf cd 84 17			call break_point_state  
32c2				endm  
# End of macro CALLMONITOR
32c2					endif 
32c2				; next item on the stack is the limit. get it 
32c2			 
32c2			 
32c2				FORTH_LOOP_POP 
32c2 cd 46 20			call macro_forth_loop_pop 
32c5				endm 
# End of macro FORTH_LOOP_POP
32c5			 
32c5				FORTH_LOOP_TOS 
32c5 cd 3c 20			call macro_forth_loop_tos 
32c8				endm 
# End of macro FORTH_LOOP_TOS
32c8			 
32c8 d1				pop de		 ; de = i, hl = limit 
32c9			 
32c9					if DEBUG_FORTH_WORDS 
32c9						DMARK "LP1" 
32c9 f5				push af  
32ca 3a de 32			ld a, (.dmark)  
32cd 32 6e fb			ld (debug_mark),a  
32d0 3a df 32			ld a, (.dmark+1)  
32d3 32 6f fb			ld (debug_mark+1),a  
32d6 3a e0 32			ld a, (.dmark+2)  
32d9 32 70 fb			ld (debug_mark+2),a  
32dc 18 03			jr .pastdmark  
32de ..			.dmark: db "LP1"  
32e1 f1			.pastdmark: pop af  
32e2			endm  
# End of macro DMARK
32e2						CALLMONITOR 
32e2 cd 84 17			call break_point_state  
32e5				endm  
# End of macro CALLMONITOR
32e5					endif 
32e5			 
32e5				; go back to previous word 
32e5			 
32e5 d5				push de    ; save I for inc later 
32e6			 
32e6			 
32e6				; get limit 
32e6				;  is I at limit? 
32e6			 
32e6			 
32e6					if DEBUG_FORTH_WORDS 
32e6						DMARK "LP1" 
32e6 f5				push af  
32e7 3a fb 32			ld a, (.dmark)  
32ea 32 6e fb			ld (debug_mark),a  
32ed 3a fc 32			ld a, (.dmark+1)  
32f0 32 6f fb			ld (debug_mark+1),a  
32f3 3a fd 32			ld a, (.dmark+2)  
32f6 32 70 fb			ld (debug_mark+2),a  
32f9 18 03			jr .pastdmark  
32fb ..			.dmark: db "LP1"  
32fe f1			.pastdmark: pop af  
32ff			endm  
# End of macro DMARK
32ff						CALLMONITOR 
32ff cd 84 17			call break_point_state  
3302				endm  
# End of macro CALLMONITOR
3302					endif 
3302			 
3302 ed 52			sbc hl, de 
3304			 
3304			 
3304				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3304			 
3304 20 26				jr nz, .loopnotdone 
3306			 
3306 e1				pop hl   ; get rid of saved I 
3307				FORTH_LOOP_POP     ; get rid of limit 
3307 cd 46 20			call macro_forth_loop_pop 
330a				endm 
# End of macro FORTH_LOOP_POP
330a			 
330a				FORTH_RSP_POP     ; get rid of DO ptr 
330a cd a9 1d			call macro_forth_rsp_pop 
330d				endm 
# End of macro FORTH_RSP_POP
330d			 
330d			if DEBUG_FORTH_WORDS 
330d						DMARK "LP>" 
330d f5				push af  
330e 3a 22 33			ld a, (.dmark)  
3311 32 6e fb			ld (debug_mark),a  
3314 3a 23 33			ld a, (.dmark+1)  
3317 32 6f fb			ld (debug_mark+1),a  
331a 3a 24 33			ld a, (.dmark+2)  
331d 32 70 fb			ld (debug_mark+2),a  
3320 18 03			jr .pastdmark  
3322 ..			.dmark: db "LP>"  
3325 f1			.pastdmark: pop af  
3326			endm  
# End of macro DMARK
3326				CALLMONITOR 
3326 cd 84 17			call break_point_state  
3329				endm  
# End of macro CALLMONITOR
3329			endif 
3329			 
3329					NEXTW 
3329 c3 4a 21			jp macro_next 
332c				endm 
# End of macro NEXTW
332c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
332c			 
332c			.loopnotdone: 
332c			 
332c e1				pop hl    ; get I 
332d 23				inc hl 
332e			 
332e			   	; save new I 
332e			 
332e			 
332e					; set I counter 
332e			 
332e 22 39 f1				ld (os_current_i), hl 
3331			 
3331					if DEBUG_FORTH_WORDS 
3331						DMARK "LPN" 
3331 f5				push af  
3332 3a 46 33			ld a, (.dmark)  
3335 32 6e fb			ld (debug_mark),a  
3338 3a 47 33			ld a, (.dmark+1)  
333b 32 6f fb			ld (debug_mark+1),a  
333e 3a 48 33			ld a, (.dmark+2)  
3341 32 70 fb			ld (debug_mark+2),a  
3344 18 03			jr .pastdmark  
3346 ..			.dmark: db "LPN"  
3349 f1			.pastdmark: pop af  
334a			endm  
# End of macro DMARK
334a					CALLMONITOR 
334a cd 84 17			call break_point_state  
334d				endm  
# End of macro CALLMONITOR
334d					endif 
334d					 
334d				FORTH_LOOP_NEXT 
334d cd 09 20			call macro_forth_loop_next 
3350				endm 
# End of macro FORTH_LOOP_NEXT
3350			 
3350			 
3350					if DEBUG_FORTH_WORDS 
3350 eb						ex de,hl 
3351					endif 
3351			 
3351			;	; get DO ptr 
3351			; 
3351					if DEBUG_FORTH_WORDS 
3351						DMARK "LP7" 
3351 f5				push af  
3352 3a 66 33			ld a, (.dmark)  
3355 32 6e fb			ld (debug_mark),a  
3358 3a 67 33			ld a, (.dmark+1)  
335b 32 6f fb			ld (debug_mark+1),a  
335e 3a 68 33			ld a, (.dmark+2)  
3361 32 70 fb			ld (debug_mark+2),a  
3364 18 03			jr .pastdmark  
3366 ..			.dmark: db "LP7"  
3369 f1			.pastdmark: pop af  
336a			endm  
# End of macro DMARK
336a					CALLMONITOR 
336a cd 84 17			call break_point_state  
336d				endm  
# End of macro CALLMONITOR
336d					endif 
336d				FORTH_RSP_TOS 
336d cd 9f 1d			call macro_forth_rsp_tos 
3370				endm 
# End of macro FORTH_RSP_TOS
3370			 
3370					if DEBUG_FORTH_WORDS 
3370						DMARK "LP8" 
3370 f5				push af  
3371 3a 85 33			ld a, (.dmark)  
3374 32 6e fb			ld (debug_mark),a  
3377 3a 86 33			ld a, (.dmark+1)  
337a 32 6f fb			ld (debug_mark+1),a  
337d 3a 87 33			ld a, (.dmark+2)  
3380 32 70 fb			ld (debug_mark+2),a  
3383 18 03			jr .pastdmark  
3385 ..			.dmark: db "LP8"  
3388 f1			.pastdmark: pop af  
3389			endm  
# End of macro DMARK
3389					CALLMONITOR 
3389 cd 84 17			call break_point_state  
338c				endm  
# End of macro CALLMONITOR
338c					endif 
338c				;push hl 
338c			 
338c				; not going to DO any more 
338c				; get rid of the RSP pointer as DO will add it back in 
338c				;FORTH_RSP_POP 
338c				;pop hl 
338c			 
338c				;ld hl,(cli_ret_sp) 
338c				;ld e, (hl) 
338c				;inc hl 
338c				;ld d, (hl) 
338c				;ex de,hl 
338c 22 15 f1			ld (os_tok_ptr), hl 
338f					if DEBUG_FORTH_WORDS 
338f						DMARK "LP<" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 6e fb			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 6f fb			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 70 fb			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "LP<"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8					CALLMONITOR 
33a8 cd 84 17			call break_point_state  
33ab				endm  
# End of macro CALLMONITOR
33ab				endif 
33ab c3 db 21			jp exec1 
33ae			 
33ae					 
33ae			 
33ae			 
33ae					NEXTW 
33ae c3 4a 21			jp macro_next 
33b1				endm 
# End of macro NEXTW
33b1			.I:  
33b1			 
33b1				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
33b1 5e				db WORD_SYS_CORE+74             
33b2 dc 33			dw .DLOOP            
33b4 02				db 1 + 1 
33b5 .. 00			db "I",0              
33b7				endm 
# End of macro CWHEAD
33b7			; | I ( -- ) Current loop counter | DONE 
33b7					if DEBUG_FORTH_WORDS_KEY 
33b7						DMARK "I.." 
33b7 f5				push af  
33b8 3a cc 33			ld a, (.dmark)  
33bb 32 6e fb			ld (debug_mark),a  
33be 3a cd 33			ld a, (.dmark+1)  
33c1 32 6f fb			ld (debug_mark+1),a  
33c4 3a ce 33			ld a, (.dmark+2)  
33c7 32 70 fb			ld (debug_mark+2),a  
33ca 18 03			jr .pastdmark  
33cc ..			.dmark: db "I.."  
33cf f1			.pastdmark: pop af  
33d0			endm  
# End of macro DMARK
33d0						CALLMONITOR 
33d0 cd 84 17			call break_point_state  
33d3				endm  
# End of macro CALLMONITOR
33d3					endif 
33d3			 
33d3 2a 39 f1				ld hl,(os_current_i) 
33d6 cd e1 1d				call forth_push_numhl 
33d9			 
33d9					NEXTW 
33d9 c3 4a 21			jp macro_next 
33dc				endm 
# End of macro NEXTW
33dc			.DLOOP: 
33dc				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
33dc 5f				db WORD_SYS_CORE+75             
33dd bd 34			dw .REPEAT            
33df 06				db 5 + 1 
33e0 .. 00			db "-LOOP",0              
33e6				endm 
# End of macro CWHEAD
33e6			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
33e6				; pop tos as current loop count to hl 
33e6					if DEBUG_FORTH_WORDS_KEY 
33e6						DMARK "-LP" 
33e6 f5				push af  
33e7 3a fb 33			ld a, (.dmark)  
33ea 32 6e fb			ld (debug_mark),a  
33ed 3a fc 33			ld a, (.dmark+1)  
33f0 32 6f fb			ld (debug_mark+1),a  
33f3 3a fd 33			ld a, (.dmark+2)  
33f6 32 70 fb			ld (debug_mark+2),a  
33f9 18 03			jr .pastdmark  
33fb ..			.dmark: db "-LP"  
33fe f1			.pastdmark: pop af  
33ff			endm  
# End of macro DMARK
33ff						CALLMONITOR 
33ff cd 84 17			call break_point_state  
3402				endm  
# End of macro CALLMONITOR
3402					endif 
3402			 
3402				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3402			 
3402				FORTH_LOOP_TOS 
3402 cd 3c 20			call macro_forth_loop_tos 
3405				endm 
# End of macro FORTH_LOOP_TOS
3405 e5				push hl 
3406			 
3406					if DEBUG_FORTH_WORDS 
3406						DMARK "-LP" 
3406 f5				push af  
3407 3a 1b 34			ld a, (.dmark)  
340a 32 6e fb			ld (debug_mark),a  
340d 3a 1c 34			ld a, (.dmark+1)  
3410 32 6f fb			ld (debug_mark+1),a  
3413 3a 1d 34			ld a, (.dmark+2)  
3416 32 70 fb			ld (debug_mark+2),a  
3419 18 03			jr .pastdmark  
341b ..			.dmark: db "-LP"  
341e f1			.pastdmark: pop af  
341f			endm  
# End of macro DMARK
341f						CALLMONITOR 
341f cd 84 17			call break_point_state  
3422				endm  
# End of macro CALLMONITOR
3422					endif 
3422				; next item on the stack is the limit. get it 
3422			 
3422			 
3422				FORTH_LOOP_POP 
3422 cd 46 20			call macro_forth_loop_pop 
3425				endm 
# End of macro FORTH_LOOP_POP
3425			 
3425				FORTH_LOOP_TOS 
3425 cd 3c 20			call macro_forth_loop_tos 
3428				endm 
# End of macro FORTH_LOOP_TOS
3428			 
3428 d1				pop de		 ; de = i, hl = limit 
3429			 
3429					if DEBUG_FORTH_WORDS 
3429						DMARK "-L1" 
3429 f5				push af  
342a 3a 3e 34			ld a, (.dmark)  
342d 32 6e fb			ld (debug_mark),a  
3430 3a 3f 34			ld a, (.dmark+1)  
3433 32 6f fb			ld (debug_mark+1),a  
3436 3a 40 34			ld a, (.dmark+2)  
3439 32 70 fb			ld (debug_mark+2),a  
343c 18 03			jr .pastdmark  
343e ..			.dmark: db "-L1"  
3441 f1			.pastdmark: pop af  
3442			endm  
# End of macro DMARK
3442						CALLMONITOR 
3442 cd 84 17			call break_point_state  
3445				endm  
# End of macro CALLMONITOR
3445					endif 
3445			 
3445				; go back to previous word 
3445			 
3445 d5				push de    ; save I for inc later 
3446			 
3446			 
3446				; get limit 
3446				;  is I at limit? 
3446			 
3446			 
3446					if DEBUG_FORTH_WORDS 
3446						DMARK "-L1" 
3446 f5				push af  
3447 3a 5b 34			ld a, (.dmark)  
344a 32 6e fb			ld (debug_mark),a  
344d 3a 5c 34			ld a, (.dmark+1)  
3450 32 6f fb			ld (debug_mark+1),a  
3453 3a 5d 34			ld a, (.dmark+2)  
3456 32 70 fb			ld (debug_mark+2),a  
3459 18 03			jr .pastdmark  
345b ..			.dmark: db "-L1"  
345e f1			.pastdmark: pop af  
345f			endm  
# End of macro DMARK
345f						CALLMONITOR 
345f cd 84 17			call break_point_state  
3462				endm  
# End of macro CALLMONITOR
3462					endif 
3462			 
3462 ed 52			sbc hl, de 
3464			 
3464			 
3464				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3464			 
3464 20 26				jr nz, .mloopnotdone 
3466			 
3466 e1				pop hl   ; get rid of saved I 
3467				FORTH_LOOP_POP     ; get rid of limit 
3467 cd 46 20			call macro_forth_loop_pop 
346a				endm 
# End of macro FORTH_LOOP_POP
346a			 
346a				FORTH_RSP_POP     ; get rid of DO ptr 
346a cd a9 1d			call macro_forth_rsp_pop 
346d				endm 
# End of macro FORTH_RSP_POP
346d			 
346d			if DEBUG_FORTH_WORDS 
346d						DMARK "-L>" 
346d f5				push af  
346e 3a 82 34			ld a, (.dmark)  
3471 32 6e fb			ld (debug_mark),a  
3474 3a 83 34			ld a, (.dmark+1)  
3477 32 6f fb			ld (debug_mark+1),a  
347a 3a 84 34			ld a, (.dmark+2)  
347d 32 70 fb			ld (debug_mark+2),a  
3480 18 03			jr .pastdmark  
3482 ..			.dmark: db "-L>"  
3485 f1			.pastdmark: pop af  
3486			endm  
# End of macro DMARK
3486				CALLMONITOR 
3486 cd 84 17			call break_point_state  
3489				endm  
# End of macro CALLMONITOR
3489			endif 
3489			 
3489					NEXTW 
3489 c3 4a 21			jp macro_next 
348c				endm 
# End of macro NEXTW
348c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
348c			 
348c			.mloopnotdone: 
348c			 
348c e1				pop hl    ; get I 
348d 2b				dec hl 
348e			 
348e			   	; save new I 
348e			 
348e			 
348e					; set I counter 
348e			 
348e 22 39 f1				ld (os_current_i), hl 
3491			 
3491					 
3491				FORTH_LOOP_NEXT 
3491 cd 09 20			call macro_forth_loop_next 
3494				endm 
# End of macro FORTH_LOOP_NEXT
3494			 
3494			 
3494					if DEBUG_FORTH_WORDS 
3494 eb						ex de,hl 
3495					endif 
3495			 
3495			;	; get DO ptr 
3495			; 
3495				FORTH_RSP_TOS 
3495 cd 9f 1d			call macro_forth_rsp_tos 
3498				endm 
# End of macro FORTH_RSP_TOS
3498			 
3498				;push hl 
3498			 
3498				; not going to DO any more 
3498				; get rid of the RSP pointer as DO will add it back in 
3498				;FORTH_RSP_POP 
3498				;pop hl 
3498			 
3498			 
3498 22 15 f1			ld (os_tok_ptr), hl 
349b					if DEBUG_FORTH_WORDS 
349b						DMARK "-L<" 
349b f5				push af  
349c 3a b0 34			ld a, (.dmark)  
349f 32 6e fb			ld (debug_mark),a  
34a2 3a b1 34			ld a, (.dmark+1)  
34a5 32 6f fb			ld (debug_mark+1),a  
34a8 3a b2 34			ld a, (.dmark+2)  
34ab 32 70 fb			ld (debug_mark+2),a  
34ae 18 03			jr .pastdmark  
34b0 ..			.dmark: db "-L<"  
34b3 f1			.pastdmark: pop af  
34b4			endm  
# End of macro DMARK
34b4					CALLMONITOR 
34b4 cd 84 17			call break_point_state  
34b7				endm  
# End of macro CALLMONITOR
34b7				endif 
34b7 c3 db 21			jp exec1 
34ba			 
34ba					 
34ba			 
34ba			 
34ba			 
34ba				NEXTW 
34ba c3 4a 21			jp macro_next 
34bd				endm 
# End of macro NEXTW
34bd			 
34bd			 
34bd			 
34bd			 
34bd			.REPEAT: 
34bd				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
34bd 71				db WORD_SYS_CORE+93             
34be 10 35			dw .UNTIL            
34c0 06				db 5 + 1 
34c1 .. 00			db "REPEAT",0              
34c8				endm 
# End of macro CWHEAD
34c8			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
34c8			;  push pc to rsp stack past the REPEAT 
34c8					if DEBUG_FORTH_WORDS_KEY 
34c8						DMARK "REP" 
34c8 f5				push af  
34c9 3a dd 34			ld a, (.dmark)  
34cc 32 6e fb			ld (debug_mark),a  
34cf 3a de 34			ld a, (.dmark+1)  
34d2 32 6f fb			ld (debug_mark+1),a  
34d5 3a df 34			ld a, (.dmark+2)  
34d8 32 70 fb			ld (debug_mark+2),a  
34db 18 03			jr .pastdmark  
34dd ..			.dmark: db "REP"  
34e0 f1			.pastdmark: pop af  
34e1			endm  
# End of macro DMARK
34e1						CALLMONITOR 
34e1 cd 84 17			call break_point_state  
34e4				endm  
# End of macro CALLMONITOR
34e4					endif 
34e4			 
34e4 2a 15 f1				ld hl, (os_tok_ptr) 
34e7 23					inc hl   ; R 
34e8 23					inc hl  ; E 
34e9 23					inc hl   ; P 
34ea 23					inc hl   ; E 
34eb 23					inc hl   ; A 
34ec 23					inc hl   ; T 
34ed 23					inc hl   ; zero 
34ee					FORTH_RSP_NEXT 
34ee cd 88 1d			call macro_forth_rsp_next 
34f1				endm 
# End of macro FORTH_RSP_NEXT
34f1			 
34f1			 
34f1					if DEBUG_FORTH_WORDS 
34f1						DMARK "REP" 
34f1 f5				push af  
34f2 3a 06 35			ld a, (.dmark)  
34f5 32 6e fb			ld (debug_mark),a  
34f8 3a 07 35			ld a, (.dmark+1)  
34fb 32 6f fb			ld (debug_mark+1),a  
34fe 3a 08 35			ld a, (.dmark+2)  
3501 32 70 fb			ld (debug_mark+2),a  
3504 18 03			jr .pastdmark  
3506 ..			.dmark: db "REP"  
3509 f1			.pastdmark: pop af  
350a			endm  
# End of macro DMARK
350a						;pop bc    ; TODO BUG ?????? what is this for???? 
350a						CALLMONITOR 
350a cd 84 17			call break_point_state  
350d				endm  
# End of macro CALLMONITOR
350d					endif 
350d			 
350d					NEXTW 
350d c3 4a 21			jp macro_next 
3510				endm 
# End of macro NEXTW
3510			;	       NEXTW 
3510			 
3510			.UNTIL: 
3510				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3510 72				db WORD_SYS_CORE+94             
3511 a7 35			dw .ENDFLOW            
3513 06				db 5 + 1 
3514 .. 00			db "UNTIL",0              
351a				endm 
# End of macro CWHEAD
351a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
351a			 
351a				; pop tos as check 
351a			 
351a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
351a			 
351a				FORTH_DSP_VALUEHL 
351a cd d8 1f			call macro_dsp_valuehl 
351d				endm 
# End of macro FORTH_DSP_VALUEHL
351d			 
351d					if DEBUG_FORTH_WORDS_KEY 
351d						DMARK "UNT" 
351d f5				push af  
351e 3a 32 35			ld a, (.dmark)  
3521 32 6e fb			ld (debug_mark),a  
3524 3a 33 35			ld a, (.dmark+1)  
3527 32 6f fb			ld (debug_mark+1),a  
352a 3a 34 35			ld a, (.dmark+2)  
352d 32 70 fb			ld (debug_mark+2),a  
3530 18 03			jr .pastdmark  
3532 ..			.dmark: db "UNT"  
3535 f1			.pastdmark: pop af  
3536			endm  
# End of macro DMARK
3536						CALLMONITOR 
3536 cd 84 17			call break_point_state  
3539				endm  
# End of macro CALLMONITOR
3539					endif 
3539			 
3539			;	push hl 
3539				FORTH_DSP_POP 
3539 cd 90 20			call macro_forth_dsp_pop 
353c				endm 
# End of macro FORTH_DSP_POP
353c			 
353c			;	pop hl 
353c			 
353c				; test if true 
353c			 
353c cd 06 0e			call ishlzero 
353f			;	ld a,l 
353f			;	add h 
353f			; 
353f			;	cp 0 
353f			 
353f 20 3e			jr nz, .untilnotdone 
3541			 
3541					if DEBUG_FORTH_WORDS 
3541						DMARK "UNf" 
3541 f5				push af  
3542 3a 56 35			ld a, (.dmark)  
3545 32 6e fb			ld (debug_mark),a  
3548 3a 57 35			ld a, (.dmark+1)  
354b 32 6f fb			ld (debug_mark+1),a  
354e 3a 58 35			ld a, (.dmark+2)  
3551 32 70 fb			ld (debug_mark+2),a  
3554 18 03			jr .pastdmark  
3556 ..			.dmark: db "UNf"  
3559 f1			.pastdmark: pop af  
355a			endm  
# End of macro DMARK
355a						CALLMONITOR 
355a cd 84 17			call break_point_state  
355d				endm  
# End of macro CALLMONITOR
355d					endif 
355d			 
355d			 
355d			 
355d				FORTH_RSP_POP     ; get rid of DO ptr 
355d cd a9 1d			call macro_forth_rsp_pop 
3560				endm 
# End of macro FORTH_RSP_POP
3560			 
3560			if DEBUG_FORTH_WORDS 
3560						DMARK "UN>" 
3560 f5				push af  
3561 3a 75 35			ld a, (.dmark)  
3564 32 6e fb			ld (debug_mark),a  
3567 3a 76 35			ld a, (.dmark+1)  
356a 32 6f fb			ld (debug_mark+1),a  
356d 3a 77 35			ld a, (.dmark+2)  
3570 32 70 fb			ld (debug_mark+2),a  
3573 18 03			jr .pastdmark  
3575 ..			.dmark: db "UN>"  
3578 f1			.pastdmark: pop af  
3579			endm  
# End of macro DMARK
3579				CALLMONITOR 
3579 cd 84 17			call break_point_state  
357c				endm  
# End of macro CALLMONITOR
357c			endif 
357c			 
357c					NEXTW 
357c c3 4a 21			jp macro_next 
357f				endm 
# End of macro NEXTW
357f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
357f			 
357f			.untilnotdone: 
357f			 
357f			 
357f			;	; get DO ptr 
357f			; 
357f				FORTH_RSP_TOS 
357f cd 9f 1d			call macro_forth_rsp_tos 
3582				endm 
# End of macro FORTH_RSP_TOS
3582			 
3582				;push hl 
3582			 
3582				; not going to DO any more 
3582				; get rid of the RSP pointer as DO will add it back in 
3582				;FORTH_RSP_POP 
3582				;pop hl 
3582			 
3582			 
3582 22 15 f1			ld (os_tok_ptr), hl 
3585					if DEBUG_FORTH_WORDS 
3585						DMARK "UN<" 
3585 f5				push af  
3586 3a 9a 35			ld a, (.dmark)  
3589 32 6e fb			ld (debug_mark),a  
358c 3a 9b 35			ld a, (.dmark+1)  
358f 32 6f fb			ld (debug_mark+1),a  
3592 3a 9c 35			ld a, (.dmark+2)  
3595 32 70 fb			ld (debug_mark+2),a  
3598 18 03			jr .pastdmark  
359a ..			.dmark: db "UN<"  
359d f1			.pastdmark: pop af  
359e			endm  
# End of macro DMARK
359e					CALLMONITOR 
359e cd 84 17			call break_point_state  
35a1				endm  
# End of macro CALLMONITOR
35a1				endif 
35a1 c3 db 21			jp exec1 
35a4			 
35a4					 
35a4			 
35a4			 
35a4					NEXTW 
35a4 c3 4a 21			jp macro_next 
35a7				endm 
# End of macro NEXTW
35a7			 
35a7			 
35a7			.ENDFLOW: 
35a7			 
35a7			; eof 
35a7			 
# End of file forth_words_flow.asm
35a7			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
35a7			include "forth_words_logic.asm" 
35a7			 
35a7			; | ## Logic Words 
35a7			 
35a7			.NOT: 
35a7				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
35a7 2d				db WORD_SYS_CORE+25             
35a8 ef 35			dw .IS            
35aa 04				db 3 + 1 
35ab .. 00			db "NOT",0              
35af				endm 
# End of macro CWHEAD
35af			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
35af					if DEBUG_FORTH_WORDS_KEY 
35af						DMARK "NOT" 
35af f5				push af  
35b0 3a c4 35			ld a, (.dmark)  
35b3 32 6e fb			ld (debug_mark),a  
35b6 3a c5 35			ld a, (.dmark+1)  
35b9 32 6f fb			ld (debug_mark+1),a  
35bc 3a c6 35			ld a, (.dmark+2)  
35bf 32 70 fb			ld (debug_mark+2),a  
35c2 18 03			jr .pastdmark  
35c4 ..			.dmark: db "NOT"  
35c7 f1			.pastdmark: pop af  
35c8			endm  
# End of macro DMARK
35c8						CALLMONITOR 
35c8 cd 84 17			call break_point_state  
35cb				endm  
# End of macro CALLMONITOR
35cb					endif 
35cb					FORTH_DSP 
35cb cd 9e 1f			call macro_forth_dsp 
35ce				endm 
# End of macro FORTH_DSP
35ce 7e					ld a,(hl)	; get type of value on TOS 
35cf fe 02				cp DS_TYPE_INUM  
35d1 28 03				jr z, .noti 
35d3					NEXTW 
35d3 c3 4a 21			jp macro_next 
35d6				endm 
# End of macro NEXTW
35d6			.noti:          FORTH_DSP_VALUEHL 
35d6 cd d8 1f			call macro_dsp_valuehl 
35d9				endm 
# End of macro FORTH_DSP_VALUEHL
35d9			;		push hl 
35d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d9 cd 90 20			call macro_forth_dsp_pop 
35dc				endm 
# End of macro FORTH_DSP_POP
35dc			;		pop hl 
35dc 3e 00				ld a,0 
35de bd					cp l 
35df 28 04				jr z, .not2t 
35e1 2e 00				ld l, 0 
35e3 18 02				jr .notip 
35e5			 
35e5 2e ff		.not2t:		ld l, 255 
35e7			 
35e7 26 00		.notip:		ld h, 0	 
35e9			 
35e9 cd e1 1d				call forth_push_numhl 
35ec					NEXTW 
35ec c3 4a 21			jp macro_next 
35ef				endm 
# End of macro NEXTW
35ef			 
35ef			.IS: 
35ef				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
35ef 2d				db WORD_SYS_CORE+25             
35f0 15 36			dw .LZERO            
35f2 03				db 2 + 1 
35f3 .. 00			db "IS",0              
35f6				endm 
# End of macro CWHEAD
35f6			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
35f6					if DEBUG_FORTH_WORDS_KEY 
35f6						DMARK "IS." 
35f6 f5				push af  
35f7 3a 0b 36			ld a, (.dmark)  
35fa 32 6e fb			ld (debug_mark),a  
35fd 3a 0c 36			ld a, (.dmark+1)  
3600 32 6f fb			ld (debug_mark+1),a  
3603 3a 0d 36			ld a, (.dmark+2)  
3606 32 70 fb			ld (debug_mark+2),a  
3609 18 03			jr .pastdmark  
360b ..			.dmark: db "IS."  
360e f1			.pastdmark: pop af  
360f			endm  
# End of macro DMARK
360f						CALLMONITOR 
360f cd 84 17			call break_point_state  
3612				endm  
# End of macro CALLMONITOR
3612					endif 
3612					NEXTW 
3612 c3 4a 21			jp macro_next 
3615				endm 
# End of macro NEXTW
3615			.LZERO: 
3615				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3615 2d				db WORD_SYS_CORE+25             
3616 1f 36			dw .TZERO            
3618 03				db 2 + 1 
3619 .. 00			db "0<",0              
361c				endm 
# End of macro CWHEAD
361c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
361c					NEXTW 
361c c3 4a 21			jp macro_next 
361f				endm 
# End of macro NEXTW
361f			.TZERO: 
361f				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
361f 2e				db WORD_SYS_CORE+26             
3620 66 36			dw .LESS            
3622 03				db 2 + 1 
3623 .. 00			db "0=",0              
3626				endm 
# End of macro CWHEAD
3626			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3626				; TODO add floating point number detection 
3626					;v5 FORTH_DSP_VALUE 
3626					if DEBUG_FORTH_WORDS_KEY 
3626						DMARK "0=." 
3626 f5				push af  
3627 3a 3b 36			ld a, (.dmark)  
362a 32 6e fb			ld (debug_mark),a  
362d 3a 3c 36			ld a, (.dmark+1)  
3630 32 6f fb			ld (debug_mark+1),a  
3633 3a 3d 36			ld a, (.dmark+2)  
3636 32 70 fb			ld (debug_mark+2),a  
3639 18 03			jr .pastdmark  
363b ..			.dmark: db "0=."  
363e f1			.pastdmark: pop af  
363f			endm  
# End of macro DMARK
363f						CALLMONITOR 
363f cd 84 17			call break_point_state  
3642				endm  
# End of macro CALLMONITOR
3642					endif 
3642					FORTH_DSP 
3642 cd 9e 1f			call macro_forth_dsp 
3645				endm 
# End of macro FORTH_DSP
3645 7e					ld a,(hl)	; get type of value on TOS 
3646 fe 02				cp DS_TYPE_INUM  
3648 28 00				jr z, .tz_inum 
364a			 
364a				if FORTH_ENABLE_FLOATMATH 
364a					jr .tz_done 
364a			 
364a				endif 
364a					 
364a			 
364a			.tz_inum: 
364a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364a cd d8 1f			call macro_dsp_valuehl 
364d				endm 
# End of macro FORTH_DSP_VALUEHL
364d			 
364d			;		push hl 
364d			 
364d					; destroy value TOS 
364d			 
364d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
364d cd 90 20			call macro_forth_dsp_pop 
3650				endm 
# End of macro FORTH_DSP_POP
3650			 
3650			;		pop hl 
3650			 
3650 3e 00				ld a,0 
3652			 
3652 bd					cp l 
3653 20 08				jr nz, .tz_notzero 
3655			 
3655 bc					cp h 
3656			 
3656 20 05				jr nz, .tz_notzero 
3658			 
3658			 
3658 21 01 00				ld hl, FORTH_TRUE 
365b 18 03				jr .tz_done 
365d			 
365d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3660			 
3660					; push value back onto stack for another op etc 
3660			 
3660			.tz_done: 
3660 cd e1 1d				call forth_push_numhl 
3663			 
3663					NEXTW 
3663 c3 4a 21			jp macro_next 
3666				endm 
# End of macro NEXTW
3666			.LESS: 
3666				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3666 2f				db WORD_SYS_CORE+27             
3667 cf 36			dw .GT            
3669 02				db 1 + 1 
366a .. 00			db "<",0              
366c				endm 
# End of macro CWHEAD
366c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
366c				; TODO add floating point number detection 
366c					if DEBUG_FORTH_WORDS_KEY 
366c						DMARK "LES" 
366c f5				push af  
366d 3a 81 36			ld a, (.dmark)  
3670 32 6e fb			ld (debug_mark),a  
3673 3a 82 36			ld a, (.dmark+1)  
3676 32 6f fb			ld (debug_mark+1),a  
3679 3a 83 36			ld a, (.dmark+2)  
367c 32 70 fb			ld (debug_mark+2),a  
367f 18 03			jr .pastdmark  
3681 ..			.dmark: db "LES"  
3684 f1			.pastdmark: pop af  
3685			endm  
# End of macro DMARK
3685						CALLMONITOR 
3685 cd 84 17			call break_point_state  
3688				endm  
# End of macro CALLMONITOR
3688					endif 
3688					FORTH_DSP 
3688 cd 9e 1f			call macro_forth_dsp 
368b				endm 
# End of macro FORTH_DSP
368b					;v5 FORTH_DSP_VALUE 
368b 7e					ld a,(hl)	; get type of value on TOS 
368c fe 02				cp DS_TYPE_INUM  
368e 28 00				jr z, .less_inum 
3690			 
3690				if FORTH_ENABLE_FLOATMATH 
3690					jr .less_done 
3690			 
3690				endif 
3690					 
3690			 
3690			.less_inum: 
3690					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3690 cd d8 1f			call macro_dsp_valuehl 
3693				endm 
# End of macro FORTH_DSP_VALUEHL
3693			 
3693 e5					push hl  ; u2 
3694			 
3694					; destroy value TOS 
3694			 
3694					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3694 cd 90 20			call macro_forth_dsp_pop 
3697				endm 
# End of macro FORTH_DSP_POP
3697			 
3697			 
3697					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3697 cd d8 1f			call macro_dsp_valuehl 
369a				endm 
# End of macro FORTH_DSP_VALUEHL
369a			 
369a e5					push hl    ; u1 
369b			 
369b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
369b cd 90 20			call macro_forth_dsp_pop 
369e				endm 
# End of macro FORTH_DSP_POP
369e			 
369e			 
369e b7			 or a      ;clear carry flag 
369f 01 00 00		 ld bc, FORTH_FALSE 
36a2 e1			  pop hl    ; u1 
36a3 d1			  pop de    ; u2 
36a4 ed 52		  sbc hl,de 
36a6 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
36a8			 
36a8 01 01 00		 ld bc, FORTH_TRUE 
36ab			.lscont:  
36ab c5					push bc 
36ac e1					pop hl 
36ad			 
36ad					if DEBUG_FORTH_WORDS 
36ad						DMARK "LT1" 
36ad f5				push af  
36ae 3a c2 36			ld a, (.dmark)  
36b1 32 6e fb			ld (debug_mark),a  
36b4 3a c3 36			ld a, (.dmark+1)  
36b7 32 6f fb			ld (debug_mark+1),a  
36ba 3a c4 36			ld a, (.dmark+2)  
36bd 32 70 fb			ld (debug_mark+2),a  
36c0 18 03			jr .pastdmark  
36c2 ..			.dmark: db "LT1"  
36c5 f1			.pastdmark: pop af  
36c6			endm  
# End of macro DMARK
36c6						CALLMONITOR 
36c6 cd 84 17			call break_point_state  
36c9				endm  
# End of macro CALLMONITOR
36c9					endif 
36c9 cd e1 1d				call forth_push_numhl 
36cc			 
36cc					NEXTW 
36cc c3 4a 21			jp macro_next 
36cf				endm 
# End of macro NEXTW
36cf			.GT: 
36cf				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
36cf 30				db WORD_SYS_CORE+28             
36d0 38 37			dw .EQUAL            
36d2 02				db 1 + 1 
36d3 .. 00			db ">",0              
36d5				endm 
# End of macro CWHEAD
36d5			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
36d5				; TODO add floating point number detection 
36d5					if DEBUG_FORTH_WORDS_KEY 
36d5						DMARK "GRT" 
36d5 f5				push af  
36d6 3a ea 36			ld a, (.dmark)  
36d9 32 6e fb			ld (debug_mark),a  
36dc 3a eb 36			ld a, (.dmark+1)  
36df 32 6f fb			ld (debug_mark+1),a  
36e2 3a ec 36			ld a, (.dmark+2)  
36e5 32 70 fb			ld (debug_mark+2),a  
36e8 18 03			jr .pastdmark  
36ea ..			.dmark: db "GRT"  
36ed f1			.pastdmark: pop af  
36ee			endm  
# End of macro DMARK
36ee						CALLMONITOR 
36ee cd 84 17			call break_point_state  
36f1				endm  
# End of macro CALLMONITOR
36f1					endif 
36f1					FORTH_DSP 
36f1 cd 9e 1f			call macro_forth_dsp 
36f4				endm 
# End of macro FORTH_DSP
36f4					;FORTH_DSP_VALUE 
36f4 7e					ld a,(hl)	; get type of value on TOS 
36f5 fe 02				cp DS_TYPE_INUM  
36f7 28 00				jr z, .gt_inum 
36f9			 
36f9				if FORTH_ENABLE_FLOATMATH 
36f9					jr .gt_done 
36f9			 
36f9				endif 
36f9					 
36f9			 
36f9			.gt_inum: 
36f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f9 cd d8 1f			call macro_dsp_valuehl 
36fc				endm 
# End of macro FORTH_DSP_VALUEHL
36fc			 
36fc e5					push hl  ; u2 
36fd			 
36fd					; destroy value TOS 
36fd			 
36fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fd cd 90 20			call macro_forth_dsp_pop 
3700				endm 
# End of macro FORTH_DSP_POP
3700			 
3700			 
3700					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3700 cd d8 1f			call macro_dsp_valuehl 
3703				endm 
# End of macro FORTH_DSP_VALUEHL
3703			 
3703 e5					push hl    ; u1 
3704			 
3704					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3704 cd 90 20			call macro_forth_dsp_pop 
3707				endm 
# End of macro FORTH_DSP_POP
3707			 
3707			 
3707 b7			 or a      ;clear carry flag 
3708 01 00 00		 ld bc, FORTH_FALSE 
370b e1			  pop hl    ; u1 
370c d1			  pop de    ; u2 
370d ed 52		  sbc hl,de 
370f 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3711			 
3711 01 01 00		 ld bc, FORTH_TRUE 
3714			.gtcont:  
3714 c5					push bc 
3715 e1					pop hl 
3716			 
3716					if DEBUG_FORTH_WORDS 
3716						DMARK "GT1" 
3716 f5				push af  
3717 3a 2b 37			ld a, (.dmark)  
371a 32 6e fb			ld (debug_mark),a  
371d 3a 2c 37			ld a, (.dmark+1)  
3720 32 6f fb			ld (debug_mark+1),a  
3723 3a 2d 37			ld a, (.dmark+2)  
3726 32 70 fb			ld (debug_mark+2),a  
3729 18 03			jr .pastdmark  
372b ..			.dmark: db "GT1"  
372e f1			.pastdmark: pop af  
372f			endm  
# End of macro DMARK
372f						CALLMONITOR 
372f cd 84 17			call break_point_state  
3732				endm  
# End of macro CALLMONITOR
3732					endif 
3732 cd e1 1d				call forth_push_numhl 
3735			 
3735					NEXTW 
3735 c3 4a 21			jp macro_next 
3738				endm 
# End of macro NEXTW
3738			.EQUAL: 
3738				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3738 31				db WORD_SYS_CORE+29             
3739 a3 37			dw .ENDLOGIC            
373b 02				db 1 + 1 
373c .. 00			db "=",0              
373e				endm 
# End of macro CWHEAD
373e			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
373e				; TODO add floating point number detection 
373e					if DEBUG_FORTH_WORDS_KEY 
373e						DMARK "EQ." 
373e f5				push af  
373f 3a 53 37			ld a, (.dmark)  
3742 32 6e fb			ld (debug_mark),a  
3745 3a 54 37			ld a, (.dmark+1)  
3748 32 6f fb			ld (debug_mark+1),a  
374b 3a 55 37			ld a, (.dmark+2)  
374e 32 70 fb			ld (debug_mark+2),a  
3751 18 03			jr .pastdmark  
3753 ..			.dmark: db "EQ."  
3756 f1			.pastdmark: pop af  
3757			endm  
# End of macro DMARK
3757						CALLMONITOR 
3757 cd 84 17			call break_point_state  
375a				endm  
# End of macro CALLMONITOR
375a					endif 
375a					FORTH_DSP 
375a cd 9e 1f			call macro_forth_dsp 
375d				endm 
# End of macro FORTH_DSP
375d					;v5 FORTH_DSP_VALUE 
375d 7e					ld a,(hl)	; get type of value on TOS 
375e fe 02				cp DS_TYPE_INUM  
3760 28 00				jr z, .eq_inum 
3762			 
3762				if FORTH_ENABLE_FLOATMATH 
3762					jr .eq_done 
3762			 
3762				endif 
3762					 
3762			 
3762			.eq_inum: 
3762					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3762 cd d8 1f			call macro_dsp_valuehl 
3765				endm 
# End of macro FORTH_DSP_VALUEHL
3765			 
3765 e5					push hl 
3766			 
3766					; destroy value TOS 
3766			 
3766					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3766 cd 90 20			call macro_forth_dsp_pop 
3769				endm 
# End of macro FORTH_DSP_POP
3769			 
3769			 
3769					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3769 cd d8 1f			call macro_dsp_valuehl 
376c				endm 
# End of macro FORTH_DSP_VALUEHL
376c			 
376c					; one value on hl get other one back 
376c			 
376c e5					push hl 
376d			 
376d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376d cd 90 20			call macro_forth_dsp_pop 
3770				endm 
# End of macro FORTH_DSP_POP
3770			 
3770 0e 00				ld c, FORTH_FALSE 
3772			 
3772 e1					pop hl 
3773 d1					pop de 
3774			 
3774 7b					ld a, e 
3775 bd					cp l 
3776			 
3776 20 06				jr nz, .eq_done 
3778			 
3778 7a					ld a, d 
3779 bc					cp h 
377a			 
377a 20 02				jr nz, .eq_done 
377c			 
377c 0e 01				ld c, FORTH_TRUE 
377e					 
377e			 
377e			 
377e			.eq_done: 
377e			 
377e					; TODO push value back onto stack for another op etc 
377e			 
377e 26 00				ld h, 0 
3780 69					ld l, c 
3781					if DEBUG_FORTH_WORDS 
3781						DMARK "EQ1" 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 6e fb			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 6f fb			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 70 fb			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "EQ1"  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a						CALLMONITOR 
379a cd 84 17			call break_point_state  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d cd e1 1d				call forth_push_numhl 
37a0			 
37a0					NEXTW 
37a0 c3 4a 21			jp macro_next 
37a3				endm 
# End of macro NEXTW
37a3			 
37a3			 
37a3			.ENDLOGIC: 
37a3			; eof 
37a3			 
37a3			 
# End of file forth_words_logic.asm
37a3			include "forth_words_maths.asm" 
37a3			 
37a3			; | ## Maths Words 
37a3			 
37a3			.PLUS:	 
37a3				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
37a3 15				db WORD_SYS_CORE+1             
37a4 e5 37			dw .NEG            
37a6 02				db 1 + 1 
37a7 .. 00			db "+",0              
37a9				endm 
# End of macro CWHEAD
37a9			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
37a9					if DEBUG_FORTH_WORDS_KEY 
37a9						DMARK "PLU" 
37a9 f5				push af  
37aa 3a be 37			ld a, (.dmark)  
37ad 32 6e fb			ld (debug_mark),a  
37b0 3a bf 37			ld a, (.dmark+1)  
37b3 32 6f fb			ld (debug_mark+1),a  
37b6 3a c0 37			ld a, (.dmark+2)  
37b9 32 70 fb			ld (debug_mark+2),a  
37bc 18 03			jr .pastdmark  
37be ..			.dmark: db "PLU"  
37c1 f1			.pastdmark: pop af  
37c2			endm  
# End of macro DMARK
37c2						CALLMONITOR 
37c2 cd 84 17			call break_point_state  
37c5				endm  
# End of macro CALLMONITOR
37c5					endif 
37c5					; add top two values and push back result 
37c5			 
37c5					;for v5 FORTH_DSP_VALUE 
37c5					FORTH_DSP 
37c5 cd 9e 1f			call macro_forth_dsp 
37c8				endm 
# End of macro FORTH_DSP
37c8 7e					ld a,(hl)	; get type of value on TOS 
37c9 fe 02				cp DS_TYPE_INUM  
37cb 28 03				jr z, .dot_inum 
37cd			 
37cd					NEXTW 
37cd c3 4a 21			jp macro_next 
37d0				endm 
# End of macro NEXTW
37d0			 
37d0			; float maths 
37d0			 
37d0				if FORTH_ENABLE_FLOATMATH 
37d0						inc hl      ; now at start of numeric as string 
37d0			 
37d0					if DEBUG_FORTH_MATHS 
37d0						DMARK "ADD" 
37d0				CALLMONITOR 
37d0					endif 
37d0			 
37d0					;ld ix, hl 
37d0					call CON 
37d0			 
37d0			 
37d0					push hl 
37d0					 
37d0					 
37d0			 
37d0						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
37d0			 
37d0					; get next number 
37d0			 
37d0						FORTH_DSP_VALUE 
37d0			 
37d0						inc hl      ; now at start of numeric as string 
37d0			 
37d0					;ld ix, hl 
37d0					call CON 
37d0			 
37d0					push hl 
37d0			 
37d0			 
37d0						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d0			 
37d0						; TODO do add 
37d0			 
37d0						call IADD 
37d0			 
37d0						; TODO get result back as ascii 
37d0			 
37d0						; TODO push result  
37d0			 
37d0			 
37d0			 
37d0						jr .dot_done 
37d0				endif 
37d0			 
37d0			.dot_inum: 
37d0			 
37d0			 
37d0					if DEBUG_FORTH_DOT 
37d0						DMARK "+IT" 
37d0				CALLMONITOR 
37d0					endif 
37d0			 
37d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d0 cd d8 1f			call macro_dsp_valuehl 
37d3				endm 
# End of macro FORTH_DSP_VALUEHL
37d3			 
37d3				; TODO add floating point number detection 
37d3			 
37d3 e5					push hl 
37d4			 
37d4					; destroy value TOS 
37d4			 
37d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d4 cd 90 20			call macro_forth_dsp_pop 
37d7				endm 
# End of macro FORTH_DSP_POP
37d7			 
37d7			 
37d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d7 cd d8 1f			call macro_dsp_valuehl 
37da				endm 
# End of macro FORTH_DSP_VALUEHL
37da			 
37da					; one value on hl get other one back 
37da			 
37da d1					pop de 
37db			 
37db					; do the add 
37db			 
37db 19					add hl,de 
37dc			 
37dc					; save it 
37dc			 
37dc			;		push hl	 
37dc			 
37dc					; 
37dc			 
37dc					; destroy value TOS 
37dc			 
37dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37dc cd 90 20			call macro_forth_dsp_pop 
37df				endm 
# End of macro FORTH_DSP_POP
37df			 
37df					; TODO push value back onto stack for another op etc 
37df			 
37df			;		pop hl 
37df			 
37df			.dot_done: 
37df cd e1 1d				call forth_push_numhl 
37e2			 
37e2					NEXTW 
37e2 c3 4a 21			jp macro_next 
37e5				endm 
# End of macro NEXTW
37e5			.NEG: 
37e5			 
37e5				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
37e5 17				db WORD_SYS_CORE+3             
37e6 28 38			dw .DIV            
37e8 02				db 1 + 1 
37e9 .. 00			db "-",0              
37eb				endm 
# End of macro CWHEAD
37eb			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
37eb					if DEBUG_FORTH_WORDS_KEY 
37eb						DMARK "SUB" 
37eb f5				push af  
37ec 3a 00 38			ld a, (.dmark)  
37ef 32 6e fb			ld (debug_mark),a  
37f2 3a 01 38			ld a, (.dmark+1)  
37f5 32 6f fb			ld (debug_mark+1),a  
37f8 3a 02 38			ld a, (.dmark+2)  
37fb 32 70 fb			ld (debug_mark+2),a  
37fe 18 03			jr .pastdmark  
3800 ..			.dmark: db "SUB"  
3803 f1			.pastdmark: pop af  
3804			endm  
# End of macro DMARK
3804						CALLMONITOR 
3804 cd 84 17			call break_point_state  
3807				endm  
# End of macro CALLMONITOR
3807					endif 
3807			 
3807			 
3807				; TODO add floating point number detection 
3807					; v5 FORTH_DSP_VALUE 
3807					FORTH_DSP 
3807 cd 9e 1f			call macro_forth_dsp 
380a				endm 
# End of macro FORTH_DSP
380a 7e					ld a,(hl)	; get type of value on TOS 
380b fe 02				cp DS_TYPE_INUM  
380d 28 03				jr z, .neg_inum 
380f			 
380f					NEXTW 
380f c3 4a 21			jp macro_next 
3812				endm 
# End of macro NEXTW
3812			 
3812			; float maths 
3812			 
3812				if FORTH_ENABLE_FLOATMATH 
3812					jr .neg_done 
3812			 
3812				endif 
3812					 
3812			 
3812			.neg_inum: 
3812					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3812 cd d8 1f			call macro_dsp_valuehl 
3815				endm 
# End of macro FORTH_DSP_VALUEHL
3815			 
3815 e5					push hl 
3816			 
3816					; destroy value TOS 
3816			 
3816					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3816 cd 90 20			call macro_forth_dsp_pop 
3819				endm 
# End of macro FORTH_DSP_POP
3819			 
3819			 
3819					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3819 cd d8 1f			call macro_dsp_valuehl 
381c				endm 
# End of macro FORTH_DSP_VALUEHL
381c			 
381c					; one value on hl get other one back 
381c			 
381c d1					pop de 
381d			 
381d					; do the sub 
381d			;		ex de, hl 
381d			 
381d ed 52				sbc hl,de 
381f			 
381f					; save it 
381f			 
381f			;		push hl	 
381f			 
381f					; 
381f			 
381f					; destroy value TOS 
381f			 
381f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381f cd 90 20			call macro_forth_dsp_pop 
3822				endm 
# End of macro FORTH_DSP_POP
3822			 
3822					; TODO push value back onto stack for another op etc 
3822			 
3822			;		pop hl 
3822			 
3822 cd e1 1d				call forth_push_numhl 
3825			.neg_done: 
3825			 
3825					NEXTW 
3825 c3 4a 21			jp macro_next 
3828				endm 
# End of macro NEXTW
3828			.DIV: 
3828				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3828 18				db WORD_SYS_CORE+4             
3829 75 38			dw .MUL            
382b 02				db 1 + 1 
382c .. 00			db "/",0              
382e				endm 
# End of macro CWHEAD
382e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
382e					if DEBUG_FORTH_WORDS_KEY 
382e						DMARK "DIV" 
382e f5				push af  
382f 3a 43 38			ld a, (.dmark)  
3832 32 6e fb			ld (debug_mark),a  
3835 3a 44 38			ld a, (.dmark+1)  
3838 32 6f fb			ld (debug_mark+1),a  
383b 3a 45 38			ld a, (.dmark+2)  
383e 32 70 fb			ld (debug_mark+2),a  
3841 18 03			jr .pastdmark  
3843 ..			.dmark: db "DIV"  
3846 f1			.pastdmark: pop af  
3847			endm  
# End of macro DMARK
3847						CALLMONITOR 
3847 cd 84 17			call break_point_state  
384a				endm  
# End of macro CALLMONITOR
384a					endif 
384a				; TODO add floating point number detection 
384a					; v5 FORTH_DSP_VALUE 
384a					FORTH_DSP 
384a cd 9e 1f			call macro_forth_dsp 
384d				endm 
# End of macro FORTH_DSP
384d 7e					ld a,(hl)	; get type of value on TOS 
384e fe 02				cp DS_TYPE_INUM  
3850 28 03				jr z, .div_inum 
3852			 
3852				if FORTH_ENABLE_FLOATMATH 
3852					jr .div_done 
3852			 
3852				endif 
3852					NEXTW 
3852 c3 4a 21			jp macro_next 
3855				endm 
# End of macro NEXTW
3855			.div_inum: 
3855			 
3855					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3855 cd d8 1f			call macro_dsp_valuehl 
3858				endm 
# End of macro FORTH_DSP_VALUEHL
3858			 
3858 e5					push hl    ; to go to bc 
3859			 
3859					; destroy value TOS 
3859			 
3859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3859 cd 90 20			call macro_forth_dsp_pop 
385c				endm 
# End of macro FORTH_DSP_POP
385c			 
385c			 
385c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385c cd d8 1f			call macro_dsp_valuehl 
385f				endm 
# End of macro FORTH_DSP_VALUEHL
385f			 
385f					; hl to go to de 
385f			 
385f e5					push hl 
3860			 
3860 c1					pop bc 
3861 d1					pop de		 
3862			 
3862			 
3862					if DEBUG_FORTH_MATHS 
3862						DMARK "DIV" 
3862				CALLMONITOR 
3862					endif 
3862					; one value on hl but move to a get other one back 
3862			 
3862			        
3862 cd 3a 0d			call Div16 
3865			 
3865			;	push af	 
3865 e5				push hl 
3866 c5				push bc 
3867			 
3867					if DEBUG_FORTH_MATHS 
3867						DMARK "DI1" 
3867				CALLMONITOR 
3867					endif 
3867			 
3867					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3867 cd 90 20			call macro_forth_dsp_pop 
386a				endm 
# End of macro FORTH_DSP_POP
386a			 
386a			 
386a			 
386a e1					pop hl    ; result 
386b			 
386b cd e1 1d				call forth_push_numhl 
386e			 
386e e1					pop hl    ; reminder 
386f			;		ld h,0 
386f			;		ld l,d 
386f			 
386f cd e1 1d				call forth_push_numhl 
3872			.div_done: 
3872					NEXTW 
3872 c3 4a 21			jp macro_next 
3875				endm 
# End of macro NEXTW
3875			.MUL: 
3875				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3875 19				db WORD_SYS_CORE+5             
3876 ba 38			dw .MIN            
3878 02				db 1 + 1 
3879 .. 00			db "*",0              
387b				endm 
# End of macro CWHEAD
387b			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
387b				; TODO add floating point number detection 
387b					if DEBUG_FORTH_WORDS_KEY 
387b						DMARK "MUL" 
387b f5				push af  
387c 3a 90 38			ld a, (.dmark)  
387f 32 6e fb			ld (debug_mark),a  
3882 3a 91 38			ld a, (.dmark+1)  
3885 32 6f fb			ld (debug_mark+1),a  
3888 3a 92 38			ld a, (.dmark+2)  
388b 32 70 fb			ld (debug_mark+2),a  
388e 18 03			jr .pastdmark  
3890 ..			.dmark: db "MUL"  
3893 f1			.pastdmark: pop af  
3894			endm  
# End of macro DMARK
3894						CALLMONITOR 
3894 cd 84 17			call break_point_state  
3897				endm  
# End of macro CALLMONITOR
3897					endif 
3897					FORTH_DSP 
3897 cd 9e 1f			call macro_forth_dsp 
389a				endm 
# End of macro FORTH_DSP
389a					; v5 FORTH_DSP_VALUE 
389a 7e					ld a,(hl)	; get type of value on TOS 
389b fe 02				cp DS_TYPE_INUM  
389d 28 03				jr z, .mul_inum 
389f			 
389f				if FORTH_ENABLE_FLOATMATH 
389f					jr .mul_done 
389f			 
389f				endif 
389f			 
389f					NEXTW 
389f c3 4a 21			jp macro_next 
38a2				endm 
# End of macro NEXTW
38a2			.mul_inum:	 
38a2			 
38a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38a2 cd d8 1f			call macro_dsp_valuehl 
38a5				endm 
# End of macro FORTH_DSP_VALUEHL
38a5			 
38a5 e5					push hl 
38a6			 
38a6					; destroy value TOS 
38a6			 
38a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a6 cd 90 20			call macro_forth_dsp_pop 
38a9				endm 
# End of macro FORTH_DSP_POP
38a9			 
38a9			 
38a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38a9 cd d8 1f			call macro_dsp_valuehl 
38ac				endm 
# End of macro FORTH_DSP_VALUEHL
38ac			 
38ac					; one value on hl but move to a get other one back 
38ac			 
38ac 7d					ld a, l 
38ad			 
38ad d1					pop de 
38ae			 
38ae					; do the mull 
38ae			;		ex de, hl 
38ae			 
38ae cd 60 0d				call Mult16 
38b1					; save it 
38b1			 
38b1			;		push hl	 
38b1			 
38b1					; 
38b1			 
38b1					; destroy value TOS 
38b1			 
38b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b1 cd 90 20			call macro_forth_dsp_pop 
38b4				endm 
# End of macro FORTH_DSP_POP
38b4			 
38b4					; TODO push value back onto stack for another op etc 
38b4			 
38b4			;		pop hl 
38b4			 
38b4 cd e1 1d				call forth_push_numhl 
38b7			 
38b7			.mul_done: 
38b7					NEXTW 
38b7 c3 4a 21			jp macro_next 
38ba				endm 
# End of macro NEXTW
38ba			 
38ba			 
38ba			 
38ba			 
38ba			.MIN: 
38ba				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
38ba 49				db WORD_SYS_CORE+53             
38bb 3b 39			dw .MAX            
38bd 04				db 3 + 1 
38be .. 00			db "MIN",0              
38c2				endm 
# End of macro CWHEAD
38c2			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
38c2					if DEBUG_FORTH_WORDS_KEY 
38c2						DMARK "MIN" 
38c2 f5				push af  
38c3 3a d7 38			ld a, (.dmark)  
38c6 32 6e fb			ld (debug_mark),a  
38c9 3a d8 38			ld a, (.dmark+1)  
38cc 32 6f fb			ld (debug_mark+1),a  
38cf 3a d9 38			ld a, (.dmark+2)  
38d2 32 70 fb			ld (debug_mark+2),a  
38d5 18 03			jr .pastdmark  
38d7 ..			.dmark: db "MIN"  
38da f1			.pastdmark: pop af  
38db			endm  
# End of macro DMARK
38db						CALLMONITOR 
38db cd 84 17			call break_point_state  
38de				endm  
# End of macro CALLMONITOR
38de					endif 
38de					; get u2 
38de			 
38de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38de cd d8 1f			call macro_dsp_valuehl 
38e1				endm 
# End of macro FORTH_DSP_VALUEHL
38e1			 
38e1 e5					push hl   ; u2 
38e2			 
38e2					; destroy value TOS 
38e2			 
38e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e2 cd 90 20			call macro_forth_dsp_pop 
38e5				endm 
# End of macro FORTH_DSP_POP
38e5			 
38e5					; get u1 
38e5			 
38e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e5 cd d8 1f			call macro_dsp_valuehl 
38e8				endm 
# End of macro FORTH_DSP_VALUEHL
38e8			 
38e8 e5					push hl  ; u1 
38e9			 
38e9					; destroy value TOS 
38e9			 
38e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e9 cd 90 20			call macro_forth_dsp_pop 
38ec				endm 
# End of macro FORTH_DSP_POP
38ec			 
38ec b7			 or a      ;clear carry flag 
38ed e1			  pop hl    ; u1 
38ee d1			  pop de    ; u2 
38ef e5				push hl   ; saved in case hl is lowest 
38f0 ed 52		  sbc hl,de 
38f2 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
38f4			 
38f4 e1				pop hl 
38f5					if DEBUG_FORTH_WORDS 
38f5						DMARK "MIN" 
38f5 f5				push af  
38f6 3a 0a 39			ld a, (.dmark)  
38f9 32 6e fb			ld (debug_mark),a  
38fc 3a 0b 39			ld a, (.dmark+1)  
38ff 32 6f fb			ld (debug_mark+1),a  
3902 3a 0c 39			ld a, (.dmark+2)  
3905 32 70 fb			ld (debug_mark+2),a  
3908 18 03			jr .pastdmark  
390a ..			.dmark: db "MIN"  
390d f1			.pastdmark: pop af  
390e			endm  
# End of macro DMARK
390e						CALLMONITOR 
390e cd 84 17			call break_point_state  
3911				endm  
# End of macro CALLMONITOR
3911					endif 
3911 cd e1 1d				call forth_push_numhl 
3914			 
3914				       NEXTW 
3914 c3 4a 21			jp macro_next 
3917				endm 
# End of macro NEXTW
3917			 
3917			.mincont:  
3917 c1				pop bc   ; tidy up 
3918 eb				ex de , hl  
3919					if DEBUG_FORTH_WORDS 
3919						DMARK "MI1" 
3919 f5				push af  
391a 3a 2e 39			ld a, (.dmark)  
391d 32 6e fb			ld (debug_mark),a  
3920 3a 2f 39			ld a, (.dmark+1)  
3923 32 6f fb			ld (debug_mark+1),a  
3926 3a 30 39			ld a, (.dmark+2)  
3929 32 70 fb			ld (debug_mark+2),a  
392c 18 03			jr .pastdmark  
392e ..			.dmark: db "MI1"  
3931 f1			.pastdmark: pop af  
3932			endm  
# End of macro DMARK
3932						CALLMONITOR 
3932 cd 84 17			call break_point_state  
3935				endm  
# End of macro CALLMONITOR
3935					endif 
3935 cd e1 1d				call forth_push_numhl 
3938			 
3938				       NEXTW 
3938 c3 4a 21			jp macro_next 
393b				endm 
# End of macro NEXTW
393b			.MAX: 
393b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
393b 4a				db WORD_SYS_CORE+54             
393c bc 39			dw .RND16            
393e 04				db 3 + 1 
393f .. 00			db "MAX",0              
3943				endm 
# End of macro CWHEAD
3943			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3943					if DEBUG_FORTH_WORDS_KEY 
3943						DMARK "MAX" 
3943 f5				push af  
3944 3a 58 39			ld a, (.dmark)  
3947 32 6e fb			ld (debug_mark),a  
394a 3a 59 39			ld a, (.dmark+1)  
394d 32 6f fb			ld (debug_mark+1),a  
3950 3a 5a 39			ld a, (.dmark+2)  
3953 32 70 fb			ld (debug_mark+2),a  
3956 18 03			jr .pastdmark  
3958 ..			.dmark: db "MAX"  
395b f1			.pastdmark: pop af  
395c			endm  
# End of macro DMARK
395c						CALLMONITOR 
395c cd 84 17			call break_point_state  
395f				endm  
# End of macro CALLMONITOR
395f					endif 
395f					; get u2 
395f			 
395f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
395f cd d8 1f			call macro_dsp_valuehl 
3962				endm 
# End of macro FORTH_DSP_VALUEHL
3962			 
3962 e5					push hl   ; u2 
3963			 
3963					; destroy value TOS 
3963			 
3963					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3963 cd 90 20			call macro_forth_dsp_pop 
3966				endm 
# End of macro FORTH_DSP_POP
3966			 
3966					; get u1 
3966			 
3966					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3966 cd d8 1f			call macro_dsp_valuehl 
3969				endm 
# End of macro FORTH_DSP_VALUEHL
3969			 
3969 e5					push hl  ; u1 
396a			 
396a					; destroy value TOS 
396a			 
396a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396a cd 90 20			call macro_forth_dsp_pop 
396d				endm 
# End of macro FORTH_DSP_POP
396d			 
396d b7			 or a      ;clear carry flag 
396e e1			  pop hl    ; u1 
396f d1			  pop de    ; u2 
3970 e5				push hl   ; saved in case hl is lowest 
3971 ed 52		  sbc hl,de 
3973 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3975			 
3975 e1				pop hl 
3976					if DEBUG_FORTH_WORDS 
3976						DMARK "MAX" 
3976 f5				push af  
3977 3a 8b 39			ld a, (.dmark)  
397a 32 6e fb			ld (debug_mark),a  
397d 3a 8c 39			ld a, (.dmark+1)  
3980 32 6f fb			ld (debug_mark+1),a  
3983 3a 8d 39			ld a, (.dmark+2)  
3986 32 70 fb			ld (debug_mark+2),a  
3989 18 03			jr .pastdmark  
398b ..			.dmark: db "MAX"  
398e f1			.pastdmark: pop af  
398f			endm  
# End of macro DMARK
398f						CALLMONITOR 
398f cd 84 17			call break_point_state  
3992				endm  
# End of macro CALLMONITOR
3992					endif 
3992 cd e1 1d				call forth_push_numhl 
3995			 
3995				       NEXTW 
3995 c3 4a 21			jp macro_next 
3998				endm 
# End of macro NEXTW
3998			 
3998			.maxcont:  
3998 c1				pop bc   ; tidy up 
3999 eb				ex de , hl  
399a					if DEBUG_FORTH_WORDS 
399a						DMARK "MA1" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 6e fb			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 6f fb			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 70 fb			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "MA1"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3						CALLMONITOR 
39b3 cd 84 17			call break_point_state  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6 cd e1 1d				call forth_push_numhl 
39b9				       NEXTW 
39b9 c3 4a 21			jp macro_next 
39bc				endm 
# End of macro NEXTW
39bc			 
39bc			.RND16: 
39bc				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
39bc 4e				db WORD_SYS_CORE+58             
39bd eb 39			dw .RND8            
39bf 06				db 5 + 1 
39c0 .. 00			db "RND16",0              
39c6				endm 
# End of macro CWHEAD
39c6			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
39c6					if DEBUG_FORTH_WORDS_KEY 
39c6						DMARK "R16" 
39c6 f5				push af  
39c7 3a db 39			ld a, (.dmark)  
39ca 32 6e fb			ld (debug_mark),a  
39cd 3a dc 39			ld a, (.dmark+1)  
39d0 32 6f fb			ld (debug_mark+1),a  
39d3 3a dd 39			ld a, (.dmark+2)  
39d6 32 70 fb			ld (debug_mark+2),a  
39d9 18 03			jr .pastdmark  
39db ..			.dmark: db "R16"  
39de f1			.pastdmark: pop af  
39df			endm  
# End of macro DMARK
39df						CALLMONITOR 
39df cd 84 17			call break_point_state  
39e2				endm  
# End of macro CALLMONITOR
39e2					endif 
39e2 cd 04 0d				call prng16  
39e5 cd e1 1d				call forth_push_numhl 
39e8				       NEXTW 
39e8 c3 4a 21			jp macro_next 
39eb				endm 
# End of macro NEXTW
39eb			.RND8: 
39eb				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
39eb 60				db WORD_SYS_CORE+76             
39ec 20 3a			dw .RND            
39ee 05				db 4 + 1 
39ef .. 00			db "RND8",0              
39f4				endm 
# End of macro CWHEAD
39f4			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
39f4					if DEBUG_FORTH_WORDS_KEY 
39f4						DMARK "RN8" 
39f4 f5				push af  
39f5 3a 09 3a			ld a, (.dmark)  
39f8 32 6e fb			ld (debug_mark),a  
39fb 3a 0a 3a			ld a, (.dmark+1)  
39fe 32 6f fb			ld (debug_mark+1),a  
3a01 3a 0b 3a			ld a, (.dmark+2)  
3a04 32 70 fb			ld (debug_mark+2),a  
3a07 18 03			jr .pastdmark  
3a09 ..			.dmark: db "RN8"  
3a0c f1			.pastdmark: pop af  
3a0d			endm  
# End of macro DMARK
3a0d						CALLMONITOR 
3a0d cd 84 17			call break_point_state  
3a10				endm  
# End of macro CALLMONITOR
3a10					endif 
3a10 2a af f8				ld hl,(xrandc) 
3a13 23					inc hl 
3a14 cd 1e 0d				call xrnd 
3a17 6f					ld l,a	 
3a18 26 00				ld h,0 
3a1a cd e1 1d				call forth_push_numhl 
3a1d				       NEXTW 
3a1d c3 4a 21			jp macro_next 
3a20				endm 
# End of macro NEXTW
3a20			.RND: 
3a20				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3a20 60				db WORD_SYS_CORE+76             
3a21 26 3b			dw .ENDMATHS            
3a23 04				db 3 + 1 
3a24 .. 00			db "RND",0              
3a28				endm 
# End of macro CWHEAD
3a28			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3a28			 
3a28					if DEBUG_FORTH_WORDS_KEY 
3a28						DMARK "RND" 
3a28 f5				push af  
3a29 3a 3d 3a			ld a, (.dmark)  
3a2c 32 6e fb			ld (debug_mark),a  
3a2f 3a 3e 3a			ld a, (.dmark+1)  
3a32 32 6f fb			ld (debug_mark+1),a  
3a35 3a 3f 3a			ld a, (.dmark+2)  
3a38 32 70 fb			ld (debug_mark+2),a  
3a3b 18 03			jr .pastdmark  
3a3d ..			.dmark: db "RND"  
3a40 f1			.pastdmark: pop af  
3a41			endm  
# End of macro DMARK
3a41						CALLMONITOR 
3a41 cd 84 17			call break_point_state  
3a44				endm  
# End of macro CALLMONITOR
3a44					endif 
3a44					 
3a44					FORTH_DSP_VALUEHL    ; upper range 
3a44 cd d8 1f			call macro_dsp_valuehl 
3a47				endm 
# End of macro FORTH_DSP_VALUEHL
3a47			 
3a47 22 b3 f8				ld (LFSRSeed), hl	 
3a4a			 
3a4a					if DEBUG_FORTH_WORDS 
3a4a						DMARK "RN1" 
3a4a f5				push af  
3a4b 3a 5f 3a			ld a, (.dmark)  
3a4e 32 6e fb			ld (debug_mark),a  
3a51 3a 60 3a			ld a, (.dmark+1)  
3a54 32 6f fb			ld (debug_mark+1),a  
3a57 3a 61 3a			ld a, (.dmark+2)  
3a5a 32 70 fb			ld (debug_mark+2),a  
3a5d 18 03			jr .pastdmark  
3a5f ..			.dmark: db "RN1"  
3a62 f1			.pastdmark: pop af  
3a63			endm  
# End of macro DMARK
3a63						CALLMONITOR 
3a63 cd 84 17			call break_point_state  
3a66				endm  
# End of macro CALLMONITOR
3a66					endif 
3a66					FORTH_DSP_POP 
3a66 cd 90 20			call macro_forth_dsp_pop 
3a69				endm 
# End of macro FORTH_DSP_POP
3a69			 
3a69					FORTH_DSP_VALUEHL    ; low range 
3a69 cd d8 1f			call macro_dsp_valuehl 
3a6c				endm 
# End of macro FORTH_DSP_VALUEHL
3a6c			 
3a6c					if DEBUG_FORTH_WORDS 
3a6c						DMARK "RN2" 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 6e fb			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 6f fb			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 70 fb			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "RN2"  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd 84 17			call break_point_state  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88 22 b5 f8				ld (LFSRSeed+2), hl 
3a8b			 
3a8b					FORTH_DSP_POP 
3a8b cd 90 20			call macro_forth_dsp_pop 
3a8e				endm 
# End of macro FORTH_DSP_POP
3a8e			 
3a8e e5					push hl 
3a8f			 
3a8f e1			.inrange:	pop hl 
3a90 cd 04 0d				call prng16  
3a93					if DEBUG_FORTH_WORDS 
3a93						DMARK "RN3" 
3a93 f5				push af  
3a94 3a a8 3a			ld a, (.dmark)  
3a97 32 6e fb			ld (debug_mark),a  
3a9a 3a a9 3a			ld a, (.dmark+1)  
3a9d 32 6f fb			ld (debug_mark+1),a  
3aa0 3a aa 3a			ld a, (.dmark+2)  
3aa3 32 70 fb			ld (debug_mark+2),a  
3aa6 18 03			jr .pastdmark  
3aa8 ..			.dmark: db "RN3"  
3aab f1			.pastdmark: pop af  
3aac			endm  
# End of macro DMARK
3aac						CALLMONITOR 
3aac cd 84 17			call break_point_state  
3aaf				endm  
# End of macro CALLMONITOR
3aaf					endif 
3aaf					 
3aaf					; if the range is 8bit knock out the high byte 
3aaf			 
3aaf ed 5b b3 f8			ld de, (LFSRSeed)     ; check high level 
3ab3			 
3ab3 3e 00				ld a, 0 
3ab5 ba					cp d  
3ab6 20 1e				jr nz, .hirange 
3ab8 26 00				ld h, 0   ; knock it down to 8bit 
3aba			 
3aba					if DEBUG_FORTH_WORDS 
3aba						DMARK "RNk" 
3aba f5				push af  
3abb 3a cf 3a			ld a, (.dmark)  
3abe 32 6e fb			ld (debug_mark),a  
3ac1 3a d0 3a			ld a, (.dmark+1)  
3ac4 32 6f fb			ld (debug_mark+1),a  
3ac7 3a d1 3a			ld a, (.dmark+2)  
3aca 32 70 fb			ld (debug_mark+2),a  
3acd 18 03			jr .pastdmark  
3acf ..			.dmark: db "RNk"  
3ad2 f1			.pastdmark: pop af  
3ad3			endm  
# End of macro DMARK
3ad3						CALLMONITOR 
3ad3 cd 84 17			call break_point_state  
3ad6				endm  
# End of macro CALLMONITOR
3ad6					endif 
3ad6			.hirange:   
3ad6 e5					push hl  
3ad7 b7					or a  
3ad8 ed 52		                sbc hl, de 
3ada			 
3ada					;call cmp16 
3ada			 
3ada 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3adc e1					pop hl 
3add e5					push hl 
3ade			 
3ade					if DEBUG_FORTH_WORDS 
3ade						DMARK "RN4" 
3ade f5				push af  
3adf 3a f3 3a			ld a, (.dmark)  
3ae2 32 6e fb			ld (debug_mark),a  
3ae5 3a f4 3a			ld a, (.dmark+1)  
3ae8 32 6f fb			ld (debug_mark+1),a  
3aeb 3a f5 3a			ld a, (.dmark+2)  
3aee 32 70 fb			ld (debug_mark+2),a  
3af1 18 03			jr .pastdmark  
3af3 ..			.dmark: db "RN4"  
3af6 f1			.pastdmark: pop af  
3af7			endm  
# End of macro DMARK
3af7						CALLMONITOR 
3af7 cd 84 17			call break_point_state  
3afa				endm  
# End of macro CALLMONITOR
3afa					endif 
3afa ed 5b b5 f8			ld de, (LFSRSeed+2)   ; check low range 
3afe					;call cmp16 
3afe				 
3afe b7					or a  
3aff ed 52		                sbc hl, de 
3b01 38 8c				jr c, .inrange 
3b03			 
3b03 e1					pop hl 
3b04					 
3b04					if DEBUG_FORTH_WORDS 
3b04						DMARK "RNd" 
3b04 f5				push af  
3b05 3a 19 3b			ld a, (.dmark)  
3b08 32 6e fb			ld (debug_mark),a  
3b0b 3a 1a 3b			ld a, (.dmark+1)  
3b0e 32 6f fb			ld (debug_mark+1),a  
3b11 3a 1b 3b			ld a, (.dmark+2)  
3b14 32 70 fb			ld (debug_mark+2),a  
3b17 18 03			jr .pastdmark  
3b19 ..			.dmark: db "RNd"  
3b1c f1			.pastdmark: pop af  
3b1d			endm  
# End of macro DMARK
3b1d						CALLMONITOR 
3b1d cd 84 17			call break_point_state  
3b20				endm  
# End of macro CALLMONITOR
3b20					endif 
3b20			 
3b20			 
3b20 cd e1 1d				call forth_push_numhl 
3b23				       NEXTW 
3b23 c3 4a 21			jp macro_next 
3b26				endm 
# End of macro NEXTW
3b26			 
3b26			.ENDMATHS: 
3b26			 
3b26			; eof 
3b26			 
# End of file forth_words_maths.asm
3b26			include "forth_words_display.asm" 
3b26			 
3b26			; | ## Display Words 
3b26			 
3b26			.INFO: 
3b26			 
3b26				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3b26 62				db WORD_SYS_CORE+78             
3b27 43 3b			dw .ATP            
3b29 05				db 4 + 1 
3b2a .. 00			db "INFO",0              
3b2f				endm 
# End of macro CWHEAD
3b2f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3b2f					FORTH_DSP_VALUEHL 
3b2f cd d8 1f			call macro_dsp_valuehl 
3b32				endm 
# End of macro FORTH_DSP_VALUEHL
3b32			 
3b32					FORTH_DSP_POP 
3b32 cd 90 20			call macro_forth_dsp_pop 
3b35				endm 
# End of macro FORTH_DSP_POP
3b35			 
3b35 e5					push hl 
3b36			 
3b36					FORTH_DSP_VALUEHL 
3b36 cd d8 1f			call macro_dsp_valuehl 
3b39				endm 
# End of macro FORTH_DSP_VALUEHL
3b39			 
3b39					FORTH_DSP_POP 
3b39 cd 90 20			call macro_forth_dsp_pop 
3b3c				endm 
# End of macro FORTH_DSP_POP
3b3c			 
3b3c d1					pop de 
3b3d			 
3b3d cd 3a 0b				call info_panel 
3b40			 
3b40			 
3b40					NEXTW 
3b40 c3 4a 21			jp macro_next 
3b43				endm 
# End of macro NEXTW
3b43			.ATP: 
3b43				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b43 62				db WORD_SYS_CORE+78             
3b44 ba 3b			dw .FB            
3b46 04				db 3 + 1 
3b47 .. 00			db "AT?",0              
3b4b				endm 
# End of macro CWHEAD
3b4b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b4b					if DEBUG_FORTH_WORDS_KEY 
3b4b						DMARK "AT?" 
3b4b f5				push af  
3b4c 3a 60 3b			ld a, (.dmark)  
3b4f 32 6e fb			ld (debug_mark),a  
3b52 3a 61 3b			ld a, (.dmark+1)  
3b55 32 6f fb			ld (debug_mark+1),a  
3b58 3a 62 3b			ld a, (.dmark+2)  
3b5b 32 70 fb			ld (debug_mark+2),a  
3b5e 18 03			jr .pastdmark  
3b60 ..			.dmark: db "AT?"  
3b63 f1			.pastdmark: pop af  
3b64			endm  
# End of macro DMARK
3b64						CALLMONITOR 
3b64 cd 84 17			call break_point_state  
3b67				endm  
# End of macro CALLMONITOR
3b67					endif 
3b67 3a 3d f8				ld a, (f_cursor_ptr) 
3b6a			 
3b6a			if DEBUG_FORTH_WORDS 
3b6a				DMARK "AT?" 
3b6a f5				push af  
3b6b 3a 7f 3b			ld a, (.dmark)  
3b6e 32 6e fb			ld (debug_mark),a  
3b71 3a 80 3b			ld a, (.dmark+1)  
3b74 32 6f fb			ld (debug_mark+1),a  
3b77 3a 81 3b			ld a, (.dmark+2)  
3b7a 32 70 fb			ld (debug_mark+2),a  
3b7d 18 03			jr .pastdmark  
3b7f ..			.dmark: db "AT?"  
3b82 f1			.pastdmark: pop af  
3b83			endm  
# End of macro DMARK
3b83				CALLMONITOR 
3b83 cd 84 17			call break_point_state  
3b86				endm  
# End of macro CALLMONITOR
3b86			endif	 
3b86					; count the number of rows 
3b86			 
3b86 06 00				ld b, 0 
3b88 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b89 d6 28				sub display_cols 
3b8b f2 91 3b				jp p, .atprunder 
3b8e 04					inc b 
3b8f 18 f7				jr .atpr 
3b91			.atprunder:	 
3b91			if DEBUG_FORTH_WORDS 
3b91				DMARK "A?2" 
3b91 f5				push af  
3b92 3a a6 3b			ld a, (.dmark)  
3b95 32 6e fb			ld (debug_mark),a  
3b98 3a a7 3b			ld a, (.dmark+1)  
3b9b 32 6f fb			ld (debug_mark+1),a  
3b9e 3a a8 3b			ld a, (.dmark+2)  
3ba1 32 70 fb			ld (debug_mark+2),a  
3ba4 18 03			jr .pastdmark  
3ba6 ..			.dmark: db "A?2"  
3ba9 f1			.pastdmark: pop af  
3baa			endm  
# End of macro DMARK
3baa				CALLMONITOR 
3baa cd 84 17			call break_point_state  
3bad				endm  
# End of macro CALLMONITOR
3bad			endif	 
3bad 26 00				ld h, 0 
3baf 69					ld l, c 
3bb0 cd e1 1d				call forth_push_numhl 
3bb3 68					ld l, b  
3bb4 cd e1 1d				call forth_push_numhl 
3bb7			 
3bb7			 
3bb7				NEXTW 
3bb7 c3 4a 21			jp macro_next 
3bba				endm 
# End of macro NEXTW
3bba			 
3bba			.FB: 
3bba				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3bba 1b				db WORD_SYS_CORE+7             
3bbb 08 3c			dw .EMIT            
3bbd 03				db 2 + 1 
3bbe .. 00			db "FB",0              
3bc1				endm 
# End of macro CWHEAD
3bc1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3bc1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3bc1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3bc1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3bc1					if DEBUG_FORTH_WORDS_KEY 
3bc1						DMARK "FB." 
3bc1 f5				push af  
3bc2 3a d6 3b			ld a, (.dmark)  
3bc5 32 6e fb			ld (debug_mark),a  
3bc8 3a d7 3b			ld a, (.dmark+1)  
3bcb 32 6f fb			ld (debug_mark+1),a  
3bce 3a d8 3b			ld a, (.dmark+2)  
3bd1 32 70 fb			ld (debug_mark+2),a  
3bd4 18 03			jr .pastdmark  
3bd6 ..			.dmark: db "FB."  
3bd9 f1			.pastdmark: pop af  
3bda			endm  
# End of macro DMARK
3bda						CALLMONITOR 
3bda cd 84 17			call break_point_state  
3bdd				endm  
# End of macro CALLMONITOR
3bdd					endif 
3bdd			 
3bdd					FORTH_DSP_VALUEHL 
3bdd cd d8 1f			call macro_dsp_valuehl 
3be0				endm 
# End of macro FORTH_DSP_VALUEHL
3be0			 
3be0 7d					ld a, l 
3be1 fe 01				cp 1 
3be3 20 05				jr nz, .fbn1 
3be5 21 13 fa				ld hl, display_fb1 
3be8 18 15				jr .fbset 
3bea fe 02		.fbn1:		cp 2 
3bec 20 05				jr nz, .fbn2 
3bee 21 d1 f8				ld hl, display_fb2 
3bf1 18 0c				jr .fbset 
3bf3 fe 03		.fbn2:		cp 3 
3bf5 20 05				jr nz, .fbn3 
3bf7 21 72 f9				ld hl, display_fb3 
3bfa 18 03				jr .fbset 
3bfc			.fbn3:		 ; if invalid number select first 
3bfc 21 13 fa				ld hl, display_fb1 
3bff 22 cf f8		.fbset:		ld (display_fb_active), hl 
3c02			 
3c02					FORTH_DSP_POP 
3c02 cd 90 20			call macro_forth_dsp_pop 
3c05				endm 
# End of macro FORTH_DSP_POP
3c05			 
3c05					NEXTW 
3c05 c3 4a 21			jp macro_next 
3c08				endm 
# End of macro NEXTW
3c08			 
3c08			 
3c08			.EMIT: 
3c08				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3c08 1b				db WORD_SYS_CORE+7             
3c09 59 3c			dw .DOTH            
3c0b 05				db 4 + 1 
3c0c .. 00			db "EMIT",0              
3c11				endm 
# End of macro CWHEAD
3c11			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3c11					; get value off TOS and display it 
3c11			 
3c11					if DEBUG_FORTH_WORDS_KEY 
3c11						DMARK "EMT" 
3c11 f5				push af  
3c12 3a 26 3c			ld a, (.dmark)  
3c15 32 6e fb			ld (debug_mark),a  
3c18 3a 27 3c			ld a, (.dmark+1)  
3c1b 32 6f fb			ld (debug_mark+1),a  
3c1e 3a 28 3c			ld a, (.dmark+2)  
3c21 32 70 fb			ld (debug_mark+2),a  
3c24 18 03			jr .pastdmark  
3c26 ..			.dmark: db "EMT"  
3c29 f1			.pastdmark: pop af  
3c2a			endm  
# End of macro DMARK
3c2a						CALLMONITOR 
3c2a cd 84 17			call break_point_state  
3c2d				endm  
# End of macro CALLMONITOR
3c2d					endif 
3c2d			 
3c2d					FORTH_DSP_VALUEHL 
3c2d cd d8 1f			call macro_dsp_valuehl 
3c30				endm 
# End of macro FORTH_DSP_VALUEHL
3c30			 
3c30 7d					ld a,l 
3c31			 
3c31					; TODO write to display 
3c31			 
3c31 32 12 f0				ld (os_input), a 
3c34 3e 00				ld a, 0 
3c36 32 13 f0				ld (os_input+1), a 
3c39					 
3c39 3a 3d f8				ld a, (f_cursor_ptr) 
3c3c 11 12 f0				ld de, os_input 
3c3f cd bc 0b				call str_at_display 
3c42			 
3c42			 
3c42 3a 1b f8				ld a,(cli_autodisplay) 
3c45 fe 00				cp 0 
3c47 28 03				jr z, .enoupdate 
3c49 cd cc 0b						call update_display 
3c4c					.enoupdate: 
3c4c			 
3c4c 3a 3d f8				ld a, (f_cursor_ptr) 
3c4f 3c					inc a 
3c50 32 3d f8				ld (f_cursor_ptr), a   ; save new pos 
3c53			 
3c53			 
3c53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c53 cd 90 20			call macro_forth_dsp_pop 
3c56				endm 
# End of macro FORTH_DSP_POP
3c56			  
3c56			 
3c56					NEXTW 
3c56 c3 4a 21			jp macro_next 
3c59				endm 
# End of macro NEXTW
3c59			.DOTH: 
3c59				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c59 1c				db WORD_SYS_CORE+8             
3c5a 89 3c			dw .DOTF            
3c5c 03				db 2 + 1 
3c5d .. 00			db ".-",0              
3c60				endm 
# End of macro CWHEAD
3c60			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c60					; get value off TOS and display it 
3c60					if DEBUG_FORTH_WORDS_KEY 
3c60						DMARK "DTD" 
3c60 f5				push af  
3c61 3a 75 3c			ld a, (.dmark)  
3c64 32 6e fb			ld (debug_mark),a  
3c67 3a 76 3c			ld a, (.dmark+1)  
3c6a 32 6f fb			ld (debug_mark+1),a  
3c6d 3a 77 3c			ld a, (.dmark+2)  
3c70 32 70 fb			ld (debug_mark+2),a  
3c73 18 03			jr .pastdmark  
3c75 ..			.dmark: db "DTD"  
3c78 f1			.pastdmark: pop af  
3c79			endm  
# End of macro DMARK
3c79						CALLMONITOR 
3c79 cd 84 17			call break_point_state  
3c7c				endm  
# End of macro CALLMONITOR
3c7c					endif 
3c7c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c7e 3e 00			ld a, 0 
3c80 32 1c f8			ld (cli_mvdot), a 
3c83 c3 e0 3c			jp .dotgo 
3c86				NEXTW 
3c86 c3 4a 21			jp macro_next 
3c89				endm 
# End of macro NEXTW
3c89			.DOTF: 
3c89				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c89 1c				db WORD_SYS_CORE+8             
3c8a b7 3c			dw .DOT            
3c8c 03				db 2 + 1 
3c8d .. 00			db ".>",0              
3c90				endm 
# End of macro CWHEAD
3c90			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c90					; get value off TOS and display it 
3c90			        ; TODO BUG adds extra spaces 
3c90			        ; TODO BUG handle numerics? 
3c90					if DEBUG_FORTH_WORDS_KEY 
3c90						DMARK "DTC" 
3c90 f5				push af  
3c91 3a a5 3c			ld a, (.dmark)  
3c94 32 6e fb			ld (debug_mark),a  
3c97 3a a6 3c			ld a, (.dmark+1)  
3c9a 32 6f fb			ld (debug_mark+1),a  
3c9d 3a a7 3c			ld a, (.dmark+2)  
3ca0 32 70 fb			ld (debug_mark+2),a  
3ca3 18 03			jr .pastdmark  
3ca5 ..			.dmark: db "DTC"  
3ca8 f1			.pastdmark: pop af  
3ca9			endm  
# End of macro DMARK
3ca9						CALLMONITOR 
3ca9 cd 84 17			call break_point_state  
3cac				endm  
# End of macro CALLMONITOR
3cac					endif 
3cac 3e 01			ld a, 1 
3cae 32 1c f8			ld (cli_mvdot), a 
3cb1 c3 e0 3c			jp .dotgo 
3cb4				NEXTW 
3cb4 c3 4a 21			jp macro_next 
3cb7				endm 
# End of macro NEXTW
3cb7			 
3cb7			.DOT: 
3cb7				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3cb7 1c				db WORD_SYS_CORE+8             
3cb8 43 3d			dw .CLS            
3cba 02				db 1 + 1 
3cbb .. 00			db ".",0              
3cbd				endm 
# End of macro CWHEAD
3cbd			        ; | . ( u -- ) Display TOS | DONE 
3cbd					; get value off TOS and display it 
3cbd			 
3cbd					if DEBUG_FORTH_WORDS_KEY 
3cbd						DMARK "DOT" 
3cbd f5				push af  
3cbe 3a d2 3c			ld a, (.dmark)  
3cc1 32 6e fb			ld (debug_mark),a  
3cc4 3a d3 3c			ld a, (.dmark+1)  
3cc7 32 6f fb			ld (debug_mark+1),a  
3cca 3a d4 3c			ld a, (.dmark+2)  
3ccd 32 70 fb			ld (debug_mark+2),a  
3cd0 18 03			jr .pastdmark  
3cd2 ..			.dmark: db "DOT"  
3cd5 f1			.pastdmark: pop af  
3cd6			endm  
# End of macro DMARK
3cd6						CALLMONITOR 
3cd6 cd 84 17			call break_point_state  
3cd9				endm  
# End of macro CALLMONITOR
3cd9					endif 
3cd9 3e 00			ld a, 0 
3cdb 32 1c f8			ld (cli_mvdot), a 
3cde 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ce0				 
3ce0			 
3ce0			.dotgo: 
3ce0			 
3ce0			; move up type to on stack for parserv5 
3ce0					FORTH_DSP 
3ce0 cd 9e 1f			call macro_forth_dsp 
3ce3				endm 
# End of macro FORTH_DSP
3ce3				;FORTH_DSP_VALUE  
3ce3			 
3ce3			if DEBUG_FORTH_DOT 
3ce3				DMARK "DOT" 
3ce3				CALLMONITOR 
3ce3			endif	 
3ce3			;		.print: 
3ce3			 
3ce3 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ce4 23				inc hl   ; position to the actual value 
3ce5 fe 01			cp DS_TYPE_STR 
3ce7 20 06			jr nz, .dotnum1  
3ce9			 
3ce9			; display string 
3ce9				FORTH_DSP_VALUE  
3ce9 cd c1 1f			call macro_forth_dsp_value 
3cec				endm 
# End of macro FORTH_DSP_VALUE
3cec eb				ex de,hl 
3ced 18 11			jr .dotwrite 
3cef			 
3cef			.dotnum1: 
3cef fe 02			cp DS_TYPE_INUM 
3cf1 20 0c			jr nz, .dotflot 
3cf3			 
3cf3			 
3cf3			; display number 
3cf3			 
3cf3			;	push hl 
3cf3			;	call clear_display 
3cf3			;	pop hl 
3cf3			 
3cf3 5e				ld e, (hl) 
3cf4 23				inc hl 
3cf5 56				ld d, (hl) 
3cf6 21 14 ee			ld hl, scratch 
3cf9			if DEBUG_FORTH_DOT 
3cf9				DMARK "DT1" 
3cf9				CALLMONITOR 
3cf9			endif	 
3cf9			 
3cf9 cd ea 11			call uitoa_16 
3cfc eb				ex de,hl 
3cfd			 
3cfd			if DEBUG_FORTH_DOT 
3cfd				DMARK "DT2" 
3cfd				CALLMONITOR 
3cfd			endif	 
3cfd			 
3cfd			;	ld de, os_word_scratch 
3cfd 18 01			jr .dotwrite 
3cff			 
3cff 00			.dotflot:   nop 
3d00			; TODO print floating point number 
3d00			 
3d00			.dotwrite:		 
3d00			 
3d00					; if c is set then set all '-' to spaces 
3d00					; need to also take into account .>  
3d00			 
3d00 3e 01				ld a, 1 
3d02 b9					cp c 
3d03 20 13				jr nz, .nodashswap 
3d05			 
3d05					; DE has the string to write, working with HL 
3d05			 
3d05 06 ff				ld b, 255 
3d07 d5					push de 
3d08 e1					pop hl 
3d09			 
3d09			if DEBUG_FORTH_DOT 
3d09				DMARK "DT-" 
3d09				CALLMONITOR 
3d09			endif	 
3d09 7e			.dashscan:	ld a, (hl) 
3d0a fe 00				cp 0 
3d0c 28 0a				jr z, .nodashswap 
3d0e fe 2d				cp '-' 
3d10 20 03				jr nz, .dashskip 
3d12 3e 20				ld a, ' ' 
3d14 77					ld (hl), a 
3d15 23			.dashskip:	inc hl 
3d16			if DEBUG_FORTH_DOT 
3d16				DMARK "D-2" 
3d16				CALLMONITOR 
3d16			endif	 
3d16 10 f1				djnz .dashscan 
3d18			 
3d18			if DEBUG_FORTH_DOT 
3d18				DMARK "D-1" 
3d18				CALLMONITOR 
3d18			endif	 
3d18			 
3d18			.nodashswap: 
3d18			 
3d18 e5					push hl   ; save string start in case we need to advance print 
3d19			 
3d19 3a 3d f8				ld a, (f_cursor_ptr) 
3d1c cd bc 0b				call str_at_display 
3d1f 3a 1b f8				ld a,(cli_autodisplay) 
3d22 fe 00				cp 0 
3d24 28 03				jr z, .noupdate 
3d26 cd cc 0b						call update_display 
3d29					.noupdate: 
3d29			 
3d29			 
3d29					; see if we need to advance the print position 
3d29			 
3d29 e1					pop hl   ; get back string 
3d2a			 
3d2a 3a 1c f8				ld a, (cli_mvdot) 
3d2d			if DEBUG_FORTH_DOT 
3d2d					ld e,a 
3d2d				DMARK "D>1" 
3d2d				CALLMONITOR 
3d2d			endif	 
3d2d fe 00				cp 0 
3d2f 28 0c				jr z, .noadv 
3d31					; yes, lets advance the print position 
3d31 3e 00				ld a, 0 
3d33 cd 46 12				call strlent 
3d36 3a 3d f8				ld a, (f_cursor_ptr) 
3d39 85					add a,l 
3d3a					;call addatohl 
3d3a					;ld a, l 
3d3a 32 3d f8				ld (f_cursor_ptr), a   ; save new pos 
3d3d			 
3d3d			if DEBUG_FORTH_DOT 
3d3d				DMARK "D->" 
3d3d				CALLMONITOR 
3d3d			endif	 
3d3d			 
3d3d			.noadv:	 
3d3d			 
3d3d					if DEBUG_FORTH_DOT_WAIT 
3d3d							call next_page_prompt 
3d3d					endif	 
3d3d			; TODO this pop off the stack causes a crash. i dont know why 
3d3d			 
3d3d			 
3d3d			if DEBUG_FORTH_DOT 
3d3d				DMARK "DTh" 
3d3d				CALLMONITOR 
3d3d			endif	 
3d3d			 
3d3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3d cd 90 20			call macro_forth_dsp_pop 
3d40				endm 
# End of macro FORTH_DSP_POP
3d40			 
3d40			if DEBUG_FORTH_DOT 
3d40				DMARK "DTi" 
3d40				CALLMONITOR 
3d40			endif	 
3d40			 
3d40			 
3d40					NEXTW 
3d40 c3 4a 21			jp macro_next 
3d43				endm 
# End of macro NEXTW
3d43			 
3d43			.CLS: 
3d43				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d43 35				db WORD_SYS_CORE+33             
3d44 70 3d			dw .DRAW            
3d46 04				db 3 + 1 
3d47 .. 00			db "CLS",0              
3d4b				endm 
# End of macro CWHEAD
3d4b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d4b					if DEBUG_FORTH_WORDS_KEY 
3d4b						DMARK "CLS" 
3d4b f5				push af  
3d4c 3a 60 3d			ld a, (.dmark)  
3d4f 32 6e fb			ld (debug_mark),a  
3d52 3a 61 3d			ld a, (.dmark+1)  
3d55 32 6f fb			ld (debug_mark+1),a  
3d58 3a 62 3d			ld a, (.dmark+2)  
3d5b 32 70 fb			ld (debug_mark+2),a  
3d5e 18 03			jr .pastdmark  
3d60 ..			.dmark: db "CLS"  
3d63 f1			.pastdmark: pop af  
3d64			endm  
# End of macro DMARK
3d64						CALLMONITOR 
3d64 cd 84 17			call break_point_state  
3d67				endm  
# End of macro CALLMONITOR
3d67					endif 
3d67 cd a9 0b				call clear_display 
3d6a c3 7e 3e				jp .home		; and home cursor 
3d6d					NEXTW 
3d6d c3 4a 21			jp macro_next 
3d70				endm 
# End of macro NEXTW
3d70			 
3d70			.DRAW: 
3d70				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3d70 36				db WORD_SYS_CORE+34             
3d71 9b 3d			dw .DUMP            
3d73 05				db 4 + 1 
3d74 .. 00			db "DRAW",0              
3d79				endm 
# End of macro CWHEAD
3d79			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3d79					if DEBUG_FORTH_WORDS_KEY 
3d79						DMARK "DRW" 
3d79 f5				push af  
3d7a 3a 8e 3d			ld a, (.dmark)  
3d7d 32 6e fb			ld (debug_mark),a  
3d80 3a 8f 3d			ld a, (.dmark+1)  
3d83 32 6f fb			ld (debug_mark+1),a  
3d86 3a 90 3d			ld a, (.dmark+2)  
3d89 32 70 fb			ld (debug_mark+2),a  
3d8c 18 03			jr .pastdmark  
3d8e ..			.dmark: db "DRW"  
3d91 f1			.pastdmark: pop af  
3d92			endm  
# End of macro DMARK
3d92						CALLMONITOR 
3d92 cd 84 17			call break_point_state  
3d95				endm  
# End of macro CALLMONITOR
3d95					endif 
3d95 cd cc 0b				call update_display 
3d98					NEXTW 
3d98 c3 4a 21			jp macro_next 
3d9b				endm 
# End of macro NEXTW
3d9b			 
3d9b			.DUMP: 
3d9b				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3d9b 37				db WORD_SYS_CORE+35             
3d9c d3 3d			dw .CDUMP            
3d9e 05				db 4 + 1 
3d9f .. 00			db "DUMP",0              
3da4				endm 
# End of macro CWHEAD
3da4			; | DUMP ( x -- ) With address x display dump   | DONE 
3da4			; TODO pop address to use off of the stack 
3da4					if DEBUG_FORTH_WORDS_KEY 
3da4						DMARK "DUM" 
3da4 f5				push af  
3da5 3a b9 3d			ld a, (.dmark)  
3da8 32 6e fb			ld (debug_mark),a  
3dab 3a ba 3d			ld a, (.dmark+1)  
3dae 32 6f fb			ld (debug_mark+1),a  
3db1 3a bb 3d			ld a, (.dmark+2)  
3db4 32 70 fb			ld (debug_mark+2),a  
3db7 18 03			jr .pastdmark  
3db9 ..			.dmark: db "DUM"  
3dbc f1			.pastdmark: pop af  
3dbd			endm  
# End of macro DMARK
3dbd						CALLMONITOR 
3dbd cd 84 17			call break_point_state  
3dc0				endm  
# End of macro CALLMONITOR
3dc0					endif 
3dc0 cd a9 0b				call clear_display 
3dc3			 
3dc3					; get address 
3dc3			 
3dc3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc3 cd d8 1f			call macro_dsp_valuehl 
3dc6				endm 
# End of macro FORTH_DSP_VALUEHL
3dc6				 
3dc6					; save it for cdump 
3dc6			 
3dc6 22 37 f1				ld (os_cur_ptr),hl 
3dc9			 
3dc9					; destroy value TOS 
3dc9			 
3dc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dc9 cd 90 20			call macro_forth_dsp_pop 
3dcc				endm 
# End of macro FORTH_DSP_POP
3dcc			 
3dcc cd 61 1c				call dumpcont	; skip old style of param parsing	 
3dcf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3dd0					NEXTW 
3dd0 c3 4a 21			jp macro_next 
3dd3				endm 
# End of macro NEXTW
3dd3			.CDUMP: 
3dd3				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3dd3 38				db WORD_SYS_CORE+36             
3dd4 03 3e			dw .DAT            
3dd6 06				db 5 + 1 
3dd7 .. 00			db "CDUMP",0              
3ddd				endm 
# End of macro CWHEAD
3ddd			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ddd					if DEBUG_FORTH_WORDS_KEY 
3ddd						DMARK "CDP" 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 6e fb			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 6f fb			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 70 fb			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "CDP"  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd 84 17			call break_point_state  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9 cd a9 0b				call clear_display 
3dfc cd 61 1c				call dumpcont	 
3dff c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e00					NEXTW 
3e00 c3 4a 21			jp macro_next 
3e03				endm 
# End of macro NEXTW
3e03			 
3e03			 
3e03			 
3e03			 
3e03			.DAT: 
3e03				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e03 3d				db WORD_SYS_CORE+41             
3e04 59 3e			dw .HOME            
3e06 03				db 2 + 1 
3e07 .. 00			db "AT",0              
3e0a				endm 
# End of macro CWHEAD
3e0a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e0a					if DEBUG_FORTH_WORDS_KEY 
3e0a						DMARK "AT." 
3e0a f5				push af  
3e0b 3a 1f 3e			ld a, (.dmark)  
3e0e 32 6e fb			ld (debug_mark),a  
3e11 3a 20 3e			ld a, (.dmark+1)  
3e14 32 6f fb			ld (debug_mark+1),a  
3e17 3a 21 3e			ld a, (.dmark+2)  
3e1a 32 70 fb			ld (debug_mark+2),a  
3e1d 18 03			jr .pastdmark  
3e1f ..			.dmark: db "AT."  
3e22 f1			.pastdmark: pop af  
3e23			endm  
# End of macro DMARK
3e23						CALLMONITOR 
3e23 cd 84 17			call break_point_state  
3e26				endm  
# End of macro CALLMONITOR
3e26					endif 
3e26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e26 cd d8 1f			call macro_dsp_valuehl 
3e29				endm 
# End of macro FORTH_DSP_VALUEHL
3e29			 
3e29			 
3e29					; TODO save cursor row 
3e29 7d					ld a,l 
3e2a fe 02				cp 2 
3e2c 20 04				jr nz, .crow3 
3e2e 3e 28				ld a, display_row_2 
3e30 18 12				jr .ccol1 
3e32 fe 03		.crow3:		cp 3 
3e34 20 04				jr nz, .crow4 
3e36 3e 50				ld a, display_row_3 
3e38 18 0a				jr .ccol1 
3e3a fe 04		.crow4:		cp 4 
3e3c 20 04				jr nz, .crow1 
3e3e 3e 78				ld a, display_row_4 
3e40 18 02				jr .ccol1 
3e42 3e 00		.crow1:		ld a,display_row_1 
3e44 f5			.ccol1:		push af			; got row offset 
3e45 6f					ld l,a 
3e46 26 00				ld h,0 
3e48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e48 cd 90 20			call macro_forth_dsp_pop 
3e4b				endm 
# End of macro FORTH_DSP_POP
3e4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e4b cd d8 1f			call macro_dsp_valuehl 
3e4e				endm 
# End of macro FORTH_DSP_VALUEHL
3e4e					; TODO save cursor col 
3e4e f1					pop af 
3e4f 85					add l		; add col offset 
3e50 32 3d f8				ld (f_cursor_ptr), a 
3e53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e53 cd 90 20			call macro_forth_dsp_pop 
3e56				endm 
# End of macro FORTH_DSP_POP
3e56			 
3e56					; calculate  
3e56			 
3e56					NEXTW 
3e56 c3 4a 21			jp macro_next 
3e59				endm 
# End of macro NEXTW
3e59			 
3e59			 
3e59			.HOME: 
3e59				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3e59 41				db WORD_SYS_CORE+45             
3e5a 86 3e			dw .SPACE            
3e5c 05				db 4 + 1 
3e5d .. 00			db "HOME",0              
3e62				endm 
# End of macro CWHEAD
3e62			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3e62					if DEBUG_FORTH_WORDS_KEY 
3e62						DMARK "HOM" 
3e62 f5				push af  
3e63 3a 77 3e			ld a, (.dmark)  
3e66 32 6e fb			ld (debug_mark),a  
3e69 3a 78 3e			ld a, (.dmark+1)  
3e6c 32 6f fb			ld (debug_mark+1),a  
3e6f 3a 79 3e			ld a, (.dmark+2)  
3e72 32 70 fb			ld (debug_mark+2),a  
3e75 18 03			jr .pastdmark  
3e77 ..			.dmark: db "HOM"  
3e7a f1			.pastdmark: pop af  
3e7b			endm  
# End of macro DMARK
3e7b						CALLMONITOR 
3e7b cd 84 17			call break_point_state  
3e7e				endm  
# End of macro CALLMONITOR
3e7e					endif 
3e7e 3e 00		.home:		ld a, 0		; and home cursor 
3e80 32 3d f8				ld (f_cursor_ptr), a 
3e83					NEXTW 
3e83 c3 4a 21			jp macro_next 
3e86				endm 
# End of macro NEXTW
3e86			 
3e86			 
3e86			.SPACE: 
3e86				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3e86 46				db WORD_SYS_CORE+50             
3e87 b4 3e			dw .SPACES            
3e89 03				db 2 + 1 
3e8a .. 00			db "BL",0              
3e8d				endm 
# End of macro CWHEAD
3e8d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3e8d					if DEBUG_FORTH_WORDS_KEY 
3e8d						DMARK "BL." 
3e8d f5				push af  
3e8e 3a a2 3e			ld a, (.dmark)  
3e91 32 6e fb			ld (debug_mark),a  
3e94 3a a3 3e			ld a, (.dmark+1)  
3e97 32 6f fb			ld (debug_mark+1),a  
3e9a 3a a4 3e			ld a, (.dmark+2)  
3e9d 32 70 fb			ld (debug_mark+2),a  
3ea0 18 03			jr .pastdmark  
3ea2 ..			.dmark: db "BL."  
3ea5 f1			.pastdmark: pop af  
3ea6			endm  
# End of macro DMARK
3ea6						CALLMONITOR 
3ea6 cd 84 17			call break_point_state  
3ea9				endm  
# End of macro CALLMONITOR
3ea9					endif 
3ea9 21 b2 3e				ld hl, .blstr 
3eac cd 4f 1e				call forth_push_str 
3eaf					 
3eaf				       NEXTW 
3eaf c3 4a 21			jp macro_next 
3eb2				endm 
# End of macro NEXTW
3eb2			 
3eb2 .. 00		.blstr: db " ", 0 
3eb4			 
3eb4			.SPACES: 
3eb4				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3eb4 47				db WORD_SYS_CORE+51             
3eb5 4f 3f			dw .SCROLL            
3eb7 07				db 6 + 1 
3eb8 .. 00			db "SPACES",0              
3ebf				endm 
# End of macro CWHEAD
3ebf			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ebf					if DEBUG_FORTH_WORDS_KEY 
3ebf						DMARK "SPS" 
3ebf f5				push af  
3ec0 3a d4 3e			ld a, (.dmark)  
3ec3 32 6e fb			ld (debug_mark),a  
3ec6 3a d5 3e			ld a, (.dmark+1)  
3ec9 32 6f fb			ld (debug_mark+1),a  
3ecc 3a d6 3e			ld a, (.dmark+2)  
3ecf 32 70 fb			ld (debug_mark+2),a  
3ed2 18 03			jr .pastdmark  
3ed4 ..			.dmark: db "SPS"  
3ed7 f1			.pastdmark: pop af  
3ed8			endm  
# End of macro DMARK
3ed8						CALLMONITOR 
3ed8 cd 84 17			call break_point_state  
3edb				endm  
# End of macro CALLMONITOR
3edb					endif 
3edb			 
3edb			 
3edb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3edb cd d8 1f			call macro_dsp_valuehl 
3ede				endm 
# End of macro FORTH_DSP_VALUEHL
3ede			 
3ede			;		push hl    ; u 
3ede					if DEBUG_FORTH_WORDS 
3ede						DMARK "SPA" 
3ede f5				push af  
3edf 3a f3 3e			ld a, (.dmark)  
3ee2 32 6e fb			ld (debug_mark),a  
3ee5 3a f4 3e			ld a, (.dmark+1)  
3ee8 32 6f fb			ld (debug_mark+1),a  
3eeb 3a f5 3e			ld a, (.dmark+2)  
3eee 32 70 fb			ld (debug_mark+2),a  
3ef1 18 03			jr .pastdmark  
3ef3 ..			.dmark: db "SPA"  
3ef6 f1			.pastdmark: pop af  
3ef7			endm  
# End of macro DMARK
3ef7						CALLMONITOR 
3ef7 cd 84 17			call break_point_state  
3efa				endm  
# End of macro CALLMONITOR
3efa					endif 
3efa			 
3efa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3efa cd 90 20			call macro_forth_dsp_pop 
3efd				endm 
# End of macro FORTH_DSP_POP
3efd			;		pop hl 
3efd 4d					ld c, l 
3efe 06 00				ld b, 0 
3f00 21 14 ee				ld hl, scratch  
3f03			 
3f03					if DEBUG_FORTH_WORDS 
3f03						DMARK "SP2" 
3f03 f5				push af  
3f04 3a 18 3f			ld a, (.dmark)  
3f07 32 6e fb			ld (debug_mark),a  
3f0a 3a 19 3f			ld a, (.dmark+1)  
3f0d 32 6f fb			ld (debug_mark+1),a  
3f10 3a 1a 3f			ld a, (.dmark+2)  
3f13 32 70 fb			ld (debug_mark+2),a  
3f16 18 03			jr .pastdmark  
3f18 ..			.dmark: db "SP2"  
3f1b f1			.pastdmark: pop af  
3f1c			endm  
# End of macro DMARK
3f1c						CALLMONITOR 
3f1c cd 84 17			call break_point_state  
3f1f				endm  
# End of macro CALLMONITOR
3f1f					endif 
3f1f 3e 20				ld a, ' ' 
3f21 c5			.spaces1:	push bc 
3f22 77					ld (hl),a 
3f23 23					inc hl 
3f24 c1					pop bc 
3f25 10 fa				djnz .spaces1 
3f27 3e 00				ld a,0 
3f29 77					ld (hl),a 
3f2a 21 14 ee				ld hl, scratch 
3f2d					if DEBUG_FORTH_WORDS 
3f2d						DMARK "SP3" 
3f2d f5				push af  
3f2e 3a 42 3f			ld a, (.dmark)  
3f31 32 6e fb			ld (debug_mark),a  
3f34 3a 43 3f			ld a, (.dmark+1)  
3f37 32 6f fb			ld (debug_mark+1),a  
3f3a 3a 44 3f			ld a, (.dmark+2)  
3f3d 32 70 fb			ld (debug_mark+2),a  
3f40 18 03			jr .pastdmark  
3f42 ..			.dmark: db "SP3"  
3f45 f1			.pastdmark: pop af  
3f46			endm  
# End of macro DMARK
3f46						CALLMONITOR 
3f46 cd 84 17			call break_point_state  
3f49				endm  
# End of macro CALLMONITOR
3f49					endif 
3f49 cd 4a 1f				call forth_apush 
3f4c			 
3f4c				       NEXTW 
3f4c c3 4a 21			jp macro_next 
3f4f				endm 
# End of macro NEXTW
3f4f			 
3f4f			 
3f4f			 
3f4f			.SCROLL: 
3f4f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3f4f 53				db WORD_SYS_CORE+63             
3f50 7c 3f			dw .SCROLLD            
3f52 07				db 6 + 1 
3f53 .. 00			db "SCROLL",0              
3f5a				endm 
# End of macro CWHEAD
3f5a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3f5a					if DEBUG_FORTH_WORDS_KEY 
3f5a						DMARK "SCR" 
3f5a f5				push af  
3f5b 3a 6f 3f			ld a, (.dmark)  
3f5e 32 6e fb			ld (debug_mark),a  
3f61 3a 70 3f			ld a, (.dmark+1)  
3f64 32 6f fb			ld (debug_mark+1),a  
3f67 3a 71 3f			ld a, (.dmark+2)  
3f6a 32 70 fb			ld (debug_mark+2),a  
3f6d 18 03			jr .pastdmark  
3f6f ..			.dmark: db "SCR"  
3f72 f1			.pastdmark: pop af  
3f73			endm  
# End of macro DMARK
3f73						CALLMONITOR 
3f73 cd 84 17			call break_point_state  
3f76				endm  
# End of macro CALLMONITOR
3f76					endif 
3f76			 
3f76 cd 6b 0b			call scroll_up 
3f79			;	call update_display 
3f79			 
3f79					NEXTW 
3f79 c3 4a 21			jp macro_next 
3f7c				endm 
# End of macro NEXTW
3f7c			 
3f7c			 
3f7c			 
3f7c			;		; get dir 
3f7c			; 
3f7c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f7c			; 
3f7c			;		push hl 
3f7c			; 
3f7c			;		; destroy value TOS 
3f7c			; 
3f7c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7c			; 
3f7c			;		; get count 
3f7c			; 
3f7c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f7c			; 
3f7c			;		push hl 
3f7c			; 
3f7c			;		; destroy value TOS 
3f7c			; 
3f7c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7c			; 
3f7c			;		; one value on hl get other one back 
3f7c			; 
3f7c			;		pop bc    ; count 
3f7c			; 
3f7c			;		pop de   ; dir 
3f7c			; 
3f7c			; 
3f7c			;		ld b, c 
3f7c			; 
3f7c			;.scrolldir:     push bc 
3f7c			;		push de 
3f7c			; 
3f7c			;		ld a, 0 
3f7c			;		cp e 
3f7c			;		jr z, .scrollup  
3f7c			;		call scroll_down 
3f7c			;		jr .scrollnext 
3f7c			;.scrollup:	call scroll_up 
3f7c			; 
3f7c			;		 
3f7c			;.scrollnext: 
3f7c			;		pop de 
3f7c			;		pop bc 
3f7c			;		djnz .scrolldir 
3f7c			; 
3f7c			; 
3f7c			; 
3f7c			; 
3f7c			; 
3f7c			;		NEXTW 
3f7c			 
3f7c			.SCROLLD: 
3f7c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3f7c 53				db WORD_SYS_CORE+63             
3f7d aa 3f			dw .ATQ            
3f7f 08				db 7 + 1 
3f80 .. 00			db "SCROLLD",0              
3f88				endm 
# End of macro CWHEAD
3f88			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3f88					if DEBUG_FORTH_WORDS_KEY 
3f88						DMARK "SCD" 
3f88 f5				push af  
3f89 3a 9d 3f			ld a, (.dmark)  
3f8c 32 6e fb			ld (debug_mark),a  
3f8f 3a 9e 3f			ld a, (.dmark+1)  
3f92 32 6f fb			ld (debug_mark+1),a  
3f95 3a 9f 3f			ld a, (.dmark+2)  
3f98 32 70 fb			ld (debug_mark+2),a  
3f9b 18 03			jr .pastdmark  
3f9d ..			.dmark: db "SCD"  
3fa0 f1			.pastdmark: pop af  
3fa1			endm  
# End of macro DMARK
3fa1						CALLMONITOR 
3fa1 cd 84 17			call break_point_state  
3fa4				endm  
# End of macro CALLMONITOR
3fa4					endif 
3fa4			 
3fa4 cd 8f 0b			call scroll_down 
3fa7			;	call update_display 
3fa7			 
3fa7					NEXTW 
3fa7 c3 4a 21			jp macro_next 
3faa				endm 
# End of macro NEXTW
3faa			 
3faa			 
3faa			.ATQ: 
3faa				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3faa 62				db WORD_SYS_CORE+78             
3fab 08 40			dw .AUTODSP            
3fad 04				db 3 + 1 
3fae .. 00			db "AT@",0              
3fb2				endm 
# End of macro CWHEAD
3fb2			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3fb2					if DEBUG_FORTH_WORDS_KEY 
3fb2						DMARK "ATA" 
3fb2 f5				push af  
3fb3 3a c7 3f			ld a, (.dmark)  
3fb6 32 6e fb			ld (debug_mark),a  
3fb9 3a c8 3f			ld a, (.dmark+1)  
3fbc 32 6f fb			ld (debug_mark+1),a  
3fbf 3a c9 3f			ld a, (.dmark+2)  
3fc2 32 70 fb			ld (debug_mark+2),a  
3fc5 18 03			jr .pastdmark  
3fc7 ..			.dmark: db "ATA"  
3fca f1			.pastdmark: pop af  
3fcb			endm  
# End of macro DMARK
3fcb						CALLMONITOR 
3fcb cd 84 17			call break_point_state  
3fce				endm  
# End of macro CALLMONITOR
3fce					endif 
3fce			 
3fce			 
3fce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fce cd d8 1f			call macro_dsp_valuehl 
3fd1				endm 
# End of macro FORTH_DSP_VALUEHL
3fd1			 
3fd1					; TODO save cursor row 
3fd1 7d					ld a,l 
3fd2 fe 02				cp 2 
3fd4 20 04				jr nz, .crow3aq 
3fd6 3e 28				ld a, display_row_2 
3fd8 18 12				jr .ccol1aq 
3fda fe 03		.crow3aq:		cp 3 
3fdc 20 04				jr nz, .crow4aq 
3fde 3e 50				ld a, display_row_3 
3fe0 18 0a				jr .ccol1aq 
3fe2 fe 04		.crow4aq:		cp 4 
3fe4 20 04				jr nz, .crow1aq 
3fe6 3e 78				ld a, display_row_4 
3fe8 18 02				jr .ccol1aq 
3fea 3e 00		.crow1aq:		ld a,display_row_1 
3fec f5			.ccol1aq:		push af			; got row offset 
3fed 6f					ld l,a 
3fee 26 00				ld h,0 
3ff0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff0 cd 90 20			call macro_forth_dsp_pop 
3ff3				endm 
# End of macro FORTH_DSP_POP
3ff3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff3 cd d8 1f			call macro_dsp_valuehl 
3ff6				endm 
# End of macro FORTH_DSP_VALUEHL
3ff6					; TODO save cursor col 
3ff6 f1					pop af 
3ff7 85					add l		; add col offset 
3ff8			 
3ff8					; add current frame buffer address 
3ff8 2a cf f8				ld hl, (display_fb_active) 
3ffb cd dd 0d				call addatohl 
3ffe			 
3ffe			 
3ffe			 
3ffe			 
3ffe					; get char frame buffer location offset in hl 
3ffe			 
3ffe 7e					ld a,(hl) 
3fff 26 00				ld h, 0 
4001 6f					ld l, a 
4002			 
4002 cd e1 1d				call forth_push_numhl 
4005			 
4005			 
4005					NEXTW 
4005 c3 4a 21			jp macro_next 
4008				endm 
# End of macro NEXTW
4008			 
4008			.AUTODSP: 
4008				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4008 63				db WORD_SYS_CORE+79             
4009 1e 40			dw .MENU            
400b 05				db 4 + 1 
400c .. 00			db "ADSP",0              
4011				endm 
# End of macro CWHEAD
4011			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4011			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4011			 
4011					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4011 cd d8 1f			call macro_dsp_valuehl 
4014				endm 
# End of macro FORTH_DSP_VALUEHL
4014			 
4014			;		push hl 
4014			 
4014					; destroy value TOS 
4014			 
4014					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4014 cd 90 20			call macro_forth_dsp_pop 
4017				endm 
# End of macro FORTH_DSP_POP
4017			 
4017			;		pop hl 
4017			 
4017 7d					ld a,l 
4018 32 1b f8				ld (cli_autodisplay), a 
401b				       NEXTW 
401b c3 4a 21			jp macro_next 
401e				endm 
# End of macro NEXTW
401e			 
401e			.MENU: 
401e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
401e 70				db WORD_SYS_CORE+92             
401f c7 40			dw .ENDDISPLAY            
4021 05				db 4 + 1 
4022 .. 00			db "MENU",0              
4027				endm 
# End of macro CWHEAD
4027			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4027			 
4027			;		; get number of items on the stack 
4027			; 
4027				 
4027					FORTH_DSP_VALUEHL 
4027 cd d8 1f			call macro_dsp_valuehl 
402a				endm 
# End of macro FORTH_DSP_VALUEHL
402a				 
402a					if DEBUG_FORTH_WORDS_KEY 
402a						DMARK "MNU" 
402a f5				push af  
402b 3a 3f 40			ld a, (.dmark)  
402e 32 6e fb			ld (debug_mark),a  
4031 3a 40 40			ld a, (.dmark+1)  
4034 32 6f fb			ld (debug_mark+1),a  
4037 3a 41 40			ld a, (.dmark+2)  
403a 32 70 fb			ld (debug_mark+2),a  
403d 18 03			jr .pastdmark  
403f ..			.dmark: db "MNU"  
4042 f1			.pastdmark: pop af  
4043			endm  
# End of macro DMARK
4043						CALLMONITOR 
4043 cd 84 17			call break_point_state  
4046				endm  
# End of macro CALLMONITOR
4046					endif 
4046			 
4046 45					ld b, l	 
4047 05					dec b 
4048			 
4048					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4048 cd 90 20			call macro_forth_dsp_pop 
404b				endm 
# End of macro FORTH_DSP_POP
404b			 
404b			 
404b					; go directly through the stack to pluck out the string pointers and build an array 
404b			 
404b			;		FORTH_DSP 
404b			 
404b					; hl contains top most stack item 
404b				 
404b 11 14 ee				ld de, scratch 
404e			 
404e			.mbuild: 
404e			 
404e					FORTH_DSP_VALUEHL 
404e cd d8 1f			call macro_dsp_valuehl 
4051				endm 
# End of macro FORTH_DSP_VALUEHL
4051			 
4051					if DEBUG_FORTH_WORDS 
4051						DMARK "MN3" 
4051 f5				push af  
4052 3a 66 40			ld a, (.dmark)  
4055 32 6e fb			ld (debug_mark),a  
4058 3a 67 40			ld a, (.dmark+1)  
405b 32 6f fb			ld (debug_mark+1),a  
405e 3a 68 40			ld a, (.dmark+2)  
4061 32 70 fb			ld (debug_mark+2),a  
4064 18 03			jr .pastdmark  
4066 ..			.dmark: db "MN3"  
4069 f1			.pastdmark: pop af  
406a			endm  
# End of macro DMARK
406a						CALLMONITOR 
406a cd 84 17			call break_point_state  
406d				endm  
# End of macro CALLMONITOR
406d					endif 
406d eb					ex de, hl 
406e 73					ld (hl), e 
406f 23					inc hl 
4070 72					ld (hl), d 
4071 23					inc hl 
4072 eb					ex de, hl 
4073			 
4073					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4073 cd 90 20			call macro_forth_dsp_pop 
4076				endm 
# End of macro FORTH_DSP_POP
4076			 
4076 10 d6				djnz .mbuild 
4078			 
4078					; done add term 
4078			 
4078 eb					ex de, hl 
4079 36 00				ld (hl), 0 
407b 23					inc hl 
407c 36 00				ld (hl), 0 
407e			 
407e				 
407e					 
407e 21 14 ee				ld hl, scratch 
4081			 
4081					if DEBUG_FORTH_WORDS 
4081						DMARK "MNx" 
4081 f5				push af  
4082 3a 96 40			ld a, (.dmark)  
4085 32 6e fb			ld (debug_mark),a  
4088 3a 97 40			ld a, (.dmark+1)  
408b 32 6f fb			ld (debug_mark+1),a  
408e 3a 98 40			ld a, (.dmark+2)  
4091 32 70 fb			ld (debug_mark+2),a  
4094 18 03			jr .pastdmark  
4096 ..			.dmark: db "MNx"  
4099 f1			.pastdmark: pop af  
409a			endm  
# End of macro DMARK
409a						CALLMONITOR 
409a cd 84 17			call break_point_state  
409d				endm  
# End of macro CALLMONITOR
409d					endif 
409d			 
409d			 
409d			 
409d 3e 00				ld a, 0 
409f cd da 0b				call menu 
40a2			 
40a2			 
40a2 6f					ld l, a 
40a3 26 00				ld h, 0 
40a5			 
40a5					if DEBUG_FORTH_WORDS 
40a5						DMARK "MNr" 
40a5 f5				push af  
40a6 3a ba 40			ld a, (.dmark)  
40a9 32 6e fb			ld (debug_mark),a  
40ac 3a bb 40			ld a, (.dmark+1)  
40af 32 6f fb			ld (debug_mark+1),a  
40b2 3a bc 40			ld a, (.dmark+2)  
40b5 32 70 fb			ld (debug_mark+2),a  
40b8 18 03			jr .pastdmark  
40ba ..			.dmark: db "MNr"  
40bd f1			.pastdmark: pop af  
40be			endm  
# End of macro DMARK
40be						CALLMONITOR 
40be cd 84 17			call break_point_state  
40c1				endm  
# End of macro CALLMONITOR
40c1					endif 
40c1			 
40c1 cd e1 1d				call forth_push_numhl 
40c4			 
40c4			 
40c4			 
40c4			 
40c4				       NEXTW 
40c4 c3 4a 21			jp macro_next 
40c7				endm 
# End of macro NEXTW
40c7			 
40c7			 
40c7			.ENDDISPLAY: 
40c7			 
40c7			; eof 
# End of file forth_words_display.asm
40c7			include "forth_words_str.asm" 
40c7			 
40c7			; | ## String Words 
40c7			 
40c7			.PTR:   
40c7			 
40c7				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
40c7 48				db WORD_SYS_CORE+52             
40c8 f4 40			dw .STYPE            
40ca 04				db 3 + 1 
40cb .. 00			db "PTR",0              
40cf				endm 
# End of macro CWHEAD
40cf			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
40cf			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
40cf			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
40cf			 
40cf					if DEBUG_FORTH_WORDS_KEY 
40cf						DMARK "PTR" 
40cf f5				push af  
40d0 3a e4 40			ld a, (.dmark)  
40d3 32 6e fb			ld (debug_mark),a  
40d6 3a e5 40			ld a, (.dmark+1)  
40d9 32 6f fb			ld (debug_mark+1),a  
40dc 3a e6 40			ld a, (.dmark+2)  
40df 32 70 fb			ld (debug_mark+2),a  
40e2 18 03			jr .pastdmark  
40e4 ..			.dmark: db "PTR"  
40e7 f1			.pastdmark: pop af  
40e8			endm  
# End of macro DMARK
40e8						CALLMONITOR 
40e8 cd 84 17			call break_point_state  
40eb				endm  
# End of macro CALLMONITOR
40eb					endif 
40eb					FORTH_DSP_VALUEHL 
40eb cd d8 1f			call macro_dsp_valuehl 
40ee				endm 
# End of macro FORTH_DSP_VALUEHL
40ee cd e1 1d				call forth_push_numhl 
40f1			 
40f1			 
40f1					NEXTW 
40f1 c3 4a 21			jp macro_next 
40f4				endm 
# End of macro NEXTW
40f4			.STYPE: 
40f4				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
40f4 48				db WORD_SYS_CORE+52             
40f5 43 41			dw .UPPER            
40f7 06				db 5 + 1 
40f8 .. 00			db "STYPE",0              
40fe				endm 
# End of macro CWHEAD
40fe			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
40fe					if DEBUG_FORTH_WORDS_KEY 
40fe						DMARK "STY" 
40fe f5				push af  
40ff 3a 13 41			ld a, (.dmark)  
4102 32 6e fb			ld (debug_mark),a  
4105 3a 14 41			ld a, (.dmark+1)  
4108 32 6f fb			ld (debug_mark+1),a  
410b 3a 15 41			ld a, (.dmark+2)  
410e 32 70 fb			ld (debug_mark+2),a  
4111 18 03			jr .pastdmark  
4113 ..			.dmark: db "STY"  
4116 f1			.pastdmark: pop af  
4117			endm  
# End of macro DMARK
4117						CALLMONITOR 
4117 cd 84 17			call break_point_state  
411a				endm  
# End of macro CALLMONITOR
411a					endif 
411a					FORTH_DSP 
411a cd 9e 1f			call macro_forth_dsp 
411d				endm 
# End of macro FORTH_DSP
411d					;v5 FORTH_DSP_VALUE 
411d			 
411d 7e					ld a, (hl) 
411e			 
411e f5					push af 
411f			 
411f			; Dont destroy TOS		FORTH_DSP_POP 
411f			 
411f f1					pop af 
4120			 
4120 fe 01				cp DS_TYPE_STR 
4122 28 09				jr z, .typestr 
4124			 
4124 fe 02				cp DS_TYPE_INUM 
4126 28 0a				jr z, .typeinum 
4128			 
4128 21 41 41				ld hl, .tna 
412b 18 0a				jr .tpush 
412d			 
412d 21 3d 41		.typestr:	ld hl, .tstr 
4130 18 05				jr .tpush 
4132 21 3f 41		.typeinum:	ld hl, .tinum 
4135 18 00				jr .tpush 
4137			 
4137			.tpush: 
4137			 
4137 cd 4f 1e				call forth_push_str 
413a			 
413a					NEXTW 
413a c3 4a 21			jp macro_next 
413d				endm 
# End of macro NEXTW
413d .. 00		.tstr:	db "s",0 
413f .. 00		.tinum:  db "i",0 
4141 .. 00		.tna:   db "?", 0 
4143			 
4143			 
4143			.UPPER: 
4143				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4143 48				db WORD_SYS_CORE+52             
4144 7e 41			dw .LOWER            
4146 06				db 5 + 1 
4147 .. 00			db "UPPER",0              
414d				endm 
# End of macro CWHEAD
414d			; | UPPER ( s -- s ) Upper case string s  | DONE 
414d					if DEBUG_FORTH_WORDS_KEY 
414d						DMARK "UPR" 
414d f5				push af  
414e 3a 62 41			ld a, (.dmark)  
4151 32 6e fb			ld (debug_mark),a  
4154 3a 63 41			ld a, (.dmark+1)  
4157 32 6f fb			ld (debug_mark+1),a  
415a 3a 64 41			ld a, (.dmark+2)  
415d 32 70 fb			ld (debug_mark+2),a  
4160 18 03			jr .pastdmark  
4162 ..			.dmark: db "UPR"  
4165 f1			.pastdmark: pop af  
4166			endm  
# End of macro DMARK
4166						CALLMONITOR 
4166 cd 84 17			call break_point_state  
4169				endm  
# End of macro CALLMONITOR
4169					endif 
4169			 
4169					FORTH_DSP 
4169 cd 9e 1f			call macro_forth_dsp 
416c				endm 
# End of macro FORTH_DSP
416c					 
416c			; TODO check is string type 
416c			 
416c					FORTH_DSP_VALUEHL 
416c cd d8 1f			call macro_dsp_valuehl 
416f				endm 
# End of macro FORTH_DSP_VALUEHL
416f			; get pointer to string in hl 
416f			 
416f 7e			.toup:		ld a, (hl) 
4170 fe 00				cp 0 
4172 28 07				jr z, .toupdone 
4174			 
4174 cd 4a 11				call to_upper 
4177			 
4177 77					ld (hl), a 
4178 23					inc hl 
4179 18 f4				jr .toup 
417b			 
417b					 
417b			 
417b			 
417b			; for each char convert to upper 
417b					 
417b			.toupdone: 
417b			 
417b			 
417b					NEXTW 
417b c3 4a 21			jp macro_next 
417e				endm 
# End of macro NEXTW
417e			.LOWER: 
417e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
417e 48				db WORD_SYS_CORE+52             
417f b9 41			dw .TCASE            
4181 06				db 5 + 1 
4182 .. 00			db "LOWER",0              
4188				endm 
# End of macro CWHEAD
4188			; | LOWER ( s -- s ) Lower case string s  | DONE 
4188					if DEBUG_FORTH_WORDS_KEY 
4188						DMARK "LWR" 
4188 f5				push af  
4189 3a 9d 41			ld a, (.dmark)  
418c 32 6e fb			ld (debug_mark),a  
418f 3a 9e 41			ld a, (.dmark+1)  
4192 32 6f fb			ld (debug_mark+1),a  
4195 3a 9f 41			ld a, (.dmark+2)  
4198 32 70 fb			ld (debug_mark+2),a  
419b 18 03			jr .pastdmark  
419d ..			.dmark: db "LWR"  
41a0 f1			.pastdmark: pop af  
41a1			endm  
# End of macro DMARK
41a1						CALLMONITOR 
41a1 cd 84 17			call break_point_state  
41a4				endm  
# End of macro CALLMONITOR
41a4					endif 
41a4			 
41a4					FORTH_DSP 
41a4 cd 9e 1f			call macro_forth_dsp 
41a7				endm 
# End of macro FORTH_DSP
41a7					 
41a7			; TODO check is string type 
41a7			 
41a7					FORTH_DSP_VALUEHL 
41a7 cd d8 1f			call macro_dsp_valuehl 
41aa				endm 
# End of macro FORTH_DSP_VALUEHL
41aa			; get pointer to string in hl 
41aa			 
41aa 7e			.tolow:		ld a, (hl) 
41ab fe 00				cp 0 
41ad 28 07				jr z, .tolowdone 
41af			 
41af cd 53 11				call to_lower 
41b2			 
41b2 77					ld (hl), a 
41b3 23					inc hl 
41b4 18 f4				jr .tolow 
41b6			 
41b6					 
41b6			 
41b6			 
41b6			; for each char convert to low 
41b6					 
41b6			.tolowdone: 
41b6					NEXTW 
41b6 c3 4a 21			jp macro_next 
41b9				endm 
# End of macro NEXTW
41b9			.TCASE: 
41b9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
41b9 48				db WORD_SYS_CORE+52             
41ba ef 42			dw .SUBSTR            
41bc 06				db 5 + 1 
41bd .. 00			db "TCASE",0              
41c3				endm 
# End of macro CWHEAD
41c3			; | TCASE ( s -- s ) Title case string s  | DONE 
41c3					if DEBUG_FORTH_WORDS_KEY 
41c3						DMARK "TCS" 
41c3 f5				push af  
41c4 3a d8 41			ld a, (.dmark)  
41c7 32 6e fb			ld (debug_mark),a  
41ca 3a d9 41			ld a, (.dmark+1)  
41cd 32 6f fb			ld (debug_mark+1),a  
41d0 3a da 41			ld a, (.dmark+2)  
41d3 32 70 fb			ld (debug_mark+2),a  
41d6 18 03			jr .pastdmark  
41d8 ..			.dmark: db "TCS"  
41db f1			.pastdmark: pop af  
41dc			endm  
# End of macro DMARK
41dc						CALLMONITOR 
41dc cd 84 17			call break_point_state  
41df				endm  
# End of macro CALLMONITOR
41df					endif 
41df			 
41df					FORTH_DSP 
41df cd 9e 1f			call macro_forth_dsp 
41e2				endm 
# End of macro FORTH_DSP
41e2					 
41e2			; TODO check is string type 
41e2			 
41e2					FORTH_DSP_VALUEHL 
41e2 cd d8 1f			call macro_dsp_valuehl 
41e5				endm 
# End of macro FORTH_DSP_VALUEHL
41e5			; get pointer to string in hl 
41e5			 
41e5					if DEBUG_FORTH_WORDS 
41e5						DMARK "TC1" 
41e5 f5				push af  
41e6 3a fa 41			ld a, (.dmark)  
41e9 32 6e fb			ld (debug_mark),a  
41ec 3a fb 41			ld a, (.dmark+1)  
41ef 32 6f fb			ld (debug_mark+1),a  
41f2 3a fc 41			ld a, (.dmark+2)  
41f5 32 70 fb			ld (debug_mark+2),a  
41f8 18 03			jr .pastdmark  
41fa ..			.dmark: db "TC1"  
41fd f1			.pastdmark: pop af  
41fe			endm  
# End of macro DMARK
41fe						CALLMONITOR 
41fe cd 84 17			call break_point_state  
4201				endm  
# End of macro CALLMONITOR
4201					endif 
4201			 
4201					; first time in turn to upper case first char 
4201			 
4201 7e					ld a, (hl) 
4202 c3 8c 42				jp .totsiptou 
4205			 
4205			 
4205 7e			.tot:		ld a, (hl) 
4206 fe 00				cp 0 
4208 ca d0 42				jp z, .totdone 
420b			 
420b					if DEBUG_FORTH_WORDS 
420b						DMARK "TC2" 
420b f5				push af  
420c 3a 20 42			ld a, (.dmark)  
420f 32 6e fb			ld (debug_mark),a  
4212 3a 21 42			ld a, (.dmark+1)  
4215 32 6f fb			ld (debug_mark+1),a  
4218 3a 22 42			ld a, (.dmark+2)  
421b 32 70 fb			ld (debug_mark+2),a  
421e 18 03			jr .pastdmark  
4220 ..			.dmark: db "TC2"  
4223 f1			.pastdmark: pop af  
4224			endm  
# End of macro DMARK
4224						CALLMONITOR 
4224 cd 84 17			call break_point_state  
4227				endm  
# End of macro CALLMONITOR
4227					endif 
4227					; check to see if current char is a space 
4227			 
4227 fe 20				cp ' ' 
4229 28 21				jr z, .totsp 
422b cd 53 11				call to_lower 
422e					if DEBUG_FORTH_WORDS 
422e						DMARK "TC3" 
422e f5				push af  
422f 3a 43 42			ld a, (.dmark)  
4232 32 6e fb			ld (debug_mark),a  
4235 3a 44 42			ld a, (.dmark+1)  
4238 32 6f fb			ld (debug_mark+1),a  
423b 3a 45 42			ld a, (.dmark+2)  
423e 32 70 fb			ld (debug_mark+2),a  
4241 18 03			jr .pastdmark  
4243 ..			.dmark: db "TC3"  
4246 f1			.pastdmark: pop af  
4247			endm  
# End of macro DMARK
4247						CALLMONITOR 
4247 cd 84 17			call break_point_state  
424a				endm  
# End of macro CALLMONITOR
424a					endif 
424a 18 63				jr .totnxt 
424c			 
424c			.totsp:         ; on a space, find next char which should be upper 
424c			 
424c					if DEBUG_FORTH_WORDS 
424c						DMARK "TC4" 
424c f5				push af  
424d 3a 61 42			ld a, (.dmark)  
4250 32 6e fb			ld (debug_mark),a  
4253 3a 62 42			ld a, (.dmark+1)  
4256 32 6f fb			ld (debug_mark+1),a  
4259 3a 63 42			ld a, (.dmark+2)  
425c 32 70 fb			ld (debug_mark+2),a  
425f 18 03			jr .pastdmark  
4261 ..			.dmark: db "TC4"  
4264 f1			.pastdmark: pop af  
4265			endm  
# End of macro DMARK
4265						CALLMONITOR 
4265 cd 84 17			call break_point_state  
4268				endm  
# End of macro CALLMONITOR
4268					endif 
4268					;; 
4268			 
4268 fe 20				cp ' ' 
426a 20 20				jr nz, .totsiptou 
426c 23					inc hl 
426d 7e					ld a, (hl) 
426e					if DEBUG_FORTH_WORDS 
426e						DMARK "TC5" 
426e f5				push af  
426f 3a 83 42			ld a, (.dmark)  
4272 32 6e fb			ld (debug_mark),a  
4275 3a 84 42			ld a, (.dmark+1)  
4278 32 6f fb			ld (debug_mark+1),a  
427b 3a 85 42			ld a, (.dmark+2)  
427e 32 70 fb			ld (debug_mark+2),a  
4281 18 03			jr .pastdmark  
4283 ..			.dmark: db "TC5"  
4286 f1			.pastdmark: pop af  
4287			endm  
# End of macro DMARK
4287						CALLMONITOR 
4287 cd 84 17			call break_point_state  
428a				endm  
# End of macro CALLMONITOR
428a					endif 
428a 18 c0				jr .totsp 
428c fe 00		.totsiptou:    cp 0 
428e 28 40				jr z, .totdone 
4290					; not space and not zero term so upper case it 
4290 cd 4a 11				call to_upper 
4293			 
4293					if DEBUG_FORTH_WORDS 
4293						DMARK "TC6" 
4293 f5				push af  
4294 3a a8 42			ld a, (.dmark)  
4297 32 6e fb			ld (debug_mark),a  
429a 3a a9 42			ld a, (.dmark+1)  
429d 32 6f fb			ld (debug_mark+1),a  
42a0 3a aa 42			ld a, (.dmark+2)  
42a3 32 70 fb			ld (debug_mark+2),a  
42a6 18 03			jr .pastdmark  
42a8 ..			.dmark: db "TC6"  
42ab f1			.pastdmark: pop af  
42ac			endm  
# End of macro DMARK
42ac						CALLMONITOR 
42ac cd 84 17			call break_point_state  
42af				endm  
# End of macro CALLMONITOR
42af					endif 
42af			 
42af			 
42af			.totnxt: 
42af			 
42af 77					ld (hl), a 
42b0 23					inc hl 
42b1					if DEBUG_FORTH_WORDS 
42b1						DMARK "TC7" 
42b1 f5				push af  
42b2 3a c6 42			ld a, (.dmark)  
42b5 32 6e fb			ld (debug_mark),a  
42b8 3a c7 42			ld a, (.dmark+1)  
42bb 32 6f fb			ld (debug_mark+1),a  
42be 3a c8 42			ld a, (.dmark+2)  
42c1 32 70 fb			ld (debug_mark+2),a  
42c4 18 03			jr .pastdmark  
42c6 ..			.dmark: db "TC7"  
42c9 f1			.pastdmark: pop af  
42ca			endm  
# End of macro DMARK
42ca						CALLMONITOR 
42ca cd 84 17			call break_point_state  
42cd				endm  
# End of macro CALLMONITOR
42cd					endif 
42cd c3 05 42				jp .tot 
42d0			 
42d0					 
42d0			 
42d0			 
42d0			; for each char convert to low 
42d0					 
42d0			.totdone: 
42d0					if DEBUG_FORTH_WORDS 
42d0						DMARK "TCd" 
42d0 f5				push af  
42d1 3a e5 42			ld a, (.dmark)  
42d4 32 6e fb			ld (debug_mark),a  
42d7 3a e6 42			ld a, (.dmark+1)  
42da 32 6f fb			ld (debug_mark+1),a  
42dd 3a e7 42			ld a, (.dmark+2)  
42e0 32 70 fb			ld (debug_mark+2),a  
42e3 18 03			jr .pastdmark  
42e5 ..			.dmark: db "TCd"  
42e8 f1			.pastdmark: pop af  
42e9			endm  
# End of macro DMARK
42e9						CALLMONITOR 
42e9 cd 84 17			call break_point_state  
42ec				endm  
# End of macro CALLMONITOR
42ec					endif 
42ec					NEXTW 
42ec c3 4a 21			jp macro_next 
42ef				endm 
# End of macro NEXTW
42ef			 
42ef			.SUBSTR: 
42ef				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
42ef 48				db WORD_SYS_CORE+52             
42f0 4d 43			dw .LEFT            
42f2 07				db 6 + 1 
42f3 .. 00			db "SUBSTR",0              
42fa				endm 
# End of macro CWHEAD
42fa			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
42fa			 
42fa					if DEBUG_FORTH_WORDS_KEY 
42fa						DMARK "SST" 
42fa f5				push af  
42fb 3a 0f 43			ld a, (.dmark)  
42fe 32 6e fb			ld (debug_mark),a  
4301 3a 10 43			ld a, (.dmark+1)  
4304 32 6f fb			ld (debug_mark+1),a  
4307 3a 11 43			ld a, (.dmark+2)  
430a 32 70 fb			ld (debug_mark+2),a  
430d 18 03			jr .pastdmark  
430f ..			.dmark: db "SST"  
4312 f1			.pastdmark: pop af  
4313			endm  
# End of macro DMARK
4313						CALLMONITOR 
4313 cd 84 17			call break_point_state  
4316				endm  
# End of macro CALLMONITOR
4316					endif 
4316			; TODO check string type 
4316					FORTH_DSP_VALUEHL 
4316 cd d8 1f			call macro_dsp_valuehl 
4319				endm 
# End of macro FORTH_DSP_VALUEHL
4319			 
4319 e5					push hl      ; string length 
431a			 
431a					FORTH_DSP_POP 
431a cd 90 20			call macro_forth_dsp_pop 
431d				endm 
# End of macro FORTH_DSP_POP
431d			 
431d					FORTH_DSP_VALUEHL 
431d cd d8 1f			call macro_dsp_valuehl 
4320				endm 
# End of macro FORTH_DSP_VALUEHL
4320			 
4320 e5					push hl     ; start char 
4321			 
4321					FORTH_DSP_POP 
4321 cd 90 20			call macro_forth_dsp_pop 
4324				endm 
# End of macro FORTH_DSP_POP
4324			 
4324			 
4324					FORTH_DSP_VALUE 
4324 cd c1 1f			call macro_forth_dsp_value 
4327				endm 
# End of macro FORTH_DSP_VALUE
4327			 
4327 d1					pop de    ; get start post offset 
4328			 
4328 19					add hl, de    ; starting offset 
4329			 
4329 c1					pop bc 
432a c5					push bc      ; grab size of string 
432b			 
432b e5					push hl    ; save string start  
432c			 
432c 26 00				ld h, 0 
432e 69					ld l, c 
432f 23					inc hl 
4330 23					inc hl 
4331			 
4331 cd a4 12				call malloc 
4334				if DEBUG_FORTH_MALLOC_GUARD 
4334 cc c8 53				call z,malloc_error 
4337				endif 
4337			 
4337 eb					ex de, hl      ; save malloc area for string copy 
4338 e1					pop hl    ; get back source 
4339 c1					pop bc    ; get length of string back 
433a			 
433a d5					push de    ; save malloc area for after we push 
433b ed b0				ldir     ; copy substr 
433d			 
433d			 
433d eb					ex de, hl 
433e 3e 00				ld a, 0 
4340 77					ld (hl), a   ; term substr 
4341			 
4341					 
4341 e1					pop hl    ; get malloc so we can push it 
4342 e5					push hl   ; save so we can free it afterwards 
4343			 
4343 cd 4f 1e				call forth_push_str 
4346			 
4346 e1					pop hl 
4347 cd 6e 13				call free 
434a			 
434a					 
434a					 
434a			 
434a			 
434a					NEXTW 
434a c3 4a 21			jp macro_next 
434d				endm 
# End of macro NEXTW
434d			 
434d			.LEFT: 
434d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
434d 48				db WORD_SYS_CORE+52             
434e 75 43			dw .RIGHT            
4350 05				db 4 + 1 
4351 .. 00			db "LEFT",0              
4356				endm 
# End of macro CWHEAD
4356			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4356					if DEBUG_FORTH_WORDS_KEY 
4356						DMARK "LEF" 
4356 f5				push af  
4357 3a 6b 43			ld a, (.dmark)  
435a 32 6e fb			ld (debug_mark),a  
435d 3a 6c 43			ld a, (.dmark+1)  
4360 32 6f fb			ld (debug_mark+1),a  
4363 3a 6d 43			ld a, (.dmark+2)  
4366 32 70 fb			ld (debug_mark+2),a  
4369 18 03			jr .pastdmark  
436b ..			.dmark: db "LEF"  
436e f1			.pastdmark: pop af  
436f			endm  
# End of macro DMARK
436f						CALLMONITOR 
436f cd 84 17			call break_point_state  
4372				endm  
# End of macro CALLMONITOR
4372					endif 
4372			 
4372					NEXTW 
4372 c3 4a 21			jp macro_next 
4375				endm 
# End of macro NEXTW
4375			.RIGHT: 
4375				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4375 48				db WORD_SYS_CORE+52             
4376 9e 43			dw .STR2NUM            
4378 06				db 5 + 1 
4379 .. 00			db "RIGHT",0              
437f				endm 
# End of macro CWHEAD
437f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
437f					if DEBUG_FORTH_WORDS_KEY 
437f						DMARK "RIG" 
437f f5				push af  
4380 3a 94 43			ld a, (.dmark)  
4383 32 6e fb			ld (debug_mark),a  
4386 3a 95 43			ld a, (.dmark+1)  
4389 32 6f fb			ld (debug_mark+1),a  
438c 3a 96 43			ld a, (.dmark+2)  
438f 32 70 fb			ld (debug_mark+2),a  
4392 18 03			jr .pastdmark  
4394 ..			.dmark: db "RIG"  
4397 f1			.pastdmark: pop af  
4398			endm  
# End of macro DMARK
4398						CALLMONITOR 
4398 cd 84 17			call break_point_state  
439b				endm  
# End of macro CALLMONITOR
439b					endif 
439b			 
439b					NEXTW 
439b c3 4a 21			jp macro_next 
439e				endm 
# End of macro NEXTW
439e			 
439e			 
439e			.STR2NUM: 
439e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
439e 48				db WORD_SYS_CORE+52             
439f 2a 44			dw .NUM2STR            
43a1 08				db 7 + 1 
43a2 .. 00			db "STR2NUM",0              
43aa				endm 
# End of macro CWHEAD
43aa			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
43aa			 
43aa			 
43aa			; TODO STR type check to do 
43aa					if DEBUG_FORTH_WORDS_KEY 
43aa						DMARK "S2N" 
43aa f5				push af  
43ab 3a bf 43			ld a, (.dmark)  
43ae 32 6e fb			ld (debug_mark),a  
43b1 3a c0 43			ld a, (.dmark+1)  
43b4 32 6f fb			ld (debug_mark+1),a  
43b7 3a c1 43			ld a, (.dmark+2)  
43ba 32 70 fb			ld (debug_mark+2),a  
43bd 18 03			jr .pastdmark  
43bf ..			.dmark: db "S2N"  
43c2 f1			.pastdmark: pop af  
43c3			endm  
# End of macro DMARK
43c3						CALLMONITOR 
43c3 cd 84 17			call break_point_state  
43c6				endm  
# End of macro CALLMONITOR
43c6					endif 
43c6			 
43c6					;FORTH_DSP 
43c6					FORTH_DSP_VALUE 
43c6 cd c1 1f			call macro_forth_dsp_value 
43c9				endm 
# End of macro FORTH_DSP_VALUE
43c9					;inc hl 
43c9			 
43c9 eb					ex de, hl 
43ca					if DEBUG_FORTH_WORDS 
43ca						DMARK "S2a" 
43ca f5				push af  
43cb 3a df 43			ld a, (.dmark)  
43ce 32 6e fb			ld (debug_mark),a  
43d1 3a e0 43			ld a, (.dmark+1)  
43d4 32 6f fb			ld (debug_mark+1),a  
43d7 3a e1 43			ld a, (.dmark+2)  
43da 32 70 fb			ld (debug_mark+2),a  
43dd 18 03			jr .pastdmark  
43df ..			.dmark: db "S2a"  
43e2 f1			.pastdmark: pop af  
43e3			endm  
# End of macro DMARK
43e3						CALLMONITOR 
43e3 cd 84 17			call break_point_state  
43e6				endm  
# End of macro CALLMONITOR
43e6					endif 
43e6 cd d2 11				call string_to_uint16 
43e9			 
43e9					if DEBUG_FORTH_WORDS 
43e9						DMARK "S2b" 
43e9 f5				push af  
43ea 3a fe 43			ld a, (.dmark)  
43ed 32 6e fb			ld (debug_mark),a  
43f0 3a ff 43			ld a, (.dmark+1)  
43f3 32 6f fb			ld (debug_mark+1),a  
43f6 3a 00 44			ld a, (.dmark+2)  
43f9 32 70 fb			ld (debug_mark+2),a  
43fc 18 03			jr .pastdmark  
43fe ..			.dmark: db "S2b"  
4401 f1			.pastdmark: pop af  
4402			endm  
# End of macro DMARK
4402						CALLMONITOR 
4402 cd 84 17			call break_point_state  
4405				endm  
# End of macro CALLMONITOR
4405					endif 
4405			;		push hl 
4405					FORTH_DSP_POP 
4405 cd 90 20			call macro_forth_dsp_pop 
4408				endm 
# End of macro FORTH_DSP_POP
4408			;		pop hl 
4408					 
4408					if DEBUG_FORTH_WORDS 
4408						DMARK "S2b" 
4408 f5				push af  
4409 3a 1d 44			ld a, (.dmark)  
440c 32 6e fb			ld (debug_mark),a  
440f 3a 1e 44			ld a, (.dmark+1)  
4412 32 6f fb			ld (debug_mark+1),a  
4415 3a 1f 44			ld a, (.dmark+2)  
4418 32 70 fb			ld (debug_mark+2),a  
441b 18 03			jr .pastdmark  
441d ..			.dmark: db "S2b"  
4420 f1			.pastdmark: pop af  
4421			endm  
# End of macro DMARK
4421						CALLMONITOR 
4421 cd 84 17			call break_point_state  
4424				endm  
# End of macro CALLMONITOR
4424					endif 
4424 cd e1 1d				call forth_push_numhl	 
4427			 
4427				 
4427				       NEXTW 
4427 c3 4a 21			jp macro_next 
442a				endm 
# End of macro NEXTW
442a			.NUM2STR: 
442a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
442a 48				db WORD_SYS_CORE+52             
442b 39 44			dw .CONCAT            
442d 08				db 7 + 1 
442e .. 00			db "NUM2STR",0              
4436				endm 
# End of macro CWHEAD
4436			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4436			 
4436			;		; malloc a string to target 
4436			;		ld hl, 10     ; TODO max string size should be fine 
4436			;		call malloc 
4436			;		push hl    ; save malloc location 
4436			; 
4436			; 
4436			;; TODO check int type 
4436			;		FORTH_DSP_VALUEHL 
4436			;		ld a, l 
4436			;		call DispAToASCII   
4436			;;TODO need to chage above call to dump into string 
4436			; 
4436			; 
4436			 
4436				       NEXTW 
4436 c3 4a 21			jp macro_next 
4439				endm 
# End of macro NEXTW
4439			 
4439			.CONCAT: 
4439				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4439 48				db WORD_SYS_CORE+52             
443a ec 44			dw .FIND            
443c 07				db 6 + 1 
443d .. 00			db "CONCAT",0              
4444				endm 
# End of macro CWHEAD
4444			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4444			 
4444			; TODO check string type 
4444			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4444			 
4444					if DEBUG_FORTH_WORDS_KEY 
4444						DMARK "CON" 
4444 f5				push af  
4445 3a 59 44			ld a, (.dmark)  
4448 32 6e fb			ld (debug_mark),a  
444b 3a 5a 44			ld a, (.dmark+1)  
444e 32 6f fb			ld (debug_mark+1),a  
4451 3a 5b 44			ld a, (.dmark+2)  
4454 32 70 fb			ld (debug_mark+2),a  
4457 18 03			jr .pastdmark  
4459 ..			.dmark: db "CON"  
445c f1			.pastdmark: pop af  
445d			endm  
# End of macro DMARK
445d						CALLMONITOR 
445d cd 84 17			call break_point_state  
4460				endm  
# End of macro CALLMONITOR
4460					endif 
4460			 
4460			 
4460					FORTH_DSP_VALUE 
4460 cd c1 1f			call macro_forth_dsp_value 
4463				endm 
# End of macro FORTH_DSP_VALUE
4463 e5					push hl   ; s2 
4464			 
4464					FORTH_DSP_POP 
4464 cd 90 20			call macro_forth_dsp_pop 
4467				endm 
# End of macro FORTH_DSP_POP
4467			 
4467					FORTH_DSP_VALUE 
4467 cd c1 1f			call macro_forth_dsp_value 
446a				endm 
# End of macro FORTH_DSP_VALUE
446a			 
446a e5					push hl   ; s1 
446b			 
446b					FORTH_DSP_POP 
446b cd 90 20			call macro_forth_dsp_pop 
446e				endm 
# End of macro FORTH_DSP_POP
446e					 
446e			 
446e					; copy s1 
446e			 
446e				 
446e					; save ptr 
446e e1					pop hl  
446f e5					push hl 
4470 3e 00				ld a, 0 
4472 cd 46 12				call strlent 
4475					;inc hl    ; zer0 
4475 06 00				ld b, 0 
4477 4d					ld c, l 
4478 e1					pop hl		 
4479 11 14 ee				ld de, scratch	 
447c					if DEBUG_FORTH_WORDS 
447c						DMARK "CO1" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 6e fb			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 6f fb			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 70 fb			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "CO1"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495						CALLMONITOR 
4495 cd 84 17			call break_point_state  
4498				endm  
# End of macro CALLMONITOR
4498					endif 
4498 ed b0				ldir 
449a			 
449a e1					pop hl 
449b e5					push hl 
449c d5					push de 
449d			 
449d			 
449d 3e 00				ld a, 0 
449f cd 46 12				call strlent 
44a2 23					inc hl    ; zer0 
44a3 23					inc hl 
44a4 06 00				ld b, 0 
44a6 4d					ld c, l 
44a7 d1					pop de 
44a8 e1					pop hl		 
44a9					if DEBUG_FORTH_WORDS 
44a9						DMARK "CO2" 
44a9 f5				push af  
44aa 3a be 44			ld a, (.dmark)  
44ad 32 6e fb			ld (debug_mark),a  
44b0 3a bf 44			ld a, (.dmark+1)  
44b3 32 6f fb			ld (debug_mark+1),a  
44b6 3a c0 44			ld a, (.dmark+2)  
44b9 32 70 fb			ld (debug_mark+2),a  
44bc 18 03			jr .pastdmark  
44be ..			.dmark: db "CO2"  
44c1 f1			.pastdmark: pop af  
44c2			endm  
# End of macro DMARK
44c2						CALLMONITOR 
44c2 cd 84 17			call break_point_state  
44c5				endm  
# End of macro CALLMONITOR
44c5					endif 
44c5 ed b0				ldir 
44c7			 
44c7			 
44c7			 
44c7 21 14 ee				ld hl, scratch 
44ca					if DEBUG_FORTH_WORDS 
44ca						DMARK "CO5" 
44ca f5				push af  
44cb 3a df 44			ld a, (.dmark)  
44ce 32 6e fb			ld (debug_mark),a  
44d1 3a e0 44			ld a, (.dmark+1)  
44d4 32 6f fb			ld (debug_mark+1),a  
44d7 3a e1 44			ld a, (.dmark+2)  
44da 32 70 fb			ld (debug_mark+2),a  
44dd 18 03			jr .pastdmark  
44df ..			.dmark: db "CO5"  
44e2 f1			.pastdmark: pop af  
44e3			endm  
# End of macro DMARK
44e3						CALLMONITOR 
44e3 cd 84 17			call break_point_state  
44e6				endm  
# End of macro CALLMONITOR
44e6					endif 
44e6			 
44e6 cd 4f 1e				call forth_push_str 
44e9			 
44e9			 
44e9			 
44e9			 
44e9				       NEXTW 
44e9 c3 4a 21			jp macro_next 
44ec				endm 
# End of macro NEXTW
44ec			 
44ec			 
44ec			.FIND: 
44ec				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
44ec 4b				db WORD_SYS_CORE+55             
44ed aa 45			dw .LEN            
44ef 05				db 4 + 1 
44f0 .. 00			db "FIND",0              
44f5				endm 
# End of macro CWHEAD
44f5			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
44f5			 
44f5					if DEBUG_FORTH_WORDS_KEY 
44f5						DMARK "FND" 
44f5 f5				push af  
44f6 3a 0a 45			ld a, (.dmark)  
44f9 32 6e fb			ld (debug_mark),a  
44fc 3a 0b 45			ld a, (.dmark+1)  
44ff 32 6f fb			ld (debug_mark+1),a  
4502 3a 0c 45			ld a, (.dmark+2)  
4505 32 70 fb			ld (debug_mark+2),a  
4508 18 03			jr .pastdmark  
450a ..			.dmark: db "FND"  
450d f1			.pastdmark: pop af  
450e			endm  
# End of macro DMARK
450e						CALLMONITOR 
450e cd 84 17			call break_point_state  
4511				endm  
# End of macro CALLMONITOR
4511					endif 
4511			 
4511			; TODO check string type 
4511					FORTH_DSP_VALUE 
4511 cd c1 1f			call macro_forth_dsp_value 
4514				endm 
# End of macro FORTH_DSP_VALUE
4514			 
4514 e5					push hl    
4515 7e					ld a,(hl)    ; char to find   
4516			; TODO change char to substr 
4516			 
4516 f5					push af 
4517					 
4517			 
4517			 
4517					if DEBUG_FORTH_WORDS 
4517						DMARK "FN1" 
4517 f5				push af  
4518 3a 2c 45			ld a, (.dmark)  
451b 32 6e fb			ld (debug_mark),a  
451e 3a 2d 45			ld a, (.dmark+1)  
4521 32 6f fb			ld (debug_mark+1),a  
4524 3a 2e 45			ld a, (.dmark+2)  
4527 32 70 fb			ld (debug_mark+2),a  
452a 18 03			jr .pastdmark  
452c ..			.dmark: db "FN1"  
452f f1			.pastdmark: pop af  
4530			endm  
# End of macro DMARK
4530						CALLMONITOR 
4530 cd 84 17			call break_point_state  
4533				endm  
# End of macro CALLMONITOR
4533					endif 
4533			 
4533					FORTH_DSP_POP 
4533 cd 90 20			call macro_forth_dsp_pop 
4536				endm 
# End of macro FORTH_DSP_POP
4536			 
4536					; string to search 
4536			 
4536					FORTH_DSP_VALUE 
4536 cd c1 1f			call macro_forth_dsp_value 
4539				endm 
# End of macro FORTH_DSP_VALUE
4539			 
4539 d1					pop de  ; d is char to find  
453a			 
453a					if DEBUG_FORTH_WORDS 
453a						DMARK "FN2" 
453a f5				push af  
453b 3a 4f 45			ld a, (.dmark)  
453e 32 6e fb			ld (debug_mark),a  
4541 3a 50 45			ld a, (.dmark+1)  
4544 32 6f fb			ld (debug_mark+1),a  
4547 3a 51 45			ld a, (.dmark+2)  
454a 32 70 fb			ld (debug_mark+2),a  
454d 18 03			jr .pastdmark  
454f ..			.dmark: db "FN2"  
4552 f1			.pastdmark: pop af  
4553			endm  
# End of macro DMARK
4553						CALLMONITOR 
4553 cd 84 17			call break_point_state  
4556				endm  
# End of macro CALLMONITOR
4556					endif 
4556					 
4556 01 00 00				ld bc, 0 
4559 7e			.findchar:      ld a,(hl) 
455a fe 00				cp 0   		 
455c 28 27				jr z, .finddone     
455e ba					cp d 
455f 28 20				jr z, .foundchar 
4561 03					inc bc 
4562 23					inc hl 
4563					if DEBUG_FORTH_WORDS 
4563						DMARK "FN3" 
4563 f5				push af  
4564 3a 78 45			ld a, (.dmark)  
4567 32 6e fb			ld (debug_mark),a  
456a 3a 79 45			ld a, (.dmark+1)  
456d 32 6f fb			ld (debug_mark+1),a  
4570 3a 7a 45			ld a, (.dmark+2)  
4573 32 70 fb			ld (debug_mark+2),a  
4576 18 03			jr .pastdmark  
4578 ..			.dmark: db "FN3"  
457b f1			.pastdmark: pop af  
457c			endm  
# End of macro DMARK
457c						CALLMONITOR 
457c cd 84 17			call break_point_state  
457f				endm  
# End of macro CALLMONITOR
457f					endif 
457f 18 d8				jr .findchar 
4581			 
4581			 
4581 c5			.foundchar:	push bc 
4582 e1					pop hl 
4583 18 03				jr .findexit 
4585			 
4585			 
4585							 
4585			 
4585			.finddone:     ; got to end of string with no find 
4585 21 00 00				ld hl, 0 
4588			.findexit: 
4588			 
4588					if DEBUG_FORTH_WORDS 
4588						DMARK "FNd" 
4588 f5				push af  
4589 3a 9d 45			ld a, (.dmark)  
458c 32 6e fb			ld (debug_mark),a  
458f 3a 9e 45			ld a, (.dmark+1)  
4592 32 6f fb			ld (debug_mark+1),a  
4595 3a 9f 45			ld a, (.dmark+2)  
4598 32 70 fb			ld (debug_mark+2),a  
459b 18 03			jr .pastdmark  
459d ..			.dmark: db "FNd"  
45a0 f1			.pastdmark: pop af  
45a1			endm  
# End of macro DMARK
45a1						CALLMONITOR 
45a1 cd 84 17			call break_point_state  
45a4				endm  
# End of macro CALLMONITOR
45a4					endif 
45a4 cd e1 1d			call forth_push_numhl 
45a7			 
45a7				       NEXTW 
45a7 c3 4a 21			jp macro_next 
45aa				endm 
# End of macro NEXTW
45aa			 
45aa			.LEN: 
45aa				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
45aa 4c				db WORD_SYS_CORE+56             
45ab df 45			dw .CHAR            
45ad 06				db 5 + 1 
45ae .. 00			db "COUNT",0              
45b4				endm 
# End of macro CWHEAD
45b4			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
45b4			 
45b4					if DEBUG_FORTH_WORDS_KEY 
45b4						DMARK "CNT" 
45b4 f5				push af  
45b5 3a c9 45			ld a, (.dmark)  
45b8 32 6e fb			ld (debug_mark),a  
45bb 3a ca 45			ld a, (.dmark+1)  
45be 32 6f fb			ld (debug_mark+1),a  
45c1 3a cb 45			ld a, (.dmark+2)  
45c4 32 70 fb			ld (debug_mark+2),a  
45c7 18 03			jr .pastdmark  
45c9 ..			.dmark: db "CNT"  
45cc f1			.pastdmark: pop af  
45cd			endm  
# End of macro DMARK
45cd						CALLMONITOR 
45cd cd 84 17			call break_point_state  
45d0				endm  
# End of macro CALLMONITOR
45d0					endif 
45d0			; TODO check string type 
45d0					FORTH_DSP 
45d0 cd 9e 1f			call macro_forth_dsp 
45d3				endm 
# End of macro FORTH_DSP
45d3					;v5FORTH_DSP_VALUE 
45d3			 
45d3 23					inc hl 
45d4			 
45d4 3e 00				ld a, 0 
45d6 cd 46 12				call strlent 
45d9			 
45d9 cd e1 1d				call forth_push_numhl 
45dc			 
45dc			 
45dc			 
45dc				       NEXTW 
45dc c3 4a 21			jp macro_next 
45df				endm 
# End of macro NEXTW
45df			.CHAR: 
45df				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
45df 4d				db WORD_SYS_CORE+57             
45e0 15 46			dw .ENDSTR            
45e2 05				db 4 + 1 
45e3 .. 00			db "CHAR",0              
45e8				endm 
# End of macro CWHEAD
45e8			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
45e8					if DEBUG_FORTH_WORDS_KEY 
45e8						DMARK "CHR" 
45e8 f5				push af  
45e9 3a fd 45			ld a, (.dmark)  
45ec 32 6e fb			ld (debug_mark),a  
45ef 3a fe 45			ld a, (.dmark+1)  
45f2 32 6f fb			ld (debug_mark+1),a  
45f5 3a ff 45			ld a, (.dmark+2)  
45f8 32 70 fb			ld (debug_mark+2),a  
45fb 18 03			jr .pastdmark  
45fd ..			.dmark: db "CHR"  
4600 f1			.pastdmark: pop af  
4601			endm  
# End of macro DMARK
4601						CALLMONITOR 
4601 cd 84 17			call break_point_state  
4604				endm  
# End of macro CALLMONITOR
4604					endif 
4604					FORTH_DSP 
4604 cd 9e 1f			call macro_forth_dsp 
4607				endm 
# End of macro FORTH_DSP
4607					;v5 FORTH_DSP_VALUE 
4607 23					inc hl      ; now at start of numeric as string 
4608			 
4608			;		push hl 
4608			 
4608					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4608 cd 90 20			call macro_forth_dsp_pop 
460b				endm 
# End of macro FORTH_DSP_POP
460b			 
460b			;		pop hl 
460b			 
460b					; push the content of a onto the stack as a value 
460b			 
460b 7e					ld a,(hl)   ; get char 
460c 26 00				ld h,0 
460e 6f					ld l,a 
460f cd e1 1d				call forth_push_numhl 
4612			 
4612				       NEXTW 
4612 c3 4a 21			jp macro_next 
4615				endm 
# End of macro NEXTW
4615			 
4615			 
4615			 
4615			 
4615			.ENDSTR: 
4615			; eof 
4615			 
# End of file forth_words_str.asm
4615			include "forth_words_key.asm" 
4615			 
4615			; | ## Keyboard Words 
4615			 
4615			.KEY: 
4615				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4615 3e				db WORD_SYS_CORE+42             
4616 45 46			dw .WAITK            
4618 04				db 3 + 1 
4619 .. 00			db "KEY",0              
461d				endm 
# End of macro CWHEAD
461d			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
461d			 
461d					if DEBUG_FORTH_WORDS_KEY 
461d						DMARK "KEY" 
461d f5				push af  
461e 3a 32 46			ld a, (.dmark)  
4621 32 6e fb			ld (debug_mark),a  
4624 3a 33 46			ld a, (.dmark+1)  
4627 32 6f fb			ld (debug_mark+1),a  
462a 3a 34 46			ld a, (.dmark+2)  
462d 32 70 fb			ld (debug_mark+2),a  
4630 18 03			jr .pastdmark  
4632 ..			.dmark: db "KEY"  
4635 f1			.pastdmark: pop af  
4636			endm  
# End of macro DMARK
4636						CALLMONITOR 
4636 cd 84 17			call break_point_state  
4639				endm  
# End of macro CALLMONITOR
4639					endif 
4639			; TODO currently waits 
4639 cd 2a 6b				call cin 
463c					;call cin_wait 
463c 6f					ld l, a 
463d 26 00				ld h, 0 
463f cd e1 1d				call forth_push_numhl 
4642					NEXTW 
4642 c3 4a 21			jp macro_next 
4645				endm 
# End of macro NEXTW
4645			.WAITK: 
4645				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4645 3f				db WORD_SYS_CORE+43             
4646 77 46			dw .ACCEPT            
4648 06				db 5 + 1 
4649 .. 00			db "WAITK",0              
464f				endm 
# End of macro CWHEAD
464f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
464f					if DEBUG_FORTH_WORDS_KEY 
464f						DMARK "WAI" 
464f f5				push af  
4650 3a 64 46			ld a, (.dmark)  
4653 32 6e fb			ld (debug_mark),a  
4656 3a 65 46			ld a, (.dmark+1)  
4659 32 6f fb			ld (debug_mark+1),a  
465c 3a 66 46			ld a, (.dmark+2)  
465f 32 70 fb			ld (debug_mark+2),a  
4662 18 03			jr .pastdmark  
4664 ..			.dmark: db "WAI"  
4667 f1			.pastdmark: pop af  
4668			endm  
# End of macro DMARK
4668						CALLMONITOR 
4668 cd 84 17			call break_point_state  
466b				endm  
# End of macro CALLMONITOR
466b					endif 
466b cd 19 6b				call cin_wait 
466e 6f					ld l, a 
466f 26 00				ld h, 0 
4671 cd e1 1d				call forth_push_numhl 
4674					NEXTW 
4674 c3 4a 21			jp macro_next 
4677				endm 
# End of macro NEXTW
4677			.ACCEPT: 
4677				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4677 40				db WORD_SYS_CORE+44             
4678 d5 46			dw .EDIT            
467a 07				db 6 + 1 
467b .. 00			db "ACCEPT",0              
4682				endm 
# End of macro CWHEAD
4682			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4682					; TODO crashes on push 
4682					if DEBUG_FORTH_WORDS_KEY 
4682						DMARK "ACC" 
4682 f5				push af  
4683 3a 97 46			ld a, (.dmark)  
4686 32 6e fb			ld (debug_mark),a  
4689 3a 98 46			ld a, (.dmark+1)  
468c 32 6f fb			ld (debug_mark+1),a  
468f 3a 99 46			ld a, (.dmark+2)  
4692 32 70 fb			ld (debug_mark+2),a  
4695 18 03			jr .pastdmark  
4697 ..			.dmark: db "ACC"  
469a f1			.pastdmark: pop af  
469b			endm  
# End of macro DMARK
469b						CALLMONITOR 
469b cd 84 17			call break_point_state  
469e				endm  
# End of macro CALLMONITOR
469e					endif 
469e 21 12 f0				ld hl, os_input 
46a1 3e 00				ld a, 0 
46a3 77					ld (hl),a 
46a4 3a 3d f8				ld a,(f_cursor_ptr) 
46a7 16 64				ld d, 100 
46a9 0e 00				ld c, 0 
46ab 1e 28				ld e, 40 
46ad cd 0a 0e				call input_str 
46b0					; TODO perhaps do a type check and wrap in quotes if not a number 
46b0 21 12 f0				ld hl, os_input 
46b3					if DEBUG_FORTH_WORDS 
46b3						DMARK "AC1" 
46b3 f5				push af  
46b4 3a c8 46			ld a, (.dmark)  
46b7 32 6e fb			ld (debug_mark),a  
46ba 3a c9 46			ld a, (.dmark+1)  
46bd 32 6f fb			ld (debug_mark+1),a  
46c0 3a ca 46			ld a, (.dmark+2)  
46c3 32 70 fb			ld (debug_mark+2),a  
46c6 18 03			jr .pastdmark  
46c8 ..			.dmark: db "AC1"  
46cb f1			.pastdmark: pop af  
46cc			endm  
# End of macro DMARK
46cc						CALLMONITOR 
46cc cd 84 17			call break_point_state  
46cf				endm  
# End of macro CALLMONITOR
46cf					endif 
46cf cd 4f 1e				call forth_push_str 
46d2					NEXTW 
46d2 c3 4a 21			jp macro_next 
46d5				endm 
# End of macro NEXTW
46d5			 
46d5			.EDIT: 
46d5				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
46d5 40				db WORD_SYS_CORE+44             
46d6 77 47			dw .ENDKEY            
46d8 05				db 4 + 1 
46d9 .. 00			db "EDIT",0              
46de				endm 
# End of macro CWHEAD
46de			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
46de			 
46de					; TODO does not copy from stack 
46de					if DEBUG_FORTH_WORDS_KEY 
46de						DMARK "EDT" 
46de f5				push af  
46df 3a f3 46			ld a, (.dmark)  
46e2 32 6e fb			ld (debug_mark),a  
46e5 3a f4 46			ld a, (.dmark+1)  
46e8 32 6f fb			ld (debug_mark+1),a  
46eb 3a f5 46			ld a, (.dmark+2)  
46ee 32 70 fb			ld (debug_mark+2),a  
46f1 18 03			jr .pastdmark  
46f3 ..			.dmark: db "EDT"  
46f6 f1			.pastdmark: pop af  
46f7			endm  
# End of macro DMARK
46f7						CALLMONITOR 
46f7 cd 84 17			call break_point_state  
46fa				endm  
# End of macro CALLMONITOR
46fa					endif 
46fa			 
46fa					;FORTH_DSP 
46fa					FORTH_DSP_VALUEHL 
46fa cd d8 1f			call macro_dsp_valuehl 
46fd				endm 
# End of macro FORTH_DSP_VALUEHL
46fd			;		inc hl    ; TODO do type check 
46fd			 
46fd			;		call get_word_hl 
46fd e5					push hl 
46fe					if DEBUG_FORTH_WORDS 
46fe						DMARK "EDp" 
46fe f5				push af  
46ff 3a 13 47			ld a, (.dmark)  
4702 32 6e fb			ld (debug_mark),a  
4705 3a 14 47			ld a, (.dmark+1)  
4708 32 6f fb			ld (debug_mark+1),a  
470b 3a 15 47			ld a, (.dmark+2)  
470e 32 70 fb			ld (debug_mark+2),a  
4711 18 03			jr .pastdmark  
4713 ..			.dmark: db "EDp"  
4716 f1			.pastdmark: pop af  
4717			endm  
# End of macro DMARK
4717						CALLMONITOR 
4717 cd 84 17			call break_point_state  
471a				endm  
# End of macro CALLMONITOR
471a					endif 
471a				;	ld a, 0 
471a cd 3b 12				call strlenz 
471d 23					inc hl 
471e			 
471e 06 00				ld b, 0 
4720 4d					ld c, l 
4721			 
4721 e1					pop hl 
4722 11 12 f0				ld de, os_input 
4725					if DEBUG_FORTH_WORDS_KEY 
4725						DMARK "EDc" 
4725 f5				push af  
4726 3a 3a 47			ld a, (.dmark)  
4729 32 6e fb			ld (debug_mark),a  
472c 3a 3b 47			ld a, (.dmark+1)  
472f 32 6f fb			ld (debug_mark+1),a  
4732 3a 3c 47			ld a, (.dmark+2)  
4735 32 70 fb			ld (debug_mark+2),a  
4738 18 03			jr .pastdmark  
473a ..			.dmark: db "EDc"  
473d f1			.pastdmark: pop af  
473e			endm  
# End of macro DMARK
473e						CALLMONITOR 
473e cd 84 17			call break_point_state  
4741				endm  
# End of macro CALLMONITOR
4741					endif 
4741 ed b0				ldir 
4743			 
4743			 
4743 21 12 f0				ld hl, os_input 
4746					;ld a, 0 
4746					;ld (hl),a 
4746 3a 3d f8				ld a,(f_cursor_ptr) 
4749 16 64				ld d, 100 
474b 0e 00				ld c, 0 
474d 1e 28				ld e, 40 
474f cd 0a 0e				call input_str 
4752					; TODO perhaps do a type check and wrap in quotes if not a number 
4752 21 12 f0				ld hl, os_input 
4755					if DEBUG_FORTH_WORDS 
4755						DMARK "ED1" 
4755 f5				push af  
4756 3a 6a 47			ld a, (.dmark)  
4759 32 6e fb			ld (debug_mark),a  
475c 3a 6b 47			ld a, (.dmark+1)  
475f 32 6f fb			ld (debug_mark+1),a  
4762 3a 6c 47			ld a, (.dmark+2)  
4765 32 70 fb			ld (debug_mark+2),a  
4768 18 03			jr .pastdmark  
476a ..			.dmark: db "ED1"  
476d f1			.pastdmark: pop af  
476e			endm  
# End of macro DMARK
476e						CALLMONITOR 
476e cd 84 17			call break_point_state  
4771				endm  
# End of macro CALLMONITOR
4771					endif 
4771 cd 4f 1e				call forth_push_str 
4774					NEXTW 
4774 c3 4a 21			jp macro_next 
4777				endm 
# End of macro NEXTW
4777			 
4777			 
4777			 
4777			.ENDKEY: 
4777			; eof 
4777			 
# End of file forth_words_key.asm
4777			 
4777			if STORAGE_SE 
4777			   	include "forth_words_storage.asm" 
4777			 
4777			; | ## Fixed Storage Words 
4777			 
4777			.RECORD: 
4777			  
4777				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4777 3a				db WORD_SYS_CORE+38             
4778 1b 48			dw .BREAD            
477a 07				db 6 + 1 
477b .. 00			db "RECORD",0              
4782				endm 
# End of macro CWHEAD
4782			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4782			 
4782					if DEBUG_FORTH_WORDS_KEY 
4782						DMARK "REC" 
4782 f5				push af  
4783 3a 97 47			ld a, (.dmark)  
4786 32 6e fb			ld (debug_mark),a  
4789 3a 98 47			ld a, (.dmark+1)  
478c 32 6f fb			ld (debug_mark+1),a  
478f 3a 99 47			ld a, (.dmark+2)  
4792 32 70 fb			ld (debug_mark+2),a  
4795 18 03			jr .pastdmark  
4797 ..			.dmark: db "REC"  
479a f1			.pastdmark: pop af  
479b			endm  
# End of macro DMARK
479b						CALLMONITOR 
479b cd 84 17			call break_point_state  
479e				endm  
# End of macro CALLMONITOR
479e					endif 
479e			 
479e					FORTH_DSP_VALUEHL 
479e cd d8 1f			call macro_dsp_valuehl 
47a1				endm 
# End of macro FORTH_DSP_VALUEHL
47a1			 
47a1 e5					push hl    ; id 
47a2			 
47a2					FORTH_DSP_POP 
47a2 cd 90 20			call macro_forth_dsp_pop 
47a5				endm 
# End of macro FORTH_DSP_POP
47a5			 
47a5					FORTH_DSP_VALUEHL 
47a5 cd d8 1f			call macro_dsp_valuehl 
47a8				endm 
# End of macro FORTH_DSP_VALUEHL
47a8			 
47a8					FORTH_DSP_POP 
47a8 cd 90 20			call macro_forth_dsp_pop 
47ab				endm 
# End of macro FORTH_DSP_POP
47ab			 
47ab d1					pop de     ; get file id 
47ac			 
47ac					; e = file id 
47ac					; l = file extent 
47ac			 
47ac			 
47ac					; construct request to access file extent 
47ac			 
47ac			;		ld a, e 
47ac 63					ld h, e 
47ad					 
47ad					 
47ad					 
47ad			 
47ad					; e has id 
47ad			 
47ad 11 59 f8			ld de, store_page 
47b0					if DEBUG_FORTH_WORDS 
47b0						DMARK "REr" 
47b0 f5				push af  
47b1 3a c5 47			ld a, (.dmark)  
47b4 32 6e fb			ld (debug_mark),a  
47b7 3a c6 47			ld a, (.dmark+1)  
47ba 32 6f fb			ld (debug_mark+1),a  
47bd 3a c7 47			ld a, (.dmark+2)  
47c0 32 70 fb			ld (debug_mark+2),a  
47c3 18 03			jr .pastdmark  
47c5 ..			.dmark: db "REr"  
47c8 f1			.pastdmark: pop af  
47c9			endm  
# End of macro DMARK
47c9						CALLMONITOR 
47c9 cd 84 17			call break_point_state  
47cc				endm  
# End of macro CALLMONITOR
47cc					endif 
47cc cd 14 09				call storage_read 
47cf cd 06 0e			call ishlzero 
47d2 28 22			jr z, .recnotfound 
47d4			 
47d4			 
47d4					if DEBUG_FORTH_WORDS 
47d4						DMARK "REe" 
47d4 f5				push af  
47d5 3a e9 47			ld a, (.dmark)  
47d8 32 6e fb			ld (debug_mark),a  
47db 3a ea 47			ld a, (.dmark+1)  
47de 32 6f fb			ld (debug_mark+1),a  
47e1 3a eb 47			ld a, (.dmark+2)  
47e4 32 70 fb			ld (debug_mark+2),a  
47e7 18 03			jr .pastdmark  
47e9 ..			.dmark: db "REe"  
47ec f1			.pastdmark: pop af  
47ed			endm  
# End of macro DMARK
47ed						CALLMONITOR 
47ed cd 84 17			call break_point_state  
47f0				endm  
# End of macro CALLMONITOR
47f0					endif 
47f0 cd 4f 1e			call forth_push_str 
47f3			 
47f3					NEXTW 
47f3 c3 4a 21			jp macro_next 
47f6				endm 
# End of macro NEXTW
47f6			 
47f6			.recnotfound: 
47f6					if DEBUG_FORTH_WORDS 
47f6						DMARK "REf" 
47f6 f5				push af  
47f7 3a 0b 48			ld a, (.dmark)  
47fa 32 6e fb			ld (debug_mark),a  
47fd 3a 0c 48			ld a, (.dmark+1)  
4800 32 6f fb			ld (debug_mark+1),a  
4803 3a 0d 48			ld a, (.dmark+2)  
4806 32 70 fb			ld (debug_mark+2),a  
4809 18 03			jr .pastdmark  
480b ..			.dmark: db "REf"  
480e f1			.pastdmark: pop af  
480f			endm  
# End of macro DMARK
480f						CALLMONITOR 
480f cd 84 17			call break_point_state  
4812				endm  
# End of macro CALLMONITOR
4812					endif 
4812 21 ff 00			ld hl, 255 
4815 cd e1 1d			call forth_push_numhl 
4818				NEXTW 
4818 c3 4a 21			jp macro_next 
481b				endm 
# End of macro NEXTW
481b			 
481b			 
481b			.BREAD: 
481b			  
481b				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
481b 3a				db WORD_SYS_CORE+38             
481c 9e 48			dw .BWRITE            
481e 06				db 5 + 1 
481f .. 00			db "BREAD",0              
4825				endm 
# End of macro CWHEAD
4825			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4825				 
4825					if DEBUG_FORTH_WORDS_KEY 
4825						DMARK "BRD" 
4825 f5				push af  
4826 3a 3a 48			ld a, (.dmark)  
4829 32 6e fb			ld (debug_mark),a  
482c 3a 3b 48			ld a, (.dmark+1)  
482f 32 6f fb			ld (debug_mark+1),a  
4832 3a 3c 48			ld a, (.dmark+2)  
4835 32 70 fb			ld (debug_mark+2),a  
4838 18 03			jr .pastdmark  
483a ..			.dmark: db "BRD"  
483d f1			.pastdmark: pop af  
483e			endm  
# End of macro DMARK
483e						CALLMONITOR 
483e cd 84 17			call break_point_state  
4841				endm  
# End of macro CALLMONITOR
4841					endif 
4841			 
4841				FORTH_DSP_VALUEHL 
4841 cd d8 1f			call macro_dsp_valuehl 
4844				endm 
# End of macro FORTH_DSP_VALUEHL
4844			 
4844				FORTH_DSP_POP 
4844 cd 90 20			call macro_forth_dsp_pop 
4847				endm 
# End of macro FORTH_DSP_POP
4847			 
4847				; calc block address 
4847			 
4847 eb				ex de, hl 
4848 3e 40			ld a, STORE_BLOCK_PHY 
484a cd 60 0d			call Mult16 
484d			 
484d			 
484d 11 59 f8			ld de, store_page 
4850			 
4850					if DEBUG_FORTH_WORDS 
4850						DMARK "BR1" 
4850 f5				push af  
4851 3a 65 48			ld a, (.dmark)  
4854 32 6e fb			ld (debug_mark),a  
4857 3a 66 48			ld a, (.dmark+1)  
485a 32 6f fb			ld (debug_mark+1),a  
485d 3a 67 48			ld a, (.dmark+2)  
4860 32 70 fb			ld (debug_mark+2),a  
4863 18 03			jr .pastdmark  
4865 ..			.dmark: db "BR1"  
4868 f1			.pastdmark: pop af  
4869			endm  
# End of macro DMARK
4869						CALLMONITOR 
4869 cd 84 17			call break_point_state  
486c				endm  
# End of macro CALLMONITOR
486c					endif 
486c			 
486c cd bb 03			call storage_read_block 
486f			 
486f cd 06 0e			call ishlzero 
4872 20 05			jr nz, .brfound 
4874			 
4874 cd e1 1d			call forth_push_numhl 
4877 18 22			jr .brdone 
4879			 
4879			 
4879			.brfound: 
4879 21 5b f8		        ld hl, store_page+2 
487c			 
487c					if DEBUG_FORTH_WORDS 
487c						DMARK "BR2" 
487c f5				push af  
487d 3a 91 48			ld a, (.dmark)  
4880 32 6e fb			ld (debug_mark),a  
4883 3a 92 48			ld a, (.dmark+1)  
4886 32 6f fb			ld (debug_mark+1),a  
4889 3a 93 48			ld a, (.dmark+2)  
488c 32 70 fb			ld (debug_mark+2),a  
488f 18 03			jr .pastdmark  
4891 ..			.dmark: db "BR2"  
4894 f1			.pastdmark: pop af  
4895			endm  
# End of macro DMARK
4895						CALLMONITOR 
4895 cd 84 17			call break_point_state  
4898				endm  
# End of macro CALLMONITOR
4898					endif 
4898			 
4898 cd 4f 1e			call forth_push_str 
489b			 
489b			 
489b			.brdone: 
489b			 
489b					NEXTW 
489b c3 4a 21			jp macro_next 
489e				endm 
# End of macro NEXTW
489e			.BWRITE: 
489e				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
489e 3a				db WORD_SYS_CORE+38             
489f 33 49			dw .BUPD            
48a1 07				db 6 + 1 
48a2 .. 00			db "BWRITE",0              
48a9				endm 
# End of macro CWHEAD
48a9			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
48a9			 
48a9					if DEBUG_FORTH_WORDS_KEY 
48a9						DMARK "BWR" 
48a9 f5				push af  
48aa 3a be 48			ld a, (.dmark)  
48ad 32 6e fb			ld (debug_mark),a  
48b0 3a bf 48			ld a, (.dmark+1)  
48b3 32 6f fb			ld (debug_mark+1),a  
48b6 3a c0 48			ld a, (.dmark+2)  
48b9 32 70 fb			ld (debug_mark+2),a  
48bc 18 03			jr .pastdmark  
48be ..			.dmark: db "BWR"  
48c1 f1			.pastdmark: pop af  
48c2			endm  
# End of macro DMARK
48c2						CALLMONITOR 
48c2 cd 84 17			call break_point_state  
48c5				endm  
# End of macro CALLMONITOR
48c5					endif 
48c5			 
48c5				FORTH_DSP_VALUEHL 
48c5 cd d8 1f			call macro_dsp_valuehl 
48c8				endm 
# End of macro FORTH_DSP_VALUEHL
48c8			 
48c8				; calc block address 
48c8			 
48c8 eb				ex de, hl 
48c9 3e 40			ld a, STORE_BLOCK_PHY 
48cb cd 60 0d			call Mult16 
48ce			 
48ce e5				push hl         ; address 
48cf			 
48cf				FORTH_DSP_POP 
48cf cd 90 20			call macro_forth_dsp_pop 
48d2				endm 
# End of macro FORTH_DSP_POP
48d2			 
48d2				FORTH_DSP_VALUEHL 
48d2 cd d8 1f			call macro_dsp_valuehl 
48d5				endm 
# End of macro FORTH_DSP_VALUEHL
48d5			 
48d5				FORTH_DSP_POP 
48d5 cd 90 20			call macro_forth_dsp_pop 
48d8				endm 
# End of macro FORTH_DSP_POP
48d8			 
48d8 cd e9 0a			call storage_clear_page 
48db			 
48db				; copy string to store page 
48db			 
48db e5				push hl     ; save string address 
48dc			 
48dc 3e 00			ld a, 0 
48de cd 46 12			call strlent 
48e1			 
48e1 23				inc hl 
48e2			 
48e2 4d				ld c, l 
48e3 06 00			ld b, 0 
48e5			 
48e5 e1				pop hl 
48e6 11 5b f8			ld de, store_page + 2 
48e9					if DEBUG_FORTH_WORDS 
48e9						DMARK "BW1" 
48e9 f5				push af  
48ea 3a fe 48			ld a, (.dmark)  
48ed 32 6e fb			ld (debug_mark),a  
48f0 3a ff 48			ld a, (.dmark+1)  
48f3 32 6f fb			ld (debug_mark+1),a  
48f6 3a 00 49			ld a, (.dmark+2)  
48f9 32 70 fb			ld (debug_mark+2),a  
48fc 18 03			jr .pastdmark  
48fe ..			.dmark: db "BW1"  
4901 f1			.pastdmark: pop af  
4902			endm  
# End of macro DMARK
4902						CALLMONITOR 
4902 cd 84 17			call break_point_state  
4905				endm  
# End of macro CALLMONITOR
4905					endif 
4905 ed b0			ldir 
4907			 
4907			 
4907				; poke the start of the block with flags to prevent high level file ops hitting the block 
4907			 
4907 21 ff ff			ld hl, $ffff 
490a			 
490a 22 59 f8			ld (store_page), hl	 
490d				 
490d e1				pop hl    ; get address 
490e 11 59 f8			ld de, store_page 
4911			 
4911					if DEBUG_FORTH_WORDS 
4911						DMARK "BW2" 
4911 f5				push af  
4912 3a 26 49			ld a, (.dmark)  
4915 32 6e fb			ld (debug_mark),a  
4918 3a 27 49			ld a, (.dmark+1)  
491b 32 6f fb			ld (debug_mark+1),a  
491e 3a 28 49			ld a, (.dmark+2)  
4921 32 70 fb			ld (debug_mark+2),a  
4924 18 03			jr .pastdmark  
4926 ..			.dmark: db "BW2"  
4929 f1			.pastdmark: pop af  
492a			endm  
# End of macro DMARK
492a						CALLMONITOR 
492a cd 84 17			call break_point_state  
492d				endm  
# End of macro CALLMONITOR
492d					endif 
492d			 
492d cd 20 04			call storage_write_block 
4930			 
4930					NEXTW 
4930 c3 4a 21			jp macro_next 
4933				endm 
# End of macro NEXTW
4933			 
4933			.BUPD: 
4933				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4933 3a				db WORD_SYS_CORE+38             
4934 89 49			dw .BYID            
4936 05				db 4 + 1 
4937 .. 00			db "BUPD",0              
493c				endm 
# End of macro CWHEAD
493c			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
493c			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
493c			; | | or completely different file system structure. 
493c			 
493c					if DEBUG_FORTH_WORDS_KEY 
493c						DMARK "BUD" 
493c f5				push af  
493d 3a 51 49			ld a, (.dmark)  
4940 32 6e fb			ld (debug_mark),a  
4943 3a 52 49			ld a, (.dmark+1)  
4946 32 6f fb			ld (debug_mark+1),a  
4949 3a 53 49			ld a, (.dmark+2)  
494c 32 70 fb			ld (debug_mark+2),a  
494f 18 03			jr .pastdmark  
4951 ..			.dmark: db "BUD"  
4954 f1			.pastdmark: pop af  
4955			endm  
# End of macro DMARK
4955						CALLMONITOR 
4955 cd 84 17			call break_point_state  
4958				endm  
# End of macro CALLMONITOR
4958					endif 
4958			 
4958				FORTH_DSP_VALUEHL 
4958 cd d8 1f			call macro_dsp_valuehl 
495b				endm 
# End of macro FORTH_DSP_VALUEHL
495b			 
495b				; calc block address 
495b			 
495b eb				ex de, hl 
495c 3e 40			ld a, STORE_BLOCK_PHY 
495e cd 60 0d			call Mult16 
4961			 
4961				FORTH_DSP_POP 
4961 cd 90 20			call macro_forth_dsp_pop 
4964				endm 
# End of macro FORTH_DSP_POP
4964			 
4964			 
4964 11 59 f8			ld de, store_page 
4967			 
4967					if DEBUG_FORTH_WORDS 
4967						DMARK "BUe" 
4967 f5				push af  
4968 3a 7c 49			ld a, (.dmark)  
496b 32 6e fb			ld (debug_mark),a  
496e 3a 7d 49			ld a, (.dmark+1)  
4971 32 6f fb			ld (debug_mark+1),a  
4974 3a 7e 49			ld a, (.dmark+2)  
4977 32 70 fb			ld (debug_mark+2),a  
497a 18 03			jr .pastdmark  
497c ..			.dmark: db "BUe"  
497f f1			.pastdmark: pop af  
4980			endm  
# End of macro DMARK
4980						CALLMONITOR 
4980 cd 84 17			call break_point_state  
4983				endm  
# End of macro CALLMONITOR
4983					endif 
4983			 
4983 cd 20 04			call storage_write_block 
4986			 
4986					NEXTW 
4986 c3 4a 21			jp macro_next 
4989				endm 
# End of macro NEXTW
4989			 
4989			.BYID: 
4989			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4989			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4989			; 
4989			;		 
4989			;		if DEBUG_FORTH_WORDS_KEY 
4989			;			DMARK "BYID" 
4989			;			CALLMONITOR 
4989			;		endif 
4989			; 
4989			;		; get direct address 
4989			; 
4989			;		FORTH_DSP_VALUEHL 
4989			; 
4989			;		FORTH_DSP_POP 
4989			; 
4989			;	; calc block address 
4989			; 
4989			;	ex de, hl 
4989			;	ld a, STORE_BLOCK_PHY 
4989			;	call Mult16 
4989			;	;	do BREAD with number as param 
4989			;	; push the file name	 
4989			;	ld de, store_page 
4989			;	call storage_read_block 
4989			 ;       ld hl, store_page+2 
4989			; 
4989			; 
4989			;		NEXTW 
4989			;.BYNAME: 
4989				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4989 3a				db WORD_SYS_CORE+38             
498a a2 49			dw .DIR            
498c 06				db 5 + 1 
498d .. 00			db "GETID",0              
4993				endm 
# End of macro CWHEAD
4993			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4993			 
4993					; get pointer to file name to seek 
4993			 
4993					FORTH_DSP_VALUEHL 
4993 cd d8 1f			call macro_dsp_valuehl 
4996				endm 
# End of macro FORTH_DSP_VALUEHL
4996			 
4996			 
4996 cd e2 02				call storage_getid  
4999			 
4999					FORTH_DSP_POP 
4999 cd 90 20			call macro_forth_dsp_pop 
499c				endm 
# End of macro FORTH_DSP_POP
499c			 
499c cd e1 1d				call forth_push_numhl 
499f			 
499f					NEXTW 
499f c3 4a 21			jp macro_next 
49a2				endm 
# End of macro NEXTW
49a2			; 
49a2			.DIR: 
49a2				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
49a2 3a				db WORD_SYS_CORE+38             
49a3 a6 4a			dw .SAVE            
49a5 04				db 3 + 1 
49a6 .. 00			db "DIR",0              
49aa				endm 
# End of macro CWHEAD
49aa			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
49aa			 
49aa					if DEBUG_FORTH_WORDS_KEY 
49aa						DMARK "DIR" 
49aa f5				push af  
49ab 3a bf 49			ld a, (.dmark)  
49ae 32 6e fb			ld (debug_mark),a  
49b1 3a c0 49			ld a, (.dmark+1)  
49b4 32 6f fb			ld (debug_mark+1),a  
49b7 3a c1 49			ld a, (.dmark+2)  
49ba 32 70 fb			ld (debug_mark+2),a  
49bd 18 03			jr .pastdmark  
49bf ..			.dmark: db "DIR"  
49c2 f1			.pastdmark: pop af  
49c3			endm  
# End of macro DMARK
49c3						CALLMONITOR 
49c3 cd 84 17			call break_point_state  
49c6				endm  
# End of macro CALLMONITOR
49c6					endif 
49c6 cd 6c 04			call storage_get_block_0 
49c9			 
49c9 21 59 f8			ld hl, store_page     ; get current id count 
49cc 46				ld b, (hl) 
49cd 0e 00			ld c, 0    ; count of files   
49cf					if DEBUG_FORTH_WORDS 
49cf						DMARK "DI1" 
49cf f5				push af  
49d0 3a e4 49			ld a, (.dmark)  
49d3 32 6e fb			ld (debug_mark),a  
49d6 3a e5 49			ld a, (.dmark+1)  
49d9 32 6f fb			ld (debug_mark+1),a  
49dc 3a e6 49			ld a, (.dmark+2)  
49df 32 70 fb			ld (debug_mark+2),a  
49e2 18 03			jr .pastdmark  
49e4 ..			.dmark: db "DI1"  
49e7 f1			.pastdmark: pop af  
49e8			endm  
# End of macro DMARK
49e8						CALLMONITOR 
49e8 cd 84 17			call break_point_state  
49eb				endm  
# End of macro CALLMONITOR
49eb					endif 
49eb			 
49eb				; check for empty drive 
49eb			 
49eb 3e 00			ld a, 0 
49ed b8				cp b 
49ee ca 5c 4a			jp z, .dirdone 
49f1			 
49f1				; for each of the current ids do a search for them and if found push to stack 
49f1			 
49f1 c5			.diritem:	push bc 
49f2 21 40 00				ld hl, STORE_BLOCK_PHY 
49f5 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
49f7 58					ld e,b 
49f8			 
49f8			;		if DEBUG_FORTH_WORDS 
49f8			;			DMARK "DI2" 
49f8			;			CALLMONITOR 
49f8			;		endif 
49f8			 
49f8 cd ee 06				call storage_findnextid 
49fb			 
49fb			;		if DEBUG_FORTH_WORDS 
49fb			;			DMARK "DI3" 
49fb			;			CALLMONITOR 
49fb			;		endif 
49fb			 
49fb					; if found hl will be non zero 
49fb			 
49fb cd 06 0e				call ishlzero 
49fe			;		ld a, l 
49fe			;		add h 
49fe			; 
49fe			;		cp 0 
49fe 28 59				jr z, .dirnotfound 
4a00			 
4a00					; increase count 
4a00			 
4a00 c1					pop bc	 
4a01 0c					inc c 
4a02 c5					push bc 
4a03					 
4a03			 
4a03					; get file header and push the file name 
4a03			 
4a03 11 59 f8				ld de, store_page 
4a06 cd bb 03				call storage_read_block 
4a09			 
4a09					; push file id to stack 
4a09				 
4a09 3a 59 f8				ld a, (store_page) 
4a0c 26 00				ld h, 0 
4a0e 6f					ld l, a 
4a0f cd e1 1d				call forth_push_numhl 
4a12			 
4a12					; push extent count to stack  
4a12				 
4a12 3a 5b f8				ld a, (store_page+2) 
4a15 26 00				ld h, 0 
4a17 6f					ld l, a 
4a18 cd e1 1d				call forth_push_numhl 
4a1b			 
4a1b					; push file name 
4a1b			 
4a1b 21 5c f8				ld hl, store_page+3 
4a1e					if DEBUG_FORTH_WORDS 
4a1e						DMARK "DI5" 
4a1e f5				push af  
4a1f 3a 33 4a			ld a, (.dmark)  
4a22 32 6e fb			ld (debug_mark),a  
4a25 3a 34 4a			ld a, (.dmark+1)  
4a28 32 6f fb			ld (debug_mark+1),a  
4a2b 3a 35 4a			ld a, (.dmark+2)  
4a2e 32 70 fb			ld (debug_mark+2),a  
4a31 18 03			jr .pastdmark  
4a33 ..			.dmark: db "DI5"  
4a36 f1			.pastdmark: pop af  
4a37			endm  
# End of macro DMARK
4a37						CALLMONITOR 
4a37 cd 84 17			call break_point_state  
4a3a				endm  
# End of macro CALLMONITOR
4a3a					endif 
4a3a cd 4f 1e				call forth_push_str 
4a3d					if DEBUG_FORTH_WORDS 
4a3d						DMARK "DI6" 
4a3d f5				push af  
4a3e 3a 52 4a			ld a, (.dmark)  
4a41 32 6e fb			ld (debug_mark),a  
4a44 3a 53 4a			ld a, (.dmark+1)  
4a47 32 6f fb			ld (debug_mark+1),a  
4a4a 3a 54 4a			ld a, (.dmark+2)  
4a4d 32 70 fb			ld (debug_mark+2),a  
4a50 18 03			jr .pastdmark  
4a52 ..			.dmark: db "DI6"  
4a55 f1			.pastdmark: pop af  
4a56			endm  
# End of macro DMARK
4a56						CALLMONITOR 
4a56 cd 84 17			call break_point_state  
4a59				endm  
# End of macro CALLMONITOR
4a59					endif 
4a59			.dirnotfound: 
4a59 c1					pop bc     
4a5a 10 95				djnz .diritem 
4a5c				 
4a5c			.dirdone:	 
4a5c					if DEBUG_FORTH_WORDS 
4a5c						DMARK "DI7" 
4a5c f5				push af  
4a5d 3a 71 4a			ld a, (.dmark)  
4a60 32 6e fb			ld (debug_mark),a  
4a63 3a 72 4a			ld a, (.dmark+1)  
4a66 32 6f fb			ld (debug_mark+1),a  
4a69 3a 73 4a			ld a, (.dmark+2)  
4a6c 32 70 fb			ld (debug_mark+2),a  
4a6f 18 03			jr .pastdmark  
4a71 ..			.dmark: db "DI7"  
4a74 f1			.pastdmark: pop af  
4a75			endm  
# End of macro DMARK
4a75						CALLMONITOR 
4a75 cd 84 17			call break_point_state  
4a78				endm  
# End of macro CALLMONITOR
4a78					endif 
4a78			 
4a78					; push a count of the dir items found 
4a78			 
4a78 26 00				ld h, 0 
4a7a 69					ld l, c 
4a7b cd e1 1d				call forth_push_numhl 
4a7e			 
4a7e					; push the bank label 
4a7e			 
4a7e cd 6c 04				call storage_get_block_0 
4a81			 
4a81				 
4a81 21 5c f8		 		ld hl, store_page+3 
4a84			 
4a84					if DEBUG_FORTH_WORDS 
4a84						DMARK "DI8" 
4a84 f5				push af  
4a85 3a 99 4a			ld a, (.dmark)  
4a88 32 6e fb			ld (debug_mark),a  
4a8b 3a 9a 4a			ld a, (.dmark+1)  
4a8e 32 6f fb			ld (debug_mark+1),a  
4a91 3a 9b 4a			ld a, (.dmark+2)  
4a94 32 70 fb			ld (debug_mark+2),a  
4a97 18 03			jr .pastdmark  
4a99 ..			.dmark: db "DI8"  
4a9c f1			.pastdmark: pop af  
4a9d			endm  
# End of macro DMARK
4a9d						CALLMONITOR 
4a9d cd 84 17			call break_point_state  
4aa0				endm  
# End of macro CALLMONITOR
4aa0					endif 
4aa0 cd 4f 1e				call forth_push_str 
4aa3			 
4aa3			 
4aa3				 
4aa3					NEXTW 
4aa3 c3 4a 21			jp macro_next 
4aa6				endm 
# End of macro NEXTW
4aa6			.SAVE: 
4aa6			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4aa6			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4aa6			;		NEXTW 
4aa6			;.LOAD: 
4aa6			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4aa6			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4aa6			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4aa6			;; > > The LOAD command can not be used in any user words or compound lines. 
4aa6			; 
4aa6			;		; store_openext use it. If zero it is EOF 
4aa6			; 
4aa6			;		; read block from current stream id 
4aa6			;		; if the block does not contain zero term keep reading blocks until zero found 
4aa6			;		; push the block to stack 
4aa6			;		; save the block id to stream 
4aa6			; 
4aa6			; 
4aa6			;		FORTH_DSP_VALUEHL 
4aa6			; 
4aa6			;;		push hl 
4aa6			; 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LOA" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;		FORTH_DSP_POP 
4aa6			; 
4aa6			;;		pop hl 
4aa6			; 
4aa6			;		ld h, l 
4aa6			;		ld l, 0 
4aa6			; 
4aa6			;		push hl     ; stack holds current file id and extent to work with 
4aa6			; 
4aa6			; 
4aa6			;		ld de, store_page      ; get block zero of file 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LO0" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;		call storage_read 
4aa6			; 
4aa6			;		ld a, (store_page+2)    ; max extents for this file 
4aa6			;		ld  (store_openmaxext),a   ; get our limit 
4aa6			; 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LOE" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			; 
4aa6			;; TODO dont know why max extents are not present 
4aa6			;;		cp 0 
4aa6			;;		jp z, .loadeof     ; dont read past eof 
4aa6			; 
4aa6			;;		ld a, 1   ; start from the head of the file 
4aa6			; 
4aa6			;.loadline:	pop hl 
4aa6			;		inc hl 
4aa6			;		ld  a, (store_openmaxext)   ; get our limit 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LOx" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;		inc a 
4aa6			;		cp l 
4aa6			;		jp z, .loadeof 
4aa6			;		push hl    ; save current extent 
4aa6			; 
4aa6			;		ld de, store_page 
4aa6			; 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LO1" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;		call storage_read 
4aa6			; 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LO2" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;	call ishlzero 
4aa6			;	ld a, l 
4aa6			;	add h 
4aa6			;	cp 0 
4aa6			;	jr z, .loadeof 
4aa6			; 
4aa6			;	; not eof so hl should point to data to exec 
4aa6			; 
4aa6			;	; will need to add the FORTH_END_BUFFER flag 
4aa6			 ; 
4aa6			;	ld hl, store_page+2 
4aa6			;	ld bc, 255 
4aa6			;	ld a, 0 
4aa6			;	cpir 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LOt" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;	dec hl 
4aa6			;	ld a, ' ' 
4aa6			;	ld (hl), a 
4aa6			;	inc hl 
4aa6			;	ld (hl), a 
4aa6			;	inc hl 
4aa6			;	ld (hl), a 
4aa6			;	inc hl 
4aa6			;	ld a, FORTH_END_BUFFER 
4aa6			;	ld (hl), a 
4aa6			; 
4aa6			;	; TODO handle more than a single block read 
4aa6			; 
4aa6			; 
4aa6			;	ld hl, store_page+2 
4aa6			; 
4aa6			;	ld (os_tok_ptr), hl 
4aa6			; 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LO3" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			; 
4aa6			;	call forthparse 
4aa6			;	call forthexec 
4aa6			;	call forthexec_cleanup 
4aa6			; 
4aa6			;	; go to next extent 
4aa6			; 
4aa6			;	; get next block  or mark as eof 
4aa6			;	jp .loadline 
4aa6			; 
4aa6			; 
4aa6			; 
4aa6			;	       NEXTW 
4aa6			;.loadeof:	ld a, 0 
4aa6			;		ld (store_openext), a 
4aa6			; 
4aa6			;	if DEBUG_STORESE 
4aa6			;		DMARK "LOF" 
4aa6			;		CALLMONITOR 
4aa6			;	endif 
4aa6			;		ret 
4aa6			;		;NEXTW 
4aa6			;.BSAVE:   
4aa6			; 
4aa6			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4aa6			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4aa6			;		NEXTW 
4aa6			;.BLOAD: 
4aa6			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4aa6			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4aa6			;		NEXTW 
4aa6			;;;; counter gap 
4aa6			 
4aa6			 
4aa6			.SEO: 
4aa6				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4aa6 64				db WORD_SYS_CORE+80             
4aa7 c5 4a			dw .SEI            
4aa9 04				db 3 + 1 
4aaa .. 00			db "SEO",0              
4aae				endm 
# End of macro CWHEAD
4aae			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4aae			 
4aae					; get port 
4aae			 
4aae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aae cd d8 1f			call macro_dsp_valuehl 
4ab1				endm 
# End of macro FORTH_DSP_VALUEHL
4ab1			 
4ab1 e5					push hl    ; u2 - byte 
4ab2			 
4ab2					; destroy value TOS 
4ab2			 
4ab2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab2 cd 90 20			call macro_forth_dsp_pop 
4ab5				endm 
# End of macro FORTH_DSP_POP
4ab5			 
4ab5					; get byte to send 
4ab5			 
4ab5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab5 cd d8 1f			call macro_dsp_valuehl 
4ab8				endm 
# End of macro FORTH_DSP_VALUEHL
4ab8			 
4ab8 e5					push hl    ; u1 - addr 
4ab9			 
4ab9					; destroy value TOS 
4ab9			 
4ab9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab9 cd 90 20			call macro_forth_dsp_pop 
4abc				endm 
# End of macro FORTH_DSP_POP
4abc			 
4abc					; one value on hl get other one back 
4abc			 
4abc d1					pop de   ; u1 - byte 
4abd			 
4abd e1					pop hl   ; u2 - addr 
4abe			 
4abe					; TODO Send SPI byte 
4abe			 
4abe			 
4abe 7b					ld a, e 
4abf cd c0 01				call se_writebyte 
4ac2			 
4ac2					 
4ac2			 
4ac2					NEXTW 
4ac2 c3 4a 21			jp macro_next 
4ac5				endm 
# End of macro NEXTW
4ac5			 
4ac5			.SEI: 
4ac5				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4ac5 65				db WORD_SYS_CORE+81             
4ac6 df 4a			dw .SFREE            
4ac8 04				db 3 + 1 
4ac9 .. 00			db "SEI",0              
4acd				endm 
# End of macro CWHEAD
4acd			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4acd			 
4acd					; get port 
4acd			 
4acd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4acd cd d8 1f			call macro_dsp_valuehl 
4ad0				endm 
# End of macro FORTH_DSP_VALUEHL
4ad0			 
4ad0			;		push hl 
4ad0			 
4ad0					; destroy value TOS 
4ad0			 
4ad0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ad0 cd 90 20			call macro_forth_dsp_pop 
4ad3				endm 
# End of macro FORTH_DSP_POP
4ad3			 
4ad3					; one value on hl get other one back 
4ad3			 
4ad3			;		pop hl 
4ad3			 
4ad3			 
4ad3					; TODO Get SPI byte 
4ad3			 
4ad3 cd 62 02				call se_readbyte 
4ad6			 
4ad6 26 00				ld h, 0 
4ad8 6f					ld l, a 
4ad9 cd e1 1d				call forth_push_numhl 
4adc			 
4adc					NEXTW 
4adc c3 4a 21			jp macro_next 
4adf				endm 
# End of macro NEXTW
4adf			 
4adf			.SFREE: 
4adf				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4adf 67				db WORD_SYS_CORE+83             
4ae0 0e 4b			dw .SIZE            
4ae2 06				db 5 + 1 
4ae3 .. 00			db "FFREE",0              
4ae9				endm 
# End of macro CWHEAD
4ae9			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4ae9					if DEBUG_FORTH_WORDS_KEY 
4ae9						DMARK "FFR" 
4ae9 f5				push af  
4aea 3a fe 4a			ld a, (.dmark)  
4aed 32 6e fb			ld (debug_mark),a  
4af0 3a ff 4a			ld a, (.dmark+1)  
4af3 32 6f fb			ld (debug_mark+1),a  
4af6 3a 00 4b			ld a, (.dmark+2)  
4af9 32 70 fb			ld (debug_mark+2),a  
4afc 18 03			jr .pastdmark  
4afe ..			.dmark: db "FFR"  
4b01 f1			.pastdmark: pop af  
4b02			endm  
# End of macro DMARK
4b02						CALLMONITOR 
4b02 cd 84 17			call break_point_state  
4b05				endm  
# End of macro CALLMONITOR
4b05					endif 
4b05			 
4b05 cd 88 07				call storage_freeblocks 
4b08			 
4b08 cd e1 1d				call forth_push_numhl 
4b0b			 
4b0b				       NEXTW 
4b0b c3 4a 21			jp macro_next 
4b0e				endm 
# End of macro NEXTW
4b0e			.SIZE: 
4b0e				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4b0e 67				db WORD_SYS_CORE+83             
4b0f 42 4b			dw .CREATE            
4b11 05				db 4 + 1 
4b12 .. 00			db "SIZE",0              
4b17				endm 
# End of macro CWHEAD
4b17			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4b17					if DEBUG_FORTH_WORDS_KEY 
4b17						DMARK "SIZ" 
4b17 f5				push af  
4b18 3a 2c 4b			ld a, (.dmark)  
4b1b 32 6e fb			ld (debug_mark),a  
4b1e 3a 2d 4b			ld a, (.dmark+1)  
4b21 32 6f fb			ld (debug_mark+1),a  
4b24 3a 2e 4b			ld a, (.dmark+2)  
4b27 32 70 fb			ld (debug_mark+2),a  
4b2a 18 03			jr .pastdmark  
4b2c ..			.dmark: db "SIZ"  
4b2f f1			.pastdmark: pop af  
4b30			endm  
# End of macro DMARK
4b30						CALLMONITOR 
4b30 cd 84 17			call break_point_state  
4b33				endm  
# End of macro CALLMONITOR
4b33					endif 
4b33			 
4b33					FORTH_DSP_VALUEHL 
4b33 cd d8 1f			call macro_dsp_valuehl 
4b36				endm 
# End of macro FORTH_DSP_VALUEHL
4b36			;		push hl 
4b36					FORTH_DSP_POP 
4b36 cd 90 20			call macro_forth_dsp_pop 
4b39				endm 
# End of macro FORTH_DSP_POP
4b39			;		pop hl 
4b39 cd ea 03				call storage_file_size 
4b3c			 
4b3c cd e1 1d				call forth_push_numhl 
4b3f			  
4b3f			 
4b3f				       NEXTW 
4b3f c3 4a 21			jp macro_next 
4b42				endm 
# End of macro NEXTW
4b42			 
4b42			.CREATE: 
4b42				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4b42 68				db WORD_SYS_CORE+84             
4b43 b0 4b			dw .APPEND            
4b45 07				db 6 + 1 
4b46 .. 00			db "CREATE",0              
4b4d				endm 
# End of macro CWHEAD
4b4d			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4b4d			; | | e.g.  
4b4d			; | | TestProgram CREATE 
4b4d			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4b4d			; | |  
4b4d			; | | Max file IDs are 255. 
4b4d			; | |  
4b4d					 
4b4d					if DEBUG_FORTH_WORDS_KEY 
4b4d						DMARK "CRT" 
4b4d f5				push af  
4b4e 3a 62 4b			ld a, (.dmark)  
4b51 32 6e fb			ld (debug_mark),a  
4b54 3a 63 4b			ld a, (.dmark+1)  
4b57 32 6f fb			ld (debug_mark+1),a  
4b5a 3a 64 4b			ld a, (.dmark+2)  
4b5d 32 70 fb			ld (debug_mark+2),a  
4b60 18 03			jr .pastdmark  
4b62 ..			.dmark: db "CRT"  
4b65 f1			.pastdmark: pop af  
4b66			endm  
# End of macro DMARK
4b66						CALLMONITOR 
4b66 cd 84 17			call break_point_state  
4b69				endm  
# End of macro CALLMONITOR
4b69					endif 
4b69			;		call storage_get_block_0 
4b69			 
4b69					; TODO pop hl 
4b69			 
4b69					;v5 FORTH_DSP_VALUE 
4b69					FORTH_DSP_VALUE 
4b69 cd c1 1f			call macro_forth_dsp_value 
4b6c				endm 
# End of macro FORTH_DSP_VALUE
4b6c			 
4b6c				if DEBUG_STORESE 
4b6c					DMARK "CR1" 
4b6c f5				push af  
4b6d 3a 81 4b			ld a, (.dmark)  
4b70 32 6e fb			ld (debug_mark),a  
4b73 3a 82 4b			ld a, (.dmark+1)  
4b76 32 6f fb			ld (debug_mark+1),a  
4b79 3a 83 4b			ld a, (.dmark+2)  
4b7c 32 70 fb			ld (debug_mark+2),a  
4b7f 18 03			jr .pastdmark  
4b81 ..			.dmark: db "CR1"  
4b84 f1			.pastdmark: pop af  
4b85			endm  
# End of macro DMARK
4b85					CALLMONITOR 
4b85 cd 84 17			call break_point_state  
4b88				endm  
# End of macro CALLMONITOR
4b88				endif 
4b88			;		push hl 
4b88			;		FORTH_DSP_POP 
4b88			;		pop hl 
4b88			 
4b88			;		inc hl   ; move past the type marker 
4b88			 
4b88 cd be 07				call storage_create 
4b8b			 
4b8b				if DEBUG_STORESE 
4b8b					DMARK "CT1" 
4b8b f5				push af  
4b8c 3a a0 4b			ld a, (.dmark)  
4b8f 32 6e fb			ld (debug_mark),a  
4b92 3a a1 4b			ld a, (.dmark+1)  
4b95 32 6f fb			ld (debug_mark+1),a  
4b98 3a a2 4b			ld a, (.dmark+2)  
4b9b 32 70 fb			ld (debug_mark+2),a  
4b9e 18 03			jr .pastdmark  
4ba0 ..			.dmark: db "CT1"  
4ba3 f1			.pastdmark: pop af  
4ba4			endm  
# End of macro DMARK
4ba4					CALLMONITOR 
4ba4 cd 84 17			call break_point_state  
4ba7				endm  
# End of macro CALLMONITOR
4ba7				endif 
4ba7			;		push hl 
4ba7					FORTH_DSP_POP 
4ba7 cd 90 20			call macro_forth_dsp_pop 
4baa				endm 
# End of macro FORTH_DSP_POP
4baa			;		pop hl 
4baa					; push file id to stack 
4baa cd e1 1d				call forth_push_numhl 
4bad			 
4bad			 
4bad			 
4bad				       NEXTW 
4bad c3 4a 21			jp macro_next 
4bb0				endm 
# End of macro NEXTW
4bb0			 
4bb0			.APPEND: 
4bb0				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4bb0 69				db WORD_SYS_CORE+85             
4bb1 41 4c			dw .SDEL            
4bb3 07				db 6 + 1 
4bb4 .. 00			db "APPEND",0              
4bbb				endm 
# End of macro CWHEAD
4bbb			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4bbb			; | | e.g. 
4bbb			; | | Test CREATE      -> $01 
4bbb			; | | "A string to add to file" $01 APPEND 
4bbb			; | |  
4bbb			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4bbb					if DEBUG_FORTH_WORDS_KEY 
4bbb						DMARK "APP" 
4bbb f5				push af  
4bbc 3a d0 4b			ld a, (.dmark)  
4bbf 32 6e fb			ld (debug_mark),a  
4bc2 3a d1 4b			ld a, (.dmark+1)  
4bc5 32 6f fb			ld (debug_mark+1),a  
4bc8 3a d2 4b			ld a, (.dmark+2)  
4bcb 32 70 fb			ld (debug_mark+2),a  
4bce 18 03			jr .pastdmark  
4bd0 ..			.dmark: db "APP"  
4bd3 f1			.pastdmark: pop af  
4bd4			endm  
# End of macro DMARK
4bd4						CALLMONITOR 
4bd4 cd 84 17			call break_point_state  
4bd7				endm  
# End of macro CALLMONITOR
4bd7					endif 
4bd7			 
4bd7					FORTH_DSP_VALUEHL 
4bd7 cd d8 1f			call macro_dsp_valuehl 
4bda				endm 
# End of macro FORTH_DSP_VALUEHL
4bda e5					push hl 	; save file id 
4bdb			 
4bdb				if DEBUG_STORESE 
4bdb					DMARK "AP1" 
4bdb f5				push af  
4bdc 3a f0 4b			ld a, (.dmark)  
4bdf 32 6e fb			ld (debug_mark),a  
4be2 3a f1 4b			ld a, (.dmark+1)  
4be5 32 6f fb			ld (debug_mark+1),a  
4be8 3a f2 4b			ld a, (.dmark+2)  
4beb 32 70 fb			ld (debug_mark+2),a  
4bee 18 03			jr .pastdmark  
4bf0 ..			.dmark: db "AP1"  
4bf3 f1			.pastdmark: pop af  
4bf4			endm  
# End of macro DMARK
4bf4					CALLMONITOR 
4bf4 cd 84 17			call break_point_state  
4bf7				endm  
# End of macro CALLMONITOR
4bf7				endif 
4bf7					FORTH_DSP_POP 
4bf7 cd 90 20			call macro_forth_dsp_pop 
4bfa				endm 
# End of macro FORTH_DSP_POP
4bfa			 
4bfa					FORTH_DSP_VALUEHL 
4bfa cd d8 1f			call macro_dsp_valuehl 
4bfd				endm 
# End of macro FORTH_DSP_VALUEHL
4bfd					;v5 FORTH_DSP_VALUE 
4bfd e5					push hl 	; save ptr to string to save 
4bfe			 
4bfe				if DEBUG_STORESE 
4bfe					DMARK "AP1" 
4bfe f5				push af  
4bff 3a 13 4c			ld a, (.dmark)  
4c02 32 6e fb			ld (debug_mark),a  
4c05 3a 14 4c			ld a, (.dmark+1)  
4c08 32 6f fb			ld (debug_mark+1),a  
4c0b 3a 15 4c			ld a, (.dmark+2)  
4c0e 32 70 fb			ld (debug_mark+2),a  
4c11 18 03			jr .pastdmark  
4c13 ..			.dmark: db "AP1"  
4c16 f1			.pastdmark: pop af  
4c17			endm  
# End of macro DMARK
4c17					CALLMONITOR 
4c17 cd 84 17			call break_point_state  
4c1a				endm  
# End of macro CALLMONITOR
4c1a				endif 
4c1a					FORTH_DSP_POP 
4c1a cd 90 20			call macro_forth_dsp_pop 
4c1d				endm 
# End of macro FORTH_DSP_POP
4c1d			 
4c1d d1					pop de 
4c1e e1					pop hl 
4c1f				if DEBUG_STORESE 
4c1f					DMARK "AP2" 
4c1f f5				push af  
4c20 3a 34 4c			ld a, (.dmark)  
4c23 32 6e fb			ld (debug_mark),a  
4c26 3a 35 4c			ld a, (.dmark+1)  
4c29 32 6f fb			ld (debug_mark+1),a  
4c2c 3a 36 4c			ld a, (.dmark+2)  
4c2f 32 70 fb			ld (debug_mark+2),a  
4c32 18 03			jr .pastdmark  
4c34 ..			.dmark: db "AP2"  
4c37 f1			.pastdmark: pop af  
4c38			endm  
# End of macro DMARK
4c38					CALLMONITOR 
4c38 cd 84 17			call break_point_state  
4c3b				endm  
# End of macro CALLMONITOR
4c3b				endif 
4c3b					;inc de ; skip var type indicator 
4c3b			 
4c3b					; TODO how to append numerics???? 
4c3b			 
4c3b cd 9d 09				call storage_append		 
4c3e			 
4c3e				       NEXTW 
4c3e c3 4a 21			jp macro_next 
4c41				endm 
# End of macro NEXTW
4c41			.SDEL: 
4c41				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4c41 6a				db WORD_SYS_CORE+86             
4c42 8d 4c			dw .OPEN            
4c44 05				db 4 + 1 
4c45 .. 00			db "ERA",0              
4c49				endm 
# End of macro CWHEAD
4c49			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4c49					FORTH_DSP_VALUEHL 
4c49 cd d8 1f			call macro_dsp_valuehl 
4c4c				endm 
# End of macro FORTH_DSP_VALUEHL
4c4c			;		push hl 	; save file id 
4c4c			 
4c4c					if DEBUG_FORTH_WORDS_KEY 
4c4c						DMARK "ERA" 
4c4c f5				push af  
4c4d 3a 61 4c			ld a, (.dmark)  
4c50 32 6e fb			ld (debug_mark),a  
4c53 3a 62 4c			ld a, (.dmark+1)  
4c56 32 6f fb			ld (debug_mark+1),a  
4c59 3a 63 4c			ld a, (.dmark+2)  
4c5c 32 70 fb			ld (debug_mark+2),a  
4c5f 18 03			jr .pastdmark  
4c61 ..			.dmark: db "ERA"  
4c64 f1			.pastdmark: pop af  
4c65			endm  
# End of macro DMARK
4c65						CALLMONITOR 
4c65 cd 84 17			call break_point_state  
4c68				endm  
# End of macro CALLMONITOR
4c68					endif 
4c68				if DEBUG_STORESE 
4c68					DMARK "ER1" 
4c68 f5				push af  
4c69 3a 7d 4c			ld a, (.dmark)  
4c6c 32 6e fb			ld (debug_mark),a  
4c6f 3a 7e 4c			ld a, (.dmark+1)  
4c72 32 6f fb			ld (debug_mark+1),a  
4c75 3a 7f 4c			ld a, (.dmark+2)  
4c78 32 70 fb			ld (debug_mark+2),a  
4c7b 18 03			jr .pastdmark  
4c7d ..			.dmark: db "ER1"  
4c80 f1			.pastdmark: pop af  
4c81			endm  
# End of macro DMARK
4c81					CALLMONITOR 
4c81 cd 84 17			call break_point_state  
4c84				endm  
# End of macro CALLMONITOR
4c84				endif 
4c84					FORTH_DSP_POP 
4c84 cd 90 20			call macro_forth_dsp_pop 
4c87				endm 
# End of macro FORTH_DSP_POP
4c87			 
4c87			;		pop hl 
4c87			 
4c87 cd fd 05				call storage_erase 
4c8a				       NEXTW 
4c8a c3 4a 21			jp macro_next 
4c8d				endm 
# End of macro NEXTW
4c8d			 
4c8d			.OPEN: 
4c8d				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4c8d 6b				db WORD_SYS_CORE+87             
4c8e 1d 4d			dw .READ            
4c90 05				db 4 + 1 
4c91 .. 00			db "OPEN",0              
4c96				endm 
# End of macro CWHEAD
4c96			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4c96			; | | e.g. 
4c96			; | | $01 OPEN $01 DO $01 READ . LOOP 
4c96			; | | 
4c96			; | | Will return with 255 blocks if the file does not exist 
4c96			 
4c96					if DEBUG_FORTH_WORDS_KEY 
4c96						DMARK "OPN" 
4c96 f5				push af  
4c97 3a ab 4c			ld a, (.dmark)  
4c9a 32 6e fb			ld (debug_mark),a  
4c9d 3a ac 4c			ld a, (.dmark+1)  
4ca0 32 6f fb			ld (debug_mark+1),a  
4ca3 3a ad 4c			ld a, (.dmark+2)  
4ca6 32 70 fb			ld (debug_mark+2),a  
4ca9 18 03			jr .pastdmark  
4cab ..			.dmark: db "OPN"  
4cae f1			.pastdmark: pop af  
4caf			endm  
# End of macro DMARK
4caf						CALLMONITOR 
4caf cd 84 17			call break_point_state  
4cb2				endm  
# End of macro CALLMONITOR
4cb2					endif 
4cb2					; TODO handle multiple file opens 
4cb2			 
4cb2 3e 01			       	ld a, 1 
4cb4 32 50 f8				ld (store_openext), a 
4cb7			 
4cb7					; get max extents for this file 
4cb7				 
4cb7								 
4cb7					FORTH_DSP_VALUEHL 
4cb7 cd d8 1f			call macro_dsp_valuehl 
4cba				endm 
# End of macro FORTH_DSP_VALUEHL
4cba			 
4cba 65					ld h, l 
4cbb 2e 00				ld l, 0 
4cbd			 
4cbd				if DEBUG_STORESE 
4cbd					DMARK "OPN" 
4cbd f5				push af  
4cbe 3a d2 4c			ld a, (.dmark)  
4cc1 32 6e fb			ld (debug_mark),a  
4cc4 3a d3 4c			ld a, (.dmark+1)  
4cc7 32 6f fb			ld (debug_mark+1),a  
4cca 3a d4 4c			ld a, (.dmark+2)  
4ccd 32 70 fb			ld (debug_mark+2),a  
4cd0 18 03			jr .pastdmark  
4cd2 ..			.dmark: db "OPN"  
4cd5 f1			.pastdmark: pop af  
4cd6			endm  
# End of macro DMARK
4cd6					CALLMONITOR 
4cd6 cd 84 17			call break_point_state  
4cd9				endm  
# End of macro CALLMONITOR
4cd9				endif 
4cd9			;		push hl 
4cd9					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4cd9 cd 90 20			call macro_forth_dsp_pop 
4cdc				endm 
# End of macro FORTH_DSP_POP
4cdc			;		pop hl 
4cdc						 
4cdc 11 59 f8				ld de, store_page      ; get block zero of file 
4cdf cd 14 09				call storage_read 
4ce2 cd 06 0e			call ishlzero 
4ce5 20 04			jr nz, .opfound 
4ce7			 
4ce7				; file does not exist so indicate with 255 extents in use 
4ce7			 
4ce7 3e ff			ld a, 255 
4ce9 18 29			jr .skipopeneof 
4ceb			 
4ceb			 
4ceb			.opfound: 
4ceb			 
4ceb			 
4ceb 3a 5b f8				ld a, (store_page+2)    ; max extents for this file 
4cee 32 4f f8				ld  (store_openmaxext), a   ; get our limit and push 
4cf1					 
4cf1				if DEBUG_STORESE 
4cf1					DMARK "OPx" 
4cf1 f5				push af  
4cf2 3a 06 4d			ld a, (.dmark)  
4cf5 32 6e fb			ld (debug_mark),a  
4cf8 3a 07 4d			ld a, (.dmark+1)  
4cfb 32 6f fb			ld (debug_mark+1),a  
4cfe 3a 08 4d			ld a, (.dmark+2)  
4d01 32 70 fb			ld (debug_mark+2),a  
4d04 18 03			jr .pastdmark  
4d06 ..			.dmark: db "OPx"  
4d09 f1			.pastdmark: pop af  
4d0a			endm  
# End of macro DMARK
4d0a					CALLMONITOR 
4d0a cd 84 17			call break_point_state  
4d0d				endm  
# End of macro CALLMONITOR
4d0d				endif 
4d0d fe 00				cp 0 
4d0f 20 03				jr nz, .skipopeneof 
4d11					; have opened an empty file 
4d11					 
4d11 32 50 f8				ld (store_openext), a 
4d14			 
4d14			.skipopeneof: 
4d14			 
4d14 6f					ld l, a 
4d15 26 00				ld h, 0 
4d17 cd e1 1d				call forth_push_numhl 
4d1a			 
4d1a			 
4d1a				       NEXTW 
4d1a c3 4a 21			jp macro_next 
4d1d				endm 
# End of macro NEXTW
4d1d			.READ: 
4d1d				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4d1d 6c				db WORD_SYS_CORE+88             
4d1e 64 4e			dw .EOF            
4d20 05				db 4 + 1 
4d21 .. 00			db "READ",0              
4d26				endm 
# End of macro CWHEAD
4d26			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4d26			; | | e.g. 
4d26			; | | $01 OPEN $01 DO $01 READ . LOOP 
4d26			 
4d26					if DEBUG_FORTH_WORDS_KEY 
4d26						DMARK "REA" 
4d26 f5				push af  
4d27 3a 3b 4d			ld a, (.dmark)  
4d2a 32 6e fb			ld (debug_mark),a  
4d2d 3a 3c 4d			ld a, (.dmark+1)  
4d30 32 6f fb			ld (debug_mark+1),a  
4d33 3a 3d 4d			ld a, (.dmark+2)  
4d36 32 70 fb			ld (debug_mark+2),a  
4d39 18 03			jr .pastdmark  
4d3b ..			.dmark: db "REA"  
4d3e f1			.pastdmark: pop af  
4d3f			endm  
# End of macro DMARK
4d3f						CALLMONITOR 
4d3f cd 84 17			call break_point_state  
4d42				endm  
# End of macro CALLMONITOR
4d42					endif 
4d42					; store_openext use it. If zero it is EOF 
4d42			 
4d42					; read block from current stream id 
4d42					; if the block does not contain zero term keep reading blocks until zero found 
4d42					; push the block to stack 
4d42					; save the block id to stream 
4d42			 
4d42			 
4d42					FORTH_DSP_VALUEHL 
4d42 cd d8 1f			call macro_dsp_valuehl 
4d45				endm 
# End of macro FORTH_DSP_VALUEHL
4d45			 
4d45			;		push hl 
4d45			 
4d45				if DEBUG_STORESE 
4d45					DMARK "REA" 
4d45 f5				push af  
4d46 3a 5a 4d			ld a, (.dmark)  
4d49 32 6e fb			ld (debug_mark),a  
4d4c 3a 5b 4d			ld a, (.dmark+1)  
4d4f 32 6f fb			ld (debug_mark+1),a  
4d52 3a 5c 4d			ld a, (.dmark+2)  
4d55 32 70 fb			ld (debug_mark+2),a  
4d58 18 03			jr .pastdmark  
4d5a ..			.dmark: db "REA"  
4d5d f1			.pastdmark: pop af  
4d5e			endm  
# End of macro DMARK
4d5e					CALLMONITOR 
4d5e cd 84 17			call break_point_state  
4d61				endm  
# End of macro CALLMONITOR
4d61				endif 
4d61					FORTH_DSP_POP 
4d61 cd 90 20			call macro_forth_dsp_pop 
4d64				endm 
# End of macro FORTH_DSP_POP
4d64			 
4d64			;		pop hl 
4d64				 
4d64 65					ld h,l 
4d65			 
4d65 3a 50 f8				ld a, (store_openext) 
4d68 6f					ld l, a 
4d69					 
4d69 fe 00				cp 0 
4d6b ca 36 4e				jp z, .ateof     ; dont read past eof 
4d6e			 
4d6e			 
4d6e 11 59 f8				ld de, store_page 
4d71				if DEBUG_STORESE 
4d71					DMARK "RE1" 
4d71 f5				push af  
4d72 3a 86 4d			ld a, (.dmark)  
4d75 32 6e fb			ld (debug_mark),a  
4d78 3a 87 4d			ld a, (.dmark+1)  
4d7b 32 6f fb			ld (debug_mark+1),a  
4d7e 3a 88 4d			ld a, (.dmark+2)  
4d81 32 70 fb			ld (debug_mark+2),a  
4d84 18 03			jr .pastdmark  
4d86 ..			.dmark: db "RE1"  
4d89 f1			.pastdmark: pop af  
4d8a			endm  
# End of macro DMARK
4d8a					CALLMONITOR 
4d8a cd 84 17			call break_point_state  
4d8d				endm  
# End of macro CALLMONITOR
4d8d				endif 
4d8d cd 14 09				call storage_read 
4d90			 
4d90				if DEBUG_STORESE 
4d90					DMARK "RE2" 
4d90 f5				push af  
4d91 3a a5 4d			ld a, (.dmark)  
4d94 32 6e fb			ld (debug_mark),a  
4d97 3a a6 4d			ld a, (.dmark+1)  
4d9a 32 6f fb			ld (debug_mark+1),a  
4d9d 3a a7 4d			ld a, (.dmark+2)  
4da0 32 70 fb			ld (debug_mark+2),a  
4da3 18 03			jr .pastdmark  
4da5 ..			.dmark: db "RE2"  
4da8 f1			.pastdmark: pop af  
4da9			endm  
# End of macro DMARK
4da9					CALLMONITOR 
4da9 cd 84 17			call break_point_state  
4dac				endm  
# End of macro CALLMONITOR
4dac				endif 
4dac cd 06 0e			call ishlzero 
4daf			;	ld a, l 
4daf			;	add h 
4daf			;	cp 0 
4daf ca 3c 4e			jp z, .readeof 
4db2			 
4db2				; not eof so hl should point to data to push to stack 
4db2			 
4db2				if DEBUG_STORESE 
4db2					DMARK "RE3" 
4db2 f5				push af  
4db3 3a c7 4d			ld a, (.dmark)  
4db6 32 6e fb			ld (debug_mark),a  
4db9 3a c8 4d			ld a, (.dmark+1)  
4dbc 32 6f fb			ld (debug_mark+1),a  
4dbf 3a c9 4d			ld a, (.dmark+2)  
4dc2 32 70 fb			ld (debug_mark+2),a  
4dc5 18 03			jr .pastdmark  
4dc7 ..			.dmark: db "RE3"  
4dca f1			.pastdmark: pop af  
4dcb			endm  
# End of macro DMARK
4dcb					CALLMONITOR 
4dcb cd 84 17			call break_point_state  
4dce				endm  
# End of macro CALLMONITOR
4dce				endif 
4dce cd 4f 1e			call forth_push_str 
4dd1			 
4dd1				if DEBUG_STORESE 
4dd1					DMARK "RE4" 
4dd1 f5				push af  
4dd2 3a e6 4d			ld a, (.dmark)  
4dd5 32 6e fb			ld (debug_mark),a  
4dd8 3a e7 4d			ld a, (.dmark+1)  
4ddb 32 6f fb			ld (debug_mark+1),a  
4dde 3a e8 4d			ld a, (.dmark+2)  
4de1 32 70 fb			ld (debug_mark+2),a  
4de4 18 03			jr .pastdmark  
4de6 ..			.dmark: db "RE4"  
4de9 f1			.pastdmark: pop af  
4dea			endm  
# End of macro DMARK
4dea					CALLMONITOR 
4dea cd 84 17			call break_point_state  
4ded				endm  
# End of macro CALLMONITOR
4ded				endif 
4ded				; get next block  or mark as eof 
4ded			 
4ded 3a 4f f8			ld a, (store_openmaxext)   ; get our limit 
4df0 4f				ld c, a	 
4df1 3a 50 f8			ld a, (store_openext) 
4df4			 
4df4				if DEBUG_STORESE 
4df4					DMARK "RE5" 
4df4 f5				push af  
4df5 3a 09 4e			ld a, (.dmark)  
4df8 32 6e fb			ld (debug_mark),a  
4dfb 3a 0a 4e			ld a, (.dmark+1)  
4dfe 32 6f fb			ld (debug_mark+1),a  
4e01 3a 0b 4e			ld a, (.dmark+2)  
4e04 32 70 fb			ld (debug_mark+2),a  
4e07 18 03			jr .pastdmark  
4e09 ..			.dmark: db "RE5"  
4e0c f1			.pastdmark: pop af  
4e0d			endm  
# End of macro DMARK
4e0d					CALLMONITOR 
4e0d cd 84 17			call break_point_state  
4e10				endm  
# End of macro CALLMONITOR
4e10				endif 
4e10 b9				cp c 
4e11 28 29			jr z, .readeof     ; at last extent 
4e13			 
4e13 3c					inc a 
4e14 32 50 f8				ld (store_openext), a 
4e17			 
4e17				if DEBUG_STORESE 
4e17					DMARK "RE6" 
4e17 f5				push af  
4e18 3a 2c 4e			ld a, (.dmark)  
4e1b 32 6e fb			ld (debug_mark),a  
4e1e 3a 2d 4e			ld a, (.dmark+1)  
4e21 32 6f fb			ld (debug_mark+1),a  
4e24 3a 2e 4e			ld a, (.dmark+2)  
4e27 32 70 fb			ld (debug_mark+2),a  
4e2a 18 03			jr .pastdmark  
4e2c ..			.dmark: db "RE6"  
4e2f f1			.pastdmark: pop af  
4e30			endm  
# End of macro DMARK
4e30					CALLMONITOR 
4e30 cd 84 17			call break_point_state  
4e33				endm  
# End of macro CALLMONITOR
4e33				endif 
4e33			 
4e33			 
4e33				       NEXTW 
4e33 c3 4a 21			jp macro_next 
4e36				endm 
# End of macro NEXTW
4e36			.ateof: 
4e36 21 60 4e				ld hl, .showeof 
4e39 cd 4f 1e				call forth_push_str 
4e3c 3e 00		.readeof:	ld a, 0 
4e3e 32 50 f8				ld (store_openext), a 
4e41			 
4e41					 
4e41				if DEBUG_STORESE 
4e41					DMARK "REF" 
4e41 f5				push af  
4e42 3a 56 4e			ld a, (.dmark)  
4e45 32 6e fb			ld (debug_mark),a  
4e48 3a 57 4e			ld a, (.dmark+1)  
4e4b 32 6f fb			ld (debug_mark+1),a  
4e4e 3a 58 4e			ld a, (.dmark+2)  
4e51 32 70 fb			ld (debug_mark+2),a  
4e54 18 03			jr .pastdmark  
4e56 ..			.dmark: db "REF"  
4e59 f1			.pastdmark: pop af  
4e5a			endm  
# End of macro DMARK
4e5a					CALLMONITOR 
4e5a cd 84 17			call break_point_state  
4e5d				endm  
# End of macro CALLMONITOR
4e5d				endif 
4e5d				       NEXTW 
4e5d c3 4a 21			jp macro_next 
4e60				endm 
# End of macro NEXTW
4e60			 
4e60 .. 00		.showeof:   db "eof", 0 
4e64			 
4e64			 
4e64			.EOF: 
4e64				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4e64 6d				db WORD_SYS_CORE+89             
4e65 a5 4e			dw .FORMAT            
4e67 04				db 3 + 1 
4e68 .. 00			db "EOF",0              
4e6c				endm 
# End of macro CWHEAD
4e6c			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4e6c			; | | e.g. 
4e6c			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4e6c					; TODO if current block id for stream is zero then push true else false 
4e6c			 
4e6c					if DEBUG_FORTH_WORDS_KEY 
4e6c						DMARK "EOF" 
4e6c f5				push af  
4e6d 3a 81 4e			ld a, (.dmark)  
4e70 32 6e fb			ld (debug_mark),a  
4e73 3a 82 4e			ld a, (.dmark+1)  
4e76 32 6f fb			ld (debug_mark+1),a  
4e79 3a 83 4e			ld a, (.dmark+2)  
4e7c 32 70 fb			ld (debug_mark+2),a  
4e7f 18 03			jr .pastdmark  
4e81 ..			.dmark: db "EOF"  
4e84 f1			.pastdmark: pop af  
4e85			endm  
# End of macro DMARK
4e85						CALLMONITOR 
4e85 cd 84 17			call break_point_state  
4e88				endm  
# End of macro CALLMONITOR
4e88					endif 
4e88			 
4e88					; TODO handlue multiple file streams 
4e88			 
4e88					FORTH_DSP_POP     ; for now just get rid of stream id 
4e88 cd 90 20			call macro_forth_dsp_pop 
4e8b				endm 
# End of macro FORTH_DSP_POP
4e8b			 
4e8b 2e 01				ld l, 1 
4e8d 3a 4f f8				ld a, (store_openmaxext) 
4e90 fe 00				cp 0 
4e92 28 09				jr  z, .eofdone   ; empty file 
4e94 3a 50 f8				ld a, (store_openext) 
4e97 fe 00				cp 0 
4e99 28 02				jr  z, .eofdone 
4e9b 2e 00				ld l, 0 
4e9d 26 00		.eofdone:	ld h, 0 
4e9f cd e1 1d				call forth_push_numhl 
4ea2			 
4ea2			 
4ea2				       NEXTW 
4ea2 c3 4a 21			jp macro_next 
4ea5				endm 
# End of macro NEXTW
4ea5			 
4ea5			.FORMAT: 
4ea5				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4ea5 6d				db WORD_SYS_CORE+89             
4ea6 f6 4e			dw .LABEL            
4ea8 07				db 6 + 1 
4ea9 .. 00			db "FORMAT",0              
4eb0				endm 
# End of macro CWHEAD
4eb0			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4eb0					; TODO if current block id for stream is zero then push true else false 
4eb0				 
4eb0				if DEBUG_STORESE 
4eb0					DMARK "FOR" 
4eb0 f5				push af  
4eb1 3a c5 4e			ld a, (.dmark)  
4eb4 32 6e fb			ld (debug_mark),a  
4eb7 3a c6 4e			ld a, (.dmark+1)  
4eba 32 6f fb			ld (debug_mark+1),a  
4ebd 3a c7 4e			ld a, (.dmark+2)  
4ec0 32 70 fb			ld (debug_mark+2),a  
4ec3 18 03			jr .pastdmark  
4ec5 ..			.dmark: db "FOR"  
4ec8 f1			.pastdmark: pop af  
4ec9			endm  
# End of macro DMARK
4ec9					CALLMONITOR 
4ec9 cd 84 17			call break_point_state  
4ecc				endm  
# End of macro CALLMONITOR
4ecc				endif 
4ecc					; Wipes the bank check flags to cause a reformat on next block 0 read 
4ecc			 
4ecc 21 01 00				ld hl, 1 
4ecf 3e 00				ld a, 0 
4ed1 cd c0 01				call se_writebyte 
4ed4			 
4ed4				if DEBUG_STORESE 
4ed4					DMARK "FO0" 
4ed4 f5				push af  
4ed5 3a e9 4e			ld a, (.dmark)  
4ed8 32 6e fb			ld (debug_mark),a  
4edb 3a ea 4e			ld a, (.dmark+1)  
4ede 32 6f fb			ld (debug_mark+1),a  
4ee1 3a eb 4e			ld a, (.dmark+2)  
4ee4 32 70 fb			ld (debug_mark+2),a  
4ee7 18 03			jr .pastdmark  
4ee9 ..			.dmark: db "FO0"  
4eec f1			.pastdmark: pop af  
4eed			endm  
# End of macro DMARK
4eed					CALLMONITOR 
4eed cd 84 17			call break_point_state  
4ef0				endm  
# End of macro CALLMONITOR
4ef0				endif 
4ef0					; force bank init 
4ef0			 
4ef0 cd 6c 04				call storage_get_block_0 
4ef3					 
4ef3				       NEXTW 
4ef3 c3 4a 21			jp macro_next 
4ef6				endm 
# End of macro NEXTW
4ef6			.LABEL: 
4ef6				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4ef6 6d				db WORD_SYS_CORE+89             
4ef7 44 4f			dw .STOREPAGE            
4ef9 06				db 5 + 1 
4efa .. 00			db "LABEL",0              
4f00				endm 
# End of macro CWHEAD
4f00			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4f00					; TODO test to see if bank is selected 
4f00				 
4f00					if DEBUG_FORTH_WORDS_KEY 
4f00						DMARK "LBL" 
4f00 f5				push af  
4f01 3a 15 4f			ld a, (.dmark)  
4f04 32 6e fb			ld (debug_mark),a  
4f07 3a 16 4f			ld a, (.dmark+1)  
4f0a 32 6f fb			ld (debug_mark+1),a  
4f0d 3a 17 4f			ld a, (.dmark+2)  
4f10 32 70 fb			ld (debug_mark+2),a  
4f13 18 03			jr .pastdmark  
4f15 ..			.dmark: db "LBL"  
4f18 f1			.pastdmark: pop af  
4f19			endm  
# End of macro DMARK
4f19						CALLMONITOR 
4f19 cd 84 17			call break_point_state  
4f1c				endm  
# End of macro CALLMONITOR
4f1c					endif 
4f1c			;	if DEBUG_STORESE 
4f1c			;		DMARK "LBL" 
4f1c			;		CALLMONITOR 
4f1c			;	endif 
4f1c					FORTH_DSP_VALUEHL 
4f1c cd d8 1f			call macro_dsp_valuehl 
4f1f				endm 
# End of macro FORTH_DSP_VALUEHL
4f1f					;v5FORTH_DSP_VALUE 
4f1f					 
4f1f			;		push hl 
4f1f					FORTH_DSP_POP 
4f1f cd 90 20			call macro_forth_dsp_pop 
4f22				endm 
# End of macro FORTH_DSP_POP
4f22			;		pop hl 
4f22			 
4f22			;v5		inc hl   ; move past the type marker 
4f22			 
4f22				if DEBUG_STORESE 
4f22					DMARK "LBl" 
4f22 f5				push af  
4f23 3a 37 4f			ld a, (.dmark)  
4f26 32 6e fb			ld (debug_mark),a  
4f29 3a 38 4f			ld a, (.dmark+1)  
4f2c 32 6f fb			ld (debug_mark+1),a  
4f2f 3a 39 4f			ld a, (.dmark+2)  
4f32 32 70 fb			ld (debug_mark+2),a  
4f35 18 03			jr .pastdmark  
4f37 ..			.dmark: db "LBl"  
4f3a f1			.pastdmark: pop af  
4f3b			endm  
# End of macro DMARK
4f3b					CALLMONITOR 
4f3b cd 84 17			call break_point_state  
4f3e				endm  
# End of macro CALLMONITOR
4f3e				endif 
4f3e cd 90 05				call storage_label 
4f41			 
4f41				       NEXTW 
4f41 c3 4a 21			jp macro_next 
4f44				endm 
# End of macro NEXTW
4f44			.STOREPAGE: 
4f44				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4f44 6d				db WORD_SYS_CORE+89             
4f45 77 4f			dw .LABELS            
4f47 0a				db 9 + 1 
4f48 .. 00			db "STOREPAGE",0              
4f52				endm 
# End of macro CWHEAD
4f52			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4f52					; TODO test to see if bank is selected 
4f52				 
4f52					if DEBUG_FORTH_WORDS_KEY 
4f52						DMARK "STP" 
4f52 f5				push af  
4f53 3a 67 4f			ld a, (.dmark)  
4f56 32 6e fb			ld (debug_mark),a  
4f59 3a 68 4f			ld a, (.dmark+1)  
4f5c 32 6f fb			ld (debug_mark+1),a  
4f5f 3a 69 4f			ld a, (.dmark+2)  
4f62 32 70 fb			ld (debug_mark+2),a  
4f65 18 03			jr .pastdmark  
4f67 ..			.dmark: db "STP"  
4f6a f1			.pastdmark: pop af  
4f6b			endm  
# End of macro DMARK
4f6b						CALLMONITOR 
4f6b cd 84 17			call break_point_state  
4f6e				endm  
# End of macro CALLMONITOR
4f6e					endif 
4f6e			;	if DEBUG_STORESE 
4f6e			;		DMARK "STP" 
4f6e			;		CALLMONITOR 
4f6e			;	endif 
4f6e			 
4f6e 21 59 f8			ld hl, store_page 
4f71 cd e1 1d			call forth_push_numhl 
4f74			 
4f74			 
4f74				       NEXTW 
4f74 c3 4a 21			jp macro_next 
4f77				endm 
# End of macro NEXTW
4f77			.LABELS: 
4f77				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4f77 6d				db WORD_SYS_CORE+89             
4f78 01 50			dw .ENDSTORAGE            
4f7a 07				db 6 + 1 
4f7b .. 00			db "LABELS",0              
4f82				endm 
# End of macro CWHEAD
4f82			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4f82					;  
4f82			 
4f82					; save the current device selected to restore afterwards 
4f82				 
4f82 3a 3f f8				ld a, (spi_device) 
4f85 f5					push af 
4f86			 
4f86			 
4f86					; run through each of the banks 
4f86			 
4f86 21 01 00				ld hl, 1 
4f89 cd e1 1d				call forth_push_numhl 
4f8c 3e ff				ld a, SPI_CE_HIGH 
4f8e cb 87				res SPI_CE0, a 
4f90 32 3f f8				ld (spi_device), a 
4f93 cd 6c 04				call storage_get_block_0 
4f96 21 5c f8				ld hl, store_page+3 
4f99 cd 4f 1e				call forth_push_str 
4f9c			 
4f9c					 
4f9c 21 02 00				ld hl, 2 
4f9f cd e1 1d				call forth_push_numhl 
4fa2 3e ff				ld a, SPI_CE_HIGH 
4fa4 cb 8f				res SPI_CE1, a 
4fa6 32 3f f8				ld (spi_device), a 
4fa9 cd 6c 04				call storage_get_block_0 
4fac 21 5c f8				ld hl, store_page+3 
4faf cd 4f 1e				call forth_push_str 
4fb2			 
4fb2					 
4fb2 21 03 00				ld hl, 3 
4fb5 cd e1 1d				call forth_push_numhl 
4fb8 3e ff				ld a, SPI_CE_HIGH 
4fba cb 97				res SPI_CE2, a 
4fbc 32 3f f8				ld (spi_device), a 
4fbf cd 6c 04				call storage_get_block_0 
4fc2 21 5c f8				ld hl, store_page+3 
4fc5 cd 4f 1e				call forth_push_str 
4fc8			 
4fc8			 
4fc8 21 04 00				ld hl, 4 
4fcb cd e1 1d				call forth_push_numhl 
4fce 3e ff				ld a, SPI_CE_HIGH 
4fd0 cb 9f				res SPI_CE3, a 
4fd2 32 3f f8				ld (spi_device), a 
4fd5 cd 6c 04				call storage_get_block_0 
4fd8 21 5c f8				ld hl, store_page+3 
4fdb cd 4f 1e				call forth_push_str 
4fde			 
4fde					 
4fde			 
4fde 21 05 00				ld hl, 5 
4fe1 cd e1 1d				call forth_push_numhl 
4fe4 3e ff				ld a, SPI_CE_HIGH 
4fe6 cb a7				res SPI_CE4, a 
4fe8 32 3f f8				ld (spi_device), a 
4feb cd 6c 04				call storage_get_block_0 
4fee 21 5c f8				ld hl, store_page+3 
4ff1 cd 4f 1e				call forth_push_str 
4ff4			 
4ff4					 
4ff4					; push fixed count of storage devices (on board) for now 
4ff4			 
4ff4 21 05 00				ld hl, 5 
4ff7 cd e1 1d				call forth_push_numhl 
4ffa			 
4ffa					; restore selected device  
4ffa				 
4ffa f1					pop af 
4ffb 32 3f f8				ld (spi_device), a 
4ffe			 
4ffe				       NEXTW 
4ffe c3 4a 21			jp macro_next 
5001				endm 
# End of macro NEXTW
5001			 
5001			.ENDSTORAGE: 
5001			; eof 
# End of file forth_words_storage.asm
5001			endif 
5001				include "forth_words_device.asm" 
5001			; Device related words 
5001			 
5001			; | ## Device Words 
5001			 
5001			if SOUND_ENABLE 
5001			.NOTE: 
5001				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5001 33				db WORD_SYS_CORE+31             
5002 29 50			dw .AFTERSOUND            
5004 05				db 4 + 1 
5005 .. 00			db "NOTE",0              
500a				endm 
# End of macro CWHEAD
500a			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
500a					if DEBUG_FORTH_WORDS_KEY 
500a						DMARK "NTE" 
500a f5				push af  
500b 3a 1f 50			ld a, (.dmark)  
500e 32 6e fb			ld (debug_mark),a  
5011 3a 20 50			ld a, (.dmark+1)  
5014 32 6f fb			ld (debug_mark+1),a  
5017 3a 21 50			ld a, (.dmark+2)  
501a 32 70 fb			ld (debug_mark+2),a  
501d 18 03			jr .pastdmark  
501f ..			.dmark: db "NTE"  
5022 f1			.pastdmark: pop af  
5023			endm  
# End of macro DMARK
5023						CALLMONITOR 
5023 cd 84 17			call break_point_state  
5026				endm  
# End of macro CALLMONITOR
5026					endif 
5026			 
5026				 
5026			 
5026					NEXTW 
5026 c3 4a 21			jp macro_next 
5029				endm 
# End of macro NEXTW
5029			.AFTERSOUND: 
5029			endif 
5029			 
5029			 
5029			USE_GPIO: equ 0 
5029			 
5029			if USE_GPIO 
5029			.GP1: 
5029				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5029			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5029					NEXTW 
5029			.GP2: 
5029				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5029			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5029			 
5029					NEXTW 
5029			 
5029			.GP3: 
5029				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5029			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5029			 
5029					NEXTW 
5029			 
5029			.GP4: 
5029				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5029			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5029			 
5029					NEXTW 
5029			.SIN: 
5029			 
5029			 
5029			endif 
5029			 
5029			 
5029				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5029 33				db WORD_SYS_CORE+31             
502a 5e 50			dw .SOUT            
502c 03				db 2 + 1 
502d .. 00			db "IN",0              
5030				endm 
# End of macro CWHEAD
5030			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5030					if DEBUG_FORTH_WORDS_KEY 
5030						DMARK "IN." 
5030 f5				push af  
5031 3a 45 50			ld a, (.dmark)  
5034 32 6e fb			ld (debug_mark),a  
5037 3a 46 50			ld a, (.dmark+1)  
503a 32 6f fb			ld (debug_mark+1),a  
503d 3a 47 50			ld a, (.dmark+2)  
5040 32 70 fb			ld (debug_mark+2),a  
5043 18 03			jr .pastdmark  
5045 ..			.dmark: db "IN."  
5048 f1			.pastdmark: pop af  
5049			endm  
# End of macro DMARK
5049						CALLMONITOR 
5049 cd 84 17			call break_point_state  
504c				endm  
# End of macro CALLMONITOR
504c					endif 
504c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
504c cd d8 1f			call macro_dsp_valuehl 
504f				endm 
# End of macro FORTH_DSP_VALUEHL
504f			 
504f e5					push hl 
5050			 
5050					; destroy value TOS 
5050			 
5050					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5050 cd 90 20			call macro_forth_dsp_pop 
5053				endm 
# End of macro FORTH_DSP_POP
5053			 
5053					; one value on hl get other one back 
5053			 
5053 c1					pop bc 
5054			 
5054					; do the sub 
5054			;		ex de, hl 
5054			 
5054 ed 68				in l,(c) 
5056			 
5056					; save it 
5056			 
5056 26 00				ld h,0 
5058			 
5058					; TODO push value back onto stack for another op etc 
5058			 
5058 cd e1 1d				call forth_push_numhl 
505b					NEXTW 
505b c3 4a 21			jp macro_next 
505e				endm 
# End of macro NEXTW
505e			.SOUT: 
505e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
505e 34				db WORD_SYS_CORE+32             
505f b1 50			dw .SPIO            
5061 04				db 3 + 1 
5062 .. 00			db "OUT",0              
5066				endm 
# End of macro CWHEAD
5066			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5066					if DEBUG_FORTH_WORDS_KEY 
5066						DMARK "OUT" 
5066 f5				push af  
5067 3a 7b 50			ld a, (.dmark)  
506a 32 6e fb			ld (debug_mark),a  
506d 3a 7c 50			ld a, (.dmark+1)  
5070 32 6f fb			ld (debug_mark+1),a  
5073 3a 7d 50			ld a, (.dmark+2)  
5076 32 70 fb			ld (debug_mark+2),a  
5079 18 03			jr .pastdmark  
507b ..			.dmark: db "OUT"  
507e f1			.pastdmark: pop af  
507f			endm  
# End of macro DMARK
507f						CALLMONITOR 
507f cd 84 17			call break_point_state  
5082				endm  
# End of macro CALLMONITOR
5082					endif 
5082			 
5082					; get port 
5082			 
5082					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5082 cd d8 1f			call macro_dsp_valuehl 
5085				endm 
# End of macro FORTH_DSP_VALUEHL
5085			 
5085 e5					push hl 
5086			 
5086					; destroy value TOS 
5086			 
5086					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5086 cd 90 20			call macro_forth_dsp_pop 
5089				endm 
# End of macro FORTH_DSP_POP
5089			 
5089					; get byte to send 
5089			 
5089					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5089 cd d8 1f			call macro_dsp_valuehl 
508c				endm 
# End of macro FORTH_DSP_VALUEHL
508c			 
508c			;		push hl 
508c			 
508c					; destroy value TOS 
508c			 
508c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
508c cd 90 20			call macro_forth_dsp_pop 
508f				endm 
# End of macro FORTH_DSP_POP
508f			 
508f					; one value on hl get other one back 
508f			 
508f			;		pop hl 
508f			 
508f c1					pop bc 
5090			 
5090					if DEBUG_FORTH_WORDS 
5090						DMARK "OUT" 
5090 f5				push af  
5091 3a a5 50			ld a, (.dmark)  
5094 32 6e fb			ld (debug_mark),a  
5097 3a a6 50			ld a, (.dmark+1)  
509a 32 6f fb			ld (debug_mark+1),a  
509d 3a a7 50			ld a, (.dmark+2)  
50a0 32 70 fb			ld (debug_mark+2),a  
50a3 18 03			jr .pastdmark  
50a5 ..			.dmark: db "OUT"  
50a8 f1			.pastdmark: pop af  
50a9			endm  
# End of macro DMARK
50a9						CALLMONITOR 
50a9 cd 84 17			call break_point_state  
50ac				endm  
# End of macro CALLMONITOR
50ac					endif 
50ac			 
50ac ed 69				out (c), l 
50ae			 
50ae					NEXTW 
50ae c3 4a 21			jp macro_next 
50b1				endm 
# End of macro NEXTW
50b1			 
50b1			 
50b1			.SPIO: 
50b1			 
50b1			if STORAGE_SE 
50b1				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
50b1 51				db WORD_SYS_CORE+61             
50b2 c2 50			dw .SPICEH            
50b4 07				db 6 + 1 
50b5 .. 00			db "SPICEL",0              
50bc				endm 
# End of macro CWHEAD
50bc			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
50bc			 
50bc cd 6e 01				call spi_ce_low 
50bf			    NEXTW 
50bf c3 4a 21			jp macro_next 
50c2				endm 
# End of macro NEXTW
50c2			 
50c2			.SPICEH: 
50c2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
50c2 51				db WORD_SYS_CORE+61             
50c3 d3 50			dw .SPIOb            
50c5 07				db 6 + 1 
50c6 .. 00			db "SPICEH",0              
50cd				endm 
# End of macro CWHEAD
50cd			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
50cd			 
50cd cd 5d 01				call spi_ce_high 
50d0			    NEXTW 
50d0 c3 4a 21			jp macro_next 
50d3				endm 
# End of macro NEXTW
50d3			 
50d3			 
50d3			.SPIOb: 
50d3			 
50d3				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
50d3 51				db WORD_SYS_CORE+61             
50d4 e9 50			dw .SPII            
50d6 05				db 4 + 1 
50d7 .. 00			db "SPIO",0              
50dc				endm 
# End of macro CWHEAD
50dc			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
50dc			 
50dc					; get port 
50dc			 
50dc			 
50dc					; get byte to send 
50dc			 
50dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50dc cd d8 1f			call macro_dsp_valuehl 
50df				endm 
# End of macro FORTH_DSP_VALUEHL
50df			 
50df			;		push hl    ; u1  
50df			 
50df					; destroy value TOS 
50df			 
50df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50df cd 90 20			call macro_forth_dsp_pop 
50e2				endm 
# End of macro FORTH_DSP_POP
50e2			 
50e2					; one value on hl get other one back 
50e2			 
50e2			;		pop hl   ; u2 - addr 
50e2			 
50e2					; TODO Send SPI byte 
50e2			 
50e2 7d					ld a, l 
50e3 cd 92 00				call spi_send_byte 
50e6			 
50e6					NEXTW 
50e6 c3 4a 21			jp macro_next 
50e9				endm 
# End of macro NEXTW
50e9			 
50e9			.SPII: 
50e9				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
50e9 52				db WORD_SYS_CORE+62             
50ea fe 50			dw .SESEL            
50ec 06				db 5 + 1 
50ed .. 00			db "SPII",0              
50f2				endm 
# End of macro CWHEAD
50f2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
50f2			 
50f2					; TODO Get SPI byte 
50f2			 
50f2 cd b3 00				call spi_read_byte 
50f5			 
50f5 26 00				ld h, 0 
50f7 6f					ld l, a 
50f8 cd e1 1d				call forth_push_numhl 
50fb			 
50fb					NEXTW 
50fb c3 4a 21			jp macro_next 
50fe				endm 
# End of macro NEXTW
50fe			 
50fe			 
50fe			 
50fe			.SESEL: 
50fe				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
50fe 66				db WORD_SYS_CORE+82             
50ff a2 51			dw .CARTDEV            
5101 05				db 4 + 1 
5102 .. 00			db "BANK",0              
5107				endm 
# End of macro CWHEAD
5107			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5107					if DEBUG_FORTH_WORDS_KEY 
5107						DMARK "BNK" 
5107 f5				push af  
5108 3a 1c 51			ld a, (.dmark)  
510b 32 6e fb			ld (debug_mark),a  
510e 3a 1d 51			ld a, (.dmark+1)  
5111 32 6f fb			ld (debug_mark+1),a  
5114 3a 1e 51			ld a, (.dmark+2)  
5117 32 70 fb			ld (debug_mark+2),a  
511a 18 03			jr .pastdmark  
511c ..			.dmark: db "BNK"  
511f f1			.pastdmark: pop af  
5120			endm  
# End of macro DMARK
5120						CALLMONITOR 
5120 cd 84 17			call break_point_state  
5123				endm  
# End of macro CALLMONITOR
5123					endif 
5123			 
5123 3e ff				ld a, 255 
5125 32 42 f8				ld (spi_cartdev), a 
5128			 
5128					; get bank 
5128			 
5128					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5128 cd d8 1f			call macro_dsp_valuehl 
512b				endm 
# End of macro FORTH_DSP_VALUEHL
512b			 
512b			;		push hl 
512b			 
512b					; destroy value TOS 
512b			 
512b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
512b cd 90 20			call macro_forth_dsp_pop 
512e				endm 
# End of macro FORTH_DSP_POP
512e			 
512e					; one value on hl get other one back 
512e			 
512e			;		pop hl 
512e			 
512e			 
512e 0e ff				ld c, SPI_CE_HIGH 
5130 06 30				ld b, '0'    ; human readable bank number 
5132			 
5132 7d					ld a, l 
5133			 
5133					if DEBUG_FORTH_WORDS 
5133						DMARK "BNK" 
5133 f5				push af  
5134 3a 48 51			ld a, (.dmark)  
5137 32 6e fb			ld (debug_mark),a  
513a 3a 49 51			ld a, (.dmark+1)  
513d 32 6f fb			ld (debug_mark+1),a  
5140 3a 4a 51			ld a, (.dmark+2)  
5143 32 70 fb			ld (debug_mark+2),a  
5146 18 03			jr .pastdmark  
5148 ..			.dmark: db "BNK"  
514b f1			.pastdmark: pop af  
514c			endm  
# End of macro DMARK
514c						CALLMONITOR 
514c cd 84 17			call break_point_state  
514f				endm  
# End of macro CALLMONITOR
514f					endif 
514f			 
514f					; active low 
514f			 
514f fe 00				cp 0 
5151 28 28				jr z, .bset 
5153 fe 01				cp 1 
5155 20 04				jr nz, .b2 
5157 cb 81				res 0, c 
5159 06 31				ld b, '1'    ; human readable bank number 
515b fe 02		.b2:		cp 2 
515d 20 04				jr nz, .b3 
515f cb 89				res 1, c 
5161 06 32				ld b, '2'    ; human readable bank number 
5163 fe 03		.b3:		cp 3 
5165 20 04				jr nz, .b4 
5167 cb 91				res 2, c 
5169 06 33				ld b, '3'    ; human readable bank number 
516b fe 04		.b4:		cp 4 
516d 20 04				jr nz, .b5 
516f cb 99				res 3, c 
5171 06 34				ld b, '4'    ; human readable bank number 
5173 fe 05		.b5:		cp 5 
5175 20 04				jr nz, .bset 
5177 cb a1				res 4, c 
5179 06 35				ld b, '5'    ; human readable bank number 
517b			 
517b			.bset: 
517b 79					ld a, c 
517c 32 3f f8				ld (spi_device),a 
517f 78					ld a, b 
5180 32 3e f8				ld (spi_device_id),a 
5183					if DEBUG_FORTH_WORDS 
5183						DMARK "BN2" 
5183 f5				push af  
5184 3a 98 51			ld a, (.dmark)  
5187 32 6e fb			ld (debug_mark),a  
518a 3a 99 51			ld a, (.dmark+1)  
518d 32 6f fb			ld (debug_mark+1),a  
5190 3a 9a 51			ld a, (.dmark+2)  
5193 32 70 fb			ld (debug_mark+2),a  
5196 18 03			jr .pastdmark  
5198 ..			.dmark: db "BN2"  
519b f1			.pastdmark: pop af  
519c			endm  
# End of macro DMARK
519c						CALLMONITOR 
519c cd 84 17			call break_point_state  
519f				endm  
# End of macro CALLMONITOR
519f					endif 
519f			 
519f					NEXTW 
519f c3 4a 21			jp macro_next 
51a2				endm 
# End of macro NEXTW
51a2			 
51a2			.CARTDEV: 
51a2				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
51a2 66				db WORD_SYS_CORE+82             
51a3 4b 52			dw .ENDDEVICE            
51a5 08				db 7 + 1 
51a6 .. 00			db "CARTDEV",0              
51ae				endm 
# End of macro CWHEAD
51ae			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
51ae					if DEBUG_FORTH_WORDS_KEY 
51ae						DMARK "CDV" 
51ae f5				push af  
51af 3a c3 51			ld a, (.dmark)  
51b2 32 6e fb			ld (debug_mark),a  
51b5 3a c4 51			ld a, (.dmark+1)  
51b8 32 6f fb			ld (debug_mark+1),a  
51bb 3a c5 51			ld a, (.dmark+2)  
51be 32 70 fb			ld (debug_mark+2),a  
51c1 18 03			jr .pastdmark  
51c3 ..			.dmark: db "CDV"  
51c6 f1			.pastdmark: pop af  
51c7			endm  
# End of macro DMARK
51c7						CALLMONITOR 
51c7 cd 84 17			call break_point_state  
51ca				endm  
# End of macro CALLMONITOR
51ca					endif 
51ca			 
51ca					; disable se storage bank selection 
51ca			 
51ca 3e ff				ld a, SPI_CE_HIGH		; ce high 
51cc 32 3f f8				ld (spi_device), a 
51cf			 
51cf					; get bank 
51cf			 
51cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51cf cd d8 1f			call macro_dsp_valuehl 
51d2				endm 
# End of macro FORTH_DSP_VALUEHL
51d2			 
51d2			;		push hl 
51d2			 
51d2					; destroy value TOS 
51d2			 
51d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51d2 cd 90 20			call macro_forth_dsp_pop 
51d5				endm 
# End of macro FORTH_DSP_POP
51d5			 
51d5					; one value on hl get other one back 
51d5			 
51d5			;		pop hl 
51d5			 
51d5					; active low 
51d5			 
51d5 0e ff				ld c, 255 
51d7			 
51d7 7d					ld a, l 
51d8					if DEBUG_FORTH_WORDS 
51d8						DMARK "CDV" 
51d8 f5				push af  
51d9 3a ed 51			ld a, (.dmark)  
51dc 32 6e fb			ld (debug_mark),a  
51df 3a ee 51			ld a, (.dmark+1)  
51e2 32 6f fb			ld (debug_mark+1),a  
51e5 3a ef 51			ld a, (.dmark+2)  
51e8 32 70 fb			ld (debug_mark+2),a  
51eb 18 03			jr .pastdmark  
51ed ..			.dmark: db "CDV"  
51f0 f1			.pastdmark: pop af  
51f1			endm  
# End of macro DMARK
51f1						CALLMONITOR 
51f1 cd 84 17			call break_point_state  
51f4				endm  
# End of macro CALLMONITOR
51f4					endif 
51f4 fe 00				cp 0 
51f6 28 30				jr z, .cset 
51f8 fe 01				cp 1 
51fa 20 02				jr nz, .c2 
51fc cb 81				res 0, c 
51fe fe 02		.c2:		cp 2 
5200 20 02				jr nz, .c3 
5202 cb 89				res 1, c 
5204 fe 03		.c3:		cp 3 
5206 20 02				jr nz, .c4 
5208 cb 91				res 2, c 
520a fe 04		.c4:		cp 4 
520c 20 02				jr nz, .c5 
520e cb 99				res 3, c 
5210 fe 05		.c5:		cp 5 
5212 20 02				jr nz, .c6 
5214 cb a1				res 4, c 
5216 fe 06		.c6:		cp 6 
5218 20 02				jr nz, .c7 
521a cb a9				res 5, c 
521c fe 07		.c7:		cp 7 
521e 20 02				jr nz, .c8 
5220 cb b1				res 6, c 
5222 fe 08		.c8:		cp 8 
5224 20 02				jr nz, .cset 
5226 cb b9				res 7, c 
5228 79			.cset:		ld a, c 
5229 32 42 f8				ld (spi_cartdev),a 
522c			 
522c					if DEBUG_FORTH_WORDS 
522c						DMARK "CD2" 
522c f5				push af  
522d 3a 41 52			ld a, (.dmark)  
5230 32 6e fb			ld (debug_mark),a  
5233 3a 42 52			ld a, (.dmark+1)  
5236 32 6f fb			ld (debug_mark+1),a  
5239 3a 43 52			ld a, (.dmark+2)  
523c 32 70 fb			ld (debug_mark+2),a  
523f 18 03			jr .pastdmark  
5241 ..			.dmark: db "CD2"  
5244 f1			.pastdmark: pop af  
5245			endm  
# End of macro DMARK
5245						CALLMONITOR 
5245 cd 84 17			call break_point_state  
5248				endm  
# End of macro CALLMONITOR
5248					endif 
5248					NEXTW 
5248 c3 4a 21			jp macro_next 
524b				endm 
# End of macro NEXTW
524b			endif 
524b			 
524b			.ENDDEVICE: 
524b			; eof 
524b			 
# End of file forth_words_device.asm
524b			 
524b			; var handler 
524b			 
524b			 
524b			.VARS: 
524b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
524b 78				db WORD_SYS_CORE+100             
524c 63 52			dw .V0Q            
524e 04				db 3 + 1 
524f .. 00			db "V0!",0              
5253				endm 
# End of macro CWHEAD
5253			;| V0! ( u1 -- )  Store value to v0  | DONE 
5253			 
5253					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5253 cd d8 1f			call macro_dsp_valuehl 
5256				endm 
# End of macro FORTH_DSP_VALUEHL
5256			 
5256 11 07 f8				ld de, cli_var_array 
5259			 
5259 eb					ex de, hl 
525a 73					ld (hl), e 
525b 23					inc hl 
525c 72					ld (hl), d 
525d			 
525d					; destroy value TOS 
525d			 
525d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
525d cd 90 20			call macro_forth_dsp_pop 
5260				endm 
# End of macro FORTH_DSP_POP
5260			 
5260				       NEXTW 
5260 c3 4a 21			jp macro_next 
5263				endm 
# End of macro NEXTW
5263			.V0Q: 
5263				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5263 79				db WORD_SYS_CORE+101             
5264 74 52			dw .V1S            
5266 04				db 3 + 1 
5267 .. 00			db "V0@",0              
526b				endm 
# End of macro CWHEAD
526b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
526b 2a 07 f8				ld hl, (cli_var_array) 
526e cd e1 1d				call forth_push_numhl 
5271			 
5271				       NEXTW 
5271 c3 4a 21			jp macro_next 
5274				endm 
# End of macro NEXTW
5274			.V1S: 
5274				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5274 7a				db WORD_SYS_CORE+102             
5275 8c 52			dw .V1Q            
5277 04				db 3 + 1 
5278 .. 00			db "V1!",0              
527c				endm 
# End of macro CWHEAD
527c			;| V1! ( u1 -- )  Store value to v1 | DONE 
527c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
527c cd d8 1f			call macro_dsp_valuehl 
527f				endm 
# End of macro FORTH_DSP_VALUEHL
527f			 
527f 11 09 f8				ld de, cli_var_array+2 
5282				 
5282 eb					ex de, hl 
5283 73					ld (hl), e 
5284 23					inc hl 
5285 72					ld (hl), d 
5286			 
5286					; destroy value TOS 
5286			 
5286					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5286 cd 90 20			call macro_forth_dsp_pop 
5289				endm 
# End of macro FORTH_DSP_POP
5289				       NEXTW 
5289 c3 4a 21			jp macro_next 
528c				endm 
# End of macro NEXTW
528c			.V1Q: 
528c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
528c 7b				db WORD_SYS_CORE+103             
528d 9d 52			dw .V2S            
528f 04				db 3 + 1 
5290 .. 00			db "V1@",0              
5294				endm 
# End of macro CWHEAD
5294			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5294 2a 09 f8				ld hl, (cli_var_array+2) 
5297 cd e1 1d				call forth_push_numhl 
529a				       NEXTW 
529a c3 4a 21			jp macro_next 
529d				endm 
# End of macro NEXTW
529d			.V2S: 
529d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
529d 7c				db WORD_SYS_CORE+104             
529e b5 52			dw .V2Q            
52a0 04				db 3 + 1 
52a1 .. 00			db "V2!",0              
52a5				endm 
# End of macro CWHEAD
52a5			;| V2! ( u1 -- )  Store value to v2 | DONE 
52a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52a5 cd d8 1f			call macro_dsp_valuehl 
52a8				endm 
# End of macro FORTH_DSP_VALUEHL
52a8			 
52a8 11 0b f8				ld de, cli_var_array+4 
52ab				 
52ab eb					ex de, hl 
52ac 73					ld (hl), e 
52ad 23					inc hl 
52ae 72					ld (hl), d 
52af			 
52af					; destroy value TOS 
52af			 
52af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52af cd 90 20			call macro_forth_dsp_pop 
52b2				endm 
# End of macro FORTH_DSP_POP
52b2				       NEXTW 
52b2 c3 4a 21			jp macro_next 
52b5				endm 
# End of macro NEXTW
52b5			.V2Q: 
52b5				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
52b5 7d				db WORD_SYS_CORE+105             
52b6 c6 52			dw .V3S            
52b8 04				db 3 + 1 
52b9 .. 00			db "V2@",0              
52bd				endm 
# End of macro CWHEAD
52bd			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
52bd 2a 0b f8				ld hl, (cli_var_array+4) 
52c0 cd e1 1d				call forth_push_numhl 
52c3				       NEXTW 
52c3 c3 4a 21			jp macro_next 
52c6				endm 
# End of macro NEXTW
52c6			.V3S: 
52c6				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
52c6 7c				db WORD_SYS_CORE+104             
52c7 de 52			dw .V3Q            
52c9 04				db 3 + 1 
52ca .. 00			db "V3!",0              
52ce				endm 
# End of macro CWHEAD
52ce			;| V3! ( u1 -- )  Store value to v3 | DONE 
52ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52ce cd d8 1f			call macro_dsp_valuehl 
52d1				endm 
# End of macro FORTH_DSP_VALUEHL
52d1			 
52d1 11 0d f8				ld de, cli_var_array+6 
52d4				 
52d4 eb					ex de, hl 
52d5 73					ld (hl), e 
52d6 23					inc hl 
52d7 72					ld (hl), d 
52d8			 
52d8					; destroy value TOS 
52d8			 
52d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52d8 cd 90 20			call macro_forth_dsp_pop 
52db				endm 
# End of macro FORTH_DSP_POP
52db				       NEXTW 
52db c3 4a 21			jp macro_next 
52de				endm 
# End of macro NEXTW
52de			.V3Q: 
52de				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
52de 7d				db WORD_SYS_CORE+105             
52df ef 52			dw .END            
52e1 04				db 3 + 1 
52e2 .. 00			db "V3@",0              
52e6				endm 
# End of macro CWHEAD
52e6			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
52e6 2a 0d f8				ld hl, (cli_var_array+6) 
52e9 cd e1 1d				call forth_push_numhl 
52ec				       NEXTW 
52ec c3 4a 21			jp macro_next 
52ef				endm 
# End of macro NEXTW
52ef			 
52ef			 
52ef			 
52ef			 
52ef			 
52ef			; end of dict marker 
52ef			 
52ef 00			.END:    db WORD_SYS_END 
52f0 00 00			dw 0 
52f2 00				db 0 
52f3			 
52f3			; use to jp here for user dict words to save on macro expansion  
52f3			 
52f3			user_dict_next: 
52f3				NEXTW 
52f3 c3 4a 21			jp macro_next 
52f6				endm 
# End of macro NEXTW
52f6			 
52f6			 
52f6			user_exec: 
52f6				;    ld hl, <word code> 
52f6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
52f6				;    call forthexec 
52f6				;    jp user_dict_next   (NEXT) 
52f6			        ;    <word code bytes> 
52f6 eb				ex de, hl 
52f7 2a 15 f1			ld hl,(os_tok_ptr) 
52fa				 
52fa				FORTH_RSP_NEXT 
52fa cd 88 1d			call macro_forth_rsp_next 
52fd				endm 
# End of macro FORTH_RSP_NEXT
52fd			 
52fd			if DEBUG_FORTH_UWORD 
52fd						DMARK "UEX" 
52fd f5				push af  
52fe 3a 12 53			ld a, (.dmark)  
5301 32 6e fb			ld (debug_mark),a  
5304 3a 13 53			ld a, (.dmark+1)  
5307 32 6f fb			ld (debug_mark+1),a  
530a 3a 14 53			ld a, (.dmark+2)  
530d 32 70 fb			ld (debug_mark+2),a  
5310 18 03			jr .pastdmark  
5312 ..			.dmark: db "UEX"  
5315 f1			.pastdmark: pop af  
5316			endm  
# End of macro DMARK
5316				CALLMONITOR 
5316 cd 84 17			call break_point_state  
5319				endm  
# End of macro CALLMONITOR
5319			endif 
5319			 
5319			 
5319			 
5319 eb				ex de, hl 
531a 22 15 f1			ld (os_tok_ptr), hl 
531d				 
531d				; Don't use next - Skips the first word in uword. 
531d			 
531d c3 db 21			jp exec1 
5320			;	NEXT 
5320			 
5320			 
5320			; eof 
# End of file forth_wordsv4.asm
5320			endif 
5320			;;;;;;;;;;;;;; Debug code 
5320			 
5320			 
5320			;if DEBUG_FORTH_PARSE 
5320 .. 00		.nowordfound: db "No match",0 
5329 .. 00		.compword:	db "Comparing word ",0 
5339 .. 00		.nextwordat:	db "Next word at",0 
5346 .. 00		.charmatch:	db "Char match",0 
5351			;endif 
5351			if DEBUG_FORTH_JP 
5351			.foundword:	db "Word match. Exec..",0 
5351			endif 
5351			;if DEBUG_FORTH_PUSH 
5351 .. 00		.enddict:	db "Dict end. Push.",0 
5361 .. 00		.push_str:	db "Pushing string",0 
5370 .. 00		.push_num:	db "Pushing number",0 
537f .. 00		.data_sp:	db "SP:",0 
5383 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5395 .. 00		.wordinde:	db "Word in DE (3/0):",0 
53a7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
53b9			;endif 
53b9			;if DEBUG_FORTH_MALLOC 
53b9 .. 00		.push_malloc:	db "Malloc address",0 
53c8			;endif 
53c8			 
53c8			 
53c8			 
53c8			; display malloc address and current data stack pointer  
53c8			 
53c8			malloc_error: 
53c8 d5				push de 
53c9 f5				push af 
53ca e5				push hl 
53cb cd a9 0b			call clear_display 
53ce 11 f0 53			ld de, .mallocerr 
53d1 3e 00			ld a,0 
53d3			;	ld de,os_word_scratch 
53d3 cd bc 0b			call str_at_display 
53d6 3e 11			ld a, display_row_1+17 
53d8 11 6e fb			ld de, debug_mark 
53db cd bc 0b			call str_at_display 
53de cd cc 0b			call update_display 
53e1				;call break_point_state 
53e1 cd 19 6b			call cin_wait 
53e4			 
53e4 3e 20			ld a, ' ' 
53e6 32 05 ee			ld (os_view_disable), a 
53e9 e1				pop hl 
53ea f1				pop af 
53eb d1				pop de	 
53ec				CALLMONITOR 
53ec cd 84 17			call break_point_state  
53ef				endm  
# End of macro CALLMONITOR
53ef c9				ret 
53f0			 
53f0 .. 00		.mallocerr: 	db "Malloc Error",0 
53fd			;if DEBUG_FORTH_PUSH 
53fd			display_data_sp: 
53fd f5				push af 
53fe			 
53fe				; see if disabled 
53fe			 
53fe 3a 05 ee			ld a, (os_view_disable) 
5401 fe 2a			cp '*' 
5403 28 67			jr z, .skipdsp 
5405			 
5405 e5				push hl 
5406 e5				push hl 
5407 e5			push hl 
5408 cd a9 0b			call clear_display 
540b e1			pop hl 
540c 7c				ld a,h 
540d 21 19 f1			ld hl, os_word_scratch 
5410 cd de 10			call hexout 
5413 e1				pop hl 
5414 7d				ld a,l 
5415 21 1b f1			ld hl, os_word_scratch+2 
5418 cd de 10			call hexout 
541b 21 1d f1			ld hl, os_word_scratch+4 
541e 3e 00			ld a,0 
5420 77				ld (hl),a 
5421 11 19 f1			ld de,os_word_scratch 
5424 3e 28				ld a, display_row_2 
5426 cd bc 0b				call str_at_display 
5429 11 83 53			ld de, .wordinhl 
542c 3e 00			ld a, display_row_1 
542e			 
542e cd bc 0b				call str_at_display 
5431 11 6e fb			ld de, debug_mark 
5434 3e 11			ld a, display_row_1+17 
5436			 
5436 cd bc 0b				call str_at_display 
5439			 
5439				; display current data stack pointer 
5439 11 7f 53			ld de,.data_sp 
543c 3e 30				ld a, display_row_2 + 8 
543e cd bc 0b				call str_at_display 
5441			 
5441 2a 01 f8			ld hl,(cli_data_sp) 
5444 e5				push hl 
5445 7c				ld a,h 
5446 21 19 f1			ld hl, os_word_scratch 
5449 cd de 10			call hexout 
544c e1				pop hl 
544d 7d				ld a,l 
544e 21 1b f1			ld hl, os_word_scratch+2 
5451 cd de 10			call hexout 
5454 21 1d f1			ld hl, os_word_scratch+4 
5457 3e 00			ld a,0 
5459 77				ld (hl),a 
545a 11 19 f1			ld de,os_word_scratch 
545d 3e 33				ld a, display_row_2 + 11 
545f cd bc 0b				call str_at_display 
5462			 
5462			 
5462 cd cc 0b			call update_display 
5465 cd 26 0b			call delay1s 
5468 cd 26 0b			call delay1s 
546b e1				pop hl 
546c			.skipdsp: 
546c f1				pop af 
546d c9				ret 
546e			 
546e			display_data_malloc: 
546e			 
546e f5				push af 
546f e5				push hl 
5470 e5				push hl 
5471 e5			push hl 
5472 cd a9 0b			call clear_display 
5475 e1			pop hl 
5476 7c				ld a,h 
5477 21 19 f1			ld hl, os_word_scratch 
547a cd de 10			call hexout 
547d e1				pop hl 
547e 7d				ld a,l 
547f 21 1b f1			ld hl, os_word_scratch+2 
5482 cd de 10			call hexout 
5485 21 1d f1			ld hl, os_word_scratch+4 
5488 3e 00			ld a,0 
548a 77				ld (hl),a 
548b 11 19 f1			ld de,os_word_scratch 
548e 3e 28				ld a, display_row_2 
5490 cd bc 0b				call str_at_display 
5493 11 b9 53			ld de, .push_malloc 
5496 3e 00			ld a, display_row_1 
5498			 
5498 cd bc 0b				call str_at_display 
549b			 
549b				; display current data stack pointer 
549b 11 7f 53			ld de,.data_sp 
549e 3e 30				ld a, display_row_2 + 8 
54a0 cd bc 0b				call str_at_display 
54a3			 
54a3 2a 01 f8			ld hl,(cli_data_sp) 
54a6 e5				push hl 
54a7 7c				ld a,h 
54a8 21 19 f1			ld hl, os_word_scratch 
54ab cd de 10			call hexout 
54ae e1				pop hl 
54af 7d				ld a,l 
54b0 21 1b f1			ld hl, os_word_scratch+2 
54b3 cd de 10			call hexout 
54b6 21 1d f1			ld hl, os_word_scratch+4 
54b9 3e 00			ld a,0 
54bb 77				ld (hl),a 
54bc 11 19 f1			ld de,os_word_scratch 
54bf 3e 33				ld a, display_row_2 + 11 
54c1 cd bc 0b				call str_at_display 
54c4			 
54c4 cd cc 0b			call update_display 
54c7 cd 26 0b			call delay1s 
54ca cd 26 0b			call delay1s 
54cd e1				pop hl 
54ce f1				pop af 
54cf c9				ret 
54d0			;endif 
54d0			 
54d0			include "forth_autostart.asm" 
54d0			; list of commands to perform at system start up 
54d0			 
54d0			startcmds: 
54d0			;	dw test11 
54d0			;	dw test12 
54d0			;	dw test13 
54d0			;	dw test14 
54d0			;	dw test15 
54d0			;	dw test16 
54d0			;	dw test17 
54d0			;	dw ifthtest1 
54d0			;	dw ifthtest2 
54d0			;	dw ifthtest3 
54d0			;	dw mmtest1 
54d0			;	dw mmtest2 
54d0			;	dw mmtest3 
54d0			;	dw mmtest4 
54d0			;	dw mmtest5 
54d0			;	dw mmtest6 
54d0			;	dw iftest1 
54d0			;	dw iftest2 
54d0			;	dw iftest3 
54d0			;	dw looptest1 
54d0			;	dw looptest2 
54d0			;	dw test1 
54d0			;	dw test2 
54d0			;	dw test3 
54d0			;	dw test4 
54d0			;	dw game2r 
54d0			;	dw game2b1 
54d0			;	dw game2b2 
54d0			 
54d0				; start up words that are actually useful 
54d0			 
54d0 2e 55			dw clrstack 
54d2 61 55			dw type 
54d4 51 57			dw stest 
54d6 85 55			dw strncpy 
54d8 e7 56			dw list 
54da e6 55			dw start1 
54dc f8 55			dw start2 
54de			;	dw start3 
54de 0b 56			dw start3b 
54e0 87 56			dw start3c 
54e2			 
54e2				; (unit) testing words 
54e2			 
54e2 c8 57			dw mtesta 
54e4 7d 58			dw mtestb 
54e6 20 59			dw mtestc 
54e8 d5 59			dw mtestd 
54ea 79 5a			dw mteste 
54ec			 
54ec				; demo/game words 
54ec			 
54ec 85 61		        dw game3w 
54ee b3 61		        dw game3p 
54f0 d1 61		        dw game3sc 
54f2 02 62		        dw game3vsi 
54f4 2e 62		        dw game3vs 
54f6				 
54f6 78 5f			dw game2b 
54f8 e6 5f			dw game2bf 
54fa 30 60			dw game2mba 
54fc c6 60			dw game2mbas 
54fe 08 61			dw game2mb 
5500			 
5500 39 5c			dw game1 
5502 4a 5c			dw game1a 
5504 ac 5c			dw game1b 
5506 e1 5c			dw game1c 
5508 17 5d			dw game1d 
550a 48 5d			dw game1s 
550c 5c 5d			dw game1t 
550e 71 5d			dw game1f 
5510 a5 5d			dw game1z 
5512 e9 5d			dw game1zz 
5514			 
5514 2f 5b			dw test5 
5516 67 5b			dw test6 
5518 9f 5b			dw test7 
551a b3 5b			dw test8 
551c df 5b			dw test9 
551e f5 5b			dw test10 
5520				 
5520 c0 5e		        dw ssv5 
5522 a4 5e		        dw ssv4 
5524 88 5e		        dw ssv3 
5526 52 5e		        dw ssv2 
5528 d9 5e		        dw ssv1 
552a 21 5f		        dw ssv1cpm 
552c			;	dw keyup 
552c			;	dw keydown 
552c			;	dw keyleft 
552c			;	dw keyright 
552c			;	dw 	keyf1 
552c			;	dw keyf2 
552c			;	dw keyf3 
552c			;	dw keyf4 
552c			;	dw keyf5 
552c			;	dw keyf6 
552c			;	dw keyf7 
552c			;	dw keyf8 
552c			;	dw keyf9 
552c			;	dw keyf10 
552c			;	dw keyf11 
552c			;	dw keyf12 
552c			;	dw keytab 
552c			;	dw keycr 
552c			;	dw keyhome 
552c			;	dw keyend 
552c			;	dw keybs 
552c 00 00			db 0, 0	 
552e			 
552e			 
552e			; clear stack  
552e			 
552e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5561			 
5561			; type ( addr count - ) 
5561 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5585			 
5585			; some direct memory words 
5585			; strncpy ( len t f -- t ) 
5585			 
5585 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
55e6			 
55e6 .. 00		start1:     	db ": bpon $0000 bp ;",0 
55f8 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
560b .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5687 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
56e7			 
56e7			 
56e7			; a handy word to list items on the stack 
56e7			 
56e7 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5751			 
5751			 
5751			; test stack  
5751			; rnd8 stest 
5751			 
5751 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
57c8			 
57c8			; random malloc and free cycles 
57c8			 
57c8 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
587d			 
587d			; fixed malloc and free cycles 
587d			 
587d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5920			 
5920			; fixed double string push and drop cycle  
5920			 
5920 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
59d5			 
59d5			; consistent fixed string push and drop cycle  
59d5			 
59d5 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5a79			 
5a79 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b2f			 
5b2f			;test1:		db ": aa 1 2 3 ;", 0 
5b2f			;test2:     	db "111 aa 888 999",0 
5b2f			;test3:     	db ": bb 77 ;",0 
5b2f			;test4:     	db "$02 $01 do i . loop bb",0 
5b2f			 
5b2f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5b67 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5b9f .. 00		test7:     	db ": box hline vline ;",0 
5bb3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5bdf .. 00		test9:     	db ": sw $01 adsp world ;",0 
5bf5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5c1a .. 00		test11:     	db "hello create .",0 
5c29 .. 00		test12:     	db "hello2 create .",0 
5c39			 
5c39			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5c39			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5c39			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5c39			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5c39			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5c39			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5c39			 
5c39			;iftest1:     	db "$0001 IF cls .",0 
5c39			;iftest2:     	db "$0000 IF cls .",0 
5c39			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5c39			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5c39			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5c39			 
5c39			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c39			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c39			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5c39			 
5c39			 
5c39			 
5c39			; a small guess the number game 
5c39			 
5c39 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5c4a .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5cac			 
5cac .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ce1 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5d17 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5d48 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5d5c .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5d71 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5da5 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5de9			 
5de9			; Using 'ga' save a high score across multiple runs using external storage 
5de9			 
5de9 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5e52			 
5e52			 
5e52			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5e52			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e52			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e52			 
5e52			; simple screen saver to test code memory reuse to destruction 
5e52			 
5e52 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5e88 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5ea4 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ec0 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5ed9 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f21 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5f78			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f78			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5f78			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5f78			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5f78			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5f78			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5f78			 
5f78			 
5f78			 
5f78			; minesweeper/battleship finding game 
5f78			; draws a game board of random ship/mine positions 
5f78			; user enters coords to see if it hits on 
5f78			; game ends when all are hit 
5f78			; when hit or miss says how many may be in the area 
5f78			 
5f78			; setup the game board and then hide it 
5f78 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5fe6 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6030			; prompt for where to target 
6030 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
60c6 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
60eb			; TODO see if the entered coords hits or misses pushes char hit of miss 
60eb .. 00		game2mbht:      db ": mbckht nop ;",0 
60fa .. 00		game2mbms:      db ": mbcms nop ;",0 
6108			; TODO how many might be near by 
6108 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6185			 
6185			; Game 3 
6185			 
6185			; Vert scroller ski game - avoid the trees! 
6185			 
6185			; v0 score (ie turns) 
6185			; v1 player pos 
6185			; v2 left wall 
6185			; v3 right wall 
6185			 
6185			; Draw side walls randomly 
6185			 
6185 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
61b3			 
61b3			; Draw player 
61b3 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
61d1			 
61d1			; TODO Get Key 
61d1			 
61d1			; TODO Move left right 
61d1			 
61d1			; scroll and move walls a bit 
61d1			 
61d1 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6202			 
6202			; main game loop 
6202			 
6202 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
622e .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
626d			 
626d			; key board defs 
626d			 
626d .. 00		keyup:       db ": keyup $05 ;",0 
627b .. 00		keydown:       db ": keydown $0a ;",0 
628b .. 00		keyleft:       db ": keyleft $0b ;",0 
629b .. 00		keyright:       db ": keyright $0c ;",0 
62ac .. 00		keyf1:       db ": keyf1 $10 ;",0 
62ba .. 00		keyf2:       db ": keyf2 $11 ;",0 
62c8 .. 00		keyf3:       db ": keyf3 $12 ;",0 
62d6 .. 00		keyf4:       db ": keyf4 $13 ;",0 
62e4 .. 00		keyf5:       db ": keyf5 $14 ;",0 
62f2 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6300 .. 00		keyf7:       db ": keyf7 $16 ;",0 
630e .. 00		keyf8:       db ": keyf8 $17 ;",0 
631c .. 00		keyf9:       db ": keyf9 $18 ;",0 
632a .. 00		keyf10:       db ": keyf10 $19 ;",0 
6339 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6348 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6357			 
6357 .. 00		keytab:       db ": keytab $09 ;",0 
6366 .. 00		keycr:       db ": keycr $0d ;",0 
6374 .. 00		keyhome:       db ": keyhome $0e ;",0 
6384 .. 00		keyend:       db ": keyend $0f ;",0 
6393 .. 00		keybs:       db ": keybs $08 ;",0 
63a1			 
63a1			   
63a1			 
63a1			 
63a1			 
63a1			; eof 
# End of file forth_autostart.asm
63a1			 
63a1 .. 00		sprompt1: db "Startup load...",0 
63b1 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63c7			 
63c7			 
63c7			 
63c7			 
63c7			forth_startup: 
63c7 21 d0 54			ld hl, startcmds 
63ca 3e 00			ld a, 0 
63cc 32 3a f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63cf			 
63cf e5			.start1:	push hl 
63d0 cd a9 0b			call clear_display 
63d3 11 a1 63			ld de, sprompt1 
63d6 3e 00		        ld a, display_row_1 
63d8 cd bc 0b			call str_at_display 
63db 11 b1 63			ld de, sprompt2 
63de 3e 28		        ld a, display_row_2 
63e0 cd bc 0b			call str_at_display 
63e3 e1				pop hl 
63e4 e5				push hl 
63e5 5e				ld e,(hl) 
63e6 23				inc hl 
63e7 56				ld d,(hl) 
63e8 3e 50		        ld a, display_row_3 
63ea cd bc 0b			call str_at_display 
63ed cd cc 0b			call update_display 
63f0			 
63f0			 
63f0 3a 3a f2			ld a, (os_last_cmd) 
63f3 fe 00			cp 0 
63f5 28 05			jr z, .startprompt 
63f7 cd 1a 0b			call delay250ms 
63fa 18 24			jr .startdo 
63fc				 
63fc				 
63fc			 
63fc			.startprompt: 
63fc			 
63fc 3e 9f			ld a,display_row_4 + display_cols - 1 
63fe 11 57 1d		        ld de, endprg 
6401 cd bc 0b			call str_at_display 
6404 cd cc 0b			call update_display 
6407 cd 26 0b			call delay1s 
640a cd 19 6b			call cin_wait 
640d						 
640d fe 2a			cp '*' 
640f 28 5e			jr z, .startupend1 
6411 fe 23			cp '#' 
6413 20 07			jr nz, .startno 
6415 3e 01			ld a, 1 
6417 32 3a f2			ld (os_last_cmd),a 
641a 18 04			jr .startdo 
641c fe 31		.startno:	cp '1' 
641e 28 3a			jr z,.startnxt  
6420			 
6420				; exec startup line 
6420			.startdo:	 
6420 e1				pop hl 
6421 e5				push hl 
6422				 
6422 5e				ld e,(hl) 
6423 23				inc hl 
6424 56				ld d,(hl) 
6425 eb				ex de,hl 
6426			 
6426 e5				push hl 
6427			 
6427 3e 00			ld a, 0 
6429				;ld a, FORTH_END_BUFFER 
6429 cd 46 12			call strlent 
642c 23				inc hl   ; include zero term to copy 
642d 06 00			ld b,0 
642f 4d				ld c,l 
6430 e1				pop hl 
6431 11 14 ee			ld de, scratch 
6434 ed b0			ldir 
6436			 
6436			 
6436 21 14 ee			ld hl, scratch 
6439 cd 98 21			call forthparse 
643c cd d8 21			call forthexec 
643f cd ef 20			call forthexec_cleanup 
6442			 
6442 3e 78			ld a, display_row_4 
6444 11 fb 1a			ld de, endprog 
6447			 
6447 cd cc 0b			call update_display		 
644a			 
644a 3a 3a f2			ld a, (os_last_cmd) 
644d fe 00			cp 0 
644f 20 09			jr nz, .startnxt 
6451 cd 59 1d			call next_page_prompt 
6454 cd a9 0b		        call clear_display 
6457 cd cc 0b			call update_display		 
645a			 
645a				; move onto next startup line? 
645a			.startnxt: 
645a			 
645a cd 1a 0b			call delay250ms 
645d e1				pop hl 
645e			 
645e 23				inc hl 
645f 23				inc hl 
6460			 
6460 e5				push hl 
6461 5e				ld e, (hl) 
6462 23				inc hl 
6463 56				ld d, (hl) 
6464 e1				pop hl 
6465				; TODO replace 0 test 
6465			 
6465 eb				ex de, hl 
6466 cd 06 0e			call ishlzero 
6469			;	ld a,e 
6469			;	add d 
6469			;	cp 0    ; any left to do? 
6469 eb				ex de, hl 
646a c2 cf 63			jp nz, .start1 
646d 18 01			jr .startupend 
646f			 
646f e1			.startupend1: pop hl 
6470			.startupend: 
6470			 
6470 cd a9 0b			call clear_display 
6473 cd cc 0b			call update_display 
6476 c9				ret 
6477			 
6477			 
6477			; stack over and underflow checks 
6477			 
6477			; init the words to detect the under/overflow 
6477			 
6477			chk_stk_init: 
6477				; a vague random number to check so we dont get any "lucky" hits 
6477 3e 2d			ld a, 45 
6479 6f				ld l, a 
647a 00				nop 
647b 3e 17			ld a, 23 
647d 67				ld h, a 
647e			 
647e 22 fb ed			ld (chk_word), hl     ; the word we need to check against 
6481			 
6481			;	ld (chk_stund), hl	; stack points.... 
6481 22 fd fb			ld (chk_stovr), hl 
6484 22 ff f7			ld (chk_ret_und), hl 
6487 22 7d f7			ld (chk_ret_ovr), hl 
648a 22 7b f5			ld (chk_loop_ovr), hl 
648d 22 79 f3			ld (chk_data_ovr), hl 
6490 c9				ret 
6491				 
6491			check_stacks: 
6491				; check all stack words 
6491			 
6491 e5				push hl 
6492 d5				push de 
6493			 
6493			;	ld de,(chk_word) 
6493			;	ld hl, (chk_stund)	; stack points.... 
6493			;	if DEBUG_STK_FAULT 
6493			;		DMARK "FAa" 
6493			;		CALLMONITOR 
6493			;	endif 
6493			;	call cmp16 
6493			;	jp z, .chk_faulta 
6493			; 
6493			;	ld de, sfaultsu 
6493			;	jp .chk_fault 
6493			 
6493 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6496 ed 5b fb ed		ld de,(chk_word) 
649a				if DEBUG_STK_FAULT 
649a					DMARK "FAb" 
649a					CALLMONITOR 
649a				endif 
649a cd fb 0d			call cmp16 
649d 28 06			jr z, .chk_fault1 
649f 11 40 65			ld de, sfaultso 
64a2 c3 f4 64			jp .chk_fault 
64a5			.chk_fault1:  
64a5 2a ff f7			ld hl, (chk_ret_und) 
64a8 ed 5b fb ed		ld de,(chk_word) 
64ac				if DEBUG_STK_FAULT 
64ac					DMARK "FAU" 
64ac					CALLMONITOR 
64ac				endif 
64ac cd fb 0d			call cmp16 
64af ca b8 64			jp z, .chk_fault2 
64b2 11 50 65			ld de, sfaultru 
64b5 c3 f4 64			jp .chk_fault 
64b8			.chk_fault2:  
64b8 2a 7d f7			ld hl, (chk_ret_ovr) 
64bb ed 5b fb ed		ld de,(chk_word) 
64bf				if DEBUG_STK_FAULT 
64bf					DMARK "FA1" 
64bf					CALLMONITOR 
64bf				endif 
64bf cd fb 0d			call cmp16 
64c2 ca cb 64			jp z, .chk_fault3 
64c5 11 5e 65			ld de, sfaultro 
64c8 c3 f4 64			jp .chk_fault 
64cb			.chk_fault3:  
64cb 2a 7b f5			ld hl, (chk_loop_ovr) 
64ce ed 5b fb ed		ld de,(chk_word) 
64d2				if DEBUG_STK_FAULT 
64d2					DMARK "FA2" 
64d2					CALLMONITOR 
64d2				endif 
64d2 cd fb 0d			call cmp16 
64d5 ca de 64			jp z, .chk_fault4 
64d8 11 78 65			ld de, sfaultlo 
64db c3 f4 64			jp .chk_fault 
64de			.chk_fault4:  
64de 2a 79 f3			ld hl, (chk_data_ovr) 
64e1 ed 5b fb ed		ld de,(chk_word) 
64e5				if DEBUG_STK_FAULT 
64e5					DMARK "FA3" 
64e5					CALLMONITOR 
64e5				endif 
64e5 cd fb 0d			call cmp16 
64e8 ca f1 64			jp z, .chk_fault5 
64eb 11 92 65			ld de, sfaultdo 
64ee c3 f4 64			jp .chk_fault 
64f1			 
64f1			 
64f1			.chk_fault5:  
64f1 d1				pop de 
64f2 e1				pop hl 
64f3			 
64f3 c9				ret 
64f4			 
64f4 cd a9 0b		.chk_fault: 	call clear_display 
64f7 3e 28				ld a, display_row_2 
64f9 cd bc 0b				call str_at_display 
64fc 11 22 65				   ld de, .stackfault 
64ff 3e 00				ld a, display_row_1 
6501 cd bc 0b				call str_at_display 
6504 11 6e fb				    ld de, debug_mark 
6507 3e 11				ld a, display_row_1+17 
6509 cd bc 0b				call str_at_display 
650c cd cc 0b				call update_display 
650f			 
650f				; prompt before entering montior for investigating issue 
650f			 
650f 3e 78			ld a, display_row_4 
6511 11 fb 1a			ld de, endprog 
6514			 
6514 cd cc 0b			call update_display		 
6517			 
6517 cd 59 1d			call next_page_prompt 
651a			 
651a d1				pop de 
651b e1				pop hl 
651c cd 4f 1b				call monitor 
651f c3 46 1a				jp warmstart 
6522					;jp 0 
6522					;halt 
6522			 
6522			 
6522			 
6522 .. 00		.stackfault: 	db "Stack fault:",0 
652f			 
652f .. 00		sfaultsu: 	db	"Stack under flow",0 
6540 .. 00		sfaultso: 	db	"Stack over flow",0 
6550 .. 00		sfaultru:	db "RTS underflow",0 
655e .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6578 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6592 .. 00		sfaultdo:	db "DTS overflow", 0 
659f			 
659f			 
659f			fault_dsp_under: 
659f 11 b1 65			ld de, .dsp_under 
65a2 c3 61 66			jp .show_fault 
65a5			 
65a5			fault_rsp_under: 
65a5 11 bf 65			ld de, .rsp_under 
65a8 c3 61 66			jp .show_fault 
65ab			fault_loop_under: 
65ab 11 cd 65			ld de, .loop_under 
65ae c3 61 66			jp .show_fault 
65b1			 
65b1 .. 00		.dsp_under: db "DSP Underflow",0 
65bf .. 00		.rsp_under: db "RSP Underflow",0 
65cd .. 00		.loop_under: db "LOOP Underflow",0 
65dc			 
65dc			 
65dc d5			type_faultn: 	push de 
65dd e5					push hl 
65de cd a9 0b				call clear_display 
65e1 11 08 66				   ld de, .typefaultn 
65e4 3e 00				ld a, display_row_1 
65e6 cd bc 0b				call str_at_display 
65e9 11 6e fb				    ld de, debug_mark 
65ec 3e 11				ld a, display_row_1+17 
65ee cd bc 0b				call str_at_display 
65f1 cd cc 0b				call update_display 
65f4			 
65f4				; prompt before entering montior for investigating issue 
65f4			 
65f4 3e 78			ld a, display_row_4 
65f6 11 fb 1a			ld de, endprog 
65f9			 
65f9 cd cc 0b			call update_display		 
65fc			 
65fc cd 59 1d			call next_page_prompt 
65ff			 
65ff e5					push hl 
6600 d5					push de 
6601 cd 4f 1b				call monitor 
6604 c3 46 1a				jp warmstart 
6607 76					halt 
6608			 
6608			 
6608 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
661f			 
661f d5			type_faults: 	push de 
6620 e5					push hl 
6621 cd a9 0b				call clear_display 
6624 11 4a 66				   ld de, .typefaults 
6627 3e 00				ld a, display_row_1 
6629 cd bc 0b				call str_at_display 
662c 11 6e fb				    ld de, debug_mark 
662f 3e 11				ld a, display_row_1+17 
6631 cd bc 0b				call str_at_display 
6634 cd cc 0b				call update_display 
6637			 
6637				; prompt before entering montior for investigating issue 
6637			 
6637 3e 78			ld a, display_row_4 
6639 11 fb 1a			ld de, endprog 
663c			 
663c cd cc 0b			call update_display		 
663f			 
663f cd 59 1d			call next_page_prompt 
6642			 
6642 e1					pop hl 
6643 d1					pop de 
6644 cd 4f 1b				call monitor 
6647 c3 46 1a				jp warmstart 
664a			 
664a			 
664a .. 00		.typefaults: db "STR Type Expected TOS!",0 
6661			 
6661			.show_fault: 	 
6661 d5					push de 
6662 cd a9 0b				call clear_display 
6665 d1					pop de 
6666 3e 00				ld a, display_row_1 
6668 cd bc 0b				call str_at_display 
666b 11 6e fb				    ld de, debug_mark 
666e 3e 11				ld a, display_row_1+17 
6670 cd bc 0b				call str_at_display 
6673 cd cc 0b				call update_display 
6676			 
6676				; prompt before entering montior for investigating issue 
6676			 
6676 3e 78			ld a, display_row_4 
6678 11 fb 1a			ld de, endprog 
667b			 
667b cd cc 0b			call update_display		 
667e			 
667e cd 59 1d			call next_page_prompt 
6681			 
6681 e1					pop hl 
6682 d1					pop de 
6683 cd 4f 1b				call monitor 
6686			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6686			; TODO Make optional fault restart to cli or warm boot? 
6686					;jp warmstart 
6686 c3 a1 1a				jp cli 
6689 76					halt 
668a			 
668a			; handle the auto run of code from files in storage 
668a			 
668a			 
668a			if STORAGE_SE 
668a			 
668a .. 00		sprompt3: db "Loading from start-up file?:",0 
66a7 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
66b8			 
66b8			 
66b8			forth_autoload: 
66b8			 
66b8				; load block 0 of store 1 
66b8				 
66b8 3e fe			ld a, $fe      ; bit 0 clear 
66ba 32 3f f8			ld (spi_device), a 
66bd			 
66bd cd 6c 04			call storage_get_block_0 
66c0			 
66c0 3a 7a f8			ld a, (store_page+STORE_0_AUTOFILE) 
66c3			 
66c3 fe 00			cp 0 
66c5 c8				ret z     ; auto start not enabled 
66c6			 
66c6 cd a9 0b			call clear_display 
66c9			 
66c9				; set bank 
66c9			 
66c9 3a 7c f8				ld a, (store_page+STORE_0_BANKRUN) 
66cc 32 3f f8				ld (spi_device), a 
66cf			 
66cf				; get file id to load from and get the file name to display 
66cf			 
66cf 3a 7d f8				ld a, (store_page+STORE_0_FILERUN) 
66d2			 
66d2 2e 00				ld l, 0 
66d4 67					ld h, a 
66d5 11 59 f8				ld de, store_page 
66d8			 
66d8					if DEBUG_FORTH_WORDS 
66d8						DMARK "ASp" 
66d8 f5				push af  
66d9 3a ed 66			ld a, (.dmark)  
66dc 32 6e fb			ld (debug_mark),a  
66df 3a ee 66			ld a, (.dmark+1)  
66e2 32 6f fb			ld (debug_mark+1),a  
66e5 3a ef 66			ld a, (.dmark+2)  
66e8 32 70 fb			ld (debug_mark+2),a  
66eb 18 03			jr .pastdmark  
66ed ..			.dmark: db "ASp"  
66f0 f1			.pastdmark: pop af  
66f1			endm  
# End of macro DMARK
66f1						CALLMONITOR 
66f1 cd 84 17			call break_point_state  
66f4				endm  
# End of macro CALLMONITOR
66f4					endif 
66f4 cd 14 09				call storage_read 
66f7			 
66f7					if DEBUG_FORTH_WORDS 
66f7						DMARK "ASr" 
66f7 f5				push af  
66f8 3a 0c 67			ld a, (.dmark)  
66fb 32 6e fb			ld (debug_mark),a  
66fe 3a 0d 67			ld a, (.dmark+1)  
6701 32 6f fb			ld (debug_mark+1),a  
6704 3a 0e 67			ld a, (.dmark+2)  
6707 32 70 fb			ld (debug_mark+2),a  
670a 18 03			jr .pastdmark  
670c ..			.dmark: db "ASr"  
670f f1			.pastdmark: pop af  
6710			endm  
# End of macro DMARK
6710						CALLMONITOR 
6710 cd 84 17			call break_point_state  
6713				endm  
# End of macro CALLMONITOR
6713					endif 
6713			 
6713 cd 06 0e				call ishlzero 
6716 c8					ret z             ; file not found 
6717			 
6717 3e 32				ld a, display_row_2 + 10 
6719 11 5c f8				ld de, store_page+3 
671c cd bc 0b				call str_at_display 
671f				 
671f			; 
671f			 
671f 3e 05			ld a, display_row_1+5 
6721 11 8a 66			ld de, sprompt3 
6724 cd bc 0b			call str_at_display 
6727 3e 5f			ld a, display_row_3+15 
6729 11 a7 66			ld de, sprompt4 
672c cd bc 0b			call str_at_display 
672f			 
672f cd cc 0b			call update_display 
6732			 
6732 cd 19 6b			call cin_wait 
6735 fe 6e			cp 'n' 
6737 c8				ret z 
6738 fe 4e			cp 'N' 
673a c8				ret z 
673b			 
673b cd 26 0b			call delay1s 
673e			 
673e 3a 5b f8			ld a, (store_page+2) 
6741 32 4f f8			ld (store_openmaxext), a    ; save count of ext 
6744 3e 01			ld a, 1  
6746 32 50 f8			ld (store_openext), a    ; save count of ext 
6749			 
6749			.autof:  
6749 6f				ld l , a 
674a				 
674a 3a 59 f8			ld a, (store_page) 
674d 67				ld h, a	 
674e 11 59 f8			ld de, store_page 
6751					if DEBUG_FORTH_WORDS 
6751						DMARK "ASl" 
6751 f5				push af  
6752 3a 66 67			ld a, (.dmark)  
6755 32 6e fb			ld (debug_mark),a  
6758 3a 67 67			ld a, (.dmark+1)  
675b 32 6f fb			ld (debug_mark+1),a  
675e 3a 68 67			ld a, (.dmark+2)  
6761 32 70 fb			ld (debug_mark+2),a  
6764 18 03			jr .pastdmark  
6766 ..			.dmark: db "ASl"  
6769 f1			.pastdmark: pop af  
676a			endm  
# End of macro DMARK
676a						CALLMONITOR 
676a cd 84 17			call break_point_state  
676d				endm  
# End of macro CALLMONITOR
676d					endif 
676d cd 14 09				call storage_read 
6770 cd 06 0e			call ishlzero 
6773 c8				ret z 
6774			;	jr z, .autoend 
6774			 
6774					if DEBUG_FORTH_WORDS 
6774						DMARK "ASc" 
6774 f5				push af  
6775 3a 89 67			ld a, (.dmark)  
6778 32 6e fb			ld (debug_mark),a  
677b 3a 8a 67			ld a, (.dmark+1)  
677e 32 6f fb			ld (debug_mark+1),a  
6781 3a 8b 67			ld a, (.dmark+2)  
6784 32 70 fb			ld (debug_mark+2),a  
6787 18 03			jr .pastdmark  
6789 ..			.dmark: db "ASc"  
678c f1			.pastdmark: pop af  
678d			endm  
# End of macro DMARK
678d						CALLMONITOR 
678d cd 84 17			call break_point_state  
6790				endm  
# End of macro CALLMONITOR
6790					endif 
6790 11 5b f8			ld de, store_page+2 
6793 3e 78			ld a, display_row_4 
6795 cd bc 0b			call str_at_display 
6798			 
6798 cd cc 0b			call update_display 
679b cd 1a 0b			call delay250ms 
679e			 
679e			 
679e			 
679e 21 5b f8			ld hl, store_page+2 
67a1 cd 98 21			call forthparse 
67a4 cd d8 21			call forthexec 
67a7 cd ef 20			call forthexec_cleanup 
67aa			 
67aa				 
67aa 3a 50 f8			ld a, (store_openext) 
67ad 3c				inc a 
67ae 32 50 f8			ld (store_openext), a    ; save count of ext 
67b1			 
67b1 18 96			jr .autof 
67b3			;.autofdone: 
67b3			; 
67b3			;		if DEBUG_FORTH_WORDS 
67b3			;			DMARK "ASx" 
67b3			;			CALLMONITOR 
67b3			;		endif 
67b3			;;	call clear_display 
67b3			;	ret 
67b3			 
67b3			 
67b3			 
67b3			endif 
67b3			 
67b3			 
67b3			; eof 
# End of file forth_kernel.asm
67b3			;include "nascombasic.asm" 
67b3			 
67b3			 
67b3			; find out where the code ends if loaded into RAM (for SC114) 
67b3			;endofcode:  
67b3			;	nop 
67b3			 
67b3			 
67b3			; eof 
67b3			 
# End of file main.asm
67b3			include "firmware_lcd_4x40.asm" 
67b3			; **********************************************************************  
67b3			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
67b3			; **********************************************************************  
67b3			;  
67b3			; **  Written as a Small Computer Monitor App  
67b3			; **  www.scc.me.uk  
67b3			;  
67b3			; History  
67b3			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
67b3			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
67b3			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
67b3			;  
67b3			; **********************************************************************  
67b3			;  
67b3			; This program is an example of one of the methods of interfacing an   
67b3			; alphanumeric LCD module.   
67b3			;  
67b3			; In this example the display is connected to either a Z80 PIO or a   
67b3			; simple 8-bit output port.   
67b3			;  
67b3			; This interfacing method uses 4-bit data mode and uses time delays  
67b3			; rather than polling the display's ready status. As a result the   
67b3			; interface only requires 6 simple output lines:  
67b3			;   Output bit 0 = not used  
67b3			;   Output bit 1 = not used  
67b3			;   Output bit 2 = RS         High = data, Low = instruction  
67b3			;   Output bit 3 = E          Active high  
67b3			;   Output bit 4 = DB4  
67b3			;   Output bit 5 = DB5  
67b3			;   Output bit 6 = DB6  
67b3			;   Output bit 7 = DB7  
67b3			; Display's R/W is connected to 0v so it is always in write mode  
67b3			;  
67b3			; This set up should work with any system supporting the RC2014 bus  
67b3			  
67b3			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
67b3			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
67b3			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
67b3			;  
67b3			; **********************************************************************  
67b3			  
67b3			; Additonal for 4x40. E1 and E2 instead of just E   
67b3			; TODO swipe vidout signal on port a to activate E2  
67b3			  
67b3			; **********************************************************************  
67b3			; **  Constants  
67b3			; **********************************************************************  
67b3			; LCD constants required by LCD support module  
67b3			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
67b3			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
67b3			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
67b3			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
67b3			; TODO Decide which E is being set  
67b3			kLCDWidth:  EQU display_cols             ;Width in characters  
67b3			  
67b3			; **********************************************************************  
67b3			; **  Code library usage  
67b3			; **********************************************************************  
67b3			  
67b3			; send character to current cursor position  
67b3			; wraps and/or scrolls screen automatically  
67b3			  
67b3			  
67b3			  
67b3			lcd_init:  
67b3			  
67b3			; SCMonAPI functions used  
67b3			  
67b3			; Alphanumeric LCD functions used  
67b3			; no need to specify specific functions for this module  
67b3			  
67b3 3e cf		            LD   A, 11001111b  
67b5 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
67b7 3e 00		            LD   A, 00000000b  
67b9 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
67bb			  
67bb			; Initialise alphanumeric LCD module  
67bb 3e 00				ld a, 0  
67bd 32 ce f8				ld (display_lcde1e2), a  
67c0 cd 41 68		            CALL fLCD_Init      ;Initialise LCD module  
67c3 3e 01				ld a, 1  
67c5 32 ce f8				ld (display_lcde1e2), a  
67c8 cd 41 68		            CALL fLCD_Init      ;Initialise LCD module  
67cb			  
67cb c9				ret  
67cc			  
67cc			;  
67cc			;;  
67cc			; lcd functions  
67cc			;  
67cc			;  
67cc			  
67cc			; what is at cursor position   
67cc			  
67cc			;get_cursor:	ld de, (cursor_row)   ;  row + col  
67cc			;		call curptr  
67cc			;		ret  
67cc			  
67cc			  
67cc			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
67cc			  
67cc			curptr:  
67cc c5				push bc  
67cd 21 b4 fa			ld hl, display_fb0  
67d0			cpr:	  
67d0				; loop for cursor whole row  
67d0 0e 28			ld c, display_cols  
67d2 23			cpr1:	inc hl  
67d3 0d				dec c  
67d4 20 fc			jr nz, cpr1  
67d6 05				dec b  
67d7 20 f7			jr nz, cpr  
67d9			  
67d9				; add col	  
67d9			  
67d9 23			cpr2:	inc hl  
67da 1d				dec e  
67db 20 fc			jr nz, cpr2  
67dd			  
67dd c1				pop bc  
67de c9				ret  
67df				  
67df			  
67df			  
67df			  
67df			  
67df			; write the frame buffer given in hl to hardware   
67df 22 cc f8		write_display: ld (display_write_tmp), hl 	   
67e2 3e 00			ld a, kLCD_Line1  
67e4 cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67e7 06 28			ld b, display_cols  
67e9 ed 5b cc f8		ld de, (display_write_tmp)  
67ed cd 39 68			call write_len_string  
67f0				  
67f0				  
67f0 2a cc f8			ld hl, (display_write_tmp)  
67f3 11 28 00			ld de, display_cols  
67f6 19				add hl,de  
67f7 22 cc f8			ld (display_write_tmp),hl  
67fa			  
67fa				  
67fa 3e 28			ld a, kLCD_Line2  
67fc cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
67ff 06 28			ld b, display_cols  
6801 ed 5b cc f8		ld de, (display_write_tmp)  
6805 cd 39 68			call write_len_string  
6808				  
6808 2a cc f8			ld hl, (display_write_tmp)  
680b 11 28 00			ld de, display_cols  
680e 19				add hl,de  
680f 22 cc f8			ld (display_write_tmp),hl  
6812			  
6812				  
6812 3e 50			ld a, kLCD_Line3  
6814 cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6817 06 28			ld b, display_cols  
6819 ed 5b cc f8		ld de, (display_write_tmp)  
681d cd 39 68			call write_len_string  
6820				  
6820 2a cc f8			ld hl, (display_write_tmp)  
6823 11 28 00			ld de, display_cols  
6826 19				add hl,de  
6827 22 cc f8			ld (display_write_tmp),hl  
682a			  
682a				  
682a 3e 78			ld a, kLCD_Line4  
682c cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
682f 06 28			ld b, display_cols  
6831 ed 5b cc f8		ld de, (display_write_tmp)  
6835 cd 39 68			call write_len_string  
6838 c9					ret  
6839				  
6839				; write out a fixed length string given in b from de  
6839			  
6839 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
683a cd a6 68		            CALL fLCD_Data      ;Write character to display  
683d 13				inc de  
683e 10 f9			djnz write_len_string  
6840 c9				ret  
6841			  
6841			; Some other things to do  
6841			;            LD   A, kLCD_Clear ;Display clear  
6841			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6841			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6841			;            LD   A, kLCD_On     ;Display on with no cursor  
6841			;            ;LD   A, kLCD_Off   ;Display off  
6841			;            CALL fLCD_Inst      ;Send instruction to display  
6841			;  
6841			;  
6841			;            halt  
6841			;  
6841			;  
6841			;MsgHello:   DB  "Hello World!",0  
6841			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6841			  
6841			; Custom characters 5 pixels wide by 8 pixels high  
6841			; Up to 8 custom characters can be defined  
6841			;BitMaps:      
6841			;; Character 0x00 = Battery icon  
6841			;            DB  01110b  
6841			;            DB  11011b  
6841			;            DB  10001b  
6841			;            DB  10001b  
6841			;            DB  11111b  
6841			;            DB  11111b  
6841			;            DB  11111b  
6841			;            DB  11111b  
6841			;; Character 0x01 = Bluetooth icon  
6841			;            DB  01100b  
6841			;            DB  01010b  
6841			;            DB  11100b  
6841			;            DB  01000b  
6841			;            DB  11100b  
6841			;            DB  01010b  
6841			;            DB  01100b  
6841			;            DB  00000b  
6841			;  
6841			  
6841			  
6841			; **********************************************************************  
6841			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6841			; **********************************************************************  
6841			;  
6841			; **  Written as a Small Computer Monitor App   
6841			; **  Version 0.1 SCC 2018-05-16  
6841			; **  www.scc.me.uk  
6841			;  
6841			; **********************************************************************  
6841			;  
6841			; This module provides support for alphanumeric LCD modules using with  
6841			; *  HD44780 (or compatible) controller  
6841			; *  5 x 7 pixel fonts  
6841			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6841			; *  Interface via six digital outputs to the display (see below)  
6841			;  
6841			; LCD module pinout:  
6841			;   1  Vss   0v supply  
6841			;   2  Vdd   5v supply  
6841			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6841			;   4  RS    High = data, Low = instruction  
6841			;   5  R/W   High = Read, Low = Write  
6841			;   6  E     Enable signal (active high)  
6841			;   7  DB0   Data bit 0  
6841			;   8  DB1   Data bit 1  
6841			;   9  DB2   Data bit 2  
6841			;  10  DB3   Data bit 3  
6841			;  11  DB4   Data bit 4  
6841			;  12  DB5   Data bit 5  
6841			;  13  DB6   Data bit 6  
6841			;  14  DB7   Data bit 7  
6841			;  15  A     Backlight anode (+)  
6841			;  16  K     Backlight cathode (-)  
6841			;  
6841			; This interfacing method uses 4-bit data mode and uses time delays  
6841			; rather than polling the display's ready status. As a result the   
6841			; interface only requires 6 simple output lines:  
6841			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6841			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6841			;   LCD DB4 = Microcomputer output port bit 4  
6841			;   LCD DB5 = Microcomputer output port bit 5  
6841			;   LCD DB6 = Microcomputer output port bit 6  
6841			;   LCD DB7 = Microcomputer output port bit 7  
6841			; Display's R/W is connected to 0v so it is always in write mode  
6841			; All 6 connections must be on the same port address <kLCDPrt>  
6841			; This method also allows a decent length of cable from micro to LCD  
6841			;  
6841			; **********************************************************************  
6841			;  
6841			; To include the code for any given function provided by this module,   
6841			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6841			; the parent source file.  
6841			; For example:  #REQUIRES   uHexPrefix  
6841			;  
6841			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6841			; in the parent source file.  
6841			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6841			;  
6841			; These are the function names provided by this module:  
6841			; fLCD_Init                     ;Initialise LCD  
6841			; fLCD_Inst                     ;Send instruction to LCD  
6841			; fLCD_Data                     ;Send data byte to LCD  
6841			; fLCD_Pos                      ;Position cursor  
6841			; fLCD_Str                      ;Display string  
6841			; fLCD_Def                      ;Define custom character  
6841			;  
6841			; **********************************************************************  
6841			;  
6841			; Requires SCMonAPI.asm to also be included in the project  
6841			;  
6841			  
6841			  
6841			; **********************************************************************  
6841			; **  Constants  
6841			; **********************************************************************  
6841			  
6841			; Constants that must be defined externally  
6841			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6841			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6841			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6841			;kLCDWidth: EQU 20             ;Width in characters  
6841			  
6841			; general line offsets in any frame buffer  
6841			  
6841			  
6841			display_row_1: equ 0  
6841			display_row_2: equ display_row_1+display_cols  
6841			display_row_3: equ display_row_2 + display_cols  
6841			display_row_4: equ display_row_3 + display_cols  
6841			;display_row_4_eol:   
6841			  
6841			  
6841			; Cursor position values for the start of each line  
6841			  
6841			; E  
6841			kLCD_Line1: EQU 0x00   
6841			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6841			; E1  
6841			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6841			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6841			  
6841			; Instructions to send as A register to fLCD_Inst  
6841			kLCD_Clear: EQU 00000001b     ;LCD clear  
6841			kLCD_Off:   EQU 00001000b     ;LCD off  
6841			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6841			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6841			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6841			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6841			  
6841			; Constants used by this code module  
6841			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6841			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6841			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6841			  
6841			  
6841			  
6841			; **********************************************************************  
6841			; **  LCD support functions  
6841			; **********************************************************************  
6841			  
6841			; Initialise alphanumeric LCD module  
6841			; LCD control register codes:  
6841			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6841			;   N    0 = 1-line mode       1 = 2-line mode  
6841			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6841			;   D    0 = Display off       1 = Display on  
6841			;   C    0 = Cursor off        1 = Cursor on  
6841			;   B    0 = Blinking off      1 = Blinking on  
6841			;   ID   0 = Decrement mode    1 = Increment mode  
6841			;   SH   0 = Entire shift off  1 = Entire shift on  
6841 3e 28		fLCD_Init:  LD   A, 40  
6843 cd 68 69		            CALL LCDDelay       ;Delay 40ms after power up  
6846			; For reliable reset set 8-bit mode - 3 times  
6846 cd 38 69		            CALL WrFn8bit       ;Function = 8-bit mode  
6849 cd 38 69		            CALL WrFn8bit       ;Function = 8-bit mode  
684c cd 38 69		            CALL WrFn8bit       ;Function = 8-bit mode  
684f			; Set 4-bit mode  
684f cd 34 69		            CALL WrFn4bit       ;Function = 4-bit mode  
6852 cd 66 69		            CALL LCDDelay1      ;Delay 37 us or more  
6855			; Function set  
6855 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6857 cd 6a 68		            CALL fLCD_Inst      ;2 line, display on  
685a			; Display On/Off control  
685a 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
685c cd 6a 68		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
685f			; Display Clear  
685f 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6861 cd 6a 68		            CALL fLCD_Inst      ;Clear display  
6864			; Entry mode  
6864 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6866 cd 6a 68		            CALL fLCD_Inst      ;Increment mode, shift off  
6869			; Display module now initialised  
6869 c9			            RET  
686a			; ok to here  
686a			  
686a			; Write instruction to LCD  
686a			;   On entry: A = Instruction byte to be written  
686a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
686a f5			fLCD_Inst:  PUSH AF  
686b f5			            PUSH AF  
686c cd 7e 68		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
686f f1			            POP  AF  
6870 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6871 17			            RLA  
6872 17			            RLA  
6873 17			            RLA  
6874 cd 7e 68		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6877 3e 02		            LD   A, 2  
6879 cd 68 69		            CALL LCDDelay       ;Delay 2 ms to complete   
687c f1			            POP  AF  
687d c9			            RET  
687e			Wr4bits:   
687e f5					push af  
687f 3a ce f8				ld a, (display_lcde1e2)  
6882 fe 00				cp 0     ; e  
6884 20 10				jr nz, .wea2	  
6886 f1					pop af  
6887 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6889 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
688b cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
688d cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
688f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6891 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6893 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6895 c9			            RET  
6896 f1			.wea2:		pop af  
6897 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6899 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
689b cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
689d cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
689f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
68a1 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
68a3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68a5 c9			            RET  
68a6			  
68a6			  
68a6			; Write data to LCD  
68a6			;   On entry: A = Data byte to be written  
68a6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
68a6 f5			fLCD_Data:  PUSH AF  
68a7 f5			            PUSH AF  
68a8 cd ba 68		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
68ab f1			            POP  AF  
68ac 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
68ad 17			            RLA  
68ae 17			            RLA  
68af 17			            RLA  
68b0 cd ba 68		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
68b3 3e 96		            LD   A, 150  
68b5 3d			Wait:      DEC  A              ;Wait a while to allow data   
68b6 20 fd		            JR   NZ, Wait      ;  write to complete  
68b8 f1			            POP  AF  
68b9 c9			            RET  
68ba			Wr4bitsa:     
68ba f5					push af  
68bb 3a ce f8				ld a, (display_lcde1e2)  
68be fe 00				cp 0     ; e1  
68c0 20 16				jr nz, .we2	  
68c2 f1					pop af  
68c3 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
68c5 cb d7		            SET  kLCDBitRS, A  
68c7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
68c9 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
68cb cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
68cd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
68cf cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
68d1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
68d3 cb 97		            RES  kLCDBitRS, A  
68d5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68d7 c9			            RET  
68d8 f1			.we2:		pop af  
68d9 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
68db cb d7		            SET  kLCDBitRS, A  
68dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
68df cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
68e1 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
68e3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
68e5 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
68e7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
68e9 cb 97		            RES  kLCDBitRS, A  
68eb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
68ed c9			            RET  
68ee			  
68ee			  
68ee			; Position cursor to specified location  
68ee			;   On entry: A = Cursor position  
68ee			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
68ee f5			fLCD_Pos:   PUSH AF  
68ef					; at this point set the E1 or E2 flag depending on position  
68ef			  
68ef c5					push bc  
68f0			;		push af  
68f0 06 00				ld b, 0  
68f2 4f					ld c, a  
68f3 3e 4f				ld a, kLCD_Line3-1  
68f5 b7			 		or a      ;clear carry flag  
68f6 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
68f7 38 04				jr c, .pe1  
68f9			  
68f9					; E selection  
68f9 cb 80				res 0, b         ; bit 0 unset e  
68fb			;		pop af    ; before line 3 so recover orig pos  
68fb			;		ld c, a    ; save for poking back  
68fb 18 06				jr .peset	          
68fd			.pe1:          	; E2 selection  
68fd cb c0				set 0, b         ; bit 0 set e1  
68ff 79					ld a, c  
6900 de 4f				sbc a, kLCD_Line3-1  
6902 4f					ld c, a	         ; save caculated offset  
6903			;		pop af     ; bin this original value now we have calculated form  
6903			  
6903			.peset:		; set bit  
6903 78					ld a, b  
6904 32 ce f8				ld (display_lcde1e2), a 	  
6907 79					ld a, c  
6908 c1					pop bc  
6909			  
6909 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
690b cd 6a 68		            CALL fLCD_Inst      ;Write instruction to LCD  
690e f1			            POP  AF  
690f c9			            RET  
6910			  
6910			  
6910			; Output text string to LCD  
6910			;   On entry: DE = Pointer to null terminated text string  
6910			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6910 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6911 b7			            OR   A              ;Null terminator?  
6912 c8			            RET  Z              ;Yes, so finished  
6913 cd a6 68		            CALL fLCD_Data      ;Write character to display  
6916 13			            INC  DE             ;Point to next character  
6917 18 f7		            JR   fLCD_Str       ;Repeat  
6919 c9					ret  
691a			  
691a			; Define custom character  
691a			;   On entry: A = Character number (0 to 7)  
691a			;             DE = Pointer to character bitmap data  
691a			;   On exit:  A = Next character number  
691a			;             DE = Next location following bitmap  
691a			;             BC HL IX IY I AF' BC' DE' HL' preserved  
691a			; Character is   
691a c5			fLCD_Def:   PUSH BC  
691b f5			            PUSH AF  
691c 07			            RLCA                ;Calculate location  
691d 07			            RLCA                ;  for bitmap data  
691e 07			            RLCA                ;  = 8 x CharacterNumber  
691f f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6921 cd 6a 68		            CALL fLCD_Inst      ;Write instruction to LCD  
6924 06 00		            LD   B, 0  
6926 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6927 cd a6 68		            CALL fLCD_Data      ;Write byte to display  
692a 13			            INC  DE             ;Point to next byte  
692b 04			            INC  B              ;Count bytes  
692c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
692e 28 f6		            JR   Z, Loop       ;No, so repeat  
6930 f1			            POP  AF  
6931 3c			            INC  A              ;Increment character number  
6932 c1			            POP  BC  
6933 c9			            RET  
6934			  
6934			  
6934			; **********************************************************************  
6934			; **  Private functions  
6934			; **********************************************************************  
6934			  
6934			; Write function to LCD  
6934			;   On entry: A = Function byte to be written  
6934			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6934 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6936 18 02		            JR   WrFunc  
6938 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
693a f5			WrFunc:     PUSH AF  
693b f5					push af  
693c 3a ce f8				ld a, (display_lcde1e2)  
693f fe 00				cp 0     ; e1  
6941 20 0f				jr nz, .wfea2	  
6943 f1					pop af  
6944 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6946 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6948 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
694a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
694c cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
694e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6950 18 0d			jr .wfskip  
6952 f1			.wfea2:		pop af  
6953 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6955 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6957 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6959 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
695b cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
695d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
695f 3e 05		.wfskip:            LD  A, 5  
6961 cd 68 69		            CALL LCDDelay       ;Delay 5 ms to complete  
6964 f1			            POP  AF  
6965 c9			            RET  
6966			  
6966			  
6966			; Delay in milliseconds  
6966			;   On entry: A = Number of milliseconds delay  
6966			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6966 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6968 d5			LCDDelay:   PUSH DE  
6969 5f			            LD   E, A           ;Delay by 'A' ms  
696a 16 00		            LD   D, 0  
696c cd 0b 0b		            CALL aDelayInMS  
696f d1			            POP  DE  
6970 c9			            RET  
6971			  
6971			  
6971			testlcd:  
6971 3e 00			ld a, kLCD_Line1  
6973 cd ee 68			call fLCD_Pos  
6976 06 28			ld b, 40  
6978 11 a6 69			ld de, .ttext1  
697b cd 39 68			call write_len_string  
697e			  
697e 3e 28			ld a, kLCD_Line2  
6980 cd ee 68			call fLCD_Pos  
6983 06 28			ld b, 40  
6985 11 cf 69			ld de, .ttext2  
6988 cd 39 68			call write_len_string  
698b 3e 50			ld a, kLCD_Line3  
698d cd ee 68			call fLCD_Pos  
6990 06 28			ld b, 40  
6992 11 f8 69			ld de, .ttext3  
6995 cd 39 68			call write_len_string  
6998 3e 78			ld a, kLCD_Line4  
699a cd ee 68			call fLCD_Pos  
699d 06 28			ld b, 40  
699f 11 21 6a			ld de, .ttext4  
69a2 cd 39 68			call write_len_string  
69a5			  
69a5 76				halt  
69a6			  
69a6			  
69a6 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
69cf .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
69f8 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6a21 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6a4a			   
6a4a			  
6a4a			  
6a4a			; eof  
6a4a			  
# End of file firmware_lcd_4x40.asm
6a4a			;include "firmware_lcd_4x20.asm" 
6a4a			include "firmware_key_5x10.asm" 
6a4a			; 5 x 10 decade counter scanner  
6a4a			  
6a4a			  
6a4a			; TODO do cursor shape change for shift keys  
6a4a			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6a4a			  
6a4a			  
6a4a			; bit mask for each scan column and row for teing the matrix  
6a4a			  
6a4a			  
6a4a			key_init:  
6a4a			  
6a4a			; SCMonAPI functions used  
6a4a			  
6a4a			; Alphanumeric LCD functions used  
6a4a			; no need to specify specific functions for this module  
6a4a			  
6a4a			  
6a4a 3e cf		            LD   A, 11001111b  
6a4c d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6a4e			;            LD   A, 00000000b  
6a4e 3e 1f		            LD   A, 00011111b  
6a50 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6a52			  
6a52			  
6a52				; TODO Configure cursor shapes  
6a52			  
6a52				; Load cursor shapes   
6a52 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6a54 11 64 6a		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6a57 06 02		            LD   B, 2           ;Number of characters to define  
6a59 cd 1a 69		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6a5c 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6a5e			  
6a5e 3e 01				ld a, 1  
6a60 32 c7 f8			ld (cursor_shape),a  
6a63 c9				ret  
6a64			  
6a64			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6a64			; Up to 8 custom characters can be defined  
6a64			.cursor_shapes:      
6a64			;; Character 0x00 = Normal  
6a64 1f			            DB  11111b  
6a65 1f			            DB  11111b  
6a66 1f			            DB  11111b  
6a67 1f			            DB  11111b  
6a68 1f			            DB  11111b  
6a69 1f			            DB  11111b  
6a6a 1f			            DB  11111b  
6a6b 1f			            DB  11111b  
6a6c			;; Character 0x01 = Modifier  
6a6c 1f			            DB  11111b  
6a6d 1b			            DB  11011b  
6a6e 1b			            DB  11011b  
6a6f 1b			            DB  11011b  
6a70 1b			            DB  11011b  
6a71 1f			            DB  11111b  
6a72 1b			            DB  11011b  
6a73 1f			            DB  11111b  
6a74			  
6a74			  
6a74			  
6a74			  
6a74			; Display custom character 0  
6a74			;            LD   A, kLCD_Line1+14  
6a74			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a74			;            LD   A, 0  
6a74			;            CALL fLCD_Data      ;Write character in A at cursor  
6a74			  
6a74			; Display custom character 1  
6a74			;            LD   A, kLCD_Line2+14  
6a74			;            CALL fLCD_Pos      ;Position cursor to location in A  
6a74			;            LD   A, 1  
6a74			;            CALL fLCD_Data     ;Write character in A at cursor  
6a74			  
6a74			; keyboard scanning   
6a74			  
6a74			; character in from keyboard  
6a74			  
6a74			; mapping for the pcb layout  
6a74			  
6a74			.matrix_to_char:  
6a74 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6a7f .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6a8a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6a95 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6aa0 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6aab			.matrix_to_shift:  
6aab			  
6aab .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6ab6 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6ac1 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6acc 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6ad7 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6ae2			  
6ae2			.matrix_to_symbolshift:  
6ae2			  
6ae2 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6aed .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6af8 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6b03			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6b03 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6b0e .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6b19			  
6b19			  
6b19			  
6b19			; mapping for a simple straight through breadboard layout  
6b19			  
6b19			;.matrix_to_char:  
6b19			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6b19			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6b19			;		db "asdfghjkl",KEY_CR,0  
6b19			;		db "qwertyuiop",0  
6b19			;		 db "1234567890",0  
6b19			;.matrix_to_shift:  
6b19			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6b19			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6b19			;		db "ASDFGHJKL",KEY_CR,0  
6b19			;		db "QWERTYUIOP",0  
6b19			;		 db "!",'"',"#$%^&*()",0  
6b19			;.matrix_to_symbolshift:  
6b19			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6b19			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6b19			;		db "_?*fghjk=",KEY_CR,0  
6b19			;		db "-/+*[]{}@#",0  
6b19			;		 db "1234567890",0  
6b19			  
6b19			;.matrix_to_char: db "D#0*C987B654A321"  
6b19			  
6b19			  
6b19				  
6b19			  
6b19			; add cin and cin_wait  
6b19			  
6b19 cd 2a 6b		cin_wait: 	call cin  
6b1c						if DEBUG_KEYCINWAIT  
6b1c							push af  
6b1c							  
6b1c							ld hl,key_repeat_ct  
6b1c							ld (hl),a  
6b1c							inc hl  
6b1c							call hexout  
6b1c							ld hl,key_repeat_ct+3  
6b1c							ld a,0  
6b1c							ld (hl),a  
6b1c			  
6b1c							    LD   A, kLCD_Line1+11  
6b1c							    CALL fLCD_Pos       ;Position cursor to location in A  
6b1c							    LD   DE, key_repeat_ct  
6b1c							    ;LD   DE, MsgHello  
6b1c							    CALL fLCD_Str       ;Display string pointed to by DE  
6b1c			  
6b1c			  
6b1c			  
6b1c							pop af  
6b1c						endif  
6b1c fe 00			cp 0  
6b1e 28 f9			jr z, cin_wait   ; block until key press  
6b20			  
6b20							if DEBUG_KEYCINWAIT  
6b20								push af  
6b20			  
6b20								ld a, 'A'	  
6b20								ld hl,key_repeat_ct  
6b20								ld (hl),a  
6b20								inc hl  
6b20								ld a,0  
6b20								ld (hl),a  
6b20			  
6b20								    LD   A, kLCD_Line2+11  
6b20								    CALL fLCD_Pos       ;Position cursor to location in A  
6b20								    LD   DE, key_repeat_ct  
6b20								    ;LD   DE, MsgHello  
6b20								    CALL fLCD_Str       ;Display string pointed to by DE  
6b20			  
6b20							call delay500ms  
6b20			  
6b20								pop af  
6b20							endif  
6b20 f5				push af   ; save key pressed  
6b21			  
6b21			.cin_wait1:	  
6b21							if DEBUG_KEYCINWAIT  
6b21								push af  
6b21			  
6b21								ld a, 'b'	  
6b21								ld hl,key_repeat_ct  
6b21								ld (hl),a  
6b21								inc hl  
6b21								ld a,0  
6b21								ld (hl),a  
6b21			  
6b21								    LD   A, kLCD_Line2+11  
6b21								    CALL fLCD_Pos       ;Position cursor to location in A  
6b21								    LD   DE, key_repeat_ct  
6b21								    ;LD   DE, MsgHello  
6b21								    CALL fLCD_Str       ;Display string pointed to by DE  
6b21			  
6b21			  
6b21							call delay500ms  
6b21			  
6b21								pop af  
6b21							endif  
6b21			  
6b21 cd 2a 6b		call cin  
6b24 fe 00			cp 0  
6b26 20 f9			jr nz, .cin_wait1  	; wait for key release  
6b28			if DEBUG_KEYCINWAIT  
6b28				push af  
6b28			  
6b28				ld a, '3'	  
6b28				ld hl,key_repeat_ct  
6b28				ld (hl),a  
6b28				inc hl  
6b28				ld a,0  
6b28				ld (hl),a  
6b28			  
6b28			            LD   A, kLCD_Line2+11  
6b28			            CALL fLCD_Pos       ;Position cursor to location in A  
6b28			            LD   DE, key_repeat_ct  
6b28			            ;LD   DE, MsgHello  
6b28			            CALL fLCD_Str       ;Display string pointed to by DE  
6b28			  
6b28			  
6b28			call delay500ms  
6b28			  
6b28				pop af  
6b28			endif  
6b28			  
6b28 f1				pop af   ; get key  
6b29 c9				ret  
6b2a			  
6b2a			  
6b2a cd 3e 6b		cin: 	call .mtoc  
6b2d			  
6b2d			if DEBUG_KEYCIN  
6b2d				push af  
6b2d				  
6b2d				ld hl,key_repeat_ct  
6b2d				ld (hl),a  
6b2d				inc hl  
6b2d				call hexout  
6b2d				ld hl,key_repeat_ct+3  
6b2d				ld a,0  
6b2d				ld (hl),a  
6b2d			  
6b2d			            LD   A, kLCD_Line3+15  
6b2d			            CALL fLCD_Pos       ;Position cursor to location in A  
6b2d			            LD   DE, key_repeat_ct  
6b2d			            ;LD   DE, MsgHello  
6b2d			            CALL fLCD_Str       ;Display string pointed to by DE  
6b2d			  
6b2d			  
6b2d			call delay500ms  
6b2d			  
6b2d				pop af  
6b2d			endif  
6b2d			  
6b2d			  
6b2d				; no key held  
6b2d fe 00			cp 0  
6b2f c8				ret z  
6b30			  
6b30			if DEBUG_KEYCIN  
6b30				push af  
6b30			  
6b30				ld a, '1'	  
6b30				ld hl,key_repeat_ct  
6b30				ld (hl),a  
6b30				inc hl  
6b30				ld a,0  
6b30				ld (hl),a  
6b30			  
6b30			            LD   A, kLCD_Line4+15  
6b30			            CALL fLCD_Pos       ;Position cursor to location in A  
6b30			            LD   DE, key_repeat_ct  
6b30			            ;LD   DE, MsgHello  
6b30			            CALL fLCD_Str       ;Display string pointed to by DE  
6b30			  
6b30			  
6b30			call delay500ms  
6b30			  
6b30				pop af  
6b30			endif  
6b30			  
6b30				; stop key bounce  
6b30			  
6b30 32 88 fb			ld (key_held),a		 ; save it  
6b33 47				ld b, a  
6b34			  
6b34 c5			.cina1:	push bc  
6b35			if DEBUG_KEYCIN  
6b35				push af  
6b35			  
6b35				ld hl,key_repeat_ct  
6b35				inc hl  
6b35				call hexout  
6b35				ld hl,key_repeat_ct+3  
6b35				ld a,0  
6b35				ld (hl),a  
6b35				ld hl,key_repeat_ct  
6b35				ld a, '2'	  
6b35				ld (hl),a  
6b35			  
6b35			            LD   A, kLCD_Line4+15  
6b35			            CALL fLCD_Pos       ;Position cursor to location in A  
6b35			            LD   DE, key_repeat_ct  
6b35			            ;LD   DE, MsgHello  
6b35			            CALL fLCD_Str       ;Display string pointed to by DE  
6b35			  
6b35				pop af  
6b35			endif  
6b35 cd 3e 6b			call .mtoc  
6b38 c1				pop bc  
6b39 b8				cp b  
6b3a 28 f8			jr z, .cina1  
6b3c 78				ld a,b		  
6b3d			if DEBUG_KEYCIN  
6b3d				push af  
6b3d			  
6b3d				ld hl,key_repeat_ct  
6b3d				inc hl  
6b3d				call hexout  
6b3d				ld hl,key_repeat_ct+3  
6b3d				ld a,0  
6b3d				ld (hl),a  
6b3d				ld hl,key_repeat_ct  
6b3d				ld a, '3'	  
6b3d				ld (hl),a  
6b3d			  
6b3d			            LD   A, kLCD_Line4+15  
6b3d			            CALL fLCD_Pos       ;Position cursor to location in A  
6b3d			            LD   DE, key_repeat_ct  
6b3d			            ;LD   DE, MsgHello  
6b3d			            CALL fLCD_Str       ;Display string pointed to by DE  
6b3d			  
6b3d				pop af  
6b3d			endif  
6b3d c9				ret  
6b3e			  
6b3e			; detect keyboard modifier key press and apply new overlay to the face key held  
6b3e			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6b3e			  
6b3e			;.cin_map_modifier:   
6b3e			;	ld a, (hl)  
6b3e			;	and 255  
6b3e			;	ret NZ		; modifier key not flagged  
6b3e			;  
6b3e			;	; get key face  
6b3e			;  
6b3e			;	ld b,(key_face_held)  
6b3e			;  
6b3e			;	ld b, key_cols * key_rows  
6b3e			;  
6b3e			;	push de  
6b3e			;	pop hl  
6b3e			;  
6b3e			;.mmod1: ld a,(hl)   ; get map test  
6b3e			;	cp b  
6b3e			;	jr z, .mmod2  
6b3e			;  
6b3e			;  
6b3e			;  
6b3e			;.mmod2: inc hl    ;   
6b3e			;  
6b3e			;	  
6b3e			;  
6b3e			;	  
6b3e			;  
6b3e			;	ld hl,key_actual_pressed  
6b3e			;	ld (hl),a,  
6b3e			;	ret  
6b3e			  
6b3e			; map matrix key held to char on face of key  
6b3e			  
6b3e			.mtoc:  
6b3e			  
6b3e			; test decade counter strobes  
6b3e			  
6b3e			;.decadetest1:  
6b3e			  
6b3e			; reset counter  
6b3e			;ld a, 128  
6b3e			;out (portbdata),a  
6b3e			  
6b3e			  
6b3e			;ld b, 5  
6b3e			;.dec1:  
6b3e			;ld a, 0  
6b3e			;out (portbdata),a  
6b3e			;call delay1s  
6b3e			  
6b3e			;ld a, 32  
6b3e			;out (portbdata),a  
6b3e			;call delay1s  
6b3e			;call delay1s  
6b3e			;call delay1s  
6b3e			;  
6b3e			;ld a, 64+32  
6b3e			;out (portbdata),a  
6b3e			;call delay1s  
6b3e			;;djnz .dec1  
6b3e			;  
6b3e			;jp .decadetest1  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e			  
6b3e				; scan keyboard matrix and generate raw scan map  
6b3e cd d1 6b			call matrix  
6b41			  
6b41				; reuse c bit 0 left modifer button - ie shift  
6b41			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6b41				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6b41			  
6b41 0e 00			ld c, 0  
6b43			  
6b43				; TODO set flags for modifer key presses   
6b43				; TODO do a search for modifer key...  
6b43			  
6b43				;ld hl,keyscan_table_row4  
6b43 21 e7 fb			ld hl,keyscan_table_row2  
6b46			  
6b46 7e				ld a, (hl)  
6b47 fe 23			cp '#'  
6b49 20 07			jr nz, .nextmodcheck  
6b4b cb c1			set 0, c  
6b4d 21 ab 6a			ld hl, .matrix_to_shift  
6b50 18 21			jr .dokeymap  
6b52				; TODO for now igonre  
6b52			.nextmodcheck:  
6b52 21 dc fb			ld hl,keyscan_table_row3  
6b55			  
6b55 7e				ld a, (hl)  
6b56 fe 23			cp '#'  
6b58 20 07			jr nz, .nextmodcheck2  
6b5a cb c9			set 1, c   
6b5c 21 e2 6a			ld hl, .matrix_to_symbolshift  
6b5f 18 12			jr .dokeymap  
6b61			.nextmodcheck2:  
6b61 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6b64			  
6b64 7e				ld a, (hl)  
6b65 fe 23			cp '#'  
6b67 20 07			jr nz, .donemodcheck  
6b69 cb c9			set 1, c   
6b6b 21 ab 6a			ld hl, .matrix_to_shift  
6b6e 18 03			jr .dokeymap  
6b70			  
6b70				; no modifer found so just map to normal keys  
6b70				; get mtoc map matrix to respective keys  
6b70			;	ld hl, .matrix_to_char  
6b70			;	ld hl, .matrix_to_char  
6b70			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6b70			;	ld a, KEY_SHIFT  
6b70			;	call findchar  
6b70			;  
6b70			;	; got offset to key modifer in b  
6b70			;  
6b70			;	ld hl,keyscan_table_row5  
6b70			;  
6b70			;	ld a,b  
6b70			;	call addatohl  
6b70			;	ld a,(hl)  
6b70			;  
6b70			;	cp '#'  
6b70			;	jr nz, .nextmodcheck  
6b70			;	set 0, c  
6b70			;	ld hl, .matrix_to_char  
6b70			;	jr .dokeymap  
6b70			;	; TODO for now igonre  
6b70			;.nextmodcheck:  
6b70			;	ld hl, .matrix_to_symbolshift  
6b70			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6b70			;	ld a, KEY_SYMBOLSHIFT  
6b70			;	call findchar  
6b70			;  
6b70			;  
6b70			;	; got offset to key modifer in b  
6b70			;  
6b70			;	ld hl,keyscan_table_row5  
6b70			;  
6b70			;	ld a,b  
6b70			;	call addatohl  
6b70			;	ld a,(hl)  
6b70			;  
6b70			;	cp '#'  
6b70			;	jr nz, .donemodcheck  
6b70			;	set 1, c   
6b70			;	ld hl, .matrix_to_symbolshift  
6b70			;	jr .dokeymap  
6b70			  
6b70			  
6b70			  
6b70			.donemodcheck:  
6b70				; no modifer found so just map to normal keys  
6b70				; get mtoc map matrix to respective keys  
6b70 21 74 6a			ld hl, .matrix_to_char  
6b73			  
6b73			.dokeymap:  
6b73				;ld (key_fa), c   
6b73 cd 8c 6b			call .mapkeys  
6b76			  
6b76			  
6b76			if DEBUG_KEY  
6b76			  
6b76			; Display text on first line  
6b76			            LD   A, kLCD_Line1  
6b76			            CALL fLCD_Pos       ;Position cursor to location in A  
6b76			            LD   DE, keyscan_table_row1  
6b76			            ;LD   DE, MsgHello  
6b76			            CALL fLCD_Str       ;Display string pointed to by DE  
6b76			  
6b76			; Display text on second line  
6b76			            LD   A, kLCD_Line2  
6b76			            CALL fLCD_Pos       ;Position cursor to location in A  
6b76			            LD   DE, keyscan_table_row2  
6b76			            CALL fLCD_Str       ;Display string pointed to by DE  
6b76			            LD   A, kLCD_Line3  
6b76			            CALL fLCD_Pos       ;Position cursor to location in A  
6b76			            LD   DE, keyscan_table_row3  
6b76			            CALL fLCD_Str       ;Display string pointed to by DE  
6b76			            LD   A, kLCD_Line4  
6b76			            CALL fLCD_Pos       ;Position cursor to location in A  
6b76			            LD   DE, keyscan_table_row4  
6b76			            CALL fLCD_Str       ;Display string pointed to by DE  
6b76			            LD   A, kLCD_Line1+10  
6b76			            CALL fLCD_Pos       ;Position cursor to location in A  
6b76			            LD   DE, keyscan_table_row5  
6b76			            CALL fLCD_Str       ;Display string pointed to by DE  
6b76			  
6b76				;call delay250ms  
6b76			endif  
6b76			;	jp testkey  
6b76			  
6b76			; get first char reported  
6b76			  
6b76 21 c6 fb			ld hl,keyscan_table_row5  
6b79			  
6b79				;ld b, 46   ; 30 keys to remap + 8 nulls   
6b79 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6b7b			.findkey:  
6b7b 7e				ld a,(hl)  
6b7c fe 00			cp 0  
6b7e 28 04			jr z, .nextkey  
6b80 fe 7e			cp KEY_MATRIX_NO_PRESS  
6b82 20 06			jr nz, .foundkey  
6b84			.nextkey:  
6b84 23				inc hl  
6b85 10 f4			djnz .findkey  
6b87 3e 00			ld a,0  
6b89 c9				ret  
6b8a			.foundkey:  
6b8a 7e				ld a,(hl)  
6b8b c9				ret  
6b8c				  
6b8c			  
6b8c			; convert the raw key map given hl for destination key  
6b8c			.mapkeys:  
6b8c 11 c6 fb			ld de,keyscan_table_row5  
6b8f			  
6b8f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6b91			.remap:  
6b91 1a				ld a,(de)  
6b92 fe 23			cp '#'  
6b94 20 02			jr nz, .remapnext  
6b96				;CALLMONITOR  
6b96 7e				ld a,(hl)  
6b97 12				ld (de),a  
6b98			  
6b98			  
6b98			  
6b98			.remapnext:  
6b98 23				inc hl  
6b99 13				inc de  
6b9a 10 f5			djnz .remap  
6b9c				  
6b9c c9				ret  
6b9d			  
6b9d			  
6b9d			  
6b9d			.mtocold2:  
6b9d			  
6b9d			;	; flag if key D is held down and remove from reporting  
6b9d			;	ld bc, .key_map_fd    
6b9d			;	ld hl, keyscan_table  
6b9d			;	ld de, key_fd  
6b9d			;	call .key_shift_hold  
6b9d			;	cp 255  
6b9d			;	jr z, .cinmap  
6b9d			;	; flag if key C is held down and remove from reporting  
6b9d			;	ld bc, .key_map_fc    
6b9d			;	ld hl, keyscan_table+key_cols  
6b9d			;	ld de, key_fc  
6b9d			;	call .key_shift_hold  
6b9d			;	cp 255  
6b9d			;	jr z, .cinmap  
6b9d			;	; flag if key B is held down and remove from reporting  
6b9d			;	ld bc, .key_map_fb    
6b9d			;	ld hl, keyscan_table+(key_cols*2)  
6b9d			;	ld de, key_fb  
6b9d			;	call .key_shift_hold  
6b9d			;	cp 255  
6b9d			;	jr z, .cinmap  
6b9d			;	; flag if key A is held down and remove from reporting  
6b9d			;	ld bc, .key_map_fa    
6b9d			;	ld hl, keyscan_table+(key_cols*3)  
6b9d			;	ld de, key_fa  
6b9d			;	call .key_shift_hold  
6b9d			;	cp 255  
6b9d			;	jr z, .cinmap  
6b9d			  
6b9d 11 74 6a			ld de, .matrix_to_char  
6ba0			  
6ba0			  
6ba0			.cinmap1:   
6ba0				if DEBUG_KEY  
6ba0			            LD   A, kLCD_Line4  
6ba0			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba0					push de  
6ba0			            LD   DE, keyscan_table  
6ba0			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba0					pop de  
6ba0				endif  
6ba0			  
6ba0				; scan key matrix table for any held key  
6ba0			  
6ba0				; de holds either the default matrix or one selected above  
6ba0			  
6ba0 21 93 fb			ld hl, keyscan_table  
6ba3 06 32			ld b,key_cols*key_rows  
6ba5			  
6ba5 7e			.cin11:	ld a,(hl)  
6ba6 fe 23			cp '#'  
6ba8 28 08			jr z, .cinhit1  
6baa 23				inc hl  
6bab 13				inc de  
6bac 05				dec b  
6bad 20 f6			jr nz, .cin11  
6baf				; no key found held  
6baf 3e 00			ld a,0  
6bb1 c9				ret  
6bb2 d5			.cinhit1: push de  
6bb3 e1				pop hl  
6bb4 7e				ld a,(hl)  
6bb5 c9				ret  
6bb6			  
6bb6			; flag a control key is held   
6bb6			; hl is key pin, de is flag indicator  
6bb6			  
6bb6			.key_shift_hold1:  
6bb6 c5				push bc  
6bb7 3e 01			ld a, 1  
6bb9 32 c7 f8			ld (cursor_shape),a  
6bbc 06 00			ld b, 0  
6bbe 7e				ld a, (hl)  
6bbf fe 2e			cp '.'  
6bc1 28 0a			jr z, .key_shift11  
6bc3 06 ff			ld b, 255  
6bc5 3e 2b			ld a, '+'    ; hide key from later scans  
6bc7 77				ld (hl),a  
6bc8 3e 02			ld a, 2  
6bca 32 c7 f8			ld (cursor_shape),a  
6bcd			.key_shift11:  
6bcd				; write flag indicator  
6bcd 78				ld a,b  
6bce 12				ld (de),a  
6bcf			  
6bcf d1				pop de    ; de now holds the key map ptr  
6bd0 c9				ret  
6bd1			  
6bd1				  
6bd1			  
6bd1			; scans keyboard matrix and flags key press in memory array	  
6bd1				  
6bd1			matrix:  
6bd1				;call matrix  
6bd1				; TODO optimise the code....  
6bd1			  
6bd1			  
6bd1			;ld hl, keyscan_table_row1  
6bd1			;ld de, keyscan_table_row1+1  
6bd1			;ld bc,46  
6bd1			;ld a,KEY_MATRIX_NO_PRESS  
6bd1			;ldir  
6bd1			  
6bd1			  
6bd1			  
6bd1			; reset counter  
6bd1 3e 80		ld a, 128  
6bd3 d3 c1		out (portbdata),a  
6bd5			  
6bd5 06 0a		ld b, 10  
6bd7 0e 00		ld c, 0       ; current clock toggle  
6bd9			  
6bd9			.colscan:  
6bd9			  
6bd9			; set current column  
6bd9			; disable clock enable and set clock low  
6bd9			  
6bd9			;ld a, 0  
6bd9			;out (portbdata),a  
6bd9			  
6bd9			; For each column scan for switches  
6bd9			  
6bd9 c5			push bc  
6bda 21 89 fb		ld hl, keyscan_scancol  
6bdd cd e6 6c		call .rowscan  
6be0 c1			pop bc  
6be1			  
6be1			  
6be1			; get back current column  
6be1			  
6be1			; translate the row scan  
6be1			  
6be1			;   
6be1			; row 1  
6be1			  
6be1 78			ld a,b  
6be2			  
6be2 21 fc fb		LD   hl, keyscan_table_row1+10  
6be5			  
6be5 cd ef 0d		call subafromhl  
6be8			;call addatohl  
6be8			  
6be8 11 89 fb		ld de, keyscan_scancol  
6beb			  
6beb 1a			ld a,(de)  
6bec 77			ld (hl),a  
6bed			  
6bed			  
6bed			  
6bed			  
6bed			; row 2  
6bed			  
6bed 78			ld a,b  
6bee			  
6bee 21 f1 fb		LD   hl, keyscan_table_row2+10  
6bf1			  
6bf1			;call addatohl  
6bf1 cd ef 0d		call subafromhl  
6bf4			  
6bf4			  
6bf4 11 8a fb		ld de, keyscan_scancol+1  
6bf7			  
6bf7 1a			ld a,(de)  
6bf8 77			ld (hl),a  
6bf9			  
6bf9			  
6bf9			; row 3  
6bf9			  
6bf9 78			ld a,b  
6bfa			  
6bfa 21 e6 fb		LD   hl, keyscan_table_row3+10  
6bfd			  
6bfd			;call addatohl  
6bfd cd ef 0d		call subafromhl  
6c00			  
6c00 11 8b fb		ld de, keyscan_scancol+2  
6c03			  
6c03 1a			ld a,(de)  
6c04 77			ld (hl),a  
6c05			  
6c05			  
6c05			  
6c05			; row 4  
6c05			  
6c05 78			ld a,b  
6c06			  
6c06 21 db fb		LD   hl, keyscan_table_row4+10  
6c09			  
6c09			;call addatohl  
6c09 cd ef 0d		call subafromhl  
6c0c			  
6c0c 11 8c fb		ld de, keyscan_scancol+3  
6c0f			  
6c0f 1a			ld a,(de)  
6c10 77			ld (hl),a  
6c11			  
6c11			; row 5  
6c11			  
6c11 78			ld a,b  
6c12			  
6c12 21 d0 fb		LD   hl, keyscan_table_row5+10  
6c15			  
6c15			;call addatohl  
6c15 cd ef 0d		call subafromhl  
6c18			  
6c18 11 8d fb		ld de, keyscan_scancol+4  
6c1b			  
6c1b 1a			ld a,(de)  
6c1c 77			ld (hl),a  
6c1d			  
6c1d			; handshake next column  
6c1d			  
6c1d			  
6c1d 3e 40		ld a, 64  
6c1f d3 c1		out (portbdata),a  
6c21			  
6c21 3e 00		ld a, 0  
6c23 d3 c1		out (portbdata),a  
6c25			  
6c25			; toggle clk and move to next column  
6c25			;ld a, 64  
6c25			;cp c  
6c25			;  
6c25			;jr z, .coltoglow  
6c25			;ld c, a  
6c25			;jr .coltog  
6c25			;.coltoglow:  
6c25			;ld c, 0  
6c25			;.coltog:  
6c25			;ld a, c  
6c25			;out (portbdata),a  
6c25			  
6c25 10 b2		djnz .colscan  
6c27			  
6c27 3e 0a		ld a,10  
6c29 21 f2 fb		LD   hl, keyscan_table_row1  
6c2c cd dd 0d		call addatohl  
6c2f 3e 00		ld a, 0  
6c31 77			ld (hl), a  
6c32			  
6c32			  
6c32 3e 0a		ld a,10  
6c34 21 e7 fb		LD   hl, keyscan_table_row2  
6c37 cd dd 0d		call addatohl  
6c3a 3e 00		ld a, 0  
6c3c 77			ld (hl), a  
6c3d			  
6c3d 3e 0a		ld a,10  
6c3f 21 dc fb		LD   hl, keyscan_table_row3  
6c42 cd dd 0d		call addatohl  
6c45 3e 00		ld a, 0  
6c47 77			ld (hl), a  
6c48			  
6c48 3e 0a		ld a,10  
6c4a 21 d1 fb		LD   hl, keyscan_table_row4  
6c4d cd dd 0d		call addatohl  
6c50 3e 00		ld a, 0  
6c52 77			ld (hl), a  
6c53			  
6c53 3e 0a		ld a,10  
6c55 21 c6 fb		LD   hl, keyscan_table_row5  
6c58 cd dd 0d		call addatohl  
6c5b 3e 00		ld a, 0  
6c5d 77			ld (hl), a  
6c5e			  
6c5e			if DEBUG_KEY_MATRIX  
6c5e			  
6c5e			; Display text on first line  
6c5e			            LD   A, kLCD_Line1  
6c5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6c5e			            LD   DE, keyscan_table_row1  
6c5e			            ;LD   DE, MsgHello  
6c5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6c5e			  
6c5e			; Display text on second line  
6c5e			            LD   A, kLCD_Line2  
6c5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6c5e			            LD   DE, keyscan_table_row2  
6c5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6c5e			            LD   A, kLCD_Line3  
6c5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6c5e			            LD   DE, keyscan_table_row3  
6c5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6c5e			            LD   A, kLCD_Line4  
6c5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6c5e			            LD   DE, keyscan_table_row4  
6c5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6c5e			            LD   A, kLCD_Line4+10  
6c5e			            CALL fLCD_Pos       ;Position cursor to location in A  
6c5e			            LD   DE, keyscan_table_row5  
6c5e			            CALL fLCD_Str       ;Display string pointed to by DE  
6c5e			  
6c5e			;call delay250ms  
6c5e				jp matrix  
6c5e			endif  
6c5e c9			ret  
6c5f			  
6c5f			; using decade counter....  
6c5f			  
6c5f			  
6c5f			; TODO reset decade counter to start of scan  
6c5f			  
6c5f			; reset 15  
6c5f			; clock 14  
6c5f			; ce 13  
6c5f			  
6c5f			; 1 - q5  
6c5f			; 2 - q1  
6c5f			; 3 - q0  
6c5f			; 4 - q2  
6c5f			; 5 - q6  
6c5f			; 6 - q7  
6c5f			; 7 - q3  
6c5f			; 8 - vss  
6c5f			; 9 - q8  
6c5f			; 10 - q4  
6c5f			; 11 - q9  
6c5f			; 12 - cout  
6c5f			; 16 - vdd  
6c5f			  
6c5f			; clock      ce       reset     output  
6c5f			; 0          x        0         n  
6c5f			; x          1        0         n  
6c5f			; x          x        1         q0  
6c5f			; rising     0        0         n+1  
6c5f			; falling    x        0         n  
6c5f			; x          rising   0         n  
6c5f			; 1          falling  0         x+1  
6c5f			;  
6c5f			; x = dont care, if n < 5 carry = 1 otherwise 0  
6c5f			  
6c5f			;   
6c5f			; reset   
6c5f			; 13=0, 14=0, 15=1 .. 15=0  
6c5f			;  
6c5f			; handshake line  
6c5f			; 14=1.... read line 14=0  
6c5f			  
6c5f			  
6c5f			  
6c5f			  
6c5f			  
6c5f			; TODO hand shake clock for next column scan  
6c5f			; TODO detect each row  
6c5f			  
6c5f			  
6c5f			  
6c5f			  
6c5f			; reset 128  
6c5f			; clock 64  
6c5f			; ce 32  
6c5f			  
6c5f			  
6c5f			.cyclestart:  
6c5f			  
6c5f			; reset counter  
6c5f 3e 80		ld a, 128  
6c61 d3 c1		out (portbdata),a  
6c63			  
6c63			; loop leds  
6c63 06 0a		ld b,10  
6c65			  
6c65			.cycle1:  
6c65 c5			push bc  
6c66 3e 00		ld a, 0  
6c68 d3 c1		out (portbdata),a  
6c6a cd 1a 0b		call delay250ms  
6c6d			  
6c6d 3e 40		ld a, 64  
6c6f d3 c1		out (portbdata),a  
6c71 cd 1a 0b		call delay250ms  
6c74			  
6c74 3e 00		ld a, 0  
6c76 d3 c1		out (portbdata),a  
6c78 cd 1a 0b		call delay250ms  
6c7b			  
6c7b c1			pop bc  
6c7c 10 e7		djnz .cycle1  
6c7e			  
6c7e			  
6c7e 18 df		jr .cyclestart  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			; map matrix key held to char on face of key  
6c80			  
6c80			;.mtocold:  
6c80			;  
6c80			;  
6c80			;; reset counter  
6c80			;ld a, 128  
6c80			;out (portbdata),a  
6c80			;  
6c80			;  
6c80			;; scan keyboard row 1  
6c80			;ld a, 0  
6c80			;out (portbdata),a  
6c80			;;ld a, 64  
6c80			;;out (portbdata),a  
6c80			;  
6c80			;  
6c80			;	ld a, 128  
6c80			;	ld hl, keyscan_table  
6c80			;	call .rowscan  
6c80			;  
6c80			;;ld a, 0  
6c80			;;out (portbdata),a  
6c80			;ld a, 64  
6c80			;out (portbdata),a  
6c80			;  
6c80			;	ld a, 64  
6c80			;	ld hl, keyscan_table+key_cols  
6c80			;	call .rowscan  
6c80			;  
6c80			;ld a, 0  
6c80			;out (portbdata),a  
6c80			;;ld a, 64  
6c80			;;out (portbdata),a  
6c80			;	ld a, 32  
6c80			;	ld hl, keyscan_table+(key_cols*2)  
6c80			;	call .rowscan  
6c80			;  
6c80			;  
6c80			;;ld a, 0  
6c80			;;out (portbdata),a  
6c80			;ld a, 64  
6c80			;out (portbdata),a  
6c80			;  
6c80			;	ld a, 16  
6c80			;	ld hl, keyscan_table+(key_cols*3)  
6c80			;	call .rowscan  
6c80			;  
6c80			;  
6c80			;	; flag if key D is held down and remove from reporting  
6c80			;	ld bc, .key_map_fd    
6c80			;	ld hl, keyscan_table  
6c80			;	ld de, key_fd  
6c80			;	call .key_shift_hold  
6c80			;	cp 255  
6c80			;	jr z, .cinmap  
6c80			;	; flag if key C is held down and remove from reporting  
6c80			;	ld bc, .key_map_fc    
6c80			;	ld hl, keyscan_table+key_cols  
6c80			;	ld de, key_fc  
6c80			;	call .key_shift_hold  
6c80			;	cp 255  
6c80			;	jr z, .cinmap  
6c80			;	; flag if key B is held down and remove from reporting  
6c80			;	ld bc, .key_map_fb    
6c80			;	ld hl, keyscan_table+(key_cols*2)  
6c80			;	ld de, key_fb  
6c80			;	call .key_shift_hold  
6c80			;	cp 255  
6c80			;	jr z, .cinmap  
6c80			;	; flag if key A is held down and remove from reporting  
6c80			;	ld bc, .key_map_fa    
6c80			;	ld hl, keyscan_table+(key_cols*3)  
6c80			;	ld de, key_fa  
6c80			;	call .key_shift_hold  
6c80			;	cp 255  
6c80			;	jr z, .cinmap  
6c80			;  
6c80			;	ld de, .matrix_to_char  
6c80			;  
6c80			;  
6c80			;.cinmap:   
6c80			;	if DEBUG_KEY  
6c80			;            LD   A, kLCD_Line4  
6c80			;            CALL fLCD_Pos       ;Position cursor to location in A  
6c80			;		push de  
6c80			;            LD   DE, keyscan_table  
6c80			;            CALL fLCD_Str       ;Display string pointed to by DE  
6c80			;		pop de  
6c80			;	endif  
6c80			  
6c80				; scan key matrix table for any held key  
6c80			  
6c80				; de holds either the default matrix or one selected above  
6c80			  
6c80			;	ld hl, keyscan_table  
6c80			;	ld b,key_cols*key_rows  
6c80			;  
6c80			;.cin1:	ld a,(hl)  
6c80			;	cp '#'  
6c80			;	jr z, .cinhit  
6c80			;	inc hl  
6c80			;	inc de  
6c80			;	dec b  
6c80			;	jr nz, .cin1  
6c80			;	; no key found held  
6c80			;	ld a,0  
6c80			;	ret  
6c80			;.cinhit: push de  
6c80			;	pop hl  
6c80			;	ld a,(hl)  
6c80			;	ret  
6c80			  
6c80			; flag a control key is held   
6c80			; hl is key pin, de is flag indicator  
6c80			  
6c80			;.key_shift_hold:  
6c80			;	push bc  
6c80			;	ld a, 1  
6c80			;	ld (cursor_shape),a  
6c80			;	ld b, 0  
6c80			;	ld a, (hl)  
6c80			;	cp '.'  
6c80			;	jr z, .key_shift1  
6c80			;	ld b, 255  
6c80			;	ld a, '+'    ; hide key from later scans  
6c80			;	ld (hl),a  
6c80			;	ld a, 2  
6c80			;	ld (cursor_shape),a  
6c80			;.key_shift1:  
6c80			;	; write flag indicator  
6c80			;	ld a,b  
6c80			;	ld (de),a  
6c80			;  
6c80			;	pop de    ; de now holds the key map ptr  
6c80			;	ret  
6c80			  
6c80				  
6c80				  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			;	push hl  
6c80			;	push de  
6c80			;	push bc  
6c80			;	call keyscan  
6c80			;	; map key matrix to ascii value of key face  
6c80			;  
6c80			;	ld hl, key_face_map  
6c80			;	ld de, keyscan_table  
6c80			;  
6c80			;	; get how many keys to look at  
6c80			;	ld b, keyscan_table_len  
6c80			;	  
6c80			;  
6c80			;	; at this stage fall out on first key hit  
6c80			;	; TODO handle multiple key press  
6c80			;  
6c80			;map1:	ld a,(hl)  
6c80			;	cp '#'  
6c80			;	jr z, keyhit  
6c80			;	inc hl  
6c80			;	inc de  
6c80			;	dec b  
6c80			;	jr nz, map1  
6c80			;nohit:	ld a, 0  
6c80			;	jr keydone  
6c80			;keyhit: push de  
6c80			;	pop hl  
6c80			;	ld a,(hl)  
6c80			;keydone:  
6c80			;	push bc  
6c80			;	push de  
6c80			; 	push hl  
6c80			;	ret   
6c80			;  
6c80			  
6c80			  
6c80			  
6c80			  
6c80			; scan physical key matrix  
6c80			  
6c80			  
6c80			;keyscan:  
6c80			;  
6c80			;; for each key_row use keyscanr bit mask for out  
6c80			;; then read in for keyscanc bitmask  
6c80			;; save result of row scan to keyscantable  
6c80			;  
6c80			;; scan keyboard row 1  
6c80			;  
6c80			;	ld b, key_rows  
6c80			;	ld hl, key_scanr  
6c80			;	ld de, keyscan_table  
6c80			;  
6c80			;rowloop:  
6c80			;  
6c80			;	ld a,(hl)		; out bit mask to energise keyboard row  
6c80			;	call rowscan  
6c80			;	inc hl  
6c80			;	dec b  
6c80			;	jr nz, rowloop  
6c80			;  
6c80			;	ret  
6c80			;  
6c80			;  
6c80			;; pass a out bitmask, b row number  
6c80			;arowscan:   
6c80			;	push bc  
6c80			;  
6c80			;	ld d, b  
6c80			;  
6c80			;	; calculate buffer location for this row  
6c80			;  
6c80			;	ld hl, keyscan_table	  
6c80			;kbufr:  ld e, key_cols  
6c80			;kbufc:	inc hl  
6c80			;	dec e  
6c80			;	jr nz, kbufc  
6c80			;	dec d  
6c80			;	jr nz, kbufr  
6c80			;  
6c80			;	; energise row and read columns  
6c80			;  
6c80			;	out (portbdata),a  
6c80			;	in a,(portbdata)  
6c80			;	ld c,a  
6c80			;  
6c80			;  
6c80			;	; save buffer loc  
6c80			;  
6c80			;	ld (keybufptr), hl  
6c80			;  
6c80			;	ld hl, key_scanc  
6c80			;	ld d, key_cols  
6c80			;  
6c80			;	; for each column check each bit mask  
6c80			;  
6c80			;colloop:  
6c80			;	  
6c80			;  
6c80			;	; reset flags for the row   
6c80			;  
6c80			;	ld b,'.'  
6c80			;	and (hl)  
6c80			;	jr z, maskskip  
6c80			;	ld b,'#'  
6c80			;maskskip:  
6c80			;	; save  key state  
6c80			;	push hl  
6c80			;	ld hl, (keybufptr)  
6c80			;	ld (hl), b  
6c80			;	inc hl  
6c80			;	ld (keybufptr), hl  
6c80			;  
6c80			;	; move to next bit mask  
6c80			;	pop hl  
6c80			;	inc hl  
6c80			;  
6c80			;	dec d  
6c80			;	jr nz, colloop  
6c80			;  
6c80			;	ret  
6c80			;  
6c80			;  
6c80			;;  
6c80			; lcd functions  
6c80			;  
6c80			;  
6c80			  
6c80			;if DEBUG_KEY_MATRIX  
6c80			  
6c80			; test function to display hardware view of matrix state  
6c80			  
6c80			matrixold:  
6c80			  
6c80			  
6c80			  
6c80			; reset counter  
6c80 3e 80		ld a, 128  
6c82 d3 c1		out (portbdata),a  
6c84			; scan keyboard row 1  
6c84 3e 00		ld a, 0  
6c86 d3 c1		out (portbdata),a  
6c88			;ld a, 64  
6c88			;out (portbdata),a  
6c88 3e 80			ld a, 128  
6c8a 21 f2 fb			ld hl, keyscan_table_row1  
6c8d cd e6 6c			call .rowscan  
6c90			  
6c90			;ld a, 0  
6c90			;out (portbdata),a  
6c90 3e 40		ld a, 64  
6c92 d3 c1		out (portbdata),a  
6c94 3e 40			ld a, 64  
6c96 21 e7 fb			ld hl, keyscan_table_row2  
6c99 cd e6 6c			call .rowscan  
6c9c			  
6c9c 3e 00		ld a, 0  
6c9e d3 c1		out (portbdata),a  
6ca0			;ld a, 64  
6ca0			;out (portbdata),a  
6ca0 3e 20			ld a, 32  
6ca2 21 dc fb			ld hl, keyscan_table_row3  
6ca5 cd e6 6c			call .rowscan  
6ca8			  
6ca8			;ld a, 0  
6ca8			;out (portbdata),a  
6ca8 3e 40		ld a, 64  
6caa d3 c1		out (portbdata),a  
6cac 3e 10			ld a, 16  
6cae 21 d1 fb			ld hl, keyscan_table_row4  
6cb1 cd e6 6c			call .rowscan  
6cb4			  
6cb4			; Display text on first line  
6cb4 3e 00		            LD   A, kLCD_Line1  
6cb6 cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6cb9 11 f2 fb		            LD   DE, keyscan_table_row1  
6cbc			            ;LD   DE, MsgHello  
6cbc cd 10 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6cbf			  
6cbf			; Display text on second line  
6cbf 3e 28		            LD   A, kLCD_Line2  
6cc1 cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6cc4 11 e7 fb		            LD   DE, keyscan_table_row2  
6cc7 cd 10 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6cca 3e 50		            LD   A, kLCD_Line3  
6ccc cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6ccf 11 dc fb		            LD   DE, keyscan_table_row3  
6cd2 cd 10 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6cd5 3e 78		            LD   A, kLCD_Line4  
6cd7 cd ee 68		            CALL fLCD_Pos       ;Position cursor to location in A  
6cda 11 d1 fb		            LD   DE, keyscan_table_row4  
6cdd cd 10 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6ce0			  
6ce0 cd 1a 0b			call delay250ms  
6ce3 c3 d1 6b			jp matrix  
6ce6			  
6ce6			; pass de as row display flags  
6ce6			.rowscan:   
6ce6			;	out (portbdata),a  
6ce6 db c1			in a,(portbdata)  
6ce8 4f				ld c,a  
6ce9				; reset flags for the row   
6ce9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ceb e6 01			and 1  
6ced 28 02			jr z, .p1on  
6cef 06 23			ld b,'#'  
6cf1			.p1on:  
6cf1 70				ld (hl), b  
6cf2 23				inc hl  
6cf3			  
6cf3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6cf5 79				ld a,c  
6cf6 e6 02			and 2  
6cf8			;	bit 0,a  
6cf8 28 02			jr z, .p2on  
6cfa 06 23			ld b,'#'  
6cfc			.p2on:  
6cfc 70				ld (hl), b  
6cfd 23				inc hl  
6cfe			;  
6cfe 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d00 79				ld a,c  
6d01 e6 04			and 4  
6d03			;;	bit 0,a  
6d03 28 02			jr z, .p3on  
6d05 06 23			ld b,'#'  
6d07			.p3on:  
6d07 70				ld (hl), b  
6d08 23				inc hl  
6d09			;;  
6d09 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d0b			;;	bit 0,a  
6d0b 79				ld a,c  
6d0c e6 08			and 8  
6d0e 28 02			jr z, .p4on  
6d10 06 23			ld b,'#'  
6d12			.p4on:  
6d12 70				ld (hl), b  
6d13 23				inc hl  
6d14			  
6d14 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6d16			;;	bit 0,a  
6d16 79				ld a,c  
6d17 e6 10			and 16  
6d19 28 02			jr z, .p5on  
6d1b 06 23			ld b,'#'  
6d1d			.p5on:  
6d1d 70				ld (hl), b  
6d1e 23				inc hl  
6d1f			; zero term  
6d1f 06 00			ld b,0  
6d21 70				ld (hl), b  
6d22			  
6d22 c9			.rscandone: ret  
6d23			  
6d23			;addatohl:  
6d23			;  
6d23			 ;add   a, l    ; A = A+L  
6d23			  ;  ld    l, a    ; L = A+L  
6d23			   ; adc   a, h    ; A = A+L+H+carry  
6d23			   ; sub   l       ; A = H+carry  
6d23			   ; ld    h, a    ; H = H+carry  
6d23			  
6d23			;ret  
6d23			; eof  
# End of file firmware_key_5x10.asm
6d23			;include "firmware_key_4x10.asm" 
6d23			 
6d23			heap_size:    equ heap_end - heap_start 
6d23			;eof 
# End of file os_mega.asm
6d23
