# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 e9 1a			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd 95 0c				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd 95 0c				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd 95 0c				call clear_display  
0037			  
0037			  
0037 cd f5 68				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 3e 6a			call key_init  
003d cd b8 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 6c 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd b8 0c			call update_display  
0046 cd 12 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd 9a 0c			call fill_display  
004e cd b8 0c			call update_display  
0051 cd 12 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd 9a 0c			call fill_display  
0059 cd b8 0c			call update_display  
005c cd 12 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd 9a 0c			call fill_display  
0064 cd b8 0c			call update_display  
0067 cd 12 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 1c 1a			ld de, prom_bootmsg  
006f cd a8 0c			call str_at_display  
0072 cd b8 0c			call update_display  
0075			  
0075			  
0075 cd 12 0c			call delay1s  
0078 cd 12 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 31 1a			ld de, prom_bootmsg1  
0080 cd a8 0c			call str_at_display  
0083 cd b8 0c			call update_display  
0086 cd 12 0c			call delay1s  
0089 cd 12 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			 
009d			; TODO store port id for spi device ie dev c 
009d			; TODO store pin for SO 
009d			; TODO store pin for SI 
009d			; TODO store pin for SCLK 
009d			 
009d			; 
009d			 
009d			; ensure that spi bus is in a stable state with default pins  
009d			 
009d			se_stable_spi:   
009d			 
009d				 ; set DI high, CE high , SCLK low 
009d				;ld a, SPI_DI | SPI_CE0 
009d 3e 07			ld a, SPI_DI  
009f cd 73 01			call spi_ce_high 
00a2 d3 80			 out (storage_adata),a 
00a4 32 f1 fb			ld (spi_portbyte),a 
00a7			 
00a7				if DEBUG_SPI 
00a7					push hl 
00a7					ld l, a 
00a7					DMARK "SPI" 
00a7					CALLMONITOR 
00a7					pop hl 
00a7				endif 
00a7 c9				ret 
00a8			 
00a8			; byte to send in a 
00a8			 
00a8			spi_send_byte: 
00a8				; save byte to send for bit mask shift out 
00a8 4f			        ld c,a 
00a9 3a f1 fb			ld a,(spi_portbyte) 
00ac				  
00ac				; clock out	each bit of the byte msb first 
00ac			 
00ac 06 08			ld b, 8 
00ae			.ssb1: 
00ae				; clear so bit  
00ae cb bf			res SPI_DI, a 
00b0 cb 11			rl c 
00b2				; if bit 7 is set then carry is set 
00b2 30 02			jr nc, .ssb2 
00b4 cb ff			set SPI_DI,a 
00b6			.ssb2:  ; output bit to ensure it is stable 
00b6 d3 80			out (storage_adata),a 
00b8 00				nop 
00b9				; clock bit high 
00b9 cb ef			set SPI_SCLK,a 
00bb d3 80			out (storage_adata),a 
00bd 00				nop 
00be				; then low 
00be cb af			res SPI_SCLK,a 
00c0 d3 80			out (storage_adata),a 
00c2 00				nop 
00c3 10 e9			djnz .ssb1 
00c5			 
00c5 32 f1 fb			ld (spi_portbyte),a 
00c8 c9				ret 
00c9			 
00c9			; TODO low level get byte into A on spi 
00c9			 
00c9			spi_read_byte:  
00c9			 
00c9				; save byte to send for bit mask shift out 
00c9 0e 00		    ld c,0 
00cb 3a f1 fb			ld a,(spi_portbyte) 
00ce				  
00ce				; clock out	each bit of the byte msb first 
00ce			 
00ce			 
00ce				; clock bit high 
00ce cb ef			set SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3			 
00d3			    ; read DO  
00d3			 
00d3 cb f9		    set 7,c 
00d5 db 80			in a,(storage_adata) 
00d7 cb 77		    bit SPI_DO,a 
00d9 20 02		    jr nz, .b7 
00db cb b9		    res 7,c 
00dd			.b7: 
00dd				; then low 
00dd cb af			res SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			     
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f1		    set 6,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b6 
00ef cb b1		    res 6,c 
00f1			.b6: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb e9		    set 5,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b5 
0103 cb a9		    res 5,c 
0105			.b5: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			    ; read DO  
010f			 
010f cb e1		    set 4,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b4 
0117 cb a1		    res 4,c 
0119			.b4: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb d9		    set 3,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b3 
012b cb 99		    res 3,c 
012d			.b3: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d1		    set 2,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b2 
013f cb 91		    res 2,c 
0141			.b2: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb c9		    set 1,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b1 
0153 cb 89		    res 1,c 
0155			.b1: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c1		    set 0,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b0 
0167 cb 81		    res 0,c 
0169			.b0: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e			 
016e			 
016e 32 f1 fb			ld (spi_portbyte),a 
0171			 
0171			    ; return byte 
0171 79			    ld a,c 
0172			 
0172			 
0172 c9				ret 
0173			 
0173			 
0173			 
0173			spi_ce_high: 
0173			 
0173				if DEBUG_SPI_HARD_CE0 
0173			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0173					ret 
0173			 
0173				endif 
0173			 
0173			 
0173 f5				push af 
0174			 
0174				; send direct ce to port b 
0174 3e ff			ld a, 255 
0176 d3 81			out (storage_bdata), a 
0178			 
0178 f1				pop af 
0179			 
0179				; for port a that shares with spi lines AND the mask 
0179			  
0179				if DEBUG_SPI 
0179					push hl 
0179					ld h, a 
0179				endif 
0179			;	ld c, SPI_CE_HIGH 
0179			;	and c 
0179 cb c7			set SPI_CE0, a 
017b cb cf			set SPI_CE1, a 
017d cb d7			set SPI_CE2, a 
017f cb df			set SPI_CE3, a 
0181 cb e7			set SPI_CE4, a 
0183			 
0183				if DEBUG_SPI 
0183					ld l, a 
0183					DMARK "CEh" 
0183					CALLMONITOR 
0183					pop hl 
0183				endif 
0183 c9				ret 
0184			 
0184			 
0184			spi_ce_low: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184 c5				push bc 
0185 f5				push af 
0186			 
0186				; send direct ce to port b 
0186 3a f3 fb			ld a, (spi_cartdev) 
0189 d3 81			out (storage_bdata), a 
018b			 
018b			 
018b			 
018b				; for port a that shares with spi lines AND the mask 
018b			 
018b 3a f0 fb			ld a, (spi_device)  
018e 4f				ld c, a 
018f			 
018f f1				pop af 
0190			 
0190				; detect CEx 
0190			 
0190				if DEBUG_SPI 
0190					push hl 
0190					ld h, a 
0190				endif 
0190			 
0190 cb 41			bit SPI_CE0, c 
0192 20 04			jr nz, .cel1 
0194 cb 87			res SPI_CE0, a 
0196 18 1e			jr .celn 
0198			.cel1: 
0198 cb 49			bit SPI_CE1, c 
019a 20 04			jr nz, .cel2 
019c cb 8f			res SPI_CE1, a 
019e 18 16			jr .celn 
01a0			.cel2: 
01a0 cb 51			bit SPI_CE2, c 
01a2 20 04			jr nz, .cel3 
01a4 cb 97			res SPI_CE2, a 
01a6 18 0e			jr .celn 
01a8			.cel3: 
01a8 cb 59			bit SPI_CE3, c 
01aa 20 04			jr nz, .cel4 
01ac cb 9f			res SPI_CE3, a 
01ae 18 06			jr .celn 
01b0			.cel4: 
01b0 cb 61			bit SPI_CE4, c 
01b2 20 02			jr nz, .celn 
01b4 cb a7			res SPI_CE4, a 
01b6			.celn: 
01b6			 
01b6			 
01b6			 
01b6			;	add c 
01b6			 
01b6				if DEBUG_SPI 
01b6					ld l, a 
01b6					DMARK "CEl" 
01b6					CALLMONITOR 
01b6					pop hl 
01b6				endif 
01b6 c1				pop bc 
01b7 c9				ret 
01b8			 
01b8			 
01b8			 
01b8			; eof 
01b8			 
01b8			 
01b8			 
01b8			 
01b8			 
# End of file firmware_spi.asm
01b8				include "firmware_seeprom.asm"  
01b8			; 
01b8			; persisent storage interface via microchip serial eeprom 
01b8			 
01b8			; port a pio 2 
01b8			; pa 7 - si 
01b8			; pa 6 - sclk  
01b8			; pa 5 - so 
01b8			; pa 4 - cs 
01b8			; pa 3 - cs 
01b8			; pa 2 - cs 
01b8			; pa 1 - cs 
01b8			; pa 0 - cs 
01b8			; 
01b8			; TODO get block 
01b8			; TODO save block 
01b8			; TODO load file 
01b8			; TODO save file 
01b8			; TODO get dir  
01b8			 
01b8			;  
01b8			storage_adata: equ Device_C    ; device c port a - onboard storage 
01b8			storage_actl: equ Device_C+2     ; device c port a 
01b8			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01b8			storage_bctl: equ Device_C+3     ; device c port b 
01b8			 
01b8			 
01b8			; TODO move these to hardware driver file 
01b8			 
01b8			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01b8			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01b8			; storage bank file system format 
01b8			; 
01b8			; first page of bank: 
01b8			; 	addr 0 - status check 
01b8			;       addr 1 - write protect flag 
01b8			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01b8			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01b8			;         TODO see if scanning whole of for available next file id is fast enough 
01b8			;	addr 4 > zero term string of bank label 
01b8			; 
01b8			;        
01b8			;  
01b8			; first page of any file: 
01b8			;      byte 0 - file id  
01b8			;      byte 1-17 - fixed file name  
01b8			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01b8			; 
01b8			; other pages of any file: 
01b8			;      byte 0 - file id 
01b8			;      byte 1> - file data 
01b8			; 
01b8			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01b8			;  
01b8			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01b8			 
01b8			 
01b8			;storage_so_bit: 5 
01b8			;storage_si_bit: 7 
01b8			;storage_sclk_bit: 6 
01b8			  
01b8			 
01b8			; init storage pio 
01b8			 
01b8			storage_init: 
01b8			 
01b8 3e cf		            LD   A, 11001111b 
01ba d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bc 3e 00		            LD   A, 00000000b 
01be cb f7			set SPI_DO,a 
01c0			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c0 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c2			 
01c2 3e cf		            LD   A, 11001111b 
01c4 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c6 3e 00		            LD   A, 00000000b 
01c8 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01ca			 
01ca				; set all external spi devices off 
01ca 3e 00			ld a, 0 
01cc 32 f0 fb			ld (spi_device), a 
01cf 32 f3 fb			ld (spi_cartdev), a 
01d2			 
01d2					; ensure the spi bus is in a default stable state 
01d2 cd 9d 00				call se_stable_spi 
01d5			 
01d5			; TODO scan spi bus and gather which storage banks are present 
01d5			 
01d5			; populate store_bank_active  
01d5			; for each ce line activate and attempt to write first byte of bank and read back 
01d5			; if zero is returned then bank is empty 
01d5			;   
01d5			; 
01d5			 
01d5					; init file extent cache to save on slow reads 
01d5			 
01d5			;	ld hl, store_filecache 
01d5			;	ld de, 0 
01d5			;	ld hl,(de)	 
01d5			 
01d5			 
01d5 c9			    ret 
01d6			 
01d6			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d6			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d6			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d6			 
01d6			; INSTRUCTION SET 
01d6			; READ 0000 0011 Read data from memory array beginning at selected address 
01d6			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d6			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d6			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d6			; RDSR 0000 0101 Read STATUS register 
01d6			; WRSR 0000 0001 Write STATUS register 
01d6			; PE 0100 0010 Page Erase – erase one page in memory array 
01d6			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d6			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d6			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d6			 
01d6			; TODO send byte steam for page without setting the address for every single byte 
01d6			; TODO read byte  
01d6			 
01d6			; byte in a 
01d6			; address in hl  
01d6			se_writebyte: 
01d6			        
01d6			    ;   ld c, a 
01d6 f5			        push af 
01d7 e5			        push hl 
01d8			 
01d8			    ; initi write mode 
01d8			    ; 
01d8			    ;CS low 
01d8			 
01d8 3a f1 fb		       ld a,(spi_portbyte) 
01db cd 84 01			call spi_ce_low 
01de			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01de d3 80		       out (storage_adata),a 
01e0 32 f1 fb		       ld (spi_portbyte), a 
01e3			 
01e3			    ;clock out wren instruction 
01e3			 
01e3 3e 06		    ld a, store_wren_ins 
01e5 cd a8 00		    call spi_send_byte  
01e8			 
01e8			    ;cs high to enable write latch 
01e8			 
01e8 3a f1 fb		       ld a,(spi_portbyte) 
01eb cd 73 01			call spi_ce_high 
01ee			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ee d3 80		       out (storage_adata),a 
01f0 32 f1 fb		       ld (spi_portbyte), a 
01f3			 
01f3 00				nop 
01f4			    ; 
01f4			    ; intial write data 
01f4			    ; 
01f4			    ; cs low 
01f4			     
01f4 3a f1 fb		       ld a,(spi_portbyte) 
01f7 cd 84 01			call spi_ce_low 
01fa			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fa d3 80		       out (storage_adata),a 
01fc 32 f1 fb		       ld (spi_portbyte), a 
01ff			 
01ff			    ; clock out write instruction 
01ff			     
01ff 3e 02		    ld a, store_write_ins  
0201 cd a8 00		    call spi_send_byte  
0204			 
0204			    ; clock out address (depending on address size) 
0204			     
0204 e1			    pop hl 
0205 7c			    ld a,h    ; address out msb first 
0206 cd a8 00		    call spi_send_byte  
0209 7d			    ld a,l 
020a cd a8 00		    call spi_send_byte  
020d			 
020d			    ; clock out byte(s) for page 
020d			 
020d f1			    pop af 
020e cd a8 00		    call spi_send_byte  
0211			 
0211			    ; end write with ce high 
0211 3a f1 fb		       ld a,(spi_portbyte) 
0214			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0214 cd 73 01			call spi_ce_high 
0217 d3 80		       out (storage_adata),a 
0219 32 f1 fb		       ld (spi_portbyte), a 
021c			 
021c				; pause for internal write cycle 
021c 3e 0a			ld a, 10 
021e cd f7 0b			call aDelayInMS 
0221 c9			    ret 
0222			 
0222			; buffer to write in de 
0222			; address in hl  
0222			se_writepage: 
0222			        
0222			    ;   ld c, a 
0222 d5				push de 
0223 e5			        push hl 
0224			 
0224			    ; initi write mode 
0224			    ; 
0224			    ;CS low 
0224			 
0224 3a f1 fb		       ld a,(spi_portbyte) 
0227 cd 84 01			call spi_ce_low 
022a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022a d3 80		       out (storage_adata),a 
022c 32 f1 fb		       ld (spi_portbyte), a 
022f			 
022f			    ;clock out wren instruction 
022f			 
022f 3e 06		    ld a, store_wren_ins 
0231 cd a8 00		    call spi_send_byte  
0234			 
0234			    ;cs high to enable write latch 
0234			 
0234 3a f1 fb		       ld a,(spi_portbyte) 
0237 cd 73 01			call spi_ce_high 
023a			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023a d3 80		       out (storage_adata),a 
023c 32 f1 fb		       ld (spi_portbyte), a 
023f			 
023f 00				nop 
0240			    ; 
0240			    ; intial write data 
0240			    ; 
0240			    ; cs low 
0240			     
0240 3a f1 fb		       ld a,(spi_portbyte) 
0243			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0243 cd 84 01			call spi_ce_low 
0246 d3 80		       out (storage_adata),a 
0248 32 f1 fb		       ld (spi_portbyte), a 
024b			 
024b			    ; clock out write instruction 
024b			     
024b 3e 02		    ld a, store_write_ins  
024d cd a8 00		    call spi_send_byte  
0250			 
0250			    ; clock out address (depending on address size) 
0250			     
0250 e1			    pop hl 
0251 7c			    ld a,h    ; address out msb first 
0252 cd a8 00		    call spi_send_byte  
0255 7d			    ld a,l 
0256 cd a8 00		    call spi_send_byte  
0259			 
0259			    ; clock out byte(s) for page 
0259			 
0259 e1				pop hl 
025a 06 40			ld b, STORE_BLOCK_PHY 
025c			.bytewrite: 
025c			 
025c 7e				ld a,(hl) 
025d e5			    push hl 
025e c5				push bc 
025f cd a8 00		    call spi_send_byte  
0262 c1				pop bc 
0263 e1				pop hl 
0264			 
0264			    ; end write with ce high 
0264 3a f1 fb		       ld a,(spi_portbyte) 
0267 cd 73 01			call spi_ce_high 
026a			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026a d3 80		       out (storage_adata),a 
026c 32 f1 fb		       ld (spi_portbyte), a 
026f			 
026f 23				inc hl 
0270 10 ea			djnz .bytewrite 
0272			 
0272				; pause for internal write cycle 
0272 3e 64			ld a, 100 
0274 cd f7 0b			call aDelayInMS 
0277 c9			    ret 
0278			; returns byte in a 
0278			; address in hl  
0278			se_readbyte: 
0278 d5				push de 
0279 c5				push bc 
027a			 
027a			    ;   ld c, a 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a f1 fb		       ld a,(spi_portbyte) 
027e cd 84 01			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 f1 fb		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 03		    ld a, store_read_ins 
0288 cd a8 00		    call spi_send_byte  
028b			 
028b			 
028b			    ; clock out address (depending on address size) 
028b			     
028b e1			    pop hl 
028c 7c			    ld a,h    ; address out msb first 
028d cd a8 00		    call spi_send_byte  
0290 7d			    ld a,l 
0291 cd a8 00		    call spi_send_byte  
0294			 
0294			    ; clock in byte(s) for page 
0294			 
0294 cd c9 00		    call spi_read_byte  
0297 f5				push af 
0298			 
0298			    ; end write with ce high 
0298 3a f1 fb		       ld a,(spi_portbyte) 
029b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029b cd 73 01			call spi_ce_high 
029e d3 80		       out (storage_adata),a 
02a0 32 f1 fb		       ld (spi_portbyte), a 
02a3			 
02a3 f1				pop af 
02a4			 
02a4 c1				pop bc 
02a5 d1				pop de 
02a6			 
02a6 c9			    ret 
02a7			 
02a7			if DEBUG_STORESE 
02a7			 
02a7			storageput:  
02a7			 
02a7			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02a7			 
02a7 21 87 f3			ld hl,scratch+2 
02aa cd 80 12			call get_word_hl 
02ad			 
02ad				; stuff it here for the moment as it will be overwritten later anyway 
02ad			 
02ad 22 a8 f6			ld (os_cur_ptr),hl	 
02b0			 
02b0			 
02b0			; get pointer to start of string 
02b0			 
02b0 21 8c f3			ld hl, scratch+7 
02b3			 
02b3			; loop writing char of string to eeprom 
02b3			 
02b3 7e			.writestr:	ld a,(hl) 
02b4 fe 00				cp 0 
02b6 28 12				jr z, .wsdone		; done writing 
02b8 e5					push hl 
02b9 2a a8 f6				ld hl,(os_cur_ptr) 
02bc cd d6 01				call se_writebyte 
02bf			 
02bf 2a a8 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c2 23					inc hl 
02c3 22 a8 f6				ld (os_cur_ptr),hl 
02c6			 
02c6					; restore string pointer and get next char 
02c6			 
02c6 e1					pop hl 
02c7 23					inc hl 
02c8 18 e9				jr .writestr 
02ca			 
02ca			 
02ca			 
02ca			.wsdone: 
02ca			 
02ca			 
02ca			; when done load first page into a buffer  
02ca			 
02ca 21 00 80				ld hl,08000h		; start in ram 
02cd 22 a8 f6				ld (os_cur_ptr),hl 
02d0 21 00 00				ld hl, 0		 ; start of page 
02d3 22 ad f3				ld (scratch+40),hl	; hang on to it 
02d6			 
02d6 06 80				ld b, 128		; actually get more then one page 
02d8 c5			.wsload:	push bc 
02d9 2a ad f3				ld hl,(scratch+40) 
02dc e5					push hl 
02dd cd 78 02				call se_readbyte 
02e0			 
02e0					; a now as the byte 
02e0			 
02e0 2a a8 f6				ld hl,(os_cur_ptr) 
02e3 77					ld (hl),a 
02e4					; inc next buffer area 
02e4 23					inc hl 
02e5 22 a8 f6				ld (os_cur_ptr),hl 
02e8			 
02e8					; get eeprom position, inc and save for next round 
02e8 e1					pop hl		 
02e9 23					inc hl 
02ea 22 ad f3				ld (scratch+40),hl 
02ed c1					pop bc 
02ee 10 e8				djnz .wsload 
02f0			 
02f0			; set 'd' pointer to start of buffer 
02f0			 
02f0 21 00 80				ld hl,08000h 
02f3 22 a8 f6				ld (os_cur_ptr),hl 
02f6			 
02f6			 
02f6 c9			ret 
02f7			 
02f7			 
02f7 c9			storageread: ret 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			endif 
02f8			 
02f8			 
02f8			 
# End of file firmware_seeprom.asm
02f8			else  
02f8			   ; create some stubs for the labels  
02f8			se_readbyte: ret  
02f8			se_writebyte: ret  
02f8			storage_init: ret  
02f8			  
02f8			endif  
02f8			  
02f8			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02f8			;include "firmware_cf.asm"  
02f8			  
02f8			; load up high level storage hardward abstractions  
02f8			include "firmware_storage.asm"  
02f8			 
02f8			; persisent storage hardware abstraction layer  
02f8			 
02f8			 
02f8			 
02f8			; Block 0 on storage is a config state 
02f8			 
02f8			 
02f8			 
02f8			; TODO add read phy block and write phy block functions 
02f8			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02f8			 
02f8			; Abstraction layer  
02f8			 
02f8			; Logocial block size is same size as physical size - using tape concept 
02f8			 
02f8			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02f8			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02f8			 
02f8			 
02f8			 
02f8			; Filesystem layout (Logical layout) 
02f8			; 
02f8			; Block 0 - Bank config  
02f8			; 
02f8			;      Byte - 0 file id counter 
02f8			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02f8			;      Byte - 3-20 zero terminated bank label 
02f8			; 
02f8			; Block 1 > File storage 
02f8			; 
02f8			;      Byte 0 file id    - block 0 file details 
02f8			;      Byte 1 block id - block 0 is file  
02f8			;            Byte 2-15 - File name 
02f8			; 
02f8			;       - to end of block data 
02f8			; 
02f8			 
02f8			; Get ID for the file named in pointer held HL 
02f8			; Returns ID in HL = 255 if no file found 
02f8			 
02f8			storage_getid: 
02f8			 
02f8 22 00 fc			ld (store_tmp1), hl 
02fb			 
02fb				if DEBUG_STORESE 
02fb					DMARK "SGI" 
02fb f5				push af  
02fc 3a 10 03			ld a, (.dmark)  
02ff 32 b4 fe			ld (debug_mark),a  
0302 3a 11 03			ld a, (.dmark+1)  
0305 32 b5 fe			ld (debug_mark+1),a  
0308 3a 12 03			ld a, (.dmark+2)  
030b 32 b6 fe			ld (debug_mark+2),a  
030e 18 03			jr .pastdmark  
0310 ..			.dmark: db "SGI"  
0313 f1			.pastdmark: pop af  
0314			endm  
# End of macro DMARK
0314					CALLMONITOR 
0314 cd 46 18			call break_point_state  
0317				endm  
# End of macro CALLMONITOR
0317				endif 
0317				; get block 0 and set counter for number of files to scan 
0317			 
0317 cd 82 04			call storage_get_block_0 
031a			 
031a 3a 07 fc			ld a, (store_page) 
031d 47				ld b, a 
031e			 
031e				; get extent 0 of each file id 
031e			 
031e				if DEBUG_STORESE 
031e					DMARK "SGc" 
031e f5				push af  
031f 3a 33 03			ld a, (.dmark)  
0322 32 b4 fe			ld (debug_mark),a  
0325 3a 34 03			ld a, (.dmark+1)  
0328 32 b5 fe			ld (debug_mark+1),a  
032b 3a 35 03			ld a, (.dmark+2)  
032e 32 b6 fe			ld (debug_mark+2),a  
0331 18 03			jr .pastdmark  
0333 ..			.dmark: db "SGc"  
0336 f1			.pastdmark: pop af  
0337			endm  
# End of macro DMARK
0337					CALLMONITOR 
0337 cd 46 18			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a 60			.getloop:	ld h, b 
033b 2e 00				ld l, 0 
033d c5					push bc 
033e			 
033e 11 07 fc				ld de, store_page 
0341				if DEBUG_STORESE 
0341					DMARK "SGr" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 b4 fe			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 b5 fe			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 b6 fe			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SGr"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a					CALLMONITOR 
035a cd 46 18			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d cd 2a 09				call storage_read 
0360 cd f2 0e				call ishlzero 
0363 28 2d				jr z, .gap 
0365					 
0365					; have a file name read. Is it one we want. 
0365			 
0365 2a 00 fc				ld hl, (store_tmp1) 
0368 11 0a fc				ld de, store_page+3   ; file name 
036b			 
036b				if DEBUG_STORESE 
036b					DMARK "SGc" 
036b f5				push af  
036c 3a 80 03			ld a, (.dmark)  
036f 32 b4 fe			ld (debug_mark),a  
0372 3a 81 03			ld a, (.dmark+1)  
0375 32 b5 fe			ld (debug_mark+1),a  
0378 3a 82 03			ld a, (.dmark+2)  
037b 32 b6 fe			ld (debug_mark+2),a  
037e 18 03			jr .pastdmark  
0380 ..			.dmark: db "SGc"  
0383 f1			.pastdmark: pop af  
0384			endm  
# End of macro DMARK
0384					CALLMONITOR 
0384 cd 46 18			call break_point_state  
0387				endm  
# End of macro CALLMONITOR
0387				endif 
0387 cd 5f 13				call strcmp 
038a 20 06				jr nz, .gap   ; not this one 
038c			 
038c c1				        pop bc 
038d			 
038d 26 00				ld h, 0 
038f 68					ld l, b 
0390 18 22				jr .getdone 
0392						 
0392			 
0392			 
0392			 
0392			.gap: 
0392				if DEBUG_STORESE 
0392					DMARK "SGg" 
0392 f5				push af  
0393 3a a7 03			ld a, (.dmark)  
0396 32 b4 fe			ld (debug_mark),a  
0399 3a a8 03			ld a, (.dmark+1)  
039c 32 b5 fe			ld (debug_mark+1),a  
039f 3a a9 03			ld a, (.dmark+2)  
03a2 32 b6 fe			ld (debug_mark+2),a  
03a5 18 03			jr .pastdmark  
03a7 ..			.dmark: db "SGg"  
03aa f1			.pastdmark: pop af  
03ab			endm  
# End of macro DMARK
03ab					CALLMONITOR 
03ab cd 46 18			call break_point_state  
03ae				endm  
# End of macro CALLMONITOR
03ae				endif 
03ae			 
03ae c1					pop bc 
03af 10 89				djnz .getloop 
03b1 21 ff 00				ld hl, 255 
03b4			.getdone: 
03b4			 
03b4				if DEBUG_STORESE 
03b4					DMARK "SGe" 
03b4 f5				push af  
03b5 3a c9 03			ld a, (.dmark)  
03b8 32 b4 fe			ld (debug_mark),a  
03bb 3a ca 03			ld a, (.dmark+1)  
03be 32 b5 fe			ld (debug_mark+1),a  
03c1 3a cb 03			ld a, (.dmark+2)  
03c4 32 b6 fe			ld (debug_mark+2),a  
03c7 18 03			jr .pastdmark  
03c9 ..			.dmark: db "SGe"  
03cc f1			.pastdmark: pop af  
03cd			endm  
# End of macro DMARK
03cd					CALLMONITOR 
03cd cd 46 18			call break_point_state  
03d0				endm  
# End of macro CALLMONITOR
03d0				endif 
03d0			 
03d0 c9				ret 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			; Read Block 
03d1			; ---------- 
03d1			; 
03d1			; With current bank 
03d1			;  
03d1			; Get block number to read 
03d1			; Load physical blocks starting at start block into buffer 
03d1			 
03d1			; de points to buffer to use 
03d1			; hl holds logical block number  
03d1			 
03d1			storage_read_block: 
03d1			 
03d1				; TODO bank selection 
03d1			 
03d1				; for each of the physical blocks read it into the buffer 
03d1 06 40			ld b, STORE_BLOCK_PHY 
03d3			 
03d3				if DEBUG_STORESE 
03d3 d5					push de 
03d4				endif 
03d4				 
03d4			.rl1:    
03d4			 
03d4				; read physical block at hl into de 
03d4			        ; increment hl and de to next read position on exit 
03d4			 
03d4 e5				push hl 
03d5 d5				push de	 
03d6 c5				push bc 
03d7			;	if DEBUG_STORESE 
03d7			;		push af 
03d7			;		ld a, 'R' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7			;		CALLMONITOR 
03d7			;	endif 
03d7 cd 78 02			call se_readbyte 
03da			;	if DEBUG_STORESE 
03da			;		ld a,(spi_portbyte) 
03da			;		ld l, a 
03da			;		push af 
03da			;		ld a, '1' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da c1				pop bc 
03db d1				pop de 
03dc e1				pop hl 
03dd 12				ld (de),a 
03de 23				inc hl 
03df 13				inc de 
03e0			 
03e0			;	if DEBUG_STORESE 
03e0			;		push af 
03e0			;		ld a, 'r' 
03e0			;		ld (debug_mark),a 
03e0			;		pop af 
03e0			;		CALLMONITOR 
03e0			;	endif 
03e0			 
03e0 10 f2			djnz .rl1 
03e2			 
03e2				if DEBUG_STORESE 
03e2					DMARK "SRB" 
03e2 f5				push af  
03e3 3a f7 03			ld a, (.dmark)  
03e6 32 b4 fe			ld (debug_mark),a  
03e9 3a f8 03			ld a, (.dmark+1)  
03ec 32 b5 fe			ld (debug_mark+1),a  
03ef 3a f9 03			ld a, (.dmark+2)  
03f2 32 b6 fe			ld (debug_mark+2),a  
03f5 18 03			jr .pastdmark  
03f7 ..			.dmark: db "SRB"  
03fa f1			.pastdmark: pop af  
03fb			endm  
# End of macro DMARK
03fb d1					pop de 
03fc			; 
03fc			;		push af 
03fc			;		ld a, 'R' 
03fc			;		ld (debug_mark),a 
03fc			;		pop af 
03fc					CALLMONITOR 
03fc cd 46 18			call break_point_state  
03ff				endm  
# End of macro CALLMONITOR
03ff				endif 
03ff c9				ret	 
0400				 
0400			 
0400			; File Size 
0400			; --------- 
0400			; 
0400			;   hl file id 
0400			; 
0400			;  returns in hl the number of blocks 
0400			 
0400			storage_file_size: 
0400 5d				ld e, l 
0401 16 00			ld d, 0 
0403 21 40 00			ld hl, STORE_BLOCK_PHY 
0406					if DEBUG_FORTH_WORDS 
0406						DMARK "SIZ" 
0406 f5				push af  
0407 3a 1b 04			ld a, (.dmark)  
040a 32 b4 fe			ld (debug_mark),a  
040d 3a 1c 04			ld a, (.dmark+1)  
0410 32 b5 fe			ld (debug_mark+1),a  
0413 3a 1d 04			ld a, (.dmark+2)  
0416 32 b6 fe			ld (debug_mark+2),a  
0419 18 03			jr .pastdmark  
041b ..			.dmark: db "SIZ"  
041e f1			.pastdmark: pop af  
041f			endm  
# End of macro DMARK
041f						CALLMONITOR 
041f cd 46 18			call break_point_state  
0422				endm  
# End of macro CALLMONITOR
0422					endif 
0422 cd 04 07			call storage_findnextid 
0425			 
0425 cd f2 0e			call ishlzero 
0428			;	ld a, l 
0428			;	add h 
0428			;	cp 0 
0428 c8				ret z			; block not found so EOF 
0429			 
0429 11 07 fc			ld de, store_page 
042c cd d1 03			call storage_read_block 
042f			 
042f 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
0432 6f				ld l, a 
0433 26 00			ld h, 0 
0435 c9			 	ret 
0436			 
0436			 
0436			; Write Block 
0436			; ----------- 
0436			; 
0436			; With current bank 
0436			;  
0436			; Get block number to write 
0436			; Write physical blocks starting at start block from buffer 
0436			  
0436			storage_write_block: 
0436				; TODO bank selection 
0436			 
0436				; for each of the physical blocks read it into the buffer 
0436 06 40			ld b, STORE_BLOCK_PHY 
0438			 
0438				if DEBUG_STORESE 
0438					DMARK "SWB" 
0438 f5				push af  
0439 3a 4d 04			ld a, (.dmark)  
043c 32 b4 fe			ld (debug_mark),a  
043f 3a 4e 04			ld a, (.dmark+1)  
0442 32 b5 fe			ld (debug_mark+1),a  
0445 3a 4f 04			ld a, (.dmark+2)  
0448 32 b6 fe			ld (debug_mark+2),a  
044b 18 03			jr .pastdmark  
044d ..			.dmark: db "SWB"  
0450 f1			.pastdmark: pop af  
0451			endm  
# End of macro DMARK
0451			 
0451					;push af 
0451					;ld a, 'W' 
0451					;ld (debug_mark),a 
0451					;pop af 
0451					CALLMONITOR 
0451 cd 46 18			call break_point_state  
0454				endm  
# End of macro CALLMONITOR
0454				endif 
0454			 
0454			; might not be working 
0454			;	call se_writepage 
0454			 
0454			;	ret 
0454			; 
0454			 
0454			 
0454			 
0454			.wl1:    
0454			 
0454				; read physical block at hl into de 
0454			        ; increment hl and de to next read position on exit 
0454			 
0454 e5				push hl 
0455 d5				push de	 
0456 c5				push bc 
0457 1a				ld a,(de) 
0458				;if DEBUG_STORESE 
0458			;		push af 
0458			;		ld a, 'W' 
0458			;		ld (debug_mark),a 
0458			;		pop af 
0458			;		CALLMONITOR 
0458			;	endif 
0458 cd d6 01			call se_writebyte 
045b			;	call delay250ms 
045b 00				nop 
045c 00				nop 
045d 00				nop 
045e			;	if DEBUG_STORESE 
045e			;		push af 
045e			;		ld a, 'w' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e			;		CALLMONITOR 
045e			;	endif 
045e c1				pop bc 
045f d1				pop de 
0460 e1				pop hl 
0461 23				inc hl 
0462 13				inc de 
0463			 
0463			 
0463 10 ef			djnz .wl1 
0465			 
0465				if DEBUG_STORESE 
0465					DMARK "SW2" 
0465 f5				push af  
0466 3a 7a 04			ld a, (.dmark)  
0469 32 b4 fe			ld (debug_mark),a  
046c 3a 7b 04			ld a, (.dmark+1)  
046f 32 b5 fe			ld (debug_mark+1),a  
0472 3a 7c 04			ld a, (.dmark+2)  
0475 32 b6 fe			ld (debug_mark+2),a  
0478 18 03			jr .pastdmark  
047a ..			.dmark: db "SW2"  
047d f1			.pastdmark: pop af  
047e			endm  
# End of macro DMARK
047e			 
047e					;push af 
047e					;ld a, 'W' 
047e					;ld (debug_mark),a 
047e					;pop af 
047e					CALLMONITOR 
047e cd 46 18			call break_point_state  
0481				endm  
# End of macro CALLMONITOR
0481				endif 
0481 c9				ret	 
0482			 
0482			; Init bank 
0482			; --------- 
0482			; 
0482			; With current bank 
0482			; 
0482			; Setup block 0 config 
0482			;     Set 0 file id counter 
0482			;     Set formatted byte pattern 
0482			;     Zero out bank label 
0482			;      
0482			; For every logical block write 0-1 byte as null 
0482			 
0482			storage_get_block_0: 
0482			 
0482				; TODO check presence 
0482			 
0482				; get block 0 config 
0482			 
0482 21 00 00			ld hl, 0 
0485 11 07 fc			ld de, store_page 
0488 cd d1 03			call storage_read_block 
048b			 
048b				if DEBUG_STORESE 
048b					DMARK "SB0" 
048b f5				push af  
048c 3a a0 04			ld a, (.dmark)  
048f 32 b4 fe			ld (debug_mark),a  
0492 3a a1 04			ld a, (.dmark+1)  
0495 32 b5 fe			ld (debug_mark+1),a  
0498 3a a2 04			ld a, (.dmark+2)  
049b 32 b6 fe			ld (debug_mark+2),a  
049e 18 03			jr .pastdmark  
04a0 ..			.dmark: db "SB0"  
04a3 f1			.pastdmark: pop af  
04a4			endm  
# End of macro DMARK
04a4 11 07 fc				ld de, store_page 
04a7			;		push af 
04a7			;		ld a, 'i' 
04a7			;		ld (debug_mark),a 
04a7			;		pop af 
04a7					CALLMONITOR 
04a7 cd 46 18			call break_point_state  
04aa				endm  
# End of macro CALLMONITOR
04aa				endif 
04aa			 
04aa				; is this area formatted? 
04aa			 
04aa			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04aa 2a 08 fc			ld hl, (store_page+1) 
04ad 3e 80			ld a,0x80 
04af bd				cp l 
04b0 20 22			jr nz, .ininotformatted 
04b2				; do a double check 
04b2 3e 27			ld a, 0x27 
04b4 bc				cp h 
04b5 20 1d			jr nz, .ininotformatted 
04b7			 
04b7				; formatted then 
04b7			 
04b7				if DEBUG_STORESE 
04b7					DMARK "SB1" 
04b7 f5				push af  
04b8 3a cc 04			ld a, (.dmark)  
04bb 32 b4 fe			ld (debug_mark),a  
04be 3a cd 04			ld a, (.dmark+1)  
04c1 32 b5 fe			ld (debug_mark+1),a  
04c4 3a ce 04			ld a, (.dmark+2)  
04c7 32 b6 fe			ld (debug_mark+2),a  
04ca 18 03			jr .pastdmark  
04cc ..			.dmark: db "SB1"  
04cf f1			.pastdmark: pop af  
04d0			endm  
# End of macro DMARK
04d0					;push af 
04d0					;ld a, 'I' 
04d0					;ld (debug_mark),a 
04d0					;pop af 
04d0					CALLMONITOR 
04d0 cd 46 18			call break_point_state  
04d3				endm  
# End of macro CALLMONITOR
04d3				endif 
04d3 c9				ret 
04d4			 
04d4			.ininotformatted: 
04d4				; bank not formatted so poke various bits to make sure 
04d4			 
04d4				if DEBUG_STORESE 
04d4					DMARK "SB2" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 b4 fe			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 b5 fe			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 b6 fe			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "SB2"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed					;push af 
04ed					;ld a, 'f' 
04ed					;ld (debug_mark),a 
04ed					;pop af 
04ed					CALLMONITOR 
04ed cd 46 18			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0				endif 
04f0			 
04f0 cd d5 0b			call storage_clear_page 
04f3			 
04f3 21 07 fc			ld hl, store_page 
04f6 3e 00			ld a, 0 
04f8				 
04f8 77				ld (hl),a   ; reset file counter 
04f9			 
04f9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04fc 22 08 fc		 	ld (store_page+1), hl	 
04ff			 
04ff				; set default label 
04ff			 
04ff 21 9b 05			ld hl, .defaultbanklabl 
0502 11 0a fc		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508 ed b0			ldir 
050a			 
050a				; Append the current bank id 
050a 21 13 fc			ld hl, store_page+3+9 
050d 3a ef fb			ld a, (spi_device_id) 
0510 77				ld (hl), a 
0511			 
0511				; save default page 0 
0511			 
0511 21 00 00			ld hl, 0 
0514 11 07 fc			ld de, store_page 
0517				if DEBUG_STORESE 
0517					DMARK "SB3" 
0517 f5				push af  
0518 3a 2c 05			ld a, (.dmark)  
051b 32 b4 fe			ld (debug_mark),a  
051e 3a 2d 05			ld a, (.dmark+1)  
0521 32 b5 fe			ld (debug_mark+1),a  
0524 3a 2e 05			ld a, (.dmark+2)  
0527 32 b6 fe			ld (debug_mark+2),a  
052a 18 03			jr .pastdmark  
052c ..			.dmark: db "SB3"  
052f f1			.pastdmark: pop af  
0530			endm  
# End of macro DMARK
0530			;		push af 
0530			;		ld a, 'F' 
0530			;		ld (debug_mark),a 
0530			;		pop af 
0530					CALLMONITOR 
0530 cd 46 18			call break_point_state  
0533				endm  
# End of macro CALLMONITOR
0533				endif 
0533 cd 36 04			call storage_write_block 
0536				if DEBUG_STORESE 
0536					DMARK "SB4" 
0536 f5				push af  
0537 3a 4b 05			ld a, (.dmark)  
053a 32 b4 fe			ld (debug_mark),a  
053d 3a 4c 05			ld a, (.dmark+1)  
0540 32 b5 fe			ld (debug_mark+1),a  
0543 3a 4d 05			ld a, (.dmark+2)  
0546 32 b6 fe			ld (debug_mark+2),a  
0549 18 03			jr .pastdmark  
054b ..			.dmark: db "SB4"  
054e f1			.pastdmark: pop af  
054f			endm  
# End of macro DMARK
054f			;		push af 
054f			;		ld a, '>' 
054f			;		ld (debug_mark),a 
054f			;		pop af 
054f					CALLMONITOR 
054f cd 46 18			call break_point_state  
0552				endm  
# End of macro CALLMONITOR
0552				endif 
0552			 
0552 00				nop 
0553 00				nop 
0554 00				nop 
0555			 
0555				; now set 0 in every page to mark as a free block 
0555			 
0555 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a			 
055a 3e 00		.setmark1:   	ld a,0 
055c e5					push hl 
055d c5					push bc 
055e cd d6 01				call se_writebyte 
0561 3e 0a			ld a, 10 
0563 cd f7 0b			call aDelayInMS 
0566 23				inc hl 
0567 cd d6 01				call se_writebyte 
056a 3e 0a			ld a, 10 
056c cd f7 0b			call aDelayInMS 
056f 2b				dec hl 
0570 c1					pop bc 
0571 e1					pop hl 
0572 3e 40				ld a, STORE_BLOCK_PHY 
0574 cd c9 0e				call addatohl 
0577 10 e1				djnz .setmark1 
0579			 
0579 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057b 3e 00		.setmark2:   	ld a,0 
057d e5					push hl 
057e c5					push bc 
057f cd d6 01				call se_writebyte 
0582 3e 0a			ld a, 10 
0584 cd f7 0b			call aDelayInMS 
0587 23				inc hl 
0588 cd d6 01				call se_writebyte 
058b 3e 0a			ld a, 10 
058d cd f7 0b			call aDelayInMS 
0590 2b				dec hl 
0591 c1					pop bc 
0592 e1					pop hl 
0593 3e 40				ld a, STORE_BLOCK_PHY 
0595 cd c9 0e				call addatohl 
0598 10 e1				djnz .setmark2 
059a			 
059a					 
059a			 
059a			 
059a c9				ret 
059b			 
059b			 
059b			 
059b			 
059b .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a6			 
05a6			 
05a6			 
05a6			; Label Bank 
05a6			; ---------- 
05a6			; 
05a6			; With current bank 
05a6			; Read block 0 
05a6			; Set label 
05a6			; Write block 0 
05a6			 
05a6			; label str pointer in hl 
05a6			 
05a6			storage_label:     
05a6			 
05a6				if DEBUG_STORESE 
05a6					DMARK "LBL" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 b4 fe			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 b5 fe			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 b6 fe			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "LBL"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 46 18			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl 
05c3			 
05c3 cd 82 04			call storage_get_block_0 
05c6			 
05c6				; set default label 
05c6			 
05c6 e1				pop hl 
05c7			 
05c7 11 0a fc		 	ld de, store_page+3 
05ca 01 0f 00			ld bc, 15 
05cd				if DEBUG_STORESE 
05cd					DMARK "LB3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 b4 fe			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 b5 fe			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 b6 fe			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "LB3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6					CALLMONITOR 
05e6 cd 46 18			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9				endif 
05e9 ed b0			ldir 
05eb				; save default page 0 
05eb			 
05eb 21 00 00			ld hl, 0 
05ee 11 07 fc			ld de, store_page 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBW" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 b4 fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 b5 fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 b6 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBW"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd 46 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d cd 36 04			call storage_write_block 
0610			 
0610 c9				ret 
0611			 
0611			 
0611			 
0611			; Read Block 0 - Config 
0611			; --------------------- 
0611			; 
0611			; With current bank 
0611			; Call presence test 
0611			;    If not present format/init bank  
0611			; Read block 0  
0611			;  
0611			 
0611			 
0611			; Dir 
0611			; --- 
0611			; 
0611			; With current bank 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block read byte 2 
0611			;      if first block of file 
0611			;         Display file name 
0611			;         Display type flags for file 
0611			;        
0611			 
0611			; moving to words as this requires stack control 
0611			 
0611			 
0611			; Delete File 
0611			; ----------- 
0611			; 
0611			; With current bank 
0611			; 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block file id 
0611			;      If first block of file and dont have file id 
0611			;         if file to delete 
0611			;         Save file id 
0611			;         Null file id 
0611			;         Write this block back 
0611			;      If file id is one saved 
0611			;         Null file id 
0611			;         Write this block back 
0611			 
0611			 
0611			.se_done: 
0611 e1				pop hl 
0612 c9				ret 
0613			 
0613			storage_erase: 
0613			 
0613				; hl contains the file id 
0613			 
0613 5d				ld e, l 
0614 16 00			ld d, 0 
0616 21 40 00			ld hl, STORE_BLOCK_PHY 
0619					if DEBUG_FORTH_WORDS 
0619						DMARK "ERA" 
0619 f5				push af  
061a 3a 2e 06			ld a, (.dmark)  
061d 32 b4 fe			ld (debug_mark),a  
0620 3a 2f 06			ld a, (.dmark+1)  
0623 32 b5 fe			ld (debug_mark+1),a  
0626 3a 30 06			ld a, (.dmark+2)  
0629 32 b6 fe			ld (debug_mark+2),a  
062c 18 03			jr .pastdmark  
062e ..			.dmark: db "ERA"  
0631 f1			.pastdmark: pop af  
0632			endm  
# End of macro DMARK
0632						CALLMONITOR 
0632 cd 46 18			call break_point_state  
0635				endm  
# End of macro CALLMONITOR
0635					endif 
0635 cd 04 07			call storage_findnextid 
0638 cd f2 0e			call ishlzero 
063b c8				ret z 
063c			 
063c e5				push hl 
063d			 
063d				; TODO check file not found 
063d			 
063d 11 07 fc			ld de, store_page 
0640 cd d1 03			call storage_read_block 
0643			 
0643 cd f2 0e			call ishlzero 
0646 ca 11 06			jp z,.se_done 
0649			 
0649					if DEBUG_FORTH_WORDS 
0649						DMARK "ER1" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 b4 fe			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 b5 fe			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 b6 fe			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "ER1"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662						CALLMONITOR 
0662 cd 46 18			call break_point_state  
0665				endm  
# End of macro CALLMONITOR
0665					endif 
0665 3a 07 fc			ld a, (store_page)	; get file id 
0668 32 fb fb			ld (store_tmpid), a 
066b			 
066b 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
066e 32 fa fb			ld (store_tmpext), a 
0671			 
0671				; wipe file header 
0671			 
0671 e1				pop hl 
0672 3e 00			ld a, 0 
0674 32 07 fc			ld (store_page), a 
0677 32 08 fc			ld (store_page+1),a 
067a 11 07 fc			ld de, store_page 
067d					if DEBUG_FORTH_WORDS 
067d						DMARK "ER2" 
067d f5				push af  
067e 3a 92 06			ld a, (.dmark)  
0681 32 b4 fe			ld (debug_mark),a  
0684 3a 93 06			ld a, (.dmark+1)  
0687 32 b5 fe			ld (debug_mark+1),a  
068a 3a 94 06			ld a, (.dmark+2)  
068d 32 b6 fe			ld (debug_mark+2),a  
0690 18 03			jr .pastdmark  
0692 ..			.dmark: db "ER2"  
0695 f1			.pastdmark: pop af  
0696			endm  
# End of macro DMARK
0696						CALLMONITOR 
0696 cd 46 18			call break_point_state  
0699				endm  
# End of macro CALLMONITOR
0699					endif 
0699 cd 36 04			call storage_write_block 
069c			 
069c			 
069c				; wipe file extents 
069c			 
069c 3a fa fb			ld a, (store_tmpext) 
069f 47				ld b, a 
06a0			 
06a0			.eraext:	  
06a0 c5				push bc 
06a1			 
06a1 21 40 00			ld hl, STORE_BLOCK_PHY 
06a4 3a fb fb			ld a,(store_tmpid) 
06a7 5f				ld e, a 
06a8 50				ld d, b	 
06a9					if DEBUG_FORTH_WORDS 
06a9						DMARK "ER3" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 b4 fe			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 b5 fe			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 b6 fe			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "ER3"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2						CALLMONITOR 
06c2 cd 46 18			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5					endif 
06c5 cd 04 07			call storage_findnextid 
06c8 cd f2 0e			call ishlzero 
06cb ca 11 06			jp z,.se_done 
06ce			 
06ce e5				push hl 
06cf 11 07 fc			ld de, store_page 
06d2 cd d1 03			call storage_read_block 
06d5			 
06d5				; free block	 
06d5			 
06d5 3e 00			ld a, 0 
06d7 32 07 fc			ld (store_page), a 
06da 32 08 fc			ld (store_page+1),a 
06dd 11 07 fc			ld de, store_page 
06e0 e1				pop hl 
06e1					if DEBUG_FORTH_WORDS 
06e1						DMARK "ER4" 
06e1 f5				push af  
06e2 3a f6 06			ld a, (.dmark)  
06e5 32 b4 fe			ld (debug_mark),a  
06e8 3a f7 06			ld a, (.dmark+1)  
06eb 32 b5 fe			ld (debug_mark+1),a  
06ee 3a f8 06			ld a, (.dmark+2)  
06f1 32 b6 fe			ld (debug_mark+2),a  
06f4 18 03			jr .pastdmark  
06f6 ..			.dmark: db "ER4"  
06f9 f1			.pastdmark: pop af  
06fa			endm  
# End of macro DMARK
06fa						CALLMONITOR 
06fa cd 46 18			call break_point_state  
06fd				endm  
# End of macro CALLMONITOR
06fd					endif 
06fd cd 36 04			call storage_write_block 
0700			 
0700 c1				pop bc 
0701 10 9d			djnz .eraext 
0703			 
0703 c9				ret 
0704			 
0704			 
0704			; Find Free Block 
0704			; --------------- 
0704			; 
0704			; With current bank 
0704			;  
0704			; From given starting logical block 
0704			;    Read block  
0704			;    If no file id 
0704			;         Return block id 
0704			 
0704			 
0704			; hl starting page number 
0704			; hl contains free page number or zero if no pages free 
0704			; e contains the file id to locate 
0704			; d contains the block number 
0704			 
0704			; TODO change to find file id and use zero for free block 
0704			 
0704			storage_findnextid: 
0704			 
0704				; now locate first 0 page to mark as a free block 
0704			 
0704 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0706			;	ld hl, STORE_BLOCK_PHY 
0706			 
0706					if DEBUG_FORTH_WORDS 
0706					DMARK "FNI" 
0706 f5				push af  
0707 3a 1b 07			ld a, (.dmark)  
070a 32 b4 fe			ld (debug_mark),a  
070d 3a 1c 07			ld a, (.dmark+1)  
0710 32 b5 fe			ld (debug_mark+1),a  
0713 3a 1d 07			ld a, (.dmark+2)  
0716 32 b6 fe			ld (debug_mark+2),a  
0719 18 03			jr .pastdmark  
071b ..			.dmark: db "FNI"  
071e f1			.pastdmark: pop af  
071f			endm  
# End of macro DMARK
071f						CALLMONITOR 
071f cd 46 18			call break_point_state  
0722				endm  
# End of macro CALLMONITOR
0722					endif 
0722			.ff1:   	 
0722 e5					push hl 
0723 c5					push bc 
0724 d5					push de 
0725 cd 78 02				call se_readbyte 
0728 5f					ld e,a 
0729 23					inc hl 
072a cd 78 02				call se_readbyte 
072d 57					ld d, a 
072e e1					pop hl 
072f e5					push hl 
0730 cd e7 0e				call cmp16 
0733 28 49				jr z, .fffound 
0735			 
0735 d1					pop de 
0736 c1					pop bc 
0737 e1					pop hl 
0738			 
0738					; is found? 
0738					;cp e 
0738					;ret z 
0738			 
0738 3e 40				ld a, STORE_BLOCK_PHY 
073a cd c9 0e				call addatohl 
073d 10 e3				djnz .ff1 
073f			 
073f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0741			.ff2:   	 
0741			 
0741 e5					push hl 
0742 c5					push bc 
0743 d5					push de 
0744 cd 78 02				call se_readbyte 
0747 5f					ld e,a 
0748 23					inc hl 
0749 cd 78 02				call se_readbyte 
074c 57					ld d, a 
074d			 
074d e1					pop hl 
074e e5					push hl 
074f cd e7 0e				call cmp16 
0752 28 2a				jr z, .fffound 
0754			 
0754 d1					pop de 
0755 c1					pop bc 
0756 e1					pop hl 
0757					; is found? 
0757					;cp e 
0757					;ret z 
0757			 
0757 3e 40				ld a, STORE_BLOCK_PHY 
0759 cd c9 0e				call addatohl 
075c 10 e3				djnz .ff2 
075e			 
075e			 
075e					if DEBUG_FORTH_WORDS 
075e					DMARK "FN-" 
075e f5				push af  
075f 3a 73 07			ld a, (.dmark)  
0762 32 b4 fe			ld (debug_mark),a  
0765 3a 74 07			ld a, (.dmark+1)  
0768 32 b5 fe			ld (debug_mark+1),a  
076b 3a 75 07			ld a, (.dmark+2)  
076e 32 b6 fe			ld (debug_mark+2),a  
0771 18 03			jr .pastdmark  
0773 ..			.dmark: db "FN-"  
0776 f1			.pastdmark: pop af  
0777			endm  
# End of macro DMARK
0777					;	push af 
0777					;	ld a, 'n' 
0777					;	ld (debug_mark),a 
0777					;	pop af 
0777						CALLMONITOR 
0777 cd 46 18			call break_point_state  
077a				endm  
# End of macro CALLMONITOR
077a					endif 
077a				; no free marks! 
077a 21 00 00				ld hl, 0 
077d c9				ret 
077e			.fffound: 
077e				 
077e			 
077e d1					pop de 
077f c1					pop bc 
0780 e1					pop hl 
0781					if DEBUG_FORTH_WORDS 
0781					DMARK "FNF" 
0781 f5				push af  
0782 3a 96 07			ld a, (.dmark)  
0785 32 b4 fe			ld (debug_mark),a  
0788 3a 97 07			ld a, (.dmark+1)  
078b 32 b5 fe			ld (debug_mark+1),a  
078e 3a 98 07			ld a, (.dmark+2)  
0791 32 b6 fe			ld (debug_mark+2),a  
0794 18 03			jr .pastdmark  
0796 ..			.dmark: db "FNF"  
0799 f1			.pastdmark: pop af  
079a			endm  
# End of macro DMARK
079a					;	push af 
079a					;	ld a, 'n' 
079a					;	ld (debug_mark),a 
079a					;	pop af 
079a						CALLMONITOR 
079a cd 46 18			call break_point_state  
079d				endm  
# End of macro CALLMONITOR
079d					endif 
079d c9				ret 
079e			 
079e			 
079e			 
079e			; Free Space 
079e			; ---------- 
079e			; 
079e			; With current bank 
079e			; 
079e			; Set block count to zero 
079e			; Starting with first logical block 
079e			;      Find free block  
079e			;      If block id given, increment block count 
079e			; 
079e			;  
079e			 
079e			 
079e			; hl contains count of free blocks 
079e			 
079e			storage_freeblocks: 
079e			 
079e				; now locate first 0 page to mark as a free block 
079e			 
079e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a0 21 40 00			ld hl, STORE_BLOCK_PHY 
07a3 11 00 00			ld de, 0 
07a6			 
07a6			.fb1:   	 
07a6 e5					push hl 
07a7 c5					push bc 
07a8 d5					push de 
07a9 cd 78 02				call se_readbyte 
07ac d1					pop de 
07ad c1					pop bc 
07ae e1					pop hl 
07af			 
07af					; is free? 
07af fe 00				cp 0 
07b1 20 01				jr nz, .ff1cont 
07b3 13					inc de 
07b4			 
07b4			.ff1cont: 
07b4			 
07b4			 
07b4 3e 40				ld a, STORE_BLOCK_PHY 
07b6 cd c9 0e				call addatohl 
07b9 10 eb				djnz .fb1 
07bb			 
07bb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07bd			.fb2:   	 
07bd e5					push hl 
07be c5					push bc 
07bf d5					push de 
07c0 cd 78 02				call se_readbyte 
07c3 d1					pop de 
07c4 c1					pop bc 
07c5 e1					pop hl 
07c6			 
07c6					; is free? 
07c6 fe 00				cp 0 
07c8 20 01				jr nz, .ff2cont 
07ca 13					inc de 
07cb			 
07cb			.ff2cont: 
07cb			 
07cb 3e 40				ld a, STORE_BLOCK_PHY 
07cd cd c9 0e				call addatohl 
07d0 10 eb				djnz .fb2 
07d2			 
07d2 eb				ex de, hl 
07d3 c9				ret 
07d4			 
07d4			; Get File ID 
07d4			; ----------- 
07d4			; 
07d4			; With current bank 
07d4			;  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; For each logical block 
07d4			;    Read block file id 
07d4			;      If first block of file and dont have file id 
07d4			;         if file get id and exit 
07d4			 
07d4			 
07d4			 
07d4			 
07d4			; Create File 
07d4			; ----------- 
07d4			; 
07d4			; With current bank  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; Increment file id number 
07d4			; Save Config 
07d4			; Find free block 
07d4			; Set buffer with file name and file id 
07d4			; Write buffer to free block  
07d4			 
07d4			 
07d4			; hl point to file name 
07d4			; hl returns file id 
07d4			 
07d4			; file format: 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent number 
07d4			; byte 2-> data 
07d4			 
07d4			; format for extent number 0: 
07d4			; 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent 0 
07d4			; byte 2 - extent count 
07d4			; byte 3 -> file name and meta data 
07d4			 
07d4			 
07d4			storage_create: 
07d4				if DEBUG_STORESE 
07d4					DMARK "SCR" 
07d4 f5				push af  
07d5 3a e9 07			ld a, (.dmark)  
07d8 32 b4 fe			ld (debug_mark),a  
07db 3a ea 07			ld a, (.dmark+1)  
07de 32 b5 fe			ld (debug_mark+1),a  
07e1 3a eb 07			ld a, (.dmark+2)  
07e4 32 b6 fe			ld (debug_mark+2),a  
07e7 18 03			jr .pastdmark  
07e9 ..			.dmark: db "SCR"  
07ec f1			.pastdmark: pop af  
07ed			endm  
# End of macro DMARK
07ed					CALLMONITOR 
07ed cd 46 18			call break_point_state  
07f0				endm  
# End of macro CALLMONITOR
07f0				endif 
07f0			 
07f0 e5				push hl		; save file name pointer 
07f1			 
07f1 cd 82 04			call storage_get_block_0 
07f4			 
07f4 3a 07 fc			ld a,(store_page)	; get current file id 
07f7 3c				inc a 
07f8 32 07 fc			ld (store_page),a 
07fb				 
07fb 32 fb fb			ld (store_tmpid),a			; save id 
07fe			 
07fe 21 00 00			ld hl, 0 
0801 11 07 fc			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCw" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 b4 fe			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 b5 fe			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 b6 fe			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCw"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					CALLMONITOR 
081d cd 46 18			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 36 04			call storage_write_block	 ; save update 
0823			 
0823				if DEBUG_STORESE 
0823 11 07 fc				ld de, store_page 
0826					DMARK "SCC" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 b4 fe			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 b5 fe			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 b6 fe			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCC"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd 46 18			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842				;  
0842				 
0842 21 40 00			ld hl, STORE_BLOCK_PHY 
0845 11 00 00			ld de, 0 
0848 cd 04 07			call storage_findnextid 
084b			 
084b 22 f4 fb			ld (store_tmppageid), hl    ; save page to use  
084e			 
084e				; TODO detect 0 = no spare blocks 
084e			 
084e				; hl now contains the free page to use for the file header page 
084e			 
084e				if DEBUG_STORESE 
084e				DMARK "SCF" 
084e f5				push af  
084f 3a 63 08			ld a, (.dmark)  
0852 32 b4 fe			ld (debug_mark),a  
0855 3a 64 08			ld a, (.dmark+1)  
0858 32 b5 fe			ld (debug_mark+1),a  
085b 3a 65 08			ld a, (.dmark+2)  
085e 32 b6 fe			ld (debug_mark+2),a  
0861 18 03			jr .pastdmark  
0863 ..			.dmark: db "SCF"  
0866 f1			.pastdmark: pop af  
0867			endm  
# End of macro DMARK
0867					CALLMONITOR 
0867 cd 46 18			call break_point_state  
086a				endm  
# End of macro CALLMONITOR
086a				endif 
086a			 
086a 22 f4 fb			ld (store_tmppageid), hl 
086d				 
086d 3a fb fb			ld a,(store_tmpid)    ; get file id 
0870			;	ld a, (store_filecache)			; save to cache 
0870			 
0870 32 07 fc			ld (store_page),a    ; set page id 
0873 3e 00			ld a, 0			 ; extent 0 is file header 
0875 32 08 fc			ld (store_page+1), a   ; set file extent 
0878			 
0878 32 09 fc			ld (store_page+2), a   ; extent count for the file 
087b			 
087b			;	inc hl 		; init block 0 of file 
087b			;	inc hl   		; skip file and extent id 
087b			 ;       ld a, 0 
087b			;	ld (hl),a 
087b			;	ld a, (store_filecache+1)  	; save to cache 
087b			 
087b			;	inc hl    ; file name 
087b				 
087b				 
087b 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
087e				if DEBUG_STORESE 
087e					DMARK "SCc" 
087e f5				push af  
087f 3a 93 08			ld a, (.dmark)  
0882 32 b4 fe			ld (debug_mark),a  
0885 3a 94 08			ld a, (.dmark+1)  
0888 32 b5 fe			ld (debug_mark+1),a  
088b 3a 95 08			ld a, (.dmark+2)  
088e 32 b6 fe			ld (debug_mark+2),a  
0891 18 03			jr .pastdmark  
0893 ..			.dmark: db "SCc"  
0896 f1			.pastdmark: pop af  
0897			endm  
# End of macro DMARK
0897					CALLMONITOR 
0897 cd 46 18			call break_point_state  
089a				endm  
# End of macro CALLMONITOR
089a				endif 
089a e1				pop hl    ; get zero term string 
089b e5				push hl 
089c 3e 00			ld a, 0 
089e cd 32 13			call strlent 
08a1 23				inc hl   ; cover zero term 
08a2 06 00			ld b,0 
08a4 4d				ld c,l 
08a5 e1				pop hl 
08a6				;ex de, hl 
08a6				if DEBUG_STORESE 
08a6					DMARK "SCa" 
08a6 f5				push af  
08a7 3a bb 08			ld a, (.dmark)  
08aa 32 b4 fe			ld (debug_mark),a  
08ad 3a bc 08			ld a, (.dmark+1)  
08b0 32 b5 fe			ld (debug_mark+1),a  
08b3 3a bd 08			ld a, (.dmark+2)  
08b6 32 b6 fe			ld (debug_mark+2),a  
08b9 18 03			jr .pastdmark  
08bb ..			.dmark: db "SCa"  
08be f1			.pastdmark: pop af  
08bf			endm  
# End of macro DMARK
08bf					;push af 
08bf					;ld a, 'a' 
08bf					;ld (debug_mark),a 
08bf					;pop af 
08bf					CALLMONITOR 
08bf cd 46 18			call break_point_state  
08c2				endm  
# End of macro CALLMONITOR
08c2				endif 
08c2 ed b0			ldir    ; copy zero term string 
08c4				if DEBUG_STORESE 
08c4					DMARK "SCA" 
08c4 f5				push af  
08c5 3a d9 08			ld a, (.dmark)  
08c8 32 b4 fe			ld (debug_mark),a  
08cb 3a da 08			ld a, (.dmark+1)  
08ce 32 b5 fe			ld (debug_mark+1),a  
08d1 3a db 08			ld a, (.dmark+2)  
08d4 32 b6 fe			ld (debug_mark+2),a  
08d7 18 03			jr .pastdmark  
08d9 ..			.dmark: db "SCA"  
08dc f1			.pastdmark: pop af  
08dd			endm  
# End of macro DMARK
08dd					CALLMONITOR 
08dd cd 46 18			call break_point_state  
08e0				endm  
# End of macro CALLMONITOR
08e0				endif 
08e0			 
08e0				; write file header page 
08e0			 
08e0 2a f4 fb			ld hl,(store_tmppageid) 
08e3 11 07 fc			ld de, store_page 
08e6				if DEBUG_STORESE 
08e6					DMARK "SCb" 
08e6 f5				push af  
08e7 3a fb 08			ld a, (.dmark)  
08ea 32 b4 fe			ld (debug_mark),a  
08ed 3a fc 08			ld a, (.dmark+1)  
08f0 32 b5 fe			ld (debug_mark+1),a  
08f3 3a fd 08			ld a, (.dmark+2)  
08f6 32 b6 fe			ld (debug_mark+2),a  
08f9 18 03			jr .pastdmark  
08fb ..			.dmark: db "SCb"  
08fe f1			.pastdmark: pop af  
08ff			endm  
# End of macro DMARK
08ff					;push af 
08ff					;ld a, 'b' 
08ff					;ld (debug_mark),a 
08ff					;pop af 
08ff					CALLMONITOR 
08ff cd 46 18			call break_point_state  
0902				endm  
# End of macro CALLMONITOR
0902				endif 
0902 cd 36 04			call storage_write_block 
0905			 
0905 3a fb fb			ld a, (store_tmpid) 
0908 6f				ld l, a 
0909 26 00			ld h,0 
090b				if DEBUG_STORESE 
090b					DMARK "SCz" 
090b f5				push af  
090c 3a 20 09			ld a, (.dmark)  
090f 32 b4 fe			ld (debug_mark),a  
0912 3a 21 09			ld a, (.dmark+1)  
0915 32 b5 fe			ld (debug_mark+1),a  
0918 3a 22 09			ld a, (.dmark+2)  
091b 32 b6 fe			ld (debug_mark+2),a  
091e 18 03			jr .pastdmark  
0920 ..			.dmark: db "SCz"  
0923 f1			.pastdmark: pop af  
0924			endm  
# End of macro DMARK
0924					CALLMONITOR 
0924 cd 46 18			call break_point_state  
0927				endm  
# End of macro CALLMONITOR
0927				endif 
0927 c9				ret 
0928				 
0928			 
0928			 
0928			; 
0928			; Read File 
0928			; 
0928			; h - file id to locate 
0928			; l - extent to locate 
0928			; de - pointer to string to read into 
0928			; 
0928			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0928			 
0928			.sr_fail: 
0928 d1				pop de 
0929 c9				ret 
092a			 
092a			storage_read: 
092a			 
092a			 
092a			 
092a d5				push de 
092b			 
092b			; TODO BUG the above push is it popped before the RET Z? 
092b			 
092b			; TODO how to handle multiple part blocks 
092b			 
092b				; locate file extent to read 
092b			 
092b 5c				ld e, h 
092c 55				ld d, l 
092d			 
092d			.srext: 
092d 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0930 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
0934			 
0934 21 40 00			ld hl, STORE_BLOCK_PHY 
0937				if DEBUG_STORESE 
0937					DMARK "sre" 
0937 f5				push af  
0938 3a 4c 09			ld a, (.dmark)  
093b 32 b4 fe			ld (debug_mark),a  
093e 3a 4d 09			ld a, (.dmark+1)  
0941 32 b5 fe			ld (debug_mark+1),a  
0944 3a 4e 09			ld a, (.dmark+2)  
0947 32 b6 fe			ld (debug_mark+2),a  
094a 18 03			jr .pastdmark  
094c ..			.dmark: db "sre"  
094f f1			.pastdmark: pop af  
0950			endm  
# End of macro DMARK
0950					CALLMONITOR 
0950 cd 46 18			call break_point_state  
0953				endm  
# End of macro CALLMONITOR
0953				endif 
0953 cd 04 07			call storage_findnextid 
0956			 
0956				if DEBUG_STORESE 
0956					DMARK "srf" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 b4 fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 b5 fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 b6 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "srf"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd 46 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 cd f2 0e			call ishlzero 
0975			;	ld a, l 
0975			;	add h 
0975			;	cp 0 
0975 28 b1			jr z,.sr_fail			; block not found so EOF 
0977			 
0977				; hl contains page number to load 
0977 d1				pop de   ; get storage 
0978 d5				push de 
0979				if DEBUG_STORESE 
0979					DMARK "srg" 
0979 f5				push af  
097a 3a 8e 09			ld a, (.dmark)  
097d 32 b4 fe			ld (debug_mark),a  
0980 3a 8f 09			ld a, (.dmark+1)  
0983 32 b5 fe			ld (debug_mark+1),a  
0986 3a 90 09			ld a, (.dmark+2)  
0989 32 b6 fe			ld (debug_mark+2),a  
098c 18 03			jr .pastdmark  
098e ..			.dmark: db "srg"  
0991 f1			.pastdmark: pop af  
0992			endm  
# End of macro DMARK
0992					CALLMONITOR 
0992 cd 46 18			call break_point_state  
0995				endm  
# End of macro CALLMONITOR
0995				endif 
0995 cd d1 03			call storage_read_block 
0998			 
0998			 
0998				; only short reads enabled 
0998			 
0998 3a 02 fc			ld a, (store_longread) 
099b fe 00			cp 0 
099d ca 67 0a			jp z, .readdone 
09a0			 
09a0			; TODO if block has no zeros then need to read next block  
09a0			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
09a0			; check last byte of physical block. 
09a0			; if not zero then the next block needs to be loaded 
09a0			 
09a0			 
09a0 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09a3			 
09a3 3e 3f			ld a, STORE_BLOCK_PHY-1 
09a5 cd c9 0e			call addatohl 
09a8				;dec hl 
09a8 7e				ld a,(hl) 
09a9				if DEBUG_STORESE 
09a9					DMARK "sr?" 
09a9 f5				push af  
09aa 3a be 09			ld a, (.dmark)  
09ad 32 b4 fe			ld (debug_mark),a  
09b0 3a bf 09			ld a, (.dmark+1)  
09b3 32 b5 fe			ld (debug_mark+1),a  
09b6 3a c0 09			ld a, (.dmark+2)  
09b9 32 b6 fe			ld (debug_mark+2),a  
09bc 18 03			jr .pastdmark  
09be ..			.dmark: db "sr?"  
09c1 f1			.pastdmark: pop af  
09c2			endm  
# End of macro DMARK
09c2					CALLMONITOR 
09c2 cd 46 18			call break_point_state  
09c5				endm  
# End of macro CALLMONITOR
09c5				endif 
09c5 fe 00			cp 0 
09c7 ca 67 0a			jp z, .readdone 
09ca			 
09ca				; last byte is not zero so there is more in the next extent. Load it on the end.	 
09ca			 
09ca 23				inc hl 
09cb			 
09cb 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
09ce			 
09ce ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
09d2			 
09d2 eb				ex de, hl 
09d3			 
09d3				; next ext 
09d3			 
09d3 23				inc hl 
09d4 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
09d7			 
09d7				if DEBUG_STORESE 
09d7					DMARK "sF2" 
09d7 f5				push af  
09d8 3a ec 09			ld a, (.dmark)  
09db 32 b4 fe			ld (debug_mark),a  
09de 3a ed 09			ld a, (.dmark+1)  
09e1 32 b5 fe			ld (debug_mark+1),a  
09e4 3a ee 09			ld a, (.dmark+2)  
09e7 32 b6 fe			ld (debug_mark+2),a  
09ea 18 03			jr .pastdmark  
09ec ..			.dmark: db "sF2"  
09ef f1			.pastdmark: pop af  
09f0			endm  
# End of macro DMARK
09f0					CALLMONITOR 
09f0 cd 46 18			call break_point_state  
09f3				endm  
# End of macro CALLMONITOR
09f3				endif 
09f3			 
09f3				; get and load block 
09f3			 
09f3 cd 04 07			call storage_findnextid 
09f6			 
09f6				if DEBUG_STORESE 
09f6					DMARK "sf2" 
09f6 f5				push af  
09f7 3a 0b 0a			ld a, (.dmark)  
09fa 32 b4 fe			ld (debug_mark),a  
09fd 3a 0c 0a			ld a, (.dmark+1)  
0a00 32 b5 fe			ld (debug_mark+1),a  
0a03 3a 0d 0a			ld a, (.dmark+2)  
0a06 32 b6 fe			ld (debug_mark+2),a  
0a09 18 03			jr .pastdmark  
0a0b ..			.dmark: db "sf2"  
0a0e f1			.pastdmark: pop af  
0a0f			endm  
# End of macro DMARK
0a0f					CALLMONITOR 
0a0f cd 46 18			call break_point_state  
0a12				endm  
# End of macro CALLMONITOR
0a12				endif 
0a12 cd f2 0e			call ishlzero 
0a15			;	ld a, l 
0a15			;	add h 
0a15			;	cp 0 
0a15 ca 28 09			jp z,.sr_fail			; block not found so EOF 
0a18				 
0a18 cd d1 03			call storage_read_block 
0a1b			 
0a1b				; on a continuation block, we now have the file id and ext in the middle of the block 
0a1b				; we need to pull everything back  
0a1b			 
0a1b ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a1f 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0a22 23				inc hl 
0a23 23				inc hl     ; skip id and ext 
0a24 01 40 00			ld bc, STORE_BLOCK_PHY 
0a27				if DEBUG_STORESE 
0a27					DMARK "SR<" 
0a27 f5				push af  
0a28 3a 3c 0a			ld a, (.dmark)  
0a2b 32 b4 fe			ld (debug_mark),a  
0a2e 3a 3d 0a			ld a, (.dmark+1)  
0a31 32 b5 fe			ld (debug_mark+1),a  
0a34 3a 3e 0a			ld a, (.dmark+2)  
0a37 32 b6 fe			ld (debug_mark+2),a  
0a3a 18 03			jr .pastdmark  
0a3c ..			.dmark: db "SR<"  
0a3f f1			.pastdmark: pop af  
0a40			endm  
# End of macro DMARK
0a40					CALLMONITOR 
0a40 cd 46 18			call break_point_state  
0a43				endm  
# End of macro CALLMONITOR
0a43				endif 
0a43 ed b0			ldir     ; copy data 
0a45			 
0a45				; move the pointer back and pretend we have a full buffer for next recheck 
0a45			 
0a45 1b				dec de 
0a46 1b				dec de 
0a47			 
0a47			; TODO do pop below now short circuit loop????? 
0a47 c1				pop bc     ; get rid of spare de on stack 
0a48				if DEBUG_STORESE 
0a48					DMARK "SR>" 
0a48 f5				push af  
0a49 3a 5d 0a			ld a, (.dmark)  
0a4c 32 b4 fe			ld (debug_mark),a  
0a4f 3a 5e 0a			ld a, (.dmark+1)  
0a52 32 b5 fe			ld (debug_mark+1),a  
0a55 3a 5f 0a			ld a, (.dmark+2)  
0a58 32 b6 fe			ld (debug_mark+2),a  
0a5b 18 03			jr .pastdmark  
0a5d ..			.dmark: db "SR>"  
0a60 f1			.pastdmark: pop af  
0a61			endm  
# End of macro DMARK
0a61					CALLMONITOR 
0a61 cd 46 18			call break_point_state  
0a64				endm  
# End of macro CALLMONITOR
0a64				endif 
0a64 c3 2d 09			jp .srext 
0a67			 
0a67			 
0a67			 
0a67			 
0a67			 
0a67			.readdone:		 
0a67 e1				pop hl 		 ; return start of data to show as not EOF 
0a68 23				inc hl   ; past file id 
0a69 23				inc hl   ; past ext 
0a6a				if DEBUG_STORESE 
0a6a					DMARK "SRe" 
0a6a f5				push af  
0a6b 3a 7f 0a			ld a, (.dmark)  
0a6e 32 b4 fe			ld (debug_mark),a  
0a71 3a 80 0a			ld a, (.dmark+1)  
0a74 32 b5 fe			ld (debug_mark+1),a  
0a77 3a 81 0a			ld a, (.dmark+2)  
0a7a 32 b6 fe			ld (debug_mark+2),a  
0a7d 18 03			jr .pastdmark  
0a7f ..			.dmark: db "SRe"  
0a82 f1			.pastdmark: pop af  
0a83			endm  
# End of macro DMARK
0a83					CALLMONITOR 
0a83 cd 46 18			call break_point_state  
0a86				endm  
# End of macro CALLMONITOR
0a86				endif 
0a86 c9					ret 
0a87			 
0a87			 
0a87			 
0a87			; 
0a87			; Append File 
0a87			; 
0a87			; hl - file id to locate 
0a87			; de - pointer to (multi block) string to write 
0a87			 
0a87			.sa_notfound: 
0a87 d1				pop de 
0a88 c9				ret 
0a89			 
0a89			 
0a89			storage_append: 
0a89				; hl -  file id to append to 
0a89				; de - string to append 
0a89			 
0a89 d5				push de 
0a8a				 
0a8a				if DEBUG_STORESE 
0a8a					DMARK "AP1" 
0a8a f5				push af  
0a8b 3a 9f 0a			ld a, (.dmark)  
0a8e 32 b4 fe			ld (debug_mark),a  
0a91 3a a0 0a			ld a, (.dmark+1)  
0a94 32 b5 fe			ld (debug_mark+1),a  
0a97 3a a1 0a			ld a, (.dmark+2)  
0a9a 32 b6 fe			ld (debug_mark+2),a  
0a9d 18 03			jr .pastdmark  
0a9f ..			.dmark: db "AP1"  
0aa2 f1			.pastdmark: pop af  
0aa3			endm  
# End of macro DMARK
0aa3					CALLMONITOR 
0aa3 cd 46 18			call break_point_state  
0aa6				endm  
# End of macro CALLMONITOR
0aa6				endif 
0aa6			 
0aa6 7d				ld a, l 
0aa7 32 fb fb			ld (store_tmpid), a 
0aaa			 
0aaa				; get file header  
0aaa			 
0aaa 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0aac 3a fb fb			ld a, (store_tmpid) 
0aaf 5f				ld e, a 
0ab0			 
0ab0 21 40 00				ld hl, STORE_BLOCK_PHY 
0ab3 cd 04 07				call storage_findnextid 
0ab6			 
0ab6 cd f2 0e			call ishlzero 
0ab9 28 cc			jr z, .sa_notfound 
0abb			 
0abb 22 f4 fb			ld (store_tmppageid), hl 
0abe			 
0abe				; TODO handle file id not found 
0abe			 
0abe				if DEBUG_STORESE 
0abe					DMARK "AP2" 
0abe f5				push af  
0abf 3a d3 0a			ld a, (.dmark)  
0ac2 32 b4 fe			ld (debug_mark),a  
0ac5 3a d4 0a			ld a, (.dmark+1)  
0ac8 32 b5 fe			ld (debug_mark+1),a  
0acb 3a d5 0a			ld a, (.dmark+2)  
0ace 32 b6 fe			ld (debug_mark+2),a  
0ad1 18 03			jr .pastdmark  
0ad3 ..			.dmark: db "AP2"  
0ad6 f1			.pastdmark: pop af  
0ad7			endm  
# End of macro DMARK
0ad7					CALLMONITOR 
0ad7 cd 46 18			call break_point_state  
0ada				endm  
# End of macro CALLMONITOR
0ada				endif 
0ada			 
0ada				; update file extent count 
0ada			 
0ada 11 07 fc			ld de, store_page 
0add			 
0add cd d1 03			call storage_read_block 
0ae0			 
0ae0				if DEBUG_STORESE 
0ae0					DMARK "AP3" 
0ae0 f5				push af  
0ae1 3a f5 0a			ld a, (.dmark)  
0ae4 32 b4 fe			ld (debug_mark),a  
0ae7 3a f6 0a			ld a, (.dmark+1)  
0aea 32 b5 fe			ld (debug_mark+1),a  
0aed 3a f7 0a			ld a, (.dmark+2)  
0af0 32 b6 fe			ld (debug_mark+2),a  
0af3 18 03			jr .pastdmark  
0af5 ..			.dmark: db "AP3"  
0af8 f1			.pastdmark: pop af  
0af9			endm  
# End of macro DMARK
0af9					CALLMONITOR 
0af9 cd 46 18			call break_point_state  
0afc				endm  
# End of macro CALLMONITOR
0afc				endif 
0afc			;	ld (store_tmppageid), hl 
0afc			 
0afc 3a 09 fc			ld a, (store_page+2) 
0aff 3c				inc a 
0b00 32 09 fc			ld (store_page+2), a 
0b03 32 fa fb			ld (store_tmpext), a 
0b06				 
0b06				if DEBUG_STORESE 
0b06					DMARK "AP3" 
0b06 f5				push af  
0b07 3a 1b 0b			ld a, (.dmark)  
0b0a 32 b4 fe			ld (debug_mark),a  
0b0d 3a 1c 0b			ld a, (.dmark+1)  
0b10 32 b5 fe			ld (debug_mark+1),a  
0b13 3a 1d 0b			ld a, (.dmark+2)  
0b16 32 b6 fe			ld (debug_mark+2),a  
0b19 18 03			jr .pastdmark  
0b1b ..			.dmark: db "AP3"  
0b1e f1			.pastdmark: pop af  
0b1f			endm  
# End of macro DMARK
0b1f					CALLMONITOR 
0b1f cd 46 18			call break_point_state  
0b22				endm  
# End of macro CALLMONITOR
0b22				endif 
0b22 2a f4 fb			ld hl, (store_tmppageid) 
0b25 11 07 fc			ld de, store_page 
0b28 cd 36 04			call storage_write_block 
0b2b			 
0b2b				; find free block 
0b2b			 
0b2b 11 00 00			ld de, 0			 ; file extent to locate 
0b2e			 
0b2e 21 40 00				ld hl, STORE_BLOCK_PHY 
0b31 cd 04 07				call storage_findnextid 
0b34 cd f2 0e			call ishlzero 
0b37 ca 87 0a			jp z, .sa_notfound 
0b3a			 
0b3a					; TODO handle no space left 
0b3a					 
0b3a 22 f4 fb				ld (store_tmppageid), hl 
0b3d			 
0b3d				if DEBUG_STORESE 
0b3d					DMARK "AP4" 
0b3d f5				push af  
0b3e 3a 52 0b			ld a, (.dmark)  
0b41 32 b4 fe			ld (debug_mark),a  
0b44 3a 53 0b			ld a, (.dmark+1)  
0b47 32 b5 fe			ld (debug_mark+1),a  
0b4a 3a 54 0b			ld a, (.dmark+2)  
0b4d 32 b6 fe			ld (debug_mark+2),a  
0b50 18 03			jr .pastdmark  
0b52 ..			.dmark: db "AP4"  
0b55 f1			.pastdmark: pop af  
0b56			endm  
# End of macro DMARK
0b56					CALLMONITOR 
0b56 cd 46 18			call break_point_state  
0b59				endm  
# End of macro CALLMONITOR
0b59				endif 
0b59					; init the buffer with zeros so we can id if the buffer is full or not 
0b59			 
0b59 e5					push hl 
0b5a c5					push bc 
0b5b			 
0b5b 21 07 fc				ld hl, store_page 
0b5e 06 40				ld b, STORE_BLOCK_PHY 
0b60 3e 00				ld a, 0 
0b62 77			.zeroblock:	ld (hl), a 
0b63 23					inc hl 
0b64 10 fc				djnz .zeroblock 
0b66			 
0b66 c1					pop bc 
0b67 e1					pop hl 
0b68			 
0b68					; construct block 
0b68			 
0b68 3a fb fb				ld a, (store_tmpid) 
0b6b 32 07 fc				ld (store_page), a   ; file id 
0b6e 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0b71 32 08 fc				ld (store_page+1), a 
0b74			 
0b74 e1					pop hl    ; get string to write 
0b75 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0b77 11 09 fc				ld de, store_page+2 
0b7a			 
0b7a				if DEBUG_STORESE 
0b7a					DMARK "AP5" 
0b7a f5				push af  
0b7b 3a 8f 0b			ld a, (.dmark)  
0b7e 32 b4 fe			ld (debug_mark),a  
0b81 3a 90 0b			ld a, (.dmark+1)  
0b84 32 b5 fe			ld (debug_mark+1),a  
0b87 3a 91 0b			ld a, (.dmark+2)  
0b8a 32 b6 fe			ld (debug_mark+2),a  
0b8d 18 03			jr .pastdmark  
0b8f ..			.dmark: db "AP5"  
0b92 f1			.pastdmark: pop af  
0b93			endm  
# End of macro DMARK
0b93					CALLMONITOR 
0b93 cd 46 18			call break_point_state  
0b96				endm  
# End of macro CALLMONITOR
0b96				endif 
0b96			 
0b96			 
0b96			 
0b96					; fill buffer with data until end of string or full block 
0b96			 
0b96 7e			.appd:		ld a, (hl) 
0b97 12					ld (de), a 
0b98 fe 00				cp 0 
0b9a 28 04				jr z, .appdone 
0b9c 23					inc hl 
0b9d 13					inc de 
0b9e 10 f6				djnz .appd 
0ba0			 
0ba0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0ba1 f5					push af   		; save last byte dumped 
0ba2			 
0ba2			 
0ba2 2a f4 fb			ld hl, (store_tmppageid) 
0ba5 11 07 fc			ld de, store_page 
0ba8				if DEBUG_STORESE 
0ba8					DMARK "AP6" 
0ba8 f5				push af  
0ba9 3a bd 0b			ld a, (.dmark)  
0bac 32 b4 fe			ld (debug_mark),a  
0baf 3a be 0b			ld a, (.dmark+1)  
0bb2 32 b5 fe			ld (debug_mark+1),a  
0bb5 3a bf 0b			ld a, (.dmark+2)  
0bb8 32 b6 fe			ld (debug_mark+2),a  
0bbb 18 03			jr .pastdmark  
0bbd ..			.dmark: db "AP6"  
0bc0 f1			.pastdmark: pop af  
0bc1			endm  
# End of macro DMARK
0bc1					CALLMONITOR 
0bc1 cd 46 18			call break_point_state  
0bc4				endm  
# End of macro CALLMONITOR
0bc4				endif 
0bc4 cd 36 04				call storage_write_block 
0bc7			 
0bc7			 
0bc7				; was that a full block of data written? 
0bc7				; any more to write out? 
0bc7			 
0bc7				; if yes then set vars and jump to start of function again 
0bc7			 
0bc7 f1					pop af 
0bc8 d1					pop de 
0bc9			 
0bc9 fe 00				cp 0		 ; no, string was fully written 
0bcb c8					ret z 
0bcc			 
0bcc					; setup vars for next cycle 
0bcc			 
0bcc 3a fb fb				ld a, (store_tmpid) 
0bcf 6f					ld l, a 
0bd0 26 00				ld h, 0 
0bd2			 
0bd2 c3 89 0a			 	jp storage_append	 ; yes, need to write out some more 
0bd5			 
0bd5			 
0bd5			 
0bd5			 
0bd5			 
0bd5			 
0bd5			 
0bd5			if DEBUG_STORECF 
0bd5			storageput:	 
0bd5					ret 
0bd5			storageread: 
0bd5					ld hl, store_page 
0bd5					ld b, 200 
0bd5					ld a,0 
0bd5			.src:		ld (hl),a 
0bd5					inc hl 
0bd5					djnz .src 
0bd5					 
0bd5			 
0bd5					ld de, 0 
0bd5					ld bc, 1 
0bd5					ld hl, store_page 
0bd5					call cfRead 
0bd5			 
0bd5				call cfGetError 
0bd5				ld hl,scratch 
0bd5				call hexout 
0bd5				ld hl, scratch+2 
0bd5				ld a, 0 
0bd5				ld (hl),a 
0bd5				ld de, scratch 
0bd5				ld a,display_row_1 
0bd5				call str_at_display 
0bd5				call update_display 
0bd5			 
0bd5					ld hl, store_page 
0bd5					ld (os_cur_ptr),hl 
0bd5			 
0bd5					ret 
0bd5			endif 
0bd5			 
0bd5			 
0bd5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0bd5			 
0bd5			storage_clear_page: 
0bd5 e5				push hl 
0bd6 d5				push de 
0bd7 c5				push bc 
0bd8 21 07 fc			ld hl, store_page 
0bdb 3e 00			ld a, 0 
0bdd 77				ld (hl), a 
0bde			 
0bde 11 08 fc			ld de, store_page+1 
0be1 01 18 01			ld bc, STORE_BLOCK_LOG 
0be4			 
0be4 ed b0			ldir 
0be6				 
0be6 c1				pop bc 
0be7 d1				pop de 
0be8 e1				pop hl 
0be9 c9				ret 
0bea			 
0bea			; eof 
# End of file firmware_storage.asm
0bea			  
0bea			; support routines for above hardware abstraction layer  
0bea			  
0bea			include "firmware_general.asm"        ; general support functions  
0bea			 
0bea			; word look up 
0bea			 
0bea			; in 
0bea			; a is the index 
0bea			; hl is pointer start of array 
0bea			; 
0bea			; returns 
0bea			; hl to the word 
0bea			; 
0bea			 
0bea			table_lookup:  
0bea d5					push de 
0beb eb					ex de, hl 
0bec			 
0bec 6f					ld l, a 
0bed 26 00				ld h, 0 
0bef 29					add hl, hl 
0bf0 19					add hl, de 
0bf1 7e					ld a, (hl) 
0bf2 23					inc hl 
0bf3 66					ld h,(hl) 
0bf4 6f					ld l, a 
0bf5			 
0bf5 d1					pop de 
0bf6 c9					ret 
0bf7			 
0bf7			; Delay loops 
0bf7			 
0bf7			 
0bf7			 
0bf7			aDelayInMS: 
0bf7 c5				push bc 
0bf8 47				ld b,a 
0bf9			msdelay: 
0bf9 c5				push bc 
0bfa				 
0bfa			 
0bfa 01 41 00			ld bc,041h 
0bfd cd 15 0c			call delayloop 
0c00 c1				pop bc 
0c01 05				dec b 
0c02 20 f5			jr nz,msdelay 
0c04			 
0c04			;if CPU_CLOCK_8MHZ 
0c04			;msdelay8: 
0c04			;	push bc 
0c04			;	 
0c04			; 
0c04			;	ld bc,041h 
0c04			;	call delayloop 
0c04			;	pop bc 
0c04			;	dec b 
0c04			;	jr nz,msdelay8 
0c04			;endif 
0c04			 
0c04			 
0c04 c1				pop bc 
0c05 c9				ret 
0c06			 
0c06			 
0c06			delay250ms: 
0c06				;push de 
0c06 01 00 40			ld bc, 04000h 
0c09 c3 15 0c			jp delayloop 
0c0c			delay500ms: 
0c0c				;push de 
0c0c 01 00 80			ld bc, 08000h 
0c0f c3 15 0c			jp delayloop 
0c12			delay1s: 
0c12				;push bc 
0c12			   ; Clobbers A, d and e 
0c12 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c15			delayloop: 
0c15 c5			    push bc 
0c16			 
0c16			if BASE_CPM 
0c16				ld bc, CPM_DELAY_TUNE 
0c16			.cpmloop: 
0c16				push bc 
0c16			 
0c16			endif 
0c16			 
0c16			 
0c16			 
0c16			delayloopi: 
0c16			;	push bc 
0c16			;.dl: 
0c16 cb 47		    bit     0,a    	; 8 
0c18 cb 47		    bit     0,a    	; 8 
0c1a cb 47		    bit     0,a    	; 8 
0c1c e6 ff		    and     255  	; 7 
0c1e 0b			    dec     bc      	; 6 
0c1f 79			    ld      a,c     	; 4 
0c20 b0			    or      b     	; 4 
0c21 c2 16 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0c24			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0c24				;pop de 
0c24			;pop bc 
0c24			 
0c24			if BASE_CPM 
0c24				pop bc 
0c24				 
0c24			    dec     bc      	; 6 
0c24			    ld      a,c     	; 4 
0c24			    or      b     	; 4 
0c24			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0c24				 
0c24			 
0c24			endif 
0c24			;if CPU_CLOCK_8MHZ 
0c24			;    pop bc 
0c24			;    push bc 
0c24			;.dl8: 
0c24			;    bit     0,a    	; 8 
0c24			;    bit     0,a    	; 8 
0c24			;    bit     0,a    	; 8 
0c24			;    and     255  	; 7 
0c24			;    dec     bc      	; 6 
0c24			;    ld      a,c     	; 4 
0c24			;    or      b     	; 4 
0c24			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c24			;endif 
0c24			 
0c24			;if CPU_CLOCK_10MHZ 
0c24			;    pop bc 
0c24			;    push bc 
0c24			;.dl8: 
0c24			;    bit     0,a    	; 8 
0c24			;    bit     0,a    	; 8 
0c24			;    bit     0,a    	; 8 
0c24			;    and     255  	; 7 
0c24			;    dec     bc      	; 6 
0c24			;    ld      a,c     	; 4 
0c24			;    or      b     	; 4 
0c24			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c24			;endif 
0c24 c1			    pop bc 
0c25			 
0c25 c9				ret 
0c26			 
0c26			 
0c26			 
0c26			; eof 
# End of file firmware_general.asm
0c26			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0c26			; display routines that use the physical hardware abstraction layer 
0c26			 
0c26			 
0c26			; information window 
0c26			 
0c26			; pass hl with 1st string to display 
0c26			; pass de with 2nd string to display 
0c26			 
0c26			info_panel: 
0c26 e5				push hl 
0c27			 
0c27 2a 55 fd			ld hl, (display_fb_active) 
0c2a e5				push hl    ; future de destination 
0c2b 21 4a fe				ld hl, display_fb0 
0c2e 22 55 fd				ld (display_fb_active), hl 
0c31			 
0c31			;	call clear_display 
0c31			 
0c31				if BASE_CPM 
0c31				ld a, '.' 
0c31				else 
0c31 3e a5			ld a, 165 
0c33				endif 
0c33 cd 9a 0c			call fill_display 
0c36			 
0c36			 
0c36 3e 2d			ld a, display_row_3 + 5 
0c38 cd a8 0c			call str_at_display 
0c3b			 
0c3b e1				pop hl 
0c3c d1				pop de 
0c3d			 
0c3d e5				push hl 
0c3e			 
0c3e			 
0c3e 3e 19			ld a, display_row_2 + 5 
0c40 cd a8 0c			call str_at_display 
0c43			 
0c43			 
0c43 cd b8 0c			call update_display 
0c46 cd 32 1e			call next_page_prompt 
0c49 cd 95 0c			call clear_display 
0c4c			 
0c4c				 
0c4c 21 f9 fd				ld hl, display_fb1 
0c4f 22 55 fd				ld (display_fb_active), hl 
0c52 cd b8 0c			call update_display 
0c55			 
0c55 e1				pop hl 
0c56			 
0c56 c9				ret 
0c57			 
0c57			 
0c57			 
0c57			 
0c57			; TODO windowing? 
0c57			 
0c57			; TODO scroll line up 
0c57			 
0c57			scroll_up: 
0c57			 
0c57 e5				push hl 
0c58 d5				push de 
0c59 c5				push bc 
0c5a			 
0c5a				; get frame buffer  
0c5a			 
0c5a 2a 55 fd			ld hl, (display_fb_active) 
0c5d e5				push hl    ; future de destination 
0c5e			 
0c5e 11 14 00			ld  de, display_cols 
0c61 19				add hl, de 
0c62			 
0c62 d1				pop de 
0c63			 
0c63				;ex de, hl 
0c63 01 4f 00			ld bc, display_fb_len -1  
0c66			;if DEBUG_FORTH_WORDS 
0c66			;	DMARK "SCL" 
0c66			;	CALLMONITOR 
0c66			;endif	 
0c66 ed b0			ldir 
0c68			 
0c68				; wipe bottom row 
0c68			 
0c68			 
0c68 2a 55 fd			ld hl, (display_fb_active) 
0c6b 11 50 00			ld de, display_cols*display_rows 
0c6e 19				add hl, de 
0c6f 06 14			ld b, display_cols 
0c71 3e 20			ld a, ' ' 
0c73			.scwipe: 
0c73 77				ld (hl), a 
0c74 2b				dec hl 
0c75 10 fc			djnz .scwipe 
0c77			 
0c77				;pop hl 
0c77			 
0c77 c1				pop bc 
0c78 d1				pop de 
0c79 e1				pop hl 
0c7a			 
0c7a c9				ret 
0c7b			 
0c7b			 
0c7b			;scroll_upo: 
0c7b			;	ld de, display_row_1 
0c7b			 ;	ld hl, display_row_2 
0c7b			;	ld bc, display_cols 
0c7b			;	ldir 
0c7b			;	ld de, display_row_2 
0c7b			 ;	ld hl, display_row_3 
0c7b			;	ld bc, display_cols 
0c7b			;	ldir 
0c7b			;	ld de, display_row_3 
0c7b			 ;	ld hl, display_row_4 
0c7b			;	ld bc, display_cols 
0c7b			;	ldir 
0c7b			 
0c7b			; TODO clear row 4 
0c7b			 
0c7b			;	ret 
0c7b			 
0c7b				 
0c7b			scroll_down: 
0c7b			 
0c7b e5				push hl 
0c7c d5				push de 
0c7d c5				push bc 
0c7e			 
0c7e				; get frame buffer  
0c7e			 
0c7e 2a 55 fd			ld hl, (display_fb_active) 
0c81			 
0c81 11 4f 00			ld de, display_fb_len - 1 
0c84 19				add hl, de 
0c85			 
0c85 e5			push hl    ; future de destination 
0c86			 
0c86 11 14 00			ld  de, display_cols 
0c89 ed 52			sbc hl, de 
0c8b			 
0c8b			 
0c8b d1				pop de 
0c8c			 
0c8c			;	ex de, hl 
0c8c 01 4f 00			ld bc, display_fb_len -1  
0c8f			 
0c8f			 
0c8f				 
0c8f			 
0c8f ed b0			ldir 
0c91			 
0c91				; wipe bottom row 
0c91			 
0c91			 
0c91			;	ld hl, (display_fb_active) 
0c91			;;	ld de, display_cols*display_rows 
0c91			;;	add hl, de 
0c91			;	ld b, display_cols 
0c91			;	ld a, ' ' 
0c91			;.scwiped: 
0c91			;	ld (hl), a 
0c91			;	dec hl 
0c91			;	djnz .scwiped 
0c91			 
0c91				;pop hl 
0c91			 
0c91 c1				pop bc 
0c92 d1				pop de 
0c93 e1				pop hl 
0c94			 
0c94 c9				ret 
0c95			;scroll_down: 
0c95			;	ld de, display_row_4 
0c95			;	ld hl, display_row_3 
0c95			;	ld bc, display_cols 
0c95			;	ldir 
0c95			;	ld de, display_row_3 
0c95			; 	ld hl, display_row_2 
0c95			;	ld bc, display_cols 
0c95			;	ldir 
0c95			;	ld de, display_row_2 
0c95			;	ld hl, display_row_1 
0c95			;	ld bc, display_cols 
0c95			;	ldir 
0c95			;;; TODO clear row 1 
0c95			;	ret 
0c95			 
0c95			 
0c95			 
0c95			 
0c95			 
0c95			; clear active frame buffer 
0c95			 
0c95			clear_display: 
0c95 3e 20			ld a, ' ' 
0c97 c3 9a 0c			jp fill_display 
0c9a			 
0c9a			; fill active frame buffer with a char in A 
0c9a			 
0c9a			fill_display: 
0c9a 06 50			ld b,display_fb_len 
0c9c 2a 55 fd			ld hl, (display_fb_active) 
0c9f 77			.fd1:	ld (hl),a 
0ca0 23				inc hl 
0ca1 10 fc			djnz .fd1 
0ca3 23				inc hl 
0ca4 3e 00			ld a,0 
0ca6 77				ld (hl),a 
0ca7			 
0ca7			 
0ca7 c9				ret 
0ca8			; Write string (DE) at pos (A) to active frame buffer 
0ca8			 
0ca8 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0cab 06 00					ld b,0 
0cad 4f					ld c,a 
0cae 09					add hl,bc 
0caf 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0cb0 b7			            OR   A              ;Null terminator? 
0cb1 c8			            RET  Z              ;Yes, so finished 
0cb2 77					ld (hl),a 
0cb3 23				inc hl 
0cb4 13			            INC  DE             ;Point to next character 
0cb5 18 f8		            JR   .sad1     ;Repeat 
0cb7 c9					ret 
0cb8			 
0cb8			; using current frame buffer write to physical display 
0cb8			 
0cb8			update_display: 
0cb8 e5				push hl 
0cb9 2a 55 fd			ld hl, (display_fb_active) 
0cbc cd 14 69			call write_display 
0cbf e1				pop hl 
0cc0 c9				ret 
0cc1			 
0cc1			; TODO scrolling 
0cc1			 
0cc1			 
0cc1			; move cursor right one char 
0cc1			cursor_right: 
0cc1			 
0cc1				; TODO shift right 
0cc1				; TODO if beyond max col 
0cc1				; TODO       cursor_next_line 
0cc1			 
0cc1 c9				ret 
0cc2			 
0cc2			 
0cc2			cursor_next_line: 
0cc2				; TODO first char 
0cc2				; TODO line down 
0cc2				; TODO if past last row 
0cc2				; TODO    scroll up 
0cc2			 
0cc2 c9				ret 
0cc3			 
0cc3			cursor_left: 
0cc3				; TODO shift left 
0cc3				; TODO if beyond left  
0cc3				; TODO     cursor prev line 
0cc3				 
0cc3 c9				ret 
0cc4			 
0cc4			cursor_prev_line: 
0cc4				; TODO last char 
0cc4				; TODO line up 
0cc4				; TODO if past first row 
0cc4				; TODO   scroll down 
0cc4			 
0cc4 c9				ret 
0cc5			 
0cc5			 
0cc5			cout: 
0cc5				; A - char 
0cc5 c9				ret 
0cc6			 
0cc6			 
0cc6			; Display a menu and allow item selection (optional toggle items) 
0cc6			; 
0cc6			; format: 
0cc6			; hl pointer to word array with zero term for items 
0cc6			; e.g.    db item1 
0cc6			;         db .... 
0cc6			;         db 0 
0cc6			; 
0cc6			; a = starting menu item  
0cc6			; 
0cc6			; de = pointer item toggle array   (todo) 
0cc6			; 
0cc6			; returns item selected in a 1-... 
0cc6			; returns 0 if back button pressed 
0cc6			; 
0cc6			; NOTE: Uses system frame buffer to display 
0cc6			; 
0cc6			; LEFT, Q = go back 
0cc6			; RIGHT, SPACE, CR = select 
0cc6			; UP, A - Up 
0cc6			; DOWN, Z - Down 
0cc6			 
0cc6			 
0cc6			 
0cc6			 
0cc6			 
0cc6			menu: 
0cc6			 
0cc6					; keep array pointer 
0cc6			 
0cc6 22 00 fc				ld (store_tmp1), hl 
0cc9 32 fe fb				ld (store_tmp2), a 
0ccc			 
0ccc					; check for key bounce 
0ccc			 
0ccc			if BASE_KEV 
0ccc			 
0ccc cd c9 6a		.mbounce:	call cin 
0ccf fe 00				cp 0 
0cd1 20 f9				jr nz, .mbounce 
0cd3			endif 
0cd3					; for ease use ex 
0cd3			 
0cd3					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0cd3 21 4a fe				ld hl, display_fb0 
0cd6 22 55 fd				ld (display_fb_active), hl 
0cd9			 
0cd9 cd 95 0c		.mloop:		call clear_display 
0cdc cd b8 0c				call update_display 
0cdf			 
0cdf					; draw selection id '>' at 1 
0cdf			 
0cdf					; init start of list display 
0cdf			 
0cdf 3e 05				ld a, 5 
0ce1 32 fc fb				ld (store_tmp3), a   ; display row count 
0ce4 3a fe fb				ld a,( store_tmp2) 
0ce7 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0cea			 
0cea					 
0cea			.mitem:	 
0cea			 
0cea			 
0cea 3a ff fb				ld a,(store_tmp2+1) 
0ced 6f					ld l, a 
0cee 26 00				ld h, 0 
0cf0 29					add hl, hl 
0cf1 ed 5b 00 fc			ld de, (store_tmp1) 
0cf5 19					add hl, de 
0cf6 7e					ld a, (hl) 
0cf7 23					inc hl 
0cf8 66					ld h,(hl) 
0cf9 6f					ld l, a 
0cfa			 
0cfa cd f2 0e				call ishlzero 
0cfd 28 1a				jr z, .mdone 
0cff			 
0cff eb					ex de, hl 
0d00 3a fc fb				ld a, (store_tmp3) 
0d03 cd a8 0c				call str_at_display 
0d06					 
0d06			 
0d06					; next item 
0d06 3a ff fb				ld a, (store_tmp2+1) 
0d09 3c					inc a 
0d0a 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d0d			 
0d0d			 		; next row 
0d0d			 
0d0d 3a fc fb				ld a, (store_tmp3) 
0d10 c6 14				add display_cols 
0d12 32 fc fb				ld (store_tmp3), a 
0d15			 
0d15					; at end of screen? 
0d15			 
0d15 fe 10				cp display_rows*4 
0d17 20 d1				jr nz, .mitem 
0d19			 
0d19			 
0d19			.mdone: 
0d19 cd f2 0e				call ishlzero 
0d1c 28 08				jr z, .nodn 
0d1e			 
0d1e 3e 3c				ld a, display_row_4 
0d20 11 9f 0d				ld de, .mdown 
0d23 cd a8 0c				call str_at_display 
0d26			 
0d26					; draw options to fill the screens with active item on line 1 
0d26					; if current option is 2 or more then display ^ in top 
0d26			 
0d26 3a fe fb		.nodn:		ld a, (store_tmp2) 
0d29 fe 00				cp 0 
0d2b 28 08				jr z, .noup 
0d2d			 
0d2d 3e 00				ld a, 0 
0d2f 11 9d 0d				ld de, .mup 
0d32 cd a8 0c				call str_at_display 
0d35			 
0d35 3e 02		.noup:		ld a, 2 
0d37 11 9b 0d				ld de, .msel 
0d3a cd a8 0c				call str_at_display 
0d3d			 
0d3d					; if current option + 1 is not null then display V in bottom 
0d3d					; get key 
0d3d cd b8 0c				call update_display 
0d40			 
0d40			 
0d40					; handle key 
0d40			 
0d40 cd b8 6a				call cin_wait 
0d43			 
0d43 fe 05				cp KEY_UP 
0d45 28 2b				jr z, .mgoup 
0d47 fe 61				cp 'a' 
0d49 28 27				jr z, .mgoup 
0d4b fe 0a				cp KEY_DOWN 
0d4d 28 32				jr z, .mgod 
0d4f fe 7a				cp 'z' 
0d51 28 2e				jr z, .mgod 
0d53 fe 20				cp ' ' 
0d55 28 34				jr z, .goend 
0d57 fe 0c				cp KEY_RIGHT 
0d59 28 30				jr z, .goend 
0d5b fe 0d				cp KEY_CR 
0d5d 28 2c				jr z, .goend 
0d5f fe 71				cp 'q' 
0d61 28 0b				jr z, .goback 
0d63			 
0d63 fe 0b				cp KEY_LEFT 
0d65 28 07				jr z, .goback 
0d67 fe 08				cp KEY_BS 
0d69 28 03				jr z, .goback 
0d6b c3 d9 0c				jp .mloop 
0d6e			 
0d6e			.goback: 
0d6e 3e 00			ld a, 0 
0d70 18 1d			jr .goend2 
0d72			 
0d72				; move up one 
0d72			.mgoup: 
0d72 3a fe fb				ld a, (store_tmp2) 
0d75 fe 00				cp 0 
0d77 ca d9 0c				jp z, .mloop 
0d7a 3d					dec a 
0d7b 32 fe fb				ld (store_tmp2), a 
0d7e c3 d9 0c				jp .mloop 
0d81			 
0d81				; move down one 
0d81			.mgod: 
0d81 3a fe fb				ld a, (store_tmp2) 
0d84 3c					inc a 
0d85 32 fe fb				ld (store_tmp2), a 
0d88 c3 d9 0c				jp .mloop 
0d8b			 
0d8b			 
0d8b			.goend: 
0d8b					; get selected item number 
0d8b			 
0d8b 3a fe fb				ld a, (store_tmp2) 
0d8e 3c					inc a 
0d8f			 
0d8f			.goend2: 
0d8f f5					push af 
0d90			 
0d90					; restore active fb 
0d90					; TODO BUG assumes fb1 
0d90			 
0d90 21 f9 fd				ld hl, display_fb1 
0d93 22 55 fd				ld (display_fb_active), hl 
0d96			 
0d96					; restore main regs 
0d96			 
0d96			 
0d96 cd b8 0c				call update_display 
0d99			 
0d99 f1					pop af 
0d9a			 
0d9a c9				ret 
0d9b			 
0d9b .. 00		.msel:   db ">",0 
0d9d .. 00		.mup:   db "^",0 
0d9f .. 00		.mdown:   db "v",0 
0da1			 
0da1			 
0da1			; eof 
0da1			 
# End of file firmware_display.asm
0da1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0da1			; random number generators 
0da1			 
0da1			 
0da1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0da1			 
0da1			 
0da1			;-----> Generate a random number 
0da1			; output a=answer 0<=a<=255 
0da1			; all registers are preserved except: af 
0da1			random: 
0da1 e5			        push    hl 
0da2 d5			        push    de 
0da3 2a 37 fd		        ld      hl,(randData) 
0da6 ed 5f		        ld      a,r 
0da8 57			        ld      d,a 
0da9 5e			        ld      e,(hl) 
0daa 19			        add     hl,de 
0dab 85			        add     a,l 
0dac ac			        xor     h 
0dad 22 37 fd		        ld      (randData),hl 
0db0 d1			        pop     de 
0db1 e1			        pop     hl 
0db2 c9			        ret 
0db3			 
0db3			 
0db3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0db3			 
0db3			 
0db3			 
0db3			;------LFSR------ 
0db3			;James Montelongo 
0db3			;optimized by Spencer Putt 
0db3			;out: 
0db3			; a = 8 bit random number 
0db3			RandLFSR: 
0db3 21 3d fd		        ld hl,LFSRSeed+4 
0db6 5e			        ld e,(hl) 
0db7 23			        inc hl 
0db8 56			        ld d,(hl) 
0db9 23			        inc hl 
0dba 4e			        ld c,(hl) 
0dbb 23			        inc hl 
0dbc 7e			        ld a,(hl) 
0dbd 47			        ld b,a 
0dbe cb 13		        rl e  
0dc0 cb 12			rl d 
0dc2 cb 11		        rl c  
0dc4 17				rla 
0dc5 cb 13		        rl e  
0dc7 cb 12			rl d 
0dc9 cb 11		        rl c  
0dcb 17				rla 
0dcc cb 13		        rl e  
0dce cb 12			rl d 
0dd0 cb 11		        rl c  
0dd2 17				rla 
0dd3 67			        ld h,a 
0dd4 cb 13		        rl e  
0dd6 cb 12			rl d 
0dd8 cb 11		        rl c  
0dda 17				rla 
0ddb a8			        xor b 
0ddc cb 13		        rl e  
0dde cb 12			rl d 
0de0 ac			        xor h 
0de1 a9			        xor c 
0de2 aa			        xor d 
0de3 21 3f fd		        ld hl,LFSRSeed+6 
0de6 11 40 fd		        ld de,LFSRSeed+7 
0de9 01 07 00		        ld bc,7 
0dec ed b8		        lddr 
0dee 12			        ld (de),a 
0def c9			        ret 
0df0			 
0df0			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0df0			 
0df0			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0df0			 
0df0			 
0df0			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0df0			 
0df0			prng16: 
0df0			;Inputs: 
0df0			;   (seed1) contains a 16-bit seed value 
0df0			;   (seed2) contains a NON-ZERO 16-bit seed value 
0df0			;Outputs: 
0df0			;   HL is the result 
0df0			;   BC is the result of the LCG, so not that great of quality 
0df0			;   DE is preserved 
0df0			;Destroys: 
0df0			;   AF 
0df0			;cycle: 4,294,901,760 (almost 4.3 billion) 
0df0			;160cc 
0df0			;26 bytes 
0df0 2a 31 fd		    ld hl,(seed1) 
0df3 44			    ld b,h 
0df4 4d			    ld c,l 
0df5 29			    add hl,hl 
0df6 29			    add hl,hl 
0df7 2c			    inc l 
0df8 09			    add hl,bc 
0df9 22 31 fd		    ld (seed1),hl 
0dfc 2a 2f fd		    ld hl,(seed2) 
0dff 29			    add hl,hl 
0e00 9f			    sbc a,a 
0e01 e6 2d		    and %00101101 
0e03 ad			    xor l 
0e04 6f			    ld l,a 
0e05 22 2f fd		    ld (seed2),hl 
0e08 09			    add hl,bc 
0e09 c9			    ret 
0e0a			 
0e0a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e0a			 
0e0a			rand32: 
0e0a			;Inputs: 
0e0a			;   (seed1_0) holds the lower 16 bits of the first seed 
0e0a			;   (seed1_1) holds the upper 16 bits of the first seed 
0e0a			;   (seed2_0) holds the lower 16 bits of the second seed 
0e0a			;   (seed2_1) holds the upper 16 bits of the second seed 
0e0a			;   **NOTE: seed2 must be non-zero 
0e0a			;Outputs: 
0e0a			;   HL is the result 
0e0a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e0a			;Destroys: 
0e0a			;   AF 
0e0a			;Tested and passes all CAcert tests 
0e0a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e0a			;it has a period of 18,446,744,069,414,584,320 
0e0a			;roughly 18.4 quintillion. 
0e0a			;LFSR taps: 0,2,6,7  = 11000101 
0e0a			;291cc 
0e0a			;seed1_0=$+1 
0e0a			;    ld hl,12345 
0e0a			;seed1_1=$+1 
0e0a			;    ld de,6789 
0e0a			;    ld b,h 
0e0a			;    ld c,l 
0e0a			;    add hl,hl \ rl e \ rl d 
0e0a			;    add hl,hl \ rl e \ rl d 
0e0a			;    inc l 
0e0a			;    add hl,bc 
0e0a			;    ld (seed1_0),hl 
0e0a			;    ld hl,(seed1_1) 
0e0a			;    adc hl,de 
0e0a			;    ld (seed1_1),hl 
0e0a			;    ex de,hl 
0e0a			;seed2_0=$+1 
0e0a			;    ld hl,9876 
0e0a			;seed2_1=$+1 
0e0a			;    ld bc,54321 
0e0a			;    add hl,hl \ rl c \ rl b 
0e0a			;    ld (seed2_1),bc 
0e0a			;    sbc a,a 
0e0a			;    and %11000101 
0e0a			;    xor l 
0e0a			;    ld l,a 
0e0a			;    ld (seed2_0),hl 
0e0a			;    ex de,hl 
0e0a			;    add hl,bc 
0e0a			;    ret 
0e0a			; 
0e0a			 
0e0a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e0a			; 20 bytes, 86 cycles (excluding ret) 
0e0a			 
0e0a			; returns   hl = pseudorandom number 
0e0a			; corrupts   a 
0e0a			 
0e0a			; generates 16-bit pseudorandom numbers with a period of 65535 
0e0a			; using the xorshift method: 
0e0a			 
0e0a			; hl ^= hl << 7 
0e0a			; hl ^= hl >> 9 
0e0a			; hl ^= hl << 8 
0e0a			 
0e0a			; some alternative shift triplets which also perform well are: 
0e0a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e0a			 
0e0a			;  org 32768 
0e0a			 
0e0a			xrnd: 
0e0a 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e0d 3e 00		  ld a,0 
0e0f bd			  cp l 
0e10 20 02		  jr nz, .xrnd1 
0e12 2e 01		  ld l, 1 
0e14			.xrnd1: 
0e14			 
0e14 7c			  ld a,h 
0e15 1f			  rra 
0e16 7d			  ld a,l 
0e17 1f			  rra 
0e18 ac			  xor h 
0e19 67			  ld h,a 
0e1a 7d			  ld a,l 
0e1b 1f			  rra 
0e1c 7c			  ld a,h 
0e1d 1f			  rra 
0e1e ad			  xor l 
0e1f 6f			  ld l,a 
0e20 ac			  xor h 
0e21 67			  ld h,a 
0e22			 
0e22 22 35 fd		  ld (xrandc),hl 
0e25			 
0e25 c9			  ret 
0e26			;  
0e26			 
0e26			 
0e26			;;;; int maths 
0e26			 
0e26			; https://map.grauw.nl/articles/mult_div_shifts.php 
0e26			; Divide 16-bit values (with 16-bit result) 
0e26			; In: Divide BC by divider DE 
0e26			; Out: BC = result, HL = rest 
0e26			; 
0e26			Div16: 
0e26 21 00 00		    ld hl,0 
0e29 78			    ld a,b 
0e2a 06 08		    ld b,8 
0e2c			Div16_Loop1: 
0e2c 17			    rla 
0e2d ed 6a		    adc hl,hl 
0e2f ed 52		    sbc hl,de 
0e31 30 01		    jr nc,Div16_NoAdd1 
0e33 19			    add hl,de 
0e34			Div16_NoAdd1: 
0e34 10 f6		    djnz Div16_Loop1 
0e36 17			    rla 
0e37 2f			    cpl 
0e38 47			    ld b,a 
0e39 79			    ld a,c 
0e3a 48			    ld c,b 
0e3b 06 08		    ld b,8 
0e3d			Div16_Loop2: 
0e3d 17			    rla 
0e3e ed 6a		    adc hl,hl 
0e40 ed 52		    sbc hl,de 
0e42 30 01		    jr nc,Div16_NoAdd2 
0e44 19			    add hl,de 
0e45			Div16_NoAdd2: 
0e45 10 f6		    djnz Div16_Loop2 
0e47 17			    rla 
0e48 2f			    cpl 
0e49 41			    ld b,c 
0e4a 4f			    ld c,a 
0e4b c9			ret 
0e4c			 
0e4c			 
0e4c			;http://z80-heaven.wikidot.com/math 
0e4c			; 
0e4c			;Inputs: 
0e4c			;     DE and A are factors 
0e4c			;Outputs: 
0e4c			;     A is not changed 
0e4c			;     B is 0 
0e4c			;     C is not changed 
0e4c			;     DE is not changed 
0e4c			;     HL is the product 
0e4c			;Time: 
0e4c			;     342+6x 
0e4c			; 
0e4c			Mult16: 
0e4c			 
0e4c 06 08		     ld b,8          ;7           7 
0e4e 21 00 00		     ld hl,0         ;10         10 
0e51 29			       add hl,hl     ;11*8       88 
0e52 07			       rlca          ;4*8        32 
0e53 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0e55 19			         add hl,de   ;--         -- 
0e56 10 f9		       djnz $-5      ;13*7+8     99 
0e58 c9			ret 
0e59			 
0e59			; 
0e59			; Square root of 16-bit value 
0e59			; In:  HL = value 
0e59			; Out:  D = result (rounded down) 
0e59			; 
0e59			;Sqr16: 
0e59			;    ld de,#0040 
0e59			;    ld a,l 
0e59			;    ld l,h 
0e59			;    ld h,d 
0e59			;    or a 
0e59			;    ld b,8 
0e59			;Sqr16_Loop: 
0e59			;    sbc hl,de 
0e59			;    jr nc,Sqr16_Skip 
0e59			;    add hl,de 
0e59			;Sqr16_Skip: 
0e59			;    ccf 
0e59			;    rl d 
0e59			;    add a,a 
0e59			;    adc hl,hl 
0e59			;    add a,a 
0e59			;    adc hl,hl 
0e59			;    djnz Sqr16_Loop 
0e59			;    ret 
0e59			; 
0e59			; 
0e59			; Divide 8-bit values 
0e59			; In: Divide E by divider C 
0e59			; Out: A = result, B = rest 
0e59			; 
0e59			Div8: 
0e59 af			    xor a 
0e5a 06 08		    ld b,8 
0e5c			Div8_Loop: 
0e5c cb 13		    rl e 
0e5e 17			    rla 
0e5f 91			    sub c 
0e60 30 01		    jr nc,Div8_NoAdd 
0e62 81			    add a,c 
0e63			Div8_NoAdd: 
0e63 10 f7		    djnz Div8_Loop 
0e65 47			    ld b,a 
0e66 7b			    ld a,e 
0e67 17			    rla 
0e68 2f			    cpl 
0e69 c9			    ret 
0e6a			 
0e6a			; 
0e6a			; Multiply 8-bit value with a 16-bit value (unrolled) 
0e6a			; In: Multiply A with DE 
0e6a			; Out: HL = result 
0e6a			; 
0e6a			Mult12U: 
0e6a 2e 00		    ld l,0 
0e6c 87			    add a,a 
0e6d 30 01		    jr nc,Mult12U_NoAdd0 
0e6f 19			    add hl,de 
0e70			Mult12U_NoAdd0: 
0e70 29			    add hl,hl 
0e71 87			    add a,a 
0e72 30 01		    jr nc,Mult12U_NoAdd1 
0e74 19			    add hl,de 
0e75			Mult12U_NoAdd1: 
0e75 29			    add hl,hl 
0e76 87			    add a,a 
0e77 30 01		    jr nc,Mult12U_NoAdd2 
0e79 19			    add hl,de 
0e7a			Mult12U_NoAdd2: 
0e7a 29			    add hl,hl 
0e7b 87			    add a,a 
0e7c 30 01		    jr nc,Mult12U_NoAdd3 
0e7e 19			    add hl,de 
0e7f			Mult12U_NoAdd3: 
0e7f 29			    add hl,hl 
0e80 87			    add a,a 
0e81 30 01		    jr nc,Mult12U_NoAdd4 
0e83 19			    add hl,de 
0e84			Mult12U_NoAdd4: 
0e84 29			    add hl,hl 
0e85 87			    add a,a 
0e86 30 01		    jr nc,Mult12U_NoAdd5 
0e88 19			    add hl,de 
0e89			Mult12U_NoAdd5: 
0e89 29			    add hl,hl 
0e8a 87			    add a,a 
0e8b 30 01		    jr nc,Mult12U_NoAdd6 
0e8d 19			    add hl,de 
0e8e			Mult12U_NoAdd6: 
0e8e 29			    add hl,hl 
0e8f 87			    add a,a 
0e90 d0			    ret nc 
0e91 19			    add hl,de 
0e92 c9			    ret 
0e93			 
0e93			; 
0e93			; Multiply 8-bit value with a 16-bit value (right rotating) 
0e93			; In: Multiply A with DE 
0e93			;      Put lowest value in A for most efficient calculation 
0e93			; Out: HL = result 
0e93			; 
0e93			Mult12R: 
0e93 21 00 00		    ld hl,0 
0e96			Mult12R_Loop: 
0e96 cb 3f		    srl a 
0e98 30 01		    jr nc,Mult12R_NoAdd 
0e9a 19			    add hl,de 
0e9b			Mult12R_NoAdd: 
0e9b cb 23		    sla e 
0e9d cb 12		    rl d 
0e9f b7			    or a 
0ea0 c2 96 0e		    jp nz,Mult12R_Loop 
0ea3 c9			    ret 
0ea4			 
0ea4			; 
0ea4			; Multiply 16-bit values (with 32-bit result) 
0ea4			; In: Multiply BC with DE 
0ea4			; Out: BCHL = result 
0ea4			; 
0ea4			Mult32: 
0ea4 79			    ld a,c 
0ea5 48			    ld c,b 
0ea6 21 00 00		    ld hl,0 
0ea9 06 10		    ld b,16 
0eab			Mult32_Loop: 
0eab 29			    add hl,hl 
0eac 17			    rla 
0ead cb 11		    rl c 
0eaf 30 07		    jr nc,Mult32_NoAdd 
0eb1 19			    add hl,de 
0eb2 ce 00		    adc a,0 
0eb4 d2 b8 0e		    jp nc,Mult32_NoAdd 
0eb7 0c			    inc c 
0eb8			Mult32_NoAdd: 
0eb8 10 f1		    djnz Mult32_Loop 
0eba 41			    ld b,c 
0ebb 4f			    ld c,a 
0ebc c9			    ret 
0ebd			 
0ebd			 
0ebd			 
0ebd			; 
0ebd			; Multiply 8-bit values 
0ebd			; In:  Multiply H with E 
0ebd			; Out: HL = result 
0ebd			; 
0ebd			Mult8: 
0ebd 16 00		    ld d,0 
0ebf 6a			    ld l,d 
0ec0 06 08		    ld b,8 
0ec2			Mult8_Loop: 
0ec2 29			    add hl,hl 
0ec3 30 01		    jr nc,Mult8_NoAdd 
0ec5 19			    add hl,de 
0ec6			Mult8_NoAdd: 
0ec6 10 fa		    djnz Mult8_Loop 
0ec8 c9			    ret 
0ec9			 
0ec9			 
0ec9			 
0ec9			 
0ec9			 
0ec9			 
0ec9			 
0ec9			 
0ec9			;;http://z80-heaven.wikidot.com/math 
0ec9			;;This divides DE by BC, storing the result in DE, remainder in HL 
0ec9			; 
0ec9			;DE_Div_BC:          ;1281-2x, x is at most 16 
0ec9			;     ld a,16        ;7 
0ec9			;     ld hl,0        ;10 
0ec9			;     jp $+5         ;10 
0ec9			;.DivLoop: 
0ec9			;       add hl,bc    ;-- 
0ec9			;       dec a        ;64 
0ec9			;       jr z,.DivLoopEnd        ;86 
0ec9			; 
0ec9			;       sla e        ;128 
0ec9			;       rl d         ;128 
0ec9			;       adc hl,hl    ;240 
0ec9			;       sbc hl,bc    ;240 
0ec9			;       jr nc,.DivLoop ;23|21 
0ec9			;       inc e        ;-- 
0ec9			;       jp .DivLoop+1 
0ec9			; 
0ec9			;.DivLoopEnd: 
0ec9			 
0ec9			;HL_Div_C: 
0ec9			;Inputs: 
0ec9			;     HL is the numerator 
0ec9			;     C is the denominator 
0ec9			;Outputs: 
0ec9			;     A is the remainder 
0ec9			;     B is 0 
0ec9			;     C is not changed 
0ec9			;     DE is not changed 
0ec9			;     HL is the quotient 
0ec9			; 
0ec9			;       ld b,16 
0ec9			;       xor a 
0ec9			;         add hl,hl 
0ec9			;         rla 
0ec9			;         cp c 
0ec9			;         jr c,$+4 
0ec9			;           inc l 
0ec9			;           sub c 
0ec9			;         djnz $-7 
0ec9			 
0ec9			; https://plutiedev.com/z80-add-8bit-to-16bit 
0ec9			 
0ec9			addatohl: 
0ec9 85			    add   a, l    ; A = A+L 
0eca 6f			    ld    l, a    ; L = A+L 
0ecb 8c			    adc   a, h    ; A = A+L+H+carry 
0ecc 95			    sub   l       ; A = H+carry 
0ecd 67			    ld    h, a    ; H = H+carry 
0ece c9			ret 
0ecf			 
0ecf			addatode: 
0ecf 83			    add   a, e    ; A = A+L 
0ed0 5f			    ld    e, a    ; L = A+L 
0ed1 8a			    adc   a, d    ; A = A+L+H+carry 
0ed2 93			    sub   e       ; A = H+carry 
0ed3 57			    ld    d, a    ; H = H+carry 
0ed4 c9			ret 
0ed5			 
0ed5			 
0ed5			addatobc: 
0ed5 81			    add   a, c    ; A = A+L 
0ed6 4f			    ld    c, a    ; L = A+L 
0ed7 88			    adc   a, b    ; A = A+L+H+carry 
0ed8 91			    sub   c       ; A = H+carry 
0ed9 47			    ld    b, a    ; H = H+carry 
0eda c9			ret 
0edb			 
0edb			subafromhl: 
0edb			   ; If A=0 do nothing 
0edb			    ; Otherwise flip A's sign. Since 
0edb			    ; the upper byte becomes -1, also 
0edb			    ; substract 1 from H. 
0edb ed 44		    neg 
0edd ca e6 0e		    jp    z, Skip 
0ee0 25			    dec   h 
0ee1			     
0ee1			    ; Now add the low byte as usual 
0ee1			    ; Two's complement takes care of 
0ee1			    ; ensuring the result is correct 
0ee1 85			    add   a, l 
0ee2 6f			    ld    l, a 
0ee3 8c			    adc   a, h 
0ee4 95			    sub   l 
0ee5 67			    ld    h, a 
0ee6			Skip: 
0ee6 c9				ret 
0ee7			 
0ee7			 
0ee7			; compare hl and de 
0ee7			; returns:  
0ee7			; if hl = de, z=1, s=0, c0=0 
0ee7			; if hl > de, z=0, s=0, c=0 
0ee7			; if hl < de, z=0, s=1, c=1 
0ee7			cmp16:	 
0ee7 b7				or a 
0ee8 ed 52			sbc hl,de 
0eea e0				ret po 
0eeb 7c				ld a,h 
0eec 1f				rra 
0eed ee 40			xor 01000000B 
0eef 37				scf 
0ef0 8f				adc a,a 
0ef1 c9				ret 
0ef2			 
0ef2			 
0ef2			; test if hl contains zero   - A is destroyed 
0ef2			 
0ef2			ishlzero:    
0ef2 b7				or a     ; reset flags 
0ef3 7c				ld a, h 
0ef4 b5				or l        	 
0ef5			 
0ef5 c9				ret 
0ef6			 
0ef6			 
0ef6			 
0ef6			 
0ef6			if FORTH_ENABLE_FLOATMATH 
0ef6			;include "float/bbcmath.z80" 
0ef6			include "float/lpfpcalc.asm" 
0ef6			endif 
0ef6			 
0ef6			 
0ef6			; eof 
0ef6			 
# End of file firmware_maths.asm
0ef6			include "firmware_strings.asm"   ; string handling  
0ef6			 
0ef6			 
0ef6			; TODO string len 
0ef6			; input text string, end on cr with zero term 
0ef6			; a offset into frame buffer to start prompt 
0ef6			; d is max length 
0ef6			; e is display size TODO 
0ef6			; c is current cursor position 
0ef6			; hl is ptr to where string will be stored 
0ef6			 
0ef6			 
0ef6			; TODO check limit of buffer for new inserts 
0ef6			; TODO check insert does not push beyond buffer 
0ef6			; TODO scroll in a limited display area 
0ef6			; TODO scroll whole screen on page wrap 
0ef6			 
0ef6			 
0ef6			; TODO handle KEY_PREVWORD 
0ef6			; TODO handle KEY_NEXTWORD 
0ef6			; TODO handle KEY_HOME 
0ef6			; TODO handle KEY_END 
0ef6			; TODO use LCD cursor? 
0ef6			 
0ef6 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0ef9 81					add c 
0efa 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0efd 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f00 79					ld a, c 
0f01 cd c9 0e				call addatohl 
0f04 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f07 7a					ld a,d 
0f08 32 af fe			        ld (input_size), a       ; save length of input area 
0f0b 79					ld a, c 
0f0c 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f0f 7b					ld a,e 
0f10 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f13					 
0f13					 
0f13			 
0f13			;		ld a,(input_ptr) 
0f13			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f13			 
0f13			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f13					; init cursor shape if not set by the cin routines 
0f13 21 4d fd				ld hl, cursor_shape 
0f16 3e ff				ld a, 255 
0f18 77					ld (hl), a 
0f19 23					inc hl 
0f1a 3e 00				ld a, 0 
0f1c 77					ld (hl), a 
0f1d			 
0f1d 3e 0f				ld a, CUR_BLINK_RATE 
0f1f 32 a9 fe				ld (input_cur_flash), a 
0f22 3e 01				ld a, 1 
0f24 32 a8 fe				ld (input_cur_onoff),a 
0f27			 
0f27			;	if DEBUG_INPUT 
0f27			;		push af 
0f27			;		ld a, 'I' 
0f27			;		ld (debug_mark),a 
0f27			;		pop af 
0f27			;		CALLMONITOR 
0f27			;	endif 
0f27			.is1:		; main entry loop 
0f27			 
0f27			 
0f27			 
0f27					; pause 1ms 
0f27			 
0f27 3e 01				ld a, 1 
0f29 cd f7 0b				call aDelayInMS 
0f2c			 
0f2c					; dec flash counter 
0f2c 3a a9 fe				ld a, (input_cur_flash) 
0f2f 3d					dec a 
0f30 32 a9 fe				ld (input_cur_flash), a 
0f33 fe 00				cp 0 
0f35 20 0d				jr nz, .nochgstate 
0f37			 
0f37			 
0f37					; change state 
0f37 3a a8 fe				ld a,(input_cur_onoff) 
0f3a ed 44				neg 
0f3c 32 a8 fe				ld (input_cur_onoff),a 
0f3f			 
0f3f			 
0f3f					; reset on change of state 
0f3f 3e 0f				ld a, CUR_BLINK_RATE 
0f41 32 a9 fe				ld (input_cur_flash), a 
0f44			 
0f44			.nochgstate: 
0f44					 
0f44					 
0f44			 
0f44					; display cursor  
0f44			 
0f44			;		ld hl, (input_start) 
0f44			;		ld a, (input_cursor) 
0f44			;		call addatohl 
0f44			 
0f44					; get char under cursor and replace with cursor 
0f44 2a b2 fe		ld hl, (input_ptr) 
0f47			;		ld a, (hl) 
0f47			;		ld (input_under_cursor),a 
0f47			;		ld a, '_' 
0f47			;		ld (hl), a 
0f47			 
0f47					; display string 
0f47			 
0f47 ed 5b b0 fe			ld de, (input_start) 
0f4b 3a ad fe				ld a, (input_at_pos) 
0f4e cd a8 0c				call str_at_display 
0f51			;	        call update_display 
0f51			 
0f51					; find place to put the cursor 
0f51			;		add h 
0f51			;		ld l, display_row_1 
0f51			;		sub l 
0f51			; (input_at_pos) 
0f51					;ld c, a 
0f51			;		ld a, (input_cursor) 
0f51			;		ld l, (input_at_pos) 
0f51			;		;ld b, h 
0f51			;		add l 
0f51			;		ld (input_at_cursor),a 
0f51					;ld l,h 
0f51			 
0f51			;		ld h, 0 
0f51			;		ld l,(input_at_pos) 
0f51			;		ld a, (input_cursor) 
0f51			;		call addatohl 
0f51			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0f51			;		call subafromhl 
0f51			;		ld a,l 
0f51			;		ld (input_at_cursor), a 
0f51			 
0f51				if DEBUG_INPUT 
0f51					ld a, (hardware_diag) 
0f51					cp 0 
0f51					jr z, .skip_input_diag 
0f51			 
0f51					ld a,(input_at_pos) 
0f51					ld hl, LFSRSeed 
0f51					call hexout 
0f51					ld a, (input_cursor) 
0f51					ld hl, LFSRSeed+2 
0f51					call hexout 
0f51					ld a,(input_at_cursor) 
0f51					ld hl, LFSRSeed+4 
0f51					call hexout 
0f51			 
0f51					ld a,(input_cur_onoff) 
0f51					ld hl, LFSRSeed+6 
0f51					call hexout 
0f51			 
0f51					ld a,(input_cur_flash) 
0f51					ld hl, LFSRSeed+8 
0f51					call hexout 
0f51			 
0f51					ld a,(input_len) 
0f51					ld hl, LFSRSeed+10 
0f51					call hexout 
0f51					ld hl, LFSRSeed+12 
0f51					ld a, 0 
0f51					ld (hl),a 
0f51					ld a, display_row_4 
0f51					ld de, LFSRSeed 
0f51					call str_at_display 
0f51					.skip_input_diag: 
0f51				endif 
0f51			 
0f51					; decide on if we are showing the cursor this time round 
0f51			 
0f51 3a a8 fe				ld a, (input_cur_onoff) 
0f54 fe ff				cp 255 
0f56 28 13				jr z, .skipcur 
0f58			 
0f58			 
0f58 3a ab fe				ld a,(input_at_cursor) 
0f5b 11 4d fd				ld de, cursor_shape 
0f5e cd a8 0c				call str_at_display 
0f61			 
0f61					; save length of current input string 
0f61 2a b0 fe				ld hl, (input_start) 
0f64 cd 27 13				call strlenz 
0f67 7d					ld a,l 
0f68 32 a3 fe				ld (input_len),a 
0f6b			 
0f6b			.skipcur: 
0f6b			 
0f6b cd b8 0c			        call update_display 
0f6e					 
0f6e			 
0f6e			 
0f6e					; wait 
0f6e				 
0f6e					; TODO loop without wait to flash the cursor and char under cursor	 
0f6e cd c9 6a				call cin    ; _wait 
0f71			 
0f71 fe 00				cp 0 
0f73 ca 27 0f				jp z, .is1 
0f76			 
0f76					; get ptr to char to input into 
0f76			 
0f76 4f					ld c,a 
0f77 2a b0 fe				ld hl, (input_start) 
0f7a 3a 9e fe				ld a, (input_cursor) 
0f7d cd c9 0e				call addatohl 
0f80 22 b2 fe				ld (input_ptr), hl 
0f83 79					ld a,c 
0f84			 
0f84					; replace char under cursor 
0f84			 
0f84			;		ld hl, (input_ptr) 
0f84			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0f84			;		ld (hl), a 
0f84			 
0f84			;	if DEBUG_INPUT 
0f84			;		push af 
0f84			;		ld a, 'i' 
0f84			;		ld (debug_mark),a 
0f84			;		pop af 
0f84			;		CALLMONITOR 
0f84			;	endif 
0f84 fe 0e				cp KEY_HOME 
0f86 20 0e				jr nz, .iske 
0f88			 
0f88 3a ad fe				ld a, (input_at_pos) 
0f8b 32 ab fe				ld (input_at_cursor),a 
0f8e 3e 00				ld a, 0 
0f90 32 9e fe				ld (input_cursor), a 
0f93 c3 27 0f				jp .is1 
0f96					 
0f96 fe 0f		.iske:		cp KEY_END 
0f98 20 03				jr nz, .isknw 
0f9a c3 27 0f				jp .is1 
0f9d			 
0f9d fe 06		.isknw:		cp KEY_NEXTWORD 
0f9f 20 1b				jr nz, .iskpw 
0fa1			 
0fa1 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
0fa4 7e					ld a,(hl)	 
0fa5 fe 00				cp 0 
0fa7 ca 27 0f				jp z, .is1    ; end of string 
0faa fe 20				cp ' ' 
0fac ca 27 0f				jp z, .is1    ; end of word 
0faf 23					inc hl 
0fb0 22 b2 fe				ld (input_ptr), hl 
0fb3 3a ab fe				ld a, (input_at_cursor) 
0fb6 3c					inc a 
0fb7 32 ab fe				ld (input_at_cursor), a 
0fba 18 e5				jr .isknwm 
0fbc			 
0fbc fe 07		.iskpw:		cp KEY_PREVWORD 
0fbe 20 1b				jr nz, .iskl 
0fc0			.iskpwm:	 
0fc0 2a b2 fe				ld hl, (input_ptr) 
0fc3 7e					ld a,(hl)	 
0fc4 fe 00				cp 0  
0fc6 ca 27 0f				jp z, .is1    ; end of string 
0fc9 fe 20				cp ' ' 
0fcb ca 27 0f				jp z, .is1    ; end of word 
0fce 2b					dec hl 
0fcf 22 b2 fe				ld (input_ptr), hl 
0fd2 3a ab fe				ld a, (input_at_cursor) 
0fd5 3d					dec a 
0fd6 32 ab fe				ld (input_at_cursor), a 
0fd9 18 e5				jr .iskpwm 
0fdb			 
0fdb			 
0fdb fe 0b		.iskl:		cp KEY_LEFT 
0fdd 20 27				jr nz, .isk1 
0fdf			 
0fdf 3a 9e fe				ld a, (input_cursor) 
0fe2			 
0fe2 fe 00				cp 0 
0fe4 ca 27 0f				jp z, .is1 		; at start of line to ignore  
0fe7			 
0fe7 3d					dec  a 		; TODO check underflow 
0fe8 32 9e fe				ld (input_cursor), a 
0feb			 
0feb 2a b2 fe				ld hl, (input_ptr) 
0fee 2b					dec hl 
0fef 22 b2 fe				ld (input_ptr), hl 
0ff2					 
0ff2 3a ab fe				ld a, (input_at_cursor) 
0ff5 3d					dec a 
0ff6 32 ab fe				ld (input_at_cursor), a 
0ff9			 
0ff9 3e 01				ld a, 1		; show cursor moving 
0ffb 32 a8 fe				ld (input_cur_onoff),a 
0ffe 3e 0f				ld a, CUR_BLINK_RATE 
1000 32 a9 fe				ld (input_cur_flash), a 
1003			 
1003 c3 27 0f				jp .is1 
1006			 
1006 fe 0c		.isk1:		cp KEY_RIGHT 
1008 20 2a				jr nz, .isk2 
100a			 
100a 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
100d 5f					ld e,a 
100e 3a 9e fe				ld a, (input_cursor) 
1011 bb					cp e 
1012 ca 27 0f				jp z, .is1		; at the end of string so dont go right 
1015			 
1015 3c					inc  a 		; TODO check overflow 
1016 32 9e fe				ld (input_cursor), a 
1019			 
1019 3a ab fe				ld a, (input_at_cursor) 
101c 3c					inc a 
101d 32 ab fe				ld (input_at_cursor), a 
1020			 
1020 2a b2 fe				ld hl, (input_ptr) 
1023 23					inc hl 
1024 22 b2 fe				ld (input_ptr), hl 
1027			 
1027 3e 01				ld a, 1		; show cursor moving 
1029 32 a8 fe				ld (input_cur_onoff),a 
102c 3e 0f				ld a, CUR_BLINK_RATE 
102e 32 a9 fe				ld (input_cur_flash), a 
1031			 
1031 c3 27 0f				jp .is1 
1034			 
1034 fe 05		.isk2:		cp KEY_UP 
1036			 
1036 20 26				jr nz, .isk3 
1038			 
1038					; swap last command with the current on 
1038			 
1038					; move cursor to start of string 
1038 2a b0 fe				ld hl, (input_start) 
103b 22 b2 fe				ld (input_ptr), hl 
103e			 
103e 3a ad fe				ld a, (input_at_pos) 
1041 32 ab fe				ld (input_at_cursor), a 
1044			 
1044 3e 00				ld a, 0 
1046 32 9e fe				ld (input_cursor), a 
1049					 
1049					; swap input and last command buffers 
1049			 
1049 21 ac f6				ld hl, os_cli_cmd 
104c 11 ab f7				ld de, os_last_cmd 
104f 06 ff				ld b, 255 
1051 7e			.swap1:		ld a, (hl) 
1052 4f					ld c,a 
1053 1a					ld a, (de) 
1054 77					ld (hl), a 
1055 79					ld a,c 
1056 12					ld (de),a 
1057 23					inc hl 
1058 13					inc de 
1059 10 f6				djnz .swap1 
105b			 
105b			 
105b			 
105b			 
105b			 
105b c3 27 0f				jp .is1 
105e			 
105e fe 08		.isk3:		cp KEY_BS 
1060 20 3c				jr nz, .isk4 
1062			 
1062 3a 9e fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca 27 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 9e fe				ld (input_cursor), a 
106e			 
106e					; hl is source 
106e					; de needs to be source - 1 
106e			 
106e			;		ld a, 0 
106e			;		dec hl 
106e			;		ld (hl), a 
106e			 
106e 2a b2 fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 b2 fe				ld (input_ptr), hl 
1075			 
1075					; shift all data 
1075			 
1075 e5					push hl 
1076 23					inc hl 
1077 d1					pop de 
1078 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
107b 4f					ld c,a 
107c 06 00				ld b,0 
107e ed b0				ldir  
1080			 
1080			 
1080			 
1080			 
1080 3a ab fe				ld a, (input_at_cursor) 
1083 3d					dec a 
1084 32 ab fe				ld (input_at_cursor), a 
1087			 
1087			 
1087 3e 01				ld a, 1		; show cursor moving 
1089 32 a8 fe				ld (input_cur_onoff),a 
108c 3e 0f				ld a, CUR_BLINK_RATE 
108e 32 a9 fe				ld (input_cur_flash), a 
1091			 
1091					; remove char 
1091 3a ab fe				ld a, (input_at_cursor) 
1094 3c					inc a 
1095 11 1f 11				ld de,.iblank 
1098 cd a8 0c				call str_at_display 
109b			 
109b c3 27 0f				jp .is1 
109e			 
109e fe 0d		.isk4:		cp KEY_CR 
10a0 28 6c				jr z, .endinput 
10a2			 
10a2					; else add the key press to the end 
10a2			 
10a2 4f					ld c, a			; save key pressed 
10a3			 
10a3 7e					ld a,(hl)		; get what is currently under char 
10a4			 
10a4 fe 00				cp 0			; we are at the end of the string 
10a6 20 2f				jr nz, .onchar 
10a8					 
10a8					; add a char to the end of the string 
10a8				 
10a8 71					ld (hl),c 
10a9 23					inc hl 
10aa			;		ld a,' ' 
10aa			;		ld (hl),a 
10aa			;		inc hl 
10aa 3e 00				ld a,0 
10ac 77					ld (hl),a 
10ad 2b					dec hl 
10ae			 
10ae 3a 9e fe				ld a, (input_cursor) 
10b1 3c					inc a				; TODO check max string length and scroll  
10b2 32 9e fe				ld (input_cursor), a		; inc cursor pos 
10b5							 
10b5 3a ab fe				ld a, (input_at_cursor) 
10b8 3c					inc a 
10b9 32 ab fe				ld (input_at_cursor), a 
10bc			 
10bc 2a b2 fe				ld hl, (input_ptr) 
10bf 23					inc hl 
10c0 22 b2 fe				ld (input_ptr), hl 
10c3			 
10c3 2a b2 fe				ld hl, (input_ptr) 
10c6 23					inc hl 
10c7 22 b2 fe				ld (input_ptr), hl 
10ca			;	if DEBUG_INPUT 
10ca			;		push af 
10ca			;		ld a, '+' 
10ca			;		ld (debug_mark),a 
10ca			;		pop af 
10ca			;		CALLMONITOR 
10ca			;	endif 
10ca 3e 01				ld a, 1		; show cursor moving 
10cc 32 a8 fe				ld (input_cur_onoff),a 
10cf 3e 0f				ld a, CUR_BLINK_RATE 
10d1 32 a9 fe				ld (input_cur_flash), a 
10d4 c3 27 0f				jp .is1 
10d7					 
10d7			 
10d7			 
10d7					; if on a char then insert 
10d7			.onchar: 
10d7			 
10d7					; TODO over flow check: make sure insert does not blow out buffer 
10d7			 
10d7					; need to do some maths to use lddr 
10d7			 
10d7 e5					push hl   ; save char pos 
10d8 c5					push bc 
10d9			 
10d9 2a b0 fe				ld hl, (input_start) 
10dc 3a a3 fe				ld a, (input_len) 
10df cd c9 0e				call addatohl  		; end of string 
10e2 23					inc hl 
10e3 23					inc hl		; past zero term 
10e4 e5					push hl 
10e5 23					inc hl 
10e6 e5					push hl  
10e7			 
10e7								; start and end of lddr set, now how much to move? 
10e7			 
10e7							 
10e7 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
10ea 47					ld b,a 
10eb 3a a3 fe				ld a,(input_len) 
10ee 5f					ld e,a 
10ef 90					sub b 
10f0 3c					inc a		;?? 
10f1 3c					inc a		;?? 
10f2 3c					inc a		;?? 
10f3			 
10f3 06 00				ld b,0 
10f5 4f					ld c,a 
10f6			 
10f6				if DEBUG_INPUT 
10f6					push af 
10f6					ld a, 'i' 
10f6					ld (debug_mark),a 
10f6					pop af 
10f6			;		CALLMONITOR 
10f6				endif 
10f6 d1					pop de 
10f7 e1					pop hl 
10f8				if DEBUG_INPUT 
10f8					push af 
10f8					ld a, 'I' 
10f8					ld (debug_mark),a 
10f8					pop af 
10f8			;		CALLMONITOR 
10f8				endif 
10f8 ed b8				lddr 
10fa				 
10fa			 
10fa			 
10fa					; TODO have a key for insert/overwrite mode???? 
10fa c1					pop bc 
10fb e1					pop hl 
10fc 71					ld (hl), c		; otherwise overwrite current char 
10fd					 
10fd			 
10fd			 
10fd			 
10fd 3a 9e fe				ld a, (input_cursor) 
1100 3c					inc  a 		; TODO check overflow 
1101 32 9e fe				ld (input_cursor), a 
1104			 
1104 3a ab fe				ld a, (input_at_cursor) 
1107 3c					inc a 
1108 32 ab fe				ld (input_at_cursor), a 
110b			 
110b c3 27 0f				jp .is1 
110e			 
110e			.endinput:	; TODO look for end of string 
110e			 
110e					; add trailing space for end of token 
110e			 
110e 2a b0 fe				ld hl, (input_start) 
1111 3a a3 fe				ld a,(input_len) 
1114 cd c9 0e				call addatohl 
1117 3e 20				ld a, ' ' 
1119 77					ld (hl),a 
111a					; TODO eof of parse marker 
111a			 
111a 23					inc hl 
111b 3e 00				ld a, 0 
111d 77					ld (hl),a 
111e			 
111e			 
111e c9					ret 
111f			 
111f .. 00		.iblank: db " ",0 
1121			 
1121			 
1121 32 ad fe		input_str_prev:	ld (input_at_pos), a 
1124 22 b0 fe				ld (input_start), hl 
1127 3e 01				ld a,1			; add cursor 
1129 77					ld (hl),a 
112a 23					inc hl 
112b 3e 00				ld a,0 
112d 77					ld (hl),a 
112e 22 b2 fe				ld (input_ptr), hl 
1131 7a					ld a,d 
1132 32 af fe				ld (input_size), a 
1135 3e 00				ld a,0 
1137 32 9e fe				ld (input_cursor),a 
113a			.instr1:	 
113a			 
113a					; TODO do block cursor 
113a					; TODO switch cursor depending on the modifer key 
113a			 
113a					; update cursor shape change on key hold 
113a			 
113a 2a b2 fe				ld hl, (input_ptr) 
113d 2b					dec hl 
113e 3a 4d fd				ld a,(cursor_shape) 
1141 77					ld (hl), a 
1142			 
1142					; display entered text 
1142 3a ad fe				ld a,(input_at_pos) 
1145 cd e7 69		            	CALL fLCD_Pos       ;Position cursor to location in A 
1148 ed 5b b0 fe	            	LD   de, (input_start) 
114c cd ef 69		            	CALL fLCD_Str       ;Display string pointed to by DE 
114f			 
114f cd c9 6a				call cin 
1152 fe 00				cp 0 
1154 28 e4				jr z, .instr1 
1156			 
1156					; proecess keyboard controls first 
1156			 
1156 2a b2 fe				ld hl,(input_ptr) 
1159			 
1159 fe 0d				cp KEY_CR	 ; pressing enter ends input 
115b 28 5a				jr z, .instrcr 
115d			 
115d fe 08				cp KEY_BS 	; back space 
115f 20 0f				jr nz, .instr2 
1161					; process back space 
1161			 
1161					; TODO stop back space if at start of string 
1161 2b					dec hl 
1162 2b					dec hl ; to over write cursor 
1163 3a 4d fd				ld a,(cursor_shape) 
1166					;ld a,0 
1166 77					ld (hl),a 
1167 23					inc hl 
1168 3e 20				ld a," " 
116a 77					ld (hl),a 
116b 22 b2 fe				ld (input_ptr),hl 
116e					 
116e			 
116e 18 ca				jr .instr1 
1170			 
1170 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1172 20 06				jr nz, .instr3 
1174 2b					dec hl 
1175 22 b2 fe				ld (input_ptr),hl 
1178 18 c0				jr .instr1 
117a				 
117a fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
117c 20 06				jr nz, .instr4 
117e 23					inc hl 
117f 22 b2 fe				ld (input_ptr),hl 
1182 18 b6				jr .instr1 
1184			 
1184 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1186 20 06				jr nz, .instr5 
1188 2b					dec hl 
1189 22 b2 fe				ld (input_ptr),hl 
118c 18 ac				jr .instr1 
118e			 
118e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1190 20 06				jr nz, .instr6 
1192 2b					dec hl 
1193 22 b2 fe				ld (input_ptr),hl 
1196 18 a2				jr .instr1 
1198 fe 05		.instr6:        cp KEY_UP      ; recall last command 
119a 20 0b				jr nz, .instrnew 
119c			 
119c 21 85 f3			ld hl, scratch 
119f 11 ab f7			ld de, os_last_cmd 
11a2 cd c0 11			call strcpy 
11a5 18 93				jr .instr1 
11a7			 
11a7			 
11a7			.instrnew:	; no special key pressed to see if we have room to store it 
11a7			 
11a7					; TODO do string size test 
11a7			 
11a7 2b					dec hl ; to over write cursor 
11a8 77					ld (hl),a 
11a9 23					inc hl 
11aa 3a 4d fd				ld a,(cursor_shape) 
11ad 77					ld (hl),a 
11ae 23					inc hl 
11af 3e 00				ld a,0 
11b1 77					ld (hl),a 
11b2			 
11b2 22 b2 fe				ld (input_ptr),hl 
11b5					 
11b5 18 83				jr .instr1 
11b7 2b			.instrcr:	dec hl		; remove cursor 
11b8 3e 20				ld a,' '	; TODO add a trailing space for safety 
11ba 77					ld (hl),a 
11bb 23					inc hl 
11bc 3e 00				ld a,0 
11be 77					ld (hl),a 
11bf			 
11bf			 
11bf					; if at end of line scroll up    
11bf					; TODO detecting only end of line 4 for scroll up  
11bf			 
11bf					;ld   
11bf			 
11bf c9					ret 
11c0			 
11c0			 
11c0			; strcpy hl = dest, de source 
11c0			 
11c0 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11c1 b7			            OR   A              ;Null terminator? 
11c2 c8			            RET  Z              ;Yes, so finished 
11c3 1a					ld a,(de) 
11c4 77					ld (hl),a 
11c5 13			            INC  DE             ;Point to next character 
11c6 23					inc hl 
11c7 18 f7		            JR   strcpy       ;Repeat 
11c9 c9					ret 
11ca			 
11ca			 
11ca			; TODO string_at  
11ca			; pass string which starts with lcd offset address and then null term string 
11ca			 
11ca			; TODO string to dec 
11ca			; TODO string to hex 
11ca			; TODO byte to string hex 
11ca			; TODO byte to string dec 
11ca			 
11ca			 
11ca			 
11ca			; from z80uartmonitor 
11ca			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ca			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11ca			; pass hl for where to put the text 
11ca			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ca c5			hexout:	PUSH BC 
11cb f5					PUSH AF 
11cc 47					LD B, A 
11cd					; Upper nybble 
11cd cb 3f				SRL A 
11cf cb 3f				SRL A 
11d1 cb 3f				SRL A 
11d3 cb 3f				SRL A 
11d5 cd e5 11				CALL tohex 
11d8 77					ld (hl),a 
11d9 23					inc hl	 
11da					 
11da					; Lower nybble 
11da 78					LD A, B 
11db e6 0f				AND 0FH 
11dd cd e5 11				CALL tohex 
11e0 77					ld (hl),a 
11e1 23					inc hl	 
11e2					 
11e2 f1					POP AF 
11e3 c1					POP BC 
11e4 c9					RET 
11e5					 
11e5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e5			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11e5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e5			tohex: 
11e5 e5					PUSH HL 
11e6 d5					PUSH DE 
11e7 16 00				LD D, 0 
11e9 5f					LD E, A 
11ea 21 f2 11				LD HL, .DATA 
11ed 19					ADD HL, DE 
11ee 7e					LD A, (HL) 
11ef d1					POP DE 
11f0 e1					POP HL 
11f1 c9					RET 
11f2			 
11f2			.DATA: 
11f2 30					DEFB	30h	; 0 
11f3 31					DEFB	31h	; 1 
11f4 32					DEFB	32h	; 2 
11f5 33					DEFB	33h	; 3 
11f6 34					DEFB	34h	; 4 
11f7 35					DEFB	35h	; 5 
11f8 36					DEFB	36h	; 6 
11f9 37					DEFB	37h	; 7 
11fa 38					DEFB	38h	; 8 
11fb 39					DEFB	39h	; 9 
11fc 41					DEFB	41h	; A 
11fd 42					DEFB	42h	; B 
11fe 43					DEFB	43h	; C 
11ff 44					DEFB	44h	; D 
1200 45					DEFB	45h	; E 
1201 46					DEFB	46h	; F 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1202			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1202			;;    subtract $30, if result > 9 then subtract $7 more 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1202			atohex: 
1202 d6 30				SUB $30 
1204 fe 0a				CP 10 
1206 f8					RET M		; If result negative it was 0-9 so we're done 
1207 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1209 c9					RET		 
120a			 
120a			 
120a			 
120a			 
120a			; Get 2 ASCII characters as hex byte from pointer in hl 
120a			 
120a			BYTERD: 
120a 16 00			LD	D,00h		;Set up 
120c cd 14 12			CALL	HEXCON		;Get byte and convert to hex 
120f 87				ADD	A,A		;First nibble so 
1210 87				ADD	A,A		;multiply by 16 
1211 87				ADD	A,A		; 
1212 87				ADD	A,A		; 
1213 57				LD	D,A		;Save hi nibble in D 
1214			HEXCON: 
1214 7e				ld a, (hl)		;Get next chr 
1215 23				inc hl 
1216 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1218 fe 0a			CP	00Ah		;Is it 0-9 ? 
121a 38 02			JR	C,NALPHA	;If so miss next bit 
121c d6 07			SUB	007h		;Else convert alpha 
121e			NALPHA: 
121e b2				OR	D		;Add hi nibble back 
121f c9				RET			; 
1220			 
1220			 
1220			; 
1220			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1220			; Since the routines get_byte and therefore get_nibble are called, only valid 
1220			; characters (0-9a-f) are accepted. 
1220			; 
1220			;get_word        push    af 
1220			;                call    get_byte        ; Get the upper byte 
1220			;                ld      h, a 
1220			;                call    get_byte        ; Get the lower byte 
1220			;                ld      l, a 
1220			;                pop     af 
1220			;                ret 
1220			; 
1220			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1220			; the routine get_nibble is used only valid characters are accepted - the  
1220			; input routine only accepts characters 0-9a-f. 
1220			; 
1220 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1221 7e					ld a,(hl) 
1222 23					inc hl 
1223 cd 48 12		                call    nibble2val      ; Get upper nibble 
1226 cb 07		                rlc     a 
1228 cb 07		                rlc     a 
122a cb 07		                rlc     a 
122c cb 07		                rlc     a 
122e 47			                ld      b, a            ; Save upper four bits 
122f 7e					ld a,(hl) 
1230 cd 48 12		                call    nibble2val      ; Get lower nibble 
1233 b0			                or      b               ; Combine both nibbles 
1234 c1			                pop     bc              ; Restore B (and C) 
1235 c9			                ret 
1236			; 
1236			; Get a hexadecimal digit from the serial line. This routine blocks until 
1236			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1236			; to the serial line interface. The lower 4 bits of A contain the value of  
1236			; that particular digit. 
1236			; 
1236			;get_nibble      ld a,(hl)           ; Read a character 
1236			;                call    to_upper        ; Convert to upper case 
1236			;                call    is_hex          ; Was it a hex digit? 
1236			;                jr      nc, get_nibble  ; No, get another character 
1236			 ;               call    nibble2val      ; Convert nibble to value 
1236			 ;               call    print_nibble 
1236			 ;               ret 
1236			; 
1236			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1236			; A valid hexadecimal digit is denoted by a set C flag. 
1236			; 
1236			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1236			;                ret     nc              ; Yes 
1236			;                cp      '0'             ; Less than '0'? 
1236			;                jr      nc, is_hex_1    ; No, continue 
1236			;                ccf                     ; Complement carry (i.e. clear it) 
1236			;                ret 
1236			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1236			;                ret     c               ; Yes 
1236			;                cp      'A'             ; Less than 'A'? 
1236			;                jr      nc, is_hex_2    ; No, continue 
1236			;                ccf                     ; Yes - clear carry and return 
1236			;                ret 
1236			;is_hex_2        scf                     ; Set carry 
1236			;                ret 
1236			; 
1236			; Convert a single character contained in A to upper case: 
1236			; 
1236 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1238 d8			                ret     c 
1239 fe 7b		                cp      'z' + 1         ; > 'z'? 
123b d0			                ret     nc              ; Nothing to do, either 
123c e6 5f		                and     $5f             ; Convert to upper case 
123e c9			                ret 
123f			 
123f			 
123f			to_lower: 
123f			 
123f			   ; if char is in [A-Z] make it lower case 
123f			 
123f			   ; enter : a = char 
123f			   ; exit  : a = lower case char 
123f			   ; uses  : af 
123f			 
123f fe 41		   cp 'A' 
1241 d8			   ret c 
1242			    
1242 fe 5b		   cp 'Z'+1 
1244 d0			   ret nc 
1245			    
1245 f6 20		   or $20 
1247 c9			   ret 
1248			 
1248			; 
1248			; Expects a hexadecimal digit (upper case!) in A and returns the 
1248			; corresponding value in A. 
1248			; 
1248 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
124a 38 02		                jr      c, nibble2val_1 ; Yes 
124c d6 07		                sub     7               ; Adjust for A-F 
124e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1250 e6 0f		                and     $f              ; Only return lower 4 bits 
1252 c9			                ret 
1253			; 
1253			; Print_nibble prints a single hex nibble which is contained in the lower  
1253			; four bits of A: 
1253			; 
1253			;print_nibble    push    af              ; We won't destroy the contents of A 
1253			;                and     $f              ; Just in case... 
1253			;                add     a, '0'             ; If we have a digit we are done here. 
1253			;                cp      '9' + 1         ; Is the result > 9? 
1253			;                jr      c, print_nibble_1 
1253			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1253			;print_nibble_1  call    putc            ; Print the nibble and 
1253			;                pop     af              ; restore the original value of A 
1253			;                ret 
1253			;; 
1253			;; Send a CR/LF pair: 
1253			; 
1253			;crlf            push    af 
1253			;                ld      a, cr 
1253			;                call    putc 
1253			;                ld      a, lf 
1253			;                call    putc 
1253			;                pop     af 
1253			;                ret 
1253			; 
1253			; Print_word prints the four hex digits of a word to the serial line. The  
1253			; word is expected to be in HL. 
1253			; 
1253			;print_word      push    hl 
1253			;                push    af 
1253			;                ld      a, h 
1253			;                call    print_byte 
1253			;                ld      a, l 
1253			;                call    print_byte 
1253			;                pop     af 
1253			;                pop     hl 
1253			;                ret 
1253			; 
1253			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1253			; The byte to be printed is expected to be in A. 
1253			; 
1253			;print_byte      push    af              ; Save the contents of the registers 
1253			;                push    bc 
1253			;                ld      b, a 
1253			;                rrca 
1253			;                rrca 
1253			;                rrca 
1253			;                rrca 
1253			;                call    print_nibble    ; Print high nibble 
1253			;                ld      a, b 
1253			;                call    print_nibble    ; Print low nibble 
1253			;                pop     bc              ; Restore original register contents 
1253			;                pop     af 
1253			;                ret 
1253			 
1253			 
1253			 
1253			 
1253			 
1253			fourehexhl:  
1253 7e				ld a,(hl) 
1254 cd 02 12			call atohex 
1257 cb 3f				SRL A 
1259 cb 3f				SRL A 
125b cb 3f				SRL A 
125d cb 3f				SRL A 
125f 47				ld b, a 
1260 23				inc hl 
1261 7e				ld a,(hl) 
1262 23				inc hl 
1263 cd 02 12			call atohex 
1266 80				add b 
1267 57				ld d,a 
1268 7e				ld a,(hl) 
1269 cd 02 12			call atohex 
126c cb 3f				SRL A 
126e cb 3f				SRL A 
1270 cb 3f				SRL A 
1272 cb 3f				SRL A 
1274 47				ld b, a 
1275 23				inc hl 
1276 7e				ld a,(hl) 
1277 23				inc hl 
1278 cd 02 12			call atohex 
127b 80				add b 
127c 5f				ld e, a 
127d d5				push de 
127e e1				pop hl 
127f c9				ret 
1280			 
1280			; pass hl. returns z set if the byte at hl is a digit 
1280			;isdigithl:  
1280			;	push bc 
1280			;	ld a,(hl) 
1280			;	cp ':' 
1280			;	jr nc, .isdf 		; > 
1280			;	cp '0' 
1280			;	jr c, .isdf		; < 
1280			; 
1280			;	; TODO find a better way to set z 
1280			; 
1280			;	ld b,a 
1280			;	cp b 
1280			;	pop bc 
1280			;	ret 
1280			; 
1280			;.isdf:	; not digit so clear z 
1280			; 
1280			;	; TODO find a better way to unset z 
1280			; 
1280			;	ld b,a 
1280			;	inc b 
1280			;	cp b 
1280			; 
1280			;	pop bc 
1280			;	ret 
1280				 
1280				 
1280			 
1280			 
1280			; pass hl as the four byte address to load 
1280			 
1280			get_word_hl:  
1280 e5				push hl 
1281 cd 20 12			call get_byte 
1284				 
1284 47				ld b, a 
1285			 
1285 e1				pop hl 
1286 23				inc hl 
1287 23				inc hl 
1288			 
1288			; TODO not able to handle a-f  
1288 7e				ld a,(hl) 
1289			;	;cp ':' 
1289			;	cp 'g' 
1289			;	jr nc, .single_byte_hl 		; > 
1289			;	cp 'G' 
1289			;	jr nc, .single_byte_hl 		; > 
1289			;	cp '0' 
1289			;	jr c, .single_byte_hl		; < 
1289			 
1289				;call isdigithl 
1289 fe 00			cp 0 
128b 28 06			jr z, .single_byte_hl 
128d			 
128d			.getwhln:   ; hex word so get next byte 
128d			 
128d cd 20 12			call get_byte 
1290 6f				ld l, a 
1291 60				ld h,b 
1292 c9				ret 
1293 68			.single_byte_hl:   ld l,b 
1294 26 00				ld h,0 
1296 c9					ret 
1297			 
1297			 
1297			 
1297			 
1297 21 d1 1b			ld hl,asc+1 
129a			;	ld a, (hl) 
129a			;	call nibble2val 
129a cd 20 12			call get_byte 
129d			 
129d			;	call fourehexhl 
129d 32 b9 f3			ld (scratch+52),a 
12a0				 
12a0 21 b7 f3			ld hl,scratch+50 
12a3 22 a8 f6			ld (os_cur_ptr),hl 
12a6			 
12a6 c9				ret 
12a7			 
12a7			 
12a7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12a7			 
12a7			; Decimal Unsigned Version 
12a7			 
12a7			;Number in a to decimal ASCII 
12a7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12a7			;Example: display a=56 as "056" 
12a7			;input: a = number 
12a7			;Output: a=0,value of a in the screen 
12a7			;destroys af,bc (don't know about hl and de) 
12a7			DispAToASCII: 
12a7 0e 9c			ld	c,-100 
12a9 cd b3 12			call	.Na1 
12ac 0e f6			ld	c,-10 
12ae cd b3 12			call	.Na1 
12b1 0e ff			ld	c,-1 
12b3 06 2f		.Na1:	ld	b,'0'-1 
12b5 04			.Na2:	inc	b 
12b6 81				add	a,c 
12b7 38 fc			jr	c,.Na2 
12b9 91				sub	c		;works as add 100/10/1 
12ba f5				push af		;safer than ld c,a 
12bb 78				ld	a,b		;char is in b 
12bc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12bc f1				pop af		;safer than ld a,c 
12bd c9				ret 
12be			 
12be			; Decimal Signed Version 
12be			 
12be			; DispA 
12be			; -------------------------------------------------------------- 
12be			; Converts a signed integer value to a zero-terminated ASCII 
12be			; string representative of that value (using radix 10). 
12be			; -------------------------------------------------------------- 
12be			; INPUTS: 
12be			;     HL     Value to convert (two's complement integer). 
12be			;     DE     Base address of string destination. (pointer). 
12be			; -------------------------------------------------------------- 
12be			; OUTPUTS: 
12be			;     None 
12be			; -------------------------------------------------------------- 
12be			; REGISTERS/MEMORY DESTROYED 
12be			; AF HL 
12be			; -------------------------------------------------------------- 
12be			 
12be			;DispHLToASCII: 
12be			;   push    de 
12be			;   push    bc 
12be			; 
12be			;; Detect sign of HL. 
12be			;    bit    7, h 
12be			;    jr     z, ._DoConvert 
12be			; 
12be			;; HL is negative. Output '-' to string and negate HL. 
12be			;    ld     a, '-' 
12be			;    ld     (de), a 
12be			;    inc    de 
12be			; 
12be			;; Negate HL (using two's complement) 
12be			;    xor    a 
12be			;    sub    l 
12be			;    ld     l, a 
12be			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12be			;    sbc    a, h 
12be			;    ld     h, a 
12be			; 
12be			;; Convert HL to digit characters 
12be			;._DoConvert: 
12be			;    ld     b, 0     ; B will count character length of number 
12be			;-   ld     a, 10 
12be			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12be			;    push   af 
12be			;    inc    b 
12be			;    ld     a, h 
12be			;    or     l 
12be			;    jr     nz, - 
12be			; 
12be			;; Retrieve digits from stack 
12be			;-   pop    af 
12be			;    or     $30 
12be			;    ld     (de), a 
12be			;    inc    de 
12be			;    djnz   - 
12be			; 
12be			;; Terminate string with NULL 
12be			;    xor    a 
12be			;    ld     (de), a 
12be			; 
12be			;    pop    bc 
12be			;    pop    de 
12be			;    ret 
12be			 
12be			;Comments 
12be			; 
12be			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12be			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12be			;    Note that the output string will not be fixed-width. 
12be			; 
12be			;Example Usage 
12be			; 
12be			;    ld    hl, -1004 
12be			;    ld    de, OP1 
12be			;    call  DispA 
12be			;    ld    hl, OP1 
12be			;    syscall  PutS 
12be			 
12be			 
12be			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12be			 
12be			 
12be			;Converts an ASCII string to an unsigned 16-bit integer 
12be			;Quits when it reaches a non-decimal digit 
12be			 
12be			string_to_uint16: 
12be			atoui_16: 
12be			;Input: 
12be			;     DE points to the string 
12be			;Outputs: 
12be			;     HL is the result 
12be			;     A is the 8-bit value of the number 
12be			;     DE points to the byte after the number 
12be			;Destroys: 
12be			;     BC 
12be			;       if the string is non-empty, BC is HL/10 
12be			;Size:  24 bytes 
12be			;Speed: 42+d(104+{0,9}) 
12be			;       d is the number of digits in the number 
12be			;       max is 640 cycles for a 5 digit number 
12be			;Assuming no leading zeros: 
12be			;1 digit:  146cc 
12be			;2 digit:  250cc 
12be			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12be			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12be			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12be			;avg: 544.81158447265625cc (544+13297/16384) 
12be			;=============================================================== 
12be 21 00 00		  ld hl,0 
12c1			.u16a: 
12c1 1a			  ld a,(de) 
12c2 d6 30		  sub 30h 
12c4 fe 0a		  cp 10 
12c6 d0			  ret nc 
12c7 13			  inc de 
12c8 44			  ld b,h 
12c9 4d			  ld c,l 
12ca 29			  add hl,hl 
12cb 29			  add hl,hl 
12cc 09			  add hl,bc 
12cd 29			  add hl,hl 
12ce 85			  add a,l 
12cf 6f			  ld l,a 
12d0 30 ef		  jr nc,.u16a 
12d2 24			  inc h 
12d3 c3 c1 12		  jp .u16a 
12d6			 
12d6			 
12d6			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12d6			 
12d6			;written by Zeda 
12d6			;Converts a 16-bit unsigned integer to an ASCII string. 
12d6			 
12d6			uitoa_16: 
12d6			;Input: 
12d6			;   DE is the number to convert 
12d6			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12d6			;Output: 
12d6			;   HL points to the null-terminated ASCII string 
12d6			;      NOTE: This isn't necessarily the same as the input HL. 
12d6 d5			  push de 
12d7 c5			  push bc 
12d8 f5			  push af 
12d9 eb			  ex de,hl 
12da			 
12da 01 f0 d8		  ld bc,-10000 
12dd 3e 2f		  ld a,'0'-1 
12df 3c			  inc a 
12e0 09			  add hl,bc  
12e1 38 fc		   jr c,$-2 
12e3 12			  ld (de),a 
12e4 13			  inc de 
12e5			 
12e5 01 e8 03		  ld bc,1000 
12e8 3e 3a		  ld a,'9'+1 
12ea 3d			  dec a  
12eb 09			  add hl,bc  
12ec 30 fc		   jr nc,$-2 
12ee 12			  ld (de),a 
12ef 13			  inc de 
12f0			 
12f0 01 9c ff		  ld bc,-100 
12f3 3e 2f		  ld a,'0'-1 
12f5 3c			  inc a  
12f6 09			  add hl,bc  
12f7 38 fc		   jr c,$-2 
12f9 12			  ld (de),a 
12fa 13			  inc de 
12fb			 
12fb 7d			  ld a,l 
12fc 26 3a		  ld h,'9'+1 
12fe 25			  dec h  
12ff c6 0a		  add a,10  
1301 30 fb		   jr nc,$-3 
1303 c6 30		  add a,'0' 
1305 eb			  ex de,hl 
1306 72			  ld (hl),d 
1307 23			  inc hl 
1308 77			  ld (hl),a 
1309 23			  inc hl 
130a 36 00		  ld (hl),0 
130c			 
130c			;Now strip the leading zeros 
130c 0e fa		  ld c,-6 
130e 09			  add hl,bc 
130f 3e 30		  ld a,'0' 
1311 23			  inc hl  
1312 be			  cp (hl)  
1313 28 fc		  jr z,$-2 
1315			 
1315			;Make sure that the string is non-empty! 
1315 7e			  ld a,(hl) 
1316 b7			  or a 
1317 20 01		  jr nz,.atoub 
1319 2b			  dec hl 
131a			.atoub: 
131a			 
131a f1			  pop af 
131b c1			  pop bc 
131c d1			  pop de 
131d c9			  ret 
131e			 
131e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
131e			 
131e			toUpper: 
131e			;A is the char. 
131e			;If A is a lowercase letter, this sets it to the matching uppercase 
131e			;18cc or 30cc or 41cc 
131e			;avg: 26.75cc 
131e fe 61		  cp 'a' 
1320 d8			  ret c 
1321 fe 7b		  cp 'z'+1 
1323 d0			  ret nc 
1324 d6 20		  sub 'a'-'A' 
1326 c9			  ret 
1327			 
1327			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1327			 
1327			; String Length 
1327			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1327			 
1327			; Get the length of the null-terminated string starting at $8000 hl 
1327			;    LD     HL, $8000 
1327			 
1327			strlenz: 
1327			 
1327 af			    XOR    A               ; Zero is the value we are looking for. 
1328 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1329 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
132a			                           ; 65, 536 bytes (the entire addressable memory space). 
132a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
132c			 
132c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
132c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
132d 6f			    LD     L, A             ; number of bytes 
132e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1330 2b			    DEC    HL              ; Compensate for null. 
1331 c9				ret 
1332			 
1332			; Get the length of the A terminated string starting at $8000 hl 
1332			;    LD     HL, $8000 
1332			 
1332			strlent: 
1332			 
1332			                  ; A is the value we are looking for. 
1332 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1334 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1336			                           ; 65, 536 bytes (the entire addressable memory space). 
1336 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1338			 
1338			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1338 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
133a 2e 00		    LD     L, 0             ; number of bytes 
133c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
133e 2b			    DEC    HL              ; Compensate for null. 
133f c9				ret 
1340			 
1340			 
1340			;Comparing Strings 
1340			 
1340			;IN    HL     Address of string1. 
1340			;      DE     Address of string2. 
1340			 
1340			; doc given but wrong??? 
1340			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1340			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1340			; tested 
1340			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1340			 
1340			strcmp_old: 
1340 e5			    PUSH   HL 
1341 d5			    PUSH   DE 
1342			 
1342 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1343 be			    CP     (HL)            ; (want to minimize work). 
1344 38 01		    JR     C, Str1IsBigger 
1346 7e			    LD     A, (HL) 
1347			 
1347			Str1IsBigger: 
1347 4f			    LD     C, A             ; Put length in BC 
1348 06 00		    LD     B, 0 
134a 13			    INC    DE              ; Increment pointers to meat of string. 
134b 23			    INC    HL 
134c			 
134c			CmpLoop: 
134c 1a			    LD     A, (DE)          ; Compare bytes. 
134d ed a1		    CPI 
134f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1351 13			    INC    DE              ; Update pointer. 
1352 ea 4c 13		    JP     PE, CmpLoop 
1355			 
1355 d1			    POP    DE 
1356 e1			    POP    HL 
1357 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1358 be			    CP     (HL) 
1359 c9			    RET 
135a			 
135a			NoMatch: 
135a 2b			    DEC    HL 
135b be			    CP     (HL)            ; Compare again to affect carry. 
135c d1			    POP    DE 
135d e1			    POP    HL 
135e c9			    RET 
135f			 
135f			;; test strmp 
135f			; 
135f			;ld de, .str1 
135f			;ld hl, .str2 
135f			;call strcmp 
135f			;jr z, .z1 
135f			;;this 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "NZ1" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			;.z1: 
135f			; 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "ZZ1" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			; 
135f			;ld de, .str1 
135f			;ld hl, .str1 
135f			;call strcmp 
135f			;jr z, .z2 
135f			;;this 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "NZ2" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			;.z2: 
135f			; 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "ZZ2" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			; 
135f			;ld de, .str1 
135f			;ld hl, .str2 
135f			;call strcmp 
135f			;jr c, .c1 
135f			; 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "Nc1" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			;.c1: 
135f			;;this 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "cc1" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			; 
135f			;ld de, .str1 
135f			;ld hl, .str1 
135f			;call strcmp 
135f			;jr c, .c2 
135f			;;this 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "Nc2" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			;.c2: 
135f			; 
135f			;	if DEBUG_FORTH_WORDS 
135f			;		DMARK "cc2" 
135f			;		CALLMONITOR 
135f			;	endif 
135f			;	NEXTW 
135f			;.str1:   db "string1",0 
135f			;.str2:   db "string2",0 
135f			 
135f			; only care about direct match or not 
135f			; hl and de strings 
135f			; zero set if the same 
135f			 
135f			strcmp: 
135f 1a				ld a, (de) 
1360 be				cp (hl) 
1361 28 02			jr z, .ssame 
1363 b7				or a 
1364 c9				ret 
1365			 
1365			.ssame:  
1365 fe 00			cp 0 
1367 c8				ret z 
1368			 
1368 23				inc hl 
1369 13				inc de 
136a 18 f3			jr strcmp 
136c				 
136c				 
136c			 
136c			 
136c			 
136c			 
136c			; eof 
136c			 
136c			 
136c			 
136c			 
136c			 
136c			 
# End of file firmware_strings.asm
136c			include "firmware_memory.asm"   ; malloc and free  
136c			 
136c			if DEBUG_FORTH_MALLOC_HIGH 
136c			.mallocsize: db "Wants malloc >256",0 
136c			.mallocasize: db "MALLOC gives >256",0 
136c			.malloczero: db "MALLOC gives zero",0 
136c			 
136c			malloc_guard_zerolen: 
136c				push hl 
136c				push de 
136c				push af 
136c			 
136c				ld de, 0 
136c			        call cmp16 
136c				jr nz, .lowalloz 
136c			 
136c				push hl 
136c				push de 
136c					ld hl, display_fb0 
136c					ld (display_fb_active), hl 
136c				call clear_display 
136c				ld a, 0 
136c				ld de, .malloczero 
136c				call str_at_display 
136c				call update_display 
136c				call delay1s 
136c				call delay1s 
136c				ld a, 0 
136c				ld (os_view_disable), a 
136c			 
136c				pop de 
136c				pop hl 
136c			 
136c				 
136c			 
136c				CALLMONITOR 
136c			.lowalloz: 
136c			 
136c			 
136c				pop af 
136c				pop de 
136c				pop hl 
136c			ret 
136c			 
136c			malloc_guard_entry: 
136c				push hl 
136c				push de 
136c				push af 
136c			 
136c			 	or a      ;clear carry flag 
136c				push hl 
136c				ld de, 255 
136c				sbc hl, de 
136c				jr c, .lowalloc 
136c			 
136c				push de 
136c					ld hl, display_fb0 
136c					ld (display_fb_active), hl 
136c				call clear_display 
136c				ld a, 0 
136c				ld de, .mallocsize 
136c				call str_at_display 
136c				call update_display 
136c				call delay1s 
136c				call delay1s 
136c				ld a, 0 
136c				ld (os_view_disable), a 
136c			 
136c				pop de 
136c				pop hl 
136c			 
136c				 
136c			 
136c				CALLMONITOR 
136c				jr .lowdone 
136c			.lowalloc: 
136c			 
136c			 
136c				pop hl 
136c			.lowdone:	pop af 
136c				pop de 
136c				pop hl 
136c			ret 
136c			 
136c			malloc_guard_exit: 
136c				push hl 
136c				push de 
136c				push af 
136c			 
136c			 	or a      ;clear carry flag 
136c				push hl 
136c				ld de, 255 
136c				sbc hl, de 
136c				jr c, .lowallocx 
136c			 
136c				push de 
136c					ld hl, display_fb0 
136c					ld (display_fb_active), hl 
136c				call clear_display 
136c				ld a, 0 
136c				ld de, .mallocasize 
136c				call str_at_display 
136c				call update_display 
136c				call delay1s 
136c				call delay1s 
136c				ld a, 0 
136c				ld (os_view_disable), a 
136c				pop de 
136c				pop hl 
136c			 
136c				CALLMONITOR 
136c				jr .lowdonex 
136c			.lowallocx: 
136c			 
136c				pop hl 
136c			.lowdonex:	pop af 
136c				pop de 
136c				pop hl 
136c			ret 
136c			endif 
136c			 
136c			if MALLOC_2 
136c			; Z80 Malloc and Free Functions 
136c			 
136c			; Malloc Function: 
136c			; Input: 
136c			;   HL: Size of block to allocate 
136c			; Output: 
136c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
136c			 
136c			malloc: 
136c				 
136c			if DEBUG_FORTH_MALLOC_HIGH 
136c			call malloc_guard_entry 
136c			endif 
136c			 
136c			 
136c			 
136c			 
136c					if DEBUG_FORTH_MALLOC 
136c						DMARK "mal" 
136c						CALLMONITOR 
136c					endif 
136c			    push af            ; Save AF register 
136c			    ld a, l            ; Load low byte of size into A 
136c			    or h               ; Check if size is zero 
136c			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
136c			 
136c			    ; Allocate memory 
136c			    ld hl, (heap_start) ; Load start of heap into HL 
136c					if DEBUG_FORTH_MALLOC 
136c						DMARK "ma1" 
136c						CALLMONITOR 
136c					endif 
136c			    call malloc_internal ; Call internal malloc function 
136c			    pop af             ; Restore AF register 
136c			if DEBUG_FORTH_MALLOC_HIGH 
136c			call malloc_guard_exit 
136c			call malloc_guard_zerolen 
136c			endif 
136c			    ret                ; Return 
136c			 
136c			; Free Function: 
136c			; Input: 
136c			;   HL: Pointer to memory block to free 
136c			; Output: 
136c			;   None 
136c			 
136c			free: 
136c			    push af            ; Save AF register 
136c			    ld a, l            ; Load low byte of pointer into A 
136c			    or h               ; Check if pointer is NULL 
136c			    jp z, free_exit    ; If pointer is NULL, exit 
136c			 
136c			    ; Free memory 
136c			    ld hl, (heap_start) ; Load start of heap into HL 
136c			    call free_internal  ; Call internal free function 
136c			    pop af             ; Restore AF register 
136c			    ret                ; Return 
136c			 
136c			; Internal Malloc Function: 
136c			; Input: 
136c			;   HL: Size of block to allocate 
136c			; Output: 
136c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
136c			 
136c			malloc_internal: 
136c			    ld bc, 2           ; Number of bytes to allocate for management overhead 
136c			    add hl, bc         ; Add management overhead to requested size 
136c			    ex de, hl          ; Save total size in DE, and keep it in HL 
136c					if DEBUG_FORTH_MALLOC 
136c						DMARK "ma2" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c			    ; Search for free memory block 
136c			    ld de, (heap_end)  ; Load end of heap into DE 
136c			    ld bc, 0           ; Initialize counter 
136c			 
136c					if DEBUG_FORTH_MALLOC 
136c						DMARK "ma2" 
136c						CALLMONITOR 
136c					endif 
136c			malloc_search_loop: 
136c			    ; Check if current block is free 
136c			    ld a, (hl)         ; Load current block's status (free or used) 
136c			    cp 0               ; Compare with zero (free) 
136c			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
136c			 
136c			    ; Check if current block is large enough 
136c			    ld a, (hl+1)       ; Load high byte of block size 
136c			    cp l               ; Compare with low byte of requested size 
136c			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
136c			 
136c			    ld a, (hl+2)       ; Load low byte of block size 
136c			    cp h               ; Compare with high byte of requested size 
136c			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
136c			 
136c			    ; Mark block as used 
136c			    ld (hl), 0xFF      ; Set status byte to indicate used block 
136c			 
136c			    ; Calculate remaining space in block 
136c			    ld bc, 0           ; Clear BC 
136c			    add hl, bc         ; Increment HL to point to start of data block 
136c			    add hl, de         ; HL = HL + DE (total size) 
136c			    ld bc, 1           ; Number of bytes to allocate for management overhead 
136c			    add hl, bc         ; Add management overhead to start of data block 
136c			 
136c			    ; Save pointer to allocated block in HL 
136c			if DEBUG_FORTH_MALLOC_HIGH 
136c						DMARK "ma5" 
136c			call malloc_guard_exit 
136c			call malloc_guard_zerolen 
136c			endif 
136c			    ret 
136c			 
136c			malloc_skip_block_check: 
136c			    ; Move to the next block 
136c			    ld bc, 3           ; Size of management overhead 
136c			    add hl, bc         ; Move to the next block 
136c			    inc de             ; Increment counter 
136c			 
136c			    ; Check if we have reached the end of heap 
136c			    ld a, e            ; Load low byte of heap end address 
136c			    cp (hl)            ; Compare with low byte of current address 
136c			    jr nz, malloc_search_loop  ; If not equal, continue searching 
136c			    ld a, d            ; Load high byte of heap end address 
136c			    cp 0               ; Check if it's zero (end of memory) 
136c			    jr nz, malloc_search_loop  ; If not zero, continue searching 
136c			 
136c			    ; If we reached here, allocation failed 
136c			    xor a              ; Set result to NULL 
136c			if DEBUG_FORTH_MALLOC_HIGH 
136c						DMARK "ma6" 
136c			call malloc_guard_exit 
136c			call malloc_guard_zerolen 
136c			endif 
136c			    ret 
136c			malloc_exit: 
136c			if DEBUG_FORTH_MALLOC_HIGH 
136c						DMARK "ma7" 
136c			call malloc_guard_exit 
136c			call malloc_guard_zerolen 
136c			endif 
136c			    ret 
136c			 
136c			; Internal Free Function: 
136c			; Input: 
136c			;   HL: Pointer to memory block to free 
136c			; Output: 
136c			;   None 
136c			 
136c			free_internal: 
136c			    ld de, (heap_start) ; Load start of heap into DE 
136c			    ld bc, 0            ; Initialize counter 
136c			 
136c			free_search_loop: 
136c			    ; Check if current block contains the pointer 
136c			    ld a, l             ; Load low byte of pointer 
136c			    cp (hl+1)           ; Compare with high byte of current block's address 
136c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
136c			    ld a, h             ; Load high byte of pointer 
136c			    cp (hl+2)           ; Compare with low byte of current block's address 
136c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
136c			 
136c			    ; Mark block as free 
136c			    ld (hl), 0          ; Set status byte to indicate free block 
136c			    ret                 ; Return 
136c			 
136c			free_skip_block_check: 
136c			    ; Move to the next block 
136c			    ld bc, 3            ; Size of management overhead 
136c			    add hl, bc          ; Move to the next block 
136c			    inc de              ; Increment counter 
136c			 
136c			    ; Check if we have reached the end of heap 
136c			    ld a, e             ; Load low byte of heap end address 
136c			    cp (hl)             ; Compare with low byte of current address 
136c			    jr nz, free_search_loop  ; If not equal, continue searching 
136c			    ld a, d             ; Load high byte of heap end address 
136c			    cp 0                ; Check if it's zero (end of memory) 
136c			    jr nz, free_search_loop  ; If not zero, continue searching 
136c			 
136c			    ; If we reached here, pointer is not found in heap 
136c			    ret 
136c			 
136c			free_exit: 
136c			    ret                 ; Return 
136c			 
136c			; Define heap start and end addresses 
136c			;heap_start:    .dw 0xC000   ; Start of heap 
136c			;heap_end:      .dw 0xE000   ; End of heap 
136c			 
136c			endif 
136c			 
136c			 
136c			if MALLOC_1 
136c			 
136c			 
136c			 
136c			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
136c			 
136c			;moved to firmware.asm 
136c			;heap_start        .equ  0x9000      ; Starting address of heap 
136c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
136c			 
136c			;      .org 0 
136c			;      jp    main 
136c			 
136c			 
136c			;      .org  0x100 
136c			;main: 
136c			;      ld    HL, 0x8100 
136c			;      ld    SP, HL 
136c			; 
136c			;      call  heap_init 
136c			; 
136c			;      ; Make some allocations 
136c			;      ld    HL, 12 
136c			;      call  malloc            ; Allocates 0x9004 
136c			; 
136c			;      ld    HL, 12 
136c			;      call  malloc            ; Allocates 0x9014 
136c			; 
136c			;      ld    HL, 12 
136c			;      call  malloc            ; Allocates 0x9024 
136c			; 
136c			;      ; Free some allocations 
136c			;      ld    HL, 0x9014 
136c			;      call  free 
136c			; 
136c			;      ld    HL, 0x9004 
136c			;      call  free 
136c			; 
136c			;      ld    HL, 0x9024 
136c			;      call  free 
136c			; 
136c			; 
136c			;      halt 
136c			 
136c			 
136c			;------------------------------------------------------------------------------ 
136c			;     heap_init                                                               : 
136c			;                                                                             : 
136c			; Description                                                                 : 
136c			;     Initialise the heap and make it ready for malloc and free operations.   : 
136c			;                                                                             : 
136c			;     The heap is maintained as a linked list, starting with an initial       : 
136c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
136c			;     the first free block in the heap. Each block then points to the next    : 
136c			;     free block within the heap, and the free list ends at the first block   : 
136c			;     with a null pointer to the next free block.                             : 
136c			;                                                                             : 
136c			; Parameters                                                                  : 
136c			;     Inputs are compile-time only. Two defines which specify the starting    : 
136c			;     address of the heap and its size are required, along with a memory      : 
136c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
136c			;     principally stores a pointer to the first free block in the heap.       : 
136c			;                                                                             : 
136c			; Returns                                                                     : 
136c			;     Nothing                                                                 : 
136c			;------------------------------------------------------------------------------ 
136c			heap_init: 
136c e5			      push  HL 
136d			 
136d			      ; Initialise free list struct 
136d 21 0e 80		      ld    HL, heap_start 
1370 22 0a 80		      ld    (free_list), HL 
1373 21 00 00		      ld    HL, 0 
1376 22 0c 80		      ld    (free_list+2), HL 
1379			 
1379			      ; Insert first free block at bottom of heap, consumes entire heap 
1379 21 0a 80		      ld    HL, heap_start+heap_size-4 
137c 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
137f 21 fc ff		      ld    HL, heap_size-4 
1382 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1385			 
1385			      ; Insert end of free list block at top of heap - two null words will 
1385			      ; terminate the free list 
1385 21 00 00		      ld    HL, 0 
1388 22 0c 80		      ld    (heap_start+heap_size-2), HL 
138b 22 0a 80		      ld    (heap_start+heap_size-4), HL 
138e			 
138e e1			      pop   HL 
138f			 
138f c9			      ret 
1390			 
1390			 
1390			;------------------------------------------------------------------------------ 
1390			;     malloc                                                                  : 
1390			;                                                                             : 
1390			; Description                                                                 : 
1390			;     Allocates the wanted space from the heap and returns the address of the : 
1390			;     first useable byte of the allocation.                                   : 
1390			;                                                                             : 
1390			;     Allocations can happen in one of two ways:                              : 
1390			;                                                                             : 
1390			;     1. A free block may be found which is the exact size wanted. In this    : 
1390			;        case the block is removed from the free list and retuedn to the      : 
1390			;        caller.                                                              : 
1390			;     2. A free block may be found which is larger than the size wanted. In   : 
1390			;        this case, the larger block is split into two. The first portion of  : 
1390			;        this block will become the requested space by the malloc call and    : 
1390			;        is returned to the caller. The second portion becomes a new free     : 
1390			;        block, and the free list is adjusted to maintain continuity via this : 
1390			;        newly created block.                                                 : 
1390			;                                                                             : 
1390			;     malloc does not set any initial value in the allocated space, the       : 
1390			;     caller is required to do this as required.                              : 
1390			;                                                                             : 
1390			;     This implementation of malloc uses the stack exclusively, and is        : 
1390			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1390			;     advisable to disable interrupts before calling malloc, and recommended  : 
1390			;     to avoid the use of malloc inside ISRs in general.                      : 
1390			;                                                                             : 
1390			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1390			;                                                                             : 
1390			; Parameters                                                                  : 
1390			;     HL  Number of bytes wanted                                              : 
1390			;                                                                             : 
1390			; Returns                                                                     : 
1390			;     HL  Address of the first useable byte of the allocation                 : 
1390			;                                                                             : 
1390			; Flags                                                                       : 
1390			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1390			;                                                                             : 
1390			; Stack frame                                                                 : 
1390			;       |             |                                                       : 
1390			;       +-------------+                                                       : 
1390			;       |     BC      |                                                       : 
1390			;       +-------------+                                                       : 
1390			;       |     DE      |                                                       : 
1390			;       +-------------+                                                       : 
1390			;       |     IX      |                                                       : 
1390			;       +-------------+                                                       : 
1390			;       |  prev_free  |                                                       : 
1390			;   +4  +-------------+                                                       : 
1390			;       |  this_free  |                                                       : 
1390			;   +2  +-------------+                                                       : 
1390			;       |  next_free  |                                                       : 
1390			;   +0  +-------------+                                                       : 
1390			;       |             |                                                       : 
1390			;                                                                             : 
1390			;------------------------------------------------------------------------------ 
1390			 
1390			 
1390			;malloc: 
1390			; 
1390			;	SAVESP ON 1 
1390			; 
1390			;	call malloc_code 
1390			; 
1390			;	CHECKSP ON 1 
1390			;	ret 
1390			 
1390			 
1390			malloc: 
1390 c5			      push  BC 
1391 d5			      push  DE 
1392 dd e5		      push  IX 
1394			if DEBUG_FORTH_MALLOC_HIGH 
1394			call malloc_guard_entry 
1394			endif 
1394			 
1394					if DEBUG_FORTH_MALLOC 
1394						DMARK "mal" 
1394						CALLMONITOR 
1394					endif 
1394 7c			      ld    A, H                    ; Exit if no space requested 
1395 b5			      or    L 
1396 ca 55 14		      jp    Z, malloc_early_exit 
1399			 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			; 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			;inc hl 
1399			 
1399			 
1399			 
1399			 
1399					if DEBUG_FORTH_MALLOC 
1399						DMARK "maA" 
1399						CALLMONITOR 
1399					endif 
1399			      ; Set up stack frame 
1399 eb			      ex    DE, HL 
139a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
139d 39			      add   HL, SP 
139e f9			      ld    SP, HL 
139f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13a3 dd 39		      add   IX, SP 
13a5			 
13a5			      ; Setup initial state 
13a5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13a8 19			      add   HL, DE 
13a9			 
13a9 44			      ld    B, H                    ; Move want to BC 
13aa 4d			      ld    C, L 
13ab			 
13ab 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13ae dd 75 04		      ld    (IX+4), L 
13b1 dd 74 05		      ld    (IX+5), H 
13b4			 
13b4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13b5 23			      inc   HL 
13b6 56			      ld    D, (HL) 
13b7 dd 73 02		      ld    (IX+2), E 
13ba dd 72 03		      ld    (IX+3), D 
13bd eb			      ex    DE, HL                  ; this_free ptr into HL 
13be			 
13be					if DEBUG_FORTH_MALLOC 
13be						DMARK "maB" 
13be						CALLMONITOR 
13be					endif 
13be			      ; Loop through free block list to find some space 
13be			malloc_find_space: 
13be 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13bf 23			      inc   HL 
13c0 56			      ld    D, (HL) 
13c1			 
13c1 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13c2 b3			      or    E 
13c3 ca 4f 14		      jp    Z, malloc_no_space 
13c6			 
13c6 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13c9 dd 72 01		      ld    (IX+1), D 
13cc			 
13cc			      ; Does this block have enough space to make the allocation? 
13cc 23			      inc   HL                      ; Load free block size into DE 
13cd 5e			      ld    E, (HL) 
13ce 23			      inc   HL 
13cf 56			      ld    D, (HL) 
13d0			 
13d0 eb			      ex    DE, HL                  ; Check size of block against want 
13d1 b7			      or    A                       ; Ensure carry flag clear 
13d2 ed 42		      sbc   HL, BC 
13d4 e5			      push  HL                      ; Store the result for later (new block size) 
13d5			 
13d5 ca 24 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13d8 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13da			 
13da			      ; this_free block is not big enough, setup ptrs to test next free block 
13da e1			      pop   HL                      ; Discard previous result 
13db			 
13db dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13de dd 66 03		      ld    H, (IX+3) 
13e1 dd 75 04		      ld    (IX+4), L 
13e4 dd 74 05		      ld    (IX+5), H 
13e7			 
13e7 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13ea dd 66 01		      ld    H, (IX+1) 
13ed dd 75 02		      ld    (IX+2), L 
13f0 dd 74 03		      ld    (IX+3), H 
13f3			 
13f3					if DEBUG_FORTH_MALLOC 
13f3						DMARK "MA>" 
13f3						CALLMONITOR 
13f3					endif 
13f3 18 c9		      jr    malloc_find_space 
13f5			 
13f5			      ; split a bigger block into two - requested size and remaining size 
13f5			malloc_alloc_split: 
13f5					if DEBUG_FORTH_MALLOC 
13f5						DMARK "MAs" 
13f5						CALLMONITOR 
13f5					endif 
13f5 eb			      ex    DE, HL                  ; Calculate address of new free block 
13f6 2b			      dec   HL 
13f7 2b			      dec   HL 
13f8 2b			      dec   HL 
13f9 09			      add   HL, BC 
13fa			 
13fa			      ; Create a new block and point it at next_free 
13fa dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
13fd dd 56 01		      ld    D, (IX+1) 
1400			 
1400 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1401 23			      inc   HL 
1402 72			      ld    (HL), D 
1403			 
1403 d1			      pop   DE                      ; Store size of new block into new block 
1404 23			      inc   HL 
1405 73			      ld    (HL), E 
1406 23			      inc   HL 
1407 72			      ld    (HL), D 
1408			 
1408			      ; Update this_free ptr to point to new block 
1408 2b			      dec   HL 
1409 2b			      dec   HL 
140a 2b			      dec   HL 
140b			 
140b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
140e dd 56 03		      ld    D, (IX+3) 
1411			 
1411 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1414 dd 74 03		      ld    (IX+3), H 
1417			 
1417			      ; Modify this_free block to be allocation 
1417 eb			      ex    DE, HL 
1418 af			      xor   A                       ; Null the next block ptr of allocated block 
1419 77			      ld    (HL), A 
141a 23			      inc   HL 
141b 77			      ld    (HL), A 
141c			 
141c 23			      inc   HL                      ; Store want size into allocated block 
141d 71			      ld    (HL), C 
141e 23			      inc   HL 
141f 70			      ld    (HL), B 
1420 23			      inc   HL 
1421 e5			      push  HL                      ; Address of allocation to return 
1422			 
1422 18 19		      jr    malloc_update_links 
1424			 
1424			malloc_alloc_fit: 
1424 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1425			 
1425					if DEBUG_FORTH_MALLOC 
1425						DMARK "MAf" 
1425						CALLMONITOR 
1425					endif 
1425			      ; Modify this_free block to be allocation 
1425 eb			      ex    DE, HL 
1426 2b			      dec   HL 
1427 2b			      dec   HL 
1428 2b			      dec   HL 
1429			 
1429 af			      xor   A                       ; Null the next block ptr of allocated block 
142a 77			      ld    (HL), A 
142b 23			      inc   HL 
142c 77			      ld    (HL), A 
142d			 
142d 23			      inc   HL                      ; Store address of allocation to return 
142e 23			      inc   HL 
142f 23			      inc   HL 
1430 e5			      push  HL 
1431			 
1431			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1431 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1434 dd 66 01		      ld    H, (IX+1) 
1437			 
1437 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
143a dd 74 03		      ld    (IX+3), H 
143d			 
143d			 
143d			malloc_update_links: 
143d			      ; Update prev_free ptr to point to this_free 
143d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1440 dd 66 05		      ld    H, (IX+5) 
1443			 
1443 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1446 dd 56 03		      ld    D, (IX+3) 
1449			 
1449 73			      ld    (HL), E                 ; this_free ptr into prev_free 
144a 23			      inc   HL 
144b 72			      ld    (HL), D 
144c			 
144c					if DEBUG_FORTH_MALLOC 
144c						DMARK "Mul" 
144c						CALLMONITOR 
144c					endif 
144c			      ; Clear the Z flag to indicate successful allocation 
144c 7a			      ld    A, D 
144d b3			      or    E 
144e			 
144e d1			      pop   DE                      ; Address of allocation 
144f					if DEBUG_FORTH_MALLOC 
144f						DMARK "MAu" 
144f						CALLMONITOR 
144f					endif 
144f			 
144f			malloc_no_space: 
144f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1452 39			      add   HL, SP 
1453 f9			      ld    SP, HL 
1454			 
1454 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1455					if DEBUG_FORTH_MALLOC 
1455						DMARK "MAN" 
1455						CALLMONITOR 
1455					endif 
1455			 
1455			malloc_early_exit: 
1455					if DEBUG_FORTH_MALLOC 
1455						DMARK "MAx" 
1455						CALLMONITOR 
1455					endif 
1455 dd e1		      pop   IX 
1457 d1			      pop   DE 
1458 c1			      pop   BC 
1459			 
1459			if DEBUG_FORTH_MALLOC_HIGH 
1459			call malloc_guard_exit 
1459			call malloc_guard_zerolen 
1459			endif 
1459 c9			      ret 
145a			 
145a			 
145a			;------------------------------------------------------------------------------ 
145a			;     free                                                                    : 
145a			;                                                                             : 
145a			; Description                                                                 : 
145a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
145a			;     returned by malloc, otherwise the behaviour is undefined.               : 
145a			;                                                                             : 
145a			;     Where possible, directly adjacent free blocks will be merged together   : 
145a			;     into larger blocks to help ensure that the heap does not become         : 
145a			;     excessively fragmented.                                                 : 
145a			;                                                                             : 
145a			;     free does not clear or set any other value into the freed space, and    : 
145a			;     therefore its contents may be visible through subsequent malloc's. The  : 
145a			;     caller should clear the freed space as required.                        : 
145a			;                                                                             : 
145a			;     This implementation of free uses the stack exclusively, and is          : 
145a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
145a			;     advisable to disable interrupts before calling free, and recommended    : 
145a			;     to avoid the use of free inside ISRs in general.                        : 
145a			;                                                                             : 
145a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
145a			;                                                                             : 
145a			; Parameters                                                                  : 
145a			;     HL  Pointer to address of first byte of allocation to be freed          : 
145a			;                                                                             : 
145a			; Returns                                                                     : 
145a			;     Nothing                                                                 : 
145a			;                                                                             : 
145a			; Stack frame                                                                 : 
145a			;       |             |                                                       : 
145a			;       +-------------+                                                       : 
145a			;       |     BC      |                                                       : 
145a			;       +-------------+                                                       : 
145a			;       |     DE      |                                                       : 
145a			;       +-------------+                                                       : 
145a			;       |     IX      |                                                       : 
145a			;       +-------------+                                                       : 
145a			;       |  prev_free  |                                                       : 
145a			;   +2  +-------------+                                                       : 
145a			;       |  next_free  |                                                       : 
145a			;   +0  +-------------+                                                       : 
145a			;       |             |                                                       : 
145a			;                                                                             : 
145a			;------------------------------------------------------------------------------ 
145a			free: 
145a c5			      push  BC 
145b d5			      push  DE 
145c dd e5		      push  IX 
145e			 
145e 7c			      ld    A, H                    ; Exit if ptr is null 
145f b5			      or    L 
1460 ca 24 15		      jp    Z, free_early_exit 
1463			 
1463			      ; Set up stack frame 
1463 eb			      ex    DE, HL 
1464 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1467 39			      add   HL, SP 
1468 f9			      ld    SP, HL 
1469 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
146d dd 39		      add   IX, SP 
146f			 
146f			      ; The address in HL points to the start of the useable allocated space, 
146f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
146f			      ; address of the block itself. 
146f eb			      ex    DE, HL 
1470 11 fc ff		      ld    DE, -4 
1473 19			      add   HL, DE 
1474			 
1474			      ; An allocated block must have a null next block pointer in it 
1474 7e			      ld    A, (HL) 
1475 23			      inc   HL 
1476 b6			      or    (HL) 
1477 c2 1f 15		      jp    NZ, free_done 
147a			 
147a 2b			      dec   HL 
147b			 
147b 44			      ld    B, H                    ; Copy HL to BC 
147c 4d			      ld    C, L 
147d			 
147d			      ; Loop through the free list to find the first block with an address 
147d			      ; higher than the block being freed 
147d 21 0a 80		      ld    HL, free_list 
1480			 
1480			free_find_higher_block: 
1480 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1481 23			      inc   HL 
1482 56			      ld    D, (HL) 
1483 2b			      dec   HL 
1484			 
1484 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1487 dd 72 01		      ld    (IX+1), D 
148a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
148d dd 74 03		      ld    (IX+3), H 
1490			 
1490 78			      ld    A, B                    ; Check if DE is greater than BC 
1491 ba			      cp    D                       ; Compare MSB first 
1492 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1494 30 04		      jr    NC, free_find_higher_block_skip 
1496 79			      ld    A, C 
1497 bb			      cp    E                       ; Then compare LSB 
1498 38 08		      jr    C, free_found_higher_block 
149a			 
149a			free_find_higher_block_skip: 
149a 7a			      ld    A, D                    ; Reached the end of the free list? 
149b b3			      or    E 
149c ca 1f 15		      jp    Z, free_done 
149f			 
149f eb			      ex    DE, HL 
14a0			 
14a0 18 de		      jr    free_find_higher_block 
14a2			 
14a2			free_found_higher_block: 
14a2			      ; Insert freed block between prev and next free blocks 
14a2 71			      ld    (HL), C                 ; Point prev free block to freed block 
14a3 23			      inc   HL 
14a4 70			      ld    (HL), B 
14a5			 
14a5 60			      ld    H, B                    ; Point freed block at next free block 
14a6 69			      ld    L, C 
14a7 73			      ld    (HL), E 
14a8 23			      inc   HL 
14a9 72			      ld    (HL), D 
14aa			 
14aa			      ; Check if the freed block is adjacent to the next free block 
14aa 23			      inc   HL                      ; Load size of freed block into HL 
14ab 5e			      ld    E, (HL) 
14ac 23			      inc   HL 
14ad 56			      ld    D, (HL) 
14ae eb			      ex    DE, HL 
14af			 
14af 09			      add   HL, BC                  ; Add addr of freed block and its size 
14b0			 
14b0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14b3 dd 56 01		      ld    D, (IX+1) 
14b6			 
14b6 b7			      or    A                       ; Clear the carry flag 
14b7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14b9 20 22		      jr    NZ, free_check_adjacent_to_prev 
14bb			 
14bb			      ; Freed block is adjacent to next, merge into one bigger block 
14bb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14bc 5e			      ld    E, (HL) 
14bd 23			      inc   HL 
14be 56			      ld    D, (HL) 
14bf e5			      push  HL                      ; Save ptr to next block for later 
14c0			 
14c0 60			      ld    H, B                    ; Store ptr from next block into freed block 
14c1 69			      ld    L, C 
14c2 73			      ld    (HL), E 
14c3 23			      inc   HL 
14c4 72			      ld    (HL), D 
14c5			 
14c5 e1			      pop   HL                      ; Restore ptr to next block 
14c6 23			      inc   HL                      ; Load size of next block into DE 
14c7 5e			      ld    E, (HL) 
14c8 23			      inc   HL 
14c9 56			      ld    D, (HL) 
14ca d5			      push  DE                      ; Save next block size for later 
14cb			 
14cb 60			      ld    H, B                    ; Load size of freed block into HL 
14cc 69			      ld    L, C 
14cd 23			      inc   HL 
14ce 23			      inc   HL 
14cf 5e			      ld    E, (HL) 
14d0 23			      inc   HL 
14d1 56			      ld    D, (HL) 
14d2 eb			      ex    DE, HL 
14d3			 
14d3 d1			      pop   DE                      ; Restore size of next block 
14d4 19			      add   HL, DE                  ; Add sizes of both blocks 
14d5 eb			      ex    DE, HL 
14d6			 
14d6 60			      ld    H, B                    ; Store new bigger size into freed block 
14d7 69			      ld    L, C 
14d8 23			      inc   HL 
14d9 23			      inc   HL 
14da 73			      ld    (HL), E 
14db 23			      inc   HL 
14dc 72			      ld    (HL), D 
14dd			 
14dd			free_check_adjacent_to_prev: 
14dd			      ; Check if the freed block is adjacent to the prev free block 
14dd dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14e0 dd 66 03		      ld    H, (IX+3) 
14e3			 
14e3 23			      inc   HL                      ; Size of prev free block into DE 
14e4 23			      inc   HL 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 2b			      dec   HL 
14e9 2b			      dec   HL 
14ea 2b			      dec   HL 
14eb			 
14eb 19			      add   HL, DE                  ; Add prev block addr and size 
14ec			 
14ec b7			      or    A                       ; Clear the carry flag 
14ed ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
14ef 20 2e		      jr    NZ, free_done 
14f1			 
14f1			      ; Freed block is adjacent to prev, merge into one bigger block 
14f1 60			      ld    H, B                    ; Load next ptr from freed block into DE 
14f2 69			      ld    L, C 
14f3 5e			      ld    E, (HL) 
14f4 23			      inc   HL 
14f5 56			      ld    D, (HL) 
14f6 e5			      push  HL                      ; Save freed block ptr for later 
14f7			 
14f7 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
14fa dd 66 03		      ld    H, (IX+3) 
14fd 73			      ld    (HL), E 
14fe 23			      inc   HL 
14ff 72			      ld    (HL), D 
1500			 
1500 e1			      pop   HL                      ; Restore freed block ptr 
1501 23			      inc   HL                      ; Load size of freed block into DE 
1502 5e			      ld    E, (HL) 
1503 23			      inc   HL 
1504 56			      ld    D, (HL) 
1505 d5			      push  DE                      ; Save freed block size for later 
1506			 
1506 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1509 dd 66 03		      ld    H, (IX+3) 
150c 23			      inc   HL 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511			 
1511 e1			      pop   HL                      ; Add sizes of both blocks 
1512 19			      add   HL, DE 
1513 eb			      ex    DE, HL 
1514			 
1514 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1517 dd 66 03		      ld    H, (IX+3) 
151a 23			      inc   HL 
151b 23			      inc   HL 
151c 73			      ld    (HL), E 
151d 23			      inc   HL 
151e 72			      ld    (HL), D 
151f			 
151f			free_done: 
151f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1522 39			      add   HL, SP 
1523 f9			      ld    SP, HL 
1524			 
1524			free_early_exit: 
1524 dd e1		      pop   IX 
1526 d1			      pop   DE 
1527 c1			      pop   BC 
1528			 
1528 c9			      ret 
1529			 
1529			; moved to firmware.asm 
1529			; 
1529			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1529			;                  .dw   0 
1529			 
1529			 
1529			endif 
1529			 
1529			 
1529			if MALLOC_3 
1529			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1529			;heap_start        .equ  0x9000      ; Starting address of heap 
1529			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1529			; 
1529			 ;     .org 0 
1529			  ;    jp    main 
1529			; 
1529			; 
1529			 ;     .org  0x100 
1529			;main: 
1529			 ;     ld    HL, 0x8100 
1529			  ;    ld    SP, HL 
1529			; 
1529			;      call  heap_init 
1529			 
1529			      ; Make some allocations 
1529			;      ld    HL, 12 
1529			;      call  malloc            ; Allocates 0x9004 
1529			; 
1529			 ;     ld    HL, 12 
1529			;      call  malloc            ; Allocates 0x9014 
1529			 
1529			;      ld    HL, 12 
1529			;      call  malloc            ; Allocates 0x9024 
1529			 
1529			      ; Free some allocations 
1529			;      ld    HL, 0x9014 
1529			;      call  free 
1529			 
1529			;      ld    HL, 0x9004 
1529			;      call  free 
1529			; 
1529			;      ld    HL, 0x9024 
1529			;      call  free 
1529			 
1529			 
1529			 ;     halt 
1529			 
1529			 
1529			;------------------------------------------------------------------------------ 
1529			;     heap_init                                                               : 
1529			;                                                                             : 
1529			; Description                                                                 : 
1529			;     Initialise the heap and make it ready for malloc and free operations.   : 
1529			;                                                                             : 
1529			;     The heap is maintained as a linked list, starting with an initial       : 
1529			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1529			;     the first free block in the heap. Each block then points to the next    : 
1529			;     free block within the heap, and the free list ends at the first block   : 
1529			;     with a null pointer to the next free block.                             : 
1529			;                                                                             : 
1529			; Parameters                                                                  : 
1529			;     Inputs are compile-time only. Two defines which specify the starting    : 
1529			;     address of the heap and its size are required, along with a memory      : 
1529			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1529			;     principally stores a pointer to the first free block in the heap.       : 
1529			;                                                                             : 
1529			; Returns                                                                     : 
1529			;     Nothing                                                                 : 
1529			;------------------------------------------------------------------------------ 
1529			heap_init: 
1529			      push  HL 
1529			 
1529			      ; Initialise free list struct 
1529			      ld    HL, heap_start 
1529			      ld    (free_list), HL 
1529			      ld    HL, 0 
1529			      ld    (free_list+2), HL 
1529			 
1529			      ; Insert first free block at bottom of heap, consumes entire heap 
1529			      ld    HL, heap_start+heap_size-4 
1529			      ld    (heap_start), HL        ; Next block (end of free list) 
1529			      ld    HL, heap_size-4 
1529			      ld    (heap_start+2), HL      ; Block size 
1529			 
1529			      ; Insert end of free list block at top of heap - two null words will 
1529			      ; terminate the free list 
1529			      ld    HL, 0 
1529			      ld    (heap_start+heap_size-2), HL 
1529			      ld    (heap_start+heap_size-4), HL 
1529			 
1529			      pop   HL 
1529			 
1529			      ret 
1529			 
1529			 
1529			;------------------------------------------------------------------------------ 
1529			;     malloc                                                                  : 
1529			;                                                                             : 
1529			; Description                                                                 : 
1529			;     Allocates the wanted space from the heap and returns the address of the : 
1529			;     first useable byte of the allocation.                                   : 
1529			;                                                                             : 
1529			;     Allocations can happen in one of two ways:                              : 
1529			;                                                                             : 
1529			;     1. A free block may be found which is the exact size wanted. In this    : 
1529			;        case the block is removed from the free list and retuedn to the      : 
1529			;        caller.                                                              : 
1529			;     2. A free block may be found which is larger than the size wanted. In   : 
1529			;        this case, the larger block is split into two. The first portion of  : 
1529			;        this block will become the requested space by the malloc call and    : 
1529			;        is returned to the caller. The second portion becomes a new free     : 
1529			;        block, and the free list is adjusted to maintain continuity via this : 
1529			;        newly created block.                                                 : 
1529			;                                                                             : 
1529			;     malloc does not set any initial value in the allocated space, the       : 
1529			;     caller is required to do this as required.                              : 
1529			;                                                                             : 
1529			;     This implementation of malloc uses the stack exclusively, and is        : 
1529			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1529			;     advisable to disable interrupts before calling malloc, and recommended  : 
1529			;     to avoid the use of malloc inside ISRs in general.                      : 
1529			;                                                                             : 
1529			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1529			;                                                                             : 
1529			; Parameters                                                                  : 
1529			;     HL  Number of bytes wanted                                              : 
1529			;                                                                             : 
1529			; Returns                                                                     : 
1529			;     HL  Address of the first useable byte of the allocation                 : 
1529			;                                                                             : 
1529			; Flags                                                                       : 
1529			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1529			;                                                                             : 
1529			; Stack frame                                                                 : 
1529			;       |             |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |     BC      |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |     DE      |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |     IX      |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |  prev_free  |                                                       : 
1529			;   +4  +-------------+                                                       : 
1529			;       |  this_free  |                                                       : 
1529			;   +2  +-------------+                                                       : 
1529			;       |  next_free  |                                                       : 
1529			;   +0  +-------------+                                                       : 
1529			;       |             |                                                       : 
1529			;                                                                             : 
1529			;------------------------------------------------------------------------------ 
1529			malloc: 
1529			      push  BC 
1529			      push  DE 
1529			      push  IX 
1529			 
1529			      ld    A, H                    ; Exit if no space requested 
1529			      or    L 
1529			      jp    Z, malloc_early_exit 
1529			 
1529			      ; Set up stack frame 
1529			      ex    DE, HL 
1529			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1529			      add   HL, SP 
1529			      ld    SP, HL 
1529			      ld    IX, 0                   ; Use IX as a frame pointer 
1529			      add   IX, SP 
1529			 
1529			      ; Setup initial state 
1529			      ld    HL, 4                   ; want must also include space used by block struct 
1529			      add   HL, DE 
1529			 
1529			      ld    B, H                    ; Move want to BC 
1529			      ld    C, L 
1529			 
1529			      ld    HL, free_list           ; Store prev_free ptr to stack 
1529			      ld    (IX+4), L 
1529			      ld    (IX+5), H 
1529			 
1529			      ld    E, (HL)                 ; Store this_free ptr to stack 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      ld    (IX+2), E 
1529			      ld    (IX+3), D 
1529			      ex    DE, HL                  ; this_free ptr into HL 
1529			 
1529			      ; Loop through free block list to find some space 
1529			malloc_find_space: 
1529			      ld    E, (HL)                 ; Load next_free ptr into DE 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			 
1529			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1529			      or    E 
1529			      jp    Z, malloc_no_space 
1529			 
1529			      ld    (IX+0), E               ; Store next_free ptr to stack 
1529			      ld    (IX+1), D 
1529			 
1529			      ; Does this block have enough space to make the allocation? 
1529			      inc   HL                      ; Load free block size into DE 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			 
1529			      ex    DE, HL                  ; Check size of block against want 
1529			      or    A                       ; Ensure carry flag clear 
1529			      sbc   HL, BC 
1529			      push  HL                      ; Store the result for later (new block size) 
1529			 
1529			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1529			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1529			 
1529			      ; this_free block is not big enough, setup ptrs to test next free block 
1529			      pop   HL                      ; Discard previous result 
1529			 
1529			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1529			      ld    H, (IX+3) 
1529			      ld    (IX+4), L 
1529			      ld    (IX+5), H 
1529			 
1529			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1529			      ld    H, (IX+1) 
1529			      ld    (IX+2), L 
1529			      ld    (IX+3), H 
1529			 
1529			      jr    malloc_find_space 
1529			 
1529			      ; split a bigger block into two - requested size and remaining size 
1529			malloc_alloc_split: 
1529			      ex    DE, HL                  ; Calculate address of new free block 
1529			      dec   HL 
1529			      dec   HL 
1529			      dec   HL 
1529			      add   HL, BC 
1529			 
1529			      ; Create a new block and point it at next_free 
1529			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1529			      ld    D, (IX+1) 
1529			 
1529			      ld    (HL), E                 ; Store next_free ptr into new block 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			      pop   DE                      ; Store size of new block into new block 
1529			      inc   HL 
1529			      ld    (HL), E 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			      ; Update this_free ptr to point to new block 
1529			      dec   HL 
1529			      dec   HL 
1529			      dec   HL 
1529			 
1529			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1529			      ld    D, (IX+3) 
1529			 
1529			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1529			      ld    (IX+3), H 
1529			 
1529			      ; Modify this_free block to be allocation 
1529			      ex    DE, HL 
1529			      xor   A                       ; Null the next block ptr of allocated block 
1529			      ld    (HL), A 
1529			      inc   HL 
1529			      ld    (HL), A 
1529			 
1529			      inc   HL                      ; Store want size into allocated block 
1529			      ld    (HL), C 
1529			      inc   HL 
1529			      ld    (HL), B 
1529			      inc   HL 
1529			      push  HL                      ; Address of allocation to return 
1529			 
1529			      jr    malloc_update_links 
1529			 
1529			malloc_alloc_fit: 
1529			      pop   HL                      ; Dont need new block size, want is exact fit 
1529			 
1529			      ; Modify this_free block to be allocation 
1529			      ex    DE, HL 
1529			      dec   HL 
1529			      dec   HL 
1529			      dec   HL 
1529			 
1529			      xor   A                       ; Null the next block ptr of allocated block 
1529			      ld    (HL), A 
1529			      inc   HL 
1529			      ld    (HL), A 
1529			 
1529			      inc   HL                      ; Store address of allocation to return 
1529			      inc   HL 
1529			      inc   HL 
1529			      push  HL 
1529			 
1529			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1529			      ld    L, (IX+0)               ; next_free to HL 
1529			      ld    H, (IX+1) 
1529			 
1529			      ld    (IX+2), L               ; HL to this_free 
1529			      ld    (IX+3), H 
1529			 
1529			 
1529			malloc_update_links: 
1529			      ; Update prev_free ptr to point to this_free 
1529			      ld    L, (IX+4)               ; prev_free ptr to HL 
1529			      ld    H, (IX+5) 
1529			 
1529			      ld    E, (IX+2)               ; this_free ptr to DE 
1529			      ld    D, (IX+3) 
1529			 
1529			      ld    (HL), E                 ; this_free ptr into prev_free 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			      ; Clear the Z flag to indicate successful allocation 
1529			      ld    A, D 
1529			      or    E 
1529			 
1529			      pop   DE                      ; Address of allocation 
1529			 
1529			malloc_no_space: 
1529			      ld    HL, 6                   ; Clean up stack frame 
1529			      add   HL, SP 
1529			      ld    SP, HL 
1529			 
1529			      ex    DE, HL                  ; Alloc addr into HL for return 
1529			 
1529			malloc_early_exit: 
1529			      pop   IX 
1529			      pop   DE 
1529			      pop   BC 
1529			 
1529			      ret 
1529			 
1529			 
1529			;------------------------------------------------------------------------------ 
1529			;     free                                                                    : 
1529			;                                                                             : 
1529			; Description                                                                 : 
1529			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1529			;     returned by malloc, otherwise the behaviour is undefined.               : 
1529			;                                                                             : 
1529			;     Where possible, directly adjacent free blocks will be merged together   : 
1529			;     into larger blocks to help ensure that the heap does not become         : 
1529			;     excessively fragmented.                                                 : 
1529			;                                                                             : 
1529			;     free does not clear or set any other value into the freed space, and    : 
1529			;     therefore its contents may be visible through subsequent malloc's. The  : 
1529			;     caller should clear the freed space as required.                        : 
1529			;                                                                             : 
1529			;     This implementation of free uses the stack exclusively, and is          : 
1529			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1529			;     advisable to disable interrupts before calling free, and recommended    : 
1529			;     to avoid the use of free inside ISRs in general.                        : 
1529			;                                                                             : 
1529			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1529			;                                                                             : 
1529			; Parameters                                                                  : 
1529			;     HL  Pointer to address of first byte of allocation to be freed          : 
1529			;                                                                             : 
1529			; Returns                                                                     : 
1529			;     Nothing                                                                 : 
1529			;                                                                             : 
1529			; Stack frame                                                                 : 
1529			;       |             |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |     BC      |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |     DE      |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |     IX      |                                                       : 
1529			;       +-------------+                                                       : 
1529			;       |  prev_free  |                                                       : 
1529			;   +2  +-------------+                                                       : 
1529			;       |  next_free  |                                                       : 
1529			;   +0  +-------------+                                                       : 
1529			;       |             |                                                       : 
1529			;                                                                             : 
1529			;------------------------------------------------------------------------------ 
1529			free: 
1529			      push  BC 
1529			      push  DE 
1529			      push  IX 
1529			 
1529			      ld    A, H                    ; Exit if ptr is null 
1529			      or    L 
1529			      jp    Z, free_early_exit 
1529			 
1529			      ; Set up stack frame 
1529			      ex    DE, HL 
1529			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1529			      add   HL, SP 
1529			      ld    SP, HL 
1529			      ld    IX, 0                   ; Use IX as a frame pointer 
1529			      add   IX, SP 
1529			 
1529			      ; The address in HL points to the start of the useable allocated space, 
1529			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1529			      ; address of the block itself. 
1529			      ex    DE, HL 
1529			      ld    DE, -4 
1529			      add   HL, DE 
1529			 
1529			      ; An allocated block must have a null next block pointer in it 
1529			      ld    A, (HL) 
1529			      inc   HL 
1529			      or    (HL) 
1529			      jp    NZ, free_done 
1529			 
1529			      dec   HL 
1529			 
1529			      ld    B, H                    ; Copy HL to BC 
1529			      ld    C, L 
1529			 
1529			      ; Loop through the free list to find the first block with an address 
1529			      ; higher than the block being freed 
1529			      ld    HL, free_list 
1529			 
1529			free_find_higher_block: 
1529			      ld    E, (HL)                 ; Load next ptr from free block 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      dec   HL 
1529			 
1529			      ld    (IX+0), E               ; Save ptr to next free block 
1529			      ld    (IX+1), D 
1529			      ld    (IX+2), L               ; Save ptr to prev free block 
1529			      ld    (IX+3), H 
1529			 
1529			      ld    A, B                    ; Check if DE is greater than BC 
1529			      cp    D                       ; Compare MSB first 
1529			      jr    Z, $+4                  ; MSB the same, compare LSB 
1529			      jr    NC, free_find_higher_block_skip 
1529			      ld    A, C 
1529			      cp    E                       ; Then compare LSB 
1529			      jr    C, free_found_higher_block 
1529			 
1529			free_find_higher_block_skip: 
1529			      ld    A, D                    ; Reached the end of the free list? 
1529			      or    E 
1529			      jp    Z, free_done 
1529			 
1529			      ex    DE, HL 
1529			 
1529			      jr    free_find_higher_block 
1529			 
1529			free_found_higher_block: 
1529			      ; Insert freed block between prev and next free blocks 
1529			      ld    (HL), C                 ; Point prev free block to freed block 
1529			      inc   HL 
1529			      ld    (HL), B 
1529			 
1529			      ld    H, B                    ; Point freed block at next free block 
1529			      ld    L, C 
1529			      ld    (HL), E 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			      ; Check if the freed block is adjacent to the next free block 
1529			      inc   HL                      ; Load size of freed block into HL 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      ex    DE, HL 
1529			 
1529			      add   HL, BC                  ; Add addr of freed block and its size 
1529			 
1529			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1529			      ld    D, (IX+1) 
1529			 
1529			      or    A                       ; Clear the carry flag 
1529			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1529			      jr    NZ, free_check_adjacent_to_prev 
1529			 
1529			      ; Freed block is adjacent to next, merge into one bigger block 
1529			      ex    DE, HL                  ; Load next ptr from next block into DE 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      push  HL                      ; Save ptr to next block for later 
1529			 
1529			      ld    H, B                    ; Store ptr from next block into freed block 
1529			      ld    L, C 
1529			      ld    (HL), E 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			      pop   HL                      ; Restore ptr to next block 
1529			      inc   HL                      ; Load size of next block into DE 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      push  DE                      ; Save next block size for later 
1529			 
1529			      ld    H, B                    ; Load size of freed block into HL 
1529			      ld    L, C 
1529			      inc   HL 
1529			      inc   HL 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      ex    DE, HL 
1529			 
1529			      pop   DE                      ; Restore size of next block 
1529			      add   HL, DE                  ; Add sizes of both blocks 
1529			      ex    DE, HL 
1529			 
1529			      ld    H, B                    ; Store new bigger size into freed block 
1529			      ld    L, C 
1529			      inc   HL 
1529			      inc   HL 
1529			      ld    (HL), E 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			free_check_adjacent_to_prev: 
1529			      ; Check if the freed block is adjacent to the prev free block 
1529			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1529			      ld    H, (IX+3) 
1529			 
1529			      inc   HL                      ; Size of prev free block into DE 
1529			      inc   HL 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      dec   HL 
1529			      dec   HL 
1529			      dec   HL 
1529			 
1529			      add   HL, DE                  ; Add prev block addr and size 
1529			 
1529			      or    A                       ; Clear the carry flag 
1529			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1529			      jr    NZ, free_done 
1529			 
1529			      ; Freed block is adjacent to prev, merge into one bigger block 
1529			      ld    H, B                    ; Load next ptr from freed block into DE 
1529			      ld    L, C 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      push  HL                      ; Save freed block ptr for later 
1529			 
1529			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1529			      ld    H, (IX+3) 
1529			      ld    (HL), E 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			      pop   HL                      ; Restore freed block ptr 
1529			      inc   HL                      ; Load size of freed block into DE 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			      push  DE                      ; Save freed block size for later 
1529			 
1529			      ld    L, (IX+2)               ; Load size of prev block into DE 
1529			      ld    H, (IX+3) 
1529			      inc   HL 
1529			      inc   HL 
1529			      ld    E, (HL) 
1529			      inc   HL 
1529			      ld    D, (HL) 
1529			 
1529			      pop   HL                      ; Add sizes of both blocks 
1529			      add   HL, DE 
1529			      ex    DE, HL 
1529			 
1529			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1529			      ld    H, (IX+3) 
1529			      inc   HL 
1529			      inc   HL 
1529			      ld    (HL), E 
1529			      inc   HL 
1529			      ld    (HL), D 
1529			 
1529			free_done: 
1529			      ld    HL, 4                   ; Clean up stack frame 
1529			      add   HL, SP 
1529			      ld    SP, HL 
1529			 
1529			free_early_exit: 
1529			      pop   IX 
1529			      pop   DE 
1529			      pop   BC 
1529			 
1529			      ret 
1529			 
1529			 
1529			;      .org 0x8000 
1529			; 
1529			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1529			 ;                 .dw   0 
1529			 
1529			endif 
1529			 
1529			 
1529			if MALLOC_4 
1529			 
1529			; My memory allocation code. Very very simple.... 
1529			; allocate space under 250 chars 
1529			 
1529			heap_init: 
1529				; init start of heap as zero 
1529				;  
1529			 
1529				ld hl, heap_start 
1529				ld a, 0 
1529				ld (hl), a      ; empty block 
1529				inc hl 
1529				ld a, 0 
1529				ld (hl), a      ; length of block 
1529				; write end of list 
1529				inc hl 
1529				ld a,(hl) 
1529				inc hl 
1529				ld a,(hl) 
1529				 
1529			 
1529				; init some malloc vars 
1529			 
1529				ld hl, 0 
1529				ld (free_list), hl       ; store last malloc location 
1529			 
1529				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1529				ld a, 0 
1529				ld (hl), a 
1529			 
1529			 
1529				ld hl, heap_start 
1529				;  
1529				  
1529				ret 
1529			 
1529			 
1529			;    free block marker 
1529			;    requested size  
1529			;    pointer to next block 
1529			;    .... 
1529			;    next block marker 
1529			 
1529			 
1529			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1529			; 
1529			 
1529			 
1529			malloc:  
1529				push de 
1529				push bc 
1529				push af 
1529			 
1529				; hl space required 
1529				 
1529				ld c, l    ; hold space   (TODO only a max of 255) 
1529			 
1529			;	inc c     ; TODO BUG need to fix memory leak on push str 
1529			;	inc c 
1529			;	inc c 
1529			;	inc c 
1529			;	inc c 
1529			;	inc c 
1529			;	inc c 
1529			 
1529			 
1529			 
1529				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1529			 
1529				ld a, (free_list+3) 
1529				cp 0 
1529				jr z, .contheap 
1529			 
1529				ld hl, (free_list)     ; get last alloc 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "mrs" 
1529						CALLMONITOR 
1529					endif 
1529				jr .startalloc 
1529			 
1529			.contheap: 
1529				ld hl, heap_start 
1529			 
1529			.startalloc: 
1529			 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "mym" 
1529						CALLMONITOR 
1529					endif 
1529			.findblock: 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "mmf" 
1529						CALLMONITOR 
1529					endif 
1529			 
1529				ld a,(hl)  
1529				; if byte is zero then clear to use 
1529			 
1529				cp 0 
1529				jr z, .foundemptyblock 
1529			 
1529				; if byte is not clear 
1529				;     then byte is offset to next block 
1529			 
1529				inc hl 
1529				ld a, (hl) ; get size 
1529			.nextblock:	inc hl 
1529					ld e, (hl) 
1529					inc hl 
1529					ld d, (hl) 
1529					ex de, hl 
1529			;	inc hl  ; move past the store space 
1529			;	inc hl  ; move past zero index  
1529			 
1529				; TODO detect no more space 
1529			 
1529				push hl 
1529				ld de, heap_end 
1529				call cmp16 
1529				pop hl 
1529				jr nc, .nospace 
1529			 
1529				jr .findblock 
1529			 
1529			.nospace: ld hl, 0 
1529				jp .exit 
1529			 
1529			 
1529			.foundemptyblock:	 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "mme" 
1529						CALLMONITOR 
1529					endif 
1529			 
1529			; TODO has block enough space if reusing??? 
1529			 
1529				;  
1529			 
1529			; see if this block has been previously used 
1529				inc hl 
1529				ld a, (hl) 
1529				dec hl 
1529				cp 0 
1529				jr z, .newblock 
1529			 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "meR" 
1529						CALLMONITOR 
1529					endif 
1529			 
1529			; no reusing previously allocated block 
1529			 
1529			; is it smaller than previously used? 
1529				 
1529				inc hl    ; move to size 
1529				ld a, c 
1529				sub (hl)        ; we want c < (hl) 
1529				dec hl    ; move back to marker 
1529			        jr z, .findblock 
1529			 
1529				; update with the new size which should be lower 
1529			 
1529			        ;inc  hl   ; negate next move. move back to size  
1529			 
1529			.newblock: 
1529				; need to be at marker here 
1529			 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "meN" 
1529						CALLMONITOR 
1529					endif 
1529			 
1529			 
1529				ld a, c 
1529			 
1529				ld (free_list+3), a	 ; flag resume from last malloc  
1529				ld (free_list), hl    ; save out last location 
1529			 
1529			 
1529				;inc a     ; space for length byte 
1529				ld (hl), a     ; save block in use marker 
1529			 
1529				inc hl   ; move to space marker 
1529				ld (hl), a    ; save new space 
1529			 
1529				inc hl   ; move to start of allocated area 
1529				 
1529			;	push hl     ; save where we are - 1  
1529			 
1529			;	inc hl  ; move past zero index  
1529				; skip space to set down new marker 
1529			 
1529				; provide some extra space for now 
1529			 
1529				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1529				inc a 
1529				inc a 
1529			 
1529				push hl   ; save where we are in the node block 
1529			 
1529				call addatohl 
1529			 
1529				; write linked list point 
1529			 
1529				pop de     ; get our node position 
1529				ex de, hl 
1529			 
1529				ld (hl), e 
1529				inc hl 
1529				ld (hl), d 
1529			 
1529				inc hl 
1529			 
1529				; now at start of allocated data so save pointer 
1529			 
1529				push hl 
1529			 
1529				; jump to position of next node and setup empty header in DE 
1529			 
1529				ex de, hl 
1529			 
1529			;	inc hl ; move past end of block 
1529			 
1529				ld a, 0 
1529				ld (hl), a   ; empty marker 
1529				inc hl 
1529				ld (hl), a   ; size 
1529				inc hl  
1529				ld (hl), a   ; ptr 
1529				inc hl 
1529				ld (hl), a   ; ptr 
1529			 
1529			 
1529				pop hl 
1529			 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "mmr" 
1529						CALLMONITOR 
1529					endif 
1529			 
1529			.exit: 
1529				pop af 
1529				pop bc 
1529				pop de  
1529				ret 
1529			 
1529			 
1529			 
1529			 
1529			free:  
1529				push hl 
1529				push af 
1529				; get address in hl 
1529			 
1529					if DEBUG_FORTH_MALLOC_INT 
1529						DMARK "fre" 
1529						CALLMONITOR 
1529					endif 
1529				; data is at hl - move to block count 
1529				dec hl 
1529				dec hl    ; get past pointer 
1529				dec hl 
1529			 
1529				ld a, (hl)    ; need this for a validation check 
1529			 
1529				dec hl    ; move to block marker 
1529			 
1529				; now check that the block count and block marker are the same  
1529			        ; this checks that we are on a malloc node and not random memory 
1529			        ; OK a faint chance this could be a problem but rare - famous last words! 
1529			 
1529				ld c, a 
1529				ld a, (hl)    
1529			 
1529				cp c 
1529				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1529			 
1529				; yes good chance we are on a malloc node 
1529			 
1529				ld a, 0      
1529				ld (hl), a   ; mark as free 
1529			 
1529				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1529			 
1529			.freeignore:  
1529			 
1529				pop af 
1529				pop hl 
1529			 
1529				ret 
1529			 
1529			 
1529			 
1529			endif 
1529			 
1529			; eof 
# End of file firmware_memory.asm
1529			  
1529			; device C  
1529			if SOUND_ENABLE  
1529				include "firmware_sound.asm"  
1529			endif  
1529			  
1529			include "firmware_diags.asm"  
1529			; Hardware diags menu 
1529			 
1529			 
1529			config: 
1529			 
1529 3e 00			ld a, 0 
152b 21 59 15			ld hl, .configmn 
152e cd c6 0c			call menu 
1531			 
1531 fe 00			cp 0 
1533 c8				ret z 
1534			 
1534 fe 01			cp 1 
1536 cc 32 16			call z, .savetostore 
1539			 
1539 fe 02			cp 2 
153b cc 80 15			call z, .selautoload 
153e fe 03			cp 3 
1540 cc 69 15			call z, .disautoload 
1543 fe 04			cp 4 
1545 cc 30 16			call z, .selbank 
1548 fe 05			cp 5 
154a cc 0d 17			call z, .debug_tog 
154d fe 06			cp 6 
154f cc 50 18			call z, .bpsgo 
1552 fe 07			cp 7 
1554 cc 33 17			call z, hardware_diags 
1557			 
1557 18 d0			jr config 
1559			 
1559			.configmn: 
1559 41 1a			dw prom_c3 
155b 58 1a			dw prom_c2 
155d 6d 1a			dw prom_c2a 
155f 83 1a			dw prom_c2b 
1561			;	dw prom_c4 
1561 a0 1a			dw prom_m4 
1563 bb 1a			dw prom_m4b 
1565 c3 1a			dw prom_c1 
1567 00 00			dw 0 
1569				 
1569			 
1569			 
1569			 
1569			.disautoload: 
1569				if STORAGE_SE 
1569 3e fe			ld a, $fe      ; bit 0 clear 
156b 32 f0 fb			ld (spi_device), a 
156e			 
156e cd 82 04			call storage_get_block_0 
1571			 
1571 3e 00			ld a, 0 
1573 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
1576			 
1576 21 00 00				ld hl, 0 
1579 11 07 fc				ld de, store_page 
157c cd 36 04			call storage_write_block	 ; save update 
157f				else 
157f			 
157f				ld hl, prom_notav 
157f				ld de, prom_empty 
157f				call info_panel 
157f				endif 
157f			 
157f			 
157f c9				ret 
1580			 
1580			 
1580			 
1580			; Select auto start 
1580			 
1580			.selautoload: 
1580			 
1580				 
1580				if STORAGE_SE 
1580			 
1580 cd 57 16				call config_dir 
1583 21 85 f3			        ld hl, scratch 
1586 3e 00				ld a, 0 
1588 cd c6 0c				call menu 
158b			 
158b fe 00				cp 0 
158d c8					ret z 
158e			 
158e 3d					dec a 
158f			 
158f			 
158f					; locate menu option 
158f			 
158f 21 85 f3				ld hl, scratch 
1592 cd ea 0b				call table_lookup 
1595			 
1595					if DEBUG_FORTH_WORDS 
1595						DMARK "ALl" 
1595 f5				push af  
1596 3a aa 15			ld a, (.dmark)  
1599 32 b4 fe			ld (debug_mark),a  
159c 3a ab 15			ld a, (.dmark+1)  
159f 32 b5 fe			ld (debug_mark+1),a  
15a2 3a ac 15			ld a, (.dmark+2)  
15a5 32 b6 fe			ld (debug_mark+2),a  
15a8 18 03			jr .pastdmark  
15aa ..			.dmark: db "ALl"  
15ad f1			.pastdmark: pop af  
15ae			endm  
# End of macro DMARK
15ae						CALLMONITOR 
15ae cd 46 18			call break_point_state  
15b1				endm  
# End of macro CALLMONITOR
15b1					endif 
15b1					; with the pointer to the menu it, the byte following the zero term is the file id 
15b1			 
15b1 3e 00				ld a, 0 
15b3 01 32 00				ld bc, 50   ; max of bytes to look at 
15b6 ed b1				cpir  
15b8			 
15b8					if DEBUG_FORTH_WORDS 
15b8						DMARK "ALb" 
15b8 f5				push af  
15b9 3a cd 15			ld a, (.dmark)  
15bc 32 b4 fe			ld (debug_mark),a  
15bf 3a ce 15			ld a, (.dmark+1)  
15c2 32 b5 fe			ld (debug_mark+1),a  
15c5 3a cf 15			ld a, (.dmark+2)  
15c8 32 b6 fe			ld (debug_mark+2),a  
15cb 18 03			jr .pastdmark  
15cd ..			.dmark: db "ALb"  
15d0 f1			.pastdmark: pop af  
15d1			endm  
# End of macro DMARK
15d1						CALLMONITOR 
15d1 cd 46 18			call break_point_state  
15d4				endm  
# End of macro CALLMONITOR
15d4					endif 
15d4					;inc hl 
15d4			 
15d4 7e					ld a, (hl)   ; file id 
15d5					 
15d5				        ; save bank and file ids 
15d5			 
15d5 f5					push af 
15d6			 
15d6			; TODO need to save to block 0 on bank 1	 
15d6			 
15d6 cd 82 04				call storage_get_block_0 
15d9			 
15d9					if DEBUG_FORTH_WORDS 
15d9						DMARK "AL0" 
15d9 f5				push af  
15da 3a ee 15			ld a, (.dmark)  
15dd 32 b4 fe			ld (debug_mark),a  
15e0 3a ef 15			ld a, (.dmark+1)  
15e3 32 b5 fe			ld (debug_mark+1),a  
15e6 3a f0 15			ld a, (.dmark+2)  
15e9 32 b6 fe			ld (debug_mark+2),a  
15ec 18 03			jr .pastdmark  
15ee ..			.dmark: db "AL0"  
15f1 f1			.pastdmark: pop af  
15f2			endm  
# End of macro DMARK
15f2						CALLMONITOR 
15f2 cd 46 18			call break_point_state  
15f5				endm  
# End of macro CALLMONITOR
15f5					endif 
15f5 f1					pop af 
15f6			 
15f6 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
15f9					 
15f9					; save bank id 
15f9			 
15f9 3a f0 fb				ld a,(spi_device) 
15fc 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
15ff			 
15ff					; enable auto run of store file 
15ff			 
15ff 3e 01				ld a, 1 
1601 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
1604			 
1604					; save buffer 
1604			 
1604 21 00 00				ld hl, 0 
1607 11 07 fc				ld de, store_page 
160a					if DEBUG_FORTH_WORDS 
160a						DMARK "ALw" 
160a f5				push af  
160b 3a 1f 16			ld a, (.dmark)  
160e 32 b4 fe			ld (debug_mark),a  
1611 3a 20 16			ld a, (.dmark+1)  
1614 32 b5 fe			ld (debug_mark+1),a  
1617 3a 21 16			ld a, (.dmark+2)  
161a 32 b6 fe			ld (debug_mark+2),a  
161d 18 03			jr .pastdmark  
161f ..			.dmark: db "ALw"  
1622 f1			.pastdmark: pop af  
1623			endm  
# End of macro DMARK
1623						CALLMONITOR 
1623 cd 46 18			call break_point_state  
1626				endm  
# End of macro CALLMONITOR
1626					endif 
1626 cd 36 04			call storage_write_block	 ; save update 
1629			  
1629			 
1629			 
1629			 
1629 21 85 f3				ld hl, scratch 
162c cd 44 16				call config_fdir 
162f			 
162f				else 
162f			 
162f				ld hl, prom_notav 
162f				ld de, prom_empty 
162f				call info_panel 
162f			 
162f				endif 
162f c9				ret 
1630			 
1630			 
1630			 
1630			; Select storage bank 
1630			 
1630			.selbank: 
1630			 
1630				if STORAGE_SE 
1630				else 
1630			 
1630				ld hl, prom_notav 
1630				ld de, prom_empty 
1630				call info_panel 
1630				endif 
1630				 
1630 c9				ret 
1631			 
1631			if STORAGE_SE 
1631			 
1631			.config_ldir:   
1631				; Load storage bank labels into menu array 
1631			 
1631				 
1631			 
1631			 
1631 c9				ret 
1632			 
1632			 
1632			endif 
1632			 
1632			 
1632			; Save user words to storage 
1632			 
1632			.savetostore: 
1632			 
1632				if STORAGE_SE 
1632			 
1632 cd 57 16				call config_dir 
1635 21 85 f3			        ld hl, scratch 
1638 3e 00				ld a, 0 
163a cd c6 0c				call menu 
163d					 
163d 21 85 f3				ld hl, scratch 
1640 cd 44 16				call config_fdir 
1643			 
1643				else 
1643			 
1643				ld hl, prom_notav 
1643				ld de, prom_empty 
1643				call info_panel 
1643			 
1643				endif 
1643			 
1643 c9				ret 
1644			 
1644			 
1644			 
1644			if STORAGE_SE 
1644			 
1644			config_fdir: 
1644				; using the scratch dir go through and release the memory allocated for each string 
1644				 
1644 21 85 f3			ld hl, scratch 
1647 5e			.cfdir:	ld e,(hl) 
1648 23				inc hl 
1649 56				ld d,(hl) 
164a 23				inc hl 
164b			 
164b eb				ex de, hl 
164c cd f2 0e			call ishlzero 
164f c8				ret z     ; return on null pointer 
1650 cd 5a 14			call free 
1653 eb				ex de, hl 
1654 18 f1			jr .cfdir 
1656			 
1656			 
1656 c9				ret 
1657			 
1657			 
1657			config_dir: 
1657			 
1657				; for the config menus that need to build a directory of storage call this routine 
1657				; it will construct a menu in scratch to pass to menu 
1657			 
1657				; open storage device 
1657			 
1657				; execute DIR to build a list of files and their ids into scratch in menu format 
1657				; once the menu has finished then will need to call config_fdir to release the strings 
1657				 
1657				; c = number items 
1657			 
1657				 
1657 cd 82 04			call storage_get_block_0 
165a			 
165a 21 07 fc			ld hl, store_page     ; get current id count 
165d 46				ld b, (hl) 
165e 0e 00			ld c, 0    ; count of files   
1660			 
1660			 
1660 21 85 f3			ld hl, scratch 
1663 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
1666			 
1666				; check for empty drive 
1666			 
1666 3e 00			ld a, 0 
1668 b8				cp b 
1669 ca 03 17			jp z, .dirdone 
166c			 
166c				 
166c					if DEBUG_FORTH_WORDS 
166c						DMARK "Cdc" 
166c f5				push af  
166d 3a 81 16			ld a, (.dmark)  
1670 32 b4 fe			ld (debug_mark),a  
1673 3a 82 16			ld a, (.dmark+1)  
1676 32 b5 fe			ld (debug_mark+1),a  
1679 3a 83 16			ld a, (.dmark+2)  
167c 32 b6 fe			ld (debug_mark+2),a  
167f 18 03			jr .pastdmark  
1681 ..			.dmark: db "Cdc"  
1684 f1			.pastdmark: pop af  
1685			endm  
# End of macro DMARK
1685						CALLMONITOR 
1685 cd 46 18			call break_point_state  
1688				endm  
# End of macro CALLMONITOR
1688					endif 
1688			 
1688			 
1688			.diritem:	 
1688 c5				push bc 
1689				; for each of the current ids do a search for them and if found push to stack 
1689			 
1689 21 40 00				ld hl, STORE_BLOCK_PHY 
168c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
168e 58					ld e,b 
168f			 
168f cd 04 07				call storage_findnextid 
1692			 
1692			 
1692					; if found hl will be non zero 
1692			 
1692 cd f2 0e				call ishlzero 
1695 28 69				jr z, .dirnotfound 
1697			 
1697					; increase count 
1697			 
1697 c1					pop bc	 
1698 0c					inc c 
1699 c5					push bc 
169a					 
169a			 
169a					; get file header and push the file name 
169a			 
169a 11 07 fc				ld de, store_page 
169d cd d1 03				call storage_read_block 
16a0			 
16a0					; push file id to stack 
16a0				 
16a0 3a 07 fc				ld a, (store_page) 
16a3 26 00				ld h, 0 
16a5 6f					ld l, a 
16a6			 
16a6					;call forth_push_numhl 
16a6					; TODO store id 
16a6			 
16a6 e5					push hl 
16a7			 
16a7					; push extent count to stack  
16a7				 
16a7 21 0a fc				ld hl, store_page+3 
16aa			 
16aa					; get file name length 
16aa			 
16aa cd 27 13				call strlenz   
16ad			 
16ad 23					inc hl   ; cover zero term 
16ae 23					inc hl  ; stick the id at the end of the area 
16af			 
16af e5					push hl 
16b0 c1					pop bc    ; move length to bc 
16b1			 
16b1 cd 90 13				call malloc 
16b4			 
16b4					; TODO save malloc area to scratch 
16b4			 
16b4 eb					ex de, hl 
16b5 2a fe fb				ld hl, (store_tmp2) 
16b8 73					ld (hl), e 
16b9 23					inc hl 
16ba 72					ld (hl), d 
16bb 23					inc hl 
16bc 22 fe fb				ld (store_tmp2), hl 
16bf			 
16bf					 
16bf			 
16bf					;pop hl   ; get source 
16bf			;		ex de, hl    ; swap aronund	 
16bf			 
16bf 21 0a fc				ld hl, store_page+3 
16c2					if DEBUG_FORTH_WORDS 
16c2						DMARK "CFd" 
16c2 f5				push af  
16c3 3a d7 16			ld a, (.dmark)  
16c6 32 b4 fe			ld (debug_mark),a  
16c9 3a d8 16			ld a, (.dmark+1)  
16cc 32 b5 fe			ld (debug_mark+1),a  
16cf 3a d9 16			ld a, (.dmark+2)  
16d2 32 b6 fe			ld (debug_mark+2),a  
16d5 18 03			jr .pastdmark  
16d7 ..			.dmark: db "CFd"  
16da f1			.pastdmark: pop af  
16db			endm  
# End of macro DMARK
16db						CALLMONITOR 
16db cd 46 18			call break_point_state  
16de				endm  
# End of macro CALLMONITOR
16de					endif 
16de ed b0				ldir 
16e0			 
16e0					; de is past string, move back one and store id 
16e0					 
16e0 1b					dec de 
16e1			 
16e1					; store file id 
16e1			 
16e1 e1					pop hl 
16e2 eb					ex de,hl 
16e3 73					ld (hl), e 
16e4			 
16e4					if DEBUG_FORTH_WORDS 
16e4						DMARK "Cdi" 
16e4 f5				push af  
16e5 3a f9 16			ld a, (.dmark)  
16e8 32 b4 fe			ld (debug_mark),a  
16eb 3a fa 16			ld a, (.dmark+1)  
16ee 32 b5 fe			ld (debug_mark+1),a  
16f1 3a fb 16			ld a, (.dmark+2)  
16f4 32 b6 fe			ld (debug_mark+2),a  
16f7 18 03			jr .pastdmark  
16f9 ..			.dmark: db "Cdi"  
16fc f1			.pastdmark: pop af  
16fd			endm  
# End of macro DMARK
16fd						CALLMONITOR 
16fd cd 46 18			call break_point_state  
1700				endm  
# End of macro CALLMONITOR
1700					endif 
1700					 
1700			.dirnotfound: 
1700 c1					pop bc     
1701 10 85				djnz .diritem 
1703				 
1703			.dirdone:	 
1703			 
1703 3e 00				ld a, 0 
1705 2a fe fb				ld hl, (store_tmp2) 
1708 77					ld (hl), a 
1709 23					inc hl 
170a 77					ld (hl), a 
170b 23					inc hl 
170c					; push a count of the dir items found 
170c			 
170c			;		ld h, 0 
170c			;		ld l, c 
170c			 
170c c9				ret 
170d			 
170d			endif 
170d			 
170d			 
170d			; Settings 
170d			; Run  
170d			 
170d			 
170d			 
170d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
170d			;;hd_menu2:   db "        2: Editor",0   
170d			;hd_menu2:   db "        2: Editor       6: Menu",0   
170d			;hd_menu3:   db "        3: Storage",0 
170d			;hd_menu4:   db "0=quit  4: Debug",0 
170d			;hd_don:     db "ON",0 
170d			;hd_doff:     db "OFF",0 
170d			; 
170d			; 
170d			; 
170d			;hardware_diags_old:       
170d			; 
170d			;.diagmenu: 
170d			;	call clear_display 
170d			;	ld a, display_row_1 
170d			;	ld de, hd_menu1 
170d			;	call str_at_display 
170d			; 
170d			;	ld a, display_row_2 
170d			;	ld de, hd_menu2 
170d			;	call str_at_display 
170d			; 
170d			;	ld a, display_row_3 
170d			;	ld de, hd_menu3 
170d			;	call str_at_display 
170d			; 
170d			;	ld a,  display_row_4 
170d			;	ld de, hd_menu4 
170d			;	call str_at_display 
170d			; 
170d			;	; display debug state 
170d			; 
170d			;	ld de, hd_don 
170d			;	ld a, (os_view_disable) 
170d			;	cp 0 
170d			;	jr z, .distog 
170d			;	ld de, hd_doff 
170d			;.distog: ld a, display_row_4+17 
170d			;	call str_at_display 
170d			; 
170d			;	call update_display 
170d			; 
170d			;	call cin_wait 
170d			; 
170d			; 
170d			; 
170d			;	cp '4' 
170d			;	jr nz, .diagn1 
170d			; 
170d			;	; debug toggle 
170d			; 
170d			;	ld a, (os_view_disable) 
170d			;	ld b, '*' 
170d			;	cp 0 
170d			;	jr z, .debtog 
170d			;	ld b, 0 
170d			;.debtog:	 
170d			;	ld a,b 
170d			;	ld (os_view_disable),a 
170d			; 
170d			;.diagn1: cp '0' 
170d			;	 ret z 
170d			; 
170d			;;	cp '1' 
170d			;;       jp z, matrix	 
170d			;;   TODO keyboard matrix test 
170d			; 
170d			;	cp '2' 
170d			;	jp z, .diagedit 
170d			; 
170d			;;	cp '6' 
170d			;;	jp z, .menutest 
170d			;;if ENABLE_BASIC 
170d			;;	cp '6' 
170d			;;	jp z, basic 
170d			;;endif 
170d			 ; 
170d			;	jp .diagmenu 
170d			; 
170d			; 
170d			;	ret 
170d			 
170d			 
170d			.debug_tog: 
170d 21 54 17			ld hl, .menudebug 
1710				 
1710 3a 76 f3			ld a, (os_view_disable) 
1713 fe 2a			cp '*' 
1715 20 04			jr nz,.tdon  
1717 3e 01			ld a, 1 
1719 18 02			jr .tog1 
171b 3e 00		.tdon: ld a, 0 
171d			 
171d			.tog1: 
171d cd c6 0c			call menu 
1720 fe 00			cp 0 
1722 c8				ret z 
1723 fe 01			cp 1    ; disable debug 
1725 28 04			jr z, .dtog0 
1727 3e 2a			ld a, '*' 
1729 18 02			jr .dtogset 
172b 3e 00		.dtog0: ld a, 0 
172d 32 76 f3		.dtogset:  ld (os_view_disable), a 
1730 c3 0d 17			jp .debug_tog 
1733			 
1733			 
1733			hardware_diags:       
1733			 
1733			.diagm: 
1733 21 46 17			ld hl, .menuitems 
1736 3e 00			ld a, 0 
1738 cd c6 0c			call menu 
173b			 
173b fe 00		         cp 0 
173d c8				 ret z 
173e			 
173e fe 02			cp 2 
1740 ca 9f 17			jp z, .diagedit 
1743			 
1743			;	cp '6' 
1743			;	jp z, .menutest 
1743			;if ENABLE_BASIC 
1743			;	cp '6' 
1743			;	jp z, basic 
1743			;endif 
1743			  
1743 c3 33 17			jp .diagm 
1746			 
1746				 
1746 5a 17		.menuitems:   	dw .m1 
1748 65 17				dw .m2 
174a 6c 17				dw .m3 
174c 74 17				dw .m5 
174e 7a 17				dw .m5a 
1750 83 17				dw .m5b 
1752 00 00				dw 0 
1754			 
1754			.menudebug: 
1754 8c 17				dw .m6 
1756 95 17				dw .m7 
1758 00 00				dw 0 
175a			 
175a .. 00		.m1:   db "Key Matrix",0 
1765 .. 00		.m2:   db "Editor",0 
176c .. 00		.m3:   db "Storage",0 
1774 .. 00		.m5:   db "Sound",0 
177a .. 00		.m5a:  db "RAM Test",0 
1783 .. 00		.m5b:  db "LCD Test",0 
178c			 
178c .. 00		.m6:   db "Debug ON",0 
1795 .. 00		.m7:   db "Debug OFF",0 
179f			 
179f			; debug editor 
179f			 
179f			.diagedit: 
179f			 
179f 21 85 f3			ld hl, scratch 
17a2			;	ld bc, 250 
17a2			;	ldir 
17a2				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
17a2 3e 00			ld a, 0 
17a4 77				ld (hl), a 
17a5 23				inc hl 
17a6 77				ld (hl), a 
17a7 23				inc hl 
17a8 77				ld (hl), a 
17a9			 
17a9 cd 95 0c		        call clear_display 
17ac cd b8 0c			call update_display 
17af				;ld a, 1 
17af				;ld (hardware_diag), a 
17af			.diloop: 
17af 3e 00			ld a, display_row_1 
17b1 0e 00			ld c, 0 
17b3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17b5 1e 28			ld e, 40 
17b7			 
17b7 21 85 f3			ld hl, scratch	 
17ba cd f6 0e			call input_str 
17bd			 
17bd 3e 14			ld a, display_row_2 
17bf 11 85 f3			ld de, scratch 
17c2 cd a8 0c			call str_at_display 
17c5 cd b8 0c			call update_display 
17c8			 
17c8 c3 af 17			jp .diloop 
17cb			 
17cb			 
17cb			; pass word in hl 
17cb			; a has display location 
17cb			display_word_at: 
17cb f5				push af 
17cc e5				push hl 
17cd 7c				ld a,h 
17ce 21 8a f6			ld hl, os_word_scratch 
17d1 cd ca 11			call hexout 
17d4 e1				pop hl 
17d5 7d				ld a,l 
17d6 21 8c f6			ld hl, os_word_scratch+2 
17d9 cd ca 11			call hexout 
17dc 21 8e f6			ld hl, os_word_scratch+4 
17df 3e 00			ld a,0 
17e1 77				ld (hl),a 
17e2 11 8a f6			ld de,os_word_scratch 
17e5 f1				pop af 
17e6 cd a8 0c				call str_at_display 
17e9 c9				ret 
17ea			 
17ea			display_ptr_state: 
17ea			 
17ea				; to restore afterwards 
17ea			 
17ea d5				push de 
17eb c5				push bc 
17ec e5				push hl 
17ed f5				push af 
17ee			 
17ee				; for use in here 
17ee			 
17ee			;	push bc 
17ee			;	push de 
17ee			;	push hl 
17ee			;	push af 
17ee			 
17ee cd 95 0c			call clear_display 
17f1			 
17f1 11 c4 19			ld de, .ptrstate 
17f4 3e 00			ld a, display_row_1 
17f6 cd a8 0c			call str_at_display 
17f9			 
17f9				; display debug step 
17f9			 
17f9			 
17f9 11 b4 fe			ld de, debug_mark 
17fc 3e 12			ld a, display_row_1+display_cols-2 
17fe cd a8 0c			call str_at_display 
1801			 
1801				; display a 
1801 11 ce 19			ld de, .ptrcliptr 
1804 3e 14			ld a, display_row_2 
1806 cd a8 0c			call str_at_display 
1809			 
1809 f1				pop af 
180a 2a d0 fb			ld hl,(cli_ptr) 
180d 3e 1c			ld a, display_row_2+8 
180f cd cb 17			call display_word_at 
1812			 
1812			 
1812				; display hl 
1812			 
1812			 
1812 11 d6 19			ld de, .ptrclioptr 
1815 3e 1e			ld a, display_row_2+10 
1817 cd a8 0c			call str_at_display 
181a			; 
181a			;	pop hl 
181a 3e 21			ld a, display_row_2+13 
181c 2a ce fb			ld hl,(cli_origptr) 
181f cd cb 17			call display_word_at 
1822			; 
1822			;	 
1822			;	; display de 
1822			 
1822			;	ld de, .regstatede 
1822			;	ld a, display_row_3 
1822			;	call str_at_display 
1822			 
1822			;	pop de 
1822			;	ld h,d 
1822			;	ld l, e 
1822			;	ld a, display_row_3+3 
1822			;	call display_word_at 
1822			 
1822			 
1822				; display bc 
1822			 
1822			;	ld de, .regstatebc 
1822			;	ld a, display_row_3+10 
1822			;	call str_at_display 
1822			 
1822			;	pop bc 
1822			;	ld h,b 
1822			;	ld l, c 
1822			;	ld a, display_row_3+13 
1822			;	call display_word_at 
1822			 
1822			 
1822				; display dsp 
1822			 
1822			;	ld de, .regstatedsp 
1822			;	ld a, display_row_4 
1822			;	call str_at_display 
1822			 
1822				 
1822			;	ld hl,(cli_data_sp) 
1822			;	ld a, display_row_4+4 
1822			;	call display_word_at 
1822			 
1822				; display rsp 
1822			 
1822 11 05 1a			ld de, .regstatersp 
1825 3e 46			ld a, display_row_4+10 
1827 cd a8 0c			call str_at_display 
182a			 
182a				 
182a 2a b6 fb			ld hl,(cli_ret_sp) 
182d 3e 4a			ld a, display_row_4+14 
182f cd cb 17			call display_word_at 
1832			 
1832 cd b8 0c			call update_display 
1835			 
1835 cd 12 0c			call delay1s 
1838 cd 12 0c			call delay1s 
183b cd 12 0c			call delay1s 
183e			 
183e			 
183e cd 32 1e			call next_page_prompt 
1841			 
1841				; restore  
1841			 
1841 f1				pop af 
1842 e1				pop hl 
1843 c1				pop bc 
1844 d1				pop de 
1845 c9				ret 
1846			 
1846			break_point_state: 
1846 f5				push af 
1847			 
1847				; see if disabled 
1847			 
1847 3a 76 f3			ld a, (os_view_disable) 
184a fe 2a			cp '*' 
184c 20 02			jr nz, .bpsgo 
184e f1				pop af 
184f c9				ret 
1850			 
1850			.bpsgo: 
1850 f1				pop af 
1851 f5				push af 
1852 22 72 f3			ld (os_view_hl), hl 
1855 ed 53 70 f3		ld (os_view_de), de 
1859 ed 43 6e f3		ld (os_view_bc), bc 
185d e5				push hl 
185e 6f				ld l, a 
185f 26 00			ld h, 0 
1861 22 74 f3			ld (os_view_af),hl 
1864			 
1864 21 4a fe				ld hl, display_fb0 
1867 22 55 fd				ld (display_fb_active), hl 
186a e1				pop hl	 
186b			 
186b 3e 31			ld a, '1' 
186d fe 2a		.bps1:  cp '*' 
186f 20 03			jr nz, .bps1b 
1871 32 76 f3			ld (os_view_disable),a 
1874 fe 31		.bps1b:  cp '1' 
1876 20 14			jr nz, .bps2 
1878			 
1878				; display reg 
1878			 
1878				 
1878			 
1878 3a 74 f3			ld a, (os_view_af) 
187b 2a 72 f3			ld hl, (os_view_hl) 
187e ed 5b 70 f3		ld de, (os_view_de) 
1882 ed 4b 6e f3		ld bc, (os_view_bc) 
1886 cd 20 19			call display_reg_state 
1889 c3 0c 19			jp .bpschk 
188c			 
188c fe 32		.bps2:  cp '2' 
188e 20 08			jr nz, .bps3 
1890				 
1890				; display hl 
1890 2a 72 f3			ld hl, (os_view_hl) 
1893 cd 0a 1a			call display_dump_at_hl 
1896			 
1896 18 74			jr .bpschk 
1898			 
1898 fe 33		.bps3:  cp '3' 
189a 20 08			jr nz, .bps4 
189c			 
189c			        ; display de 
189c 2a 70 f3			ld hl, (os_view_de) 
189f cd 0a 1a			call display_dump_at_hl 
18a2			 
18a2 18 68			jr .bpschk 
18a4 fe 34		.bps4:  cp '4' 
18a6 20 08			jr nz, .bps5 
18a8			 
18a8			        ; display bc 
18a8 2a 6e f3			ld hl, (os_view_bc) 
18ab cd 0a 1a			call display_dump_at_hl 
18ae			 
18ae 18 5c			jr .bpschk 
18b0 fe 35		.bps5:  cp '5' 
18b2 20 08		        jr nz, .bps7 
18b4			 
18b4				; display cur ptr 
18b4 2a d0 fb			ld hl, (cli_ptr) 
18b7 cd 0a 1a			call display_dump_at_hl 
18ba			 
18ba 18 50			jr .bpschk 
18bc fe 36		.bps7:  cp '6' 
18be 20 08			jr nz, .bps8b 
18c0				 
18c0				; display cur orig ptr 
18c0 2a ce fb			ld hl, (cli_origptr) 
18c3 cd 0a 1a			call display_dump_at_hl 
18c6 18 44			jr .bpschk 
18c8 fe 37		.bps8b:  cp '7' 
18ca 20 08			jr nz, .bps9 
18cc				 
18cc				; display dsp 
18cc 2a b2 fb			ld hl, (cli_data_sp) 
18cf cd 0a 1a			call display_dump_at_hl 
18d2			 
18d2 18 38			jr .bpschk 
18d4 fe 39		.bps9:  cp '9' 
18d6 20 05			jr nz, .bps8c 
18d8				 
18d8				; display SP 
18d8			;	ld hl, sp 
18d8 cd 0a 1a			call display_dump_at_hl 
18db			 
18db 18 2f			jr .bpschk 
18dd fe 38		.bps8c:  cp '8' 
18df 20 08			jr nz, .bps8d 
18e1				 
18e1				; display rsp 
18e1 2a b6 fb			ld hl, (cli_ret_sp) 
18e4 cd 0a 1a			call display_dump_at_hl 
18e7			 
18e7 18 23			jr .bpschk 
18e9 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
18eb 20 05			jr nz, .bps8 
18ed cd 28 1c			call monitor 
18f0			 
18f0 18 1a			jr .bpschk 
18f2 fe 30		.bps8:  cp '0' 
18f4 20 16			jr nz, .bpschk 
18f6			 
18f6 21 f9 fd				ld hl, display_fb1 
18f9 22 55 fd				ld (display_fb_active), hl 
18fc cd b8 0c				call update_display 
18ff			 
18ff				;ld a, (os_view_af) 
18ff 2a 72 f3			ld hl, (os_view_hl) 
1902 ed 5b 70 f3		ld de, (os_view_de) 
1906 ed 4b 6e f3		ld bc, (os_view_bc) 
190a f1				pop af 
190b c9				ret 
190c			 
190c			.bpschk:   
190c cd 12 0c			call delay1s 
190f 3e 4f		ld a,display_row_4 + display_cols - 1 
1911 11 30 1e		        ld de, endprg 
1914 cd a8 0c			call str_at_display 
1917 cd b8 0c			call update_display 
191a cd b8 6a			call cin_wait 
191d			 
191d c3 6d 18			jp .bps1 
1920			 
1920			 
1920			display_reg_state: 
1920			 
1920				; to restore afterwards 
1920			 
1920 d5				push de 
1921 c5				push bc 
1922 e5				push hl 
1923 f5				push af 
1924			 
1924				; for use in here 
1924			 
1924 c5				push bc 
1925 d5				push de 
1926 e5				push hl 
1927 f5				push af 
1928			 
1928 cd 95 0c			call clear_display 
192b			 
192b 11 e0 19			ld de, .regstate 
192e 3e 00			ld a, display_row_1 
1930 cd a8 0c			call str_at_display 
1933			 
1933				; display debug step 
1933			 
1933			 
1933 11 b4 fe			ld de, debug_mark 
1936 3e 11			ld a, display_row_1+display_cols-3 
1938 cd a8 0c			call str_at_display 
193b			 
193b				; display a 
193b 11 fc 19			ld de, .regstatea 
193e 3e 14			ld a, display_row_2 
1940 cd a8 0c			call str_at_display 
1943			 
1943 e1				pop hl 
1944			;	ld h,0 
1944			;	ld l, a 
1944 3e 17			ld a, display_row_2+3 
1946 cd cb 17			call display_word_at 
1949			 
1949			 
1949				; display hl 
1949			 
1949			 
1949 11 f0 19			ld de, .regstatehl 
194c 3e 1e			ld a, display_row_2+10 
194e cd a8 0c			call str_at_display 
1951			 
1951 e1				pop hl 
1952 3e 21			ld a, display_row_2+13 
1954 cd cb 17			call display_word_at 
1957			 
1957				 
1957				; display de 
1957			 
1957 11 f4 19			ld de, .regstatede 
195a 3e 28			ld a, display_row_3 
195c cd a8 0c			call str_at_display 
195f			 
195f e1				pop hl 
1960			;	ld h,d 
1960			;	ld l, e 
1960 3e 2b			ld a, display_row_3+3 
1962 cd cb 17			call display_word_at 
1965			 
1965			 
1965				; display bc 
1965			 
1965 11 f8 19			ld de, .regstatebc 
1968 3e 32			ld a, display_row_3+10 
196a cd a8 0c			call str_at_display 
196d			 
196d e1				pop hl 
196e			;	ld h,b 
196e			;	ld l, c 
196e 3e 35			ld a, display_row_3+13 
1970 cd cb 17			call display_word_at 
1973			 
1973			 
1973				; display dsp 
1973			 
1973 11 00 1a			ld de, .regstatedsp 
1976 3e 3c			ld a, display_row_4 
1978 cd a8 0c			call str_at_display 
197b			 
197b				 
197b 2a b2 fb			ld hl,(cli_data_sp) 
197e 3e 40			ld a, display_row_4+4 
1980 cd cb 17			call display_word_at 
1983			 
1983				; display rsp 
1983			 
1983 11 05 1a			ld de, .regstatersp 
1986 3e 46			ld a, display_row_4+10 
1988 cd a8 0c			call str_at_display 
198b			 
198b				 
198b 2a b6 fb			ld hl,(cli_ret_sp) 
198e 3e 4a			ld a, display_row_4+14 
1990 cd cb 17			call display_word_at 
1993			 
1993 cd b8 0c			call update_display 
1996			 
1996			;	call delay1s 
1996			;	call delay1s 
1996			;	call delay1s 
1996			 
1996			 
1996			;	call next_page_prompt 
1996			 
1996				; restore  
1996			 
1996 f1				pop af 
1997 e1				pop hl 
1998 c1				pop bc 
1999 d1				pop de 
199a c9				ret 
199b			 
199b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
19af .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
19c4 .. 00		.ptrstate:	db "Ptr State",0 
19ce .. 00		.ptrcliptr:     db "cli_ptr",0 
19d6 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
19e0 .. 00		.regstate:	db "Reg State (1/0)",0 
19f0 .. 00		.regstatehl:	db "HL:",0 
19f4 .. 00		.regstatede:	db "DE:",0 
19f8 .. 00		.regstatebc:	db "BC:",0 
19fc .. 00		.regstatea:	db "A :",0 
1a00 .. 00		.regstatedsp:	db "DSP:",0 
1a05 .. 00		.regstatersp:	db "RSP:",0 
1a0a			 
1a0a			display_dump_at_hl: 
1a0a e5				push hl 
1a0b d5				push de 
1a0c c5				push bc 
1a0d f5				push af 
1a0e			 
1a0e 22 a8 f6			ld (os_cur_ptr),hl	 
1a11 cd 95 0c			call clear_display 
1a14 cd 3a 1d			call dumpcont 
1a17			;	call delay1s 
1a17			;	call next_page_prompt 
1a17			 
1a17			 
1a17 f1				pop af 
1a18 c1				pop bc 
1a19 d1				pop de 
1a1a e1				pop hl 
1a1b c9				ret 
1a1c			 
1a1c			;if ENABLE_BASIC 
1a1c			;	include "nascombasic.asm" 
1a1c			;	basic: 
1a1c			;	include "forth/FORTH.ASM" 
1a1c			;endif 
1a1c			 
1a1c			; eof 
1a1c			 
1a1c			 
# End of file firmware_diags.asm
1a1c			  
1a1c			include "firmware_prompts.asm"  
1a1c			; Prompts  
1a1c			 
1a1c			; boot messages 
1a1c			 
1a1c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1a31 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1a41			 
1a41			 
1a41			; config menus 
1a41			 
1a41 .. 00		prom_c3: db "Add Dictionary To File",0 
1a58 .. 00		prom_c2: db "Select Autoload File",0 
1a6d .. 00		prom_c2a: db "Disable Autoload File", 0 
1a83 .. 00		prom_c2b: db "Select Storage Bank",0 
1a97 .. 00		prom_c4: db "Settings",0 
1aa0 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1abb .. 00		prom_m4b:   db "Monitor",0 
1ac3 .. 00		prom_c1: db "Hardware Diags",0 
1ad2			 
1ad2			 
1ad2 .. 00		prom_notav:    db "Feature not available",0 
1ae8 .. 00		prom_empty:    db "",0 
1ae9			 
1ae9			; eof 
1ae9			 
# End of file firmware_prompts.asm
1ae9			  
1ae9			  
1ae9			; eof  
1ae9			  
# End of file firmware.asm
1ae9			 
1ae9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1ae9			;if BASE_KEV  
1ae9			;baseram: equ 08000h 
1ae9			;endif 
1ae9			 
1ae9			;if BASE_SC114 
1ae9			;baseram:     equ    endofcode 
1ae9			;endif 
1ae9			 
1ae9			 
1ae9			; start system 
1ae9			 
1ae9			coldstart: 
1ae9				; set sp 
1ae9				; di/ei 
1ae9			 
1ae9 f3				di 
1aea 31 fd ff			ld sp, tos 
1aed			;	ei 
1aed			 
1aed			 
1aed				; disable breakpoint by default 
1aed			 
1aed 3e 2a			ld a,'*' 
1aef 32 76 f3			ld (os_view_disable),a 
1af2			 
1af2				; init hardware 
1af2			 
1af2				; init keyboard and screen hardware 
1af2			 
1af2 cd 1c 00			call hardware_init 
1af5			 
1af5			 
1af5 cd 12 0c			call delay1s 
1af8 3e 30			ld a, display_row_3+8 
1afa 11 03 00			ld de, buildtime 
1afd cd a8 0c			call str_at_display 
1b00 cd b8 0c			call update_display 
1b03			 
1b03 cd 12 0c			call delay1s 
1b06 cd 12 0c			call delay1s 
1b09 cd 12 0c			call delay1s 
1b0c			 
1b0c				; detect if any keys are held down to enable breakpoints at start up 
1b0c			 
1b0c cd c9 6a			call cin  
1b0f fe 00			cp 0 
1b11 28 03			jr z, .nokeys 
1b13			 
1b13				;call hardware_diags 
1b13 cd 29 15			call config 
1b16			 
1b16			;	ld de, .bpen 
1b16			;	ld a, display_row_4 
1b16			;	call str_at_display 
1b16			;	call update_display 
1b16			; 
1b16			;	ld a,0 
1b16			;	ld (os_view_disable),a 
1b16			; 
1b16			;.bpwait: 
1b16			;	call cin 
1b16			;	cp 0 
1b16			;	jr z, .bpwait 
1b16			;	jr .nokeys 
1b16			; 
1b16			; 
1b16			;.bpen:  db "Break points enabled!",0 
1b16			 
1b16			 
1b16			 
1b16			 
1b16			 
1b16			 
1b16			.nokeys: 
1b16			 
1b16			 
1b16				 
1b16			 
1b16			;jp  testkey 
1b16			 
1b16			;call storage_get_block_0 
1b16			; 
1b16			;ld hl, 0 
1b16			;ld de, store_page 
1b16			;call storage_read_block 
1b16			 
1b16				 
1b16			;ld hl, 10 
1b16			;ld de, store_page 
1b16			;call storage_read_block 
1b16			 
1b16			 
1b16			 
1b16			 
1b16			 
1b16			;stop:	nop 
1b16			;	jp stop 
1b16			 
1b16			 
1b16			 
1b16			main: 
1b16 cd 95 0c			call clear_display 
1b19 cd b8 0c			call update_display 
1b1c			 
1b1c			 
1b1c			 
1b1c			;	call testlcd 
1b1c			 
1b1c			 
1b1c			 
1b1c cd f8 21			call forth_init 
1b1f			 
1b1f			 
1b1f			warmstart: 
1b1f cd ce 21			call forth_warmstart 
1b22			 
1b22				; run startup word load 
1b22			        ; TODO prevent this running at warmstart after crash  
1b22			 
1b22				if STARTUP_ENABLE 
1b22					if STORAGE_SE 
1b22 cd fa 67					call forth_autoload 
1b25					endif 
1b25 cd 09 65				call forth_startup 
1b28			 
1b28			 
1b28				endif 
1b28			 
1b28				; show free memory after boot 
1b28 11 c2 1b			ld de, freeram 
1b2b 3e 00			ld a, display_row_1 
1b2d cd a8 0c			call str_at_display 
1b30			 
1b30			; Or use heap_size word???? 
1b30 21 6b f3			ld hl, heap_end 
1b33 11 0e 80			ld de, heap_start 
1b36 ed 52			sbc hl, de 
1b38 e5				push hl 
1b39 7c				ld a,h	         	 
1b3a 21 8a f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b3d cd ca 11			call hexout 
1b40 e1			   	pop hl 
1b41			 
1b41 7d				ld a,l 
1b42 21 8c f6			ld hl, os_word_scratch+2 
1b45 cd ca 11			call hexout 
1b48 21 8e f6			ld hl, os_word_scratch+4 
1b4b 3e 00			ld a, 0 
1b4d 77				ld (hl),a 
1b4e 11 8a f6			ld de, os_word_scratch 
1b51 3e 0d			ld a, display_row_1 + 13 
1b53 cd a8 0c			call str_at_display 
1b56 cd b8 0c			call update_display 
1b59			 
1b59			 
1b59				;call demo 
1b59			 
1b59			 
1b59				; init scratch input area for cli commands 
1b59			 
1b59 21 ac f6			ld hl, os_cli_cmd 
1b5c 3e 00			ld a,0 
1b5e 77				ld (hl),a 
1b5f 23				inc hl 
1b60 77				ld (hl),a 
1b61			 
1b61 3e 00			ld a,0 
1b63 32 ab f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1b66			 
1b66 32 a8 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1b69 32 a9 f6			ld (os_cur_ptr+1),a	 
1b6c			 
1b6c 32 8a f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1b6f 32 8b f6			ld (os_word_scratch+1),a	 
1b72				 
1b72			 
1b72				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b72 21 ac f6			ld hl, os_cli_cmd 
1b75			 
1b75 3e 00			ld a, 0		 ; init cli input 
1b77 77				ld (hl), a 
1b78 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b7a			cli: 
1b7a				; show cli prompt 
1b7a				;push af 
1b7a				;ld a, 0 
1b7a				;ld de, prompt 
1b7a				;call str_at_display 
1b7a			 
1b7a				;call update_display 
1b7a				;pop af 
1b7a				;inc a 
1b7a				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b7a 0e 00			ld c, 0 
1b7c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1b7e 1e 28			ld e, 40 
1b80			 
1b80 21 ac f6			ld hl, os_cli_cmd 
1b83			 
1b83				STACKFRAME OFF $fefe $9f9f 
1b83				if DEBUG_STACK_IMB 
1b83					if OFF 
1b83						exx 
1b83						ld de, $fefe 
1b83						ld a, d 
1b83						ld hl, curframe 
1b83						call hexout 
1b83						ld a, e 
1b83						ld hl, curframe+2 
1b83						call hexout 
1b83						ld hl, $fefe 
1b83						push hl 
1b83						ld hl, $9f9f 
1b83						push hl 
1b83						exx 
1b83					endif 
1b83				endif 
1b83			endm 
# End of macro STACKFRAME
1b83			 
1b83 cd f6 0e			call input_str 
1b86			 
1b86				STACKFRAMECHK OFF $fefe $9f9f 
1b86				if DEBUG_STACK_IMB 
1b86					if OFF 
1b86						exx 
1b86						ld hl, $9f9f 
1b86						pop de   ; $9f9f 
1b86						call cmp16 
1b86						jr nz, .spnosame 
1b86						ld hl, $fefe 
1b86						pop de   ; $fefe 
1b86						call cmp16 
1b86						jr z, .spfrsame 
1b86						.spnosame: call showsperror 
1b86						.spfrsame: nop 
1b86						exx 
1b86					endif 
1b86				endif 
1b86			endm 
# End of macro STACKFRAMECHK
1b86			 
1b86				; copy input to last command 
1b86			 
1b86 21 ac f6			ld hl, os_cli_cmd 
1b89 11 ab f7			ld de, os_last_cmd 
1b8c 01 ff 00			ld bc, 255 
1b8f ed b0			ldir 
1b91			 
1b91				; wipe current buffer 
1b91			 
1b91			;	ld a, 0 
1b91			;	ld hl, os_cli_cmd 
1b91			;	ld de, os_cli_cmd+1 
1b91			;	ld bc, 254 
1b91			;	ldir 
1b91				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1b91			;	call strcpy 
1b91			;	ld a, 0 
1b91			;	ld (hl), a 
1b91			;	inc hl 
1b91			;	ld (hl), a 
1b91			;	inc hl 
1b91			;	ld (hl), a 
1b91			 
1b91				; switch frame buffer to program  
1b91			 
1b91 21 f9 fd				ld hl, display_fb1 
1b94 22 55 fd				ld (display_fb_active), hl 
1b97			 
1b97			;	nop 
1b97				STACKFRAME ON $fbfe $8f9f 
1b97				if DEBUG_STACK_IMB 
1b97					if ON 
1b97						exx 
1b97						ld de, $fbfe 
1b97						ld a, d 
1b97						ld hl, curframe 
1b97						call hexout 
1b97						ld a, e 
1b97						ld hl, curframe+2 
1b97						call hexout 
1b97						ld hl, $fbfe 
1b97						push hl 
1b97						ld hl, $8f9f 
1b97						push hl 
1b97						exx 
1b97					endif 
1b97				endif 
1b97			endm 
# End of macro STACKFRAME
1b97				; first time into the parser so pass over the current scratch pad 
1b97 21 ac f6			ld hl,os_cli_cmd 
1b9a				; tokenise the entered statement(s) in HL 
1b9a cd 76 22			call forthparse 
1b9d			        ; exec forth statements in top of return stack 
1b9d cd b6 22			call forthexec 
1ba0				;call forthexec_cleanup 
1ba0			;	call parsenext 
1ba0			 
1ba0				STACKFRAMECHK ON $fbfe $8f9f 
1ba0				if DEBUG_STACK_IMB 
1ba0					if ON 
1ba0						exx 
1ba0						ld hl, $8f9f 
1ba0						pop de   ; $8f9f 
1ba0						call cmp16 
1ba0						jr nz, .spnosame 
1ba0						ld hl, $fbfe 
1ba0						pop de   ; $fbfe 
1ba0						call cmp16 
1ba0						jr z, .spfrsame 
1ba0						.spnosame: call showsperror 
1ba0						.spfrsame: nop 
1ba0						exx 
1ba0					endif 
1ba0				endif 
1ba0			endm 
# End of macro STACKFRAMECHK
1ba0				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1ba0			 
1ba0 3e 3c			ld a, display_row_4 
1ba2 11 d4 1b			ld de, endprog 
1ba5			 
1ba5 cd b8 0c			call update_display		 
1ba8			 
1ba8 cd 32 1e			call next_page_prompt 
1bab			 
1bab				; switch frame buffer to cli 
1bab			 
1bab 21 4a fe				ld hl, display_fb0 
1bae 22 55 fd				ld (display_fb_active), hl 
1bb1			 
1bb1			 
1bb1 cd 95 0c		        call clear_display 
1bb4 cd b8 0c			call update_display		 
1bb7			 
1bb7 21 ac f6			ld hl, os_cli_cmd 
1bba			 
1bba 3e 00			ld a, 0		 ; init cli input 
1bbc 77				ld (hl), a 
1bbd			 
1bbd				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1bbd			 
1bbd				; now on last line 
1bbd			 
1bbd				; TODO scroll screen up 
1bbd			 
1bbd				; TODO instead just clear screen and place at top of screen 
1bbd			 
1bbd			;	ld a, 0 
1bbd			;	ld (f_cursor_ptr),a 
1bbd			 
1bbd				;call clear_display 
1bbd				;call update_display 
1bbd			 
1bbd				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bbd 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bbf c3 7a 1b			jp cli 
1bc2			 
1bc2 .. 00		freeram: db "Free bytes: $",0 
1bd0 ..			asc: db "1A2F" 
1bd4 .. 00		endprog: db "End prog...",0 
1be0			 
1be0			testenter2:   
1be0 21 b7 f3			ld hl,scratch+50 
1be3 22 a8 f6			ld (os_cur_ptr),hl 
1be6 c3 7a 1b			jp cli 
1be9			 
1be9			testenter:  
1be9			 
1be9 21 d0 1b			ld hl,asc 
1bec			;	ld a,(hl) 
1bec			;	call nibble2val 
1bec cd 20 12			call get_byte 
1bef			 
1bef			 
1bef			;	ld a,(hl) 
1bef			;	call atohex 
1bef			 
1bef			;	call fourehexhl 
1bef 32 b7 f3			ld (scratch+50),a 
1bf2			 
1bf2			 
1bf2			 
1bf2 21 d2 1b			ld hl,asc+2 
1bf5			;	ld a, (hl) 
1bf5			;	call nibble2val 
1bf5 cd 20 12			call get_byte 
1bf8			 
1bf8			;	call fourehexhl 
1bf8 32 b9 f3			ld (scratch+52),a 
1bfb				 
1bfb 21 b7 f3			ld hl,scratch+50 
1bfe 22 a8 f6			ld (os_cur_ptr),hl 
1c01 c3 7a 1b			jp cli 
1c04			 
1c04			enter:	 
1c04 3a 89 f3			ld a,(scratch+4) 
1c07 fe 00			cp 0 
1c09 28 0c			jr z, .entercont 
1c0b				; no, not a null term line so has an address to work out.... 
1c0b			 
1c0b 21 87 f3			ld hl,scratch+2 
1c0e cd 80 12			call get_word_hl 
1c11			 
1c11 22 a8 f6			ld (os_cur_ptr),hl	 
1c14 c3 7a 1b			jp cli 
1c17			 
1c17			 
1c17			.entercont:  
1c17			 
1c17 21 87 f3			ld hl, scratch+2 
1c1a cd 20 12			call get_byte 
1c1d			 
1c1d 2a a8 f6		   	ld hl,(os_cur_ptr) 
1c20 77					ld (hl),a 
1c21 23					inc hl 
1c22 22 a8 f6				ld (os_cur_ptr),hl 
1c25				 
1c25			; get byte  
1c25			 
1c25			 
1c25 c3 7a 1b			jp cli 
1c28			 
1c28			 
1c28			; basic monitor support 
1c28			 
1c28			monitor: 
1c28				;  
1c28 cd 95 0c			call clear_display 
1c2b 3e 00			ld a, 0 
1c2d 11 75 1c			ld de, .monprompt 
1c30 cd a8 0c			call str_at_display 
1c33 cd b8 0c			call update_display 
1c36			 
1c36				; get a monitor command 
1c36			 
1c36 0e 00			ld c, 0     ; entry at top left 
1c38 16 64			ld d, 100   ; max buffer size 
1c3a 1e 0f			ld e, 15    ; input scroll area 
1c3c 3e 00			ld a, 0     ; init string 
1c3e 21 83 f5			ld hl, os_input 
1c41 77				ld (hl), a 
1c42 23				inc hl 
1c43 77				ld (hl), a 
1c44 21 83 f5			ld hl, os_input 
1c47 3e 01			ld a, 1     ; init string 
1c49 cd f6 0e			call input_str 
1c4c			 
1c4c cd 95 0c		        call clear_display 
1c4f cd b8 0c			call update_display		 
1c52			 
1c52 3a 83 f5			ld a, (os_input) 
1c55 cd 1e 13			call toUpper 
1c58 fe 48		        cp 'H' 
1c5a 28 6f		        jr z, .monhelp 
1c5c fe 44			cp 'D'		; dump 
1c5e ca ec 1c			jp z, .mondump	 
1c61 fe 43			cp 'C'		; dump 
1c63 ca 06 1d			jp z, .moncdump	 
1c66 fe 4d			cp 'M'		; dump 
1c68 ca 77 1c			jp z, .moneditstart 
1c6b fe 55			cp 'U'		; dump 
1c6d 28 14			jr z, .monedit	 
1c6f fe 51			cp 'Q'		; dump 
1c71 c8				ret z	 
1c72			 
1c72			 
1c72				; TODO "S" to access symbol by name and not need the address 
1c72				; TODO "F" to find a string in memory 
1c72			 
1c72 c3 28 1c			jp monitor 
1c75			 
1c75 .. 00		.monprompt: db ">", 0 
1c77			 
1c77			.moneditstart: 
1c77				; get starting address 
1c77			 
1c77 21 85 f5			ld hl,os_input+2 
1c7a cd 80 12			call get_word_hl 
1c7d			 
1c7d 22 a8 f6			ld (os_cur_ptr),hl	 
1c80			 
1c80 c3 28 1c			jp monitor 
1c83			 
1c83			.monedit: 
1c83				; get byte to load 
1c83			 
1c83 21 85 f5			ld hl,os_input+2 
1c86 cd 20 12			call get_byte 
1c89			 
1c89				; get address to update 
1c89 2a a8 f6			ld hl, (os_cur_ptr) 
1c8c			 
1c8c				; update byte 
1c8c			 
1c8c 77				ld (hl), a 
1c8d			 
1c8d				; move to next address and save it 
1c8d			 
1c8d 23				inc hl 
1c8e 22 a8 f6			ld (os_cur_ptr),hl	 
1c91			 
1c91 c3 28 1c			jp monitor 
1c94			 
1c94			 
1c94 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ca8 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1cc4 .. 00		.monhelptext3:  db "Q-Quit",0 
1ccb			        
1ccb			.monhelp: 
1ccb 3e 00			ld a, display_row_1 
1ccd 11 94 1c		        ld de, .monhelptext1 
1cd0			 
1cd0 cd a8 0c			call str_at_display 
1cd3 3e 14			ld a, display_row_2 
1cd5 11 a8 1c		        ld de, .monhelptext2 
1cd8					 
1cd8 cd a8 0c			call str_at_display 
1cdb 3e 28			ld a, display_row_3 
1cdd 11 c4 1c		        ld de, .monhelptext3 
1ce0					 
1ce0 cd a8 0c			call str_at_display 
1ce3 cd b8 0c			call update_display		 
1ce6			 
1ce6 cd 32 1e			call next_page_prompt 
1ce9 c3 28 1c			jp monitor 
1cec			 
1cec			.mondump:    
1cec 21 85 f5			ld hl,os_input+2 
1cef cd 80 12			call get_word_hl 
1cf2			 
1cf2 22 a8 f6			ld (os_cur_ptr),hl	 
1cf5 cd 3a 1d			call dumpcont 
1cf8 3e 3c			ld a, display_row_4 
1cfa 11 d4 1b			ld de, endprog 
1cfd			 
1cfd cd b8 0c			call update_display		 
1d00			 
1d00 cd 32 1e			call next_page_prompt 
1d03 c3 28 1c			jp monitor 
1d06			.moncdump: 
1d06 cd 3a 1d			call dumpcont 
1d09 3e 3c			ld a, display_row_4 
1d0b 11 d4 1b			ld de, endprog 
1d0e			 
1d0e cd b8 0c			call update_display		 
1d11			 
1d11 cd 32 1e			call next_page_prompt 
1d14 c3 28 1c			jp monitor 
1d17			 
1d17			 
1d17			; TODO symbol access  
1d17			 
1d17			.symbols:     ;; A list of symbols that can be called up  
1d17 4a fe			dw display_fb0 
1d19 .. 00			db "fb0",0  
1d1d 07 fc		     	dw store_page 
1d1f .. 00			db "store_page",0 
1d2a			 
1d2a			 
1d2a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1d2a			 
1d2a 3a 86 f3			ld a,(scratch+1) 
1d2d fe 00			cp 0 
1d2f 28 09			jr z, dumpcont 
1d31			 
1d31				; no, not a null term line so has an address to work out.... 
1d31			 
1d31 21 87 f3			ld hl,scratch+2 
1d34 cd 80 12			call get_word_hl 
1d37			 
1d37 22 a8 f6			ld (os_cur_ptr),hl	 
1d3a			 
1d3a			 
1d3a			 
1d3a			dumpcont: 
1d3a			 
1d3a				; dump bytes at ptr 
1d3a			 
1d3a			 
1d3a 3e 00			ld a, display_row_1 
1d3c 2a 55 fd			ld hl, (display_fb_active) 
1d3f cd c9 0e			call addatohl 
1d42 cd 6a 1d			call .dumpbyterow 
1d45			 
1d45 3e 14			ld a, display_row_2 
1d47 2a 55 fd			ld hl, (display_fb_active) 
1d4a cd c9 0e			call addatohl 
1d4d cd 6a 1d			call .dumpbyterow 
1d50			 
1d50			 
1d50 3e 28			ld a, display_row_3 
1d52 2a 55 fd			ld hl, (display_fb_active) 
1d55 cd c9 0e			call addatohl 
1d58 cd 6a 1d			call .dumpbyterow 
1d5b			 
1d5b 3e 3c			ld a, display_row_4 
1d5d 2a 55 fd			ld hl, (display_fb_active) 
1d60 cd c9 0e			call addatohl 
1d63 cd 6a 1d			call .dumpbyterow 
1d66			 
1d66 cd b8 0c			call update_display 
1d69			;		jp cli 
1d69 c9				ret 
1d6a			 
1d6a			.dumpbyterow: 
1d6a			 
1d6a				;push af 
1d6a			 
1d6a e5				push hl 
1d6b			 
1d6b				; calc where to poke the ascii 
1d6b			if display_cols == 20 
1d6b 3e 10			ld a, 16 
1d6d			else 
1d6d				ld a, 31 
1d6d			endif 
1d6d			 
1d6d cd c9 0e			call addatohl 
1d70 22 8a f6			ld (os_word_scratch),hl  		; save pos for later 
1d73			 
1d73			 
1d73			; display decoding address 
1d73 2a a8 f6		   	ld hl,(os_cur_ptr) 
1d76			 
1d76 7c				ld a,h 
1d77 e1				pop hl 
1d78 e5				push hl 
1d79			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d79 cd ca 11			call hexout 
1d7c 2a a8 f6		   	ld hl,(os_cur_ptr) 
1d7f			 
1d7f 7d				ld a,l 
1d80 e1				pop hl 
1d81 23				inc hl 
1d82 23				inc hl 
1d83 e5				push hl 
1d84			;	ld hl, os_word_scratch+2 
1d84 cd ca 11			call hexout 
1d87 e1				pop hl 
1d88 23				inc hl 
1d89 23				inc hl 
1d8a				;ld hl, os_word_scratch+4 
1d8a 3e 3a			ld a, ':' 
1d8c 77				ld (hl),a 
1d8d 23				inc hl 
1d8e				;ld a, 0 
1d8e				;ld (hl),a 
1d8e				;ld de, os_word_scratch 
1d8e				;pop af 
1d8e				;push af 
1d8e			;		ld a, display_row_2 
1d8e			;		call str_at_display 
1d8e			;		call update_display 
1d8e			 
1d8e			 
1d8e			;pop af 
1d8e			;	add 5 
1d8e			 
1d8e			if display_cols == 20 
1d8e 06 04			ld b, 4 
1d90			else 
1d90				ld b, 8 
1d90			endif	 
1d90			 
1d90			.dumpbyte: 
1d90 c5				push bc 
1d91 e5				push hl 
1d92			 
1d92			 
1d92 2a a8 f6		   	ld hl,(os_cur_ptr) 
1d95 7e					ld a,(hl) 
1d96			 
1d96					; poke the ascii to display 
1d96 2a 8a f6				ld hl,(os_word_scratch) 
1d99 77					ld (hl),a 
1d9a 23					inc hl 
1d9b 22 8a f6				ld (os_word_scratch),hl 
1d9e			 
1d9e					 
1d9e			 
1d9e			 
1d9e e1					pop hl 
1d9f e5					push hl 
1da0			 
1da0 cd ca 11				call hexout 
1da3			 
1da3					 
1da3 2a a8 f6		   	ld hl,(os_cur_ptr) 
1da6 23				inc hl 
1da7 22 a8 f6		   	ld (os_cur_ptr),hl 
1daa			 
1daa e1					pop hl 
1dab 23					inc hl 
1dac 23					inc hl 
1dad 23					inc hl 
1dae			 
1dae			 
1dae			 
1dae					;ld a,0 
1dae					;ld (os_word_scratch+2),a 
1dae					;pop af 
1dae					;push af 
1dae			 
1dae					;ld de, os_word_scratch 
1dae					;call str_at_display 
1dae			;		call update_display 
1dae			;		pop af 
1dae c1					pop bc 
1daf c6 03				add 3 
1db1 10 dd			djnz .dumpbyte 
1db3			 
1db3				 
1db3			 
1db3 c9				ret 
1db4			 
1db4			jump:	 
1db4			 
1db4 21 87 f3			ld hl,scratch+2 
1db7 cd 80 12			call get_word_hl 
1dba				;ld hl,(scratch+2) 
1dba				;call fourehexhl 
1dba			 
1dba 22 a8 f6			ld (os_cur_ptr),hl	 
1dbd			 
1dbd e9				jp (hl) 
1dbe			 
1dbe			 
1dbe			 
1dbe			; TODO implement a basic monitor mode to start with 
1dbe			 
1dbe			 
1dbe			 
1dbe			 
1dbe			 
1dbe			 
1dbe			 
1dbe			 
1dbe			 
1dbe			; testing and demo code during development 
1dbe			 
1dbe			 
1dbe .. 00		str1: db "Enter some text...",0 
1dd1 .. 00		clear: db "                    ",0 
1de6			 
1de6			demo: 
1de6			 
1de6			 
1de6			 
1de6			;	call update_display 
1de6			 
1de6				; init scratch input area for testing 
1de6 21 85 f3			ld hl, scratch	 
1de9 3e 00			ld a,0 
1deb 77				ld (hl),a 
1dec			 
1dec			 
1dec 3e 14		            LD   A, display_row_2 
1dee			;            CALL fLCD_Pos       ;Position cursor to location in A 
1dee 11 be 1d		            LD   DE, str1 
1df1 cd a8 0c			call str_at_display 
1df4			 
1df4			;            CALL fLCD_Str       ;Display string pointed to by DE 
1df4			cloop:	 
1df4 3e 28		            LD   A, display_row_3 
1df6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1df6 11 d1 1d		            LD   DE, clear 
1df9			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1df9 cd a8 0c				call str_at_display 
1dfc 3e 3c			ld a, display_row_4 
1dfe 11 2e 1e			ld de, prompt 
1e01			 
1e01 cd a8 0c				call str_at_display 
1e04 cd b8 0c			call update_display 
1e07			 
1e07 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e09 16 0a			ld d, 10 
1e0b 21 85 f3			ld hl, scratch	 
1e0e cd f6 0e			call input_str 
1e11			 
1e11			;	call clear_display 
1e11			;'	call update_display 
1e11			 
1e11 3e 00		            LD   A, display_row_1 
1e13			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e13 11 d1 1d		            LD   DE, clear 
1e16 cd a8 0c				call str_at_display 
1e19			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e19 3e 00		            LD   A, display_row_1 
1e1b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e1b 11 85 f3		            LD   DE, scratch 
1e1e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e1e cd a8 0c				call str_at_display 
1e21 cd b8 0c			call update_display 
1e24			 
1e24 3e 00				ld a,0 
1e26 21 85 f3			ld hl, scratch 
1e29 77				ld (hl),a 
1e2a			 
1e2a 00				nop 
1e2b c3 f4 1d			jp cloop 
1e2e			 
1e2e			 
1e2e			 
1e2e			; OS Prompt 
1e2e			 
1e2e .. 00		prompt: db ">",0 
1e30 .. 00		endprg: db "?",0 
1e32			 
1e32			 
1e32			; handy next page prompt 
1e32			next_page_prompt: 
1e32 e5				push hl 
1e33 d5				push de 
1e34 f5				push af 
1e35 c5				push bc 
1e36			 
1e36 3e 4f			ld a,display_row_4 + display_cols - 1 
1e38 11 30 1e		        ld de, endprg 
1e3b cd a8 0c			call str_at_display 
1e3e cd b8 0c			call update_display 
1e41 cd b8 6a			call cin_wait 
1e44 c1				pop bc 
1e45 f1				pop af 
1e46 d1				pop de 
1e47 e1				pop hl 
1e48			 
1e48			 
1e48 c9				ret 
1e49			 
1e49			 
1e49			; forth parser 
1e49			 
1e49			; My forth kernel 
1e49			include "forth_kernel.asm" 
1e49			; 
1e49			; kernel to the forth OS 
1e49			 
1e49			DS_TYPE_STR: equ 1     ; string type 
1e49			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1e49			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1e49			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1e49			 
1e49			FORTH_PARSEV1: equ 0 
1e49			FORTH_PARSEV2: equ 0 
1e49			FORTH_PARSEV3: equ 0 
1e49			FORTH_PARSEV4: equ 0 
1e49			FORTH_PARSEV5: equ 1 
1e49			 
1e49			;if FORTH_PARSEV5 
1e49			;	FORTH_END_BUFFER: equ 0 
1e49			;else 
1e49			FORTH_END_BUFFER: equ 127 
1e49			;endif 
1e49			 
1e49			FORTH_TRUE: equ 1 
1e49			FORTH_FALSE: equ 0 
1e49			 
1e49			if FORTH_PARSEV4 
1e49			include "forth_stackops.asm" 
1e49			endif 
1e49			 
1e49			if FORTH_PARSEV5 
1e49			include "forth_stackopsv5.asm" 
1e49			 
1e49			; Stack operations for v5 parser on wards 
1e49			; * DATA stack 
1e49			; * LOOP stack 
1e49			; * RETURN stack 
1e49			 
1e49			 
1e49			 
1e49			FORTH_CHK_DSP_UNDER: macro 
1e49				push hl 
1e49				push de 
1e49				ld hl,(cli_data_sp) 
1e49				ld de, cli_data_stack 
1e49				call cmp16 
1e49				jp c, fault_dsp_under 
1e49				pop de 
1e49				pop hl 
1e49				endm 
1e49			 
1e49			 
1e49			FORTH_CHK_RSP_UNDER: macro 
1e49				push hl 
1e49				push de 
1e49				ld hl,(cli_ret_sp) 
1e49				ld de, cli_ret_stack 
1e49				call cmp16 
1e49				jp c, fault_rsp_under 
1e49				pop de 
1e49				pop hl 
1e49				endm 
1e49			 
1e49			FORTH_CHK_LOOP_UNDER: macro 
1e49				push hl 
1e49				push de 
1e49				ld hl,(cli_loop_sp) 
1e49				ld de, cli_loop_stack 
1e49				call cmp16 
1e49				jp c, fault_loop_under 
1e49				pop de 
1e49				pop hl 
1e49				endm 
1e49			 
1e49			FORTH_ERR_TOS_NOTSTR: macro 
1e49				; TOSO might need more for checks when used 
1e49				push af 
1e49				ld a,(hl) 
1e49				cp DS_TYPE_STR 
1e49				jp nz, type_faultn   
1e49				pop af 
1e49				endm 
1e49			 
1e49			FORTH_ERR_TOS_NOTNUM: macro 
1e49				push af 
1e49				ld a,(hl) 
1e49				cp DS_TYPE_INUM 
1e49				jp nz, type_faultn   
1e49				pop af 
1e49				endm 
1e49			 
1e49			 
1e49			; increase data stack pointer and save hl to it 
1e49				 
1e49			FORTH_DSP_NEXT: macro 
1e49				call macro_forth_dsp_next 
1e49				endm 
1e49			 
1e49			 
1e49			macro_forth_dsp_next: 
1e49				if DEBUG_FORTH_STACK_GUARD 
1e49 cd d3 65				call check_stacks 
1e4c				endif 
1e4c e5				push hl 
1e4d d5				push de 
1e4e eb				ex de,hl 
1e4f 2a b2 fb			ld hl,(cli_data_sp) 
1e52 23				inc hl 
1e53 23				inc hl 
1e54			 
1e54			; PARSEV5 
1e54 23				inc hl 
1e55 22 b2 fb			ld (cli_data_sp),hl 
1e58 73				ld (hl), e 
1e59 23				inc hl 
1e5a 72				ld (hl), d 
1e5b d1				pop de 
1e5c e1				pop hl 
1e5d				if DEBUG_FORTH_STACK_GUARD 
1e5d cd d3 65				call check_stacks 
1e60				endif 
1e60 c9				ret 
1e61			 
1e61			 
1e61			; increase ret stack pointer and save hl to it 
1e61				 
1e61			FORTH_RSP_NEXT: macro 
1e61				call macro_forth_rsp_next 
1e61				endm 
1e61			 
1e61			macro_forth_rsp_next: 
1e61				if DEBUG_FORTH_STACK_GUARD 
1e61 cd d3 65				call check_stacks 
1e64				endif 
1e64 e5				push hl 
1e65 d5				push de 
1e66 eb				ex de,hl 
1e67 2a b6 fb			ld hl,(cli_ret_sp) 
1e6a 23				inc hl 
1e6b 23				inc hl 
1e6c 22 b6 fb			ld (cli_ret_sp),hl 
1e6f 73				ld (hl), e 
1e70 23				inc hl 
1e71 72				ld (hl), d 
1e72 d1				pop de 
1e73 e1				pop hl 
1e74				if DEBUG_FORTH_STACK_GUARD 
1e74 cd d3 65				call check_stacks 
1e77				endif 
1e77 c9				ret 
1e78			 
1e78			; get current ret stack pointer and save to hl  
1e78				 
1e78			FORTH_RSP_TOS: macro 
1e78				call macro_forth_rsp_tos 
1e78				endm 
1e78			 
1e78			macro_forth_rsp_tos: 
1e78				;push de 
1e78 2a b6 fb			ld hl,(cli_ret_sp) 
1e7b cd b3 1e			call loadhlptrtohl 
1e7e				;ld e, (hl) 
1e7e				;inc hl 
1e7e				;ld d, (hl) 
1e7e				;ex de, hl 
1e7e					if DEBUG_FORTH_WORDS 
1e7e			;			DMARK "RST" 
1e7e						CALLMONITOR 
1e7e cd 46 18			call break_point_state  
1e81				endm  
# End of macro CALLMONITOR
1e81					endif 
1e81				;pop de 
1e81 c9				ret 
1e82			 
1e82			; pop ret stack pointer 
1e82				 
1e82			FORTH_RSP_POP: macro 
1e82				call macro_forth_rsp_pop 
1e82				endm 
1e82			 
1e82			 
1e82			macro_forth_rsp_pop: 
1e82				if DEBUG_FORTH_STACK_GUARD 
1e82			;		DMARK "RPP" 
1e82 cd d3 65				call check_stacks 
1e85					FORTH_CHK_RSP_UNDER 
1e85 e5				push hl 
1e86 d5				push de 
1e87 2a b6 fb			ld hl,(cli_ret_sp) 
1e8a 11 70 fb			ld de, cli_ret_stack 
1e8d cd e7 0e			call cmp16 
1e90 da e7 66			jp c, fault_rsp_under 
1e93 d1				pop de 
1e94 e1				pop hl 
1e95				endm 
# End of macro FORTH_CHK_RSP_UNDER
1e95				endif 
1e95 e5				push hl 
1e96 2a b6 fb			ld hl,(cli_ret_sp) 
1e99			 
1e99			 
1e99				if FORTH_ENABLE_FREE 
1e99			 
1e99					; get pointer 
1e99			 
1e99					push de 
1e99					push hl 
1e99			 
1e99					ld e, (hl) 
1e99					inc hl 
1e99					ld d, (hl) 
1e99			 
1e99					ex de, hl 
1e99					call free 
1e99			 
1e99					pop hl 
1e99					pop de 
1e99			 
1e99			 
1e99				endif 
1e99			 
1e99			 
1e99 2b				dec hl 
1e9a 2b				dec hl 
1e9b 22 b6 fb			ld (cli_ret_sp), hl 
1e9e				; do stack underflow checks 
1e9e e1				pop hl 
1e9f				if DEBUG_FORTH_STACK_GUARD 
1e9f cd d3 65				call check_stacks 
1ea2					FORTH_CHK_RSP_UNDER 
1ea2 e5				push hl 
1ea3 d5				push de 
1ea4 2a b6 fb			ld hl,(cli_ret_sp) 
1ea7 11 70 fb			ld de, cli_ret_stack 
1eaa cd e7 0e			call cmp16 
1ead da e7 66			jp c, fault_rsp_under 
1eb0 d1				pop de 
1eb1 e1				pop hl 
1eb2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1eb2				endif 
1eb2 c9				ret 
1eb3			 
1eb3			 
1eb3			 
1eb3			; routine to load word pointed to by hl into hl 
1eb3			 
1eb3			loadhlptrtohl: 
1eb3			 
1eb3 d5				push de 
1eb4 5e				ld e, (hl) 
1eb5 23				inc hl 
1eb6 56				ld d, (hl) 
1eb7 eb				ex de, hl 
1eb8 d1				pop de 
1eb9			 
1eb9 c9				ret 
1eba			 
1eba			 
1eba			 
1eba			 
1eba			 
1eba			; push a number held in HL onto the data stack 
1eba			; entry point for pushing a value when already in hl used in function above 
1eba			 
1eba			forth_push_numhl: 
1eba			 
1eba e5				push hl    ; save value to push 
1ebb			 
1ebb			if DEBUG_FORTH_PUSH 
1ebb				; see if disabled 
1ebb			 
1ebb			 
1ebb f5				push af 
1ebc 3a 76 f3			ld a, (os_view_disable) 
1ebf fe 2a			cp '*' 
1ec1 28 34			jr z, .pskip2 
1ec3 e5				push hl 
1ec4 e5			push hl 
1ec5 cd 95 0c			call clear_display 
1ec8 e1			pop hl 
1ec9 7c				ld a,h 
1eca 21 8a f6			ld hl, os_word_scratch 
1ecd cd ca 11			call hexout 
1ed0 e1				pop hl 
1ed1 7d				ld a,l 
1ed2 21 8c f6			ld hl, os_word_scratch+2 
1ed5 cd ca 11			call hexout 
1ed8			 
1ed8 21 8e f6			ld hl, os_word_scratch+4 
1edb 3e 00			ld a,0 
1edd 77				ld (hl),a 
1ede 11 8a f6			ld de,os_word_scratch 
1ee1 3e 14				ld a, display_row_2 
1ee3 cd a8 0c				call str_at_display 
1ee6 11 8a 54			ld de, .push_num 
1ee9 3e 00			ld a, display_row_1 
1eeb			 
1eeb cd a8 0c				call str_at_display 
1eee			 
1eee			 
1eee cd b8 0c			call update_display 
1ef1 cd 12 0c			call delay1s 
1ef4 cd 12 0c			call delay1s 
1ef7			.pskip2:  
1ef7			 
1ef7 f1				pop af 
1ef8			endif	 
1ef8			 
1ef8			 
1ef8				FORTH_DSP_NEXT 
1ef8 cd 49 1e			call macro_forth_dsp_next 
1efb				endm 
# End of macro FORTH_DSP_NEXT
1efb			 
1efb 2a b2 fb			ld hl, (cli_data_sp) 
1efe			 
1efe				; save item type 
1efe 3e 02			ld a,  DS_TYPE_INUM 
1f00 77				ld (hl), a 
1f01 23				inc hl 
1f02			 
1f02				; get word off stack 
1f02 d1				pop de 
1f03 7b				ld a,e 
1f04 77				ld (hl), a 
1f05 23				inc hl 
1f06 7a				ld a,d 
1f07 77				ld (hl), a 
1f08			 
1f08			if DEBUG_FORTH_PUSH 
1f08 2b				dec hl 
1f09 2b				dec hl 
1f0a 2b				dec hl 
1f0b						DMARK "PH5" 
1f0b f5				push af  
1f0c 3a 20 1f			ld a, (.dmark)  
1f0f 32 b4 fe			ld (debug_mark),a  
1f12 3a 21 1f			ld a, (.dmark+1)  
1f15 32 b5 fe			ld (debug_mark+1),a  
1f18 3a 22 1f			ld a, (.dmark+2)  
1f1b 32 b6 fe			ld (debug_mark+2),a  
1f1e 18 03			jr .pastdmark  
1f20 ..			.dmark: db "PH5"  
1f23 f1			.pastdmark: pop af  
1f24			endm  
# End of macro DMARK
1f24				CALLMONITOR 
1f24 cd 46 18			call break_point_state  
1f27				endm  
# End of macro CALLMONITOR
1f27			endif	 
1f27			 
1f27 c9				ret 
1f28			 
1f28			 
1f28			; Push a string to stack pointed to by hl 
1f28			 
1f28			forth_push_str: 
1f28			 
1f28			if DEBUG_FORTH_PUSH 
1f28						DMARK "PSQ" 
1f28 f5				push af  
1f29 3a 3d 1f			ld a, (.dmark)  
1f2c 32 b4 fe			ld (debug_mark),a  
1f2f 3a 3e 1f			ld a, (.dmark+1)  
1f32 32 b5 fe			ld (debug_mark+1),a  
1f35 3a 3f 1f			ld a, (.dmark+2)  
1f38 32 b6 fe			ld (debug_mark+2),a  
1f3b 18 03			jr .pastdmark  
1f3d ..			.dmark: db "PSQ"  
1f40 f1			.pastdmark: pop af  
1f41			endm  
# End of macro DMARK
1f41				CALLMONITOR 
1f41 cd 46 18			call break_point_state  
1f44				endm  
# End of macro CALLMONITOR
1f44			endif	 
1f44			    
1f44 e5				push hl 
1f45 e5				push hl 
1f46			 
1f46			;	ld a, 0   ; find end of string 
1f46 cd 27 13			call strlenz 
1f49			if DEBUG_FORTH_PUSH 
1f49						DMARK "PQ2" 
1f49 f5				push af  
1f4a 3a 5e 1f			ld a, (.dmark)  
1f4d 32 b4 fe			ld (debug_mark),a  
1f50 3a 5f 1f			ld a, (.dmark+1)  
1f53 32 b5 fe			ld (debug_mark+1),a  
1f56 3a 60 1f			ld a, (.dmark+2)  
1f59 32 b6 fe			ld (debug_mark+2),a  
1f5c 18 03			jr .pastdmark  
1f5e ..			.dmark: db "PQ2"  
1f61 f1			.pastdmark: pop af  
1f62			endm  
# End of macro DMARK
1f62				CALLMONITOR 
1f62 cd 46 18			call break_point_state  
1f65				endm  
# End of macro CALLMONITOR
1f65			endif	 
1f65 eb				ex de, hl 
1f66 e1				pop hl   ; get ptr to start of string 
1f67			if DEBUG_FORTH_PUSH 
1f67						DMARK "PQ3" 
1f67 f5				push af  
1f68 3a 7c 1f			ld a, (.dmark)  
1f6b 32 b4 fe			ld (debug_mark),a  
1f6e 3a 7d 1f			ld a, (.dmark+1)  
1f71 32 b5 fe			ld (debug_mark+1),a  
1f74 3a 7e 1f			ld a, (.dmark+2)  
1f77 32 b6 fe			ld (debug_mark+2),a  
1f7a 18 03			jr .pastdmark  
1f7c ..			.dmark: db "PQ3"  
1f7f f1			.pastdmark: pop af  
1f80			endm  
# End of macro DMARK
1f80				CALLMONITOR 
1f80 cd 46 18			call break_point_state  
1f83				endm  
# End of macro CALLMONITOR
1f83			endif	 
1f83 19				add hl,de 
1f84			if DEBUG_FORTH_PUSH 
1f84						DMARK "PQE" 
1f84 f5				push af  
1f85 3a 99 1f			ld a, (.dmark)  
1f88 32 b4 fe			ld (debug_mark),a  
1f8b 3a 9a 1f			ld a, (.dmark+1)  
1f8e 32 b5 fe			ld (debug_mark+1),a  
1f91 3a 9b 1f			ld a, (.dmark+2)  
1f94 32 b6 fe			ld (debug_mark+2),a  
1f97 18 03			jr .pastdmark  
1f99 ..			.dmark: db "PQE"  
1f9c f1			.pastdmark: pop af  
1f9d			endm  
# End of macro DMARK
1f9d				CALLMONITOR 
1f9d cd 46 18			call break_point_state  
1fa0				endm  
# End of macro CALLMONITOR
1fa0			endif	 
1fa0			 
1fa0 2b				dec hl    ; see if there is an optional trailing double quote 
1fa1 7e				ld a,(hl) 
1fa2 fe 22			cp '"' 
1fa4 20 03			jr nz, .strnoq 
1fa6 3e 00			ld a, 0      ; get rid of double quote 
1fa8 77				ld (hl), a 
1fa9 23			.strnoq: inc hl 
1faa			 
1faa 3e 00			ld a, 0 
1fac 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1fad			 
1fad 13				inc de ; add one for the type string 
1fae 13				inc de ; add one for null term??? 
1faf			 
1faf				; tos is get string pointer again 
1faf				; de contains space to allocate 
1faf				 
1faf d5				push de 
1fb0			 
1fb0 eb				ex de, hl 
1fb1			 
1fb1				;push af 
1fb1			 
1fb1			if DEBUG_FORTH_PUSH 
1fb1						DMARK "PHm" 
1fb1 f5				push af  
1fb2 3a c6 1f			ld a, (.dmark)  
1fb5 32 b4 fe			ld (debug_mark),a  
1fb8 3a c7 1f			ld a, (.dmark+1)  
1fbb 32 b5 fe			ld (debug_mark+1),a  
1fbe 3a c8 1f			ld a, (.dmark+2)  
1fc1 32 b6 fe			ld (debug_mark+2),a  
1fc4 18 03			jr .pastdmark  
1fc6 ..			.dmark: db "PHm"  
1fc9 f1			.pastdmark: pop af  
1fca			endm  
# End of macro DMARK
1fca				CALLMONITOR 
1fca cd 46 18			call break_point_state  
1fcd				endm  
# End of macro CALLMONITOR
1fcd			endif	 
1fcd cd 90 13			call malloc	; on ret hl now contains allocated memory 
1fd0				if DEBUG_FORTH_MALLOC_GUARD 
1fd0 cc e2 54				call z,malloc_error 
1fd3				endif 
1fd3			 
1fd3				 
1fd3 c1				pop bc    ; get length 
1fd4 d1				pop de   ;  get string start    
1fd5			 
1fd5				; hl has destination from malloc 
1fd5			 
1fd5 eb				ex de, hl    ; prep for ldir 
1fd6			 
1fd6 d5				push de   ; save malloc area for DSP later 
1fd7				;push hl   ; save malloc area for DSP later 
1fd7			 
1fd7			if DEBUG_FORTH_PUSH 
1fd7						DMARK "PHc" 
1fd7 f5				push af  
1fd8 3a ec 1f			ld a, (.dmark)  
1fdb 32 b4 fe			ld (debug_mark),a  
1fde 3a ed 1f			ld a, (.dmark+1)  
1fe1 32 b5 fe			ld (debug_mark+1),a  
1fe4 3a ee 1f			ld a, (.dmark+2)  
1fe7 32 b6 fe			ld (debug_mark+2),a  
1fea 18 03			jr .pastdmark  
1fec ..			.dmark: db "PHc"  
1fef f1			.pastdmark: pop af  
1ff0			endm  
# End of macro DMARK
1ff0				CALLMONITOR 
1ff0 cd 46 18			call break_point_state  
1ff3				endm  
# End of macro CALLMONITOR
1ff3			endif	 
1ff3			 
1ff3			 
1ff3 ed b0			ldir 
1ff5			 
1ff5			 
1ff5				; push malloc to data stack     macro?????  
1ff5			 
1ff5				FORTH_DSP_NEXT 
1ff5 cd 49 1e			call macro_forth_dsp_next 
1ff8				endm 
# End of macro FORTH_DSP_NEXT
1ff8			 
1ff8				; save value and type 
1ff8			 
1ff8 2a b2 fb			ld hl, (cli_data_sp) 
1ffb			 
1ffb				; save item type 
1ffb 3e 01			ld a,  DS_TYPE_STR 
1ffd 77				ld (hl), a 
1ffe 23				inc hl 
1fff			 
1fff				; get malloc word off stack 
1fff d1				pop de 
2000 73				ld (hl), e 
2001 23				inc hl 
2002 72				ld (hl), d 
2003			 
2003			 
2003			 
2003			if DEBUG_FORTH_PUSH 
2003 2a b2 fb			ld hl, (cli_data_sp) 
2006						DMARK "PHS" 
2006 f5				push af  
2007 3a 1b 20			ld a, (.dmark)  
200a 32 b4 fe			ld (debug_mark),a  
200d 3a 1c 20			ld a, (.dmark+1)  
2010 32 b5 fe			ld (debug_mark+1),a  
2013 3a 1d 20			ld a, (.dmark+2)  
2016 32 b6 fe			ld (debug_mark+2),a  
2019 18 03			jr .pastdmark  
201b ..			.dmark: db "PHS"  
201e f1			.pastdmark: pop af  
201f			endm  
# End of macro DMARK
201f				CALLMONITOR 
201f cd 46 18			call break_point_state  
2022				endm  
# End of macro CALLMONITOR
2022			;	ex de,hl 
2022			endif	 
2022				; in case of spaces, skip the ptr past the copied string 
2022				;pop af 
2022				;ld (cli_origptr),hl 
2022			 
2022 c9				ret 
2023			 
2023			 
2023			 
2023			; TODO ascii push input onto stack given hl to start of input 
2023			 
2023			; identify type 
2023			; if starts with a " then a string 
2023			; otherwise it is a number 
2023			;  
2023			; if a string 
2023			;     scan for ending " to get length of string to malloc for + 1 
2023			;     malloc 
2023			;     put pointer to string on stack first byte flags as string 
2023			; 
2023			; else a number 
2023			;    look for number format identifier 
2023			;    $xx hex 
2023			;    %xxxxx bin 
2023			;    xxxxx decimal 
2023			;    convert number to 16bit word.  
2023			;    malloc word + 1 with flag to identiy as num 
2023			;    put pointer to number on stack 
2023			;   
2023			;  
2023			  
2023			forth_apush: 
2023				; kernel push 
2023			 
2023			if DEBUG_FORTH_PUSH 
2023						DMARK "PSH" 
2023 f5				push af  
2024 3a 38 20			ld a, (.dmark)  
2027 32 b4 fe			ld (debug_mark),a  
202a 3a 39 20			ld a, (.dmark+1)  
202d 32 b5 fe			ld (debug_mark+1),a  
2030 3a 3a 20			ld a, (.dmark+2)  
2033 32 b6 fe			ld (debug_mark+2),a  
2036 18 03			jr .pastdmark  
2038 ..			.dmark: db "PSH"  
203b f1			.pastdmark: pop af  
203c			endm  
# End of macro DMARK
203c				CALLMONITOR 
203c cd 46 18			call break_point_state  
203f				endm  
# End of macro CALLMONITOR
203f			endif	 
203f				; identify input type 
203f			 
203f 7e				ld a,(hl) 
2040 fe 22			cp '"' 
2042 28 0a			jr z, .fapstr 
2044 fe 24			cp '$' 
2046 ca 6e 20			jp z, .faphex 
2049 fe 25			cp '%' 
204b ca 56 20			jp z, .fapbin 
204e			;	cp 'b' 
204e			;	jp z, .fabin 
204e				; else decimal 
204e			 
204e				; TODO do decimal conversion 
204e				; decimal is stored as a 16bit word 
204e			 
204e				; by default everything is a string if type is not detected 
204e			.fapstr: ; 
204e fe 22			cp '"' 
2050 20 01			jr nz, .strnoqu 
2052 23				inc hl 
2053			.strnoqu: 
2053 c3 28 1f			jp forth_push_str 
2056			 
2056			 
2056			 
2056			.fapbin:    ; push a binary string.  
2056 11 00 00			ld de, 0   ; hold a 16bit value 
2059			 
2059 23			.fapbinshift:	inc hl  
205a 7e				ld a,(hl) 
205b fe 00			cp 0     ; done scanning  
205d 28 0b			jr z, .fapbdone  	; got it in HL so push  
205f			 
205f				; left shift de 
205f eb				ex de, hl	 
2060 29				add hl, hl 
2061			 
2061				; is 1 
2061 fe 31			cp '1' 
2063 20 02			jr nz, .binzero 
2065 cb 4d			bit 1, l 
2067			.binzero: 
2067 eb				ex de, hl	 ; save current de 
2068 18 ef			jr .fapbinshift 
206a			 
206a			.fapbdone: 
206a eb				ex de, hl 
206b c3 ba 1e			jp forth_push_numhl 
206e			 
206e			 
206e			.faphex:   ; hex is always stored as a 16bit word 
206e				; skip number prefix 
206e 23				inc hl 
206f				; turn ascii into number 
206f cd 80 12			call get_word_hl	; ret 16bit word in hl 
2072			 
2072 c3 ba 1e			jp forth_push_numhl 
2075			 
2075 00				 nop 
2076			 
2076			.fabin:   ; TODO bin conversion 
2076			 
2076			 
2076 c9				ret 
2077			 
2077			 
2077			; get either a string ptr or a 16bit word from the data stack 
2077			 
2077			FORTH_DSP: macro 
2077				call macro_forth_dsp 
2077				endm 
2077			 
2077			macro_forth_dsp: 
2077				; data stack pointer points to current word on tos 
2077			 
2077 2a b2 fb			ld hl,(cli_data_sp) 
207a			 
207a				if DEBUG_FORTH_PUSH 
207a						DMARK "DSP" 
207a f5				push af  
207b 3a 8f 20			ld a, (.dmark)  
207e 32 b4 fe			ld (debug_mark),a  
2081 3a 90 20			ld a, (.dmark+1)  
2084 32 b5 fe			ld (debug_mark+1),a  
2087 3a 91 20			ld a, (.dmark+2)  
208a 32 b6 fe			ld (debug_mark+2),a  
208d 18 03			jr .pastdmark  
208f ..			.dmark: db "DSP"  
2092 f1			.pastdmark: pop af  
2093			endm  
# End of macro DMARK
2093			 
2093 cd 17 55				call display_data_sp 
2096				;call break_point_state 
2096				;rst 030h 
2096				CALLMONITOR 
2096 cd 46 18			call break_point_state  
2099				endm  
# End of macro CALLMONITOR
2099				endif 
2099			 
2099 c9				ret 
209a			 
209a			; return hl to start of value on stack 
209a			 
209a			FORTH_DSP_VALUE: macro 
209a				call macro_forth_dsp_value 
209a				endm 
209a			 
209a			macro_forth_dsp_value: 
209a			 
209a				FORTH_DSP 
209a cd 77 20			call macro_forth_dsp 
209d				endm 
# End of macro FORTH_DSP
209d			 
209d d5				push de 
209e			 
209e 23				inc hl ; skip type 
209f			 
209f 5e				ld e, (hl) 
20a0 23				inc hl 
20a1 56				ld d, (hl) 
20a2 eb				ex de,hl  
20a3			 
20a3 d1				pop de 
20a4			 
20a4 c9				ret 
20a5			 
20a5			; return hl to start of value to second item on stack 
20a5			 
20a5			FORTH_DSP_VALUEM1: macro 
20a5				call macro_forth_dsp_value_m1 
20a5				endm 
20a5			 
20a5			macro_forth_dsp_value_m1: 
20a5			 
20a5				FORTH_DSP 
20a5 cd 77 20			call macro_forth_dsp 
20a8				endm 
# End of macro FORTH_DSP
20a8			 
20a8 2b				dec hl 
20a9 2b				dec hl 
20aa			;	dec hl 
20aa			 
20aa d5				push de 
20ab			 
20ab 5e				ld e, (hl) 
20ac 23				inc hl 
20ad 56				ld d, (hl) 
20ae eb				ex de,hl  
20af			 
20af d1				pop de 
20b0			 
20b0 c9				ret 
20b1			 
20b1				 
20b1			 
20b1			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
20b1			 
20b1			FORTH_DSP_POP: macro 
20b1				call macro_forth_dsp_pop 
20b1				endm 
20b1			 
20b1			 
20b1			; get the tos data type 
20b1			 
20b1			FORTH_DSP_TYPE:   macro 
20b1			 
20b1				;FORTH_DSP_VALUE 
20b1				FORTH_DSP 
20b1				 
20b1				; hl points to value 
20b1				; check type 
20b1			 
20b1				ld a,(hl) 
20b1			 
20b1				endm 
20b1			 
20b1			; load the tos value into hl 
20b1			 
20b1			 
20b1			FORTH_DSP_VALUEHL:  macro 
20b1				call macro_dsp_valuehl 
20b1				endm 
20b1			 
20b1			 
20b1			 
20b1			macro_dsp_valuehl: 
20b1				FORTH_DSP_VALUE 
20b1 cd 9a 20			call macro_forth_dsp_value 
20b4				endm 
# End of macro FORTH_DSP_VALUE
20b4			 
20b4				;FORTH_ERR_TOS_NOTNUM 
20b4			 
20b4				;inc hl   ; skip type id 
20b4			 
20b4			;	push de 
20b4			; 
20b4			;	ld e, (hl) 
20b4			;	inc hl 
20b4			;	ld d, (hl) 
20b4			;	ex de,hl  
20b4			 
20b4			;	pop de 
20b4			 
20b4				if DEBUG_FORTH_PUSH 
20b4						DMARK "DVL" 
20b4 f5				push af  
20b5 3a c9 20			ld a, (.dmark)  
20b8 32 b4 fe			ld (debug_mark),a  
20bb 3a ca 20			ld a, (.dmark+1)  
20be 32 b5 fe			ld (debug_mark+1),a  
20c1 3a cb 20			ld a, (.dmark+2)  
20c4 32 b6 fe			ld (debug_mark+2),a  
20c7 18 03			jr .pastdmark  
20c9 ..			.dmark: db "DVL"  
20cc f1			.pastdmark: pop af  
20cd			endm  
# End of macro DMARK
20cd				CALLMONITOR 
20cd cd 46 18			call break_point_state  
20d0				endm  
# End of macro CALLMONITOR
20d0				endif 
20d0 c9				ret 
20d1			 
20d1			forth_apushstrhl:      
20d1				; push of string requires use of cli_origptr 
20d1				; bodge use 
20d1			 
20d1				; get current cli_origptr, save, update with temp pointer  
20d1 ed 5b ce fb		ld de, (cli_origptr) 
20d5 22 ce fb			ld (cli_origptr), hl 
20d8 d5				push de 
20d9 cd 23 20			call forth_apush 
20dc d1				pop de 
20dd ed 53 ce fb		ld (cli_origptr), de 
20e1 c9			        ret	 
20e2			 
20e2			 
20e2			; increase loop stack pointer and save hl to it 
20e2				 
20e2			FORTH_LOOP_NEXT: macro 
20e2				call macro_forth_loop_next 
20e2				;nop 
20e2				endm 
20e2			 
20e2			macro_forth_loop_next: 
20e2				if DEBUG_FORTH_STACK_GUARD 
20e2 cd d3 65				call check_stacks 
20e5				endif 
20e5 e5				push hl 
20e6 d5				push de 
20e7 eb				ex de,hl 
20e8 2a b4 fb			ld hl,(cli_loop_sp) 
20eb 23				inc hl 
20ec 23				inc hl 
20ed					if DEBUG_FORTH_WORDS 
20ed						DMARK "LNX" 
20ed f5				push af  
20ee 3a 02 21			ld a, (.dmark)  
20f1 32 b4 fe			ld (debug_mark),a  
20f4 3a 03 21			ld a, (.dmark+1)  
20f7 32 b5 fe			ld (debug_mark+1),a  
20fa 3a 04 21			ld a, (.dmark+2)  
20fd 32 b6 fe			ld (debug_mark+2),a  
2100 18 03			jr .pastdmark  
2102 ..			.dmark: db "LNX"  
2105 f1			.pastdmark: pop af  
2106			endm  
# End of macro DMARK
2106						CALLMONITOR 
2106 cd 46 18			call break_point_state  
2109				endm  
# End of macro CALLMONITOR
2109					endif 
2109 22 b4 fb			ld (cli_loop_sp),hl 
210c 73				ld (hl), e 
210d 23				inc hl 
210e 72				ld (hl), d 
210f d1				pop de    ; been reversed so save a swap on restore 
2110 e1				pop hl 
2111				if DEBUG_FORTH_STACK_GUARD 
2111 cd d3 65				call check_stacks 
2114				endif 
2114 c9				ret 
2115			 
2115			; get current ret stack pointer and save to hl  
2115				 
2115			FORTH_LOOP_TOS: macro 
2115				call macro_forth_loop_tos 
2115				endm 
2115			 
2115			macro_forth_loop_tos: 
2115 d5				push de 
2116 2a b4 fb			ld hl,(cli_loop_sp) 
2119 5e				ld e, (hl) 
211a 23				inc hl 
211b 56				ld d, (hl) 
211c eb				ex de, hl 
211d d1				pop de 
211e c9				ret 
211f			 
211f			; pop loop stack pointer 
211f				 
211f			FORTH_LOOP_POP: macro 
211f				call macro_forth_loop_pop 
211f				endm 
211f			 
211f			 
211f			macro_forth_loop_pop: 
211f				if DEBUG_FORTH_STACK_GUARD 
211f					DMARK "LPP" 
211f f5				push af  
2120 3a 34 21			ld a, (.dmark)  
2123 32 b4 fe			ld (debug_mark),a  
2126 3a 35 21			ld a, (.dmark+1)  
2129 32 b5 fe			ld (debug_mark+1),a  
212c 3a 36 21			ld a, (.dmark+2)  
212f 32 b6 fe			ld (debug_mark+2),a  
2132 18 03			jr .pastdmark  
2134 ..			.dmark: db "LPP"  
2137 f1			.pastdmark: pop af  
2138			endm  
# End of macro DMARK
2138 cd d3 65				call check_stacks 
213b					FORTH_CHK_LOOP_UNDER 
213b e5				push hl 
213c d5				push de 
213d 2a b4 fb			ld hl,(cli_loop_sp) 
2140 11 ee fa			ld de, cli_loop_stack 
2143 cd e7 0e			call cmp16 
2146 da ed 66			jp c, fault_loop_under 
2149 d1				pop de 
214a e1				pop hl 
214b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
214b				endif 
214b e5				push hl 
214c 2a b4 fb			ld hl,(cli_loop_sp) 
214f 2b				dec hl 
2150 2b				dec hl 
2151 22 b4 fb			ld (cli_loop_sp), hl 
2154				; TODO do stack underflow checks 
2154 e1				pop hl 
2155				if DEBUG_FORTH_STACK_GUARD 
2155 cd d3 65				call check_stacks 
2158					FORTH_CHK_LOOP_UNDER 
2158 e5				push hl 
2159 d5				push de 
215a 2a b4 fb			ld hl,(cli_loop_sp) 
215d 11 ee fa			ld de, cli_loop_stack 
2160 cd e7 0e			call cmp16 
2163 da ed 66			jp c, fault_loop_under 
2166 d1				pop de 
2167 e1				pop hl 
2168				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2168				endif 
2168 c9				ret 
2169			 
2169			macro_forth_dsp_pop: 
2169			 
2169 e5				push hl 
216a			 
216a				; release malloc data 
216a			 
216a				if DEBUG_FORTH_STACK_GUARD 
216a cd d3 65				call check_stacks 
216d					FORTH_CHK_DSP_UNDER 
216d e5				push hl 
216e d5				push de 
216f 2a b2 fb			ld hl,(cli_data_sp) 
2172 11 ec f8			ld de, cli_data_stack 
2175 cd e7 0e			call cmp16 
2178 da e1 66			jp c, fault_dsp_under 
217b d1				pop de 
217c e1				pop hl 
217d				endm 
# End of macro FORTH_CHK_DSP_UNDER
217d				endif 
217d				;ld hl,(cli_data_sp) 
217d			if DEBUG_FORTH_DOT 
217d				DMARK "DPP" 
217d				CALLMONITOR 
217d			endif	 
217d			 
217d			 
217d			if FORTH_ENABLE_DSPPOPFREE 
217d			 
217d				FORTH_DSP 
217d cd 77 20			call macro_forth_dsp 
2180				endm 
# End of macro FORTH_DSP
2180			 
2180 7e				ld a, (hl) 
2181 fe 01			cp DS_TYPE_STR 
2183 20 07			jr nz, .skippopfree 
2185			 
2185				FORTH_DSP_VALUEHL 
2185 cd b1 20			call macro_dsp_valuehl 
2188				endm 
# End of macro FORTH_DSP_VALUEHL
2188 00				nop 
2189			if DEBUG_FORTH_DOT 
2189				DMARK "DPf" 
2189				CALLMONITOR 
2189			endif	 
2189 cd 5a 14			call free 
218c			.skippopfree: 
218c				 
218c			 
218c			endif 
218c			 
218c			if DEBUG_FORTH_DOT_KEY 
218c				DMARK "DP2" 
218c				CALLMONITOR 
218c			endif	 
218c			 
218c				; move pointer down 
218c			 
218c 2a b2 fb			ld hl,(cli_data_sp) 
218f 2b				dec hl 
2190 2b				dec hl 
2191			; PARSEV5 
2191 2b				dec hl 
2192 22 b2 fb			ld (cli_data_sp), hl 
2195			 
2195				if DEBUG_FORTH_STACK_GUARD 
2195 cd d3 65				call check_stacks 
2198					FORTH_CHK_DSP_UNDER 
2198 e5				push hl 
2199 d5				push de 
219a 2a b2 fb			ld hl,(cli_data_sp) 
219d 11 ec f8			ld de, cli_data_stack 
21a0 cd e7 0e			call cmp16 
21a3 da e1 66			jp c, fault_dsp_under 
21a6 d1				pop de 
21a7 e1				pop hl 
21a8				endm 
# End of macro FORTH_CHK_DSP_UNDER
21a8				endif 
21a8			 
21a8 e1				pop hl 
21a9			 
21a9 c9				ret 
21aa			 
21aa			getwordathl: 
21aa				; hl points to an address 
21aa				; load hl with the word at that address 
21aa			 
21aa d5				push de 
21ab			 
21ab 5e				ld e, (hl) 
21ac 23				inc hl 
21ad 56				ld d, (hl) 
21ae eb				ex de, hl 
21af			 
21af d1				pop de 
21b0 c9				ret 
21b1			 
21b1			 
21b1			 
21b1			 
21b1			 
21b1			; eof 
21b1			 
# End of file forth_stackopsv5.asm
21b1			endif 
21b1			 
21b1			user_word_eol:  
21b1				; hl contains the pointer to where to create a linked list item from the end 
21b1				; of the user dict to continue on at the system word dict 
21b1				 
21b1				; poke the stub of the word list linked list to repoint to rom words 
21b1			 
21b1				; stub format 
21b1				; db   word id 
21b1				; dw    link to next word 
21b1			        ; db char length of token 
21b1				; db string + 0 term 
21b1				; db exec code....  
21b1			 
21b1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
21b3 77				ld (hl), a		; word id 
21b4 23				inc hl 
21b5			 
21b5 11 80 23			ld de, sysdict 
21b8 73				ld (hl), e		; next word link ie system dict 
21b9 23				inc hl 
21ba 72				ld (hl), d		; next word link ie system dict 
21bb 23				inc hl	 
21bc			 
21bc			;	ld (hl), sysdict		; next word link ie system dict 
21bc			;	inc hl 
21bc			;	inc hl 
21bc			 
21bc			;	inc hl 
21bc			;	inc hl 
21bc			 
21bc 3e 02			ld a, 2			; word length is 0 
21be 77				ld (hl), a	 
21bf 23				inc hl 
21c0			 
21c0 3e 7e			ld a, '~'			; word length is 0 
21c2 77				ld (hl), a	 
21c3 23				inc hl 
21c4 3e 00			ld a, 0			; save empty word 
21c6 77				ld (hl), a 
21c7			 
21c7 c9				ret 
21c8			 
21c8				 
21c8			 
21c8			forthexec_cleanup: 
21c8				FORTH_RSP_POP 
21c8 cd 82 1e			call macro_forth_rsp_pop 
21cb				endm 
# End of macro FORTH_RSP_POP
21cb c9				ret 
21cc			 
21cc			forth_call_hl: 
21cc				; taking hl 
21cc e5				push hl 
21cd c9				ret 
21ce			 
21ce			; this is called to reset Forth system but keep existing uwords etc 
21ce			 
21ce			forth_warmstart: 
21ce				; setup stack over/under flow checks 
21ce				if DEBUG_FORTH_STACK_GUARD 
21ce cd b9 65				call chk_stk_init 
21d1				endif 
21d1			 
21d1				; init stack pointers  - * these stacks go upwards *  
21d1 21 70 fb			ld hl, cli_ret_stack 
21d4 22 b6 fb			ld (cli_ret_sp), hl	 
21d7				; set bottom of stack 
21d7 3e 00			ld a,0 
21d9 77				ld (hl),a 
21da 23				inc hl 
21db 77				ld (hl),a 
21dc			 
21dc 21 ec f8			ld hl, cli_data_stack 
21df 22 b2 fb			ld (cli_data_sp), hl	 
21e2				; set bottom of stack 
21e2 3e 00			ld a,0 
21e4 77				ld (hl),a 
21e5 23				inc hl 
21e6 77				ld (hl),a 
21e7			 
21e7 21 ee fa			ld hl, cli_loop_stack 
21ea 22 b4 fb			ld (cli_loop_sp), hl	 
21ed				; set bottom of stack 
21ed 3e 00			ld a,0 
21ef 77				ld (hl),a 
21f0 23				inc hl 
21f1 77				ld (hl),a 
21f2			 
21f2				; init extent of current open file 
21f2			 
21f2 3e 00			ld a, 0 
21f4 32 f9 fb			ld (store_openext), a 
21f7			 
21f7 c9				ret 
21f8			 
21f8			 
21f8			; Cold Start - this is called to setup the whole Forth system 
21f8			 
21f8			forth_init: 
21f8			 
21f8				; setup stack over/under flow checks 
21f8			 
21f8			;	if DEBUG_FORTH_STACK_GUARD 
21f8			;		call chk_stk_init 
21f8			;	endif 
21f8			 
21f8				; enable auto display updates (slow.....) 
21f8			 
21f8 3e 01			ld a, 1 
21fa 32 cc fb			ld (cli_autodisplay), a 
21fd			 
21fd				; if storage is in use disable long reads for now 
21fd 3e 00			ld a, 0 
21ff 32 02 fc			ld (store_longread), a 
2202			 
2202			 
2202				; show start up screen 
2202			 
2202 cd 95 0c			call clear_display 
2205			 
2205 3e 00			ld a,0 
2207 32 ee fb			ld (f_cursor_ptr), a 
220a			 
220a				; set start of word list in start of ram - for use when creating user words 
220a			 
220a 21 00 80			ld hl, baseram 
220d 22 82 f6			ld (os_last_new_uword), hl 
2210 cd b1 21			call user_word_eol 
2213				 
2213			;		call display_data_sp 
2213			;		call next_page_prompt 
2213			 
2213			 
2213			 
2213			 
2213 c9				ret 
2214			 
2214 .. 00		.bootforth: db " Forth Kernel Init ",0 
2228			 
2228			; TODO push to stack 
2228			 
2228			;  
2228			 
2228			if FORTH_PARSEV2 
2228			 
2228			 
2228				include "forth_parserv2.asm" 
2228			 
2228			endif 
2228			 
2228			 
2228			; parse cli version 1 
2228			 
2228			if FORTH_PARSEV1 
2228			 
2228			 
2228			 
2228			      include "forth_parserv1.asm" 
2228			endif 
2228				 
2228			if FORTH_PARSEV3 
2228			 
2228			 
2228			 
2228			      include "forth_parserv3.asm" 
2228				include "forth_wordsv3.asm" 
2228			endif 
2228			 
2228			if FORTH_PARSEV4 
2228			 
2228			 
2228			 
2228			      include "forth_parserv4.asm" 
2228				include "forth_wordsv4.asm" 
2228			endif 
2228			 
2228			if FORTH_PARSEV5 
2228			 
2228			 
2228			 
2228			      include "forth_parserv5.asm" 
2228			 
2228			 
2228			; A better parser without using malloc and string copies all over the place.  
2228			; Exec in situ should be faster 
2228			 
2228			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2228			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2228			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2228			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2228			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2228			WORD_SYS_END: equ 0   ; Opcode for all user words 
2228			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2228			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2228			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2228			 
2228			; Core word preamble macro 
2228			 
2228			CWHEAD:   macro nxtword opcode lit len opflags 
2228				db WORD_SYS_CORE+opcode             
2228				; internal op code number 
2228				dw nxtword            
2228				; link to next dict word block 
2228				db len + 1 
2228				; literal length of dict word inc zero term 
2228				db lit,0              
2228				; literal dict word 
2228			        ; TODO db opflags        
2228				endm 
2228			 
2228			 
2228			NEXTW: macro  
2228				jp macro_next 
2228				endm 
2228			 
2228			macro_next: 
2228			if DEBUG_FORTH_PARSE_KEY 
2228				DMARK "NXT" 
2228				CALLMONITOR 
2228			endif	 
2228			;	inc hl  ; skip token null term  
2228 ed 4b d0 fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
222c ed 5b ce fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2230 2a 86 f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2233			if DEBUG_FORTH_PARSE_KEY 
2233				DMARK "}AA" 
2233				CALLMONITOR 
2233			endif	 
2233 c3 36 23			jp execnext 
2236				;jp exec1 
2236			       
2236			 
2236			 
2236			; Another go at the parser to compile  
2236			 
2236			 
2236			; TODO rework parser to change all of the string words to byte tokens 
2236			; TODO do a search for  
2236			 
2236			; TODO first run normal parser to zero term sections 
2236			; TODO for each word do a token look up to get the op code 
2236			; TODO need some means to flag to the exec that this is a byte code form    
2236			 
2236			 
2236			forthcompile: 
2236			 
2236			; 
2236			; line parse: 
2236			;       parse raw input buffer 
2236			;       tokenise the words 
2236			;       malloc new copy (for looping etc) 
2236			;       copy to malloc + current pc in line to start of string and add line term 
2236			;       save on new rsp 
2236			; 
2236			 
2236			; hl to point to the line to tokenise 
2236			 
2236			;	push hl 
2236 22 86 f6			ld (os_tok_ptr), hl  ; save ptr to string 
2239			 
2239			;	ld a,0		; string term on input 
2239			;	call strlent 
2239			 
2239			;	ld (os_tok_len), hl	 ; save string length 
2239			 
2239			;if DEBUG_FORTH_TOK 
2239			;	ex de,hl		 
2239			;endif 
2239			 
2239			;	pop hl 		; get back string pointer 
2239			 
2239			if DEBUG_FORTH_TOK 
2239						DMARK "TOc" 
2239				CALLMONITOR 
2239			endif 
2239 7e			.cptoken2:    ld a,(hl) 
223a 23				inc hl 
223b fe 7f			cp FORTH_END_BUFFER 
223d 28 29			jr z, .cptokendone2 
223f fe 00			cp 0 
2241 28 25			jr z, .cptokendone2 
2243 fe 22			cp '"' 
2245 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2247 fe 20			cp ' ' 
2249 20 ee			jr nz,  .cptoken2 
224b			 
224b			; TODO consume comments held between ( and ) 
224b			 
224b				; we have a space so change to zero term for dict match later 
224b 2b				dec hl 
224c 3e 00			ld a,0 
224e 77				ld (hl), a 
224f 23				inc hl 
2250 18 e7			jr .cptoken2 
2252				 
2252			 
2252			.cptokenstr2: 
2252				; skip all white space until either eol (because forgot to term) or end double quote 
2252			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2252				;inc hl ; skip current double quote 
2252 7e				ld a,(hl) 
2253 23				inc hl 
2254 fe 22			cp '"' 
2256 28 e1			jr z, .cptoken2 
2258 fe 7f			cp FORTH_END_BUFFER 
225a 28 0c			jr z, .cptokendone2 
225c fe 00			cp 0 
225e 28 08			jr z, .cptokendone2 
2260 fe 20			cp ' ' 
2262 28 02			jr z, .cptmp2 
2264 18 ec			jr .cptokenstr2 
2266			 
2266			.cptmp2:	; we have a space so change to zero term for dict match later 
2266				;dec hl 
2266				;ld a,"-"	; TODO remove this when working 
2266				;ld (hl), a 
2266				;inc hl 
2266 18 ea			jr .cptokenstr2 
2268			 
2268			.cptokendone2: 
2268				;inc hl 
2268 3e 7f			ld a, FORTH_END_BUFFER 
226a 77				ld (hl),a 
226b 23				inc hl 
226c 3e 21			ld a, '!' 
226e 77				ld (hl),a 
226f			 
226f 2a 86 f6			ld hl,(os_tok_ptr) 
2272			         
2272			if DEBUG_FORTH_TOK 
2272						DMARK "Tc1" 
2272				CALLMONITOR 
2272			endif 
2272			 
2272				; push exec string to top of return stack 
2272				FORTH_RSP_NEXT 
2272 cd 61 1e			call macro_forth_rsp_next 
2275				endm 
# End of macro FORTH_RSP_NEXT
2275 c9				ret 
2276			 
2276			; Another go at the parser need to simplify the process 
2276			 
2276			forthparse: 
2276			 
2276			; 
2276			; line parse: 
2276			;       parse raw input buffer 
2276			;       tokenise the words 
2276			;       malloc new copy (for looping etc) 
2276			;       copy to malloc + current pc in line to start of string and add line term 
2276			;       save on new rsp 
2276			; 
2276			 
2276			; hl to point to the line to tokenise 
2276			 
2276			;	push hl 
2276 22 86 f6			ld (os_tok_ptr), hl  ; save ptr to string 
2279			 
2279			;	ld a,0		; string term on input 
2279			;	call strlent 
2279			 
2279			;	ld (os_tok_len), hl	 ; save string length 
2279			 
2279			;if DEBUG_FORTH_TOK 
2279			;	ex de,hl		 
2279			;endif 
2279			 
2279			;	pop hl 		; get back string pointer 
2279			 
2279			if DEBUG_FORTH_TOK 
2279						DMARK "TOK" 
2279				CALLMONITOR 
2279			endif 
2279 7e			.ptoken2:    ld a,(hl) 
227a 23				inc hl 
227b fe 7f			cp FORTH_END_BUFFER 
227d 28 29			jr z, .ptokendone2 
227f fe 00			cp 0 
2281 28 25			jr z, .ptokendone2 
2283 fe 22			cp '"' 
2285 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2287 fe 20			cp ' ' 
2289 20 ee			jr nz,  .ptoken2 
228b			 
228b			; TODO consume comments held between ( and ) 
228b			 
228b				; we have a space so change to zero term for dict match later 
228b 2b				dec hl 
228c 3e 00			ld a,0 
228e 77				ld (hl), a 
228f 23				inc hl 
2290 18 e7			jr .ptoken2 
2292				 
2292			 
2292			.ptokenstr2: 
2292				; skip all white space until either eol (because forgot to term) or end double quote 
2292			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2292				;inc hl ; skip current double quote 
2292 7e				ld a,(hl) 
2293 23				inc hl 
2294 fe 22			cp '"' 
2296 28 e1			jr z, .ptoken2 
2298 fe 7f			cp FORTH_END_BUFFER 
229a 28 0c			jr z, .ptokendone2 
229c fe 00			cp 0 
229e 28 08			jr z, .ptokendone2 
22a0 fe 20			cp ' ' 
22a2 28 02			jr z, .ptmp2 
22a4 18 ec			jr .ptokenstr2 
22a6			 
22a6			.ptmp2:	; we have a space so change to zero term for dict match later 
22a6				;dec hl 
22a6				;ld a,"-"	; TODO remove this when working 
22a6				;ld (hl), a 
22a6				;inc hl 
22a6 18 ea			jr .ptokenstr2 
22a8			 
22a8			.ptokendone2: 
22a8				;inc hl 
22a8 3e 7f			ld a, FORTH_END_BUFFER 
22aa 77				ld (hl),a 
22ab 23				inc hl 
22ac 3e 21			ld a, '!' 
22ae 77				ld (hl),a 
22af			 
22af 2a 86 f6			ld hl,(os_tok_ptr) 
22b2			         
22b2			if DEBUG_FORTH_TOK 
22b2						DMARK "TK1" 
22b2				CALLMONITOR 
22b2			endif 
22b2			 
22b2				; push exec string to top of return stack 
22b2				FORTH_RSP_NEXT 
22b2 cd 61 1e			call macro_forth_rsp_next 
22b5				endm 
# End of macro FORTH_RSP_NEXT
22b5 c9				ret 
22b6			 
22b6			; 
22b6			;	; malloc size + buffer pointer + if is loop flag 
22b6			;	ld hl,(os_tok_len) 		 ; get string length 
22b6			; 
22b6			;	ld a,l 
22b6			; 
22b6			;	cp 0			; we dont want to use a null string 
22b6			;	ret z 
22b6			; 
22b6			;;	add 3    ; prefix malloc with buffer for current word ptr 
22b6			; 
22b6			;	add 5     ; TODO when certain not over writing memory remove 
22b6			; 
22b6			;		 
22b6			; 
22b6			;if DEBUG_FORTH_TOK 
22b6			;			DMARK "TKE" 
22b6			;	CALLMONITOR 
22b6			;endif 
22b6			; 
22b6			;	ld l,a 
22b6			;	ld h,0 
22b6			;;	push hl   ; save required space for the copy later 
22b6			;	call malloc 
22b6			;if DEBUG_FORTH_TOK 
22b6			;			DMARK "TKM" 
22b6			;	CALLMONITOR 
22b6			;endif 
22b6			;	if DEBUG_FORTH_MALLOC_GUARD 
22b6			;		push af 
22b6			;		call ishlzero 
22b6			;;		ld a, l 
22b6			;;		add h 
22b6			;;		cp 0 
22b6			;		pop af 
22b6			;		 
22b6			;		call z,malloc_error 
22b6			;	endif 
22b6			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
22b6			; 
22b6			; 
22b6			;if DEBUG_FORTH_TOK 
22b6			;			DMARK "TKR" 
22b6			;	CALLMONITOR 
22b6			;endif 
22b6			; 
22b6			;	FORTH_RSP_NEXT 
22b6			; 
22b6			;	;inc hl	 ; go past current buffer pointer 
22b6			;	;inc hl 
22b6			;	;inc hl   ; and past if loop flag 
22b6			;		; TODO Need to set flag  
22b6			; 
22b6			;	 
22b6			;	 
22b6			;	ex de,hl	; malloc is dest 
22b6			;	ld hl, (os_tok_len) 
22b6			;;	pop bc 
22b6			;	ld c, l                
22b6			;	ld b,0 
22b6			;	ld hl, (os_tok_ptr) 
22b6			; 
22b6			;if DEBUG_FORTH_TOK 
22b6			;			DMARK "TKT" 
22b6			;	CALLMONITOR 
22b6			;endif 
22b6			; 
22b6			;	; do str cpy 
22b6			; 
22b6			;	ldir      ; copy byte in hl to de 
22b6			; 
22b6			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
22b6			; 
22b6			;if DEBUG_FORTH_TOK 
22b6			; 
22b6			;			DMARK "TKY" 
22b6			;	CALLMONITOR 
22b6			;endif 
22b6			;	;ld a,0 
22b6			;	;ld a,FORTH_END_BUFFER 
22b6			;	ex de, hl 
22b6			;	;dec hl			 ; go back over the space delim at the end of word 
22b6			;	;ld (hl),a 
22b6			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
22b6			;	ld a,FORTH_END_BUFFER 
22b6			;	ld (hl),a 
22b6			;	inc hl 
22b6			;	ld a,FORTH_END_BUFFER 
22b6			;	ld (hl),a 
22b6			; 
22b6			;	; init the malloc area data 
22b6			;	; set pc for in current area 
22b6			;	;ld hl, (os_tok_malloc) 
22b6			;	;inc hl 
22b6			;	;inc hl 
22b6			;	;inc hl 
22b6			;	;ex de,hl 
22b6			;	;ld hl, (os_tok_malloc) 
22b6			;	;ld (hl),e 
22b6			;	;inc hl 
22b6			;	;ld (hl),d 
22b6			; 
22b6			; 
22b6			;	ld hl,(os_tok_malloc) 
22b6			;if DEBUG_FORTH_PARSE_KEY 
22b6			;			DMARK "TKU" 
22b6			;	CALLMONITOR 
22b6			;endif 
22b6			; 
22b6			;	ret 
22b6			 
22b6			forthexec: 
22b6			 
22b6			; line exec: 
22b6			; forth parser 
22b6			 
22b6			; 
22b6			;       get current exec line on rsp 
22b6			 
22b6				FORTH_RSP_TOS 
22b6 cd 78 1e			call macro_forth_rsp_tos 
22b9				endm 
# End of macro FORTH_RSP_TOS
22b9			 
22b9			;       restore current pc - hl points to malloc of data 
22b9			 
22b9				;ld e, (hl) 
22b9				;inc hl 
22b9				;ld d, (hl) 
22b9				;ex de,hl 
22b9			 
22b9			 
22b9			exec1: 
22b9 22 86 f6			ld (os_tok_ptr), hl 
22bc			 
22bc				; copy our PC to working vars  
22bc 22 d0 fb			ld (cli_ptr), hl 
22bf 22 ce fb			ld (cli_origptr), hl 
22c2			 
22c2 7e				ld a,(hl) 
22c3 fe 7f			cp FORTH_END_BUFFER 
22c5 c8				ret z 
22c6			 
22c6				; skip any nulls 
22c6			 
22c6 fe 00			cp 0 
22c8 20 03			jr nz, .execword 
22ca 23				inc hl 
22cb 18 ec			jr exec1 
22cd			 
22cd			 
22cd			.execword: 
22cd			 
22cd			 
22cd			 
22cd			if DEBUG_FORTH_PARSE_KEY 
22cd						DMARK "KYQ" 
22cd				CALLMONITOR 
22cd			endif 
22cd			;       while at start of word: 
22cd			; get start of dict (in user area first) 
22cd			 
22cd 21 00 80		ld hl, baseram 
22d0			;ld hl, sysdict 
22d0 22 d2 fb		ld (cli_nextword),hl 
22d3			;           match word at pc 
22d3			;           exec word 
22d3			;           or push to dsp 
22d3			;           forward to next token 
22d3			;           if line term pop rsp and exit 
22d3			;        
22d3			 
22d3			if DEBUG_FORTH_PARSE_KEY 
22d3						DMARK "KYq" 
22d3				CALLMONITOR 
22d3			endif 
22d3			 
22d3			; 
22d3			; word comp 
22d3			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
22d3			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
22d3			;    move to start of word  
22d3			;    compare word to cli_token 
22d3			 
22d3			.execpnword:	; HL at start of a word in the dictionary to check 
22d3			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
22d3			;	ld (cli_ptr), hl 
22d3			 
22d3 2a d2 fb			ld hl,(cli_nextword) 
22d6			 
22d6 cd 79 23			call forth_tok_next 
22d9			; tok next start here 
22d9			;	; TODO skip compiled symbol for now 
22d9			;	inc hl 
22d9			; 
22d9			;	; save pointer to next word 
22d9			; 
22d9			;	; hl now points to the address of the next word pointer  
22d9			;	ld e, (hl) 
22d9			;	inc hl 
22d9			;	ld d, (hl) 
22d9			;	inc l 
22d9			; 
22d9			;	ex de,hl 
22d9			;if DEBUG_FORTH_PARSE_NEXTWORD 
22d9			;	push bc 
22d9			;	ld bc, (cli_nextword) 
22d9			;			DMARK "NXW" 
22d9			;	CALLMONITOR 
22d9			;	pop bc 
22d9			;endif 
22d9			; tok next end here 
22d9 22 d2 fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
22dc eb				ex de, hl 
22dd			 
22dd			 
22dd				; save the pointer of the current token - 1 to check against 
22dd				 
22dd 22 d6 fb			ld (cli_token), hl   
22e0				; TODO maybe remove below save if no debug 
22e0				; save token string ptr for any debug later 
22e0 23				inc hl  
22e1 22 d8 fb			ld (cli_origtoken), hl 
22e4 2b				dec hl 
22e5				; save pointer to the start of the next dictionay word 
22e5 7e				ld a,(hl)   ; get string length 
22e6 47				ld b,a 
22e7			.execpnwordinc:  
22e7 23				inc hl 
22e8 10 fd			djnz .execpnwordinc 
22ea 22 d4 fb			ld (cli_execword), hl      ; save start of this words code 
22ed			 
22ed				; now check the word token against the string being parsed 
22ed			 
22ed 2a d6 fb			ld hl,(cli_token) 
22f0 23				inc hl     ; skip string length (use zero term instead to end) 
22f1 22 d6 fb			ld (cli_token), hl 
22f4			 
22f4			if DEBUG_FORTH_PARSE_KEY 
22f4						DMARK "KY2" 
22f4			endif 
22f4			if DEBUG_FORTH_PARSE_EXEC 
22f4				; see if disabled 
22f4			 
22f4				ld a, (os_view_disable) 
22f4				cp '*' 
22f4				jr z, .skip 
22f4			 
22f4				push hl 
22f4				push hl 
22f4				call clear_display 
22f4				ld de, .compword 
22f4				ld a, display_row_1 
22f4				call str_at_display 
22f4				pop de 
22f4				ld a, display_row_2 
22f4				call str_at_display 
22f4				ld hl,(cli_ptr) 
22f4				ld a,(hl) 
22f4			        ld hl, os_word_scratch 
22f4				ld (hl),a 
22f4				ld a,0 
22f4				inc hl 
22f4				ld (hl),a 	 
22f4				ld de, os_word_scratch 
22f4				ld a, display_row_2+10 
22f4				call str_at_display 
22f4				call update_display 
22f4				ld a, 100 
22f4				call aDelayInMS 
22f4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
22f4				call delay250ms 
22f4				endif 
22f4				pop hl 
22f4			.skip:  
22f4			endif	 
22f4			.execpnchar:    ; compare char between token and string to parse 
22f4			 
22f4			if DEBUG_FORTH_PARSE_KEY 
22f4						DMARK "Ky3" 
22f4			endif 
22f4			if DEBUG_FORTH_PARSE_EXEC 
22f4				; see if disabled 
22f4			 
22f4				ld a, (os_view_disable) 
22f4				cp '*' 
22f4				jr z, .skip2 
22f4			 
22f4			;	call clear_display 
22f4			ld hl,(cli_token) 
22f4			ld a,(hl) 
22f4			ld (os_word_scratch),a 
22f4				ld hl,(cli_ptr) 
22f4			ld a,(hl) 
22f4				ld (os_word_scratch+1),a 
22f4				ld a,0 
22f4				ld (os_word_scratch+2),a 
22f4				ld de,os_word_scratch 
22f4				ld a,display_row_4 
22f4				call str_at_display 
22f4				call update_display 
22f4			.skip2:  
22f4			endif 
22f4 2a d6 fb			ld hl,(cli_token) 
22f7 7e				ld a, (hl)	 ; char in word token 
22f8 23				inc hl 		; move to next char 
22f9 22 d6 fb			ld (cli_token), hl ; and save it 
22fc 47				ld b,a 
22fd			 
22fd 2a d0 fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
2300 7e				ld a,(hl) 
2301 23				inc hl 
2302 22 d0 fb			ld (cli_ptr), hl		; move to next char 
2305 cd 1e 13			call toUpper 		; make sure the input string matches case 
2308			 
2308			if DEBUG_FORTH_PARSE 
2308			endif 
2308			 
2308				; input stream end of token is a space so get rid of it 
2308			 
2308			;	cp ' ' 
2308			;	jr nz, .pnskipspace 
2308			; 
2308			;	ld a, 0		; make same term as word token term 
2308			; 
2308			;.pnskipspace: 
2308			 
2308			if DEBUG_FORTH_PARSE_KEY 
2308						DMARK "KY7" 
2308			endif 
2308 b8				cp b 
2309 c2 1f 23			jp nz, .execpnskipword	 ; no match so move to next word 
230c				 
230c			;    if same 
230c			;       scan for string terms 0 for token and 32 for input 
230c			 
230c				 
230c			if DEBUG_FORTH_PARSE_KEY 
230c						DMARK "KY8" 
230c			endif 
230c			 
230c 80				add b			 
230d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
230f							; TODO need to make sure last word in zero term string is accounted for 
230f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2311			 
2311			 
2311				; at end of both strings so both are exact match 
2311			 
2311			;       skip ptr for next word 
2311			 
2311 2a d0 fb			ld hl,(cli_ptr) 	; at input string term 
2314 23				inc hl			 ; at next char 
2315 22 d0 fb			ld (cli_ptr), hl     ; save for next round of the parser 
2318 22 ce fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
231b				 
231b				 
231b			if DEBUG_FORTH_PARSE_KEY 
231b						DMARK "KY3" 
231b			endif 
231b			 
231b			 
231b			 
231b			;       exec code block 
231b			if DEBUG_FORTH_JP 
231b				call clear_display 
231b				call update_display 
231b				call delay1s 
231b				ld hl, (cli_execword)     ; save for next check if no match on this word 
231b				ld a,h 
231b				ld hl, os_word_scratch 
231b				call hexout 
231b				ld hl, (cli_execword)     ; save for next check if no match on this word 
231b				ld a,l 
231b				ld hl, os_word_scratch+2 
231b				call hexout 
231b				ld hl, os_word_scratch+4 
231b				ld a,0 
231b				ld (hl),a 
231b				ld de,os_word_scratch 
231b				call str_at_display 
231b					ld a, display_row_2 
231b					call str_at_display 
231b				ld de, (cli_origtoken) 
231b				ld a, display_row_1+10 
231b					call str_at_display 
231b			 
231b				ld a,display_row_1 
231b				ld de, .foundword 
231b				ld a, display_row_3 
231b				call str_at_display 
231b				call update_display 
231b				call delay1s 
231b				call delay1s 
231b				call delay1s 
231b			endif 
231b			 
231b			if DEBUG_FORTH_PARSE_KEY 
231b						DMARK "KYj" 
231b			endif 
231b				; TODO save the word pointer in this exec 
231b			 
231b 2a d4 fb			ld hl,(cli_execword) 
231e e9				jp (hl) 
231f			 
231f			 
231f			;    if not same 
231f			;	scan for zero term 
231f			;	get ptr for next word 
231f			;	goto word comp 
231f			 
231f			.execpnskipword:	; get pointer to next word 
231f 2a d2 fb			ld hl,(cli_nextword) 
2322			 
2322 7e				ld a,(hl) 
2323 fe 00			cp WORD_SYS_END 
2325			;	cp 0 
2325 28 09			jr z, .execendofdict			 ; at end of words 
2327			 
2327			if DEBUG_FORTH_PARSE_KEY 
2327						DMARK "KY4" 
2327			endif 
2327			if DEBUG_FORTH_PARSE_EXEC 
2327			 
2327				; see if disabled 
2327			 
2327				ld a, (os_view_disable) 
2327				cp '*' 
2327				jr z, .noskip 
2327			 
2327			 
2327				ld de, .nowordfound 
2327				ld a, display_row_3 
2327				call str_at_display 
2327				call update_display 
2327				ld a, 100 
2327				call aDelayInMS 
2327				 
2327				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2327					call delay250ms 
2327				endif 
2327			.noskip:  
2327			 
2327			endif	 
2327			 
2327 2a ce fb			ld hl,(cli_origptr) 
232a 22 d0 fb			ld (cli_ptr),hl 
232d			 
232d			if DEBUG_FORTH_PARSE_KEY 
232d						DMARK "KY5" 
232d			endif 
232d c3 d3 22			jp .execpnword			; else go to next word 
2330			 
2330			.execendofdict:  
2330			 
2330			if DEBUG_FORTH_PARSE_KEY 
2330						DMARK "KYe" 
2330			endif 
2330			if DEBUG_FORTH_PARSE_EXEC 
2330				; see if disabled 
2330			 
2330				ld a, (os_view_disable) 
2330				cp '*' 
2330				jr z, .ispskip 
2330			 
2330				call clear_display 
2330				call update_display 
2330				call delay1s 
2330				ld de, (cli_origptr) 
2330				ld a, display_row_1 
2330				call str_at_display 
2330				 
2330				ld de, .enddict 
2330				ld a, display_row_3 
2330				call str_at_display 
2330				call update_display 
2330				ld a, 100 
2330				call aDelayInMS 
2330				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2330				call delay1s 
2330				call delay1s 
2330				call delay1s 
2330				endif 
2330			.ispskip:  
2330				 
2330			endif	 
2330			 
2330			 
2330			 
2330				; if the word is not a keyword then must be a literal so push it to stack 
2330			 
2330			; push token to stack to end of word 
2330			 
2330				STACKFRAME ON $1efe $2f9f 
2330				if DEBUG_STACK_IMB 
2330					if ON 
2330						exx 
2330						ld de, $1efe 
2330						ld a, d 
2330						ld hl, curframe 
2330						call hexout 
2330						ld a, e 
2330						ld hl, curframe+2 
2330						call hexout 
2330						ld hl, $1efe 
2330						push hl 
2330						ld hl, $2f9f 
2330						push hl 
2330						exx 
2330					endif 
2330				endif 
2330			endm 
# End of macro STACKFRAME
2330			 
2330 2a 86 f6		ld hl,(os_tok_ptr) 
2333 cd 23 20		call forth_apush 
2336			 
2336				STACKFRAMECHK ON $1efe $2f9f 
2336				if DEBUG_STACK_IMB 
2336					if ON 
2336						exx 
2336						ld hl, $2f9f 
2336						pop de   ; $2f9f 
2336						call cmp16 
2336						jr nz, .spnosame 
2336						ld hl, $1efe 
2336						pop de   ; $1efe 
2336						call cmp16 
2336						jr z, .spfrsame 
2336						.spnosame: call showsperror 
2336						.spfrsame: nop 
2336						exx 
2336					endif 
2336				endif 
2336			endm 
# End of macro STACKFRAMECHK
2336			 
2336			execnext: 
2336			 
2336			if DEBUG_FORTH_PARSE_KEY 
2336						DMARK "KY>" 
2336			endif 
2336			; move past token to next word 
2336			 
2336 2a 86 f6		ld hl, (os_tok_ptr) 
2339 3e 00		ld a, 0 
233b 01 ff 00		ld bc, 255     ; input buffer size 
233e ed b1		cpir 
2340			 
2340			if DEBUG_FORTH_PARSE_KEY 
2340						DMARK "KY!" 
2340				CALLMONITOR 
2340			endif	 
2340			; TODO this might place hl on the null, so will need to forward on??? 
2340			;inc hl   ; see if this gets onto the next item 
2340			 
2340			 
2340			; TODO pass a pointer to the buffer to push 
2340			; TODO call function to push 
2340			 
2340			; look for end of input 
2340			 
2340			;inc hl 
2340			;ld a,(hl) 
2340			;cp FORTH_END_BUFFER 
2340			;ret z 
2340			 
2340			 
2340 c3 b9 22		jp exec1 
2343			 
2343			 
2343			 
2343			 
2343			 
2343			 
2343			 
2343			 
2343			 
2343			findnexttok: 
2343			 
2343				; hl is pointer to move 
2343				; de is the token to locate 
2343			 
2343					if DEBUG_FORTH 
2343						DMARK "NTK" 
2343						CALLMONITOR 
2343					endif 
2343 d5				push de 
2344			 
2344			.fnt1:	 
2344				; find first char of token to locate 
2344			 
2344 1a				ld a, (de) 
2345 4f				ld c,a 
2346 7e				ld a,(hl) 
2347 cd 1e 13			call toUpper 
234a					if DEBUG_FORTH 
234a						DMARK "NT1" 
234a						CALLMONITOR 
234a					endif 
234a b9				cp c 
234b			 
234b 28 03			jr z, .fnt2cmpmorefirst	 
234d			 
234d				; first char not found move to next char 
234d			 
234d 23				inc hl 
234e 18 f4			jr .fnt1 
2350			 
2350			.fnt2cmpmorefirst:	 
2350				; first char of token found.  
2350			 
2350 e5				push hl     ; save start of token just in case it is the right one 
2351 d9				exx 
2352 e1				pop hl        ; save it to hl' 
2353 d9				exx 
2354			 
2354			 
2354			.fnt2cmpmore:	 
2354				; compare the rest 
2354				 
2354 23				inc hl 
2355 13				inc de 
2356				 
2356 1a				ld a, (de) 
2357 4f				ld c,a 
2358 7e				ld a,(hl) 
2359 cd 1e 13			call toUpper 
235c			 
235c					if DEBUG_FORTH 
235c						DMARK "NT2" 
235c						CALLMONITOR 
235c					endif 
235c				; c has the token to find char 
235c				; a has the mem to scan char 
235c			 
235c b9				cp c 
235d 28 04			jr z,.fntmatch1 
235f			 
235f				; they are not the same 
235f			 
235f					if DEBUG_FORTH 
235f						DMARK "NT3" 
235f						CALLMONITOR 
235f					endif 
235f d1				pop de	; reset de token to look for 
2360 d5				push de 
2361 18 e1			jr .fnt1 
2363				 
2363			.fntmatch1: 
2363			 
2363				; is the same char a null which means we might have a full hit? 
2363					if DEBUG_FORTH 
2363						DMARK "NT4" 
2363						CALLMONITOR 
2363					endif 
2363			 
2363 fe 00			cp 0 
2365 28 0b			jr z, .fntmatchyes 
2367			 
2367				; are we at the end of the token to find? 
2367			 
2367					if DEBUG_FORTH 
2367						DMARK "NT5" 
2367						CALLMONITOR 
2367					endif 
2367 3e 00			ld a, 0 
2369 b9				cp c 
236a			 
236a c2 54 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
236d			 
236d					if DEBUG_FORTH 
236d						DMARK "NT6" 
236d						CALLMONITOR 
236d					endif 
236d				; token to find is exhusted but no match to stream 
236d			 
236d				; restore tok pointer and continue on 
236d d1				pop de 
236e d5				push de 
236f c3 44 23			jp .fnt1 
2372			 
2372			 
2372			.fntmatchyes: 
2372			 
2372				; hl now contains the end of the found token 
2372			 
2372				; get rid of saved token pointer to find 
2372			 
2372 d1				pop de 
2373			 
2373					if DEBUG_FORTH 
2373						DMARK "NT9" 
2373						CALLMONITOR 
2373					endif 
2373			 
2373				; hl will be on the null term so forward on 
2373			 
2373				; get back the saved start of the token 
2373			 
2373 d9				exx 
2374 e5				push hl     ; save start of token just in case it is the right one 
2375 d9				exx 
2376 e1				pop hl        ; save it to hl 
2377			 
2377 c9				ret 
2378			 
2378			 
2378			; LIST needs to find a specific token   
2378			; FORGET needs to find a spefici token 
2378			 
2378			; SAVE needs to find all tokens by flag 
2378			; WORDS just needs to scan through all  by flag 
2378			; UWORDS needs to scan through all by flag 
2378			 
2378			 
2378			; given hl as pointer to start of dict look up string 
2378			; return hl as pointer to start of word block 
2378			; or 0 if not found 
2378			 
2378			forth_find_tok: 
2378 c9				ret 
2379			 
2379			; given hl as pointer to dict structure 
2379			; move to the next dict block structure 
2379			 
2379			forth_tok_next: 
2379				; hl now points to the address of the next word pointer  
2379				; TODO skip compiled symbol for now 
2379			;	push de 
2379 23				inc hl 
237a 5e				ld e, (hl) 
237b 23				inc hl 
237c 56				ld d, (hl) 
237d 23				inc hl 
237e			 
237e eb				ex de,hl 
237f			if DEBUG_FORTH_PARSE_NEXTWORD 
237f				push bc 
237f				ld bc, (cli_nextword) 
237f						DMARK "NXW" 
237f				CALLMONITOR 
237f				pop bc 
237f			endif 
237f			;	pop de	 
237f c9				ret 
2380			 
2380			 
2380			 
2380			; eof 
# End of file forth_parserv5.asm
2380				include "forth_wordsv4.asm" 
2380			 
2380			; the core word dictionary v4 
2380			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2380			 
2380			; this is a linked list for each of the system words used 
2380			; user defined words will follow the same format but will be in ram 
2380			 
2380			 
2380			; 
2380			; 
2380			; define linked list: 
2380			; 
2380			; 1. compiled byte op code 
2380			; 2. len of text word 
2380			; 3. text word 
2380			; 4. ptr to next dictionary word 
2380			; 5. asm, calls etc for the word 
2380			; 
2380			;  if 1 == 0 then last word in dict  
2380			;   
2380			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2380			;  
2380			;  
2380			; create basic standard set of words 
2380			; 
2380			;  
2380			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2380			; 2DUP 2DROP 2SWAP  
2380			; @ C@ - get byte  
2380			; ! C! - store byte 
2380			; 0< true if less than zero 
2380			; 0= true if zero 
2380			; < >  
2380			; = true if same 
2380			; variables 
2380			 
2380			 
2380			; Hardware specific words I may need 
2380			; 
2380			; IN OUT  
2380			; calls to key util functions 
2380			; calls to hardward abstraction stuff 
2380			; easy control of frame buffers and lcd i/o 
2380			; keyboard  
2380			 
2380			 
2380			;DICT: macro 
2380			; op_code, len, word, next 
2380			;    word: 
2380			;    db op_code 
2380			;    ds word zero term 
2380			;    dw next 
2380			;    endm 
2380			 
2380			 
2380			 
2380			 
2380			; op code 1 is a flag for user define words which are to be handled differently 
2380			 
2380			 
2380			; 
2380			; 
2380			;    TODO on entry to a word this should be the expected environment 
2380			;    hl - tos value if number then held, if string this is the ptr 
2380			;    de -  
2380			 
2380			 
2380			; opcode ranges 
2380			; 0 - end of word dict 
2380			; 255 - user define words 
2380			 
2380			sysdict: 
2380			include "forth_opcodes.asm" 
2380			; op codes for forth keywords 
2380			; free to use code 0  
2380				OPCODE_HEAP: equ  1 
2380				OPCODE_EXEC: equ 2 
2380				OPCODE_DUP: equ 3 
2380				OPCODE_SWAP: equ 4 
2380				OPCODE_COLN: equ 5 
2380				OPCODE_SCOLN: equ 6 
2380				OPCODE_DROP: equ 7 
2380				OPCODE_DUP2: equ 8 
2380				OPCODE_DROP2: equ 9 
2380				OPCODE_SWAP2: equ 10 
2380				OPCODE_AT: equ 11 
2380				OPCODE_CAT: equ 12 
2380				OPCODE_BANG: equ 13 
2380				OPCODE_CBANG: equ 14 
2380				OPCODE_SCALL: equ 15 
2380				OPCODE_DEPTH: equ 16 
2380				OPCODE_OVER: equ 17 
2380				OPCODE_PAUSE: equ 18 
2380				OPCODE_PAUSES: equ 19 
2380				OPCODE_ROT: equ 20 
2380			;free to reuse	OPCODE_WORDS: equ 21 
2380			        OPCODE_NOT: equ 21 
2380				OPCODE_UWORDS: equ 22 
2380				OPCODE_BP: equ 23 
2380				OPCODE_MONITOR: equ 24  
2380				OPCODE_MALLOC: equ 25 
2380				OPCODE_FREE: equ 26 
2380				OPCODE_LIST: equ 27 
2380				OPCODE_FORGET: equ 28 
2380				OPCODE_NOP: equ 29 
2380				OPCODE_COMO: equ 30 
2380				OPCODE_COMC: equ 31 
2380			;free to reuse	OPCODE_ENDCORE: equ 32 
2380				OPCODE_AFTERSOUND: equ 33 
2380				OPCODE_GP2: equ 34 
2380				OPCODE_GP3: equ 35 
2380				OPCODE_GP4: equ 36 
2380				OPCODE_SIN: equ 37 
2380				OPCODE_SOUT: equ 38 
2380				OPCODE_SPIO: equ 39 
2380				OPCODE_SPICEH: equ 40 
2380				OPCODE_SPIOb: equ 41 
2380				OPCODE_SPII: equ 42 
2380				OPCODE_SESEL: equ 43 
2380				OPCODE_CARTDEV: equ 44 
2380			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2380				OPCODE_FB: equ 46 
2380				OPCODE_EMIT: equ 47 
2380				OPCODE_DOTH: equ 48 
2380				OPCODE_DOTF: equ 49 
2380				OPCODE_DOT: equ 50 
2380				OPCODE_CLS: equ 51 
2380				OPCODE_DRAW: equ 52 
2380				OPCODE_DUMP: equ 53 
2380				OPCODE_CDUMP: equ 54 
2380				OPCODE_DAT: equ 55 
2380				OPCODE_HOME: equ 56 
2380				OPCODE_SPACE: equ 57 
2380				OPCODE_SPACES: equ 58 
2380				OPCODE_SCROLL: equ 59 
2380				OPCODE_ATQ: equ 60 
2380				OPCODE_AUTODSP: equ 61 
2380				OPCODE_MENU: equ 62 
2380			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2380				OPCODE_THEN: equ 64 
2380				OPCODE_ELSE: equ 65 
2380				OPCODE_DO: equ 66 
2380				OPCODE_LOOP: equ 67 
2380				OPCODE_I: equ 68 
2380				OPCODE_DLOOP: equ 69  
2380				OPCODE_REPEAT: equ 70  
2380				OPCODE_UNTIL: equ 71 
2380				OPCODE_ENDFLOW: equ 72 
2380				OPCODE_WAITK: equ 73 
2380				OPCODE_ACCEPT: equ 74 
2380				OPCODE_EDIT: equ 75 
2380			;free to reuse	OPCODE_ENDKEY: equ 76 
2380				OPCODE_LZERO: equ 77 
2380				OPCODE_TZERO: equ 78 
2380				OPCODE_LESS: equ 79 
2380				OPCODE_GT: equ 80 
2380				OPCODE_EQUAL: equ 81  
2380			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2380				OPCODE_NEG: equ 83 
2380				OPCODE_DIV: equ 84 
2380				OPCODE_MUL: equ 85 
2380				OPCODE_MIN: equ 86 
2380				OPCODE_MAX: equ 87 
2380				OPCODE_RND16: equ 88 
2380				OPCODE_RND8: equ 89 
2380				OPCODE_RND: equ 90 
2380			;free to reuse	OPCODE_ENDMATHS: equ 91  
2380				OPCODE_BYNAME: equ 92 
2380				OPCODE_DIR: equ 93 
2380				OPCODE_SAVE: equ 94 
2380				OPCODE_LOAD: equ 95 
2380				OPCODE_BSAVE: equ 96 
2380				OPCODE_BLOAD: equ 97 
2380				OPCODE_SEO: equ 98  
2380				OPCODE_SEI: equ 99 
2380				OPCODE_SFREE: equ 100 
2380				OPCODE_SIZE: equ 101 
2380				OPCODE_CREATE: equ 102 
2380				OPCODE_APPEND: equ 103 
2380				OPCODE_SDEL: equ 104 
2380				OPCODE_OPEN: equ 105 
2380				OPCODE_READ: equ 106 
2380				OPCODE_EOF: equ 106 
2380				OPCODE_FORMAT: equ 107 
2380				OPCODE_LABEL: equ 108 
2380				OPCODE_LABELS: equ 109 
2380			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2380				OPCODE_UPPER: equ 111 
2380				OPCODE_LOWER: equ 112 
2380				OPCODE_SUBSTR: equ 113 
2380				OPCODE_LEFT: equ 114 
2380				OPCODE_RIGHT: equ 115 
2380				OPCODE_STR2NUM: equ 116 
2380				OPCODE_NUM2STR: equ 117 
2380				OPCODE_CONCAT: equ 118 
2380				OPCODE_FIND: equ 119 
2380				OPCODE_LEN: equ 120 
2380				OPCODE_CHAR: equ 121 
2380			; free to reuse	OPCODE_STRLEN: equ 122 
2380			; free to reuse	OPCODE_ENDSTR: equ 123 
2380				OPCODE_V0S: equ 124 
2380				OPCODE_V0Q: equ 125 
2380				OPCODE_V1S: equ 126 
2380				OPCODE_V1Q: equ 127 
2380				OPCODE_V2S: equ 128 
2380				OPCODE_V2Q: equ 129 
2380				OPCODE_V3S: equ 130 
2380				OPCODE_V3Q: equ 131 
2380			;free to reuse	OPCODE_END: equ 132 
2380				OPCODE_ZDUP: equ 133 
2380			 
2380			; eof 
# End of file forth_opcodes.asm
2380			 
2380			include "forth_words_core.asm" 
2380			 
2380			; | ## Core Words 
2380			 
2380			;if MALLOC_4 
2380			 
2380			.HEAP: 
2380				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2380 15				db WORD_SYS_CORE+OPCODE_HEAP             
2381 bf 23			dw .EXEC            
2383 05				db 4 + 1 
2384 .. 00			db "HEAP",0              
2389				endm 
# End of macro CWHEAD
2389			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2389			; | | u1 - Current number of bytes in the heap 
2389			; | | u2 - Remaining bytes left on the heap 
2389			; | |  
2389			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2389			 
2389			 
2389					if DEBUG_FORTH_WORDS_KEY 
2389						DMARK "HEP" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 b4 fe			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 b5 fe			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 b6 fe			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db "HEP"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2						CALLMONITOR 
23a2 cd 46 18			call break_point_state  
23a5				endm  
# End of macro CALLMONITOR
23a5					endif 
23a5 2a 0a 80				ld hl, (free_list )      
23a8 11 0e 80				ld de, heap_start 
23ab			 
23ab ed 52				sbc hl, de  
23ad			 
23ad cd ba 1e				call forth_push_numhl 
23b0			 
23b0			 
23b0 ed 5b 0a 80			ld de, (free_list )      
23b4 21 6b f3				ld hl, heap_end 
23b7			 
23b7 ed 52				sbc hl, de 
23b9			 
23b9 cd ba 1e				call forth_push_numhl 
23bc					 
23bc			 
23bc					 
23bc			 
23bc			 
23bc			 
23bc					NEXTW 
23bc c3 28 22			jp macro_next 
23bf				endm 
# End of macro NEXTW
23bf			;endif 
23bf			 
23bf			.EXEC: 
23bf			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
23bf			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
23bf			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
23bf			;; > > 
23bf			;; > >   
23bf			;	STACKFRAME OFF $5efe $5f9f 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS_KEY 
23bf			;			DMARK "EXE" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			; 
23bf			;	FORTH_DSP_VALUEHL 
23bf			; 
23bf			;	FORTH_DSP_POP 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX1" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;;	ld e,(hl) 
23bf			;;	inc hl 
23bf			;;	ld d,(hl) 
23bf			;;	ex de,hl 
23bf			; 
23bf			;;		if DEBUG_FORTH_WORDS 
23bf			;;			DMARK "EX2" 
23bf			;;			CALLMONITOR 
23bf			;;		endif 
23bf			;	push hl 
23bf			; 
23bf			;	;ld a, 0 
23bf			;	;ld a, FORTH_END_BUFFER 
23bf			;	call strlenz 
23bf			;	inc hl   ; include zero term to copy 
23bf			;	inc hl   ; include term 
23bf			;	inc hl   ; include term 
23bf			;	ld b,0 
23bf			;	ld c,l 
23bf			;	pop hl 
23bf			;	ld de, execscratch 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX3" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	ldir 
23bf			; 
23bf			; 
23bf			;	ld hl, execscratch 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EXe" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			; 
23bf			;	call forthparse 
23bf			;	call forthexec 
23bf			;;	call forthexec_cleanup 
23bf			;;	call forthparse 
23bf			;;	call forthexec 
23bf			; 
23bf			;	STACKFRAMECHK OFF $5efe $5f9f 
23bf			; 
23bf			;	; an immediate word so no need to process any more words 
23bf			;	ret 
23bf			;	NEXTW 
23bf			 
23bf			; dead code - old version  
23bf			;	FORTH_RSP_NEXT 
23bf			 
23bf			;  
23bf			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23bf			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23bf			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23bf			;	push hl 
23bf			;	push de 
23bf			;	push bc 
23bf			; 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS_KEY 
23bf			;			DMARK "EXR" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			; 
23bf			; 
23bf			; 
23bf			;	;v5 FORTH_DSP_VALUE 
23bf			;	FORTH_DSP_VALUEHL 
23bf			; 
23bf			;	; TODO do string type checks 
23bf			; 
23bf			;;v5	inc hl   ; skip type 
23bf			; 
23bf			;	push hl  ; source code  
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX1" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	ld a, 0 
23bf			;	call strlent 
23bf			; 
23bf			;	inc hl 
23bf			;	inc hl 
23bf			;	inc hl 
23bf			;	inc hl 
23bf			; 
23bf			;	push hl    ; size 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX2" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	call malloc 
23bf			; 
23bf			;	ex de, hl    ; de now contains malloc area 
23bf			;	pop bc   	; get byte count 
23bf			;	pop hl      ; get string to copy 
23bf			; 
23bf			;	push de     ; save malloc for free later 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX3" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	ldir       ; duplicate string 
23bf			; 
23bf			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
23bf			;	 
23bf			;	; TODO fix the parse would be better than this...  
23bf			;	ex de, hl 
23bf			;	dec hl 
23bf			;	ld a, 0 
23bf			;	ld (hl), a 
23bf			;	dec hl 
23bf			;	ld a, ' ' 
23bf			;	ld (hl), a 
23bf			;	dec hl 
23bf			;	ld (hl), a 
23bf			; 
23bf			;	dec hl 
23bf			;	ld (hl), a 
23bf			; 
23bf			; 
23bf			;	FORTH_DSP_POP  
23bf			; 
23bf			;	pop hl     
23bf			;	push hl    ; save malloc area 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX4" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			; 
23bf			;	call forthparse 
23bf			;	call forthexec 
23bf			;	 
23bf			;	pop hl 
23bf			;	if DEBUG_FORTH_WORDS 
23bf			;		DMARK "EX5" 
23bf			;		CALLMONITOR 
23bf			;	endif 
23bf			; 
23bf			;	if FORTH_ENABLE_FREE 
23bf			;	call free 
23bf			;	endif 
23bf			; 
23bf			;	if DEBUG_FORTH_WORDS 
23bf			;		DMARK "EX6" 
23bf			;		CALLMONITOR 
23bf			;	endif 
23bf			; 
23bf			;	pop bc 
23bf			;	pop de 
23bf			;	pop hl 
23bf			;;	FORTH_RSP_POP	  
23bf			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
23bf			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
23bf			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
23bf			; 
23bf			;	if DEBUG_FORTH_WORDS 
23bf			;		DMARK "EX7" 
23bf			;		CALLMONITOR 
23bf			;	endif 
23bf			;	NEXTW 
23bf			 
23bf			;.STKEXEC: 
23bf			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
23bf			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
23bf			; 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS_KEY 
23bf			;			DMARK "STX" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			; 
23bf			;	FORTH_DSP_VALUEHL 
23bf			; 
23bf			;	ld (store_tmp1), hl    ; count 
23bf			; 
23bf			;	FORTH_DSP_POP 
23bf			;.stkexec1: 
23bf			;	ld hl, (store_tmp1)   ; count 
23bf			;	ld a, 0 
23bf			;	cp l 
23bf			;	ret z 
23bf			; 
23bf			;	dec hl 
23bf			;	ld (store_tmp1), hl    ; count 
23bf			;	 
23bf			;	FORTH_DSP_VALUEHL 
23bf			;	push hl 
23bf			;	 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EXp" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	FORTH_DSP_POP 
23bf			; 
23bf			;	call strlenz 
23bf			;	inc hl   ; include zero term to copy 
23bf			;	inc hl   ; include zero term to copy 
23bf			;	inc hl   ; include zero term to copy 
23bf			;	ld b,0 
23bf			;	ld c,l 
23bf			;	pop hl 
23bf			;	ld de, execscratch 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EX3" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	ldir 
23bf			; 
23bf			; 
23bf			;	ld hl, execscratch 
23bf			; 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EXP" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			; 
23bf			;	call forthparse 
23bf			;	ld hl, execscratch 
23bf			;		if DEBUG_FORTH_WORDS 
23bf			;			DMARK "EXx" 
23bf			;			CALLMONITOR 
23bf			;		endif 
23bf			;	call forthexec 
23bf			; 
23bf			;	jp .stkexec1 
23bf			; 
23bf			;	ret 
23bf			 
23bf			 
23bf			.DUP: 
23bf				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
23bf 17				db WORD_SYS_CORE+OPCODE_DUP             
23c0 35 24			dw .ZDUP            
23c2 04				db 3 + 1 
23c3 .. 00			db "DUP",0              
23c7				endm 
# End of macro CWHEAD
23c7			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
23c7			 
23c7					if DEBUG_FORTH_WORDS_KEY 
23c7						DMARK "DUP" 
23c7 f5				push af  
23c8 3a dc 23			ld a, (.dmark)  
23cb 32 b4 fe			ld (debug_mark),a  
23ce 3a dd 23			ld a, (.dmark+1)  
23d1 32 b5 fe			ld (debug_mark+1),a  
23d4 3a de 23			ld a, (.dmark+2)  
23d7 32 b6 fe			ld (debug_mark+2),a  
23da 18 03			jr .pastdmark  
23dc ..			.dmark: db "DUP"  
23df f1			.pastdmark: pop af  
23e0			endm  
# End of macro DMARK
23e0						CALLMONITOR 
23e0 cd 46 18			call break_point_state  
23e3				endm  
# End of macro CALLMONITOR
23e3					endif 
23e3			 
23e3					FORTH_DSP 
23e3 cd 77 20			call macro_forth_dsp 
23e6				endm 
# End of macro FORTH_DSP
23e6			 
23e6 7e					ld a, (HL) 
23e7 fe 01				cp DS_TYPE_STR 
23e9 20 25				jr nz, .dupinum 
23eb			 
23eb					; push another string 
23eb			 
23eb					FORTH_DSP_VALUEHL     		 
23eb cd b1 20			call macro_dsp_valuehl 
23ee				endm 
# End of macro FORTH_DSP_VALUEHL
23ee			 
23ee				if DEBUG_FORTH_WORDS 
23ee					DMARK "DUs" 
23ee f5				push af  
23ef 3a 03 24			ld a, (.dmark)  
23f2 32 b4 fe			ld (debug_mark),a  
23f5 3a 04 24			ld a, (.dmark+1)  
23f8 32 b5 fe			ld (debug_mark+1),a  
23fb 3a 05 24			ld a, (.dmark+2)  
23fe 32 b6 fe			ld (debug_mark+2),a  
2401 18 03			jr .pastdmark  
2403 ..			.dmark: db "DUs"  
2406 f1			.pastdmark: pop af  
2407			endm  
# End of macro DMARK
2407					CALLMONITOR 
2407 cd 46 18			call break_point_state  
240a				endm  
# End of macro CALLMONITOR
240a				endif 
240a cd 28 1f				call forth_push_str 
240d			 
240d					NEXTW 
240d c3 28 22			jp macro_next 
2410				endm 
# End of macro NEXTW
2410			 
2410			 
2410			.dupinum: 
2410					 
2410			 
2410			 
2410					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2410 cd b1 20			call macro_dsp_valuehl 
2413				endm 
# End of macro FORTH_DSP_VALUEHL
2413			 
2413				; TODO add floating point number detection 
2413			 
2413				if DEBUG_FORTH_WORDS 
2413					DMARK "DUi" 
2413 f5				push af  
2414 3a 28 24			ld a, (.dmark)  
2417 32 b4 fe			ld (debug_mark),a  
241a 3a 29 24			ld a, (.dmark+1)  
241d 32 b5 fe			ld (debug_mark+1),a  
2420 3a 2a 24			ld a, (.dmark+2)  
2423 32 b6 fe			ld (debug_mark+2),a  
2426 18 03			jr .pastdmark  
2428 ..			.dmark: db "DUi"  
242b f1			.pastdmark: pop af  
242c			endm  
# End of macro DMARK
242c					CALLMONITOR 
242c cd 46 18			call break_point_state  
242f				endm  
# End of macro CALLMONITOR
242f				endif 
242f			 
242f cd ba 1e				call forth_push_numhl 
2432					NEXTW 
2432 c3 28 22			jp macro_next 
2435				endm 
# End of macro NEXTW
2435			.ZDUP: 
2435				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2435 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2436 6d 24			dw .SWAP            
2438 05				db 4 + 1 
2439 .. 00			db "?DUP",0              
243e				endm 
# End of macro CWHEAD
243e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
243e			 
243e					if DEBUG_FORTH_WORDS_KEY 
243e						DMARK "qDU" 
243e f5				push af  
243f 3a 53 24			ld a, (.dmark)  
2442 32 b4 fe			ld (debug_mark),a  
2445 3a 54 24			ld a, (.dmark+1)  
2448 32 b5 fe			ld (debug_mark+1),a  
244b 3a 55 24			ld a, (.dmark+2)  
244e 32 b6 fe			ld (debug_mark+2),a  
2451 18 03			jr .pastdmark  
2453 ..			.dmark: db "qDU"  
2456 f1			.pastdmark: pop af  
2457			endm  
# End of macro DMARK
2457						CALLMONITOR 
2457 cd 46 18			call break_point_state  
245a				endm  
# End of macro CALLMONITOR
245a					endif 
245a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
245a cd b1 20			call macro_dsp_valuehl 
245d				endm 
# End of macro FORTH_DSP_VALUEHL
245d			 
245d e5					push hl 
245e			 
245e					; is it a zero? 
245e			 
245e 3e 00				ld a, 0 
2460 84					add h 
2461 85					add l 
2462			 
2462 e1					pop hl 
2463			 
2463 fe 00				cp 0 
2465 28 03				jr z, .dup2orig 
2467			 
2467			 
2467 cd ba 1e				call forth_push_numhl 
246a			 
246a			 
246a				; TODO add floating point number detection 
246a			 
246a			.dup2orig: 
246a			 
246a					NEXTW 
246a c3 28 22			jp macro_next 
246d				endm 
# End of macro NEXTW
246d			.SWAP: 
246d				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
246d 18				db WORD_SYS_CORE+OPCODE_SWAP             
246e ac 24			dw .COLN            
2470 05				db 4 + 1 
2471 .. 00			db "SWAP",0              
2476				endm 
# End of macro CWHEAD
2476			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2476					if DEBUG_FORTH_WORDS_KEY 
2476						DMARK "SWP" 
2476 f5				push af  
2477 3a 8b 24			ld a, (.dmark)  
247a 32 b4 fe			ld (debug_mark),a  
247d 3a 8c 24			ld a, (.dmark+1)  
2480 32 b5 fe			ld (debug_mark+1),a  
2483 3a 8d 24			ld a, (.dmark+2)  
2486 32 b6 fe			ld (debug_mark+2),a  
2489 18 03			jr .pastdmark  
248b ..			.dmark: db "SWP"  
248e f1			.pastdmark: pop af  
248f			endm  
# End of macro DMARK
248f						CALLMONITOR 
248f cd 46 18			call break_point_state  
2492				endm  
# End of macro CALLMONITOR
2492					endif 
2492			 
2492					FORTH_DSP_VALUEHL 
2492 cd b1 20			call macro_dsp_valuehl 
2495				endm 
# End of macro FORTH_DSP_VALUEHL
2495 e5					push hl     ; w2 
2496			 
2496					FORTH_DSP_POP 
2496 cd 69 21			call macro_forth_dsp_pop 
2499				endm 
# End of macro FORTH_DSP_POP
2499			 
2499					FORTH_DSP_VALUEHL 
2499 cd b1 20			call macro_dsp_valuehl 
249c				endm 
# End of macro FORTH_DSP_VALUEHL
249c			 
249c					FORTH_DSP_POP 
249c cd 69 21			call macro_forth_dsp_pop 
249f				endm 
# End of macro FORTH_DSP_POP
249f			 
249f d1					pop de     ; w2	, hl = w1 
24a0			 
24a0 eb					ex de, hl 
24a1 d5					push de 
24a2			 
24a2 cd ba 1e				call forth_push_numhl 
24a5			 
24a5 e1					pop hl 
24a6			 
24a6 cd ba 1e				call forth_push_numhl 
24a9					 
24a9			 
24a9					NEXTW 
24a9 c3 28 22			jp macro_next 
24ac				endm 
# End of macro NEXTW
24ac			.COLN: 
24ac				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
24ac 19				db WORD_SYS_CORE+OPCODE_COLN             
24ad 38 26			dw .SCOLN            
24af 02				db 1 + 1 
24b0 .. 00			db ":",0              
24b2				endm 
# End of macro CWHEAD
24b2			; | : ( -- )         Create new word | DONE 
24b2			 
24b2					if DEBUG_FORTH_WORDS_KEY 
24b2						DMARK "CLN" 
24b2 f5				push af  
24b3 3a c7 24			ld a, (.dmark)  
24b6 32 b4 fe			ld (debug_mark),a  
24b9 3a c8 24			ld a, (.dmark+1)  
24bc 32 b5 fe			ld (debug_mark+1),a  
24bf 3a c9 24			ld a, (.dmark+2)  
24c2 32 b6 fe			ld (debug_mark+2),a  
24c5 18 03			jr .pastdmark  
24c7 ..			.dmark: db "CLN"  
24ca f1			.pastdmark: pop af  
24cb			endm  
# End of macro DMARK
24cb						CALLMONITOR 
24cb cd 46 18			call break_point_state  
24ce				endm  
# End of macro CALLMONITOR
24ce					endif 
24ce				STACKFRAME OFF $8efe $989f 
24ce				if DEBUG_STACK_IMB 
24ce					if OFF 
24ce						exx 
24ce						ld de, $8efe 
24ce						ld a, d 
24ce						ld hl, curframe 
24ce						call hexout 
24ce						ld a, e 
24ce						ld hl, curframe+2 
24ce						call hexout 
24ce						ld hl, $8efe 
24ce						push hl 
24ce						ld hl, $989f 
24ce						push hl 
24ce						exx 
24ce					endif 
24ce				endif 
24ce			endm 
# End of macro STACKFRAME
24ce				; get parser buffer length  of new word 
24ce			 
24ce				 
24ce			 
24ce					; move tok past this to start of name defintition 
24ce					; TODO get word to define 
24ce					; TODO Move past word token 
24ce					; TODO get length of string up to the ';' 
24ce			 
24ce 2a 86 f6			ld hl, (os_tok_ptr) 
24d1 23				inc hl 
24d2 23				inc hl 
24d3			 
24d3 3e 3b			ld a, ';' 
24d5 cd 32 13			call strlent 
24d8			 
24d8 7d				ld a,l 
24d9 32 81 f3			ld (os_new_parse_len), a 
24dc			 
24dc			 
24dc			if DEBUG_FORTH_UWORD 
24dc ed 5b 86 f6		ld de, (os_tok_ptr) 
24e0						DMARK ":01" 
24e0 f5				push af  
24e1 3a f5 24			ld a, (.dmark)  
24e4 32 b4 fe			ld (debug_mark),a  
24e7 3a f6 24			ld a, (.dmark+1)  
24ea 32 b5 fe			ld (debug_mark+1),a  
24ed 3a f7 24			ld a, (.dmark+2)  
24f0 32 b6 fe			ld (debug_mark+2),a  
24f3 18 03			jr .pastdmark  
24f5 ..			.dmark: db ":01"  
24f8 f1			.pastdmark: pop af  
24f9			endm  
# End of macro DMARK
24f9				CALLMONITOR 
24f9 cd 46 18			call break_point_state  
24fc				endm  
# End of macro CALLMONITOR
24fc			endif 
24fc			 
24fc			; 
24fc			;  new word memory layout: 
24fc			;  
24fc			;    : adg 6666 ;  
24fc			; 
24fc			;    db   1     ; user defined word  
24fc 23				inc hl    
24fd			;    dw   sysdict 
24fd 23				inc hl 
24fe 23				inc hl 
24ff			;    db <word len>+1 (for null) 
24ff 23				inc hl 
2500			;    db .... <word> 
2500			; 
2500			 
2500 23				inc hl    ; some extras for the word preamble before the above 
2501 23				inc hl 
2502 23				inc hl 
2503 23				inc hl 
2504 23				inc hl 
2505 23				inc hl 
2506 23				inc hl  
2507 23				inc hl 
2508 23				inc hl 
2509 23				inc hl 
250a 23				inc hl 
250b 23				inc hl 
250c 23				inc hl 
250d 23				inc hl     ; TODO how many do we really need?     maybe only 6 
250e			;       exec word buffer 
250e			;	<ptr word>   
250e 23				inc hl 
250f 23				inc hl 
2510			;       <word list><null term> 7F final term 
2510			 
2510			 
2510			if DEBUG_FORTH_UWORD 
2510						DMARK ":02" 
2510 f5				push af  
2511 3a 25 25			ld a, (.dmark)  
2514 32 b4 fe			ld (debug_mark),a  
2517 3a 26 25			ld a, (.dmark+1)  
251a 32 b5 fe			ld (debug_mark+1),a  
251d 3a 27 25			ld a, (.dmark+2)  
2520 32 b6 fe			ld (debug_mark+2),a  
2523 18 03			jr .pastdmark  
2525 ..			.dmark: db ":02"  
2528 f1			.pastdmark: pop af  
2529			endm  
# End of macro DMARK
2529				CALLMONITOR 
2529 cd 46 18			call break_point_state  
252c				endm  
# End of macro CALLMONITOR
252c			endif 
252c			 
252c				 
252c					; malloc the size 
252c			 
252c cd 90 13				call malloc 
252f 22 83 f3				ld (os_new_malloc), hl     ; save malloc start 
2532			 
2532			;    db   1     ; user defined word  
2532 3e 01				ld a, WORD_SYS_UWORD  
2534 77					ld (hl), a 
2535				 
2535 23				inc hl    
2536			;    dw   sysdict 
2536 11 80 23			ld de, sysdict       ; continue on with the scan to the system dict 
2539 73				ld (hl), e 
253a 23				inc hl 
253b 72				ld (hl), d 
253c 23				inc hl 
253d			 
253d			 
253d			;    Setup dict word 
253d			 
253d 23				inc hl 
253e 22 7d f3			ld (os_new_work_ptr), hl     ; save start of dict word  
2541			 
2541				; 1. get length of dict word 
2541			 
2541			 
2541 2a 86 f6			ld hl, (os_tok_ptr) 
2544 23				inc hl 
2545 23				inc hl    ; position to start of dict word 
2546 3e 00			ld a, 0 
2548 cd 32 13			call strlent 
254b			 
254b			 
254b 23				inc hl    ; to include null??? 
254c			 
254c				; write length of dict word 
254c			 
254c ed 5b 7d f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2550 1b				dec de 
2551 eb				ex de, hl 
2552 73				ld (hl), e 
2553 eb				ex de, hl 
2554			 
2554				 
2554			 
2554				; copy  
2554 4d				ld c, l 
2555 06 00			ld b, 0 
2557 ed 5b 7d f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
255b 2a 86 f6			ld hl, (os_tok_ptr) 
255e 23				inc hl 
255f 23				inc hl    ; position to start of dict word 
2560				 
2560			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2560				 
2560				; TODO need to convert word to upper case 
2560			 
2560			ucasetok:	 
2560 7e				ld a,(hl) 
2561 cd 1e 13			call toUpper 
2564 77				ld (hl),a 
2565 ed a0			ldi 
2567 f2 60 25		 	jp p, ucasetok 
256a			 
256a			 
256a			 
256a				; de now points to start of where the word body code should be placed 
256a ed 53 7d f3		ld (os_new_work_ptr), de 
256e				; hl now points to the words to throw at forthexec which needs to be copied 
256e 22 7b f3			ld (os_new_src_ptr), hl 
2571			 
2571				; TODO add 'call to forthexec' 
2571			 
2571			if DEBUG_FORTH_UWORD 
2571 c5				push bc 
2572 ed 4b 83 f3		ld bc, (os_new_malloc) 
2576						DMARK ":0x" 
2576 f5				push af  
2577 3a 8b 25			ld a, (.dmark)  
257a 32 b4 fe			ld (debug_mark),a  
257d 3a 8c 25			ld a, (.dmark+1)  
2580 32 b5 fe			ld (debug_mark+1),a  
2583 3a 8d 25			ld a, (.dmark+2)  
2586 32 b6 fe			ld (debug_mark+2),a  
2589 18 03			jr .pastdmark  
258b ..			.dmark: db ":0x"  
258e f1			.pastdmark: pop af  
258f			endm  
# End of macro DMARK
258f				CALLMONITOR 
258f cd 46 18			call break_point_state  
2592				endm  
# End of macro CALLMONITOR
2592 c1				pop bc 
2593			endif 
2593			 
2593			 
2593				; create word preamble which should be: 
2593			 
2593			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2593			 
2593				;    ld hl, <word code> 
2593				;    jp user_exec 
2593			        ;    <word code bytes> 
2593			 
2593			 
2593			;	inc de     ; TODO ??? or are we already past the word's null 
2593 eb				ex de, hl 
2594			 
2594 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2596			 
2596 23				inc hl 
2597 22 77 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
259a 23				inc hl 
259b			 
259b 23				inc hl 
259c 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
259e			 
259e 01 10 54			ld bc, user_exec 
25a1 23				inc hl 
25a2 71				ld (hl), c     ; poke address of user_exec 
25a3 23				inc hl 
25a4 70				ld (hl), b     
25a5			 ; 
25a5			;	inc hl 
25a5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25a5			; 
25a5			; 
25a5			;	ld bc, macro_forth_rsp_next 
25a5			;	inc hl 
25a5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
25a5			;	inc hl 
25a5			;	ld (hl), b     
25a5			 ; 
25a5			;	inc hl 
25a5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25a5			; 
25a5			; 
25a5			;	inc hl 
25a5			;	ld bc, forthexec 
25a5			;	ld (hl), c     ; poke address of forthexec 
25a5			;	inc hl 
25a5			;	ld (hl), b      
25a5			; 
25a5			;	inc hl 
25a5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
25a5			; 
25a5			;	ld bc, user_dict_next 
25a5			;	inc hl 
25a5			;	ld (hl), c     ; poke address of forthexec 
25a5			;	inc hl 
25a5			;	ld (hl), b      
25a5			 
25a5				; hl is now where we need to copy the word byte data to save this 
25a5			 
25a5 23				inc hl 
25a6 22 79 f3			ld (os_new_exec), hl 
25a9				 
25a9				; copy definition 
25a9			 
25a9 eb				ex de, hl 
25aa			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
25aa			;	inc de    ; skip the PC for this parse 
25aa 3a 81 f3			ld a, (os_new_parse_len) 
25ad 4f				ld c, a 
25ae 06 00			ld b, 0 
25b0 ed b0			ldir		 ; copy defintion 
25b2			 
25b2			 
25b2				; poke the address of where the new word bytes live for forthexec 
25b2			 
25b2 2a 77 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
25b5			 
25b5 ed 5b 79 f3		ld de, (os_new_exec)      
25b9				 
25b9 73				ld (hl), e 
25ba 23				inc hl 
25bb 72				ld (hl), d 
25bc			 
25bc					; TODO copy last user dict word next link to this word 
25bc					; TODO update last user dict word to point to this word 
25bc			; 
25bc			; hl f923 de 812a ; bc 811a 
25bc			 
25bc			if DEBUG_FORTH_UWORD 
25bc c5				push bc 
25bd ed 4b 83 f3		ld bc, (os_new_malloc) 
25c1						DMARK ":0A" 
25c1 f5				push af  
25c2 3a d6 25			ld a, (.dmark)  
25c5 32 b4 fe			ld (debug_mark),a  
25c8 3a d7 25			ld a, (.dmark+1)  
25cb 32 b5 fe			ld (debug_mark+1),a  
25ce 3a d8 25			ld a, (.dmark+2)  
25d1 32 b6 fe			ld (debug_mark+2),a  
25d4 18 03			jr .pastdmark  
25d6 ..			.dmark: db ":0A"  
25d9 f1			.pastdmark: pop af  
25da			endm  
# End of macro DMARK
25da				CALLMONITOR 
25da cd 46 18			call break_point_state  
25dd				endm  
# End of macro CALLMONITOR
25dd c1				pop bc 
25de			endif 
25de			if DEBUG_FORTH_UWORD 
25de c5				push bc 
25df ed 4b 83 f3		ld bc, (os_new_malloc) 
25e3 03				inc bc 
25e4 03				inc bc 
25e5 03				inc bc 
25e6 03				inc bc 
25e7 03				inc bc 
25e8 03				inc bc 
25e9 03				inc bc 
25ea 03				inc bc 
25eb			 
25eb						DMARK ":0B" 
25eb f5				push af  
25ec 3a 00 26			ld a, (.dmark)  
25ef 32 b4 fe			ld (debug_mark),a  
25f2 3a 01 26			ld a, (.dmark+1)  
25f5 32 b5 fe			ld (debug_mark+1),a  
25f8 3a 02 26			ld a, (.dmark+2)  
25fb 32 b6 fe			ld (debug_mark+2),a  
25fe 18 03			jr .pastdmark  
2600 ..			.dmark: db ":0B"  
2603 f1			.pastdmark: pop af  
2604			endm  
# End of macro DMARK
2604				CALLMONITOR 
2604 cd 46 18			call break_point_state  
2607				endm  
# End of macro CALLMONITOR
2607 c1				pop bc 
2608			endif 
2608			 
2608			; update word dict linked list for new word 
2608			 
2608			 
2608 2a 82 f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
260b 23			inc hl     ; move to next work linked list ptr 
260c			 
260c ed 5b 83 f3	ld de, (os_new_malloc)		 ; new next word 
2610 73			ld (hl), e 
2611 23			inc hl 
2612 72			ld (hl), d 
2613			 
2613			if DEBUG_FORTH_UWORD 
2613 ed 4b 82 f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2617			endif 
2617			 
2617 ed 53 82 f6	ld (os_last_new_uword), de      ; update last new uword ptr 
261b			 
261b			 
261b			if DEBUG_FORTH_UWORD 
261b						DMARK ":0+" 
261b f5				push af  
261c 3a 30 26			ld a, (.dmark)  
261f 32 b4 fe			ld (debug_mark),a  
2622 3a 31 26			ld a, (.dmark+1)  
2625 32 b5 fe			ld (debug_mark+1),a  
2628 3a 32 26			ld a, (.dmark+2)  
262b 32 b6 fe			ld (debug_mark+2),a  
262e 18 03			jr .pastdmark  
2630 ..			.dmark: db ":0+"  
2633 f1			.pastdmark: pop af  
2634			endm  
# End of macro DMARK
2634				CALLMONITOR 
2634 cd 46 18			call break_point_state  
2637				endm  
# End of macro CALLMONITOR
2637			endif 
2637			 
2637				STACKFRAMECHK OFF $8efe $989f 
2637				if DEBUG_STACK_IMB 
2637					if OFF 
2637						exx 
2637						ld hl, $989f 
2637						pop de   ; $989f 
2637						call cmp16 
2637						jr nz, .spnosame 
2637						ld hl, $8efe 
2637						pop de   ; $8efe 
2637						call cmp16 
2637						jr z, .spfrsame 
2637						.spnosame: call showsperror 
2637						.spfrsame: nop 
2637						exx 
2637					endif 
2637				endif 
2637			endm 
# End of macro STACKFRAMECHK
2637			 
2637 c9			ret    ; dont process any remaining parser tokens as they form new word 
2638			 
2638			 
2638			 
2638			 
2638			;		NEXT 
2638			.SCOLN: 
2638			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2638 06				db OPCODE_SCOLN 
2639 84 26			dw .DROP 
263b 02				db 2 
263c .. 00			db ";",0           
263e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
263e					if DEBUG_FORTH_WORDS_KEY 
263e						DMARK "SCN" 
263e f5				push af  
263f 3a 53 26			ld a, (.dmark)  
2642 32 b4 fe			ld (debug_mark),a  
2645 3a 54 26			ld a, (.dmark+1)  
2648 32 b5 fe			ld (debug_mark+1),a  
264b 3a 55 26			ld a, (.dmark+2)  
264e 32 b6 fe			ld (debug_mark+2),a  
2651 18 03			jr .pastdmark  
2653 ..			.dmark: db "SCN"  
2656 f1			.pastdmark: pop af  
2657			endm  
# End of macro DMARK
2657						CALLMONITOR 
2657 cd 46 18			call break_point_state  
265a				endm  
# End of macro CALLMONITOR
265a					endif 
265a					FORTH_RSP_TOS 
265a cd 78 1e			call macro_forth_rsp_tos 
265d				endm 
# End of macro FORTH_RSP_TOS
265d e5					push hl 
265e					FORTH_RSP_POP 
265e cd 82 1e			call macro_forth_rsp_pop 
2661				endm 
# End of macro FORTH_RSP_POP
2661 e1					pop hl 
2662			;		ex de,hl 
2662 22 86 f6				ld (os_tok_ptr),hl 
2665			 
2665			if DEBUG_FORTH_UWORD 
2665						DMARK "SCL" 
2665 f5				push af  
2666 3a 7a 26			ld a, (.dmark)  
2669 32 b4 fe			ld (debug_mark),a  
266c 3a 7b 26			ld a, (.dmark+1)  
266f 32 b5 fe			ld (debug_mark+1),a  
2672 3a 7c 26			ld a, (.dmark+2)  
2675 32 b6 fe			ld (debug_mark+2),a  
2678 18 03			jr .pastdmark  
267a ..			.dmark: db "SCL"  
267d f1			.pastdmark: pop af  
267e			endm  
# End of macro DMARK
267e				CALLMONITOR 
267e cd 46 18			call break_point_state  
2681				endm  
# End of macro CALLMONITOR
2681			endif 
2681					NEXTW 
2681 c3 28 22			jp macro_next 
2684				endm 
# End of macro NEXTW
2684			 
2684			.DROP: 
2684				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2684 1b				db WORD_SYS_CORE+OPCODE_DROP             
2685 af 26			dw .DUP2            
2687 05				db 4 + 1 
2688 .. 00			db "DROP",0              
268d				endm 
# End of macro CWHEAD
268d			; | DROP ( w -- )   drop the TOS item   | DONE 
268d					if DEBUG_FORTH_WORDS_KEY 
268d						DMARK "DRP" 
268d f5				push af  
268e 3a a2 26			ld a, (.dmark)  
2691 32 b4 fe			ld (debug_mark),a  
2694 3a a3 26			ld a, (.dmark+1)  
2697 32 b5 fe			ld (debug_mark+1),a  
269a 3a a4 26			ld a, (.dmark+2)  
269d 32 b6 fe			ld (debug_mark+2),a  
26a0 18 03			jr .pastdmark  
26a2 ..			.dmark: db "DRP"  
26a5 f1			.pastdmark: pop af  
26a6			endm  
# End of macro DMARK
26a6						CALLMONITOR 
26a6 cd 46 18			call break_point_state  
26a9				endm  
# End of macro CALLMONITOR
26a9					endif 
26a9					FORTH_DSP_POP 
26a9 cd 69 21			call macro_forth_dsp_pop 
26ac				endm 
# End of macro FORTH_DSP_POP
26ac					NEXTW 
26ac c3 28 22			jp macro_next 
26af				endm 
# End of macro NEXTW
26af			.DUP2: 
26af				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
26af 1c				db WORD_SYS_CORE+OPCODE_DUP2             
26b0 f4 26			dw .DROP2            
26b2 05				db 4 + 1 
26b3 .. 00			db "2DUP",0              
26b8				endm 
# End of macro CWHEAD
26b8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
26b8					if DEBUG_FORTH_WORDS_KEY 
26b8						DMARK "2DU" 
26b8 f5				push af  
26b9 3a cd 26			ld a, (.dmark)  
26bc 32 b4 fe			ld (debug_mark),a  
26bf 3a ce 26			ld a, (.dmark+1)  
26c2 32 b5 fe			ld (debug_mark+1),a  
26c5 3a cf 26			ld a, (.dmark+2)  
26c8 32 b6 fe			ld (debug_mark+2),a  
26cb 18 03			jr .pastdmark  
26cd ..			.dmark: db "2DU"  
26d0 f1			.pastdmark: pop af  
26d1			endm  
# End of macro DMARK
26d1						CALLMONITOR 
26d1 cd 46 18			call break_point_state  
26d4				endm  
# End of macro CALLMONITOR
26d4					endif 
26d4					FORTH_DSP_VALUEHL 
26d4 cd b1 20			call macro_dsp_valuehl 
26d7				endm 
# End of macro FORTH_DSP_VALUEHL
26d7 e5					push hl      ; 2 
26d8			 
26d8					FORTH_DSP_POP 
26d8 cd 69 21			call macro_forth_dsp_pop 
26db				endm 
# End of macro FORTH_DSP_POP
26db					 
26db					FORTH_DSP_VALUEHL 
26db cd b1 20			call macro_dsp_valuehl 
26de				endm 
# End of macro FORTH_DSP_VALUEHL
26de			;		push hl      ; 1 
26de			 
26de					FORTH_DSP_POP 
26de cd 69 21			call macro_forth_dsp_pop 
26e1				endm 
# End of macro FORTH_DSP_POP
26e1			 
26e1			;		pop hl       ; 1 
26e1 d1					pop de       ; 2 
26e2			 
26e2 cd ba 1e				call forth_push_numhl 
26e5 eb					ex de, hl 
26e6 cd ba 1e				call forth_push_numhl 
26e9			 
26e9					 
26e9 eb					ex de, hl 
26ea			 
26ea cd ba 1e				call forth_push_numhl 
26ed eb					ex de, hl 
26ee cd ba 1e				call forth_push_numhl 
26f1			 
26f1			 
26f1					NEXTW 
26f1 c3 28 22			jp macro_next 
26f4				endm 
# End of macro NEXTW
26f4			.DROP2: 
26f4				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
26f4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
26f5 23 27			dw .SWAP2            
26f7 06				db 5 + 1 
26f8 .. 00			db "2DROP",0              
26fe				endm 
# End of macro CWHEAD
26fe			; | 2DROP ( w w -- )    Double drop | DONE 
26fe					if DEBUG_FORTH_WORDS_KEY 
26fe						DMARK "2DR" 
26fe f5				push af  
26ff 3a 13 27			ld a, (.dmark)  
2702 32 b4 fe			ld (debug_mark),a  
2705 3a 14 27			ld a, (.dmark+1)  
2708 32 b5 fe			ld (debug_mark+1),a  
270b 3a 15 27			ld a, (.dmark+2)  
270e 32 b6 fe			ld (debug_mark+2),a  
2711 18 03			jr .pastdmark  
2713 ..			.dmark: db "2DR"  
2716 f1			.pastdmark: pop af  
2717			endm  
# End of macro DMARK
2717						CALLMONITOR 
2717 cd 46 18			call break_point_state  
271a				endm  
# End of macro CALLMONITOR
271a					endif 
271a					FORTH_DSP_POP 
271a cd 69 21			call macro_forth_dsp_pop 
271d				endm 
# End of macro FORTH_DSP_POP
271d					FORTH_DSP_POP 
271d cd 69 21			call macro_forth_dsp_pop 
2720				endm 
# End of macro FORTH_DSP_POP
2720					NEXTW 
2720 c3 28 22			jp macro_next 
2723				endm 
# End of macro NEXTW
2723			.SWAP2: 
2723				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2723 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2724 4c 27			dw .AT            
2726 06				db 5 + 1 
2727 .. 00			db "2SWAP",0              
272d				endm 
# End of macro CWHEAD
272d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
272d					if DEBUG_FORTH_WORDS_KEY 
272d						DMARK "2SW" 
272d f5				push af  
272e 3a 42 27			ld a, (.dmark)  
2731 32 b4 fe			ld (debug_mark),a  
2734 3a 43 27			ld a, (.dmark+1)  
2737 32 b5 fe			ld (debug_mark+1),a  
273a 3a 44 27			ld a, (.dmark+2)  
273d 32 b6 fe			ld (debug_mark+2),a  
2740 18 03			jr .pastdmark  
2742 ..			.dmark: db "2SW"  
2745 f1			.pastdmark: pop af  
2746			endm  
# End of macro DMARK
2746						CALLMONITOR 
2746 cd 46 18			call break_point_state  
2749				endm  
# End of macro CALLMONITOR
2749					endif 
2749					NEXTW 
2749 c3 28 22			jp macro_next 
274c				endm 
# End of macro NEXTW
274c			.AT: 
274c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
274c 1f				db WORD_SYS_CORE+OPCODE_AT             
274d 7e 27			dw .CAT            
274f 02				db 1 + 1 
2750 .. 00			db "@",0              
2752				endm 
# End of macro CWHEAD
2752			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2752			 
2752					if DEBUG_FORTH_WORDS_KEY 
2752						DMARK "AT." 
2752 f5				push af  
2753 3a 67 27			ld a, (.dmark)  
2756 32 b4 fe			ld (debug_mark),a  
2759 3a 68 27			ld a, (.dmark+1)  
275c 32 b5 fe			ld (debug_mark+1),a  
275f 3a 69 27			ld a, (.dmark+2)  
2762 32 b6 fe			ld (debug_mark+2),a  
2765 18 03			jr .pastdmark  
2767 ..			.dmark: db "AT."  
276a f1			.pastdmark: pop af  
276b			endm  
# End of macro DMARK
276b						CALLMONITOR 
276b cd 46 18			call break_point_state  
276e				endm  
# End of macro CALLMONITOR
276e					endif 
276e			.getbyteat:	 
276e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
276e cd b1 20			call macro_dsp_valuehl 
2771				endm 
# End of macro FORTH_DSP_VALUEHL
2771					 
2771			;		push hl 
2771				 
2771					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2771 cd 69 21			call macro_forth_dsp_pop 
2774				endm 
# End of macro FORTH_DSP_POP
2774			 
2774			;		pop hl 
2774			 
2774 7e					ld a, (hl) 
2775			 
2775 6f					ld l, a 
2776 26 00				ld h, 0 
2778 cd ba 1e				call forth_push_numhl 
277b			 
277b					NEXTW 
277b c3 28 22			jp macro_next 
277e				endm 
# End of macro NEXTW
277e			.CAT: 
277e				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
277e 20				db WORD_SYS_CORE+OPCODE_CAT             
277f a7 27			dw .BANG            
2781 03				db 2 + 1 
2782 .. 00			db "C@",0              
2785				endm 
# End of macro CWHEAD
2785			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2785					if DEBUG_FORTH_WORDS_KEY 
2785						DMARK "CAA" 
2785 f5				push af  
2786 3a 9a 27			ld a, (.dmark)  
2789 32 b4 fe			ld (debug_mark),a  
278c 3a 9b 27			ld a, (.dmark+1)  
278f 32 b5 fe			ld (debug_mark+1),a  
2792 3a 9c 27			ld a, (.dmark+2)  
2795 32 b6 fe			ld (debug_mark+2),a  
2798 18 03			jr .pastdmark  
279a ..			.dmark: db "CAA"  
279d f1			.pastdmark: pop af  
279e			endm  
# End of macro DMARK
279e						CALLMONITOR 
279e cd 46 18			call break_point_state  
27a1				endm  
# End of macro CALLMONITOR
27a1					endif 
27a1 c3 6e 27				jp .getbyteat 
27a4					NEXTW 
27a4 c3 28 22			jp macro_next 
27a7				endm 
# End of macro NEXTW
27a7			.BANG: 
27a7				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
27a7 21				db WORD_SYS_CORE+OPCODE_BANG             
27a8 dd 27			dw .CBANG            
27aa 02				db 1 + 1 
27ab .. 00			db "!",0              
27ad				endm 
# End of macro CWHEAD
27ad			; | ! ( x w -- ) Store x at address w      | DONE 
27ad					if DEBUG_FORTH_WORDS_KEY 
27ad						DMARK "BNG" 
27ad f5				push af  
27ae 3a c2 27			ld a, (.dmark)  
27b1 32 b4 fe			ld (debug_mark),a  
27b4 3a c3 27			ld a, (.dmark+1)  
27b7 32 b5 fe			ld (debug_mark+1),a  
27ba 3a c4 27			ld a, (.dmark+2)  
27bd 32 b6 fe			ld (debug_mark+2),a  
27c0 18 03			jr .pastdmark  
27c2 ..			.dmark: db "BNG"  
27c5 f1			.pastdmark: pop af  
27c6			endm  
# End of macro DMARK
27c6						CALLMONITOR 
27c6 cd 46 18			call break_point_state  
27c9				endm  
# End of macro CALLMONITOR
27c9					endif 
27c9			 
27c9			.storebyteat:		 
27c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c9 cd b1 20			call macro_dsp_valuehl 
27cc				endm 
# End of macro FORTH_DSP_VALUEHL
27cc					 
27cc e5					push hl 
27cd				 
27cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27cd cd 69 21			call macro_forth_dsp_pop 
27d0				endm 
# End of macro FORTH_DSP_POP
27d0			 
27d0					; get byte to poke 
27d0			 
27d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27d0 cd b1 20			call macro_dsp_valuehl 
27d3				endm 
# End of macro FORTH_DSP_VALUEHL
27d3 e5					push hl 
27d4			 
27d4			 
27d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27d4 cd 69 21			call macro_forth_dsp_pop 
27d7				endm 
# End of macro FORTH_DSP_POP
27d7			 
27d7			 
27d7 d1					pop de 
27d8 e1					pop hl 
27d9			 
27d9 73					ld (hl),e 
27da			 
27da			 
27da					NEXTW 
27da c3 28 22			jp macro_next 
27dd				endm 
# End of macro NEXTW
27dd			.CBANG: 
27dd				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
27dd 22				db WORD_SYS_CORE+OPCODE_CBANG             
27de 06 28			dw .SCALL            
27e0 03				db 2 + 1 
27e1 .. 00			db "C!",0              
27e4				endm 
# End of macro CWHEAD
27e4			; | C!  ( x w -- ) Store x at address w  | DONE 
27e4					if DEBUG_FORTH_WORDS_KEY 
27e4						DMARK "CBA" 
27e4 f5				push af  
27e5 3a f9 27			ld a, (.dmark)  
27e8 32 b4 fe			ld (debug_mark),a  
27eb 3a fa 27			ld a, (.dmark+1)  
27ee 32 b5 fe			ld (debug_mark+1),a  
27f1 3a fb 27			ld a, (.dmark+2)  
27f4 32 b6 fe			ld (debug_mark+2),a  
27f7 18 03			jr .pastdmark  
27f9 ..			.dmark: db "CBA"  
27fc f1			.pastdmark: pop af  
27fd			endm  
# End of macro DMARK
27fd						CALLMONITOR 
27fd cd 46 18			call break_point_state  
2800				endm  
# End of macro CALLMONITOR
2800					endif 
2800 c3 c9 27				jp .storebyteat 
2803					NEXTW 
2803 c3 28 22			jp macro_next 
2806				endm 
# End of macro NEXTW
2806			.SCALL: 
2806				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2806 23				db WORD_SYS_CORE+OPCODE_SCALL             
2807 3a 28			dw .DEPTH            
2809 05				db 4 + 1 
280a .. 00			db "CALL",0              
280f				endm 
# End of macro CWHEAD
280f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
280f					if DEBUG_FORTH_WORDS_KEY 
280f						DMARK "CLL" 
280f f5				push af  
2810 3a 24 28			ld a, (.dmark)  
2813 32 b4 fe			ld (debug_mark),a  
2816 3a 25 28			ld a, (.dmark+1)  
2819 32 b5 fe			ld (debug_mark+1),a  
281c 3a 26 28			ld a, (.dmark+2)  
281f 32 b6 fe			ld (debug_mark+2),a  
2822 18 03			jr .pastdmark  
2824 ..			.dmark: db "CLL"  
2827 f1			.pastdmark: pop af  
2828			endm  
# End of macro DMARK
2828						CALLMONITOR 
2828 cd 46 18			call break_point_state  
282b				endm  
# End of macro CALLMONITOR
282b					endif 
282b			 
282b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
282b cd b1 20			call macro_dsp_valuehl 
282e				endm 
# End of macro FORTH_DSP_VALUEHL
282e			 
282e			;		push hl 
282e			 
282e					; destroy value TOS 
282e			 
282e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
282e cd 69 21			call macro_forth_dsp_pop 
2831				endm 
# End of macro FORTH_DSP_POP
2831			 
2831						 
2831			;		pop hl 
2831			 
2831					; how to do a call with hl???? save SP? 
2831 cd cc 21				call forth_call_hl 
2834			 
2834			 
2834					; TODO push value back onto stack for another op etc 
2834			 
2834 cd ba 1e				call forth_push_numhl 
2837					NEXTW 
2837 c3 28 22			jp macro_next 
283a				endm 
# End of macro NEXTW
283a			.DEPTH: 
283a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
283a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
283b 77 28			dw .OVER            
283d 06				db 5 + 1 
283e .. 00			db "DEPTH",0              
2844				endm 
# End of macro CWHEAD
2844			; | DEPTH ( -- u ) Push count of stack | DONE 
2844					; take current TOS and remove from base value div by two to get count 
2844					if DEBUG_FORTH_WORDS_KEY 
2844						DMARK "DEP" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 b4 fe			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 b5 fe			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 b6 fe			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "DEP"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d						CALLMONITOR 
285d cd 46 18			call break_point_state  
2860				endm  
# End of macro CALLMONITOR
2860					endif 
2860			 
2860			 
2860 2a b2 fb			ld hl, (cli_data_sp) 
2863 11 ec f8			ld de, cli_data_stack 
2866 ed 52			sbc hl,de 
2868				 
2868				; div by size of stack item 
2868			 
2868 5d				ld e,l 
2869 0e 03			ld c, 3 
286b cd 59 0e			call Div8 
286e			 
286e 6f				ld l,a 
286f 26 00			ld h,0 
2871			 
2871				;srl h 
2871				;rr l 
2871			 
2871 cd ba 1e				call forth_push_numhl 
2874					NEXTW 
2874 c3 28 22			jp macro_next 
2877				endm 
# End of macro NEXTW
2877			.OVER: 
2877				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2877 42				db WORD_SYS_CORE+46             
2878 be 28			dw .PAUSE            
287a 05				db 4 + 1 
287b .. 00			db "OVER",0              
2880				endm 
# End of macro CWHEAD
2880			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2880					if DEBUG_FORTH_WORDS_KEY 
2880						DMARK "OVR" 
2880 f5				push af  
2881 3a 95 28			ld a, (.dmark)  
2884 32 b4 fe			ld (debug_mark),a  
2887 3a 96 28			ld a, (.dmark+1)  
288a 32 b5 fe			ld (debug_mark+1),a  
288d 3a 97 28			ld a, (.dmark+2)  
2890 32 b6 fe			ld (debug_mark+2),a  
2893 18 03			jr .pastdmark  
2895 ..			.dmark: db "OVR"  
2898 f1			.pastdmark: pop af  
2899			endm  
# End of macro DMARK
2899						CALLMONITOR 
2899 cd 46 18			call break_point_state  
289c				endm  
# End of macro CALLMONITOR
289c					endif 
289c			 
289c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
289c cd b1 20			call macro_dsp_valuehl 
289f				endm 
# End of macro FORTH_DSP_VALUEHL
289f e5					push hl    ; n2 
28a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28a0 cd 69 21			call macro_forth_dsp_pop 
28a3				endm 
# End of macro FORTH_DSP_POP
28a3			 
28a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28a3 cd b1 20			call macro_dsp_valuehl 
28a6				endm 
# End of macro FORTH_DSP_VALUEHL
28a6 e5					push hl    ; n1 
28a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28a7 cd 69 21			call macro_forth_dsp_pop 
28aa				endm 
# End of macro FORTH_DSP_POP
28aa			 
28aa d1					pop de     ; n1 
28ab e1					pop hl     ; n2 
28ac			 
28ac d5					push de 
28ad e5					push hl 
28ae d5					push de 
28af			 
28af					; push back  
28af			 
28af e1					pop hl 
28b0 cd ba 1e				call forth_push_numhl 
28b3 e1					pop hl 
28b4 cd ba 1e				call forth_push_numhl 
28b7 e1					pop hl 
28b8 cd ba 1e				call forth_push_numhl 
28bb					NEXTW 
28bb c3 28 22			jp macro_next 
28be				endm 
# End of macro NEXTW
28be			 
28be			.PAUSE: 
28be				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
28be 43				db WORD_SYS_CORE+47             
28bf f3 28			dw .PAUSES            
28c1 08				db 7 + 1 
28c2 .. 00			db "PAUSEMS",0              
28ca				endm 
# End of macro CWHEAD
28ca			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
28ca					if DEBUG_FORTH_WORDS_KEY 
28ca						DMARK "PMS" 
28ca f5				push af  
28cb 3a df 28			ld a, (.dmark)  
28ce 32 b4 fe			ld (debug_mark),a  
28d1 3a e0 28			ld a, (.dmark+1)  
28d4 32 b5 fe			ld (debug_mark+1),a  
28d7 3a e1 28			ld a, (.dmark+2)  
28da 32 b6 fe			ld (debug_mark+2),a  
28dd 18 03			jr .pastdmark  
28df ..			.dmark: db "PMS"  
28e2 f1			.pastdmark: pop af  
28e3			endm  
# End of macro DMARK
28e3						CALLMONITOR 
28e3 cd 46 18			call break_point_state  
28e6				endm  
# End of macro CALLMONITOR
28e6					endif 
28e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28e6 cd b1 20			call macro_dsp_valuehl 
28e9				endm 
# End of macro FORTH_DSP_VALUEHL
28e9			;		push hl    ; n2 
28e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28e9 cd 69 21			call macro_forth_dsp_pop 
28ec				endm 
# End of macro FORTH_DSP_POP
28ec			;		pop hl 
28ec			 
28ec 7d					ld a, l 
28ed cd f7 0b				call aDelayInMS 
28f0				       NEXTW 
28f0 c3 28 22			jp macro_next 
28f3				endm 
# End of macro NEXTW
28f3			.PAUSES:  
28f3				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
28f3 44				db WORD_SYS_CORE+48             
28f4 62 29			dw .ROT            
28f6 06				db 5 + 1 
28f7 .. 00			db "PAUSE",0              
28fd				endm 
# End of macro CWHEAD
28fd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
28fd					if DEBUG_FORTH_WORDS_KEY 
28fd						DMARK "PAU" 
28fd f5				push af  
28fe 3a 12 29			ld a, (.dmark)  
2901 32 b4 fe			ld (debug_mark),a  
2904 3a 13 29			ld a, (.dmark+1)  
2907 32 b5 fe			ld (debug_mark+1),a  
290a 3a 14 29			ld a, (.dmark+2)  
290d 32 b6 fe			ld (debug_mark+2),a  
2910 18 03			jr .pastdmark  
2912 ..			.dmark: db "PAU"  
2915 f1			.pastdmark: pop af  
2916			endm  
# End of macro DMARK
2916						CALLMONITOR 
2916 cd 46 18			call break_point_state  
2919				endm  
# End of macro CALLMONITOR
2919					endif 
2919					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2919 cd b1 20			call macro_dsp_valuehl 
291c				endm 
# End of macro FORTH_DSP_VALUEHL
291c			;		push hl    ; n2 
291c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291c cd 69 21			call macro_forth_dsp_pop 
291f				endm 
# End of macro FORTH_DSP_POP
291f			;		pop hl 
291f 45					ld b, l 
2920					if DEBUG_FORTH_WORDS 
2920						DMARK "PAU" 
2920 f5				push af  
2921 3a 35 29			ld a, (.dmark)  
2924 32 b4 fe			ld (debug_mark),a  
2927 3a 36 29			ld a, (.dmark+1)  
292a 32 b5 fe			ld (debug_mark+1),a  
292d 3a 37 29			ld a, (.dmark+2)  
2930 32 b6 fe			ld (debug_mark+2),a  
2933 18 03			jr .pastdmark  
2935 ..			.dmark: db "PAU"  
2938 f1			.pastdmark: pop af  
2939			endm  
# End of macro DMARK
2939						CALLMONITOR 
2939 cd 46 18			call break_point_state  
293c				endm  
# End of macro CALLMONITOR
293c					endif 
293c c5			.pauses1:	push bc 
293d cd 12 0c				call delay1s 
2940 c1					pop bc 
2941					if DEBUG_FORTH_WORDS 
2941						DMARK "PA1" 
2941 f5				push af  
2942 3a 56 29			ld a, (.dmark)  
2945 32 b4 fe			ld (debug_mark),a  
2948 3a 57 29			ld a, (.dmark+1)  
294b 32 b5 fe			ld (debug_mark+1),a  
294e 3a 58 29			ld a, (.dmark+2)  
2951 32 b6 fe			ld (debug_mark+2),a  
2954 18 03			jr .pastdmark  
2956 ..			.dmark: db "PA1"  
2959 f1			.pastdmark: pop af  
295a			endm  
# End of macro DMARK
295a						CALLMONITOR 
295a cd 46 18			call break_point_state  
295d				endm  
# End of macro CALLMONITOR
295d					endif 
295d 10 dd				djnz .pauses1 
295f			 
295f				       NEXTW 
295f c3 28 22			jp macro_next 
2962				endm 
# End of macro NEXTW
2962			.ROT: 
2962				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2962 45				db WORD_SYS_CORE+49             
2963 b0 29			dw .UWORDS            
2965 04				db 3 + 1 
2966 .. 00			db "ROT",0              
296a				endm 
# End of macro CWHEAD
296a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
296a					if DEBUG_FORTH_WORDS_KEY 
296a						DMARK "ROT" 
296a f5				push af  
296b 3a 7f 29			ld a, (.dmark)  
296e 32 b4 fe			ld (debug_mark),a  
2971 3a 80 29			ld a, (.dmark+1)  
2974 32 b5 fe			ld (debug_mark+1),a  
2977 3a 81 29			ld a, (.dmark+2)  
297a 32 b6 fe			ld (debug_mark+2),a  
297d 18 03			jr .pastdmark  
297f ..			.dmark: db "ROT"  
2982 f1			.pastdmark: pop af  
2983			endm  
# End of macro DMARK
2983						CALLMONITOR 
2983 cd 46 18			call break_point_state  
2986				endm  
# End of macro CALLMONITOR
2986					endif 
2986			 
2986					FORTH_DSP_VALUEHL 
2986 cd b1 20			call macro_dsp_valuehl 
2989				endm 
# End of macro FORTH_DSP_VALUEHL
2989 e5					push hl    ; u3  
298a			 
298a					FORTH_DSP_POP 
298a cd 69 21			call macro_forth_dsp_pop 
298d				endm 
# End of macro FORTH_DSP_POP
298d			   
298d					FORTH_DSP_VALUEHL 
298d cd b1 20			call macro_dsp_valuehl 
2990				endm 
# End of macro FORTH_DSP_VALUEHL
2990 e5					push hl     ; u2 
2991			 
2991					FORTH_DSP_POP 
2991 cd 69 21			call macro_forth_dsp_pop 
2994				endm 
# End of macro FORTH_DSP_POP
2994			 
2994					FORTH_DSP_VALUEHL 
2994 cd b1 20			call macro_dsp_valuehl 
2997				endm 
# End of macro FORTH_DSP_VALUEHL
2997 e5					push hl     ; u1 
2998			 
2998					FORTH_DSP_POP 
2998 cd 69 21			call macro_forth_dsp_pop 
299b				endm 
# End of macro FORTH_DSP_POP
299b			 
299b c1					pop bc      ; u1 
299c e1					pop hl      ; u2 
299d d1					pop de      ; u3 
299e			 
299e			 
299e c5					push bc 
299f d5					push de 
29a0 e5					push hl 
29a1			 
29a1			 
29a1 e1					pop hl 
29a2 cd ba 1e				call forth_push_numhl 
29a5			 
29a5 e1					pop hl 
29a6 cd ba 1e				call forth_push_numhl 
29a9			 
29a9 e1					pop hl 
29aa cd ba 1e				call forth_push_numhl 
29ad					 
29ad			 
29ad			 
29ad			 
29ad			 
29ad			 
29ad				       NEXTW 
29ad c3 28 22			jp macro_next 
29b0				endm 
# End of macro NEXTW
29b0			 
29b0			.UWORDS: 
29b0				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
29b0 50				db WORD_SYS_CORE+60             
29b1 72 2a			dw .BP            
29b3 07				db 6 + 1 
29b4 .. 00			db "UWORDS",0              
29bb				endm 
# End of macro CWHEAD
29bb			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
29bb			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
29bb			; | | Following the count are the individual words. 
29bb			; | | 
29bb			; | | e.g. UWORDS 
29bb			; | | BOX DIRLIST 2 
29bb			; | |  
29bb			; | | Can be used to save the words to storage via: 
29bb			; | | UWORDS $01 DO $01 APPEND LOOP 
29bb				if DEBUG_FORTH_WORDS_KEY 
29bb					DMARK "UWR" 
29bb f5				push af  
29bc 3a d0 29			ld a, (.dmark)  
29bf 32 b4 fe			ld (debug_mark),a  
29c2 3a d1 29			ld a, (.dmark+1)  
29c5 32 b5 fe			ld (debug_mark+1),a  
29c8 3a d2 29			ld a, (.dmark+2)  
29cb 32 b6 fe			ld (debug_mark+2),a  
29ce 18 03			jr .pastdmark  
29d0 ..			.dmark: db "UWR"  
29d3 f1			.pastdmark: pop af  
29d4			endm  
# End of macro DMARK
29d4					CALLMONITOR 
29d4 cd 46 18			call break_point_state  
29d7				endm  
# End of macro CALLMONITOR
29d7				endif 
29d7 21 00 80				ld hl, baseram 
29da					;ld hl, baseusermem 
29da 01 00 00				ld bc, 0    ; start a counter 
29dd			 
29dd				; skip dict stub 
29dd			 
29dd cd 79 23				call forth_tok_next 
29e0			 
29e0			 
29e0			; while we have words to look for 
29e0			 
29e0 7e			.douscan:	ld a, (hl)      
29e1				if DEBUG_FORTH_WORDS 
29e1					DMARK "UWs" 
29e1 f5				push af  
29e2 3a f6 29			ld a, (.dmark)  
29e5 32 b4 fe			ld (debug_mark),a  
29e8 3a f7 29			ld a, (.dmark+1)  
29eb 32 b5 fe			ld (debug_mark+1),a  
29ee 3a f8 29			ld a, (.dmark+2)  
29f1 32 b6 fe			ld (debug_mark+2),a  
29f4 18 03			jr .pastdmark  
29f6 ..			.dmark: db "UWs"  
29f9 f1			.pastdmark: pop af  
29fa			endm  
# End of macro DMARK
29fa					CALLMONITOR 
29fa cd 46 18			call break_point_state  
29fd				endm  
# End of macro CALLMONITOR
29fd				endif 
29fd fe 00				cp WORD_SYS_END 
29ff 28 4d				jr z, .udone 
2a01 fe 01				cp WORD_SYS_UWORD 
2a03 20 44				jr nz, .nuword 
2a05			 
2a05				if DEBUG_FORTH_WORDS 
2a05					DMARK "UWu" 
2a05 f5				push af  
2a06 3a 1a 2a			ld a, (.dmark)  
2a09 32 b4 fe			ld (debug_mark),a  
2a0c 3a 1b 2a			ld a, (.dmark+1)  
2a0f 32 b5 fe			ld (debug_mark+1),a  
2a12 3a 1c 2a			ld a, (.dmark+2)  
2a15 32 b6 fe			ld (debug_mark+2),a  
2a18 18 03			jr .pastdmark  
2a1a ..			.dmark: db "UWu"  
2a1d f1			.pastdmark: pop af  
2a1e			endm  
# End of macro DMARK
2a1e					CALLMONITOR 
2a1e cd 46 18			call break_point_state  
2a21				endm  
# End of macro CALLMONITOR
2a21				endif 
2a21					; we have a uword so push its name to the stack 
2a21			 
2a21 e5				   	push hl  ; save so we can move to next dict block 
2a22			 
2a22					; skip opcode 
2a22 23					inc hl  
2a23					; skip next ptr 
2a23 23					inc hl  
2a24 23					inc hl 
2a25					; skip len 
2a25 23					inc hl 
2a26				if DEBUG_FORTH_WORDS 
2a26					DMARK "UWt" 
2a26 f5				push af  
2a27 3a 3b 2a			ld a, (.dmark)  
2a2a 32 b4 fe			ld (debug_mark),a  
2a2d 3a 3c 2a			ld a, (.dmark+1)  
2a30 32 b5 fe			ld (debug_mark+1),a  
2a33 3a 3d 2a			ld a, (.dmark+2)  
2a36 32 b6 fe			ld (debug_mark+2),a  
2a39 18 03			jr .pastdmark  
2a3b ..			.dmark: db "UWt"  
2a3e f1			.pastdmark: pop af  
2a3f			endm  
# End of macro DMARK
2a3f					CALLMONITOR 
2a3f cd 46 18			call break_point_state  
2a42				endm  
# End of macro CALLMONITOR
2a42				endif 
2a42 03					inc bc 
2a43			 
2a43 c5					push bc 
2a44 cd 28 1f				call forth_push_str 
2a47 c1					pop bc 
2a48			 
2a48 e1					pop hl 	 
2a49			 
2a49 cd 79 23		.nuword:	call forth_tok_next 
2a4c 18 92				jr .douscan  
2a4e			 
2a4e			.udone:		 ; push count of uwords found 
2a4e c5					push bc 
2a4f e1					pop hl 
2a50			 
2a50				if DEBUG_FORTH_WORDS 
2a50					DMARK "UWc" 
2a50 f5				push af  
2a51 3a 65 2a			ld a, (.dmark)  
2a54 32 b4 fe			ld (debug_mark),a  
2a57 3a 66 2a			ld a, (.dmark+1)  
2a5a 32 b5 fe			ld (debug_mark+1),a  
2a5d 3a 67 2a			ld a, (.dmark+2)  
2a60 32 b6 fe			ld (debug_mark+2),a  
2a63 18 03			jr .pastdmark  
2a65 ..			.dmark: db "UWc"  
2a68 f1			.pastdmark: pop af  
2a69			endm  
# End of macro DMARK
2a69					CALLMONITOR 
2a69 cd 46 18			call break_point_state  
2a6c				endm  
# End of macro CALLMONITOR
2a6c				endif 
2a6c cd ba 1e				call forth_push_numhl 
2a6f			 
2a6f			 
2a6f				       NEXTW 
2a6f c3 28 22			jp macro_next 
2a72				endm 
# End of macro NEXTW
2a72			 
2a72			.BP: 
2a72				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2a72 54				db WORD_SYS_CORE+64             
2a73 a8 2a			dw .MONITOR            
2a75 03				db 2 + 1 
2a76 .. 00			db "BP",0              
2a79				endm 
# End of macro CWHEAD
2a79			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2a79			; | | $00 Will enable the break points within specific code paths 
2a79			; | | $01 Will disable break points 
2a79			; | |  
2a79			; | | By default break points are off. Either the above can be used to enable them 
2a79			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2a79			; | | and on release of the pressed key a message will be disaplayed to notify 
2a79			; | | that break points are enabled. Pressing any key will then continue boot process. 
2a79					; get byte count 
2a79					if DEBUG_FORTH_WORDS_KEY 
2a79						DMARK "BP." 
2a79 f5				push af  
2a7a 3a 8e 2a			ld a, (.dmark)  
2a7d 32 b4 fe			ld (debug_mark),a  
2a80 3a 8f 2a			ld a, (.dmark+1)  
2a83 32 b5 fe			ld (debug_mark+1),a  
2a86 3a 90 2a			ld a, (.dmark+2)  
2a89 32 b6 fe			ld (debug_mark+2),a  
2a8c 18 03			jr .pastdmark  
2a8e ..			.dmark: db "BP."  
2a91 f1			.pastdmark: pop af  
2a92			endm  
# End of macro DMARK
2a92						CALLMONITOR 
2a92 cd 46 18			call break_point_state  
2a95				endm  
# End of macro CALLMONITOR
2a95					endif 
2a95			 
2a95					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a95 cd b1 20			call macro_dsp_valuehl 
2a98				endm 
# End of macro FORTH_DSP_VALUEHL
2a98			 
2a98			;		push hl 
2a98			 
2a98					; destroy value TOS 
2a98			 
2a98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a98 cd 69 21			call macro_forth_dsp_pop 
2a9b				endm 
# End of macro FORTH_DSP_POP
2a9b			 
2a9b			;		pop hl 
2a9b			 
2a9b 3e 00				ld a,0 
2a9d bd					cp l 
2a9e 28 02				jr z, .bpset 
2aa0 3e 2a				ld a, '*' 
2aa2			 
2aa2 32 76 f3		.bpset:		ld (os_view_disable), a 
2aa5			 
2aa5			 
2aa5					NEXTW 
2aa5 c3 28 22			jp macro_next 
2aa8				endm 
# End of macro NEXTW
2aa8			 
2aa8			 
2aa8			.MONITOR: 
2aa8				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2aa8 55				db WORD_SYS_CORE+65             
2aa9 db 2a			dw .MALLOC            
2aab 08				db 7 + 1 
2aac .. 00			db "MONITOR",0              
2ab4				endm 
# End of macro CWHEAD
2ab4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2ab4			; | | At start the current various registers will be displayed with contents. 
2ab4			; | | Top right corner will show the most recent debug marker seen. 
2ab4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2ab4			; | | and the return stack pointer (RSP). 
2ab4			; | | Pressing: 
2ab4			; | |    1 - Initial screen 
2ab4			; | |    2 - Display a data dump of HL 
2ab4			; | |    3 - Display a data dump of DE 
2ab4			; | |    4 - Display a data dump of BC 
2ab4			; | |    5 - Display a data dump of HL 
2ab4			; | |    6 - Display a data dump of DSP 
2ab4			; | |    7 - Display a data dump of RSP 
2ab4			; | |    8 - Display a data dump of what is at DSP 
2ab4			; | |    9 - Display a data dump of what is at RSP 
2ab4			; | |    0 - Exit monitor and continue running. This will also enable break points 
2ab4			; | |    * - Disable break points 
2ab4			; | |    # - Enter traditional monitor mode 
2ab4			; | | 
2ab4			; | | Monitor Mode 
2ab4			; | | ------------ 
2ab4			; | | A prompt of '>' will be shown for various commands: 
2ab4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2ab4			; | |    C - Continue display a data dump from the last set address 
2ab4			; | |    M xxxx - Set start of memory edit at address xx 
2ab4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2ab4			; | |    Q - Return to previous 
2ab4					if DEBUG_FORTH_WORDS_KEY 
2ab4						DMARK "MON" 
2ab4 f5				push af  
2ab5 3a c9 2a			ld a, (.dmark)  
2ab8 32 b4 fe			ld (debug_mark),a  
2abb 3a ca 2a			ld a, (.dmark+1)  
2abe 32 b5 fe			ld (debug_mark+1),a  
2ac1 3a cb 2a			ld a, (.dmark+2)  
2ac4 32 b6 fe			ld (debug_mark+2),a  
2ac7 18 03			jr .pastdmark  
2ac9 ..			.dmark: db "MON"  
2acc f1			.pastdmark: pop af  
2acd			endm  
# End of macro DMARK
2acd						CALLMONITOR 
2acd cd 46 18			call break_point_state  
2ad0				endm  
# End of macro CALLMONITOR
2ad0					endif 
2ad0 3e 00				ld a, 0 
2ad2 32 76 f3				ld (os_view_disable), a 
2ad5			 
2ad5					CALLMONITOR 
2ad5 cd 46 18			call break_point_state  
2ad8				endm  
# End of macro CALLMONITOR
2ad8			 
2ad8			;	call monitor 
2ad8			 
2ad8					NEXTW 
2ad8 c3 28 22			jp macro_next 
2adb				endm 
# End of macro NEXTW
2adb			 
2adb			 
2adb			.MALLOC: 
2adb				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2adb 56				db WORD_SYS_CORE+66             
2adc 04 2b			dw .MALLOC2            
2ade 06				db 5 + 1 
2adf .. 00			db "ALLOT",0              
2ae5				endm 
# End of macro CWHEAD
2ae5			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ae5					if DEBUG_FORTH_WORDS_KEY 
2ae5						DMARK "ALL" 
2ae5 f5				push af  
2ae6 3a fa 2a			ld a, (.dmark)  
2ae9 32 b4 fe			ld (debug_mark),a  
2aec 3a fb 2a			ld a, (.dmark+1)  
2aef 32 b5 fe			ld (debug_mark+1),a  
2af2 3a fc 2a			ld a, (.dmark+2)  
2af5 32 b6 fe			ld (debug_mark+2),a  
2af8 18 03			jr .pastdmark  
2afa ..			.dmark: db "ALL"  
2afd f1			.pastdmark: pop af  
2afe			endm  
# End of macro DMARK
2afe						CALLMONITOR 
2afe cd 46 18			call break_point_state  
2b01				endm  
# End of macro CALLMONITOR
2b01					endif 
2b01 c3 2b 2b				jp .mallocc 
2b04			.MALLOC2: 
2b04				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b04 56				db WORD_SYS_CORE+66             
2b05 42 2b			dw .FREE            
2b07 07				db 6 + 1 
2b08 .. 00			db "MALLOC",0              
2b0f				endm 
# End of macro CWHEAD
2b0f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b0f					; get byte count 
2b0f					if DEBUG_FORTH_WORDS_KEY 
2b0f						DMARK "MAL" 
2b0f f5				push af  
2b10 3a 24 2b			ld a, (.dmark)  
2b13 32 b4 fe			ld (debug_mark),a  
2b16 3a 25 2b			ld a, (.dmark+1)  
2b19 32 b5 fe			ld (debug_mark+1),a  
2b1c 3a 26 2b			ld a, (.dmark+2)  
2b1f 32 b6 fe			ld (debug_mark+2),a  
2b22 18 03			jr .pastdmark  
2b24 ..			.dmark: db "MAL"  
2b27 f1			.pastdmark: pop af  
2b28			endm  
# End of macro DMARK
2b28						CALLMONITOR 
2b28 cd 46 18			call break_point_state  
2b2b				endm  
# End of macro CALLMONITOR
2b2b					endif 
2b2b			.mallocc: 
2b2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2b cd b1 20			call macro_dsp_valuehl 
2b2e				endm 
# End of macro FORTH_DSP_VALUEHL
2b2e			 
2b2e			;		push hl 
2b2e			 
2b2e					; destroy value TOS 
2b2e			 
2b2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b2e cd 69 21			call macro_forth_dsp_pop 
2b31				endm 
# End of macro FORTH_DSP_POP
2b31			 
2b31			;		pop hl 
2b31 cd 90 13				call malloc 
2b34				if DEBUG_FORTH_MALLOC_GUARD 
2b34 f5					push af 
2b35 cd f2 0e				call ishlzero 
2b38			;		ld a, l 
2b38			;		add h 
2b38			;		cp 0 
2b38 f1					pop af 
2b39					 
2b39 cc e2 54				call z,malloc_error 
2b3c				endif 
2b3c			 
2b3c cd ba 1e				call forth_push_numhl 
2b3f					NEXTW 
2b3f c3 28 22			jp macro_next 
2b42				endm 
# End of macro NEXTW
2b42			 
2b42			.FREE: 
2b42				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2b42 57				db WORD_SYS_CORE+67             
2b43 73 2b			dw .LIST            
2b45 05				db 4 + 1 
2b46 .. 00			db "FREE",0              
2b4b				endm 
# End of macro CWHEAD
2b4b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2b4b					if DEBUG_FORTH_WORDS_KEY 
2b4b						DMARK "FRE" 
2b4b f5				push af  
2b4c 3a 60 2b			ld a, (.dmark)  
2b4f 32 b4 fe			ld (debug_mark),a  
2b52 3a 61 2b			ld a, (.dmark+1)  
2b55 32 b5 fe			ld (debug_mark+1),a  
2b58 3a 62 2b			ld a, (.dmark+2)  
2b5b 32 b6 fe			ld (debug_mark+2),a  
2b5e 18 03			jr .pastdmark  
2b60 ..			.dmark: db "FRE"  
2b63 f1			.pastdmark: pop af  
2b64			endm  
# End of macro DMARK
2b64						CALLMONITOR 
2b64 cd 46 18			call break_point_state  
2b67				endm  
# End of macro CALLMONITOR
2b67					endif 
2b67					; get address 
2b67			 
2b67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b67 cd b1 20			call macro_dsp_valuehl 
2b6a				endm 
# End of macro FORTH_DSP_VALUEHL
2b6a			 
2b6a			;		push hl 
2b6a			 
2b6a					; destroy value TOS 
2b6a			 
2b6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b6a cd 69 21			call macro_forth_dsp_pop 
2b6d				endm 
# End of macro FORTH_DSP_POP
2b6d			 
2b6d			;		pop hl 
2b6d			if FORTH_ENABLE_MALLOCFREE 
2b6d cd 5a 14				call free 
2b70			endif 
2b70					NEXTW 
2b70 c3 28 22			jp macro_next 
2b73				endm 
# End of macro NEXTW
2b73			.LIST: 
2b73				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b73 5c				db WORD_SYS_CORE+72             
2b74 61 2d			dw .FORGET            
2b76 05				db 4 + 1 
2b77 .. 00			db "LIST",0              
2b7c				endm 
# End of macro CWHEAD
2b7c			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b7c			; | | The quoted word must be in upper case. 
2b7c				if DEBUG_FORTH_WORDS_KEY 
2b7c					DMARK "LST" 
2b7c f5				push af  
2b7d 3a 91 2b			ld a, (.dmark)  
2b80 32 b4 fe			ld (debug_mark),a  
2b83 3a 92 2b			ld a, (.dmark+1)  
2b86 32 b5 fe			ld (debug_mark+1),a  
2b89 3a 93 2b			ld a, (.dmark+2)  
2b8c 32 b6 fe			ld (debug_mark+2),a  
2b8f 18 03			jr .pastdmark  
2b91 ..			.dmark: db "LST"  
2b94 f1			.pastdmark: pop af  
2b95			endm  
# End of macro DMARK
2b95					CALLMONITOR 
2b95 cd 46 18			call break_point_state  
2b98				endm  
# End of macro CALLMONITOR
2b98				endif 
2b98			 
2b98					FORTH_DSP_VALUEHL 
2b98 cd b1 20			call macro_dsp_valuehl 
2b9b				endm 
# End of macro FORTH_DSP_VALUEHL
2b9b			 
2b9b e5					push hl 
2b9c					FORTH_DSP_POP 
2b9c cd 69 21			call macro_forth_dsp_pop 
2b9f				endm 
# End of macro FORTH_DSP_POP
2b9f c1					pop bc 
2ba0			 
2ba0			; Start format of scratch string 
2ba0			 
2ba0 21 85 f3				ld hl, scratch 
2ba3			 
2ba3 3e 3a				ld a, ':' 
2ba5 77					ld (hl),a 
2ba6 23					inc hl 
2ba7 3e 20				ld a, ' ' 
2ba9 77					ld (hl), a 
2baa			 
2baa					; Get ptr to the word we need to look up 
2baa			 
2baa			;		FORTH_DSP_VALUEHL 
2baa					;v5 FORTH_DSP_VALUE 
2baa				; TODO type check 
2baa			;		inc hl    ; Skip type check  
2baa			;		push hl 
2baa			;		ex de, hl    ; put into DE 
2baa			 
2baa			 
2baa 21 00 80				ld hl, baseram 
2bad					;ld hl, baseusermem 
2bad			 
2bad e5			push hl   ; sacreifical push 
2bae			 
2bae			.ldouscanm: 
2bae e1				pop hl 
2baf			.ldouscan: 
2baf				if DEBUG_FORTH_WORDS 
2baf					DMARK "LSs" 
2baf f5				push af  
2bb0 3a c4 2b			ld a, (.dmark)  
2bb3 32 b4 fe			ld (debug_mark),a  
2bb6 3a c5 2b			ld a, (.dmark+1)  
2bb9 32 b5 fe			ld (debug_mark+1),a  
2bbc 3a c6 2b			ld a, (.dmark+2)  
2bbf 32 b6 fe			ld (debug_mark+2),a  
2bc2 18 03			jr .pastdmark  
2bc4 ..			.dmark: db "LSs"  
2bc7 f1			.pastdmark: pop af  
2bc8			endm  
# End of macro DMARK
2bc8					CALLMONITOR 
2bc8 cd 46 18			call break_point_state  
2bcb				endm  
# End of macro CALLMONITOR
2bcb				endif 
2bcb				; skip dict stub 
2bcb cd 79 23				call forth_tok_next 
2bce			 
2bce			 
2bce			; while we have words to look for 
2bce			 
2bce 7e				ld a, (hl)      
2bcf				if DEBUG_FORTH_WORDS 
2bcf					DMARK "LSk" 
2bcf f5				push af  
2bd0 3a e4 2b			ld a, (.dmark)  
2bd3 32 b4 fe			ld (debug_mark),a  
2bd6 3a e5 2b			ld a, (.dmark+1)  
2bd9 32 b5 fe			ld (debug_mark+1),a  
2bdc 3a e6 2b			ld a, (.dmark+2)  
2bdf 32 b6 fe			ld (debug_mark+2),a  
2be2 18 03			jr .pastdmark  
2be4 ..			.dmark: db "LSk"  
2be7 f1			.pastdmark: pop af  
2be8			endm  
# End of macro DMARK
2be8					CALLMONITOR 
2be8 cd 46 18			call break_point_state  
2beb				endm  
# End of macro CALLMONITOR
2beb				endif 
2beb					;cp WORD_SYS_END 
2beb					;jp z, .lunotfound 
2beb			 
2beb					; if we hit non uwords then gone too far 
2beb fe 01				cp WORD_SYS_UWORD 
2bed c2 1d 2d				jp nz, .lunotfound 
2bf0			 
2bf0				if DEBUG_FORTH_WORDS 
2bf0					DMARK "LSu" 
2bf0 f5				push af  
2bf1 3a 05 2c			ld a, (.dmark)  
2bf4 32 b4 fe			ld (debug_mark),a  
2bf7 3a 06 2c			ld a, (.dmark+1)  
2bfa 32 b5 fe			ld (debug_mark+1),a  
2bfd 3a 07 2c			ld a, (.dmark+2)  
2c00 32 b6 fe			ld (debug_mark+2),a  
2c03 18 03			jr .pastdmark  
2c05 ..			.dmark: db "LSu"  
2c08 f1			.pastdmark: pop af  
2c09			endm  
# End of macro DMARK
2c09					CALLMONITOR 
2c09 cd 46 18			call break_point_state  
2c0c				endm  
# End of macro CALLMONITOR
2c0c				endif 
2c0c			 
2c0c					; found a uword but is it the one we want... 
2c0c			 
2c0c c5					push bc     ; uword to find is on bc 
2c0d d1					pop de 
2c0e			 
2c0e e5					push hl  ; to save the ptr 
2c0f			 
2c0f					; skip opcode 
2c0f 23					inc hl  
2c10					; skip next ptr 
2c10 23					inc hl  
2c11 23					inc hl 
2c12					; skip len 
2c12 23					inc hl 
2c13			 
2c13				if DEBUG_FORTH_WORDS 
2c13					DMARK "LSc" 
2c13 f5				push af  
2c14 3a 28 2c			ld a, (.dmark)  
2c17 32 b4 fe			ld (debug_mark),a  
2c1a 3a 29 2c			ld a, (.dmark+1)  
2c1d 32 b5 fe			ld (debug_mark+1),a  
2c20 3a 2a 2c			ld a, (.dmark+2)  
2c23 32 b6 fe			ld (debug_mark+2),a  
2c26 18 03			jr .pastdmark  
2c28 ..			.dmark: db "LSc"  
2c2b f1			.pastdmark: pop af  
2c2c			endm  
# End of macro DMARK
2c2c					CALLMONITOR 
2c2c cd 46 18			call break_point_state  
2c2f				endm  
# End of macro CALLMONITOR
2c2f				endif 
2c2f cd 5f 13				call strcmp 
2c32 c2 ae 2b				jp nz, .ldouscanm 
2c35				 
2c35			 
2c35			 
2c35					; we have a uword so push its name to the stack 
2c35			 
2c35			;	   	push hl  ; save so we can move to next dict block 
2c35 e1			pop hl 
2c36			 
2c36				if DEBUG_FORTH_WORDS 
2c36					DMARK "LSm" 
2c36 f5				push af  
2c37 3a 4b 2c			ld a, (.dmark)  
2c3a 32 b4 fe			ld (debug_mark),a  
2c3d 3a 4c 2c			ld a, (.dmark+1)  
2c40 32 b5 fe			ld (debug_mark+1),a  
2c43 3a 4d 2c			ld a, (.dmark+2)  
2c46 32 b6 fe			ld (debug_mark+2),a  
2c49 18 03			jr .pastdmark  
2c4b ..			.dmark: db "LSm"  
2c4e f1			.pastdmark: pop af  
2c4f			endm  
# End of macro DMARK
2c4f					CALLMONITOR 
2c4f cd 46 18			call break_point_state  
2c52				endm  
# End of macro CALLMONITOR
2c52				endif 
2c52			 
2c52					; skip opcode 
2c52 23					inc hl  
2c53					; skip next ptr 
2c53 23					inc hl  
2c54 23					inc hl 
2c55					; skip len 
2c55 7e					ld a, (hl)   ; save length to add 
2c56				if DEBUG_FORTH_WORDS 
2c56					DMARK "LS2" 
2c56 f5				push af  
2c57 3a 6b 2c			ld a, (.dmark)  
2c5a 32 b4 fe			ld (debug_mark),a  
2c5d 3a 6c 2c			ld a, (.dmark+1)  
2c60 32 b5 fe			ld (debug_mark+1),a  
2c63 3a 6d 2c			ld a, (.dmark+2)  
2c66 32 b6 fe			ld (debug_mark+2),a  
2c69 18 03			jr .pastdmark  
2c6b ..			.dmark: db "LS2"  
2c6e f1			.pastdmark: pop af  
2c6f			endm  
# End of macro DMARK
2c6f					CALLMONITOR 
2c6f cd 46 18			call break_point_state  
2c72				endm  
# End of macro CALLMONITOR
2c72				endif 
2c72			 
2c72					; save this location 
2c72				 
2c72 e5					push hl 
2c73			 
2c73 23					inc hl 
2c74 11 87 f3				ld de, scratch+2 
2c77 4f					ld c, a 
2c78 06 00				ld b, 0 
2c7a			 
2c7a				if DEBUG_FORTH_WORDS 
2c7a					DMARK "LSn" 
2c7a f5				push af  
2c7b 3a 8f 2c			ld a, (.dmark)  
2c7e 32 b4 fe			ld (debug_mark),a  
2c81 3a 90 2c			ld a, (.dmark+1)  
2c84 32 b5 fe			ld (debug_mark+1),a  
2c87 3a 91 2c			ld a, (.dmark+2)  
2c8a 32 b6 fe			ld (debug_mark+2),a  
2c8d 18 03			jr .pastdmark  
2c8f ..			.dmark: db "LSn"  
2c92 f1			.pastdmark: pop af  
2c93			endm  
# End of macro DMARK
2c93					CALLMONITOR 
2c93 cd 46 18			call break_point_state  
2c96				endm  
# End of macro CALLMONITOR
2c96				endif 
2c96			 
2c96					; copy uword name to scratch 
2c96			 
2c96 ed b0				ldir 
2c98			 
2c98 1b					dec de 
2c99 3e 20				ld a, ' '    ; change null to space 
2c9b 12					ld (de), a 
2c9c			 
2c9c 13					inc de 
2c9d			 
2c9d d5					push de 
2c9e c1					pop bc     ; move scratch pointer to end of word name and save it 
2c9f			 
2c9f e1					pop hl 
2ca0 7e					ld a, (hl) 
2ca1					;inc hl 
2ca1					; skip word string 
2ca1 cd c9 0e				call addatohl 
2ca4			 
2ca4 23					inc hl 
2ca5			 
2ca5				if DEBUG_FORTH_WORDS 
2ca5					DMARK "LS3" 
2ca5 f5				push af  
2ca6 3a ba 2c			ld a, (.dmark)  
2ca9 32 b4 fe			ld (debug_mark),a  
2cac 3a bb 2c			ld a, (.dmark+1)  
2caf 32 b5 fe			ld (debug_mark+1),a  
2cb2 3a bc 2c			ld a, (.dmark+2)  
2cb5 32 b6 fe			ld (debug_mark+2),a  
2cb8 18 03			jr .pastdmark  
2cba ..			.dmark: db "LS3"  
2cbd f1			.pastdmark: pop af  
2cbe			endm  
# End of macro DMARK
2cbe					CALLMONITOR 
2cbe cd 46 18			call break_point_state  
2cc1				endm  
# End of macro CALLMONITOR
2cc1				endif 
2cc1					; should now be at the start of the machine code to setup the eval of the uword 
2cc1					; now locate the ptr to the string defintion 
2cc1			 
2cc1					; skip ld hl, 
2cc1					; then load the ptr 
2cc1			; TODO use get from hl ptr 
2cc1 23					inc hl 
2cc2 5e					ld e, (hl) 
2cc3 23					inc hl 
2cc4 56					ld d, (hl) 
2cc5 eb					ex de, hl 
2cc6			 
2cc6			 
2cc6				if DEBUG_FORTH_WORDS 
2cc6					DMARK "LSt" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 b4 fe			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 b5 fe			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 b6 fe			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "LSt"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf					CALLMONITOR 
2cdf cd 46 18			call break_point_state  
2ce2				endm  
# End of macro CALLMONITOR
2ce2				endif 
2ce2			 
2ce2			; cant push right now due to tokenised strings  
2ce2			 
2ce2			; get the destination of where to copy this definition to. 
2ce2			 
2ce2 c5					push bc 
2ce3 d1					pop de 
2ce4			 
2ce4 7e			.listl:         ld a,(hl) 
2ce5 fe 00				cp 0 
2ce7 28 09				jr z, .lreplsp     ; replace zero with space 
2ce9					;cp FORTH_END_BUFFER 
2ce9 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ceb 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ced				 
2ced					; just copy this char as is then 
2ced			 
2ced 12					ld (de), a 
2cee			 
2cee 23			.listnxt:	inc hl 
2cef 13					inc de 
2cf0 18 f2				jr .listl 
2cf2			 
2cf2 3e 20		.lreplsp:	ld a,' ' 
2cf4 12					ld (de), a 
2cf5 18 f7				jr .listnxt 
2cf7			 
2cf7			; close up uword def 
2cf7			 
2cf7			.listdone: 
2cf7 12					ld (de), a 
2cf8 13					inc de 
2cf9 3e 00				ld a, 0 
2cfb 12					ld (de), a 
2cfc			 
2cfc			; now have def so clean up and push to stack 
2cfc			 
2cfc 21 85 f3				ld hl, scratch 
2cff				if DEBUG_FORTH_WORDS 
2cff					DMARK "Ltp" 
2cff f5				push af  
2d00 3a 14 2d			ld a, (.dmark)  
2d03 32 b4 fe			ld (debug_mark),a  
2d06 3a 15 2d			ld a, (.dmark+1)  
2d09 32 b5 fe			ld (debug_mark+1),a  
2d0c 3a 16 2d			ld a, (.dmark+2)  
2d0f 32 b6 fe			ld (debug_mark+2),a  
2d12 18 03			jr .pastdmark  
2d14 ..			.dmark: db "Ltp"  
2d17 f1			.pastdmark: pop af  
2d18			endm  
# End of macro DMARK
2d18					CALLMONITOR 
2d18 cd 46 18			call break_point_state  
2d1b				endm  
# End of macro CALLMONITOR
2d1b				endif 
2d1b			 
2d1b 18 1f			jr .listpush 
2d1d			 
2d1d			;.lnuword:	pop hl 
2d1d			;		call forth_tok_next 
2d1d			;		jp .ldouscan  
2d1d			 
2d1d			.lunotfound:		  
2d1d			 
2d1d				if DEBUG_FORTH_WORDS 
2d1d					DMARK "LSn" 
2d1d f5				push af  
2d1e 3a 32 2d			ld a, (.dmark)  
2d21 32 b4 fe			ld (debug_mark),a  
2d24 3a 33 2d			ld a, (.dmark+1)  
2d27 32 b5 fe			ld (debug_mark+1),a  
2d2a 3a 34 2d			ld a, (.dmark+2)  
2d2d 32 b6 fe			ld (debug_mark+2),a  
2d30 18 03			jr .pastdmark  
2d32 ..			.dmark: db "LSn"  
2d35 f1			.pastdmark: pop af  
2d36			endm  
# End of macro DMARK
2d36					CALLMONITOR 
2d36 cd 46 18			call break_point_state  
2d39				endm  
# End of macro CALLMONITOR
2d39				endif 
2d39			 
2d39					 
2d39			;		FORTH_DSP_POP 
2d39			;		ld hl, .luno 
2d39			 
2d39					NEXTW			 
2d39 c3 28 22			jp macro_next 
2d3c				endm 
# End of macro NEXTW
2d3c			 
2d3c			.listpush: 
2d3c				if DEBUG_FORTH_WORDS 
2d3c					DMARK "LS>" 
2d3c f5				push af  
2d3d 3a 51 2d			ld a, (.dmark)  
2d40 32 b4 fe			ld (debug_mark),a  
2d43 3a 52 2d			ld a, (.dmark+1)  
2d46 32 b5 fe			ld (debug_mark+1),a  
2d49 3a 53 2d			ld a, (.dmark+2)  
2d4c 32 b6 fe			ld (debug_mark+2),a  
2d4f 18 03			jr .pastdmark  
2d51 ..			.dmark: db "LS>"  
2d54 f1			.pastdmark: pop af  
2d55			endm  
# End of macro DMARK
2d55					CALLMONITOR 
2d55 cd 46 18			call break_point_state  
2d58				endm  
# End of macro CALLMONITOR
2d58				endif 
2d58 cd 28 1f				call forth_push_str 
2d5b			 
2d5b			 
2d5b			 
2d5b					NEXTW 
2d5b c3 28 22			jp macro_next 
2d5e				endm 
# End of macro NEXTW
2d5e			 
2d5e			;.luno:    db "Word not found",0 
2d5e			 
2d5e			 
2d5e			 
2d5e			 
2d5e			 
2d5e			;		push hl   ; save pointer to start of uword def string 
2d5e			; 
2d5e			;; look for FORTH_EOL_LINE 
2d5e			;		ld a, FORTH_END_BUFFER 
2d5e			;		call strlent 
2d5e			; 
2d5e			;		inc hl		 ; space for coln def 
2d5e			;		inc hl 
2d5e			;		inc hl          ; space for terms 
2d5e			;		inc hl 
2d5e			; 
2d5e			;		ld a, 20   ; TODO get actual length 
2d5e			;		call addatohl    ; include a random amount of room for the uword name 
2d5e			; 
2d5e			;		 
2d5e			;	if DEBUG_FORTH_WORDS 
2d5e			;		DMARK "Lt1" 
2d5e			;		CALLMONITOR 
2d5e			;	endif 
2d5e			;		 
2d5e			; 
2d5e			;; malloc space for the string because we cant change it 
2d5e			; 
2d5e			;		call malloc 
2d5e			;	if DEBUG_FORTH_MALLOC_GUARD 
2d5e			;		push af 
2d5e			;		call ishlzero 
2d5e			;		pop af 
2d5e			;		 
2d5e			;		call z,malloc_error 
2d5e			;	endif 
2d5e			; 
2d5e			;	if DEBUG_FORTH_WORDS 
2d5e			;		DMARK "Lt2" 
2d5e			;		CALLMONITOR 
2d5e			;	endif 
2d5e			;		pop de 
2d5e			;		push hl    ; push the malloc to release later 
2d5e			;		push hl   ;  push back a copy for the later stack push 
2d5e			;		 
2d5e			;; copy the string swapping out the zero terms for spaces 
2d5e			; 
2d5e			;		; de has our source 
2d5e			;		; hl has our dest 
2d5e			; 
2d5e			;; add the coln def 
2d5e			; 
2d5e			;		ld a, ':' 
2d5e			;		ld (hl), a 
2d5e			;		inc hl 
2d5e			;		ld a, ' ' 
2d5e			;		ld (hl), a 
2d5e			;		inc hl 
2d5e			; 
2d5e			;; add the uname word 
2d5e			;		push de   ; save our string for now 
2d5e			;		ex de, hl 
2d5e			; 
2d5e			;		FORTH_DSP_VALUE 
2d5e			;		;v5 FORTH_DSP_VALUE 
2d5e			; 
2d5e			;		inc hl   ; skip type but we know by now this is OK 
2d5e			; 
2d5e			;.luword:	ld a,(hl) 
2d5e			;		cp 0 
2d5e			;		jr z, .luword2 
2d5e			;		ld (de), a 
2d5e			;		inc de 
2d5e			;		inc hl 
2d5e			;		jr .luword 
2d5e			; 
2d5e			;.luword2:	ld a, ' ' 
2d5e			;		ld (de), a 
2d5e			;;		inc hl 
2d5e			;;		inc de 
2d5e			;;		ld (de), a 
2d5e			;;		inc hl 
2d5e			;		inc de 
2d5e			; 
2d5e			;		ex de, hl 
2d5e			;		pop de 
2d5e			;		 
2d5e			;		 
2d5e			; 
2d5e			;; detoken that string and copy it 
2d5e			; 
2d5e			;	if DEBUG_FORTH_WORDS 
2d5e			;		DMARK "Lt2" 
2d5e			;		CALLMONITOR 
2d5e			;	endif 
2d5e			;.ldetok:	ld a, (de) 
2d5e			;		cp FORTH_END_BUFFER 
2d5e			;		jr z, .ldetokend 
2d5e			;		; swap out any zero term for space 
2d5e			;		cp 0 
2d5e			;		jr nz, .ldetoknext 
2d5e			;		ld a, ' ' 
2d5e			; 
2d5e			;	if DEBUG_FORTH_WORDS 
2d5e			;		DMARK "LtS" 
2d5e			;		CALLMONITOR 
2d5e			;	endif 
2d5e			;.ldetoknext:	ld (hl), a 
2d5e			;		inc de 
2d5e			;		inc hl 
2d5e			;		jr .ldetok 
2d5e			; 
2d5e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d5e			;		ld (hl), a  
2d5e			; 
2d5e			;; free that temp malloc 
2d5e			; 
2d5e			;		pop hl    
2d5e			; 
2d5e			;	if DEBUG_FORTH_WORDS 
2d5e			;		DMARK "Lt4" 
2d5e			;		CALLMONITOR 
2d5e			;	endif 
2d5e			;		call forth_apushstrhl 
2d5e			; 
2d5e			;		; get rid of temp malloc area 
2d5e			; 
2d5e			;		pop hl 
2d5e			;		call free 
2d5e			; 
2d5e			;		jr .ludone 
2d5e			; 
2d5e			;.lnuword:	pop hl 
2d5e			;		call forth_tok_next 
2d5e			;		jp .ldouscan  
2d5e			; 
2d5e			;.ludone:		 pop hl 
2d5e			; 
2d5e					NEXTW 
2d5e c3 28 22			jp macro_next 
2d61				endm 
# End of macro NEXTW
2d61			 
2d61			.FORGET: 
2d61				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d61 5d				db WORD_SYS_CORE+73             
2d62 da 2d			dw .NOP            
2d64 07				db 6 + 1 
2d65 .. 00			db "FORGET",0              
2d6c				endm 
# End of macro CWHEAD
2d6c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d6c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2d6c			; | |  
2d6c			; | | e.g. "MORE" forget 
2d6c					if DEBUG_FORTH_WORDS_KEY 
2d6c						DMARK "FRG" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 b4 fe			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 b5 fe			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 b6 fe			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "FRG"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 46 18			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88				; find uword 
2d88			        ; update start of word with "_" 
2d88				; replace uword with deleted flag 
2d88			 
2d88			 
2d88			;	if DEBUG_FORTH_WORDS 
2d88			;		DMARK "FOG" 
2d88			;		CALLMONITOR 
2d88			;	endif 
2d88			 
2d88			 
2d88					; Get ptr to the word we need to look up 
2d88			 
2d88					FORTH_DSP_VALUEHL 
2d88 cd b1 20			call macro_dsp_valuehl 
2d8b				endm 
# End of macro FORTH_DSP_VALUEHL
2d8b					;v5 FORTH_DSP_VALUE 
2d8b				; TODO type check 
2d8b			;		inc hl    ; Skip type check  
2d8b e5					push hl 
2d8c c1					pop bc 
2d8d			;		ex de, hl    ; put into DE 
2d8d			 
2d8d			 
2d8d 21 00 80				ld hl, baseram 
2d90					;ld hl, baseusermem 
2d90			 
2d90				; skip dict stub 
2d90			;	call forth_tok_next 
2d90 e5			push hl   ; sacreifical push 
2d91			 
2d91			.fldouscanm: 
2d91 e1				pop hl 
2d92			.fldouscan: 
2d92			;	if DEBUG_FORTH_WORDS 
2d92			;		DMARK "LSs" 
2d92			;		CALLMONITOR 
2d92			;	endif 
2d92				; skip dict stub 
2d92 cd 79 23				call forth_tok_next 
2d95			 
2d95			 
2d95			; while we have words to look for 
2d95			 
2d95 7e				ld a, (hl)      
2d96			;	if DEBUG_FORTH_WORDS 
2d96			;		DMARK "LSk" 
2d96			;		CALLMONITOR 
2d96			;	endif 
2d96 fe 00				cp WORD_SYS_END 
2d98 ca d4 2d				jp z, .flunotfound 
2d9b fe 01				cp WORD_SYS_UWORD 
2d9d c2 92 2d				jp nz, .fldouscan 
2da0			 
2da0			;	if DEBUG_FORTH_WORDS 
2da0			;		DMARK "LSu" 
2da0			;		CALLMONITOR 
2da0			;	endif 
2da0			 
2da0					; found a uword but is it the one we want... 
2da0			 
2da0 c5					push bc     ; uword to find is on bc 
2da1 d1					pop de 
2da2			 
2da2 e5					push hl  ; to save the ptr 
2da3			 
2da3					; skip opcode 
2da3 23					inc hl  
2da4					; skip next ptr 
2da4 23					inc hl  
2da5 23					inc hl 
2da6					; skip len 
2da6 23					inc hl 
2da7			 
2da7			;	if DEBUG_FORTH_WORDS 
2da7			;		DMARK "LSc" 
2da7			;		CALLMONITOR 
2da7			;	endif 
2da7 cd 5f 13				call strcmp 
2daa c2 91 2d				jp nz, .fldouscanm 
2dad			; 
2dad			; 
2dad			;; while we have words to look for 
2dad			; 
2dad			;.fdouscan:	ld a, (hl)      
2dad			;	if DEBUG_FORTH_WORDS 
2dad			;		DMARK "LSs" 
2dad			;		CALLMONITOR 
2dad			;	endif 
2dad			;		cp WORD_SYS_END 
2dad			;		jp z, .fudone 
2dad			;		cp WORD_SYS_UWORD 
2dad			;		jp nz, .fnuword 
2dad			; 
2dad			;	if DEBUG_FORTH_WORDS 
2dad			;		DMARK "FGu" 
2dad			;		CALLMONITOR 
2dad			;	endif 
2dad			; 
2dad			;		; found a uword but is it the one we want... 
2dad			; 
2dad			; 
2dad			;	        pop de   ; get back the dsp name 
2dad			;		push de 
2dad			; 
2dad			;		push hl  ; to save the ptr 
2dad			; 
2dad			;		; skip opcode 
2dad			;		inc hl  
2dad			;		; skip next ptr 
2dad			;		inc hl  
2dad			;		inc hl 
2dad			;		; skip len 
2dad			;		inc hl 
2dad			; 
2dad			;	if DEBUG_FORTH_WORDS 
2dad			;		DMARK "FGc" 
2dad			;		CALLMONITOR 
2dad			;	endif 
2dad			;		call strcmp 
2dad			;		jp nz, .fnuword 
2dad			 
2dad			 
2dad e1			pop hl 
2dae			 
2dae				 
2dae				if DEBUG_FORTH_WORDS 
2dae					DMARK "FGm" 
2dae f5				push af  
2daf 3a c3 2d			ld a, (.dmark)  
2db2 32 b4 fe			ld (debug_mark),a  
2db5 3a c4 2d			ld a, (.dmark+1)  
2db8 32 b5 fe			ld (debug_mark+1),a  
2dbb 3a c5 2d			ld a, (.dmark+2)  
2dbe 32 b6 fe			ld (debug_mark+2),a  
2dc1 18 03			jr .pastdmark  
2dc3 ..			.dmark: db "FGm"  
2dc6 f1			.pastdmark: pop af  
2dc7			endm  
# End of macro DMARK
2dc7					CALLMONITOR 
2dc7 cd 46 18			call break_point_state  
2dca				endm  
# End of macro CALLMONITOR
2dca				endif 
2dca			 
2dca			 
2dca			 
2dca					; we have a uword so push its name to the stack 
2dca			 
2dca			;	   	push hl  ; save so we can move to next dict block 
2dca			;pop hl 
2dca			 
2dca					; update opcode to deleted 
2dca 3e 03				ld a, WORD_SYS_DELETED 
2dcc 77					ld (hl), a 
2dcd			 
2dcd 23					inc hl  
2dce					; skip next ptr 
2dce 23					inc hl  
2dcf 23					inc hl 
2dd0					; skip len 
2dd0 23					inc hl 
2dd1			 
2dd1					; TODO change parser to skip deleted words but for now mark it out 
2dd1 3e 5f				ld a, "_" 
2dd3 77					ld  (hl),a 
2dd4			 
2dd4			;		jr .fudone 
2dd4			; 
2dd4			;.fnuword:	pop hl 
2dd4			;		call forth_tok_next 
2dd4			;		jp .fdouscan  
2dd4			 
2dd4			.flunotfound:		  
2dd4			 
2dd4			 
2dd4					 
2dd4					FORTH_DSP_POP 
2dd4 cd 69 21			call macro_forth_dsp_pop 
2dd7				endm 
# End of macro FORTH_DSP_POP
2dd7			;		ld hl, .luno 
2dd7			;.fudone:		 pop hl 
2dd7					NEXTW 
2dd7 c3 28 22			jp macro_next 
2dda				endm 
# End of macro NEXTW
2dda			.NOP: 
2dda				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2dda 61				db WORD_SYS_CORE+77             
2ddb 01 2e			dw .COMO            
2ddd 04				db 3 + 1 
2dde .. 00			db "NOP",0              
2de2				endm 
# End of macro CWHEAD
2de2			; | NOP (  --  ) Do nothing | DONE 
2de2					if DEBUG_FORTH_WORDS_KEY 
2de2						DMARK "NOP" 
2de2 f5				push af  
2de3 3a f7 2d			ld a, (.dmark)  
2de6 32 b4 fe			ld (debug_mark),a  
2de9 3a f8 2d			ld a, (.dmark+1)  
2dec 32 b5 fe			ld (debug_mark+1),a  
2def 3a f9 2d			ld a, (.dmark+2)  
2df2 32 b6 fe			ld (debug_mark+2),a  
2df5 18 03			jr .pastdmark  
2df7 ..			.dmark: db "NOP"  
2dfa f1			.pastdmark: pop af  
2dfb			endm  
# End of macro DMARK
2dfb						CALLMONITOR 
2dfb cd 46 18			call break_point_state  
2dfe				endm  
# End of macro CALLMONITOR
2dfe					endif 
2dfe				       NEXTW 
2dfe c3 28 22			jp macro_next 
2e01				endm 
# End of macro NEXTW
2e01			.COMO: 
2e01				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e01 6e				db WORD_SYS_CORE+90             
2e02 53 2e			dw .COMC            
2e04 02				db 1 + 1 
2e05 .. 00			db "(",0              
2e07				endm 
# End of macro CWHEAD
2e07			; | ( ( -- )  Start of comment | DONE 
2e07			 
2e07			 
2e07 2a 86 f6				ld hl, ( os_tok_ptr) 
2e0a 11 4e 2e			ld de, .closepar 
2e0d					 
2e0d					if DEBUG_FORTH_WORDS 
2e0d						DMARK ").." 
2e0d f5				push af  
2e0e 3a 22 2e			ld a, (.dmark)  
2e11 32 b4 fe			ld (debug_mark),a  
2e14 3a 23 2e			ld a, (.dmark+1)  
2e17 32 b5 fe			ld (debug_mark+1),a  
2e1a 3a 24 2e			ld a, (.dmark+2)  
2e1d 32 b6 fe			ld (debug_mark+2),a  
2e20 18 03			jr .pastdmark  
2e22 ..			.dmark: db ").."  
2e25 f1			.pastdmark: pop af  
2e26			endm  
# End of macro DMARK
2e26						CALLMONITOR 
2e26 cd 46 18			call break_point_state  
2e29				endm  
# End of macro CALLMONITOR
2e29					endif 
2e29 cd 43 23			call findnexttok  
2e2c			 
2e2c					if DEBUG_FORTH_WORDS 
2e2c						DMARK "IF5" 
2e2c f5				push af  
2e2d 3a 41 2e			ld a, (.dmark)  
2e30 32 b4 fe			ld (debug_mark),a  
2e33 3a 42 2e			ld a, (.dmark+1)  
2e36 32 b5 fe			ld (debug_mark+1),a  
2e39 3a 43 2e			ld a, (.dmark+2)  
2e3c 32 b6 fe			ld (debug_mark+2),a  
2e3f 18 03			jr .pastdmark  
2e41 ..			.dmark: db "IF5"  
2e44 f1			.pastdmark: pop af  
2e45			endm  
# End of macro DMARK
2e45						CALLMONITOR 
2e45 cd 46 18			call break_point_state  
2e48				endm  
# End of macro CALLMONITOR
2e48					endif 
2e48				; replace below with ) exec using tok_ptr 
2e48 22 86 f6			ld (os_tok_ptr), hl 
2e4b c3 b9 22			jp exec1 
2e4e			 
2e4e .. 00			.closepar:   db ")",0 
2e50			 
2e50				       NEXTW 
2e50 c3 28 22			jp macro_next 
2e53				endm 
# End of macro NEXTW
2e53			.COMC: 
2e53				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e53 6f				db WORD_SYS_CORE+91             
2e54 5c 2e			dw .SCRATCH            
2e56 02				db 1 + 1 
2e57 .. 00			db ")",0              
2e59				endm 
# End of macro CWHEAD
2e59			; | ) ( -- )  End of comment |  DONE  
2e59				       NEXTW 
2e59 c3 28 22			jp macro_next 
2e5c				endm 
# End of macro NEXTW
2e5c			 
2e5c			.SCRATCH: 
2e5c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e5c 6f				db WORD_SYS_CORE+91             
2e5d 97 2e			dw .INC            
2e5f 08				db 7 + 1 
2e60 .. 00			db "SCRATCH",0              
2e68				endm 
# End of macro CWHEAD
2e68			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e68			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e68			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e68			; | |  
2e68			; | | e.g.    : score $00 scratch ; 
2e68			; | |  
2e68			; | | $00 score ! 
2e68			; | | $01 score +! 
2e68			; | |  
2e68			; | | e.g.   : varword $0a scratch ;  
2e68			; | | 
2e68			; | | $8000 varword ! 
2e68					if DEBUG_FORTH_WORDS_KEY 
2e68						DMARK "SCR" 
2e68 f5				push af  
2e69 3a 7d 2e			ld a, (.dmark)  
2e6c 32 b4 fe			ld (debug_mark),a  
2e6f 3a 7e 2e			ld a, (.dmark+1)  
2e72 32 b5 fe			ld (debug_mark+1),a  
2e75 3a 7f 2e			ld a, (.dmark+2)  
2e78 32 b6 fe			ld (debug_mark+2),a  
2e7b 18 03			jr .pastdmark  
2e7d ..			.dmark: db "SCR"  
2e80 f1			.pastdmark: pop af  
2e81			endm  
# End of macro DMARK
2e81						CALLMONITOR 
2e81 cd 46 18			call break_point_state  
2e84				endm  
# End of macro CALLMONITOR
2e84					endif 
2e84			 
2e84					FORTH_DSP_VALUEHL 
2e84 cd b1 20			call macro_dsp_valuehl 
2e87				endm 
# End of macro FORTH_DSP_VALUEHL
2e87				 
2e87					FORTH_DSP_POP 
2e87 cd 69 21			call macro_forth_dsp_pop 
2e8a				endm 
# End of macro FORTH_DSP_POP
2e8a			 
2e8a 7d					ld a, l 
2e8b 21 aa f8				ld hl, os_var_array 
2e8e cd c9 0e				call addatohl 
2e91			 
2e91 cd ba 1e				call forth_push_numhl 
2e94			 
2e94				       NEXTW 
2e94 c3 28 22			jp macro_next 
2e97				endm 
# End of macro NEXTW
2e97			 
2e97			.INC: 
2e97				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2e97 6f				db WORD_SYS_CORE+91             
2e98 eb 2e			dw .DEC            
2e9a 03				db 2 + 1 
2e9b .. 00			db "+!",0              
2e9e				endm 
# End of macro CWHEAD
2e9e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2e9e					if DEBUG_FORTH_WORDS_KEY 
2e9e						DMARK "+s_" 
2e9e f5				push af  
2e9f 3a b3 2e			ld a, (.dmark)  
2ea2 32 b4 fe			ld (debug_mark),a  
2ea5 3a b4 2e			ld a, (.dmark+1)  
2ea8 32 b5 fe			ld (debug_mark+1),a  
2eab 3a b5 2e			ld a, (.dmark+2)  
2eae 32 b6 fe			ld (debug_mark+2),a  
2eb1 18 03			jr .pastdmark  
2eb3 ..			.dmark: db "+s_"  
2eb6 f1			.pastdmark: pop af  
2eb7			endm  
# End of macro DMARK
2eb7						CALLMONITOR 
2eb7 cd 46 18			call break_point_state  
2eba				endm  
# End of macro CALLMONITOR
2eba					endif 
2eba			 
2eba					FORTH_DSP_VALUEHL 
2eba cd b1 20			call macro_dsp_valuehl 
2ebd				endm 
# End of macro FORTH_DSP_VALUEHL
2ebd			 
2ebd e5					push hl   ; save address 
2ebe			 
2ebe					FORTH_DSP_POP 
2ebe cd 69 21			call macro_forth_dsp_pop 
2ec1				endm 
# End of macro FORTH_DSP_POP
2ec1			 
2ec1					FORTH_DSP_VALUEHL 
2ec1 cd b1 20			call macro_dsp_valuehl 
2ec4				endm 
# End of macro FORTH_DSP_VALUEHL
2ec4			 
2ec4					FORTH_DSP_POP 
2ec4 cd 69 21			call macro_forth_dsp_pop 
2ec7				endm 
# End of macro FORTH_DSP_POP
2ec7			 
2ec7					; hl contains value to add to byte at a 
2ec7				 
2ec7 eb					ex de, hl 
2ec8			 
2ec8 e1					pop hl 
2ec9			 
2ec9					if DEBUG_FORTH_WORDS 
2ec9						DMARK "INC" 
2ec9 f5				push af  
2eca 3a de 2e			ld a, (.dmark)  
2ecd 32 b4 fe			ld (debug_mark),a  
2ed0 3a df 2e			ld a, (.dmark+1)  
2ed3 32 b5 fe			ld (debug_mark+1),a  
2ed6 3a e0 2e			ld a, (.dmark+2)  
2ed9 32 b6 fe			ld (debug_mark+2),a  
2edc 18 03			jr .pastdmark  
2ede ..			.dmark: db "INC"  
2ee1 f1			.pastdmark: pop af  
2ee2			endm  
# End of macro DMARK
2ee2						CALLMONITOR 
2ee2 cd 46 18			call break_point_state  
2ee5				endm  
# End of macro CALLMONITOR
2ee5					endif 
2ee5			 
2ee5 7e					ld a,(hl) 
2ee6 83					add e 
2ee7 77					ld (hl),a 
2ee8			 
2ee8			 
2ee8			 
2ee8				       NEXTW 
2ee8 c3 28 22			jp macro_next 
2eeb				endm 
# End of macro NEXTW
2eeb			 
2eeb			.DEC: 
2eeb				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2eeb 6f				db WORD_SYS_CORE+91             
2eec 3c 2f			dw .INC2            
2eee 03				db 2 + 1 
2eef .. 00			db "-!",0              
2ef2				endm 
# End of macro CWHEAD
2ef2			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ef2					if DEBUG_FORTH_WORDS_KEY 
2ef2						DMARK "-s_" 
2ef2 f5				push af  
2ef3 3a 07 2f			ld a, (.dmark)  
2ef6 32 b4 fe			ld (debug_mark),a  
2ef9 3a 08 2f			ld a, (.dmark+1)  
2efc 32 b5 fe			ld (debug_mark+1),a  
2eff 3a 09 2f			ld a, (.dmark+2)  
2f02 32 b6 fe			ld (debug_mark+2),a  
2f05 18 03			jr .pastdmark  
2f07 ..			.dmark: db "-s_"  
2f0a f1			.pastdmark: pop af  
2f0b			endm  
# End of macro DMARK
2f0b						CALLMONITOR 
2f0b cd 46 18			call break_point_state  
2f0e				endm  
# End of macro CALLMONITOR
2f0e					endif 
2f0e			 
2f0e					FORTH_DSP_VALUEHL 
2f0e cd b1 20			call macro_dsp_valuehl 
2f11				endm 
# End of macro FORTH_DSP_VALUEHL
2f11			 
2f11 e5					push hl   ; save address 
2f12			 
2f12					FORTH_DSP_POP 
2f12 cd 69 21			call macro_forth_dsp_pop 
2f15				endm 
# End of macro FORTH_DSP_POP
2f15			 
2f15					FORTH_DSP_VALUEHL 
2f15 cd b1 20			call macro_dsp_valuehl 
2f18				endm 
# End of macro FORTH_DSP_VALUEHL
2f18			 
2f18					; hl contains value to add to byte at a 
2f18				 
2f18 eb					ex de, hl 
2f19			 
2f19 e1					pop hl 
2f1a			 
2f1a					if DEBUG_FORTH_WORDS 
2f1a						DMARK "DEC" 
2f1a f5				push af  
2f1b 3a 2f 2f			ld a, (.dmark)  
2f1e 32 b4 fe			ld (debug_mark),a  
2f21 3a 30 2f			ld a, (.dmark+1)  
2f24 32 b5 fe			ld (debug_mark+1),a  
2f27 3a 31 2f			ld a, (.dmark+2)  
2f2a 32 b6 fe			ld (debug_mark+2),a  
2f2d 18 03			jr .pastdmark  
2f2f ..			.dmark: db "DEC"  
2f32 f1			.pastdmark: pop af  
2f33			endm  
# End of macro DMARK
2f33						CALLMONITOR 
2f33 cd 46 18			call break_point_state  
2f36				endm  
# End of macro CALLMONITOR
2f36					endif 
2f36			 
2f36 7e					ld a,(hl) 
2f37 93					sub e 
2f38 77					ld (hl),a 
2f39			 
2f39			 
2f39			 
2f39				       NEXTW 
2f39 c3 28 22			jp macro_next 
2f3c				endm 
# End of macro NEXTW
2f3c			 
2f3c			.INC2: 
2f3c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f3c 6f				db WORD_SYS_CORE+91             
2f3d e6 2f			dw .DEC2            
2f3f 04				db 3 + 1 
2f40 .. 00			db "+2!",0              
2f44				endm 
# End of macro CWHEAD
2f44			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f44			 
2f44					if DEBUG_FORTH_WORDS_KEY 
2f44						DMARK "+2s" 
2f44 f5				push af  
2f45 3a 59 2f			ld a, (.dmark)  
2f48 32 b4 fe			ld (debug_mark),a  
2f4b 3a 5a 2f			ld a, (.dmark+1)  
2f4e 32 b5 fe			ld (debug_mark+1),a  
2f51 3a 5b 2f			ld a, (.dmark+2)  
2f54 32 b6 fe			ld (debug_mark+2),a  
2f57 18 03			jr .pastdmark  
2f59 ..			.dmark: db "+2s"  
2f5c f1			.pastdmark: pop af  
2f5d			endm  
# End of macro DMARK
2f5d						CALLMONITOR 
2f5d cd 46 18			call break_point_state  
2f60				endm  
# End of macro CALLMONITOR
2f60					endif 
2f60			 
2f60					; Address 
2f60			 
2f60					FORTH_DSP_VALUEHL 
2f60 cd b1 20			call macro_dsp_valuehl 
2f63				endm 
# End of macro FORTH_DSP_VALUEHL
2f63			 
2f63 e5					push hl    ; save address 
2f64			 
2f64					; load content into de 
2f64			 
2f64 5e					ld e,(hl) 
2f65 23					inc hl 
2f66 56					ld d, (hl) 
2f67			 
2f67					if DEBUG_FORTH_WORDS 
2f67						DMARK "+2a" 
2f67 f5				push af  
2f68 3a 7c 2f			ld a, (.dmark)  
2f6b 32 b4 fe			ld (debug_mark),a  
2f6e 3a 7d 2f			ld a, (.dmark+1)  
2f71 32 b5 fe			ld (debug_mark+1),a  
2f74 3a 7e 2f			ld a, (.dmark+2)  
2f77 32 b6 fe			ld (debug_mark+2),a  
2f7a 18 03			jr .pastdmark  
2f7c ..			.dmark: db "+2a"  
2f7f f1			.pastdmark: pop af  
2f80			endm  
# End of macro DMARK
2f80						CALLMONITOR 
2f80 cd 46 18			call break_point_state  
2f83				endm  
# End of macro CALLMONITOR
2f83					endif 
2f83			 
2f83					FORTH_DSP_POP 
2f83 cd 69 21			call macro_forth_dsp_pop 
2f86				endm 
# End of macro FORTH_DSP_POP
2f86			 
2f86					; Get value to add 
2f86			 
2f86					FORTH_DSP_VALUE 
2f86 cd 9a 20			call macro_forth_dsp_value 
2f89				endm 
# End of macro FORTH_DSP_VALUE
2f89			 
2f89					if DEBUG_FORTH_WORDS 
2f89						DMARK "+2v" 
2f89 f5				push af  
2f8a 3a 9e 2f			ld a, (.dmark)  
2f8d 32 b4 fe			ld (debug_mark),a  
2f90 3a 9f 2f			ld a, (.dmark+1)  
2f93 32 b5 fe			ld (debug_mark+1),a  
2f96 3a a0 2f			ld a, (.dmark+2)  
2f99 32 b6 fe			ld (debug_mark+2),a  
2f9c 18 03			jr .pastdmark  
2f9e ..			.dmark: db "+2v"  
2fa1 f1			.pastdmark: pop af  
2fa2			endm  
# End of macro DMARK
2fa2						CALLMONITOR 
2fa2 cd 46 18			call break_point_state  
2fa5				endm  
# End of macro CALLMONITOR
2fa5					endif 
2fa5			 
2fa5 19					add hl, de 
2fa6			 
2fa6					if DEBUG_FORTH_WORDS 
2fa6						DMARK "+2+" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 b4 fe			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 b5 fe			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 b6 fe			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "+2+"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd 46 18			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2					endif 
2fc2			 
2fc2					; move result to de 
2fc2			 
2fc2 eb					ex de, hl 
2fc3			 
2fc3					; Address 
2fc3			 
2fc3 e1					pop hl 
2fc4			 
2fc4					; save it back 
2fc4			 
2fc4 73					ld (hl), e 
2fc5 23					inc hl 
2fc6 72					ld (hl), d 
2fc7			 
2fc7					if DEBUG_FORTH_WORDS 
2fc7						DMARK "+2e" 
2fc7 f5				push af  
2fc8 3a dc 2f			ld a, (.dmark)  
2fcb 32 b4 fe			ld (debug_mark),a  
2fce 3a dd 2f			ld a, (.dmark+1)  
2fd1 32 b5 fe			ld (debug_mark+1),a  
2fd4 3a de 2f			ld a, (.dmark+2)  
2fd7 32 b6 fe			ld (debug_mark+2),a  
2fda 18 03			jr .pastdmark  
2fdc ..			.dmark: db "+2e"  
2fdf f1			.pastdmark: pop af  
2fe0			endm  
# End of macro DMARK
2fe0						CALLMONITOR 
2fe0 cd 46 18			call break_point_state  
2fe3				endm  
# End of macro CALLMONITOR
2fe3					endif 
2fe3			 
2fe3			 
2fe3			 
2fe3			 
2fe3			 
2fe3				       NEXTW 
2fe3 c3 28 22			jp macro_next 
2fe6				endm 
# End of macro NEXTW
2fe6			 
2fe6			.DEC2: 
2fe6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2fe6 6f				db WORD_SYS_CORE+91             
2fe7 92 30			dw .GET2            
2fe9 04				db 3 + 1 
2fea .. 00			db "-2!",0              
2fee				endm 
# End of macro CWHEAD
2fee			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2fee			 
2fee			 
2fee					if DEBUG_FORTH_WORDS_KEY 
2fee						DMARK "-2s" 
2fee f5				push af  
2fef 3a 03 30			ld a, (.dmark)  
2ff2 32 b4 fe			ld (debug_mark),a  
2ff5 3a 04 30			ld a, (.dmark+1)  
2ff8 32 b5 fe			ld (debug_mark+1),a  
2ffb 3a 05 30			ld a, (.dmark+2)  
2ffe 32 b6 fe			ld (debug_mark+2),a  
3001 18 03			jr .pastdmark  
3003 ..			.dmark: db "-2s"  
3006 f1			.pastdmark: pop af  
3007			endm  
# End of macro DMARK
3007						CALLMONITOR 
3007 cd 46 18			call break_point_state  
300a				endm  
# End of macro CALLMONITOR
300a					endif 
300a			 
300a					; Address 
300a			 
300a					FORTH_DSP_VALUEHL 
300a cd b1 20			call macro_dsp_valuehl 
300d				endm 
# End of macro FORTH_DSP_VALUEHL
300d			 
300d e5					push hl    ; save address 
300e			 
300e					; load content into de 
300e			 
300e 5e					ld e,(hl) 
300f 23					inc hl 
3010 56					ld d, (hl) 
3011			 
3011					if DEBUG_FORTH_WORDS 
3011						DMARK "-2a" 
3011 f5				push af  
3012 3a 26 30			ld a, (.dmark)  
3015 32 b4 fe			ld (debug_mark),a  
3018 3a 27 30			ld a, (.dmark+1)  
301b 32 b5 fe			ld (debug_mark+1),a  
301e 3a 28 30			ld a, (.dmark+2)  
3021 32 b6 fe			ld (debug_mark+2),a  
3024 18 03			jr .pastdmark  
3026 ..			.dmark: db "-2a"  
3029 f1			.pastdmark: pop af  
302a			endm  
# End of macro DMARK
302a						CALLMONITOR 
302a cd 46 18			call break_point_state  
302d				endm  
# End of macro CALLMONITOR
302d					endif 
302d			 
302d					FORTH_DSP_POP 
302d cd 69 21			call macro_forth_dsp_pop 
3030				endm 
# End of macro FORTH_DSP_POP
3030			 
3030					; Get value to remove 
3030			 
3030					FORTH_DSP_VALUE 
3030 cd 9a 20			call macro_forth_dsp_value 
3033				endm 
# End of macro FORTH_DSP_VALUE
3033			 
3033					if DEBUG_FORTH_WORDS 
3033						DMARK "-2v" 
3033 f5				push af  
3034 3a 48 30			ld a, (.dmark)  
3037 32 b4 fe			ld (debug_mark),a  
303a 3a 49 30			ld a, (.dmark+1)  
303d 32 b5 fe			ld (debug_mark+1),a  
3040 3a 4a 30			ld a, (.dmark+2)  
3043 32 b6 fe			ld (debug_mark+2),a  
3046 18 03			jr .pastdmark  
3048 ..			.dmark: db "-2v"  
304b f1			.pastdmark: pop af  
304c			endm  
# End of macro DMARK
304c						CALLMONITOR 
304c cd 46 18			call break_point_state  
304f				endm  
# End of macro CALLMONITOR
304f					endif 
304f			 
304f eb					ex de, hl 
3050 ed 52				sbc hl, de 
3052			 
3052					if DEBUG_FORTH_WORDS 
3052						DMARK "-2d" 
3052 f5				push af  
3053 3a 67 30			ld a, (.dmark)  
3056 32 b4 fe			ld (debug_mark),a  
3059 3a 68 30			ld a, (.dmark+1)  
305c 32 b5 fe			ld (debug_mark+1),a  
305f 3a 69 30			ld a, (.dmark+2)  
3062 32 b6 fe			ld (debug_mark+2),a  
3065 18 03			jr .pastdmark  
3067 ..			.dmark: db "-2d"  
306a f1			.pastdmark: pop af  
306b			endm  
# End of macro DMARK
306b						CALLMONITOR 
306b cd 46 18			call break_point_state  
306e				endm  
# End of macro CALLMONITOR
306e					endif 
306e			 
306e					; move result to de 
306e			 
306e eb					ex de, hl 
306f			 
306f					; Address 
306f			 
306f e1					pop hl 
3070			 
3070					; save it back 
3070			 
3070 73					ld (hl), e 
3071 23					inc hl 
3072 72					ld (hl), d 
3073			 
3073					if DEBUG_FORTH_WORDS 
3073						DMARK "-2e" 
3073 f5				push af  
3074 3a 88 30			ld a, (.dmark)  
3077 32 b4 fe			ld (debug_mark),a  
307a 3a 89 30			ld a, (.dmark+1)  
307d 32 b5 fe			ld (debug_mark+1),a  
3080 3a 8a 30			ld a, (.dmark+2)  
3083 32 b6 fe			ld (debug_mark+2),a  
3086 18 03			jr .pastdmark  
3088 ..			.dmark: db "-2e"  
308b f1			.pastdmark: pop af  
308c			endm  
# End of macro DMARK
308c						CALLMONITOR 
308c cd 46 18			call break_point_state  
308f				endm  
# End of macro CALLMONITOR
308f					endif 
308f			 
308f			 
308f			 
308f			 
308f			 
308f				       NEXTW 
308f c3 28 22			jp macro_next 
3092				endm 
# End of macro NEXTW
3092			.GET2: 
3092				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3092 6f				db WORD_SYS_CORE+91             
3093 c2 30			dw .BANG2            
3095 03				db 2 + 1 
3096 .. 00			db "2@",0              
3099				endm 
# End of macro CWHEAD
3099			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3099					if DEBUG_FORTH_WORDS_KEY 
3099						DMARK "2A_" 
3099 f5				push af  
309a 3a ae 30			ld a, (.dmark)  
309d 32 b4 fe			ld (debug_mark),a  
30a0 3a af 30			ld a, (.dmark+1)  
30a3 32 b5 fe			ld (debug_mark+1),a  
30a6 3a b0 30			ld a, (.dmark+2)  
30a9 32 b6 fe			ld (debug_mark+2),a  
30ac 18 03			jr .pastdmark  
30ae ..			.dmark: db "2A_"  
30b1 f1			.pastdmark: pop af  
30b2			endm  
# End of macro DMARK
30b2						CALLMONITOR 
30b2 cd 46 18			call break_point_state  
30b5				endm  
# End of macro CALLMONITOR
30b5					endif 
30b5			 
30b5					FORTH_DSP_VALUEHL 
30b5 cd b1 20			call macro_dsp_valuehl 
30b8				endm 
# End of macro FORTH_DSP_VALUEHL
30b8			 
30b8 5e					ld e, (hl) 
30b9 23					inc hl 
30ba 56					ld d, (hl) 
30bb			 
30bb eb					ex de, hl 
30bc			 
30bc cd ba 1e				call forth_push_numhl 
30bf			 
30bf				       NEXTW 
30bf c3 28 22			jp macro_next 
30c2				endm 
# End of macro NEXTW
30c2			.BANG2: 
30c2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30c2 6f				db WORD_SYS_CORE+91             
30c3 fa 30			dw .CONFIG            
30c5 03				db 2 + 1 
30c6 .. 00			db "2!",0              
30c9				endm 
# End of macro CWHEAD
30c9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30c9					if DEBUG_FORTH_WORDS_KEY 
30c9						DMARK "2S_" 
30c9 f5				push af  
30ca 3a de 30			ld a, (.dmark)  
30cd 32 b4 fe			ld (debug_mark),a  
30d0 3a df 30			ld a, (.dmark+1)  
30d3 32 b5 fe			ld (debug_mark+1),a  
30d6 3a e0 30			ld a, (.dmark+2)  
30d9 32 b6 fe			ld (debug_mark+2),a  
30dc 18 03			jr .pastdmark  
30de ..			.dmark: db "2S_"  
30e1 f1			.pastdmark: pop af  
30e2			endm  
# End of macro DMARK
30e2						CALLMONITOR 
30e2 cd 46 18			call break_point_state  
30e5				endm  
# End of macro CALLMONITOR
30e5					endif 
30e5			 
30e5					FORTH_DSP_VALUEHL 
30e5 cd b1 20			call macro_dsp_valuehl 
30e8				endm 
# End of macro FORTH_DSP_VALUEHL
30e8			 
30e8 e5					push hl   ; save address 
30e9			 
30e9			 
30e9					FORTH_DSP_POP 
30e9 cd 69 21			call macro_forth_dsp_pop 
30ec				endm 
# End of macro FORTH_DSP_POP
30ec			 
30ec					 
30ec					FORTH_DSP_VALUEHL 
30ec cd b1 20			call macro_dsp_valuehl 
30ef				endm 
# End of macro FORTH_DSP_VALUEHL
30ef			 
30ef					FORTH_DSP_POP 
30ef cd 69 21			call macro_forth_dsp_pop 
30f2				endm 
# End of macro FORTH_DSP_POP
30f2			 
30f2 eb					ex de, hl    ; value now in de 
30f3			 
30f3 e1					pop hl 
30f4			 
30f4 73					ld (hl), e 
30f5			 
30f5 23					inc hl 
30f6			 
30f6 72					ld (hl), d 
30f7			 
30f7			 
30f7				       NEXTW 
30f7 c3 28 22			jp macro_next 
30fa				endm 
# End of macro NEXTW
30fa			.CONFIG: 
30fa				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
30fa 6f				db WORD_SYS_CORE+91             
30fb 0b 31			dw .ENDCORE            
30fd 07				db 6 + 1 
30fe .. 00			db "CONFIG",0              
3105				endm 
# End of macro CWHEAD
3105			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3105			 
3105 cd 29 15				call config 
3108					NEXTW 
3108 c3 28 22			jp macro_next 
310b				endm 
# End of macro NEXTW
310b			.ENDCORE: 
310b			 
310b			; eof 
310b			 
310b			 
# End of file forth_words_core.asm
310b			include "forth_words_flow.asm" 
310b			 
310b			; | ## Program Flow Words 
310b			 
310b			.IF: 
310b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
310b 1e				db WORD_SYS_CORE+10             
310c 00 32			dw .THEN            
310e 03				db 2 + 1 
310f .. 00			db "IF",0              
3112				endm 
# End of macro CWHEAD
3112			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3112			; 
3112					if DEBUG_FORTH_WORDS_KEY 
3112						DMARK "IF." 
3112 f5				push af  
3113 3a 27 31			ld a, (.dmark)  
3116 32 b4 fe			ld (debug_mark),a  
3119 3a 28 31			ld a, (.dmark+1)  
311c 32 b5 fe			ld (debug_mark+1),a  
311f 3a 29 31			ld a, (.dmark+2)  
3122 32 b6 fe			ld (debug_mark+2),a  
3125 18 03			jr .pastdmark  
3127 ..			.dmark: db "IF."  
312a f1			.pastdmark: pop af  
312b			endm  
# End of macro DMARK
312b						CALLMONITOR 
312b cd 46 18			call break_point_state  
312e				endm  
# End of macro CALLMONITOR
312e					endif 
312e			; eval TOS 
312e			 
312e				FORTH_DSP_VALUEHL 
312e cd b1 20			call macro_dsp_valuehl 
3131				endm 
# End of macro FORTH_DSP_VALUEHL
3131			 
3131			;	push hl 
3131				FORTH_DSP_POP 
3131 cd 69 21			call macro_forth_dsp_pop 
3134				endm 
# End of macro FORTH_DSP_POP
3134			;	pop hl 
3134			 
3134					if DEBUG_FORTH_WORDS 
3134						DMARK "IF1" 
3134 f5				push af  
3135 3a 49 31			ld a, (.dmark)  
3138 32 b4 fe			ld (debug_mark),a  
313b 3a 4a 31			ld a, (.dmark+1)  
313e 32 b5 fe			ld (debug_mark+1),a  
3141 3a 4b 31			ld a, (.dmark+2)  
3144 32 b6 fe			ld (debug_mark+2),a  
3147 18 03			jr .pastdmark  
3149 ..			.dmark: db "IF1"  
314c f1			.pastdmark: pop af  
314d			endm  
# End of macro DMARK
314d						CALLMONITOR 
314d cd 46 18			call break_point_state  
3150				endm  
# End of macro CALLMONITOR
3150					endif 
3150 b7				or a        ; clear carry flag 
3151 11 00 00			ld de, 0 
3154 eb				ex de,hl 
3155 ed 52			sbc hl, de 
3157 c2 e1 31			jp nz, .iftrue 
315a			 
315a					if DEBUG_FORTH_WORDS 
315a						DMARK "IF2" 
315a f5				push af  
315b 3a 6f 31			ld a, (.dmark)  
315e 32 b4 fe			ld (debug_mark),a  
3161 3a 70 31			ld a, (.dmark+1)  
3164 32 b5 fe			ld (debug_mark+1),a  
3167 3a 71 31			ld a, (.dmark+2)  
316a 32 b6 fe			ld (debug_mark+2),a  
316d 18 03			jr .pastdmark  
316f ..			.dmark: db "IF2"  
3172 f1			.pastdmark: pop af  
3173			endm  
# End of macro DMARK
3173						CALLMONITOR 
3173 cd 46 18			call break_point_state  
3176				endm  
# End of macro CALLMONITOR
3176					endif 
3176			 
3176			; if not true then skip to THEN 
3176			 
3176				; TODO get tok_ptr 
3176				; TODO consume toks until we get to THEN 
3176			 
3176 2a 86 f6			ld hl, (os_tok_ptr) 
3179					if DEBUG_FORTH_WORDS 
3179						DMARK "IF3" 
3179 f5				push af  
317a 3a 8e 31			ld a, (.dmark)  
317d 32 b4 fe			ld (debug_mark),a  
3180 3a 8f 31			ld a, (.dmark+1)  
3183 32 b5 fe			ld (debug_mark+1),a  
3186 3a 90 31			ld a, (.dmark+2)  
3189 32 b6 fe			ld (debug_mark+2),a  
318c 18 03			jr .pastdmark  
318e ..			.dmark: db "IF3"  
3191 f1			.pastdmark: pop af  
3192			endm  
# End of macro DMARK
3192						CALLMONITOR 
3192 cd 46 18			call break_point_state  
3195				endm  
# End of macro CALLMONITOR
3195						 
3195					endif 
3195 11 dc 31			ld de, .ifthen 
3198					if DEBUG_FORTH_WORDS 
3198						DMARK "IF4" 
3198 f5				push af  
3199 3a ad 31			ld a, (.dmark)  
319c 32 b4 fe			ld (debug_mark),a  
319f 3a ae 31			ld a, (.dmark+1)  
31a2 32 b5 fe			ld (debug_mark+1),a  
31a5 3a af 31			ld a, (.dmark+2)  
31a8 32 b6 fe			ld (debug_mark+2),a  
31ab 18 03			jr .pastdmark  
31ad ..			.dmark: db "IF4"  
31b0 f1			.pastdmark: pop af  
31b1			endm  
# End of macro DMARK
31b1						CALLMONITOR 
31b1 cd 46 18			call break_point_state  
31b4				endm  
# End of macro CALLMONITOR
31b4					endif 
31b4 cd 43 23			call findnexttok  
31b7			 
31b7					if DEBUG_FORTH_WORDS 
31b7						DMARK "IF5" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 b4 fe			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 b5 fe			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 b6 fe			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "IF5"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0						CALLMONITOR 
31d0 cd 46 18			call break_point_state  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3				; TODO replace below with ; exec using tok_ptr 
31d3 22 86 f6			ld (os_tok_ptr), hl 
31d6 c3 b9 22			jp exec1 
31d9				NEXTW 
31d9 c3 28 22			jp macro_next 
31dc				endm 
# End of macro NEXTW
31dc			 
31dc .. 00		.ifthen:  db "THEN",0 
31e1			 
31e1			.iftrue:		 
31e1				; Exec next words normally 
31e1			 
31e1				; if true then exec following IF as normal 
31e1					if DEBUG_FORTH_WORDS 
31e1						DMARK "IFT" 
31e1 f5				push af  
31e2 3a f6 31			ld a, (.dmark)  
31e5 32 b4 fe			ld (debug_mark),a  
31e8 3a f7 31			ld a, (.dmark+1)  
31eb 32 b5 fe			ld (debug_mark+1),a  
31ee 3a f8 31			ld a, (.dmark+2)  
31f1 32 b6 fe			ld (debug_mark+2),a  
31f4 18 03			jr .pastdmark  
31f6 ..			.dmark: db "IFT"  
31f9 f1			.pastdmark: pop af  
31fa			endm  
# End of macro DMARK
31fa						CALLMONITOR 
31fa cd 46 18			call break_point_state  
31fd				endm  
# End of macro CALLMONITOR
31fd					endif 
31fd			 
31fd					NEXTW 
31fd c3 28 22			jp macro_next 
3200				endm 
# End of macro NEXTW
3200			.THEN: 
3200				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3200 1f				db WORD_SYS_CORE+11             
3201 28 32			dw .ELSE            
3203 05				db 4 + 1 
3204 .. 00			db "THEN",0              
3209				endm 
# End of macro CWHEAD
3209			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3209					if DEBUG_FORTH_WORDS_KEY 
3209						DMARK "THN" 
3209 f5				push af  
320a 3a 1e 32			ld a, (.dmark)  
320d 32 b4 fe			ld (debug_mark),a  
3210 3a 1f 32			ld a, (.dmark+1)  
3213 32 b5 fe			ld (debug_mark+1),a  
3216 3a 20 32			ld a, (.dmark+2)  
3219 32 b6 fe			ld (debug_mark+2),a  
321c 18 03			jr .pastdmark  
321e ..			.dmark: db "THN"  
3221 f1			.pastdmark: pop af  
3222			endm  
# End of macro DMARK
3222						CALLMONITOR 
3222 cd 46 18			call break_point_state  
3225				endm  
# End of macro CALLMONITOR
3225					endif 
3225					NEXTW 
3225 c3 28 22			jp macro_next 
3228				endm 
# End of macro NEXTW
3228			.ELSE: 
3228				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3228 20				db WORD_SYS_CORE+12             
3229 50 32			dw .DO            
322b 03				db 2 + 1 
322c .. 00			db "ELSE",0              
3231				endm 
# End of macro CWHEAD
3231			; | ELSE ( -- ) Not supported - does nothing | TODO 
3231			 
3231					if DEBUG_FORTH_WORDS_KEY 
3231						DMARK "ELS" 
3231 f5				push af  
3232 3a 46 32			ld a, (.dmark)  
3235 32 b4 fe			ld (debug_mark),a  
3238 3a 47 32			ld a, (.dmark+1)  
323b 32 b5 fe			ld (debug_mark+1),a  
323e 3a 48 32			ld a, (.dmark+2)  
3241 32 b6 fe			ld (debug_mark+2),a  
3244 18 03			jr .pastdmark  
3246 ..			.dmark: db "ELS"  
3249 f1			.pastdmark: pop af  
324a			endm  
# End of macro DMARK
324a						CALLMONITOR 
324a cd 46 18			call break_point_state  
324d				endm  
# End of macro CALLMONITOR
324d					endif 
324d			 
324d			 
324d					NEXTW 
324d c3 28 22			jp macro_next 
3250				endm 
# End of macro NEXTW
3250			.DO: 
3250				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3250 21				db WORD_SYS_CORE+13             
3251 77 33			dw .LOOP            
3253 03				db 2 + 1 
3254 .. 00			db "DO",0              
3257				endm 
# End of macro CWHEAD
3257			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3257			 
3257					if DEBUG_FORTH_WORDS_KEY 
3257						DMARK "DO." 
3257 f5				push af  
3258 3a 6c 32			ld a, (.dmark)  
325b 32 b4 fe			ld (debug_mark),a  
325e 3a 6d 32			ld a, (.dmark+1)  
3261 32 b5 fe			ld (debug_mark+1),a  
3264 3a 6e 32			ld a, (.dmark+2)  
3267 32 b6 fe			ld (debug_mark+2),a  
326a 18 03			jr .pastdmark  
326c ..			.dmark: db "DO."  
326f f1			.pastdmark: pop af  
3270			endm  
# End of macro DMARK
3270						CALLMONITOR 
3270 cd 46 18			call break_point_state  
3273				endm  
# End of macro CALLMONITOR
3273					endif 
3273			;  push pc to rsp stack past the DO 
3273			 
3273 2a 86 f6				ld hl, (os_tok_ptr) 
3276 23					inc hl   ; D 
3277 23					inc hl  ; O 
3278 23					inc hl   ; null 
3279					if DEBUG_FORTH_WORDS 
3279						DMARK "DO2" 
3279 f5				push af  
327a 3a 8e 32			ld a, (.dmark)  
327d 32 b4 fe			ld (debug_mark),a  
3280 3a 8f 32			ld a, (.dmark+1)  
3283 32 b5 fe			ld (debug_mark+1),a  
3286 3a 90 32			ld a, (.dmark+2)  
3289 32 b6 fe			ld (debug_mark+2),a  
328c 18 03			jr .pastdmark  
328e ..			.dmark: db "DO2"  
3291 f1			.pastdmark: pop af  
3292			endm  
# End of macro DMARK
3292						CALLMONITOR 
3292 cd 46 18			call break_point_state  
3295				endm  
# End of macro CALLMONITOR
3295					endif 
3295					FORTH_RSP_NEXT 
3295 cd 61 1e			call macro_forth_rsp_next 
3298				endm 
# End of macro FORTH_RSP_NEXT
3298					if DEBUG_FORTH_WORDS 
3298						DMARK "DO3" 
3298 f5				push af  
3299 3a ad 32			ld a, (.dmark)  
329c 32 b4 fe			ld (debug_mark),a  
329f 3a ae 32			ld a, (.dmark+1)  
32a2 32 b5 fe			ld (debug_mark+1),a  
32a5 3a af 32			ld a, (.dmark+2)  
32a8 32 b6 fe			ld (debug_mark+2),a  
32ab 18 03			jr .pastdmark  
32ad ..			.dmark: db "DO3"  
32b0 f1			.pastdmark: pop af  
32b1			endm  
# End of macro DMARK
32b1						CALLMONITOR 
32b1 cd 46 18			call break_point_state  
32b4				endm  
# End of macro CALLMONITOR
32b4					endif 
32b4			 
32b4					;if DEBUG_FORTH_WORDS 
32b4				;		push hl 
32b4			;		endif  
32b4			 
32b4			; get counters from data stack 
32b4			 
32b4			 
32b4					FORTH_DSP_VALUEHL 
32b4 cd b1 20			call macro_dsp_valuehl 
32b7				endm 
# End of macro FORTH_DSP_VALUEHL
32b7 e5					push hl		 ; hl now has starting counter which needs to be tos 
32b8			 
32b8					if DEBUG_FORTH_WORDS 
32b8						DMARK "DO4" 
32b8 f5				push af  
32b9 3a cd 32			ld a, (.dmark)  
32bc 32 b4 fe			ld (debug_mark),a  
32bf 3a ce 32			ld a, (.dmark+1)  
32c2 32 b5 fe			ld (debug_mark+1),a  
32c5 3a cf 32			ld a, (.dmark+2)  
32c8 32 b6 fe			ld (debug_mark+2),a  
32cb 18 03			jr .pastdmark  
32cd ..			.dmark: db "DO4"  
32d0 f1			.pastdmark: pop af  
32d1			endm  
# End of macro DMARK
32d1						CALLMONITOR 
32d1 cd 46 18			call break_point_state  
32d4				endm  
# End of macro CALLMONITOR
32d4					endif 
32d4					FORTH_DSP_POP 
32d4 cd 69 21			call macro_forth_dsp_pop 
32d7				endm 
# End of macro FORTH_DSP_POP
32d7			 
32d7					if DEBUG_FORTH_WORDS 
32d7						DMARK "DO5" 
32d7 f5				push af  
32d8 3a ec 32			ld a, (.dmark)  
32db 32 b4 fe			ld (debug_mark),a  
32de 3a ed 32			ld a, (.dmark+1)  
32e1 32 b5 fe			ld (debug_mark+1),a  
32e4 3a ee 32			ld a, (.dmark+2)  
32e7 32 b6 fe			ld (debug_mark+2),a  
32ea 18 03			jr .pastdmark  
32ec ..			.dmark: db "DO5"  
32ef f1			.pastdmark: pop af  
32f0			endm  
# End of macro DMARK
32f0						CALLMONITOR 
32f0 cd 46 18			call break_point_state  
32f3				endm  
# End of macro CALLMONITOR
32f3					endif 
32f3			 
32f3					FORTH_DSP_VALUEHL 
32f3 cd b1 20			call macro_dsp_valuehl 
32f6				endm 
# End of macro FORTH_DSP_VALUEHL
32f6			;		push hl		 ; hl now has starting limit counter 
32f6			 
32f6					if DEBUG_FORTH_WORDS 
32f6						DMARK "DO6" 
32f6 f5				push af  
32f7 3a 0b 33			ld a, (.dmark)  
32fa 32 b4 fe			ld (debug_mark),a  
32fd 3a 0c 33			ld a, (.dmark+1)  
3300 32 b5 fe			ld (debug_mark+1),a  
3303 3a 0d 33			ld a, (.dmark+2)  
3306 32 b6 fe			ld (debug_mark+2),a  
3309 18 03			jr .pastdmark  
330b ..			.dmark: db "DO6"  
330e f1			.pastdmark: pop af  
330f			endm  
# End of macro DMARK
330f						CALLMONITOR 
330f cd 46 18			call break_point_state  
3312				endm  
# End of macro CALLMONITOR
3312					endif 
3312					FORTH_DSP_POP 
3312 cd 69 21			call macro_forth_dsp_pop 
3315				endm 
# End of macro FORTH_DSP_POP
3315			 
3315			; put counters on the loop stack 
3315			 
3315			;		pop hl			 ; limit counter 
3315 d1					pop de			; start counter 
3316			 
3316					; push limit counter 
3316			 
3316					if DEBUG_FORTH_WORDS 
3316						DMARK "DO7" 
3316 f5				push af  
3317 3a 2b 33			ld a, (.dmark)  
331a 32 b4 fe			ld (debug_mark),a  
331d 3a 2c 33			ld a, (.dmark+1)  
3320 32 b5 fe			ld (debug_mark+1),a  
3323 3a 2d 33			ld a, (.dmark+2)  
3326 32 b6 fe			ld (debug_mark+2),a  
3329 18 03			jr .pastdmark  
332b ..			.dmark: db "DO7"  
332e f1			.pastdmark: pop af  
332f			endm  
# End of macro DMARK
332f						CALLMONITOR 
332f cd 46 18			call break_point_state  
3332				endm  
# End of macro CALLMONITOR
3332					endif 
3332					FORTH_LOOP_NEXT 
3332 cd e2 20			call macro_forth_loop_next 
3335				endm 
# End of macro FORTH_LOOP_NEXT
3335			 
3335					; push start counter 
3335			 
3335 eb					ex de, hl 
3336					if DEBUG_FORTH_WORDS 
3336						DMARK "DO7" 
3336 f5				push af  
3337 3a 4b 33			ld a, (.dmark)  
333a 32 b4 fe			ld (debug_mark),a  
333d 3a 4c 33			ld a, (.dmark+1)  
3340 32 b5 fe			ld (debug_mark+1),a  
3343 3a 4d 33			ld a, (.dmark+2)  
3346 32 b6 fe			ld (debug_mark+2),a  
3349 18 03			jr .pastdmark  
334b ..			.dmark: db "DO7"  
334e f1			.pastdmark: pop af  
334f			endm  
# End of macro DMARK
334f						CALLMONITOR 
334f cd 46 18			call break_point_state  
3352				endm  
# End of macro CALLMONITOR
3352					endif 
3352					FORTH_LOOP_NEXT 
3352 cd e2 20			call macro_forth_loop_next 
3355				endm 
# End of macro FORTH_LOOP_NEXT
3355			 
3355			 
3355					; init first round of I counter 
3355			 
3355 22 aa f6				ld (os_current_i), hl 
3358			 
3358					if DEBUG_FORTH_WORDS 
3358						DMARK "DO8" 
3358 f5				push af  
3359 3a 6d 33			ld a, (.dmark)  
335c 32 b4 fe			ld (debug_mark),a  
335f 3a 6e 33			ld a, (.dmark+1)  
3362 32 b5 fe			ld (debug_mark+1),a  
3365 3a 6f 33			ld a, (.dmark+2)  
3368 32 b6 fe			ld (debug_mark+2),a  
336b 18 03			jr .pastdmark  
336d ..			.dmark: db "DO8"  
3370 f1			.pastdmark: pop af  
3371			endm  
# End of macro DMARK
3371						CALLMONITOR 
3371 cd 46 18			call break_point_state  
3374				endm  
# End of macro CALLMONITOR
3374					endif 
3374			 
3374					NEXTW 
3374 c3 28 22			jp macro_next 
3377				endm 
# End of macro NEXTW
3377			.LOOP: 
3377				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3377 22				db WORD_SYS_CORE+14             
3378 8f 34			dw .I            
337a 05				db 4 + 1 
337b .. 00			db "LOOP",0              
3380				endm 
# End of macro CWHEAD
3380			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3380			 
3380				; pop tos as current loop count to hl 
3380			 
3380				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3380			 
3380				FORTH_LOOP_TOS 
3380 cd 15 21			call macro_forth_loop_tos 
3383				endm 
# End of macro FORTH_LOOP_TOS
3383 e5				push hl 
3384			 
3384					if DEBUG_FORTH_WORDS_KEY 
3384						DMARK "LOP" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 b4 fe			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 b5 fe			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 b6 fe			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "LOP"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd 46 18			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0				; next item on the stack is the limit. get it 
33a0			 
33a0			 
33a0				FORTH_LOOP_POP 
33a0 cd 1f 21			call macro_forth_loop_pop 
33a3				endm 
# End of macro FORTH_LOOP_POP
33a3			 
33a3				FORTH_LOOP_TOS 
33a3 cd 15 21			call macro_forth_loop_tos 
33a6				endm 
# End of macro FORTH_LOOP_TOS
33a6			 
33a6 d1				pop de		 ; de = i, hl = limit 
33a7			 
33a7					if DEBUG_FORTH_WORDS 
33a7						DMARK "LP1" 
33a7 f5				push af  
33a8 3a bc 33			ld a, (.dmark)  
33ab 32 b4 fe			ld (debug_mark),a  
33ae 3a bd 33			ld a, (.dmark+1)  
33b1 32 b5 fe			ld (debug_mark+1),a  
33b4 3a be 33			ld a, (.dmark+2)  
33b7 32 b6 fe			ld (debug_mark+2),a  
33ba 18 03			jr .pastdmark  
33bc ..			.dmark: db "LP1"  
33bf f1			.pastdmark: pop af  
33c0			endm  
# End of macro DMARK
33c0						CALLMONITOR 
33c0 cd 46 18			call break_point_state  
33c3				endm  
# End of macro CALLMONITOR
33c3					endif 
33c3			 
33c3				; go back to previous word 
33c3			 
33c3 d5				push de    ; save I for inc later 
33c4			 
33c4			 
33c4				; get limit 
33c4				;  is I at limit? 
33c4			 
33c4			 
33c4					if DEBUG_FORTH_WORDS 
33c4						DMARK "LP1" 
33c4 f5				push af  
33c5 3a d9 33			ld a, (.dmark)  
33c8 32 b4 fe			ld (debug_mark),a  
33cb 3a da 33			ld a, (.dmark+1)  
33ce 32 b5 fe			ld (debug_mark+1),a  
33d1 3a db 33			ld a, (.dmark+2)  
33d4 32 b6 fe			ld (debug_mark+2),a  
33d7 18 03			jr .pastdmark  
33d9 ..			.dmark: db "LP1"  
33dc f1			.pastdmark: pop af  
33dd			endm  
# End of macro DMARK
33dd						CALLMONITOR 
33dd cd 46 18			call break_point_state  
33e0				endm  
# End of macro CALLMONITOR
33e0					endif 
33e0			 
33e0 ed 52			sbc hl, de 
33e2			 
33e2			 
33e2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33e2			 
33e2 20 26				jr nz, .loopnotdone 
33e4			 
33e4 e1				pop hl   ; get rid of saved I 
33e5				FORTH_LOOP_POP     ; get rid of limit 
33e5 cd 1f 21			call macro_forth_loop_pop 
33e8				endm 
# End of macro FORTH_LOOP_POP
33e8			 
33e8				FORTH_RSP_POP     ; get rid of DO ptr 
33e8 cd 82 1e			call macro_forth_rsp_pop 
33eb				endm 
# End of macro FORTH_RSP_POP
33eb			 
33eb			if DEBUG_FORTH_WORDS 
33eb						DMARK "LP>" 
33eb f5				push af  
33ec 3a 00 34			ld a, (.dmark)  
33ef 32 b4 fe			ld (debug_mark),a  
33f2 3a 01 34			ld a, (.dmark+1)  
33f5 32 b5 fe			ld (debug_mark+1),a  
33f8 3a 02 34			ld a, (.dmark+2)  
33fb 32 b6 fe			ld (debug_mark+2),a  
33fe 18 03			jr .pastdmark  
3400 ..			.dmark: db "LP>"  
3403 f1			.pastdmark: pop af  
3404			endm  
# End of macro DMARK
3404				CALLMONITOR 
3404 cd 46 18			call break_point_state  
3407				endm  
# End of macro CALLMONITOR
3407			endif 
3407			 
3407					NEXTW 
3407 c3 28 22			jp macro_next 
340a				endm 
# End of macro NEXTW
340a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
340a			 
340a			.loopnotdone: 
340a			 
340a e1				pop hl    ; get I 
340b 23				inc hl 
340c			 
340c			   	; save new I 
340c			 
340c			 
340c					; set I counter 
340c			 
340c 22 aa f6				ld (os_current_i), hl 
340f			 
340f					if DEBUG_FORTH_WORDS 
340f						DMARK "LPN" 
340f f5				push af  
3410 3a 24 34			ld a, (.dmark)  
3413 32 b4 fe			ld (debug_mark),a  
3416 3a 25 34			ld a, (.dmark+1)  
3419 32 b5 fe			ld (debug_mark+1),a  
341c 3a 26 34			ld a, (.dmark+2)  
341f 32 b6 fe			ld (debug_mark+2),a  
3422 18 03			jr .pastdmark  
3424 ..			.dmark: db "LPN"  
3427 f1			.pastdmark: pop af  
3428			endm  
# End of macro DMARK
3428					CALLMONITOR 
3428 cd 46 18			call break_point_state  
342b				endm  
# End of macro CALLMONITOR
342b					endif 
342b					 
342b				FORTH_LOOP_NEXT 
342b cd e2 20			call macro_forth_loop_next 
342e				endm 
# End of macro FORTH_LOOP_NEXT
342e			 
342e			 
342e					if DEBUG_FORTH_WORDS 
342e eb						ex de,hl 
342f					endif 
342f			 
342f			;	; get DO ptr 
342f			; 
342f					if DEBUG_FORTH_WORDS 
342f						DMARK "LP7" 
342f f5				push af  
3430 3a 44 34			ld a, (.dmark)  
3433 32 b4 fe			ld (debug_mark),a  
3436 3a 45 34			ld a, (.dmark+1)  
3439 32 b5 fe			ld (debug_mark+1),a  
343c 3a 46 34			ld a, (.dmark+2)  
343f 32 b6 fe			ld (debug_mark+2),a  
3442 18 03			jr .pastdmark  
3444 ..			.dmark: db "LP7"  
3447 f1			.pastdmark: pop af  
3448			endm  
# End of macro DMARK
3448					CALLMONITOR 
3448 cd 46 18			call break_point_state  
344b				endm  
# End of macro CALLMONITOR
344b					endif 
344b				FORTH_RSP_TOS 
344b cd 78 1e			call macro_forth_rsp_tos 
344e				endm 
# End of macro FORTH_RSP_TOS
344e			 
344e					if DEBUG_FORTH_WORDS 
344e						DMARK "LP8" 
344e f5				push af  
344f 3a 63 34			ld a, (.dmark)  
3452 32 b4 fe			ld (debug_mark),a  
3455 3a 64 34			ld a, (.dmark+1)  
3458 32 b5 fe			ld (debug_mark+1),a  
345b 3a 65 34			ld a, (.dmark+2)  
345e 32 b6 fe			ld (debug_mark+2),a  
3461 18 03			jr .pastdmark  
3463 ..			.dmark: db "LP8"  
3466 f1			.pastdmark: pop af  
3467			endm  
# End of macro DMARK
3467					CALLMONITOR 
3467 cd 46 18			call break_point_state  
346a				endm  
# End of macro CALLMONITOR
346a					endif 
346a				;push hl 
346a			 
346a				; not going to DO any more 
346a				; get rid of the RSP pointer as DO will add it back in 
346a				;FORTH_RSP_POP 
346a				;pop hl 
346a			 
346a				;ld hl,(cli_ret_sp) 
346a				;ld e, (hl) 
346a				;inc hl 
346a				;ld d, (hl) 
346a				;ex de,hl 
346a 22 86 f6			ld (os_tok_ptr), hl 
346d					if DEBUG_FORTH_WORDS 
346d						DMARK "LP<" 
346d f5				push af  
346e 3a 82 34			ld a, (.dmark)  
3471 32 b4 fe			ld (debug_mark),a  
3474 3a 83 34			ld a, (.dmark+1)  
3477 32 b5 fe			ld (debug_mark+1),a  
347a 3a 84 34			ld a, (.dmark+2)  
347d 32 b6 fe			ld (debug_mark+2),a  
3480 18 03			jr .pastdmark  
3482 ..			.dmark: db "LP<"  
3485 f1			.pastdmark: pop af  
3486			endm  
# End of macro DMARK
3486					CALLMONITOR 
3486 cd 46 18			call break_point_state  
3489				endm  
# End of macro CALLMONITOR
3489				endif 
3489 c3 b9 22			jp exec1 
348c			 
348c					 
348c			 
348c			 
348c					NEXTW 
348c c3 28 22			jp macro_next 
348f				endm 
# End of macro NEXTW
348f			.I:  
348f			 
348f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
348f 5e				db WORD_SYS_CORE+74             
3490 ba 34			dw .DLOOP            
3492 02				db 1 + 1 
3493 .. 00			db "I",0              
3495				endm 
# End of macro CWHEAD
3495			; | I ( -- ) Current loop counter | DONE 
3495					if DEBUG_FORTH_WORDS_KEY 
3495						DMARK "I.." 
3495 f5				push af  
3496 3a aa 34			ld a, (.dmark)  
3499 32 b4 fe			ld (debug_mark),a  
349c 3a ab 34			ld a, (.dmark+1)  
349f 32 b5 fe			ld (debug_mark+1),a  
34a2 3a ac 34			ld a, (.dmark+2)  
34a5 32 b6 fe			ld (debug_mark+2),a  
34a8 18 03			jr .pastdmark  
34aa ..			.dmark: db "I.."  
34ad f1			.pastdmark: pop af  
34ae			endm  
# End of macro DMARK
34ae						CALLMONITOR 
34ae cd 46 18			call break_point_state  
34b1				endm  
# End of macro CALLMONITOR
34b1					endif 
34b1			 
34b1 2a aa f6				ld hl,(os_current_i) 
34b4 cd ba 1e				call forth_push_numhl 
34b7			 
34b7					NEXTW 
34b7 c3 28 22			jp macro_next 
34ba				endm 
# End of macro NEXTW
34ba			.DLOOP: 
34ba				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
34ba 5f				db WORD_SYS_CORE+75             
34bb 9b 35			dw .REPEAT            
34bd 06				db 5 + 1 
34be .. 00			db "-LOOP",0              
34c4				endm 
# End of macro CWHEAD
34c4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
34c4				; pop tos as current loop count to hl 
34c4					if DEBUG_FORTH_WORDS_KEY 
34c4						DMARK "-LP" 
34c4 f5				push af  
34c5 3a d9 34			ld a, (.dmark)  
34c8 32 b4 fe			ld (debug_mark),a  
34cb 3a da 34			ld a, (.dmark+1)  
34ce 32 b5 fe			ld (debug_mark+1),a  
34d1 3a db 34			ld a, (.dmark+2)  
34d4 32 b6 fe			ld (debug_mark+2),a  
34d7 18 03			jr .pastdmark  
34d9 ..			.dmark: db "-LP"  
34dc f1			.pastdmark: pop af  
34dd			endm  
# End of macro DMARK
34dd						CALLMONITOR 
34dd cd 46 18			call break_point_state  
34e0				endm  
# End of macro CALLMONITOR
34e0					endif 
34e0			 
34e0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
34e0			 
34e0				FORTH_LOOP_TOS 
34e0 cd 15 21			call macro_forth_loop_tos 
34e3				endm 
# End of macro FORTH_LOOP_TOS
34e3 e5				push hl 
34e4			 
34e4					if DEBUG_FORTH_WORDS 
34e4						DMARK "-LP" 
34e4 f5				push af  
34e5 3a f9 34			ld a, (.dmark)  
34e8 32 b4 fe			ld (debug_mark),a  
34eb 3a fa 34			ld a, (.dmark+1)  
34ee 32 b5 fe			ld (debug_mark+1),a  
34f1 3a fb 34			ld a, (.dmark+2)  
34f4 32 b6 fe			ld (debug_mark+2),a  
34f7 18 03			jr .pastdmark  
34f9 ..			.dmark: db "-LP"  
34fc f1			.pastdmark: pop af  
34fd			endm  
# End of macro DMARK
34fd						CALLMONITOR 
34fd cd 46 18			call break_point_state  
3500				endm  
# End of macro CALLMONITOR
3500					endif 
3500				; next item on the stack is the limit. get it 
3500			 
3500			 
3500				FORTH_LOOP_POP 
3500 cd 1f 21			call macro_forth_loop_pop 
3503				endm 
# End of macro FORTH_LOOP_POP
3503			 
3503				FORTH_LOOP_TOS 
3503 cd 15 21			call macro_forth_loop_tos 
3506				endm 
# End of macro FORTH_LOOP_TOS
3506			 
3506 d1				pop de		 ; de = i, hl = limit 
3507			 
3507					if DEBUG_FORTH_WORDS 
3507						DMARK "-L1" 
3507 f5				push af  
3508 3a 1c 35			ld a, (.dmark)  
350b 32 b4 fe			ld (debug_mark),a  
350e 3a 1d 35			ld a, (.dmark+1)  
3511 32 b5 fe			ld (debug_mark+1),a  
3514 3a 1e 35			ld a, (.dmark+2)  
3517 32 b6 fe			ld (debug_mark+2),a  
351a 18 03			jr .pastdmark  
351c ..			.dmark: db "-L1"  
351f f1			.pastdmark: pop af  
3520			endm  
# End of macro DMARK
3520						CALLMONITOR 
3520 cd 46 18			call break_point_state  
3523				endm  
# End of macro CALLMONITOR
3523					endif 
3523			 
3523				; go back to previous word 
3523			 
3523 d5				push de    ; save I for inc later 
3524			 
3524			 
3524				; get limit 
3524				;  is I at limit? 
3524			 
3524			 
3524					if DEBUG_FORTH_WORDS 
3524						DMARK "-L1" 
3524 f5				push af  
3525 3a 39 35			ld a, (.dmark)  
3528 32 b4 fe			ld (debug_mark),a  
352b 3a 3a 35			ld a, (.dmark+1)  
352e 32 b5 fe			ld (debug_mark+1),a  
3531 3a 3b 35			ld a, (.dmark+2)  
3534 32 b6 fe			ld (debug_mark+2),a  
3537 18 03			jr .pastdmark  
3539 ..			.dmark: db "-L1"  
353c f1			.pastdmark: pop af  
353d			endm  
# End of macro DMARK
353d						CALLMONITOR 
353d cd 46 18			call break_point_state  
3540				endm  
# End of macro CALLMONITOR
3540					endif 
3540			 
3540 ed 52			sbc hl, de 
3542			 
3542			 
3542				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3542			 
3542 20 26				jr nz, .mloopnotdone 
3544			 
3544 e1				pop hl   ; get rid of saved I 
3545				FORTH_LOOP_POP     ; get rid of limit 
3545 cd 1f 21			call macro_forth_loop_pop 
3548				endm 
# End of macro FORTH_LOOP_POP
3548			 
3548				FORTH_RSP_POP     ; get rid of DO ptr 
3548 cd 82 1e			call macro_forth_rsp_pop 
354b				endm 
# End of macro FORTH_RSP_POP
354b			 
354b			if DEBUG_FORTH_WORDS 
354b						DMARK "-L>" 
354b f5				push af  
354c 3a 60 35			ld a, (.dmark)  
354f 32 b4 fe			ld (debug_mark),a  
3552 3a 61 35			ld a, (.dmark+1)  
3555 32 b5 fe			ld (debug_mark+1),a  
3558 3a 62 35			ld a, (.dmark+2)  
355b 32 b6 fe			ld (debug_mark+2),a  
355e 18 03			jr .pastdmark  
3560 ..			.dmark: db "-L>"  
3563 f1			.pastdmark: pop af  
3564			endm  
# End of macro DMARK
3564				CALLMONITOR 
3564 cd 46 18			call break_point_state  
3567				endm  
# End of macro CALLMONITOR
3567			endif 
3567			 
3567					NEXTW 
3567 c3 28 22			jp macro_next 
356a				endm 
# End of macro NEXTW
356a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
356a			 
356a			.mloopnotdone: 
356a			 
356a e1				pop hl    ; get I 
356b 2b				dec hl 
356c			 
356c			   	; save new I 
356c			 
356c			 
356c					; set I counter 
356c			 
356c 22 aa f6				ld (os_current_i), hl 
356f			 
356f					 
356f				FORTH_LOOP_NEXT 
356f cd e2 20			call macro_forth_loop_next 
3572				endm 
# End of macro FORTH_LOOP_NEXT
3572			 
3572			 
3572					if DEBUG_FORTH_WORDS 
3572 eb						ex de,hl 
3573					endif 
3573			 
3573			;	; get DO ptr 
3573			; 
3573				FORTH_RSP_TOS 
3573 cd 78 1e			call macro_forth_rsp_tos 
3576				endm 
# End of macro FORTH_RSP_TOS
3576			 
3576				;push hl 
3576			 
3576				; not going to DO any more 
3576				; get rid of the RSP pointer as DO will add it back in 
3576				;FORTH_RSP_POP 
3576				;pop hl 
3576			 
3576			 
3576 22 86 f6			ld (os_tok_ptr), hl 
3579					if DEBUG_FORTH_WORDS 
3579						DMARK "-L<" 
3579 f5				push af  
357a 3a 8e 35			ld a, (.dmark)  
357d 32 b4 fe			ld (debug_mark),a  
3580 3a 8f 35			ld a, (.dmark+1)  
3583 32 b5 fe			ld (debug_mark+1),a  
3586 3a 90 35			ld a, (.dmark+2)  
3589 32 b6 fe			ld (debug_mark+2),a  
358c 18 03			jr .pastdmark  
358e ..			.dmark: db "-L<"  
3591 f1			.pastdmark: pop af  
3592			endm  
# End of macro DMARK
3592					CALLMONITOR 
3592 cd 46 18			call break_point_state  
3595				endm  
# End of macro CALLMONITOR
3595				endif 
3595 c3 b9 22			jp exec1 
3598			 
3598					 
3598			 
3598			 
3598			 
3598				NEXTW 
3598 c3 28 22			jp macro_next 
359b				endm 
# End of macro NEXTW
359b			 
359b			 
359b			 
359b			 
359b			.REPEAT: 
359b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
359b 71				db WORD_SYS_CORE+93             
359c ee 35			dw .UNTIL            
359e 06				db 5 + 1 
359f .. 00			db "REPEAT",0              
35a6				endm 
# End of macro CWHEAD
35a6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
35a6			;  push pc to rsp stack past the REPEAT 
35a6					if DEBUG_FORTH_WORDS_KEY 
35a6						DMARK "REP" 
35a6 f5				push af  
35a7 3a bb 35			ld a, (.dmark)  
35aa 32 b4 fe			ld (debug_mark),a  
35ad 3a bc 35			ld a, (.dmark+1)  
35b0 32 b5 fe			ld (debug_mark+1),a  
35b3 3a bd 35			ld a, (.dmark+2)  
35b6 32 b6 fe			ld (debug_mark+2),a  
35b9 18 03			jr .pastdmark  
35bb ..			.dmark: db "REP"  
35be f1			.pastdmark: pop af  
35bf			endm  
# End of macro DMARK
35bf						CALLMONITOR 
35bf cd 46 18			call break_point_state  
35c2				endm  
# End of macro CALLMONITOR
35c2					endif 
35c2			 
35c2 2a 86 f6				ld hl, (os_tok_ptr) 
35c5 23					inc hl   ; R 
35c6 23					inc hl  ; E 
35c7 23					inc hl   ; P 
35c8 23					inc hl   ; E 
35c9 23					inc hl   ; A 
35ca 23					inc hl   ; T 
35cb 23					inc hl   ; zero 
35cc					FORTH_RSP_NEXT 
35cc cd 61 1e			call macro_forth_rsp_next 
35cf				endm 
# End of macro FORTH_RSP_NEXT
35cf			 
35cf			 
35cf					if DEBUG_FORTH_WORDS 
35cf						DMARK "REP" 
35cf f5				push af  
35d0 3a e4 35			ld a, (.dmark)  
35d3 32 b4 fe			ld (debug_mark),a  
35d6 3a e5 35			ld a, (.dmark+1)  
35d9 32 b5 fe			ld (debug_mark+1),a  
35dc 3a e6 35			ld a, (.dmark+2)  
35df 32 b6 fe			ld (debug_mark+2),a  
35e2 18 03			jr .pastdmark  
35e4 ..			.dmark: db "REP"  
35e7 f1			.pastdmark: pop af  
35e8			endm  
# End of macro DMARK
35e8						;pop bc    ; TODO BUG ?????? what is this for???? 
35e8						CALLMONITOR 
35e8 cd 46 18			call break_point_state  
35eb				endm  
# End of macro CALLMONITOR
35eb					endif 
35eb			 
35eb					NEXTW 
35eb c3 28 22			jp macro_next 
35ee				endm 
# End of macro NEXTW
35ee			;	       NEXTW 
35ee			 
35ee			.UNTIL: 
35ee				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
35ee 72				db WORD_SYS_CORE+94             
35ef 85 36			dw .ENDFLOW            
35f1 06				db 5 + 1 
35f2 .. 00			db "UNTIL",0              
35f8				endm 
# End of macro CWHEAD
35f8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
35f8			 
35f8				; pop tos as check 
35f8			 
35f8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35f8			 
35f8				FORTH_DSP_VALUEHL 
35f8 cd b1 20			call macro_dsp_valuehl 
35fb				endm 
# End of macro FORTH_DSP_VALUEHL
35fb			 
35fb					if DEBUG_FORTH_WORDS_KEY 
35fb						DMARK "UNT" 
35fb f5				push af  
35fc 3a 10 36			ld a, (.dmark)  
35ff 32 b4 fe			ld (debug_mark),a  
3602 3a 11 36			ld a, (.dmark+1)  
3605 32 b5 fe			ld (debug_mark+1),a  
3608 3a 12 36			ld a, (.dmark+2)  
360b 32 b6 fe			ld (debug_mark+2),a  
360e 18 03			jr .pastdmark  
3610 ..			.dmark: db "UNT"  
3613 f1			.pastdmark: pop af  
3614			endm  
# End of macro DMARK
3614						CALLMONITOR 
3614 cd 46 18			call break_point_state  
3617				endm  
# End of macro CALLMONITOR
3617					endif 
3617			 
3617			;	push hl 
3617				FORTH_DSP_POP 
3617 cd 69 21			call macro_forth_dsp_pop 
361a				endm 
# End of macro FORTH_DSP_POP
361a			 
361a			;	pop hl 
361a			 
361a				; test if true 
361a			 
361a cd f2 0e			call ishlzero 
361d			;	ld a,l 
361d			;	add h 
361d			; 
361d			;	cp 0 
361d			 
361d 20 3e			jr nz, .untilnotdone 
361f			 
361f					if DEBUG_FORTH_WORDS 
361f						DMARK "UNf" 
361f f5				push af  
3620 3a 34 36			ld a, (.dmark)  
3623 32 b4 fe			ld (debug_mark),a  
3626 3a 35 36			ld a, (.dmark+1)  
3629 32 b5 fe			ld (debug_mark+1),a  
362c 3a 36 36			ld a, (.dmark+2)  
362f 32 b6 fe			ld (debug_mark+2),a  
3632 18 03			jr .pastdmark  
3634 ..			.dmark: db "UNf"  
3637 f1			.pastdmark: pop af  
3638			endm  
# End of macro DMARK
3638						CALLMONITOR 
3638 cd 46 18			call break_point_state  
363b				endm  
# End of macro CALLMONITOR
363b					endif 
363b			 
363b			 
363b			 
363b				FORTH_RSP_POP     ; get rid of DO ptr 
363b cd 82 1e			call macro_forth_rsp_pop 
363e				endm 
# End of macro FORTH_RSP_POP
363e			 
363e			if DEBUG_FORTH_WORDS 
363e						DMARK "UN>" 
363e f5				push af  
363f 3a 53 36			ld a, (.dmark)  
3642 32 b4 fe			ld (debug_mark),a  
3645 3a 54 36			ld a, (.dmark+1)  
3648 32 b5 fe			ld (debug_mark+1),a  
364b 3a 55 36			ld a, (.dmark+2)  
364e 32 b6 fe			ld (debug_mark+2),a  
3651 18 03			jr .pastdmark  
3653 ..			.dmark: db "UN>"  
3656 f1			.pastdmark: pop af  
3657			endm  
# End of macro DMARK
3657				CALLMONITOR 
3657 cd 46 18			call break_point_state  
365a				endm  
# End of macro CALLMONITOR
365a			endif 
365a			 
365a					NEXTW 
365a c3 28 22			jp macro_next 
365d				endm 
# End of macro NEXTW
365d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
365d			 
365d			.untilnotdone: 
365d			 
365d			 
365d			;	; get DO ptr 
365d			; 
365d				FORTH_RSP_TOS 
365d cd 78 1e			call macro_forth_rsp_tos 
3660				endm 
# End of macro FORTH_RSP_TOS
3660			 
3660				;push hl 
3660			 
3660				; not going to DO any more 
3660				; get rid of the RSP pointer as DO will add it back in 
3660				;FORTH_RSP_POP 
3660				;pop hl 
3660			 
3660			 
3660 22 86 f6			ld (os_tok_ptr), hl 
3663					if DEBUG_FORTH_WORDS 
3663						DMARK "UN<" 
3663 f5				push af  
3664 3a 78 36			ld a, (.dmark)  
3667 32 b4 fe			ld (debug_mark),a  
366a 3a 79 36			ld a, (.dmark+1)  
366d 32 b5 fe			ld (debug_mark+1),a  
3670 3a 7a 36			ld a, (.dmark+2)  
3673 32 b6 fe			ld (debug_mark+2),a  
3676 18 03			jr .pastdmark  
3678 ..			.dmark: db "UN<"  
367b f1			.pastdmark: pop af  
367c			endm  
# End of macro DMARK
367c					CALLMONITOR 
367c cd 46 18			call break_point_state  
367f				endm  
# End of macro CALLMONITOR
367f				endif 
367f c3 b9 22			jp exec1 
3682			 
3682					 
3682			 
3682			 
3682					NEXTW 
3682 c3 28 22			jp macro_next 
3685				endm 
# End of macro NEXTW
3685			 
3685			 
3685			.ENDFLOW: 
3685			 
3685			; eof 
3685			 
# End of file forth_words_flow.asm
3685			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3685			include "forth_words_logic.asm" 
3685			 
3685			; | ## Logic Words 
3685			 
3685			.NOT: 
3685				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3685 2d				db WORD_SYS_CORE+25             
3686 cd 36			dw .IS            
3688 04				db 3 + 1 
3689 .. 00			db "NOT",0              
368d				endm 
# End of macro CWHEAD
368d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
368d					if DEBUG_FORTH_WORDS_KEY 
368d						DMARK "NOT" 
368d f5				push af  
368e 3a a2 36			ld a, (.dmark)  
3691 32 b4 fe			ld (debug_mark),a  
3694 3a a3 36			ld a, (.dmark+1)  
3697 32 b5 fe			ld (debug_mark+1),a  
369a 3a a4 36			ld a, (.dmark+2)  
369d 32 b6 fe			ld (debug_mark+2),a  
36a0 18 03			jr .pastdmark  
36a2 ..			.dmark: db "NOT"  
36a5 f1			.pastdmark: pop af  
36a6			endm  
# End of macro DMARK
36a6						CALLMONITOR 
36a6 cd 46 18			call break_point_state  
36a9				endm  
# End of macro CALLMONITOR
36a9					endif 
36a9					FORTH_DSP 
36a9 cd 77 20			call macro_forth_dsp 
36ac				endm 
# End of macro FORTH_DSP
36ac 7e					ld a,(hl)	; get type of value on TOS 
36ad fe 02				cp DS_TYPE_INUM  
36af 28 03				jr z, .noti 
36b1					NEXTW 
36b1 c3 28 22			jp macro_next 
36b4				endm 
# End of macro NEXTW
36b4			.noti:          FORTH_DSP_VALUEHL 
36b4 cd b1 20			call macro_dsp_valuehl 
36b7				endm 
# End of macro FORTH_DSP_VALUEHL
36b7			;		push hl 
36b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b7 cd 69 21			call macro_forth_dsp_pop 
36ba				endm 
# End of macro FORTH_DSP_POP
36ba			;		pop hl 
36ba 3e 00				ld a,0 
36bc bd					cp l 
36bd 28 04				jr z, .not2t 
36bf 2e 00				ld l, 0 
36c1 18 02				jr .notip 
36c3			 
36c3 2e ff		.not2t:		ld l, 255 
36c5			 
36c5 26 00		.notip:		ld h, 0	 
36c7			 
36c7 cd ba 1e				call forth_push_numhl 
36ca					NEXTW 
36ca c3 28 22			jp macro_next 
36cd				endm 
# End of macro NEXTW
36cd			 
36cd			.IS: 
36cd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
36cd 2d				db WORD_SYS_CORE+25             
36ce f3 36			dw .LZERO            
36d0 03				db 2 + 1 
36d1 .. 00			db "IS",0              
36d4				endm 
# End of macro CWHEAD
36d4			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
36d4					if DEBUG_FORTH_WORDS_KEY 
36d4						DMARK "IS." 
36d4 f5				push af  
36d5 3a e9 36			ld a, (.dmark)  
36d8 32 b4 fe			ld (debug_mark),a  
36db 3a ea 36			ld a, (.dmark+1)  
36de 32 b5 fe			ld (debug_mark+1),a  
36e1 3a eb 36			ld a, (.dmark+2)  
36e4 32 b6 fe			ld (debug_mark+2),a  
36e7 18 03			jr .pastdmark  
36e9 ..			.dmark: db "IS."  
36ec f1			.pastdmark: pop af  
36ed			endm  
# End of macro DMARK
36ed						CALLMONITOR 
36ed cd 46 18			call break_point_state  
36f0				endm  
# End of macro CALLMONITOR
36f0					endif 
36f0					NEXTW 
36f0 c3 28 22			jp macro_next 
36f3				endm 
# End of macro NEXTW
36f3			.LZERO: 
36f3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
36f3 2d				db WORD_SYS_CORE+25             
36f4 fd 36			dw .TZERO            
36f6 03				db 2 + 1 
36f7 .. 00			db "0<",0              
36fa				endm 
# End of macro CWHEAD
36fa			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
36fa					NEXTW 
36fa c3 28 22			jp macro_next 
36fd				endm 
# End of macro NEXTW
36fd			.TZERO: 
36fd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
36fd 2e				db WORD_SYS_CORE+26             
36fe 44 37			dw .LESS            
3700 03				db 2 + 1 
3701 .. 00			db "0=",0              
3704				endm 
# End of macro CWHEAD
3704			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3704				; TODO add floating point number detection 
3704					;v5 FORTH_DSP_VALUE 
3704					if DEBUG_FORTH_WORDS_KEY 
3704						DMARK "0=." 
3704 f5				push af  
3705 3a 19 37			ld a, (.dmark)  
3708 32 b4 fe			ld (debug_mark),a  
370b 3a 1a 37			ld a, (.dmark+1)  
370e 32 b5 fe			ld (debug_mark+1),a  
3711 3a 1b 37			ld a, (.dmark+2)  
3714 32 b6 fe			ld (debug_mark+2),a  
3717 18 03			jr .pastdmark  
3719 ..			.dmark: db "0=."  
371c f1			.pastdmark: pop af  
371d			endm  
# End of macro DMARK
371d						CALLMONITOR 
371d cd 46 18			call break_point_state  
3720				endm  
# End of macro CALLMONITOR
3720					endif 
3720					FORTH_DSP 
3720 cd 77 20			call macro_forth_dsp 
3723				endm 
# End of macro FORTH_DSP
3723 7e					ld a,(hl)	; get type of value on TOS 
3724 fe 02				cp DS_TYPE_INUM  
3726 28 00				jr z, .tz_inum 
3728			 
3728				if FORTH_ENABLE_FLOATMATH 
3728					jr .tz_done 
3728			 
3728				endif 
3728					 
3728			 
3728			.tz_inum: 
3728					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3728 cd b1 20			call macro_dsp_valuehl 
372b				endm 
# End of macro FORTH_DSP_VALUEHL
372b			 
372b			;		push hl 
372b			 
372b					; destroy value TOS 
372b			 
372b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372b cd 69 21			call macro_forth_dsp_pop 
372e				endm 
# End of macro FORTH_DSP_POP
372e			 
372e			;		pop hl 
372e			 
372e 3e 00				ld a,0 
3730			 
3730 bd					cp l 
3731 20 08				jr nz, .tz_notzero 
3733			 
3733 bc					cp h 
3734			 
3734 20 05				jr nz, .tz_notzero 
3736			 
3736			 
3736 21 01 00				ld hl, FORTH_TRUE 
3739 18 03				jr .tz_done 
373b			 
373b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
373e			 
373e					; push value back onto stack for another op etc 
373e			 
373e			.tz_done: 
373e cd ba 1e				call forth_push_numhl 
3741			 
3741					NEXTW 
3741 c3 28 22			jp macro_next 
3744				endm 
# End of macro NEXTW
3744			.LESS: 
3744				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3744 2f				db WORD_SYS_CORE+27             
3745 ad 37			dw .GT            
3747 02				db 1 + 1 
3748 .. 00			db "<",0              
374a				endm 
# End of macro CWHEAD
374a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
374a				; TODO add floating point number detection 
374a					if DEBUG_FORTH_WORDS_KEY 
374a						DMARK "LES" 
374a f5				push af  
374b 3a 5f 37			ld a, (.dmark)  
374e 32 b4 fe			ld (debug_mark),a  
3751 3a 60 37			ld a, (.dmark+1)  
3754 32 b5 fe			ld (debug_mark+1),a  
3757 3a 61 37			ld a, (.dmark+2)  
375a 32 b6 fe			ld (debug_mark+2),a  
375d 18 03			jr .pastdmark  
375f ..			.dmark: db "LES"  
3762 f1			.pastdmark: pop af  
3763			endm  
# End of macro DMARK
3763						CALLMONITOR 
3763 cd 46 18			call break_point_state  
3766				endm  
# End of macro CALLMONITOR
3766					endif 
3766					FORTH_DSP 
3766 cd 77 20			call macro_forth_dsp 
3769				endm 
# End of macro FORTH_DSP
3769					;v5 FORTH_DSP_VALUE 
3769 7e					ld a,(hl)	; get type of value on TOS 
376a fe 02				cp DS_TYPE_INUM  
376c 28 00				jr z, .less_inum 
376e			 
376e				if FORTH_ENABLE_FLOATMATH 
376e					jr .less_done 
376e			 
376e				endif 
376e					 
376e			 
376e			.less_inum: 
376e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376e cd b1 20			call macro_dsp_valuehl 
3771				endm 
# End of macro FORTH_DSP_VALUEHL
3771			 
3771 e5					push hl  ; u2 
3772			 
3772					; destroy value TOS 
3772			 
3772					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3772 cd 69 21			call macro_forth_dsp_pop 
3775				endm 
# End of macro FORTH_DSP_POP
3775			 
3775			 
3775					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3775 cd b1 20			call macro_dsp_valuehl 
3778				endm 
# End of macro FORTH_DSP_VALUEHL
3778			 
3778 e5					push hl    ; u1 
3779			 
3779					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3779 cd 69 21			call macro_forth_dsp_pop 
377c				endm 
# End of macro FORTH_DSP_POP
377c			 
377c			 
377c b7			 or a      ;clear carry flag 
377d 01 00 00		 ld bc, FORTH_FALSE 
3780 e1			  pop hl    ; u1 
3781 d1			  pop de    ; u2 
3782 ed 52		  sbc hl,de 
3784 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3786			 
3786 01 01 00		 ld bc, FORTH_TRUE 
3789			.lscont:  
3789 c5					push bc 
378a e1					pop hl 
378b			 
378b					if DEBUG_FORTH_WORDS 
378b						DMARK "LT1" 
378b f5				push af  
378c 3a a0 37			ld a, (.dmark)  
378f 32 b4 fe			ld (debug_mark),a  
3792 3a a1 37			ld a, (.dmark+1)  
3795 32 b5 fe			ld (debug_mark+1),a  
3798 3a a2 37			ld a, (.dmark+2)  
379b 32 b6 fe			ld (debug_mark+2),a  
379e 18 03			jr .pastdmark  
37a0 ..			.dmark: db "LT1"  
37a3 f1			.pastdmark: pop af  
37a4			endm  
# End of macro DMARK
37a4						CALLMONITOR 
37a4 cd 46 18			call break_point_state  
37a7				endm  
# End of macro CALLMONITOR
37a7					endif 
37a7 cd ba 1e				call forth_push_numhl 
37aa			 
37aa					NEXTW 
37aa c3 28 22			jp macro_next 
37ad				endm 
# End of macro NEXTW
37ad			.GT: 
37ad				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
37ad 30				db WORD_SYS_CORE+28             
37ae 16 38			dw .EQUAL            
37b0 02				db 1 + 1 
37b1 .. 00			db ">",0              
37b3				endm 
# End of macro CWHEAD
37b3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
37b3				; TODO add floating point number detection 
37b3					if DEBUG_FORTH_WORDS_KEY 
37b3						DMARK "GRT" 
37b3 f5				push af  
37b4 3a c8 37			ld a, (.dmark)  
37b7 32 b4 fe			ld (debug_mark),a  
37ba 3a c9 37			ld a, (.dmark+1)  
37bd 32 b5 fe			ld (debug_mark+1),a  
37c0 3a ca 37			ld a, (.dmark+2)  
37c3 32 b6 fe			ld (debug_mark+2),a  
37c6 18 03			jr .pastdmark  
37c8 ..			.dmark: db "GRT"  
37cb f1			.pastdmark: pop af  
37cc			endm  
# End of macro DMARK
37cc						CALLMONITOR 
37cc cd 46 18			call break_point_state  
37cf				endm  
# End of macro CALLMONITOR
37cf					endif 
37cf					FORTH_DSP 
37cf cd 77 20			call macro_forth_dsp 
37d2				endm 
# End of macro FORTH_DSP
37d2					;FORTH_DSP_VALUE 
37d2 7e					ld a,(hl)	; get type of value on TOS 
37d3 fe 02				cp DS_TYPE_INUM  
37d5 28 00				jr z, .gt_inum 
37d7			 
37d7				if FORTH_ENABLE_FLOATMATH 
37d7					jr .gt_done 
37d7			 
37d7				endif 
37d7					 
37d7			 
37d7			.gt_inum: 
37d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d7 cd b1 20			call macro_dsp_valuehl 
37da				endm 
# End of macro FORTH_DSP_VALUEHL
37da			 
37da e5					push hl  ; u2 
37db			 
37db					; destroy value TOS 
37db			 
37db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37db cd 69 21			call macro_forth_dsp_pop 
37de				endm 
# End of macro FORTH_DSP_POP
37de			 
37de			 
37de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37de cd b1 20			call macro_dsp_valuehl 
37e1				endm 
# End of macro FORTH_DSP_VALUEHL
37e1			 
37e1 e5					push hl    ; u1 
37e2			 
37e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e2 cd 69 21			call macro_forth_dsp_pop 
37e5				endm 
# End of macro FORTH_DSP_POP
37e5			 
37e5			 
37e5 b7			 or a      ;clear carry flag 
37e6 01 00 00		 ld bc, FORTH_FALSE 
37e9 e1			  pop hl    ; u1 
37ea d1			  pop de    ; u2 
37eb ed 52		  sbc hl,de 
37ed 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
37ef			 
37ef 01 01 00		 ld bc, FORTH_TRUE 
37f2			.gtcont:  
37f2 c5					push bc 
37f3 e1					pop hl 
37f4			 
37f4					if DEBUG_FORTH_WORDS 
37f4						DMARK "GT1" 
37f4 f5				push af  
37f5 3a 09 38			ld a, (.dmark)  
37f8 32 b4 fe			ld (debug_mark),a  
37fb 3a 0a 38			ld a, (.dmark+1)  
37fe 32 b5 fe			ld (debug_mark+1),a  
3801 3a 0b 38			ld a, (.dmark+2)  
3804 32 b6 fe			ld (debug_mark+2),a  
3807 18 03			jr .pastdmark  
3809 ..			.dmark: db "GT1"  
380c f1			.pastdmark: pop af  
380d			endm  
# End of macro DMARK
380d						CALLMONITOR 
380d cd 46 18			call break_point_state  
3810				endm  
# End of macro CALLMONITOR
3810					endif 
3810 cd ba 1e				call forth_push_numhl 
3813			 
3813					NEXTW 
3813 c3 28 22			jp macro_next 
3816				endm 
# End of macro NEXTW
3816			.EQUAL: 
3816				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3816 31				db WORD_SYS_CORE+29             
3817 81 38			dw .ENDLOGIC            
3819 02				db 1 + 1 
381a .. 00			db "=",0              
381c				endm 
# End of macro CWHEAD
381c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
381c				; TODO add floating point number detection 
381c					if DEBUG_FORTH_WORDS_KEY 
381c						DMARK "EQ." 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 b4 fe			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 b5 fe			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 b6 fe			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "EQ."  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd 46 18			call break_point_state  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838					FORTH_DSP 
3838 cd 77 20			call macro_forth_dsp 
383b				endm 
# End of macro FORTH_DSP
383b					;v5 FORTH_DSP_VALUE 
383b 7e					ld a,(hl)	; get type of value on TOS 
383c fe 02				cp DS_TYPE_INUM  
383e 28 00				jr z, .eq_inum 
3840			 
3840				if FORTH_ENABLE_FLOATMATH 
3840					jr .eq_done 
3840			 
3840				endif 
3840					 
3840			 
3840			.eq_inum: 
3840					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3840 cd b1 20			call macro_dsp_valuehl 
3843				endm 
# End of macro FORTH_DSP_VALUEHL
3843			 
3843 e5					push hl 
3844			 
3844					; destroy value TOS 
3844			 
3844					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3844 cd 69 21			call macro_forth_dsp_pop 
3847				endm 
# End of macro FORTH_DSP_POP
3847			 
3847			 
3847					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3847 cd b1 20			call macro_dsp_valuehl 
384a				endm 
# End of macro FORTH_DSP_VALUEHL
384a			 
384a					; one value on hl get other one back 
384a			 
384a e5					push hl 
384b			 
384b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
384b cd 69 21			call macro_forth_dsp_pop 
384e				endm 
# End of macro FORTH_DSP_POP
384e			 
384e 0e 00				ld c, FORTH_FALSE 
3850			 
3850 e1					pop hl 
3851 d1					pop de 
3852			 
3852 7b					ld a, e 
3853 bd					cp l 
3854			 
3854 20 06				jr nz, .eq_done 
3856			 
3856 7a					ld a, d 
3857 bc					cp h 
3858			 
3858 20 02				jr nz, .eq_done 
385a			 
385a 0e 01				ld c, FORTH_TRUE 
385c					 
385c			 
385c			 
385c			.eq_done: 
385c			 
385c					; TODO push value back onto stack for another op etc 
385c			 
385c 26 00				ld h, 0 
385e 69					ld l, c 
385f					if DEBUG_FORTH_WORDS 
385f						DMARK "EQ1" 
385f f5				push af  
3860 3a 74 38			ld a, (.dmark)  
3863 32 b4 fe			ld (debug_mark),a  
3866 3a 75 38			ld a, (.dmark+1)  
3869 32 b5 fe			ld (debug_mark+1),a  
386c 3a 76 38			ld a, (.dmark+2)  
386f 32 b6 fe			ld (debug_mark+2),a  
3872 18 03			jr .pastdmark  
3874 ..			.dmark: db "EQ1"  
3877 f1			.pastdmark: pop af  
3878			endm  
# End of macro DMARK
3878						CALLMONITOR 
3878 cd 46 18			call break_point_state  
387b				endm  
# End of macro CALLMONITOR
387b					endif 
387b cd ba 1e				call forth_push_numhl 
387e			 
387e					NEXTW 
387e c3 28 22			jp macro_next 
3881				endm 
# End of macro NEXTW
3881			 
3881			 
3881			.ENDLOGIC: 
3881			; eof 
3881			 
3881			 
# End of file forth_words_logic.asm
3881			include "forth_words_maths.asm" 
3881			 
3881			; | ## Maths Words 
3881			 
3881			.PLUS:	 
3881				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3881 15				db WORD_SYS_CORE+1             
3882 c3 38			dw .NEG            
3884 02				db 1 + 1 
3885 .. 00			db "+",0              
3887				endm 
# End of macro CWHEAD
3887			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3887					if DEBUG_FORTH_WORDS_KEY 
3887						DMARK "PLU" 
3887 f5				push af  
3888 3a 9c 38			ld a, (.dmark)  
388b 32 b4 fe			ld (debug_mark),a  
388e 3a 9d 38			ld a, (.dmark+1)  
3891 32 b5 fe			ld (debug_mark+1),a  
3894 3a 9e 38			ld a, (.dmark+2)  
3897 32 b6 fe			ld (debug_mark+2),a  
389a 18 03			jr .pastdmark  
389c ..			.dmark: db "PLU"  
389f f1			.pastdmark: pop af  
38a0			endm  
# End of macro DMARK
38a0						CALLMONITOR 
38a0 cd 46 18			call break_point_state  
38a3				endm  
# End of macro CALLMONITOR
38a3					endif 
38a3					; add top two values and push back result 
38a3			 
38a3					;for v5 FORTH_DSP_VALUE 
38a3					FORTH_DSP 
38a3 cd 77 20			call macro_forth_dsp 
38a6				endm 
# End of macro FORTH_DSP
38a6 7e					ld a,(hl)	; get type of value on TOS 
38a7 fe 02				cp DS_TYPE_INUM  
38a9 28 03				jr z, .dot_inum 
38ab			 
38ab					NEXTW 
38ab c3 28 22			jp macro_next 
38ae				endm 
# End of macro NEXTW
38ae			 
38ae			; float maths 
38ae			 
38ae				if FORTH_ENABLE_FLOATMATH 
38ae						inc hl      ; now at start of numeric as string 
38ae			 
38ae					if DEBUG_FORTH_MATHS 
38ae						DMARK "ADD" 
38ae				CALLMONITOR 
38ae					endif 
38ae			 
38ae					;ld ix, hl 
38ae					call CON 
38ae			 
38ae			 
38ae					push hl 
38ae					 
38ae					 
38ae			 
38ae						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
38ae			 
38ae					; get next number 
38ae			 
38ae						FORTH_DSP_VALUE 
38ae			 
38ae						inc hl      ; now at start of numeric as string 
38ae			 
38ae					;ld ix, hl 
38ae					call CON 
38ae			 
38ae					push hl 
38ae			 
38ae			 
38ae						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ae			 
38ae						; TODO do add 
38ae			 
38ae						call IADD 
38ae			 
38ae						; TODO get result back as ascii 
38ae			 
38ae						; TODO push result  
38ae			 
38ae			 
38ae			 
38ae						jr .dot_done 
38ae				endif 
38ae			 
38ae			.dot_inum: 
38ae			 
38ae			 
38ae					if DEBUG_FORTH_DOT 
38ae						DMARK "+IT" 
38ae				CALLMONITOR 
38ae					endif 
38ae			 
38ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ae cd b1 20			call macro_dsp_valuehl 
38b1				endm 
# End of macro FORTH_DSP_VALUEHL
38b1			 
38b1				; TODO add floating point number detection 
38b1			 
38b1 e5					push hl 
38b2			 
38b2					; destroy value TOS 
38b2			 
38b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b2 cd 69 21			call macro_forth_dsp_pop 
38b5				endm 
# End of macro FORTH_DSP_POP
38b5			 
38b5			 
38b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b5 cd b1 20			call macro_dsp_valuehl 
38b8				endm 
# End of macro FORTH_DSP_VALUEHL
38b8			 
38b8					; one value on hl get other one back 
38b8			 
38b8 d1					pop de 
38b9			 
38b9					; do the add 
38b9			 
38b9 19					add hl,de 
38ba			 
38ba					; save it 
38ba			 
38ba			;		push hl	 
38ba			 
38ba					; 
38ba			 
38ba					; destroy value TOS 
38ba			 
38ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ba cd 69 21			call macro_forth_dsp_pop 
38bd				endm 
# End of macro FORTH_DSP_POP
38bd			 
38bd					; TODO push value back onto stack for another op etc 
38bd			 
38bd			;		pop hl 
38bd			 
38bd			.dot_done: 
38bd cd ba 1e				call forth_push_numhl 
38c0			 
38c0					NEXTW 
38c0 c3 28 22			jp macro_next 
38c3				endm 
# End of macro NEXTW
38c3			.NEG: 
38c3			 
38c3				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
38c3 17				db WORD_SYS_CORE+3             
38c4 06 39			dw .DIV            
38c6 02				db 1 + 1 
38c7 .. 00			db "-",0              
38c9				endm 
# End of macro CWHEAD
38c9			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
38c9					if DEBUG_FORTH_WORDS_KEY 
38c9						DMARK "SUB" 
38c9 f5				push af  
38ca 3a de 38			ld a, (.dmark)  
38cd 32 b4 fe			ld (debug_mark),a  
38d0 3a df 38			ld a, (.dmark+1)  
38d3 32 b5 fe			ld (debug_mark+1),a  
38d6 3a e0 38			ld a, (.dmark+2)  
38d9 32 b6 fe			ld (debug_mark+2),a  
38dc 18 03			jr .pastdmark  
38de ..			.dmark: db "SUB"  
38e1 f1			.pastdmark: pop af  
38e2			endm  
# End of macro DMARK
38e2						CALLMONITOR 
38e2 cd 46 18			call break_point_state  
38e5				endm  
# End of macro CALLMONITOR
38e5					endif 
38e5			 
38e5			 
38e5				; TODO add floating point number detection 
38e5					; v5 FORTH_DSP_VALUE 
38e5					FORTH_DSP 
38e5 cd 77 20			call macro_forth_dsp 
38e8				endm 
# End of macro FORTH_DSP
38e8 7e					ld a,(hl)	; get type of value on TOS 
38e9 fe 02				cp DS_TYPE_INUM  
38eb 28 03				jr z, .neg_inum 
38ed			 
38ed					NEXTW 
38ed c3 28 22			jp macro_next 
38f0				endm 
# End of macro NEXTW
38f0			 
38f0			; float maths 
38f0			 
38f0				if FORTH_ENABLE_FLOATMATH 
38f0					jr .neg_done 
38f0			 
38f0				endif 
38f0					 
38f0			 
38f0			.neg_inum: 
38f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38f0 cd b1 20			call macro_dsp_valuehl 
38f3				endm 
# End of macro FORTH_DSP_VALUEHL
38f3			 
38f3 e5					push hl 
38f4			 
38f4					; destroy value TOS 
38f4			 
38f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f4 cd 69 21			call macro_forth_dsp_pop 
38f7				endm 
# End of macro FORTH_DSP_POP
38f7			 
38f7			 
38f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38f7 cd b1 20			call macro_dsp_valuehl 
38fa				endm 
# End of macro FORTH_DSP_VALUEHL
38fa			 
38fa					; one value on hl get other one back 
38fa			 
38fa d1					pop de 
38fb			 
38fb					; do the sub 
38fb			;		ex de, hl 
38fb			 
38fb ed 52				sbc hl,de 
38fd			 
38fd					; save it 
38fd			 
38fd			;		push hl	 
38fd			 
38fd					; 
38fd			 
38fd					; destroy value TOS 
38fd			 
38fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38fd cd 69 21			call macro_forth_dsp_pop 
3900				endm 
# End of macro FORTH_DSP_POP
3900			 
3900					; TODO push value back onto stack for another op etc 
3900			 
3900			;		pop hl 
3900			 
3900 cd ba 1e				call forth_push_numhl 
3903			.neg_done: 
3903			 
3903					NEXTW 
3903 c3 28 22			jp macro_next 
3906				endm 
# End of macro NEXTW
3906			.DIV: 
3906				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3906 18				db WORD_SYS_CORE+4             
3907 53 39			dw .MUL            
3909 02				db 1 + 1 
390a .. 00			db "/",0              
390c				endm 
# End of macro CWHEAD
390c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
390c					if DEBUG_FORTH_WORDS_KEY 
390c						DMARK "DIV" 
390c f5				push af  
390d 3a 21 39			ld a, (.dmark)  
3910 32 b4 fe			ld (debug_mark),a  
3913 3a 22 39			ld a, (.dmark+1)  
3916 32 b5 fe			ld (debug_mark+1),a  
3919 3a 23 39			ld a, (.dmark+2)  
391c 32 b6 fe			ld (debug_mark+2),a  
391f 18 03			jr .pastdmark  
3921 ..			.dmark: db "DIV"  
3924 f1			.pastdmark: pop af  
3925			endm  
# End of macro DMARK
3925						CALLMONITOR 
3925 cd 46 18			call break_point_state  
3928				endm  
# End of macro CALLMONITOR
3928					endif 
3928				; TODO add floating point number detection 
3928					; v5 FORTH_DSP_VALUE 
3928					FORTH_DSP 
3928 cd 77 20			call macro_forth_dsp 
392b				endm 
# End of macro FORTH_DSP
392b 7e					ld a,(hl)	; get type of value on TOS 
392c fe 02				cp DS_TYPE_INUM  
392e 28 03				jr z, .div_inum 
3930			 
3930				if FORTH_ENABLE_FLOATMATH 
3930					jr .div_done 
3930			 
3930				endif 
3930					NEXTW 
3930 c3 28 22			jp macro_next 
3933				endm 
# End of macro NEXTW
3933			.div_inum: 
3933			 
3933					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3933 cd b1 20			call macro_dsp_valuehl 
3936				endm 
# End of macro FORTH_DSP_VALUEHL
3936			 
3936 e5					push hl    ; to go to bc 
3937			 
3937					; destroy value TOS 
3937			 
3937					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3937 cd 69 21			call macro_forth_dsp_pop 
393a				endm 
# End of macro FORTH_DSP_POP
393a			 
393a			 
393a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
393a cd b1 20			call macro_dsp_valuehl 
393d				endm 
# End of macro FORTH_DSP_VALUEHL
393d			 
393d					; hl to go to de 
393d			 
393d e5					push hl 
393e			 
393e c1					pop bc 
393f d1					pop de		 
3940			 
3940			 
3940					if DEBUG_FORTH_MATHS 
3940						DMARK "DIV" 
3940				CALLMONITOR 
3940					endif 
3940					; one value on hl but move to a get other one back 
3940			 
3940			        
3940 cd 26 0e			call Div16 
3943			 
3943			;	push af	 
3943 e5				push hl 
3944 c5				push bc 
3945			 
3945					if DEBUG_FORTH_MATHS 
3945						DMARK "DI1" 
3945				CALLMONITOR 
3945					endif 
3945			 
3945					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3945 cd 69 21			call macro_forth_dsp_pop 
3948				endm 
# End of macro FORTH_DSP_POP
3948			 
3948			 
3948			 
3948 e1					pop hl    ; result 
3949			 
3949 cd ba 1e				call forth_push_numhl 
394c			 
394c e1					pop hl    ; reminder 
394d			;		ld h,0 
394d			;		ld l,d 
394d			 
394d cd ba 1e				call forth_push_numhl 
3950			.div_done: 
3950					NEXTW 
3950 c3 28 22			jp macro_next 
3953				endm 
# End of macro NEXTW
3953			.MUL: 
3953				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3953 19				db WORD_SYS_CORE+5             
3954 98 39			dw .MIN            
3956 02				db 1 + 1 
3957 .. 00			db "*",0              
3959				endm 
# End of macro CWHEAD
3959			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3959				; TODO add floating point number detection 
3959					if DEBUG_FORTH_WORDS_KEY 
3959						DMARK "MUL" 
3959 f5				push af  
395a 3a 6e 39			ld a, (.dmark)  
395d 32 b4 fe			ld (debug_mark),a  
3960 3a 6f 39			ld a, (.dmark+1)  
3963 32 b5 fe			ld (debug_mark+1),a  
3966 3a 70 39			ld a, (.dmark+2)  
3969 32 b6 fe			ld (debug_mark+2),a  
396c 18 03			jr .pastdmark  
396e ..			.dmark: db "MUL"  
3971 f1			.pastdmark: pop af  
3972			endm  
# End of macro DMARK
3972						CALLMONITOR 
3972 cd 46 18			call break_point_state  
3975				endm  
# End of macro CALLMONITOR
3975					endif 
3975					FORTH_DSP 
3975 cd 77 20			call macro_forth_dsp 
3978				endm 
# End of macro FORTH_DSP
3978					; v5 FORTH_DSP_VALUE 
3978 7e					ld a,(hl)	; get type of value on TOS 
3979 fe 02				cp DS_TYPE_INUM  
397b 28 03				jr z, .mul_inum 
397d			 
397d				if FORTH_ENABLE_FLOATMATH 
397d					jr .mul_done 
397d			 
397d				endif 
397d			 
397d					NEXTW 
397d c3 28 22			jp macro_next 
3980				endm 
# End of macro NEXTW
3980			.mul_inum:	 
3980			 
3980					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3980 cd b1 20			call macro_dsp_valuehl 
3983				endm 
# End of macro FORTH_DSP_VALUEHL
3983			 
3983 e5					push hl 
3984			 
3984					; destroy value TOS 
3984			 
3984					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3984 cd 69 21			call macro_forth_dsp_pop 
3987				endm 
# End of macro FORTH_DSP_POP
3987			 
3987			 
3987					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3987 cd b1 20			call macro_dsp_valuehl 
398a				endm 
# End of macro FORTH_DSP_VALUEHL
398a			 
398a					; one value on hl but move to a get other one back 
398a			 
398a 7d					ld a, l 
398b			 
398b d1					pop de 
398c			 
398c					; do the mull 
398c			;		ex de, hl 
398c			 
398c cd 4c 0e				call Mult16 
398f					; save it 
398f			 
398f			;		push hl	 
398f			 
398f					; 
398f			 
398f					; destroy value TOS 
398f			 
398f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398f cd 69 21			call macro_forth_dsp_pop 
3992				endm 
# End of macro FORTH_DSP_POP
3992			 
3992					; TODO push value back onto stack for another op etc 
3992			 
3992			;		pop hl 
3992			 
3992 cd ba 1e				call forth_push_numhl 
3995			 
3995			.mul_done: 
3995					NEXTW 
3995 c3 28 22			jp macro_next 
3998				endm 
# End of macro NEXTW
3998			 
3998			 
3998			 
3998			 
3998			.MIN: 
3998				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3998 49				db WORD_SYS_CORE+53             
3999 19 3a			dw .MAX            
399b 04				db 3 + 1 
399c .. 00			db "MIN",0              
39a0				endm 
# End of macro CWHEAD
39a0			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
39a0					if DEBUG_FORTH_WORDS_KEY 
39a0						DMARK "MIN" 
39a0 f5				push af  
39a1 3a b5 39			ld a, (.dmark)  
39a4 32 b4 fe			ld (debug_mark),a  
39a7 3a b6 39			ld a, (.dmark+1)  
39aa 32 b5 fe			ld (debug_mark+1),a  
39ad 3a b7 39			ld a, (.dmark+2)  
39b0 32 b6 fe			ld (debug_mark+2),a  
39b3 18 03			jr .pastdmark  
39b5 ..			.dmark: db "MIN"  
39b8 f1			.pastdmark: pop af  
39b9			endm  
# End of macro DMARK
39b9						CALLMONITOR 
39b9 cd 46 18			call break_point_state  
39bc				endm  
# End of macro CALLMONITOR
39bc					endif 
39bc					; get u2 
39bc			 
39bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bc cd b1 20			call macro_dsp_valuehl 
39bf				endm 
# End of macro FORTH_DSP_VALUEHL
39bf			 
39bf e5					push hl   ; u2 
39c0			 
39c0					; destroy value TOS 
39c0			 
39c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c0 cd 69 21			call macro_forth_dsp_pop 
39c3				endm 
# End of macro FORTH_DSP_POP
39c3			 
39c3					; get u1 
39c3			 
39c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c3 cd b1 20			call macro_dsp_valuehl 
39c6				endm 
# End of macro FORTH_DSP_VALUEHL
39c6			 
39c6 e5					push hl  ; u1 
39c7			 
39c7					; destroy value TOS 
39c7			 
39c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c7 cd 69 21			call macro_forth_dsp_pop 
39ca				endm 
# End of macro FORTH_DSP_POP
39ca			 
39ca b7			 or a      ;clear carry flag 
39cb e1			  pop hl    ; u1 
39cc d1			  pop de    ; u2 
39cd e5				push hl   ; saved in case hl is lowest 
39ce ed 52		  sbc hl,de 
39d0 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
39d2			 
39d2 e1				pop hl 
39d3					if DEBUG_FORTH_WORDS 
39d3						DMARK "MIN" 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 b4 fe			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 b5 fe			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 b6 fe			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "MIN"  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd 46 18			call break_point_state  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef cd ba 1e				call forth_push_numhl 
39f2			 
39f2				       NEXTW 
39f2 c3 28 22			jp macro_next 
39f5				endm 
# End of macro NEXTW
39f5			 
39f5			.mincont:  
39f5 c1				pop bc   ; tidy up 
39f6 eb				ex de , hl  
39f7					if DEBUG_FORTH_WORDS 
39f7						DMARK "MI1" 
39f7 f5				push af  
39f8 3a 0c 3a			ld a, (.dmark)  
39fb 32 b4 fe			ld (debug_mark),a  
39fe 3a 0d 3a			ld a, (.dmark+1)  
3a01 32 b5 fe			ld (debug_mark+1),a  
3a04 3a 0e 3a			ld a, (.dmark+2)  
3a07 32 b6 fe			ld (debug_mark+2),a  
3a0a 18 03			jr .pastdmark  
3a0c ..			.dmark: db "MI1"  
3a0f f1			.pastdmark: pop af  
3a10			endm  
# End of macro DMARK
3a10						CALLMONITOR 
3a10 cd 46 18			call break_point_state  
3a13				endm  
# End of macro CALLMONITOR
3a13					endif 
3a13 cd ba 1e				call forth_push_numhl 
3a16			 
3a16				       NEXTW 
3a16 c3 28 22			jp macro_next 
3a19				endm 
# End of macro NEXTW
3a19			.MAX: 
3a19				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a19 4a				db WORD_SYS_CORE+54             
3a1a 9a 3a			dw .RND16            
3a1c 04				db 3 + 1 
3a1d .. 00			db "MAX",0              
3a21				endm 
# End of macro CWHEAD
3a21			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a21					if DEBUG_FORTH_WORDS_KEY 
3a21						DMARK "MAX" 
3a21 f5				push af  
3a22 3a 36 3a			ld a, (.dmark)  
3a25 32 b4 fe			ld (debug_mark),a  
3a28 3a 37 3a			ld a, (.dmark+1)  
3a2b 32 b5 fe			ld (debug_mark+1),a  
3a2e 3a 38 3a			ld a, (.dmark+2)  
3a31 32 b6 fe			ld (debug_mark+2),a  
3a34 18 03			jr .pastdmark  
3a36 ..			.dmark: db "MAX"  
3a39 f1			.pastdmark: pop af  
3a3a			endm  
# End of macro DMARK
3a3a						CALLMONITOR 
3a3a cd 46 18			call break_point_state  
3a3d				endm  
# End of macro CALLMONITOR
3a3d					endif 
3a3d					; get u2 
3a3d			 
3a3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3d cd b1 20			call macro_dsp_valuehl 
3a40				endm 
# End of macro FORTH_DSP_VALUEHL
3a40			 
3a40 e5					push hl   ; u2 
3a41			 
3a41					; destroy value TOS 
3a41			 
3a41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a41 cd 69 21			call macro_forth_dsp_pop 
3a44				endm 
# End of macro FORTH_DSP_POP
3a44			 
3a44					; get u1 
3a44			 
3a44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a44 cd b1 20			call macro_dsp_valuehl 
3a47				endm 
# End of macro FORTH_DSP_VALUEHL
3a47			 
3a47 e5					push hl  ; u1 
3a48			 
3a48					; destroy value TOS 
3a48			 
3a48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a48 cd 69 21			call macro_forth_dsp_pop 
3a4b				endm 
# End of macro FORTH_DSP_POP
3a4b			 
3a4b b7			 or a      ;clear carry flag 
3a4c e1			  pop hl    ; u1 
3a4d d1			  pop de    ; u2 
3a4e e5				push hl   ; saved in case hl is lowest 
3a4f ed 52		  sbc hl,de 
3a51 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3a53			 
3a53 e1				pop hl 
3a54					if DEBUG_FORTH_WORDS 
3a54						DMARK "MAX" 
3a54 f5				push af  
3a55 3a 69 3a			ld a, (.dmark)  
3a58 32 b4 fe			ld (debug_mark),a  
3a5b 3a 6a 3a			ld a, (.dmark+1)  
3a5e 32 b5 fe			ld (debug_mark+1),a  
3a61 3a 6b 3a			ld a, (.dmark+2)  
3a64 32 b6 fe			ld (debug_mark+2),a  
3a67 18 03			jr .pastdmark  
3a69 ..			.dmark: db "MAX"  
3a6c f1			.pastdmark: pop af  
3a6d			endm  
# End of macro DMARK
3a6d						CALLMONITOR 
3a6d cd 46 18			call break_point_state  
3a70				endm  
# End of macro CALLMONITOR
3a70					endif 
3a70 cd ba 1e				call forth_push_numhl 
3a73			 
3a73				       NEXTW 
3a73 c3 28 22			jp macro_next 
3a76				endm 
# End of macro NEXTW
3a76			 
3a76			.maxcont:  
3a76 c1				pop bc   ; tidy up 
3a77 eb				ex de , hl  
3a78					if DEBUG_FORTH_WORDS 
3a78						DMARK "MA1" 
3a78 f5				push af  
3a79 3a 8d 3a			ld a, (.dmark)  
3a7c 32 b4 fe			ld (debug_mark),a  
3a7f 3a 8e 3a			ld a, (.dmark+1)  
3a82 32 b5 fe			ld (debug_mark+1),a  
3a85 3a 8f 3a			ld a, (.dmark+2)  
3a88 32 b6 fe			ld (debug_mark+2),a  
3a8b 18 03			jr .pastdmark  
3a8d ..			.dmark: db "MA1"  
3a90 f1			.pastdmark: pop af  
3a91			endm  
# End of macro DMARK
3a91						CALLMONITOR 
3a91 cd 46 18			call break_point_state  
3a94				endm  
# End of macro CALLMONITOR
3a94					endif 
3a94 cd ba 1e				call forth_push_numhl 
3a97				       NEXTW 
3a97 c3 28 22			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a			 
3a9a			.RND16: 
3a9a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3a9a 4e				db WORD_SYS_CORE+58             
3a9b c9 3a			dw .RND8            
3a9d 06				db 5 + 1 
3a9e .. 00			db "RND16",0              
3aa4				endm 
# End of macro CWHEAD
3aa4			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3aa4					if DEBUG_FORTH_WORDS_KEY 
3aa4						DMARK "R16" 
3aa4 f5				push af  
3aa5 3a b9 3a			ld a, (.dmark)  
3aa8 32 b4 fe			ld (debug_mark),a  
3aab 3a ba 3a			ld a, (.dmark+1)  
3aae 32 b5 fe			ld (debug_mark+1),a  
3ab1 3a bb 3a			ld a, (.dmark+2)  
3ab4 32 b6 fe			ld (debug_mark+2),a  
3ab7 18 03			jr .pastdmark  
3ab9 ..			.dmark: db "R16"  
3abc f1			.pastdmark: pop af  
3abd			endm  
# End of macro DMARK
3abd						CALLMONITOR 
3abd cd 46 18			call break_point_state  
3ac0				endm  
# End of macro CALLMONITOR
3ac0					endif 
3ac0 cd f0 0d				call prng16  
3ac3 cd ba 1e				call forth_push_numhl 
3ac6				       NEXTW 
3ac6 c3 28 22			jp macro_next 
3ac9				endm 
# End of macro NEXTW
3ac9			.RND8: 
3ac9				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3ac9 60				db WORD_SYS_CORE+76             
3aca fe 3a			dw .RND            
3acc 05				db 4 + 1 
3acd .. 00			db "RND8",0              
3ad2				endm 
# End of macro CWHEAD
3ad2			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3ad2					if DEBUG_FORTH_WORDS_KEY 
3ad2						DMARK "RN8" 
3ad2 f5				push af  
3ad3 3a e7 3a			ld a, (.dmark)  
3ad6 32 b4 fe			ld (debug_mark),a  
3ad9 3a e8 3a			ld a, (.dmark+1)  
3adc 32 b5 fe			ld (debug_mark+1),a  
3adf 3a e9 3a			ld a, (.dmark+2)  
3ae2 32 b6 fe			ld (debug_mark+2),a  
3ae5 18 03			jr .pastdmark  
3ae7 ..			.dmark: db "RN8"  
3aea f1			.pastdmark: pop af  
3aeb			endm  
# End of macro DMARK
3aeb						CALLMONITOR 
3aeb cd 46 18			call break_point_state  
3aee				endm  
# End of macro CALLMONITOR
3aee					endif 
3aee 2a 35 fd				ld hl,(xrandc) 
3af1 23					inc hl 
3af2 cd 0a 0e				call xrnd 
3af5 6f					ld l,a	 
3af6 26 00				ld h,0 
3af8 cd ba 1e				call forth_push_numhl 
3afb				       NEXTW 
3afb c3 28 22			jp macro_next 
3afe				endm 
# End of macro NEXTW
3afe			.RND: 
3afe				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3afe 60				db WORD_SYS_CORE+76             
3aff 04 3c			dw .ENDMATHS            
3b01 04				db 3 + 1 
3b02 .. 00			db "RND",0              
3b06				endm 
# End of macro CWHEAD
3b06			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b06			 
3b06					if DEBUG_FORTH_WORDS_KEY 
3b06						DMARK "RND" 
3b06 f5				push af  
3b07 3a 1b 3b			ld a, (.dmark)  
3b0a 32 b4 fe			ld (debug_mark),a  
3b0d 3a 1c 3b			ld a, (.dmark+1)  
3b10 32 b5 fe			ld (debug_mark+1),a  
3b13 3a 1d 3b			ld a, (.dmark+2)  
3b16 32 b6 fe			ld (debug_mark+2),a  
3b19 18 03			jr .pastdmark  
3b1b ..			.dmark: db "RND"  
3b1e f1			.pastdmark: pop af  
3b1f			endm  
# End of macro DMARK
3b1f						CALLMONITOR 
3b1f cd 46 18			call break_point_state  
3b22				endm  
# End of macro CALLMONITOR
3b22					endif 
3b22					 
3b22					FORTH_DSP_VALUEHL    ; upper range 
3b22 cd b1 20			call macro_dsp_valuehl 
3b25				endm 
# End of macro FORTH_DSP_VALUEHL
3b25			 
3b25 22 39 fd				ld (LFSRSeed), hl	 
3b28			 
3b28					if DEBUG_FORTH_WORDS 
3b28						DMARK "RN1" 
3b28 f5				push af  
3b29 3a 3d 3b			ld a, (.dmark)  
3b2c 32 b4 fe			ld (debug_mark),a  
3b2f 3a 3e 3b			ld a, (.dmark+1)  
3b32 32 b5 fe			ld (debug_mark+1),a  
3b35 3a 3f 3b			ld a, (.dmark+2)  
3b38 32 b6 fe			ld (debug_mark+2),a  
3b3b 18 03			jr .pastdmark  
3b3d ..			.dmark: db "RN1"  
3b40 f1			.pastdmark: pop af  
3b41			endm  
# End of macro DMARK
3b41						CALLMONITOR 
3b41 cd 46 18			call break_point_state  
3b44				endm  
# End of macro CALLMONITOR
3b44					endif 
3b44					FORTH_DSP_POP 
3b44 cd 69 21			call macro_forth_dsp_pop 
3b47				endm 
# End of macro FORTH_DSP_POP
3b47			 
3b47					FORTH_DSP_VALUEHL    ; low range 
3b47 cd b1 20			call macro_dsp_valuehl 
3b4a				endm 
# End of macro FORTH_DSP_VALUEHL
3b4a			 
3b4a					if DEBUG_FORTH_WORDS 
3b4a						DMARK "RN2" 
3b4a f5				push af  
3b4b 3a 5f 3b			ld a, (.dmark)  
3b4e 32 b4 fe			ld (debug_mark),a  
3b51 3a 60 3b			ld a, (.dmark+1)  
3b54 32 b5 fe			ld (debug_mark+1),a  
3b57 3a 61 3b			ld a, (.dmark+2)  
3b5a 32 b6 fe			ld (debug_mark+2),a  
3b5d 18 03			jr .pastdmark  
3b5f ..			.dmark: db "RN2"  
3b62 f1			.pastdmark: pop af  
3b63			endm  
# End of macro DMARK
3b63						CALLMONITOR 
3b63 cd 46 18			call break_point_state  
3b66				endm  
# End of macro CALLMONITOR
3b66					endif 
3b66 22 3b fd				ld (LFSRSeed+2), hl 
3b69			 
3b69					FORTH_DSP_POP 
3b69 cd 69 21			call macro_forth_dsp_pop 
3b6c				endm 
# End of macro FORTH_DSP_POP
3b6c			 
3b6c e5					push hl 
3b6d			 
3b6d e1			.inrange:	pop hl 
3b6e cd f0 0d				call prng16  
3b71					if DEBUG_FORTH_WORDS 
3b71						DMARK "RN3" 
3b71 f5				push af  
3b72 3a 86 3b			ld a, (.dmark)  
3b75 32 b4 fe			ld (debug_mark),a  
3b78 3a 87 3b			ld a, (.dmark+1)  
3b7b 32 b5 fe			ld (debug_mark+1),a  
3b7e 3a 88 3b			ld a, (.dmark+2)  
3b81 32 b6 fe			ld (debug_mark+2),a  
3b84 18 03			jr .pastdmark  
3b86 ..			.dmark: db "RN3"  
3b89 f1			.pastdmark: pop af  
3b8a			endm  
# End of macro DMARK
3b8a						CALLMONITOR 
3b8a cd 46 18			call break_point_state  
3b8d				endm  
# End of macro CALLMONITOR
3b8d					endif 
3b8d					 
3b8d					; if the range is 8bit knock out the high byte 
3b8d			 
3b8d ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3b91			 
3b91 3e 00				ld a, 0 
3b93 ba					cp d  
3b94 20 1e				jr nz, .hirange 
3b96 26 00				ld h, 0   ; knock it down to 8bit 
3b98			 
3b98					if DEBUG_FORTH_WORDS 
3b98						DMARK "RNk" 
3b98 f5				push af  
3b99 3a ad 3b			ld a, (.dmark)  
3b9c 32 b4 fe			ld (debug_mark),a  
3b9f 3a ae 3b			ld a, (.dmark+1)  
3ba2 32 b5 fe			ld (debug_mark+1),a  
3ba5 3a af 3b			ld a, (.dmark+2)  
3ba8 32 b6 fe			ld (debug_mark+2),a  
3bab 18 03			jr .pastdmark  
3bad ..			.dmark: db "RNk"  
3bb0 f1			.pastdmark: pop af  
3bb1			endm  
# End of macro DMARK
3bb1						CALLMONITOR 
3bb1 cd 46 18			call break_point_state  
3bb4				endm  
# End of macro CALLMONITOR
3bb4					endif 
3bb4			.hirange:   
3bb4 e5					push hl  
3bb5 b7					or a  
3bb6 ed 52		                sbc hl, de 
3bb8			 
3bb8					;call cmp16 
3bb8			 
3bb8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3bba e1					pop hl 
3bbb e5					push hl 
3bbc			 
3bbc					if DEBUG_FORTH_WORDS 
3bbc						DMARK "RN4" 
3bbc f5				push af  
3bbd 3a d1 3b			ld a, (.dmark)  
3bc0 32 b4 fe			ld (debug_mark),a  
3bc3 3a d2 3b			ld a, (.dmark+1)  
3bc6 32 b5 fe			ld (debug_mark+1),a  
3bc9 3a d3 3b			ld a, (.dmark+2)  
3bcc 32 b6 fe			ld (debug_mark+2),a  
3bcf 18 03			jr .pastdmark  
3bd1 ..			.dmark: db "RN4"  
3bd4 f1			.pastdmark: pop af  
3bd5			endm  
# End of macro DMARK
3bd5						CALLMONITOR 
3bd5 cd 46 18			call break_point_state  
3bd8				endm  
# End of macro CALLMONITOR
3bd8					endif 
3bd8 ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3bdc					;call cmp16 
3bdc				 
3bdc b7					or a  
3bdd ed 52		                sbc hl, de 
3bdf 38 8c				jr c, .inrange 
3be1			 
3be1 e1					pop hl 
3be2					 
3be2					if DEBUG_FORTH_WORDS 
3be2						DMARK "RNd" 
3be2 f5				push af  
3be3 3a f7 3b			ld a, (.dmark)  
3be6 32 b4 fe			ld (debug_mark),a  
3be9 3a f8 3b			ld a, (.dmark+1)  
3bec 32 b5 fe			ld (debug_mark+1),a  
3bef 3a f9 3b			ld a, (.dmark+2)  
3bf2 32 b6 fe			ld (debug_mark+2),a  
3bf5 18 03			jr .pastdmark  
3bf7 ..			.dmark: db "RNd"  
3bfa f1			.pastdmark: pop af  
3bfb			endm  
# End of macro DMARK
3bfb						CALLMONITOR 
3bfb cd 46 18			call break_point_state  
3bfe				endm  
# End of macro CALLMONITOR
3bfe					endif 
3bfe			 
3bfe			 
3bfe cd ba 1e				call forth_push_numhl 
3c01				       NEXTW 
3c01 c3 28 22			jp macro_next 
3c04				endm 
# End of macro NEXTW
3c04			 
3c04			.ENDMATHS: 
3c04			 
3c04			; eof 
3c04			 
# End of file forth_words_maths.asm
3c04			include "forth_words_display.asm" 
3c04			 
3c04			; | ## Display Words 
3c04			 
3c04			.INFO: 
3c04			 
3c04				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c04 62				db WORD_SYS_CORE+78             
3c05 21 3c			dw .ATP            
3c07 05				db 4 + 1 
3c08 .. 00			db "INFO",0              
3c0d				endm 
# End of macro CWHEAD
3c0d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c0d					FORTH_DSP_VALUEHL 
3c0d cd b1 20			call macro_dsp_valuehl 
3c10				endm 
# End of macro FORTH_DSP_VALUEHL
3c10			 
3c10					FORTH_DSP_POP 
3c10 cd 69 21			call macro_forth_dsp_pop 
3c13				endm 
# End of macro FORTH_DSP_POP
3c13			 
3c13 e5					push hl 
3c14			 
3c14					FORTH_DSP_VALUEHL 
3c14 cd b1 20			call macro_dsp_valuehl 
3c17				endm 
# End of macro FORTH_DSP_VALUEHL
3c17			 
3c17					FORTH_DSP_POP 
3c17 cd 69 21			call macro_forth_dsp_pop 
3c1a				endm 
# End of macro FORTH_DSP_POP
3c1a			 
3c1a d1					pop de 
3c1b			 
3c1b cd 26 0c				call info_panel 
3c1e			 
3c1e			 
3c1e					NEXTW 
3c1e c3 28 22			jp macro_next 
3c21				endm 
# End of macro NEXTW
3c21			.ATP: 
3c21				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c21 62				db WORD_SYS_CORE+78             
3c22 98 3c			dw .FB            
3c24 04				db 3 + 1 
3c25 .. 00			db "AT?",0              
3c29				endm 
# End of macro CWHEAD
3c29			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c29					if DEBUG_FORTH_WORDS_KEY 
3c29						DMARK "AT?" 
3c29 f5				push af  
3c2a 3a 3e 3c			ld a, (.dmark)  
3c2d 32 b4 fe			ld (debug_mark),a  
3c30 3a 3f 3c			ld a, (.dmark+1)  
3c33 32 b5 fe			ld (debug_mark+1),a  
3c36 3a 40 3c			ld a, (.dmark+2)  
3c39 32 b6 fe			ld (debug_mark+2),a  
3c3c 18 03			jr .pastdmark  
3c3e ..			.dmark: db "AT?"  
3c41 f1			.pastdmark: pop af  
3c42			endm  
# End of macro DMARK
3c42						CALLMONITOR 
3c42 cd 46 18			call break_point_state  
3c45				endm  
# End of macro CALLMONITOR
3c45					endif 
3c45 3a ee fb				ld a, (f_cursor_ptr) 
3c48			 
3c48			if DEBUG_FORTH_WORDS 
3c48				DMARK "AT?" 
3c48 f5				push af  
3c49 3a 5d 3c			ld a, (.dmark)  
3c4c 32 b4 fe			ld (debug_mark),a  
3c4f 3a 5e 3c			ld a, (.dmark+1)  
3c52 32 b5 fe			ld (debug_mark+1),a  
3c55 3a 5f 3c			ld a, (.dmark+2)  
3c58 32 b6 fe			ld (debug_mark+2),a  
3c5b 18 03			jr .pastdmark  
3c5d ..			.dmark: db "AT?"  
3c60 f1			.pastdmark: pop af  
3c61			endm  
# End of macro DMARK
3c61				CALLMONITOR 
3c61 cd 46 18			call break_point_state  
3c64				endm  
# End of macro CALLMONITOR
3c64			endif	 
3c64					; count the number of rows 
3c64			 
3c64 06 00				ld b, 0 
3c66 4f			.atpr:		ld c, a    ; save in case we go below zero 
3c67 d6 14				sub display_cols 
3c69 f2 6f 3c				jp p, .atprunder 
3c6c 04					inc b 
3c6d 18 f7				jr .atpr 
3c6f			.atprunder:	 
3c6f			if DEBUG_FORTH_WORDS 
3c6f				DMARK "A?2" 
3c6f f5				push af  
3c70 3a 84 3c			ld a, (.dmark)  
3c73 32 b4 fe			ld (debug_mark),a  
3c76 3a 85 3c			ld a, (.dmark+1)  
3c79 32 b5 fe			ld (debug_mark+1),a  
3c7c 3a 86 3c			ld a, (.dmark+2)  
3c7f 32 b6 fe			ld (debug_mark+2),a  
3c82 18 03			jr .pastdmark  
3c84 ..			.dmark: db "A?2"  
3c87 f1			.pastdmark: pop af  
3c88			endm  
# End of macro DMARK
3c88				CALLMONITOR 
3c88 cd 46 18			call break_point_state  
3c8b				endm  
# End of macro CALLMONITOR
3c8b			endif	 
3c8b 26 00				ld h, 0 
3c8d 69					ld l, c 
3c8e cd ba 1e				call forth_push_numhl 
3c91 68					ld l, b  
3c92 cd ba 1e				call forth_push_numhl 
3c95			 
3c95			 
3c95				NEXTW 
3c95 c3 28 22			jp macro_next 
3c98				endm 
# End of macro NEXTW
3c98			 
3c98			.FB: 
3c98				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3c98 1b				db WORD_SYS_CORE+7             
3c99 e6 3c			dw .EMIT            
3c9b 03				db 2 + 1 
3c9c .. 00			db "FB",0              
3c9f				endm 
# End of macro CWHEAD
3c9f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3c9f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3c9f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3c9f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3c9f					if DEBUG_FORTH_WORDS_KEY 
3c9f						DMARK "FB." 
3c9f f5				push af  
3ca0 3a b4 3c			ld a, (.dmark)  
3ca3 32 b4 fe			ld (debug_mark),a  
3ca6 3a b5 3c			ld a, (.dmark+1)  
3ca9 32 b5 fe			ld (debug_mark+1),a  
3cac 3a b6 3c			ld a, (.dmark+2)  
3caf 32 b6 fe			ld (debug_mark+2),a  
3cb2 18 03			jr .pastdmark  
3cb4 ..			.dmark: db "FB."  
3cb7 f1			.pastdmark: pop af  
3cb8			endm  
# End of macro DMARK
3cb8						CALLMONITOR 
3cb8 cd 46 18			call break_point_state  
3cbb				endm  
# End of macro CALLMONITOR
3cbb					endif 
3cbb			 
3cbb					FORTH_DSP_VALUEHL 
3cbb cd b1 20			call macro_dsp_valuehl 
3cbe				endm 
# End of macro FORTH_DSP_VALUEHL
3cbe			 
3cbe 7d					ld a, l 
3cbf fe 01				cp 1 
3cc1 20 05				jr nz, .fbn1 
3cc3 21 f9 fd				ld hl, display_fb1 
3cc6 18 15				jr .fbset 
3cc8 fe 02		.fbn1:		cp 2 
3cca 20 05				jr nz, .fbn2 
3ccc 21 57 fd				ld hl, display_fb2 
3ccf 18 0c				jr .fbset 
3cd1 fe 03		.fbn2:		cp 3 
3cd3 20 05				jr nz, .fbn3 
3cd5 21 a8 fd				ld hl, display_fb3 
3cd8 18 03				jr .fbset 
3cda			.fbn3:		 ; if invalid number select first 
3cda 21 f9 fd				ld hl, display_fb1 
3cdd 22 55 fd		.fbset:		ld (display_fb_active), hl 
3ce0			 
3ce0					FORTH_DSP_POP 
3ce0 cd 69 21			call macro_forth_dsp_pop 
3ce3				endm 
# End of macro FORTH_DSP_POP
3ce3			 
3ce3					NEXTW 
3ce3 c3 28 22			jp macro_next 
3ce6				endm 
# End of macro NEXTW
3ce6			 
3ce6			 
3ce6			.EMIT: 
3ce6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ce6 1b				db WORD_SYS_CORE+7             
3ce7 37 3d			dw .DOTH            
3ce9 05				db 4 + 1 
3cea .. 00			db "EMIT",0              
3cef				endm 
# End of macro CWHEAD
3cef			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3cef					; get value off TOS and display it 
3cef			 
3cef					if DEBUG_FORTH_WORDS_KEY 
3cef						DMARK "EMT" 
3cef f5				push af  
3cf0 3a 04 3d			ld a, (.dmark)  
3cf3 32 b4 fe			ld (debug_mark),a  
3cf6 3a 05 3d			ld a, (.dmark+1)  
3cf9 32 b5 fe			ld (debug_mark+1),a  
3cfc 3a 06 3d			ld a, (.dmark+2)  
3cff 32 b6 fe			ld (debug_mark+2),a  
3d02 18 03			jr .pastdmark  
3d04 ..			.dmark: db "EMT"  
3d07 f1			.pastdmark: pop af  
3d08			endm  
# End of macro DMARK
3d08						CALLMONITOR 
3d08 cd 46 18			call break_point_state  
3d0b				endm  
# End of macro CALLMONITOR
3d0b					endif 
3d0b			 
3d0b					FORTH_DSP_VALUEHL 
3d0b cd b1 20			call macro_dsp_valuehl 
3d0e				endm 
# End of macro FORTH_DSP_VALUEHL
3d0e			 
3d0e 7d					ld a,l 
3d0f			 
3d0f					; TODO write to display 
3d0f			 
3d0f 32 83 f5				ld (os_input), a 
3d12 3e 00				ld a, 0 
3d14 32 84 f5				ld (os_input+1), a 
3d17					 
3d17 3a ee fb				ld a, (f_cursor_ptr) 
3d1a 11 83 f5				ld de, os_input 
3d1d cd a8 0c				call str_at_display 
3d20			 
3d20			 
3d20 3a cc fb				ld a,(cli_autodisplay) 
3d23 fe 00				cp 0 
3d25 28 03				jr z, .enoupdate 
3d27 cd b8 0c						call update_display 
3d2a					.enoupdate: 
3d2a			 
3d2a 3a ee fb				ld a, (f_cursor_ptr) 
3d2d 3c					inc a 
3d2e 32 ee fb				ld (f_cursor_ptr), a   ; save new pos 
3d31			 
3d31			 
3d31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d31 cd 69 21			call macro_forth_dsp_pop 
3d34				endm 
# End of macro FORTH_DSP_POP
3d34			  
3d34			 
3d34					NEXTW 
3d34 c3 28 22			jp macro_next 
3d37				endm 
# End of macro NEXTW
3d37			.DOTH: 
3d37				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d37 1c				db WORD_SYS_CORE+8             
3d38 67 3d			dw .DOTF            
3d3a 03				db 2 + 1 
3d3b .. 00			db ".-",0              
3d3e				endm 
# End of macro CWHEAD
3d3e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3d3e					; get value off TOS and display it 
3d3e					if DEBUG_FORTH_WORDS_KEY 
3d3e						DMARK "DTD" 
3d3e f5				push af  
3d3f 3a 53 3d			ld a, (.dmark)  
3d42 32 b4 fe			ld (debug_mark),a  
3d45 3a 54 3d			ld a, (.dmark+1)  
3d48 32 b5 fe			ld (debug_mark+1),a  
3d4b 3a 55 3d			ld a, (.dmark+2)  
3d4e 32 b6 fe			ld (debug_mark+2),a  
3d51 18 03			jr .pastdmark  
3d53 ..			.dmark: db "DTD"  
3d56 f1			.pastdmark: pop af  
3d57			endm  
# End of macro DMARK
3d57						CALLMONITOR 
3d57 cd 46 18			call break_point_state  
3d5a				endm  
# End of macro CALLMONITOR
3d5a					endif 
3d5a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3d5c 3e 00			ld a, 0 
3d5e 32 cd fb			ld (cli_mvdot), a 
3d61 c3 be 3d			jp .dotgo 
3d64				NEXTW 
3d64 c3 28 22			jp macro_next 
3d67				endm 
# End of macro NEXTW
3d67			.DOTF: 
3d67				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3d67 1c				db WORD_SYS_CORE+8             
3d68 95 3d			dw .DOT            
3d6a 03				db 2 + 1 
3d6b .. 00			db ".>",0              
3d6e				endm 
# End of macro CWHEAD
3d6e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3d6e					; get value off TOS and display it 
3d6e			        ; TODO BUG adds extra spaces 
3d6e			        ; TODO BUG handle numerics? 
3d6e					if DEBUG_FORTH_WORDS_KEY 
3d6e						DMARK "DTC" 
3d6e f5				push af  
3d6f 3a 83 3d			ld a, (.dmark)  
3d72 32 b4 fe			ld (debug_mark),a  
3d75 3a 84 3d			ld a, (.dmark+1)  
3d78 32 b5 fe			ld (debug_mark+1),a  
3d7b 3a 85 3d			ld a, (.dmark+2)  
3d7e 32 b6 fe			ld (debug_mark+2),a  
3d81 18 03			jr .pastdmark  
3d83 ..			.dmark: db "DTC"  
3d86 f1			.pastdmark: pop af  
3d87			endm  
# End of macro DMARK
3d87						CALLMONITOR 
3d87 cd 46 18			call break_point_state  
3d8a				endm  
# End of macro CALLMONITOR
3d8a					endif 
3d8a 3e 01			ld a, 1 
3d8c 32 cd fb			ld (cli_mvdot), a 
3d8f c3 be 3d			jp .dotgo 
3d92				NEXTW 
3d92 c3 28 22			jp macro_next 
3d95				endm 
# End of macro NEXTW
3d95			 
3d95			.DOT: 
3d95				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3d95 1c				db WORD_SYS_CORE+8             
3d96 21 3e			dw .CLS            
3d98 02				db 1 + 1 
3d99 .. 00			db ".",0              
3d9b				endm 
# End of macro CWHEAD
3d9b			        ; | . ( u -- ) Display TOS | DONE 
3d9b					; get value off TOS and display it 
3d9b			 
3d9b					if DEBUG_FORTH_WORDS_KEY 
3d9b						DMARK "DOT" 
3d9b f5				push af  
3d9c 3a b0 3d			ld a, (.dmark)  
3d9f 32 b4 fe			ld (debug_mark),a  
3da2 3a b1 3d			ld a, (.dmark+1)  
3da5 32 b5 fe			ld (debug_mark+1),a  
3da8 3a b2 3d			ld a, (.dmark+2)  
3dab 32 b6 fe			ld (debug_mark+2),a  
3dae 18 03			jr .pastdmark  
3db0 ..			.dmark: db "DOT"  
3db3 f1			.pastdmark: pop af  
3db4			endm  
# End of macro DMARK
3db4						CALLMONITOR 
3db4 cd 46 18			call break_point_state  
3db7				endm  
# End of macro CALLMONITOR
3db7					endif 
3db7 3e 00			ld a, 0 
3db9 32 cd fb			ld (cli_mvdot), a 
3dbc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3dbe				 
3dbe			 
3dbe			.dotgo: 
3dbe			 
3dbe			; move up type to on stack for parserv5 
3dbe					FORTH_DSP 
3dbe cd 77 20			call macro_forth_dsp 
3dc1				endm 
# End of macro FORTH_DSP
3dc1				;FORTH_DSP_VALUE  
3dc1			 
3dc1			if DEBUG_FORTH_DOT 
3dc1				DMARK "DOT" 
3dc1				CALLMONITOR 
3dc1			endif	 
3dc1			;		.print: 
3dc1			 
3dc1 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3dc2 23				inc hl   ; position to the actual value 
3dc3 fe 01			cp DS_TYPE_STR 
3dc5 20 06			jr nz, .dotnum1  
3dc7			 
3dc7			; display string 
3dc7				FORTH_DSP_VALUE  
3dc7 cd 9a 20			call macro_forth_dsp_value 
3dca				endm 
# End of macro FORTH_DSP_VALUE
3dca eb				ex de,hl 
3dcb 18 11			jr .dotwrite 
3dcd			 
3dcd			.dotnum1: 
3dcd fe 02			cp DS_TYPE_INUM 
3dcf 20 0c			jr nz, .dotflot 
3dd1			 
3dd1			 
3dd1			; display number 
3dd1			 
3dd1			;	push hl 
3dd1			;	call clear_display 
3dd1			;	pop hl 
3dd1			 
3dd1 5e				ld e, (hl) 
3dd2 23				inc hl 
3dd3 56				ld d, (hl) 
3dd4 21 85 f3			ld hl, scratch 
3dd7			if DEBUG_FORTH_DOT 
3dd7				DMARK "DT1" 
3dd7				CALLMONITOR 
3dd7			endif	 
3dd7			 
3dd7 cd d6 12			call uitoa_16 
3dda eb				ex de,hl 
3ddb			 
3ddb			if DEBUG_FORTH_DOT 
3ddb				DMARK "DT2" 
3ddb				CALLMONITOR 
3ddb			endif	 
3ddb			 
3ddb			;	ld de, os_word_scratch 
3ddb 18 01			jr .dotwrite 
3ddd			 
3ddd 00			.dotflot:   nop 
3dde			; TODO print floating point number 
3dde			 
3dde			.dotwrite:		 
3dde			 
3dde					; if c is set then set all '-' to spaces 
3dde					; need to also take into account .>  
3dde			 
3dde 3e 01				ld a, 1 
3de0 b9					cp c 
3de1 20 13				jr nz, .nodashswap 
3de3			 
3de3					; DE has the string to write, working with HL 
3de3			 
3de3 06 ff				ld b, 255 
3de5 d5					push de 
3de6 e1					pop hl 
3de7			 
3de7			if DEBUG_FORTH_DOT 
3de7				DMARK "DT-" 
3de7				CALLMONITOR 
3de7			endif	 
3de7 7e			.dashscan:	ld a, (hl) 
3de8 fe 00				cp 0 
3dea 28 0a				jr z, .nodashswap 
3dec fe 2d				cp '-' 
3dee 20 03				jr nz, .dashskip 
3df0 3e 20				ld a, ' ' 
3df2 77					ld (hl), a 
3df3 23			.dashskip:	inc hl 
3df4			if DEBUG_FORTH_DOT 
3df4				DMARK "D-2" 
3df4				CALLMONITOR 
3df4			endif	 
3df4 10 f1				djnz .dashscan 
3df6			 
3df6			if DEBUG_FORTH_DOT 
3df6				DMARK "D-1" 
3df6				CALLMONITOR 
3df6			endif	 
3df6			 
3df6			.nodashswap: 
3df6			 
3df6 e5					push hl   ; save string start in case we need to advance print 
3df7			 
3df7 3a ee fb				ld a, (f_cursor_ptr) 
3dfa cd a8 0c				call str_at_display 
3dfd 3a cc fb				ld a,(cli_autodisplay) 
3e00 fe 00				cp 0 
3e02 28 03				jr z, .noupdate 
3e04 cd b8 0c						call update_display 
3e07					.noupdate: 
3e07			 
3e07			 
3e07					; see if we need to advance the print position 
3e07			 
3e07 e1					pop hl   ; get back string 
3e08			 
3e08 3a cd fb				ld a, (cli_mvdot) 
3e0b			if DEBUG_FORTH_DOT 
3e0b					ld e,a 
3e0b				DMARK "D>1" 
3e0b				CALLMONITOR 
3e0b			endif	 
3e0b fe 00				cp 0 
3e0d 28 0c				jr z, .noadv 
3e0f					; yes, lets advance the print position 
3e0f 3e 00				ld a, 0 
3e11 cd 32 13				call strlent 
3e14 3a ee fb				ld a, (f_cursor_ptr) 
3e17 85					add a,l 
3e18					;call addatohl 
3e18					;ld a, l 
3e18 32 ee fb				ld (f_cursor_ptr), a   ; save new pos 
3e1b			 
3e1b			if DEBUG_FORTH_DOT 
3e1b				DMARK "D->" 
3e1b				CALLMONITOR 
3e1b			endif	 
3e1b			 
3e1b			.noadv:	 
3e1b			 
3e1b					if DEBUG_FORTH_DOT_WAIT 
3e1b							call next_page_prompt 
3e1b					endif	 
3e1b			; TODO this pop off the stack causes a crash. i dont know why 
3e1b			 
3e1b			 
3e1b			if DEBUG_FORTH_DOT 
3e1b				DMARK "DTh" 
3e1b				CALLMONITOR 
3e1b			endif	 
3e1b			 
3e1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e1b cd 69 21			call macro_forth_dsp_pop 
3e1e				endm 
# End of macro FORTH_DSP_POP
3e1e			 
3e1e			if DEBUG_FORTH_DOT 
3e1e				DMARK "DTi" 
3e1e				CALLMONITOR 
3e1e			endif	 
3e1e			 
3e1e			 
3e1e					NEXTW 
3e1e c3 28 22			jp macro_next 
3e21				endm 
# End of macro NEXTW
3e21			 
3e21			.CLS: 
3e21				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e21 35				db WORD_SYS_CORE+33             
3e22 4e 3e			dw .DRAW            
3e24 04				db 3 + 1 
3e25 .. 00			db "CLS",0              
3e29				endm 
# End of macro CWHEAD
3e29			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e29					if DEBUG_FORTH_WORDS_KEY 
3e29						DMARK "CLS" 
3e29 f5				push af  
3e2a 3a 3e 3e			ld a, (.dmark)  
3e2d 32 b4 fe			ld (debug_mark),a  
3e30 3a 3f 3e			ld a, (.dmark+1)  
3e33 32 b5 fe			ld (debug_mark+1),a  
3e36 3a 40 3e			ld a, (.dmark+2)  
3e39 32 b6 fe			ld (debug_mark+2),a  
3e3c 18 03			jr .pastdmark  
3e3e ..			.dmark: db "CLS"  
3e41 f1			.pastdmark: pop af  
3e42			endm  
# End of macro DMARK
3e42						CALLMONITOR 
3e42 cd 46 18			call break_point_state  
3e45				endm  
# End of macro CALLMONITOR
3e45					endif 
3e45 cd 95 0c				call clear_display 
3e48 c3 5c 3f				jp .home		; and home cursor 
3e4b					NEXTW 
3e4b c3 28 22			jp macro_next 
3e4e				endm 
# End of macro NEXTW
3e4e			 
3e4e			.DRAW: 
3e4e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e4e 36				db WORD_SYS_CORE+34             
3e4f 79 3e			dw .DUMP            
3e51 05				db 4 + 1 
3e52 .. 00			db "DRAW",0              
3e57				endm 
# End of macro CWHEAD
3e57			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e57					if DEBUG_FORTH_WORDS_KEY 
3e57						DMARK "DRW" 
3e57 f5				push af  
3e58 3a 6c 3e			ld a, (.dmark)  
3e5b 32 b4 fe			ld (debug_mark),a  
3e5e 3a 6d 3e			ld a, (.dmark+1)  
3e61 32 b5 fe			ld (debug_mark+1),a  
3e64 3a 6e 3e			ld a, (.dmark+2)  
3e67 32 b6 fe			ld (debug_mark+2),a  
3e6a 18 03			jr .pastdmark  
3e6c ..			.dmark: db "DRW"  
3e6f f1			.pastdmark: pop af  
3e70			endm  
# End of macro DMARK
3e70						CALLMONITOR 
3e70 cd 46 18			call break_point_state  
3e73				endm  
# End of macro CALLMONITOR
3e73					endif 
3e73 cd b8 0c				call update_display 
3e76					NEXTW 
3e76 c3 28 22			jp macro_next 
3e79				endm 
# End of macro NEXTW
3e79			 
3e79			.DUMP: 
3e79				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e79 37				db WORD_SYS_CORE+35             
3e7a b1 3e			dw .CDUMP            
3e7c 05				db 4 + 1 
3e7d .. 00			db "DUMP",0              
3e82				endm 
# End of macro CWHEAD
3e82			; | DUMP ( x -- ) With address x display dump   | DONE 
3e82			; TODO pop address to use off of the stack 
3e82					if DEBUG_FORTH_WORDS_KEY 
3e82						DMARK "DUM" 
3e82 f5				push af  
3e83 3a 97 3e			ld a, (.dmark)  
3e86 32 b4 fe			ld (debug_mark),a  
3e89 3a 98 3e			ld a, (.dmark+1)  
3e8c 32 b5 fe			ld (debug_mark+1),a  
3e8f 3a 99 3e			ld a, (.dmark+2)  
3e92 32 b6 fe			ld (debug_mark+2),a  
3e95 18 03			jr .pastdmark  
3e97 ..			.dmark: db "DUM"  
3e9a f1			.pastdmark: pop af  
3e9b			endm  
# End of macro DMARK
3e9b						CALLMONITOR 
3e9b cd 46 18			call break_point_state  
3e9e				endm  
# End of macro CALLMONITOR
3e9e					endif 
3e9e cd 95 0c				call clear_display 
3ea1			 
3ea1					; get address 
3ea1			 
3ea1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea1 cd b1 20			call macro_dsp_valuehl 
3ea4				endm 
# End of macro FORTH_DSP_VALUEHL
3ea4				 
3ea4					; save it for cdump 
3ea4			 
3ea4 22 a8 f6				ld (os_cur_ptr),hl 
3ea7			 
3ea7					; destroy value TOS 
3ea7			 
3ea7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea7 cd 69 21			call macro_forth_dsp_pop 
3eaa				endm 
# End of macro FORTH_DSP_POP
3eaa			 
3eaa cd 3a 1d				call dumpcont	; skip old style of param parsing	 
3ead c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3eae					NEXTW 
3eae c3 28 22			jp macro_next 
3eb1				endm 
# End of macro NEXTW
3eb1			.CDUMP: 
3eb1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3eb1 38				db WORD_SYS_CORE+36             
3eb2 e1 3e			dw .DAT            
3eb4 06				db 5 + 1 
3eb5 .. 00			db "CDUMP",0              
3ebb				endm 
# End of macro CWHEAD
3ebb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ebb					if DEBUG_FORTH_WORDS_KEY 
3ebb						DMARK "CDP" 
3ebb f5				push af  
3ebc 3a d0 3e			ld a, (.dmark)  
3ebf 32 b4 fe			ld (debug_mark),a  
3ec2 3a d1 3e			ld a, (.dmark+1)  
3ec5 32 b5 fe			ld (debug_mark+1),a  
3ec8 3a d2 3e			ld a, (.dmark+2)  
3ecb 32 b6 fe			ld (debug_mark+2),a  
3ece 18 03			jr .pastdmark  
3ed0 ..			.dmark: db "CDP"  
3ed3 f1			.pastdmark: pop af  
3ed4			endm  
# End of macro DMARK
3ed4						CALLMONITOR 
3ed4 cd 46 18			call break_point_state  
3ed7				endm  
# End of macro CALLMONITOR
3ed7					endif 
3ed7 cd 95 0c				call clear_display 
3eda cd 3a 1d				call dumpcont	 
3edd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ede					NEXTW 
3ede c3 28 22			jp macro_next 
3ee1				endm 
# End of macro NEXTW
3ee1			 
3ee1			 
3ee1			 
3ee1			 
3ee1			.DAT: 
3ee1				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ee1 3d				db WORD_SYS_CORE+41             
3ee2 37 3f			dw .HOME            
3ee4 03				db 2 + 1 
3ee5 .. 00			db "AT",0              
3ee8				endm 
# End of macro CWHEAD
3ee8			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3ee8					if DEBUG_FORTH_WORDS_KEY 
3ee8						DMARK "AT." 
3ee8 f5				push af  
3ee9 3a fd 3e			ld a, (.dmark)  
3eec 32 b4 fe			ld (debug_mark),a  
3eef 3a fe 3e			ld a, (.dmark+1)  
3ef2 32 b5 fe			ld (debug_mark+1),a  
3ef5 3a ff 3e			ld a, (.dmark+2)  
3ef8 32 b6 fe			ld (debug_mark+2),a  
3efb 18 03			jr .pastdmark  
3efd ..			.dmark: db "AT."  
3f00 f1			.pastdmark: pop af  
3f01			endm  
# End of macro DMARK
3f01						CALLMONITOR 
3f01 cd 46 18			call break_point_state  
3f04				endm  
# End of macro CALLMONITOR
3f04					endif 
3f04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f04 cd b1 20			call macro_dsp_valuehl 
3f07				endm 
# End of macro FORTH_DSP_VALUEHL
3f07			 
3f07			 
3f07					; TODO save cursor row 
3f07 7d					ld a,l 
3f08 fe 02				cp 2 
3f0a 20 04				jr nz, .crow3 
3f0c 3e 14				ld a, display_row_2 
3f0e 18 12				jr .ccol1 
3f10 fe 03		.crow3:		cp 3 
3f12 20 04				jr nz, .crow4 
3f14 3e 28				ld a, display_row_3 
3f16 18 0a				jr .ccol1 
3f18 fe 04		.crow4:		cp 4 
3f1a 20 04				jr nz, .crow1 
3f1c 3e 3c				ld a, display_row_4 
3f1e 18 02				jr .ccol1 
3f20 3e 00		.crow1:		ld a,display_row_1 
3f22 f5			.ccol1:		push af			; got row offset 
3f23 6f					ld l,a 
3f24 26 00				ld h,0 
3f26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f26 cd 69 21			call macro_forth_dsp_pop 
3f29				endm 
# End of macro FORTH_DSP_POP
3f29					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f29 cd b1 20			call macro_dsp_valuehl 
3f2c				endm 
# End of macro FORTH_DSP_VALUEHL
3f2c					; TODO save cursor col 
3f2c f1					pop af 
3f2d 85					add l		; add col offset 
3f2e 32 ee fb				ld (f_cursor_ptr), a 
3f31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f31 cd 69 21			call macro_forth_dsp_pop 
3f34				endm 
# End of macro FORTH_DSP_POP
3f34			 
3f34					; calculate  
3f34			 
3f34					NEXTW 
3f34 c3 28 22			jp macro_next 
3f37				endm 
# End of macro NEXTW
3f37			 
3f37			 
3f37			.HOME: 
3f37				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f37 41				db WORD_SYS_CORE+45             
3f38 64 3f			dw .SPACE            
3f3a 05				db 4 + 1 
3f3b .. 00			db "HOME",0              
3f40				endm 
# End of macro CWHEAD
3f40			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f40					if DEBUG_FORTH_WORDS_KEY 
3f40						DMARK "HOM" 
3f40 f5				push af  
3f41 3a 55 3f			ld a, (.dmark)  
3f44 32 b4 fe			ld (debug_mark),a  
3f47 3a 56 3f			ld a, (.dmark+1)  
3f4a 32 b5 fe			ld (debug_mark+1),a  
3f4d 3a 57 3f			ld a, (.dmark+2)  
3f50 32 b6 fe			ld (debug_mark+2),a  
3f53 18 03			jr .pastdmark  
3f55 ..			.dmark: db "HOM"  
3f58 f1			.pastdmark: pop af  
3f59			endm  
# End of macro DMARK
3f59						CALLMONITOR 
3f59 cd 46 18			call break_point_state  
3f5c				endm  
# End of macro CALLMONITOR
3f5c					endif 
3f5c 3e 00		.home:		ld a, 0		; and home cursor 
3f5e 32 ee fb				ld (f_cursor_ptr), a 
3f61					NEXTW 
3f61 c3 28 22			jp macro_next 
3f64				endm 
# End of macro NEXTW
3f64			 
3f64			 
3f64			.SPACE: 
3f64				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f64 46				db WORD_SYS_CORE+50             
3f65 92 3f			dw .SPACES            
3f67 03				db 2 + 1 
3f68 .. 00			db "BL",0              
3f6b				endm 
# End of macro CWHEAD
3f6b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f6b					if DEBUG_FORTH_WORDS_KEY 
3f6b						DMARK "BL." 
3f6b f5				push af  
3f6c 3a 80 3f			ld a, (.dmark)  
3f6f 32 b4 fe			ld (debug_mark),a  
3f72 3a 81 3f			ld a, (.dmark+1)  
3f75 32 b5 fe			ld (debug_mark+1),a  
3f78 3a 82 3f			ld a, (.dmark+2)  
3f7b 32 b6 fe			ld (debug_mark+2),a  
3f7e 18 03			jr .pastdmark  
3f80 ..			.dmark: db "BL."  
3f83 f1			.pastdmark: pop af  
3f84			endm  
# End of macro DMARK
3f84						CALLMONITOR 
3f84 cd 46 18			call break_point_state  
3f87				endm  
# End of macro CALLMONITOR
3f87					endif 
3f87 21 90 3f				ld hl, .blstr 
3f8a cd 28 1f				call forth_push_str 
3f8d					 
3f8d				       NEXTW 
3f8d c3 28 22			jp macro_next 
3f90				endm 
# End of macro NEXTW
3f90			 
3f90 .. 00		.blstr: db " ", 0 
3f92			 
3f92			.SPACES: 
3f92				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f92 47				db WORD_SYS_CORE+51             
3f93 2d 40			dw .SCROLL            
3f95 07				db 6 + 1 
3f96 .. 00			db "SPACES",0              
3f9d				endm 
# End of macro CWHEAD
3f9d			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3f9d					if DEBUG_FORTH_WORDS_KEY 
3f9d						DMARK "SPS" 
3f9d f5				push af  
3f9e 3a b2 3f			ld a, (.dmark)  
3fa1 32 b4 fe			ld (debug_mark),a  
3fa4 3a b3 3f			ld a, (.dmark+1)  
3fa7 32 b5 fe			ld (debug_mark+1),a  
3faa 3a b4 3f			ld a, (.dmark+2)  
3fad 32 b6 fe			ld (debug_mark+2),a  
3fb0 18 03			jr .pastdmark  
3fb2 ..			.dmark: db "SPS"  
3fb5 f1			.pastdmark: pop af  
3fb6			endm  
# End of macro DMARK
3fb6						CALLMONITOR 
3fb6 cd 46 18			call break_point_state  
3fb9				endm  
# End of macro CALLMONITOR
3fb9					endif 
3fb9			 
3fb9			 
3fb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fb9 cd b1 20			call macro_dsp_valuehl 
3fbc				endm 
# End of macro FORTH_DSP_VALUEHL
3fbc			 
3fbc			;		push hl    ; u 
3fbc					if DEBUG_FORTH_WORDS 
3fbc						DMARK "SPA" 
3fbc f5				push af  
3fbd 3a d1 3f			ld a, (.dmark)  
3fc0 32 b4 fe			ld (debug_mark),a  
3fc3 3a d2 3f			ld a, (.dmark+1)  
3fc6 32 b5 fe			ld (debug_mark+1),a  
3fc9 3a d3 3f			ld a, (.dmark+2)  
3fcc 32 b6 fe			ld (debug_mark+2),a  
3fcf 18 03			jr .pastdmark  
3fd1 ..			.dmark: db "SPA"  
3fd4 f1			.pastdmark: pop af  
3fd5			endm  
# End of macro DMARK
3fd5						CALLMONITOR 
3fd5 cd 46 18			call break_point_state  
3fd8				endm  
# End of macro CALLMONITOR
3fd8					endif 
3fd8			 
3fd8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd8 cd 69 21			call macro_forth_dsp_pop 
3fdb				endm 
# End of macro FORTH_DSP_POP
3fdb			;		pop hl 
3fdb 4d					ld c, l 
3fdc 06 00				ld b, 0 
3fde 21 85 f3				ld hl, scratch  
3fe1			 
3fe1					if DEBUG_FORTH_WORDS 
3fe1						DMARK "SP2" 
3fe1 f5				push af  
3fe2 3a f6 3f			ld a, (.dmark)  
3fe5 32 b4 fe			ld (debug_mark),a  
3fe8 3a f7 3f			ld a, (.dmark+1)  
3feb 32 b5 fe			ld (debug_mark+1),a  
3fee 3a f8 3f			ld a, (.dmark+2)  
3ff1 32 b6 fe			ld (debug_mark+2),a  
3ff4 18 03			jr .pastdmark  
3ff6 ..			.dmark: db "SP2"  
3ff9 f1			.pastdmark: pop af  
3ffa			endm  
# End of macro DMARK
3ffa						CALLMONITOR 
3ffa cd 46 18			call break_point_state  
3ffd				endm  
# End of macro CALLMONITOR
3ffd					endif 
3ffd 3e 20				ld a, ' ' 
3fff c5			.spaces1:	push bc 
4000 77					ld (hl),a 
4001 23					inc hl 
4002 c1					pop bc 
4003 10 fa				djnz .spaces1 
4005 3e 00				ld a,0 
4007 77					ld (hl),a 
4008 21 85 f3				ld hl, scratch 
400b					if DEBUG_FORTH_WORDS 
400b						DMARK "SP3" 
400b f5				push af  
400c 3a 20 40			ld a, (.dmark)  
400f 32 b4 fe			ld (debug_mark),a  
4012 3a 21 40			ld a, (.dmark+1)  
4015 32 b5 fe			ld (debug_mark+1),a  
4018 3a 22 40			ld a, (.dmark+2)  
401b 32 b6 fe			ld (debug_mark+2),a  
401e 18 03			jr .pastdmark  
4020 ..			.dmark: db "SP3"  
4023 f1			.pastdmark: pop af  
4024			endm  
# End of macro DMARK
4024						CALLMONITOR 
4024 cd 46 18			call break_point_state  
4027				endm  
# End of macro CALLMONITOR
4027					endif 
4027 cd 23 20				call forth_apush 
402a			 
402a				       NEXTW 
402a c3 28 22			jp macro_next 
402d				endm 
# End of macro NEXTW
402d			 
402d			 
402d			 
402d			.SCROLL: 
402d				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
402d 53				db WORD_SYS_CORE+63             
402e 5a 40			dw .SCROLLD            
4030 07				db 6 + 1 
4031 .. 00			db "SCROLL",0              
4038				endm 
# End of macro CWHEAD
4038			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4038					if DEBUG_FORTH_WORDS_KEY 
4038						DMARK "SCR" 
4038 f5				push af  
4039 3a 4d 40			ld a, (.dmark)  
403c 32 b4 fe			ld (debug_mark),a  
403f 3a 4e 40			ld a, (.dmark+1)  
4042 32 b5 fe			ld (debug_mark+1),a  
4045 3a 4f 40			ld a, (.dmark+2)  
4048 32 b6 fe			ld (debug_mark+2),a  
404b 18 03			jr .pastdmark  
404d ..			.dmark: db "SCR"  
4050 f1			.pastdmark: pop af  
4051			endm  
# End of macro DMARK
4051						CALLMONITOR 
4051 cd 46 18			call break_point_state  
4054				endm  
# End of macro CALLMONITOR
4054					endif 
4054			 
4054 cd 57 0c			call scroll_up 
4057			;	call update_display 
4057			 
4057					NEXTW 
4057 c3 28 22			jp macro_next 
405a				endm 
# End of macro NEXTW
405a			 
405a			 
405a			 
405a			;		; get dir 
405a			; 
405a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
405a			; 
405a			;		push hl 
405a			; 
405a			;		; destroy value TOS 
405a			; 
405a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
405a			; 
405a			;		; get count 
405a			; 
405a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
405a			; 
405a			;		push hl 
405a			; 
405a			;		; destroy value TOS 
405a			; 
405a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
405a			; 
405a			;		; one value on hl get other one back 
405a			; 
405a			;		pop bc    ; count 
405a			; 
405a			;		pop de   ; dir 
405a			; 
405a			; 
405a			;		ld b, c 
405a			; 
405a			;.scrolldir:     push bc 
405a			;		push de 
405a			; 
405a			;		ld a, 0 
405a			;		cp e 
405a			;		jr z, .scrollup  
405a			;		call scroll_down 
405a			;		jr .scrollnext 
405a			;.scrollup:	call scroll_up 
405a			; 
405a			;		 
405a			;.scrollnext: 
405a			;		pop de 
405a			;		pop bc 
405a			;		djnz .scrolldir 
405a			; 
405a			; 
405a			; 
405a			; 
405a			; 
405a			;		NEXTW 
405a			 
405a			.SCROLLD: 
405a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
405a 53				db WORD_SYS_CORE+63             
405b 88 40			dw .ATQ            
405d 08				db 7 + 1 
405e .. 00			db "SCROLLD",0              
4066				endm 
# End of macro CWHEAD
4066			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4066					if DEBUG_FORTH_WORDS_KEY 
4066						DMARK "SCD" 
4066 f5				push af  
4067 3a 7b 40			ld a, (.dmark)  
406a 32 b4 fe			ld (debug_mark),a  
406d 3a 7c 40			ld a, (.dmark+1)  
4070 32 b5 fe			ld (debug_mark+1),a  
4073 3a 7d 40			ld a, (.dmark+2)  
4076 32 b6 fe			ld (debug_mark+2),a  
4079 18 03			jr .pastdmark  
407b ..			.dmark: db "SCD"  
407e f1			.pastdmark: pop af  
407f			endm  
# End of macro DMARK
407f						CALLMONITOR 
407f cd 46 18			call break_point_state  
4082				endm  
# End of macro CALLMONITOR
4082					endif 
4082			 
4082 cd 7b 0c			call scroll_down 
4085			;	call update_display 
4085			 
4085					NEXTW 
4085 c3 28 22			jp macro_next 
4088				endm 
# End of macro NEXTW
4088			 
4088			 
4088			.ATQ: 
4088				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4088 62				db WORD_SYS_CORE+78             
4089 e6 40			dw .AUTODSP            
408b 04				db 3 + 1 
408c .. 00			db "AT@",0              
4090				endm 
# End of macro CWHEAD
4090			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4090					if DEBUG_FORTH_WORDS_KEY 
4090						DMARK "ATA" 
4090 f5				push af  
4091 3a a5 40			ld a, (.dmark)  
4094 32 b4 fe			ld (debug_mark),a  
4097 3a a6 40			ld a, (.dmark+1)  
409a 32 b5 fe			ld (debug_mark+1),a  
409d 3a a7 40			ld a, (.dmark+2)  
40a0 32 b6 fe			ld (debug_mark+2),a  
40a3 18 03			jr .pastdmark  
40a5 ..			.dmark: db "ATA"  
40a8 f1			.pastdmark: pop af  
40a9			endm  
# End of macro DMARK
40a9						CALLMONITOR 
40a9 cd 46 18			call break_point_state  
40ac				endm  
# End of macro CALLMONITOR
40ac					endif 
40ac			 
40ac			 
40ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ac cd b1 20			call macro_dsp_valuehl 
40af				endm 
# End of macro FORTH_DSP_VALUEHL
40af			 
40af					; TODO save cursor row 
40af 7d					ld a,l 
40b0 fe 02				cp 2 
40b2 20 04				jr nz, .crow3aq 
40b4 3e 14				ld a, display_row_2 
40b6 18 12				jr .ccol1aq 
40b8 fe 03		.crow3aq:		cp 3 
40ba 20 04				jr nz, .crow4aq 
40bc 3e 28				ld a, display_row_3 
40be 18 0a				jr .ccol1aq 
40c0 fe 04		.crow4aq:		cp 4 
40c2 20 04				jr nz, .crow1aq 
40c4 3e 3c				ld a, display_row_4 
40c6 18 02				jr .ccol1aq 
40c8 3e 00		.crow1aq:		ld a,display_row_1 
40ca f5			.ccol1aq:		push af			; got row offset 
40cb 6f					ld l,a 
40cc 26 00				ld h,0 
40ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ce cd 69 21			call macro_forth_dsp_pop 
40d1				endm 
# End of macro FORTH_DSP_POP
40d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40d1 cd b1 20			call macro_dsp_valuehl 
40d4				endm 
# End of macro FORTH_DSP_VALUEHL
40d4					; TODO save cursor col 
40d4 f1					pop af 
40d5 85					add l		; add col offset 
40d6			 
40d6					; add current frame buffer address 
40d6 2a 55 fd				ld hl, (display_fb_active) 
40d9 cd c9 0e				call addatohl 
40dc			 
40dc			 
40dc			 
40dc			 
40dc					; get char frame buffer location offset in hl 
40dc			 
40dc 7e					ld a,(hl) 
40dd 26 00				ld h, 0 
40df 6f					ld l, a 
40e0			 
40e0 cd ba 1e				call forth_push_numhl 
40e3			 
40e3			 
40e3					NEXTW 
40e3 c3 28 22			jp macro_next 
40e6				endm 
# End of macro NEXTW
40e6			 
40e6			.AUTODSP: 
40e6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40e6 63				db WORD_SYS_CORE+79             
40e7 fc 40			dw .MENU            
40e9 05				db 4 + 1 
40ea .. 00			db "ADSP",0              
40ef				endm 
# End of macro CWHEAD
40ef			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40ef			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40ef			 
40ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ef cd b1 20			call macro_dsp_valuehl 
40f2				endm 
# End of macro FORTH_DSP_VALUEHL
40f2			 
40f2			;		push hl 
40f2			 
40f2					; destroy value TOS 
40f2			 
40f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f2 cd 69 21			call macro_forth_dsp_pop 
40f5				endm 
# End of macro FORTH_DSP_POP
40f5			 
40f5			;		pop hl 
40f5			 
40f5 7d					ld a,l 
40f6 32 cc fb				ld (cli_autodisplay), a 
40f9				       NEXTW 
40f9 c3 28 22			jp macro_next 
40fc				endm 
# End of macro NEXTW
40fc			 
40fc			.MENU: 
40fc				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40fc 70				db WORD_SYS_CORE+92             
40fd a5 41			dw .ENDDISPLAY            
40ff 05				db 4 + 1 
4100 .. 00			db "MENU",0              
4105				endm 
# End of macro CWHEAD
4105			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4105			 
4105			;		; get number of items on the stack 
4105			; 
4105				 
4105					FORTH_DSP_VALUEHL 
4105 cd b1 20			call macro_dsp_valuehl 
4108				endm 
# End of macro FORTH_DSP_VALUEHL
4108				 
4108					if DEBUG_FORTH_WORDS_KEY 
4108						DMARK "MNU" 
4108 f5				push af  
4109 3a 1d 41			ld a, (.dmark)  
410c 32 b4 fe			ld (debug_mark),a  
410f 3a 1e 41			ld a, (.dmark+1)  
4112 32 b5 fe			ld (debug_mark+1),a  
4115 3a 1f 41			ld a, (.dmark+2)  
4118 32 b6 fe			ld (debug_mark+2),a  
411b 18 03			jr .pastdmark  
411d ..			.dmark: db "MNU"  
4120 f1			.pastdmark: pop af  
4121			endm  
# End of macro DMARK
4121						CALLMONITOR 
4121 cd 46 18			call break_point_state  
4124				endm  
# End of macro CALLMONITOR
4124					endif 
4124			 
4124 45					ld b, l	 
4125 05					dec b 
4126			 
4126					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4126 cd 69 21			call macro_forth_dsp_pop 
4129				endm 
# End of macro FORTH_DSP_POP
4129			 
4129			 
4129					; go directly through the stack to pluck out the string pointers and build an array 
4129			 
4129			;		FORTH_DSP 
4129			 
4129					; hl contains top most stack item 
4129				 
4129 11 85 f3				ld de, scratch 
412c			 
412c			.mbuild: 
412c			 
412c					FORTH_DSP_VALUEHL 
412c cd b1 20			call macro_dsp_valuehl 
412f				endm 
# End of macro FORTH_DSP_VALUEHL
412f			 
412f					if DEBUG_FORTH_WORDS 
412f						DMARK "MN3" 
412f f5				push af  
4130 3a 44 41			ld a, (.dmark)  
4133 32 b4 fe			ld (debug_mark),a  
4136 3a 45 41			ld a, (.dmark+1)  
4139 32 b5 fe			ld (debug_mark+1),a  
413c 3a 46 41			ld a, (.dmark+2)  
413f 32 b6 fe			ld (debug_mark+2),a  
4142 18 03			jr .pastdmark  
4144 ..			.dmark: db "MN3"  
4147 f1			.pastdmark: pop af  
4148			endm  
# End of macro DMARK
4148						CALLMONITOR 
4148 cd 46 18			call break_point_state  
414b				endm  
# End of macro CALLMONITOR
414b					endif 
414b eb					ex de, hl 
414c 73					ld (hl), e 
414d 23					inc hl 
414e 72					ld (hl), d 
414f 23					inc hl 
4150 eb					ex de, hl 
4151			 
4151					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4151 cd 69 21			call macro_forth_dsp_pop 
4154				endm 
# End of macro FORTH_DSP_POP
4154			 
4154 10 d6				djnz .mbuild 
4156			 
4156					; done add term 
4156			 
4156 eb					ex de, hl 
4157 36 00				ld (hl), 0 
4159 23					inc hl 
415a 36 00				ld (hl), 0 
415c			 
415c				 
415c					 
415c 21 85 f3				ld hl, scratch 
415f			 
415f					if DEBUG_FORTH_WORDS 
415f						DMARK "MNx" 
415f f5				push af  
4160 3a 74 41			ld a, (.dmark)  
4163 32 b4 fe			ld (debug_mark),a  
4166 3a 75 41			ld a, (.dmark+1)  
4169 32 b5 fe			ld (debug_mark+1),a  
416c 3a 76 41			ld a, (.dmark+2)  
416f 32 b6 fe			ld (debug_mark+2),a  
4172 18 03			jr .pastdmark  
4174 ..			.dmark: db "MNx"  
4177 f1			.pastdmark: pop af  
4178			endm  
# End of macro DMARK
4178						CALLMONITOR 
4178 cd 46 18			call break_point_state  
417b				endm  
# End of macro CALLMONITOR
417b					endif 
417b			 
417b			 
417b			 
417b 3e 00				ld a, 0 
417d cd c6 0c				call menu 
4180			 
4180			 
4180 6f					ld l, a 
4181 26 00				ld h, 0 
4183			 
4183					if DEBUG_FORTH_WORDS 
4183						DMARK "MNr" 
4183 f5				push af  
4184 3a 98 41			ld a, (.dmark)  
4187 32 b4 fe			ld (debug_mark),a  
418a 3a 99 41			ld a, (.dmark+1)  
418d 32 b5 fe			ld (debug_mark+1),a  
4190 3a 9a 41			ld a, (.dmark+2)  
4193 32 b6 fe			ld (debug_mark+2),a  
4196 18 03			jr .pastdmark  
4198 ..			.dmark: db "MNr"  
419b f1			.pastdmark: pop af  
419c			endm  
# End of macro DMARK
419c						CALLMONITOR 
419c cd 46 18			call break_point_state  
419f				endm  
# End of macro CALLMONITOR
419f					endif 
419f			 
419f cd ba 1e				call forth_push_numhl 
41a2			 
41a2			 
41a2			 
41a2			 
41a2				       NEXTW 
41a2 c3 28 22			jp macro_next 
41a5				endm 
# End of macro NEXTW
41a5			 
41a5			 
41a5			.ENDDISPLAY: 
41a5			 
41a5			; eof 
# End of file forth_words_display.asm
41a5			include "forth_words_str.asm" 
41a5			 
41a5			; | ## String Words 
41a5			 
41a5			.PTR:   
41a5			 
41a5				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41a5 48				db WORD_SYS_CORE+52             
41a6 d2 41			dw .STYPE            
41a8 04				db 3 + 1 
41a9 .. 00			db "PTR",0              
41ad				endm 
# End of macro CWHEAD
41ad			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41ad			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41ad			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41ad			 
41ad					if DEBUG_FORTH_WORDS_KEY 
41ad						DMARK "PTR" 
41ad f5				push af  
41ae 3a c2 41			ld a, (.dmark)  
41b1 32 b4 fe			ld (debug_mark),a  
41b4 3a c3 41			ld a, (.dmark+1)  
41b7 32 b5 fe			ld (debug_mark+1),a  
41ba 3a c4 41			ld a, (.dmark+2)  
41bd 32 b6 fe			ld (debug_mark+2),a  
41c0 18 03			jr .pastdmark  
41c2 ..			.dmark: db "PTR"  
41c5 f1			.pastdmark: pop af  
41c6			endm  
# End of macro DMARK
41c6						CALLMONITOR 
41c6 cd 46 18			call break_point_state  
41c9				endm  
# End of macro CALLMONITOR
41c9					endif 
41c9					FORTH_DSP_VALUEHL 
41c9 cd b1 20			call macro_dsp_valuehl 
41cc				endm 
# End of macro FORTH_DSP_VALUEHL
41cc cd ba 1e				call forth_push_numhl 
41cf			 
41cf			 
41cf					NEXTW 
41cf c3 28 22			jp macro_next 
41d2				endm 
# End of macro NEXTW
41d2			.STYPE: 
41d2				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41d2 48				db WORD_SYS_CORE+52             
41d3 21 42			dw .UPPER            
41d5 06				db 5 + 1 
41d6 .. 00			db "STYPE",0              
41dc				endm 
# End of macro CWHEAD
41dc			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41dc					if DEBUG_FORTH_WORDS_KEY 
41dc						DMARK "STY" 
41dc f5				push af  
41dd 3a f1 41			ld a, (.dmark)  
41e0 32 b4 fe			ld (debug_mark),a  
41e3 3a f2 41			ld a, (.dmark+1)  
41e6 32 b5 fe			ld (debug_mark+1),a  
41e9 3a f3 41			ld a, (.dmark+2)  
41ec 32 b6 fe			ld (debug_mark+2),a  
41ef 18 03			jr .pastdmark  
41f1 ..			.dmark: db "STY"  
41f4 f1			.pastdmark: pop af  
41f5			endm  
# End of macro DMARK
41f5						CALLMONITOR 
41f5 cd 46 18			call break_point_state  
41f8				endm  
# End of macro CALLMONITOR
41f8					endif 
41f8					FORTH_DSP 
41f8 cd 77 20			call macro_forth_dsp 
41fb				endm 
# End of macro FORTH_DSP
41fb					;v5 FORTH_DSP_VALUE 
41fb			 
41fb 7e					ld a, (hl) 
41fc			 
41fc f5					push af 
41fd			 
41fd			; Dont destroy TOS		FORTH_DSP_POP 
41fd			 
41fd f1					pop af 
41fe			 
41fe fe 01				cp DS_TYPE_STR 
4200 28 09				jr z, .typestr 
4202			 
4202 fe 02				cp DS_TYPE_INUM 
4204 28 0a				jr z, .typeinum 
4206			 
4206 21 1f 42				ld hl, .tna 
4209 18 0a				jr .tpush 
420b			 
420b 21 1b 42		.typestr:	ld hl, .tstr 
420e 18 05				jr .tpush 
4210 21 1d 42		.typeinum:	ld hl, .tinum 
4213 18 00				jr .tpush 
4215			 
4215			.tpush: 
4215			 
4215 cd 28 1f				call forth_push_str 
4218			 
4218					NEXTW 
4218 c3 28 22			jp macro_next 
421b				endm 
# End of macro NEXTW
421b .. 00		.tstr:	db "s",0 
421d .. 00		.tinum:  db "i",0 
421f .. 00		.tna:   db "?", 0 
4221			 
4221			 
4221			.UPPER: 
4221				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4221 48				db WORD_SYS_CORE+52             
4222 5c 42			dw .LOWER            
4224 06				db 5 + 1 
4225 .. 00			db "UPPER",0              
422b				endm 
# End of macro CWHEAD
422b			; | UPPER ( s -- s ) Upper case string s  | DONE 
422b					if DEBUG_FORTH_WORDS_KEY 
422b						DMARK "UPR" 
422b f5				push af  
422c 3a 40 42			ld a, (.dmark)  
422f 32 b4 fe			ld (debug_mark),a  
4232 3a 41 42			ld a, (.dmark+1)  
4235 32 b5 fe			ld (debug_mark+1),a  
4238 3a 42 42			ld a, (.dmark+2)  
423b 32 b6 fe			ld (debug_mark+2),a  
423e 18 03			jr .pastdmark  
4240 ..			.dmark: db "UPR"  
4243 f1			.pastdmark: pop af  
4244			endm  
# End of macro DMARK
4244						CALLMONITOR 
4244 cd 46 18			call break_point_state  
4247				endm  
# End of macro CALLMONITOR
4247					endif 
4247			 
4247					FORTH_DSP 
4247 cd 77 20			call macro_forth_dsp 
424a				endm 
# End of macro FORTH_DSP
424a					 
424a			; TODO check is string type 
424a			 
424a					FORTH_DSP_VALUEHL 
424a cd b1 20			call macro_dsp_valuehl 
424d				endm 
# End of macro FORTH_DSP_VALUEHL
424d			; get pointer to string in hl 
424d			 
424d 7e			.toup:		ld a, (hl) 
424e fe 00				cp 0 
4250 28 07				jr z, .toupdone 
4252			 
4252 cd 36 12				call to_upper 
4255			 
4255 77					ld (hl), a 
4256 23					inc hl 
4257 18 f4				jr .toup 
4259			 
4259					 
4259			 
4259			 
4259			; for each char convert to upper 
4259					 
4259			.toupdone: 
4259			 
4259			 
4259					NEXTW 
4259 c3 28 22			jp macro_next 
425c				endm 
# End of macro NEXTW
425c			.LOWER: 
425c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
425c 48				db WORD_SYS_CORE+52             
425d 97 42			dw .TCASE            
425f 06				db 5 + 1 
4260 .. 00			db "LOWER",0              
4266				endm 
# End of macro CWHEAD
4266			; | LOWER ( s -- s ) Lower case string s  | DONE 
4266					if DEBUG_FORTH_WORDS_KEY 
4266						DMARK "LWR" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 b4 fe			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 b5 fe			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 b6 fe			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "LWR"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f						CALLMONITOR 
427f cd 46 18			call break_point_state  
4282				endm  
# End of macro CALLMONITOR
4282					endif 
4282			 
4282					FORTH_DSP 
4282 cd 77 20			call macro_forth_dsp 
4285				endm 
# End of macro FORTH_DSP
4285					 
4285			; TODO check is string type 
4285			 
4285					FORTH_DSP_VALUEHL 
4285 cd b1 20			call macro_dsp_valuehl 
4288				endm 
# End of macro FORTH_DSP_VALUEHL
4288			; get pointer to string in hl 
4288			 
4288 7e			.tolow:		ld a, (hl) 
4289 fe 00				cp 0 
428b 28 07				jr z, .tolowdone 
428d			 
428d cd 3f 12				call to_lower 
4290			 
4290 77					ld (hl), a 
4291 23					inc hl 
4292 18 f4				jr .tolow 
4294			 
4294					 
4294			 
4294			 
4294			; for each char convert to low 
4294					 
4294			.tolowdone: 
4294					NEXTW 
4294 c3 28 22			jp macro_next 
4297				endm 
# End of macro NEXTW
4297			.TCASE: 
4297				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4297 48				db WORD_SYS_CORE+52             
4298 cd 43			dw .SUBSTR            
429a 06				db 5 + 1 
429b .. 00			db "TCASE",0              
42a1				endm 
# End of macro CWHEAD
42a1			; | TCASE ( s -- s ) Title case string s  | DONE 
42a1					if DEBUG_FORTH_WORDS_KEY 
42a1						DMARK "TCS" 
42a1 f5				push af  
42a2 3a b6 42			ld a, (.dmark)  
42a5 32 b4 fe			ld (debug_mark),a  
42a8 3a b7 42			ld a, (.dmark+1)  
42ab 32 b5 fe			ld (debug_mark+1),a  
42ae 3a b8 42			ld a, (.dmark+2)  
42b1 32 b6 fe			ld (debug_mark+2),a  
42b4 18 03			jr .pastdmark  
42b6 ..			.dmark: db "TCS"  
42b9 f1			.pastdmark: pop af  
42ba			endm  
# End of macro DMARK
42ba						CALLMONITOR 
42ba cd 46 18			call break_point_state  
42bd				endm  
# End of macro CALLMONITOR
42bd					endif 
42bd			 
42bd					FORTH_DSP 
42bd cd 77 20			call macro_forth_dsp 
42c0				endm 
# End of macro FORTH_DSP
42c0					 
42c0			; TODO check is string type 
42c0			 
42c0					FORTH_DSP_VALUEHL 
42c0 cd b1 20			call macro_dsp_valuehl 
42c3				endm 
# End of macro FORTH_DSP_VALUEHL
42c3			; get pointer to string in hl 
42c3			 
42c3					if DEBUG_FORTH_WORDS 
42c3						DMARK "TC1" 
42c3 f5				push af  
42c4 3a d8 42			ld a, (.dmark)  
42c7 32 b4 fe			ld (debug_mark),a  
42ca 3a d9 42			ld a, (.dmark+1)  
42cd 32 b5 fe			ld (debug_mark+1),a  
42d0 3a da 42			ld a, (.dmark+2)  
42d3 32 b6 fe			ld (debug_mark+2),a  
42d6 18 03			jr .pastdmark  
42d8 ..			.dmark: db "TC1"  
42db f1			.pastdmark: pop af  
42dc			endm  
# End of macro DMARK
42dc						CALLMONITOR 
42dc cd 46 18			call break_point_state  
42df				endm  
# End of macro CALLMONITOR
42df					endif 
42df			 
42df					; first time in turn to upper case first char 
42df			 
42df 7e					ld a, (hl) 
42e0 c3 6a 43				jp .totsiptou 
42e3			 
42e3			 
42e3 7e			.tot:		ld a, (hl) 
42e4 fe 00				cp 0 
42e6 ca ae 43				jp z, .totdone 
42e9			 
42e9					if DEBUG_FORTH_WORDS 
42e9						DMARK "TC2" 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 b4 fe			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 b5 fe			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 b6 fe			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "TC2"  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd 46 18			call break_point_state  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305					; check to see if current char is a space 
4305			 
4305 fe 20				cp ' ' 
4307 28 21				jr z, .totsp 
4309 cd 3f 12				call to_lower 
430c					if DEBUG_FORTH_WORDS 
430c						DMARK "TC3" 
430c f5				push af  
430d 3a 21 43			ld a, (.dmark)  
4310 32 b4 fe			ld (debug_mark),a  
4313 3a 22 43			ld a, (.dmark+1)  
4316 32 b5 fe			ld (debug_mark+1),a  
4319 3a 23 43			ld a, (.dmark+2)  
431c 32 b6 fe			ld (debug_mark+2),a  
431f 18 03			jr .pastdmark  
4321 ..			.dmark: db "TC3"  
4324 f1			.pastdmark: pop af  
4325			endm  
# End of macro DMARK
4325						CALLMONITOR 
4325 cd 46 18			call break_point_state  
4328				endm  
# End of macro CALLMONITOR
4328					endif 
4328 18 63				jr .totnxt 
432a			 
432a			.totsp:         ; on a space, find next char which should be upper 
432a			 
432a					if DEBUG_FORTH_WORDS 
432a						DMARK "TC4" 
432a f5				push af  
432b 3a 3f 43			ld a, (.dmark)  
432e 32 b4 fe			ld (debug_mark),a  
4331 3a 40 43			ld a, (.dmark+1)  
4334 32 b5 fe			ld (debug_mark+1),a  
4337 3a 41 43			ld a, (.dmark+2)  
433a 32 b6 fe			ld (debug_mark+2),a  
433d 18 03			jr .pastdmark  
433f ..			.dmark: db "TC4"  
4342 f1			.pastdmark: pop af  
4343			endm  
# End of macro DMARK
4343						CALLMONITOR 
4343 cd 46 18			call break_point_state  
4346				endm  
# End of macro CALLMONITOR
4346					endif 
4346					;; 
4346			 
4346 fe 20				cp ' ' 
4348 20 20				jr nz, .totsiptou 
434a 23					inc hl 
434b 7e					ld a, (hl) 
434c					if DEBUG_FORTH_WORDS 
434c						DMARK "TC5" 
434c f5				push af  
434d 3a 61 43			ld a, (.dmark)  
4350 32 b4 fe			ld (debug_mark),a  
4353 3a 62 43			ld a, (.dmark+1)  
4356 32 b5 fe			ld (debug_mark+1),a  
4359 3a 63 43			ld a, (.dmark+2)  
435c 32 b6 fe			ld (debug_mark+2),a  
435f 18 03			jr .pastdmark  
4361 ..			.dmark: db "TC5"  
4364 f1			.pastdmark: pop af  
4365			endm  
# End of macro DMARK
4365						CALLMONITOR 
4365 cd 46 18			call break_point_state  
4368				endm  
# End of macro CALLMONITOR
4368					endif 
4368 18 c0				jr .totsp 
436a fe 00		.totsiptou:    cp 0 
436c 28 40				jr z, .totdone 
436e					; not space and not zero term so upper case it 
436e cd 36 12				call to_upper 
4371			 
4371					if DEBUG_FORTH_WORDS 
4371						DMARK "TC6" 
4371 f5				push af  
4372 3a 86 43			ld a, (.dmark)  
4375 32 b4 fe			ld (debug_mark),a  
4378 3a 87 43			ld a, (.dmark+1)  
437b 32 b5 fe			ld (debug_mark+1),a  
437e 3a 88 43			ld a, (.dmark+2)  
4381 32 b6 fe			ld (debug_mark+2),a  
4384 18 03			jr .pastdmark  
4386 ..			.dmark: db "TC6"  
4389 f1			.pastdmark: pop af  
438a			endm  
# End of macro DMARK
438a						CALLMONITOR 
438a cd 46 18			call break_point_state  
438d				endm  
# End of macro CALLMONITOR
438d					endif 
438d			 
438d			 
438d			.totnxt: 
438d			 
438d 77					ld (hl), a 
438e 23					inc hl 
438f					if DEBUG_FORTH_WORDS 
438f						DMARK "TC7" 
438f f5				push af  
4390 3a a4 43			ld a, (.dmark)  
4393 32 b4 fe			ld (debug_mark),a  
4396 3a a5 43			ld a, (.dmark+1)  
4399 32 b5 fe			ld (debug_mark+1),a  
439c 3a a6 43			ld a, (.dmark+2)  
439f 32 b6 fe			ld (debug_mark+2),a  
43a2 18 03			jr .pastdmark  
43a4 ..			.dmark: db "TC7"  
43a7 f1			.pastdmark: pop af  
43a8			endm  
# End of macro DMARK
43a8						CALLMONITOR 
43a8 cd 46 18			call break_point_state  
43ab				endm  
# End of macro CALLMONITOR
43ab					endif 
43ab c3 e3 42				jp .tot 
43ae			 
43ae					 
43ae			 
43ae			 
43ae			; for each char convert to low 
43ae					 
43ae			.totdone: 
43ae					if DEBUG_FORTH_WORDS 
43ae						DMARK "TCd" 
43ae f5				push af  
43af 3a c3 43			ld a, (.dmark)  
43b2 32 b4 fe			ld (debug_mark),a  
43b5 3a c4 43			ld a, (.dmark+1)  
43b8 32 b5 fe			ld (debug_mark+1),a  
43bb 3a c5 43			ld a, (.dmark+2)  
43be 32 b6 fe			ld (debug_mark+2),a  
43c1 18 03			jr .pastdmark  
43c3 ..			.dmark: db "TCd"  
43c6 f1			.pastdmark: pop af  
43c7			endm  
# End of macro DMARK
43c7						CALLMONITOR 
43c7 cd 46 18			call break_point_state  
43ca				endm  
# End of macro CALLMONITOR
43ca					endif 
43ca					NEXTW 
43ca c3 28 22			jp macro_next 
43cd				endm 
# End of macro NEXTW
43cd			 
43cd			.SUBSTR: 
43cd				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43cd 48				db WORD_SYS_CORE+52             
43ce 2b 44			dw .LEFT            
43d0 07				db 6 + 1 
43d1 .. 00			db "SUBSTR",0              
43d8				endm 
# End of macro CWHEAD
43d8			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43d8			 
43d8					if DEBUG_FORTH_WORDS_KEY 
43d8						DMARK "SST" 
43d8 f5				push af  
43d9 3a ed 43			ld a, (.dmark)  
43dc 32 b4 fe			ld (debug_mark),a  
43df 3a ee 43			ld a, (.dmark+1)  
43e2 32 b5 fe			ld (debug_mark+1),a  
43e5 3a ef 43			ld a, (.dmark+2)  
43e8 32 b6 fe			ld (debug_mark+2),a  
43eb 18 03			jr .pastdmark  
43ed ..			.dmark: db "SST"  
43f0 f1			.pastdmark: pop af  
43f1			endm  
# End of macro DMARK
43f1						CALLMONITOR 
43f1 cd 46 18			call break_point_state  
43f4				endm  
# End of macro CALLMONITOR
43f4					endif 
43f4			; TODO check string type 
43f4					FORTH_DSP_VALUEHL 
43f4 cd b1 20			call macro_dsp_valuehl 
43f7				endm 
# End of macro FORTH_DSP_VALUEHL
43f7			 
43f7 e5					push hl      ; string length 
43f8			 
43f8					FORTH_DSP_POP 
43f8 cd 69 21			call macro_forth_dsp_pop 
43fb				endm 
# End of macro FORTH_DSP_POP
43fb			 
43fb					FORTH_DSP_VALUEHL 
43fb cd b1 20			call macro_dsp_valuehl 
43fe				endm 
# End of macro FORTH_DSP_VALUEHL
43fe			 
43fe e5					push hl     ; start char 
43ff			 
43ff					FORTH_DSP_POP 
43ff cd 69 21			call macro_forth_dsp_pop 
4402				endm 
# End of macro FORTH_DSP_POP
4402			 
4402			 
4402					FORTH_DSP_VALUE 
4402 cd 9a 20			call macro_forth_dsp_value 
4405				endm 
# End of macro FORTH_DSP_VALUE
4405			 
4405 d1					pop de    ; get start post offset 
4406			 
4406 19					add hl, de    ; starting offset 
4407			 
4407 c1					pop bc 
4408 c5					push bc      ; grab size of string 
4409			 
4409 e5					push hl    ; save string start  
440a			 
440a 26 00				ld h, 0 
440c 69					ld l, c 
440d 23					inc hl 
440e 23					inc hl 
440f			 
440f cd 90 13				call malloc 
4412				if DEBUG_FORTH_MALLOC_GUARD 
4412 cc e2 54				call z,malloc_error 
4415				endif 
4415			 
4415 eb					ex de, hl      ; save malloc area for string copy 
4416 e1					pop hl    ; get back source 
4417 c1					pop bc    ; get length of string back 
4418			 
4418 d5					push de    ; save malloc area for after we push 
4419 ed b0				ldir     ; copy substr 
441b			 
441b			 
441b eb					ex de, hl 
441c 3e 00				ld a, 0 
441e 77					ld (hl), a   ; term substr 
441f			 
441f					 
441f e1					pop hl    ; get malloc so we can push it 
4420 e5					push hl   ; save so we can free it afterwards 
4421			 
4421 cd 28 1f				call forth_push_str 
4424			 
4424 e1					pop hl 
4425 cd 5a 14				call free 
4428			 
4428					 
4428					 
4428			 
4428			 
4428					NEXTW 
4428 c3 28 22			jp macro_next 
442b				endm 
# End of macro NEXTW
442b			 
442b			.LEFT: 
442b				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
442b 48				db WORD_SYS_CORE+52             
442c 53 44			dw .RIGHT            
442e 05				db 4 + 1 
442f .. 00			db "LEFT",0              
4434				endm 
# End of macro CWHEAD
4434			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4434					if DEBUG_FORTH_WORDS_KEY 
4434						DMARK "LEF" 
4434 f5				push af  
4435 3a 49 44			ld a, (.dmark)  
4438 32 b4 fe			ld (debug_mark),a  
443b 3a 4a 44			ld a, (.dmark+1)  
443e 32 b5 fe			ld (debug_mark+1),a  
4441 3a 4b 44			ld a, (.dmark+2)  
4444 32 b6 fe			ld (debug_mark+2),a  
4447 18 03			jr .pastdmark  
4449 ..			.dmark: db "LEF"  
444c f1			.pastdmark: pop af  
444d			endm  
# End of macro DMARK
444d						CALLMONITOR 
444d cd 46 18			call break_point_state  
4450				endm  
# End of macro CALLMONITOR
4450					endif 
4450			 
4450					NEXTW 
4450 c3 28 22			jp macro_next 
4453				endm 
# End of macro NEXTW
4453			.RIGHT: 
4453				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4453 48				db WORD_SYS_CORE+52             
4454 7c 44			dw .STR2NUM            
4456 06				db 5 + 1 
4457 .. 00			db "RIGHT",0              
445d				endm 
# End of macro CWHEAD
445d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
445d					if DEBUG_FORTH_WORDS_KEY 
445d						DMARK "RIG" 
445d f5				push af  
445e 3a 72 44			ld a, (.dmark)  
4461 32 b4 fe			ld (debug_mark),a  
4464 3a 73 44			ld a, (.dmark+1)  
4467 32 b5 fe			ld (debug_mark+1),a  
446a 3a 74 44			ld a, (.dmark+2)  
446d 32 b6 fe			ld (debug_mark+2),a  
4470 18 03			jr .pastdmark  
4472 ..			.dmark: db "RIG"  
4475 f1			.pastdmark: pop af  
4476			endm  
# End of macro DMARK
4476						CALLMONITOR 
4476 cd 46 18			call break_point_state  
4479				endm  
# End of macro CALLMONITOR
4479					endif 
4479			 
4479					NEXTW 
4479 c3 28 22			jp macro_next 
447c				endm 
# End of macro NEXTW
447c			 
447c			 
447c			.STR2NUM: 
447c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
447c 48				db WORD_SYS_CORE+52             
447d 08 45			dw .NUM2STR            
447f 08				db 7 + 1 
4480 .. 00			db "STR2NUM",0              
4488				endm 
# End of macro CWHEAD
4488			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4488			 
4488			 
4488			; TODO STR type check to do 
4488					if DEBUG_FORTH_WORDS_KEY 
4488						DMARK "S2N" 
4488 f5				push af  
4489 3a 9d 44			ld a, (.dmark)  
448c 32 b4 fe			ld (debug_mark),a  
448f 3a 9e 44			ld a, (.dmark+1)  
4492 32 b5 fe			ld (debug_mark+1),a  
4495 3a 9f 44			ld a, (.dmark+2)  
4498 32 b6 fe			ld (debug_mark+2),a  
449b 18 03			jr .pastdmark  
449d ..			.dmark: db "S2N"  
44a0 f1			.pastdmark: pop af  
44a1			endm  
# End of macro DMARK
44a1						CALLMONITOR 
44a1 cd 46 18			call break_point_state  
44a4				endm  
# End of macro CALLMONITOR
44a4					endif 
44a4			 
44a4					;FORTH_DSP 
44a4					FORTH_DSP_VALUE 
44a4 cd 9a 20			call macro_forth_dsp_value 
44a7				endm 
# End of macro FORTH_DSP_VALUE
44a7					;inc hl 
44a7			 
44a7 eb					ex de, hl 
44a8					if DEBUG_FORTH_WORDS 
44a8						DMARK "S2a" 
44a8 f5				push af  
44a9 3a bd 44			ld a, (.dmark)  
44ac 32 b4 fe			ld (debug_mark),a  
44af 3a be 44			ld a, (.dmark+1)  
44b2 32 b5 fe			ld (debug_mark+1),a  
44b5 3a bf 44			ld a, (.dmark+2)  
44b8 32 b6 fe			ld (debug_mark+2),a  
44bb 18 03			jr .pastdmark  
44bd ..			.dmark: db "S2a"  
44c0 f1			.pastdmark: pop af  
44c1			endm  
# End of macro DMARK
44c1						CALLMONITOR 
44c1 cd 46 18			call break_point_state  
44c4				endm  
# End of macro CALLMONITOR
44c4					endif 
44c4 cd be 12				call string_to_uint16 
44c7			 
44c7					if DEBUG_FORTH_WORDS 
44c7						DMARK "S2b" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 b4 fe			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 b5 fe			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 b6 fe			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "S2b"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0						CALLMONITOR 
44e0 cd 46 18			call break_point_state  
44e3				endm  
# End of macro CALLMONITOR
44e3					endif 
44e3			;		push hl 
44e3					FORTH_DSP_POP 
44e3 cd 69 21			call macro_forth_dsp_pop 
44e6				endm 
# End of macro FORTH_DSP_POP
44e6			;		pop hl 
44e6					 
44e6					if DEBUG_FORTH_WORDS 
44e6						DMARK "S2b" 
44e6 f5				push af  
44e7 3a fb 44			ld a, (.dmark)  
44ea 32 b4 fe			ld (debug_mark),a  
44ed 3a fc 44			ld a, (.dmark+1)  
44f0 32 b5 fe			ld (debug_mark+1),a  
44f3 3a fd 44			ld a, (.dmark+2)  
44f6 32 b6 fe			ld (debug_mark+2),a  
44f9 18 03			jr .pastdmark  
44fb ..			.dmark: db "S2b"  
44fe f1			.pastdmark: pop af  
44ff			endm  
# End of macro DMARK
44ff						CALLMONITOR 
44ff cd 46 18			call break_point_state  
4502				endm  
# End of macro CALLMONITOR
4502					endif 
4502 cd ba 1e				call forth_push_numhl	 
4505			 
4505				 
4505				       NEXTW 
4505 c3 28 22			jp macro_next 
4508				endm 
# End of macro NEXTW
4508			.NUM2STR: 
4508				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4508 48				db WORD_SYS_CORE+52             
4509 17 45			dw .CONCAT            
450b 08				db 7 + 1 
450c .. 00			db "NUM2STR",0              
4514				endm 
# End of macro CWHEAD
4514			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4514			 
4514			;		; malloc a string to target 
4514			;		ld hl, 10     ; TODO max string size should be fine 
4514			;		call malloc 
4514			;		push hl    ; save malloc location 
4514			; 
4514			; 
4514			;; TODO check int type 
4514			;		FORTH_DSP_VALUEHL 
4514			;		ld a, l 
4514			;		call DispAToASCII   
4514			;;TODO need to chage above call to dump into string 
4514			; 
4514			; 
4514			 
4514				       NEXTW 
4514 c3 28 22			jp macro_next 
4517				endm 
# End of macro NEXTW
4517			 
4517			.CONCAT: 
4517				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4517 48				db WORD_SYS_CORE+52             
4518 ca 45			dw .FIND            
451a 07				db 6 + 1 
451b .. 00			db "CONCAT",0              
4522				endm 
# End of macro CWHEAD
4522			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4522			 
4522			; TODO check string type 
4522			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4522			 
4522					if DEBUG_FORTH_WORDS_KEY 
4522						DMARK "CON" 
4522 f5				push af  
4523 3a 37 45			ld a, (.dmark)  
4526 32 b4 fe			ld (debug_mark),a  
4529 3a 38 45			ld a, (.dmark+1)  
452c 32 b5 fe			ld (debug_mark+1),a  
452f 3a 39 45			ld a, (.dmark+2)  
4532 32 b6 fe			ld (debug_mark+2),a  
4535 18 03			jr .pastdmark  
4537 ..			.dmark: db "CON"  
453a f1			.pastdmark: pop af  
453b			endm  
# End of macro DMARK
453b						CALLMONITOR 
453b cd 46 18			call break_point_state  
453e				endm  
# End of macro CALLMONITOR
453e					endif 
453e			 
453e			 
453e					FORTH_DSP_VALUE 
453e cd 9a 20			call macro_forth_dsp_value 
4541				endm 
# End of macro FORTH_DSP_VALUE
4541 e5					push hl   ; s2 
4542			 
4542					FORTH_DSP_POP 
4542 cd 69 21			call macro_forth_dsp_pop 
4545				endm 
# End of macro FORTH_DSP_POP
4545			 
4545					FORTH_DSP_VALUE 
4545 cd 9a 20			call macro_forth_dsp_value 
4548				endm 
# End of macro FORTH_DSP_VALUE
4548			 
4548 e5					push hl   ; s1 
4549			 
4549					FORTH_DSP_POP 
4549 cd 69 21			call macro_forth_dsp_pop 
454c				endm 
# End of macro FORTH_DSP_POP
454c					 
454c			 
454c					; copy s1 
454c			 
454c				 
454c					; save ptr 
454c e1					pop hl  
454d e5					push hl 
454e 3e 00				ld a, 0 
4550 cd 32 13				call strlent 
4553					;inc hl    ; zer0 
4553 06 00				ld b, 0 
4555 4d					ld c, l 
4556 e1					pop hl		 
4557 11 85 f3				ld de, scratch	 
455a					if DEBUG_FORTH_WORDS 
455a						DMARK "CO1" 
455a f5				push af  
455b 3a 6f 45			ld a, (.dmark)  
455e 32 b4 fe			ld (debug_mark),a  
4561 3a 70 45			ld a, (.dmark+1)  
4564 32 b5 fe			ld (debug_mark+1),a  
4567 3a 71 45			ld a, (.dmark+2)  
456a 32 b6 fe			ld (debug_mark+2),a  
456d 18 03			jr .pastdmark  
456f ..			.dmark: db "CO1"  
4572 f1			.pastdmark: pop af  
4573			endm  
# End of macro DMARK
4573						CALLMONITOR 
4573 cd 46 18			call break_point_state  
4576				endm  
# End of macro CALLMONITOR
4576					endif 
4576 ed b0				ldir 
4578			 
4578 e1					pop hl 
4579 e5					push hl 
457a d5					push de 
457b			 
457b			 
457b 3e 00				ld a, 0 
457d cd 32 13				call strlent 
4580 23					inc hl    ; zer0 
4581 23					inc hl 
4582 06 00				ld b, 0 
4584 4d					ld c, l 
4585 d1					pop de 
4586 e1					pop hl		 
4587					if DEBUG_FORTH_WORDS 
4587						DMARK "CO2" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 b4 fe			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 b5 fe			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 b6 fe			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "CO2"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0						CALLMONITOR 
45a0 cd 46 18			call break_point_state  
45a3				endm  
# End of macro CALLMONITOR
45a3					endif 
45a3 ed b0				ldir 
45a5			 
45a5			 
45a5			 
45a5 21 85 f3				ld hl, scratch 
45a8					if DEBUG_FORTH_WORDS 
45a8						DMARK "CO5" 
45a8 f5				push af  
45a9 3a bd 45			ld a, (.dmark)  
45ac 32 b4 fe			ld (debug_mark),a  
45af 3a be 45			ld a, (.dmark+1)  
45b2 32 b5 fe			ld (debug_mark+1),a  
45b5 3a bf 45			ld a, (.dmark+2)  
45b8 32 b6 fe			ld (debug_mark+2),a  
45bb 18 03			jr .pastdmark  
45bd ..			.dmark: db "CO5"  
45c0 f1			.pastdmark: pop af  
45c1			endm  
# End of macro DMARK
45c1						CALLMONITOR 
45c1 cd 46 18			call break_point_state  
45c4				endm  
# End of macro CALLMONITOR
45c4					endif 
45c4			 
45c4 cd 28 1f				call forth_push_str 
45c7			 
45c7			 
45c7			 
45c7			 
45c7				       NEXTW 
45c7 c3 28 22			jp macro_next 
45ca				endm 
# End of macro NEXTW
45ca			 
45ca			 
45ca			.FIND: 
45ca				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45ca 4b				db WORD_SYS_CORE+55             
45cb 88 46			dw .LEN            
45cd 05				db 4 + 1 
45ce .. 00			db "FIND",0              
45d3				endm 
# End of macro CWHEAD
45d3			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
45d3			 
45d3					if DEBUG_FORTH_WORDS_KEY 
45d3						DMARK "FND" 
45d3 f5				push af  
45d4 3a e8 45			ld a, (.dmark)  
45d7 32 b4 fe			ld (debug_mark),a  
45da 3a e9 45			ld a, (.dmark+1)  
45dd 32 b5 fe			ld (debug_mark+1),a  
45e0 3a ea 45			ld a, (.dmark+2)  
45e3 32 b6 fe			ld (debug_mark+2),a  
45e6 18 03			jr .pastdmark  
45e8 ..			.dmark: db "FND"  
45eb f1			.pastdmark: pop af  
45ec			endm  
# End of macro DMARK
45ec						CALLMONITOR 
45ec cd 46 18			call break_point_state  
45ef				endm  
# End of macro CALLMONITOR
45ef					endif 
45ef			 
45ef			; TODO check string type 
45ef					FORTH_DSP_VALUE 
45ef cd 9a 20			call macro_forth_dsp_value 
45f2				endm 
# End of macro FORTH_DSP_VALUE
45f2			 
45f2 e5					push hl    
45f3 7e					ld a,(hl)    ; char to find   
45f4			; TODO change char to substr 
45f4			 
45f4 f5					push af 
45f5					 
45f5			 
45f5			 
45f5					if DEBUG_FORTH_WORDS 
45f5						DMARK "FN1" 
45f5 f5				push af  
45f6 3a 0a 46			ld a, (.dmark)  
45f9 32 b4 fe			ld (debug_mark),a  
45fc 3a 0b 46			ld a, (.dmark+1)  
45ff 32 b5 fe			ld (debug_mark+1),a  
4602 3a 0c 46			ld a, (.dmark+2)  
4605 32 b6 fe			ld (debug_mark+2),a  
4608 18 03			jr .pastdmark  
460a ..			.dmark: db "FN1"  
460d f1			.pastdmark: pop af  
460e			endm  
# End of macro DMARK
460e						CALLMONITOR 
460e cd 46 18			call break_point_state  
4611				endm  
# End of macro CALLMONITOR
4611					endif 
4611			 
4611					FORTH_DSP_POP 
4611 cd 69 21			call macro_forth_dsp_pop 
4614				endm 
# End of macro FORTH_DSP_POP
4614			 
4614					; string to search 
4614			 
4614					FORTH_DSP_VALUE 
4614 cd 9a 20			call macro_forth_dsp_value 
4617				endm 
# End of macro FORTH_DSP_VALUE
4617			 
4617 d1					pop de  ; d is char to find  
4618			 
4618					if DEBUG_FORTH_WORDS 
4618						DMARK "FN2" 
4618 f5				push af  
4619 3a 2d 46			ld a, (.dmark)  
461c 32 b4 fe			ld (debug_mark),a  
461f 3a 2e 46			ld a, (.dmark+1)  
4622 32 b5 fe			ld (debug_mark+1),a  
4625 3a 2f 46			ld a, (.dmark+2)  
4628 32 b6 fe			ld (debug_mark+2),a  
462b 18 03			jr .pastdmark  
462d ..			.dmark: db "FN2"  
4630 f1			.pastdmark: pop af  
4631			endm  
# End of macro DMARK
4631						CALLMONITOR 
4631 cd 46 18			call break_point_state  
4634				endm  
# End of macro CALLMONITOR
4634					endif 
4634					 
4634 01 00 00				ld bc, 0 
4637 7e			.findchar:      ld a,(hl) 
4638 fe 00				cp 0   		 
463a 28 27				jr z, .finddone     
463c ba					cp d 
463d 28 20				jr z, .foundchar 
463f 03					inc bc 
4640 23					inc hl 
4641					if DEBUG_FORTH_WORDS 
4641						DMARK "FN3" 
4641 f5				push af  
4642 3a 56 46			ld a, (.dmark)  
4645 32 b4 fe			ld (debug_mark),a  
4648 3a 57 46			ld a, (.dmark+1)  
464b 32 b5 fe			ld (debug_mark+1),a  
464e 3a 58 46			ld a, (.dmark+2)  
4651 32 b6 fe			ld (debug_mark+2),a  
4654 18 03			jr .pastdmark  
4656 ..			.dmark: db "FN3"  
4659 f1			.pastdmark: pop af  
465a			endm  
# End of macro DMARK
465a						CALLMONITOR 
465a cd 46 18			call break_point_state  
465d				endm  
# End of macro CALLMONITOR
465d					endif 
465d 18 d8				jr .findchar 
465f			 
465f			 
465f c5			.foundchar:	push bc 
4660 e1					pop hl 
4661 18 03				jr .findexit 
4663			 
4663			 
4663							 
4663			 
4663			.finddone:     ; got to end of string with no find 
4663 21 00 00				ld hl, 0 
4666			.findexit: 
4666			 
4666					if DEBUG_FORTH_WORDS 
4666						DMARK "FNd" 
4666 f5				push af  
4667 3a 7b 46			ld a, (.dmark)  
466a 32 b4 fe			ld (debug_mark),a  
466d 3a 7c 46			ld a, (.dmark+1)  
4670 32 b5 fe			ld (debug_mark+1),a  
4673 3a 7d 46			ld a, (.dmark+2)  
4676 32 b6 fe			ld (debug_mark+2),a  
4679 18 03			jr .pastdmark  
467b ..			.dmark: db "FNd"  
467e f1			.pastdmark: pop af  
467f			endm  
# End of macro DMARK
467f						CALLMONITOR 
467f cd 46 18			call break_point_state  
4682				endm  
# End of macro CALLMONITOR
4682					endif 
4682 cd ba 1e			call forth_push_numhl 
4685			 
4685				       NEXTW 
4685 c3 28 22			jp macro_next 
4688				endm 
# End of macro NEXTW
4688			 
4688			.LEN: 
4688				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4688 4c				db WORD_SYS_CORE+56             
4689 f2 46			dw .CHAR            
468b 06				db 5 + 1 
468c .. 00			db "COUNT",0              
4692				endm 
# End of macro CWHEAD
4692			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4692			 
4692					if DEBUG_FORTH_WORDS_KEY 
4692						DMARK "CNT" 
4692 f5				push af  
4693 3a a7 46			ld a, (.dmark)  
4696 32 b4 fe			ld (debug_mark),a  
4699 3a a8 46			ld a, (.dmark+1)  
469c 32 b5 fe			ld (debug_mark+1),a  
469f 3a a9 46			ld a, (.dmark+2)  
46a2 32 b6 fe			ld (debug_mark+2),a  
46a5 18 03			jr .pastdmark  
46a7 ..			.dmark: db "CNT"  
46aa f1			.pastdmark: pop af  
46ab			endm  
# End of macro DMARK
46ab						CALLMONITOR 
46ab cd 46 18			call break_point_state  
46ae				endm  
# End of macro CALLMONITOR
46ae					endif 
46ae			; TODO check string type 
46ae					FORTH_DSP_VALUE 
46ae cd 9a 20			call macro_forth_dsp_value 
46b1				endm 
# End of macro FORTH_DSP_VALUE
46b1			 
46b1			 
46b1					if DEBUG_FORTH_WORDS 
46b1						DMARK "CN?" 
46b1 f5				push af  
46b2 3a c6 46			ld a, (.dmark)  
46b5 32 b4 fe			ld (debug_mark),a  
46b8 3a c7 46			ld a, (.dmark+1)  
46bb 32 b5 fe			ld (debug_mark+1),a  
46be 3a c8 46			ld a, (.dmark+2)  
46c1 32 b6 fe			ld (debug_mark+2),a  
46c4 18 03			jr .pastdmark  
46c6 ..			.dmark: db "CN?"  
46c9 f1			.pastdmark: pop af  
46ca			endm  
# End of macro DMARK
46ca						CALLMONITOR 
46ca cd 46 18			call break_point_state  
46cd				endm  
# End of macro CALLMONITOR
46cd					endif 
46cd cd 27 13				call strlenz 
46d0					if DEBUG_FORTH_WORDS 
46d0						DMARK "CNl" 
46d0 f5				push af  
46d1 3a e5 46			ld a, (.dmark)  
46d4 32 b4 fe			ld (debug_mark),a  
46d7 3a e6 46			ld a, (.dmark+1)  
46da 32 b5 fe			ld (debug_mark+1),a  
46dd 3a e7 46			ld a, (.dmark+2)  
46e0 32 b6 fe			ld (debug_mark+2),a  
46e3 18 03			jr .pastdmark  
46e5 ..			.dmark: db "CNl"  
46e8 f1			.pastdmark: pop af  
46e9			endm  
# End of macro DMARK
46e9						CALLMONITOR 
46e9 cd 46 18			call break_point_state  
46ec				endm  
# End of macro CALLMONITOR
46ec					endif 
46ec			 
46ec cd ba 1e				call forth_push_numhl 
46ef			 
46ef			 
46ef			 
46ef				       NEXTW 
46ef c3 28 22			jp macro_next 
46f2				endm 
# End of macro NEXTW
46f2			.CHAR: 
46f2				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
46f2 4d				db WORD_SYS_CORE+57             
46f3 28 47			dw .ENDSTR            
46f5 05				db 4 + 1 
46f6 .. 00			db "CHAR",0              
46fb				endm 
# End of macro CWHEAD
46fb			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
46fb					if DEBUG_FORTH_WORDS_KEY 
46fb						DMARK "CHR" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 b4 fe			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 b5 fe			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 b6 fe			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "CHR"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 46 18			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717					FORTH_DSP 
4717 cd 77 20			call macro_forth_dsp 
471a				endm 
# End of macro FORTH_DSP
471a					;v5 FORTH_DSP_VALUE 
471a 23					inc hl      ; now at start of numeric as string 
471b			 
471b			;		push hl 
471b			 
471b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
471b cd 69 21			call macro_forth_dsp_pop 
471e				endm 
# End of macro FORTH_DSP_POP
471e			 
471e			;		pop hl 
471e			 
471e					; push the content of a onto the stack as a value 
471e			 
471e 7e					ld a,(hl)   ; get char 
471f 26 00				ld h,0 
4721 6f					ld l,a 
4722 cd ba 1e				call forth_push_numhl 
4725			 
4725				       NEXTW 
4725 c3 28 22			jp macro_next 
4728				endm 
# End of macro NEXTW
4728			 
4728			 
4728			 
4728			 
4728			.ENDSTR: 
4728			; eof 
4728			 
# End of file forth_words_str.asm
4728			include "forth_words_key.asm" 
4728			 
4728			; | ## Keyboard Words 
4728			 
4728			.KEY: 
4728				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4728 3e				db WORD_SYS_CORE+42             
4729 58 47			dw .WAITK            
472b 04				db 3 + 1 
472c .. 00			db "KEY",0              
4730				endm 
# End of macro CWHEAD
4730			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4730			 
4730					if DEBUG_FORTH_WORDS_KEY 
4730						DMARK "KEY" 
4730 f5				push af  
4731 3a 45 47			ld a, (.dmark)  
4734 32 b4 fe			ld (debug_mark),a  
4737 3a 46 47			ld a, (.dmark+1)  
473a 32 b5 fe			ld (debug_mark+1),a  
473d 3a 47 47			ld a, (.dmark+2)  
4740 32 b6 fe			ld (debug_mark+2),a  
4743 18 03			jr .pastdmark  
4745 ..			.dmark: db "KEY"  
4748 f1			.pastdmark: pop af  
4749			endm  
# End of macro DMARK
4749						CALLMONITOR 
4749 cd 46 18			call break_point_state  
474c				endm  
# End of macro CALLMONITOR
474c					endif 
474c			; TODO currently waits 
474c cd c9 6a				call cin 
474f					;call cin_wait 
474f 6f					ld l, a 
4750 26 00				ld h, 0 
4752 cd ba 1e				call forth_push_numhl 
4755					NEXTW 
4755 c3 28 22			jp macro_next 
4758				endm 
# End of macro NEXTW
4758			.WAITK: 
4758				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4758 3f				db WORD_SYS_CORE+43             
4759 8a 47			dw .ACCEPT            
475b 06				db 5 + 1 
475c .. 00			db "WAITK",0              
4762				endm 
# End of macro CWHEAD
4762			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4762					if DEBUG_FORTH_WORDS_KEY 
4762						DMARK "WAI" 
4762 f5				push af  
4763 3a 77 47			ld a, (.dmark)  
4766 32 b4 fe			ld (debug_mark),a  
4769 3a 78 47			ld a, (.dmark+1)  
476c 32 b5 fe			ld (debug_mark+1),a  
476f 3a 79 47			ld a, (.dmark+2)  
4772 32 b6 fe			ld (debug_mark+2),a  
4775 18 03			jr .pastdmark  
4777 ..			.dmark: db "WAI"  
477a f1			.pastdmark: pop af  
477b			endm  
# End of macro DMARK
477b						CALLMONITOR 
477b cd 46 18			call break_point_state  
477e				endm  
# End of macro CALLMONITOR
477e					endif 
477e cd b8 6a				call cin_wait 
4781 6f					ld l, a 
4782 26 00				ld h, 0 
4784 cd ba 1e				call forth_push_numhl 
4787					NEXTW 
4787 c3 28 22			jp macro_next 
478a				endm 
# End of macro NEXTW
478a			.ACCEPT: 
478a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
478a 40				db WORD_SYS_CORE+44             
478b e8 47			dw .EDIT            
478d 07				db 6 + 1 
478e .. 00			db "ACCEPT",0              
4795				endm 
# End of macro CWHEAD
4795			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4795					; TODO crashes on push 
4795					if DEBUG_FORTH_WORDS_KEY 
4795						DMARK "ACC" 
4795 f5				push af  
4796 3a aa 47			ld a, (.dmark)  
4799 32 b4 fe			ld (debug_mark),a  
479c 3a ab 47			ld a, (.dmark+1)  
479f 32 b5 fe			ld (debug_mark+1),a  
47a2 3a ac 47			ld a, (.dmark+2)  
47a5 32 b6 fe			ld (debug_mark+2),a  
47a8 18 03			jr .pastdmark  
47aa ..			.dmark: db "ACC"  
47ad f1			.pastdmark: pop af  
47ae			endm  
# End of macro DMARK
47ae						CALLMONITOR 
47ae cd 46 18			call break_point_state  
47b1				endm  
# End of macro CALLMONITOR
47b1					endif 
47b1 21 83 f5				ld hl, os_input 
47b4 3e 00				ld a, 0 
47b6 77					ld (hl),a 
47b7 3a ee fb				ld a,(f_cursor_ptr) 
47ba 16 64				ld d, 100 
47bc 0e 00				ld c, 0 
47be 1e 28				ld e, 40 
47c0 cd f6 0e				call input_str 
47c3					; TODO perhaps do a type check and wrap in quotes if not a number 
47c3 21 83 f5				ld hl, os_input 
47c6					if DEBUG_FORTH_WORDS 
47c6						DMARK "AC1" 
47c6 f5				push af  
47c7 3a db 47			ld a, (.dmark)  
47ca 32 b4 fe			ld (debug_mark),a  
47cd 3a dc 47			ld a, (.dmark+1)  
47d0 32 b5 fe			ld (debug_mark+1),a  
47d3 3a dd 47			ld a, (.dmark+2)  
47d6 32 b6 fe			ld (debug_mark+2),a  
47d9 18 03			jr .pastdmark  
47db ..			.dmark: db "AC1"  
47de f1			.pastdmark: pop af  
47df			endm  
# End of macro DMARK
47df						CALLMONITOR 
47df cd 46 18			call break_point_state  
47e2				endm  
# End of macro CALLMONITOR
47e2					endif 
47e2 cd 28 1f				call forth_push_str 
47e5					NEXTW 
47e5 c3 28 22			jp macro_next 
47e8				endm 
# End of macro NEXTW
47e8			 
47e8			.EDIT: 
47e8				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
47e8 40				db WORD_SYS_CORE+44             
47e9 8a 48			dw .ENDKEY            
47eb 05				db 4 + 1 
47ec .. 00			db "EDIT",0              
47f1				endm 
# End of macro CWHEAD
47f1			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
47f1			 
47f1					; TODO does not copy from stack 
47f1					if DEBUG_FORTH_WORDS_KEY 
47f1						DMARK "EDT" 
47f1 f5				push af  
47f2 3a 06 48			ld a, (.dmark)  
47f5 32 b4 fe			ld (debug_mark),a  
47f8 3a 07 48			ld a, (.dmark+1)  
47fb 32 b5 fe			ld (debug_mark+1),a  
47fe 3a 08 48			ld a, (.dmark+2)  
4801 32 b6 fe			ld (debug_mark+2),a  
4804 18 03			jr .pastdmark  
4806 ..			.dmark: db "EDT"  
4809 f1			.pastdmark: pop af  
480a			endm  
# End of macro DMARK
480a						CALLMONITOR 
480a cd 46 18			call break_point_state  
480d				endm  
# End of macro CALLMONITOR
480d					endif 
480d			 
480d					;FORTH_DSP 
480d					FORTH_DSP_VALUEHL 
480d cd b1 20			call macro_dsp_valuehl 
4810				endm 
# End of macro FORTH_DSP_VALUEHL
4810			;		inc hl    ; TODO do type check 
4810			 
4810			;		call get_word_hl 
4810 e5					push hl 
4811					if DEBUG_FORTH_WORDS 
4811						DMARK "EDp" 
4811 f5				push af  
4812 3a 26 48			ld a, (.dmark)  
4815 32 b4 fe			ld (debug_mark),a  
4818 3a 27 48			ld a, (.dmark+1)  
481b 32 b5 fe			ld (debug_mark+1),a  
481e 3a 28 48			ld a, (.dmark+2)  
4821 32 b6 fe			ld (debug_mark+2),a  
4824 18 03			jr .pastdmark  
4826 ..			.dmark: db "EDp"  
4829 f1			.pastdmark: pop af  
482a			endm  
# End of macro DMARK
482a						CALLMONITOR 
482a cd 46 18			call break_point_state  
482d				endm  
# End of macro CALLMONITOR
482d					endif 
482d				;	ld a, 0 
482d cd 27 13				call strlenz 
4830 23					inc hl 
4831			 
4831 06 00				ld b, 0 
4833 4d					ld c, l 
4834			 
4834 e1					pop hl 
4835 11 83 f5				ld de, os_input 
4838					if DEBUG_FORTH_WORDS_KEY 
4838						DMARK "EDc" 
4838 f5				push af  
4839 3a 4d 48			ld a, (.dmark)  
483c 32 b4 fe			ld (debug_mark),a  
483f 3a 4e 48			ld a, (.dmark+1)  
4842 32 b5 fe			ld (debug_mark+1),a  
4845 3a 4f 48			ld a, (.dmark+2)  
4848 32 b6 fe			ld (debug_mark+2),a  
484b 18 03			jr .pastdmark  
484d ..			.dmark: db "EDc"  
4850 f1			.pastdmark: pop af  
4851			endm  
# End of macro DMARK
4851						CALLMONITOR 
4851 cd 46 18			call break_point_state  
4854				endm  
# End of macro CALLMONITOR
4854					endif 
4854 ed b0				ldir 
4856			 
4856			 
4856 21 83 f5				ld hl, os_input 
4859					;ld a, 0 
4859					;ld (hl),a 
4859 3a ee fb				ld a,(f_cursor_ptr) 
485c 16 64				ld d, 100 
485e 0e 00				ld c, 0 
4860 1e 28				ld e, 40 
4862 cd f6 0e				call input_str 
4865					; TODO perhaps do a type check and wrap in quotes if not a number 
4865 21 83 f5				ld hl, os_input 
4868					if DEBUG_FORTH_WORDS 
4868						DMARK "ED1" 
4868 f5				push af  
4869 3a 7d 48			ld a, (.dmark)  
486c 32 b4 fe			ld (debug_mark),a  
486f 3a 7e 48			ld a, (.dmark+1)  
4872 32 b5 fe			ld (debug_mark+1),a  
4875 3a 7f 48			ld a, (.dmark+2)  
4878 32 b6 fe			ld (debug_mark+2),a  
487b 18 03			jr .pastdmark  
487d ..			.dmark: db "ED1"  
4880 f1			.pastdmark: pop af  
4881			endm  
# End of macro DMARK
4881						CALLMONITOR 
4881 cd 46 18			call break_point_state  
4884				endm  
# End of macro CALLMONITOR
4884					endif 
4884 cd 28 1f				call forth_push_str 
4887					NEXTW 
4887 c3 28 22			jp macro_next 
488a				endm 
# End of macro NEXTW
488a			 
488a			 
488a			 
488a			.ENDKEY: 
488a			; eof 
488a			 
# End of file forth_words_key.asm
488a			 
488a			if STORAGE_SE 
488a			   	include "forth_words_storage.asm" 
488a			 
488a			; | ## Fixed Storage Words 
488a			 
488a			.RECORD: 
488a			  
488a				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
488a 3a				db WORD_SYS_CORE+38             
488b 2e 49			dw .BREAD            
488d 07				db 6 + 1 
488e .. 00			db "RECORD",0              
4895				endm 
# End of macro CWHEAD
4895			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4895			 
4895					if DEBUG_FORTH_WORDS_KEY 
4895						DMARK "REC" 
4895 f5				push af  
4896 3a aa 48			ld a, (.dmark)  
4899 32 b4 fe			ld (debug_mark),a  
489c 3a ab 48			ld a, (.dmark+1)  
489f 32 b5 fe			ld (debug_mark+1),a  
48a2 3a ac 48			ld a, (.dmark+2)  
48a5 32 b6 fe			ld (debug_mark+2),a  
48a8 18 03			jr .pastdmark  
48aa ..			.dmark: db "REC"  
48ad f1			.pastdmark: pop af  
48ae			endm  
# End of macro DMARK
48ae						CALLMONITOR 
48ae cd 46 18			call break_point_state  
48b1				endm  
# End of macro CALLMONITOR
48b1					endif 
48b1			 
48b1					FORTH_DSP_VALUEHL 
48b1 cd b1 20			call macro_dsp_valuehl 
48b4				endm 
# End of macro FORTH_DSP_VALUEHL
48b4			 
48b4 e5					push hl    ; id 
48b5			 
48b5					FORTH_DSP_POP 
48b5 cd 69 21			call macro_forth_dsp_pop 
48b8				endm 
# End of macro FORTH_DSP_POP
48b8			 
48b8					FORTH_DSP_VALUEHL 
48b8 cd b1 20			call macro_dsp_valuehl 
48bb				endm 
# End of macro FORTH_DSP_VALUEHL
48bb			 
48bb					FORTH_DSP_POP 
48bb cd 69 21			call macro_forth_dsp_pop 
48be				endm 
# End of macro FORTH_DSP_POP
48be			 
48be d1					pop de     ; get file id 
48bf			 
48bf					; e = file id 
48bf					; l = file extent 
48bf			 
48bf			 
48bf					; construct request to access file extent 
48bf			 
48bf			;		ld a, e 
48bf 63					ld h, e 
48c0					 
48c0					 
48c0					 
48c0			 
48c0					; e has id 
48c0			 
48c0 11 07 fc			ld de, store_page 
48c3					if DEBUG_FORTH_WORDS 
48c3						DMARK "REr" 
48c3 f5				push af  
48c4 3a d8 48			ld a, (.dmark)  
48c7 32 b4 fe			ld (debug_mark),a  
48ca 3a d9 48			ld a, (.dmark+1)  
48cd 32 b5 fe			ld (debug_mark+1),a  
48d0 3a da 48			ld a, (.dmark+2)  
48d3 32 b6 fe			ld (debug_mark+2),a  
48d6 18 03			jr .pastdmark  
48d8 ..			.dmark: db "REr"  
48db f1			.pastdmark: pop af  
48dc			endm  
# End of macro DMARK
48dc						CALLMONITOR 
48dc cd 46 18			call break_point_state  
48df				endm  
# End of macro CALLMONITOR
48df					endif 
48df cd 2a 09				call storage_read 
48e2 cd f2 0e			call ishlzero 
48e5 28 22			jr z, .recnotfound 
48e7			 
48e7			 
48e7					if DEBUG_FORTH_WORDS 
48e7						DMARK "REe" 
48e7 f5				push af  
48e8 3a fc 48			ld a, (.dmark)  
48eb 32 b4 fe			ld (debug_mark),a  
48ee 3a fd 48			ld a, (.dmark+1)  
48f1 32 b5 fe			ld (debug_mark+1),a  
48f4 3a fe 48			ld a, (.dmark+2)  
48f7 32 b6 fe			ld (debug_mark+2),a  
48fa 18 03			jr .pastdmark  
48fc ..			.dmark: db "REe"  
48ff f1			.pastdmark: pop af  
4900			endm  
# End of macro DMARK
4900						CALLMONITOR 
4900 cd 46 18			call break_point_state  
4903				endm  
# End of macro CALLMONITOR
4903					endif 
4903 cd 28 1f			call forth_push_str 
4906			 
4906					NEXTW 
4906 c3 28 22			jp macro_next 
4909				endm 
# End of macro NEXTW
4909			 
4909			.recnotfound: 
4909					if DEBUG_FORTH_WORDS 
4909						DMARK "REf" 
4909 f5				push af  
490a 3a 1e 49			ld a, (.dmark)  
490d 32 b4 fe			ld (debug_mark),a  
4910 3a 1f 49			ld a, (.dmark+1)  
4913 32 b5 fe			ld (debug_mark+1),a  
4916 3a 20 49			ld a, (.dmark+2)  
4919 32 b6 fe			ld (debug_mark+2),a  
491c 18 03			jr .pastdmark  
491e ..			.dmark: db "REf"  
4921 f1			.pastdmark: pop af  
4922			endm  
# End of macro DMARK
4922						CALLMONITOR 
4922 cd 46 18			call break_point_state  
4925				endm  
# End of macro CALLMONITOR
4925					endif 
4925 21 ff 00			ld hl, 255 
4928 cd ba 1e			call forth_push_numhl 
492b				NEXTW 
492b c3 28 22			jp macro_next 
492e				endm 
# End of macro NEXTW
492e			 
492e			 
492e			.BREAD: 
492e			  
492e				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
492e 3a				db WORD_SYS_CORE+38             
492f b1 49			dw .BWRITE            
4931 06				db 5 + 1 
4932 .. 00			db "BREAD",0              
4938				endm 
# End of macro CWHEAD
4938			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4938				 
4938					if DEBUG_FORTH_WORDS_KEY 
4938						DMARK "BRD" 
4938 f5				push af  
4939 3a 4d 49			ld a, (.dmark)  
493c 32 b4 fe			ld (debug_mark),a  
493f 3a 4e 49			ld a, (.dmark+1)  
4942 32 b5 fe			ld (debug_mark+1),a  
4945 3a 4f 49			ld a, (.dmark+2)  
4948 32 b6 fe			ld (debug_mark+2),a  
494b 18 03			jr .pastdmark  
494d ..			.dmark: db "BRD"  
4950 f1			.pastdmark: pop af  
4951			endm  
# End of macro DMARK
4951						CALLMONITOR 
4951 cd 46 18			call break_point_state  
4954				endm  
# End of macro CALLMONITOR
4954					endif 
4954			 
4954				FORTH_DSP_VALUEHL 
4954 cd b1 20			call macro_dsp_valuehl 
4957				endm 
# End of macro FORTH_DSP_VALUEHL
4957			 
4957				FORTH_DSP_POP 
4957 cd 69 21			call macro_forth_dsp_pop 
495a				endm 
# End of macro FORTH_DSP_POP
495a			 
495a				; calc block address 
495a			 
495a eb				ex de, hl 
495b 3e 40			ld a, STORE_BLOCK_PHY 
495d cd 4c 0e			call Mult16 
4960			 
4960			 
4960 11 07 fc			ld de, store_page 
4963			 
4963					if DEBUG_FORTH_WORDS 
4963						DMARK "BR1" 
4963 f5				push af  
4964 3a 78 49			ld a, (.dmark)  
4967 32 b4 fe			ld (debug_mark),a  
496a 3a 79 49			ld a, (.dmark+1)  
496d 32 b5 fe			ld (debug_mark+1),a  
4970 3a 7a 49			ld a, (.dmark+2)  
4973 32 b6 fe			ld (debug_mark+2),a  
4976 18 03			jr .pastdmark  
4978 ..			.dmark: db "BR1"  
497b f1			.pastdmark: pop af  
497c			endm  
# End of macro DMARK
497c						CALLMONITOR 
497c cd 46 18			call break_point_state  
497f				endm  
# End of macro CALLMONITOR
497f					endif 
497f			 
497f cd d1 03			call storage_read_block 
4982			 
4982 cd f2 0e			call ishlzero 
4985 20 05			jr nz, .brfound 
4987			 
4987 cd ba 1e			call forth_push_numhl 
498a 18 22			jr .brdone 
498c			 
498c			 
498c			.brfound: 
498c 21 09 fc		        ld hl, store_page+2 
498f			 
498f					if DEBUG_FORTH_WORDS 
498f						DMARK "BR2" 
498f f5				push af  
4990 3a a4 49			ld a, (.dmark)  
4993 32 b4 fe			ld (debug_mark),a  
4996 3a a5 49			ld a, (.dmark+1)  
4999 32 b5 fe			ld (debug_mark+1),a  
499c 3a a6 49			ld a, (.dmark+2)  
499f 32 b6 fe			ld (debug_mark+2),a  
49a2 18 03			jr .pastdmark  
49a4 ..			.dmark: db "BR2"  
49a7 f1			.pastdmark: pop af  
49a8			endm  
# End of macro DMARK
49a8						CALLMONITOR 
49a8 cd 46 18			call break_point_state  
49ab				endm  
# End of macro CALLMONITOR
49ab					endif 
49ab			 
49ab cd 28 1f			call forth_push_str 
49ae			 
49ae			 
49ae			.brdone: 
49ae			 
49ae					NEXTW 
49ae c3 28 22			jp macro_next 
49b1				endm 
# End of macro NEXTW
49b1			.BWRITE: 
49b1				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
49b1 3a				db WORD_SYS_CORE+38             
49b2 46 4a			dw .BUPD            
49b4 07				db 6 + 1 
49b5 .. 00			db "BWRITE",0              
49bc				endm 
# End of macro CWHEAD
49bc			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
49bc			 
49bc					if DEBUG_FORTH_WORDS_KEY 
49bc						DMARK "BWR" 
49bc f5				push af  
49bd 3a d1 49			ld a, (.dmark)  
49c0 32 b4 fe			ld (debug_mark),a  
49c3 3a d2 49			ld a, (.dmark+1)  
49c6 32 b5 fe			ld (debug_mark+1),a  
49c9 3a d3 49			ld a, (.dmark+2)  
49cc 32 b6 fe			ld (debug_mark+2),a  
49cf 18 03			jr .pastdmark  
49d1 ..			.dmark: db "BWR"  
49d4 f1			.pastdmark: pop af  
49d5			endm  
# End of macro DMARK
49d5						CALLMONITOR 
49d5 cd 46 18			call break_point_state  
49d8				endm  
# End of macro CALLMONITOR
49d8					endif 
49d8			 
49d8				FORTH_DSP_VALUEHL 
49d8 cd b1 20			call macro_dsp_valuehl 
49db				endm 
# End of macro FORTH_DSP_VALUEHL
49db			 
49db				; calc block address 
49db			 
49db eb				ex de, hl 
49dc 3e 40			ld a, STORE_BLOCK_PHY 
49de cd 4c 0e			call Mult16 
49e1			 
49e1 e5				push hl         ; address 
49e2			 
49e2				FORTH_DSP_POP 
49e2 cd 69 21			call macro_forth_dsp_pop 
49e5				endm 
# End of macro FORTH_DSP_POP
49e5			 
49e5				FORTH_DSP_VALUEHL 
49e5 cd b1 20			call macro_dsp_valuehl 
49e8				endm 
# End of macro FORTH_DSP_VALUEHL
49e8			 
49e8				FORTH_DSP_POP 
49e8 cd 69 21			call macro_forth_dsp_pop 
49eb				endm 
# End of macro FORTH_DSP_POP
49eb			 
49eb cd d5 0b			call storage_clear_page 
49ee			 
49ee				; copy string to store page 
49ee			 
49ee e5				push hl     ; save string address 
49ef			 
49ef 3e 00			ld a, 0 
49f1 cd 32 13			call strlent 
49f4			 
49f4 23				inc hl 
49f5			 
49f5 4d				ld c, l 
49f6 06 00			ld b, 0 
49f8			 
49f8 e1				pop hl 
49f9 11 09 fc			ld de, store_page + 2 
49fc					if DEBUG_FORTH_WORDS 
49fc						DMARK "BW1" 
49fc f5				push af  
49fd 3a 11 4a			ld a, (.dmark)  
4a00 32 b4 fe			ld (debug_mark),a  
4a03 3a 12 4a			ld a, (.dmark+1)  
4a06 32 b5 fe			ld (debug_mark+1),a  
4a09 3a 13 4a			ld a, (.dmark+2)  
4a0c 32 b6 fe			ld (debug_mark+2),a  
4a0f 18 03			jr .pastdmark  
4a11 ..			.dmark: db "BW1"  
4a14 f1			.pastdmark: pop af  
4a15			endm  
# End of macro DMARK
4a15						CALLMONITOR 
4a15 cd 46 18			call break_point_state  
4a18				endm  
# End of macro CALLMONITOR
4a18					endif 
4a18 ed b0			ldir 
4a1a			 
4a1a			 
4a1a				; poke the start of the block with flags to prevent high level file ops hitting the block 
4a1a			 
4a1a 21 ff ff			ld hl, $ffff 
4a1d			 
4a1d 22 07 fc			ld (store_page), hl	 
4a20				 
4a20 e1				pop hl    ; get address 
4a21 11 07 fc			ld de, store_page 
4a24			 
4a24					if DEBUG_FORTH_WORDS 
4a24						DMARK "BW2" 
4a24 f5				push af  
4a25 3a 39 4a			ld a, (.dmark)  
4a28 32 b4 fe			ld (debug_mark),a  
4a2b 3a 3a 4a			ld a, (.dmark+1)  
4a2e 32 b5 fe			ld (debug_mark+1),a  
4a31 3a 3b 4a			ld a, (.dmark+2)  
4a34 32 b6 fe			ld (debug_mark+2),a  
4a37 18 03			jr .pastdmark  
4a39 ..			.dmark: db "BW2"  
4a3c f1			.pastdmark: pop af  
4a3d			endm  
# End of macro DMARK
4a3d						CALLMONITOR 
4a3d cd 46 18			call break_point_state  
4a40				endm  
# End of macro CALLMONITOR
4a40					endif 
4a40			 
4a40 cd 36 04			call storage_write_block 
4a43			 
4a43					NEXTW 
4a43 c3 28 22			jp macro_next 
4a46				endm 
# End of macro NEXTW
4a46			 
4a46			.BUPD: 
4a46				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4a46 3a				db WORD_SYS_CORE+38             
4a47 9c 4a			dw .BYID            
4a49 05				db 4 + 1 
4a4a .. 00			db "BUPD",0              
4a4f				endm 
# End of macro CWHEAD
4a4f			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4a4f			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4a4f			; | | or completely different file system structure. 
4a4f			 
4a4f					if DEBUG_FORTH_WORDS_KEY 
4a4f						DMARK "BUD" 
4a4f f5				push af  
4a50 3a 64 4a			ld a, (.dmark)  
4a53 32 b4 fe			ld (debug_mark),a  
4a56 3a 65 4a			ld a, (.dmark+1)  
4a59 32 b5 fe			ld (debug_mark+1),a  
4a5c 3a 66 4a			ld a, (.dmark+2)  
4a5f 32 b6 fe			ld (debug_mark+2),a  
4a62 18 03			jr .pastdmark  
4a64 ..			.dmark: db "BUD"  
4a67 f1			.pastdmark: pop af  
4a68			endm  
# End of macro DMARK
4a68						CALLMONITOR 
4a68 cd 46 18			call break_point_state  
4a6b				endm  
# End of macro CALLMONITOR
4a6b					endif 
4a6b			 
4a6b				FORTH_DSP_VALUEHL 
4a6b cd b1 20			call macro_dsp_valuehl 
4a6e				endm 
# End of macro FORTH_DSP_VALUEHL
4a6e			 
4a6e				; calc block address 
4a6e			 
4a6e eb				ex de, hl 
4a6f 3e 40			ld a, STORE_BLOCK_PHY 
4a71 cd 4c 0e			call Mult16 
4a74			 
4a74				FORTH_DSP_POP 
4a74 cd 69 21			call macro_forth_dsp_pop 
4a77				endm 
# End of macro FORTH_DSP_POP
4a77			 
4a77			 
4a77 11 07 fc			ld de, store_page 
4a7a			 
4a7a					if DEBUG_FORTH_WORDS 
4a7a						DMARK "BUe" 
4a7a f5				push af  
4a7b 3a 8f 4a			ld a, (.dmark)  
4a7e 32 b4 fe			ld (debug_mark),a  
4a81 3a 90 4a			ld a, (.dmark+1)  
4a84 32 b5 fe			ld (debug_mark+1),a  
4a87 3a 91 4a			ld a, (.dmark+2)  
4a8a 32 b6 fe			ld (debug_mark+2),a  
4a8d 18 03			jr .pastdmark  
4a8f ..			.dmark: db "BUe"  
4a92 f1			.pastdmark: pop af  
4a93			endm  
# End of macro DMARK
4a93						CALLMONITOR 
4a93 cd 46 18			call break_point_state  
4a96				endm  
# End of macro CALLMONITOR
4a96					endif 
4a96			 
4a96 cd 36 04			call storage_write_block 
4a99			 
4a99					NEXTW 
4a99 c3 28 22			jp macro_next 
4a9c				endm 
# End of macro NEXTW
4a9c			 
4a9c			.BYID: 
4a9c			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4a9c			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4a9c			; 
4a9c			;		 
4a9c			;		if DEBUG_FORTH_WORDS_KEY 
4a9c			;			DMARK "BYID" 
4a9c			;			CALLMONITOR 
4a9c			;		endif 
4a9c			; 
4a9c			;		; get direct address 
4a9c			; 
4a9c			;		FORTH_DSP_VALUEHL 
4a9c			; 
4a9c			;		FORTH_DSP_POP 
4a9c			; 
4a9c			;	; calc block address 
4a9c			; 
4a9c			;	ex de, hl 
4a9c			;	ld a, STORE_BLOCK_PHY 
4a9c			;	call Mult16 
4a9c			;	;	do BREAD with number as param 
4a9c			;	; push the file name	 
4a9c			;	ld de, store_page 
4a9c			;	call storage_read_block 
4a9c			 ;       ld hl, store_page+2 
4a9c			; 
4a9c			; 
4a9c			;		NEXTW 
4a9c			;.BYNAME: 
4a9c				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4a9c 3a				db WORD_SYS_CORE+38             
4a9d b5 4a			dw .DIR            
4a9f 06				db 5 + 1 
4aa0 .. 00			db "GETID",0              
4aa6				endm 
# End of macro CWHEAD
4aa6			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4aa6			 
4aa6					; get pointer to file name to seek 
4aa6			 
4aa6					FORTH_DSP_VALUEHL 
4aa6 cd b1 20			call macro_dsp_valuehl 
4aa9				endm 
# End of macro FORTH_DSP_VALUEHL
4aa9			 
4aa9			 
4aa9 cd f8 02				call storage_getid  
4aac			 
4aac					FORTH_DSP_POP 
4aac cd 69 21			call macro_forth_dsp_pop 
4aaf				endm 
# End of macro FORTH_DSP_POP
4aaf			 
4aaf cd ba 1e				call forth_push_numhl 
4ab2			 
4ab2					NEXTW 
4ab2 c3 28 22			jp macro_next 
4ab5				endm 
# End of macro NEXTW
4ab5			; 
4ab5			.DIR: 
4ab5				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4ab5 3a				db WORD_SYS_CORE+38             
4ab6 b9 4b			dw .SAVE            
4ab8 04				db 3 + 1 
4ab9 .. 00			db "DIR",0              
4abd				endm 
# End of macro CWHEAD
4abd			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4abd			 
4abd					if DEBUG_FORTH_WORDS_KEY 
4abd						DMARK "DIR" 
4abd f5				push af  
4abe 3a d2 4a			ld a, (.dmark)  
4ac1 32 b4 fe			ld (debug_mark),a  
4ac4 3a d3 4a			ld a, (.dmark+1)  
4ac7 32 b5 fe			ld (debug_mark+1),a  
4aca 3a d4 4a			ld a, (.dmark+2)  
4acd 32 b6 fe			ld (debug_mark+2),a  
4ad0 18 03			jr .pastdmark  
4ad2 ..			.dmark: db "DIR"  
4ad5 f1			.pastdmark: pop af  
4ad6			endm  
# End of macro DMARK
4ad6						CALLMONITOR 
4ad6 cd 46 18			call break_point_state  
4ad9				endm  
# End of macro CALLMONITOR
4ad9					endif 
4ad9 cd 82 04			call storage_get_block_0 
4adc			 
4adc 21 07 fc			ld hl, store_page     ; get current id count 
4adf 46				ld b, (hl) 
4ae0 0e 00			ld c, 0    ; count of files   
4ae2					if DEBUG_FORTH_WORDS 
4ae2						DMARK "DI1" 
4ae2 f5				push af  
4ae3 3a f7 4a			ld a, (.dmark)  
4ae6 32 b4 fe			ld (debug_mark),a  
4ae9 3a f8 4a			ld a, (.dmark+1)  
4aec 32 b5 fe			ld (debug_mark+1),a  
4aef 3a f9 4a			ld a, (.dmark+2)  
4af2 32 b6 fe			ld (debug_mark+2),a  
4af5 18 03			jr .pastdmark  
4af7 ..			.dmark: db "DI1"  
4afa f1			.pastdmark: pop af  
4afb			endm  
# End of macro DMARK
4afb						CALLMONITOR 
4afb cd 46 18			call break_point_state  
4afe				endm  
# End of macro CALLMONITOR
4afe					endif 
4afe			 
4afe				; check for empty drive 
4afe			 
4afe 3e 00			ld a, 0 
4b00 b8				cp b 
4b01 ca 6f 4b			jp z, .dirdone 
4b04			 
4b04				; for each of the current ids do a search for them and if found push to stack 
4b04			 
4b04 c5			.diritem:	push bc 
4b05 21 40 00				ld hl, STORE_BLOCK_PHY 
4b08 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4b0a 58					ld e,b 
4b0b			 
4b0b			;		if DEBUG_FORTH_WORDS 
4b0b			;			DMARK "DI2" 
4b0b			;			CALLMONITOR 
4b0b			;		endif 
4b0b			 
4b0b cd 04 07				call storage_findnextid 
4b0e			 
4b0e			;		if DEBUG_FORTH_WORDS 
4b0e			;			DMARK "DI3" 
4b0e			;			CALLMONITOR 
4b0e			;		endif 
4b0e			 
4b0e					; if found hl will be non zero 
4b0e			 
4b0e cd f2 0e				call ishlzero 
4b11			;		ld a, l 
4b11			;		add h 
4b11			; 
4b11			;		cp 0 
4b11 28 59				jr z, .dirnotfound 
4b13			 
4b13					; increase count 
4b13			 
4b13 c1					pop bc	 
4b14 0c					inc c 
4b15 c5					push bc 
4b16					 
4b16			 
4b16					; get file header and push the file name 
4b16			 
4b16 11 07 fc				ld de, store_page 
4b19 cd d1 03				call storage_read_block 
4b1c			 
4b1c					; push file id to stack 
4b1c				 
4b1c 3a 07 fc				ld a, (store_page) 
4b1f 26 00				ld h, 0 
4b21 6f					ld l, a 
4b22 cd ba 1e				call forth_push_numhl 
4b25			 
4b25					; push extent count to stack  
4b25				 
4b25 3a 09 fc				ld a, (store_page+2) 
4b28 26 00				ld h, 0 
4b2a 6f					ld l, a 
4b2b cd ba 1e				call forth_push_numhl 
4b2e			 
4b2e					; push file name 
4b2e			 
4b2e 21 0a fc				ld hl, store_page+3 
4b31					if DEBUG_FORTH_WORDS 
4b31						DMARK "DI5" 
4b31 f5				push af  
4b32 3a 46 4b			ld a, (.dmark)  
4b35 32 b4 fe			ld (debug_mark),a  
4b38 3a 47 4b			ld a, (.dmark+1)  
4b3b 32 b5 fe			ld (debug_mark+1),a  
4b3e 3a 48 4b			ld a, (.dmark+2)  
4b41 32 b6 fe			ld (debug_mark+2),a  
4b44 18 03			jr .pastdmark  
4b46 ..			.dmark: db "DI5"  
4b49 f1			.pastdmark: pop af  
4b4a			endm  
# End of macro DMARK
4b4a						CALLMONITOR 
4b4a cd 46 18			call break_point_state  
4b4d				endm  
# End of macro CALLMONITOR
4b4d					endif 
4b4d cd 28 1f				call forth_push_str 
4b50					if DEBUG_FORTH_WORDS 
4b50						DMARK "DI6" 
4b50 f5				push af  
4b51 3a 65 4b			ld a, (.dmark)  
4b54 32 b4 fe			ld (debug_mark),a  
4b57 3a 66 4b			ld a, (.dmark+1)  
4b5a 32 b5 fe			ld (debug_mark+1),a  
4b5d 3a 67 4b			ld a, (.dmark+2)  
4b60 32 b6 fe			ld (debug_mark+2),a  
4b63 18 03			jr .pastdmark  
4b65 ..			.dmark: db "DI6"  
4b68 f1			.pastdmark: pop af  
4b69			endm  
# End of macro DMARK
4b69						CALLMONITOR 
4b69 cd 46 18			call break_point_state  
4b6c				endm  
# End of macro CALLMONITOR
4b6c					endif 
4b6c			.dirnotfound: 
4b6c c1					pop bc     
4b6d 10 95				djnz .diritem 
4b6f				 
4b6f			.dirdone:	 
4b6f					if DEBUG_FORTH_WORDS 
4b6f						DMARK "DI7" 
4b6f f5				push af  
4b70 3a 84 4b			ld a, (.dmark)  
4b73 32 b4 fe			ld (debug_mark),a  
4b76 3a 85 4b			ld a, (.dmark+1)  
4b79 32 b5 fe			ld (debug_mark+1),a  
4b7c 3a 86 4b			ld a, (.dmark+2)  
4b7f 32 b6 fe			ld (debug_mark+2),a  
4b82 18 03			jr .pastdmark  
4b84 ..			.dmark: db "DI7"  
4b87 f1			.pastdmark: pop af  
4b88			endm  
# End of macro DMARK
4b88						CALLMONITOR 
4b88 cd 46 18			call break_point_state  
4b8b				endm  
# End of macro CALLMONITOR
4b8b					endif 
4b8b			 
4b8b					; push a count of the dir items found 
4b8b			 
4b8b 26 00				ld h, 0 
4b8d 69					ld l, c 
4b8e cd ba 1e				call forth_push_numhl 
4b91			 
4b91					; push the bank label 
4b91			 
4b91 cd 82 04				call storage_get_block_0 
4b94			 
4b94				 
4b94 21 0a fc		 		ld hl, store_page+3 
4b97			 
4b97					if DEBUG_FORTH_WORDS 
4b97						DMARK "DI8" 
4b97 f5				push af  
4b98 3a ac 4b			ld a, (.dmark)  
4b9b 32 b4 fe			ld (debug_mark),a  
4b9e 3a ad 4b			ld a, (.dmark+1)  
4ba1 32 b5 fe			ld (debug_mark+1),a  
4ba4 3a ae 4b			ld a, (.dmark+2)  
4ba7 32 b6 fe			ld (debug_mark+2),a  
4baa 18 03			jr .pastdmark  
4bac ..			.dmark: db "DI8"  
4baf f1			.pastdmark: pop af  
4bb0			endm  
# End of macro DMARK
4bb0						CALLMONITOR 
4bb0 cd 46 18			call break_point_state  
4bb3				endm  
# End of macro CALLMONITOR
4bb3					endif 
4bb3 cd 28 1f				call forth_push_str 
4bb6			 
4bb6			 
4bb6				 
4bb6					NEXTW 
4bb6 c3 28 22			jp macro_next 
4bb9				endm 
# End of macro NEXTW
4bb9			.SAVE: 
4bb9			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4bb9			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4bb9			;		NEXTW 
4bb9			;.LOAD: 
4bb9			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4bb9			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4bb9			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4bb9			;; > > The LOAD command can not be used in any user words or compound lines. 
4bb9			; 
4bb9			;		; store_openext use it. If zero it is EOF 
4bb9			; 
4bb9			;		; read block from current stream id 
4bb9			;		; if the block does not contain zero term keep reading blocks until zero found 
4bb9			;		; push the block to stack 
4bb9			;		; save the block id to stream 
4bb9			; 
4bb9			; 
4bb9			;		FORTH_DSP_VALUEHL 
4bb9			; 
4bb9			;;		push hl 
4bb9			; 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LOA" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;		FORTH_DSP_POP 
4bb9			; 
4bb9			;;		pop hl 
4bb9			; 
4bb9			;		ld h, l 
4bb9			;		ld l, 0 
4bb9			; 
4bb9			;		push hl     ; stack holds current file id and extent to work with 
4bb9			; 
4bb9			; 
4bb9			;		ld de, store_page      ; get block zero of file 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LO0" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;		call storage_read 
4bb9			; 
4bb9			;		ld a, (store_page+2)    ; max extents for this file 
4bb9			;		ld  (store_openmaxext),a   ; get our limit 
4bb9			; 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LOE" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			; 
4bb9			;; TODO dont know why max extents are not present 
4bb9			;;		cp 0 
4bb9			;;		jp z, .loadeof     ; dont read past eof 
4bb9			; 
4bb9			;;		ld a, 1   ; start from the head of the file 
4bb9			; 
4bb9			;.loadline:	pop hl 
4bb9			;		inc hl 
4bb9			;		ld  a, (store_openmaxext)   ; get our limit 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LOx" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;		inc a 
4bb9			;		cp l 
4bb9			;		jp z, .loadeof 
4bb9			;		push hl    ; save current extent 
4bb9			; 
4bb9			;		ld de, store_page 
4bb9			; 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LO1" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;		call storage_read 
4bb9			; 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LO2" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;	call ishlzero 
4bb9			;	ld a, l 
4bb9			;	add h 
4bb9			;	cp 0 
4bb9			;	jr z, .loadeof 
4bb9			; 
4bb9			;	; not eof so hl should point to data to exec 
4bb9			; 
4bb9			;	; will need to add the FORTH_END_BUFFER flag 
4bb9			 ; 
4bb9			;	ld hl, store_page+2 
4bb9			;	ld bc, 255 
4bb9			;	ld a, 0 
4bb9			;	cpir 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LOt" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;	dec hl 
4bb9			;	ld a, ' ' 
4bb9			;	ld (hl), a 
4bb9			;	inc hl 
4bb9			;	ld (hl), a 
4bb9			;	inc hl 
4bb9			;	ld (hl), a 
4bb9			;	inc hl 
4bb9			;	ld a, FORTH_END_BUFFER 
4bb9			;	ld (hl), a 
4bb9			; 
4bb9			;	; TODO handle more than a single block read 
4bb9			; 
4bb9			; 
4bb9			;	ld hl, store_page+2 
4bb9			; 
4bb9			;	ld (os_tok_ptr), hl 
4bb9			; 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LO3" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			; 
4bb9			;	call forthparse 
4bb9			;	call forthexec 
4bb9			;	call forthexec_cleanup 
4bb9			; 
4bb9			;	; go to next extent 
4bb9			; 
4bb9			;	; get next block  or mark as eof 
4bb9			;	jp .loadline 
4bb9			; 
4bb9			; 
4bb9			; 
4bb9			;	       NEXTW 
4bb9			;.loadeof:	ld a, 0 
4bb9			;		ld (store_openext), a 
4bb9			; 
4bb9			;	if DEBUG_STORESE 
4bb9			;		DMARK "LOF" 
4bb9			;		CALLMONITOR 
4bb9			;	endif 
4bb9			;		ret 
4bb9			;		;NEXTW 
4bb9			;.BSAVE:   
4bb9			; 
4bb9			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4bb9			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4bb9			;		NEXTW 
4bb9			;.BLOAD: 
4bb9			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4bb9			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4bb9			;		NEXTW 
4bb9			;;;; counter gap 
4bb9			 
4bb9			 
4bb9			.SEO: 
4bb9				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4bb9 64				db WORD_SYS_CORE+80             
4bba d8 4b			dw .SEI            
4bbc 04				db 3 + 1 
4bbd .. 00			db "SEO",0              
4bc1				endm 
# End of macro CWHEAD
4bc1			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4bc1			 
4bc1					; get port 
4bc1			 
4bc1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc1 cd b1 20			call macro_dsp_valuehl 
4bc4				endm 
# End of macro FORTH_DSP_VALUEHL
4bc4			 
4bc4 e5					push hl    ; u2 - byte 
4bc5			 
4bc5					; destroy value TOS 
4bc5			 
4bc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc5 cd 69 21			call macro_forth_dsp_pop 
4bc8				endm 
# End of macro FORTH_DSP_POP
4bc8			 
4bc8					; get byte to send 
4bc8			 
4bc8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc8 cd b1 20			call macro_dsp_valuehl 
4bcb				endm 
# End of macro FORTH_DSP_VALUEHL
4bcb			 
4bcb e5					push hl    ; u1 - addr 
4bcc			 
4bcc					; destroy value TOS 
4bcc			 
4bcc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bcc cd 69 21			call macro_forth_dsp_pop 
4bcf				endm 
# End of macro FORTH_DSP_POP
4bcf			 
4bcf					; one value on hl get other one back 
4bcf			 
4bcf d1					pop de   ; u1 - byte 
4bd0			 
4bd0 e1					pop hl   ; u2 - addr 
4bd1			 
4bd1					; TODO Send SPI byte 
4bd1			 
4bd1			 
4bd1 7b					ld a, e 
4bd2 cd d6 01				call se_writebyte 
4bd5			 
4bd5					 
4bd5			 
4bd5					NEXTW 
4bd5 c3 28 22			jp macro_next 
4bd8				endm 
# End of macro NEXTW
4bd8			 
4bd8			.SEI: 
4bd8				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4bd8 65				db WORD_SYS_CORE+81             
4bd9 f2 4b			dw .SFREE            
4bdb 04				db 3 + 1 
4bdc .. 00			db "SEI",0              
4be0				endm 
# End of macro CWHEAD
4be0			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4be0			 
4be0					; get port 
4be0			 
4be0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be0 cd b1 20			call macro_dsp_valuehl 
4be3				endm 
# End of macro FORTH_DSP_VALUEHL
4be3			 
4be3			;		push hl 
4be3			 
4be3					; destroy value TOS 
4be3			 
4be3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4be3 cd 69 21			call macro_forth_dsp_pop 
4be6				endm 
# End of macro FORTH_DSP_POP
4be6			 
4be6					; one value on hl get other one back 
4be6			 
4be6			;		pop hl 
4be6			 
4be6			 
4be6					; TODO Get SPI byte 
4be6			 
4be6 cd 78 02				call se_readbyte 
4be9			 
4be9 26 00				ld h, 0 
4beb 6f					ld l, a 
4bec cd ba 1e				call forth_push_numhl 
4bef			 
4bef					NEXTW 
4bef c3 28 22			jp macro_next 
4bf2				endm 
# End of macro NEXTW
4bf2			 
4bf2			.SFREE: 
4bf2				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4bf2 67				db WORD_SYS_CORE+83             
4bf3 21 4c			dw .SIZE            
4bf5 06				db 5 + 1 
4bf6 .. 00			db "FFREE",0              
4bfc				endm 
# End of macro CWHEAD
4bfc			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4bfc					if DEBUG_FORTH_WORDS_KEY 
4bfc						DMARK "FFR" 
4bfc f5				push af  
4bfd 3a 11 4c			ld a, (.dmark)  
4c00 32 b4 fe			ld (debug_mark),a  
4c03 3a 12 4c			ld a, (.dmark+1)  
4c06 32 b5 fe			ld (debug_mark+1),a  
4c09 3a 13 4c			ld a, (.dmark+2)  
4c0c 32 b6 fe			ld (debug_mark+2),a  
4c0f 18 03			jr .pastdmark  
4c11 ..			.dmark: db "FFR"  
4c14 f1			.pastdmark: pop af  
4c15			endm  
# End of macro DMARK
4c15						CALLMONITOR 
4c15 cd 46 18			call break_point_state  
4c18				endm  
# End of macro CALLMONITOR
4c18					endif 
4c18			 
4c18 cd 9e 07				call storage_freeblocks 
4c1b			 
4c1b cd ba 1e				call forth_push_numhl 
4c1e			 
4c1e				       NEXTW 
4c1e c3 28 22			jp macro_next 
4c21				endm 
# End of macro NEXTW
4c21			.SIZE: 
4c21				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4c21 67				db WORD_SYS_CORE+83             
4c22 55 4c			dw .CREATE            
4c24 05				db 4 + 1 
4c25 .. 00			db "SIZE",0              
4c2a				endm 
# End of macro CWHEAD
4c2a			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4c2a					if DEBUG_FORTH_WORDS_KEY 
4c2a						DMARK "SIZ" 
4c2a f5				push af  
4c2b 3a 3f 4c			ld a, (.dmark)  
4c2e 32 b4 fe			ld (debug_mark),a  
4c31 3a 40 4c			ld a, (.dmark+1)  
4c34 32 b5 fe			ld (debug_mark+1),a  
4c37 3a 41 4c			ld a, (.dmark+2)  
4c3a 32 b6 fe			ld (debug_mark+2),a  
4c3d 18 03			jr .pastdmark  
4c3f ..			.dmark: db "SIZ"  
4c42 f1			.pastdmark: pop af  
4c43			endm  
# End of macro DMARK
4c43						CALLMONITOR 
4c43 cd 46 18			call break_point_state  
4c46				endm  
# End of macro CALLMONITOR
4c46					endif 
4c46			 
4c46					FORTH_DSP_VALUEHL 
4c46 cd b1 20			call macro_dsp_valuehl 
4c49				endm 
# End of macro FORTH_DSP_VALUEHL
4c49			;		push hl 
4c49					FORTH_DSP_POP 
4c49 cd 69 21			call macro_forth_dsp_pop 
4c4c				endm 
# End of macro FORTH_DSP_POP
4c4c			;		pop hl 
4c4c cd 00 04				call storage_file_size 
4c4f			 
4c4f cd ba 1e				call forth_push_numhl 
4c52			  
4c52			 
4c52				       NEXTW 
4c52 c3 28 22			jp macro_next 
4c55				endm 
# End of macro NEXTW
4c55			 
4c55			.CREATE: 
4c55				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4c55 68				db WORD_SYS_CORE+84             
4c56 c3 4c			dw .APPEND            
4c58 07				db 6 + 1 
4c59 .. 00			db "CREATE",0              
4c60				endm 
# End of macro CWHEAD
4c60			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4c60			; | | e.g.  
4c60			; | | TestProgram CREATE 
4c60			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4c60			; | |  
4c60			; | | Max file IDs are 255. 
4c60			; | |  
4c60					 
4c60					if DEBUG_FORTH_WORDS_KEY 
4c60						DMARK "CRT" 
4c60 f5				push af  
4c61 3a 75 4c			ld a, (.dmark)  
4c64 32 b4 fe			ld (debug_mark),a  
4c67 3a 76 4c			ld a, (.dmark+1)  
4c6a 32 b5 fe			ld (debug_mark+1),a  
4c6d 3a 77 4c			ld a, (.dmark+2)  
4c70 32 b6 fe			ld (debug_mark+2),a  
4c73 18 03			jr .pastdmark  
4c75 ..			.dmark: db "CRT"  
4c78 f1			.pastdmark: pop af  
4c79			endm  
# End of macro DMARK
4c79						CALLMONITOR 
4c79 cd 46 18			call break_point_state  
4c7c				endm  
# End of macro CALLMONITOR
4c7c					endif 
4c7c			;		call storage_get_block_0 
4c7c			 
4c7c					; TODO pop hl 
4c7c			 
4c7c					;v5 FORTH_DSP_VALUE 
4c7c					FORTH_DSP_VALUE 
4c7c cd 9a 20			call macro_forth_dsp_value 
4c7f				endm 
# End of macro FORTH_DSP_VALUE
4c7f			 
4c7f				if DEBUG_STORESE 
4c7f					DMARK "CR1" 
4c7f f5				push af  
4c80 3a 94 4c			ld a, (.dmark)  
4c83 32 b4 fe			ld (debug_mark),a  
4c86 3a 95 4c			ld a, (.dmark+1)  
4c89 32 b5 fe			ld (debug_mark+1),a  
4c8c 3a 96 4c			ld a, (.dmark+2)  
4c8f 32 b6 fe			ld (debug_mark+2),a  
4c92 18 03			jr .pastdmark  
4c94 ..			.dmark: db "CR1"  
4c97 f1			.pastdmark: pop af  
4c98			endm  
# End of macro DMARK
4c98					CALLMONITOR 
4c98 cd 46 18			call break_point_state  
4c9b				endm  
# End of macro CALLMONITOR
4c9b				endif 
4c9b			;		push hl 
4c9b			;		FORTH_DSP_POP 
4c9b			;		pop hl 
4c9b			 
4c9b			;		inc hl   ; move past the type marker 
4c9b			 
4c9b cd d4 07				call storage_create 
4c9e			 
4c9e				if DEBUG_STORESE 
4c9e					DMARK "CT1" 
4c9e f5				push af  
4c9f 3a b3 4c			ld a, (.dmark)  
4ca2 32 b4 fe			ld (debug_mark),a  
4ca5 3a b4 4c			ld a, (.dmark+1)  
4ca8 32 b5 fe			ld (debug_mark+1),a  
4cab 3a b5 4c			ld a, (.dmark+2)  
4cae 32 b6 fe			ld (debug_mark+2),a  
4cb1 18 03			jr .pastdmark  
4cb3 ..			.dmark: db "CT1"  
4cb6 f1			.pastdmark: pop af  
4cb7			endm  
# End of macro DMARK
4cb7					CALLMONITOR 
4cb7 cd 46 18			call break_point_state  
4cba				endm  
# End of macro CALLMONITOR
4cba				endif 
4cba			;		push hl 
4cba					FORTH_DSP_POP 
4cba cd 69 21			call macro_forth_dsp_pop 
4cbd				endm 
# End of macro FORTH_DSP_POP
4cbd			;		pop hl 
4cbd					; push file id to stack 
4cbd cd ba 1e				call forth_push_numhl 
4cc0			 
4cc0			 
4cc0			 
4cc0				       NEXTW 
4cc0 c3 28 22			jp macro_next 
4cc3				endm 
# End of macro NEXTW
4cc3			 
4cc3			.APPEND: 
4cc3				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4cc3 69				db WORD_SYS_CORE+85             
4cc4 54 4d			dw .SDEL            
4cc6 07				db 6 + 1 
4cc7 .. 00			db "APPEND",0              
4cce				endm 
# End of macro CWHEAD
4cce			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4cce			; | | e.g. 
4cce			; | | Test CREATE      -> $01 
4cce			; | | "A string to add to file" $01 APPEND 
4cce			; | |  
4cce			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4cce					if DEBUG_FORTH_WORDS_KEY 
4cce						DMARK "APP" 
4cce f5				push af  
4ccf 3a e3 4c			ld a, (.dmark)  
4cd2 32 b4 fe			ld (debug_mark),a  
4cd5 3a e4 4c			ld a, (.dmark+1)  
4cd8 32 b5 fe			ld (debug_mark+1),a  
4cdb 3a e5 4c			ld a, (.dmark+2)  
4cde 32 b6 fe			ld (debug_mark+2),a  
4ce1 18 03			jr .pastdmark  
4ce3 ..			.dmark: db "APP"  
4ce6 f1			.pastdmark: pop af  
4ce7			endm  
# End of macro DMARK
4ce7						CALLMONITOR 
4ce7 cd 46 18			call break_point_state  
4cea				endm  
# End of macro CALLMONITOR
4cea					endif 
4cea			 
4cea					FORTH_DSP_VALUEHL 
4cea cd b1 20			call macro_dsp_valuehl 
4ced				endm 
# End of macro FORTH_DSP_VALUEHL
4ced e5					push hl 	; save file id 
4cee			 
4cee				if DEBUG_STORESE 
4cee					DMARK "AP1" 
4cee f5				push af  
4cef 3a 03 4d			ld a, (.dmark)  
4cf2 32 b4 fe			ld (debug_mark),a  
4cf5 3a 04 4d			ld a, (.dmark+1)  
4cf8 32 b5 fe			ld (debug_mark+1),a  
4cfb 3a 05 4d			ld a, (.dmark+2)  
4cfe 32 b6 fe			ld (debug_mark+2),a  
4d01 18 03			jr .pastdmark  
4d03 ..			.dmark: db "AP1"  
4d06 f1			.pastdmark: pop af  
4d07			endm  
# End of macro DMARK
4d07					CALLMONITOR 
4d07 cd 46 18			call break_point_state  
4d0a				endm  
# End of macro CALLMONITOR
4d0a				endif 
4d0a					FORTH_DSP_POP 
4d0a cd 69 21			call macro_forth_dsp_pop 
4d0d				endm 
# End of macro FORTH_DSP_POP
4d0d			 
4d0d					FORTH_DSP_VALUEHL 
4d0d cd b1 20			call macro_dsp_valuehl 
4d10				endm 
# End of macro FORTH_DSP_VALUEHL
4d10					;v5 FORTH_DSP_VALUE 
4d10 e5					push hl 	; save ptr to string to save 
4d11			 
4d11				if DEBUG_STORESE 
4d11					DMARK "AP1" 
4d11 f5				push af  
4d12 3a 26 4d			ld a, (.dmark)  
4d15 32 b4 fe			ld (debug_mark),a  
4d18 3a 27 4d			ld a, (.dmark+1)  
4d1b 32 b5 fe			ld (debug_mark+1),a  
4d1e 3a 28 4d			ld a, (.dmark+2)  
4d21 32 b6 fe			ld (debug_mark+2),a  
4d24 18 03			jr .pastdmark  
4d26 ..			.dmark: db "AP1"  
4d29 f1			.pastdmark: pop af  
4d2a			endm  
# End of macro DMARK
4d2a					CALLMONITOR 
4d2a cd 46 18			call break_point_state  
4d2d				endm  
# End of macro CALLMONITOR
4d2d				endif 
4d2d					FORTH_DSP_POP 
4d2d cd 69 21			call macro_forth_dsp_pop 
4d30				endm 
# End of macro FORTH_DSP_POP
4d30			 
4d30 d1					pop de 
4d31 e1					pop hl 
4d32				if DEBUG_STORESE 
4d32					DMARK "AP2" 
4d32 f5				push af  
4d33 3a 47 4d			ld a, (.dmark)  
4d36 32 b4 fe			ld (debug_mark),a  
4d39 3a 48 4d			ld a, (.dmark+1)  
4d3c 32 b5 fe			ld (debug_mark+1),a  
4d3f 3a 49 4d			ld a, (.dmark+2)  
4d42 32 b6 fe			ld (debug_mark+2),a  
4d45 18 03			jr .pastdmark  
4d47 ..			.dmark: db "AP2"  
4d4a f1			.pastdmark: pop af  
4d4b			endm  
# End of macro DMARK
4d4b					CALLMONITOR 
4d4b cd 46 18			call break_point_state  
4d4e				endm  
# End of macro CALLMONITOR
4d4e				endif 
4d4e					;inc de ; skip var type indicator 
4d4e			 
4d4e					; TODO how to append numerics???? 
4d4e			 
4d4e cd 89 0a				call storage_append		 
4d51			 
4d51				       NEXTW 
4d51 c3 28 22			jp macro_next 
4d54				endm 
# End of macro NEXTW
4d54			.SDEL: 
4d54				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4d54 6a				db WORD_SYS_CORE+86             
4d55 a0 4d			dw .OPEN            
4d57 05				db 4 + 1 
4d58 .. 00			db "ERA",0              
4d5c				endm 
# End of macro CWHEAD
4d5c			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4d5c					FORTH_DSP_VALUEHL 
4d5c cd b1 20			call macro_dsp_valuehl 
4d5f				endm 
# End of macro FORTH_DSP_VALUEHL
4d5f			;		push hl 	; save file id 
4d5f			 
4d5f					if DEBUG_FORTH_WORDS_KEY 
4d5f						DMARK "ERA" 
4d5f f5				push af  
4d60 3a 74 4d			ld a, (.dmark)  
4d63 32 b4 fe			ld (debug_mark),a  
4d66 3a 75 4d			ld a, (.dmark+1)  
4d69 32 b5 fe			ld (debug_mark+1),a  
4d6c 3a 76 4d			ld a, (.dmark+2)  
4d6f 32 b6 fe			ld (debug_mark+2),a  
4d72 18 03			jr .pastdmark  
4d74 ..			.dmark: db "ERA"  
4d77 f1			.pastdmark: pop af  
4d78			endm  
# End of macro DMARK
4d78						CALLMONITOR 
4d78 cd 46 18			call break_point_state  
4d7b				endm  
# End of macro CALLMONITOR
4d7b					endif 
4d7b				if DEBUG_STORESE 
4d7b					DMARK "ER1" 
4d7b f5				push af  
4d7c 3a 90 4d			ld a, (.dmark)  
4d7f 32 b4 fe			ld (debug_mark),a  
4d82 3a 91 4d			ld a, (.dmark+1)  
4d85 32 b5 fe			ld (debug_mark+1),a  
4d88 3a 92 4d			ld a, (.dmark+2)  
4d8b 32 b6 fe			ld (debug_mark+2),a  
4d8e 18 03			jr .pastdmark  
4d90 ..			.dmark: db "ER1"  
4d93 f1			.pastdmark: pop af  
4d94			endm  
# End of macro DMARK
4d94					CALLMONITOR 
4d94 cd 46 18			call break_point_state  
4d97				endm  
# End of macro CALLMONITOR
4d97				endif 
4d97					FORTH_DSP_POP 
4d97 cd 69 21			call macro_forth_dsp_pop 
4d9a				endm 
# End of macro FORTH_DSP_POP
4d9a			 
4d9a			;		pop hl 
4d9a			 
4d9a cd 13 06				call storage_erase 
4d9d				       NEXTW 
4d9d c3 28 22			jp macro_next 
4da0				endm 
# End of macro NEXTW
4da0			 
4da0			.OPEN: 
4da0				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4da0 6b				db WORD_SYS_CORE+87             
4da1 34 4e			dw .READ            
4da3 05				db 4 + 1 
4da4 .. 00			db "OPEN",0              
4da9				endm 
# End of macro CWHEAD
4da9			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4da9			; | | e.g. 
4da9			; | | $01 OPEN $01 DO $01 READ . LOOP 
4da9			; | | 
4da9			; | | Will return with 255 blocks if the file does not exist 
4da9			 
4da9					if DEBUG_FORTH_WORDS_KEY 
4da9						DMARK "OPN" 
4da9 f5				push af  
4daa 3a be 4d			ld a, (.dmark)  
4dad 32 b4 fe			ld (debug_mark),a  
4db0 3a bf 4d			ld a, (.dmark+1)  
4db3 32 b5 fe			ld (debug_mark+1),a  
4db6 3a c0 4d			ld a, (.dmark+2)  
4db9 32 b6 fe			ld (debug_mark+2),a  
4dbc 18 03			jr .pastdmark  
4dbe ..			.dmark: db "OPN"  
4dc1 f1			.pastdmark: pop af  
4dc2			endm  
# End of macro DMARK
4dc2						CALLMONITOR 
4dc2 cd 46 18			call break_point_state  
4dc5				endm  
# End of macro CALLMONITOR
4dc5					endif 
4dc5					; TODO handle multiple file opens 
4dc5			 
4dc5 3e 01			       	ld a, 1 
4dc7 32 f9 fb				ld (store_openext), a 
4dca			 
4dca					; get max extents for this file 
4dca				 
4dca								 
4dca					FORTH_DSP_VALUEHL 
4dca cd b1 20			call macro_dsp_valuehl 
4dcd				endm 
# End of macro FORTH_DSP_VALUEHL
4dcd			 
4dcd 65					ld h, l 
4dce 2e 00				ld l, 0 
4dd0			 
4dd0					; store file id 
4dd0			 
4dd0 7c					ld a, h 
4dd1 32 f6 fb				ld (store_filecache), a 
4dd4			 
4dd4				if DEBUG_STORESE 
4dd4					DMARK "OPN" 
4dd4 f5				push af  
4dd5 3a e9 4d			ld a, (.dmark)  
4dd8 32 b4 fe			ld (debug_mark),a  
4ddb 3a ea 4d			ld a, (.dmark+1)  
4dde 32 b5 fe			ld (debug_mark+1),a  
4de1 3a eb 4d			ld a, (.dmark+2)  
4de4 32 b6 fe			ld (debug_mark+2),a  
4de7 18 03			jr .pastdmark  
4de9 ..			.dmark: db "OPN"  
4dec f1			.pastdmark: pop af  
4ded			endm  
# End of macro DMARK
4ded					CALLMONITOR 
4ded cd 46 18			call break_point_state  
4df0				endm  
# End of macro CALLMONITOR
4df0				endif 
4df0			;		push hl 
4df0					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4df0 cd 69 21			call macro_forth_dsp_pop 
4df3				endm 
# End of macro FORTH_DSP_POP
4df3			;		pop hl 
4df3						 
4df3 11 07 fc				ld de, store_page      ; get block zero of file 
4df6 cd 2a 09				call storage_read 
4df9 cd f2 0e			call ishlzero 
4dfc 20 04			jr nz, .opfound 
4dfe			 
4dfe				; file does not exist so indicate with 255 extents in use 
4dfe			 
4dfe 3e ff			ld a, 255 
4e00 18 29			jr .skipopeneof 
4e02			 
4e02			 
4e02			.opfound: 
4e02			 
4e02			 
4e02 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
4e05 32 f8 fb				ld  (store_openmaxext), a   ; get our limit and push 
4e08					 
4e08				if DEBUG_STORESE 
4e08					DMARK "OPx" 
4e08 f5				push af  
4e09 3a 1d 4e			ld a, (.dmark)  
4e0c 32 b4 fe			ld (debug_mark),a  
4e0f 3a 1e 4e			ld a, (.dmark+1)  
4e12 32 b5 fe			ld (debug_mark+1),a  
4e15 3a 1f 4e			ld a, (.dmark+2)  
4e18 32 b6 fe			ld (debug_mark+2),a  
4e1b 18 03			jr .pastdmark  
4e1d ..			.dmark: db "OPx"  
4e20 f1			.pastdmark: pop af  
4e21			endm  
# End of macro DMARK
4e21					CALLMONITOR 
4e21 cd 46 18			call break_point_state  
4e24				endm  
# End of macro CALLMONITOR
4e24				endif 
4e24 fe 00				cp 0 
4e26 20 03				jr nz, .skipopeneof 
4e28					; have opened an empty file 
4e28					 
4e28 32 f9 fb				ld (store_openext), a 
4e2b			 
4e2b			.skipopeneof: 
4e2b			 
4e2b 6f					ld l, a 
4e2c 26 00				ld h, 0 
4e2e cd ba 1e				call forth_push_numhl 
4e31			 
4e31			 
4e31				       NEXTW 
4e31 c3 28 22			jp macro_next 
4e34				endm 
# End of macro NEXTW
4e34			.READ: 
4e34				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4e34 6c				db WORD_SYS_CORE+88             
4e35 5e 4f			dw .EOF            
4e37 05				db 4 + 1 
4e38 .. 00			db "READ",0              
4e3d				endm 
# End of macro CWHEAD
4e3d			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4e3d			; | | e.g. 
4e3d			; | | $01 OPEN $01 DO READ . LOOP 
4e3d			; | | 
4e3d			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4e3d			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4e3d			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4e3d			; | | two bytes contain the file id and extent. 
4e3d			; | |  
4e3d			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4e3d			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4e3d			 
4e3d					if DEBUG_FORTH_WORDS_KEY 
4e3d						DMARK "REA" 
4e3d f5				push af  
4e3e 3a 52 4e			ld a, (.dmark)  
4e41 32 b4 fe			ld (debug_mark),a  
4e44 3a 53 4e			ld a, (.dmark+1)  
4e47 32 b5 fe			ld (debug_mark+1),a  
4e4a 3a 54 4e			ld a, (.dmark+2)  
4e4d 32 b6 fe			ld (debug_mark+2),a  
4e50 18 03			jr .pastdmark  
4e52 ..			.dmark: db "REA"  
4e55 f1			.pastdmark: pop af  
4e56			endm  
# End of macro DMARK
4e56						CALLMONITOR 
4e56 cd 46 18			call break_point_state  
4e59				endm  
# End of macro CALLMONITOR
4e59					endif 
4e59					; store_openext use it. If zero it is EOF 
4e59			 
4e59					; read block from current stream id 
4e59					; if the block does not contain zero term keep reading blocks until zero found 
4e59					; push the block to stack 
4e59					; save the block id to stream 
4e59			 
4e59			 
4e59 cd 8b 4f				call .testeof 
4e5c 3e 01				ld a, 1 
4e5e bd					cp l 
4e5f ca 3a 4f				jp z, .ateof 
4e62			 
4e62			 
4e62			;		FORTH_DSP_VALUEHL 
4e62			 
4e62			;		push hl 
4e62			 
4e62			;	if DEBUG_STORESE 
4e62			;		DMARK "REA" 
4e62			;		CALLMONITOR 
4e62			;	endif 
4e62			;		FORTH_DSP_POP 
4e62			 
4e62			;		pop hl 
4e62				 
4e62 3a f6 fb				ld a, (store_filecache) 
4e65 67					ld h,a 
4e66			 
4e66 3a f9 fb				ld a, (store_openext) 
4e69 6f					ld l, a 
4e6a					 
4e6a fe 00				cp 0 
4e6c ca 3a 4f				jp z, .ateof     ; dont read past eof 
4e6f			 
4e6f cd d5 0b				call storage_clear_page 
4e72			 
4e72 11 07 fc				ld de, store_page 
4e75				if DEBUG_STORESE 
4e75					DMARK "RE1" 
4e75 f5				push af  
4e76 3a 8a 4e			ld a, (.dmark)  
4e79 32 b4 fe			ld (debug_mark),a  
4e7c 3a 8b 4e			ld a, (.dmark+1)  
4e7f 32 b5 fe			ld (debug_mark+1),a  
4e82 3a 8c 4e			ld a, (.dmark+2)  
4e85 32 b6 fe			ld (debug_mark+2),a  
4e88 18 03			jr .pastdmark  
4e8a ..			.dmark: db "RE1"  
4e8d f1			.pastdmark: pop af  
4e8e			endm  
# End of macro DMARK
4e8e					CALLMONITOR 
4e8e cd 46 18			call break_point_state  
4e91				endm  
# End of macro CALLMONITOR
4e91				endif 
4e91 cd 2a 09				call storage_read 
4e94			 
4e94				if DEBUG_STORESE 
4e94					DMARK "RE2" 
4e94 f5				push af  
4e95 3a a9 4e			ld a, (.dmark)  
4e98 32 b4 fe			ld (debug_mark),a  
4e9b 3a aa 4e			ld a, (.dmark+1)  
4e9e 32 b5 fe			ld (debug_mark+1),a  
4ea1 3a ab 4e			ld a, (.dmark+2)  
4ea4 32 b6 fe			ld (debug_mark+2),a  
4ea7 18 03			jr .pastdmark  
4ea9 ..			.dmark: db "RE2"  
4eac f1			.pastdmark: pop af  
4ead			endm  
# End of macro DMARK
4ead					CALLMONITOR 
4ead cd 46 18			call break_point_state  
4eb0				endm  
# End of macro CALLMONITOR
4eb0				endif 
4eb0 cd f2 0e			call ishlzero 
4eb3			;	ld a, l 
4eb3			;	add h 
4eb3			;	cp 0 
4eb3 ca 3a 4f			jp z, .readeof 
4eb6			 
4eb6				; not eof so hl should point to data to push to stack 
4eb6			 
4eb6				if DEBUG_STORESE 
4eb6					DMARK "RE3" 
4eb6 f5				push af  
4eb7 3a cb 4e			ld a, (.dmark)  
4eba 32 b4 fe			ld (debug_mark),a  
4ebd 3a cc 4e			ld a, (.dmark+1)  
4ec0 32 b5 fe			ld (debug_mark+1),a  
4ec3 3a cd 4e			ld a, (.dmark+2)  
4ec6 32 b6 fe			ld (debug_mark+2),a  
4ec9 18 03			jr .pastdmark  
4ecb ..			.dmark: db "RE3"  
4ece f1			.pastdmark: pop af  
4ecf			endm  
# End of macro DMARK
4ecf					CALLMONITOR 
4ecf cd 46 18			call break_point_state  
4ed2				endm  
# End of macro CALLMONITOR
4ed2				endif 
4ed2 cd 28 1f			call forth_push_str 
4ed5			 
4ed5				if DEBUG_STORESE 
4ed5					DMARK "RE4" 
4ed5 f5				push af  
4ed6 3a ea 4e			ld a, (.dmark)  
4ed9 32 b4 fe			ld (debug_mark),a  
4edc 3a eb 4e			ld a, (.dmark+1)  
4edf 32 b5 fe			ld (debug_mark+1),a  
4ee2 3a ec 4e			ld a, (.dmark+2)  
4ee5 32 b6 fe			ld (debug_mark+2),a  
4ee8 18 03			jr .pastdmark  
4eea ..			.dmark: db "RE4"  
4eed f1			.pastdmark: pop af  
4eee			endm  
# End of macro DMARK
4eee					CALLMONITOR 
4eee cd 46 18			call break_point_state  
4ef1				endm  
# End of macro CALLMONITOR
4ef1				endif 
4ef1				; get next block  or mark as eof 
4ef1			 
4ef1 3a f8 fb			ld a, (store_openmaxext)   ; get our limit 
4ef4 4f				ld c, a	 
4ef5 3a f9 fb			ld a, (store_openext) 
4ef8			 
4ef8				if DEBUG_STORESE 
4ef8					DMARK "RE5" 
4ef8 f5				push af  
4ef9 3a 0d 4f			ld a, (.dmark)  
4efc 32 b4 fe			ld (debug_mark),a  
4eff 3a 0e 4f			ld a, (.dmark+1)  
4f02 32 b5 fe			ld (debug_mark+1),a  
4f05 3a 0f 4f			ld a, (.dmark+2)  
4f08 32 b6 fe			ld (debug_mark+2),a  
4f0b 18 03			jr .pastdmark  
4f0d ..			.dmark: db "RE5"  
4f10 f1			.pastdmark: pop af  
4f11			endm  
# End of macro DMARK
4f11					CALLMONITOR 
4f11 cd 46 18			call break_point_state  
4f14				endm  
# End of macro CALLMONITOR
4f14				endif 
4f14 b9				cp c 
4f15 28 23			jr z, .readeof     ; at last extent 
4f17			 
4f17 3c					inc a 
4f18 32 f9 fb				ld (store_openext), a 
4f1b			 
4f1b				if DEBUG_STORESE 
4f1b					DMARK "RE6" 
4f1b f5				push af  
4f1c 3a 30 4f			ld a, (.dmark)  
4f1f 32 b4 fe			ld (debug_mark),a  
4f22 3a 31 4f			ld a, (.dmark+1)  
4f25 32 b5 fe			ld (debug_mark+1),a  
4f28 3a 32 4f			ld a, (.dmark+2)  
4f2b 32 b6 fe			ld (debug_mark+2),a  
4f2e 18 03			jr .pastdmark  
4f30 ..			.dmark: db "RE6"  
4f33 f1			.pastdmark: pop af  
4f34			endm  
# End of macro DMARK
4f34					CALLMONITOR 
4f34 cd 46 18			call break_point_state  
4f37				endm  
# End of macro CALLMONITOR
4f37				endif 
4f37			 
4f37			 
4f37				       NEXTW 
4f37 c3 28 22			jp macro_next 
4f3a				endm 
# End of macro NEXTW
4f3a			.ateof: 
4f3a				;	ld hl, .showeof 
4f3a				;	call forth_push_str 
4f3a 3e 00		.readeof:	ld a, 0 
4f3c 32 f9 fb				ld (store_openext), a 
4f3f			 
4f3f					 
4f3f				if DEBUG_STORESE 
4f3f					DMARK "REF" 
4f3f f5				push af  
4f40 3a 54 4f			ld a, (.dmark)  
4f43 32 b4 fe			ld (debug_mark),a  
4f46 3a 55 4f			ld a, (.dmark+1)  
4f49 32 b5 fe			ld (debug_mark+1),a  
4f4c 3a 56 4f			ld a, (.dmark+2)  
4f4f 32 b6 fe			ld (debug_mark+2),a  
4f52 18 03			jr .pastdmark  
4f54 ..			.dmark: db "REF"  
4f57 f1			.pastdmark: pop af  
4f58			endm  
# End of macro DMARK
4f58					CALLMONITOR 
4f58 cd 46 18			call break_point_state  
4f5b				endm  
# End of macro CALLMONITOR
4f5b				endif 
4f5b				       NEXTW 
4f5b c3 28 22			jp macro_next 
4f5e				endm 
# End of macro NEXTW
4f5e			 
4f5e			;.showeof:   db "eof", 0 
4f5e			 
4f5e			 
4f5e			.EOF: 
4f5e				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4f5e 6d				db WORD_SYS_CORE+89             
4f5f a0 4f			dw .FORMAT            
4f61 04				db 3 + 1 
4f62 .. 00			db "EOF",0              
4f66				endm 
# End of macro CWHEAD
4f66			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
4f66			; | | e.g. 
4f66			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
4f66					; TODO if current block id for stream is zero then push true else false 
4f66			 
4f66					if DEBUG_FORTH_WORDS_KEY 
4f66						DMARK "EOF" 
4f66 f5				push af  
4f67 3a 7b 4f			ld a, (.dmark)  
4f6a 32 b4 fe			ld (debug_mark),a  
4f6d 3a 7c 4f			ld a, (.dmark+1)  
4f70 32 b5 fe			ld (debug_mark+1),a  
4f73 3a 7d 4f			ld a, (.dmark+2)  
4f76 32 b6 fe			ld (debug_mark+2),a  
4f79 18 03			jr .pastdmark  
4f7b ..			.dmark: db "EOF"  
4f7e f1			.pastdmark: pop af  
4f7f			endm  
# End of macro DMARK
4f7f						CALLMONITOR 
4f7f cd 46 18			call break_point_state  
4f82				endm  
# End of macro CALLMONITOR
4f82					endif 
4f82			 
4f82					; TODO handlue multiple file streams 
4f82			 
4f82			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
4f82 cd 8b 4f				call .testeof 
4f85 cd ba 1e				call forth_push_numhl 
4f88			 
4f88			 
4f88				       NEXTW 
4f88 c3 28 22			jp macro_next 
4f8b				endm 
# End of macro NEXTW
4f8b			 
4f8b			.testeof: 
4f8b 2e 01				ld l, 1 
4f8d 3a f8 fb				ld a, (store_openmaxext) 
4f90 fe 00				cp 0 
4f92 28 09				jr  z, .eofdone   ; empty file 
4f94 3a f9 fb				ld a, (store_openext) 
4f97 fe 00				cp 0 
4f99 28 02				jr  z, .eofdone 
4f9b 2e 00				ld l, 0 
4f9d 26 00		.eofdone:	ld h, 0 
4f9f c9					ret 
4fa0			 
4fa0			 
4fa0			 
4fa0			 
4fa0			.FORMAT: 
4fa0				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4fa0 6d				db WORD_SYS_CORE+89             
4fa1 f1 4f			dw .LABEL            
4fa3 07				db 6 + 1 
4fa4 .. 00			db "FORMAT",0              
4fab				endm 
# End of macro CWHEAD
4fab			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4fab					; TODO if current block id for stream is zero then push true else false 
4fab				 
4fab				if DEBUG_STORESE 
4fab					DMARK "FOR" 
4fab f5				push af  
4fac 3a c0 4f			ld a, (.dmark)  
4faf 32 b4 fe			ld (debug_mark),a  
4fb2 3a c1 4f			ld a, (.dmark+1)  
4fb5 32 b5 fe			ld (debug_mark+1),a  
4fb8 3a c2 4f			ld a, (.dmark+2)  
4fbb 32 b6 fe			ld (debug_mark+2),a  
4fbe 18 03			jr .pastdmark  
4fc0 ..			.dmark: db "FOR"  
4fc3 f1			.pastdmark: pop af  
4fc4			endm  
# End of macro DMARK
4fc4					CALLMONITOR 
4fc4 cd 46 18			call break_point_state  
4fc7				endm  
# End of macro CALLMONITOR
4fc7				endif 
4fc7					; Wipes the bank check flags to cause a reformat on next block 0 read 
4fc7			 
4fc7 21 01 00				ld hl, 1 
4fca 3e 00				ld a, 0 
4fcc cd d6 01				call se_writebyte 
4fcf			 
4fcf				if DEBUG_STORESE 
4fcf					DMARK "FO0" 
4fcf f5				push af  
4fd0 3a e4 4f			ld a, (.dmark)  
4fd3 32 b4 fe			ld (debug_mark),a  
4fd6 3a e5 4f			ld a, (.dmark+1)  
4fd9 32 b5 fe			ld (debug_mark+1),a  
4fdc 3a e6 4f			ld a, (.dmark+2)  
4fdf 32 b6 fe			ld (debug_mark+2),a  
4fe2 18 03			jr .pastdmark  
4fe4 ..			.dmark: db "FO0"  
4fe7 f1			.pastdmark: pop af  
4fe8			endm  
# End of macro DMARK
4fe8					CALLMONITOR 
4fe8 cd 46 18			call break_point_state  
4feb				endm  
# End of macro CALLMONITOR
4feb				endif 
4feb					; force bank init 
4feb			 
4feb cd 82 04				call storage_get_block_0 
4fee					 
4fee				       NEXTW 
4fee c3 28 22			jp macro_next 
4ff1				endm 
# End of macro NEXTW
4ff1			.LABEL: 
4ff1				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4ff1 6d				db WORD_SYS_CORE+89             
4ff2 3f 50			dw .STOREPAGE            
4ff4 06				db 5 + 1 
4ff5 .. 00			db "LABEL",0              
4ffb				endm 
# End of macro CWHEAD
4ffb			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4ffb					; TODO test to see if bank is selected 
4ffb				 
4ffb					if DEBUG_FORTH_WORDS_KEY 
4ffb						DMARK "LBL" 
4ffb f5				push af  
4ffc 3a 10 50			ld a, (.dmark)  
4fff 32 b4 fe			ld (debug_mark),a  
5002 3a 11 50			ld a, (.dmark+1)  
5005 32 b5 fe			ld (debug_mark+1),a  
5008 3a 12 50			ld a, (.dmark+2)  
500b 32 b6 fe			ld (debug_mark+2),a  
500e 18 03			jr .pastdmark  
5010 ..			.dmark: db "LBL"  
5013 f1			.pastdmark: pop af  
5014			endm  
# End of macro DMARK
5014						CALLMONITOR 
5014 cd 46 18			call break_point_state  
5017				endm  
# End of macro CALLMONITOR
5017					endif 
5017			;	if DEBUG_STORESE 
5017			;		DMARK "LBL" 
5017			;		CALLMONITOR 
5017			;	endif 
5017					FORTH_DSP_VALUEHL 
5017 cd b1 20			call macro_dsp_valuehl 
501a				endm 
# End of macro FORTH_DSP_VALUEHL
501a					;v5FORTH_DSP_VALUE 
501a					 
501a			;		push hl 
501a					FORTH_DSP_POP 
501a cd 69 21			call macro_forth_dsp_pop 
501d				endm 
# End of macro FORTH_DSP_POP
501d			;		pop hl 
501d			 
501d			;v5		inc hl   ; move past the type marker 
501d			 
501d				if DEBUG_STORESE 
501d					DMARK "LBl" 
501d f5				push af  
501e 3a 32 50			ld a, (.dmark)  
5021 32 b4 fe			ld (debug_mark),a  
5024 3a 33 50			ld a, (.dmark+1)  
5027 32 b5 fe			ld (debug_mark+1),a  
502a 3a 34 50			ld a, (.dmark+2)  
502d 32 b6 fe			ld (debug_mark+2),a  
5030 18 03			jr .pastdmark  
5032 ..			.dmark: db "LBl"  
5035 f1			.pastdmark: pop af  
5036			endm  
# End of macro DMARK
5036					CALLMONITOR 
5036 cd 46 18			call break_point_state  
5039				endm  
# End of macro CALLMONITOR
5039				endif 
5039 cd a6 05				call storage_label 
503c			 
503c				       NEXTW 
503c c3 28 22			jp macro_next 
503f				endm 
# End of macro NEXTW
503f			.STOREPAGE: 
503f				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
503f 6d				db WORD_SYS_CORE+89             
5040 72 50			dw .LABELS            
5042 0a				db 9 + 1 
5043 .. 00			db "STOREPAGE",0              
504d				endm 
# End of macro CWHEAD
504d			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
504d					; TODO test to see if bank is selected 
504d				 
504d					if DEBUG_FORTH_WORDS_KEY 
504d						DMARK "STP" 
504d f5				push af  
504e 3a 62 50			ld a, (.dmark)  
5051 32 b4 fe			ld (debug_mark),a  
5054 3a 63 50			ld a, (.dmark+1)  
5057 32 b5 fe			ld (debug_mark+1),a  
505a 3a 64 50			ld a, (.dmark+2)  
505d 32 b6 fe			ld (debug_mark+2),a  
5060 18 03			jr .pastdmark  
5062 ..			.dmark: db "STP"  
5065 f1			.pastdmark: pop af  
5066			endm  
# End of macro DMARK
5066						CALLMONITOR 
5066 cd 46 18			call break_point_state  
5069				endm  
# End of macro CALLMONITOR
5069					endif 
5069			;	if DEBUG_STORESE 
5069			;		DMARK "STP" 
5069			;		CALLMONITOR 
5069			;	endif 
5069			 
5069 21 07 fc			ld hl, store_page 
506c cd ba 1e			call forth_push_numhl 
506f			 
506f			 
506f				       NEXTW 
506f c3 28 22			jp macro_next 
5072				endm 
# End of macro NEXTW
5072			.LABELS: 
5072				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5072 6d				db WORD_SYS_CORE+89             
5073 fc 50			dw .SCONST1            
5075 07				db 6 + 1 
5076 .. 00			db "LABELS",0              
507d				endm 
# End of macro CWHEAD
507d			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
507d					;  
507d			 
507d					; save the current device selected to restore afterwards 
507d				 
507d 3a f0 fb				ld a, (spi_device) 
5080 f5					push af 
5081			 
5081			 
5081					; run through each of the banks 
5081			 
5081 21 01 00				ld hl, 1 
5084 cd ba 1e				call forth_push_numhl 
5087 3e ff				ld a, SPI_CE_HIGH 
5089 cb 87				res SPI_CE0, a 
508b 32 f0 fb				ld (spi_device), a 
508e cd 82 04				call storage_get_block_0 
5091 21 0a fc				ld hl, store_page+3 
5094 cd 28 1f				call forth_push_str 
5097			 
5097					 
5097 21 02 00				ld hl, 2 
509a cd ba 1e				call forth_push_numhl 
509d 3e ff				ld a, SPI_CE_HIGH 
509f cb 8f				res SPI_CE1, a 
50a1 32 f0 fb				ld (spi_device), a 
50a4 cd 82 04				call storage_get_block_0 
50a7 21 0a fc				ld hl, store_page+3 
50aa cd 28 1f				call forth_push_str 
50ad			 
50ad					 
50ad 21 03 00				ld hl, 3 
50b0 cd ba 1e				call forth_push_numhl 
50b3 3e ff				ld a, SPI_CE_HIGH 
50b5 cb 97				res SPI_CE2, a 
50b7 32 f0 fb				ld (spi_device), a 
50ba cd 82 04				call storage_get_block_0 
50bd 21 0a fc				ld hl, store_page+3 
50c0 cd 28 1f				call forth_push_str 
50c3			 
50c3			 
50c3 21 04 00				ld hl, 4 
50c6 cd ba 1e				call forth_push_numhl 
50c9 3e ff				ld a, SPI_CE_HIGH 
50cb cb 9f				res SPI_CE3, a 
50cd 32 f0 fb				ld (spi_device), a 
50d0 cd 82 04				call storage_get_block_0 
50d3 21 0a fc				ld hl, store_page+3 
50d6 cd 28 1f				call forth_push_str 
50d9			 
50d9					 
50d9			 
50d9 21 05 00				ld hl, 5 
50dc cd ba 1e				call forth_push_numhl 
50df 3e ff				ld a, SPI_CE_HIGH 
50e1 cb a7				res SPI_CE4, a 
50e3 32 f0 fb				ld (spi_device), a 
50e6 cd 82 04				call storage_get_block_0 
50e9 21 0a fc				ld hl, store_page+3 
50ec cd 28 1f				call forth_push_str 
50ef			 
50ef					 
50ef					; push fixed count of storage devices (on board) for now 
50ef			 
50ef 21 05 00				ld hl, 5 
50f2 cd ba 1e				call forth_push_numhl 
50f5			 
50f5					; restore selected device  
50f5				 
50f5 f1					pop af 
50f6 32 f0 fb				ld (spi_device), a 
50f9			 
50f9				       NEXTW 
50f9 c3 28 22			jp macro_next 
50fc				endm 
# End of macro NEXTW
50fc			 
50fc			.SCONST1: 
50fc				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
50fc 6d				db WORD_SYS_CORE+89             
50fd 13 51			dw .SCONST2            
50ff 07				db 6 + 1 
5100 .. 00			db "FILEID",0              
5107				endm 
# End of macro CWHEAD
5107			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5107 3a f6 fb				ld a, (store_filecache) 
510a 26 00				ld h, 0 
510c 6f					ld l, a 
510d cd ba 1e				call forth_push_numhl 
5110					NEXTW 
5110 c3 28 22			jp macro_next 
5113				endm 
# End of macro NEXTW
5113			.SCONST2: 
5113				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5113 6d				db WORD_SYS_CORE+89             
5114 2b 51			dw .SCONST3            
5116 08				db 7 + 1 
5117 .. 00			db "FILEEXT",0              
511f				endm 
# End of macro CWHEAD
511f			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
511f 3a f9 fb				ld a, (store_openext) 
5122 26 00				ld h, 0 
5124 6f					ld l, a 
5125 cd ba 1e				call forth_push_numhl 
5128					NEXTW 
5128 c3 28 22			jp macro_next 
512b				endm 
# End of macro NEXTW
512b			.SCONST3: 
512b				CWHEAD .ENDSTORAGE 89 "FILEMAX" 7 WORD_FLAG_CODE 
512b 6d				db WORD_SYS_CORE+89             
512c 43 51			dw .ENDSTORAGE            
512e 08				db 7 + 1 
512f .. 00			db "FILEMAX",0              
5137				endm 
# End of macro CWHEAD
5137			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5137 3a f8 fb				ld a, (store_openmaxext) 
513a 26 00				ld h, 0 
513c 6f					ld l, a 
513d cd ba 1e				call forth_push_numhl 
5140					NEXTW 
5140 c3 28 22			jp macro_next 
5143				endm 
# End of macro NEXTW
5143			.ENDSTORAGE: 
5143			; eof 
# End of file forth_words_storage.asm
5143			endif 
5143				include "forth_words_device.asm" 
5143			; Device related words 
5143			 
5143			; | ## Device Words 
5143			 
5143			if SOUND_ENABLE 
5143			.NOTE: 
5143				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5143			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5143					if DEBUG_FORTH_WORDS_KEY 
5143						DMARK "NTE" 
5143						CALLMONITOR 
5143					endif 
5143			 
5143				 
5143			 
5143					NEXTW 
5143			.AFTERSOUND: 
5143			endif 
5143			 
5143			 
5143			USE_GPIO: equ 0 
5143			 
5143			if USE_GPIO 
5143			.GP1: 
5143				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5143			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5143					NEXTW 
5143			.GP2: 
5143				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5143			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5143			 
5143					NEXTW 
5143			 
5143			.GP3: 
5143				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5143			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5143			 
5143					NEXTW 
5143			 
5143			.GP4: 
5143				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5143			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5143			 
5143					NEXTW 
5143			.SIN: 
5143			 
5143			 
5143			endif 
5143			 
5143			 
5143				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5143 33				db WORD_SYS_CORE+31             
5144 78 51			dw .SOUT            
5146 03				db 2 + 1 
5147 .. 00			db "IN",0              
514a				endm 
# End of macro CWHEAD
514a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
514a					if DEBUG_FORTH_WORDS_KEY 
514a						DMARK "IN." 
514a f5				push af  
514b 3a 5f 51			ld a, (.dmark)  
514e 32 b4 fe			ld (debug_mark),a  
5151 3a 60 51			ld a, (.dmark+1)  
5154 32 b5 fe			ld (debug_mark+1),a  
5157 3a 61 51			ld a, (.dmark+2)  
515a 32 b6 fe			ld (debug_mark+2),a  
515d 18 03			jr .pastdmark  
515f ..			.dmark: db "IN."  
5162 f1			.pastdmark: pop af  
5163			endm  
# End of macro DMARK
5163						CALLMONITOR 
5163 cd 46 18			call break_point_state  
5166				endm  
# End of macro CALLMONITOR
5166					endif 
5166					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5166 cd b1 20			call macro_dsp_valuehl 
5169				endm 
# End of macro FORTH_DSP_VALUEHL
5169			 
5169 e5					push hl 
516a			 
516a					; destroy value TOS 
516a			 
516a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
516a cd 69 21			call macro_forth_dsp_pop 
516d				endm 
# End of macro FORTH_DSP_POP
516d			 
516d					; one value on hl get other one back 
516d			 
516d c1					pop bc 
516e			 
516e					; do the sub 
516e			;		ex de, hl 
516e			 
516e ed 68				in l,(c) 
5170			 
5170					; save it 
5170			 
5170 26 00				ld h,0 
5172			 
5172					; TODO push value back onto stack for another op etc 
5172			 
5172 cd ba 1e				call forth_push_numhl 
5175					NEXTW 
5175 c3 28 22			jp macro_next 
5178				endm 
# End of macro NEXTW
5178			.SOUT: 
5178				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5178 34				db WORD_SYS_CORE+32             
5179 cb 51			dw .SPIO            
517b 04				db 3 + 1 
517c .. 00			db "OUT",0              
5180				endm 
# End of macro CWHEAD
5180			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5180					if DEBUG_FORTH_WORDS_KEY 
5180						DMARK "OUT" 
5180 f5				push af  
5181 3a 95 51			ld a, (.dmark)  
5184 32 b4 fe			ld (debug_mark),a  
5187 3a 96 51			ld a, (.dmark+1)  
518a 32 b5 fe			ld (debug_mark+1),a  
518d 3a 97 51			ld a, (.dmark+2)  
5190 32 b6 fe			ld (debug_mark+2),a  
5193 18 03			jr .pastdmark  
5195 ..			.dmark: db "OUT"  
5198 f1			.pastdmark: pop af  
5199			endm  
# End of macro DMARK
5199						CALLMONITOR 
5199 cd 46 18			call break_point_state  
519c				endm  
# End of macro CALLMONITOR
519c					endif 
519c			 
519c					; get port 
519c			 
519c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
519c cd b1 20			call macro_dsp_valuehl 
519f				endm 
# End of macro FORTH_DSP_VALUEHL
519f			 
519f e5					push hl 
51a0			 
51a0					; destroy value TOS 
51a0			 
51a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51a0 cd 69 21			call macro_forth_dsp_pop 
51a3				endm 
# End of macro FORTH_DSP_POP
51a3			 
51a3					; get byte to send 
51a3			 
51a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51a3 cd b1 20			call macro_dsp_valuehl 
51a6				endm 
# End of macro FORTH_DSP_VALUEHL
51a6			 
51a6			;		push hl 
51a6			 
51a6					; destroy value TOS 
51a6			 
51a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51a6 cd 69 21			call macro_forth_dsp_pop 
51a9				endm 
# End of macro FORTH_DSP_POP
51a9			 
51a9					; one value on hl get other one back 
51a9			 
51a9			;		pop hl 
51a9			 
51a9 c1					pop bc 
51aa			 
51aa					if DEBUG_FORTH_WORDS 
51aa						DMARK "OUT" 
51aa f5				push af  
51ab 3a bf 51			ld a, (.dmark)  
51ae 32 b4 fe			ld (debug_mark),a  
51b1 3a c0 51			ld a, (.dmark+1)  
51b4 32 b5 fe			ld (debug_mark+1),a  
51b7 3a c1 51			ld a, (.dmark+2)  
51ba 32 b6 fe			ld (debug_mark+2),a  
51bd 18 03			jr .pastdmark  
51bf ..			.dmark: db "OUT"  
51c2 f1			.pastdmark: pop af  
51c3			endm  
# End of macro DMARK
51c3						CALLMONITOR 
51c3 cd 46 18			call break_point_state  
51c6				endm  
# End of macro CALLMONITOR
51c6					endif 
51c6			 
51c6 ed 69				out (c), l 
51c8			 
51c8					NEXTW 
51c8 c3 28 22			jp macro_next 
51cb				endm 
# End of macro NEXTW
51cb			 
51cb			 
51cb			.SPIO: 
51cb			 
51cb			if STORAGE_SE 
51cb				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
51cb 51				db WORD_SYS_CORE+61             
51cc dc 51			dw .SPICEH            
51ce 07				db 6 + 1 
51cf .. 00			db "SPICEL",0              
51d6				endm 
# End of macro CWHEAD
51d6			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
51d6			 
51d6 cd 84 01				call spi_ce_low 
51d9			    NEXTW 
51d9 c3 28 22			jp macro_next 
51dc				endm 
# End of macro NEXTW
51dc			 
51dc			.SPICEH: 
51dc				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
51dc 51				db WORD_SYS_CORE+61             
51dd ed 51			dw .SPIOb            
51df 07				db 6 + 1 
51e0 .. 00			db "SPICEH",0              
51e7				endm 
# End of macro CWHEAD
51e7			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
51e7			 
51e7 cd 73 01				call spi_ce_high 
51ea			    NEXTW 
51ea c3 28 22			jp macro_next 
51ed				endm 
# End of macro NEXTW
51ed			 
51ed			 
51ed			.SPIOb: 
51ed			 
51ed				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
51ed 51				db WORD_SYS_CORE+61             
51ee 03 52			dw .SPII            
51f0 05				db 4 + 1 
51f1 .. 00			db "SPIO",0              
51f6				endm 
# End of macro CWHEAD
51f6			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
51f6			 
51f6					; get port 
51f6			 
51f6			 
51f6					; get byte to send 
51f6			 
51f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51f6 cd b1 20			call macro_dsp_valuehl 
51f9				endm 
# End of macro FORTH_DSP_VALUEHL
51f9			 
51f9			;		push hl    ; u1  
51f9			 
51f9					; destroy value TOS 
51f9			 
51f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51f9 cd 69 21			call macro_forth_dsp_pop 
51fc				endm 
# End of macro FORTH_DSP_POP
51fc			 
51fc					; one value on hl get other one back 
51fc			 
51fc			;		pop hl   ; u2 - addr 
51fc			 
51fc					; TODO Send SPI byte 
51fc			 
51fc 7d					ld a, l 
51fd cd a8 00				call spi_send_byte 
5200			 
5200					NEXTW 
5200 c3 28 22			jp macro_next 
5203				endm 
# End of macro NEXTW
5203			 
5203			.SPII: 
5203				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5203 52				db WORD_SYS_CORE+62             
5204 18 52			dw .SESEL            
5206 06				db 5 + 1 
5207 .. 00			db "SPII",0              
520c				endm 
# End of macro CWHEAD
520c			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
520c			 
520c					; TODO Get SPI byte 
520c			 
520c cd c9 00				call spi_read_byte 
520f			 
520f 26 00				ld h, 0 
5211 6f					ld l, a 
5212 cd ba 1e				call forth_push_numhl 
5215			 
5215					NEXTW 
5215 c3 28 22			jp macro_next 
5218				endm 
# End of macro NEXTW
5218			 
5218			 
5218			 
5218			.SESEL: 
5218				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5218 66				db WORD_SYS_CORE+82             
5219 bc 52			dw .CARTDEV            
521b 05				db 4 + 1 
521c .. 00			db "BANK",0              
5221				endm 
# End of macro CWHEAD
5221			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5221					if DEBUG_FORTH_WORDS_KEY 
5221						DMARK "BNK" 
5221 f5				push af  
5222 3a 36 52			ld a, (.dmark)  
5225 32 b4 fe			ld (debug_mark),a  
5228 3a 37 52			ld a, (.dmark+1)  
522b 32 b5 fe			ld (debug_mark+1),a  
522e 3a 38 52			ld a, (.dmark+2)  
5231 32 b6 fe			ld (debug_mark+2),a  
5234 18 03			jr .pastdmark  
5236 ..			.dmark: db "BNK"  
5239 f1			.pastdmark: pop af  
523a			endm  
# End of macro DMARK
523a						CALLMONITOR 
523a cd 46 18			call break_point_state  
523d				endm  
# End of macro CALLMONITOR
523d					endif 
523d			 
523d 3e ff				ld a, 255 
523f 32 f3 fb				ld (spi_cartdev), a 
5242			 
5242					; get bank 
5242			 
5242					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5242 cd b1 20			call macro_dsp_valuehl 
5245				endm 
# End of macro FORTH_DSP_VALUEHL
5245			 
5245			;		push hl 
5245			 
5245					; destroy value TOS 
5245			 
5245					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5245 cd 69 21			call macro_forth_dsp_pop 
5248				endm 
# End of macro FORTH_DSP_POP
5248			 
5248					; one value on hl get other one back 
5248			 
5248			;		pop hl 
5248			 
5248			 
5248 0e ff				ld c, SPI_CE_HIGH 
524a 06 30				ld b, '0'    ; human readable bank number 
524c			 
524c 7d					ld a, l 
524d			 
524d					if DEBUG_FORTH_WORDS 
524d						DMARK "BNK" 
524d f5				push af  
524e 3a 62 52			ld a, (.dmark)  
5251 32 b4 fe			ld (debug_mark),a  
5254 3a 63 52			ld a, (.dmark+1)  
5257 32 b5 fe			ld (debug_mark+1),a  
525a 3a 64 52			ld a, (.dmark+2)  
525d 32 b6 fe			ld (debug_mark+2),a  
5260 18 03			jr .pastdmark  
5262 ..			.dmark: db "BNK"  
5265 f1			.pastdmark: pop af  
5266			endm  
# End of macro DMARK
5266						CALLMONITOR 
5266 cd 46 18			call break_point_state  
5269				endm  
# End of macro CALLMONITOR
5269					endif 
5269			 
5269					; active low 
5269			 
5269 fe 00				cp 0 
526b 28 28				jr z, .bset 
526d fe 01				cp 1 
526f 20 04				jr nz, .b2 
5271 cb 81				res 0, c 
5273 06 31				ld b, '1'    ; human readable bank number 
5275 fe 02		.b2:		cp 2 
5277 20 04				jr nz, .b3 
5279 cb 89				res 1, c 
527b 06 32				ld b, '2'    ; human readable bank number 
527d fe 03		.b3:		cp 3 
527f 20 04				jr nz, .b4 
5281 cb 91				res 2, c 
5283 06 33				ld b, '3'    ; human readable bank number 
5285 fe 04		.b4:		cp 4 
5287 20 04				jr nz, .b5 
5289 cb 99				res 3, c 
528b 06 34				ld b, '4'    ; human readable bank number 
528d fe 05		.b5:		cp 5 
528f 20 04				jr nz, .bset 
5291 cb a1				res 4, c 
5293 06 35				ld b, '5'    ; human readable bank number 
5295			 
5295			.bset: 
5295 79					ld a, c 
5296 32 f0 fb				ld (spi_device),a 
5299 78					ld a, b 
529a 32 ef fb				ld (spi_device_id),a 
529d					if DEBUG_FORTH_WORDS 
529d						DMARK "BN2" 
529d f5				push af  
529e 3a b2 52			ld a, (.dmark)  
52a1 32 b4 fe			ld (debug_mark),a  
52a4 3a b3 52			ld a, (.dmark+1)  
52a7 32 b5 fe			ld (debug_mark+1),a  
52aa 3a b4 52			ld a, (.dmark+2)  
52ad 32 b6 fe			ld (debug_mark+2),a  
52b0 18 03			jr .pastdmark  
52b2 ..			.dmark: db "BN2"  
52b5 f1			.pastdmark: pop af  
52b6			endm  
# End of macro DMARK
52b6						CALLMONITOR 
52b6 cd 46 18			call break_point_state  
52b9				endm  
# End of macro CALLMONITOR
52b9					endif 
52b9			 
52b9					NEXTW 
52b9 c3 28 22			jp macro_next 
52bc				endm 
# End of macro NEXTW
52bc			 
52bc			.CARTDEV: 
52bc				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
52bc 66				db WORD_SYS_CORE+82             
52bd 65 53			dw .ENDDEVICE            
52bf 08				db 7 + 1 
52c0 .. 00			db "CARTDEV",0              
52c8				endm 
# End of macro CWHEAD
52c8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
52c8					if DEBUG_FORTH_WORDS_KEY 
52c8						DMARK "CDV" 
52c8 f5				push af  
52c9 3a dd 52			ld a, (.dmark)  
52cc 32 b4 fe			ld (debug_mark),a  
52cf 3a de 52			ld a, (.dmark+1)  
52d2 32 b5 fe			ld (debug_mark+1),a  
52d5 3a df 52			ld a, (.dmark+2)  
52d8 32 b6 fe			ld (debug_mark+2),a  
52db 18 03			jr .pastdmark  
52dd ..			.dmark: db "CDV"  
52e0 f1			.pastdmark: pop af  
52e1			endm  
# End of macro DMARK
52e1						CALLMONITOR 
52e1 cd 46 18			call break_point_state  
52e4				endm  
# End of macro CALLMONITOR
52e4					endif 
52e4			 
52e4					; disable se storage bank selection 
52e4			 
52e4 3e ff				ld a, SPI_CE_HIGH		; ce high 
52e6 32 f0 fb				ld (spi_device), a 
52e9			 
52e9					; get bank 
52e9			 
52e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52e9 cd b1 20			call macro_dsp_valuehl 
52ec				endm 
# End of macro FORTH_DSP_VALUEHL
52ec			 
52ec			;		push hl 
52ec			 
52ec					; destroy value TOS 
52ec			 
52ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52ec cd 69 21			call macro_forth_dsp_pop 
52ef				endm 
# End of macro FORTH_DSP_POP
52ef			 
52ef					; one value on hl get other one back 
52ef			 
52ef			;		pop hl 
52ef			 
52ef					; active low 
52ef			 
52ef 0e ff				ld c, 255 
52f1			 
52f1 7d					ld a, l 
52f2					if DEBUG_FORTH_WORDS 
52f2						DMARK "CDV" 
52f2 f5				push af  
52f3 3a 07 53			ld a, (.dmark)  
52f6 32 b4 fe			ld (debug_mark),a  
52f9 3a 08 53			ld a, (.dmark+1)  
52fc 32 b5 fe			ld (debug_mark+1),a  
52ff 3a 09 53			ld a, (.dmark+2)  
5302 32 b6 fe			ld (debug_mark+2),a  
5305 18 03			jr .pastdmark  
5307 ..			.dmark: db "CDV"  
530a f1			.pastdmark: pop af  
530b			endm  
# End of macro DMARK
530b						CALLMONITOR 
530b cd 46 18			call break_point_state  
530e				endm  
# End of macro CALLMONITOR
530e					endif 
530e fe 00				cp 0 
5310 28 30				jr z, .cset 
5312 fe 01				cp 1 
5314 20 02				jr nz, .c2 
5316 cb 81				res 0, c 
5318 fe 02		.c2:		cp 2 
531a 20 02				jr nz, .c3 
531c cb 89				res 1, c 
531e fe 03		.c3:		cp 3 
5320 20 02				jr nz, .c4 
5322 cb 91				res 2, c 
5324 fe 04		.c4:		cp 4 
5326 20 02				jr nz, .c5 
5328 cb 99				res 3, c 
532a fe 05		.c5:		cp 5 
532c 20 02				jr nz, .c6 
532e cb a1				res 4, c 
5330 fe 06		.c6:		cp 6 
5332 20 02				jr nz, .c7 
5334 cb a9				res 5, c 
5336 fe 07		.c7:		cp 7 
5338 20 02				jr nz, .c8 
533a cb b1				res 6, c 
533c fe 08		.c8:		cp 8 
533e 20 02				jr nz, .cset 
5340 cb b9				res 7, c 
5342 79			.cset:		ld a, c 
5343 32 f3 fb				ld (spi_cartdev),a 
5346			 
5346					if DEBUG_FORTH_WORDS 
5346						DMARK "CD2" 
5346 f5				push af  
5347 3a 5b 53			ld a, (.dmark)  
534a 32 b4 fe			ld (debug_mark),a  
534d 3a 5c 53			ld a, (.dmark+1)  
5350 32 b5 fe			ld (debug_mark+1),a  
5353 3a 5d 53			ld a, (.dmark+2)  
5356 32 b6 fe			ld (debug_mark+2),a  
5359 18 03			jr .pastdmark  
535b ..			.dmark: db "CD2"  
535e f1			.pastdmark: pop af  
535f			endm  
# End of macro DMARK
535f						CALLMONITOR 
535f cd 46 18			call break_point_state  
5362				endm  
# End of macro CALLMONITOR
5362					endif 
5362					NEXTW 
5362 c3 28 22			jp macro_next 
5365				endm 
# End of macro NEXTW
5365			endif 
5365			 
5365			.ENDDEVICE: 
5365			; eof 
5365			 
# End of file forth_words_device.asm
5365			 
5365			; var handler 
5365			 
5365			 
5365			.VARS: 
5365				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5365 78				db WORD_SYS_CORE+100             
5366 7d 53			dw .V0Q            
5368 04				db 3 + 1 
5369 .. 00			db "V0!",0              
536d				endm 
# End of macro CWHEAD
536d			;| V0! ( u1 -- )  Store value to v0  | DONE 
536d			 
536d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
536d cd b1 20			call macro_dsp_valuehl 
5370				endm 
# End of macro FORTH_DSP_VALUEHL
5370			 
5370 11 b8 fb				ld de, cli_var_array 
5373			 
5373 eb					ex de, hl 
5374 73					ld (hl), e 
5375 23					inc hl 
5376 72					ld (hl), d 
5377			 
5377					; destroy value TOS 
5377			 
5377					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5377 cd 69 21			call macro_forth_dsp_pop 
537a				endm 
# End of macro FORTH_DSP_POP
537a			 
537a				       NEXTW 
537a c3 28 22			jp macro_next 
537d				endm 
# End of macro NEXTW
537d			.V0Q: 
537d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
537d 79				db WORD_SYS_CORE+101             
537e 8e 53			dw .V1S            
5380 04				db 3 + 1 
5381 .. 00			db "V0@",0              
5385				endm 
# End of macro CWHEAD
5385			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5385 2a b8 fb				ld hl, (cli_var_array) 
5388 cd ba 1e				call forth_push_numhl 
538b			 
538b				       NEXTW 
538b c3 28 22			jp macro_next 
538e				endm 
# End of macro NEXTW
538e			.V1S: 
538e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
538e 7a				db WORD_SYS_CORE+102             
538f a6 53			dw .V1Q            
5391 04				db 3 + 1 
5392 .. 00			db "V1!",0              
5396				endm 
# End of macro CWHEAD
5396			;| V1! ( u1 -- )  Store value to v1 | DONE 
5396					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5396 cd b1 20			call macro_dsp_valuehl 
5399				endm 
# End of macro FORTH_DSP_VALUEHL
5399			 
5399 11 ba fb				ld de, cli_var_array+2 
539c				 
539c eb					ex de, hl 
539d 73					ld (hl), e 
539e 23					inc hl 
539f 72					ld (hl), d 
53a0			 
53a0					; destroy value TOS 
53a0			 
53a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53a0 cd 69 21			call macro_forth_dsp_pop 
53a3				endm 
# End of macro FORTH_DSP_POP
53a3				       NEXTW 
53a3 c3 28 22			jp macro_next 
53a6				endm 
# End of macro NEXTW
53a6			.V1Q: 
53a6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
53a6 7b				db WORD_SYS_CORE+103             
53a7 b7 53			dw .V2S            
53a9 04				db 3 + 1 
53aa .. 00			db "V1@",0              
53ae				endm 
# End of macro CWHEAD
53ae			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
53ae 2a ba fb				ld hl, (cli_var_array+2) 
53b1 cd ba 1e				call forth_push_numhl 
53b4				       NEXTW 
53b4 c3 28 22			jp macro_next 
53b7				endm 
# End of macro NEXTW
53b7			.V2S: 
53b7				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
53b7 7c				db WORD_SYS_CORE+104             
53b8 cf 53			dw .V2Q            
53ba 04				db 3 + 1 
53bb .. 00			db "V2!",0              
53bf				endm 
# End of macro CWHEAD
53bf			;| V2! ( u1 -- )  Store value to v2 | DONE 
53bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53bf cd b1 20			call macro_dsp_valuehl 
53c2				endm 
# End of macro FORTH_DSP_VALUEHL
53c2			 
53c2 11 bc fb				ld de, cli_var_array+4 
53c5				 
53c5 eb					ex de, hl 
53c6 73					ld (hl), e 
53c7 23					inc hl 
53c8 72					ld (hl), d 
53c9			 
53c9					; destroy value TOS 
53c9			 
53c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53c9 cd 69 21			call macro_forth_dsp_pop 
53cc				endm 
# End of macro FORTH_DSP_POP
53cc				       NEXTW 
53cc c3 28 22			jp macro_next 
53cf				endm 
# End of macro NEXTW
53cf			.V2Q: 
53cf				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
53cf 7d				db WORD_SYS_CORE+105             
53d0 e0 53			dw .V3S            
53d2 04				db 3 + 1 
53d3 .. 00			db "V2@",0              
53d7				endm 
# End of macro CWHEAD
53d7			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
53d7 2a bc fb				ld hl, (cli_var_array+4) 
53da cd ba 1e				call forth_push_numhl 
53dd				       NEXTW 
53dd c3 28 22			jp macro_next 
53e0				endm 
# End of macro NEXTW
53e0			.V3S: 
53e0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
53e0 7c				db WORD_SYS_CORE+104             
53e1 f8 53			dw .V3Q            
53e3 04				db 3 + 1 
53e4 .. 00			db "V3!",0              
53e8				endm 
# End of macro CWHEAD
53e8			;| V3! ( u1 -- )  Store value to v3 | DONE 
53e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53e8 cd b1 20			call macro_dsp_valuehl 
53eb				endm 
# End of macro FORTH_DSP_VALUEHL
53eb			 
53eb 11 be fb				ld de, cli_var_array+6 
53ee				 
53ee eb					ex de, hl 
53ef 73					ld (hl), e 
53f0 23					inc hl 
53f1 72					ld (hl), d 
53f2			 
53f2					; destroy value TOS 
53f2			 
53f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53f2 cd 69 21			call macro_forth_dsp_pop 
53f5				endm 
# End of macro FORTH_DSP_POP
53f5				       NEXTW 
53f5 c3 28 22			jp macro_next 
53f8				endm 
# End of macro NEXTW
53f8			.V3Q: 
53f8				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
53f8 7d				db WORD_SYS_CORE+105             
53f9 09 54			dw .END            
53fb 04				db 3 + 1 
53fc .. 00			db "V3@",0              
5400				endm 
# End of macro CWHEAD
5400			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5400 2a be fb				ld hl, (cli_var_array+6) 
5403 cd ba 1e				call forth_push_numhl 
5406				       NEXTW 
5406 c3 28 22			jp macro_next 
5409				endm 
# End of macro NEXTW
5409			 
5409			 
5409			 
5409			 
5409			 
5409			; end of dict marker 
5409			 
5409 00			.END:    db WORD_SYS_END 
540a 00 00			dw 0 
540c 00				db 0 
540d			 
540d			; use to jp here for user dict words to save on macro expansion  
540d			 
540d			user_dict_next: 
540d				NEXTW 
540d c3 28 22			jp macro_next 
5410				endm 
# End of macro NEXTW
5410			 
5410			 
5410			user_exec: 
5410				;    ld hl, <word code> 
5410				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5410				;    call forthexec 
5410				;    jp user_dict_next   (NEXT) 
5410			        ;    <word code bytes> 
5410 eb				ex de, hl 
5411 2a 86 f6			ld hl,(os_tok_ptr) 
5414				 
5414				FORTH_RSP_NEXT 
5414 cd 61 1e			call macro_forth_rsp_next 
5417				endm 
# End of macro FORTH_RSP_NEXT
5417			 
5417			if DEBUG_FORTH_UWORD 
5417						DMARK "UEX" 
5417 f5				push af  
5418 3a 2c 54			ld a, (.dmark)  
541b 32 b4 fe			ld (debug_mark),a  
541e 3a 2d 54			ld a, (.dmark+1)  
5421 32 b5 fe			ld (debug_mark+1),a  
5424 3a 2e 54			ld a, (.dmark+2)  
5427 32 b6 fe			ld (debug_mark+2),a  
542a 18 03			jr .pastdmark  
542c ..			.dmark: db "UEX"  
542f f1			.pastdmark: pop af  
5430			endm  
# End of macro DMARK
5430				CALLMONITOR 
5430 cd 46 18			call break_point_state  
5433				endm  
# End of macro CALLMONITOR
5433			endif 
5433			 
5433			 
5433			 
5433 eb				ex de, hl 
5434 22 86 f6			ld (os_tok_ptr), hl 
5437				 
5437				; Don't use next - Skips the first word in uword. 
5437			 
5437 c3 b9 22			jp exec1 
543a			;	NEXT 
543a			 
543a			 
543a			; eof 
# End of file forth_wordsv4.asm
543a			endif 
543a			;;;;;;;;;;;;;; Debug code 
543a			 
543a			 
543a			;if DEBUG_FORTH_PARSE 
543a .. 00		.nowordfound: db "No match",0 
5443 .. 00		.compword:	db "Comparing word ",0 
5453 .. 00		.nextwordat:	db "Next word at",0 
5460 .. 00		.charmatch:	db "Char match",0 
546b			;endif 
546b			if DEBUG_FORTH_JP 
546b			.foundword:	db "Word match. Exec..",0 
546b			endif 
546b			;if DEBUG_FORTH_PUSH 
546b .. 00		.enddict:	db "Dict end. Push.",0 
547b .. 00		.push_str:	db "Pushing string",0 
548a .. 00		.push_num:	db "Pushing number",0 
5499 .. 00		.data_sp:	db "SP:",0 
549d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
54af .. 00		.wordinde:	db "Word in DE (3/0):",0 
54c1 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
54d3			;endif 
54d3			;if DEBUG_FORTH_MALLOC 
54d3 .. 00		.push_malloc:	db "Malloc address",0 
54e2			;endif 
54e2			 
54e2			 
54e2			 
54e2			; display malloc address and current data stack pointer  
54e2			 
54e2			malloc_error: 
54e2 d5				push de 
54e3 f5				push af 
54e4 e5				push hl 
54e5 cd 95 0c			call clear_display 
54e8 11 0a 55			ld de, .mallocerr 
54eb 3e 00			ld a,0 
54ed			;	ld de,os_word_scratch 
54ed cd a8 0c			call str_at_display 
54f0 3e 11			ld a, display_row_1+17 
54f2 11 b4 fe			ld de, debug_mark 
54f5 cd a8 0c			call str_at_display 
54f8 cd b8 0c			call update_display 
54fb				;call break_point_state 
54fb cd b8 6a			call cin_wait 
54fe			 
54fe 3e 20			ld a, ' ' 
5500 32 76 f3			ld (os_view_disable), a 
5503 e1				pop hl 
5504 f1				pop af 
5505 d1				pop de	 
5506				CALLMONITOR 
5506 cd 46 18			call break_point_state  
5509				endm  
# End of macro CALLMONITOR
5509 c9				ret 
550a			 
550a .. 00		.mallocerr: 	db "Malloc Error",0 
5517			;if DEBUG_FORTH_PUSH 
5517			display_data_sp: 
5517 f5				push af 
5518			 
5518				; see if disabled 
5518			 
5518 3a 76 f3			ld a, (os_view_disable) 
551b fe 2a			cp '*' 
551d 28 67			jr z, .skipdsp 
551f			 
551f e5				push hl 
5520 e5				push hl 
5521 e5			push hl 
5522 cd 95 0c			call clear_display 
5525 e1			pop hl 
5526 7c				ld a,h 
5527 21 8a f6			ld hl, os_word_scratch 
552a cd ca 11			call hexout 
552d e1				pop hl 
552e 7d				ld a,l 
552f 21 8c f6			ld hl, os_word_scratch+2 
5532 cd ca 11			call hexout 
5535 21 8e f6			ld hl, os_word_scratch+4 
5538 3e 00			ld a,0 
553a 77				ld (hl),a 
553b 11 8a f6			ld de,os_word_scratch 
553e 3e 14				ld a, display_row_2 
5540 cd a8 0c				call str_at_display 
5543 11 9d 54			ld de, .wordinhl 
5546 3e 00			ld a, display_row_1 
5548			 
5548 cd a8 0c				call str_at_display 
554b 11 b4 fe			ld de, debug_mark 
554e 3e 11			ld a, display_row_1+17 
5550			 
5550 cd a8 0c				call str_at_display 
5553			 
5553				; display current data stack pointer 
5553 11 99 54			ld de,.data_sp 
5556 3e 1c				ld a, display_row_2 + 8 
5558 cd a8 0c				call str_at_display 
555b			 
555b 2a b2 fb			ld hl,(cli_data_sp) 
555e e5				push hl 
555f 7c				ld a,h 
5560 21 8a f6			ld hl, os_word_scratch 
5563 cd ca 11			call hexout 
5566 e1				pop hl 
5567 7d				ld a,l 
5568 21 8c f6			ld hl, os_word_scratch+2 
556b cd ca 11			call hexout 
556e 21 8e f6			ld hl, os_word_scratch+4 
5571 3e 00			ld a,0 
5573 77				ld (hl),a 
5574 11 8a f6			ld de,os_word_scratch 
5577 3e 1f				ld a, display_row_2 + 11 
5579 cd a8 0c				call str_at_display 
557c			 
557c			 
557c cd b8 0c			call update_display 
557f cd 12 0c			call delay1s 
5582 cd 12 0c			call delay1s 
5585 e1				pop hl 
5586			.skipdsp: 
5586 f1				pop af 
5587 c9				ret 
5588			 
5588			display_data_malloc: 
5588			 
5588 f5				push af 
5589 e5				push hl 
558a e5				push hl 
558b e5			push hl 
558c cd 95 0c			call clear_display 
558f e1			pop hl 
5590 7c				ld a,h 
5591 21 8a f6			ld hl, os_word_scratch 
5594 cd ca 11			call hexout 
5597 e1				pop hl 
5598 7d				ld a,l 
5599 21 8c f6			ld hl, os_word_scratch+2 
559c cd ca 11			call hexout 
559f 21 8e f6			ld hl, os_word_scratch+4 
55a2 3e 00			ld a,0 
55a4 77				ld (hl),a 
55a5 11 8a f6			ld de,os_word_scratch 
55a8 3e 14				ld a, display_row_2 
55aa cd a8 0c				call str_at_display 
55ad 11 d3 54			ld de, .push_malloc 
55b0 3e 00			ld a, display_row_1 
55b2			 
55b2 cd a8 0c				call str_at_display 
55b5			 
55b5				; display current data stack pointer 
55b5 11 99 54			ld de,.data_sp 
55b8 3e 1c				ld a, display_row_2 + 8 
55ba cd a8 0c				call str_at_display 
55bd			 
55bd 2a b2 fb			ld hl,(cli_data_sp) 
55c0 e5				push hl 
55c1 7c				ld a,h 
55c2 21 8a f6			ld hl, os_word_scratch 
55c5 cd ca 11			call hexout 
55c8 e1				pop hl 
55c9 7d				ld a,l 
55ca 21 8c f6			ld hl, os_word_scratch+2 
55cd cd ca 11			call hexout 
55d0 21 8e f6			ld hl, os_word_scratch+4 
55d3 3e 00			ld a,0 
55d5 77				ld (hl),a 
55d6 11 8a f6			ld de,os_word_scratch 
55d9 3e 1f				ld a, display_row_2 + 11 
55db cd a8 0c				call str_at_display 
55de			 
55de cd b8 0c			call update_display 
55e1 cd 12 0c			call delay1s 
55e4 cd 12 0c			call delay1s 
55e7 e1				pop hl 
55e8 f1				pop af 
55e9 c9				ret 
55ea			;endif 
55ea			 
55ea			include "forth_autostart.asm" 
55ea			; list of commands to perform at system start up 
55ea			 
55ea			startcmds: 
55ea			;	dw test11 
55ea			;	dw test12 
55ea			;	dw test13 
55ea			;	dw test14 
55ea			;	dw test15 
55ea			;	dw test16 
55ea			;	dw test17 
55ea			;	dw ifthtest1 
55ea			;	dw ifthtest2 
55ea			;	dw ifthtest3 
55ea			;	dw mmtest1 
55ea			;	dw mmtest2 
55ea			;	dw mmtest3 
55ea			;	dw mmtest4 
55ea			;	dw mmtest5 
55ea			;	dw mmtest6 
55ea			;	dw iftest1 
55ea			;	dw iftest2 
55ea			;	dw iftest3 
55ea			;	dw looptest1 
55ea			;	dw looptest2 
55ea			;	dw test1 
55ea			;	dw test2 
55ea			;	dw test3 
55ea			;	dw test4 
55ea			;	dw game2r 
55ea			;	dw game2b1 
55ea			;	dw game2b2 
55ea			 
55ea				; start up words that are actually useful 
55ea			 
55ea 4a 56			dw longread 
55ec 70 56			dw clrstack 
55ee a3 56			dw type 
55f0 93 58			dw stest 
55f2 c7 56			dw strncpy 
55f4 29 58			dw list 
55f6 28 57			dw start1 
55f8 3a 57			dw start2 
55fa			;	dw start3 
55fa 4d 57			dw start3b 
55fc c9 57			dw start3c 
55fe			 
55fe				; (unit) testing words 
55fe			 
55fe 0a 59			dw mtesta 
5600 bf 59			dw mtestb 
5602 62 5a			dw mtestc 
5604 17 5b			dw mtestd 
5606 bb 5b			dw mteste 
5608			 
5608				; demo/game words 
5608			 
5608 c7 62		        dw game3w 
560a f5 62		        dw game3p 
560c 13 63		        dw game3sc 
560e 44 63		        dw game3vsi 
5610 70 63		        dw game3vs 
5612				 
5612 ba 60			dw game2b 
5614 28 61			dw game2bf 
5616 72 61			dw game2mba 
5618 08 62			dw game2mbas 
561a 4a 62			dw game2mb 
561c			 
561c 7b 5d			dw game1 
561e 8c 5d			dw game1a 
5620 ee 5d			dw game1b 
5622 23 5e			dw game1c 
5624 59 5e			dw game1d 
5626 8a 5e			dw game1s 
5628 9e 5e			dw game1t 
562a b3 5e			dw game1f 
562c e7 5e			dw game1z 
562e 2b 5f			dw game1zz 
5630			 
5630 71 5c			dw test5 
5632 a9 5c			dw test6 
5634 e1 5c			dw test7 
5636 f5 5c			dw test8 
5638 21 5d			dw test9 
563a 37 5d			dw test10 
563c				 
563c 02 60		        dw ssv5 
563e e6 5f		        dw ssv4 
5640 ca 5f		        dw ssv3 
5642 94 5f		        dw ssv2 
5644 1b 60		        dw ssv1 
5646 63 60		        dw ssv1cpm 
5648			;	dw keyup 
5648			;	dw keydown 
5648			;	dw keyleft 
5648			;	dw keyright 
5648			;	dw 	keyf1 
5648			;	dw keyf2 
5648			;	dw keyf3 
5648			;	dw keyf4 
5648			;	dw keyf5 
5648			;	dw keyf6 
5648			;	dw keyf7 
5648			;	dw keyf8 
5648			;	dw keyf9 
5648			;	dw keyf10 
5648			;	dw keyf11 
5648			;	dw keyf12 
5648			;	dw keytab 
5648			;	dw keycr 
5648			;	dw keyhome 
5648			;	dw keyend 
5648			;	dw keybs 
5648 00 00			db 0, 0	 
564a			 
564a			 
564a			; Long read 
564a			; e.g. $01 lread 
564a			; 
564a			; TODO need some constants 
564a			 
564a .. 00		longread:   db ": lread read repeat count $3e = if ; ", 0 
5670			 
5670			; clear stack  
5670			 
5670 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
56a3			 
56a3			; type ( addr count - ) 
56a3 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
56c7			 
56c7			; some direct memory words 
56c7			; strncpy ( len t f -- t ) 
56c7			 
56c7 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5728			 
5728 .. 00		start1:     	db ": bpon $0000 bp ;",0 
573a .. 00		start2:     	db ": bpoff $0001 bp ;",0 
574d .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
57c9 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5829			 
5829			 
5829			; a handy word to list items on the stack 
5829			 
5829 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5893			 
5893			 
5893			; test stack  
5893			; rnd8 stest 
5893			 
5893 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
590a			 
590a			; random malloc and free cycles 
590a			 
590a .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
59bf			 
59bf			; fixed malloc and free cycles 
59bf			 
59bf .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5a62			 
5a62			; fixed double string push and drop cycle  
5a62			 
5a62 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5b17			 
5b17			; consistent fixed string push and drop cycle  
5b17			 
5b17 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5bbb			 
5bbb .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5c71			 
5c71			;test1:		db ": aa 1 2 3 ;", 0 
5c71			;test2:     	db "111 aa 888 999",0 
5c71			;test3:     	db ": bb 77 ;",0 
5c71			;test4:     	db "$02 $01 do i . loop bb",0 
5c71			 
5c71 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5ca9 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5ce1 .. 00		test7:     	db ": box hline vline ;",0 
5cf5 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5d21 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5d37 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5d5c .. 00		test11:     	db "hello create .",0 
5d6b .. 00		test12:     	db "hello2 create .",0 
5d7b			 
5d7b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5d7b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5d7b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5d7b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5d7b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5d7b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5d7b			 
5d7b			;iftest1:     	db "$0001 IF cls .",0 
5d7b			;iftest2:     	db "$0000 IF cls .",0 
5d7b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5d7b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5d7b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5d7b			 
5d7b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5d7b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5d7b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5d7b			 
5d7b			 
5d7b			 
5d7b			; a small guess the number game 
5d7b			 
5d7b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5d8c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5dee			 
5dee .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5e23 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5e59 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5e8a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5e9e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5eb3 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ee7 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5f2b			 
5f2b			; Using 'ga' save a high score across multiple runs using external storage 
5f2b			 
5f2b .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5f94			 
5f94			 
5f94			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5f94			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f94			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5f94			 
5f94			; simple screen saver to test code memory reuse to destruction 
5f94			 
5f94 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5fca .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5fe6 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6002 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
601b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6063 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
60ba			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
60ba			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
60ba			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
60ba			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
60ba			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
60ba			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
60ba			 
60ba			 
60ba			 
60ba			; minesweeper/battleship finding game 
60ba			; draws a game board of random ship/mine positions 
60ba			; user enters coords to see if it hits on 
60ba			; game ends when all are hit 
60ba			; when hit or miss says how many may be in the area 
60ba			 
60ba			; setup the game board and then hide it 
60ba .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6128 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6172			; prompt for where to target 
6172 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6208 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
622d			; TODO see if the entered coords hits or misses pushes char hit of miss 
622d .. 00		game2mbht:      db ": mbckht nop ;",0 
623c .. 00		game2mbms:      db ": mbcms nop ;",0 
624a			; TODO how many might be near by 
624a .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
62c7			 
62c7			; Game 3 
62c7			 
62c7			; Vert scroller ski game - avoid the trees! 
62c7			 
62c7			; v0 score (ie turns) 
62c7			; v1 player pos 
62c7			; v2 left wall 
62c7			; v3 right wall 
62c7			 
62c7			; Draw side walls randomly 
62c7			 
62c7 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
62f5			 
62f5			; Draw player 
62f5 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6313			 
6313			; TODO Get Key 
6313			 
6313			; TODO Move left right 
6313			 
6313			; scroll and move walls a bit 
6313			 
6313 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6344			 
6344			; main game loop 
6344			 
6344 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6370 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
63af			 
63af			; key board defs 
63af			 
63af .. 00		keyup:       db ": keyup $05 ;",0 
63bd .. 00		keydown:       db ": keydown $0a ;",0 
63cd .. 00		keyleft:       db ": keyleft $0b ;",0 
63dd .. 00		keyright:       db ": keyright $0c ;",0 
63ee .. 00		keyf1:       db ": keyf1 $10 ;",0 
63fc .. 00		keyf2:       db ": keyf2 $11 ;",0 
640a .. 00		keyf3:       db ": keyf3 $12 ;",0 
6418 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6426 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6434 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6442 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6450 .. 00		keyf8:       db ": keyf8 $17 ;",0 
645e .. 00		keyf9:       db ": keyf9 $18 ;",0 
646c .. 00		keyf10:       db ": keyf10 $19 ;",0 
647b .. 00		keyf11:       db ": keyf11 $1a ;",0 
648a .. 00		keyf12:       db ": keyf12 $1b ;",0 
6499			 
6499 .. 00		keytab:       db ": keytab $09 ;",0 
64a8 .. 00		keycr:       db ": keycr $0d ;",0 
64b6 .. 00		keyhome:       db ": keyhome $0e ;",0 
64c6 .. 00		keyend:       db ": keyend $0f ;",0 
64d5 .. 00		keybs:       db ": keybs $08 ;",0 
64e3			 
64e3			   
64e3			 
64e3			 
64e3			 
64e3			; eof 
# End of file forth_autostart.asm
64e3			 
64e3 .. 00		sprompt1: db "Startup load...",0 
64f3 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6509			 
6509			 
6509			 
6509			 
6509			forth_startup: 
6509 21 ea 55			ld hl, startcmds 
650c 3e 00			ld a, 0 
650e 32 ab f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6511			 
6511 e5			.start1:	push hl 
6512 cd 95 0c			call clear_display 
6515 11 e3 64			ld de, sprompt1 
6518 3e 00		        ld a, display_row_1 
651a cd a8 0c			call str_at_display 
651d 11 f3 64			ld de, sprompt2 
6520 3e 14		        ld a, display_row_2 
6522 cd a8 0c			call str_at_display 
6525 e1				pop hl 
6526 e5				push hl 
6527 5e				ld e,(hl) 
6528 23				inc hl 
6529 56				ld d,(hl) 
652a 3e 28		        ld a, display_row_3 
652c cd a8 0c			call str_at_display 
652f cd b8 0c			call update_display 
6532			 
6532			 
6532 3a ab f7			ld a, (os_last_cmd) 
6535 fe 00			cp 0 
6537 28 05			jr z, .startprompt 
6539 cd 06 0c			call delay250ms 
653c 18 24			jr .startdo 
653e				 
653e				 
653e			 
653e			.startprompt: 
653e			 
653e 3e 4f			ld a,display_row_4 + display_cols - 1 
6540 11 30 1e		        ld de, endprg 
6543 cd a8 0c			call str_at_display 
6546 cd b8 0c			call update_display 
6549 cd 12 0c			call delay1s 
654c cd b8 6a			call cin_wait 
654f						 
654f fe 2a			cp '*' 
6551 28 5e			jr z, .startupend1 
6553 fe 23			cp '#' 
6555 20 07			jr nz, .startno 
6557 3e 01			ld a, 1 
6559 32 ab f7			ld (os_last_cmd),a 
655c 18 04			jr .startdo 
655e fe 31		.startno:	cp '1' 
6560 28 3a			jr z,.startnxt  
6562			 
6562				; exec startup line 
6562			.startdo:	 
6562 e1				pop hl 
6563 e5				push hl 
6564				 
6564 5e				ld e,(hl) 
6565 23				inc hl 
6566 56				ld d,(hl) 
6567 eb				ex de,hl 
6568			 
6568 e5				push hl 
6569			 
6569 3e 00			ld a, 0 
656b				;ld a, FORTH_END_BUFFER 
656b cd 32 13			call strlent 
656e 23				inc hl   ; include zero term to copy 
656f 06 00			ld b,0 
6571 4d				ld c,l 
6572 e1				pop hl 
6573 11 85 f3			ld de, scratch 
6576 ed b0			ldir 
6578			 
6578			 
6578 21 85 f3			ld hl, scratch 
657b cd 76 22			call forthparse 
657e cd b6 22			call forthexec 
6581 cd c8 21			call forthexec_cleanup 
6584			 
6584 3e 3c			ld a, display_row_4 
6586 11 d4 1b			ld de, endprog 
6589			 
6589 cd b8 0c			call update_display		 
658c			 
658c 3a ab f7			ld a, (os_last_cmd) 
658f fe 00			cp 0 
6591 20 09			jr nz, .startnxt 
6593 cd 32 1e			call next_page_prompt 
6596 cd 95 0c		        call clear_display 
6599 cd b8 0c			call update_display		 
659c			 
659c				; move onto next startup line? 
659c			.startnxt: 
659c			 
659c cd 06 0c			call delay250ms 
659f e1				pop hl 
65a0			 
65a0 23				inc hl 
65a1 23				inc hl 
65a2			 
65a2 e5				push hl 
65a3 5e				ld e, (hl) 
65a4 23				inc hl 
65a5 56				ld d, (hl) 
65a6 e1				pop hl 
65a7				; TODO replace 0 test 
65a7			 
65a7 eb				ex de, hl 
65a8 cd f2 0e			call ishlzero 
65ab			;	ld a,e 
65ab			;	add d 
65ab			;	cp 0    ; any left to do? 
65ab eb				ex de, hl 
65ac c2 11 65			jp nz, .start1 
65af 18 01			jr .startupend 
65b1			 
65b1 e1			.startupend1: pop hl 
65b2			.startupend: 
65b2			 
65b2 cd 95 0c			call clear_display 
65b5 cd b8 0c			call update_display 
65b8 c9				ret 
65b9			 
65b9			 
65b9			; stack over and underflow checks 
65b9			 
65b9			; init the words to detect the under/overflow 
65b9			 
65b9			chk_stk_init: 
65b9				; a vague random number to check so we dont get any "lucky" hits 
65b9 3e 2d			ld a, 45 
65bb 6f				ld l, a 
65bc 00				nop 
65bd 3e 17			ld a, 23 
65bf 67				ld h, a 
65c0			 
65c0 22 6c f3			ld (chk_word), hl     ; the word we need to check against 
65c3			 
65c3			;	ld (chk_stund), hl	; stack points.... 
65c3 22 fd fe			ld (chk_stovr), hl 
65c6 22 b0 fb			ld (chk_ret_und), hl 
65c9 22 6e fb			ld (chk_ret_ovr), hl 
65cc 22 ec fa			ld (chk_loop_ovr), hl 
65cf 22 ea f8			ld (chk_data_ovr), hl 
65d2 c9				ret 
65d3				 
65d3			check_stacks: 
65d3				; check all stack words 
65d3			 
65d3 e5				push hl 
65d4 d5				push de 
65d5			 
65d5			;	ld de,(chk_word) 
65d5			;	ld hl, (chk_stund)	; stack points.... 
65d5			;	if DEBUG_STK_FAULT 
65d5			;		DMARK "FAa" 
65d5			;		CALLMONITOR 
65d5			;	endif 
65d5			;	call cmp16 
65d5			;	jp z, .chk_faulta 
65d5			; 
65d5			;	ld de, sfaultsu 
65d5			;	jp .chk_fault 
65d5			 
65d5 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
65d8 ed 5b 6c f3		ld de,(chk_word) 
65dc				if DEBUG_STK_FAULT 
65dc					DMARK "FAb" 
65dc					CALLMONITOR 
65dc				endif 
65dc cd e7 0e			call cmp16 
65df 28 06			jr z, .chk_fault1 
65e1 11 82 66			ld de, sfaultso 
65e4 c3 36 66			jp .chk_fault 
65e7			.chk_fault1:  
65e7 2a b0 fb			ld hl, (chk_ret_und) 
65ea ed 5b 6c f3		ld de,(chk_word) 
65ee				if DEBUG_STK_FAULT 
65ee					DMARK "FAU" 
65ee					CALLMONITOR 
65ee				endif 
65ee cd e7 0e			call cmp16 
65f1 ca fa 65			jp z, .chk_fault2 
65f4 11 92 66			ld de, sfaultru 
65f7 c3 36 66			jp .chk_fault 
65fa			.chk_fault2:  
65fa 2a 6e fb			ld hl, (chk_ret_ovr) 
65fd ed 5b 6c f3		ld de,(chk_word) 
6601				if DEBUG_STK_FAULT 
6601					DMARK "FA1" 
6601					CALLMONITOR 
6601				endif 
6601 cd e7 0e			call cmp16 
6604 ca 0d 66			jp z, .chk_fault3 
6607 11 a0 66			ld de, sfaultro 
660a c3 36 66			jp .chk_fault 
660d			.chk_fault3:  
660d 2a ec fa			ld hl, (chk_loop_ovr) 
6610 ed 5b 6c f3		ld de,(chk_word) 
6614				if DEBUG_STK_FAULT 
6614					DMARK "FA2" 
6614					CALLMONITOR 
6614				endif 
6614 cd e7 0e			call cmp16 
6617 ca 20 66			jp z, .chk_fault4 
661a 11 ba 66			ld de, sfaultlo 
661d c3 36 66			jp .chk_fault 
6620			.chk_fault4:  
6620 2a ea f8			ld hl, (chk_data_ovr) 
6623 ed 5b 6c f3		ld de,(chk_word) 
6627				if DEBUG_STK_FAULT 
6627					DMARK "FA3" 
6627					CALLMONITOR 
6627				endif 
6627 cd e7 0e			call cmp16 
662a ca 33 66			jp z, .chk_fault5 
662d 11 d4 66			ld de, sfaultdo 
6630 c3 36 66			jp .chk_fault 
6633			 
6633			 
6633			.chk_fault5:  
6633 d1				pop de 
6634 e1				pop hl 
6635			 
6635 c9				ret 
6636			 
6636 cd 95 0c		.chk_fault: 	call clear_display 
6639 3e 14				ld a, display_row_2 
663b cd a8 0c				call str_at_display 
663e 11 64 66				   ld de, .stackfault 
6641 3e 00				ld a, display_row_1 
6643 cd a8 0c				call str_at_display 
6646 11 b4 fe				    ld de, debug_mark 
6649 3e 11				ld a, display_row_1+17 
664b cd a8 0c				call str_at_display 
664e cd b8 0c				call update_display 
6651			 
6651				; prompt before entering montior for investigating issue 
6651			 
6651 3e 3c			ld a, display_row_4 
6653 11 d4 1b			ld de, endprog 
6656			 
6656 cd b8 0c			call update_display		 
6659			 
6659 cd 32 1e			call next_page_prompt 
665c			 
665c d1				pop de 
665d e1				pop hl 
665e cd 28 1c				call monitor 
6661 c3 1f 1b				jp warmstart 
6664					;jp 0 
6664					;halt 
6664			 
6664			 
6664			 
6664 .. 00		.stackfault: 	db "Stack fault:",0 
6671			 
6671 .. 00		sfaultsu: 	db	"Stack under flow",0 
6682 .. 00		sfaultso: 	db	"Stack over flow",0 
6692 .. 00		sfaultru:	db "RTS underflow",0 
66a0 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
66ba .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
66d4 .. 00		sfaultdo:	db "DTS overflow", 0 
66e1			 
66e1			 
66e1			fault_dsp_under: 
66e1 11 f3 66			ld de, .dsp_under 
66e4 c3 a3 67			jp .show_fault 
66e7			 
66e7			fault_rsp_under: 
66e7 11 01 67			ld de, .rsp_under 
66ea c3 a3 67			jp .show_fault 
66ed			fault_loop_under: 
66ed 11 0f 67			ld de, .loop_under 
66f0 c3 a3 67			jp .show_fault 
66f3			 
66f3 .. 00		.dsp_under: db "DSP Underflow",0 
6701 .. 00		.rsp_under: db "RSP Underflow",0 
670f .. 00		.loop_under: db "LOOP Underflow",0 
671e			 
671e			 
671e d5			type_faultn: 	push de 
671f e5					push hl 
6720 cd 95 0c				call clear_display 
6723 11 4a 67				   ld de, .typefaultn 
6726 3e 00				ld a, display_row_1 
6728 cd a8 0c				call str_at_display 
672b 11 b4 fe				    ld de, debug_mark 
672e 3e 11				ld a, display_row_1+17 
6730 cd a8 0c				call str_at_display 
6733 cd b8 0c				call update_display 
6736			 
6736				; prompt before entering montior for investigating issue 
6736			 
6736 3e 3c			ld a, display_row_4 
6738 11 d4 1b			ld de, endprog 
673b			 
673b cd b8 0c			call update_display		 
673e			 
673e cd 32 1e			call next_page_prompt 
6741			 
6741 e5					push hl 
6742 d5					push de 
6743 cd 28 1c				call monitor 
6746 c3 1f 1b				jp warmstart 
6749 76					halt 
674a			 
674a			 
674a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6761			 
6761 d5			type_faults: 	push de 
6762 e5					push hl 
6763 cd 95 0c				call clear_display 
6766 11 8c 67				   ld de, .typefaults 
6769 3e 00				ld a, display_row_1 
676b cd a8 0c				call str_at_display 
676e 11 b4 fe				    ld de, debug_mark 
6771 3e 11				ld a, display_row_1+17 
6773 cd a8 0c				call str_at_display 
6776 cd b8 0c				call update_display 
6779			 
6779				; prompt before entering montior for investigating issue 
6779			 
6779 3e 3c			ld a, display_row_4 
677b 11 d4 1b			ld de, endprog 
677e			 
677e cd b8 0c			call update_display		 
6781			 
6781 cd 32 1e			call next_page_prompt 
6784			 
6784 e1					pop hl 
6785 d1					pop de 
6786 cd 28 1c				call monitor 
6789 c3 1f 1b				jp warmstart 
678c			 
678c			 
678c .. 00		.typefaults: db "STR Type Expected TOS!",0 
67a3			 
67a3			.show_fault: 	 
67a3 d5					push de 
67a4 cd 95 0c				call clear_display 
67a7 d1					pop de 
67a8 3e 00				ld a, display_row_1 
67aa cd a8 0c				call str_at_display 
67ad 11 b4 fe				    ld de, debug_mark 
67b0 3e 11				ld a, display_row_1+17 
67b2 cd a8 0c				call str_at_display 
67b5 cd b8 0c				call update_display 
67b8			 
67b8				; prompt before entering montior for investigating issue 
67b8			 
67b8 3e 3c			ld a, display_row_4 
67ba 11 d4 1b			ld de, endprog 
67bd			 
67bd cd b8 0c			call update_display		 
67c0			 
67c0 cd 32 1e			call next_page_prompt 
67c3			 
67c3 e1					pop hl 
67c4 d1					pop de 
67c5 cd 28 1c				call monitor 
67c8			; do a dump to cli and not warmstart so we preserve all of the uwords.  
67c8			; TODO Make optional fault restart to cli or warm boot? 
67c8					;jp warmstart 
67c8 c3 7a 1b				jp cli 
67cb 76					halt 
67cc			 
67cc			; handle the auto run of code from files in storage 
67cc			 
67cc			 
67cc			if STORAGE_SE 
67cc			 
67cc .. 00		sprompt3: db "Loading from start-up file?:",0 
67e9 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
67fa			 
67fa			 
67fa			forth_autoload: 
67fa			 
67fa				; load block 0 of store 1 
67fa				 
67fa 3e fe			ld a, $fe      ; bit 0 clear 
67fc 32 f0 fb			ld (spi_device), a 
67ff			 
67ff cd 82 04			call storage_get_block_0 
6802			 
6802 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
6805			 
6805 fe 00			cp 0 
6807 c8				ret z     ; auto start not enabled 
6808			 
6808 cd 95 0c			call clear_display 
680b			 
680b				; set bank 
680b			 
680b 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
680e 32 f0 fb				ld (spi_device), a 
6811			 
6811				; get file id to load from and get the file name to display 
6811			 
6811 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
6814			 
6814 2e 00				ld l, 0 
6816 67					ld h, a 
6817 11 07 fc				ld de, store_page 
681a			 
681a					if DEBUG_FORTH_WORDS 
681a						DMARK "ASp" 
681a f5				push af  
681b 3a 2f 68			ld a, (.dmark)  
681e 32 b4 fe			ld (debug_mark),a  
6821 3a 30 68			ld a, (.dmark+1)  
6824 32 b5 fe			ld (debug_mark+1),a  
6827 3a 31 68			ld a, (.dmark+2)  
682a 32 b6 fe			ld (debug_mark+2),a  
682d 18 03			jr .pastdmark  
682f ..			.dmark: db "ASp"  
6832 f1			.pastdmark: pop af  
6833			endm  
# End of macro DMARK
6833						CALLMONITOR 
6833 cd 46 18			call break_point_state  
6836				endm  
# End of macro CALLMONITOR
6836					endif 
6836 cd 2a 09				call storage_read 
6839			 
6839					if DEBUG_FORTH_WORDS 
6839						DMARK "ASr" 
6839 f5				push af  
683a 3a 4e 68			ld a, (.dmark)  
683d 32 b4 fe			ld (debug_mark),a  
6840 3a 4f 68			ld a, (.dmark+1)  
6843 32 b5 fe			ld (debug_mark+1),a  
6846 3a 50 68			ld a, (.dmark+2)  
6849 32 b6 fe			ld (debug_mark+2),a  
684c 18 03			jr .pastdmark  
684e ..			.dmark: db "ASr"  
6851 f1			.pastdmark: pop af  
6852			endm  
# End of macro DMARK
6852						CALLMONITOR 
6852 cd 46 18			call break_point_state  
6855				endm  
# End of macro CALLMONITOR
6855					endif 
6855			 
6855 cd f2 0e				call ishlzero 
6858 c8					ret z             ; file not found 
6859			 
6859 3e 1e				ld a, display_row_2 + 10 
685b 11 0a fc				ld de, store_page+3 
685e cd a8 0c				call str_at_display 
6861				 
6861			; 
6861			 
6861 3e 05			ld a, display_row_1+5 
6863 11 cc 67			ld de, sprompt3 
6866 cd a8 0c			call str_at_display 
6869 3e 37			ld a, display_row_3+15 
686b 11 e9 67			ld de, sprompt4 
686e cd a8 0c			call str_at_display 
6871			 
6871 cd b8 0c			call update_display 
6874			 
6874 cd b8 6a			call cin_wait 
6877 fe 6e			cp 'n' 
6879 c8				ret z 
687a fe 4e			cp 'N' 
687c c8				ret z 
687d			 
687d cd 12 0c			call delay1s 
6880			 
6880 3a 09 fc			ld a, (store_page+2) 
6883 32 f8 fb			ld (store_openmaxext), a    ; save count of ext 
6886 3e 01			ld a, 1  
6888 32 f9 fb			ld (store_openext), a    ; save count of ext 
688b			 
688b			.autof:  
688b 6f				ld l , a 
688c				 
688c 3a 07 fc			ld a, (store_page) 
688f 67				ld h, a	 
6890 11 07 fc			ld de, store_page 
6893					if DEBUG_FORTH_WORDS 
6893						DMARK "ASl" 
6893 f5				push af  
6894 3a a8 68			ld a, (.dmark)  
6897 32 b4 fe			ld (debug_mark),a  
689a 3a a9 68			ld a, (.dmark+1)  
689d 32 b5 fe			ld (debug_mark+1),a  
68a0 3a aa 68			ld a, (.dmark+2)  
68a3 32 b6 fe			ld (debug_mark+2),a  
68a6 18 03			jr .pastdmark  
68a8 ..			.dmark: db "ASl"  
68ab f1			.pastdmark: pop af  
68ac			endm  
# End of macro DMARK
68ac						CALLMONITOR 
68ac cd 46 18			call break_point_state  
68af				endm  
# End of macro CALLMONITOR
68af					endif 
68af cd 2a 09				call storage_read 
68b2 cd f2 0e			call ishlzero 
68b5 c8				ret z 
68b6			;	jr z, .autoend 
68b6			 
68b6					if DEBUG_FORTH_WORDS 
68b6						DMARK "ASc" 
68b6 f5				push af  
68b7 3a cb 68			ld a, (.dmark)  
68ba 32 b4 fe			ld (debug_mark),a  
68bd 3a cc 68			ld a, (.dmark+1)  
68c0 32 b5 fe			ld (debug_mark+1),a  
68c3 3a cd 68			ld a, (.dmark+2)  
68c6 32 b6 fe			ld (debug_mark+2),a  
68c9 18 03			jr .pastdmark  
68cb ..			.dmark: db "ASc"  
68ce f1			.pastdmark: pop af  
68cf			endm  
# End of macro DMARK
68cf						CALLMONITOR 
68cf cd 46 18			call break_point_state  
68d2				endm  
# End of macro CALLMONITOR
68d2					endif 
68d2 11 09 fc			ld de, store_page+2 
68d5 3e 3c			ld a, display_row_4 
68d7 cd a8 0c			call str_at_display 
68da			 
68da cd b8 0c			call update_display 
68dd cd 06 0c			call delay250ms 
68e0			 
68e0			 
68e0			 
68e0 21 09 fc			ld hl, store_page+2 
68e3 cd 76 22			call forthparse 
68e6 cd b6 22			call forthexec 
68e9 cd c8 21			call forthexec_cleanup 
68ec			 
68ec				 
68ec 3a f9 fb			ld a, (store_openext) 
68ef 3c				inc a 
68f0 32 f9 fb			ld (store_openext), a    ; save count of ext 
68f3			 
68f3 18 96			jr .autof 
68f5			;.autofdone: 
68f5			; 
68f5			;		if DEBUG_FORTH_WORDS 
68f5			;			DMARK "ASx" 
68f5			;			CALLMONITOR 
68f5			;		endif 
68f5			;;	call clear_display 
68f5			;	ret 
68f5			 
68f5			 
68f5			 
68f5			endif 
68f5			 
68f5			 
68f5			; eof 
# End of file forth_kernel.asm
68f5			;include "nascombasic.asm" 
68f5			 
68f5			 
68f5			; find out where the code ends if loaded into RAM (for SC114) 
68f5			;endofcode:  
68f5			;	nop 
68f5			 
68f5			 
68f5			; eof 
68f5			 
# End of file main.asm
68f5			include "firmware_lcd_4x20.asm" 
68f5			; **********************************************************************  
68f5			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
68f5			; **********************************************************************  
68f5			;  
68f5			; **  Written as a Small Computer Monitor App  
68f5			; **  www.scc.me.uk  
68f5			;  
68f5			; History  
68f5			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
68f5			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
68f5			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
68f5			;  
68f5			; **********************************************************************  
68f5			;  
68f5			; This program is an example of one of the methods of interfacing an   
68f5			; alphanumeric LCD module.   
68f5			;  
68f5			; In this example the display is connected to either a Z80 PIO or a   
68f5			; simple 8-bit output port.   
68f5			;  
68f5			; This interfacing method uses 4-bit data mode and uses time delays  
68f5			; rather than polling the display's ready status. As a result the   
68f5			; interface only requires 6 simple output lines:  
68f5			;   Output bit 0 = not used  
68f5			;   Output bit 1 = not used  
68f5			;   Output bit 2 = RS         High = data, Low = instruction  
68f5			;   Output bit 3 = E          Active high  
68f5			;   Output bit 4 = DB4  
68f5			;   Output bit 5 = DB5  
68f5			;   Output bit 6 = DB6  
68f5			;   Output bit 7 = DB7  
68f5			; Display's R/W is connected to 0v so it is always in write mode  
68f5			;  
68f5			; This set up should work with any system supporting the RC2014 bus  
68f5			  
68f5			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
68f5			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
68f5			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
68f5			;  
68f5			; **********************************************************************  
68f5			  
68f5			; **********************************************************************  
68f5			; **  Constants  
68f5			; **********************************************************************  
68f5			; LCD constants required by LCD support module  
68f5			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
68f5			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
68f5			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
68f5			kLCDWidth:  EQU display_cols             ;Width in characters  
68f5			  
68f5			; **********************************************************************  
68f5			; **  Code library usage  
68f5			; **********************************************************************  
68f5			  
68f5			; send character to current cursor position  
68f5			; wraps and/or scrolls screen automatically  
68f5			  
68f5			  
68f5			lcd_init:  
68f5			  
68f5			; SCMonAPI functions used  
68f5			  
68f5			; Alphanumeric LCD functions used  
68f5			; no need to specify specific functions for this module  
68f5			  
68f5 3e cf		            LD   A, 11001111b  
68f7 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
68f9 3e 00		            LD   A, 00000000b  
68fb d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
68fd			  
68fd			; Initialise alphanumeric LCD module  
68fd cd 76 69		            CALL fLCD_Init      ;Initialise LCD module  
6900			  
6900 c9				ret  
6901			  
6901			;  
6901			;;  
6901			; lcd functions  
6901			;  
6901			;  
6901			  
6901			; what is at cursor position   
6901			  
6901			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6901			;		call curptr  
6901			;		ret  
6901			  
6901			  
6901			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6901			  
6901			curptr:  
6901 c5				push bc  
6902 21 4a fe			ld hl, display_fb0  
6905			cpr:	  
6905				; loop for cursor whole row  
6905 0e 14			ld c, display_cols  
6907 23			cpr1:	inc hl  
6908 0d				dec c  
6909 20 fc			jr nz, cpr1  
690b 05				dec b  
690c 20 f7			jr nz, cpr  
690e			  
690e				; add col	  
690e			  
690e 23			cpr2:	inc hl  
690f 1d				dec e  
6910 20 fc			jr nz, cpr2  
6912			  
6912 c1				pop bc  
6913 c9				ret  
6914				  
6914			  
6914			  
6914			  
6914			  
6914			; write the frame buffer given in hl to hardware   
6914 22 52 fd		write_display: ld (display_write_tmp), hl 	   
6917 3e 00			ld a, kLCD_Line1  
6919 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
691c 06 14			ld b, display_cols  
691e ed 5b 52 fd		ld de, (display_write_tmp)  
6922 cd 6e 69			call write_len_string  
6925				  
6925				  
6925 2a 52 fd			ld hl, (display_write_tmp)  
6928 11 14 00			ld de, display_cols  
692b 19				add hl,de  
692c 22 52 fd			ld (display_write_tmp),hl  
692f			  
692f				  
692f 3e 40			ld a, kLCD_Line2  
6931 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6934 06 14			ld b, display_cols  
6936 ed 5b 52 fd		ld de, (display_write_tmp)  
693a cd 6e 69			call write_len_string  
693d				  
693d 2a 52 fd			ld hl, (display_write_tmp)  
6940 11 14 00			ld de, display_cols  
6943 19				add hl,de  
6944 22 52 fd			ld (display_write_tmp),hl  
6947			  
6947				  
6947 3e 14			ld a, kLCD_Line3  
6949 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
694c 06 14			ld b, display_cols  
694e ed 5b 52 fd		ld de, (display_write_tmp)  
6952 cd 6e 69			call write_len_string  
6955				  
6955 2a 52 fd			ld hl, (display_write_tmp)  
6958 11 14 00			ld de, display_cols  
695b 19				add hl,de  
695c 22 52 fd			ld (display_write_tmp),hl  
695f			  
695f				  
695f 3e 54			ld a, kLCD_Line4  
6961 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6964 06 14			ld b, display_cols  
6966 ed 5b 52 fd		ld de, (display_write_tmp)  
696a cd 6e 69			call write_len_string  
696d c9					ret  
696e				  
696e				; write out a fixed length string given in b from de  
696e			  
696e 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
696f cd c0 69		            CALL fLCD_Data      ;Write character to display  
6972 13				inc de  
6973 10 f9			djnz write_len_string  
6975 c9				ret  
6976			  
6976			; Some other things to do  
6976			;            LD   A, kLCD_Clear ;Display clear  
6976			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6976			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6976			;            LD   A, kLCD_On     ;Display on with no cursor  
6976			;            ;LD   A, kLCD_Off   ;Display off  
6976			;            CALL fLCD_Inst      ;Send instruction to display  
6976			;  
6976			;  
6976			;            halt  
6976			;  
6976			;  
6976			;MsgHello:   DB  "Hello World!",0  
6976			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6976			  
6976			; Custom characters 5 pixels wide by 8 pixels high  
6976			; Up to 8 custom characters can be defined  
6976			;BitMaps:      
6976			;; Character 0x00 = Battery icon  
6976			;            DB  01110b  
6976			;            DB  11011b  
6976			;            DB  10001b  
6976			;            DB  10001b  
6976			;            DB  11111b  
6976			;            DB  11111b  
6976			;            DB  11111b  
6976			;            DB  11111b  
6976			;; Character 0x01 = Bluetooth icon  
6976			;            DB  01100b  
6976			;            DB  01010b  
6976			;            DB  11100b  
6976			;            DB  01000b  
6976			;            DB  11100b  
6976			;            DB  01010b  
6976			;            DB  01100b  
6976			;            DB  00000b  
6976			;  
6976			  
6976			  
6976			; **********************************************************************  
6976			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6976			; **********************************************************************  
6976			;  
6976			; **  Written as a Small Computer Monitor App   
6976			; **  Version 0.1 SCC 2018-05-16  
6976			; **  www.scc.me.uk  
6976			;  
6976			; **********************************************************************  
6976			;  
6976			; This module provides support for alphanumeric LCD modules using with  
6976			; *  HD44780 (or compatible) controller  
6976			; *  5 x 7 pixel fonts  
6976			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6976			; *  Interface via six digital outputs to the display (see below)  
6976			;  
6976			; LCD module pinout:  
6976			;   1  Vss   0v supply  
6976			;   2  Vdd   5v supply  
6976			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6976			;   4  RS    High = data, Low = instruction  
6976			;   5  R/W   High = Read, Low = Write  
6976			;   6  E     Enable signal (active high)  
6976			;   7  DB0   Data bit 0  
6976			;   8  DB1   Data bit 1  
6976			;   9  DB2   Data bit 2  
6976			;  10  DB3   Data bit 3  
6976			;  11  DB4   Data bit 4  
6976			;  12  DB5   Data bit 5  
6976			;  13  DB6   Data bit 6  
6976			;  14  DB7   Data bit 7  
6976			;  15  A     Backlight anode (+)  
6976			;  16  K     Backlight cathode (-)  
6976			;  
6976			; This interfacing method uses 4-bit data mode and uses time delays  
6976			; rather than polling the display's ready status. As a result the   
6976			; interface only requires 6 simple output lines:  
6976			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6976			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6976			;   LCD DB4 = Microcomputer output port bit 4  
6976			;   LCD DB5 = Microcomputer output port bit 5  
6976			;   LCD DB6 = Microcomputer output port bit 6  
6976			;   LCD DB7 = Microcomputer output port bit 7  
6976			; Display's R/W is connected to 0v so it is always in write mode  
6976			; All 6 connections must be on the same port address <kLCDPrt>  
6976			; This method also allows a decent length of cable from micro to LCD  
6976			;  
6976			; **********************************************************************  
6976			;  
6976			; To include the code for any given function provided by this module,   
6976			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6976			; the parent source file.  
6976			; For example:  #REQUIRES   uHexPrefix  
6976			;  
6976			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6976			; in the parent source file.  
6976			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6976			;  
6976			; These are the function names provided by this module:  
6976			; fLCD_Init                     ;Initialise LCD  
6976			; fLCD_Inst                     ;Send instruction to LCD  
6976			; fLCD_Data                     ;Send data byte to LCD  
6976			; fLCD_Pos                      ;Position cursor  
6976			; fLCD_Str                      ;Display string  
6976			; fLCD_Def                      ;Define custom character  
6976			;  
6976			; **********************************************************************  
6976			;  
6976			; Requires SCMonAPI.asm to also be included in the project  
6976			;  
6976			  
6976			  
6976			; **********************************************************************  
6976			; **  Constants  
6976			; **********************************************************************  
6976			  
6976			; Constants that must be defined externally  
6976			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6976			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6976			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6976			;kLCDWidth: EQU 20             ;Width in characters  
6976			  
6976			; general line offsets in any frame buffer  
6976			  
6976			  
6976			display_row_1: equ 0  
6976			display_row_2: equ display_row_1+display_cols  
6976			display_row_3: equ display_row_2 + display_cols  
6976			display_row_4: equ display_row_3 + display_cols  
6976			;display_row_4_eol:   
6976			  
6976			  
6976			; Cursor position values for the start of each line  
6976			kLCD_Line1: EQU 0x00   
6976			kLCD_Line2: EQU 0x40    
6976			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6976			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6976			  
6976			; Instructions to send as A register to fLCD_Inst  
6976			kLCD_Clear: EQU 00000001b     ;LCD clear  
6976			kLCD_Off:   EQU 00001000b     ;LCD off  
6976			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6976			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6976			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6976			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6976			  
6976			; Constants used by this code module  
6976			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6976			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6976			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6976			  
6976			  
6976			  
6976			; **********************************************************************  
6976			; **  LCD support functions  
6976			; **********************************************************************  
6976			  
6976			; Initialise alphanumeric LCD module  
6976			; LCD control register codes:  
6976			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6976			;   N    0 = 1-line mode       1 = 2-line mode  
6976			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6976			;   D    0 = Display off       1 = Display on  
6976			;   C    0 = Cursor off        1 = Cursor on  
6976			;   B    0 = Blinking off      1 = Blinking on  
6976			;   ID   0 = Decrement mode    1 = Increment mode  
6976			;   SH   0 = Entire shift off  1 = Entire shift on  
6976 3e 28		fLCD_Init:  LD   A, 40  
6978 cd 2d 6a		            CALL LCDDelay       ;Delay 40ms after power up  
697b			; For reliable reset set 8-bit mode - 3 times  
697b cd 17 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
697e cd 17 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
6981 cd 17 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
6984			; Set 4-bit mode  
6984 cd 13 6a		            CALL WrFn4bit       ;Function = 4-bit mode  
6987 cd 2b 6a		            CALL LCDDelay1      ;Delay 37 us or more  
698a			; Function set  
698a 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
698c cd 9f 69		            CALL fLCD_Inst      ;2 line, display on  
698f			; Display On/Off control  
698f 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6991 cd 9f 69		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6994			; Display Clear  
6994 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6996 cd 9f 69		            CALL fLCD_Inst      ;Clear display  
6999			; Entry mode  
6999 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
699b cd 9f 69		            CALL fLCD_Inst      ;Increment mode, shift off  
699e			; Display module now initialised  
699e c9			            RET  
699f			; ok to here  
699f			  
699f			; Write instruction to LCD  
699f			;   On entry: A = Instruction byte to be written  
699f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
699f f5			fLCD_Inst:  PUSH AF  
69a0 f5			            PUSH AF  
69a1 cd b3 69		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
69a4 f1			            POP  AF  
69a5 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
69a6 17			            RLA  
69a7 17			            RLA  
69a8 17			            RLA  
69a9 cd b3 69		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
69ac 3e 02		            LD   A, 2  
69ae cd 2d 6a		            CALL LCDDelay       ;Delay 2 ms to complete   
69b1 f1			            POP  AF  
69b2 c9			            RET  
69b3 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
69b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
69b7 cb df		            SET  kLCDBitE, A  
69b9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
69bb cb 9f		            RES  kLCDBitE, A  
69bd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
69bf c9			            RET  
69c0			  
69c0			  
69c0			; Write data to LCD  
69c0			;   On entry: A = Data byte to be written  
69c0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
69c0 f5			fLCD_Data:  PUSH AF  
69c1 f5			            PUSH AF  
69c2 cd d4 69		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
69c5 f1			            POP  AF  
69c6 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
69c7 17			            RLA  
69c8 17			            RLA  
69c9 17			            RLA  
69ca cd d4 69		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
69cd 3e 96		            LD   A, 150  
69cf 3d			Wait:      DEC  A              ;Wait a while to allow data   
69d0 20 fd		            JR   NZ, Wait      ;  write to complete  
69d2 f1			            POP  AF  
69d3 c9			            RET  
69d4 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
69d6 cb d7		            SET  kLCDBitRS, A  
69d8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
69da cb df		            SET  kLCDBitE, A  
69dc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
69de cb 9f		            RES  kLCDBitE, A  
69e0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
69e2 cb 97		            RES  kLCDBitRS, A  
69e4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
69e6 c9			            RET  
69e7			  
69e7			  
69e7			; Position cursor to specified location  
69e7			;   On entry: A = Cursor position  
69e7			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
69e7 f5			fLCD_Pos:   PUSH AF  
69e8 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
69ea cd 9f 69		            CALL fLCD_Inst      ;Write instruction to LCD  
69ed f1			            POP  AF  
69ee c9			            RET  
69ef			  
69ef			  
69ef			; Output text string to LCD  
69ef			;   On entry: DE = Pointer to null terminated text string  
69ef			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
69ef 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
69f0 b7			            OR   A              ;Null terminator?  
69f1 c8			            RET  Z              ;Yes, so finished  
69f2 cd c0 69		            CALL fLCD_Data      ;Write character to display  
69f5 13			            INC  DE             ;Point to next character  
69f6 18 f7		            JR   fLCD_Str       ;Repeat  
69f8 c9					ret  
69f9			  
69f9			; Define custom character  
69f9			;   On entry: A = Character number (0 to 7)  
69f9			;             DE = Pointer to character bitmap data  
69f9			;   On exit:  A = Next character number  
69f9			;             DE = Next location following bitmap  
69f9			;             BC HL IX IY I AF' BC' DE' HL' preserved  
69f9			; Character is   
69f9 c5			fLCD_Def:   PUSH BC  
69fa f5			            PUSH AF  
69fb 07			            RLCA                ;Calculate location  
69fc 07			            RLCA                ;  for bitmap data  
69fd 07			            RLCA                ;  = 8 x CharacterNumber  
69fe f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6a00 cd 9f 69		            CALL fLCD_Inst      ;Write instruction to LCD  
6a03 06 00		            LD   B, 0  
6a05 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6a06 cd c0 69		            CALL fLCD_Data      ;Write byte to display  
6a09 13			            INC  DE             ;Point to next byte  
6a0a 04			            INC  B              ;Count bytes  
6a0b cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6a0d 28 f6		            JR   Z, Loop       ;No, so repeat  
6a0f f1			            POP  AF  
6a10 3c			            INC  A              ;Increment character number  
6a11 c1			            POP  BC  
6a12 c9			            RET  
6a13			  
6a13			  
6a13			; **********************************************************************  
6a13			; **  Private functions  
6a13			; **********************************************************************  
6a13			  
6a13			; Write function to LCD  
6a13			;   On entry: A = Function byte to be written  
6a13			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a13 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6a15 18 02		            JR   WrFunc  
6a17 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6a19 f5			WrFunc:     PUSH AF  
6a1a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a1c cb df		            SET  kLCDBitE, A  
6a1e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a20 cb 9f		            RES  kLCDBitE, A  
6a22 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a24 3e 05		            LD   A, 5  
6a26 cd 2d 6a		            CALL LCDDelay       ;Delay 5 ms to complete  
6a29 f1			            POP  AF  
6a2a c9			            RET  
6a2b			  
6a2b			  
6a2b			; Delay in milliseconds  
6a2b			;   On entry: A = Number of milliseconds delay  
6a2b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a2b 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6a2d d5			LCDDelay:   PUSH DE  
6a2e 5f			            LD   E, A           ;Delay by 'A' ms  
6a2f 16 00		            LD   D, 0  
6a31 cd f7 0b		            CALL aDelayInMS  
6a34 d1			            POP  DE  
6a35 c9			            RET  
6a36			  
6a36			  
6a36			  
6a36			  
6a36			; eof  
6a36			  
# End of file firmware_lcd_4x20.asm
6a36			include "firmware_key_4x4.asm" 
6a36			  
6a36			  
6a36			; bit mask for each scan column and row for teing the matrix  
6a36			  
6a36			; out   
6a36 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
6a3a			; in  
6a3a 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6a3e			  
6a3e			; row/col to character map  
6a3e			  
6a3e			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6a3e			;    
6a3e			  
6a3e			; physical key matrix map to face of key  
6a3e			  
6a3e			  
6a3e			;      	1	2	3	A  
6a3e			;   	abc”	def&	ghi$	s1  
6a3e			;			  
6a3e			;	4	5	6	B  
6a3e			; 	jkl,	mno.	pqr:	s2  
6a3e			;			  
6a3e			; 	7	8	9	C  
6a3e			;	stu;	vwx@	yz?!	s3  
6a3e			;			  
6a3e			; 	*	0	#	D  
6a3e			; 	shift lck '	Space < >	Enter ( )	s4  
6a3e			;       tab bs 		  
6a3e			  
6a3e			  
6a3e			  
6a3e			  
6a3e			key_init:  
6a3e			  
6a3e			; SCMonAPI functions used  
6a3e			  
6a3e			; Alphanumeric LCD functions used  
6a3e			; no need to specify specific functions for this module  
6a3e			  
6a3e			  
6a3e 3e cf		            LD   A, 11001111b  
6a40 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6a42			;            LD   A, 00000000b  
6a42 3e 0f		            LD   A, 00001111b  
6a44 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6a46			  
6a46			  
6a46				; TODO Configure cursor shapes  
6a46			  
6a46				; Load cursor shapes   
6a46 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6a48 11 58 6a		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6a4b 06 02		            LD   B, 2           ;Number of characters to define  
6a4d cd f9 69		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6a50 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6a52			  
6a52 3e 01				ld a, 1  
6a54 32 4d fd			ld (cursor_shape),a  
6a57 c9				ret  
6a58			  
6a58			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6a58			; Up to 8 custom characters can be defined  
6a58			.cursor_shapes:      
6a58			;; Character 0x00 = Normal  
6a58 1f			            DB  11111b  
6a59 1f			            DB  11111b  
6a5a 1f			            DB  11111b  
6a5b 1f			            DB  11111b  
6a5c 1f			            DB  11111b  
6a5d 1f			            DB  11111b  
6a5e 1f			            DB  11111b  
6a5f 1f			            DB  11111b  
6a60			;; Character 0x01 = Modifier  
6a60 1f			            DB  11111b  
6a61 1b			            DB  11011b  
6a62 1b			            DB  11011b  
6a63 1b			            DB  11011b  
6a64 1b			            DB  11011b  
6a65 1f			            DB  11111b  
6a66 1b			            DB  11011b  
6a67 1f			            DB  11111b  
6a68			  
6a68			  
6a68			  
6a68			  
6a68			; Display custom character 0  
6a68			;            LD   A, kLCD_Line1+14  
6a68			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a68			;            LD   A, 0  
6a68			;            CALL fLCD_Data      ;Write character in A at cursor  
6a68			  
6a68			; Display custom character 1  
6a68			;            LD   A, kLCD_Line2+14  
6a68			;            CALL fLCD_Pos      ;Position cursor to location in A  
6a68			;            LD   A, 1  
6a68			;            CALL fLCD_Data     ;Write character in A at cursor  
6a68			  
6a68			; keyboard scanning   
6a68			  
6a68			  
6a68			; key_rows: equ 4  
6a68			; key_cols: equ 4  
6a68			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6a68			  
6a68			; key_scanr: equ key_row_bitmask  
6a68			; key_scanc: equ key_col_bitmask  
6a68			  
6a68			; key_char_map: equ key_map  
6a68			  
6a68			  
6a68			  
6a68			; character in from keyboard  
6a68			  
6a68 ..			.matrix_to_char: db "D#0*C987B654A321"  
6a78			  
6a78			  
6a78			; map the physical key to a char dependant on state  
6a78			  
6a78			.key_map_fa:   
6a78			  
6a78 ..					db 'D'  
6a79 0d					db KEY_CR    ; cr  
6a7a ..					db ' '  
6a7b 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6a7c ..					db 'C'  
6a7d ..					db 'y'  
6a7e ..					db 'v'  
6a7f ..					db 's'  
6a80 ..					db 'B'  
6a81 ..					db 'p'  
6a82 ..					db 'm'  
6a83 ..					db 'j'  
6a84 ..					db 'A'  
6a85 ..					db 'g'  
6a86 ..					db 'd'  
6a87 ..					db 'a'  
6a88			  
6a88			.key_map_fb:  
6a88			  
6a88 ..					db 'A'  
6a89 ..					db '+'   
6a8a ..					db '<'  
6a8b ..					db  "'"    
6a8c			  
6a8c ..					db 'A'  
6a8d ..					db 'z'  
6a8e ..					db 'w'  
6a8f ..					db 't'  
6a90 ..					db 'A'  
6a91 ..					db 'q'  
6a92 ..					db 'n'  
6a93 ..					db 'k'  
6a94 ..					db 'A'  
6a95 ..					db 'h'  
6a96 ..					db 'e'  
6a97 ..			 		db 'b'  
6a98			  
6a98			.key_map_fc:   
6a98			  
6a98			  
6a98 ..					db 'A'  
6a99 ..					db '-'   
6a9a ..					db '>'  
6a9b ..					db  '='   	  
6a9c ..					db 'A'  
6a9d ..					db '?'  
6a9e ..					db 'x'  
6a9f ..					db 'u'  
6aa0 ..					db 'A'  
6aa1 ..					db 'r'  
6aa2 ..					db 'o'  
6aa3 ..					db 'l'  
6aa4 ..					db 'A'  
6aa5 ..					db 'i'  
6aa6 ..					db 'f'  
6aa7 ..					db 'c'  
6aa8			  
6aa8				  
6aa8			.key_map_fd:  
6aa8			  
6aa8 ..					db 'A'  
6aa9 ..					db '/'   
6aaa ..					db '%'   
6aab 08					db KEY_BS  ; back space  
6aac ..					db 'A'  
6aad ..					db '!'  
6aae ..					db '@'  
6aaf ..					db ';'  
6ab0 ..					db 'A'  
6ab1 ..					db ':'  
6ab2 ..					db '.'  
6ab3 ..					db ','  
6ab4 ..					db 'A'  
6ab5 ..					db '$'  
6ab6 ..					db '&'  
6ab7 ..				 	db '"'  
6ab8			  
6ab8					  
6ab8				  
6ab8			  
6ab8			; add cin and cin_wait  
6ab8			  
6ab8 cd c9 6a		cin_wait: 	call cin  
6abb fe 00			cp 0  
6abd 28 f9			jr z, cin_wait   ; block until key press  
6abf			  
6abf f5				push af   ; save key pressed  
6ac0			  
6ac0 cd c9 6a		.cin_wait1:	call cin  
6ac3 fe 00			cp 0  
6ac5 20 f9			jr nz, .cin_wait1  	; wait for key release  
6ac7			  
6ac7 f1				pop af   ; get key  
6ac8 c9				ret  
6ac9			  
6ac9			  
6ac9 cd da 6a		cin: 	call .mtoc  
6acc			  
6acc				; no key held  
6acc fe 00			cp 0  
6ace c8				ret z  
6acf			  
6acf				; stop key bounce  
6acf			  
6acf			;	ld (key_held),a		 ; save it  
6acf 47				ld b, a  
6ad0			  
6ad0 c5			.cina1:	push bc  
6ad1 cd da 6a			call .mtoc  
6ad4 c1				pop bc  
6ad5 b8				cp b  
6ad6 28 f8			jr z, .cina1  
6ad8 78				ld a,b		  
6ad9 c9				ret  
6ada			  
6ada			; detect keyboard modifier key press and apply new overlay to the face key held  
6ada			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6ada			  
6ada			;.cin_map_modifier:   
6ada			;	ld a, (hl)  
6ada			;	and 255  
6ada			;	ret NZ		; modifier key not flagged  
6ada			;  
6ada			;	; get key face  
6ada			;  
6ada			;	ld b,(key_face_held)  
6ada			;  
6ada			;	ld b, key_cols * key_rows  
6ada			;  
6ada			;	push de  
6ada			;	pop hl  
6ada			;  
6ada			;.mmod1: ld a,(hl)   ; get map test  
6ada			;	cp b  
6ada			;	jr z, .mmod2  
6ada			;  
6ada			;  
6ada			;  
6ada			;.mmod2: inc hl    ;   
6ada			;  
6ada			;	  
6ada			;  
6ada			;	  
6ada			;  
6ada			;	ld hl,key_actual_pressed  
6ada			;	ld (hl),a,  
6ada			;	ret  
6ada			  
6ada				  
6ada			  
6ada			; map matrix key held to char on face of key  
6ada			  
6ada			.mtoc:  
6ada			  
6ada			  
6ada				; TODO optimise the code....  
6ada			  
6ada			; scan keyboard row 1  
6ada 3e 80			ld a, 128  
6adc 21 d3 fe			ld hl, keyscan_table  
6adf cd c1 6b			call .rowscan  
6ae2			  
6ae2				   
6ae2			  
6ae2 3e 40			ld a, 64  
6ae4 21 d7 fe			ld hl, keyscan_table+key_cols  
6ae7 cd c1 6b			call .rowscan  
6aea			  
6aea			  
6aea			  
6aea			  
6aea 3e 20			ld a, 32  
6aec 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6aef cd c1 6b			call .rowscan  
6af2			  
6af2			  
6af2			  
6af2 3e 10			ld a, 16  
6af4 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6af7 cd c1 6b			call .rowscan  
6afa			  
6afa			  
6afa				; flag if key D is held down and remove from reporting  
6afa 01 a8 6a			ld bc, .key_map_fd    
6afd 21 d3 fe			ld hl, keyscan_table  
6b00 11 c5 fe			ld de, key_fd  
6b03 cd 53 6b			call .key_shift_hold  
6b06 fe ff			cp 255  
6b08 28 33			jr z, .cinmap  
6b0a				; flag if key C is held down and remove from reporting  
6b0a 01 98 6a			ld bc, .key_map_fc    
6b0d 21 d7 fe			ld hl, keyscan_table+key_cols  
6b10 11 c6 fe			ld de, key_fc  
6b13 cd 53 6b			call .key_shift_hold  
6b16 fe ff			cp 255  
6b18 28 23			jr z, .cinmap  
6b1a				; flag if key B is held down and remove from reporting  
6b1a 01 88 6a			ld bc, .key_map_fb    
6b1d 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6b20 11 c7 fe			ld de, key_fb  
6b23 cd 53 6b			call .key_shift_hold  
6b26 fe ff			cp 255  
6b28 28 13			jr z, .cinmap  
6b2a				; flag if key A is held down and remove from reporting  
6b2a 01 78 6a			ld bc, .key_map_fa    
6b2d 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6b30 11 c8 fe			ld de, key_fa  
6b33 cd 53 6b			call .key_shift_hold  
6b36 fe ff			cp 255  
6b38 28 03			jr z, .cinmap  
6b3a			  
6b3a 11 68 6a			ld de, .matrix_to_char  
6b3d			  
6b3d			  
6b3d			.cinmap:   
6b3d				if DEBUG_KEY  
6b3d			            LD   A, kLCD_Line4  
6b3d			            CALL fLCD_Pos       ;Position cursor to location in A  
6b3d					push de  
6b3d			            LD   DE, keyscan_table  
6b3d			            CALL fLCD_Str       ;Display string pointed to by DE  
6b3d					pop de  
6b3d				endif  
6b3d			  
6b3d				; scan key matrix table for any held key  
6b3d			  
6b3d				; de holds either the default matrix or one selected above  
6b3d			  
6b3d 21 d3 fe			ld hl, keyscan_table  
6b40 06 10			ld b,key_cols*key_rows  
6b42			  
6b42 7e			.cin1:	ld a,(hl)  
6b43 fe 23			cp '#'  
6b45 28 08			jr z, .cinhit  
6b47 23				inc hl  
6b48 13				inc de  
6b49 05				dec b  
6b4a 20 f6			jr nz, .cin1  
6b4c				; no key found held  
6b4c 3e 00			ld a,0  
6b4e c9				ret  
6b4f d5			.cinhit: push de  
6b50 e1				pop hl  
6b51 7e				ld a,(hl)  
6b52 c9				ret  
6b53			  
6b53			; flag a control key is held   
6b53			; hl is key pin, de is flag indicator  
6b53			  
6b53			.key_shift_hold:  
6b53 c5				push bc  
6b54 3e 01			ld a, 1  
6b56 32 4d fd			ld (cursor_shape),a  
6b59 06 00			ld b, 0  
6b5b 7e				ld a, (hl)  
6b5c fe 2e			cp '.'  
6b5e 28 0a			jr z, .key_shift1  
6b60 06 ff			ld b, 255  
6b62 3e 2b			ld a, '+'    ; hide key from later scans  
6b64 77				ld (hl),a  
6b65 3e 02			ld a, 2  
6b67 32 4d fd			ld (cursor_shape),a  
6b6a			.key_shift1:  
6b6a				; write flag indicator  
6b6a 78				ld a,b  
6b6b 12				ld (de),a  
6b6c			  
6b6c d1				pop de    ; de now holds the key map ptr  
6b6d c9				ret  
6b6e			  
6b6e				  
6b6e				  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e			  
6b6e c9				ret  
6b6f			  
6b6f			;	push hl  
6b6f			;	push de  
6b6f			;	push bc  
6b6f			;	call keyscan  
6b6f			;	; map key matrix to ascii value of key face  
6b6f			;  
6b6f			;	ld hl, key_face_map  
6b6f			;	ld de, keyscan_table  
6b6f			;  
6b6f			;	; get how many keys to look at  
6b6f			;	ld b, keyscan_table_len  
6b6f			;	  
6b6f			;  
6b6f			;	; at this stage fall out on first key hit  
6b6f			;	; TODO handle multiple key press  
6b6f			;  
6b6f			;map1:	ld a,(hl)  
6b6f			;	cp '#'  
6b6f			;	jr z, keyhit  
6b6f			;	inc hl  
6b6f			;	inc de  
6b6f			;	dec b  
6b6f			;	jr nz, map1  
6b6f			;nohit:	ld a, 0  
6b6f			;	jr keydone  
6b6f			;keyhit: push de  
6b6f			;	pop hl  
6b6f			;	ld a,(hl)  
6b6f			;keydone:  
6b6f			;	push bc  
6b6f			;	push de  
6b6f			; 	push hl  
6b6f			;	ret   
6b6f			;  
6b6f			  
6b6f			  
6b6f			  
6b6f			  
6b6f			; scan physical key matrix  
6b6f			  
6b6f			  
6b6f			;keyscan:  
6b6f			;  
6b6f			;; for each key_row use keyscanr bit mask for out  
6b6f			;; then read in for keyscanc bitmask  
6b6f			;; save result of row scan to keyscantable  
6b6f			;  
6b6f			;; scan keyboard row 1  
6b6f			;  
6b6f			;	ld b, key_rows  
6b6f			;	ld hl, key_scanr  
6b6f			;	ld de, keyscan_table  
6b6f			;  
6b6f			;rowloop:  
6b6f			;  
6b6f			;	ld a,(hl)		; out bit mask to energise keyboard row  
6b6f			;	call rowscan  
6b6f			;	inc hl  
6b6f			;	dec b  
6b6f			;	jr nz, rowloop  
6b6f			;  
6b6f			;	ret  
6b6f			;  
6b6f			;  
6b6f			;; pass a out bitmask, b row number  
6b6f			;arowscan:   
6b6f			;	push bc  
6b6f			;  
6b6f			;	ld d, b  
6b6f			;  
6b6f			;	; calculate buffer location for this row  
6b6f			;  
6b6f			;	ld hl, keyscan_table	  
6b6f			;kbufr:  ld e, key_cols  
6b6f			;kbufc:	inc hl  
6b6f			;	dec e  
6b6f			;	jr nz, kbufc  
6b6f			;	dec d  
6b6f			;	jr nz, kbufr  
6b6f			;  
6b6f			;	; energise row and read columns  
6b6f			;  
6b6f			;	out (portbdata),a  
6b6f			;	in a,(portbdata)  
6b6f			;	ld c,a  
6b6f			;  
6b6f			;  
6b6f			;	; save buffer loc  
6b6f			;  
6b6f			;	ld (keybufptr), hl  
6b6f			;  
6b6f			;	ld hl, key_scanc  
6b6f			;	ld d, key_cols  
6b6f			;  
6b6f			;	; for each column check each bit mask  
6b6f			;  
6b6f			;colloop:  
6b6f			;	  
6b6f			;  
6b6f			;	; reset flags for the row   
6b6f			;  
6b6f			;	ld b,'.'  
6b6f			;	and (hl)  
6b6f			;	jr z, maskskip  
6b6f			;	ld b,'#'  
6b6f			;maskskip:  
6b6f			;	; save  key state  
6b6f			;	push hl  
6b6f			;	ld hl, (keybufptr)  
6b6f			;	ld (hl), b  
6b6f			;	inc hl  
6b6f			;	ld (keybufptr), hl  
6b6f			;  
6b6f			;	; move to next bit mask  
6b6f			;	pop hl  
6b6f			;	inc hl  
6b6f			;  
6b6f			;	dec d  
6b6f			;	jr nz, colloop  
6b6f			;  
6b6f			;	ret  
6b6f			;  
6b6f			;  
6b6f			;;  
6b6f			; lcd functions  
6b6f			;  
6b6f			;  
6b6f			  
6b6f			;if DEBUG_KEY_MATRIX  
6b6f			  
6b6f			; test function to display hardware view of matrix state  
6b6f			  
6b6f			matrix:  
6b6f			  
6b6f			  
6b6f			  
6b6f			; scan keyboard row 1  
6b6f 3e 80			ld a, 128  
6b71 21 f8 fe			ld hl, keyscan_table_row1  
6b74 cd c1 6b			call .rowscan  
6b77			  
6b77 3e 40			ld a, 64  
6b79 21 f3 fe			ld hl, keyscan_table_row2  
6b7c cd c1 6b			call .rowscan  
6b7f			  
6b7f 3e 20			ld a, 32  
6b81 21 ee fe			ld hl, keyscan_table_row3  
6b84 cd c1 6b			call .rowscan  
6b87			  
6b87 3e 10			ld a, 16  
6b89 21 e9 fe			ld hl, keyscan_table_row4  
6b8c cd c1 6b			call .rowscan  
6b8f			  
6b8f			; Display text on first line  
6b8f 3e 00		            LD   A, kLCD_Line1  
6b91 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6b94 11 f8 fe		            LD   DE, keyscan_table_row1  
6b97			            ;LD   DE, MsgHello  
6b97 cd ef 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6b9a			  
6b9a			; Display text on second line  
6b9a 3e 40		            LD   A, kLCD_Line2  
6b9c cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6b9f 11 f3 fe		            LD   DE, keyscan_table_row2  
6ba2 cd ef 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6ba5 3e 14		            LD   A, kLCD_Line3  
6ba7 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6baa 11 ee fe		            LD   DE, keyscan_table_row3  
6bad cd ef 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6bb0 3e 54		            LD   A, kLCD_Line4  
6bb2 cd e7 69		            CALL fLCD_Pos       ;Position cursor to location in A  
6bb5 11 e9 fe		            LD   DE, keyscan_table_row4  
6bb8 cd ef 69		            CALL fLCD_Str       ;Display string pointed to by DE  
6bbb			  
6bbb cd 06 0c			call delay250ms  
6bbe c3 6f 6b			jp matrix  
6bc1			  
6bc1			; pass de as row display flags  
6bc1			.rowscan:   
6bc1 d3 c1			out (portbdata),a  
6bc3 db c1			in a,(portbdata)  
6bc5 4f				ld c,a  
6bc6				; reset flags for the row   
6bc6 06 2e			ld b,'.'  
6bc8 e6 01			and 1  
6bca 28 02			jr z, .p1on  
6bcc 06 23			ld b,'#'  
6bce			.p1on:  
6bce 70				ld (hl), b  
6bcf 23				inc hl  
6bd0			  
6bd0 06 2e			ld b,'.'  
6bd2 79				ld a,c  
6bd3 e6 02			and 2  
6bd5			;	bit 0,a  
6bd5 28 02			jr z, .p2on  
6bd7 06 23			ld b,'#'  
6bd9			.p2on:  
6bd9 70				ld (hl), b  
6bda 23				inc hl  
6bdb			;  
6bdb 06 2e			ld b,'.'  
6bdd 79				ld a,c  
6bde e6 04			and 4  
6be0			;;	bit 0,a  
6be0 28 02			jr z, .p3on  
6be2 06 23			ld b,'#'  
6be4			.p3on:  
6be4 70				ld (hl), b  
6be5 23				inc hl  
6be6			;;  
6be6 06 2e			ld b,'.'  
6be8			;;	bit 0,a  
6be8 79				ld a,c  
6be9 e6 08			and 8  
6beb 28 02			jr z, .p4on  
6bed 06 23			ld b,'#'  
6bef			.p4on:  
6bef 70				ld (hl), b  
6bf0 23				inc hl  
6bf1			  
6bf1			; zero term  
6bf1 06 00			ld b,0  
6bf3 70				ld (hl), b  
6bf4			  
6bf4 c9			.rscandone: ret  
6bf5			  
6bf5			  
6bf5			  
6bf5			;endif  
6bf5			  
6bf5			  
6bf5			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6bf5
