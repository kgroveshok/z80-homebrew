# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 a9 15			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd b6 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd b6 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd b6 0a				call clear_display  
0023			  
0023			  
0023 cd 2d 61				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 76 62			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b2 10				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd d9 0a			call update_display  
0032 cd 3a 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd bb 0a			call fill_display  
003a cd d9 0a			call update_display  
003d cd 3a 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd bb 0a			call fill_display  
0045 cd d9 0a			call update_display  
0048 cd 3a 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd bb 0a			call fill_display  
0050 cd d9 0a			call update_display  
0053 cd 3a 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd c9 0a			call str_at_display  
005e cd d9 0a			call update_display  
0061			  
0061			  
0061 cd 3a 0a			call delay1s  
0064 cd 3a 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd c9 0a			call str_at_display  
006f cd d9 0a			call update_display  
0072 cd 3a 0a			call delay1s  
0075 cd 3a 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 e3 f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a e3 f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 e3 f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a e3 f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 e3 f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a e5 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a e2 f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 e2 f9			ld (spi_device), a 
01e0 32 e5 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a e3 f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 e3 f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a e3 f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 e3 f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a e3 f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 e3 f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a e3 f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 e3 f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 1f 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a e3 f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 e3 f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a e3 f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 e3 f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a e3 f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 e3 f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a e3 f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 e3 f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 1f 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a e3 f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 e3 f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a e3 f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 e3 f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 ba ef			ld hl,scratch+2 
02bb cd c6 0f			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 db f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 bf ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a db f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a db f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 db f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 db f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 e0 ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a e0 ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a db f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 db f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 e0 ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 db f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd d3 13			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd d3 13			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 1f 06			call storage_findnextid 
035d			 
035d cd 38 0c			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd d3 13			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd d3 13			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd d3 13			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd d3 13			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd d3 13			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 21 e8 f9			ld hl, store_page 
042b 3e 00			ld a, 0 
042d				 
042d 77				ld (hl),a   ; reset file counter 
042e			 
042e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0431 22 e9 f9		 	ld (store_page+1), hl	 
0434			 
0434				; set default label 
0434			 
0434 21 c9 04			ld hl, .defaultbanklabl 
0437 11 eb f9		 	ld de, store_page+3 
043a 01 0f 00			ld bc, 15 
043d ed b0			ldir 
043f			 
043f				; save default page 0 
043f			 
043f 21 00 00			ld hl, 0 
0442 11 e8 f9			ld de, store_page 
0445				if DEBUG_STORESE 
0445					DMARK "SB3" 
0445 f5				push af  
0446 3a 5a 04			ld a, (.dmark)  
0449 32 bd fb			ld (debug_mark),a  
044c 3a 5b 04			ld a, (.dmark+1)  
044f 32 be fb			ld (debug_mark+1),a  
0452 3a 5c 04			ld a, (.dmark+2)  
0455 32 bf fb			ld (debug_mark+2),a  
0458 18 03			jr .pastdmark  
045a ..			.dmark: db "SB3"  
045d f1			.pastdmark: pop af  
045e			endm  
# End of macro DMARK
045e			;		push af 
045e			;		ld a, 'F' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e					CALLMONITOR 
045e cd d3 13			call break_point_state  
0461				endm  
# End of macro CALLMONITOR
0461				endif 
0461 cd 6e 03			call storage_write_block 
0464				if DEBUG_STORESE 
0464					DMARK "SB4" 
0464 f5				push af  
0465 3a 79 04			ld a, (.dmark)  
0468 32 bd fb			ld (debug_mark),a  
046b 3a 7a 04			ld a, (.dmark+1)  
046e 32 be fb			ld (debug_mark+1),a  
0471 3a 7b 04			ld a, (.dmark+2)  
0474 32 bf fb			ld (debug_mark+2),a  
0477 18 03			jr .pastdmark  
0479 ..			.dmark: db "SB4"  
047c f1			.pastdmark: pop af  
047d			endm  
# End of macro DMARK
047d			;		push af 
047d			;		ld a, '>' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d					CALLMONITOR 
047d cd d3 13			call break_point_state  
0480				endm  
# End of macro CALLMONITOR
0480				endif 
0480			 
0480 00				nop 
0481 00				nop 
0482 00				nop 
0483			 
0483				; now set 0 in every page to mark as a free block 
0483			 
0483 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0485 21 40 00			ld hl, STORE_BLOCK_PHY 
0488			 
0488 3e 00		.setmark1:   	ld a,0 
048a e5					push hl 
048b c5					push bc 
048c cd e7 01				call se_writebyte 
048f 3e 0a			ld a, 10 
0491 cd 1f 0a			call aDelayInMS 
0494 23				inc hl 
0495 cd e7 01				call se_writebyte 
0498 3e 0a			ld a, 10 
049a cd 1f 0a			call aDelayInMS 
049d 2b				dec hl 
049e c1					pop bc 
049f e1					pop hl 
04a0 3e 40				ld a, STORE_BLOCK_PHY 
04a2 cd 0f 0c				call addatohl 
04a5 10 e1				djnz .setmark1 
04a7			 
04a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04a9 3e 00		.setmark2:   	ld a,0 
04ab e5					push hl 
04ac c5					push bc 
04ad cd e7 01				call se_writebyte 
04b0 3e 0a			ld a, 10 
04b2 cd 1f 0a			call aDelayInMS 
04b5 23				inc hl 
04b6 cd e7 01				call se_writebyte 
04b9 3e 0a			ld a, 10 
04bb cd 1f 0a			call aDelayInMS 
04be 2b				dec hl 
04bf c1					pop bc 
04c0 e1					pop hl 
04c1 3e 40				ld a, STORE_BLOCK_PHY 
04c3 cd 0f 0c				call addatohl 
04c6 10 e1				djnz .setmark2 
04c8			 
04c8					 
04c8			 
04c8			 
04c8 c9				ret 
04c9			 
04c9			 
04c9			 
04c9			 
04c9 .. 00		.defaultbanklabl:   db "BankLabel",0 
04d3			 
04d3			 
04d3			 
04d3			; Label Bank 
04d3			; ---------- 
04d3			; 
04d3			; With current bank 
04d3			; Read block 0 
04d3			; Set label 
04d3			; Write block 0 
04d3			 
04d3			; label str pointer in hl 
04d3			 
04d3			storage_label:     
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "LBL" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 bd fb			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 be fb			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 bf fb			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "LBL"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec					CALLMONITOR 
04ec cd d3 13			call break_point_state  
04ef				endm  
# End of macro CALLMONITOR
04ef				endif 
04ef			 
04ef e5				push hl 
04f0			 
04f0 cd ba 03			call storage_get_block_0 
04f3			 
04f3				; set default label 
04f3			 
04f3 e1				pop hl 
04f4			 
04f4 11 eb f9		 	ld de, store_page+3 
04f7 01 0f 00			ld bc, 15 
04fa				if DEBUG_STORESE 
04fa					DMARK "LB3" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 bd fb			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 be fb			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 bf fb			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "LB3"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513					CALLMONITOR 
0513 cd d3 13			call break_point_state  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 ed b0			ldir 
0518				; save default page 0 
0518			 
0518 21 00 00			ld hl, 0 
051b 11 e8 f9			ld de, store_page 
051e				if DEBUG_STORESE 
051e					DMARK "LBW" 
051e f5				push af  
051f 3a 33 05			ld a, (.dmark)  
0522 32 bd fb			ld (debug_mark),a  
0525 3a 34 05			ld a, (.dmark+1)  
0528 32 be fb			ld (debug_mark+1),a  
052b 3a 35 05			ld a, (.dmark+2)  
052e 32 bf fb			ld (debug_mark+2),a  
0531 18 03			jr .pastdmark  
0533 ..			.dmark: db "LBW"  
0536 f1			.pastdmark: pop af  
0537			endm  
# End of macro DMARK
0537					CALLMONITOR 
0537 cd d3 13			call break_point_state  
053a				endm  
# End of macro CALLMONITOR
053a				endif 
053a cd 6e 03			call storage_write_block 
053d			 
053d c9				ret 
053e			 
053e			 
053e			 
053e			; Read Block 0 - Config 
053e			; --------------------- 
053e			; 
053e			; With current bank 
053e			; Call presence test 
053e			;    If not present format/init bank  
053e			; Read block 0  
053e			;  
053e			 
053e			 
053e			; Dir 
053e			; --- 
053e			; 
053e			; With current bank 
053e			; Load Block 0 Config 
053e			; Get max file id number 
053e			; For each logical block 
053e			;    Read block read byte 2 
053e			;      if first block of file 
053e			;         Display file name 
053e			;         Display type flags for file 
053e			;        
053e			 
053e			; moving to words as this requires stack control 
053e			 
053e			 
053e			; Delete File 
053e			; ----------- 
053e			; 
053e			; With current bank 
053e			; 
053e			; Load Block 0 Config 
053e			; Get max file id number 
053e			; For each logical block 
053e			;    Read block file id 
053e			;      If first block of file and dont have file id 
053e			;         if file to delete 
053e			;         Save file id 
053e			;         Null file id 
053e			;         Write this block back 
053e			;      If file id is one saved 
053e			;         Null file id 
053e			;         Write this block back 
053e			 
053e			storage_erase: 
053e			 
053e				; hl contains the file id 
053e			 
053e 5d				ld e, l 
053f 16 00			ld d, 0 
0541 21 40 00			ld hl, STORE_BLOCK_PHY 
0544					if DEBUG_FORTH_WORDS 
0544						DMARK "ERA" 
0544 f5				push af  
0545 3a 59 05			ld a, (.dmark)  
0548 32 bd fb			ld (debug_mark),a  
054b 3a 5a 05			ld a, (.dmark+1)  
054e 32 be fb			ld (debug_mark+1),a  
0551 3a 5b 05			ld a, (.dmark+2)  
0554 32 bf fb			ld (debug_mark+2),a  
0557 18 03			jr .pastdmark  
0559 ..			.dmark: db "ERA"  
055c f1			.pastdmark: pop af  
055d			endm  
# End of macro DMARK
055d						CALLMONITOR 
055d cd d3 13			call break_point_state  
0560				endm  
# End of macro CALLMONITOR
0560					endif 
0560 cd 1f 06			call storage_findnextid 
0563			 
0563 e5				push hl 
0564			 
0564				; TODO check file not found 
0564			 
0564 11 e8 f9			ld de, store_page 
0567 cd 09 03			call storage_read_block 
056a			 
056a					if DEBUG_FORTH_WORDS 
056a						DMARK "ER1" 
056a f5				push af  
056b 3a 7f 05			ld a, (.dmark)  
056e 32 bd fb			ld (debug_mark),a  
0571 3a 80 05			ld a, (.dmark+1)  
0574 32 be fb			ld (debug_mark+1),a  
0577 3a 81 05			ld a, (.dmark+2)  
057a 32 bf fb			ld (debug_mark+2),a  
057d 18 03			jr .pastdmark  
057f ..			.dmark: db "ER1"  
0582 f1			.pastdmark: pop af  
0583			endm  
# End of macro DMARK
0583						CALLMONITOR 
0583 cd d3 13			call break_point_state  
0586				endm  
# End of macro CALLMONITOR
0586					endif 
0586 3a e8 f9			ld a, (store_page)	; get file id 
0589 32 e1 f9			ld (store_tmpid), a 
058c			 
058c 3a ea f9			ld a, (store_page+2)    ; get count of extends 
058f 32 e0 f9			ld (store_tmpext), a 
0592			 
0592				; wipe file header 
0592			 
0592 e1				pop hl 
0593 3e 00			ld a, 0 
0595 32 e8 f9			ld (store_page), a 
0598 32 e9 f9			ld (store_page+1),a 
059b 11 e8 f9			ld de, store_page 
059e					if DEBUG_FORTH_WORDS 
059e						DMARK "ER2" 
059e f5				push af  
059f 3a b3 05			ld a, (.dmark)  
05a2 32 bd fb			ld (debug_mark),a  
05a5 3a b4 05			ld a, (.dmark+1)  
05a8 32 be fb			ld (debug_mark+1),a  
05ab 3a b5 05			ld a, (.dmark+2)  
05ae 32 bf fb			ld (debug_mark+2),a  
05b1 18 03			jr .pastdmark  
05b3 ..			.dmark: db "ER2"  
05b6 f1			.pastdmark: pop af  
05b7			endm  
# End of macro DMARK
05b7						CALLMONITOR 
05b7 cd d3 13			call break_point_state  
05ba				endm  
# End of macro CALLMONITOR
05ba					endif 
05ba cd 6e 03			call storage_write_block 
05bd			 
05bd			 
05bd				; wipe file extents 
05bd			 
05bd 3a e0 f9			ld a, (store_tmpext) 
05c0 47				ld b, a 
05c1			 
05c1			.eraext:	  
05c1 c5				push bc 
05c2			 
05c2 21 40 00			ld hl, STORE_BLOCK_PHY 
05c5 3a e1 f9			ld a,(store_tmpid) 
05c8 5f				ld e, a 
05c9 50				ld d, b	 
05ca					if DEBUG_FORTH_WORDS 
05ca						DMARK "ER3" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 bd fb			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 be fb			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 bf fb			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "ER3"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3						CALLMONITOR 
05e3 cd d3 13			call break_point_state  
05e6				endm  
# End of macro CALLMONITOR
05e6					endif 
05e6 cd 1f 06			call storage_findnextid 
05e9			 
05e9 e5				push hl 
05ea 11 e8 f9			ld de, store_page 
05ed cd 09 03			call storage_read_block 
05f0			 
05f0				; free block	 
05f0			 
05f0 3e 00			ld a, 0 
05f2 32 e8 f9			ld (store_page), a 
05f5 32 e9 f9			ld (store_page+1),a 
05f8 11 e8 f9			ld de, store_page 
05fb e1				pop hl 
05fc					if DEBUG_FORTH_WORDS 
05fc						DMARK "ER4" 
05fc f5				push af  
05fd 3a 11 06			ld a, (.dmark)  
0600 32 bd fb			ld (debug_mark),a  
0603 3a 12 06			ld a, (.dmark+1)  
0606 32 be fb			ld (debug_mark+1),a  
0609 3a 13 06			ld a, (.dmark+2)  
060c 32 bf fb			ld (debug_mark+2),a  
060f 18 03			jr .pastdmark  
0611 ..			.dmark: db "ER4"  
0614 f1			.pastdmark: pop af  
0615			endm  
# End of macro DMARK
0615						CALLMONITOR 
0615 cd d3 13			call break_point_state  
0618				endm  
# End of macro CALLMONITOR
0618					endif 
0618 cd 6e 03			call storage_write_block 
061b			 
061b c1				pop bc 
061c 10 a3			djnz .eraext 
061e			 
061e c9				ret 
061f			 
061f			 
061f			; Find Free Block 
061f			; --------------- 
061f			; 
061f			; With current bank 
061f			;  
061f			; From given starting logical block 
061f			;    Read block  
061f			;    If no file id 
061f			;         Return block id 
061f			 
061f			 
061f			; hl starting page number 
061f			; hl contains free page number or zero if no pages free 
061f			; e contains the file id to locate 
061f			; d contains the block number 
061f			 
061f			; TODO change to find file id and use zero for free block 
061f			 
061f			storage_findnextid: 
061f			 
061f				; now locate first 0 page to mark as a free block 
061f			 
061f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0621			;	ld hl, STORE_BLOCK_PHY 
0621			 
0621					if DEBUG_FORTH_WORDS 
0621					DMARK "FNI" 
0621 f5				push af  
0622 3a 36 06			ld a, (.dmark)  
0625 32 bd fb			ld (debug_mark),a  
0628 3a 37 06			ld a, (.dmark+1)  
062b 32 be fb			ld (debug_mark+1),a  
062e 3a 38 06			ld a, (.dmark+2)  
0631 32 bf fb			ld (debug_mark+2),a  
0634 18 03			jr .pastdmark  
0636 ..			.dmark: db "FNI"  
0639 f1			.pastdmark: pop af  
063a			endm  
# End of macro DMARK
063a						CALLMONITOR 
063a cd d3 13			call break_point_state  
063d				endm  
# End of macro CALLMONITOR
063d					endif 
063d			.ff1:   	 
063d e5					push hl 
063e c5					push bc 
063f d5					push de 
0640 cd 89 02				call se_readbyte 
0643 5f					ld e,a 
0644 23					inc hl 
0645 cd 89 02				call se_readbyte 
0648 57					ld d, a 
0649 e1					pop hl 
064a e5					push hl 
064b cd 2d 0c				call cmp16 
064e 28 49				jr z, .fffound 
0650			 
0650 d1					pop de 
0651 c1					pop bc 
0652 e1					pop hl 
0653			 
0653					; is found? 
0653					;cp e 
0653					;ret z 
0653			 
0653 3e 40				ld a, STORE_BLOCK_PHY 
0655 cd 0f 0c				call addatohl 
0658 10 e3				djnz .ff1 
065a			 
065a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065c			.ff2:   	 
065c			 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd 89 02				call se_readbyte 
0662 5f					ld e,a 
0663 23					inc hl 
0664 cd 89 02				call se_readbyte 
0667 57					ld d, a 
0668			 
0668 e1					pop hl 
0669 e5					push hl 
066a cd 2d 0c				call cmp16 
066d 28 2a				jr z, .fffound 
066f			 
066f d1					pop de 
0670 c1					pop bc 
0671 e1					pop hl 
0672					; is found? 
0672					;cp e 
0672					;ret z 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd 0f 0c				call addatohl 
0677 10 e3				djnz .ff2 
0679			 
0679			 
0679					if DEBUG_FORTH_WORDS 
0679					DMARK "FN-" 
0679 f5				push af  
067a 3a 8e 06			ld a, (.dmark)  
067d 32 bd fb			ld (debug_mark),a  
0680 3a 8f 06			ld a, (.dmark+1)  
0683 32 be fb			ld (debug_mark+1),a  
0686 3a 90 06			ld a, (.dmark+2)  
0689 32 bf fb			ld (debug_mark+2),a  
068c 18 03			jr .pastdmark  
068e ..			.dmark: db "FN-"  
0691 f1			.pastdmark: pop af  
0692			endm  
# End of macro DMARK
0692					;	push af 
0692					;	ld a, 'n' 
0692					;	ld (debug_mark),a 
0692					;	pop af 
0692						CALLMONITOR 
0692 cd d3 13			call break_point_state  
0695				endm  
# End of macro CALLMONITOR
0695					endif 
0695				; no free marks! 
0695 21 00 00				ld hl, 0 
0698 c9				ret 
0699			.fffound: 
0699				 
0699			 
0699 d1					pop de 
069a c1					pop bc 
069b e1					pop hl 
069c					if DEBUG_FORTH_WORDS 
069c					DMARK "FNF" 
069c f5				push af  
069d 3a b1 06			ld a, (.dmark)  
06a0 32 bd fb			ld (debug_mark),a  
06a3 3a b2 06			ld a, (.dmark+1)  
06a6 32 be fb			ld (debug_mark+1),a  
06a9 3a b3 06			ld a, (.dmark+2)  
06ac 32 bf fb			ld (debug_mark+2),a  
06af 18 03			jr .pastdmark  
06b1 ..			.dmark: db "FNF"  
06b4 f1			.pastdmark: pop af  
06b5			endm  
# End of macro DMARK
06b5					;	push af 
06b5					;	ld a, 'n' 
06b5					;	ld (debug_mark),a 
06b5					;	pop af 
06b5						CALLMONITOR 
06b5 cd d3 13			call break_point_state  
06b8				endm  
# End of macro CALLMONITOR
06b8					endif 
06b8 c9				ret 
06b9			 
06b9			 
06b9			 
06b9			; Free Space 
06b9			; ---------- 
06b9			; 
06b9			; With current bank 
06b9			; 
06b9			; Set block count to zero 
06b9			; Starting with first logical block 
06b9			;      Find free block  
06b9			;      If block id given, increment block count 
06b9			; 
06b9			;  
06b9			 
06b9			 
06b9			; hl contains count of free blocks 
06b9			 
06b9			storage_freeblocks: 
06b9			 
06b9				; now locate first 0 page to mark as a free block 
06b9			 
06b9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06bb 21 40 00			ld hl, STORE_BLOCK_PHY 
06be 11 00 00			ld de, 0 
06c1			 
06c1			.fb1:   	 
06c1 e5					push hl 
06c2 c5					push bc 
06c3 d5					push de 
06c4 cd 89 02				call se_readbyte 
06c7 d1					pop de 
06c8 c1					pop bc 
06c9 e1					pop hl 
06ca			 
06ca					; is free? 
06ca fe 00				cp 0 
06cc 20 01				jr nz, .ff1cont 
06ce 13					inc de 
06cf			 
06cf			.ff1cont: 
06cf			 
06cf			 
06cf 3e 40				ld a, STORE_BLOCK_PHY 
06d1 cd 0f 0c				call addatohl 
06d4 10 eb				djnz .fb1 
06d6			 
06d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06d8			.fb2:   	 
06d8 e5					push hl 
06d9 c5					push bc 
06da d5					push de 
06db cd 89 02				call se_readbyte 
06de d1					pop de 
06df c1					pop bc 
06e0 e1					pop hl 
06e1			 
06e1					; is free? 
06e1 fe 00				cp 0 
06e3 20 01				jr nz, .ff2cont 
06e5 13					inc de 
06e6			 
06e6			.ff2cont: 
06e6			 
06e6 3e 40				ld a, STORE_BLOCK_PHY 
06e8 cd 0f 0c				call addatohl 
06eb 10 eb				djnz .fb2 
06ed			 
06ed eb				ex de, hl 
06ee c9				ret 
06ef			 
06ef			; Get File ID 
06ef			; ----------- 
06ef			; 
06ef			; With current bank 
06ef			;  
06ef			; Load Block 0 Config 
06ef			; Get max file id number 
06ef			; For each logical block 
06ef			;    Read block file id 
06ef			;      If first block of file and dont have file id 
06ef			;         if file get id and exit 
06ef			 
06ef			 
06ef			 
06ef			 
06ef			; Create File 
06ef			; ----------- 
06ef			; 
06ef			; With current bank  
06ef			; Load Block 0 Config 
06ef			; Get max file id number 
06ef			; Increment file id number 
06ef			; Save Config 
06ef			; Find free block 
06ef			; Set buffer with file name and file id 
06ef			; Write buffer to free block  
06ef			 
06ef			 
06ef			; hl point to file name 
06ef			; hl returns file id 
06ef			 
06ef			; file format: 
06ef			; byte 0 - file id 
06ef			; byte 1 - extent number 
06ef			; byte 2-> data 
06ef			 
06ef			; format for extent number 0: 
06ef			; 
06ef			; byte 0 - file id 
06ef			; byte 1 - extent 0 
06ef			; byte 2 - extent count 
06ef			; byte 3 -> file name and meta data 
06ef			 
06ef			 
06ef			storage_create: 
06ef				if DEBUG_STORESE 
06ef					DMARK "SCR" 
06ef f5				push af  
06f0 3a 04 07			ld a, (.dmark)  
06f3 32 bd fb			ld (debug_mark),a  
06f6 3a 05 07			ld a, (.dmark+1)  
06f9 32 be fb			ld (debug_mark+1),a  
06fc 3a 06 07			ld a, (.dmark+2)  
06ff 32 bf fb			ld (debug_mark+2),a  
0702 18 03			jr .pastdmark  
0704 ..			.dmark: db "SCR"  
0707 f1			.pastdmark: pop af  
0708			endm  
# End of macro DMARK
0708					CALLMONITOR 
0708 cd d3 13			call break_point_state  
070b				endm  
# End of macro CALLMONITOR
070b				endif 
070b			 
070b e5				push hl		; save file name pointer 
070c			 
070c cd ba 03			call storage_get_block_0 
070f			 
070f 3a e8 f9			ld a,(store_page)	; get current file id 
0712 3c				inc a 
0713 32 e8 f9			ld (store_page),a 
0716				 
0716 32 e1 f9			ld (store_tmpid),a			; save id 
0719			 
0719 21 00 00			ld hl, 0 
071c 11 e8 f9			ld de, store_page 
071f				if DEBUG_STORESE 
071f					DMARK "SCw" 
071f f5				push af  
0720 3a 34 07			ld a, (.dmark)  
0723 32 bd fb			ld (debug_mark),a  
0726 3a 35 07			ld a, (.dmark+1)  
0729 32 be fb			ld (debug_mark+1),a  
072c 3a 36 07			ld a, (.dmark+2)  
072f 32 bf fb			ld (debug_mark+2),a  
0732 18 03			jr .pastdmark  
0734 ..			.dmark: db "SCw"  
0737 f1			.pastdmark: pop af  
0738			endm  
# End of macro DMARK
0738					CALLMONITOR 
0738 cd d3 13			call break_point_state  
073b				endm  
# End of macro CALLMONITOR
073b				endif 
073b cd 6e 03			call storage_write_block	 ; save update 
073e			 
073e				if DEBUG_STORESE 
073e 11 e8 f9				ld de, store_page 
0741					DMARK "SCC" 
0741 f5				push af  
0742 3a 56 07			ld a, (.dmark)  
0745 32 bd fb			ld (debug_mark),a  
0748 3a 57 07			ld a, (.dmark+1)  
074b 32 be fb			ld (debug_mark+1),a  
074e 3a 58 07			ld a, (.dmark+2)  
0751 32 bf fb			ld (debug_mark+2),a  
0754 18 03			jr .pastdmark  
0756 ..			.dmark: db "SCC"  
0759 f1			.pastdmark: pop af  
075a			endm  
# End of macro DMARK
075a					CALLMONITOR 
075a cd d3 13			call break_point_state  
075d				endm  
# End of macro CALLMONITOR
075d				endif 
075d				;  
075d				 
075d 21 40 00			ld hl, STORE_BLOCK_PHY 
0760 11 00 00			ld de, 0 
0763 cd 1f 06			call storage_findnextid 
0766			 
0766 22 e6 f9			ld (store_tmppageid), hl    ; save page to use  
0769			 
0769				; TODO detect 0 = no spare blocks 
0769			 
0769				; hl now contains the free page to use for the file header page 
0769			 
0769				if DEBUG_STORESE 
0769				DMARK "SCF" 
0769 f5				push af  
076a 3a 7e 07			ld a, (.dmark)  
076d 32 bd fb			ld (debug_mark),a  
0770 3a 7f 07			ld a, (.dmark+1)  
0773 32 be fb			ld (debug_mark+1),a  
0776 3a 80 07			ld a, (.dmark+2)  
0779 32 bf fb			ld (debug_mark+2),a  
077c 18 03			jr .pastdmark  
077e ..			.dmark: db "SCF"  
0781 f1			.pastdmark: pop af  
0782			endm  
# End of macro DMARK
0782					CALLMONITOR 
0782 cd d3 13			call break_point_state  
0785				endm  
# End of macro CALLMONITOR
0785				endif 
0785			 
0785 22 e6 f9			ld (store_tmppageid), hl 
0788				 
0788 3a e1 f9			ld a,(store_tmpid)    ; get file id 
078b			;	ld a, (store_filecache)			; save to cache 
078b			 
078b 32 e8 f9			ld (store_page),a    ; set page id 
078e 3e 00			ld a, 0			 ; extent 0 is file header 
0790 32 e9 f9			ld (store_page+1), a   ; set file extent 
0793			 
0793 32 ea f9			ld (store_page+2), a   ; extent count for the file 
0796			 
0796			;	inc hl 		; init block 0 of file 
0796			;	inc hl   		; skip file and extent id 
0796			 ;       ld a, 0 
0796			;	ld (hl),a 
0796			;	ld a, (store_filecache+1)  	; save to cache 
0796			 
0796			;	inc hl    ; file name 
0796				 
0796				 
0796 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0799				if DEBUG_STORESE 
0799					DMARK "SCc" 
0799 f5				push af  
079a 3a ae 07			ld a, (.dmark)  
079d 32 bd fb			ld (debug_mark),a  
07a0 3a af 07			ld a, (.dmark+1)  
07a3 32 be fb			ld (debug_mark+1),a  
07a6 3a b0 07			ld a, (.dmark+2)  
07a9 32 bf fb			ld (debug_mark+2),a  
07ac 18 03			jr .pastdmark  
07ae ..			.dmark: db "SCc"  
07b1 f1			.pastdmark: pop af  
07b2			endm  
# End of macro DMARK
07b2					CALLMONITOR 
07b2 cd d3 13			call break_point_state  
07b5				endm  
# End of macro CALLMONITOR
07b5				endif 
07b5 e1				pop hl    ; get zero term string 
07b6 e5				push hl 
07b7 3e 00			ld a, 0 
07b9 cd 78 10			call strlent 
07bc 23				inc hl   ; cover zero term 
07bd 06 00			ld b,0 
07bf 4d				ld c,l 
07c0 e1				pop hl 
07c1				;ex de, hl 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCa" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 bd fb			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 be fb			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 bf fb			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCa"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					;push af 
07da					;ld a, 'a' 
07da					;ld (debug_mark),a 
07da					;pop af 
07da					CALLMONITOR 
07da cd d3 13			call break_point_state  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd ed b0			ldir    ; copy zero term string 
07df				if DEBUG_STORESE 
07df					DMARK "SCA" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 bd fb			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 be fb			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 bf fb			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "SCA"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd d3 13			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb			 
07fb				; write file header page 
07fb			 
07fb 2a e6 f9			ld hl,(store_tmppageid) 
07fe 11 e8 f9			ld de, store_page 
0801				if DEBUG_STORESE 
0801					DMARK "SCb" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 bd fb			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 be fb			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 bf fb			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "SCb"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;push af 
081a					;ld a, 'b' 
081a					;ld (debug_mark),a 
081a					;pop af 
081a					CALLMONITOR 
081a cd d3 13			call break_point_state  
081d				endm  
# End of macro CALLMONITOR
081d				endif 
081d cd 6e 03			call storage_write_block 
0820			 
0820 3a e1 f9			ld a, (store_tmpid) 
0823 6f				ld l, a 
0824 26 00			ld h,0 
0826				if DEBUG_STORESE 
0826					DMARK "SCz" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 bd fb			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 be fb			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 bf fb			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCz"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd d3 13			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842 c9				ret 
0843				 
0843			 
0843			 
0843			; 
0843			; Read File 
0843			; 
0843			; h - file id to locate 
0843			; l - extent to locate 
0843			; de - pointer to string to read into 
0843			; 
0843			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0843			storage_read: 
0843 d5				push de 
0844			 
0844			; TODO BUG the above push is it popped before the RET Z? 
0844			 
0844			; TODO how to handle multiple part blocks 
0844			 
0844				; locate file extent to read 
0844			 
0844 5c				ld e, h 
0845 55				ld d, l 
0846 21 40 00			ld hl, STORE_BLOCK_PHY 
0849				if DEBUG_STORESE 
0849					DMARK "SRE" 
0849 f5				push af  
084a 3a 5e 08			ld a, (.dmark)  
084d 32 bd fb			ld (debug_mark),a  
0850 3a 5f 08			ld a, (.dmark+1)  
0853 32 be fb			ld (debug_mark+1),a  
0856 3a 60 08			ld a, (.dmark+2)  
0859 32 bf fb			ld (debug_mark+2),a  
085c 18 03			jr .pastdmark  
085e ..			.dmark: db "SRE"  
0861 f1			.pastdmark: pop af  
0862			endm  
# End of macro DMARK
0862					CALLMONITOR 
0862 cd d3 13			call break_point_state  
0865				endm  
# End of macro CALLMONITOR
0865				endif 
0865 cd 1f 06			call storage_findnextid 
0868			 
0868				if DEBUG_STORESE 
0868					DMARK "SRf" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 bd fb			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 be fb			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 bf fb			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SRf"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd d3 13			call break_point_state  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884 cd 38 0c			call ishlzero 
0887			;	ld a, l 
0887			;	add h 
0887			;	cp 0 
0887 c8				ret z			; block not found so EOF 
0888			 
0888				; hl contains page number to load 
0888 d1				pop de   ; get storage 
0889 d5				push de 
088a				if DEBUG_STORESE 
088a					DMARK "SRg" 
088a f5				push af  
088b 3a 9f 08			ld a, (.dmark)  
088e 32 bd fb			ld (debug_mark),a  
0891 3a a0 08			ld a, (.dmark+1)  
0894 32 be fb			ld (debug_mark+1),a  
0897 3a a1 08			ld a, (.dmark+2)  
089a 32 bf fb			ld (debug_mark+2),a  
089d 18 03			jr .pastdmark  
089f ..			.dmark: db "SRg"  
08a2 f1			.pastdmark: pop af  
08a3			endm  
# End of macro DMARK
08a3					CALLMONITOR 
08a3 cd d3 13			call break_point_state  
08a6				endm  
# End of macro CALLMONITOR
08a6				endif 
08a6 cd 09 03			call storage_read_block 
08a9			 
08a9			 
08a9			; TODO if block has no zeros then need to read next block  
08a9			 
08a9			 
08a9					 
08a9 e1				pop hl 		 ; return start of data to show as not EOF 
08aa 23				inc hl   ; past file id 
08ab 23				inc hl   ; past ext 
08ac				if DEBUG_STORESE 
08ac					DMARK "SRe" 
08ac f5				push af  
08ad 3a c1 08			ld a, (.dmark)  
08b0 32 bd fb			ld (debug_mark),a  
08b3 3a c2 08			ld a, (.dmark+1)  
08b6 32 be fb			ld (debug_mark+1),a  
08b9 3a c3 08			ld a, (.dmark+2)  
08bc 32 bf fb			ld (debug_mark+2),a  
08bf 18 03			jr .pastdmark  
08c1 ..			.dmark: db "SRe"  
08c4 f1			.pastdmark: pop af  
08c5			endm  
# End of macro DMARK
08c5					CALLMONITOR 
08c5 cd d3 13			call break_point_state  
08c8				endm  
# End of macro CALLMONITOR
08c8				endif 
08c8 c9					ret 
08c9			 
08c9			 
08c9			 
08c9			; 
08c9			; Append File 
08c9			; 
08c9			; hl - file id to locate 
08c9			; de - pointer to (multi block) string to write 
08c9			 
08c9			 
08c9			storage_append: 
08c9				; hl -  file id to append to 
08c9				; de - string to append 
08c9			 
08c9 d5				push de 
08ca				 
08ca				if DEBUG_STORESE 
08ca					DMARK "AP1" 
08ca f5				push af  
08cb 3a df 08			ld a, (.dmark)  
08ce 32 bd fb			ld (debug_mark),a  
08d1 3a e0 08			ld a, (.dmark+1)  
08d4 32 be fb			ld (debug_mark+1),a  
08d7 3a e1 08			ld a, (.dmark+2)  
08da 32 bf fb			ld (debug_mark+2),a  
08dd 18 03			jr .pastdmark  
08df ..			.dmark: db "AP1"  
08e2 f1			.pastdmark: pop af  
08e3			endm  
# End of macro DMARK
08e3					CALLMONITOR 
08e3 cd d3 13			call break_point_state  
08e6				endm  
# End of macro CALLMONITOR
08e6				endif 
08e6			 
08e6 7d				ld a, l 
08e7 32 e1 f9			ld (store_tmpid), a 
08ea			 
08ea				; get file header  
08ea			 
08ea 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ec 3a e1 f9			ld a, (store_tmpid) 
08ef 5f				ld e, a 
08f0			 
08f0 21 40 00				ld hl, STORE_BLOCK_PHY 
08f3 cd 1f 06				call storage_findnextid 
08f6			 
08f6 22 e6 f9			ld (store_tmppageid), hl 
08f9			 
08f9				; TODO handle file id not found 
08f9			 
08f9				if DEBUG_STORESE 
08f9					DMARK "AP2" 
08f9 f5				push af  
08fa 3a 0e 09			ld a, (.dmark)  
08fd 32 bd fb			ld (debug_mark),a  
0900 3a 0f 09			ld a, (.dmark+1)  
0903 32 be fb			ld (debug_mark+1),a  
0906 3a 10 09			ld a, (.dmark+2)  
0909 32 bf fb			ld (debug_mark+2),a  
090c 18 03			jr .pastdmark  
090e ..			.dmark: db "AP2"  
0911 f1			.pastdmark: pop af  
0912			endm  
# End of macro DMARK
0912					CALLMONITOR 
0912 cd d3 13			call break_point_state  
0915				endm  
# End of macro CALLMONITOR
0915				endif 
0915			 
0915				; update file extent count 
0915			 
0915 11 e8 f9			ld de, store_page 
0918			 
0918 cd 09 03			call storage_read_block 
091b			 
091b				if DEBUG_STORESE 
091b					DMARK "AP3" 
091b f5				push af  
091c 3a 30 09			ld a, (.dmark)  
091f 32 bd fb			ld (debug_mark),a  
0922 3a 31 09			ld a, (.dmark+1)  
0925 32 be fb			ld (debug_mark+1),a  
0928 3a 32 09			ld a, (.dmark+2)  
092b 32 bf fb			ld (debug_mark+2),a  
092e 18 03			jr .pastdmark  
0930 ..			.dmark: db "AP3"  
0933 f1			.pastdmark: pop af  
0934			endm  
# End of macro DMARK
0934					CALLMONITOR 
0934 cd d3 13			call break_point_state  
0937				endm  
# End of macro CALLMONITOR
0937				endif 
0937			;	ld (store_tmppageid), hl 
0937			 
0937 3a ea f9			ld a, (store_page+2) 
093a 3c				inc a 
093b 32 ea f9			ld (store_page+2), a 
093e 32 e0 f9			ld (store_tmpext), a 
0941				 
0941				if DEBUG_STORESE 
0941					DMARK "AP3" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 bd fb			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 be fb			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 bf fb			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "AP3"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd d3 13			call break_point_state  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d 2a e6 f9			ld hl, (store_tmppageid) 
0960 11 e8 f9			ld de, store_page 
0963 cd 6e 03			call storage_write_block 
0966			 
0966				; find free block 
0966			 
0966 11 00 00			ld de, 0			 ; file extent to locate 
0969			 
0969 21 40 00				ld hl, STORE_BLOCK_PHY 
096c cd 1f 06				call storage_findnextid 
096f			 
096f					; TODO handle no space left 
096f					 
096f 22 e6 f9				ld (store_tmppageid), hl 
0972			 
0972				if DEBUG_STORESE 
0972					DMARK "AP4" 
0972 f5				push af  
0973 3a 87 09			ld a, (.dmark)  
0976 32 bd fb			ld (debug_mark),a  
0979 3a 88 09			ld a, (.dmark+1)  
097c 32 be fb			ld (debug_mark+1),a  
097f 3a 89 09			ld a, (.dmark+2)  
0982 32 bf fb			ld (debug_mark+2),a  
0985 18 03			jr .pastdmark  
0987 ..			.dmark: db "AP4"  
098a f1			.pastdmark: pop af  
098b			endm  
# End of macro DMARK
098b					CALLMONITOR 
098b cd d3 13			call break_point_state  
098e				endm  
# End of macro CALLMONITOR
098e				endif 
098e					; init the buffer with zeros so we can id if the buffer is full or not 
098e			 
098e e5					push hl 
098f c5					push bc 
0990			 
0990 21 e8 f9				ld hl, store_page 
0993 06 40				ld b, STORE_BLOCK_PHY 
0995 3e 00				ld a, 0 
0997 77			.zeroblock:	ld (hl), a 
0998 23					inc hl 
0999 10 fc				djnz .zeroblock 
099b			 
099b c1					pop bc 
099c e1					pop hl 
099d			 
099d					; construct block 
099d			 
099d 3a e1 f9				ld a, (store_tmpid) 
09a0 32 e8 f9				ld (store_page), a   ; file id 
09a3 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09a6 32 e9 f9				ld (store_page+1), a 
09a9			 
09a9 e1					pop hl    ; get string to write 
09aa 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ac 11 ea f9				ld de, store_page+2 
09af			 
09af				if DEBUG_STORESE 
09af					DMARK "AP5" 
09af f5				push af  
09b0 3a c4 09			ld a, (.dmark)  
09b3 32 bd fb			ld (debug_mark),a  
09b6 3a c5 09			ld a, (.dmark+1)  
09b9 32 be fb			ld (debug_mark+1),a  
09bc 3a c6 09			ld a, (.dmark+2)  
09bf 32 bf fb			ld (debug_mark+2),a  
09c2 18 03			jr .pastdmark  
09c4 ..			.dmark: db "AP5"  
09c7 f1			.pastdmark: pop af  
09c8			endm  
# End of macro DMARK
09c8					CALLMONITOR 
09c8 cd d3 13			call break_point_state  
09cb				endm  
# End of macro CALLMONITOR
09cb				endif 
09cb			 
09cb			 
09cb			 
09cb					; fill buffer with data until end of string or full block 
09cb			 
09cb 7e			.appd:		ld a, (hl) 
09cc 12					ld (de), a 
09cd fe 00				cp 0 
09cf 28 04				jr z, .appdone 
09d1 23					inc hl 
09d2 13					inc de 
09d3 10 f6				djnz .appd 
09d5			 
09d5 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d6 f5					push af   		; save last byte dumped 
09d7			 
09d7			 
09d7 2a e6 f9			ld hl, (store_tmppageid) 
09da 11 e8 f9			ld de, store_page 
09dd				if DEBUG_STORESE 
09dd					DMARK "AP6" 
09dd f5				push af  
09de 3a f2 09			ld a, (.dmark)  
09e1 32 bd fb			ld (debug_mark),a  
09e4 3a f3 09			ld a, (.dmark+1)  
09e7 32 be fb			ld (debug_mark+1),a  
09ea 3a f4 09			ld a, (.dmark+2)  
09ed 32 bf fb			ld (debug_mark+2),a  
09f0 18 03			jr .pastdmark  
09f2 ..			.dmark: db "AP6"  
09f5 f1			.pastdmark: pop af  
09f6			endm  
# End of macro DMARK
09f6					CALLMONITOR 
09f6 cd d3 13			call break_point_state  
09f9				endm  
# End of macro CALLMONITOR
09f9				endif 
09f9 cd 6e 03				call storage_write_block 
09fc			 
09fc			 
09fc				; was that a full block of data written? 
09fc				; any more to write out? 
09fc			 
09fc				; if yes then set vars and jump to start of function again 
09fc			 
09fc f1					pop af 
09fd d1					pop de 
09fe			 
09fe fe 00				cp 0		 ; no, string was fully written 
0a00 c8					ret z 
0a01			 
0a01					; setup vars for next cycle 
0a01			 
0a01 3a e1 f9				ld a, (store_tmpid) 
0a04 6f					ld l, a 
0a05 26 00				ld h, 0 
0a07			 
0a07 c3 c9 08			 	jp storage_append	 ; yes, need to write out some more 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			 
0a0a			if DEBUG_STORECF 
0a0a			storageput:	 
0a0a					ret 
0a0a			storageread: 
0a0a					ld hl, store_page 
0a0a					ld b, 200 
0a0a					ld a,0 
0a0a			.src:		ld (hl),a 
0a0a					inc hl 
0a0a					djnz .src 
0a0a					 
0a0a			 
0a0a					ld de, 0 
0a0a					ld bc, 1 
0a0a					ld hl, store_page 
0a0a					call cfRead 
0a0a			 
0a0a				call cfGetError 
0a0a				ld hl,scratch 
0a0a				call hexout 
0a0a				ld hl, scratch+2 
0a0a				ld a, 0 
0a0a				ld (hl),a 
0a0a				ld de, scratch 
0a0a				ld a,display_row_1 
0a0a				call str_at_display 
0a0a				call update_display 
0a0a			 
0a0a					ld hl, store_page 
0a0a					ld (os_cur_ptr),hl 
0a0a			 
0a0a					ret 
0a0a			endif 
0a0a			 
0a0a			 
0a0a			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0a			 
0a0a			storage_clear_page: 
0a0a e5				push hl 
0a0b d5				push de 
0a0c c5				push bc 
0a0d 21 e8 f9			ld hl, store_page 
0a10 3e 00			ld a, 0 
0a12 77				ld (hl), a 
0a13			 
0a13 11 e9 f9			ld de, store_page+1 
0a16 01 40 00			ld bc, STORE_BLOCK_PHY 
0a19			 
0a19 ed b0			ldir 
0a1b				 
0a1b c1				pop bc 
0a1c d1				pop de 
0a1d e1				pop hl 
0a1e c9				ret 
0a1f			 
0a1f			; eof 
# End of file firmware_storage.asm
0a1f			  
0a1f			; support routines for above hardware abstraction layer  
0a1f			  
0a1f			include "firmware_general.asm"        ; general support functions  
0a1f			 
0a1f			 
0a1f			 
0a1f			; Delay loops 
0a1f			 
0a1f			 
0a1f			 
0a1f			aDelayInMS: 
0a1f c5				push bc 
0a20 47				ld b,a 
0a21			msdelay: 
0a21 c5				push bc 
0a22				 
0a22			 
0a22 01 41 00			ld bc,041h 
0a25 cd 3d 0a			call delayloop 
0a28 c1				pop bc 
0a29 05				dec b 
0a2a 20 f5			jr nz,msdelay 
0a2c			 
0a2c			;if CPU_CLOCK_8MHZ 
0a2c			;msdelay8: 
0a2c			;	push bc 
0a2c			;	 
0a2c			; 
0a2c			;	ld bc,041h 
0a2c			;	call delayloop 
0a2c			;	pop bc 
0a2c			;	dec b 
0a2c			;	jr nz,msdelay8 
0a2c			;endif 
0a2c			 
0a2c			 
0a2c c1				pop bc 
0a2d c9				ret 
0a2e			 
0a2e			 
0a2e			delay250ms: 
0a2e				;push de 
0a2e 01 00 40			ld bc, 04000h 
0a31 c3 3d 0a			jp delayloop 
0a34			delay500ms: 
0a34				;push de 
0a34 01 00 80			ld bc, 08000h 
0a37 c3 3d 0a			jp delayloop 
0a3a			delay1s: 
0a3a				;push bc 
0a3a			   ; Clobbers A, d and e 
0a3a 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a3d			delayloop: 
0a3d c5			    push bc 
0a3e			 
0a3e			if BASE_CPM 
0a3e				ld bc, CPM_DELAY_TUNE 
0a3e			.cpmloop: 
0a3e				push bc 
0a3e			 
0a3e			endif 
0a3e			 
0a3e			 
0a3e			 
0a3e			delayloopi: 
0a3e			;	push bc 
0a3e			;.dl: 
0a3e cb 47		    bit     0,a    	; 8 
0a40 cb 47		    bit     0,a    	; 8 
0a42 cb 47		    bit     0,a    	; 8 
0a44 e6 ff		    and     255  	; 7 
0a46 0b			    dec     bc      	; 6 
0a47 79			    ld      a,c     	; 4 
0a48 b0			    or      b     	; 4 
0a49 c2 3e 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4c				;pop de 
0a4c			;pop bc 
0a4c			 
0a4c			if BASE_CPM 
0a4c				pop bc 
0a4c				 
0a4c			    dec     bc      	; 6 
0a4c			    ld      a,c     	; 4 
0a4c			    or      b     	; 4 
0a4c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4c				 
0a4c			 
0a4c			endif 
0a4c			;if CPU_CLOCK_8MHZ 
0a4c			;    pop bc 
0a4c			;    push bc 
0a4c			;.dl8: 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    and     255  	; 7 
0a4c			;    dec     bc      	; 6 
0a4c			;    ld      a,c     	; 4 
0a4c			;    or      b     	; 4 
0a4c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4c			;endif 
0a4c			 
0a4c			;if CPU_CLOCK_10MHZ 
0a4c			;    pop bc 
0a4c			;    push bc 
0a4c			;.dl8: 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    bit     0,a    	; 8 
0a4c			;    and     255  	; 7 
0a4c			;    dec     bc      	; 6 
0a4c			;    ld      a,c     	; 4 
0a4c			;    or      b     	; 4 
0a4c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4c			;endif 
0a4c c1			    pop bc 
0a4d			 
0a4d c9				ret 
0a4e			 
0a4e			 
0a4e			 
0a4e			; eof 
# End of file firmware_general.asm
0a4e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a4e			; display routines that use the physical hardware abstraction layer 
0a4e			 
0a4e			 
0a4e			; TODO windowing? 
0a4e			 
0a4e			; TODO scroll line up 
0a4e			 
0a4e			scroll_up: 
0a4e			 
0a4e e5				push hl 
0a4f d5				push de 
0a50 c5				push bc 
0a51			 
0a51				; get frame buffer  
0a51			 
0a51 2a 5e fa			ld hl, (display_fb_active) 
0a54 e5				push hl    ; future de destination 
0a55			 
0a55 11 14 00			ld  de, display_cols 
0a58 19				add hl, de 
0a59			 
0a59 d1				pop de 
0a5a			 
0a5a				;ex de, hl 
0a5a 01 4f 00			ld bc, display_fb_len -1  
0a5d			;if DEBUG_FORTH_WORDS 
0a5d			;	DMARK "SCL" 
0a5d			;	CALLMONITOR 
0a5d			;endif	 
0a5d ed b0			ldir 
0a5f			 
0a5f				; wipe bottom row 
0a5f			 
0a5f			 
0a5f 2a 5e fa			ld hl, (display_fb_active) 
0a62 11 50 00			ld de, display_cols*display_rows 
0a65 19				add hl, de 
0a66 06 14			ld b, display_cols 
0a68 3e 20			ld a, ' ' 
0a6a			.scwipe: 
0a6a 77				ld (hl), a 
0a6b 2b				dec hl 
0a6c 10 fc			djnz .scwipe 
0a6e			 
0a6e				;pop hl 
0a6e			 
0a6e c1				pop bc 
0a6f d1				pop de 
0a70 e1				pop hl 
0a71			 
0a71 c9				ret 
0a72			 
0a72			 
0a72			scroll_upo: 
0a72 11 00 00			ld de, display_row_1 
0a75 21 14 00		 	ld hl, display_row_2 
0a78 01 14 00			ld bc, display_cols 
0a7b ed b0			ldir 
0a7d 11 14 00			ld de, display_row_2 
0a80 21 28 00		 	ld hl, display_row_3 
0a83 01 14 00			ld bc, display_cols 
0a86 ed b0			ldir 
0a88 11 28 00			ld de, display_row_3 
0a8b 21 3c 00		 	ld hl, display_row_4 
0a8e 01 14 00			ld bc, display_cols 
0a91 ed b0			ldir 
0a93			 
0a93			; TODO clear row 4 
0a93			 
0a93 c9				ret 
0a94				 
0a94			scroll_down: 
0a94 11 3c 00			ld de, display_row_4 
0a97 21 28 00		 	ld hl, display_row_3 
0a9a 01 14 00			ld bc, display_cols 
0a9d ed b0			ldir 
0a9f 11 28 00			ld de, display_row_3 
0aa2 21 14 00		 	ld hl, display_row_2 
0aa5 01 14 00			ld bc, display_cols 
0aa8 ed b0			ldir 
0aaa 11 14 00			ld de, display_row_2 
0aad 21 00 00		 	ld hl, display_row_1 
0ab0 01 14 00			ld bc, display_cols 
0ab3 ed b0			ldir 
0ab5			; TODO clear row 1 
0ab5 c9				ret 
0ab6			 
0ab6			 
0ab6			 
0ab6			 
0ab6			 
0ab6			; clear active frame buffer 
0ab6			 
0ab6			clear_display: 
0ab6 3e 20			ld a, ' ' 
0ab8 c3 bb 0a			jp fill_display 
0abb			 
0abb			; fill active frame buffer with a char in A 
0abb			 
0abb			fill_display: 
0abb 06 50			ld b,display_fb_len 
0abd 2a 5e fa			ld hl, (display_fb_active) 
0ac0 77			.fd1:	ld (hl),a 
0ac1 23				inc hl 
0ac2 10 fc			djnz .fd1 
0ac4 23				inc hl 
0ac5 3e 00			ld a,0 
0ac7 77				ld (hl),a 
0ac8			 
0ac8			 
0ac8 c9				ret 
0ac9			; Write string (DE) at pos (A) to active frame buffer 
0ac9			 
0ac9 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0acc 06 00					ld b,0 
0ace 4f					ld c,a 
0acf 09					add hl,bc 
0ad0 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ad1 b7			            OR   A              ;Null terminator? 
0ad2 c8			            RET  Z              ;Yes, so finished 
0ad3 77					ld (hl),a 
0ad4 23				inc hl 
0ad5 13			            INC  DE             ;Point to next character 
0ad6 18 f8		            JR   .sad1     ;Repeat 
0ad8 c9					ret 
0ad9			 
0ad9			; using current frame buffer write to physical display 
0ad9			 
0ad9			update_display: 
0ad9 e5				push hl 
0ada 2a 5e fa			ld hl, (display_fb_active) 
0add cd 4c 61			call write_display 
0ae0 e1				pop hl 
0ae1 c9				ret 
0ae2			 
0ae2			; TODO scrolling 
0ae2			 
0ae2			 
0ae2			; move cursor right one char 
0ae2			cursor_right: 
0ae2			 
0ae2				; TODO shift right 
0ae2				; TODO if beyond max col 
0ae2				; TODO       cursor_next_line 
0ae2			 
0ae2 c9				ret 
0ae3			 
0ae3			 
0ae3			cursor_next_line: 
0ae3				; TODO first char 
0ae3				; TODO line down 
0ae3				; TODO if past last row 
0ae3				; TODO    scroll up 
0ae3			 
0ae3 c9				ret 
0ae4			 
0ae4			cursor_left: 
0ae4				; TODO shift left 
0ae4				; TODO if beyond left  
0ae4				; TODO     cursor prev line 
0ae4				 
0ae4 c9				ret 
0ae5			 
0ae5			cursor_prev_line: 
0ae5				; TODO last char 
0ae5				; TODO line up 
0ae5				; TODO if past first row 
0ae5				; TODO   scroll down 
0ae5			 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			cout: 
0ae6				; A - char 
0ae6 c9				ret 
0ae7			 
0ae7			; eof 
0ae7			 
# End of file firmware_display.asm
0ae7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ae7			; random number generators 
0ae7			 
0ae7			 
0ae7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ae7			 
0ae7			 
0ae7			;-----> Generate a random number 
0ae7			; output a=answer 0<=a<=255 
0ae7			; all registers are preserved except: af 
0ae7			random: 
0ae7 e5			        push    hl 
0ae8 d5			        push    de 
0ae9 2a 40 fa		        ld      hl,(randData) 
0aec ed 5f		        ld      a,r 
0aee 57			        ld      d,a 
0aef 5e			        ld      e,(hl) 
0af0 19			        add     hl,de 
0af1 85			        add     a,l 
0af2 ac			        xor     h 
0af3 22 40 fa		        ld      (randData),hl 
0af6 d1			        pop     de 
0af7 e1			        pop     hl 
0af8 c9			        ret 
0af9			 
0af9			 
0af9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0af9			 
0af9			 
0af9			 
0af9			;------LFSR------ 
0af9			;James Montelongo 
0af9			;optimized by Spencer Putt 
0af9			;out: 
0af9			; a = 8 bit random number 
0af9			RandLFSR: 
0af9 21 46 fa		        ld hl,LFSRSeed+4 
0afc 5e			        ld e,(hl) 
0afd 23			        inc hl 
0afe 56			        ld d,(hl) 
0aff 23			        inc hl 
0b00 4e			        ld c,(hl) 
0b01 23			        inc hl 
0b02 7e			        ld a,(hl) 
0b03 47			        ld b,a 
0b04 cb 13		        rl e  
0b06 cb 12			rl d 
0b08 cb 11		        rl c  
0b0a 17				rla 
0b0b cb 13		        rl e  
0b0d cb 12			rl d 
0b0f cb 11		        rl c  
0b11 17				rla 
0b12 cb 13		        rl e  
0b14 cb 12			rl d 
0b16 cb 11		        rl c  
0b18 17				rla 
0b19 67			        ld h,a 
0b1a cb 13		        rl e  
0b1c cb 12			rl d 
0b1e cb 11		        rl c  
0b20 17				rla 
0b21 a8			        xor b 
0b22 cb 13		        rl e  
0b24 cb 12			rl d 
0b26 ac			        xor h 
0b27 a9			        xor c 
0b28 aa			        xor d 
0b29 21 48 fa		        ld hl,LFSRSeed+6 
0b2c 11 49 fa		        ld de,LFSRSeed+7 
0b2f 01 07 00		        ld bc,7 
0b32 ed b8		        lddr 
0b34 12			        ld (de),a 
0b35 c9			        ret 
0b36			 
0b36			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0b36			 
0b36			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0b36			 
0b36			 
0b36			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0b36			 
0b36			prng16: 
0b36			;Inputs: 
0b36			;   (seed1) contains a 16-bit seed value 
0b36			;   (seed2) contains a NON-ZERO 16-bit seed value 
0b36			;Outputs: 
0b36			;   HL is the result 
0b36			;   BC is the result of the LCG, so not that great of quality 
0b36			;   DE is preserved 
0b36			;Destroys: 
0b36			;   AF 
0b36			;cycle: 4,294,901,760 (almost 4.3 billion) 
0b36			;160cc 
0b36			;26 bytes 
0b36 2a 3a fa		    ld hl,(seed1) 
0b39 44			    ld b,h 
0b3a 4d			    ld c,l 
0b3b 29			    add hl,hl 
0b3c 29			    add hl,hl 
0b3d 2c			    inc l 
0b3e 09			    add hl,bc 
0b3f 22 3a fa		    ld (seed1),hl 
0b42 2a 38 fa		    ld hl,(seed2) 
0b45 29			    add hl,hl 
0b46 9f			    sbc a,a 
0b47 e6 2d		    and %00101101 
0b49 ad			    xor l 
0b4a 6f			    ld l,a 
0b4b 22 38 fa		    ld (seed2),hl 
0b4e 09			    add hl,bc 
0b4f c9			    ret 
0b50			 
0b50			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b50			 
0b50			rand32: 
0b50			;Inputs: 
0b50			;   (seed1_0) holds the lower 16 bits of the first seed 
0b50			;   (seed1_1) holds the upper 16 bits of the first seed 
0b50			;   (seed2_0) holds the lower 16 bits of the second seed 
0b50			;   (seed2_1) holds the upper 16 bits of the second seed 
0b50			;   **NOTE: seed2 must be non-zero 
0b50			;Outputs: 
0b50			;   HL is the result 
0b50			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b50			;Destroys: 
0b50			;   AF 
0b50			;Tested and passes all CAcert tests 
0b50			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b50			;it has a period of 18,446,744,069,414,584,320 
0b50			;roughly 18.4 quintillion. 
0b50			;LFSR taps: 0,2,6,7  = 11000101 
0b50			;291cc 
0b50			;seed1_0=$+1 
0b50			;    ld hl,12345 
0b50			;seed1_1=$+1 
0b50			;    ld de,6789 
0b50			;    ld b,h 
0b50			;    ld c,l 
0b50			;    add hl,hl \ rl e \ rl d 
0b50			;    add hl,hl \ rl e \ rl d 
0b50			;    inc l 
0b50			;    add hl,bc 
0b50			;    ld (seed1_0),hl 
0b50			;    ld hl,(seed1_1) 
0b50			;    adc hl,de 
0b50			;    ld (seed1_1),hl 
0b50			;    ex de,hl 
0b50			;seed2_0=$+1 
0b50			;    ld hl,9876 
0b50			;seed2_1=$+1 
0b50			;    ld bc,54321 
0b50			;    add hl,hl \ rl c \ rl b 
0b50			;    ld (seed2_1),bc 
0b50			;    sbc a,a 
0b50			;    and %11000101 
0b50			;    xor l 
0b50			;    ld l,a 
0b50			;    ld (seed2_0),hl 
0b50			;    ex de,hl 
0b50			;    add hl,bc 
0b50			;    ret 
0b50			; 
0b50			 
0b50			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b50			; 20 bytes, 86 cycles (excluding ret) 
0b50			 
0b50			; returns   hl = pseudorandom number 
0b50			; corrupts   a 
0b50			 
0b50			; generates 16-bit pseudorandom numbers with a period of 65535 
0b50			; using the xorshift method: 
0b50			 
0b50			; hl ^= hl << 7 
0b50			; hl ^= hl >> 9 
0b50			; hl ^= hl << 8 
0b50			 
0b50			; some alternative shift triplets which also perform well are: 
0b50			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b50			 
0b50			;  org 32768 
0b50			 
0b50			xrnd: 
0b50 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0b53 3e 00		  ld a,0 
0b55 bd			  cp l 
0b56 20 02		  jr nz, .xrnd1 
0b58 2e 01		  ld l, 1 
0b5a			.xrnd1: 
0b5a			 
0b5a 7c			  ld a,h 
0b5b 1f			  rra 
0b5c 7d			  ld a,l 
0b5d 1f			  rra 
0b5e ac			  xor h 
0b5f 67			  ld h,a 
0b60 7d			  ld a,l 
0b61 1f			  rra 
0b62 7c			  ld a,h 
0b63 1f			  rra 
0b64 ad			  xor l 
0b65 6f			  ld l,a 
0b66 ac			  xor h 
0b67 67			  ld h,a 
0b68			 
0b68 22 3e fa		  ld (xrandc),hl 
0b6b			 
0b6b c9			  ret 
0b6c			;  
0b6c			 
0b6c			 
0b6c			;;;; int maths 
0b6c			 
0b6c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b6c			; Divide 16-bit values (with 16-bit result) 
0b6c			; In: Divide BC by divider DE 
0b6c			; Out: BC = result, HL = rest 
0b6c			; 
0b6c			Div16: 
0b6c 21 00 00		    ld hl,0 
0b6f 78			    ld a,b 
0b70 06 08		    ld b,8 
0b72			Div16_Loop1: 
0b72 17			    rla 
0b73 ed 6a		    adc hl,hl 
0b75 ed 52		    sbc hl,de 
0b77 30 01		    jr nc,Div16_NoAdd1 
0b79 19			    add hl,de 
0b7a			Div16_NoAdd1: 
0b7a 10 f6		    djnz Div16_Loop1 
0b7c 17			    rla 
0b7d 2f			    cpl 
0b7e 47			    ld b,a 
0b7f 79			    ld a,c 
0b80 48			    ld c,b 
0b81 06 08		    ld b,8 
0b83			Div16_Loop2: 
0b83 17			    rla 
0b84 ed 6a		    adc hl,hl 
0b86 ed 52		    sbc hl,de 
0b88 30 01		    jr nc,Div16_NoAdd2 
0b8a 19			    add hl,de 
0b8b			Div16_NoAdd2: 
0b8b 10 f6		    djnz Div16_Loop2 
0b8d 17			    rla 
0b8e 2f			    cpl 
0b8f 41			    ld b,c 
0b90 4f			    ld c,a 
0b91 c9			ret 
0b92			 
0b92			 
0b92			;http://z80-heaven.wikidot.com/math 
0b92			; 
0b92			;Inputs: 
0b92			;     DE and A are factors 
0b92			;Outputs: 
0b92			;     A is not changed 
0b92			;     B is 0 
0b92			;     C is not changed 
0b92			;     DE is not changed 
0b92			;     HL is the product 
0b92			;Time: 
0b92			;     342+6x 
0b92			; 
0b92			Mult16: 
0b92			 
0b92 06 08		     ld b,8          ;7           7 
0b94 21 00 00		     ld hl,0         ;10         10 
0b97 29			       add hl,hl     ;11*8       88 
0b98 07			       rlca          ;4*8        32 
0b99 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b9b 19			         add hl,de   ;--         -- 
0b9c 10 f9		       djnz $-5      ;13*7+8     99 
0b9e c9			ret 
0b9f			 
0b9f			; 
0b9f			; Square root of 16-bit value 
0b9f			; In:  HL = value 
0b9f			; Out:  D = result (rounded down) 
0b9f			; 
0b9f			;Sqr16: 
0b9f			;    ld de,#0040 
0b9f			;    ld a,l 
0b9f			;    ld l,h 
0b9f			;    ld h,d 
0b9f			;    or a 
0b9f			;    ld b,8 
0b9f			;Sqr16_Loop: 
0b9f			;    sbc hl,de 
0b9f			;    jr nc,Sqr16_Skip 
0b9f			;    add hl,de 
0b9f			;Sqr16_Skip: 
0b9f			;    ccf 
0b9f			;    rl d 
0b9f			;    add a,a 
0b9f			;    adc hl,hl 
0b9f			;    add a,a 
0b9f			;    adc hl,hl 
0b9f			;    djnz Sqr16_Loop 
0b9f			;    ret 
0b9f			; 
0b9f			; 
0b9f			; Divide 8-bit values 
0b9f			; In: Divide E by divider C 
0b9f			; Out: A = result, B = rest 
0b9f			; 
0b9f			Div8: 
0b9f af			    xor a 
0ba0 06 08		    ld b,8 
0ba2			Div8_Loop: 
0ba2 cb 13		    rl e 
0ba4 17			    rla 
0ba5 91			    sub c 
0ba6 30 01		    jr nc,Div8_NoAdd 
0ba8 81			    add a,c 
0ba9			Div8_NoAdd: 
0ba9 10 f7		    djnz Div8_Loop 
0bab 47			    ld b,a 
0bac 7b			    ld a,e 
0bad 17			    rla 
0bae 2f			    cpl 
0baf c9			    ret 
0bb0			 
0bb0			; 
0bb0			; Multiply 8-bit value with a 16-bit value (unrolled) 
0bb0			; In: Multiply A with DE 
0bb0			; Out: HL = result 
0bb0			; 
0bb0			Mult12U: 
0bb0 2e 00		    ld l,0 
0bb2 87			    add a,a 
0bb3 30 01		    jr nc,Mult12U_NoAdd0 
0bb5 19			    add hl,de 
0bb6			Mult12U_NoAdd0: 
0bb6 29			    add hl,hl 
0bb7 87			    add a,a 
0bb8 30 01		    jr nc,Mult12U_NoAdd1 
0bba 19			    add hl,de 
0bbb			Mult12U_NoAdd1: 
0bbb 29			    add hl,hl 
0bbc 87			    add a,a 
0bbd 30 01		    jr nc,Mult12U_NoAdd2 
0bbf 19			    add hl,de 
0bc0			Mult12U_NoAdd2: 
0bc0 29			    add hl,hl 
0bc1 87			    add a,a 
0bc2 30 01		    jr nc,Mult12U_NoAdd3 
0bc4 19			    add hl,de 
0bc5			Mult12U_NoAdd3: 
0bc5 29			    add hl,hl 
0bc6 87			    add a,a 
0bc7 30 01		    jr nc,Mult12U_NoAdd4 
0bc9 19			    add hl,de 
0bca			Mult12U_NoAdd4: 
0bca 29			    add hl,hl 
0bcb 87			    add a,a 
0bcc 30 01		    jr nc,Mult12U_NoAdd5 
0bce 19			    add hl,de 
0bcf			Mult12U_NoAdd5: 
0bcf 29			    add hl,hl 
0bd0 87			    add a,a 
0bd1 30 01		    jr nc,Mult12U_NoAdd6 
0bd3 19			    add hl,de 
0bd4			Mult12U_NoAdd6: 
0bd4 29			    add hl,hl 
0bd5 87			    add a,a 
0bd6 d0			    ret nc 
0bd7 19			    add hl,de 
0bd8 c9			    ret 
0bd9			 
0bd9			; 
0bd9			; Multiply 8-bit value with a 16-bit value (right rotating) 
0bd9			; In: Multiply A with DE 
0bd9			;      Put lowest value in A for most efficient calculation 
0bd9			; Out: HL = result 
0bd9			; 
0bd9			Mult12R: 
0bd9 21 00 00		    ld hl,0 
0bdc			Mult12R_Loop: 
0bdc cb 3f		    srl a 
0bde 30 01		    jr nc,Mult12R_NoAdd 
0be0 19			    add hl,de 
0be1			Mult12R_NoAdd: 
0be1 cb 23		    sla e 
0be3 cb 12		    rl d 
0be5 b7			    or a 
0be6 c2 dc 0b		    jp nz,Mult12R_Loop 
0be9 c9			    ret 
0bea			 
0bea			; 
0bea			; Multiply 16-bit values (with 32-bit result) 
0bea			; In: Multiply BC with DE 
0bea			; Out: BCHL = result 
0bea			; 
0bea			Mult32: 
0bea 79			    ld a,c 
0beb 48			    ld c,b 
0bec 21 00 00		    ld hl,0 
0bef 06 10		    ld b,16 
0bf1			Mult32_Loop: 
0bf1 29			    add hl,hl 
0bf2 17			    rla 
0bf3 cb 11		    rl c 
0bf5 30 07		    jr nc,Mult32_NoAdd 
0bf7 19			    add hl,de 
0bf8 ce 00		    adc a,0 
0bfa d2 fe 0b		    jp nc,Mult32_NoAdd 
0bfd 0c			    inc c 
0bfe			Mult32_NoAdd: 
0bfe 10 f1		    djnz Mult32_Loop 
0c00 41			    ld b,c 
0c01 4f			    ld c,a 
0c02 c9			    ret 
0c03			 
0c03			 
0c03			 
0c03			; 
0c03			; Multiply 8-bit values 
0c03			; In:  Multiply H with E 
0c03			; Out: HL = result 
0c03			; 
0c03			Mult8: 
0c03 16 00		    ld d,0 
0c05 6a			    ld l,d 
0c06 06 08		    ld b,8 
0c08			Mult8_Loop: 
0c08 29			    add hl,hl 
0c09 30 01		    jr nc,Mult8_NoAdd 
0c0b 19			    add hl,de 
0c0c			Mult8_NoAdd: 
0c0c 10 fa		    djnz Mult8_Loop 
0c0e c9			    ret 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			 
0c0f			;;http://z80-heaven.wikidot.com/math 
0c0f			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c0f			; 
0c0f			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c0f			;     ld a,16        ;7 
0c0f			;     ld hl,0        ;10 
0c0f			;     jp $+5         ;10 
0c0f			;.DivLoop: 
0c0f			;       add hl,bc    ;-- 
0c0f			;       dec a        ;64 
0c0f			;       jr z,.DivLoopEnd        ;86 
0c0f			; 
0c0f			;       sla e        ;128 
0c0f			;       rl d         ;128 
0c0f			;       adc hl,hl    ;240 
0c0f			;       sbc hl,bc    ;240 
0c0f			;       jr nc,.DivLoop ;23|21 
0c0f			;       inc e        ;-- 
0c0f			;       jp .DivLoop+1 
0c0f			; 
0c0f			;.DivLoopEnd: 
0c0f			 
0c0f			;HL_Div_C: 
0c0f			;Inputs: 
0c0f			;     HL is the numerator 
0c0f			;     C is the denominator 
0c0f			;Outputs: 
0c0f			;     A is the remainder 
0c0f			;     B is 0 
0c0f			;     C is not changed 
0c0f			;     DE is not changed 
0c0f			;     HL is the quotient 
0c0f			; 
0c0f			;       ld b,16 
0c0f			;       xor a 
0c0f			;         add hl,hl 
0c0f			;         rla 
0c0f			;         cp c 
0c0f			;         jr c,$+4 
0c0f			;           inc l 
0c0f			;           sub c 
0c0f			;         djnz $-7 
0c0f			 
0c0f			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c0f			 
0c0f			addatohl: 
0c0f 85			    add   a, l    ; A = A+L 
0c10 6f			    ld    l, a    ; L = A+L 
0c11 8c			    adc   a, h    ; A = A+L+H+carry 
0c12 95			    sub   l       ; A = H+carry 
0c13 67			    ld    h, a    ; H = H+carry 
0c14 c9			ret 
0c15			 
0c15			addatode: 
0c15 83			    add   a, e    ; A = A+L 
0c16 5f			    ld    e, a    ; L = A+L 
0c17 8a			    adc   a, d    ; A = A+L+H+carry 
0c18 93			    sub   e       ; A = H+carry 
0c19 57			    ld    d, a    ; H = H+carry 
0c1a c9			ret 
0c1b			 
0c1b			 
0c1b			addatobc: 
0c1b 81			    add   a, c    ; A = A+L 
0c1c 4f			    ld    c, a    ; L = A+L 
0c1d 88			    adc   a, b    ; A = A+L+H+carry 
0c1e 91			    sub   c       ; A = H+carry 
0c1f 47			    ld    b, a    ; H = H+carry 
0c20 c9			ret 
0c21			 
0c21			subafromhl: 
0c21			   ; If A=0 do nothing 
0c21			    ; Otherwise flip A's sign. Since 
0c21			    ; the upper byte becomes -1, also 
0c21			    ; substract 1 from H. 
0c21 ed 44		    neg 
0c23 ca 2c 0c		    jp    z, Skip 
0c26 25			    dec   h 
0c27			     
0c27			    ; Now add the low byte as usual 
0c27			    ; Two's complement takes care of 
0c27			    ; ensuring the result is correct 
0c27 85			    add   a, l 
0c28 6f			    ld    l, a 
0c29 8c			    adc   a, h 
0c2a 95			    sub   l 
0c2b 67			    ld    h, a 
0c2c			Skip: 
0c2c c9				ret 
0c2d			 
0c2d			 
0c2d			; compare hl and de 
0c2d			; returns:  
0c2d			; if hl = de, z=1, s=0, c0=0 
0c2d			; if hl > de, z=0, s=0, c=0 
0c2d			; if hl < de, z=0, s=1, c=1 
0c2d			cmp16:	 
0c2d b7				or a 
0c2e ed 52			sbc hl,de 
0c30 e0				ret po 
0c31 7c				ld a,h 
0c32 1f				rra 
0c33 ee 40			xor 01000000B 
0c35 37				scf 
0c36 8f				adc a,a 
0c37 c9				ret 
0c38			 
0c38			 
0c38			; test if hl contains zero   - A is destroyed 
0c38			 
0c38			ishlzero:    
0c38 b7				or a     ; reset flags 
0c39 7c				ld a, h 
0c3a b5				or l        	 
0c3b			 
0c3b c9				ret 
0c3c			 
0c3c			 
0c3c			 
0c3c			 
0c3c			if FORTH_ENABLE_FLOATMATH 
0c3c			;include "float/bbcmath.z80" 
0c3c			include "float/lpfpcalc.asm" 
0c3c			endif 
0c3c			 
0c3c			 
0c3c			; eof 
0c3c			 
# End of file firmware_maths.asm
0c3c			include "firmware_strings.asm"   ; string handling  
0c3c			 
0c3c			 
0c3c			; TODO string len 
0c3c			; input text string, end on cr with zero term 
0c3c			; a offset into frame buffer to start prompt 
0c3c			; d is max length 
0c3c			; e is display size TODO 
0c3c			; c is current cursor position 
0c3c			; hl is ptr to where string will be stored 
0c3c			 
0c3c			 
0c3c			; TODO check limit of buffer for new inserts 
0c3c			; TODO check insert does not push beyond buffer 
0c3c			; TODO scroll in a limited display area 
0c3c			; TODO scroll whole screen on page wrap 
0c3c			 
0c3c			 
0c3c			; TODO handle KEY_PREVWORD 
0c3c			; TODO handle KEY_NEXTWORD 
0c3c			; TODO handle KEY_HOME 
0c3c			; TODO handle KEY_END 
0c3c			; TODO use LCD cursor? 
0c3c			 
0c3c 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0c3f 81					add c 
0c40 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0c43 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0c46 79					ld a, c 
0c47 cd 0f 0c				call addatohl 
0c4a 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c4d 7a					ld a,d 
0c4e 32 b8 fb			        ld (input_size), a       ; save length of input area 
0c51 79					ld a, c 
0c52 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0c55 7b					ld a,e 
0c56 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c59					 
0c59					 
0c59			 
0c59			;		ld a,(input_ptr) 
0c59			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c59			 
0c59			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c59					; init cursor shape if not set by the cin routines 
0c59 21 56 fa				ld hl, cursor_shape 
0c5c 3e ff				ld a, 255 
0c5e 77					ld (hl), a 
0c5f 23					inc hl 
0c60 3e 00				ld a, 0 
0c62 77					ld (hl), a 
0c63			 
0c63 3e 0f				ld a, CUR_BLINK_RATE 
0c65 32 b2 fb				ld (input_cur_flash), a 
0c68 3e 01				ld a, 1 
0c6a 32 b1 fb				ld (input_cur_onoff),a 
0c6d			 
0c6d			;	if DEBUG_INPUT 
0c6d			;		push af 
0c6d			;		ld a, 'I' 
0c6d			;		ld (debug_mark),a 
0c6d			;		pop af 
0c6d			;		CALLMONITOR 
0c6d			;	endif 
0c6d			.is1:		; main entry loop 
0c6d			 
0c6d			 
0c6d			 
0c6d					; pause 1ms 
0c6d			 
0c6d 3e 01				ld a, 1 
0c6f cd 1f 0a				call aDelayInMS 
0c72			 
0c72					; dec flash counter 
0c72 3a b2 fb				ld a, (input_cur_flash) 
0c75 3d					dec a 
0c76 32 b2 fb				ld (input_cur_flash), a 
0c79 fe 00				cp 0 
0c7b 20 0d				jr nz, .nochgstate 
0c7d			 
0c7d			 
0c7d					; change state 
0c7d 3a b1 fb				ld a,(input_cur_onoff) 
0c80 ed 44				neg 
0c82 32 b1 fb				ld (input_cur_onoff),a 
0c85			 
0c85			 
0c85					; reset on change of state 
0c85 3e 0f				ld a, CUR_BLINK_RATE 
0c87 32 b2 fb				ld (input_cur_flash), a 
0c8a			 
0c8a			.nochgstate: 
0c8a					 
0c8a					 
0c8a			 
0c8a					; display cursor  
0c8a			 
0c8a			;		ld hl, (input_start) 
0c8a			;		ld a, (input_cursor) 
0c8a			;		call addatohl 
0c8a			 
0c8a					; get char under cursor and replace with cursor 
0c8a 2a bb fb		ld hl, (input_ptr) 
0c8d			;		ld a, (hl) 
0c8d			;		ld (input_under_cursor),a 
0c8d			;		ld a, '_' 
0c8d			;		ld (hl), a 
0c8d			 
0c8d					; display string 
0c8d			 
0c8d ed 5b b9 fb			ld de, (input_start) 
0c91 3a b6 fb				ld a, (input_at_pos) 
0c94 cd c9 0a				call str_at_display 
0c97			;	        call update_display 
0c97			 
0c97					; find place to put the cursor 
0c97			;		add h 
0c97			;		ld l, display_row_1 
0c97			;		sub l 
0c97			; (input_at_pos) 
0c97					;ld c, a 
0c97			;		ld a, (input_cursor) 
0c97			;		ld l, (input_at_pos) 
0c97			;		;ld b, h 
0c97			;		add l 
0c97			;		ld (input_at_cursor),a 
0c97					;ld l,h 
0c97			 
0c97			;		ld h, 0 
0c97			;		ld l,(input_at_pos) 
0c97			;		ld a, (input_cursor) 
0c97			;		call addatohl 
0c97			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c97			;		call subafromhl 
0c97			;		ld a,l 
0c97			;		ld (input_at_cursor), a 
0c97			 
0c97				if DEBUG_INPUT 
0c97					ld a, (hardware_diag) 
0c97					cp 0 
0c97					jr z, .skip_input_diag 
0c97			 
0c97					ld a,(input_at_pos) 
0c97					ld hl, LFSRSeed 
0c97					call hexout 
0c97					ld a, (input_cursor) 
0c97					ld hl, LFSRSeed+2 
0c97					call hexout 
0c97					ld a,(input_at_cursor) 
0c97					ld hl, LFSRSeed+4 
0c97					call hexout 
0c97			 
0c97					ld a,(input_cur_onoff) 
0c97					ld hl, LFSRSeed+6 
0c97					call hexout 
0c97			 
0c97					ld a,(input_cur_flash) 
0c97					ld hl, LFSRSeed+8 
0c97					call hexout 
0c97			 
0c97					ld a,(input_len) 
0c97					ld hl, LFSRSeed+10 
0c97					call hexout 
0c97					ld hl, LFSRSeed+12 
0c97					ld a, 0 
0c97					ld (hl),a 
0c97					ld a, display_row_4 
0c97					ld de, LFSRSeed 
0c97					call str_at_display 
0c97					.skip_input_diag: 
0c97				endif 
0c97			 
0c97					; decide on if we are showing the cursor this time round 
0c97			 
0c97 3a b1 fb				ld a, (input_cur_onoff) 
0c9a fe ff				cp 255 
0c9c 28 13				jr z, .skipcur 
0c9e			 
0c9e			 
0c9e 3a b4 fb				ld a,(input_at_cursor) 
0ca1 11 56 fa				ld de, cursor_shape 
0ca4 cd c9 0a				call str_at_display 
0ca7			 
0ca7					; save length of current input string 
0ca7 2a b9 fb				ld hl, (input_start) 
0caa cd 6d 10				call strlenz 
0cad 7d					ld a,l 
0cae 32 ac fb				ld (input_len),a 
0cb1			 
0cb1			.skipcur: 
0cb1			 
0cb1 cd d9 0a			        call update_display 
0cb4					 
0cb4			 
0cb4			 
0cb4					; wait 
0cb4				 
0cb4					; TODO loop without wait to flash the cursor and char under cursor	 
0cb4 cd 01 63				call cin    ; _wait 
0cb7			 
0cb7 fe 00				cp 0 
0cb9 ca 6d 0c				jp z, .is1 
0cbc			 
0cbc					; get ptr to char to input into 
0cbc			 
0cbc 4f					ld c,a 
0cbd 2a b9 fb				ld hl, (input_start) 
0cc0 3a a7 fb				ld a, (input_cursor) 
0cc3 cd 0f 0c				call addatohl 
0cc6 22 bb fb				ld (input_ptr), hl 
0cc9 79					ld a,c 
0cca			 
0cca					; replace char under cursor 
0cca			 
0cca			;		ld hl, (input_ptr) 
0cca			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0cca			;		ld (hl), a 
0cca			 
0cca			;	if DEBUG_INPUT 
0cca			;		push af 
0cca			;		ld a, 'i' 
0cca			;		ld (debug_mark),a 
0cca			;		pop af 
0cca			;		CALLMONITOR 
0cca			;	endif 
0cca fe 0e				cp KEY_HOME 
0ccc 20 0e				jr nz, .iske 
0cce			 
0cce 3a b6 fb				ld a, (input_at_pos) 
0cd1 32 b4 fb				ld (input_at_cursor),a 
0cd4 3e 00				ld a, 0 
0cd6 32 a7 fb				ld (input_cursor), a 
0cd9 c3 6d 0c				jp .is1 
0cdc					 
0cdc fe 0f		.iske:		cp KEY_END 
0cde 20 03				jr nz, .isknw 
0ce0 c3 6d 0c				jp .is1 
0ce3			 
0ce3 fe 06		.isknw:		cp KEY_NEXTWORD 
0ce5 20 1b				jr nz, .iskpw 
0ce7			 
0ce7 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0cea 7e					ld a,(hl)	 
0ceb fe 00				cp 0 
0ced ca 6d 0c				jp z, .is1    ; end of string 
0cf0 fe 20				cp ' ' 
0cf2 ca 6d 0c				jp z, .is1    ; end of word 
0cf5 23					inc hl 
0cf6 22 bb fb				ld (input_ptr), hl 
0cf9 3a b4 fb				ld a, (input_at_cursor) 
0cfc 3c					inc a 
0cfd 32 b4 fb				ld (input_at_cursor), a 
0d00 18 e5				jr .isknwm 
0d02			 
0d02 fe 07		.iskpw:		cp KEY_PREVWORD 
0d04 20 1b				jr nz, .iskl 
0d06			.iskpwm:	 
0d06 2a bb fb				ld hl, (input_ptr) 
0d09 7e					ld a,(hl)	 
0d0a fe 00				cp 0  
0d0c ca 6d 0c				jp z, .is1    ; end of string 
0d0f fe 20				cp ' ' 
0d11 ca 6d 0c				jp z, .is1    ; end of word 
0d14 2b					dec hl 
0d15 22 bb fb				ld (input_ptr), hl 
0d18 3a b4 fb				ld a, (input_at_cursor) 
0d1b 3d					dec a 
0d1c 32 b4 fb				ld (input_at_cursor), a 
0d1f 18 e5				jr .iskpwm 
0d21			 
0d21			 
0d21 fe 0b		.iskl:		cp KEY_LEFT 
0d23 20 27				jr nz, .isk1 
0d25			 
0d25 3a a7 fb				ld a, (input_cursor) 
0d28			 
0d28 fe 00				cp 0 
0d2a ca 6d 0c				jp z, .is1 		; at start of line to ignore  
0d2d			 
0d2d 3d					dec  a 		; TODO check underflow 
0d2e 32 a7 fb				ld (input_cursor), a 
0d31			 
0d31 2a bb fb				ld hl, (input_ptr) 
0d34 2b					dec hl 
0d35 22 bb fb				ld (input_ptr), hl 
0d38					 
0d38 3a b4 fb				ld a, (input_at_cursor) 
0d3b 3d					dec a 
0d3c 32 b4 fb				ld (input_at_cursor), a 
0d3f			 
0d3f 3e 01				ld a, 1		; show cursor moving 
0d41 32 b1 fb				ld (input_cur_onoff),a 
0d44 3e 0f				ld a, CUR_BLINK_RATE 
0d46 32 b2 fb				ld (input_cur_flash), a 
0d49			 
0d49 c3 6d 0c				jp .is1 
0d4c			 
0d4c fe 0c		.isk1:		cp KEY_RIGHT 
0d4e 20 2a				jr nz, .isk2 
0d50			 
0d50 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d53 5f					ld e,a 
0d54 3a a7 fb				ld a, (input_cursor) 
0d57 bb					cp e 
0d58 ca 6d 0c				jp z, .is1		; at the end of string so dont go right 
0d5b			 
0d5b 3c					inc  a 		; TODO check overflow 
0d5c 32 a7 fb				ld (input_cursor), a 
0d5f			 
0d5f 3a b4 fb				ld a, (input_at_cursor) 
0d62 3c					inc a 
0d63 32 b4 fb				ld (input_at_cursor), a 
0d66			 
0d66 2a bb fb				ld hl, (input_ptr) 
0d69 23					inc hl 
0d6a 22 bb fb				ld (input_ptr), hl 
0d6d			 
0d6d 3e 01				ld a, 1		; show cursor moving 
0d6f 32 b1 fb				ld (input_cur_onoff),a 
0d72 3e 0f				ld a, CUR_BLINK_RATE 
0d74 32 b2 fb				ld (input_cur_flash), a 
0d77			 
0d77 c3 6d 0c				jp .is1 
0d7a			 
0d7a fe 05		.isk2:		cp KEY_UP 
0d7c			 
0d7c 20 26				jr nz, .isk3 
0d7e			 
0d7e					; swap last command with the current on 
0d7e			 
0d7e					; move cursor to start of string 
0d7e 2a b9 fb				ld hl, (input_start) 
0d81 22 bb fb				ld (input_ptr), hl 
0d84			 
0d84 3a b6 fb				ld a, (input_at_pos) 
0d87 32 b4 fb				ld (input_at_cursor), a 
0d8a			 
0d8a 3e 00				ld a, 0 
0d8c 32 a7 fb				ld (input_cursor), a 
0d8f					 
0d8f					; swap input and last command buffers 
0d8f			 
0d8f 21 df f2				ld hl, os_cli_cmd 
0d92 11 de f3				ld de, os_last_cmd 
0d95 06 ff				ld b, 255 
0d97 7e			.swap1:		ld a, (hl) 
0d98 4f					ld c,a 
0d99 1a					ld a, (de) 
0d9a 77					ld (hl), a 
0d9b 79					ld a,c 
0d9c 12					ld (de),a 
0d9d 23					inc hl 
0d9e 13					inc de 
0d9f 10 f6				djnz .swap1 
0da1			 
0da1			 
0da1			 
0da1			 
0da1			 
0da1 c3 6d 0c				jp .is1 
0da4			 
0da4 fe 08		.isk3:		cp KEY_BS 
0da6 20 3c				jr nz, .isk4 
0da8			 
0da8 3a a7 fb				ld a, (input_cursor) 
0dab			 
0dab fe 00				cp 0 
0dad ca 6d 0c				jp z, .is1 		; at start of line to ignore  
0db0			 
0db0 3d					dec  a 		; TODO check underflow 
0db1 32 a7 fb				ld (input_cursor), a 
0db4			 
0db4					; hl is source 
0db4					; de needs to be source - 1 
0db4			 
0db4			;		ld a, 0 
0db4			;		dec hl 
0db4			;		ld (hl), a 
0db4			 
0db4 2a bb fb				ld hl, (input_ptr) 
0db7 2b					dec hl 
0db8 22 bb fb				ld (input_ptr), hl 
0dbb			 
0dbb					; shift all data 
0dbb			 
0dbb e5					push hl 
0dbc 23					inc hl 
0dbd d1					pop de 
0dbe 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0dc1 4f					ld c,a 
0dc2 06 00				ld b,0 
0dc4 ed b0				ldir  
0dc6			 
0dc6			 
0dc6			 
0dc6			 
0dc6 3a b4 fb				ld a, (input_at_cursor) 
0dc9 3d					dec a 
0dca 32 b4 fb				ld (input_at_cursor), a 
0dcd			 
0dcd			 
0dcd 3e 01				ld a, 1		; show cursor moving 
0dcf 32 b1 fb				ld (input_cur_onoff),a 
0dd2 3e 0f				ld a, CUR_BLINK_RATE 
0dd4 32 b2 fb				ld (input_cur_flash), a 
0dd7			 
0dd7					; remove char 
0dd7 3a b4 fb				ld a, (input_at_cursor) 
0dda 3c					inc a 
0ddb 11 65 0e				ld de,.iblank 
0dde cd c9 0a				call str_at_display 
0de1			 
0de1 c3 6d 0c				jp .is1 
0de4			 
0de4 fe 0d		.isk4:		cp KEY_CR 
0de6 28 6c				jr z, .endinput 
0de8			 
0de8					; else add the key press to the end 
0de8			 
0de8 4f					ld c, a			; save key pressed 
0de9			 
0de9 7e					ld a,(hl)		; get what is currently under char 
0dea			 
0dea fe 00				cp 0			; we are at the end of the string 
0dec 20 2f				jr nz, .onchar 
0dee					 
0dee					; add a char to the end of the string 
0dee				 
0dee 71					ld (hl),c 
0def 23					inc hl 
0df0			;		ld a,' ' 
0df0			;		ld (hl),a 
0df0			;		inc hl 
0df0 3e 00				ld a,0 
0df2 77					ld (hl),a 
0df3 2b					dec hl 
0df4			 
0df4 3a a7 fb				ld a, (input_cursor) 
0df7 3c					inc a				; TODO check max string length and scroll  
0df8 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0dfb							 
0dfb 3a b4 fb				ld a, (input_at_cursor) 
0dfe 3c					inc a 
0dff 32 b4 fb				ld (input_at_cursor), a 
0e02			 
0e02 2a bb fb				ld hl, (input_ptr) 
0e05 23					inc hl 
0e06 22 bb fb				ld (input_ptr), hl 
0e09			 
0e09 2a bb fb				ld hl, (input_ptr) 
0e0c 23					inc hl 
0e0d 22 bb fb				ld (input_ptr), hl 
0e10			;	if DEBUG_INPUT 
0e10			;		push af 
0e10			;		ld a, '+' 
0e10			;		ld (debug_mark),a 
0e10			;		pop af 
0e10			;		CALLMONITOR 
0e10			;	endif 
0e10 3e 01				ld a, 1		; show cursor moving 
0e12 32 b1 fb				ld (input_cur_onoff),a 
0e15 3e 0f				ld a, CUR_BLINK_RATE 
0e17 32 b2 fb				ld (input_cur_flash), a 
0e1a c3 6d 0c				jp .is1 
0e1d					 
0e1d			 
0e1d			 
0e1d					; if on a char then insert 
0e1d			.onchar: 
0e1d			 
0e1d					; TODO over flow check: make sure insert does not blow out buffer 
0e1d			 
0e1d					; need to do some maths to use lddr 
0e1d			 
0e1d e5					push hl   ; save char pos 
0e1e c5					push bc 
0e1f			 
0e1f 2a b9 fb				ld hl, (input_start) 
0e22 3a ac fb				ld a, (input_len) 
0e25 cd 0f 0c				call addatohl  		; end of string 
0e28 23					inc hl 
0e29 23					inc hl		; past zero term 
0e2a e5					push hl 
0e2b 23					inc hl 
0e2c e5					push hl  
0e2d			 
0e2d								; start and end of lddr set, now how much to move? 
0e2d			 
0e2d							 
0e2d 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0e30 47					ld b,a 
0e31 3a ac fb				ld a,(input_len) 
0e34 5f					ld e,a 
0e35 90					sub b 
0e36 3c					inc a		;?? 
0e37 3c					inc a		;?? 
0e38 3c					inc a		;?? 
0e39			 
0e39 06 00				ld b,0 
0e3b 4f					ld c,a 
0e3c			 
0e3c				if DEBUG_INPUT 
0e3c					push af 
0e3c					ld a, 'i' 
0e3c					ld (debug_mark),a 
0e3c					pop af 
0e3c			;		CALLMONITOR 
0e3c				endif 
0e3c d1					pop de 
0e3d e1					pop hl 
0e3e				if DEBUG_INPUT 
0e3e					push af 
0e3e					ld a, 'I' 
0e3e					ld (debug_mark),a 
0e3e					pop af 
0e3e			;		CALLMONITOR 
0e3e				endif 
0e3e ed b8				lddr 
0e40				 
0e40			 
0e40			 
0e40					; TODO have a key for insert/overwrite mode???? 
0e40 c1					pop bc 
0e41 e1					pop hl 
0e42 71					ld (hl), c		; otherwise overwrite current char 
0e43					 
0e43			 
0e43			 
0e43			 
0e43 3a a7 fb				ld a, (input_cursor) 
0e46 3c					inc  a 		; TODO check overflow 
0e47 32 a7 fb				ld (input_cursor), a 
0e4a			 
0e4a 3a b4 fb				ld a, (input_at_cursor) 
0e4d 3c					inc a 
0e4e 32 b4 fb				ld (input_at_cursor), a 
0e51			 
0e51 c3 6d 0c				jp .is1 
0e54			 
0e54			.endinput:	; TODO look for end of string 
0e54			 
0e54					; add trailing space for end of token 
0e54			 
0e54 2a b9 fb				ld hl, (input_start) 
0e57 3a ac fb				ld a,(input_len) 
0e5a cd 0f 0c				call addatohl 
0e5d 3e 20				ld a, ' ' 
0e5f 77					ld (hl),a 
0e60					; TODO eof of parse marker 
0e60			 
0e60 23					inc hl 
0e61 3e 00				ld a, 0 
0e63 77					ld (hl),a 
0e64			 
0e64			 
0e64 c9					ret 
0e65			 
0e65 .. 00		.iblank: db " ",0 
0e67			 
0e67			 
0e67 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0e6a 22 b9 fb				ld (input_start), hl 
0e6d 3e 01				ld a,1			; add cursor 
0e6f 77					ld (hl),a 
0e70 23					inc hl 
0e71 3e 00				ld a,0 
0e73 77					ld (hl),a 
0e74 22 bb fb				ld (input_ptr), hl 
0e77 7a					ld a,d 
0e78 32 b8 fb				ld (input_size), a 
0e7b 3e 00				ld a,0 
0e7d 32 a7 fb				ld (input_cursor),a 
0e80			.instr1:	 
0e80			 
0e80					; TODO do block cursor 
0e80					; TODO switch cursor depending on the modifer key 
0e80			 
0e80					; update cursor shape change on key hold 
0e80			 
0e80 2a bb fb				ld hl, (input_ptr) 
0e83 2b					dec hl 
0e84 3a 56 fa				ld a,(cursor_shape) 
0e87 77					ld (hl), a 
0e88			 
0e88					; display entered text 
0e88 3a b6 fb				ld a,(input_at_pos) 
0e8b cd 1f 62		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e8e ed 5b b9 fb	            	LD   de, (input_start) 
0e92 cd 27 62		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e95			 
0e95 cd 01 63				call cin 
0e98 fe 00				cp 0 
0e9a 28 e4				jr z, .instr1 
0e9c			 
0e9c					; proecess keyboard controls first 
0e9c			 
0e9c 2a bb fb				ld hl,(input_ptr) 
0e9f			 
0e9f fe 0d				cp KEY_CR	 ; pressing enter ends input 
0ea1 28 5a				jr z, .instrcr 
0ea3			 
0ea3 fe 08				cp KEY_BS 	; back space 
0ea5 20 0f				jr nz, .instr2 
0ea7					; process back space 
0ea7			 
0ea7					; TODO stop back space if at start of string 
0ea7 2b					dec hl 
0ea8 2b					dec hl ; to over write cursor 
0ea9 3a 56 fa				ld a,(cursor_shape) 
0eac					;ld a,0 
0eac 77					ld (hl),a 
0ead 23					inc hl 
0eae 3e 20				ld a," " 
0eb0 77					ld (hl),a 
0eb1 22 bb fb				ld (input_ptr),hl 
0eb4					 
0eb4			 
0eb4 18 ca				jr .instr1 
0eb6			 
0eb6 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0eb8 20 06				jr nz, .instr3 
0eba 2b					dec hl 
0ebb 22 bb fb				ld (input_ptr),hl 
0ebe 18 c0				jr .instr1 
0ec0				 
0ec0 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0ec2 20 06				jr nz, .instr4 
0ec4 23					inc hl 
0ec5 22 bb fb				ld (input_ptr),hl 
0ec8 18 b6				jr .instr1 
0eca			 
0eca fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0ecc 20 06				jr nz, .instr5 
0ece 2b					dec hl 
0ecf 22 bb fb				ld (input_ptr),hl 
0ed2 18 ac				jr .instr1 
0ed4			 
0ed4 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0ed6 20 06				jr nz, .instr6 
0ed8 2b					dec hl 
0ed9 22 bb fb				ld (input_ptr),hl 
0edc 18 a2				jr .instr1 
0ede fe 05		.instr6:        cp KEY_UP      ; recall last command 
0ee0 20 0b				jr nz, .instrnew 
0ee2			 
0ee2 21 b8 ef			ld hl, scratch 
0ee5 11 de f3			ld de, os_last_cmd 
0ee8 cd 06 0f			call strcpy 
0eeb 18 93				jr .instr1 
0eed			 
0eed			 
0eed			.instrnew:	; no special key pressed to see if we have room to store it 
0eed			 
0eed					; TODO do string size test 
0eed			 
0eed 2b					dec hl ; to over write cursor 
0eee 77					ld (hl),a 
0eef 23					inc hl 
0ef0 3a 56 fa				ld a,(cursor_shape) 
0ef3 77					ld (hl),a 
0ef4 23					inc hl 
0ef5 3e 00				ld a,0 
0ef7 77					ld (hl),a 
0ef8			 
0ef8 22 bb fb				ld (input_ptr),hl 
0efb					 
0efb 18 83				jr .instr1 
0efd 2b			.instrcr:	dec hl		; remove cursor 
0efe 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f00 77					ld (hl),a 
0f01 23					inc hl 
0f02 3e 00				ld a,0 
0f04 77					ld (hl),a 
0f05			 
0f05			 
0f05					; if at end of line scroll up    
0f05					; TODO detecting only end of line 4 for scroll up  
0f05			 
0f05					;ld   
0f05			 
0f05 c9					ret 
0f06			 
0f06			 
0f06			; strcpy hl = dest, de source 
0f06			 
0f06 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f07 b7			            OR   A              ;Null terminator? 
0f08 c8			            RET  Z              ;Yes, so finished 
0f09 1a					ld a,(de) 
0f0a 77					ld (hl),a 
0f0b 13			            INC  DE             ;Point to next character 
0f0c 23					inc hl 
0f0d 18 f7		            JR   strcpy       ;Repeat 
0f0f c9					ret 
0f10			 
0f10			 
0f10			; TODO string_at  
0f10			; pass string which starts with lcd offset address and then null term string 
0f10			 
0f10			; TODO string to dec 
0f10			; TODO string to hex 
0f10			; TODO byte to string hex 
0f10			; TODO byte to string dec 
0f10			 
0f10			 
0f10			 
0f10			; from z80uartmonitor 
0f10			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f10			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0f10			; pass hl for where to put the text 
0f10			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f10 c5			hexout:	PUSH BC 
0f11 f5					PUSH AF 
0f12 47					LD B, A 
0f13					; Upper nybble 
0f13 cb 3f				SRL A 
0f15 cb 3f				SRL A 
0f17 cb 3f				SRL A 
0f19 cb 3f				SRL A 
0f1b cd 2b 0f				CALL tohex 
0f1e 77					ld (hl),a 
0f1f 23					inc hl	 
0f20					 
0f20					; Lower nybble 
0f20 78					LD A, B 
0f21 e6 0f				AND 0FH 
0f23 cd 2b 0f				CALL tohex 
0f26 77					ld (hl),a 
0f27 23					inc hl	 
0f28					 
0f28 f1					POP AF 
0f29 c1					POP BC 
0f2a c9					RET 
0f2b					 
0f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2b			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0f2b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2b			tohex: 
0f2b e5					PUSH HL 
0f2c d5					PUSH DE 
0f2d 16 00				LD D, 0 
0f2f 5f					LD E, A 
0f30 21 38 0f				LD HL, .DATA 
0f33 19					ADD HL, DE 
0f34 7e					LD A, (HL) 
0f35 d1					POP DE 
0f36 e1					POP HL 
0f37 c9					RET 
0f38			 
0f38			.DATA: 
0f38 30					DEFB	30h	; 0 
0f39 31					DEFB	31h	; 1 
0f3a 32					DEFB	32h	; 2 
0f3b 33					DEFB	33h	; 3 
0f3c 34					DEFB	34h	; 4 
0f3d 35					DEFB	35h	; 5 
0f3e 36					DEFB	36h	; 6 
0f3f 37					DEFB	37h	; 7 
0f40 38					DEFB	38h	; 8 
0f41 39					DEFB	39h	; 9 
0f42 41					DEFB	41h	; A 
0f43 42					DEFB	42h	; B 
0f44 43					DEFB	43h	; C 
0f45 44					DEFB	44h	; D 
0f46 45					DEFB	45h	; E 
0f47 46					DEFB	46h	; F 
0f48			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f48			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0f48			;;    subtract $30, if result > 9 then subtract $7 more 
0f48			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f48			atohex: 
0f48 d6 30				SUB $30 
0f4a fe 0a				CP 10 
0f4c f8					RET M		; If result negative it was 0-9 so we're done 
0f4d d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f4f c9					RET		 
0f50			 
0f50			 
0f50			 
0f50			 
0f50			; Get 2 ASCII characters as hex byte from pointer in hl 
0f50			 
0f50			BYTERD: 
0f50 16 00			LD	D,00h		;Set up 
0f52 cd 5a 0f			CALL	HEXCON		;Get byte and convert to hex 
0f55 87				ADD	A,A		;First nibble so 
0f56 87				ADD	A,A		;multiply by 16 
0f57 87				ADD	A,A		; 
0f58 87				ADD	A,A		; 
0f59 57				LD	D,A		;Save hi nibble in D 
0f5a			HEXCON: 
0f5a 7e				ld a, (hl)		;Get next chr 
0f5b 23				inc hl 
0f5c d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f5e fe 0a			CP	00Ah		;Is it 0-9 ? 
0f60 38 02			JR	C,NALPHA	;If so miss next bit 
0f62 d6 07			SUB	007h		;Else convert alpha 
0f64			NALPHA: 
0f64 b2				OR	D		;Add hi nibble back 
0f65 c9				RET			; 
0f66			 
0f66			 
0f66			; 
0f66			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f66			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f66			; characters (0-9a-f) are accepted. 
0f66			; 
0f66			;get_word        push    af 
0f66			;                call    get_byte        ; Get the upper byte 
0f66			;                ld      h, a 
0f66			;                call    get_byte        ; Get the lower byte 
0f66			;                ld      l, a 
0f66			;                pop     af 
0f66			;                ret 
0f66			; 
0f66			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f66			; the routine get_nibble is used only valid characters are accepted - the  
0f66			; input routine only accepts characters 0-9a-f. 
0f66			; 
0f66 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f67 7e					ld a,(hl) 
0f68 23					inc hl 
0f69 cd 8e 0f		                call    nibble2val      ; Get upper nibble 
0f6c cb 07		                rlc     a 
0f6e cb 07		                rlc     a 
0f70 cb 07		                rlc     a 
0f72 cb 07		                rlc     a 
0f74 47			                ld      b, a            ; Save upper four bits 
0f75 7e					ld a,(hl) 
0f76 cd 8e 0f		                call    nibble2val      ; Get lower nibble 
0f79 b0			                or      b               ; Combine both nibbles 
0f7a c1			                pop     bc              ; Restore B (and C) 
0f7b c9			                ret 
0f7c			; 
0f7c			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f7c			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f7c			; to the serial line interface. The lower 4 bits of A contain the value of  
0f7c			; that particular digit. 
0f7c			; 
0f7c			;get_nibble      ld a,(hl)           ; Read a character 
0f7c			;                call    to_upper        ; Convert to upper case 
0f7c			;                call    is_hex          ; Was it a hex digit? 
0f7c			;                jr      nc, get_nibble  ; No, get another character 
0f7c			 ;               call    nibble2val      ; Convert nibble to value 
0f7c			 ;               call    print_nibble 
0f7c			 ;               ret 
0f7c			; 
0f7c			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f7c			; A valid hexadecimal digit is denoted by a set C flag. 
0f7c			; 
0f7c			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f7c			;                ret     nc              ; Yes 
0f7c			;                cp      '0'             ; Less than '0'? 
0f7c			;                jr      nc, is_hex_1    ; No, continue 
0f7c			;                ccf                     ; Complement carry (i.e. clear it) 
0f7c			;                ret 
0f7c			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f7c			;                ret     c               ; Yes 
0f7c			;                cp      'A'             ; Less than 'A'? 
0f7c			;                jr      nc, is_hex_2    ; No, continue 
0f7c			;                ccf                     ; Yes - clear carry and return 
0f7c			;                ret 
0f7c			;is_hex_2        scf                     ; Set carry 
0f7c			;                ret 
0f7c			; 
0f7c			; Convert a single character contained in A to upper case: 
0f7c			; 
0f7c fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f7e d8			                ret     c 
0f7f fe 7b		                cp      'z' + 1         ; > 'z'? 
0f81 d0			                ret     nc              ; Nothing to do, either 
0f82 e6 5f		                and     $5f             ; Convert to upper case 
0f84 c9			                ret 
0f85			 
0f85			 
0f85			to_lower: 
0f85			 
0f85			   ; if char is in [A-Z] make it lower case 
0f85			 
0f85			   ; enter : a = char 
0f85			   ; exit  : a = lower case char 
0f85			   ; uses  : af 
0f85			 
0f85 fe 41		   cp 'A' 
0f87 d8			   ret c 
0f88			    
0f88 fe 5b		   cp 'Z'+1 
0f8a d0			   ret nc 
0f8b			    
0f8b f6 20		   or $20 
0f8d c9			   ret 
0f8e			 
0f8e			; 
0f8e			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f8e			; corresponding value in A. 
0f8e			; 
0f8e fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f90 38 02		                jr      c, nibble2val_1 ; Yes 
0f92 d6 07		                sub     7               ; Adjust for A-F 
0f94 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f96 e6 0f		                and     $f              ; Only return lower 4 bits 
0f98 c9			                ret 
0f99			; 
0f99			; Print_nibble prints a single hex nibble which is contained in the lower  
0f99			; four bits of A: 
0f99			; 
0f99			;print_nibble    push    af              ; We won't destroy the contents of A 
0f99			;                and     $f              ; Just in case... 
0f99			;                add     a, '0'             ; If we have a digit we are done here. 
0f99			;                cp      '9' + 1         ; Is the result > 9? 
0f99			;                jr      c, print_nibble_1 
0f99			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f99			;print_nibble_1  call    putc            ; Print the nibble and 
0f99			;                pop     af              ; restore the original value of A 
0f99			;                ret 
0f99			;; 
0f99			;; Send a CR/LF pair: 
0f99			; 
0f99			;crlf            push    af 
0f99			;                ld      a, cr 
0f99			;                call    putc 
0f99			;                ld      a, lf 
0f99			;                call    putc 
0f99			;                pop     af 
0f99			;                ret 
0f99			; 
0f99			; Print_word prints the four hex digits of a word to the serial line. The  
0f99			; word is expected to be in HL. 
0f99			; 
0f99			;print_word      push    hl 
0f99			;                push    af 
0f99			;                ld      a, h 
0f99			;                call    print_byte 
0f99			;                ld      a, l 
0f99			;                call    print_byte 
0f99			;                pop     af 
0f99			;                pop     hl 
0f99			;                ret 
0f99			; 
0f99			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f99			; The byte to be printed is expected to be in A. 
0f99			; 
0f99			;print_byte      push    af              ; Save the contents of the registers 
0f99			;                push    bc 
0f99			;                ld      b, a 
0f99			;                rrca 
0f99			;                rrca 
0f99			;                rrca 
0f99			;                rrca 
0f99			;                call    print_nibble    ; Print high nibble 
0f99			;                ld      a, b 
0f99			;                call    print_nibble    ; Print low nibble 
0f99			;                pop     bc              ; Restore original register contents 
0f99			;                pop     af 
0f99			;                ret 
0f99			 
0f99			 
0f99			 
0f99			 
0f99			 
0f99			fourehexhl:  
0f99 7e				ld a,(hl) 
0f9a cd 48 0f			call atohex 
0f9d cb 3f				SRL A 
0f9f cb 3f				SRL A 
0fa1 cb 3f				SRL A 
0fa3 cb 3f				SRL A 
0fa5 47				ld b, a 
0fa6 23				inc hl 
0fa7 7e				ld a,(hl) 
0fa8 23				inc hl 
0fa9 cd 48 0f			call atohex 
0fac 80				add b 
0fad 57				ld d,a 
0fae 7e				ld a,(hl) 
0faf cd 48 0f			call atohex 
0fb2 cb 3f				SRL A 
0fb4 cb 3f				SRL A 
0fb6 cb 3f				SRL A 
0fb8 cb 3f				SRL A 
0fba 47				ld b, a 
0fbb 23				inc hl 
0fbc 7e				ld a,(hl) 
0fbd 23				inc hl 
0fbe cd 48 0f			call atohex 
0fc1 80				add b 
0fc2 5f				ld e, a 
0fc3 d5				push de 
0fc4 e1				pop hl 
0fc5 c9				ret 
0fc6			 
0fc6			; pass hl. returns z set if the byte at hl is a digit 
0fc6			;isdigithl:  
0fc6			;	push bc 
0fc6			;	ld a,(hl) 
0fc6			;	cp ':' 
0fc6			;	jr nc, .isdf 		; > 
0fc6			;	cp '0' 
0fc6			;	jr c, .isdf		; < 
0fc6			; 
0fc6			;	; TODO find a better way to set z 
0fc6			; 
0fc6			;	ld b,a 
0fc6			;	cp b 
0fc6			;	pop bc 
0fc6			;	ret 
0fc6			; 
0fc6			;.isdf:	; not digit so clear z 
0fc6			; 
0fc6			;	; TODO find a better way to unset z 
0fc6			; 
0fc6			;	ld b,a 
0fc6			;	inc b 
0fc6			;	cp b 
0fc6			; 
0fc6			;	pop bc 
0fc6			;	ret 
0fc6				 
0fc6				 
0fc6			 
0fc6			 
0fc6			; pass hl as the four byte address to load 
0fc6			 
0fc6			get_word_hl:  
0fc6 e5				push hl 
0fc7 cd 66 0f			call get_byte 
0fca				 
0fca 47				ld b, a 
0fcb			 
0fcb e1				pop hl 
0fcc 23				inc hl 
0fcd 23				inc hl 
0fce			 
0fce			; TODO not able to handle a-f  
0fce 7e				ld a,(hl) 
0fcf			;	;cp ':' 
0fcf			;	cp 'g' 
0fcf			;	jr nc, .single_byte_hl 		; > 
0fcf			;	cp 'G' 
0fcf			;	jr nc, .single_byte_hl 		; > 
0fcf			;	cp '0' 
0fcf			;	jr c, .single_byte_hl		; < 
0fcf			 
0fcf				;call isdigithl 
0fcf fe 00			cp 0 
0fd1 28 06			jr z, .single_byte_hl 
0fd3			 
0fd3			.getwhln:   ; hex word so get next byte 
0fd3			 
0fd3 cd 66 0f			call get_byte 
0fd6 6f				ld l, a 
0fd7 60				ld h,b 
0fd8 c9				ret 
0fd9 68			.single_byte_hl:   ld l,b 
0fda 26 00				ld h,0 
0fdc c9					ret 
0fdd			 
0fdd			 
0fdd			 
0fdd			 
0fdd 21 77 16			ld hl,asc+1 
0fe0			;	ld a, (hl) 
0fe0			;	call nibble2val 
0fe0 cd 66 0f			call get_byte 
0fe3			 
0fe3			;	call fourehexhl 
0fe3 32 ec ef			ld (scratch+52),a 
0fe6				 
0fe6 21 ea ef			ld hl,scratch+50 
0fe9 22 db f2			ld (os_cur_ptr),hl 
0fec			 
0fec c9				ret 
0fed			 
0fed			 
0fed			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0fed			 
0fed			; Decimal Unsigned Version 
0fed			 
0fed			;Number in a to decimal ASCII 
0fed			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0fed			;Example: display a=56 as "056" 
0fed			;input: a = number 
0fed			;Output: a=0,value of a in the screen 
0fed			;destroys af,bc (don't know about hl and de) 
0fed			DispAToASCII: 
0fed 0e 9c			ld	c,-100 
0fef cd f9 0f			call	.Na1 
0ff2 0e f6			ld	c,-10 
0ff4 cd f9 0f			call	.Na1 
0ff7 0e ff			ld	c,-1 
0ff9 06 2f		.Na1:	ld	b,'0'-1 
0ffb 04			.Na2:	inc	b 
0ffc 81				add	a,c 
0ffd 38 fc			jr	c,.Na2 
0fff 91				sub	c		;works as add 100/10/1 
1000 f5				push af		;safer than ld c,a 
1001 78				ld	a,b		;char is in b 
1002			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1002 f1				pop af		;safer than ld a,c 
1003 c9				ret 
1004			 
1004			; Decimal Signed Version 
1004			 
1004			; DispA 
1004			; -------------------------------------------------------------- 
1004			; Converts a signed integer value to a zero-terminated ASCII 
1004			; string representative of that value (using radix 10). 
1004			; -------------------------------------------------------------- 
1004			; INPUTS: 
1004			;     HL     Value to convert (two's complement integer). 
1004			;     DE     Base address of string destination. (pointer). 
1004			; -------------------------------------------------------------- 
1004			; OUTPUTS: 
1004			;     None 
1004			; -------------------------------------------------------------- 
1004			; REGISTERS/MEMORY DESTROYED 
1004			; AF HL 
1004			; -------------------------------------------------------------- 
1004			 
1004			;DispHLToASCII: 
1004			;   push    de 
1004			;   push    bc 
1004			; 
1004			;; Detect sign of HL. 
1004			;    bit    7, h 
1004			;    jr     z, ._DoConvert 
1004			; 
1004			;; HL is negative. Output '-' to string and negate HL. 
1004			;    ld     a, '-' 
1004			;    ld     (de), a 
1004			;    inc    de 
1004			; 
1004			;; Negate HL (using two's complement) 
1004			;    xor    a 
1004			;    sub    l 
1004			;    ld     l, a 
1004			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1004			;    sbc    a, h 
1004			;    ld     h, a 
1004			; 
1004			;; Convert HL to digit characters 
1004			;._DoConvert: 
1004			;    ld     b, 0     ; B will count character length of number 
1004			;-   ld     a, 10 
1004			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1004			;    push   af 
1004			;    inc    b 
1004			;    ld     a, h 
1004			;    or     l 
1004			;    jr     nz, - 
1004			; 
1004			;; Retrieve digits from stack 
1004			;-   pop    af 
1004			;    or     $30 
1004			;    ld     (de), a 
1004			;    inc    de 
1004			;    djnz   - 
1004			; 
1004			;; Terminate string with NULL 
1004			;    xor    a 
1004			;    ld     (de), a 
1004			; 
1004			;    pop    bc 
1004			;    pop    de 
1004			;    ret 
1004			 
1004			;Comments 
1004			; 
1004			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1004			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1004			;    Note that the output string will not be fixed-width. 
1004			; 
1004			;Example Usage 
1004			; 
1004			;    ld    hl, -1004 
1004			;    ld    de, OP1 
1004			;    call  DispA 
1004			;    ld    hl, OP1 
1004			;    syscall  PutS 
1004			 
1004			 
1004			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1004			 
1004			 
1004			;Converts an ASCII string to an unsigned 16-bit integer 
1004			;Quits when it reaches a non-decimal digit 
1004			 
1004			string_to_uint16: 
1004			atoui_16: 
1004			;Input: 
1004			;     DE points to the string 
1004			;Outputs: 
1004			;     HL is the result 
1004			;     A is the 8-bit value of the number 
1004			;     DE points to the byte after the number 
1004			;Destroys: 
1004			;     BC 
1004			;       if the string is non-empty, BC is HL/10 
1004			;Size:  24 bytes 
1004			;Speed: 42+d(104+{0,9}) 
1004			;       d is the number of digits in the number 
1004			;       max is 640 cycles for a 5 digit number 
1004			;Assuming no leading zeros: 
1004			;1 digit:  146cc 
1004			;2 digit:  250cc 
1004			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1004			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1004			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1004			;avg: 544.81158447265625cc (544+13297/16384) 
1004			;=============================================================== 
1004 21 00 00		  ld hl,0 
1007			.u16a: 
1007 1a			  ld a,(de) 
1008 d6 30		  sub 30h 
100a fe 0a		  cp 10 
100c d0			  ret nc 
100d 13			  inc de 
100e 44			  ld b,h 
100f 4d			  ld c,l 
1010 29			  add hl,hl 
1011 29			  add hl,hl 
1012 09			  add hl,bc 
1013 29			  add hl,hl 
1014 85			  add a,l 
1015 6f			  ld l,a 
1016 30 ef		  jr nc,.u16a 
1018 24			  inc h 
1019 c3 07 10		  jp .u16a 
101c			 
101c			 
101c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
101c			 
101c			;written by Zeda 
101c			;Converts a 16-bit unsigned integer to an ASCII string. 
101c			 
101c			uitoa_16: 
101c			;Input: 
101c			;   DE is the number to convert 
101c			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
101c			;Output: 
101c			;   HL points to the null-terminated ASCII string 
101c			;      NOTE: This isn't necessarily the same as the input HL. 
101c d5			  push de 
101d c5			  push bc 
101e f5			  push af 
101f eb			  ex de,hl 
1020			 
1020 01 f0 d8		  ld bc,-10000 
1023 3e 2f		  ld a,'0'-1 
1025 3c			  inc a 
1026 09			  add hl,bc  
1027 38 fc		   jr c,$-2 
1029 12			  ld (de),a 
102a 13			  inc de 
102b			 
102b 01 e8 03		  ld bc,1000 
102e 3e 3a		  ld a,'9'+1 
1030 3d			  dec a  
1031 09			  add hl,bc  
1032 30 fc		   jr nc,$-2 
1034 12			  ld (de),a 
1035 13			  inc de 
1036			 
1036 01 9c ff		  ld bc,-100 
1039 3e 2f		  ld a,'0'-1 
103b 3c			  inc a  
103c 09			  add hl,bc  
103d 38 fc		   jr c,$-2 
103f 12			  ld (de),a 
1040 13			  inc de 
1041			 
1041 7d			  ld a,l 
1042 26 3a		  ld h,'9'+1 
1044 25			  dec h  
1045 c6 0a		  add a,10  
1047 30 fb		   jr nc,$-3 
1049 c6 30		  add a,'0' 
104b eb			  ex de,hl 
104c 72			  ld (hl),d 
104d 23			  inc hl 
104e 77			  ld (hl),a 
104f 23			  inc hl 
1050 36 00		  ld (hl),0 
1052			 
1052			;Now strip the leading zeros 
1052 0e fa		  ld c,-6 
1054 09			  add hl,bc 
1055 3e 30		  ld a,'0' 
1057 23			  inc hl  
1058 be			  cp (hl)  
1059 28 fc		  jr z,$-2 
105b			 
105b			;Make sure that the string is non-empty! 
105b 7e			  ld a,(hl) 
105c b7			  or a 
105d 20 01		  jr nz,.atoub 
105f 2b			  dec hl 
1060			.atoub: 
1060			 
1060 f1			  pop af 
1061 c1			  pop bc 
1062 d1			  pop de 
1063 c9			  ret 
1064			 
1064			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1064			 
1064			toUpper: 
1064			;A is the char. 
1064			;If A is a lowercase letter, this sets it to the matching uppercase 
1064			;18cc or 30cc or 41cc 
1064			;avg: 26.75cc 
1064 fe 61		  cp 'a' 
1066 d8			  ret c 
1067 fe 7b		  cp 'z'+1 
1069 d0			  ret nc 
106a d6 20		  sub 'a'-'A' 
106c c9			  ret 
106d			 
106d			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
106d			 
106d			; String Length 
106d			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
106d			 
106d			; Get the length of the null-terminated string starting at $8000 hl 
106d			;    LD     HL, $8000 
106d			 
106d			strlenz: 
106d			 
106d af			    XOR    A               ; Zero is the value we are looking for. 
106e 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
106f 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1070			                           ; 65, 536 bytes (the entire addressable memory space). 
1070 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1072			 
1072			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1072 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1073 6f			    LD     L, A             ; number of bytes 
1074 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1076 2b			    DEC    HL              ; Compensate for null. 
1077 c9				ret 
1078			 
1078			; Get the length of the A terminated string starting at $8000 hl 
1078			;    LD     HL, $8000 
1078			 
1078			strlent: 
1078			 
1078			                  ; A is the value we are looking for. 
1078 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
107a 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
107c			                           ; 65, 536 bytes (the entire addressable memory space). 
107c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
107e			 
107e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
107e 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1080 2e 00		    LD     L, 0             ; number of bytes 
1082 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1084 2b			    DEC    HL              ; Compensate for null. 
1085 c9				ret 
1086			 
1086			 
1086			;Comparing Strings 
1086			 
1086			;IN    HL     Address of string1. 
1086			;      DE     Address of string2. 
1086			 
1086			; doc given but wrong??? 
1086			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1086			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1086			; tested 
1086			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1086			 
1086			strcmp_old: 
1086 e5			    PUSH   HL 
1087 d5			    PUSH   DE 
1088			 
1088 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1089 be			    CP     (HL)            ; (want to minimize work). 
108a 38 01		    JR     C, Str1IsBigger 
108c 7e			    LD     A, (HL) 
108d			 
108d			Str1IsBigger: 
108d 4f			    LD     C, A             ; Put length in BC 
108e 06 00		    LD     B, 0 
1090 13			    INC    DE              ; Increment pointers to meat of string. 
1091 23			    INC    HL 
1092			 
1092			CmpLoop: 
1092 1a			    LD     A, (DE)          ; Compare bytes. 
1093 ed a1		    CPI 
1095 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1097 13			    INC    DE              ; Update pointer. 
1098 ea 92 10		    JP     PE, CmpLoop 
109b			 
109b d1			    POP    DE 
109c e1			    POP    HL 
109d 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
109e be			    CP     (HL) 
109f c9			    RET 
10a0			 
10a0			NoMatch: 
10a0 2b			    DEC    HL 
10a1 be			    CP     (HL)            ; Compare again to affect carry. 
10a2 d1			    POP    DE 
10a3 e1			    POP    HL 
10a4 c9			    RET 
10a5			 
10a5			;; test strmp 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str2 
10a5			;call strcmp 
10a5			;jr z, .z1 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "NZ1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.z1: 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "ZZ1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str1 
10a5			;call strcmp 
10a5			;jr z, .z2 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "NZ2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.z2: 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "ZZ2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str2 
10a5			;call strcmp 
10a5			;jr c, .c1 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "Nc1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.c1: 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "cc1" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			; 
10a5			;ld de, .str1 
10a5			;ld hl, .str1 
10a5			;call strcmp 
10a5			;jr c, .c2 
10a5			;;this 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "Nc2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;.c2: 
10a5			; 
10a5			;	if DEBUG_FORTH_WORDS 
10a5			;		DMARK "cc2" 
10a5			;		CALLMONITOR 
10a5			;	endif 
10a5			;	NEXTW 
10a5			;.str1:   db "string1",0 
10a5			;.str2:   db "string2",0 
10a5			 
10a5			; only care about direct match or not 
10a5			; hl and de strings 
10a5			; zero set if the same 
10a5			 
10a5			strcmp: 
10a5 1a				ld a, (de) 
10a6 be				cp (hl) 
10a7 28 02			jr z, .ssame 
10a9 b7				or a 
10aa c9				ret 
10ab			 
10ab			.ssame:  
10ab fe 00			cp 0 
10ad c8				ret z 
10ae			 
10ae 23				inc hl 
10af 13				inc de 
10b0 18 f3			jr strcmp 
10b2				 
10b2				 
10b2			 
10b2			 
10b2			 
10b2			 
10b2			; eof 
10b2			 
10b2			 
10b2			 
10b2			 
10b2			 
10b2			 
# End of file firmware_strings.asm
10b2			include "firmware_memory.asm"   ; malloc and free  
10b2			 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2			.mallocsize: db "Wants malloc >256",0 
10b2			.mallocasize: db "MALLOC gives >256",0 
10b2			.malloczero: db "MALLOC gives zero",0 
10b2			 
10b2			malloc_guard_zerolen: 
10b2				push hl 
10b2				push de 
10b2				push af 
10b2			 
10b2				ld de, 0 
10b2			        call cmp16 
10b2				jr nz, .lowalloz 
10b2			 
10b2				push hl 
10b2				push de 
10b2					ld hl, display_fb0 
10b2					ld (display_fb_active), hl 
10b2				call clear_display 
10b2				ld a, 0 
10b2				ld de, .malloczero 
10b2				call str_at_display 
10b2				call update_display 
10b2				call delay1s 
10b2				call delay1s 
10b2				ld a, 0 
10b2				ld (os_view_disable), a 
10b2			 
10b2				pop de 
10b2				pop hl 
10b2			 
10b2				 
10b2			 
10b2				CALLMONITOR 
10b2			.lowalloz: 
10b2			 
10b2			 
10b2				pop af 
10b2				pop de 
10b2				pop hl 
10b2			ret 
10b2			 
10b2			malloc_guard_entry: 
10b2				push hl 
10b2				push de 
10b2				push af 
10b2			 
10b2			 	or a      ;clear carry flag 
10b2				push hl 
10b2				ld de, 255 
10b2				sbc hl, de 
10b2				jr c, .lowalloc 
10b2			 
10b2				push de 
10b2					ld hl, display_fb0 
10b2					ld (display_fb_active), hl 
10b2				call clear_display 
10b2				ld a, 0 
10b2				ld de, .mallocsize 
10b2				call str_at_display 
10b2				call update_display 
10b2				call delay1s 
10b2				call delay1s 
10b2				ld a, 0 
10b2				ld (os_view_disable), a 
10b2			 
10b2				pop de 
10b2				pop hl 
10b2			 
10b2				 
10b2			 
10b2				CALLMONITOR 
10b2				jr .lowdone 
10b2			.lowalloc: 
10b2			 
10b2			 
10b2				pop hl 
10b2			.lowdone:	pop af 
10b2				pop de 
10b2				pop hl 
10b2			ret 
10b2			 
10b2			malloc_guard_exit: 
10b2				push hl 
10b2				push de 
10b2				push af 
10b2			 
10b2			 	or a      ;clear carry flag 
10b2				push hl 
10b2				ld de, 255 
10b2				sbc hl, de 
10b2				jr c, .lowallocx 
10b2			 
10b2				push de 
10b2					ld hl, display_fb0 
10b2					ld (display_fb_active), hl 
10b2				call clear_display 
10b2				ld a, 0 
10b2				ld de, .mallocasize 
10b2				call str_at_display 
10b2				call update_display 
10b2				call delay1s 
10b2				call delay1s 
10b2				ld a, 0 
10b2				ld (os_view_disable), a 
10b2				pop de 
10b2				pop hl 
10b2			 
10b2				CALLMONITOR 
10b2				jr .lowdonex 
10b2			.lowallocx: 
10b2			 
10b2				pop hl 
10b2			.lowdonex:	pop af 
10b2				pop de 
10b2				pop hl 
10b2			ret 
10b2			endif 
10b2			 
10b2			if MALLOC_2 
10b2			; Z80 Malloc and Free Functions 
10b2			 
10b2			; Malloc Function: 
10b2			; Input: 
10b2			;   HL: Size of block to allocate 
10b2			; Output: 
10b2			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b2			 
10b2			malloc: 
10b2				 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2			call malloc_guard_entry 
10b2			endif 
10b2			 
10b2			 
10b2			 
10b2			 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "mal" 
10b2						CALLMONITOR 
10b2					endif 
10b2			    push af            ; Save AF register 
10b2			    ld a, l            ; Load low byte of size into A 
10b2			    or h               ; Check if size is zero 
10b2			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
10b2			 
10b2			    ; Allocate memory 
10b2			    ld hl, (heap_start) ; Load start of heap into HL 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "ma1" 
10b2						CALLMONITOR 
10b2					endif 
10b2			    call malloc_internal ; Call internal malloc function 
10b2			    pop af             ; Restore AF register 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret                ; Return 
10b2			 
10b2			; Free Function: 
10b2			; Input: 
10b2			;   HL: Pointer to memory block to free 
10b2			; Output: 
10b2			;   None 
10b2			 
10b2			free: 
10b2			    push af            ; Save AF register 
10b2			    ld a, l            ; Load low byte of pointer into A 
10b2			    or h               ; Check if pointer is NULL 
10b2			    jp z, free_exit    ; If pointer is NULL, exit 
10b2			 
10b2			    ; Free memory 
10b2			    ld hl, (heap_start) ; Load start of heap into HL 
10b2			    call free_internal  ; Call internal free function 
10b2			    pop af             ; Restore AF register 
10b2			    ret                ; Return 
10b2			 
10b2			; Internal Malloc Function: 
10b2			; Input: 
10b2			;   HL: Size of block to allocate 
10b2			; Output: 
10b2			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b2			 
10b2			malloc_internal: 
10b2			    ld bc, 2           ; Number of bytes to allocate for management overhead 
10b2			    add hl, bc         ; Add management overhead to requested size 
10b2			    ex de, hl          ; Save total size in DE, and keep it in HL 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "ma2" 
10b2						CALLMONITOR 
10b2					endif 
10b2			 
10b2			    ; Search for free memory block 
10b2			    ld de, (heap_end)  ; Load end of heap into DE 
10b2			    ld bc, 0           ; Initialize counter 
10b2			 
10b2					if DEBUG_FORTH_MALLOC 
10b2						DMARK "ma2" 
10b2						CALLMONITOR 
10b2					endif 
10b2			malloc_search_loop: 
10b2			    ; Check if current block is free 
10b2			    ld a, (hl)         ; Load current block's status (free or used) 
10b2			    cp 0               ; Compare with zero (free) 
10b2			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
10b2			 
10b2			    ; Check if current block is large enough 
10b2			    ld a, (hl+1)       ; Load high byte of block size 
10b2			    cp l               ; Compare with low byte of requested size 
10b2			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
10b2			 
10b2			    ld a, (hl+2)       ; Load low byte of block size 
10b2			    cp h               ; Compare with high byte of requested size 
10b2			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
10b2			 
10b2			    ; Mark block as used 
10b2			    ld (hl), 0xFF      ; Set status byte to indicate used block 
10b2			 
10b2			    ; Calculate remaining space in block 
10b2			    ld bc, 0           ; Clear BC 
10b2			    add hl, bc         ; Increment HL to point to start of data block 
10b2			    add hl, de         ; HL = HL + DE (total size) 
10b2			    ld bc, 1           ; Number of bytes to allocate for management overhead 
10b2			    add hl, bc         ; Add management overhead to start of data block 
10b2			 
10b2			    ; Save pointer to allocated block in HL 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2						DMARK "ma5" 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret 
10b2			 
10b2			malloc_skip_block_check: 
10b2			    ; Move to the next block 
10b2			    ld bc, 3           ; Size of management overhead 
10b2			    add hl, bc         ; Move to the next block 
10b2			    inc de             ; Increment counter 
10b2			 
10b2			    ; Check if we have reached the end of heap 
10b2			    ld a, e            ; Load low byte of heap end address 
10b2			    cp (hl)            ; Compare with low byte of current address 
10b2			    jr nz, malloc_search_loop  ; If not equal, continue searching 
10b2			    ld a, d            ; Load high byte of heap end address 
10b2			    cp 0               ; Check if it's zero (end of memory) 
10b2			    jr nz, malloc_search_loop  ; If not zero, continue searching 
10b2			 
10b2			    ; If we reached here, allocation failed 
10b2			    xor a              ; Set result to NULL 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2						DMARK "ma6" 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret 
10b2			malloc_exit: 
10b2			if DEBUG_FORTH_MALLOC_HIGH 
10b2						DMARK "ma7" 
10b2			call malloc_guard_exit 
10b2			call malloc_guard_zerolen 
10b2			endif 
10b2			    ret 
10b2			 
10b2			; Internal Free Function: 
10b2			; Input: 
10b2			;   HL: Pointer to memory block to free 
10b2			; Output: 
10b2			;   None 
10b2			 
10b2			free_internal: 
10b2			    ld de, (heap_start) ; Load start of heap into DE 
10b2			    ld bc, 0            ; Initialize counter 
10b2			 
10b2			free_search_loop: 
10b2			    ; Check if current block contains the pointer 
10b2			    ld a, l             ; Load low byte of pointer 
10b2			    cp (hl+1)           ; Compare with high byte of current block's address 
10b2			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b2			    ld a, h             ; Load high byte of pointer 
10b2			    cp (hl+2)           ; Compare with low byte of current block's address 
10b2			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b2			 
10b2			    ; Mark block as free 
10b2			    ld (hl), 0          ; Set status byte to indicate free block 
10b2			    ret                 ; Return 
10b2			 
10b2			free_skip_block_check: 
10b2			    ; Move to the next block 
10b2			    ld bc, 3            ; Size of management overhead 
10b2			    add hl, bc          ; Move to the next block 
10b2			    inc de              ; Increment counter 
10b2			 
10b2			    ; Check if we have reached the end of heap 
10b2			    ld a, e             ; Load low byte of heap end address 
10b2			    cp (hl)             ; Compare with low byte of current address 
10b2			    jr nz, free_search_loop  ; If not equal, continue searching 
10b2			    ld a, d             ; Load high byte of heap end address 
10b2			    cp 0                ; Check if it's zero (end of memory) 
10b2			    jr nz, free_search_loop  ; If not zero, continue searching 
10b2			 
10b2			    ; If we reached here, pointer is not found in heap 
10b2			    ret 
10b2			 
10b2			free_exit: 
10b2			    ret                 ; Return 
10b2			 
10b2			; Define heap start and end addresses 
10b2			;heap_start:    .dw 0xC000   ; Start of heap 
10b2			;heap_end:      .dw 0xE000   ; End of heap 
10b2			 
10b2			endif 
10b2			 
10b2			 
10b2			if MALLOC_1 
10b2			 
10b2			 
10b2			 
10b2			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
10b2			 
10b2			;moved to firmware.asm 
10b2			;heap_start        .equ  0x9000      ; Starting address of heap 
10b2			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
10b2			 
10b2			;      .org 0 
10b2			;      jp    main 
10b2			 
10b2			 
10b2			;      .org  0x100 
10b2			;main: 
10b2			;      ld    HL, 0x8100 
10b2			;      ld    SP, HL 
10b2			; 
10b2			;      call  heap_init 
10b2			; 
10b2			;      ; Make some allocations 
10b2			;      ld    HL, 12 
10b2			;      call  malloc            ; Allocates 0x9004 
10b2			; 
10b2			;      ld    HL, 12 
10b2			;      call  malloc            ; Allocates 0x9014 
10b2			; 
10b2			;      ld    HL, 12 
10b2			;      call  malloc            ; Allocates 0x9024 
10b2			; 
10b2			;      ; Free some allocations 
10b2			;      ld    HL, 0x9014 
10b2			;      call  free 
10b2			; 
10b2			;      ld    HL, 0x9004 
10b2			;      call  free 
10b2			; 
10b2			;      ld    HL, 0x9024 
10b2			;      call  free 
10b2			; 
10b2			; 
10b2			;      halt 
10b2			 
10b2			 
10b2			;------------------------------------------------------------------------------ 
10b2			;     heap_init                                                               : 
10b2			;                                                                             : 
10b2			; Description                                                                 : 
10b2			;     Initialise the heap and make it ready for malloc and free operations.   : 
10b2			;                                                                             : 
10b2			;     The heap is maintained as a linked list, starting with an initial       : 
10b2			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
10b2			;     the first free block in the heap. Each block then points to the next    : 
10b2			;     free block within the heap, and the free list ends at the first block   : 
10b2			;     with a null pointer to the next free block.                             : 
10b2			;                                                                             : 
10b2			; Parameters                                                                  : 
10b2			;     Inputs are compile-time only. Two defines which specify the starting    : 
10b2			;     address of the heap and its size are required, along with a memory      : 
10b2			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
10b2			;     principally stores a pointer to the first free block in the heap.       : 
10b2			;                                                                             : 
10b2			; Returns                                                                     : 
10b2			;     Nothing                                                                 : 
10b2			;------------------------------------------------------------------------------ 
10b2			heap_init: 
10b2 e5			      push  HL 
10b3			 
10b3			      ; Initialise free list struct 
10b3 21 0e 80		      ld    HL, heap_start 
10b6 22 0a 80		      ld    (free_list), HL 
10b9 21 00 00		      ld    HL, 0 
10bc 22 0c 80		      ld    (free_list+2), HL 
10bf			 
10bf			      ; Insert first free block at bottom of heap, consumes entire heap 
10bf 21 0a 80		      ld    HL, heap_start+heap_size-4 
10c2 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
10c5 21 fc ff		      ld    HL, heap_size-4 
10c8 22 10 80		      ld    (heap_start+2), HL      ; Block size 
10cb			 
10cb			      ; Insert end of free list block at top of heap - two null words will 
10cb			      ; terminate the free list 
10cb 21 00 00		      ld    HL, 0 
10ce 22 0c 80		      ld    (heap_start+heap_size-2), HL 
10d1 22 0a 80		      ld    (heap_start+heap_size-4), HL 
10d4			 
10d4 e1			      pop   HL 
10d5			 
10d5 c9			      ret 
10d6			 
10d6			 
10d6			;------------------------------------------------------------------------------ 
10d6			;     malloc                                                                  : 
10d6			;                                                                             : 
10d6			; Description                                                                 : 
10d6			;     Allocates the wanted space from the heap and returns the address of the : 
10d6			;     first useable byte of the allocation.                                   : 
10d6			;                                                                             : 
10d6			;     Allocations can happen in one of two ways:                              : 
10d6			;                                                                             : 
10d6			;     1. A free block may be found which is the exact size wanted. In this    : 
10d6			;        case the block is removed from the free list and retuedn to the      : 
10d6			;        caller.                                                              : 
10d6			;     2. A free block may be found which is larger than the size wanted. In   : 
10d6			;        this case, the larger block is split into two. The first portion of  : 
10d6			;        this block will become the requested space by the malloc call and    : 
10d6			;        is returned to the caller. The second portion becomes a new free     : 
10d6			;        block, and the free list is adjusted to maintain continuity via this : 
10d6			;        newly created block.                                                 : 
10d6			;                                                                             : 
10d6			;     malloc does not set any initial value in the allocated space, the       : 
10d6			;     caller is required to do this as required.                              : 
10d6			;                                                                             : 
10d6			;     This implementation of malloc uses the stack exclusively, and is        : 
10d6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10d6			;     advisable to disable interrupts before calling malloc, and recommended  : 
10d6			;     to avoid the use of malloc inside ISRs in general.                      : 
10d6			;                                                                             : 
10d6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10d6			;                                                                             : 
10d6			; Parameters                                                                  : 
10d6			;     HL  Number of bytes wanted                                              : 
10d6			;                                                                             : 
10d6			; Returns                                                                     : 
10d6			;     HL  Address of the first useable byte of the allocation                 : 
10d6			;                                                                             : 
10d6			; Flags                                                                       : 
10d6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
10d6			;                                                                             : 
10d6			; Stack frame                                                                 : 
10d6			;       |             |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |     BC      |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |     DE      |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |     IX      |                                                       : 
10d6			;       +-------------+                                                       : 
10d6			;       |  prev_free  |                                                       : 
10d6			;   +4  +-------------+                                                       : 
10d6			;       |  this_free  |                                                       : 
10d6			;   +2  +-------------+                                                       : 
10d6			;       |  next_free  |                                                       : 
10d6			;   +0  +-------------+                                                       : 
10d6			;       |             |                                                       : 
10d6			;                                                                             : 
10d6			;------------------------------------------------------------------------------ 
10d6			 
10d6			 
10d6			;malloc: 
10d6			; 
10d6			;	SAVESP ON 1 
10d6			; 
10d6			;	call malloc_code 
10d6			; 
10d6			;	CHECKSP ON 1 
10d6			;	ret 
10d6			 
10d6			 
10d6			malloc: 
10d6 c5			      push  BC 
10d7 d5			      push  DE 
10d8 dd e5		      push  IX 
10da			if DEBUG_FORTH_MALLOC_HIGH 
10da			call malloc_guard_entry 
10da			endif 
10da			 
10da					if DEBUG_FORTH_MALLOC 
10da						DMARK "mal" 
10da						CALLMONITOR 
10da					endif 
10da 7c			      ld    A, H                    ; Exit if no space requested 
10db b5			      or    L 
10dc ca 9b 11		      jp    Z, malloc_early_exit 
10df			 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			; 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			;inc hl 
10df			 
10df			 
10df			 
10df			 
10df					if DEBUG_FORTH_MALLOC 
10df						DMARK "maA" 
10df						CALLMONITOR 
10df					endif 
10df			      ; Set up stack frame 
10df eb			      ex    DE, HL 
10e0 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
10e3 39			      add   HL, SP 
10e4 f9			      ld    SP, HL 
10e5 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10e9 dd 39		      add   IX, SP 
10eb			 
10eb			      ; Setup initial state 
10eb 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10ee 19			      add   HL, DE 
10ef			 
10ef 44			      ld    B, H                    ; Move want to BC 
10f0 4d			      ld    C, L 
10f1			 
10f1 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
10f4 dd 75 04		      ld    (IX+4), L 
10f7 dd 74 05		      ld    (IX+5), H 
10fa			 
10fa 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10fb 23			      inc   HL 
10fc 56			      ld    D, (HL) 
10fd dd 73 02		      ld    (IX+2), E 
1100 dd 72 03		      ld    (IX+3), D 
1103 eb			      ex    DE, HL                  ; this_free ptr into HL 
1104			 
1104					if DEBUG_FORTH_MALLOC 
1104						DMARK "maB" 
1104						CALLMONITOR 
1104					endif 
1104			      ; Loop through free block list to find some space 
1104			malloc_find_space: 
1104 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1105 23			      inc   HL 
1106 56			      ld    D, (HL) 
1107			 
1107 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1108 b3			      or    E 
1109 ca 95 11		      jp    Z, malloc_no_space 
110c			 
110c dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
110f dd 72 01		      ld    (IX+1), D 
1112			 
1112			      ; Does this block have enough space to make the allocation? 
1112 23			      inc   HL                      ; Load free block size into DE 
1113 5e			      ld    E, (HL) 
1114 23			      inc   HL 
1115 56			      ld    D, (HL) 
1116			 
1116 eb			      ex    DE, HL                  ; Check size of block against want 
1117 b7			      or    A                       ; Ensure carry flag clear 
1118 ed 42		      sbc   HL, BC 
111a e5			      push  HL                      ; Store the result for later (new block size) 
111b			 
111b ca 6a 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
111e 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1120			 
1120			      ; this_free block is not big enough, setup ptrs to test next free block 
1120 e1			      pop   HL                      ; Discard previous result 
1121			 
1121 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1124 dd 66 03		      ld    H, (IX+3) 
1127 dd 75 04		      ld    (IX+4), L 
112a dd 74 05		      ld    (IX+5), H 
112d			 
112d dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1130 dd 66 01		      ld    H, (IX+1) 
1133 dd 75 02		      ld    (IX+2), L 
1136 dd 74 03		      ld    (IX+3), H 
1139			 
1139					if DEBUG_FORTH_MALLOC 
1139						DMARK "MA>" 
1139						CALLMONITOR 
1139					endif 
1139 18 c9		      jr    malloc_find_space 
113b			 
113b			      ; split a bigger block into two - requested size and remaining size 
113b			malloc_alloc_split: 
113b					if DEBUG_FORTH_MALLOC 
113b						DMARK "MAs" 
113b						CALLMONITOR 
113b					endif 
113b eb			      ex    DE, HL                  ; Calculate address of new free block 
113c 2b			      dec   HL 
113d 2b			      dec   HL 
113e 2b			      dec   HL 
113f 09			      add   HL, BC 
1140			 
1140			      ; Create a new block and point it at next_free 
1140 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1143 dd 56 01		      ld    D, (IX+1) 
1146			 
1146 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1147 23			      inc   HL 
1148 72			      ld    (HL), D 
1149			 
1149 d1			      pop   DE                      ; Store size of new block into new block 
114a 23			      inc   HL 
114b 73			      ld    (HL), E 
114c 23			      inc   HL 
114d 72			      ld    (HL), D 
114e			 
114e			      ; Update this_free ptr to point to new block 
114e 2b			      dec   HL 
114f 2b			      dec   HL 
1150 2b			      dec   HL 
1151			 
1151 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1154 dd 56 03		      ld    D, (IX+3) 
1157			 
1157 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
115a dd 74 03		      ld    (IX+3), H 
115d			 
115d			      ; Modify this_free block to be allocation 
115d eb			      ex    DE, HL 
115e af			      xor   A                       ; Null the next block ptr of allocated block 
115f 77			      ld    (HL), A 
1160 23			      inc   HL 
1161 77			      ld    (HL), A 
1162			 
1162 23			      inc   HL                      ; Store want size into allocated block 
1163 71			      ld    (HL), C 
1164 23			      inc   HL 
1165 70			      ld    (HL), B 
1166 23			      inc   HL 
1167 e5			      push  HL                      ; Address of allocation to return 
1168			 
1168 18 19		      jr    malloc_update_links 
116a			 
116a			malloc_alloc_fit: 
116a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
116b			 
116b					if DEBUG_FORTH_MALLOC 
116b						DMARK "MAf" 
116b						CALLMONITOR 
116b					endif 
116b			      ; Modify this_free block to be allocation 
116b eb			      ex    DE, HL 
116c 2b			      dec   HL 
116d 2b			      dec   HL 
116e 2b			      dec   HL 
116f			 
116f af			      xor   A                       ; Null the next block ptr of allocated block 
1170 77			      ld    (HL), A 
1171 23			      inc   HL 
1172 77			      ld    (HL), A 
1173			 
1173 23			      inc   HL                      ; Store address of allocation to return 
1174 23			      inc   HL 
1175 23			      inc   HL 
1176 e5			      push  HL 
1177			 
1177			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1177 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
117a dd 66 01		      ld    H, (IX+1) 
117d			 
117d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1180 dd 74 03		      ld    (IX+3), H 
1183			 
1183			 
1183			malloc_update_links: 
1183			      ; Update prev_free ptr to point to this_free 
1183 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1186 dd 66 05		      ld    H, (IX+5) 
1189			 
1189 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
118c dd 56 03		      ld    D, (IX+3) 
118f			 
118f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1190 23			      inc   HL 
1191 72			      ld    (HL), D 
1192			 
1192					if DEBUG_FORTH_MALLOC 
1192						DMARK "Mul" 
1192						CALLMONITOR 
1192					endif 
1192			      ; Clear the Z flag to indicate successful allocation 
1192 7a			      ld    A, D 
1193 b3			      or    E 
1194			 
1194 d1			      pop   DE                      ; Address of allocation 
1195					if DEBUG_FORTH_MALLOC 
1195						DMARK "MAu" 
1195						CALLMONITOR 
1195					endif 
1195			 
1195			malloc_no_space: 
1195 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1198 39			      add   HL, SP 
1199 f9			      ld    SP, HL 
119a			 
119a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
119b					if DEBUG_FORTH_MALLOC 
119b						DMARK "MAN" 
119b						CALLMONITOR 
119b					endif 
119b			 
119b			malloc_early_exit: 
119b					if DEBUG_FORTH_MALLOC 
119b						DMARK "MAx" 
119b						CALLMONITOR 
119b					endif 
119b dd e1		      pop   IX 
119d d1			      pop   DE 
119e c1			      pop   BC 
119f			 
119f			if DEBUG_FORTH_MALLOC_HIGH 
119f			call malloc_guard_exit 
119f			call malloc_guard_zerolen 
119f			endif 
119f c9			      ret 
11a0			 
11a0			 
11a0			;------------------------------------------------------------------------------ 
11a0			;     free                                                                    : 
11a0			;                                                                             : 
11a0			; Description                                                                 : 
11a0			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11a0			;     returned by malloc, otherwise the behaviour is undefined.               : 
11a0			;                                                                             : 
11a0			;     Where possible, directly adjacent free blocks will be merged together   : 
11a0			;     into larger blocks to help ensure that the heap does not become         : 
11a0			;     excessively fragmented.                                                 : 
11a0			;                                                                             : 
11a0			;     free does not clear or set any other value into the freed space, and    : 
11a0			;     therefore its contents may be visible through subsequent malloc's. The  : 
11a0			;     caller should clear the freed space as required.                        : 
11a0			;                                                                             : 
11a0			;     This implementation of free uses the stack exclusively, and is          : 
11a0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11a0			;     advisable to disable interrupts before calling free, and recommended    : 
11a0			;     to avoid the use of free inside ISRs in general.                        : 
11a0			;                                                                             : 
11a0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11a0			;                                                                             : 
11a0			; Parameters                                                                  : 
11a0			;     HL  Pointer to address of first byte of allocation to be freed          : 
11a0			;                                                                             : 
11a0			; Returns                                                                     : 
11a0			;     Nothing                                                                 : 
11a0			;                                                                             : 
11a0			; Stack frame                                                                 : 
11a0			;       |             |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |     BC      |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |     DE      |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |     IX      |                                                       : 
11a0			;       +-------------+                                                       : 
11a0			;       |  prev_free  |                                                       : 
11a0			;   +2  +-------------+                                                       : 
11a0			;       |  next_free  |                                                       : 
11a0			;   +0  +-------------+                                                       : 
11a0			;       |             |                                                       : 
11a0			;                                                                             : 
11a0			;------------------------------------------------------------------------------ 
11a0			free: 
11a0 c5			      push  BC 
11a1 d5			      push  DE 
11a2 dd e5		      push  IX 
11a4			 
11a4 7c			      ld    A, H                    ; Exit if ptr is null 
11a5 b5			      or    L 
11a6 ca 6a 12		      jp    Z, free_early_exit 
11a9			 
11a9			      ; Set up stack frame 
11a9 eb			      ex    DE, HL 
11aa 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11ad 39			      add   HL, SP 
11ae f9			      ld    SP, HL 
11af dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11b3 dd 39		      add   IX, SP 
11b5			 
11b5			      ; The address in HL points to the start of the useable allocated space, 
11b5			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11b5			      ; address of the block itself. 
11b5 eb			      ex    DE, HL 
11b6 11 fc ff		      ld    DE, -4 
11b9 19			      add   HL, DE 
11ba			 
11ba			      ; An allocated block must have a null next block pointer in it 
11ba 7e			      ld    A, (HL) 
11bb 23			      inc   HL 
11bc b6			      or    (HL) 
11bd c2 65 12		      jp    NZ, free_done 
11c0			 
11c0 2b			      dec   HL 
11c1			 
11c1 44			      ld    B, H                    ; Copy HL to BC 
11c2 4d			      ld    C, L 
11c3			 
11c3			      ; Loop through the free list to find the first block with an address 
11c3			      ; higher than the block being freed 
11c3 21 0a 80		      ld    HL, free_list 
11c6			 
11c6			free_find_higher_block: 
11c6 5e			      ld    E, (HL)                 ; Load next ptr from free block 
11c7 23			      inc   HL 
11c8 56			      ld    D, (HL) 
11c9 2b			      dec   HL 
11ca			 
11ca dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
11cd dd 72 01		      ld    (IX+1), D 
11d0 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
11d3 dd 74 03		      ld    (IX+3), H 
11d6			 
11d6 78			      ld    A, B                    ; Check if DE is greater than BC 
11d7 ba			      cp    D                       ; Compare MSB first 
11d8 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
11da 30 04		      jr    NC, free_find_higher_block_skip 
11dc 79			      ld    A, C 
11dd bb			      cp    E                       ; Then compare LSB 
11de 38 08		      jr    C, free_found_higher_block 
11e0			 
11e0			free_find_higher_block_skip: 
11e0 7a			      ld    A, D                    ; Reached the end of the free list? 
11e1 b3			      or    E 
11e2 ca 65 12		      jp    Z, free_done 
11e5			 
11e5 eb			      ex    DE, HL 
11e6			 
11e6 18 de		      jr    free_find_higher_block 
11e8			 
11e8			free_found_higher_block: 
11e8			      ; Insert freed block between prev and next free blocks 
11e8 71			      ld    (HL), C                 ; Point prev free block to freed block 
11e9 23			      inc   HL 
11ea 70			      ld    (HL), B 
11eb			 
11eb 60			      ld    H, B                    ; Point freed block at next free block 
11ec 69			      ld    L, C 
11ed 73			      ld    (HL), E 
11ee 23			      inc   HL 
11ef 72			      ld    (HL), D 
11f0			 
11f0			      ; Check if the freed block is adjacent to the next free block 
11f0 23			      inc   HL                      ; Load size of freed block into HL 
11f1 5e			      ld    E, (HL) 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 eb			      ex    DE, HL 
11f5			 
11f5 09			      add   HL, BC                  ; Add addr of freed block and its size 
11f6			 
11f6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11f9 dd 56 01		      ld    D, (IX+1) 
11fc			 
11fc b7			      or    A                       ; Clear the carry flag 
11fd ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11ff 20 22		      jr    NZ, free_check_adjacent_to_prev 
1201			 
1201			      ; Freed block is adjacent to next, merge into one bigger block 
1201 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1202 5e			      ld    E, (HL) 
1203 23			      inc   HL 
1204 56			      ld    D, (HL) 
1205 e5			      push  HL                      ; Save ptr to next block for later 
1206			 
1206 60			      ld    H, B                    ; Store ptr from next block into freed block 
1207 69			      ld    L, C 
1208 73			      ld    (HL), E 
1209 23			      inc   HL 
120a 72			      ld    (HL), D 
120b			 
120b e1			      pop   HL                      ; Restore ptr to next block 
120c 23			      inc   HL                      ; Load size of next block into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210 d5			      push  DE                      ; Save next block size for later 
1211			 
1211 60			      ld    H, B                    ; Load size of freed block into HL 
1212 69			      ld    L, C 
1213 23			      inc   HL 
1214 23			      inc   HL 
1215 5e			      ld    E, (HL) 
1216 23			      inc   HL 
1217 56			      ld    D, (HL) 
1218 eb			      ex    DE, HL 
1219			 
1219 d1			      pop   DE                      ; Restore size of next block 
121a 19			      add   HL, DE                  ; Add sizes of both blocks 
121b eb			      ex    DE, HL 
121c			 
121c 60			      ld    H, B                    ; Store new bigger size into freed block 
121d 69			      ld    L, C 
121e 23			      inc   HL 
121f 23			      inc   HL 
1220 73			      ld    (HL), E 
1221 23			      inc   HL 
1222 72			      ld    (HL), D 
1223			 
1223			free_check_adjacent_to_prev: 
1223			      ; Check if the freed block is adjacent to the prev free block 
1223 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1226 dd 66 03		      ld    H, (IX+3) 
1229			 
1229 23			      inc   HL                      ; Size of prev free block into DE 
122a 23			      inc   HL 
122b 5e			      ld    E, (HL) 
122c 23			      inc   HL 
122d 56			      ld    D, (HL) 
122e 2b			      dec   HL 
122f 2b			      dec   HL 
1230 2b			      dec   HL 
1231			 
1231 19			      add   HL, DE                  ; Add prev block addr and size 
1232			 
1232 b7			      or    A                       ; Clear the carry flag 
1233 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1235 20 2e		      jr    NZ, free_done 
1237			 
1237			      ; Freed block is adjacent to prev, merge into one bigger block 
1237 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1238 69			      ld    L, C 
1239 5e			      ld    E, (HL) 
123a 23			      inc   HL 
123b 56			      ld    D, (HL) 
123c e5			      push  HL                      ; Save freed block ptr for later 
123d			 
123d dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1240 dd 66 03		      ld    H, (IX+3) 
1243 73			      ld    (HL), E 
1244 23			      inc   HL 
1245 72			      ld    (HL), D 
1246			 
1246 e1			      pop   HL                      ; Restore freed block ptr 
1247 23			      inc   HL                      ; Load size of freed block into DE 
1248 5e			      ld    E, (HL) 
1249 23			      inc   HL 
124a 56			      ld    D, (HL) 
124b d5			      push  DE                      ; Save freed block size for later 
124c			 
124c dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
124f dd 66 03		      ld    H, (IX+3) 
1252 23			      inc   HL 
1253 23			      inc   HL 
1254 5e			      ld    E, (HL) 
1255 23			      inc   HL 
1256 56			      ld    D, (HL) 
1257			 
1257 e1			      pop   HL                      ; Add sizes of both blocks 
1258 19			      add   HL, DE 
1259 eb			      ex    DE, HL 
125a			 
125a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
125d dd 66 03		      ld    H, (IX+3) 
1260 23			      inc   HL 
1261 23			      inc   HL 
1262 73			      ld    (HL), E 
1263 23			      inc   HL 
1264 72			      ld    (HL), D 
1265			 
1265			free_done: 
1265 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1268 39			      add   HL, SP 
1269 f9			      ld    SP, HL 
126a			 
126a			free_early_exit: 
126a dd e1		      pop   IX 
126c d1			      pop   DE 
126d c1			      pop   BC 
126e			 
126e c9			      ret 
126f			 
126f			; moved to firmware.asm 
126f			; 
126f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
126f			;                  .dw   0 
126f			 
126f			 
126f			endif 
126f			 
126f			 
126f			if MALLOC_3 
126f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
126f			;heap_start        .equ  0x9000      ; Starting address of heap 
126f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
126f			; 
126f			 ;     .org 0 
126f			  ;    jp    main 
126f			; 
126f			; 
126f			 ;     .org  0x100 
126f			;main: 
126f			 ;     ld    HL, 0x8100 
126f			  ;    ld    SP, HL 
126f			; 
126f			;      call  heap_init 
126f			 
126f			      ; Make some allocations 
126f			;      ld    HL, 12 
126f			;      call  malloc            ; Allocates 0x9004 
126f			; 
126f			 ;     ld    HL, 12 
126f			;      call  malloc            ; Allocates 0x9014 
126f			 
126f			;      ld    HL, 12 
126f			;      call  malloc            ; Allocates 0x9024 
126f			 
126f			      ; Free some allocations 
126f			;      ld    HL, 0x9014 
126f			;      call  free 
126f			 
126f			;      ld    HL, 0x9004 
126f			;      call  free 
126f			; 
126f			;      ld    HL, 0x9024 
126f			;      call  free 
126f			 
126f			 
126f			 ;     halt 
126f			 
126f			 
126f			;------------------------------------------------------------------------------ 
126f			;     heap_init                                                               : 
126f			;                                                                             : 
126f			; Description                                                                 : 
126f			;     Initialise the heap and make it ready for malloc and free operations.   : 
126f			;                                                                             : 
126f			;     The heap is maintained as a linked list, starting with an initial       : 
126f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
126f			;     the first free block in the heap. Each block then points to the next    : 
126f			;     free block within the heap, and the free list ends at the first block   : 
126f			;     with a null pointer to the next free block.                             : 
126f			;                                                                             : 
126f			; Parameters                                                                  : 
126f			;     Inputs are compile-time only. Two defines which specify the starting    : 
126f			;     address of the heap and its size are required, along with a memory      : 
126f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
126f			;     principally stores a pointer to the first free block in the heap.       : 
126f			;                                                                             : 
126f			; Returns                                                                     : 
126f			;     Nothing                                                                 : 
126f			;------------------------------------------------------------------------------ 
126f			heap_init: 
126f			      push  HL 
126f			 
126f			      ; Initialise free list struct 
126f			      ld    HL, heap_start 
126f			      ld    (free_list), HL 
126f			      ld    HL, 0 
126f			      ld    (free_list+2), HL 
126f			 
126f			      ; Insert first free block at bottom of heap, consumes entire heap 
126f			      ld    HL, heap_start+heap_size-4 
126f			      ld    (heap_start), HL        ; Next block (end of free list) 
126f			      ld    HL, heap_size-4 
126f			      ld    (heap_start+2), HL      ; Block size 
126f			 
126f			      ; Insert end of free list block at top of heap - two null words will 
126f			      ; terminate the free list 
126f			      ld    HL, 0 
126f			      ld    (heap_start+heap_size-2), HL 
126f			      ld    (heap_start+heap_size-4), HL 
126f			 
126f			      pop   HL 
126f			 
126f			      ret 
126f			 
126f			 
126f			;------------------------------------------------------------------------------ 
126f			;     malloc                                                                  : 
126f			;                                                                             : 
126f			; Description                                                                 : 
126f			;     Allocates the wanted space from the heap and returns the address of the : 
126f			;     first useable byte of the allocation.                                   : 
126f			;                                                                             : 
126f			;     Allocations can happen in one of two ways:                              : 
126f			;                                                                             : 
126f			;     1. A free block may be found which is the exact size wanted. In this    : 
126f			;        case the block is removed from the free list and retuedn to the      : 
126f			;        caller.                                                              : 
126f			;     2. A free block may be found which is larger than the size wanted. In   : 
126f			;        this case, the larger block is split into two. The first portion of  : 
126f			;        this block will become the requested space by the malloc call and    : 
126f			;        is returned to the caller. The second portion becomes a new free     : 
126f			;        block, and the free list is adjusted to maintain continuity via this : 
126f			;        newly created block.                                                 : 
126f			;                                                                             : 
126f			;     malloc does not set any initial value in the allocated space, the       : 
126f			;     caller is required to do this as required.                              : 
126f			;                                                                             : 
126f			;     This implementation of malloc uses the stack exclusively, and is        : 
126f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
126f			;     advisable to disable interrupts before calling malloc, and recommended  : 
126f			;     to avoid the use of malloc inside ISRs in general.                      : 
126f			;                                                                             : 
126f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
126f			;                                                                             : 
126f			; Parameters                                                                  : 
126f			;     HL  Number of bytes wanted                                              : 
126f			;                                                                             : 
126f			; Returns                                                                     : 
126f			;     HL  Address of the first useable byte of the allocation                 : 
126f			;                                                                             : 
126f			; Flags                                                                       : 
126f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
126f			;                                                                             : 
126f			; Stack frame                                                                 : 
126f			;       |             |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     BC      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     DE      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     IX      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |  prev_free  |                                                       : 
126f			;   +4  +-------------+                                                       : 
126f			;       |  this_free  |                                                       : 
126f			;   +2  +-------------+                                                       : 
126f			;       |  next_free  |                                                       : 
126f			;   +0  +-------------+                                                       : 
126f			;       |             |                                                       : 
126f			;                                                                             : 
126f			;------------------------------------------------------------------------------ 
126f			malloc: 
126f			      push  BC 
126f			      push  DE 
126f			      push  IX 
126f			 
126f			      ld    A, H                    ; Exit if no space requested 
126f			      or    L 
126f			      jp    Z, malloc_early_exit 
126f			 
126f			      ; Set up stack frame 
126f			      ex    DE, HL 
126f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			      ld    IX, 0                   ; Use IX as a frame pointer 
126f			      add   IX, SP 
126f			 
126f			      ; Setup initial state 
126f			      ld    HL, 4                   ; want must also include space used by block struct 
126f			      add   HL, DE 
126f			 
126f			      ld    B, H                    ; Move want to BC 
126f			      ld    C, L 
126f			 
126f			      ld    HL, free_list           ; Store prev_free ptr to stack 
126f			      ld    (IX+4), L 
126f			      ld    (IX+5), H 
126f			 
126f			      ld    E, (HL)                 ; Store this_free ptr to stack 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      ld    (IX+2), E 
126f			      ld    (IX+3), D 
126f			      ex    DE, HL                  ; this_free ptr into HL 
126f			 
126f			      ; Loop through free block list to find some space 
126f			malloc_find_space: 
126f			      ld    E, (HL)                 ; Load next_free ptr into DE 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			 
126f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
126f			      or    E 
126f			      jp    Z, malloc_no_space 
126f			 
126f			      ld    (IX+0), E               ; Store next_free ptr to stack 
126f			      ld    (IX+1), D 
126f			 
126f			      ; Does this block have enough space to make the allocation? 
126f			      inc   HL                      ; Load free block size into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			 
126f			      ex    DE, HL                  ; Check size of block against want 
126f			      or    A                       ; Ensure carry flag clear 
126f			      sbc   HL, BC 
126f			      push  HL                      ; Store the result for later (new block size) 
126f			 
126f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
126f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
126f			 
126f			      ; this_free block is not big enough, setup ptrs to test next free block 
126f			      pop   HL                      ; Discard previous result 
126f			 
126f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
126f			      ld    H, (IX+3) 
126f			      ld    (IX+4), L 
126f			      ld    (IX+5), H 
126f			 
126f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
126f			      ld    H, (IX+1) 
126f			      ld    (IX+2), L 
126f			      ld    (IX+3), H 
126f			 
126f			      jr    malloc_find_space 
126f			 
126f			      ; split a bigger block into two - requested size and remaining size 
126f			malloc_alloc_split: 
126f			      ex    DE, HL                  ; Calculate address of new free block 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			      add   HL, BC 
126f			 
126f			      ; Create a new block and point it at next_free 
126f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
126f			      ld    D, (IX+1) 
126f			 
126f			      ld    (HL), E                 ; Store next_free ptr into new block 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      pop   DE                      ; Store size of new block into new block 
126f			      inc   HL 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      ; Update this_free ptr to point to new block 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			 
126f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
126f			      ld    D, (IX+3) 
126f			 
126f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
126f			      ld    (IX+3), H 
126f			 
126f			      ; Modify this_free block to be allocation 
126f			      ex    DE, HL 
126f			      xor   A                       ; Null the next block ptr of allocated block 
126f			      ld    (HL), A 
126f			      inc   HL 
126f			      ld    (HL), A 
126f			 
126f			      inc   HL                      ; Store want size into allocated block 
126f			      ld    (HL), C 
126f			      inc   HL 
126f			      ld    (HL), B 
126f			      inc   HL 
126f			      push  HL                      ; Address of allocation to return 
126f			 
126f			      jr    malloc_update_links 
126f			 
126f			malloc_alloc_fit: 
126f			      pop   HL                      ; Dont need new block size, want is exact fit 
126f			 
126f			      ; Modify this_free block to be allocation 
126f			      ex    DE, HL 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			 
126f			      xor   A                       ; Null the next block ptr of allocated block 
126f			      ld    (HL), A 
126f			      inc   HL 
126f			      ld    (HL), A 
126f			 
126f			      inc   HL                      ; Store address of allocation to return 
126f			      inc   HL 
126f			      inc   HL 
126f			      push  HL 
126f			 
126f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126f			      ld    L, (IX+0)               ; next_free to HL 
126f			      ld    H, (IX+1) 
126f			 
126f			      ld    (IX+2), L               ; HL to this_free 
126f			      ld    (IX+3), H 
126f			 
126f			 
126f			malloc_update_links: 
126f			      ; Update prev_free ptr to point to this_free 
126f			      ld    L, (IX+4)               ; prev_free ptr to HL 
126f			      ld    H, (IX+5) 
126f			 
126f			      ld    E, (IX+2)               ; this_free ptr to DE 
126f			      ld    D, (IX+3) 
126f			 
126f			      ld    (HL), E                 ; this_free ptr into prev_free 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      ; Clear the Z flag to indicate successful allocation 
126f			      ld    A, D 
126f			      or    E 
126f			 
126f			      pop   DE                      ; Address of allocation 
126f			 
126f			malloc_no_space: 
126f			      ld    HL, 6                   ; Clean up stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			 
126f			      ex    DE, HL                  ; Alloc addr into HL for return 
126f			 
126f			malloc_early_exit: 
126f			      pop   IX 
126f			      pop   DE 
126f			      pop   BC 
126f			 
126f			      ret 
126f			 
126f			 
126f			;------------------------------------------------------------------------------ 
126f			;     free                                                                    : 
126f			;                                                                             : 
126f			; Description                                                                 : 
126f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
126f			;     returned by malloc, otherwise the behaviour is undefined.               : 
126f			;                                                                             : 
126f			;     Where possible, directly adjacent free blocks will be merged together   : 
126f			;     into larger blocks to help ensure that the heap does not become         : 
126f			;     excessively fragmented.                                                 : 
126f			;                                                                             : 
126f			;     free does not clear or set any other value into the freed space, and    : 
126f			;     therefore its contents may be visible through subsequent malloc's. The  : 
126f			;     caller should clear the freed space as required.                        : 
126f			;                                                                             : 
126f			;     This implementation of free uses the stack exclusively, and is          : 
126f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
126f			;     advisable to disable interrupts before calling free, and recommended    : 
126f			;     to avoid the use of free inside ISRs in general.                        : 
126f			;                                                                             : 
126f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
126f			;                                                                             : 
126f			; Parameters                                                                  : 
126f			;     HL  Pointer to address of first byte of allocation to be freed          : 
126f			;                                                                             : 
126f			; Returns                                                                     : 
126f			;     Nothing                                                                 : 
126f			;                                                                             : 
126f			; Stack frame                                                                 : 
126f			;       |             |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     BC      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     DE      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |     IX      |                                                       : 
126f			;       +-------------+                                                       : 
126f			;       |  prev_free  |                                                       : 
126f			;   +2  +-------------+                                                       : 
126f			;       |  next_free  |                                                       : 
126f			;   +0  +-------------+                                                       : 
126f			;       |             |                                                       : 
126f			;                                                                             : 
126f			;------------------------------------------------------------------------------ 
126f			free: 
126f			      push  BC 
126f			      push  DE 
126f			      push  IX 
126f			 
126f			      ld    A, H                    ; Exit if ptr is null 
126f			      or    L 
126f			      jp    Z, free_early_exit 
126f			 
126f			      ; Set up stack frame 
126f			      ex    DE, HL 
126f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			      ld    IX, 0                   ; Use IX as a frame pointer 
126f			      add   IX, SP 
126f			 
126f			      ; The address in HL points to the start of the useable allocated space, 
126f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
126f			      ; address of the block itself. 
126f			      ex    DE, HL 
126f			      ld    DE, -4 
126f			      add   HL, DE 
126f			 
126f			      ; An allocated block must have a null next block pointer in it 
126f			      ld    A, (HL) 
126f			      inc   HL 
126f			      or    (HL) 
126f			      jp    NZ, free_done 
126f			 
126f			      dec   HL 
126f			 
126f			      ld    B, H                    ; Copy HL to BC 
126f			      ld    C, L 
126f			 
126f			      ; Loop through the free list to find the first block with an address 
126f			      ; higher than the block being freed 
126f			      ld    HL, free_list 
126f			 
126f			free_find_higher_block: 
126f			      ld    E, (HL)                 ; Load next ptr from free block 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      dec   HL 
126f			 
126f			      ld    (IX+0), E               ; Save ptr to next free block 
126f			      ld    (IX+1), D 
126f			      ld    (IX+2), L               ; Save ptr to prev free block 
126f			      ld    (IX+3), H 
126f			 
126f			      ld    A, B                    ; Check if DE is greater than BC 
126f			      cp    D                       ; Compare MSB first 
126f			      jr    Z, $+4                  ; MSB the same, compare LSB 
126f			      jr    NC, free_find_higher_block_skip 
126f			      ld    A, C 
126f			      cp    E                       ; Then compare LSB 
126f			      jr    C, free_found_higher_block 
126f			 
126f			free_find_higher_block_skip: 
126f			      ld    A, D                    ; Reached the end of the free list? 
126f			      or    E 
126f			      jp    Z, free_done 
126f			 
126f			      ex    DE, HL 
126f			 
126f			      jr    free_find_higher_block 
126f			 
126f			free_found_higher_block: 
126f			      ; Insert freed block between prev and next free blocks 
126f			      ld    (HL), C                 ; Point prev free block to freed block 
126f			      inc   HL 
126f			      ld    (HL), B 
126f			 
126f			      ld    H, B                    ; Point freed block at next free block 
126f			      ld    L, C 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      ; Check if the freed block is adjacent to the next free block 
126f			      inc   HL                      ; Load size of freed block into HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      ex    DE, HL 
126f			 
126f			      add   HL, BC                  ; Add addr of freed block and its size 
126f			 
126f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
126f			      ld    D, (IX+1) 
126f			 
126f			      or    A                       ; Clear the carry flag 
126f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
126f			      jr    NZ, free_check_adjacent_to_prev 
126f			 
126f			      ; Freed block is adjacent to next, merge into one bigger block 
126f			      ex    DE, HL                  ; Load next ptr from next block into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  HL                      ; Save ptr to next block for later 
126f			 
126f			      ld    H, B                    ; Store ptr from next block into freed block 
126f			      ld    L, C 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      pop   HL                      ; Restore ptr to next block 
126f			      inc   HL                      ; Load size of next block into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  DE                      ; Save next block size for later 
126f			 
126f			      ld    H, B                    ; Load size of freed block into HL 
126f			      ld    L, C 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      ex    DE, HL 
126f			 
126f			      pop   DE                      ; Restore size of next block 
126f			      add   HL, DE                  ; Add sizes of both blocks 
126f			      ex    DE, HL 
126f			 
126f			      ld    H, B                    ; Store new bigger size into freed block 
126f			      ld    L, C 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			free_check_adjacent_to_prev: 
126f			      ; Check if the freed block is adjacent to the prev free block 
126f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
126f			      ld    H, (IX+3) 
126f			 
126f			      inc   HL                      ; Size of prev free block into DE 
126f			      inc   HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      dec   HL 
126f			      dec   HL 
126f			      dec   HL 
126f			 
126f			      add   HL, DE                  ; Add prev block addr and size 
126f			 
126f			      or    A                       ; Clear the carry flag 
126f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
126f			      jr    NZ, free_done 
126f			 
126f			      ; Freed block is adjacent to prev, merge into one bigger block 
126f			      ld    H, B                    ; Load next ptr from freed block into DE 
126f			      ld    L, C 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  HL                      ; Save freed block ptr for later 
126f			 
126f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
126f			      ld    H, (IX+3) 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			      pop   HL                      ; Restore freed block ptr 
126f			      inc   HL                      ; Load size of freed block into DE 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			      push  DE                      ; Save freed block size for later 
126f			 
126f			      ld    L, (IX+2)               ; Load size of prev block into DE 
126f			      ld    H, (IX+3) 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    E, (HL) 
126f			      inc   HL 
126f			      ld    D, (HL) 
126f			 
126f			      pop   HL                      ; Add sizes of both blocks 
126f			      add   HL, DE 
126f			      ex    DE, HL 
126f			 
126f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
126f			      ld    H, (IX+3) 
126f			      inc   HL 
126f			      inc   HL 
126f			      ld    (HL), E 
126f			      inc   HL 
126f			      ld    (HL), D 
126f			 
126f			free_done: 
126f			      ld    HL, 4                   ; Clean up stack frame 
126f			      add   HL, SP 
126f			      ld    SP, HL 
126f			 
126f			free_early_exit: 
126f			      pop   IX 
126f			      pop   DE 
126f			      pop   BC 
126f			 
126f			      ret 
126f			 
126f			 
126f			;      .org 0x8000 
126f			; 
126f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
126f			 ;                 .dw   0 
126f			 
126f			endif 
126f			 
126f			 
126f			if MALLOC_4 
126f			 
126f			; My memory allocation code. Very very simple.... 
126f			; allocate space under 250 chars 
126f			 
126f			heap_init: 
126f				; init start of heap as zero 
126f				;  
126f			 
126f				ld hl, heap_start 
126f				ld a, 0 
126f				ld (hl), a      ; empty block 
126f				inc hl 
126f				ld a, 0 
126f				ld (hl), a      ; length of block 
126f				; write end of list 
126f				inc hl 
126f				ld a,(hl) 
126f				inc hl 
126f				ld a,(hl) 
126f				 
126f			 
126f				; init some malloc vars 
126f			 
126f				ld hl, 0 
126f				ld (free_list), hl       ; store last malloc location 
126f			 
126f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
126f				ld a, 0 
126f				ld (hl), a 
126f			 
126f			 
126f				ld hl, heap_start 
126f				;  
126f				  
126f				ret 
126f			 
126f			 
126f			;    free block marker 
126f			;    requested size  
126f			;    pointer to next block 
126f			;    .... 
126f			;    next block marker 
126f			 
126f			 
126f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
126f			; 
126f			 
126f			 
126f			malloc:  
126f				push de 
126f				push bc 
126f				push af 
126f			 
126f				; hl space required 
126f				 
126f				ld c, l    ; hold space   (TODO only a max of 255) 
126f			 
126f			;	inc c     ; TODO BUG need to fix memory leak on push str 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			;	inc c 
126f			 
126f			 
126f			 
126f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
126f			 
126f				ld a, (free_list+3) 
126f				cp 0 
126f				jr z, .contheap 
126f			 
126f				ld hl, (free_list)     ; get last alloc 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mrs" 
126f						CALLMONITOR 
126f					endif 
126f				jr .startalloc 
126f			 
126f			.contheap: 
126f				ld hl, heap_start 
126f			 
126f			.startalloc: 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mym" 
126f						CALLMONITOR 
126f					endif 
126f			.findblock: 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mmf" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f				ld a,(hl)  
126f				; if byte is zero then clear to use 
126f			 
126f				cp 0 
126f				jr z, .foundemptyblock 
126f			 
126f				; if byte is not clear 
126f				;     then byte is offset to next block 
126f			 
126f				inc hl 
126f				ld a, (hl) ; get size 
126f			.nextblock:	inc hl 
126f					ld e, (hl) 
126f					inc hl 
126f					ld d, (hl) 
126f					ex de, hl 
126f			;	inc hl  ; move past the store space 
126f			;	inc hl  ; move past zero index  
126f			 
126f				; TODO detect no more space 
126f			 
126f				push hl 
126f				ld de, heap_end 
126f				call cmp16 
126f				pop hl 
126f				jr nc, .nospace 
126f			 
126f				jr .findblock 
126f			 
126f			.nospace: ld hl, 0 
126f				jp .exit 
126f			 
126f			 
126f			.foundemptyblock:	 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mme" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			; TODO has block enough space if reusing??? 
126f			 
126f				;  
126f			 
126f			; see if this block has been previously used 
126f				inc hl 
126f				ld a, (hl) 
126f				dec hl 
126f				cp 0 
126f				jr z, .newblock 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "meR" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			; no reusing previously allocated block 
126f			 
126f			; is it smaller than previously used? 
126f				 
126f				inc hl    ; move to size 
126f				ld a, c 
126f				sub (hl)        ; we want c < (hl) 
126f				dec hl    ; move back to marker 
126f			        jr z, .findblock 
126f			 
126f				; update with the new size which should be lower 
126f			 
126f			        ;inc  hl   ; negate next move. move back to size  
126f			 
126f			.newblock: 
126f				; need to be at marker here 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "meN" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			 
126f				ld a, c 
126f			 
126f				ld (free_list+3), a	 ; flag resume from last malloc  
126f				ld (free_list), hl    ; save out last location 
126f			 
126f			 
126f				;inc a     ; space for length byte 
126f				ld (hl), a     ; save block in use marker 
126f			 
126f				inc hl   ; move to space marker 
126f				ld (hl), a    ; save new space 
126f			 
126f				inc hl   ; move to start of allocated area 
126f				 
126f			;	push hl     ; save where we are - 1  
126f			 
126f			;	inc hl  ; move past zero index  
126f				; skip space to set down new marker 
126f			 
126f				; provide some extra space for now 
126f			 
126f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
126f				inc a 
126f				inc a 
126f			 
126f				push hl   ; save where we are in the node block 
126f			 
126f				call addatohl 
126f			 
126f				; write linked list point 
126f			 
126f				pop de     ; get our node position 
126f				ex de, hl 
126f			 
126f				ld (hl), e 
126f				inc hl 
126f				ld (hl), d 
126f			 
126f				inc hl 
126f			 
126f				; now at start of allocated data so save pointer 
126f			 
126f				push hl 
126f			 
126f				; jump to position of next node and setup empty header in DE 
126f			 
126f				ex de, hl 
126f			 
126f			;	inc hl ; move past end of block 
126f			 
126f				ld a, 0 
126f				ld (hl), a   ; empty marker 
126f				inc hl 
126f				ld (hl), a   ; size 
126f				inc hl  
126f				ld (hl), a   ; ptr 
126f				inc hl 
126f				ld (hl), a   ; ptr 
126f			 
126f			 
126f				pop hl 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "mmr" 
126f						CALLMONITOR 
126f					endif 
126f			 
126f			.exit: 
126f				pop af 
126f				pop bc 
126f				pop de  
126f				ret 
126f			 
126f			 
126f			 
126f			 
126f			free:  
126f				push hl 
126f				push af 
126f				; get address in hl 
126f			 
126f					if DEBUG_FORTH_MALLOC_INT 
126f						DMARK "fre" 
126f						CALLMONITOR 
126f					endif 
126f				; data is at hl - move to block count 
126f				dec hl 
126f				dec hl    ; get past pointer 
126f				dec hl 
126f			 
126f				ld a, (hl)    ; need this for a validation check 
126f			 
126f				dec hl    ; move to block marker 
126f			 
126f				; now check that the block count and block marker are the same  
126f			        ; this checks that we are on a malloc node and not random memory 
126f			        ; OK a faint chance this could be a problem but rare - famous last words! 
126f			 
126f				ld c, a 
126f				ld a, (hl)    
126f			 
126f				cp c 
126f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
126f			 
126f				; yes good chance we are on a malloc node 
126f			 
126f				ld a, 0      
126f				ld (hl), a   ; mark as free 
126f			 
126f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
126f			 
126f			.freeignore:  
126f			 
126f				pop af 
126f				pop hl 
126f			 
126f				ret 
126f			 
126f			 
126f			 
126f			endif 
126f			 
126f			; eof 
# End of file firmware_memory.asm
126f			  
126f			; device C  
126f			if SOUND_ENABLE  
126f				include "firmware_sound.asm"  
126f			endif  
126f			  
126f			include "firmware_diags.asm"  
126f			; Hardware diags menu 
126f			 
126f			 
126f .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1290 .. 00		hd_menu2:   db "        2: Editor",0   
12a2			;hd_menu2:   db "        2: Editor       6: BASIC",0   
12a2 .. 00		hd_menu3:   db "        3: Storage",0 
12b5 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
12c6 .. 00		hd_don:     db "ON",0 
12c9 .. 00		hd_doff:     db "OFF",0 
12cd			 
12cd			 
12cd			 
12cd			hardware_diags:       
12cd			 
12cd			.diagmenu: 
12cd cd b6 0a			call clear_display 
12d0 3e 00			ld a, display_row_1 
12d2 11 6f 12			ld de, hd_menu1 
12d5 cd c9 0a			call str_at_display 
12d8			 
12d8 3e 14			ld a, display_row_2 
12da 11 90 12			ld de, hd_menu2 
12dd cd c9 0a			call str_at_display 
12e0			 
12e0 3e 28			ld a, display_row_3 
12e2 11 a2 12			ld de, hd_menu3 
12e5 cd c9 0a			call str_at_display 
12e8			 
12e8 3e 3c			ld a,  display_row_4 
12ea 11 b5 12			ld de, hd_menu4 
12ed cd c9 0a			call str_at_display 
12f0			 
12f0				; display debug state 
12f0			 
12f0 11 c6 12			ld de, hd_don 
12f3 3a b7 ef			ld a, (os_view_disable) 
12f6 fe 00			cp 0 
12f8 28 03			jr z, .distog 
12fa 11 c9 12			ld de, hd_doff 
12fd 3e 4d		.distog: ld a, display_row_4+17 
12ff cd c9 0a			call str_at_display 
1302			 
1302 cd d9 0a			call update_display 
1305			 
1305 cd f0 62			call cin_wait 
1308			 
1308			 
1308			 
1308 fe 34			cp '4' 
130a 20 0f			jr nz, .diagn1 
130c			 
130c				; debug toggle 
130c			 
130c 3a b7 ef			ld a, (os_view_disable) 
130f 06 2a			ld b, '*' 
1311 fe 00			cp 0 
1313 28 02			jr z, .debtog 
1315 06 00			ld b, 0 
1317			.debtog:	 
1317 78				ld a,b 
1318 32 b7 ef			ld (os_view_disable),a 
131b			 
131b fe 30		.diagn1: cp '0' 
131d c8				 ret z 
131e			 
131e			;	cp '1' 
131e			;       jp z, matrix	 
131e			;   TODO keyboard matrix test 
131e			 
131e fe 32			cp '2' 
1320 ca 27 13			jp z, .diagedit 
1323			 
1323			;if ENABLE_BASIC 
1323			;	cp '6' 
1323			;	jp z, basic 
1323			;endif 
1323			  
1323 c3 cd 12			jp .diagmenu 
1326			 
1326			 
1326 c9				ret 
1327			 
1327			; debug editor 
1327			 
1327			.diagedit: 
1327			 
1327 21 b8 ef			ld hl, scratch 
132a			;	ld bc, 250 
132a			;	ldir 
132a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
132a 3e 00			ld a, 0 
132c 77				ld (hl), a 
132d 23				inc hl 
132e 77				ld (hl), a 
132f 23				inc hl 
1330 77				ld (hl), a 
1331			 
1331 cd b6 0a		        call clear_display 
1334 cd d9 0a			call update_display 
1337 3e 01			ld a, 1 
1339 32 c3 fb			ld (hardware_diag), a 
133c			.diloop: 
133c 3e 00			ld a, display_row_1 
133e 0e 00			ld c, 0 
1340 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1342 1e 28			ld e, 40 
1344			 
1344 21 b8 ef			ld hl, scratch	 
1347 cd 3c 0c			call input_str 
134a			 
134a 3e 14			ld a, display_row_2 
134c 11 b8 ef			ld de, scratch 
134f cd c9 0a			call str_at_display 
1352 cd d9 0a			call update_display 
1355			 
1355 c3 3c 13			jp .diloop 
1358			 
1358			 
1358			; pass word in hl 
1358			; a has display location 
1358			display_word_at: 
1358 f5				push af 
1359 e5				push hl 
135a 7c				ld a,h 
135b 21 bd f2			ld hl, os_word_scratch 
135e cd 10 0f			call hexout 
1361 e1				pop hl 
1362 7d				ld a,l 
1363 21 bf f2			ld hl, os_word_scratch+2 
1366 cd 10 0f			call hexout 
1369 21 c1 f2			ld hl, os_word_scratch+4 
136c 3e 00			ld a,0 
136e 77				ld (hl),a 
136f 11 bd f2			ld de,os_word_scratch 
1372 f1				pop af 
1373 cd c9 0a				call str_at_display 
1376 c9				ret 
1377			 
1377			display_ptr_state: 
1377			 
1377				; to restore afterwards 
1377			 
1377 d5				push de 
1378 c5				push bc 
1379 e5				push hl 
137a f5				push af 
137b			 
137b				; for use in here 
137b			 
137b			;	push bc 
137b			;	push de 
137b			;	push hl 
137b			;	push af 
137b			 
137b cd b6 0a			call clear_display 
137e			 
137e 11 51 15			ld de, .ptrstate 
1381 3e 00			ld a, display_row_1 
1383 cd c9 0a			call str_at_display 
1386			 
1386				; display debug step 
1386			 
1386			 
1386 11 bd fb			ld de, debug_mark 
1389 3e 12			ld a, display_row_1+display_cols-2 
138b cd c9 0a			call str_at_display 
138e			 
138e				; display a 
138e 11 5b 15			ld de, .ptrcliptr 
1391 3e 14			ld a, display_row_2 
1393 cd c9 0a			call str_at_display 
1396			 
1396 f1				pop af 
1397 2a c3 f9			ld hl,(cli_ptr) 
139a 3e 1c			ld a, display_row_2+8 
139c cd 58 13			call display_word_at 
139f			 
139f			 
139f				; display hl 
139f			 
139f			 
139f 11 63 15			ld de, .ptrclioptr 
13a2 3e 1e			ld a, display_row_2+10 
13a4 cd c9 0a			call str_at_display 
13a7			; 
13a7			;	pop hl 
13a7 3e 21			ld a, display_row_2+13 
13a9 2a c1 f9			ld hl,(cli_origptr) 
13ac cd 58 13			call display_word_at 
13af			; 
13af			;	 
13af			;	; display de 
13af			 
13af			;	ld de, .regstatede 
13af			;	ld a, display_row_3 
13af			;	call str_at_display 
13af			 
13af			;	pop de 
13af			;	ld h,d 
13af			;	ld l, e 
13af			;	ld a, display_row_3+3 
13af			;	call display_word_at 
13af			 
13af			 
13af				; display bc 
13af			 
13af			;	ld de, .regstatebc 
13af			;	ld a, display_row_3+10 
13af			;	call str_at_display 
13af			 
13af			;	pop bc 
13af			;	ld h,b 
13af			;	ld l, c 
13af			;	ld a, display_row_3+13 
13af			;	call display_word_at 
13af			 
13af			 
13af				; display dsp 
13af			 
13af			;	ld de, .regstatedsp 
13af			;	ld a, display_row_4 
13af			;	call str_at_display 
13af			 
13af				 
13af			;	ld hl,(cli_data_sp) 
13af			;	ld a, display_row_4+4 
13af			;	call display_word_at 
13af			 
13af				; display rsp 
13af			 
13af 11 92 15			ld de, .regstatersp 
13b2 3e 46			ld a, display_row_4+10 
13b4 cd c9 0a			call str_at_display 
13b7			 
13b7				 
13b7 2a a9 f9			ld hl,(cli_ret_sp) 
13ba 3e 4a			ld a, display_row_4+14 
13bc cd 58 13			call display_word_at 
13bf			 
13bf cd d9 0a			call update_display 
13c2			 
13c2 cd 3a 0a			call delay1s 
13c5 cd 3a 0a			call delay1s 
13c8 cd 3a 0a			call delay1s 
13cb			 
13cb			 
13cb cd d8 18			call next_page_prompt 
13ce			 
13ce				; restore  
13ce			 
13ce f1				pop af 
13cf e1				pop hl 
13d0 c1				pop bc 
13d1 d1				pop de 
13d2 c9				ret 
13d3			 
13d3			break_point_state: 
13d3 f5				push af 
13d4			 
13d4				; see if disabled 
13d4			 
13d4 3a b7 ef			ld a, (os_view_disable) 
13d7 fe 2a			cp '*' 
13d9 20 02			jr nz, .bpsgo 
13db f1				pop af 
13dc c9				ret 
13dd			 
13dd			.bpsgo: 
13dd f1				pop af 
13de f5				push af 
13df 22 b3 ef			ld (os_view_hl), hl 
13e2 ed 53 b1 ef		ld (os_view_de), de 
13e6 ed 43 af ef		ld (os_view_bc), bc 
13ea e5				push hl 
13eb 6f				ld l, a 
13ec 26 00			ld h, 0 
13ee 22 b5 ef			ld (os_view_af),hl 
13f1			 
13f1 21 53 fb				ld hl, display_fb0 
13f4 22 5e fa				ld (display_fb_active), hl 
13f7 e1				pop hl	 
13f8			 
13f8 3e 31			ld a, '1' 
13fa fe 2a		.bps1:  cp '*' 
13fc 20 03			jr nz, .bps1b 
13fe 32 b7 ef			ld (os_view_disable),a 
1401 fe 31		.bps1b:  cp '1' 
1403 20 14			jr nz, .bps2 
1405			 
1405				; display reg 
1405			 
1405				 
1405			 
1405 3a b5 ef			ld a, (os_view_af) 
1408 2a b3 ef			ld hl, (os_view_hl) 
140b ed 5b b1 ef		ld de, (os_view_de) 
140f ed 4b af ef		ld bc, (os_view_bc) 
1413 cd ad 14			call display_reg_state 
1416 c3 99 14			jp .bpschk 
1419			 
1419 fe 32		.bps2:  cp '2' 
141b 20 08			jr nz, .bps3 
141d				 
141d				; display hl 
141d 2a b3 ef			ld hl, (os_view_hl) 
1420 cd 97 15			call display_dump_at_hl 
1423			 
1423 18 74			jr .bpschk 
1425			 
1425 fe 33		.bps3:  cp '3' 
1427 20 08			jr nz, .bps4 
1429			 
1429			        ; display de 
1429 2a b1 ef			ld hl, (os_view_de) 
142c cd 97 15			call display_dump_at_hl 
142f			 
142f 18 68			jr .bpschk 
1431 fe 34		.bps4:  cp '4' 
1433 20 08			jr nz, .bps5 
1435			 
1435			        ; display bc 
1435 2a af ef			ld hl, (os_view_bc) 
1438 cd 97 15			call display_dump_at_hl 
143b			 
143b 18 5c			jr .bpschk 
143d fe 35		.bps5:  cp '5' 
143f 20 08		        jr nz, .bps7 
1441			 
1441				; display cur ptr 
1441 2a c3 f9			ld hl, (cli_ptr) 
1444 cd 97 15			call display_dump_at_hl 
1447			 
1447 18 50			jr .bpschk 
1449 fe 36		.bps7:  cp '6' 
144b 20 08			jr nz, .bps8b 
144d				 
144d				; display cur orig ptr 
144d 2a c1 f9			ld hl, (cli_origptr) 
1450 cd 97 15			call display_dump_at_hl 
1453 18 44			jr .bpschk 
1455 fe 37		.bps8b:  cp '7' 
1457 20 08			jr nz, .bps9 
1459				 
1459				; display dsp 
1459 2a a5 f9			ld hl, (cli_data_sp) 
145c cd 97 15			call display_dump_at_hl 
145f			 
145f 18 38			jr .bpschk 
1461 fe 39		.bps9:  cp '9' 
1463 20 05			jr nz, .bps8c 
1465				 
1465				; display SP 
1465			;	ld hl, sp 
1465 cd 97 15			call display_dump_at_hl 
1468			 
1468 18 2f			jr .bpschk 
146a fe 38		.bps8c:  cp '8' 
146c 20 08			jr nz, .bps8d 
146e				 
146e				; display rsp 
146e 2a a9 f9			ld hl, (cli_ret_sp) 
1471 cd 97 15			call display_dump_at_hl 
1474			 
1474 18 23			jr .bpschk 
1476 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1478 20 05			jr nz, .bps8 
147a cd ce 16			call monitor 
147d			 
147d 18 1a			jr .bpschk 
147f fe 30		.bps8:  cp '0' 
1481 20 16			jr nz, .bpschk 
1483			 
1483 21 02 fb				ld hl, display_fb1 
1486 22 5e fa				ld (display_fb_active), hl 
1489 cd d9 0a				call update_display 
148c			 
148c				;ld a, (os_view_af) 
148c 2a b3 ef			ld hl, (os_view_hl) 
148f ed 5b b1 ef		ld de, (os_view_de) 
1493 ed 4b af ef		ld bc, (os_view_bc) 
1497 f1				pop af 
1498 c9				ret 
1499			 
1499			.bpschk:   
1499 cd 3a 0a			call delay1s 
149c 3e 4f		ld a,display_row_4 + display_cols - 1 
149e 11 d6 18		        ld de, endprg 
14a1 cd c9 0a			call str_at_display 
14a4 cd d9 0a			call update_display 
14a7 cd f0 62			call cin_wait 
14aa			 
14aa c3 fa 13			jp .bps1 
14ad			 
14ad			 
14ad			display_reg_state: 
14ad			 
14ad				; to restore afterwards 
14ad			 
14ad d5				push de 
14ae c5				push bc 
14af e5				push hl 
14b0 f5				push af 
14b1			 
14b1				; for use in here 
14b1			 
14b1 c5				push bc 
14b2 d5				push de 
14b3 e5				push hl 
14b4 f5				push af 
14b5			 
14b5 cd b6 0a			call clear_display 
14b8			 
14b8 11 6d 15			ld de, .regstate 
14bb 3e 00			ld a, display_row_1 
14bd cd c9 0a			call str_at_display 
14c0			 
14c0				; display debug step 
14c0			 
14c0			 
14c0 11 bd fb			ld de, debug_mark 
14c3 3e 11			ld a, display_row_1+display_cols-3 
14c5 cd c9 0a			call str_at_display 
14c8			 
14c8				; display a 
14c8 11 89 15			ld de, .regstatea 
14cb 3e 14			ld a, display_row_2 
14cd cd c9 0a			call str_at_display 
14d0			 
14d0 e1				pop hl 
14d1			;	ld h,0 
14d1			;	ld l, a 
14d1 3e 17			ld a, display_row_2+3 
14d3 cd 58 13			call display_word_at 
14d6			 
14d6			 
14d6				; display hl 
14d6			 
14d6			 
14d6 11 7d 15			ld de, .regstatehl 
14d9 3e 1e			ld a, display_row_2+10 
14db cd c9 0a			call str_at_display 
14de			 
14de e1				pop hl 
14df 3e 21			ld a, display_row_2+13 
14e1 cd 58 13			call display_word_at 
14e4			 
14e4				 
14e4				; display de 
14e4			 
14e4 11 81 15			ld de, .regstatede 
14e7 3e 28			ld a, display_row_3 
14e9 cd c9 0a			call str_at_display 
14ec			 
14ec e1				pop hl 
14ed			;	ld h,d 
14ed			;	ld l, e 
14ed 3e 2b			ld a, display_row_3+3 
14ef cd 58 13			call display_word_at 
14f2			 
14f2			 
14f2				; display bc 
14f2			 
14f2 11 85 15			ld de, .regstatebc 
14f5 3e 32			ld a, display_row_3+10 
14f7 cd c9 0a			call str_at_display 
14fa			 
14fa e1				pop hl 
14fb			;	ld h,b 
14fb			;	ld l, c 
14fb 3e 35			ld a, display_row_3+13 
14fd cd 58 13			call display_word_at 
1500			 
1500			 
1500				; display dsp 
1500			 
1500 11 8d 15			ld de, .regstatedsp 
1503 3e 3c			ld a, display_row_4 
1505 cd c9 0a			call str_at_display 
1508			 
1508				 
1508 2a a5 f9			ld hl,(cli_data_sp) 
150b 3e 40			ld a, display_row_4+4 
150d cd 58 13			call display_word_at 
1510			 
1510				; display rsp 
1510			 
1510 11 92 15			ld de, .regstatersp 
1513 3e 46			ld a, display_row_4+10 
1515 cd c9 0a			call str_at_display 
1518			 
1518				 
1518 2a a9 f9			ld hl,(cli_ret_sp) 
151b 3e 4a			ld a, display_row_4+14 
151d cd 58 13			call display_word_at 
1520			 
1520 cd d9 0a			call update_display 
1523			 
1523			;	call delay1s 
1523			;	call delay1s 
1523			;	call delay1s 
1523			 
1523			 
1523			;	call next_page_prompt 
1523			 
1523				; restore  
1523			 
1523 f1				pop af 
1524 e1				pop hl 
1525 c1				pop bc 
1526 d1				pop de 
1527 c9				ret 
1528			 
1528 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
153c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1551 .. 00		.ptrstate:	db "Ptr State",0 
155b .. 00		.ptrcliptr:     db "cli_ptr",0 
1563 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
156d .. 00		.regstate:	db "Reg State (1/0)",0 
157d .. 00		.regstatehl:	db "HL:",0 
1581 .. 00		.regstatede:	db "DE:",0 
1585 .. 00		.regstatebc:	db "BC:",0 
1589 .. 00		.regstatea:	db "A :",0 
158d .. 00		.regstatedsp:	db "DSP:",0 
1592 .. 00		.regstatersp:	db "RSP:",0 
1597			 
1597			display_dump_at_hl: 
1597 e5				push hl 
1598 d5				push de 
1599 c5				push bc 
159a f5				push af 
159b			 
159b 22 db f2			ld (os_cur_ptr),hl	 
159e cd b6 0a			call clear_display 
15a1 cd e0 17			call dumpcont 
15a4			;	call delay1s 
15a4			;	call next_page_prompt 
15a4			 
15a4			 
15a4 f1				pop af 
15a5 c1				pop bc 
15a6 d1				pop de 
15a7 e1				pop hl 
15a8 c9				ret 
15a9			 
15a9			;if ENABLE_BASIC 
15a9			;	include "nascombasic.asm" 
15a9			;	basic: 
15a9			;	include "forth/FORTH.ASM" 
15a9			;endif 
15a9			 
15a9			; eof 
15a9			 
15a9			 
# End of file firmware_diags.asm
15a9			  
15a9			  
15a9			  
15a9			  
15a9			; eof  
15a9			  
# End of file firmware.asm
15a9			 
15a9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15a9			;if BASE_KEV  
15a9			;baseram: equ 08000h 
15a9			;endif 
15a9			 
15a9			;if BASE_SC114 
15a9			;baseram:     equ    endofcode 
15a9			;endif 
15a9			 
15a9			 
15a9			; start system 
15a9			 
15a9			coldstart: 
15a9				; set sp 
15a9				; di/ei 
15a9			 
15a9 f3				di 
15aa 31 fd ff			ld sp, tos 
15ad			;	ei 
15ad			 
15ad			 
15ad				; disable breakpoint by default 
15ad			 
15ad 3e 2a			ld a,'*' 
15af 32 b7 ef			ld (os_view_disable),a 
15b2			 
15b2				; init hardware 
15b2			 
15b2				; init keyboard and screen hardware 
15b2			 
15b2 cd 03 00			call hardware_init 
15b5			 
15b5			 
15b5				; detect if any keys are held down to enable breakpoints at start up 
15b5			 
15b5 cd 01 63			call cin  
15b8 fe 00			cp 0 
15ba 28 03			jr z, .nokeys 
15bc			 
15bc cd cd 12			call hardware_diags 
15bf			 
15bf			;	ld de, .bpen 
15bf			;	ld a, display_row_4 
15bf			;	call str_at_display 
15bf			;	call update_display 
15bf			; 
15bf			;	ld a,0 
15bf			;	ld (os_view_disable),a 
15bf			; 
15bf			;.bpwait: 
15bf			;	call cin 
15bf			;	cp 0 
15bf			;	jr z, .bpwait 
15bf			;	jr .nokeys 
15bf			; 
15bf			; 
15bf			;.bpen:  db "Break points enabled!",0 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			.nokeys: 
15bf			 
15bf			 
15bf				 
15bf			 
15bf			;jp  testkey 
15bf			 
15bf			;call storage_get_block_0 
15bf			; 
15bf			;ld hl, 0 
15bf			;ld de, store_page 
15bf			;call storage_read_block 
15bf			 
15bf				 
15bf			;ld hl, 10 
15bf			;ld de, store_page 
15bf			;call storage_read_block 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			 
15bf			;stop:	nop 
15bf			;	jp stop 
15bf			 
15bf			 
15bf			 
15bf			main: 
15bf cd b6 0a			call clear_display 
15c2 cd d9 0a			call update_display 
15c5			 
15c5			 
15c5			 
15c5			;	call testlcd 
15c5			 
15c5			 
15c5			 
15c5 cd 26 1b			call forth_init 
15c8			 
15c8			 
15c8			warmstart: 
15c8 cd fc 1a			call forth_warmstart 
15cb			 
15cb				; run startup word load 
15cb			        ; TODO prevent this running at warmstart after crash  
15cb			 
15cb				if STARTUP_ENABLE 
15cb cd 6a 5e				call forth_startup 
15ce				endif 
15ce			 
15ce				; show free memory after boot 
15ce 11 68 16			ld de, freeram 
15d1 3e 00			ld a, display_row_1 
15d3 cd c9 0a			call str_at_display 
15d6			 
15d6			; Or use heap_size word???? 
15d6 21 ac ef			ld hl, heap_end 
15d9 11 0e 80			ld de, heap_start 
15dc ed 52			sbc hl, de 
15de e5				push hl 
15df 7c				ld a,h	         	 
15e0 21 bd f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
15e3 cd 10 0f			call hexout 
15e6 e1			   	pop hl 
15e7			 
15e7 7d				ld a,l 
15e8 21 bf f2			ld hl, os_word_scratch+2 
15eb cd 10 0f			call hexout 
15ee 21 c1 f2			ld hl, os_word_scratch+4 
15f1 3e 00			ld a, 0 
15f3 77				ld (hl),a 
15f4 11 bd f2			ld de, os_word_scratch 
15f7 3e 0d			ld a, display_row_1 + 13 
15f9 cd c9 0a			call str_at_display 
15fc cd d9 0a			call update_display 
15ff			 
15ff			 
15ff				;call demo 
15ff			 
15ff			 
15ff				; init scratch input area for cli commands 
15ff			 
15ff 21 df f2			ld hl, os_cli_cmd 
1602 3e 00			ld a,0 
1604 77				ld (hl),a 
1605 23				inc hl 
1606 77				ld (hl),a 
1607			 
1607 3e 00			ld a,0 
1609 32 de f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
160c			 
160c 32 db f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
160f 32 dc f2			ld (os_cur_ptr+1),a	 
1612			 
1612 32 bd f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1615 32 be f2			ld (os_word_scratch+1),a	 
1618				 
1618			 
1618				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1618 21 df f2			ld hl, os_cli_cmd 
161b			 
161b 3e 00			ld a, 0		 ; init cli input 
161d 77				ld (hl), a 
161e 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1620			cli: 
1620				; show cli prompt 
1620				;push af 
1620				;ld a, 0 
1620				;ld de, prompt 
1620				;call str_at_display 
1620			 
1620				;call update_display 
1620				;pop af 
1620				;inc a 
1620				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1620 0e 00			ld c, 0 
1622 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1624 1e 28			ld e, 40 
1626			 
1626 21 df f2			ld hl, os_cli_cmd 
1629			 
1629				STACKFRAME OFF $fefe $9f9f 
1629				if DEBUG_STACK_IMB 
1629					if OFF 
1629						exx 
1629						ld de, $fefe 
1629						ld a, d 
1629						ld hl, curframe 
1629						call hexout 
1629						ld a, e 
1629						ld hl, curframe+2 
1629						call hexout 
1629						ld hl, $fefe 
1629						push hl 
1629						ld hl, $9f9f 
1629						push hl 
1629						exx 
1629					endif 
1629				endif 
1629			endm 
# End of macro STACKFRAME
1629			 
1629 cd 3c 0c			call input_str 
162c			 
162c				STACKFRAMECHK OFF $fefe $9f9f 
162c				if DEBUG_STACK_IMB 
162c					if OFF 
162c						exx 
162c						ld hl, $9f9f 
162c						pop de   ; $9f9f 
162c						call cmp16 
162c						jr nz, .spnosame 
162c						ld hl, $fefe 
162c						pop de   ; $fefe 
162c						call cmp16 
162c						jr z, .spfrsame 
162c						.spnosame: call showsperror 
162c						.spfrsame: nop 
162c						exx 
162c					endif 
162c				endif 
162c			endm 
# End of macro STACKFRAMECHK
162c			 
162c				; copy input to last command 
162c			 
162c 21 df f2			ld hl, os_cli_cmd 
162f 11 de f3			ld de, os_last_cmd 
1632 01 ff 00			ld bc, 255 
1635 ed b0			ldir 
1637				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1637			;	call strcpy 
1637			;	ld a, 0 
1637			;	ld (hl), a 
1637			;	inc hl 
1637			;	ld (hl), a 
1637			;	inc hl 
1637			;	ld (hl), a 
1637			 
1637				; switch frame buffer to program  
1637			 
1637 21 02 fb				ld hl, display_fb1 
163a 22 5e fa				ld (display_fb_active), hl 
163d			 
163d			;	nop 
163d				STACKFRAME ON $fbfe $8f9f 
163d				if DEBUG_STACK_IMB 
163d					if ON 
163d						exx 
163d						ld de, $fbfe 
163d						ld a, d 
163d						ld hl, curframe 
163d						call hexout 
163d						ld a, e 
163d						ld hl, curframe+2 
163d						call hexout 
163d						ld hl, $fbfe 
163d						push hl 
163d						ld hl, $8f9f 
163d						push hl 
163d						exx 
163d					endif 
163d				endif 
163d			endm 
# End of macro STACKFRAME
163d				; first time into the parser so pass over the current scratch pad 
163d 21 df f2			ld hl,os_cli_cmd 
1640				; tokenise the entered statement(s) in HL 
1640 cd 9f 1b			call forthparse 
1643			        ; exec forth statements in top of return stack 
1643 cd df 1b			call forthexec 
1646				;call forthexec_cleanup 
1646			;	call parsenext 
1646			 
1646				STACKFRAMECHK ON $fbfe $8f9f 
1646				if DEBUG_STACK_IMB 
1646					if ON 
1646						exx 
1646						ld hl, $8f9f 
1646						pop de   ; $8f9f 
1646						call cmp16 
1646						jr nz, .spnosame 
1646						ld hl, $fbfe 
1646						pop de   ; $fbfe 
1646						call cmp16 
1646						jr z, .spfrsame 
1646						.spnosame: call showsperror 
1646						.spfrsame: nop 
1646						exx 
1646					endif 
1646				endif 
1646			endm 
# End of macro STACKFRAMECHK
1646				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1646			 
1646 3e 3c			ld a, display_row_4 
1648 11 7a 16			ld de, endprog 
164b			 
164b cd d9 0a			call update_display		 
164e			 
164e cd d8 18			call next_page_prompt 
1651			 
1651				; switch frame buffer to cli 
1651			 
1651 21 53 fb				ld hl, display_fb0 
1654 22 5e fa				ld (display_fb_active), hl 
1657			 
1657			 
1657 cd b6 0a		        call clear_display 
165a cd d9 0a			call update_display		 
165d			 
165d 21 df f2			ld hl, os_cli_cmd 
1660			 
1660 3e 00			ld a, 0		 ; init cli input 
1662 77				ld (hl), a 
1663			 
1663				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1663			 
1663				; now on last line 
1663			 
1663				; TODO scroll screen up 
1663			 
1663				; TODO instead just clear screen and place at top of screen 
1663			 
1663			;	ld a, 0 
1663			;	ld (f_cursor_ptr),a 
1663			 
1663				;call clear_display 
1663				;call update_display 
1663			 
1663				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1663 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1665 c3 20 16			jp cli 
1668			 
1668 .. 00		freeram: db "Free bytes: $",0 
1676 ..			asc: db "1A2F" 
167a .. 00		endprog: db "End prog...",0 
1686			 
1686			testenter2:   
1686 21 ea ef			ld hl,scratch+50 
1689 22 db f2			ld (os_cur_ptr),hl 
168c c3 20 16			jp cli 
168f			 
168f			testenter:  
168f			 
168f 21 76 16			ld hl,asc 
1692			;	ld a,(hl) 
1692			;	call nibble2val 
1692 cd 66 0f			call get_byte 
1695			 
1695			 
1695			;	ld a,(hl) 
1695			;	call atohex 
1695			 
1695			;	call fourehexhl 
1695 32 ea ef			ld (scratch+50),a 
1698			 
1698			 
1698			 
1698 21 78 16			ld hl,asc+2 
169b			;	ld a, (hl) 
169b			;	call nibble2val 
169b cd 66 0f			call get_byte 
169e			 
169e			;	call fourehexhl 
169e 32 ec ef			ld (scratch+52),a 
16a1				 
16a1 21 ea ef			ld hl,scratch+50 
16a4 22 db f2			ld (os_cur_ptr),hl 
16a7 c3 20 16			jp cli 
16aa			 
16aa			enter:	 
16aa 3a bc ef			ld a,(scratch+4) 
16ad fe 00			cp 0 
16af 28 0c			jr z, .entercont 
16b1				; no, not a null term line so has an address to work out.... 
16b1			 
16b1 21 ba ef			ld hl,scratch+2 
16b4 cd c6 0f			call get_word_hl 
16b7			 
16b7 22 db f2			ld (os_cur_ptr),hl	 
16ba c3 20 16			jp cli 
16bd			 
16bd			 
16bd			.entercont:  
16bd			 
16bd 21 ba ef			ld hl, scratch+2 
16c0 cd 66 0f			call get_byte 
16c3			 
16c3 2a db f2		   	ld hl,(os_cur_ptr) 
16c6 77					ld (hl),a 
16c7 23					inc hl 
16c8 22 db f2				ld (os_cur_ptr),hl 
16cb				 
16cb			; get byte  
16cb			 
16cb			 
16cb c3 20 16			jp cli 
16ce			 
16ce			 
16ce			; basic monitor support 
16ce			 
16ce			monitor: 
16ce				;  
16ce cd b6 0a			call clear_display 
16d1 3e 00			ld a, 0 
16d3 11 1b 17			ld de, .monprompt 
16d6 cd c9 0a			call str_at_display 
16d9 cd d9 0a			call update_display 
16dc			 
16dc				; get a monitor command 
16dc			 
16dc 0e 00			ld c, 0     ; entry at top left 
16de 16 64			ld d, 100   ; max buffer size 
16e0 1e 0f			ld e, 15    ; input scroll area 
16e2 3e 00			ld a, 0     ; init string 
16e4 21 b6 f1			ld hl, os_input 
16e7 77				ld (hl), a 
16e8 23				inc hl 
16e9 77				ld (hl), a 
16ea 21 b6 f1			ld hl, os_input 
16ed 3e 01			ld a, 1     ; init string 
16ef cd 3c 0c			call input_str 
16f2			 
16f2 cd b6 0a		        call clear_display 
16f5 cd d9 0a			call update_display		 
16f8			 
16f8 3a b6 f1			ld a, (os_input) 
16fb cd 64 10			call toUpper 
16fe fe 48		        cp 'H' 
1700 28 6f		        jr z, .monhelp 
1702 fe 44			cp 'D'		; dump 
1704 ca 92 17			jp z, .mondump	 
1707 fe 43			cp 'C'		; dump 
1709 ca ac 17			jp z, .moncdump	 
170c fe 4d			cp 'M'		; dump 
170e ca 1d 17			jp z, .moneditstart 
1711 fe 55			cp 'U'		; dump 
1713 28 14			jr z, .monedit	 
1715 fe 51			cp 'Q'		; dump 
1717 c8				ret z	 
1718			 
1718			 
1718				; TODO "S" to access symbol by name and not need the address 
1718				; TODO "F" to find a string in memory 
1718			 
1718 c3 ce 16			jp monitor 
171b			 
171b .. 00		.monprompt: db ">", 0 
171d			 
171d			.moneditstart: 
171d				; get starting address 
171d			 
171d 21 b8 f1			ld hl,os_input+2 
1720 cd c6 0f			call get_word_hl 
1723			 
1723 22 db f2			ld (os_cur_ptr),hl	 
1726			 
1726 c3 ce 16			jp monitor 
1729			 
1729			.monedit: 
1729				; get byte to load 
1729			 
1729 21 b8 f1			ld hl,os_input+2 
172c cd 66 0f			call get_byte 
172f			 
172f				; get address to update 
172f 2a db f2			ld hl, (os_cur_ptr) 
1732			 
1732				; update byte 
1732			 
1732 77				ld (hl), a 
1733			 
1733				; move to next address and save it 
1733			 
1733 23				inc hl 
1734 22 db f2			ld (os_cur_ptr),hl	 
1737			 
1737 c3 ce 16			jp monitor 
173a			 
173a			 
173a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
174e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
176a .. 00		.monhelptext3:  db "Q-Quit",0 
1771			        
1771			.monhelp: 
1771 3e 00			ld a, display_row_1 
1773 11 3a 17		        ld de, .monhelptext1 
1776			 
1776 cd c9 0a			call str_at_display 
1779 3e 14			ld a, display_row_2 
177b 11 4e 17		        ld de, .monhelptext2 
177e					 
177e cd c9 0a			call str_at_display 
1781 3e 28			ld a, display_row_3 
1783 11 6a 17		        ld de, .monhelptext3 
1786					 
1786 cd c9 0a			call str_at_display 
1789 cd d9 0a			call update_display		 
178c			 
178c cd d8 18			call next_page_prompt 
178f c3 ce 16			jp monitor 
1792			 
1792			.mondump:    
1792 21 b8 f1			ld hl,os_input+2 
1795 cd c6 0f			call get_word_hl 
1798			 
1798 22 db f2			ld (os_cur_ptr),hl	 
179b cd e0 17			call dumpcont 
179e 3e 3c			ld a, display_row_4 
17a0 11 7a 16			ld de, endprog 
17a3			 
17a3 cd d9 0a			call update_display		 
17a6			 
17a6 cd d8 18			call next_page_prompt 
17a9 c3 ce 16			jp monitor 
17ac			.moncdump: 
17ac cd e0 17			call dumpcont 
17af 3e 3c			ld a, display_row_4 
17b1 11 7a 16			ld de, endprog 
17b4			 
17b4 cd d9 0a			call update_display		 
17b7			 
17b7 cd d8 18			call next_page_prompt 
17ba c3 ce 16			jp monitor 
17bd			 
17bd			 
17bd			; TODO symbol access  
17bd			 
17bd			.symbols:     ;; A list of symbols that can be called up  
17bd 53 fb			dw display_fb0 
17bf .. 00			db "fb0",0  
17c3 e8 f9		     	dw store_page 
17c5 .. 00			db "store_page",0 
17d0			 
17d0			 
17d0			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
17d0			 
17d0 3a b9 ef			ld a,(scratch+1) 
17d3 fe 00			cp 0 
17d5 28 09			jr z, dumpcont 
17d7			 
17d7				; no, not a null term line so has an address to work out.... 
17d7			 
17d7 21 ba ef			ld hl,scratch+2 
17da cd c6 0f			call get_word_hl 
17dd			 
17dd 22 db f2			ld (os_cur_ptr),hl	 
17e0			 
17e0			 
17e0			 
17e0			dumpcont: 
17e0			 
17e0				; dump bytes at ptr 
17e0			 
17e0			 
17e0 3e 00			ld a, display_row_1 
17e2 2a 5e fa			ld hl, (display_fb_active) 
17e5 cd 0f 0c			call addatohl 
17e8 cd 10 18			call .dumpbyterow 
17eb			 
17eb 3e 14			ld a, display_row_2 
17ed 2a 5e fa			ld hl, (display_fb_active) 
17f0 cd 0f 0c			call addatohl 
17f3 cd 10 18			call .dumpbyterow 
17f6			 
17f6			 
17f6 3e 28			ld a, display_row_3 
17f8 2a 5e fa			ld hl, (display_fb_active) 
17fb cd 0f 0c			call addatohl 
17fe cd 10 18			call .dumpbyterow 
1801			 
1801 3e 3c			ld a, display_row_4 
1803 2a 5e fa			ld hl, (display_fb_active) 
1806 cd 0f 0c			call addatohl 
1809 cd 10 18			call .dumpbyterow 
180c			 
180c cd d9 0a			call update_display 
180f			;		jp cli 
180f c9				ret 
1810			 
1810			.dumpbyterow: 
1810			 
1810				;push af 
1810			 
1810 e5				push hl 
1811			 
1811				; calc where to poke the ascii 
1811			if display_cols == 20 
1811 3e 10			ld a, 16 
1813			else 
1813				ld a, 31 
1813			endif 
1813			 
1813 cd 0f 0c			call addatohl 
1816 22 bd f2			ld (os_word_scratch),hl  		; save pos for later 
1819			 
1819			 
1819			; display decoding address 
1819 2a db f2		   	ld hl,(os_cur_ptr) 
181c			 
181c 7c				ld a,h 
181d e1				pop hl 
181e e5				push hl 
181f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
181f cd 10 0f			call hexout 
1822 2a db f2		   	ld hl,(os_cur_ptr) 
1825			 
1825 7d				ld a,l 
1826 e1				pop hl 
1827 23				inc hl 
1828 23				inc hl 
1829 e5				push hl 
182a			;	ld hl, os_word_scratch+2 
182a cd 10 0f			call hexout 
182d e1				pop hl 
182e 23				inc hl 
182f 23				inc hl 
1830				;ld hl, os_word_scratch+4 
1830 3e 3a			ld a, ':' 
1832 77				ld (hl),a 
1833 23				inc hl 
1834				;ld a, 0 
1834				;ld (hl),a 
1834				;ld de, os_word_scratch 
1834				;pop af 
1834				;push af 
1834			;		ld a, display_row_2 
1834			;		call str_at_display 
1834			;		call update_display 
1834			 
1834			 
1834			;pop af 
1834			;	add 5 
1834			 
1834			if display_cols == 20 
1834 06 04			ld b, 4 
1836			else 
1836				ld b, 8 
1836			endif	 
1836			 
1836			.dumpbyte: 
1836 c5				push bc 
1837 e5				push hl 
1838			 
1838			 
1838 2a db f2		   	ld hl,(os_cur_ptr) 
183b 7e					ld a,(hl) 
183c			 
183c					; poke the ascii to display 
183c 2a bd f2				ld hl,(os_word_scratch) 
183f 77					ld (hl),a 
1840 23					inc hl 
1841 22 bd f2				ld (os_word_scratch),hl 
1844			 
1844					 
1844			 
1844			 
1844 e1					pop hl 
1845 e5					push hl 
1846			 
1846 cd 10 0f				call hexout 
1849			 
1849					 
1849 2a db f2		   	ld hl,(os_cur_ptr) 
184c 23				inc hl 
184d 22 db f2		   	ld (os_cur_ptr),hl 
1850			 
1850 e1					pop hl 
1851 23					inc hl 
1852 23					inc hl 
1853 23					inc hl 
1854			 
1854			 
1854			 
1854					;ld a,0 
1854					;ld (os_word_scratch+2),a 
1854					;pop af 
1854					;push af 
1854			 
1854					;ld de, os_word_scratch 
1854					;call str_at_display 
1854			;		call update_display 
1854			;		pop af 
1854 c1					pop bc 
1855 c6 03				add 3 
1857 10 dd			djnz .dumpbyte 
1859			 
1859				 
1859			 
1859 c9				ret 
185a			 
185a			jump:	 
185a			 
185a 21 ba ef			ld hl,scratch+2 
185d cd c6 0f			call get_word_hl 
1860				;ld hl,(scratch+2) 
1860				;call fourehexhl 
1860			 
1860 22 db f2			ld (os_cur_ptr),hl	 
1863			 
1863 e9				jp (hl) 
1864			 
1864			 
1864			 
1864			; TODO implement a basic monitor mode to start with 
1864			 
1864			 
1864			 
1864			 
1864			 
1864			 
1864			 
1864			 
1864			 
1864			; testing and demo code during development 
1864			 
1864			 
1864 .. 00		str1: db "Enter some text...",0 
1877 .. 00		clear: db "                    ",0 
188c			 
188c			demo: 
188c			 
188c			 
188c			 
188c			;	call update_display 
188c			 
188c				; init scratch input area for testing 
188c 21 b8 ef			ld hl, scratch	 
188f 3e 00			ld a,0 
1891 77				ld (hl),a 
1892			 
1892			 
1892 3e 14		            LD   A, display_row_2 
1894			;            CALL fLCD_Pos       ;Position cursor to location in A 
1894 11 64 18		            LD   DE, str1 
1897 cd c9 0a			call str_at_display 
189a			 
189a			;            CALL fLCD_Str       ;Display string pointed to by DE 
189a			cloop:	 
189a 3e 28		            LD   A, display_row_3 
189c			;            CALL fLCD_Pos       ;Position cursor to location in A 
189c 11 77 18		            LD   DE, clear 
189f			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
189f cd c9 0a				call str_at_display 
18a2 3e 3c			ld a, display_row_4 
18a4 11 d4 18			ld de, prompt 
18a7			 
18a7 cd c9 0a				call str_at_display 
18aa cd d9 0a			call update_display 
18ad			 
18ad 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18af 16 0a			ld d, 10 
18b1 21 b8 ef			ld hl, scratch	 
18b4 cd 3c 0c			call input_str 
18b7			 
18b7			;	call clear_display 
18b7			;'	call update_display 
18b7			 
18b7 3e 00		            LD   A, display_row_1 
18b9			;            CALL fLCD_Pos       ;Position cursor to location in A 
18b9 11 77 18		            LD   DE, clear 
18bc cd c9 0a				call str_at_display 
18bf			;            CALL fLCD_Str       ;Display string pointed to by DE 
18bf 3e 00		            LD   A, display_row_1 
18c1			;            CALL fLCD_Pos       ;Position cursor to location in A 
18c1 11 b8 ef		            LD   DE, scratch 
18c4			;            CALL fLCD_Str       ;Display string pointed to by DE 
18c4 cd c9 0a				call str_at_display 
18c7 cd d9 0a			call update_display 
18ca			 
18ca 3e 00				ld a,0 
18cc 21 b8 ef			ld hl, scratch 
18cf 77				ld (hl),a 
18d0			 
18d0 00				nop 
18d1 c3 9a 18			jp cloop 
18d4			 
18d4			 
18d4			 
18d4			; OS Prompt 
18d4			 
18d4 .. 00		prompt: db ">",0 
18d6 .. 00		endprg: db "?",0 
18d8			 
18d8			 
18d8			; handy next page prompt 
18d8			next_page_prompt: 
18d8 e5				push hl 
18d9 d5				push de 
18da f5				push af 
18db c5				push bc 
18dc			 
18dc 3e 4f			ld a,display_row_4 + display_cols - 1 
18de 11 d6 18		        ld de, endprg 
18e1 cd c9 0a			call str_at_display 
18e4 cd d9 0a			call update_display 
18e7 cd f0 62			call cin_wait 
18ea c1				pop bc 
18eb f1				pop af 
18ec d1				pop de 
18ed e1				pop hl 
18ee			 
18ee			 
18ee c9				ret 
18ef			 
18ef			 
18ef			; forth parser 
18ef			 
18ef			; My forth kernel 
18ef			include "forth_kernel.asm" 
18ef			; 
18ef			; kernel to the forth OS 
18ef			 
18ef			DS_TYPE_STR: equ 1     ; string type 
18ef			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
18ef			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
18ef			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
18ef			 
18ef			FORTH_PARSEV1: equ 0 
18ef			FORTH_PARSEV2: equ 0 
18ef			FORTH_PARSEV3: equ 0 
18ef			FORTH_PARSEV4: equ 0 
18ef			FORTH_PARSEV5: equ 1 
18ef			 
18ef			;if FORTH_PARSEV5 
18ef			;	FORTH_END_BUFFER: equ 0 
18ef			;else 
18ef			FORTH_END_BUFFER: equ 127 
18ef			;endif 
18ef			 
18ef			FORTH_TRUE: equ 1 
18ef			FORTH_FALSE: equ 0 
18ef			 
18ef			if FORTH_PARSEV4 
18ef			include "forth_stackops.asm" 
18ef			endif 
18ef			 
18ef			if FORTH_PARSEV5 
18ef			include "forth_stackopsv5.asm" 
18ef			 
18ef			; Stack operations for v5 parser on wards 
18ef			; * DATA stack 
18ef			; * LOOP stack 
18ef			; * RETURN stack 
18ef			 
18ef			 
18ef			 
18ef			FORTH_CHK_DSP_UNDER: macro 
18ef				push hl 
18ef				push de 
18ef				ld hl,(cli_data_sp) 
18ef				ld de, cli_data_stack 
18ef				call cmp16 
18ef				jp c, fault_dsp_under 
18ef				pop de 
18ef				pop hl 
18ef				endm 
18ef			 
18ef			 
18ef			FORTH_CHK_RSP_UNDER: macro 
18ef				push hl 
18ef				push de 
18ef				ld hl,(cli_ret_sp) 
18ef				ld de, cli_ret_stack 
18ef				call cmp16 
18ef				jp c, fault_rsp_under 
18ef				pop de 
18ef				pop hl 
18ef				endm 
18ef			 
18ef			FORTH_CHK_LOOP_UNDER: macro 
18ef				push hl 
18ef				push de 
18ef				ld hl,(cli_loop_sp) 
18ef				ld de, cli_loop_stack 
18ef				call cmp16 
18ef				jp c, fault_loop_under 
18ef				pop de 
18ef				pop hl 
18ef				endm 
18ef			 
18ef			FORTH_ERR_TOS_NOTSTR: macro 
18ef				; TOSO might need more for checks when used 
18ef				push af 
18ef				ld a,(hl) 
18ef				cp DS_TYPE_STR 
18ef				jp nz, type_faultn   
18ef				pop af 
18ef				endm 
18ef			 
18ef			FORTH_ERR_TOS_NOTNUM: macro 
18ef				push af 
18ef				ld a,(hl) 
18ef				cp DS_TYPE_INUM 
18ef				jp nz, type_faultn   
18ef				pop af 
18ef				endm 
18ef			 
18ef			 
18ef			; increase data stack pointer and save hl to it 
18ef				 
18ef			FORTH_DSP_NEXT: macro 
18ef				call macro_forth_dsp_next 
18ef				endm 
18ef			 
18ef			 
18ef			macro_forth_dsp_next: 
18ef				if DEBUG_FORTH_STACK_GUARD 
18ef cd 34 5f				call check_stacks 
18f2				endif 
18f2 e5				push hl 
18f3 d5				push de 
18f4 eb				ex de,hl 
18f5 2a a5 f9			ld hl,(cli_data_sp) 
18f8 23				inc hl 
18f9 23				inc hl 
18fa			 
18fa			; PARSEV5 
18fa 23				inc hl 
18fb 22 a5 f9			ld (cli_data_sp),hl 
18fe 73				ld (hl), e 
18ff 23				inc hl 
1900 72				ld (hl), d 
1901 d1				pop de 
1902 e1				pop hl 
1903				if DEBUG_FORTH_STACK_GUARD 
1903 cd 34 5f				call check_stacks 
1906				endif 
1906 c9				ret 
1907			 
1907			 
1907			; increase ret stack pointer and save hl to it 
1907				 
1907			FORTH_RSP_NEXT: macro 
1907				call macro_forth_rsp_next 
1907				endm 
1907			 
1907			macro_forth_rsp_next: 
1907				if DEBUG_FORTH_STACK_GUARD 
1907 cd 34 5f				call check_stacks 
190a				endif 
190a e5				push hl 
190b d5				push de 
190c eb				ex de,hl 
190d 2a a9 f9			ld hl,(cli_ret_sp) 
1910 23				inc hl 
1911 23				inc hl 
1912 22 a9 f9			ld (cli_ret_sp),hl 
1915 73				ld (hl), e 
1916 23				inc hl 
1917 72				ld (hl), d 
1918 d1				pop de 
1919 e1				pop hl 
191a				if DEBUG_FORTH_STACK_GUARD 
191a cd 34 5f				call check_stacks 
191d				endif 
191d c9				ret 
191e			 
191e			; get current ret stack pointer and save to hl  
191e				 
191e			FORTH_RSP_TOS: macro 
191e				call macro_forth_rsp_tos 
191e				endm 
191e			 
191e			macro_forth_rsp_tos: 
191e				;push de 
191e 2a a9 f9			ld hl,(cli_ret_sp) 
1921 cd 59 19			call loadhlptrtohl 
1924				;ld e, (hl) 
1924				;inc hl 
1924				;ld d, (hl) 
1924				;ex de, hl 
1924					if DEBUG_FORTH_WORDS 
1924			;			DMARK "RST" 
1924						CALLMONITOR 
1924 cd d3 13			call break_point_state  
1927				endm  
# End of macro CALLMONITOR
1927					endif 
1927				;pop de 
1927 c9				ret 
1928			 
1928			; pop ret stack pointer 
1928				 
1928			FORTH_RSP_POP: macro 
1928				call macro_forth_rsp_pop 
1928				endm 
1928			 
1928			 
1928			macro_forth_rsp_pop: 
1928				if DEBUG_FORTH_STACK_GUARD 
1928			;		DMARK "RPP" 
1928 cd 34 5f				call check_stacks 
192b					FORTH_CHK_RSP_UNDER 
192b e5				push hl 
192c d5				push de 
192d 2a a9 f9			ld hl,(cli_ret_sp) 
1930 11 23 f9			ld de, cli_ret_stack 
1933 cd 2d 0c			call cmp16 
1936 da 48 60			jp c, fault_rsp_under 
1939 d1				pop de 
193a e1				pop hl 
193b				endm 
# End of macro FORTH_CHK_RSP_UNDER
193b				endif 
193b e5				push hl 
193c 2a a9 f9			ld hl,(cli_ret_sp) 
193f			 
193f			 
193f				if FORTH_ENABLE_FREE 
193f			 
193f					; get pointer 
193f			 
193f					push de 
193f					push hl 
193f			 
193f					ld e, (hl) 
193f					inc hl 
193f					ld d, (hl) 
193f			 
193f					ex de, hl 
193f					call free 
193f			 
193f					pop hl 
193f					pop de 
193f			 
193f			 
193f				endif 
193f			 
193f			 
193f 2b				dec hl 
1940 2b				dec hl 
1941 22 a9 f9			ld (cli_ret_sp), hl 
1944				; do stack underflow checks 
1944 e1				pop hl 
1945				if DEBUG_FORTH_STACK_GUARD 
1945 cd 34 5f				call check_stacks 
1948					FORTH_CHK_RSP_UNDER 
1948 e5				push hl 
1949 d5				push de 
194a 2a a9 f9			ld hl,(cli_ret_sp) 
194d 11 23 f9			ld de, cli_ret_stack 
1950 cd 2d 0c			call cmp16 
1953 da 48 60			jp c, fault_rsp_under 
1956 d1				pop de 
1957 e1				pop hl 
1958				endm 
# End of macro FORTH_CHK_RSP_UNDER
1958				endif 
1958 c9				ret 
1959			 
1959			 
1959			 
1959			; routine to load word pointed to by hl into hl 
1959			 
1959			loadhlptrtohl: 
1959			 
1959 d5				push de 
195a 5e				ld e, (hl) 
195b 23				inc hl 
195c 56				ld d, (hl) 
195d eb				ex de, hl 
195e d1				pop de 
195f			 
195f c9				ret 
1960			 
1960			 
1960			 
1960			 
1960			 
1960			; push a number held in HL onto the data stack 
1960			; entry point for pushing a value when already in hl used in function above 
1960			 
1960			forth_push_numhl: 
1960			 
1960 e5				push hl    ; save value to push 
1961			 
1961			if DEBUG_FORTH_PUSH 
1961				; see if disabled 
1961			 
1961			 
1961				push af 
1961				ld a, (os_view_disable) 
1961				cp '*' 
1961				jr z, .pskip2 
1961				push hl 
1961			push hl 
1961				call clear_display 
1961			pop hl 
1961				ld a,h 
1961				ld hl, os_word_scratch 
1961				call hexout 
1961				pop hl 
1961				ld a,l 
1961				ld hl, os_word_scratch+2 
1961				call hexout 
1961			 
1961				ld hl, os_word_scratch+4 
1961				ld a,0 
1961				ld (hl),a 
1961				ld de,os_word_scratch 
1961					ld a, display_row_2 
1961					call str_at_display 
1961				ld de, .push_num 
1961				ld a, display_row_1 
1961			 
1961					call str_at_display 
1961			 
1961			 
1961				call update_display 
1961				call delay1s 
1961				call delay1s 
1961			.pskip2:  
1961			 
1961				pop af 
1961			endif	 
1961			 
1961			 
1961				FORTH_DSP_NEXT 
1961 cd ef 18			call macro_forth_dsp_next 
1964				endm 
# End of macro FORTH_DSP_NEXT
1964			 
1964 2a a5 f9			ld hl, (cli_data_sp) 
1967			 
1967				; save item type 
1967 3e 02			ld a,  DS_TYPE_INUM 
1969 77				ld (hl), a 
196a 23				inc hl 
196b			 
196b				; get word off stack 
196b d1				pop de 
196c 7b				ld a,e 
196d 77				ld (hl), a 
196e 23				inc hl 
196f 7a				ld a,d 
1970 77				ld (hl), a 
1971			 
1971			if DEBUG_FORTH_PUSH 
1971				dec hl 
1971				dec hl 
1971				dec hl 
1971						DMARK "PH5" 
1971				CALLMONITOR 
1971			endif	 
1971			 
1971 c9				ret 
1972			 
1972			 
1972			; Push a string to stack pointed to by hl 
1972			 
1972			forth_push_str: 
1972			 
1972			if DEBUG_FORTH_PUSH 
1972						DMARK "PSQ" 
1972				CALLMONITOR 
1972			endif	 
1972			    
1972 e5				push hl 
1973 e5				push hl 
1974			 
1974 3e 00			ld a, 0   ; find end of string 
1976 cd 78 10			call strlent       
1979			if DEBUG_FORTH_PUSH 
1979						DMARK "PQ2" 
1979				CALLMONITOR 
1979			endif	 
1979 eb				ex de, hl 
197a e1				pop hl   ; get ptr to start of string 
197b			if DEBUG_FORTH_PUSH 
197b						DMARK "PQ3" 
197b				CALLMONITOR 
197b			endif	 
197b 19				add hl,de 
197c			if DEBUG_FORTH_PUSH 
197c						DMARK "PQE" 
197c				CALLMONITOR 
197c			endif	 
197c			 
197c 2b				dec hl    ; see if there is an optional trailing double quote 
197d 7e				ld a,(hl) 
197e fe 22			cp '"' 
1980 20 03			jr nz, .strnoq 
1982 3e 00			ld a, 0      ; get rid of double quote 
1984 77				ld (hl), a 
1985 23			.strnoq: inc hl 
1986			 
1986 3e 00			ld a, 0 
1988 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1989			 
1989 13				inc de ; add one for the type string 
198a 13				inc de ; add one for null term??? 
198b			 
198b				; tos is get string pointer again 
198b				; de contains space to allocate 
198b				 
198b d5				push de 
198c			 
198c eb				ex de, hl 
198d			 
198d				;push af 
198d			 
198d			if DEBUG_FORTH_PUSH 
198d						DMARK "PHm" 
198d				CALLMONITOR 
198d			endif	 
198d cd d6 10			call malloc	; on ret hl now contains allocated memory 
1990				if DEBUG_FORTH_MALLOC_GUARD 
1990 cc 9a 4e				call z,malloc_error 
1993				endif 
1993			 
1993				 
1993 c1				pop bc    ; get length 
1994 d1				pop de   ;  get string start    
1995			 
1995				; hl has destination from malloc 
1995			 
1995 eb				ex de, hl    ; prep for ldir 
1996			 
1996 e5				push hl   ; save malloc area for DSP later 
1997			 
1997			if DEBUG_FORTH_PUSH 
1997						DMARK "PHc" 
1997				CALLMONITOR 
1997			endif	 
1997			 
1997			 
1997 ed b0			ldir 
1999			 
1999			 
1999				; push malloc to data stack     macro?????  
1999			 
1999				FORTH_DSP_NEXT 
1999 cd ef 18			call macro_forth_dsp_next 
199c				endm 
# End of macro FORTH_DSP_NEXT
199c			 
199c				; save value and type 
199c			 
199c 2a a5 f9			ld hl, (cli_data_sp) 
199f			 
199f				; save item type 
199f 3e 01			ld a,  DS_TYPE_STR 
19a1 77				ld (hl), a 
19a2 23				inc hl 
19a3			 
19a3				; get malloc word off stack 
19a3 d1				pop de 
19a4 73				ld (hl), e 
19a5 23				inc hl 
19a6 72				ld (hl), d 
19a7			 
19a7			 
19a7			 
19a7			if DEBUG_FORTH_PUSH 
19a7				ld hl, (cli_data_sp) 
19a7						DMARK "PHS" 
19a7				CALLMONITOR 
19a7			;	ex de,hl 
19a7			endif	 
19a7				; in case of spaces, skip the ptr past the copied string 
19a7				;pop af 
19a7				;ld (cli_origptr),hl 
19a7			 
19a7 c9				ret 
19a8			 
19a8			 
19a8			 
19a8			; TODO ascii push input onto stack given hl to start of input 
19a8			 
19a8			; identify type 
19a8			; if starts with a " then a string 
19a8			; otherwise it is a number 
19a8			;  
19a8			; if a string 
19a8			;     scan for ending " to get length of string to malloc for + 1 
19a8			;     malloc 
19a8			;     put pointer to string on stack first byte flags as string 
19a8			; 
19a8			; else a number 
19a8			;    look for number format identifier 
19a8			;    $xx hex 
19a8			;    %xxxxx bin 
19a8			;    xxxxx decimal 
19a8			;    convert number to 16bit word.  
19a8			;    malloc word + 1 with flag to identiy as num 
19a8			;    put pointer to number on stack 
19a8			;   
19a8			;  
19a8			  
19a8			forth_apush: 
19a8				; kernel push 
19a8			 
19a8			if DEBUG_FORTH_PUSH 
19a8						DMARK "PSH" 
19a8				CALLMONITOR 
19a8			endif	 
19a8				; identify input type 
19a8			 
19a8 7e				ld a,(hl) 
19a9 fe 22			cp '"' 
19ab 28 0a			jr z, .fapstr 
19ad fe 24			cp '$' 
19af ca d7 19			jp z, .faphex 
19b2 fe 25			cp '%' 
19b4 ca bf 19			jp z, .fapbin 
19b7			;	cp 'b' 
19b7			;	jp z, .fabin 
19b7				; else decimal 
19b7			 
19b7				; TODO do decimal conversion 
19b7				; decimal is stored as a 16bit word 
19b7			 
19b7				; by default everything is a string if type is not detected 
19b7			.fapstr: ; 
19b7 fe 22			cp '"' 
19b9 20 01			jr nz, .strnoqu 
19bb 23				inc hl 
19bc			.strnoqu: 
19bc c3 72 19			jp forth_push_str 
19bf			 
19bf			 
19bf			 
19bf			.fapbin:    ; push a binary string.  
19bf 11 00 00			ld de, 0   ; hold a 16bit value 
19c2			 
19c2 23			.fapbinshift:	inc hl  
19c3 7e				ld a,(hl) 
19c4 fe 00			cp 0     ; done scanning  
19c6 28 0b			jr z, .fapbdone  	; got it in HL so push  
19c8			 
19c8				; left shift de 
19c8 eb				ex de, hl	 
19c9 29				add hl, hl 
19ca			 
19ca				; is 1 
19ca fe 31			cp '1' 
19cc 20 02			jr nz, .binzero 
19ce cb 4d			bit 1, l 
19d0			.binzero: 
19d0 eb				ex de, hl	 ; save current de 
19d1 18 ef			jr .fapbinshift 
19d3			 
19d3			.fapbdone: 
19d3 eb				ex de, hl 
19d4 c3 60 19			jp forth_push_numhl 
19d7			 
19d7			 
19d7			.faphex:   ; hex is always stored as a 16bit word 
19d7				; skip number prefix 
19d7 23				inc hl 
19d8				; turn ascii into number 
19d8 cd c6 0f			call get_word_hl	; ret 16bit word in hl 
19db			 
19db c3 60 19			jp forth_push_numhl 
19de			 
19de 00				 nop 
19df			 
19df			.fabin:   ; TODO bin conversion 
19df			 
19df			 
19df c9				ret 
19e0			 
19e0			 
19e0			; get either a string ptr or a 16bit word from the data stack 
19e0			 
19e0			FORTH_DSP: macro 
19e0				call macro_forth_dsp 
19e0				endm 
19e0			 
19e0			macro_forth_dsp: 
19e0				; data stack pointer points to current word on tos 
19e0			 
19e0 2a a5 f9			ld hl,(cli_data_sp) 
19e3			 
19e3				if DEBUG_FORTH_PUSH 
19e3						DMARK "DSP" 
19e3			 
19e3					call display_data_sp 
19e3				;call break_point_state 
19e3				;rst 030h 
19e3				CALLMONITOR 
19e3				endif 
19e3			 
19e3 c9				ret 
19e4			 
19e4			; return hl to start of value on stack 
19e4			 
19e4			FORTH_DSP_VALUE: macro 
19e4				call macro_forth_dsp_value 
19e4				endm 
19e4			 
19e4			macro_forth_dsp_value: 
19e4			 
19e4				FORTH_DSP 
19e4 cd e0 19			call macro_forth_dsp 
19e7				endm 
# End of macro FORTH_DSP
19e7			 
19e7 d5				push de 
19e8			 
19e8 23				inc hl ; skip type 
19e9			 
19e9 5e				ld e, (hl) 
19ea 23				inc hl 
19eb 56				ld d, (hl) 
19ec eb				ex de,hl  
19ed			 
19ed d1				pop de 
19ee			 
19ee c9				ret 
19ef			 
19ef			; return hl to start of value to second item on stack 
19ef			 
19ef			FORTH_DSP_VALUEM1: macro 
19ef				call macro_forth_dsp_value_m1 
19ef				endm 
19ef			 
19ef			macro_forth_dsp_value_m1: 
19ef			 
19ef				FORTH_DSP 
19ef cd e0 19			call macro_forth_dsp 
19f2				endm 
# End of macro FORTH_DSP
19f2			 
19f2 2b				dec hl 
19f3 2b				dec hl 
19f4			;	dec hl 
19f4			 
19f4 d5				push de 
19f5			 
19f5 5e				ld e, (hl) 
19f6 23				inc hl 
19f7 56				ld d, (hl) 
19f8 eb				ex de,hl  
19f9			 
19f9 d1				pop de 
19fa			 
19fa c9				ret 
19fb			 
19fb				 
19fb			 
19fb			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
19fb			 
19fb			FORTH_DSP_POP: macro 
19fb				call macro_forth_dsp_pop 
19fb				endm 
19fb			 
19fb			 
19fb			; get the tos data type 
19fb			 
19fb			FORTH_DSP_TYPE:   macro 
19fb			 
19fb				;FORTH_DSP_VALUE 
19fb				FORTH_DSP 
19fb				 
19fb				; hl points to value 
19fb				; check type 
19fb			 
19fb				ld a,(hl) 
19fb			 
19fb				endm 
19fb			 
19fb			; load the tos value into hl 
19fb			 
19fb			 
19fb			FORTH_DSP_VALUEHL:  macro 
19fb				call macro_dsp_valuehl 
19fb				endm 
19fb			 
19fb			 
19fb			 
19fb			macro_dsp_valuehl: 
19fb				FORTH_DSP_VALUE 
19fb cd e4 19			call macro_forth_dsp_value 
19fe				endm 
# End of macro FORTH_DSP_VALUE
19fe			 
19fe				;FORTH_ERR_TOS_NOTNUM 
19fe			 
19fe				;inc hl   ; skip type id 
19fe			 
19fe			;	push de 
19fe			; 
19fe			;	ld e, (hl) 
19fe			;	inc hl 
19fe			;	ld d, (hl) 
19fe			;	ex de,hl  
19fe			 
19fe			;	pop de 
19fe			 
19fe				if DEBUG_FORTH_PUSH 
19fe						DMARK "DVL" 
19fe				CALLMONITOR 
19fe				endif 
19fe c9				ret 
19ff			 
19ff			forth_apushstrhl:      
19ff				; push of string requires use of cli_origptr 
19ff				; bodge use 
19ff			 
19ff				; get current cli_origptr, save, update with temp pointer  
19ff ed 5b c1 f9		ld de, (cli_origptr) 
1a03 22 c1 f9			ld (cli_origptr), hl 
1a06 d5				push de 
1a07 cd a8 19			call forth_apush 
1a0a d1				pop de 
1a0b ed 53 c1 f9		ld (cli_origptr), de 
1a0f c9			        ret	 
1a10			 
1a10			 
1a10			; increase loop stack pointer and save hl to it 
1a10				 
1a10			FORTH_LOOP_NEXT: macro 
1a10				call macro_forth_loop_next 
1a10				;nop 
1a10				endm 
1a10			 
1a10			macro_forth_loop_next: 
1a10				if DEBUG_FORTH_STACK_GUARD 
1a10 cd 34 5f				call check_stacks 
1a13				endif 
1a13 e5				push hl 
1a14 d5				push de 
1a15 eb				ex de,hl 
1a16 2a a7 f9			ld hl,(cli_loop_sp) 
1a19 23				inc hl 
1a1a 23				inc hl 
1a1b					if DEBUG_FORTH_WORDS 
1a1b						DMARK "LNX" 
1a1b f5				push af  
1a1c 3a 30 1a			ld a, (.dmark)  
1a1f 32 bd fb			ld (debug_mark),a  
1a22 3a 31 1a			ld a, (.dmark+1)  
1a25 32 be fb			ld (debug_mark+1),a  
1a28 3a 32 1a			ld a, (.dmark+2)  
1a2b 32 bf fb			ld (debug_mark+2),a  
1a2e 18 03			jr .pastdmark  
1a30 ..			.dmark: db "LNX"  
1a33 f1			.pastdmark: pop af  
1a34			endm  
# End of macro DMARK
1a34						CALLMONITOR 
1a34 cd d3 13			call break_point_state  
1a37				endm  
# End of macro CALLMONITOR
1a37					endif 
1a37 22 a7 f9			ld (cli_loop_sp),hl 
1a3a 73				ld (hl), e 
1a3b 23				inc hl 
1a3c 72				ld (hl), d 
1a3d d1				pop de    ; been reversed so save a swap on restore 
1a3e e1				pop hl 
1a3f				if DEBUG_FORTH_STACK_GUARD 
1a3f cd 34 5f				call check_stacks 
1a42				endif 
1a42 c9				ret 
1a43			 
1a43			; get current ret stack pointer and save to hl  
1a43				 
1a43			FORTH_LOOP_TOS: macro 
1a43				call macro_forth_loop_tos 
1a43				endm 
1a43			 
1a43			macro_forth_loop_tos: 
1a43 d5				push de 
1a44 2a a7 f9			ld hl,(cli_loop_sp) 
1a47 5e				ld e, (hl) 
1a48 23				inc hl 
1a49 56				ld d, (hl) 
1a4a eb				ex de, hl 
1a4b d1				pop de 
1a4c c9				ret 
1a4d			 
1a4d			; pop loop stack pointer 
1a4d				 
1a4d			FORTH_LOOP_POP: macro 
1a4d				call macro_forth_loop_pop 
1a4d				endm 
1a4d			 
1a4d			 
1a4d			macro_forth_loop_pop: 
1a4d				if DEBUG_FORTH_STACK_GUARD 
1a4d					DMARK "LPP" 
1a4d f5				push af  
1a4e 3a 62 1a			ld a, (.dmark)  
1a51 32 bd fb			ld (debug_mark),a  
1a54 3a 63 1a			ld a, (.dmark+1)  
1a57 32 be fb			ld (debug_mark+1),a  
1a5a 3a 64 1a			ld a, (.dmark+2)  
1a5d 32 bf fb			ld (debug_mark+2),a  
1a60 18 03			jr .pastdmark  
1a62 ..			.dmark: db "LPP"  
1a65 f1			.pastdmark: pop af  
1a66			endm  
# End of macro DMARK
1a66 cd 34 5f				call check_stacks 
1a69					FORTH_CHK_LOOP_UNDER 
1a69 e5				push hl 
1a6a d5				push de 
1a6b 2a a7 f9			ld hl,(cli_loop_sp) 
1a6e 11 21 f7			ld de, cli_loop_stack 
1a71 cd 2d 0c			call cmp16 
1a74 da 4e 60			jp c, fault_loop_under 
1a77 d1				pop de 
1a78 e1				pop hl 
1a79				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1a79				endif 
1a79 e5				push hl 
1a7a 2a a7 f9			ld hl,(cli_loop_sp) 
1a7d 2b				dec hl 
1a7e 2b				dec hl 
1a7f 22 a7 f9			ld (cli_loop_sp), hl 
1a82				; TODO do stack underflow checks 
1a82 e1				pop hl 
1a83				if DEBUG_FORTH_STACK_GUARD 
1a83 cd 34 5f				call check_stacks 
1a86					FORTH_CHK_LOOP_UNDER 
1a86 e5				push hl 
1a87 d5				push de 
1a88 2a a7 f9			ld hl,(cli_loop_sp) 
1a8b 11 21 f7			ld de, cli_loop_stack 
1a8e cd 2d 0c			call cmp16 
1a91 da 4e 60			jp c, fault_loop_under 
1a94 d1				pop de 
1a95 e1				pop hl 
1a96				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1a96				endif 
1a96 c9				ret 
1a97			 
1a97			macro_forth_dsp_pop: 
1a97			 
1a97 e5				push hl 
1a98			 
1a98				; release malloc data 
1a98			 
1a98				if DEBUG_FORTH_STACK_GUARD 
1a98 cd 34 5f				call check_stacks 
1a9b					FORTH_CHK_DSP_UNDER 
1a9b e5				push hl 
1a9c d5				push de 
1a9d 2a a5 f9			ld hl,(cli_data_sp) 
1aa0 11 1f f5			ld de, cli_data_stack 
1aa3 cd 2d 0c			call cmp16 
1aa6 da 42 60			jp c, fault_dsp_under 
1aa9 d1				pop de 
1aaa e1				pop hl 
1aab				endm 
# End of macro FORTH_CHK_DSP_UNDER
1aab				endif 
1aab				;ld hl,(cli_data_sp) 
1aab			if DEBUG_FORTH_DOT 
1aab				DMARK "DPP" 
1aab				CALLMONITOR 
1aab			endif	 
1aab			 
1aab			 
1aab			if FORTH_ENABLE_DSPPOPFREE 
1aab			 
1aab				FORTH_DSP 
1aab cd e0 19			call macro_forth_dsp 
1aae				endm 
# End of macro FORTH_DSP
1aae			 
1aae 7e				ld a, (hl) 
1aaf fe 01			cp DS_TYPE_STR 
1ab1 20 07			jr nz, .skippopfree 
1ab3			 
1ab3				FORTH_DSP_VALUEHL 
1ab3 cd fb 19			call macro_dsp_valuehl 
1ab6				endm 
# End of macro FORTH_DSP_VALUEHL
1ab6 00				nop 
1ab7			if DEBUG_FORTH_DOT 
1ab7				DMARK "DPf" 
1ab7				CALLMONITOR 
1ab7			endif	 
1ab7 cd a0 11			call free 
1aba			.skippopfree: 
1aba				 
1aba			 
1aba			endif 
1aba			 
1aba			if DEBUG_FORTH_DOT_KEY 
1aba				DMARK "DP2" 
1aba				CALLMONITOR 
1aba			endif	 
1aba			 
1aba				; move pointer down 
1aba			 
1aba 2a a5 f9			ld hl,(cli_data_sp) 
1abd 2b				dec hl 
1abe 2b				dec hl 
1abf			; PARSEV5 
1abf 2b				dec hl 
1ac0 22 a5 f9			ld (cli_data_sp), hl 
1ac3			 
1ac3				if DEBUG_FORTH_STACK_GUARD 
1ac3 cd 34 5f				call check_stacks 
1ac6					FORTH_CHK_DSP_UNDER 
1ac6 e5				push hl 
1ac7 d5				push de 
1ac8 2a a5 f9			ld hl,(cli_data_sp) 
1acb 11 1f f5			ld de, cli_data_stack 
1ace cd 2d 0c			call cmp16 
1ad1 da 42 60			jp c, fault_dsp_under 
1ad4 d1				pop de 
1ad5 e1				pop hl 
1ad6				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ad6				endif 
1ad6			 
1ad6 e1				pop hl 
1ad7			 
1ad7 c9				ret 
1ad8			 
1ad8			getwordathl: 
1ad8				; hl points to an address 
1ad8				; load hl with the word at that address 
1ad8			 
1ad8 d5				push de 
1ad9			 
1ad9 5e				ld e, (hl) 
1ada 23				inc hl 
1adb 56				ld d, (hl) 
1adc eb				ex de, hl 
1add			 
1add d1				pop de 
1ade c9				ret 
1adf			 
1adf			 
1adf			 
1adf			 
1adf			 
1adf			; eof 
1adf			 
# End of file forth_stackopsv5.asm
1adf			endif 
1adf			 
1adf			user_word_eol:  
1adf				; hl contains the pointer to where to create a linked list item from the end 
1adf				; of the user dict to continue on at the system word dict 
1adf				 
1adf				; poke the stub of the word list linked list to repoint to rom words 
1adf			 
1adf				; stub format 
1adf				; db   word id 
1adf				; dw    link to next word 
1adf			        ; db char length of token 
1adf				; db string + 0 term 
1adf				; db exec code....  
1adf			 
1adf 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ae1 77				ld (hl), a		; word id 
1ae2 23				inc hl 
1ae3			 
1ae3 11 a9 1c			ld de, sysdict 
1ae6 73				ld (hl), e		; next word link ie system dict 
1ae7 23				inc hl 
1ae8 72				ld (hl), d		; next word link ie system dict 
1ae9 23				inc hl	 
1aea			 
1aea			;	ld (hl), sysdict		; next word link ie system dict 
1aea			;	inc hl 
1aea			;	inc hl 
1aea			 
1aea			;	inc hl 
1aea			;	inc hl 
1aea			 
1aea 3e 02			ld a, 2			; word length is 0 
1aec 77				ld (hl), a	 
1aed 23				inc hl 
1aee			 
1aee 3e 7e			ld a, '~'			; word length is 0 
1af0 77				ld (hl), a	 
1af1 23				inc hl 
1af2 3e 00			ld a, 0			; save empty word 
1af4 77				ld (hl), a 
1af5			 
1af5 c9				ret 
1af6			 
1af6				 
1af6			 
1af6			forthexec_cleanup: 
1af6				FORTH_RSP_POP 
1af6 cd 28 19			call macro_forth_rsp_pop 
1af9				endm 
# End of macro FORTH_RSP_POP
1af9 c9				ret 
1afa			 
1afa			forth_call_hl: 
1afa				; taking hl 
1afa e5				push hl 
1afb c9				ret 
1afc			 
1afc			; this is called to reset Forth system but keep existing uwords etc 
1afc			 
1afc			forth_warmstart: 
1afc				; setup stack over/under flow checks 
1afc				if DEBUG_FORTH_STACK_GUARD 
1afc cd 1a 5f				call chk_stk_init 
1aff				endif 
1aff			 
1aff				; init stack pointers  - * these stacks go upwards *  
1aff 21 23 f9			ld hl, cli_ret_stack 
1b02 22 a9 f9			ld (cli_ret_sp), hl	 
1b05				; set bottom of stack 
1b05 3e 00			ld a,0 
1b07 77				ld (hl),a 
1b08 23				inc hl 
1b09 77				ld (hl),a 
1b0a			 
1b0a 21 1f f5			ld hl, cli_data_stack 
1b0d 22 a5 f9			ld (cli_data_sp), hl	 
1b10				; set bottom of stack 
1b10 3e 00			ld a,0 
1b12 77				ld (hl),a 
1b13 23				inc hl 
1b14 77				ld (hl),a 
1b15			 
1b15 21 21 f7			ld hl, cli_loop_stack 
1b18 22 a7 f9			ld (cli_loop_sp), hl	 
1b1b				; set bottom of stack 
1b1b 3e 00			ld a,0 
1b1d 77				ld (hl),a 
1b1e 23				inc hl 
1b1f 77				ld (hl),a 
1b20			 
1b20				; init extent of current open file 
1b20			 
1b20 3e 00			ld a, 0 
1b22 32 df f9			ld (store_openext), a 
1b25			 
1b25 c9				ret 
1b26			 
1b26			 
1b26			; Cold Start - this is called to setup the whole Forth system 
1b26			 
1b26			forth_init: 
1b26			 
1b26				; setup stack over/under flow checks 
1b26			 
1b26			;	if DEBUG_FORTH_STACK_GUARD 
1b26			;		call chk_stk_init 
1b26			;	endif 
1b26			 
1b26				; enable auto display updates (slow.....) 
1b26			 
1b26 3e 01			ld a, 1 
1b28 32 bf f9			ld (cli_autodisplay), a 
1b2b			 
1b2b			 
1b2b			 
1b2b				; show start up screen 
1b2b			 
1b2b cd b6 0a			call clear_display 
1b2e			 
1b2e 3e 00			ld a,0 
1b30 32 e1 f9			ld (f_cursor_ptr), a 
1b33			 
1b33				; set start of word list in start of ram - for use when creating user words 
1b33			 
1b33 21 00 80			ld hl, baseram 
1b36 22 b5 f2			ld (os_last_new_uword), hl 
1b39 cd df 1a			call user_word_eol 
1b3c				 
1b3c			;		call display_data_sp 
1b3c			;		call next_page_prompt 
1b3c			 
1b3c			 
1b3c			 
1b3c			 
1b3c c9				ret 
1b3d			 
1b3d .. 00		.bootforth: db " Forth Kernel Init ",0 
1b51			 
1b51			; TODO push to stack 
1b51			 
1b51			;  
1b51			 
1b51			if FORTH_PARSEV2 
1b51			 
1b51			 
1b51				include "forth_parserv2.asm" 
1b51			 
1b51			endif 
1b51			 
1b51			 
1b51			; parse cli version 1 
1b51			 
1b51			if FORTH_PARSEV1 
1b51			 
1b51			 
1b51			 
1b51			      include "forth_parserv1.asm" 
1b51			endif 
1b51				 
1b51			if FORTH_PARSEV3 
1b51			 
1b51			 
1b51			 
1b51			      include "forth_parserv3.asm" 
1b51				include "forth_wordsv3.asm" 
1b51			endif 
1b51			 
1b51			if FORTH_PARSEV4 
1b51			 
1b51			 
1b51			 
1b51			      include "forth_parserv4.asm" 
1b51				include "forth_wordsv4.asm" 
1b51			endif 
1b51			 
1b51			if FORTH_PARSEV5 
1b51			 
1b51			 
1b51			 
1b51			      include "forth_parserv5.asm" 
1b51			 
1b51			 
1b51			; A better parser without using malloc and string copies all over the place.  
1b51			; Exec in situ should be faster 
1b51			 
1b51			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1b51			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1b51			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1b51			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1b51			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1b51			WORD_SYS_END: equ 0   ; Opcode for all user words 
1b51			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1b51			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1b51			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1b51			 
1b51			; Core word preamble macro 
1b51			 
1b51			CWHEAD:   macro nxtword opcode lit len opflags 
1b51				db WORD_SYS_CORE+opcode             
1b51				; internal op code number 
1b51				dw nxtword            
1b51				; link to next dict word block 
1b51				db len + 1 
1b51				; literal length of dict word inc zero term 
1b51				db lit,0              
1b51				; literal dict word 
1b51			        ; TODO db opflags        
1b51				endm 
1b51			 
1b51			 
1b51			NEXTW: macro  
1b51				jp macro_next 
1b51				endm 
1b51			 
1b51			macro_next: 
1b51			if DEBUG_FORTH_PARSE_KEY 
1b51				DMARK "NXT" 
1b51				CALLMONITOR 
1b51			endif	 
1b51			;	inc hl  ; skip token null term  
1b51 ed 4b c3 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1b55 ed 5b c1 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1b59 2a b9 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1b5c			if DEBUG_FORTH_PARSE_KEY 
1b5c				DMARK "}AA" 
1b5c				CALLMONITOR 
1b5c			endif	 
1b5c c3 5f 1c			jp execnext 
1b5f				;jp exec1 
1b5f			       
1b5f			 
1b5f			 
1b5f			; Another go at the parser to compile  
1b5f			 
1b5f			 
1b5f			; TODO rework parser to change all of the string words to byte tokens 
1b5f			; TODO do a search for  
1b5f			 
1b5f			; TODO first run normal parser to zero term sections 
1b5f			; TODO for each word do a token look up to get the op code 
1b5f			; TODO need some means to flag to the exec that this is a byte code form    
1b5f			 
1b5f			 
1b5f			forthcompile: 
1b5f			 
1b5f			; 
1b5f			; line parse: 
1b5f			;       parse raw input buffer 
1b5f			;       tokenise the words 
1b5f			;       malloc new copy (for looping etc) 
1b5f			;       copy to malloc + current pc in line to start of string and add line term 
1b5f			;       save on new rsp 
1b5f			; 
1b5f			 
1b5f			; hl to point to the line to tokenise 
1b5f			 
1b5f			;	push hl 
1b5f 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1b62			 
1b62			;	ld a,0		; string term on input 
1b62			;	call strlent 
1b62			 
1b62			;	ld (os_tok_len), hl	 ; save string length 
1b62			 
1b62			;if DEBUG_FORTH_TOK 
1b62			;	ex de,hl		 
1b62			;endif 
1b62			 
1b62			;	pop hl 		; get back string pointer 
1b62			 
1b62			if DEBUG_FORTH_TOK 
1b62						DMARK "TOc" 
1b62				CALLMONITOR 
1b62			endif 
1b62 7e			.cptoken2:    ld a,(hl) 
1b63 23				inc hl 
1b64 fe 7f			cp FORTH_END_BUFFER 
1b66 28 29			jr z, .cptokendone2 
1b68 fe 00			cp 0 
1b6a 28 25			jr z, .cptokendone2 
1b6c fe 22			cp '"' 
1b6e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1b70 fe 20			cp ' ' 
1b72 20 ee			jr nz,  .cptoken2 
1b74			 
1b74			; TODO consume comments held between ( and ) 
1b74			 
1b74				; we have a space so change to zero term for dict match later 
1b74 2b				dec hl 
1b75 3e 00			ld a,0 
1b77 77				ld (hl), a 
1b78 23				inc hl 
1b79 18 e7			jr .cptoken2 
1b7b				 
1b7b			 
1b7b			.cptokenstr2: 
1b7b				; skip all white space until either eol (because forgot to term) or end double quote 
1b7b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1b7b				;inc hl ; skip current double quote 
1b7b 7e				ld a,(hl) 
1b7c 23				inc hl 
1b7d fe 22			cp '"' 
1b7f 28 e1			jr z, .cptoken2 
1b81 fe 7f			cp FORTH_END_BUFFER 
1b83 28 0c			jr z, .cptokendone2 
1b85 fe 00			cp 0 
1b87 28 08			jr z, .cptokendone2 
1b89 fe 20			cp ' ' 
1b8b 28 02			jr z, .cptmp2 
1b8d 18 ec			jr .cptokenstr2 
1b8f			 
1b8f			.cptmp2:	; we have a space so change to zero term for dict match later 
1b8f				;dec hl 
1b8f				;ld a,"-"	; TODO remove this when working 
1b8f				;ld (hl), a 
1b8f				;inc hl 
1b8f 18 ea			jr .cptokenstr2 
1b91			 
1b91			.cptokendone2: 
1b91				;inc hl 
1b91 3e 7f			ld a, FORTH_END_BUFFER 
1b93 77				ld (hl),a 
1b94 23				inc hl 
1b95 3e 21			ld a, '!' 
1b97 77				ld (hl),a 
1b98			 
1b98 2a b9 f2			ld hl,(os_tok_ptr) 
1b9b			         
1b9b			if DEBUG_FORTH_TOK 
1b9b						DMARK "Tc1" 
1b9b				CALLMONITOR 
1b9b			endif 
1b9b			 
1b9b				; push exec string to top of return stack 
1b9b				FORTH_RSP_NEXT 
1b9b cd 07 19			call macro_forth_rsp_next 
1b9e				endm 
# End of macro FORTH_RSP_NEXT
1b9e c9				ret 
1b9f			 
1b9f			; Another go at the parser need to simplify the process 
1b9f			 
1b9f			forthparse: 
1b9f			 
1b9f			; 
1b9f			; line parse: 
1b9f			;       parse raw input buffer 
1b9f			;       tokenise the words 
1b9f			;       malloc new copy (for looping etc) 
1b9f			;       copy to malloc + current pc in line to start of string and add line term 
1b9f			;       save on new rsp 
1b9f			; 
1b9f			 
1b9f			; hl to point to the line to tokenise 
1b9f			 
1b9f			;	push hl 
1b9f 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1ba2			 
1ba2			;	ld a,0		; string term on input 
1ba2			;	call strlent 
1ba2			 
1ba2			;	ld (os_tok_len), hl	 ; save string length 
1ba2			 
1ba2			;if DEBUG_FORTH_TOK 
1ba2			;	ex de,hl		 
1ba2			;endif 
1ba2			 
1ba2			;	pop hl 		; get back string pointer 
1ba2			 
1ba2			if DEBUG_FORTH_TOK 
1ba2						DMARK "TOK" 
1ba2				CALLMONITOR 
1ba2			endif 
1ba2 7e			.ptoken2:    ld a,(hl) 
1ba3 23				inc hl 
1ba4 fe 7f			cp FORTH_END_BUFFER 
1ba6 28 29			jr z, .ptokendone2 
1ba8 fe 00			cp 0 
1baa 28 25			jr z, .ptokendone2 
1bac fe 22			cp '"' 
1bae 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1bb0 fe 20			cp ' ' 
1bb2 20 ee			jr nz,  .ptoken2 
1bb4			 
1bb4			; TODO consume comments held between ( and ) 
1bb4			 
1bb4				; we have a space so change to zero term for dict match later 
1bb4 2b				dec hl 
1bb5 3e 00			ld a,0 
1bb7 77				ld (hl), a 
1bb8 23				inc hl 
1bb9 18 e7			jr .ptoken2 
1bbb				 
1bbb			 
1bbb			.ptokenstr2: 
1bbb				; skip all white space until either eol (because forgot to term) or end double quote 
1bbb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1bbb				;inc hl ; skip current double quote 
1bbb 7e				ld a,(hl) 
1bbc 23				inc hl 
1bbd fe 22			cp '"' 
1bbf 28 e1			jr z, .ptoken2 
1bc1 fe 7f			cp FORTH_END_BUFFER 
1bc3 28 0c			jr z, .ptokendone2 
1bc5 fe 00			cp 0 
1bc7 28 08			jr z, .ptokendone2 
1bc9 fe 20			cp ' ' 
1bcb 28 02			jr z, .ptmp2 
1bcd 18 ec			jr .ptokenstr2 
1bcf			 
1bcf			.ptmp2:	; we have a space so change to zero term for dict match later 
1bcf				;dec hl 
1bcf				;ld a,"-"	; TODO remove this when working 
1bcf				;ld (hl), a 
1bcf				;inc hl 
1bcf 18 ea			jr .ptokenstr2 
1bd1			 
1bd1			.ptokendone2: 
1bd1				;inc hl 
1bd1 3e 7f			ld a, FORTH_END_BUFFER 
1bd3 77				ld (hl),a 
1bd4 23				inc hl 
1bd5 3e 21			ld a, '!' 
1bd7 77				ld (hl),a 
1bd8			 
1bd8 2a b9 f2			ld hl,(os_tok_ptr) 
1bdb			         
1bdb			if DEBUG_FORTH_TOK 
1bdb						DMARK "TK1" 
1bdb				CALLMONITOR 
1bdb			endif 
1bdb			 
1bdb				; push exec string to top of return stack 
1bdb				FORTH_RSP_NEXT 
1bdb cd 07 19			call macro_forth_rsp_next 
1bde				endm 
# End of macro FORTH_RSP_NEXT
1bde c9				ret 
1bdf			 
1bdf			; 
1bdf			;	; malloc size + buffer pointer + if is loop flag 
1bdf			;	ld hl,(os_tok_len) 		 ; get string length 
1bdf			; 
1bdf			;	ld a,l 
1bdf			; 
1bdf			;	cp 0			; we dont want to use a null string 
1bdf			;	ret z 
1bdf			; 
1bdf			;;	add 3    ; prefix malloc with buffer for current word ptr 
1bdf			; 
1bdf			;	add 5     ; TODO when certain not over writing memory remove 
1bdf			; 
1bdf			;		 
1bdf			; 
1bdf			;if DEBUG_FORTH_TOK 
1bdf			;			DMARK "TKE" 
1bdf			;	CALLMONITOR 
1bdf			;endif 
1bdf			; 
1bdf			;	ld l,a 
1bdf			;	ld h,0 
1bdf			;;	push hl   ; save required space for the copy later 
1bdf			;	call malloc 
1bdf			;if DEBUG_FORTH_TOK 
1bdf			;			DMARK "TKM" 
1bdf			;	CALLMONITOR 
1bdf			;endif 
1bdf			;	if DEBUG_FORTH_MALLOC_GUARD 
1bdf			;		push af 
1bdf			;		call ishlzero 
1bdf			;;		ld a, l 
1bdf			;;		add h 
1bdf			;;		cp 0 
1bdf			;		pop af 
1bdf			;		 
1bdf			;		call z,malloc_error 
1bdf			;	endif 
1bdf			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1bdf			; 
1bdf			; 
1bdf			;if DEBUG_FORTH_TOK 
1bdf			;			DMARK "TKR" 
1bdf			;	CALLMONITOR 
1bdf			;endif 
1bdf			; 
1bdf			;	FORTH_RSP_NEXT 
1bdf			; 
1bdf			;	;inc hl	 ; go past current buffer pointer 
1bdf			;	;inc hl 
1bdf			;	;inc hl   ; and past if loop flag 
1bdf			;		; TODO Need to set flag  
1bdf			; 
1bdf			;	 
1bdf			;	 
1bdf			;	ex de,hl	; malloc is dest 
1bdf			;	ld hl, (os_tok_len) 
1bdf			;;	pop bc 
1bdf			;	ld c, l                
1bdf			;	ld b,0 
1bdf			;	ld hl, (os_tok_ptr) 
1bdf			; 
1bdf			;if DEBUG_FORTH_TOK 
1bdf			;			DMARK "TKT" 
1bdf			;	CALLMONITOR 
1bdf			;endif 
1bdf			; 
1bdf			;	; do str cpy 
1bdf			; 
1bdf			;	ldir      ; copy byte in hl to de 
1bdf			; 
1bdf			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1bdf			; 
1bdf			;if DEBUG_FORTH_TOK 
1bdf			; 
1bdf			;			DMARK "TKY" 
1bdf			;	CALLMONITOR 
1bdf			;endif 
1bdf			;	;ld a,0 
1bdf			;	;ld a,FORTH_END_BUFFER 
1bdf			;	ex de, hl 
1bdf			;	;dec hl			 ; go back over the space delim at the end of word 
1bdf			;	;ld (hl),a 
1bdf			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1bdf			;	ld a,FORTH_END_BUFFER 
1bdf			;	ld (hl),a 
1bdf			;	inc hl 
1bdf			;	ld a,FORTH_END_BUFFER 
1bdf			;	ld (hl),a 
1bdf			; 
1bdf			;	; init the malloc area data 
1bdf			;	; set pc for in current area 
1bdf			;	;ld hl, (os_tok_malloc) 
1bdf			;	;inc hl 
1bdf			;	;inc hl 
1bdf			;	;inc hl 
1bdf			;	;ex de,hl 
1bdf			;	;ld hl, (os_tok_malloc) 
1bdf			;	;ld (hl),e 
1bdf			;	;inc hl 
1bdf			;	;ld (hl),d 
1bdf			; 
1bdf			; 
1bdf			;	ld hl,(os_tok_malloc) 
1bdf			;if DEBUG_FORTH_PARSE_KEY 
1bdf			;			DMARK "TKU" 
1bdf			;	CALLMONITOR 
1bdf			;endif 
1bdf			; 
1bdf			;	ret 
1bdf			 
1bdf			forthexec: 
1bdf			 
1bdf			; line exec: 
1bdf			; forth parser 
1bdf			 
1bdf			; 
1bdf			;       get current exec line on rsp 
1bdf			 
1bdf				FORTH_RSP_TOS 
1bdf cd 1e 19			call macro_forth_rsp_tos 
1be2				endm 
# End of macro FORTH_RSP_TOS
1be2			 
1be2			;       restore current pc - hl points to malloc of data 
1be2			 
1be2				;ld e, (hl) 
1be2				;inc hl 
1be2				;ld d, (hl) 
1be2				;ex de,hl 
1be2			 
1be2			 
1be2			exec1: 
1be2 22 b9 f2			ld (os_tok_ptr), hl 
1be5			 
1be5				; copy our PC to working vars  
1be5 22 c3 f9			ld (cli_ptr), hl 
1be8 22 c1 f9			ld (cli_origptr), hl 
1beb			 
1beb 7e				ld a,(hl) 
1bec fe 7f			cp FORTH_END_BUFFER 
1bee c8				ret z 
1bef			 
1bef				; skip any nulls 
1bef			 
1bef fe 00			cp 0 
1bf1 20 03			jr nz, .execword 
1bf3 23				inc hl 
1bf4 18 ec			jr exec1 
1bf6			 
1bf6			 
1bf6			.execword: 
1bf6			 
1bf6			 
1bf6			 
1bf6			if DEBUG_FORTH_PARSE_KEY 
1bf6						DMARK "KYQ" 
1bf6				CALLMONITOR 
1bf6			endif 
1bf6			;       while at start of word: 
1bf6			; get start of dict (in user area first) 
1bf6			 
1bf6 21 00 80		ld hl, baseram 
1bf9			;ld hl, sysdict 
1bf9 22 c5 f9		ld (cli_nextword),hl 
1bfc			;           match word at pc 
1bfc			;           exec word 
1bfc			;           or push to dsp 
1bfc			;           forward to next token 
1bfc			;           if line term pop rsp and exit 
1bfc			;        
1bfc			 
1bfc			if DEBUG_FORTH_PARSE_KEY 
1bfc						DMARK "KYq" 
1bfc				CALLMONITOR 
1bfc			endif 
1bfc			 
1bfc			; 
1bfc			; word comp 
1bfc			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1bfc			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1bfc			;    move to start of word  
1bfc			;    compare word to cli_token 
1bfc			 
1bfc			.execpnword:	; HL at start of a word in the dictionary to check 
1bfc			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1bfc			;	ld (cli_ptr), hl 
1bfc			 
1bfc 2a c5 f9			ld hl,(cli_nextword) 
1bff			 
1bff cd a2 1c			call forth_tok_next 
1c02			; tok next start here 
1c02			;	; TODO skip compiled symbol for now 
1c02			;	inc hl 
1c02			; 
1c02			;	; save pointer to next word 
1c02			; 
1c02			;	; hl now points to the address of the next word pointer  
1c02			;	ld e, (hl) 
1c02			;	inc hl 
1c02			;	ld d, (hl) 
1c02			;	inc l 
1c02			; 
1c02			;	ex de,hl 
1c02			;if DEBUG_FORTH_PARSE_NEXTWORD 
1c02			;	push bc 
1c02			;	ld bc, (cli_nextword) 
1c02			;			DMARK "NXW" 
1c02			;	CALLMONITOR 
1c02			;	pop bc 
1c02			;endif 
1c02			; tok next end here 
1c02 22 c5 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
1c05 eb				ex de, hl 
1c06			 
1c06			 
1c06				; save the pointer of the current token - 1 to check against 
1c06				 
1c06 22 c9 f9			ld (cli_token), hl   
1c09				; TODO maybe remove below save if no debug 
1c09				; save token string ptr for any debug later 
1c09 23				inc hl  
1c0a 22 cb f9			ld (cli_origtoken), hl 
1c0d 2b				dec hl 
1c0e				; save pointer to the start of the next dictionay word 
1c0e 7e				ld a,(hl)   ; get string length 
1c0f 47				ld b,a 
1c10			.execpnwordinc:  
1c10 23				inc hl 
1c11 10 fd			djnz .execpnwordinc 
1c13 22 c7 f9			ld (cli_execword), hl      ; save start of this words code 
1c16			 
1c16				; now check the word token against the string being parsed 
1c16			 
1c16 2a c9 f9			ld hl,(cli_token) 
1c19 23				inc hl     ; skip string length (use zero term instead to end) 
1c1a 22 c9 f9			ld (cli_token), hl 
1c1d			 
1c1d			if DEBUG_FORTH_PARSE_KEY 
1c1d						DMARK "KY2" 
1c1d			endif 
1c1d			if DEBUG_FORTH_PARSE_EXEC 
1c1d				; see if disabled 
1c1d			 
1c1d				ld a, (os_view_disable) 
1c1d				cp '*' 
1c1d				jr z, .skip 
1c1d			 
1c1d				push hl 
1c1d				push hl 
1c1d				call clear_display 
1c1d				ld de, .compword 
1c1d				ld a, display_row_1 
1c1d				call str_at_display 
1c1d				pop de 
1c1d				ld a, display_row_2 
1c1d				call str_at_display 
1c1d				ld hl,(cli_ptr) 
1c1d				ld a,(hl) 
1c1d			        ld hl, os_word_scratch 
1c1d				ld (hl),a 
1c1d				ld a,0 
1c1d				inc hl 
1c1d				ld (hl),a 	 
1c1d				ld de, os_word_scratch 
1c1d				ld a, display_row_2+10 
1c1d				call str_at_display 
1c1d				call update_display 
1c1d				ld a, 100 
1c1d				call aDelayInMS 
1c1d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c1d				call delay250ms 
1c1d				endif 
1c1d				pop hl 
1c1d			.skip:  
1c1d			endif	 
1c1d			.execpnchar:    ; compare char between token and string to parse 
1c1d			 
1c1d			if DEBUG_FORTH_PARSE_KEY 
1c1d						DMARK "Ky3" 
1c1d			endif 
1c1d			if DEBUG_FORTH_PARSE_EXEC 
1c1d				; see if disabled 
1c1d			 
1c1d				ld a, (os_view_disable) 
1c1d				cp '*' 
1c1d				jr z, .skip2 
1c1d			 
1c1d			;	call clear_display 
1c1d			ld hl,(cli_token) 
1c1d			ld a,(hl) 
1c1d			ld (os_word_scratch),a 
1c1d				ld hl,(cli_ptr) 
1c1d			ld a,(hl) 
1c1d				ld (os_word_scratch+1),a 
1c1d				ld a,0 
1c1d				ld (os_word_scratch+2),a 
1c1d				ld de,os_word_scratch 
1c1d				ld a,display_row_4 
1c1d				call str_at_display 
1c1d				call update_display 
1c1d			.skip2:  
1c1d			endif 
1c1d 2a c9 f9			ld hl,(cli_token) 
1c20 7e				ld a, (hl)	 ; char in word token 
1c21 23				inc hl 		; move to next char 
1c22 22 c9 f9			ld (cli_token), hl ; and save it 
1c25 47				ld b,a 
1c26			 
1c26 2a c3 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
1c29 7e				ld a,(hl) 
1c2a 23				inc hl 
1c2b 22 c3 f9			ld (cli_ptr), hl		; move to next char 
1c2e cd 64 10			call toUpper 		; make sure the input string matches case 
1c31			 
1c31			if DEBUG_FORTH_PARSE 
1c31			endif 
1c31			 
1c31				; input stream end of token is a space so get rid of it 
1c31			 
1c31			;	cp ' ' 
1c31			;	jr nz, .pnskipspace 
1c31			; 
1c31			;	ld a, 0		; make same term as word token term 
1c31			; 
1c31			;.pnskipspace: 
1c31			 
1c31			if DEBUG_FORTH_PARSE_KEY 
1c31						DMARK "KY7" 
1c31			endif 
1c31 b8				cp b 
1c32 c2 48 1c			jp nz, .execpnskipword	 ; no match so move to next word 
1c35				 
1c35			;    if same 
1c35			;       scan for string terms 0 for token and 32 for input 
1c35			 
1c35				 
1c35			if DEBUG_FORTH_PARSE_KEY 
1c35						DMARK "KY8" 
1c35			endif 
1c35			 
1c35 80				add b			 
1c36 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1c38							; TODO need to make sure last word in zero term string is accounted for 
1c38 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1c3a			 
1c3a			 
1c3a				; at end of both strings so both are exact match 
1c3a			 
1c3a			;       skip ptr for next word 
1c3a			 
1c3a 2a c3 f9			ld hl,(cli_ptr) 	; at input string term 
1c3d 23				inc hl			 ; at next char 
1c3e 22 c3 f9			ld (cli_ptr), hl     ; save for next round of the parser 
1c41 22 c1 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1c44				 
1c44				 
1c44			if DEBUG_FORTH_PARSE_KEY 
1c44						DMARK "KY3" 
1c44			endif 
1c44			 
1c44			 
1c44			 
1c44			;       exec code block 
1c44			if DEBUG_FORTH_JP 
1c44				call clear_display 
1c44				call update_display 
1c44				call delay1s 
1c44				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c44				ld a,h 
1c44				ld hl, os_word_scratch 
1c44				call hexout 
1c44				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c44				ld a,l 
1c44				ld hl, os_word_scratch+2 
1c44				call hexout 
1c44				ld hl, os_word_scratch+4 
1c44				ld a,0 
1c44				ld (hl),a 
1c44				ld de,os_word_scratch 
1c44				call str_at_display 
1c44					ld a, display_row_2 
1c44					call str_at_display 
1c44				ld de, (cli_origtoken) 
1c44				ld a, display_row_1+10 
1c44					call str_at_display 
1c44			 
1c44				ld a,display_row_1 
1c44				ld de, .foundword 
1c44				ld a, display_row_3 
1c44				call str_at_display 
1c44				call update_display 
1c44				call delay1s 
1c44				call delay1s 
1c44				call delay1s 
1c44			endif 
1c44			 
1c44			if DEBUG_FORTH_PARSE_KEY 
1c44						DMARK "KYj" 
1c44			endif 
1c44				; TODO save the word pointer in this exec 
1c44			 
1c44 2a c7 f9			ld hl,(cli_execword) 
1c47 e9				jp (hl) 
1c48			 
1c48			 
1c48			;    if not same 
1c48			;	scan for zero term 
1c48			;	get ptr for next word 
1c48			;	goto word comp 
1c48			 
1c48			.execpnskipword:	; get pointer to next word 
1c48 2a c5 f9			ld hl,(cli_nextword) 
1c4b			 
1c4b 7e				ld a,(hl) 
1c4c fe 00			cp WORD_SYS_END 
1c4e			;	cp 0 
1c4e 28 09			jr z, .execendofdict			 ; at end of words 
1c50			 
1c50			if DEBUG_FORTH_PARSE_KEY 
1c50						DMARK "KY4" 
1c50			endif 
1c50			if DEBUG_FORTH_PARSE_EXEC 
1c50			 
1c50				; see if disabled 
1c50			 
1c50				ld a, (os_view_disable) 
1c50				cp '*' 
1c50				jr z, .noskip 
1c50			 
1c50			 
1c50				ld de, .nowordfound 
1c50				ld a, display_row_3 
1c50				call str_at_display 
1c50				call update_display 
1c50				ld a, 100 
1c50				call aDelayInMS 
1c50				 
1c50				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c50					call delay250ms 
1c50				endif 
1c50			.noskip:  
1c50			 
1c50			endif	 
1c50			 
1c50 2a c1 f9			ld hl,(cli_origptr) 
1c53 22 c3 f9			ld (cli_ptr),hl 
1c56			 
1c56			if DEBUG_FORTH_PARSE_KEY 
1c56						DMARK "KY5" 
1c56			endif 
1c56 c3 fc 1b			jp .execpnword			; else go to next word 
1c59			 
1c59			.execendofdict:  
1c59			 
1c59			if DEBUG_FORTH_PARSE_KEY 
1c59						DMARK "KYe" 
1c59			endif 
1c59			if DEBUG_FORTH_PARSE_EXEC 
1c59				; see if disabled 
1c59			 
1c59				ld a, (os_view_disable) 
1c59				cp '*' 
1c59				jr z, .ispskip 
1c59			 
1c59				call clear_display 
1c59				call update_display 
1c59				call delay1s 
1c59				ld de, (cli_origptr) 
1c59				ld a, display_row_1 
1c59				call str_at_display 
1c59				 
1c59				ld de, .enddict 
1c59				ld a, display_row_3 
1c59				call str_at_display 
1c59				call update_display 
1c59				ld a, 100 
1c59				call aDelayInMS 
1c59				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c59				call delay1s 
1c59				call delay1s 
1c59				call delay1s 
1c59				endif 
1c59			.ispskip:  
1c59				 
1c59			endif	 
1c59			 
1c59			 
1c59			 
1c59				; if the word is not a keyword then must be a literal so push it to stack 
1c59			 
1c59			; push token to stack to end of word 
1c59			 
1c59				STACKFRAME ON $1efe $2f9f 
1c59				if DEBUG_STACK_IMB 
1c59					if ON 
1c59						exx 
1c59						ld de, $1efe 
1c59						ld a, d 
1c59						ld hl, curframe 
1c59						call hexout 
1c59						ld a, e 
1c59						ld hl, curframe+2 
1c59						call hexout 
1c59						ld hl, $1efe 
1c59						push hl 
1c59						ld hl, $2f9f 
1c59						push hl 
1c59						exx 
1c59					endif 
1c59				endif 
1c59			endm 
# End of macro STACKFRAME
1c59			 
1c59 2a b9 f2		ld hl,(os_tok_ptr) 
1c5c cd a8 19		call forth_apush 
1c5f			 
1c5f				STACKFRAMECHK ON $1efe $2f9f 
1c5f				if DEBUG_STACK_IMB 
1c5f					if ON 
1c5f						exx 
1c5f						ld hl, $2f9f 
1c5f						pop de   ; $2f9f 
1c5f						call cmp16 
1c5f						jr nz, .spnosame 
1c5f						ld hl, $1efe 
1c5f						pop de   ; $1efe 
1c5f						call cmp16 
1c5f						jr z, .spfrsame 
1c5f						.spnosame: call showsperror 
1c5f						.spfrsame: nop 
1c5f						exx 
1c5f					endif 
1c5f				endif 
1c5f			endm 
# End of macro STACKFRAMECHK
1c5f			 
1c5f			execnext: 
1c5f			 
1c5f			if DEBUG_FORTH_PARSE_KEY 
1c5f						DMARK "KY>" 
1c5f			endif 
1c5f			; move past token to next word 
1c5f			 
1c5f 2a b9 f2		ld hl, (os_tok_ptr) 
1c62 3e 00		ld a, 0 
1c64 01 ff 00		ld bc, 255     ; input buffer size 
1c67 ed b1		cpir 
1c69			 
1c69			if DEBUG_FORTH_PARSE_KEY 
1c69						DMARK "KY!" 
1c69				CALLMONITOR 
1c69			endif	 
1c69			; TODO this might place hl on the null, so will need to forward on??? 
1c69			;inc hl   ; see if this gets onto the next item 
1c69			 
1c69			 
1c69			; TODO pass a pointer to the buffer to push 
1c69			; TODO call function to push 
1c69			 
1c69			; look for end of input 
1c69			 
1c69			;inc hl 
1c69			;ld a,(hl) 
1c69			;cp FORTH_END_BUFFER 
1c69			;ret z 
1c69			 
1c69			 
1c69 c3 e2 1b		jp exec1 
1c6c			 
1c6c			 
1c6c			 
1c6c			 
1c6c			 
1c6c			 
1c6c			 
1c6c			 
1c6c			 
1c6c			findnexttok: 
1c6c			 
1c6c				; hl is pointer to move 
1c6c				; de is the token to locate 
1c6c			 
1c6c					if DEBUG_FORTH 
1c6c						DMARK "NTK" 
1c6c						CALLMONITOR 
1c6c					endif 
1c6c d5				push de 
1c6d			 
1c6d			.fnt1:	 
1c6d				; find first char of token to locate 
1c6d			 
1c6d 1a				ld a, (de) 
1c6e 4f				ld c,a 
1c6f 7e				ld a,(hl) 
1c70 cd 64 10			call toUpper 
1c73					if DEBUG_FORTH 
1c73						DMARK "NT1" 
1c73						CALLMONITOR 
1c73					endif 
1c73 b9				cp c 
1c74			 
1c74 28 03			jr z, .fnt2cmpmorefirst	 
1c76			 
1c76				; first char not found move to next char 
1c76			 
1c76 23				inc hl 
1c77 18 f4			jr .fnt1 
1c79			 
1c79			.fnt2cmpmorefirst:	 
1c79				; first char of token found.  
1c79			 
1c79 e5				push hl     ; save start of token just in case it is the right one 
1c7a d9				exx 
1c7b e1				pop hl        ; save it to hl' 
1c7c d9				exx 
1c7d			 
1c7d			 
1c7d			.fnt2cmpmore:	 
1c7d				; compare the rest 
1c7d				 
1c7d 23				inc hl 
1c7e 13				inc de 
1c7f				 
1c7f 1a				ld a, (de) 
1c80 4f				ld c,a 
1c81 7e				ld a,(hl) 
1c82 cd 64 10			call toUpper 
1c85			 
1c85					if DEBUG_FORTH 
1c85						DMARK "NT2" 
1c85						CALLMONITOR 
1c85					endif 
1c85				; c has the token to find char 
1c85				; a has the mem to scan char 
1c85			 
1c85 b9				cp c 
1c86 28 04			jr z,.fntmatch1 
1c88			 
1c88				; they are not the same 
1c88			 
1c88					if DEBUG_FORTH 
1c88						DMARK "NT3" 
1c88						CALLMONITOR 
1c88					endif 
1c88 d1				pop de	; reset de token to look for 
1c89 d5				push de 
1c8a 18 e1			jr .fnt1 
1c8c				 
1c8c			.fntmatch1: 
1c8c			 
1c8c				; is the same char a null which means we might have a full hit? 
1c8c					if DEBUG_FORTH 
1c8c						DMARK "NT4" 
1c8c						CALLMONITOR 
1c8c					endif 
1c8c			 
1c8c fe 00			cp 0 
1c8e 28 0b			jr z, .fntmatchyes 
1c90			 
1c90				; are we at the end of the token to find? 
1c90			 
1c90					if DEBUG_FORTH 
1c90						DMARK "NT5" 
1c90						CALLMONITOR 
1c90					endif 
1c90 3e 00			ld a, 0 
1c92 b9				cp c 
1c93			 
1c93 c2 7d 1c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1c96			 
1c96					if DEBUG_FORTH 
1c96						DMARK "NT6" 
1c96						CALLMONITOR 
1c96					endif 
1c96				; token to find is exhusted but no match to stream 
1c96			 
1c96				; restore tok pointer and continue on 
1c96 d1				pop de 
1c97 d5				push de 
1c98 c3 6d 1c			jp .fnt1 
1c9b			 
1c9b			 
1c9b			.fntmatchyes: 
1c9b			 
1c9b				; hl now contains the end of the found token 
1c9b			 
1c9b				; get rid of saved token pointer to find 
1c9b			 
1c9b d1				pop de 
1c9c			 
1c9c					if DEBUG_FORTH 
1c9c						DMARK "NT9" 
1c9c						CALLMONITOR 
1c9c					endif 
1c9c			 
1c9c				; hl will be on the null term so forward on 
1c9c			 
1c9c				; get back the saved start of the token 
1c9c			 
1c9c d9				exx 
1c9d e5				push hl     ; save start of token just in case it is the right one 
1c9e d9				exx 
1c9f e1				pop hl        ; save it to hl 
1ca0			 
1ca0 c9				ret 
1ca1			 
1ca1			 
1ca1			; LIST needs to find a specific token   
1ca1			; FORGET needs to find a spefici token 
1ca1			 
1ca1			; SAVE needs to find all tokens by flag 
1ca1			; WORDS just needs to scan through all  by flag 
1ca1			; UWORDS needs to scan through all by flag 
1ca1			 
1ca1			 
1ca1			; given hl as pointer to start of dict look up string 
1ca1			; return hl as pointer to start of word block 
1ca1			; or 0 if not found 
1ca1			 
1ca1			forth_find_tok: 
1ca1 c9				ret 
1ca2			 
1ca2			; given hl as pointer to dict structure 
1ca2			; move to the next dict block structure 
1ca2			 
1ca2			forth_tok_next: 
1ca2				; hl now points to the address of the next word pointer  
1ca2				; TODO skip compiled symbol for now 
1ca2			;	push de 
1ca2 23				inc hl 
1ca3 5e				ld e, (hl) 
1ca4 23				inc hl 
1ca5 56				ld d, (hl) 
1ca6 23				inc hl 
1ca7			 
1ca7 eb				ex de,hl 
1ca8			if DEBUG_FORTH_PARSE_NEXTWORD 
1ca8				push bc 
1ca8				ld bc, (cli_nextword) 
1ca8						DMARK "NXW" 
1ca8				CALLMONITOR 
1ca8				pop bc 
1ca8			endif 
1ca8			;	pop de	 
1ca8 c9				ret 
1ca9			 
1ca9			 
1ca9			 
1ca9			; eof 
# End of file forth_parserv5.asm
1ca9				include "forth_wordsv4.asm" 
1ca9			 
1ca9			; the core word dictionary v4 
1ca9			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ca9			 
1ca9			; this is a linked list for each of the system words used 
1ca9			; user defined words will follow the same format but will be in ram 
1ca9			 
1ca9			 
1ca9			; 
1ca9			; 
1ca9			; define linked list: 
1ca9			; 
1ca9			; 1. compiled byte op code 
1ca9			; 2. len of text word 
1ca9			; 3. text word 
1ca9			; 4. ptr to next dictionary word 
1ca9			; 5. asm, calls etc for the word 
1ca9			; 
1ca9			;  if 1 == 0 then last word in dict  
1ca9			;   
1ca9			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ca9			;  
1ca9			;  
1ca9			; create basic standard set of words 
1ca9			; 
1ca9			;  
1ca9			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ca9			; 2DUP 2DROP 2SWAP  
1ca9			; @ C@ - get byte  
1ca9			; ! C! - store byte 
1ca9			; 0< true if less than zero 
1ca9			; 0= true if zero 
1ca9			; < >  
1ca9			; = true if same 
1ca9			; variables 
1ca9			 
1ca9			 
1ca9			; Hardware specific words I may need 
1ca9			; 
1ca9			; IN OUT  
1ca9			; calls to key util functions 
1ca9			; calls to hardward abstraction stuff 
1ca9			; easy control of frame buffers and lcd i/o 
1ca9			; keyboard  
1ca9			 
1ca9			 
1ca9			;DICT: macro 
1ca9			; op_code, len, word, next 
1ca9			;    word: 
1ca9			;    db op_code 
1ca9			;    ds word zero term 
1ca9			;    dw next 
1ca9			;    endm 
1ca9			 
1ca9			 
1ca9			 
1ca9			 
1ca9			; op code 1 is a flag for user define words which are to be handled differently 
1ca9			 
1ca9			 
1ca9			; 
1ca9			; 
1ca9			;    TODO on entry to a word this should be the expected environment 
1ca9			;    hl - tos value if number then held, if string this is the ptr 
1ca9			;    de -  
1ca9			 
1ca9			 
1ca9			; opcode ranges 
1ca9			; 0 - end of word dict 
1ca9			; 255 - user define words 
1ca9			 
1ca9			sysdict: 
1ca9			include "forth_opcodes.asm" 
1ca9			; op codes for forth keywords 
1ca9			; free to use code 0  
1ca9				OPCODE_HEAP: equ  1 
1ca9				OPCODE_EXEC: equ 2 
1ca9				OPCODE_DUP: equ 3 
1ca9				OPCODE_SWAP: equ 4 
1ca9				OPCODE_COLN: equ 5 
1ca9				OPCODE_SCOLN: equ 6 
1ca9				OPCODE_DROP: equ 7 
1ca9				OPCODE_DUP2: equ 8 
1ca9				OPCODE_DROP2: equ 9 
1ca9				OPCODE_SWAP2: equ 10 
1ca9				OPCODE_AT: equ 11 
1ca9				OPCODE_CAT: equ 12 
1ca9				OPCODE_BANG: equ 13 
1ca9				OPCODE_CBANG: equ 14 
1ca9				OPCODE_SCALL: equ 15 
1ca9				OPCODE_DEPTH: equ 16 
1ca9				OPCODE_OVER: equ 17 
1ca9				OPCODE_PAUSE: equ 18 
1ca9				OPCODE_PAUSES: equ 19 
1ca9				OPCODE_ROT: equ 20 
1ca9			;free to reuse	OPCODE_WORDS: equ 21 
1ca9			        OPCODE_NOT: equ 21 
1ca9				OPCODE_UWORDS: equ 22 
1ca9				OPCODE_BP: equ 23 
1ca9				OPCODE_MONITOR: equ 24  
1ca9				OPCODE_MALLOC: equ 25 
1ca9				OPCODE_FREE: equ 26 
1ca9				OPCODE_LIST: equ 27 
1ca9				OPCODE_FORGET: equ 28 
1ca9				OPCODE_NOP: equ 29 
1ca9				OPCODE_COMO: equ 30 
1ca9				OPCODE_COMC: equ 31 
1ca9			;free to reuse	OPCODE_ENDCORE: equ 32 
1ca9				OPCODE_AFTERSOUND: equ 33 
1ca9				OPCODE_GP2: equ 34 
1ca9				OPCODE_GP3: equ 35 
1ca9				OPCODE_GP4: equ 36 
1ca9				OPCODE_SIN: equ 37 
1ca9				OPCODE_SOUT: equ 38 
1ca9				OPCODE_SPIO: equ 39 
1ca9				OPCODE_SPICEH: equ 40 
1ca9				OPCODE_SPIOb: equ 41 
1ca9				OPCODE_SPII: equ 42 
1ca9				OPCODE_SESEL: equ 43 
1ca9				OPCODE_CARTDEV: equ 44 
1ca9			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ca9				OPCODE_FB: equ 46 
1ca9				OPCODE_EMIT: equ 47 
1ca9				OPCODE_DOTH: equ 48 
1ca9				OPCODE_DOTF: equ 49 
1ca9				OPCODE_DOT: equ 50 
1ca9				OPCODE_CLS: equ 51 
1ca9				OPCODE_DRAW: equ 52 
1ca9				OPCODE_DUMP: equ 53 
1ca9				OPCODE_CDUMP: equ 54 
1ca9				OPCODE_DAT: equ 55 
1ca9				OPCODE_HOME: equ 56 
1ca9				OPCODE_SPACE: equ 57 
1ca9				OPCODE_SPACES: equ 58 
1ca9				OPCODE_SCROLL: equ 59 
1ca9				OPCODE_ATQ: equ 60 
1ca9				OPCODE_AUTODSP: equ 61 
1ca9				OPCODE_MENU: equ 62 
1ca9			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ca9				OPCODE_THEN: equ 64 
1ca9				OPCODE_ELSE: equ 65 
1ca9				OPCODE_DO: equ 66 
1ca9				OPCODE_LOOP: equ 67 
1ca9				OPCODE_I: equ 68 
1ca9				OPCODE_DLOOP: equ 69  
1ca9				OPCODE_REPEAT: equ 70  
1ca9				OPCODE_UNTIL: equ 71 
1ca9				OPCODE_ENDFLOW: equ 72 
1ca9				OPCODE_WAITK: equ 73 
1ca9				OPCODE_ACCEPT: equ 74 
1ca9				OPCODE_EDIT: equ 75 
1ca9			;free to reuse	OPCODE_ENDKEY: equ 76 
1ca9				OPCODE_LZERO: equ 77 
1ca9				OPCODE_TZERO: equ 78 
1ca9				OPCODE_LESS: equ 79 
1ca9				OPCODE_GT: equ 80 
1ca9				OPCODE_EQUAL: equ 81  
1ca9			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ca9				OPCODE_NEG: equ 83 
1ca9				OPCODE_DIV: equ 84 
1ca9				OPCODE_MUL: equ 85 
1ca9				OPCODE_MIN: equ 86 
1ca9				OPCODE_MAX: equ 87 
1ca9				OPCODE_RND16: equ 88 
1ca9				OPCODE_RND8: equ 89 
1ca9				OPCODE_RND: equ 90 
1ca9			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ca9				OPCODE_BYNAME: equ 92 
1ca9				OPCODE_DIR: equ 93 
1ca9				OPCODE_SAVE: equ 94 
1ca9				OPCODE_LOAD: equ 95 
1ca9				OPCODE_BSAVE: equ 96 
1ca9				OPCODE_BLOAD: equ 97 
1ca9				OPCODE_SEO: equ 98  
1ca9				OPCODE_SEI: equ 99 
1ca9				OPCODE_SFREE: equ 100 
1ca9				OPCODE_SIZE: equ 101 
1ca9				OPCODE_CREATE: equ 102 
1ca9				OPCODE_APPEND: equ 103 
1ca9				OPCODE_SDEL: equ 104 
1ca9				OPCODE_OPEN: equ 105 
1ca9				OPCODE_READ: equ 106 
1ca9				OPCODE_EOF: equ 106 
1ca9				OPCODE_FORMAT: equ 107 
1ca9				OPCODE_LABEL: equ 108 
1ca9				OPCODE_LABELS: equ 109 
1ca9			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ca9				OPCODE_UPPER: equ 111 
1ca9				OPCODE_LOWER: equ 112 
1ca9				OPCODE_SUBSTR: equ 113 
1ca9				OPCODE_LEFT: equ 114 
1ca9				OPCODE_RIGHT: equ 115 
1ca9				OPCODE_STR2NUM: equ 116 
1ca9				OPCODE_NUM2STR: equ 117 
1ca9				OPCODE_CONCAT: equ 118 
1ca9				OPCODE_FIND: equ 119 
1ca9				OPCODE_LEN: equ 120 
1ca9				OPCODE_CHAR: equ 121 
1ca9			; free to reuse	OPCODE_STRLEN: equ 122 
1ca9			; free to reuse	OPCODE_ENDSTR: equ 123 
1ca9				OPCODE_V0S: equ 124 
1ca9				OPCODE_V0Q: equ 125 
1ca9				OPCODE_V1S: equ 126 
1ca9				OPCODE_V1Q: equ 127 
1ca9				OPCODE_V2S: equ 128 
1ca9				OPCODE_V2Q: equ 129 
1ca9				OPCODE_V3S: equ 130 
1ca9				OPCODE_V3Q: equ 131 
1ca9			;free to reuse	OPCODE_END: equ 132 
1ca9				OPCODE_ZDUP: equ 133 
1ca9			 
1ca9			; eof 
# End of file forth_opcodes.asm
1ca9			 
1ca9			include "forth_words_core.asm" 
1ca9			 
1ca9			; | ## Core Words 
1ca9			 
1ca9			;if MALLOC_4 
1ca9			 
1ca9			.HEAP: 
1ca9				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ca9 15				db WORD_SYS_CORE+OPCODE_HEAP             
1caa e8 1c			dw .EXEC            
1cac 05				db 4 + 1 
1cad .. 00			db "HEAP",0              
1cb2				endm 
# End of macro CWHEAD
1cb2			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1cb2			; | | u1 - Current number of bytes in the heap 
1cb2			; | | u2 - Remaining bytes left on the heap 
1cb2			; | |  
1cb2			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1cb2			 
1cb2			 
1cb2					if DEBUG_FORTH_WORDS_KEY 
1cb2						DMARK "HEP" 
1cb2 f5				push af  
1cb3 3a c7 1c			ld a, (.dmark)  
1cb6 32 bd fb			ld (debug_mark),a  
1cb9 3a c8 1c			ld a, (.dmark+1)  
1cbc 32 be fb			ld (debug_mark+1),a  
1cbf 3a c9 1c			ld a, (.dmark+2)  
1cc2 32 bf fb			ld (debug_mark+2),a  
1cc5 18 03			jr .pastdmark  
1cc7 ..			.dmark: db "HEP"  
1cca f1			.pastdmark: pop af  
1ccb			endm  
# End of macro DMARK
1ccb						CALLMONITOR 
1ccb cd d3 13			call break_point_state  
1cce				endm  
# End of macro CALLMONITOR
1cce					endif 
1cce 2a 0a 80				ld hl, (free_list )      
1cd1 11 0e 80				ld de, heap_start 
1cd4			 
1cd4 ed 52				sbc hl, de  
1cd6			 
1cd6 cd 60 19				call forth_push_numhl 
1cd9			 
1cd9			 
1cd9 ed 5b 0a 80			ld de, (free_list )      
1cdd 21 ac ef				ld hl, heap_end 
1ce0			 
1ce0 ed 52				sbc hl, de 
1ce2			 
1ce2 cd 60 19				call forth_push_numhl 
1ce5					 
1ce5			 
1ce5					 
1ce5			 
1ce5			 
1ce5			 
1ce5					NEXTW 
1ce5 c3 51 1b			jp macro_next 
1ce8				endm 
# End of macro NEXTW
1ce8			;endif 
1ce8			 
1ce8			.EXEC: 
1ce8				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1ce8 16				db WORD_SYS_CORE+OPCODE_EXEC             
1ce9 84 1d			dw .STKEXEC            
1ceb 05				db 4 + 1 
1cec .. 00			db "EXEC",0              
1cf1				endm 
# End of macro CWHEAD
1cf1			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1cf1			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1cf1			; | | 
1cf1			; | |   
1cf1				STACKFRAME OFF $5efe $5f9f 
1cf1				if DEBUG_STACK_IMB 
1cf1					if OFF 
1cf1						exx 
1cf1						ld de, $5efe 
1cf1						ld a, d 
1cf1						ld hl, curframe 
1cf1						call hexout 
1cf1						ld a, e 
1cf1						ld hl, curframe+2 
1cf1						call hexout 
1cf1						ld hl, $5efe 
1cf1						push hl 
1cf1						ld hl, $5f9f 
1cf1						push hl 
1cf1						exx 
1cf1					endif 
1cf1				endif 
1cf1			endm 
# End of macro STACKFRAME
1cf1			 
1cf1					if DEBUG_FORTH_WORDS_KEY 
1cf1						DMARK "EXE" 
1cf1 f5				push af  
1cf2 3a 06 1d			ld a, (.dmark)  
1cf5 32 bd fb			ld (debug_mark),a  
1cf8 3a 07 1d			ld a, (.dmark+1)  
1cfb 32 be fb			ld (debug_mark+1),a  
1cfe 3a 08 1d			ld a, (.dmark+2)  
1d01 32 bf fb			ld (debug_mark+2),a  
1d04 18 03			jr .pastdmark  
1d06 ..			.dmark: db "EXE"  
1d09 f1			.pastdmark: pop af  
1d0a			endm  
# End of macro DMARK
1d0a						CALLMONITOR 
1d0a cd d3 13			call break_point_state  
1d0d				endm  
# End of macro CALLMONITOR
1d0d					endif 
1d0d			 
1d0d				FORTH_DSP_VALUEHL 
1d0d cd fb 19			call macro_dsp_valuehl 
1d10				endm 
# End of macro FORTH_DSP_VALUEHL
1d10			 
1d10				FORTH_DSP_POP 
1d10 cd 97 1a			call macro_forth_dsp_pop 
1d13				endm 
# End of macro FORTH_DSP_POP
1d13			 
1d13					if DEBUG_FORTH_WORDS 
1d13						DMARK "EX1" 
1d13 f5				push af  
1d14 3a 28 1d			ld a, (.dmark)  
1d17 32 bd fb			ld (debug_mark),a  
1d1a 3a 29 1d			ld a, (.dmark+1)  
1d1d 32 be fb			ld (debug_mark+1),a  
1d20 3a 2a 1d			ld a, (.dmark+2)  
1d23 32 bf fb			ld (debug_mark+2),a  
1d26 18 03			jr .pastdmark  
1d28 ..			.dmark: db "EX1"  
1d2b f1			.pastdmark: pop af  
1d2c			endm  
# End of macro DMARK
1d2c						CALLMONITOR 
1d2c cd d3 13			call break_point_state  
1d2f				endm  
# End of macro CALLMONITOR
1d2f					endif 
1d2f			;	ld e,(hl) 
1d2f			;	inc hl 
1d2f			;	ld d,(hl) 
1d2f			;	ex de,hl 
1d2f			 
1d2f			;		if DEBUG_FORTH_WORDS 
1d2f			;			DMARK "EX2" 
1d2f			;			CALLMONITOR 
1d2f			;		endif 
1d2f e5				push hl 
1d30			 
1d30				;ld a, 0 
1d30				;ld a, FORTH_END_BUFFER 
1d30 cd 6d 10			call strlenz 
1d33 23				inc hl   ; include zero term to copy 
1d34 23				inc hl   ; include term 
1d35 23				inc hl   ; include term 
1d36 06 00			ld b,0 
1d38 4d				ld c,l 
1d39 e1				pop hl 
1d3a 11 b7 f0			ld de, execscratch 
1d3d					if DEBUG_FORTH_WORDS 
1d3d						DMARK "EX3" 
1d3d f5				push af  
1d3e 3a 52 1d			ld a, (.dmark)  
1d41 32 bd fb			ld (debug_mark),a  
1d44 3a 53 1d			ld a, (.dmark+1)  
1d47 32 be fb			ld (debug_mark+1),a  
1d4a 3a 54 1d			ld a, (.dmark+2)  
1d4d 32 bf fb			ld (debug_mark+2),a  
1d50 18 03			jr .pastdmark  
1d52 ..			.dmark: db "EX3"  
1d55 f1			.pastdmark: pop af  
1d56			endm  
# End of macro DMARK
1d56						CALLMONITOR 
1d56 cd d3 13			call break_point_state  
1d59				endm  
# End of macro CALLMONITOR
1d59					endif 
1d59 ed b0			ldir 
1d5b			 
1d5b			 
1d5b 21 b7 f0			ld hl, execscratch 
1d5e			 
1d5e					if DEBUG_FORTH_WORDS 
1d5e						DMARK "EXe" 
1d5e f5				push af  
1d5f 3a 73 1d			ld a, (.dmark)  
1d62 32 bd fb			ld (debug_mark),a  
1d65 3a 74 1d			ld a, (.dmark+1)  
1d68 32 be fb			ld (debug_mark+1),a  
1d6b 3a 75 1d			ld a, (.dmark+2)  
1d6e 32 bf fb			ld (debug_mark+2),a  
1d71 18 03			jr .pastdmark  
1d73 ..			.dmark: db "EXe"  
1d76 f1			.pastdmark: pop af  
1d77			endm  
# End of macro DMARK
1d77						CALLMONITOR 
1d77 cd d3 13			call break_point_state  
1d7a				endm  
# End of macro CALLMONITOR
1d7a					endif 
1d7a			 
1d7a cd 9f 1b			call forthparse 
1d7d cd df 1b			call forthexec 
1d80			;	call forthexec_cleanup 
1d80			;	call forthparse 
1d80			;	call forthexec 
1d80			 
1d80				STACKFRAMECHK OFF $5efe $5f9f 
1d80				if DEBUG_STACK_IMB 
1d80					if OFF 
1d80						exx 
1d80						ld hl, $5f9f 
1d80						pop de   ; $5f9f 
1d80						call cmp16 
1d80						jr nz, .spnosame 
1d80						ld hl, $5efe 
1d80						pop de   ; $5efe 
1d80						call cmp16 
1d80						jr z, .spfrsame 
1d80						.spnosame: call showsperror 
1d80						.spfrsame: nop 
1d80						exx 
1d80					endif 
1d80				endif 
1d80			endm 
# End of macro STACKFRAMECHK
1d80			 
1d80				; an immediate word so no need to process any more words 
1d80 c9				ret 
1d81				NEXTW 
1d81 c3 51 1b			jp macro_next 
1d84				endm 
# End of macro NEXTW
1d84			 
1d84			; dead code - old version  
1d84			;	FORTH_RSP_NEXT 
1d84			 
1d84			;  
1d84			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d84			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d84			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d84			;	push hl 
1d84			;	push de 
1d84			;	push bc 
1d84			; 
1d84			; 
1d84			;		if DEBUG_FORTH_WORDS_KEY 
1d84			;			DMARK "EXR" 
1d84			;			CALLMONITOR 
1d84			;		endif 
1d84			; 
1d84			; 
1d84			; 
1d84			;	;v5 FORTH_DSP_VALUE 
1d84			;	FORTH_DSP_VALUEHL 
1d84			; 
1d84			;	; TODO do string type checks 
1d84			; 
1d84			;;v5	inc hl   ; skip type 
1d84			; 
1d84			;	push hl  ; source code  
1d84			;		if DEBUG_FORTH_WORDS 
1d84			;			DMARK "EX1" 
1d84			;			CALLMONITOR 
1d84			;		endif 
1d84			;	ld a, 0 
1d84			;	call strlent 
1d84			; 
1d84			;	inc hl 
1d84			;	inc hl 
1d84			;	inc hl 
1d84			;	inc hl 
1d84			; 
1d84			;	push hl    ; size 
1d84			; 
1d84			;		if DEBUG_FORTH_WORDS 
1d84			;			DMARK "EX2" 
1d84			;			CALLMONITOR 
1d84			;		endif 
1d84			;	call malloc 
1d84			; 
1d84			;	ex de, hl    ; de now contains malloc area 
1d84			;	pop bc   	; get byte count 
1d84			;	pop hl      ; get string to copy 
1d84			; 
1d84			;	push de     ; save malloc for free later 
1d84			; 
1d84			;		if DEBUG_FORTH_WORDS 
1d84			;			DMARK "EX3" 
1d84			;			CALLMONITOR 
1d84			;		endif 
1d84			;	ldir       ; duplicate string 
1d84			; 
1d84			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1d84			;	 
1d84			;	; TODO fix the parse would be better than this...  
1d84			;	ex de, hl 
1d84			;	dec hl 
1d84			;	ld a, 0 
1d84			;	ld (hl), a 
1d84			;	dec hl 
1d84			;	ld a, ' ' 
1d84			;	ld (hl), a 
1d84			;	dec hl 
1d84			;	ld (hl), a 
1d84			; 
1d84			;	dec hl 
1d84			;	ld (hl), a 
1d84			; 
1d84			; 
1d84			;	FORTH_DSP_POP  
1d84			; 
1d84			;	pop hl     
1d84			;	push hl    ; save malloc area 
1d84			; 
1d84			;		if DEBUG_FORTH_WORDS 
1d84			;			DMARK "EX4" 
1d84			;			CALLMONITOR 
1d84			;		endif 
1d84			; 
1d84			;	call forthparse 
1d84			;	call forthexec 
1d84			;	 
1d84			;	pop hl 
1d84			;	if DEBUG_FORTH_WORDS 
1d84			;		DMARK "EX5" 
1d84			;		CALLMONITOR 
1d84			;	endif 
1d84			; 
1d84			;	if FORTH_ENABLE_FREE 
1d84			;	call free 
1d84			;	endif 
1d84			; 
1d84			;	if DEBUG_FORTH_WORDS 
1d84			;		DMARK "EX6" 
1d84			;		CALLMONITOR 
1d84			;	endif 
1d84			; 
1d84			;	pop bc 
1d84			;	pop de 
1d84			;	pop hl 
1d84			;;	FORTH_RSP_POP	  
1d84			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1d84			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1d84			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1d84			; 
1d84			;	if DEBUG_FORTH_WORDS 
1d84			;		DMARK "EX7" 
1d84			;		CALLMONITOR 
1d84			;	endif 
1d84			;	NEXTW 
1d84			 
1d84			.STKEXEC: 
1d84				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1d84 3f				db WORD_SYS_CORE+43             
1d85 cc 1e			dw .ZDUP            
1d87 08				db 7 + 1 
1d88 .. 00			db "STKEXEC",0              
1d90				endm 
# End of macro CWHEAD
1d90			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1d90			 
1d90			 
1d90					if DEBUG_FORTH_WORDS_KEY 
1d90						DMARK "STX" 
1d90 f5				push af  
1d91 3a a5 1d			ld a, (.dmark)  
1d94 32 bd fb			ld (debug_mark),a  
1d97 3a a6 1d			ld a, (.dmark+1)  
1d9a 32 be fb			ld (debug_mark+1),a  
1d9d 3a a7 1d			ld a, (.dmark+2)  
1da0 32 bf fb			ld (debug_mark+2),a  
1da3 18 03			jr .pastdmark  
1da5 ..			.dmark: db "STX"  
1da8 f1			.pastdmark: pop af  
1da9			endm  
# End of macro DMARK
1da9						CALLMONITOR 
1da9 cd d3 13			call break_point_state  
1dac				endm  
# End of macro CALLMONITOR
1dac					endif 
1dac			 
1dac				FORTH_DSP_VALUEHL 
1dac cd fb 19			call macro_dsp_valuehl 
1daf				endm 
# End of macro FORTH_DSP_VALUEHL
1daf			 
1daf 22 e6 f9			ld (store_tmp1), hl    ; count 
1db2			 
1db2				FORTH_DSP_POP 
1db2 cd 97 1a			call macro_forth_dsp_pop 
1db5				endm 
# End of macro FORTH_DSP_POP
1db5			.stkexec1: 
1db5 2a e6 f9			ld hl, (store_tmp1)   ; count 
1db8 3e 00			ld a, 0 
1dba bd				cp l 
1dbb c8				ret z 
1dbc			 
1dbc 2b				dec hl 
1dbd 22 e6 f9			ld (store_tmp1), hl    ; count 
1dc0				 
1dc0				FORTH_DSP_VALUEHL 
1dc0 cd fb 19			call macro_dsp_valuehl 
1dc3				endm 
# End of macro FORTH_DSP_VALUEHL
1dc3 e5				push hl 
1dc4				 
1dc4					if DEBUG_FORTH_WORDS 
1dc4						DMARK "EXp" 
1dc4 f5				push af  
1dc5 3a d9 1d			ld a, (.dmark)  
1dc8 32 bd fb			ld (debug_mark),a  
1dcb 3a da 1d			ld a, (.dmark+1)  
1dce 32 be fb			ld (debug_mark+1),a  
1dd1 3a db 1d			ld a, (.dmark+2)  
1dd4 32 bf fb			ld (debug_mark+2),a  
1dd7 18 03			jr .pastdmark  
1dd9 ..			.dmark: db "EXp"  
1ddc f1			.pastdmark: pop af  
1ddd			endm  
# End of macro DMARK
1ddd						CALLMONITOR 
1ddd cd d3 13			call break_point_state  
1de0				endm  
# End of macro CALLMONITOR
1de0					endif 
1de0				FORTH_DSP_POP 
1de0 cd 97 1a			call macro_forth_dsp_pop 
1de3				endm 
# End of macro FORTH_DSP_POP
1de3			 
1de3 cd 6d 10			call strlenz 
1de6 23				inc hl   ; include zero term to copy 
1de7 23				inc hl   ; include zero term to copy 
1de8 23				inc hl   ; include zero term to copy 
1de9 06 00			ld b,0 
1deb 4d				ld c,l 
1dec e1				pop hl 
1ded 11 b7 f0			ld de, execscratch 
1df0					if DEBUG_FORTH_WORDS 
1df0						DMARK "EX3" 
1df0 f5				push af  
1df1 3a 05 1e			ld a, (.dmark)  
1df4 32 bd fb			ld (debug_mark),a  
1df7 3a 06 1e			ld a, (.dmark+1)  
1dfa 32 be fb			ld (debug_mark+1),a  
1dfd 3a 07 1e			ld a, (.dmark+2)  
1e00 32 bf fb			ld (debug_mark+2),a  
1e03 18 03			jr .pastdmark  
1e05 ..			.dmark: db "EX3"  
1e08 f1			.pastdmark: pop af  
1e09			endm  
# End of macro DMARK
1e09						CALLMONITOR 
1e09 cd d3 13			call break_point_state  
1e0c				endm  
# End of macro CALLMONITOR
1e0c					endif 
1e0c ed b0			ldir 
1e0e			 
1e0e			 
1e0e 21 b7 f0			ld hl, execscratch 
1e11			 
1e11					if DEBUG_FORTH_WORDS 
1e11						DMARK "EXP" 
1e11 f5				push af  
1e12 3a 26 1e			ld a, (.dmark)  
1e15 32 bd fb			ld (debug_mark),a  
1e18 3a 27 1e			ld a, (.dmark+1)  
1e1b 32 be fb			ld (debug_mark+1),a  
1e1e 3a 28 1e			ld a, (.dmark+2)  
1e21 32 bf fb			ld (debug_mark+2),a  
1e24 18 03			jr .pastdmark  
1e26 ..			.dmark: db "EXP"  
1e29 f1			.pastdmark: pop af  
1e2a			endm  
# End of macro DMARK
1e2a						CALLMONITOR 
1e2a cd d3 13			call break_point_state  
1e2d				endm  
# End of macro CALLMONITOR
1e2d					endif 
1e2d			 
1e2d cd 9f 1b			call forthparse 
1e30 21 b7 f0			ld hl, execscratch 
1e33					if DEBUG_FORTH_WORDS 
1e33						DMARK "EXx" 
1e33 f5				push af  
1e34 3a 48 1e			ld a, (.dmark)  
1e37 32 bd fb			ld (debug_mark),a  
1e3a 3a 49 1e			ld a, (.dmark+1)  
1e3d 32 be fb			ld (debug_mark+1),a  
1e40 3a 4a 1e			ld a, (.dmark+2)  
1e43 32 bf fb			ld (debug_mark+2),a  
1e46 18 03			jr .pastdmark  
1e48 ..			.dmark: db "EXx"  
1e4b f1			.pastdmark: pop af  
1e4c			endm  
# End of macro DMARK
1e4c						CALLMONITOR 
1e4c cd d3 13			call break_point_state  
1e4f				endm  
# End of macro CALLMONITOR
1e4f					endif 
1e4f cd df 1b			call forthexec 
1e52			 
1e52 c3 b5 1d			jp .stkexec1 
1e55			 
1e55 c9				ret 
1e56			 
1e56			 
1e56			.DUP: 
1e56				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1e56 17				db WORD_SYS_CORE+OPCODE_DUP             
1e57 cc 1e			dw .ZDUP            
1e59 04				db 3 + 1 
1e5a .. 00			db "DUP",0              
1e5e				endm 
# End of macro CWHEAD
1e5e			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1e5e			 
1e5e					if DEBUG_FORTH_WORDS_KEY 
1e5e						DMARK "DUP" 
1e5e f5				push af  
1e5f 3a 73 1e			ld a, (.dmark)  
1e62 32 bd fb			ld (debug_mark),a  
1e65 3a 74 1e			ld a, (.dmark+1)  
1e68 32 be fb			ld (debug_mark+1),a  
1e6b 3a 75 1e			ld a, (.dmark+2)  
1e6e 32 bf fb			ld (debug_mark+2),a  
1e71 18 03			jr .pastdmark  
1e73 ..			.dmark: db "DUP"  
1e76 f1			.pastdmark: pop af  
1e77			endm  
# End of macro DMARK
1e77						CALLMONITOR 
1e77 cd d3 13			call break_point_state  
1e7a				endm  
# End of macro CALLMONITOR
1e7a					endif 
1e7a			 
1e7a					FORTH_DSP 
1e7a cd e0 19			call macro_forth_dsp 
1e7d				endm 
# End of macro FORTH_DSP
1e7d			 
1e7d 7e					ld a, (HL) 
1e7e fe 01				cp DS_TYPE_STR 
1e80 20 25				jr nz, .dupinum 
1e82			 
1e82					; push another string 
1e82			 
1e82					FORTH_DSP_VALUEHL     		 
1e82 cd fb 19			call macro_dsp_valuehl 
1e85				endm 
# End of macro FORTH_DSP_VALUEHL
1e85			 
1e85				if DEBUG_FORTH_WORDS 
1e85					DMARK "DUs" 
1e85 f5				push af  
1e86 3a 9a 1e			ld a, (.dmark)  
1e89 32 bd fb			ld (debug_mark),a  
1e8c 3a 9b 1e			ld a, (.dmark+1)  
1e8f 32 be fb			ld (debug_mark+1),a  
1e92 3a 9c 1e			ld a, (.dmark+2)  
1e95 32 bf fb			ld (debug_mark+2),a  
1e98 18 03			jr .pastdmark  
1e9a ..			.dmark: db "DUs"  
1e9d f1			.pastdmark: pop af  
1e9e			endm  
# End of macro DMARK
1e9e					CALLMONITOR 
1e9e cd d3 13			call break_point_state  
1ea1				endm  
# End of macro CALLMONITOR
1ea1				endif 
1ea1 cd 72 19				call forth_push_str 
1ea4			 
1ea4					NEXTW 
1ea4 c3 51 1b			jp macro_next 
1ea7				endm 
# End of macro NEXTW
1ea7			 
1ea7			 
1ea7			.dupinum: 
1ea7					 
1ea7			 
1ea7			 
1ea7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ea7 cd fb 19			call macro_dsp_valuehl 
1eaa				endm 
# End of macro FORTH_DSP_VALUEHL
1eaa			 
1eaa				; TODO add floating point number detection 
1eaa			 
1eaa				if DEBUG_FORTH_WORDS 
1eaa					DMARK "DUi" 
1eaa f5				push af  
1eab 3a bf 1e			ld a, (.dmark)  
1eae 32 bd fb			ld (debug_mark),a  
1eb1 3a c0 1e			ld a, (.dmark+1)  
1eb4 32 be fb			ld (debug_mark+1),a  
1eb7 3a c1 1e			ld a, (.dmark+2)  
1eba 32 bf fb			ld (debug_mark+2),a  
1ebd 18 03			jr .pastdmark  
1ebf ..			.dmark: db "DUi"  
1ec2 f1			.pastdmark: pop af  
1ec3			endm  
# End of macro DMARK
1ec3					CALLMONITOR 
1ec3 cd d3 13			call break_point_state  
1ec6				endm  
# End of macro CALLMONITOR
1ec6				endif 
1ec6			 
1ec6 cd 60 19				call forth_push_numhl 
1ec9					NEXTW 
1ec9 c3 51 1b			jp macro_next 
1ecc				endm 
# End of macro NEXTW
1ecc			.ZDUP: 
1ecc				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1ecc 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1ecd 04 1f			dw .SWAP            
1ecf 05				db 4 + 1 
1ed0 .. 00			db "?DUP",0              
1ed5				endm 
# End of macro CWHEAD
1ed5			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1ed5			 
1ed5					if DEBUG_FORTH_WORDS_KEY 
1ed5						DMARK "qDU" 
1ed5 f5				push af  
1ed6 3a ea 1e			ld a, (.dmark)  
1ed9 32 bd fb			ld (debug_mark),a  
1edc 3a eb 1e			ld a, (.dmark+1)  
1edf 32 be fb			ld (debug_mark+1),a  
1ee2 3a ec 1e			ld a, (.dmark+2)  
1ee5 32 bf fb			ld (debug_mark+2),a  
1ee8 18 03			jr .pastdmark  
1eea ..			.dmark: db "qDU"  
1eed f1			.pastdmark: pop af  
1eee			endm  
# End of macro DMARK
1eee						CALLMONITOR 
1eee cd d3 13			call break_point_state  
1ef1				endm  
# End of macro CALLMONITOR
1ef1					endif 
1ef1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ef1 cd fb 19			call macro_dsp_valuehl 
1ef4				endm 
# End of macro FORTH_DSP_VALUEHL
1ef4			 
1ef4 e5					push hl 
1ef5			 
1ef5					; is it a zero? 
1ef5			 
1ef5 3e 00				ld a, 0 
1ef7 84					add h 
1ef8 85					add l 
1ef9			 
1ef9 e1					pop hl 
1efa			 
1efa fe 00				cp 0 
1efc 28 03				jr z, .dup2orig 
1efe			 
1efe			 
1efe cd 60 19				call forth_push_numhl 
1f01			 
1f01			 
1f01				; TODO add floating point number detection 
1f01			 
1f01			.dup2orig: 
1f01			 
1f01					NEXTW 
1f01 c3 51 1b			jp macro_next 
1f04				endm 
# End of macro NEXTW
1f04			.SWAP: 
1f04				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f04 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f05 43 1f			dw .COLN            
1f07 05				db 4 + 1 
1f08 .. 00			db "SWAP",0              
1f0d				endm 
# End of macro CWHEAD
1f0d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f0d					if DEBUG_FORTH_WORDS_KEY 
1f0d						DMARK "SWP" 
1f0d f5				push af  
1f0e 3a 22 1f			ld a, (.dmark)  
1f11 32 bd fb			ld (debug_mark),a  
1f14 3a 23 1f			ld a, (.dmark+1)  
1f17 32 be fb			ld (debug_mark+1),a  
1f1a 3a 24 1f			ld a, (.dmark+2)  
1f1d 32 bf fb			ld (debug_mark+2),a  
1f20 18 03			jr .pastdmark  
1f22 ..			.dmark: db "SWP"  
1f25 f1			.pastdmark: pop af  
1f26			endm  
# End of macro DMARK
1f26						CALLMONITOR 
1f26 cd d3 13			call break_point_state  
1f29				endm  
# End of macro CALLMONITOR
1f29					endif 
1f29			 
1f29					FORTH_DSP_VALUEHL 
1f29 cd fb 19			call macro_dsp_valuehl 
1f2c				endm 
# End of macro FORTH_DSP_VALUEHL
1f2c e5					push hl     ; w2 
1f2d			 
1f2d					FORTH_DSP_POP 
1f2d cd 97 1a			call macro_forth_dsp_pop 
1f30				endm 
# End of macro FORTH_DSP_POP
1f30			 
1f30					FORTH_DSP_VALUEHL 
1f30 cd fb 19			call macro_dsp_valuehl 
1f33				endm 
# End of macro FORTH_DSP_VALUEHL
1f33			 
1f33					FORTH_DSP_POP 
1f33 cd 97 1a			call macro_forth_dsp_pop 
1f36				endm 
# End of macro FORTH_DSP_POP
1f36			 
1f36 d1					pop de     ; w2	, hl = w1 
1f37			 
1f37 eb					ex de, hl 
1f38 d5					push de 
1f39			 
1f39 cd 60 19				call forth_push_numhl 
1f3c			 
1f3c e1					pop hl 
1f3d			 
1f3d cd 60 19				call forth_push_numhl 
1f40					 
1f40			 
1f40					NEXTW 
1f40 c3 51 1b			jp macro_next 
1f43				endm 
# End of macro NEXTW
1f43			.COLN: 
1f43				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1f43 19				db WORD_SYS_CORE+OPCODE_COLN             
1f44 cf 20			dw .SCOLN            
1f46 02				db 1 + 1 
1f47 .. 00			db ":",0              
1f49				endm 
# End of macro CWHEAD
1f49			; | : ( -- )         Create new word | DONE 
1f49			 
1f49					if DEBUG_FORTH_WORDS_KEY 
1f49						DMARK "CLN" 
1f49 f5				push af  
1f4a 3a 5e 1f			ld a, (.dmark)  
1f4d 32 bd fb			ld (debug_mark),a  
1f50 3a 5f 1f			ld a, (.dmark+1)  
1f53 32 be fb			ld (debug_mark+1),a  
1f56 3a 60 1f			ld a, (.dmark+2)  
1f59 32 bf fb			ld (debug_mark+2),a  
1f5c 18 03			jr .pastdmark  
1f5e ..			.dmark: db "CLN"  
1f61 f1			.pastdmark: pop af  
1f62			endm  
# End of macro DMARK
1f62						CALLMONITOR 
1f62 cd d3 13			call break_point_state  
1f65				endm  
# End of macro CALLMONITOR
1f65					endif 
1f65				STACKFRAME OFF $8efe $989f 
1f65				if DEBUG_STACK_IMB 
1f65					if OFF 
1f65						exx 
1f65						ld de, $8efe 
1f65						ld a, d 
1f65						ld hl, curframe 
1f65						call hexout 
1f65						ld a, e 
1f65						ld hl, curframe+2 
1f65						call hexout 
1f65						ld hl, $8efe 
1f65						push hl 
1f65						ld hl, $989f 
1f65						push hl 
1f65						exx 
1f65					endif 
1f65				endif 
1f65			endm 
# End of macro STACKFRAME
1f65				; get parser buffer length  of new word 
1f65			 
1f65				 
1f65			 
1f65					; move tok past this to start of name defintition 
1f65					; TODO get word to define 
1f65					; TODO Move past word token 
1f65					; TODO get length of string up to the ';' 
1f65			 
1f65 2a b9 f2			ld hl, (os_tok_ptr) 
1f68 23				inc hl 
1f69 23				inc hl 
1f6a			 
1f6a 3e 3b			ld a, ';' 
1f6c cd 78 10			call strlent 
1f6f			 
1f6f 7d				ld a,l 
1f70 32 b8 f1			ld (os_new_parse_len), a 
1f73			 
1f73			 
1f73			if DEBUG_FORTH_UWORD 
1f73 ed 5b b9 f2		ld de, (os_tok_ptr) 
1f77						DMARK ":01" 
1f77 f5				push af  
1f78 3a 8c 1f			ld a, (.dmark)  
1f7b 32 bd fb			ld (debug_mark),a  
1f7e 3a 8d 1f			ld a, (.dmark+1)  
1f81 32 be fb			ld (debug_mark+1),a  
1f84 3a 8e 1f			ld a, (.dmark+2)  
1f87 32 bf fb			ld (debug_mark+2),a  
1f8a 18 03			jr .pastdmark  
1f8c ..			.dmark: db ":01"  
1f8f f1			.pastdmark: pop af  
1f90			endm  
# End of macro DMARK
1f90				CALLMONITOR 
1f90 cd d3 13			call break_point_state  
1f93				endm  
# End of macro CALLMONITOR
1f93			endif 
1f93			 
1f93			; 
1f93			;  new word memory layout: 
1f93			;  
1f93			;    : adg 6666 ;  
1f93			; 
1f93			;    db   1     ; user defined word  
1f93 23				inc hl    
1f94			;    dw   sysdict 
1f94 23				inc hl 
1f95 23				inc hl 
1f96			;    db <word len>+1 (for null) 
1f96 23				inc hl 
1f97			;    db .... <word> 
1f97			; 
1f97			 
1f97 23				inc hl    ; some extras for the word preamble before the above 
1f98 23				inc hl 
1f99 23				inc hl 
1f9a 23				inc hl 
1f9b 23				inc hl 
1f9c 23				inc hl 
1f9d 23				inc hl  
1f9e 23				inc hl 
1f9f 23				inc hl 
1fa0 23				inc hl 
1fa1 23				inc hl 
1fa2 23				inc hl 
1fa3 23				inc hl 
1fa4 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1fa5			;       exec word buffer 
1fa5			;	<ptr word>   
1fa5 23				inc hl 
1fa6 23				inc hl 
1fa7			;       <word list><null term> 7F final term 
1fa7			 
1fa7			 
1fa7			if DEBUG_FORTH_UWORD 
1fa7						DMARK ":02" 
1fa7 f5				push af  
1fa8 3a bc 1f			ld a, (.dmark)  
1fab 32 bd fb			ld (debug_mark),a  
1fae 3a bd 1f			ld a, (.dmark+1)  
1fb1 32 be fb			ld (debug_mark+1),a  
1fb4 3a be 1f			ld a, (.dmark+2)  
1fb7 32 bf fb			ld (debug_mark+2),a  
1fba 18 03			jr .pastdmark  
1fbc ..			.dmark: db ":02"  
1fbf f1			.pastdmark: pop af  
1fc0			endm  
# End of macro DMARK
1fc0				CALLMONITOR 
1fc0 cd d3 13			call break_point_state  
1fc3				endm  
# End of macro CALLMONITOR
1fc3			endif 
1fc3			 
1fc3				 
1fc3					; malloc the size 
1fc3			 
1fc3 cd d6 10				call malloc 
1fc6 22 b6 f1				ld (os_new_malloc), hl     ; save malloc start 
1fc9			 
1fc9			;    db   1     ; user defined word  
1fc9 3e 01				ld a, WORD_SYS_UWORD  
1fcb 77					ld (hl), a 
1fcc				 
1fcc 23				inc hl    
1fcd			;    dw   sysdict 
1fcd 11 a9 1c			ld de, sysdict       ; continue on with the scan to the system dict 
1fd0 73				ld (hl), e 
1fd1 23				inc hl 
1fd2 72				ld (hl), d 
1fd3 23				inc hl 
1fd4			 
1fd4			 
1fd4			;    Setup dict word 
1fd4			 
1fd4 23				inc hl 
1fd5 22 bc f1			ld (os_new_work_ptr), hl     ; save start of dict word  
1fd8			 
1fd8				; 1. get length of dict word 
1fd8			 
1fd8			 
1fd8 2a b9 f2			ld hl, (os_tok_ptr) 
1fdb 23				inc hl 
1fdc 23				inc hl    ; position to start of dict word 
1fdd 3e 00			ld a, 0 
1fdf cd 78 10			call strlent 
1fe2			 
1fe2			 
1fe2 23				inc hl    ; to include null??? 
1fe3			 
1fe3				; write length of dict word 
1fe3			 
1fe3 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1fe7 1b				dec de 
1fe8 eb				ex de, hl 
1fe9 73				ld (hl), e 
1fea eb				ex de, hl 
1feb			 
1feb				 
1feb			 
1feb				; copy  
1feb 4d				ld c, l 
1fec 06 00			ld b, 0 
1fee ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1ff2 2a b9 f2			ld hl, (os_tok_ptr) 
1ff5 23				inc hl 
1ff6 23				inc hl    ; position to start of dict word 
1ff7				 
1ff7			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1ff7				 
1ff7				; TODO need to convert word to upper case 
1ff7			 
1ff7			ucasetok:	 
1ff7 7e				ld a,(hl) 
1ff8 cd 64 10			call toUpper 
1ffb 77				ld (hl),a 
1ffc ed a0			ldi 
1ffe f2 f7 1f		 	jp p, ucasetok 
2001			 
2001			 
2001			 
2001				; de now points to start of where the word body code should be placed 
2001 ed 53 bc f1		ld (os_new_work_ptr), de 
2005				; hl now points to the words to throw at forthexec which needs to be copied 
2005 22 be f1			ld (os_new_src_ptr), hl 
2008			 
2008				; TODO add 'call to forthexec' 
2008			 
2008			if DEBUG_FORTH_UWORD 
2008 c5				push bc 
2009 ed 4b b6 f1		ld bc, (os_new_malloc) 
200d						DMARK ":0x" 
200d f5				push af  
200e 3a 22 20			ld a, (.dmark)  
2011 32 bd fb			ld (debug_mark),a  
2014 3a 23 20			ld a, (.dmark+1)  
2017 32 be fb			ld (debug_mark+1),a  
201a 3a 24 20			ld a, (.dmark+2)  
201d 32 bf fb			ld (debug_mark+2),a  
2020 18 03			jr .pastdmark  
2022 ..			.dmark: db ":0x"  
2025 f1			.pastdmark: pop af  
2026			endm  
# End of macro DMARK
2026				CALLMONITOR 
2026 cd d3 13			call break_point_state  
2029				endm  
# End of macro CALLMONITOR
2029 c1				pop bc 
202a			endif 
202a			 
202a			 
202a				; create word preamble which should be: 
202a			 
202a			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
202a			 
202a				;    ld hl, <word code> 
202a				;    jp user_exec 
202a			        ;    <word code bytes> 
202a			 
202a			 
202a			;	inc de     ; TODO ??? or are we already past the word's null 
202a eb				ex de, hl 
202b			 
202b 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
202d			 
202d 23				inc hl 
202e 22 c2 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2031 23				inc hl 
2032			 
2032 23				inc hl 
2033 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2035			 
2035 01 c8 4d			ld bc, user_exec 
2038 23				inc hl 
2039 71				ld (hl), c     ; poke address of user_exec 
203a 23				inc hl 
203b 70				ld (hl), b     
203c			 ; 
203c			;	inc hl 
203c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
203c			; 
203c			; 
203c			;	ld bc, macro_forth_rsp_next 
203c			;	inc hl 
203c			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
203c			;	inc hl 
203c			;	ld (hl), b     
203c			 ; 
203c			;	inc hl 
203c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
203c			; 
203c			; 
203c			;	inc hl 
203c			;	ld bc, forthexec 
203c			;	ld (hl), c     ; poke address of forthexec 
203c			;	inc hl 
203c			;	ld (hl), b      
203c			; 
203c			;	inc hl 
203c			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
203c			; 
203c			;	ld bc, user_dict_next 
203c			;	inc hl 
203c			;	ld (hl), c     ; poke address of forthexec 
203c			;	inc hl 
203c			;	ld (hl), b      
203c			 
203c				; hl is now where we need to copy the word byte data to save this 
203c			 
203c 23				inc hl 
203d 22 c0 f1			ld (os_new_exec), hl 
2040				 
2040				; copy definition 
2040			 
2040 eb				ex de, hl 
2041			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2041			;	inc de    ; skip the PC for this parse 
2041 3a b8 f1			ld a, (os_new_parse_len) 
2044 4f				ld c, a 
2045 06 00			ld b, 0 
2047 ed b0			ldir		 ; copy defintion 
2049			 
2049			 
2049				; poke the address of where the new word bytes live for forthexec 
2049			 
2049 2a c2 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
204c			 
204c ed 5b c0 f1		ld de, (os_new_exec)      
2050				 
2050 73				ld (hl), e 
2051 23				inc hl 
2052 72				ld (hl), d 
2053			 
2053					; TODO copy last user dict word next link to this word 
2053					; TODO update last user dict word to point to this word 
2053			; 
2053			; hl f923 de 812a ; bc 811a 
2053			 
2053			if DEBUG_FORTH_UWORD 
2053 c5				push bc 
2054 ed 4b b6 f1		ld bc, (os_new_malloc) 
2058						DMARK ":0A" 
2058 f5				push af  
2059 3a 6d 20			ld a, (.dmark)  
205c 32 bd fb			ld (debug_mark),a  
205f 3a 6e 20			ld a, (.dmark+1)  
2062 32 be fb			ld (debug_mark+1),a  
2065 3a 6f 20			ld a, (.dmark+2)  
2068 32 bf fb			ld (debug_mark+2),a  
206b 18 03			jr .pastdmark  
206d ..			.dmark: db ":0A"  
2070 f1			.pastdmark: pop af  
2071			endm  
# End of macro DMARK
2071				CALLMONITOR 
2071 cd d3 13			call break_point_state  
2074				endm  
# End of macro CALLMONITOR
2074 c1				pop bc 
2075			endif 
2075			if DEBUG_FORTH_UWORD 
2075 c5				push bc 
2076 ed 4b b6 f1		ld bc, (os_new_malloc) 
207a 03				inc bc 
207b 03				inc bc 
207c 03				inc bc 
207d 03				inc bc 
207e 03				inc bc 
207f 03				inc bc 
2080 03				inc bc 
2081 03				inc bc 
2082			 
2082						DMARK ":0B" 
2082 f5				push af  
2083 3a 97 20			ld a, (.dmark)  
2086 32 bd fb			ld (debug_mark),a  
2089 3a 98 20			ld a, (.dmark+1)  
208c 32 be fb			ld (debug_mark+1),a  
208f 3a 99 20			ld a, (.dmark+2)  
2092 32 bf fb			ld (debug_mark+2),a  
2095 18 03			jr .pastdmark  
2097 ..			.dmark: db ":0B"  
209a f1			.pastdmark: pop af  
209b			endm  
# End of macro DMARK
209b				CALLMONITOR 
209b cd d3 13			call break_point_state  
209e				endm  
# End of macro CALLMONITOR
209e c1				pop bc 
209f			endif 
209f			 
209f			; update word dict linked list for new word 
209f			 
209f			 
209f 2a b5 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
20a2 23			inc hl     ; move to next work linked list ptr 
20a3			 
20a3 ed 5b b6 f1	ld de, (os_new_malloc)		 ; new next word 
20a7 73			ld (hl), e 
20a8 23			inc hl 
20a9 72			ld (hl), d 
20aa			 
20aa			if DEBUG_FORTH_UWORD 
20aa ed 4b b5 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
20ae			endif 
20ae			 
20ae ed 53 b5 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
20b2			 
20b2			 
20b2			if DEBUG_FORTH_UWORD 
20b2						DMARK ":0+" 
20b2 f5				push af  
20b3 3a c7 20			ld a, (.dmark)  
20b6 32 bd fb			ld (debug_mark),a  
20b9 3a c8 20			ld a, (.dmark+1)  
20bc 32 be fb			ld (debug_mark+1),a  
20bf 3a c9 20			ld a, (.dmark+2)  
20c2 32 bf fb			ld (debug_mark+2),a  
20c5 18 03			jr .pastdmark  
20c7 ..			.dmark: db ":0+"  
20ca f1			.pastdmark: pop af  
20cb			endm  
# End of macro DMARK
20cb				CALLMONITOR 
20cb cd d3 13			call break_point_state  
20ce				endm  
# End of macro CALLMONITOR
20ce			endif 
20ce			 
20ce				STACKFRAMECHK OFF $8efe $989f 
20ce				if DEBUG_STACK_IMB 
20ce					if OFF 
20ce						exx 
20ce						ld hl, $989f 
20ce						pop de   ; $989f 
20ce						call cmp16 
20ce						jr nz, .spnosame 
20ce						ld hl, $8efe 
20ce						pop de   ; $8efe 
20ce						call cmp16 
20ce						jr z, .spfrsame 
20ce						.spnosame: call showsperror 
20ce						.spfrsame: nop 
20ce						exx 
20ce					endif 
20ce				endif 
20ce			endm 
# End of macro STACKFRAMECHK
20ce			 
20ce c9			ret    ; dont process any remaining parser tokens as they form new word 
20cf			 
20cf			 
20cf			 
20cf			 
20cf			;		NEXT 
20cf			.SCOLN: 
20cf			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
20cf 06				db OPCODE_SCOLN 
20d0 1b 21			dw .DROP 
20d2 02				db 2 
20d3 .. 00			db ";",0           
20d5			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
20d5					if DEBUG_FORTH_WORDS_KEY 
20d5						DMARK "SCN" 
20d5 f5				push af  
20d6 3a ea 20			ld a, (.dmark)  
20d9 32 bd fb			ld (debug_mark),a  
20dc 3a eb 20			ld a, (.dmark+1)  
20df 32 be fb			ld (debug_mark+1),a  
20e2 3a ec 20			ld a, (.dmark+2)  
20e5 32 bf fb			ld (debug_mark+2),a  
20e8 18 03			jr .pastdmark  
20ea ..			.dmark: db "SCN"  
20ed f1			.pastdmark: pop af  
20ee			endm  
# End of macro DMARK
20ee						CALLMONITOR 
20ee cd d3 13			call break_point_state  
20f1				endm  
# End of macro CALLMONITOR
20f1					endif 
20f1					FORTH_RSP_TOS 
20f1 cd 1e 19			call macro_forth_rsp_tos 
20f4				endm 
# End of macro FORTH_RSP_TOS
20f4 e5					push hl 
20f5					FORTH_RSP_POP 
20f5 cd 28 19			call macro_forth_rsp_pop 
20f8				endm 
# End of macro FORTH_RSP_POP
20f8 e1					pop hl 
20f9			;		ex de,hl 
20f9 22 b9 f2				ld (os_tok_ptr),hl 
20fc			 
20fc			if DEBUG_FORTH_UWORD 
20fc						DMARK "SCL" 
20fc f5				push af  
20fd 3a 11 21			ld a, (.dmark)  
2100 32 bd fb			ld (debug_mark),a  
2103 3a 12 21			ld a, (.dmark+1)  
2106 32 be fb			ld (debug_mark+1),a  
2109 3a 13 21			ld a, (.dmark+2)  
210c 32 bf fb			ld (debug_mark+2),a  
210f 18 03			jr .pastdmark  
2111 ..			.dmark: db "SCL"  
2114 f1			.pastdmark: pop af  
2115			endm  
# End of macro DMARK
2115				CALLMONITOR 
2115 cd d3 13			call break_point_state  
2118				endm  
# End of macro CALLMONITOR
2118			endif 
2118					NEXTW 
2118 c3 51 1b			jp macro_next 
211b				endm 
# End of macro NEXTW
211b			 
211b			.DROP: 
211b				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
211b 1b				db WORD_SYS_CORE+OPCODE_DROP             
211c 46 21			dw .DUP2            
211e 05				db 4 + 1 
211f .. 00			db "DROP",0              
2124				endm 
# End of macro CWHEAD
2124			; | DROP ( w -- )   drop the TOS item   | DONE 
2124					if DEBUG_FORTH_WORDS_KEY 
2124						DMARK "DRP" 
2124 f5				push af  
2125 3a 39 21			ld a, (.dmark)  
2128 32 bd fb			ld (debug_mark),a  
212b 3a 3a 21			ld a, (.dmark+1)  
212e 32 be fb			ld (debug_mark+1),a  
2131 3a 3b 21			ld a, (.dmark+2)  
2134 32 bf fb			ld (debug_mark+2),a  
2137 18 03			jr .pastdmark  
2139 ..			.dmark: db "DRP"  
213c f1			.pastdmark: pop af  
213d			endm  
# End of macro DMARK
213d						CALLMONITOR 
213d cd d3 13			call break_point_state  
2140				endm  
# End of macro CALLMONITOR
2140					endif 
2140					FORTH_DSP_POP 
2140 cd 97 1a			call macro_forth_dsp_pop 
2143				endm 
# End of macro FORTH_DSP_POP
2143					NEXTW 
2143 c3 51 1b			jp macro_next 
2146				endm 
# End of macro NEXTW
2146			.DUP2: 
2146				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2146 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2147 8b 21			dw .DROP2            
2149 05				db 4 + 1 
214a .. 00			db "2DUP",0              
214f				endm 
# End of macro CWHEAD
214f			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
214f					if DEBUG_FORTH_WORDS_KEY 
214f						DMARK "2DU" 
214f f5				push af  
2150 3a 64 21			ld a, (.dmark)  
2153 32 bd fb			ld (debug_mark),a  
2156 3a 65 21			ld a, (.dmark+1)  
2159 32 be fb			ld (debug_mark+1),a  
215c 3a 66 21			ld a, (.dmark+2)  
215f 32 bf fb			ld (debug_mark+2),a  
2162 18 03			jr .pastdmark  
2164 ..			.dmark: db "2DU"  
2167 f1			.pastdmark: pop af  
2168			endm  
# End of macro DMARK
2168						CALLMONITOR 
2168 cd d3 13			call break_point_state  
216b				endm  
# End of macro CALLMONITOR
216b					endif 
216b					FORTH_DSP_VALUEHL 
216b cd fb 19			call macro_dsp_valuehl 
216e				endm 
# End of macro FORTH_DSP_VALUEHL
216e e5					push hl      ; 2 
216f			 
216f					FORTH_DSP_POP 
216f cd 97 1a			call macro_forth_dsp_pop 
2172				endm 
# End of macro FORTH_DSP_POP
2172					 
2172					FORTH_DSP_VALUEHL 
2172 cd fb 19			call macro_dsp_valuehl 
2175				endm 
# End of macro FORTH_DSP_VALUEHL
2175			;		push hl      ; 1 
2175			 
2175					FORTH_DSP_POP 
2175 cd 97 1a			call macro_forth_dsp_pop 
2178				endm 
# End of macro FORTH_DSP_POP
2178			 
2178			;		pop hl       ; 1 
2178 d1					pop de       ; 2 
2179			 
2179 cd 60 19				call forth_push_numhl 
217c eb					ex de, hl 
217d cd 60 19				call forth_push_numhl 
2180			 
2180					 
2180 eb					ex de, hl 
2181			 
2181 cd 60 19				call forth_push_numhl 
2184 eb					ex de, hl 
2185 cd 60 19				call forth_push_numhl 
2188			 
2188			 
2188					NEXTW 
2188 c3 51 1b			jp macro_next 
218b				endm 
# End of macro NEXTW
218b			.DROP2: 
218b				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
218b 1d				db WORD_SYS_CORE+OPCODE_DROP2             
218c ba 21			dw .SWAP2            
218e 06				db 5 + 1 
218f .. 00			db "2DROP",0              
2195				endm 
# End of macro CWHEAD
2195			; | 2DROP ( w w -- )    Double drop | DONE 
2195					if DEBUG_FORTH_WORDS_KEY 
2195						DMARK "2DR" 
2195 f5				push af  
2196 3a aa 21			ld a, (.dmark)  
2199 32 bd fb			ld (debug_mark),a  
219c 3a ab 21			ld a, (.dmark+1)  
219f 32 be fb			ld (debug_mark+1),a  
21a2 3a ac 21			ld a, (.dmark+2)  
21a5 32 bf fb			ld (debug_mark+2),a  
21a8 18 03			jr .pastdmark  
21aa ..			.dmark: db "2DR"  
21ad f1			.pastdmark: pop af  
21ae			endm  
# End of macro DMARK
21ae						CALLMONITOR 
21ae cd d3 13			call break_point_state  
21b1				endm  
# End of macro CALLMONITOR
21b1					endif 
21b1					FORTH_DSP_POP 
21b1 cd 97 1a			call macro_forth_dsp_pop 
21b4				endm 
# End of macro FORTH_DSP_POP
21b4					FORTH_DSP_POP 
21b4 cd 97 1a			call macro_forth_dsp_pop 
21b7				endm 
# End of macro FORTH_DSP_POP
21b7					NEXTW 
21b7 c3 51 1b			jp macro_next 
21ba				endm 
# End of macro NEXTW
21ba			.SWAP2: 
21ba				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
21ba 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
21bb e3 21			dw .AT            
21bd 06				db 5 + 1 
21be .. 00			db "2SWAP",0              
21c4				endm 
# End of macro CWHEAD
21c4			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
21c4					if DEBUG_FORTH_WORDS_KEY 
21c4						DMARK "2SW" 
21c4 f5				push af  
21c5 3a d9 21			ld a, (.dmark)  
21c8 32 bd fb			ld (debug_mark),a  
21cb 3a da 21			ld a, (.dmark+1)  
21ce 32 be fb			ld (debug_mark+1),a  
21d1 3a db 21			ld a, (.dmark+2)  
21d4 32 bf fb			ld (debug_mark+2),a  
21d7 18 03			jr .pastdmark  
21d9 ..			.dmark: db "2SW"  
21dc f1			.pastdmark: pop af  
21dd			endm  
# End of macro DMARK
21dd						CALLMONITOR 
21dd cd d3 13			call break_point_state  
21e0				endm  
# End of macro CALLMONITOR
21e0					endif 
21e0					NEXTW 
21e0 c3 51 1b			jp macro_next 
21e3				endm 
# End of macro NEXTW
21e3			.AT: 
21e3				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
21e3 1f				db WORD_SYS_CORE+OPCODE_AT             
21e4 15 22			dw .CAT            
21e6 02				db 1 + 1 
21e7 .. 00			db "@",0              
21e9				endm 
# End of macro CWHEAD
21e9			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
21e9			 
21e9					if DEBUG_FORTH_WORDS_KEY 
21e9						DMARK "AT." 
21e9 f5				push af  
21ea 3a fe 21			ld a, (.dmark)  
21ed 32 bd fb			ld (debug_mark),a  
21f0 3a ff 21			ld a, (.dmark+1)  
21f3 32 be fb			ld (debug_mark+1),a  
21f6 3a 00 22			ld a, (.dmark+2)  
21f9 32 bf fb			ld (debug_mark+2),a  
21fc 18 03			jr .pastdmark  
21fe ..			.dmark: db "AT."  
2201 f1			.pastdmark: pop af  
2202			endm  
# End of macro DMARK
2202						CALLMONITOR 
2202 cd d3 13			call break_point_state  
2205				endm  
# End of macro CALLMONITOR
2205					endif 
2205			.getbyteat:	 
2205					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2205 cd fb 19			call macro_dsp_valuehl 
2208				endm 
# End of macro FORTH_DSP_VALUEHL
2208					 
2208			;		push hl 
2208				 
2208					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2208 cd 97 1a			call macro_forth_dsp_pop 
220b				endm 
# End of macro FORTH_DSP_POP
220b			 
220b			;		pop hl 
220b			 
220b 7e					ld a, (hl) 
220c			 
220c 6f					ld l, a 
220d 26 00				ld h, 0 
220f cd 60 19				call forth_push_numhl 
2212			 
2212					NEXTW 
2212 c3 51 1b			jp macro_next 
2215				endm 
# End of macro NEXTW
2215			.CAT: 
2215				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2215 20				db WORD_SYS_CORE+OPCODE_CAT             
2216 3e 22			dw .BANG            
2218 03				db 2 + 1 
2219 .. 00			db "C@",0              
221c				endm 
# End of macro CWHEAD
221c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
221c					if DEBUG_FORTH_WORDS_KEY 
221c						DMARK "CAA" 
221c f5				push af  
221d 3a 31 22			ld a, (.dmark)  
2220 32 bd fb			ld (debug_mark),a  
2223 3a 32 22			ld a, (.dmark+1)  
2226 32 be fb			ld (debug_mark+1),a  
2229 3a 33 22			ld a, (.dmark+2)  
222c 32 bf fb			ld (debug_mark+2),a  
222f 18 03			jr .pastdmark  
2231 ..			.dmark: db "CAA"  
2234 f1			.pastdmark: pop af  
2235			endm  
# End of macro DMARK
2235						CALLMONITOR 
2235 cd d3 13			call break_point_state  
2238				endm  
# End of macro CALLMONITOR
2238					endif 
2238 c3 05 22				jp .getbyteat 
223b					NEXTW 
223b c3 51 1b			jp macro_next 
223e				endm 
# End of macro NEXTW
223e			.BANG: 
223e				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
223e 21				db WORD_SYS_CORE+OPCODE_BANG             
223f 74 22			dw .CBANG            
2241 02				db 1 + 1 
2242 .. 00			db "!",0              
2244				endm 
# End of macro CWHEAD
2244			; | ! ( x w -- ) Store x at address w      | DONE 
2244					if DEBUG_FORTH_WORDS_KEY 
2244						DMARK "BNG" 
2244 f5				push af  
2245 3a 59 22			ld a, (.dmark)  
2248 32 bd fb			ld (debug_mark),a  
224b 3a 5a 22			ld a, (.dmark+1)  
224e 32 be fb			ld (debug_mark+1),a  
2251 3a 5b 22			ld a, (.dmark+2)  
2254 32 bf fb			ld (debug_mark+2),a  
2257 18 03			jr .pastdmark  
2259 ..			.dmark: db "BNG"  
225c f1			.pastdmark: pop af  
225d			endm  
# End of macro DMARK
225d						CALLMONITOR 
225d cd d3 13			call break_point_state  
2260				endm  
# End of macro CALLMONITOR
2260					endif 
2260			 
2260			.storebyteat:		 
2260					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2260 cd fb 19			call macro_dsp_valuehl 
2263				endm 
# End of macro FORTH_DSP_VALUEHL
2263					 
2263 e5					push hl 
2264				 
2264					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2264 cd 97 1a			call macro_forth_dsp_pop 
2267				endm 
# End of macro FORTH_DSP_POP
2267			 
2267					; get byte to poke 
2267			 
2267					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2267 cd fb 19			call macro_dsp_valuehl 
226a				endm 
# End of macro FORTH_DSP_VALUEHL
226a e5					push hl 
226b			 
226b			 
226b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
226b cd 97 1a			call macro_forth_dsp_pop 
226e				endm 
# End of macro FORTH_DSP_POP
226e			 
226e			 
226e d1					pop de 
226f e1					pop hl 
2270			 
2270 73					ld (hl),e 
2271			 
2271			 
2271					NEXTW 
2271 c3 51 1b			jp macro_next 
2274				endm 
# End of macro NEXTW
2274			.CBANG: 
2274				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2274 22				db WORD_SYS_CORE+OPCODE_CBANG             
2275 9d 22			dw .SCALL            
2277 03				db 2 + 1 
2278 .. 00			db "C!",0              
227b				endm 
# End of macro CWHEAD
227b			; | C!  ( x w -- ) Store x at address w  | DONE 
227b					if DEBUG_FORTH_WORDS_KEY 
227b						DMARK "CBA" 
227b f5				push af  
227c 3a 90 22			ld a, (.dmark)  
227f 32 bd fb			ld (debug_mark),a  
2282 3a 91 22			ld a, (.dmark+1)  
2285 32 be fb			ld (debug_mark+1),a  
2288 3a 92 22			ld a, (.dmark+2)  
228b 32 bf fb			ld (debug_mark+2),a  
228e 18 03			jr .pastdmark  
2290 ..			.dmark: db "CBA"  
2293 f1			.pastdmark: pop af  
2294			endm  
# End of macro DMARK
2294						CALLMONITOR 
2294 cd d3 13			call break_point_state  
2297				endm  
# End of macro CALLMONITOR
2297					endif 
2297 c3 60 22				jp .storebyteat 
229a					NEXTW 
229a c3 51 1b			jp macro_next 
229d				endm 
# End of macro NEXTW
229d			.SCALL: 
229d				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
229d 23				db WORD_SYS_CORE+OPCODE_SCALL             
229e d1 22			dw .DEPTH            
22a0 05				db 4 + 1 
22a1 .. 00			db "CALL",0              
22a6				endm 
# End of macro CWHEAD
22a6			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
22a6					if DEBUG_FORTH_WORDS_KEY 
22a6						DMARK "CLL" 
22a6 f5				push af  
22a7 3a bb 22			ld a, (.dmark)  
22aa 32 bd fb			ld (debug_mark),a  
22ad 3a bc 22			ld a, (.dmark+1)  
22b0 32 be fb			ld (debug_mark+1),a  
22b3 3a bd 22			ld a, (.dmark+2)  
22b6 32 bf fb			ld (debug_mark+2),a  
22b9 18 03			jr .pastdmark  
22bb ..			.dmark: db "CLL"  
22be f1			.pastdmark: pop af  
22bf			endm  
# End of macro DMARK
22bf						CALLMONITOR 
22bf cd d3 13			call break_point_state  
22c2				endm  
# End of macro CALLMONITOR
22c2					endif 
22c2			 
22c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22c2 cd fb 19			call macro_dsp_valuehl 
22c5				endm 
# End of macro FORTH_DSP_VALUEHL
22c5			 
22c5			;		push hl 
22c5			 
22c5					; destroy value TOS 
22c5			 
22c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22c5 cd 97 1a			call macro_forth_dsp_pop 
22c8				endm 
# End of macro FORTH_DSP_POP
22c8			 
22c8						 
22c8			;		pop hl 
22c8			 
22c8					; how to do a call with hl???? save SP? 
22c8 cd fa 1a				call forth_call_hl 
22cb			 
22cb			 
22cb					; TODO push value back onto stack for another op etc 
22cb			 
22cb cd 60 19				call forth_push_numhl 
22ce					NEXTW 
22ce c3 51 1b			jp macro_next 
22d1				endm 
# End of macro NEXTW
22d1			.DEPTH: 
22d1				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
22d1 24				db WORD_SYS_CORE+OPCODE_DEPTH             
22d2 0e 23			dw .OVER            
22d4 06				db 5 + 1 
22d5 .. 00			db "DEPTH",0              
22db				endm 
# End of macro CWHEAD
22db			; | DEPTH ( -- u ) Push count of stack | DONE 
22db					; take current TOS and remove from base value div by two to get count 
22db					if DEBUG_FORTH_WORDS_KEY 
22db						DMARK "DEP" 
22db f5				push af  
22dc 3a f0 22			ld a, (.dmark)  
22df 32 bd fb			ld (debug_mark),a  
22e2 3a f1 22			ld a, (.dmark+1)  
22e5 32 be fb			ld (debug_mark+1),a  
22e8 3a f2 22			ld a, (.dmark+2)  
22eb 32 bf fb			ld (debug_mark+2),a  
22ee 18 03			jr .pastdmark  
22f0 ..			.dmark: db "DEP"  
22f3 f1			.pastdmark: pop af  
22f4			endm  
# End of macro DMARK
22f4						CALLMONITOR 
22f4 cd d3 13			call break_point_state  
22f7				endm  
# End of macro CALLMONITOR
22f7					endif 
22f7			 
22f7			 
22f7 2a a5 f9			ld hl, (cli_data_sp) 
22fa 11 1f f5			ld de, cli_data_stack 
22fd ed 52			sbc hl,de 
22ff				 
22ff				; div by size of stack item 
22ff			 
22ff 5d				ld e,l 
2300 0e 03			ld c, 3 
2302 cd 9f 0b			call Div8 
2305			 
2305 6f				ld l,a 
2306 26 00			ld h,0 
2308			 
2308				;srl h 
2308				;rr l 
2308			 
2308 cd 60 19				call forth_push_numhl 
230b					NEXTW 
230b c3 51 1b			jp macro_next 
230e				endm 
# End of macro NEXTW
230e			.OVER: 
230e				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
230e 42				db WORD_SYS_CORE+46             
230f 55 23			dw .PAUSE            
2311 05				db 4 + 1 
2312 .. 00			db "OVER",0              
2317				endm 
# End of macro CWHEAD
2317			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2317					if DEBUG_FORTH_WORDS_KEY 
2317						DMARK "OVR" 
2317 f5				push af  
2318 3a 2c 23			ld a, (.dmark)  
231b 32 bd fb			ld (debug_mark),a  
231e 3a 2d 23			ld a, (.dmark+1)  
2321 32 be fb			ld (debug_mark+1),a  
2324 3a 2e 23			ld a, (.dmark+2)  
2327 32 bf fb			ld (debug_mark+2),a  
232a 18 03			jr .pastdmark  
232c ..			.dmark: db "OVR"  
232f f1			.pastdmark: pop af  
2330			endm  
# End of macro DMARK
2330						CALLMONITOR 
2330 cd d3 13			call break_point_state  
2333				endm  
# End of macro CALLMONITOR
2333					endif 
2333			 
2333					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2333 cd fb 19			call macro_dsp_valuehl 
2336				endm 
# End of macro FORTH_DSP_VALUEHL
2336 e5					push hl    ; n2 
2337					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2337 cd 97 1a			call macro_forth_dsp_pop 
233a				endm 
# End of macro FORTH_DSP_POP
233a			 
233a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
233a cd fb 19			call macro_dsp_valuehl 
233d				endm 
# End of macro FORTH_DSP_VALUEHL
233d e5					push hl    ; n1 
233e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
233e cd 97 1a			call macro_forth_dsp_pop 
2341				endm 
# End of macro FORTH_DSP_POP
2341			 
2341 d1					pop de     ; n1 
2342 e1					pop hl     ; n2 
2343			 
2343 d5					push de 
2344 e5					push hl 
2345 d5					push de 
2346			 
2346					; push back  
2346			 
2346 e1					pop hl 
2347 cd 60 19				call forth_push_numhl 
234a e1					pop hl 
234b cd 60 19				call forth_push_numhl 
234e e1					pop hl 
234f cd 60 19				call forth_push_numhl 
2352					NEXTW 
2352 c3 51 1b			jp macro_next 
2355				endm 
# End of macro NEXTW
2355			 
2355			.PAUSE: 
2355				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2355 43				db WORD_SYS_CORE+47             
2356 8a 23			dw .PAUSES            
2358 08				db 7 + 1 
2359 .. 00			db "PAUSEMS",0              
2361				endm 
# End of macro CWHEAD
2361			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2361					if DEBUG_FORTH_WORDS_KEY 
2361						DMARK "PMS" 
2361 f5				push af  
2362 3a 76 23			ld a, (.dmark)  
2365 32 bd fb			ld (debug_mark),a  
2368 3a 77 23			ld a, (.dmark+1)  
236b 32 be fb			ld (debug_mark+1),a  
236e 3a 78 23			ld a, (.dmark+2)  
2371 32 bf fb			ld (debug_mark+2),a  
2374 18 03			jr .pastdmark  
2376 ..			.dmark: db "PMS"  
2379 f1			.pastdmark: pop af  
237a			endm  
# End of macro DMARK
237a						CALLMONITOR 
237a cd d3 13			call break_point_state  
237d				endm  
# End of macro CALLMONITOR
237d					endif 
237d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
237d cd fb 19			call macro_dsp_valuehl 
2380				endm 
# End of macro FORTH_DSP_VALUEHL
2380			;		push hl    ; n2 
2380					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2380 cd 97 1a			call macro_forth_dsp_pop 
2383				endm 
# End of macro FORTH_DSP_POP
2383			;		pop hl 
2383			 
2383 7d					ld a, l 
2384 cd 1f 0a				call aDelayInMS 
2387				       NEXTW 
2387 c3 51 1b			jp macro_next 
238a				endm 
# End of macro NEXTW
238a			.PAUSES:  
238a				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
238a 44				db WORD_SYS_CORE+48             
238b f9 23			dw .ROT            
238d 06				db 5 + 1 
238e .. 00			db "PAUSE",0              
2394				endm 
# End of macro CWHEAD
2394			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2394					if DEBUG_FORTH_WORDS_KEY 
2394						DMARK "PAU" 
2394 f5				push af  
2395 3a a9 23			ld a, (.dmark)  
2398 32 bd fb			ld (debug_mark),a  
239b 3a aa 23			ld a, (.dmark+1)  
239e 32 be fb			ld (debug_mark+1),a  
23a1 3a ab 23			ld a, (.dmark+2)  
23a4 32 bf fb			ld (debug_mark+2),a  
23a7 18 03			jr .pastdmark  
23a9 ..			.dmark: db "PAU"  
23ac f1			.pastdmark: pop af  
23ad			endm  
# End of macro DMARK
23ad						CALLMONITOR 
23ad cd d3 13			call break_point_state  
23b0				endm  
# End of macro CALLMONITOR
23b0					endif 
23b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23b0 cd fb 19			call macro_dsp_valuehl 
23b3				endm 
# End of macro FORTH_DSP_VALUEHL
23b3			;		push hl    ; n2 
23b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23b3 cd 97 1a			call macro_forth_dsp_pop 
23b6				endm 
# End of macro FORTH_DSP_POP
23b6			;		pop hl 
23b6 45					ld b, l 
23b7					if DEBUG_FORTH_WORDS 
23b7						DMARK "PAU" 
23b7 f5				push af  
23b8 3a cc 23			ld a, (.dmark)  
23bb 32 bd fb			ld (debug_mark),a  
23be 3a cd 23			ld a, (.dmark+1)  
23c1 32 be fb			ld (debug_mark+1),a  
23c4 3a ce 23			ld a, (.dmark+2)  
23c7 32 bf fb			ld (debug_mark+2),a  
23ca 18 03			jr .pastdmark  
23cc ..			.dmark: db "PAU"  
23cf f1			.pastdmark: pop af  
23d0			endm  
# End of macro DMARK
23d0						CALLMONITOR 
23d0 cd d3 13			call break_point_state  
23d3				endm  
# End of macro CALLMONITOR
23d3					endif 
23d3 c5			.pauses1:	push bc 
23d4 cd 3a 0a				call delay1s 
23d7 c1					pop bc 
23d8					if DEBUG_FORTH_WORDS 
23d8						DMARK "PA1" 
23d8 f5				push af  
23d9 3a ed 23			ld a, (.dmark)  
23dc 32 bd fb			ld (debug_mark),a  
23df 3a ee 23			ld a, (.dmark+1)  
23e2 32 be fb			ld (debug_mark+1),a  
23e5 3a ef 23			ld a, (.dmark+2)  
23e8 32 bf fb			ld (debug_mark+2),a  
23eb 18 03			jr .pastdmark  
23ed ..			.dmark: db "PA1"  
23f0 f1			.pastdmark: pop af  
23f1			endm  
# End of macro DMARK
23f1						CALLMONITOR 
23f1 cd d3 13			call break_point_state  
23f4				endm  
# End of macro CALLMONITOR
23f4					endif 
23f4 10 dd				djnz .pauses1 
23f6			 
23f6				       NEXTW 
23f6 c3 51 1b			jp macro_next 
23f9				endm 
# End of macro NEXTW
23f9			.ROT: 
23f9				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
23f9 45				db WORD_SYS_CORE+49             
23fa 47 24			dw .UWORDS            
23fc 04				db 3 + 1 
23fd .. 00			db "ROT",0              
2401				endm 
# End of macro CWHEAD
2401			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2401					if DEBUG_FORTH_WORDS_KEY 
2401						DMARK "ROT" 
2401 f5				push af  
2402 3a 16 24			ld a, (.dmark)  
2405 32 bd fb			ld (debug_mark),a  
2408 3a 17 24			ld a, (.dmark+1)  
240b 32 be fb			ld (debug_mark+1),a  
240e 3a 18 24			ld a, (.dmark+2)  
2411 32 bf fb			ld (debug_mark+2),a  
2414 18 03			jr .pastdmark  
2416 ..			.dmark: db "ROT"  
2419 f1			.pastdmark: pop af  
241a			endm  
# End of macro DMARK
241a						CALLMONITOR 
241a cd d3 13			call break_point_state  
241d				endm  
# End of macro CALLMONITOR
241d					endif 
241d			 
241d					FORTH_DSP_VALUEHL 
241d cd fb 19			call macro_dsp_valuehl 
2420				endm 
# End of macro FORTH_DSP_VALUEHL
2420 e5					push hl    ; u3  
2421			 
2421					FORTH_DSP_POP 
2421 cd 97 1a			call macro_forth_dsp_pop 
2424				endm 
# End of macro FORTH_DSP_POP
2424			   
2424					FORTH_DSP_VALUEHL 
2424 cd fb 19			call macro_dsp_valuehl 
2427				endm 
# End of macro FORTH_DSP_VALUEHL
2427 e5					push hl     ; u2 
2428			 
2428					FORTH_DSP_POP 
2428 cd 97 1a			call macro_forth_dsp_pop 
242b				endm 
# End of macro FORTH_DSP_POP
242b			 
242b					FORTH_DSP_VALUEHL 
242b cd fb 19			call macro_dsp_valuehl 
242e				endm 
# End of macro FORTH_DSP_VALUEHL
242e e5					push hl     ; u1 
242f			 
242f					FORTH_DSP_POP 
242f cd 97 1a			call macro_forth_dsp_pop 
2432				endm 
# End of macro FORTH_DSP_POP
2432			 
2432 c1					pop bc      ; u1 
2433 e1					pop hl      ; u2 
2434 d1					pop de      ; u3 
2435			 
2435			 
2435 c5					push bc 
2436 d5					push de 
2437 e5					push hl 
2438			 
2438			 
2438 e1					pop hl 
2439 cd 60 19				call forth_push_numhl 
243c			 
243c e1					pop hl 
243d cd 60 19				call forth_push_numhl 
2440			 
2440 e1					pop hl 
2441 cd 60 19				call forth_push_numhl 
2444					 
2444			 
2444			 
2444			 
2444			 
2444			 
2444				       NEXTW 
2444 c3 51 1b			jp macro_next 
2447				endm 
# End of macro NEXTW
2447			 
2447			.UWORDS: 
2447				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2447 50				db WORD_SYS_CORE+60             
2448 09 25			dw .BP            
244a 07				db 6 + 1 
244b .. 00			db "UWORDS",0              
2452				endm 
# End of macro CWHEAD
2452			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2452			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2452			; | | Following the count are the individual words. 
2452			; | | 
2452			; | | e.g. UWORDS 
2452			; | | BOX DIRLIST 2 
2452			; | |  
2452			; | | Can be used to save the words to storage via: 
2452			; | | UWORDS $01 DO $01 APPEND LOOP 
2452				if DEBUG_FORTH_WORDS_KEY 
2452					DMARK "UWR" 
2452 f5				push af  
2453 3a 67 24			ld a, (.dmark)  
2456 32 bd fb			ld (debug_mark),a  
2459 3a 68 24			ld a, (.dmark+1)  
245c 32 be fb			ld (debug_mark+1),a  
245f 3a 69 24			ld a, (.dmark+2)  
2462 32 bf fb			ld (debug_mark+2),a  
2465 18 03			jr .pastdmark  
2467 ..			.dmark: db "UWR"  
246a f1			.pastdmark: pop af  
246b			endm  
# End of macro DMARK
246b					CALLMONITOR 
246b cd d3 13			call break_point_state  
246e				endm  
# End of macro CALLMONITOR
246e				endif 
246e 21 00 80				ld hl, baseram 
2471					;ld hl, baseusermem 
2471 01 00 00				ld bc, 0    ; start a counter 
2474			 
2474				; skip dict stub 
2474			 
2474 cd a2 1c				call forth_tok_next 
2477			 
2477			 
2477			; while we have words to look for 
2477			 
2477 7e			.douscan:	ld a, (hl)      
2478				if DEBUG_FORTH_WORDS 
2478					DMARK "UWs" 
2478 f5				push af  
2479 3a 8d 24			ld a, (.dmark)  
247c 32 bd fb			ld (debug_mark),a  
247f 3a 8e 24			ld a, (.dmark+1)  
2482 32 be fb			ld (debug_mark+1),a  
2485 3a 8f 24			ld a, (.dmark+2)  
2488 32 bf fb			ld (debug_mark+2),a  
248b 18 03			jr .pastdmark  
248d ..			.dmark: db "UWs"  
2490 f1			.pastdmark: pop af  
2491			endm  
# End of macro DMARK
2491					CALLMONITOR 
2491 cd d3 13			call break_point_state  
2494				endm  
# End of macro CALLMONITOR
2494				endif 
2494 fe 00				cp WORD_SYS_END 
2496 28 4d				jr z, .udone 
2498 fe 01				cp WORD_SYS_UWORD 
249a 20 44				jr nz, .nuword 
249c			 
249c				if DEBUG_FORTH_WORDS 
249c					DMARK "UWu" 
249c f5				push af  
249d 3a b1 24			ld a, (.dmark)  
24a0 32 bd fb			ld (debug_mark),a  
24a3 3a b2 24			ld a, (.dmark+1)  
24a6 32 be fb			ld (debug_mark+1),a  
24a9 3a b3 24			ld a, (.dmark+2)  
24ac 32 bf fb			ld (debug_mark+2),a  
24af 18 03			jr .pastdmark  
24b1 ..			.dmark: db "UWu"  
24b4 f1			.pastdmark: pop af  
24b5			endm  
# End of macro DMARK
24b5					CALLMONITOR 
24b5 cd d3 13			call break_point_state  
24b8				endm  
# End of macro CALLMONITOR
24b8				endif 
24b8					; we have a uword so push its name to the stack 
24b8			 
24b8 e5				   	push hl  ; save so we can move to next dict block 
24b9			 
24b9					; skip opcode 
24b9 23					inc hl  
24ba					; skip next ptr 
24ba 23					inc hl  
24bb 23					inc hl 
24bc					; skip len 
24bc 23					inc hl 
24bd				if DEBUG_FORTH_WORDS 
24bd					DMARK "UWt" 
24bd f5				push af  
24be 3a d2 24			ld a, (.dmark)  
24c1 32 bd fb			ld (debug_mark),a  
24c4 3a d3 24			ld a, (.dmark+1)  
24c7 32 be fb			ld (debug_mark+1),a  
24ca 3a d4 24			ld a, (.dmark+2)  
24cd 32 bf fb			ld (debug_mark+2),a  
24d0 18 03			jr .pastdmark  
24d2 ..			.dmark: db "UWt"  
24d5 f1			.pastdmark: pop af  
24d6			endm  
# End of macro DMARK
24d6					CALLMONITOR 
24d6 cd d3 13			call break_point_state  
24d9				endm  
# End of macro CALLMONITOR
24d9				endif 
24d9 03					inc bc 
24da			 
24da c5					push bc 
24db cd 72 19				call forth_push_str 
24de c1					pop bc 
24df			 
24df e1					pop hl 	 
24e0			 
24e0 cd a2 1c		.nuword:	call forth_tok_next 
24e3 18 92				jr .douscan  
24e5			 
24e5			.udone:		 ; push count of uwords found 
24e5 c5					push bc 
24e6 e1					pop hl 
24e7			 
24e7				if DEBUG_FORTH_WORDS 
24e7					DMARK "UWc" 
24e7 f5				push af  
24e8 3a fc 24			ld a, (.dmark)  
24eb 32 bd fb			ld (debug_mark),a  
24ee 3a fd 24			ld a, (.dmark+1)  
24f1 32 be fb			ld (debug_mark+1),a  
24f4 3a fe 24			ld a, (.dmark+2)  
24f7 32 bf fb			ld (debug_mark+2),a  
24fa 18 03			jr .pastdmark  
24fc ..			.dmark: db "UWc"  
24ff f1			.pastdmark: pop af  
2500			endm  
# End of macro DMARK
2500					CALLMONITOR 
2500 cd d3 13			call break_point_state  
2503				endm  
# End of macro CALLMONITOR
2503				endif 
2503 cd 60 19				call forth_push_numhl 
2506			 
2506			 
2506				       NEXTW 
2506 c3 51 1b			jp macro_next 
2509				endm 
# End of macro NEXTW
2509			 
2509			.BP: 
2509				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2509 54				db WORD_SYS_CORE+64             
250a 3f 25			dw .MONITOR            
250c 03				db 2 + 1 
250d .. 00			db "BP",0              
2510				endm 
# End of macro CWHEAD
2510			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2510			; | | $00 Will enable the break points within specific code paths 
2510			; | | $01 Will disable break points 
2510			; | |  
2510			; | | By default break points are off. Either the above can be used to enable them 
2510			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2510			; | | and on release of the pressed key a message will be disaplayed to notify 
2510			; | | that break points are enabled. Pressing any key will then continue boot process. 
2510					; get byte count 
2510					if DEBUG_FORTH_WORDS_KEY 
2510						DMARK "BP." 
2510 f5				push af  
2511 3a 25 25			ld a, (.dmark)  
2514 32 bd fb			ld (debug_mark),a  
2517 3a 26 25			ld a, (.dmark+1)  
251a 32 be fb			ld (debug_mark+1),a  
251d 3a 27 25			ld a, (.dmark+2)  
2520 32 bf fb			ld (debug_mark+2),a  
2523 18 03			jr .pastdmark  
2525 ..			.dmark: db "BP."  
2528 f1			.pastdmark: pop af  
2529			endm  
# End of macro DMARK
2529						CALLMONITOR 
2529 cd d3 13			call break_point_state  
252c				endm  
# End of macro CALLMONITOR
252c					endif 
252c			 
252c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
252c cd fb 19			call macro_dsp_valuehl 
252f				endm 
# End of macro FORTH_DSP_VALUEHL
252f			 
252f			;		push hl 
252f			 
252f					; destroy value TOS 
252f			 
252f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
252f cd 97 1a			call macro_forth_dsp_pop 
2532				endm 
# End of macro FORTH_DSP_POP
2532			 
2532			;		pop hl 
2532			 
2532 3e 00				ld a,0 
2534 bd					cp l 
2535 28 02				jr z, .bpset 
2537 3e 2a				ld a, '*' 
2539			 
2539 32 b7 ef		.bpset:		ld (os_view_disable), a 
253c			 
253c			 
253c					NEXTW 
253c c3 51 1b			jp macro_next 
253f				endm 
# End of macro NEXTW
253f			 
253f			 
253f			.MONITOR: 
253f				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
253f 55				db WORD_SYS_CORE+65             
2540 72 25			dw .MALLOC            
2542 08				db 7 + 1 
2543 .. 00			db "MONITOR",0              
254b				endm 
# End of macro CWHEAD
254b			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
254b			; | | At start the current various registers will be displayed with contents. 
254b			; | | Top right corner will show the most recent debug marker seen. 
254b			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
254b			; | | and the return stack pointer (RSP). 
254b			; | | Pressing: 
254b			; | |    1 - Initial screen 
254b			; | |    2 - Display a data dump of HL 
254b			; | |    3 - Display a data dump of DE 
254b			; | |    4 - Display a data dump of BC 
254b			; | |    5 - Display a data dump of HL 
254b			; | |    6 - Display a data dump of DSP 
254b			; | |    7 - Display a data dump of RSP 
254b			; | |    8 - Display a data dump of what is at DSP 
254b			; | |    9 - Display a data dump of what is at RSP 
254b			; | |    0 - Exit monitor and continue running. This will also enable break points 
254b			; | |    * - Disable break points 
254b			; | |    # - Enter traditional monitor mode 
254b			; | | 
254b			; | | Monitor Mode 
254b			; | | ------------ 
254b			; | | A prompt of '>' will be shown for various commands: 
254b			; | |    D xxxx - Display a data dump starting from hex address xxxx 
254b			; | |    C - Continue display a data dump from the last set address 
254b			; | |    M xxxx - Set start of memory edit at address xx 
254b			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
254b			; | |    Q - Return to previous 
254b					if DEBUG_FORTH_WORDS_KEY 
254b						DMARK "MON" 
254b f5				push af  
254c 3a 60 25			ld a, (.dmark)  
254f 32 bd fb			ld (debug_mark),a  
2552 3a 61 25			ld a, (.dmark+1)  
2555 32 be fb			ld (debug_mark+1),a  
2558 3a 62 25			ld a, (.dmark+2)  
255b 32 bf fb			ld (debug_mark+2),a  
255e 18 03			jr .pastdmark  
2560 ..			.dmark: db "MON"  
2563 f1			.pastdmark: pop af  
2564			endm  
# End of macro DMARK
2564						CALLMONITOR 
2564 cd d3 13			call break_point_state  
2567				endm  
# End of macro CALLMONITOR
2567					endif 
2567 3e 00				ld a, 0 
2569 32 b7 ef				ld (os_view_disable), a 
256c			 
256c					CALLMONITOR 
256c cd d3 13			call break_point_state  
256f				endm  
# End of macro CALLMONITOR
256f			 
256f			;	call monitor 
256f			 
256f					NEXTW 
256f c3 51 1b			jp macro_next 
2572				endm 
# End of macro NEXTW
2572			 
2572			 
2572			.MALLOC: 
2572				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2572 56				db WORD_SYS_CORE+66             
2573 9b 25			dw .MALLOC2            
2575 06				db 5 + 1 
2576 .. 00			db "ALLOT",0              
257c				endm 
# End of macro CWHEAD
257c			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
257c					if DEBUG_FORTH_WORDS_KEY 
257c						DMARK "ALL" 
257c f5				push af  
257d 3a 91 25			ld a, (.dmark)  
2580 32 bd fb			ld (debug_mark),a  
2583 3a 92 25			ld a, (.dmark+1)  
2586 32 be fb			ld (debug_mark+1),a  
2589 3a 93 25			ld a, (.dmark+2)  
258c 32 bf fb			ld (debug_mark+2),a  
258f 18 03			jr .pastdmark  
2591 ..			.dmark: db "ALL"  
2594 f1			.pastdmark: pop af  
2595			endm  
# End of macro DMARK
2595						CALLMONITOR 
2595 cd d3 13			call break_point_state  
2598				endm  
# End of macro CALLMONITOR
2598					endif 
2598 c3 c2 25				jp .mallocc 
259b			.MALLOC2: 
259b				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
259b 56				db WORD_SYS_CORE+66             
259c d9 25			dw .FREE            
259e 07				db 6 + 1 
259f .. 00			db "MALLOC",0              
25a6				endm 
# End of macro CWHEAD
25a6			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25a6					; get byte count 
25a6					if DEBUG_FORTH_WORDS_KEY 
25a6						DMARK "MAL" 
25a6 f5				push af  
25a7 3a bb 25			ld a, (.dmark)  
25aa 32 bd fb			ld (debug_mark),a  
25ad 3a bc 25			ld a, (.dmark+1)  
25b0 32 be fb			ld (debug_mark+1),a  
25b3 3a bd 25			ld a, (.dmark+2)  
25b6 32 bf fb			ld (debug_mark+2),a  
25b9 18 03			jr .pastdmark  
25bb ..			.dmark: db "MAL"  
25be f1			.pastdmark: pop af  
25bf			endm  
# End of macro DMARK
25bf						CALLMONITOR 
25bf cd d3 13			call break_point_state  
25c2				endm  
# End of macro CALLMONITOR
25c2					endif 
25c2			.mallocc: 
25c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c2 cd fb 19			call macro_dsp_valuehl 
25c5				endm 
# End of macro FORTH_DSP_VALUEHL
25c5			 
25c5			;		push hl 
25c5			 
25c5					; destroy value TOS 
25c5			 
25c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25c5 cd 97 1a			call macro_forth_dsp_pop 
25c8				endm 
# End of macro FORTH_DSP_POP
25c8			 
25c8			;		pop hl 
25c8 cd d6 10				call malloc 
25cb				if DEBUG_FORTH_MALLOC_GUARD 
25cb f5					push af 
25cc cd 38 0c				call ishlzero 
25cf			;		ld a, l 
25cf			;		add h 
25cf			;		cp 0 
25cf f1					pop af 
25d0					 
25d0 cc 9a 4e				call z,malloc_error 
25d3				endif 
25d3			 
25d3 cd 60 19				call forth_push_numhl 
25d6					NEXTW 
25d6 c3 51 1b			jp macro_next 
25d9				endm 
# End of macro NEXTW
25d9			 
25d9			.FREE: 
25d9				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
25d9 57				db WORD_SYS_CORE+67             
25da 0a 26			dw .LIST            
25dc 05				db 4 + 1 
25dd .. 00			db "FREE",0              
25e2				endm 
# End of macro CWHEAD
25e2			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
25e2					if DEBUG_FORTH_WORDS_KEY 
25e2						DMARK "FRE" 
25e2 f5				push af  
25e3 3a f7 25			ld a, (.dmark)  
25e6 32 bd fb			ld (debug_mark),a  
25e9 3a f8 25			ld a, (.dmark+1)  
25ec 32 be fb			ld (debug_mark+1),a  
25ef 3a f9 25			ld a, (.dmark+2)  
25f2 32 bf fb			ld (debug_mark+2),a  
25f5 18 03			jr .pastdmark  
25f7 ..			.dmark: db "FRE"  
25fa f1			.pastdmark: pop af  
25fb			endm  
# End of macro DMARK
25fb						CALLMONITOR 
25fb cd d3 13			call break_point_state  
25fe				endm  
# End of macro CALLMONITOR
25fe					endif 
25fe					; get address 
25fe			 
25fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fe cd fb 19			call macro_dsp_valuehl 
2601				endm 
# End of macro FORTH_DSP_VALUEHL
2601			 
2601			;		push hl 
2601			 
2601					; destroy value TOS 
2601			 
2601					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2601 cd 97 1a			call macro_forth_dsp_pop 
2604				endm 
# End of macro FORTH_DSP_POP
2604			 
2604			;		pop hl 
2604			if FORTH_ENABLE_MALLOCFREE 
2604 cd a0 11				call free 
2607			endif 
2607					NEXTW 
2607 c3 51 1b			jp macro_next 
260a				endm 
# End of macro NEXTW
260a			.LIST: 
260a				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
260a 5c				db WORD_SYS_CORE+72             
260b cd 27			dw .FORGET            
260d 05				db 4 + 1 
260e .. 00			db "LIST",0              
2613				endm 
# End of macro CWHEAD
2613			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2613			; | | The quoted word must be in upper case. 
2613				if DEBUG_FORTH_WORDS_KEY 
2613					DMARK "LST" 
2613 f5				push af  
2614 3a 28 26			ld a, (.dmark)  
2617 32 bd fb			ld (debug_mark),a  
261a 3a 29 26			ld a, (.dmark+1)  
261d 32 be fb			ld (debug_mark+1),a  
2620 3a 2a 26			ld a, (.dmark+2)  
2623 32 bf fb			ld (debug_mark+2),a  
2626 18 03			jr .pastdmark  
2628 ..			.dmark: db "LST"  
262b f1			.pastdmark: pop af  
262c			endm  
# End of macro DMARK
262c					CALLMONITOR 
262c cd d3 13			call break_point_state  
262f				endm  
# End of macro CALLMONITOR
262f				endif 
262f			 
262f					FORTH_DSP_VALUEHL 
262f cd fb 19			call macro_dsp_valuehl 
2632				endm 
# End of macro FORTH_DSP_VALUEHL
2632			 
2632 e5					push hl 
2633 c1					pop bc 
2634			 
2634			; Start format of scratch string 
2634			 
2634 21 b8 ef				ld hl, scratch 
2637			 
2637 3e 3a				ld a, ':' 
2639 77					ld (hl),a 
263a 23					inc hl 
263b 3e 20				ld a, ' ' 
263d 77					ld (hl), a 
263e			 
263e					; Get ptr to the word we need to look up 
263e			 
263e			;		FORTH_DSP_VALUEHL 
263e					;v5 FORTH_DSP_VALUE 
263e				; TODO type check 
263e			;		inc hl    ; Skip type check  
263e			;		push hl 
263e			;		ex de, hl    ; put into DE 
263e			 
263e			 
263e 21 00 80				ld hl, baseram 
2641					;ld hl, baseusermem 
2641			 
2641 e5			push hl   ; sacreifical push 
2642			 
2642			.ldouscanm: 
2642 e1				pop hl 
2643			.ldouscan: 
2643				if DEBUG_FORTH_WORDS 
2643					DMARK "LSs" 
2643 f5				push af  
2644 3a 58 26			ld a, (.dmark)  
2647 32 bd fb			ld (debug_mark),a  
264a 3a 59 26			ld a, (.dmark+1)  
264d 32 be fb			ld (debug_mark+1),a  
2650 3a 5a 26			ld a, (.dmark+2)  
2653 32 bf fb			ld (debug_mark+2),a  
2656 18 03			jr .pastdmark  
2658 ..			.dmark: db "LSs"  
265b f1			.pastdmark: pop af  
265c			endm  
# End of macro DMARK
265c					CALLMONITOR 
265c cd d3 13			call break_point_state  
265f				endm  
# End of macro CALLMONITOR
265f				endif 
265f				; skip dict stub 
265f cd a2 1c				call forth_tok_next 
2662			 
2662			 
2662			; while we have words to look for 
2662			 
2662 7e				ld a, (hl)      
2663				if DEBUG_FORTH_WORDS 
2663					DMARK "LSk" 
2663 f5				push af  
2664 3a 78 26			ld a, (.dmark)  
2667 32 bd fb			ld (debug_mark),a  
266a 3a 79 26			ld a, (.dmark+1)  
266d 32 be fb			ld (debug_mark+1),a  
2670 3a 7a 26			ld a, (.dmark+2)  
2673 32 bf fb			ld (debug_mark+2),a  
2676 18 03			jr .pastdmark  
2678 ..			.dmark: db "LSk"  
267b f1			.pastdmark: pop af  
267c			endm  
# End of macro DMARK
267c					CALLMONITOR 
267c cd d3 13			call break_point_state  
267f				endm  
# End of macro CALLMONITOR
267f				endif 
267f fe 00				cp WORD_SYS_END 
2681 ca b4 27				jp z, .lunotfound 
2684 fe 01				cp WORD_SYS_UWORD 
2686 c2 43 26				jp nz, .ldouscan 
2689			 
2689				if DEBUG_FORTH_WORDS 
2689					DMARK "LSu" 
2689 f5				push af  
268a 3a 9e 26			ld a, (.dmark)  
268d 32 bd fb			ld (debug_mark),a  
2690 3a 9f 26			ld a, (.dmark+1)  
2693 32 be fb			ld (debug_mark+1),a  
2696 3a a0 26			ld a, (.dmark+2)  
2699 32 bf fb			ld (debug_mark+2),a  
269c 18 03			jr .pastdmark  
269e ..			.dmark: db "LSu"  
26a1 f1			.pastdmark: pop af  
26a2			endm  
# End of macro DMARK
26a2					CALLMONITOR 
26a2 cd d3 13			call break_point_state  
26a5				endm  
# End of macro CALLMONITOR
26a5				endif 
26a5			 
26a5					; found a uword but is it the one we want... 
26a5			 
26a5 c5					push bc     ; uword to find is on bc 
26a6 d1					pop de 
26a7			 
26a7 e5					push hl  ; to save the ptr 
26a8			 
26a8					; skip opcode 
26a8 23					inc hl  
26a9					; skip next ptr 
26a9 23					inc hl  
26aa 23					inc hl 
26ab					; skip len 
26ab 23					inc hl 
26ac			 
26ac				if DEBUG_FORTH_WORDS 
26ac					DMARK "LSc" 
26ac f5				push af  
26ad 3a c1 26			ld a, (.dmark)  
26b0 32 bd fb			ld (debug_mark),a  
26b3 3a c2 26			ld a, (.dmark+1)  
26b6 32 be fb			ld (debug_mark+1),a  
26b9 3a c3 26			ld a, (.dmark+2)  
26bc 32 bf fb			ld (debug_mark+2),a  
26bf 18 03			jr .pastdmark  
26c1 ..			.dmark: db "LSc"  
26c4 f1			.pastdmark: pop af  
26c5			endm  
# End of macro DMARK
26c5					CALLMONITOR 
26c5 cd d3 13			call break_point_state  
26c8				endm  
# End of macro CALLMONITOR
26c8				endif 
26c8 cd a5 10				call strcmp 
26cb c2 42 26				jp nz, .ldouscanm 
26ce				 
26ce			 
26ce			 
26ce					; we have a uword so push its name to the stack 
26ce			 
26ce			;	   	push hl  ; save so we can move to next dict block 
26ce e1			pop hl 
26cf			 
26cf				if DEBUG_FORTH_WORDS 
26cf					DMARK "LSm" 
26cf f5				push af  
26d0 3a e4 26			ld a, (.dmark)  
26d3 32 bd fb			ld (debug_mark),a  
26d6 3a e5 26			ld a, (.dmark+1)  
26d9 32 be fb			ld (debug_mark+1),a  
26dc 3a e6 26			ld a, (.dmark+2)  
26df 32 bf fb			ld (debug_mark+2),a  
26e2 18 03			jr .pastdmark  
26e4 ..			.dmark: db "LSm"  
26e7 f1			.pastdmark: pop af  
26e8			endm  
# End of macro DMARK
26e8					CALLMONITOR 
26e8 cd d3 13			call break_point_state  
26eb				endm  
# End of macro CALLMONITOR
26eb				endif 
26eb			 
26eb					; skip opcode 
26eb 23					inc hl  
26ec					; skip next ptr 
26ec 23					inc hl  
26ed 23					inc hl 
26ee					; skip len 
26ee 7e					ld a, (hl)   ; save length to add 
26ef				if DEBUG_FORTH_WORDS 
26ef					DMARK "LS2" 
26ef f5				push af  
26f0 3a 04 27			ld a, (.dmark)  
26f3 32 bd fb			ld (debug_mark),a  
26f6 3a 05 27			ld a, (.dmark+1)  
26f9 32 be fb			ld (debug_mark+1),a  
26fc 3a 06 27			ld a, (.dmark+2)  
26ff 32 bf fb			ld (debug_mark+2),a  
2702 18 03			jr .pastdmark  
2704 ..			.dmark: db "LS2"  
2707 f1			.pastdmark: pop af  
2708			endm  
# End of macro DMARK
2708					CALLMONITOR 
2708 cd d3 13			call break_point_state  
270b				endm  
# End of macro CALLMONITOR
270b				endif 
270b			 
270b					; save this location 
270b				 
270b e5					push hl 
270c			 
270c 23					inc hl 
270d 11 ba ef				ld de, scratch+2 
2710 4f					ld c, a 
2711 06 00				ld b, 0 
2713			 
2713				if DEBUG_FORTH_WORDS 
2713					DMARK "LSn" 
2713 f5				push af  
2714 3a 28 27			ld a, (.dmark)  
2717 32 bd fb			ld (debug_mark),a  
271a 3a 29 27			ld a, (.dmark+1)  
271d 32 be fb			ld (debug_mark+1),a  
2720 3a 2a 27			ld a, (.dmark+2)  
2723 32 bf fb			ld (debug_mark+2),a  
2726 18 03			jr .pastdmark  
2728 ..			.dmark: db "LSn"  
272b f1			.pastdmark: pop af  
272c			endm  
# End of macro DMARK
272c					CALLMONITOR 
272c cd d3 13			call break_point_state  
272f				endm  
# End of macro CALLMONITOR
272f				endif 
272f			 
272f					; copy uword name to scratch 
272f			 
272f ed b0				ldir 
2731			 
2731 1b					dec de 
2732 3e 20				ld a, ' '    ; change null to space 
2734 12					ld (de), a 
2735			 
2735 13					inc de 
2736			 
2736 d5					push de 
2737 c1					pop bc     ; move scratch pointer to end of word name and save it 
2738			 
2738 e1					pop hl 
2739 7e					ld a, (hl) 
273a					;inc hl 
273a					; skip word string 
273a cd 0f 0c				call addatohl 
273d			 
273d 23					inc hl 
273e			 
273e				if DEBUG_FORTH_WORDS 
273e					DMARK "LS3" 
273e f5				push af  
273f 3a 53 27			ld a, (.dmark)  
2742 32 bd fb			ld (debug_mark),a  
2745 3a 54 27			ld a, (.dmark+1)  
2748 32 be fb			ld (debug_mark+1),a  
274b 3a 55 27			ld a, (.dmark+2)  
274e 32 bf fb			ld (debug_mark+2),a  
2751 18 03			jr .pastdmark  
2753 ..			.dmark: db "LS3"  
2756 f1			.pastdmark: pop af  
2757			endm  
# End of macro DMARK
2757					CALLMONITOR 
2757 cd d3 13			call break_point_state  
275a				endm  
# End of macro CALLMONITOR
275a				endif 
275a					; should now be at the start of the machine code to setup the eval of the uword 
275a					; now locate the ptr to the string defintion 
275a			 
275a					; skip ld hl, 
275a					; then load the ptr 
275a			 
275a 23					inc hl 
275b 5e					ld e, (hl) 
275c 23					inc hl 
275d 56					ld d, (hl) 
275e eb					ex de, hl 
275f			 
275f			 
275f				if DEBUG_FORTH_WORDS 
275f					DMARK "LSt" 
275f f5				push af  
2760 3a 74 27			ld a, (.dmark)  
2763 32 bd fb			ld (debug_mark),a  
2766 3a 75 27			ld a, (.dmark+1)  
2769 32 be fb			ld (debug_mark+1),a  
276c 3a 76 27			ld a, (.dmark+2)  
276f 32 bf fb			ld (debug_mark+2),a  
2772 18 03			jr .pastdmark  
2774 ..			.dmark: db "LSt"  
2777 f1			.pastdmark: pop af  
2778			endm  
# End of macro DMARK
2778					CALLMONITOR 
2778 cd d3 13			call break_point_state  
277b				endm  
# End of macro CALLMONITOR
277b				endif 
277b			 
277b			; cant push right now due to tokenised strings  
277b			 
277b			; get the destination of where to copy this definition to. 
277b			 
277b c5					push bc 
277c d1					pop de 
277d			 
277d 7e			.listl:         ld a,(hl) 
277e fe 00				cp 0 
2780 28 09				jr z, .lreplsp     ; replace zero with space 
2782 fe 7f				cp FORTH_END_BUFFER 
2784 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2786				 
2786					; just copy this char as is then 
2786			 
2786 12					ld (de), a 
2787			 
2787 23			.listnxt:	inc hl 
2788 13					inc de 
2789 18 f2				jr .listl 
278b			 
278b 3e 20		.lreplsp:	ld a,' ' 
278d 12					ld (de), a 
278e 18 f7				jr .listnxt 
2790			 
2790			; close up uword def 
2790			 
2790			.listdone: 
2790 3e 00				ld a, 0 
2792 12					ld (de), a 
2793			 
2793			; now have def so clean up and push to stack 
2793			 
2793 21 b8 ef				ld hl, scratch 
2796				if DEBUG_FORTH_WORDS 
2796					DMARK "Ltp" 
2796 f5				push af  
2797 3a ab 27			ld a, (.dmark)  
279a 32 bd fb			ld (debug_mark),a  
279d 3a ac 27			ld a, (.dmark+1)  
27a0 32 be fb			ld (debug_mark+1),a  
27a3 3a ad 27			ld a, (.dmark+2)  
27a6 32 bf fb			ld (debug_mark+2),a  
27a9 18 03			jr .pastdmark  
27ab ..			.dmark: db "Ltp"  
27ae f1			.pastdmark: pop af  
27af			endm  
# End of macro DMARK
27af					CALLMONITOR 
27af cd d3 13			call break_point_state  
27b2				endm  
# End of macro CALLMONITOR
27b2				endif 
27b2			 
27b2 18 06			jr .listpush 
27b4			 
27b4			;.lnuword:	pop hl 
27b4			;		call forth_tok_next 
27b4			;		jp .ldouscan  
27b4			 
27b4			.lunotfound:		  
27b4			 
27b4			 
27b4					 
27b4					FORTH_DSP_POP 
27b4 cd 97 1a			call macro_forth_dsp_pop 
27b7				endm 
# End of macro FORTH_DSP_POP
27b7 21 c0 27				ld hl, .luno 
27ba						 
27ba			 
27ba			.listpush: 
27ba cd 72 19				call forth_push_str 
27bd			 
27bd			 
27bd			 
27bd					NEXTW 
27bd c3 51 1b			jp macro_next 
27c0				endm 
# End of macro NEXTW
27c0			 
27c0 .. 00		.luno:    db "Not found",0 
27ca			 
27ca			 
27ca			 
27ca			 
27ca			 
27ca			;		push hl   ; save pointer to start of uword def string 
27ca			; 
27ca			;; look for FORTH_EOL_LINE 
27ca			;		ld a, FORTH_END_BUFFER 
27ca			;		call strlent 
27ca			; 
27ca			;		inc hl		 ; space for coln def 
27ca			;		inc hl 
27ca			;		inc hl          ; space for terms 
27ca			;		inc hl 
27ca			; 
27ca			;		ld a, 20   ; TODO get actual length 
27ca			;		call addatohl    ; include a random amount of room for the uword name 
27ca			; 
27ca			;		 
27ca			;	if DEBUG_FORTH_WORDS 
27ca			;		DMARK "Lt1" 
27ca			;		CALLMONITOR 
27ca			;	endif 
27ca			;		 
27ca			; 
27ca			;; malloc space for the string because we cant change it 
27ca			; 
27ca			;		call malloc 
27ca			;	if DEBUG_FORTH_MALLOC_GUARD 
27ca			;		push af 
27ca			;		call ishlzero 
27ca			;		pop af 
27ca			;		 
27ca			;		call z,malloc_error 
27ca			;	endif 
27ca			; 
27ca			;	if DEBUG_FORTH_WORDS 
27ca			;		DMARK "Lt2" 
27ca			;		CALLMONITOR 
27ca			;	endif 
27ca			;		pop de 
27ca			;		push hl    ; push the malloc to release later 
27ca			;		push hl   ;  push back a copy for the later stack push 
27ca			;		 
27ca			;; copy the string swapping out the zero terms for spaces 
27ca			; 
27ca			;		; de has our source 
27ca			;		; hl has our dest 
27ca			; 
27ca			;; add the coln def 
27ca			; 
27ca			;		ld a, ':' 
27ca			;		ld (hl), a 
27ca			;		inc hl 
27ca			;		ld a, ' ' 
27ca			;		ld (hl), a 
27ca			;		inc hl 
27ca			; 
27ca			;; add the uname word 
27ca			;		push de   ; save our string for now 
27ca			;		ex de, hl 
27ca			; 
27ca			;		FORTH_DSP_VALUE 
27ca			;		;v5 FORTH_DSP_VALUE 
27ca			; 
27ca			;		inc hl   ; skip type but we know by now this is OK 
27ca			; 
27ca			;.luword:	ld a,(hl) 
27ca			;		cp 0 
27ca			;		jr z, .luword2 
27ca			;		ld (de), a 
27ca			;		inc de 
27ca			;		inc hl 
27ca			;		jr .luword 
27ca			; 
27ca			;.luword2:	ld a, ' ' 
27ca			;		ld (de), a 
27ca			;;		inc hl 
27ca			;;		inc de 
27ca			;;		ld (de), a 
27ca			;;		inc hl 
27ca			;		inc de 
27ca			; 
27ca			;		ex de, hl 
27ca			;		pop de 
27ca			;		 
27ca			;		 
27ca			; 
27ca			;; detoken that string and copy it 
27ca			; 
27ca			;	if DEBUG_FORTH_WORDS 
27ca			;		DMARK "Lt2" 
27ca			;		CALLMONITOR 
27ca			;	endif 
27ca			;.ldetok:	ld a, (de) 
27ca			;		cp FORTH_END_BUFFER 
27ca			;		jr z, .ldetokend 
27ca			;		; swap out any zero term for space 
27ca			;		cp 0 
27ca			;		jr nz, .ldetoknext 
27ca			;		ld a, ' ' 
27ca			; 
27ca			;	if DEBUG_FORTH_WORDS 
27ca			;		DMARK "LtS" 
27ca			;		CALLMONITOR 
27ca			;	endif 
27ca			;.ldetoknext:	ld (hl), a 
27ca			;		inc de 
27ca			;		inc hl 
27ca			;		jr .ldetok 
27ca			; 
27ca			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
27ca			;		ld (hl), a  
27ca			; 
27ca			;; free that temp malloc 
27ca			; 
27ca			;		pop hl    
27ca			; 
27ca			;	if DEBUG_FORTH_WORDS 
27ca			;		DMARK "Lt4" 
27ca			;		CALLMONITOR 
27ca			;	endif 
27ca			;		call forth_apushstrhl 
27ca			; 
27ca			;		; get rid of temp malloc area 
27ca			; 
27ca			;		pop hl 
27ca			;		call free 
27ca			; 
27ca			;		jr .ludone 
27ca			; 
27ca			;.lnuword:	pop hl 
27ca			;		call forth_tok_next 
27ca			;		jp .ldouscan  
27ca			; 
27ca			;.ludone:		 pop hl 
27ca			; 
27ca					NEXTW 
27ca c3 51 1b			jp macro_next 
27cd				endm 
# End of macro NEXTW
27cd			 
27cd			.FORGET: 
27cd				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
27cd 5d				db WORD_SYS_CORE+73             
27ce 46 28			dw .NOP            
27d0 07				db 6 + 1 
27d1 .. 00			db "FORGET",0              
27d8				endm 
# End of macro CWHEAD
27d8			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
27d8			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
27d8			; | |  
27d8			; | | e.g. "MORE" forget 
27d8					if DEBUG_FORTH_WORDS_KEY 
27d8						DMARK "FRG" 
27d8 f5				push af  
27d9 3a ed 27			ld a, (.dmark)  
27dc 32 bd fb			ld (debug_mark),a  
27df 3a ee 27			ld a, (.dmark+1)  
27e2 32 be fb			ld (debug_mark+1),a  
27e5 3a ef 27			ld a, (.dmark+2)  
27e8 32 bf fb			ld (debug_mark+2),a  
27eb 18 03			jr .pastdmark  
27ed ..			.dmark: db "FRG"  
27f0 f1			.pastdmark: pop af  
27f1			endm  
# End of macro DMARK
27f1						CALLMONITOR 
27f1 cd d3 13			call break_point_state  
27f4				endm  
# End of macro CALLMONITOR
27f4					endif 
27f4			 
27f4				; find uword 
27f4			        ; update start of word with "_" 
27f4				; replace uword with deleted flag 
27f4			 
27f4			 
27f4			;	if DEBUG_FORTH_WORDS 
27f4			;		DMARK "FOG" 
27f4			;		CALLMONITOR 
27f4			;	endif 
27f4			 
27f4			 
27f4					; Get ptr to the word we need to look up 
27f4			 
27f4					FORTH_DSP_VALUEHL 
27f4 cd fb 19			call macro_dsp_valuehl 
27f7				endm 
# End of macro FORTH_DSP_VALUEHL
27f7					;v5 FORTH_DSP_VALUE 
27f7				; TODO type check 
27f7			;		inc hl    ; Skip type check  
27f7 e5					push hl 
27f8 c1					pop bc 
27f9			;		ex de, hl    ; put into DE 
27f9			 
27f9			 
27f9 21 00 80				ld hl, baseram 
27fc					;ld hl, baseusermem 
27fc			 
27fc				; skip dict stub 
27fc			;	call forth_tok_next 
27fc e5			push hl   ; sacreifical push 
27fd			 
27fd			.fldouscanm: 
27fd e1				pop hl 
27fe			.fldouscan: 
27fe			;	if DEBUG_FORTH_WORDS 
27fe			;		DMARK "LSs" 
27fe			;		CALLMONITOR 
27fe			;	endif 
27fe				; skip dict stub 
27fe cd a2 1c				call forth_tok_next 
2801			 
2801			 
2801			; while we have words to look for 
2801			 
2801 7e				ld a, (hl)      
2802			;	if DEBUG_FORTH_WORDS 
2802			;		DMARK "LSk" 
2802			;		CALLMONITOR 
2802			;	endif 
2802 fe 00				cp WORD_SYS_END 
2804 ca 40 28				jp z, .flunotfound 
2807 fe 01				cp WORD_SYS_UWORD 
2809 c2 fe 27				jp nz, .fldouscan 
280c			 
280c			;	if DEBUG_FORTH_WORDS 
280c			;		DMARK "LSu" 
280c			;		CALLMONITOR 
280c			;	endif 
280c			 
280c					; found a uword but is it the one we want... 
280c			 
280c c5					push bc     ; uword to find is on bc 
280d d1					pop de 
280e			 
280e e5					push hl  ; to save the ptr 
280f			 
280f					; skip opcode 
280f 23					inc hl  
2810					; skip next ptr 
2810 23					inc hl  
2811 23					inc hl 
2812					; skip len 
2812 23					inc hl 
2813			 
2813			;	if DEBUG_FORTH_WORDS 
2813			;		DMARK "LSc" 
2813			;		CALLMONITOR 
2813			;	endif 
2813 cd a5 10				call strcmp 
2816 c2 fd 27				jp nz, .fldouscanm 
2819			; 
2819			; 
2819			;; while we have words to look for 
2819			; 
2819			;.fdouscan:	ld a, (hl)      
2819			;	if DEBUG_FORTH_WORDS 
2819			;		DMARK "LSs" 
2819			;		CALLMONITOR 
2819			;	endif 
2819			;		cp WORD_SYS_END 
2819			;		jp z, .fudone 
2819			;		cp WORD_SYS_UWORD 
2819			;		jp nz, .fnuword 
2819			; 
2819			;	if DEBUG_FORTH_WORDS 
2819			;		DMARK "FGu" 
2819			;		CALLMONITOR 
2819			;	endif 
2819			; 
2819			;		; found a uword but is it the one we want... 
2819			; 
2819			; 
2819			;	        pop de   ; get back the dsp name 
2819			;		push de 
2819			; 
2819			;		push hl  ; to save the ptr 
2819			; 
2819			;		; skip opcode 
2819			;		inc hl  
2819			;		; skip next ptr 
2819			;		inc hl  
2819			;		inc hl 
2819			;		; skip len 
2819			;		inc hl 
2819			; 
2819			;	if DEBUG_FORTH_WORDS 
2819			;		DMARK "FGc" 
2819			;		CALLMONITOR 
2819			;	endif 
2819			;		call strcmp 
2819			;		jp nz, .fnuword 
2819			 
2819			 
2819 e1			pop hl 
281a			 
281a				 
281a				if DEBUG_FORTH_WORDS 
281a					DMARK "FGm" 
281a f5				push af  
281b 3a 2f 28			ld a, (.dmark)  
281e 32 bd fb			ld (debug_mark),a  
2821 3a 30 28			ld a, (.dmark+1)  
2824 32 be fb			ld (debug_mark+1),a  
2827 3a 31 28			ld a, (.dmark+2)  
282a 32 bf fb			ld (debug_mark+2),a  
282d 18 03			jr .pastdmark  
282f ..			.dmark: db "FGm"  
2832 f1			.pastdmark: pop af  
2833			endm  
# End of macro DMARK
2833					CALLMONITOR 
2833 cd d3 13			call break_point_state  
2836				endm  
# End of macro CALLMONITOR
2836				endif 
2836			 
2836			 
2836			 
2836					; we have a uword so push its name to the stack 
2836			 
2836			;	   	push hl  ; save so we can move to next dict block 
2836			;pop hl 
2836			 
2836					; update opcode to deleted 
2836 3e 03				ld a, WORD_SYS_DELETED 
2838 77					ld (hl), a 
2839			 
2839 23					inc hl  
283a					; skip next ptr 
283a 23					inc hl  
283b 23					inc hl 
283c					; skip len 
283c 23					inc hl 
283d			 
283d					; TODO change parser to skip deleted words but for now mark it out 
283d 3e 5f				ld a, "_" 
283f 77					ld  (hl),a 
2840			 
2840			;		jr .fudone 
2840			; 
2840			;.fnuword:	pop hl 
2840			;		call forth_tok_next 
2840			;		jp .fdouscan  
2840			 
2840			.flunotfound:		  
2840			 
2840			 
2840					 
2840					FORTH_DSP_POP 
2840 cd 97 1a			call macro_forth_dsp_pop 
2843				endm 
# End of macro FORTH_DSP_POP
2843			;		ld hl, .luno 
2843			;.fudone:		 pop hl 
2843					NEXTW 
2843 c3 51 1b			jp macro_next 
2846				endm 
# End of macro NEXTW
2846			.NOP: 
2846				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2846 61				db WORD_SYS_CORE+77             
2847 6d 28			dw .COMO            
2849 04				db 3 + 1 
284a .. 00			db "NOP",0              
284e				endm 
# End of macro CWHEAD
284e			; | NOP (  --  ) Do nothing | DONE 
284e					if DEBUG_FORTH_WORDS_KEY 
284e						DMARK "NOP" 
284e f5				push af  
284f 3a 63 28			ld a, (.dmark)  
2852 32 bd fb			ld (debug_mark),a  
2855 3a 64 28			ld a, (.dmark+1)  
2858 32 be fb			ld (debug_mark+1),a  
285b 3a 65 28			ld a, (.dmark+2)  
285e 32 bf fb			ld (debug_mark+2),a  
2861 18 03			jr .pastdmark  
2863 ..			.dmark: db "NOP"  
2866 f1			.pastdmark: pop af  
2867			endm  
# End of macro DMARK
2867						CALLMONITOR 
2867 cd d3 13			call break_point_state  
286a				endm  
# End of macro CALLMONITOR
286a					endif 
286a				       NEXTW 
286a c3 51 1b			jp macro_next 
286d				endm 
# End of macro NEXTW
286d			.COMO: 
286d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
286d 6e				db WORD_SYS_CORE+90             
286e bf 28			dw .COMC            
2870 02				db 1 + 1 
2871 .. 00			db "(",0              
2873				endm 
# End of macro CWHEAD
2873			; | ( ( -- )  Start of comment | DONE 
2873			 
2873			 
2873 2a b9 f2				ld hl, ( os_tok_ptr) 
2876 11 ba 28			ld de, .closepar 
2879					 
2879					if DEBUG_FORTH_WORDS 
2879						DMARK ").." 
2879 f5				push af  
287a 3a 8e 28			ld a, (.dmark)  
287d 32 bd fb			ld (debug_mark),a  
2880 3a 8f 28			ld a, (.dmark+1)  
2883 32 be fb			ld (debug_mark+1),a  
2886 3a 90 28			ld a, (.dmark+2)  
2889 32 bf fb			ld (debug_mark+2),a  
288c 18 03			jr .pastdmark  
288e ..			.dmark: db ").."  
2891 f1			.pastdmark: pop af  
2892			endm  
# End of macro DMARK
2892						CALLMONITOR 
2892 cd d3 13			call break_point_state  
2895				endm  
# End of macro CALLMONITOR
2895					endif 
2895 cd 6c 1c			call findnexttok  
2898			 
2898					if DEBUG_FORTH_WORDS 
2898						DMARK "IF5" 
2898 f5				push af  
2899 3a ad 28			ld a, (.dmark)  
289c 32 bd fb			ld (debug_mark),a  
289f 3a ae 28			ld a, (.dmark+1)  
28a2 32 be fb			ld (debug_mark+1),a  
28a5 3a af 28			ld a, (.dmark+2)  
28a8 32 bf fb			ld (debug_mark+2),a  
28ab 18 03			jr .pastdmark  
28ad ..			.dmark: db "IF5"  
28b0 f1			.pastdmark: pop af  
28b1			endm  
# End of macro DMARK
28b1						CALLMONITOR 
28b1 cd d3 13			call break_point_state  
28b4				endm  
# End of macro CALLMONITOR
28b4					endif 
28b4				; replace below with ) exec using tok_ptr 
28b4 22 b9 f2			ld (os_tok_ptr), hl 
28b7 c3 e2 1b			jp exec1 
28ba			 
28ba .. 00			.closepar:   db ")",0 
28bc			 
28bc				       NEXTW 
28bc c3 51 1b			jp macro_next 
28bf				endm 
# End of macro NEXTW
28bf			.COMC: 
28bf				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
28bf 6f				db WORD_SYS_CORE+91             
28c0 c8 28			dw .SCRATCH            
28c2 02				db 1 + 1 
28c3 .. 00			db ")",0              
28c5				endm 
# End of macro CWHEAD
28c5			; | ) ( -- )  End of comment |  DONE  
28c5				       NEXTW 
28c5 c3 51 1b			jp macro_next 
28c8				endm 
# End of macro NEXTW
28c8			 
28c8			.SCRATCH: 
28c8				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
28c8 6f				db WORD_SYS_CORE+91             
28c9 03 29			dw .INC            
28cb 08				db 7 + 1 
28cc .. 00			db "SCRATCH",0              
28d4				endm 
# End of macro CWHEAD
28d4			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
28d4			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
28d4			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
28d4			; | |  
28d4			; | | e.g.    : score $00 scratch ; 
28d4			; | |  
28d4			; | | $00 score ! 
28d4			; | | $01 score +! 
28d4			; | |  
28d4			; | | e.g.   : varword $0a scratch ;  
28d4			; | | 
28d4			; | | $8000 varword ! 
28d4					if DEBUG_FORTH_WORDS_KEY 
28d4						DMARK "SCR" 
28d4 f5				push af  
28d5 3a e9 28			ld a, (.dmark)  
28d8 32 bd fb			ld (debug_mark),a  
28db 3a ea 28			ld a, (.dmark+1)  
28de 32 be fb			ld (debug_mark+1),a  
28e1 3a eb 28			ld a, (.dmark+2)  
28e4 32 bf fb			ld (debug_mark+2),a  
28e7 18 03			jr .pastdmark  
28e9 ..			.dmark: db "SCR"  
28ec f1			.pastdmark: pop af  
28ed			endm  
# End of macro DMARK
28ed						CALLMONITOR 
28ed cd d3 13			call break_point_state  
28f0				endm  
# End of macro CALLMONITOR
28f0					endif 
28f0			 
28f0					FORTH_DSP_VALUEHL 
28f0 cd fb 19			call macro_dsp_valuehl 
28f3				endm 
# End of macro FORTH_DSP_VALUEHL
28f3				 
28f3					FORTH_DSP_POP 
28f3 cd 97 1a			call macro_forth_dsp_pop 
28f6				endm 
# End of macro FORTH_DSP_POP
28f6			 
28f6 7d					ld a, l 
28f7 21 dd f4				ld hl, os_var_array 
28fa cd 0f 0c				call addatohl 
28fd			 
28fd cd 60 19				call forth_push_numhl 
2900			 
2900				       NEXTW 
2900 c3 51 1b			jp macro_next 
2903				endm 
# End of macro NEXTW
2903			 
2903			.INC: 
2903				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2903 6f				db WORD_SYS_CORE+91             
2904 57 29			dw .DEC            
2906 03				db 2 + 1 
2907 .. 00			db "+!",0              
290a				endm 
# End of macro CWHEAD
290a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
290a					if DEBUG_FORTH_WORDS_KEY 
290a						DMARK "+s_" 
290a f5				push af  
290b 3a 1f 29			ld a, (.dmark)  
290e 32 bd fb			ld (debug_mark),a  
2911 3a 20 29			ld a, (.dmark+1)  
2914 32 be fb			ld (debug_mark+1),a  
2917 3a 21 29			ld a, (.dmark+2)  
291a 32 bf fb			ld (debug_mark+2),a  
291d 18 03			jr .pastdmark  
291f ..			.dmark: db "+s_"  
2922 f1			.pastdmark: pop af  
2923			endm  
# End of macro DMARK
2923						CALLMONITOR 
2923 cd d3 13			call break_point_state  
2926				endm  
# End of macro CALLMONITOR
2926					endif 
2926			 
2926					FORTH_DSP_VALUEHL 
2926 cd fb 19			call macro_dsp_valuehl 
2929				endm 
# End of macro FORTH_DSP_VALUEHL
2929			 
2929 e5					push hl   ; save address 
292a			 
292a					FORTH_DSP_POP 
292a cd 97 1a			call macro_forth_dsp_pop 
292d				endm 
# End of macro FORTH_DSP_POP
292d			 
292d					FORTH_DSP_VALUEHL 
292d cd fb 19			call macro_dsp_valuehl 
2930				endm 
# End of macro FORTH_DSP_VALUEHL
2930			 
2930					FORTH_DSP_POP 
2930 cd 97 1a			call macro_forth_dsp_pop 
2933				endm 
# End of macro FORTH_DSP_POP
2933			 
2933					; hl contains value to add to byte at a 
2933				 
2933 eb					ex de, hl 
2934			 
2934 e1					pop hl 
2935			 
2935					if DEBUG_FORTH_WORDS 
2935						DMARK "INC" 
2935 f5				push af  
2936 3a 4a 29			ld a, (.dmark)  
2939 32 bd fb			ld (debug_mark),a  
293c 3a 4b 29			ld a, (.dmark+1)  
293f 32 be fb			ld (debug_mark+1),a  
2942 3a 4c 29			ld a, (.dmark+2)  
2945 32 bf fb			ld (debug_mark+2),a  
2948 18 03			jr .pastdmark  
294a ..			.dmark: db "INC"  
294d f1			.pastdmark: pop af  
294e			endm  
# End of macro DMARK
294e						CALLMONITOR 
294e cd d3 13			call break_point_state  
2951				endm  
# End of macro CALLMONITOR
2951					endif 
2951			 
2951 7e					ld a,(hl) 
2952 83					add e 
2953 77					ld (hl),a 
2954			 
2954			 
2954			 
2954				       NEXTW 
2954 c3 51 1b			jp macro_next 
2957				endm 
# End of macro NEXTW
2957			 
2957			.DEC: 
2957				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2957 6f				db WORD_SYS_CORE+91             
2958 a8 29			dw .INC2            
295a 03				db 2 + 1 
295b .. 00			db "-!",0              
295e				endm 
# End of macro CWHEAD
295e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
295e					if DEBUG_FORTH_WORDS_KEY 
295e						DMARK "-s_" 
295e f5				push af  
295f 3a 73 29			ld a, (.dmark)  
2962 32 bd fb			ld (debug_mark),a  
2965 3a 74 29			ld a, (.dmark+1)  
2968 32 be fb			ld (debug_mark+1),a  
296b 3a 75 29			ld a, (.dmark+2)  
296e 32 bf fb			ld (debug_mark+2),a  
2971 18 03			jr .pastdmark  
2973 ..			.dmark: db "-s_"  
2976 f1			.pastdmark: pop af  
2977			endm  
# End of macro DMARK
2977						CALLMONITOR 
2977 cd d3 13			call break_point_state  
297a				endm  
# End of macro CALLMONITOR
297a					endif 
297a			 
297a					FORTH_DSP_VALUEHL 
297a cd fb 19			call macro_dsp_valuehl 
297d				endm 
# End of macro FORTH_DSP_VALUEHL
297d			 
297d e5					push hl   ; save address 
297e			 
297e					FORTH_DSP_POP 
297e cd 97 1a			call macro_forth_dsp_pop 
2981				endm 
# End of macro FORTH_DSP_POP
2981			 
2981					FORTH_DSP_VALUEHL 
2981 cd fb 19			call macro_dsp_valuehl 
2984				endm 
# End of macro FORTH_DSP_VALUEHL
2984			 
2984					; hl contains value to add to byte at a 
2984				 
2984 eb					ex de, hl 
2985			 
2985 e1					pop hl 
2986			 
2986					if DEBUG_FORTH_WORDS 
2986						DMARK "DEC" 
2986 f5				push af  
2987 3a 9b 29			ld a, (.dmark)  
298a 32 bd fb			ld (debug_mark),a  
298d 3a 9c 29			ld a, (.dmark+1)  
2990 32 be fb			ld (debug_mark+1),a  
2993 3a 9d 29			ld a, (.dmark+2)  
2996 32 bf fb			ld (debug_mark+2),a  
2999 18 03			jr .pastdmark  
299b ..			.dmark: db "DEC"  
299e f1			.pastdmark: pop af  
299f			endm  
# End of macro DMARK
299f						CALLMONITOR 
299f cd d3 13			call break_point_state  
29a2				endm  
# End of macro CALLMONITOR
29a2					endif 
29a2			 
29a2 7e					ld a,(hl) 
29a3 93					sub e 
29a4 77					ld (hl),a 
29a5			 
29a5			 
29a5			 
29a5				       NEXTW 
29a5 c3 51 1b			jp macro_next 
29a8				endm 
# End of macro NEXTW
29a8			 
29a8			.INC2: 
29a8				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
29a8 6f				db WORD_SYS_CORE+91             
29a9 52 2a			dw .DEC2            
29ab 04				db 3 + 1 
29ac .. 00			db "+2!",0              
29b0				endm 
# End of macro CWHEAD
29b0			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
29b0			 
29b0					if DEBUG_FORTH_WORDS_KEY 
29b0						DMARK "+2s" 
29b0 f5				push af  
29b1 3a c5 29			ld a, (.dmark)  
29b4 32 bd fb			ld (debug_mark),a  
29b7 3a c6 29			ld a, (.dmark+1)  
29ba 32 be fb			ld (debug_mark+1),a  
29bd 3a c7 29			ld a, (.dmark+2)  
29c0 32 bf fb			ld (debug_mark+2),a  
29c3 18 03			jr .pastdmark  
29c5 ..			.dmark: db "+2s"  
29c8 f1			.pastdmark: pop af  
29c9			endm  
# End of macro DMARK
29c9						CALLMONITOR 
29c9 cd d3 13			call break_point_state  
29cc				endm  
# End of macro CALLMONITOR
29cc					endif 
29cc			 
29cc					; Address 
29cc			 
29cc					FORTH_DSP_VALUEHL 
29cc cd fb 19			call macro_dsp_valuehl 
29cf				endm 
# End of macro FORTH_DSP_VALUEHL
29cf			 
29cf e5					push hl    ; save address 
29d0			 
29d0					; load content into de 
29d0			 
29d0 5e					ld e,(hl) 
29d1 23					inc hl 
29d2 56					ld d, (hl) 
29d3			 
29d3					if DEBUG_FORTH_WORDS 
29d3						DMARK "+2a" 
29d3 f5				push af  
29d4 3a e8 29			ld a, (.dmark)  
29d7 32 bd fb			ld (debug_mark),a  
29da 3a e9 29			ld a, (.dmark+1)  
29dd 32 be fb			ld (debug_mark+1),a  
29e0 3a ea 29			ld a, (.dmark+2)  
29e3 32 bf fb			ld (debug_mark+2),a  
29e6 18 03			jr .pastdmark  
29e8 ..			.dmark: db "+2a"  
29eb f1			.pastdmark: pop af  
29ec			endm  
# End of macro DMARK
29ec						CALLMONITOR 
29ec cd d3 13			call break_point_state  
29ef				endm  
# End of macro CALLMONITOR
29ef					endif 
29ef			 
29ef					FORTH_DSP_POP 
29ef cd 97 1a			call macro_forth_dsp_pop 
29f2				endm 
# End of macro FORTH_DSP_POP
29f2			 
29f2					; Get value to add 
29f2			 
29f2					FORTH_DSP_VALUE 
29f2 cd e4 19			call macro_forth_dsp_value 
29f5				endm 
# End of macro FORTH_DSP_VALUE
29f5			 
29f5					if DEBUG_FORTH_WORDS 
29f5						DMARK "+2v" 
29f5 f5				push af  
29f6 3a 0a 2a			ld a, (.dmark)  
29f9 32 bd fb			ld (debug_mark),a  
29fc 3a 0b 2a			ld a, (.dmark+1)  
29ff 32 be fb			ld (debug_mark+1),a  
2a02 3a 0c 2a			ld a, (.dmark+2)  
2a05 32 bf fb			ld (debug_mark+2),a  
2a08 18 03			jr .pastdmark  
2a0a ..			.dmark: db "+2v"  
2a0d f1			.pastdmark: pop af  
2a0e			endm  
# End of macro DMARK
2a0e						CALLMONITOR 
2a0e cd d3 13			call break_point_state  
2a11				endm  
# End of macro CALLMONITOR
2a11					endif 
2a11			 
2a11 19					add hl, de 
2a12			 
2a12					if DEBUG_FORTH_WORDS 
2a12						DMARK "+2+" 
2a12 f5				push af  
2a13 3a 27 2a			ld a, (.dmark)  
2a16 32 bd fb			ld (debug_mark),a  
2a19 3a 28 2a			ld a, (.dmark+1)  
2a1c 32 be fb			ld (debug_mark+1),a  
2a1f 3a 29 2a			ld a, (.dmark+2)  
2a22 32 bf fb			ld (debug_mark+2),a  
2a25 18 03			jr .pastdmark  
2a27 ..			.dmark: db "+2+"  
2a2a f1			.pastdmark: pop af  
2a2b			endm  
# End of macro DMARK
2a2b						CALLMONITOR 
2a2b cd d3 13			call break_point_state  
2a2e				endm  
# End of macro CALLMONITOR
2a2e					endif 
2a2e			 
2a2e					; move result to de 
2a2e			 
2a2e eb					ex de, hl 
2a2f			 
2a2f					; Address 
2a2f			 
2a2f e1					pop hl 
2a30			 
2a30					; save it back 
2a30			 
2a30 73					ld (hl), e 
2a31 23					inc hl 
2a32 72					ld (hl), d 
2a33			 
2a33					if DEBUG_FORTH_WORDS 
2a33						DMARK "+2e" 
2a33 f5				push af  
2a34 3a 48 2a			ld a, (.dmark)  
2a37 32 bd fb			ld (debug_mark),a  
2a3a 3a 49 2a			ld a, (.dmark+1)  
2a3d 32 be fb			ld (debug_mark+1),a  
2a40 3a 4a 2a			ld a, (.dmark+2)  
2a43 32 bf fb			ld (debug_mark+2),a  
2a46 18 03			jr .pastdmark  
2a48 ..			.dmark: db "+2e"  
2a4b f1			.pastdmark: pop af  
2a4c			endm  
# End of macro DMARK
2a4c						CALLMONITOR 
2a4c cd d3 13			call break_point_state  
2a4f				endm  
# End of macro CALLMONITOR
2a4f					endif 
2a4f			 
2a4f			 
2a4f			 
2a4f			 
2a4f			 
2a4f				       NEXTW 
2a4f c3 51 1b			jp macro_next 
2a52				endm 
# End of macro NEXTW
2a52			 
2a52			.DEC2: 
2a52				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2a52 6f				db WORD_SYS_CORE+91             
2a53 fe 2a			dw .GET2            
2a55 04				db 3 + 1 
2a56 .. 00			db "-2!",0              
2a5a				endm 
# End of macro CWHEAD
2a5a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2a5a			 
2a5a			 
2a5a					if DEBUG_FORTH_WORDS_KEY 
2a5a						DMARK "-2s" 
2a5a f5				push af  
2a5b 3a 6f 2a			ld a, (.dmark)  
2a5e 32 bd fb			ld (debug_mark),a  
2a61 3a 70 2a			ld a, (.dmark+1)  
2a64 32 be fb			ld (debug_mark+1),a  
2a67 3a 71 2a			ld a, (.dmark+2)  
2a6a 32 bf fb			ld (debug_mark+2),a  
2a6d 18 03			jr .pastdmark  
2a6f ..			.dmark: db "-2s"  
2a72 f1			.pastdmark: pop af  
2a73			endm  
# End of macro DMARK
2a73						CALLMONITOR 
2a73 cd d3 13			call break_point_state  
2a76				endm  
# End of macro CALLMONITOR
2a76					endif 
2a76			 
2a76					; Address 
2a76			 
2a76					FORTH_DSP_VALUEHL 
2a76 cd fb 19			call macro_dsp_valuehl 
2a79				endm 
# End of macro FORTH_DSP_VALUEHL
2a79			 
2a79 e5					push hl    ; save address 
2a7a			 
2a7a					; load content into de 
2a7a			 
2a7a 5e					ld e,(hl) 
2a7b 23					inc hl 
2a7c 56					ld d, (hl) 
2a7d			 
2a7d					if DEBUG_FORTH_WORDS 
2a7d						DMARK "-2a" 
2a7d f5				push af  
2a7e 3a 92 2a			ld a, (.dmark)  
2a81 32 bd fb			ld (debug_mark),a  
2a84 3a 93 2a			ld a, (.dmark+1)  
2a87 32 be fb			ld (debug_mark+1),a  
2a8a 3a 94 2a			ld a, (.dmark+2)  
2a8d 32 bf fb			ld (debug_mark+2),a  
2a90 18 03			jr .pastdmark  
2a92 ..			.dmark: db "-2a"  
2a95 f1			.pastdmark: pop af  
2a96			endm  
# End of macro DMARK
2a96						CALLMONITOR 
2a96 cd d3 13			call break_point_state  
2a99				endm  
# End of macro CALLMONITOR
2a99					endif 
2a99			 
2a99					FORTH_DSP_POP 
2a99 cd 97 1a			call macro_forth_dsp_pop 
2a9c				endm 
# End of macro FORTH_DSP_POP
2a9c			 
2a9c					; Get value to remove 
2a9c			 
2a9c					FORTH_DSP_VALUE 
2a9c cd e4 19			call macro_forth_dsp_value 
2a9f				endm 
# End of macro FORTH_DSP_VALUE
2a9f			 
2a9f					if DEBUG_FORTH_WORDS 
2a9f						DMARK "-2v" 
2a9f f5				push af  
2aa0 3a b4 2a			ld a, (.dmark)  
2aa3 32 bd fb			ld (debug_mark),a  
2aa6 3a b5 2a			ld a, (.dmark+1)  
2aa9 32 be fb			ld (debug_mark+1),a  
2aac 3a b6 2a			ld a, (.dmark+2)  
2aaf 32 bf fb			ld (debug_mark+2),a  
2ab2 18 03			jr .pastdmark  
2ab4 ..			.dmark: db "-2v"  
2ab7 f1			.pastdmark: pop af  
2ab8			endm  
# End of macro DMARK
2ab8						CALLMONITOR 
2ab8 cd d3 13			call break_point_state  
2abb				endm  
# End of macro CALLMONITOR
2abb					endif 
2abb			 
2abb eb					ex de, hl 
2abc ed 52				sbc hl, de 
2abe			 
2abe					if DEBUG_FORTH_WORDS 
2abe						DMARK "-2d" 
2abe f5				push af  
2abf 3a d3 2a			ld a, (.dmark)  
2ac2 32 bd fb			ld (debug_mark),a  
2ac5 3a d4 2a			ld a, (.dmark+1)  
2ac8 32 be fb			ld (debug_mark+1),a  
2acb 3a d5 2a			ld a, (.dmark+2)  
2ace 32 bf fb			ld (debug_mark+2),a  
2ad1 18 03			jr .pastdmark  
2ad3 ..			.dmark: db "-2d"  
2ad6 f1			.pastdmark: pop af  
2ad7			endm  
# End of macro DMARK
2ad7						CALLMONITOR 
2ad7 cd d3 13			call break_point_state  
2ada				endm  
# End of macro CALLMONITOR
2ada					endif 
2ada			 
2ada					; move result to de 
2ada			 
2ada eb					ex de, hl 
2adb			 
2adb					; Address 
2adb			 
2adb e1					pop hl 
2adc			 
2adc					; save it back 
2adc			 
2adc 73					ld (hl), e 
2add 23					inc hl 
2ade 72					ld (hl), d 
2adf			 
2adf					if DEBUG_FORTH_WORDS 
2adf						DMARK "-2e" 
2adf f5				push af  
2ae0 3a f4 2a			ld a, (.dmark)  
2ae3 32 bd fb			ld (debug_mark),a  
2ae6 3a f5 2a			ld a, (.dmark+1)  
2ae9 32 be fb			ld (debug_mark+1),a  
2aec 3a f6 2a			ld a, (.dmark+2)  
2aef 32 bf fb			ld (debug_mark+2),a  
2af2 18 03			jr .pastdmark  
2af4 ..			.dmark: db "-2e"  
2af7 f1			.pastdmark: pop af  
2af8			endm  
# End of macro DMARK
2af8						CALLMONITOR 
2af8 cd d3 13			call break_point_state  
2afb				endm  
# End of macro CALLMONITOR
2afb					endif 
2afb			 
2afb			 
2afb			 
2afb			 
2afb			 
2afb				       NEXTW 
2afb c3 51 1b			jp macro_next 
2afe				endm 
# End of macro NEXTW
2afe			.GET2: 
2afe				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2afe 6f				db WORD_SYS_CORE+91             
2aff 2e 2b			dw .BANG2            
2b01 03				db 2 + 1 
2b02 .. 00			db "2@",0              
2b05				endm 
# End of macro CWHEAD
2b05			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b05					if DEBUG_FORTH_WORDS_KEY 
2b05						DMARK "2A_" 
2b05 f5				push af  
2b06 3a 1a 2b			ld a, (.dmark)  
2b09 32 bd fb			ld (debug_mark),a  
2b0c 3a 1b 2b			ld a, (.dmark+1)  
2b0f 32 be fb			ld (debug_mark+1),a  
2b12 3a 1c 2b			ld a, (.dmark+2)  
2b15 32 bf fb			ld (debug_mark+2),a  
2b18 18 03			jr .pastdmark  
2b1a ..			.dmark: db "2A_"  
2b1d f1			.pastdmark: pop af  
2b1e			endm  
# End of macro DMARK
2b1e						CALLMONITOR 
2b1e cd d3 13			call break_point_state  
2b21				endm  
# End of macro CALLMONITOR
2b21					endif 
2b21			 
2b21					FORTH_DSP_VALUEHL 
2b21 cd fb 19			call macro_dsp_valuehl 
2b24				endm 
# End of macro FORTH_DSP_VALUEHL
2b24			 
2b24 5e					ld e, (hl) 
2b25 23					inc hl 
2b26 56					ld d, (hl) 
2b27			 
2b27 eb					ex de, hl 
2b28			 
2b28 cd 60 19				call forth_push_numhl 
2b2b			 
2b2b				       NEXTW 
2b2b c3 51 1b			jp macro_next 
2b2e				endm 
# End of macro NEXTW
2b2e			.BANG2: 
2b2e				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
2b2e 6f				db WORD_SYS_CORE+91             
2b2f 66 2b			dw .ENDCORE            
2b31 03				db 2 + 1 
2b32 .. 00			db "2!",0              
2b35				endm 
# End of macro CWHEAD
2b35			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b35					if DEBUG_FORTH_WORDS_KEY 
2b35						DMARK "2S_" 
2b35 f5				push af  
2b36 3a 4a 2b			ld a, (.dmark)  
2b39 32 bd fb			ld (debug_mark),a  
2b3c 3a 4b 2b			ld a, (.dmark+1)  
2b3f 32 be fb			ld (debug_mark+1),a  
2b42 3a 4c 2b			ld a, (.dmark+2)  
2b45 32 bf fb			ld (debug_mark+2),a  
2b48 18 03			jr .pastdmark  
2b4a ..			.dmark: db "2S_"  
2b4d f1			.pastdmark: pop af  
2b4e			endm  
# End of macro DMARK
2b4e						CALLMONITOR 
2b4e cd d3 13			call break_point_state  
2b51				endm  
# End of macro CALLMONITOR
2b51					endif 
2b51			 
2b51					FORTH_DSP_VALUEHL 
2b51 cd fb 19			call macro_dsp_valuehl 
2b54				endm 
# End of macro FORTH_DSP_VALUEHL
2b54			 
2b54 e5					push hl   ; save address 
2b55			 
2b55			 
2b55					FORTH_DSP_POP 
2b55 cd 97 1a			call macro_forth_dsp_pop 
2b58				endm 
# End of macro FORTH_DSP_POP
2b58			 
2b58					 
2b58					FORTH_DSP_VALUEHL 
2b58 cd fb 19			call macro_dsp_valuehl 
2b5b				endm 
# End of macro FORTH_DSP_VALUEHL
2b5b			 
2b5b					FORTH_DSP_POP 
2b5b cd 97 1a			call macro_forth_dsp_pop 
2b5e				endm 
# End of macro FORTH_DSP_POP
2b5e			 
2b5e eb					ex de, hl    ; value now in de 
2b5f			 
2b5f e1					pop hl 
2b60			 
2b60 73					ld (hl), e 
2b61			 
2b61 23					inc hl 
2b62			 
2b62 72					ld (hl), d 
2b63			 
2b63			 
2b63				       NEXTW 
2b63 c3 51 1b			jp macro_next 
2b66				endm 
# End of macro NEXTW
2b66			.ENDCORE: 
2b66			 
2b66			; eof 
2b66			 
2b66			 
# End of file forth_words_core.asm
2b66			include "forth_words_flow.asm" 
2b66			 
2b66			; | ## Program Flow Words 
2b66			 
2b66			.IF: 
2b66				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2b66 1e				db WORD_SYS_CORE+10             
2b67 5b 2c			dw .THEN            
2b69 03				db 2 + 1 
2b6a .. 00			db "IF",0              
2b6d				endm 
# End of macro CWHEAD
2b6d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2b6d			; 
2b6d					if DEBUG_FORTH_WORDS_KEY 
2b6d						DMARK "IF." 
2b6d f5				push af  
2b6e 3a 82 2b			ld a, (.dmark)  
2b71 32 bd fb			ld (debug_mark),a  
2b74 3a 83 2b			ld a, (.dmark+1)  
2b77 32 be fb			ld (debug_mark+1),a  
2b7a 3a 84 2b			ld a, (.dmark+2)  
2b7d 32 bf fb			ld (debug_mark+2),a  
2b80 18 03			jr .pastdmark  
2b82 ..			.dmark: db "IF."  
2b85 f1			.pastdmark: pop af  
2b86			endm  
# End of macro DMARK
2b86						CALLMONITOR 
2b86 cd d3 13			call break_point_state  
2b89				endm  
# End of macro CALLMONITOR
2b89					endif 
2b89			; eval TOS 
2b89			 
2b89				FORTH_DSP_VALUEHL 
2b89 cd fb 19			call macro_dsp_valuehl 
2b8c				endm 
# End of macro FORTH_DSP_VALUEHL
2b8c			 
2b8c			;	push hl 
2b8c				FORTH_DSP_POP 
2b8c cd 97 1a			call macro_forth_dsp_pop 
2b8f				endm 
# End of macro FORTH_DSP_POP
2b8f			;	pop hl 
2b8f			 
2b8f					if DEBUG_FORTH_WORDS 
2b8f						DMARK "IF1" 
2b8f f5				push af  
2b90 3a a4 2b			ld a, (.dmark)  
2b93 32 bd fb			ld (debug_mark),a  
2b96 3a a5 2b			ld a, (.dmark+1)  
2b99 32 be fb			ld (debug_mark+1),a  
2b9c 3a a6 2b			ld a, (.dmark+2)  
2b9f 32 bf fb			ld (debug_mark+2),a  
2ba2 18 03			jr .pastdmark  
2ba4 ..			.dmark: db "IF1"  
2ba7 f1			.pastdmark: pop af  
2ba8			endm  
# End of macro DMARK
2ba8						CALLMONITOR 
2ba8 cd d3 13			call break_point_state  
2bab				endm  
# End of macro CALLMONITOR
2bab					endif 
2bab b7				or a        ; clear carry flag 
2bac 11 00 00			ld de, 0 
2baf eb				ex de,hl 
2bb0 ed 52			sbc hl, de 
2bb2 c2 3c 2c			jp nz, .iftrue 
2bb5			 
2bb5					if DEBUG_FORTH_WORDS 
2bb5						DMARK "IF2" 
2bb5 f5				push af  
2bb6 3a ca 2b			ld a, (.dmark)  
2bb9 32 bd fb			ld (debug_mark),a  
2bbc 3a cb 2b			ld a, (.dmark+1)  
2bbf 32 be fb			ld (debug_mark+1),a  
2bc2 3a cc 2b			ld a, (.dmark+2)  
2bc5 32 bf fb			ld (debug_mark+2),a  
2bc8 18 03			jr .pastdmark  
2bca ..			.dmark: db "IF2"  
2bcd f1			.pastdmark: pop af  
2bce			endm  
# End of macro DMARK
2bce						CALLMONITOR 
2bce cd d3 13			call break_point_state  
2bd1				endm  
# End of macro CALLMONITOR
2bd1					endif 
2bd1			 
2bd1			; if not true then skip to THEN 
2bd1			 
2bd1				; TODO get tok_ptr 
2bd1				; TODO consume toks until we get to THEN 
2bd1			 
2bd1 2a b9 f2			ld hl, (os_tok_ptr) 
2bd4					if DEBUG_FORTH_WORDS 
2bd4						DMARK "IF3" 
2bd4 f5				push af  
2bd5 3a e9 2b			ld a, (.dmark)  
2bd8 32 bd fb			ld (debug_mark),a  
2bdb 3a ea 2b			ld a, (.dmark+1)  
2bde 32 be fb			ld (debug_mark+1),a  
2be1 3a eb 2b			ld a, (.dmark+2)  
2be4 32 bf fb			ld (debug_mark+2),a  
2be7 18 03			jr .pastdmark  
2be9 ..			.dmark: db "IF3"  
2bec f1			.pastdmark: pop af  
2bed			endm  
# End of macro DMARK
2bed						CALLMONITOR 
2bed cd d3 13			call break_point_state  
2bf0				endm  
# End of macro CALLMONITOR
2bf0						 
2bf0					endif 
2bf0 11 37 2c			ld de, .ifthen 
2bf3					if DEBUG_FORTH_WORDS 
2bf3						DMARK "IF4" 
2bf3 f5				push af  
2bf4 3a 08 2c			ld a, (.dmark)  
2bf7 32 bd fb			ld (debug_mark),a  
2bfa 3a 09 2c			ld a, (.dmark+1)  
2bfd 32 be fb			ld (debug_mark+1),a  
2c00 3a 0a 2c			ld a, (.dmark+2)  
2c03 32 bf fb			ld (debug_mark+2),a  
2c06 18 03			jr .pastdmark  
2c08 ..			.dmark: db "IF4"  
2c0b f1			.pastdmark: pop af  
2c0c			endm  
# End of macro DMARK
2c0c						CALLMONITOR 
2c0c cd d3 13			call break_point_state  
2c0f				endm  
# End of macro CALLMONITOR
2c0f					endif 
2c0f cd 6c 1c			call findnexttok  
2c12			 
2c12					if DEBUG_FORTH_WORDS 
2c12						DMARK "IF5" 
2c12 f5				push af  
2c13 3a 27 2c			ld a, (.dmark)  
2c16 32 bd fb			ld (debug_mark),a  
2c19 3a 28 2c			ld a, (.dmark+1)  
2c1c 32 be fb			ld (debug_mark+1),a  
2c1f 3a 29 2c			ld a, (.dmark+2)  
2c22 32 bf fb			ld (debug_mark+2),a  
2c25 18 03			jr .pastdmark  
2c27 ..			.dmark: db "IF5"  
2c2a f1			.pastdmark: pop af  
2c2b			endm  
# End of macro DMARK
2c2b						CALLMONITOR 
2c2b cd d3 13			call break_point_state  
2c2e				endm  
# End of macro CALLMONITOR
2c2e					endif 
2c2e				; TODO replace below with ; exec using tok_ptr 
2c2e 22 b9 f2			ld (os_tok_ptr), hl 
2c31 c3 e2 1b			jp exec1 
2c34				NEXTW 
2c34 c3 51 1b			jp macro_next 
2c37				endm 
# End of macro NEXTW
2c37			 
2c37 .. 00		.ifthen:  db "THEN",0 
2c3c			 
2c3c			.iftrue:		 
2c3c				; Exec next words normally 
2c3c			 
2c3c				; if true then exec following IF as normal 
2c3c					if DEBUG_FORTH_WORDS 
2c3c						DMARK "IFT" 
2c3c f5				push af  
2c3d 3a 51 2c			ld a, (.dmark)  
2c40 32 bd fb			ld (debug_mark),a  
2c43 3a 52 2c			ld a, (.dmark+1)  
2c46 32 be fb			ld (debug_mark+1),a  
2c49 3a 53 2c			ld a, (.dmark+2)  
2c4c 32 bf fb			ld (debug_mark+2),a  
2c4f 18 03			jr .pastdmark  
2c51 ..			.dmark: db "IFT"  
2c54 f1			.pastdmark: pop af  
2c55			endm  
# End of macro DMARK
2c55						CALLMONITOR 
2c55 cd d3 13			call break_point_state  
2c58				endm  
# End of macro CALLMONITOR
2c58					endif 
2c58			 
2c58					NEXTW 
2c58 c3 51 1b			jp macro_next 
2c5b				endm 
# End of macro NEXTW
2c5b			.THEN: 
2c5b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2c5b 1f				db WORD_SYS_CORE+11             
2c5c 83 2c			dw .ELSE            
2c5e 05				db 4 + 1 
2c5f .. 00			db "THEN",0              
2c64				endm 
# End of macro CWHEAD
2c64			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2c64					if DEBUG_FORTH_WORDS_KEY 
2c64						DMARK "THN" 
2c64 f5				push af  
2c65 3a 79 2c			ld a, (.dmark)  
2c68 32 bd fb			ld (debug_mark),a  
2c6b 3a 7a 2c			ld a, (.dmark+1)  
2c6e 32 be fb			ld (debug_mark+1),a  
2c71 3a 7b 2c			ld a, (.dmark+2)  
2c74 32 bf fb			ld (debug_mark+2),a  
2c77 18 03			jr .pastdmark  
2c79 ..			.dmark: db "THN"  
2c7c f1			.pastdmark: pop af  
2c7d			endm  
# End of macro DMARK
2c7d						CALLMONITOR 
2c7d cd d3 13			call break_point_state  
2c80				endm  
# End of macro CALLMONITOR
2c80					endif 
2c80					NEXTW 
2c80 c3 51 1b			jp macro_next 
2c83				endm 
# End of macro NEXTW
2c83			.ELSE: 
2c83				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2c83 20				db WORD_SYS_CORE+12             
2c84 ab 2c			dw .DO            
2c86 03				db 2 + 1 
2c87 .. 00			db "ELSE",0              
2c8c				endm 
# End of macro CWHEAD
2c8c			; | ELSE ( -- ) Not supported - does nothing | TODO 
2c8c			 
2c8c					if DEBUG_FORTH_WORDS_KEY 
2c8c						DMARK "ELS" 
2c8c f5				push af  
2c8d 3a a1 2c			ld a, (.dmark)  
2c90 32 bd fb			ld (debug_mark),a  
2c93 3a a2 2c			ld a, (.dmark+1)  
2c96 32 be fb			ld (debug_mark+1),a  
2c99 3a a3 2c			ld a, (.dmark+2)  
2c9c 32 bf fb			ld (debug_mark+2),a  
2c9f 18 03			jr .pastdmark  
2ca1 ..			.dmark: db "ELS"  
2ca4 f1			.pastdmark: pop af  
2ca5			endm  
# End of macro DMARK
2ca5						CALLMONITOR 
2ca5 cd d3 13			call break_point_state  
2ca8				endm  
# End of macro CALLMONITOR
2ca8					endif 
2ca8			 
2ca8			 
2ca8					NEXTW 
2ca8 c3 51 1b			jp macro_next 
2cab				endm 
# End of macro NEXTW
2cab			.DO: 
2cab				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2cab 21				db WORD_SYS_CORE+13             
2cac d2 2d			dw .LOOP            
2cae 03				db 2 + 1 
2caf .. 00			db "DO",0              
2cb2				endm 
# End of macro CWHEAD
2cb2			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2cb2			 
2cb2					if DEBUG_FORTH_WORDS_KEY 
2cb2						DMARK "DO." 
2cb2 f5				push af  
2cb3 3a c7 2c			ld a, (.dmark)  
2cb6 32 bd fb			ld (debug_mark),a  
2cb9 3a c8 2c			ld a, (.dmark+1)  
2cbc 32 be fb			ld (debug_mark+1),a  
2cbf 3a c9 2c			ld a, (.dmark+2)  
2cc2 32 bf fb			ld (debug_mark+2),a  
2cc5 18 03			jr .pastdmark  
2cc7 ..			.dmark: db "DO."  
2cca f1			.pastdmark: pop af  
2ccb			endm  
# End of macro DMARK
2ccb						CALLMONITOR 
2ccb cd d3 13			call break_point_state  
2cce				endm  
# End of macro CALLMONITOR
2cce					endif 
2cce			;  push pc to rsp stack past the DO 
2cce			 
2cce 2a b9 f2				ld hl, (os_tok_ptr) 
2cd1 23					inc hl   ; D 
2cd2 23					inc hl  ; O 
2cd3 23					inc hl   ; null 
2cd4					if DEBUG_FORTH_WORDS 
2cd4						DMARK "DO2" 
2cd4 f5				push af  
2cd5 3a e9 2c			ld a, (.dmark)  
2cd8 32 bd fb			ld (debug_mark),a  
2cdb 3a ea 2c			ld a, (.dmark+1)  
2cde 32 be fb			ld (debug_mark+1),a  
2ce1 3a eb 2c			ld a, (.dmark+2)  
2ce4 32 bf fb			ld (debug_mark+2),a  
2ce7 18 03			jr .pastdmark  
2ce9 ..			.dmark: db "DO2"  
2cec f1			.pastdmark: pop af  
2ced			endm  
# End of macro DMARK
2ced						CALLMONITOR 
2ced cd d3 13			call break_point_state  
2cf0				endm  
# End of macro CALLMONITOR
2cf0					endif 
2cf0					FORTH_RSP_NEXT 
2cf0 cd 07 19			call macro_forth_rsp_next 
2cf3				endm 
# End of macro FORTH_RSP_NEXT
2cf3					if DEBUG_FORTH_WORDS 
2cf3						DMARK "DO3" 
2cf3 f5				push af  
2cf4 3a 08 2d			ld a, (.dmark)  
2cf7 32 bd fb			ld (debug_mark),a  
2cfa 3a 09 2d			ld a, (.dmark+1)  
2cfd 32 be fb			ld (debug_mark+1),a  
2d00 3a 0a 2d			ld a, (.dmark+2)  
2d03 32 bf fb			ld (debug_mark+2),a  
2d06 18 03			jr .pastdmark  
2d08 ..			.dmark: db "DO3"  
2d0b f1			.pastdmark: pop af  
2d0c			endm  
# End of macro DMARK
2d0c						CALLMONITOR 
2d0c cd d3 13			call break_point_state  
2d0f				endm  
# End of macro CALLMONITOR
2d0f					endif 
2d0f			 
2d0f					;if DEBUG_FORTH_WORDS 
2d0f				;		push hl 
2d0f			;		endif  
2d0f			 
2d0f			; get counters from data stack 
2d0f			 
2d0f			 
2d0f					FORTH_DSP_VALUEHL 
2d0f cd fb 19			call macro_dsp_valuehl 
2d12				endm 
# End of macro FORTH_DSP_VALUEHL
2d12 e5					push hl		 ; hl now has starting counter which needs to be tos 
2d13			 
2d13					if DEBUG_FORTH_WORDS 
2d13						DMARK "DO4" 
2d13 f5				push af  
2d14 3a 28 2d			ld a, (.dmark)  
2d17 32 bd fb			ld (debug_mark),a  
2d1a 3a 29 2d			ld a, (.dmark+1)  
2d1d 32 be fb			ld (debug_mark+1),a  
2d20 3a 2a 2d			ld a, (.dmark+2)  
2d23 32 bf fb			ld (debug_mark+2),a  
2d26 18 03			jr .pastdmark  
2d28 ..			.dmark: db "DO4"  
2d2b f1			.pastdmark: pop af  
2d2c			endm  
# End of macro DMARK
2d2c						CALLMONITOR 
2d2c cd d3 13			call break_point_state  
2d2f				endm  
# End of macro CALLMONITOR
2d2f					endif 
2d2f					FORTH_DSP_POP 
2d2f cd 97 1a			call macro_forth_dsp_pop 
2d32				endm 
# End of macro FORTH_DSP_POP
2d32			 
2d32					if DEBUG_FORTH_WORDS 
2d32						DMARK "DO5" 
2d32 f5				push af  
2d33 3a 47 2d			ld a, (.dmark)  
2d36 32 bd fb			ld (debug_mark),a  
2d39 3a 48 2d			ld a, (.dmark+1)  
2d3c 32 be fb			ld (debug_mark+1),a  
2d3f 3a 49 2d			ld a, (.dmark+2)  
2d42 32 bf fb			ld (debug_mark+2),a  
2d45 18 03			jr .pastdmark  
2d47 ..			.dmark: db "DO5"  
2d4a f1			.pastdmark: pop af  
2d4b			endm  
# End of macro DMARK
2d4b						CALLMONITOR 
2d4b cd d3 13			call break_point_state  
2d4e				endm  
# End of macro CALLMONITOR
2d4e					endif 
2d4e			 
2d4e					FORTH_DSP_VALUEHL 
2d4e cd fb 19			call macro_dsp_valuehl 
2d51				endm 
# End of macro FORTH_DSP_VALUEHL
2d51			;		push hl		 ; hl now has starting limit counter 
2d51			 
2d51					if DEBUG_FORTH_WORDS 
2d51						DMARK "DO6" 
2d51 f5				push af  
2d52 3a 66 2d			ld a, (.dmark)  
2d55 32 bd fb			ld (debug_mark),a  
2d58 3a 67 2d			ld a, (.dmark+1)  
2d5b 32 be fb			ld (debug_mark+1),a  
2d5e 3a 68 2d			ld a, (.dmark+2)  
2d61 32 bf fb			ld (debug_mark+2),a  
2d64 18 03			jr .pastdmark  
2d66 ..			.dmark: db "DO6"  
2d69 f1			.pastdmark: pop af  
2d6a			endm  
# End of macro DMARK
2d6a						CALLMONITOR 
2d6a cd d3 13			call break_point_state  
2d6d				endm  
# End of macro CALLMONITOR
2d6d					endif 
2d6d					FORTH_DSP_POP 
2d6d cd 97 1a			call macro_forth_dsp_pop 
2d70				endm 
# End of macro FORTH_DSP_POP
2d70			 
2d70			; put counters on the loop stack 
2d70			 
2d70			;		pop hl			 ; limit counter 
2d70 d1					pop de			; start counter 
2d71			 
2d71					; push limit counter 
2d71			 
2d71					if DEBUG_FORTH_WORDS 
2d71						DMARK "DO7" 
2d71 f5				push af  
2d72 3a 86 2d			ld a, (.dmark)  
2d75 32 bd fb			ld (debug_mark),a  
2d78 3a 87 2d			ld a, (.dmark+1)  
2d7b 32 be fb			ld (debug_mark+1),a  
2d7e 3a 88 2d			ld a, (.dmark+2)  
2d81 32 bf fb			ld (debug_mark+2),a  
2d84 18 03			jr .pastdmark  
2d86 ..			.dmark: db "DO7"  
2d89 f1			.pastdmark: pop af  
2d8a			endm  
# End of macro DMARK
2d8a						CALLMONITOR 
2d8a cd d3 13			call break_point_state  
2d8d				endm  
# End of macro CALLMONITOR
2d8d					endif 
2d8d					FORTH_LOOP_NEXT 
2d8d cd 10 1a			call macro_forth_loop_next 
2d90				endm 
# End of macro FORTH_LOOP_NEXT
2d90			 
2d90					; push start counter 
2d90			 
2d90 eb					ex de, hl 
2d91					if DEBUG_FORTH_WORDS 
2d91						DMARK "DO7" 
2d91 f5				push af  
2d92 3a a6 2d			ld a, (.dmark)  
2d95 32 bd fb			ld (debug_mark),a  
2d98 3a a7 2d			ld a, (.dmark+1)  
2d9b 32 be fb			ld (debug_mark+1),a  
2d9e 3a a8 2d			ld a, (.dmark+2)  
2da1 32 bf fb			ld (debug_mark+2),a  
2da4 18 03			jr .pastdmark  
2da6 ..			.dmark: db "DO7"  
2da9 f1			.pastdmark: pop af  
2daa			endm  
# End of macro DMARK
2daa						CALLMONITOR 
2daa cd d3 13			call break_point_state  
2dad				endm  
# End of macro CALLMONITOR
2dad					endif 
2dad					FORTH_LOOP_NEXT 
2dad cd 10 1a			call macro_forth_loop_next 
2db0				endm 
# End of macro FORTH_LOOP_NEXT
2db0			 
2db0			 
2db0					; init first round of I counter 
2db0			 
2db0 22 dd f2				ld (os_current_i), hl 
2db3			 
2db3					if DEBUG_FORTH_WORDS 
2db3						DMARK "DO8" 
2db3 f5				push af  
2db4 3a c8 2d			ld a, (.dmark)  
2db7 32 bd fb			ld (debug_mark),a  
2dba 3a c9 2d			ld a, (.dmark+1)  
2dbd 32 be fb			ld (debug_mark+1),a  
2dc0 3a ca 2d			ld a, (.dmark+2)  
2dc3 32 bf fb			ld (debug_mark+2),a  
2dc6 18 03			jr .pastdmark  
2dc8 ..			.dmark: db "DO8"  
2dcb f1			.pastdmark: pop af  
2dcc			endm  
# End of macro DMARK
2dcc						CALLMONITOR 
2dcc cd d3 13			call break_point_state  
2dcf				endm  
# End of macro CALLMONITOR
2dcf					endif 
2dcf			 
2dcf					NEXTW 
2dcf c3 51 1b			jp macro_next 
2dd2				endm 
# End of macro NEXTW
2dd2			.LOOP: 
2dd2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2dd2 22				db WORD_SYS_CORE+14             
2dd3 ea 2e			dw .I            
2dd5 05				db 4 + 1 
2dd6 .. 00			db "LOOP",0              
2ddb				endm 
# End of macro CWHEAD
2ddb			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2ddb			 
2ddb				; pop tos as current loop count to hl 
2ddb			 
2ddb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2ddb			 
2ddb				FORTH_LOOP_TOS 
2ddb cd 43 1a			call macro_forth_loop_tos 
2dde				endm 
# End of macro FORTH_LOOP_TOS
2dde e5				push hl 
2ddf			 
2ddf					if DEBUG_FORTH_WORDS_KEY 
2ddf						DMARK "LOP" 
2ddf f5				push af  
2de0 3a f4 2d			ld a, (.dmark)  
2de3 32 bd fb			ld (debug_mark),a  
2de6 3a f5 2d			ld a, (.dmark+1)  
2de9 32 be fb			ld (debug_mark+1),a  
2dec 3a f6 2d			ld a, (.dmark+2)  
2def 32 bf fb			ld (debug_mark+2),a  
2df2 18 03			jr .pastdmark  
2df4 ..			.dmark: db "LOP"  
2df7 f1			.pastdmark: pop af  
2df8			endm  
# End of macro DMARK
2df8						CALLMONITOR 
2df8 cd d3 13			call break_point_state  
2dfb				endm  
# End of macro CALLMONITOR
2dfb					endif 
2dfb				; next item on the stack is the limit. get it 
2dfb			 
2dfb			 
2dfb				FORTH_LOOP_POP 
2dfb cd 4d 1a			call macro_forth_loop_pop 
2dfe				endm 
# End of macro FORTH_LOOP_POP
2dfe			 
2dfe				FORTH_LOOP_TOS 
2dfe cd 43 1a			call macro_forth_loop_tos 
2e01				endm 
# End of macro FORTH_LOOP_TOS
2e01			 
2e01 d1				pop de		 ; de = i, hl = limit 
2e02			 
2e02					if DEBUG_FORTH_WORDS 
2e02						DMARK "LP1" 
2e02 f5				push af  
2e03 3a 17 2e			ld a, (.dmark)  
2e06 32 bd fb			ld (debug_mark),a  
2e09 3a 18 2e			ld a, (.dmark+1)  
2e0c 32 be fb			ld (debug_mark+1),a  
2e0f 3a 19 2e			ld a, (.dmark+2)  
2e12 32 bf fb			ld (debug_mark+2),a  
2e15 18 03			jr .pastdmark  
2e17 ..			.dmark: db "LP1"  
2e1a f1			.pastdmark: pop af  
2e1b			endm  
# End of macro DMARK
2e1b						CALLMONITOR 
2e1b cd d3 13			call break_point_state  
2e1e				endm  
# End of macro CALLMONITOR
2e1e					endif 
2e1e			 
2e1e				; go back to previous word 
2e1e			 
2e1e d5				push de    ; save I for inc later 
2e1f			 
2e1f			 
2e1f				; get limit 
2e1f				;  is I at limit? 
2e1f			 
2e1f			 
2e1f					if DEBUG_FORTH_WORDS 
2e1f						DMARK "LP1" 
2e1f f5				push af  
2e20 3a 34 2e			ld a, (.dmark)  
2e23 32 bd fb			ld (debug_mark),a  
2e26 3a 35 2e			ld a, (.dmark+1)  
2e29 32 be fb			ld (debug_mark+1),a  
2e2c 3a 36 2e			ld a, (.dmark+2)  
2e2f 32 bf fb			ld (debug_mark+2),a  
2e32 18 03			jr .pastdmark  
2e34 ..			.dmark: db "LP1"  
2e37 f1			.pastdmark: pop af  
2e38			endm  
# End of macro DMARK
2e38						CALLMONITOR 
2e38 cd d3 13			call break_point_state  
2e3b				endm  
# End of macro CALLMONITOR
2e3b					endif 
2e3b			 
2e3b ed 52			sbc hl, de 
2e3d			 
2e3d			 
2e3d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e3d			 
2e3d 20 26				jr nz, .loopnotdone 
2e3f			 
2e3f e1				pop hl   ; get rid of saved I 
2e40				FORTH_LOOP_POP     ; get rid of limit 
2e40 cd 4d 1a			call macro_forth_loop_pop 
2e43				endm 
# End of macro FORTH_LOOP_POP
2e43			 
2e43				FORTH_RSP_POP     ; get rid of DO ptr 
2e43 cd 28 19			call macro_forth_rsp_pop 
2e46				endm 
# End of macro FORTH_RSP_POP
2e46			 
2e46			if DEBUG_FORTH_WORDS 
2e46						DMARK "LP>" 
2e46 f5				push af  
2e47 3a 5b 2e			ld a, (.dmark)  
2e4a 32 bd fb			ld (debug_mark),a  
2e4d 3a 5c 2e			ld a, (.dmark+1)  
2e50 32 be fb			ld (debug_mark+1),a  
2e53 3a 5d 2e			ld a, (.dmark+2)  
2e56 32 bf fb			ld (debug_mark+2),a  
2e59 18 03			jr .pastdmark  
2e5b ..			.dmark: db "LP>"  
2e5e f1			.pastdmark: pop af  
2e5f			endm  
# End of macro DMARK
2e5f				CALLMONITOR 
2e5f cd d3 13			call break_point_state  
2e62				endm  
# End of macro CALLMONITOR
2e62			endif 
2e62			 
2e62					NEXTW 
2e62 c3 51 1b			jp macro_next 
2e65				endm 
# End of macro NEXTW
2e65				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e65			 
2e65			.loopnotdone: 
2e65			 
2e65 e1				pop hl    ; get I 
2e66 23				inc hl 
2e67			 
2e67			   	; save new I 
2e67			 
2e67			 
2e67					; set I counter 
2e67			 
2e67 22 dd f2				ld (os_current_i), hl 
2e6a			 
2e6a					if DEBUG_FORTH_WORDS 
2e6a						DMARK "LPN" 
2e6a f5				push af  
2e6b 3a 7f 2e			ld a, (.dmark)  
2e6e 32 bd fb			ld (debug_mark),a  
2e71 3a 80 2e			ld a, (.dmark+1)  
2e74 32 be fb			ld (debug_mark+1),a  
2e77 3a 81 2e			ld a, (.dmark+2)  
2e7a 32 bf fb			ld (debug_mark+2),a  
2e7d 18 03			jr .pastdmark  
2e7f ..			.dmark: db "LPN"  
2e82 f1			.pastdmark: pop af  
2e83			endm  
# End of macro DMARK
2e83					CALLMONITOR 
2e83 cd d3 13			call break_point_state  
2e86				endm  
# End of macro CALLMONITOR
2e86					endif 
2e86					 
2e86				FORTH_LOOP_NEXT 
2e86 cd 10 1a			call macro_forth_loop_next 
2e89				endm 
# End of macro FORTH_LOOP_NEXT
2e89			 
2e89			 
2e89					if DEBUG_FORTH_WORDS 
2e89 eb						ex de,hl 
2e8a					endif 
2e8a			 
2e8a			;	; get DO ptr 
2e8a			; 
2e8a					if DEBUG_FORTH_WORDS 
2e8a						DMARK "LP7" 
2e8a f5				push af  
2e8b 3a 9f 2e			ld a, (.dmark)  
2e8e 32 bd fb			ld (debug_mark),a  
2e91 3a a0 2e			ld a, (.dmark+1)  
2e94 32 be fb			ld (debug_mark+1),a  
2e97 3a a1 2e			ld a, (.dmark+2)  
2e9a 32 bf fb			ld (debug_mark+2),a  
2e9d 18 03			jr .pastdmark  
2e9f ..			.dmark: db "LP7"  
2ea2 f1			.pastdmark: pop af  
2ea3			endm  
# End of macro DMARK
2ea3					CALLMONITOR 
2ea3 cd d3 13			call break_point_state  
2ea6				endm  
# End of macro CALLMONITOR
2ea6					endif 
2ea6				FORTH_RSP_TOS 
2ea6 cd 1e 19			call macro_forth_rsp_tos 
2ea9				endm 
# End of macro FORTH_RSP_TOS
2ea9			 
2ea9					if DEBUG_FORTH_WORDS 
2ea9						DMARK "LP8" 
2ea9 f5				push af  
2eaa 3a be 2e			ld a, (.dmark)  
2ead 32 bd fb			ld (debug_mark),a  
2eb0 3a bf 2e			ld a, (.dmark+1)  
2eb3 32 be fb			ld (debug_mark+1),a  
2eb6 3a c0 2e			ld a, (.dmark+2)  
2eb9 32 bf fb			ld (debug_mark+2),a  
2ebc 18 03			jr .pastdmark  
2ebe ..			.dmark: db "LP8"  
2ec1 f1			.pastdmark: pop af  
2ec2			endm  
# End of macro DMARK
2ec2					CALLMONITOR 
2ec2 cd d3 13			call break_point_state  
2ec5				endm  
# End of macro CALLMONITOR
2ec5					endif 
2ec5				;push hl 
2ec5			 
2ec5				; not going to DO any more 
2ec5				; get rid of the RSP pointer as DO will add it back in 
2ec5				;FORTH_RSP_POP 
2ec5				;pop hl 
2ec5			 
2ec5				;ld hl,(cli_ret_sp) 
2ec5				;ld e, (hl) 
2ec5				;inc hl 
2ec5				;ld d, (hl) 
2ec5				;ex de,hl 
2ec5 22 b9 f2			ld (os_tok_ptr), hl 
2ec8					if DEBUG_FORTH_WORDS 
2ec8						DMARK "LP<" 
2ec8 f5				push af  
2ec9 3a dd 2e			ld a, (.dmark)  
2ecc 32 bd fb			ld (debug_mark),a  
2ecf 3a de 2e			ld a, (.dmark+1)  
2ed2 32 be fb			ld (debug_mark+1),a  
2ed5 3a df 2e			ld a, (.dmark+2)  
2ed8 32 bf fb			ld (debug_mark+2),a  
2edb 18 03			jr .pastdmark  
2edd ..			.dmark: db "LP<"  
2ee0 f1			.pastdmark: pop af  
2ee1			endm  
# End of macro DMARK
2ee1					CALLMONITOR 
2ee1 cd d3 13			call break_point_state  
2ee4				endm  
# End of macro CALLMONITOR
2ee4				endif 
2ee4 c3 e2 1b			jp exec1 
2ee7			 
2ee7					 
2ee7			 
2ee7			 
2ee7					NEXTW 
2ee7 c3 51 1b			jp macro_next 
2eea				endm 
# End of macro NEXTW
2eea			.I:  
2eea			 
2eea				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2eea 5e				db WORD_SYS_CORE+74             
2eeb 15 2f			dw .DLOOP            
2eed 02				db 1 + 1 
2eee .. 00			db "I",0              
2ef0				endm 
# End of macro CWHEAD
2ef0			; | I ( -- ) Current loop counter | DONE 
2ef0					if DEBUG_FORTH_WORDS_KEY 
2ef0						DMARK "I.." 
2ef0 f5				push af  
2ef1 3a 05 2f			ld a, (.dmark)  
2ef4 32 bd fb			ld (debug_mark),a  
2ef7 3a 06 2f			ld a, (.dmark+1)  
2efa 32 be fb			ld (debug_mark+1),a  
2efd 3a 07 2f			ld a, (.dmark+2)  
2f00 32 bf fb			ld (debug_mark+2),a  
2f03 18 03			jr .pastdmark  
2f05 ..			.dmark: db "I.."  
2f08 f1			.pastdmark: pop af  
2f09			endm  
# End of macro DMARK
2f09						CALLMONITOR 
2f09 cd d3 13			call break_point_state  
2f0c				endm  
# End of macro CALLMONITOR
2f0c					endif 
2f0c			 
2f0c 2a dd f2				ld hl,(os_current_i) 
2f0f cd 60 19				call forth_push_numhl 
2f12			 
2f12					NEXTW 
2f12 c3 51 1b			jp macro_next 
2f15				endm 
# End of macro NEXTW
2f15			.DLOOP: 
2f15				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f15 5f				db WORD_SYS_CORE+75             
2f16 f6 2f			dw .REPEAT            
2f18 06				db 5 + 1 
2f19 .. 00			db "-LOOP",0              
2f1f				endm 
# End of macro CWHEAD
2f1f			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f1f				; pop tos as current loop count to hl 
2f1f					if DEBUG_FORTH_WORDS_KEY 
2f1f						DMARK "-LP" 
2f1f f5				push af  
2f20 3a 34 2f			ld a, (.dmark)  
2f23 32 bd fb			ld (debug_mark),a  
2f26 3a 35 2f			ld a, (.dmark+1)  
2f29 32 be fb			ld (debug_mark+1),a  
2f2c 3a 36 2f			ld a, (.dmark+2)  
2f2f 32 bf fb			ld (debug_mark+2),a  
2f32 18 03			jr .pastdmark  
2f34 ..			.dmark: db "-LP"  
2f37 f1			.pastdmark: pop af  
2f38			endm  
# End of macro DMARK
2f38						CALLMONITOR 
2f38 cd d3 13			call break_point_state  
2f3b				endm  
# End of macro CALLMONITOR
2f3b					endif 
2f3b			 
2f3b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f3b			 
2f3b				FORTH_LOOP_TOS 
2f3b cd 43 1a			call macro_forth_loop_tos 
2f3e				endm 
# End of macro FORTH_LOOP_TOS
2f3e e5				push hl 
2f3f			 
2f3f					if DEBUG_FORTH_WORDS 
2f3f						DMARK "-LP" 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 bd fb			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 be fb			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 bf fb			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "-LP"  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58						CALLMONITOR 
2f58 cd d3 13			call break_point_state  
2f5b				endm  
# End of macro CALLMONITOR
2f5b					endif 
2f5b				; next item on the stack is the limit. get it 
2f5b			 
2f5b			 
2f5b				FORTH_LOOP_POP 
2f5b cd 4d 1a			call macro_forth_loop_pop 
2f5e				endm 
# End of macro FORTH_LOOP_POP
2f5e			 
2f5e				FORTH_LOOP_TOS 
2f5e cd 43 1a			call macro_forth_loop_tos 
2f61				endm 
# End of macro FORTH_LOOP_TOS
2f61			 
2f61 d1				pop de		 ; de = i, hl = limit 
2f62			 
2f62					if DEBUG_FORTH_WORDS 
2f62						DMARK "-L1" 
2f62 f5				push af  
2f63 3a 77 2f			ld a, (.dmark)  
2f66 32 bd fb			ld (debug_mark),a  
2f69 3a 78 2f			ld a, (.dmark+1)  
2f6c 32 be fb			ld (debug_mark+1),a  
2f6f 3a 79 2f			ld a, (.dmark+2)  
2f72 32 bf fb			ld (debug_mark+2),a  
2f75 18 03			jr .pastdmark  
2f77 ..			.dmark: db "-L1"  
2f7a f1			.pastdmark: pop af  
2f7b			endm  
# End of macro DMARK
2f7b						CALLMONITOR 
2f7b cd d3 13			call break_point_state  
2f7e				endm  
# End of macro CALLMONITOR
2f7e					endif 
2f7e			 
2f7e				; go back to previous word 
2f7e			 
2f7e d5				push de    ; save I for inc later 
2f7f			 
2f7f			 
2f7f				; get limit 
2f7f				;  is I at limit? 
2f7f			 
2f7f			 
2f7f					if DEBUG_FORTH_WORDS 
2f7f						DMARK "-L1" 
2f7f f5				push af  
2f80 3a 94 2f			ld a, (.dmark)  
2f83 32 bd fb			ld (debug_mark),a  
2f86 3a 95 2f			ld a, (.dmark+1)  
2f89 32 be fb			ld (debug_mark+1),a  
2f8c 3a 96 2f			ld a, (.dmark+2)  
2f8f 32 bf fb			ld (debug_mark+2),a  
2f92 18 03			jr .pastdmark  
2f94 ..			.dmark: db "-L1"  
2f97 f1			.pastdmark: pop af  
2f98			endm  
# End of macro DMARK
2f98						CALLMONITOR 
2f98 cd d3 13			call break_point_state  
2f9b				endm  
# End of macro CALLMONITOR
2f9b					endif 
2f9b			 
2f9b ed 52			sbc hl, de 
2f9d			 
2f9d			 
2f9d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f9d			 
2f9d 20 26				jr nz, .mloopnotdone 
2f9f			 
2f9f e1				pop hl   ; get rid of saved I 
2fa0				FORTH_LOOP_POP     ; get rid of limit 
2fa0 cd 4d 1a			call macro_forth_loop_pop 
2fa3				endm 
# End of macro FORTH_LOOP_POP
2fa3			 
2fa3				FORTH_RSP_POP     ; get rid of DO ptr 
2fa3 cd 28 19			call macro_forth_rsp_pop 
2fa6				endm 
# End of macro FORTH_RSP_POP
2fa6			 
2fa6			if DEBUG_FORTH_WORDS 
2fa6						DMARK "-L>" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 bd fb			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 be fb			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 bf fb			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "-L>"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf				CALLMONITOR 
2fbf cd d3 13			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2			endif 
2fc2			 
2fc2					NEXTW 
2fc2 c3 51 1b			jp macro_next 
2fc5				endm 
# End of macro NEXTW
2fc5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2fc5			 
2fc5			.mloopnotdone: 
2fc5			 
2fc5 e1				pop hl    ; get I 
2fc6 2b				dec hl 
2fc7			 
2fc7			   	; save new I 
2fc7			 
2fc7			 
2fc7					; set I counter 
2fc7			 
2fc7 22 dd f2				ld (os_current_i), hl 
2fca			 
2fca					 
2fca				FORTH_LOOP_NEXT 
2fca cd 10 1a			call macro_forth_loop_next 
2fcd				endm 
# End of macro FORTH_LOOP_NEXT
2fcd			 
2fcd			 
2fcd					if DEBUG_FORTH_WORDS 
2fcd eb						ex de,hl 
2fce					endif 
2fce			 
2fce			;	; get DO ptr 
2fce			; 
2fce				FORTH_RSP_TOS 
2fce cd 1e 19			call macro_forth_rsp_tos 
2fd1				endm 
# End of macro FORTH_RSP_TOS
2fd1			 
2fd1				;push hl 
2fd1			 
2fd1				; not going to DO any more 
2fd1				; get rid of the RSP pointer as DO will add it back in 
2fd1				;FORTH_RSP_POP 
2fd1				;pop hl 
2fd1			 
2fd1			 
2fd1 22 b9 f2			ld (os_tok_ptr), hl 
2fd4					if DEBUG_FORTH_WORDS 
2fd4						DMARK "-L<" 
2fd4 f5				push af  
2fd5 3a e9 2f			ld a, (.dmark)  
2fd8 32 bd fb			ld (debug_mark),a  
2fdb 3a ea 2f			ld a, (.dmark+1)  
2fde 32 be fb			ld (debug_mark+1),a  
2fe1 3a eb 2f			ld a, (.dmark+2)  
2fe4 32 bf fb			ld (debug_mark+2),a  
2fe7 18 03			jr .pastdmark  
2fe9 ..			.dmark: db "-L<"  
2fec f1			.pastdmark: pop af  
2fed			endm  
# End of macro DMARK
2fed					CALLMONITOR 
2fed cd d3 13			call break_point_state  
2ff0				endm  
# End of macro CALLMONITOR
2ff0				endif 
2ff0 c3 e2 1b			jp exec1 
2ff3			 
2ff3					 
2ff3			 
2ff3			 
2ff3			 
2ff3				NEXTW 
2ff3 c3 51 1b			jp macro_next 
2ff6				endm 
# End of macro NEXTW
2ff6			 
2ff6			 
2ff6			 
2ff6			 
2ff6			.REPEAT: 
2ff6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
2ff6 71				db WORD_SYS_CORE+93             
2ff7 49 30			dw .UNTIL            
2ff9 06				db 5 + 1 
2ffa .. 00			db "REPEAT",0              
3001				endm 
# End of macro CWHEAD
3001			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3001			;  push pc to rsp stack past the REPEAT 
3001					if DEBUG_FORTH_WORDS_KEY 
3001						DMARK "REP" 
3001 f5				push af  
3002 3a 16 30			ld a, (.dmark)  
3005 32 bd fb			ld (debug_mark),a  
3008 3a 17 30			ld a, (.dmark+1)  
300b 32 be fb			ld (debug_mark+1),a  
300e 3a 18 30			ld a, (.dmark+2)  
3011 32 bf fb			ld (debug_mark+2),a  
3014 18 03			jr .pastdmark  
3016 ..			.dmark: db "REP"  
3019 f1			.pastdmark: pop af  
301a			endm  
# End of macro DMARK
301a						CALLMONITOR 
301a cd d3 13			call break_point_state  
301d				endm  
# End of macro CALLMONITOR
301d					endif 
301d			 
301d 2a b9 f2				ld hl, (os_tok_ptr) 
3020 23					inc hl   ; R 
3021 23					inc hl  ; E 
3022 23					inc hl   ; P 
3023 23					inc hl   ; E 
3024 23					inc hl   ; A 
3025 23					inc hl   ; T 
3026 23					inc hl   ; zero 
3027					FORTH_RSP_NEXT 
3027 cd 07 19			call macro_forth_rsp_next 
302a				endm 
# End of macro FORTH_RSP_NEXT
302a			 
302a			 
302a					if DEBUG_FORTH_WORDS 
302a						DMARK "REP" 
302a f5				push af  
302b 3a 3f 30			ld a, (.dmark)  
302e 32 bd fb			ld (debug_mark),a  
3031 3a 40 30			ld a, (.dmark+1)  
3034 32 be fb			ld (debug_mark+1),a  
3037 3a 41 30			ld a, (.dmark+2)  
303a 32 bf fb			ld (debug_mark+2),a  
303d 18 03			jr .pastdmark  
303f ..			.dmark: db "REP"  
3042 f1			.pastdmark: pop af  
3043			endm  
# End of macro DMARK
3043						;pop bc    ; TODO BUG ?????? what is this for???? 
3043						CALLMONITOR 
3043 cd d3 13			call break_point_state  
3046				endm  
# End of macro CALLMONITOR
3046					endif 
3046			 
3046					NEXTW 
3046 c3 51 1b			jp macro_next 
3049				endm 
# End of macro NEXTW
3049			;	       NEXTW 
3049			 
3049			.UNTIL: 
3049				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3049 72				db WORD_SYS_CORE+94             
304a e0 30			dw .ENDFLOW            
304c 06				db 5 + 1 
304d .. 00			db "UNTIL",0              
3053				endm 
# End of macro CWHEAD
3053			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3053			 
3053				; pop tos as check 
3053			 
3053				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3053			 
3053				FORTH_DSP_VALUEHL 
3053 cd fb 19			call macro_dsp_valuehl 
3056				endm 
# End of macro FORTH_DSP_VALUEHL
3056			 
3056					if DEBUG_FORTH_WORDS_KEY 
3056						DMARK "UNT" 
3056 f5				push af  
3057 3a 6b 30			ld a, (.dmark)  
305a 32 bd fb			ld (debug_mark),a  
305d 3a 6c 30			ld a, (.dmark+1)  
3060 32 be fb			ld (debug_mark+1),a  
3063 3a 6d 30			ld a, (.dmark+2)  
3066 32 bf fb			ld (debug_mark+2),a  
3069 18 03			jr .pastdmark  
306b ..			.dmark: db "UNT"  
306e f1			.pastdmark: pop af  
306f			endm  
# End of macro DMARK
306f						CALLMONITOR 
306f cd d3 13			call break_point_state  
3072				endm  
# End of macro CALLMONITOR
3072					endif 
3072			 
3072			;	push hl 
3072				FORTH_DSP_POP 
3072 cd 97 1a			call macro_forth_dsp_pop 
3075				endm 
# End of macro FORTH_DSP_POP
3075			 
3075			;	pop hl 
3075			 
3075				; test if true 
3075			 
3075 cd 38 0c			call ishlzero 
3078			;	ld a,l 
3078			;	add h 
3078			; 
3078			;	cp 0 
3078			 
3078 20 3e			jr nz, .untilnotdone 
307a			 
307a					if DEBUG_FORTH_WORDS 
307a						DMARK "UNf" 
307a f5				push af  
307b 3a 8f 30			ld a, (.dmark)  
307e 32 bd fb			ld (debug_mark),a  
3081 3a 90 30			ld a, (.dmark+1)  
3084 32 be fb			ld (debug_mark+1),a  
3087 3a 91 30			ld a, (.dmark+2)  
308a 32 bf fb			ld (debug_mark+2),a  
308d 18 03			jr .pastdmark  
308f ..			.dmark: db "UNf"  
3092 f1			.pastdmark: pop af  
3093			endm  
# End of macro DMARK
3093						CALLMONITOR 
3093 cd d3 13			call break_point_state  
3096				endm  
# End of macro CALLMONITOR
3096					endif 
3096			 
3096			 
3096			 
3096				FORTH_RSP_POP     ; get rid of DO ptr 
3096 cd 28 19			call macro_forth_rsp_pop 
3099				endm 
# End of macro FORTH_RSP_POP
3099			 
3099			if DEBUG_FORTH_WORDS 
3099						DMARK "UN>" 
3099 f5				push af  
309a 3a ae 30			ld a, (.dmark)  
309d 32 bd fb			ld (debug_mark),a  
30a0 3a af 30			ld a, (.dmark+1)  
30a3 32 be fb			ld (debug_mark+1),a  
30a6 3a b0 30			ld a, (.dmark+2)  
30a9 32 bf fb			ld (debug_mark+2),a  
30ac 18 03			jr .pastdmark  
30ae ..			.dmark: db "UN>"  
30b1 f1			.pastdmark: pop af  
30b2			endm  
# End of macro DMARK
30b2				CALLMONITOR 
30b2 cd d3 13			call break_point_state  
30b5				endm  
# End of macro CALLMONITOR
30b5			endif 
30b5			 
30b5					NEXTW 
30b5 c3 51 1b			jp macro_next 
30b8				endm 
# End of macro NEXTW
30b8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30b8			 
30b8			.untilnotdone: 
30b8			 
30b8			 
30b8			;	; get DO ptr 
30b8			; 
30b8				FORTH_RSP_TOS 
30b8 cd 1e 19			call macro_forth_rsp_tos 
30bb				endm 
# End of macro FORTH_RSP_TOS
30bb			 
30bb				;push hl 
30bb			 
30bb				; not going to DO any more 
30bb				; get rid of the RSP pointer as DO will add it back in 
30bb				;FORTH_RSP_POP 
30bb				;pop hl 
30bb			 
30bb			 
30bb 22 b9 f2			ld (os_tok_ptr), hl 
30be					if DEBUG_FORTH_WORDS 
30be						DMARK "UN<" 
30be f5				push af  
30bf 3a d3 30			ld a, (.dmark)  
30c2 32 bd fb			ld (debug_mark),a  
30c5 3a d4 30			ld a, (.dmark+1)  
30c8 32 be fb			ld (debug_mark+1),a  
30cb 3a d5 30			ld a, (.dmark+2)  
30ce 32 bf fb			ld (debug_mark+2),a  
30d1 18 03			jr .pastdmark  
30d3 ..			.dmark: db "UN<"  
30d6 f1			.pastdmark: pop af  
30d7			endm  
# End of macro DMARK
30d7					CALLMONITOR 
30d7 cd d3 13			call break_point_state  
30da				endm  
# End of macro CALLMONITOR
30da				endif 
30da c3 e2 1b			jp exec1 
30dd			 
30dd					 
30dd			 
30dd			 
30dd					NEXTW 
30dd c3 51 1b			jp macro_next 
30e0				endm 
# End of macro NEXTW
30e0			 
30e0			 
30e0			.ENDFLOW: 
30e0			 
30e0			; eof 
30e0			 
# End of file forth_words_flow.asm
30e0			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
30e0			include "forth_words_logic.asm" 
30e0			 
30e0			; | ## Logic Words 
30e0			 
30e0			.NOT: 
30e0				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
30e0 2d				db WORD_SYS_CORE+25             
30e1 28 31			dw .IS            
30e3 04				db 3 + 1 
30e4 .. 00			db "NOT",0              
30e8				endm 
# End of macro CWHEAD
30e8			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
30e8					if DEBUG_FORTH_WORDS_KEY 
30e8						DMARK "NOT" 
30e8 f5				push af  
30e9 3a fd 30			ld a, (.dmark)  
30ec 32 bd fb			ld (debug_mark),a  
30ef 3a fe 30			ld a, (.dmark+1)  
30f2 32 be fb			ld (debug_mark+1),a  
30f5 3a ff 30			ld a, (.dmark+2)  
30f8 32 bf fb			ld (debug_mark+2),a  
30fb 18 03			jr .pastdmark  
30fd ..			.dmark: db "NOT"  
3100 f1			.pastdmark: pop af  
3101			endm  
# End of macro DMARK
3101						CALLMONITOR 
3101 cd d3 13			call break_point_state  
3104				endm  
# End of macro CALLMONITOR
3104					endif 
3104					FORTH_DSP 
3104 cd e0 19			call macro_forth_dsp 
3107				endm 
# End of macro FORTH_DSP
3107 7e					ld a,(hl)	; get type of value on TOS 
3108 fe 02				cp DS_TYPE_INUM  
310a 28 03				jr z, .noti 
310c					NEXTW 
310c c3 51 1b			jp macro_next 
310f				endm 
# End of macro NEXTW
310f			.noti:          FORTH_DSP_VALUEHL 
310f cd fb 19			call macro_dsp_valuehl 
3112				endm 
# End of macro FORTH_DSP_VALUEHL
3112			;		push hl 
3112					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3112 cd 97 1a			call macro_forth_dsp_pop 
3115				endm 
# End of macro FORTH_DSP_POP
3115			;		pop hl 
3115 3e 00				ld a,0 
3117 bd					cp l 
3118 28 04				jr z, .not2t 
311a 2e 00				ld l, 0 
311c 18 02				jr .notip 
311e			 
311e 2e ff		.not2t:		ld l, 255 
3120			 
3120 26 00		.notip:		ld h, 0	 
3122			 
3122 cd 60 19				call forth_push_numhl 
3125					NEXTW 
3125 c3 51 1b			jp macro_next 
3128				endm 
# End of macro NEXTW
3128			 
3128			.IS: 
3128				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3128 2d				db WORD_SYS_CORE+25             
3129 4e 31			dw .LZERO            
312b 03				db 2 + 1 
312c .. 00			db "IS",0              
312f				endm 
# End of macro CWHEAD
312f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
312f					if DEBUG_FORTH_WORDS_KEY 
312f						DMARK "IS." 
312f f5				push af  
3130 3a 44 31			ld a, (.dmark)  
3133 32 bd fb			ld (debug_mark),a  
3136 3a 45 31			ld a, (.dmark+1)  
3139 32 be fb			ld (debug_mark+1),a  
313c 3a 46 31			ld a, (.dmark+2)  
313f 32 bf fb			ld (debug_mark+2),a  
3142 18 03			jr .pastdmark  
3144 ..			.dmark: db "IS."  
3147 f1			.pastdmark: pop af  
3148			endm  
# End of macro DMARK
3148						CALLMONITOR 
3148 cd d3 13			call break_point_state  
314b				endm  
# End of macro CALLMONITOR
314b					endif 
314b					NEXTW 
314b c3 51 1b			jp macro_next 
314e				endm 
# End of macro NEXTW
314e			.LZERO: 
314e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
314e 2d				db WORD_SYS_CORE+25             
314f 58 31			dw .TZERO            
3151 03				db 2 + 1 
3152 .. 00			db "0<",0              
3155				endm 
# End of macro CWHEAD
3155			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3155					NEXTW 
3155 c3 51 1b			jp macro_next 
3158				endm 
# End of macro NEXTW
3158			.TZERO: 
3158				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3158 2e				db WORD_SYS_CORE+26             
3159 9f 31			dw .LESS            
315b 03				db 2 + 1 
315c .. 00			db "0=",0              
315f				endm 
# End of macro CWHEAD
315f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
315f				; TODO add floating point number detection 
315f					;v5 FORTH_DSP_VALUE 
315f					if DEBUG_FORTH_WORDS_KEY 
315f						DMARK "0=." 
315f f5				push af  
3160 3a 74 31			ld a, (.dmark)  
3163 32 bd fb			ld (debug_mark),a  
3166 3a 75 31			ld a, (.dmark+1)  
3169 32 be fb			ld (debug_mark+1),a  
316c 3a 76 31			ld a, (.dmark+2)  
316f 32 bf fb			ld (debug_mark+2),a  
3172 18 03			jr .pastdmark  
3174 ..			.dmark: db "0=."  
3177 f1			.pastdmark: pop af  
3178			endm  
# End of macro DMARK
3178						CALLMONITOR 
3178 cd d3 13			call break_point_state  
317b				endm  
# End of macro CALLMONITOR
317b					endif 
317b					FORTH_DSP 
317b cd e0 19			call macro_forth_dsp 
317e				endm 
# End of macro FORTH_DSP
317e 7e					ld a,(hl)	; get type of value on TOS 
317f fe 02				cp DS_TYPE_INUM  
3181 28 00				jr z, .tz_inum 
3183			 
3183				if FORTH_ENABLE_FLOATMATH 
3183					jr .tz_done 
3183			 
3183				endif 
3183					 
3183			 
3183			.tz_inum: 
3183					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3183 cd fb 19			call macro_dsp_valuehl 
3186				endm 
# End of macro FORTH_DSP_VALUEHL
3186			 
3186			;		push hl 
3186			 
3186					; destroy value TOS 
3186			 
3186					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3186 cd 97 1a			call macro_forth_dsp_pop 
3189				endm 
# End of macro FORTH_DSP_POP
3189			 
3189			;		pop hl 
3189			 
3189 3e 00				ld a,0 
318b			 
318b bd					cp l 
318c 20 08				jr nz, .tz_notzero 
318e			 
318e bc					cp h 
318f			 
318f 20 05				jr nz, .tz_notzero 
3191			 
3191			 
3191 21 01 00				ld hl, FORTH_TRUE 
3194 18 03				jr .tz_done 
3196			 
3196 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3199			 
3199					; push value back onto stack for another op etc 
3199			 
3199			.tz_done: 
3199 cd 60 19				call forth_push_numhl 
319c			 
319c					NEXTW 
319c c3 51 1b			jp macro_next 
319f				endm 
# End of macro NEXTW
319f			.LESS: 
319f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
319f 2f				db WORD_SYS_CORE+27             
31a0 08 32			dw .GT            
31a2 02				db 1 + 1 
31a3 .. 00			db "<",0              
31a5				endm 
# End of macro CWHEAD
31a5			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
31a5				; TODO add floating point number detection 
31a5					if DEBUG_FORTH_WORDS_KEY 
31a5						DMARK "LES" 
31a5 f5				push af  
31a6 3a ba 31			ld a, (.dmark)  
31a9 32 bd fb			ld (debug_mark),a  
31ac 3a bb 31			ld a, (.dmark+1)  
31af 32 be fb			ld (debug_mark+1),a  
31b2 3a bc 31			ld a, (.dmark+2)  
31b5 32 bf fb			ld (debug_mark+2),a  
31b8 18 03			jr .pastdmark  
31ba ..			.dmark: db "LES"  
31bd f1			.pastdmark: pop af  
31be			endm  
# End of macro DMARK
31be						CALLMONITOR 
31be cd d3 13			call break_point_state  
31c1				endm  
# End of macro CALLMONITOR
31c1					endif 
31c1					FORTH_DSP 
31c1 cd e0 19			call macro_forth_dsp 
31c4				endm 
# End of macro FORTH_DSP
31c4					;v5 FORTH_DSP_VALUE 
31c4 7e					ld a,(hl)	; get type of value on TOS 
31c5 fe 02				cp DS_TYPE_INUM  
31c7 28 00				jr z, .less_inum 
31c9			 
31c9				if FORTH_ENABLE_FLOATMATH 
31c9					jr .less_done 
31c9			 
31c9				endif 
31c9					 
31c9			 
31c9			.less_inum: 
31c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31c9 cd fb 19			call macro_dsp_valuehl 
31cc				endm 
# End of macro FORTH_DSP_VALUEHL
31cc			 
31cc e5					push hl  ; u2 
31cd			 
31cd					; destroy value TOS 
31cd			 
31cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31cd cd 97 1a			call macro_forth_dsp_pop 
31d0				endm 
# End of macro FORTH_DSP_POP
31d0			 
31d0			 
31d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31d0 cd fb 19			call macro_dsp_valuehl 
31d3				endm 
# End of macro FORTH_DSP_VALUEHL
31d3			 
31d3 e5					push hl    ; u1 
31d4			 
31d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31d4 cd 97 1a			call macro_forth_dsp_pop 
31d7				endm 
# End of macro FORTH_DSP_POP
31d7			 
31d7			 
31d7 b7			 or a      ;clear carry flag 
31d8 01 00 00		 ld bc, FORTH_FALSE 
31db e1			  pop hl    ; u1 
31dc d1			  pop de    ; u2 
31dd ed 52		  sbc hl,de 
31df 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
31e1			 
31e1 01 01 00		 ld bc, FORTH_TRUE 
31e4			.lscont:  
31e4 c5					push bc 
31e5 e1					pop hl 
31e6			 
31e6					if DEBUG_FORTH_WORDS 
31e6						DMARK "LT1" 
31e6 f5				push af  
31e7 3a fb 31			ld a, (.dmark)  
31ea 32 bd fb			ld (debug_mark),a  
31ed 3a fc 31			ld a, (.dmark+1)  
31f0 32 be fb			ld (debug_mark+1),a  
31f3 3a fd 31			ld a, (.dmark+2)  
31f6 32 bf fb			ld (debug_mark+2),a  
31f9 18 03			jr .pastdmark  
31fb ..			.dmark: db "LT1"  
31fe f1			.pastdmark: pop af  
31ff			endm  
# End of macro DMARK
31ff						CALLMONITOR 
31ff cd d3 13			call break_point_state  
3202				endm  
# End of macro CALLMONITOR
3202					endif 
3202 cd 60 19				call forth_push_numhl 
3205			 
3205					NEXTW 
3205 c3 51 1b			jp macro_next 
3208				endm 
# End of macro NEXTW
3208			.GT: 
3208				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3208 30				db WORD_SYS_CORE+28             
3209 71 32			dw .EQUAL            
320b 02				db 1 + 1 
320c .. 00			db ">",0              
320e				endm 
# End of macro CWHEAD
320e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
320e				; TODO add floating point number detection 
320e					if DEBUG_FORTH_WORDS_KEY 
320e						DMARK "GRT" 
320e f5				push af  
320f 3a 23 32			ld a, (.dmark)  
3212 32 bd fb			ld (debug_mark),a  
3215 3a 24 32			ld a, (.dmark+1)  
3218 32 be fb			ld (debug_mark+1),a  
321b 3a 25 32			ld a, (.dmark+2)  
321e 32 bf fb			ld (debug_mark+2),a  
3221 18 03			jr .pastdmark  
3223 ..			.dmark: db "GRT"  
3226 f1			.pastdmark: pop af  
3227			endm  
# End of macro DMARK
3227						CALLMONITOR 
3227 cd d3 13			call break_point_state  
322a				endm  
# End of macro CALLMONITOR
322a					endif 
322a					FORTH_DSP 
322a cd e0 19			call macro_forth_dsp 
322d				endm 
# End of macro FORTH_DSP
322d					;FORTH_DSP_VALUE 
322d 7e					ld a,(hl)	; get type of value on TOS 
322e fe 02				cp DS_TYPE_INUM  
3230 28 00				jr z, .gt_inum 
3232			 
3232				if FORTH_ENABLE_FLOATMATH 
3232					jr .gt_done 
3232			 
3232				endif 
3232					 
3232			 
3232			.gt_inum: 
3232					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3232 cd fb 19			call macro_dsp_valuehl 
3235				endm 
# End of macro FORTH_DSP_VALUEHL
3235			 
3235 e5					push hl  ; u2 
3236			 
3236					; destroy value TOS 
3236			 
3236					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3236 cd 97 1a			call macro_forth_dsp_pop 
3239				endm 
# End of macro FORTH_DSP_POP
3239			 
3239			 
3239					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3239 cd fb 19			call macro_dsp_valuehl 
323c				endm 
# End of macro FORTH_DSP_VALUEHL
323c			 
323c e5					push hl    ; u1 
323d			 
323d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
323d cd 97 1a			call macro_forth_dsp_pop 
3240				endm 
# End of macro FORTH_DSP_POP
3240			 
3240			 
3240 b7			 or a      ;clear carry flag 
3241 01 00 00		 ld bc, FORTH_FALSE 
3244 e1			  pop hl    ; u1 
3245 d1			  pop de    ; u2 
3246 ed 52		  sbc hl,de 
3248 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
324a			 
324a 01 01 00		 ld bc, FORTH_TRUE 
324d			.gtcont:  
324d c5					push bc 
324e e1					pop hl 
324f			 
324f					if DEBUG_FORTH_WORDS 
324f						DMARK "GT1" 
324f f5				push af  
3250 3a 64 32			ld a, (.dmark)  
3253 32 bd fb			ld (debug_mark),a  
3256 3a 65 32			ld a, (.dmark+1)  
3259 32 be fb			ld (debug_mark+1),a  
325c 3a 66 32			ld a, (.dmark+2)  
325f 32 bf fb			ld (debug_mark+2),a  
3262 18 03			jr .pastdmark  
3264 ..			.dmark: db "GT1"  
3267 f1			.pastdmark: pop af  
3268			endm  
# End of macro DMARK
3268						CALLMONITOR 
3268 cd d3 13			call break_point_state  
326b				endm  
# End of macro CALLMONITOR
326b					endif 
326b cd 60 19				call forth_push_numhl 
326e			 
326e					NEXTW 
326e c3 51 1b			jp macro_next 
3271				endm 
# End of macro NEXTW
3271			.EQUAL: 
3271				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3271 31				db WORD_SYS_CORE+29             
3272 dc 32			dw .ENDLOGIC            
3274 02				db 1 + 1 
3275 .. 00			db "=",0              
3277				endm 
# End of macro CWHEAD
3277			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3277				; TODO add floating point number detection 
3277					if DEBUG_FORTH_WORDS_KEY 
3277						DMARK "EQ." 
3277 f5				push af  
3278 3a 8c 32			ld a, (.dmark)  
327b 32 bd fb			ld (debug_mark),a  
327e 3a 8d 32			ld a, (.dmark+1)  
3281 32 be fb			ld (debug_mark+1),a  
3284 3a 8e 32			ld a, (.dmark+2)  
3287 32 bf fb			ld (debug_mark+2),a  
328a 18 03			jr .pastdmark  
328c ..			.dmark: db "EQ."  
328f f1			.pastdmark: pop af  
3290			endm  
# End of macro DMARK
3290						CALLMONITOR 
3290 cd d3 13			call break_point_state  
3293				endm  
# End of macro CALLMONITOR
3293					endif 
3293					FORTH_DSP 
3293 cd e0 19			call macro_forth_dsp 
3296				endm 
# End of macro FORTH_DSP
3296					;v5 FORTH_DSP_VALUE 
3296 7e					ld a,(hl)	; get type of value on TOS 
3297 fe 02				cp DS_TYPE_INUM  
3299 28 00				jr z, .eq_inum 
329b			 
329b				if FORTH_ENABLE_FLOATMATH 
329b					jr .eq_done 
329b			 
329b				endif 
329b					 
329b			 
329b			.eq_inum: 
329b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
329b cd fb 19			call macro_dsp_valuehl 
329e				endm 
# End of macro FORTH_DSP_VALUEHL
329e			 
329e e5					push hl 
329f			 
329f					; destroy value TOS 
329f			 
329f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
329f cd 97 1a			call macro_forth_dsp_pop 
32a2				endm 
# End of macro FORTH_DSP_POP
32a2			 
32a2			 
32a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a2 cd fb 19			call macro_dsp_valuehl 
32a5				endm 
# End of macro FORTH_DSP_VALUEHL
32a5			 
32a5					; one value on hl get other one back 
32a5			 
32a5 e5					push hl 
32a6			 
32a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32a6 cd 97 1a			call macro_forth_dsp_pop 
32a9				endm 
# End of macro FORTH_DSP_POP
32a9			 
32a9 0e 00				ld c, FORTH_FALSE 
32ab			 
32ab e1					pop hl 
32ac d1					pop de 
32ad			 
32ad 7b					ld a, e 
32ae bd					cp l 
32af			 
32af 20 06				jr nz, .eq_done 
32b1			 
32b1 7a					ld a, d 
32b2 bc					cp h 
32b3			 
32b3 20 02				jr nz, .eq_done 
32b5			 
32b5 0e 01				ld c, FORTH_TRUE 
32b7					 
32b7			 
32b7			 
32b7			.eq_done: 
32b7			 
32b7					; TODO push value back onto stack for another op etc 
32b7			 
32b7 26 00				ld h, 0 
32b9 69					ld l, c 
32ba					if DEBUG_FORTH_WORDS 
32ba						DMARK "EQ1" 
32ba f5				push af  
32bb 3a cf 32			ld a, (.dmark)  
32be 32 bd fb			ld (debug_mark),a  
32c1 3a d0 32			ld a, (.dmark+1)  
32c4 32 be fb			ld (debug_mark+1),a  
32c7 3a d1 32			ld a, (.dmark+2)  
32ca 32 bf fb			ld (debug_mark+2),a  
32cd 18 03			jr .pastdmark  
32cf ..			.dmark: db "EQ1"  
32d2 f1			.pastdmark: pop af  
32d3			endm  
# End of macro DMARK
32d3						CALLMONITOR 
32d3 cd d3 13			call break_point_state  
32d6				endm  
# End of macro CALLMONITOR
32d6					endif 
32d6 cd 60 19				call forth_push_numhl 
32d9			 
32d9					NEXTW 
32d9 c3 51 1b			jp macro_next 
32dc				endm 
# End of macro NEXTW
32dc			 
32dc			 
32dc			.ENDLOGIC: 
32dc			; eof 
32dc			 
32dc			 
# End of file forth_words_logic.asm
32dc			include "forth_words_maths.asm" 
32dc			 
32dc			; | ## Maths Words 
32dc			 
32dc			.PLUS:	 
32dc				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
32dc 15				db WORD_SYS_CORE+1             
32dd 1e 33			dw .NEG            
32df 02				db 1 + 1 
32e0 .. 00			db "+",0              
32e2				endm 
# End of macro CWHEAD
32e2			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
32e2					if DEBUG_FORTH_WORDS_KEY 
32e2						DMARK "PLU" 
32e2 f5				push af  
32e3 3a f7 32			ld a, (.dmark)  
32e6 32 bd fb			ld (debug_mark),a  
32e9 3a f8 32			ld a, (.dmark+1)  
32ec 32 be fb			ld (debug_mark+1),a  
32ef 3a f9 32			ld a, (.dmark+2)  
32f2 32 bf fb			ld (debug_mark+2),a  
32f5 18 03			jr .pastdmark  
32f7 ..			.dmark: db "PLU"  
32fa f1			.pastdmark: pop af  
32fb			endm  
# End of macro DMARK
32fb						CALLMONITOR 
32fb cd d3 13			call break_point_state  
32fe				endm  
# End of macro CALLMONITOR
32fe					endif 
32fe					; add top two values and push back result 
32fe			 
32fe					;for v5 FORTH_DSP_VALUE 
32fe					FORTH_DSP 
32fe cd e0 19			call macro_forth_dsp 
3301				endm 
# End of macro FORTH_DSP
3301 7e					ld a,(hl)	; get type of value on TOS 
3302 fe 02				cp DS_TYPE_INUM  
3304 28 03				jr z, .dot_inum 
3306			 
3306					NEXTW 
3306 c3 51 1b			jp macro_next 
3309				endm 
# End of macro NEXTW
3309			 
3309			; float maths 
3309			 
3309				if FORTH_ENABLE_FLOATMATH 
3309						inc hl      ; now at start of numeric as string 
3309			 
3309					if DEBUG_FORTH_MATHS 
3309						DMARK "ADD" 
3309				CALLMONITOR 
3309					endif 
3309			 
3309					;ld ix, hl 
3309					call CON 
3309			 
3309			 
3309					push hl 
3309					 
3309					 
3309			 
3309						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3309			 
3309					; get next number 
3309			 
3309						FORTH_DSP_VALUE 
3309			 
3309						inc hl      ; now at start of numeric as string 
3309			 
3309					;ld ix, hl 
3309					call CON 
3309			 
3309					push hl 
3309			 
3309			 
3309						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3309			 
3309						; TODO do add 
3309			 
3309						call IADD 
3309			 
3309						; TODO get result back as ascii 
3309			 
3309						; TODO push result  
3309			 
3309			 
3309			 
3309						jr .dot_done 
3309				endif 
3309			 
3309			.dot_inum: 
3309			 
3309			 
3309					if DEBUG_FORTH_DOT 
3309						DMARK "+IT" 
3309				CALLMONITOR 
3309					endif 
3309			 
3309					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3309 cd fb 19			call macro_dsp_valuehl 
330c				endm 
# End of macro FORTH_DSP_VALUEHL
330c			 
330c				; TODO add floating point number detection 
330c			 
330c e5					push hl 
330d			 
330d					; destroy value TOS 
330d			 
330d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
330d cd 97 1a			call macro_forth_dsp_pop 
3310				endm 
# End of macro FORTH_DSP_POP
3310			 
3310			 
3310					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3310 cd fb 19			call macro_dsp_valuehl 
3313				endm 
# End of macro FORTH_DSP_VALUEHL
3313			 
3313					; one value on hl get other one back 
3313			 
3313 d1					pop de 
3314			 
3314					; do the add 
3314			 
3314 19					add hl,de 
3315			 
3315					; save it 
3315			 
3315			;		push hl	 
3315			 
3315					; 
3315			 
3315					; destroy value TOS 
3315			 
3315					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3315 cd 97 1a			call macro_forth_dsp_pop 
3318				endm 
# End of macro FORTH_DSP_POP
3318			 
3318					; TODO push value back onto stack for another op etc 
3318			 
3318			;		pop hl 
3318			 
3318			.dot_done: 
3318 cd 60 19				call forth_push_numhl 
331b			 
331b					NEXTW 
331b c3 51 1b			jp macro_next 
331e				endm 
# End of macro NEXTW
331e			.NEG: 
331e			 
331e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
331e 17				db WORD_SYS_CORE+3             
331f 61 33			dw .DIV            
3321 02				db 1 + 1 
3322 .. 00			db "-",0              
3324				endm 
# End of macro CWHEAD
3324			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3324					if DEBUG_FORTH_WORDS_KEY 
3324						DMARK "SUB" 
3324 f5				push af  
3325 3a 39 33			ld a, (.dmark)  
3328 32 bd fb			ld (debug_mark),a  
332b 3a 3a 33			ld a, (.dmark+1)  
332e 32 be fb			ld (debug_mark+1),a  
3331 3a 3b 33			ld a, (.dmark+2)  
3334 32 bf fb			ld (debug_mark+2),a  
3337 18 03			jr .pastdmark  
3339 ..			.dmark: db "SUB"  
333c f1			.pastdmark: pop af  
333d			endm  
# End of macro DMARK
333d						CALLMONITOR 
333d cd d3 13			call break_point_state  
3340				endm  
# End of macro CALLMONITOR
3340					endif 
3340			 
3340			 
3340				; TODO add floating point number detection 
3340					; v5 FORTH_DSP_VALUE 
3340					FORTH_DSP 
3340 cd e0 19			call macro_forth_dsp 
3343				endm 
# End of macro FORTH_DSP
3343 7e					ld a,(hl)	; get type of value on TOS 
3344 fe 02				cp DS_TYPE_INUM  
3346 28 03				jr z, .neg_inum 
3348			 
3348					NEXTW 
3348 c3 51 1b			jp macro_next 
334b				endm 
# End of macro NEXTW
334b			 
334b			; float maths 
334b			 
334b				if FORTH_ENABLE_FLOATMATH 
334b					jr .neg_done 
334b			 
334b				endif 
334b					 
334b			 
334b			.neg_inum: 
334b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
334b cd fb 19			call macro_dsp_valuehl 
334e				endm 
# End of macro FORTH_DSP_VALUEHL
334e			 
334e e5					push hl 
334f			 
334f					; destroy value TOS 
334f			 
334f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334f cd 97 1a			call macro_forth_dsp_pop 
3352				endm 
# End of macro FORTH_DSP_POP
3352			 
3352			 
3352					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3352 cd fb 19			call macro_dsp_valuehl 
3355				endm 
# End of macro FORTH_DSP_VALUEHL
3355			 
3355					; one value on hl get other one back 
3355			 
3355 d1					pop de 
3356			 
3356					; do the sub 
3356			;		ex de, hl 
3356			 
3356 ed 52				sbc hl,de 
3358			 
3358					; save it 
3358			 
3358			;		push hl	 
3358			 
3358					; 
3358			 
3358					; destroy value TOS 
3358			 
3358					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3358 cd 97 1a			call macro_forth_dsp_pop 
335b				endm 
# End of macro FORTH_DSP_POP
335b			 
335b					; TODO push value back onto stack for another op etc 
335b			 
335b			;		pop hl 
335b			 
335b cd 60 19				call forth_push_numhl 
335e			.neg_done: 
335e			 
335e					NEXTW 
335e c3 51 1b			jp macro_next 
3361				endm 
# End of macro NEXTW
3361			.DIV: 
3361				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3361 18				db WORD_SYS_CORE+4             
3362 ae 33			dw .MUL            
3364 02				db 1 + 1 
3365 .. 00			db "/",0              
3367				endm 
# End of macro CWHEAD
3367			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3367					if DEBUG_FORTH_WORDS_KEY 
3367						DMARK "DIV" 
3367 f5				push af  
3368 3a 7c 33			ld a, (.dmark)  
336b 32 bd fb			ld (debug_mark),a  
336e 3a 7d 33			ld a, (.dmark+1)  
3371 32 be fb			ld (debug_mark+1),a  
3374 3a 7e 33			ld a, (.dmark+2)  
3377 32 bf fb			ld (debug_mark+2),a  
337a 18 03			jr .pastdmark  
337c ..			.dmark: db "DIV"  
337f f1			.pastdmark: pop af  
3380			endm  
# End of macro DMARK
3380						CALLMONITOR 
3380 cd d3 13			call break_point_state  
3383				endm  
# End of macro CALLMONITOR
3383					endif 
3383				; TODO add floating point number detection 
3383					; v5 FORTH_DSP_VALUE 
3383					FORTH_DSP 
3383 cd e0 19			call macro_forth_dsp 
3386				endm 
# End of macro FORTH_DSP
3386 7e					ld a,(hl)	; get type of value on TOS 
3387 fe 02				cp DS_TYPE_INUM  
3389 28 03				jr z, .div_inum 
338b			 
338b				if FORTH_ENABLE_FLOATMATH 
338b					jr .div_done 
338b			 
338b				endif 
338b					NEXTW 
338b c3 51 1b			jp macro_next 
338e				endm 
# End of macro NEXTW
338e			.div_inum: 
338e			 
338e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
338e cd fb 19			call macro_dsp_valuehl 
3391				endm 
# End of macro FORTH_DSP_VALUEHL
3391			 
3391 e5					push hl    ; to go to bc 
3392			 
3392					; destroy value TOS 
3392			 
3392					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3392 cd 97 1a			call macro_forth_dsp_pop 
3395				endm 
# End of macro FORTH_DSP_POP
3395			 
3395			 
3395					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3395 cd fb 19			call macro_dsp_valuehl 
3398				endm 
# End of macro FORTH_DSP_VALUEHL
3398			 
3398					; hl to go to de 
3398			 
3398 e5					push hl 
3399			 
3399 c1					pop bc 
339a d1					pop de		 
339b			 
339b			 
339b					if DEBUG_FORTH_MATHS 
339b						DMARK "DIV" 
339b				CALLMONITOR 
339b					endif 
339b					; one value on hl but move to a get other one back 
339b			 
339b			        
339b cd 6c 0b			call Div16 
339e			 
339e			;	push af	 
339e e5				push hl 
339f c5				push bc 
33a0			 
33a0					if DEBUG_FORTH_MATHS 
33a0						DMARK "DI1" 
33a0				CALLMONITOR 
33a0					endif 
33a0			 
33a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33a0 cd 97 1a			call macro_forth_dsp_pop 
33a3				endm 
# End of macro FORTH_DSP_POP
33a3			 
33a3			 
33a3			 
33a3 e1					pop hl    ; result 
33a4			 
33a4 cd 60 19				call forth_push_numhl 
33a7			 
33a7 e1					pop hl    ; reminder 
33a8			;		ld h,0 
33a8			;		ld l,d 
33a8			 
33a8 cd 60 19				call forth_push_numhl 
33ab			.div_done: 
33ab					NEXTW 
33ab c3 51 1b			jp macro_next 
33ae				endm 
# End of macro NEXTW
33ae			.MUL: 
33ae				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
33ae 19				db WORD_SYS_CORE+5             
33af f3 33			dw .MIN            
33b1 02				db 1 + 1 
33b2 .. 00			db "*",0              
33b4				endm 
# End of macro CWHEAD
33b4			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
33b4				; TODO add floating point number detection 
33b4					if DEBUG_FORTH_WORDS_KEY 
33b4						DMARK "MUL" 
33b4 f5				push af  
33b5 3a c9 33			ld a, (.dmark)  
33b8 32 bd fb			ld (debug_mark),a  
33bb 3a ca 33			ld a, (.dmark+1)  
33be 32 be fb			ld (debug_mark+1),a  
33c1 3a cb 33			ld a, (.dmark+2)  
33c4 32 bf fb			ld (debug_mark+2),a  
33c7 18 03			jr .pastdmark  
33c9 ..			.dmark: db "MUL"  
33cc f1			.pastdmark: pop af  
33cd			endm  
# End of macro DMARK
33cd						CALLMONITOR 
33cd cd d3 13			call break_point_state  
33d0				endm  
# End of macro CALLMONITOR
33d0					endif 
33d0					FORTH_DSP 
33d0 cd e0 19			call macro_forth_dsp 
33d3				endm 
# End of macro FORTH_DSP
33d3					; v5 FORTH_DSP_VALUE 
33d3 7e					ld a,(hl)	; get type of value on TOS 
33d4 fe 02				cp DS_TYPE_INUM  
33d6 28 03				jr z, .mul_inum 
33d8			 
33d8				if FORTH_ENABLE_FLOATMATH 
33d8					jr .mul_done 
33d8			 
33d8				endif 
33d8			 
33d8					NEXTW 
33d8 c3 51 1b			jp macro_next 
33db				endm 
# End of macro NEXTW
33db			.mul_inum:	 
33db			 
33db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33db cd fb 19			call macro_dsp_valuehl 
33de				endm 
# End of macro FORTH_DSP_VALUEHL
33de			 
33de e5					push hl 
33df			 
33df					; destroy value TOS 
33df			 
33df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33df cd 97 1a			call macro_forth_dsp_pop 
33e2				endm 
# End of macro FORTH_DSP_POP
33e2			 
33e2			 
33e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e2 cd fb 19			call macro_dsp_valuehl 
33e5				endm 
# End of macro FORTH_DSP_VALUEHL
33e5			 
33e5					; one value on hl but move to a get other one back 
33e5			 
33e5 7d					ld a, l 
33e6			 
33e6 d1					pop de 
33e7			 
33e7					; do the mull 
33e7			;		ex de, hl 
33e7			 
33e7 cd 92 0b				call Mult16 
33ea					; save it 
33ea			 
33ea			;		push hl	 
33ea			 
33ea					; 
33ea			 
33ea					; destroy value TOS 
33ea			 
33ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ea cd 97 1a			call macro_forth_dsp_pop 
33ed				endm 
# End of macro FORTH_DSP_POP
33ed			 
33ed					; TODO push value back onto stack for another op etc 
33ed			 
33ed			;		pop hl 
33ed			 
33ed cd 60 19				call forth_push_numhl 
33f0			 
33f0			.mul_done: 
33f0					NEXTW 
33f0 c3 51 1b			jp macro_next 
33f3				endm 
# End of macro NEXTW
33f3			 
33f3			 
33f3			 
33f3			 
33f3			.MIN: 
33f3				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
33f3 49				db WORD_SYS_CORE+53             
33f4 74 34			dw .MAX            
33f6 04				db 3 + 1 
33f7 .. 00			db "MIN",0              
33fb				endm 
# End of macro CWHEAD
33fb			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
33fb					if DEBUG_FORTH_WORDS_KEY 
33fb						DMARK "MIN" 
33fb f5				push af  
33fc 3a 10 34			ld a, (.dmark)  
33ff 32 bd fb			ld (debug_mark),a  
3402 3a 11 34			ld a, (.dmark+1)  
3405 32 be fb			ld (debug_mark+1),a  
3408 3a 12 34			ld a, (.dmark+2)  
340b 32 bf fb			ld (debug_mark+2),a  
340e 18 03			jr .pastdmark  
3410 ..			.dmark: db "MIN"  
3413 f1			.pastdmark: pop af  
3414			endm  
# End of macro DMARK
3414						CALLMONITOR 
3414 cd d3 13			call break_point_state  
3417				endm  
# End of macro CALLMONITOR
3417					endif 
3417					; get u2 
3417			 
3417					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3417 cd fb 19			call macro_dsp_valuehl 
341a				endm 
# End of macro FORTH_DSP_VALUEHL
341a			 
341a e5					push hl   ; u2 
341b			 
341b					; destroy value TOS 
341b			 
341b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
341b cd 97 1a			call macro_forth_dsp_pop 
341e				endm 
# End of macro FORTH_DSP_POP
341e			 
341e					; get u1 
341e			 
341e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
341e cd fb 19			call macro_dsp_valuehl 
3421				endm 
# End of macro FORTH_DSP_VALUEHL
3421			 
3421 e5					push hl  ; u1 
3422			 
3422					; destroy value TOS 
3422			 
3422					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3422 cd 97 1a			call macro_forth_dsp_pop 
3425				endm 
# End of macro FORTH_DSP_POP
3425			 
3425 b7			 or a      ;clear carry flag 
3426 e1			  pop hl    ; u1 
3427 d1			  pop de    ; u2 
3428 e5				push hl   ; saved in case hl is lowest 
3429 ed 52		  sbc hl,de 
342b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
342d			 
342d e1				pop hl 
342e					if DEBUG_FORTH_WORDS 
342e						DMARK "MIN" 
342e f5				push af  
342f 3a 43 34			ld a, (.dmark)  
3432 32 bd fb			ld (debug_mark),a  
3435 3a 44 34			ld a, (.dmark+1)  
3438 32 be fb			ld (debug_mark+1),a  
343b 3a 45 34			ld a, (.dmark+2)  
343e 32 bf fb			ld (debug_mark+2),a  
3441 18 03			jr .pastdmark  
3443 ..			.dmark: db "MIN"  
3446 f1			.pastdmark: pop af  
3447			endm  
# End of macro DMARK
3447						CALLMONITOR 
3447 cd d3 13			call break_point_state  
344a				endm  
# End of macro CALLMONITOR
344a					endif 
344a cd 60 19				call forth_push_numhl 
344d			 
344d				       NEXTW 
344d c3 51 1b			jp macro_next 
3450				endm 
# End of macro NEXTW
3450			 
3450			.mincont:  
3450 c1				pop bc   ; tidy up 
3451 eb				ex de , hl  
3452					if DEBUG_FORTH_WORDS 
3452						DMARK "MI1" 
3452 f5				push af  
3453 3a 67 34			ld a, (.dmark)  
3456 32 bd fb			ld (debug_mark),a  
3459 3a 68 34			ld a, (.dmark+1)  
345c 32 be fb			ld (debug_mark+1),a  
345f 3a 69 34			ld a, (.dmark+2)  
3462 32 bf fb			ld (debug_mark+2),a  
3465 18 03			jr .pastdmark  
3467 ..			.dmark: db "MI1"  
346a f1			.pastdmark: pop af  
346b			endm  
# End of macro DMARK
346b						CALLMONITOR 
346b cd d3 13			call break_point_state  
346e				endm  
# End of macro CALLMONITOR
346e					endif 
346e cd 60 19				call forth_push_numhl 
3471			 
3471				       NEXTW 
3471 c3 51 1b			jp macro_next 
3474				endm 
# End of macro NEXTW
3474			.MAX: 
3474				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3474 4a				db WORD_SYS_CORE+54             
3475 f5 34			dw .RND16            
3477 04				db 3 + 1 
3478 .. 00			db "MAX",0              
347c				endm 
# End of macro CWHEAD
347c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
347c					if DEBUG_FORTH_WORDS_KEY 
347c						DMARK "MAX" 
347c f5				push af  
347d 3a 91 34			ld a, (.dmark)  
3480 32 bd fb			ld (debug_mark),a  
3483 3a 92 34			ld a, (.dmark+1)  
3486 32 be fb			ld (debug_mark+1),a  
3489 3a 93 34			ld a, (.dmark+2)  
348c 32 bf fb			ld (debug_mark+2),a  
348f 18 03			jr .pastdmark  
3491 ..			.dmark: db "MAX"  
3494 f1			.pastdmark: pop af  
3495			endm  
# End of macro DMARK
3495						CALLMONITOR 
3495 cd d3 13			call break_point_state  
3498				endm  
# End of macro CALLMONITOR
3498					endif 
3498					; get u2 
3498			 
3498					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3498 cd fb 19			call macro_dsp_valuehl 
349b				endm 
# End of macro FORTH_DSP_VALUEHL
349b			 
349b e5					push hl   ; u2 
349c			 
349c					; destroy value TOS 
349c			 
349c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
349c cd 97 1a			call macro_forth_dsp_pop 
349f				endm 
# End of macro FORTH_DSP_POP
349f			 
349f					; get u1 
349f			 
349f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
349f cd fb 19			call macro_dsp_valuehl 
34a2				endm 
# End of macro FORTH_DSP_VALUEHL
34a2			 
34a2 e5					push hl  ; u1 
34a3			 
34a3					; destroy value TOS 
34a3			 
34a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34a3 cd 97 1a			call macro_forth_dsp_pop 
34a6				endm 
# End of macro FORTH_DSP_POP
34a6			 
34a6 b7			 or a      ;clear carry flag 
34a7 e1			  pop hl    ; u1 
34a8 d1			  pop de    ; u2 
34a9 e5				push hl   ; saved in case hl is lowest 
34aa ed 52		  sbc hl,de 
34ac 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
34ae			 
34ae e1				pop hl 
34af					if DEBUG_FORTH_WORDS 
34af						DMARK "MAX" 
34af f5				push af  
34b0 3a c4 34			ld a, (.dmark)  
34b3 32 bd fb			ld (debug_mark),a  
34b6 3a c5 34			ld a, (.dmark+1)  
34b9 32 be fb			ld (debug_mark+1),a  
34bc 3a c6 34			ld a, (.dmark+2)  
34bf 32 bf fb			ld (debug_mark+2),a  
34c2 18 03			jr .pastdmark  
34c4 ..			.dmark: db "MAX"  
34c7 f1			.pastdmark: pop af  
34c8			endm  
# End of macro DMARK
34c8						CALLMONITOR 
34c8 cd d3 13			call break_point_state  
34cb				endm  
# End of macro CALLMONITOR
34cb					endif 
34cb cd 60 19				call forth_push_numhl 
34ce			 
34ce				       NEXTW 
34ce c3 51 1b			jp macro_next 
34d1				endm 
# End of macro NEXTW
34d1			 
34d1			.maxcont:  
34d1 c1				pop bc   ; tidy up 
34d2 eb				ex de , hl  
34d3					if DEBUG_FORTH_WORDS 
34d3						DMARK "MA1" 
34d3 f5				push af  
34d4 3a e8 34			ld a, (.dmark)  
34d7 32 bd fb			ld (debug_mark),a  
34da 3a e9 34			ld a, (.dmark+1)  
34dd 32 be fb			ld (debug_mark+1),a  
34e0 3a ea 34			ld a, (.dmark+2)  
34e3 32 bf fb			ld (debug_mark+2),a  
34e6 18 03			jr .pastdmark  
34e8 ..			.dmark: db "MA1"  
34eb f1			.pastdmark: pop af  
34ec			endm  
# End of macro DMARK
34ec						CALLMONITOR 
34ec cd d3 13			call break_point_state  
34ef				endm  
# End of macro CALLMONITOR
34ef					endif 
34ef cd 60 19				call forth_push_numhl 
34f2				       NEXTW 
34f2 c3 51 1b			jp macro_next 
34f5				endm 
# End of macro NEXTW
34f5			 
34f5			.RND16: 
34f5				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
34f5 4e				db WORD_SYS_CORE+58             
34f6 24 35			dw .RND8            
34f8 06				db 5 + 1 
34f9 .. 00			db "RND16",0              
34ff				endm 
# End of macro CWHEAD
34ff			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
34ff					if DEBUG_FORTH_WORDS_KEY 
34ff						DMARK "R16" 
34ff f5				push af  
3500 3a 14 35			ld a, (.dmark)  
3503 32 bd fb			ld (debug_mark),a  
3506 3a 15 35			ld a, (.dmark+1)  
3509 32 be fb			ld (debug_mark+1),a  
350c 3a 16 35			ld a, (.dmark+2)  
350f 32 bf fb			ld (debug_mark+2),a  
3512 18 03			jr .pastdmark  
3514 ..			.dmark: db "R16"  
3517 f1			.pastdmark: pop af  
3518			endm  
# End of macro DMARK
3518						CALLMONITOR 
3518 cd d3 13			call break_point_state  
351b				endm  
# End of macro CALLMONITOR
351b					endif 
351b cd 36 0b				call prng16  
351e cd 60 19				call forth_push_numhl 
3521				       NEXTW 
3521 c3 51 1b			jp macro_next 
3524				endm 
# End of macro NEXTW
3524			.RND8: 
3524				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3524 60				db WORD_SYS_CORE+76             
3525 59 35			dw .RND            
3527 05				db 4 + 1 
3528 .. 00			db "RND8",0              
352d				endm 
# End of macro CWHEAD
352d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
352d					if DEBUG_FORTH_WORDS_KEY 
352d						DMARK "RN8" 
352d f5				push af  
352e 3a 42 35			ld a, (.dmark)  
3531 32 bd fb			ld (debug_mark),a  
3534 3a 43 35			ld a, (.dmark+1)  
3537 32 be fb			ld (debug_mark+1),a  
353a 3a 44 35			ld a, (.dmark+2)  
353d 32 bf fb			ld (debug_mark+2),a  
3540 18 03			jr .pastdmark  
3542 ..			.dmark: db "RN8"  
3545 f1			.pastdmark: pop af  
3546			endm  
# End of macro DMARK
3546						CALLMONITOR 
3546 cd d3 13			call break_point_state  
3549				endm  
# End of macro CALLMONITOR
3549					endif 
3549 2a 3e fa				ld hl,(xrandc) 
354c 23					inc hl 
354d cd 50 0b				call xrnd 
3550 6f					ld l,a	 
3551 26 00				ld h,0 
3553 cd 60 19				call forth_push_numhl 
3556				       NEXTW 
3556 c3 51 1b			jp macro_next 
3559				endm 
# End of macro NEXTW
3559			.RND: 
3559				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3559 60				db WORD_SYS_CORE+76             
355a 5f 36			dw .ENDMATHS            
355c 04				db 3 + 1 
355d .. 00			db "RND",0              
3561				endm 
# End of macro CWHEAD
3561			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3561			 
3561					if DEBUG_FORTH_WORDS_KEY 
3561						DMARK "RND" 
3561 f5				push af  
3562 3a 76 35			ld a, (.dmark)  
3565 32 bd fb			ld (debug_mark),a  
3568 3a 77 35			ld a, (.dmark+1)  
356b 32 be fb			ld (debug_mark+1),a  
356e 3a 78 35			ld a, (.dmark+2)  
3571 32 bf fb			ld (debug_mark+2),a  
3574 18 03			jr .pastdmark  
3576 ..			.dmark: db "RND"  
3579 f1			.pastdmark: pop af  
357a			endm  
# End of macro DMARK
357a						CALLMONITOR 
357a cd d3 13			call break_point_state  
357d				endm  
# End of macro CALLMONITOR
357d					endif 
357d					 
357d					FORTH_DSP_VALUEHL    ; upper range 
357d cd fb 19			call macro_dsp_valuehl 
3580				endm 
# End of macro FORTH_DSP_VALUEHL
3580			 
3580 22 42 fa				ld (LFSRSeed), hl	 
3583			 
3583					if DEBUG_FORTH_WORDS 
3583						DMARK "RN1" 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 bd fb			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 be fb			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 bf fb			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "RN1"  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c						CALLMONITOR 
359c cd d3 13			call break_point_state  
359f				endm  
# End of macro CALLMONITOR
359f					endif 
359f					FORTH_DSP_POP 
359f cd 97 1a			call macro_forth_dsp_pop 
35a2				endm 
# End of macro FORTH_DSP_POP
35a2			 
35a2					FORTH_DSP_VALUEHL    ; low range 
35a2 cd fb 19			call macro_dsp_valuehl 
35a5				endm 
# End of macro FORTH_DSP_VALUEHL
35a5			 
35a5					if DEBUG_FORTH_WORDS 
35a5						DMARK "RN2" 
35a5 f5				push af  
35a6 3a ba 35			ld a, (.dmark)  
35a9 32 bd fb			ld (debug_mark),a  
35ac 3a bb 35			ld a, (.dmark+1)  
35af 32 be fb			ld (debug_mark+1),a  
35b2 3a bc 35			ld a, (.dmark+2)  
35b5 32 bf fb			ld (debug_mark+2),a  
35b8 18 03			jr .pastdmark  
35ba ..			.dmark: db "RN2"  
35bd f1			.pastdmark: pop af  
35be			endm  
# End of macro DMARK
35be						CALLMONITOR 
35be cd d3 13			call break_point_state  
35c1				endm  
# End of macro CALLMONITOR
35c1					endif 
35c1 22 44 fa				ld (LFSRSeed+2), hl 
35c4			 
35c4					FORTH_DSP_POP 
35c4 cd 97 1a			call macro_forth_dsp_pop 
35c7				endm 
# End of macro FORTH_DSP_POP
35c7			 
35c7 e5					push hl 
35c8			 
35c8 e1			.inrange:	pop hl 
35c9 cd 36 0b				call prng16  
35cc					if DEBUG_FORTH_WORDS 
35cc						DMARK "RN3" 
35cc f5				push af  
35cd 3a e1 35			ld a, (.dmark)  
35d0 32 bd fb			ld (debug_mark),a  
35d3 3a e2 35			ld a, (.dmark+1)  
35d6 32 be fb			ld (debug_mark+1),a  
35d9 3a e3 35			ld a, (.dmark+2)  
35dc 32 bf fb			ld (debug_mark+2),a  
35df 18 03			jr .pastdmark  
35e1 ..			.dmark: db "RN3"  
35e4 f1			.pastdmark: pop af  
35e5			endm  
# End of macro DMARK
35e5						CALLMONITOR 
35e5 cd d3 13			call break_point_state  
35e8				endm  
# End of macro CALLMONITOR
35e8					endif 
35e8					 
35e8					; if the range is 8bit knock out the high byte 
35e8			 
35e8 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
35ec			 
35ec 3e 00				ld a, 0 
35ee ba					cp d  
35ef 20 1e				jr nz, .hirange 
35f1 26 00				ld h, 0   ; knock it down to 8bit 
35f3			 
35f3					if DEBUG_FORTH_WORDS 
35f3						DMARK "RNk" 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 bd fb			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 be fb			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 bf fb			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "RNk"  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c						CALLMONITOR 
360c cd d3 13			call break_point_state  
360f				endm  
# End of macro CALLMONITOR
360f					endif 
360f			.hirange:   
360f e5					push hl  
3610 b7					or a  
3611 ed 52		                sbc hl, de 
3613			 
3613					;call cmp16 
3613			 
3613 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3615 e1					pop hl 
3616 e5					push hl 
3617			 
3617					if DEBUG_FORTH_WORDS 
3617						DMARK "RN4" 
3617 f5				push af  
3618 3a 2c 36			ld a, (.dmark)  
361b 32 bd fb			ld (debug_mark),a  
361e 3a 2d 36			ld a, (.dmark+1)  
3621 32 be fb			ld (debug_mark+1),a  
3624 3a 2e 36			ld a, (.dmark+2)  
3627 32 bf fb			ld (debug_mark+2),a  
362a 18 03			jr .pastdmark  
362c ..			.dmark: db "RN4"  
362f f1			.pastdmark: pop af  
3630			endm  
# End of macro DMARK
3630						CALLMONITOR 
3630 cd d3 13			call break_point_state  
3633				endm  
# End of macro CALLMONITOR
3633					endif 
3633 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3637					;call cmp16 
3637				 
3637 b7					or a  
3638 ed 52		                sbc hl, de 
363a 38 8c				jr c, .inrange 
363c			 
363c e1					pop hl 
363d					 
363d					if DEBUG_FORTH_WORDS 
363d						DMARK "RNd" 
363d f5				push af  
363e 3a 52 36			ld a, (.dmark)  
3641 32 bd fb			ld (debug_mark),a  
3644 3a 53 36			ld a, (.dmark+1)  
3647 32 be fb			ld (debug_mark+1),a  
364a 3a 54 36			ld a, (.dmark+2)  
364d 32 bf fb			ld (debug_mark+2),a  
3650 18 03			jr .pastdmark  
3652 ..			.dmark: db "RNd"  
3655 f1			.pastdmark: pop af  
3656			endm  
# End of macro DMARK
3656						CALLMONITOR 
3656 cd d3 13			call break_point_state  
3659				endm  
# End of macro CALLMONITOR
3659					endif 
3659			 
3659			 
3659 cd 60 19				call forth_push_numhl 
365c				       NEXTW 
365c c3 51 1b			jp macro_next 
365f				endm 
# End of macro NEXTW
365f			 
365f			.ENDMATHS: 
365f			 
365f			; eof 
365f			 
# End of file forth_words_maths.asm
365f			include "forth_words_display.asm" 
365f			 
365f			; | ## Display Words 
365f			 
365f			.ATP: 
365f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
365f 62				db WORD_SYS_CORE+78             
3660 d6 36			dw .FB            
3662 04				db 3 + 1 
3663 .. 00			db "AT?",0              
3667				endm 
# End of macro CWHEAD
3667			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3667					if DEBUG_FORTH_WORDS_KEY 
3667						DMARK "AT?" 
3667 f5				push af  
3668 3a 7c 36			ld a, (.dmark)  
366b 32 bd fb			ld (debug_mark),a  
366e 3a 7d 36			ld a, (.dmark+1)  
3671 32 be fb			ld (debug_mark+1),a  
3674 3a 7e 36			ld a, (.dmark+2)  
3677 32 bf fb			ld (debug_mark+2),a  
367a 18 03			jr .pastdmark  
367c ..			.dmark: db "AT?"  
367f f1			.pastdmark: pop af  
3680			endm  
# End of macro DMARK
3680						CALLMONITOR 
3680 cd d3 13			call break_point_state  
3683				endm  
# End of macro CALLMONITOR
3683					endif 
3683 3a e1 f9				ld a, (f_cursor_ptr) 
3686			 
3686			if DEBUG_FORTH_WORDS 
3686				DMARK "AT?" 
3686 f5				push af  
3687 3a 9b 36			ld a, (.dmark)  
368a 32 bd fb			ld (debug_mark),a  
368d 3a 9c 36			ld a, (.dmark+1)  
3690 32 be fb			ld (debug_mark+1),a  
3693 3a 9d 36			ld a, (.dmark+2)  
3696 32 bf fb			ld (debug_mark+2),a  
3699 18 03			jr .pastdmark  
369b ..			.dmark: db "AT?"  
369e f1			.pastdmark: pop af  
369f			endm  
# End of macro DMARK
369f				CALLMONITOR 
369f cd d3 13			call break_point_state  
36a2				endm  
# End of macro CALLMONITOR
36a2			endif	 
36a2					; count the number of rows 
36a2			 
36a2 06 00				ld b, 0 
36a4 4f			.atpr:		ld c, a    ; save in case we go below zero 
36a5 d6 14				sub display_cols 
36a7 f2 ad 36				jp p, .atprunder 
36aa 04					inc b 
36ab 18 f7				jr .atpr 
36ad			.atprunder:	 
36ad			if DEBUG_FORTH_WORDS 
36ad				DMARK "A?2" 
36ad f5				push af  
36ae 3a c2 36			ld a, (.dmark)  
36b1 32 bd fb			ld (debug_mark),a  
36b4 3a c3 36			ld a, (.dmark+1)  
36b7 32 be fb			ld (debug_mark+1),a  
36ba 3a c4 36			ld a, (.dmark+2)  
36bd 32 bf fb			ld (debug_mark+2),a  
36c0 18 03			jr .pastdmark  
36c2 ..			.dmark: db "A?2"  
36c5 f1			.pastdmark: pop af  
36c6			endm  
# End of macro DMARK
36c6				CALLMONITOR 
36c6 cd d3 13			call break_point_state  
36c9				endm  
# End of macro CALLMONITOR
36c9			endif	 
36c9 26 00				ld h, 0 
36cb 69					ld l, c 
36cc cd 60 19				call forth_push_numhl 
36cf 68					ld l, b  
36d0 cd 60 19				call forth_push_numhl 
36d3			 
36d3			 
36d3				NEXTW 
36d3 c3 51 1b			jp macro_next 
36d6				endm 
# End of macro NEXTW
36d6			 
36d6			.FB: 
36d6				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
36d6 1b				db WORD_SYS_CORE+7             
36d7 24 37			dw .EMIT            
36d9 03				db 2 + 1 
36da .. 00			db "FB",0              
36dd				endm 
# End of macro CWHEAD
36dd			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
36dd			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
36dd			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
36dd			; | | If automatic display is off then updates will not be shown until DRAW is used. 
36dd					if DEBUG_FORTH_WORDS_KEY 
36dd						DMARK "FB." 
36dd f5				push af  
36de 3a f2 36			ld a, (.dmark)  
36e1 32 bd fb			ld (debug_mark),a  
36e4 3a f3 36			ld a, (.dmark+1)  
36e7 32 be fb			ld (debug_mark+1),a  
36ea 3a f4 36			ld a, (.dmark+2)  
36ed 32 bf fb			ld (debug_mark+2),a  
36f0 18 03			jr .pastdmark  
36f2 ..			.dmark: db "FB."  
36f5 f1			.pastdmark: pop af  
36f6			endm  
# End of macro DMARK
36f6						CALLMONITOR 
36f6 cd d3 13			call break_point_state  
36f9				endm  
# End of macro CALLMONITOR
36f9					endif 
36f9			 
36f9					FORTH_DSP_VALUEHL 
36f9 cd fb 19			call macro_dsp_valuehl 
36fc				endm 
# End of macro FORTH_DSP_VALUEHL
36fc			 
36fc 7d					ld a, l 
36fd fe 01				cp 1 
36ff 20 05				jr nz, .fbn1 
3701 21 02 fb				ld hl, display_fb1 
3704 18 15				jr .fbset 
3706 fe 02		.fbn1:		cp 2 
3708 20 05				jr nz, .fbn2 
370a 21 60 fa				ld hl, display_fb2 
370d 18 0c				jr .fbset 
370f fe 03		.fbn2:		cp 3 
3711 20 05				jr nz, .fbn3 
3713 21 b1 fa				ld hl, display_fb3 
3716 18 03				jr .fbset 
3718			.fbn3:		 ; if invalid number select first 
3718 21 02 fb				ld hl, display_fb1 
371b 22 5e fa		.fbset:		ld (display_fb_active), hl 
371e			 
371e					FORTH_DSP_POP 
371e cd 97 1a			call macro_forth_dsp_pop 
3721				endm 
# End of macro FORTH_DSP_POP
3721			 
3721					NEXTW 
3721 c3 51 1b			jp macro_next 
3724				endm 
# End of macro NEXTW
3724			 
3724			 
3724			.EMIT: 
3724				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3724 1b				db WORD_SYS_CORE+7             
3725 75 37			dw .DOTH            
3727 05				db 4 + 1 
3728 .. 00			db "EMIT",0              
372d				endm 
# End of macro CWHEAD
372d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
372d					; get value off TOS and display it 
372d			 
372d					if DEBUG_FORTH_WORDS_KEY 
372d						DMARK "EMT" 
372d f5				push af  
372e 3a 42 37			ld a, (.dmark)  
3731 32 bd fb			ld (debug_mark),a  
3734 3a 43 37			ld a, (.dmark+1)  
3737 32 be fb			ld (debug_mark+1),a  
373a 3a 44 37			ld a, (.dmark+2)  
373d 32 bf fb			ld (debug_mark+2),a  
3740 18 03			jr .pastdmark  
3742 ..			.dmark: db "EMT"  
3745 f1			.pastdmark: pop af  
3746			endm  
# End of macro DMARK
3746						CALLMONITOR 
3746 cd d3 13			call break_point_state  
3749				endm  
# End of macro CALLMONITOR
3749					endif 
3749			 
3749					FORTH_DSP_VALUEHL 
3749 cd fb 19			call macro_dsp_valuehl 
374c				endm 
# End of macro FORTH_DSP_VALUEHL
374c			 
374c 7d					ld a,l 
374d			 
374d					; TODO write to display 
374d			 
374d 32 b6 f1				ld (os_input), a 
3750 3e 00				ld a, 0 
3752 32 b7 f1				ld (os_input+1), a 
3755					 
3755 3a e1 f9				ld a, (f_cursor_ptr) 
3758 11 b6 f1				ld de, os_input 
375b cd c9 0a				call str_at_display 
375e			 
375e			 
375e 3a bf f9				ld a,(cli_autodisplay) 
3761 fe 00				cp 0 
3763 28 03				jr z, .enoupdate 
3765 cd d9 0a						call update_display 
3768					.enoupdate: 
3768			 
3768 3a e1 f9				ld a, (f_cursor_ptr) 
376b 3c					inc a 
376c 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
376f			 
376f			 
376f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376f cd 97 1a			call macro_forth_dsp_pop 
3772				endm 
# End of macro FORTH_DSP_POP
3772			  
3772			 
3772					NEXTW 
3772 c3 51 1b			jp macro_next 
3775				endm 
# End of macro NEXTW
3775			.DOTH: 
3775				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3775 1c				db WORD_SYS_CORE+8             
3776 a5 37			dw .DOTF            
3778 03				db 2 + 1 
3779 .. 00			db ".-",0              
377c				endm 
# End of macro CWHEAD
377c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
377c					; get value off TOS and display it 
377c					if DEBUG_FORTH_WORDS_KEY 
377c						DMARK "DTD" 
377c f5				push af  
377d 3a 91 37			ld a, (.dmark)  
3780 32 bd fb			ld (debug_mark),a  
3783 3a 92 37			ld a, (.dmark+1)  
3786 32 be fb			ld (debug_mark+1),a  
3789 3a 93 37			ld a, (.dmark+2)  
378c 32 bf fb			ld (debug_mark+2),a  
378f 18 03			jr .pastdmark  
3791 ..			.dmark: db "DTD"  
3794 f1			.pastdmark: pop af  
3795			endm  
# End of macro DMARK
3795						CALLMONITOR 
3795 cd d3 13			call break_point_state  
3798				endm  
# End of macro CALLMONITOR
3798					endif 
3798 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
379a 3e 00			ld a, 0 
379c 32 c0 f9			ld (cli_mvdot), a 
379f c3 fc 37			jp .dotgo 
37a2				NEXTW 
37a2 c3 51 1b			jp macro_next 
37a5				endm 
# End of macro NEXTW
37a5			.DOTF: 
37a5				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
37a5 1c				db WORD_SYS_CORE+8             
37a6 d3 37			dw .DOT            
37a8 03				db 2 + 1 
37a9 .. 00			db ".>",0              
37ac				endm 
# End of macro CWHEAD
37ac			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
37ac					; get value off TOS and display it 
37ac			        ; TODO BUG adds extra spaces 
37ac			        ; TODO BUG handle numerics? 
37ac					if DEBUG_FORTH_WORDS_KEY 
37ac						DMARK "DTC" 
37ac f5				push af  
37ad 3a c1 37			ld a, (.dmark)  
37b0 32 bd fb			ld (debug_mark),a  
37b3 3a c2 37			ld a, (.dmark+1)  
37b6 32 be fb			ld (debug_mark+1),a  
37b9 3a c3 37			ld a, (.dmark+2)  
37bc 32 bf fb			ld (debug_mark+2),a  
37bf 18 03			jr .pastdmark  
37c1 ..			.dmark: db "DTC"  
37c4 f1			.pastdmark: pop af  
37c5			endm  
# End of macro DMARK
37c5						CALLMONITOR 
37c5 cd d3 13			call break_point_state  
37c8				endm  
# End of macro CALLMONITOR
37c8					endif 
37c8 3e 01			ld a, 1 
37ca 32 c0 f9			ld (cli_mvdot), a 
37cd c3 fc 37			jp .dotgo 
37d0				NEXTW 
37d0 c3 51 1b			jp macro_next 
37d3				endm 
# End of macro NEXTW
37d3			 
37d3			.DOT: 
37d3				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
37d3 1c				db WORD_SYS_CORE+8             
37d4 5f 38			dw .CLS            
37d6 02				db 1 + 1 
37d7 .. 00			db ".",0              
37d9				endm 
# End of macro CWHEAD
37d9			        ; | . ( u -- ) Display TOS | DONE 
37d9					; get value off TOS and display it 
37d9			 
37d9					if DEBUG_FORTH_WORDS_KEY 
37d9						DMARK "DOT" 
37d9 f5				push af  
37da 3a ee 37			ld a, (.dmark)  
37dd 32 bd fb			ld (debug_mark),a  
37e0 3a ef 37			ld a, (.dmark+1)  
37e3 32 be fb			ld (debug_mark+1),a  
37e6 3a f0 37			ld a, (.dmark+2)  
37e9 32 bf fb			ld (debug_mark+2),a  
37ec 18 03			jr .pastdmark  
37ee ..			.dmark: db "DOT"  
37f1 f1			.pastdmark: pop af  
37f2			endm  
# End of macro DMARK
37f2						CALLMONITOR 
37f2 cd d3 13			call break_point_state  
37f5				endm  
# End of macro CALLMONITOR
37f5					endif 
37f5 3e 00			ld a, 0 
37f7 32 c0 f9			ld (cli_mvdot), a 
37fa 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
37fc				 
37fc			 
37fc			.dotgo: 
37fc			 
37fc			; move up type to on stack for parserv5 
37fc					FORTH_DSP 
37fc cd e0 19			call macro_forth_dsp 
37ff				endm 
# End of macro FORTH_DSP
37ff				;FORTH_DSP_VALUE  
37ff			 
37ff			if DEBUG_FORTH_DOT 
37ff				DMARK "DOT" 
37ff				CALLMONITOR 
37ff			endif	 
37ff			;		.print: 
37ff			 
37ff 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3800 23				inc hl   ; position to the actual value 
3801 fe 01			cp DS_TYPE_STR 
3803 20 06			jr nz, .dotnum1  
3805			 
3805			; display string 
3805				FORTH_DSP_VALUE  
3805 cd e4 19			call macro_forth_dsp_value 
3808				endm 
# End of macro FORTH_DSP_VALUE
3808 eb				ex de,hl 
3809 18 11			jr .dotwrite 
380b			 
380b			.dotnum1: 
380b fe 02			cp DS_TYPE_INUM 
380d 20 0c			jr nz, .dotflot 
380f			 
380f			 
380f			; display number 
380f			 
380f			;	push hl 
380f			;	call clear_display 
380f			;	pop hl 
380f			 
380f 5e				ld e, (hl) 
3810 23				inc hl 
3811 56				ld d, (hl) 
3812 21 b8 ef			ld hl, scratch 
3815			if DEBUG_FORTH_DOT 
3815				DMARK "DT1" 
3815				CALLMONITOR 
3815			endif	 
3815			 
3815 cd 1c 10			call uitoa_16 
3818 eb				ex de,hl 
3819			 
3819			if DEBUG_FORTH_DOT 
3819				DMARK "DT2" 
3819				CALLMONITOR 
3819			endif	 
3819			 
3819			;	ld de, os_word_scratch 
3819 18 01			jr .dotwrite 
381b			 
381b 00			.dotflot:   nop 
381c			; TODO print floating point number 
381c			 
381c			.dotwrite:		 
381c			 
381c					; if c is set then set all '-' to spaces 
381c					; need to also take into account .>  
381c			 
381c 3e 01				ld a, 1 
381e b9					cp c 
381f 20 13				jr nz, .nodashswap 
3821			 
3821					; DE has the string to write, working with HL 
3821			 
3821 06 ff				ld b, 255 
3823 d5					push de 
3824 e1					pop hl 
3825			 
3825			if DEBUG_FORTH_DOT 
3825				DMARK "DT-" 
3825				CALLMONITOR 
3825			endif	 
3825 7e			.dashscan:	ld a, (hl) 
3826 fe 00				cp 0 
3828 28 0a				jr z, .nodashswap 
382a fe 2d				cp '-' 
382c 20 03				jr nz, .dashskip 
382e 3e 20				ld a, ' ' 
3830 77					ld (hl), a 
3831 23			.dashskip:	inc hl 
3832			if DEBUG_FORTH_DOT 
3832				DMARK "D-2" 
3832				CALLMONITOR 
3832			endif	 
3832 10 f1				djnz .dashscan 
3834			 
3834			if DEBUG_FORTH_DOT 
3834				DMARK "D-1" 
3834				CALLMONITOR 
3834			endif	 
3834			 
3834			.nodashswap: 
3834			 
3834 e5					push hl   ; save string start in case we need to advance print 
3835			 
3835 3a e1 f9				ld a, (f_cursor_ptr) 
3838 cd c9 0a				call str_at_display 
383b 3a bf f9				ld a,(cli_autodisplay) 
383e fe 00				cp 0 
3840 28 03				jr z, .noupdate 
3842 cd d9 0a						call update_display 
3845					.noupdate: 
3845			 
3845			 
3845					; see if we need to advance the print position 
3845			 
3845 e1					pop hl   ; get back string 
3846			 
3846 3a c0 f9				ld a, (cli_mvdot) 
3849			if DEBUG_FORTH_DOT 
3849					ld e,a 
3849				DMARK "D>1" 
3849				CALLMONITOR 
3849			endif	 
3849 fe 00				cp 0 
384b 28 0c				jr z, .noadv 
384d					; yes, lets advance the print position 
384d 3e 00				ld a, 0 
384f cd 78 10				call strlent 
3852 3a e1 f9				ld a, (f_cursor_ptr) 
3855 85					add a,l 
3856					;call addatohl 
3856					;ld a, l 
3856 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
3859			 
3859			if DEBUG_FORTH_DOT 
3859				DMARK "D->" 
3859				CALLMONITOR 
3859			endif	 
3859			 
3859			.noadv:	 
3859			 
3859					if DEBUG_FORTH_DOT_WAIT 
3859							call next_page_prompt 
3859					endif	 
3859			; TODO this pop off the stack causes a crash. i dont know why 
3859			 
3859			 
3859			if DEBUG_FORTH_DOT 
3859				DMARK "DTh" 
3859				CALLMONITOR 
3859			endif	 
3859			 
3859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3859 cd 97 1a			call macro_forth_dsp_pop 
385c				endm 
# End of macro FORTH_DSP_POP
385c			 
385c			if DEBUG_FORTH_DOT 
385c				DMARK "DTi" 
385c				CALLMONITOR 
385c			endif	 
385c			 
385c			 
385c					NEXTW 
385c c3 51 1b			jp macro_next 
385f				endm 
# End of macro NEXTW
385f			 
385f			.CLS: 
385f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
385f 35				db WORD_SYS_CORE+33             
3860 8c 38			dw .DRAW            
3862 04				db 3 + 1 
3863 .. 00			db "CLS",0              
3867				endm 
# End of macro CWHEAD
3867			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3867					if DEBUG_FORTH_WORDS_KEY 
3867						DMARK "CLS" 
3867 f5				push af  
3868 3a 7c 38			ld a, (.dmark)  
386b 32 bd fb			ld (debug_mark),a  
386e 3a 7d 38			ld a, (.dmark+1)  
3871 32 be fb			ld (debug_mark+1),a  
3874 3a 7e 38			ld a, (.dmark+2)  
3877 32 bf fb			ld (debug_mark+2),a  
387a 18 03			jr .pastdmark  
387c ..			.dmark: db "CLS"  
387f f1			.pastdmark: pop af  
3880			endm  
# End of macro DMARK
3880						CALLMONITOR 
3880 cd d3 13			call break_point_state  
3883				endm  
# End of macro CALLMONITOR
3883					endif 
3883 cd b6 0a				call clear_display 
3886 c3 9a 39				jp .home		; and home cursor 
3889					NEXTW 
3889 c3 51 1b			jp macro_next 
388c				endm 
# End of macro NEXTW
388c			 
388c			.DRAW: 
388c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
388c 36				db WORD_SYS_CORE+34             
388d b7 38			dw .DUMP            
388f 05				db 4 + 1 
3890 .. 00			db "DRAW",0              
3895				endm 
# End of macro CWHEAD
3895			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3895					if DEBUG_FORTH_WORDS_KEY 
3895						DMARK "DRW" 
3895 f5				push af  
3896 3a aa 38			ld a, (.dmark)  
3899 32 bd fb			ld (debug_mark),a  
389c 3a ab 38			ld a, (.dmark+1)  
389f 32 be fb			ld (debug_mark+1),a  
38a2 3a ac 38			ld a, (.dmark+2)  
38a5 32 bf fb			ld (debug_mark+2),a  
38a8 18 03			jr .pastdmark  
38aa ..			.dmark: db "DRW"  
38ad f1			.pastdmark: pop af  
38ae			endm  
# End of macro DMARK
38ae						CALLMONITOR 
38ae cd d3 13			call break_point_state  
38b1				endm  
# End of macro CALLMONITOR
38b1					endif 
38b1 cd d9 0a				call update_display 
38b4					NEXTW 
38b4 c3 51 1b			jp macro_next 
38b7				endm 
# End of macro NEXTW
38b7			 
38b7			.DUMP: 
38b7				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
38b7 37				db WORD_SYS_CORE+35             
38b8 ef 38			dw .CDUMP            
38ba 05				db 4 + 1 
38bb .. 00			db "DUMP",0              
38c0				endm 
# End of macro CWHEAD
38c0			; | DUMP ( x -- ) With address x display dump   | DONE 
38c0			; TODO pop address to use off of the stack 
38c0					if DEBUG_FORTH_WORDS_KEY 
38c0						DMARK "DUM" 
38c0 f5				push af  
38c1 3a d5 38			ld a, (.dmark)  
38c4 32 bd fb			ld (debug_mark),a  
38c7 3a d6 38			ld a, (.dmark+1)  
38ca 32 be fb			ld (debug_mark+1),a  
38cd 3a d7 38			ld a, (.dmark+2)  
38d0 32 bf fb			ld (debug_mark+2),a  
38d3 18 03			jr .pastdmark  
38d5 ..			.dmark: db "DUM"  
38d8 f1			.pastdmark: pop af  
38d9			endm  
# End of macro DMARK
38d9						CALLMONITOR 
38d9 cd d3 13			call break_point_state  
38dc				endm  
# End of macro CALLMONITOR
38dc					endif 
38dc cd b6 0a				call clear_display 
38df			 
38df					; get address 
38df			 
38df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38df cd fb 19			call macro_dsp_valuehl 
38e2				endm 
# End of macro FORTH_DSP_VALUEHL
38e2				 
38e2					; save it for cdump 
38e2			 
38e2 22 db f2				ld (os_cur_ptr),hl 
38e5			 
38e5					; destroy value TOS 
38e5			 
38e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e5 cd 97 1a			call macro_forth_dsp_pop 
38e8				endm 
# End of macro FORTH_DSP_POP
38e8			 
38e8 cd e0 17				call dumpcont	; skip old style of param parsing	 
38eb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
38ec					NEXTW 
38ec c3 51 1b			jp macro_next 
38ef				endm 
# End of macro NEXTW
38ef			.CDUMP: 
38ef				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
38ef 38				db WORD_SYS_CORE+36             
38f0 1f 39			dw .DAT            
38f2 06				db 5 + 1 
38f3 .. 00			db "CDUMP",0              
38f9				endm 
# End of macro CWHEAD
38f9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
38f9					if DEBUG_FORTH_WORDS_KEY 
38f9						DMARK "CDP" 
38f9 f5				push af  
38fa 3a 0e 39			ld a, (.dmark)  
38fd 32 bd fb			ld (debug_mark),a  
3900 3a 0f 39			ld a, (.dmark+1)  
3903 32 be fb			ld (debug_mark+1),a  
3906 3a 10 39			ld a, (.dmark+2)  
3909 32 bf fb			ld (debug_mark+2),a  
390c 18 03			jr .pastdmark  
390e ..			.dmark: db "CDP"  
3911 f1			.pastdmark: pop af  
3912			endm  
# End of macro DMARK
3912						CALLMONITOR 
3912 cd d3 13			call break_point_state  
3915				endm  
# End of macro CALLMONITOR
3915					endif 
3915 cd b6 0a				call clear_display 
3918 cd e0 17				call dumpcont	 
391b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
391c					NEXTW 
391c c3 51 1b			jp macro_next 
391f				endm 
# End of macro NEXTW
391f			 
391f			 
391f			 
391f			 
391f			.DAT: 
391f				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
391f 3d				db WORD_SYS_CORE+41             
3920 75 39			dw .HOME            
3922 03				db 2 + 1 
3923 .. 00			db "AT",0              
3926				endm 
# End of macro CWHEAD
3926			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3926					if DEBUG_FORTH_WORDS_KEY 
3926						DMARK "AT." 
3926 f5				push af  
3927 3a 3b 39			ld a, (.dmark)  
392a 32 bd fb			ld (debug_mark),a  
392d 3a 3c 39			ld a, (.dmark+1)  
3930 32 be fb			ld (debug_mark+1),a  
3933 3a 3d 39			ld a, (.dmark+2)  
3936 32 bf fb			ld (debug_mark+2),a  
3939 18 03			jr .pastdmark  
393b ..			.dmark: db "AT."  
393e f1			.pastdmark: pop af  
393f			endm  
# End of macro DMARK
393f						CALLMONITOR 
393f cd d3 13			call break_point_state  
3942				endm  
# End of macro CALLMONITOR
3942					endif 
3942					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3942 cd fb 19			call macro_dsp_valuehl 
3945				endm 
# End of macro FORTH_DSP_VALUEHL
3945			 
3945			 
3945					; TODO save cursor row 
3945 7d					ld a,l 
3946 fe 02				cp 2 
3948 20 04				jr nz, .crow3 
394a 3e 14				ld a, display_row_2 
394c 18 12				jr .ccol1 
394e fe 03		.crow3:		cp 3 
3950 20 04				jr nz, .crow4 
3952 3e 28				ld a, display_row_3 
3954 18 0a				jr .ccol1 
3956 fe 04		.crow4:		cp 4 
3958 20 04				jr nz, .crow1 
395a 3e 3c				ld a, display_row_4 
395c 18 02				jr .ccol1 
395e 3e 00		.crow1:		ld a,display_row_1 
3960 f5			.ccol1:		push af			; got row offset 
3961 6f					ld l,a 
3962 26 00				ld h,0 
3964					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3964 cd 97 1a			call macro_forth_dsp_pop 
3967				endm 
# End of macro FORTH_DSP_POP
3967					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3967 cd fb 19			call macro_dsp_valuehl 
396a				endm 
# End of macro FORTH_DSP_VALUEHL
396a					; TODO save cursor col 
396a f1					pop af 
396b 85					add l		; add col offset 
396c 32 e1 f9				ld (f_cursor_ptr), a 
396f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396f cd 97 1a			call macro_forth_dsp_pop 
3972				endm 
# End of macro FORTH_DSP_POP
3972			 
3972					; calculate  
3972			 
3972					NEXTW 
3972 c3 51 1b			jp macro_next 
3975				endm 
# End of macro NEXTW
3975			 
3975			 
3975			.HOME: 
3975				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3975 41				db WORD_SYS_CORE+45             
3976 a2 39			dw .SPACE            
3978 05				db 4 + 1 
3979 .. 00			db "HOME",0              
397e				endm 
# End of macro CWHEAD
397e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
397e					if DEBUG_FORTH_WORDS_KEY 
397e						DMARK "HOM" 
397e f5				push af  
397f 3a 93 39			ld a, (.dmark)  
3982 32 bd fb			ld (debug_mark),a  
3985 3a 94 39			ld a, (.dmark+1)  
3988 32 be fb			ld (debug_mark+1),a  
398b 3a 95 39			ld a, (.dmark+2)  
398e 32 bf fb			ld (debug_mark+2),a  
3991 18 03			jr .pastdmark  
3993 ..			.dmark: db "HOM"  
3996 f1			.pastdmark: pop af  
3997			endm  
# End of macro DMARK
3997						CALLMONITOR 
3997 cd d3 13			call break_point_state  
399a				endm  
# End of macro CALLMONITOR
399a					endif 
399a 3e 00		.home:		ld a, 0		; and home cursor 
399c 32 e1 f9				ld (f_cursor_ptr), a 
399f					NEXTW 
399f c3 51 1b			jp macro_next 
39a2				endm 
# End of macro NEXTW
39a2			 
39a2			 
39a2			.SPACE: 
39a2				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
39a2 46				db WORD_SYS_CORE+50             
39a3 d0 39			dw .SPACES            
39a5 03				db 2 + 1 
39a6 .. 00			db "BL",0              
39a9				endm 
# End of macro CWHEAD
39a9			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
39a9					if DEBUG_FORTH_WORDS_KEY 
39a9						DMARK "BL." 
39a9 f5				push af  
39aa 3a be 39			ld a, (.dmark)  
39ad 32 bd fb			ld (debug_mark),a  
39b0 3a bf 39			ld a, (.dmark+1)  
39b3 32 be fb			ld (debug_mark+1),a  
39b6 3a c0 39			ld a, (.dmark+2)  
39b9 32 bf fb			ld (debug_mark+2),a  
39bc 18 03			jr .pastdmark  
39be ..			.dmark: db "BL."  
39c1 f1			.pastdmark: pop af  
39c2			endm  
# End of macro DMARK
39c2						CALLMONITOR 
39c2 cd d3 13			call break_point_state  
39c5				endm  
# End of macro CALLMONITOR
39c5					endif 
39c5 21 ce 39				ld hl, .blstr 
39c8 cd 72 19				call forth_push_str 
39cb					 
39cb				       NEXTW 
39cb c3 51 1b			jp macro_next 
39ce				endm 
# End of macro NEXTW
39ce			 
39ce .. 00		.blstr: db " ", 0 
39d0			 
39d0			.SPACES: 
39d0				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
39d0 47				db WORD_SYS_CORE+51             
39d1 6b 3a			dw .SCROLL            
39d3 07				db 6 + 1 
39d4 .. 00			db "SPACES",0              
39db				endm 
# End of macro CWHEAD
39db			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
39db					if DEBUG_FORTH_WORDS_KEY 
39db						DMARK "SPS" 
39db f5				push af  
39dc 3a f0 39			ld a, (.dmark)  
39df 32 bd fb			ld (debug_mark),a  
39e2 3a f1 39			ld a, (.dmark+1)  
39e5 32 be fb			ld (debug_mark+1),a  
39e8 3a f2 39			ld a, (.dmark+2)  
39eb 32 bf fb			ld (debug_mark+2),a  
39ee 18 03			jr .pastdmark  
39f0 ..			.dmark: db "SPS"  
39f3 f1			.pastdmark: pop af  
39f4			endm  
# End of macro DMARK
39f4						CALLMONITOR 
39f4 cd d3 13			call break_point_state  
39f7				endm  
# End of macro CALLMONITOR
39f7					endif 
39f7			 
39f7			 
39f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f7 cd fb 19			call macro_dsp_valuehl 
39fa				endm 
# End of macro FORTH_DSP_VALUEHL
39fa			 
39fa			;		push hl    ; u 
39fa					if DEBUG_FORTH_WORDS 
39fa						DMARK "SPA" 
39fa f5				push af  
39fb 3a 0f 3a			ld a, (.dmark)  
39fe 32 bd fb			ld (debug_mark),a  
3a01 3a 10 3a			ld a, (.dmark+1)  
3a04 32 be fb			ld (debug_mark+1),a  
3a07 3a 11 3a			ld a, (.dmark+2)  
3a0a 32 bf fb			ld (debug_mark+2),a  
3a0d 18 03			jr .pastdmark  
3a0f ..			.dmark: db "SPA"  
3a12 f1			.pastdmark: pop af  
3a13			endm  
# End of macro DMARK
3a13						CALLMONITOR 
3a13 cd d3 13			call break_point_state  
3a16				endm  
# End of macro CALLMONITOR
3a16					endif 
3a16			 
3a16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a16 cd 97 1a			call macro_forth_dsp_pop 
3a19				endm 
# End of macro FORTH_DSP_POP
3a19			;		pop hl 
3a19 4d					ld c, l 
3a1a 06 00				ld b, 0 
3a1c 21 b8 ef				ld hl, scratch  
3a1f			 
3a1f					if DEBUG_FORTH_WORDS 
3a1f						DMARK "SP2" 
3a1f f5				push af  
3a20 3a 34 3a			ld a, (.dmark)  
3a23 32 bd fb			ld (debug_mark),a  
3a26 3a 35 3a			ld a, (.dmark+1)  
3a29 32 be fb			ld (debug_mark+1),a  
3a2c 3a 36 3a			ld a, (.dmark+2)  
3a2f 32 bf fb			ld (debug_mark+2),a  
3a32 18 03			jr .pastdmark  
3a34 ..			.dmark: db "SP2"  
3a37 f1			.pastdmark: pop af  
3a38			endm  
# End of macro DMARK
3a38						CALLMONITOR 
3a38 cd d3 13			call break_point_state  
3a3b				endm  
# End of macro CALLMONITOR
3a3b					endif 
3a3b 3e 20				ld a, ' ' 
3a3d c5			.spaces1:	push bc 
3a3e 77					ld (hl),a 
3a3f 23					inc hl 
3a40 c1					pop bc 
3a41 10 fa				djnz .spaces1 
3a43 3e 00				ld a,0 
3a45 77					ld (hl),a 
3a46 21 b8 ef				ld hl, scratch 
3a49					if DEBUG_FORTH_WORDS 
3a49						DMARK "SP3" 
3a49 f5				push af  
3a4a 3a 5e 3a			ld a, (.dmark)  
3a4d 32 bd fb			ld (debug_mark),a  
3a50 3a 5f 3a			ld a, (.dmark+1)  
3a53 32 be fb			ld (debug_mark+1),a  
3a56 3a 60 3a			ld a, (.dmark+2)  
3a59 32 bf fb			ld (debug_mark+2),a  
3a5c 18 03			jr .pastdmark  
3a5e ..			.dmark: db "SP3"  
3a61 f1			.pastdmark: pop af  
3a62			endm  
# End of macro DMARK
3a62						CALLMONITOR 
3a62 cd d3 13			call break_point_state  
3a65				endm  
# End of macro CALLMONITOR
3a65					endif 
3a65 cd a8 19				call forth_apush 
3a68			 
3a68				       NEXTW 
3a68 c3 51 1b			jp macro_next 
3a6b				endm 
# End of macro NEXTW
3a6b			 
3a6b			 
3a6b			 
3a6b			.SCROLL: 
3a6b				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
3a6b 53				db WORD_SYS_CORE+63             
3a6c 98 3a			dw .ATQ            
3a6e 07				db 6 + 1 
3a6f .. 00			db "SCROLL",0              
3a76				endm 
# End of macro CWHEAD
3a76			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3a76					if DEBUG_FORTH_WORDS_KEY 
3a76						DMARK "SCR" 
3a76 f5				push af  
3a77 3a 8b 3a			ld a, (.dmark)  
3a7a 32 bd fb			ld (debug_mark),a  
3a7d 3a 8c 3a			ld a, (.dmark+1)  
3a80 32 be fb			ld (debug_mark+1),a  
3a83 3a 8d 3a			ld a, (.dmark+2)  
3a86 32 bf fb			ld (debug_mark+2),a  
3a89 18 03			jr .pastdmark  
3a8b ..			.dmark: db "SCR"  
3a8e f1			.pastdmark: pop af  
3a8f			endm  
# End of macro DMARK
3a8f						CALLMONITOR 
3a8f cd d3 13			call break_point_state  
3a92				endm  
# End of macro CALLMONITOR
3a92					endif 
3a92			 
3a92 cd 4e 0a			call scroll_up 
3a95			;	call update_display 
3a95			 
3a95					NEXTW 
3a95 c3 51 1b			jp macro_next 
3a98				endm 
# End of macro NEXTW
3a98			 
3a98			 
3a98			 
3a98			;		; get dir 
3a98			; 
3a98			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a98			; 
3a98			;		push hl 
3a98			; 
3a98			;		; destroy value TOS 
3a98			; 
3a98			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a98			; 
3a98			;		; get count 
3a98			; 
3a98			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a98			; 
3a98			;		push hl 
3a98			; 
3a98			;		; destroy value TOS 
3a98			; 
3a98			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a98			; 
3a98			;		; one value on hl get other one back 
3a98			; 
3a98			;		pop bc    ; count 
3a98			; 
3a98			;		pop de   ; dir 
3a98			; 
3a98			; 
3a98			;		ld b, c 
3a98			; 
3a98			;.scrolldir:     push bc 
3a98			;		push de 
3a98			; 
3a98			;		ld a, 0 
3a98			;		cp e 
3a98			;		jr z, .scrollup  
3a98			;		call scroll_down 
3a98			;		jr .scrollnext 
3a98			;.scrollup:	call scroll_up 
3a98			; 
3a98			;		 
3a98			;.scrollnext: 
3a98			;		pop de 
3a98			;		pop bc 
3a98			;		djnz .scrolldir 
3a98			; 
3a98			; 
3a98			; 
3a98			; 
3a98			; 
3a98			;		NEXTW 
3a98			 
3a98			 
3a98			 
3a98			 
3a98			.ATQ: 
3a98				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3a98 62				db WORD_SYS_CORE+78             
3a99 f6 3a			dw .AUTODSP            
3a9b 04				db 3 + 1 
3a9c .. 00			db "AT@",0              
3aa0				endm 
# End of macro CWHEAD
3aa0			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3aa0					if DEBUG_FORTH_WORDS_KEY 
3aa0						DMARK "ATA" 
3aa0 f5				push af  
3aa1 3a b5 3a			ld a, (.dmark)  
3aa4 32 bd fb			ld (debug_mark),a  
3aa7 3a b6 3a			ld a, (.dmark+1)  
3aaa 32 be fb			ld (debug_mark+1),a  
3aad 3a b7 3a			ld a, (.dmark+2)  
3ab0 32 bf fb			ld (debug_mark+2),a  
3ab3 18 03			jr .pastdmark  
3ab5 ..			.dmark: db "ATA"  
3ab8 f1			.pastdmark: pop af  
3ab9			endm  
# End of macro DMARK
3ab9						CALLMONITOR 
3ab9 cd d3 13			call break_point_state  
3abc				endm  
# End of macro CALLMONITOR
3abc					endif 
3abc			 
3abc			 
3abc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abc cd fb 19			call macro_dsp_valuehl 
3abf				endm 
# End of macro FORTH_DSP_VALUEHL
3abf			 
3abf					; TODO save cursor row 
3abf 7d					ld a,l 
3ac0 fe 02				cp 2 
3ac2 20 04				jr nz, .crow3aq 
3ac4 3e 14				ld a, display_row_2 
3ac6 18 12				jr .ccol1aq 
3ac8 fe 03		.crow3aq:		cp 3 
3aca 20 04				jr nz, .crow4aq 
3acc 3e 28				ld a, display_row_3 
3ace 18 0a				jr .ccol1aq 
3ad0 fe 04		.crow4aq:		cp 4 
3ad2 20 04				jr nz, .crow1aq 
3ad4 3e 3c				ld a, display_row_4 
3ad6 18 02				jr .ccol1aq 
3ad8 3e 00		.crow1aq:		ld a,display_row_1 
3ada f5			.ccol1aq:		push af			; got row offset 
3adb 6f					ld l,a 
3adc 26 00				ld h,0 
3ade					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ade cd 97 1a			call macro_forth_dsp_pop 
3ae1				endm 
# End of macro FORTH_DSP_POP
3ae1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae1 cd fb 19			call macro_dsp_valuehl 
3ae4				endm 
# End of macro FORTH_DSP_VALUEHL
3ae4					; TODO save cursor col 
3ae4 f1					pop af 
3ae5 85					add l		; add col offset 
3ae6			 
3ae6					; add current frame buffer address 
3ae6 2a 5e fa				ld hl, (display_fb_active) 
3ae9 cd 0f 0c				call addatohl 
3aec			 
3aec			 
3aec			 
3aec			 
3aec					; get char frame buffer location offset in hl 
3aec			 
3aec 7e					ld a,(hl) 
3aed 26 00				ld h, 0 
3aef 6f					ld l, a 
3af0			 
3af0 cd 60 19				call forth_push_numhl 
3af3			 
3af3			 
3af3					NEXTW 
3af3 c3 51 1b			jp macro_next 
3af6				endm 
# End of macro NEXTW
3af6			 
3af6			.AUTODSP: 
3af6				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3af6 63				db WORD_SYS_CORE+79             
3af7 0c 3b			dw .MENU            
3af9 05				db 4 + 1 
3afa .. 00			db "ADSP",0              
3aff				endm 
# End of macro CWHEAD
3aff			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3aff			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3aff			 
3aff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aff cd fb 19			call macro_dsp_valuehl 
3b02				endm 
# End of macro FORTH_DSP_VALUEHL
3b02			 
3b02			;		push hl 
3b02			 
3b02					; destroy value TOS 
3b02			 
3b02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b02 cd 97 1a			call macro_forth_dsp_pop 
3b05				endm 
# End of macro FORTH_DSP_POP
3b05			 
3b05			;		pop hl 
3b05			 
3b05 7d					ld a,l 
3b06 32 bf f9				ld (cli_autodisplay), a 
3b09				       NEXTW 
3b09 c3 51 1b			jp macro_next 
3b0c				endm 
# End of macro NEXTW
3b0c			 
3b0c			.MENU: 
3b0c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3b0c 70				db WORD_SYS_CORE+92             
3b0d 18 3b			dw .ENDDISPLAY            
3b0f 05				db 4 + 1 
3b10 .. 00			db "MENU",0              
3b15				endm 
# End of macro CWHEAD
3b15			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
3b15			 
3b15					; get the title address and save it 
3b15			 
3b15			;		FORTH_DSP_VALUEHL 
3b15			;		push hl 
3b15			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b15			; 
3b15			;		; get number of items on the stack 
3b15			; 
3b15			;	 
3b15			;		FORTH_DSP_VALUEHL 
3b15			;		push hl 
3b15			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b15			 
3b15			 
3b15			 
3b15			 
3b15				       NEXTW 
3b15 c3 51 1b			jp macro_next 
3b18				endm 
# End of macro NEXTW
3b18			 
3b18			 
3b18			.ENDDISPLAY: 
3b18			 
3b18			; eof 
# End of file forth_words_display.asm
3b18			include "forth_words_str.asm" 
3b18			 
3b18			; | ## String Words 
3b18			 
3b18			.PTR:   
3b18			 
3b18				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3b18 48				db WORD_SYS_CORE+52             
3b19 45 3b			dw .STYPE            
3b1b 04				db 3 + 1 
3b1c .. 00			db "PTR",0              
3b20				endm 
# End of macro CWHEAD
3b20			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3b20			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3b20			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3b20			 
3b20					if DEBUG_FORTH_WORDS_KEY 
3b20						DMARK "PTR" 
3b20 f5				push af  
3b21 3a 35 3b			ld a, (.dmark)  
3b24 32 bd fb			ld (debug_mark),a  
3b27 3a 36 3b			ld a, (.dmark+1)  
3b2a 32 be fb			ld (debug_mark+1),a  
3b2d 3a 37 3b			ld a, (.dmark+2)  
3b30 32 bf fb			ld (debug_mark+2),a  
3b33 18 03			jr .pastdmark  
3b35 ..			.dmark: db "PTR"  
3b38 f1			.pastdmark: pop af  
3b39			endm  
# End of macro DMARK
3b39						CALLMONITOR 
3b39 cd d3 13			call break_point_state  
3b3c				endm  
# End of macro CALLMONITOR
3b3c					endif 
3b3c					FORTH_DSP_VALUEHL 
3b3c cd fb 19			call macro_dsp_valuehl 
3b3f				endm 
# End of macro FORTH_DSP_VALUEHL
3b3f cd 60 19				call forth_push_numhl 
3b42			 
3b42			 
3b42					NEXTW 
3b42 c3 51 1b			jp macro_next 
3b45				endm 
# End of macro NEXTW
3b45			.STYPE: 
3b45				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3b45 48				db WORD_SYS_CORE+52             
3b46 94 3b			dw .UPPER            
3b48 06				db 5 + 1 
3b49 .. 00			db "STYPE",0              
3b4f				endm 
# End of macro CWHEAD
3b4f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3b4f					if DEBUG_FORTH_WORDS_KEY 
3b4f						DMARK "STY" 
3b4f f5				push af  
3b50 3a 64 3b			ld a, (.dmark)  
3b53 32 bd fb			ld (debug_mark),a  
3b56 3a 65 3b			ld a, (.dmark+1)  
3b59 32 be fb			ld (debug_mark+1),a  
3b5c 3a 66 3b			ld a, (.dmark+2)  
3b5f 32 bf fb			ld (debug_mark+2),a  
3b62 18 03			jr .pastdmark  
3b64 ..			.dmark: db "STY"  
3b67 f1			.pastdmark: pop af  
3b68			endm  
# End of macro DMARK
3b68						CALLMONITOR 
3b68 cd d3 13			call break_point_state  
3b6b				endm  
# End of macro CALLMONITOR
3b6b					endif 
3b6b					FORTH_DSP 
3b6b cd e0 19			call macro_forth_dsp 
3b6e				endm 
# End of macro FORTH_DSP
3b6e					;v5 FORTH_DSP_VALUE 
3b6e			 
3b6e 7e					ld a, (hl) 
3b6f			 
3b6f f5					push af 
3b70			 
3b70			; Dont destroy TOS		FORTH_DSP_POP 
3b70			 
3b70 f1					pop af 
3b71			 
3b71 fe 01				cp DS_TYPE_STR 
3b73 28 09				jr z, .typestr 
3b75			 
3b75 fe 02				cp DS_TYPE_INUM 
3b77 28 0a				jr z, .typeinum 
3b79			 
3b79 21 92 3b				ld hl, .tna 
3b7c 18 0a				jr .tpush 
3b7e			 
3b7e 21 8e 3b		.typestr:	ld hl, .tstr 
3b81 18 05				jr .tpush 
3b83 21 90 3b		.typeinum:	ld hl, .tinum 
3b86 18 00				jr .tpush 
3b88			 
3b88			.tpush: 
3b88			 
3b88 cd 72 19				call forth_push_str 
3b8b			 
3b8b					NEXTW 
3b8b c3 51 1b			jp macro_next 
3b8e				endm 
# End of macro NEXTW
3b8e .. 00		.tstr:	db "s",0 
3b90 .. 00		.tinum:  db "i",0 
3b92 .. 00		.tna:   db "?", 0 
3b94			 
3b94			 
3b94			.UPPER: 
3b94				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3b94 48				db WORD_SYS_CORE+52             
3b95 cf 3b			dw .LOWER            
3b97 06				db 5 + 1 
3b98 .. 00			db "UPPER",0              
3b9e				endm 
# End of macro CWHEAD
3b9e			; | UPPER ( s -- s ) Upper case string s  | DONE 
3b9e					if DEBUG_FORTH_WORDS_KEY 
3b9e						DMARK "UPR" 
3b9e f5				push af  
3b9f 3a b3 3b			ld a, (.dmark)  
3ba2 32 bd fb			ld (debug_mark),a  
3ba5 3a b4 3b			ld a, (.dmark+1)  
3ba8 32 be fb			ld (debug_mark+1),a  
3bab 3a b5 3b			ld a, (.dmark+2)  
3bae 32 bf fb			ld (debug_mark+2),a  
3bb1 18 03			jr .pastdmark  
3bb3 ..			.dmark: db "UPR"  
3bb6 f1			.pastdmark: pop af  
3bb7			endm  
# End of macro DMARK
3bb7						CALLMONITOR 
3bb7 cd d3 13			call break_point_state  
3bba				endm  
# End of macro CALLMONITOR
3bba					endif 
3bba			 
3bba					FORTH_DSP 
3bba cd e0 19			call macro_forth_dsp 
3bbd				endm 
# End of macro FORTH_DSP
3bbd					 
3bbd			; TODO check is string type 
3bbd			 
3bbd					FORTH_DSP_VALUEHL 
3bbd cd fb 19			call macro_dsp_valuehl 
3bc0				endm 
# End of macro FORTH_DSP_VALUEHL
3bc0			; get pointer to string in hl 
3bc0			 
3bc0 7e			.toup:		ld a, (hl) 
3bc1 fe 00				cp 0 
3bc3 28 07				jr z, .toupdone 
3bc5			 
3bc5 cd 7c 0f				call to_upper 
3bc8			 
3bc8 77					ld (hl), a 
3bc9 23					inc hl 
3bca 18 f4				jr .toup 
3bcc			 
3bcc					 
3bcc			 
3bcc			 
3bcc			; for each char convert to upper 
3bcc					 
3bcc			.toupdone: 
3bcc			 
3bcc			 
3bcc					NEXTW 
3bcc c3 51 1b			jp macro_next 
3bcf				endm 
# End of macro NEXTW
3bcf			.LOWER: 
3bcf				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3bcf 48				db WORD_SYS_CORE+52             
3bd0 0a 3c			dw .TCASE            
3bd2 06				db 5 + 1 
3bd3 .. 00			db "LOWER",0              
3bd9				endm 
# End of macro CWHEAD
3bd9			; | LOWER ( s -- s ) Lower case string s  | DONE 
3bd9					if DEBUG_FORTH_WORDS_KEY 
3bd9						DMARK "LWR" 
3bd9 f5				push af  
3bda 3a ee 3b			ld a, (.dmark)  
3bdd 32 bd fb			ld (debug_mark),a  
3be0 3a ef 3b			ld a, (.dmark+1)  
3be3 32 be fb			ld (debug_mark+1),a  
3be6 3a f0 3b			ld a, (.dmark+2)  
3be9 32 bf fb			ld (debug_mark+2),a  
3bec 18 03			jr .pastdmark  
3bee ..			.dmark: db "LWR"  
3bf1 f1			.pastdmark: pop af  
3bf2			endm  
# End of macro DMARK
3bf2						CALLMONITOR 
3bf2 cd d3 13			call break_point_state  
3bf5				endm  
# End of macro CALLMONITOR
3bf5					endif 
3bf5			 
3bf5					FORTH_DSP 
3bf5 cd e0 19			call macro_forth_dsp 
3bf8				endm 
# End of macro FORTH_DSP
3bf8					 
3bf8			; TODO check is string type 
3bf8			 
3bf8					FORTH_DSP_VALUEHL 
3bf8 cd fb 19			call macro_dsp_valuehl 
3bfb				endm 
# End of macro FORTH_DSP_VALUEHL
3bfb			; get pointer to string in hl 
3bfb			 
3bfb 7e			.tolow:		ld a, (hl) 
3bfc fe 00				cp 0 
3bfe 28 07				jr z, .tolowdone 
3c00			 
3c00 cd 85 0f				call to_lower 
3c03			 
3c03 77					ld (hl), a 
3c04 23					inc hl 
3c05 18 f4				jr .tolow 
3c07			 
3c07					 
3c07			 
3c07			 
3c07			; for each char convert to low 
3c07					 
3c07			.tolowdone: 
3c07					NEXTW 
3c07 c3 51 1b			jp macro_next 
3c0a				endm 
# End of macro NEXTW
3c0a			.TCASE: 
3c0a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3c0a 48				db WORD_SYS_CORE+52             
3c0b 40 3d			dw .SUBSTR            
3c0d 06				db 5 + 1 
3c0e .. 00			db "TCASE",0              
3c14				endm 
# End of macro CWHEAD
3c14			; | TCASE ( s -- s ) Title case string s  | DONE 
3c14					if DEBUG_FORTH_WORDS_KEY 
3c14						DMARK "TCS" 
3c14 f5				push af  
3c15 3a 29 3c			ld a, (.dmark)  
3c18 32 bd fb			ld (debug_mark),a  
3c1b 3a 2a 3c			ld a, (.dmark+1)  
3c1e 32 be fb			ld (debug_mark+1),a  
3c21 3a 2b 3c			ld a, (.dmark+2)  
3c24 32 bf fb			ld (debug_mark+2),a  
3c27 18 03			jr .pastdmark  
3c29 ..			.dmark: db "TCS"  
3c2c f1			.pastdmark: pop af  
3c2d			endm  
# End of macro DMARK
3c2d						CALLMONITOR 
3c2d cd d3 13			call break_point_state  
3c30				endm  
# End of macro CALLMONITOR
3c30					endif 
3c30			 
3c30					FORTH_DSP 
3c30 cd e0 19			call macro_forth_dsp 
3c33				endm 
# End of macro FORTH_DSP
3c33					 
3c33			; TODO check is string type 
3c33			 
3c33					FORTH_DSP_VALUEHL 
3c33 cd fb 19			call macro_dsp_valuehl 
3c36				endm 
# End of macro FORTH_DSP_VALUEHL
3c36			; get pointer to string in hl 
3c36			 
3c36					if DEBUG_FORTH_WORDS 
3c36						DMARK "TC1" 
3c36 f5				push af  
3c37 3a 4b 3c			ld a, (.dmark)  
3c3a 32 bd fb			ld (debug_mark),a  
3c3d 3a 4c 3c			ld a, (.dmark+1)  
3c40 32 be fb			ld (debug_mark+1),a  
3c43 3a 4d 3c			ld a, (.dmark+2)  
3c46 32 bf fb			ld (debug_mark+2),a  
3c49 18 03			jr .pastdmark  
3c4b ..			.dmark: db "TC1"  
3c4e f1			.pastdmark: pop af  
3c4f			endm  
# End of macro DMARK
3c4f						CALLMONITOR 
3c4f cd d3 13			call break_point_state  
3c52				endm  
# End of macro CALLMONITOR
3c52					endif 
3c52			 
3c52					; first time in turn to upper case first char 
3c52			 
3c52 7e					ld a, (hl) 
3c53 c3 dd 3c				jp .totsiptou 
3c56			 
3c56			 
3c56 7e			.tot:		ld a, (hl) 
3c57 fe 00				cp 0 
3c59 ca 21 3d				jp z, .totdone 
3c5c			 
3c5c					if DEBUG_FORTH_WORDS 
3c5c						DMARK "TC2" 
3c5c f5				push af  
3c5d 3a 71 3c			ld a, (.dmark)  
3c60 32 bd fb			ld (debug_mark),a  
3c63 3a 72 3c			ld a, (.dmark+1)  
3c66 32 be fb			ld (debug_mark+1),a  
3c69 3a 73 3c			ld a, (.dmark+2)  
3c6c 32 bf fb			ld (debug_mark+2),a  
3c6f 18 03			jr .pastdmark  
3c71 ..			.dmark: db "TC2"  
3c74 f1			.pastdmark: pop af  
3c75			endm  
# End of macro DMARK
3c75						CALLMONITOR 
3c75 cd d3 13			call break_point_state  
3c78				endm  
# End of macro CALLMONITOR
3c78					endif 
3c78					; check to see if current char is a space 
3c78			 
3c78 fe 20				cp ' ' 
3c7a 28 21				jr z, .totsp 
3c7c cd 85 0f				call to_lower 
3c7f					if DEBUG_FORTH_WORDS 
3c7f						DMARK "TC3" 
3c7f f5				push af  
3c80 3a 94 3c			ld a, (.dmark)  
3c83 32 bd fb			ld (debug_mark),a  
3c86 3a 95 3c			ld a, (.dmark+1)  
3c89 32 be fb			ld (debug_mark+1),a  
3c8c 3a 96 3c			ld a, (.dmark+2)  
3c8f 32 bf fb			ld (debug_mark+2),a  
3c92 18 03			jr .pastdmark  
3c94 ..			.dmark: db "TC3"  
3c97 f1			.pastdmark: pop af  
3c98			endm  
# End of macro DMARK
3c98						CALLMONITOR 
3c98 cd d3 13			call break_point_state  
3c9b				endm  
# End of macro CALLMONITOR
3c9b					endif 
3c9b 18 63				jr .totnxt 
3c9d			 
3c9d			.totsp:         ; on a space, find next char which should be upper 
3c9d			 
3c9d					if DEBUG_FORTH_WORDS 
3c9d						DMARK "TC4" 
3c9d f5				push af  
3c9e 3a b2 3c			ld a, (.dmark)  
3ca1 32 bd fb			ld (debug_mark),a  
3ca4 3a b3 3c			ld a, (.dmark+1)  
3ca7 32 be fb			ld (debug_mark+1),a  
3caa 3a b4 3c			ld a, (.dmark+2)  
3cad 32 bf fb			ld (debug_mark+2),a  
3cb0 18 03			jr .pastdmark  
3cb2 ..			.dmark: db "TC4"  
3cb5 f1			.pastdmark: pop af  
3cb6			endm  
# End of macro DMARK
3cb6						CALLMONITOR 
3cb6 cd d3 13			call break_point_state  
3cb9				endm  
# End of macro CALLMONITOR
3cb9					endif 
3cb9					;; 
3cb9			 
3cb9 fe 20				cp ' ' 
3cbb 20 20				jr nz, .totsiptou 
3cbd 23					inc hl 
3cbe 7e					ld a, (hl) 
3cbf					if DEBUG_FORTH_WORDS 
3cbf						DMARK "TC5" 
3cbf f5				push af  
3cc0 3a d4 3c			ld a, (.dmark)  
3cc3 32 bd fb			ld (debug_mark),a  
3cc6 3a d5 3c			ld a, (.dmark+1)  
3cc9 32 be fb			ld (debug_mark+1),a  
3ccc 3a d6 3c			ld a, (.dmark+2)  
3ccf 32 bf fb			ld (debug_mark+2),a  
3cd2 18 03			jr .pastdmark  
3cd4 ..			.dmark: db "TC5"  
3cd7 f1			.pastdmark: pop af  
3cd8			endm  
# End of macro DMARK
3cd8						CALLMONITOR 
3cd8 cd d3 13			call break_point_state  
3cdb				endm  
# End of macro CALLMONITOR
3cdb					endif 
3cdb 18 c0				jr .totsp 
3cdd fe 00		.totsiptou:    cp 0 
3cdf 28 40				jr z, .totdone 
3ce1					; not space and not zero term so upper case it 
3ce1 cd 7c 0f				call to_upper 
3ce4			 
3ce4					if DEBUG_FORTH_WORDS 
3ce4						DMARK "TC6" 
3ce4 f5				push af  
3ce5 3a f9 3c			ld a, (.dmark)  
3ce8 32 bd fb			ld (debug_mark),a  
3ceb 3a fa 3c			ld a, (.dmark+1)  
3cee 32 be fb			ld (debug_mark+1),a  
3cf1 3a fb 3c			ld a, (.dmark+2)  
3cf4 32 bf fb			ld (debug_mark+2),a  
3cf7 18 03			jr .pastdmark  
3cf9 ..			.dmark: db "TC6"  
3cfc f1			.pastdmark: pop af  
3cfd			endm  
# End of macro DMARK
3cfd						CALLMONITOR 
3cfd cd d3 13			call break_point_state  
3d00				endm  
# End of macro CALLMONITOR
3d00					endif 
3d00			 
3d00			 
3d00			.totnxt: 
3d00			 
3d00 77					ld (hl), a 
3d01 23					inc hl 
3d02					if DEBUG_FORTH_WORDS 
3d02						DMARK "TC7" 
3d02 f5				push af  
3d03 3a 17 3d			ld a, (.dmark)  
3d06 32 bd fb			ld (debug_mark),a  
3d09 3a 18 3d			ld a, (.dmark+1)  
3d0c 32 be fb			ld (debug_mark+1),a  
3d0f 3a 19 3d			ld a, (.dmark+2)  
3d12 32 bf fb			ld (debug_mark+2),a  
3d15 18 03			jr .pastdmark  
3d17 ..			.dmark: db "TC7"  
3d1a f1			.pastdmark: pop af  
3d1b			endm  
# End of macro DMARK
3d1b						CALLMONITOR 
3d1b cd d3 13			call break_point_state  
3d1e				endm  
# End of macro CALLMONITOR
3d1e					endif 
3d1e c3 56 3c				jp .tot 
3d21			 
3d21					 
3d21			 
3d21			 
3d21			; for each char convert to low 
3d21					 
3d21			.totdone: 
3d21					if DEBUG_FORTH_WORDS 
3d21						DMARK "TCd" 
3d21 f5				push af  
3d22 3a 36 3d			ld a, (.dmark)  
3d25 32 bd fb			ld (debug_mark),a  
3d28 3a 37 3d			ld a, (.dmark+1)  
3d2b 32 be fb			ld (debug_mark+1),a  
3d2e 3a 38 3d			ld a, (.dmark+2)  
3d31 32 bf fb			ld (debug_mark+2),a  
3d34 18 03			jr .pastdmark  
3d36 ..			.dmark: db "TCd"  
3d39 f1			.pastdmark: pop af  
3d3a			endm  
# End of macro DMARK
3d3a						CALLMONITOR 
3d3a cd d3 13			call break_point_state  
3d3d				endm  
# End of macro CALLMONITOR
3d3d					endif 
3d3d					NEXTW 
3d3d c3 51 1b			jp macro_next 
3d40				endm 
# End of macro NEXTW
3d40			 
3d40			.SUBSTR: 
3d40				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3d40 48				db WORD_SYS_CORE+52             
3d41 9e 3d			dw .LEFT            
3d43 07				db 6 + 1 
3d44 .. 00			db "SUBSTR",0              
3d4b				endm 
# End of macro CWHEAD
3d4b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3d4b			 
3d4b					if DEBUG_FORTH_WORDS_KEY 
3d4b						DMARK "SST" 
3d4b f5				push af  
3d4c 3a 60 3d			ld a, (.dmark)  
3d4f 32 bd fb			ld (debug_mark),a  
3d52 3a 61 3d			ld a, (.dmark+1)  
3d55 32 be fb			ld (debug_mark+1),a  
3d58 3a 62 3d			ld a, (.dmark+2)  
3d5b 32 bf fb			ld (debug_mark+2),a  
3d5e 18 03			jr .pastdmark  
3d60 ..			.dmark: db "SST"  
3d63 f1			.pastdmark: pop af  
3d64			endm  
# End of macro DMARK
3d64						CALLMONITOR 
3d64 cd d3 13			call break_point_state  
3d67				endm  
# End of macro CALLMONITOR
3d67					endif 
3d67			; TODO check string type 
3d67					FORTH_DSP_VALUEHL 
3d67 cd fb 19			call macro_dsp_valuehl 
3d6a				endm 
# End of macro FORTH_DSP_VALUEHL
3d6a			 
3d6a e5					push hl      ; string length 
3d6b			 
3d6b					FORTH_DSP_POP 
3d6b cd 97 1a			call macro_forth_dsp_pop 
3d6e				endm 
# End of macro FORTH_DSP_POP
3d6e			 
3d6e					FORTH_DSP_VALUEHL 
3d6e cd fb 19			call macro_dsp_valuehl 
3d71				endm 
# End of macro FORTH_DSP_VALUEHL
3d71			 
3d71 e5					push hl     ; start char 
3d72			 
3d72					FORTH_DSP_POP 
3d72 cd 97 1a			call macro_forth_dsp_pop 
3d75				endm 
# End of macro FORTH_DSP_POP
3d75			 
3d75			 
3d75					FORTH_DSP_VALUE 
3d75 cd e4 19			call macro_forth_dsp_value 
3d78				endm 
# End of macro FORTH_DSP_VALUE
3d78			 
3d78 d1					pop de    ; get start post offset 
3d79			 
3d79 19					add hl, de    ; starting offset 
3d7a			 
3d7a c1					pop bc 
3d7b c5					push bc      ; grab size of string 
3d7c			 
3d7c e5					push hl    ; save string start  
3d7d			 
3d7d 26 00				ld h, 0 
3d7f 69					ld l, c 
3d80 23					inc hl 
3d81 23					inc hl 
3d82			 
3d82 cd d6 10				call malloc 
3d85				if DEBUG_FORTH_MALLOC_GUARD 
3d85 cc 9a 4e				call z,malloc_error 
3d88				endif 
3d88			 
3d88 eb					ex de, hl      ; save malloc area for string copy 
3d89 e1					pop hl    ; get back source 
3d8a c1					pop bc    ; get length of string back 
3d8b			 
3d8b d5					push de    ; save malloc area for after we push 
3d8c ed b0				ldir     ; copy substr 
3d8e			 
3d8e			 
3d8e eb					ex de, hl 
3d8f 3e 00				ld a, 0 
3d91 77					ld (hl), a   ; term substr 
3d92			 
3d92					 
3d92 e1					pop hl    ; get malloc so we can push it 
3d93 e5					push hl   ; save so we can free it afterwards 
3d94			 
3d94 cd 72 19				call forth_push_str 
3d97			 
3d97 e1					pop hl 
3d98 cd a0 11				call free 
3d9b			 
3d9b					 
3d9b					 
3d9b			 
3d9b			 
3d9b					NEXTW 
3d9b c3 51 1b			jp macro_next 
3d9e				endm 
# End of macro NEXTW
3d9e			 
3d9e			.LEFT: 
3d9e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3d9e 48				db WORD_SYS_CORE+52             
3d9f c6 3d			dw .RIGHT            
3da1 05				db 4 + 1 
3da2 .. 00			db "LEFT",0              
3da7				endm 
# End of macro CWHEAD
3da7			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3da7					if DEBUG_FORTH_WORDS_KEY 
3da7						DMARK "LEF" 
3da7 f5				push af  
3da8 3a bc 3d			ld a, (.dmark)  
3dab 32 bd fb			ld (debug_mark),a  
3dae 3a bd 3d			ld a, (.dmark+1)  
3db1 32 be fb			ld (debug_mark+1),a  
3db4 3a be 3d			ld a, (.dmark+2)  
3db7 32 bf fb			ld (debug_mark+2),a  
3dba 18 03			jr .pastdmark  
3dbc ..			.dmark: db "LEF"  
3dbf f1			.pastdmark: pop af  
3dc0			endm  
# End of macro DMARK
3dc0						CALLMONITOR 
3dc0 cd d3 13			call break_point_state  
3dc3				endm  
# End of macro CALLMONITOR
3dc3					endif 
3dc3			 
3dc3					NEXTW 
3dc3 c3 51 1b			jp macro_next 
3dc6				endm 
# End of macro NEXTW
3dc6			.RIGHT: 
3dc6				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3dc6 48				db WORD_SYS_CORE+52             
3dc7 ef 3d			dw .STR2NUM            
3dc9 06				db 5 + 1 
3dca .. 00			db "RIGHT",0              
3dd0				endm 
# End of macro CWHEAD
3dd0			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3dd0					if DEBUG_FORTH_WORDS_KEY 
3dd0						DMARK "RIG" 
3dd0 f5				push af  
3dd1 3a e5 3d			ld a, (.dmark)  
3dd4 32 bd fb			ld (debug_mark),a  
3dd7 3a e6 3d			ld a, (.dmark+1)  
3dda 32 be fb			ld (debug_mark+1),a  
3ddd 3a e7 3d			ld a, (.dmark+2)  
3de0 32 bf fb			ld (debug_mark+2),a  
3de3 18 03			jr .pastdmark  
3de5 ..			.dmark: db "RIG"  
3de8 f1			.pastdmark: pop af  
3de9			endm  
# End of macro DMARK
3de9						CALLMONITOR 
3de9 cd d3 13			call break_point_state  
3dec				endm  
# End of macro CALLMONITOR
3dec					endif 
3dec			 
3dec					NEXTW 
3dec c3 51 1b			jp macro_next 
3def				endm 
# End of macro NEXTW
3def			 
3def			 
3def			.STR2NUM: 
3def				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3def 48				db WORD_SYS_CORE+52             
3df0 7b 3e			dw .NUM2STR            
3df2 08				db 7 + 1 
3df3 .. 00			db "STR2NUM",0              
3dfb				endm 
# End of macro CWHEAD
3dfb			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3dfb			 
3dfb			 
3dfb			; TODO STR type check to do 
3dfb					if DEBUG_FORTH_WORDS_KEY 
3dfb						DMARK "S2N" 
3dfb f5				push af  
3dfc 3a 10 3e			ld a, (.dmark)  
3dff 32 bd fb			ld (debug_mark),a  
3e02 3a 11 3e			ld a, (.dmark+1)  
3e05 32 be fb			ld (debug_mark+1),a  
3e08 3a 12 3e			ld a, (.dmark+2)  
3e0b 32 bf fb			ld (debug_mark+2),a  
3e0e 18 03			jr .pastdmark  
3e10 ..			.dmark: db "S2N"  
3e13 f1			.pastdmark: pop af  
3e14			endm  
# End of macro DMARK
3e14						CALLMONITOR 
3e14 cd d3 13			call break_point_state  
3e17				endm  
# End of macro CALLMONITOR
3e17					endif 
3e17			 
3e17					;FORTH_DSP 
3e17					FORTH_DSP_VALUE 
3e17 cd e4 19			call macro_forth_dsp_value 
3e1a				endm 
# End of macro FORTH_DSP_VALUE
3e1a					;inc hl 
3e1a			 
3e1a eb					ex de, hl 
3e1b					if DEBUG_FORTH_WORDS 
3e1b						DMARK "S2a" 
3e1b f5				push af  
3e1c 3a 30 3e			ld a, (.dmark)  
3e1f 32 bd fb			ld (debug_mark),a  
3e22 3a 31 3e			ld a, (.dmark+1)  
3e25 32 be fb			ld (debug_mark+1),a  
3e28 3a 32 3e			ld a, (.dmark+2)  
3e2b 32 bf fb			ld (debug_mark+2),a  
3e2e 18 03			jr .pastdmark  
3e30 ..			.dmark: db "S2a"  
3e33 f1			.pastdmark: pop af  
3e34			endm  
# End of macro DMARK
3e34						CALLMONITOR 
3e34 cd d3 13			call break_point_state  
3e37				endm  
# End of macro CALLMONITOR
3e37					endif 
3e37 cd 04 10				call string_to_uint16 
3e3a			 
3e3a					if DEBUG_FORTH_WORDS 
3e3a						DMARK "S2b" 
3e3a f5				push af  
3e3b 3a 4f 3e			ld a, (.dmark)  
3e3e 32 bd fb			ld (debug_mark),a  
3e41 3a 50 3e			ld a, (.dmark+1)  
3e44 32 be fb			ld (debug_mark+1),a  
3e47 3a 51 3e			ld a, (.dmark+2)  
3e4a 32 bf fb			ld (debug_mark+2),a  
3e4d 18 03			jr .pastdmark  
3e4f ..			.dmark: db "S2b"  
3e52 f1			.pastdmark: pop af  
3e53			endm  
# End of macro DMARK
3e53						CALLMONITOR 
3e53 cd d3 13			call break_point_state  
3e56				endm  
# End of macro CALLMONITOR
3e56					endif 
3e56			;		push hl 
3e56					FORTH_DSP_POP 
3e56 cd 97 1a			call macro_forth_dsp_pop 
3e59				endm 
# End of macro FORTH_DSP_POP
3e59			;		pop hl 
3e59					 
3e59					if DEBUG_FORTH_WORDS 
3e59						DMARK "S2b" 
3e59 f5				push af  
3e5a 3a 6e 3e			ld a, (.dmark)  
3e5d 32 bd fb			ld (debug_mark),a  
3e60 3a 6f 3e			ld a, (.dmark+1)  
3e63 32 be fb			ld (debug_mark+1),a  
3e66 3a 70 3e			ld a, (.dmark+2)  
3e69 32 bf fb			ld (debug_mark+2),a  
3e6c 18 03			jr .pastdmark  
3e6e ..			.dmark: db "S2b"  
3e71 f1			.pastdmark: pop af  
3e72			endm  
# End of macro DMARK
3e72						CALLMONITOR 
3e72 cd d3 13			call break_point_state  
3e75				endm  
# End of macro CALLMONITOR
3e75					endif 
3e75 cd 60 19				call forth_push_numhl	 
3e78			 
3e78				 
3e78				       NEXTW 
3e78 c3 51 1b			jp macro_next 
3e7b				endm 
# End of macro NEXTW
3e7b			.NUM2STR: 
3e7b				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3e7b 48				db WORD_SYS_CORE+52             
3e7c 8a 3e			dw .CONCAT            
3e7e 08				db 7 + 1 
3e7f .. 00			db "NUM2STR",0              
3e87				endm 
# End of macro CWHEAD
3e87			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3e87			 
3e87			;		; malloc a string to target 
3e87			;		ld hl, 10     ; TODO max string size should be fine 
3e87			;		call malloc 
3e87			;		push hl    ; save malloc location 
3e87			; 
3e87			; 
3e87			;; TODO check int type 
3e87			;		FORTH_DSP_VALUEHL 
3e87			;		ld a, l 
3e87			;		call DispAToASCII   
3e87			;;TODO need to chage above call to dump into string 
3e87			; 
3e87			; 
3e87			 
3e87				       NEXTW 
3e87 c3 51 1b			jp macro_next 
3e8a				endm 
# End of macro NEXTW
3e8a			 
3e8a			.CONCAT: 
3e8a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3e8a 48				db WORD_SYS_CORE+52             
3e8b 3d 3f			dw .FIND            
3e8d 07				db 6 + 1 
3e8e .. 00			db "CONCAT",0              
3e95				endm 
# End of macro CWHEAD
3e95			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3e95			 
3e95			; TODO check string type 
3e95			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3e95			 
3e95					if DEBUG_FORTH_WORDS_KEY 
3e95						DMARK "CON" 
3e95 f5				push af  
3e96 3a aa 3e			ld a, (.dmark)  
3e99 32 bd fb			ld (debug_mark),a  
3e9c 3a ab 3e			ld a, (.dmark+1)  
3e9f 32 be fb			ld (debug_mark+1),a  
3ea2 3a ac 3e			ld a, (.dmark+2)  
3ea5 32 bf fb			ld (debug_mark+2),a  
3ea8 18 03			jr .pastdmark  
3eaa ..			.dmark: db "CON"  
3ead f1			.pastdmark: pop af  
3eae			endm  
# End of macro DMARK
3eae						CALLMONITOR 
3eae cd d3 13			call break_point_state  
3eb1				endm  
# End of macro CALLMONITOR
3eb1					endif 
3eb1			 
3eb1			 
3eb1					FORTH_DSP_VALUE 
3eb1 cd e4 19			call macro_forth_dsp_value 
3eb4				endm 
# End of macro FORTH_DSP_VALUE
3eb4 e5					push hl   ; s2 
3eb5			 
3eb5					FORTH_DSP_POP 
3eb5 cd 97 1a			call macro_forth_dsp_pop 
3eb8				endm 
# End of macro FORTH_DSP_POP
3eb8			 
3eb8					FORTH_DSP_VALUE 
3eb8 cd e4 19			call macro_forth_dsp_value 
3ebb				endm 
# End of macro FORTH_DSP_VALUE
3ebb			 
3ebb e5					push hl   ; s1 
3ebc			 
3ebc					FORTH_DSP_POP 
3ebc cd 97 1a			call macro_forth_dsp_pop 
3ebf				endm 
# End of macro FORTH_DSP_POP
3ebf					 
3ebf			 
3ebf					; copy s1 
3ebf			 
3ebf				 
3ebf					; save ptr 
3ebf e1					pop hl  
3ec0 e5					push hl 
3ec1 3e 00				ld a, 0 
3ec3 cd 78 10				call strlent 
3ec6					;inc hl    ; zer0 
3ec6 06 00				ld b, 0 
3ec8 4d					ld c, l 
3ec9 e1					pop hl		 
3eca 11 b8 ef				ld de, scratch	 
3ecd					if DEBUG_FORTH_WORDS 
3ecd						DMARK "CO1" 
3ecd f5				push af  
3ece 3a e2 3e			ld a, (.dmark)  
3ed1 32 bd fb			ld (debug_mark),a  
3ed4 3a e3 3e			ld a, (.dmark+1)  
3ed7 32 be fb			ld (debug_mark+1),a  
3eda 3a e4 3e			ld a, (.dmark+2)  
3edd 32 bf fb			ld (debug_mark+2),a  
3ee0 18 03			jr .pastdmark  
3ee2 ..			.dmark: db "CO1"  
3ee5 f1			.pastdmark: pop af  
3ee6			endm  
# End of macro DMARK
3ee6						CALLMONITOR 
3ee6 cd d3 13			call break_point_state  
3ee9				endm  
# End of macro CALLMONITOR
3ee9					endif 
3ee9 ed b0				ldir 
3eeb			 
3eeb e1					pop hl 
3eec e5					push hl 
3eed d5					push de 
3eee			 
3eee			 
3eee 3e 00				ld a, 0 
3ef0 cd 78 10				call strlent 
3ef3 23					inc hl    ; zer0 
3ef4 23					inc hl 
3ef5 06 00				ld b, 0 
3ef7 4d					ld c, l 
3ef8 d1					pop de 
3ef9 e1					pop hl		 
3efa					if DEBUG_FORTH_WORDS 
3efa						DMARK "CO2" 
3efa f5				push af  
3efb 3a 0f 3f			ld a, (.dmark)  
3efe 32 bd fb			ld (debug_mark),a  
3f01 3a 10 3f			ld a, (.dmark+1)  
3f04 32 be fb			ld (debug_mark+1),a  
3f07 3a 11 3f			ld a, (.dmark+2)  
3f0a 32 bf fb			ld (debug_mark+2),a  
3f0d 18 03			jr .pastdmark  
3f0f ..			.dmark: db "CO2"  
3f12 f1			.pastdmark: pop af  
3f13			endm  
# End of macro DMARK
3f13						CALLMONITOR 
3f13 cd d3 13			call break_point_state  
3f16				endm  
# End of macro CALLMONITOR
3f16					endif 
3f16 ed b0				ldir 
3f18			 
3f18			 
3f18			 
3f18 21 b8 ef				ld hl, scratch 
3f1b					if DEBUG_FORTH_WORDS 
3f1b						DMARK "CO5" 
3f1b f5				push af  
3f1c 3a 30 3f			ld a, (.dmark)  
3f1f 32 bd fb			ld (debug_mark),a  
3f22 3a 31 3f			ld a, (.dmark+1)  
3f25 32 be fb			ld (debug_mark+1),a  
3f28 3a 32 3f			ld a, (.dmark+2)  
3f2b 32 bf fb			ld (debug_mark+2),a  
3f2e 18 03			jr .pastdmark  
3f30 ..			.dmark: db "CO5"  
3f33 f1			.pastdmark: pop af  
3f34			endm  
# End of macro DMARK
3f34						CALLMONITOR 
3f34 cd d3 13			call break_point_state  
3f37				endm  
# End of macro CALLMONITOR
3f37					endif 
3f37			 
3f37 cd 72 19				call forth_push_str 
3f3a			 
3f3a			 
3f3a			 
3f3a			 
3f3a				       NEXTW 
3f3a c3 51 1b			jp macro_next 
3f3d				endm 
# End of macro NEXTW
3f3d			 
3f3d			 
3f3d			.FIND: 
3f3d				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3f3d 4b				db WORD_SYS_CORE+55             
3f3e fb 3f			dw .LEN            
3f40 05				db 4 + 1 
3f41 .. 00			db "FIND",0              
3f46				endm 
# End of macro CWHEAD
3f46			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3f46			 
3f46					if DEBUG_FORTH_WORDS_KEY 
3f46						DMARK "FND" 
3f46 f5				push af  
3f47 3a 5b 3f			ld a, (.dmark)  
3f4a 32 bd fb			ld (debug_mark),a  
3f4d 3a 5c 3f			ld a, (.dmark+1)  
3f50 32 be fb			ld (debug_mark+1),a  
3f53 3a 5d 3f			ld a, (.dmark+2)  
3f56 32 bf fb			ld (debug_mark+2),a  
3f59 18 03			jr .pastdmark  
3f5b ..			.dmark: db "FND"  
3f5e f1			.pastdmark: pop af  
3f5f			endm  
# End of macro DMARK
3f5f						CALLMONITOR 
3f5f cd d3 13			call break_point_state  
3f62				endm  
# End of macro CALLMONITOR
3f62					endif 
3f62			 
3f62			; TODO check string type 
3f62					FORTH_DSP_VALUE 
3f62 cd e4 19			call macro_forth_dsp_value 
3f65				endm 
# End of macro FORTH_DSP_VALUE
3f65			 
3f65 e5					push hl    
3f66 7e					ld a,(hl)    ; char to find   
3f67			; TODO change char to substr 
3f67			 
3f67 f5					push af 
3f68					 
3f68			 
3f68			 
3f68					if DEBUG_FORTH_WORDS 
3f68						DMARK "FN1" 
3f68 f5				push af  
3f69 3a 7d 3f			ld a, (.dmark)  
3f6c 32 bd fb			ld (debug_mark),a  
3f6f 3a 7e 3f			ld a, (.dmark+1)  
3f72 32 be fb			ld (debug_mark+1),a  
3f75 3a 7f 3f			ld a, (.dmark+2)  
3f78 32 bf fb			ld (debug_mark+2),a  
3f7b 18 03			jr .pastdmark  
3f7d ..			.dmark: db "FN1"  
3f80 f1			.pastdmark: pop af  
3f81			endm  
# End of macro DMARK
3f81						CALLMONITOR 
3f81 cd d3 13			call break_point_state  
3f84				endm  
# End of macro CALLMONITOR
3f84					endif 
3f84			 
3f84					FORTH_DSP_POP 
3f84 cd 97 1a			call macro_forth_dsp_pop 
3f87				endm 
# End of macro FORTH_DSP_POP
3f87			 
3f87					; string to search 
3f87			 
3f87					FORTH_DSP_VALUE 
3f87 cd e4 19			call macro_forth_dsp_value 
3f8a				endm 
# End of macro FORTH_DSP_VALUE
3f8a			 
3f8a d1					pop de  ; d is char to find  
3f8b			 
3f8b					if DEBUG_FORTH_WORDS 
3f8b						DMARK "FN2" 
3f8b f5				push af  
3f8c 3a a0 3f			ld a, (.dmark)  
3f8f 32 bd fb			ld (debug_mark),a  
3f92 3a a1 3f			ld a, (.dmark+1)  
3f95 32 be fb			ld (debug_mark+1),a  
3f98 3a a2 3f			ld a, (.dmark+2)  
3f9b 32 bf fb			ld (debug_mark+2),a  
3f9e 18 03			jr .pastdmark  
3fa0 ..			.dmark: db "FN2"  
3fa3 f1			.pastdmark: pop af  
3fa4			endm  
# End of macro DMARK
3fa4						CALLMONITOR 
3fa4 cd d3 13			call break_point_state  
3fa7				endm  
# End of macro CALLMONITOR
3fa7					endif 
3fa7					 
3fa7 01 00 00				ld bc, 0 
3faa 7e			.findchar:      ld a,(hl) 
3fab fe 00				cp 0   		 
3fad 28 27				jr z, .finddone     
3faf ba					cp d 
3fb0 28 20				jr z, .foundchar 
3fb2 03					inc bc 
3fb3 23					inc hl 
3fb4					if DEBUG_FORTH_WORDS 
3fb4						DMARK "FN3" 
3fb4 f5				push af  
3fb5 3a c9 3f			ld a, (.dmark)  
3fb8 32 bd fb			ld (debug_mark),a  
3fbb 3a ca 3f			ld a, (.dmark+1)  
3fbe 32 be fb			ld (debug_mark+1),a  
3fc1 3a cb 3f			ld a, (.dmark+2)  
3fc4 32 bf fb			ld (debug_mark+2),a  
3fc7 18 03			jr .pastdmark  
3fc9 ..			.dmark: db "FN3"  
3fcc f1			.pastdmark: pop af  
3fcd			endm  
# End of macro DMARK
3fcd						CALLMONITOR 
3fcd cd d3 13			call break_point_state  
3fd0				endm  
# End of macro CALLMONITOR
3fd0					endif 
3fd0 18 d8				jr .findchar 
3fd2			 
3fd2			 
3fd2 c5			.foundchar:	push bc 
3fd3 e1					pop hl 
3fd4 18 03				jr .findexit 
3fd6			 
3fd6			 
3fd6							 
3fd6			 
3fd6			.finddone:     ; got to end of string with no find 
3fd6 21 00 00				ld hl, 0 
3fd9			.findexit: 
3fd9			 
3fd9					if DEBUG_FORTH_WORDS 
3fd9						DMARK "FNd" 
3fd9 f5				push af  
3fda 3a ee 3f			ld a, (.dmark)  
3fdd 32 bd fb			ld (debug_mark),a  
3fe0 3a ef 3f			ld a, (.dmark+1)  
3fe3 32 be fb			ld (debug_mark+1),a  
3fe6 3a f0 3f			ld a, (.dmark+2)  
3fe9 32 bf fb			ld (debug_mark+2),a  
3fec 18 03			jr .pastdmark  
3fee ..			.dmark: db "FNd"  
3ff1 f1			.pastdmark: pop af  
3ff2			endm  
# End of macro DMARK
3ff2						CALLMONITOR 
3ff2 cd d3 13			call break_point_state  
3ff5				endm  
# End of macro CALLMONITOR
3ff5					endif 
3ff5 cd 60 19			call forth_push_numhl 
3ff8			 
3ff8				       NEXTW 
3ff8 c3 51 1b			jp macro_next 
3ffb				endm 
# End of macro NEXTW
3ffb			 
3ffb			.LEN: 
3ffb				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
3ffb 4c				db WORD_SYS_CORE+56             
3ffc 30 40			dw .CHAR            
3ffe 06				db 5 + 1 
3fff .. 00			db "COUNT",0              
4005				endm 
# End of macro CWHEAD
4005			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4005			 
4005					if DEBUG_FORTH_WORDS_KEY 
4005						DMARK "CNT" 
4005 f5				push af  
4006 3a 1a 40			ld a, (.dmark)  
4009 32 bd fb			ld (debug_mark),a  
400c 3a 1b 40			ld a, (.dmark+1)  
400f 32 be fb			ld (debug_mark+1),a  
4012 3a 1c 40			ld a, (.dmark+2)  
4015 32 bf fb			ld (debug_mark+2),a  
4018 18 03			jr .pastdmark  
401a ..			.dmark: db "CNT"  
401d f1			.pastdmark: pop af  
401e			endm  
# End of macro DMARK
401e						CALLMONITOR 
401e cd d3 13			call break_point_state  
4021				endm  
# End of macro CALLMONITOR
4021					endif 
4021			; TODO check string type 
4021					FORTH_DSP 
4021 cd e0 19			call macro_forth_dsp 
4024				endm 
# End of macro FORTH_DSP
4024					;v5FORTH_DSP_VALUE 
4024			 
4024 23					inc hl 
4025			 
4025 3e 00				ld a, 0 
4027 cd 78 10				call strlent 
402a			 
402a cd 60 19				call forth_push_numhl 
402d			 
402d			 
402d			 
402d				       NEXTW 
402d c3 51 1b			jp macro_next 
4030				endm 
# End of macro NEXTW
4030			.CHAR: 
4030				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4030 4d				db WORD_SYS_CORE+57             
4031 66 40			dw .ENDSTR            
4033 05				db 4 + 1 
4034 .. 00			db "CHAR",0              
4039				endm 
# End of macro CWHEAD
4039			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4039					if DEBUG_FORTH_WORDS_KEY 
4039						DMARK "CHR" 
4039 f5				push af  
403a 3a 4e 40			ld a, (.dmark)  
403d 32 bd fb			ld (debug_mark),a  
4040 3a 4f 40			ld a, (.dmark+1)  
4043 32 be fb			ld (debug_mark+1),a  
4046 3a 50 40			ld a, (.dmark+2)  
4049 32 bf fb			ld (debug_mark+2),a  
404c 18 03			jr .pastdmark  
404e ..			.dmark: db "CHR"  
4051 f1			.pastdmark: pop af  
4052			endm  
# End of macro DMARK
4052						CALLMONITOR 
4052 cd d3 13			call break_point_state  
4055				endm  
# End of macro CALLMONITOR
4055					endif 
4055					FORTH_DSP 
4055 cd e0 19			call macro_forth_dsp 
4058				endm 
# End of macro FORTH_DSP
4058					;v5 FORTH_DSP_VALUE 
4058 23					inc hl      ; now at start of numeric as string 
4059			 
4059			;		push hl 
4059			 
4059					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4059 cd 97 1a			call macro_forth_dsp_pop 
405c				endm 
# End of macro FORTH_DSP_POP
405c			 
405c			;		pop hl 
405c			 
405c					; push the content of a onto the stack as a value 
405c			 
405c 7e					ld a,(hl)   ; get char 
405d 26 00				ld h,0 
405f 6f					ld l,a 
4060 cd 60 19				call forth_push_numhl 
4063			 
4063				       NEXTW 
4063 c3 51 1b			jp macro_next 
4066				endm 
# End of macro NEXTW
4066			 
4066			 
4066			 
4066			 
4066			.ENDSTR: 
4066			; eof 
4066			 
# End of file forth_words_str.asm
4066			include "forth_words_key.asm" 
4066			 
4066			; | ## Keyboard Words 
4066			 
4066			.KEY: 
4066				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4066 3e				db WORD_SYS_CORE+42             
4067 96 40			dw .WAITK            
4069 04				db 3 + 1 
406a .. 00			db "KEY",0              
406e				endm 
# End of macro CWHEAD
406e			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
406e			 
406e					if DEBUG_FORTH_WORDS_KEY 
406e						DMARK "KEY" 
406e f5				push af  
406f 3a 83 40			ld a, (.dmark)  
4072 32 bd fb			ld (debug_mark),a  
4075 3a 84 40			ld a, (.dmark+1)  
4078 32 be fb			ld (debug_mark+1),a  
407b 3a 85 40			ld a, (.dmark+2)  
407e 32 bf fb			ld (debug_mark+2),a  
4081 18 03			jr .pastdmark  
4083 ..			.dmark: db "KEY"  
4086 f1			.pastdmark: pop af  
4087			endm  
# End of macro DMARK
4087						CALLMONITOR 
4087 cd d3 13			call break_point_state  
408a				endm  
# End of macro CALLMONITOR
408a					endif 
408a			; TODO currently waits 
408a cd 01 63				call cin 
408d					;call cin_wait 
408d 6f					ld l, a 
408e 26 00				ld h, 0 
4090 cd 60 19				call forth_push_numhl 
4093					NEXTW 
4093 c3 51 1b			jp macro_next 
4096				endm 
# End of macro NEXTW
4096			.WAITK: 
4096				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4096 3f				db WORD_SYS_CORE+43             
4097 c8 40			dw .ACCEPT            
4099 06				db 5 + 1 
409a .. 00			db "WAITK",0              
40a0				endm 
# End of macro CWHEAD
40a0			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
40a0					if DEBUG_FORTH_WORDS_KEY 
40a0						DMARK "WAI" 
40a0 f5				push af  
40a1 3a b5 40			ld a, (.dmark)  
40a4 32 bd fb			ld (debug_mark),a  
40a7 3a b6 40			ld a, (.dmark+1)  
40aa 32 be fb			ld (debug_mark+1),a  
40ad 3a b7 40			ld a, (.dmark+2)  
40b0 32 bf fb			ld (debug_mark+2),a  
40b3 18 03			jr .pastdmark  
40b5 ..			.dmark: db "WAI"  
40b8 f1			.pastdmark: pop af  
40b9			endm  
# End of macro DMARK
40b9						CALLMONITOR 
40b9 cd d3 13			call break_point_state  
40bc				endm  
# End of macro CALLMONITOR
40bc					endif 
40bc cd f0 62				call cin_wait 
40bf 6f					ld l, a 
40c0 26 00				ld h, 0 
40c2 cd 60 19				call forth_push_numhl 
40c5					NEXTW 
40c5 c3 51 1b			jp macro_next 
40c8				endm 
# End of macro NEXTW
40c8			.ACCEPT: 
40c8				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
40c8 40				db WORD_SYS_CORE+44             
40c9 26 41			dw .EDIT            
40cb 07				db 6 + 1 
40cc .. 00			db "ACCEPT",0              
40d3				endm 
# End of macro CWHEAD
40d3			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
40d3					; TODO crashes on push 
40d3					if DEBUG_FORTH_WORDS_KEY 
40d3						DMARK "ACC" 
40d3 f5				push af  
40d4 3a e8 40			ld a, (.dmark)  
40d7 32 bd fb			ld (debug_mark),a  
40da 3a e9 40			ld a, (.dmark+1)  
40dd 32 be fb			ld (debug_mark+1),a  
40e0 3a ea 40			ld a, (.dmark+2)  
40e3 32 bf fb			ld (debug_mark+2),a  
40e6 18 03			jr .pastdmark  
40e8 ..			.dmark: db "ACC"  
40eb f1			.pastdmark: pop af  
40ec			endm  
# End of macro DMARK
40ec						CALLMONITOR 
40ec cd d3 13			call break_point_state  
40ef				endm  
# End of macro CALLMONITOR
40ef					endif 
40ef 21 b6 f1				ld hl, os_input 
40f2 3e 00				ld a, 0 
40f4 77					ld (hl),a 
40f5 3a e1 f9				ld a,(f_cursor_ptr) 
40f8 16 64				ld d, 100 
40fa 0e 00				ld c, 0 
40fc 1e 28				ld e, 40 
40fe cd 3c 0c				call input_str 
4101					; TODO perhaps do a type check and wrap in quotes if not a number 
4101 21 b6 f1				ld hl, os_input 
4104					if DEBUG_FORTH_WORDS 
4104						DMARK "AC1" 
4104 f5				push af  
4105 3a 19 41			ld a, (.dmark)  
4108 32 bd fb			ld (debug_mark),a  
410b 3a 1a 41			ld a, (.dmark+1)  
410e 32 be fb			ld (debug_mark+1),a  
4111 3a 1b 41			ld a, (.dmark+2)  
4114 32 bf fb			ld (debug_mark+2),a  
4117 18 03			jr .pastdmark  
4119 ..			.dmark: db "AC1"  
411c f1			.pastdmark: pop af  
411d			endm  
# End of macro DMARK
411d						CALLMONITOR 
411d cd d3 13			call break_point_state  
4120				endm  
# End of macro CALLMONITOR
4120					endif 
4120 cd 72 19				call forth_push_str 
4123					NEXTW 
4123 c3 51 1b			jp macro_next 
4126				endm 
# End of macro NEXTW
4126			 
4126			.EDIT: 
4126				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4126 40				db WORD_SYS_CORE+44             
4127 af 41			dw .ENDKEY            
4129 05				db 4 + 1 
412a .. 00			db "EDIT",0              
412f				endm 
# End of macro CWHEAD
412f			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
412f			 
412f					; TODO does not copy from stack 
412f					if DEBUG_FORTH_WORDS_KEY 
412f						DMARK "EDT" 
412f f5				push af  
4130 3a 44 41			ld a, (.dmark)  
4133 32 bd fb			ld (debug_mark),a  
4136 3a 45 41			ld a, (.dmark+1)  
4139 32 be fb			ld (debug_mark+1),a  
413c 3a 46 41			ld a, (.dmark+2)  
413f 32 bf fb			ld (debug_mark+2),a  
4142 18 03			jr .pastdmark  
4144 ..			.dmark: db "EDT"  
4147 f1			.pastdmark: pop af  
4148			endm  
# End of macro DMARK
4148						CALLMONITOR 
4148 cd d3 13			call break_point_state  
414b				endm  
# End of macro CALLMONITOR
414b					endif 
414b			 
414b					FORTH_DSP 
414b cd e0 19			call macro_forth_dsp 
414e				endm 
# End of macro FORTH_DSP
414e					;v5 FORTH_DSP_VALUE 
414e 23					inc hl    ; TODO do type check 
414f			 
414f e5					push hl 
4150 3e 00				ld a, 0 
4152 cd 78 10				call strlent 
4155 23					inc hl 
4156			 
4156 06 00				ld b, 0 
4158 4d					ld c, l 
4159			 
4159 e1					pop hl 
415a 11 b6 f1				ld de, os_input 
415d					if DEBUG_FORTH_WORDS_KEY 
415d						DMARK "EDc" 
415d f5				push af  
415e 3a 72 41			ld a, (.dmark)  
4161 32 bd fb			ld (debug_mark),a  
4164 3a 73 41			ld a, (.dmark+1)  
4167 32 be fb			ld (debug_mark+1),a  
416a 3a 74 41			ld a, (.dmark+2)  
416d 32 bf fb			ld (debug_mark+2),a  
4170 18 03			jr .pastdmark  
4172 ..			.dmark: db "EDc"  
4175 f1			.pastdmark: pop af  
4176			endm  
# End of macro DMARK
4176						CALLMONITOR 
4176 cd d3 13			call break_point_state  
4179				endm  
# End of macro CALLMONITOR
4179					endif 
4179 ed b0				ldir 
417b			 
417b			 
417b 21 b6 f1				ld hl, os_input 
417e					;ld a, 0 
417e					;ld (hl),a 
417e 3a e1 f9				ld a,(f_cursor_ptr) 
4181 16 64				ld d, 100 
4183 0e 00				ld c, 0 
4185 1e 28				ld e, 40 
4187 cd 3c 0c				call input_str 
418a					; TODO perhaps do a type check and wrap in quotes if not a number 
418a 21 b6 f1				ld hl, os_input 
418d					if DEBUG_FORTH_WORDS 
418d						DMARK "ED1" 
418d f5				push af  
418e 3a a2 41			ld a, (.dmark)  
4191 32 bd fb			ld (debug_mark),a  
4194 3a a3 41			ld a, (.dmark+1)  
4197 32 be fb			ld (debug_mark+1),a  
419a 3a a4 41			ld a, (.dmark+2)  
419d 32 bf fb			ld (debug_mark+2),a  
41a0 18 03			jr .pastdmark  
41a2 ..			.dmark: db "ED1"  
41a5 f1			.pastdmark: pop af  
41a6			endm  
# End of macro DMARK
41a6						CALLMONITOR 
41a6 cd d3 13			call break_point_state  
41a9				endm  
# End of macro CALLMONITOR
41a9					endif 
41a9 cd 72 19				call forth_push_str 
41ac					NEXTW 
41ac c3 51 1b			jp macro_next 
41af				endm 
# End of macro NEXTW
41af			 
41af			 
41af			 
41af			.ENDKEY: 
41af			; eof 
41af			 
# End of file forth_words_key.asm
41af			 
41af			if STORAGE_SE 
41af			   	include "forth_words_storage.asm" 
41af			 
41af			; | ## Fixed Storage Words 
41af			 
41af			 
41af			.BREAD: 
41af			  
41af				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
41af 3a				db WORD_SYS_CORE+38             
41b0 28 42			dw .BWRITE            
41b2 06				db 5 + 1 
41b3 .. 00			db "BREAD",0              
41b9				endm 
# End of macro CWHEAD
41b9			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
41b9				 
41b9					if DEBUG_FORTH_WORDS_KEY 
41b9						DMARK "BRD" 
41b9 f5				push af  
41ba 3a ce 41			ld a, (.dmark)  
41bd 32 bd fb			ld (debug_mark),a  
41c0 3a cf 41			ld a, (.dmark+1)  
41c3 32 be fb			ld (debug_mark+1),a  
41c6 3a d0 41			ld a, (.dmark+2)  
41c9 32 bf fb			ld (debug_mark+2),a  
41cc 18 03			jr .pastdmark  
41ce ..			.dmark: db "BRD"  
41d1 f1			.pastdmark: pop af  
41d2			endm  
# End of macro DMARK
41d2						CALLMONITOR 
41d2 cd d3 13			call break_point_state  
41d5				endm  
# End of macro CALLMONITOR
41d5					endif 
41d5			 
41d5				FORTH_DSP_VALUEHL 
41d5 cd fb 19			call macro_dsp_valuehl 
41d8				endm 
# End of macro FORTH_DSP_VALUEHL
41d8			 
41d8				FORTH_DSP_POP 
41d8 cd 97 1a			call macro_forth_dsp_pop 
41db				endm 
# End of macro FORTH_DSP_POP
41db			 
41db				; calc block address 
41db			 
41db eb				ex de, hl 
41dc 3e 40			ld a, STORE_BLOCK_PHY 
41de cd 92 0b			call Mult16 
41e1			 
41e1			 
41e1 11 e8 f9			ld de, store_page 
41e4			 
41e4					if DEBUG_FORTH_WORDS 
41e4						DMARK "BR1" 
41e4 f5				push af  
41e5 3a f9 41			ld a, (.dmark)  
41e8 32 bd fb			ld (debug_mark),a  
41eb 3a fa 41			ld a, (.dmark+1)  
41ee 32 be fb			ld (debug_mark+1),a  
41f1 3a fb 41			ld a, (.dmark+2)  
41f4 32 bf fb			ld (debug_mark+2),a  
41f7 18 03			jr .pastdmark  
41f9 ..			.dmark: db "BR1"  
41fc f1			.pastdmark: pop af  
41fd			endm  
# End of macro DMARK
41fd						CALLMONITOR 
41fd cd d3 13			call break_point_state  
4200				endm  
# End of macro CALLMONITOR
4200					endif 
4200			 
4200 cd 09 03			call storage_read_block 
4203			 
4203 21 ea f9		        ld hl, store_page+2 
4206					if DEBUG_FORTH_WORDS 
4206						DMARK "BR2" 
4206 f5				push af  
4207 3a 1b 42			ld a, (.dmark)  
420a 32 bd fb			ld (debug_mark),a  
420d 3a 1c 42			ld a, (.dmark+1)  
4210 32 be fb			ld (debug_mark+1),a  
4213 3a 1d 42			ld a, (.dmark+2)  
4216 32 bf fb			ld (debug_mark+2),a  
4219 18 03			jr .pastdmark  
421b ..			.dmark: db "BR2"  
421e f1			.pastdmark: pop af  
421f			endm  
# End of macro DMARK
421f						CALLMONITOR 
421f cd d3 13			call break_point_state  
4222				endm  
# End of macro CALLMONITOR
4222					endif 
4222 cd 72 19			call forth_push_str 
4225			 
4225			 
4225					NEXTW 
4225 c3 51 1b			jp macro_next 
4228				endm 
# End of macro NEXTW
4228			.BWRITE: 
4228				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4228 3a				db WORD_SYS_CORE+38             
4229 bd 42			dw .BUPD            
422b 07				db 6 + 1 
422c .. 00			db "BWRITE",0              
4233				endm 
# End of macro CWHEAD
4233			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
4233			 
4233					if DEBUG_FORTH_WORDS_KEY 
4233						DMARK "BWR" 
4233 f5				push af  
4234 3a 48 42			ld a, (.dmark)  
4237 32 bd fb			ld (debug_mark),a  
423a 3a 49 42			ld a, (.dmark+1)  
423d 32 be fb			ld (debug_mark+1),a  
4240 3a 4a 42			ld a, (.dmark+2)  
4243 32 bf fb			ld (debug_mark+2),a  
4246 18 03			jr .pastdmark  
4248 ..			.dmark: db "BWR"  
424b f1			.pastdmark: pop af  
424c			endm  
# End of macro DMARK
424c						CALLMONITOR 
424c cd d3 13			call break_point_state  
424f				endm  
# End of macro CALLMONITOR
424f					endif 
424f			 
424f				FORTH_DSP_VALUEHL 
424f cd fb 19			call macro_dsp_valuehl 
4252				endm 
# End of macro FORTH_DSP_VALUEHL
4252			 
4252				; calc block address 
4252			 
4252 eb				ex de, hl 
4253 3e 40			ld a, STORE_BLOCK_PHY 
4255 cd 92 0b			call Mult16 
4258			 
4258 e5				push hl         ; address 
4259			 
4259				FORTH_DSP_POP 
4259 cd 97 1a			call macro_forth_dsp_pop 
425c				endm 
# End of macro FORTH_DSP_POP
425c			 
425c				FORTH_DSP_VALUEHL 
425c cd fb 19			call macro_dsp_valuehl 
425f				endm 
# End of macro FORTH_DSP_VALUEHL
425f			 
425f				FORTH_DSP_POP 
425f cd 97 1a			call macro_forth_dsp_pop 
4262				endm 
# End of macro FORTH_DSP_POP
4262			 
4262 cd 0a 0a			call storage_clear_page 
4265			 
4265				; copy string to store page 
4265			 
4265 e5				push hl     ; save string address 
4266			 
4266 3e 00			ld a, 0 
4268 cd 78 10			call strlent 
426b			 
426b 23				inc hl 
426c			 
426c 4d				ld c, l 
426d 06 00			ld b, 0 
426f			 
426f e1				pop hl 
4270 11 ea f9			ld de, store_page + 2 
4273					if DEBUG_FORTH_WORDS 
4273						DMARK "BW1" 
4273 f5				push af  
4274 3a 88 42			ld a, (.dmark)  
4277 32 bd fb			ld (debug_mark),a  
427a 3a 89 42			ld a, (.dmark+1)  
427d 32 be fb			ld (debug_mark+1),a  
4280 3a 8a 42			ld a, (.dmark+2)  
4283 32 bf fb			ld (debug_mark+2),a  
4286 18 03			jr .pastdmark  
4288 ..			.dmark: db "BW1"  
428b f1			.pastdmark: pop af  
428c			endm  
# End of macro DMARK
428c						CALLMONITOR 
428c cd d3 13			call break_point_state  
428f				endm  
# End of macro CALLMONITOR
428f					endif 
428f ed b0			ldir 
4291			 
4291			 
4291				; poke the start of the block with flags to prevent high level file ops hitting the block 
4291			 
4291 21 ff ff			ld hl, $ffff 
4294			 
4294 22 e8 f9			ld (store_page), hl	 
4297				 
4297 e1				pop hl    ; get address 
4298 11 e8 f9			ld de, store_page 
429b			 
429b					if DEBUG_FORTH_WORDS 
429b						DMARK "BW2" 
429b f5				push af  
429c 3a b0 42			ld a, (.dmark)  
429f 32 bd fb			ld (debug_mark),a  
42a2 3a b1 42			ld a, (.dmark+1)  
42a5 32 be fb			ld (debug_mark+1),a  
42a8 3a b2 42			ld a, (.dmark+2)  
42ab 32 bf fb			ld (debug_mark+2),a  
42ae 18 03			jr .pastdmark  
42b0 ..			.dmark: db "BW2"  
42b3 f1			.pastdmark: pop af  
42b4			endm  
# End of macro DMARK
42b4						CALLMONITOR 
42b4 cd d3 13			call break_point_state  
42b7				endm  
# End of macro CALLMONITOR
42b7					endif 
42b7			 
42b7 cd 6e 03			call storage_write_block 
42ba			 
42ba					NEXTW 
42ba c3 51 1b			jp macro_next 
42bd				endm 
# End of macro NEXTW
42bd			 
42bd			.BUPD: 
42bd				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
42bd 3a				db WORD_SYS_CORE+38             
42be 13 43			dw .BYID            
42c0 05				db 4 + 1 
42c1 .. 00			db "BUPD",0              
42c6				endm 
# End of macro CWHEAD
42c6			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
42c6			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
42c6			; | | or completely different file system structure. 
42c6			 
42c6					if DEBUG_FORTH_WORDS_KEY 
42c6						DMARK "BUD" 
42c6 f5				push af  
42c7 3a db 42			ld a, (.dmark)  
42ca 32 bd fb			ld (debug_mark),a  
42cd 3a dc 42			ld a, (.dmark+1)  
42d0 32 be fb			ld (debug_mark+1),a  
42d3 3a dd 42			ld a, (.dmark+2)  
42d6 32 bf fb			ld (debug_mark+2),a  
42d9 18 03			jr .pastdmark  
42db ..			.dmark: db "BUD"  
42de f1			.pastdmark: pop af  
42df			endm  
# End of macro DMARK
42df						CALLMONITOR 
42df cd d3 13			call break_point_state  
42e2				endm  
# End of macro CALLMONITOR
42e2					endif 
42e2			 
42e2				FORTH_DSP_VALUEHL 
42e2 cd fb 19			call macro_dsp_valuehl 
42e5				endm 
# End of macro FORTH_DSP_VALUEHL
42e5			 
42e5				; calc block address 
42e5			 
42e5 eb				ex de, hl 
42e6 3e 40			ld a, STORE_BLOCK_PHY 
42e8 cd 92 0b			call Mult16 
42eb			 
42eb				FORTH_DSP_POP 
42eb cd 97 1a			call macro_forth_dsp_pop 
42ee				endm 
# End of macro FORTH_DSP_POP
42ee			 
42ee			 
42ee 11 e8 f9			ld de, store_page 
42f1			 
42f1					if DEBUG_FORTH_WORDS 
42f1						DMARK "BUe" 
42f1 f5				push af  
42f2 3a 06 43			ld a, (.dmark)  
42f5 32 bd fb			ld (debug_mark),a  
42f8 3a 07 43			ld a, (.dmark+1)  
42fb 32 be fb			ld (debug_mark+1),a  
42fe 3a 08 43			ld a, (.dmark+2)  
4301 32 bf fb			ld (debug_mark+2),a  
4304 18 03			jr .pastdmark  
4306 ..			.dmark: db "BUe"  
4309 f1			.pastdmark: pop af  
430a			endm  
# End of macro DMARK
430a						CALLMONITOR 
430a cd d3 13			call break_point_state  
430d				endm  
# End of macro CALLMONITOR
430d					endif 
430d			 
430d cd 6e 03			call storage_write_block 
4310			 
4310					NEXTW 
4310 c3 51 1b			jp macro_next 
4313				endm 
# End of macro NEXTW
4313			 
4313			.BYID: 
4313				CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4313 3a				db WORD_SYS_CORE+38             
4314 1f 43			dw .BYNAME            
4316 05				db 4 + 1 
4317 .. 00			db "BYID",0              
431c				endm 
# End of macro CWHEAD
431c			; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
431c					NEXTW 
431c c3 51 1b			jp macro_next 
431f				endm 
# End of macro NEXTW
431f			.BYNAME: 
431f				CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
431f 3a				db WORD_SYS_CORE+38             
4320 2d 43			dw .DIR            
4322 07				db 6 + 1 
4323 .. 00			db "BYNAME",0              
432a				endm 
# End of macro CWHEAD
432a			; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
432a					NEXTW 
432a c3 51 1b			jp macro_next 
432d				endm 
# End of macro NEXTW
432d			 
432d			.DIR: 
432d				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
432d 3a				db WORD_SYS_CORE+38             
432e 31 44			dw .SAVE            
4330 04				db 3 + 1 
4331 .. 00			db "DIR",0              
4335				endm 
# End of macro CWHEAD
4335			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4335			 
4335					if DEBUG_FORTH_WORDS_KEY 
4335						DMARK "DIR" 
4335 f5				push af  
4336 3a 4a 43			ld a, (.dmark)  
4339 32 bd fb			ld (debug_mark),a  
433c 3a 4b 43			ld a, (.dmark+1)  
433f 32 be fb			ld (debug_mark+1),a  
4342 3a 4c 43			ld a, (.dmark+2)  
4345 32 bf fb			ld (debug_mark+2),a  
4348 18 03			jr .pastdmark  
434a ..			.dmark: db "DIR"  
434d f1			.pastdmark: pop af  
434e			endm  
# End of macro DMARK
434e						CALLMONITOR 
434e cd d3 13			call break_point_state  
4351				endm  
# End of macro CALLMONITOR
4351					endif 
4351 cd ba 03			call storage_get_block_0 
4354			 
4354 21 e8 f9			ld hl, store_page     ; get current id count 
4357 46				ld b, (hl) 
4358 0e 00			ld c, 0    ; count of files   
435a					if DEBUG_FORTH_WORDS 
435a						DMARK "DI1" 
435a f5				push af  
435b 3a 6f 43			ld a, (.dmark)  
435e 32 bd fb			ld (debug_mark),a  
4361 3a 70 43			ld a, (.dmark+1)  
4364 32 be fb			ld (debug_mark+1),a  
4367 3a 71 43			ld a, (.dmark+2)  
436a 32 bf fb			ld (debug_mark+2),a  
436d 18 03			jr .pastdmark  
436f ..			.dmark: db "DI1"  
4372 f1			.pastdmark: pop af  
4373			endm  
# End of macro DMARK
4373						CALLMONITOR 
4373 cd d3 13			call break_point_state  
4376				endm  
# End of macro CALLMONITOR
4376					endif 
4376			 
4376				; check for empty drive 
4376			 
4376 3e 00			ld a, 0 
4378 b8				cp b 
4379 ca e7 43			jp z, .dirdone 
437c			 
437c				; for each of the current ids do a search for them and if found push to stack 
437c			 
437c c5			.diritem:	push bc 
437d 21 40 00				ld hl, STORE_BLOCK_PHY 
4380 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4382 58					ld e,b 
4383			 
4383			;		if DEBUG_FORTH_WORDS 
4383			;			DMARK "DI2" 
4383			;			CALLMONITOR 
4383			;		endif 
4383			 
4383 cd 1f 06				call storage_findnextid 
4386			 
4386			;		if DEBUG_FORTH_WORDS 
4386			;			DMARK "DI3" 
4386			;			CALLMONITOR 
4386			;		endif 
4386			 
4386					; if found hl will be non zero 
4386			 
4386 cd 38 0c				call ishlzero 
4389			;		ld a, l 
4389			;		add h 
4389			; 
4389			;		cp 0 
4389 28 59				jr z, .dirnotfound 
438b			 
438b					; increase count 
438b			 
438b c1					pop bc	 
438c 0c					inc c 
438d c5					push bc 
438e					 
438e			 
438e					; get file header and push the file name 
438e			 
438e 11 e8 f9				ld de, store_page 
4391 cd 09 03				call storage_read_block 
4394			 
4394					; push file id to stack 
4394				 
4394 3a e8 f9				ld a, (store_page) 
4397 26 00				ld h, 0 
4399 6f					ld l, a 
439a cd 60 19				call forth_push_numhl 
439d			 
439d					; push extent count to stack  
439d				 
439d 3a ea f9				ld a, (store_page+2) 
43a0 26 00				ld h, 0 
43a2 6f					ld l, a 
43a3 cd 60 19				call forth_push_numhl 
43a6			 
43a6					; push file name 
43a6			 
43a6 21 eb f9				ld hl, store_page+3 
43a9					if DEBUG_FORTH_WORDS 
43a9						DMARK "DI5" 
43a9 f5				push af  
43aa 3a be 43			ld a, (.dmark)  
43ad 32 bd fb			ld (debug_mark),a  
43b0 3a bf 43			ld a, (.dmark+1)  
43b3 32 be fb			ld (debug_mark+1),a  
43b6 3a c0 43			ld a, (.dmark+2)  
43b9 32 bf fb			ld (debug_mark+2),a  
43bc 18 03			jr .pastdmark  
43be ..			.dmark: db "DI5"  
43c1 f1			.pastdmark: pop af  
43c2			endm  
# End of macro DMARK
43c2						CALLMONITOR 
43c2 cd d3 13			call break_point_state  
43c5				endm  
# End of macro CALLMONITOR
43c5					endif 
43c5 cd 72 19				call forth_push_str 
43c8					if DEBUG_FORTH_WORDS 
43c8						DMARK "DI6" 
43c8 f5				push af  
43c9 3a dd 43			ld a, (.dmark)  
43cc 32 bd fb			ld (debug_mark),a  
43cf 3a de 43			ld a, (.dmark+1)  
43d2 32 be fb			ld (debug_mark+1),a  
43d5 3a df 43			ld a, (.dmark+2)  
43d8 32 bf fb			ld (debug_mark+2),a  
43db 18 03			jr .pastdmark  
43dd ..			.dmark: db "DI6"  
43e0 f1			.pastdmark: pop af  
43e1			endm  
# End of macro DMARK
43e1						CALLMONITOR 
43e1 cd d3 13			call break_point_state  
43e4				endm  
# End of macro CALLMONITOR
43e4					endif 
43e4			.dirnotfound: 
43e4 c1					pop bc     
43e5 10 95				djnz .diritem 
43e7				 
43e7			.dirdone:	 
43e7					if DEBUG_FORTH_WORDS 
43e7						DMARK "DI7" 
43e7 f5				push af  
43e8 3a fc 43			ld a, (.dmark)  
43eb 32 bd fb			ld (debug_mark),a  
43ee 3a fd 43			ld a, (.dmark+1)  
43f1 32 be fb			ld (debug_mark+1),a  
43f4 3a fe 43			ld a, (.dmark+2)  
43f7 32 bf fb			ld (debug_mark+2),a  
43fa 18 03			jr .pastdmark  
43fc ..			.dmark: db "DI7"  
43ff f1			.pastdmark: pop af  
4400			endm  
# End of macro DMARK
4400						CALLMONITOR 
4400 cd d3 13			call break_point_state  
4403				endm  
# End of macro CALLMONITOR
4403					endif 
4403			 
4403					; push a count of the dir items found 
4403			 
4403 26 00				ld h, 0 
4405 69					ld l, c 
4406 cd 60 19				call forth_push_numhl 
4409			 
4409					; push the bank label 
4409			 
4409 cd ba 03				call storage_get_block_0 
440c			 
440c				 
440c 21 eb f9		 		ld hl, store_page+3 
440f			 
440f					if DEBUG_FORTH_WORDS 
440f						DMARK "DI8" 
440f f5				push af  
4410 3a 24 44			ld a, (.dmark)  
4413 32 bd fb			ld (debug_mark),a  
4416 3a 25 44			ld a, (.dmark+1)  
4419 32 be fb			ld (debug_mark+1),a  
441c 3a 26 44			ld a, (.dmark+2)  
441f 32 bf fb			ld (debug_mark+2),a  
4422 18 03			jr .pastdmark  
4424 ..			.dmark: db "DI8"  
4427 f1			.pastdmark: pop af  
4428			endm  
# End of macro DMARK
4428						CALLMONITOR 
4428 cd d3 13			call break_point_state  
442b				endm  
# End of macro CALLMONITOR
442b					endif 
442b cd 72 19				call forth_push_str 
442e			 
442e			 
442e				 
442e					NEXTW 
442e c3 51 1b			jp macro_next 
4431				endm 
# End of macro NEXTW
4431			.SAVE: 
4431				CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4431 3b				db WORD_SYS_CORE+39             
4432 3d 44			dw .LOAD            
4434 05				db 4 + 1 
4435 .. 00			db "SAVE",0              
443a				endm 
# End of macro CWHEAD
443a			; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
443a					NEXTW 
443a c3 51 1b			jp macro_next 
443d				endm 
# End of macro NEXTW
443d			.LOAD: 
443d				CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
443d 3c				db WORD_SYS_CORE+40             
443e 9f 45			dw .BSAVE            
4440 05				db 4 + 1 
4441 .. 00			db "LOAD",0              
4446				endm 
# End of macro CWHEAD
4446			; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
4446			; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
4446			; | | The LOAD command can not be used in any user words or compound lines. 
4446			 
4446					; store_openext use it. If zero it is EOF 
4446			 
4446					; read block from current stream id 
4446					; if the block does not contain zero term keep reading blocks until zero found 
4446					; push the block to stack 
4446					; save the block id to stream 
4446			 
4446			 
4446					FORTH_DSP_VALUEHL 
4446 cd fb 19			call macro_dsp_valuehl 
4449				endm 
# End of macro FORTH_DSP_VALUEHL
4449			 
4449			;		push hl 
4449			 
4449				if DEBUG_STORESE 
4449					DMARK "LOA" 
4449 f5				push af  
444a 3a 5e 44			ld a, (.dmark)  
444d 32 bd fb			ld (debug_mark),a  
4450 3a 5f 44			ld a, (.dmark+1)  
4453 32 be fb			ld (debug_mark+1),a  
4456 3a 60 44			ld a, (.dmark+2)  
4459 32 bf fb			ld (debug_mark+2),a  
445c 18 03			jr .pastdmark  
445e ..			.dmark: db "LOA"  
4461 f1			.pastdmark: pop af  
4462			endm  
# End of macro DMARK
4462					CALLMONITOR 
4462 cd d3 13			call break_point_state  
4465				endm  
# End of macro CALLMONITOR
4465				endif 
4465					FORTH_DSP_POP 
4465 cd 97 1a			call macro_forth_dsp_pop 
4468				endm 
# End of macro FORTH_DSP_POP
4468			 
4468			;		pop hl 
4468			 
4468 65					ld h, l 
4469 2e 00				ld l, 0 
446b			 
446b e5					push hl     ; stack holds current file id and extent to work with 
446c			 
446c			 
446c 11 e8 f9				ld de, store_page      ; get block zero of file 
446f				if DEBUG_STORESE 
446f					DMARK "LO0" 
446f f5				push af  
4470 3a 84 44			ld a, (.dmark)  
4473 32 bd fb			ld (debug_mark),a  
4476 3a 85 44			ld a, (.dmark+1)  
4479 32 be fb			ld (debug_mark+1),a  
447c 3a 86 44			ld a, (.dmark+2)  
447f 32 bf fb			ld (debug_mark+2),a  
4482 18 03			jr .pastdmark  
4484 ..			.dmark: db "LO0"  
4487 f1			.pastdmark: pop af  
4488			endm  
# End of macro DMARK
4488					CALLMONITOR 
4488 cd d3 13			call break_point_state  
448b				endm  
# End of macro CALLMONITOR
448b				endif 
448b cd 43 08				call storage_read 
448e			 
448e 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4491 32 de f9				ld  (store_openmaxext),a   ; get our limit 
4494			 
4494				if DEBUG_STORESE 
4494					DMARK "LOE" 
4494 f5				push af  
4495 3a a9 44			ld a, (.dmark)  
4498 32 bd fb			ld (debug_mark),a  
449b 3a aa 44			ld a, (.dmark+1)  
449e 32 be fb			ld (debug_mark+1),a  
44a1 3a ab 44			ld a, (.dmark+2)  
44a4 32 bf fb			ld (debug_mark+2),a  
44a7 18 03			jr .pastdmark  
44a9 ..			.dmark: db "LOE"  
44ac f1			.pastdmark: pop af  
44ad			endm  
# End of macro DMARK
44ad					CALLMONITOR 
44ad cd d3 13			call break_point_state  
44b0				endm  
# End of macro CALLMONITOR
44b0				endif 
44b0			 
44b0			; TODO dont know why max extents are not present 
44b0			;		cp 0 
44b0			;		jp z, .loadeof     ; dont read past eof 
44b0			 
44b0			;		ld a, 1   ; start from the head of the file 
44b0			 
44b0 e1			.loadline:	pop hl 
44b1 23					inc hl 
44b2 3a de f9				ld  a, (store_openmaxext)   ; get our limit 
44b5				if DEBUG_STORESE 
44b5					DMARK "LOx" 
44b5 f5				push af  
44b6 3a ca 44			ld a, (.dmark)  
44b9 32 bd fb			ld (debug_mark),a  
44bc 3a cb 44			ld a, (.dmark+1)  
44bf 32 be fb			ld (debug_mark+1),a  
44c2 3a cc 44			ld a, (.dmark+2)  
44c5 32 bf fb			ld (debug_mark+2),a  
44c8 18 03			jr .pastdmark  
44ca ..			.dmark: db "LOx"  
44cd f1			.pastdmark: pop af  
44ce			endm  
# End of macro DMARK
44ce					CALLMONITOR 
44ce cd d3 13			call break_point_state  
44d1				endm  
# End of macro CALLMONITOR
44d1				endif 
44d1 3c					inc a 
44d2 bd					cp l 
44d3 ca 7d 45				jp z, .loadeof 
44d6 e5					push hl    ; save current extent 
44d7			 
44d7 11 e8 f9				ld de, store_page 
44da			 
44da				if DEBUG_STORESE 
44da					DMARK "LO1" 
44da f5				push af  
44db 3a ef 44			ld a, (.dmark)  
44de 32 bd fb			ld (debug_mark),a  
44e1 3a f0 44			ld a, (.dmark+1)  
44e4 32 be fb			ld (debug_mark+1),a  
44e7 3a f1 44			ld a, (.dmark+2)  
44ea 32 bf fb			ld (debug_mark+2),a  
44ed 18 03			jr .pastdmark  
44ef ..			.dmark: db "LO1"  
44f2 f1			.pastdmark: pop af  
44f3			endm  
# End of macro DMARK
44f3					CALLMONITOR 
44f3 cd d3 13			call break_point_state  
44f6				endm  
# End of macro CALLMONITOR
44f6				endif 
44f6 cd 43 08				call storage_read 
44f9			 
44f9				if DEBUG_STORESE 
44f9					DMARK "LO2" 
44f9 f5				push af  
44fa 3a 0e 45			ld a, (.dmark)  
44fd 32 bd fb			ld (debug_mark),a  
4500 3a 0f 45			ld a, (.dmark+1)  
4503 32 be fb			ld (debug_mark+1),a  
4506 3a 10 45			ld a, (.dmark+2)  
4509 32 bf fb			ld (debug_mark+2),a  
450c 18 03			jr .pastdmark  
450e ..			.dmark: db "LO2"  
4511 f1			.pastdmark: pop af  
4512			endm  
# End of macro DMARK
4512					CALLMONITOR 
4512 cd d3 13			call break_point_state  
4515				endm  
# End of macro CALLMONITOR
4515				endif 
4515 cd 38 0c			call ishlzero 
4518			;	ld a, l 
4518			;	add h 
4518			;	cp 0 
4518 28 63			jr z, .loadeof 
451a			 
451a				; not eof so hl should point to data to exec 
451a			 
451a				; will need to add the FORTH_END_BUFFER flag 
451a			  
451a 21 ea f9			ld hl, store_page+2 
451d 01 ff 00			ld bc, 255 
4520 3e 00			ld a, 0 
4522 ed b1			cpir 
4524				if DEBUG_STORESE 
4524					DMARK "LOt" 
4524 f5				push af  
4525 3a 39 45			ld a, (.dmark)  
4528 32 bd fb			ld (debug_mark),a  
452b 3a 3a 45			ld a, (.dmark+1)  
452e 32 be fb			ld (debug_mark+1),a  
4531 3a 3b 45			ld a, (.dmark+2)  
4534 32 bf fb			ld (debug_mark+2),a  
4537 18 03			jr .pastdmark  
4539 ..			.dmark: db "LOt"  
453c f1			.pastdmark: pop af  
453d			endm  
# End of macro DMARK
453d					CALLMONITOR 
453d cd d3 13			call break_point_state  
4540				endm  
# End of macro CALLMONITOR
4540				endif 
4540 2b				dec hl 
4541 3e 20			ld a, ' ' 
4543 77				ld (hl), a 
4544 23				inc hl 
4545 77				ld (hl), a 
4546 23				inc hl 
4547 77				ld (hl), a 
4548 23				inc hl 
4549 3e 7f			ld a, FORTH_END_BUFFER 
454b 77				ld (hl), a 
454c			 
454c				; TODO handle more than a single block read 
454c			 
454c			 
454c 21 ea f9			ld hl, store_page+2 
454f			 
454f 22 b9 f2			ld (os_tok_ptr), hl 
4552			 
4552				if DEBUG_STORESE 
4552					DMARK "LO3" 
4552 f5				push af  
4553 3a 67 45			ld a, (.dmark)  
4556 32 bd fb			ld (debug_mark),a  
4559 3a 68 45			ld a, (.dmark+1)  
455c 32 be fb			ld (debug_mark+1),a  
455f 3a 69 45			ld a, (.dmark+2)  
4562 32 bf fb			ld (debug_mark+2),a  
4565 18 03			jr .pastdmark  
4567 ..			.dmark: db "LO3"  
456a f1			.pastdmark: pop af  
456b			endm  
# End of macro DMARK
456b					CALLMONITOR 
456b cd d3 13			call break_point_state  
456e				endm  
# End of macro CALLMONITOR
456e				endif 
456e			 
456e cd 9f 1b			call forthparse 
4571 cd df 1b			call forthexec 
4574 cd f6 1a			call forthexec_cleanup 
4577			 
4577				; go to next extent 
4577			 
4577				; get next block  or mark as eof 
4577 c3 b0 44			jp .loadline 
457a			 
457a			 
457a			 
457a				       NEXTW 
457a c3 51 1b			jp macro_next 
457d				endm 
# End of macro NEXTW
457d 3e 00		.loadeof:	ld a, 0 
457f 32 df f9				ld (store_openext), a 
4582			 
4582				if DEBUG_STORESE 
4582					DMARK "LOF" 
4582 f5				push af  
4583 3a 97 45			ld a, (.dmark)  
4586 32 bd fb			ld (debug_mark),a  
4589 3a 98 45			ld a, (.dmark+1)  
458c 32 be fb			ld (debug_mark+1),a  
458f 3a 99 45			ld a, (.dmark+2)  
4592 32 bf fb			ld (debug_mark+2),a  
4595 18 03			jr .pastdmark  
4597 ..			.dmark: db "LOF"  
459a f1			.pastdmark: pop af  
459b			endm  
# End of macro DMARK
459b					CALLMONITOR 
459b cd d3 13			call break_point_state  
459e				endm  
# End of macro CALLMONITOR
459e				endif 
459e c9					ret 
459f					;NEXTW 
459f			.BSAVE:   
459f			 
459f				CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
459f 5a				db WORD_SYS_CORE+70             
45a0 ac 45			dw .BLOAD            
45a2 06				db 5 + 1 
45a3 .. 00			db "BSAVE",0              
45a9				endm 
# End of macro CWHEAD
45a9			; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
45a9					NEXTW 
45a9 c3 51 1b			jp macro_next 
45ac				endm 
# End of macro NEXTW
45ac			.BLOAD: 
45ac				CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
45ac 5b				db WORD_SYS_CORE+71             
45ad b9 45			dw .SEO            
45af 06				db 5 + 1 
45b0 .. 00			db "BLOAD",0              
45b6				endm 
# End of macro CWHEAD
45b6			; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
45b6					NEXTW 
45b6 c3 51 1b			jp macro_next 
45b9				endm 
# End of macro NEXTW
45b9			;;;; counter gap 
45b9			 
45b9			 
45b9			.SEO: 
45b9				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
45b9 64				db WORD_SYS_CORE+80             
45ba d8 45			dw .SEI            
45bc 04				db 3 + 1 
45bd .. 00			db "SEO",0              
45c1				endm 
# End of macro CWHEAD
45c1			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
45c1			 
45c1					; get port 
45c1			 
45c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45c1 cd fb 19			call macro_dsp_valuehl 
45c4				endm 
# End of macro FORTH_DSP_VALUEHL
45c4			 
45c4 e5					push hl    ; u2 - byte 
45c5			 
45c5					; destroy value TOS 
45c5			 
45c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45c5 cd 97 1a			call macro_forth_dsp_pop 
45c8				endm 
# End of macro FORTH_DSP_POP
45c8			 
45c8					; get byte to send 
45c8			 
45c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45c8 cd fb 19			call macro_dsp_valuehl 
45cb				endm 
# End of macro FORTH_DSP_VALUEHL
45cb			 
45cb e5					push hl    ; u1 - addr 
45cc			 
45cc					; destroy value TOS 
45cc			 
45cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45cc cd 97 1a			call macro_forth_dsp_pop 
45cf				endm 
# End of macro FORTH_DSP_POP
45cf			 
45cf					; one value on hl get other one back 
45cf			 
45cf d1					pop de   ; u1 - byte 
45d0			 
45d0 e1					pop hl   ; u2 - addr 
45d1			 
45d1					; TODO Send SPI byte 
45d1			 
45d1			 
45d1 7b					ld a, e 
45d2 cd e7 01				call se_writebyte 
45d5			 
45d5					 
45d5			 
45d5					NEXTW 
45d5 c3 51 1b			jp macro_next 
45d8				endm 
# End of macro NEXTW
45d8			 
45d8			.SEI: 
45d8				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
45d8 65				db WORD_SYS_CORE+81             
45d9 f2 45			dw .SFREE            
45db 04				db 3 + 1 
45dc .. 00			db "SEI",0              
45e0				endm 
# End of macro CWHEAD
45e0			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
45e0			 
45e0					; get port 
45e0			 
45e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45e0 cd fb 19			call macro_dsp_valuehl 
45e3				endm 
# End of macro FORTH_DSP_VALUEHL
45e3			 
45e3			;		push hl 
45e3			 
45e3					; destroy value TOS 
45e3			 
45e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45e3 cd 97 1a			call macro_forth_dsp_pop 
45e6				endm 
# End of macro FORTH_DSP_POP
45e6			 
45e6					; one value on hl get other one back 
45e6			 
45e6			;		pop hl 
45e6			 
45e6			 
45e6					; TODO Get SPI byte 
45e6			 
45e6 cd 89 02				call se_readbyte 
45e9			 
45e9 26 00				ld h, 0 
45eb 6f					ld l, a 
45ec cd 60 19				call forth_push_numhl 
45ef			 
45ef					NEXTW 
45ef c3 51 1b			jp macro_next 
45f2				endm 
# End of macro NEXTW
45f2			 
45f2			.SFREE: 
45f2				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
45f2 67				db WORD_SYS_CORE+83             
45f3 21 46			dw .SIZE            
45f5 06				db 5 + 1 
45f6 .. 00			db "FFREE",0              
45fc				endm 
# End of macro CWHEAD
45fc			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
45fc					if DEBUG_FORTH_WORDS_KEY 
45fc						DMARK "FFR" 
45fc f5				push af  
45fd 3a 11 46			ld a, (.dmark)  
4600 32 bd fb			ld (debug_mark),a  
4603 3a 12 46			ld a, (.dmark+1)  
4606 32 be fb			ld (debug_mark+1),a  
4609 3a 13 46			ld a, (.dmark+2)  
460c 32 bf fb			ld (debug_mark+2),a  
460f 18 03			jr .pastdmark  
4611 ..			.dmark: db "FFR"  
4614 f1			.pastdmark: pop af  
4615			endm  
# End of macro DMARK
4615						CALLMONITOR 
4615 cd d3 13			call break_point_state  
4618				endm  
# End of macro CALLMONITOR
4618					endif 
4618			 
4618 cd b9 06				call storage_freeblocks 
461b			 
461b cd 60 19				call forth_push_numhl 
461e			 
461e				       NEXTW 
461e c3 51 1b			jp macro_next 
4621				endm 
# End of macro NEXTW
4621			.SIZE: 
4621				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4621 67				db WORD_SYS_CORE+83             
4622 55 46			dw .CREATE            
4624 05				db 4 + 1 
4625 .. 00			db "SIZE",0              
462a				endm 
# End of macro CWHEAD
462a			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
462a					if DEBUG_FORTH_WORDS_KEY 
462a						DMARK "SIZ" 
462a f5				push af  
462b 3a 3f 46			ld a, (.dmark)  
462e 32 bd fb			ld (debug_mark),a  
4631 3a 40 46			ld a, (.dmark+1)  
4634 32 be fb			ld (debug_mark+1),a  
4637 3a 41 46			ld a, (.dmark+2)  
463a 32 bf fb			ld (debug_mark+2),a  
463d 18 03			jr .pastdmark  
463f ..			.dmark: db "SIZ"  
4642 f1			.pastdmark: pop af  
4643			endm  
# End of macro DMARK
4643						CALLMONITOR 
4643 cd d3 13			call break_point_state  
4646				endm  
# End of macro CALLMONITOR
4646					endif 
4646			 
4646					FORTH_DSP_VALUEHL 
4646 cd fb 19			call macro_dsp_valuehl 
4649				endm 
# End of macro FORTH_DSP_VALUEHL
4649			;		push hl 
4649					FORTH_DSP_POP 
4649 cd 97 1a			call macro_forth_dsp_pop 
464c				endm 
# End of macro FORTH_DSP_POP
464c			;		pop hl 
464c cd 38 03				call storage_file_size 
464f			 
464f cd 60 19				call forth_push_numhl 
4652			  
4652			 
4652				       NEXTW 
4652 c3 51 1b			jp macro_next 
4655				endm 
# End of macro NEXTW
4655			 
4655			.CREATE: 
4655				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4655 68				db WORD_SYS_CORE+84             
4656 c3 46			dw .APPEND            
4658 07				db 6 + 1 
4659 .. 00			db "CREATE",0              
4660				endm 
# End of macro CWHEAD
4660			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | TO TEST 
4660			; | | e.g.  
4660			; | | TestProgram CREATE 
4660			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4660			; | |  
4660			; | | Max file IDs are 255. 
4660			; | |  
4660					 
4660					if DEBUG_FORTH_WORDS_KEY 
4660						DMARK "CRT" 
4660 f5				push af  
4661 3a 75 46			ld a, (.dmark)  
4664 32 bd fb			ld (debug_mark),a  
4667 3a 76 46			ld a, (.dmark+1)  
466a 32 be fb			ld (debug_mark+1),a  
466d 3a 77 46			ld a, (.dmark+2)  
4670 32 bf fb			ld (debug_mark+2),a  
4673 18 03			jr .pastdmark  
4675 ..			.dmark: db "CRT"  
4678 f1			.pastdmark: pop af  
4679			endm  
# End of macro DMARK
4679						CALLMONITOR 
4679 cd d3 13			call break_point_state  
467c				endm  
# End of macro CALLMONITOR
467c					endif 
467c			;		call storage_get_block_0 
467c			 
467c					; TODO pop hl 
467c			 
467c					;v5 FORTH_DSP_VALUE 
467c					FORTH_DSP_VALUE 
467c cd e4 19			call macro_forth_dsp_value 
467f				endm 
# End of macro FORTH_DSP_VALUE
467f			 
467f				if DEBUG_STORESE 
467f					DMARK "CR1" 
467f f5				push af  
4680 3a 94 46			ld a, (.dmark)  
4683 32 bd fb			ld (debug_mark),a  
4686 3a 95 46			ld a, (.dmark+1)  
4689 32 be fb			ld (debug_mark+1),a  
468c 3a 96 46			ld a, (.dmark+2)  
468f 32 bf fb			ld (debug_mark+2),a  
4692 18 03			jr .pastdmark  
4694 ..			.dmark: db "CR1"  
4697 f1			.pastdmark: pop af  
4698			endm  
# End of macro DMARK
4698					CALLMONITOR 
4698 cd d3 13			call break_point_state  
469b				endm  
# End of macro CALLMONITOR
469b				endif 
469b			;		push hl 
469b			;		FORTH_DSP_POP 
469b			;		pop hl 
469b			 
469b			;		inc hl   ; move past the type marker 
469b			 
469b cd ef 06				call storage_create 
469e			 
469e				if DEBUG_STORESE 
469e					DMARK "CT1" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 bd fb			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 be fb			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 bf fb			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "CT1"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7					CALLMONITOR 
46b7 cd d3 13			call break_point_state  
46ba				endm  
# End of macro CALLMONITOR
46ba				endif 
46ba			;		push hl 
46ba					FORTH_DSP_POP 
46ba cd 97 1a			call macro_forth_dsp_pop 
46bd				endm 
# End of macro FORTH_DSP_POP
46bd			;		pop hl 
46bd					; push file id to stack 
46bd cd 60 19				call forth_push_numhl 
46c0			 
46c0			 
46c0			 
46c0				       NEXTW 
46c0 c3 51 1b			jp macro_next 
46c3				endm 
# End of macro NEXTW
46c3			 
46c3			.APPEND: 
46c3				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
46c3 69				db WORD_SYS_CORE+85             
46c4 54 47			dw .SDEL            
46c6 07				db 6 + 1 
46c7 .. 00			db "APPEND",0              
46ce				endm 
# End of macro CWHEAD
46ce			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | TO TEST 
46ce			; | | e.g. 
46ce			; | | Test CREATE      -> $01 
46ce			; | | "A string to add to file" $01 APPEND 
46ce			; | |  
46ce			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
46ce					if DEBUG_FORTH_WORDS_KEY 
46ce						DMARK "APP" 
46ce f5				push af  
46cf 3a e3 46			ld a, (.dmark)  
46d2 32 bd fb			ld (debug_mark),a  
46d5 3a e4 46			ld a, (.dmark+1)  
46d8 32 be fb			ld (debug_mark+1),a  
46db 3a e5 46			ld a, (.dmark+2)  
46de 32 bf fb			ld (debug_mark+2),a  
46e1 18 03			jr .pastdmark  
46e3 ..			.dmark: db "APP"  
46e6 f1			.pastdmark: pop af  
46e7			endm  
# End of macro DMARK
46e7						CALLMONITOR 
46e7 cd d3 13			call break_point_state  
46ea				endm  
# End of macro CALLMONITOR
46ea					endif 
46ea			 
46ea					FORTH_DSP_VALUEHL 
46ea cd fb 19			call macro_dsp_valuehl 
46ed				endm 
# End of macro FORTH_DSP_VALUEHL
46ed e5					push hl 	; save file id 
46ee			 
46ee				if DEBUG_STORESE 
46ee					DMARK "AP1" 
46ee f5				push af  
46ef 3a 03 47			ld a, (.dmark)  
46f2 32 bd fb			ld (debug_mark),a  
46f5 3a 04 47			ld a, (.dmark+1)  
46f8 32 be fb			ld (debug_mark+1),a  
46fb 3a 05 47			ld a, (.dmark+2)  
46fe 32 bf fb			ld (debug_mark+2),a  
4701 18 03			jr .pastdmark  
4703 ..			.dmark: db "AP1"  
4706 f1			.pastdmark: pop af  
4707			endm  
# End of macro DMARK
4707					CALLMONITOR 
4707 cd d3 13			call break_point_state  
470a				endm  
# End of macro CALLMONITOR
470a				endif 
470a					FORTH_DSP_POP 
470a cd 97 1a			call macro_forth_dsp_pop 
470d				endm 
# End of macro FORTH_DSP_POP
470d			 
470d					FORTH_DSP_VALUEHL 
470d cd fb 19			call macro_dsp_valuehl 
4710				endm 
# End of macro FORTH_DSP_VALUEHL
4710					;v5 FORTH_DSP_VALUE 
4710 e5					push hl 	; save ptr to string to save 
4711			 
4711				if DEBUG_STORESE 
4711					DMARK "AP1" 
4711 f5				push af  
4712 3a 26 47			ld a, (.dmark)  
4715 32 bd fb			ld (debug_mark),a  
4718 3a 27 47			ld a, (.dmark+1)  
471b 32 be fb			ld (debug_mark+1),a  
471e 3a 28 47			ld a, (.dmark+2)  
4721 32 bf fb			ld (debug_mark+2),a  
4724 18 03			jr .pastdmark  
4726 ..			.dmark: db "AP1"  
4729 f1			.pastdmark: pop af  
472a			endm  
# End of macro DMARK
472a					CALLMONITOR 
472a cd d3 13			call break_point_state  
472d				endm  
# End of macro CALLMONITOR
472d				endif 
472d					FORTH_DSP_POP 
472d cd 97 1a			call macro_forth_dsp_pop 
4730				endm 
# End of macro FORTH_DSP_POP
4730			 
4730 d1					pop de 
4731 e1					pop hl 
4732				if DEBUG_STORESE 
4732					DMARK "AP2" 
4732 f5				push af  
4733 3a 47 47			ld a, (.dmark)  
4736 32 bd fb			ld (debug_mark),a  
4739 3a 48 47			ld a, (.dmark+1)  
473c 32 be fb			ld (debug_mark+1),a  
473f 3a 49 47			ld a, (.dmark+2)  
4742 32 bf fb			ld (debug_mark+2),a  
4745 18 03			jr .pastdmark  
4747 ..			.dmark: db "AP2"  
474a f1			.pastdmark: pop af  
474b			endm  
# End of macro DMARK
474b					CALLMONITOR 
474b cd d3 13			call break_point_state  
474e				endm  
# End of macro CALLMONITOR
474e				endif 
474e					;inc de ; skip var type indicator 
474e			 
474e					; TODO how to append numerics???? 
474e			 
474e cd c9 08				call storage_append		 
4751			 
4751				       NEXTW 
4751 c3 51 1b			jp macro_next 
4754				endm 
# End of macro NEXTW
4754			.SDEL: 
4754				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4754 6a				db WORD_SYS_CORE+86             
4755 a0 47			dw .OPEN            
4757 05				db 4 + 1 
4758 .. 00			db "ERA",0              
475c				endm 
# End of macro CWHEAD
475c			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
475c					FORTH_DSP_VALUEHL 
475c cd fb 19			call macro_dsp_valuehl 
475f				endm 
# End of macro FORTH_DSP_VALUEHL
475f			;		push hl 	; save file id 
475f			 
475f					if DEBUG_FORTH_WORDS_KEY 
475f						DMARK "ERA" 
475f f5				push af  
4760 3a 74 47			ld a, (.dmark)  
4763 32 bd fb			ld (debug_mark),a  
4766 3a 75 47			ld a, (.dmark+1)  
4769 32 be fb			ld (debug_mark+1),a  
476c 3a 76 47			ld a, (.dmark+2)  
476f 32 bf fb			ld (debug_mark+2),a  
4772 18 03			jr .pastdmark  
4774 ..			.dmark: db "ERA"  
4777 f1			.pastdmark: pop af  
4778			endm  
# End of macro DMARK
4778						CALLMONITOR 
4778 cd d3 13			call break_point_state  
477b				endm  
# End of macro CALLMONITOR
477b					endif 
477b				if DEBUG_STORESE 
477b					DMARK "ER1" 
477b f5				push af  
477c 3a 90 47			ld a, (.dmark)  
477f 32 bd fb			ld (debug_mark),a  
4782 3a 91 47			ld a, (.dmark+1)  
4785 32 be fb			ld (debug_mark+1),a  
4788 3a 92 47			ld a, (.dmark+2)  
478b 32 bf fb			ld (debug_mark+2),a  
478e 18 03			jr .pastdmark  
4790 ..			.dmark: db "ER1"  
4793 f1			.pastdmark: pop af  
4794			endm  
# End of macro DMARK
4794					CALLMONITOR 
4794 cd d3 13			call break_point_state  
4797				endm  
# End of macro CALLMONITOR
4797				endif 
4797					FORTH_DSP_POP 
4797 cd 97 1a			call macro_forth_dsp_pop 
479a				endm 
# End of macro FORTH_DSP_POP
479a			 
479a			;		pop hl 
479a			 
479a cd 3e 05				call storage_erase 
479d				       NEXTW 
479d c3 51 1b			jp macro_next 
47a0				endm 
# End of macro NEXTW
47a0			 
47a0			.OPEN: 
47a0				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
47a0 6b				db WORD_SYS_CORE+87             
47a1 27 48			dw .READ            
47a3 05				db 4 + 1 
47a4 .. 00			db "OPEN",0              
47a9				endm 
# End of macro CWHEAD
47a9			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
47a9			; | | e.g. 
47a9			; | | $01 OPEN $01 DO $01 READ . LOOP 
47a9			 
47a9					if DEBUG_FORTH_WORDS_KEY 
47a9						DMARK "OPN" 
47a9 f5				push af  
47aa 3a be 47			ld a, (.dmark)  
47ad 32 bd fb			ld (debug_mark),a  
47b0 3a bf 47			ld a, (.dmark+1)  
47b3 32 be fb			ld (debug_mark+1),a  
47b6 3a c0 47			ld a, (.dmark+2)  
47b9 32 bf fb			ld (debug_mark+2),a  
47bc 18 03			jr .pastdmark  
47be ..			.dmark: db "OPN"  
47c1 f1			.pastdmark: pop af  
47c2			endm  
# End of macro DMARK
47c2						CALLMONITOR 
47c2 cd d3 13			call break_point_state  
47c5				endm  
# End of macro CALLMONITOR
47c5					endif 
47c5					; TODO handle multiple file opens 
47c5			 
47c5 3e 01			       	ld a, 1 
47c7 32 df f9				ld (store_openext), a 
47ca			 
47ca					; get max extents for this file 
47ca				 
47ca								 
47ca					FORTH_DSP_VALUEHL 
47ca cd fb 19			call macro_dsp_valuehl 
47cd				endm 
# End of macro FORTH_DSP_VALUEHL
47cd			 
47cd 65					ld h, l 
47ce 2e 00				ld l, 0 
47d0			 
47d0				if DEBUG_STORESE 
47d0					DMARK "OPN" 
47d0 f5				push af  
47d1 3a e5 47			ld a, (.dmark)  
47d4 32 bd fb			ld (debug_mark),a  
47d7 3a e6 47			ld a, (.dmark+1)  
47da 32 be fb			ld (debug_mark+1),a  
47dd 3a e7 47			ld a, (.dmark+2)  
47e0 32 bf fb			ld (debug_mark+2),a  
47e3 18 03			jr .pastdmark  
47e5 ..			.dmark: db "OPN"  
47e8 f1			.pastdmark: pop af  
47e9			endm  
# End of macro DMARK
47e9					CALLMONITOR 
47e9 cd d3 13			call break_point_state  
47ec				endm  
# End of macro CALLMONITOR
47ec				endif 
47ec			;		push hl 
47ec					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
47ec cd 97 1a			call macro_forth_dsp_pop 
47ef				endm 
# End of macro FORTH_DSP_POP
47ef			;		pop hl 
47ef						 
47ef 11 e8 f9				ld de, store_page      ; get block zero of file 
47f2 cd 43 08				call storage_read 
47f5			 
47f5			 
47f5 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
47f8 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
47fb					 
47fb				if DEBUG_STORESE 
47fb					DMARK "OPx" 
47fb f5				push af  
47fc 3a 10 48			ld a, (.dmark)  
47ff 32 bd fb			ld (debug_mark),a  
4802 3a 11 48			ld a, (.dmark+1)  
4805 32 be fb			ld (debug_mark+1),a  
4808 3a 12 48			ld a, (.dmark+2)  
480b 32 bf fb			ld (debug_mark+2),a  
480e 18 03			jr .pastdmark  
4810 ..			.dmark: db "OPx"  
4813 f1			.pastdmark: pop af  
4814			endm  
# End of macro DMARK
4814					CALLMONITOR 
4814 cd d3 13			call break_point_state  
4817				endm  
# End of macro CALLMONITOR
4817				endif 
4817 fe 00				cp 0 
4819 20 03				jr nz, .skipopeneof 
481b					; have opened an empty file 
481b					 
481b 32 df f9				ld (store_openext), a 
481e			 
481e			.skipopeneof: 
481e			 
481e 6f					ld l, a 
481f 26 00				ld h, 0 
4821 cd 60 19				call forth_push_numhl 
4824			 
4824			 
4824				       NEXTW 
4824 c3 51 1b			jp macro_next 
4827				endm 
# End of macro NEXTW
4827			.READ: 
4827				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4827 6c				db WORD_SYS_CORE+88             
4828 6e 49			dw .EOF            
482a 05				db 4 + 1 
482b .. 00			db "READ",0              
4830				endm 
# End of macro CWHEAD
4830			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4830			; | | e.g. 
4830			; | | $01 OPEN $01 DO $01 READ . LOOP 
4830			 
4830					if DEBUG_FORTH_WORDS_KEY 
4830						DMARK "REA" 
4830 f5				push af  
4831 3a 45 48			ld a, (.dmark)  
4834 32 bd fb			ld (debug_mark),a  
4837 3a 46 48			ld a, (.dmark+1)  
483a 32 be fb			ld (debug_mark+1),a  
483d 3a 47 48			ld a, (.dmark+2)  
4840 32 bf fb			ld (debug_mark+2),a  
4843 18 03			jr .pastdmark  
4845 ..			.dmark: db "REA"  
4848 f1			.pastdmark: pop af  
4849			endm  
# End of macro DMARK
4849						CALLMONITOR 
4849 cd d3 13			call break_point_state  
484c				endm  
# End of macro CALLMONITOR
484c					endif 
484c					; store_openext use it. If zero it is EOF 
484c			 
484c					; read block from current stream id 
484c					; if the block does not contain zero term keep reading blocks until zero found 
484c					; push the block to stack 
484c					; save the block id to stream 
484c			 
484c			 
484c					FORTH_DSP_VALUEHL 
484c cd fb 19			call macro_dsp_valuehl 
484f				endm 
# End of macro FORTH_DSP_VALUEHL
484f			 
484f			;		push hl 
484f			 
484f				if DEBUG_STORESE 
484f					DMARK "REA" 
484f f5				push af  
4850 3a 64 48			ld a, (.dmark)  
4853 32 bd fb			ld (debug_mark),a  
4856 3a 65 48			ld a, (.dmark+1)  
4859 32 be fb			ld (debug_mark+1),a  
485c 3a 66 48			ld a, (.dmark+2)  
485f 32 bf fb			ld (debug_mark+2),a  
4862 18 03			jr .pastdmark  
4864 ..			.dmark: db "REA"  
4867 f1			.pastdmark: pop af  
4868			endm  
# End of macro DMARK
4868					CALLMONITOR 
4868 cd d3 13			call break_point_state  
486b				endm  
# End of macro CALLMONITOR
486b				endif 
486b					FORTH_DSP_POP 
486b cd 97 1a			call macro_forth_dsp_pop 
486e				endm 
# End of macro FORTH_DSP_POP
486e			 
486e			;		pop hl 
486e				 
486e 65					ld h,l 
486f			 
486f 3a df f9				ld a, (store_openext) 
4872 6f					ld l, a 
4873					 
4873 fe 00				cp 0 
4875 ca 40 49				jp z, .ateof     ; dont read past eof 
4878			 
4878			 
4878 11 e8 f9				ld de, store_page 
487b				if DEBUG_STORESE 
487b					DMARK "RE1" 
487b f5				push af  
487c 3a 90 48			ld a, (.dmark)  
487f 32 bd fb			ld (debug_mark),a  
4882 3a 91 48			ld a, (.dmark+1)  
4885 32 be fb			ld (debug_mark+1),a  
4888 3a 92 48			ld a, (.dmark+2)  
488b 32 bf fb			ld (debug_mark+2),a  
488e 18 03			jr .pastdmark  
4890 ..			.dmark: db "RE1"  
4893 f1			.pastdmark: pop af  
4894			endm  
# End of macro DMARK
4894					CALLMONITOR 
4894 cd d3 13			call break_point_state  
4897				endm  
# End of macro CALLMONITOR
4897				endif 
4897 cd 43 08				call storage_read 
489a			 
489a				if DEBUG_STORESE 
489a					DMARK "RE2" 
489a f5				push af  
489b 3a af 48			ld a, (.dmark)  
489e 32 bd fb			ld (debug_mark),a  
48a1 3a b0 48			ld a, (.dmark+1)  
48a4 32 be fb			ld (debug_mark+1),a  
48a7 3a b1 48			ld a, (.dmark+2)  
48aa 32 bf fb			ld (debug_mark+2),a  
48ad 18 03			jr .pastdmark  
48af ..			.dmark: db "RE2"  
48b2 f1			.pastdmark: pop af  
48b3			endm  
# End of macro DMARK
48b3					CALLMONITOR 
48b3 cd d3 13			call break_point_state  
48b6				endm  
# End of macro CALLMONITOR
48b6				endif 
48b6 cd 38 0c			call ishlzero 
48b9			;	ld a, l 
48b9			;	add h 
48b9			;	cp 0 
48b9 ca 46 49			jp z, .readeof 
48bc			 
48bc				; not eof so hl should point to data to push to stack 
48bc			 
48bc				if DEBUG_STORESE 
48bc					DMARK "RE3" 
48bc f5				push af  
48bd 3a d1 48			ld a, (.dmark)  
48c0 32 bd fb			ld (debug_mark),a  
48c3 3a d2 48			ld a, (.dmark+1)  
48c6 32 be fb			ld (debug_mark+1),a  
48c9 3a d3 48			ld a, (.dmark+2)  
48cc 32 bf fb			ld (debug_mark+2),a  
48cf 18 03			jr .pastdmark  
48d1 ..			.dmark: db "RE3"  
48d4 f1			.pastdmark: pop af  
48d5			endm  
# End of macro DMARK
48d5					CALLMONITOR 
48d5 cd d3 13			call break_point_state  
48d8				endm  
# End of macro CALLMONITOR
48d8				endif 
48d8 cd 72 19			call forth_push_str 
48db			 
48db				if DEBUG_STORESE 
48db					DMARK "RE4" 
48db f5				push af  
48dc 3a f0 48			ld a, (.dmark)  
48df 32 bd fb			ld (debug_mark),a  
48e2 3a f1 48			ld a, (.dmark+1)  
48e5 32 be fb			ld (debug_mark+1),a  
48e8 3a f2 48			ld a, (.dmark+2)  
48eb 32 bf fb			ld (debug_mark+2),a  
48ee 18 03			jr .pastdmark  
48f0 ..			.dmark: db "RE4"  
48f3 f1			.pastdmark: pop af  
48f4			endm  
# End of macro DMARK
48f4					CALLMONITOR 
48f4 cd d3 13			call break_point_state  
48f7				endm  
# End of macro CALLMONITOR
48f7				endif 
48f7				; get next block  or mark as eof 
48f7			 
48f7 3a de f9			ld a, (store_openmaxext)   ; get our limit 
48fa 4f				ld c, a	 
48fb 3a df f9			ld a, (store_openext) 
48fe			 
48fe				if DEBUG_STORESE 
48fe					DMARK "RE5" 
48fe f5				push af  
48ff 3a 13 49			ld a, (.dmark)  
4902 32 bd fb			ld (debug_mark),a  
4905 3a 14 49			ld a, (.dmark+1)  
4908 32 be fb			ld (debug_mark+1),a  
490b 3a 15 49			ld a, (.dmark+2)  
490e 32 bf fb			ld (debug_mark+2),a  
4911 18 03			jr .pastdmark  
4913 ..			.dmark: db "RE5"  
4916 f1			.pastdmark: pop af  
4917			endm  
# End of macro DMARK
4917					CALLMONITOR 
4917 cd d3 13			call break_point_state  
491a				endm  
# End of macro CALLMONITOR
491a				endif 
491a b9				cp c 
491b 28 29			jr z, .readeof     ; at last extent 
491d			 
491d 3c					inc a 
491e 32 df f9				ld (store_openext), a 
4921			 
4921				if DEBUG_STORESE 
4921					DMARK "RE6" 
4921 f5				push af  
4922 3a 36 49			ld a, (.dmark)  
4925 32 bd fb			ld (debug_mark),a  
4928 3a 37 49			ld a, (.dmark+1)  
492b 32 be fb			ld (debug_mark+1),a  
492e 3a 38 49			ld a, (.dmark+2)  
4931 32 bf fb			ld (debug_mark+2),a  
4934 18 03			jr .pastdmark  
4936 ..			.dmark: db "RE6"  
4939 f1			.pastdmark: pop af  
493a			endm  
# End of macro DMARK
493a					CALLMONITOR 
493a cd d3 13			call break_point_state  
493d				endm  
# End of macro CALLMONITOR
493d				endif 
493d			 
493d			 
493d				       NEXTW 
493d c3 51 1b			jp macro_next 
4940				endm 
# End of macro NEXTW
4940			.ateof: 
4940 21 6a 49				ld hl, .showeof 
4943 cd 72 19				call forth_push_str 
4946 3e 00		.readeof:	ld a, 0 
4948 32 df f9				ld (store_openext), a 
494b			 
494b					 
494b				if DEBUG_STORESE 
494b					DMARK "REF" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 bd fb			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 be fb			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 bf fb			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "REF"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964					CALLMONITOR 
4964 cd d3 13			call break_point_state  
4967				endm  
# End of macro CALLMONITOR
4967				endif 
4967				       NEXTW 
4967 c3 51 1b			jp macro_next 
496a				endm 
# End of macro NEXTW
496a			 
496a .. 00		.showeof:   db "eof", 0 
496e			 
496e			 
496e			.EOF: 
496e				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
496e 6d				db WORD_SYS_CORE+89             
496f af 49			dw .FORMAT            
4971 04				db 3 + 1 
4972 .. 00			db "EOF",0              
4976				endm 
# End of macro CWHEAD
4976			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4976			; | | e.g. 
4976			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4976					; TODO if current block id for stream is zero then push true else false 
4976			 
4976					if DEBUG_FORTH_WORDS_KEY 
4976						DMARK "EOF" 
4976 f5				push af  
4977 3a 8b 49			ld a, (.dmark)  
497a 32 bd fb			ld (debug_mark),a  
497d 3a 8c 49			ld a, (.dmark+1)  
4980 32 be fb			ld (debug_mark+1),a  
4983 3a 8d 49			ld a, (.dmark+2)  
4986 32 bf fb			ld (debug_mark+2),a  
4989 18 03			jr .pastdmark  
498b ..			.dmark: db "EOF"  
498e f1			.pastdmark: pop af  
498f			endm  
# End of macro DMARK
498f						CALLMONITOR 
498f cd d3 13			call break_point_state  
4992				endm  
# End of macro CALLMONITOR
4992					endif 
4992			 
4992					; TODO handlue multiple file streams 
4992			 
4992					FORTH_DSP_POP     ; for now just get rid of stream id 
4992 cd 97 1a			call macro_forth_dsp_pop 
4995				endm 
# End of macro FORTH_DSP_POP
4995			 
4995 2e 01				ld l, 1 
4997 3a de f9				ld a, (store_openmaxext) 
499a fe 00				cp 0 
499c 28 09				jr  z, .eofdone   ; empty file 
499e 3a df f9				ld a, (store_openext) 
49a1 fe 00				cp 0 
49a3 28 02				jr  z, .eofdone 
49a5 2e 00				ld l, 0 
49a7 26 00		.eofdone:	ld h, 0 
49a9 cd 60 19				call forth_push_numhl 
49ac			 
49ac			 
49ac				       NEXTW 
49ac c3 51 1b			jp macro_next 
49af				endm 
# End of macro NEXTW
49af			 
49af			.FORMAT: 
49af				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
49af 6d				db WORD_SYS_CORE+89             
49b0 00 4a			dw .LABEL            
49b2 07				db 6 + 1 
49b3 .. 00			db "FORMAT",0              
49ba				endm 
# End of macro CWHEAD
49ba			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
49ba					; TODO if current block id for stream is zero then push true else false 
49ba				 
49ba				if DEBUG_STORESE 
49ba					DMARK "FOR" 
49ba f5				push af  
49bb 3a cf 49			ld a, (.dmark)  
49be 32 bd fb			ld (debug_mark),a  
49c1 3a d0 49			ld a, (.dmark+1)  
49c4 32 be fb			ld (debug_mark+1),a  
49c7 3a d1 49			ld a, (.dmark+2)  
49ca 32 bf fb			ld (debug_mark+2),a  
49cd 18 03			jr .pastdmark  
49cf ..			.dmark: db "FOR"  
49d2 f1			.pastdmark: pop af  
49d3			endm  
# End of macro DMARK
49d3					CALLMONITOR 
49d3 cd d3 13			call break_point_state  
49d6				endm  
# End of macro CALLMONITOR
49d6				endif 
49d6					; Wipes the bank check flags to cause a reformat on next block 0 read 
49d6			 
49d6 21 01 00				ld hl, 1 
49d9 3e 00				ld a, 0 
49db cd e7 01				call se_writebyte 
49de			 
49de				if DEBUG_STORESE 
49de					DMARK "FO0" 
49de f5				push af  
49df 3a f3 49			ld a, (.dmark)  
49e2 32 bd fb			ld (debug_mark),a  
49e5 3a f4 49			ld a, (.dmark+1)  
49e8 32 be fb			ld (debug_mark+1),a  
49eb 3a f5 49			ld a, (.dmark+2)  
49ee 32 bf fb			ld (debug_mark+2),a  
49f1 18 03			jr .pastdmark  
49f3 ..			.dmark: db "FO0"  
49f6 f1			.pastdmark: pop af  
49f7			endm  
# End of macro DMARK
49f7					CALLMONITOR 
49f7 cd d3 13			call break_point_state  
49fa				endm  
# End of macro CALLMONITOR
49fa				endif 
49fa					; force bank init 
49fa			 
49fa cd ba 03				call storage_get_block_0 
49fd					 
49fd				       NEXTW 
49fd c3 51 1b			jp macro_next 
4a00				endm 
# End of macro NEXTW
4a00			.LABEL: 
4a00				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4a00 6d				db WORD_SYS_CORE+89             
4a01 4e 4a			dw .STOREPAGE            
4a03 06				db 5 + 1 
4a04 .. 00			db "LABEL",0              
4a0a				endm 
# End of macro CWHEAD
4a0a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4a0a					; TODO test to see if bank is selected 
4a0a				 
4a0a					if DEBUG_FORTH_WORDS_KEY 
4a0a						DMARK "LBL" 
4a0a f5				push af  
4a0b 3a 1f 4a			ld a, (.dmark)  
4a0e 32 bd fb			ld (debug_mark),a  
4a11 3a 20 4a			ld a, (.dmark+1)  
4a14 32 be fb			ld (debug_mark+1),a  
4a17 3a 21 4a			ld a, (.dmark+2)  
4a1a 32 bf fb			ld (debug_mark+2),a  
4a1d 18 03			jr .pastdmark  
4a1f ..			.dmark: db "LBL"  
4a22 f1			.pastdmark: pop af  
4a23			endm  
# End of macro DMARK
4a23						CALLMONITOR 
4a23 cd d3 13			call break_point_state  
4a26				endm  
# End of macro CALLMONITOR
4a26					endif 
4a26			;	if DEBUG_STORESE 
4a26			;		DMARK "LBL" 
4a26			;		CALLMONITOR 
4a26			;	endif 
4a26					FORTH_DSP_VALUEHL 
4a26 cd fb 19			call macro_dsp_valuehl 
4a29				endm 
# End of macro FORTH_DSP_VALUEHL
4a29					;v5FORTH_DSP_VALUE 
4a29					 
4a29			;		push hl 
4a29					FORTH_DSP_POP 
4a29 cd 97 1a			call macro_forth_dsp_pop 
4a2c				endm 
# End of macro FORTH_DSP_POP
4a2c			;		pop hl 
4a2c			 
4a2c			;v5		inc hl   ; move past the type marker 
4a2c			 
4a2c				if DEBUG_STORESE 
4a2c					DMARK "LBl" 
4a2c f5				push af  
4a2d 3a 41 4a			ld a, (.dmark)  
4a30 32 bd fb			ld (debug_mark),a  
4a33 3a 42 4a			ld a, (.dmark+1)  
4a36 32 be fb			ld (debug_mark+1),a  
4a39 3a 43 4a			ld a, (.dmark+2)  
4a3c 32 bf fb			ld (debug_mark+2),a  
4a3f 18 03			jr .pastdmark  
4a41 ..			.dmark: db "LBl"  
4a44 f1			.pastdmark: pop af  
4a45			endm  
# End of macro DMARK
4a45					CALLMONITOR 
4a45 cd d3 13			call break_point_state  
4a48				endm  
# End of macro CALLMONITOR
4a48				endif 
4a48 cd d3 04				call storage_label 
4a4b			 
4a4b				       NEXTW 
4a4b c3 51 1b			jp macro_next 
4a4e				endm 
# End of macro NEXTW
4a4e			.STOREPAGE: 
4a4e				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4a4e 6d				db WORD_SYS_CORE+89             
4a4f 81 4a			dw .LABELS            
4a51 0a				db 9 + 1 
4a52 .. 00			db "STOREPAGE",0              
4a5c				endm 
# End of macro CWHEAD
4a5c			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4a5c					; TODO test to see if bank is selected 
4a5c				 
4a5c					if DEBUG_FORTH_WORDS_KEY 
4a5c						DMARK "STP" 
4a5c f5				push af  
4a5d 3a 71 4a			ld a, (.dmark)  
4a60 32 bd fb			ld (debug_mark),a  
4a63 3a 72 4a			ld a, (.dmark+1)  
4a66 32 be fb			ld (debug_mark+1),a  
4a69 3a 73 4a			ld a, (.dmark+2)  
4a6c 32 bf fb			ld (debug_mark+2),a  
4a6f 18 03			jr .pastdmark  
4a71 ..			.dmark: db "STP"  
4a74 f1			.pastdmark: pop af  
4a75			endm  
# End of macro DMARK
4a75						CALLMONITOR 
4a75 cd d3 13			call break_point_state  
4a78				endm  
# End of macro CALLMONITOR
4a78					endif 
4a78			;	if DEBUG_STORESE 
4a78			;		DMARK "STP" 
4a78			;		CALLMONITOR 
4a78			;	endif 
4a78			 
4a78 21 e8 f9			ld hl, store_page 
4a7b cd 60 19			call forth_push_numhl 
4a7e			 
4a7e			 
4a7e				       NEXTW 
4a7e c3 51 1b			jp macro_next 
4a81				endm 
# End of macro NEXTW
4a81			.LABELS: 
4a81				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4a81 6d				db WORD_SYS_CORE+89             
4a82 0b 4b			dw .ENDSTORAGE            
4a84 07				db 6 + 1 
4a85 .. 00			db "LABELS",0              
4a8c				endm 
# End of macro CWHEAD
4a8c			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4a8c					;  
4a8c			 
4a8c					; save the current device selected to restore afterwards 
4a8c				 
4a8c 3a e2 f9				ld a, (spi_device) 
4a8f f5					push af 
4a90			 
4a90			 
4a90					; run through each of the banks 
4a90			 
4a90 21 01 00				ld hl, 1 
4a93 cd 60 19				call forth_push_numhl 
4a96 3e ff				ld a, SPI_CE_HIGH 
4a98 cb 87				res SPI_CE0, a 
4a9a 32 e2 f9				ld (spi_device), a 
4a9d cd ba 03				call storage_get_block_0 
4aa0 21 eb f9				ld hl, store_page+3 
4aa3 cd 72 19				call forth_push_str 
4aa6			 
4aa6					 
4aa6 21 02 00				ld hl, 2 
4aa9 cd 60 19				call forth_push_numhl 
4aac 3e ff				ld a, SPI_CE_HIGH 
4aae cb 8f				res SPI_CE1, a 
4ab0 32 e2 f9				ld (spi_device), a 
4ab3 cd ba 03				call storage_get_block_0 
4ab6 21 eb f9				ld hl, store_page+3 
4ab9 cd 72 19				call forth_push_str 
4abc			 
4abc					 
4abc 21 03 00				ld hl, 3 
4abf cd 60 19				call forth_push_numhl 
4ac2 3e ff				ld a, SPI_CE_HIGH 
4ac4 cb 97				res SPI_CE2, a 
4ac6 32 e2 f9				ld (spi_device), a 
4ac9 cd ba 03				call storage_get_block_0 
4acc 21 eb f9				ld hl, store_page+3 
4acf cd 72 19				call forth_push_str 
4ad2			 
4ad2			 
4ad2 21 04 00				ld hl, 4 
4ad5 cd 60 19				call forth_push_numhl 
4ad8 3e ff				ld a, SPI_CE_HIGH 
4ada cb 9f				res SPI_CE3, a 
4adc 32 e2 f9				ld (spi_device), a 
4adf cd ba 03				call storage_get_block_0 
4ae2 21 eb f9				ld hl, store_page+3 
4ae5 cd 72 19				call forth_push_str 
4ae8			 
4ae8					 
4ae8			 
4ae8 21 05 00				ld hl, 5 
4aeb cd 60 19				call forth_push_numhl 
4aee 3e ff				ld a, SPI_CE_HIGH 
4af0 cb a7				res SPI_CE4, a 
4af2 32 e2 f9				ld (spi_device), a 
4af5 cd ba 03				call storage_get_block_0 
4af8 21 eb f9				ld hl, store_page+3 
4afb cd 72 19				call forth_push_str 
4afe			 
4afe					 
4afe					; push fixed count of storage devices (on board) for now 
4afe			 
4afe 21 05 00				ld hl, 5 
4b01 cd 60 19				call forth_push_numhl 
4b04			 
4b04					; restore selected device  
4b04				 
4b04 f1					pop af 
4b05 32 e2 f9				ld (spi_device), a 
4b08			 
4b08				       NEXTW 
4b08 c3 51 1b			jp macro_next 
4b0b				endm 
# End of macro NEXTW
4b0b			 
4b0b			.ENDSTORAGE: 
4b0b			; eof 
# End of file forth_words_storage.asm
4b0b			endif 
4b0b				include "forth_words_device.asm" 
4b0b			; Device related words 
4b0b			 
4b0b			; | ## Device Words 
4b0b			 
4b0b			if SOUND_ENABLE 
4b0b			.NOTE: 
4b0b				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b0b			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4b0b					if DEBUG_FORTH_WORDS_KEY 
4b0b						DMARK "NTE" 
4b0b						CALLMONITOR 
4b0b					endif 
4b0b			 
4b0b				 
4b0b			 
4b0b					NEXTW 
4b0b			.AFTERSOUND: 
4b0b			endif 
4b0b			 
4b0b			 
4b0b			USE_GPIO: equ 0 
4b0b			 
4b0b			if USE_GPIO 
4b0b			.GP1: 
4b0b				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b0b			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4b0b					NEXTW 
4b0b			.GP2: 
4b0b				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b0b			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4b0b			 
4b0b					NEXTW 
4b0b			 
4b0b			.GP3: 
4b0b				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b0b			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4b0b			 
4b0b					NEXTW 
4b0b			 
4b0b			.GP4: 
4b0b				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b0b			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4b0b			 
4b0b					NEXTW 
4b0b			.SIN: 
4b0b			 
4b0b			 
4b0b			endif 
4b0b			 
4b0b			 
4b0b				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b0b 33				db WORD_SYS_CORE+31             
4b0c 40 4b			dw .SOUT            
4b0e 03				db 2 + 1 
4b0f .. 00			db "IN",0              
4b12				endm 
# End of macro CWHEAD
4b12			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b12					if DEBUG_FORTH_WORDS_KEY 
4b12						DMARK "IN." 
4b12 f5				push af  
4b13 3a 27 4b			ld a, (.dmark)  
4b16 32 bd fb			ld (debug_mark),a  
4b19 3a 28 4b			ld a, (.dmark+1)  
4b1c 32 be fb			ld (debug_mark+1),a  
4b1f 3a 29 4b			ld a, (.dmark+2)  
4b22 32 bf fb			ld (debug_mark+2),a  
4b25 18 03			jr .pastdmark  
4b27 ..			.dmark: db "IN."  
4b2a f1			.pastdmark: pop af  
4b2b			endm  
# End of macro DMARK
4b2b						CALLMONITOR 
4b2b cd d3 13			call break_point_state  
4b2e				endm  
# End of macro CALLMONITOR
4b2e					endif 
4b2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b2e cd fb 19			call macro_dsp_valuehl 
4b31				endm 
# End of macro FORTH_DSP_VALUEHL
4b31			 
4b31 e5					push hl 
4b32			 
4b32					; destroy value TOS 
4b32			 
4b32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b32 cd 97 1a			call macro_forth_dsp_pop 
4b35				endm 
# End of macro FORTH_DSP_POP
4b35			 
4b35					; one value on hl get other one back 
4b35			 
4b35 c1					pop bc 
4b36			 
4b36					; do the sub 
4b36			;		ex de, hl 
4b36			 
4b36 ed 68				in l,(c) 
4b38			 
4b38					; save it 
4b38			 
4b38 26 00				ld h,0 
4b3a			 
4b3a					; TODO push value back onto stack for another op etc 
4b3a			 
4b3a cd 60 19				call forth_push_numhl 
4b3d					NEXTW 
4b3d c3 51 1b			jp macro_next 
4b40				endm 
# End of macro NEXTW
4b40			.SOUT: 
4b40				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4b40 34				db WORD_SYS_CORE+32             
4b41 93 4b			dw .SPIO            
4b43 04				db 3 + 1 
4b44 .. 00			db "OUT",0              
4b48				endm 
# End of macro CWHEAD
4b48			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b48					if DEBUG_FORTH_WORDS_KEY 
4b48						DMARK "OUT" 
4b48 f5				push af  
4b49 3a 5d 4b			ld a, (.dmark)  
4b4c 32 bd fb			ld (debug_mark),a  
4b4f 3a 5e 4b			ld a, (.dmark+1)  
4b52 32 be fb			ld (debug_mark+1),a  
4b55 3a 5f 4b			ld a, (.dmark+2)  
4b58 32 bf fb			ld (debug_mark+2),a  
4b5b 18 03			jr .pastdmark  
4b5d ..			.dmark: db "OUT"  
4b60 f1			.pastdmark: pop af  
4b61			endm  
# End of macro DMARK
4b61						CALLMONITOR 
4b61 cd d3 13			call break_point_state  
4b64				endm  
# End of macro CALLMONITOR
4b64					endif 
4b64			 
4b64					; get port 
4b64			 
4b64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b64 cd fb 19			call macro_dsp_valuehl 
4b67				endm 
# End of macro FORTH_DSP_VALUEHL
4b67			 
4b67 e5					push hl 
4b68			 
4b68					; destroy value TOS 
4b68			 
4b68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b68 cd 97 1a			call macro_forth_dsp_pop 
4b6b				endm 
# End of macro FORTH_DSP_POP
4b6b			 
4b6b					; get byte to send 
4b6b			 
4b6b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b6b cd fb 19			call macro_dsp_valuehl 
4b6e				endm 
# End of macro FORTH_DSP_VALUEHL
4b6e			 
4b6e			;		push hl 
4b6e			 
4b6e					; destroy value TOS 
4b6e			 
4b6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b6e cd 97 1a			call macro_forth_dsp_pop 
4b71				endm 
# End of macro FORTH_DSP_POP
4b71			 
4b71					; one value on hl get other one back 
4b71			 
4b71			;		pop hl 
4b71			 
4b71 c1					pop bc 
4b72			 
4b72					if DEBUG_FORTH_WORDS 
4b72						DMARK "OUT" 
4b72 f5				push af  
4b73 3a 87 4b			ld a, (.dmark)  
4b76 32 bd fb			ld (debug_mark),a  
4b79 3a 88 4b			ld a, (.dmark+1)  
4b7c 32 be fb			ld (debug_mark+1),a  
4b7f 3a 89 4b			ld a, (.dmark+2)  
4b82 32 bf fb			ld (debug_mark+2),a  
4b85 18 03			jr .pastdmark  
4b87 ..			.dmark: db "OUT"  
4b8a f1			.pastdmark: pop af  
4b8b			endm  
# End of macro DMARK
4b8b						CALLMONITOR 
4b8b cd d3 13			call break_point_state  
4b8e				endm  
# End of macro CALLMONITOR
4b8e					endif 
4b8e			 
4b8e ed 69				out (c), l 
4b90			 
4b90					NEXTW 
4b90 c3 51 1b			jp macro_next 
4b93				endm 
# End of macro NEXTW
4b93			 
4b93			 
4b93			.SPIO: 
4b93			 
4b93			if STORAGE_SE 
4b93				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b93 51				db WORD_SYS_CORE+61             
4b94 a4 4b			dw .SPICEH            
4b96 07				db 6 + 1 
4b97 .. 00			db "SPICEL",0              
4b9e				endm 
# End of macro CWHEAD
4b9e			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b9e			 
4b9e cd 95 01				call spi_ce_low 
4ba1			    NEXTW 
4ba1 c3 51 1b			jp macro_next 
4ba4				endm 
# End of macro NEXTW
4ba4			 
4ba4			.SPICEH: 
4ba4				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ba4 51				db WORD_SYS_CORE+61             
4ba5 b5 4b			dw .SPIOb            
4ba7 07				db 6 + 1 
4ba8 .. 00			db "SPICEH",0              
4baf				endm 
# End of macro CWHEAD
4baf			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4baf			 
4baf cd 84 01				call spi_ce_high 
4bb2			    NEXTW 
4bb2 c3 51 1b			jp macro_next 
4bb5				endm 
# End of macro NEXTW
4bb5			 
4bb5			 
4bb5			.SPIOb: 
4bb5			 
4bb5				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4bb5 51				db WORD_SYS_CORE+61             
4bb6 cb 4b			dw .SPII            
4bb8 05				db 4 + 1 
4bb9 .. 00			db "SPIO",0              
4bbe				endm 
# End of macro CWHEAD
4bbe			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4bbe			 
4bbe					; get port 
4bbe			 
4bbe			 
4bbe					; get byte to send 
4bbe			 
4bbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bbe cd fb 19			call macro_dsp_valuehl 
4bc1				endm 
# End of macro FORTH_DSP_VALUEHL
4bc1			 
4bc1			;		push hl    ; u1  
4bc1			 
4bc1					; destroy value TOS 
4bc1			 
4bc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc1 cd 97 1a			call macro_forth_dsp_pop 
4bc4				endm 
# End of macro FORTH_DSP_POP
4bc4			 
4bc4					; one value on hl get other one back 
4bc4			 
4bc4			;		pop hl   ; u2 - addr 
4bc4			 
4bc4					; TODO Send SPI byte 
4bc4			 
4bc4 7d					ld a, l 
4bc5 cd b9 00				call spi_send_byte 
4bc8			 
4bc8					NEXTW 
4bc8 c3 51 1b			jp macro_next 
4bcb				endm 
# End of macro NEXTW
4bcb			 
4bcb			.SPII: 
4bcb				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4bcb 52				db WORD_SYS_CORE+62             
4bcc e0 4b			dw .SESEL            
4bce 06				db 5 + 1 
4bcf .. 00			db "SPII",0              
4bd4				endm 
# End of macro CWHEAD
4bd4			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4bd4			 
4bd4					; TODO Get SPI byte 
4bd4			 
4bd4 cd da 00				call spi_read_byte 
4bd7			 
4bd7 26 00				ld h, 0 
4bd9 6f					ld l, a 
4bda cd 60 19				call forth_push_numhl 
4bdd			 
4bdd					NEXTW 
4bdd c3 51 1b			jp macro_next 
4be0				endm 
# End of macro NEXTW
4be0			 
4be0			 
4be0			 
4be0			.SESEL: 
4be0				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4be0 66				db WORD_SYS_CORE+82             
4be1 74 4c			dw .CARTDEV            
4be3 05				db 4 + 1 
4be4 .. 00			db "BANK",0              
4be9				endm 
# End of macro CWHEAD
4be9			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4be9					if DEBUG_FORTH_WORDS_KEY 
4be9						DMARK "BNK" 
4be9 f5				push af  
4bea 3a fe 4b			ld a, (.dmark)  
4bed 32 bd fb			ld (debug_mark),a  
4bf0 3a ff 4b			ld a, (.dmark+1)  
4bf3 32 be fb			ld (debug_mark+1),a  
4bf6 3a 00 4c			ld a, (.dmark+2)  
4bf9 32 bf fb			ld (debug_mark+2),a  
4bfc 18 03			jr .pastdmark  
4bfe ..			.dmark: db "BNK"  
4c01 f1			.pastdmark: pop af  
4c02			endm  
# End of macro DMARK
4c02						CALLMONITOR 
4c02 cd d3 13			call break_point_state  
4c05				endm  
# End of macro CALLMONITOR
4c05					endif 
4c05			 
4c05 3e ff				ld a, 255 
4c07 32 e5 f9				ld (spi_cartdev), a 
4c0a			 
4c0a					; get bank 
4c0a			 
4c0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c0a cd fb 19			call macro_dsp_valuehl 
4c0d				endm 
# End of macro FORTH_DSP_VALUEHL
4c0d			 
4c0d			;		push hl 
4c0d			 
4c0d					; destroy value TOS 
4c0d			 
4c0d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c0d cd 97 1a			call macro_forth_dsp_pop 
4c10				endm 
# End of macro FORTH_DSP_POP
4c10			 
4c10					; one value on hl get other one back 
4c10			 
4c10			;		pop hl 
4c10			 
4c10			 
4c10 0e ff				ld c, SPI_CE_HIGH 
4c12			 
4c12 7d					ld a, l 
4c13			 
4c13					if DEBUG_FORTH_WORDS 
4c13						DMARK "BNK" 
4c13 f5				push af  
4c14 3a 28 4c			ld a, (.dmark)  
4c17 32 bd fb			ld (debug_mark),a  
4c1a 3a 29 4c			ld a, (.dmark+1)  
4c1d 32 be fb			ld (debug_mark+1),a  
4c20 3a 2a 4c			ld a, (.dmark+2)  
4c23 32 bf fb			ld (debug_mark+2),a  
4c26 18 03			jr .pastdmark  
4c28 ..			.dmark: db "BNK"  
4c2b f1			.pastdmark: pop af  
4c2c			endm  
# End of macro DMARK
4c2c						CALLMONITOR 
4c2c cd d3 13			call break_point_state  
4c2f				endm  
# End of macro CALLMONITOR
4c2f					endif 
4c2f			 
4c2f					; active low 
4c2f			 
4c2f fe 00				cp 0 
4c31 28 1e				jr z, .bset 
4c33 fe 01				cp 1 
4c35 20 02				jr nz, .b2 
4c37 cb 81				res 0, c 
4c39 fe 02		.b2:		cp 2 
4c3b 20 02				jr nz, .b3 
4c3d cb 89				res 1, c 
4c3f fe 03		.b3:		cp 3 
4c41 20 02				jr nz, .b4 
4c43 cb 91				res 2, c 
4c45 fe 04		.b4:		cp 4 
4c47 20 02				jr nz, .b5 
4c49 cb 99				res 3, c 
4c4b fe 05		.b5:		cp 5 
4c4d 20 02				jr nz, .bset 
4c4f cb a1				res 4, c 
4c51			 
4c51			.bset: 
4c51 79					ld a, c 
4c52 32 e2 f9				ld (spi_device),a 
4c55					if DEBUG_FORTH_WORDS 
4c55						DMARK "BN2" 
4c55 f5				push af  
4c56 3a 6a 4c			ld a, (.dmark)  
4c59 32 bd fb			ld (debug_mark),a  
4c5c 3a 6b 4c			ld a, (.dmark+1)  
4c5f 32 be fb			ld (debug_mark+1),a  
4c62 3a 6c 4c			ld a, (.dmark+2)  
4c65 32 bf fb			ld (debug_mark+2),a  
4c68 18 03			jr .pastdmark  
4c6a ..			.dmark: db "BN2"  
4c6d f1			.pastdmark: pop af  
4c6e			endm  
# End of macro DMARK
4c6e						CALLMONITOR 
4c6e cd d3 13			call break_point_state  
4c71				endm  
# End of macro CALLMONITOR
4c71					endif 
4c71			 
4c71					NEXTW 
4c71 c3 51 1b			jp macro_next 
4c74				endm 
# End of macro NEXTW
4c74			 
4c74			.CARTDEV: 
4c74				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4c74 66				db WORD_SYS_CORE+82             
4c75 1d 4d			dw .ENDDEVICE            
4c77 08				db 7 + 1 
4c78 .. 00			db "CARTDEV",0              
4c80				endm 
# End of macro CWHEAD
4c80			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4c80					if DEBUG_FORTH_WORDS_KEY 
4c80						DMARK "CDV" 
4c80 f5				push af  
4c81 3a 95 4c			ld a, (.dmark)  
4c84 32 bd fb			ld (debug_mark),a  
4c87 3a 96 4c			ld a, (.dmark+1)  
4c8a 32 be fb			ld (debug_mark+1),a  
4c8d 3a 97 4c			ld a, (.dmark+2)  
4c90 32 bf fb			ld (debug_mark+2),a  
4c93 18 03			jr .pastdmark  
4c95 ..			.dmark: db "CDV"  
4c98 f1			.pastdmark: pop af  
4c99			endm  
# End of macro DMARK
4c99						CALLMONITOR 
4c99 cd d3 13			call break_point_state  
4c9c				endm  
# End of macro CALLMONITOR
4c9c					endif 
4c9c			 
4c9c					; disable se storage bank selection 
4c9c			 
4c9c 3e ff				ld a, SPI_CE_HIGH		; ce high 
4c9e 32 e2 f9				ld (spi_device), a 
4ca1			 
4ca1					; get bank 
4ca1			 
4ca1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ca1 cd fb 19			call macro_dsp_valuehl 
4ca4				endm 
# End of macro FORTH_DSP_VALUEHL
4ca4			 
4ca4			;		push hl 
4ca4			 
4ca4					; destroy value TOS 
4ca4			 
4ca4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ca4 cd 97 1a			call macro_forth_dsp_pop 
4ca7				endm 
# End of macro FORTH_DSP_POP
4ca7			 
4ca7					; one value on hl get other one back 
4ca7			 
4ca7			;		pop hl 
4ca7			 
4ca7					; active low 
4ca7			 
4ca7 0e ff				ld c, 255 
4ca9			 
4ca9 7d					ld a, l 
4caa					if DEBUG_FORTH_WORDS 
4caa						DMARK "CDV" 
4caa f5				push af  
4cab 3a bf 4c			ld a, (.dmark)  
4cae 32 bd fb			ld (debug_mark),a  
4cb1 3a c0 4c			ld a, (.dmark+1)  
4cb4 32 be fb			ld (debug_mark+1),a  
4cb7 3a c1 4c			ld a, (.dmark+2)  
4cba 32 bf fb			ld (debug_mark+2),a  
4cbd 18 03			jr .pastdmark  
4cbf ..			.dmark: db "CDV"  
4cc2 f1			.pastdmark: pop af  
4cc3			endm  
# End of macro DMARK
4cc3						CALLMONITOR 
4cc3 cd d3 13			call break_point_state  
4cc6				endm  
# End of macro CALLMONITOR
4cc6					endif 
4cc6 fe 00				cp 0 
4cc8 28 30				jr z, .cset 
4cca fe 01				cp 1 
4ccc 20 02				jr nz, .c2 
4cce cb 81				res 0, c 
4cd0 fe 02		.c2:		cp 2 
4cd2 20 02				jr nz, .c3 
4cd4 cb 89				res 1, c 
4cd6 fe 03		.c3:		cp 3 
4cd8 20 02				jr nz, .c4 
4cda cb 91				res 2, c 
4cdc fe 04		.c4:		cp 4 
4cde 20 02				jr nz, .c5 
4ce0 cb 99				res 3, c 
4ce2 fe 05		.c5:		cp 5 
4ce4 20 02				jr nz, .c6 
4ce6 cb a1				res 4, c 
4ce8 fe 06		.c6:		cp 6 
4cea 20 02				jr nz, .c7 
4cec cb a9				res 5, c 
4cee fe 07		.c7:		cp 7 
4cf0 20 02				jr nz, .c8 
4cf2 cb b1				res 6, c 
4cf4 fe 08		.c8:		cp 8 
4cf6 20 02				jr nz, .cset 
4cf8 cb b9				res 7, c 
4cfa 79			.cset:		ld a, c 
4cfb 32 e5 f9				ld (spi_cartdev),a 
4cfe			 
4cfe					if DEBUG_FORTH_WORDS 
4cfe						DMARK "CD2" 
4cfe f5				push af  
4cff 3a 13 4d			ld a, (.dmark)  
4d02 32 bd fb			ld (debug_mark),a  
4d05 3a 14 4d			ld a, (.dmark+1)  
4d08 32 be fb			ld (debug_mark+1),a  
4d0b 3a 15 4d			ld a, (.dmark+2)  
4d0e 32 bf fb			ld (debug_mark+2),a  
4d11 18 03			jr .pastdmark  
4d13 ..			.dmark: db "CD2"  
4d16 f1			.pastdmark: pop af  
4d17			endm  
# End of macro DMARK
4d17						CALLMONITOR 
4d17 cd d3 13			call break_point_state  
4d1a				endm  
# End of macro CALLMONITOR
4d1a					endif 
4d1a					NEXTW 
4d1a c3 51 1b			jp macro_next 
4d1d				endm 
# End of macro NEXTW
4d1d			endif 
4d1d			 
4d1d			.ENDDEVICE: 
4d1d			; eof 
4d1d			 
# End of file forth_words_device.asm
4d1d			 
4d1d			; var handler 
4d1d			 
4d1d			 
4d1d			.VARS: 
4d1d				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4d1d 78				db WORD_SYS_CORE+100             
4d1e 35 4d			dw .V0Q            
4d20 04				db 3 + 1 
4d21 .. 00			db "V0!",0              
4d25				endm 
# End of macro CWHEAD
4d25			;| V0! ( u1 -- )  Store value to v0  | DONE 
4d25			 
4d25					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d25 cd fb 19			call macro_dsp_valuehl 
4d28				endm 
# End of macro FORTH_DSP_VALUEHL
4d28			 
4d28 11 ab f9				ld de, cli_var_array 
4d2b			 
4d2b eb					ex de, hl 
4d2c 73					ld (hl), e 
4d2d 23					inc hl 
4d2e 72					ld (hl), d 
4d2f			 
4d2f					; destroy value TOS 
4d2f			 
4d2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d2f cd 97 1a			call macro_forth_dsp_pop 
4d32				endm 
# End of macro FORTH_DSP_POP
4d32			 
4d32				       NEXTW 
4d32 c3 51 1b			jp macro_next 
4d35				endm 
# End of macro NEXTW
4d35			.V0Q: 
4d35				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4d35 79				db WORD_SYS_CORE+101             
4d36 46 4d			dw .V1S            
4d38 04				db 3 + 1 
4d39 .. 00			db "V0@",0              
4d3d				endm 
# End of macro CWHEAD
4d3d			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4d3d 2a ab f9				ld hl, (cli_var_array) 
4d40 cd 60 19				call forth_push_numhl 
4d43			 
4d43				       NEXTW 
4d43 c3 51 1b			jp macro_next 
4d46				endm 
# End of macro NEXTW
4d46			.V1S: 
4d46				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4d46 7a				db WORD_SYS_CORE+102             
4d47 5e 4d			dw .V1Q            
4d49 04				db 3 + 1 
4d4a .. 00			db "V1!",0              
4d4e				endm 
# End of macro CWHEAD
4d4e			;| V1! ( u1 -- )  Store value to v1 | DONE 
4d4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d4e cd fb 19			call macro_dsp_valuehl 
4d51				endm 
# End of macro FORTH_DSP_VALUEHL
4d51			 
4d51 11 ad f9				ld de, cli_var_array+2 
4d54				 
4d54 eb					ex de, hl 
4d55 73					ld (hl), e 
4d56 23					inc hl 
4d57 72					ld (hl), d 
4d58			 
4d58					; destroy value TOS 
4d58			 
4d58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d58 cd 97 1a			call macro_forth_dsp_pop 
4d5b				endm 
# End of macro FORTH_DSP_POP
4d5b				       NEXTW 
4d5b c3 51 1b			jp macro_next 
4d5e				endm 
# End of macro NEXTW
4d5e			.V1Q: 
4d5e				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4d5e 7b				db WORD_SYS_CORE+103             
4d5f 6f 4d			dw .V2S            
4d61 04				db 3 + 1 
4d62 .. 00			db "V1@",0              
4d66				endm 
# End of macro CWHEAD
4d66			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4d66 2a ad f9				ld hl, (cli_var_array+2) 
4d69 cd 60 19				call forth_push_numhl 
4d6c				       NEXTW 
4d6c c3 51 1b			jp macro_next 
4d6f				endm 
# End of macro NEXTW
4d6f			.V2S: 
4d6f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4d6f 7c				db WORD_SYS_CORE+104             
4d70 87 4d			dw .V2Q            
4d72 04				db 3 + 1 
4d73 .. 00			db "V2!",0              
4d77				endm 
# End of macro CWHEAD
4d77			;| V2! ( u1 -- )  Store value to v2 | DONE 
4d77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d77 cd fb 19			call macro_dsp_valuehl 
4d7a				endm 
# End of macro FORTH_DSP_VALUEHL
4d7a			 
4d7a 11 af f9				ld de, cli_var_array+4 
4d7d				 
4d7d eb					ex de, hl 
4d7e 73					ld (hl), e 
4d7f 23					inc hl 
4d80 72					ld (hl), d 
4d81			 
4d81					; destroy value TOS 
4d81			 
4d81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d81 cd 97 1a			call macro_forth_dsp_pop 
4d84				endm 
# End of macro FORTH_DSP_POP
4d84				       NEXTW 
4d84 c3 51 1b			jp macro_next 
4d87				endm 
# End of macro NEXTW
4d87			.V2Q: 
4d87				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4d87 7d				db WORD_SYS_CORE+105             
4d88 98 4d			dw .V3S            
4d8a 04				db 3 + 1 
4d8b .. 00			db "V2@",0              
4d8f				endm 
# End of macro CWHEAD
4d8f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4d8f 2a af f9				ld hl, (cli_var_array+4) 
4d92 cd 60 19				call forth_push_numhl 
4d95				       NEXTW 
4d95 c3 51 1b			jp macro_next 
4d98				endm 
# End of macro NEXTW
4d98			.V3S: 
4d98				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4d98 7c				db WORD_SYS_CORE+104             
4d99 b0 4d			dw .V3Q            
4d9b 04				db 3 + 1 
4d9c .. 00			db "V3!",0              
4da0				endm 
# End of macro CWHEAD
4da0			;| V3! ( u1 -- )  Store value to v3 | DONE 
4da0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4da0 cd fb 19			call macro_dsp_valuehl 
4da3				endm 
# End of macro FORTH_DSP_VALUEHL
4da3			 
4da3 11 b1 f9				ld de, cli_var_array+6 
4da6				 
4da6 eb					ex de, hl 
4da7 73					ld (hl), e 
4da8 23					inc hl 
4da9 72					ld (hl), d 
4daa			 
4daa					; destroy value TOS 
4daa			 
4daa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4daa cd 97 1a			call macro_forth_dsp_pop 
4dad				endm 
# End of macro FORTH_DSP_POP
4dad				       NEXTW 
4dad c3 51 1b			jp macro_next 
4db0				endm 
# End of macro NEXTW
4db0			.V3Q: 
4db0				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4db0 7d				db WORD_SYS_CORE+105             
4db1 c1 4d			dw .END            
4db3 04				db 3 + 1 
4db4 .. 00			db "V3@",0              
4db8				endm 
# End of macro CWHEAD
4db8			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4db8 2a b1 f9				ld hl, (cli_var_array+6) 
4dbb cd 60 19				call forth_push_numhl 
4dbe				       NEXTW 
4dbe c3 51 1b			jp macro_next 
4dc1				endm 
# End of macro NEXTW
4dc1			 
4dc1			 
4dc1			 
4dc1			 
4dc1			 
4dc1			; end of dict marker 
4dc1			 
4dc1 00			.END:    db WORD_SYS_END 
4dc2 00 00			dw 0 
4dc4 00				db 0 
4dc5			 
4dc5			; use to jp here for user dict words to save on macro expansion  
4dc5			 
4dc5			user_dict_next: 
4dc5				NEXTW 
4dc5 c3 51 1b			jp macro_next 
4dc8				endm 
# End of macro NEXTW
4dc8			 
4dc8			 
4dc8			user_exec: 
4dc8				;    ld hl, <word code> 
4dc8				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4dc8				;    call forthexec 
4dc8				;    jp user_dict_next   (NEXT) 
4dc8			        ;    <word code bytes> 
4dc8 eb				ex de, hl 
4dc9 2a b9 f2			ld hl,(os_tok_ptr) 
4dcc				 
4dcc				FORTH_RSP_NEXT 
4dcc cd 07 19			call macro_forth_rsp_next 
4dcf				endm 
# End of macro FORTH_RSP_NEXT
4dcf			 
4dcf			if DEBUG_FORTH_UWORD 
4dcf						DMARK "UEX" 
4dcf f5				push af  
4dd0 3a e4 4d			ld a, (.dmark)  
4dd3 32 bd fb			ld (debug_mark),a  
4dd6 3a e5 4d			ld a, (.dmark+1)  
4dd9 32 be fb			ld (debug_mark+1),a  
4ddc 3a e6 4d			ld a, (.dmark+2)  
4ddf 32 bf fb			ld (debug_mark+2),a  
4de2 18 03			jr .pastdmark  
4de4 ..			.dmark: db "UEX"  
4de7 f1			.pastdmark: pop af  
4de8			endm  
# End of macro DMARK
4de8				CALLMONITOR 
4de8 cd d3 13			call break_point_state  
4deb				endm  
# End of macro CALLMONITOR
4deb			endif 
4deb			 
4deb			 
4deb			 
4deb eb				ex de, hl 
4dec 22 b9 f2			ld (os_tok_ptr), hl 
4def				 
4def				; Don't use next - Skips the first word in uword. 
4def			 
4def c3 e2 1b			jp exec1 
4df2			;	NEXT 
4df2			 
4df2			 
4df2			; eof 
# End of file forth_wordsv4.asm
4df2			endif 
4df2			;;;;;;;;;;;;;; Debug code 
4df2			 
4df2			 
4df2			;if DEBUG_FORTH_PARSE 
4df2 .. 00		.nowordfound: db "No match",0 
4dfb .. 00		.compword:	db "Comparing word ",0 
4e0b .. 00		.nextwordat:	db "Next word at",0 
4e18 .. 00		.charmatch:	db "Char match",0 
4e23			;endif 
4e23			if DEBUG_FORTH_JP 
4e23			.foundword:	db "Word match. Exec..",0 
4e23			endif 
4e23			;if DEBUG_FORTH_PUSH 
4e23 .. 00		.enddict:	db "Dict end. Push.",0 
4e33 .. 00		.push_str:	db "Pushing string",0 
4e42 .. 00		.push_num:	db "Pushing number",0 
4e51 .. 00		.data_sp:	db "SP:",0 
4e55 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4e67 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4e79 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4e8b			;endif 
4e8b			;if DEBUG_FORTH_MALLOC 
4e8b .. 00		.push_malloc:	db "Malloc address",0 
4e9a			;endif 
4e9a			 
4e9a			 
4e9a			 
4e9a			; display malloc address and current data stack pointer  
4e9a			 
4e9a			malloc_error: 
4e9a d5				push de 
4e9b f5				push af 
4e9c e5				push hl 
4e9d cd b6 0a			call clear_display 
4ea0 11 c2 4e			ld de, .mallocerr 
4ea3 3e 00			ld a,0 
4ea5			;	ld de,os_word_scratch 
4ea5 cd c9 0a			call str_at_display 
4ea8 3e 11			ld a, display_row_1+17 
4eaa 11 bd fb			ld de, debug_mark 
4ead cd c9 0a			call str_at_display 
4eb0 cd d9 0a			call update_display 
4eb3				;call break_point_state 
4eb3 cd f0 62			call cin_wait 
4eb6			 
4eb6 3e 20			ld a, ' ' 
4eb8 32 b7 ef			ld (os_view_disable), a 
4ebb e1				pop hl 
4ebc f1				pop af 
4ebd d1				pop de	 
4ebe				CALLMONITOR 
4ebe cd d3 13			call break_point_state  
4ec1				endm  
# End of macro CALLMONITOR
4ec1 c9				ret 
4ec2			 
4ec2 .. 00		.mallocerr: 	db "Malloc Error",0 
4ecf			;if DEBUG_FORTH_PUSH 
4ecf			display_data_sp: 
4ecf f5				push af 
4ed0			 
4ed0				; see if disabled 
4ed0			 
4ed0 3a b7 ef			ld a, (os_view_disable) 
4ed3 fe 2a			cp '*' 
4ed5 28 67			jr z, .skipdsp 
4ed7			 
4ed7 e5				push hl 
4ed8 e5				push hl 
4ed9 e5			push hl 
4eda cd b6 0a			call clear_display 
4edd e1			pop hl 
4ede 7c				ld a,h 
4edf 21 bd f2			ld hl, os_word_scratch 
4ee2 cd 10 0f			call hexout 
4ee5 e1				pop hl 
4ee6 7d				ld a,l 
4ee7 21 bf f2			ld hl, os_word_scratch+2 
4eea cd 10 0f			call hexout 
4eed 21 c1 f2			ld hl, os_word_scratch+4 
4ef0 3e 00			ld a,0 
4ef2 77				ld (hl),a 
4ef3 11 bd f2			ld de,os_word_scratch 
4ef6 3e 14				ld a, display_row_2 
4ef8 cd c9 0a				call str_at_display 
4efb 11 55 4e			ld de, .wordinhl 
4efe 3e 00			ld a, display_row_1 
4f00			 
4f00 cd c9 0a				call str_at_display 
4f03 11 bd fb			ld de, debug_mark 
4f06 3e 11			ld a, display_row_1+17 
4f08			 
4f08 cd c9 0a				call str_at_display 
4f0b			 
4f0b				; display current data stack pointer 
4f0b 11 51 4e			ld de,.data_sp 
4f0e 3e 1c				ld a, display_row_2 + 8 
4f10 cd c9 0a				call str_at_display 
4f13			 
4f13 2a a5 f9			ld hl,(cli_data_sp) 
4f16 e5				push hl 
4f17 7c				ld a,h 
4f18 21 bd f2			ld hl, os_word_scratch 
4f1b cd 10 0f			call hexout 
4f1e e1				pop hl 
4f1f 7d				ld a,l 
4f20 21 bf f2			ld hl, os_word_scratch+2 
4f23 cd 10 0f			call hexout 
4f26 21 c1 f2			ld hl, os_word_scratch+4 
4f29 3e 00			ld a,0 
4f2b 77				ld (hl),a 
4f2c 11 bd f2			ld de,os_word_scratch 
4f2f 3e 1f				ld a, display_row_2 + 11 
4f31 cd c9 0a				call str_at_display 
4f34			 
4f34			 
4f34 cd d9 0a			call update_display 
4f37 cd 3a 0a			call delay1s 
4f3a cd 3a 0a			call delay1s 
4f3d e1				pop hl 
4f3e			.skipdsp: 
4f3e f1				pop af 
4f3f c9				ret 
4f40			 
4f40			display_data_malloc: 
4f40			 
4f40 f5				push af 
4f41 e5				push hl 
4f42 e5				push hl 
4f43 e5			push hl 
4f44 cd b6 0a			call clear_display 
4f47 e1			pop hl 
4f48 7c				ld a,h 
4f49 21 bd f2			ld hl, os_word_scratch 
4f4c cd 10 0f			call hexout 
4f4f e1				pop hl 
4f50 7d				ld a,l 
4f51 21 bf f2			ld hl, os_word_scratch+2 
4f54 cd 10 0f			call hexout 
4f57 21 c1 f2			ld hl, os_word_scratch+4 
4f5a 3e 00			ld a,0 
4f5c 77				ld (hl),a 
4f5d 11 bd f2			ld de,os_word_scratch 
4f60 3e 14				ld a, display_row_2 
4f62 cd c9 0a				call str_at_display 
4f65 11 8b 4e			ld de, .push_malloc 
4f68 3e 00			ld a, display_row_1 
4f6a			 
4f6a cd c9 0a				call str_at_display 
4f6d			 
4f6d				; display current data stack pointer 
4f6d 11 51 4e			ld de,.data_sp 
4f70 3e 1c				ld a, display_row_2 + 8 
4f72 cd c9 0a				call str_at_display 
4f75			 
4f75 2a a5 f9			ld hl,(cli_data_sp) 
4f78 e5				push hl 
4f79 7c				ld a,h 
4f7a 21 bd f2			ld hl, os_word_scratch 
4f7d cd 10 0f			call hexout 
4f80 e1				pop hl 
4f81 7d				ld a,l 
4f82 21 bf f2			ld hl, os_word_scratch+2 
4f85 cd 10 0f			call hexout 
4f88 21 c1 f2			ld hl, os_word_scratch+4 
4f8b 3e 00			ld a,0 
4f8d 77				ld (hl),a 
4f8e 11 bd f2			ld de,os_word_scratch 
4f91 3e 1f				ld a, display_row_2 + 11 
4f93 cd c9 0a				call str_at_display 
4f96			 
4f96 cd d9 0a			call update_display 
4f99 cd 3a 0a			call delay1s 
4f9c cd 3a 0a			call delay1s 
4f9f e1				pop hl 
4fa0 f1				pop af 
4fa1 c9				ret 
4fa2			;endif 
4fa2			 
4fa2			include "forth_autostart.asm" 
4fa2			; list of commands to perform at system start up 
4fa2			 
4fa2			startcmds: 
4fa2			;	dw test11 
4fa2			;	dw test12 
4fa2			;	dw test13 
4fa2			;	dw test14 
4fa2			;	dw test15 
4fa2			;	dw test16 
4fa2			;	dw test17 
4fa2			;	dw ifthtest1 
4fa2			;	dw ifthtest2 
4fa2			;	dw ifthtest3 
4fa2			;	dw mmtest1 
4fa2			;	dw mmtest2 
4fa2			;	dw mmtest3 
4fa2			;	dw mmtest4 
4fa2			;	dw mmtest5 
4fa2			;	dw mmtest6 
4fa2			;	dw iftest1 
4fa2			;	dw iftest2 
4fa2			;	dw iftest3 
4fa2			;	dw looptest1 
4fa2			;	dw looptest2 
4fa2			;	dw test1 
4fa2			;	dw test2 
4fa2			;	dw test3 
4fa2			;	dw test4 
4fa2			;	dw game2r 
4fa2			;	dw game2b1 
4fa2			;	dw game2b2 
4fa2			 
4fa2				; start up words that are actually useful 
4fa2			 
4fa2 00 50			dw clrstack 
4fa4 33 50			dw type 
4fa6 f4 51			dw stest 
4fa8 57 50			dw strncpy 
4faa 95 51			dw list 
4fac b8 50			dw start1 
4fae ca 50			dw start2 
4fb0			;	dw start3 
4fb0 dd 50			dw start3b 
4fb2 35 51			dw start3c 
4fb4			 
4fb4				; (unit) testing words 
4fb4			 
4fb4 6b 52			dw mtesta 
4fb6 20 53			dw mtestb 
4fb8 c3 53			dw mtestc 
4fba 78 54			dw mtestd 
4fbc 1c 55			dw mteste 
4fbe			 
4fbe				; demo/game words 
4fbe			 
4fbe 28 5c		        dw game3w 
4fc0 56 5c		        dw game3p 
4fc2 74 5c		        dw game3sc 
4fc4 a5 5c		        dw game3vsi 
4fc6 d1 5c		        dw game3vs 
4fc8				 
4fc8 1b 5a			dw game2b 
4fca 89 5a			dw game2bf 
4fcc d3 5a			dw game2mba 
4fce 69 5b			dw game2mbas 
4fd0 ab 5b			dw game2mb 
4fd2			 
4fd2 dc 56			dw game1 
4fd4 ed 56			dw game1a 
4fd6 4f 57			dw game1b 
4fd8 84 57			dw game1c 
4fda ba 57			dw game1d 
4fdc eb 57			dw game1s 
4fde ff 57			dw game1t 
4fe0 14 58			dw game1f 
4fe2 48 58			dw game1z 
4fe4 8c 58			dw game1zz 
4fe6			 
4fe6 d2 55			dw test5 
4fe8 0a 56			dw test6 
4fea 42 56			dw test7 
4fec 56 56			dw test8 
4fee 82 56			dw test9 
4ff0 98 56			dw test10 
4ff2				 
4ff2 63 59		        dw ssv5 
4ff4 47 59		        dw ssv4 
4ff6 2b 59		        dw ssv3 
4ff8 f5 58		        dw ssv2 
4ffa 7c 59		        dw ssv1 
4ffc c4 59		        dw ssv1cpm 
4ffe			;	dw keyup 
4ffe			;	dw keydown 
4ffe			;	dw keyleft 
4ffe			;	dw keyright 
4ffe			;	dw 	keyf1 
4ffe			;	dw keyf2 
4ffe			;	dw keyf3 
4ffe			;	dw keyf4 
4ffe			;	dw keyf5 
4ffe			;	dw keyf6 
4ffe			;	dw keyf7 
4ffe			;	dw keyf8 
4ffe			;	dw keyf9 
4ffe			;	dw keyf10 
4ffe			;	dw keyf11 
4ffe			;	dw keyf12 
4ffe			;	dw keytab 
4ffe			;	dw keycr 
4ffe			;	dw keyhome 
4ffe			;	dw keyend 
4ffe			;	dw keybs 
4ffe 00 00			db 0, 0	 
5000			 
5000			 
5000			; clear stack  
5000			 
5000 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5033			 
5033			; type ( addr count - ) 
5033 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5057			 
5057			; some direct memory words 
5057			; strncpy ( len t f -- t ) 
5057			 
5057 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
50b8			 
50b8 .. 00		start1:     	db ": bpon $0000 bp ;",0 
50ca .. 00		start2:     	db ": bpoff $0001 bp ;",0 
50dd			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
50dd .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5135 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5195			 
5195			 
5195			; a handy word to list items on the stack 
5195			 
5195 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
51f4			 
51f4			 
51f4			; test stack  
51f4			; rnd8 stest 
51f4			 
51f4 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
526b			 
526b			; random malloc and free cycles 
526b			 
526b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5320			 
5320			; fixed malloc and free cycles 
5320			 
5320 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
53c3			 
53c3			; fixed double string push and drop cycle  
53c3			 
53c3 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5478			 
5478			; consistent fixed string push and drop cycle  
5478			 
5478 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
551c			 
551c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
55d2			 
55d2			;test1:		db ": aa 1 2 3 ;", 0 
55d2			;test2:     	db "111 aa 888 999",0 
55d2			;test3:     	db ": bb 77 ;",0 
55d2			;test4:     	db "$02 $01 do i . loop bb",0 
55d2			 
55d2 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
560a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5642 .. 00		test7:     	db ": box hline vline ;",0 
5656 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5682 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5698 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
56bd .. 00		test11:     	db "hello create .",0 
56cc .. 00		test12:     	db "hello2 create .",0 
56dc			 
56dc			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
56dc			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
56dc			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
56dc			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
56dc			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
56dc			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
56dc			 
56dc			;iftest1:     	db "$0001 IF cls .",0 
56dc			;iftest2:     	db "$0000 IF cls .",0 
56dc			;iftest3:     	db "$0002 $0003 - IF cls .",0 
56dc			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
56dc			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
56dc			 
56dc			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
56dc			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
56dc			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
56dc			 
56dc			 
56dc			 
56dc			; a small guess the number game 
56dc			 
56dc .. 00		game1:          db ": gsn rnd8 v1! ;",0 
56ed .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
574f			 
574f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5784 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
57ba .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
57eb .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
57ff .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5814 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5848 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
588c			 
588c			; Using 'ga' save a high score across multiple runs using external storage 
588c			 
588c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
58f5			 
58f5			 
58f5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
58f5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
58f5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
58f5			 
58f5			; simple screen saver to test code memory reuse to destruction 
58f5			 
58f5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
592b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5947 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5963 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
597c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
59c4 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5a1b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a1b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5a1b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5a1b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5a1b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5a1b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5a1b			 
5a1b			 
5a1b			 
5a1b			; minesweeper/battleship finding game 
5a1b			; draws a game board of random ship/mine positions 
5a1b			; user enters coords to see if it hits on 
5a1b			; game ends when all are hit 
5a1b			; when hit or miss says how many may be in the area 
5a1b			 
5a1b			; setup the game board and then hide it 
5a1b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5a89 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5ad3			; prompt for where to target 
5ad3 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5b69 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5b8e			; TODO see if the entered coords hits or misses pushes char hit of miss 
5b8e .. 00		game2mbht:      db ": mbckht nop ;",0 
5b9d .. 00		game2mbms:      db ": mbcms nop ;",0 
5bab			; TODO how many might be near by 
5bab .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5c28			 
5c28			; Game 3 
5c28			 
5c28			; Vert scroller ski game - avoid the trees! 
5c28			 
5c28			; v0 score (ie turns) 
5c28			; v1 player pos 
5c28			; v2 left wall 
5c28			; v3 right wall 
5c28			 
5c28			; Draw side walls randomly 
5c28			 
5c28 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5c56			 
5c56			; Draw player 
5c56 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5c74			 
5c74			; TODO Get Key 
5c74			 
5c74			; TODO Move left right 
5c74			 
5c74			; scroll and move walls a bit 
5c74			 
5c74 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ca5			 
5ca5			; main game loop 
5ca5			 
5ca5 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5cd1 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5d10			 
5d10			; key board defs 
5d10			 
5d10 .. 00		keyup:       db ": keyup $05 ;",0 
5d1e .. 00		keydown:       db ": keydown $0a ;",0 
5d2e .. 00		keyleft:       db ": keyleft $0b ;",0 
5d3e .. 00		keyright:       db ": keyright $0c ;",0 
5d4f .. 00		keyf1:       db ": keyf1 $10 ;",0 
5d5d .. 00		keyf2:       db ": keyf2 $11 ;",0 
5d6b .. 00		keyf3:       db ": keyf3 $12 ;",0 
5d79 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5d87 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5d95 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5da3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5db1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5dbf .. 00		keyf9:       db ": keyf9 $18 ;",0 
5dcd .. 00		keyf10:       db ": keyf10 $19 ;",0 
5ddc .. 00		keyf11:       db ": keyf11 $1a ;",0 
5deb .. 00		keyf12:       db ": keyf12 $1b ;",0 
5dfa			 
5dfa .. 00		keytab:       db ": keytab $09 ;",0 
5e09 .. 00		keycr:       db ": keycr $0d ;",0 
5e17 .. 00		keyhome:       db ": keyhome $0e ;",0 
5e27 .. 00		keyend:       db ": keyend $0f ;",0 
5e36 .. 00		keybs:       db ": keybs $08 ;",0 
5e44			 
5e44			   
5e44			 
5e44			 
5e44			 
5e44			; eof 
# End of file forth_autostart.asm
5e44			 
5e44 .. 00		sprompt1: db "Startup load...",0 
5e54 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5e6a			 
5e6a			forth_startup: 
5e6a 21 a2 4f			ld hl, startcmds 
5e6d 3e 00			ld a, 0 
5e6f 32 de f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5e72			 
5e72 e5			.start1:	push hl 
5e73 cd b6 0a			call clear_display 
5e76 11 44 5e			ld de, sprompt1 
5e79 3e 00		        ld a, display_row_1 
5e7b cd c9 0a			call str_at_display 
5e7e 11 54 5e			ld de, sprompt2 
5e81 3e 14		        ld a, display_row_2 
5e83 cd c9 0a			call str_at_display 
5e86 e1				pop hl 
5e87 e5				push hl 
5e88 5e				ld e,(hl) 
5e89 23				inc hl 
5e8a 56				ld d,(hl) 
5e8b 3e 28		        ld a, display_row_3 
5e8d cd c9 0a			call str_at_display 
5e90 cd d9 0a			call update_display 
5e93			 
5e93			 
5e93 3a de f3			ld a, (os_last_cmd) 
5e96 fe 00			cp 0 
5e98 28 05			jr z, .startprompt 
5e9a cd 2e 0a			call delay250ms 
5e9d 18 24			jr .startdo 
5e9f				 
5e9f				 
5e9f			 
5e9f			.startprompt: 
5e9f			 
5e9f 3e 4f			ld a,display_row_4 + display_cols - 1 
5ea1 11 d6 18		        ld de, endprg 
5ea4 cd c9 0a			call str_at_display 
5ea7 cd d9 0a			call update_display 
5eaa cd 3a 0a			call delay1s 
5ead cd f0 62			call cin_wait 
5eb0						 
5eb0 fe 2a			cp '*' 
5eb2 28 5e			jr z, .startupend1 
5eb4 fe 23			cp '#' 
5eb6 20 07			jr nz, .startno 
5eb8 3e 01			ld a, 1 
5eba 32 de f3			ld (os_last_cmd),a 
5ebd 18 04			jr .startdo 
5ebf fe 31		.startno:	cp '1' 
5ec1 28 3a			jr z,.startnxt  
5ec3			 
5ec3				; exec startup line 
5ec3			.startdo:	 
5ec3 e1				pop hl 
5ec4 e5				push hl 
5ec5				 
5ec5 5e				ld e,(hl) 
5ec6 23				inc hl 
5ec7 56				ld d,(hl) 
5ec8 eb				ex de,hl 
5ec9			 
5ec9 e5				push hl 
5eca			 
5eca 3e 00			ld a, 0 
5ecc				;ld a, FORTH_END_BUFFER 
5ecc cd 78 10			call strlent 
5ecf 23				inc hl   ; include zero term to copy 
5ed0 06 00			ld b,0 
5ed2 4d				ld c,l 
5ed3 e1				pop hl 
5ed4 11 b8 ef			ld de, scratch 
5ed7 ed b0			ldir 
5ed9			 
5ed9			 
5ed9 21 b8 ef			ld hl, scratch 
5edc cd 9f 1b			call forthparse 
5edf cd df 1b			call forthexec 
5ee2 cd f6 1a			call forthexec_cleanup 
5ee5			 
5ee5 3e 3c			ld a, display_row_4 
5ee7 11 7a 16			ld de, endprog 
5eea			 
5eea cd d9 0a			call update_display		 
5eed			 
5eed 3a de f3			ld a, (os_last_cmd) 
5ef0 fe 00			cp 0 
5ef2 20 09			jr nz, .startnxt 
5ef4 cd d8 18			call next_page_prompt 
5ef7 cd b6 0a		        call clear_display 
5efa cd d9 0a			call update_display		 
5efd			 
5efd				; move onto next startup line? 
5efd			.startnxt: 
5efd			 
5efd cd 2e 0a			call delay250ms 
5f00 e1				pop hl 
5f01			 
5f01 23				inc hl 
5f02 23				inc hl 
5f03			 
5f03 e5				push hl 
5f04 5e				ld e, (hl) 
5f05 23				inc hl 
5f06 56				ld d, (hl) 
5f07 e1				pop hl 
5f08				; TODO replace 0 test 
5f08			 
5f08 eb				ex de, hl 
5f09 cd 38 0c			call ishlzero 
5f0c			;	ld a,e 
5f0c			;	add d 
5f0c			;	cp 0    ; any left to do? 
5f0c eb				ex de, hl 
5f0d c2 72 5e			jp nz, .start1 
5f10 18 01			jr .startupend 
5f12			 
5f12 e1			.startupend1: pop hl 
5f13			.startupend: 
5f13			 
5f13 cd b6 0a			call clear_display 
5f16 cd d9 0a			call update_display 
5f19 c9				ret 
5f1a			 
5f1a			 
5f1a			; stack over and underflow checks 
5f1a			 
5f1a			; init the words to detect the under/overflow 
5f1a			 
5f1a			chk_stk_init: 
5f1a				; a vague random number to check so we dont get any "lucky" hits 
5f1a 3e 2d			ld a, 45 
5f1c 6f				ld l, a 
5f1d 00				nop 
5f1e 3e 17			ld a, 23 
5f20 67				ld h, a 
5f21			 
5f21 22 ad ef			ld (chk_word), hl     ; the word we need to check against 
5f24			 
5f24			;	ld (chk_stund), hl	; stack points.... 
5f24 22 fd fb			ld (chk_stovr), hl 
5f27 22 a3 f9			ld (chk_ret_und), hl 
5f2a 22 21 f9			ld (chk_ret_ovr), hl 
5f2d 22 1f f7			ld (chk_loop_ovr), hl 
5f30 22 1d f5			ld (chk_data_ovr), hl 
5f33 c9				ret 
5f34				 
5f34			check_stacks: 
5f34				; check all stack words 
5f34			 
5f34 e5				push hl 
5f35 d5				push de 
5f36			 
5f36			;	ld de,(chk_word) 
5f36			;	ld hl, (chk_stund)	; stack points.... 
5f36			;	if DEBUG_STK_FAULT 
5f36			;		DMARK "FAa" 
5f36			;		CALLMONITOR 
5f36			;	endif 
5f36			;	call cmp16 
5f36			;	jp z, .chk_faulta 
5f36			; 
5f36			;	ld de, sfaultsu 
5f36			;	jp .chk_fault 
5f36			 
5f36 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5f39 ed 5b ad ef		ld de,(chk_word) 
5f3d				if DEBUG_STK_FAULT 
5f3d					DMARK "FAb" 
5f3d					CALLMONITOR 
5f3d				endif 
5f3d cd 2d 0c			call cmp16 
5f40 28 06			jr z, .chk_fault1 
5f42 11 e3 5f			ld de, sfaultso 
5f45 c3 97 5f			jp .chk_fault 
5f48			.chk_fault1:  
5f48 2a a3 f9			ld hl, (chk_ret_und) 
5f4b ed 5b ad ef		ld de,(chk_word) 
5f4f				if DEBUG_STK_FAULT 
5f4f					DMARK "FAU" 
5f4f					CALLMONITOR 
5f4f				endif 
5f4f cd 2d 0c			call cmp16 
5f52 ca 5b 5f			jp z, .chk_fault2 
5f55 11 f3 5f			ld de, sfaultru 
5f58 c3 97 5f			jp .chk_fault 
5f5b			.chk_fault2:  
5f5b 2a 21 f9			ld hl, (chk_ret_ovr) 
5f5e ed 5b ad ef		ld de,(chk_word) 
5f62				if DEBUG_STK_FAULT 
5f62					DMARK "FA1" 
5f62					CALLMONITOR 
5f62				endif 
5f62 cd 2d 0c			call cmp16 
5f65 ca 6e 5f			jp z, .chk_fault3 
5f68 11 01 60			ld de, sfaultro 
5f6b c3 97 5f			jp .chk_fault 
5f6e			.chk_fault3:  
5f6e 2a 1f f7			ld hl, (chk_loop_ovr) 
5f71 ed 5b ad ef		ld de,(chk_word) 
5f75				if DEBUG_STK_FAULT 
5f75					DMARK "FA2" 
5f75					CALLMONITOR 
5f75				endif 
5f75 cd 2d 0c			call cmp16 
5f78 ca 81 5f			jp z, .chk_fault4 
5f7b 11 1b 60			ld de, sfaultlo 
5f7e c3 97 5f			jp .chk_fault 
5f81			.chk_fault4:  
5f81 2a 1d f5			ld hl, (chk_data_ovr) 
5f84 ed 5b ad ef		ld de,(chk_word) 
5f88				if DEBUG_STK_FAULT 
5f88					DMARK "FA3" 
5f88					CALLMONITOR 
5f88				endif 
5f88 cd 2d 0c			call cmp16 
5f8b ca 94 5f			jp z, .chk_fault5 
5f8e 11 35 60			ld de, sfaultdo 
5f91 c3 97 5f			jp .chk_fault 
5f94			 
5f94			 
5f94			.chk_fault5:  
5f94 d1				pop de 
5f95 e1				pop hl 
5f96			 
5f96 c9				ret 
5f97			 
5f97 cd b6 0a		.chk_fault: 	call clear_display 
5f9a 3e 14				ld a, display_row_2 
5f9c cd c9 0a				call str_at_display 
5f9f 11 c5 5f				   ld de, .stackfault 
5fa2 3e 00				ld a, display_row_1 
5fa4 cd c9 0a				call str_at_display 
5fa7 11 bd fb				    ld de, debug_mark 
5faa 3e 11				ld a, display_row_1+17 
5fac cd c9 0a				call str_at_display 
5faf cd d9 0a				call update_display 
5fb2			 
5fb2				; prompt before entering montior for investigating issue 
5fb2			 
5fb2 3e 3c			ld a, display_row_4 
5fb4 11 7a 16			ld de, endprog 
5fb7			 
5fb7 cd d9 0a			call update_display		 
5fba			 
5fba cd d8 18			call next_page_prompt 
5fbd			 
5fbd d1				pop de 
5fbe e1				pop hl 
5fbf cd ce 16				call monitor 
5fc2 c3 c8 15				jp warmstart 
5fc5					;jp 0 
5fc5					;halt 
5fc5			 
5fc5			 
5fc5			 
5fc5 .. 00		.stackfault: 	db "Stack fault:",0 
5fd2			 
5fd2 .. 00		sfaultsu: 	db	"Stack under flow",0 
5fe3 .. 00		sfaultso: 	db	"Stack over flow",0 
5ff3 .. 00		sfaultru:	db "RTS underflow",0 
6001 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
601b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6035 .. 00		sfaultdo:	db "DTS overflow", 0 
6042			 
6042			 
6042			fault_dsp_under: 
6042 11 54 60			ld de, .dsp_under 
6045 c3 04 61			jp .show_fault 
6048			 
6048			fault_rsp_under: 
6048 11 62 60			ld de, .rsp_under 
604b c3 04 61			jp .show_fault 
604e			fault_loop_under: 
604e 11 70 60			ld de, .loop_under 
6051 c3 04 61			jp .show_fault 
6054			 
6054 .. 00		.dsp_under: db "DSP Underflow",0 
6062 .. 00		.rsp_under: db "RSP Underflow",0 
6070 .. 00		.loop_under: db "LOOP Underflow",0 
607f			 
607f			 
607f d5			type_faultn: 	push de 
6080 e5					push hl 
6081 cd b6 0a				call clear_display 
6084 11 ab 60				   ld de, .typefaultn 
6087 3e 00				ld a, display_row_1 
6089 cd c9 0a				call str_at_display 
608c 11 bd fb				    ld de, debug_mark 
608f 3e 11				ld a, display_row_1+17 
6091 cd c9 0a				call str_at_display 
6094 cd d9 0a				call update_display 
6097			 
6097				; prompt before entering montior for investigating issue 
6097			 
6097 3e 3c			ld a, display_row_4 
6099 11 7a 16			ld de, endprog 
609c			 
609c cd d9 0a			call update_display		 
609f			 
609f cd d8 18			call next_page_prompt 
60a2			 
60a2 e5					push hl 
60a3 d5					push de 
60a4 cd ce 16				call monitor 
60a7 c3 c8 15				jp warmstart 
60aa 76					halt 
60ab			 
60ab			 
60ab .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
60c2			 
60c2 d5			type_faults: 	push de 
60c3 e5					push hl 
60c4 cd b6 0a				call clear_display 
60c7 11 ed 60				   ld de, .typefaults 
60ca 3e 00				ld a, display_row_1 
60cc cd c9 0a				call str_at_display 
60cf 11 bd fb				    ld de, debug_mark 
60d2 3e 11				ld a, display_row_1+17 
60d4 cd c9 0a				call str_at_display 
60d7 cd d9 0a				call update_display 
60da			 
60da				; prompt before entering montior for investigating issue 
60da			 
60da 3e 3c			ld a, display_row_4 
60dc 11 7a 16			ld de, endprog 
60df			 
60df cd d9 0a			call update_display		 
60e2			 
60e2 cd d8 18			call next_page_prompt 
60e5			 
60e5 e1					pop hl 
60e6 d1					pop de 
60e7 cd ce 16				call monitor 
60ea c3 c8 15				jp warmstart 
60ed			 
60ed			 
60ed .. 00		.typefaults: db "STR Type Expected TOS!",0 
6104			 
6104			.show_fault: 	 
6104 d5					push de 
6105 cd b6 0a				call clear_display 
6108 d1					pop de 
6109 3e 00				ld a, display_row_1 
610b cd c9 0a				call str_at_display 
610e 11 bd fb				    ld de, debug_mark 
6111 3e 11				ld a, display_row_1+17 
6113 cd c9 0a				call str_at_display 
6116 cd d9 0a				call update_display 
6119			 
6119				; prompt before entering montior for investigating issue 
6119			 
6119 3e 3c			ld a, display_row_4 
611b 11 7a 16			ld de, endprog 
611e			 
611e cd d9 0a			call update_display		 
6121			 
6121 cd d8 18			call next_page_prompt 
6124			 
6124 e1					pop hl 
6125 d1					pop de 
6126 cd ce 16				call monitor 
6129			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6129			; TODO Make optional fault restart to cli or warm boot? 
6129					;jp warmstart 
6129 c3 20 16				jp cli 
612c 76					halt 
612d			; eof 
# End of file forth_kernel.asm
612d			;include "nascombasic.asm" 
612d			 
612d			 
612d			; find out where the code ends if loaded into RAM (for SC114) 
612d			;endofcode:  
612d			;	nop 
612d			 
612d			 
612d			; eof 
612d			 
# End of file main.asm
612d			include "firmware_lcd_4x20.asm" 
612d			; **********************************************************************  
612d			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
612d			; **********************************************************************  
612d			;  
612d			; **  Written as a Small Computer Monitor App  
612d			; **  www.scc.me.uk  
612d			;  
612d			; History  
612d			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
612d			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
612d			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
612d			;  
612d			; **********************************************************************  
612d			;  
612d			; This program is an example of one of the methods of interfacing an   
612d			; alphanumeric LCD module.   
612d			;  
612d			; In this example the display is connected to either a Z80 PIO or a   
612d			; simple 8-bit output port.   
612d			;  
612d			; This interfacing method uses 4-bit data mode and uses time delays  
612d			; rather than polling the display's ready status. As a result the   
612d			; interface only requires 6 simple output lines:  
612d			;   Output bit 0 = not used  
612d			;   Output bit 1 = not used  
612d			;   Output bit 2 = RS         High = data, Low = instruction  
612d			;   Output bit 3 = E          Active high  
612d			;   Output bit 4 = DB4  
612d			;   Output bit 5 = DB5  
612d			;   Output bit 6 = DB6  
612d			;   Output bit 7 = DB7  
612d			; Display's R/W is connected to 0v so it is always in write mode  
612d			;  
612d			; This set up should work with any system supporting the RC2014 bus  
612d			  
612d			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
612d			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
612d			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
612d			;  
612d			; **********************************************************************  
612d			  
612d			; **********************************************************************  
612d			; **  Constants  
612d			; **********************************************************************  
612d			; LCD constants required by LCD support module  
612d			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
612d			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
612d			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
612d			kLCDWidth:  EQU display_cols             ;Width in characters  
612d			  
612d			; **********************************************************************  
612d			; **  Code library usage  
612d			; **********************************************************************  
612d			  
612d			; send character to current cursor position  
612d			; wraps and/or scrolls screen automatically  
612d			  
612d			  
612d			lcd_init:  
612d			  
612d			; SCMonAPI functions used  
612d			  
612d			; Alphanumeric LCD functions used  
612d			; no need to specify specific functions for this module  
612d			  
612d 3e cf		            LD   A, 11001111b  
612f d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6131 3e 00		            LD   A, 00000000b  
6133 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6135			  
6135			; Initialise alphanumeric LCD module  
6135 cd ae 61		            CALL fLCD_Init      ;Initialise LCD module  
6138			  
6138 c9				ret  
6139			  
6139			;  
6139			;;  
6139			; lcd functions  
6139			;  
6139			;  
6139			  
6139			; what is at cursor position   
6139			  
6139			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6139			;		call curptr  
6139			;		ret  
6139			  
6139			  
6139			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6139			  
6139			curptr:  
6139 c5				push bc  
613a 21 53 fb			ld hl, display_fb0  
613d			cpr:	  
613d				; loop for cursor whole row  
613d 0e 14			ld c, display_cols  
613f 23			cpr1:	inc hl  
6140 0d				dec c  
6141 20 fc			jr nz, cpr1  
6143 05				dec b  
6144 20 f7			jr nz, cpr  
6146			  
6146				; add col	  
6146			  
6146 23			cpr2:	inc hl  
6147 1d				dec e  
6148 20 fc			jr nz, cpr2  
614a			  
614a c1				pop bc  
614b c9				ret  
614c				  
614c			  
614c			  
614c			  
614c			  
614c			; write the frame buffer given in hl to hardware   
614c 22 5b fa		write_display: ld (display_write_tmp), hl 	   
614f 3e 00			ld a, kLCD_Line1  
6151 cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6154 06 14			ld b, display_cols  
6156 ed 5b 5b fa		ld de, (display_write_tmp)  
615a cd a6 61			call write_len_string  
615d				  
615d				  
615d 2a 5b fa			ld hl, (display_write_tmp)  
6160 11 14 00			ld de, display_cols  
6163 19				add hl,de  
6164 22 5b fa			ld (display_write_tmp),hl  
6167			  
6167				  
6167 3e 40			ld a, kLCD_Line2  
6169 cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
616c 06 14			ld b, display_cols  
616e ed 5b 5b fa		ld de, (display_write_tmp)  
6172 cd a6 61			call write_len_string  
6175				  
6175 2a 5b fa			ld hl, (display_write_tmp)  
6178 11 14 00			ld de, display_cols  
617b 19				add hl,de  
617c 22 5b fa			ld (display_write_tmp),hl  
617f			  
617f				  
617f 3e 14			ld a, kLCD_Line3  
6181 cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6184 06 14			ld b, display_cols  
6186 ed 5b 5b fa		ld de, (display_write_tmp)  
618a cd a6 61			call write_len_string  
618d				  
618d 2a 5b fa			ld hl, (display_write_tmp)  
6190 11 14 00			ld de, display_cols  
6193 19				add hl,de  
6194 22 5b fa			ld (display_write_tmp),hl  
6197			  
6197				  
6197 3e 54			ld a, kLCD_Line4  
6199 cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
619c 06 14			ld b, display_cols  
619e ed 5b 5b fa		ld de, (display_write_tmp)  
61a2 cd a6 61			call write_len_string  
61a5 c9					ret  
61a6				  
61a6				; write out a fixed length string given in b from de  
61a6			  
61a6 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
61a7 cd f8 61		            CALL fLCD_Data      ;Write character to display  
61aa 13				inc de  
61ab 10 f9			djnz write_len_string  
61ad c9				ret  
61ae			  
61ae			; Some other things to do  
61ae			;            LD   A, kLCD_Clear ;Display clear  
61ae			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
61ae			;            LD   A, kLCD_Under ;Display on with underscore cursor  
61ae			;            LD   A, kLCD_On     ;Display on with no cursor  
61ae			;            ;LD   A, kLCD_Off   ;Display off  
61ae			;            CALL fLCD_Inst      ;Send instruction to display  
61ae			;  
61ae			;  
61ae			;            halt  
61ae			;  
61ae			;  
61ae			;MsgHello:   DB  "Hello World!",0  
61ae			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
61ae			  
61ae			; Custom characters 5 pixels wide by 8 pixels high  
61ae			; Up to 8 custom characters can be defined  
61ae			;BitMaps:      
61ae			;; Character 0x00 = Battery icon  
61ae			;            DB  01110b  
61ae			;            DB  11011b  
61ae			;            DB  10001b  
61ae			;            DB  10001b  
61ae			;            DB  11111b  
61ae			;            DB  11111b  
61ae			;            DB  11111b  
61ae			;            DB  11111b  
61ae			;; Character 0x01 = Bluetooth icon  
61ae			;            DB  01100b  
61ae			;            DB  01010b  
61ae			;            DB  11100b  
61ae			;            DB  01000b  
61ae			;            DB  11100b  
61ae			;            DB  01010b  
61ae			;            DB  01100b  
61ae			;            DB  00000b  
61ae			;  
61ae			  
61ae			  
61ae			; **********************************************************************  
61ae			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
61ae			; **********************************************************************  
61ae			;  
61ae			; **  Written as a Small Computer Monitor App   
61ae			; **  Version 0.1 SCC 2018-05-16  
61ae			; **  www.scc.me.uk  
61ae			;  
61ae			; **********************************************************************  
61ae			;  
61ae			; This module provides support for alphanumeric LCD modules using with  
61ae			; *  HD44780 (or compatible) controller  
61ae			; *  5 x 7 pixel fonts  
61ae			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
61ae			; *  Interface via six digital outputs to the display (see below)  
61ae			;  
61ae			; LCD module pinout:  
61ae			;   1  Vss   0v supply  
61ae			;   2  Vdd   5v supply  
61ae			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
61ae			;   4  RS    High = data, Low = instruction  
61ae			;   5  R/W   High = Read, Low = Write  
61ae			;   6  E     Enable signal (active high)  
61ae			;   7  DB0   Data bit 0  
61ae			;   8  DB1   Data bit 1  
61ae			;   9  DB2   Data bit 2  
61ae			;  10  DB3   Data bit 3  
61ae			;  11  DB4   Data bit 4  
61ae			;  12  DB5   Data bit 5  
61ae			;  13  DB6   Data bit 6  
61ae			;  14  DB7   Data bit 7  
61ae			;  15  A     Backlight anode (+)  
61ae			;  16  K     Backlight cathode (-)  
61ae			;  
61ae			; This interfacing method uses 4-bit data mode and uses time delays  
61ae			; rather than polling the display's ready status. As a result the   
61ae			; interface only requires 6 simple output lines:  
61ae			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
61ae			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
61ae			;   LCD DB4 = Microcomputer output port bit 4  
61ae			;   LCD DB5 = Microcomputer output port bit 5  
61ae			;   LCD DB6 = Microcomputer output port bit 6  
61ae			;   LCD DB7 = Microcomputer output port bit 7  
61ae			; Display's R/W is connected to 0v so it is always in write mode  
61ae			; All 6 connections must be on the same port address <kLCDPrt>  
61ae			; This method also allows a decent length of cable from micro to LCD  
61ae			;  
61ae			; **********************************************************************  
61ae			;  
61ae			; To include the code for any given function provided by this module,   
61ae			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
61ae			; the parent source file.  
61ae			; For example:  #REQUIRES   uHexPrefix  
61ae			;  
61ae			; Also #INCLUDE this file at some point after the #REQUIRES statements  
61ae			; in the parent source file.  
61ae			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
61ae			;  
61ae			; These are the function names provided by this module:  
61ae			; fLCD_Init                     ;Initialise LCD  
61ae			; fLCD_Inst                     ;Send instruction to LCD  
61ae			; fLCD_Data                     ;Send data byte to LCD  
61ae			; fLCD_Pos                      ;Position cursor  
61ae			; fLCD_Str                      ;Display string  
61ae			; fLCD_Def                      ;Define custom character  
61ae			;  
61ae			; **********************************************************************  
61ae			;  
61ae			; Requires SCMonAPI.asm to also be included in the project  
61ae			;  
61ae			  
61ae			  
61ae			; **********************************************************************  
61ae			; **  Constants  
61ae			; **********************************************************************  
61ae			  
61ae			; Constants that must be defined externally  
61ae			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
61ae			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
61ae			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
61ae			;kLCDWidth: EQU 20             ;Width in characters  
61ae			  
61ae			; general line offsets in any frame buffer  
61ae			  
61ae			  
61ae			display_row_1: equ 0  
61ae			display_row_2: equ display_row_1+display_cols  
61ae			display_row_3: equ display_row_2 + display_cols  
61ae			display_row_4: equ display_row_3 + display_cols  
61ae			;display_row_4_eol:   
61ae			  
61ae			  
61ae			; Cursor position values for the start of each line  
61ae			kLCD_Line1: EQU 0x00   
61ae			kLCD_Line2: EQU 0x40    
61ae			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
61ae			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
61ae			  
61ae			; Instructions to send as A register to fLCD_Inst  
61ae			kLCD_Clear: EQU 00000001b     ;LCD clear  
61ae			kLCD_Off:   EQU 00001000b     ;LCD off  
61ae			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
61ae			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
61ae			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
61ae			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
61ae			  
61ae			; Constants used by this code module  
61ae			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
61ae			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
61ae			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
61ae			  
61ae			  
61ae			  
61ae			; **********************************************************************  
61ae			; **  LCD support functions  
61ae			; **********************************************************************  
61ae			  
61ae			; Initialise alphanumeric LCD module  
61ae			; LCD control register codes:  
61ae			;   DL   0 = 4-bit mode        1 = 8-bit mode  
61ae			;   N    0 = 1-line mode       1 = 2-line mode  
61ae			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
61ae			;   D    0 = Display off       1 = Display on  
61ae			;   C    0 = Cursor off        1 = Cursor on  
61ae			;   B    0 = Blinking off      1 = Blinking on  
61ae			;   ID   0 = Decrement mode    1 = Increment mode  
61ae			;   SH   0 = Entire shift off  1 = Entire shift on  
61ae 3e 28		fLCD_Init:  LD   A, 40  
61b0 cd 65 62		            CALL LCDDelay       ;Delay 40ms after power up  
61b3			; For reliable reset set 8-bit mode - 3 times  
61b3 cd 4f 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61b6 cd 4f 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61b9 cd 4f 62		            CALL WrFn8bit       ;Function = 8-bit mode  
61bc			; Set 4-bit mode  
61bc cd 4b 62		            CALL WrFn4bit       ;Function = 4-bit mode  
61bf cd 63 62		            CALL LCDDelay1      ;Delay 37 us or more  
61c2			; Function set  
61c2 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
61c4 cd d7 61		            CALL fLCD_Inst      ;2 line, display on  
61c7			; Display On/Off control  
61c7 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
61c9 cd d7 61		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
61cc			; Display Clear  
61cc 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
61ce cd d7 61		            CALL fLCD_Inst      ;Clear display  
61d1			; Entry mode  
61d1 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
61d3 cd d7 61		            CALL fLCD_Inst      ;Increment mode, shift off  
61d6			; Display module now initialised  
61d6 c9			            RET  
61d7			; ok to here  
61d7			  
61d7			; Write instruction to LCD  
61d7			;   On entry: A = Instruction byte to be written  
61d7			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
61d7 f5			fLCD_Inst:  PUSH AF  
61d8 f5			            PUSH AF  
61d9 cd eb 61		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
61dc f1			            POP  AF  
61dd 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
61de 17			            RLA  
61df 17			            RLA  
61e0 17			            RLA  
61e1 cd eb 61		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
61e4 3e 02		            LD   A, 2  
61e6 cd 65 62		            CALL LCDDelay       ;Delay 2 ms to complete   
61e9 f1			            POP  AF  
61ea c9			            RET  
61eb e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
61ed d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
61ef cb df		            SET  kLCDBitE, A  
61f1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
61f3 cb 9f		            RES  kLCDBitE, A  
61f5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
61f7 c9			            RET  
61f8			  
61f8			  
61f8			; Write data to LCD  
61f8			;   On entry: A = Data byte to be written  
61f8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
61f8 f5			fLCD_Data:  PUSH AF  
61f9 f5			            PUSH AF  
61fa cd 0c 62		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
61fd f1			            POP  AF  
61fe 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
61ff 17			            RLA  
6200 17			            RLA  
6201 17			            RLA  
6202 cd 0c 62		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6205 3e 96		            LD   A, 150  
6207 3d			Wait:      DEC  A              ;Wait a while to allow data   
6208 20 fd		            JR   NZ, Wait      ;  write to complete  
620a f1			            POP  AF  
620b c9			            RET  
620c e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
620e cb d7		            SET  kLCDBitRS, A  
6210 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6212 cb df		            SET  kLCDBitE, A  
6214 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6216 cb 9f		            RES  kLCDBitE, A  
6218 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
621a cb 97		            RES  kLCDBitRS, A  
621c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
621e c9			            RET  
621f			  
621f			  
621f			; Position cursor to specified location  
621f			;   On entry: A = Cursor position  
621f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
621f f5			fLCD_Pos:   PUSH AF  
6220 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6222 cd d7 61		            CALL fLCD_Inst      ;Write instruction to LCD  
6225 f1			            POP  AF  
6226 c9			            RET  
6227			  
6227			  
6227			; Output text string to LCD  
6227			;   On entry: DE = Pointer to null terminated text string  
6227			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6227 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6228 b7			            OR   A              ;Null terminator?  
6229 c8			            RET  Z              ;Yes, so finished  
622a cd f8 61		            CALL fLCD_Data      ;Write character to display  
622d 13			            INC  DE             ;Point to next character  
622e 18 f7		            JR   fLCD_Str       ;Repeat  
6230 c9					ret  
6231			  
6231			; Define custom character  
6231			;   On entry: A = Character number (0 to 7)  
6231			;             DE = Pointer to character bitmap data  
6231			;   On exit:  A = Next character number  
6231			;             DE = Next location following bitmap  
6231			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6231			; Character is   
6231 c5			fLCD_Def:   PUSH BC  
6232 f5			            PUSH AF  
6233 07			            RLCA                ;Calculate location  
6234 07			            RLCA                ;  for bitmap data  
6235 07			            RLCA                ;  = 8 x CharacterNumber  
6236 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6238 cd d7 61		            CALL fLCD_Inst      ;Write instruction to LCD  
623b 06 00		            LD   B, 0  
623d 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
623e cd f8 61		            CALL fLCD_Data      ;Write byte to display  
6241 13			            INC  DE             ;Point to next byte  
6242 04			            INC  B              ;Count bytes  
6243 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6245 28 f6		            JR   Z, Loop       ;No, so repeat  
6247 f1			            POP  AF  
6248 3c			            INC  A              ;Increment character number  
6249 c1			            POP  BC  
624a c9			            RET  
624b			  
624b			  
624b			; **********************************************************************  
624b			; **  Private functions  
624b			; **********************************************************************  
624b			  
624b			; Write function to LCD  
624b			;   On entry: A = Function byte to be written  
624b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
624b 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
624d 18 02		            JR   WrFunc  
624f 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6251 f5			WrFunc:     PUSH AF  
6252 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6254 cb df		            SET  kLCDBitE, A  
6256 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6258 cb 9f		            RES  kLCDBitE, A  
625a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
625c 3e 05		            LD   A, 5  
625e cd 65 62		            CALL LCDDelay       ;Delay 5 ms to complete  
6261 f1			            POP  AF  
6262 c9			            RET  
6263			  
6263			  
6263			; Delay in milliseconds  
6263			;   On entry: A = Number of milliseconds delay  
6263			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6263 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6265 d5			LCDDelay:   PUSH DE  
6266 5f			            LD   E, A           ;Delay by 'A' ms  
6267 16 00		            LD   D, 0  
6269 cd 1f 0a		            CALL aDelayInMS  
626c d1			            POP  DE  
626d c9			            RET  
626e			  
626e			  
626e			  
626e			  
626e			; eof  
626e			  
# End of file firmware_lcd_4x20.asm
626e			include "firmware_key_4x4.asm" 
626e			  
626e			  
626e			; bit mask for each scan column and row for teing the matrix  
626e			  
626e			; out   
626e 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
6272			; in  
6272 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6276			  
6276			; row/col to character map  
6276			  
6276			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6276			;    
6276			  
6276			; physical key matrix map to face of key  
6276			  
6276			  
6276			;      	1	2	3	A  
6276			;   	abc”	def&	ghi$	s1  
6276			;			  
6276			;	4	5	6	B  
6276			; 	jkl,	mno.	pqr:	s2  
6276			;			  
6276			; 	7	8	9	C  
6276			;	stu;	vwx@	yz?!	s3  
6276			;			  
6276			; 	*	0	#	D  
6276			; 	shift lck '	Space < >	Enter ( )	s4  
6276			;       tab bs 		  
6276			  
6276			  
6276			  
6276			  
6276			key_init:  
6276			  
6276			; SCMonAPI functions used  
6276			  
6276			; Alphanumeric LCD functions used  
6276			; no need to specify specific functions for this module  
6276			  
6276			  
6276 3e cf		            LD   A, 11001111b  
6278 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
627a			;            LD   A, 00000000b  
627a 3e 0f		            LD   A, 00001111b  
627c d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
627e			  
627e			  
627e				; TODO Configure cursor shapes  
627e			  
627e				; Load cursor shapes   
627e 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6280 11 90 62		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6283 06 02		            LD   B, 2           ;Number of characters to define  
6285 cd 31 62		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6288 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
628a			  
628a 3e 01				ld a, 1  
628c 32 56 fa			ld (cursor_shape),a  
628f c9				ret  
6290			  
6290			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6290			; Up to 8 custom characters can be defined  
6290			.cursor_shapes:      
6290			;; Character 0x00 = Normal  
6290 1f			            DB  11111b  
6291 1f			            DB  11111b  
6292 1f			            DB  11111b  
6293 1f			            DB  11111b  
6294 1f			            DB  11111b  
6295 1f			            DB  11111b  
6296 1f			            DB  11111b  
6297 1f			            DB  11111b  
6298			;; Character 0x01 = Modifier  
6298 1f			            DB  11111b  
6299 1b			            DB  11011b  
629a 1b			            DB  11011b  
629b 1b			            DB  11011b  
629c 1b			            DB  11011b  
629d 1f			            DB  11111b  
629e 1b			            DB  11011b  
629f 1f			            DB  11111b  
62a0			  
62a0			  
62a0			  
62a0			  
62a0			; Display custom character 0  
62a0			;            LD   A, kLCD_Line1+14  
62a0			;            CALL fLCD_Pos       ;Position cursor to location in A  
62a0			;            LD   A, 0  
62a0			;            CALL fLCD_Data      ;Write character in A at cursor  
62a0			  
62a0			; Display custom character 1  
62a0			;            LD   A, kLCD_Line2+14  
62a0			;            CALL fLCD_Pos      ;Position cursor to location in A  
62a0			;            LD   A, 1  
62a0			;            CALL fLCD_Data     ;Write character in A at cursor  
62a0			  
62a0			; keyboard scanning   
62a0			  
62a0			  
62a0			; key_rows: equ 4  
62a0			; key_cols: equ 4  
62a0			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
62a0			  
62a0			; key_scanr: equ key_row_bitmask  
62a0			; key_scanc: equ key_col_bitmask  
62a0			  
62a0			; key_char_map: equ key_map  
62a0			  
62a0			  
62a0			  
62a0			; character in from keyboard  
62a0			  
62a0 ..			.matrix_to_char: db "D#0*C987B654A321"  
62b0			  
62b0			  
62b0			; map the physical key to a char dependant on state  
62b0			  
62b0			.key_map_fa:   
62b0			  
62b0 ..					db 'D'  
62b1 0d					db KEY_CR    ; cr  
62b2 ..					db ' '  
62b3 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
62b4 ..					db 'C'  
62b5 ..					db 'y'  
62b6 ..					db 'v'  
62b7 ..					db 's'  
62b8 ..					db 'B'  
62b9 ..					db 'p'  
62ba ..					db 'm'  
62bb ..					db 'j'  
62bc ..					db 'A'  
62bd ..					db 'g'  
62be ..					db 'd'  
62bf ..					db 'a'  
62c0			  
62c0			.key_map_fb:  
62c0			  
62c0 ..					db 'A'  
62c1 ..					db '+'   
62c2 ..					db '<'  
62c3 ..					db  "'"    
62c4			  
62c4 ..					db 'A'  
62c5 ..					db 'z'  
62c6 ..					db 'w'  
62c7 ..					db 't'  
62c8 ..					db 'A'  
62c9 ..					db 'q'  
62ca ..					db 'n'  
62cb ..					db 'k'  
62cc ..					db 'A'  
62cd ..					db 'h'  
62ce ..					db 'e'  
62cf ..			 		db 'b'  
62d0			  
62d0			.key_map_fc:   
62d0			  
62d0			  
62d0 ..					db 'A'  
62d1 ..					db '-'   
62d2 ..					db '>'  
62d3 ..					db  '='   	  
62d4 ..					db 'A'  
62d5 ..					db '?'  
62d6 ..					db 'x'  
62d7 ..					db 'u'  
62d8 ..					db 'A'  
62d9 ..					db 'r'  
62da ..					db 'o'  
62db ..					db 'l'  
62dc ..					db 'A'  
62dd ..					db 'i'  
62de ..					db 'f'  
62df ..					db 'c'  
62e0			  
62e0				  
62e0			.key_map_fd:  
62e0			  
62e0 ..					db 'A'  
62e1 ..					db '/'   
62e2 ..					db '%'   
62e3 08					db KEY_BS  ; back space  
62e4 ..					db 'A'  
62e5 ..					db '!'  
62e6 ..					db '@'  
62e7 ..					db ';'  
62e8 ..					db 'A'  
62e9 ..					db ':'  
62ea ..					db '.'  
62eb ..					db ','  
62ec ..					db 'A'  
62ed ..					db '$'  
62ee ..					db '&'  
62ef ..				 	db '"'  
62f0			  
62f0					  
62f0				  
62f0			  
62f0			; add cin and cin_wait  
62f0			  
62f0 cd 01 63		cin_wait: 	call cin  
62f3 fe 00			cp 0  
62f5 28 f9			jr z, cin_wait   ; block until key press  
62f7			  
62f7 f5				push af   ; save key pressed  
62f8			  
62f8 cd 01 63		.cin_wait1:	call cin  
62fb fe 00			cp 0  
62fd 20 f9			jr nz, .cin_wait1  	; wait for key release  
62ff			  
62ff f1				pop af   ; get key  
6300 c9				ret  
6301			  
6301			  
6301 cd 12 63		cin: 	call .mtoc  
6304			  
6304				; no key held  
6304 fe 00			cp 0  
6306 c8				ret z  
6307			  
6307				; stop key bounce  
6307			  
6307			;	ld (key_held),a		 ; save it  
6307 47				ld b, a  
6308			  
6308 c5			.cina1:	push bc  
6309 cd 12 63			call .mtoc  
630c c1				pop bc  
630d b8				cp b  
630e 28 f8			jr z, .cina1  
6310 78				ld a,b		  
6311 c9				ret  
6312			  
6312			; detect keyboard modifier key press and apply new overlay to the face key held  
6312			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6312			  
6312			;.cin_map_modifier:   
6312			;	ld a, (hl)  
6312			;	and 255  
6312			;	ret NZ		; modifier key not flagged  
6312			;  
6312			;	; get key face  
6312			;  
6312			;	ld b,(key_face_held)  
6312			;  
6312			;	ld b, key_cols * key_rows  
6312			;  
6312			;	push de  
6312			;	pop hl  
6312			;  
6312			;.mmod1: ld a,(hl)   ; get map test  
6312			;	cp b  
6312			;	jr z, .mmod2  
6312			;  
6312			;  
6312			;  
6312			;.mmod2: inc hl    ;   
6312			;  
6312			;	  
6312			;  
6312			;	  
6312			;  
6312			;	ld hl,key_actual_pressed  
6312			;	ld (hl),a,  
6312			;	ret  
6312			  
6312				  
6312			  
6312			; map matrix key held to char on face of key  
6312			  
6312			.mtoc:  
6312			  
6312			  
6312				; TODO optimise the code....  
6312			  
6312			; scan keyboard row 1  
6312 3e 80			ld a, 128  
6314 21 d3 fb			ld hl, keyscan_table  
6317 cd f9 63			call .rowscan  
631a			  
631a				   
631a			  
631a 3e 40			ld a, 64  
631c 21 d7 fb			ld hl, keyscan_table+key_cols  
631f cd f9 63			call .rowscan  
6322			  
6322			  
6322			  
6322			  
6322 3e 20			ld a, 32  
6324 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6327 cd f9 63			call .rowscan  
632a			  
632a			  
632a			  
632a 3e 10			ld a, 16  
632c 21 df fb			ld hl, keyscan_table+(key_cols*3)  
632f cd f9 63			call .rowscan  
6332			  
6332			  
6332				; flag if key D is held down and remove from reporting  
6332 01 e0 62			ld bc, .key_map_fd    
6335 21 d3 fb			ld hl, keyscan_table  
6338 11 c5 fb			ld de, key_fd  
633b cd 8b 63			call .key_shift_hold  
633e fe ff			cp 255  
6340 28 33			jr z, .cinmap  
6342				; flag if key C is held down and remove from reporting  
6342 01 d0 62			ld bc, .key_map_fc    
6345 21 d7 fb			ld hl, keyscan_table+key_cols  
6348 11 c6 fb			ld de, key_fc  
634b cd 8b 63			call .key_shift_hold  
634e fe ff			cp 255  
6350 28 23			jr z, .cinmap  
6352				; flag if key B is held down and remove from reporting  
6352 01 c0 62			ld bc, .key_map_fb    
6355 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6358 11 c7 fb			ld de, key_fb  
635b cd 8b 63			call .key_shift_hold  
635e fe ff			cp 255  
6360 28 13			jr z, .cinmap  
6362				; flag if key A is held down and remove from reporting  
6362 01 b0 62			ld bc, .key_map_fa    
6365 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6368 11 c8 fb			ld de, key_fa  
636b cd 8b 63			call .key_shift_hold  
636e fe ff			cp 255  
6370 28 03			jr z, .cinmap  
6372			  
6372 11 a0 62			ld de, .matrix_to_char  
6375			  
6375			  
6375			.cinmap:   
6375				if DEBUG_KEY  
6375			            LD   A, kLCD_Line4  
6375			            CALL fLCD_Pos       ;Position cursor to location in A  
6375					push de  
6375			            LD   DE, keyscan_table  
6375			            CALL fLCD_Str       ;Display string pointed to by DE  
6375					pop de  
6375				endif  
6375			  
6375				; scan key matrix table for any held key  
6375			  
6375				; de holds either the default matrix or one selected above  
6375			  
6375 21 d3 fb			ld hl, keyscan_table  
6378 06 10			ld b,key_cols*key_rows  
637a			  
637a 7e			.cin1:	ld a,(hl)  
637b fe 23			cp '#'  
637d 28 08			jr z, .cinhit  
637f 23				inc hl  
6380 13				inc de  
6381 05				dec b  
6382 20 f6			jr nz, .cin1  
6384				; no key found held  
6384 3e 00			ld a,0  
6386 c9				ret  
6387 d5			.cinhit: push de  
6388 e1				pop hl  
6389 7e				ld a,(hl)  
638a c9				ret  
638b			  
638b			; flag a control key is held   
638b			; hl is key pin, de is flag indicator  
638b			  
638b			.key_shift_hold:  
638b c5				push bc  
638c 3e 01			ld a, 1  
638e 32 56 fa			ld (cursor_shape),a  
6391 06 00			ld b, 0  
6393 7e				ld a, (hl)  
6394 fe 2e			cp '.'  
6396 28 0a			jr z, .key_shift1  
6398 06 ff			ld b, 255  
639a 3e 2b			ld a, '+'    ; hide key from later scans  
639c 77				ld (hl),a  
639d 3e 02			ld a, 2  
639f 32 56 fa			ld (cursor_shape),a  
63a2			.key_shift1:  
63a2				; write flag indicator  
63a2 78				ld a,b  
63a3 12				ld (de),a  
63a4			  
63a4 d1				pop de    ; de now holds the key map ptr  
63a5 c9				ret  
63a6			  
63a6				  
63a6				  
63a6			  
63a6			  
63a6			  
63a6			  
63a6			  
63a6			  
63a6			  
63a6			  
63a6			  
63a6			  
63a6 c9				ret  
63a7			  
63a7			;	push hl  
63a7			;	push de  
63a7			;	push bc  
63a7			;	call keyscan  
63a7			;	; map key matrix to ascii value of key face  
63a7			;  
63a7			;	ld hl, key_face_map  
63a7			;	ld de, keyscan_table  
63a7			;  
63a7			;	; get how many keys to look at  
63a7			;	ld b, keyscan_table_len  
63a7			;	  
63a7			;  
63a7			;	; at this stage fall out on first key hit  
63a7			;	; TODO handle multiple key press  
63a7			;  
63a7			;map1:	ld a,(hl)  
63a7			;	cp '#'  
63a7			;	jr z, keyhit  
63a7			;	inc hl  
63a7			;	inc de  
63a7			;	dec b  
63a7			;	jr nz, map1  
63a7			;nohit:	ld a, 0  
63a7			;	jr keydone  
63a7			;keyhit: push de  
63a7			;	pop hl  
63a7			;	ld a,(hl)  
63a7			;keydone:  
63a7			;	push bc  
63a7			;	push de  
63a7			; 	push hl  
63a7			;	ret   
63a7			;  
63a7			  
63a7			  
63a7			  
63a7			  
63a7			; scan physical key matrix  
63a7			  
63a7			  
63a7			;keyscan:  
63a7			;  
63a7			;; for each key_row use keyscanr bit mask for out  
63a7			;; then read in for keyscanc bitmask  
63a7			;; save result of row scan to keyscantable  
63a7			;  
63a7			;; scan keyboard row 1  
63a7			;  
63a7			;	ld b, key_rows  
63a7			;	ld hl, key_scanr  
63a7			;	ld de, keyscan_table  
63a7			;  
63a7			;rowloop:  
63a7			;  
63a7			;	ld a,(hl)		; out bit mask to energise keyboard row  
63a7			;	call rowscan  
63a7			;	inc hl  
63a7			;	dec b  
63a7			;	jr nz, rowloop  
63a7			;  
63a7			;	ret  
63a7			;  
63a7			;  
63a7			;; pass a out bitmask, b row number  
63a7			;arowscan:   
63a7			;	push bc  
63a7			;  
63a7			;	ld d, b  
63a7			;  
63a7			;	; calculate buffer location for this row  
63a7			;  
63a7			;	ld hl, keyscan_table	  
63a7			;kbufr:  ld e, key_cols  
63a7			;kbufc:	inc hl  
63a7			;	dec e  
63a7			;	jr nz, kbufc  
63a7			;	dec d  
63a7			;	jr nz, kbufr  
63a7			;  
63a7			;	; energise row and read columns  
63a7			;  
63a7			;	out (portbdata),a  
63a7			;	in a,(portbdata)  
63a7			;	ld c,a  
63a7			;  
63a7			;  
63a7			;	; save buffer loc  
63a7			;  
63a7			;	ld (keybufptr), hl  
63a7			;  
63a7			;	ld hl, key_scanc  
63a7			;	ld d, key_cols  
63a7			;  
63a7			;	; for each column check each bit mask  
63a7			;  
63a7			;colloop:  
63a7			;	  
63a7			;  
63a7			;	; reset flags for the row   
63a7			;  
63a7			;	ld b,'.'  
63a7			;	and (hl)  
63a7			;	jr z, maskskip  
63a7			;	ld b,'#'  
63a7			;maskskip:  
63a7			;	; save  key state  
63a7			;	push hl  
63a7			;	ld hl, (keybufptr)  
63a7			;	ld (hl), b  
63a7			;	inc hl  
63a7			;	ld (keybufptr), hl  
63a7			;  
63a7			;	; move to next bit mask  
63a7			;	pop hl  
63a7			;	inc hl  
63a7			;  
63a7			;	dec d  
63a7			;	jr nz, colloop  
63a7			;  
63a7			;	ret  
63a7			;  
63a7			;  
63a7			;;  
63a7			; lcd functions  
63a7			;  
63a7			;  
63a7			  
63a7			;if DEBUG_KEY_MATRIX  
63a7			  
63a7			; test function to display hardware view of matrix state  
63a7			  
63a7			matrix:  
63a7			  
63a7			  
63a7			  
63a7			; scan keyboard row 1  
63a7 3e 80			ld a, 128  
63a9 21 f8 fb			ld hl, keyscan_table_row1  
63ac cd f9 63			call .rowscan  
63af			  
63af 3e 40			ld a, 64  
63b1 21 f3 fb			ld hl, keyscan_table_row2  
63b4 cd f9 63			call .rowscan  
63b7			  
63b7 3e 20			ld a, 32  
63b9 21 ee fb			ld hl, keyscan_table_row3  
63bc cd f9 63			call .rowscan  
63bf			  
63bf 3e 10			ld a, 16  
63c1 21 e9 fb			ld hl, keyscan_table_row4  
63c4 cd f9 63			call .rowscan  
63c7			  
63c7			; Display text on first line  
63c7 3e 00		            LD   A, kLCD_Line1  
63c9 cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63cc 11 f8 fb		            LD   DE, keyscan_table_row1  
63cf			            ;LD   DE, MsgHello  
63cf cd 27 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63d2			  
63d2			; Display text on second line  
63d2 3e 40		            LD   A, kLCD_Line2  
63d4 cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63d7 11 f3 fb		            LD   DE, keyscan_table_row2  
63da cd 27 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63dd 3e 14		            LD   A, kLCD_Line3  
63df cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63e2 11 ee fb		            LD   DE, keyscan_table_row3  
63e5 cd 27 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63e8 3e 54		            LD   A, kLCD_Line4  
63ea cd 1f 62		            CALL fLCD_Pos       ;Position cursor to location in A  
63ed 11 e9 fb		            LD   DE, keyscan_table_row4  
63f0 cd 27 62		            CALL fLCD_Str       ;Display string pointed to by DE  
63f3			  
63f3 cd 2e 0a			call delay250ms  
63f6 c3 a7 63			jp matrix  
63f9			  
63f9			; pass de as row display flags  
63f9			.rowscan:   
63f9 d3 c1			out (portbdata),a  
63fb db c1			in a,(portbdata)  
63fd 4f				ld c,a  
63fe				; reset flags for the row   
63fe 06 2e			ld b,'.'  
6400 e6 01			and 1  
6402 28 02			jr z, .p1on  
6404 06 23			ld b,'#'  
6406			.p1on:  
6406 70				ld (hl), b  
6407 23				inc hl  
6408			  
6408 06 2e			ld b,'.'  
640a 79				ld a,c  
640b e6 02			and 2  
640d			;	bit 0,a  
640d 28 02			jr z, .p2on  
640f 06 23			ld b,'#'  
6411			.p2on:  
6411 70				ld (hl), b  
6412 23				inc hl  
6413			;  
6413 06 2e			ld b,'.'  
6415 79				ld a,c  
6416 e6 04			and 4  
6418			;;	bit 0,a  
6418 28 02			jr z, .p3on  
641a 06 23			ld b,'#'  
641c			.p3on:  
641c 70				ld (hl), b  
641d 23				inc hl  
641e			;;  
641e 06 2e			ld b,'.'  
6420			;;	bit 0,a  
6420 79				ld a,c  
6421 e6 08			and 8  
6423 28 02			jr z, .p4on  
6425 06 23			ld b,'#'  
6427			.p4on:  
6427 70				ld (hl), b  
6428 23				inc hl  
6429			  
6429			; zero term  
6429 06 00			ld b,0  
642b 70				ld (hl), b  
642c			  
642c c9			.rscandone: ret  
642d			  
642d			  
642d			  
642d			;endif  
642d			  
642d			  
642d			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
642d
