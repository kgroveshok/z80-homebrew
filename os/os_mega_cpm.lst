# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5a 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			if BASE_KEV = 1  
011c			 
011c				; need to be at $66 for nmi support 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255 
011c				jp nmi 
011c			endif 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 0       
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c			;	call break_point_state  
011c			; now use the break point debug vector  
011c				call debug_vector  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011c			  
011c			debug_mark: equ debug_vector - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			;os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_new_exec_ptr - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c			;	ld a, ' ' 
011c			;	ld (os_view_disable), a 
011c				call bp_on 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 10 ed				ld hl, display_fb1  
011f 22 cc eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 ce eb				ld hl, display_fb2  
0128 22 cc eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b1 ed				ld hl, display_fb0  
0131 22 cc eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd 80 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 6e 65			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 b8 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 cd 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 6b ee		ld (debug_mark),a  
0191 32 6c ee		ld (debug_mark+1),a  
0194 32 6d ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 6e ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 73 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 6b ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 6c ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 6d ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 6f ee			call debug_vector  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 7a ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 6b ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 6c ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 6d ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 6f ee			call debug_vector  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 7a ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 6b ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 6c ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 6d ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 6f ee			call debug_vector  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 73 ea				ld hl, (store_tmp1) 
0210 11 7d ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 6b ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 6c ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 6d ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 6f ee			call debug_vector  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 6b ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 6c ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 6d ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 6f ee			call debug_vector  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 6b ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 6c ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 6d ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 6f ee			call debug_vector  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 6b ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 6c ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 6d ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 6f ee			call debug_vector  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 6b ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 6c ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 6d ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 6f ee			call debug_vector  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 7a ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 6b ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 6c ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 6d ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 6f ee			call debug_vector  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 6b ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 6c ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 6d ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 6f ee			call debug_vector  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 7a ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 6b ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 6c ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 6d ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 7a ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 6f ee			call debug_vector  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 7b ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 6b ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 6c ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 6d ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 6f ee			call debug_vector  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6b ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6c ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 6d ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 6f ee			call debug_vector  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 7a ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 7b ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 7d ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 86 ea			ld hl, store_page+3+9 
03b5 3a 5f ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 7a ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 6b ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 6c ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 6d ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 6f ee			call debug_vector  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 6b ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 6c ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 6d ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 6f ee			call debug_vector  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 6b ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 6c ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 6d ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 6f ee			call debug_vector  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 7d ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6b ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6c ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 6d ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 6f ee			call debug_vector  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 7a ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 6b ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 6c ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 6d ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 6f ee			call debug_vector  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 6b ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 6c ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 6d ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 6f ee			call debug_vector  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 7a ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 6b ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 6c ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 6d ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 6f ee			call debug_vector  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 7a ea			ld a, (store_page)	; get file id 
0510 32 6e ea			ld (store_tmpid), a 
0513			 
0513 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0516 32 6d ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 7a ea			ld (store_page), a 
051f 32 7b ea			ld (store_page+1),a 
0522 11 7a ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 6b ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 6c ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 6d ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 6f ee			call debug_vector  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 6d ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 6e ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 6b ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 6c ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 6d ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 6f ee			call debug_vector  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 7a ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 7a ea			ld (store_page), a 
0582 32 7b ea			ld (store_page+1),a 
0585 11 7a ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 6b ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 6c ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 6d ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 6f ee			call debug_vector  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 6b ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 6c ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 6d ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 6f ee			call debug_vector  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 6b ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 6c ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 6d ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 6f ee			call debug_vector  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 6b ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 6c ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 6d ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 6f ee			call debug_vector  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 6b ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 6c ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 6d ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 6f ee			call debug_vector  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 7a ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 7a ea			ld (store_page),a 
06a3				 
06a3 32 6e ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 7a ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6b ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6c ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 6d ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 6f ee			call debug_vector  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 7a ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 6b ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 6c ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 6d ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 6f ee			call debug_vector  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 6b ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 6c ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 6d ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 6f ee			call debug_vector  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 65 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 7a ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 7b ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 6b ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 6c ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 6d ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 6f ee			call debug_vector  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6b ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6c ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 6d ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 6f ee			call debug_vector  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 6b ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 6c ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 6d ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 6f ee			call debug_vector  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 65 ea			ld hl,(store_tmppageid) 
078b 11 7a ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 6b ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 6c ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 6d ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 6f ee			call debug_vector  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 6e ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 6b ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 6c ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 6d ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 6f ee			call debug_vector  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 6b ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 6c ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 6d ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 6f ee			call debug_vector  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 6b ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 6c ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 6d ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 6f ee			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 6b ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 6b ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 6c ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 6d ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 6f ee			call debug_vector  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 6d ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 6b ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 6c ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 6d ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 6f ee			call debug_vector  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 75 ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 6b ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 6c ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 6d ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd 6f ee			call debug_vector  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 6b ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 6c ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 6d ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd 6f ee			call debug_vector  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 6b ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 6c ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 6d ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd 6f ee			call debug_vector  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 6b ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 6b ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 6c ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 6d ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 6f ee			call debug_vector  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 6b ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 6c ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 6d ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd 6f ee			call debug_vector  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 6b ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 6c ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 6d ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd 6f ee			call debug_vector  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 6b ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 6c ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 6d ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd 6f ee			call debug_vector  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 6e ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 6e ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 65 ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6b ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6c ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 6d ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 6f ee			call debug_vector  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 7a ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 6b ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 6c ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 6d ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 6f ee			call debug_vector  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 7c ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 7c ea			ld (store_page+2), a 
09e3 32 6d ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 6b ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 6c ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 6d ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd 6f ee			call debug_vector  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 65 ea			ld hl, (store_tmppageid) 
0a05 11 7a ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 65 ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 6b ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 6c ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 6d ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd 6f ee			call debug_vector  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 7a ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 6e ea				ld a, (store_tmpid) 
0a4b 32 7a ea				ld (store_page), a   ; file id 
0a4e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 7b ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 7c ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 6b ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 6c ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 6d ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd 6f ee			call debug_vector  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 65 ea			ld hl, (store_tmppageid) 
0a85 11 7a ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 6b ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 6c ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 6d ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 6e ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 7a ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 7b ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a c6 eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 c6 eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 75 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 c7 eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 c7 eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a cc eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b1 ed				ld hl, display_fb0 
0b53 22 cc eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd be 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 10 ed				ld hl, display_fb1 
0b74 22 cc eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a cc eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a cc eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a cc eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a cc eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a cc eb			ld hl, (display_fb_active) 
0be1 cd bd 64			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 73 ea				ld (store_tmp1), hl 
0bee 32 71 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b1 ed				ld hl, display_fb0 
0bf4 22 cc eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 6f ea				ld (store_tmp3), a   ; display row count 
0c02 3a 71 ea				ld a,( store_tmp2) 
0c05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 72 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 73 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 6f ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 72 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 6f ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 6f ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 6f 65				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 71 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 71 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 71 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 71 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 71 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 10 ed				ld hl, display_fb1 
0cb1 22 cc eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a ab eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 ab eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b1 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b3 eb		        ld hl,LFSRSeed+6 
0d04 11 b4 eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a a5 eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 a5 eb		    ld (seed1),hl 
0d1a 2a a3 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a3 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 a9 eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 60 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 60 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 5f ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 5f ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 60 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 69 ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 67 ee			ld de, (input_start) 
0e69 3a 64 ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 5f ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 62 ee				ld a,(input_at_cursor) 
0e79 11 c1 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 67 ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 5a ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 77 65				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 67 ee				ld hl, (input_start) 
0e98 3a 55 ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 69 ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 64 ee				ld a, (input_at_pos) 
0ea9 32 62 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 55 ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 69 ee				ld (input_ptr), hl 
0ed1 3a 62 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 62 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 69 ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 69 ee				ld (input_ptr), hl 
0ef0 3a 62 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 62 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 55 ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 55 ee				ld (input_cursor), a 
0f09			 
0f09 2a 69 ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 69 ee				ld (input_ptr), hl 
0f10					 
0f10 3a 62 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 62 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 5f ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 60 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 55 ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 55 ee				ld (input_cursor), a 
0f37			 
0f37 3a 62 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 62 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 69 ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 69 ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 5f ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 60 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 67 ee				ld hl, (input_start) 
0f59 22 69 ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 64 ee				ld a, (input_at_pos) 
0f5f 32 62 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 55 ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 e8 e5				ld hl, os_cli_cmd 
0f6a 11 e7 e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 55 ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 55 ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 69 ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 69 ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 62 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 62 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 5f ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 60 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 62 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 55 ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 62 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 62 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 69 ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 69 ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 69 ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 69 ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 5f ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 60 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 67 ee				ld hl, (input_start) 
0ffa 3a 5a ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 5a ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 55 ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 55 ee				ld (input_cursor), a 
1022			 
1022 3a 62 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 62 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 67 ee				ld hl, (input_start) 
102f 3a 5a ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1042 22 67 ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 69 ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 66 ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 55 ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 69 ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c1 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 64 ee				ld a,(input_at_pos) 
1063 cd 8c 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 67 ee	            	LD   de, (input_start) 
106a cd 81 64		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 77 65				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 69 ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c1 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 69 ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 69 ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 69 ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 69 ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 69 ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c1 e2			ld hl, scratch 
10bd 11 e7 e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c1 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 69 ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 35 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 f5 e2			ld (scratch+52),a 
11be				 
11be 21 f3 e2			ld hl,scratch+50 
11c1 22 e4 e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				call bp_on 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 9f 65		      ld    HL, heap_start 
128e 22 9a 65		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 9c 65		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a4 e2		      ld    HL, heap_start+heap_size-4 
129a 22 9f 65		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 05 7d		      ld    HL, heap_size-4 
12a0 22 a1 65		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 9a 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 9a 65		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			; Now handled by SPI  
1447			;if SOUND_ENABLE  
1447			;	include "firmware_sound.asm"  
1447			;endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 6d 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452			;	cp 1 
1452			;	call z, .savetostore 
1452			 
1452 fe 01			cp 1 
1454			if STARTUP_V1 
1454 cc 83 14			call z, .selautoload 
1457			endif 
1457			 
1457			if STARTUP_V2 
1457				call z, .enautoload 
1457			endif 
1457 fe 02			cp 2 
1459 cc 79 14			call z, .disautoload 
145c			;	cp 3 
145c			;	call z, .selbank 
145c fe 03			cp 3 
145e cc a1 14			call z, .debug_tog 
1461 fe 04			cp 4 
1463 cc ef 15			call z, .bpsgo 
1466 fe 05			cp 5 
1468 cc ca 14			call z, hardware_diags 
146b			if STARTUP_V2 
146b				cp 6 
146b				call z, create_startup 
146b			endif 
146b 18 da			jr config 
146d			 
146d			.configmn: 
146d			;	dw prom_c3 
146d dd 17			dw prom_c2 
146f f2 17			dw prom_c2a 
1471			;	dw prom_c2b 
1471			;	dw prom_c4 
1471 11 18			dw prom_m4 
1473 2c 18			dw prom_m4b 
1475 34 18			dw prom_c1 
1477			if STARTUP_V2 
1477				dw prom_c9 
1477			endif 
1477 00 00			dw 0 
1479				 
1479			 
1479			if STARTUP_V2 
1479			.enautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 1 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479				ld hl, prom_notav 
1479				ld de, prom_empty 
1479				call info_panel 
1479				endif 
1479			 
1479			 
1479				ret 
1479			endif 
1479			 
1479			.disautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 0 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479 21 43 18			ld hl, prom_notav 
147c 11 59 18			ld de, prom_empty 
147f cd 4b 0b			call info_panel 
1482				endif 
1482			 
1482			 
1482 c9				ret 
1483			 
1483			if STARTUP_V1 
1483			 
1483			; Select auto start 
1483			 
1483			.selautoload: 
1483			 
1483				 
1483				if STORAGE_SE 
1483			 
1483					call config_dir 
1483				        ld hl, scratch 
1483					ld a, 0 
1483					call menu 
1483			 
1483					cp 0 
1483					ret z 
1483			 
1483					dec a 
1483			 
1483			 
1483					; locate menu option 
1483			 
1483					ld hl, scratch 
1483					call table_lookup 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALl" 
1483						CALLMONITOR 
1483					endif 
1483					; with the pointer to the menu it, the byte following the zero term is the file id 
1483			 
1483					ld a, 0 
1483					ld bc, 50   ; max of bytes to look at 
1483					cpir  
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALb" 
1483						CALLMONITOR 
1483					endif 
1483					;inc hl 
1483			 
1483					ld a, (hl)   ; file id 
1483					 
1483				        ; save bank and file ids 
1483			 
1483					push af 
1483			 
1483			; TODO need to save to block 0 on bank 1	 
1483			 
1483					call storage_get_block_0 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "AL0" 
1483						CALLMONITOR 
1483					endif 
1483					pop af 
1483			 
1483					ld (store_page+STORE_0_FILERUN),a 
1483					 
1483					; save bank id 
1483			 
1483					ld a,(spi_device) 
1483					ld (store_page+STORE_0_BANKRUN),a 
1483			 
1483					; enable auto run of store file 
1483			 
1483					ld a, 1 
1483					ld (store_page+STORE_0_AUTOFILE),a 
1483			 
1483					; save buffer 
1483			 
1483					ld hl, 0 
1483					ld de, store_page 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALw" 
1483						CALLMONITOR 
1483					endif 
1483				call storage_write_block	 ; save update 
1483			  
1483			 
1483			 
1483			 
1483					ld hl, scratch 
1483					call config_fdir 
1483			 
1483				else 
1483			 
1483 21 43 18			ld hl, prom_notav 
1486 11 59 18			ld de, prom_empty 
1489 cd 4b 0b			call info_panel 
148c			 
148c				endif 
148c c9				ret 
148d			endif 
148d			 
148d			 
148d			; Select storage bank 
148d			 
148d			.selbank: 
148d			 
148d			;	if STORAGE_SE 
148d			;	else 
148d			 
148d 21 43 18			ld hl, prom_notav 
1490 11 59 18			ld de, prom_empty 
1493 cd 4b 0b			call info_panel 
1496			;	endif 
1496				 
1496 c9				ret 
1497			 
1497			if STORAGE_SE 
1497			 
1497			.config_ldir:   
1497				; Load storage bank labels into menu array 
1497			 
1497				 
1497			 
1497			 
1497				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497			;	if STORAGE_SE 
1497			; 
1497			;		call config_dir 
1497			;	        ld hl, scratch 
1497			;		ld a, 0 
1497			;		call menu 
1497			;		 
1497			;		ld hl, scratch 
1497			;		call config_fdir 
1497			; 
1497			;	else 
1497			 
1497 21 43 18			ld hl, prom_notav 
149a 11 59 18			ld de, prom_empty 
149d cd 4b 0b			call info_panel 
14a0			 
14a0			;	endif 
14a0			 
14a0 c9				ret 
14a1			 
14a1			if STARTUP_V2 
14a1			 
14a1			create_startup: 
14a1			 
14a1				ld a, 0 
14a1				ld hl, .crstart 
14a1				call menu 
14a1			 
14a1				cp 0 
14a1				ret z 
14a1			 
14a1				cp 1 
14a1				call z, .genlsword 
14a1				cp 2 
14a1				call z, .genedword 
14a1			 
14a1				cp 3 
14a1				call z, .gendemword 
14a1			 
14a1				cp 4 
14a1				call z, .genutlword 
14a1				cp 5 
14a1				call z, .genspiword 
14a1				cp 6 
14a1				call z, .genkeyword 
14a1				cp 7 
14a1				call z, .gensoundword 
14a1				jr create_startup 
14a1			 
14a1			.gensoundword: 
14a1				ld hl, crs_sound 
14a1				ld de, .soundworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genlsword: 
14a1				ld hl, crs_s1 
14a1				ld de, .lsworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genedword: 
14a1				ld de, .edworddef 
14a1				ld hl, crs_s2 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.gendemword: 
14a1				ld de, .demoworddef 
14a1				ld hl, crs_s3 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genutlword: 
14a1				ld hl, crs_s4 
14a1				ld de, .utilwordef 
14a1				call .genfile 
14a1				ret 
14a1			.genspiword: 
14a1				ld hl, crs_s5 
14a1				ld de, .spiworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genkeyword: 
14a1				ld hl, crs_s6 
14a1				ld de, .keyworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			; hl - points to file name 
14a1			; de - points to strings to add to file 
14a1			 
14a1			.genfile: 
14a1				push hl 
14a1				push de 
14a1			 
14a1				call clear_display 
14a1				ld a, display_row_1 
14a1				ld de, .genfiletxt 
14a1				call str_at_display 
14a1				call update_display 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1			 
14a1				push de 
14a1				call storage_create 
14a1				; id in hl 
14a1				pop de   ; table of strings to add 
14a1			 
14a1			.genloop: 
14a1			 
14a1				push hl ; save id for next time around 
14a1				push de ; save de for next time around 
14a1			 
14a1				ex de, hl 
14a1				call loadwordinhl 
14a1				ex de, hl 
14a1			 
14a1				; need hl to be the id 
14a1				; need de to be the string ptr 
14a1				 
14a1				call storage_append 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1				inc de 
14a1				inc de 
14a1			 
14a1				ld a,(de) 
14a1				cp 0 
14a1				jr nz, .genloop 
14a1				inc de 
14a1				ld a, (de) 
14a1				dec de 
14a1				cp 0 
14a1				jr nz, .genloop	 
14a1			 
14a1				ret 
14a1			 
14a1			.genfiletxt:  db "Creating file...",0 
14a1			 
14a1			.soundworddef: 
14a1				dw sound1 
14a1				dw sound2 
14a1				dw sound3 
14a1				dw sound4 
14a1				dw sound5 
14a1				dw sound6 
14a1				dw sound7 
14a1				dw sound8 
14a1				dw sound9 
14a1				dw 0 
14a1			 
14a1			.utilwordef: 
14a1				dw strncpy 
14a1				dw type 
14a1				dw clrstack 
14a1				dw longread 
14a1				dw start1 
14a1				dw start2 
14a1				dw start3b 
14a1				dw start3c 
14a1				dw list 
14a1				dw 0 
14a1			 
14a1			.lsworddef: 
14a1				dw start3b 
14a1				dw 0 
14a1			 
14a1			.edworddef: 
14a1				dw edit1 
14a1				dw edit2 
14a1				dw edit3 
14a1				dw 0 
14a1			 
14a1			.demoworddef: 
14a1				dw test5 
14a1				dw test6 
14a1				dw test7 
14a1				dw test8 
14a1				dw test9 
14a1				dw test10 
14a1				dw game1 
14a1				dw game1a 
14a1				dw game1b 
14a1				dw game1c 
14a1				dw game1d 
14a1				dw game1s 
14a1				dw game1t 
14a1				dw game1f 
14a1				dw game1z 
14a1				dw game1zz 
14a1				dw ssv2 
14a1				dw ssv3 
14a1				dw ssv4 
14a1				dw ssv5 
14a1				dw ssv1 
14a1				dw ssv1cpm	 
14a1				dw game2b 
14a1				dw game2bf 
14a1				dw game2mba 
14a1				dw game2mbas	 
14a1				dw game2mbht 
14a1				dw game2mbms 
14a1				dw game2mb 
14a1				dw game3w 
14a1				dw game3p 
14a1				dw game3sc 
14a1				dw game3vsi 
14a1				dw game3vs 
14a1				dw 0 
14a1			 
14a1			 
14a1			.spiworddef: 
14a1			 
14a1			    dw spi1 
14a1			    dw spi2 
14a1			    dw spi3 
14a1			    dw spi4 
14a1			    dw spi5 
14a1			    dw spi6 
14a1			    dw spi7 
14a1			 
14a1			    dw spi8 
14a1			    dw spi9 
14a1			    dw spi10 
14a1			    dw 0 
14a1			 
14a1			.keyworddef: 
14a1			 
14a1				dw keyup 
14a1				dw keydown 
14a1				dw keyleft 
14a1				dw keyright 
14a1				dw 	keyf1 
14a1				dw keyf2 
14a1				dw keyf3 
14a1				dw keyf4 
14a1				dw keyf5 
14a1				dw keyf6 
14a1				dw keyf7 
14a1				dw keyf8 
14a1				dw keyf9 
14a1				dw keyf10 
14a1				dw keyf11 
14a1				dw keyf12 
14a1				dw keytab 
14a1				dw keycr 
14a1				dw keyhome 
14a1				dw keyend 
14a1				dw keybs 
14a1				dw 0 
14a1			 
14a1			.crstart: 
14a1				dw crs_s1 
14a1				dw crs_s2 
14a1				dw crs_s3 
14a1				dw crs_s4 
14a1				dw crs_s5 
14a1				dw crs_s6 
14a1				dw crs_sound 
14a1				dw 0 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			if STORAGE_SE 
14a1			 
14a1			config_fdir: 
14a1				; using the scratch dir go through and release the memory allocated for each string 
14a1				 
14a1				ld hl, scratch 
14a1			.cfdir:	ld e,(hl) 
14a1				inc hl 
14a1				ld d,(hl) 
14a1				inc hl 
14a1			 
14a1				ex de, hl 
14a1				call ishlzero 
14a1				ret z     ; return on null pointer 
14a1				call free 
14a1				ex de, hl 
14a1				jr .cfdir 
14a1			 
14a1			 
14a1				ret 
14a1			 
14a1			 
14a1			config_dir: 
14a1			 
14a1				; for the config menus that need to build a directory of storage call this routine 
14a1				; it will construct a menu in scratch to pass to menu 
14a1			 
14a1				; open storage device 
14a1			 
14a1				; execute DIR to build a list of files and their ids into scratch in menu format 
14a1				; once the menu has finished then will need to call config_fdir to release the strings 
14a1				 
14a1				; c = number items 
14a1			 
14a1				 
14a1				call storage_get_block_0 
14a1			 
14a1				ld hl, store_page     ; get current id count 
14a1				ld b, (hl) 
14a1				ld c, 0    ; count of files   
14a1			 
14a1			 
14a1				ld hl, scratch 
14a1				ld (store_tmp2), hl    ; location to poke strings 
14a1			 
14a1				; check for empty drive 
14a1			 
14a1				ld a, 0 
14a1				cp b 
14a1				jp z, .dirdone 
14a1			 
14a1				 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdc" 
14a1						CALLMONITOR 
14a1					endif 
14a1			 
14a1			 
14a1			.diritem:	 
14a1				push bc 
14a1				; for each of the current ids do a search for them and if found push to stack 
14a1			 
14a1					ld hl, STORE_BLOCK_PHY 
14a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a1					ld e,b 
14a1			 
14a1					call storage_findnextid 
14a1			 
14a1			 
14a1					; if found hl will be non zero 
14a1			 
14a1					call ishlzero 
14a1					jr z, .dirnotfound 
14a1			 
14a1					; increase count 
14a1			 
14a1					pop bc	 
14a1					inc c 
14a1					push bc 
14a1					 
14a1			 
14a1					; get file header and push the file name 
14a1			 
14a1					ld de, store_page 
14a1					call storage_read_block 
14a1			 
14a1					; push file id to stack 
14a1				 
14a1					ld a, (store_page) 
14a1					ld h, 0 
14a1					ld l, a 
14a1			 
14a1					;call forth_push_numhl 
14a1					; TODO store id 
14a1			 
14a1					push hl 
14a1			 
14a1					; push extent count to stack  
14a1				 
14a1					ld hl, store_page+3 
14a1			 
14a1					; get file name length 
14a1			 
14a1					call strlenz   
14a1			 
14a1					inc hl   ; cover zero term 
14a1					inc hl  ; stick the id at the end of the area 
14a1			 
14a1					push hl 
14a1					pop bc    ; move length to bc 
14a1			 
14a1					call malloc 
14a1			 
14a1					; TODO save malloc area to scratch 
14a1			 
14a1					ex de, hl 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), e 
14a1					inc hl 
14a1					ld (hl), d 
14a1					inc hl 
14a1					ld (store_tmp2), hl 
14a1			 
14a1					 
14a1			 
14a1					;pop hl   ; get source 
14a1			;		ex de, hl    ; swap aronund	 
14a1			 
14a1					ld hl, store_page+3 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "CFd" 
14a1						CALLMONITOR 
14a1					endif 
14a1					ldir 
14a1			 
14a1					; de is past string, move back one and store id 
14a1					 
14a1					dec de 
14a1			 
14a1					; store file id 
14a1			 
14a1					pop hl 
14a1					ex de,hl 
14a1					ld (hl), e 
14a1			 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdi" 
14a1						CALLMONITOR 
14a1					endif 
14a1					 
14a1			.dirnotfound: 
14a1					pop bc     
14a1					djnz .diritem 
14a1				 
14a1			.dirdone:	 
14a1			 
14a1					ld a, 0 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), a 
14a1					inc hl 
14a1					ld (hl), a 
14a1					inc hl 
14a1					; push a count of the dir items found 
14a1			 
14a1			;		ld h, 0 
14a1			;		ld l, c 
14a1			 
14a1				ret 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			; Settings 
14a1			; Run  
14a1			 
14a1			 
14a1			 
14a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a1			;;hd_menu2:   db "        2: Editor",0   
14a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a1			;hd_menu3:   db "        3: Storage",0 
14a1			;hd_menu4:   db "0=quit  4: Debug",0 
14a1			;hd_don:     db "ON",0 
14a1			;hd_doff:     db "OFF",0 
14a1			; 
14a1			; 
14a1			; 
14a1			;hardware_diags_old:       
14a1			; 
14a1			;.diagmenu: 
14a1			;	call clear_display 
14a1			;	ld a, display_row_1 
14a1			;	ld de, hd_menu1 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_2 
14a1			;	ld de, hd_menu2 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_3 
14a1			;	ld de, hd_menu3 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a,  display_row_4 
14a1			;	ld de, hd_menu4 
14a1			;	call str_at_display 
14a1			; 
14a1			;	; display debug state 
14a1			; 
14a1			;	ld de, hd_don 
14a1			;	ld a, (os_view_disable) 
14a1			;	cp 0 
14a1			;	jr z, .distog 
14a1			;	ld de, hd_doff 
14a1			;.distog: ld a, display_row_4+17 
14a1			;	call str_at_display 
14a1			; 
14a1			;	call update_display 
14a1			; 
14a1			;	call cin_wait 
14a1			; 
14a1			; 
14a1			; 
14a1			;	cp '4' 
14a1			;	jr nz, .diagn1 
14a1			; 
14a1			;	; debug toggle 
14a1			; 
14a1			;	ld a, (os_view_disable) 
14a1			;	ld b, '*' 
14a1			;	cp 0 
14a1			;	jr z, .debtog 
14a1			;	ld b, 0 
14a1			;.debtog:	 
14a1			;	ld a,b 
14a1			;	ld (os_view_disable),a 
14a1			; 
14a1			;.diagn1: cp '0' 
14a1			;	 ret z 
14a1			; 
14a1			;;	cp '1' 
14a1			;;       jp z, matrix	 
14a1			;;   TODO keyboard matrix test 
14a1			; 
14a1			;	cp '2' 
14a1			;	jp z, .diagedit 
14a1			; 
14a1			;;	cp '6' 
14a1			;;	jp z, .menutest 
14a1			;;if ENABLE_BASIC 
14a1			;;	cp '6' 
14a1			;;	jp z, basic 
14a1			;;endif 
14a1			 ; 
14a1			;	jp .diagmenu 
14a1			; 
14a1			; 
14a1			;	ret 
14a1			 
14a1			 
14a1			.debug_tog: 
14a1 21 eb 14			ld hl, .menudebug 
14a4				 
14a4			;	ld a, (os_view_disable) 
14a4			;	cp '*' 
14a4 3a 6f ee			ld a,(debug_vector) 
14a7 fe c9			cp $C9   ; RET 
14a9 20 04			jr nz,.tdon  
14ab 3e 01			ld a, 1 
14ad 18 02			jr .tog1 
14af 3e 00		.tdon: ld a, 0 
14b1			 
14b1			.tog1: 
14b1 cd eb 0b			call menu 
14b4 fe 00			cp 0 
14b6 c8				ret z 
14b7 fe 01			cp 1    ; disable debug 
14b9 28 04			jr z, .dtog0 
14bb 3e 2a			ld a, '*' 
14bd 18 05			jr .dtogset 
14bf			.dtog0:  
14bf				;ld a, 0 
14bf cd dd 15			call bp_on 
14c2 18 dd			jr .debug_tog 
14c4			.dtogset:  
14c4				; ld (os_view_disable), a 
14c4 cd e9 15			call bp_off 
14c7 c3 a1 14			jp .debug_tog 
14ca			 
14ca			 
14ca			hardware_diags:       
14ca			 
14ca			.diagm: 
14ca 21 dd 14			ld hl, .menuitems 
14cd 3e 00			ld a, 0 
14cf cd eb 0b			call menu 
14d2			 
14d2 fe 00		         cp 0 
14d4 c8				 ret z 
14d5			 
14d5 fe 02			cp 2 
14d7 ca 36 15			jp z, .diagedit 
14da			 
14da			;	cp '6' 
14da			;	jp z, .menutest 
14da			;if ENABLE_BASIC 
14da			;	cp '6' 
14da			;	jp z, basic 
14da			;endif 
14da			  
14da c3 ca 14			jp .diagm 
14dd			 
14dd				 
14dd f1 14		.menuitems:   	dw .m1 
14df fc 14				dw .m2 
14e1 03 15				dw .m3 
14e3 0b 15				dw .m5 
14e5 11 15				dw .m5a 
14e7 1a 15				dw .m5b 
14e9 00 00				dw 0 
14eb			 
14eb			.menudebug: 
14eb 23 15				dw .m6 
14ed 2c 15				dw .m7 
14ef 00 00				dw 0 
14f1			 
14f1 .. 00		.m1:   db "Key Matrix",0 
14fc .. 00		.m2:   db "Editor",0 
1503 .. 00		.m3:   db "Storage",0 
150b .. 00		.m5:   db "Sound",0 
1511 .. 00		.m5a:  db "RAM Test",0 
151a .. 00		.m5b:  db "LCD Test",0 
1523			 
1523 .. 00		.m6:   db "Debug ON",0 
152c .. 00		.m7:   db "Debug OFF",0 
1536			 
1536			; debug editor 
1536			 
1536			.diagedit: 
1536			 
1536 21 c1 e2			ld hl, scratch 
1539			;	ld bc, 250 
1539			;	ldir 
1539				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1539 3e 00			ld a, 0 
153b 77				ld (hl), a 
153c 23				inc hl 
153d 77				ld (hl), a 
153e 23				inc hl 
153f 77				ld (hl), a 
1540			 
1540 cd ba 0b		        call clear_display 
1543 cd dd 0b			call update_display 
1546				;ld a, 1 
1546				;ld (hardware_diag), a 
1546			.diloop: 
1546 3e 00			ld a, display_row_1 
1548 0e 00			ld c, 0 
154a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154c 1e 28			ld e, 40 
154e			 
154e 21 c1 e2			ld hl, scratch	 
1551 cd 14 0e			call input_str 
1554			 
1554 3e 28			ld a, display_row_2 
1556 11 c1 e2			ld de, scratch 
1559 cd cd 0b			call str_at_display 
155c cd dd 0b			call update_display 
155f			 
155f c3 46 15			jp .diloop 
1562			 
1562			 
1562			; pass word in hl 
1562			; a has display location 
1562			display_word_at: 
1562 f5				push af 
1563 e5				push hl 
1564 7c				ld a,h 
1565 21 c6 e5			ld hl, os_word_scratch 
1568 cd e8 10			call hexout 
156b e1				pop hl 
156c 7d				ld a,l 
156d 21 c8 e5			ld hl, os_word_scratch+2 
1570 cd e8 10			call hexout 
1573 21 ca e5			ld hl, os_word_scratch+4 
1576 3e 00			ld a,0 
1578 77				ld (hl),a 
1579 11 c6 e5			ld de,os_word_scratch 
157c f1				pop af 
157d cd cd 0b				call str_at_display 
1580 c9				ret 
1581			 
1581			display_ptr_state: 
1581			 
1581				; to restore afterwards 
1581			 
1581 d5				push de 
1582 c5				push bc 
1583 e5				push hl 
1584 f5				push af 
1585			 
1585				; for use in here 
1585			 
1585			;	push bc 
1585			;	push de 
1585			;	push hl 
1585			;	push af 
1585			 
1585 cd ba 0b			call clear_display 
1588			 
1588 11 60 17			ld de, .ptrstate 
158b 3e 00			ld a, display_row_1 
158d cd cd 0b			call str_at_display 
1590			 
1590				; display debug step 
1590			 
1590			 
1590 11 6b ee			ld de, debug_mark 
1593 3e 26			ld a, display_row_1+display_cols-2 
1595 cd cd 0b			call str_at_display 
1598			 
1598				; display a 
1598 11 6a 17			ld de, .ptrcliptr 
159b 3e 28			ld a, display_row_2 
159d cd cd 0b			call str_at_display 
15a0			 
15a0 f1				pop af 
15a1 2a 40 ea			ld hl,(cli_ptr) 
15a4 3e 30			ld a, display_row_2+8 
15a6 cd 62 15			call display_word_at 
15a9			 
15a9			 
15a9				; display hl 
15a9			 
15a9			 
15a9 11 72 17			ld de, .ptrclioptr 
15ac 3e 32			ld a, display_row_2+10 
15ae cd cd 0b			call str_at_display 
15b1			; 
15b1			;	pop hl 
15b1 3e 35			ld a, display_row_2+13 
15b3 2a 3e ea			ld hl,(cli_origptr) 
15b6 cd 62 15			call display_word_at 
15b9			; 
15b9			;	 
15b9			;	; display de 
15b9			 
15b9			;	ld de, .regstatede 
15b9			;	ld a, display_row_3 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop de 
15b9			;	ld h,d 
15b9			;	ld l, e 
15b9			;	ld a, display_row_3+3 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display bc 
15b9			 
15b9			;	ld de, .regstatebc 
15b9			;	ld a, display_row_3+10 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop bc 
15b9			;	ld h,b 
15b9			;	ld l, c 
15b9			;	ld a, display_row_3+13 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display dsp 
15b9			 
15b9			;	ld de, .regstatedsp 
15b9			;	ld a, display_row_4 
15b9			;	call str_at_display 
15b9			 
15b9				 
15b9			;	ld hl,(cli_data_sp) 
15b9			;	ld a, display_row_4+4 
15b9			;	call display_word_at 
15b9			 
15b9				; display rsp 
15b9			 
15b9 11 a1 17			ld de, .regstatersp 
15bc 3e 82			ld a, display_row_4+10 
15be cd cd 0b			call str_at_display 
15c1			 
15c1				 
15c1 2a f2 e9			ld hl,(cli_ret_sp) 
15c4 3e 86			ld a, display_row_4+14 
15c6 cd 62 15			call display_word_at 
15c9			 
15c9 cd dd 0b			call update_display 
15cc			 
15cc cd f2 0a			call delay1s 
15cf cd f2 0a			call delay1s 
15d2 cd f2 0a			call delay1s 
15d5			 
15d5			 
15d5 cd be 1b			call next_page_prompt 
15d8			 
15d8				; restore  
15d8			 
15d8 f1				pop af 
15d9 e1				pop hl 
15da c1				pop bc 
15db d1				pop de 
15dc c9				ret 
15dd			 
15dd			; Update the break point vector so that the user can hook a new routine 
15dd			 
15dd			bp_on: 
15dd 3e c3			ld a, $c3    ; JP 
15df 32 6f ee			ld (debug_vector), a 
15e2 21 ef 15			ld hl, break_point_state 
15e5 22 70 ee			ld (debug_vector+1), hl 
15e8 c9				ret 
15e9			 
15e9			bp_off: 
15e9 3e c9			ld a, $c9    ; RET 
15eb 32 6f ee			ld (debug_vector), a 
15ee c9				ret 
15ef			 
15ef			 
15ef			break_point_state: 
15ef			;	push af 
15ef			; 
15ef			;	; see if disabled 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp '*' 
15ef			;	jr nz, .bpsgo 
15ef			;	pop af 
15ef			;	ret 
15ef			 
15ef			.bpsgo: 
15ef			;	pop af 
15ef f5				push af 
15f0 22 af e2			ld (os_view_hl), hl 
15f3 ed 53 ad e2		ld (os_view_de), de 
15f7 ed 43 ab e2		ld (os_view_bc), bc 
15fb e5				push hl 
15fc 6f				ld l, a 
15fd 26 00			ld h, 0 
15ff 22 b1 e2			ld (os_view_af),hl 
1602			 
1602 21 b1 ed				ld hl, display_fb0 
1605 22 cc eb				ld (display_fb_active), hl 
1608 e1				pop hl	 
1609			 
1609 3e 31			ld a, '1' 
160b fe 2a		.bps1:  cp '*' 
160d cc e9 15			call z, bp_off 
1610			;	jr nz, .bps1b 
1610			;	ld (os_view_disable),a 
1610 fe 31		.bps1b:  cp '1' 
1612 20 14			jr nz, .bps2 
1614			 
1614				; display reg 
1614			 
1614				 
1614			 
1614 3a b1 e2			ld a, (os_view_af) 
1617 2a af e2			ld hl, (os_view_hl) 
161a ed 5b ad e2		ld de, (os_view_de) 
161e ed 4b ab e2		ld bc, (os_view_bc) 
1622 cd bc 16			call display_reg_state 
1625 c3 a8 16			jp .bpschk 
1628			 
1628 fe 32		.bps2:  cp '2' 
162a 20 08			jr nz, .bps3 
162c				 
162c				; display hl 
162c 2a af e2			ld hl, (os_view_hl) 
162f cd a6 17			call display_dump_at_hl 
1632			 
1632 18 74			jr .bpschk 
1634			 
1634 fe 33		.bps3:  cp '3' 
1636 20 08			jr nz, .bps4 
1638			 
1638			        ; display de 
1638 2a ad e2			ld hl, (os_view_de) 
163b cd a6 17			call display_dump_at_hl 
163e			 
163e 18 68			jr .bpschk 
1640 fe 34		.bps4:  cp '4' 
1642 20 08			jr nz, .bps5 
1644			 
1644			        ; display bc 
1644 2a ab e2			ld hl, (os_view_bc) 
1647 cd a6 17			call display_dump_at_hl 
164a			 
164a 18 5c			jr .bpschk 
164c fe 35		.bps5:  cp '5' 
164e 20 08		        jr nz, .bps7 
1650			 
1650				; display cur ptr 
1650 2a 40 ea			ld hl, (cli_ptr) 
1653 cd a6 17			call display_dump_at_hl 
1656			 
1656 18 50			jr .bpschk 
1658 fe 36		.bps7:  cp '6' 
165a 20 08			jr nz, .bps8b 
165c				 
165c				; display cur orig ptr 
165c 2a 3e ea			ld hl, (cli_origptr) 
165f cd a6 17			call display_dump_at_hl 
1662 18 44			jr .bpschk 
1664 fe 37		.bps8b:  cp '7' 
1666 20 08			jr nz, .bps9 
1668				 
1668				; display dsp 
1668 2a ee e9			ld hl, (cli_data_sp) 
166b cd a6 17			call display_dump_at_hl 
166e			 
166e 18 38			jr .bpschk 
1670 fe 39		.bps9:  cp '9' 
1672 20 05			jr nz, .bps8c 
1674				 
1674				; display SP 
1674			;	ld hl, sp 
1674 cd a6 17			call display_dump_at_hl 
1677			 
1677 18 2f			jr .bpschk 
1679 fe 38		.bps8c:  cp '8' 
167b 20 08			jr nz, .bps8d 
167d				 
167d				; display rsp 
167d 2a f2 e9			ld hl, (cli_ret_sp) 
1680 cd a6 17			call display_dump_at_hl 
1683			 
1683 18 23			jr .bpschk 
1685 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1687 20 05			jr nz, .bps8 
1689 cd 8c 19			call monitor 
168c			 
168c 18 1a			jr .bpschk 
168e fe 30		.bps8:  cp '0' 
1690 20 16			jr nz, .bpschk 
1692			 
1692 21 10 ed				ld hl, display_fb1 
1695 22 cc eb				ld (display_fb_active), hl 
1698 cd dd 0b				call update_display 
169b			 
169b				;ld a, (os_view_af) 
169b 2a af e2			ld hl, (os_view_hl) 
169e ed 5b ad e2		ld de, (os_view_de) 
16a2 ed 4b ab e2		ld bc, (os_view_bc) 
16a6 f1				pop af 
16a7 c9				ret 
16a8			 
16a8			.bpschk:   
16a8 cd f2 0a			call delay1s 
16ab 3e 9f		ld a,display_row_4 + display_cols - 1 
16ad 11 bc 1b		        ld de, endprg 
16b0 cd cd 0b			call str_at_display 
16b3 cd dd 0b			call update_display 
16b6 cd 6f 65			call cin_wait 
16b9			 
16b9 c3 0b 16			jp .bps1 
16bc			 
16bc			 
16bc			display_reg_state: 
16bc			 
16bc				; to restore afterwards 
16bc			 
16bc d5				push de 
16bd c5				push bc 
16be e5				push hl 
16bf f5				push af 
16c0			 
16c0				; for use in here 
16c0			 
16c0 c5				push bc 
16c1 d5				push de 
16c2 e5				push hl 
16c3 f5				push af 
16c4			 
16c4 cd ba 0b			call clear_display 
16c7			 
16c7 11 7c 17			ld de, .regstate 
16ca 3e 00			ld a, display_row_1 
16cc cd cd 0b			call str_at_display 
16cf			 
16cf				; display debug step 
16cf			 
16cf			 
16cf 11 6b ee			ld de, debug_mark 
16d2 3e 25			ld a, display_row_1+display_cols-3 
16d4 cd cd 0b			call str_at_display 
16d7			 
16d7				; display a 
16d7 11 98 17			ld de, .regstatea 
16da 3e 28			ld a, display_row_2 
16dc cd cd 0b			call str_at_display 
16df			 
16df e1				pop hl 
16e0			;	ld h,0 
16e0			;	ld l, a 
16e0 3e 2b			ld a, display_row_2+3 
16e2 cd 62 15			call display_word_at 
16e5			 
16e5			 
16e5				; display hl 
16e5			 
16e5			 
16e5 11 8c 17			ld de, .regstatehl 
16e8 3e 32			ld a, display_row_2+10 
16ea cd cd 0b			call str_at_display 
16ed			 
16ed e1				pop hl 
16ee 3e 35			ld a, display_row_2+13 
16f0 cd 62 15			call display_word_at 
16f3			 
16f3				 
16f3				; display de 
16f3			 
16f3 11 90 17			ld de, .regstatede 
16f6 3e 50			ld a, display_row_3 
16f8 cd cd 0b			call str_at_display 
16fb			 
16fb e1				pop hl 
16fc			;	ld h,d 
16fc			;	ld l, e 
16fc 3e 53			ld a, display_row_3+3 
16fe cd 62 15			call display_word_at 
1701			 
1701			 
1701				; display bc 
1701			 
1701 11 94 17			ld de, .regstatebc 
1704 3e 5a			ld a, display_row_3+10 
1706 cd cd 0b			call str_at_display 
1709			 
1709 e1				pop hl 
170a			;	ld h,b 
170a			;	ld l, c 
170a 3e 5d			ld a, display_row_3+13 
170c cd 62 15			call display_word_at 
170f			 
170f			 
170f				; display dsp 
170f			 
170f 11 9c 17			ld de, .regstatedsp 
1712 3e 78			ld a, display_row_4 
1714 cd cd 0b			call str_at_display 
1717			 
1717				 
1717 2a ee e9			ld hl,(cli_data_sp) 
171a 3e 7c			ld a, display_row_4+4 
171c cd 62 15			call display_word_at 
171f			 
171f				; display rsp 
171f			 
171f 11 a1 17			ld de, .regstatersp 
1722 3e 82			ld a, display_row_4+10 
1724 cd cd 0b			call str_at_display 
1727			 
1727				 
1727 2a f2 e9			ld hl,(cli_ret_sp) 
172a 3e 86			ld a, display_row_4+14 
172c cd 62 15			call display_word_at 
172f			 
172f cd dd 0b			call update_display 
1732			 
1732			;	call delay1s 
1732			;	call delay1s 
1732			;	call delay1s 
1732			 
1732			 
1732			;	call next_page_prompt 
1732			 
1732				; restore  
1732			 
1732 f1				pop af 
1733 e1				pop hl 
1734 c1				pop bc 
1735 d1				pop de 
1736 c9				ret 
1737			 
1737 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1760 .. 00		.ptrstate:	db "Ptr State",0 
176a .. 00		.ptrcliptr:     db "cli_ptr",0 
1772 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177c .. 00		.regstate:	db "Reg State (1/0)",0 
178c .. 00		.regstatehl:	db "HL:",0 
1790 .. 00		.regstatede:	db "DE:",0 
1794 .. 00		.regstatebc:	db "BC:",0 
1798 .. 00		.regstatea:	db "A :",0 
179c .. 00		.regstatedsp:	db "DSP:",0 
17a1 .. 00		.regstatersp:	db "RSP:",0 
17a6			 
17a6			display_dump_at_hl: 
17a6 e5				push hl 
17a7 d5				push de 
17a8 c5				push bc 
17a9 f5				push af 
17aa			 
17aa 22 e4 e5			ld (os_cur_ptr),hl	 
17ad cd ba 0b			call clear_display 
17b0 cd c6 1a			call dumpcont 
17b3			;	call delay1s 
17b3			;	call next_page_prompt 
17b3			 
17b3			 
17b3 f1				pop af 
17b4 c1				pop bc 
17b5 d1				pop de 
17b6 e1				pop hl 
17b7 c9				ret 
17b8			 
17b8			;if ENABLE_BASIC 
17b8			;	include "nascombasic.asm" 
17b8			;	basic: 
17b8			;	include "forth/FORTH.ASM" 
17b8			;endif 
17b8			 
17b8			; eof 
17b8			 
17b8			 
# End of file firmware_diags.asm
17b8			  
17b8			include "firmware_prompts.asm"  
17b8			; Prompts  
17b8			 
17b8			; boot messages 
17b8			 
17b8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17cd .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17dd			 
17dd			 
17dd			; config menus 
17dd			 
17dd			;prom_c3: db "Add Dictionary To File",0 
17dd			 
17dd			if STARTUP_V1 
17dd .. 00		prom_c2: db "Select Autoload File",0 
17f2 .. 00		prom_c2a: db "Disable Autoload File", 0 
1808			endif 
1808			 
1808			if STARTUP_V2 
1808			prom_c2: db "Enable Autoload Files",0 
1808			prom_c2a: db "Disable Autoload Files", 0 
1808			 
1808			crs_s1: db "*ls-word", 0 
1808			crs_s2: db "*ed-word", 0 
1808			crs_s3: db "*Demo-Programs", 0 
1808			crs_s4: db "*Utils", 0 
1808			crs_s5: db "*SPI-Addons", 0 
1808			crs_s6: db "*Key-constants", 0 
1808			crs_sound: db "*Sound-Util", 0 
1808			 
1808			 
1808			 
1808			endif 
1808			;prom_c2b: db "Select Storage Bank",0 
1808 .. 00		prom_c4: db "Settings",0 
1811 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182c .. 00		prom_m4b:   db "Monitor",0 
1834 .. 00		prom_c1: db "Hardware Diags",0 
1843			 
1843			 
1843			if STARTUP_V2 
1843			prom_c9: db "Create Startup Files",0 
1843			endif 
1843			 
1843 .. 00		prom_notav:    db "Feature not available",0 
1859 .. 00		prom_empty:    db "",0 
185a			 
185a			; eof 
185a			 
# End of file firmware_prompts.asm
185a			  
185a			  
185a			; eof  
185a			  
# End of file firmware.asm
185a			 
185a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
185a			;if BASE_KEV  
185a			;baseram: equ 08000h 
185a			;endif 
185a			 
185a			;if BASE_SC114 
185a			;baseram:     equ    endofcode 
185a			;endif 
185a			 
185a			 
185a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
185a			 
185a			; start system 
185a			 
185a			coldstart: 
185a				; set sp 
185a				; di/ei 
185a			 
185a f3				di 
185b 31 00 f0			ld sp, tos 
185e cd 6d 64			call init_nmi 
1861			;	ei 
1861			 
1861				; init spinner 
1861 3e 00			ld a,0 
1863 32 c6 eb			ld (display_active), a 
1866			 
1866				; disable breakpoint by default 
1866			 
1866				;ld a,'*' 
1866			;	ld a,' ' 
1866			;	ld (os_view_disable),a 
1866			 
1866				; set break point vector as new break point on or off 
1866 cd e9 15			call bp_off 
1869			 
1869				; init hardware 
1869			 
1869				; init keyboard and screen hardware 
1869			 
1869 cd 1c 01			call hardware_init 
186c			 
186c			 
186c cd f2 0a			call delay1s 
186f 3e 58			ld a, display_row_3+8 
1871 11 03 01			ld de, buildtime 
1874 cd cd 0b			call str_at_display 
1877 cd dd 0b			call update_display 
187a			 
187a cd f2 0a			call delay1s 
187d cd f2 0a			call delay1s 
1880 cd f2 0a			call delay1s 
1883			 
1883				; detect if any keys are held down to enable breakpoints at start up 
1883			 
1883 cd 77 65			call cin  
1886 fe 00			cp 0 
1888 28 03			jr z, .nokeys 
188a			 
188a				;call hardware_diags 
188a cd 47 14			call config 
188d			 
188d			;	ld de, .bpen 
188d			;	ld a, display_row_4 
188d			;	call str_at_display 
188d			;	call update_display 
188d			; 
188d			;	ld a,0 
188d			;	ld (os_view_disable),a 
188d			; 
188d			;.bpwait: 
188d			;	call cin 
188d			;	cp 0 
188d			;	jr z, .bpwait 
188d			;	jr .nokeys 
188d			; 
188d			; 
188d			;.bpen:  db "Break points enabled!",0 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			.nokeys: 
188d			 
188d			 
188d				 
188d			 
188d			;jp  testkey 
188d			 
188d			;call storage_get_block_0 
188d			; 
188d			;ld hl, 0 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d				 
188d			;ld hl, 10 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			;stop:	nop 
188d			;	jp stop 
188d			 
188d			 
188d			 
188d			main: 
188d cd ba 0b			call clear_display 
1890 cd dd 0b			call update_display 
1893			 
1893			 
1893			 
1893			;	call testlcd 
1893			 
1893			 
1893			 
1893 cd c3 1f			call forth_init 
1896			 
1896			 
1896			warmstart: 
1896 cd 99 1f			call forth_warmstart 
1899			 
1899				; run startup word load 
1899			        ; TODO prevent this running at warmstart after crash  
1899			 
1899				if STARTUP_ENABLE 
1899			 
1899					if STARTUP_V1 
1899			 
1899						if STORAGE_SE 
1899							call forth_autoload 
1899						endif 
1899 cd bd 63					call forth_startup 
189c					endif 
189c			 
189c					if STARTUP_V2 
189c			 
189c						if STORAGE_SE 
189c							call forth_autoload 
189c						else 
189c							call forth_startup 
189c						endif 
189c			 
189c			 
189c					endif 
189c			 
189c				endif 
189c			 
189c				; show free memory after boot 
189c 11 27 19			ld de, freeram 
189f 3e 00			ld a, display_row_1 
18a1 cd cd 0b			call str_at_display 
18a4			 
18a4				; get current heap start after loading any uwords 
18a4			 
18a4 ed 5b be e5		ld de, (os_last_new_uword) 
18a8				;ex de, hl 
18a8			 
18a8			; Or use heap_size word???? 
18a8				;ld hl, heap_end 
18a8 21 09 7d			ld hl, heap_size 
18ab				;ld de, topusermem 
18ab				;ld de, heap_start 
18ab ed 52			sbc hl, de 
18ad				;push hl 
18ad				;ld a,h	         	 
18ad				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18ad				;call hexout 
18ad			   	;pop hl 
18ad			; 
18ad			;	ld a,l 
18ad			;	ld hl, os_word_scratch+2 
18ad			;	call hexout 
18ad			;	ld hl, os_word_scratch+4 
18ad			;	ld a, 0 
18ad			;	ld (hl),a 
18ad			 
18ad 21 c6 e5			ld hl, os_word_scratch 
18b0 cd f4 11			call uitoa_16 
18b3			 
18b3			 
18b3 11 c6 e5			ld de, os_word_scratch 
18b6 3e 0d			ld a, display_row_1 + 13 
18b8 cd cd 0b			call str_at_display 
18bb cd dd 0b			call update_display 
18be			 
18be			 
18be				;call demo 
18be			 
18be			 
18be				; init scratch input area for cli commands 
18be			 
18be 21 e8 e5			ld hl, os_cli_cmd 
18c1 3e 00			ld a,0 
18c3 77				ld (hl),a 
18c4 23				inc hl 
18c5 77				ld (hl),a 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cb			 
18cb 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18ce 32 e5 e5			ld (os_cur_ptr+1),a	 
18d1			 
18d1 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d4 32 c7 e5			ld (os_word_scratch+1),a	 
18d7				 
18d7			 
18d7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d7 21 e8 e5			ld hl, os_cli_cmd 
18da			 
18da 3e 00			ld a, 0		 ; init cli input 
18dc 77				ld (hl), a 
18dd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df			cli: 
18df				; show cli prompt 
18df				;push af 
18df				;ld a, 0 
18df				;ld de, prompt 
18df				;call str_at_display 
18df			 
18df				;call update_display 
18df				;pop af 
18df				;inc a 
18df				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18df 0e 00			ld c, 0 
18e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e3 1e 28			ld e, 40 
18e5			 
18e5 21 e8 e5			ld hl, os_cli_cmd 
18e8			 
18e8				STACKFRAME OFF $fefe $9f9f 
18e8				if DEBUG_STACK_IMB 
18e8					if OFF 
18e8						exx 
18e8						ld de, $fefe 
18e8						ld a, d 
18e8						ld hl, curframe 
18e8						call hexout 
18e8						ld a, e 
18e8						ld hl, curframe+2 
18e8						call hexout 
18e8						ld hl, $fefe 
18e8						push hl 
18e8						ld hl, $9f9f 
18e8						push hl 
18e8						exx 
18e8					endif 
18e8				endif 
18e8			endm 
# End of macro STACKFRAME
18e8			 
18e8 cd 14 0e			call input_str 
18eb			 
18eb				STACKFRAMECHK OFF $fefe $9f9f 
18eb				if DEBUG_STACK_IMB 
18eb					if OFF 
18eb						exx 
18eb						ld hl, $9f9f 
18eb						pop de   ; $9f9f 
18eb						call cmp16 
18eb						jr nz, .spnosame 
18eb						ld hl, $fefe 
18eb						pop de   ; $fefe 
18eb						call cmp16 
18eb						jr z, .spfrsame 
18eb						.spnosame: call showsperror 
18eb						.spfrsame: nop 
18eb						exx 
18eb					endif 
18eb				endif 
18eb			endm 
# End of macro STACKFRAMECHK
18eb			 
18eb				; copy input to last command 
18eb			 
18eb 21 e8 e5			ld hl, os_cli_cmd 
18ee 11 e7 e6			ld de, os_last_cmd 
18f1 01 ff 00			ld bc, 255 
18f4 ed b0			ldir 
18f6			 
18f6				; wipe current buffer 
18f6			 
18f6			;	ld a, 0 
18f6			;	ld hl, os_cli_cmd 
18f6			;	ld de, os_cli_cmd+1 
18f6			;	ld bc, 254 
18f6			;	ldir 
18f6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f6			;	call strcpy 
18f6			;	ld a, 0 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			 
18f6				; switch frame buffer to program  
18f6			 
18f6 21 10 ed				ld hl, display_fb1 
18f9 22 cc eb				ld (display_fb_active), hl 
18fc			 
18fc			;	nop 
18fc				STACKFRAME ON $fbfe $8f9f 
18fc				if DEBUG_STACK_IMB 
18fc					if ON 
18fc						exx 
18fc						ld de, $fbfe 
18fc						ld a, d 
18fc						ld hl, curframe 
18fc						call hexout 
18fc						ld a, e 
18fc						ld hl, curframe+2 
18fc						call hexout 
18fc						ld hl, $fbfe 
18fc						push hl 
18fc						ld hl, $8f9f 
18fc						push hl 
18fc						exx 
18fc					endif 
18fc				endif 
18fc			endm 
# End of macro STACKFRAME
18fc				; first time into the parser so pass over the current scratch pad 
18fc 21 e8 e5			ld hl,os_cli_cmd 
18ff				; tokenise the entered statement(s) in HL 
18ff cd 41 20			call forthparse 
1902			        ; exec forth statements in top of return stack 
1902 cd 81 20			call forthexec 
1905				;call forthexec_cleanup 
1905			;	call parsenext 
1905			 
1905				STACKFRAMECHK ON $fbfe $8f9f 
1905				if DEBUG_STACK_IMB 
1905					if ON 
1905						exx 
1905						ld hl, $8f9f 
1905						pop de   ; $8f9f 
1905						call cmp16 
1905						jr nz, .spnosame 
1905						ld hl, $fbfe 
1905						pop de   ; $fbfe 
1905						call cmp16 
1905						jr z, .spfrsame 
1905						.spnosame: call showsperror 
1905						.spfrsame: nop 
1905						exx 
1905					endif 
1905				endif 
1905			endm 
# End of macro STACKFRAMECHK
1905				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1905			 
1905 3e 78			ld a, display_row_4 
1907 11 38 19			ld de, endprog 
190a			 
190a cd dd 0b			call update_display		 
190d			 
190d cd be 1b			call next_page_prompt 
1910			 
1910				; switch frame buffer to cli 
1910			 
1910 21 b1 ed				ld hl, display_fb0 
1913 22 cc eb				ld (display_fb_active), hl 
1916			 
1916			 
1916 cd ba 0b		        call clear_display 
1919 cd dd 0b			call update_display		 
191c			 
191c 21 e8 e5			ld hl, os_cli_cmd 
191f			 
191f 3e 00			ld a, 0		 ; init cli input 
1921 77				ld (hl), a 
1922			 
1922				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1922			 
1922				; now on last line 
1922			 
1922				; TODO scroll screen up 
1922			 
1922				; TODO instead just clear screen and place at top of screen 
1922			 
1922			;	ld a, 0 
1922			;	ld (f_cursor_ptr),a 
1922			 
1922				;call clear_display 
1922				;call update_display 
1922			 
1922				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1922 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1924 c3 df 18			jp cli 
1927			 
1927 .. 00		freeram: db "Free bytes: ",0 
1934 ..			asc: db "1A2F" 
1938 .. 00		endprog: db "End prog...",0 
1944			 
1944			testenter2:   
1944 21 f3 e2			ld hl,scratch+50 
1947 22 e4 e5			ld (os_cur_ptr),hl 
194a c3 df 18			jp cli 
194d			 
194d			testenter:  
194d			 
194d 21 34 19			ld hl,asc 
1950			;	ld a,(hl) 
1950			;	call nibble2val 
1950 cd 3e 11			call get_byte 
1953			 
1953			 
1953			;	ld a,(hl) 
1953			;	call atohex 
1953			 
1953			;	call fourehexhl 
1953 32 f3 e2			ld (scratch+50),a 
1956			 
1956			 
1956			 
1956 21 36 19			ld hl,asc+2 
1959			;	ld a, (hl) 
1959			;	call nibble2val 
1959 cd 3e 11			call get_byte 
195c			 
195c			;	call fourehexhl 
195c 32 f5 e2			ld (scratch+52),a 
195f				 
195f 21 f3 e2			ld hl,scratch+50 
1962 22 e4 e5			ld (os_cur_ptr),hl 
1965 c3 df 18			jp cli 
1968			 
1968			enter:	 
1968 3a c5 e2			ld a,(scratch+4) 
196b fe 00			cp 0 
196d 28 0c			jr z, .entercont 
196f				; no, not a null term line so has an address to work out.... 
196f			 
196f 21 c3 e2			ld hl,scratch+2 
1972 cd 9e 11			call get_word_hl 
1975			 
1975 22 e4 e5			ld (os_cur_ptr),hl	 
1978 c3 df 18			jp cli 
197b			 
197b			 
197b			.entercont:  
197b			 
197b 21 c3 e2			ld hl, scratch+2 
197e cd 3e 11			call get_byte 
1981			 
1981 2a e4 e5		   	ld hl,(os_cur_ptr) 
1984 77					ld (hl),a 
1985 23					inc hl 
1986 22 e4 e5				ld (os_cur_ptr),hl 
1989				 
1989			; get byte  
1989			 
1989			 
1989 c3 df 18			jp cli 
198c			 
198c			 
198c			; basic monitor support 
198c			 
198c			monitor: 
198c				;  
198c cd ba 0b			call clear_display 
198f 3e 00			ld a, 0 
1991 11 e0 19			ld de, .monprompt 
1994 cd cd 0b			call str_at_display 
1997 cd dd 0b			call update_display 
199a			 
199a				; get a monitor command 
199a			 
199a 0e 00			ld c, 0     ; entry at top left 
199c 16 64			ld d, 100   ; max buffer size 
199e 1e 0f			ld e, 15    ; input scroll area 
19a0 3e 00			ld a, 0     ; init string 
19a2 21 bf e4			ld hl, os_input 
19a5 77				ld (hl), a 
19a6 23				inc hl 
19a7 77				ld (hl), a 
19a8 21 bf e4			ld hl, os_input 
19ab 3e 01			ld a, 1     ; init string 
19ad cd 14 0e			call input_str 
19b0			 
19b0 cd ba 0b		        call clear_display 
19b3 cd dd 0b			call update_display		 
19b6			 
19b6 3a bf e4			ld a, (os_input) 
19b9 cd 3c 12			call toUpper 
19bc fe 48		        cp 'H' 
19be ca 45 1a		        jp z, .monhelp 
19c1 fe 44			cp 'D'		; dump 
19c3 ca 78 1a			jp z, .mondump	 
19c6 fe 43			cp 'C'		; dump 
19c8 ca 92 1a			jp z, .moncdump	 
19cb fe 4d			cp 'M'		; dump 
19cd ca e2 19			jp z, .moneditstart 
19d0 fe 55			cp 'U'		; dump 
19d2 ca ee 19			jp z, .monedit	 
19d5 fe 47			cp 'G'		; dump 
19d7 ca 6e 1a			jp z, .monjump 
19da fe 51			cp 'Q'		; dump 
19dc c8				ret z	 
19dd			 
19dd			 
19dd				; TODO "S" to access symbol by name and not need the address 
19dd				; TODO "F" to find a string in memory 
19dd			 
19dd c3 8c 19			jp monitor 
19e0			 
19e0 .. 00		.monprompt: db ">", 0 
19e2			 
19e2			.moneditstart: 
19e2				; get starting address 
19e2			 
19e2 21 c1 e4			ld hl,os_input+2 
19e5 cd 9e 11			call get_word_hl 
19e8			 
19e8 22 e4 e5			ld (os_cur_ptr),hl	 
19eb			 
19eb c3 8c 19			jp monitor 
19ee			 
19ee			.monedit: 
19ee				; get byte to load 
19ee			 
19ee 21 c1 e4			ld hl,os_input+2 
19f1 cd 3e 11			call get_byte 
19f4			 
19f4				; get address to update 
19f4 2a e4 e5			ld hl, (os_cur_ptr) 
19f7			 
19f7				; update byte 
19f7			 
19f7 77				ld (hl), a 
19f8			 
19f8				; move to next address and save it 
19f8			 
19f8 23				inc hl 
19f9 22 e4 e5			ld (os_cur_ptr),hl	 
19fc			 
19fc c3 8c 19			jp monitor 
19ff			 
19ff			 
19ff .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a13 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a2f .. 00		.monhelptext3:  db "G-Call address",0 
1a3e .. 00		.monhelptext4:  db "Q-Quit",0 
1a45			        
1a45			.monhelp: 
1a45 3e 00			ld a, display_row_1 
1a47 11 ff 19		        ld de, .monhelptext1 
1a4a			 
1a4a cd cd 0b			call str_at_display 
1a4d 3e 28			ld a, display_row_2 
1a4f 11 13 1a		        ld de, .monhelptext2 
1a52					 
1a52 cd cd 0b			call str_at_display 
1a55 3e 50			ld a, display_row_3 
1a57 11 2f 1a		        ld de, .monhelptext3 
1a5a					 
1a5a cd cd 0b			call str_at_display 
1a5d 3e 78			ld a, display_row_4 
1a5f 11 3e 1a		        ld de, .monhelptext4 
1a62 cd cd 0b			call str_at_display 
1a65			 
1a65 cd dd 0b			call update_display		 
1a68			 
1a68 cd be 1b			call next_page_prompt 
1a6b c3 8c 19			jp monitor 
1a6e			 
1a6e			.monjump:    
1a6e 21 c1 e4			ld hl,os_input+2 
1a71 cd 9e 11			call get_word_hl 
1a74			 
1a74 e9				jp (hl) 
1a75 c3 8c 19			jp monitor 
1a78			 
1a78			.mondump:    
1a78 21 c1 e4			ld hl,os_input+2 
1a7b cd 9e 11			call get_word_hl 
1a7e			 
1a7e 22 e4 e5			ld (os_cur_ptr),hl	 
1a81 cd c6 1a			call dumpcont 
1a84 3e 78			ld a, display_row_4 
1a86 11 38 19			ld de, endprog 
1a89			 
1a89 cd dd 0b			call update_display		 
1a8c			 
1a8c cd be 1b			call next_page_prompt 
1a8f c3 8c 19			jp monitor 
1a92			.moncdump: 
1a92 cd c6 1a			call dumpcont 
1a95 3e 78			ld a, display_row_4 
1a97 11 38 19			ld de, endprog 
1a9a			 
1a9a cd dd 0b			call update_display		 
1a9d			 
1a9d cd be 1b			call next_page_prompt 
1aa0 c3 8c 19			jp monitor 
1aa3			 
1aa3			 
1aa3			; TODO symbol access  
1aa3			 
1aa3			.symbols:     ;; A list of symbols that can be called up  
1aa3 b1 ed			dw display_fb0 
1aa5 .. 00			db "fb0",0  
1aa9 7a ea		     	dw store_page 
1aab .. 00			db "store_page",0 
1ab6			 
1ab6			 
1ab6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ab6			 
1ab6 3a c2 e2			ld a,(scratch+1) 
1ab9 fe 00			cp 0 
1abb 28 09			jr z, dumpcont 
1abd			 
1abd				; no, not a null term line so has an address to work out.... 
1abd			 
1abd 21 c3 e2			ld hl,scratch+2 
1ac0 cd 9e 11			call get_word_hl 
1ac3			 
1ac3 22 e4 e5			ld (os_cur_ptr),hl	 
1ac6			 
1ac6			 
1ac6			 
1ac6			dumpcont: 
1ac6			 
1ac6				; dump bytes at ptr 
1ac6			 
1ac6			 
1ac6 3e 00			ld a, display_row_1 
1ac8 2a cc eb			ld hl, (display_fb_active) 
1acb cd e7 0d			call addatohl 
1ace cd f6 1a			call .dumpbyterow 
1ad1			 
1ad1 3e 28			ld a, display_row_2 
1ad3 2a cc eb			ld hl, (display_fb_active) 
1ad6 cd e7 0d			call addatohl 
1ad9 cd f6 1a			call .dumpbyterow 
1adc			 
1adc			 
1adc 3e 50			ld a, display_row_3 
1ade 2a cc eb			ld hl, (display_fb_active) 
1ae1 cd e7 0d			call addatohl 
1ae4 cd f6 1a			call .dumpbyterow 
1ae7			 
1ae7 3e 78			ld a, display_row_4 
1ae9 2a cc eb			ld hl, (display_fb_active) 
1aec cd e7 0d			call addatohl 
1aef cd f6 1a			call .dumpbyterow 
1af2			 
1af2 cd dd 0b			call update_display 
1af5			;		jp cli 
1af5 c9				ret 
1af6			 
1af6			.dumpbyterow: 
1af6			 
1af6				;push af 
1af6			 
1af6 e5				push hl 
1af7			 
1af7				; calc where to poke the ascii 
1af7			if display_cols == 20 
1af7				ld a, 16 
1af7			else 
1af7 3e 1f			ld a, 31 
1af9			endif 
1af9			 
1af9 cd e7 0d			call addatohl 
1afc 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1aff			 
1aff			 
1aff			; display decoding address 
1aff 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b02			 
1b02 7c				ld a,h 
1b03 e1				pop hl 
1b04 e5				push hl 
1b05			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b05 cd e8 10			call hexout 
1b08 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b0b			 
1b0b 7d				ld a,l 
1b0c e1				pop hl 
1b0d 23				inc hl 
1b0e 23				inc hl 
1b0f e5				push hl 
1b10			;	ld hl, os_word_scratch+2 
1b10 cd e8 10			call hexout 
1b13 e1				pop hl 
1b14 23				inc hl 
1b15 23				inc hl 
1b16				;ld hl, os_word_scratch+4 
1b16 3e 3a			ld a, ':' 
1b18 77				ld (hl),a 
1b19 23				inc hl 
1b1a				;ld a, 0 
1b1a				;ld (hl),a 
1b1a				;ld de, os_word_scratch 
1b1a				;pop af 
1b1a				;push af 
1b1a			;		ld a, display_row_2 
1b1a			;		call str_at_display 
1b1a			;		call update_display 
1b1a			 
1b1a			 
1b1a			;pop af 
1b1a			;	add 5 
1b1a			 
1b1a			if display_cols == 20 
1b1a				ld b, 4 
1b1a			else 
1b1a 06 08			ld b, 8 
1b1c			endif	 
1b1c			 
1b1c			.dumpbyte: 
1b1c c5				push bc 
1b1d e5				push hl 
1b1e			 
1b1e			 
1b1e 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b21 7e					ld a,(hl) 
1b22			 
1b22					; poke the ascii to display 
1b22 2a c6 e5				ld hl,(os_word_scratch) 
1b25 77					ld (hl),a 
1b26 23					inc hl 
1b27 22 c6 e5				ld (os_word_scratch),hl 
1b2a			 
1b2a					 
1b2a			 
1b2a			 
1b2a e1					pop hl 
1b2b e5					push hl 
1b2c			 
1b2c cd e8 10				call hexout 
1b2f			 
1b2f					 
1b2f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b32 23				inc hl 
1b33 22 e4 e5		   	ld (os_cur_ptr),hl 
1b36			 
1b36 e1					pop hl 
1b37 23					inc hl 
1b38 23					inc hl 
1b39 23					inc hl 
1b3a			 
1b3a			 
1b3a			 
1b3a					;ld a,0 
1b3a					;ld (os_word_scratch+2),a 
1b3a					;pop af 
1b3a					;push af 
1b3a			 
1b3a					;ld de, os_word_scratch 
1b3a					;call str_at_display 
1b3a			;		call update_display 
1b3a			;		pop af 
1b3a c1					pop bc 
1b3b c6 03				add 3 
1b3d 10 dd			djnz .dumpbyte 
1b3f			 
1b3f				 
1b3f			 
1b3f c9				ret 
1b40			 
1b40			jump:	 
1b40			 
1b40 21 c3 e2			ld hl,scratch+2 
1b43 cd 9e 11			call get_word_hl 
1b46				;ld hl,(scratch+2) 
1b46				;call fourehexhl 
1b46			 
1b46 22 e4 e5			ld (os_cur_ptr),hl	 
1b49			 
1b49 e9				jp (hl) 
1b4a			 
1b4a			 
1b4a			 
1b4a			; TODO implement a basic monitor mode to start with 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			; testing and demo code during development 
1b4a			 
1b4a			 
1b4a .. 00		str1: db "Enter some text...",0 
1b5d .. 00		clear: db "                    ",0 
1b72			 
1b72			demo: 
1b72			 
1b72			 
1b72			 
1b72			;	call update_display 
1b72			 
1b72				; init scratch input area for testing 
1b72 21 c1 e2			ld hl, scratch	 
1b75 3e 00			ld a,0 
1b77 77				ld (hl),a 
1b78			 
1b78			 
1b78 3e 28		            LD   A, display_row_2 
1b7a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b7a 11 4a 1b		            LD   DE, str1 
1b7d cd cd 0b			call str_at_display 
1b80			 
1b80			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b80			cloop:	 
1b80 3e 50		            LD   A, display_row_3 
1b82			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b82 11 5d 1b		            LD   DE, clear 
1b85			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b85 cd cd 0b				call str_at_display 
1b88 3e 78			ld a, display_row_4 
1b8a 11 ba 1b			ld de, prompt 
1b8d			 
1b8d cd cd 0b				call str_at_display 
1b90 cd dd 0b			call update_display 
1b93			 
1b93 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b95 16 0a			ld d, 10 
1b97 21 c1 e2			ld hl, scratch	 
1b9a cd 14 0e			call input_str 
1b9d			 
1b9d			;	call clear_display 
1b9d			;'	call update_display 
1b9d			 
1b9d 3e 00		            LD   A, display_row_1 
1b9f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b9f 11 5d 1b		            LD   DE, clear 
1ba2 cd cd 0b				call str_at_display 
1ba5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ba5 3e 00		            LD   A, display_row_1 
1ba7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ba7 11 c1 e2		            LD   DE, scratch 
1baa			;            CALL fLCD_Str       ;Display string pointed to by DE 
1baa cd cd 0b				call str_at_display 
1bad cd dd 0b			call update_display 
1bb0			 
1bb0 3e 00				ld a,0 
1bb2 21 c1 e2			ld hl, scratch 
1bb5 77				ld (hl),a 
1bb6			 
1bb6 00				nop 
1bb7 c3 80 1b			jp cloop 
1bba			 
1bba			 
1bba			 
1bba			; OS Prompt 
1bba			 
1bba .. 00		prompt: db ">",0 
1bbc .. 00		endprg: db "?",0 
1bbe			 
1bbe			 
1bbe			; handy next page prompt 
1bbe			next_page_prompt: 
1bbe e5				push hl 
1bbf d5				push de 
1bc0 f5				push af 
1bc1 c5				push bc 
1bc2			 
1bc2 3e 9f			ld a,display_row_4 + display_cols - 1 
1bc4 11 bc 1b		        ld de, endprg 
1bc7 cd cd 0b			call str_at_display 
1bca cd dd 0b			call update_display 
1bcd cd 6f 65			call cin_wait 
1bd0 c1				pop bc 
1bd1 f1				pop af 
1bd2 d1				pop de 
1bd3 e1				pop hl 
1bd4			 
1bd4			 
1bd4 c9				ret 
1bd5			 
1bd5			 
1bd5			; forth parser 
1bd5			 
1bd5			; My forth kernel 
1bd5			include "forth_kernel.asm" 
1bd5			; 
1bd5			; kernel to the forth OS 
1bd5			 
1bd5			DS_TYPE_STR: equ 1     ; string type 
1bd5			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bd5			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bd5			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bd5			 
1bd5			FORTH_PARSEV1: equ 0 
1bd5			FORTH_PARSEV2: equ 0 
1bd5			FORTH_PARSEV3: equ 0 
1bd5			FORTH_PARSEV4: equ 0 
1bd5			FORTH_PARSEV5: equ 1 
1bd5			 
1bd5			;if FORTH_PARSEV5 
1bd5			;	FORTH_END_BUFFER: equ 0 
1bd5			;else 
1bd5			FORTH_END_BUFFER: equ 127 
1bd5			;endif 
1bd5			 
1bd5			FORTH_TRUE: equ 1 
1bd5			FORTH_FALSE: equ 0 
1bd5			 
1bd5			if FORTH_PARSEV4 
1bd5			include "forth_stackops.asm" 
1bd5			endif 
1bd5			 
1bd5			if FORTH_PARSEV5 
1bd5			include "forth_stackopsv5.asm" 
1bd5			 
1bd5			; Stack operations for v5 parser on wards 
1bd5			; * DATA stack 
1bd5			; * LOOP stack 
1bd5			; * RETURN stack 
1bd5			 
1bd5			 
1bd5			 
1bd5			FORTH_CHK_DSP_UNDER: macro 
1bd5				push hl 
1bd5				push de 
1bd5				ld hl,(cli_data_sp) 
1bd5				ld de, cli_data_stack 
1bd5				call cmp16 
1bd5				jp c, fault_dsp_under 
1bd5				pop de 
1bd5				pop hl 
1bd5				endm 
1bd5			 
1bd5			 
1bd5			FORTH_CHK_RSP_UNDER: macro 
1bd5				push hl 
1bd5				push de 
1bd5				ld hl,(cli_ret_sp) 
1bd5				ld de, cli_ret_stack 
1bd5				call cmp16 
1bd5				jp c, fault_rsp_under 
1bd5				pop de 
1bd5				pop hl 
1bd5				endm 
1bd5			 
1bd5			FORTH_CHK_LOOP_UNDER: macro 
1bd5				push hl 
1bd5				push de 
1bd5				ld hl,(cli_loop_sp) 
1bd5				ld de, cli_loop_stack 
1bd5				call cmp16 
1bd5				jp c, fault_loop_under 
1bd5				pop de 
1bd5				pop hl 
1bd5				endm 
1bd5			 
1bd5			FORTH_ERR_TOS_NOTSTR: macro 
1bd5				; TOSO might need more for checks when used 
1bd5				push af 
1bd5				ld a,(hl) 
1bd5				cp DS_TYPE_STR 
1bd5				jp nz, type_faultn   
1bd5				pop af 
1bd5				endm 
1bd5			 
1bd5			FORTH_ERR_TOS_NOTNUM: macro 
1bd5				push af 
1bd5				ld a,(hl) 
1bd5				cp DS_TYPE_INUM 
1bd5				jp nz, type_faultn   
1bd5				pop af 
1bd5				endm 
1bd5			 
1bd5			 
1bd5			; increase data stack pointer and save hl to it 
1bd5				 
1bd5			FORTH_DSP_NEXT: macro 
1bd5				call macro_forth_dsp_next 
1bd5				endm 
1bd5			 
1bd5			 
1bd5			macro_forth_dsp_next: 
1bd5				if DEBUG_FORTH_STACK_GUARD 
1bd5 cd 9e 61				call check_stacks 
1bd8				endif 
1bd8 e5				push hl 
1bd9 d5				push de 
1bda eb				ex de,hl 
1bdb 2a ee e9			ld hl,(cli_data_sp) 
1bde 23				inc hl 
1bdf 23				inc hl 
1be0			 
1be0			; PARSEV5 
1be0 23				inc hl 
1be1 22 ee e9			ld (cli_data_sp),hl 
1be4 73				ld (hl), e 
1be5 23				inc hl 
1be6 72				ld (hl), d 
1be7 d1				pop de 
1be8 e1				pop hl 
1be9				if DEBUG_FORTH_STACK_GUARD 
1be9 cd 9e 61				call check_stacks 
1bec				endif 
1bec c9				ret 
1bed			 
1bed			 
1bed			; increase ret stack pointer and save hl to it 
1bed				 
1bed			FORTH_RSP_NEXT: macro 
1bed				call macro_forth_rsp_next 
1bed				endm 
1bed			 
1bed			macro_forth_rsp_next: 
1bed				if DEBUG_FORTH_STACK_GUARD 
1bed cd 9e 61				call check_stacks 
1bf0				endif 
1bf0 e5				push hl 
1bf1 d5				push de 
1bf2 eb				ex de,hl 
1bf3 2a f2 e9			ld hl,(cli_ret_sp) 
1bf6 23				inc hl 
1bf7 23				inc hl 
1bf8 22 f2 e9			ld (cli_ret_sp),hl 
1bfb 73				ld (hl), e 
1bfc 23				inc hl 
1bfd 72				ld (hl), d 
1bfe d1				pop de 
1bff e1				pop hl 
1c00				if DEBUG_FORTH_STACK_GUARD 
1c00 cd 9e 61				call check_stacks 
1c03				endif 
1c03 c9				ret 
1c04			 
1c04			; get current ret stack pointer and save to hl  
1c04				 
1c04			FORTH_RSP_TOS: macro 
1c04				call macro_forth_rsp_tos 
1c04				endm 
1c04			 
1c04			macro_forth_rsp_tos: 
1c04				;push de 
1c04 2a f2 e9			ld hl,(cli_ret_sp) 
1c07 cd 3f 1c			call loadhlptrtohl 
1c0a				;ld e, (hl) 
1c0a				;inc hl 
1c0a				;ld d, (hl) 
1c0a				;ex de, hl 
1c0a					if DEBUG_FORTH_WORDS 
1c0a			;			DMARK "RST" 
1c0a						CALLMONITOR 
1c0a cd 6f ee			call debug_vector  
1c0d				endm  
# End of macro CALLMONITOR
1c0d					endif 
1c0d				;pop de 
1c0d c9				ret 
1c0e			 
1c0e			; pop ret stack pointer 
1c0e				 
1c0e			FORTH_RSP_POP: macro 
1c0e				call macro_forth_rsp_pop 
1c0e				endm 
1c0e			 
1c0e			 
1c0e			macro_forth_rsp_pop: 
1c0e				if DEBUG_FORTH_STACK_GUARD 
1c0e			;		DMARK "RPP" 
1c0e cd 9e 61				call check_stacks 
1c11					FORTH_CHK_RSP_UNDER 
1c11 e5				push hl 
1c12 d5				push de 
1c13 2a f2 e9			ld hl,(cli_ret_sp) 
1c16 11 ac e9			ld de, cli_ret_stack 
1c19 cd 05 0e			call cmp16 
1c1c da b2 62			jp c, fault_rsp_under 
1c1f d1				pop de 
1c20 e1				pop hl 
1c21				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c21				endif 
1c21 e5				push hl 
1c22 2a f2 e9			ld hl,(cli_ret_sp) 
1c25			 
1c25			 
1c25				if FORTH_ENABLE_FREE 
1c25			 
1c25					; get pointer 
1c25			 
1c25					push de 
1c25					push hl 
1c25			 
1c25					ld e, (hl) 
1c25					inc hl 
1c25					ld d, (hl) 
1c25			 
1c25					ex de, hl 
1c25					call free 
1c25			 
1c25					pop hl 
1c25					pop de 
1c25			 
1c25			 
1c25				endif 
1c25			 
1c25			 
1c25 2b				dec hl 
1c26 2b				dec hl 
1c27 22 f2 e9			ld (cli_ret_sp), hl 
1c2a				; do stack underflow checks 
1c2a e1				pop hl 
1c2b				if DEBUG_FORTH_STACK_GUARD 
1c2b cd 9e 61				call check_stacks 
1c2e					FORTH_CHK_RSP_UNDER 
1c2e e5				push hl 
1c2f d5				push de 
1c30 2a f2 e9			ld hl,(cli_ret_sp) 
1c33 11 ac e9			ld de, cli_ret_stack 
1c36 cd 05 0e			call cmp16 
1c39 da b2 62			jp c, fault_rsp_under 
1c3c d1				pop de 
1c3d e1				pop hl 
1c3e				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c3e				endif 
1c3e c9				ret 
1c3f			 
1c3f			 
1c3f			 
1c3f			; routine to load word pointed to by hl into hl 
1c3f			 
1c3f			loadhlptrtohl: 
1c3f			 
1c3f d5				push de 
1c40 5e				ld e, (hl) 
1c41 23				inc hl 
1c42 56				ld d, (hl) 
1c43 eb				ex de, hl 
1c44 d1				pop de 
1c45			 
1c45 c9				ret 
1c46			 
1c46			 
1c46			 
1c46			 
1c46			 
1c46			; push a number held in HL onto the data stack 
1c46			; entry point for pushing a value when already in hl used in function above 
1c46			 
1c46			forth_push_numhl: 
1c46			 
1c46 e5				push hl    ; save value to push 
1c47			 
1c47			if DEBUG_FORTH_PUSH 
1c47				; see if disabled 
1c47			 
1c47			 
1c47 f5				push af 
1c48 3a 6f ee			ld a,(debug_vector) 
1c4b fe c9			cp $c9   ; ret 
1c4d			;	ld a, (os_view_disable) 
1c4d			;	cp '*' 
1c4d 28 34			jr z, .pskip2 
1c4f e5				push hl 
1c50 e5			push hl 
1c51 cd ba 0b			call clear_display 
1c54 e1			pop hl 
1c55 7c				ld a,h 
1c56 21 c6 e5			ld hl, os_word_scratch 
1c59 cd e8 10			call hexout 
1c5c e1				pop hl 
1c5d 7d				ld a,l 
1c5e 21 c8 e5			ld hl, os_word_scratch+2 
1c61 cd e8 10			call hexout 
1c64			 
1c64 21 ca e5			ld hl, os_word_scratch+4 
1c67 3e 00			ld a,0 
1c69 77				ld (hl),a 
1c6a 11 c6 e5			ld de,os_word_scratch 
1c6d 3e 28				ld a, display_row_2 
1c6f cd cd 0b				call str_at_display 
1c72 11 da 4c			ld de, .push_num 
1c75 3e 00			ld a, display_row_1 
1c77			 
1c77 cd cd 0b				call str_at_display 
1c7a			 
1c7a			 
1c7a cd dd 0b			call update_display 
1c7d cd f2 0a			call delay1s 
1c80 cd f2 0a			call delay1s 
1c83			.pskip2:  
1c83			 
1c83 f1				pop af 
1c84			endif	 
1c84			 
1c84			 
1c84				FORTH_DSP_NEXT 
1c84 cd d5 1b			call macro_forth_dsp_next 
1c87				endm 
# End of macro FORTH_DSP_NEXT
1c87			 
1c87 2a ee e9			ld hl, (cli_data_sp) 
1c8a			 
1c8a				; save item type 
1c8a 3e 02			ld a,  DS_TYPE_INUM 
1c8c 77				ld (hl), a 
1c8d 23				inc hl 
1c8e			 
1c8e				; get word off stack 
1c8e d1				pop de 
1c8f 7b				ld a,e 
1c90 77				ld (hl), a 
1c91 23				inc hl 
1c92 7a				ld a,d 
1c93 77				ld (hl), a 
1c94			 
1c94			if DEBUG_FORTH_PUSH 
1c94 2b				dec hl 
1c95 2b				dec hl 
1c96 2b				dec hl 
1c97						DMARK "PH5" 
1c97 f5				push af  
1c98 3a ac 1c			ld a, (.dmark)  
1c9b 32 6b ee			ld (debug_mark),a  
1c9e 3a ad 1c			ld a, (.dmark+1)  
1ca1 32 6c ee			ld (debug_mark+1),a  
1ca4 3a ae 1c			ld a, (.dmark+2)  
1ca7 32 6d ee			ld (debug_mark+2),a  
1caa 18 03			jr .pastdmark  
1cac ..			.dmark: db "PH5"  
1caf f1			.pastdmark: pop af  
1cb0			endm  
# End of macro DMARK
1cb0				CALLMONITOR 
1cb0 cd 6f ee			call debug_vector  
1cb3				endm  
# End of macro CALLMONITOR
1cb3			endif	 
1cb3			 
1cb3 c9				ret 
1cb4			 
1cb4			 
1cb4			; Push a string to stack pointed to by hl 
1cb4			 
1cb4			forth_push_str: 
1cb4			 
1cb4			if DEBUG_FORTH_PUSH 
1cb4						DMARK "PSQ" 
1cb4 f5				push af  
1cb5 3a c9 1c			ld a, (.dmark)  
1cb8 32 6b ee			ld (debug_mark),a  
1cbb 3a ca 1c			ld a, (.dmark+1)  
1cbe 32 6c ee			ld (debug_mark+1),a  
1cc1 3a cb 1c			ld a, (.dmark+2)  
1cc4 32 6d ee			ld (debug_mark+2),a  
1cc7 18 03			jr .pastdmark  
1cc9 ..			.dmark: db "PSQ"  
1ccc f1			.pastdmark: pop af  
1ccd			endm  
# End of macro DMARK
1ccd				CALLMONITOR 
1ccd cd 6f ee			call debug_vector  
1cd0				endm  
# End of macro CALLMONITOR
1cd0			endif	 
1cd0			    
1cd0 e5				push hl 
1cd1 e5				push hl 
1cd2			 
1cd2			;	ld a, 0   ; find end of string 
1cd2 cd 45 12			call strlenz 
1cd5			if DEBUG_FORTH_PUSH 
1cd5						DMARK "PQ2" 
1cd5 f5				push af  
1cd6 3a ea 1c			ld a, (.dmark)  
1cd9 32 6b ee			ld (debug_mark),a  
1cdc 3a eb 1c			ld a, (.dmark+1)  
1cdf 32 6c ee			ld (debug_mark+1),a  
1ce2 3a ec 1c			ld a, (.dmark+2)  
1ce5 32 6d ee			ld (debug_mark+2),a  
1ce8 18 03			jr .pastdmark  
1cea ..			.dmark: db "PQ2"  
1ced f1			.pastdmark: pop af  
1cee			endm  
# End of macro DMARK
1cee				CALLMONITOR 
1cee cd 6f ee			call debug_vector  
1cf1				endm  
# End of macro CALLMONITOR
1cf1			endif	 
1cf1 eb				ex de, hl 
1cf2 e1				pop hl   ; get ptr to start of string 
1cf3			if DEBUG_FORTH_PUSH 
1cf3						DMARK "PQ3" 
1cf3 f5				push af  
1cf4 3a 08 1d			ld a, (.dmark)  
1cf7 32 6b ee			ld (debug_mark),a  
1cfa 3a 09 1d			ld a, (.dmark+1)  
1cfd 32 6c ee			ld (debug_mark+1),a  
1d00 3a 0a 1d			ld a, (.dmark+2)  
1d03 32 6d ee			ld (debug_mark+2),a  
1d06 18 03			jr .pastdmark  
1d08 ..			.dmark: db "PQ3"  
1d0b f1			.pastdmark: pop af  
1d0c			endm  
# End of macro DMARK
1d0c				CALLMONITOR 
1d0c cd 6f ee			call debug_vector  
1d0f				endm  
# End of macro CALLMONITOR
1d0f			endif	 
1d0f 19				add hl,de 
1d10			if DEBUG_FORTH_PUSH 
1d10						DMARK "PQE" 
1d10 f5				push af  
1d11 3a 25 1d			ld a, (.dmark)  
1d14 32 6b ee			ld (debug_mark),a  
1d17 3a 26 1d			ld a, (.dmark+1)  
1d1a 32 6c ee			ld (debug_mark+1),a  
1d1d 3a 27 1d			ld a, (.dmark+2)  
1d20 32 6d ee			ld (debug_mark+2),a  
1d23 18 03			jr .pastdmark  
1d25 ..			.dmark: db "PQE"  
1d28 f1			.pastdmark: pop af  
1d29			endm  
# End of macro DMARK
1d29				CALLMONITOR 
1d29 cd 6f ee			call debug_vector  
1d2c				endm  
# End of macro CALLMONITOR
1d2c			endif	 
1d2c			 
1d2c 2b				dec hl    ; see if there is an optional trailing double quote 
1d2d 7e				ld a,(hl) 
1d2e fe 22			cp '"' 
1d30 20 03			jr nz, .strnoq 
1d32 3e 00			ld a, 0      ; get rid of double quote 
1d34 77				ld (hl), a 
1d35 23			.strnoq: inc hl 
1d36			 
1d36 3e 00			ld a, 0 
1d38 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d39			 
1d39 13				inc de ; add one for the type string 
1d3a 13				inc de ; add one for null term??? 
1d3b			 
1d3b				; tos is get string pointer again 
1d3b				; de contains space to allocate 
1d3b				 
1d3b d5				push de 
1d3c			 
1d3c eb				ex de, hl 
1d3d			 
1d3d				;push af 
1d3d			 
1d3d			if DEBUG_FORTH_PUSH 
1d3d						DMARK "PHm" 
1d3d f5				push af  
1d3e 3a 52 1d			ld a, (.dmark)  
1d41 32 6b ee			ld (debug_mark),a  
1d44 3a 53 1d			ld a, (.dmark+1)  
1d47 32 6c ee			ld (debug_mark+1),a  
1d4a 3a 54 1d			ld a, (.dmark+2)  
1d4d 32 6d ee			ld (debug_mark+2),a  
1d50 18 03			jr .pastdmark  
1d52 ..			.dmark: db "PHm"  
1d55 f1			.pastdmark: pop af  
1d56			endm  
# End of macro DMARK
1d56				CALLMONITOR 
1d56 cd 6f ee			call debug_vector  
1d59				endm  
# End of macro CALLMONITOR
1d59			endif	 
1d59 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d5c				if DEBUG_FORTH_MALLOC_GUARD 
1d5c cc 32 4d				call z,malloc_error 
1d5f				endif 
1d5f			 
1d5f				 
1d5f c1				pop bc    ; get length 
1d60 d1				pop de   ;  get string start    
1d61			 
1d61				; hl has destination from malloc 
1d61			 
1d61 eb				ex de, hl    ; prep for ldir 
1d62			 
1d62 d5				push de   ; save malloc area for DSP later 
1d63				;push hl   ; save malloc area for DSP later 
1d63			 
1d63			if DEBUG_FORTH_PUSH 
1d63						DMARK "PHc" 
1d63 f5				push af  
1d64 3a 78 1d			ld a, (.dmark)  
1d67 32 6b ee			ld (debug_mark),a  
1d6a 3a 79 1d			ld a, (.dmark+1)  
1d6d 32 6c ee			ld (debug_mark+1),a  
1d70 3a 7a 1d			ld a, (.dmark+2)  
1d73 32 6d ee			ld (debug_mark+2),a  
1d76 18 03			jr .pastdmark  
1d78 ..			.dmark: db "PHc"  
1d7b f1			.pastdmark: pop af  
1d7c			endm  
# End of macro DMARK
1d7c				CALLMONITOR 
1d7c cd 6f ee			call debug_vector  
1d7f				endm  
# End of macro CALLMONITOR
1d7f			endif	 
1d7f			 
1d7f			 
1d7f ed b0			ldir 
1d81			 
1d81			 
1d81				; push malloc to data stack     macro?????  
1d81			 
1d81				FORTH_DSP_NEXT 
1d81 cd d5 1b			call macro_forth_dsp_next 
1d84				endm 
# End of macro FORTH_DSP_NEXT
1d84			 
1d84				; save value and type 
1d84			 
1d84 2a ee e9			ld hl, (cli_data_sp) 
1d87			 
1d87				; save item type 
1d87 3e 01			ld a,  DS_TYPE_STR 
1d89 77				ld (hl), a 
1d8a 23				inc hl 
1d8b			 
1d8b				; get malloc word off stack 
1d8b d1				pop de 
1d8c 73				ld (hl), e 
1d8d 23				inc hl 
1d8e 72				ld (hl), d 
1d8f			 
1d8f			 
1d8f			 
1d8f			if DEBUG_FORTH_PUSH 
1d8f 2a ee e9			ld hl, (cli_data_sp) 
1d92						DMARK "PHS" 
1d92 f5				push af  
1d93 3a a7 1d			ld a, (.dmark)  
1d96 32 6b ee			ld (debug_mark),a  
1d99 3a a8 1d			ld a, (.dmark+1)  
1d9c 32 6c ee			ld (debug_mark+1),a  
1d9f 3a a9 1d			ld a, (.dmark+2)  
1da2 32 6d ee			ld (debug_mark+2),a  
1da5 18 03			jr .pastdmark  
1da7 ..			.dmark: db "PHS"  
1daa f1			.pastdmark: pop af  
1dab			endm  
# End of macro DMARK
1dab				CALLMONITOR 
1dab cd 6f ee			call debug_vector  
1dae				endm  
# End of macro CALLMONITOR
1dae			;	ex de,hl 
1dae			endif	 
1dae				; in case of spaces, skip the ptr past the copied string 
1dae				;pop af 
1dae				;ld (cli_origptr),hl 
1dae			 
1dae c9				ret 
1daf			 
1daf			 
1daf			 
1daf			; TODO ascii push input onto stack given hl to start of input 
1daf			 
1daf			; identify type 
1daf			; if starts with a " then a string 
1daf			; otherwise it is a number 
1daf			;  
1daf			; if a string 
1daf			;     scan for ending " to get length of string to malloc for + 1 
1daf			;     malloc 
1daf			;     put pointer to string on stack first byte flags as string 
1daf			; 
1daf			; else a number 
1daf			;    look for number format identifier 
1daf			;    $xx hex 
1daf			;    %xxxxx bin 
1daf			;    xxxxx decimal 
1daf			;    convert number to 16bit word.  
1daf			;    malloc word + 1 with flag to identiy as num 
1daf			;    put pointer to number on stack 
1daf			;   
1daf			;  
1daf			  
1daf			forth_apush: 
1daf				; kernel push 
1daf			 
1daf			if DEBUG_FORTH_PUSH 
1daf						DMARK "PSH" 
1daf f5				push af  
1db0 3a c4 1d			ld a, (.dmark)  
1db3 32 6b ee			ld (debug_mark),a  
1db6 3a c5 1d			ld a, (.dmark+1)  
1db9 32 6c ee			ld (debug_mark+1),a  
1dbc 3a c6 1d			ld a, (.dmark+2)  
1dbf 32 6d ee			ld (debug_mark+2),a  
1dc2 18 03			jr .pastdmark  
1dc4 ..			.dmark: db "PSH"  
1dc7 f1			.pastdmark: pop af  
1dc8			endm  
# End of macro DMARK
1dc8				CALLMONITOR 
1dc8 cd 6f ee			call debug_vector  
1dcb				endm  
# End of macro CALLMONITOR
1dcb			endif	 
1dcb				; identify input type 
1dcb			 
1dcb 7e				ld a,(hl) 
1dcc fe 22			cp '"' 
1dce 28 0a			jr z, .fapstr 
1dd0 fe 24			cp '$' 
1dd2 ca fa 1d			jp z, .faphex 
1dd5 fe 25			cp '%' 
1dd7 ca e2 1d			jp z, .fapbin 
1dda			;	cp 'b' 
1dda			;	jp z, .fabin 
1dda				; else decimal 
1dda			 
1dda				; TODO do decimal conversion 
1dda				; decimal is stored as a 16bit word 
1dda			 
1dda				; by default everything is a string if type is not detected 
1dda			.fapstr: ; 
1dda fe 22			cp '"' 
1ddc 20 01			jr nz, .strnoqu 
1dde 23				inc hl 
1ddf			.strnoqu: 
1ddf c3 b4 1c			jp forth_push_str 
1de2			 
1de2			 
1de2			 
1de2			.fapbin:    ; push a binary string.  
1de2 11 00 00			ld de, 0   ; hold a 16bit value 
1de5			 
1de5 23			.fapbinshift:	inc hl  
1de6 7e				ld a,(hl) 
1de7 fe 00			cp 0     ; done scanning  
1de9 28 0b			jr z, .fapbdone  	; got it in HL so push  
1deb			 
1deb				; left shift de 
1deb eb				ex de, hl	 
1dec 29				add hl, hl 
1ded			 
1ded				; is 1 
1ded fe 31			cp '1' 
1def 20 02			jr nz, .binzero 
1df1 cb 4d			bit 1, l 
1df3			.binzero: 
1df3 eb				ex de, hl	 ; save current de 
1df4 18 ef			jr .fapbinshift 
1df6			 
1df6			.fapbdone: 
1df6 eb				ex de, hl 
1df7 c3 46 1c			jp forth_push_numhl 
1dfa			 
1dfa			 
1dfa			.faphex:   ; hex is always stored as a 16bit word 
1dfa				; skip number prefix 
1dfa 23				inc hl 
1dfb				; turn ascii into number 
1dfb cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1dfe			 
1dfe c3 46 1c			jp forth_push_numhl 
1e01			 
1e01 00				 nop 
1e02			 
1e02			.fabin:   ; TODO bin conversion 
1e02			 
1e02			 
1e02 c9				ret 
1e03			 
1e03			 
1e03			; get either a string ptr or a 16bit word from the data stack 
1e03			 
1e03			FORTH_DSP: macro 
1e03				call macro_forth_dsp 
1e03				endm 
1e03			 
1e03			macro_forth_dsp: 
1e03				; data stack pointer points to current word on tos 
1e03			 
1e03 2a ee e9			ld hl,(cli_data_sp) 
1e06			 
1e06				if DEBUG_FORTH_PUSH 
1e06						DMARK "DSP" 
1e06 f5				push af  
1e07 3a 1b 1e			ld a, (.dmark)  
1e0a 32 6b ee			ld (debug_mark),a  
1e0d 3a 1c 1e			ld a, (.dmark+1)  
1e10 32 6c ee			ld (debug_mark+1),a  
1e13 3a 1d 1e			ld a, (.dmark+2)  
1e16 32 6d ee			ld (debug_mark+2),a  
1e19 18 03			jr .pastdmark  
1e1b ..			.dmark: db "DSP"  
1e1e f1			.pastdmark: pop af  
1e1f			endm  
# End of macro DMARK
1e1f			 
1e1f cd 65 4d				call display_data_sp 
1e22				;call break_point_state 
1e22				;rst 030h 
1e22				CALLMONITOR 
1e22 cd 6f ee			call debug_vector  
1e25				endm  
# End of macro CALLMONITOR
1e25				endif 
1e25			 
1e25 c9				ret 
1e26			 
1e26			; return hl to start of value on stack 
1e26			 
1e26			FORTH_DSP_VALUE: macro 
1e26				call macro_forth_dsp_value 
1e26				endm 
1e26			 
1e26			macro_forth_dsp_value: 
1e26			 
1e26				FORTH_DSP 
1e26 cd 03 1e			call macro_forth_dsp 
1e29				endm 
# End of macro FORTH_DSP
1e29			 
1e29 d5				push de 
1e2a			 
1e2a 23				inc hl ; skip type 
1e2b			 
1e2b 5e				ld e, (hl) 
1e2c 23				inc hl 
1e2d 56				ld d, (hl) 
1e2e eb				ex de,hl  
1e2f			 
1e2f d1				pop de 
1e30			 
1e30 c9				ret 
1e31			 
1e31			; return hl to start of value to second item on stack 
1e31			 
1e31			FORTH_DSP_VALUEM1: macro 
1e31				call macro_forth_dsp_value_m1 
1e31				endm 
1e31			 
1e31			macro_forth_dsp_value_m1: 
1e31			 
1e31				FORTH_DSP 
1e31 cd 03 1e			call macro_forth_dsp 
1e34				endm 
# End of macro FORTH_DSP
1e34			 
1e34 2b				dec hl 
1e35 2b				dec hl 
1e36			;	dec hl 
1e36			 
1e36 d5				push de 
1e37			 
1e37 5e				ld e, (hl) 
1e38 23				inc hl 
1e39 56				ld d, (hl) 
1e3a eb				ex de,hl  
1e3b			 
1e3b d1				pop de 
1e3c			 
1e3c c9				ret 
1e3d			 
1e3d				 
1e3d			 
1e3d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e3d			 
1e3d			FORTH_DSP_POP: macro 
1e3d				call macro_forth_dsp_pop 
1e3d				endm 
1e3d			 
1e3d			 
1e3d			; get the tos data type 
1e3d			 
1e3d			FORTH_DSP_TYPE:   macro 
1e3d			 
1e3d				;FORTH_DSP_VALUE 
1e3d				FORTH_DSP 
1e3d				 
1e3d				; hl points to value 
1e3d				; check type 
1e3d			 
1e3d				ld a,(hl) 
1e3d			 
1e3d				endm 
1e3d			 
1e3d			; load the tos value into hl 
1e3d			 
1e3d			 
1e3d			FORTH_DSP_VALUEHL:  macro 
1e3d				call macro_dsp_valuehl 
1e3d				endm 
1e3d			 
1e3d			 
1e3d			 
1e3d			macro_dsp_valuehl: 
1e3d				FORTH_DSP_VALUE 
1e3d cd 26 1e			call macro_forth_dsp_value 
1e40				endm 
# End of macro FORTH_DSP_VALUE
1e40			 
1e40				;FORTH_ERR_TOS_NOTNUM 
1e40			 
1e40				;inc hl   ; skip type id 
1e40			 
1e40			;	push de 
1e40			; 
1e40			;	ld e, (hl) 
1e40			;	inc hl 
1e40			;	ld d, (hl) 
1e40			;	ex de,hl  
1e40			 
1e40			;	pop de 
1e40			 
1e40				if DEBUG_FORTH_PUSH 
1e40						DMARK "DVL" 
1e40 f5				push af  
1e41 3a 55 1e			ld a, (.dmark)  
1e44 32 6b ee			ld (debug_mark),a  
1e47 3a 56 1e			ld a, (.dmark+1)  
1e4a 32 6c ee			ld (debug_mark+1),a  
1e4d 3a 57 1e			ld a, (.dmark+2)  
1e50 32 6d ee			ld (debug_mark+2),a  
1e53 18 03			jr .pastdmark  
1e55 ..			.dmark: db "DVL"  
1e58 f1			.pastdmark: pop af  
1e59			endm  
# End of macro DMARK
1e59				CALLMONITOR 
1e59 cd 6f ee			call debug_vector  
1e5c				endm  
# End of macro CALLMONITOR
1e5c				endif 
1e5c c9				ret 
1e5d			 
1e5d			forth_apushstrhl:      
1e5d				; push of string requires use of cli_origptr 
1e5d				; bodge use 
1e5d			 
1e5d				; get current cli_origptr, save, update with temp pointer  
1e5d ed 5b 3e ea		ld de, (cli_origptr) 
1e61 22 3e ea			ld (cli_origptr), hl 
1e64 d5				push de 
1e65 cd af 1d			call forth_apush 
1e68 d1				pop de 
1e69 ed 53 3e ea		ld (cli_origptr), de 
1e6d c9			        ret	 
1e6e			 
1e6e			 
1e6e			; increase loop stack pointer and save hl to it 
1e6e				 
1e6e			FORTH_LOOP_NEXT: macro 
1e6e				call macro_forth_loop_next 
1e6e				;nop 
1e6e				endm 
1e6e			 
1e6e			macro_forth_loop_next: 
1e6e				if DEBUG_FORTH_STACK_GUARD 
1e6e cd 9e 61				call check_stacks 
1e71				endif 
1e71 e5				push hl 
1e72 d5				push de 
1e73 eb				ex de,hl 
1e74 2a f0 e9			ld hl,(cli_loop_sp) 
1e77 23				inc hl 
1e78 23				inc hl 
1e79					if DEBUG_FORTH_WORDS 
1e79						DMARK "LNX" 
1e79 f5				push af  
1e7a 3a 8e 1e			ld a, (.dmark)  
1e7d 32 6b ee			ld (debug_mark),a  
1e80 3a 8f 1e			ld a, (.dmark+1)  
1e83 32 6c ee			ld (debug_mark+1),a  
1e86 3a 90 1e			ld a, (.dmark+2)  
1e89 32 6d ee			ld (debug_mark+2),a  
1e8c 18 03			jr .pastdmark  
1e8e ..			.dmark: db "LNX"  
1e91 f1			.pastdmark: pop af  
1e92			endm  
# End of macro DMARK
1e92						CALLMONITOR 
1e92 cd 6f ee			call debug_vector  
1e95				endm  
# End of macro CALLMONITOR
1e95					endif 
1e95 22 f0 e9			ld (cli_loop_sp),hl 
1e98 73				ld (hl), e 
1e99 23				inc hl 
1e9a 72				ld (hl), d 
1e9b d1				pop de    ; been reversed so save a swap on restore 
1e9c e1				pop hl 
1e9d				if DEBUG_FORTH_STACK_GUARD 
1e9d cd 9e 61				call check_stacks 
1ea0				endif 
1ea0 c9				ret 
1ea1			 
1ea1			; get current ret stack pointer and save to hl  
1ea1				 
1ea1			FORTH_LOOP_TOS: macro 
1ea1				call macro_forth_loop_tos 
1ea1				endm 
1ea1			 
1ea1			macro_forth_loop_tos: 
1ea1 d5				push de 
1ea2 2a f0 e9			ld hl,(cli_loop_sp) 
1ea5 5e				ld e, (hl) 
1ea6 23				inc hl 
1ea7 56				ld d, (hl) 
1ea8 eb				ex de, hl 
1ea9 d1				pop de 
1eaa c9				ret 
1eab			 
1eab			; pop loop stack pointer 
1eab				 
1eab			FORTH_LOOP_POP: macro 
1eab				call macro_forth_loop_pop 
1eab				endm 
1eab			 
1eab			 
1eab			macro_forth_loop_pop: 
1eab				if DEBUG_FORTH_STACK_GUARD 
1eab					DMARK "LPP" 
1eab f5				push af  
1eac 3a c0 1e			ld a, (.dmark)  
1eaf 32 6b ee			ld (debug_mark),a  
1eb2 3a c1 1e			ld a, (.dmark+1)  
1eb5 32 6c ee			ld (debug_mark+1),a  
1eb8 3a c2 1e			ld a, (.dmark+2)  
1ebb 32 6d ee			ld (debug_mark+2),a  
1ebe 18 03			jr .pastdmark  
1ec0 ..			.dmark: db "LPP"  
1ec3 f1			.pastdmark: pop af  
1ec4			endm  
# End of macro DMARK
1ec4 cd 9e 61				call check_stacks 
1ec7					FORTH_CHK_LOOP_UNDER 
1ec7 e5				push hl 
1ec8 d5				push de 
1ec9 2a f0 e9			ld hl,(cli_loop_sp) 
1ecc 11 2a e9			ld de, cli_loop_stack 
1ecf cd 05 0e			call cmp16 
1ed2 da b8 62			jp c, fault_loop_under 
1ed5 d1				pop de 
1ed6 e1				pop hl 
1ed7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ed7				endif 
1ed7 e5				push hl 
1ed8 2a f0 e9			ld hl,(cli_loop_sp) 
1edb 2b				dec hl 
1edc 2b				dec hl 
1edd 22 f0 e9			ld (cli_loop_sp), hl 
1ee0				; TODO do stack underflow checks 
1ee0 e1				pop hl 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1 cd 9e 61				call check_stacks 
1ee4					FORTH_CHK_LOOP_UNDER 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 2a f0 e9			ld hl,(cli_loop_sp) 
1ee9 11 2a e9			ld de, cli_loop_stack 
1eec cd 05 0e			call cmp16 
1eef da b8 62			jp c, fault_loop_under 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ef4				endif 
1ef4 c9				ret 
1ef5			 
1ef5			macro_forth_dsp_pop: 
1ef5			 
1ef5 e5				push hl 
1ef6			 
1ef6				; release malloc data 
1ef6			 
1ef6				if DEBUG_FORTH_STACK_GUARD 
1ef6 cd 9e 61				call check_stacks 
1ef9					FORTH_CHK_DSP_UNDER 
1ef9 e5				push hl 
1efa d5				push de 
1efb 2a ee e9			ld hl,(cli_data_sp) 
1efe 11 28 e8			ld de, cli_data_stack 
1f01 cd 05 0e			call cmp16 
1f04 da ac 62			jp c, fault_dsp_under 
1f07 d1				pop de 
1f08 e1				pop hl 
1f09				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f09				endif 
1f09				;ld hl,(cli_data_sp) 
1f09			if DEBUG_FORTH_DOT 
1f09				DMARK "DPP" 
1f09 f5				push af  
1f0a 3a 1e 1f			ld a, (.dmark)  
1f0d 32 6b ee			ld (debug_mark),a  
1f10 3a 1f 1f			ld a, (.dmark+1)  
1f13 32 6c ee			ld (debug_mark+1),a  
1f16 3a 20 1f			ld a, (.dmark+2)  
1f19 32 6d ee			ld (debug_mark+2),a  
1f1c 18 03			jr .pastdmark  
1f1e ..			.dmark: db "DPP"  
1f21 f1			.pastdmark: pop af  
1f22			endm  
# End of macro DMARK
1f22				CALLMONITOR 
1f22 cd 6f ee			call debug_vector  
1f25				endm  
# End of macro CALLMONITOR
1f25			endif	 
1f25			 
1f25			 
1f25			if FORTH_ENABLE_DSPPOPFREE 
1f25			 
1f25				FORTH_DSP 
1f25 cd 03 1e			call macro_forth_dsp 
1f28				endm 
# End of macro FORTH_DSP
1f28			 
1f28 7e				ld a, (hl) 
1f29 fe 01			cp DS_TYPE_STR 
1f2b 20 23			jr nz, .skippopfree 
1f2d			 
1f2d				FORTH_DSP_VALUEHL 
1f2d cd 3d 1e			call macro_dsp_valuehl 
1f30				endm 
# End of macro FORTH_DSP_VALUEHL
1f30 00				nop 
1f31			if DEBUG_FORTH_DOT 
1f31				DMARK "DPf" 
1f31 f5				push af  
1f32 3a 46 1f			ld a, (.dmark)  
1f35 32 6b ee			ld (debug_mark),a  
1f38 3a 47 1f			ld a, (.dmark+1)  
1f3b 32 6c ee			ld (debug_mark+1),a  
1f3e 3a 48 1f			ld a, (.dmark+2)  
1f41 32 6d ee			ld (debug_mark+2),a  
1f44 18 03			jr .pastdmark  
1f46 ..			.dmark: db "DPf"  
1f49 f1			.pastdmark: pop af  
1f4a			endm  
# End of macro DMARK
1f4a				CALLMONITOR 
1f4a cd 6f ee			call debug_vector  
1f4d				endm  
# End of macro CALLMONITOR
1f4d			endif	 
1f4d cd 78 13			call free 
1f50			.skippopfree: 
1f50				 
1f50			 
1f50			endif 
1f50			 
1f50			if DEBUG_FORTH_DOT_KEY 
1f50				DMARK "DP2" 
1f50				CALLMONITOR 
1f50			endif	 
1f50			 
1f50				; move pointer down 
1f50			 
1f50 2a ee e9			ld hl,(cli_data_sp) 
1f53 2b				dec hl 
1f54 2b				dec hl 
1f55			; PARSEV5 
1f55 2b				dec hl 
1f56 22 ee e9			ld (cli_data_sp), hl 
1f59			 
1f59				if DEBUG_FORTH_STACK_GUARD 
1f59 cd 9e 61				call check_stacks 
1f5c					FORTH_CHK_DSP_UNDER 
1f5c e5				push hl 
1f5d d5				push de 
1f5e 2a ee e9			ld hl,(cli_data_sp) 
1f61 11 28 e8			ld de, cli_data_stack 
1f64 cd 05 0e			call cmp16 
1f67 da ac 62			jp c, fault_dsp_under 
1f6a d1				pop de 
1f6b e1				pop hl 
1f6c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6c				endif 
1f6c			 
1f6c e1				pop hl 
1f6d			 
1f6d c9				ret 
1f6e			 
1f6e			getwordathl: 
1f6e				; hl points to an address 
1f6e				; load hl with the word at that address 
1f6e			 
1f6e d5				push de 
1f6f			 
1f6f 5e				ld e, (hl) 
1f70 23				inc hl 
1f71 56				ld d, (hl) 
1f72 eb				ex de, hl 
1f73			 
1f73 d1				pop de 
1f74 c9				ret 
1f75			 
1f75			 
1f75			 
1f75			 
1f75			 
1f75			; eof 
1f75			 
# End of file forth_stackopsv5.asm
1f75			endif 
1f75			 
1f75			loadwordinhl:	 
1f75			 
1f75 d5				push de 
1f76			 
1f76 5e				ld e, (hl) 
1f77 23				inc hl 
1f78 56				ld d, (hl) 
1f79 eb				ex de,hl  
1f7a			 
1f7a d1				pop de 
1f7b			 
1f7b c9				ret 
1f7c			 
1f7c			user_word_eol:  
1f7c				; hl contains the pointer to where to create a linked list item from the end 
1f7c				; of the user dict to continue on at the system word dict 
1f7c				 
1f7c				; poke the stub of the word list linked list to repoint to rom words 
1f7c			 
1f7c				; stub format 
1f7c				; db   word id 
1f7c				; dw    link to next word 
1f7c			        ; db char length of token 
1f7c				; db string + 0 term 
1f7c				; db exec code....  
1f7c			 
1f7c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f7e 77				ld (hl), a		; word id 
1f7f 23				inc hl 
1f80			 
1f80 11 4b 21			ld de, sysdict 
1f83 73				ld (hl), e		; next word link ie system dict 
1f84 23				inc hl 
1f85 72				ld (hl), d		; next word link ie system dict 
1f86 23				inc hl	 
1f87			 
1f87			;	ld (hl), sysdict		; next word link ie system dict 
1f87			;	inc hl 
1f87			;	inc hl 
1f87			 
1f87			;	inc hl 
1f87			;	inc hl 
1f87			 
1f87 3e 02			ld a, 2			; word length is 0 
1f89 77				ld (hl), a	 
1f8a 23				inc hl 
1f8b			 
1f8b 3e 7e			ld a, '~'			; word length is 0 
1f8d 77				ld (hl), a	 
1f8e 23				inc hl 
1f8f 3e 00			ld a, 0			; save empty word 
1f91 77				ld (hl), a 
1f92			 
1f92 c9				ret 
1f93			 
1f93				 
1f93			 
1f93			forthexec_cleanup: 
1f93				FORTH_RSP_POP 
1f93 cd 0e 1c			call macro_forth_rsp_pop 
1f96				endm 
# End of macro FORTH_RSP_POP
1f96 c9				ret 
1f97			 
1f97			forth_call_hl: 
1f97				; taking hl 
1f97 e5				push hl 
1f98 c9				ret 
1f99			 
1f99			; this is called to reset Forth system but keep existing uwords etc 
1f99			 
1f99			forth_warmstart: 
1f99				; setup stack over/under flow checks 
1f99				if DEBUG_FORTH_STACK_GUARD 
1f99 cd 84 61				call chk_stk_init 
1f9c				endif 
1f9c			 
1f9c				; init stack pointers  - * these stacks go upwards *  
1f9c 21 ac e9			ld hl, cli_ret_stack 
1f9f 22 f2 e9			ld (cli_ret_sp), hl	 
1fa2				; set bottom of stack 
1fa2 3e 00			ld a,0 
1fa4 77				ld (hl),a 
1fa5 23				inc hl 
1fa6 77				ld (hl),a 
1fa7			 
1fa7 21 28 e8			ld hl, cli_data_stack 
1faa 22 ee e9			ld (cli_data_sp), hl	 
1fad				; set bottom of stack 
1fad 3e 00			ld a,0 
1faf 77				ld (hl),a 
1fb0 23				inc hl 
1fb1 77				ld (hl),a 
1fb2			 
1fb2 21 2a e9			ld hl, cli_loop_stack 
1fb5 22 f0 e9			ld (cli_loop_sp), hl	 
1fb8				; set bottom of stack 
1fb8 3e 00			ld a,0 
1fba 77				ld (hl),a 
1fbb 23				inc hl 
1fbc 77				ld (hl),a 
1fbd			 
1fbd				; init extent of current open file 
1fbd			 
1fbd 3e 00			ld a, 0 
1fbf 32 6a ea			ld (store_openext), a 
1fc2			 
1fc2 c9				ret 
1fc3			 
1fc3			 
1fc3			 
1fc3			; Cold Start - this is called to setup the whole Forth system 
1fc3			 
1fc3			forth_init: 
1fc3			 
1fc3				; setup stack over/under flow checks 
1fc3			 
1fc3			;	if DEBUG_FORTH_STACK_GUARD 
1fc3			;		call chk_stk_init 
1fc3			;	endif 
1fc3			 
1fc3				; enable auto display updates (slow.....) 
1fc3			 
1fc3 3e 01			ld a, 1 
1fc5 32 3c ea			ld (cli_autodisplay), a 
1fc8			 
1fc8				; if storage is in use disable long reads for now 
1fc8 3e 00			ld a, 0 
1fca 32 75 ea			ld (store_longread), a 
1fcd			 
1fcd			 
1fcd				; show start up screen 
1fcd			 
1fcd cd ba 0b			call clear_display 
1fd0			 
1fd0 3e 00			ld a,0 
1fd2 32 5e ea			ld (f_cursor_ptr), a 
1fd5			 
1fd5				; set start of word list in start of ram - for use when creating user words 
1fd5			 
1fd5 21 90 65			ld hl, baseram 
1fd8 22 be e5			ld (os_last_new_uword), hl 
1fdb cd 7c 1f			call user_word_eol 
1fde				 
1fde			;		call display_data_sp 
1fde			;		call next_page_prompt 
1fde			 
1fde			 
1fde			 
1fde			 
1fde c9				ret 
1fdf			 
1fdf .. 00		.bootforth: db " Forth Kernel Init ",0 
1ff3			 
1ff3			; TODO push to stack 
1ff3			 
1ff3			;  
1ff3			 
1ff3			if FORTH_PARSEV2 
1ff3			 
1ff3			 
1ff3				include "forth_parserv2.asm" 
1ff3			 
1ff3			endif 
1ff3			 
1ff3			 
1ff3			; parse cli version 1 
1ff3			 
1ff3			if FORTH_PARSEV1 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv1.asm" 
1ff3			endif 
1ff3				 
1ff3			if FORTH_PARSEV3 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv3.asm" 
1ff3				include "forth_wordsv3.asm" 
1ff3			endif 
1ff3			 
1ff3			if FORTH_PARSEV4 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv4.asm" 
1ff3				include "forth_wordsv4.asm" 
1ff3			endif 
1ff3			 
1ff3			if FORTH_PARSEV5 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv5.asm" 
1ff3			 
1ff3			 
1ff3			; A better parser without using malloc and string copies all over the place.  
1ff3			; Exec in situ should be faster 
1ff3			 
1ff3			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1ff3			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1ff3			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1ff3			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1ff3			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1ff3			WORD_SYS_END: equ 0   ; Opcode for all user words 
1ff3			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1ff3			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1ff3			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1ff3			 
1ff3			; Core word preamble macro 
1ff3			 
1ff3			CWHEAD:   macro nxtword opcode lit len opflags 
1ff3				db WORD_SYS_CORE+opcode             
1ff3				; internal op code number 
1ff3				dw nxtword            
1ff3				; link to next dict word block 
1ff3				db len + 1 
1ff3				; literal length of dict word inc zero term 
1ff3				db lit,0              
1ff3				; literal dict word 
1ff3			        ; TODO db opflags        
1ff3				endm 
1ff3			 
1ff3			 
1ff3			NEXTW: macro  
1ff3				jp macro_next 
1ff3				endm 
1ff3			 
1ff3			macro_next: 
1ff3			if DEBUG_FORTH_PARSE_KEY 
1ff3				DMARK "NXT" 
1ff3				CALLMONITOR 
1ff3			endif	 
1ff3			;	inc hl  ; skip token null term  
1ff3 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ff7 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ffb 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ffe			if DEBUG_FORTH_PARSE_KEY 
1ffe				DMARK "}AA" 
1ffe				CALLMONITOR 
1ffe			endif	 
1ffe c3 01 21			jp execnext 
2001				;jp exec1 
2001			       
2001			 
2001			 
2001			; Another go at the parser to compile  
2001			 
2001			 
2001			; TODO rework parser to change all of the string words to byte tokens 
2001			; TODO do a search for  
2001			 
2001			; TODO first run normal parser to zero term sections 
2001			; TODO for each word do a token look up to get the op code 
2001			; TODO need some means to flag to the exec that this is a byte code form    
2001			 
2001			 
2001			forthcompile: 
2001			 
2001			; 
2001			; line parse: 
2001			;       parse raw input buffer 
2001			;       tokenise the words 
2001			;       malloc new copy (for looping etc) 
2001			;       copy to malloc + current pc in line to start of string and add line term 
2001			;       save on new rsp 
2001			; 
2001			 
2001			; hl to point to the line to tokenise 
2001			 
2001			;	push hl 
2001 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2004			 
2004			;	ld a,0		; string term on input 
2004			;	call strlent 
2004			 
2004			;	ld (os_tok_len), hl	 ; save string length 
2004			 
2004			;if DEBUG_FORTH_TOK 
2004			;	ex de,hl		 
2004			;endif 
2004			 
2004			;	pop hl 		; get back string pointer 
2004			 
2004			if DEBUG_FORTH_TOK 
2004						DMARK "TOc" 
2004				CALLMONITOR 
2004			endif 
2004 7e			.cptoken2:    ld a,(hl) 
2005 23				inc hl 
2006 fe 7f			cp FORTH_END_BUFFER 
2008 28 29			jr z, .cptokendone2 
200a fe 00			cp 0 
200c 28 25			jr z, .cptokendone2 
200e fe 22			cp '"' 
2010 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2012 fe 20			cp ' ' 
2014 20 ee			jr nz,  .cptoken2 
2016			 
2016			; TODO consume comments held between ( and ) 
2016			 
2016				; we have a space so change to zero term for dict match later 
2016 2b				dec hl 
2017 3e 00			ld a,0 
2019 77				ld (hl), a 
201a 23				inc hl 
201b 18 e7			jr .cptoken2 
201d				 
201d			 
201d			.cptokenstr2: 
201d				; skip all white space until either eol (because forgot to term) or end double quote 
201d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
201d				;inc hl ; skip current double quote 
201d 7e				ld a,(hl) 
201e 23				inc hl 
201f fe 22			cp '"' 
2021 28 e1			jr z, .cptoken2 
2023 fe 7f			cp FORTH_END_BUFFER 
2025 28 0c			jr z, .cptokendone2 
2027 fe 00			cp 0 
2029 28 08			jr z, .cptokendone2 
202b fe 20			cp ' ' 
202d 28 02			jr z, .cptmp2 
202f 18 ec			jr .cptokenstr2 
2031			 
2031			.cptmp2:	; we have a space so change to zero term for dict match later 
2031				;dec hl 
2031				;ld a,"-"	; TODO remove this when working 
2031				;ld (hl), a 
2031				;inc hl 
2031 18 ea			jr .cptokenstr2 
2033			 
2033			.cptokendone2: 
2033				;inc hl 
2033 3e 7f			ld a, FORTH_END_BUFFER 
2035 77				ld (hl),a 
2036 23				inc hl 
2037 3e 21			ld a, '!' 
2039 77				ld (hl),a 
203a			 
203a 2a c2 e5			ld hl,(os_tok_ptr) 
203d			         
203d			if DEBUG_FORTH_TOK 
203d						DMARK "Tc1" 
203d				CALLMONITOR 
203d			endif 
203d			 
203d				; push exec string to top of return stack 
203d				FORTH_RSP_NEXT 
203d cd ed 1b			call macro_forth_rsp_next 
2040				endm 
# End of macro FORTH_RSP_NEXT
2040 c9				ret 
2041			 
2041			; Another go at the parser need to simplify the process 
2041			 
2041			forthparse: 
2041			 
2041			; 
2041			; line parse: 
2041			;       parse raw input buffer 
2041			;       tokenise the words 
2041			;       malloc new copy (for looping etc) 
2041			;       copy to malloc + current pc in line to start of string and add line term 
2041			;       save on new rsp 
2041			; 
2041			 
2041			; hl to point to the line to tokenise 
2041			 
2041			;	push hl 
2041 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2044			 
2044			;	ld a,0		; string term on input 
2044			;	call strlent 
2044			 
2044			;	ld (os_tok_len), hl	 ; save string length 
2044			 
2044			;if DEBUG_FORTH_TOK 
2044			;	ex de,hl		 
2044			;endif 
2044			 
2044			;	pop hl 		; get back string pointer 
2044			 
2044			if DEBUG_FORTH_TOK 
2044						DMARK "TOK" 
2044				CALLMONITOR 
2044			endif 
2044 7e			.ptoken2:    ld a,(hl) 
2045 23				inc hl 
2046 fe 7f			cp FORTH_END_BUFFER 
2048 28 29			jr z, .ptokendone2 
204a fe 00			cp 0 
204c 28 25			jr z, .ptokendone2 
204e fe 22			cp '"' 
2050 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2052 fe 20			cp ' ' 
2054 20 ee			jr nz,  .ptoken2 
2056			 
2056			; TODO consume comments held between ( and ) 
2056			 
2056				; we have a space so change to zero term for dict match later 
2056 2b				dec hl 
2057 3e 00			ld a,0 
2059 77				ld (hl), a 
205a 23				inc hl 
205b 18 e7			jr .ptoken2 
205d				 
205d			 
205d			.ptokenstr2: 
205d				; skip all white space until either eol (because forgot to term) or end double quote 
205d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
205d				;inc hl ; skip current double quote 
205d 7e				ld a,(hl) 
205e 23				inc hl 
205f fe 22			cp '"' 
2061 28 e1			jr z, .ptoken2 
2063 fe 7f			cp FORTH_END_BUFFER 
2065 28 0c			jr z, .ptokendone2 
2067 fe 00			cp 0 
2069 28 08			jr z, .ptokendone2 
206b fe 20			cp ' ' 
206d 28 02			jr z, .ptmp2 
206f 18 ec			jr .ptokenstr2 
2071			 
2071			.ptmp2:	; we have a space so change to zero term for dict match later 
2071				;dec hl 
2071				;ld a,"-"	; TODO remove this when working 
2071				;ld (hl), a 
2071				;inc hl 
2071 18 ea			jr .ptokenstr2 
2073			 
2073			.ptokendone2: 
2073				;inc hl 
2073 3e 7f			ld a, FORTH_END_BUFFER 
2075 77				ld (hl),a 
2076 23				inc hl 
2077 3e 21			ld a, '!' 
2079 77				ld (hl),a 
207a			 
207a 2a c2 e5			ld hl,(os_tok_ptr) 
207d			         
207d			if DEBUG_FORTH_TOK 
207d						DMARK "TK1" 
207d				CALLMONITOR 
207d			endif 
207d			 
207d				; push exec string to top of return stack 
207d				FORTH_RSP_NEXT 
207d cd ed 1b			call macro_forth_rsp_next 
2080				endm 
# End of macro FORTH_RSP_NEXT
2080 c9				ret 
2081			 
2081			; 
2081			;	; malloc size + buffer pointer + if is loop flag 
2081			;	ld hl,(os_tok_len) 		 ; get string length 
2081			; 
2081			;	ld a,l 
2081			; 
2081			;	cp 0			; we dont want to use a null string 
2081			;	ret z 
2081			; 
2081			;;	add 3    ; prefix malloc with buffer for current word ptr 
2081			; 
2081			;	add 5     ; TODO when certain not over writing memory remove 
2081			; 
2081			;		 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKE" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	ld l,a 
2081			;	ld h,0 
2081			;;	push hl   ; save required space for the copy later 
2081			;	call malloc 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKM" 
2081			;	CALLMONITOR 
2081			;endif 
2081			;	if DEBUG_FORTH_MALLOC_GUARD 
2081			;		push af 
2081			;		call ishlzero 
2081			;;		ld a, l 
2081			;;		add h 
2081			;;		cp 0 
2081			;		pop af 
2081			;		 
2081			;		call z,malloc_error 
2081			;	endif 
2081			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2081			; 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKR" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	FORTH_RSP_NEXT 
2081			; 
2081			;	;inc hl	 ; go past current buffer pointer 
2081			;	;inc hl 
2081			;	;inc hl   ; and past if loop flag 
2081			;		; TODO Need to set flag  
2081			; 
2081			;	 
2081			;	 
2081			;	ex de,hl	; malloc is dest 
2081			;	ld hl, (os_tok_len) 
2081			;;	pop bc 
2081			;	ld c, l                
2081			;	ld b,0 
2081			;	ld hl, (os_tok_ptr) 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKT" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	; do str cpy 
2081			; 
2081			;	ldir      ; copy byte in hl to de 
2081			; 
2081			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			; 
2081			;			DMARK "TKY" 
2081			;	CALLMONITOR 
2081			;endif 
2081			;	;ld a,0 
2081			;	;ld a,FORTH_END_BUFFER 
2081			;	ex de, hl 
2081			;	;dec hl			 ; go back over the space delim at the end of word 
2081			;	;ld (hl),a 
2081			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2081			;	ld a,FORTH_END_BUFFER 
2081			;	ld (hl),a 
2081			;	inc hl 
2081			;	ld a,FORTH_END_BUFFER 
2081			;	ld (hl),a 
2081			; 
2081			;	; init the malloc area data 
2081			;	; set pc for in current area 
2081			;	;ld hl, (os_tok_malloc) 
2081			;	;inc hl 
2081			;	;inc hl 
2081			;	;inc hl 
2081			;	;ex de,hl 
2081			;	;ld hl, (os_tok_malloc) 
2081			;	;ld (hl),e 
2081			;	;inc hl 
2081			;	;ld (hl),d 
2081			; 
2081			; 
2081			;	ld hl,(os_tok_malloc) 
2081			;if DEBUG_FORTH_PARSE_KEY 
2081			;			DMARK "TKU" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	ret 
2081			 
2081			forthexec: 
2081			 
2081			; line exec: 
2081			; forth parser 
2081			 
2081			; 
2081			;       get current exec line on rsp 
2081			 
2081				FORTH_RSP_TOS 
2081 cd 04 1c			call macro_forth_rsp_tos 
2084				endm 
# End of macro FORTH_RSP_TOS
2084			 
2084			;       restore current pc - hl points to malloc of data 
2084			 
2084				;ld e, (hl) 
2084				;inc hl 
2084				;ld d, (hl) 
2084				;ex de,hl 
2084			 
2084			 
2084			exec1: 
2084 22 c2 e5			ld (os_tok_ptr), hl 
2087			 
2087				; copy our PC to working vars  
2087 22 40 ea			ld (cli_ptr), hl 
208a 22 3e ea			ld (cli_origptr), hl 
208d			 
208d 7e				ld a,(hl) 
208e fe 7f			cp FORTH_END_BUFFER 
2090 c8				ret z 
2091			 
2091				; skip any nulls 
2091			 
2091 fe 00			cp 0 
2093 20 03			jr nz, .execword 
2095 23				inc hl 
2096 18 ec			jr exec1 
2098			 
2098			 
2098			.execword: 
2098			 
2098			 
2098			 
2098			if DEBUG_FORTH_PARSE_KEY 
2098						DMARK "KYQ" 
2098				CALLMONITOR 
2098			endif 
2098			;       while at start of word: 
2098			; get start of dict (in user area first) 
2098			 
2098 21 90 65		ld hl, baseram 
209b			;ld hl, sysdict 
209b 22 42 ea		ld (cli_nextword),hl 
209e			;           match word at pc 
209e			;           exec word 
209e			;           or push to dsp 
209e			;           forward to next token 
209e			;           if line term pop rsp and exit 
209e			;        
209e			 
209e			if DEBUG_FORTH_PARSE_KEY 
209e						DMARK "KYq" 
209e				CALLMONITOR 
209e			endif 
209e			 
209e			; 
209e			; word comp 
209e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
209e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
209e			;    move to start of word  
209e			;    compare word to cli_token 
209e			 
209e			.execpnword:	; HL at start of a word in the dictionary to check 
209e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
209e			;	ld (cli_ptr), hl 
209e			 
209e 2a 42 ea			ld hl,(cli_nextword) 
20a1			 
20a1 cd 44 21			call forth_tok_next 
20a4			; tok next start here 
20a4			;	; TODO skip compiled symbol for now 
20a4			;	inc hl 
20a4			; 
20a4			;	; save pointer to next word 
20a4			; 
20a4			;	; hl now points to the address of the next word pointer  
20a4			;	ld e, (hl) 
20a4			;	inc hl 
20a4			;	ld d, (hl) 
20a4			;	inc l 
20a4			; 
20a4			;	ex de,hl 
20a4			;if DEBUG_FORTH_PARSE_NEXTWORD 
20a4			;	push bc 
20a4			;	ld bc, (cli_nextword) 
20a4			;			DMARK "NXW" 
20a4			;	CALLMONITOR 
20a4			;	pop bc 
20a4			;endif 
20a4			; tok next end here 
20a4 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20a7 eb				ex de, hl 
20a8			 
20a8			 
20a8				; save the pointer of the current token - 1 to check against 
20a8				 
20a8 22 46 ea			ld (cli_token), hl   
20ab				; TODO maybe remove below save if no debug 
20ab				; save token string ptr for any debug later 
20ab 23				inc hl  
20ac 22 48 ea			ld (cli_origtoken), hl 
20af 2b				dec hl 
20b0				; save pointer to the start of the next dictionay word 
20b0 7e				ld a,(hl)   ; get string length 
20b1 47				ld b,a 
20b2			.execpnwordinc:  
20b2 23				inc hl 
20b3 10 fd			djnz .execpnwordinc 
20b5 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20b8			 
20b8				; now check the word token against the string being parsed 
20b8			 
20b8 2a 46 ea			ld hl,(cli_token) 
20bb 23				inc hl     ; skip string length (use zero term instead to end) 
20bc 22 46 ea			ld (cli_token), hl 
20bf			 
20bf			if DEBUG_FORTH_PARSE_KEY 
20bf						DMARK "KY2" 
20bf			endif 
20bf			if DEBUG_FORTH_PARSE_EXEC 
20bf				; see if disabled 
20bf			 
20bf			;	ld a, (os_view_disable) 
20bf			;	cp '*' 
20bf				ld a, (debug_vector) 
20bf				cp $c9   ; RET  
20bf				jr z, .skip 
20bf			 
20bf				push hl 
20bf				push hl 
20bf				call clear_display 
20bf				ld de, .compword 
20bf				ld a, display_row_1 
20bf				call str_at_display 
20bf				pop de 
20bf				ld a, display_row_2 
20bf				call str_at_display 
20bf				ld hl,(cli_ptr) 
20bf				ld a,(hl) 
20bf			        ld hl, os_word_scratch 
20bf				ld (hl),a 
20bf				ld a,0 
20bf				inc hl 
20bf				ld (hl),a 	 
20bf				ld de, os_word_scratch 
20bf				ld a, display_row_2+10 
20bf				call str_at_display 
20bf				call update_display 
20bf				ld a, 100 
20bf				call aDelayInMS 
20bf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20bf				call delay250ms 
20bf				endif 
20bf				pop hl 
20bf			.skip:  
20bf			endif	 
20bf			.execpnchar:    ; compare char between token and string to parse 
20bf			 
20bf			if DEBUG_FORTH_PARSE_KEY 
20bf						DMARK "Ky3" 
20bf			endif 
20bf			if DEBUG_FORTH_PARSE_EXEC 
20bf				; see if disabled 
20bf			 
20bf			;	ld a, (os_view_disable) 
20bf			;	cp '*' 
20bf				ld a, (debug_vector) 
20bf				cp $C9  ; RET 
20bf				jr z, .skip2 
20bf			 
20bf			;	call clear_display 
20bf			ld hl,(cli_token) 
20bf			ld a,(hl) 
20bf			ld (os_word_scratch),a 
20bf				ld hl,(cli_ptr) 
20bf			ld a,(hl) 
20bf				ld (os_word_scratch+1),a 
20bf				ld a,0 
20bf				ld (os_word_scratch+2),a 
20bf				ld de,os_word_scratch 
20bf				ld a,display_row_4 
20bf				call str_at_display 
20bf				call update_display 
20bf			.skip2:  
20bf			endif 
20bf 2a 46 ea			ld hl,(cli_token) 
20c2 7e				ld a, (hl)	 ; char in word token 
20c3 23				inc hl 		; move to next char 
20c4 22 46 ea			ld (cli_token), hl ; and save it 
20c7 47				ld b,a 
20c8			 
20c8 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20cb 7e				ld a,(hl) 
20cc 23				inc hl 
20cd 22 40 ea			ld (cli_ptr), hl		; move to next char 
20d0 cd 3c 12			call toUpper 		; make sure the input string matches case 
20d3			 
20d3			if DEBUG_FORTH_PARSE 
20d3			endif 
20d3			 
20d3				; input stream end of token is a space so get rid of it 
20d3			 
20d3			;	cp ' ' 
20d3			;	jr nz, .pnskipspace 
20d3			; 
20d3			;	ld a, 0		; make same term as word token term 
20d3			; 
20d3			;.pnskipspace: 
20d3			 
20d3			if DEBUG_FORTH_PARSE_KEY 
20d3						DMARK "KY7" 
20d3			endif 
20d3 b8				cp b 
20d4 c2 ea 20			jp nz, .execpnskipword	 ; no match so move to next word 
20d7				 
20d7			;    if same 
20d7			;       scan for string terms 0 for token and 32 for input 
20d7			 
20d7				 
20d7			if DEBUG_FORTH_PARSE_KEY 
20d7						DMARK "KY8" 
20d7			endif 
20d7			 
20d7 80				add b			 
20d8 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20da							; TODO need to make sure last word in zero term string is accounted for 
20da 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20dc			 
20dc			 
20dc				; at end of both strings so both are exact match 
20dc			 
20dc			;       skip ptr for next word 
20dc			 
20dc 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20df 23				inc hl			 ; at next char 
20e0 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20e3 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20e6				 
20e6				 
20e6			if DEBUG_FORTH_PARSE_KEY 
20e6						DMARK "KY3" 
20e6			endif 
20e6			 
20e6			 
20e6			 
20e6			;       exec code block 
20e6			if DEBUG_FORTH_JP 
20e6				call clear_display 
20e6				call update_display 
20e6				call delay1s 
20e6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e6				ld a,h 
20e6				ld hl, os_word_scratch 
20e6				call hexout 
20e6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e6				ld a,l 
20e6				ld hl, os_word_scratch+2 
20e6				call hexout 
20e6				ld hl, os_word_scratch+4 
20e6				ld a,0 
20e6				ld (hl),a 
20e6				ld de,os_word_scratch 
20e6				call str_at_display 
20e6					ld a, display_row_2 
20e6					call str_at_display 
20e6				ld de, (cli_origtoken) 
20e6				ld a, display_row_1+10 
20e6					call str_at_display 
20e6			 
20e6				ld a,display_row_1 
20e6				ld de, .foundword 
20e6				ld a, display_row_3 
20e6				call str_at_display 
20e6				call update_display 
20e6				call delay1s 
20e6				call delay1s 
20e6				call delay1s 
20e6			endif 
20e6			 
20e6			if DEBUG_FORTH_PARSE_KEY 
20e6						DMARK "KYj" 
20e6			endif 
20e6				; TODO save the word pointer in this exec 
20e6			 
20e6 2a 44 ea			ld hl,(cli_execword) 
20e9 e9				jp (hl) 
20ea			 
20ea			 
20ea			;    if not same 
20ea			;	scan for zero term 
20ea			;	get ptr for next word 
20ea			;	goto word comp 
20ea			 
20ea			.execpnskipword:	; get pointer to next word 
20ea 2a 42 ea			ld hl,(cli_nextword) 
20ed			 
20ed 7e				ld a,(hl) 
20ee fe 00			cp WORD_SYS_END 
20f0			;	cp 0 
20f0 28 09			jr z, .execendofdict			 ; at end of words 
20f2			 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "KY4" 
20f2			endif 
20f2			if DEBUG_FORTH_PARSE_EXEC 
20f2			 
20f2				; see if disabled 
20f2			 
20f2			;	ld a, (os_view_disable) 
20f2			;	cp '*' 
20f2				ld a,(debug_vector) 
20f2				cp $c9   ; RET 
20f2				jr z, .noskip 
20f2			 
20f2			 
20f2				ld de, .nowordfound 
20f2				ld a, display_row_3 
20f2				call str_at_display 
20f2				call update_display 
20f2				ld a, 100 
20f2				call aDelayInMS 
20f2				 
20f2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20f2					call delay250ms 
20f2				endif 
20f2			.noskip:  
20f2			 
20f2			endif	 
20f2			 
20f2 2a 3e ea			ld hl,(cli_origptr) 
20f5 22 40 ea			ld (cli_ptr),hl 
20f8			 
20f8			if DEBUG_FORTH_PARSE_KEY 
20f8						DMARK "KY5" 
20f8			endif 
20f8 c3 9e 20			jp .execpnword			; else go to next word 
20fb			 
20fb			.execendofdict:  
20fb			 
20fb			if DEBUG_FORTH_PARSE_KEY 
20fb						DMARK "KYe" 
20fb			endif 
20fb			if DEBUG_FORTH_PARSE_EXEC 
20fb				; see if disabled 
20fb			 
20fb			;	ld a, (os_view_disable) 
20fb			;	cp '*' 
20fb				ld a,(debug_vector) 
20fb				cp $c9   ; ret 
20fb				jr z, .ispskip 
20fb			 
20fb				call clear_display 
20fb				call update_display 
20fb				call delay1s 
20fb				ld de, (cli_origptr) 
20fb				ld a, display_row_1 
20fb				call str_at_display 
20fb				 
20fb				ld de, .enddict 
20fb				ld a, display_row_3 
20fb				call str_at_display 
20fb				call update_display 
20fb				ld a, 100 
20fb				call aDelayInMS 
20fb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20fb				call delay1s 
20fb				call delay1s 
20fb				call delay1s 
20fb				endif 
20fb			.ispskip:  
20fb				 
20fb			endif	 
20fb			 
20fb			 
20fb			 
20fb				; if the word is not a keyword then must be a literal so push it to stack 
20fb			 
20fb			; push token to stack to end of word 
20fb			 
20fb				STACKFRAME ON $1efe $2f9f 
20fb				if DEBUG_STACK_IMB 
20fb					if ON 
20fb						exx 
20fb						ld de, $1efe 
20fb						ld a, d 
20fb						ld hl, curframe 
20fb						call hexout 
20fb						ld a, e 
20fb						ld hl, curframe+2 
20fb						call hexout 
20fb						ld hl, $1efe 
20fb						push hl 
20fb						ld hl, $2f9f 
20fb						push hl 
20fb						exx 
20fb					endif 
20fb				endif 
20fb			endm 
# End of macro STACKFRAME
20fb			 
20fb 2a c2 e5		ld hl,(os_tok_ptr) 
20fe cd af 1d		call forth_apush 
2101			 
2101				STACKFRAMECHK ON $1efe $2f9f 
2101				if DEBUG_STACK_IMB 
2101					if ON 
2101						exx 
2101						ld hl, $2f9f 
2101						pop de   ; $2f9f 
2101						call cmp16 
2101						jr nz, .spnosame 
2101						ld hl, $1efe 
2101						pop de   ; $1efe 
2101						call cmp16 
2101						jr z, .spfrsame 
2101						.spnosame: call showsperror 
2101						.spfrsame: nop 
2101						exx 
2101					endif 
2101				endif 
2101			endm 
# End of macro STACKFRAMECHK
2101			 
2101			execnext: 
2101			 
2101			if DEBUG_FORTH_PARSE_KEY 
2101						DMARK "KY>" 
2101			endif 
2101			; move past token to next word 
2101			 
2101 2a c2 e5		ld hl, (os_tok_ptr) 
2104 3e 00		ld a, 0 
2106 01 ff 00		ld bc, 255     ; input buffer size 
2109 ed b1		cpir 
210b			 
210b			if DEBUG_FORTH_PARSE_KEY 
210b						DMARK "KY!" 
210b				CALLMONITOR 
210b			endif	 
210b			; TODO this might place hl on the null, so will need to forward on??? 
210b			;inc hl   ; see if this gets onto the next item 
210b			 
210b			 
210b			; TODO pass a pointer to the buffer to push 
210b			; TODO call function to push 
210b			 
210b			; look for end of input 
210b			 
210b			;inc hl 
210b			;ld a,(hl) 
210b			;cp FORTH_END_BUFFER 
210b			;ret z 
210b			 
210b			 
210b c3 84 20		jp exec1 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			findnexttok: 
210e			 
210e				; hl is pointer to move 
210e				; de is the token to locate 
210e			 
210e					if DEBUG_FORTH 
210e						DMARK "NTK" 
210e						CALLMONITOR 
210e					endif 
210e d5				push de 
210f			 
210f			.fnt1:	 
210f				; find first char of token to locate 
210f			 
210f 1a				ld a, (de) 
2110 4f				ld c,a 
2111 7e				ld a,(hl) 
2112 cd 3c 12			call toUpper 
2115					if DEBUG_FORTH 
2115						DMARK "NT1" 
2115						CALLMONITOR 
2115					endif 
2115 b9				cp c 
2116			 
2116 28 03			jr z, .fnt2cmpmorefirst	 
2118			 
2118				; first char not found move to next char 
2118			 
2118 23				inc hl 
2119 18 f4			jr .fnt1 
211b			 
211b			.fnt2cmpmorefirst:	 
211b				; first char of token found.  
211b			 
211b e5				push hl     ; save start of token just in case it is the right one 
211c d9				exx 
211d e1				pop hl        ; save it to hl' 
211e d9				exx 
211f			 
211f			 
211f			.fnt2cmpmore:	 
211f				; compare the rest 
211f				 
211f 23				inc hl 
2120 13				inc de 
2121				 
2121 1a				ld a, (de) 
2122 4f				ld c,a 
2123 7e				ld a,(hl) 
2124 cd 3c 12			call toUpper 
2127			 
2127					if DEBUG_FORTH 
2127						DMARK "NT2" 
2127						CALLMONITOR 
2127					endif 
2127				; c has the token to find char 
2127				; a has the mem to scan char 
2127			 
2127 b9				cp c 
2128 28 04			jr z,.fntmatch1 
212a			 
212a				; they are not the same 
212a			 
212a					if DEBUG_FORTH 
212a						DMARK "NT3" 
212a						CALLMONITOR 
212a					endif 
212a d1				pop de	; reset de token to look for 
212b d5				push de 
212c 18 e1			jr .fnt1 
212e				 
212e			.fntmatch1: 
212e			 
212e				; is the same char a null which means we might have a full hit? 
212e					if DEBUG_FORTH 
212e						DMARK "NT4" 
212e						CALLMONITOR 
212e					endif 
212e			 
212e fe 00			cp 0 
2130 28 0b			jr z, .fntmatchyes 
2132			 
2132				; are we at the end of the token to find? 
2132			 
2132					if DEBUG_FORTH 
2132						DMARK "NT5" 
2132						CALLMONITOR 
2132					endif 
2132 3e 00			ld a, 0 
2134 b9				cp c 
2135			 
2135 c2 1f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2138			 
2138					if DEBUG_FORTH 
2138						DMARK "NT6" 
2138						CALLMONITOR 
2138					endif 
2138				; token to find is exhusted but no match to stream 
2138			 
2138				; restore tok pointer and continue on 
2138 d1				pop de 
2139 d5				push de 
213a c3 0f 21			jp .fnt1 
213d			 
213d			 
213d			.fntmatchyes: 
213d			 
213d				; hl now contains the end of the found token 
213d			 
213d				; get rid of saved token pointer to find 
213d			 
213d d1				pop de 
213e			 
213e					if DEBUG_FORTH 
213e						DMARK "NT9" 
213e						CALLMONITOR 
213e					endif 
213e			 
213e				; hl will be on the null term so forward on 
213e			 
213e				; get back the saved start of the token 
213e			 
213e d9				exx 
213f e5				push hl     ; save start of token just in case it is the right one 
2140 d9				exx 
2141 e1				pop hl        ; save it to hl 
2142			 
2142 c9				ret 
2143			 
2143			 
2143			; LIST needs to find a specific token   
2143			; FORGET needs to find a spefici token 
2143			 
2143			; SAVE needs to find all tokens by flag 
2143			; WORDS just needs to scan through all  by flag 
2143			; UWORDS needs to scan through all by flag 
2143			 
2143			 
2143			; given hl as pointer to start of dict look up string 
2143			; return hl as pointer to start of word block 
2143			; or 0 if not found 
2143			 
2143			forth_find_tok: 
2143 c9				ret 
2144			 
2144			; given hl as pointer to dict structure 
2144			; move to the next dict block structure 
2144			 
2144			forth_tok_next: 
2144				; hl now points to the address of the next word pointer  
2144				; TODO skip compiled symbol for now 
2144			;	push de 
2144 23				inc hl 
2145 5e				ld e, (hl) 
2146 23				inc hl 
2147 56				ld d, (hl) 
2148 23				inc hl 
2149			 
2149 eb				ex de,hl 
214a			if DEBUG_FORTH_PARSE_NEXTWORD 
214a				push bc 
214a				ld bc, (cli_nextword) 
214a						DMARK "NXW" 
214a				CALLMONITOR 
214a				pop bc 
214a			endif 
214a			;	pop de	 
214a c9				ret 
214b			 
214b			 
214b			 
214b			; eof 
# End of file forth_parserv5.asm
214b				include "forth_wordsv4.asm" 
214b			 
214b			; the core word dictionary v4 
214b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
214b			 
214b			; this is a linked list for each of the system words used 
214b			; user defined words will follow the same format but will be in ram 
214b			 
214b			 
214b			; 
214b			; 
214b			; define linked list: 
214b			; 
214b			; 1. compiled byte op code 
214b			; 2. len of text word 
214b			; 3. text word 
214b			; 4. ptr to next dictionary word 
214b			; 5. asm, calls etc for the word 
214b			; 
214b			;  if 1 == 0 then last word in dict  
214b			;   
214b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
214b			;  
214b			;  
214b			; create basic standard set of words 
214b			; 
214b			;  
214b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
214b			; 2DUP 2DROP 2SWAP  
214b			; @ C@ - get byte  
214b			; ! C! - store byte 
214b			; 0< true if less than zero 
214b			; 0= true if zero 
214b			; < >  
214b			; = true if same 
214b			; variables 
214b			 
214b			 
214b			; Hardware specific words I may need 
214b			; 
214b			; IN OUT  
214b			; calls to key util functions 
214b			; calls to hardward abstraction stuff 
214b			; easy control of frame buffers and lcd i/o 
214b			; keyboard  
214b			 
214b			 
214b			;DICT: macro 
214b			; op_code, len, word, next 
214b			;    word: 
214b			;    db op_code 
214b			;    ds word zero term 
214b			;    dw next 
214b			;    endm 
214b			 
214b			 
214b			 
214b			 
214b			; op code 1 is a flag for user define words which are to be handled differently 
214b			 
214b			 
214b			; 
214b			; 
214b			;    TODO on entry to a word this should be the expected environment 
214b			;    hl - tos value if number then held, if string this is the ptr 
214b			;    de -  
214b			 
214b			 
214b			; opcode ranges 
214b			; 0 - end of word dict 
214b			; 255 - user define words 
214b			 
214b			sysdict: 
214b			include "forth_opcodes.asm" 
214b			; op codes for forth keywords 
214b			; free to use code 0  
214b				OPCODE_HEAP: equ  1 
214b				OPCODE_EXEC: equ 2 
214b				OPCODE_DUP: equ 3 
214b				OPCODE_SWAP: equ 4 
214b				OPCODE_COLN: equ 5 
214b				OPCODE_SCOLN: equ 6 
214b				OPCODE_DROP: equ 7 
214b				OPCODE_DUP2: equ 8 
214b				OPCODE_DROP2: equ 9 
214b				OPCODE_SWAP2: equ 10 
214b				OPCODE_AT: equ 11 
214b				OPCODE_CAT: equ 12 
214b				OPCODE_BANG: equ 13 
214b				OPCODE_CBANG: equ 14 
214b				OPCODE_SCALL: equ 15 
214b				OPCODE_DEPTH: equ 16 
214b				OPCODE_OVER: equ 17 
214b				OPCODE_PAUSE: equ 18 
214b				OPCODE_PAUSES: equ 19 
214b				OPCODE_ROT: equ 20 
214b			;free to reuse	OPCODE_WORDS: equ 21 
214b			        OPCODE_NOT: equ 21 
214b				OPCODE_UWORDS: equ 22 
214b				OPCODE_BP: equ 23 
214b				OPCODE_MONITOR: equ 24  
214b				OPCODE_MALLOC: equ 25 
214b				OPCODE_FREE: equ 26 
214b				OPCODE_LIST: equ 27 
214b				OPCODE_FORGET: equ 28 
214b				OPCODE_NOP: equ 29 
214b				OPCODE_COMO: equ 30 
214b				OPCODE_COMC: equ 31 
214b			;free to reuse	OPCODE_ENDCORE: equ 32 
214b				OPCODE_AFTERSOUND: equ 33 
214b				OPCODE_GP2: equ 34 
214b				OPCODE_GP3: equ 35 
214b				OPCODE_GP4: equ 36 
214b				OPCODE_SIN: equ 37 
214b				OPCODE_SOUT: equ 38 
214b				OPCODE_SPIO: equ 39 
214b				OPCODE_SPICEH: equ 40 
214b				OPCODE_SPIOb: equ 41 
214b				OPCODE_SPII: equ 42 
214b				OPCODE_SESEL: equ 43 
214b				OPCODE_CARTDEV: equ 44 
214b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
214b				OPCODE_FB: equ 46 
214b				OPCODE_EMIT: equ 47 
214b				OPCODE_DOTH: equ 48 
214b				OPCODE_DOTF: equ 49 
214b				OPCODE_DOT: equ 50 
214b				OPCODE_CLS: equ 51 
214b				OPCODE_DRAW: equ 52 
214b				OPCODE_DUMP: equ 53 
214b				OPCODE_CDUMP: equ 54 
214b				OPCODE_DAT: equ 55 
214b				OPCODE_HOME: equ 56 
214b				OPCODE_SPACE: equ 57 
214b				OPCODE_SPACES: equ 58 
214b				OPCODE_SCROLL: equ 59 
214b				OPCODE_ATQ: equ 60 
214b				OPCODE_AUTODSP: equ 61 
214b				OPCODE_MENU: equ 62 
214b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
214b				OPCODE_THEN: equ 64 
214b				OPCODE_ELSE: equ 65 
214b				OPCODE_DO: equ 66 
214b				OPCODE_LOOP: equ 67 
214b				OPCODE_I: equ 68 
214b				OPCODE_DLOOP: equ 69  
214b				OPCODE_REPEAT: equ 70  
214b				OPCODE_UNTIL: equ 71 
214b				OPCODE_ENDFLOW: equ 72 
214b				OPCODE_WAITK: equ 73 
214b				OPCODE_ACCEPT: equ 74 
214b				OPCODE_EDIT: equ 75 
214b			;free to reuse	OPCODE_ENDKEY: equ 76 
214b				OPCODE_LZERO: equ 77 
214b				OPCODE_TZERO: equ 78 
214b				OPCODE_LESS: equ 79 
214b				OPCODE_GT: equ 80 
214b				OPCODE_EQUAL: equ 81  
214b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
214b				OPCODE_NEG: equ 83 
214b				OPCODE_DIV: equ 84 
214b				OPCODE_MUL: equ 85 
214b				OPCODE_MIN: equ 86 
214b				OPCODE_MAX: equ 87 
214b				OPCODE_RND16: equ 88 
214b				OPCODE_RND8: equ 89 
214b				OPCODE_RND: equ 90 
214b			;free to reuse	OPCODE_ENDMATHS: equ 91  
214b				OPCODE_BYNAME: equ 92 
214b				OPCODE_DIR: equ 93 
214b				OPCODE_SAVE: equ 94 
214b				OPCODE_LOAD: equ 95 
214b				OPCODE_BSAVE: equ 96 
214b				OPCODE_BLOAD: equ 97 
214b				OPCODE_SEO: equ 98  
214b				OPCODE_SEI: equ 99 
214b				OPCODE_SFREE: equ 100 
214b				OPCODE_SIZE: equ 101 
214b				OPCODE_CREATE: equ 102 
214b				OPCODE_APPEND: equ 103 
214b				OPCODE_SDEL: equ 104 
214b				OPCODE_OPEN: equ 105 
214b				OPCODE_READ: equ 106 
214b				OPCODE_EOF: equ 106 
214b				OPCODE_FORMAT: equ 107 
214b				OPCODE_LABEL: equ 108 
214b				OPCODE_LABELS: equ 109 
214b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
214b				OPCODE_UPPER: equ 111 
214b				OPCODE_LOWER: equ 112 
214b				OPCODE_SUBSTR: equ 113 
214b				OPCODE_LEFT: equ 114 
214b				OPCODE_RIGHT: equ 115 
214b				OPCODE_STR2NUM: equ 116 
214b				OPCODE_NUM2STR: equ 117 
214b				OPCODE_CONCAT: equ 118 
214b				OPCODE_FIND: equ 119 
214b				OPCODE_LEN: equ 120 
214b				OPCODE_CHAR: equ 121 
214b			; free to reuse	OPCODE_STRLEN: equ 122 
214b			; free to reuse	OPCODE_ENDSTR: equ 123 
214b				OPCODE_V0S: equ 124 
214b				OPCODE_V0Q: equ 125 
214b				OPCODE_V1S: equ 126 
214b				OPCODE_V1Q: equ 127 
214b				OPCODE_V2S: equ 128 
214b				OPCODE_V2Q: equ 129 
214b				OPCODE_V3S: equ 130 
214b				OPCODE_V3Q: equ 131 
214b			;free to reuse	OPCODE_END: equ 132 
214b				OPCODE_ZDUP: equ 133 
214b			 
214b			; eof 
# End of file forth_opcodes.asm
214b			 
214b			include "forth_words_core.asm" 
214b			 
214b			; | ## Core Words 
214b			 
214b			;if MALLOC_4 
214b			 
214b			.HEAP: 
214b				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
214b 15				db WORD_SYS_CORE+OPCODE_HEAP             
214c 8a 21			dw .EXEC            
214e 05				db 4 + 1 
214f .. 00			db "HEAP",0              
2154				endm 
# End of macro CWHEAD
2154			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2154			; | | u1 - Current number of bytes in the heap 
2154			; | | u2 - Remaining bytes left on the heap 
2154			; | |  
2154			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2154			 
2154			 
2154					if DEBUG_FORTH_WORDS_KEY 
2154						DMARK "HEP" 
2154 f5				push af  
2155 3a 69 21			ld a, (.dmark)  
2158 32 6b ee			ld (debug_mark),a  
215b 3a 6a 21			ld a, (.dmark+1)  
215e 32 6c ee			ld (debug_mark+1),a  
2161 3a 6b 21			ld a, (.dmark+2)  
2164 32 6d ee			ld (debug_mark+2),a  
2167 18 03			jr .pastdmark  
2169 ..			.dmark: db "HEP"  
216c f1			.pastdmark: pop af  
216d			endm  
# End of macro DMARK
216d						CALLMONITOR 
216d cd 6f ee			call debug_vector  
2170				endm  
# End of macro CALLMONITOR
2170					endif 
2170 2a 9a 65				ld hl, (free_list )      
2173 11 9f 65				ld de, heap_start 
2176			 
2176 ed 52				sbc hl, de  
2178			 
2178 cd 46 1c				call forth_push_numhl 
217b			 
217b			 
217b ed 5b 9a 65			ld de, (free_list )      
217f 21 a8 e2				ld hl, heap_end 
2182			 
2182 ed 52				sbc hl, de 
2184			 
2184 cd 46 1c				call forth_push_numhl 
2187					 
2187			 
2187					 
2187			 
2187			 
2187			 
2187					NEXTW 
2187 c3 f3 1f			jp macro_next 
218a				endm 
# End of macro NEXTW
218a			;endif 
218a			 
218a			.EXEC: 
218a			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
218a			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
218a			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
218a			;; > > 
218a			;; > >   
218a			;	STACKFRAME OFF $5efe $5f9f 
218a			; 
218a			;		if DEBUG_FORTH_WORDS_KEY 
218a			;			DMARK "EXE" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	FORTH_DSP_VALUEHL 
218a			; 
218a			;	FORTH_DSP_POP 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX1" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;;	ld e,(hl) 
218a			;;	inc hl 
218a			;;	ld d,(hl) 
218a			;;	ex de,hl 
218a			; 
218a			;;		if DEBUG_FORTH_WORDS 
218a			;;			DMARK "EX2" 
218a			;;			CALLMONITOR 
218a			;;		endif 
218a			;	push hl 
218a			; 
218a			;	;ld a, 0 
218a			;	;ld a, FORTH_END_BUFFER 
218a			;	call strlenz 
218a			;	inc hl   ; include zero term to copy 
218a			;	inc hl   ; include term 
218a			;	inc hl   ; include term 
218a			;	ld b,0 
218a			;	ld c,l 
218a			;	pop hl 
218a			;	ld de, execscratch 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX3" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ldir 
218a			; 
218a			; 
218a			;	ld hl, execscratch 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXe" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	call forthparse 
218a			;	call forthexec 
218a			;;	call forthexec_cleanup 
218a			;;	call forthparse 
218a			;;	call forthexec 
218a			; 
218a			;	STACKFRAMECHK OFF $5efe $5f9f 
218a			; 
218a			;	; an immediate word so no need to process any more words 
218a			;	ret 
218a			;	NEXTW 
218a			 
218a			; dead code - old version  
218a			;	FORTH_RSP_NEXT 
218a			 
218a			;  
218a			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
218a			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
218a			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
218a			;	push hl 
218a			;	push de 
218a			;	push bc 
218a			; 
218a			; 
218a			;		if DEBUG_FORTH_WORDS_KEY 
218a			;			DMARK "EXR" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			; 
218a			; 
218a			;	;v5 FORTH_DSP_VALUE 
218a			;	FORTH_DSP_VALUEHL 
218a			; 
218a			;	; TODO do string type checks 
218a			; 
218a			;;v5	inc hl   ; skip type 
218a			; 
218a			;	push hl  ; source code  
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX1" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ld a, 0 
218a			;	call strlent 
218a			; 
218a			;	inc hl 
218a			;	inc hl 
218a			;	inc hl 
218a			;	inc hl 
218a			; 
218a			;	push hl    ; size 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX2" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	call malloc 
218a			; 
218a			;	ex de, hl    ; de now contains malloc area 
218a			;	pop bc   	; get byte count 
218a			;	pop hl      ; get string to copy 
218a			; 
218a			;	push de     ; save malloc for free later 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX3" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ldir       ; duplicate string 
218a			; 
218a			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
218a			;	 
218a			;	; TODO fix the parse would be better than this...  
218a			;	ex de, hl 
218a			;	dec hl 
218a			;	ld a, 0 
218a			;	ld (hl), a 
218a			;	dec hl 
218a			;	ld a, ' ' 
218a			;	ld (hl), a 
218a			;	dec hl 
218a			;	ld (hl), a 
218a			; 
218a			;	dec hl 
218a			;	ld (hl), a 
218a			; 
218a			; 
218a			;	FORTH_DSP_POP  
218a			; 
218a			;	pop hl     
218a			;	push hl    ; save malloc area 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX4" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	call forthparse 
218a			;	call forthexec 
218a			;	 
218a			;	pop hl 
218a			;	if DEBUG_FORTH_WORDS 
218a			;		DMARK "EX5" 
218a			;		CALLMONITOR 
218a			;	endif 
218a			; 
218a			;	if FORTH_ENABLE_FREE 
218a			;	call free 
218a			;	endif 
218a			; 
218a			;	if DEBUG_FORTH_WORDS 
218a			;		DMARK "EX6" 
218a			;		CALLMONITOR 
218a			;	endif 
218a			; 
218a			;	pop bc 
218a			;	pop de 
218a			;	pop hl 
218a			;;	FORTH_RSP_POP	  
218a			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
218a			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
218a			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
218a			; 
218a			;	if DEBUG_FORTH_WORDS 
218a			;		DMARK "EX7" 
218a			;		CALLMONITOR 
218a			;	endif 
218a			;	NEXTW 
218a			 
218a			;.STKEXEC: 
218a			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
218a			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
218a			; 
218a			; 
218a			;		if DEBUG_FORTH_WORDS_KEY 
218a			;			DMARK "STX" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	FORTH_DSP_VALUEHL 
218a			; 
218a			;	ld (store_tmp1), hl    ; count 
218a			; 
218a			;	FORTH_DSP_POP 
218a			;.stkexec1: 
218a			;	ld hl, (store_tmp1)   ; count 
218a			;	ld a, 0 
218a			;	cp l 
218a			;	ret z 
218a			; 
218a			;	dec hl 
218a			;	ld (store_tmp1), hl    ; count 
218a			;	 
218a			;	FORTH_DSP_VALUEHL 
218a			;	push hl 
218a			;	 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXp" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	FORTH_DSP_POP 
218a			; 
218a			;	call strlenz 
218a			;	inc hl   ; include zero term to copy 
218a			;	inc hl   ; include zero term to copy 
218a			;	inc hl   ; include zero term to copy 
218a			;	ld b,0 
218a			;	ld c,l 
218a			;	pop hl 
218a			;	ld de, execscratch 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX3" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ldir 
218a			; 
218a			; 
218a			;	ld hl, execscratch 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXP" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	call forthparse 
218a			;	ld hl, execscratch 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXx" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	call forthexec 
218a			; 
218a			;	jp .stkexec1 
218a			; 
218a			;	ret 
218a			 
218a			 
218a			.DUP: 
218a				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
218a 17				db WORD_SYS_CORE+OPCODE_DUP             
218b 00 22			dw .ZDUP            
218d 04				db 3 + 1 
218e .. 00			db "DUP",0              
2192				endm 
# End of macro CWHEAD
2192			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2192			 
2192					if DEBUG_FORTH_WORDS_KEY 
2192						DMARK "DUP" 
2192 f5				push af  
2193 3a a7 21			ld a, (.dmark)  
2196 32 6b ee			ld (debug_mark),a  
2199 3a a8 21			ld a, (.dmark+1)  
219c 32 6c ee			ld (debug_mark+1),a  
219f 3a a9 21			ld a, (.dmark+2)  
21a2 32 6d ee			ld (debug_mark+2),a  
21a5 18 03			jr .pastdmark  
21a7 ..			.dmark: db "DUP"  
21aa f1			.pastdmark: pop af  
21ab			endm  
# End of macro DMARK
21ab						CALLMONITOR 
21ab cd 6f ee			call debug_vector  
21ae				endm  
# End of macro CALLMONITOR
21ae					endif 
21ae			 
21ae					FORTH_DSP 
21ae cd 03 1e			call macro_forth_dsp 
21b1				endm 
# End of macro FORTH_DSP
21b1			 
21b1 7e					ld a, (HL) 
21b2 fe 01				cp DS_TYPE_STR 
21b4 20 25				jr nz, .dupinum 
21b6			 
21b6					; push another string 
21b6			 
21b6					FORTH_DSP_VALUEHL     		 
21b6 cd 3d 1e			call macro_dsp_valuehl 
21b9				endm 
# End of macro FORTH_DSP_VALUEHL
21b9			 
21b9				if DEBUG_FORTH_WORDS 
21b9					DMARK "DUs" 
21b9 f5				push af  
21ba 3a ce 21			ld a, (.dmark)  
21bd 32 6b ee			ld (debug_mark),a  
21c0 3a cf 21			ld a, (.dmark+1)  
21c3 32 6c ee			ld (debug_mark+1),a  
21c6 3a d0 21			ld a, (.dmark+2)  
21c9 32 6d ee			ld (debug_mark+2),a  
21cc 18 03			jr .pastdmark  
21ce ..			.dmark: db "DUs"  
21d1 f1			.pastdmark: pop af  
21d2			endm  
# End of macro DMARK
21d2					CALLMONITOR 
21d2 cd 6f ee			call debug_vector  
21d5				endm  
# End of macro CALLMONITOR
21d5				endif 
21d5 cd b4 1c				call forth_push_str 
21d8			 
21d8					NEXTW 
21d8 c3 f3 1f			jp macro_next 
21db				endm 
# End of macro NEXTW
21db			 
21db			 
21db			.dupinum: 
21db					 
21db			 
21db			 
21db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21db cd 3d 1e			call macro_dsp_valuehl 
21de				endm 
# End of macro FORTH_DSP_VALUEHL
21de			 
21de				; TODO add floating point number detection 
21de			 
21de				if DEBUG_FORTH_WORDS 
21de					DMARK "DUi" 
21de f5				push af  
21df 3a f3 21			ld a, (.dmark)  
21e2 32 6b ee			ld (debug_mark),a  
21e5 3a f4 21			ld a, (.dmark+1)  
21e8 32 6c ee			ld (debug_mark+1),a  
21eb 3a f5 21			ld a, (.dmark+2)  
21ee 32 6d ee			ld (debug_mark+2),a  
21f1 18 03			jr .pastdmark  
21f3 ..			.dmark: db "DUi"  
21f6 f1			.pastdmark: pop af  
21f7			endm  
# End of macro DMARK
21f7					CALLMONITOR 
21f7 cd 6f ee			call debug_vector  
21fa				endm  
# End of macro CALLMONITOR
21fa				endif 
21fa			 
21fa cd 46 1c				call forth_push_numhl 
21fd					NEXTW 
21fd c3 f3 1f			jp macro_next 
2200				endm 
# End of macro NEXTW
2200			.ZDUP: 
2200				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2200 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2201 38 22			dw .SWAP            
2203 05				db 4 + 1 
2204 .. 00			db "?DUP",0              
2209				endm 
# End of macro CWHEAD
2209			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2209			 
2209					if DEBUG_FORTH_WORDS_KEY 
2209						DMARK "qDU" 
2209 f5				push af  
220a 3a 1e 22			ld a, (.dmark)  
220d 32 6b ee			ld (debug_mark),a  
2210 3a 1f 22			ld a, (.dmark+1)  
2213 32 6c ee			ld (debug_mark+1),a  
2216 3a 20 22			ld a, (.dmark+2)  
2219 32 6d ee			ld (debug_mark+2),a  
221c 18 03			jr .pastdmark  
221e ..			.dmark: db "qDU"  
2221 f1			.pastdmark: pop af  
2222			endm  
# End of macro DMARK
2222						CALLMONITOR 
2222 cd 6f ee			call debug_vector  
2225				endm  
# End of macro CALLMONITOR
2225					endif 
2225					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2225 cd 3d 1e			call macro_dsp_valuehl 
2228				endm 
# End of macro FORTH_DSP_VALUEHL
2228			 
2228 e5					push hl 
2229			 
2229					; is it a zero? 
2229			 
2229 3e 00				ld a, 0 
222b 84					add h 
222c 85					add l 
222d			 
222d e1					pop hl 
222e			 
222e fe 00				cp 0 
2230 28 03				jr z, .dup2orig 
2232			 
2232			 
2232 cd 46 1c				call forth_push_numhl 
2235			 
2235			 
2235				; TODO add floating point number detection 
2235			 
2235			.dup2orig: 
2235			 
2235					NEXTW 
2235 c3 f3 1f			jp macro_next 
2238				endm 
# End of macro NEXTW
2238			.SWAP: 
2238				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2238 18				db WORD_SYS_CORE+OPCODE_SWAP             
2239 77 22			dw .COLN            
223b 05				db 4 + 1 
223c .. 00			db "SWAP",0              
2241				endm 
# End of macro CWHEAD
2241			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2241					if DEBUG_FORTH_WORDS_KEY 
2241						DMARK "SWP" 
2241 f5				push af  
2242 3a 56 22			ld a, (.dmark)  
2245 32 6b ee			ld (debug_mark),a  
2248 3a 57 22			ld a, (.dmark+1)  
224b 32 6c ee			ld (debug_mark+1),a  
224e 3a 58 22			ld a, (.dmark+2)  
2251 32 6d ee			ld (debug_mark+2),a  
2254 18 03			jr .pastdmark  
2256 ..			.dmark: db "SWP"  
2259 f1			.pastdmark: pop af  
225a			endm  
# End of macro DMARK
225a						CALLMONITOR 
225a cd 6f ee			call debug_vector  
225d				endm  
# End of macro CALLMONITOR
225d					endif 
225d			 
225d					FORTH_DSP_VALUEHL 
225d cd 3d 1e			call macro_dsp_valuehl 
2260				endm 
# End of macro FORTH_DSP_VALUEHL
2260 e5					push hl     ; w2 
2261			 
2261					FORTH_DSP_POP 
2261 cd f5 1e			call macro_forth_dsp_pop 
2264				endm 
# End of macro FORTH_DSP_POP
2264			 
2264					FORTH_DSP_VALUEHL 
2264 cd 3d 1e			call macro_dsp_valuehl 
2267				endm 
# End of macro FORTH_DSP_VALUEHL
2267			 
2267					FORTH_DSP_POP 
2267 cd f5 1e			call macro_forth_dsp_pop 
226a				endm 
# End of macro FORTH_DSP_POP
226a			 
226a d1					pop de     ; w2	, hl = w1 
226b			 
226b eb					ex de, hl 
226c d5					push de 
226d			 
226d cd 46 1c				call forth_push_numhl 
2270			 
2270 e1					pop hl 
2271			 
2271 cd 46 1c				call forth_push_numhl 
2274					 
2274			 
2274					NEXTW 
2274 c3 f3 1f			jp macro_next 
2277				endm 
# End of macro NEXTW
2277			.COLN: 
2277				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2277 19				db WORD_SYS_CORE+OPCODE_COLN             
2278 03 24			dw .SCOLN            
227a 02				db 1 + 1 
227b .. 00			db ":",0              
227d				endm 
# End of macro CWHEAD
227d			; | : ( -- )         Create new word | DONE 
227d			 
227d					if DEBUG_FORTH_WORDS_KEY 
227d						DMARK "CLN" 
227d f5				push af  
227e 3a 92 22			ld a, (.dmark)  
2281 32 6b ee			ld (debug_mark),a  
2284 3a 93 22			ld a, (.dmark+1)  
2287 32 6c ee			ld (debug_mark+1),a  
228a 3a 94 22			ld a, (.dmark+2)  
228d 32 6d ee			ld (debug_mark+2),a  
2290 18 03			jr .pastdmark  
2292 ..			.dmark: db "CLN"  
2295 f1			.pastdmark: pop af  
2296			endm  
# End of macro DMARK
2296						CALLMONITOR 
2296 cd 6f ee			call debug_vector  
2299				endm  
# End of macro CALLMONITOR
2299					endif 
2299				STACKFRAME OFF $8efe $989f 
2299				if DEBUG_STACK_IMB 
2299					if OFF 
2299						exx 
2299						ld de, $8efe 
2299						ld a, d 
2299						ld hl, curframe 
2299						call hexout 
2299						ld a, e 
2299						ld hl, curframe+2 
2299						call hexout 
2299						ld hl, $8efe 
2299						push hl 
2299						ld hl, $989f 
2299						push hl 
2299						exx 
2299					endif 
2299				endif 
2299			endm 
# End of macro STACKFRAME
2299				; get parser buffer length  of new word 
2299			 
2299				 
2299			 
2299					; move tok past this to start of name defintition 
2299					; TODO get word to define 
2299					; TODO Move past word token 
2299					; TODO get length of string up to the ';' 
2299			 
2299 2a c2 e5			ld hl, (os_tok_ptr) 
229c 23				inc hl 
229d 23				inc hl 
229e			 
229e 3e 3b			ld a, ';' 
22a0 cd 50 12			call strlent 
22a3			 
22a3 7d				ld a,l 
22a4 32 bd e2			ld (os_new_parse_len), a 
22a7			 
22a7			 
22a7			if DEBUG_FORTH_UWORD 
22a7 ed 5b c2 e5		ld de, (os_tok_ptr) 
22ab						DMARK ":01" 
22ab f5				push af  
22ac 3a c0 22			ld a, (.dmark)  
22af 32 6b ee			ld (debug_mark),a  
22b2 3a c1 22			ld a, (.dmark+1)  
22b5 32 6c ee			ld (debug_mark+1),a  
22b8 3a c2 22			ld a, (.dmark+2)  
22bb 32 6d ee			ld (debug_mark+2),a  
22be 18 03			jr .pastdmark  
22c0 ..			.dmark: db ":01"  
22c3 f1			.pastdmark: pop af  
22c4			endm  
# End of macro DMARK
22c4				CALLMONITOR 
22c4 cd 6f ee			call debug_vector  
22c7				endm  
# End of macro CALLMONITOR
22c7			endif 
22c7			 
22c7			; 
22c7			;  new word memory layout: 
22c7			;  
22c7			;    : adg 6666 ;  
22c7			; 
22c7			;    db   1     ; user defined word  
22c7 23				inc hl    
22c8			;    dw   sysdict 
22c8 23				inc hl 
22c9 23				inc hl 
22ca			;    db <word len>+1 (for null) 
22ca 23				inc hl 
22cb			;    db .... <word> 
22cb			; 
22cb			 
22cb 23				inc hl    ; some extras for the word preamble before the above 
22cc 23				inc hl 
22cd 23				inc hl 
22ce 23				inc hl 
22cf 23				inc hl 
22d0 23				inc hl 
22d1 23				inc hl  
22d2 23				inc hl 
22d3 23				inc hl 
22d4 23				inc hl 
22d5 23				inc hl 
22d6 23				inc hl 
22d7 23				inc hl 
22d8 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22d9			;       exec word buffer 
22d9			;	<ptr word>   
22d9 23				inc hl 
22da 23				inc hl 
22db			;       <word list><null term> 7F final term 
22db			 
22db			 
22db			if DEBUG_FORTH_UWORD 
22db						DMARK ":02" 
22db f5				push af  
22dc 3a f0 22			ld a, (.dmark)  
22df 32 6b ee			ld (debug_mark),a  
22e2 3a f1 22			ld a, (.dmark+1)  
22e5 32 6c ee			ld (debug_mark+1),a  
22e8 3a f2 22			ld a, (.dmark+2)  
22eb 32 6d ee			ld (debug_mark+2),a  
22ee 18 03			jr .pastdmark  
22f0 ..			.dmark: db ":02"  
22f3 f1			.pastdmark: pop af  
22f4			endm  
# End of macro DMARK
22f4				CALLMONITOR 
22f4 cd 6f ee			call debug_vector  
22f7				endm  
# End of macro CALLMONITOR
22f7			endif 
22f7			 
22f7				 
22f7					; malloc the size 
22f7			 
22f7 cd ae 12				call malloc 
22fa 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
22fd			 
22fd			;    db   1     ; user defined word  
22fd 3e 01				ld a, WORD_SYS_UWORD  
22ff 77					ld (hl), a 
2300				 
2300 23				inc hl    
2301			;    dw   sysdict 
2301 11 4b 21			ld de, sysdict       ; continue on with the scan to the system dict 
2304 73				ld (hl), e 
2305 23				inc hl 
2306 72				ld (hl), d 
2307 23				inc hl 
2308			 
2308			 
2308			;    Setup dict word 
2308			 
2308 23				inc hl 
2309 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
230c			 
230c				; 1. get length of dict word 
230c			 
230c			 
230c 2a c2 e5			ld hl, (os_tok_ptr) 
230f 23				inc hl 
2310 23				inc hl    ; position to start of dict word 
2311 3e 00			ld a, 0 
2313 cd 50 12			call strlent 
2316			 
2316			 
2316 23				inc hl    ; to include null??? 
2317			 
2317				; write length of dict word 
2317			 
2317 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
231b 1b				dec de 
231c eb				ex de, hl 
231d 73				ld (hl), e 
231e eb				ex de, hl 
231f			 
231f				 
231f			 
231f				; copy  
231f 4d				ld c, l 
2320 06 00			ld b, 0 
2322 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2326 2a c2 e5			ld hl, (os_tok_ptr) 
2329 23				inc hl 
232a 23				inc hl    ; position to start of dict word 
232b				 
232b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
232b				 
232b				; TODO need to convert word to upper case 
232b			 
232b			ucasetok:	 
232b 7e				ld a,(hl) 
232c cd 3c 12			call toUpper 
232f 77				ld (hl),a 
2330 ed a0			ldi 
2332 f2 2b 23		 	jp p, ucasetok 
2335			 
2335			 
2335			 
2335				; de now points to start of where the word body code should be placed 
2335 ed 53 b9 e2		ld (os_new_work_ptr), de 
2339				; hl now points to the words to throw at forthexec which needs to be copied 
2339 22 b7 e2			ld (os_new_src_ptr), hl 
233c			 
233c				; TODO add 'call to forthexec' 
233c			 
233c			if DEBUG_FORTH_UWORD 
233c c5				push bc 
233d ed 4b bf e2		ld bc, (os_new_malloc) 
2341						DMARK ":0x" 
2341 f5				push af  
2342 3a 56 23			ld a, (.dmark)  
2345 32 6b ee			ld (debug_mark),a  
2348 3a 57 23			ld a, (.dmark+1)  
234b 32 6c ee			ld (debug_mark+1),a  
234e 3a 58 23			ld a, (.dmark+2)  
2351 32 6d ee			ld (debug_mark+2),a  
2354 18 03			jr .pastdmark  
2356 ..			.dmark: db ":0x"  
2359 f1			.pastdmark: pop af  
235a			endm  
# End of macro DMARK
235a				CALLMONITOR 
235a cd 6f ee			call debug_vector  
235d				endm  
# End of macro CALLMONITOR
235d c1				pop bc 
235e			endif 
235e			 
235e			 
235e				; create word preamble which should be: 
235e			 
235e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
235e			 
235e				;    ld hl, <word code> 
235e				;    jp user_exec 
235e			        ;    <word code bytes> 
235e			 
235e			 
235e			;	inc de     ; TODO ??? or are we already past the word's null 
235e eb				ex de, hl 
235f			 
235f 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2361			 
2361 23				inc hl 
2362 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2365 23				inc hl 
2366			 
2366 23				inc hl 
2367 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2369			 
2369 01 60 4c			ld bc, user_exec 
236c 23				inc hl 
236d 71				ld (hl), c     ; poke address of user_exec 
236e 23				inc hl 
236f 70				ld (hl), b     
2370			 ; 
2370			;	inc hl 
2370			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2370			; 
2370			; 
2370			;	ld bc, macro_forth_rsp_next 
2370			;	inc hl 
2370			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2370			;	inc hl 
2370			;	ld (hl), b     
2370			 ; 
2370			;	inc hl 
2370			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2370			; 
2370			; 
2370			;	inc hl 
2370			;	ld bc, forthexec 
2370			;	ld (hl), c     ; poke address of forthexec 
2370			;	inc hl 
2370			;	ld (hl), b      
2370			; 
2370			;	inc hl 
2370			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2370			; 
2370			;	ld bc, user_dict_next 
2370			;	inc hl 
2370			;	ld (hl), c     ; poke address of forthexec 
2370			;	inc hl 
2370			;	ld (hl), b      
2370			 
2370				; hl is now where we need to copy the word byte data to save this 
2370			 
2370 23				inc hl 
2371 22 b5 e2			ld (os_new_exec), hl 
2374				 
2374				; copy definition 
2374			 
2374 eb				ex de, hl 
2375			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2375			;	inc de    ; skip the PC for this parse 
2375 3a bd e2			ld a, (os_new_parse_len) 
2378 4f				ld c, a 
2379 06 00			ld b, 0 
237b ed b0			ldir		 ; copy defintion 
237d			 
237d			 
237d				; poke the address of where the new word bytes live for forthexec 
237d			 
237d 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2380			 
2380 ed 5b b5 e2		ld de, (os_new_exec)      
2384				 
2384 73				ld (hl), e 
2385 23				inc hl 
2386 72				ld (hl), d 
2387			 
2387					; TODO copy last user dict word next link to this word 
2387					; TODO update last user dict word to point to this word 
2387			; 
2387			; hl f923 de 812a ; bc 811a 
2387			 
2387			if DEBUG_FORTH_UWORD 
2387 c5				push bc 
2388 ed 4b bf e2		ld bc, (os_new_malloc) 
238c						DMARK ":0A" 
238c f5				push af  
238d 3a a1 23			ld a, (.dmark)  
2390 32 6b ee			ld (debug_mark),a  
2393 3a a2 23			ld a, (.dmark+1)  
2396 32 6c ee			ld (debug_mark+1),a  
2399 3a a3 23			ld a, (.dmark+2)  
239c 32 6d ee			ld (debug_mark+2),a  
239f 18 03			jr .pastdmark  
23a1 ..			.dmark: db ":0A"  
23a4 f1			.pastdmark: pop af  
23a5			endm  
# End of macro DMARK
23a5				CALLMONITOR 
23a5 cd 6f ee			call debug_vector  
23a8				endm  
# End of macro CALLMONITOR
23a8 c1				pop bc 
23a9			endif 
23a9			if DEBUG_FORTH_UWORD 
23a9 c5				push bc 
23aa ed 4b bf e2		ld bc, (os_new_malloc) 
23ae 03				inc bc 
23af 03				inc bc 
23b0 03				inc bc 
23b1 03				inc bc 
23b2 03				inc bc 
23b3 03				inc bc 
23b4 03				inc bc 
23b5 03				inc bc 
23b6			 
23b6						DMARK ":0B" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 6b ee			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 6c ee			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 6d ee			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db ":0B"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf				CALLMONITOR 
23cf cd 6f ee			call debug_vector  
23d2				endm  
# End of macro CALLMONITOR
23d2 c1				pop bc 
23d3			endif 
23d3			 
23d3			; update word dict linked list for new word 
23d3			 
23d3			 
23d3 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23d6 23			inc hl     ; move to next work linked list ptr 
23d7			 
23d7 ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
23db 73			ld (hl), e 
23dc 23			inc hl 
23dd 72			ld (hl), d 
23de			 
23de			if DEBUG_FORTH_UWORD 
23de ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23e2			endif 
23e2			 
23e2 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23e6			 
23e6			 
23e6			if DEBUG_FORTH_UWORD 
23e6						DMARK ":0+" 
23e6 f5				push af  
23e7 3a fb 23			ld a, (.dmark)  
23ea 32 6b ee			ld (debug_mark),a  
23ed 3a fc 23			ld a, (.dmark+1)  
23f0 32 6c ee			ld (debug_mark+1),a  
23f3 3a fd 23			ld a, (.dmark+2)  
23f6 32 6d ee			ld (debug_mark+2),a  
23f9 18 03			jr .pastdmark  
23fb ..			.dmark: db ":0+"  
23fe f1			.pastdmark: pop af  
23ff			endm  
# End of macro DMARK
23ff				CALLMONITOR 
23ff cd 6f ee			call debug_vector  
2402				endm  
# End of macro CALLMONITOR
2402			endif 
2402			 
2402				STACKFRAMECHK OFF $8efe $989f 
2402				if DEBUG_STACK_IMB 
2402					if OFF 
2402						exx 
2402						ld hl, $989f 
2402						pop de   ; $989f 
2402						call cmp16 
2402						jr nz, .spnosame 
2402						ld hl, $8efe 
2402						pop de   ; $8efe 
2402						call cmp16 
2402						jr z, .spfrsame 
2402						.spnosame: call showsperror 
2402						.spfrsame: nop 
2402						exx 
2402					endif 
2402				endif 
2402			endm 
# End of macro STACKFRAMECHK
2402			 
2402 c9			ret    ; dont process any remaining parser tokens as they form new word 
2403			 
2403			 
2403			 
2403			 
2403			;		NEXT 
2403			.SCOLN: 
2403			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2403 06				db OPCODE_SCOLN 
2404 4f 24			dw .DROP 
2406 02				db 2 
2407 .. 00			db ";",0           
2409			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2409					if DEBUG_FORTH_WORDS_KEY 
2409						DMARK "SCN" 
2409 f5				push af  
240a 3a 1e 24			ld a, (.dmark)  
240d 32 6b ee			ld (debug_mark),a  
2410 3a 1f 24			ld a, (.dmark+1)  
2413 32 6c ee			ld (debug_mark+1),a  
2416 3a 20 24			ld a, (.dmark+2)  
2419 32 6d ee			ld (debug_mark+2),a  
241c 18 03			jr .pastdmark  
241e ..			.dmark: db "SCN"  
2421 f1			.pastdmark: pop af  
2422			endm  
# End of macro DMARK
2422						CALLMONITOR 
2422 cd 6f ee			call debug_vector  
2425				endm  
# End of macro CALLMONITOR
2425					endif 
2425					FORTH_RSP_TOS 
2425 cd 04 1c			call macro_forth_rsp_tos 
2428				endm 
# End of macro FORTH_RSP_TOS
2428 e5					push hl 
2429					FORTH_RSP_POP 
2429 cd 0e 1c			call macro_forth_rsp_pop 
242c				endm 
# End of macro FORTH_RSP_POP
242c e1					pop hl 
242d			;		ex de,hl 
242d 22 c2 e5				ld (os_tok_ptr),hl 
2430			 
2430			if DEBUG_FORTH_UWORD 
2430						DMARK "SCL" 
2430 f5				push af  
2431 3a 45 24			ld a, (.dmark)  
2434 32 6b ee			ld (debug_mark),a  
2437 3a 46 24			ld a, (.dmark+1)  
243a 32 6c ee			ld (debug_mark+1),a  
243d 3a 47 24			ld a, (.dmark+2)  
2440 32 6d ee			ld (debug_mark+2),a  
2443 18 03			jr .pastdmark  
2445 ..			.dmark: db "SCL"  
2448 f1			.pastdmark: pop af  
2449			endm  
# End of macro DMARK
2449				CALLMONITOR 
2449 cd 6f ee			call debug_vector  
244c				endm  
# End of macro CALLMONITOR
244c			endif 
244c					NEXTW 
244c c3 f3 1f			jp macro_next 
244f				endm 
# End of macro NEXTW
244f			 
244f			.DROP: 
244f				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
244f 1b				db WORD_SYS_CORE+OPCODE_DROP             
2450 7a 24			dw .DUP2            
2452 05				db 4 + 1 
2453 .. 00			db "DROP",0              
2458				endm 
# End of macro CWHEAD
2458			; | DROP ( w -- )   drop the TOS item   | DONE 
2458					if DEBUG_FORTH_WORDS_KEY 
2458						DMARK "DRP" 
2458 f5				push af  
2459 3a 6d 24			ld a, (.dmark)  
245c 32 6b ee			ld (debug_mark),a  
245f 3a 6e 24			ld a, (.dmark+1)  
2462 32 6c ee			ld (debug_mark+1),a  
2465 3a 6f 24			ld a, (.dmark+2)  
2468 32 6d ee			ld (debug_mark+2),a  
246b 18 03			jr .pastdmark  
246d ..			.dmark: db "DRP"  
2470 f1			.pastdmark: pop af  
2471			endm  
# End of macro DMARK
2471						CALLMONITOR 
2471 cd 6f ee			call debug_vector  
2474				endm  
# End of macro CALLMONITOR
2474					endif 
2474					FORTH_DSP_POP 
2474 cd f5 1e			call macro_forth_dsp_pop 
2477				endm 
# End of macro FORTH_DSP_POP
2477					NEXTW 
2477 c3 f3 1f			jp macro_next 
247a				endm 
# End of macro NEXTW
247a			.DUP2: 
247a				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
247a 1c				db WORD_SYS_CORE+OPCODE_DUP2             
247b bf 24			dw .DROP2            
247d 05				db 4 + 1 
247e .. 00			db "2DUP",0              
2483				endm 
# End of macro CWHEAD
2483			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2483					if DEBUG_FORTH_WORDS_KEY 
2483						DMARK "2DU" 
2483 f5				push af  
2484 3a 98 24			ld a, (.dmark)  
2487 32 6b ee			ld (debug_mark),a  
248a 3a 99 24			ld a, (.dmark+1)  
248d 32 6c ee			ld (debug_mark+1),a  
2490 3a 9a 24			ld a, (.dmark+2)  
2493 32 6d ee			ld (debug_mark+2),a  
2496 18 03			jr .pastdmark  
2498 ..			.dmark: db "2DU"  
249b f1			.pastdmark: pop af  
249c			endm  
# End of macro DMARK
249c						CALLMONITOR 
249c cd 6f ee			call debug_vector  
249f				endm  
# End of macro CALLMONITOR
249f					endif 
249f					FORTH_DSP_VALUEHL 
249f cd 3d 1e			call macro_dsp_valuehl 
24a2				endm 
# End of macro FORTH_DSP_VALUEHL
24a2 e5					push hl      ; 2 
24a3			 
24a3					FORTH_DSP_POP 
24a3 cd f5 1e			call macro_forth_dsp_pop 
24a6				endm 
# End of macro FORTH_DSP_POP
24a6					 
24a6					FORTH_DSP_VALUEHL 
24a6 cd 3d 1e			call macro_dsp_valuehl 
24a9				endm 
# End of macro FORTH_DSP_VALUEHL
24a9			;		push hl      ; 1 
24a9			 
24a9					FORTH_DSP_POP 
24a9 cd f5 1e			call macro_forth_dsp_pop 
24ac				endm 
# End of macro FORTH_DSP_POP
24ac			 
24ac			;		pop hl       ; 1 
24ac d1					pop de       ; 2 
24ad			 
24ad cd 46 1c				call forth_push_numhl 
24b0 eb					ex de, hl 
24b1 cd 46 1c				call forth_push_numhl 
24b4			 
24b4					 
24b4 eb					ex de, hl 
24b5			 
24b5 cd 46 1c				call forth_push_numhl 
24b8 eb					ex de, hl 
24b9 cd 46 1c				call forth_push_numhl 
24bc			 
24bc			 
24bc					NEXTW 
24bc c3 f3 1f			jp macro_next 
24bf				endm 
# End of macro NEXTW
24bf			.DROP2: 
24bf				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24bf 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24c0 ee 24			dw .SWAP2            
24c2 06				db 5 + 1 
24c3 .. 00			db "2DROP",0              
24c9				endm 
# End of macro CWHEAD
24c9			; | 2DROP ( w w -- )    Double drop | DONE 
24c9					if DEBUG_FORTH_WORDS_KEY 
24c9						DMARK "2DR" 
24c9 f5				push af  
24ca 3a de 24			ld a, (.dmark)  
24cd 32 6b ee			ld (debug_mark),a  
24d0 3a df 24			ld a, (.dmark+1)  
24d3 32 6c ee			ld (debug_mark+1),a  
24d6 3a e0 24			ld a, (.dmark+2)  
24d9 32 6d ee			ld (debug_mark+2),a  
24dc 18 03			jr .pastdmark  
24de ..			.dmark: db "2DR"  
24e1 f1			.pastdmark: pop af  
24e2			endm  
# End of macro DMARK
24e2						CALLMONITOR 
24e2 cd 6f ee			call debug_vector  
24e5				endm  
# End of macro CALLMONITOR
24e5					endif 
24e5					FORTH_DSP_POP 
24e5 cd f5 1e			call macro_forth_dsp_pop 
24e8				endm 
# End of macro FORTH_DSP_POP
24e8					FORTH_DSP_POP 
24e8 cd f5 1e			call macro_forth_dsp_pop 
24eb				endm 
# End of macro FORTH_DSP_POP
24eb					NEXTW 
24eb c3 f3 1f			jp macro_next 
24ee				endm 
# End of macro NEXTW
24ee			.SWAP2: 
24ee				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24ee 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24ef 17 25			dw .AT            
24f1 06				db 5 + 1 
24f2 .. 00			db "2SWAP",0              
24f8				endm 
# End of macro CWHEAD
24f8			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24f8					if DEBUG_FORTH_WORDS_KEY 
24f8						DMARK "2SW" 
24f8 f5				push af  
24f9 3a 0d 25			ld a, (.dmark)  
24fc 32 6b ee			ld (debug_mark),a  
24ff 3a 0e 25			ld a, (.dmark+1)  
2502 32 6c ee			ld (debug_mark+1),a  
2505 3a 0f 25			ld a, (.dmark+2)  
2508 32 6d ee			ld (debug_mark+2),a  
250b 18 03			jr .pastdmark  
250d ..			.dmark: db "2SW"  
2510 f1			.pastdmark: pop af  
2511			endm  
# End of macro DMARK
2511						CALLMONITOR 
2511 cd 6f ee			call debug_vector  
2514				endm  
# End of macro CALLMONITOR
2514					endif 
2514					NEXTW 
2514 c3 f3 1f			jp macro_next 
2517				endm 
# End of macro NEXTW
2517			.AT: 
2517				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2517 1f				db WORD_SYS_CORE+OPCODE_AT             
2518 49 25			dw .CAT            
251a 02				db 1 + 1 
251b .. 00			db "@",0              
251d				endm 
# End of macro CWHEAD
251d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
251d			 
251d					if DEBUG_FORTH_WORDS_KEY 
251d						DMARK "AT." 
251d f5				push af  
251e 3a 32 25			ld a, (.dmark)  
2521 32 6b ee			ld (debug_mark),a  
2524 3a 33 25			ld a, (.dmark+1)  
2527 32 6c ee			ld (debug_mark+1),a  
252a 3a 34 25			ld a, (.dmark+2)  
252d 32 6d ee			ld (debug_mark+2),a  
2530 18 03			jr .pastdmark  
2532 ..			.dmark: db "AT."  
2535 f1			.pastdmark: pop af  
2536			endm  
# End of macro DMARK
2536						CALLMONITOR 
2536 cd 6f ee			call debug_vector  
2539				endm  
# End of macro CALLMONITOR
2539					endif 
2539			.getbyteat:	 
2539					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2539 cd 3d 1e			call macro_dsp_valuehl 
253c				endm 
# End of macro FORTH_DSP_VALUEHL
253c					 
253c			;		push hl 
253c				 
253c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253c cd f5 1e			call macro_forth_dsp_pop 
253f				endm 
# End of macro FORTH_DSP_POP
253f			 
253f			;		pop hl 
253f			 
253f 7e					ld a, (hl) 
2540			 
2540 6f					ld l, a 
2541 26 00				ld h, 0 
2543 cd 46 1c				call forth_push_numhl 
2546			 
2546					NEXTW 
2546 c3 f3 1f			jp macro_next 
2549				endm 
# End of macro NEXTW
2549			.CAT: 
2549				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2549 20				db WORD_SYS_CORE+OPCODE_CAT             
254a 72 25			dw .BANG            
254c 03				db 2 + 1 
254d .. 00			db "C@",0              
2550				endm 
# End of macro CWHEAD
2550			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2550					if DEBUG_FORTH_WORDS_KEY 
2550						DMARK "CAA" 
2550 f5				push af  
2551 3a 65 25			ld a, (.dmark)  
2554 32 6b ee			ld (debug_mark),a  
2557 3a 66 25			ld a, (.dmark+1)  
255a 32 6c ee			ld (debug_mark+1),a  
255d 3a 67 25			ld a, (.dmark+2)  
2560 32 6d ee			ld (debug_mark+2),a  
2563 18 03			jr .pastdmark  
2565 ..			.dmark: db "CAA"  
2568 f1			.pastdmark: pop af  
2569			endm  
# End of macro DMARK
2569						CALLMONITOR 
2569 cd 6f ee			call debug_vector  
256c				endm  
# End of macro CALLMONITOR
256c					endif 
256c c3 39 25				jp .getbyteat 
256f					NEXTW 
256f c3 f3 1f			jp macro_next 
2572				endm 
# End of macro NEXTW
2572			.BANG: 
2572				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2572 21				db WORD_SYS_CORE+OPCODE_BANG             
2573 a8 25			dw .CBANG            
2575 02				db 1 + 1 
2576 .. 00			db "!",0              
2578				endm 
# End of macro CWHEAD
2578			; | ! ( x w -- ) Store x at address w      | DONE 
2578					if DEBUG_FORTH_WORDS_KEY 
2578						DMARK "BNG" 
2578 f5				push af  
2579 3a 8d 25			ld a, (.dmark)  
257c 32 6b ee			ld (debug_mark),a  
257f 3a 8e 25			ld a, (.dmark+1)  
2582 32 6c ee			ld (debug_mark+1),a  
2585 3a 8f 25			ld a, (.dmark+2)  
2588 32 6d ee			ld (debug_mark+2),a  
258b 18 03			jr .pastdmark  
258d ..			.dmark: db "BNG"  
2590 f1			.pastdmark: pop af  
2591			endm  
# End of macro DMARK
2591						CALLMONITOR 
2591 cd 6f ee			call debug_vector  
2594				endm  
# End of macro CALLMONITOR
2594					endif 
2594			 
2594			.storebyteat:		 
2594					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2594 cd 3d 1e			call macro_dsp_valuehl 
2597				endm 
# End of macro FORTH_DSP_VALUEHL
2597					 
2597 e5					push hl 
2598				 
2598					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2598 cd f5 1e			call macro_forth_dsp_pop 
259b				endm 
# End of macro FORTH_DSP_POP
259b			 
259b					; get byte to poke 
259b			 
259b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259b cd 3d 1e			call macro_dsp_valuehl 
259e				endm 
# End of macro FORTH_DSP_VALUEHL
259e e5					push hl 
259f			 
259f			 
259f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259f cd f5 1e			call macro_forth_dsp_pop 
25a2				endm 
# End of macro FORTH_DSP_POP
25a2			 
25a2			 
25a2 d1					pop de 
25a3 e1					pop hl 
25a4			 
25a4 73					ld (hl),e 
25a5			 
25a5			 
25a5					NEXTW 
25a5 c3 f3 1f			jp macro_next 
25a8				endm 
# End of macro NEXTW
25a8			.CBANG: 
25a8				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25a8 22				db WORD_SYS_CORE+OPCODE_CBANG             
25a9 d1 25			dw .SCALL            
25ab 03				db 2 + 1 
25ac .. 00			db "C!",0              
25af				endm 
# End of macro CWHEAD
25af			; | C!  ( x w -- ) Store x at address w  | DONE 
25af					if DEBUG_FORTH_WORDS_KEY 
25af						DMARK "CBA" 
25af f5				push af  
25b0 3a c4 25			ld a, (.dmark)  
25b3 32 6b ee			ld (debug_mark),a  
25b6 3a c5 25			ld a, (.dmark+1)  
25b9 32 6c ee			ld (debug_mark+1),a  
25bc 3a c6 25			ld a, (.dmark+2)  
25bf 32 6d ee			ld (debug_mark+2),a  
25c2 18 03			jr .pastdmark  
25c4 ..			.dmark: db "CBA"  
25c7 f1			.pastdmark: pop af  
25c8			endm  
# End of macro DMARK
25c8						CALLMONITOR 
25c8 cd 6f ee			call debug_vector  
25cb				endm  
# End of macro CALLMONITOR
25cb					endif 
25cb c3 94 25				jp .storebyteat 
25ce					NEXTW 
25ce c3 f3 1f			jp macro_next 
25d1				endm 
# End of macro NEXTW
25d1			.SCALL: 
25d1				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25d1 23				db WORD_SYS_CORE+OPCODE_SCALL             
25d2 05 26			dw .DEPTH            
25d4 05				db 4 + 1 
25d5 .. 00			db "CALL",0              
25da				endm 
# End of macro CWHEAD
25da			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25da					if DEBUG_FORTH_WORDS_KEY 
25da						DMARK "CLL" 
25da f5				push af  
25db 3a ef 25			ld a, (.dmark)  
25de 32 6b ee			ld (debug_mark),a  
25e1 3a f0 25			ld a, (.dmark+1)  
25e4 32 6c ee			ld (debug_mark+1),a  
25e7 3a f1 25			ld a, (.dmark+2)  
25ea 32 6d ee			ld (debug_mark+2),a  
25ed 18 03			jr .pastdmark  
25ef ..			.dmark: db "CLL"  
25f2 f1			.pastdmark: pop af  
25f3			endm  
# End of macro DMARK
25f3						CALLMONITOR 
25f3 cd 6f ee			call debug_vector  
25f6				endm  
# End of macro CALLMONITOR
25f6					endif 
25f6			 
25f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f6 cd 3d 1e			call macro_dsp_valuehl 
25f9				endm 
# End of macro FORTH_DSP_VALUEHL
25f9			 
25f9			;		push hl 
25f9			 
25f9					; destroy value TOS 
25f9			 
25f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f9 cd f5 1e			call macro_forth_dsp_pop 
25fc				endm 
# End of macro FORTH_DSP_POP
25fc			 
25fc						 
25fc			;		pop hl 
25fc			 
25fc					; how to do a call with hl???? save SP? 
25fc cd 97 1f				call forth_call_hl 
25ff			 
25ff			 
25ff					; TODO push value back onto stack for another op etc 
25ff			 
25ff cd 46 1c				call forth_push_numhl 
2602					NEXTW 
2602 c3 f3 1f			jp macro_next 
2605				endm 
# End of macro NEXTW
2605			.DEPTH: 
2605				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2605 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2606 42 26			dw .OVER            
2608 06				db 5 + 1 
2609 .. 00			db "DEPTH",0              
260f				endm 
# End of macro CWHEAD
260f			; | DEPTH ( -- u ) Push count of stack | DONE 
260f					; take current TOS and remove from base value div by two to get count 
260f					if DEBUG_FORTH_WORDS_KEY 
260f						DMARK "DEP" 
260f f5				push af  
2610 3a 24 26			ld a, (.dmark)  
2613 32 6b ee			ld (debug_mark),a  
2616 3a 25 26			ld a, (.dmark+1)  
2619 32 6c ee			ld (debug_mark+1),a  
261c 3a 26 26			ld a, (.dmark+2)  
261f 32 6d ee			ld (debug_mark+2),a  
2622 18 03			jr .pastdmark  
2624 ..			.dmark: db "DEP"  
2627 f1			.pastdmark: pop af  
2628			endm  
# End of macro DMARK
2628						CALLMONITOR 
2628 cd 6f ee			call debug_vector  
262b				endm  
# End of macro CALLMONITOR
262b					endif 
262b			 
262b			 
262b 2a ee e9			ld hl, (cli_data_sp) 
262e 11 28 e8			ld de, cli_data_stack 
2631 ed 52			sbc hl,de 
2633				 
2633				; div by size of stack item 
2633			 
2633 5d				ld e,l 
2634 0e 03			ld c, 3 
2636 cd 77 0d			call Div8 
2639			 
2639 6f				ld l,a 
263a 26 00			ld h,0 
263c			 
263c				;srl h 
263c				;rr l 
263c			 
263c cd 46 1c				call forth_push_numhl 
263f					NEXTW 
263f c3 f3 1f			jp macro_next 
2642				endm 
# End of macro NEXTW
2642			.OVER: 
2642				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2642 42				db WORD_SYS_CORE+46             
2643 89 26			dw .PAUSE            
2645 05				db 4 + 1 
2646 .. 00			db "OVER",0              
264b				endm 
# End of macro CWHEAD
264b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
264b					if DEBUG_FORTH_WORDS_KEY 
264b						DMARK "OVR" 
264b f5				push af  
264c 3a 60 26			ld a, (.dmark)  
264f 32 6b ee			ld (debug_mark),a  
2652 3a 61 26			ld a, (.dmark+1)  
2655 32 6c ee			ld (debug_mark+1),a  
2658 3a 62 26			ld a, (.dmark+2)  
265b 32 6d ee			ld (debug_mark+2),a  
265e 18 03			jr .pastdmark  
2660 ..			.dmark: db "OVR"  
2663 f1			.pastdmark: pop af  
2664			endm  
# End of macro DMARK
2664						CALLMONITOR 
2664 cd 6f ee			call debug_vector  
2667				endm  
# End of macro CALLMONITOR
2667					endif 
2667			 
2667					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2667 cd 3d 1e			call macro_dsp_valuehl 
266a				endm 
# End of macro FORTH_DSP_VALUEHL
266a e5					push hl    ; n2 
266b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
266b cd f5 1e			call macro_forth_dsp_pop 
266e				endm 
# End of macro FORTH_DSP_POP
266e			 
266e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266e cd 3d 1e			call macro_dsp_valuehl 
2671				endm 
# End of macro FORTH_DSP_VALUEHL
2671 e5					push hl    ; n1 
2672					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2672 cd f5 1e			call macro_forth_dsp_pop 
2675				endm 
# End of macro FORTH_DSP_POP
2675			 
2675 d1					pop de     ; n1 
2676 e1					pop hl     ; n2 
2677			 
2677 d5					push de 
2678 e5					push hl 
2679 d5					push de 
267a			 
267a					; push back  
267a			 
267a e1					pop hl 
267b cd 46 1c				call forth_push_numhl 
267e e1					pop hl 
267f cd 46 1c				call forth_push_numhl 
2682 e1					pop hl 
2683 cd 46 1c				call forth_push_numhl 
2686					NEXTW 
2686 c3 f3 1f			jp macro_next 
2689				endm 
# End of macro NEXTW
2689			 
2689			.PAUSE: 
2689				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2689 43				db WORD_SYS_CORE+47             
268a be 26			dw .PAUSES            
268c 08				db 7 + 1 
268d .. 00			db "PAUSEMS",0              
2695				endm 
# End of macro CWHEAD
2695			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2695					if DEBUG_FORTH_WORDS_KEY 
2695						DMARK "PMS" 
2695 f5				push af  
2696 3a aa 26			ld a, (.dmark)  
2699 32 6b ee			ld (debug_mark),a  
269c 3a ab 26			ld a, (.dmark+1)  
269f 32 6c ee			ld (debug_mark+1),a  
26a2 3a ac 26			ld a, (.dmark+2)  
26a5 32 6d ee			ld (debug_mark+2),a  
26a8 18 03			jr .pastdmark  
26aa ..			.dmark: db "PMS"  
26ad f1			.pastdmark: pop af  
26ae			endm  
# End of macro DMARK
26ae						CALLMONITOR 
26ae cd 6f ee			call debug_vector  
26b1				endm  
# End of macro CALLMONITOR
26b1					endif 
26b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b1 cd 3d 1e			call macro_dsp_valuehl 
26b4				endm 
# End of macro FORTH_DSP_VALUEHL
26b4			;		push hl    ; n2 
26b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b4 cd f5 1e			call macro_forth_dsp_pop 
26b7				endm 
# End of macro FORTH_DSP_POP
26b7			;		pop hl 
26b7			 
26b7 7d					ld a, l 
26b8 cd d7 0a				call aDelayInMS 
26bb				       NEXTW 
26bb c3 f3 1f			jp macro_next 
26be				endm 
# End of macro NEXTW
26be			.PAUSES:  
26be				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26be 44				db WORD_SYS_CORE+48             
26bf 2d 27			dw .ROT            
26c1 06				db 5 + 1 
26c2 .. 00			db "PAUSE",0              
26c8				endm 
# End of macro CWHEAD
26c8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26c8					if DEBUG_FORTH_WORDS_KEY 
26c8						DMARK "PAU" 
26c8 f5				push af  
26c9 3a dd 26			ld a, (.dmark)  
26cc 32 6b ee			ld (debug_mark),a  
26cf 3a de 26			ld a, (.dmark+1)  
26d2 32 6c ee			ld (debug_mark+1),a  
26d5 3a df 26			ld a, (.dmark+2)  
26d8 32 6d ee			ld (debug_mark+2),a  
26db 18 03			jr .pastdmark  
26dd ..			.dmark: db "PAU"  
26e0 f1			.pastdmark: pop af  
26e1			endm  
# End of macro DMARK
26e1						CALLMONITOR 
26e1 cd 6f ee			call debug_vector  
26e4				endm  
# End of macro CALLMONITOR
26e4					endif 
26e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e4 cd 3d 1e			call macro_dsp_valuehl 
26e7				endm 
# End of macro FORTH_DSP_VALUEHL
26e7			;		push hl    ; n2 
26e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e7 cd f5 1e			call macro_forth_dsp_pop 
26ea				endm 
# End of macro FORTH_DSP_POP
26ea			;		pop hl 
26ea 45					ld b, l 
26eb					if DEBUG_FORTH_WORDS 
26eb						DMARK "PAU" 
26eb f5				push af  
26ec 3a 00 27			ld a, (.dmark)  
26ef 32 6b ee			ld (debug_mark),a  
26f2 3a 01 27			ld a, (.dmark+1)  
26f5 32 6c ee			ld (debug_mark+1),a  
26f8 3a 02 27			ld a, (.dmark+2)  
26fb 32 6d ee			ld (debug_mark+2),a  
26fe 18 03			jr .pastdmark  
2700 ..			.dmark: db "PAU"  
2703 f1			.pastdmark: pop af  
2704			endm  
# End of macro DMARK
2704						CALLMONITOR 
2704 cd 6f ee			call debug_vector  
2707				endm  
# End of macro CALLMONITOR
2707					endif 
2707 c5			.pauses1:	push bc 
2708 cd f2 0a				call delay1s 
270b c1					pop bc 
270c					if DEBUG_FORTH_WORDS 
270c						DMARK "PA1" 
270c f5				push af  
270d 3a 21 27			ld a, (.dmark)  
2710 32 6b ee			ld (debug_mark),a  
2713 3a 22 27			ld a, (.dmark+1)  
2716 32 6c ee			ld (debug_mark+1),a  
2719 3a 23 27			ld a, (.dmark+2)  
271c 32 6d ee			ld (debug_mark+2),a  
271f 18 03			jr .pastdmark  
2721 ..			.dmark: db "PA1"  
2724 f1			.pastdmark: pop af  
2725			endm  
# End of macro DMARK
2725						CALLMONITOR 
2725 cd 6f ee			call debug_vector  
2728				endm  
# End of macro CALLMONITOR
2728					endif 
2728 10 dd				djnz .pauses1 
272a			 
272a				       NEXTW 
272a c3 f3 1f			jp macro_next 
272d				endm 
# End of macro NEXTW
272d			.ROT: 
272d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
272d 45				db WORD_SYS_CORE+49             
272e 7b 27			dw .UWORDS            
2730 04				db 3 + 1 
2731 .. 00			db "ROT",0              
2735				endm 
# End of macro CWHEAD
2735			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2735					if DEBUG_FORTH_WORDS_KEY 
2735						DMARK "ROT" 
2735 f5				push af  
2736 3a 4a 27			ld a, (.dmark)  
2739 32 6b ee			ld (debug_mark),a  
273c 3a 4b 27			ld a, (.dmark+1)  
273f 32 6c ee			ld (debug_mark+1),a  
2742 3a 4c 27			ld a, (.dmark+2)  
2745 32 6d ee			ld (debug_mark+2),a  
2748 18 03			jr .pastdmark  
274a ..			.dmark: db "ROT"  
274d f1			.pastdmark: pop af  
274e			endm  
# End of macro DMARK
274e						CALLMONITOR 
274e cd 6f ee			call debug_vector  
2751				endm  
# End of macro CALLMONITOR
2751					endif 
2751			 
2751					FORTH_DSP_VALUEHL 
2751 cd 3d 1e			call macro_dsp_valuehl 
2754				endm 
# End of macro FORTH_DSP_VALUEHL
2754 e5					push hl    ; u3  
2755			 
2755					FORTH_DSP_POP 
2755 cd f5 1e			call macro_forth_dsp_pop 
2758				endm 
# End of macro FORTH_DSP_POP
2758			   
2758					FORTH_DSP_VALUEHL 
2758 cd 3d 1e			call macro_dsp_valuehl 
275b				endm 
# End of macro FORTH_DSP_VALUEHL
275b e5					push hl     ; u2 
275c			 
275c					FORTH_DSP_POP 
275c cd f5 1e			call macro_forth_dsp_pop 
275f				endm 
# End of macro FORTH_DSP_POP
275f			 
275f					FORTH_DSP_VALUEHL 
275f cd 3d 1e			call macro_dsp_valuehl 
2762				endm 
# End of macro FORTH_DSP_VALUEHL
2762 e5					push hl     ; u1 
2763			 
2763					FORTH_DSP_POP 
2763 cd f5 1e			call macro_forth_dsp_pop 
2766				endm 
# End of macro FORTH_DSP_POP
2766			 
2766 c1					pop bc      ; u1 
2767 e1					pop hl      ; u2 
2768 d1					pop de      ; u3 
2769			 
2769			 
2769 c5					push bc 
276a d5					push de 
276b e5					push hl 
276c			 
276c			 
276c e1					pop hl 
276d cd 46 1c				call forth_push_numhl 
2770			 
2770 e1					pop hl 
2771 cd 46 1c				call forth_push_numhl 
2774			 
2774 e1					pop hl 
2775 cd 46 1c				call forth_push_numhl 
2778					 
2778			 
2778			 
2778			 
2778			 
2778			 
2778				       NEXTW 
2778 c3 f3 1f			jp macro_next 
277b				endm 
# End of macro NEXTW
277b			 
277b			.UWORDS: 
277b				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
277b 50				db WORD_SYS_CORE+60             
277c 3d 28			dw .BP            
277e 07				db 6 + 1 
277f .. 00			db "UWORDS",0              
2786				endm 
# End of macro CWHEAD
2786			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2786			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2786			; | | Following the count are the individual words. 
2786			; | | 
2786			; | | e.g. UWORDS 
2786			; | | BOX DIRLIST 2 
2786			; | |  
2786			; | | Can be used to save the words to storage via: 
2786			; | | UWORDS $01 DO $01 APPEND LOOP 
2786				if DEBUG_FORTH_WORDS_KEY 
2786					DMARK "UWR" 
2786 f5				push af  
2787 3a 9b 27			ld a, (.dmark)  
278a 32 6b ee			ld (debug_mark),a  
278d 3a 9c 27			ld a, (.dmark+1)  
2790 32 6c ee			ld (debug_mark+1),a  
2793 3a 9d 27			ld a, (.dmark+2)  
2796 32 6d ee			ld (debug_mark+2),a  
2799 18 03			jr .pastdmark  
279b ..			.dmark: db "UWR"  
279e f1			.pastdmark: pop af  
279f			endm  
# End of macro DMARK
279f					CALLMONITOR 
279f cd 6f ee			call debug_vector  
27a2				endm  
# End of macro CALLMONITOR
27a2				endif 
27a2 21 90 65				ld hl, baseram 
27a5					;ld hl, baseusermem 
27a5 01 00 00				ld bc, 0    ; start a counter 
27a8			 
27a8				; skip dict stub 
27a8			 
27a8 cd 44 21				call forth_tok_next 
27ab			 
27ab			 
27ab			; while we have words to look for 
27ab			 
27ab 7e			.douscan:	ld a, (hl)      
27ac				if DEBUG_FORTH_WORDS 
27ac					DMARK "UWs" 
27ac f5				push af  
27ad 3a c1 27			ld a, (.dmark)  
27b0 32 6b ee			ld (debug_mark),a  
27b3 3a c2 27			ld a, (.dmark+1)  
27b6 32 6c ee			ld (debug_mark+1),a  
27b9 3a c3 27			ld a, (.dmark+2)  
27bc 32 6d ee			ld (debug_mark+2),a  
27bf 18 03			jr .pastdmark  
27c1 ..			.dmark: db "UWs"  
27c4 f1			.pastdmark: pop af  
27c5			endm  
# End of macro DMARK
27c5					CALLMONITOR 
27c5 cd 6f ee			call debug_vector  
27c8				endm  
# End of macro CALLMONITOR
27c8				endif 
27c8 fe 00				cp WORD_SYS_END 
27ca 28 4d				jr z, .udone 
27cc fe 01				cp WORD_SYS_UWORD 
27ce 20 44				jr nz, .nuword 
27d0			 
27d0				if DEBUG_FORTH_WORDS 
27d0					DMARK "UWu" 
27d0 f5				push af  
27d1 3a e5 27			ld a, (.dmark)  
27d4 32 6b ee			ld (debug_mark),a  
27d7 3a e6 27			ld a, (.dmark+1)  
27da 32 6c ee			ld (debug_mark+1),a  
27dd 3a e7 27			ld a, (.dmark+2)  
27e0 32 6d ee			ld (debug_mark+2),a  
27e3 18 03			jr .pastdmark  
27e5 ..			.dmark: db "UWu"  
27e8 f1			.pastdmark: pop af  
27e9			endm  
# End of macro DMARK
27e9					CALLMONITOR 
27e9 cd 6f ee			call debug_vector  
27ec				endm  
# End of macro CALLMONITOR
27ec				endif 
27ec					; we have a uword so push its name to the stack 
27ec			 
27ec e5				   	push hl  ; save so we can move to next dict block 
27ed			 
27ed					; skip opcode 
27ed 23					inc hl  
27ee					; skip next ptr 
27ee 23					inc hl  
27ef 23					inc hl 
27f0					; skip len 
27f0 23					inc hl 
27f1				if DEBUG_FORTH_WORDS 
27f1					DMARK "UWt" 
27f1 f5				push af  
27f2 3a 06 28			ld a, (.dmark)  
27f5 32 6b ee			ld (debug_mark),a  
27f8 3a 07 28			ld a, (.dmark+1)  
27fb 32 6c ee			ld (debug_mark+1),a  
27fe 3a 08 28			ld a, (.dmark+2)  
2801 32 6d ee			ld (debug_mark+2),a  
2804 18 03			jr .pastdmark  
2806 ..			.dmark: db "UWt"  
2809 f1			.pastdmark: pop af  
280a			endm  
# End of macro DMARK
280a					CALLMONITOR 
280a cd 6f ee			call debug_vector  
280d				endm  
# End of macro CALLMONITOR
280d				endif 
280d 03					inc bc 
280e			 
280e c5					push bc 
280f cd b4 1c				call forth_push_str 
2812 c1					pop bc 
2813			 
2813 e1					pop hl 	 
2814			 
2814 cd 44 21		.nuword:	call forth_tok_next 
2817 18 92				jr .douscan  
2819			 
2819			.udone:		 ; push count of uwords found 
2819 c5					push bc 
281a e1					pop hl 
281b			 
281b				if DEBUG_FORTH_WORDS 
281b					DMARK "UWc" 
281b f5				push af  
281c 3a 30 28			ld a, (.dmark)  
281f 32 6b ee			ld (debug_mark),a  
2822 3a 31 28			ld a, (.dmark+1)  
2825 32 6c ee			ld (debug_mark+1),a  
2828 3a 32 28			ld a, (.dmark+2)  
282b 32 6d ee			ld (debug_mark+2),a  
282e 18 03			jr .pastdmark  
2830 ..			.dmark: db "UWc"  
2833 f1			.pastdmark: pop af  
2834			endm  
# End of macro DMARK
2834					CALLMONITOR 
2834 cd 6f ee			call debug_vector  
2837				endm  
# End of macro CALLMONITOR
2837				endif 
2837 cd 46 1c				call forth_push_numhl 
283a			 
283a			 
283a				       NEXTW 
283a c3 f3 1f			jp macro_next 
283d				endm 
# End of macro NEXTW
283d			 
283d			.BP: 
283d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
283d 54				db WORD_SYS_CORE+64             
283e 77 28			dw .MONITOR            
2840 03				db 2 + 1 
2841 .. 00			db "BP",0              
2844				endm 
# End of macro CWHEAD
2844			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2844			; | | $00 Will enable the break points within specific code paths 
2844			; | | $01 Will disable break points 
2844			; | |  
2844			; | | By default break points are off. Either the above can be used to enable them 
2844			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2844			; | | and on release of the pressed key a message will be disaplayed to notify 
2844			; | | that break points are enabled. Pressing any key will then continue boot process. 
2844					; get byte count 
2844					if DEBUG_FORTH_WORDS_KEY 
2844						DMARK "BP." 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 6b ee			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 6c ee			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 6d ee			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "BP."  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d						CALLMONITOR 
285d cd 6f ee			call debug_vector  
2860				endm  
# End of macro CALLMONITOR
2860					endif 
2860			 
2860					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2860 cd 3d 1e			call macro_dsp_valuehl 
2863				endm 
# End of macro FORTH_DSP_VALUEHL
2863			 
2863			;		push hl 
2863			 
2863					; destroy value TOS 
2863			 
2863					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2863 cd f5 1e			call macro_forth_dsp_pop 
2866				endm 
# End of macro FORTH_DSP_POP
2866			 
2866			;		pop hl 
2866			 
2866 3e 00				ld a,0 
2868 bd					cp l 
2869 28 06				jr z, .bpset 
286b			;		ld a, '*' 
286b cd e9 15				call bp_off 
286e					NEXTW 
286e c3 f3 1f			jp macro_next 
2871				endm 
# End of macro NEXTW
2871			 
2871			.bpset:	 
2871					;	ld (os_view_disable), a 
2871 cd dd 15				call bp_on 
2874			 
2874			 
2874					NEXTW 
2874 c3 f3 1f			jp macro_next 
2877				endm 
# End of macro NEXTW
2877			 
2877			 
2877			.MONITOR: 
2877				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2877 55				db WORD_SYS_CORE+65             
2878 a8 28			dw .MALLOC            
287a 08				db 7 + 1 
287b .. 00			db "MONITOR",0              
2883				endm 
# End of macro CWHEAD
2883			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2883			; | | At start the current various registers will be displayed with contents. 
2883			; | | Top right corner will show the most recent debug marker seen. 
2883			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2883			; | | and the return stack pointer (RSP). 
2883			; | | Pressing: 
2883			; | |    1 - Initial screen 
2883			; | |    2 - Display a data dump of HL 
2883			; | |    3 - Display a data dump of DE 
2883			; | |    4 - Display a data dump of BC 
2883			; | |    5 - Display a data dump of HL 
2883			; | |    6 - Display a data dump of DSP 
2883			; | |    7 - Display a data dump of RSP 
2883			; | |    8 - Display a data dump of what is at DSP 
2883			; | |    9 - Display a data dump of what is at RSP 
2883			; | |    0 - Exit monitor and continue running. This will also enable break points 
2883			; | |    * - Disable break points 
2883			; | |    # - Enter traditional monitor mode 
2883			; | | 
2883			; | | Monitor Mode 
2883			; | | ------------ 
2883			; | | A prompt of '>' will be shown for various commands: 
2883			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2883			; | |    C - Continue display a data dump from the last set address 
2883			; | |    M xxxx - Set start of memory edit at address xx 
2883			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2883			; | |    Q - Return to previous 
2883					if DEBUG_FORTH_WORDS_KEY 
2883						DMARK "MON" 
2883 f5				push af  
2884 3a 98 28			ld a, (.dmark)  
2887 32 6b ee			ld (debug_mark),a  
288a 3a 99 28			ld a, (.dmark+1)  
288d 32 6c ee			ld (debug_mark+1),a  
2890 3a 9a 28			ld a, (.dmark+2)  
2893 32 6d ee			ld (debug_mark+2),a  
2896 18 03			jr .pastdmark  
2898 ..			.dmark: db "MON"  
289b f1			.pastdmark: pop af  
289c			endm  
# End of macro DMARK
289c						CALLMONITOR 
289c cd 6f ee			call debug_vector  
289f				endm  
# End of macro CALLMONITOR
289f					endif 
289f			;		ld a, 0 
289f			;		ld (os_view_disable), a 
289f cd dd 15				call bp_on 
28a2			 
28a2					CALLMONITOR 
28a2 cd 6f ee			call debug_vector  
28a5				endm  
# End of macro CALLMONITOR
28a5			 
28a5			;	call monitor 
28a5			 
28a5					NEXTW 
28a5 c3 f3 1f			jp macro_next 
28a8				endm 
# End of macro NEXTW
28a8			 
28a8			 
28a8			.MALLOC: 
28a8				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28a8 56				db WORD_SYS_CORE+66             
28a9 d1 28			dw .MALLOC2            
28ab 06				db 5 + 1 
28ac .. 00			db "ALLOT",0              
28b2				endm 
# End of macro CWHEAD
28b2			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28b2					if DEBUG_FORTH_WORDS_KEY 
28b2						DMARK "ALL" 
28b2 f5				push af  
28b3 3a c7 28			ld a, (.dmark)  
28b6 32 6b ee			ld (debug_mark),a  
28b9 3a c8 28			ld a, (.dmark+1)  
28bc 32 6c ee			ld (debug_mark+1),a  
28bf 3a c9 28			ld a, (.dmark+2)  
28c2 32 6d ee			ld (debug_mark+2),a  
28c5 18 03			jr .pastdmark  
28c7 ..			.dmark: db "ALL"  
28ca f1			.pastdmark: pop af  
28cb			endm  
# End of macro DMARK
28cb						CALLMONITOR 
28cb cd 6f ee			call debug_vector  
28ce				endm  
# End of macro CALLMONITOR
28ce					endif 
28ce c3 f8 28				jp .mallocc 
28d1			.MALLOC2: 
28d1				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28d1 56				db WORD_SYS_CORE+66             
28d2 0f 29			dw .FREE            
28d4 07				db 6 + 1 
28d5 .. 00			db "MALLOC",0              
28dc				endm 
# End of macro CWHEAD
28dc			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28dc					; get byte count 
28dc					if DEBUG_FORTH_WORDS_KEY 
28dc						DMARK "MAL" 
28dc f5				push af  
28dd 3a f1 28			ld a, (.dmark)  
28e0 32 6b ee			ld (debug_mark),a  
28e3 3a f2 28			ld a, (.dmark+1)  
28e6 32 6c ee			ld (debug_mark+1),a  
28e9 3a f3 28			ld a, (.dmark+2)  
28ec 32 6d ee			ld (debug_mark+2),a  
28ef 18 03			jr .pastdmark  
28f1 ..			.dmark: db "MAL"  
28f4 f1			.pastdmark: pop af  
28f5			endm  
# End of macro DMARK
28f5						CALLMONITOR 
28f5 cd 6f ee			call debug_vector  
28f8				endm  
# End of macro CALLMONITOR
28f8					endif 
28f8			.mallocc: 
28f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f8 cd 3d 1e			call macro_dsp_valuehl 
28fb				endm 
# End of macro FORTH_DSP_VALUEHL
28fb			 
28fb			;		push hl 
28fb			 
28fb					; destroy value TOS 
28fb			 
28fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28fb cd f5 1e			call macro_forth_dsp_pop 
28fe				endm 
# End of macro FORTH_DSP_POP
28fe			 
28fe			;		pop hl 
28fe cd ae 12				call malloc 
2901				if DEBUG_FORTH_MALLOC_GUARD 
2901 f5					push af 
2902 cd 10 0e				call ishlzero 
2905			;		ld a, l 
2905			;		add h 
2905			;		cp 0 
2905 f1					pop af 
2906					 
2906 cc 32 4d				call z,malloc_error 
2909				endif 
2909			 
2909 cd 46 1c				call forth_push_numhl 
290c					NEXTW 
290c c3 f3 1f			jp macro_next 
290f				endm 
# End of macro NEXTW
290f			 
290f			.FREE: 
290f				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
290f 57				db WORD_SYS_CORE+67             
2910 40 29			dw .LIST            
2912 05				db 4 + 1 
2913 .. 00			db "FREE",0              
2918				endm 
# End of macro CWHEAD
2918			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2918					if DEBUG_FORTH_WORDS_KEY 
2918						DMARK "FRE" 
2918 f5				push af  
2919 3a 2d 29			ld a, (.dmark)  
291c 32 6b ee			ld (debug_mark),a  
291f 3a 2e 29			ld a, (.dmark+1)  
2922 32 6c ee			ld (debug_mark+1),a  
2925 3a 2f 29			ld a, (.dmark+2)  
2928 32 6d ee			ld (debug_mark+2),a  
292b 18 03			jr .pastdmark  
292d ..			.dmark: db "FRE"  
2930 f1			.pastdmark: pop af  
2931			endm  
# End of macro DMARK
2931						CALLMONITOR 
2931 cd 6f ee			call debug_vector  
2934				endm  
# End of macro CALLMONITOR
2934					endif 
2934					; get address 
2934			 
2934					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2934 cd 3d 1e			call macro_dsp_valuehl 
2937				endm 
# End of macro FORTH_DSP_VALUEHL
2937			 
2937			;		push hl 
2937			 
2937					; destroy value TOS 
2937			 
2937					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2937 cd f5 1e			call macro_forth_dsp_pop 
293a				endm 
# End of macro FORTH_DSP_POP
293a			 
293a			;		pop hl 
293a			if FORTH_ENABLE_MALLOCFREE 
293a cd 78 13				call free 
293d			endif 
293d					NEXTW 
293d c3 f3 1f			jp macro_next 
2940				endm 
# End of macro NEXTW
2940			.LIST: 
2940				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2940 5c				db WORD_SYS_CORE+72             
2941 2e 2b			dw .FORGET            
2943 05				db 4 + 1 
2944 .. 00			db "LIST",0              
2949				endm 
# End of macro CWHEAD
2949			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2949			; | | The quoted word must be in upper case. 
2949				if DEBUG_FORTH_WORDS_KEY 
2949					DMARK "LST" 
2949 f5				push af  
294a 3a 5e 29			ld a, (.dmark)  
294d 32 6b ee			ld (debug_mark),a  
2950 3a 5f 29			ld a, (.dmark+1)  
2953 32 6c ee			ld (debug_mark+1),a  
2956 3a 60 29			ld a, (.dmark+2)  
2959 32 6d ee			ld (debug_mark+2),a  
295c 18 03			jr .pastdmark  
295e ..			.dmark: db "LST"  
2961 f1			.pastdmark: pop af  
2962			endm  
# End of macro DMARK
2962					CALLMONITOR 
2962 cd 6f ee			call debug_vector  
2965				endm  
# End of macro CALLMONITOR
2965				endif 
2965			 
2965					FORTH_DSP_VALUEHL 
2965 cd 3d 1e			call macro_dsp_valuehl 
2968				endm 
# End of macro FORTH_DSP_VALUEHL
2968			 
2968 e5					push hl 
2969					FORTH_DSP_POP 
2969 cd f5 1e			call macro_forth_dsp_pop 
296c				endm 
# End of macro FORTH_DSP_POP
296c c1					pop bc 
296d			 
296d			; Start format of scratch string 
296d			 
296d 21 c1 e2				ld hl, scratch 
2970			 
2970 3e 3a				ld a, ':' 
2972 77					ld (hl),a 
2973 23					inc hl 
2974 3e 20				ld a, ' ' 
2976 77					ld (hl), a 
2977			 
2977					; Get ptr to the word we need to look up 
2977			 
2977			;		FORTH_DSP_VALUEHL 
2977					;v5 FORTH_DSP_VALUE 
2977				; TODO type check 
2977			;		inc hl    ; Skip type check  
2977			;		push hl 
2977			;		ex de, hl    ; put into DE 
2977			 
2977			 
2977 21 90 65				ld hl, baseram 
297a					;ld hl, baseusermem 
297a			 
297a e5			push hl   ; sacreifical push 
297b			 
297b			.ldouscanm: 
297b e1				pop hl 
297c			.ldouscan: 
297c				if DEBUG_FORTH_WORDS 
297c					DMARK "LSs" 
297c f5				push af  
297d 3a 91 29			ld a, (.dmark)  
2980 32 6b ee			ld (debug_mark),a  
2983 3a 92 29			ld a, (.dmark+1)  
2986 32 6c ee			ld (debug_mark+1),a  
2989 3a 93 29			ld a, (.dmark+2)  
298c 32 6d ee			ld (debug_mark+2),a  
298f 18 03			jr .pastdmark  
2991 ..			.dmark: db "LSs"  
2994 f1			.pastdmark: pop af  
2995			endm  
# End of macro DMARK
2995					CALLMONITOR 
2995 cd 6f ee			call debug_vector  
2998				endm  
# End of macro CALLMONITOR
2998				endif 
2998				; skip dict stub 
2998 cd 44 21				call forth_tok_next 
299b			 
299b			 
299b			; while we have words to look for 
299b			 
299b 7e				ld a, (hl)      
299c				if DEBUG_FORTH_WORDS 
299c					DMARK "LSk" 
299c f5				push af  
299d 3a b1 29			ld a, (.dmark)  
29a0 32 6b ee			ld (debug_mark),a  
29a3 3a b2 29			ld a, (.dmark+1)  
29a6 32 6c ee			ld (debug_mark+1),a  
29a9 3a b3 29			ld a, (.dmark+2)  
29ac 32 6d ee			ld (debug_mark+2),a  
29af 18 03			jr .pastdmark  
29b1 ..			.dmark: db "LSk"  
29b4 f1			.pastdmark: pop af  
29b5			endm  
# End of macro DMARK
29b5					CALLMONITOR 
29b5 cd 6f ee			call debug_vector  
29b8				endm  
# End of macro CALLMONITOR
29b8				endif 
29b8					;cp WORD_SYS_END 
29b8					;jp z, .lunotfound 
29b8			 
29b8					; if we hit non uwords then gone too far 
29b8 fe 01				cp WORD_SYS_UWORD 
29ba c2 ea 2a				jp nz, .lunotfound 
29bd			 
29bd				if DEBUG_FORTH_WORDS 
29bd					DMARK "LSu" 
29bd f5				push af  
29be 3a d2 29			ld a, (.dmark)  
29c1 32 6b ee			ld (debug_mark),a  
29c4 3a d3 29			ld a, (.dmark+1)  
29c7 32 6c ee			ld (debug_mark+1),a  
29ca 3a d4 29			ld a, (.dmark+2)  
29cd 32 6d ee			ld (debug_mark+2),a  
29d0 18 03			jr .pastdmark  
29d2 ..			.dmark: db "LSu"  
29d5 f1			.pastdmark: pop af  
29d6			endm  
# End of macro DMARK
29d6					CALLMONITOR 
29d6 cd 6f ee			call debug_vector  
29d9				endm  
# End of macro CALLMONITOR
29d9				endif 
29d9			 
29d9					; found a uword but is it the one we want... 
29d9			 
29d9 c5					push bc     ; uword to find is on bc 
29da d1					pop de 
29db			 
29db e5					push hl  ; to save the ptr 
29dc			 
29dc					; skip opcode 
29dc 23					inc hl  
29dd					; skip next ptr 
29dd 23					inc hl  
29de 23					inc hl 
29df					; skip len 
29df 23					inc hl 
29e0			 
29e0				if DEBUG_FORTH_WORDS 
29e0					DMARK "LSc" 
29e0 f5				push af  
29e1 3a f5 29			ld a, (.dmark)  
29e4 32 6b ee			ld (debug_mark),a  
29e7 3a f6 29			ld a, (.dmark+1)  
29ea 32 6c ee			ld (debug_mark+1),a  
29ed 3a f7 29			ld a, (.dmark+2)  
29f0 32 6d ee			ld (debug_mark+2),a  
29f3 18 03			jr .pastdmark  
29f5 ..			.dmark: db "LSc"  
29f8 f1			.pastdmark: pop af  
29f9			endm  
# End of macro DMARK
29f9					CALLMONITOR 
29f9 cd 6f ee			call debug_vector  
29fc				endm  
# End of macro CALLMONITOR
29fc				endif 
29fc cd 7d 12				call strcmp 
29ff c2 7b 29				jp nz, .ldouscanm 
2a02				 
2a02			 
2a02			 
2a02					; we have a uword so push its name to the stack 
2a02			 
2a02			;	   	push hl  ; save so we can move to next dict block 
2a02 e1			pop hl 
2a03			 
2a03				if DEBUG_FORTH_WORDS 
2a03					DMARK "LSm" 
2a03 f5				push af  
2a04 3a 18 2a			ld a, (.dmark)  
2a07 32 6b ee			ld (debug_mark),a  
2a0a 3a 19 2a			ld a, (.dmark+1)  
2a0d 32 6c ee			ld (debug_mark+1),a  
2a10 3a 1a 2a			ld a, (.dmark+2)  
2a13 32 6d ee			ld (debug_mark+2),a  
2a16 18 03			jr .pastdmark  
2a18 ..			.dmark: db "LSm"  
2a1b f1			.pastdmark: pop af  
2a1c			endm  
# End of macro DMARK
2a1c					CALLMONITOR 
2a1c cd 6f ee			call debug_vector  
2a1f				endm  
# End of macro CALLMONITOR
2a1f				endif 
2a1f			 
2a1f					; skip opcode 
2a1f 23					inc hl  
2a20					; skip next ptr 
2a20 23					inc hl  
2a21 23					inc hl 
2a22					; skip len 
2a22 7e					ld a, (hl)   ; save length to add 
2a23				if DEBUG_FORTH_WORDS 
2a23					DMARK "LS2" 
2a23 f5				push af  
2a24 3a 38 2a			ld a, (.dmark)  
2a27 32 6b ee			ld (debug_mark),a  
2a2a 3a 39 2a			ld a, (.dmark+1)  
2a2d 32 6c ee			ld (debug_mark+1),a  
2a30 3a 3a 2a			ld a, (.dmark+2)  
2a33 32 6d ee			ld (debug_mark+2),a  
2a36 18 03			jr .pastdmark  
2a38 ..			.dmark: db "LS2"  
2a3b f1			.pastdmark: pop af  
2a3c			endm  
# End of macro DMARK
2a3c					CALLMONITOR 
2a3c cd 6f ee			call debug_vector  
2a3f				endm  
# End of macro CALLMONITOR
2a3f				endif 
2a3f			 
2a3f					; save this location 
2a3f				 
2a3f e5					push hl 
2a40			 
2a40 23					inc hl 
2a41 11 c3 e2				ld de, scratch+2 
2a44 4f					ld c, a 
2a45 06 00				ld b, 0 
2a47			 
2a47				if DEBUG_FORTH_WORDS 
2a47					DMARK "LSn" 
2a47 f5				push af  
2a48 3a 5c 2a			ld a, (.dmark)  
2a4b 32 6b ee			ld (debug_mark),a  
2a4e 3a 5d 2a			ld a, (.dmark+1)  
2a51 32 6c ee			ld (debug_mark+1),a  
2a54 3a 5e 2a			ld a, (.dmark+2)  
2a57 32 6d ee			ld (debug_mark+2),a  
2a5a 18 03			jr .pastdmark  
2a5c ..			.dmark: db "LSn"  
2a5f f1			.pastdmark: pop af  
2a60			endm  
# End of macro DMARK
2a60					CALLMONITOR 
2a60 cd 6f ee			call debug_vector  
2a63				endm  
# End of macro CALLMONITOR
2a63				endif 
2a63			 
2a63					; copy uword name to scratch 
2a63			 
2a63 ed b0				ldir 
2a65			 
2a65 1b					dec de 
2a66 3e 20				ld a, ' '    ; change null to space 
2a68 12					ld (de), a 
2a69			 
2a69 13					inc de 
2a6a			 
2a6a d5					push de 
2a6b c1					pop bc     ; move scratch pointer to end of word name and save it 
2a6c			 
2a6c e1					pop hl 
2a6d 7e					ld a, (hl) 
2a6e					;inc hl 
2a6e					; skip word string 
2a6e cd e7 0d				call addatohl 
2a71			 
2a71 23					inc hl 
2a72			 
2a72				if DEBUG_FORTH_WORDS 
2a72					DMARK "LS3" 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 6b ee			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 6c ee			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 6d ee			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "LS3"  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b					CALLMONITOR 
2a8b cd 6f ee			call debug_vector  
2a8e				endm  
# End of macro CALLMONITOR
2a8e				endif 
2a8e					; should now be at the start of the machine code to setup the eval of the uword 
2a8e					; now locate the ptr to the string defintion 
2a8e			 
2a8e					; skip ld hl, 
2a8e					; then load the ptr 
2a8e			; TODO use get from hl ptr 
2a8e 23					inc hl 
2a8f 5e					ld e, (hl) 
2a90 23					inc hl 
2a91 56					ld d, (hl) 
2a92 eb					ex de, hl 
2a93			 
2a93			 
2a93				if DEBUG_FORTH_WORDS 
2a93					DMARK "LSt" 
2a93 f5				push af  
2a94 3a a8 2a			ld a, (.dmark)  
2a97 32 6b ee			ld (debug_mark),a  
2a9a 3a a9 2a			ld a, (.dmark+1)  
2a9d 32 6c ee			ld (debug_mark+1),a  
2aa0 3a aa 2a			ld a, (.dmark+2)  
2aa3 32 6d ee			ld (debug_mark+2),a  
2aa6 18 03			jr .pastdmark  
2aa8 ..			.dmark: db "LSt"  
2aab f1			.pastdmark: pop af  
2aac			endm  
# End of macro DMARK
2aac					CALLMONITOR 
2aac cd 6f ee			call debug_vector  
2aaf				endm  
# End of macro CALLMONITOR
2aaf				endif 
2aaf			 
2aaf			; cant push right now due to tokenised strings  
2aaf			 
2aaf			; get the destination of where to copy this definition to. 
2aaf			 
2aaf c5					push bc 
2ab0 d1					pop de 
2ab1			 
2ab1 7e			.listl:         ld a,(hl) 
2ab2 fe 00				cp 0 
2ab4 28 09				jr z, .lreplsp     ; replace zero with space 
2ab6					;cp FORTH_END_BUFFER 
2ab6 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ab8 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2aba				 
2aba					; just copy this char as is then 
2aba			 
2aba 12					ld (de), a 
2abb			 
2abb 23			.listnxt:	inc hl 
2abc 13					inc de 
2abd 18 f2				jr .listl 
2abf			 
2abf 3e 20		.lreplsp:	ld a,' ' 
2ac1 12					ld (de), a 
2ac2 18 f7				jr .listnxt 
2ac4			 
2ac4			; close up uword def 
2ac4			 
2ac4			.listdone: 
2ac4 12					ld (de), a 
2ac5 13					inc de 
2ac6 3e 00				ld a, 0 
2ac8 12					ld (de), a 
2ac9			 
2ac9			; now have def so clean up and push to stack 
2ac9			 
2ac9 21 c1 e2				ld hl, scratch 
2acc				if DEBUG_FORTH_WORDS 
2acc					DMARK "Ltp" 
2acc f5				push af  
2acd 3a e1 2a			ld a, (.dmark)  
2ad0 32 6b ee			ld (debug_mark),a  
2ad3 3a e2 2a			ld a, (.dmark+1)  
2ad6 32 6c ee			ld (debug_mark+1),a  
2ad9 3a e3 2a			ld a, (.dmark+2)  
2adc 32 6d ee			ld (debug_mark+2),a  
2adf 18 03			jr .pastdmark  
2ae1 ..			.dmark: db "Ltp"  
2ae4 f1			.pastdmark: pop af  
2ae5			endm  
# End of macro DMARK
2ae5					CALLMONITOR 
2ae5 cd 6f ee			call debug_vector  
2ae8				endm  
# End of macro CALLMONITOR
2ae8				endif 
2ae8			 
2ae8 18 1f			jr .listpush 
2aea			 
2aea			;.lnuword:	pop hl 
2aea			;		call forth_tok_next 
2aea			;		jp .ldouscan  
2aea			 
2aea			.lunotfound:		  
2aea			 
2aea				if DEBUG_FORTH_WORDS 
2aea					DMARK "LSn" 
2aea f5				push af  
2aeb 3a ff 2a			ld a, (.dmark)  
2aee 32 6b ee			ld (debug_mark),a  
2af1 3a 00 2b			ld a, (.dmark+1)  
2af4 32 6c ee			ld (debug_mark+1),a  
2af7 3a 01 2b			ld a, (.dmark+2)  
2afa 32 6d ee			ld (debug_mark+2),a  
2afd 18 03			jr .pastdmark  
2aff ..			.dmark: db "LSn"  
2b02 f1			.pastdmark: pop af  
2b03			endm  
# End of macro DMARK
2b03					CALLMONITOR 
2b03 cd 6f ee			call debug_vector  
2b06				endm  
# End of macro CALLMONITOR
2b06				endif 
2b06			 
2b06					 
2b06			;		FORTH_DSP_POP 
2b06			;		ld hl, .luno 
2b06			 
2b06					NEXTW			 
2b06 c3 f3 1f			jp macro_next 
2b09				endm 
# End of macro NEXTW
2b09			 
2b09			.listpush: 
2b09				if DEBUG_FORTH_WORDS 
2b09					DMARK "LS>" 
2b09 f5				push af  
2b0a 3a 1e 2b			ld a, (.dmark)  
2b0d 32 6b ee			ld (debug_mark),a  
2b10 3a 1f 2b			ld a, (.dmark+1)  
2b13 32 6c ee			ld (debug_mark+1),a  
2b16 3a 20 2b			ld a, (.dmark+2)  
2b19 32 6d ee			ld (debug_mark+2),a  
2b1c 18 03			jr .pastdmark  
2b1e ..			.dmark: db "LS>"  
2b21 f1			.pastdmark: pop af  
2b22			endm  
# End of macro DMARK
2b22					CALLMONITOR 
2b22 cd 6f ee			call debug_vector  
2b25				endm  
# End of macro CALLMONITOR
2b25				endif 
2b25 cd b4 1c				call forth_push_str 
2b28			 
2b28			 
2b28			 
2b28					NEXTW 
2b28 c3 f3 1f			jp macro_next 
2b2b				endm 
# End of macro NEXTW
2b2b			 
2b2b			;.luno:    db "Word not found",0 
2b2b			 
2b2b			 
2b2b			 
2b2b			 
2b2b			 
2b2b			;		push hl   ; save pointer to start of uword def string 
2b2b			; 
2b2b			;; look for FORTH_EOL_LINE 
2b2b			;		ld a, FORTH_END_BUFFER 
2b2b			;		call strlent 
2b2b			; 
2b2b			;		inc hl		 ; space for coln def 
2b2b			;		inc hl 
2b2b			;		inc hl          ; space for terms 
2b2b			;		inc hl 
2b2b			; 
2b2b			;		ld a, 20   ; TODO get actual length 
2b2b			;		call addatohl    ; include a random amount of room for the uword name 
2b2b			; 
2b2b			;		 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt1" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;		 
2b2b			; 
2b2b			;; malloc space for the string because we cant change it 
2b2b			; 
2b2b			;		call malloc 
2b2b			;	if DEBUG_FORTH_MALLOC_GUARD 
2b2b			;		push af 
2b2b			;		call ishlzero 
2b2b			;		pop af 
2b2b			;		 
2b2b			;		call z,malloc_error 
2b2b			;	endif 
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt2" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;		pop de 
2b2b			;		push hl    ; push the malloc to release later 
2b2b			;		push hl   ;  push back a copy for the later stack push 
2b2b			;		 
2b2b			;; copy the string swapping out the zero terms for spaces 
2b2b			; 
2b2b			;		; de has our source 
2b2b			;		; hl has our dest 
2b2b			; 
2b2b			;; add the coln def 
2b2b			; 
2b2b			;		ld a, ':' 
2b2b			;		ld (hl), a 
2b2b			;		inc hl 
2b2b			;		ld a, ' ' 
2b2b			;		ld (hl), a 
2b2b			;		inc hl 
2b2b			; 
2b2b			;; add the uname word 
2b2b			;		push de   ; save our string for now 
2b2b			;		ex de, hl 
2b2b			; 
2b2b			;		FORTH_DSP_VALUE 
2b2b			;		;v5 FORTH_DSP_VALUE 
2b2b			; 
2b2b			;		inc hl   ; skip type but we know by now this is OK 
2b2b			; 
2b2b			;.luword:	ld a,(hl) 
2b2b			;		cp 0 
2b2b			;		jr z, .luword2 
2b2b			;		ld (de), a 
2b2b			;		inc de 
2b2b			;		inc hl 
2b2b			;		jr .luword 
2b2b			; 
2b2b			;.luword2:	ld a, ' ' 
2b2b			;		ld (de), a 
2b2b			;;		inc hl 
2b2b			;;		inc de 
2b2b			;;		ld (de), a 
2b2b			;;		inc hl 
2b2b			;		inc de 
2b2b			; 
2b2b			;		ex de, hl 
2b2b			;		pop de 
2b2b			;		 
2b2b			;		 
2b2b			; 
2b2b			;; detoken that string and copy it 
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt2" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;.ldetok:	ld a, (de) 
2b2b			;		cp FORTH_END_BUFFER 
2b2b			;		jr z, .ldetokend 
2b2b			;		; swap out any zero term for space 
2b2b			;		cp 0 
2b2b			;		jr nz, .ldetoknext 
2b2b			;		ld a, ' ' 
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "LtS" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;.ldetoknext:	ld (hl), a 
2b2b			;		inc de 
2b2b			;		inc hl 
2b2b			;		jr .ldetok 
2b2b			; 
2b2b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b2b			;		ld (hl), a  
2b2b			; 
2b2b			;; free that temp malloc 
2b2b			; 
2b2b			;		pop hl    
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt4" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;		call forth_apushstrhl 
2b2b			; 
2b2b			;		; get rid of temp malloc area 
2b2b			; 
2b2b			;		pop hl 
2b2b			;		call free 
2b2b			; 
2b2b			;		jr .ludone 
2b2b			; 
2b2b			;.lnuword:	pop hl 
2b2b			;		call forth_tok_next 
2b2b			;		jp .ldouscan  
2b2b			; 
2b2b			;.ludone:		 pop hl 
2b2b			; 
2b2b					NEXTW 
2b2b c3 f3 1f			jp macro_next 
2b2e				endm 
# End of macro NEXTW
2b2e			 
2b2e			.FORGET: 
2b2e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b2e 5d				db WORD_SYS_CORE+73             
2b2f a7 2b			dw .NOP            
2b31 07				db 6 + 1 
2b32 .. 00			db "FORGET",0              
2b39				endm 
# End of macro CWHEAD
2b39			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b39			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b39			; | |  
2b39			; | | e.g. "MORE" forget 
2b39					if DEBUG_FORTH_WORDS_KEY 
2b39						DMARK "FRG" 
2b39 f5				push af  
2b3a 3a 4e 2b			ld a, (.dmark)  
2b3d 32 6b ee			ld (debug_mark),a  
2b40 3a 4f 2b			ld a, (.dmark+1)  
2b43 32 6c ee			ld (debug_mark+1),a  
2b46 3a 50 2b			ld a, (.dmark+2)  
2b49 32 6d ee			ld (debug_mark+2),a  
2b4c 18 03			jr .pastdmark  
2b4e ..			.dmark: db "FRG"  
2b51 f1			.pastdmark: pop af  
2b52			endm  
# End of macro DMARK
2b52						CALLMONITOR 
2b52 cd 6f ee			call debug_vector  
2b55				endm  
# End of macro CALLMONITOR
2b55					endif 
2b55			 
2b55				; find uword 
2b55			        ; update start of word with "_" 
2b55				; replace uword with deleted flag 
2b55			 
2b55			 
2b55			;	if DEBUG_FORTH_WORDS 
2b55			;		DMARK "FOG" 
2b55			;		CALLMONITOR 
2b55			;	endif 
2b55			 
2b55			 
2b55					; Get ptr to the word we need to look up 
2b55			 
2b55					FORTH_DSP_VALUEHL 
2b55 cd 3d 1e			call macro_dsp_valuehl 
2b58				endm 
# End of macro FORTH_DSP_VALUEHL
2b58					;v5 FORTH_DSP_VALUE 
2b58				; TODO type check 
2b58			;		inc hl    ; Skip type check  
2b58 e5					push hl 
2b59 c1					pop bc 
2b5a			;		ex de, hl    ; put into DE 
2b5a			 
2b5a			 
2b5a 21 90 65				ld hl, baseram 
2b5d					;ld hl, baseusermem 
2b5d			 
2b5d				; skip dict stub 
2b5d			;	call forth_tok_next 
2b5d e5			push hl   ; sacreifical push 
2b5e			 
2b5e			.fldouscanm: 
2b5e e1				pop hl 
2b5f			.fldouscan: 
2b5f			;	if DEBUG_FORTH_WORDS 
2b5f			;		DMARK "LSs" 
2b5f			;		CALLMONITOR 
2b5f			;	endif 
2b5f				; skip dict stub 
2b5f cd 44 21				call forth_tok_next 
2b62			 
2b62			 
2b62			; while we have words to look for 
2b62			 
2b62 7e				ld a, (hl)      
2b63			;	if DEBUG_FORTH_WORDS 
2b63			;		DMARK "LSk" 
2b63			;		CALLMONITOR 
2b63			;	endif 
2b63 fe 00				cp WORD_SYS_END 
2b65 ca a1 2b				jp z, .flunotfound 
2b68 fe 01				cp WORD_SYS_UWORD 
2b6a c2 5f 2b				jp nz, .fldouscan 
2b6d			 
2b6d			;	if DEBUG_FORTH_WORDS 
2b6d			;		DMARK "LSu" 
2b6d			;		CALLMONITOR 
2b6d			;	endif 
2b6d			 
2b6d					; found a uword but is it the one we want... 
2b6d			 
2b6d c5					push bc     ; uword to find is on bc 
2b6e d1					pop de 
2b6f			 
2b6f e5					push hl  ; to save the ptr 
2b70			 
2b70					; skip opcode 
2b70 23					inc hl  
2b71					; skip next ptr 
2b71 23					inc hl  
2b72 23					inc hl 
2b73					; skip len 
2b73 23					inc hl 
2b74			 
2b74			;	if DEBUG_FORTH_WORDS 
2b74			;		DMARK "LSc" 
2b74			;		CALLMONITOR 
2b74			;	endif 
2b74 cd 7d 12				call strcmp 
2b77 c2 5e 2b				jp nz, .fldouscanm 
2b7a			; 
2b7a			; 
2b7a			;; while we have words to look for 
2b7a			; 
2b7a			;.fdouscan:	ld a, (hl)      
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "LSs" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		cp WORD_SYS_END 
2b7a			;		jp z, .fudone 
2b7a			;		cp WORD_SYS_UWORD 
2b7a			;		jp nz, .fnuword 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "FGu" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			; 
2b7a			;		; found a uword but is it the one we want... 
2b7a			; 
2b7a			; 
2b7a			;	        pop de   ; get back the dsp name 
2b7a			;		push de 
2b7a			; 
2b7a			;		push hl  ; to save the ptr 
2b7a			; 
2b7a			;		; skip opcode 
2b7a			;		inc hl  
2b7a			;		; skip next ptr 
2b7a			;		inc hl  
2b7a			;		inc hl 
2b7a			;		; skip len 
2b7a			;		inc hl 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "FGc" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		call strcmp 
2b7a			;		jp nz, .fnuword 
2b7a			 
2b7a			 
2b7a e1			pop hl 
2b7b			 
2b7b				 
2b7b				if DEBUG_FORTH_WORDS 
2b7b					DMARK "FGm" 
2b7b f5				push af  
2b7c 3a 90 2b			ld a, (.dmark)  
2b7f 32 6b ee			ld (debug_mark),a  
2b82 3a 91 2b			ld a, (.dmark+1)  
2b85 32 6c ee			ld (debug_mark+1),a  
2b88 3a 92 2b			ld a, (.dmark+2)  
2b8b 32 6d ee			ld (debug_mark+2),a  
2b8e 18 03			jr .pastdmark  
2b90 ..			.dmark: db "FGm"  
2b93 f1			.pastdmark: pop af  
2b94			endm  
# End of macro DMARK
2b94					CALLMONITOR 
2b94 cd 6f ee			call debug_vector  
2b97				endm  
# End of macro CALLMONITOR
2b97				endif 
2b97			 
2b97			 
2b97			 
2b97					; we have a uword so push its name to the stack 
2b97			 
2b97			;	   	push hl  ; save so we can move to next dict block 
2b97			;pop hl 
2b97			 
2b97					; update opcode to deleted 
2b97 3e 03				ld a, WORD_SYS_DELETED 
2b99 77					ld (hl), a 
2b9a			 
2b9a 23					inc hl  
2b9b					; skip next ptr 
2b9b 23					inc hl  
2b9c 23					inc hl 
2b9d					; skip len 
2b9d 23					inc hl 
2b9e			 
2b9e					; TODO change parser to skip deleted words but for now mark it out 
2b9e 3e 5f				ld a, "_" 
2ba0 77					ld  (hl),a 
2ba1			 
2ba1			;		jr .fudone 
2ba1			; 
2ba1			;.fnuword:	pop hl 
2ba1			;		call forth_tok_next 
2ba1			;		jp .fdouscan  
2ba1			 
2ba1			.flunotfound:		  
2ba1			 
2ba1			 
2ba1					 
2ba1					FORTH_DSP_POP 
2ba1 cd f5 1e			call macro_forth_dsp_pop 
2ba4				endm 
# End of macro FORTH_DSP_POP
2ba4			;		ld hl, .luno 
2ba4			;.fudone:		 pop hl 
2ba4					NEXTW 
2ba4 c3 f3 1f			jp macro_next 
2ba7				endm 
# End of macro NEXTW
2ba7			.NOP: 
2ba7				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ba7 61				db WORD_SYS_CORE+77             
2ba8 ce 2b			dw .COMO            
2baa 04				db 3 + 1 
2bab .. 00			db "NOP",0              
2baf				endm 
# End of macro CWHEAD
2baf			; | NOP (  --  ) Do nothing | DONE 
2baf					if DEBUG_FORTH_WORDS_KEY 
2baf						DMARK "NOP" 
2baf f5				push af  
2bb0 3a c4 2b			ld a, (.dmark)  
2bb3 32 6b ee			ld (debug_mark),a  
2bb6 3a c5 2b			ld a, (.dmark+1)  
2bb9 32 6c ee			ld (debug_mark+1),a  
2bbc 3a c6 2b			ld a, (.dmark+2)  
2bbf 32 6d ee			ld (debug_mark+2),a  
2bc2 18 03			jr .pastdmark  
2bc4 ..			.dmark: db "NOP"  
2bc7 f1			.pastdmark: pop af  
2bc8			endm  
# End of macro DMARK
2bc8						CALLMONITOR 
2bc8 cd 6f ee			call debug_vector  
2bcb				endm  
# End of macro CALLMONITOR
2bcb					endif 
2bcb				       NEXTW 
2bcb c3 f3 1f			jp macro_next 
2bce				endm 
# End of macro NEXTW
2bce			.COMO: 
2bce				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bce 6e				db WORD_SYS_CORE+90             
2bcf 20 2c			dw .COMC            
2bd1 02				db 1 + 1 
2bd2 .. 00			db "(",0              
2bd4				endm 
# End of macro CWHEAD
2bd4			; | ( ( -- )  Start of comment | DONE 
2bd4			 
2bd4			 
2bd4 2a c2 e5				ld hl, ( os_tok_ptr) 
2bd7 11 1b 2c			ld de, .closepar 
2bda					 
2bda					if DEBUG_FORTH_WORDS 
2bda						DMARK ").." 
2bda f5				push af  
2bdb 3a ef 2b			ld a, (.dmark)  
2bde 32 6b ee			ld (debug_mark),a  
2be1 3a f0 2b			ld a, (.dmark+1)  
2be4 32 6c ee			ld (debug_mark+1),a  
2be7 3a f1 2b			ld a, (.dmark+2)  
2bea 32 6d ee			ld (debug_mark+2),a  
2bed 18 03			jr .pastdmark  
2bef ..			.dmark: db ").."  
2bf2 f1			.pastdmark: pop af  
2bf3			endm  
# End of macro DMARK
2bf3						CALLMONITOR 
2bf3 cd 6f ee			call debug_vector  
2bf6				endm  
# End of macro CALLMONITOR
2bf6					endif 
2bf6 cd 0e 21			call findnexttok  
2bf9			 
2bf9					if DEBUG_FORTH_WORDS 
2bf9						DMARK "IF5" 
2bf9 f5				push af  
2bfa 3a 0e 2c			ld a, (.dmark)  
2bfd 32 6b ee			ld (debug_mark),a  
2c00 3a 0f 2c			ld a, (.dmark+1)  
2c03 32 6c ee			ld (debug_mark+1),a  
2c06 3a 10 2c			ld a, (.dmark+2)  
2c09 32 6d ee			ld (debug_mark+2),a  
2c0c 18 03			jr .pastdmark  
2c0e ..			.dmark: db "IF5"  
2c11 f1			.pastdmark: pop af  
2c12			endm  
# End of macro DMARK
2c12						CALLMONITOR 
2c12 cd 6f ee			call debug_vector  
2c15				endm  
# End of macro CALLMONITOR
2c15					endif 
2c15				; replace below with ) exec using tok_ptr 
2c15 22 c2 e5			ld (os_tok_ptr), hl 
2c18 c3 84 20			jp exec1 
2c1b			 
2c1b .. 00			.closepar:   db ")",0 
2c1d			 
2c1d				       NEXTW 
2c1d c3 f3 1f			jp macro_next 
2c20				endm 
# End of macro NEXTW
2c20			.COMC: 
2c20				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c20 6f				db WORD_SYS_CORE+91             
2c21 29 2c			dw .SCRATCH            
2c23 02				db 1 + 1 
2c24 .. 00			db ")",0              
2c26				endm 
# End of macro CWHEAD
2c26			; | ) ( -- )  End of comment |  DONE  
2c26				       NEXTW 
2c26 c3 f3 1f			jp macro_next 
2c29				endm 
# End of macro NEXTW
2c29			 
2c29			.SCRATCH: 
2c29				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c29 6f				db WORD_SYS_CORE+91             
2c2a 64 2c			dw .INC            
2c2c 08				db 7 + 1 
2c2d .. 00			db "SCRATCH",0              
2c35				endm 
# End of macro CWHEAD
2c35			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c35			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c35			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c35			; | |  
2c35			; | | e.g.    : score $00 scratch ; 
2c35			; | |  
2c35			; | | $00 score ! 
2c35			; | | $01 score +! 
2c35			; | |  
2c35			; | | e.g.   : varword $0a scratch ;  
2c35			; | | 
2c35			; | | $8000 varword ! 
2c35					if DEBUG_FORTH_WORDS_KEY 
2c35						DMARK "SCR" 
2c35 f5				push af  
2c36 3a 4a 2c			ld a, (.dmark)  
2c39 32 6b ee			ld (debug_mark),a  
2c3c 3a 4b 2c			ld a, (.dmark+1)  
2c3f 32 6c ee			ld (debug_mark+1),a  
2c42 3a 4c 2c			ld a, (.dmark+2)  
2c45 32 6d ee			ld (debug_mark+2),a  
2c48 18 03			jr .pastdmark  
2c4a ..			.dmark: db "SCR"  
2c4d f1			.pastdmark: pop af  
2c4e			endm  
# End of macro DMARK
2c4e						CALLMONITOR 
2c4e cd 6f ee			call debug_vector  
2c51				endm  
# End of macro CALLMONITOR
2c51					endif 
2c51			 
2c51					FORTH_DSP_VALUEHL 
2c51 cd 3d 1e			call macro_dsp_valuehl 
2c54				endm 
# End of macro FORTH_DSP_VALUEHL
2c54				 
2c54					FORTH_DSP_POP 
2c54 cd f5 1e			call macro_forth_dsp_pop 
2c57				endm 
# End of macro FORTH_DSP_POP
2c57			 
2c57 7d					ld a, l 
2c58 21 e6 e7				ld hl, os_var_array 
2c5b cd e7 0d				call addatohl 
2c5e			 
2c5e cd 46 1c				call forth_push_numhl 
2c61			 
2c61				       NEXTW 
2c61 c3 f3 1f			jp macro_next 
2c64				endm 
# End of macro NEXTW
2c64			 
2c64			.INC: 
2c64				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c64 6f				db WORD_SYS_CORE+91             
2c65 b8 2c			dw .DEC            
2c67 03				db 2 + 1 
2c68 .. 00			db "+!",0              
2c6b				endm 
# End of macro CWHEAD
2c6b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c6b					if DEBUG_FORTH_WORDS_KEY 
2c6b						DMARK "+s_" 
2c6b f5				push af  
2c6c 3a 80 2c			ld a, (.dmark)  
2c6f 32 6b ee			ld (debug_mark),a  
2c72 3a 81 2c			ld a, (.dmark+1)  
2c75 32 6c ee			ld (debug_mark+1),a  
2c78 3a 82 2c			ld a, (.dmark+2)  
2c7b 32 6d ee			ld (debug_mark+2),a  
2c7e 18 03			jr .pastdmark  
2c80 ..			.dmark: db "+s_"  
2c83 f1			.pastdmark: pop af  
2c84			endm  
# End of macro DMARK
2c84						CALLMONITOR 
2c84 cd 6f ee			call debug_vector  
2c87				endm  
# End of macro CALLMONITOR
2c87					endif 
2c87			 
2c87					FORTH_DSP_VALUEHL 
2c87 cd 3d 1e			call macro_dsp_valuehl 
2c8a				endm 
# End of macro FORTH_DSP_VALUEHL
2c8a			 
2c8a e5					push hl   ; save address 
2c8b			 
2c8b					FORTH_DSP_POP 
2c8b cd f5 1e			call macro_forth_dsp_pop 
2c8e				endm 
# End of macro FORTH_DSP_POP
2c8e			 
2c8e					FORTH_DSP_VALUEHL 
2c8e cd 3d 1e			call macro_dsp_valuehl 
2c91				endm 
# End of macro FORTH_DSP_VALUEHL
2c91			 
2c91					FORTH_DSP_POP 
2c91 cd f5 1e			call macro_forth_dsp_pop 
2c94				endm 
# End of macro FORTH_DSP_POP
2c94			 
2c94					; hl contains value to add to byte at a 
2c94				 
2c94 eb					ex de, hl 
2c95			 
2c95 e1					pop hl 
2c96			 
2c96					if DEBUG_FORTH_WORDS 
2c96						DMARK "INC" 
2c96 f5				push af  
2c97 3a ab 2c			ld a, (.dmark)  
2c9a 32 6b ee			ld (debug_mark),a  
2c9d 3a ac 2c			ld a, (.dmark+1)  
2ca0 32 6c ee			ld (debug_mark+1),a  
2ca3 3a ad 2c			ld a, (.dmark+2)  
2ca6 32 6d ee			ld (debug_mark+2),a  
2ca9 18 03			jr .pastdmark  
2cab ..			.dmark: db "INC"  
2cae f1			.pastdmark: pop af  
2caf			endm  
# End of macro DMARK
2caf						CALLMONITOR 
2caf cd 6f ee			call debug_vector  
2cb2				endm  
# End of macro CALLMONITOR
2cb2					endif 
2cb2			 
2cb2 7e					ld a,(hl) 
2cb3 83					add e 
2cb4 77					ld (hl),a 
2cb5			 
2cb5			 
2cb5			 
2cb5				       NEXTW 
2cb5 c3 f3 1f			jp macro_next 
2cb8				endm 
# End of macro NEXTW
2cb8			 
2cb8			.DEC: 
2cb8				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cb8 6f				db WORD_SYS_CORE+91             
2cb9 09 2d			dw .INC2            
2cbb 03				db 2 + 1 
2cbc .. 00			db "-!",0              
2cbf				endm 
# End of macro CWHEAD
2cbf			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cbf					if DEBUG_FORTH_WORDS_KEY 
2cbf						DMARK "-s_" 
2cbf f5				push af  
2cc0 3a d4 2c			ld a, (.dmark)  
2cc3 32 6b ee			ld (debug_mark),a  
2cc6 3a d5 2c			ld a, (.dmark+1)  
2cc9 32 6c ee			ld (debug_mark+1),a  
2ccc 3a d6 2c			ld a, (.dmark+2)  
2ccf 32 6d ee			ld (debug_mark+2),a  
2cd2 18 03			jr .pastdmark  
2cd4 ..			.dmark: db "-s_"  
2cd7 f1			.pastdmark: pop af  
2cd8			endm  
# End of macro DMARK
2cd8						CALLMONITOR 
2cd8 cd 6f ee			call debug_vector  
2cdb				endm  
# End of macro CALLMONITOR
2cdb					endif 
2cdb			 
2cdb					FORTH_DSP_VALUEHL 
2cdb cd 3d 1e			call macro_dsp_valuehl 
2cde				endm 
# End of macro FORTH_DSP_VALUEHL
2cde			 
2cde e5					push hl   ; save address 
2cdf			 
2cdf					FORTH_DSP_POP 
2cdf cd f5 1e			call macro_forth_dsp_pop 
2ce2				endm 
# End of macro FORTH_DSP_POP
2ce2			 
2ce2					FORTH_DSP_VALUEHL 
2ce2 cd 3d 1e			call macro_dsp_valuehl 
2ce5				endm 
# End of macro FORTH_DSP_VALUEHL
2ce5			 
2ce5					; hl contains value to add to byte at a 
2ce5				 
2ce5 eb					ex de, hl 
2ce6			 
2ce6 e1					pop hl 
2ce7			 
2ce7					if DEBUG_FORTH_WORDS 
2ce7						DMARK "DEC" 
2ce7 f5				push af  
2ce8 3a fc 2c			ld a, (.dmark)  
2ceb 32 6b ee			ld (debug_mark),a  
2cee 3a fd 2c			ld a, (.dmark+1)  
2cf1 32 6c ee			ld (debug_mark+1),a  
2cf4 3a fe 2c			ld a, (.dmark+2)  
2cf7 32 6d ee			ld (debug_mark+2),a  
2cfa 18 03			jr .pastdmark  
2cfc ..			.dmark: db "DEC"  
2cff f1			.pastdmark: pop af  
2d00			endm  
# End of macro DMARK
2d00						CALLMONITOR 
2d00 cd 6f ee			call debug_vector  
2d03				endm  
# End of macro CALLMONITOR
2d03					endif 
2d03			 
2d03 7e					ld a,(hl) 
2d04 93					sub e 
2d05 77					ld (hl),a 
2d06			 
2d06			 
2d06			 
2d06				       NEXTW 
2d06 c3 f3 1f			jp macro_next 
2d09				endm 
# End of macro NEXTW
2d09			 
2d09			.INC2: 
2d09				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d09 6f				db WORD_SYS_CORE+91             
2d0a b3 2d			dw .DEC2            
2d0c 04				db 3 + 1 
2d0d .. 00			db "+2!",0              
2d11				endm 
# End of macro CWHEAD
2d11			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d11			 
2d11					if DEBUG_FORTH_WORDS_KEY 
2d11						DMARK "+2s" 
2d11 f5				push af  
2d12 3a 26 2d			ld a, (.dmark)  
2d15 32 6b ee			ld (debug_mark),a  
2d18 3a 27 2d			ld a, (.dmark+1)  
2d1b 32 6c ee			ld (debug_mark+1),a  
2d1e 3a 28 2d			ld a, (.dmark+2)  
2d21 32 6d ee			ld (debug_mark+2),a  
2d24 18 03			jr .pastdmark  
2d26 ..			.dmark: db "+2s"  
2d29 f1			.pastdmark: pop af  
2d2a			endm  
# End of macro DMARK
2d2a						CALLMONITOR 
2d2a cd 6f ee			call debug_vector  
2d2d				endm  
# End of macro CALLMONITOR
2d2d					endif 
2d2d			 
2d2d					; Address 
2d2d			 
2d2d					FORTH_DSP_VALUEHL 
2d2d cd 3d 1e			call macro_dsp_valuehl 
2d30				endm 
# End of macro FORTH_DSP_VALUEHL
2d30			 
2d30 e5					push hl    ; save address 
2d31			 
2d31					; load content into de 
2d31			 
2d31 5e					ld e,(hl) 
2d32 23					inc hl 
2d33 56					ld d, (hl) 
2d34			 
2d34					if DEBUG_FORTH_WORDS 
2d34						DMARK "+2a" 
2d34 f5				push af  
2d35 3a 49 2d			ld a, (.dmark)  
2d38 32 6b ee			ld (debug_mark),a  
2d3b 3a 4a 2d			ld a, (.dmark+1)  
2d3e 32 6c ee			ld (debug_mark+1),a  
2d41 3a 4b 2d			ld a, (.dmark+2)  
2d44 32 6d ee			ld (debug_mark+2),a  
2d47 18 03			jr .pastdmark  
2d49 ..			.dmark: db "+2a"  
2d4c f1			.pastdmark: pop af  
2d4d			endm  
# End of macro DMARK
2d4d						CALLMONITOR 
2d4d cd 6f ee			call debug_vector  
2d50				endm  
# End of macro CALLMONITOR
2d50					endif 
2d50			 
2d50					FORTH_DSP_POP 
2d50 cd f5 1e			call macro_forth_dsp_pop 
2d53				endm 
# End of macro FORTH_DSP_POP
2d53			 
2d53					; Get value to add 
2d53			 
2d53					FORTH_DSP_VALUE 
2d53 cd 26 1e			call macro_forth_dsp_value 
2d56				endm 
# End of macro FORTH_DSP_VALUE
2d56			 
2d56					if DEBUG_FORTH_WORDS 
2d56						DMARK "+2v" 
2d56 f5				push af  
2d57 3a 6b 2d			ld a, (.dmark)  
2d5a 32 6b ee			ld (debug_mark),a  
2d5d 3a 6c 2d			ld a, (.dmark+1)  
2d60 32 6c ee			ld (debug_mark+1),a  
2d63 3a 6d 2d			ld a, (.dmark+2)  
2d66 32 6d ee			ld (debug_mark+2),a  
2d69 18 03			jr .pastdmark  
2d6b ..			.dmark: db "+2v"  
2d6e f1			.pastdmark: pop af  
2d6f			endm  
# End of macro DMARK
2d6f						CALLMONITOR 
2d6f cd 6f ee			call debug_vector  
2d72				endm  
# End of macro CALLMONITOR
2d72					endif 
2d72			 
2d72 19					add hl, de 
2d73			 
2d73					if DEBUG_FORTH_WORDS 
2d73						DMARK "+2+" 
2d73 f5				push af  
2d74 3a 88 2d			ld a, (.dmark)  
2d77 32 6b ee			ld (debug_mark),a  
2d7a 3a 89 2d			ld a, (.dmark+1)  
2d7d 32 6c ee			ld (debug_mark+1),a  
2d80 3a 8a 2d			ld a, (.dmark+2)  
2d83 32 6d ee			ld (debug_mark+2),a  
2d86 18 03			jr .pastdmark  
2d88 ..			.dmark: db "+2+"  
2d8b f1			.pastdmark: pop af  
2d8c			endm  
# End of macro DMARK
2d8c						CALLMONITOR 
2d8c cd 6f ee			call debug_vector  
2d8f				endm  
# End of macro CALLMONITOR
2d8f					endif 
2d8f			 
2d8f					; move result to de 
2d8f			 
2d8f eb					ex de, hl 
2d90			 
2d90					; Address 
2d90			 
2d90 e1					pop hl 
2d91			 
2d91					; save it back 
2d91			 
2d91 73					ld (hl), e 
2d92 23					inc hl 
2d93 72					ld (hl), d 
2d94			 
2d94					if DEBUG_FORTH_WORDS 
2d94						DMARK "+2e" 
2d94 f5				push af  
2d95 3a a9 2d			ld a, (.dmark)  
2d98 32 6b ee			ld (debug_mark),a  
2d9b 3a aa 2d			ld a, (.dmark+1)  
2d9e 32 6c ee			ld (debug_mark+1),a  
2da1 3a ab 2d			ld a, (.dmark+2)  
2da4 32 6d ee			ld (debug_mark+2),a  
2da7 18 03			jr .pastdmark  
2da9 ..			.dmark: db "+2e"  
2dac f1			.pastdmark: pop af  
2dad			endm  
# End of macro DMARK
2dad						CALLMONITOR 
2dad cd 6f ee			call debug_vector  
2db0				endm  
# End of macro CALLMONITOR
2db0					endif 
2db0			 
2db0			 
2db0			 
2db0			 
2db0			 
2db0				       NEXTW 
2db0 c3 f3 1f			jp macro_next 
2db3				endm 
# End of macro NEXTW
2db3			 
2db3			.DEC2: 
2db3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2db3 6f				db WORD_SYS_CORE+91             
2db4 5f 2e			dw .GET2            
2db6 04				db 3 + 1 
2db7 .. 00			db "-2!",0              
2dbb				endm 
# End of macro CWHEAD
2dbb			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dbb			 
2dbb			 
2dbb					if DEBUG_FORTH_WORDS_KEY 
2dbb						DMARK "-2s" 
2dbb f5				push af  
2dbc 3a d0 2d			ld a, (.dmark)  
2dbf 32 6b ee			ld (debug_mark),a  
2dc2 3a d1 2d			ld a, (.dmark+1)  
2dc5 32 6c ee			ld (debug_mark+1),a  
2dc8 3a d2 2d			ld a, (.dmark+2)  
2dcb 32 6d ee			ld (debug_mark+2),a  
2dce 18 03			jr .pastdmark  
2dd0 ..			.dmark: db "-2s"  
2dd3 f1			.pastdmark: pop af  
2dd4			endm  
# End of macro DMARK
2dd4						CALLMONITOR 
2dd4 cd 6f ee			call debug_vector  
2dd7				endm  
# End of macro CALLMONITOR
2dd7					endif 
2dd7			 
2dd7					; Address 
2dd7			 
2dd7					FORTH_DSP_VALUEHL 
2dd7 cd 3d 1e			call macro_dsp_valuehl 
2dda				endm 
# End of macro FORTH_DSP_VALUEHL
2dda			 
2dda e5					push hl    ; save address 
2ddb			 
2ddb					; load content into de 
2ddb			 
2ddb 5e					ld e,(hl) 
2ddc 23					inc hl 
2ddd 56					ld d, (hl) 
2dde			 
2dde					if DEBUG_FORTH_WORDS 
2dde						DMARK "-2a" 
2dde f5				push af  
2ddf 3a f3 2d			ld a, (.dmark)  
2de2 32 6b ee			ld (debug_mark),a  
2de5 3a f4 2d			ld a, (.dmark+1)  
2de8 32 6c ee			ld (debug_mark+1),a  
2deb 3a f5 2d			ld a, (.dmark+2)  
2dee 32 6d ee			ld (debug_mark+2),a  
2df1 18 03			jr .pastdmark  
2df3 ..			.dmark: db "-2a"  
2df6 f1			.pastdmark: pop af  
2df7			endm  
# End of macro DMARK
2df7						CALLMONITOR 
2df7 cd 6f ee			call debug_vector  
2dfa				endm  
# End of macro CALLMONITOR
2dfa					endif 
2dfa			 
2dfa					FORTH_DSP_POP 
2dfa cd f5 1e			call macro_forth_dsp_pop 
2dfd				endm 
# End of macro FORTH_DSP_POP
2dfd			 
2dfd					; Get value to remove 
2dfd			 
2dfd					FORTH_DSP_VALUE 
2dfd cd 26 1e			call macro_forth_dsp_value 
2e00				endm 
# End of macro FORTH_DSP_VALUE
2e00			 
2e00					if DEBUG_FORTH_WORDS 
2e00						DMARK "-2v" 
2e00 f5				push af  
2e01 3a 15 2e			ld a, (.dmark)  
2e04 32 6b ee			ld (debug_mark),a  
2e07 3a 16 2e			ld a, (.dmark+1)  
2e0a 32 6c ee			ld (debug_mark+1),a  
2e0d 3a 17 2e			ld a, (.dmark+2)  
2e10 32 6d ee			ld (debug_mark+2),a  
2e13 18 03			jr .pastdmark  
2e15 ..			.dmark: db "-2v"  
2e18 f1			.pastdmark: pop af  
2e19			endm  
# End of macro DMARK
2e19						CALLMONITOR 
2e19 cd 6f ee			call debug_vector  
2e1c				endm  
# End of macro CALLMONITOR
2e1c					endif 
2e1c			 
2e1c eb					ex de, hl 
2e1d ed 52				sbc hl, de 
2e1f			 
2e1f					if DEBUG_FORTH_WORDS 
2e1f						DMARK "-2d" 
2e1f f5				push af  
2e20 3a 34 2e			ld a, (.dmark)  
2e23 32 6b ee			ld (debug_mark),a  
2e26 3a 35 2e			ld a, (.dmark+1)  
2e29 32 6c ee			ld (debug_mark+1),a  
2e2c 3a 36 2e			ld a, (.dmark+2)  
2e2f 32 6d ee			ld (debug_mark+2),a  
2e32 18 03			jr .pastdmark  
2e34 ..			.dmark: db "-2d"  
2e37 f1			.pastdmark: pop af  
2e38			endm  
# End of macro DMARK
2e38						CALLMONITOR 
2e38 cd 6f ee			call debug_vector  
2e3b				endm  
# End of macro CALLMONITOR
2e3b					endif 
2e3b			 
2e3b					; move result to de 
2e3b			 
2e3b eb					ex de, hl 
2e3c			 
2e3c					; Address 
2e3c			 
2e3c e1					pop hl 
2e3d			 
2e3d					; save it back 
2e3d			 
2e3d 73					ld (hl), e 
2e3e 23					inc hl 
2e3f 72					ld (hl), d 
2e40			 
2e40					if DEBUG_FORTH_WORDS 
2e40						DMARK "-2e" 
2e40 f5				push af  
2e41 3a 55 2e			ld a, (.dmark)  
2e44 32 6b ee			ld (debug_mark),a  
2e47 3a 56 2e			ld a, (.dmark+1)  
2e4a 32 6c ee			ld (debug_mark+1),a  
2e4d 3a 57 2e			ld a, (.dmark+2)  
2e50 32 6d ee			ld (debug_mark+2),a  
2e53 18 03			jr .pastdmark  
2e55 ..			.dmark: db "-2e"  
2e58 f1			.pastdmark: pop af  
2e59			endm  
# End of macro DMARK
2e59						CALLMONITOR 
2e59 cd 6f ee			call debug_vector  
2e5c				endm  
# End of macro CALLMONITOR
2e5c					endif 
2e5c			 
2e5c			 
2e5c			 
2e5c			 
2e5c			 
2e5c				       NEXTW 
2e5c c3 f3 1f			jp macro_next 
2e5f				endm 
# End of macro NEXTW
2e5f			.GET2: 
2e5f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e5f 6f				db WORD_SYS_CORE+91             
2e60 8f 2e			dw .BANG2            
2e62 03				db 2 + 1 
2e63 .. 00			db "2@",0              
2e66				endm 
# End of macro CWHEAD
2e66			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e66					if DEBUG_FORTH_WORDS_KEY 
2e66						DMARK "2A_" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 6b ee			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 6c ee			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 6d ee			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "2A_"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f						CALLMONITOR 
2e7f cd 6f ee			call debug_vector  
2e82				endm  
# End of macro CALLMONITOR
2e82					endif 
2e82			 
2e82					FORTH_DSP_VALUEHL 
2e82 cd 3d 1e			call macro_dsp_valuehl 
2e85				endm 
# End of macro FORTH_DSP_VALUEHL
2e85			 
2e85 5e					ld e, (hl) 
2e86 23					inc hl 
2e87 56					ld d, (hl) 
2e88			 
2e88 eb					ex de, hl 
2e89			 
2e89 cd 46 1c				call forth_push_numhl 
2e8c			 
2e8c				       NEXTW 
2e8c c3 f3 1f			jp macro_next 
2e8f				endm 
# End of macro NEXTW
2e8f			.BANG2: 
2e8f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e8f 6f				db WORD_SYS_CORE+91             
2e90 c7 2e			dw .CONFIG            
2e92 03				db 2 + 1 
2e93 .. 00			db "2!",0              
2e96				endm 
# End of macro CWHEAD
2e96			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e96					if DEBUG_FORTH_WORDS_KEY 
2e96						DMARK "2S_" 
2e96 f5				push af  
2e97 3a ab 2e			ld a, (.dmark)  
2e9a 32 6b ee			ld (debug_mark),a  
2e9d 3a ac 2e			ld a, (.dmark+1)  
2ea0 32 6c ee			ld (debug_mark+1),a  
2ea3 3a ad 2e			ld a, (.dmark+2)  
2ea6 32 6d ee			ld (debug_mark+2),a  
2ea9 18 03			jr .pastdmark  
2eab ..			.dmark: db "2S_"  
2eae f1			.pastdmark: pop af  
2eaf			endm  
# End of macro DMARK
2eaf						CALLMONITOR 
2eaf cd 6f ee			call debug_vector  
2eb2				endm  
# End of macro CALLMONITOR
2eb2					endif 
2eb2			 
2eb2					FORTH_DSP_VALUEHL 
2eb2 cd 3d 1e			call macro_dsp_valuehl 
2eb5				endm 
# End of macro FORTH_DSP_VALUEHL
2eb5			 
2eb5 e5					push hl   ; save address 
2eb6			 
2eb6			 
2eb6					FORTH_DSP_POP 
2eb6 cd f5 1e			call macro_forth_dsp_pop 
2eb9				endm 
# End of macro FORTH_DSP_POP
2eb9			 
2eb9					 
2eb9					FORTH_DSP_VALUEHL 
2eb9 cd 3d 1e			call macro_dsp_valuehl 
2ebc				endm 
# End of macro FORTH_DSP_VALUEHL
2ebc			 
2ebc					FORTH_DSP_POP 
2ebc cd f5 1e			call macro_forth_dsp_pop 
2ebf				endm 
# End of macro FORTH_DSP_POP
2ebf			 
2ebf eb					ex de, hl    ; value now in de 
2ec0			 
2ec0 e1					pop hl 
2ec1			 
2ec1 73					ld (hl), e 
2ec2			 
2ec2 23					inc hl 
2ec3			 
2ec3 72					ld (hl), d 
2ec4			 
2ec4			 
2ec4				       NEXTW 
2ec4 c3 f3 1f			jp macro_next 
2ec7				endm 
# End of macro NEXTW
2ec7			.CONFIG: 
2ec7				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ec7 6f				db WORD_SYS_CORE+91             
2ec8 d8 2e			dw .ADTOS            
2eca 07				db 6 + 1 
2ecb .. 00			db "CONFIG",0              
2ed2				endm 
# End of macro CWHEAD
2ed2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ed2			 
2ed2 cd 47 14				call config 
2ed5					NEXTW 
2ed5 c3 f3 1f			jp macro_next 
2ed8				endm 
# End of macro NEXTW
2ed8			 
2ed8			.ADTOS: 
2ed8				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ed8 6f				db WORD_SYS_CORE+91             
2ed9 ee 2e			dw .SBTOS            
2edb 03				db 2 + 1 
2edc .. 00			db "1+",0              
2edf				endm 
# End of macro CWHEAD
2edf			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2edf			 
2edf					FORTH_DSP_VALUEHL 
2edf cd 3d 1e			call macro_dsp_valuehl 
2ee2				endm 
# End of macro FORTH_DSP_VALUEHL
2ee2 e5					push hl 
2ee3			 
2ee3					FORTH_DSP_POP 
2ee3 cd f5 1e			call macro_forth_dsp_pop 
2ee6				endm 
# End of macro FORTH_DSP_POP
2ee6 e1					pop hl 
2ee7			 
2ee7 23					inc hl 
2ee8 cd 46 1c				call forth_push_numhl 
2eeb					 
2eeb					NEXTW 
2eeb c3 f3 1f			jp macro_next 
2eee				endm 
# End of macro NEXTW
2eee			.SBTOS: 
2eee				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2eee 6f				db WORD_SYS_CORE+91             
2eef 04 2f			dw .ADSTORE            
2ef1 03				db 2 + 1 
2ef2 .. 00			db "1-",0              
2ef5				endm 
# End of macro CWHEAD
2ef5			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2ef5			 
2ef5					FORTH_DSP_VALUEHL 
2ef5 cd 3d 1e			call macro_dsp_valuehl 
2ef8				endm 
# End of macro FORTH_DSP_VALUEHL
2ef8 e5					push hl 
2ef9			 
2ef9					FORTH_DSP_POP 
2ef9 cd f5 1e			call macro_forth_dsp_pop 
2efc				endm 
# End of macro FORTH_DSP_POP
2efc e1					pop hl 
2efd			 
2efd 2b					dec hl 
2efe cd 46 1c				call forth_push_numhl 
2f01					 
2f01					NEXTW 
2f01 c3 f3 1f			jp macro_next 
2f04				endm 
# End of macro NEXTW
2f04			.ADSTORE: 
2f04				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f04 6f				db WORD_SYS_CORE+91             
2f05 1a 2f			dw .ADWSTORE            
2f07 04				db 3 + 1 
2f08 .. 00			db "1+!",0              
2f0c				endm 
# End of macro CWHEAD
2f0c			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f0c			 
2f0c					FORTH_DSP_VALUEHL 
2f0c cd 3d 1e			call macro_dsp_valuehl 
2f0f				endm 
# End of macro FORTH_DSP_VALUEHL
2f0f e5					push hl 
2f10			 
2f10					FORTH_DSP_POP 
2f10 cd f5 1e			call macro_forth_dsp_pop 
2f13				endm 
# End of macro FORTH_DSP_POP
2f13 e1					pop hl 
2f14			 
2f14 7e					ld a, (hl) 
2f15 3c					inc a 
2f16 77					ld (hl), a 
2f17					 
2f17					NEXTW 
2f17 c3 f3 1f			jp macro_next 
2f1a				endm 
# End of macro NEXTW
2f1a			.ADWSTORE: 
2f1a				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f1a 6f				db WORD_SYS_CORE+91             
2f1b 38 2f			dw .ENDCORE            
2f1d 05				db 4 + 1 
2f1e .. 00			db "1+2!",0              
2f23				endm 
# End of macro CWHEAD
2f23			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f23			 
2f23					FORTH_DSP_VALUEHL 
2f23 cd 3d 1e			call macro_dsp_valuehl 
2f26				endm 
# End of macro FORTH_DSP_VALUEHL
2f26 e5					push hl 
2f27			 
2f27					FORTH_DSP_POP 
2f27 cd f5 1e			call macro_forth_dsp_pop 
2f2a				endm 
# End of macro FORTH_DSP_POP
2f2a e1					pop hl 
2f2b			 
2f2b e5					push hl 
2f2c			 
2f2c cd 75 1f				call loadwordinhl 
2f2f 23					inc hl 
2f30			 
2f30 d1					pop de 
2f31 eb					ex de, hl 
2f32 73					ld (hl), e 
2f33 23					inc hl 
2f34 72					ld (hl), d 
2f35					 
2f35					NEXTW 
2f35 c3 f3 1f			jp macro_next 
2f38				endm 
# End of macro NEXTW
2f38			.ENDCORE: 
2f38			 
2f38			; eof 
2f38			 
2f38			 
# End of file forth_words_core.asm
2f38			include "forth_words_flow.asm" 
2f38			 
2f38			; | ## Program Flow Words 
2f38			 
2f38			.IF: 
2f38				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f38 1e				db WORD_SYS_CORE+10             
2f39 2d 30			dw .THEN            
2f3b 03				db 2 + 1 
2f3c .. 00			db "IF",0              
2f3f				endm 
# End of macro CWHEAD
2f3f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f3f			; 
2f3f					if DEBUG_FORTH_WORDS_KEY 
2f3f						DMARK "IF." 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 6b ee			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 6c ee			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 6d ee			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "IF."  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58						CALLMONITOR 
2f58 cd 6f ee			call debug_vector  
2f5b				endm  
# End of macro CALLMONITOR
2f5b					endif 
2f5b			; eval TOS 
2f5b			 
2f5b				FORTH_DSP_VALUEHL 
2f5b cd 3d 1e			call macro_dsp_valuehl 
2f5e				endm 
# End of macro FORTH_DSP_VALUEHL
2f5e			 
2f5e			;	push hl 
2f5e				FORTH_DSP_POP 
2f5e cd f5 1e			call macro_forth_dsp_pop 
2f61				endm 
# End of macro FORTH_DSP_POP
2f61			;	pop hl 
2f61			 
2f61					if DEBUG_FORTH_WORDS 
2f61						DMARK "IF1" 
2f61 f5				push af  
2f62 3a 76 2f			ld a, (.dmark)  
2f65 32 6b ee			ld (debug_mark),a  
2f68 3a 77 2f			ld a, (.dmark+1)  
2f6b 32 6c ee			ld (debug_mark+1),a  
2f6e 3a 78 2f			ld a, (.dmark+2)  
2f71 32 6d ee			ld (debug_mark+2),a  
2f74 18 03			jr .pastdmark  
2f76 ..			.dmark: db "IF1"  
2f79 f1			.pastdmark: pop af  
2f7a			endm  
# End of macro DMARK
2f7a						CALLMONITOR 
2f7a cd 6f ee			call debug_vector  
2f7d				endm  
# End of macro CALLMONITOR
2f7d					endif 
2f7d b7				or a        ; clear carry flag 
2f7e 11 00 00			ld de, 0 
2f81 eb				ex de,hl 
2f82 ed 52			sbc hl, de 
2f84 c2 0e 30			jp nz, .iftrue 
2f87			 
2f87					if DEBUG_FORTH_WORDS 
2f87						DMARK "IF2" 
2f87 f5				push af  
2f88 3a 9c 2f			ld a, (.dmark)  
2f8b 32 6b ee			ld (debug_mark),a  
2f8e 3a 9d 2f			ld a, (.dmark+1)  
2f91 32 6c ee			ld (debug_mark+1),a  
2f94 3a 9e 2f			ld a, (.dmark+2)  
2f97 32 6d ee			ld (debug_mark+2),a  
2f9a 18 03			jr .pastdmark  
2f9c ..			.dmark: db "IF2"  
2f9f f1			.pastdmark: pop af  
2fa0			endm  
# End of macro DMARK
2fa0						CALLMONITOR 
2fa0 cd 6f ee			call debug_vector  
2fa3				endm  
# End of macro CALLMONITOR
2fa3					endif 
2fa3			 
2fa3			; if not true then skip to THEN 
2fa3			 
2fa3				; TODO get tok_ptr 
2fa3				; TODO consume toks until we get to THEN 
2fa3			 
2fa3 2a c2 e5			ld hl, (os_tok_ptr) 
2fa6					if DEBUG_FORTH_WORDS 
2fa6						DMARK "IF3" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 6b ee			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 6c ee			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 6d ee			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "IF3"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd 6f ee			call debug_vector  
2fc2				endm  
# End of macro CALLMONITOR
2fc2						 
2fc2					endif 
2fc2 11 09 30			ld de, .ifthen 
2fc5					if DEBUG_FORTH_WORDS 
2fc5						DMARK "IF4" 
2fc5 f5				push af  
2fc6 3a da 2f			ld a, (.dmark)  
2fc9 32 6b ee			ld (debug_mark),a  
2fcc 3a db 2f			ld a, (.dmark+1)  
2fcf 32 6c ee			ld (debug_mark+1),a  
2fd2 3a dc 2f			ld a, (.dmark+2)  
2fd5 32 6d ee			ld (debug_mark+2),a  
2fd8 18 03			jr .pastdmark  
2fda ..			.dmark: db "IF4"  
2fdd f1			.pastdmark: pop af  
2fde			endm  
# End of macro DMARK
2fde						CALLMONITOR 
2fde cd 6f ee			call debug_vector  
2fe1				endm  
# End of macro CALLMONITOR
2fe1					endif 
2fe1 cd 0e 21			call findnexttok  
2fe4			 
2fe4					if DEBUG_FORTH_WORDS 
2fe4						DMARK "IF5" 
2fe4 f5				push af  
2fe5 3a f9 2f			ld a, (.dmark)  
2fe8 32 6b ee			ld (debug_mark),a  
2feb 3a fa 2f			ld a, (.dmark+1)  
2fee 32 6c ee			ld (debug_mark+1),a  
2ff1 3a fb 2f			ld a, (.dmark+2)  
2ff4 32 6d ee			ld (debug_mark+2),a  
2ff7 18 03			jr .pastdmark  
2ff9 ..			.dmark: db "IF5"  
2ffc f1			.pastdmark: pop af  
2ffd			endm  
# End of macro DMARK
2ffd						CALLMONITOR 
2ffd cd 6f ee			call debug_vector  
3000				endm  
# End of macro CALLMONITOR
3000					endif 
3000				; TODO replace below with ; exec using tok_ptr 
3000 22 c2 e5			ld (os_tok_ptr), hl 
3003 c3 84 20			jp exec1 
3006				NEXTW 
3006 c3 f3 1f			jp macro_next 
3009				endm 
# End of macro NEXTW
3009			 
3009 .. 00		.ifthen:  db "THEN",0 
300e			 
300e			.iftrue:		 
300e				; Exec next words normally 
300e			 
300e				; if true then exec following IF as normal 
300e					if DEBUG_FORTH_WORDS 
300e						DMARK "IFT" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 6b ee			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 6c ee			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 6d ee			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "IFT"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027						CALLMONITOR 
3027 cd 6f ee			call debug_vector  
302a				endm  
# End of macro CALLMONITOR
302a					endif 
302a			 
302a					NEXTW 
302a c3 f3 1f			jp macro_next 
302d				endm 
# End of macro NEXTW
302d			.THEN: 
302d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
302d 1f				db WORD_SYS_CORE+11             
302e 55 30			dw .ELSE            
3030 05				db 4 + 1 
3031 .. 00			db "THEN",0              
3036				endm 
# End of macro CWHEAD
3036			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3036					if DEBUG_FORTH_WORDS_KEY 
3036						DMARK "THN" 
3036 f5				push af  
3037 3a 4b 30			ld a, (.dmark)  
303a 32 6b ee			ld (debug_mark),a  
303d 3a 4c 30			ld a, (.dmark+1)  
3040 32 6c ee			ld (debug_mark+1),a  
3043 3a 4d 30			ld a, (.dmark+2)  
3046 32 6d ee			ld (debug_mark+2),a  
3049 18 03			jr .pastdmark  
304b ..			.dmark: db "THN"  
304e f1			.pastdmark: pop af  
304f			endm  
# End of macro DMARK
304f						CALLMONITOR 
304f cd 6f ee			call debug_vector  
3052				endm  
# End of macro CALLMONITOR
3052					endif 
3052					NEXTW 
3052 c3 f3 1f			jp macro_next 
3055				endm 
# End of macro NEXTW
3055			.ELSE: 
3055				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3055 20				db WORD_SYS_CORE+12             
3056 7d 30			dw .DO            
3058 03				db 2 + 1 
3059 .. 00			db "ELSE",0              
305e				endm 
# End of macro CWHEAD
305e			; | ELSE ( -- ) Not supported - does nothing | TODO 
305e			 
305e					if DEBUG_FORTH_WORDS_KEY 
305e						DMARK "ELS" 
305e f5				push af  
305f 3a 73 30			ld a, (.dmark)  
3062 32 6b ee			ld (debug_mark),a  
3065 3a 74 30			ld a, (.dmark+1)  
3068 32 6c ee			ld (debug_mark+1),a  
306b 3a 75 30			ld a, (.dmark+2)  
306e 32 6d ee			ld (debug_mark+2),a  
3071 18 03			jr .pastdmark  
3073 ..			.dmark: db "ELS"  
3076 f1			.pastdmark: pop af  
3077			endm  
# End of macro DMARK
3077						CALLMONITOR 
3077 cd 6f ee			call debug_vector  
307a				endm  
# End of macro CALLMONITOR
307a					endif 
307a			 
307a			 
307a					NEXTW 
307a c3 f3 1f			jp macro_next 
307d				endm 
# End of macro NEXTW
307d			.DO: 
307d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
307d 21				db WORD_SYS_CORE+13             
307e a4 31			dw .LOOP            
3080 03				db 2 + 1 
3081 .. 00			db "DO",0              
3084				endm 
# End of macro CWHEAD
3084			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3084			 
3084					if DEBUG_FORTH_WORDS_KEY 
3084						DMARK "DO." 
3084 f5				push af  
3085 3a 99 30			ld a, (.dmark)  
3088 32 6b ee			ld (debug_mark),a  
308b 3a 9a 30			ld a, (.dmark+1)  
308e 32 6c ee			ld (debug_mark+1),a  
3091 3a 9b 30			ld a, (.dmark+2)  
3094 32 6d ee			ld (debug_mark+2),a  
3097 18 03			jr .pastdmark  
3099 ..			.dmark: db "DO."  
309c f1			.pastdmark: pop af  
309d			endm  
# End of macro DMARK
309d						CALLMONITOR 
309d cd 6f ee			call debug_vector  
30a0				endm  
# End of macro CALLMONITOR
30a0					endif 
30a0			;  push pc to rsp stack past the DO 
30a0			 
30a0 2a c2 e5				ld hl, (os_tok_ptr) 
30a3 23					inc hl   ; D 
30a4 23					inc hl  ; O 
30a5 23					inc hl   ; null 
30a6					if DEBUG_FORTH_WORDS 
30a6						DMARK "DO2" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 6b ee			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 6c ee			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 6d ee			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "DO2"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf						CALLMONITOR 
30bf cd 6f ee			call debug_vector  
30c2				endm  
# End of macro CALLMONITOR
30c2					endif 
30c2					FORTH_RSP_NEXT 
30c2 cd ed 1b			call macro_forth_rsp_next 
30c5				endm 
# End of macro FORTH_RSP_NEXT
30c5					if DEBUG_FORTH_WORDS 
30c5						DMARK "DO3" 
30c5 f5				push af  
30c6 3a da 30			ld a, (.dmark)  
30c9 32 6b ee			ld (debug_mark),a  
30cc 3a db 30			ld a, (.dmark+1)  
30cf 32 6c ee			ld (debug_mark+1),a  
30d2 3a dc 30			ld a, (.dmark+2)  
30d5 32 6d ee			ld (debug_mark+2),a  
30d8 18 03			jr .pastdmark  
30da ..			.dmark: db "DO3"  
30dd f1			.pastdmark: pop af  
30de			endm  
# End of macro DMARK
30de						CALLMONITOR 
30de cd 6f ee			call debug_vector  
30e1				endm  
# End of macro CALLMONITOR
30e1					endif 
30e1			 
30e1					;if DEBUG_FORTH_WORDS 
30e1				;		push hl 
30e1			;		endif  
30e1			 
30e1			; get counters from data stack 
30e1			 
30e1			 
30e1					FORTH_DSP_VALUEHL 
30e1 cd 3d 1e			call macro_dsp_valuehl 
30e4				endm 
# End of macro FORTH_DSP_VALUEHL
30e4 e5					push hl		 ; hl now has starting counter which needs to be tos 
30e5			 
30e5					if DEBUG_FORTH_WORDS 
30e5						DMARK "DO4" 
30e5 f5				push af  
30e6 3a fa 30			ld a, (.dmark)  
30e9 32 6b ee			ld (debug_mark),a  
30ec 3a fb 30			ld a, (.dmark+1)  
30ef 32 6c ee			ld (debug_mark+1),a  
30f2 3a fc 30			ld a, (.dmark+2)  
30f5 32 6d ee			ld (debug_mark+2),a  
30f8 18 03			jr .pastdmark  
30fa ..			.dmark: db "DO4"  
30fd f1			.pastdmark: pop af  
30fe			endm  
# End of macro DMARK
30fe						CALLMONITOR 
30fe cd 6f ee			call debug_vector  
3101				endm  
# End of macro CALLMONITOR
3101					endif 
3101					FORTH_DSP_POP 
3101 cd f5 1e			call macro_forth_dsp_pop 
3104				endm 
# End of macro FORTH_DSP_POP
3104			 
3104					if DEBUG_FORTH_WORDS 
3104						DMARK "DO5" 
3104 f5				push af  
3105 3a 19 31			ld a, (.dmark)  
3108 32 6b ee			ld (debug_mark),a  
310b 3a 1a 31			ld a, (.dmark+1)  
310e 32 6c ee			ld (debug_mark+1),a  
3111 3a 1b 31			ld a, (.dmark+2)  
3114 32 6d ee			ld (debug_mark+2),a  
3117 18 03			jr .pastdmark  
3119 ..			.dmark: db "DO5"  
311c f1			.pastdmark: pop af  
311d			endm  
# End of macro DMARK
311d						CALLMONITOR 
311d cd 6f ee			call debug_vector  
3120				endm  
# End of macro CALLMONITOR
3120					endif 
3120			 
3120					FORTH_DSP_VALUEHL 
3120 cd 3d 1e			call macro_dsp_valuehl 
3123				endm 
# End of macro FORTH_DSP_VALUEHL
3123			;		push hl		 ; hl now has starting limit counter 
3123			 
3123					if DEBUG_FORTH_WORDS 
3123						DMARK "DO6" 
3123 f5				push af  
3124 3a 38 31			ld a, (.dmark)  
3127 32 6b ee			ld (debug_mark),a  
312a 3a 39 31			ld a, (.dmark+1)  
312d 32 6c ee			ld (debug_mark+1),a  
3130 3a 3a 31			ld a, (.dmark+2)  
3133 32 6d ee			ld (debug_mark+2),a  
3136 18 03			jr .pastdmark  
3138 ..			.dmark: db "DO6"  
313b f1			.pastdmark: pop af  
313c			endm  
# End of macro DMARK
313c						CALLMONITOR 
313c cd 6f ee			call debug_vector  
313f				endm  
# End of macro CALLMONITOR
313f					endif 
313f					FORTH_DSP_POP 
313f cd f5 1e			call macro_forth_dsp_pop 
3142				endm 
# End of macro FORTH_DSP_POP
3142			 
3142			; put counters on the loop stack 
3142			 
3142			;		pop hl			 ; limit counter 
3142 d1					pop de			; start counter 
3143			 
3143					; push limit counter 
3143			 
3143					if DEBUG_FORTH_WORDS 
3143						DMARK "DO7" 
3143 f5				push af  
3144 3a 58 31			ld a, (.dmark)  
3147 32 6b ee			ld (debug_mark),a  
314a 3a 59 31			ld a, (.dmark+1)  
314d 32 6c ee			ld (debug_mark+1),a  
3150 3a 5a 31			ld a, (.dmark+2)  
3153 32 6d ee			ld (debug_mark+2),a  
3156 18 03			jr .pastdmark  
3158 ..			.dmark: db "DO7"  
315b f1			.pastdmark: pop af  
315c			endm  
# End of macro DMARK
315c						CALLMONITOR 
315c cd 6f ee			call debug_vector  
315f				endm  
# End of macro CALLMONITOR
315f					endif 
315f					FORTH_LOOP_NEXT 
315f cd 6e 1e			call macro_forth_loop_next 
3162				endm 
# End of macro FORTH_LOOP_NEXT
3162			 
3162					; push start counter 
3162			 
3162 eb					ex de, hl 
3163					if DEBUG_FORTH_WORDS 
3163						DMARK "DO7" 
3163 f5				push af  
3164 3a 78 31			ld a, (.dmark)  
3167 32 6b ee			ld (debug_mark),a  
316a 3a 79 31			ld a, (.dmark+1)  
316d 32 6c ee			ld (debug_mark+1),a  
3170 3a 7a 31			ld a, (.dmark+2)  
3173 32 6d ee			ld (debug_mark+2),a  
3176 18 03			jr .pastdmark  
3178 ..			.dmark: db "DO7"  
317b f1			.pastdmark: pop af  
317c			endm  
# End of macro DMARK
317c						CALLMONITOR 
317c cd 6f ee			call debug_vector  
317f				endm  
# End of macro CALLMONITOR
317f					endif 
317f					FORTH_LOOP_NEXT 
317f cd 6e 1e			call macro_forth_loop_next 
3182				endm 
# End of macro FORTH_LOOP_NEXT
3182			 
3182			 
3182					; init first round of I counter 
3182			 
3182 22 e6 e5				ld (os_current_i), hl 
3185			 
3185					if DEBUG_FORTH_WORDS 
3185						DMARK "DO8" 
3185 f5				push af  
3186 3a 9a 31			ld a, (.dmark)  
3189 32 6b ee			ld (debug_mark),a  
318c 3a 9b 31			ld a, (.dmark+1)  
318f 32 6c ee			ld (debug_mark+1),a  
3192 3a 9c 31			ld a, (.dmark+2)  
3195 32 6d ee			ld (debug_mark+2),a  
3198 18 03			jr .pastdmark  
319a ..			.dmark: db "DO8"  
319d f1			.pastdmark: pop af  
319e			endm  
# End of macro DMARK
319e						CALLMONITOR 
319e cd 6f ee			call debug_vector  
31a1				endm  
# End of macro CALLMONITOR
31a1					endif 
31a1			 
31a1					NEXTW 
31a1 c3 f3 1f			jp macro_next 
31a4				endm 
# End of macro NEXTW
31a4			.LOOP: 
31a4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31a4 22				db WORD_SYS_CORE+14             
31a5 bc 32			dw .I            
31a7 05				db 4 + 1 
31a8 .. 00			db "LOOP",0              
31ad				endm 
# End of macro CWHEAD
31ad			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31ad			 
31ad				; pop tos as current loop count to hl 
31ad			 
31ad				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31ad			 
31ad				FORTH_LOOP_TOS 
31ad cd a1 1e			call macro_forth_loop_tos 
31b0				endm 
# End of macro FORTH_LOOP_TOS
31b0 e5				push hl 
31b1			 
31b1					if DEBUG_FORTH_WORDS_KEY 
31b1						DMARK "LOP" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 6b ee			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 6c ee			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 6d ee			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "LOP"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca						CALLMONITOR 
31ca cd 6f ee			call debug_vector  
31cd				endm  
# End of macro CALLMONITOR
31cd					endif 
31cd				; next item on the stack is the limit. get it 
31cd			 
31cd			 
31cd				FORTH_LOOP_POP 
31cd cd ab 1e			call macro_forth_loop_pop 
31d0				endm 
# End of macro FORTH_LOOP_POP
31d0			 
31d0				FORTH_LOOP_TOS 
31d0 cd a1 1e			call macro_forth_loop_tos 
31d3				endm 
# End of macro FORTH_LOOP_TOS
31d3			 
31d3 d1				pop de		 ; de = i, hl = limit 
31d4			 
31d4					if DEBUG_FORTH_WORDS 
31d4						DMARK "LP1" 
31d4 f5				push af  
31d5 3a e9 31			ld a, (.dmark)  
31d8 32 6b ee			ld (debug_mark),a  
31db 3a ea 31			ld a, (.dmark+1)  
31de 32 6c ee			ld (debug_mark+1),a  
31e1 3a eb 31			ld a, (.dmark+2)  
31e4 32 6d ee			ld (debug_mark+2),a  
31e7 18 03			jr .pastdmark  
31e9 ..			.dmark: db "LP1"  
31ec f1			.pastdmark: pop af  
31ed			endm  
# End of macro DMARK
31ed						CALLMONITOR 
31ed cd 6f ee			call debug_vector  
31f0				endm  
# End of macro CALLMONITOR
31f0					endif 
31f0			 
31f0				; go back to previous word 
31f0			 
31f0 d5				push de    ; save I for inc later 
31f1			 
31f1			 
31f1				; get limit 
31f1				;  is I at limit? 
31f1			 
31f1			 
31f1					if DEBUG_FORTH_WORDS 
31f1						DMARK "LP1" 
31f1 f5				push af  
31f2 3a 06 32			ld a, (.dmark)  
31f5 32 6b ee			ld (debug_mark),a  
31f8 3a 07 32			ld a, (.dmark+1)  
31fb 32 6c ee			ld (debug_mark+1),a  
31fe 3a 08 32			ld a, (.dmark+2)  
3201 32 6d ee			ld (debug_mark+2),a  
3204 18 03			jr .pastdmark  
3206 ..			.dmark: db "LP1"  
3209 f1			.pastdmark: pop af  
320a			endm  
# End of macro DMARK
320a						CALLMONITOR 
320a cd 6f ee			call debug_vector  
320d				endm  
# End of macro CALLMONITOR
320d					endif 
320d			 
320d ed 52			sbc hl, de 
320f			 
320f			 
320f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
320f			 
320f 20 26				jr nz, .loopnotdone 
3211			 
3211 e1				pop hl   ; get rid of saved I 
3212				FORTH_LOOP_POP     ; get rid of limit 
3212 cd ab 1e			call macro_forth_loop_pop 
3215				endm 
# End of macro FORTH_LOOP_POP
3215			 
3215				FORTH_RSP_POP     ; get rid of DO ptr 
3215 cd 0e 1c			call macro_forth_rsp_pop 
3218				endm 
# End of macro FORTH_RSP_POP
3218			 
3218			if DEBUG_FORTH_WORDS 
3218						DMARK "LP>" 
3218 f5				push af  
3219 3a 2d 32			ld a, (.dmark)  
321c 32 6b ee			ld (debug_mark),a  
321f 3a 2e 32			ld a, (.dmark+1)  
3222 32 6c ee			ld (debug_mark+1),a  
3225 3a 2f 32			ld a, (.dmark+2)  
3228 32 6d ee			ld (debug_mark+2),a  
322b 18 03			jr .pastdmark  
322d ..			.dmark: db "LP>"  
3230 f1			.pastdmark: pop af  
3231			endm  
# End of macro DMARK
3231				CALLMONITOR 
3231 cd 6f ee			call debug_vector  
3234				endm  
# End of macro CALLMONITOR
3234			endif 
3234			 
3234					NEXTW 
3234 c3 f3 1f			jp macro_next 
3237				endm 
# End of macro NEXTW
3237				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3237			 
3237			.loopnotdone: 
3237			 
3237 e1				pop hl    ; get I 
3238 23				inc hl 
3239			 
3239			   	; save new I 
3239			 
3239			 
3239					; set I counter 
3239			 
3239 22 e6 e5				ld (os_current_i), hl 
323c			 
323c					if DEBUG_FORTH_WORDS 
323c						DMARK "LPN" 
323c f5				push af  
323d 3a 51 32			ld a, (.dmark)  
3240 32 6b ee			ld (debug_mark),a  
3243 3a 52 32			ld a, (.dmark+1)  
3246 32 6c ee			ld (debug_mark+1),a  
3249 3a 53 32			ld a, (.dmark+2)  
324c 32 6d ee			ld (debug_mark+2),a  
324f 18 03			jr .pastdmark  
3251 ..			.dmark: db "LPN"  
3254 f1			.pastdmark: pop af  
3255			endm  
# End of macro DMARK
3255					CALLMONITOR 
3255 cd 6f ee			call debug_vector  
3258				endm  
# End of macro CALLMONITOR
3258					endif 
3258					 
3258				FORTH_LOOP_NEXT 
3258 cd 6e 1e			call macro_forth_loop_next 
325b				endm 
# End of macro FORTH_LOOP_NEXT
325b			 
325b			 
325b					if DEBUG_FORTH_WORDS 
325b eb						ex de,hl 
325c					endif 
325c			 
325c			;	; get DO ptr 
325c			; 
325c					if DEBUG_FORTH_WORDS 
325c						DMARK "LP7" 
325c f5				push af  
325d 3a 71 32			ld a, (.dmark)  
3260 32 6b ee			ld (debug_mark),a  
3263 3a 72 32			ld a, (.dmark+1)  
3266 32 6c ee			ld (debug_mark+1),a  
3269 3a 73 32			ld a, (.dmark+2)  
326c 32 6d ee			ld (debug_mark+2),a  
326f 18 03			jr .pastdmark  
3271 ..			.dmark: db "LP7"  
3274 f1			.pastdmark: pop af  
3275			endm  
# End of macro DMARK
3275					CALLMONITOR 
3275 cd 6f ee			call debug_vector  
3278				endm  
# End of macro CALLMONITOR
3278					endif 
3278				FORTH_RSP_TOS 
3278 cd 04 1c			call macro_forth_rsp_tos 
327b				endm 
# End of macro FORTH_RSP_TOS
327b			 
327b					if DEBUG_FORTH_WORDS 
327b						DMARK "LP8" 
327b f5				push af  
327c 3a 90 32			ld a, (.dmark)  
327f 32 6b ee			ld (debug_mark),a  
3282 3a 91 32			ld a, (.dmark+1)  
3285 32 6c ee			ld (debug_mark+1),a  
3288 3a 92 32			ld a, (.dmark+2)  
328b 32 6d ee			ld (debug_mark+2),a  
328e 18 03			jr .pastdmark  
3290 ..			.dmark: db "LP8"  
3293 f1			.pastdmark: pop af  
3294			endm  
# End of macro DMARK
3294					CALLMONITOR 
3294 cd 6f ee			call debug_vector  
3297				endm  
# End of macro CALLMONITOR
3297					endif 
3297				;push hl 
3297			 
3297				; not going to DO any more 
3297				; get rid of the RSP pointer as DO will add it back in 
3297				;FORTH_RSP_POP 
3297				;pop hl 
3297			 
3297				;ld hl,(cli_ret_sp) 
3297				;ld e, (hl) 
3297				;inc hl 
3297				;ld d, (hl) 
3297				;ex de,hl 
3297 22 c2 e5			ld (os_tok_ptr), hl 
329a					if DEBUG_FORTH_WORDS 
329a						DMARK "LP<" 
329a f5				push af  
329b 3a af 32			ld a, (.dmark)  
329e 32 6b ee			ld (debug_mark),a  
32a1 3a b0 32			ld a, (.dmark+1)  
32a4 32 6c ee			ld (debug_mark+1),a  
32a7 3a b1 32			ld a, (.dmark+2)  
32aa 32 6d ee			ld (debug_mark+2),a  
32ad 18 03			jr .pastdmark  
32af ..			.dmark: db "LP<"  
32b2 f1			.pastdmark: pop af  
32b3			endm  
# End of macro DMARK
32b3					CALLMONITOR 
32b3 cd 6f ee			call debug_vector  
32b6				endm  
# End of macro CALLMONITOR
32b6				endif 
32b6 c3 84 20			jp exec1 
32b9			 
32b9					 
32b9			 
32b9			 
32b9					NEXTW 
32b9 c3 f3 1f			jp macro_next 
32bc				endm 
# End of macro NEXTW
32bc			.I:  
32bc			 
32bc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32bc 5e				db WORD_SYS_CORE+74             
32bd e7 32			dw .DLOOP            
32bf 02				db 1 + 1 
32c0 .. 00			db "I",0              
32c2				endm 
# End of macro CWHEAD
32c2			; | I ( -- ) Current loop counter | DONE 
32c2					if DEBUG_FORTH_WORDS_KEY 
32c2						DMARK "I.." 
32c2 f5				push af  
32c3 3a d7 32			ld a, (.dmark)  
32c6 32 6b ee			ld (debug_mark),a  
32c9 3a d8 32			ld a, (.dmark+1)  
32cc 32 6c ee			ld (debug_mark+1),a  
32cf 3a d9 32			ld a, (.dmark+2)  
32d2 32 6d ee			ld (debug_mark+2),a  
32d5 18 03			jr .pastdmark  
32d7 ..			.dmark: db "I.."  
32da f1			.pastdmark: pop af  
32db			endm  
# End of macro DMARK
32db						CALLMONITOR 
32db cd 6f ee			call debug_vector  
32de				endm  
# End of macro CALLMONITOR
32de					endif 
32de			 
32de 2a e6 e5				ld hl,(os_current_i) 
32e1 cd 46 1c				call forth_push_numhl 
32e4			 
32e4					NEXTW 
32e4 c3 f3 1f			jp macro_next 
32e7				endm 
# End of macro NEXTW
32e7			.DLOOP: 
32e7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32e7 5f				db WORD_SYS_CORE+75             
32e8 c8 33			dw .REPEAT            
32ea 06				db 5 + 1 
32eb .. 00			db "-LOOP",0              
32f1				endm 
# End of macro CWHEAD
32f1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32f1				; pop tos as current loop count to hl 
32f1					if DEBUG_FORTH_WORDS_KEY 
32f1						DMARK "-LP" 
32f1 f5				push af  
32f2 3a 06 33			ld a, (.dmark)  
32f5 32 6b ee			ld (debug_mark),a  
32f8 3a 07 33			ld a, (.dmark+1)  
32fb 32 6c ee			ld (debug_mark+1),a  
32fe 3a 08 33			ld a, (.dmark+2)  
3301 32 6d ee			ld (debug_mark+2),a  
3304 18 03			jr .pastdmark  
3306 ..			.dmark: db "-LP"  
3309 f1			.pastdmark: pop af  
330a			endm  
# End of macro DMARK
330a						CALLMONITOR 
330a cd 6f ee			call debug_vector  
330d				endm  
# End of macro CALLMONITOR
330d					endif 
330d			 
330d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
330d			 
330d				FORTH_LOOP_TOS 
330d cd a1 1e			call macro_forth_loop_tos 
3310				endm 
# End of macro FORTH_LOOP_TOS
3310 e5				push hl 
3311			 
3311					if DEBUG_FORTH_WORDS 
3311						DMARK "-LP" 
3311 f5				push af  
3312 3a 26 33			ld a, (.dmark)  
3315 32 6b ee			ld (debug_mark),a  
3318 3a 27 33			ld a, (.dmark+1)  
331b 32 6c ee			ld (debug_mark+1),a  
331e 3a 28 33			ld a, (.dmark+2)  
3321 32 6d ee			ld (debug_mark+2),a  
3324 18 03			jr .pastdmark  
3326 ..			.dmark: db "-LP"  
3329 f1			.pastdmark: pop af  
332a			endm  
# End of macro DMARK
332a						CALLMONITOR 
332a cd 6f ee			call debug_vector  
332d				endm  
# End of macro CALLMONITOR
332d					endif 
332d				; next item on the stack is the limit. get it 
332d			 
332d			 
332d				FORTH_LOOP_POP 
332d cd ab 1e			call macro_forth_loop_pop 
3330				endm 
# End of macro FORTH_LOOP_POP
3330			 
3330				FORTH_LOOP_TOS 
3330 cd a1 1e			call macro_forth_loop_tos 
3333				endm 
# End of macro FORTH_LOOP_TOS
3333			 
3333 d1				pop de		 ; de = i, hl = limit 
3334			 
3334					if DEBUG_FORTH_WORDS 
3334						DMARK "-L1" 
3334 f5				push af  
3335 3a 49 33			ld a, (.dmark)  
3338 32 6b ee			ld (debug_mark),a  
333b 3a 4a 33			ld a, (.dmark+1)  
333e 32 6c ee			ld (debug_mark+1),a  
3341 3a 4b 33			ld a, (.dmark+2)  
3344 32 6d ee			ld (debug_mark+2),a  
3347 18 03			jr .pastdmark  
3349 ..			.dmark: db "-L1"  
334c f1			.pastdmark: pop af  
334d			endm  
# End of macro DMARK
334d						CALLMONITOR 
334d cd 6f ee			call debug_vector  
3350				endm  
# End of macro CALLMONITOR
3350					endif 
3350			 
3350				; go back to previous word 
3350			 
3350 d5				push de    ; save I for inc later 
3351			 
3351			 
3351				; get limit 
3351				;  is I at limit? 
3351			 
3351			 
3351					if DEBUG_FORTH_WORDS 
3351						DMARK "-L1" 
3351 f5				push af  
3352 3a 66 33			ld a, (.dmark)  
3355 32 6b ee			ld (debug_mark),a  
3358 3a 67 33			ld a, (.dmark+1)  
335b 32 6c ee			ld (debug_mark+1),a  
335e 3a 68 33			ld a, (.dmark+2)  
3361 32 6d ee			ld (debug_mark+2),a  
3364 18 03			jr .pastdmark  
3366 ..			.dmark: db "-L1"  
3369 f1			.pastdmark: pop af  
336a			endm  
# End of macro DMARK
336a						CALLMONITOR 
336a cd 6f ee			call debug_vector  
336d				endm  
# End of macro CALLMONITOR
336d					endif 
336d			 
336d ed 52			sbc hl, de 
336f			 
336f			 
336f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
336f			 
336f 20 26				jr nz, .mloopnotdone 
3371			 
3371 e1				pop hl   ; get rid of saved I 
3372				FORTH_LOOP_POP     ; get rid of limit 
3372 cd ab 1e			call macro_forth_loop_pop 
3375				endm 
# End of macro FORTH_LOOP_POP
3375			 
3375				FORTH_RSP_POP     ; get rid of DO ptr 
3375 cd 0e 1c			call macro_forth_rsp_pop 
3378				endm 
# End of macro FORTH_RSP_POP
3378			 
3378			if DEBUG_FORTH_WORDS 
3378						DMARK "-L>" 
3378 f5				push af  
3379 3a 8d 33			ld a, (.dmark)  
337c 32 6b ee			ld (debug_mark),a  
337f 3a 8e 33			ld a, (.dmark+1)  
3382 32 6c ee			ld (debug_mark+1),a  
3385 3a 8f 33			ld a, (.dmark+2)  
3388 32 6d ee			ld (debug_mark+2),a  
338b 18 03			jr .pastdmark  
338d ..			.dmark: db "-L>"  
3390 f1			.pastdmark: pop af  
3391			endm  
# End of macro DMARK
3391				CALLMONITOR 
3391 cd 6f ee			call debug_vector  
3394				endm  
# End of macro CALLMONITOR
3394			endif 
3394			 
3394					NEXTW 
3394 c3 f3 1f			jp macro_next 
3397				endm 
# End of macro NEXTW
3397				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3397			 
3397			.mloopnotdone: 
3397			 
3397 e1				pop hl    ; get I 
3398 2b				dec hl 
3399			 
3399			   	; save new I 
3399			 
3399			 
3399					; set I counter 
3399			 
3399 22 e6 e5				ld (os_current_i), hl 
339c			 
339c					 
339c				FORTH_LOOP_NEXT 
339c cd 6e 1e			call macro_forth_loop_next 
339f				endm 
# End of macro FORTH_LOOP_NEXT
339f			 
339f			 
339f					if DEBUG_FORTH_WORDS 
339f eb						ex de,hl 
33a0					endif 
33a0			 
33a0			;	; get DO ptr 
33a0			; 
33a0				FORTH_RSP_TOS 
33a0 cd 04 1c			call macro_forth_rsp_tos 
33a3				endm 
# End of macro FORTH_RSP_TOS
33a3			 
33a3				;push hl 
33a3			 
33a3				; not going to DO any more 
33a3				; get rid of the RSP pointer as DO will add it back in 
33a3				;FORTH_RSP_POP 
33a3				;pop hl 
33a3			 
33a3			 
33a3 22 c2 e5			ld (os_tok_ptr), hl 
33a6					if DEBUG_FORTH_WORDS 
33a6						DMARK "-L<" 
33a6 f5				push af  
33a7 3a bb 33			ld a, (.dmark)  
33aa 32 6b ee			ld (debug_mark),a  
33ad 3a bc 33			ld a, (.dmark+1)  
33b0 32 6c ee			ld (debug_mark+1),a  
33b3 3a bd 33			ld a, (.dmark+2)  
33b6 32 6d ee			ld (debug_mark+2),a  
33b9 18 03			jr .pastdmark  
33bb ..			.dmark: db "-L<"  
33be f1			.pastdmark: pop af  
33bf			endm  
# End of macro DMARK
33bf					CALLMONITOR 
33bf cd 6f ee			call debug_vector  
33c2				endm  
# End of macro CALLMONITOR
33c2				endif 
33c2 c3 84 20			jp exec1 
33c5			 
33c5					 
33c5			 
33c5			 
33c5			 
33c5				NEXTW 
33c5 c3 f3 1f			jp macro_next 
33c8				endm 
# End of macro NEXTW
33c8			 
33c8			 
33c8			 
33c8			 
33c8			.REPEAT: 
33c8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33c8 71				db WORD_SYS_CORE+93             
33c9 1b 34			dw .UNTIL            
33cb 06				db 5 + 1 
33cc .. 00			db "REPEAT",0              
33d3				endm 
# End of macro CWHEAD
33d3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33d3			;  push pc to rsp stack past the REPEAT 
33d3					if DEBUG_FORTH_WORDS_KEY 
33d3						DMARK "REP" 
33d3 f5				push af  
33d4 3a e8 33			ld a, (.dmark)  
33d7 32 6b ee			ld (debug_mark),a  
33da 3a e9 33			ld a, (.dmark+1)  
33dd 32 6c ee			ld (debug_mark+1),a  
33e0 3a ea 33			ld a, (.dmark+2)  
33e3 32 6d ee			ld (debug_mark+2),a  
33e6 18 03			jr .pastdmark  
33e8 ..			.dmark: db "REP"  
33eb f1			.pastdmark: pop af  
33ec			endm  
# End of macro DMARK
33ec						CALLMONITOR 
33ec cd 6f ee			call debug_vector  
33ef				endm  
# End of macro CALLMONITOR
33ef					endif 
33ef			 
33ef 2a c2 e5				ld hl, (os_tok_ptr) 
33f2 23					inc hl   ; R 
33f3 23					inc hl  ; E 
33f4 23					inc hl   ; P 
33f5 23					inc hl   ; E 
33f6 23					inc hl   ; A 
33f7 23					inc hl   ; T 
33f8 23					inc hl   ; zero 
33f9					FORTH_RSP_NEXT 
33f9 cd ed 1b			call macro_forth_rsp_next 
33fc				endm 
# End of macro FORTH_RSP_NEXT
33fc			 
33fc			 
33fc					if DEBUG_FORTH_WORDS 
33fc						DMARK "REP" 
33fc f5				push af  
33fd 3a 11 34			ld a, (.dmark)  
3400 32 6b ee			ld (debug_mark),a  
3403 3a 12 34			ld a, (.dmark+1)  
3406 32 6c ee			ld (debug_mark+1),a  
3409 3a 13 34			ld a, (.dmark+2)  
340c 32 6d ee			ld (debug_mark+2),a  
340f 18 03			jr .pastdmark  
3411 ..			.dmark: db "REP"  
3414 f1			.pastdmark: pop af  
3415			endm  
# End of macro DMARK
3415						;pop bc    ; TODO BUG ?????? what is this for???? 
3415						CALLMONITOR 
3415 cd 6f ee			call debug_vector  
3418				endm  
# End of macro CALLMONITOR
3418					endif 
3418			 
3418					NEXTW 
3418 c3 f3 1f			jp macro_next 
341b				endm 
# End of macro NEXTW
341b			;	       NEXTW 
341b			 
341b			.UNTIL: 
341b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
341b 72				db WORD_SYS_CORE+94             
341c b2 34			dw .ENDFLOW            
341e 06				db 5 + 1 
341f .. 00			db "UNTIL",0              
3425				endm 
# End of macro CWHEAD
3425			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3425			 
3425				; pop tos as check 
3425			 
3425				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3425			 
3425				FORTH_DSP_VALUEHL 
3425 cd 3d 1e			call macro_dsp_valuehl 
3428				endm 
# End of macro FORTH_DSP_VALUEHL
3428			 
3428					if DEBUG_FORTH_WORDS_KEY 
3428						DMARK "UNT" 
3428 f5				push af  
3429 3a 3d 34			ld a, (.dmark)  
342c 32 6b ee			ld (debug_mark),a  
342f 3a 3e 34			ld a, (.dmark+1)  
3432 32 6c ee			ld (debug_mark+1),a  
3435 3a 3f 34			ld a, (.dmark+2)  
3438 32 6d ee			ld (debug_mark+2),a  
343b 18 03			jr .pastdmark  
343d ..			.dmark: db "UNT"  
3440 f1			.pastdmark: pop af  
3441			endm  
# End of macro DMARK
3441						CALLMONITOR 
3441 cd 6f ee			call debug_vector  
3444				endm  
# End of macro CALLMONITOR
3444					endif 
3444			 
3444			;	push hl 
3444				FORTH_DSP_POP 
3444 cd f5 1e			call macro_forth_dsp_pop 
3447				endm 
# End of macro FORTH_DSP_POP
3447			 
3447			;	pop hl 
3447			 
3447				; test if true 
3447			 
3447 cd 10 0e			call ishlzero 
344a			;	ld a,l 
344a			;	add h 
344a			; 
344a			;	cp 0 
344a			 
344a 20 3e			jr nz, .untilnotdone 
344c			 
344c					if DEBUG_FORTH_WORDS 
344c						DMARK "UNf" 
344c f5				push af  
344d 3a 61 34			ld a, (.dmark)  
3450 32 6b ee			ld (debug_mark),a  
3453 3a 62 34			ld a, (.dmark+1)  
3456 32 6c ee			ld (debug_mark+1),a  
3459 3a 63 34			ld a, (.dmark+2)  
345c 32 6d ee			ld (debug_mark+2),a  
345f 18 03			jr .pastdmark  
3461 ..			.dmark: db "UNf"  
3464 f1			.pastdmark: pop af  
3465			endm  
# End of macro DMARK
3465						CALLMONITOR 
3465 cd 6f ee			call debug_vector  
3468				endm  
# End of macro CALLMONITOR
3468					endif 
3468			 
3468			 
3468			 
3468				FORTH_RSP_POP     ; get rid of DO ptr 
3468 cd 0e 1c			call macro_forth_rsp_pop 
346b				endm 
# End of macro FORTH_RSP_POP
346b			 
346b			if DEBUG_FORTH_WORDS 
346b						DMARK "UN>" 
346b f5				push af  
346c 3a 80 34			ld a, (.dmark)  
346f 32 6b ee			ld (debug_mark),a  
3472 3a 81 34			ld a, (.dmark+1)  
3475 32 6c ee			ld (debug_mark+1),a  
3478 3a 82 34			ld a, (.dmark+2)  
347b 32 6d ee			ld (debug_mark+2),a  
347e 18 03			jr .pastdmark  
3480 ..			.dmark: db "UN>"  
3483 f1			.pastdmark: pop af  
3484			endm  
# End of macro DMARK
3484				CALLMONITOR 
3484 cd 6f ee			call debug_vector  
3487				endm  
# End of macro CALLMONITOR
3487			endif 
3487			 
3487					NEXTW 
3487 c3 f3 1f			jp macro_next 
348a				endm 
# End of macro NEXTW
348a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
348a			 
348a			.untilnotdone: 
348a			 
348a			 
348a			;	; get DO ptr 
348a			; 
348a				FORTH_RSP_TOS 
348a cd 04 1c			call macro_forth_rsp_tos 
348d				endm 
# End of macro FORTH_RSP_TOS
348d			 
348d				;push hl 
348d			 
348d				; not going to DO any more 
348d				; get rid of the RSP pointer as DO will add it back in 
348d				;FORTH_RSP_POP 
348d				;pop hl 
348d			 
348d			 
348d 22 c2 e5			ld (os_tok_ptr), hl 
3490					if DEBUG_FORTH_WORDS 
3490						DMARK "UN<" 
3490 f5				push af  
3491 3a a5 34			ld a, (.dmark)  
3494 32 6b ee			ld (debug_mark),a  
3497 3a a6 34			ld a, (.dmark+1)  
349a 32 6c ee			ld (debug_mark+1),a  
349d 3a a7 34			ld a, (.dmark+2)  
34a0 32 6d ee			ld (debug_mark+2),a  
34a3 18 03			jr .pastdmark  
34a5 ..			.dmark: db "UN<"  
34a8 f1			.pastdmark: pop af  
34a9			endm  
# End of macro DMARK
34a9					CALLMONITOR 
34a9 cd 6f ee			call debug_vector  
34ac				endm  
# End of macro CALLMONITOR
34ac				endif 
34ac c3 84 20			jp exec1 
34af			 
34af					 
34af			 
34af			 
34af					NEXTW 
34af c3 f3 1f			jp macro_next 
34b2				endm 
# End of macro NEXTW
34b2			 
34b2			 
34b2			.ENDFLOW: 
34b2			 
34b2			; eof 
34b2			 
# End of file forth_words_flow.asm
34b2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34b2			include "forth_words_logic.asm" 
34b2			 
34b2			; | ## Logic Words 
34b2			 
34b2			.NOT: 
34b2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34b2 2d				db WORD_SYS_CORE+25             
34b3 fa 34			dw .IS            
34b5 04				db 3 + 1 
34b6 .. 00			db "NOT",0              
34ba				endm 
# End of macro CWHEAD
34ba			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34ba					if DEBUG_FORTH_WORDS_KEY 
34ba						DMARK "NOT" 
34ba f5				push af  
34bb 3a cf 34			ld a, (.dmark)  
34be 32 6b ee			ld (debug_mark),a  
34c1 3a d0 34			ld a, (.dmark+1)  
34c4 32 6c ee			ld (debug_mark+1),a  
34c7 3a d1 34			ld a, (.dmark+2)  
34ca 32 6d ee			ld (debug_mark+2),a  
34cd 18 03			jr .pastdmark  
34cf ..			.dmark: db "NOT"  
34d2 f1			.pastdmark: pop af  
34d3			endm  
# End of macro DMARK
34d3						CALLMONITOR 
34d3 cd 6f ee			call debug_vector  
34d6				endm  
# End of macro CALLMONITOR
34d6					endif 
34d6					FORTH_DSP 
34d6 cd 03 1e			call macro_forth_dsp 
34d9				endm 
# End of macro FORTH_DSP
34d9 7e					ld a,(hl)	; get type of value on TOS 
34da fe 02				cp DS_TYPE_INUM  
34dc 28 03				jr z, .noti 
34de					NEXTW 
34de c3 f3 1f			jp macro_next 
34e1				endm 
# End of macro NEXTW
34e1			.noti:          FORTH_DSP_VALUEHL 
34e1 cd 3d 1e			call macro_dsp_valuehl 
34e4				endm 
# End of macro FORTH_DSP_VALUEHL
34e4			;		push hl 
34e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34e4 cd f5 1e			call macro_forth_dsp_pop 
34e7				endm 
# End of macro FORTH_DSP_POP
34e7			;		pop hl 
34e7 3e 00				ld a,0 
34e9 bd					cp l 
34ea 28 04				jr z, .not2t 
34ec 2e 00				ld l, 0 
34ee 18 02				jr .notip 
34f0			 
34f0 2e ff		.not2t:		ld l, 255 
34f2			 
34f2 26 00		.notip:		ld h, 0	 
34f4			 
34f4 cd 46 1c				call forth_push_numhl 
34f7					NEXTW 
34f7 c3 f3 1f			jp macro_next 
34fa				endm 
# End of macro NEXTW
34fa			 
34fa			.IS: 
34fa				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34fa 2d				db WORD_SYS_CORE+25             
34fb 20 35			dw .LZERO            
34fd 03				db 2 + 1 
34fe .. 00			db "IS",0              
3501				endm 
# End of macro CWHEAD
3501			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3501					if DEBUG_FORTH_WORDS_KEY 
3501						DMARK "IS." 
3501 f5				push af  
3502 3a 16 35			ld a, (.dmark)  
3505 32 6b ee			ld (debug_mark),a  
3508 3a 17 35			ld a, (.dmark+1)  
350b 32 6c ee			ld (debug_mark+1),a  
350e 3a 18 35			ld a, (.dmark+2)  
3511 32 6d ee			ld (debug_mark+2),a  
3514 18 03			jr .pastdmark  
3516 ..			.dmark: db "IS."  
3519 f1			.pastdmark: pop af  
351a			endm  
# End of macro DMARK
351a						CALLMONITOR 
351a cd 6f ee			call debug_vector  
351d				endm  
# End of macro CALLMONITOR
351d					endif 
351d					NEXTW 
351d c3 f3 1f			jp macro_next 
3520				endm 
# End of macro NEXTW
3520			.LZERO: 
3520				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3520 2d				db WORD_SYS_CORE+25             
3521 2a 35			dw .TZERO            
3523 03				db 2 + 1 
3524 .. 00			db "0<",0              
3527				endm 
# End of macro CWHEAD
3527			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3527					NEXTW 
3527 c3 f3 1f			jp macro_next 
352a				endm 
# End of macro NEXTW
352a			.TZERO: 
352a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
352a 2e				db WORD_SYS_CORE+26             
352b 71 35			dw .LESS            
352d 03				db 2 + 1 
352e .. 00			db "0=",0              
3531				endm 
# End of macro CWHEAD
3531			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3531				; TODO add floating point number detection 
3531					;v5 FORTH_DSP_VALUE 
3531					if DEBUG_FORTH_WORDS_KEY 
3531						DMARK "0=." 
3531 f5				push af  
3532 3a 46 35			ld a, (.dmark)  
3535 32 6b ee			ld (debug_mark),a  
3538 3a 47 35			ld a, (.dmark+1)  
353b 32 6c ee			ld (debug_mark+1),a  
353e 3a 48 35			ld a, (.dmark+2)  
3541 32 6d ee			ld (debug_mark+2),a  
3544 18 03			jr .pastdmark  
3546 ..			.dmark: db "0=."  
3549 f1			.pastdmark: pop af  
354a			endm  
# End of macro DMARK
354a						CALLMONITOR 
354a cd 6f ee			call debug_vector  
354d				endm  
# End of macro CALLMONITOR
354d					endif 
354d					FORTH_DSP 
354d cd 03 1e			call macro_forth_dsp 
3550				endm 
# End of macro FORTH_DSP
3550 7e					ld a,(hl)	; get type of value on TOS 
3551 fe 02				cp DS_TYPE_INUM  
3553 28 00				jr z, .tz_inum 
3555			 
3555				if FORTH_ENABLE_FLOATMATH 
3555					jr .tz_done 
3555			 
3555				endif 
3555					 
3555			 
3555			.tz_inum: 
3555					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3555 cd 3d 1e			call macro_dsp_valuehl 
3558				endm 
# End of macro FORTH_DSP_VALUEHL
3558			 
3558			;		push hl 
3558			 
3558					; destroy value TOS 
3558			 
3558					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3558 cd f5 1e			call macro_forth_dsp_pop 
355b				endm 
# End of macro FORTH_DSP_POP
355b			 
355b			;		pop hl 
355b			 
355b 3e 00				ld a,0 
355d			 
355d bd					cp l 
355e 20 08				jr nz, .tz_notzero 
3560			 
3560 bc					cp h 
3561			 
3561 20 05				jr nz, .tz_notzero 
3563			 
3563			 
3563 21 01 00				ld hl, FORTH_TRUE 
3566 18 03				jr .tz_done 
3568			 
3568 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
356b			 
356b					; push value back onto stack for another op etc 
356b			 
356b			.tz_done: 
356b cd 46 1c				call forth_push_numhl 
356e			 
356e					NEXTW 
356e c3 f3 1f			jp macro_next 
3571				endm 
# End of macro NEXTW
3571			.LESS: 
3571				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3571 2f				db WORD_SYS_CORE+27             
3572 da 35			dw .GT            
3574 02				db 1 + 1 
3575 .. 00			db "<",0              
3577				endm 
# End of macro CWHEAD
3577			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3577				; TODO add floating point number detection 
3577					if DEBUG_FORTH_WORDS_KEY 
3577						DMARK "LES" 
3577 f5				push af  
3578 3a 8c 35			ld a, (.dmark)  
357b 32 6b ee			ld (debug_mark),a  
357e 3a 8d 35			ld a, (.dmark+1)  
3581 32 6c ee			ld (debug_mark+1),a  
3584 3a 8e 35			ld a, (.dmark+2)  
3587 32 6d ee			ld (debug_mark+2),a  
358a 18 03			jr .pastdmark  
358c ..			.dmark: db "LES"  
358f f1			.pastdmark: pop af  
3590			endm  
# End of macro DMARK
3590						CALLMONITOR 
3590 cd 6f ee			call debug_vector  
3593				endm  
# End of macro CALLMONITOR
3593					endif 
3593					FORTH_DSP 
3593 cd 03 1e			call macro_forth_dsp 
3596				endm 
# End of macro FORTH_DSP
3596					;v5 FORTH_DSP_VALUE 
3596 7e					ld a,(hl)	; get type of value on TOS 
3597 fe 02				cp DS_TYPE_INUM  
3599 28 00				jr z, .less_inum 
359b			 
359b				if FORTH_ENABLE_FLOATMATH 
359b					jr .less_done 
359b			 
359b				endif 
359b					 
359b			 
359b			.less_inum: 
359b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359b cd 3d 1e			call macro_dsp_valuehl 
359e				endm 
# End of macro FORTH_DSP_VALUEHL
359e			 
359e e5					push hl  ; u2 
359f			 
359f					; destroy value TOS 
359f			 
359f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359f cd f5 1e			call macro_forth_dsp_pop 
35a2				endm 
# End of macro FORTH_DSP_POP
35a2			 
35a2			 
35a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a2 cd 3d 1e			call macro_dsp_valuehl 
35a5				endm 
# End of macro FORTH_DSP_VALUEHL
35a5			 
35a5 e5					push hl    ; u1 
35a6			 
35a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a6 cd f5 1e			call macro_forth_dsp_pop 
35a9				endm 
# End of macro FORTH_DSP_POP
35a9			 
35a9			 
35a9 b7			 or a      ;clear carry flag 
35aa 01 00 00		 ld bc, FORTH_FALSE 
35ad e1			  pop hl    ; u1 
35ae d1			  pop de    ; u2 
35af ed 52		  sbc hl,de 
35b1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35b3			 
35b3 01 01 00		 ld bc, FORTH_TRUE 
35b6			.lscont:  
35b6 c5					push bc 
35b7 e1					pop hl 
35b8			 
35b8					if DEBUG_FORTH_WORDS 
35b8						DMARK "LT1" 
35b8 f5				push af  
35b9 3a cd 35			ld a, (.dmark)  
35bc 32 6b ee			ld (debug_mark),a  
35bf 3a ce 35			ld a, (.dmark+1)  
35c2 32 6c ee			ld (debug_mark+1),a  
35c5 3a cf 35			ld a, (.dmark+2)  
35c8 32 6d ee			ld (debug_mark+2),a  
35cb 18 03			jr .pastdmark  
35cd ..			.dmark: db "LT1"  
35d0 f1			.pastdmark: pop af  
35d1			endm  
# End of macro DMARK
35d1						CALLMONITOR 
35d1 cd 6f ee			call debug_vector  
35d4				endm  
# End of macro CALLMONITOR
35d4					endif 
35d4 cd 46 1c				call forth_push_numhl 
35d7			 
35d7					NEXTW 
35d7 c3 f3 1f			jp macro_next 
35da				endm 
# End of macro NEXTW
35da			.GT: 
35da				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35da 30				db WORD_SYS_CORE+28             
35db 43 36			dw .EQUAL            
35dd 02				db 1 + 1 
35de .. 00			db ">",0              
35e0				endm 
# End of macro CWHEAD
35e0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35e0				; TODO add floating point number detection 
35e0					if DEBUG_FORTH_WORDS_KEY 
35e0						DMARK "GRT" 
35e0 f5				push af  
35e1 3a f5 35			ld a, (.dmark)  
35e4 32 6b ee			ld (debug_mark),a  
35e7 3a f6 35			ld a, (.dmark+1)  
35ea 32 6c ee			ld (debug_mark+1),a  
35ed 3a f7 35			ld a, (.dmark+2)  
35f0 32 6d ee			ld (debug_mark+2),a  
35f3 18 03			jr .pastdmark  
35f5 ..			.dmark: db "GRT"  
35f8 f1			.pastdmark: pop af  
35f9			endm  
# End of macro DMARK
35f9						CALLMONITOR 
35f9 cd 6f ee			call debug_vector  
35fc				endm  
# End of macro CALLMONITOR
35fc					endif 
35fc					FORTH_DSP 
35fc cd 03 1e			call macro_forth_dsp 
35ff				endm 
# End of macro FORTH_DSP
35ff					;FORTH_DSP_VALUE 
35ff 7e					ld a,(hl)	; get type of value on TOS 
3600 fe 02				cp DS_TYPE_INUM  
3602 28 00				jr z, .gt_inum 
3604			 
3604				if FORTH_ENABLE_FLOATMATH 
3604					jr .gt_done 
3604			 
3604				endif 
3604					 
3604			 
3604			.gt_inum: 
3604					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3604 cd 3d 1e			call macro_dsp_valuehl 
3607				endm 
# End of macro FORTH_DSP_VALUEHL
3607			 
3607 e5					push hl  ; u2 
3608			 
3608					; destroy value TOS 
3608			 
3608					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3608 cd f5 1e			call macro_forth_dsp_pop 
360b				endm 
# End of macro FORTH_DSP_POP
360b			 
360b			 
360b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
360b cd 3d 1e			call macro_dsp_valuehl 
360e				endm 
# End of macro FORTH_DSP_VALUEHL
360e			 
360e e5					push hl    ; u1 
360f			 
360f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360f cd f5 1e			call macro_forth_dsp_pop 
3612				endm 
# End of macro FORTH_DSP_POP
3612			 
3612			 
3612 b7			 or a      ;clear carry flag 
3613 01 00 00		 ld bc, FORTH_FALSE 
3616 e1			  pop hl    ; u1 
3617 d1			  pop de    ; u2 
3618 ed 52		  sbc hl,de 
361a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
361c			 
361c 01 01 00		 ld bc, FORTH_TRUE 
361f			.gtcont:  
361f c5					push bc 
3620 e1					pop hl 
3621			 
3621					if DEBUG_FORTH_WORDS 
3621						DMARK "GT1" 
3621 f5				push af  
3622 3a 36 36			ld a, (.dmark)  
3625 32 6b ee			ld (debug_mark),a  
3628 3a 37 36			ld a, (.dmark+1)  
362b 32 6c ee			ld (debug_mark+1),a  
362e 3a 38 36			ld a, (.dmark+2)  
3631 32 6d ee			ld (debug_mark+2),a  
3634 18 03			jr .pastdmark  
3636 ..			.dmark: db "GT1"  
3639 f1			.pastdmark: pop af  
363a			endm  
# End of macro DMARK
363a						CALLMONITOR 
363a cd 6f ee			call debug_vector  
363d				endm  
# End of macro CALLMONITOR
363d					endif 
363d cd 46 1c				call forth_push_numhl 
3640			 
3640					NEXTW 
3640 c3 f3 1f			jp macro_next 
3643				endm 
# End of macro NEXTW
3643			.EQUAL: 
3643				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3643 31				db WORD_SYS_CORE+29             
3644 ae 36			dw .ENDLOGIC            
3646 02				db 1 + 1 
3647 .. 00			db "=",0              
3649				endm 
# End of macro CWHEAD
3649			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3649				; TODO add floating point number detection 
3649					if DEBUG_FORTH_WORDS_KEY 
3649						DMARK "EQ." 
3649 f5				push af  
364a 3a 5e 36			ld a, (.dmark)  
364d 32 6b ee			ld (debug_mark),a  
3650 3a 5f 36			ld a, (.dmark+1)  
3653 32 6c ee			ld (debug_mark+1),a  
3656 3a 60 36			ld a, (.dmark+2)  
3659 32 6d ee			ld (debug_mark+2),a  
365c 18 03			jr .pastdmark  
365e ..			.dmark: db "EQ."  
3661 f1			.pastdmark: pop af  
3662			endm  
# End of macro DMARK
3662						CALLMONITOR 
3662 cd 6f ee			call debug_vector  
3665				endm  
# End of macro CALLMONITOR
3665					endif 
3665					FORTH_DSP 
3665 cd 03 1e			call macro_forth_dsp 
3668				endm 
# End of macro FORTH_DSP
3668					;v5 FORTH_DSP_VALUE 
3668 7e					ld a,(hl)	; get type of value on TOS 
3669 fe 02				cp DS_TYPE_INUM  
366b 28 00				jr z, .eq_inum 
366d			 
366d				if FORTH_ENABLE_FLOATMATH 
366d					jr .eq_done 
366d			 
366d				endif 
366d					 
366d			 
366d			.eq_inum: 
366d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366d cd 3d 1e			call macro_dsp_valuehl 
3670				endm 
# End of macro FORTH_DSP_VALUEHL
3670			 
3670 e5					push hl 
3671			 
3671					; destroy value TOS 
3671			 
3671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3671 cd f5 1e			call macro_forth_dsp_pop 
3674				endm 
# End of macro FORTH_DSP_POP
3674			 
3674			 
3674					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3674 cd 3d 1e			call macro_dsp_valuehl 
3677				endm 
# End of macro FORTH_DSP_VALUEHL
3677			 
3677					; one value on hl get other one back 
3677			 
3677 e5					push hl 
3678			 
3678					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3678 cd f5 1e			call macro_forth_dsp_pop 
367b				endm 
# End of macro FORTH_DSP_POP
367b			 
367b 0e 00				ld c, FORTH_FALSE 
367d			 
367d e1					pop hl 
367e d1					pop de 
367f			 
367f 7b					ld a, e 
3680 bd					cp l 
3681			 
3681 20 06				jr nz, .eq_done 
3683			 
3683 7a					ld a, d 
3684 bc					cp h 
3685			 
3685 20 02				jr nz, .eq_done 
3687			 
3687 0e 01				ld c, FORTH_TRUE 
3689					 
3689			 
3689			 
3689			.eq_done: 
3689			 
3689					; TODO push value back onto stack for another op etc 
3689			 
3689 26 00				ld h, 0 
368b 69					ld l, c 
368c					if DEBUG_FORTH_WORDS 
368c						DMARK "EQ1" 
368c f5				push af  
368d 3a a1 36			ld a, (.dmark)  
3690 32 6b ee			ld (debug_mark),a  
3693 3a a2 36			ld a, (.dmark+1)  
3696 32 6c ee			ld (debug_mark+1),a  
3699 3a a3 36			ld a, (.dmark+2)  
369c 32 6d ee			ld (debug_mark+2),a  
369f 18 03			jr .pastdmark  
36a1 ..			.dmark: db "EQ1"  
36a4 f1			.pastdmark: pop af  
36a5			endm  
# End of macro DMARK
36a5						CALLMONITOR 
36a5 cd 6f ee			call debug_vector  
36a8				endm  
# End of macro CALLMONITOR
36a8					endif 
36a8 cd 46 1c				call forth_push_numhl 
36ab			 
36ab					NEXTW 
36ab c3 f3 1f			jp macro_next 
36ae				endm 
# End of macro NEXTW
36ae			 
36ae			 
36ae			.ENDLOGIC: 
36ae			; eof 
36ae			 
36ae			 
# End of file forth_words_logic.asm
36ae			include "forth_words_maths.asm" 
36ae			 
36ae			; | ## Maths Words 
36ae			 
36ae			.PLUS:	 
36ae				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36ae 15				db WORD_SYS_CORE+1             
36af 0c 37			dw .NEG            
36b1 02				db 1 + 1 
36b2 .. 00			db "+",0              
36b4				endm 
# End of macro CWHEAD
36b4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36b4					if DEBUG_FORTH_WORDS_KEY 
36b4						DMARK "PLU" 
36b4 f5				push af  
36b5 3a c9 36			ld a, (.dmark)  
36b8 32 6b ee			ld (debug_mark),a  
36bb 3a ca 36			ld a, (.dmark+1)  
36be 32 6c ee			ld (debug_mark+1),a  
36c1 3a cb 36			ld a, (.dmark+2)  
36c4 32 6d ee			ld (debug_mark+2),a  
36c7 18 03			jr .pastdmark  
36c9 ..			.dmark: db "PLU"  
36cc f1			.pastdmark: pop af  
36cd			endm  
# End of macro DMARK
36cd						CALLMONITOR 
36cd cd 6f ee			call debug_vector  
36d0				endm  
# End of macro CALLMONITOR
36d0					endif 
36d0					; add top two values and push back result 
36d0			 
36d0					;for v5 FORTH_DSP_VALUE 
36d0					FORTH_DSP 
36d0 cd 03 1e			call macro_forth_dsp 
36d3				endm 
# End of macro FORTH_DSP
36d3 7e					ld a,(hl)	; get type of value on TOS 
36d4 fe 02				cp DS_TYPE_INUM  
36d6 28 03				jr z, .dot_inum 
36d8			 
36d8					NEXTW 
36d8 c3 f3 1f			jp macro_next 
36db				endm 
# End of macro NEXTW
36db			 
36db			; float maths 
36db			 
36db				if FORTH_ENABLE_FLOATMATH 
36db						inc hl      ; now at start of numeric as string 
36db			 
36db					if DEBUG_FORTH_MATHS 
36db						DMARK "ADD" 
36db				CALLMONITOR 
36db					endif 
36db			 
36db					;ld ix, hl 
36db					call CON 
36db			 
36db			 
36db					push hl 
36db					 
36db					 
36db			 
36db						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36db			 
36db					; get next number 
36db			 
36db						FORTH_DSP_VALUE 
36db			 
36db						inc hl      ; now at start of numeric as string 
36db			 
36db					;ld ix, hl 
36db					call CON 
36db			 
36db					push hl 
36db			 
36db			 
36db						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36db			 
36db						; TODO do add 
36db			 
36db						call IADD 
36db			 
36db						; TODO get result back as ascii 
36db			 
36db						; TODO push result  
36db			 
36db			 
36db			 
36db						jr .dot_done 
36db				endif 
36db			 
36db			.dot_inum: 
36db			 
36db			 
36db					if DEBUG_FORTH_DOT 
36db						DMARK "+IT" 
36db f5				push af  
36dc 3a f0 36			ld a, (.dmark)  
36df 32 6b ee			ld (debug_mark),a  
36e2 3a f1 36			ld a, (.dmark+1)  
36e5 32 6c ee			ld (debug_mark+1),a  
36e8 3a f2 36			ld a, (.dmark+2)  
36eb 32 6d ee			ld (debug_mark+2),a  
36ee 18 03			jr .pastdmark  
36f0 ..			.dmark: db "+IT"  
36f3 f1			.pastdmark: pop af  
36f4			endm  
# End of macro DMARK
36f4				CALLMONITOR 
36f4 cd 6f ee			call debug_vector  
36f7				endm  
# End of macro CALLMONITOR
36f7					endif 
36f7			 
36f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f7 cd 3d 1e			call macro_dsp_valuehl 
36fa				endm 
# End of macro FORTH_DSP_VALUEHL
36fa			 
36fa				; TODO add floating point number detection 
36fa			 
36fa e5					push hl 
36fb			 
36fb					; destroy value TOS 
36fb			 
36fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fb cd f5 1e			call macro_forth_dsp_pop 
36fe				endm 
# End of macro FORTH_DSP_POP
36fe			 
36fe			 
36fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fe cd 3d 1e			call macro_dsp_valuehl 
3701				endm 
# End of macro FORTH_DSP_VALUEHL
3701			 
3701					; one value on hl get other one back 
3701			 
3701 d1					pop de 
3702			 
3702					; do the add 
3702			 
3702 19					add hl,de 
3703			 
3703					; save it 
3703			 
3703			;		push hl	 
3703			 
3703					; 
3703			 
3703					; destroy value TOS 
3703			 
3703					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3703 cd f5 1e			call macro_forth_dsp_pop 
3706				endm 
# End of macro FORTH_DSP_POP
3706			 
3706					; TODO push value back onto stack for another op etc 
3706			 
3706			;		pop hl 
3706			 
3706			.dot_done: 
3706 cd 46 1c				call forth_push_numhl 
3709			 
3709					NEXTW 
3709 c3 f3 1f			jp macro_next 
370c				endm 
# End of macro NEXTW
370c			.NEG: 
370c			 
370c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
370c 17				db WORD_SYS_CORE+3             
370d 4f 37			dw .DIV            
370f 02				db 1 + 1 
3710 .. 00			db "-",0              
3712				endm 
# End of macro CWHEAD
3712			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3712					if DEBUG_FORTH_WORDS_KEY 
3712						DMARK "SUB" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 6b ee			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 6c ee			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 6d ee			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "SUB"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b						CALLMONITOR 
372b cd 6f ee			call debug_vector  
372e				endm  
# End of macro CALLMONITOR
372e					endif 
372e			 
372e			 
372e				; TODO add floating point number detection 
372e					; v5 FORTH_DSP_VALUE 
372e					FORTH_DSP 
372e cd 03 1e			call macro_forth_dsp 
3731				endm 
# End of macro FORTH_DSP
3731 7e					ld a,(hl)	; get type of value on TOS 
3732 fe 02				cp DS_TYPE_INUM  
3734 28 03				jr z, .neg_inum 
3736			 
3736					NEXTW 
3736 c3 f3 1f			jp macro_next 
3739				endm 
# End of macro NEXTW
3739			 
3739			; float maths 
3739			 
3739				if FORTH_ENABLE_FLOATMATH 
3739					jr .neg_done 
3739			 
3739				endif 
3739					 
3739			 
3739			.neg_inum: 
3739					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3739 cd 3d 1e			call macro_dsp_valuehl 
373c				endm 
# End of macro FORTH_DSP_VALUEHL
373c			 
373c e5					push hl 
373d			 
373d					; destroy value TOS 
373d			 
373d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373d cd f5 1e			call macro_forth_dsp_pop 
3740				endm 
# End of macro FORTH_DSP_POP
3740			 
3740			 
3740					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3740 cd 3d 1e			call macro_dsp_valuehl 
3743				endm 
# End of macro FORTH_DSP_VALUEHL
3743			 
3743					; one value on hl get other one back 
3743			 
3743 d1					pop de 
3744			 
3744					; do the sub 
3744			;		ex de, hl 
3744			 
3744 ed 52				sbc hl,de 
3746			 
3746					; save it 
3746			 
3746			;		push hl	 
3746			 
3746					; 
3746			 
3746					; destroy value TOS 
3746			 
3746					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3746 cd f5 1e			call macro_forth_dsp_pop 
3749				endm 
# End of macro FORTH_DSP_POP
3749			 
3749					; TODO push value back onto stack for another op etc 
3749			 
3749			;		pop hl 
3749			 
3749 cd 46 1c				call forth_push_numhl 
374c			.neg_done: 
374c			 
374c					NEXTW 
374c c3 f3 1f			jp macro_next 
374f				endm 
# End of macro NEXTW
374f			.DIV: 
374f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
374f 18				db WORD_SYS_CORE+4             
3750 9c 37			dw .MUL            
3752 02				db 1 + 1 
3753 .. 00			db "/",0              
3755				endm 
# End of macro CWHEAD
3755			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3755					if DEBUG_FORTH_WORDS_KEY 
3755						DMARK "DIV" 
3755 f5				push af  
3756 3a 6a 37			ld a, (.dmark)  
3759 32 6b ee			ld (debug_mark),a  
375c 3a 6b 37			ld a, (.dmark+1)  
375f 32 6c ee			ld (debug_mark+1),a  
3762 3a 6c 37			ld a, (.dmark+2)  
3765 32 6d ee			ld (debug_mark+2),a  
3768 18 03			jr .pastdmark  
376a ..			.dmark: db "DIV"  
376d f1			.pastdmark: pop af  
376e			endm  
# End of macro DMARK
376e						CALLMONITOR 
376e cd 6f ee			call debug_vector  
3771				endm  
# End of macro CALLMONITOR
3771					endif 
3771				; TODO add floating point number detection 
3771					; v5 FORTH_DSP_VALUE 
3771					FORTH_DSP 
3771 cd 03 1e			call macro_forth_dsp 
3774				endm 
# End of macro FORTH_DSP
3774 7e					ld a,(hl)	; get type of value on TOS 
3775 fe 02				cp DS_TYPE_INUM  
3777 28 03				jr z, .div_inum 
3779			 
3779				if FORTH_ENABLE_FLOATMATH 
3779					jr .div_done 
3779			 
3779				endif 
3779					NEXTW 
3779 c3 f3 1f			jp macro_next 
377c				endm 
# End of macro NEXTW
377c			.div_inum: 
377c			 
377c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377c cd 3d 1e			call macro_dsp_valuehl 
377f				endm 
# End of macro FORTH_DSP_VALUEHL
377f			 
377f e5					push hl    ; to go to bc 
3780			 
3780					; destroy value TOS 
3780			 
3780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3780 cd f5 1e			call macro_forth_dsp_pop 
3783				endm 
# End of macro FORTH_DSP_POP
3783			 
3783			 
3783					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3783 cd 3d 1e			call macro_dsp_valuehl 
3786				endm 
# End of macro FORTH_DSP_VALUEHL
3786			 
3786					; hl to go to de 
3786			 
3786 e5					push hl 
3787			 
3787 c1					pop bc 
3788 d1					pop de		 
3789			 
3789			 
3789					if DEBUG_FORTH_MATHS 
3789						DMARK "DIV" 
3789				CALLMONITOR 
3789					endif 
3789					; one value on hl but move to a get other one back 
3789			 
3789			        
3789 cd 44 0d			call Div16 
378c			 
378c			;	push af	 
378c e5				push hl 
378d c5				push bc 
378e			 
378e					if DEBUG_FORTH_MATHS 
378e						DMARK "DI1" 
378e				CALLMONITOR 
378e					endif 
378e			 
378e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378e cd f5 1e			call macro_forth_dsp_pop 
3791				endm 
# End of macro FORTH_DSP_POP
3791			 
3791			 
3791			 
3791 e1					pop hl    ; result 
3792			 
3792 cd 46 1c				call forth_push_numhl 
3795			 
3795 e1					pop hl    ; reminder 
3796			;		ld h,0 
3796			;		ld l,d 
3796			 
3796 cd 46 1c				call forth_push_numhl 
3799			.div_done: 
3799					NEXTW 
3799 c3 f3 1f			jp macro_next 
379c				endm 
# End of macro NEXTW
379c			.MUL: 
379c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
379c 19				db WORD_SYS_CORE+5             
379d e1 37			dw .MIN            
379f 02				db 1 + 1 
37a0 .. 00			db "*",0              
37a2				endm 
# End of macro CWHEAD
37a2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37a2				; TODO add floating point number detection 
37a2					if DEBUG_FORTH_WORDS_KEY 
37a2						DMARK "MUL" 
37a2 f5				push af  
37a3 3a b7 37			ld a, (.dmark)  
37a6 32 6b ee			ld (debug_mark),a  
37a9 3a b8 37			ld a, (.dmark+1)  
37ac 32 6c ee			ld (debug_mark+1),a  
37af 3a b9 37			ld a, (.dmark+2)  
37b2 32 6d ee			ld (debug_mark+2),a  
37b5 18 03			jr .pastdmark  
37b7 ..			.dmark: db "MUL"  
37ba f1			.pastdmark: pop af  
37bb			endm  
# End of macro DMARK
37bb						CALLMONITOR 
37bb cd 6f ee			call debug_vector  
37be				endm  
# End of macro CALLMONITOR
37be					endif 
37be					FORTH_DSP 
37be cd 03 1e			call macro_forth_dsp 
37c1				endm 
# End of macro FORTH_DSP
37c1					; v5 FORTH_DSP_VALUE 
37c1 7e					ld a,(hl)	; get type of value on TOS 
37c2 fe 02				cp DS_TYPE_INUM  
37c4 28 03				jr z, .mul_inum 
37c6			 
37c6				if FORTH_ENABLE_FLOATMATH 
37c6					jr .mul_done 
37c6			 
37c6				endif 
37c6			 
37c6					NEXTW 
37c6 c3 f3 1f			jp macro_next 
37c9				endm 
# End of macro NEXTW
37c9			.mul_inum:	 
37c9			 
37c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c9 cd 3d 1e			call macro_dsp_valuehl 
37cc				endm 
# End of macro FORTH_DSP_VALUEHL
37cc			 
37cc e5					push hl 
37cd			 
37cd					; destroy value TOS 
37cd			 
37cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37cd cd f5 1e			call macro_forth_dsp_pop 
37d0				endm 
# End of macro FORTH_DSP_POP
37d0			 
37d0			 
37d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d0 cd 3d 1e			call macro_dsp_valuehl 
37d3				endm 
# End of macro FORTH_DSP_VALUEHL
37d3			 
37d3					; one value on hl but move to a get other one back 
37d3			 
37d3 7d					ld a, l 
37d4			 
37d4 d1					pop de 
37d5			 
37d5					; do the mull 
37d5			;		ex de, hl 
37d5			 
37d5 cd 6a 0d				call Mult16 
37d8					; save it 
37d8			 
37d8			;		push hl	 
37d8			 
37d8					; 
37d8			 
37d8					; destroy value TOS 
37d8			 
37d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d8 cd f5 1e			call macro_forth_dsp_pop 
37db				endm 
# End of macro FORTH_DSP_POP
37db			 
37db					; TODO push value back onto stack for another op etc 
37db			 
37db			;		pop hl 
37db			 
37db cd 46 1c				call forth_push_numhl 
37de			 
37de			.mul_done: 
37de					NEXTW 
37de c3 f3 1f			jp macro_next 
37e1				endm 
# End of macro NEXTW
37e1			 
37e1			 
37e1			 
37e1			 
37e1			.MIN: 
37e1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37e1 49				db WORD_SYS_CORE+53             
37e2 62 38			dw .MAX            
37e4 04				db 3 + 1 
37e5 .. 00			db "MIN",0              
37e9				endm 
# End of macro CWHEAD
37e9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37e9					if DEBUG_FORTH_WORDS_KEY 
37e9						DMARK "MIN" 
37e9 f5				push af  
37ea 3a fe 37			ld a, (.dmark)  
37ed 32 6b ee			ld (debug_mark),a  
37f0 3a ff 37			ld a, (.dmark+1)  
37f3 32 6c ee			ld (debug_mark+1),a  
37f6 3a 00 38			ld a, (.dmark+2)  
37f9 32 6d ee			ld (debug_mark+2),a  
37fc 18 03			jr .pastdmark  
37fe ..			.dmark: db "MIN"  
3801 f1			.pastdmark: pop af  
3802			endm  
# End of macro DMARK
3802						CALLMONITOR 
3802 cd 6f ee			call debug_vector  
3805				endm  
# End of macro CALLMONITOR
3805					endif 
3805					; get u2 
3805			 
3805					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3805 cd 3d 1e			call macro_dsp_valuehl 
3808				endm 
# End of macro FORTH_DSP_VALUEHL
3808			 
3808 e5					push hl   ; u2 
3809			 
3809					; destroy value TOS 
3809			 
3809					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3809 cd f5 1e			call macro_forth_dsp_pop 
380c				endm 
# End of macro FORTH_DSP_POP
380c			 
380c					; get u1 
380c			 
380c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380c cd 3d 1e			call macro_dsp_valuehl 
380f				endm 
# End of macro FORTH_DSP_VALUEHL
380f			 
380f e5					push hl  ; u1 
3810			 
3810					; destroy value TOS 
3810			 
3810					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3810 cd f5 1e			call macro_forth_dsp_pop 
3813				endm 
# End of macro FORTH_DSP_POP
3813			 
3813 b7			 or a      ;clear carry flag 
3814 e1			  pop hl    ; u1 
3815 d1			  pop de    ; u2 
3816 e5				push hl   ; saved in case hl is lowest 
3817 ed 52		  sbc hl,de 
3819 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
381b			 
381b e1				pop hl 
381c					if DEBUG_FORTH_WORDS 
381c						DMARK "MIN" 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 6b ee			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 6c ee			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 6d ee			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "MIN"  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd 6f ee			call debug_vector  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838 cd 46 1c				call forth_push_numhl 
383b			 
383b				       NEXTW 
383b c3 f3 1f			jp macro_next 
383e				endm 
# End of macro NEXTW
383e			 
383e			.mincont:  
383e c1				pop bc   ; tidy up 
383f eb				ex de , hl  
3840					if DEBUG_FORTH_WORDS 
3840						DMARK "MI1" 
3840 f5				push af  
3841 3a 55 38			ld a, (.dmark)  
3844 32 6b ee			ld (debug_mark),a  
3847 3a 56 38			ld a, (.dmark+1)  
384a 32 6c ee			ld (debug_mark+1),a  
384d 3a 57 38			ld a, (.dmark+2)  
3850 32 6d ee			ld (debug_mark+2),a  
3853 18 03			jr .pastdmark  
3855 ..			.dmark: db "MI1"  
3858 f1			.pastdmark: pop af  
3859			endm  
# End of macro DMARK
3859						CALLMONITOR 
3859 cd 6f ee			call debug_vector  
385c				endm  
# End of macro CALLMONITOR
385c					endif 
385c cd 46 1c				call forth_push_numhl 
385f			 
385f				       NEXTW 
385f c3 f3 1f			jp macro_next 
3862				endm 
# End of macro NEXTW
3862			.MAX: 
3862				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3862 4a				db WORD_SYS_CORE+54             
3863 e3 38			dw .RND16            
3865 04				db 3 + 1 
3866 .. 00			db "MAX",0              
386a				endm 
# End of macro CWHEAD
386a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
386a					if DEBUG_FORTH_WORDS_KEY 
386a						DMARK "MAX" 
386a f5				push af  
386b 3a 7f 38			ld a, (.dmark)  
386e 32 6b ee			ld (debug_mark),a  
3871 3a 80 38			ld a, (.dmark+1)  
3874 32 6c ee			ld (debug_mark+1),a  
3877 3a 81 38			ld a, (.dmark+2)  
387a 32 6d ee			ld (debug_mark+2),a  
387d 18 03			jr .pastdmark  
387f ..			.dmark: db "MAX"  
3882 f1			.pastdmark: pop af  
3883			endm  
# End of macro DMARK
3883						CALLMONITOR 
3883 cd 6f ee			call debug_vector  
3886				endm  
# End of macro CALLMONITOR
3886					endif 
3886					; get u2 
3886			 
3886					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3886 cd 3d 1e			call macro_dsp_valuehl 
3889				endm 
# End of macro FORTH_DSP_VALUEHL
3889			 
3889 e5					push hl   ; u2 
388a			 
388a					; destroy value TOS 
388a			 
388a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388a cd f5 1e			call macro_forth_dsp_pop 
388d				endm 
# End of macro FORTH_DSP_POP
388d			 
388d					; get u1 
388d			 
388d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
388d cd 3d 1e			call macro_dsp_valuehl 
3890				endm 
# End of macro FORTH_DSP_VALUEHL
3890			 
3890 e5					push hl  ; u1 
3891			 
3891					; destroy value TOS 
3891			 
3891					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3891 cd f5 1e			call macro_forth_dsp_pop 
3894				endm 
# End of macro FORTH_DSP_POP
3894			 
3894 b7			 or a      ;clear carry flag 
3895 e1			  pop hl    ; u1 
3896 d1			  pop de    ; u2 
3897 e5				push hl   ; saved in case hl is lowest 
3898 ed 52		  sbc hl,de 
389a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
389c			 
389c e1				pop hl 
389d					if DEBUG_FORTH_WORDS 
389d						DMARK "MAX" 
389d f5				push af  
389e 3a b2 38			ld a, (.dmark)  
38a1 32 6b ee			ld (debug_mark),a  
38a4 3a b3 38			ld a, (.dmark+1)  
38a7 32 6c ee			ld (debug_mark+1),a  
38aa 3a b4 38			ld a, (.dmark+2)  
38ad 32 6d ee			ld (debug_mark+2),a  
38b0 18 03			jr .pastdmark  
38b2 ..			.dmark: db "MAX"  
38b5 f1			.pastdmark: pop af  
38b6			endm  
# End of macro DMARK
38b6						CALLMONITOR 
38b6 cd 6f ee			call debug_vector  
38b9				endm  
# End of macro CALLMONITOR
38b9					endif 
38b9 cd 46 1c				call forth_push_numhl 
38bc			 
38bc				       NEXTW 
38bc c3 f3 1f			jp macro_next 
38bf				endm 
# End of macro NEXTW
38bf			 
38bf			.maxcont:  
38bf c1				pop bc   ; tidy up 
38c0 eb				ex de , hl  
38c1					if DEBUG_FORTH_WORDS 
38c1						DMARK "MA1" 
38c1 f5				push af  
38c2 3a d6 38			ld a, (.dmark)  
38c5 32 6b ee			ld (debug_mark),a  
38c8 3a d7 38			ld a, (.dmark+1)  
38cb 32 6c ee			ld (debug_mark+1),a  
38ce 3a d8 38			ld a, (.dmark+2)  
38d1 32 6d ee			ld (debug_mark+2),a  
38d4 18 03			jr .pastdmark  
38d6 ..			.dmark: db "MA1"  
38d9 f1			.pastdmark: pop af  
38da			endm  
# End of macro DMARK
38da						CALLMONITOR 
38da cd 6f ee			call debug_vector  
38dd				endm  
# End of macro CALLMONITOR
38dd					endif 
38dd cd 46 1c				call forth_push_numhl 
38e0				       NEXTW 
38e0 c3 f3 1f			jp macro_next 
38e3				endm 
# End of macro NEXTW
38e3			 
38e3			.RND16: 
38e3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38e3 4e				db WORD_SYS_CORE+58             
38e4 12 39			dw .RND8            
38e6 06				db 5 + 1 
38e7 .. 00			db "RND16",0              
38ed				endm 
# End of macro CWHEAD
38ed			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38ed					if DEBUG_FORTH_WORDS_KEY 
38ed						DMARK "R16" 
38ed f5				push af  
38ee 3a 02 39			ld a, (.dmark)  
38f1 32 6b ee			ld (debug_mark),a  
38f4 3a 03 39			ld a, (.dmark+1)  
38f7 32 6c ee			ld (debug_mark+1),a  
38fa 3a 04 39			ld a, (.dmark+2)  
38fd 32 6d ee			ld (debug_mark+2),a  
3900 18 03			jr .pastdmark  
3902 ..			.dmark: db "R16"  
3905 f1			.pastdmark: pop af  
3906			endm  
# End of macro DMARK
3906						CALLMONITOR 
3906 cd 6f ee			call debug_vector  
3909				endm  
# End of macro CALLMONITOR
3909					endif 
3909 cd 0e 0d				call prng16  
390c cd 46 1c				call forth_push_numhl 
390f				       NEXTW 
390f c3 f3 1f			jp macro_next 
3912				endm 
# End of macro NEXTW
3912			.RND8: 
3912				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3912 60				db WORD_SYS_CORE+76             
3913 47 39			dw .RND            
3915 05				db 4 + 1 
3916 .. 00			db "RND8",0              
391b				endm 
# End of macro CWHEAD
391b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
391b					if DEBUG_FORTH_WORDS_KEY 
391b						DMARK "RN8" 
391b f5				push af  
391c 3a 30 39			ld a, (.dmark)  
391f 32 6b ee			ld (debug_mark),a  
3922 3a 31 39			ld a, (.dmark+1)  
3925 32 6c ee			ld (debug_mark+1),a  
3928 3a 32 39			ld a, (.dmark+2)  
392b 32 6d ee			ld (debug_mark+2),a  
392e 18 03			jr .pastdmark  
3930 ..			.dmark: db "RN8"  
3933 f1			.pastdmark: pop af  
3934			endm  
# End of macro DMARK
3934						CALLMONITOR 
3934 cd 6f ee			call debug_vector  
3937				endm  
# End of macro CALLMONITOR
3937					endif 
3937 2a a9 eb				ld hl,(xrandc) 
393a 23					inc hl 
393b cd 28 0d				call xrnd 
393e 6f					ld l,a	 
393f 26 00				ld h,0 
3941 cd 46 1c				call forth_push_numhl 
3944				       NEXTW 
3944 c3 f3 1f			jp macro_next 
3947				endm 
# End of macro NEXTW
3947			.RND: 
3947				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3947 60				db WORD_SYS_CORE+76             
3948 4d 3a			dw .ENDMATHS            
394a 04				db 3 + 1 
394b .. 00			db "RND",0              
394f				endm 
# End of macro CWHEAD
394f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
394f			 
394f					if DEBUG_FORTH_WORDS_KEY 
394f						DMARK "RND" 
394f f5				push af  
3950 3a 64 39			ld a, (.dmark)  
3953 32 6b ee			ld (debug_mark),a  
3956 3a 65 39			ld a, (.dmark+1)  
3959 32 6c ee			ld (debug_mark+1),a  
395c 3a 66 39			ld a, (.dmark+2)  
395f 32 6d ee			ld (debug_mark+2),a  
3962 18 03			jr .pastdmark  
3964 ..			.dmark: db "RND"  
3967 f1			.pastdmark: pop af  
3968			endm  
# End of macro DMARK
3968						CALLMONITOR 
3968 cd 6f ee			call debug_vector  
396b				endm  
# End of macro CALLMONITOR
396b					endif 
396b					 
396b					FORTH_DSP_VALUEHL    ; upper range 
396b cd 3d 1e			call macro_dsp_valuehl 
396e				endm 
# End of macro FORTH_DSP_VALUEHL
396e			 
396e 22 ad eb				ld (LFSRSeed), hl	 
3971			 
3971					if DEBUG_FORTH_WORDS 
3971						DMARK "RN1" 
3971 f5				push af  
3972 3a 86 39			ld a, (.dmark)  
3975 32 6b ee			ld (debug_mark),a  
3978 3a 87 39			ld a, (.dmark+1)  
397b 32 6c ee			ld (debug_mark+1),a  
397e 3a 88 39			ld a, (.dmark+2)  
3981 32 6d ee			ld (debug_mark+2),a  
3984 18 03			jr .pastdmark  
3986 ..			.dmark: db "RN1"  
3989 f1			.pastdmark: pop af  
398a			endm  
# End of macro DMARK
398a						CALLMONITOR 
398a cd 6f ee			call debug_vector  
398d				endm  
# End of macro CALLMONITOR
398d					endif 
398d					FORTH_DSP_POP 
398d cd f5 1e			call macro_forth_dsp_pop 
3990				endm 
# End of macro FORTH_DSP_POP
3990			 
3990					FORTH_DSP_VALUEHL    ; low range 
3990 cd 3d 1e			call macro_dsp_valuehl 
3993				endm 
# End of macro FORTH_DSP_VALUEHL
3993			 
3993					if DEBUG_FORTH_WORDS 
3993						DMARK "RN2" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 6b ee			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 6c ee			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 6d ee			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "RN2"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac						CALLMONITOR 
39ac cd 6f ee			call debug_vector  
39af				endm  
# End of macro CALLMONITOR
39af					endif 
39af 22 af eb				ld (LFSRSeed+2), hl 
39b2			 
39b2					FORTH_DSP_POP 
39b2 cd f5 1e			call macro_forth_dsp_pop 
39b5				endm 
# End of macro FORTH_DSP_POP
39b5			 
39b5 e5					push hl 
39b6			 
39b6 e1			.inrange:	pop hl 
39b7 cd 0e 0d				call prng16  
39ba					if DEBUG_FORTH_WORDS 
39ba						DMARK "RN3" 
39ba f5				push af  
39bb 3a cf 39			ld a, (.dmark)  
39be 32 6b ee			ld (debug_mark),a  
39c1 3a d0 39			ld a, (.dmark+1)  
39c4 32 6c ee			ld (debug_mark+1),a  
39c7 3a d1 39			ld a, (.dmark+2)  
39ca 32 6d ee			ld (debug_mark+2),a  
39cd 18 03			jr .pastdmark  
39cf ..			.dmark: db "RN3"  
39d2 f1			.pastdmark: pop af  
39d3			endm  
# End of macro DMARK
39d3						CALLMONITOR 
39d3 cd 6f ee			call debug_vector  
39d6				endm  
# End of macro CALLMONITOR
39d6					endif 
39d6					 
39d6					; if the range is 8bit knock out the high byte 
39d6			 
39d6 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
39da			 
39da 3e 00				ld a, 0 
39dc ba					cp d  
39dd 20 1e				jr nz, .hirange 
39df 26 00				ld h, 0   ; knock it down to 8bit 
39e1			 
39e1					if DEBUG_FORTH_WORDS 
39e1						DMARK "RNk" 
39e1 f5				push af  
39e2 3a f6 39			ld a, (.dmark)  
39e5 32 6b ee			ld (debug_mark),a  
39e8 3a f7 39			ld a, (.dmark+1)  
39eb 32 6c ee			ld (debug_mark+1),a  
39ee 3a f8 39			ld a, (.dmark+2)  
39f1 32 6d ee			ld (debug_mark+2),a  
39f4 18 03			jr .pastdmark  
39f6 ..			.dmark: db "RNk"  
39f9 f1			.pastdmark: pop af  
39fa			endm  
# End of macro DMARK
39fa						CALLMONITOR 
39fa cd 6f ee			call debug_vector  
39fd				endm  
# End of macro CALLMONITOR
39fd					endif 
39fd			.hirange:   
39fd e5					push hl  
39fe b7					or a  
39ff ed 52		                sbc hl, de 
3a01			 
3a01					;call cmp16 
3a01			 
3a01 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a03 e1					pop hl 
3a04 e5					push hl 
3a05			 
3a05					if DEBUG_FORTH_WORDS 
3a05						DMARK "RN4" 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 6b ee			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 6c ee			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 6d ee			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "RN4"  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd 6f ee			call debug_vector  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3a25					;call cmp16 
3a25				 
3a25 b7					or a  
3a26 ed 52		                sbc hl, de 
3a28 38 8c				jr c, .inrange 
3a2a			 
3a2a e1					pop hl 
3a2b					 
3a2b					if DEBUG_FORTH_WORDS 
3a2b						DMARK "RNd" 
3a2b f5				push af  
3a2c 3a 40 3a			ld a, (.dmark)  
3a2f 32 6b ee			ld (debug_mark),a  
3a32 3a 41 3a			ld a, (.dmark+1)  
3a35 32 6c ee			ld (debug_mark+1),a  
3a38 3a 42 3a			ld a, (.dmark+2)  
3a3b 32 6d ee			ld (debug_mark+2),a  
3a3e 18 03			jr .pastdmark  
3a40 ..			.dmark: db "RNd"  
3a43 f1			.pastdmark: pop af  
3a44			endm  
# End of macro DMARK
3a44						CALLMONITOR 
3a44 cd 6f ee			call debug_vector  
3a47				endm  
# End of macro CALLMONITOR
3a47					endif 
3a47			 
3a47			 
3a47 cd 46 1c				call forth_push_numhl 
3a4a				       NEXTW 
3a4a c3 f3 1f			jp macro_next 
3a4d				endm 
# End of macro NEXTW
3a4d			 
3a4d			.ENDMATHS: 
3a4d			 
3a4d			; eof 
3a4d			 
# End of file forth_words_maths.asm
3a4d			include "forth_words_display.asm" 
3a4d			 
3a4d			; | ## Display Words 
3a4d			 
3a4d			.ACT: 
3a4d			 
3a4d				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a4d 62				db WORD_SYS_CORE+78             
3a4e 99 3a			dw .INFO            
3a50 07				db 6 + 1 
3a51 .. 00			db "ACTIVE",0              
3a58				endm 
# End of macro CWHEAD
3a58			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a58			;  
3a58			; | | e.g. $ff $00 do active . $01 pause loop 
3a58			 
3a58					if DEBUG_FORTH_WORDS_KEY 
3a58						DMARK "ACT" 
3a58 f5				push af  
3a59 3a 6d 3a			ld a, (.dmark)  
3a5c 32 6b ee			ld (debug_mark),a  
3a5f 3a 6e 3a			ld a, (.dmark+1)  
3a62 32 6c ee			ld (debug_mark+1),a  
3a65 3a 6f 3a			ld a, (.dmark+2)  
3a68 32 6d ee			ld (debug_mark+2),a  
3a6b 18 03			jr .pastdmark  
3a6d ..			.dmark: db "ACT"  
3a70 f1			.pastdmark: pop af  
3a71			endm  
# End of macro DMARK
3a71						CALLMONITOR 
3a71 cd 6f ee			call debug_vector  
3a74				endm  
# End of macro CALLMONITOR
3a74					endif 
3a74 cd 11 0b				call active 
3a77					if DEBUG_FORTH_WORDS 
3a77						DMARK "ACp" 
3a77 f5				push af  
3a78 3a 8c 3a			ld a, (.dmark)  
3a7b 32 6b ee			ld (debug_mark),a  
3a7e 3a 8d 3a			ld a, (.dmark+1)  
3a81 32 6c ee			ld (debug_mark+1),a  
3a84 3a 8e 3a			ld a, (.dmark+2)  
3a87 32 6d ee			ld (debug_mark+2),a  
3a8a 18 03			jr .pastdmark  
3a8c ..			.dmark: db "ACp"  
3a8f f1			.pastdmark: pop af  
3a90			endm  
# End of macro DMARK
3a90						CALLMONITOR 
3a90 cd 6f ee			call debug_vector  
3a93				endm  
# End of macro CALLMONITOR
3a93					endif 
3a93 cd b4 1c				call forth_push_str 
3a96			 
3a96					NEXTW 
3a96 c3 f3 1f			jp macro_next 
3a99				endm 
# End of macro NEXTW
3a99			.INFO: 
3a99			 
3a99				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a99 62				db WORD_SYS_CORE+78             
3a9a b6 3a			dw .ATP            
3a9c 05				db 4 + 1 
3a9d .. 00			db "INFO",0              
3aa2				endm 
# End of macro CWHEAD
3aa2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3aa2					FORTH_DSP_VALUEHL 
3aa2 cd 3d 1e			call macro_dsp_valuehl 
3aa5				endm 
# End of macro FORTH_DSP_VALUEHL
3aa5			 
3aa5					FORTH_DSP_POP 
3aa5 cd f5 1e			call macro_forth_dsp_pop 
3aa8				endm 
# End of macro FORTH_DSP_POP
3aa8			 
3aa8 e5					push hl 
3aa9			 
3aa9					FORTH_DSP_VALUEHL 
3aa9 cd 3d 1e			call macro_dsp_valuehl 
3aac				endm 
# End of macro FORTH_DSP_VALUEHL
3aac			 
3aac					FORTH_DSP_POP 
3aac cd f5 1e			call macro_forth_dsp_pop 
3aaf				endm 
# End of macro FORTH_DSP_POP
3aaf			 
3aaf d1					pop de 
3ab0			 
3ab0 cd 4b 0b				call info_panel 
3ab3			 
3ab3			 
3ab3					NEXTW 
3ab3 c3 f3 1f			jp macro_next 
3ab6				endm 
# End of macro NEXTW
3ab6			.ATP: 
3ab6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ab6 62				db WORD_SYS_CORE+78             
3ab7 2d 3b			dw .FB            
3ab9 04				db 3 + 1 
3aba .. 00			db "AT?",0              
3abe				endm 
# End of macro CWHEAD
3abe			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3abe					if DEBUG_FORTH_WORDS_KEY 
3abe						DMARK "AT?" 
3abe f5				push af  
3abf 3a d3 3a			ld a, (.dmark)  
3ac2 32 6b ee			ld (debug_mark),a  
3ac5 3a d4 3a			ld a, (.dmark+1)  
3ac8 32 6c ee			ld (debug_mark+1),a  
3acb 3a d5 3a			ld a, (.dmark+2)  
3ace 32 6d ee			ld (debug_mark+2),a  
3ad1 18 03			jr .pastdmark  
3ad3 ..			.dmark: db "AT?"  
3ad6 f1			.pastdmark: pop af  
3ad7			endm  
# End of macro DMARK
3ad7						CALLMONITOR 
3ad7 cd 6f ee			call debug_vector  
3ada				endm  
# End of macro CALLMONITOR
3ada					endif 
3ada 3a 5e ea				ld a, (f_cursor_ptr) 
3add			 
3add			if DEBUG_FORTH_WORDS 
3add				DMARK "AT?" 
3add f5				push af  
3ade 3a f2 3a			ld a, (.dmark)  
3ae1 32 6b ee			ld (debug_mark),a  
3ae4 3a f3 3a			ld a, (.dmark+1)  
3ae7 32 6c ee			ld (debug_mark+1),a  
3aea 3a f4 3a			ld a, (.dmark+2)  
3aed 32 6d ee			ld (debug_mark+2),a  
3af0 18 03			jr .pastdmark  
3af2 ..			.dmark: db "AT?"  
3af5 f1			.pastdmark: pop af  
3af6			endm  
# End of macro DMARK
3af6				CALLMONITOR 
3af6 cd 6f ee			call debug_vector  
3af9				endm  
# End of macro CALLMONITOR
3af9			endif	 
3af9					; count the number of rows 
3af9			 
3af9 06 00				ld b, 0 
3afb 4f			.atpr:		ld c, a    ; save in case we go below zero 
3afc d6 28				sub display_cols 
3afe f2 04 3b				jp p, .atprunder 
3b01 04					inc b 
3b02 18 f7				jr .atpr 
3b04			.atprunder:	 
3b04			if DEBUG_FORTH_WORDS 
3b04				DMARK "A?2" 
3b04 f5				push af  
3b05 3a 19 3b			ld a, (.dmark)  
3b08 32 6b ee			ld (debug_mark),a  
3b0b 3a 1a 3b			ld a, (.dmark+1)  
3b0e 32 6c ee			ld (debug_mark+1),a  
3b11 3a 1b 3b			ld a, (.dmark+2)  
3b14 32 6d ee			ld (debug_mark+2),a  
3b17 18 03			jr .pastdmark  
3b19 ..			.dmark: db "A?2"  
3b1c f1			.pastdmark: pop af  
3b1d			endm  
# End of macro DMARK
3b1d				CALLMONITOR 
3b1d cd 6f ee			call debug_vector  
3b20				endm  
# End of macro CALLMONITOR
3b20			endif	 
3b20 26 00				ld h, 0 
3b22 69					ld l, c 
3b23 cd 46 1c				call forth_push_numhl 
3b26 68					ld l, b  
3b27 cd 46 1c				call forth_push_numhl 
3b2a			 
3b2a			 
3b2a				NEXTW 
3b2a c3 f3 1f			jp macro_next 
3b2d				endm 
# End of macro NEXTW
3b2d			 
3b2d			.FB: 
3b2d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b2d 1b				db WORD_SYS_CORE+7             
3b2e 7b 3b			dw .EMIT            
3b30 03				db 2 + 1 
3b31 .. 00			db "FB",0              
3b34				endm 
# End of macro CWHEAD
3b34			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b34			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b34			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b34			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b34					if DEBUG_FORTH_WORDS_KEY 
3b34						DMARK "FB." 
3b34 f5				push af  
3b35 3a 49 3b			ld a, (.dmark)  
3b38 32 6b ee			ld (debug_mark),a  
3b3b 3a 4a 3b			ld a, (.dmark+1)  
3b3e 32 6c ee			ld (debug_mark+1),a  
3b41 3a 4b 3b			ld a, (.dmark+2)  
3b44 32 6d ee			ld (debug_mark+2),a  
3b47 18 03			jr .pastdmark  
3b49 ..			.dmark: db "FB."  
3b4c f1			.pastdmark: pop af  
3b4d			endm  
# End of macro DMARK
3b4d						CALLMONITOR 
3b4d cd 6f ee			call debug_vector  
3b50				endm  
# End of macro CALLMONITOR
3b50					endif 
3b50			 
3b50					FORTH_DSP_VALUEHL 
3b50 cd 3d 1e			call macro_dsp_valuehl 
3b53				endm 
# End of macro FORTH_DSP_VALUEHL
3b53			 
3b53 7d					ld a, l 
3b54 fe 01				cp 1 
3b56 20 05				jr nz, .fbn1 
3b58 21 10 ed				ld hl, display_fb1 
3b5b 18 15				jr .fbset 
3b5d fe 02		.fbn1:		cp 2 
3b5f 20 05				jr nz, .fbn2 
3b61 21 ce eb				ld hl, display_fb2 
3b64 18 0c				jr .fbset 
3b66 fe 03		.fbn2:		cp 3 
3b68 20 05				jr nz, .fbn3 
3b6a 21 6f ec				ld hl, display_fb3 
3b6d 18 03				jr .fbset 
3b6f			.fbn3:		 ; if invalid number select first 
3b6f 21 10 ed				ld hl, display_fb1 
3b72 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b75			 
3b75					FORTH_DSP_POP 
3b75 cd f5 1e			call macro_forth_dsp_pop 
3b78				endm 
# End of macro FORTH_DSP_POP
3b78			 
3b78					NEXTW 
3b78 c3 f3 1f			jp macro_next 
3b7b				endm 
# End of macro NEXTW
3b7b			 
3b7b			 
3b7b			.EMIT: 
3b7b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b7b 1b				db WORD_SYS_CORE+7             
3b7c cc 3b			dw .DOTH            
3b7e 05				db 4 + 1 
3b7f .. 00			db "EMIT",0              
3b84				endm 
# End of macro CWHEAD
3b84			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b84					; get value off TOS and display it 
3b84			 
3b84					if DEBUG_FORTH_WORDS_KEY 
3b84						DMARK "EMT" 
3b84 f5				push af  
3b85 3a 99 3b			ld a, (.dmark)  
3b88 32 6b ee			ld (debug_mark),a  
3b8b 3a 9a 3b			ld a, (.dmark+1)  
3b8e 32 6c ee			ld (debug_mark+1),a  
3b91 3a 9b 3b			ld a, (.dmark+2)  
3b94 32 6d ee			ld (debug_mark+2),a  
3b97 18 03			jr .pastdmark  
3b99 ..			.dmark: db "EMT"  
3b9c f1			.pastdmark: pop af  
3b9d			endm  
# End of macro DMARK
3b9d						CALLMONITOR 
3b9d cd 6f ee			call debug_vector  
3ba0				endm  
# End of macro CALLMONITOR
3ba0					endif 
3ba0			 
3ba0					FORTH_DSP_VALUEHL 
3ba0 cd 3d 1e			call macro_dsp_valuehl 
3ba3				endm 
# End of macro FORTH_DSP_VALUEHL
3ba3			 
3ba3 7d					ld a,l 
3ba4			 
3ba4					; TODO write to display 
3ba4			 
3ba4 32 bf e4				ld (os_input), a 
3ba7 3e 00				ld a, 0 
3ba9 32 c0 e4				ld (os_input+1), a 
3bac					 
3bac 3a 5e ea				ld a, (f_cursor_ptr) 
3baf 11 bf e4				ld de, os_input 
3bb2 cd cd 0b				call str_at_display 
3bb5			 
3bb5			 
3bb5 3a 3c ea				ld a,(cli_autodisplay) 
3bb8 fe 00				cp 0 
3bba 28 03				jr z, .enoupdate 
3bbc cd dd 0b						call update_display 
3bbf					.enoupdate: 
3bbf			 
3bbf 3a 5e ea				ld a, (f_cursor_ptr) 
3bc2 3c					inc a 
3bc3 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3bc6			 
3bc6			 
3bc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc6 cd f5 1e			call macro_forth_dsp_pop 
3bc9				endm 
# End of macro FORTH_DSP_POP
3bc9			  
3bc9			 
3bc9					NEXTW 
3bc9 c3 f3 1f			jp macro_next 
3bcc				endm 
# End of macro NEXTW
3bcc			.DOTH: 
3bcc				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bcc 1c				db WORD_SYS_CORE+8             
3bcd fc 3b			dw .DOTF            
3bcf 03				db 2 + 1 
3bd0 .. 00			db ".-",0              
3bd3				endm 
# End of macro CWHEAD
3bd3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3bd3					; get value off TOS and display it 
3bd3					if DEBUG_FORTH_WORDS_KEY 
3bd3						DMARK "DTD" 
3bd3 f5				push af  
3bd4 3a e8 3b			ld a, (.dmark)  
3bd7 32 6b ee			ld (debug_mark),a  
3bda 3a e9 3b			ld a, (.dmark+1)  
3bdd 32 6c ee			ld (debug_mark+1),a  
3be0 3a ea 3b			ld a, (.dmark+2)  
3be3 32 6d ee			ld (debug_mark+2),a  
3be6 18 03			jr .pastdmark  
3be8 ..			.dmark: db "DTD"  
3beb f1			.pastdmark: pop af  
3bec			endm  
# End of macro DMARK
3bec						CALLMONITOR 
3bec cd 6f ee			call debug_vector  
3bef				endm  
# End of macro CALLMONITOR
3bef					endif 
3bef 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bf1 3e 00			ld a, 0 
3bf3 32 3d ea			ld (cli_mvdot), a 
3bf6 c3 53 3c			jp .dotgo 
3bf9				NEXTW 
3bf9 c3 f3 1f			jp macro_next 
3bfc				endm 
# End of macro NEXTW
3bfc			.DOTF: 
3bfc				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bfc 1c				db WORD_SYS_CORE+8             
3bfd 2a 3c			dw .DOT            
3bff 03				db 2 + 1 
3c00 .. 00			db ".>",0              
3c03				endm 
# End of macro CWHEAD
3c03			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c03					; get value off TOS and display it 
3c03			        ; TODO BUG adds extra spaces 
3c03			        ; TODO BUG handle numerics? 
3c03					if DEBUG_FORTH_WORDS_KEY 
3c03						DMARK "DTC" 
3c03 f5				push af  
3c04 3a 18 3c			ld a, (.dmark)  
3c07 32 6b ee			ld (debug_mark),a  
3c0a 3a 19 3c			ld a, (.dmark+1)  
3c0d 32 6c ee			ld (debug_mark+1),a  
3c10 3a 1a 3c			ld a, (.dmark+2)  
3c13 32 6d ee			ld (debug_mark+2),a  
3c16 18 03			jr .pastdmark  
3c18 ..			.dmark: db "DTC"  
3c1b f1			.pastdmark: pop af  
3c1c			endm  
# End of macro DMARK
3c1c						CALLMONITOR 
3c1c cd 6f ee			call debug_vector  
3c1f				endm  
# End of macro CALLMONITOR
3c1f					endif 
3c1f 3e 01			ld a, 1 
3c21 32 3d ea			ld (cli_mvdot), a 
3c24 c3 53 3c			jp .dotgo 
3c27				NEXTW 
3c27 c3 f3 1f			jp macro_next 
3c2a				endm 
# End of macro NEXTW
3c2a			 
3c2a			.DOT: 
3c2a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c2a 1c				db WORD_SYS_CORE+8             
3c2b 06 3e			dw .CLS            
3c2d 02				db 1 + 1 
3c2e .. 00			db ".",0              
3c30				endm 
# End of macro CWHEAD
3c30			        ; | . ( u -- ) Display TOS | DONE 
3c30					; get value off TOS and display it 
3c30			 
3c30					if DEBUG_FORTH_WORDS_KEY 
3c30						DMARK "DOT" 
3c30 f5				push af  
3c31 3a 45 3c			ld a, (.dmark)  
3c34 32 6b ee			ld (debug_mark),a  
3c37 3a 46 3c			ld a, (.dmark+1)  
3c3a 32 6c ee			ld (debug_mark+1),a  
3c3d 3a 47 3c			ld a, (.dmark+2)  
3c40 32 6d ee			ld (debug_mark+2),a  
3c43 18 03			jr .pastdmark  
3c45 ..			.dmark: db "DOT"  
3c48 f1			.pastdmark: pop af  
3c49			endm  
# End of macro DMARK
3c49						CALLMONITOR 
3c49 cd 6f ee			call debug_vector  
3c4c				endm  
# End of macro CALLMONITOR
3c4c					endif 
3c4c 3e 00			ld a, 0 
3c4e 32 3d ea			ld (cli_mvdot), a 
3c51 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c53				 
3c53			 
3c53			.dotgo: 
3c53			 
3c53			; move up type to on stack for parserv5 
3c53					FORTH_DSP 
3c53 cd 03 1e			call macro_forth_dsp 
3c56				endm 
# End of macro FORTH_DSP
3c56				;FORTH_DSP_VALUE  
3c56			 
3c56			if DEBUG_FORTH_DOT 
3c56				DMARK "DOT" 
3c56 f5				push af  
3c57 3a 6b 3c			ld a, (.dmark)  
3c5a 32 6b ee			ld (debug_mark),a  
3c5d 3a 6c 3c			ld a, (.dmark+1)  
3c60 32 6c ee			ld (debug_mark+1),a  
3c63 3a 6d 3c			ld a, (.dmark+2)  
3c66 32 6d ee			ld (debug_mark+2),a  
3c69 18 03			jr .pastdmark  
3c6b ..			.dmark: db "DOT"  
3c6e f1			.pastdmark: pop af  
3c6f			endm  
# End of macro DMARK
3c6f				CALLMONITOR 
3c6f cd 6f ee			call debug_vector  
3c72				endm  
# End of macro CALLMONITOR
3c72			endif	 
3c72			;		.print: 
3c72			 
3c72 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c73 23				inc hl   ; position to the actual value 
3c74 fe 01			cp DS_TYPE_STR 
3c76 20 06			jr nz, .dotnum1  
3c78			 
3c78			; display string 
3c78				FORTH_DSP_VALUE  
3c78 cd 26 1e			call macro_forth_dsp_value 
3c7b				endm 
# End of macro FORTH_DSP_VALUE
3c7b eb				ex de,hl 
3c7c 18 49			jr .dotwrite 
3c7e			 
3c7e			.dotnum1: 
3c7e fe 02			cp DS_TYPE_INUM 
3c80 20 44			jr nz, .dotflot 
3c82			 
3c82			 
3c82			; display number 
3c82			 
3c82			;	push hl 
3c82			;	call clear_display 
3c82			;	pop hl 
3c82			 
3c82 5e				ld e, (hl) 
3c83 23				inc hl 
3c84 56				ld d, (hl) 
3c85 21 c1 e2			ld hl, scratch 
3c88			if DEBUG_FORTH_DOT 
3c88				DMARK "DT1" 
3c88 f5				push af  
3c89 3a 9d 3c			ld a, (.dmark)  
3c8c 32 6b ee			ld (debug_mark),a  
3c8f 3a 9e 3c			ld a, (.dmark+1)  
3c92 32 6c ee			ld (debug_mark+1),a  
3c95 3a 9f 3c			ld a, (.dmark+2)  
3c98 32 6d ee			ld (debug_mark+2),a  
3c9b 18 03			jr .pastdmark  
3c9d ..			.dmark: db "DT1"  
3ca0 f1			.pastdmark: pop af  
3ca1			endm  
# End of macro DMARK
3ca1				CALLMONITOR 
3ca1 cd 6f ee			call debug_vector  
3ca4				endm  
# End of macro CALLMONITOR
3ca4			endif	 
3ca4			 
3ca4 cd f4 11			call uitoa_16 
3ca7 eb				ex de,hl 
3ca8			 
3ca8			if DEBUG_FORTH_DOT 
3ca8				DMARK "DT2" 
3ca8 f5				push af  
3ca9 3a bd 3c			ld a, (.dmark)  
3cac 32 6b ee			ld (debug_mark),a  
3caf 3a be 3c			ld a, (.dmark+1)  
3cb2 32 6c ee			ld (debug_mark+1),a  
3cb5 3a bf 3c			ld a, (.dmark+2)  
3cb8 32 6d ee			ld (debug_mark+2),a  
3cbb 18 03			jr .pastdmark  
3cbd ..			.dmark: db "DT2"  
3cc0 f1			.pastdmark: pop af  
3cc1			endm  
# End of macro DMARK
3cc1				CALLMONITOR 
3cc1 cd 6f ee			call debug_vector  
3cc4				endm  
# End of macro CALLMONITOR
3cc4			endif	 
3cc4			 
3cc4			;	ld de, os_word_scratch 
3cc4 18 01			jr .dotwrite 
3cc6			 
3cc6 00			.dotflot:   nop 
3cc7			; TODO print floating point number 
3cc7			 
3cc7			.dotwrite:		 
3cc7			 
3cc7					; if c is set then set all '-' to spaces 
3cc7					; need to also take into account .>  
3cc7			 
3cc7 3e 01				ld a, 1 
3cc9 b9					cp c 
3cca 20 67				jr nz, .nodashswap 
3ccc			 
3ccc					; DE has the string to write, working with HL 
3ccc			 
3ccc 06 ff				ld b, 255 
3cce d5					push de 
3ccf e1					pop hl 
3cd0			 
3cd0			if DEBUG_FORTH_DOT 
3cd0				DMARK "DT-" 
3cd0 f5				push af  
3cd1 3a e5 3c			ld a, (.dmark)  
3cd4 32 6b ee			ld (debug_mark),a  
3cd7 3a e6 3c			ld a, (.dmark+1)  
3cda 32 6c ee			ld (debug_mark+1),a  
3cdd 3a e7 3c			ld a, (.dmark+2)  
3ce0 32 6d ee			ld (debug_mark+2),a  
3ce3 18 03			jr .pastdmark  
3ce5 ..			.dmark: db "DT-"  
3ce8 f1			.pastdmark: pop af  
3ce9			endm  
# End of macro DMARK
3ce9				CALLMONITOR 
3ce9 cd 6f ee			call debug_vector  
3cec				endm  
# End of macro CALLMONITOR
3cec			endif	 
3cec 7e			.dashscan:	ld a, (hl) 
3ced fe 00				cp 0 
3cef 28 42				jr z, .nodashswap 
3cf1 fe 2d				cp '-' 
3cf3 20 03				jr nz, .dashskip 
3cf5 3e 20				ld a, ' ' 
3cf7 77					ld (hl), a 
3cf8 23			.dashskip:	inc hl 
3cf9			if DEBUG_FORTH_DOT 
3cf9				DMARK "D-2" 
3cf9 f5				push af  
3cfa 3a 0e 3d			ld a, (.dmark)  
3cfd 32 6b ee			ld (debug_mark),a  
3d00 3a 0f 3d			ld a, (.dmark+1)  
3d03 32 6c ee			ld (debug_mark+1),a  
3d06 3a 10 3d			ld a, (.dmark+2)  
3d09 32 6d ee			ld (debug_mark+2),a  
3d0c 18 03			jr .pastdmark  
3d0e ..			.dmark: db "D-2"  
3d11 f1			.pastdmark: pop af  
3d12			endm  
# End of macro DMARK
3d12				CALLMONITOR 
3d12 cd 6f ee			call debug_vector  
3d15				endm  
# End of macro CALLMONITOR
3d15			endif	 
3d15 10 d5				djnz .dashscan 
3d17			 
3d17			if DEBUG_FORTH_DOT 
3d17				DMARK "D-1" 
3d17 f5				push af  
3d18 3a 2c 3d			ld a, (.dmark)  
3d1b 32 6b ee			ld (debug_mark),a  
3d1e 3a 2d 3d			ld a, (.dmark+1)  
3d21 32 6c ee			ld (debug_mark+1),a  
3d24 3a 2e 3d			ld a, (.dmark+2)  
3d27 32 6d ee			ld (debug_mark+2),a  
3d2a 18 03			jr .pastdmark  
3d2c ..			.dmark: db "D-1"  
3d2f f1			.pastdmark: pop af  
3d30			endm  
# End of macro DMARK
3d30				CALLMONITOR 
3d30 cd 6f ee			call debug_vector  
3d33				endm  
# End of macro CALLMONITOR
3d33			endif	 
3d33			 
3d33			.nodashswap: 
3d33			 
3d33			if DEBUG_FORTH_DOT 
3d33				DMARK "D-o" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 6b ee			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 6c ee			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 6d ee			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "D-o"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c				CALLMONITOR 
3d4c cd 6f ee			call debug_vector  
3d4f				endm  
# End of macro CALLMONITOR
3d4f			endif	 
3d4f			 
3d4f d5					push de   ; save string start in case we need to advance print 
3d50			 
3d50 3a 5e ea				ld a, (f_cursor_ptr) 
3d53 cd cd 0b				call str_at_display 
3d56 3a 3c ea				ld a,(cli_autodisplay) 
3d59 fe 00				cp 0 
3d5b 28 03				jr z, .noupdate 
3d5d cd dd 0b						call update_display 
3d60					.noupdate: 
3d60			 
3d60			 
3d60					; see if we need to advance the print position 
3d60			 
3d60 e1					pop hl   ; get back string 
3d61			;		ex de,hl 
3d61			 
3d61 3a 3d ea				ld a, (cli_mvdot) 
3d64			if DEBUG_FORTH_DOT 
3d64			;		ld e,a 
3d64				DMARK "D>1" 
3d64 f5				push af  
3d65 3a 79 3d			ld a, (.dmark)  
3d68 32 6b ee			ld (debug_mark),a  
3d6b 3a 7a 3d			ld a, (.dmark+1)  
3d6e 32 6c ee			ld (debug_mark+1),a  
3d71 3a 7b 3d			ld a, (.dmark+2)  
3d74 32 6d ee			ld (debug_mark+2),a  
3d77 18 03			jr .pastdmark  
3d79 ..			.dmark: db "D>1"  
3d7c f1			.pastdmark: pop af  
3d7d			endm  
# End of macro DMARK
3d7d				CALLMONITOR 
3d7d cd 6f ee			call debug_vector  
3d80				endm  
# End of macro CALLMONITOR
3d80			endif	 
3d80 fe 00				cp 0 
3d82 28 44				jr z, .noadv 
3d84					; yes, lets advance the print position 
3d84 3e 00				ld a, 0 
3d86 cd 50 12				call strlent 
3d89			if DEBUG_FORTH_DOT 
3d89				DMARK "D-?" 
3d89 f5				push af  
3d8a 3a 9e 3d			ld a, (.dmark)  
3d8d 32 6b ee			ld (debug_mark),a  
3d90 3a 9f 3d			ld a, (.dmark+1)  
3d93 32 6c ee			ld (debug_mark+1),a  
3d96 3a a0 3d			ld a, (.dmark+2)  
3d99 32 6d ee			ld (debug_mark+2),a  
3d9c 18 03			jr .pastdmark  
3d9e ..			.dmark: db "D-?"  
3da1 f1			.pastdmark: pop af  
3da2			endm  
# End of macro DMARK
3da2				CALLMONITOR 
3da2 cd 6f ee			call debug_vector  
3da5				endm  
# End of macro CALLMONITOR
3da5			endif	 
3da5 3a 5e ea				ld a, (f_cursor_ptr) 
3da8 85					add a,l 
3da9					;call addatohl 
3da9					;ld a, l 
3da9 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3dac			 
3dac			if DEBUG_FORTH_DOT 
3dac				DMARK "D->" 
3dac f5				push af  
3dad 3a c1 3d			ld a, (.dmark)  
3db0 32 6b ee			ld (debug_mark),a  
3db3 3a c2 3d			ld a, (.dmark+1)  
3db6 32 6c ee			ld (debug_mark+1),a  
3db9 3a c3 3d			ld a, (.dmark+2)  
3dbc 32 6d ee			ld (debug_mark+2),a  
3dbf 18 03			jr .pastdmark  
3dc1 ..			.dmark: db "D->"  
3dc4 f1			.pastdmark: pop af  
3dc5			endm  
# End of macro DMARK
3dc5				CALLMONITOR 
3dc5 cd 6f ee			call debug_vector  
3dc8				endm  
# End of macro CALLMONITOR
3dc8			endif	 
3dc8			 
3dc8			.noadv:	 
3dc8			 
3dc8					if DEBUG_FORTH_DOT_WAIT 
3dc8							call next_page_prompt 
3dc8					endif	 
3dc8			; TODO this pop off the stack causes a crash. i dont know why 
3dc8			 
3dc8			 
3dc8			if DEBUG_FORTH_DOT 
3dc8				DMARK "DTh" 
3dc8 f5				push af  
3dc9 3a dd 3d			ld a, (.dmark)  
3dcc 32 6b ee			ld (debug_mark),a  
3dcf 3a de 3d			ld a, (.dmark+1)  
3dd2 32 6c ee			ld (debug_mark+1),a  
3dd5 3a df 3d			ld a, (.dmark+2)  
3dd8 32 6d ee			ld (debug_mark+2),a  
3ddb 18 03			jr .pastdmark  
3ddd ..			.dmark: db "DTh"  
3de0 f1			.pastdmark: pop af  
3de1			endm  
# End of macro DMARK
3de1				CALLMONITOR 
3de1 cd 6f ee			call debug_vector  
3de4				endm  
# End of macro CALLMONITOR
3de4			endif	 
3de4			 
3de4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de4 cd f5 1e			call macro_forth_dsp_pop 
3de7				endm 
# End of macro FORTH_DSP_POP
3de7			 
3de7			if DEBUG_FORTH_DOT 
3de7				DMARK "DTi" 
3de7 f5				push af  
3de8 3a fc 3d			ld a, (.dmark)  
3deb 32 6b ee			ld (debug_mark),a  
3dee 3a fd 3d			ld a, (.dmark+1)  
3df1 32 6c ee			ld (debug_mark+1),a  
3df4 3a fe 3d			ld a, (.dmark+2)  
3df7 32 6d ee			ld (debug_mark+2),a  
3dfa 18 03			jr .pastdmark  
3dfc ..			.dmark: db "DTi"  
3dff f1			.pastdmark: pop af  
3e00			endm  
# End of macro DMARK
3e00				CALLMONITOR 
3e00 cd 6f ee			call debug_vector  
3e03				endm  
# End of macro CALLMONITOR
3e03			endif	 
3e03			 
3e03			 
3e03					NEXTW 
3e03 c3 f3 1f			jp macro_next 
3e06				endm 
# End of macro NEXTW
3e06			 
3e06			.CLS: 
3e06				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e06 35				db WORD_SYS_CORE+33             
3e07 33 3e			dw .DRAW            
3e09 04				db 3 + 1 
3e0a .. 00			db "CLS",0              
3e0e				endm 
# End of macro CWHEAD
3e0e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e0e					if DEBUG_FORTH_WORDS_KEY 
3e0e						DMARK "CLS" 
3e0e f5				push af  
3e0f 3a 23 3e			ld a, (.dmark)  
3e12 32 6b ee			ld (debug_mark),a  
3e15 3a 24 3e			ld a, (.dmark+1)  
3e18 32 6c ee			ld (debug_mark+1),a  
3e1b 3a 25 3e			ld a, (.dmark+2)  
3e1e 32 6d ee			ld (debug_mark+2),a  
3e21 18 03			jr .pastdmark  
3e23 ..			.dmark: db "CLS"  
3e26 f1			.pastdmark: pop af  
3e27			endm  
# End of macro DMARK
3e27						CALLMONITOR 
3e27 cd 6f ee			call debug_vector  
3e2a				endm  
# End of macro CALLMONITOR
3e2a					endif 
3e2a cd ba 0b				call clear_display 
3e2d c3 41 3f				jp .home		; and home cursor 
3e30					NEXTW 
3e30 c3 f3 1f			jp macro_next 
3e33				endm 
# End of macro NEXTW
3e33			 
3e33			.DRAW: 
3e33				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e33 36				db WORD_SYS_CORE+34             
3e34 5e 3e			dw .DUMP            
3e36 05				db 4 + 1 
3e37 .. 00			db "DRAW",0              
3e3c				endm 
# End of macro CWHEAD
3e3c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e3c					if DEBUG_FORTH_WORDS_KEY 
3e3c						DMARK "DRW" 
3e3c f5				push af  
3e3d 3a 51 3e			ld a, (.dmark)  
3e40 32 6b ee			ld (debug_mark),a  
3e43 3a 52 3e			ld a, (.dmark+1)  
3e46 32 6c ee			ld (debug_mark+1),a  
3e49 3a 53 3e			ld a, (.dmark+2)  
3e4c 32 6d ee			ld (debug_mark+2),a  
3e4f 18 03			jr .pastdmark  
3e51 ..			.dmark: db "DRW"  
3e54 f1			.pastdmark: pop af  
3e55			endm  
# End of macro DMARK
3e55						CALLMONITOR 
3e55 cd 6f ee			call debug_vector  
3e58				endm  
# End of macro CALLMONITOR
3e58					endif 
3e58 cd dd 0b				call update_display 
3e5b					NEXTW 
3e5b c3 f3 1f			jp macro_next 
3e5e				endm 
# End of macro NEXTW
3e5e			 
3e5e			.DUMP: 
3e5e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e5e 37				db WORD_SYS_CORE+35             
3e5f 96 3e			dw .CDUMP            
3e61 05				db 4 + 1 
3e62 .. 00			db "DUMP",0              
3e67				endm 
# End of macro CWHEAD
3e67			; | DUMP ( x -- ) With address x display dump   | DONE 
3e67			; TODO pop address to use off of the stack 
3e67					if DEBUG_FORTH_WORDS_KEY 
3e67						DMARK "DUM" 
3e67 f5				push af  
3e68 3a 7c 3e			ld a, (.dmark)  
3e6b 32 6b ee			ld (debug_mark),a  
3e6e 3a 7d 3e			ld a, (.dmark+1)  
3e71 32 6c ee			ld (debug_mark+1),a  
3e74 3a 7e 3e			ld a, (.dmark+2)  
3e77 32 6d ee			ld (debug_mark+2),a  
3e7a 18 03			jr .pastdmark  
3e7c ..			.dmark: db "DUM"  
3e7f f1			.pastdmark: pop af  
3e80			endm  
# End of macro DMARK
3e80						CALLMONITOR 
3e80 cd 6f ee			call debug_vector  
3e83				endm  
# End of macro CALLMONITOR
3e83					endif 
3e83 cd ba 0b				call clear_display 
3e86			 
3e86					; get address 
3e86			 
3e86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e86 cd 3d 1e			call macro_dsp_valuehl 
3e89				endm 
# End of macro FORTH_DSP_VALUEHL
3e89				 
3e89					; save it for cdump 
3e89			 
3e89 22 e4 e5				ld (os_cur_ptr),hl 
3e8c			 
3e8c					; destroy value TOS 
3e8c			 
3e8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e8c cd f5 1e			call macro_forth_dsp_pop 
3e8f				endm 
# End of macro FORTH_DSP_POP
3e8f			 
3e8f cd c6 1a				call dumpcont	; skip old style of param parsing	 
3e92 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e93					NEXTW 
3e93 c3 f3 1f			jp macro_next 
3e96				endm 
# End of macro NEXTW
3e96			.CDUMP: 
3e96				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e96 38				db WORD_SYS_CORE+36             
3e97 c6 3e			dw .DAT            
3e99 06				db 5 + 1 
3e9a .. 00			db "CDUMP",0              
3ea0				endm 
# End of macro CWHEAD
3ea0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ea0					if DEBUG_FORTH_WORDS_KEY 
3ea0						DMARK "CDP" 
3ea0 f5				push af  
3ea1 3a b5 3e			ld a, (.dmark)  
3ea4 32 6b ee			ld (debug_mark),a  
3ea7 3a b6 3e			ld a, (.dmark+1)  
3eaa 32 6c ee			ld (debug_mark+1),a  
3ead 3a b7 3e			ld a, (.dmark+2)  
3eb0 32 6d ee			ld (debug_mark+2),a  
3eb3 18 03			jr .pastdmark  
3eb5 ..			.dmark: db "CDP"  
3eb8 f1			.pastdmark: pop af  
3eb9			endm  
# End of macro DMARK
3eb9						CALLMONITOR 
3eb9 cd 6f ee			call debug_vector  
3ebc				endm  
# End of macro CALLMONITOR
3ebc					endif 
3ebc cd ba 0b				call clear_display 
3ebf cd c6 1a				call dumpcont	 
3ec2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ec3					NEXTW 
3ec3 c3 f3 1f			jp macro_next 
3ec6				endm 
# End of macro NEXTW
3ec6			 
3ec6			 
3ec6			 
3ec6			 
3ec6			.DAT: 
3ec6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ec6 3d				db WORD_SYS_CORE+41             
3ec7 1c 3f			dw .HOME            
3ec9 03				db 2 + 1 
3eca .. 00			db "AT",0              
3ecd				endm 
# End of macro CWHEAD
3ecd			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3ecd					if DEBUG_FORTH_WORDS_KEY 
3ecd						DMARK "AT." 
3ecd f5				push af  
3ece 3a e2 3e			ld a, (.dmark)  
3ed1 32 6b ee			ld (debug_mark),a  
3ed4 3a e3 3e			ld a, (.dmark+1)  
3ed7 32 6c ee			ld (debug_mark+1),a  
3eda 3a e4 3e			ld a, (.dmark+2)  
3edd 32 6d ee			ld (debug_mark+2),a  
3ee0 18 03			jr .pastdmark  
3ee2 ..			.dmark: db "AT."  
3ee5 f1			.pastdmark: pop af  
3ee6			endm  
# End of macro DMARK
3ee6						CALLMONITOR 
3ee6 cd 6f ee			call debug_vector  
3ee9				endm  
# End of macro CALLMONITOR
3ee9					endif 
3ee9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee9 cd 3d 1e			call macro_dsp_valuehl 
3eec				endm 
# End of macro FORTH_DSP_VALUEHL
3eec			 
3eec			 
3eec					; TODO save cursor row 
3eec 7d					ld a,l 
3eed fe 02				cp 2 
3eef 20 04				jr nz, .crow3 
3ef1 3e 28				ld a, display_row_2 
3ef3 18 12				jr .ccol1 
3ef5 fe 03		.crow3:		cp 3 
3ef7 20 04				jr nz, .crow4 
3ef9 3e 50				ld a, display_row_3 
3efb 18 0a				jr .ccol1 
3efd fe 04		.crow4:		cp 4 
3eff 20 04				jr nz, .crow1 
3f01 3e 78				ld a, display_row_4 
3f03 18 02				jr .ccol1 
3f05 3e 00		.crow1:		ld a,display_row_1 
3f07 f5			.ccol1:		push af			; got row offset 
3f08 6f					ld l,a 
3f09 26 00				ld h,0 
3f0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f0b cd f5 1e			call macro_forth_dsp_pop 
3f0e				endm 
# End of macro FORTH_DSP_POP
3f0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0e cd 3d 1e			call macro_dsp_valuehl 
3f11				endm 
# End of macro FORTH_DSP_VALUEHL
3f11					; TODO save cursor col 
3f11 f1					pop af 
3f12 85					add l		; add col offset 
3f13 32 5e ea				ld (f_cursor_ptr), a 
3f16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f16 cd f5 1e			call macro_forth_dsp_pop 
3f19				endm 
# End of macro FORTH_DSP_POP
3f19			 
3f19					; calculate  
3f19			 
3f19					NEXTW 
3f19 c3 f3 1f			jp macro_next 
3f1c				endm 
# End of macro NEXTW
3f1c			 
3f1c			 
3f1c			.HOME: 
3f1c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f1c 41				db WORD_SYS_CORE+45             
3f1d 49 3f			dw .SPACE            
3f1f 05				db 4 + 1 
3f20 .. 00			db "HOME",0              
3f25				endm 
# End of macro CWHEAD
3f25			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f25					if DEBUG_FORTH_WORDS_KEY 
3f25						DMARK "HOM" 
3f25 f5				push af  
3f26 3a 3a 3f			ld a, (.dmark)  
3f29 32 6b ee			ld (debug_mark),a  
3f2c 3a 3b 3f			ld a, (.dmark+1)  
3f2f 32 6c ee			ld (debug_mark+1),a  
3f32 3a 3c 3f			ld a, (.dmark+2)  
3f35 32 6d ee			ld (debug_mark+2),a  
3f38 18 03			jr .pastdmark  
3f3a ..			.dmark: db "HOM"  
3f3d f1			.pastdmark: pop af  
3f3e			endm  
# End of macro DMARK
3f3e						CALLMONITOR 
3f3e cd 6f ee			call debug_vector  
3f41				endm  
# End of macro CALLMONITOR
3f41					endif 
3f41 3e 00		.home:		ld a, 0		; and home cursor 
3f43 32 5e ea				ld (f_cursor_ptr), a 
3f46					NEXTW 
3f46 c3 f3 1f			jp macro_next 
3f49				endm 
# End of macro NEXTW
3f49			 
3f49			 
3f49			.SPACE: 
3f49				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f49 46				db WORD_SYS_CORE+50             
3f4a 7f 3f			dw .SPACES            
3f4c 03				db 2 + 1 
3f4d .. 00			db "BL",0              
3f50				endm 
# End of macro CWHEAD
3f50			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f50					if DEBUG_FORTH_WORDS_KEY 
3f50						DMARK "BL." 
3f50 f5				push af  
3f51 3a 65 3f			ld a, (.dmark)  
3f54 32 6b ee			ld (debug_mark),a  
3f57 3a 66 3f			ld a, (.dmark+1)  
3f5a 32 6c ee			ld (debug_mark+1),a  
3f5d 3a 67 3f			ld a, (.dmark+2)  
3f60 32 6d ee			ld (debug_mark+2),a  
3f63 18 03			jr .pastdmark  
3f65 ..			.dmark: db "BL."  
3f68 f1			.pastdmark: pop af  
3f69			endm  
# End of macro DMARK
3f69						CALLMONITOR 
3f69 cd 6f ee			call debug_vector  
3f6c				endm  
# End of macro CALLMONITOR
3f6c					endif 
3f6c 3e 20				ld a, " " 
3f6e 32 c1 e2				ld (scratch),a 
3f71 3e 00				ld a, 0 
3f73 32 c2 e2				ld (scratch+1),a 
3f76 21 c1 e2				ld hl, scratch 
3f79 cd b4 1c				call forth_push_str 
3f7c					 
3f7c				       NEXTW 
3f7c c3 f3 1f			jp macro_next 
3f7f				endm 
# End of macro NEXTW
3f7f			 
3f7f			;.blstr: db " ", 0 
3f7f			 
3f7f			.SPACES: 
3f7f				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f7f 47				db WORD_SYS_CORE+51             
3f80 1a 40			dw .SCROLL            
3f82 07				db 6 + 1 
3f83 .. 00			db "SPACES",0              
3f8a				endm 
# End of macro CWHEAD
3f8a			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f8a					if DEBUG_FORTH_WORDS_KEY 
3f8a						DMARK "SPS" 
3f8a f5				push af  
3f8b 3a 9f 3f			ld a, (.dmark)  
3f8e 32 6b ee			ld (debug_mark),a  
3f91 3a a0 3f			ld a, (.dmark+1)  
3f94 32 6c ee			ld (debug_mark+1),a  
3f97 3a a1 3f			ld a, (.dmark+2)  
3f9a 32 6d ee			ld (debug_mark+2),a  
3f9d 18 03			jr .pastdmark  
3f9f ..			.dmark: db "SPS"  
3fa2 f1			.pastdmark: pop af  
3fa3			endm  
# End of macro DMARK
3fa3						CALLMONITOR 
3fa3 cd 6f ee			call debug_vector  
3fa6				endm  
# End of macro CALLMONITOR
3fa6					endif 
3fa6			 
3fa6			 
3fa6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fa6 cd 3d 1e			call macro_dsp_valuehl 
3fa9				endm 
# End of macro FORTH_DSP_VALUEHL
3fa9			 
3fa9 e5					push hl    ; u 
3faa					if DEBUG_FORTH_WORDS 
3faa						DMARK "SPA" 
3faa f5				push af  
3fab 3a bf 3f			ld a, (.dmark)  
3fae 32 6b ee			ld (debug_mark),a  
3fb1 3a c0 3f			ld a, (.dmark+1)  
3fb4 32 6c ee			ld (debug_mark+1),a  
3fb7 3a c1 3f			ld a, (.dmark+2)  
3fba 32 6d ee			ld (debug_mark+2),a  
3fbd 18 03			jr .pastdmark  
3fbf ..			.dmark: db "SPA"  
3fc2 f1			.pastdmark: pop af  
3fc3			endm  
# End of macro DMARK
3fc3						CALLMONITOR 
3fc3 cd 6f ee			call debug_vector  
3fc6				endm  
# End of macro CALLMONITOR
3fc6					endif 
3fc6			 
3fc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fc6 cd f5 1e			call macro_forth_dsp_pop 
3fc9				endm 
# End of macro FORTH_DSP_POP
3fc9 e1					pop hl 
3fca 0e 00				ld c, 0 
3fcc 45					ld b, l 
3fcd 21 c1 e2				ld hl, scratch  
3fd0			 
3fd0					if DEBUG_FORTH_WORDS 
3fd0						DMARK "SP2" 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 6b ee			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 6c ee			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 6d ee			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "SP2"  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9						CALLMONITOR 
3fe9 cd 6f ee			call debug_vector  
3fec				endm  
# End of macro CALLMONITOR
3fec					endif 
3fec 3e 20				ld a, ' ' 
3fee			.spaces1:	 
3fee 77					ld (hl),a 
3fef 23					inc hl 
3ff0					 
3ff0 10 fc				djnz .spaces1 
3ff2 3e 00				ld a,0 
3ff4 77					ld (hl),a 
3ff5 21 c1 e2				ld hl, scratch 
3ff8					if DEBUG_FORTH_WORDS 
3ff8						DMARK "SP3" 
3ff8 f5				push af  
3ff9 3a 0d 40			ld a, (.dmark)  
3ffc 32 6b ee			ld (debug_mark),a  
3fff 3a 0e 40			ld a, (.dmark+1)  
4002 32 6c ee			ld (debug_mark+1),a  
4005 3a 0f 40			ld a, (.dmark+2)  
4008 32 6d ee			ld (debug_mark+2),a  
400b 18 03			jr .pastdmark  
400d ..			.dmark: db "SP3"  
4010 f1			.pastdmark: pop af  
4011			endm  
# End of macro DMARK
4011						CALLMONITOR 
4011 cd 6f ee			call debug_vector  
4014				endm  
# End of macro CALLMONITOR
4014					endif 
4014 cd b4 1c				call forth_push_str 
4017			 
4017				       NEXTW 
4017 c3 f3 1f			jp macro_next 
401a				endm 
# End of macro NEXTW
401a			 
401a			 
401a			 
401a			.SCROLL: 
401a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
401a 53				db WORD_SYS_CORE+63             
401b 47 40			dw .SCROLLD            
401d 07				db 6 + 1 
401e .. 00			db "SCROLL",0              
4025				endm 
# End of macro CWHEAD
4025			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4025					if DEBUG_FORTH_WORDS_KEY 
4025						DMARK "SCR" 
4025 f5				push af  
4026 3a 3a 40			ld a, (.dmark)  
4029 32 6b ee			ld (debug_mark),a  
402c 3a 3b 40			ld a, (.dmark+1)  
402f 32 6c ee			ld (debug_mark+1),a  
4032 3a 3c 40			ld a, (.dmark+2)  
4035 32 6d ee			ld (debug_mark+2),a  
4038 18 03			jr .pastdmark  
403a ..			.dmark: db "SCR"  
403d f1			.pastdmark: pop af  
403e			endm  
# End of macro DMARK
403e						CALLMONITOR 
403e cd 6f ee			call debug_vector  
4041				endm  
# End of macro CALLMONITOR
4041					endif 
4041			 
4041 cd 7c 0b			call scroll_up 
4044			;	call update_display 
4044			 
4044					NEXTW 
4044 c3 f3 1f			jp macro_next 
4047				endm 
# End of macro NEXTW
4047			 
4047			 
4047			 
4047			;		; get dir 
4047			; 
4047			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4047			; 
4047			;		push hl 
4047			; 
4047			;		; destroy value TOS 
4047			; 
4047			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4047			; 
4047			;		; get count 
4047			; 
4047			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4047			; 
4047			;		push hl 
4047			; 
4047			;		; destroy value TOS 
4047			; 
4047			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4047			; 
4047			;		; one value on hl get other one back 
4047			; 
4047			;		pop bc    ; count 
4047			; 
4047			;		pop de   ; dir 
4047			; 
4047			; 
4047			;		ld b, c 
4047			; 
4047			;.scrolldir:     push bc 
4047			;		push de 
4047			; 
4047			;		ld a, 0 
4047			;		cp e 
4047			;		jr z, .scrollup  
4047			;		call scroll_down 
4047			;		jr .scrollnext 
4047			;.scrollup:	call scroll_up 
4047			; 
4047			;		 
4047			;.scrollnext: 
4047			;		pop de 
4047			;		pop bc 
4047			;		djnz .scrolldir 
4047			; 
4047			; 
4047			; 
4047			; 
4047			; 
4047			;		NEXTW 
4047			 
4047			.SCROLLD: 
4047				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4047 53				db WORD_SYS_CORE+63             
4048 75 40			dw .ATQ            
404a 08				db 7 + 1 
404b .. 00			db "SCROLLD",0              
4053				endm 
# End of macro CWHEAD
4053			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4053					if DEBUG_FORTH_WORDS_KEY 
4053						DMARK "SCD" 
4053 f5				push af  
4054 3a 68 40			ld a, (.dmark)  
4057 32 6b ee			ld (debug_mark),a  
405a 3a 69 40			ld a, (.dmark+1)  
405d 32 6c ee			ld (debug_mark+1),a  
4060 3a 6a 40			ld a, (.dmark+2)  
4063 32 6d ee			ld (debug_mark+2),a  
4066 18 03			jr .pastdmark  
4068 ..			.dmark: db "SCD"  
406b f1			.pastdmark: pop af  
406c			endm  
# End of macro DMARK
406c						CALLMONITOR 
406c cd 6f ee			call debug_vector  
406f				endm  
# End of macro CALLMONITOR
406f					endif 
406f			 
406f cd a0 0b			call scroll_down 
4072			;	call update_display 
4072			 
4072					NEXTW 
4072 c3 f3 1f			jp macro_next 
4075				endm 
# End of macro NEXTW
4075			 
4075			 
4075			.ATQ: 
4075				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4075 62				db WORD_SYS_CORE+78             
4076 d3 40			dw .AUTODSP            
4078 04				db 3 + 1 
4079 .. 00			db "AT@",0              
407d				endm 
# End of macro CWHEAD
407d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
407d					if DEBUG_FORTH_WORDS_KEY 
407d						DMARK "ATA" 
407d f5				push af  
407e 3a 92 40			ld a, (.dmark)  
4081 32 6b ee			ld (debug_mark),a  
4084 3a 93 40			ld a, (.dmark+1)  
4087 32 6c ee			ld (debug_mark+1),a  
408a 3a 94 40			ld a, (.dmark+2)  
408d 32 6d ee			ld (debug_mark+2),a  
4090 18 03			jr .pastdmark  
4092 ..			.dmark: db "ATA"  
4095 f1			.pastdmark: pop af  
4096			endm  
# End of macro DMARK
4096						CALLMONITOR 
4096 cd 6f ee			call debug_vector  
4099				endm  
# End of macro CALLMONITOR
4099					endif 
4099			 
4099			 
4099					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4099 cd 3d 1e			call macro_dsp_valuehl 
409c				endm 
# End of macro FORTH_DSP_VALUEHL
409c			 
409c					; TODO save cursor row 
409c 7d					ld a,l 
409d fe 02				cp 2 
409f 20 04				jr nz, .crow3aq 
40a1 3e 28				ld a, display_row_2 
40a3 18 12				jr .ccol1aq 
40a5 fe 03		.crow3aq:		cp 3 
40a7 20 04				jr nz, .crow4aq 
40a9 3e 50				ld a, display_row_3 
40ab 18 0a				jr .ccol1aq 
40ad fe 04		.crow4aq:		cp 4 
40af 20 04				jr nz, .crow1aq 
40b1 3e 78				ld a, display_row_4 
40b3 18 02				jr .ccol1aq 
40b5 3e 00		.crow1aq:		ld a,display_row_1 
40b7 f5			.ccol1aq:		push af			; got row offset 
40b8 6f					ld l,a 
40b9 26 00				ld h,0 
40bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bb cd f5 1e			call macro_forth_dsp_pop 
40be				endm 
# End of macro FORTH_DSP_POP
40be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40be cd 3d 1e			call macro_dsp_valuehl 
40c1				endm 
# End of macro FORTH_DSP_VALUEHL
40c1					; TODO save cursor col 
40c1 f1					pop af 
40c2 85					add l		; add col offset 
40c3			 
40c3					; add current frame buffer address 
40c3 2a cc eb				ld hl, (display_fb_active) 
40c6 cd e7 0d				call addatohl 
40c9			 
40c9			 
40c9			 
40c9			 
40c9					; get char frame buffer location offset in hl 
40c9			 
40c9 7e					ld a,(hl) 
40ca 26 00				ld h, 0 
40cc 6f					ld l, a 
40cd			 
40cd cd 46 1c				call forth_push_numhl 
40d0			 
40d0			 
40d0					NEXTW 
40d0 c3 f3 1f			jp macro_next 
40d3				endm 
# End of macro NEXTW
40d3			 
40d3			.AUTODSP: 
40d3				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40d3 63				db WORD_SYS_CORE+79             
40d4 e9 40			dw .MENU            
40d6 05				db 4 + 1 
40d7 .. 00			db "ADSP",0              
40dc				endm 
# End of macro CWHEAD
40dc			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40dc			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40dc			 
40dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40dc cd 3d 1e			call macro_dsp_valuehl 
40df				endm 
# End of macro FORTH_DSP_VALUEHL
40df			 
40df			;		push hl 
40df			 
40df					; destroy value TOS 
40df			 
40df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40df cd f5 1e			call macro_forth_dsp_pop 
40e2				endm 
# End of macro FORTH_DSP_POP
40e2			 
40e2			;		pop hl 
40e2			 
40e2 7d					ld a,l 
40e3 32 3c ea				ld (cli_autodisplay), a 
40e6				       NEXTW 
40e6 c3 f3 1f			jp macro_next 
40e9				endm 
# End of macro NEXTW
40e9			 
40e9			.MENU: 
40e9				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40e9 70				db WORD_SYS_CORE+92             
40ea 92 41			dw .ENDDISPLAY            
40ec 05				db 4 + 1 
40ed .. 00			db "MENU",0              
40f2				endm 
# End of macro CWHEAD
40f2			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40f2			 
40f2			;		; get number of items on the stack 
40f2			; 
40f2				 
40f2					FORTH_DSP_VALUEHL 
40f2 cd 3d 1e			call macro_dsp_valuehl 
40f5				endm 
# End of macro FORTH_DSP_VALUEHL
40f5				 
40f5					if DEBUG_FORTH_WORDS_KEY 
40f5						DMARK "MNU" 
40f5 f5				push af  
40f6 3a 0a 41			ld a, (.dmark)  
40f9 32 6b ee			ld (debug_mark),a  
40fc 3a 0b 41			ld a, (.dmark+1)  
40ff 32 6c ee			ld (debug_mark+1),a  
4102 3a 0c 41			ld a, (.dmark+2)  
4105 32 6d ee			ld (debug_mark+2),a  
4108 18 03			jr .pastdmark  
410a ..			.dmark: db "MNU"  
410d f1			.pastdmark: pop af  
410e			endm  
# End of macro DMARK
410e						CALLMONITOR 
410e cd 6f ee			call debug_vector  
4111				endm  
# End of macro CALLMONITOR
4111					endif 
4111			 
4111 45					ld b, l	 
4112 05					dec b 
4113			 
4113					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4113 cd f5 1e			call macro_forth_dsp_pop 
4116				endm 
# End of macro FORTH_DSP_POP
4116			 
4116			 
4116					; go directly through the stack to pluck out the string pointers and build an array 
4116			 
4116			;		FORTH_DSP 
4116			 
4116					; hl contains top most stack item 
4116				 
4116 11 c1 e2				ld de, scratch 
4119			 
4119			.mbuild: 
4119			 
4119					FORTH_DSP_VALUEHL 
4119 cd 3d 1e			call macro_dsp_valuehl 
411c				endm 
# End of macro FORTH_DSP_VALUEHL
411c			 
411c					if DEBUG_FORTH_WORDS 
411c						DMARK "MN3" 
411c f5				push af  
411d 3a 31 41			ld a, (.dmark)  
4120 32 6b ee			ld (debug_mark),a  
4123 3a 32 41			ld a, (.dmark+1)  
4126 32 6c ee			ld (debug_mark+1),a  
4129 3a 33 41			ld a, (.dmark+2)  
412c 32 6d ee			ld (debug_mark+2),a  
412f 18 03			jr .pastdmark  
4131 ..			.dmark: db "MN3"  
4134 f1			.pastdmark: pop af  
4135			endm  
# End of macro DMARK
4135						CALLMONITOR 
4135 cd 6f ee			call debug_vector  
4138				endm  
# End of macro CALLMONITOR
4138					endif 
4138 eb					ex de, hl 
4139 73					ld (hl), e 
413a 23					inc hl 
413b 72					ld (hl), d 
413c 23					inc hl 
413d eb					ex de, hl 
413e			 
413e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
413e cd f5 1e			call macro_forth_dsp_pop 
4141				endm 
# End of macro FORTH_DSP_POP
4141			 
4141 10 d6				djnz .mbuild 
4143			 
4143					; done add term 
4143			 
4143 eb					ex de, hl 
4144 36 00				ld (hl), 0 
4146 23					inc hl 
4147 36 00				ld (hl), 0 
4149			 
4149				 
4149					 
4149 21 c1 e2				ld hl, scratch 
414c			 
414c					if DEBUG_FORTH_WORDS 
414c						DMARK "MNx" 
414c f5				push af  
414d 3a 61 41			ld a, (.dmark)  
4150 32 6b ee			ld (debug_mark),a  
4153 3a 62 41			ld a, (.dmark+1)  
4156 32 6c ee			ld (debug_mark+1),a  
4159 3a 63 41			ld a, (.dmark+2)  
415c 32 6d ee			ld (debug_mark+2),a  
415f 18 03			jr .pastdmark  
4161 ..			.dmark: db "MNx"  
4164 f1			.pastdmark: pop af  
4165			endm  
# End of macro DMARK
4165						CALLMONITOR 
4165 cd 6f ee			call debug_vector  
4168				endm  
# End of macro CALLMONITOR
4168					endif 
4168			 
4168			 
4168			 
4168 3e 00				ld a, 0 
416a cd eb 0b				call menu 
416d			 
416d			 
416d 6f					ld l, a 
416e 26 00				ld h, 0 
4170			 
4170					if DEBUG_FORTH_WORDS 
4170						DMARK "MNr" 
4170 f5				push af  
4171 3a 85 41			ld a, (.dmark)  
4174 32 6b ee			ld (debug_mark),a  
4177 3a 86 41			ld a, (.dmark+1)  
417a 32 6c ee			ld (debug_mark+1),a  
417d 3a 87 41			ld a, (.dmark+2)  
4180 32 6d ee			ld (debug_mark+2),a  
4183 18 03			jr .pastdmark  
4185 ..			.dmark: db "MNr"  
4188 f1			.pastdmark: pop af  
4189			endm  
# End of macro DMARK
4189						CALLMONITOR 
4189 cd 6f ee			call debug_vector  
418c				endm  
# End of macro CALLMONITOR
418c					endif 
418c			 
418c cd 46 1c				call forth_push_numhl 
418f			 
418f			 
418f			 
418f			 
418f				       NEXTW 
418f c3 f3 1f			jp macro_next 
4192				endm 
# End of macro NEXTW
4192			 
4192			 
4192			.ENDDISPLAY: 
4192			 
4192			; eof 
# End of file forth_words_display.asm
4192			include "forth_words_str.asm" 
4192			 
4192			; | ## String Words 
4192			 
4192			.PTR:   
4192			 
4192				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4192 48				db WORD_SYS_CORE+52             
4193 bf 41			dw .STYPE            
4195 04				db 3 + 1 
4196 .. 00			db "PTR",0              
419a				endm 
# End of macro CWHEAD
419a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
419a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
419a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
419a			 
419a					if DEBUG_FORTH_WORDS_KEY 
419a						DMARK "PTR" 
419a f5				push af  
419b 3a af 41			ld a, (.dmark)  
419e 32 6b ee			ld (debug_mark),a  
41a1 3a b0 41			ld a, (.dmark+1)  
41a4 32 6c ee			ld (debug_mark+1),a  
41a7 3a b1 41			ld a, (.dmark+2)  
41aa 32 6d ee			ld (debug_mark+2),a  
41ad 18 03			jr .pastdmark  
41af ..			.dmark: db "PTR"  
41b2 f1			.pastdmark: pop af  
41b3			endm  
# End of macro DMARK
41b3						CALLMONITOR 
41b3 cd 6f ee			call debug_vector  
41b6				endm  
# End of macro CALLMONITOR
41b6					endif 
41b6					FORTH_DSP_VALUEHL 
41b6 cd 3d 1e			call macro_dsp_valuehl 
41b9				endm 
# End of macro FORTH_DSP_VALUEHL
41b9 cd 46 1c				call forth_push_numhl 
41bc			 
41bc			 
41bc					NEXTW 
41bc c3 f3 1f			jp macro_next 
41bf				endm 
# End of macro NEXTW
41bf			.STYPE: 
41bf				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41bf 48				db WORD_SYS_CORE+52             
41c0 0e 42			dw .UPPER            
41c2 06				db 5 + 1 
41c3 .. 00			db "STYPE",0              
41c9				endm 
# End of macro CWHEAD
41c9			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41c9					if DEBUG_FORTH_WORDS_KEY 
41c9						DMARK "STY" 
41c9 f5				push af  
41ca 3a de 41			ld a, (.dmark)  
41cd 32 6b ee			ld (debug_mark),a  
41d0 3a df 41			ld a, (.dmark+1)  
41d3 32 6c ee			ld (debug_mark+1),a  
41d6 3a e0 41			ld a, (.dmark+2)  
41d9 32 6d ee			ld (debug_mark+2),a  
41dc 18 03			jr .pastdmark  
41de ..			.dmark: db "STY"  
41e1 f1			.pastdmark: pop af  
41e2			endm  
# End of macro DMARK
41e2						CALLMONITOR 
41e2 cd 6f ee			call debug_vector  
41e5				endm  
# End of macro CALLMONITOR
41e5					endif 
41e5					FORTH_DSP 
41e5 cd 03 1e			call macro_forth_dsp 
41e8				endm 
# End of macro FORTH_DSP
41e8					;v5 FORTH_DSP_VALUE 
41e8			 
41e8 7e					ld a, (hl) 
41e9			 
41e9 f5					push af 
41ea			 
41ea			; Dont destroy TOS		FORTH_DSP_POP 
41ea			 
41ea f1					pop af 
41eb			 
41eb fe 01				cp DS_TYPE_STR 
41ed 28 09				jr z, .typestr 
41ef			 
41ef fe 02				cp DS_TYPE_INUM 
41f1 28 0a				jr z, .typeinum 
41f3			 
41f3 21 0c 42				ld hl, .tna 
41f6 18 0a				jr .tpush 
41f8			 
41f8 21 08 42		.typestr:	ld hl, .tstr 
41fb 18 05				jr .tpush 
41fd 21 0a 42		.typeinum:	ld hl, .tinum 
4200 18 00				jr .tpush 
4202			 
4202			.tpush: 
4202			 
4202 cd b4 1c				call forth_push_str 
4205			 
4205					NEXTW 
4205 c3 f3 1f			jp macro_next 
4208				endm 
# End of macro NEXTW
4208 .. 00		.tstr:	db "s",0 
420a .. 00		.tinum:  db "i",0 
420c .. 00		.tna:   db "?", 0 
420e			 
420e			 
420e			.UPPER: 
420e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
420e 48				db WORD_SYS_CORE+52             
420f 49 42			dw .LOWER            
4211 06				db 5 + 1 
4212 .. 00			db "UPPER",0              
4218				endm 
# End of macro CWHEAD
4218			; | UPPER ( s -- s ) Upper case string s  | DONE 
4218					if DEBUG_FORTH_WORDS_KEY 
4218						DMARK "UPR" 
4218 f5				push af  
4219 3a 2d 42			ld a, (.dmark)  
421c 32 6b ee			ld (debug_mark),a  
421f 3a 2e 42			ld a, (.dmark+1)  
4222 32 6c ee			ld (debug_mark+1),a  
4225 3a 2f 42			ld a, (.dmark+2)  
4228 32 6d ee			ld (debug_mark+2),a  
422b 18 03			jr .pastdmark  
422d ..			.dmark: db "UPR"  
4230 f1			.pastdmark: pop af  
4231			endm  
# End of macro DMARK
4231						CALLMONITOR 
4231 cd 6f ee			call debug_vector  
4234				endm  
# End of macro CALLMONITOR
4234					endif 
4234			 
4234					FORTH_DSP 
4234 cd 03 1e			call macro_forth_dsp 
4237				endm 
# End of macro FORTH_DSP
4237					 
4237			; TODO check is string type 
4237			 
4237					FORTH_DSP_VALUEHL 
4237 cd 3d 1e			call macro_dsp_valuehl 
423a				endm 
# End of macro FORTH_DSP_VALUEHL
423a			; get pointer to string in hl 
423a			 
423a 7e			.toup:		ld a, (hl) 
423b fe 00				cp 0 
423d 28 07				jr z, .toupdone 
423f			 
423f cd 54 11				call to_upper 
4242			 
4242 77					ld (hl), a 
4243 23					inc hl 
4244 18 f4				jr .toup 
4246			 
4246					 
4246			 
4246			 
4246			; for each char convert to upper 
4246					 
4246			.toupdone: 
4246			 
4246			 
4246					NEXTW 
4246 c3 f3 1f			jp macro_next 
4249				endm 
# End of macro NEXTW
4249			.LOWER: 
4249				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4249 48				db WORD_SYS_CORE+52             
424a 84 42			dw .TCASE            
424c 06				db 5 + 1 
424d .. 00			db "LOWER",0              
4253				endm 
# End of macro CWHEAD
4253			; | LOWER ( s -- s ) Lower case string s  | DONE 
4253					if DEBUG_FORTH_WORDS_KEY 
4253						DMARK "LWR" 
4253 f5				push af  
4254 3a 68 42			ld a, (.dmark)  
4257 32 6b ee			ld (debug_mark),a  
425a 3a 69 42			ld a, (.dmark+1)  
425d 32 6c ee			ld (debug_mark+1),a  
4260 3a 6a 42			ld a, (.dmark+2)  
4263 32 6d ee			ld (debug_mark+2),a  
4266 18 03			jr .pastdmark  
4268 ..			.dmark: db "LWR"  
426b f1			.pastdmark: pop af  
426c			endm  
# End of macro DMARK
426c						CALLMONITOR 
426c cd 6f ee			call debug_vector  
426f				endm  
# End of macro CALLMONITOR
426f					endif 
426f			 
426f					FORTH_DSP 
426f cd 03 1e			call macro_forth_dsp 
4272				endm 
# End of macro FORTH_DSP
4272					 
4272			; TODO check is string type 
4272			 
4272					FORTH_DSP_VALUEHL 
4272 cd 3d 1e			call macro_dsp_valuehl 
4275				endm 
# End of macro FORTH_DSP_VALUEHL
4275			; get pointer to string in hl 
4275			 
4275 7e			.tolow:		ld a, (hl) 
4276 fe 00				cp 0 
4278 28 07				jr z, .tolowdone 
427a			 
427a cd 5d 11				call to_lower 
427d			 
427d 77					ld (hl), a 
427e 23					inc hl 
427f 18 f4				jr .tolow 
4281			 
4281					 
4281			 
4281			 
4281			; for each char convert to low 
4281					 
4281			.tolowdone: 
4281					NEXTW 
4281 c3 f3 1f			jp macro_next 
4284				endm 
# End of macro NEXTW
4284			.TCASE: 
4284				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4284 48				db WORD_SYS_CORE+52             
4285 ba 43			dw .SUBSTR            
4287 06				db 5 + 1 
4288 .. 00			db "TCASE",0              
428e				endm 
# End of macro CWHEAD
428e			; | TCASE ( s -- s ) Title case string s  | DONE 
428e					if DEBUG_FORTH_WORDS_KEY 
428e						DMARK "TCS" 
428e f5				push af  
428f 3a a3 42			ld a, (.dmark)  
4292 32 6b ee			ld (debug_mark),a  
4295 3a a4 42			ld a, (.dmark+1)  
4298 32 6c ee			ld (debug_mark+1),a  
429b 3a a5 42			ld a, (.dmark+2)  
429e 32 6d ee			ld (debug_mark+2),a  
42a1 18 03			jr .pastdmark  
42a3 ..			.dmark: db "TCS"  
42a6 f1			.pastdmark: pop af  
42a7			endm  
# End of macro DMARK
42a7						CALLMONITOR 
42a7 cd 6f ee			call debug_vector  
42aa				endm  
# End of macro CALLMONITOR
42aa					endif 
42aa			 
42aa					FORTH_DSP 
42aa cd 03 1e			call macro_forth_dsp 
42ad				endm 
# End of macro FORTH_DSP
42ad					 
42ad			; TODO check is string type 
42ad			 
42ad					FORTH_DSP_VALUEHL 
42ad cd 3d 1e			call macro_dsp_valuehl 
42b0				endm 
# End of macro FORTH_DSP_VALUEHL
42b0			; get pointer to string in hl 
42b0			 
42b0					if DEBUG_FORTH_WORDS 
42b0						DMARK "TC1" 
42b0 f5				push af  
42b1 3a c5 42			ld a, (.dmark)  
42b4 32 6b ee			ld (debug_mark),a  
42b7 3a c6 42			ld a, (.dmark+1)  
42ba 32 6c ee			ld (debug_mark+1),a  
42bd 3a c7 42			ld a, (.dmark+2)  
42c0 32 6d ee			ld (debug_mark+2),a  
42c3 18 03			jr .pastdmark  
42c5 ..			.dmark: db "TC1"  
42c8 f1			.pastdmark: pop af  
42c9			endm  
# End of macro DMARK
42c9						CALLMONITOR 
42c9 cd 6f ee			call debug_vector  
42cc				endm  
# End of macro CALLMONITOR
42cc					endif 
42cc			 
42cc					; first time in turn to upper case first char 
42cc			 
42cc 7e					ld a, (hl) 
42cd c3 57 43				jp .totsiptou 
42d0			 
42d0			 
42d0 7e			.tot:		ld a, (hl) 
42d1 fe 00				cp 0 
42d3 ca 9b 43				jp z, .totdone 
42d6			 
42d6					if DEBUG_FORTH_WORDS 
42d6						DMARK "TC2" 
42d6 f5				push af  
42d7 3a eb 42			ld a, (.dmark)  
42da 32 6b ee			ld (debug_mark),a  
42dd 3a ec 42			ld a, (.dmark+1)  
42e0 32 6c ee			ld (debug_mark+1),a  
42e3 3a ed 42			ld a, (.dmark+2)  
42e6 32 6d ee			ld (debug_mark+2),a  
42e9 18 03			jr .pastdmark  
42eb ..			.dmark: db "TC2"  
42ee f1			.pastdmark: pop af  
42ef			endm  
# End of macro DMARK
42ef						CALLMONITOR 
42ef cd 6f ee			call debug_vector  
42f2				endm  
# End of macro CALLMONITOR
42f2					endif 
42f2					; check to see if current char is a space 
42f2			 
42f2 fe 20				cp ' ' 
42f4 28 21				jr z, .totsp 
42f6 cd 5d 11				call to_lower 
42f9					if DEBUG_FORTH_WORDS 
42f9						DMARK "TC3" 
42f9 f5				push af  
42fa 3a 0e 43			ld a, (.dmark)  
42fd 32 6b ee			ld (debug_mark),a  
4300 3a 0f 43			ld a, (.dmark+1)  
4303 32 6c ee			ld (debug_mark+1),a  
4306 3a 10 43			ld a, (.dmark+2)  
4309 32 6d ee			ld (debug_mark+2),a  
430c 18 03			jr .pastdmark  
430e ..			.dmark: db "TC3"  
4311 f1			.pastdmark: pop af  
4312			endm  
# End of macro DMARK
4312						CALLMONITOR 
4312 cd 6f ee			call debug_vector  
4315				endm  
# End of macro CALLMONITOR
4315					endif 
4315 18 63				jr .totnxt 
4317			 
4317			.totsp:         ; on a space, find next char which should be upper 
4317			 
4317					if DEBUG_FORTH_WORDS 
4317						DMARK "TC4" 
4317 f5				push af  
4318 3a 2c 43			ld a, (.dmark)  
431b 32 6b ee			ld (debug_mark),a  
431e 3a 2d 43			ld a, (.dmark+1)  
4321 32 6c ee			ld (debug_mark+1),a  
4324 3a 2e 43			ld a, (.dmark+2)  
4327 32 6d ee			ld (debug_mark+2),a  
432a 18 03			jr .pastdmark  
432c ..			.dmark: db "TC4"  
432f f1			.pastdmark: pop af  
4330			endm  
# End of macro DMARK
4330						CALLMONITOR 
4330 cd 6f ee			call debug_vector  
4333				endm  
# End of macro CALLMONITOR
4333					endif 
4333					;; 
4333			 
4333 fe 20				cp ' ' 
4335 20 20				jr nz, .totsiptou 
4337 23					inc hl 
4338 7e					ld a, (hl) 
4339					if DEBUG_FORTH_WORDS 
4339						DMARK "TC5" 
4339 f5				push af  
433a 3a 4e 43			ld a, (.dmark)  
433d 32 6b ee			ld (debug_mark),a  
4340 3a 4f 43			ld a, (.dmark+1)  
4343 32 6c ee			ld (debug_mark+1),a  
4346 3a 50 43			ld a, (.dmark+2)  
4349 32 6d ee			ld (debug_mark+2),a  
434c 18 03			jr .pastdmark  
434e ..			.dmark: db "TC5"  
4351 f1			.pastdmark: pop af  
4352			endm  
# End of macro DMARK
4352						CALLMONITOR 
4352 cd 6f ee			call debug_vector  
4355				endm  
# End of macro CALLMONITOR
4355					endif 
4355 18 c0				jr .totsp 
4357 fe 00		.totsiptou:    cp 0 
4359 28 40				jr z, .totdone 
435b					; not space and not zero term so upper case it 
435b cd 54 11				call to_upper 
435e			 
435e					if DEBUG_FORTH_WORDS 
435e						DMARK "TC6" 
435e f5				push af  
435f 3a 73 43			ld a, (.dmark)  
4362 32 6b ee			ld (debug_mark),a  
4365 3a 74 43			ld a, (.dmark+1)  
4368 32 6c ee			ld (debug_mark+1),a  
436b 3a 75 43			ld a, (.dmark+2)  
436e 32 6d ee			ld (debug_mark+2),a  
4371 18 03			jr .pastdmark  
4373 ..			.dmark: db "TC6"  
4376 f1			.pastdmark: pop af  
4377			endm  
# End of macro DMARK
4377						CALLMONITOR 
4377 cd 6f ee			call debug_vector  
437a				endm  
# End of macro CALLMONITOR
437a					endif 
437a			 
437a			 
437a			.totnxt: 
437a			 
437a 77					ld (hl), a 
437b 23					inc hl 
437c					if DEBUG_FORTH_WORDS 
437c						DMARK "TC7" 
437c f5				push af  
437d 3a 91 43			ld a, (.dmark)  
4380 32 6b ee			ld (debug_mark),a  
4383 3a 92 43			ld a, (.dmark+1)  
4386 32 6c ee			ld (debug_mark+1),a  
4389 3a 93 43			ld a, (.dmark+2)  
438c 32 6d ee			ld (debug_mark+2),a  
438f 18 03			jr .pastdmark  
4391 ..			.dmark: db "TC7"  
4394 f1			.pastdmark: pop af  
4395			endm  
# End of macro DMARK
4395						CALLMONITOR 
4395 cd 6f ee			call debug_vector  
4398				endm  
# End of macro CALLMONITOR
4398					endif 
4398 c3 d0 42				jp .tot 
439b			 
439b					 
439b			 
439b			 
439b			; for each char convert to low 
439b					 
439b			.totdone: 
439b					if DEBUG_FORTH_WORDS 
439b						DMARK "TCd" 
439b f5				push af  
439c 3a b0 43			ld a, (.dmark)  
439f 32 6b ee			ld (debug_mark),a  
43a2 3a b1 43			ld a, (.dmark+1)  
43a5 32 6c ee			ld (debug_mark+1),a  
43a8 3a b2 43			ld a, (.dmark+2)  
43ab 32 6d ee			ld (debug_mark+2),a  
43ae 18 03			jr .pastdmark  
43b0 ..			.dmark: db "TCd"  
43b3 f1			.pastdmark: pop af  
43b4			endm  
# End of macro DMARK
43b4						CALLMONITOR 
43b4 cd 6f ee			call debug_vector  
43b7				endm  
# End of macro CALLMONITOR
43b7					endif 
43b7					NEXTW 
43b7 c3 f3 1f			jp macro_next 
43ba				endm 
# End of macro NEXTW
43ba			 
43ba			.SUBSTR: 
43ba				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43ba 48				db WORD_SYS_CORE+52             
43bb 18 44			dw .LEFT            
43bd 07				db 6 + 1 
43be .. 00			db "SUBSTR",0              
43c5				endm 
# End of macro CWHEAD
43c5			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43c5			 
43c5					if DEBUG_FORTH_WORDS_KEY 
43c5						DMARK "SST" 
43c5 f5				push af  
43c6 3a da 43			ld a, (.dmark)  
43c9 32 6b ee			ld (debug_mark),a  
43cc 3a db 43			ld a, (.dmark+1)  
43cf 32 6c ee			ld (debug_mark+1),a  
43d2 3a dc 43			ld a, (.dmark+2)  
43d5 32 6d ee			ld (debug_mark+2),a  
43d8 18 03			jr .pastdmark  
43da ..			.dmark: db "SST"  
43dd f1			.pastdmark: pop af  
43de			endm  
# End of macro DMARK
43de						CALLMONITOR 
43de cd 6f ee			call debug_vector  
43e1				endm  
# End of macro CALLMONITOR
43e1					endif 
43e1			; TODO check string type 
43e1					FORTH_DSP_VALUEHL 
43e1 cd 3d 1e			call macro_dsp_valuehl 
43e4				endm 
# End of macro FORTH_DSP_VALUEHL
43e4			 
43e4 e5					push hl      ; string length 
43e5			 
43e5					FORTH_DSP_POP 
43e5 cd f5 1e			call macro_forth_dsp_pop 
43e8				endm 
# End of macro FORTH_DSP_POP
43e8			 
43e8					FORTH_DSP_VALUEHL 
43e8 cd 3d 1e			call macro_dsp_valuehl 
43eb				endm 
# End of macro FORTH_DSP_VALUEHL
43eb			 
43eb e5					push hl     ; start char 
43ec			 
43ec					FORTH_DSP_POP 
43ec cd f5 1e			call macro_forth_dsp_pop 
43ef				endm 
# End of macro FORTH_DSP_POP
43ef			 
43ef			 
43ef					FORTH_DSP_VALUE 
43ef cd 26 1e			call macro_forth_dsp_value 
43f2				endm 
# End of macro FORTH_DSP_VALUE
43f2			 
43f2 d1					pop de    ; get start post offset 
43f3			 
43f3 19					add hl, de    ; starting offset 
43f4			 
43f4 c1					pop bc 
43f5 c5					push bc      ; grab size of string 
43f6			 
43f6 e5					push hl    ; save string start  
43f7			 
43f7 26 00				ld h, 0 
43f9 69					ld l, c 
43fa 23					inc hl 
43fb 23					inc hl 
43fc			 
43fc cd ae 12				call malloc 
43ff				if DEBUG_FORTH_MALLOC_GUARD 
43ff cc 32 4d				call z,malloc_error 
4402				endif 
4402			 
4402 eb					ex de, hl      ; save malloc area for string copy 
4403 e1					pop hl    ; get back source 
4404 c1					pop bc    ; get length of string back 
4405			 
4405 d5					push de    ; save malloc area for after we push 
4406 ed b0				ldir     ; copy substr 
4408			 
4408			 
4408 eb					ex de, hl 
4409 3e 00				ld a, 0 
440b 77					ld (hl), a   ; term substr 
440c			 
440c					 
440c e1					pop hl    ; get malloc so we can push it 
440d e5					push hl   ; save so we can free it afterwards 
440e			 
440e cd b4 1c				call forth_push_str 
4411			 
4411 e1					pop hl 
4412 cd 78 13				call free 
4415			 
4415					 
4415					 
4415			 
4415			 
4415					NEXTW 
4415 c3 f3 1f			jp macro_next 
4418				endm 
# End of macro NEXTW
4418			 
4418			.LEFT: 
4418				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4418 48				db WORD_SYS_CORE+52             
4419 40 44			dw .RIGHT            
441b 05				db 4 + 1 
441c .. 00			db "LEFT",0              
4421				endm 
# End of macro CWHEAD
4421			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4421					if DEBUG_FORTH_WORDS_KEY 
4421						DMARK "LEF" 
4421 f5				push af  
4422 3a 36 44			ld a, (.dmark)  
4425 32 6b ee			ld (debug_mark),a  
4428 3a 37 44			ld a, (.dmark+1)  
442b 32 6c ee			ld (debug_mark+1),a  
442e 3a 38 44			ld a, (.dmark+2)  
4431 32 6d ee			ld (debug_mark+2),a  
4434 18 03			jr .pastdmark  
4436 ..			.dmark: db "LEF"  
4439 f1			.pastdmark: pop af  
443a			endm  
# End of macro DMARK
443a						CALLMONITOR 
443a cd 6f ee			call debug_vector  
443d				endm  
# End of macro CALLMONITOR
443d					endif 
443d			 
443d					NEXTW 
443d c3 f3 1f			jp macro_next 
4440				endm 
# End of macro NEXTW
4440			.RIGHT: 
4440				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4440 48				db WORD_SYS_CORE+52             
4441 69 44			dw .STR2NUM            
4443 06				db 5 + 1 
4444 .. 00			db "RIGHT",0              
444a				endm 
# End of macro CWHEAD
444a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
444a					if DEBUG_FORTH_WORDS_KEY 
444a						DMARK "RIG" 
444a f5				push af  
444b 3a 5f 44			ld a, (.dmark)  
444e 32 6b ee			ld (debug_mark),a  
4451 3a 60 44			ld a, (.dmark+1)  
4454 32 6c ee			ld (debug_mark+1),a  
4457 3a 61 44			ld a, (.dmark+2)  
445a 32 6d ee			ld (debug_mark+2),a  
445d 18 03			jr .pastdmark  
445f ..			.dmark: db "RIG"  
4462 f1			.pastdmark: pop af  
4463			endm  
# End of macro DMARK
4463						CALLMONITOR 
4463 cd 6f ee			call debug_vector  
4466				endm  
# End of macro CALLMONITOR
4466					endif 
4466			 
4466					NEXTW 
4466 c3 f3 1f			jp macro_next 
4469				endm 
# End of macro NEXTW
4469			 
4469			 
4469			.STR2NUM: 
4469				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4469 48				db WORD_SYS_CORE+52             
446a f5 44			dw .NUM2STR            
446c 08				db 7 + 1 
446d .. 00			db "STR2NUM",0              
4475				endm 
# End of macro CWHEAD
4475			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4475			 
4475			 
4475			; TODO STR type check to do 
4475					if DEBUG_FORTH_WORDS_KEY 
4475						DMARK "S2N" 
4475 f5				push af  
4476 3a 8a 44			ld a, (.dmark)  
4479 32 6b ee			ld (debug_mark),a  
447c 3a 8b 44			ld a, (.dmark+1)  
447f 32 6c ee			ld (debug_mark+1),a  
4482 3a 8c 44			ld a, (.dmark+2)  
4485 32 6d ee			ld (debug_mark+2),a  
4488 18 03			jr .pastdmark  
448a ..			.dmark: db "S2N"  
448d f1			.pastdmark: pop af  
448e			endm  
# End of macro DMARK
448e						CALLMONITOR 
448e cd 6f ee			call debug_vector  
4491				endm  
# End of macro CALLMONITOR
4491					endif 
4491			 
4491					;FORTH_DSP 
4491					FORTH_DSP_VALUE 
4491 cd 26 1e			call macro_forth_dsp_value 
4494				endm 
# End of macro FORTH_DSP_VALUE
4494					;inc hl 
4494			 
4494 eb					ex de, hl 
4495					if DEBUG_FORTH_WORDS 
4495						DMARK "S2a" 
4495 f5				push af  
4496 3a aa 44			ld a, (.dmark)  
4499 32 6b ee			ld (debug_mark),a  
449c 3a ab 44			ld a, (.dmark+1)  
449f 32 6c ee			ld (debug_mark+1),a  
44a2 3a ac 44			ld a, (.dmark+2)  
44a5 32 6d ee			ld (debug_mark+2),a  
44a8 18 03			jr .pastdmark  
44aa ..			.dmark: db "S2a"  
44ad f1			.pastdmark: pop af  
44ae			endm  
# End of macro DMARK
44ae						CALLMONITOR 
44ae cd 6f ee			call debug_vector  
44b1				endm  
# End of macro CALLMONITOR
44b1					endif 
44b1 cd dc 11				call string_to_uint16 
44b4			 
44b4					if DEBUG_FORTH_WORDS 
44b4						DMARK "S2b" 
44b4 f5				push af  
44b5 3a c9 44			ld a, (.dmark)  
44b8 32 6b ee			ld (debug_mark),a  
44bb 3a ca 44			ld a, (.dmark+1)  
44be 32 6c ee			ld (debug_mark+1),a  
44c1 3a cb 44			ld a, (.dmark+2)  
44c4 32 6d ee			ld (debug_mark+2),a  
44c7 18 03			jr .pastdmark  
44c9 ..			.dmark: db "S2b"  
44cc f1			.pastdmark: pop af  
44cd			endm  
# End of macro DMARK
44cd						CALLMONITOR 
44cd cd 6f ee			call debug_vector  
44d0				endm  
# End of macro CALLMONITOR
44d0					endif 
44d0			;		push hl 
44d0					FORTH_DSP_POP 
44d0 cd f5 1e			call macro_forth_dsp_pop 
44d3				endm 
# End of macro FORTH_DSP_POP
44d3			;		pop hl 
44d3					 
44d3					if DEBUG_FORTH_WORDS 
44d3						DMARK "S2b" 
44d3 f5				push af  
44d4 3a e8 44			ld a, (.dmark)  
44d7 32 6b ee			ld (debug_mark),a  
44da 3a e9 44			ld a, (.dmark+1)  
44dd 32 6c ee			ld (debug_mark+1),a  
44e0 3a ea 44			ld a, (.dmark+2)  
44e3 32 6d ee			ld (debug_mark+2),a  
44e6 18 03			jr .pastdmark  
44e8 ..			.dmark: db "S2b"  
44eb f1			.pastdmark: pop af  
44ec			endm  
# End of macro DMARK
44ec						CALLMONITOR 
44ec cd 6f ee			call debug_vector  
44ef				endm  
# End of macro CALLMONITOR
44ef					endif 
44ef cd 46 1c				call forth_push_numhl	 
44f2			 
44f2				 
44f2				       NEXTW 
44f2 c3 f3 1f			jp macro_next 
44f5				endm 
# End of macro NEXTW
44f5			.NUM2STR: 
44f5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44f5 48				db WORD_SYS_CORE+52             
44f6 04 45			dw .CONCAT            
44f8 08				db 7 + 1 
44f9 .. 00			db "NUM2STR",0              
4501				endm 
# End of macro CWHEAD
4501			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4501			 
4501			;		; malloc a string to target 
4501			;		ld hl, 10     ; TODO max string size should be fine 
4501			;		call malloc 
4501			;		push hl    ; save malloc location 
4501			; 
4501			; 
4501			;; TODO check int type 
4501			;		FORTH_DSP_VALUEHL 
4501			;		ld a, l 
4501			;		call DispAToASCII   
4501			;;TODO need to chage above call to dump into string 
4501			; 
4501			; 
4501			 
4501				       NEXTW 
4501 c3 f3 1f			jp macro_next 
4504				endm 
# End of macro NEXTW
4504			 
4504			.CONCAT: 
4504				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4504 48				db WORD_SYS_CORE+52             
4505 b7 45			dw .FIND            
4507 07				db 6 + 1 
4508 .. 00			db "CONCAT",0              
450f				endm 
# End of macro CWHEAD
450f			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
450f			 
450f			; TODO check string type 
450f			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
450f			 
450f					if DEBUG_FORTH_WORDS_KEY 
450f						DMARK "CON" 
450f f5				push af  
4510 3a 24 45			ld a, (.dmark)  
4513 32 6b ee			ld (debug_mark),a  
4516 3a 25 45			ld a, (.dmark+1)  
4519 32 6c ee			ld (debug_mark+1),a  
451c 3a 26 45			ld a, (.dmark+2)  
451f 32 6d ee			ld (debug_mark+2),a  
4522 18 03			jr .pastdmark  
4524 ..			.dmark: db "CON"  
4527 f1			.pastdmark: pop af  
4528			endm  
# End of macro DMARK
4528						CALLMONITOR 
4528 cd 6f ee			call debug_vector  
452b				endm  
# End of macro CALLMONITOR
452b					endif 
452b			 
452b			 
452b					FORTH_DSP_VALUE 
452b cd 26 1e			call macro_forth_dsp_value 
452e				endm 
# End of macro FORTH_DSP_VALUE
452e e5					push hl   ; s2 
452f			 
452f					FORTH_DSP_POP 
452f cd f5 1e			call macro_forth_dsp_pop 
4532				endm 
# End of macro FORTH_DSP_POP
4532			 
4532					FORTH_DSP_VALUE 
4532 cd 26 1e			call macro_forth_dsp_value 
4535				endm 
# End of macro FORTH_DSP_VALUE
4535			 
4535 e5					push hl   ; s1 
4536			 
4536					FORTH_DSP_POP 
4536 cd f5 1e			call macro_forth_dsp_pop 
4539				endm 
# End of macro FORTH_DSP_POP
4539					 
4539			 
4539					; copy s1 
4539			 
4539				 
4539					; save ptr 
4539 e1					pop hl  
453a e5					push hl 
453b 3e 00				ld a, 0 
453d cd 50 12				call strlent 
4540					;inc hl    ; zer0 
4540 06 00				ld b, 0 
4542 4d					ld c, l 
4543 e1					pop hl		 
4544 11 c1 e2				ld de, scratch	 
4547					if DEBUG_FORTH_WORDS 
4547						DMARK "CO1" 
4547 f5				push af  
4548 3a 5c 45			ld a, (.dmark)  
454b 32 6b ee			ld (debug_mark),a  
454e 3a 5d 45			ld a, (.dmark+1)  
4551 32 6c ee			ld (debug_mark+1),a  
4554 3a 5e 45			ld a, (.dmark+2)  
4557 32 6d ee			ld (debug_mark+2),a  
455a 18 03			jr .pastdmark  
455c ..			.dmark: db "CO1"  
455f f1			.pastdmark: pop af  
4560			endm  
# End of macro DMARK
4560						CALLMONITOR 
4560 cd 6f ee			call debug_vector  
4563				endm  
# End of macro CALLMONITOR
4563					endif 
4563 ed b0				ldir 
4565			 
4565 e1					pop hl 
4566 e5					push hl 
4567 d5					push de 
4568			 
4568			 
4568 3e 00				ld a, 0 
456a cd 50 12				call strlent 
456d 23					inc hl    ; zer0 
456e 23					inc hl 
456f 06 00				ld b, 0 
4571 4d					ld c, l 
4572 d1					pop de 
4573 e1					pop hl		 
4574					if DEBUG_FORTH_WORDS 
4574						DMARK "CO2" 
4574 f5				push af  
4575 3a 89 45			ld a, (.dmark)  
4578 32 6b ee			ld (debug_mark),a  
457b 3a 8a 45			ld a, (.dmark+1)  
457e 32 6c ee			ld (debug_mark+1),a  
4581 3a 8b 45			ld a, (.dmark+2)  
4584 32 6d ee			ld (debug_mark+2),a  
4587 18 03			jr .pastdmark  
4589 ..			.dmark: db "CO2"  
458c f1			.pastdmark: pop af  
458d			endm  
# End of macro DMARK
458d						CALLMONITOR 
458d cd 6f ee			call debug_vector  
4590				endm  
# End of macro CALLMONITOR
4590					endif 
4590 ed b0				ldir 
4592			 
4592			 
4592			 
4592 21 c1 e2				ld hl, scratch 
4595					if DEBUG_FORTH_WORDS 
4595						DMARK "CO5" 
4595 f5				push af  
4596 3a aa 45			ld a, (.dmark)  
4599 32 6b ee			ld (debug_mark),a  
459c 3a ab 45			ld a, (.dmark+1)  
459f 32 6c ee			ld (debug_mark+1),a  
45a2 3a ac 45			ld a, (.dmark+2)  
45a5 32 6d ee			ld (debug_mark+2),a  
45a8 18 03			jr .pastdmark  
45aa ..			.dmark: db "CO5"  
45ad f1			.pastdmark: pop af  
45ae			endm  
# End of macro DMARK
45ae						CALLMONITOR 
45ae cd 6f ee			call debug_vector  
45b1				endm  
# End of macro CALLMONITOR
45b1					endif 
45b1			 
45b1 cd b4 1c				call forth_push_str 
45b4			 
45b4			 
45b4			 
45b4			 
45b4				       NEXTW 
45b4 c3 f3 1f			jp macro_next 
45b7				endm 
# End of macro NEXTW
45b7			 
45b7			 
45b7			.FIND: 
45b7				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45b7 4b				db WORD_SYS_CORE+55             
45b8 75 46			dw .LEN            
45ba 05				db 4 + 1 
45bb .. 00			db "FIND",0              
45c0				endm 
# End of macro CWHEAD
45c0			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
45c0			 
45c0					if DEBUG_FORTH_WORDS_KEY 
45c0						DMARK "FND" 
45c0 f5				push af  
45c1 3a d5 45			ld a, (.dmark)  
45c4 32 6b ee			ld (debug_mark),a  
45c7 3a d6 45			ld a, (.dmark+1)  
45ca 32 6c ee			ld (debug_mark+1),a  
45cd 3a d7 45			ld a, (.dmark+2)  
45d0 32 6d ee			ld (debug_mark+2),a  
45d3 18 03			jr .pastdmark  
45d5 ..			.dmark: db "FND"  
45d8 f1			.pastdmark: pop af  
45d9			endm  
# End of macro DMARK
45d9						CALLMONITOR 
45d9 cd 6f ee			call debug_vector  
45dc				endm  
# End of macro CALLMONITOR
45dc					endif 
45dc			 
45dc			; TODO check string type 
45dc					FORTH_DSP_VALUE 
45dc cd 26 1e			call macro_forth_dsp_value 
45df				endm 
# End of macro FORTH_DSP_VALUE
45df			 
45df e5					push hl    
45e0 7e					ld a,(hl)    ; char to find   
45e1			; TODO change char to substr 
45e1			 
45e1 f5					push af 
45e2					 
45e2			 
45e2			 
45e2					if DEBUG_FORTH_WORDS 
45e2						DMARK "FN1" 
45e2 f5				push af  
45e3 3a f7 45			ld a, (.dmark)  
45e6 32 6b ee			ld (debug_mark),a  
45e9 3a f8 45			ld a, (.dmark+1)  
45ec 32 6c ee			ld (debug_mark+1),a  
45ef 3a f9 45			ld a, (.dmark+2)  
45f2 32 6d ee			ld (debug_mark+2),a  
45f5 18 03			jr .pastdmark  
45f7 ..			.dmark: db "FN1"  
45fa f1			.pastdmark: pop af  
45fb			endm  
# End of macro DMARK
45fb						CALLMONITOR 
45fb cd 6f ee			call debug_vector  
45fe				endm  
# End of macro CALLMONITOR
45fe					endif 
45fe			 
45fe					FORTH_DSP_POP 
45fe cd f5 1e			call macro_forth_dsp_pop 
4601				endm 
# End of macro FORTH_DSP_POP
4601			 
4601					; string to search 
4601			 
4601					FORTH_DSP_VALUE 
4601 cd 26 1e			call macro_forth_dsp_value 
4604				endm 
# End of macro FORTH_DSP_VALUE
4604			 
4604 d1					pop de  ; d is char to find  
4605			 
4605					if DEBUG_FORTH_WORDS 
4605						DMARK "FN2" 
4605 f5				push af  
4606 3a 1a 46			ld a, (.dmark)  
4609 32 6b ee			ld (debug_mark),a  
460c 3a 1b 46			ld a, (.dmark+1)  
460f 32 6c ee			ld (debug_mark+1),a  
4612 3a 1c 46			ld a, (.dmark+2)  
4615 32 6d ee			ld (debug_mark+2),a  
4618 18 03			jr .pastdmark  
461a ..			.dmark: db "FN2"  
461d f1			.pastdmark: pop af  
461e			endm  
# End of macro DMARK
461e						CALLMONITOR 
461e cd 6f ee			call debug_vector  
4621				endm  
# End of macro CALLMONITOR
4621					endif 
4621					 
4621 01 00 00				ld bc, 0 
4624 7e			.findchar:      ld a,(hl) 
4625 fe 00				cp 0   		 
4627 28 27				jr z, .finddone     
4629 ba					cp d 
462a 28 20				jr z, .foundchar 
462c 03					inc bc 
462d 23					inc hl 
462e					if DEBUG_FORTH_WORDS 
462e						DMARK "FN3" 
462e f5				push af  
462f 3a 43 46			ld a, (.dmark)  
4632 32 6b ee			ld (debug_mark),a  
4635 3a 44 46			ld a, (.dmark+1)  
4638 32 6c ee			ld (debug_mark+1),a  
463b 3a 45 46			ld a, (.dmark+2)  
463e 32 6d ee			ld (debug_mark+2),a  
4641 18 03			jr .pastdmark  
4643 ..			.dmark: db "FN3"  
4646 f1			.pastdmark: pop af  
4647			endm  
# End of macro DMARK
4647						CALLMONITOR 
4647 cd 6f ee			call debug_vector  
464a				endm  
# End of macro CALLMONITOR
464a					endif 
464a 18 d8				jr .findchar 
464c			 
464c			 
464c c5			.foundchar:	push bc 
464d e1					pop hl 
464e 18 03				jr .findexit 
4650			 
4650			 
4650							 
4650			 
4650			.finddone:     ; got to end of string with no find 
4650 21 00 00				ld hl, 0 
4653			.findexit: 
4653			 
4653					if DEBUG_FORTH_WORDS 
4653						DMARK "FNd" 
4653 f5				push af  
4654 3a 68 46			ld a, (.dmark)  
4657 32 6b ee			ld (debug_mark),a  
465a 3a 69 46			ld a, (.dmark+1)  
465d 32 6c ee			ld (debug_mark+1),a  
4660 3a 6a 46			ld a, (.dmark+2)  
4663 32 6d ee			ld (debug_mark+2),a  
4666 18 03			jr .pastdmark  
4668 ..			.dmark: db "FNd"  
466b f1			.pastdmark: pop af  
466c			endm  
# End of macro DMARK
466c						CALLMONITOR 
466c cd 6f ee			call debug_vector  
466f				endm  
# End of macro CALLMONITOR
466f					endif 
466f cd 46 1c			call forth_push_numhl 
4672			 
4672				       NEXTW 
4672 c3 f3 1f			jp macro_next 
4675				endm 
# End of macro NEXTW
4675			 
4675			.LEN: 
4675				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4675 4c				db WORD_SYS_CORE+56             
4676 df 46			dw .ASC            
4678 06				db 5 + 1 
4679 .. 00			db "COUNT",0              
467f				endm 
# End of macro CWHEAD
467f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
467f			 
467f					if DEBUG_FORTH_WORDS_KEY 
467f						DMARK "CNT" 
467f f5				push af  
4680 3a 94 46			ld a, (.dmark)  
4683 32 6b ee			ld (debug_mark),a  
4686 3a 95 46			ld a, (.dmark+1)  
4689 32 6c ee			ld (debug_mark+1),a  
468c 3a 96 46			ld a, (.dmark+2)  
468f 32 6d ee			ld (debug_mark+2),a  
4692 18 03			jr .pastdmark  
4694 ..			.dmark: db "CNT"  
4697 f1			.pastdmark: pop af  
4698			endm  
# End of macro DMARK
4698						CALLMONITOR 
4698 cd 6f ee			call debug_vector  
469b				endm  
# End of macro CALLMONITOR
469b					endif 
469b			; TODO check string type 
469b					FORTH_DSP_VALUE 
469b cd 26 1e			call macro_forth_dsp_value 
469e				endm 
# End of macro FORTH_DSP_VALUE
469e			 
469e			 
469e					if DEBUG_FORTH_WORDS 
469e						DMARK "CN?" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 6b ee			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 6c ee			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 6d ee			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "CN?"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd 6f ee			call debug_vector  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba cd 45 12				call strlenz 
46bd					if DEBUG_FORTH_WORDS 
46bd						DMARK "CNl" 
46bd f5				push af  
46be 3a d2 46			ld a, (.dmark)  
46c1 32 6b ee			ld (debug_mark),a  
46c4 3a d3 46			ld a, (.dmark+1)  
46c7 32 6c ee			ld (debug_mark+1),a  
46ca 3a d4 46			ld a, (.dmark+2)  
46cd 32 6d ee			ld (debug_mark+2),a  
46d0 18 03			jr .pastdmark  
46d2 ..			.dmark: db "CNl"  
46d5 f1			.pastdmark: pop af  
46d6			endm  
# End of macro DMARK
46d6						CALLMONITOR 
46d6 cd 6f ee			call debug_vector  
46d9				endm  
# End of macro CALLMONITOR
46d9					endif 
46d9			 
46d9 cd 46 1c				call forth_push_numhl 
46dc			 
46dc			 
46dc			 
46dc				       NEXTW 
46dc c3 f3 1f			jp macro_next 
46df				endm 
# End of macro NEXTW
46df			.ASC: 
46df				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46df 4d				db WORD_SYS_CORE+57             
46e0 4d 47			dw .CHR            
46e2 04				db 3 + 1 
46e3 .. 00			db "ASC",0              
46e7				endm 
# End of macro CWHEAD
46e7			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
46e7					if DEBUG_FORTH_WORDS_KEY 
46e7						DMARK "ASC" 
46e7 f5				push af  
46e8 3a fc 46			ld a, (.dmark)  
46eb 32 6b ee			ld (debug_mark),a  
46ee 3a fd 46			ld a, (.dmark+1)  
46f1 32 6c ee			ld (debug_mark+1),a  
46f4 3a fe 46			ld a, (.dmark+2)  
46f7 32 6d ee			ld (debug_mark+2),a  
46fa 18 03			jr .pastdmark  
46fc ..			.dmark: db "ASC"  
46ff f1			.pastdmark: pop af  
4700			endm  
# End of macro DMARK
4700						CALLMONITOR 
4700 cd 6f ee			call debug_vector  
4703				endm  
# End of macro CALLMONITOR
4703					endif 
4703					FORTH_DSP_VALUE 
4703 cd 26 1e			call macro_forth_dsp_value 
4706				endm 
# End of macro FORTH_DSP_VALUE
4706					;v5 FORTH_DSP_VALUE 
4706			;		inc hl      ; now at start of numeric as string 
4706			 
4706 e5					push hl 
4707			 
4707					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4707 cd f5 1e			call macro_forth_dsp_pop 
470a				endm 
# End of macro FORTH_DSP_POP
470a			 
470a e1					pop hl 
470b			 
470b					if DEBUG_FORTH_WORDS 
470b						DMARK "AS1" 
470b f5				push af  
470c 3a 20 47			ld a, (.dmark)  
470f 32 6b ee			ld (debug_mark),a  
4712 3a 21 47			ld a, (.dmark+1)  
4715 32 6c ee			ld (debug_mark+1),a  
4718 3a 22 47			ld a, (.dmark+2)  
471b 32 6d ee			ld (debug_mark+2),a  
471e 18 03			jr .pastdmark  
4720 ..			.dmark: db "AS1"  
4723 f1			.pastdmark: pop af  
4724			endm  
# End of macro DMARK
4724						CALLMONITOR 
4724 cd 6f ee			call debug_vector  
4727				endm  
# End of macro CALLMONITOR
4727					endif 
4727					; push the content of a onto the stack as a value 
4727			 
4727 7e					ld a,(hl)   ; get char 
4728 26 00				ld h,0 
472a 6f					ld l,a 
472b					if DEBUG_FORTH_WORDS 
472b						DMARK "AS2" 
472b f5				push af  
472c 3a 40 47			ld a, (.dmark)  
472f 32 6b ee			ld (debug_mark),a  
4732 3a 41 47			ld a, (.dmark+1)  
4735 32 6c ee			ld (debug_mark+1),a  
4738 3a 42 47			ld a, (.dmark+2)  
473b 32 6d ee			ld (debug_mark+2),a  
473e 18 03			jr .pastdmark  
4740 ..			.dmark: db "AS2"  
4743 f1			.pastdmark: pop af  
4744			endm  
# End of macro DMARK
4744						CALLMONITOR 
4744 cd 6f ee			call debug_vector  
4747				endm  
# End of macro CALLMONITOR
4747					endif 
4747 cd 46 1c				call forth_push_numhl 
474a			 
474a				       NEXTW 
474a c3 f3 1f			jp macro_next 
474d				endm 
# End of macro NEXTW
474d			 
474d			.CHR: 
474d				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
474d 4d				db WORD_SYS_CORE+57             
474e 89 47			dw .ENDSTR            
4750 04				db 3 + 1 
4751 .. 00			db "CHR",0              
4755				endm 
# End of macro CWHEAD
4755			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4755					if DEBUG_FORTH_WORDS_KEY 
4755						DMARK "CHR" 
4755 f5				push af  
4756 3a 6a 47			ld a, (.dmark)  
4759 32 6b ee			ld (debug_mark),a  
475c 3a 6b 47			ld a, (.dmark+1)  
475f 32 6c ee			ld (debug_mark+1),a  
4762 3a 6c 47			ld a, (.dmark+2)  
4765 32 6d ee			ld (debug_mark+2),a  
4768 18 03			jr .pastdmark  
476a ..			.dmark: db "CHR"  
476d f1			.pastdmark: pop af  
476e			endm  
# End of macro DMARK
476e						CALLMONITOR 
476e cd 6f ee			call debug_vector  
4771				endm  
# End of macro CALLMONITOR
4771					endif 
4771					FORTH_DSP_VALUEHL 
4771 cd 3d 1e			call macro_dsp_valuehl 
4774				endm 
# End of macro FORTH_DSP_VALUEHL
4774			 
4774					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4774 cd f5 1e			call macro_forth_dsp_pop 
4777				endm 
# End of macro FORTH_DSP_POP
4777			 
4777					; save asci byte as a zero term string and push string 
4777			 
4777 7d					ld a,l 
4778 32 c1 e2				ld (scratch), a 
477b			 
477b 3e 00				ld a, 0 
477d 32 c2 e2				ld (scratch+1), a 
4780			 
4780 21 c1 e2				ld hl, scratch 
4783 cd b4 1c				call forth_push_str 
4786			 
4786			 
4786				       NEXTW 
4786 c3 f3 1f			jp macro_next 
4789				endm 
# End of macro NEXTW
4789			 
4789			 
4789			 
4789			 
4789			.ENDSTR: 
4789			; eof 
4789			 
# End of file forth_words_str.asm
4789			include "forth_words_key.asm" 
4789			 
4789			; | ## Keyboard Words 
4789			 
4789			.KEY: 
4789				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4789 3e				db WORD_SYS_CORE+42             
478a b9 47			dw .WAITK            
478c 04				db 3 + 1 
478d .. 00			db "KEY",0              
4791				endm 
# End of macro CWHEAD
4791			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4791			 
4791					if DEBUG_FORTH_WORDS_KEY 
4791						DMARK "KEY" 
4791 f5				push af  
4792 3a a6 47			ld a, (.dmark)  
4795 32 6b ee			ld (debug_mark),a  
4798 3a a7 47			ld a, (.dmark+1)  
479b 32 6c ee			ld (debug_mark+1),a  
479e 3a a8 47			ld a, (.dmark+2)  
47a1 32 6d ee			ld (debug_mark+2),a  
47a4 18 03			jr .pastdmark  
47a6 ..			.dmark: db "KEY"  
47a9 f1			.pastdmark: pop af  
47aa			endm  
# End of macro DMARK
47aa						CALLMONITOR 
47aa cd 6f ee			call debug_vector  
47ad				endm  
# End of macro CALLMONITOR
47ad					endif 
47ad			; TODO currently waits 
47ad cd 77 65				call cin 
47b0					;call cin_wait 
47b0 6f					ld l, a 
47b1 26 00				ld h, 0 
47b3 cd 46 1c				call forth_push_numhl 
47b6					NEXTW 
47b6 c3 f3 1f			jp macro_next 
47b9				endm 
# End of macro NEXTW
47b9			.WAITK: 
47b9				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47b9 3f				db WORD_SYS_CORE+43             
47ba eb 47			dw .ACCEPT            
47bc 06				db 5 + 1 
47bd .. 00			db "WAITK",0              
47c3				endm 
# End of macro CWHEAD
47c3			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47c3					if DEBUG_FORTH_WORDS_KEY 
47c3						DMARK "WAI" 
47c3 f5				push af  
47c4 3a d8 47			ld a, (.dmark)  
47c7 32 6b ee			ld (debug_mark),a  
47ca 3a d9 47			ld a, (.dmark+1)  
47cd 32 6c ee			ld (debug_mark+1),a  
47d0 3a da 47			ld a, (.dmark+2)  
47d3 32 6d ee			ld (debug_mark+2),a  
47d6 18 03			jr .pastdmark  
47d8 ..			.dmark: db "WAI"  
47db f1			.pastdmark: pop af  
47dc			endm  
# End of macro DMARK
47dc						CALLMONITOR 
47dc cd 6f ee			call debug_vector  
47df				endm  
# End of macro CALLMONITOR
47df					endif 
47df cd 6f 65				call cin_wait 
47e2 6f					ld l, a 
47e3 26 00				ld h, 0 
47e5 cd 46 1c				call forth_push_numhl 
47e8					NEXTW 
47e8 c3 f3 1f			jp macro_next 
47eb				endm 
# End of macro NEXTW
47eb			.ACCEPT: 
47eb				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47eb 40				db WORD_SYS_CORE+44             
47ec 49 48			dw .EDIT            
47ee 07				db 6 + 1 
47ef .. 00			db "ACCEPT",0              
47f6				endm 
# End of macro CWHEAD
47f6			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47f6					; TODO crashes on push 
47f6					if DEBUG_FORTH_WORDS_KEY 
47f6						DMARK "ACC" 
47f6 f5				push af  
47f7 3a 0b 48			ld a, (.dmark)  
47fa 32 6b ee			ld (debug_mark),a  
47fd 3a 0c 48			ld a, (.dmark+1)  
4800 32 6c ee			ld (debug_mark+1),a  
4803 3a 0d 48			ld a, (.dmark+2)  
4806 32 6d ee			ld (debug_mark+2),a  
4809 18 03			jr .pastdmark  
480b ..			.dmark: db "ACC"  
480e f1			.pastdmark: pop af  
480f			endm  
# End of macro DMARK
480f						CALLMONITOR 
480f cd 6f ee			call debug_vector  
4812				endm  
# End of macro CALLMONITOR
4812					endif 
4812 21 bf e4				ld hl, os_input 
4815 3e 00				ld a, 0 
4817 77					ld (hl),a 
4818 3a 5e ea				ld a,(f_cursor_ptr) 
481b 16 64				ld d, 100 
481d 0e 00				ld c, 0 
481f 1e 28				ld e, 40 
4821 cd 14 0e				call input_str 
4824					; TODO perhaps do a type check and wrap in quotes if not a number 
4824 21 bf e4				ld hl, os_input 
4827					if DEBUG_FORTH_WORDS 
4827						DMARK "AC1" 
4827 f5				push af  
4828 3a 3c 48			ld a, (.dmark)  
482b 32 6b ee			ld (debug_mark),a  
482e 3a 3d 48			ld a, (.dmark+1)  
4831 32 6c ee			ld (debug_mark+1),a  
4834 3a 3e 48			ld a, (.dmark+2)  
4837 32 6d ee			ld (debug_mark+2),a  
483a 18 03			jr .pastdmark  
483c ..			.dmark: db "AC1"  
483f f1			.pastdmark: pop af  
4840			endm  
# End of macro DMARK
4840						CALLMONITOR 
4840 cd 6f ee			call debug_vector  
4843				endm  
# End of macro CALLMONITOR
4843					endif 
4843 cd b4 1c				call forth_push_str 
4846					NEXTW 
4846 c3 f3 1f			jp macro_next 
4849				endm 
# End of macro NEXTW
4849			 
4849			.EDIT: 
4849				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4849 40				db WORD_SYS_CORE+44             
484a eb 48			dw .DEDIT            
484c 05				db 4 + 1 
484d .. 00			db "EDIT",0              
4852				endm 
# End of macro CWHEAD
4852			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4852			 
4852					; TODO does not copy from stack 
4852					if DEBUG_FORTH_WORDS_KEY 
4852						DMARK "EDT" 
4852 f5				push af  
4853 3a 67 48			ld a, (.dmark)  
4856 32 6b ee			ld (debug_mark),a  
4859 3a 68 48			ld a, (.dmark+1)  
485c 32 6c ee			ld (debug_mark+1),a  
485f 3a 69 48			ld a, (.dmark+2)  
4862 32 6d ee			ld (debug_mark+2),a  
4865 18 03			jr .pastdmark  
4867 ..			.dmark: db "EDT"  
486a f1			.pastdmark: pop af  
486b			endm  
# End of macro DMARK
486b						CALLMONITOR 
486b cd 6f ee			call debug_vector  
486e				endm  
# End of macro CALLMONITOR
486e					endif 
486e			 
486e					;FORTH_DSP 
486e					FORTH_DSP_VALUEHL 
486e cd 3d 1e			call macro_dsp_valuehl 
4871				endm 
# End of macro FORTH_DSP_VALUEHL
4871			;		inc hl    ; TODO do type check 
4871			 
4871			;		call get_word_hl 
4871 e5					push hl 
4872					if DEBUG_FORTH_WORDS 
4872						DMARK "EDp" 
4872 f5				push af  
4873 3a 87 48			ld a, (.dmark)  
4876 32 6b ee			ld (debug_mark),a  
4879 3a 88 48			ld a, (.dmark+1)  
487c 32 6c ee			ld (debug_mark+1),a  
487f 3a 89 48			ld a, (.dmark+2)  
4882 32 6d ee			ld (debug_mark+2),a  
4885 18 03			jr .pastdmark  
4887 ..			.dmark: db "EDp"  
488a f1			.pastdmark: pop af  
488b			endm  
# End of macro DMARK
488b						CALLMONITOR 
488b cd 6f ee			call debug_vector  
488e				endm  
# End of macro CALLMONITOR
488e					endif 
488e				;	ld a, 0 
488e cd 45 12				call strlenz 
4891 23					inc hl 
4892			 
4892 06 00				ld b, 0 
4894 4d					ld c, l 
4895			 
4895 e1					pop hl 
4896 11 bf e4				ld de, os_input 
4899					if DEBUG_FORTH_WORDS_KEY 
4899						DMARK "EDc" 
4899 f5				push af  
489a 3a ae 48			ld a, (.dmark)  
489d 32 6b ee			ld (debug_mark),a  
48a0 3a af 48			ld a, (.dmark+1)  
48a3 32 6c ee			ld (debug_mark+1),a  
48a6 3a b0 48			ld a, (.dmark+2)  
48a9 32 6d ee			ld (debug_mark+2),a  
48ac 18 03			jr .pastdmark  
48ae ..			.dmark: db "EDc"  
48b1 f1			.pastdmark: pop af  
48b2			endm  
# End of macro DMARK
48b2						CALLMONITOR 
48b2 cd 6f ee			call debug_vector  
48b5				endm  
# End of macro CALLMONITOR
48b5					endif 
48b5 ed b0				ldir 
48b7			 
48b7			 
48b7 21 bf e4				ld hl, os_input 
48ba					;ld a, 0 
48ba					;ld (hl),a 
48ba 3a 5e ea				ld a,(f_cursor_ptr) 
48bd 16 64				ld d, 100 
48bf 0e 00				ld c, 0 
48c1 1e 28				ld e, 40 
48c3 cd 14 0e				call input_str 
48c6					; TODO perhaps do a type check and wrap in quotes if not a number 
48c6 21 bf e4				ld hl, os_input 
48c9					if DEBUG_FORTH_WORDS 
48c9						DMARK "ED1" 
48c9 f5				push af  
48ca 3a de 48			ld a, (.dmark)  
48cd 32 6b ee			ld (debug_mark),a  
48d0 3a df 48			ld a, (.dmark+1)  
48d3 32 6c ee			ld (debug_mark+1),a  
48d6 3a e0 48			ld a, (.dmark+2)  
48d9 32 6d ee			ld (debug_mark+2),a  
48dc 18 03			jr .pastdmark  
48de ..			.dmark: db "ED1"  
48e1 f1			.pastdmark: pop af  
48e2			endm  
# End of macro DMARK
48e2						CALLMONITOR 
48e2 cd 6f ee			call debug_vector  
48e5				endm  
# End of macro CALLMONITOR
48e5					endif 
48e5 cd b4 1c				call forth_push_str 
48e8					NEXTW 
48e8 c3 f3 1f			jp macro_next 
48eb				endm 
# End of macro NEXTW
48eb			 
48eb			.DEDIT: 
48eb				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48eb 40				db WORD_SYS_CORE+44             
48ec 4d 49			dw .ENDKEY            
48ee 06				db 5 + 1 
48ef .. 00			db "DEDIT",0              
48f5				endm 
# End of macro CWHEAD
48f5			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48f5			 
48f5					; TODO does not copy from stack 
48f5					if DEBUG_FORTH_WORDS_KEY 
48f5						DMARK "DED" 
48f5 f5				push af  
48f6 3a 0a 49			ld a, (.dmark)  
48f9 32 6b ee			ld (debug_mark),a  
48fc 3a 0b 49			ld a, (.dmark+1)  
48ff 32 6c ee			ld (debug_mark+1),a  
4902 3a 0c 49			ld a, (.dmark+2)  
4905 32 6d ee			ld (debug_mark+2),a  
4908 18 03			jr .pastdmark  
490a ..			.dmark: db "DED"  
490d f1			.pastdmark: pop af  
490e			endm  
# End of macro DMARK
490e						CALLMONITOR 
490e cd 6f ee			call debug_vector  
4911				endm  
# End of macro CALLMONITOR
4911					endif 
4911			 
4911					;FORTH_DSP 
4911					FORTH_DSP_VALUEHL 
4911 cd 3d 1e			call macro_dsp_valuehl 
4914				endm 
# End of macro FORTH_DSP_VALUEHL
4914			;		inc hl    ; TODO do type check 
4914			 
4914			;		call get_word_hl 
4914 e5					push hl 
4915 e5					push hl 
4916					FORTH_DSP_POP 
4916 cd f5 1e			call macro_forth_dsp_pop 
4919				endm 
# End of macro FORTH_DSP_POP
4919 e1					pop hl 
491a					if DEBUG_FORTH_WORDS 
491a						DMARK "EDp" 
491a f5				push af  
491b 3a 2f 49			ld a, (.dmark)  
491e 32 6b ee			ld (debug_mark),a  
4921 3a 30 49			ld a, (.dmark+1)  
4924 32 6c ee			ld (debug_mark+1),a  
4927 3a 31 49			ld a, (.dmark+2)  
492a 32 6d ee			ld (debug_mark+2),a  
492d 18 03			jr .pastdmark  
492f ..			.dmark: db "EDp"  
4932 f1			.pastdmark: pop af  
4933			endm  
# End of macro DMARK
4933						CALLMONITOR 
4933 cd 6f ee			call debug_vector  
4936				endm  
# End of macro CALLMONITOR
4936					endif 
4936				;	ld a, 0 
4936 cd 45 12				call strlenz 
4939 23					inc hl 
493a			 
493a 06 00				ld b, 0 
493c 4d					ld c, l 
493d			 
493d e1					pop hl 
493e			 
493e					;ld a, 0 
493e					;ld (hl),a 
493e 3a 5e ea				ld a,(f_cursor_ptr) 
4941 16 64				ld d, 100 
4943 0e 00				ld c, 0 
4945 1e 28				ld e, 40 
4947 cd 14 0e				call input_str 
494a					; TODO perhaps do a type check and wrap in quotes if not a number 
494a					NEXTW 
494a c3 f3 1f			jp macro_next 
494d				endm 
# End of macro NEXTW
494d			 
494d			 
494d			.ENDKEY: 
494d			; eof 
494d			 
# End of file forth_words_key.asm
494d			include "forth_words_const.asm" 
494d			 
494d			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
494d			 
494d			 
494d			.SPITIME: 
494d				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
494d 77				db WORD_SYS_CORE+99             
494e 62 49			dw .VA            
4950 08				db 7 + 1 
4951 .. 00			db "SPITIME",0              
4959				endm 
# End of macro CWHEAD
4959			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4959			; 
4959			; | If using BANK devices then leave as is. 
4959			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4959			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4959			 
4959 21 64 ea				ld hl, spi_clktime  
495c cd 46 1c				call forth_push_numhl 
495f			 
495f					NEXTW 
495f c3 f3 1f			jp macro_next 
4962				endm 
# End of macro NEXTW
4962			 
4962			 
4962			.VA: 
4962				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4962 77				db WORD_SYS_CORE+99             
4963 72 49			dw .SYMBOL            
4965 03				db 2 + 1 
4966 .. 00			db "VA",0              
4969				endm 
# End of macro CWHEAD
4969			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4969 21 28 ea				ld hl, cli_var_array 
496c cd 46 1c				call forth_push_numhl 
496f			 
496f					NEXTW 
496f c3 f3 1f			jp macro_next 
4972				endm 
# End of macro NEXTW
4972			 
4972			.SYMBOL: 
4972				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4972 77				db WORD_SYS_CORE+99             
4973 7c 4a			dw .ENDCONST            
4975 07				db 6 + 1 
4976 .. 00			db "SYMBOL",0              
497d				endm 
# End of macro CWHEAD
497d			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
497d			; | 
497d			; | The value is the number reference and the final address is pushed to stack 
497d			 
497d			; | dw sym_table 
497d			; | dw nmi_vector 
497d			; | dw cli_autodisplay 
497d			; | dw cli_data_sp 
497d			; | dw cli_data_stack 
497d			; | dw cli_loop_sp 
497d			; | dw cli_loop_stack 
497d			; | dw cli_var_array 
497d			; | dw cursor_col 
497d			; | dw cursor_ptr 
497d			; | ; 10 
497d			; | dw cursor_row 
497d			; | dw debug_mark 
497d			; | dw display_fb0 
497d			; | dw display_fb1 
497d			; | dw display_fb2 
497d			; | dw display_fb3 
497d			; | dw display_fb_active 
497d			; | dw execscratch 
497d			; | dw f_cursor_ptr 
497d			; | dw hardware_word 
497d			; | ;20 
497d			; | dw input_at_cursor 
497d			; | dw input_at_pos 
497d			; | dw input_cur_flash 
497d			; | dw input_cur_onoff 
497d			; | dw input_cursor 
497d			; | dw input_display_size 
497d			; | dw input_len 
497d			; | dw input_ptr 
497d			; | dw input_size 
497d			; | dw input_start 
497d			; | ; 30 
497d			; | dw input_str 
497d			; | dw input_under_cursor 
497d			; | dw os_cli_cmd 
497d			; | dw os_cur_ptr 
497d			; | dw os_current_i 
497d			; | dw os_input 
497d			; | dw os_last_cmd 
497d			; | dw os_last_new_uword 
497d			; | dw debug_vector 
497d			; | dw os_view_hl 
497d			; | ;40 
497d			; | dw os_word_scratch 
497d			; | dw portbctl 
497d			; | dw portbdata 
497d			; | dw spi_cartdev 
497d			; | dw spi_cartdev2 
497d			; | dw spi_clktime 
497d			; | dw spi_device 
497d			; | dw spi_device_id 
497d			; | dw spi_portbyte 
497d			; | dw stackstore 
497d			; | ; 50 
497d			; | if STORAGE_SE 
497d			; | dw storage_actl 
497d			; | dw storage_adata 
497d			; | else 
497d			; | dw 0 
497d			; | dw 0 
497d			; | endif 
497d			; | dw storage_append 
497d			; | if STORAGE_SE 
497d			; | dw storage_bctl 
497d			; | else 
497d			; | dw 0 
497d			; | endif 
497d			; | dw store_bank_active 
497d			; | dw store_filecache 
497d			; | dw store_longread 
497d			; | dw store_openaddr 
497d			; | dw store_openext 
497d			; | dw store_openmaxext 
497d			; | ; 60 
497d			; | dw store_page 
497d			; | dw store_readbuf 
497d			; | dw store_readcont 
497d			; | dw store_readptr 
497d			; | dw store_tmpext 
497d			; | dw store_tmpid 
497d			; | dw store_tmppageid 
497d			; | dw malloc 
497d			; | dw free 
497d			; | dw cin 
497d			; | ; 70 
497d			; | dw cin_wait 
497d			; | dw forth_push_numhl 
497d			; | dw forth_push_str 
497d			 
497d					if DEBUG_FORTH_WORDS_KEY 
497d						DMARK "SYM" 
497d f5				push af  
497e 3a 92 49			ld a, (.dmark)  
4981 32 6b ee			ld (debug_mark),a  
4984 3a 93 49			ld a, (.dmark+1)  
4987 32 6c ee			ld (debug_mark+1),a  
498a 3a 94 49			ld a, (.dmark+2)  
498d 32 6d ee			ld (debug_mark+2),a  
4990 18 03			jr .pastdmark  
4992 ..			.dmark: db "SYM"  
4995 f1			.pastdmark: pop af  
4996			endm  
# End of macro DMARK
4996						CALLMONITOR 
4996 cd 6f ee			call debug_vector  
4999				endm  
# End of macro CALLMONITOR
4999					endif 
4999			 
4999					FORTH_DSP_VALUEHL 
4999 cd 3d 1e			call macro_dsp_valuehl 
499c				endm 
# End of macro FORTH_DSP_VALUEHL
499c			 
499c 7d					ld a, l     
499d			 
499d			 
499d					if DEBUG_FORTH_WORDS 
499d						DMARK "SY1" 
499d f5				push af  
499e 3a b2 49			ld a, (.dmark)  
49a1 32 6b ee			ld (debug_mark),a  
49a4 3a b3 49			ld a, (.dmark+1)  
49a7 32 6c ee			ld (debug_mark+1),a  
49aa 3a b4 49			ld a, (.dmark+2)  
49ad 32 6d ee			ld (debug_mark+2),a  
49b0 18 03			jr .pastdmark  
49b2 ..			.dmark: db "SY1"  
49b5 f1			.pastdmark: pop af  
49b6			endm  
# End of macro DMARK
49b6						CALLMONITOR 
49b6 cd 6f ee			call debug_vector  
49b9				endm  
# End of macro CALLMONITOR
49b9					endif 
49b9					 
49b9 f5					push af	 
49ba					FORTH_DSP_POP 
49ba cd f5 1e			call macro_forth_dsp_pop 
49bd				endm 
# End of macro FORTH_DSP_POP
49bd f1					pop af 
49be			 
49be cb 27				sla a  
49c0				 
49c0					 
49c0					if DEBUG_FORTH_WORDS 
49c0						DMARK "SY" 
49c0 f5				push af  
49c1 3a d5 49			ld a, (.dmark)  
49c4 32 6b ee			ld (debug_mark),a  
49c7 3a d6 49			ld a, (.dmark+1)  
49ca 32 6c ee			ld (debug_mark+1),a  
49cd 3a d7 49			ld a, (.dmark+2)  
49d0 32 6d ee			ld (debug_mark+2),a  
49d3 18 02			jr .pastdmark  
49d5 ..			.dmark: db "SY"  
49d7 f1			.pastdmark: pop af  
49d8			endm  
# End of macro DMARK
49d8						CALLMONITOR 
49d8 cd 6f ee			call debug_vector  
49db				endm  
# End of macro CALLMONITOR
49db					endif 
49db			 
49db 21 ea 49				ld hl, sym_table 
49de cd e7 0d				call addatohl 
49e1 cd 75 1f				call loadwordinhl 
49e4 cd 46 1c				call forth_push_numhl 
49e7			 
49e7			 
49e7				       NEXTW 
49e7 c3 f3 1f			jp macro_next 
49ea				endm 
# End of macro NEXTW
49ea			 
49ea			sym_table: 
49ea			 
49ea			; 0 
49ea ea 49		dw sym_table 
49ec 72 ee		dw nmi_vector 
49ee 3c ea		dw cli_autodisplay 
49f0 ee e9		dw cli_data_sp 
49f2 28 e8		dw cli_data_stack 
49f4 f0 e9		dw cli_loop_sp 
49f6 2a e9		dw cli_loop_stack 
49f8 28 ea		dw cli_var_array 
49fa c5 eb		dw cursor_col 
49fc c3 eb		dw cursor_ptr 
49fe			; 10 
49fe c4 eb		dw cursor_row 
4a00 6b ee		dw debug_mark 
4a02 b1 ed		dw display_fb0 
4a04 10 ed		dw display_fb1 
4a06 ce eb		dw display_fb2 
4a08 6f ec		dw display_fb3 
4a0a cc eb		dw display_fb_active 
4a0c c0 e3		dw execscratch 
4a0e 5e ea		dw f_cursor_ptr 
4a10 75 ee		dw hardware_word 
4a12			;20 
4a12 62 ee		dw input_at_cursor 
4a14 64 ee		dw input_at_pos 
4a16 60 ee		dw input_cur_flash 
4a18 5f ee		dw input_cur_onoff 
4a1a 55 ee		dw input_cursor 
4a1c 65 ee		dw input_display_size 
4a1e 5a ee		dw input_len 
4a20 69 ee		dw input_ptr 
4a22 66 ee		dw input_size 
4a24 67 ee		dw input_start 
4a26			; 30 
4a26 14 0e		dw input_str 
4a28 63 ee		dw input_under_cursor 
4a2a e8 e5		dw os_cli_cmd 
4a2c e4 e5		dw os_cur_ptr 
4a2e e6 e5		dw os_current_i 
4a30 bf e4		dw os_input 
4a32 e7 e6		dw os_last_cmd 
4a34 be e5		dw os_last_new_uword 
4a36 6f ee		dw debug_vector 
4a38 af e2		dw os_view_hl 
4a3a			;40 
4a3a c6 e5		dw os_word_scratch 
4a3c c3 00		dw portbctl 
4a3e c1 00		dw portbdata 
4a40 63 ea		dw spi_cartdev 
4a42 62 ea		dw spi_cartdev2 
4a44 64 ea		dw spi_clktime 
4a46 60 ea		dw spi_device 
4a48 5f ea		dw spi_device_id 
4a4a 61 ea		dw spi_portbyte 
4a4c a7 eb		dw stackstore 
4a4e			; 50 
4a4e			if STORAGE_SE 
4a4e			dw storage_actl 
4a4e			dw storage_adata 
4a4e			else 
4a4e 00 00		dw 0 
4a50 00 00		dw 0 
4a52			endif 
4a52 69 09		dw storage_append 
4a54			if STORAGE_SE 
4a54			dw storage_bctl 
4a54			else 
4a54 00 00		dw 0 
4a56			endif 
4a56 93 eb		dw store_bank_active 
4a58 67 ea		dw store_filecache 
4a5a 75 ea		dw store_longread 
4a5c 6b ea		dw store_openaddr 
4a5e 6a ea		dw store_openext 
4a60 69 ea		dw store_openmaxext 
4a62			; 60 
4a62 7a ea		dw store_page 
4a64 76 ea		dw store_readbuf 
4a66 6d ea		dw store_readcont 
4a68 78 ea		dw store_readptr 
4a6a 6d ea		dw store_tmpext 
4a6c 6e ea		dw store_tmpid 
4a6e 65 ea		dw store_tmppageid 
4a70 ae 12		dw malloc 
4a72 78 13		dw free 
4a74 77 65		dw cin 
4a76			; 70 
4a76 6f 65		dw cin_wait 
4a78 46 1c		dw forth_push_numhl 
4a7a b4 1c		dw forth_push_str 
4a7c			 
4a7c			 
4a7c			.ENDCONST: 
4a7c			 
4a7c			; eof 
4a7c			 
4a7c			 
# End of file forth_words_const.asm
4a7c			 
4a7c			if STORAGE_SE 
4a7c			   	include "forth_words_storage.asm" 
4a7c			endif 
4a7c				include "forth_words_device.asm" 
4a7c			; Device related words 
4a7c			 
4a7c			; | ## Device Words 
4a7c			 
4a7c			;if SOUND_ENABLE 
4a7c			;.NOTE: 
4a7c			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a7c			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a7c			;		if DEBUG_FORTH_WORDS_KEY 
4a7c			;			DMARK "NTE" 
4a7c			;			CALLMONITOR 
4a7c			;		endif 
4a7c			; 
4a7c			;	 
4a7c			; 
4a7c			;		NEXTW 
4a7c			;.AFTERSOUND: 
4a7c			;endif 
4a7c			 
4a7c			 
4a7c			USE_GPIO: equ 0 
4a7c			 
4a7c			if USE_GPIO 
4a7c			.GP1: 
4a7c				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a7c			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a7c					NEXTW 
4a7c			.GP2: 
4a7c				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a7c			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a7c			 
4a7c					NEXTW 
4a7c			 
4a7c			.GP3: 
4a7c				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a7c			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a7c			 
4a7c					NEXTW 
4a7c			 
4a7c			.GP4: 
4a7c				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a7c			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a7c			 
4a7c					NEXTW 
4a7c			.SIN: 
4a7c			 
4a7c			 
4a7c			endif 
4a7c			 
4a7c			 
4a7c				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a7c 33				db WORD_SYS_CORE+31             
4a7d b1 4a			dw .SOUT            
4a7f 03				db 2 + 1 
4a80 .. 00			db "IN",0              
4a83				endm 
# End of macro CWHEAD
4a83			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a83					if DEBUG_FORTH_WORDS_KEY 
4a83						DMARK "IN." 
4a83 f5				push af  
4a84 3a 98 4a			ld a, (.dmark)  
4a87 32 6b ee			ld (debug_mark),a  
4a8a 3a 99 4a			ld a, (.dmark+1)  
4a8d 32 6c ee			ld (debug_mark+1),a  
4a90 3a 9a 4a			ld a, (.dmark+2)  
4a93 32 6d ee			ld (debug_mark+2),a  
4a96 18 03			jr .pastdmark  
4a98 ..			.dmark: db "IN."  
4a9b f1			.pastdmark: pop af  
4a9c			endm  
# End of macro DMARK
4a9c						CALLMONITOR 
4a9c cd 6f ee			call debug_vector  
4a9f				endm  
# End of macro CALLMONITOR
4a9f					endif 
4a9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a9f cd 3d 1e			call macro_dsp_valuehl 
4aa2				endm 
# End of macro FORTH_DSP_VALUEHL
4aa2			 
4aa2 e5					push hl 
4aa3			 
4aa3					; destroy value TOS 
4aa3			 
4aa3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aa3 cd f5 1e			call macro_forth_dsp_pop 
4aa6				endm 
# End of macro FORTH_DSP_POP
4aa6			 
4aa6					; one value on hl get other one back 
4aa6			 
4aa6 c1					pop bc 
4aa7			 
4aa7					; do the sub 
4aa7			;		ex de, hl 
4aa7			 
4aa7 ed 68				in l,(c) 
4aa9			 
4aa9					; save it 
4aa9			 
4aa9 26 00				ld h,0 
4aab			 
4aab					; TODO push value back onto stack for another op etc 
4aab			 
4aab cd 46 1c				call forth_push_numhl 
4aae					NEXTW 
4aae c3 f3 1f			jp macro_next 
4ab1				endm 
# End of macro NEXTW
4ab1			.SOUT: 
4ab1				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ab1 34				db WORD_SYS_CORE+32             
4ab2 04 4b			dw .SPIO            
4ab4 04				db 3 + 1 
4ab5 .. 00			db "OUT",0              
4ab9				endm 
# End of macro CWHEAD
4ab9			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ab9					if DEBUG_FORTH_WORDS_KEY 
4ab9						DMARK "OUT" 
4ab9 f5				push af  
4aba 3a ce 4a			ld a, (.dmark)  
4abd 32 6b ee			ld (debug_mark),a  
4ac0 3a cf 4a			ld a, (.dmark+1)  
4ac3 32 6c ee			ld (debug_mark+1),a  
4ac6 3a d0 4a			ld a, (.dmark+2)  
4ac9 32 6d ee			ld (debug_mark+2),a  
4acc 18 03			jr .pastdmark  
4ace ..			.dmark: db "OUT"  
4ad1 f1			.pastdmark: pop af  
4ad2			endm  
# End of macro DMARK
4ad2						CALLMONITOR 
4ad2 cd 6f ee			call debug_vector  
4ad5				endm  
# End of macro CALLMONITOR
4ad5					endif 
4ad5			 
4ad5					; get port 
4ad5			 
4ad5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ad5 cd 3d 1e			call macro_dsp_valuehl 
4ad8				endm 
# End of macro FORTH_DSP_VALUEHL
4ad8			 
4ad8 e5					push hl 
4ad9			 
4ad9					; destroy value TOS 
4ad9			 
4ad9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ad9 cd f5 1e			call macro_forth_dsp_pop 
4adc				endm 
# End of macro FORTH_DSP_POP
4adc			 
4adc					; get byte to send 
4adc			 
4adc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4adc cd 3d 1e			call macro_dsp_valuehl 
4adf				endm 
# End of macro FORTH_DSP_VALUEHL
4adf			 
4adf			;		push hl 
4adf			 
4adf					; destroy value TOS 
4adf			 
4adf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4adf cd f5 1e			call macro_forth_dsp_pop 
4ae2				endm 
# End of macro FORTH_DSP_POP
4ae2			 
4ae2					; one value on hl get other one back 
4ae2			 
4ae2			;		pop hl 
4ae2			 
4ae2 c1					pop bc 
4ae3			 
4ae3					if DEBUG_FORTH_WORDS 
4ae3						DMARK "OUT" 
4ae3 f5				push af  
4ae4 3a f8 4a			ld a, (.dmark)  
4ae7 32 6b ee			ld (debug_mark),a  
4aea 3a f9 4a			ld a, (.dmark+1)  
4aed 32 6c ee			ld (debug_mark+1),a  
4af0 3a fa 4a			ld a, (.dmark+2)  
4af3 32 6d ee			ld (debug_mark+2),a  
4af6 18 03			jr .pastdmark  
4af8 ..			.dmark: db "OUT"  
4afb f1			.pastdmark: pop af  
4afc			endm  
# End of macro DMARK
4afc						CALLMONITOR 
4afc cd 6f ee			call debug_vector  
4aff				endm  
# End of macro CALLMONITOR
4aff					endif 
4aff			 
4aff ed 69				out (c), l 
4b01			 
4b01					NEXTW 
4b01 c3 f3 1f			jp macro_next 
4b04				endm 
# End of macro NEXTW
4b04			 
4b04			 
4b04			.SPIO: 
4b04			 
4b04			if STORAGE_SE 
4b04				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b04			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b04			 
4b04					call spi_ce_low 
4b04			    NEXTW 
4b04			 
4b04			.SPICEH: 
4b04				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b04			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b04			 
4b04					call spi_ce_high 
4b04			    NEXTW 
4b04			 
4b04			 
4b04			.SPIOb: 
4b04			 
4b04				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b04			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b04			 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "SPo" 
4b04						CALLMONITOR 
4b04					endif 
4b04					; get port 
4b04			 
4b04			 
4b04					; get byte to send 
4b04			 
4b04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b04			 
4b04			;		push hl    ; u1  
4b04			 
4b04					; destroy value TOS 
4b04			 
4b04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b04			 
4b04					; one value on hl get other one back 
4b04			 
4b04			;		pop hl   ; u2 - addr 
4b04			 
4b04					; TODO Send SPI byte 
4b04			 
4b04			;		push hl 
4b04			;		call spi_ce_low 
4b04			;		pop hl 
4b04					ld a, l 
4b04					call spi_send_byte 
4b04			;		call spi_ce_high 
4b04			 
4b04					NEXTW 
4b04			 
4b04			.SPII: 
4b04				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b04			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "SPi" 
4b04						CALLMONITOR 
4b04					endif 
4b04			 
4b04					; TODO Get SPI byte 
4b04			 
4b04					call spi_read_byte 
4b04			 
4b04					if DEBUG_FORTH_WORDS 
4b04						DMARK "Si2" 
4b04						CALLMONITOR 
4b04					endif 
4b04					ld h, 0 
4b04					ld l, a 
4b04					if DEBUG_FORTH_WORDS 
4b04						DMARK "Si3" 
4b04						CALLMONITOR 
4b04					endif 
4b04					call forth_push_numhl 
4b04			 
4b04					NEXTW 
4b04			 
4b04			 
4b04			 
4b04			.SESEL: 
4b04				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b04			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "BNK" 
4b04						CALLMONITOR 
4b04					endif 
4b04			 
4b04					ld a, 255 
4b04					ld (spi_cartdev), a 
4b04			 
4b04					; get bank 
4b04			 
4b04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b04			 
4b04			;		push hl 
4b04			 
4b04					; destroy value TOS 
4b04			 
4b04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b04			 
4b04					; one value on hl get other one back 
4b04			 
4b04			;		pop hl 
4b04			 
4b04			 
4b04					ld c, SPI_CE_HIGH 
4b04					ld b, '0'    ; human readable bank number 
4b04			 
4b04					ld a, l 
4b04			 
4b04					if DEBUG_FORTH_WORDS 
4b04						DMARK "BNK" 
4b04						CALLMONITOR 
4b04					endif 
4b04			 
4b04					; active low 
4b04			 
4b04					cp 0 
4b04					jr z, .bset 
4b04					cp 1 
4b04					jr nz, .b2 
4b04					res 0, c 
4b04					ld b, '1'    ; human readable bank number 
4b04			.b2:		cp 2 
4b04					jr nz, .b3 
4b04					res 1, c 
4b04					ld b, '2'    ; human readable bank number 
4b04			.b3:		cp 3 
4b04					jr nz, .b4 
4b04					res 2, c 
4b04					ld b, '3'    ; human readable bank number 
4b04			.b4:		cp 4 
4b04					jr nz, .b5 
4b04					res 3, c 
4b04					ld b, '4'    ; human readable bank number 
4b04			.b5:		cp 5 
4b04					jr nz, .bset 
4b04					res 4, c 
4b04					ld b, '5'    ; human readable bank number 
4b04			 
4b04			.bset: 
4b04					ld a, c 
4b04					ld (spi_device),a 
4b04					ld a, b 
4b04					ld (spi_device_id),a 
4b04					if DEBUG_FORTH_WORDS 
4b04						DMARK "BN2" 
4b04						CALLMONITOR 
4b04					endif 
4b04			 
4b04					; set default SPI clk pulse time as disabled for BANK use 
4b04			 
4b04					ld a, 0 
4b04					ld (spi_clktime), a 
4b04			 
4b04					NEXTW 
4b04			 
4b04			.CARTDEV: 
4b04				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b04			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "CDV" 
4b04						CALLMONITOR 
4b04					endif 
4b04			 
4b04					; disable se storage bank selection 
4b04			 
4b04					ld a, SPI_CE_HIGH		; ce high 
4b04					ld (spi_device), a 
4b04			 
4b04					; get bank 
4b04			 
4b04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b04			 
4b04			;		push hl 
4b04			 
4b04					; destroy value TOS 
4b04			 
4b04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b04			 
4b04					; one value on hl get other one back 
4b04			 
4b04			;		pop hl 
4b04			 
4b04					; active low 
4b04			 
4b04					ld c, 255 
4b04			 
4b04					ld a, l 
4b04					if DEBUG_FORTH_WORDS 
4b04						DMARK "CDV" 
4b04						CALLMONITOR 
4b04					endif 
4b04					cp 0 
4b04					jr z, .cset 
4b04					cp 1 
4b04					jr nz, .c2 
4b04					res 0, c 
4b04			.c2:		cp 2 
4b04					jr nz, .c3 
4b04					res 1, c 
4b04			.c3:		cp 3 
4b04					jr nz, .c4 
4b04					res 2, c 
4b04			.c4:		cp 4 
4b04					jr nz, .c5 
4b04					res 3, c 
4b04			.c5:		cp 5 
4b04					jr nz, .c6 
4b04					res 4, c 
4b04			.c6:		cp 6 
4b04					jr nz, .c7 
4b04					res 5, c 
4b04			.c7:		cp 7 
4b04					jr nz, .c8 
4b04					res 6, c 
4b04			.c8:		cp 8 
4b04					jr nz, .cset 
4b04					res 7, c 
4b04			.cset:		ld a, c 
4b04					ld (spi_cartdev),a 
4b04			 
4b04					if DEBUG_FORTH_WORDS 
4b04						DMARK "CD2" 
4b04						CALLMONITOR 
4b04					endif 
4b04			 
4b04					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b04			 
4b04					ld a, $0a 
4b04					ld (spi_clktime), a 
4b04					NEXTW 
4b04			endif 
4b04			 
4b04			.ENDDEVICE: 
4b04			; eof 
4b04			 
# End of file forth_words_device.asm
4b04			 
4b04			; var handler 
4b04			 
4b04			 
4b04			.VARS: 
4b04				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b04 77				db WORD_SYS_CORE+99             
4b05 b5 4b			dw .V0            
4b07 04				db 3 + 1 
4b08 .. 00			db "VAR",0              
4b0c				endm 
# End of macro CWHEAD
4b0c			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b0c			;| 
4b0c			;| The variable name should consist of a single letter. e.g. "a" 
4b0c			;! If a full string is passed then only the first char is looked at 
4b0c			;| Any other char could exceed bounds checks!  
4b0c			 
4b0c					if DEBUG_FORTH_WORDS_KEY 
4b0c						DMARK "VAR" 
4b0c f5				push af  
4b0d 3a 21 4b			ld a, (.dmark)  
4b10 32 6b ee			ld (debug_mark),a  
4b13 3a 22 4b			ld a, (.dmark+1)  
4b16 32 6c ee			ld (debug_mark+1),a  
4b19 3a 23 4b			ld a, (.dmark+2)  
4b1c 32 6d ee			ld (debug_mark+2),a  
4b1f 18 03			jr .pastdmark  
4b21 ..			.dmark: db "VAR"  
4b24 f1			.pastdmark: pop af  
4b25			endm  
# End of macro DMARK
4b25						CALLMONITOR 
4b25 cd 6f ee			call debug_vector  
4b28				endm  
# End of macro CALLMONITOR
4b28					endif 
4b28			 
4b28					FORTH_DSP_VALUEHL 
4b28 cd 3d 1e			call macro_dsp_valuehl 
4b2b				endm 
# End of macro FORTH_DSP_VALUEHL
4b2b			 
4b2b 7e					ld a, (hl)    ; get first char on of the string 
4b2c			 
4b2c			 
4b2c					if DEBUG_FORTH_WORDS 
4b2c						DMARK "VR1" 
4b2c f5				push af  
4b2d 3a 41 4b			ld a, (.dmark)  
4b30 32 6b ee			ld (debug_mark),a  
4b33 3a 42 4b			ld a, (.dmark+1)  
4b36 32 6c ee			ld (debug_mark+1),a  
4b39 3a 43 4b			ld a, (.dmark+2)  
4b3c 32 6d ee			ld (debug_mark+2),a  
4b3f 18 03			jr .pastdmark  
4b41 ..			.dmark: db "VR1"  
4b44 f1			.pastdmark: pop af  
4b45			endm  
# End of macro DMARK
4b45						CALLMONITOR 
4b45 cd 6f ee			call debug_vector  
4b48				endm  
# End of macro CALLMONITOR
4b48					endif 
4b48					 
4b48 f5					push af	 
4b49					FORTH_DSP_POP 
4b49 cd f5 1e			call macro_forth_dsp_pop 
4b4c				endm 
# End of macro FORTH_DSP_POP
4b4c f1					pop af 
4b4d			 
4b4d					; convert to upper 
4b4d			 
4b4d cd 54 11				call to_upper 
4b50					if DEBUG_FORTH_WORDS 
4b50						DMARK "Vaa" 
4b50 f5				push af  
4b51 3a 65 4b			ld a, (.dmark)  
4b54 32 6b ee			ld (debug_mark),a  
4b57 3a 66 4b			ld a, (.dmark+1)  
4b5a 32 6c ee			ld (debug_mark+1),a  
4b5d 3a 67 4b			ld a, (.dmark+2)  
4b60 32 6d ee			ld (debug_mark+2),a  
4b63 18 03			jr .pastdmark  
4b65 ..			.dmark: db "Vaa"  
4b68 f1			.pastdmark: pop af  
4b69			endm  
# End of macro DMARK
4b69						CALLMONITOR 
4b69 cd 6f ee			call debug_vector  
4b6c				endm  
# End of macro CALLMONITOR
4b6c					endif 
4b6c 06 41				ld b, 'A' 
4b6e 90					sub b			; set offset 
4b6f					if DEBUG_FORTH_WORDS 
4b6f						DMARK "Vbb" 
4b6f f5				push af  
4b70 3a 84 4b			ld a, (.dmark)  
4b73 32 6b ee			ld (debug_mark),a  
4b76 3a 85 4b			ld a, (.dmark+1)  
4b79 32 6c ee			ld (debug_mark+1),a  
4b7c 3a 86 4b			ld a, (.dmark+2)  
4b7f 32 6d ee			ld (debug_mark+2),a  
4b82 18 03			jr .pastdmark  
4b84 ..			.dmark: db "Vbb"  
4b87 f1			.pastdmark: pop af  
4b88			endm  
# End of macro DMARK
4b88						CALLMONITOR 
4b88 cd 6f ee			call debug_vector  
4b8b				endm  
# End of macro CALLMONITOR
4b8b					endif 
4b8b cb 27				sla a  
4b8d				 
4b8d					 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "VR2" 
4b8d f5				push af  
4b8e 3a a2 4b			ld a, (.dmark)  
4b91 32 6b ee			ld (debug_mark),a  
4b94 3a a3 4b			ld a, (.dmark+1)  
4b97 32 6c ee			ld (debug_mark+1),a  
4b9a 3a a4 4b			ld a, (.dmark+2)  
4b9d 32 6d ee			ld (debug_mark+2),a  
4ba0 18 03			jr .pastdmark  
4ba2 ..			.dmark: db "VR2"  
4ba5 f1			.pastdmark: pop af  
4ba6			endm  
# End of macro DMARK
4ba6						CALLMONITOR 
4ba6 cd 6f ee			call debug_vector  
4ba9				endm  
# End of macro CALLMONITOR
4ba9					endif 
4ba9			 
4ba9 21 f4 e9				ld hl, cli_var_array2 
4bac cd e7 0d				call addatohl 
4baf cd 46 1c				call forth_push_numhl 
4bb2			 
4bb2			 
4bb2				       NEXTW 
4bb2 c3 f3 1f			jp macro_next 
4bb5				endm 
# End of macro NEXTW
4bb5			.V0: 
4bb5				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bb5 78				db WORD_SYS_CORE+100             
4bb6 cd 4b			dw .V0Q            
4bb8 04				db 3 + 1 
4bb9 .. 00			db "V0!",0              
4bbd				endm 
# End of macro CWHEAD
4bbd			;| V0! ( u1 -- )  Store value to v0  | DONE 
4bbd			 
4bbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bbd cd 3d 1e			call macro_dsp_valuehl 
4bc0				endm 
# End of macro FORTH_DSP_VALUEHL
4bc0			 
4bc0 11 28 ea				ld de, cli_var_array 
4bc3			 
4bc3 eb					ex de, hl 
4bc4 73					ld (hl), e 
4bc5 23					inc hl 
4bc6 72					ld (hl), d 
4bc7			 
4bc7					; destroy value TOS 
4bc7			 
4bc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc7 cd f5 1e			call macro_forth_dsp_pop 
4bca				endm 
# End of macro FORTH_DSP_POP
4bca			 
4bca				       NEXTW 
4bca c3 f3 1f			jp macro_next 
4bcd				endm 
# End of macro NEXTW
4bcd			.V0Q: 
4bcd				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bcd 79				db WORD_SYS_CORE+101             
4bce de 4b			dw .V1S            
4bd0 04				db 3 + 1 
4bd1 .. 00			db "V0@",0              
4bd5				endm 
# End of macro CWHEAD
4bd5			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bd5 2a 28 ea				ld hl, (cli_var_array) 
4bd8 cd 46 1c				call forth_push_numhl 
4bdb			 
4bdb				       NEXTW 
4bdb c3 f3 1f			jp macro_next 
4bde				endm 
# End of macro NEXTW
4bde			.V1S: 
4bde				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bde 7a				db WORD_SYS_CORE+102             
4bdf f6 4b			dw .V1Q            
4be1 04				db 3 + 1 
4be2 .. 00			db "V1!",0              
4be6				endm 
# End of macro CWHEAD
4be6			;| V1! ( u1 -- )  Store value to v1 | DONE 
4be6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4be6 cd 3d 1e			call macro_dsp_valuehl 
4be9				endm 
# End of macro FORTH_DSP_VALUEHL
4be9			 
4be9 11 2a ea				ld de, cli_var_array+2 
4bec				 
4bec eb					ex de, hl 
4bed 73					ld (hl), e 
4bee 23					inc hl 
4bef 72					ld (hl), d 
4bf0			 
4bf0					; destroy value TOS 
4bf0			 
4bf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf0 cd f5 1e			call macro_forth_dsp_pop 
4bf3				endm 
# End of macro FORTH_DSP_POP
4bf3				       NEXTW 
4bf3 c3 f3 1f			jp macro_next 
4bf6				endm 
# End of macro NEXTW
4bf6			.V1Q: 
4bf6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bf6 7b				db WORD_SYS_CORE+103             
4bf7 07 4c			dw .V2S            
4bf9 04				db 3 + 1 
4bfa .. 00			db "V1@",0              
4bfe				endm 
# End of macro CWHEAD
4bfe			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bfe 2a 2a ea				ld hl, (cli_var_array+2) 
4c01 cd 46 1c				call forth_push_numhl 
4c04				       NEXTW 
4c04 c3 f3 1f			jp macro_next 
4c07				endm 
# End of macro NEXTW
4c07			.V2S: 
4c07				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c07 7c				db WORD_SYS_CORE+104             
4c08 1f 4c			dw .V2Q            
4c0a 04				db 3 + 1 
4c0b .. 00			db "V2!",0              
4c0f				endm 
# End of macro CWHEAD
4c0f			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c0f cd 3d 1e			call macro_dsp_valuehl 
4c12				endm 
# End of macro FORTH_DSP_VALUEHL
4c12			 
4c12 11 2c ea				ld de, cli_var_array+4 
4c15				 
4c15 eb					ex de, hl 
4c16 73					ld (hl), e 
4c17 23					inc hl 
4c18 72					ld (hl), d 
4c19			 
4c19					; destroy value TOS 
4c19			 
4c19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c19 cd f5 1e			call macro_forth_dsp_pop 
4c1c				endm 
# End of macro FORTH_DSP_POP
4c1c				       NEXTW 
4c1c c3 f3 1f			jp macro_next 
4c1f				endm 
# End of macro NEXTW
4c1f			.V2Q: 
4c1f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c1f 7d				db WORD_SYS_CORE+105             
4c20 30 4c			dw .V3S            
4c22 04				db 3 + 1 
4c23 .. 00			db "V2@",0              
4c27				endm 
# End of macro CWHEAD
4c27			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c27 2a 2c ea				ld hl, (cli_var_array+4) 
4c2a cd 46 1c				call forth_push_numhl 
4c2d				       NEXTW 
4c2d c3 f3 1f			jp macro_next 
4c30				endm 
# End of macro NEXTW
4c30			.V3S: 
4c30				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c30 7c				db WORD_SYS_CORE+104             
4c31 48 4c			dw .V3Q            
4c33 04				db 3 + 1 
4c34 .. 00			db "V3!",0              
4c38				endm 
# End of macro CWHEAD
4c38			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c38 cd 3d 1e			call macro_dsp_valuehl 
4c3b				endm 
# End of macro FORTH_DSP_VALUEHL
4c3b			 
4c3b 11 2e ea				ld de, cli_var_array+6 
4c3e				 
4c3e eb					ex de, hl 
4c3f 73					ld (hl), e 
4c40 23					inc hl 
4c41 72					ld (hl), d 
4c42			 
4c42					; destroy value TOS 
4c42			 
4c42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c42 cd f5 1e			call macro_forth_dsp_pop 
4c45				endm 
# End of macro FORTH_DSP_POP
4c45				       NEXTW 
4c45 c3 f3 1f			jp macro_next 
4c48				endm 
# End of macro NEXTW
4c48			.V3Q: 
4c48				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c48 7d				db WORD_SYS_CORE+105             
4c49 59 4c			dw .END            
4c4b 04				db 3 + 1 
4c4c .. 00			db "V3@",0              
4c50				endm 
# End of macro CWHEAD
4c50			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c50 2a 2e ea				ld hl, (cli_var_array+6) 
4c53 cd 46 1c				call forth_push_numhl 
4c56				       NEXTW 
4c56 c3 f3 1f			jp macro_next 
4c59				endm 
# End of macro NEXTW
4c59			 
4c59			 
4c59			 
4c59			 
4c59			 
4c59			; end of dict marker 
4c59			 
4c59 00			.END:    db WORD_SYS_END 
4c5a 00 00			dw 0 
4c5c 00				db 0 
4c5d			 
4c5d			; use to jp here for user dict words to save on macro expansion  
4c5d			 
4c5d			user_dict_next: 
4c5d				NEXTW 
4c5d c3 f3 1f			jp macro_next 
4c60				endm 
# End of macro NEXTW
4c60			 
4c60			 
4c60			user_exec: 
4c60				;    ld hl, <word code> 
4c60				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c60				;    call forthexec 
4c60				;    jp user_dict_next   (NEXT) 
4c60			        ;    <word code bytes> 
4c60 eb				ex de, hl 
4c61 2a c2 e5			ld hl,(os_tok_ptr) 
4c64				 
4c64				FORTH_RSP_NEXT 
4c64 cd ed 1b			call macro_forth_rsp_next 
4c67				endm 
# End of macro FORTH_RSP_NEXT
4c67			 
4c67			if DEBUG_FORTH_UWORD 
4c67						DMARK "UEX" 
4c67 f5				push af  
4c68 3a 7c 4c			ld a, (.dmark)  
4c6b 32 6b ee			ld (debug_mark),a  
4c6e 3a 7d 4c			ld a, (.dmark+1)  
4c71 32 6c ee			ld (debug_mark+1),a  
4c74 3a 7e 4c			ld a, (.dmark+2)  
4c77 32 6d ee			ld (debug_mark+2),a  
4c7a 18 03			jr .pastdmark  
4c7c ..			.dmark: db "UEX"  
4c7f f1			.pastdmark: pop af  
4c80			endm  
# End of macro DMARK
4c80				CALLMONITOR 
4c80 cd 6f ee			call debug_vector  
4c83				endm  
# End of macro CALLMONITOR
4c83			endif 
4c83			 
4c83			 
4c83			 
4c83 eb				ex de, hl 
4c84 22 c2 e5			ld (os_tok_ptr), hl 
4c87				 
4c87				; Don't use next - Skips the first word in uword. 
4c87			 
4c87 c3 84 20			jp exec1 
4c8a			;	NEXT 
4c8a			 
4c8a			 
4c8a			; eof 
# End of file forth_wordsv4.asm
4c8a			endif 
4c8a			;;;;;;;;;;;;;; Debug code 
4c8a			 
4c8a			 
4c8a			;if DEBUG_FORTH_PARSE 
4c8a .. 00		.nowordfound: db "No match",0 
4c93 .. 00		.compword:	db "Comparing word ",0 
4ca3 .. 00		.nextwordat:	db "Next word at",0 
4cb0 .. 00		.charmatch:	db "Char match",0 
4cbb			;endif 
4cbb			if DEBUG_FORTH_JP 
4cbb			.foundword:	db "Word match. Exec..",0 
4cbb			endif 
4cbb			;if DEBUG_FORTH_PUSH 
4cbb .. 00		.enddict:	db "Dict end. Push.",0 
4ccb .. 00		.push_str:	db "Pushing string",0 
4cda .. 00		.push_num:	db "Pushing number",0 
4ce9 .. 00		.data_sp:	db "SP:",0 
4ced .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4cff .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d11 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d23			;endif 
4d23			;if DEBUG_FORTH_MALLOC 
4d23 .. 00		.push_malloc:	db "Malloc address",0 
4d32			;endif 
4d32			 
4d32			 
4d32			 
4d32			; display malloc address and current data stack pointer  
4d32			 
4d32			malloc_error: 
4d32 d5				push de 
4d33 f5				push af 
4d34 e5				push hl 
4d35 cd ba 0b			call clear_display 
4d38 11 58 4d			ld de, .mallocerr 
4d3b 3e 00			ld a,0 
4d3d			;	ld de,os_word_scratch 
4d3d cd cd 0b			call str_at_display 
4d40 3e 11			ld a, display_row_1+17 
4d42 11 6b ee			ld de, debug_mark 
4d45 cd cd 0b			call str_at_display 
4d48 cd dd 0b			call update_display 
4d4b				;call break_point_state 
4d4b cd 6f 65			call cin_wait 
4d4e			 
4d4e			;	ld a, ' ' 
4d4e			;	ld (os_view_disable), a 
4d4e cd dd 15			call bp_on 
4d51 e1				pop hl 
4d52 f1				pop af 
4d53 d1				pop de	 
4d54				CALLMONITOR 
4d54 cd 6f ee			call debug_vector  
4d57				endm  
# End of macro CALLMONITOR
4d57 c9				ret 
4d58			 
4d58 .. 00		.mallocerr: 	db "Malloc Error",0 
4d65			;if DEBUG_FORTH_PUSH 
4d65			display_data_sp: 
4d65 f5				push af 
4d66			 
4d66				; see if disabled 
4d66			 
4d66			 
4d66 3a 6f ee			ld a, (debug_vector) 
4d69 fe c9			cp $C9  ; RET 
4d6b				;ld a, (os_view_disable) 
4d6b				;cp '*' 
4d6b 28 67			jr z, .skipdsp 
4d6d			 
4d6d e5				push hl 
4d6e e5				push hl 
4d6f e5			push hl 
4d70 cd ba 0b			call clear_display 
4d73 e1			pop hl 
4d74 7c				ld a,h 
4d75 21 c6 e5			ld hl, os_word_scratch 
4d78 cd e8 10			call hexout 
4d7b e1				pop hl 
4d7c 7d				ld a,l 
4d7d 21 c8 e5			ld hl, os_word_scratch+2 
4d80 cd e8 10			call hexout 
4d83 21 ca e5			ld hl, os_word_scratch+4 
4d86 3e 00			ld a,0 
4d88 77				ld (hl),a 
4d89 11 c6 e5			ld de,os_word_scratch 
4d8c 3e 28				ld a, display_row_2 
4d8e cd cd 0b				call str_at_display 
4d91 11 ed 4c			ld de, .wordinhl 
4d94 3e 00			ld a, display_row_1 
4d96			 
4d96 cd cd 0b				call str_at_display 
4d99 11 6b ee			ld de, debug_mark 
4d9c 3e 11			ld a, display_row_1+17 
4d9e			 
4d9e cd cd 0b				call str_at_display 
4da1			 
4da1				; display current data stack pointer 
4da1 11 e9 4c			ld de,.data_sp 
4da4 3e 30				ld a, display_row_2 + 8 
4da6 cd cd 0b				call str_at_display 
4da9			 
4da9 2a ee e9			ld hl,(cli_data_sp) 
4dac e5				push hl 
4dad 7c				ld a,h 
4dae 21 c6 e5			ld hl, os_word_scratch 
4db1 cd e8 10			call hexout 
4db4 e1				pop hl 
4db5 7d				ld a,l 
4db6 21 c8 e5			ld hl, os_word_scratch+2 
4db9 cd e8 10			call hexout 
4dbc 21 ca e5			ld hl, os_word_scratch+4 
4dbf 3e 00			ld a,0 
4dc1 77				ld (hl),a 
4dc2 11 c6 e5			ld de,os_word_scratch 
4dc5 3e 33				ld a, display_row_2 + 11 
4dc7 cd cd 0b				call str_at_display 
4dca			 
4dca			 
4dca cd dd 0b			call update_display 
4dcd cd f2 0a			call delay1s 
4dd0 cd f2 0a			call delay1s 
4dd3 e1				pop hl 
4dd4			.skipdsp: 
4dd4 f1				pop af 
4dd5 c9				ret 
4dd6			 
4dd6			display_data_malloc: 
4dd6			 
4dd6 f5				push af 
4dd7 e5				push hl 
4dd8 e5				push hl 
4dd9 e5			push hl 
4dda cd ba 0b			call clear_display 
4ddd e1			pop hl 
4dde 7c				ld a,h 
4ddf 21 c6 e5			ld hl, os_word_scratch 
4de2 cd e8 10			call hexout 
4de5 e1				pop hl 
4de6 7d				ld a,l 
4de7 21 c8 e5			ld hl, os_word_scratch+2 
4dea cd e8 10			call hexout 
4ded 21 ca e5			ld hl, os_word_scratch+4 
4df0 3e 00			ld a,0 
4df2 77				ld (hl),a 
4df3 11 c6 e5			ld de,os_word_scratch 
4df6 3e 28				ld a, display_row_2 
4df8 cd cd 0b				call str_at_display 
4dfb 11 23 4d			ld de, .push_malloc 
4dfe 3e 00			ld a, display_row_1 
4e00			 
4e00 cd cd 0b				call str_at_display 
4e03			 
4e03				; display current data stack pointer 
4e03 11 e9 4c			ld de,.data_sp 
4e06 3e 30				ld a, display_row_2 + 8 
4e08 cd cd 0b				call str_at_display 
4e0b			 
4e0b 2a ee e9			ld hl,(cli_data_sp) 
4e0e e5				push hl 
4e0f 7c				ld a,h 
4e10 21 c6 e5			ld hl, os_word_scratch 
4e13 cd e8 10			call hexout 
4e16 e1				pop hl 
4e17 7d				ld a,l 
4e18 21 c8 e5			ld hl, os_word_scratch+2 
4e1b cd e8 10			call hexout 
4e1e 21 ca e5			ld hl, os_word_scratch+4 
4e21 3e 00			ld a,0 
4e23 77				ld (hl),a 
4e24 11 c6 e5			ld de,os_word_scratch 
4e27 3e 33				ld a, display_row_2 + 11 
4e29 cd cd 0b				call str_at_display 
4e2c			 
4e2c cd dd 0b			call update_display 
4e2f cd f2 0a			call delay1s 
4e32 cd f2 0a			call delay1s 
4e35 e1				pop hl 
4e36 f1				pop af 
4e37 c9				ret 
4e38			;endif 
4e38			 
4e38			include "forth_autostart.asm" 
4e38			; list of commands to perform at system start up 
4e38			 
4e38			startcmds: 
4e38			;	dw test11 
4e38			;	dw test12 
4e38			;	dw test13 
4e38			;	dw test14 
4e38			;	dw test15 
4e38			;	dw test16 
4e38			;	dw test17 
4e38			;	dw ifthtest1 
4e38			;	dw ifthtest2 
4e38			;	dw ifthtest3 
4e38			;	dw mmtest1 
4e38			;	dw mmtest2 
4e38			;	dw mmtest3 
4e38			;	dw mmtest4 
4e38			;	dw mmtest5 
4e38			;	dw mmtest6 
4e38			;	dw iftest1 
4e38			;	dw iftest2 
4e38			;	dw iftest3 
4e38			;	dw looptest1 
4e38			;	dw looptest2 
4e38			;	dw test1 
4e38			;	dw test2 
4e38			;	dw test3 
4e38			;	dw test4 
4e38			;	dw game2r 
4e38			;	dw game2b1 
4e38			;	dw game2b2 
4e38			 
4e38				; start up words that are actually useful 
4e38			 
4e38			;    dw spi1 
4e38			;    dw spi2 
4e38			;    dw spi3 
4e38			;    dw spi4 
4e38			;    dw spi5 
4e38			;    dw spi6 
4e38			;    dw spi7 
4e38			; 
4e38			;    dw spi8 
4e38			;    dw spi9 
4e38			;    dw spi10 
4e38			 
4e38			; file editor 
4e38			;	dw edit1 
4e38			;	dw edit2 
4e38			;	dw edit3 
4e38			 
4e38			;	dw longread 
4e38 38 52			dw clrstack 
4e3a 6c 52			dw type 
4e3c			;	dw stest 
4e3c 91 52			dw strncpy 
4e3e			;	dw list 
4e3e f2 52			dw start1 
4e40 02 53			dw start2 
4e42			;	dw start3 
4e42			;	dw start3b 
4e42			;	dw start3c 
4e42			 
4e42				; (unit) testing words 
4e42			 
4e42			;	dw mtesta 
4e42			;	dw mtestb 
4e42			;	dw mtestc 
4e42			;	dw mtestd 
4e42			;	dw mteste 
4e42			 
4e42				; demo/game words 
4e42			 
4e42			;        dw game3w 
4e42			;        dw game3p 
4e42			;        dw game3sc 
4e42			;        dw game3vsi 
4e42			;        dw game3vs 
4e42				 
4e42 5b 5d			dw game2b 
4e44 c9 5d			dw game2bf 
4e46 13 5e			dw game2mba 
4e48 a9 5e			dw game2mbas 
4e4a eb 5e			dw game2mb 
4e4c			 
4e4c 1c 5a			dw game1 
4e4e 2d 5a			dw game1a 
4e50 8f 5a			dw game1b 
4e52 c4 5a			dw game1c 
4e54 fa 5a			dw game1d 
4e56 2b 5b			dw game1s 
4e58 3f 5b			dw game1t 
4e5a 54 5b			dw game1f 
4e5c 88 5b			dw game1z 
4e5e cc 5b			dw game1zz 
4e60			 
4e60 36 58			dw test5 
4e62 6e 58			dw test6 
4e64 a6 58			dw test7 
4e66 ba 58			dw test8 
4e68 e6 58			dw test9 
4e6a fc 58			dw test10 
4e6c				 
4e6c a3 5c		        dw ssv5 
4e6e 87 5c		        dw ssv4 
4e70 6b 5c		        dw ssv3 
4e72 35 5c		        dw ssv2 
4e74 bc 5c		        dw ssv1 
4e76 04 5d		        dw ssv1cpm 
4e78			;	dw keyup 
4e78			;	dw keydown 
4e78			;	dw keyleft 
4e78			;	dw keyright 
4e78			;	dw 	keyf1 
4e78			;	dw keyf2 
4e78			;	dw keyf3 
4e78			;	dw keyf4 
4e78			;	dw keyf5 
4e78			;	dw keyf6 
4e78			;	dw keyf7 
4e78			;	dw keyf8 
4e78			;	dw keyf9 
4e78			;	dw keyf10 
4e78			;	dw keyf11 
4e78			;	dw keyf12 
4e78			;	dw keytab 
4e78			;	dw keycr 
4e78			;	dw keyhome 
4e78			;	dw keyend 
4e78			;	dw keybs 
4e78 00 00			db 0, 0	 
4e7a			 
4e7a			 
4e7a			; File Editor 
4e7a			 
4e7a			; ( id - ) use 'e' to edit the displayed line 
4e7a .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e9b .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ed0			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ed0 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f08			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f08			 
4f08			; SPI Net support words 
4f08			 
4f08			; v0! = node to send to 
4f08			; ( str count - ) 
4f08 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f61			 
4f61			; spiputchr ( char node - ) 
4f61 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f97			 
4f97			; spigetchr ( - n ) 
4f97 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4fc2			 
4fc2			; getnode ( - n ) 
4fc2 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fef			 
4fef			; ( str node - )  
4fef .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5055			; store string ( str i - ) 
5055			 
5055			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5055 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50aa			 
50aa			; get string ( addr i -  )    TO FIX 
50aa			 
50aa .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5102			 
5102			 
5102			; NETCHAT (TODO) 
5102			; Program to allow two nodes to chat with eachother 
5102			; 
5102			; v0 - target node 
5102			;  
5102			; accept input at 0,0 
5102			; if input is string send spitype to target node 
5102			; starting at row 2,0 , while spigetchr is not zero ->  
5102			; 
5102			; 
5102			; TODO add paging of get request 
5102			 
5102			; ( node - ) 
5102 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5121 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5179 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51f1			 
51f1			 
51f1			; Long read of currently open file 
51f1 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5238			 
5238			; clear stack  
5238			 
5238 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
526c			 
526c			; type ( addr count - ) 
526c .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5291			 
5291			; some direct memory words 
5291			; strncpy ( len t f -- t ) 
5291			 
5291 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52f2			 
52f2 .. 00		start1:     	db ": bpon $00 bp ;",0 
5302 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5313 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
538e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53ee			 
53ee			 
53ee			; a handy word to list items on the stack 
53ee			 
53ee .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5458			 
5458			 
5458			; test stack  
5458			; rnd8 stest 
5458			 
5458 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54cf			 
54cf			; random malloc and free cycles 
54cf			 
54cf .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5584			 
5584			; fixed malloc and free cycles 
5584			 
5584 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5627			 
5627			; fixed double string push and drop cycle  
5627			 
5627 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56dc			 
56dc			; consistent fixed string push and drop cycle  
56dc			 
56dc .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5780			 
5780 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5836			 
5836			;test1:		db ": aa 1 2 3 ;", 0 
5836			;test2:     	db "111 aa 888 999",0 
5836			;test3:     	db ": bb 77 ;",0 
5836			;test4:     	db "$02 $01 do i . loop bb",0 
5836			 
5836 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
586e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58a6 .. 00		test7:     	db ": box hline vline ;",0 
58ba .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58e6 .. 00		test9:     	db ": sw $01 adsp world ;",0 
58fc .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5921 .. 00		test11:     	db "hello create .",0 
5930 .. 00		test12:     	db "hello2 create .",0 
5940			 
5940			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5940			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5940			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5940			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5940			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5940			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5940			 
5940			;iftest1:     	db "$0001 IF cls .",0 
5940			;iftest2:     	db "$0000 IF cls .",0 
5940			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5940			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5940			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5940			 
5940			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5940			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5940			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5940			 
5940			 
5940 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5964 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5994 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
59b9 .. 00		sound4: db ": cha $00 ; ",0 
59c6 .. 00		sound5: db ": chb $20 ; ",0 
59d3 .. 00		sound6: db ": chc $40 ; ",0 
59e0 .. 00		sound7: db ": chd $60 ; ",0 
59ed .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5a05 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5a1c			 
5a1c			 
5a1c			 
5a1c			 
5a1c			; a small guess the number game 
5a1c			 
5a1c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a2d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a8f			 
5a8f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ac4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5afa .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b2b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b3f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b54 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b88 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bcc			 
5bcc			; Using 'ga' save a high score across multiple runs using external storage 
5bcc			 
5bcc .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c35			 
5c35			 
5c35			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c35			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c35			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c35			 
5c35			; simple screen saver to test code memory reuse to destruction 
5c35			 
5c35 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c6b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c87 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ca3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cbc .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d04 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d5b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d5b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d5b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d5b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d5b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d5b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d5b			 
5d5b			 
5d5b			 
5d5b			; minesweeper/battleship finding game 
5d5b			; draws a game board of random ship/mine positions 
5d5b			; user enters coords to see if it hits on 
5d5b			; game ends when all are hit 
5d5b			; when hit or miss says how many may be in the area 
5d5b			 
5d5b			; setup the game board and then hide it 
5d5b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dc9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e13			; prompt for where to target 
5e13 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ea9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ece			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ece .. 00		game2mbht:      db ": mbckht nop ;",0 
5edd .. 00		game2mbms:      db ": mbcms nop ;",0 
5eeb			; TODO how many might be near by 
5eeb .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f68			 
5f68			; Game 3 
5f68			 
5f68			; Vert scroller ski game - avoid the trees! 
5f68			 
5f68			; v0 score (ie turns) 
5f68			; v1 player pos 
5f68			; v2 left wall 
5f68			; v3 right wall 
5f68			 
5f68			; Draw side walls randomly 
5f68			 
5f68 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f96			 
5f96			; Draw player 
5f96 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fb4			 
5fb4			; TODO Get Key 
5fb4			 
5fb4			; TODO Move left right 
5fb4			 
5fb4			; scroll and move walls a bit 
5fb4			 
5fb4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fe5			 
5fe5			; main game loop 
5fe5			 
5fe5 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6011 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6050			 
6050			; key board defs 
6050			 
6050 .. 00		keyup:       db ": keyup $05 ;",0 
605e .. 00		keydown:       db ": keydown $0a ;",0 
606e .. 00		keyleft:       db ": keyleft $0b ;",0 
607e .. 00		keyright:       db ": keyright $0c ;",0 
608f .. 00		keyf1:       db ": keyf1 $10 ;",0 
609d .. 00		keyf2:       db ": keyf2 $11 ;",0 
60ab .. 00		keyf3:       db ": keyf3 $12 ;",0 
60b9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60c7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60d5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60e3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60f1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
60ff .. 00		keyf9:       db ": keyf9 $18 ;",0 
610d .. 00		keyf10:       db ": keyf10 $19 ;",0 
611c .. 00		keyf11:       db ": keyf11 $1a ;",0 
612b .. 00		keyf12:       db ": keyf12 $1b ;",0 
613a			 
613a .. 00		keytab:       db ": keytab $09 ;",0 
6149 .. 00		keycr:       db ": keycr $0d ;",0 
6157 .. 00		keyhome:       db ": keyhome $0e ;",0 
6167 .. 00		keyend:       db ": keyend $0f ;",0 
6176 .. 00		keybs:       db ": keybs $08 ;",0 
6184			 
6184			   
6184			 
6184			 
6184			 
6184			; eof 
# End of file forth_autostart.asm
6184			 
6184			 
6184			 
6184			; stack over and underflow checks 
6184			 
6184			; init the words to detect the under/overflow 
6184			 
6184			chk_stk_init: 
6184				; a vague random number to check so we dont get any "lucky" hits 
6184 3e 2d			ld a, 45 
6186 6f				ld l, a 
6187 00				nop 
6188 3e 17			ld a, 23 
618a 67				ld h, a 
618b			 
618b 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
618e			 
618e			;	ld (chk_stund), hl	; stack points.... 
618e 22 00 ef			ld (chk_stovr), hl 
6191 22 ec e9			ld (chk_ret_und), hl 
6194 22 aa e9			ld (chk_ret_ovr), hl 
6197 22 28 e9			ld (chk_loop_ovr), hl 
619a 22 26 e8			ld (chk_data_ovr), hl 
619d c9				ret 
619e				 
619e			check_stacks: 
619e				; check all stack words 
619e			 
619e e5				push hl 
619f d5				push de 
61a0			 
61a0			;	ld de,(chk_word) 
61a0			;	ld hl, (chk_stund)	; stack points.... 
61a0			;	if DEBUG_STK_FAULT 
61a0			;		DMARK "FAa" 
61a0			;		CALLMONITOR 
61a0			;	endif 
61a0			;	call cmp16 
61a0			;	jp z, .chk_faulta 
61a0			; 
61a0			;	ld de, sfaultsu 
61a0			;	jp .chk_fault 
61a0			 
61a0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61a3 ed 5b a9 e2		ld de,(chk_word) 
61a7				if DEBUG_STK_FAULT 
61a7					DMARK "FAb" 
61a7					CALLMONITOR 
61a7				endif 
61a7 cd 05 0e			call cmp16 
61aa 28 06			jr z, .chk_fault1 
61ac 11 4d 62			ld de, sfaultso 
61af c3 01 62			jp .chk_fault 
61b2			.chk_fault1:  
61b2 2a ec e9			ld hl, (chk_ret_und) 
61b5 ed 5b a9 e2		ld de,(chk_word) 
61b9				if DEBUG_STK_FAULT 
61b9					DMARK "FAU" 
61b9					CALLMONITOR 
61b9				endif 
61b9 cd 05 0e			call cmp16 
61bc ca c5 61			jp z, .chk_fault2 
61bf 11 5d 62			ld de, sfaultru 
61c2 c3 01 62			jp .chk_fault 
61c5			.chk_fault2:  
61c5 2a aa e9			ld hl, (chk_ret_ovr) 
61c8 ed 5b a9 e2		ld de,(chk_word) 
61cc				if DEBUG_STK_FAULT 
61cc					DMARK "FA1" 
61cc					CALLMONITOR 
61cc				endif 
61cc cd 05 0e			call cmp16 
61cf ca d8 61			jp z, .chk_fault3 
61d2 11 6b 62			ld de, sfaultro 
61d5 c3 01 62			jp .chk_fault 
61d8			.chk_fault3:  
61d8 2a 28 e9			ld hl, (chk_loop_ovr) 
61db ed 5b a9 e2		ld de,(chk_word) 
61df				if DEBUG_STK_FAULT 
61df					DMARK "FA2" 
61df					CALLMONITOR 
61df				endif 
61df cd 05 0e			call cmp16 
61e2 ca eb 61			jp z, .chk_fault4 
61e5 11 85 62			ld de, sfaultlo 
61e8 c3 01 62			jp .chk_fault 
61eb			.chk_fault4:  
61eb 2a 26 e8			ld hl, (chk_data_ovr) 
61ee ed 5b a9 e2		ld de,(chk_word) 
61f2				if DEBUG_STK_FAULT 
61f2					DMARK "FA3" 
61f2					CALLMONITOR 
61f2				endif 
61f2 cd 05 0e			call cmp16 
61f5 ca fe 61			jp z, .chk_fault5 
61f8 11 9f 62			ld de, sfaultdo 
61fb c3 01 62			jp .chk_fault 
61fe			 
61fe			 
61fe			.chk_fault5:  
61fe d1				pop de 
61ff e1				pop hl 
6200			 
6200 c9				ret 
6201			 
6201 cd ba 0b		.chk_fault: 	call clear_display 
6204 3e 28				ld a, display_row_2 
6206 cd cd 0b				call str_at_display 
6209 11 2f 62				   ld de, .stackfault 
620c 3e 00				ld a, display_row_1 
620e cd cd 0b				call str_at_display 
6211 11 6b ee				    ld de, debug_mark 
6214 3e 11				ld a, display_row_1+17 
6216 cd cd 0b				call str_at_display 
6219 cd dd 0b				call update_display 
621c			 
621c				; prompt before entering montior for investigating issue 
621c			 
621c 3e 78			ld a, display_row_4 
621e 11 38 19			ld de, endprog 
6221			 
6221 cd dd 0b			call update_display		 
6224			 
6224 cd be 1b			call next_page_prompt 
6227			 
6227 d1				pop de 
6228 e1				pop hl 
6229 cd 8c 19				call monitor 
622c c3 96 18				jp warmstart 
622f					;jp 0 
622f					;halt 
622f			 
622f			 
622f			 
622f .. 00		.stackfault: 	db "Stack fault:",0 
623c			 
623c .. 00		sfaultsu: 	db	"Stack under flow",0 
624d .. 00		sfaultso: 	db	"Stack over flow",0 
625d .. 00		sfaultru:	db "RTS underflow",0 
626b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6285 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
629f .. 00		sfaultdo:	db "DTS overflow", 0 
62ac			 
62ac			 
62ac			fault_dsp_under: 
62ac 11 be 62			ld de, .dsp_under 
62af c3 6e 63			jp .show_fault 
62b2			 
62b2			fault_rsp_under: 
62b2 11 cc 62			ld de, .rsp_under 
62b5 c3 6e 63			jp .show_fault 
62b8			fault_loop_under: 
62b8 11 da 62			ld de, .loop_under 
62bb c3 6e 63			jp .show_fault 
62be			 
62be .. 00		.dsp_under: db "DSP Underflow",0 
62cc .. 00		.rsp_under: db "RSP Underflow",0 
62da .. 00		.loop_under: db "LOOP Underflow",0 
62e9			 
62e9			 
62e9 d5			type_faultn: 	push de 
62ea e5					push hl 
62eb cd ba 0b				call clear_display 
62ee 11 15 63				   ld de, .typefaultn 
62f1 3e 00				ld a, display_row_1 
62f3 cd cd 0b				call str_at_display 
62f6 11 6b ee				    ld de, debug_mark 
62f9 3e 11				ld a, display_row_1+17 
62fb cd cd 0b				call str_at_display 
62fe cd dd 0b				call update_display 
6301			 
6301				; prompt before entering montior for investigating issue 
6301			 
6301 3e 78			ld a, display_row_4 
6303 11 38 19			ld de, endprog 
6306			 
6306 cd dd 0b			call update_display		 
6309			 
6309 cd be 1b			call next_page_prompt 
630c			 
630c e5					push hl 
630d d5					push de 
630e cd 8c 19				call monitor 
6311 c3 96 18				jp warmstart 
6314 76					halt 
6315			 
6315			 
6315 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
632c			 
632c d5			type_faults: 	push de 
632d e5					push hl 
632e cd ba 0b				call clear_display 
6331 11 57 63				   ld de, .typefaults 
6334 3e 00				ld a, display_row_1 
6336 cd cd 0b				call str_at_display 
6339 11 6b ee				    ld de, debug_mark 
633c 3e 11				ld a, display_row_1+17 
633e cd cd 0b				call str_at_display 
6341 cd dd 0b				call update_display 
6344			 
6344				; prompt before entering montior for investigating issue 
6344			 
6344 3e 78			ld a, display_row_4 
6346 11 38 19			ld de, endprog 
6349			 
6349 cd dd 0b			call update_display		 
634c			 
634c cd be 1b			call next_page_prompt 
634f			 
634f e1					pop hl 
6350 d1					pop de 
6351 cd 8c 19				call monitor 
6354 c3 96 18				jp warmstart 
6357			 
6357			 
6357 .. 00		.typefaults: db "STR Type Expected TOS!",0 
636e			 
636e			.show_fault: 	 
636e d5					push de 
636f cd ba 0b				call clear_display 
6372 d1					pop de 
6373 3e 00				ld a, display_row_1 
6375 cd cd 0b				call str_at_display 
6378 11 6b ee				    ld de, debug_mark 
637b 3e 11				ld a, display_row_1+17 
637d cd cd 0b				call str_at_display 
6380 cd dd 0b				call update_display 
6383			 
6383				; prompt before entering montior for investigating issue 
6383			 
6383 3e 78			ld a, display_row_4 
6385 11 38 19			ld de, endprog 
6388			 
6388 cd dd 0b			call update_display		 
638b			 
638b cd be 1b			call next_page_prompt 
638e			 
638e e1					pop hl 
638f d1					pop de 
6390 cd 8c 19				call monitor 
6393			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6393			; TODO Make optional fault restart to cli or warm boot? 
6393					;jp warmstart 
6393 c3 df 18				jp cli 
6396 76					halt 
6397			 
6397			; handle the auto run of code from files in storage 
6397			 
6397			 
6397			include "forth_startup.asm" 
6397			; Which startup method to use? 
6397			; 
6397			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6397			; followed by loading of a list of scripts in eeprom 
6397			 
6397			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6397			; from eeprom 
6397			 
6397			; Select with define in main stubs 
6397			 
6397			if STARTUP_V1 
6397				include "forth_startupv1.asm" 
6397			; Startup script loading version 1 
6397			 
6397			; If SE storage is available first stage is to use the selected file 
6397			; then go through the eeprom list 
6397			 
6397 .. 00		sprompt1: db "Startup load...",0 
63a7 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63bd			 
63bd			 
63bd			 
63bd			 
63bd			forth_startup: 
63bd 21 38 4e			ld hl, startcmds 
63c0 3e 00			ld a, 0 
63c2 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63c5			 
63c5 e5			.start1:	push hl 
63c6 cd ba 0b			call clear_display 
63c9 11 97 63			ld de, sprompt1 
63cc 3e 00		        ld a, display_row_1 
63ce cd cd 0b			call str_at_display 
63d1 11 a7 63			ld de, sprompt2 
63d4 3e 28		        ld a, display_row_2 
63d6 cd cd 0b			call str_at_display 
63d9 e1				pop hl 
63da e5				push hl 
63db 5e				ld e,(hl) 
63dc 23				inc hl 
63dd 56				ld d,(hl) 
63de 3e 50		        ld a, display_row_3 
63e0 cd cd 0b			call str_at_display 
63e3 cd dd 0b			call update_display 
63e6			 
63e6			 
63e6 3a e7 e6			ld a, (os_last_cmd) 
63e9 fe 00			cp 0 
63eb 28 05			jr z, .startprompt 
63ed cd e6 0a			call delay250ms 
63f0 18 24			jr .startdo 
63f2				 
63f2				 
63f2			 
63f2			.startprompt: 
63f2			 
63f2 3e 9f			ld a,display_row_4 + display_cols - 1 
63f4 11 bc 1b		        ld de, endprg 
63f7 cd cd 0b			call str_at_display 
63fa cd dd 0b			call update_display 
63fd cd f2 0a			call delay1s 
6400 cd 6f 65			call cin_wait 
6403						 
6403 fe 2a			cp '*' 
6405 28 5e			jr z, .startupend1 
6407 fe 23			cp '#' 
6409 20 07			jr nz, .startno 
640b 3e 01			ld a, 1 
640d 32 e7 e6			ld (os_last_cmd),a 
6410 18 04			jr .startdo 
6412 fe 31		.startno:	cp '1' 
6414 28 3a			jr z,.startnxt  
6416			 
6416				; exec startup line 
6416			.startdo:	 
6416 e1				pop hl 
6417 e5				push hl 
6418				 
6418 5e				ld e,(hl) 
6419 23				inc hl 
641a 56				ld d,(hl) 
641b eb				ex de,hl 
641c			 
641c e5				push hl 
641d			 
641d 3e 00			ld a, 0 
641f				;ld a, FORTH_END_BUFFER 
641f cd 50 12			call strlent 
6422 23				inc hl   ; include zero term to copy 
6423 06 00			ld b,0 
6425 4d				ld c,l 
6426 e1				pop hl 
6427 11 c1 e2			ld de, scratch 
642a ed b0			ldir 
642c			 
642c			 
642c 21 c1 e2			ld hl, scratch 
642f cd 41 20			call forthparse 
6432 cd 81 20			call forthexec 
6435 cd 93 1f			call forthexec_cleanup 
6438			 
6438 3e 78			ld a, display_row_4 
643a 11 38 19			ld de, endprog 
643d			 
643d cd dd 0b			call update_display		 
6440			 
6440 3a e7 e6			ld a, (os_last_cmd) 
6443 fe 00			cp 0 
6445 20 09			jr nz, .startnxt 
6447 cd be 1b			call next_page_prompt 
644a cd ba 0b		        call clear_display 
644d cd dd 0b			call update_display		 
6450			 
6450				; move onto next startup line? 
6450			.startnxt: 
6450			 
6450 cd e6 0a			call delay250ms 
6453 e1				pop hl 
6454			 
6454 23				inc hl 
6455 23				inc hl 
6456			 
6456 e5				push hl 
6457 5e				ld e, (hl) 
6458 23				inc hl 
6459 56				ld d, (hl) 
645a e1				pop hl 
645b				; TODO replace 0 test 
645b			 
645b eb				ex de, hl 
645c cd 10 0e			call ishlzero 
645f			;	ld a,e 
645f			;	add d 
645f			;	cp 0    ; any left to do? 
645f eb				ex de, hl 
6460 c2 c5 63			jp nz, .start1 
6463 18 01			jr .startupend 
6465			 
6465 e1			.startupend1: pop hl 
6466			.startupend: 
6466			 
6466 cd ba 0b			call clear_display 
6469 cd dd 0b			call update_display 
646c c9				ret 
646d			if STORAGE_SE 
646d			 
646d			sprompt3: db "Loading from start-up file?:",0 
646d			sprompt4: db "(Y=Any key/N=No)",0 
646d			 
646d			 
646d			forth_autoload: 
646d			 
646d				; load block 0 of store 1 
646d				 
646d				ld a, $fe      ; bit 0 clear 
646d				ld (spi_device), a 
646d			 
646d				call storage_get_block_0 
646d			 
646d				ld a, (store_page+STORE_0_AUTOFILE) 
646d			 
646d				cp 0 
646d				ret z     ; auto start not enabled 
646d			 
646d				call clear_display 
646d			 
646d				; set bank 
646d			 
646d					ld a, (store_page+STORE_0_BANKRUN) 
646d					ld (spi_device), a 
646d			 
646d				; get file id to load from and get the file name to display 
646d			 
646d					ld a, (store_page+STORE_0_FILERUN) 
646d			 
646d					ld l, 0 
646d					ld h, a 
646d					ld de, store_page 
646d			 
646d					if DEBUG_FORTH_WORDS 
646d						DMARK "ASp" 
646d						CALLMONITOR 
646d					endif 
646d					call storage_read 
646d			 
646d					if DEBUG_FORTH_WORDS 
646d						DMARK "ASr" 
646d						CALLMONITOR 
646d					endif 
646d			 
646d					call ishlzero 
646d					ret z             ; file not found 
646d			 
646d					ld a, display_row_2 + 10 
646d					ld de, store_page+3 
646d					call str_at_display 
646d				 
646d			; 
646d			 
646d				ld a, display_row_1+5 
646d				ld de, sprompt3 
646d				call str_at_display 
646d				ld a, display_row_3+15 
646d				ld de, sprompt4 
646d				call str_at_display 
646d			 
646d				call update_display 
646d			 
646d				call cin_wait 
646d				cp 'n' 
646d				ret z 
646d				cp 'N' 
646d				ret z 
646d			 
646d				call delay1s 
646d			 
646d				ld a, (store_page+2) 
646d				ld (store_openmaxext), a    ; save count of ext 
646d				ld a, 1  
646d				ld (store_openext), a    ; save count of ext 
646d			 
646d			.autof:  
646d				ld l , a 
646d				 
646d				ld a, (store_page) 
646d				ld h, a	 
646d				ld de, store_page 
646d					if DEBUG_FORTH_WORDS 
646d						DMARK "ASl" 
646d						CALLMONITOR 
646d					endif 
646d					call storage_read 
646d				call ishlzero 
646d				ret z 
646d			;	jr z, .autoend 
646d			 
646d					if DEBUG_FORTH_WORDS 
646d						DMARK "ASc" 
646d						CALLMONITOR 
646d					endif 
646d				ld de, store_page+2 
646d				ld a, display_row_4 
646d				call str_at_display 
646d			 
646d				call update_display 
646d				call delay250ms 
646d			 
646d			 
646d			 
646d				ld hl, store_page+2 
646d				call forthparse 
646d				call forthexec 
646d				call forthexec_cleanup 
646d			 
646d				 
646d				ld a, (store_openext) 
646d				inc a 
646d				ld (store_openext), a    ; save count of ext 
646d			 
646d				jr .autof 
646d			;.autofdone: 
646d			; 
646d			;		if DEBUG_FORTH_WORDS 
646d			;			DMARK "ASx" 
646d			;			CALLMONITOR 
646d			;		endif 
646d			;;	call clear_display 
646d			;	ret 
646d			 
646d			 
646d			 
646d			endif 
# End of file forth_startupv1.asm
646d			endif 
646d			if STARTUP_V2 
646d				include "forth_startupv2.asm" 
646d			endif 
646d			 
# End of file forth_startup.asm
646d			 
646d			; eof 
# End of file forth_kernel.asm
646d			;include "nascombasic.asm" 
646d			 
646d			 
646d			; find out where the code ends if loaded into RAM (for SC114) 
646d			;endofcode:  
646d			;	nop 
646d			 
646d			 
646d			; jump to nmi vector 
646d			 
646d			init_nmi: 
646d 3e c9			ld a, $c9   ; RET 
646f 32 72 ee			ld (nmi_vector), a 
6472 c9				ret 
6473			nmi: 
6473 e5				push hl 
6474 d5				push de 
6475 c5				push bc 
6476 f5				push af 
6477 cd 72 ee			call nmi_vector 
647a f5				push af 
647b c5				push bc 
647c d5				push de 
647d e5				push hl 
647e ed 4d			reti 
6480			 
6480			 
6480			; eof 
6480			 
# End of file main.asm
6480			;include "firmware_lcd_4x40.asm" 
6480			;;include "firmware_lcd_4x20.asm" 
6480			include "firmware_cpm_display.asm" 
6480			 
6480			; Serial display interface for SC114 
6480			 
6480			 
6480			display_row_1: equ 0 
6480			display_row_2: equ display_row_1+display_cols 
6480			display_row_3: equ display_row_2 + display_cols 
6480			display_row_4: equ display_row_3 + display_cols 
6480			 
6480			kLCDWidth:  EQU display_cols             ;Width in characters 
6480			kLCD_Line1: EQU 0x00  
6480			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6480			; E1 
6480			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6480			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6480			 
6480			lcd_init: 
6480				; no init as handled by the SCM bios 
6480 c9				ret 
6481			 
6481			 
6481			; low level functions for direct screen writes 
6481			 
6481			; output char at pos? 
6481			fLCD_Str: 
6481			        ;out (SC114_SIO_1_OUT),a 
6481 c5				push bc 
6482 d5				push de 
6483 5f				ld e, a 
6484			; TODO Replace with CP/M BIOS call 
6484 0e 02			ld c, $02 
6486 cd 05 00			call 5 
6489 d1				pop de 
648a c1				pop bc 
648b c9				ret 
648c			 
648c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
648c			fLCD_Pos: 
648c				; use ASCII escape to position 
648c			        ;out (SC114_SIO_1_OUT),a 
648c c5				push bc 
648d d5				push de 
648e 5f				ld e, a 
648f 0e 02			ld c, $02 
6491			; TODO Replace with CP/M BIOS call 
6491 cd 05 00			call 5 
6494 d1				pop de 
6495 c1				pop bc 
6496			 
6496 c9				ret 
6497			 
6497			; output char at pos 
6497			fLCD_Data: 
6497			      ;  out (SC114_SIO_1_OUT),a 
6497 c5				push bc 
6498 d5				push de 
6499 0e 02			ld c, $02 
649b 5f				ld e, a 
649c			; TODO Replace with CP/M BIOS call 
649c cd 05 00			call 5 
649f d1				pop de 
64a0 c1				pop bc 
64a1			 
64a1 c9				ret 
64a2			 
64a2			; ascii cls  
64a2			 
64a2 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64a6			 
64a6 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64bd			;.clscpm: db 3, $3c,"$" 
64bd			 
64bd			; write the frame buffer given in hl to hardware  
64bd			write_display: 
64bd			 
64bd			API: equ 0 
64bd			 
64bd			if API 
64bd				push bc 
64bd				ld b, 4 
64bd			 
64bd			        ld (display_write_tmp), hl 	  
64bd			 
64bd				; clear and home cursor 
64bd			 
64bd				ld c, 9 
64bd				ld de, .cls 
64bd			; TODO Replace with CP/M BIOS call 
64bd				call 5 
64bd			 
64bd			 
64bd			.writeln: 
64bd			 
64bd				ld de, (display_write_tmp) 
64bd				ld c, 6 
64bd			; TODO Replace with CP/M BIOS call 
64bd				rst $30 
64bd				ld c, 7 
64bd				rst $30 
64bd			 
64bd				ld hl, (display_write_tmp) 
64bd				ld de, display_cols 
64bd				add hl,de 
64bd				ld (display_write_tmp),hl 
64bd			 
64bd				djnz  .writeln 
64bd			 
64bd				pop bc 
64bd			 
64bd			 
64bd				ret 
64bd			endif 
64bd e5				push hl 
64be c5				push bc 
64bf d5				push de 
64c0			 
64c0			;	ld c, 2 
64c0			;	;ld de, .cls 
64c0			;	ld a, 27 
64c0			;	rst $30 
64c0			;	ld c, 2 
64c0			;	;ld de, .cls 
64c0			;	ld a, '[' 
64c0			;	rst $30 
64c0			; 
64c0			;	ld c, 2 
64c0			;	;ld de, .cls 
64c0			;	ld a, 'H' 
64c0			;	rst $30 
64c0			; 
64c0			 
64c0			 
64c0			; lots of CR/LF 
64c0			;	ld c, 9 
64c0			;	ld de, .clscpm 
64c0			;	call 5 
64c0			 
64c0			; xterm cls 
64c0 0e 02			ld c, 2 
64c2 1e 1b			ld e, 27 
64c4 cd 05 00			call 5 
64c7			; cls causes too much flicker 
64c7			;	ld c, 2 
64c7			;	ld e, 'c' 
64c7			;	call 5 
64c7			 
64c7			; use xterm home instead 
64c7 0e 02			ld c, 2 
64c9 1e 5b			ld e, '[' 
64cb cd 05 00			call 5 
64ce 0e 02			ld c, 2 
64d0 1e 48			ld e, 'H' 
64d2 cd 05 00			call 5 
64d5			LLL: equ 0 
64d5			 
64d5			if LLL 
64d5			 
64d5				ld c, 2 
64d5				;ld de, .cls 
64d5				ld e, 27 
64d5			; TODO Replace with CP/M BIOS call 
64d5				call 5 
64d5			 
64d5			 
64d5				ld c, 2 
64d5				;ld de, .cls 
64d5				ld e, '[' 
64d5			; TODO Replace with CP/M BIOS call 
64d5				call 5 
64d5				ld c, 2 
64d5				;ld de, .cls 
64d5				ld e, '2' 
64d5			; TODO Replace with CP/M BIOS call 
64d5				call 5 
64d5				ld c, 2 
64d5				;ld de, .cls 
64d5				ld e, 'J' 
64d5			; TODO Replace with CP/M BIOS call 
64d5				call 5 
64d5			 
64d5			endif 
64d5			 
64d5 d1				pop de 
64d6 c1				pop bc 
64d7 e1				pop hl 
64d8			 
64d8			 
64d8 22 c9 eb		        ld (display_write_tmp), hl 	  
64db 3e 00			ld a, kLCD_Line1 
64dd			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64dd 06 28			ld b, display_cols 
64df ed 5b c9 eb		ld de, (display_write_tmp) 
64e3 cd 66 65			call write_len_string 
64e6				 
64e6			 
64e6 e5			push hl 
64e7 d5			push de 
64e8 c5			push bc 
64e9 0e 02			ld c, 2 
64eb 1e 0a			ld e, 10 
64ed cd 05 00			call 5 
64f0 0e 02			ld c, 2 
64f2 1e 0d			ld e, 13 
64f4 cd 05 00			call 5 
64f7			; TODO Replace with CP/M BIOS call 
64f7				;rst $30 
64f7 c1			pop bc 
64f8 d1			pop de 
64f9 e1			pop hl 
64fa			 
64fa				 
64fa 2a c9 eb			ld hl, (display_write_tmp) 
64fd 11 28 00			ld de, display_cols 
6500 19				add hl,de 
6501 22 c9 eb			ld (display_write_tmp),hl 
6504			 
6504				 
6504 3e 28			ld a, kLCD_Line2 
6506			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6506 06 28			ld b, display_cols 
6508 ed 5b c9 eb		ld de, (display_write_tmp) 
650c cd 66 65			call write_len_string 
650f				 
650f 2a c9 eb			ld hl, (display_write_tmp) 
6512 11 28 00			ld de, display_cols 
6515 19				add hl,de 
6516 22 c9 eb			ld (display_write_tmp),hl 
6519			 
6519 e5			push hl 
651a d5			push de 
651b c5			push bc 
651c 0e 07			ld c, 7 
651e			; TODO Replace with CP/M BIOS call 
651e				;rst $30 
651e 0e 02			ld c, 2 
6520 1e 0a			ld e, 10 
6522 cd 05 00			call 5 
6525 0e 02			ld c, 2 
6527 1e 0d			ld e, 13 
6529 cd 05 00			call 5 
652c c1			pop bc 
652d d1			pop de 
652e e1			pop hl 
652f			 
652f				 
652f 3e 50			ld a, kLCD_Line3 
6531			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6531 06 28			ld b, display_cols 
6533 ed 5b c9 eb		ld de, (display_write_tmp) 
6537 cd 66 65			call write_len_string 
653a				 
653a 2a c9 eb			ld hl, (display_write_tmp) 
653d 11 28 00			ld de, display_cols 
6540 19				add hl,de 
6541 22 c9 eb			ld (display_write_tmp),hl 
6544			 
6544 e5			push hl 
6545 d5			push de 
6546 c5			push bc 
6547 0e 07			ld c, 7 
6549			; TODO Replace with CP/M BIOS call 
6549				;rst $30 
6549 0e 02			ld c, 2 
654b 1e 0a			ld e, 10 
654d cd 05 00			call 5 
6550 0e 02			ld c, 2 
6552 1e 0d			ld e, 13 
6554 cd 05 00			call 5 
6557 c1			pop bc 
6558 d1			pop de 
6559 e1			pop hl 
655a			 
655a				 
655a 3e 78			ld a, kLCD_Line4 
655c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
655c 06 28			ld b, display_cols 
655e ed 5b c9 eb		ld de, (display_write_tmp) 
6562 cd 66 65			call write_len_string 
6565 c9					ret 
6566			 
6566			 
6566				; write out a fixed length string given in b from de 
6566			 
6566 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6567 cd 97 64		            CALL fLCD_Data      ;Write character to display 
656a 13				inc de 
656b 10 f9			djnz write_len_string 
656d c9				ret 
656e			 
656e			 
656e			; eof 
# End of file firmware_cpm_display.asm
656e			;include "firmware_key_5x10.asm" 
656e			;;include "firmware_key_4x10.asm" 
656e			include "firmware_key_cpm.asm" 
656e			; Serial keyboard interface for SC114 
656e			 
656e			 
656e			key_init: 
656e				; no init as handled by the SCM bios 
656e c9				ret 
656f			 
656f			 
656f			cin_wait: 
656f			;	ld a, 0 
656f			;	ret 
656f			 
656f				;in a,(SC114_SIO_1_IN) 
656f			        ; Use SCM API to get from whatever console device we are using 
656f			 
656f			; TODO Replace with CP/M BIOS call 
656f c5				push bc 
6570 0e 01			ld c, $01 
6572 cd 05 00			call 5 
6575 c1				pop bc 
6576 c9				ret 
6577			 
6577			cin: 
6577			 
6577			 
6577 c5				push bc 
6578			 
6578				; any key waiting to process? 
6578			; TODO Replace with CP/M BIOS call 
6578 0e 06			ld c, $06 
657a cd 05 00			call 5 
657d 28 0d			jr z, .cin_skip 
657f			 
657f				; yep, get it 
657f			 
657f 0e 01			ld c, $01 
6581			; TODO Replace with CP/M BIOS call 
6581 cd 05 00			call 5 
6584			 
6584 fe 7f			cp $7f     ; back space 
6586 20 02			jr nz, .skipbs 
6588 3e 08			ld a, KEY_BS 
658a			.skipbs: 
658a			 
658a c1				pop bc 
658b c9				ret 
658c			.cin_skip: 
658c 3e 00			ld a, 0 
658e c1				pop bc 
658f c9				ret 
6590			 
6590			 
6590			 
6590			 
# End of file firmware_key_cpm.asm
6590			endofcode:  
6590			baseram:  
6590 00				nop 
6591			 
6591			heap_start: equ baseram+15  ; Starting address of heap 
6591			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6591			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6591			;VDU:  EQU     endofcode           ; BASIC Work space 
6591			; eof 
6591			 
# End of file os_mega_cpm.asm
6591
