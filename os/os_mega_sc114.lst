# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 4b 94			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 0   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ os_input  
8003			os_new_parse_len: equ os_new_malloc + 2  
8003			os_new_word_len: equ os_new_parse_len + 2  
8003			os_new_work_ptr: equ os_new_word_len + 2  
8003			os_new_src_ptr: equ os_new_work_ptr + 2  
8003			os_new_exec: equ os_new_src_ptr + 2  
8003			os_new_exec_ptr: equ os_new_exec + 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ scratch - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 34 88				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 34 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 34 88				call clear_display  
8023			  
8023			  
8023 cd d2 d5				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 74 d6			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 00 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 57 88			call update_display  
8032 cd e2 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 39 88			call fill_display  
803a cd 57 88			call update_display  
803d cd e2 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 39 88			call fill_display  
8045 cd 57 88			call update_display  
8048 cd e2 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 39 88			call fill_display  
8050 cd 57 88			call update_display  
8053 cd e2 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 47 88			call str_at_display  
805e cd 57 88			call update_display  
8061			  
8061			  
8061 cd e2 87			call delay1s  
8064 cd e2 87			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 47 88			call str_at_display  
806f cd 57 88			call update_display  
8072 cd e2 87			call delay1s  
8075 cd e2 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 75 92			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 7a ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 7b ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 7c ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 75 92			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd c7 83			call storage_findnextid 
8105			 
8105 cd 86 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 65 eb			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 7a ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 7b ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 7c ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 75 92			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 7a ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 7b ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 7c ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 75 92			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 65 eb			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 7a ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 7b ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 7c ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 65 eb				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 75 92			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a 66 eb			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 7a ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 7b ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 7c ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 75 92			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 7a ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 7b ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 7c ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 75 92			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 21 65 eb			ld hl, store_page 
81d3 3e 00			ld a, 0 
81d5				 
81d5 77				ld (hl),a   ; reset file counter 
81d6			 
81d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81d9 22 66 eb		 	ld (store_page+1), hl	 
81dc			 
81dc				; set default label 
81dc			 
81dc 21 71 82			ld hl, .defaultbanklabl 
81df 11 68 eb		 	ld de, store_page+3 
81e2 01 0f 00			ld bc, 15 
81e5 ed b0			ldir 
81e7			 
81e7				; save default page 0 
81e7			 
81e7 21 00 00			ld hl, 0 
81ea 11 65 eb			ld de, store_page 
81ed				if DEBUG_STORESE 
81ed					DMARK "SB3" 
81ed f5				push af  
81ee 3a 02 82			ld a, (.dmark)  
81f1 32 7a ee			ld (debug_mark),a  
81f4 3a 03 82			ld a, (.dmark+1)  
81f7 32 7b ee			ld (debug_mark+1),a  
81fa 3a 04 82			ld a, (.dmark+2)  
81fd 32 7c ee			ld (debug_mark+2),a  
8200 18 03			jr .pastdmark  
8202 ..			.dmark: db "SB3"  
8205 f1			.pastdmark: pop af  
8206			endm  
# End of macro DMARK
8206			;		push af 
8206			;		ld a, 'F' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206					CALLMONITOR 
8206 cd 75 92			call break_point_state  
8209				endm  
# End of macro CALLMONITOR
8209				endif 
8209 cd 16 81			call storage_write_block 
820c				if DEBUG_STORESE 
820c					DMARK "SB4" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 7a ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 7b ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 7c ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SB4"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			;		push af 
8225			;		ld a, '>' 
8225			;		ld (debug_mark),a 
8225			;		pop af 
8225					CALLMONITOR 
8225 cd 75 92			call break_point_state  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228			 
8228 00				nop 
8229 00				nop 
822a 00				nop 
822b			 
822b				; now set 0 in every page to mark as a free block 
822b			 
822b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
822d 21 40 00			ld hl, STORE_BLOCK_PHY 
8230			 
8230 3e 00		.setmark1:   	ld a,0 
8232 e5					push hl 
8233 c5					push bc 
8234 cd af 80				call se_writebyte 
8237 3e 0a			ld a, 10 
8239 cd c7 87			call aDelayInMS 
823c 23				inc hl 
823d cd af 80				call se_writebyte 
8240 3e 0a			ld a, 10 
8242 cd c7 87			call aDelayInMS 
8245 2b				dec hl 
8246 c1					pop bc 
8247 e1					pop hl 
8248 3e 40				ld a, STORE_BLOCK_PHY 
824a cd 5d 8a				call addatohl 
824d 10 e1				djnz .setmark1 
824f			 
824f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8251 3e 00		.setmark2:   	ld a,0 
8253 e5					push hl 
8254 c5					push bc 
8255 cd af 80				call se_writebyte 
8258 3e 0a			ld a, 10 
825a cd c7 87			call aDelayInMS 
825d 23				inc hl 
825e cd af 80				call se_writebyte 
8261 3e 0a			ld a, 10 
8263 cd c7 87			call aDelayInMS 
8266 2b				dec hl 
8267 c1					pop bc 
8268 e1					pop hl 
8269 3e 40				ld a, STORE_BLOCK_PHY 
826b cd 5d 8a				call addatohl 
826e 10 e1				djnz .setmark2 
8270			 
8270					 
8270			 
8270			 
8270 c9				ret 
8271			 
8271			 
8271			 
8271			 
8271 .. 00		.defaultbanklabl:   db "BankLabel",0 
827b			 
827b			 
827b			 
827b			; Label Bank 
827b			; ---------- 
827b			; 
827b			; With current bank 
827b			; Read block 0 
827b			; Set label 
827b			; Write block 0 
827b			 
827b			; label str pointer in hl 
827b			 
827b			storage_label:     
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "LBL" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 7a ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 7b ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 7c ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "LBL"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					CALLMONITOR 
8294 cd 75 92			call break_point_state  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 e5				push hl 
8298			 
8298 cd 62 81			call storage_get_block_0 
829b			 
829b				; set default label 
829b			 
829b e1				pop hl 
829c			 
829c 11 68 eb		 	ld de, store_page+3 
829f 01 0f 00			ld bc, 15 
82a2				if DEBUG_STORESE 
82a2					DMARK "LB3" 
82a2 f5				push af  
82a3 3a b7 82			ld a, (.dmark)  
82a6 32 7a ee			ld (debug_mark),a  
82a9 3a b8 82			ld a, (.dmark+1)  
82ac 32 7b ee			ld (debug_mark+1),a  
82af 3a b9 82			ld a, (.dmark+2)  
82b2 32 7c ee			ld (debug_mark+2),a  
82b5 18 03			jr .pastdmark  
82b7 ..			.dmark: db "LB3"  
82ba f1			.pastdmark: pop af  
82bb			endm  
# End of macro DMARK
82bb					CALLMONITOR 
82bb cd 75 92			call break_point_state  
82be				endm  
# End of macro CALLMONITOR
82be				endif 
82be ed b0			ldir 
82c0				; save default page 0 
82c0			 
82c0 21 00 00			ld hl, 0 
82c3 11 65 eb			ld de, store_page 
82c6				if DEBUG_STORESE 
82c6					DMARK "LBW" 
82c6 f5				push af  
82c7 3a db 82			ld a, (.dmark)  
82ca 32 7a ee			ld (debug_mark),a  
82cd 3a dc 82			ld a, (.dmark+1)  
82d0 32 7b ee			ld (debug_mark+1),a  
82d3 3a dd 82			ld a, (.dmark+2)  
82d6 32 7c ee			ld (debug_mark+2),a  
82d9 18 03			jr .pastdmark  
82db ..			.dmark: db "LBW"  
82de f1			.pastdmark: pop af  
82df			endm  
# End of macro DMARK
82df					CALLMONITOR 
82df cd 75 92			call break_point_state  
82e2				endm  
# End of macro CALLMONITOR
82e2				endif 
82e2 cd 16 81			call storage_write_block 
82e5			 
82e5 c9				ret 
82e6			 
82e6			 
82e6			 
82e6			; Read Block 0 - Config 
82e6			; --------------------- 
82e6			; 
82e6			; With current bank 
82e6			; Call presence test 
82e6			;    If not present format/init bank  
82e6			; Read block 0  
82e6			;  
82e6			 
82e6			 
82e6			; Dir 
82e6			; --- 
82e6			; 
82e6			; With current bank 
82e6			; Load Block 0 Config 
82e6			; Get max file id number 
82e6			; For each logical block 
82e6			;    Read block read byte 2 
82e6			;      if first block of file 
82e6			;         Display file name 
82e6			;         Display type flags for file 
82e6			;        
82e6			 
82e6			; moving to words as this requires stack control 
82e6			 
82e6			 
82e6			; Delete File 
82e6			; ----------- 
82e6			; 
82e6			; With current bank 
82e6			; 
82e6			; Load Block 0 Config 
82e6			; Get max file id number 
82e6			; For each logical block 
82e6			;    Read block file id 
82e6			;      If first block of file and dont have file id 
82e6			;         if file to delete 
82e6			;         Save file id 
82e6			;         Null file id 
82e6			;         Write this block back 
82e6			;      If file id is one saved 
82e6			;         Null file id 
82e6			;         Write this block back 
82e6			 
82e6			storage_erase: 
82e6			 
82e6				; hl contains the file id 
82e6			 
82e6 5d				ld e, l 
82e7 16 00			ld d, 0 
82e9 21 40 00			ld hl, STORE_BLOCK_PHY 
82ec					if DEBUG_FORTH_WORDS 
82ec						DMARK "ERA" 
82ec f5				push af  
82ed 3a 01 83			ld a, (.dmark)  
82f0 32 7a ee			ld (debug_mark),a  
82f3 3a 02 83			ld a, (.dmark+1)  
82f6 32 7b ee			ld (debug_mark+1),a  
82f9 3a 03 83			ld a, (.dmark+2)  
82fc 32 7c ee			ld (debug_mark+2),a  
82ff 18 03			jr .pastdmark  
8301 ..			.dmark: db "ERA"  
8304 f1			.pastdmark: pop af  
8305			endm  
# End of macro DMARK
8305						CALLMONITOR 
8305 cd 75 92			call break_point_state  
8308				endm  
# End of macro CALLMONITOR
8308					endif 
8308 cd c7 83			call storage_findnextid 
830b			 
830b e5				push hl 
830c			 
830c				; TODO check file not found 
830c			 
830c 11 65 eb			ld de, store_page 
830f cd b1 80			call storage_read_block 
8312			 
8312					if DEBUG_FORTH_WORDS 
8312						DMARK "ER1" 
8312 f5				push af  
8313 3a 27 83			ld a, (.dmark)  
8316 32 7a ee			ld (debug_mark),a  
8319 3a 28 83			ld a, (.dmark+1)  
831c 32 7b ee			ld (debug_mark+1),a  
831f 3a 29 83			ld a, (.dmark+2)  
8322 32 7c ee			ld (debug_mark+2),a  
8325 18 03			jr .pastdmark  
8327 ..			.dmark: db "ER1"  
832a f1			.pastdmark: pop af  
832b			endm  
# End of macro DMARK
832b						CALLMONITOR 
832b cd 75 92			call break_point_state  
832e				endm  
# End of macro CALLMONITOR
832e					endif 
832e 3a 65 eb			ld a, (store_page)	; get file id 
8331 32 5e eb			ld (store_tmpid), a 
8334			 
8334 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
8337 32 5d eb			ld (store_tmpext), a 
833a			 
833a				; wipe file header 
833a			 
833a e1				pop hl 
833b 3e 00			ld a, 0 
833d 32 65 eb			ld (store_page), a 
8340 32 66 eb			ld (store_page+1),a 
8343 11 65 eb			ld de, store_page 
8346					if DEBUG_FORTH_WORDS 
8346						DMARK "ER2" 
8346 f5				push af  
8347 3a 5b 83			ld a, (.dmark)  
834a 32 7a ee			ld (debug_mark),a  
834d 3a 5c 83			ld a, (.dmark+1)  
8350 32 7b ee			ld (debug_mark+1),a  
8353 3a 5d 83			ld a, (.dmark+2)  
8356 32 7c ee			ld (debug_mark+2),a  
8359 18 03			jr .pastdmark  
835b ..			.dmark: db "ER2"  
835e f1			.pastdmark: pop af  
835f			endm  
# End of macro DMARK
835f						CALLMONITOR 
835f cd 75 92			call break_point_state  
8362				endm  
# End of macro CALLMONITOR
8362					endif 
8362 cd 16 81			call storage_write_block 
8365			 
8365			 
8365				; wipe file extents 
8365			 
8365 3a 5d eb			ld a, (store_tmpext) 
8368 47				ld b, a 
8369			 
8369			.eraext:	  
8369 c5				push bc 
836a			 
836a 21 40 00			ld hl, STORE_BLOCK_PHY 
836d 3a 5e eb			ld a,(store_tmpid) 
8370 5f				ld e, a 
8371 50				ld d, b	 
8372					if DEBUG_FORTH_WORDS 
8372						DMARK "ER3" 
8372 f5				push af  
8373 3a 87 83			ld a, (.dmark)  
8376 32 7a ee			ld (debug_mark),a  
8379 3a 88 83			ld a, (.dmark+1)  
837c 32 7b ee			ld (debug_mark+1),a  
837f 3a 89 83			ld a, (.dmark+2)  
8382 32 7c ee			ld (debug_mark+2),a  
8385 18 03			jr .pastdmark  
8387 ..			.dmark: db "ER3"  
838a f1			.pastdmark: pop af  
838b			endm  
# End of macro DMARK
838b						CALLMONITOR 
838b cd 75 92			call break_point_state  
838e				endm  
# End of macro CALLMONITOR
838e					endif 
838e cd c7 83			call storage_findnextid 
8391			 
8391 e5				push hl 
8392 11 65 eb			ld de, store_page 
8395 cd b1 80			call storage_read_block 
8398			 
8398				; free block	 
8398			 
8398 3e 00			ld a, 0 
839a 32 65 eb			ld (store_page), a 
839d 32 66 eb			ld (store_page+1),a 
83a0 11 65 eb			ld de, store_page 
83a3 e1				pop hl 
83a4					if DEBUG_FORTH_WORDS 
83a4						DMARK "ER4" 
83a4 f5				push af  
83a5 3a b9 83			ld a, (.dmark)  
83a8 32 7a ee			ld (debug_mark),a  
83ab 3a ba 83			ld a, (.dmark+1)  
83ae 32 7b ee			ld (debug_mark+1),a  
83b1 3a bb 83			ld a, (.dmark+2)  
83b4 32 7c ee			ld (debug_mark+2),a  
83b7 18 03			jr .pastdmark  
83b9 ..			.dmark: db "ER4"  
83bc f1			.pastdmark: pop af  
83bd			endm  
# End of macro DMARK
83bd						CALLMONITOR 
83bd cd 75 92			call break_point_state  
83c0				endm  
# End of macro CALLMONITOR
83c0					endif 
83c0 cd 16 81			call storage_write_block 
83c3			 
83c3 c1				pop bc 
83c4 10 a3			djnz .eraext 
83c6			 
83c6 c9				ret 
83c7			 
83c7			 
83c7			; Find Free Block 
83c7			; --------------- 
83c7			; 
83c7			; With current bank 
83c7			;  
83c7			; From given starting logical block 
83c7			;    Read block  
83c7			;    If no file id 
83c7			;         Return block id 
83c7			 
83c7			 
83c7			; hl starting page number 
83c7			; hl contains free page number or zero if no pages free 
83c7			; e contains the file id to locate 
83c7			; d contains the block number 
83c7			 
83c7			; TODO change to find file id and use zero for free block 
83c7			 
83c7			storage_findnextid: 
83c7			 
83c7				; now locate first 0 page to mark as a free block 
83c7			 
83c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83c9			;	ld hl, STORE_BLOCK_PHY 
83c9			 
83c9					if DEBUG_FORTH_WORDS 
83c9					DMARK "FNI" 
83c9 f5				push af  
83ca 3a de 83			ld a, (.dmark)  
83cd 32 7a ee			ld (debug_mark),a  
83d0 3a df 83			ld a, (.dmark+1)  
83d3 32 7b ee			ld (debug_mark+1),a  
83d6 3a e0 83			ld a, (.dmark+2)  
83d9 32 7c ee			ld (debug_mark+2),a  
83dc 18 03			jr .pastdmark  
83de ..			.dmark: db "FNI"  
83e1 f1			.pastdmark: pop af  
83e2			endm  
# End of macro DMARK
83e2						CALLMONITOR 
83e2 cd 75 92			call break_point_state  
83e5				endm  
# End of macro CALLMONITOR
83e5					endif 
83e5			.ff1:   	 
83e5 e5					push hl 
83e6 c5					push bc 
83e7 d5					push de 
83e8 cd ae 80				call se_readbyte 
83eb 5f					ld e,a 
83ec 23					inc hl 
83ed cd ae 80				call se_readbyte 
83f0 57					ld d, a 
83f1 e1					pop hl 
83f2 e5					push hl 
83f3 cd 7b 8a				call cmp16 
83f6 28 49				jr z, .fffound 
83f8			 
83f8 d1					pop de 
83f9 c1					pop bc 
83fa e1					pop hl 
83fb			 
83fb					; is found? 
83fb					;cp e 
83fb					;ret z 
83fb			 
83fb 3e 40				ld a, STORE_BLOCK_PHY 
83fd cd 5d 8a				call addatohl 
8400 10 e3				djnz .ff1 
8402			 
8402 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8404			.ff2:   	 
8404			 
8404 e5					push hl 
8405 c5					push bc 
8406 d5					push de 
8407 cd ae 80				call se_readbyte 
840a 5f					ld e,a 
840b 23					inc hl 
840c cd ae 80				call se_readbyte 
840f 57					ld d, a 
8410			 
8410 e1					pop hl 
8411 e5					push hl 
8412 cd 7b 8a				call cmp16 
8415 28 2a				jr z, .fffound 
8417			 
8417 d1					pop de 
8418 c1					pop bc 
8419 e1					pop hl 
841a					; is found? 
841a					;cp e 
841a					;ret z 
841a			 
841a 3e 40				ld a, STORE_BLOCK_PHY 
841c cd 5d 8a				call addatohl 
841f 10 e3				djnz .ff2 
8421			 
8421			 
8421					if DEBUG_FORTH_WORDS 
8421					DMARK "FN-" 
8421 f5				push af  
8422 3a 36 84			ld a, (.dmark)  
8425 32 7a ee			ld (debug_mark),a  
8428 3a 37 84			ld a, (.dmark+1)  
842b 32 7b ee			ld (debug_mark+1),a  
842e 3a 38 84			ld a, (.dmark+2)  
8431 32 7c ee			ld (debug_mark+2),a  
8434 18 03			jr .pastdmark  
8436 ..			.dmark: db "FN-"  
8439 f1			.pastdmark: pop af  
843a			endm  
# End of macro DMARK
843a					;	push af 
843a					;	ld a, 'n' 
843a					;	ld (debug_mark),a 
843a					;	pop af 
843a						CALLMONITOR 
843a cd 75 92			call break_point_state  
843d				endm  
# End of macro CALLMONITOR
843d					endif 
843d				; no free marks! 
843d 21 00 00				ld hl, 0 
8440 c9				ret 
8441			.fffound: 
8441				 
8441			 
8441 d1					pop de 
8442 c1					pop bc 
8443 e1					pop hl 
8444					if DEBUG_FORTH_WORDS 
8444					DMARK "FNF" 
8444 f5				push af  
8445 3a 59 84			ld a, (.dmark)  
8448 32 7a ee			ld (debug_mark),a  
844b 3a 5a 84			ld a, (.dmark+1)  
844e 32 7b ee			ld (debug_mark+1),a  
8451 3a 5b 84			ld a, (.dmark+2)  
8454 32 7c ee			ld (debug_mark+2),a  
8457 18 03			jr .pastdmark  
8459 ..			.dmark: db "FNF"  
845c f1			.pastdmark: pop af  
845d			endm  
# End of macro DMARK
845d					;	push af 
845d					;	ld a, 'n' 
845d					;	ld (debug_mark),a 
845d					;	pop af 
845d						CALLMONITOR 
845d cd 75 92			call break_point_state  
8460				endm  
# End of macro CALLMONITOR
8460					endif 
8460 c9				ret 
8461			 
8461			 
8461			 
8461			; Free Space 
8461			; ---------- 
8461			; 
8461			; With current bank 
8461			; 
8461			; Set block count to zero 
8461			; Starting with first logical block 
8461			;      Find free block  
8461			;      If block id given, increment block count 
8461			; 
8461			;  
8461			 
8461			 
8461			; hl contains count of free blocks 
8461			 
8461			storage_freeblocks: 
8461			 
8461				; now locate first 0 page to mark as a free block 
8461			 
8461 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8463 21 40 00			ld hl, STORE_BLOCK_PHY 
8466 11 00 00			ld de, 0 
8469			 
8469			.fb1:   	 
8469 e5					push hl 
846a c5					push bc 
846b d5					push de 
846c cd ae 80				call se_readbyte 
846f d1					pop de 
8470 c1					pop bc 
8471 e1					pop hl 
8472			 
8472					; is free? 
8472 fe 00				cp 0 
8474 20 01				jr nz, .ff1cont 
8476 13					inc de 
8477			 
8477			.ff1cont: 
8477			 
8477			 
8477 3e 40				ld a, STORE_BLOCK_PHY 
8479 cd 5d 8a				call addatohl 
847c 10 eb				djnz .fb1 
847e			 
847e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8480			.fb2:   	 
8480 e5					push hl 
8481 c5					push bc 
8482 d5					push de 
8483 cd ae 80				call se_readbyte 
8486 d1					pop de 
8487 c1					pop bc 
8488 e1					pop hl 
8489			 
8489					; is free? 
8489 fe 00				cp 0 
848b 20 01				jr nz, .ff2cont 
848d 13					inc de 
848e			 
848e			.ff2cont: 
848e			 
848e 3e 40				ld a, STORE_BLOCK_PHY 
8490 cd 5d 8a				call addatohl 
8493 10 eb				djnz .fb2 
8495			 
8495 eb				ex de, hl 
8496 c9				ret 
8497			 
8497			; Get File ID 
8497			; ----------- 
8497			; 
8497			; With current bank 
8497			;  
8497			; Load Block 0 Config 
8497			; Get max file id number 
8497			; For each logical block 
8497			;    Read block file id 
8497			;      If first block of file and dont have file id 
8497			;         if file get id and exit 
8497			 
8497			 
8497			 
8497			 
8497			; Create File 
8497			; ----------- 
8497			; 
8497			; With current bank  
8497			; Load Block 0 Config 
8497			; Get max file id number 
8497			; Increment file id number 
8497			; Save Config 
8497			; Find free block 
8497			; Set buffer with file name and file id 
8497			; Write buffer to free block  
8497			 
8497			 
8497			; hl point to file name 
8497			; hl returns file id 
8497			 
8497			; file format: 
8497			; byte 0 - file id 
8497			; byte 1 - extent number 
8497			; byte 2-> data 
8497			 
8497			; format for extent number 0: 
8497			; 
8497			; byte 0 - file id 
8497			; byte 1 - extent 0 
8497			; byte 2 - extent count 
8497			; byte 3 -> file name and meta data 
8497			 
8497			 
8497			storage_create: 
8497				if DEBUG_STORESE 
8497					DMARK "SCR" 
8497 f5				push af  
8498 3a ac 84			ld a, (.dmark)  
849b 32 7a ee			ld (debug_mark),a  
849e 3a ad 84			ld a, (.dmark+1)  
84a1 32 7b ee			ld (debug_mark+1),a  
84a4 3a ae 84			ld a, (.dmark+2)  
84a7 32 7c ee			ld (debug_mark+2),a  
84aa 18 03			jr .pastdmark  
84ac ..			.dmark: db "SCR"  
84af f1			.pastdmark: pop af  
84b0			endm  
# End of macro DMARK
84b0					CALLMONITOR 
84b0 cd 75 92			call break_point_state  
84b3				endm  
# End of macro CALLMONITOR
84b3				endif 
84b3			 
84b3 e5				push hl		; save file name pointer 
84b4			 
84b4 cd 62 81			call storage_get_block_0 
84b7			 
84b7 3a 65 eb			ld a,(store_page)	; get current file id 
84ba 3c				inc a 
84bb 32 65 eb			ld (store_page),a 
84be				 
84be 32 5e eb			ld (store_tmpid),a			; save id 
84c1			 
84c1 21 00 00			ld hl, 0 
84c4 11 65 eb			ld de, store_page 
84c7				if DEBUG_STORESE 
84c7					DMARK "SCw" 
84c7 f5				push af  
84c8 3a dc 84			ld a, (.dmark)  
84cb 32 7a ee			ld (debug_mark),a  
84ce 3a dd 84			ld a, (.dmark+1)  
84d1 32 7b ee			ld (debug_mark+1),a  
84d4 3a de 84			ld a, (.dmark+2)  
84d7 32 7c ee			ld (debug_mark+2),a  
84da 18 03			jr .pastdmark  
84dc ..			.dmark: db "SCw"  
84df f1			.pastdmark: pop af  
84e0			endm  
# End of macro DMARK
84e0					CALLMONITOR 
84e0 cd 75 92			call break_point_state  
84e3				endm  
# End of macro CALLMONITOR
84e3				endif 
84e3 cd 16 81			call storage_write_block	 ; save update 
84e6			 
84e6				if DEBUG_STORESE 
84e6 11 65 eb				ld de, store_page 
84e9					DMARK "SCC" 
84e9 f5				push af  
84ea 3a fe 84			ld a, (.dmark)  
84ed 32 7a ee			ld (debug_mark),a  
84f0 3a ff 84			ld a, (.dmark+1)  
84f3 32 7b ee			ld (debug_mark+1),a  
84f6 3a 00 85			ld a, (.dmark+2)  
84f9 32 7c ee			ld (debug_mark+2),a  
84fc 18 03			jr .pastdmark  
84fe ..			.dmark: db "SCC"  
8501 f1			.pastdmark: pop af  
8502			endm  
# End of macro DMARK
8502					CALLMONITOR 
8502 cd 75 92			call break_point_state  
8505				endm  
# End of macro CALLMONITOR
8505				endif 
8505				;  
8505				 
8505 21 40 00			ld hl, STORE_BLOCK_PHY 
8508 11 00 00			ld de, 0 
850b cd c7 83			call storage_findnextid 
850e			 
850e 22 63 eb			ld (store_tmppageid), hl    ; save page to use  
8511			 
8511				; TODO detect 0 = no spare blocks 
8511			 
8511				; hl now contains the free page to use for the file header page 
8511			 
8511				if DEBUG_STORESE 
8511				DMARK "SCF" 
8511 f5				push af  
8512 3a 26 85			ld a, (.dmark)  
8515 32 7a ee			ld (debug_mark),a  
8518 3a 27 85			ld a, (.dmark+1)  
851b 32 7b ee			ld (debug_mark+1),a  
851e 3a 28 85			ld a, (.dmark+2)  
8521 32 7c ee			ld (debug_mark+2),a  
8524 18 03			jr .pastdmark  
8526 ..			.dmark: db "SCF"  
8529 f1			.pastdmark: pop af  
852a			endm  
# End of macro DMARK
852a					CALLMONITOR 
852a cd 75 92			call break_point_state  
852d				endm  
# End of macro CALLMONITOR
852d				endif 
852d			 
852d 22 63 eb			ld (store_tmppageid), hl 
8530				 
8530 3a 5e eb			ld a,(store_tmpid)    ; get file id 
8533			;	ld a, (store_filecache)			; save to cache 
8533			 
8533 32 65 eb			ld (store_page),a    ; set page id 
8536 3e 00			ld a, 0			 ; extent 0 is file header 
8538 32 66 eb			ld (store_page+1), a   ; set file extent 
853b			 
853b 32 67 eb			ld (store_page+2), a   ; extent count for the file 
853e			 
853e			;	inc hl 		; init block 0 of file 
853e			;	inc hl   		; skip file and extent id 
853e			 ;       ld a, 0 
853e			;	ld (hl),a 
853e			;	ld a, (store_filecache+1)  	; save to cache 
853e			 
853e			;	inc hl    ; file name 
853e				 
853e				 
853e 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
8541				if DEBUG_STORESE 
8541					DMARK "SCc" 
8541 f5				push af  
8542 3a 56 85			ld a, (.dmark)  
8545 32 7a ee			ld (debug_mark),a  
8548 3a 57 85			ld a, (.dmark+1)  
854b 32 7b ee			ld (debug_mark+1),a  
854e 3a 58 85			ld a, (.dmark+2)  
8551 32 7c ee			ld (debug_mark+2),a  
8554 18 03			jr .pastdmark  
8556 ..			.dmark: db "SCc"  
8559 f1			.pastdmark: pop af  
855a			endm  
# End of macro DMARK
855a					CALLMONITOR 
855a cd 75 92			call break_point_state  
855d				endm  
# End of macro CALLMONITOR
855d				endif 
855d e1				pop hl    ; get zero term string 
855e e5				push hl 
855f 3e 00			ld a, 0 
8561 cd c6 8e			call strlent 
8564 23				inc hl   ; cover zero term 
8565 06 00			ld b,0 
8567 4d				ld c,l 
8568 e1				pop hl 
8569				;ex de, hl 
8569				if DEBUG_STORESE 
8569					DMARK "SCa" 
8569 f5				push af  
856a 3a 7e 85			ld a, (.dmark)  
856d 32 7a ee			ld (debug_mark),a  
8570 3a 7f 85			ld a, (.dmark+1)  
8573 32 7b ee			ld (debug_mark+1),a  
8576 3a 80 85			ld a, (.dmark+2)  
8579 32 7c ee			ld (debug_mark+2),a  
857c 18 03			jr .pastdmark  
857e ..			.dmark: db "SCa"  
8581 f1			.pastdmark: pop af  
8582			endm  
# End of macro DMARK
8582					;push af 
8582					;ld a, 'a' 
8582					;ld (debug_mark),a 
8582					;pop af 
8582					CALLMONITOR 
8582 cd 75 92			call break_point_state  
8585				endm  
# End of macro CALLMONITOR
8585				endif 
8585 ed b0			ldir    ; copy zero term string 
8587				if DEBUG_STORESE 
8587					DMARK "SCA" 
8587 f5				push af  
8588 3a 9c 85			ld a, (.dmark)  
858b 32 7a ee			ld (debug_mark),a  
858e 3a 9d 85			ld a, (.dmark+1)  
8591 32 7b ee			ld (debug_mark+1),a  
8594 3a 9e 85			ld a, (.dmark+2)  
8597 32 7c ee			ld (debug_mark+2),a  
859a 18 03			jr .pastdmark  
859c ..			.dmark: db "SCA"  
859f f1			.pastdmark: pop af  
85a0			endm  
# End of macro DMARK
85a0					CALLMONITOR 
85a0 cd 75 92			call break_point_state  
85a3				endm  
# End of macro CALLMONITOR
85a3				endif 
85a3			 
85a3				; write file header page 
85a3			 
85a3 2a 63 eb			ld hl,(store_tmppageid) 
85a6 11 65 eb			ld de, store_page 
85a9				if DEBUG_STORESE 
85a9					DMARK "SCb" 
85a9 f5				push af  
85aa 3a be 85			ld a, (.dmark)  
85ad 32 7a ee			ld (debug_mark),a  
85b0 3a bf 85			ld a, (.dmark+1)  
85b3 32 7b ee			ld (debug_mark+1),a  
85b6 3a c0 85			ld a, (.dmark+2)  
85b9 32 7c ee			ld (debug_mark+2),a  
85bc 18 03			jr .pastdmark  
85be ..			.dmark: db "SCb"  
85c1 f1			.pastdmark: pop af  
85c2			endm  
# End of macro DMARK
85c2					;push af 
85c2					;ld a, 'b' 
85c2					;ld (debug_mark),a 
85c2					;pop af 
85c2					CALLMONITOR 
85c2 cd 75 92			call break_point_state  
85c5				endm  
# End of macro CALLMONITOR
85c5				endif 
85c5 cd 16 81			call storage_write_block 
85c8			 
85c8 3a 5e eb			ld a, (store_tmpid) 
85cb 6f				ld l, a 
85cc 26 00			ld h,0 
85ce				if DEBUG_STORESE 
85ce					DMARK "SCz" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 7a ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 7b ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 7c ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCz"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 75 92			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea c9				ret 
85eb				 
85eb			 
85eb			 
85eb			; 
85eb			; Read File 
85eb			; 
85eb			; h - file id to locate 
85eb			; l - extent to locate 
85eb			; de - pointer to string to read into 
85eb			; 
85eb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85eb			storage_read: 
85eb d5				push de 
85ec			 
85ec			; TODO BUG the above push is it popped before the RET Z? 
85ec			 
85ec			; TODO how to handle multiple part blocks 
85ec			 
85ec				; locate file extent to read 
85ec			 
85ec 5c				ld e, h 
85ed 55				ld d, l 
85ee 21 40 00			ld hl, STORE_BLOCK_PHY 
85f1				if DEBUG_STORESE 
85f1					DMARK "SRE" 
85f1 f5				push af  
85f2 3a 06 86			ld a, (.dmark)  
85f5 32 7a ee			ld (debug_mark),a  
85f8 3a 07 86			ld a, (.dmark+1)  
85fb 32 7b ee			ld (debug_mark+1),a  
85fe 3a 08 86			ld a, (.dmark+2)  
8601 32 7c ee			ld (debug_mark+2),a  
8604 18 03			jr .pastdmark  
8606 ..			.dmark: db "SRE"  
8609 f1			.pastdmark: pop af  
860a			endm  
# End of macro DMARK
860a					CALLMONITOR 
860a cd 75 92			call break_point_state  
860d				endm  
# End of macro CALLMONITOR
860d				endif 
860d cd c7 83			call storage_findnextid 
8610			 
8610				if DEBUG_STORESE 
8610					DMARK "SRf" 
8610 f5				push af  
8611 3a 25 86			ld a, (.dmark)  
8614 32 7a ee			ld (debug_mark),a  
8617 3a 26 86			ld a, (.dmark+1)  
861a 32 7b ee			ld (debug_mark+1),a  
861d 3a 27 86			ld a, (.dmark+2)  
8620 32 7c ee			ld (debug_mark+2),a  
8623 18 03			jr .pastdmark  
8625 ..			.dmark: db "SRf"  
8628 f1			.pastdmark: pop af  
8629			endm  
# End of macro DMARK
8629					CALLMONITOR 
8629 cd 75 92			call break_point_state  
862c				endm  
# End of macro CALLMONITOR
862c				endif 
862c cd 86 8a			call ishlzero 
862f			;	ld a, l 
862f			;	add h 
862f			;	cp 0 
862f c8				ret z			; block not found so EOF 
8630			 
8630				; hl contains page number to load 
8630 d1				pop de   ; get storage 
8631 d5				push de 
8632				if DEBUG_STORESE 
8632					DMARK "SRg" 
8632 f5				push af  
8633 3a 47 86			ld a, (.dmark)  
8636 32 7a ee			ld (debug_mark),a  
8639 3a 48 86			ld a, (.dmark+1)  
863c 32 7b ee			ld (debug_mark+1),a  
863f 3a 49 86			ld a, (.dmark+2)  
8642 32 7c ee			ld (debug_mark+2),a  
8645 18 03			jr .pastdmark  
8647 ..			.dmark: db "SRg"  
864a f1			.pastdmark: pop af  
864b			endm  
# End of macro DMARK
864b					CALLMONITOR 
864b cd 75 92			call break_point_state  
864e				endm  
# End of macro CALLMONITOR
864e				endif 
864e cd b1 80			call storage_read_block 
8651			 
8651			 
8651			; TODO if block has no zeros then need to read next block  
8651			 
8651			 
8651					 
8651 e1				pop hl 		 ; return start of data to show as not EOF 
8652 23				inc hl   ; past file id 
8653 23				inc hl   ; past ext 
8654				if DEBUG_STORESE 
8654					DMARK "SRe" 
8654 f5				push af  
8655 3a 69 86			ld a, (.dmark)  
8658 32 7a ee			ld (debug_mark),a  
865b 3a 6a 86			ld a, (.dmark+1)  
865e 32 7b ee			ld (debug_mark+1),a  
8661 3a 6b 86			ld a, (.dmark+2)  
8664 32 7c ee			ld (debug_mark+2),a  
8667 18 03			jr .pastdmark  
8669 ..			.dmark: db "SRe"  
866c f1			.pastdmark: pop af  
866d			endm  
# End of macro DMARK
866d					CALLMONITOR 
866d cd 75 92			call break_point_state  
8670				endm  
# End of macro CALLMONITOR
8670				endif 
8670 c9					ret 
8671			 
8671			 
8671			 
8671			; 
8671			; Append File 
8671			; 
8671			; hl - file id to locate 
8671			; de - pointer to (multi block) string to write 
8671			 
8671			 
8671			storage_append: 
8671				; hl -  file id to append to 
8671				; de - string to append 
8671			 
8671 d5				push de 
8672				 
8672				if DEBUG_STORESE 
8672					DMARK "AP1" 
8672 f5				push af  
8673 3a 87 86			ld a, (.dmark)  
8676 32 7a ee			ld (debug_mark),a  
8679 3a 88 86			ld a, (.dmark+1)  
867c 32 7b ee			ld (debug_mark+1),a  
867f 3a 89 86			ld a, (.dmark+2)  
8682 32 7c ee			ld (debug_mark+2),a  
8685 18 03			jr .pastdmark  
8687 ..			.dmark: db "AP1"  
868a f1			.pastdmark: pop af  
868b			endm  
# End of macro DMARK
868b					CALLMONITOR 
868b cd 75 92			call break_point_state  
868e				endm  
# End of macro CALLMONITOR
868e				endif 
868e			 
868e 7d				ld a, l 
868f 32 5e eb			ld (store_tmpid), a 
8692			 
8692				; get file header  
8692			 
8692 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8694 3a 5e eb			ld a, (store_tmpid) 
8697 5f				ld e, a 
8698			 
8698 21 40 00				ld hl, STORE_BLOCK_PHY 
869b cd c7 83				call storage_findnextid 
869e			 
869e 22 63 eb			ld (store_tmppageid), hl 
86a1			 
86a1				; TODO handle file id not found 
86a1			 
86a1				if DEBUG_STORESE 
86a1					DMARK "AP2" 
86a1 f5				push af  
86a2 3a b6 86			ld a, (.dmark)  
86a5 32 7a ee			ld (debug_mark),a  
86a8 3a b7 86			ld a, (.dmark+1)  
86ab 32 7b ee			ld (debug_mark+1),a  
86ae 3a b8 86			ld a, (.dmark+2)  
86b1 32 7c ee			ld (debug_mark+2),a  
86b4 18 03			jr .pastdmark  
86b6 ..			.dmark: db "AP2"  
86b9 f1			.pastdmark: pop af  
86ba			endm  
# End of macro DMARK
86ba					CALLMONITOR 
86ba cd 75 92			call break_point_state  
86bd				endm  
# End of macro CALLMONITOR
86bd				endif 
86bd			 
86bd				; update file extent count 
86bd			 
86bd 11 65 eb			ld de, store_page 
86c0			 
86c0 cd b1 80			call storage_read_block 
86c3			 
86c3				if DEBUG_STORESE 
86c3					DMARK "AP3" 
86c3 f5				push af  
86c4 3a d8 86			ld a, (.dmark)  
86c7 32 7a ee			ld (debug_mark),a  
86ca 3a d9 86			ld a, (.dmark+1)  
86cd 32 7b ee			ld (debug_mark+1),a  
86d0 3a da 86			ld a, (.dmark+2)  
86d3 32 7c ee			ld (debug_mark+2),a  
86d6 18 03			jr .pastdmark  
86d8 ..			.dmark: db "AP3"  
86db f1			.pastdmark: pop af  
86dc			endm  
# End of macro DMARK
86dc					CALLMONITOR 
86dc cd 75 92			call break_point_state  
86df				endm  
# End of macro CALLMONITOR
86df				endif 
86df			;	ld (store_tmppageid), hl 
86df			 
86df 3a 67 eb			ld a, (store_page+2) 
86e2 3c				inc a 
86e3 32 67 eb			ld (store_page+2), a 
86e6 32 5d eb			ld (store_tmpext), a 
86e9				 
86e9				if DEBUG_STORESE 
86e9					DMARK "AP3" 
86e9 f5				push af  
86ea 3a fe 86			ld a, (.dmark)  
86ed 32 7a ee			ld (debug_mark),a  
86f0 3a ff 86			ld a, (.dmark+1)  
86f3 32 7b ee			ld (debug_mark+1),a  
86f6 3a 00 87			ld a, (.dmark+2)  
86f9 32 7c ee			ld (debug_mark+2),a  
86fc 18 03			jr .pastdmark  
86fe ..			.dmark: db "AP3"  
8701 f1			.pastdmark: pop af  
8702			endm  
# End of macro DMARK
8702					CALLMONITOR 
8702 cd 75 92			call break_point_state  
8705				endm  
# End of macro CALLMONITOR
8705				endif 
8705 2a 63 eb			ld hl, (store_tmppageid) 
8708 11 65 eb			ld de, store_page 
870b cd 16 81			call storage_write_block 
870e			 
870e				; find free block 
870e			 
870e 11 00 00			ld de, 0			 ; file extent to locate 
8711			 
8711 21 40 00				ld hl, STORE_BLOCK_PHY 
8714 cd c7 83				call storage_findnextid 
8717			 
8717					; TODO handle no space left 
8717					 
8717 22 63 eb				ld (store_tmppageid), hl 
871a			 
871a				if DEBUG_STORESE 
871a					DMARK "AP4" 
871a f5				push af  
871b 3a 2f 87			ld a, (.dmark)  
871e 32 7a ee			ld (debug_mark),a  
8721 3a 30 87			ld a, (.dmark+1)  
8724 32 7b ee			ld (debug_mark+1),a  
8727 3a 31 87			ld a, (.dmark+2)  
872a 32 7c ee			ld (debug_mark+2),a  
872d 18 03			jr .pastdmark  
872f ..			.dmark: db "AP4"  
8732 f1			.pastdmark: pop af  
8733			endm  
# End of macro DMARK
8733					CALLMONITOR 
8733 cd 75 92			call break_point_state  
8736				endm  
# End of macro CALLMONITOR
8736				endif 
8736					; init the buffer with zeros so we can id if the buffer is full or not 
8736			 
8736 e5					push hl 
8737 c5					push bc 
8738			 
8738 21 65 eb				ld hl, store_page 
873b 06 40				ld b, STORE_BLOCK_PHY 
873d 3e 00				ld a, 0 
873f 77			.zeroblock:	ld (hl), a 
8740 23					inc hl 
8741 10 fc				djnz .zeroblock 
8743			 
8743 c1					pop bc 
8744 e1					pop hl 
8745			 
8745					; construct block 
8745			 
8745 3a 5e eb				ld a, (store_tmpid) 
8748 32 65 eb				ld (store_page), a   ; file id 
874b 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
874e 32 66 eb				ld (store_page+1), a 
8751			 
8751 e1					pop hl    ; get string to write 
8752 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8754 11 67 eb				ld de, store_page+2 
8757			 
8757				if DEBUG_STORESE 
8757					DMARK "AP5" 
8757 f5				push af  
8758 3a 6c 87			ld a, (.dmark)  
875b 32 7a ee			ld (debug_mark),a  
875e 3a 6d 87			ld a, (.dmark+1)  
8761 32 7b ee			ld (debug_mark+1),a  
8764 3a 6e 87			ld a, (.dmark+2)  
8767 32 7c ee			ld (debug_mark+2),a  
876a 18 03			jr .pastdmark  
876c ..			.dmark: db "AP5"  
876f f1			.pastdmark: pop af  
8770			endm  
# End of macro DMARK
8770					CALLMONITOR 
8770 cd 75 92			call break_point_state  
8773				endm  
# End of macro CALLMONITOR
8773				endif 
8773			 
8773			 
8773			 
8773					; fill buffer with data until end of string or full block 
8773			 
8773 7e			.appd:		ld a, (hl) 
8774 12					ld (de), a 
8775 fe 00				cp 0 
8777 28 04				jr z, .appdone 
8779 23					inc hl 
877a 13					inc de 
877b 10 f6				djnz .appd 
877d			 
877d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
877e f5					push af   		; save last byte dumped 
877f			 
877f			 
877f 2a 63 eb			ld hl, (store_tmppageid) 
8782 11 65 eb			ld de, store_page 
8785				if DEBUG_STORESE 
8785					DMARK "AP6" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 7a ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 7b ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 7c ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "AP6"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 75 92			call break_point_state  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 cd 16 81				call storage_write_block 
87a4			 
87a4			 
87a4				; was that a full block of data written? 
87a4				; any more to write out? 
87a4			 
87a4				; if yes then set vars and jump to start of function again 
87a4			 
87a4 f1					pop af 
87a5 d1					pop de 
87a6			 
87a6 fe 00				cp 0		 ; no, string was fully written 
87a8 c8					ret z 
87a9			 
87a9					; setup vars for next cycle 
87a9			 
87a9 3a 5e eb				ld a, (store_tmpid) 
87ac 6f					ld l, a 
87ad 26 00				ld h, 0 
87af			 
87af c3 71 86			 	jp storage_append	 ; yes, need to write out some more 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			 
87b2			if DEBUG_STORECF 
87b2			storageput:	 
87b2					ret 
87b2			storageread: 
87b2					ld hl, store_page 
87b2					ld b, 200 
87b2					ld a,0 
87b2			.src:		ld (hl),a 
87b2					inc hl 
87b2					djnz .src 
87b2					 
87b2			 
87b2					ld de, 0 
87b2					ld bc, 1 
87b2					ld hl, store_page 
87b2					call cfRead 
87b2			 
87b2				call cfGetError 
87b2				ld hl,scratch 
87b2				call hexout 
87b2				ld hl, scratch+2 
87b2				ld a, 0 
87b2				ld (hl),a 
87b2				ld de, scratch 
87b2				ld a,display_row_1 
87b2				call str_at_display 
87b2				call update_display 
87b2			 
87b2					ld hl, store_page 
87b2					ld (os_cur_ptr),hl 
87b2			 
87b2					ret 
87b2			endif 
87b2			 
87b2			 
87b2			; Clear out the main buffer store (used to remove junk before writing a new block) 
87b2			 
87b2			storage_clear_page: 
87b2 e5				push hl 
87b3 d5				push de 
87b4 c5				push bc 
87b5 21 65 eb			ld hl, store_page 
87b8 3e 00			ld a, 0 
87ba 77				ld (hl), a 
87bb			 
87bb 11 66 eb			ld de, store_page+1 
87be 01 40 00			ld bc, STORE_BLOCK_PHY 
87c1			 
87c1 ed b0			ldir 
87c3				 
87c3 c1				pop bc 
87c4 d1				pop de 
87c5 e1				pop hl 
87c6 c9				ret 
87c7			 
87c7			; eof 
# End of file firmware_storage.asm
87c7			  
87c7			; support routines for above hardware abstraction layer  
87c7			  
87c7			include "firmware_general.asm"        ; general support functions  
87c7			 
87c7			 
87c7			 
87c7			; Delay loops 
87c7			 
87c7			 
87c7			 
87c7			aDelayInMS: 
87c7 c5				push bc 
87c8 47				ld b,a 
87c9			msdelay: 
87c9 c5				push bc 
87ca				 
87ca			 
87ca 01 41 00			ld bc,041h 
87cd cd e5 87			call delayloop 
87d0 c1				pop bc 
87d1 05				dec b 
87d2 20 f5			jr nz,msdelay 
87d4			 
87d4			;if CPU_CLOCK_8MHZ 
87d4			;msdelay8: 
87d4			;	push bc 
87d4			;	 
87d4			; 
87d4			;	ld bc,041h 
87d4			;	call delayloop 
87d4			;	pop bc 
87d4			;	dec b 
87d4			;	jr nz,msdelay8 
87d4			;endif 
87d4			 
87d4			 
87d4 c1				pop bc 
87d5 c9				ret 
87d6			 
87d6			 
87d6			delay250ms: 
87d6				;push de 
87d6 01 00 40			ld bc, 04000h 
87d9 c3 e5 87			jp delayloop 
87dc			delay500ms: 
87dc				;push de 
87dc 01 00 80			ld bc, 08000h 
87df c3 e5 87			jp delayloop 
87e2			delay1s: 
87e2				;push bc 
87e2			   ; Clobbers A, d and e 
87e2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87e5			delayloop: 
87e5 c5			    push bc 
87e6			 
87e6			if BASE_CPM 
87e6				ld bc, CPM_DELAY_TUNE 
87e6			.cpmloop: 
87e6				push bc 
87e6			 
87e6			endif 
87e6			 
87e6			 
87e6			 
87e6			delayloopi: 
87e6			;	push bc 
87e6			;.dl: 
87e6 cb 47		    bit     0,a    	; 8 
87e8 cb 47		    bit     0,a    	; 8 
87ea cb 47		    bit     0,a    	; 8 
87ec e6 ff		    and     255  	; 7 
87ee 0b			    dec     bc      	; 6 
87ef 79			    ld      a,c     	; 4 
87f0 b0			    or      b     	; 4 
87f1 c2 e6 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
87f4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
87f4				;pop de 
87f4			;pop bc 
87f4			 
87f4			if BASE_CPM 
87f4				pop bc 
87f4				 
87f4			    dec     bc      	; 6 
87f4			    ld      a,c     	; 4 
87f4			    or      b     	; 4 
87f4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
87f4				 
87f4			 
87f4			endif 
87f4			;if CPU_CLOCK_8MHZ 
87f4			;    pop bc 
87f4			;    push bc 
87f4			;.dl8: 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    and     255  	; 7 
87f4			;    dec     bc      	; 6 
87f4			;    ld      a,c     	; 4 
87f4			;    or      b     	; 4 
87f4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87f4			;endif 
87f4			 
87f4			;if CPU_CLOCK_10MHZ 
87f4			;    pop bc 
87f4			;    push bc 
87f4			;.dl8: 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    bit     0,a    	; 8 
87f4			;    and     255  	; 7 
87f4			;    dec     bc      	; 6 
87f4			;    ld      a,c     	; 4 
87f4			;    or      b     	; 4 
87f4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87f4			;endif 
87f4 c1			    pop bc 
87f5			 
87f5 c9				ret 
87f6			 
87f6			 
87f6			 
87f6			; eof 
# End of file firmware_general.asm
87f6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
87f6			; display routines that use the physical hardware abstraction layer 
87f6			 
87f6			 
87f6			; TODO windowing? 
87f6			 
87f6			; TODO scroll line up 
87f6			 
87f6			scroll_up: 
87f6			 
87f6 e5				push hl 
87f7 d5				push de 
87f8 c5				push bc 
87f9			 
87f9				; get frame buffer  
87f9			 
87f9 2a db eb			ld hl, (display_fb_active) 
87fc e5				push hl    ; future de destination 
87fd			 
87fd 11 28 00			ld  de, display_cols 
8800 19				add hl, de 
8801			 
8801 d1				pop de 
8802			 
8802				;ex de, hl 
8802 01 9f 00			ld bc, display_fb_len -1  
8805			;if DEBUG_FORTH_WORDS 
8805			;	DMARK "SCL" 
8805			;	CALLMONITOR 
8805			;endif	 
8805 ed b0			ldir 
8807			 
8807				; wipe bottom row 
8807			 
8807			 
8807 2a db eb			ld hl, (display_fb_active) 
880a 11 a0 00			ld de, display_cols*display_rows 
880d 19				add hl, de 
880e 06 28			ld b, display_cols 
8810 3e 20			ld a, ' ' 
8812			.scwipe: 
8812 77				ld (hl), a 
8813 2b				dec hl 
8814 10 fc			djnz .scwipe 
8816			 
8816				;pop hl 
8816			 
8816 c1				pop bc 
8817 d1				pop de 
8818 e1				pop hl 
8819			 
8819 c9				ret 
881a			 
881a			 
881a			;scroll_upo: 
881a			;	ld de, display_row_1 
881a			 ;	ld hl, display_row_2 
881a			;	ld bc, display_cols 
881a			;	ldir 
881a			;	ld de, display_row_2 
881a			 ;	ld hl, display_row_3 
881a			;	ld bc, display_cols 
881a			;	ldir 
881a			;	ld de, display_row_3 
881a			 ;	ld hl, display_row_4 
881a			;	ld bc, display_cols 
881a			;	ldir 
881a			 
881a			; TODO clear row 4 
881a			 
881a			;	ret 
881a			 
881a				 
881a			scroll_down: 
881a			 
881a e5				push hl 
881b d5				push de 
881c c5				push bc 
881d			 
881d				; get frame buffer  
881d			 
881d 2a db eb			ld hl, (display_fb_active) 
8820			 
8820 11 9f 00			ld de, display_fb_len - 1 
8823 19				add hl, de 
8824			 
8824 e5			push hl    ; future de destination 
8825			 
8825 11 28 00			ld  de, display_cols 
8828 ed 52			sbc hl, de 
882a			 
882a			 
882a d1				pop de 
882b			 
882b			;	ex de, hl 
882b 01 9f 00			ld bc, display_fb_len -1  
882e			 
882e			 
882e				 
882e			 
882e ed b0			ldir 
8830			 
8830				; wipe bottom row 
8830			 
8830			 
8830			;	ld hl, (display_fb_active) 
8830			;;	ld de, display_cols*display_rows 
8830			;;	add hl, de 
8830			;	ld b, display_cols 
8830			;	ld a, ' ' 
8830			;.scwiped: 
8830			;	ld (hl), a 
8830			;	dec hl 
8830			;	djnz .scwiped 
8830			 
8830				;pop hl 
8830			 
8830 c1				pop bc 
8831 d1				pop de 
8832 e1				pop hl 
8833			 
8833 c9				ret 
8834			;scroll_down: 
8834			;	ld de, display_row_4 
8834			;	ld hl, display_row_3 
8834			;	ld bc, display_cols 
8834			;	ldir 
8834			;	ld de, display_row_3 
8834			; 	ld hl, display_row_2 
8834			;	ld bc, display_cols 
8834			;	ldir 
8834			;	ld de, display_row_2 
8834			;	ld hl, display_row_1 
8834			;	ld bc, display_cols 
8834			;	ldir 
8834			;;; TODO clear row 1 
8834			;	ret 
8834			 
8834			 
8834			 
8834			 
8834			 
8834			; clear active frame buffer 
8834			 
8834			clear_display: 
8834 3e 20			ld a, ' ' 
8836 c3 39 88			jp fill_display 
8839			 
8839			; fill active frame buffer with a char in A 
8839			 
8839			fill_display: 
8839 06 a0			ld b,display_fb_len 
883b 2a db eb			ld hl, (display_fb_active) 
883e 77			.fd1:	ld (hl),a 
883f 23				inc hl 
8840 10 fc			djnz .fd1 
8842 23				inc hl 
8843 3e 00			ld a,0 
8845 77				ld (hl),a 
8846			 
8846			 
8846 c9				ret 
8847			; Write string (DE) at pos (A) to active frame buffer 
8847			 
8847 2a db eb		str_at_display:    ld hl,(display_fb_active) 
884a 06 00					ld b,0 
884c 4f					ld c,a 
884d 09					add hl,bc 
884e 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
884f b7			            OR   A              ;Null terminator? 
8850 c8			            RET  Z              ;Yes, so finished 
8851 77					ld (hl),a 
8852 23				inc hl 
8853 13			            INC  DE             ;Point to next character 
8854 18 f8		            JR   .sad1     ;Repeat 
8856 c9					ret 
8857			 
8857			; using current frame buffer write to physical display 
8857			 
8857			update_display: 
8857 e5				push hl 
8858 2a db eb			ld hl, (display_fb_active) 
885b cd e9 d5			call write_display 
885e e1				pop hl 
885f c9				ret 
8860			 
8860			; TODO scrolling 
8860			 
8860			 
8860			; move cursor right one char 
8860			cursor_right: 
8860			 
8860				; TODO shift right 
8860				; TODO if beyond max col 
8860				; TODO       cursor_next_line 
8860			 
8860 c9				ret 
8861			 
8861			 
8861			cursor_next_line: 
8861				; TODO first char 
8861				; TODO line down 
8861				; TODO if past last row 
8861				; TODO    scroll up 
8861			 
8861 c9				ret 
8862			 
8862			cursor_left: 
8862				; TODO shift left 
8862				; TODO if beyond left  
8862				; TODO     cursor prev line 
8862				 
8862 c9				ret 
8863			 
8863			cursor_prev_line: 
8863				; TODO last char 
8863				; TODO line up 
8863				; TODO if past first row 
8863				; TODO   scroll down 
8863			 
8863 c9				ret 
8864			 
8864			 
8864			cout: 
8864				; A - char 
8864 c9				ret 
8865			 
8865			 
8865			; Display a menu and allow item selection (optional toggle items) 
8865			; 
8865			; format: 
8865			; hl pointer to word array with zero term for items 
8865			; e.g.    db item1 
8865			;         db .... 
8865			;         db 0 
8865			; 
8865			; a = starting menu item  
8865			; 
8865			; de = pointer item toggle array   (todo) 
8865			; 
8865			; returns item selected in a 1-... 
8865			; returns 0 if back button pressed 
8865			; 
8865			; NOTE: Uses system frame buffer to display 
8865			 
8865			 
8865			 
8865			 
8865			 
8865			 
8865			menu: 
8865			 
8865					; keep array pointer 
8865			 
8865 22 63 eb				ld (store_tmp1), hl 
8868 32 61 eb				ld (store_tmp2), a 
886b			 
886b					; check for key bounce 
886b			 
886b			if BASE_KEV 
886b			 
886b			.mbounce:	call cin 
886b					cp 0 
886b					jr nz, .mbounce 
886b			endif 
886b					; for ease use ex 
886b			 
886b					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
886b 21 c0 ed				ld hl, display_fb0 
886e 22 db eb				ld (display_fb_active), hl 
8871			 
8871 cd 34 88		.mloop:		call clear_display 
8874 cd 57 88				call update_display 
8877			 
8877					; draw selection id '>' at 1 
8877			 
8877					; init start of list display 
8877			 
8877 3e 05				ld a, 5 
8879 32 5f eb				ld (store_tmp3), a   ; display row count 
887c 3a 61 eb				ld a,( store_tmp2) 
887f 32 62 eb				ld (store_tmp2+1), a   ; display item count 
8882			 
8882					 
8882			.mitem:	 
8882			 
8882			 
8882 3a 62 eb				ld a,(store_tmp2+1) 
8885 6f					ld l, a 
8886 26 00				ld h, 0 
8888 29					add hl, hl 
8889 ed 5b 63 eb			ld de, (store_tmp1) 
888d 19					add hl, de 
888e 7e					ld a, (hl) 
888f 23					inc hl 
8890 66					ld h,(hl) 
8891 6f					ld l, a 
8892			 
8892 cd 86 8a				call ishlzero 
8895 28 1a				jr z, .mdone 
8897			 
8897 eb					ex de, hl 
8898 3a 5f eb				ld a, (store_tmp3) 
889b cd 47 88				call str_at_display 
889e					 
889e			 
889e					; next item 
889e 3a 62 eb				ld a, (store_tmp2+1) 
88a1 3c					inc a 
88a2 32 62 eb				ld (store_tmp2+1), a   ; display item count 
88a5			 
88a5			 		; next row 
88a5			 
88a5 3a 5f eb				ld a, (store_tmp3) 
88a8 c6 28				add display_cols 
88aa 32 5f eb				ld (store_tmp3), a 
88ad			 
88ad					; at end of screen? 
88ad			 
88ad fe 10				cp display_rows*4 
88af 20 d1				jr nz, .mitem 
88b1			 
88b1			 
88b1			.mdone: 
88b1 cd 86 8a				call ishlzero 
88b4 28 08				jr z, .nodn 
88b6			 
88b6 3e 78				ld a, display_row_4 
88b8 11 33 89				ld de, .mdown 
88bb cd 47 88				call str_at_display 
88be			 
88be					; draw options to fill the screens with active item on line 1 
88be					; if current option is 2 or more then display ^ in top 
88be			 
88be 3a 61 eb		.nodn:		ld a, (store_tmp2) 
88c1 fe 00				cp 0 
88c3 28 08				jr z, .noup 
88c5			 
88c5 3e 00				ld a, 0 
88c7 11 31 89				ld de, .mup 
88ca cd 47 88				call str_at_display 
88cd			 
88cd 3e 02		.noup:		ld a, 2 
88cf 11 2f 89				ld de, .msel 
88d2 cd 47 88				call str_at_display 
88d5			 
88d5					; if current option + 1 is not null then display V in bottom 
88d5					; get key 
88d5 cd 57 88				call update_display 
88d8			 
88d8			 
88d8					; handle key 
88d8			 
88d8 cd 75 d6				call cin_wait 
88db			 
88db fe 05				cp KEY_UP 
88dd 28 27				jr z, .mgoup 
88df fe 61				cp 'a' 
88e1 28 23				jr z, .mgoup 
88e3 fe 0a				cp KEY_DOWN 
88e5 28 2e				jr z, .mgod 
88e7 fe 7a				cp 'z' 
88e9 28 2a				jr z, .mgod 
88eb fe 20				cp ' ' 
88ed 28 30				jr z, .goend 
88ef fe 0d				cp KEY_CR 
88f1 28 2c				jr z, .goend 
88f3 fe 71				cp 'q' 
88f5 28 0b				jr z, .goback 
88f7			 
88f7 fe 0b				cp KEY_LEFT 
88f9 28 07				jr z, .goback 
88fb fe 08				cp KEY_BS 
88fd 28 03				jr z, .goback 
88ff c3 71 88				jp .mloop 
8902			 
8902			.goback: 
8902 3e 00			ld a, 0 
8904 18 1d			jr .goend2 
8906			 
8906				; move up one 
8906			.mgoup: 
8906 3a 61 eb				ld a, (store_tmp2) 
8909 fe 00				cp 0 
890b ca 71 88				jp z, .mloop 
890e 3d					dec a 
890f 32 61 eb				ld (store_tmp2), a 
8912 c3 71 88				jp .mloop 
8915			 
8915				; move down one 
8915			.mgod: 
8915 3a 61 eb				ld a, (store_tmp2) 
8918 3c					inc a 
8919 32 61 eb				ld (store_tmp2), a 
891c c3 71 88				jp .mloop 
891f			 
891f			 
891f			.goend: 
891f					; get selected item number 
891f			 
891f 3a 61 eb				ld a, (store_tmp2) 
8922 3c					inc a 
8923			 
8923			.goend2: 
8923 f5					push af 
8924			 
8924					; restore active fb 
8924					; TODO BUG assumes fb1 
8924			 
8924 21 1f ed				ld hl, display_fb1 
8927 22 db eb				ld (display_fb_active), hl 
892a			 
892a					; restore main regs 
892a			 
892a			 
892a cd 57 88				call update_display 
892d			 
892d f1					pop af 
892e			 
892e c9				ret 
892f			 
892f .. 00		.msel:   db ">",0 
8931 .. 00		.mup:   db "^",0 
8933 .. 00		.mdown:   db "v",0 
8935			 
8935			 
8935			; eof 
8935			 
# End of file firmware_display.asm
8935			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8935			; random number generators 
8935			 
8935			 
8935			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8935			 
8935			 
8935			;-----> Generate a random number 
8935			; output a=answer 0<=a<=255 
8935			; all registers are preserved except: af 
8935			random: 
8935 e5			        push    hl 
8936 d5			        push    de 
8937 2a bd eb		        ld      hl,(randData) 
893a ed 5f		        ld      a,r 
893c 57			        ld      d,a 
893d 5e			        ld      e,(hl) 
893e 19			        add     hl,de 
893f 85			        add     a,l 
8940 ac			        xor     h 
8941 22 bd eb		        ld      (randData),hl 
8944 d1			        pop     de 
8945 e1			        pop     hl 
8946 c9			        ret 
8947			 
8947			 
8947			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8947			 
8947			 
8947			 
8947			;------LFSR------ 
8947			;James Montelongo 
8947			;optimized by Spencer Putt 
8947			;out: 
8947			; a = 8 bit random number 
8947			RandLFSR: 
8947 21 c3 eb		        ld hl,LFSRSeed+4 
894a 5e			        ld e,(hl) 
894b 23			        inc hl 
894c 56			        ld d,(hl) 
894d 23			        inc hl 
894e 4e			        ld c,(hl) 
894f 23			        inc hl 
8950 7e			        ld a,(hl) 
8951 47			        ld b,a 
8952 cb 13		        rl e  
8954 cb 12			rl d 
8956 cb 11		        rl c  
8958 17				rla 
8959 cb 13		        rl e  
895b cb 12			rl d 
895d cb 11		        rl c  
895f 17				rla 
8960 cb 13		        rl e  
8962 cb 12			rl d 
8964 cb 11		        rl c  
8966 17				rla 
8967 67			        ld h,a 
8968 cb 13		        rl e  
896a cb 12			rl d 
896c cb 11		        rl c  
896e 17				rla 
896f a8			        xor b 
8970 cb 13		        rl e  
8972 cb 12			rl d 
8974 ac			        xor h 
8975 a9			        xor c 
8976 aa			        xor d 
8977 21 c5 eb		        ld hl,LFSRSeed+6 
897a 11 c6 eb		        ld de,LFSRSeed+7 
897d 01 07 00		        ld bc,7 
8980 ed b8		        lddr 
8982 12			        ld (de),a 
8983 c9			        ret 
8984			 
8984			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8984			 
8984			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8984			 
8984			 
8984			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8984			 
8984			prng16: 
8984			;Inputs: 
8984			;   (seed1) contains a 16-bit seed value 
8984			;   (seed2) contains a NON-ZERO 16-bit seed value 
8984			;Outputs: 
8984			;   HL is the result 
8984			;   BC is the result of the LCG, so not that great of quality 
8984			;   DE is preserved 
8984			;Destroys: 
8984			;   AF 
8984			;cycle: 4,294,901,760 (almost 4.3 billion) 
8984			;160cc 
8984			;26 bytes 
8984 2a b7 eb		    ld hl,(seed1) 
8987 44			    ld b,h 
8988 4d			    ld c,l 
8989 29			    add hl,hl 
898a 29			    add hl,hl 
898b 2c			    inc l 
898c 09			    add hl,bc 
898d 22 b7 eb		    ld (seed1),hl 
8990 2a b5 eb		    ld hl,(seed2) 
8993 29			    add hl,hl 
8994 9f			    sbc a,a 
8995 e6 2d		    and %00101101 
8997 ad			    xor l 
8998 6f			    ld l,a 
8999 22 b5 eb		    ld (seed2),hl 
899c 09			    add hl,bc 
899d c9			    ret 
899e			 
899e			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
899e			 
899e			rand32: 
899e			;Inputs: 
899e			;   (seed1_0) holds the lower 16 bits of the first seed 
899e			;   (seed1_1) holds the upper 16 bits of the first seed 
899e			;   (seed2_0) holds the lower 16 bits of the second seed 
899e			;   (seed2_1) holds the upper 16 bits of the second seed 
899e			;   **NOTE: seed2 must be non-zero 
899e			;Outputs: 
899e			;   HL is the result 
899e			;   BC,DE can be used as lower quality values, but are not independent of HL. 
899e			;Destroys: 
899e			;   AF 
899e			;Tested and passes all CAcert tests 
899e			;Uses a very simple 32-bit LCG and 32-bit LFSR 
899e			;it has a period of 18,446,744,069,414,584,320 
899e			;roughly 18.4 quintillion. 
899e			;LFSR taps: 0,2,6,7  = 11000101 
899e			;291cc 
899e			;seed1_0=$+1 
899e			;    ld hl,12345 
899e			;seed1_1=$+1 
899e			;    ld de,6789 
899e			;    ld b,h 
899e			;    ld c,l 
899e			;    add hl,hl \ rl e \ rl d 
899e			;    add hl,hl \ rl e \ rl d 
899e			;    inc l 
899e			;    add hl,bc 
899e			;    ld (seed1_0),hl 
899e			;    ld hl,(seed1_1) 
899e			;    adc hl,de 
899e			;    ld (seed1_1),hl 
899e			;    ex de,hl 
899e			;seed2_0=$+1 
899e			;    ld hl,9876 
899e			;seed2_1=$+1 
899e			;    ld bc,54321 
899e			;    add hl,hl \ rl c \ rl b 
899e			;    ld (seed2_1),bc 
899e			;    sbc a,a 
899e			;    and %11000101 
899e			;    xor l 
899e			;    ld l,a 
899e			;    ld (seed2_0),hl 
899e			;    ex de,hl 
899e			;    add hl,bc 
899e			;    ret 
899e			; 
899e			 
899e			; 16-bit xorshift pseudorandom number generator by John Metcalf 
899e			; 20 bytes, 86 cycles (excluding ret) 
899e			 
899e			; returns   hl = pseudorandom number 
899e			; corrupts   a 
899e			 
899e			; generates 16-bit pseudorandom numbers with a period of 65535 
899e			; using the xorshift method: 
899e			 
899e			; hl ^= hl << 7 
899e			; hl ^= hl >> 9 
899e			; hl ^= hl << 8 
899e			 
899e			; some alternative shift triplets which also perform well are: 
899e			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
899e			 
899e			;  org 32768 
899e			 
899e			xrnd: 
899e 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
89a1 3e 00		  ld a,0 
89a3 bd			  cp l 
89a4 20 02		  jr nz, .xrnd1 
89a6 2e 01		  ld l, 1 
89a8			.xrnd1: 
89a8			 
89a8 7c			  ld a,h 
89a9 1f			  rra 
89aa 7d			  ld a,l 
89ab 1f			  rra 
89ac ac			  xor h 
89ad 67			  ld h,a 
89ae 7d			  ld a,l 
89af 1f			  rra 
89b0 7c			  ld a,h 
89b1 1f			  rra 
89b2 ad			  xor l 
89b3 6f			  ld l,a 
89b4 ac			  xor h 
89b5 67			  ld h,a 
89b6			 
89b6 22 bb eb		  ld (xrandc),hl 
89b9			 
89b9 c9			  ret 
89ba			;  
89ba			 
89ba			 
89ba			;;;; int maths 
89ba			 
89ba			; https://map.grauw.nl/articles/mult_div_shifts.php 
89ba			; Divide 16-bit values (with 16-bit result) 
89ba			; In: Divide BC by divider DE 
89ba			; Out: BC = result, HL = rest 
89ba			; 
89ba			Div16: 
89ba 21 00 00		    ld hl,0 
89bd 78			    ld a,b 
89be 06 08		    ld b,8 
89c0			Div16_Loop1: 
89c0 17			    rla 
89c1 ed 6a		    adc hl,hl 
89c3 ed 52		    sbc hl,de 
89c5 30 01		    jr nc,Div16_NoAdd1 
89c7 19			    add hl,de 
89c8			Div16_NoAdd1: 
89c8 10 f6		    djnz Div16_Loop1 
89ca 17			    rla 
89cb 2f			    cpl 
89cc 47			    ld b,a 
89cd 79			    ld a,c 
89ce 48			    ld c,b 
89cf 06 08		    ld b,8 
89d1			Div16_Loop2: 
89d1 17			    rla 
89d2 ed 6a		    adc hl,hl 
89d4 ed 52		    sbc hl,de 
89d6 30 01		    jr nc,Div16_NoAdd2 
89d8 19			    add hl,de 
89d9			Div16_NoAdd2: 
89d9 10 f6		    djnz Div16_Loop2 
89db 17			    rla 
89dc 2f			    cpl 
89dd 41			    ld b,c 
89de 4f			    ld c,a 
89df c9			ret 
89e0			 
89e0			 
89e0			;http://z80-heaven.wikidot.com/math 
89e0			; 
89e0			;Inputs: 
89e0			;     DE and A are factors 
89e0			;Outputs: 
89e0			;     A is not changed 
89e0			;     B is 0 
89e0			;     C is not changed 
89e0			;     DE is not changed 
89e0			;     HL is the product 
89e0			;Time: 
89e0			;     342+6x 
89e0			; 
89e0			Mult16: 
89e0			 
89e0 06 08		     ld b,8          ;7           7 
89e2 21 00 00		     ld hl,0         ;10         10 
89e5 29			       add hl,hl     ;11*8       88 
89e6 07			       rlca          ;4*8        32 
89e7 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
89e9 19			         add hl,de   ;--         -- 
89ea 10 f9		       djnz $-5      ;13*7+8     99 
89ec c9			ret 
89ed			 
89ed			; 
89ed			; Square root of 16-bit value 
89ed			; In:  HL = value 
89ed			; Out:  D = result (rounded down) 
89ed			; 
89ed			;Sqr16: 
89ed			;    ld de,#0040 
89ed			;    ld a,l 
89ed			;    ld l,h 
89ed			;    ld h,d 
89ed			;    or a 
89ed			;    ld b,8 
89ed			;Sqr16_Loop: 
89ed			;    sbc hl,de 
89ed			;    jr nc,Sqr16_Skip 
89ed			;    add hl,de 
89ed			;Sqr16_Skip: 
89ed			;    ccf 
89ed			;    rl d 
89ed			;    add a,a 
89ed			;    adc hl,hl 
89ed			;    add a,a 
89ed			;    adc hl,hl 
89ed			;    djnz Sqr16_Loop 
89ed			;    ret 
89ed			; 
89ed			; 
89ed			; Divide 8-bit values 
89ed			; In: Divide E by divider C 
89ed			; Out: A = result, B = rest 
89ed			; 
89ed			Div8: 
89ed af			    xor a 
89ee 06 08		    ld b,8 
89f0			Div8_Loop: 
89f0 cb 13		    rl e 
89f2 17			    rla 
89f3 91			    sub c 
89f4 30 01		    jr nc,Div8_NoAdd 
89f6 81			    add a,c 
89f7			Div8_NoAdd: 
89f7 10 f7		    djnz Div8_Loop 
89f9 47			    ld b,a 
89fa 7b			    ld a,e 
89fb 17			    rla 
89fc 2f			    cpl 
89fd c9			    ret 
89fe			 
89fe			; 
89fe			; Multiply 8-bit value with a 16-bit value (unrolled) 
89fe			; In: Multiply A with DE 
89fe			; Out: HL = result 
89fe			; 
89fe			Mult12U: 
89fe 2e 00		    ld l,0 
8a00 87			    add a,a 
8a01 30 01		    jr nc,Mult12U_NoAdd0 
8a03 19			    add hl,de 
8a04			Mult12U_NoAdd0: 
8a04 29			    add hl,hl 
8a05 87			    add a,a 
8a06 30 01		    jr nc,Mult12U_NoAdd1 
8a08 19			    add hl,de 
8a09			Mult12U_NoAdd1: 
8a09 29			    add hl,hl 
8a0a 87			    add a,a 
8a0b 30 01		    jr nc,Mult12U_NoAdd2 
8a0d 19			    add hl,de 
8a0e			Mult12U_NoAdd2: 
8a0e 29			    add hl,hl 
8a0f 87			    add a,a 
8a10 30 01		    jr nc,Mult12U_NoAdd3 
8a12 19			    add hl,de 
8a13			Mult12U_NoAdd3: 
8a13 29			    add hl,hl 
8a14 87			    add a,a 
8a15 30 01		    jr nc,Mult12U_NoAdd4 
8a17 19			    add hl,de 
8a18			Mult12U_NoAdd4: 
8a18 29			    add hl,hl 
8a19 87			    add a,a 
8a1a 30 01		    jr nc,Mult12U_NoAdd5 
8a1c 19			    add hl,de 
8a1d			Mult12U_NoAdd5: 
8a1d 29			    add hl,hl 
8a1e 87			    add a,a 
8a1f 30 01		    jr nc,Mult12U_NoAdd6 
8a21 19			    add hl,de 
8a22			Mult12U_NoAdd6: 
8a22 29			    add hl,hl 
8a23 87			    add a,a 
8a24 d0			    ret nc 
8a25 19			    add hl,de 
8a26 c9			    ret 
8a27			 
8a27			; 
8a27			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a27			; In: Multiply A with DE 
8a27			;      Put lowest value in A for most efficient calculation 
8a27			; Out: HL = result 
8a27			; 
8a27			Mult12R: 
8a27 21 00 00		    ld hl,0 
8a2a			Mult12R_Loop: 
8a2a cb 3f		    srl a 
8a2c 30 01		    jr nc,Mult12R_NoAdd 
8a2e 19			    add hl,de 
8a2f			Mult12R_NoAdd: 
8a2f cb 23		    sla e 
8a31 cb 12		    rl d 
8a33 b7			    or a 
8a34 c2 2a 8a		    jp nz,Mult12R_Loop 
8a37 c9			    ret 
8a38			 
8a38			; 
8a38			; Multiply 16-bit values (with 32-bit result) 
8a38			; In: Multiply BC with DE 
8a38			; Out: BCHL = result 
8a38			; 
8a38			Mult32: 
8a38 79			    ld a,c 
8a39 48			    ld c,b 
8a3a 21 00 00		    ld hl,0 
8a3d 06 10		    ld b,16 
8a3f			Mult32_Loop: 
8a3f 29			    add hl,hl 
8a40 17			    rla 
8a41 cb 11		    rl c 
8a43 30 07		    jr nc,Mult32_NoAdd 
8a45 19			    add hl,de 
8a46 ce 00		    adc a,0 
8a48 d2 4c 8a		    jp nc,Mult32_NoAdd 
8a4b 0c			    inc c 
8a4c			Mult32_NoAdd: 
8a4c 10 f1		    djnz Mult32_Loop 
8a4e 41			    ld b,c 
8a4f 4f			    ld c,a 
8a50 c9			    ret 
8a51			 
8a51			 
8a51			 
8a51			; 
8a51			; Multiply 8-bit values 
8a51			; In:  Multiply H with E 
8a51			; Out: HL = result 
8a51			; 
8a51			Mult8: 
8a51 16 00		    ld d,0 
8a53 6a			    ld l,d 
8a54 06 08		    ld b,8 
8a56			Mult8_Loop: 
8a56 29			    add hl,hl 
8a57 30 01		    jr nc,Mult8_NoAdd 
8a59 19			    add hl,de 
8a5a			Mult8_NoAdd: 
8a5a 10 fa		    djnz Mult8_Loop 
8a5c c9			    ret 
8a5d			 
8a5d			 
8a5d			 
8a5d			 
8a5d			 
8a5d			 
8a5d			 
8a5d			 
8a5d			;;http://z80-heaven.wikidot.com/math 
8a5d			;;This divides DE by BC, storing the result in DE, remainder in HL 
8a5d			; 
8a5d			;DE_Div_BC:          ;1281-2x, x is at most 16 
8a5d			;     ld a,16        ;7 
8a5d			;     ld hl,0        ;10 
8a5d			;     jp $+5         ;10 
8a5d			;.DivLoop: 
8a5d			;       add hl,bc    ;-- 
8a5d			;       dec a        ;64 
8a5d			;       jr z,.DivLoopEnd        ;86 
8a5d			; 
8a5d			;       sla e        ;128 
8a5d			;       rl d         ;128 
8a5d			;       adc hl,hl    ;240 
8a5d			;       sbc hl,bc    ;240 
8a5d			;       jr nc,.DivLoop ;23|21 
8a5d			;       inc e        ;-- 
8a5d			;       jp .DivLoop+1 
8a5d			; 
8a5d			;.DivLoopEnd: 
8a5d			 
8a5d			;HL_Div_C: 
8a5d			;Inputs: 
8a5d			;     HL is the numerator 
8a5d			;     C is the denominator 
8a5d			;Outputs: 
8a5d			;     A is the remainder 
8a5d			;     B is 0 
8a5d			;     C is not changed 
8a5d			;     DE is not changed 
8a5d			;     HL is the quotient 
8a5d			; 
8a5d			;       ld b,16 
8a5d			;       xor a 
8a5d			;         add hl,hl 
8a5d			;         rla 
8a5d			;         cp c 
8a5d			;         jr c,$+4 
8a5d			;           inc l 
8a5d			;           sub c 
8a5d			;         djnz $-7 
8a5d			 
8a5d			; https://plutiedev.com/z80-add-8bit-to-16bit 
8a5d			 
8a5d			addatohl: 
8a5d 85			    add   a, l    ; A = A+L 
8a5e 6f			    ld    l, a    ; L = A+L 
8a5f 8c			    adc   a, h    ; A = A+L+H+carry 
8a60 95			    sub   l       ; A = H+carry 
8a61 67			    ld    h, a    ; H = H+carry 
8a62 c9			ret 
8a63			 
8a63			addatode: 
8a63 83			    add   a, e    ; A = A+L 
8a64 5f			    ld    e, a    ; L = A+L 
8a65 8a			    adc   a, d    ; A = A+L+H+carry 
8a66 93			    sub   e       ; A = H+carry 
8a67 57			    ld    d, a    ; H = H+carry 
8a68 c9			ret 
8a69			 
8a69			 
8a69			addatobc: 
8a69 81			    add   a, c    ; A = A+L 
8a6a 4f			    ld    c, a    ; L = A+L 
8a6b 88			    adc   a, b    ; A = A+L+H+carry 
8a6c 91			    sub   c       ; A = H+carry 
8a6d 47			    ld    b, a    ; H = H+carry 
8a6e c9			ret 
8a6f			 
8a6f			subafromhl: 
8a6f			   ; If A=0 do nothing 
8a6f			    ; Otherwise flip A's sign. Since 
8a6f			    ; the upper byte becomes -1, also 
8a6f			    ; substract 1 from H. 
8a6f ed 44		    neg 
8a71 ca 7a 8a		    jp    z, Skip 
8a74 25			    dec   h 
8a75			     
8a75			    ; Now add the low byte as usual 
8a75			    ; Two's complement takes care of 
8a75			    ; ensuring the result is correct 
8a75 85			    add   a, l 
8a76 6f			    ld    l, a 
8a77 8c			    adc   a, h 
8a78 95			    sub   l 
8a79 67			    ld    h, a 
8a7a			Skip: 
8a7a c9				ret 
8a7b			 
8a7b			 
8a7b			; compare hl and de 
8a7b			; returns:  
8a7b			; if hl = de, z=1, s=0, c0=0 
8a7b			; if hl > de, z=0, s=0, c=0 
8a7b			; if hl < de, z=0, s=1, c=1 
8a7b			cmp16:	 
8a7b b7				or a 
8a7c ed 52			sbc hl,de 
8a7e e0				ret po 
8a7f 7c				ld a,h 
8a80 1f				rra 
8a81 ee 40			xor 01000000B 
8a83 37				scf 
8a84 8f				adc a,a 
8a85 c9				ret 
8a86			 
8a86			 
8a86			; test if hl contains zero   - A is destroyed 
8a86			 
8a86			ishlzero:    
8a86 b7				or a     ; reset flags 
8a87 7c				ld a, h 
8a88 b5				or l        	 
8a89			 
8a89 c9				ret 
8a8a			 
8a8a			 
8a8a			 
8a8a			 
8a8a			if FORTH_ENABLE_FLOATMATH 
8a8a			;include "float/bbcmath.z80" 
8a8a			include "float/lpfpcalc.asm" 
8a8a			endif 
8a8a			 
8a8a			 
8a8a			; eof 
8a8a			 
# End of file firmware_maths.asm
8a8a			include "firmware_strings.asm"   ; string handling  
8a8a			 
8a8a			 
8a8a			; TODO string len 
8a8a			; input text string, end on cr with zero term 
8a8a			; a offset into frame buffer to start prompt 
8a8a			; d is max length 
8a8a			; e is display size TODO 
8a8a			; c is current cursor position 
8a8a			; hl is ptr to where string will be stored 
8a8a			 
8a8a			 
8a8a			; TODO check limit of buffer for new inserts 
8a8a			; TODO check insert does not push beyond buffer 
8a8a			; TODO scroll in a limited display area 
8a8a			; TODO scroll whole screen on page wrap 
8a8a			 
8a8a			 
8a8a			; TODO handle KEY_PREVWORD 
8a8a			; TODO handle KEY_NEXTWORD 
8a8a			; TODO handle KEY_HOME 
8a8a			; TODO handle KEY_END 
8a8a			; TODO use LCD cursor? 
8a8a			 
8a8a 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8a8d 81					add c 
8a8e 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8a91 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
8a94 79					ld a, c 
8a95 cd 5d 8a				call addatohl 
8a98 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8a9b 7a					ld a,d 
8a9c 32 75 ee			        ld (input_size), a       ; save length of input area 
8a9f 79					ld a, c 
8aa0 32 64 ee				ld (input_cursor),a      ; init cursor start position  
8aa3 7b					ld a,e 
8aa4 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8aa7					 
8aa7					 
8aa7			 
8aa7			;		ld a,(input_ptr) 
8aa7			;		ld (input_under_cursor),a 	; save what is under the cursor 
8aa7			 
8aa7			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8aa7					; init cursor shape if not set by the cin routines 
8aa7 21 d3 eb				ld hl, cursor_shape 
8aaa 3e ff				ld a, 255 
8aac 77					ld (hl), a 
8aad 23					inc hl 
8aae 3e 00				ld a, 0 
8ab0 77					ld (hl), a 
8ab1			 
8ab1 3e 0f				ld a, CUR_BLINK_RATE 
8ab3 32 6f ee				ld (input_cur_flash), a 
8ab6 3e 01				ld a, 1 
8ab8 32 6e ee				ld (input_cur_onoff),a 
8abb			 
8abb			;	if DEBUG_INPUT 
8abb			;		push af 
8abb			;		ld a, 'I' 
8abb			;		ld (debug_mark),a 
8abb			;		pop af 
8abb			;		CALLMONITOR 
8abb			;	endif 
8abb			.is1:		; main entry loop 
8abb			 
8abb			 
8abb			 
8abb					; pause 1ms 
8abb			 
8abb 3e 01				ld a, 1 
8abd cd c7 87				call aDelayInMS 
8ac0			 
8ac0					; dec flash counter 
8ac0 3a 6f ee				ld a, (input_cur_flash) 
8ac3 3d					dec a 
8ac4 32 6f ee				ld (input_cur_flash), a 
8ac7 fe 00				cp 0 
8ac9 20 0d				jr nz, .nochgstate 
8acb			 
8acb			 
8acb					; change state 
8acb 3a 6e ee				ld a,(input_cur_onoff) 
8ace ed 44				neg 
8ad0 32 6e ee				ld (input_cur_onoff),a 
8ad3			 
8ad3			 
8ad3					; reset on change of state 
8ad3 3e 0f				ld a, CUR_BLINK_RATE 
8ad5 32 6f ee				ld (input_cur_flash), a 
8ad8			 
8ad8			.nochgstate: 
8ad8					 
8ad8					 
8ad8			 
8ad8					; display cursor  
8ad8			 
8ad8			;		ld hl, (input_start) 
8ad8			;		ld a, (input_cursor) 
8ad8			;		call addatohl 
8ad8			 
8ad8					; get char under cursor and replace with cursor 
8ad8 2a 78 ee		ld hl, (input_ptr) 
8adb			;		ld a, (hl) 
8adb			;		ld (input_under_cursor),a 
8adb			;		ld a, '_' 
8adb			;		ld (hl), a 
8adb			 
8adb					; display string 
8adb			 
8adb ed 5b 76 ee			ld de, (input_start) 
8adf 3a 73 ee				ld a, (input_at_pos) 
8ae2 cd 47 88				call str_at_display 
8ae5			;	        call update_display 
8ae5			 
8ae5					; find place to put the cursor 
8ae5			;		add h 
8ae5			;		ld l, display_row_1 
8ae5			;		sub l 
8ae5			; (input_at_pos) 
8ae5					;ld c, a 
8ae5			;		ld a, (input_cursor) 
8ae5			;		ld l, (input_at_pos) 
8ae5			;		;ld b, h 
8ae5			;		add l 
8ae5			;		ld (input_at_cursor),a 
8ae5					;ld l,h 
8ae5			 
8ae5			;		ld h, 0 
8ae5			;		ld l,(input_at_pos) 
8ae5			;		ld a, (input_cursor) 
8ae5			;		call addatohl 
8ae5			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ae5			;		call subafromhl 
8ae5			;		ld a,l 
8ae5			;		ld (input_at_cursor), a 
8ae5			 
8ae5				if DEBUG_INPUT 
8ae5					ld a, (hardware_diag) 
8ae5					cp 0 
8ae5					jr z, .skip_input_diag 
8ae5			 
8ae5					ld a,(input_at_pos) 
8ae5					ld hl, LFSRSeed 
8ae5					call hexout 
8ae5					ld a, (input_cursor) 
8ae5					ld hl, LFSRSeed+2 
8ae5					call hexout 
8ae5					ld a,(input_at_cursor) 
8ae5					ld hl, LFSRSeed+4 
8ae5					call hexout 
8ae5			 
8ae5					ld a,(input_cur_onoff) 
8ae5					ld hl, LFSRSeed+6 
8ae5					call hexout 
8ae5			 
8ae5					ld a,(input_cur_flash) 
8ae5					ld hl, LFSRSeed+8 
8ae5					call hexout 
8ae5			 
8ae5					ld a,(input_len) 
8ae5					ld hl, LFSRSeed+10 
8ae5					call hexout 
8ae5					ld hl, LFSRSeed+12 
8ae5					ld a, 0 
8ae5					ld (hl),a 
8ae5					ld a, display_row_4 
8ae5					ld de, LFSRSeed 
8ae5					call str_at_display 
8ae5					.skip_input_diag: 
8ae5				endif 
8ae5			 
8ae5					; decide on if we are showing the cursor this time round 
8ae5			 
8ae5 3a 6e ee				ld a, (input_cur_onoff) 
8ae8 fe ff				cp 255 
8aea 28 13				jr z, .skipcur 
8aec			 
8aec			 
8aec 3a 71 ee				ld a,(input_at_cursor) 
8aef 11 d3 eb				ld de, cursor_shape 
8af2 cd 47 88				call str_at_display 
8af5			 
8af5					; save length of current input string 
8af5 2a 76 ee				ld hl, (input_start) 
8af8 cd bb 8e				call strlenz 
8afb 7d					ld a,l 
8afc 32 69 ee				ld (input_len),a 
8aff			 
8aff			.skipcur: 
8aff			 
8aff cd 57 88			        call update_display 
8b02					 
8b02			 
8b02			 
8b02					; wait 
8b02				 
8b02					; TODO loop without wait to flash the cursor and char under cursor	 
8b02 cd 7b d6				call cin    ; _wait 
8b05			 
8b05 fe 00				cp 0 
8b07 ca bb 8a				jp z, .is1 
8b0a			 
8b0a					; get ptr to char to input into 
8b0a			 
8b0a 4f					ld c,a 
8b0b 2a 76 ee				ld hl, (input_start) 
8b0e 3a 64 ee				ld a, (input_cursor) 
8b11 cd 5d 8a				call addatohl 
8b14 22 78 ee				ld (input_ptr), hl 
8b17 79					ld a,c 
8b18			 
8b18					; replace char under cursor 
8b18			 
8b18			;		ld hl, (input_ptr) 
8b18			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b18			;		ld (hl), a 
8b18			 
8b18			;	if DEBUG_INPUT 
8b18			;		push af 
8b18			;		ld a, 'i' 
8b18			;		ld (debug_mark),a 
8b18			;		pop af 
8b18			;		CALLMONITOR 
8b18			;	endif 
8b18 fe 0e				cp KEY_HOME 
8b1a 20 0e				jr nz, .iske 
8b1c			 
8b1c 3a 73 ee				ld a, (input_at_pos) 
8b1f 32 71 ee				ld (input_at_cursor),a 
8b22 3e 00				ld a, 0 
8b24 32 64 ee				ld (input_cursor), a 
8b27 c3 bb 8a				jp .is1 
8b2a					 
8b2a fe 0f		.iske:		cp KEY_END 
8b2c 20 03				jr nz, .isknw 
8b2e c3 bb 8a				jp .is1 
8b31			 
8b31 fe 06		.isknw:		cp KEY_NEXTWORD 
8b33 20 1b				jr nz, .iskpw 
8b35			 
8b35 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8b38 7e					ld a,(hl)	 
8b39 fe 00				cp 0 
8b3b ca bb 8a				jp z, .is1    ; end of string 
8b3e fe 20				cp ' ' 
8b40 ca bb 8a				jp z, .is1    ; end of word 
8b43 23					inc hl 
8b44 22 78 ee				ld (input_ptr), hl 
8b47 3a 71 ee				ld a, (input_at_cursor) 
8b4a 3c					inc a 
8b4b 32 71 ee				ld (input_at_cursor), a 
8b4e 18 e5				jr .isknwm 
8b50			 
8b50 fe 07		.iskpw:		cp KEY_PREVWORD 
8b52 20 1b				jr nz, .iskl 
8b54			.iskpwm:	 
8b54 2a 78 ee				ld hl, (input_ptr) 
8b57 7e					ld a,(hl)	 
8b58 fe 00				cp 0  
8b5a ca bb 8a				jp z, .is1    ; end of string 
8b5d fe 20				cp ' ' 
8b5f ca bb 8a				jp z, .is1    ; end of word 
8b62 2b					dec hl 
8b63 22 78 ee				ld (input_ptr), hl 
8b66 3a 71 ee				ld a, (input_at_cursor) 
8b69 3d					dec a 
8b6a 32 71 ee				ld (input_at_cursor), a 
8b6d 18 e5				jr .iskpwm 
8b6f			 
8b6f			 
8b6f fe 0b		.iskl:		cp KEY_LEFT 
8b71 20 27				jr nz, .isk1 
8b73			 
8b73 3a 64 ee				ld a, (input_cursor) 
8b76			 
8b76 fe 00				cp 0 
8b78 ca bb 8a				jp z, .is1 		; at start of line to ignore  
8b7b			 
8b7b 3d					dec  a 		; TODO check underflow 
8b7c 32 64 ee				ld (input_cursor), a 
8b7f			 
8b7f 2a 78 ee				ld hl, (input_ptr) 
8b82 2b					dec hl 
8b83 22 78 ee				ld (input_ptr), hl 
8b86					 
8b86 3a 71 ee				ld a, (input_at_cursor) 
8b89 3d					dec a 
8b8a 32 71 ee				ld (input_at_cursor), a 
8b8d			 
8b8d 3e 01				ld a, 1		; show cursor moving 
8b8f 32 6e ee				ld (input_cur_onoff),a 
8b92 3e 0f				ld a, CUR_BLINK_RATE 
8b94 32 6f ee				ld (input_cur_flash), a 
8b97			 
8b97 c3 bb 8a				jp .is1 
8b9a			 
8b9a fe 0c		.isk1:		cp KEY_RIGHT 
8b9c 20 2a				jr nz, .isk2 
8b9e			 
8b9e 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ba1 5f					ld e,a 
8ba2 3a 64 ee				ld a, (input_cursor) 
8ba5 bb					cp e 
8ba6 ca bb 8a				jp z, .is1		; at the end of string so dont go right 
8ba9			 
8ba9 3c					inc  a 		; TODO check overflow 
8baa 32 64 ee				ld (input_cursor), a 
8bad			 
8bad 3a 71 ee				ld a, (input_at_cursor) 
8bb0 3c					inc a 
8bb1 32 71 ee				ld (input_at_cursor), a 
8bb4			 
8bb4 2a 78 ee				ld hl, (input_ptr) 
8bb7 23					inc hl 
8bb8 22 78 ee				ld (input_ptr), hl 
8bbb			 
8bbb 3e 01				ld a, 1		; show cursor moving 
8bbd 32 6e ee				ld (input_cur_onoff),a 
8bc0 3e 0f				ld a, CUR_BLINK_RATE 
8bc2 32 6f ee				ld (input_cur_flash), a 
8bc5			 
8bc5 c3 bb 8a				jp .is1 
8bc8			 
8bc8 fe 05		.isk2:		cp KEY_UP 
8bca			 
8bca 20 26				jr nz, .isk3 
8bcc			 
8bcc					; swap last command with the current on 
8bcc			 
8bcc					; move cursor to start of string 
8bcc 2a 76 ee				ld hl, (input_start) 
8bcf 22 78 ee				ld (input_ptr), hl 
8bd2			 
8bd2 3a 73 ee				ld a, (input_at_pos) 
8bd5 32 71 ee				ld (input_at_cursor), a 
8bd8			 
8bd8 3e 00				ld a, 0 
8bda 32 64 ee				ld (input_cursor), a 
8bdd					 
8bdd					; swap input and last command buffers 
8bdd			 
8bdd 21 9c e6				ld hl, os_cli_cmd 
8be0 11 9b e7				ld de, os_last_cmd 
8be3 06 ff				ld b, 255 
8be5 7e			.swap1:		ld a, (hl) 
8be6 4f					ld c,a 
8be7 1a					ld a, (de) 
8be8 77					ld (hl), a 
8be9 79					ld a,c 
8bea 12					ld (de),a 
8beb 23					inc hl 
8bec 13					inc de 
8bed 10 f6				djnz .swap1 
8bef			 
8bef			 
8bef			 
8bef			 
8bef			 
8bef c3 bb 8a				jp .is1 
8bf2			 
8bf2 fe 08		.isk3:		cp KEY_BS 
8bf4 20 3c				jr nz, .isk4 
8bf6			 
8bf6 3a 64 ee				ld a, (input_cursor) 
8bf9			 
8bf9 fe 00				cp 0 
8bfb ca bb 8a				jp z, .is1 		; at start of line to ignore  
8bfe			 
8bfe 3d					dec  a 		; TODO check underflow 
8bff 32 64 ee				ld (input_cursor), a 
8c02			 
8c02					; hl is source 
8c02					; de needs to be source - 1 
8c02			 
8c02			;		ld a, 0 
8c02			;		dec hl 
8c02			;		ld (hl), a 
8c02			 
8c02 2a 78 ee				ld hl, (input_ptr) 
8c05 2b					dec hl 
8c06 22 78 ee				ld (input_ptr), hl 
8c09			 
8c09					; shift all data 
8c09			 
8c09 e5					push hl 
8c0a 23					inc hl 
8c0b d1					pop de 
8c0c 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c0f 4f					ld c,a 
8c10 06 00				ld b,0 
8c12 ed b0				ldir  
8c14			 
8c14			 
8c14			 
8c14			 
8c14 3a 71 ee				ld a, (input_at_cursor) 
8c17 3d					dec a 
8c18 32 71 ee				ld (input_at_cursor), a 
8c1b			 
8c1b			 
8c1b 3e 01				ld a, 1		; show cursor moving 
8c1d 32 6e ee				ld (input_cur_onoff),a 
8c20 3e 0f				ld a, CUR_BLINK_RATE 
8c22 32 6f ee				ld (input_cur_flash), a 
8c25			 
8c25					; remove char 
8c25 3a 71 ee				ld a, (input_at_cursor) 
8c28 3c					inc a 
8c29 11 b3 8c				ld de,.iblank 
8c2c cd 47 88				call str_at_display 
8c2f			 
8c2f c3 bb 8a				jp .is1 
8c32			 
8c32 fe 0d		.isk4:		cp KEY_CR 
8c34 28 6c				jr z, .endinput 
8c36			 
8c36					; else add the key press to the end 
8c36			 
8c36 4f					ld c, a			; save key pressed 
8c37			 
8c37 7e					ld a,(hl)		; get what is currently under char 
8c38			 
8c38 fe 00				cp 0			; we are at the end of the string 
8c3a 20 2f				jr nz, .onchar 
8c3c					 
8c3c					; add a char to the end of the string 
8c3c				 
8c3c 71					ld (hl),c 
8c3d 23					inc hl 
8c3e			;		ld a,' ' 
8c3e			;		ld (hl),a 
8c3e			;		inc hl 
8c3e 3e 00				ld a,0 
8c40 77					ld (hl),a 
8c41 2b					dec hl 
8c42			 
8c42 3a 64 ee				ld a, (input_cursor) 
8c45 3c					inc a				; TODO check max string length and scroll  
8c46 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8c49							 
8c49 3a 71 ee				ld a, (input_at_cursor) 
8c4c 3c					inc a 
8c4d 32 71 ee				ld (input_at_cursor), a 
8c50			 
8c50 2a 78 ee				ld hl, (input_ptr) 
8c53 23					inc hl 
8c54 22 78 ee				ld (input_ptr), hl 
8c57			 
8c57 2a 78 ee				ld hl, (input_ptr) 
8c5a 23					inc hl 
8c5b 22 78 ee				ld (input_ptr), hl 
8c5e			;	if DEBUG_INPUT 
8c5e			;		push af 
8c5e			;		ld a, '+' 
8c5e			;		ld (debug_mark),a 
8c5e			;		pop af 
8c5e			;		CALLMONITOR 
8c5e			;	endif 
8c5e 3e 01				ld a, 1		; show cursor moving 
8c60 32 6e ee				ld (input_cur_onoff),a 
8c63 3e 0f				ld a, CUR_BLINK_RATE 
8c65 32 6f ee				ld (input_cur_flash), a 
8c68 c3 bb 8a				jp .is1 
8c6b					 
8c6b			 
8c6b			 
8c6b					; if on a char then insert 
8c6b			.onchar: 
8c6b			 
8c6b					; TODO over flow check: make sure insert does not blow out buffer 
8c6b			 
8c6b					; need to do some maths to use lddr 
8c6b			 
8c6b e5					push hl   ; save char pos 
8c6c c5					push bc 
8c6d			 
8c6d 2a 76 ee				ld hl, (input_start) 
8c70 3a 69 ee				ld a, (input_len) 
8c73 cd 5d 8a				call addatohl  		; end of string 
8c76 23					inc hl 
8c77 23					inc hl		; past zero term 
8c78 e5					push hl 
8c79 23					inc hl 
8c7a e5					push hl  
8c7b			 
8c7b								; start and end of lddr set, now how much to move? 
8c7b			 
8c7b							 
8c7b 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8c7e 47					ld b,a 
8c7f 3a 69 ee				ld a,(input_len) 
8c82 5f					ld e,a 
8c83 90					sub b 
8c84 3c					inc a		;?? 
8c85 3c					inc a		;?? 
8c86 3c					inc a		;?? 
8c87			 
8c87 06 00				ld b,0 
8c89 4f					ld c,a 
8c8a			 
8c8a				if DEBUG_INPUT 
8c8a					push af 
8c8a					ld a, 'i' 
8c8a					ld (debug_mark),a 
8c8a					pop af 
8c8a			;		CALLMONITOR 
8c8a				endif 
8c8a d1					pop de 
8c8b e1					pop hl 
8c8c				if DEBUG_INPUT 
8c8c					push af 
8c8c					ld a, 'I' 
8c8c					ld (debug_mark),a 
8c8c					pop af 
8c8c			;		CALLMONITOR 
8c8c				endif 
8c8c ed b8				lddr 
8c8e				 
8c8e			 
8c8e			 
8c8e					; TODO have a key for insert/overwrite mode???? 
8c8e c1					pop bc 
8c8f e1					pop hl 
8c90 71					ld (hl), c		; otherwise overwrite current char 
8c91					 
8c91			 
8c91			 
8c91			 
8c91 3a 64 ee				ld a, (input_cursor) 
8c94 3c					inc  a 		; TODO check overflow 
8c95 32 64 ee				ld (input_cursor), a 
8c98			 
8c98 3a 71 ee				ld a, (input_at_cursor) 
8c9b 3c					inc a 
8c9c 32 71 ee				ld (input_at_cursor), a 
8c9f			 
8c9f c3 bb 8a				jp .is1 
8ca2			 
8ca2			.endinput:	; TODO look for end of string 
8ca2			 
8ca2					; add trailing space for end of token 
8ca2			 
8ca2 2a 76 ee				ld hl, (input_start) 
8ca5 3a 69 ee				ld a,(input_len) 
8ca8 cd 5d 8a				call addatohl 
8cab 3e 20				ld a, ' ' 
8cad 77					ld (hl),a 
8cae					; TODO eof of parse marker 
8cae			 
8cae 23					inc hl 
8caf 3e 00				ld a, 0 
8cb1 77					ld (hl),a 
8cb2			 
8cb2			 
8cb2 c9					ret 
8cb3			 
8cb3 .. 00		.iblank: db " ",0 
8cb5			 
8cb5			 
8cb5 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8cb8 22 76 ee				ld (input_start), hl 
8cbb 3e 01				ld a,1			; add cursor 
8cbd 77					ld (hl),a 
8cbe 23					inc hl 
8cbf 3e 00				ld a,0 
8cc1 77					ld (hl),a 
8cc2 22 78 ee				ld (input_ptr), hl 
8cc5 7a					ld a,d 
8cc6 32 75 ee				ld (input_size), a 
8cc9 3e 00				ld a,0 
8ccb 32 64 ee				ld (input_cursor),a 
8cce			.instr1:	 
8cce			 
8cce					; TODO do block cursor 
8cce					; TODO switch cursor depending on the modifer key 
8cce			 
8cce					; update cursor shape change on key hold 
8cce			 
8cce 2a 78 ee				ld hl, (input_ptr) 
8cd1 2b					dec hl 
8cd2 3a d3 eb				ld a,(cursor_shape) 
8cd5 77					ld (hl), a 
8cd6			 
8cd6					; display entered text 
8cd6 3a 73 ee				ld a,(input_at_pos) 
8cd9 cd d9 d5		            	CALL fLCD_Pos       ;Position cursor to location in A 
8cdc ed 5b 76 ee	            	LD   de, (input_start) 
8ce0 cd d3 d5		            	CALL fLCD_Str       ;Display string pointed to by DE 
8ce3			 
8ce3 cd 7b d6				call cin 
8ce6 fe 00				cp 0 
8ce8 28 e4				jr z, .instr1 
8cea			 
8cea					; proecess keyboard controls first 
8cea			 
8cea 2a 78 ee				ld hl,(input_ptr) 
8ced			 
8ced fe 0d				cp KEY_CR	 ; pressing enter ends input 
8cef 28 5a				jr z, .instrcr 
8cf1			 
8cf1 fe 08				cp KEY_BS 	; back space 
8cf3 20 0f				jr nz, .instr2 
8cf5					; process back space 
8cf5			 
8cf5					; TODO stop back space if at start of string 
8cf5 2b					dec hl 
8cf6 2b					dec hl ; to over write cursor 
8cf7 3a d3 eb				ld a,(cursor_shape) 
8cfa					;ld a,0 
8cfa 77					ld (hl),a 
8cfb 23					inc hl 
8cfc 3e 20				ld a," " 
8cfe 77					ld (hl),a 
8cff 22 78 ee				ld (input_ptr),hl 
8d02					 
8d02			 
8d02 18 ca				jr .instr1 
8d04			 
8d04 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d06 20 06				jr nz, .instr3 
8d08 2b					dec hl 
8d09 22 78 ee				ld (input_ptr),hl 
8d0c 18 c0				jr .instr1 
8d0e				 
8d0e fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d10 20 06				jr nz, .instr4 
8d12 23					inc hl 
8d13 22 78 ee				ld (input_ptr),hl 
8d16 18 b6				jr .instr1 
8d18			 
8d18 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d1a 20 06				jr nz, .instr5 
8d1c 2b					dec hl 
8d1d 22 78 ee				ld (input_ptr),hl 
8d20 18 ac				jr .instr1 
8d22			 
8d22 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d24 20 06				jr nz, .instr6 
8d26 2b					dec hl 
8d27 22 78 ee				ld (input_ptr),hl 
8d2a 18 a2				jr .instr1 
8d2c fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d2e 20 0b				jr nz, .instrnew 
8d30			 
8d30 21 75 e3			ld hl, scratch 
8d33 11 9b e7			ld de, os_last_cmd 
8d36 cd 54 8d			call strcpy 
8d39 18 93				jr .instr1 
8d3b			 
8d3b			 
8d3b			.instrnew:	; no special key pressed to see if we have room to store it 
8d3b			 
8d3b					; TODO do string size test 
8d3b			 
8d3b 2b					dec hl ; to over write cursor 
8d3c 77					ld (hl),a 
8d3d 23					inc hl 
8d3e 3a d3 eb				ld a,(cursor_shape) 
8d41 77					ld (hl),a 
8d42 23					inc hl 
8d43 3e 00				ld a,0 
8d45 77					ld (hl),a 
8d46			 
8d46 22 78 ee				ld (input_ptr),hl 
8d49					 
8d49 18 83				jr .instr1 
8d4b 2b			.instrcr:	dec hl		; remove cursor 
8d4c 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d4e 77					ld (hl),a 
8d4f 23					inc hl 
8d50 3e 00				ld a,0 
8d52 77					ld (hl),a 
8d53			 
8d53			 
8d53					; if at end of line scroll up    
8d53					; TODO detecting only end of line 4 for scroll up  
8d53			 
8d53					;ld   
8d53			 
8d53 c9					ret 
8d54			 
8d54			 
8d54			; strcpy hl = dest, de source 
8d54			 
8d54 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8d55 b7			            OR   A              ;Null terminator? 
8d56 c8			            RET  Z              ;Yes, so finished 
8d57 1a					ld a,(de) 
8d58 77					ld (hl),a 
8d59 13			            INC  DE             ;Point to next character 
8d5a 23					inc hl 
8d5b 18 f7		            JR   strcpy       ;Repeat 
8d5d c9					ret 
8d5e			 
8d5e			 
8d5e			; TODO string_at  
8d5e			; pass string which starts with lcd offset address and then null term string 
8d5e			 
8d5e			; TODO string to dec 
8d5e			; TODO string to hex 
8d5e			; TODO byte to string hex 
8d5e			; TODO byte to string dec 
8d5e			 
8d5e			 
8d5e			 
8d5e			; from z80uartmonitor 
8d5e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d5e			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8d5e			; pass hl for where to put the text 
8d5e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d5e c5			hexout:	PUSH BC 
8d5f f5					PUSH AF 
8d60 47					LD B, A 
8d61					; Upper nybble 
8d61 cb 3f				SRL A 
8d63 cb 3f				SRL A 
8d65 cb 3f				SRL A 
8d67 cb 3f				SRL A 
8d69 cd 79 8d				CALL tohex 
8d6c 77					ld (hl),a 
8d6d 23					inc hl	 
8d6e					 
8d6e					; Lower nybble 
8d6e 78					LD A, B 
8d6f e6 0f				AND 0FH 
8d71 cd 79 8d				CALL tohex 
8d74 77					ld (hl),a 
8d75 23					inc hl	 
8d76					 
8d76 f1					POP AF 
8d77 c1					POP BC 
8d78 c9					RET 
8d79					 
8d79			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d79			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8d79			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d79			tohex: 
8d79 e5					PUSH HL 
8d7a d5					PUSH DE 
8d7b 16 00				LD D, 0 
8d7d 5f					LD E, A 
8d7e 21 86 8d				LD HL, .DATA 
8d81 19					ADD HL, DE 
8d82 7e					LD A, (HL) 
8d83 d1					POP DE 
8d84 e1					POP HL 
8d85 c9					RET 
8d86			 
8d86			.DATA: 
8d86 30					DEFB	30h	; 0 
8d87 31					DEFB	31h	; 1 
8d88 32					DEFB	32h	; 2 
8d89 33					DEFB	33h	; 3 
8d8a 34					DEFB	34h	; 4 
8d8b 35					DEFB	35h	; 5 
8d8c 36					DEFB	36h	; 6 
8d8d 37					DEFB	37h	; 7 
8d8e 38					DEFB	38h	; 8 
8d8f 39					DEFB	39h	; 9 
8d90 41					DEFB	41h	; A 
8d91 42					DEFB	42h	; B 
8d92 43					DEFB	43h	; C 
8d93 44					DEFB	44h	; D 
8d94 45					DEFB	45h	; E 
8d95 46					DEFB	46h	; F 
8d96			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8d96			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8d96			;;    subtract $30, if result > 9 then subtract $7 more 
8d96			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8d96			atohex: 
8d96 d6 30				SUB $30 
8d98 fe 0a				CP 10 
8d9a f8					RET M		; If result negative it was 0-9 so we're done 
8d9b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8d9d c9					RET		 
8d9e			 
8d9e			 
8d9e			 
8d9e			 
8d9e			; Get 2 ASCII characters as hex byte from pointer in hl 
8d9e			 
8d9e			BYTERD: 
8d9e 16 00			LD	D,00h		;Set up 
8da0 cd a8 8d			CALL	HEXCON		;Get byte and convert to hex 
8da3 87				ADD	A,A		;First nibble so 
8da4 87				ADD	A,A		;multiply by 16 
8da5 87				ADD	A,A		; 
8da6 87				ADD	A,A		; 
8da7 57				LD	D,A		;Save hi nibble in D 
8da8			HEXCON: 
8da8 7e				ld a, (hl)		;Get next chr 
8da9 23				inc hl 
8daa d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8dac fe 0a			CP	00Ah		;Is it 0-9 ? 
8dae 38 02			JR	C,NALPHA	;If so miss next bit 
8db0 d6 07			SUB	007h		;Else convert alpha 
8db2			NALPHA: 
8db2 b2				OR	D		;Add hi nibble back 
8db3 c9				RET			; 
8db4			 
8db4			 
8db4			; 
8db4			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8db4			; Since the routines get_byte and therefore get_nibble are called, only valid 
8db4			; characters (0-9a-f) are accepted. 
8db4			; 
8db4			;get_word        push    af 
8db4			;                call    get_byte        ; Get the upper byte 
8db4			;                ld      h, a 
8db4			;                call    get_byte        ; Get the lower byte 
8db4			;                ld      l, a 
8db4			;                pop     af 
8db4			;                ret 
8db4			; 
8db4			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8db4			; the routine get_nibble is used only valid characters are accepted - the  
8db4			; input routine only accepts characters 0-9a-f. 
8db4			; 
8db4 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8db5 7e					ld a,(hl) 
8db6 23					inc hl 
8db7 cd dc 8d		                call    nibble2val      ; Get upper nibble 
8dba cb 07		                rlc     a 
8dbc cb 07		                rlc     a 
8dbe cb 07		                rlc     a 
8dc0 cb 07		                rlc     a 
8dc2 47			                ld      b, a            ; Save upper four bits 
8dc3 7e					ld a,(hl) 
8dc4 cd dc 8d		                call    nibble2val      ; Get lower nibble 
8dc7 b0			                or      b               ; Combine both nibbles 
8dc8 c1			                pop     bc              ; Restore B (and C) 
8dc9 c9			                ret 
8dca			; 
8dca			; Get a hexadecimal digit from the serial line. This routine blocks until 
8dca			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8dca			; to the serial line interface. The lower 4 bits of A contain the value of  
8dca			; that particular digit. 
8dca			; 
8dca			;get_nibble      ld a,(hl)           ; Read a character 
8dca			;                call    to_upper        ; Convert to upper case 
8dca			;                call    is_hex          ; Was it a hex digit? 
8dca			;                jr      nc, get_nibble  ; No, get another character 
8dca			 ;               call    nibble2val      ; Convert nibble to value 
8dca			 ;               call    print_nibble 
8dca			 ;               ret 
8dca			; 
8dca			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8dca			; A valid hexadecimal digit is denoted by a set C flag. 
8dca			; 
8dca			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8dca			;                ret     nc              ; Yes 
8dca			;                cp      '0'             ; Less than '0'? 
8dca			;                jr      nc, is_hex_1    ; No, continue 
8dca			;                ccf                     ; Complement carry (i.e. clear it) 
8dca			;                ret 
8dca			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8dca			;                ret     c               ; Yes 
8dca			;                cp      'A'             ; Less than 'A'? 
8dca			;                jr      nc, is_hex_2    ; No, continue 
8dca			;                ccf                     ; Yes - clear carry and return 
8dca			;                ret 
8dca			;is_hex_2        scf                     ; Set carry 
8dca			;                ret 
8dca			; 
8dca			; Convert a single character contained in A to upper case: 
8dca			; 
8dca fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8dcc d8			                ret     c 
8dcd fe 7b		                cp      'z' + 1         ; > 'z'? 
8dcf d0			                ret     nc              ; Nothing to do, either 
8dd0 e6 5f		                and     $5f             ; Convert to upper case 
8dd2 c9			                ret 
8dd3			 
8dd3			 
8dd3			to_lower: 
8dd3			 
8dd3			   ; if char is in [A-Z] make it lower case 
8dd3			 
8dd3			   ; enter : a = char 
8dd3			   ; exit  : a = lower case char 
8dd3			   ; uses  : af 
8dd3			 
8dd3 fe 41		   cp 'A' 
8dd5 d8			   ret c 
8dd6			    
8dd6 fe 5b		   cp 'Z'+1 
8dd8 d0			   ret nc 
8dd9			    
8dd9 f6 20		   or $20 
8ddb c9			   ret 
8ddc			 
8ddc			; 
8ddc			; Expects a hexadecimal digit (upper case!) in A and returns the 
8ddc			; corresponding value in A. 
8ddc			; 
8ddc fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8dde 38 02		                jr      c, nibble2val_1 ; Yes 
8de0 d6 07		                sub     7               ; Adjust for A-F 
8de2 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8de4 e6 0f		                and     $f              ; Only return lower 4 bits 
8de6 c9			                ret 
8de7			; 
8de7			; Print_nibble prints a single hex nibble which is contained in the lower  
8de7			; four bits of A: 
8de7			; 
8de7			;print_nibble    push    af              ; We won't destroy the contents of A 
8de7			;                and     $f              ; Just in case... 
8de7			;                add     a, '0'             ; If we have a digit we are done here. 
8de7			;                cp      '9' + 1         ; Is the result > 9? 
8de7			;                jr      c, print_nibble_1 
8de7			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8de7			;print_nibble_1  call    putc            ; Print the nibble and 
8de7			;                pop     af              ; restore the original value of A 
8de7			;                ret 
8de7			;; 
8de7			;; Send a CR/LF pair: 
8de7			; 
8de7			;crlf            push    af 
8de7			;                ld      a, cr 
8de7			;                call    putc 
8de7			;                ld      a, lf 
8de7			;                call    putc 
8de7			;                pop     af 
8de7			;                ret 
8de7			; 
8de7			; Print_word prints the four hex digits of a word to the serial line. The  
8de7			; word is expected to be in HL. 
8de7			; 
8de7			;print_word      push    hl 
8de7			;                push    af 
8de7			;                ld      a, h 
8de7			;                call    print_byte 
8de7			;                ld      a, l 
8de7			;                call    print_byte 
8de7			;                pop     af 
8de7			;                pop     hl 
8de7			;                ret 
8de7			; 
8de7			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8de7			; The byte to be printed is expected to be in A. 
8de7			; 
8de7			;print_byte      push    af              ; Save the contents of the registers 
8de7			;                push    bc 
8de7			;                ld      b, a 
8de7			;                rrca 
8de7			;                rrca 
8de7			;                rrca 
8de7			;                rrca 
8de7			;                call    print_nibble    ; Print high nibble 
8de7			;                ld      a, b 
8de7			;                call    print_nibble    ; Print low nibble 
8de7			;                pop     bc              ; Restore original register contents 
8de7			;                pop     af 
8de7			;                ret 
8de7			 
8de7			 
8de7			 
8de7			 
8de7			 
8de7			fourehexhl:  
8de7 7e				ld a,(hl) 
8de8 cd 96 8d			call atohex 
8deb cb 3f				SRL A 
8ded cb 3f				SRL A 
8def cb 3f				SRL A 
8df1 cb 3f				SRL A 
8df3 47				ld b, a 
8df4 23				inc hl 
8df5 7e				ld a,(hl) 
8df6 23				inc hl 
8df7 cd 96 8d			call atohex 
8dfa 80				add b 
8dfb 57				ld d,a 
8dfc 7e				ld a,(hl) 
8dfd cd 96 8d			call atohex 
8e00 cb 3f				SRL A 
8e02 cb 3f				SRL A 
8e04 cb 3f				SRL A 
8e06 cb 3f				SRL A 
8e08 47				ld b, a 
8e09 23				inc hl 
8e0a 7e				ld a,(hl) 
8e0b 23				inc hl 
8e0c cd 96 8d			call atohex 
8e0f 80				add b 
8e10 5f				ld e, a 
8e11 d5				push de 
8e12 e1				pop hl 
8e13 c9				ret 
8e14			 
8e14			; pass hl. returns z set if the byte at hl is a digit 
8e14			;isdigithl:  
8e14			;	push bc 
8e14			;	ld a,(hl) 
8e14			;	cp ':' 
8e14			;	jr nc, .isdf 		; > 
8e14			;	cp '0' 
8e14			;	jr c, .isdf		; < 
8e14			; 
8e14			;	; TODO find a better way to set z 
8e14			; 
8e14			;	ld b,a 
8e14			;	cp b 
8e14			;	pop bc 
8e14			;	ret 
8e14			; 
8e14			;.isdf:	; not digit so clear z 
8e14			; 
8e14			;	; TODO find a better way to unset z 
8e14			; 
8e14			;	ld b,a 
8e14			;	inc b 
8e14			;	cp b 
8e14			; 
8e14			;	pop bc 
8e14			;	ret 
8e14				 
8e14				 
8e14			 
8e14			 
8e14			; pass hl as the four byte address to load 
8e14			 
8e14			get_word_hl:  
8e14 e5				push hl 
8e15 cd b4 8d			call get_byte 
8e18				 
8e18 47				ld b, a 
8e19			 
8e19 e1				pop hl 
8e1a 23				inc hl 
8e1b 23				inc hl 
8e1c			 
8e1c			; TODO not able to handle a-f  
8e1c 7e				ld a,(hl) 
8e1d			;	;cp ':' 
8e1d			;	cp 'g' 
8e1d			;	jr nc, .single_byte_hl 		; > 
8e1d			;	cp 'G' 
8e1d			;	jr nc, .single_byte_hl 		; > 
8e1d			;	cp '0' 
8e1d			;	jr c, .single_byte_hl		; < 
8e1d			 
8e1d				;call isdigithl 
8e1d fe 00			cp 0 
8e1f 28 06			jr z, .single_byte_hl 
8e21			 
8e21			.getwhln:   ; hex word so get next byte 
8e21			 
8e21 cd b4 8d			call get_byte 
8e24 6f				ld l, a 
8e25 60				ld h,b 
8e26 c9				ret 
8e27 68			.single_byte_hl:   ld l,b 
8e28 26 00				ld h,0 
8e2a c9					ret 
8e2b			 
8e2b			 
8e2b			 
8e2b			 
8e2b 21 26 95			ld hl,asc+1 
8e2e			;	ld a, (hl) 
8e2e			;	call nibble2val 
8e2e cd b4 8d			call get_byte 
8e31			 
8e31			;	call fourehexhl 
8e31 32 a9 e3			ld (scratch+52),a 
8e34				 
8e34 21 a7 e3			ld hl,scratch+50 
8e37 22 98 e6			ld (os_cur_ptr),hl 
8e3a			 
8e3a c9				ret 
8e3b			 
8e3b			 
8e3b			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e3b			 
8e3b			; Decimal Unsigned Version 
8e3b			 
8e3b			;Number in a to decimal ASCII 
8e3b			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e3b			;Example: display a=56 as "056" 
8e3b			;input: a = number 
8e3b			;Output: a=0,value of a in the screen 
8e3b			;destroys af,bc (don't know about hl and de) 
8e3b			DispAToASCII: 
8e3b 0e 9c			ld	c,-100 
8e3d cd 47 8e			call	.Na1 
8e40 0e f6			ld	c,-10 
8e42 cd 47 8e			call	.Na1 
8e45 0e ff			ld	c,-1 
8e47 06 2f		.Na1:	ld	b,'0'-1 
8e49 04			.Na2:	inc	b 
8e4a 81				add	a,c 
8e4b 38 fc			jr	c,.Na2 
8e4d 91				sub	c		;works as add 100/10/1 
8e4e f5				push af		;safer than ld c,a 
8e4f 78				ld	a,b		;char is in b 
8e50			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e50 f1				pop af		;safer than ld a,c 
8e51 c9				ret 
8e52			 
8e52			; Decimal Signed Version 
8e52			 
8e52			; DispA 
8e52			; -------------------------------------------------------------- 
8e52			; Converts a signed integer value to a zero-terminated ASCII 
8e52			; string representative of that value (using radix 10). 
8e52			; -------------------------------------------------------------- 
8e52			; INPUTS: 
8e52			;     HL     Value to convert (two's complement integer). 
8e52			;     DE     Base address of string destination. (pointer). 
8e52			; -------------------------------------------------------------- 
8e52			; OUTPUTS: 
8e52			;     None 
8e52			; -------------------------------------------------------------- 
8e52			; REGISTERS/MEMORY DESTROYED 
8e52			; AF HL 
8e52			; -------------------------------------------------------------- 
8e52			 
8e52			;DispHLToASCII: 
8e52			;   push    de 
8e52			;   push    bc 
8e52			; 
8e52			;; Detect sign of HL. 
8e52			;    bit    7, h 
8e52			;    jr     z, ._DoConvert 
8e52			; 
8e52			;; HL is negative. Output '-' to string and negate HL. 
8e52			;    ld     a, '-' 
8e52			;    ld     (de), a 
8e52			;    inc    de 
8e52			; 
8e52			;; Negate HL (using two's complement) 
8e52			;    xor    a 
8e52			;    sub    l 
8e52			;    ld     l, a 
8e52			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e52			;    sbc    a, h 
8e52			;    ld     h, a 
8e52			; 
8e52			;; Convert HL to digit characters 
8e52			;._DoConvert: 
8e52			;    ld     b, 0     ; B will count character length of number 
8e52			;-   ld     a, 10 
8e52			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e52			;    push   af 
8e52			;    inc    b 
8e52			;    ld     a, h 
8e52			;    or     l 
8e52			;    jr     nz, - 
8e52			; 
8e52			;; Retrieve digits from stack 
8e52			;-   pop    af 
8e52			;    or     $30 
8e52			;    ld     (de), a 
8e52			;    inc    de 
8e52			;    djnz   - 
8e52			; 
8e52			;; Terminate string with NULL 
8e52			;    xor    a 
8e52			;    ld     (de), a 
8e52			; 
8e52			;    pop    bc 
8e52			;    pop    de 
8e52			;    ret 
8e52			 
8e52			;Comments 
8e52			; 
8e52			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e52			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e52			;    Note that the output string will not be fixed-width. 
8e52			; 
8e52			;Example Usage 
8e52			; 
8e52			;    ld    hl, -1004 
8e52			;    ld    de, OP1 
8e52			;    call  DispA 
8e52			;    ld    hl, OP1 
8e52			;    syscall  PutS 
8e52			 
8e52			 
8e52			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e52			 
8e52			 
8e52			;Converts an ASCII string to an unsigned 16-bit integer 
8e52			;Quits when it reaches a non-decimal digit 
8e52			 
8e52			string_to_uint16: 
8e52			atoui_16: 
8e52			;Input: 
8e52			;     DE points to the string 
8e52			;Outputs: 
8e52			;     HL is the result 
8e52			;     A is the 8-bit value of the number 
8e52			;     DE points to the byte after the number 
8e52			;Destroys: 
8e52			;     BC 
8e52			;       if the string is non-empty, BC is HL/10 
8e52			;Size:  24 bytes 
8e52			;Speed: 42+d(104+{0,9}) 
8e52			;       d is the number of digits in the number 
8e52			;       max is 640 cycles for a 5 digit number 
8e52			;Assuming no leading zeros: 
8e52			;1 digit:  146cc 
8e52			;2 digit:  250cc 
8e52			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e52			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e52			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e52			;avg: 544.81158447265625cc (544+13297/16384) 
8e52			;=============================================================== 
8e52 21 00 00		  ld hl,0 
8e55			.u16a: 
8e55 1a			  ld a,(de) 
8e56 d6 30		  sub 30h 
8e58 fe 0a		  cp 10 
8e5a d0			  ret nc 
8e5b 13			  inc de 
8e5c 44			  ld b,h 
8e5d 4d			  ld c,l 
8e5e 29			  add hl,hl 
8e5f 29			  add hl,hl 
8e60 09			  add hl,bc 
8e61 29			  add hl,hl 
8e62 85			  add a,l 
8e63 6f			  ld l,a 
8e64 30 ef		  jr nc,.u16a 
8e66 24			  inc h 
8e67 c3 55 8e		  jp .u16a 
8e6a			 
8e6a			 
8e6a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e6a			 
8e6a			;written by Zeda 
8e6a			;Converts a 16-bit unsigned integer to an ASCII string. 
8e6a			 
8e6a			uitoa_16: 
8e6a			;Input: 
8e6a			;   DE is the number to convert 
8e6a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8e6a			;Output: 
8e6a			;   HL points to the null-terminated ASCII string 
8e6a			;      NOTE: This isn't necessarily the same as the input HL. 
8e6a d5			  push de 
8e6b c5			  push bc 
8e6c f5			  push af 
8e6d eb			  ex de,hl 
8e6e			 
8e6e 01 f0 d8		  ld bc,-10000 
8e71 3e 2f		  ld a,'0'-1 
8e73 3c			  inc a 
8e74 09			  add hl,bc  
8e75 38 fc		   jr c,$-2 
8e77 12			  ld (de),a 
8e78 13			  inc de 
8e79			 
8e79 01 e8 03		  ld bc,1000 
8e7c 3e 3a		  ld a,'9'+1 
8e7e 3d			  dec a  
8e7f 09			  add hl,bc  
8e80 30 fc		   jr nc,$-2 
8e82 12			  ld (de),a 
8e83 13			  inc de 
8e84			 
8e84 01 9c ff		  ld bc,-100 
8e87 3e 2f		  ld a,'0'-1 
8e89 3c			  inc a  
8e8a 09			  add hl,bc  
8e8b 38 fc		   jr c,$-2 
8e8d 12			  ld (de),a 
8e8e 13			  inc de 
8e8f			 
8e8f 7d			  ld a,l 
8e90 26 3a		  ld h,'9'+1 
8e92 25			  dec h  
8e93 c6 0a		  add a,10  
8e95 30 fb		   jr nc,$-3 
8e97 c6 30		  add a,'0' 
8e99 eb			  ex de,hl 
8e9a 72			  ld (hl),d 
8e9b 23			  inc hl 
8e9c 77			  ld (hl),a 
8e9d 23			  inc hl 
8e9e 36 00		  ld (hl),0 
8ea0			 
8ea0			;Now strip the leading zeros 
8ea0 0e fa		  ld c,-6 
8ea2 09			  add hl,bc 
8ea3 3e 30		  ld a,'0' 
8ea5 23			  inc hl  
8ea6 be			  cp (hl)  
8ea7 28 fc		  jr z,$-2 
8ea9			 
8ea9			;Make sure that the string is non-empty! 
8ea9 7e			  ld a,(hl) 
8eaa b7			  or a 
8eab 20 01		  jr nz,.atoub 
8ead 2b			  dec hl 
8eae			.atoub: 
8eae			 
8eae f1			  pop af 
8eaf c1			  pop bc 
8eb0 d1			  pop de 
8eb1 c9			  ret 
8eb2			 
8eb2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8eb2			 
8eb2			toUpper: 
8eb2			;A is the char. 
8eb2			;If A is a lowercase letter, this sets it to the matching uppercase 
8eb2			;18cc or 30cc or 41cc 
8eb2			;avg: 26.75cc 
8eb2 fe 61		  cp 'a' 
8eb4 d8			  ret c 
8eb5 fe 7b		  cp 'z'+1 
8eb7 d0			  ret nc 
8eb8 d6 20		  sub 'a'-'A' 
8eba c9			  ret 
8ebb			 
8ebb			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8ebb			 
8ebb			; String Length 
8ebb			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8ebb			 
8ebb			; Get the length of the null-terminated string starting at $8000 hl 
8ebb			;    LD     HL, $8000 
8ebb			 
8ebb			strlenz: 
8ebb			 
8ebb af			    XOR    A               ; Zero is the value we are looking for. 
8ebc 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8ebd 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8ebe			                           ; 65, 536 bytes (the entire addressable memory space). 
8ebe ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8ec0			 
8ec0			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8ec0 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8ec1 6f			    LD     L, A             ; number of bytes 
8ec2 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8ec4 2b			    DEC    HL              ; Compensate for null. 
8ec5 c9				ret 
8ec6			 
8ec6			; Get the length of the A terminated string starting at $8000 hl 
8ec6			;    LD     HL, $8000 
8ec6			 
8ec6			strlent: 
8ec6			 
8ec6			                  ; A is the value we are looking for. 
8ec6 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8ec8 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8eca			                           ; 65, 536 bytes (the entire addressable memory space). 
8eca ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8ecc			 
8ecc			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8ecc 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8ece 2e 00		    LD     L, 0             ; number of bytes 
8ed0 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8ed2 2b			    DEC    HL              ; Compensate for null. 
8ed3 c9				ret 
8ed4			 
8ed4			 
8ed4			;Comparing Strings 
8ed4			 
8ed4			;IN    HL     Address of string1. 
8ed4			;      DE     Address of string2. 
8ed4			 
8ed4			; doc given but wrong??? 
8ed4			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8ed4			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8ed4			; tested 
8ed4			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8ed4			 
8ed4			strcmp_old: 
8ed4 e5			    PUSH   HL 
8ed5 d5			    PUSH   DE 
8ed6			 
8ed6 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8ed7 be			    CP     (HL)            ; (want to minimize work). 
8ed8 38 01		    JR     C, Str1IsBigger 
8eda 7e			    LD     A, (HL) 
8edb			 
8edb			Str1IsBigger: 
8edb 4f			    LD     C, A             ; Put length in BC 
8edc 06 00		    LD     B, 0 
8ede 13			    INC    DE              ; Increment pointers to meat of string. 
8edf 23			    INC    HL 
8ee0			 
8ee0			CmpLoop: 
8ee0 1a			    LD     A, (DE)          ; Compare bytes. 
8ee1 ed a1		    CPI 
8ee3 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8ee5 13			    INC    DE              ; Update pointer. 
8ee6 ea e0 8e		    JP     PE, CmpLoop 
8ee9			 
8ee9 d1			    POP    DE 
8eea e1			    POP    HL 
8eeb 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8eec be			    CP     (HL) 
8eed c9			    RET 
8eee			 
8eee			NoMatch: 
8eee 2b			    DEC    HL 
8eef be			    CP     (HL)            ; Compare again to affect carry. 
8ef0 d1			    POP    DE 
8ef1 e1			    POP    HL 
8ef2 c9			    RET 
8ef3			 
8ef3			;; test strmp 
8ef3			; 
8ef3			;ld de, .str1 
8ef3			;ld hl, .str2 
8ef3			;call strcmp 
8ef3			;jr z, .z1 
8ef3			;;this 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "NZ1" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			;.z1: 
8ef3			; 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "ZZ1" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			; 
8ef3			;ld de, .str1 
8ef3			;ld hl, .str1 
8ef3			;call strcmp 
8ef3			;jr z, .z2 
8ef3			;;this 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "NZ2" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			;.z2: 
8ef3			; 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "ZZ2" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			; 
8ef3			;ld de, .str1 
8ef3			;ld hl, .str2 
8ef3			;call strcmp 
8ef3			;jr c, .c1 
8ef3			; 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "Nc1" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			;.c1: 
8ef3			;;this 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "cc1" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			; 
8ef3			;ld de, .str1 
8ef3			;ld hl, .str1 
8ef3			;call strcmp 
8ef3			;jr c, .c2 
8ef3			;;this 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "Nc2" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			;.c2: 
8ef3			; 
8ef3			;	if DEBUG_FORTH_WORDS 
8ef3			;		DMARK "cc2" 
8ef3			;		CALLMONITOR 
8ef3			;	endif 
8ef3			;	NEXTW 
8ef3			;.str1:   db "string1",0 
8ef3			;.str2:   db "string2",0 
8ef3			 
8ef3			; only care about direct match or not 
8ef3			; hl and de strings 
8ef3			; zero set if the same 
8ef3			 
8ef3			strcmp: 
8ef3 1a				ld a, (de) 
8ef4 be				cp (hl) 
8ef5 28 02			jr z, .ssame 
8ef7 b7				or a 
8ef8 c9				ret 
8ef9			 
8ef9			.ssame:  
8ef9 fe 00			cp 0 
8efb c8				ret z 
8efc			 
8efc 23				inc hl 
8efd 13				inc de 
8efe 18 f3			jr strcmp 
8f00				 
8f00				 
8f00			 
8f00			 
8f00			 
8f00			 
8f00			; eof 
8f00			 
8f00			 
8f00			 
8f00			 
8f00			 
8f00			 
# End of file firmware_strings.asm
8f00			include "firmware_memory.asm"   ; malloc and free  
8f00			 
8f00			if DEBUG_FORTH_MALLOC_HIGH 
8f00			.mallocsize: db "Wants malloc >256",0 
8f00			.mallocasize: db "MALLOC gives >256",0 
8f00			.malloczero: db "MALLOC gives zero",0 
8f00			 
8f00			malloc_guard_zerolen: 
8f00				push hl 
8f00				push de 
8f00				push af 
8f00			 
8f00				ld de, 0 
8f00			        call cmp16 
8f00				jr nz, .lowalloz 
8f00			 
8f00				push hl 
8f00				push de 
8f00					ld hl, display_fb0 
8f00					ld (display_fb_active), hl 
8f00				call clear_display 
8f00				ld a, 0 
8f00				ld de, .malloczero 
8f00				call str_at_display 
8f00				call update_display 
8f00				call delay1s 
8f00				call delay1s 
8f00				ld a, 0 
8f00				ld (os_view_disable), a 
8f00			 
8f00				pop de 
8f00				pop hl 
8f00			 
8f00				 
8f00			 
8f00				CALLMONITOR 
8f00			.lowalloz: 
8f00			 
8f00			 
8f00				pop af 
8f00				pop de 
8f00				pop hl 
8f00			ret 
8f00			 
8f00			malloc_guard_entry: 
8f00				push hl 
8f00				push de 
8f00				push af 
8f00			 
8f00			 	or a      ;clear carry flag 
8f00				push hl 
8f00				ld de, 255 
8f00				sbc hl, de 
8f00				jr c, .lowalloc 
8f00			 
8f00				push de 
8f00					ld hl, display_fb0 
8f00					ld (display_fb_active), hl 
8f00				call clear_display 
8f00				ld a, 0 
8f00				ld de, .mallocsize 
8f00				call str_at_display 
8f00				call update_display 
8f00				call delay1s 
8f00				call delay1s 
8f00				ld a, 0 
8f00				ld (os_view_disable), a 
8f00			 
8f00				pop de 
8f00				pop hl 
8f00			 
8f00				 
8f00			 
8f00				CALLMONITOR 
8f00				jr .lowdone 
8f00			.lowalloc: 
8f00			 
8f00			 
8f00				pop hl 
8f00			.lowdone:	pop af 
8f00				pop de 
8f00				pop hl 
8f00			ret 
8f00			 
8f00			malloc_guard_exit: 
8f00				push hl 
8f00				push de 
8f00				push af 
8f00			 
8f00			 	or a      ;clear carry flag 
8f00				push hl 
8f00				ld de, 255 
8f00				sbc hl, de 
8f00				jr c, .lowallocx 
8f00			 
8f00				push de 
8f00					ld hl, display_fb0 
8f00					ld (display_fb_active), hl 
8f00				call clear_display 
8f00				ld a, 0 
8f00				ld de, .mallocasize 
8f00				call str_at_display 
8f00				call update_display 
8f00				call delay1s 
8f00				call delay1s 
8f00				ld a, 0 
8f00				ld (os_view_disable), a 
8f00				pop de 
8f00				pop hl 
8f00			 
8f00				CALLMONITOR 
8f00				jr .lowdonex 
8f00			.lowallocx: 
8f00			 
8f00				pop hl 
8f00			.lowdonex:	pop af 
8f00				pop de 
8f00				pop hl 
8f00			ret 
8f00			endif 
8f00			 
8f00			if MALLOC_2 
8f00			; Z80 Malloc and Free Functions 
8f00			 
8f00			; Malloc Function: 
8f00			; Input: 
8f00			;   HL: Size of block to allocate 
8f00			; Output: 
8f00			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f00			 
8f00			malloc: 
8f00				 
8f00			if DEBUG_FORTH_MALLOC_HIGH 
8f00			call malloc_guard_entry 
8f00			endif 
8f00			 
8f00			 
8f00			 
8f00			 
8f00					if DEBUG_FORTH_MALLOC 
8f00						DMARK "mal" 
8f00						CALLMONITOR 
8f00					endif 
8f00			    push af            ; Save AF register 
8f00			    ld a, l            ; Load low byte of size into A 
8f00			    or h               ; Check if size is zero 
8f00			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f00			 
8f00			    ; Allocate memory 
8f00			    ld hl, (heap_start) ; Load start of heap into HL 
8f00					if DEBUG_FORTH_MALLOC 
8f00						DMARK "ma1" 
8f00						CALLMONITOR 
8f00					endif 
8f00			    call malloc_internal ; Call internal malloc function 
8f00			    pop af             ; Restore AF register 
8f00			if DEBUG_FORTH_MALLOC_HIGH 
8f00			call malloc_guard_exit 
8f00			call malloc_guard_zerolen 
8f00			endif 
8f00			    ret                ; Return 
8f00			 
8f00			; Free Function: 
8f00			; Input: 
8f00			;   HL: Pointer to memory block to free 
8f00			; Output: 
8f00			;   None 
8f00			 
8f00			free: 
8f00			    push af            ; Save AF register 
8f00			    ld a, l            ; Load low byte of pointer into A 
8f00			    or h               ; Check if pointer is NULL 
8f00			    jp z, free_exit    ; If pointer is NULL, exit 
8f00			 
8f00			    ; Free memory 
8f00			    ld hl, (heap_start) ; Load start of heap into HL 
8f00			    call free_internal  ; Call internal free function 
8f00			    pop af             ; Restore AF register 
8f00			    ret                ; Return 
8f00			 
8f00			; Internal Malloc Function: 
8f00			; Input: 
8f00			;   HL: Size of block to allocate 
8f00			; Output: 
8f00			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f00			 
8f00			malloc_internal: 
8f00			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f00			    add hl, bc         ; Add management overhead to requested size 
8f00			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f00					if DEBUG_FORTH_MALLOC 
8f00						DMARK "ma2" 
8f00						CALLMONITOR 
8f00					endif 
8f00			 
8f00			    ; Search for free memory block 
8f00			    ld de, (heap_end)  ; Load end of heap into DE 
8f00			    ld bc, 0           ; Initialize counter 
8f00			 
8f00					if DEBUG_FORTH_MALLOC 
8f00						DMARK "ma2" 
8f00						CALLMONITOR 
8f00					endif 
8f00			malloc_search_loop: 
8f00			    ; Check if current block is free 
8f00			    ld a, (hl)         ; Load current block's status (free or used) 
8f00			    cp 0               ; Compare with zero (free) 
8f00			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f00			 
8f00			    ; Check if current block is large enough 
8f00			    ld a, (hl+1)       ; Load high byte of block size 
8f00			    cp l               ; Compare with low byte of requested size 
8f00			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f00			 
8f00			    ld a, (hl+2)       ; Load low byte of block size 
8f00			    cp h               ; Compare with high byte of requested size 
8f00			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f00			 
8f00			    ; Mark block as used 
8f00			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f00			 
8f00			    ; Calculate remaining space in block 
8f00			    ld bc, 0           ; Clear BC 
8f00			    add hl, bc         ; Increment HL to point to start of data block 
8f00			    add hl, de         ; HL = HL + DE (total size) 
8f00			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f00			    add hl, bc         ; Add management overhead to start of data block 
8f00			 
8f00			    ; Save pointer to allocated block in HL 
8f00			if DEBUG_FORTH_MALLOC_HIGH 
8f00						DMARK "ma5" 
8f00			call malloc_guard_exit 
8f00			call malloc_guard_zerolen 
8f00			endif 
8f00			    ret 
8f00			 
8f00			malloc_skip_block_check: 
8f00			    ; Move to the next block 
8f00			    ld bc, 3           ; Size of management overhead 
8f00			    add hl, bc         ; Move to the next block 
8f00			    inc de             ; Increment counter 
8f00			 
8f00			    ; Check if we have reached the end of heap 
8f00			    ld a, e            ; Load low byte of heap end address 
8f00			    cp (hl)            ; Compare with low byte of current address 
8f00			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f00			    ld a, d            ; Load high byte of heap end address 
8f00			    cp 0               ; Check if it's zero (end of memory) 
8f00			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f00			 
8f00			    ; If we reached here, allocation failed 
8f00			    xor a              ; Set result to NULL 
8f00			if DEBUG_FORTH_MALLOC_HIGH 
8f00						DMARK "ma6" 
8f00			call malloc_guard_exit 
8f00			call malloc_guard_zerolen 
8f00			endif 
8f00			    ret 
8f00			malloc_exit: 
8f00			if DEBUG_FORTH_MALLOC_HIGH 
8f00						DMARK "ma7" 
8f00			call malloc_guard_exit 
8f00			call malloc_guard_zerolen 
8f00			endif 
8f00			    ret 
8f00			 
8f00			; Internal Free Function: 
8f00			; Input: 
8f00			;   HL: Pointer to memory block to free 
8f00			; Output: 
8f00			;   None 
8f00			 
8f00			free_internal: 
8f00			    ld de, (heap_start) ; Load start of heap into DE 
8f00			    ld bc, 0            ; Initialize counter 
8f00			 
8f00			free_search_loop: 
8f00			    ; Check if current block contains the pointer 
8f00			    ld a, l             ; Load low byte of pointer 
8f00			    cp (hl+1)           ; Compare with high byte of current block's address 
8f00			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f00			    ld a, h             ; Load high byte of pointer 
8f00			    cp (hl+2)           ; Compare with low byte of current block's address 
8f00			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f00			 
8f00			    ; Mark block as free 
8f00			    ld (hl), 0          ; Set status byte to indicate free block 
8f00			    ret                 ; Return 
8f00			 
8f00			free_skip_block_check: 
8f00			    ; Move to the next block 
8f00			    ld bc, 3            ; Size of management overhead 
8f00			    add hl, bc          ; Move to the next block 
8f00			    inc de              ; Increment counter 
8f00			 
8f00			    ; Check if we have reached the end of heap 
8f00			    ld a, e             ; Load low byte of heap end address 
8f00			    cp (hl)             ; Compare with low byte of current address 
8f00			    jr nz, free_search_loop  ; If not equal, continue searching 
8f00			    ld a, d             ; Load high byte of heap end address 
8f00			    cp 0                ; Check if it's zero (end of memory) 
8f00			    jr nz, free_search_loop  ; If not zero, continue searching 
8f00			 
8f00			    ; If we reached here, pointer is not found in heap 
8f00			    ret 
8f00			 
8f00			free_exit: 
8f00			    ret                 ; Return 
8f00			 
8f00			; Define heap start and end addresses 
8f00			;heap_start:    .dw 0xC000   ; Start of heap 
8f00			;heap_end:      .dw 0xE000   ; End of heap 
8f00			 
8f00			endif 
8f00			 
8f00			 
8f00			if MALLOC_1 
8f00			 
8f00			 
8f00			 
8f00			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f00			 
8f00			;moved to firmware.asm 
8f00			;heap_start        .equ  0x9000      ; Starting address of heap 
8f00			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f00			 
8f00			;      .org 0 
8f00			;      jp    main 
8f00			 
8f00			 
8f00			;      .org  0x100 
8f00			;main: 
8f00			;      ld    HL, 0x8100 
8f00			;      ld    SP, HL 
8f00			; 
8f00			;      call  heap_init 
8f00			; 
8f00			;      ; Make some allocations 
8f00			;      ld    HL, 12 
8f00			;      call  malloc            ; Allocates 0x9004 
8f00			; 
8f00			;      ld    HL, 12 
8f00			;      call  malloc            ; Allocates 0x9014 
8f00			; 
8f00			;      ld    HL, 12 
8f00			;      call  malloc            ; Allocates 0x9024 
8f00			; 
8f00			;      ; Free some allocations 
8f00			;      ld    HL, 0x9014 
8f00			;      call  free 
8f00			; 
8f00			;      ld    HL, 0x9004 
8f00			;      call  free 
8f00			; 
8f00			;      ld    HL, 0x9024 
8f00			;      call  free 
8f00			; 
8f00			; 
8f00			;      halt 
8f00			 
8f00			 
8f00			;------------------------------------------------------------------------------ 
8f00			;     heap_init                                                               : 
8f00			;                                                                             : 
8f00			; Description                                                                 : 
8f00			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f00			;                                                                             : 
8f00			;     The heap is maintained as a linked list, starting with an initial       : 
8f00			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f00			;     the first free block in the heap. Each block then points to the next    : 
8f00			;     free block within the heap, and the free list ends at the first block   : 
8f00			;     with a null pointer to the next free block.                             : 
8f00			;                                                                             : 
8f00			; Parameters                                                                  : 
8f00			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f00			;     address of the heap and its size are required, along with a memory      : 
8f00			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f00			;     principally stores a pointer to the first free block in the heap.       : 
8f00			;                                                                             : 
8f00			; Returns                                                                     : 
8f00			;     Nothing                                                                 : 
8f00			;------------------------------------------------------------------------------ 
8f00			heap_init: 
8f00 e5			      push  HL 
8f01			 
8f01			      ; Initialise free list struct 
8f01 21 99 d6		      ld    HL, heap_start 
8f04 22 94 d6		      ld    (free_list), HL 
8f07 21 00 00		      ld    HL, 0 
8f0a 22 96 d6		      ld    (free_list+2), HL 
8f0d			 
8f0d			      ; Insert first free block at bottom of heap, consumes entire heap 
8f0d 21 65 e3		      ld    HL, heap_start+heap_size-4 
8f10 22 99 d6		      ld    (heap_start), HL        ; Next block (end of free list) 
8f13 21 cc 0c		      ld    HL, heap_size-4 
8f16 22 9b d6		      ld    (heap_start+2), HL      ; Block size 
8f19			 
8f19			      ; Insert end of free list block at top of heap - two null words will 
8f19			      ; terminate the free list 
8f19 21 00 00		      ld    HL, 0 
8f1c 22 67 e3		      ld    (heap_start+heap_size-2), HL 
8f1f 22 65 e3		      ld    (heap_start+heap_size-4), HL 
8f22			 
8f22 e1			      pop   HL 
8f23			 
8f23 c9			      ret 
8f24			 
8f24			 
8f24			;------------------------------------------------------------------------------ 
8f24			;     malloc                                                                  : 
8f24			;                                                                             : 
8f24			; Description                                                                 : 
8f24			;     Allocates the wanted space from the heap and returns the address of the : 
8f24			;     first useable byte of the allocation.                                   : 
8f24			;                                                                             : 
8f24			;     Allocations can happen in one of two ways:                              : 
8f24			;                                                                             : 
8f24			;     1. A free block may be found which is the exact size wanted. In this    : 
8f24			;        case the block is removed from the free list and retuedn to the      : 
8f24			;        caller.                                                              : 
8f24			;     2. A free block may be found which is larger than the size wanted. In   : 
8f24			;        this case, the larger block is split into two. The first portion of  : 
8f24			;        this block will become the requested space by the malloc call and    : 
8f24			;        is returned to the caller. The second portion becomes a new free     : 
8f24			;        block, and the free list is adjusted to maintain continuity via this : 
8f24			;        newly created block.                                                 : 
8f24			;                                                                             : 
8f24			;     malloc does not set any initial value in the allocated space, the       : 
8f24			;     caller is required to do this as required.                              : 
8f24			;                                                                             : 
8f24			;     This implementation of malloc uses the stack exclusively, and is        : 
8f24			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f24			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f24			;     to avoid the use of malloc inside ISRs in general.                      : 
8f24			;                                                                             : 
8f24			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f24			;                                                                             : 
8f24			; Parameters                                                                  : 
8f24			;     HL  Number of bytes wanted                                              : 
8f24			;                                                                             : 
8f24			; Returns                                                                     : 
8f24			;     HL  Address of the first useable byte of the allocation                 : 
8f24			;                                                                             : 
8f24			; Flags                                                                       : 
8f24			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f24			;                                                                             : 
8f24			; Stack frame                                                                 : 
8f24			;       |             |                                                       : 
8f24			;       +-------------+                                                       : 
8f24			;       |     BC      |                                                       : 
8f24			;       +-------------+                                                       : 
8f24			;       |     DE      |                                                       : 
8f24			;       +-------------+                                                       : 
8f24			;       |     IX      |                                                       : 
8f24			;       +-------------+                                                       : 
8f24			;       |  prev_free  |                                                       : 
8f24			;   +4  +-------------+                                                       : 
8f24			;       |  this_free  |                                                       : 
8f24			;   +2  +-------------+                                                       : 
8f24			;       |  next_free  |                                                       : 
8f24			;   +0  +-------------+                                                       : 
8f24			;       |             |                                                       : 
8f24			;                                                                             : 
8f24			;------------------------------------------------------------------------------ 
8f24			 
8f24			 
8f24			;malloc: 
8f24			; 
8f24			;	SAVESP ON 1 
8f24			; 
8f24			;	call malloc_code 
8f24			; 
8f24			;	CHECKSP ON 1 
8f24			;	ret 
8f24			 
8f24			 
8f24			malloc: 
8f24 c5			      push  BC 
8f25 d5			      push  DE 
8f26 dd e5		      push  IX 
8f28			if DEBUG_FORTH_MALLOC_HIGH 
8f28			call malloc_guard_entry 
8f28			endif 
8f28			 
8f28					if DEBUG_FORTH_MALLOC 
8f28						DMARK "mal" 
8f28						CALLMONITOR 
8f28					endif 
8f28 7c			      ld    A, H                    ; Exit if no space requested 
8f29 b5			      or    L 
8f2a ca e9 8f		      jp    Z, malloc_early_exit 
8f2d			 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			; 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			;inc hl 
8f2d			 
8f2d			 
8f2d			 
8f2d			 
8f2d					if DEBUG_FORTH_MALLOC 
8f2d						DMARK "maA" 
8f2d						CALLMONITOR 
8f2d					endif 
8f2d			      ; Set up stack frame 
8f2d eb			      ex    DE, HL 
8f2e 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f31 39			      add   HL, SP 
8f32 f9			      ld    SP, HL 
8f33 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f37 dd 39		      add   IX, SP 
8f39			 
8f39			      ; Setup initial state 
8f39 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f3c 19			      add   HL, DE 
8f3d			 
8f3d 44			      ld    B, H                    ; Move want to BC 
8f3e 4d			      ld    C, L 
8f3f			 
8f3f 21 94 d6		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f42 dd 75 04		      ld    (IX+4), L 
8f45 dd 74 05		      ld    (IX+5), H 
8f48			 
8f48 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f49 23			      inc   HL 
8f4a 56			      ld    D, (HL) 
8f4b dd 73 02		      ld    (IX+2), E 
8f4e dd 72 03		      ld    (IX+3), D 
8f51 eb			      ex    DE, HL                  ; this_free ptr into HL 
8f52			 
8f52					if DEBUG_FORTH_MALLOC 
8f52						DMARK "maB" 
8f52						CALLMONITOR 
8f52					endif 
8f52			      ; Loop through free block list to find some space 
8f52			malloc_find_space: 
8f52 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f53 23			      inc   HL 
8f54 56			      ld    D, (HL) 
8f55			 
8f55 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8f56 b3			      or    E 
8f57 ca e3 8f		      jp    Z, malloc_no_space 
8f5a			 
8f5a dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8f5d dd 72 01		      ld    (IX+1), D 
8f60			 
8f60			      ; Does this block have enough space to make the allocation? 
8f60 23			      inc   HL                      ; Load free block size into DE 
8f61 5e			      ld    E, (HL) 
8f62 23			      inc   HL 
8f63 56			      ld    D, (HL) 
8f64			 
8f64 eb			      ex    DE, HL                  ; Check size of block against want 
8f65 b7			      or    A                       ; Ensure carry flag clear 
8f66 ed 42		      sbc   HL, BC 
8f68 e5			      push  HL                      ; Store the result for later (new block size) 
8f69			 
8f69 ca b8 8f		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8f6c 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8f6e			 
8f6e			      ; this_free block is not big enough, setup ptrs to test next free block 
8f6e e1			      pop   HL                      ; Discard previous result 
8f6f			 
8f6f dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8f72 dd 66 03		      ld    H, (IX+3) 
8f75 dd 75 04		      ld    (IX+4), L 
8f78 dd 74 05		      ld    (IX+5), H 
8f7b			 
8f7b dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8f7e dd 66 01		      ld    H, (IX+1) 
8f81 dd 75 02		      ld    (IX+2), L 
8f84 dd 74 03		      ld    (IX+3), H 
8f87			 
8f87					if DEBUG_FORTH_MALLOC 
8f87						DMARK "MA>" 
8f87						CALLMONITOR 
8f87					endif 
8f87 18 c9		      jr    malloc_find_space 
8f89			 
8f89			      ; split a bigger block into two - requested size and remaining size 
8f89			malloc_alloc_split: 
8f89					if DEBUG_FORTH_MALLOC 
8f89						DMARK "MAs" 
8f89						CALLMONITOR 
8f89					endif 
8f89 eb			      ex    DE, HL                  ; Calculate address of new free block 
8f8a 2b			      dec   HL 
8f8b 2b			      dec   HL 
8f8c 2b			      dec   HL 
8f8d 09			      add   HL, BC 
8f8e			 
8f8e			      ; Create a new block and point it at next_free 
8f8e dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8f91 dd 56 01		      ld    D, (IX+1) 
8f94			 
8f94 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8f95 23			      inc   HL 
8f96 72			      ld    (HL), D 
8f97			 
8f97 d1			      pop   DE                      ; Store size of new block into new block 
8f98 23			      inc   HL 
8f99 73			      ld    (HL), E 
8f9a 23			      inc   HL 
8f9b 72			      ld    (HL), D 
8f9c			 
8f9c			      ; Update this_free ptr to point to new block 
8f9c 2b			      dec   HL 
8f9d 2b			      dec   HL 
8f9e 2b			      dec   HL 
8f9f			 
8f9f dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fa2 dd 56 03		      ld    D, (IX+3) 
8fa5			 
8fa5 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8fa8 dd 74 03		      ld    (IX+3), H 
8fab			 
8fab			      ; Modify this_free block to be allocation 
8fab eb			      ex    DE, HL 
8fac af			      xor   A                       ; Null the next block ptr of allocated block 
8fad 77			      ld    (HL), A 
8fae 23			      inc   HL 
8faf 77			      ld    (HL), A 
8fb0			 
8fb0 23			      inc   HL                      ; Store want size into allocated block 
8fb1 71			      ld    (HL), C 
8fb2 23			      inc   HL 
8fb3 70			      ld    (HL), B 
8fb4 23			      inc   HL 
8fb5 e5			      push  HL                      ; Address of allocation to return 
8fb6			 
8fb6 18 19		      jr    malloc_update_links 
8fb8			 
8fb8			malloc_alloc_fit: 
8fb8 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
8fb9			 
8fb9					if DEBUG_FORTH_MALLOC 
8fb9						DMARK "MAf" 
8fb9						CALLMONITOR 
8fb9					endif 
8fb9			      ; Modify this_free block to be allocation 
8fb9 eb			      ex    DE, HL 
8fba 2b			      dec   HL 
8fbb 2b			      dec   HL 
8fbc 2b			      dec   HL 
8fbd			 
8fbd af			      xor   A                       ; Null the next block ptr of allocated block 
8fbe 77			      ld    (HL), A 
8fbf 23			      inc   HL 
8fc0 77			      ld    (HL), A 
8fc1			 
8fc1 23			      inc   HL                      ; Store address of allocation to return 
8fc2 23			      inc   HL 
8fc3 23			      inc   HL 
8fc4 e5			      push  HL 
8fc5			 
8fc5			      ; Copy next_free ptr to this_free, remove allocated block from free list 
8fc5 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
8fc8 dd 66 01		      ld    H, (IX+1) 
8fcb			 
8fcb dd 75 02		      ld    (IX+2), L               ; HL to this_free 
8fce dd 74 03		      ld    (IX+3), H 
8fd1			 
8fd1			 
8fd1			malloc_update_links: 
8fd1			      ; Update prev_free ptr to point to this_free 
8fd1 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
8fd4 dd 66 05		      ld    H, (IX+5) 
8fd7			 
8fd7 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
8fda dd 56 03		      ld    D, (IX+3) 
8fdd			 
8fdd 73			      ld    (HL), E                 ; this_free ptr into prev_free 
8fde 23			      inc   HL 
8fdf 72			      ld    (HL), D 
8fe0			 
8fe0					if DEBUG_FORTH_MALLOC 
8fe0						DMARK "Mul" 
8fe0						CALLMONITOR 
8fe0					endif 
8fe0			      ; Clear the Z flag to indicate successful allocation 
8fe0 7a			      ld    A, D 
8fe1 b3			      or    E 
8fe2			 
8fe2 d1			      pop   DE                      ; Address of allocation 
8fe3					if DEBUG_FORTH_MALLOC 
8fe3						DMARK "MAu" 
8fe3						CALLMONITOR 
8fe3					endif 
8fe3			 
8fe3			malloc_no_space: 
8fe3 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
8fe6 39			      add   HL, SP 
8fe7 f9			      ld    SP, HL 
8fe8			 
8fe8 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
8fe9					if DEBUG_FORTH_MALLOC 
8fe9						DMARK "MAN" 
8fe9						CALLMONITOR 
8fe9					endif 
8fe9			 
8fe9			malloc_early_exit: 
8fe9					if DEBUG_FORTH_MALLOC 
8fe9						DMARK "MAx" 
8fe9						CALLMONITOR 
8fe9					endif 
8fe9 dd e1		      pop   IX 
8feb d1			      pop   DE 
8fec c1			      pop   BC 
8fed			 
8fed			if DEBUG_FORTH_MALLOC_HIGH 
8fed			call malloc_guard_exit 
8fed			call malloc_guard_zerolen 
8fed			endif 
8fed c9			      ret 
8fee			 
8fee			 
8fee			;------------------------------------------------------------------------------ 
8fee			;     free                                                                    : 
8fee			;                                                                             : 
8fee			; Description                                                                 : 
8fee			;     Return the space pointed to by HL to the heap. HL must be an address as : 
8fee			;     returned by malloc, otherwise the behaviour is undefined.               : 
8fee			;                                                                             : 
8fee			;     Where possible, directly adjacent free blocks will be merged together   : 
8fee			;     into larger blocks to help ensure that the heap does not become         : 
8fee			;     excessively fragmented.                                                 : 
8fee			;                                                                             : 
8fee			;     free does not clear or set any other value into the freed space, and    : 
8fee			;     therefore its contents may be visible through subsequent malloc's. The  : 
8fee			;     caller should clear the freed space as required.                        : 
8fee			;                                                                             : 
8fee			;     This implementation of free uses the stack exclusively, and is          : 
8fee			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8fee			;     advisable to disable interrupts before calling free, and recommended    : 
8fee			;     to avoid the use of free inside ISRs in general.                        : 
8fee			;                                                                             : 
8fee			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8fee			;                                                                             : 
8fee			; Parameters                                                                  : 
8fee			;     HL  Pointer to address of first byte of allocation to be freed          : 
8fee			;                                                                             : 
8fee			; Returns                                                                     : 
8fee			;     Nothing                                                                 : 
8fee			;                                                                             : 
8fee			; Stack frame                                                                 : 
8fee			;       |             |                                                       : 
8fee			;       +-------------+                                                       : 
8fee			;       |     BC      |                                                       : 
8fee			;       +-------------+                                                       : 
8fee			;       |     DE      |                                                       : 
8fee			;       +-------------+                                                       : 
8fee			;       |     IX      |                                                       : 
8fee			;       +-------------+                                                       : 
8fee			;       |  prev_free  |                                                       : 
8fee			;   +2  +-------------+                                                       : 
8fee			;       |  next_free  |                                                       : 
8fee			;   +0  +-------------+                                                       : 
8fee			;       |             |                                                       : 
8fee			;                                                                             : 
8fee			;------------------------------------------------------------------------------ 
8fee			free: 
8fee c5			      push  BC 
8fef d5			      push  DE 
8ff0 dd e5		      push  IX 
8ff2			 
8ff2 7c			      ld    A, H                    ; Exit if ptr is null 
8ff3 b5			      or    L 
8ff4 ca b8 90		      jp    Z, free_early_exit 
8ff7			 
8ff7			      ; Set up stack frame 
8ff7 eb			      ex    DE, HL 
8ff8 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
8ffb 39			      add   HL, SP 
8ffc f9			      ld    SP, HL 
8ffd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9001 dd 39		      add   IX, SP 
9003			 
9003			      ; The address in HL points to the start of the useable allocated space, 
9003			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9003			      ; address of the block itself. 
9003 eb			      ex    DE, HL 
9004 11 fc ff		      ld    DE, -4 
9007 19			      add   HL, DE 
9008			 
9008			      ; An allocated block must have a null next block pointer in it 
9008 7e			      ld    A, (HL) 
9009 23			      inc   HL 
900a b6			      or    (HL) 
900b c2 b3 90		      jp    NZ, free_done 
900e			 
900e 2b			      dec   HL 
900f			 
900f 44			      ld    B, H                    ; Copy HL to BC 
9010 4d			      ld    C, L 
9011			 
9011			      ; Loop through the free list to find the first block with an address 
9011			      ; higher than the block being freed 
9011 21 94 d6		      ld    HL, free_list 
9014			 
9014			free_find_higher_block: 
9014 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9015 23			      inc   HL 
9016 56			      ld    D, (HL) 
9017 2b			      dec   HL 
9018			 
9018 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
901b dd 72 01		      ld    (IX+1), D 
901e dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9021 dd 74 03		      ld    (IX+3), H 
9024			 
9024 78			      ld    A, B                    ; Check if DE is greater than BC 
9025 ba			      cp    D                       ; Compare MSB first 
9026 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9028 30 04		      jr    NC, free_find_higher_block_skip 
902a 79			      ld    A, C 
902b bb			      cp    E                       ; Then compare LSB 
902c 38 08		      jr    C, free_found_higher_block 
902e			 
902e			free_find_higher_block_skip: 
902e 7a			      ld    A, D                    ; Reached the end of the free list? 
902f b3			      or    E 
9030 ca b3 90		      jp    Z, free_done 
9033			 
9033 eb			      ex    DE, HL 
9034			 
9034 18 de		      jr    free_find_higher_block 
9036			 
9036			free_found_higher_block: 
9036			      ; Insert freed block between prev and next free blocks 
9036 71			      ld    (HL), C                 ; Point prev free block to freed block 
9037 23			      inc   HL 
9038 70			      ld    (HL), B 
9039			 
9039 60			      ld    H, B                    ; Point freed block at next free block 
903a 69			      ld    L, C 
903b 73			      ld    (HL), E 
903c 23			      inc   HL 
903d 72			      ld    (HL), D 
903e			 
903e			      ; Check if the freed block is adjacent to the next free block 
903e 23			      inc   HL                      ; Load size of freed block into HL 
903f 5e			      ld    E, (HL) 
9040 23			      inc   HL 
9041 56			      ld    D, (HL) 
9042 eb			      ex    DE, HL 
9043			 
9043 09			      add   HL, BC                  ; Add addr of freed block and its size 
9044			 
9044 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9047 dd 56 01		      ld    D, (IX+1) 
904a			 
904a b7			      or    A                       ; Clear the carry flag 
904b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
904d 20 22		      jr    NZ, free_check_adjacent_to_prev 
904f			 
904f			      ; Freed block is adjacent to next, merge into one bigger block 
904f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9050 5e			      ld    E, (HL) 
9051 23			      inc   HL 
9052 56			      ld    D, (HL) 
9053 e5			      push  HL                      ; Save ptr to next block for later 
9054			 
9054 60			      ld    H, B                    ; Store ptr from next block into freed block 
9055 69			      ld    L, C 
9056 73			      ld    (HL), E 
9057 23			      inc   HL 
9058 72			      ld    (HL), D 
9059			 
9059 e1			      pop   HL                      ; Restore ptr to next block 
905a 23			      inc   HL                      ; Load size of next block into DE 
905b 5e			      ld    E, (HL) 
905c 23			      inc   HL 
905d 56			      ld    D, (HL) 
905e d5			      push  DE                      ; Save next block size for later 
905f			 
905f 60			      ld    H, B                    ; Load size of freed block into HL 
9060 69			      ld    L, C 
9061 23			      inc   HL 
9062 23			      inc   HL 
9063 5e			      ld    E, (HL) 
9064 23			      inc   HL 
9065 56			      ld    D, (HL) 
9066 eb			      ex    DE, HL 
9067			 
9067 d1			      pop   DE                      ; Restore size of next block 
9068 19			      add   HL, DE                  ; Add sizes of both blocks 
9069 eb			      ex    DE, HL 
906a			 
906a 60			      ld    H, B                    ; Store new bigger size into freed block 
906b 69			      ld    L, C 
906c 23			      inc   HL 
906d 23			      inc   HL 
906e 73			      ld    (HL), E 
906f 23			      inc   HL 
9070 72			      ld    (HL), D 
9071			 
9071			free_check_adjacent_to_prev: 
9071			      ; Check if the freed block is adjacent to the prev free block 
9071 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9074 dd 66 03		      ld    H, (IX+3) 
9077			 
9077 23			      inc   HL                      ; Size of prev free block into DE 
9078 23			      inc   HL 
9079 5e			      ld    E, (HL) 
907a 23			      inc   HL 
907b 56			      ld    D, (HL) 
907c 2b			      dec   HL 
907d 2b			      dec   HL 
907e 2b			      dec   HL 
907f			 
907f 19			      add   HL, DE                  ; Add prev block addr and size 
9080			 
9080 b7			      or    A                       ; Clear the carry flag 
9081 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9083 20 2e		      jr    NZ, free_done 
9085			 
9085			      ; Freed block is adjacent to prev, merge into one bigger block 
9085 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9086 69			      ld    L, C 
9087 5e			      ld    E, (HL) 
9088 23			      inc   HL 
9089 56			      ld    D, (HL) 
908a e5			      push  HL                      ; Save freed block ptr for later 
908b			 
908b dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
908e dd 66 03		      ld    H, (IX+3) 
9091 73			      ld    (HL), E 
9092 23			      inc   HL 
9093 72			      ld    (HL), D 
9094			 
9094 e1			      pop   HL                      ; Restore freed block ptr 
9095 23			      inc   HL                      ; Load size of freed block into DE 
9096 5e			      ld    E, (HL) 
9097 23			      inc   HL 
9098 56			      ld    D, (HL) 
9099 d5			      push  DE                      ; Save freed block size for later 
909a			 
909a dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
909d dd 66 03		      ld    H, (IX+3) 
90a0 23			      inc   HL 
90a1 23			      inc   HL 
90a2 5e			      ld    E, (HL) 
90a3 23			      inc   HL 
90a4 56			      ld    D, (HL) 
90a5			 
90a5 e1			      pop   HL                      ; Add sizes of both blocks 
90a6 19			      add   HL, DE 
90a7 eb			      ex    DE, HL 
90a8			 
90a8 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90ab dd 66 03		      ld    H, (IX+3) 
90ae 23			      inc   HL 
90af 23			      inc   HL 
90b0 73			      ld    (HL), E 
90b1 23			      inc   HL 
90b2 72			      ld    (HL), D 
90b3			 
90b3			free_done: 
90b3 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
90b6 39			      add   HL, SP 
90b7 f9			      ld    SP, HL 
90b8			 
90b8			free_early_exit: 
90b8 dd e1		      pop   IX 
90ba d1			      pop   DE 
90bb c1			      pop   BC 
90bc			 
90bc c9			      ret 
90bd			 
90bd			; moved to firmware.asm 
90bd			; 
90bd			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
90bd			;                  .dw   0 
90bd			 
90bd			 
90bd			endif 
90bd			 
90bd			 
90bd			if MALLOC_3 
90bd			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
90bd			;heap_start        .equ  0x9000      ; Starting address of heap 
90bd			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
90bd			; 
90bd			 ;     .org 0 
90bd			  ;    jp    main 
90bd			; 
90bd			; 
90bd			 ;     .org  0x100 
90bd			;main: 
90bd			 ;     ld    HL, 0x8100 
90bd			  ;    ld    SP, HL 
90bd			; 
90bd			;      call  heap_init 
90bd			 
90bd			      ; Make some allocations 
90bd			;      ld    HL, 12 
90bd			;      call  malloc            ; Allocates 0x9004 
90bd			; 
90bd			 ;     ld    HL, 12 
90bd			;      call  malloc            ; Allocates 0x9014 
90bd			 
90bd			;      ld    HL, 12 
90bd			;      call  malloc            ; Allocates 0x9024 
90bd			 
90bd			      ; Free some allocations 
90bd			;      ld    HL, 0x9014 
90bd			;      call  free 
90bd			 
90bd			;      ld    HL, 0x9004 
90bd			;      call  free 
90bd			; 
90bd			;      ld    HL, 0x9024 
90bd			;      call  free 
90bd			 
90bd			 
90bd			 ;     halt 
90bd			 
90bd			 
90bd			;------------------------------------------------------------------------------ 
90bd			;     heap_init                                                               : 
90bd			;                                                                             : 
90bd			; Description                                                                 : 
90bd			;     Initialise the heap and make it ready for malloc and free operations.   : 
90bd			;                                                                             : 
90bd			;     The heap is maintained as a linked list, starting with an initial       : 
90bd			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
90bd			;     the first free block in the heap. Each block then points to the next    : 
90bd			;     free block within the heap, and the free list ends at the first block   : 
90bd			;     with a null pointer to the next free block.                             : 
90bd			;                                                                             : 
90bd			; Parameters                                                                  : 
90bd			;     Inputs are compile-time only. Two defines which specify the starting    : 
90bd			;     address of the heap and its size are required, along with a memory      : 
90bd			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
90bd			;     principally stores a pointer to the first free block in the heap.       : 
90bd			;                                                                             : 
90bd			; Returns                                                                     : 
90bd			;     Nothing                                                                 : 
90bd			;------------------------------------------------------------------------------ 
90bd			heap_init: 
90bd			      push  HL 
90bd			 
90bd			      ; Initialise free list struct 
90bd			      ld    HL, heap_start 
90bd			      ld    (free_list), HL 
90bd			      ld    HL, 0 
90bd			      ld    (free_list+2), HL 
90bd			 
90bd			      ; Insert first free block at bottom of heap, consumes entire heap 
90bd			      ld    HL, heap_start+heap_size-4 
90bd			      ld    (heap_start), HL        ; Next block (end of free list) 
90bd			      ld    HL, heap_size-4 
90bd			      ld    (heap_start+2), HL      ; Block size 
90bd			 
90bd			      ; Insert end of free list block at top of heap - two null words will 
90bd			      ; terminate the free list 
90bd			      ld    HL, 0 
90bd			      ld    (heap_start+heap_size-2), HL 
90bd			      ld    (heap_start+heap_size-4), HL 
90bd			 
90bd			      pop   HL 
90bd			 
90bd			      ret 
90bd			 
90bd			 
90bd			;------------------------------------------------------------------------------ 
90bd			;     malloc                                                                  : 
90bd			;                                                                             : 
90bd			; Description                                                                 : 
90bd			;     Allocates the wanted space from the heap and returns the address of the : 
90bd			;     first useable byte of the allocation.                                   : 
90bd			;                                                                             : 
90bd			;     Allocations can happen in one of two ways:                              : 
90bd			;                                                                             : 
90bd			;     1. A free block may be found which is the exact size wanted. In this    : 
90bd			;        case the block is removed from the free list and retuedn to the      : 
90bd			;        caller.                                                              : 
90bd			;     2. A free block may be found which is larger than the size wanted. In   : 
90bd			;        this case, the larger block is split into two. The first portion of  : 
90bd			;        this block will become the requested space by the malloc call and    : 
90bd			;        is returned to the caller. The second portion becomes a new free     : 
90bd			;        block, and the free list is adjusted to maintain continuity via this : 
90bd			;        newly created block.                                                 : 
90bd			;                                                                             : 
90bd			;     malloc does not set any initial value in the allocated space, the       : 
90bd			;     caller is required to do this as required.                              : 
90bd			;                                                                             : 
90bd			;     This implementation of malloc uses the stack exclusively, and is        : 
90bd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90bd			;     advisable to disable interrupts before calling malloc, and recommended  : 
90bd			;     to avoid the use of malloc inside ISRs in general.                      : 
90bd			;                                                                             : 
90bd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90bd			;                                                                             : 
90bd			; Parameters                                                                  : 
90bd			;     HL  Number of bytes wanted                                              : 
90bd			;                                                                             : 
90bd			; Returns                                                                     : 
90bd			;     HL  Address of the first useable byte of the allocation                 : 
90bd			;                                                                             : 
90bd			; Flags                                                                       : 
90bd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90bd			;                                                                             : 
90bd			; Stack frame                                                                 : 
90bd			;       |             |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |     BC      |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |     DE      |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |     IX      |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |  prev_free  |                                                       : 
90bd			;   +4  +-------------+                                                       : 
90bd			;       |  this_free  |                                                       : 
90bd			;   +2  +-------------+                                                       : 
90bd			;       |  next_free  |                                                       : 
90bd			;   +0  +-------------+                                                       : 
90bd			;       |             |                                                       : 
90bd			;                                                                             : 
90bd			;------------------------------------------------------------------------------ 
90bd			malloc: 
90bd			      push  BC 
90bd			      push  DE 
90bd			      push  IX 
90bd			 
90bd			      ld    A, H                    ; Exit if no space requested 
90bd			      or    L 
90bd			      jp    Z, malloc_early_exit 
90bd			 
90bd			      ; Set up stack frame 
90bd			      ex    DE, HL 
90bd			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90bd			      add   HL, SP 
90bd			      ld    SP, HL 
90bd			      ld    IX, 0                   ; Use IX as a frame pointer 
90bd			      add   IX, SP 
90bd			 
90bd			      ; Setup initial state 
90bd			      ld    HL, 4                   ; want must also include space used by block struct 
90bd			      add   HL, DE 
90bd			 
90bd			      ld    B, H                    ; Move want to BC 
90bd			      ld    C, L 
90bd			 
90bd			      ld    HL, free_list           ; Store prev_free ptr to stack 
90bd			      ld    (IX+4), L 
90bd			      ld    (IX+5), H 
90bd			 
90bd			      ld    E, (HL)                 ; Store this_free ptr to stack 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      ld    (IX+2), E 
90bd			      ld    (IX+3), D 
90bd			      ex    DE, HL                  ; this_free ptr into HL 
90bd			 
90bd			      ; Loop through free block list to find some space 
90bd			malloc_find_space: 
90bd			      ld    E, (HL)                 ; Load next_free ptr into DE 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			 
90bd			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90bd			      or    E 
90bd			      jp    Z, malloc_no_space 
90bd			 
90bd			      ld    (IX+0), E               ; Store next_free ptr to stack 
90bd			      ld    (IX+1), D 
90bd			 
90bd			      ; Does this block have enough space to make the allocation? 
90bd			      inc   HL                      ; Load free block size into DE 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			 
90bd			      ex    DE, HL                  ; Check size of block against want 
90bd			      or    A                       ; Ensure carry flag clear 
90bd			      sbc   HL, BC 
90bd			      push  HL                      ; Store the result for later (new block size) 
90bd			 
90bd			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90bd			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
90bd			 
90bd			      ; this_free block is not big enough, setup ptrs to test next free block 
90bd			      pop   HL                      ; Discard previous result 
90bd			 
90bd			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
90bd			      ld    H, (IX+3) 
90bd			      ld    (IX+4), L 
90bd			      ld    (IX+5), H 
90bd			 
90bd			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
90bd			      ld    H, (IX+1) 
90bd			      ld    (IX+2), L 
90bd			      ld    (IX+3), H 
90bd			 
90bd			      jr    malloc_find_space 
90bd			 
90bd			      ; split a bigger block into two - requested size and remaining size 
90bd			malloc_alloc_split: 
90bd			      ex    DE, HL                  ; Calculate address of new free block 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			      add   HL, BC 
90bd			 
90bd			      ; Create a new block and point it at next_free 
90bd			      ld    E, (IX+0)               ; Load next_free ptr into DE 
90bd			      ld    D, (IX+1) 
90bd			 
90bd			      ld    (HL), E                 ; Store next_free ptr into new block 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			      pop   DE                      ; Store size of new block into new block 
90bd			      inc   HL 
90bd			      ld    (HL), E 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			      ; Update this_free ptr to point to new block 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			 
90bd			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
90bd			      ld    D, (IX+3) 
90bd			 
90bd			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
90bd			      ld    (IX+3), H 
90bd			 
90bd			      ; Modify this_free block to be allocation 
90bd			      ex    DE, HL 
90bd			      xor   A                       ; Null the next block ptr of allocated block 
90bd			      ld    (HL), A 
90bd			      inc   HL 
90bd			      ld    (HL), A 
90bd			 
90bd			      inc   HL                      ; Store want size into allocated block 
90bd			      ld    (HL), C 
90bd			      inc   HL 
90bd			      ld    (HL), B 
90bd			      inc   HL 
90bd			      push  HL                      ; Address of allocation to return 
90bd			 
90bd			      jr    malloc_update_links 
90bd			 
90bd			malloc_alloc_fit: 
90bd			      pop   HL                      ; Dont need new block size, want is exact fit 
90bd			 
90bd			      ; Modify this_free block to be allocation 
90bd			      ex    DE, HL 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			 
90bd			      xor   A                       ; Null the next block ptr of allocated block 
90bd			      ld    (HL), A 
90bd			      inc   HL 
90bd			      ld    (HL), A 
90bd			 
90bd			      inc   HL                      ; Store address of allocation to return 
90bd			      inc   HL 
90bd			      inc   HL 
90bd			      push  HL 
90bd			 
90bd			      ; Copy next_free ptr to this_free, remove allocated block from free list 
90bd			      ld    L, (IX+0)               ; next_free to HL 
90bd			      ld    H, (IX+1) 
90bd			 
90bd			      ld    (IX+2), L               ; HL to this_free 
90bd			      ld    (IX+3), H 
90bd			 
90bd			 
90bd			malloc_update_links: 
90bd			      ; Update prev_free ptr to point to this_free 
90bd			      ld    L, (IX+4)               ; prev_free ptr to HL 
90bd			      ld    H, (IX+5) 
90bd			 
90bd			      ld    E, (IX+2)               ; this_free ptr to DE 
90bd			      ld    D, (IX+3) 
90bd			 
90bd			      ld    (HL), E                 ; this_free ptr into prev_free 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			      ; Clear the Z flag to indicate successful allocation 
90bd			      ld    A, D 
90bd			      or    E 
90bd			 
90bd			      pop   DE                      ; Address of allocation 
90bd			 
90bd			malloc_no_space: 
90bd			      ld    HL, 6                   ; Clean up stack frame 
90bd			      add   HL, SP 
90bd			      ld    SP, HL 
90bd			 
90bd			      ex    DE, HL                  ; Alloc addr into HL for return 
90bd			 
90bd			malloc_early_exit: 
90bd			      pop   IX 
90bd			      pop   DE 
90bd			      pop   BC 
90bd			 
90bd			      ret 
90bd			 
90bd			 
90bd			;------------------------------------------------------------------------------ 
90bd			;     free                                                                    : 
90bd			;                                                                             : 
90bd			; Description                                                                 : 
90bd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
90bd			;     returned by malloc, otherwise the behaviour is undefined.               : 
90bd			;                                                                             : 
90bd			;     Where possible, directly adjacent free blocks will be merged together   : 
90bd			;     into larger blocks to help ensure that the heap does not become         : 
90bd			;     excessively fragmented.                                                 : 
90bd			;                                                                             : 
90bd			;     free does not clear or set any other value into the freed space, and    : 
90bd			;     therefore its contents may be visible through subsequent malloc's. The  : 
90bd			;     caller should clear the freed space as required.                        : 
90bd			;                                                                             : 
90bd			;     This implementation of free uses the stack exclusively, and is          : 
90bd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90bd			;     advisable to disable interrupts before calling free, and recommended    : 
90bd			;     to avoid the use of free inside ISRs in general.                        : 
90bd			;                                                                             : 
90bd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90bd			;                                                                             : 
90bd			; Parameters                                                                  : 
90bd			;     HL  Pointer to address of first byte of allocation to be freed          : 
90bd			;                                                                             : 
90bd			; Returns                                                                     : 
90bd			;     Nothing                                                                 : 
90bd			;                                                                             : 
90bd			; Stack frame                                                                 : 
90bd			;       |             |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |     BC      |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |     DE      |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |     IX      |                                                       : 
90bd			;       +-------------+                                                       : 
90bd			;       |  prev_free  |                                                       : 
90bd			;   +2  +-------------+                                                       : 
90bd			;       |  next_free  |                                                       : 
90bd			;   +0  +-------------+                                                       : 
90bd			;       |             |                                                       : 
90bd			;                                                                             : 
90bd			;------------------------------------------------------------------------------ 
90bd			free: 
90bd			      push  BC 
90bd			      push  DE 
90bd			      push  IX 
90bd			 
90bd			      ld    A, H                    ; Exit if ptr is null 
90bd			      or    L 
90bd			      jp    Z, free_early_exit 
90bd			 
90bd			      ; Set up stack frame 
90bd			      ex    DE, HL 
90bd			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
90bd			      add   HL, SP 
90bd			      ld    SP, HL 
90bd			      ld    IX, 0                   ; Use IX as a frame pointer 
90bd			      add   IX, SP 
90bd			 
90bd			      ; The address in HL points to the start of the useable allocated space, 
90bd			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
90bd			      ; address of the block itself. 
90bd			      ex    DE, HL 
90bd			      ld    DE, -4 
90bd			      add   HL, DE 
90bd			 
90bd			      ; An allocated block must have a null next block pointer in it 
90bd			      ld    A, (HL) 
90bd			      inc   HL 
90bd			      or    (HL) 
90bd			      jp    NZ, free_done 
90bd			 
90bd			      dec   HL 
90bd			 
90bd			      ld    B, H                    ; Copy HL to BC 
90bd			      ld    C, L 
90bd			 
90bd			      ; Loop through the free list to find the first block with an address 
90bd			      ; higher than the block being freed 
90bd			      ld    HL, free_list 
90bd			 
90bd			free_find_higher_block: 
90bd			      ld    E, (HL)                 ; Load next ptr from free block 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      dec   HL 
90bd			 
90bd			      ld    (IX+0), E               ; Save ptr to next free block 
90bd			      ld    (IX+1), D 
90bd			      ld    (IX+2), L               ; Save ptr to prev free block 
90bd			      ld    (IX+3), H 
90bd			 
90bd			      ld    A, B                    ; Check if DE is greater than BC 
90bd			      cp    D                       ; Compare MSB first 
90bd			      jr    Z, $+4                  ; MSB the same, compare LSB 
90bd			      jr    NC, free_find_higher_block_skip 
90bd			      ld    A, C 
90bd			      cp    E                       ; Then compare LSB 
90bd			      jr    C, free_found_higher_block 
90bd			 
90bd			free_find_higher_block_skip: 
90bd			      ld    A, D                    ; Reached the end of the free list? 
90bd			      or    E 
90bd			      jp    Z, free_done 
90bd			 
90bd			      ex    DE, HL 
90bd			 
90bd			      jr    free_find_higher_block 
90bd			 
90bd			free_found_higher_block: 
90bd			      ; Insert freed block between prev and next free blocks 
90bd			      ld    (HL), C                 ; Point prev free block to freed block 
90bd			      inc   HL 
90bd			      ld    (HL), B 
90bd			 
90bd			      ld    H, B                    ; Point freed block at next free block 
90bd			      ld    L, C 
90bd			      ld    (HL), E 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			      ; Check if the freed block is adjacent to the next free block 
90bd			      inc   HL                      ; Load size of freed block into HL 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      ex    DE, HL 
90bd			 
90bd			      add   HL, BC                  ; Add addr of freed block and its size 
90bd			 
90bd			      ld    E, (IX+0)               ; Load addr of next free block into DE 
90bd			      ld    D, (IX+1) 
90bd			 
90bd			      or    A                       ; Clear the carry flag 
90bd			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
90bd			      jr    NZ, free_check_adjacent_to_prev 
90bd			 
90bd			      ; Freed block is adjacent to next, merge into one bigger block 
90bd			      ex    DE, HL                  ; Load next ptr from next block into DE 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      push  HL                      ; Save ptr to next block for later 
90bd			 
90bd			      ld    H, B                    ; Store ptr from next block into freed block 
90bd			      ld    L, C 
90bd			      ld    (HL), E 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			      pop   HL                      ; Restore ptr to next block 
90bd			      inc   HL                      ; Load size of next block into DE 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      push  DE                      ; Save next block size for later 
90bd			 
90bd			      ld    H, B                    ; Load size of freed block into HL 
90bd			      ld    L, C 
90bd			      inc   HL 
90bd			      inc   HL 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      ex    DE, HL 
90bd			 
90bd			      pop   DE                      ; Restore size of next block 
90bd			      add   HL, DE                  ; Add sizes of both blocks 
90bd			      ex    DE, HL 
90bd			 
90bd			      ld    H, B                    ; Store new bigger size into freed block 
90bd			      ld    L, C 
90bd			      inc   HL 
90bd			      inc   HL 
90bd			      ld    (HL), E 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			free_check_adjacent_to_prev: 
90bd			      ; Check if the freed block is adjacent to the prev free block 
90bd			      ld    L, (IX+2)               ; Prev free block ptr into HL 
90bd			      ld    H, (IX+3) 
90bd			 
90bd			      inc   HL                      ; Size of prev free block into DE 
90bd			      inc   HL 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			      dec   HL 
90bd			 
90bd			      add   HL, DE                  ; Add prev block addr and size 
90bd			 
90bd			      or    A                       ; Clear the carry flag 
90bd			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90bd			      jr    NZ, free_done 
90bd			 
90bd			      ; Freed block is adjacent to prev, merge into one bigger block 
90bd			      ld    H, B                    ; Load next ptr from freed block into DE 
90bd			      ld    L, C 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      push  HL                      ; Save freed block ptr for later 
90bd			 
90bd			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90bd			      ld    H, (IX+3) 
90bd			      ld    (HL), E 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			      pop   HL                      ; Restore freed block ptr 
90bd			      inc   HL                      ; Load size of freed block into DE 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			      push  DE                      ; Save freed block size for later 
90bd			 
90bd			      ld    L, (IX+2)               ; Load size of prev block into DE 
90bd			      ld    H, (IX+3) 
90bd			      inc   HL 
90bd			      inc   HL 
90bd			      ld    E, (HL) 
90bd			      inc   HL 
90bd			      ld    D, (HL) 
90bd			 
90bd			      pop   HL                      ; Add sizes of both blocks 
90bd			      add   HL, DE 
90bd			      ex    DE, HL 
90bd			 
90bd			      ld    L, (IX+2)               ; Store new bigger size into prev block 
90bd			      ld    H, (IX+3) 
90bd			      inc   HL 
90bd			      inc   HL 
90bd			      ld    (HL), E 
90bd			      inc   HL 
90bd			      ld    (HL), D 
90bd			 
90bd			free_done: 
90bd			      ld    HL, 4                   ; Clean up stack frame 
90bd			      add   HL, SP 
90bd			      ld    SP, HL 
90bd			 
90bd			free_early_exit: 
90bd			      pop   IX 
90bd			      pop   DE 
90bd			      pop   BC 
90bd			 
90bd			      ret 
90bd			 
90bd			 
90bd			;      .org 0x8000 
90bd			; 
90bd			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
90bd			 ;                 .dw   0 
90bd			 
90bd			endif 
90bd			 
90bd			 
90bd			if MALLOC_4 
90bd			 
90bd			; My memory allocation code. Very very simple.... 
90bd			; allocate space under 250 chars 
90bd			 
90bd			heap_init: 
90bd				; init start of heap as zero 
90bd				;  
90bd			 
90bd				ld hl, heap_start 
90bd				ld a, 0 
90bd				ld (hl), a      ; empty block 
90bd				inc hl 
90bd				ld a, 0 
90bd				ld (hl), a      ; length of block 
90bd				; write end of list 
90bd				inc hl 
90bd				ld a,(hl) 
90bd				inc hl 
90bd				ld a,(hl) 
90bd				 
90bd			 
90bd				; init some malloc vars 
90bd			 
90bd				ld hl, 0 
90bd				ld (free_list), hl       ; store last malloc location 
90bd			 
90bd				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
90bd				ld a, 0 
90bd				ld (hl), a 
90bd			 
90bd			 
90bd				ld hl, heap_start 
90bd				;  
90bd				  
90bd				ret 
90bd			 
90bd			 
90bd			;    free block marker 
90bd			;    requested size  
90bd			;    pointer to next block 
90bd			;    .... 
90bd			;    next block marker 
90bd			 
90bd			 
90bd			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
90bd			; 
90bd			 
90bd			 
90bd			malloc:  
90bd				push de 
90bd				push bc 
90bd				push af 
90bd			 
90bd				; hl space required 
90bd				 
90bd				ld c, l    ; hold space   (TODO only a max of 255) 
90bd			 
90bd			;	inc c     ; TODO BUG need to fix memory leak on push str 
90bd			;	inc c 
90bd			;	inc c 
90bd			;	inc c 
90bd			;	inc c 
90bd			;	inc c 
90bd			;	inc c 
90bd			 
90bd			 
90bd			 
90bd				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
90bd			 
90bd				ld a, (free_list+3) 
90bd				cp 0 
90bd				jr z, .contheap 
90bd			 
90bd				ld hl, (free_list)     ; get last alloc 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "mrs" 
90bd						CALLMONITOR 
90bd					endif 
90bd				jr .startalloc 
90bd			 
90bd			.contheap: 
90bd				ld hl, heap_start 
90bd			 
90bd			.startalloc: 
90bd			 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "mym" 
90bd						CALLMONITOR 
90bd					endif 
90bd			.findblock: 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "mmf" 
90bd						CALLMONITOR 
90bd					endif 
90bd			 
90bd				ld a,(hl)  
90bd				; if byte is zero then clear to use 
90bd			 
90bd				cp 0 
90bd				jr z, .foundemptyblock 
90bd			 
90bd				; if byte is not clear 
90bd				;     then byte is offset to next block 
90bd			 
90bd				inc hl 
90bd				ld a, (hl) ; get size 
90bd			.nextblock:	inc hl 
90bd					ld e, (hl) 
90bd					inc hl 
90bd					ld d, (hl) 
90bd					ex de, hl 
90bd			;	inc hl  ; move past the store space 
90bd			;	inc hl  ; move past zero index  
90bd			 
90bd				; TODO detect no more space 
90bd			 
90bd				push hl 
90bd				ld de, heap_end 
90bd				call cmp16 
90bd				pop hl 
90bd				jr nc, .nospace 
90bd			 
90bd				jr .findblock 
90bd			 
90bd			.nospace: ld hl, 0 
90bd				jp .exit 
90bd			 
90bd			 
90bd			.foundemptyblock:	 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "mme" 
90bd						CALLMONITOR 
90bd					endif 
90bd			 
90bd			; TODO has block enough space if reusing??? 
90bd			 
90bd				;  
90bd			 
90bd			; see if this block has been previously used 
90bd				inc hl 
90bd				ld a, (hl) 
90bd				dec hl 
90bd				cp 0 
90bd				jr z, .newblock 
90bd			 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "meR" 
90bd						CALLMONITOR 
90bd					endif 
90bd			 
90bd			; no reusing previously allocated block 
90bd			 
90bd			; is it smaller than previously used? 
90bd				 
90bd				inc hl    ; move to size 
90bd				ld a, c 
90bd				sub (hl)        ; we want c < (hl) 
90bd				dec hl    ; move back to marker 
90bd			        jr z, .findblock 
90bd			 
90bd				; update with the new size which should be lower 
90bd			 
90bd			        ;inc  hl   ; negate next move. move back to size  
90bd			 
90bd			.newblock: 
90bd				; need to be at marker here 
90bd			 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "meN" 
90bd						CALLMONITOR 
90bd					endif 
90bd			 
90bd			 
90bd				ld a, c 
90bd			 
90bd				ld (free_list+3), a	 ; flag resume from last malloc  
90bd				ld (free_list), hl    ; save out last location 
90bd			 
90bd			 
90bd				;inc a     ; space for length byte 
90bd				ld (hl), a     ; save block in use marker 
90bd			 
90bd				inc hl   ; move to space marker 
90bd				ld (hl), a    ; save new space 
90bd			 
90bd				inc hl   ; move to start of allocated area 
90bd				 
90bd			;	push hl     ; save where we are - 1  
90bd			 
90bd			;	inc hl  ; move past zero index  
90bd				; skip space to set down new marker 
90bd			 
90bd				; provide some extra space for now 
90bd			 
90bd				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
90bd				inc a 
90bd				inc a 
90bd			 
90bd				push hl   ; save where we are in the node block 
90bd			 
90bd				call addatohl 
90bd			 
90bd				; write linked list point 
90bd			 
90bd				pop de     ; get our node position 
90bd				ex de, hl 
90bd			 
90bd				ld (hl), e 
90bd				inc hl 
90bd				ld (hl), d 
90bd			 
90bd				inc hl 
90bd			 
90bd				; now at start of allocated data so save pointer 
90bd			 
90bd				push hl 
90bd			 
90bd				; jump to position of next node and setup empty header in DE 
90bd			 
90bd				ex de, hl 
90bd			 
90bd			;	inc hl ; move past end of block 
90bd			 
90bd				ld a, 0 
90bd				ld (hl), a   ; empty marker 
90bd				inc hl 
90bd				ld (hl), a   ; size 
90bd				inc hl  
90bd				ld (hl), a   ; ptr 
90bd				inc hl 
90bd				ld (hl), a   ; ptr 
90bd			 
90bd			 
90bd				pop hl 
90bd			 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "mmr" 
90bd						CALLMONITOR 
90bd					endif 
90bd			 
90bd			.exit: 
90bd				pop af 
90bd				pop bc 
90bd				pop de  
90bd				ret 
90bd			 
90bd			 
90bd			 
90bd			 
90bd			free:  
90bd				push hl 
90bd				push af 
90bd				; get address in hl 
90bd			 
90bd					if DEBUG_FORTH_MALLOC_INT 
90bd						DMARK "fre" 
90bd						CALLMONITOR 
90bd					endif 
90bd				; data is at hl - move to block count 
90bd				dec hl 
90bd				dec hl    ; get past pointer 
90bd				dec hl 
90bd			 
90bd				ld a, (hl)    ; need this for a validation check 
90bd			 
90bd				dec hl    ; move to block marker 
90bd			 
90bd				; now check that the block count and block marker are the same  
90bd			        ; this checks that we are on a malloc node and not random memory 
90bd			        ; OK a faint chance this could be a problem but rare - famous last words! 
90bd			 
90bd				ld c, a 
90bd				ld a, (hl)    
90bd			 
90bd				cp c 
90bd				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
90bd			 
90bd				; yes good chance we are on a malloc node 
90bd			 
90bd				ld a, 0      
90bd				ld (hl), a   ; mark as free 
90bd			 
90bd				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
90bd			 
90bd			.freeignore:  
90bd			 
90bd				pop af 
90bd				pop hl 
90bd			 
90bd				ret 
90bd			 
90bd			 
90bd			 
90bd			endif 
90bd			 
90bd			; eof 
# End of file firmware_memory.asm
90bd			  
90bd			; device C  
90bd			if SOUND_ENABLE  
90bd				include "firmware_sound.asm"  
90bd			endif  
90bd			  
90bd			include "firmware_diags.asm"  
90bd			; Hardware diags menu 
90bd			 
90bd			 
90bd			config: 
90bd			 
90bd 3e 00			ld a, 0 
90bf 21 cf 90			ld hl, .configmn 
90c2 cd 65 88			call menu 
90c5			 
90c5 fe 00			cp 0 
90c7 c8				ret z 
90c8			 
90c8 fe 04			cp 4 
90ca cc 47 91			call z, hardware_diags 
90cd			 
90cd 18 ee			jr config 
90cf			 
90cf			.configmn: 
90cf d9 90			dw .c3 
90d1 f4 90			dw .c2 
90d3 09 91			dw .c4 
90d5 12 91			dw .c1 
90d7 00 00			dw 0 
90d9				 
90d9			 
90d9 .. 00		.c3: db "Save User Words To Storage",0 
90f4 .. 00		.c2: db "Select Autoload File",0 
9109 .. 00		.c4: db "Settings",0 
9112 .. 00		.c1: db "Hardware Diags",0 
9121			 
9121			 
9121			; Settings 
9121			; Run  
9121			 
9121			 
9121			 
9121			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9121			;;hd_menu2:   db "        2: Editor",0   
9121			;hd_menu2:   db "        2: Editor       6: Menu",0   
9121			;hd_menu3:   db "        3: Storage",0 
9121			;hd_menu4:   db "0=quit  4: Debug",0 
9121			;hd_don:     db "ON",0 
9121			;hd_doff:     db "OFF",0 
9121			; 
9121			; 
9121			; 
9121			;hardware_diags_old:       
9121			; 
9121			;.diagmenu: 
9121			;	call clear_display 
9121			;	ld a, display_row_1 
9121			;	ld de, hd_menu1 
9121			;	call str_at_display 
9121			; 
9121			;	ld a, display_row_2 
9121			;	ld de, hd_menu2 
9121			;	call str_at_display 
9121			; 
9121			;	ld a, display_row_3 
9121			;	ld de, hd_menu3 
9121			;	call str_at_display 
9121			; 
9121			;	ld a,  display_row_4 
9121			;	ld de, hd_menu4 
9121			;	call str_at_display 
9121			; 
9121			;	; display debug state 
9121			; 
9121			;	ld de, hd_don 
9121			;	ld a, (os_view_disable) 
9121			;	cp 0 
9121			;	jr z, .distog 
9121			;	ld de, hd_doff 
9121			;.distog: ld a, display_row_4+17 
9121			;	call str_at_display 
9121			; 
9121			;	call update_display 
9121			; 
9121			;	call cin_wait 
9121			; 
9121			; 
9121			; 
9121			;	cp '4' 
9121			;	jr nz, .diagn1 
9121			; 
9121			;	; debug toggle 
9121			; 
9121			;	ld a, (os_view_disable) 
9121			;	ld b, '*' 
9121			;	cp 0 
9121			;	jr z, .debtog 
9121			;	ld b, 0 
9121			;.debtog:	 
9121			;	ld a,b 
9121			;	ld (os_view_disable),a 
9121			; 
9121			;.diagn1: cp '0' 
9121			;	 ret z 
9121			; 
9121			;;	cp '1' 
9121			;;       jp z, matrix	 
9121			;;   TODO keyboard matrix test 
9121			; 
9121			;	cp '2' 
9121			;	jp z, .diagedit 
9121			; 
9121			;;	cp '6' 
9121			;;	jp z, .menutest 
9121			;;if ENABLE_BASIC 
9121			;;	cp '6' 
9121			;;	jp z, basic 
9121			;;endif 
9121			 ; 
9121			;	jp .diagmenu 
9121			; 
9121			; 
9121			;	ret 
9121			 
9121			 
9121			.debug_tog: 
9121 21 6f 91			ld hl, .menudebug 
9124				 
9124 3a 74 e3			ld a, (os_view_disable) 
9127 fe 2a			cp '*' 
9129 20 04			jr nz,.tdon  
912b 3e 01			ld a, 1 
912d 18 02			jr .tog1 
912f 3e 00		.tdon: ld a, 0 
9131			 
9131			.tog1: 
9131 cd 65 88			call menu 
9134 fe 00			cp 0 
9136 c8				ret z 
9137 fe 01			cp 1    ; disable debug 
9139 28 04			jr z, .dtog0 
913b 3e 2a			ld a, '*' 
913d 18 02			jr .dtogset 
913f 3e 00		.dtog0: ld a, 0 
9141 32 74 e3		.dtogset:  ld (os_view_disable), a 
9144 c3 21 91			jp .debug_tog 
9147			 
9147			 
9147			hardware_diags:       
9147			 
9147			.diagm: 
9147 21 5f 91			ld hl, .menuitems 
914a 3e 00			ld a, 0 
914c cd 65 88			call menu 
914f			 
914f fe 00		         cp 0 
9151 c8				 ret z 
9152			 
9152 fe 02			cp 2 
9154 ca c9 91			jp z, .diagedit 
9157 fe 04			cp 4 
9159 cc 21 91			call z, .debug_tog 
915c			 
915c			;	cp '6' 
915c			;	jp z, .menutest 
915c			;if ENABLE_BASIC 
915c			;	cp '6' 
915c			;	jp z, basic 
915c			;endif 
915c			  
915c c3 47 91			jp .diagm 
915f			 
915f				 
915f 75 91		.menuitems:   	dw .m1 
9161 80 91				dw .m2 
9163 87 91				dw .m3 
9165 8f 91				dw .m4 
9167 9e 91				dw .m5 
9169 a4 91				dw .m5a 
916b ad 91				dw .m5b 
916d 00 00				dw 0 
916f			 
916f			.menudebug: 
916f b6 91				dw .m6 
9171 bf 91				dw .m7 
9173 00 00				dw 0 
9175			 
9175 .. 00		.m1:   db "Key Matrix",0 
9180 .. 00		.m2:   db "Editor",0 
9187 .. 00		.m3:   db "Storage",0 
918f .. 00		.m4:   db "Software Debug",0 
919e .. 00		.m5:   db "Sound",0 
91a4 .. 00		.m5a:  db "RAM Test",0 
91ad .. 00		.m5b:  db "LCD Test",0 
91b6			 
91b6 .. 00		.m6:   db "Debug ON",0 
91bf .. 00		.m7:   db "Debug OFF",0 
91c9			 
91c9			; debug editor 
91c9			 
91c9			.diagedit: 
91c9			 
91c9 21 75 e3			ld hl, scratch 
91cc			;	ld bc, 250 
91cc			;	ldir 
91cc				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
91cc 3e 00			ld a, 0 
91ce 77				ld (hl), a 
91cf 23				inc hl 
91d0 77				ld (hl), a 
91d1 23				inc hl 
91d2 77				ld (hl), a 
91d3			 
91d3 cd 34 88		        call clear_display 
91d6 cd 57 88			call update_display 
91d9 3e 01			ld a, 1 
91db 32 80 ee			ld (hardware_diag), a 
91de			.diloop: 
91de 3e 00			ld a, display_row_1 
91e0 0e 00			ld c, 0 
91e2 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
91e4 1e 28			ld e, 40 
91e6			 
91e6 21 75 e3			ld hl, scratch	 
91e9 cd 8a 8a			call input_str 
91ec			 
91ec 3e 28			ld a, display_row_2 
91ee 11 75 e3			ld de, scratch 
91f1 cd 47 88			call str_at_display 
91f4 cd 57 88			call update_display 
91f7			 
91f7 c3 de 91			jp .diloop 
91fa			 
91fa			 
91fa			; pass word in hl 
91fa			; a has display location 
91fa			display_word_at: 
91fa f5				push af 
91fb e5				push hl 
91fc 7c				ld a,h 
91fd 21 7a e6			ld hl, os_word_scratch 
9200 cd 5e 8d			call hexout 
9203 e1				pop hl 
9204 7d				ld a,l 
9205 21 7c e6			ld hl, os_word_scratch+2 
9208 cd 5e 8d			call hexout 
920b 21 7e e6			ld hl, os_word_scratch+4 
920e 3e 00			ld a,0 
9210 77				ld (hl),a 
9211 11 7a e6			ld de,os_word_scratch 
9214 f1				pop af 
9215 cd 47 88				call str_at_display 
9218 c9				ret 
9219			 
9219			display_ptr_state: 
9219			 
9219				; to restore afterwards 
9219			 
9219 d5				push de 
921a c5				push bc 
921b e5				push hl 
921c f5				push af 
921d			 
921d				; for use in here 
921d			 
921d			;	push bc 
921d			;	push de 
921d			;	push hl 
921d			;	push af 
921d			 
921d cd 34 88			call clear_display 
9220			 
9220 11 f3 93			ld de, .ptrstate 
9223 3e 00			ld a, display_row_1 
9225 cd 47 88			call str_at_display 
9228			 
9228				; display debug step 
9228			 
9228			 
9228 11 7a ee			ld de, debug_mark 
922b 3e 26			ld a, display_row_1+display_cols-2 
922d cd 47 88			call str_at_display 
9230			 
9230				; display a 
9230 11 fd 93			ld de, .ptrcliptr 
9233 3e 28			ld a, display_row_2 
9235 cd 47 88			call str_at_display 
9238			 
9238 f1				pop af 
9239 2a 40 eb			ld hl,(cli_ptr) 
923c 3e 30			ld a, display_row_2+8 
923e cd fa 91			call display_word_at 
9241			 
9241			 
9241				; display hl 
9241			 
9241			 
9241 11 05 94			ld de, .ptrclioptr 
9244 3e 32			ld a, display_row_2+10 
9246 cd 47 88			call str_at_display 
9249			; 
9249			;	pop hl 
9249 3e 35			ld a, display_row_2+13 
924b 2a 3e eb			ld hl,(cli_origptr) 
924e cd fa 91			call display_word_at 
9251			; 
9251			;	 
9251			;	; display de 
9251			 
9251			;	ld de, .regstatede 
9251			;	ld a, display_row_3 
9251			;	call str_at_display 
9251			 
9251			;	pop de 
9251			;	ld h,d 
9251			;	ld l, e 
9251			;	ld a, display_row_3+3 
9251			;	call display_word_at 
9251			 
9251			 
9251				; display bc 
9251			 
9251			;	ld de, .regstatebc 
9251			;	ld a, display_row_3+10 
9251			;	call str_at_display 
9251			 
9251			;	pop bc 
9251			;	ld h,b 
9251			;	ld l, c 
9251			;	ld a, display_row_3+13 
9251			;	call display_word_at 
9251			 
9251			 
9251				; display dsp 
9251			 
9251			;	ld de, .regstatedsp 
9251			;	ld a, display_row_4 
9251			;	call str_at_display 
9251			 
9251				 
9251			;	ld hl,(cli_data_sp) 
9251			;	ld a, display_row_4+4 
9251			;	call display_word_at 
9251			 
9251				; display rsp 
9251			 
9251 11 34 94			ld de, .regstatersp 
9254 3e 82			ld a, display_row_4+10 
9256 cd 47 88			call str_at_display 
9259			 
9259				 
9259 2a 26 eb			ld hl,(cli_ret_sp) 
925c 3e 86			ld a, display_row_4+14 
925e cd fa 91			call display_word_at 
9261			 
9261 cd 57 88			call update_display 
9264			 
9264 cd e2 87			call delay1s 
9267 cd e2 87			call delay1s 
926a cd e2 87			call delay1s 
926d			 
926d			 
926d cd 87 97			call next_page_prompt 
9270			 
9270				; restore  
9270			 
9270 f1				pop af 
9271 e1				pop hl 
9272 c1				pop bc 
9273 d1				pop de 
9274 c9				ret 
9275			 
9275			break_point_state: 
9275 f5				push af 
9276			 
9276				; see if disabled 
9276			 
9276 3a 74 e3			ld a, (os_view_disable) 
9279 fe 2a			cp '*' 
927b 20 02			jr nz, .bpsgo 
927d f1				pop af 
927e c9				ret 
927f			 
927f			.bpsgo: 
927f f1				pop af 
9280 f5				push af 
9281 22 70 e3			ld (os_view_hl), hl 
9284 ed 53 6e e3		ld (os_view_de), de 
9288 ed 43 6c e3		ld (os_view_bc), bc 
928c e5				push hl 
928d 6f				ld l, a 
928e 26 00			ld h, 0 
9290 22 72 e3			ld (os_view_af),hl 
9293			 
9293 21 c0 ed				ld hl, display_fb0 
9296 22 db eb				ld (display_fb_active), hl 
9299 e1				pop hl	 
929a			 
929a 3e 31			ld a, '1' 
929c fe 2a		.bps1:  cp '*' 
929e 20 03			jr nz, .bps1b 
92a0 32 74 e3			ld (os_view_disable),a 
92a3 fe 31		.bps1b:  cp '1' 
92a5 20 14			jr nz, .bps2 
92a7			 
92a7				; display reg 
92a7			 
92a7				 
92a7			 
92a7 3a 72 e3			ld a, (os_view_af) 
92aa 2a 70 e3			ld hl, (os_view_hl) 
92ad ed 5b 6e e3		ld de, (os_view_de) 
92b1 ed 4b 6c e3		ld bc, (os_view_bc) 
92b5 cd 4f 93			call display_reg_state 
92b8 c3 3b 93			jp .bpschk 
92bb			 
92bb fe 32		.bps2:  cp '2' 
92bd 20 08			jr nz, .bps3 
92bf				 
92bf				; display hl 
92bf 2a 70 e3			ld hl, (os_view_hl) 
92c2 cd 39 94			call display_dump_at_hl 
92c5			 
92c5 18 74			jr .bpschk 
92c7			 
92c7 fe 33		.bps3:  cp '3' 
92c9 20 08			jr nz, .bps4 
92cb			 
92cb			        ; display de 
92cb 2a 6e e3			ld hl, (os_view_de) 
92ce cd 39 94			call display_dump_at_hl 
92d1			 
92d1 18 68			jr .bpschk 
92d3 fe 34		.bps4:  cp '4' 
92d5 20 08			jr nz, .bps5 
92d7			 
92d7			        ; display bc 
92d7 2a 6c e3			ld hl, (os_view_bc) 
92da cd 39 94			call display_dump_at_hl 
92dd			 
92dd 18 5c			jr .bpschk 
92df fe 35		.bps5:  cp '5' 
92e1 20 08		        jr nz, .bps7 
92e3			 
92e3				; display cur ptr 
92e3 2a 40 eb			ld hl, (cli_ptr) 
92e6 cd 39 94			call display_dump_at_hl 
92e9			 
92e9 18 50			jr .bpschk 
92eb fe 36		.bps7:  cp '6' 
92ed 20 08			jr nz, .bps8b 
92ef				 
92ef				; display cur orig ptr 
92ef 2a 3e eb			ld hl, (cli_origptr) 
92f2 cd 39 94			call display_dump_at_hl 
92f5 18 44			jr .bpschk 
92f7 fe 37		.bps8b:  cp '7' 
92f9 20 08			jr nz, .bps9 
92fb				 
92fb				; display dsp 
92fb 2a 22 eb			ld hl, (cli_data_sp) 
92fe cd 39 94			call display_dump_at_hl 
9301			 
9301 18 38			jr .bpschk 
9303 fe 39		.bps9:  cp '9' 
9305 20 05			jr nz, .bps8c 
9307				 
9307				; display SP 
9307			;	ld hl, sp 
9307 cd 39 94			call display_dump_at_hl 
930a			 
930a 18 2f			jr .bpschk 
930c fe 38		.bps8c:  cp '8' 
930e 20 08			jr nz, .bps8d 
9310				 
9310				; display rsp 
9310 2a 26 eb			ld hl, (cli_ret_sp) 
9313 cd 39 94			call display_dump_at_hl 
9316			 
9316 18 23			jr .bpschk 
9318 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
931a 20 05			jr nz, .bps8 
931c cd 7d 95			call monitor 
931f			 
931f 18 1a			jr .bpschk 
9321 fe 30		.bps8:  cp '0' 
9323 20 16			jr nz, .bpschk 
9325			 
9325 21 1f ed				ld hl, display_fb1 
9328 22 db eb				ld (display_fb_active), hl 
932b cd 57 88				call update_display 
932e			 
932e				;ld a, (os_view_af) 
932e 2a 70 e3			ld hl, (os_view_hl) 
9331 ed 5b 6e e3		ld de, (os_view_de) 
9335 ed 4b 6c e3		ld bc, (os_view_bc) 
9339 f1				pop af 
933a c9				ret 
933b			 
933b			.bpschk:   
933b cd e2 87			call delay1s 
933e 3e 9f		ld a,display_row_4 + display_cols - 1 
9340 11 85 97		        ld de, endprg 
9343 cd 47 88			call str_at_display 
9346 cd 57 88			call update_display 
9349 cd 75 d6			call cin_wait 
934c			 
934c c3 9c 92			jp .bps1 
934f			 
934f			 
934f			display_reg_state: 
934f			 
934f				; to restore afterwards 
934f			 
934f d5				push de 
9350 c5				push bc 
9351 e5				push hl 
9352 f5				push af 
9353			 
9353				; for use in here 
9353			 
9353 c5				push bc 
9354 d5				push de 
9355 e5				push hl 
9356 f5				push af 
9357			 
9357 cd 34 88			call clear_display 
935a			 
935a 11 0f 94			ld de, .regstate 
935d 3e 00			ld a, display_row_1 
935f cd 47 88			call str_at_display 
9362			 
9362				; display debug step 
9362			 
9362			 
9362 11 7a ee			ld de, debug_mark 
9365 3e 25			ld a, display_row_1+display_cols-3 
9367 cd 47 88			call str_at_display 
936a			 
936a				; display a 
936a 11 2b 94			ld de, .regstatea 
936d 3e 28			ld a, display_row_2 
936f cd 47 88			call str_at_display 
9372			 
9372 e1				pop hl 
9373			;	ld h,0 
9373			;	ld l, a 
9373 3e 2b			ld a, display_row_2+3 
9375 cd fa 91			call display_word_at 
9378			 
9378			 
9378				; display hl 
9378			 
9378			 
9378 11 1f 94			ld de, .regstatehl 
937b 3e 32			ld a, display_row_2+10 
937d cd 47 88			call str_at_display 
9380			 
9380 e1				pop hl 
9381 3e 35			ld a, display_row_2+13 
9383 cd fa 91			call display_word_at 
9386			 
9386				 
9386				; display de 
9386			 
9386 11 23 94			ld de, .regstatede 
9389 3e 50			ld a, display_row_3 
938b cd 47 88			call str_at_display 
938e			 
938e e1				pop hl 
938f			;	ld h,d 
938f			;	ld l, e 
938f 3e 53			ld a, display_row_3+3 
9391 cd fa 91			call display_word_at 
9394			 
9394			 
9394				; display bc 
9394			 
9394 11 27 94			ld de, .regstatebc 
9397 3e 5a			ld a, display_row_3+10 
9399 cd 47 88			call str_at_display 
939c			 
939c e1				pop hl 
939d			;	ld h,b 
939d			;	ld l, c 
939d 3e 5d			ld a, display_row_3+13 
939f cd fa 91			call display_word_at 
93a2			 
93a2			 
93a2				; display dsp 
93a2			 
93a2 11 2f 94			ld de, .regstatedsp 
93a5 3e 78			ld a, display_row_4 
93a7 cd 47 88			call str_at_display 
93aa			 
93aa				 
93aa 2a 22 eb			ld hl,(cli_data_sp) 
93ad 3e 7c			ld a, display_row_4+4 
93af cd fa 91			call display_word_at 
93b2			 
93b2				; display rsp 
93b2			 
93b2 11 34 94			ld de, .regstatersp 
93b5 3e 82			ld a, display_row_4+10 
93b7 cd 47 88			call str_at_display 
93ba			 
93ba				 
93ba 2a 26 eb			ld hl,(cli_ret_sp) 
93bd 3e 86			ld a, display_row_4+14 
93bf cd fa 91			call display_word_at 
93c2			 
93c2 cd 57 88			call update_display 
93c5			 
93c5			;	call delay1s 
93c5			;	call delay1s 
93c5			;	call delay1s 
93c5			 
93c5			 
93c5			;	call next_page_prompt 
93c5			 
93c5				; restore  
93c5			 
93c5 f1				pop af 
93c6 e1				pop hl 
93c7 c1				pop bc 
93c8 d1				pop de 
93c9 c9				ret 
93ca			 
93ca .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
93de .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
93f3 .. 00		.ptrstate:	db "Ptr State",0 
93fd .. 00		.ptrcliptr:     db "cli_ptr",0 
9405 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
940f .. 00		.regstate:	db "Reg State (1/0)",0 
941f .. 00		.regstatehl:	db "HL:",0 
9423 .. 00		.regstatede:	db "DE:",0 
9427 .. 00		.regstatebc:	db "BC:",0 
942b .. 00		.regstatea:	db "A :",0 
942f .. 00		.regstatedsp:	db "DSP:",0 
9434 .. 00		.regstatersp:	db "RSP:",0 
9439			 
9439			display_dump_at_hl: 
9439 e5				push hl 
943a d5				push de 
943b c5				push bc 
943c f5				push af 
943d			 
943d 22 98 e6			ld (os_cur_ptr),hl	 
9440 cd 34 88			call clear_display 
9443 cd 8f 96			call dumpcont 
9446			;	call delay1s 
9446			;	call next_page_prompt 
9446			 
9446			 
9446 f1				pop af 
9447 c1				pop bc 
9448 d1				pop de 
9449 e1				pop hl 
944a c9				ret 
944b			 
944b			;if ENABLE_BASIC 
944b			;	include "nascombasic.asm" 
944b			;	basic: 
944b			;	include "forth/FORTH.ASM" 
944b			;endif 
944b			 
944b			; eof 
944b			 
944b			 
# End of file firmware_diags.asm
944b			  
944b			  
944b			  
944b			  
944b			; eof  
944b			  
# End of file firmware.asm
944b			 
944b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
944b			;if BASE_KEV  
944b			;baseram: equ 08000h 
944b			;endif 
944b			 
944b			;if BASE_SC114 
944b			;baseram:     equ    endofcode 
944b			;endif 
944b			 
944b			 
944b			; start system 
944b			 
944b			coldstart: 
944b				; set sp 
944b				; di/ei 
944b			 
944b f3				di 
944c 31 00 f0			ld sp, tos 
944f			;	ei 
944f			 
944f			 
944f				; disable breakpoint by default 
944f			 
944f 3e 2a			ld a,'*' 
9451 32 74 e3			ld (os_view_disable),a 
9454			 
9454				; init hardware 
9454			 
9454				; init keyboard and screen hardware 
9454			 
9454 cd 03 80			call hardware_init 
9457			 
9457			 
9457				; detect if any keys are held down to enable breakpoints at start up 
9457			 
9457 cd 7b d6			call cin  
945a fe 00			cp 0 
945c 28 03			jr z, .nokeys 
945e			 
945e				;call hardware_diags 
945e cd bd 90			call config 
9461			 
9461			;	ld de, .bpen 
9461			;	ld a, display_row_4 
9461			;	call str_at_display 
9461			;	call update_display 
9461			; 
9461			;	ld a,0 
9461			;	ld (os_view_disable),a 
9461			; 
9461			;.bpwait: 
9461			;	call cin 
9461			;	cp 0 
9461			;	jr z, .bpwait 
9461			;	jr .nokeys 
9461			; 
9461			; 
9461			;.bpen:  db "Break points enabled!",0 
9461			 
9461			 
9461			 
9461			 
9461			 
9461			 
9461			.nokeys: 
9461			 
9461			 
9461				 
9461			 
9461			;jp  testkey 
9461			 
9461			;call storage_get_block_0 
9461			; 
9461			;ld hl, 0 
9461			;ld de, store_page 
9461			;call storage_read_block 
9461			 
9461				 
9461			;ld hl, 10 
9461			;ld de, store_page 
9461			;call storage_read_block 
9461			 
9461			 
9461			 
9461			 
9461			 
9461			;stop:	nop 
9461			;	jp stop 
9461			 
9461			 
9461			 
9461			main: 
9461 cd 34 88			call clear_display 
9464 cd 57 88			call update_display 
9467			 
9467			 
9467			 
9467			;	call testlcd 
9467			 
9467			 
9467			 
9467 cd d5 99			call forth_init 
946a			 
946a			 
946a			warmstart: 
946a cd ab 99			call forth_warmstart 
946d			 
946d				; run startup word load 
946d			        ; TODO prevent this running at warmstart after crash  
946d			 
946d				if STARTUP_ENABLE 
946d cd 0f d3				call forth_startup 
9470				endif 
9470			 
9470				; show free memory after boot 
9470 11 17 95			ld de, freeram 
9473 3e 00			ld a, display_row_1 
9475 cd 47 88			call str_at_display 
9478			 
9478			; Or use heap_size word???? 
9478 21 69 e3			ld hl, heap_end 
947b 11 99 d6			ld de, heap_start 
947e ed 52			sbc hl, de 
9480 e5				push hl 
9481 7c				ld a,h	         	 
9482 21 7a e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9485 cd 5e 8d			call hexout 
9488 e1			   	pop hl 
9489			 
9489 7d				ld a,l 
948a 21 7c e6			ld hl, os_word_scratch+2 
948d cd 5e 8d			call hexout 
9490 21 7e e6			ld hl, os_word_scratch+4 
9493 3e 00			ld a, 0 
9495 77				ld (hl),a 
9496 11 7a e6			ld de, os_word_scratch 
9499 3e 0d			ld a, display_row_1 + 13 
949b cd 47 88			call str_at_display 
949e cd 57 88			call update_display 
94a1			 
94a1			 
94a1				;call demo 
94a1			 
94a1			 
94a1				; init scratch input area for cli commands 
94a1			 
94a1 21 9c e6			ld hl, os_cli_cmd 
94a4 3e 00			ld a,0 
94a6 77				ld (hl),a 
94a7 23				inc hl 
94a8 77				ld (hl),a 
94a9			 
94a9 3e 00			ld a,0 
94ab 32 9b e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
94ae			 
94ae 32 98 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
94b1 32 99 e6			ld (os_cur_ptr+1),a	 
94b4			 
94b4 32 7a e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
94b7 32 7b e6			ld (os_word_scratch+1),a	 
94ba				 
94ba			 
94ba				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
94ba 21 9c e6			ld hl, os_cli_cmd 
94bd			 
94bd 3e 00			ld a, 0		 ; init cli input 
94bf 77				ld (hl), a 
94c0 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
94c2			cli: 
94c2				; show cli prompt 
94c2				;push af 
94c2				;ld a, 0 
94c2				;ld de, prompt 
94c2				;call str_at_display 
94c2			 
94c2				;call update_display 
94c2				;pop af 
94c2				;inc a 
94c2				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
94c2 0e 00			ld c, 0 
94c4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
94c6 1e 28			ld e, 40 
94c8			 
94c8 21 9c e6			ld hl, os_cli_cmd 
94cb			 
94cb				STACKFRAME OFF $fefe $9f9f 
94cb				if DEBUG_STACK_IMB 
94cb					if OFF 
94cb						exx 
94cb						ld de, $fefe 
94cb						ld a, d 
94cb						ld hl, curframe 
94cb						call hexout 
94cb						ld a, e 
94cb						ld hl, curframe+2 
94cb						call hexout 
94cb						ld hl, $fefe 
94cb						push hl 
94cb						ld hl, $9f9f 
94cb						push hl 
94cb						exx 
94cb					endif 
94cb				endif 
94cb			endm 
# End of macro STACKFRAME
94cb			 
94cb cd 8a 8a			call input_str 
94ce			 
94ce				STACKFRAMECHK OFF $fefe $9f9f 
94ce				if DEBUG_STACK_IMB 
94ce					if OFF 
94ce						exx 
94ce						ld hl, $9f9f 
94ce						pop de   ; $9f9f 
94ce						call cmp16 
94ce						jr nz, .spnosame 
94ce						ld hl, $fefe 
94ce						pop de   ; $fefe 
94ce						call cmp16 
94ce						jr z, .spfrsame 
94ce						.spnosame: call showsperror 
94ce						.spfrsame: nop 
94ce						exx 
94ce					endif 
94ce				endif 
94ce			endm 
# End of macro STACKFRAMECHK
94ce			 
94ce				; copy input to last command 
94ce			 
94ce 21 9c e6			ld hl, os_cli_cmd 
94d1 11 9b e7			ld de, os_last_cmd 
94d4 01 ff 00			ld bc, 255 
94d7 ed b0			ldir 
94d9			 
94d9				; wipe current buffer 
94d9			 
94d9 3e 00			ld a, 0 
94db 21 9c e6			ld hl, os_cli_cmd 
94de 11 9d e6			ld de, os_cli_cmd+1 
94e1 01 fe 00			ld bc, 254 
94e4 ed b0			ldir 
94e6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
94e6			;	call strcpy 
94e6			;	ld a, 0 
94e6			;	ld (hl), a 
94e6			;	inc hl 
94e6			;	ld (hl), a 
94e6			;	inc hl 
94e6			;	ld (hl), a 
94e6			 
94e6				; switch frame buffer to program  
94e6			 
94e6 21 1f ed				ld hl, display_fb1 
94e9 22 db eb				ld (display_fb_active), hl 
94ec			 
94ec			;	nop 
94ec				STACKFRAME ON $fbfe $8f9f 
94ec				if DEBUG_STACK_IMB 
94ec					if ON 
94ec						exx 
94ec						ld de, $fbfe 
94ec						ld a, d 
94ec						ld hl, curframe 
94ec						call hexout 
94ec						ld a, e 
94ec						ld hl, curframe+2 
94ec						call hexout 
94ec						ld hl, $fbfe 
94ec						push hl 
94ec						ld hl, $8f9f 
94ec						push hl 
94ec						exx 
94ec					endif 
94ec				endif 
94ec			endm 
# End of macro STACKFRAME
94ec				; first time into the parser so pass over the current scratch pad 
94ec 21 9c e6			ld hl,os_cli_cmd 
94ef				; tokenise the entered statement(s) in HL 
94ef cd 4e 9a			call forthparse 
94f2			        ; exec forth statements in top of return stack 
94f2 cd 8e 9a			call forthexec 
94f5				;call forthexec_cleanup 
94f5			;	call parsenext 
94f5			 
94f5				STACKFRAMECHK ON $fbfe $8f9f 
94f5				if DEBUG_STACK_IMB 
94f5					if ON 
94f5						exx 
94f5						ld hl, $8f9f 
94f5						pop de   ; $8f9f 
94f5						call cmp16 
94f5						jr nz, .spnosame 
94f5						ld hl, $fbfe 
94f5						pop de   ; $fbfe 
94f5						call cmp16 
94f5						jr z, .spfrsame 
94f5						.spnosame: call showsperror 
94f5						.spfrsame: nop 
94f5						exx 
94f5					endif 
94f5				endif 
94f5			endm 
# End of macro STACKFRAMECHK
94f5				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
94f5			 
94f5 3e 78			ld a, display_row_4 
94f7 11 29 95			ld de, endprog 
94fa			 
94fa cd 57 88			call update_display		 
94fd			 
94fd cd 87 97			call next_page_prompt 
9500			 
9500				; switch frame buffer to cli 
9500			 
9500 21 c0 ed				ld hl, display_fb0 
9503 22 db eb				ld (display_fb_active), hl 
9506			 
9506			 
9506 cd 34 88		        call clear_display 
9509 cd 57 88			call update_display		 
950c			 
950c 21 9c e6			ld hl, os_cli_cmd 
950f			 
950f 3e 00			ld a, 0		 ; init cli input 
9511 77				ld (hl), a 
9512			 
9512				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9512			 
9512				; now on last line 
9512			 
9512				; TODO scroll screen up 
9512			 
9512				; TODO instead just clear screen and place at top of screen 
9512			 
9512			;	ld a, 0 
9512			;	ld (f_cursor_ptr),a 
9512			 
9512				;call clear_display 
9512				;call update_display 
9512			 
9512				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9512 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9514 c3 c2 94			jp cli 
9517			 
9517 .. 00		freeram: db "Free bytes: $",0 
9525 ..			asc: db "1A2F" 
9529 .. 00		endprog: db "End prog...",0 
9535			 
9535			testenter2:   
9535 21 a7 e3			ld hl,scratch+50 
9538 22 98 e6			ld (os_cur_ptr),hl 
953b c3 c2 94			jp cli 
953e			 
953e			testenter:  
953e			 
953e 21 25 95			ld hl,asc 
9541			;	ld a,(hl) 
9541			;	call nibble2val 
9541 cd b4 8d			call get_byte 
9544			 
9544			 
9544			;	ld a,(hl) 
9544			;	call atohex 
9544			 
9544			;	call fourehexhl 
9544 32 a7 e3			ld (scratch+50),a 
9547			 
9547			 
9547			 
9547 21 27 95			ld hl,asc+2 
954a			;	ld a, (hl) 
954a			;	call nibble2val 
954a cd b4 8d			call get_byte 
954d			 
954d			;	call fourehexhl 
954d 32 a9 e3			ld (scratch+52),a 
9550				 
9550 21 a7 e3			ld hl,scratch+50 
9553 22 98 e6			ld (os_cur_ptr),hl 
9556 c3 c2 94			jp cli 
9559			 
9559			enter:	 
9559 3a 79 e3			ld a,(scratch+4) 
955c fe 00			cp 0 
955e 28 0c			jr z, .entercont 
9560				; no, not a null term line so has an address to work out.... 
9560			 
9560 21 77 e3			ld hl,scratch+2 
9563 cd 14 8e			call get_word_hl 
9566			 
9566 22 98 e6			ld (os_cur_ptr),hl	 
9569 c3 c2 94			jp cli 
956c			 
956c			 
956c			.entercont:  
956c			 
956c 21 77 e3			ld hl, scratch+2 
956f cd b4 8d			call get_byte 
9572			 
9572 2a 98 e6		   	ld hl,(os_cur_ptr) 
9575 77					ld (hl),a 
9576 23					inc hl 
9577 22 98 e6				ld (os_cur_ptr),hl 
957a				 
957a			; get byte  
957a			 
957a			 
957a c3 c2 94			jp cli 
957d			 
957d			 
957d			; basic monitor support 
957d			 
957d			monitor: 
957d				;  
957d cd 34 88			call clear_display 
9580 3e 00			ld a, 0 
9582 11 ca 95			ld de, .monprompt 
9585 cd 47 88			call str_at_display 
9588 cd 57 88			call update_display 
958b			 
958b				; get a monitor command 
958b			 
958b 0e 00			ld c, 0     ; entry at top left 
958d 16 64			ld d, 100   ; max buffer size 
958f 1e 0f			ld e, 15    ; input scroll area 
9591 3e 00			ld a, 0     ; init string 
9593 21 73 e5			ld hl, os_input 
9596 77				ld (hl), a 
9597 23				inc hl 
9598 77				ld (hl), a 
9599 21 73 e5			ld hl, os_input 
959c 3e 01			ld a, 1     ; init string 
959e cd 8a 8a			call input_str 
95a1			 
95a1 cd 34 88		        call clear_display 
95a4 cd 57 88			call update_display		 
95a7			 
95a7 3a 73 e5			ld a, (os_input) 
95aa cd b2 8e			call toUpper 
95ad fe 48		        cp 'H' 
95af 28 6f		        jr z, .monhelp 
95b1 fe 44			cp 'D'		; dump 
95b3 ca 41 96			jp z, .mondump	 
95b6 fe 43			cp 'C'		; dump 
95b8 ca 5b 96			jp z, .moncdump	 
95bb fe 4d			cp 'M'		; dump 
95bd ca cc 95			jp z, .moneditstart 
95c0 fe 55			cp 'U'		; dump 
95c2 28 14			jr z, .monedit	 
95c4 fe 51			cp 'Q'		; dump 
95c6 c8				ret z	 
95c7			 
95c7			 
95c7				; TODO "S" to access symbol by name and not need the address 
95c7				; TODO "F" to find a string in memory 
95c7			 
95c7 c3 7d 95			jp monitor 
95ca			 
95ca .. 00		.monprompt: db ">", 0 
95cc			 
95cc			.moneditstart: 
95cc				; get starting address 
95cc			 
95cc 21 75 e5			ld hl,os_input+2 
95cf cd 14 8e			call get_word_hl 
95d2			 
95d2 22 98 e6			ld (os_cur_ptr),hl	 
95d5			 
95d5 c3 7d 95			jp monitor 
95d8			 
95d8			.monedit: 
95d8				; get byte to load 
95d8			 
95d8 21 75 e5			ld hl,os_input+2 
95db cd b4 8d			call get_byte 
95de			 
95de				; get address to update 
95de 2a 98 e6			ld hl, (os_cur_ptr) 
95e1			 
95e1				; update byte 
95e1			 
95e1 77				ld (hl), a 
95e2			 
95e2				; move to next address and save it 
95e2			 
95e2 23				inc hl 
95e3 22 98 e6			ld (os_cur_ptr),hl	 
95e6			 
95e6 c3 7d 95			jp monitor 
95e9			 
95e9			 
95e9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
95fd .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9619 .. 00		.monhelptext3:  db "Q-Quit",0 
9620			        
9620			.monhelp: 
9620 3e 00			ld a, display_row_1 
9622 11 e9 95		        ld de, .monhelptext1 
9625			 
9625 cd 47 88			call str_at_display 
9628 3e 28			ld a, display_row_2 
962a 11 fd 95		        ld de, .monhelptext2 
962d					 
962d cd 47 88			call str_at_display 
9630 3e 50			ld a, display_row_3 
9632 11 19 96		        ld de, .monhelptext3 
9635					 
9635 cd 47 88			call str_at_display 
9638 cd 57 88			call update_display		 
963b			 
963b cd 87 97			call next_page_prompt 
963e c3 7d 95			jp monitor 
9641			 
9641			.mondump:    
9641 21 75 e5			ld hl,os_input+2 
9644 cd 14 8e			call get_word_hl 
9647			 
9647 22 98 e6			ld (os_cur_ptr),hl	 
964a cd 8f 96			call dumpcont 
964d 3e 78			ld a, display_row_4 
964f 11 29 95			ld de, endprog 
9652			 
9652 cd 57 88			call update_display		 
9655			 
9655 cd 87 97			call next_page_prompt 
9658 c3 7d 95			jp monitor 
965b			.moncdump: 
965b cd 8f 96			call dumpcont 
965e 3e 78			ld a, display_row_4 
9660 11 29 95			ld de, endprog 
9663			 
9663 cd 57 88			call update_display		 
9666			 
9666 cd 87 97			call next_page_prompt 
9669 c3 7d 95			jp monitor 
966c			 
966c			 
966c			; TODO symbol access  
966c			 
966c			.symbols:     ;; A list of symbols that can be called up  
966c c0 ed			dw display_fb0 
966e .. 00			db "fb0",0  
9672 65 eb		     	dw store_page 
9674 .. 00			db "store_page",0 
967f			 
967f			 
967f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
967f			 
967f 3a 76 e3			ld a,(scratch+1) 
9682 fe 00			cp 0 
9684 28 09			jr z, dumpcont 
9686			 
9686				; no, not a null term line so has an address to work out.... 
9686			 
9686 21 77 e3			ld hl,scratch+2 
9689 cd 14 8e			call get_word_hl 
968c			 
968c 22 98 e6			ld (os_cur_ptr),hl	 
968f			 
968f			 
968f			 
968f			dumpcont: 
968f			 
968f				; dump bytes at ptr 
968f			 
968f			 
968f 3e 00			ld a, display_row_1 
9691 2a db eb			ld hl, (display_fb_active) 
9694 cd 5d 8a			call addatohl 
9697 cd bf 96			call .dumpbyterow 
969a			 
969a 3e 28			ld a, display_row_2 
969c 2a db eb			ld hl, (display_fb_active) 
969f cd 5d 8a			call addatohl 
96a2 cd bf 96			call .dumpbyterow 
96a5			 
96a5			 
96a5 3e 50			ld a, display_row_3 
96a7 2a db eb			ld hl, (display_fb_active) 
96aa cd 5d 8a			call addatohl 
96ad cd bf 96			call .dumpbyterow 
96b0			 
96b0 3e 78			ld a, display_row_4 
96b2 2a db eb			ld hl, (display_fb_active) 
96b5 cd 5d 8a			call addatohl 
96b8 cd bf 96			call .dumpbyterow 
96bb			 
96bb cd 57 88			call update_display 
96be			;		jp cli 
96be c9				ret 
96bf			 
96bf			.dumpbyterow: 
96bf			 
96bf				;push af 
96bf			 
96bf e5				push hl 
96c0			 
96c0				; calc where to poke the ascii 
96c0			if display_cols == 20 
96c0				ld a, 16 
96c0			else 
96c0 3e 1f			ld a, 31 
96c2			endif 
96c2			 
96c2 cd 5d 8a			call addatohl 
96c5 22 7a e6			ld (os_word_scratch),hl  		; save pos for later 
96c8			 
96c8			 
96c8			; display decoding address 
96c8 2a 98 e6		   	ld hl,(os_cur_ptr) 
96cb			 
96cb 7c				ld a,h 
96cc e1				pop hl 
96cd e5				push hl 
96ce			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96ce cd 5e 8d			call hexout 
96d1 2a 98 e6		   	ld hl,(os_cur_ptr) 
96d4			 
96d4 7d				ld a,l 
96d5 e1				pop hl 
96d6 23				inc hl 
96d7 23				inc hl 
96d8 e5				push hl 
96d9			;	ld hl, os_word_scratch+2 
96d9 cd 5e 8d			call hexout 
96dc e1				pop hl 
96dd 23				inc hl 
96de 23				inc hl 
96df				;ld hl, os_word_scratch+4 
96df 3e 3a			ld a, ':' 
96e1 77				ld (hl),a 
96e2 23				inc hl 
96e3				;ld a, 0 
96e3				;ld (hl),a 
96e3				;ld de, os_word_scratch 
96e3				;pop af 
96e3				;push af 
96e3			;		ld a, display_row_2 
96e3			;		call str_at_display 
96e3			;		call update_display 
96e3			 
96e3			 
96e3			;pop af 
96e3			;	add 5 
96e3			 
96e3			if display_cols == 20 
96e3				ld b, 4 
96e3			else 
96e3 06 08			ld b, 8 
96e5			endif	 
96e5			 
96e5			.dumpbyte: 
96e5 c5				push bc 
96e6 e5				push hl 
96e7			 
96e7			 
96e7 2a 98 e6		   	ld hl,(os_cur_ptr) 
96ea 7e					ld a,(hl) 
96eb			 
96eb					; poke the ascii to display 
96eb 2a 7a e6				ld hl,(os_word_scratch) 
96ee 77					ld (hl),a 
96ef 23					inc hl 
96f0 22 7a e6				ld (os_word_scratch),hl 
96f3			 
96f3					 
96f3			 
96f3			 
96f3 e1					pop hl 
96f4 e5					push hl 
96f5			 
96f5 cd 5e 8d				call hexout 
96f8			 
96f8					 
96f8 2a 98 e6		   	ld hl,(os_cur_ptr) 
96fb 23				inc hl 
96fc 22 98 e6		   	ld (os_cur_ptr),hl 
96ff			 
96ff e1					pop hl 
9700 23					inc hl 
9701 23					inc hl 
9702 23					inc hl 
9703			 
9703			 
9703			 
9703					;ld a,0 
9703					;ld (os_word_scratch+2),a 
9703					;pop af 
9703					;push af 
9703			 
9703					;ld de, os_word_scratch 
9703					;call str_at_display 
9703			;		call update_display 
9703			;		pop af 
9703 c1					pop bc 
9704 c6 03				add 3 
9706 10 dd			djnz .dumpbyte 
9708			 
9708				 
9708			 
9708 c9				ret 
9709			 
9709			jump:	 
9709			 
9709 21 77 e3			ld hl,scratch+2 
970c cd 14 8e			call get_word_hl 
970f				;ld hl,(scratch+2) 
970f				;call fourehexhl 
970f			 
970f 22 98 e6			ld (os_cur_ptr),hl	 
9712			 
9712 e9				jp (hl) 
9713			 
9713			 
9713			 
9713			; TODO implement a basic monitor mode to start with 
9713			 
9713			 
9713			 
9713			 
9713			 
9713			 
9713			 
9713			 
9713			 
9713			; testing and demo code during development 
9713			 
9713			 
9713 .. 00		str1: db "Enter some text...",0 
9726 .. 00		clear: db "                    ",0 
973b			 
973b			demo: 
973b			 
973b			 
973b			 
973b			;	call update_display 
973b			 
973b				; init scratch input area for testing 
973b 21 75 e3			ld hl, scratch	 
973e 3e 00			ld a,0 
9740 77				ld (hl),a 
9741			 
9741			 
9741 3e 28		            LD   A, display_row_2 
9743			;            CALL fLCD_Pos       ;Position cursor to location in A 
9743 11 13 97		            LD   DE, str1 
9746 cd 47 88			call str_at_display 
9749			 
9749			;            CALL fLCD_Str       ;Display string pointed to by DE 
9749			cloop:	 
9749 3e 50		            LD   A, display_row_3 
974b			;            CALL fLCD_Pos       ;Position cursor to location in A 
974b 11 26 97		            LD   DE, clear 
974e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
974e cd 47 88				call str_at_display 
9751 3e 78			ld a, display_row_4 
9753 11 83 97			ld de, prompt 
9756			 
9756 cd 47 88				call str_at_display 
9759 cd 57 88			call update_display 
975c			 
975c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
975e 16 0a			ld d, 10 
9760 21 75 e3			ld hl, scratch	 
9763 cd 8a 8a			call input_str 
9766			 
9766			;	call clear_display 
9766			;'	call update_display 
9766			 
9766 3e 00		            LD   A, display_row_1 
9768			;            CALL fLCD_Pos       ;Position cursor to location in A 
9768 11 26 97		            LD   DE, clear 
976b cd 47 88				call str_at_display 
976e			;            CALL fLCD_Str       ;Display string pointed to by DE 
976e 3e 00		            LD   A, display_row_1 
9770			;            CALL fLCD_Pos       ;Position cursor to location in A 
9770 11 75 e3		            LD   DE, scratch 
9773			;            CALL fLCD_Str       ;Display string pointed to by DE 
9773 cd 47 88				call str_at_display 
9776 cd 57 88			call update_display 
9779			 
9779 3e 00				ld a,0 
977b 21 75 e3			ld hl, scratch 
977e 77				ld (hl),a 
977f			 
977f 00				nop 
9780 c3 49 97			jp cloop 
9783			 
9783			 
9783			 
9783			; OS Prompt 
9783			 
9783 .. 00		prompt: db ">",0 
9785 .. 00		endprg: db "?",0 
9787			 
9787			 
9787			; handy next page prompt 
9787			next_page_prompt: 
9787 e5				push hl 
9788 d5				push de 
9789 f5				push af 
978a c5				push bc 
978b			 
978b 3e 9f			ld a,display_row_4 + display_cols - 1 
978d 11 85 97		        ld de, endprg 
9790 cd 47 88			call str_at_display 
9793 cd 57 88			call update_display 
9796 cd 75 d6			call cin_wait 
9799 c1				pop bc 
979a f1				pop af 
979b d1				pop de 
979c e1				pop hl 
979d			 
979d			 
979d c9				ret 
979e			 
979e			 
979e			; forth parser 
979e			 
979e			; My forth kernel 
979e			include "forth_kernel.asm" 
979e			; 
979e			; kernel to the forth OS 
979e			 
979e			DS_TYPE_STR: equ 1     ; string type 
979e			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
979e			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
979e			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
979e			 
979e			FORTH_PARSEV1: equ 0 
979e			FORTH_PARSEV2: equ 0 
979e			FORTH_PARSEV3: equ 0 
979e			FORTH_PARSEV4: equ 0 
979e			FORTH_PARSEV5: equ 1 
979e			 
979e			;if FORTH_PARSEV5 
979e			;	FORTH_END_BUFFER: equ 0 
979e			;else 
979e			FORTH_END_BUFFER: equ 127 
979e			;endif 
979e			 
979e			FORTH_TRUE: equ 1 
979e			FORTH_FALSE: equ 0 
979e			 
979e			if FORTH_PARSEV4 
979e			include "forth_stackops.asm" 
979e			endif 
979e			 
979e			if FORTH_PARSEV5 
979e			include "forth_stackopsv5.asm" 
979e			 
979e			; Stack operations for v5 parser on wards 
979e			; * DATA stack 
979e			; * LOOP stack 
979e			; * RETURN stack 
979e			 
979e			 
979e			 
979e			FORTH_CHK_DSP_UNDER: macro 
979e				push hl 
979e				push de 
979e				ld hl,(cli_data_sp) 
979e				ld de, cli_data_stack 
979e				call cmp16 
979e				jp c, fault_dsp_under 
979e				pop de 
979e				pop hl 
979e				endm 
979e			 
979e			 
979e			FORTH_CHK_RSP_UNDER: macro 
979e				push hl 
979e				push de 
979e				ld hl,(cli_ret_sp) 
979e				ld de, cli_ret_stack 
979e				call cmp16 
979e				jp c, fault_rsp_under 
979e				pop de 
979e				pop hl 
979e				endm 
979e			 
979e			FORTH_CHK_LOOP_UNDER: macro 
979e				push hl 
979e				push de 
979e				ld hl,(cli_loop_sp) 
979e				ld de, cli_loop_stack 
979e				call cmp16 
979e				jp c, fault_loop_under 
979e				pop de 
979e				pop hl 
979e				endm 
979e			 
979e			FORTH_ERR_TOS_NOTSTR: macro 
979e				; TOSO might need more for checks when used 
979e				push af 
979e				ld a,(hl) 
979e				cp DS_TYPE_STR 
979e				jp nz, type_faultn   
979e				pop af 
979e				endm 
979e			 
979e			FORTH_ERR_TOS_NOTNUM: macro 
979e				push af 
979e				ld a,(hl) 
979e				cp DS_TYPE_INUM 
979e				jp nz, type_faultn   
979e				pop af 
979e				endm 
979e			 
979e			 
979e			; increase data stack pointer and save hl to it 
979e				 
979e			FORTH_DSP_NEXT: macro 
979e				call macro_forth_dsp_next 
979e				endm 
979e			 
979e			 
979e			macro_forth_dsp_next: 
979e				if DEBUG_FORTH_STACK_GUARD 
979e cd d9 d3				call check_stacks 
97a1				endif 
97a1 e5				push hl 
97a2 d5				push de 
97a3 eb				ex de,hl 
97a4 2a 22 eb			ld hl,(cli_data_sp) 
97a7 23				inc hl 
97a8 23				inc hl 
97a9			 
97a9			; PARSEV5 
97a9 23				inc hl 
97aa 22 22 eb			ld (cli_data_sp),hl 
97ad 73				ld (hl), e 
97ae 23				inc hl 
97af 72				ld (hl), d 
97b0 d1				pop de 
97b1 e1				pop hl 
97b2				if DEBUG_FORTH_STACK_GUARD 
97b2 cd d9 d3				call check_stacks 
97b5				endif 
97b5 c9				ret 
97b6			 
97b6			 
97b6			; increase ret stack pointer and save hl to it 
97b6				 
97b6			FORTH_RSP_NEXT: macro 
97b6				call macro_forth_rsp_next 
97b6				endm 
97b6			 
97b6			macro_forth_rsp_next: 
97b6				if DEBUG_FORTH_STACK_GUARD 
97b6 cd d9 d3				call check_stacks 
97b9				endif 
97b9 e5				push hl 
97ba d5				push de 
97bb eb				ex de,hl 
97bc 2a 26 eb			ld hl,(cli_ret_sp) 
97bf 23				inc hl 
97c0 23				inc hl 
97c1 22 26 eb			ld (cli_ret_sp),hl 
97c4 73				ld (hl), e 
97c5 23				inc hl 
97c6 72				ld (hl), d 
97c7 d1				pop de 
97c8 e1				pop hl 
97c9				if DEBUG_FORTH_STACK_GUARD 
97c9 cd d9 d3				call check_stacks 
97cc				endif 
97cc c9				ret 
97cd			 
97cd			; get current ret stack pointer and save to hl  
97cd				 
97cd			FORTH_RSP_TOS: macro 
97cd				call macro_forth_rsp_tos 
97cd				endm 
97cd			 
97cd			macro_forth_rsp_tos: 
97cd				;push de 
97cd 2a 26 eb			ld hl,(cli_ret_sp) 
97d0 cd 08 98			call loadhlptrtohl 
97d3				;ld e, (hl) 
97d3				;inc hl 
97d3				;ld d, (hl) 
97d3				;ex de, hl 
97d3					if DEBUG_FORTH_WORDS 
97d3			;			DMARK "RST" 
97d3						CALLMONITOR 
97d3 cd 75 92			call break_point_state  
97d6				endm  
# End of macro CALLMONITOR
97d6					endif 
97d6				;pop de 
97d6 c9				ret 
97d7			 
97d7			; pop ret stack pointer 
97d7				 
97d7			FORTH_RSP_POP: macro 
97d7				call macro_forth_rsp_pop 
97d7				endm 
97d7			 
97d7			 
97d7			macro_forth_rsp_pop: 
97d7				if DEBUG_FORTH_STACK_GUARD 
97d7			;		DMARK "RPP" 
97d7 cd d9 d3				call check_stacks 
97da					FORTH_CHK_RSP_UNDER 
97da e5				push hl 
97db d5				push de 
97dc 2a 26 eb			ld hl,(cli_ret_sp) 
97df 11 e0 ea			ld de, cli_ret_stack 
97e2 cd 7b 8a			call cmp16 
97e5 da ed d4			jp c, fault_rsp_under 
97e8 d1				pop de 
97e9 e1				pop hl 
97ea				endm 
# End of macro FORTH_CHK_RSP_UNDER
97ea				endif 
97ea e5				push hl 
97eb 2a 26 eb			ld hl,(cli_ret_sp) 
97ee			 
97ee			 
97ee				if FORTH_ENABLE_FREE 
97ee			 
97ee					; get pointer 
97ee			 
97ee					push de 
97ee					push hl 
97ee			 
97ee					ld e, (hl) 
97ee					inc hl 
97ee					ld d, (hl) 
97ee			 
97ee					ex de, hl 
97ee					call free 
97ee			 
97ee					pop hl 
97ee					pop de 
97ee			 
97ee			 
97ee				endif 
97ee			 
97ee			 
97ee 2b				dec hl 
97ef 2b				dec hl 
97f0 22 26 eb			ld (cli_ret_sp), hl 
97f3				; do stack underflow checks 
97f3 e1				pop hl 
97f4				if DEBUG_FORTH_STACK_GUARD 
97f4 cd d9 d3				call check_stacks 
97f7					FORTH_CHK_RSP_UNDER 
97f7 e5				push hl 
97f8 d5				push de 
97f9 2a 26 eb			ld hl,(cli_ret_sp) 
97fc 11 e0 ea			ld de, cli_ret_stack 
97ff cd 7b 8a			call cmp16 
9802 da ed d4			jp c, fault_rsp_under 
9805 d1				pop de 
9806 e1				pop hl 
9807				endm 
# End of macro FORTH_CHK_RSP_UNDER
9807				endif 
9807 c9				ret 
9808			 
9808			 
9808			 
9808			; routine to load word pointed to by hl into hl 
9808			 
9808			loadhlptrtohl: 
9808			 
9808 d5				push de 
9809 5e				ld e, (hl) 
980a 23				inc hl 
980b 56				ld d, (hl) 
980c eb				ex de, hl 
980d d1				pop de 
980e			 
980e c9				ret 
980f			 
980f			 
980f			 
980f			 
980f			 
980f			; push a number held in HL onto the data stack 
980f			; entry point for pushing a value when already in hl used in function above 
980f			 
980f			forth_push_numhl: 
980f			 
980f e5				push hl    ; save value to push 
9810			 
9810			if DEBUG_FORTH_PUSH 
9810				; see if disabled 
9810			 
9810			 
9810				push af 
9810				ld a, (os_view_disable) 
9810				cp '*' 
9810				jr z, .pskip2 
9810				push hl 
9810			push hl 
9810				call clear_display 
9810			pop hl 
9810				ld a,h 
9810				ld hl, os_word_scratch 
9810				call hexout 
9810				pop hl 
9810				ld a,l 
9810				ld hl, os_word_scratch+2 
9810				call hexout 
9810			 
9810				ld hl, os_word_scratch+4 
9810				ld a,0 
9810				ld (hl),a 
9810				ld de,os_word_scratch 
9810					ld a, display_row_2 
9810					call str_at_display 
9810				ld de, .push_num 
9810				ld a, display_row_1 
9810			 
9810					call str_at_display 
9810			 
9810			 
9810				call update_display 
9810				call delay1s 
9810				call delay1s 
9810			.pskip2:  
9810			 
9810				pop af 
9810			endif	 
9810			 
9810			 
9810				FORTH_DSP_NEXT 
9810 cd 9e 97			call macro_forth_dsp_next 
9813				endm 
# End of macro FORTH_DSP_NEXT
9813			 
9813 2a 22 eb			ld hl, (cli_data_sp) 
9816			 
9816				; save item type 
9816 3e 02			ld a,  DS_TYPE_INUM 
9818 77				ld (hl), a 
9819 23				inc hl 
981a			 
981a				; get word off stack 
981a d1				pop de 
981b 7b				ld a,e 
981c 77				ld (hl), a 
981d 23				inc hl 
981e 7a				ld a,d 
981f 77				ld (hl), a 
9820			 
9820			if DEBUG_FORTH_PUSH 
9820				dec hl 
9820				dec hl 
9820				dec hl 
9820						DMARK "PH5" 
9820				CALLMONITOR 
9820			endif	 
9820			 
9820 c9				ret 
9821			 
9821			 
9821			; Push a string to stack pointed to by hl 
9821			 
9821			forth_push_str: 
9821			 
9821			if DEBUG_FORTH_PUSH 
9821						DMARK "PSQ" 
9821				CALLMONITOR 
9821			endif	 
9821			    
9821 e5				push hl 
9822 e5				push hl 
9823			 
9823 3e 00			ld a, 0   ; find end of string 
9825 cd c6 8e			call strlent       
9828			if DEBUG_FORTH_PUSH 
9828						DMARK "PQ2" 
9828				CALLMONITOR 
9828			endif	 
9828 eb				ex de, hl 
9829 e1				pop hl   ; get ptr to start of string 
982a			if DEBUG_FORTH_PUSH 
982a						DMARK "PQ3" 
982a				CALLMONITOR 
982a			endif	 
982a 19				add hl,de 
982b			if DEBUG_FORTH_PUSH 
982b						DMARK "PQE" 
982b				CALLMONITOR 
982b			endif	 
982b			 
982b 2b				dec hl    ; see if there is an optional trailing double quote 
982c 7e				ld a,(hl) 
982d fe 22			cp '"' 
982f 20 03			jr nz, .strnoq 
9831 3e 00			ld a, 0      ; get rid of double quote 
9833 77				ld (hl), a 
9834 23			.strnoq: inc hl 
9835			 
9835 3e 00			ld a, 0 
9837 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9838			 
9838 13				inc de ; add one for the type string 
9839 13				inc de ; add one for null term??? 
983a			 
983a				; tos is get string pointer again 
983a				; de contains space to allocate 
983a				 
983a d5				push de 
983b			 
983b eb				ex de, hl 
983c			 
983c				;push af 
983c			 
983c			if DEBUG_FORTH_PUSH 
983c						DMARK "PHm" 
983c				CALLMONITOR 
983c			endif	 
983c cd 24 8f			call malloc	; on ret hl now contains allocated memory 
983f				if DEBUG_FORTH_MALLOC_GUARD 
983f cc 3f c3				call z,malloc_error 
9842				endif 
9842			 
9842				 
9842 c1				pop bc    ; get length 
9843 d1				pop de   ;  get string start    
9844			 
9844				; hl has destination from malloc 
9844			 
9844 eb				ex de, hl    ; prep for ldir 
9845			 
9845 e5				push hl   ; save malloc area for DSP later 
9846			 
9846			if DEBUG_FORTH_PUSH 
9846						DMARK "PHc" 
9846				CALLMONITOR 
9846			endif	 
9846			 
9846			 
9846 ed b0			ldir 
9848			 
9848			 
9848				; push malloc to data stack     macro?????  
9848			 
9848				FORTH_DSP_NEXT 
9848 cd 9e 97			call macro_forth_dsp_next 
984b				endm 
# End of macro FORTH_DSP_NEXT
984b			 
984b				; save value and type 
984b			 
984b 2a 22 eb			ld hl, (cli_data_sp) 
984e			 
984e				; save item type 
984e 3e 01			ld a,  DS_TYPE_STR 
9850 77				ld (hl), a 
9851 23				inc hl 
9852			 
9852				; get malloc word off stack 
9852 d1				pop de 
9853 73				ld (hl), e 
9854 23				inc hl 
9855 72				ld (hl), d 
9856			 
9856			 
9856			 
9856			if DEBUG_FORTH_PUSH 
9856				ld hl, (cli_data_sp) 
9856						DMARK "PHS" 
9856				CALLMONITOR 
9856			;	ex de,hl 
9856			endif	 
9856				; in case of spaces, skip the ptr past the copied string 
9856				;pop af 
9856				;ld (cli_origptr),hl 
9856			 
9856 c9				ret 
9857			 
9857			 
9857			 
9857			; TODO ascii push input onto stack given hl to start of input 
9857			 
9857			; identify type 
9857			; if starts with a " then a string 
9857			; otherwise it is a number 
9857			;  
9857			; if a string 
9857			;     scan for ending " to get length of string to malloc for + 1 
9857			;     malloc 
9857			;     put pointer to string on stack first byte flags as string 
9857			; 
9857			; else a number 
9857			;    look for number format identifier 
9857			;    $xx hex 
9857			;    %xxxxx bin 
9857			;    xxxxx decimal 
9857			;    convert number to 16bit word.  
9857			;    malloc word + 1 with flag to identiy as num 
9857			;    put pointer to number on stack 
9857			;   
9857			;  
9857			  
9857			forth_apush: 
9857				; kernel push 
9857			 
9857			if DEBUG_FORTH_PUSH 
9857						DMARK "PSH" 
9857				CALLMONITOR 
9857			endif	 
9857				; identify input type 
9857			 
9857 7e				ld a,(hl) 
9858 fe 22			cp '"' 
985a 28 0a			jr z, .fapstr 
985c fe 24			cp '$' 
985e ca 86 98			jp z, .faphex 
9861 fe 25			cp '%' 
9863 ca 6e 98			jp z, .fapbin 
9866			;	cp 'b' 
9866			;	jp z, .fabin 
9866				; else decimal 
9866			 
9866				; TODO do decimal conversion 
9866				; decimal is stored as a 16bit word 
9866			 
9866				; by default everything is a string if type is not detected 
9866			.fapstr: ; 
9866 fe 22			cp '"' 
9868 20 01			jr nz, .strnoqu 
986a 23				inc hl 
986b			.strnoqu: 
986b c3 21 98			jp forth_push_str 
986e			 
986e			 
986e			 
986e			.fapbin:    ; push a binary string.  
986e 11 00 00			ld de, 0   ; hold a 16bit value 
9871			 
9871 23			.fapbinshift:	inc hl  
9872 7e				ld a,(hl) 
9873 fe 00			cp 0     ; done scanning  
9875 28 0b			jr z, .fapbdone  	; got it in HL so push  
9877			 
9877				; left shift de 
9877 eb				ex de, hl	 
9878 29				add hl, hl 
9879			 
9879				; is 1 
9879 fe 31			cp '1' 
987b 20 02			jr nz, .binzero 
987d cb 4d			bit 1, l 
987f			.binzero: 
987f eb				ex de, hl	 ; save current de 
9880 18 ef			jr .fapbinshift 
9882			 
9882			.fapbdone: 
9882 eb				ex de, hl 
9883 c3 0f 98			jp forth_push_numhl 
9886			 
9886			 
9886			.faphex:   ; hex is always stored as a 16bit word 
9886				; skip number prefix 
9886 23				inc hl 
9887				; turn ascii into number 
9887 cd 14 8e			call get_word_hl	; ret 16bit word in hl 
988a			 
988a c3 0f 98			jp forth_push_numhl 
988d			 
988d 00				 nop 
988e			 
988e			.fabin:   ; TODO bin conversion 
988e			 
988e			 
988e c9				ret 
988f			 
988f			 
988f			; get either a string ptr or a 16bit word from the data stack 
988f			 
988f			FORTH_DSP: macro 
988f				call macro_forth_dsp 
988f				endm 
988f			 
988f			macro_forth_dsp: 
988f				; data stack pointer points to current word on tos 
988f			 
988f 2a 22 eb			ld hl,(cli_data_sp) 
9892			 
9892				if DEBUG_FORTH_PUSH 
9892						DMARK "DSP" 
9892			 
9892					call display_data_sp 
9892				;call break_point_state 
9892				;rst 030h 
9892				CALLMONITOR 
9892				endif 
9892			 
9892 c9				ret 
9893			 
9893			; return hl to start of value on stack 
9893			 
9893			FORTH_DSP_VALUE: macro 
9893				call macro_forth_dsp_value 
9893				endm 
9893			 
9893			macro_forth_dsp_value: 
9893			 
9893				FORTH_DSP 
9893 cd 8f 98			call macro_forth_dsp 
9896				endm 
# End of macro FORTH_DSP
9896			 
9896 d5				push de 
9897			 
9897 23				inc hl ; skip type 
9898			 
9898 5e				ld e, (hl) 
9899 23				inc hl 
989a 56				ld d, (hl) 
989b eb				ex de,hl  
989c			 
989c d1				pop de 
989d			 
989d c9				ret 
989e			 
989e			; return hl to start of value to second item on stack 
989e			 
989e			FORTH_DSP_VALUEM1: macro 
989e				call macro_forth_dsp_value_m1 
989e				endm 
989e			 
989e			macro_forth_dsp_value_m1: 
989e			 
989e				FORTH_DSP 
989e cd 8f 98			call macro_forth_dsp 
98a1				endm 
# End of macro FORTH_DSP
98a1			 
98a1 2b				dec hl 
98a2 2b				dec hl 
98a3			;	dec hl 
98a3			 
98a3 d5				push de 
98a4			 
98a4 5e				ld e, (hl) 
98a5 23				inc hl 
98a6 56				ld d, (hl) 
98a7 eb				ex de,hl  
98a8			 
98a8 d1				pop de 
98a9			 
98a9 c9				ret 
98aa			 
98aa				 
98aa			 
98aa			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
98aa			 
98aa			FORTH_DSP_POP: macro 
98aa				call macro_forth_dsp_pop 
98aa				endm 
98aa			 
98aa			 
98aa			; get the tos data type 
98aa			 
98aa			FORTH_DSP_TYPE:   macro 
98aa			 
98aa				;FORTH_DSP_VALUE 
98aa				FORTH_DSP 
98aa				 
98aa				; hl points to value 
98aa				; check type 
98aa			 
98aa				ld a,(hl) 
98aa			 
98aa				endm 
98aa			 
98aa			; load the tos value into hl 
98aa			 
98aa			 
98aa			FORTH_DSP_VALUEHL:  macro 
98aa				call macro_dsp_valuehl 
98aa				endm 
98aa			 
98aa			 
98aa			 
98aa			macro_dsp_valuehl: 
98aa				FORTH_DSP_VALUE 
98aa cd 93 98			call macro_forth_dsp_value 
98ad				endm 
# End of macro FORTH_DSP_VALUE
98ad			 
98ad				;FORTH_ERR_TOS_NOTNUM 
98ad			 
98ad				;inc hl   ; skip type id 
98ad			 
98ad			;	push de 
98ad			; 
98ad			;	ld e, (hl) 
98ad			;	inc hl 
98ad			;	ld d, (hl) 
98ad			;	ex de,hl  
98ad			 
98ad			;	pop de 
98ad			 
98ad				if DEBUG_FORTH_PUSH 
98ad						DMARK "DVL" 
98ad				CALLMONITOR 
98ad				endif 
98ad c9				ret 
98ae			 
98ae			forth_apushstrhl:      
98ae				; push of string requires use of cli_origptr 
98ae				; bodge use 
98ae			 
98ae				; get current cli_origptr, save, update with temp pointer  
98ae ed 5b 3e eb		ld de, (cli_origptr) 
98b2 22 3e eb			ld (cli_origptr), hl 
98b5 d5				push de 
98b6 cd 57 98			call forth_apush 
98b9 d1				pop de 
98ba ed 53 3e eb		ld (cli_origptr), de 
98be c9			        ret	 
98bf			 
98bf			 
98bf			; increase loop stack pointer and save hl to it 
98bf				 
98bf			FORTH_LOOP_NEXT: macro 
98bf				call macro_forth_loop_next 
98bf				;nop 
98bf				endm 
98bf			 
98bf			macro_forth_loop_next: 
98bf				if DEBUG_FORTH_STACK_GUARD 
98bf cd d9 d3				call check_stacks 
98c2				endif 
98c2 e5				push hl 
98c3 d5				push de 
98c4 eb				ex de,hl 
98c5 2a 24 eb			ld hl,(cli_loop_sp) 
98c8 23				inc hl 
98c9 23				inc hl 
98ca					if DEBUG_FORTH_WORDS 
98ca						DMARK "LNX" 
98ca f5				push af  
98cb 3a df 98			ld a, (.dmark)  
98ce 32 7a ee			ld (debug_mark),a  
98d1 3a e0 98			ld a, (.dmark+1)  
98d4 32 7b ee			ld (debug_mark+1),a  
98d7 3a e1 98			ld a, (.dmark+2)  
98da 32 7c ee			ld (debug_mark+2),a  
98dd 18 03			jr .pastdmark  
98df ..			.dmark: db "LNX"  
98e2 f1			.pastdmark: pop af  
98e3			endm  
# End of macro DMARK
98e3						CALLMONITOR 
98e3 cd 75 92			call break_point_state  
98e6				endm  
# End of macro CALLMONITOR
98e6					endif 
98e6 22 24 eb			ld (cli_loop_sp),hl 
98e9 73				ld (hl), e 
98ea 23				inc hl 
98eb 72				ld (hl), d 
98ec d1				pop de    ; been reversed so save a swap on restore 
98ed e1				pop hl 
98ee				if DEBUG_FORTH_STACK_GUARD 
98ee cd d9 d3				call check_stacks 
98f1				endif 
98f1 c9				ret 
98f2			 
98f2			; get current ret stack pointer and save to hl  
98f2				 
98f2			FORTH_LOOP_TOS: macro 
98f2				call macro_forth_loop_tos 
98f2				endm 
98f2			 
98f2			macro_forth_loop_tos: 
98f2 d5				push de 
98f3 2a 24 eb			ld hl,(cli_loop_sp) 
98f6 5e				ld e, (hl) 
98f7 23				inc hl 
98f8 56				ld d, (hl) 
98f9 eb				ex de, hl 
98fa d1				pop de 
98fb c9				ret 
98fc			 
98fc			; pop loop stack pointer 
98fc				 
98fc			FORTH_LOOP_POP: macro 
98fc				call macro_forth_loop_pop 
98fc				endm 
98fc			 
98fc			 
98fc			macro_forth_loop_pop: 
98fc				if DEBUG_FORTH_STACK_GUARD 
98fc					DMARK "LPP" 
98fc f5				push af  
98fd 3a 11 99			ld a, (.dmark)  
9900 32 7a ee			ld (debug_mark),a  
9903 3a 12 99			ld a, (.dmark+1)  
9906 32 7b ee			ld (debug_mark+1),a  
9909 3a 13 99			ld a, (.dmark+2)  
990c 32 7c ee			ld (debug_mark+2),a  
990f 18 03			jr .pastdmark  
9911 ..			.dmark: db "LPP"  
9914 f1			.pastdmark: pop af  
9915			endm  
# End of macro DMARK
9915 cd d9 d3				call check_stacks 
9918					FORTH_CHK_LOOP_UNDER 
9918 e5				push hl 
9919 d5				push de 
991a 2a 24 eb			ld hl,(cli_loop_sp) 
991d 11 de e9			ld de, cli_loop_stack 
9920 cd 7b 8a			call cmp16 
9923 da f3 d4			jp c, fault_loop_under 
9926 d1				pop de 
9927 e1				pop hl 
9928				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9928				endif 
9928 e5				push hl 
9929 2a 24 eb			ld hl,(cli_loop_sp) 
992c 2b				dec hl 
992d 2b				dec hl 
992e 22 24 eb			ld (cli_loop_sp), hl 
9931				; TODO do stack underflow checks 
9931 e1				pop hl 
9932				if DEBUG_FORTH_STACK_GUARD 
9932 cd d9 d3				call check_stacks 
9935					FORTH_CHK_LOOP_UNDER 
9935 e5				push hl 
9936 d5				push de 
9937 2a 24 eb			ld hl,(cli_loop_sp) 
993a 11 de e9			ld de, cli_loop_stack 
993d cd 7b 8a			call cmp16 
9940 da f3 d4			jp c, fault_loop_under 
9943 d1				pop de 
9944 e1				pop hl 
9945				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9945				endif 
9945 c9				ret 
9946			 
9946			macro_forth_dsp_pop: 
9946			 
9946 e5				push hl 
9947			 
9947				; release malloc data 
9947			 
9947				if DEBUG_FORTH_STACK_GUARD 
9947 cd d9 d3				call check_stacks 
994a					FORTH_CHK_DSP_UNDER 
994a e5				push hl 
994b d5				push de 
994c 2a 22 eb			ld hl,(cli_data_sp) 
994f 11 dc e8			ld de, cli_data_stack 
9952 cd 7b 8a			call cmp16 
9955 da e7 d4			jp c, fault_dsp_under 
9958 d1				pop de 
9959 e1				pop hl 
995a				endm 
# End of macro FORTH_CHK_DSP_UNDER
995a				endif 
995a				;ld hl,(cli_data_sp) 
995a			if DEBUG_FORTH_DOT 
995a				DMARK "DPP" 
995a				CALLMONITOR 
995a			endif	 
995a			 
995a			 
995a			if FORTH_ENABLE_DSPPOPFREE 
995a			 
995a				FORTH_DSP 
995a cd 8f 98			call macro_forth_dsp 
995d				endm 
# End of macro FORTH_DSP
995d			 
995d 7e				ld a, (hl) 
995e fe 01			cp DS_TYPE_STR 
9960 20 07			jr nz, .skippopfree 
9962			 
9962				FORTH_DSP_VALUEHL 
9962 cd aa 98			call macro_dsp_valuehl 
9965				endm 
# End of macro FORTH_DSP_VALUEHL
9965 00				nop 
9966			if DEBUG_FORTH_DOT 
9966				DMARK "DPf" 
9966				CALLMONITOR 
9966			endif	 
9966 cd ee 8f			call free 
9969			.skippopfree: 
9969				 
9969			 
9969			endif 
9969			 
9969			if DEBUG_FORTH_DOT_KEY 
9969				DMARK "DP2" 
9969				CALLMONITOR 
9969			endif	 
9969			 
9969				; move pointer down 
9969			 
9969 2a 22 eb			ld hl,(cli_data_sp) 
996c 2b				dec hl 
996d 2b				dec hl 
996e			; PARSEV5 
996e 2b				dec hl 
996f 22 22 eb			ld (cli_data_sp), hl 
9972			 
9972				if DEBUG_FORTH_STACK_GUARD 
9972 cd d9 d3				call check_stacks 
9975					FORTH_CHK_DSP_UNDER 
9975 e5				push hl 
9976 d5				push de 
9977 2a 22 eb			ld hl,(cli_data_sp) 
997a 11 dc e8			ld de, cli_data_stack 
997d cd 7b 8a			call cmp16 
9980 da e7 d4			jp c, fault_dsp_under 
9983 d1				pop de 
9984 e1				pop hl 
9985				endm 
# End of macro FORTH_CHK_DSP_UNDER
9985				endif 
9985			 
9985 e1				pop hl 
9986			 
9986 c9				ret 
9987			 
9987			getwordathl: 
9987				; hl points to an address 
9987				; load hl with the word at that address 
9987			 
9987 d5				push de 
9988			 
9988 5e				ld e, (hl) 
9989 23				inc hl 
998a 56				ld d, (hl) 
998b eb				ex de, hl 
998c			 
998c d1				pop de 
998d c9				ret 
998e			 
998e			 
998e			 
998e			 
998e			 
998e			; eof 
998e			 
# End of file forth_stackopsv5.asm
998e			endif 
998e			 
998e			user_word_eol:  
998e				; hl contains the pointer to where to create a linked list item from the end 
998e				; of the user dict to continue on at the system word dict 
998e				 
998e				; poke the stub of the word list linked list to repoint to rom words 
998e			 
998e				; stub format 
998e				; db   word id 
998e				; dw    link to next word 
998e			        ; db char length of token 
998e				; db string + 0 term 
998e				; db exec code....  
998e			 
998e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9990 77				ld (hl), a		; word id 
9991 23				inc hl 
9992			 
9992 11 58 9b			ld de, sysdict 
9995 73				ld (hl), e		; next word link ie system dict 
9996 23				inc hl 
9997 72				ld (hl), d		; next word link ie system dict 
9998 23				inc hl	 
9999			 
9999			;	ld (hl), sysdict		; next word link ie system dict 
9999			;	inc hl 
9999			;	inc hl 
9999			 
9999			;	inc hl 
9999			;	inc hl 
9999			 
9999 3e 02			ld a, 2			; word length is 0 
999b 77				ld (hl), a	 
999c 23				inc hl 
999d			 
999d 3e 7e			ld a, '~'			; word length is 0 
999f 77				ld (hl), a	 
99a0 23				inc hl 
99a1 3e 00			ld a, 0			; save empty word 
99a3 77				ld (hl), a 
99a4			 
99a4 c9				ret 
99a5			 
99a5				 
99a5			 
99a5			forthexec_cleanup: 
99a5				FORTH_RSP_POP 
99a5 cd d7 97			call macro_forth_rsp_pop 
99a8				endm 
# End of macro FORTH_RSP_POP
99a8 c9				ret 
99a9			 
99a9			forth_call_hl: 
99a9				; taking hl 
99a9 e5				push hl 
99aa c9				ret 
99ab			 
99ab			; this is called to reset Forth system but keep existing uwords etc 
99ab			 
99ab			forth_warmstart: 
99ab				; setup stack over/under flow checks 
99ab				if DEBUG_FORTH_STACK_GUARD 
99ab cd bf d3				call chk_stk_init 
99ae				endif 
99ae			 
99ae				; init stack pointers  - * these stacks go upwards *  
99ae 21 e0 ea			ld hl, cli_ret_stack 
99b1 22 26 eb			ld (cli_ret_sp), hl	 
99b4				; set bottom of stack 
99b4 3e 00			ld a,0 
99b6 77				ld (hl),a 
99b7 23				inc hl 
99b8 77				ld (hl),a 
99b9			 
99b9 21 dc e8			ld hl, cli_data_stack 
99bc 22 22 eb			ld (cli_data_sp), hl	 
99bf				; set bottom of stack 
99bf 3e 00			ld a,0 
99c1 77				ld (hl),a 
99c2 23				inc hl 
99c3 77				ld (hl),a 
99c4			 
99c4 21 de e9			ld hl, cli_loop_stack 
99c7 22 24 eb			ld (cli_loop_sp), hl	 
99ca				; set bottom of stack 
99ca 3e 00			ld a,0 
99cc 77				ld (hl),a 
99cd 23				inc hl 
99ce 77				ld (hl),a 
99cf			 
99cf				; init extent of current open file 
99cf			 
99cf 3e 00			ld a, 0 
99d1 32 5c eb			ld (store_openext), a 
99d4			 
99d4 c9				ret 
99d5			 
99d5			 
99d5			; Cold Start - this is called to setup the whole Forth system 
99d5			 
99d5			forth_init: 
99d5			 
99d5				; setup stack over/under flow checks 
99d5			 
99d5			;	if DEBUG_FORTH_STACK_GUARD 
99d5			;		call chk_stk_init 
99d5			;	endif 
99d5			 
99d5				; enable auto display updates (slow.....) 
99d5			 
99d5 3e 01			ld a, 1 
99d7 32 3c eb			ld (cli_autodisplay), a 
99da			 
99da			 
99da			 
99da				; show start up screen 
99da			 
99da cd 34 88			call clear_display 
99dd			 
99dd 3e 00			ld a,0 
99df 32 5e eb			ld (f_cursor_ptr), a 
99e2			 
99e2				; set start of word list in start of ram - for use when creating user words 
99e2			 
99e2 21 8a d6			ld hl, baseram 
99e5 22 72 e6			ld (os_last_new_uword), hl 
99e8 cd 8e 99			call user_word_eol 
99eb				 
99eb			;		call display_data_sp 
99eb			;		call next_page_prompt 
99eb			 
99eb			 
99eb			 
99eb			 
99eb c9				ret 
99ec			 
99ec .. 00		.bootforth: db " Forth Kernel Init ",0 
9a00			 
9a00			; TODO push to stack 
9a00			 
9a00			;  
9a00			 
9a00			if FORTH_PARSEV2 
9a00			 
9a00			 
9a00				include "forth_parserv2.asm" 
9a00			 
9a00			endif 
9a00			 
9a00			 
9a00			; parse cli version 1 
9a00			 
9a00			if FORTH_PARSEV1 
9a00			 
9a00			 
9a00			 
9a00			      include "forth_parserv1.asm" 
9a00			endif 
9a00				 
9a00			if FORTH_PARSEV3 
9a00			 
9a00			 
9a00			 
9a00			      include "forth_parserv3.asm" 
9a00				include "forth_wordsv3.asm" 
9a00			endif 
9a00			 
9a00			if FORTH_PARSEV4 
9a00			 
9a00			 
9a00			 
9a00			      include "forth_parserv4.asm" 
9a00				include "forth_wordsv4.asm" 
9a00			endif 
9a00			 
9a00			if FORTH_PARSEV5 
9a00			 
9a00			 
9a00			 
9a00			      include "forth_parserv5.asm" 
9a00			 
9a00			 
9a00			; A better parser without using malloc and string copies all over the place.  
9a00			; Exec in situ should be faster 
9a00			 
9a00			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9a00			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9a00			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9a00			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9a00			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9a00			WORD_SYS_END: equ 0   ; Opcode for all user words 
9a00			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9a00			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9a00			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9a00			 
9a00			; Core word preamble macro 
9a00			 
9a00			CWHEAD:   macro nxtword opcode lit len opflags 
9a00				db WORD_SYS_CORE+opcode             
9a00				; internal op code number 
9a00				dw nxtword            
9a00				; link to next dict word block 
9a00				db len + 1 
9a00				; literal length of dict word inc zero term 
9a00				db lit,0              
9a00				; literal dict word 
9a00			        ; TODO db opflags        
9a00				endm 
9a00			 
9a00			 
9a00			NEXTW: macro  
9a00				jp macro_next 
9a00				endm 
9a00			 
9a00			macro_next: 
9a00			if DEBUG_FORTH_PARSE_KEY 
9a00				DMARK "NXT" 
9a00				CALLMONITOR 
9a00			endif	 
9a00			;	inc hl  ; skip token null term  
9a00 ed 4b 40 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9a04 ed 5b 3e eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9a08 2a 76 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9a0b			if DEBUG_FORTH_PARSE_KEY 
9a0b				DMARK "}AA" 
9a0b				CALLMONITOR 
9a0b			endif	 
9a0b c3 0e 9b			jp execnext 
9a0e				;jp exec1 
9a0e			       
9a0e			 
9a0e			 
9a0e			; Another go at the parser to compile  
9a0e			 
9a0e			 
9a0e			; TODO rework parser to change all of the string words to byte tokens 
9a0e			; TODO do a search for  
9a0e			 
9a0e			; TODO first run normal parser to zero term sections 
9a0e			; TODO for each word do a token look up to get the op code 
9a0e			; TODO need some means to flag to the exec that this is a byte code form    
9a0e			 
9a0e			 
9a0e			forthcompile: 
9a0e			 
9a0e			; 
9a0e			; line parse: 
9a0e			;       parse raw input buffer 
9a0e			;       tokenise the words 
9a0e			;       malloc new copy (for looping etc) 
9a0e			;       copy to malloc + current pc in line to start of string and add line term 
9a0e			;       save on new rsp 
9a0e			; 
9a0e			 
9a0e			; hl to point to the line to tokenise 
9a0e			 
9a0e			;	push hl 
9a0e 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9a11			 
9a11			;	ld a,0		; string term on input 
9a11			;	call strlent 
9a11			 
9a11			;	ld (os_tok_len), hl	 ; save string length 
9a11			 
9a11			;if DEBUG_FORTH_TOK 
9a11			;	ex de,hl		 
9a11			;endif 
9a11			 
9a11			;	pop hl 		; get back string pointer 
9a11			 
9a11			if DEBUG_FORTH_TOK 
9a11						DMARK "TOc" 
9a11				CALLMONITOR 
9a11			endif 
9a11 7e			.cptoken2:    ld a,(hl) 
9a12 23				inc hl 
9a13 fe 7f			cp FORTH_END_BUFFER 
9a15 28 29			jr z, .cptokendone2 
9a17 fe 00			cp 0 
9a19 28 25			jr z, .cptokendone2 
9a1b fe 22			cp '"' 
9a1d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9a1f fe 20			cp ' ' 
9a21 20 ee			jr nz,  .cptoken2 
9a23			 
9a23			; TODO consume comments held between ( and ) 
9a23			 
9a23				; we have a space so change to zero term for dict match later 
9a23 2b				dec hl 
9a24 3e 00			ld a,0 
9a26 77				ld (hl), a 
9a27 23				inc hl 
9a28 18 e7			jr .cptoken2 
9a2a				 
9a2a			 
9a2a			.cptokenstr2: 
9a2a				; skip all white space until either eol (because forgot to term) or end double quote 
9a2a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9a2a				;inc hl ; skip current double quote 
9a2a 7e				ld a,(hl) 
9a2b 23				inc hl 
9a2c fe 22			cp '"' 
9a2e 28 e1			jr z, .cptoken2 
9a30 fe 7f			cp FORTH_END_BUFFER 
9a32 28 0c			jr z, .cptokendone2 
9a34 fe 00			cp 0 
9a36 28 08			jr z, .cptokendone2 
9a38 fe 20			cp ' ' 
9a3a 28 02			jr z, .cptmp2 
9a3c 18 ec			jr .cptokenstr2 
9a3e			 
9a3e			.cptmp2:	; we have a space so change to zero term for dict match later 
9a3e				;dec hl 
9a3e				;ld a,"-"	; TODO remove this when working 
9a3e				;ld (hl), a 
9a3e				;inc hl 
9a3e 18 ea			jr .cptokenstr2 
9a40			 
9a40			.cptokendone2: 
9a40				;inc hl 
9a40 3e 7f			ld a, FORTH_END_BUFFER 
9a42 77				ld (hl),a 
9a43 23				inc hl 
9a44 3e 21			ld a, '!' 
9a46 77				ld (hl),a 
9a47			 
9a47 2a 76 e6			ld hl,(os_tok_ptr) 
9a4a			         
9a4a			if DEBUG_FORTH_TOK 
9a4a						DMARK "Tc1" 
9a4a				CALLMONITOR 
9a4a			endif 
9a4a			 
9a4a				; push exec string to top of return stack 
9a4a				FORTH_RSP_NEXT 
9a4a cd b6 97			call macro_forth_rsp_next 
9a4d				endm 
# End of macro FORTH_RSP_NEXT
9a4d c9				ret 
9a4e			 
9a4e			; Another go at the parser need to simplify the process 
9a4e			 
9a4e			forthparse: 
9a4e			 
9a4e			; 
9a4e			; line parse: 
9a4e			;       parse raw input buffer 
9a4e			;       tokenise the words 
9a4e			;       malloc new copy (for looping etc) 
9a4e			;       copy to malloc + current pc in line to start of string and add line term 
9a4e			;       save on new rsp 
9a4e			; 
9a4e			 
9a4e			; hl to point to the line to tokenise 
9a4e			 
9a4e			;	push hl 
9a4e 22 76 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9a51			 
9a51			;	ld a,0		; string term on input 
9a51			;	call strlent 
9a51			 
9a51			;	ld (os_tok_len), hl	 ; save string length 
9a51			 
9a51			;if DEBUG_FORTH_TOK 
9a51			;	ex de,hl		 
9a51			;endif 
9a51			 
9a51			;	pop hl 		; get back string pointer 
9a51			 
9a51			if DEBUG_FORTH_TOK 
9a51						DMARK "TOK" 
9a51				CALLMONITOR 
9a51			endif 
9a51 7e			.ptoken2:    ld a,(hl) 
9a52 23				inc hl 
9a53 fe 7f			cp FORTH_END_BUFFER 
9a55 28 29			jr z, .ptokendone2 
9a57 fe 00			cp 0 
9a59 28 25			jr z, .ptokendone2 
9a5b fe 22			cp '"' 
9a5d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9a5f fe 20			cp ' ' 
9a61 20 ee			jr nz,  .ptoken2 
9a63			 
9a63			; TODO consume comments held between ( and ) 
9a63			 
9a63				; we have a space so change to zero term for dict match later 
9a63 2b				dec hl 
9a64 3e 00			ld a,0 
9a66 77				ld (hl), a 
9a67 23				inc hl 
9a68 18 e7			jr .ptoken2 
9a6a				 
9a6a			 
9a6a			.ptokenstr2: 
9a6a				; skip all white space until either eol (because forgot to term) or end double quote 
9a6a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9a6a				;inc hl ; skip current double quote 
9a6a 7e				ld a,(hl) 
9a6b 23				inc hl 
9a6c fe 22			cp '"' 
9a6e 28 e1			jr z, .ptoken2 
9a70 fe 7f			cp FORTH_END_BUFFER 
9a72 28 0c			jr z, .ptokendone2 
9a74 fe 00			cp 0 
9a76 28 08			jr z, .ptokendone2 
9a78 fe 20			cp ' ' 
9a7a 28 02			jr z, .ptmp2 
9a7c 18 ec			jr .ptokenstr2 
9a7e			 
9a7e			.ptmp2:	; we have a space so change to zero term for dict match later 
9a7e				;dec hl 
9a7e				;ld a,"-"	; TODO remove this when working 
9a7e				;ld (hl), a 
9a7e				;inc hl 
9a7e 18 ea			jr .ptokenstr2 
9a80			 
9a80			.ptokendone2: 
9a80				;inc hl 
9a80 3e 7f			ld a, FORTH_END_BUFFER 
9a82 77				ld (hl),a 
9a83 23				inc hl 
9a84 3e 21			ld a, '!' 
9a86 77				ld (hl),a 
9a87			 
9a87 2a 76 e6			ld hl,(os_tok_ptr) 
9a8a			         
9a8a			if DEBUG_FORTH_TOK 
9a8a						DMARK "TK1" 
9a8a				CALLMONITOR 
9a8a			endif 
9a8a			 
9a8a				; push exec string to top of return stack 
9a8a				FORTH_RSP_NEXT 
9a8a cd b6 97			call macro_forth_rsp_next 
9a8d				endm 
# End of macro FORTH_RSP_NEXT
9a8d c9				ret 
9a8e			 
9a8e			; 
9a8e			;	; malloc size + buffer pointer + if is loop flag 
9a8e			;	ld hl,(os_tok_len) 		 ; get string length 
9a8e			; 
9a8e			;	ld a,l 
9a8e			; 
9a8e			;	cp 0			; we dont want to use a null string 
9a8e			;	ret z 
9a8e			; 
9a8e			;;	add 3    ; prefix malloc with buffer for current word ptr 
9a8e			; 
9a8e			;	add 5     ; TODO when certain not over writing memory remove 
9a8e			; 
9a8e			;		 
9a8e			; 
9a8e			;if DEBUG_FORTH_TOK 
9a8e			;			DMARK "TKE" 
9a8e			;	CALLMONITOR 
9a8e			;endif 
9a8e			; 
9a8e			;	ld l,a 
9a8e			;	ld h,0 
9a8e			;;	push hl   ; save required space for the copy later 
9a8e			;	call malloc 
9a8e			;if DEBUG_FORTH_TOK 
9a8e			;			DMARK "TKM" 
9a8e			;	CALLMONITOR 
9a8e			;endif 
9a8e			;	if DEBUG_FORTH_MALLOC_GUARD 
9a8e			;		push af 
9a8e			;		call ishlzero 
9a8e			;;		ld a, l 
9a8e			;;		add h 
9a8e			;;		cp 0 
9a8e			;		pop af 
9a8e			;		 
9a8e			;		call z,malloc_error 
9a8e			;	endif 
9a8e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9a8e			; 
9a8e			; 
9a8e			;if DEBUG_FORTH_TOK 
9a8e			;			DMARK "TKR" 
9a8e			;	CALLMONITOR 
9a8e			;endif 
9a8e			; 
9a8e			;	FORTH_RSP_NEXT 
9a8e			; 
9a8e			;	;inc hl	 ; go past current buffer pointer 
9a8e			;	;inc hl 
9a8e			;	;inc hl   ; and past if loop flag 
9a8e			;		; TODO Need to set flag  
9a8e			; 
9a8e			;	 
9a8e			;	 
9a8e			;	ex de,hl	; malloc is dest 
9a8e			;	ld hl, (os_tok_len) 
9a8e			;;	pop bc 
9a8e			;	ld c, l                
9a8e			;	ld b,0 
9a8e			;	ld hl, (os_tok_ptr) 
9a8e			; 
9a8e			;if DEBUG_FORTH_TOK 
9a8e			;			DMARK "TKT" 
9a8e			;	CALLMONITOR 
9a8e			;endif 
9a8e			; 
9a8e			;	; do str cpy 
9a8e			; 
9a8e			;	ldir      ; copy byte in hl to de 
9a8e			; 
9a8e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9a8e			; 
9a8e			;if DEBUG_FORTH_TOK 
9a8e			; 
9a8e			;			DMARK "TKY" 
9a8e			;	CALLMONITOR 
9a8e			;endif 
9a8e			;	;ld a,0 
9a8e			;	;ld a,FORTH_END_BUFFER 
9a8e			;	ex de, hl 
9a8e			;	;dec hl			 ; go back over the space delim at the end of word 
9a8e			;	;ld (hl),a 
9a8e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9a8e			;	ld a,FORTH_END_BUFFER 
9a8e			;	ld (hl),a 
9a8e			;	inc hl 
9a8e			;	ld a,FORTH_END_BUFFER 
9a8e			;	ld (hl),a 
9a8e			; 
9a8e			;	; init the malloc area data 
9a8e			;	; set pc for in current area 
9a8e			;	;ld hl, (os_tok_malloc) 
9a8e			;	;inc hl 
9a8e			;	;inc hl 
9a8e			;	;inc hl 
9a8e			;	;ex de,hl 
9a8e			;	;ld hl, (os_tok_malloc) 
9a8e			;	;ld (hl),e 
9a8e			;	;inc hl 
9a8e			;	;ld (hl),d 
9a8e			; 
9a8e			; 
9a8e			;	ld hl,(os_tok_malloc) 
9a8e			;if DEBUG_FORTH_PARSE_KEY 
9a8e			;			DMARK "TKU" 
9a8e			;	CALLMONITOR 
9a8e			;endif 
9a8e			; 
9a8e			;	ret 
9a8e			 
9a8e			forthexec: 
9a8e			 
9a8e			; line exec: 
9a8e			; forth parser 
9a8e			 
9a8e			; 
9a8e			;       get current exec line on rsp 
9a8e			 
9a8e				FORTH_RSP_TOS 
9a8e cd cd 97			call macro_forth_rsp_tos 
9a91				endm 
# End of macro FORTH_RSP_TOS
9a91			 
9a91			;       restore current pc - hl points to malloc of data 
9a91			 
9a91				;ld e, (hl) 
9a91				;inc hl 
9a91				;ld d, (hl) 
9a91				;ex de,hl 
9a91			 
9a91			 
9a91			exec1: 
9a91 22 76 e6			ld (os_tok_ptr), hl 
9a94			 
9a94				; copy our PC to working vars  
9a94 22 40 eb			ld (cli_ptr), hl 
9a97 22 3e eb			ld (cli_origptr), hl 
9a9a			 
9a9a 7e				ld a,(hl) 
9a9b fe 7f			cp FORTH_END_BUFFER 
9a9d c8				ret z 
9a9e			 
9a9e				; skip any nulls 
9a9e			 
9a9e fe 00			cp 0 
9aa0 20 03			jr nz, .execword 
9aa2 23				inc hl 
9aa3 18 ec			jr exec1 
9aa5			 
9aa5			 
9aa5			.execword: 
9aa5			 
9aa5			 
9aa5			 
9aa5			if DEBUG_FORTH_PARSE_KEY 
9aa5						DMARK "KYQ" 
9aa5				CALLMONITOR 
9aa5			endif 
9aa5			;       while at start of word: 
9aa5			; get start of dict (in user area first) 
9aa5			 
9aa5 21 8a d6		ld hl, baseram 
9aa8			;ld hl, sysdict 
9aa8 22 42 eb		ld (cli_nextword),hl 
9aab			;           match word at pc 
9aab			;           exec word 
9aab			;           or push to dsp 
9aab			;           forward to next token 
9aab			;           if line term pop rsp and exit 
9aab			;        
9aab			 
9aab			if DEBUG_FORTH_PARSE_KEY 
9aab						DMARK "KYq" 
9aab				CALLMONITOR 
9aab			endif 
9aab			 
9aab			; 
9aab			; word comp 
9aab			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9aab			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9aab			;    move to start of word  
9aab			;    compare word to cli_token 
9aab			 
9aab			.execpnword:	; HL at start of a word in the dictionary to check 
9aab			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9aab			;	ld (cli_ptr), hl 
9aab			 
9aab 2a 42 eb			ld hl,(cli_nextword) 
9aae			 
9aae cd 51 9b			call forth_tok_next 
9ab1			; tok next start here 
9ab1			;	; TODO skip compiled symbol for now 
9ab1			;	inc hl 
9ab1			; 
9ab1			;	; save pointer to next word 
9ab1			; 
9ab1			;	; hl now points to the address of the next word pointer  
9ab1			;	ld e, (hl) 
9ab1			;	inc hl 
9ab1			;	ld d, (hl) 
9ab1			;	inc l 
9ab1			; 
9ab1			;	ex de,hl 
9ab1			;if DEBUG_FORTH_PARSE_NEXTWORD 
9ab1			;	push bc 
9ab1			;	ld bc, (cli_nextword) 
9ab1			;			DMARK "NXW" 
9ab1			;	CALLMONITOR 
9ab1			;	pop bc 
9ab1			;endif 
9ab1			; tok next end here 
9ab1 22 42 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9ab4 eb				ex de, hl 
9ab5			 
9ab5			 
9ab5				; save the pointer of the current token - 1 to check against 
9ab5				 
9ab5 22 46 eb			ld (cli_token), hl   
9ab8				; TODO maybe remove below save if no debug 
9ab8				; save token string ptr for any debug later 
9ab8 23				inc hl  
9ab9 22 48 eb			ld (cli_origtoken), hl 
9abc 2b				dec hl 
9abd				; save pointer to the start of the next dictionay word 
9abd 7e				ld a,(hl)   ; get string length 
9abe 47				ld b,a 
9abf			.execpnwordinc:  
9abf 23				inc hl 
9ac0 10 fd			djnz .execpnwordinc 
9ac2 22 44 eb			ld (cli_execword), hl      ; save start of this words code 
9ac5			 
9ac5				; now check the word token against the string being parsed 
9ac5			 
9ac5 2a 46 eb			ld hl,(cli_token) 
9ac8 23				inc hl     ; skip string length (use zero term instead to end) 
9ac9 22 46 eb			ld (cli_token), hl 
9acc			 
9acc			if DEBUG_FORTH_PARSE_KEY 
9acc						DMARK "KY2" 
9acc			endif 
9acc			if DEBUG_FORTH_PARSE_EXEC 
9acc				; see if disabled 
9acc			 
9acc				ld a, (os_view_disable) 
9acc				cp '*' 
9acc				jr z, .skip 
9acc			 
9acc				push hl 
9acc				push hl 
9acc				call clear_display 
9acc				ld de, .compword 
9acc				ld a, display_row_1 
9acc				call str_at_display 
9acc				pop de 
9acc				ld a, display_row_2 
9acc				call str_at_display 
9acc				ld hl,(cli_ptr) 
9acc				ld a,(hl) 
9acc			        ld hl, os_word_scratch 
9acc				ld (hl),a 
9acc				ld a,0 
9acc				inc hl 
9acc				ld (hl),a 	 
9acc				ld de, os_word_scratch 
9acc				ld a, display_row_2+10 
9acc				call str_at_display 
9acc				call update_display 
9acc				ld a, 100 
9acc				call aDelayInMS 
9acc				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9acc				call delay250ms 
9acc				endif 
9acc				pop hl 
9acc			.skip:  
9acc			endif	 
9acc			.execpnchar:    ; compare char between token and string to parse 
9acc			 
9acc			if DEBUG_FORTH_PARSE_KEY 
9acc						DMARK "Ky3" 
9acc			endif 
9acc			if DEBUG_FORTH_PARSE_EXEC 
9acc				; see if disabled 
9acc			 
9acc				ld a, (os_view_disable) 
9acc				cp '*' 
9acc				jr z, .skip2 
9acc			 
9acc			;	call clear_display 
9acc			ld hl,(cli_token) 
9acc			ld a,(hl) 
9acc			ld (os_word_scratch),a 
9acc				ld hl,(cli_ptr) 
9acc			ld a,(hl) 
9acc				ld (os_word_scratch+1),a 
9acc				ld a,0 
9acc				ld (os_word_scratch+2),a 
9acc				ld de,os_word_scratch 
9acc				ld a,display_row_4 
9acc				call str_at_display 
9acc				call update_display 
9acc			.skip2:  
9acc			endif 
9acc 2a 46 eb			ld hl,(cli_token) 
9acf 7e				ld a, (hl)	 ; char in word token 
9ad0 23				inc hl 		; move to next char 
9ad1 22 46 eb			ld (cli_token), hl ; and save it 
9ad4 47				ld b,a 
9ad5			 
9ad5 2a 40 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9ad8 7e				ld a,(hl) 
9ad9 23				inc hl 
9ada 22 40 eb			ld (cli_ptr), hl		; move to next char 
9add cd b2 8e			call toUpper 		; make sure the input string matches case 
9ae0			 
9ae0			if DEBUG_FORTH_PARSE 
9ae0			endif 
9ae0			 
9ae0				; input stream end of token is a space so get rid of it 
9ae0			 
9ae0			;	cp ' ' 
9ae0			;	jr nz, .pnskipspace 
9ae0			; 
9ae0			;	ld a, 0		; make same term as word token term 
9ae0			; 
9ae0			;.pnskipspace: 
9ae0			 
9ae0			if DEBUG_FORTH_PARSE_KEY 
9ae0						DMARK "KY7" 
9ae0			endif 
9ae0 b8				cp b 
9ae1 c2 f7 9a			jp nz, .execpnskipword	 ; no match so move to next word 
9ae4				 
9ae4			;    if same 
9ae4			;       scan for string terms 0 for token and 32 for input 
9ae4			 
9ae4				 
9ae4			if DEBUG_FORTH_PARSE_KEY 
9ae4						DMARK "KY8" 
9ae4			endif 
9ae4			 
9ae4 80				add b			 
9ae5 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9ae7							; TODO need to make sure last word in zero term string is accounted for 
9ae7 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9ae9			 
9ae9			 
9ae9				; at end of both strings so both are exact match 
9ae9			 
9ae9			;       skip ptr for next word 
9ae9			 
9ae9 2a 40 eb			ld hl,(cli_ptr) 	; at input string term 
9aec 23				inc hl			 ; at next char 
9aed 22 40 eb			ld (cli_ptr), hl     ; save for next round of the parser 
9af0 22 3e eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9af3				 
9af3				 
9af3			if DEBUG_FORTH_PARSE_KEY 
9af3						DMARK "KY3" 
9af3			endif 
9af3			 
9af3			 
9af3			 
9af3			;       exec code block 
9af3			if DEBUG_FORTH_JP 
9af3				call clear_display 
9af3				call update_display 
9af3				call delay1s 
9af3				ld hl, (cli_execword)     ; save for next check if no match on this word 
9af3				ld a,h 
9af3				ld hl, os_word_scratch 
9af3				call hexout 
9af3				ld hl, (cli_execword)     ; save for next check if no match on this word 
9af3				ld a,l 
9af3				ld hl, os_word_scratch+2 
9af3				call hexout 
9af3				ld hl, os_word_scratch+4 
9af3				ld a,0 
9af3				ld (hl),a 
9af3				ld de,os_word_scratch 
9af3				call str_at_display 
9af3					ld a, display_row_2 
9af3					call str_at_display 
9af3				ld de, (cli_origtoken) 
9af3				ld a, display_row_1+10 
9af3					call str_at_display 
9af3			 
9af3				ld a,display_row_1 
9af3				ld de, .foundword 
9af3				ld a, display_row_3 
9af3				call str_at_display 
9af3				call update_display 
9af3				call delay1s 
9af3				call delay1s 
9af3				call delay1s 
9af3			endif 
9af3			 
9af3			if DEBUG_FORTH_PARSE_KEY 
9af3						DMARK "KYj" 
9af3			endif 
9af3				; TODO save the word pointer in this exec 
9af3			 
9af3 2a 44 eb			ld hl,(cli_execword) 
9af6 e9				jp (hl) 
9af7			 
9af7			 
9af7			;    if not same 
9af7			;	scan for zero term 
9af7			;	get ptr for next word 
9af7			;	goto word comp 
9af7			 
9af7			.execpnskipword:	; get pointer to next word 
9af7 2a 42 eb			ld hl,(cli_nextword) 
9afa			 
9afa 7e				ld a,(hl) 
9afb fe 00			cp WORD_SYS_END 
9afd			;	cp 0 
9afd 28 09			jr z, .execendofdict			 ; at end of words 
9aff			 
9aff			if DEBUG_FORTH_PARSE_KEY 
9aff						DMARK "KY4" 
9aff			endif 
9aff			if DEBUG_FORTH_PARSE_EXEC 
9aff			 
9aff				; see if disabled 
9aff			 
9aff				ld a, (os_view_disable) 
9aff				cp '*' 
9aff				jr z, .noskip 
9aff			 
9aff			 
9aff				ld de, .nowordfound 
9aff				ld a, display_row_3 
9aff				call str_at_display 
9aff				call update_display 
9aff				ld a, 100 
9aff				call aDelayInMS 
9aff				 
9aff				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9aff					call delay250ms 
9aff				endif 
9aff			.noskip:  
9aff			 
9aff			endif	 
9aff			 
9aff 2a 3e eb			ld hl,(cli_origptr) 
9b02 22 40 eb			ld (cli_ptr),hl 
9b05			 
9b05			if DEBUG_FORTH_PARSE_KEY 
9b05						DMARK "KY5" 
9b05			endif 
9b05 c3 ab 9a			jp .execpnword			; else go to next word 
9b08			 
9b08			.execendofdict:  
9b08			 
9b08			if DEBUG_FORTH_PARSE_KEY 
9b08						DMARK "KYe" 
9b08			endif 
9b08			if DEBUG_FORTH_PARSE_EXEC 
9b08				; see if disabled 
9b08			 
9b08				ld a, (os_view_disable) 
9b08				cp '*' 
9b08				jr z, .ispskip 
9b08			 
9b08				call clear_display 
9b08				call update_display 
9b08				call delay1s 
9b08				ld de, (cli_origptr) 
9b08				ld a, display_row_1 
9b08				call str_at_display 
9b08				 
9b08				ld de, .enddict 
9b08				ld a, display_row_3 
9b08				call str_at_display 
9b08				call update_display 
9b08				ld a, 100 
9b08				call aDelayInMS 
9b08				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9b08				call delay1s 
9b08				call delay1s 
9b08				call delay1s 
9b08				endif 
9b08			.ispskip:  
9b08				 
9b08			endif	 
9b08			 
9b08			 
9b08			 
9b08				; if the word is not a keyword then must be a literal so push it to stack 
9b08			 
9b08			; push token to stack to end of word 
9b08			 
9b08				STACKFRAME ON $1efe $2f9f 
9b08				if DEBUG_STACK_IMB 
9b08					if ON 
9b08						exx 
9b08						ld de, $1efe 
9b08						ld a, d 
9b08						ld hl, curframe 
9b08						call hexout 
9b08						ld a, e 
9b08						ld hl, curframe+2 
9b08						call hexout 
9b08						ld hl, $1efe 
9b08						push hl 
9b08						ld hl, $2f9f 
9b08						push hl 
9b08						exx 
9b08					endif 
9b08				endif 
9b08			endm 
# End of macro STACKFRAME
9b08			 
9b08 2a 76 e6		ld hl,(os_tok_ptr) 
9b0b cd 57 98		call forth_apush 
9b0e			 
9b0e				STACKFRAMECHK ON $1efe $2f9f 
9b0e				if DEBUG_STACK_IMB 
9b0e					if ON 
9b0e						exx 
9b0e						ld hl, $2f9f 
9b0e						pop de   ; $2f9f 
9b0e						call cmp16 
9b0e						jr nz, .spnosame 
9b0e						ld hl, $1efe 
9b0e						pop de   ; $1efe 
9b0e						call cmp16 
9b0e						jr z, .spfrsame 
9b0e						.spnosame: call showsperror 
9b0e						.spfrsame: nop 
9b0e						exx 
9b0e					endif 
9b0e				endif 
9b0e			endm 
# End of macro STACKFRAMECHK
9b0e			 
9b0e			execnext: 
9b0e			 
9b0e			if DEBUG_FORTH_PARSE_KEY 
9b0e						DMARK "KY>" 
9b0e			endif 
9b0e			; move past token to next word 
9b0e			 
9b0e 2a 76 e6		ld hl, (os_tok_ptr) 
9b11 3e 00		ld a, 0 
9b13 01 ff 00		ld bc, 255     ; input buffer size 
9b16 ed b1		cpir 
9b18			 
9b18			if DEBUG_FORTH_PARSE_KEY 
9b18						DMARK "KY!" 
9b18				CALLMONITOR 
9b18			endif	 
9b18			; TODO this might place hl on the null, so will need to forward on??? 
9b18			;inc hl   ; see if this gets onto the next item 
9b18			 
9b18			 
9b18			; TODO pass a pointer to the buffer to push 
9b18			; TODO call function to push 
9b18			 
9b18			; look for end of input 
9b18			 
9b18			;inc hl 
9b18			;ld a,(hl) 
9b18			;cp FORTH_END_BUFFER 
9b18			;ret z 
9b18			 
9b18			 
9b18 c3 91 9a		jp exec1 
9b1b			 
9b1b			 
9b1b			 
9b1b			 
9b1b			 
9b1b			 
9b1b			 
9b1b			 
9b1b			 
9b1b			findnexttok: 
9b1b			 
9b1b				; hl is pointer to move 
9b1b				; de is the token to locate 
9b1b			 
9b1b					if DEBUG_FORTH 
9b1b						DMARK "NTK" 
9b1b						CALLMONITOR 
9b1b					endif 
9b1b d5				push de 
9b1c			 
9b1c			.fnt1:	 
9b1c				; find first char of token to locate 
9b1c			 
9b1c 1a				ld a, (de) 
9b1d 4f				ld c,a 
9b1e 7e				ld a,(hl) 
9b1f cd b2 8e			call toUpper 
9b22					if DEBUG_FORTH 
9b22						DMARK "NT1" 
9b22						CALLMONITOR 
9b22					endif 
9b22 b9				cp c 
9b23			 
9b23 28 03			jr z, .fnt2cmpmorefirst	 
9b25			 
9b25				; first char not found move to next char 
9b25			 
9b25 23				inc hl 
9b26 18 f4			jr .fnt1 
9b28			 
9b28			.fnt2cmpmorefirst:	 
9b28				; first char of token found.  
9b28			 
9b28 e5				push hl     ; save start of token just in case it is the right one 
9b29 d9				exx 
9b2a e1				pop hl        ; save it to hl' 
9b2b d9				exx 
9b2c			 
9b2c			 
9b2c			.fnt2cmpmore:	 
9b2c				; compare the rest 
9b2c				 
9b2c 23				inc hl 
9b2d 13				inc de 
9b2e				 
9b2e 1a				ld a, (de) 
9b2f 4f				ld c,a 
9b30 7e				ld a,(hl) 
9b31 cd b2 8e			call toUpper 
9b34			 
9b34					if DEBUG_FORTH 
9b34						DMARK "NT2" 
9b34						CALLMONITOR 
9b34					endif 
9b34				; c has the token to find char 
9b34				; a has the mem to scan char 
9b34			 
9b34 b9				cp c 
9b35 28 04			jr z,.fntmatch1 
9b37			 
9b37				; they are not the same 
9b37			 
9b37					if DEBUG_FORTH 
9b37						DMARK "NT3" 
9b37						CALLMONITOR 
9b37					endif 
9b37 d1				pop de	; reset de token to look for 
9b38 d5				push de 
9b39 18 e1			jr .fnt1 
9b3b				 
9b3b			.fntmatch1: 
9b3b			 
9b3b				; is the same char a null which means we might have a full hit? 
9b3b					if DEBUG_FORTH 
9b3b						DMARK "NT4" 
9b3b						CALLMONITOR 
9b3b					endif 
9b3b			 
9b3b fe 00			cp 0 
9b3d 28 0b			jr z, .fntmatchyes 
9b3f			 
9b3f				; are we at the end of the token to find? 
9b3f			 
9b3f					if DEBUG_FORTH 
9b3f						DMARK "NT5" 
9b3f						CALLMONITOR 
9b3f					endif 
9b3f 3e 00			ld a, 0 
9b41 b9				cp c 
9b42			 
9b42 c2 2c 9b			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9b45			 
9b45					if DEBUG_FORTH 
9b45						DMARK "NT6" 
9b45						CALLMONITOR 
9b45					endif 
9b45				; token to find is exhusted but no match to stream 
9b45			 
9b45				; restore tok pointer and continue on 
9b45 d1				pop de 
9b46 d5				push de 
9b47 c3 1c 9b			jp .fnt1 
9b4a			 
9b4a			 
9b4a			.fntmatchyes: 
9b4a			 
9b4a				; hl now contains the end of the found token 
9b4a			 
9b4a				; get rid of saved token pointer to find 
9b4a			 
9b4a d1				pop de 
9b4b			 
9b4b					if DEBUG_FORTH 
9b4b						DMARK "NT9" 
9b4b						CALLMONITOR 
9b4b					endif 
9b4b			 
9b4b				; hl will be on the null term so forward on 
9b4b			 
9b4b				; get back the saved start of the token 
9b4b			 
9b4b d9				exx 
9b4c e5				push hl     ; save start of token just in case it is the right one 
9b4d d9				exx 
9b4e e1				pop hl        ; save it to hl 
9b4f			 
9b4f c9				ret 
9b50			 
9b50			 
9b50			; LIST needs to find a specific token   
9b50			; FORGET needs to find a spefici token 
9b50			 
9b50			; SAVE needs to find all tokens by flag 
9b50			; WORDS just needs to scan through all  by flag 
9b50			; UWORDS needs to scan through all by flag 
9b50			 
9b50			 
9b50			; given hl as pointer to start of dict look up string 
9b50			; return hl as pointer to start of word block 
9b50			; or 0 if not found 
9b50			 
9b50			forth_find_tok: 
9b50 c9				ret 
9b51			 
9b51			; given hl as pointer to dict structure 
9b51			; move to the next dict block structure 
9b51			 
9b51			forth_tok_next: 
9b51				; hl now points to the address of the next word pointer  
9b51				; TODO skip compiled symbol for now 
9b51			;	push de 
9b51 23				inc hl 
9b52 5e				ld e, (hl) 
9b53 23				inc hl 
9b54 56				ld d, (hl) 
9b55 23				inc hl 
9b56			 
9b56 eb				ex de,hl 
9b57			if DEBUG_FORTH_PARSE_NEXTWORD 
9b57				push bc 
9b57				ld bc, (cli_nextword) 
9b57						DMARK "NXW" 
9b57				CALLMONITOR 
9b57				pop bc 
9b57			endif 
9b57			;	pop de	 
9b57 c9				ret 
9b58			 
9b58			 
9b58			 
9b58			; eof 
# End of file forth_parserv5.asm
9b58				include "forth_wordsv4.asm" 
9b58			 
9b58			; the core word dictionary v4 
9b58			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9b58			 
9b58			; this is a linked list for each of the system words used 
9b58			; user defined words will follow the same format but will be in ram 
9b58			 
9b58			 
9b58			; 
9b58			; 
9b58			; define linked list: 
9b58			; 
9b58			; 1. compiled byte op code 
9b58			; 2. len of text word 
9b58			; 3. text word 
9b58			; 4. ptr to next dictionary word 
9b58			; 5. asm, calls etc for the word 
9b58			; 
9b58			;  if 1 == 0 then last word in dict  
9b58			;   
9b58			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9b58			;  
9b58			;  
9b58			; create basic standard set of words 
9b58			; 
9b58			;  
9b58			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9b58			; 2DUP 2DROP 2SWAP  
9b58			; @ C@ - get byte  
9b58			; ! C! - store byte 
9b58			; 0< true if less than zero 
9b58			; 0= true if zero 
9b58			; < >  
9b58			; = true if same 
9b58			; variables 
9b58			 
9b58			 
9b58			; Hardware specific words I may need 
9b58			; 
9b58			; IN OUT  
9b58			; calls to key util functions 
9b58			; calls to hardward abstraction stuff 
9b58			; easy control of frame buffers and lcd i/o 
9b58			; keyboard  
9b58			 
9b58			 
9b58			;DICT: macro 
9b58			; op_code, len, word, next 
9b58			;    word: 
9b58			;    db op_code 
9b58			;    ds word zero term 
9b58			;    dw next 
9b58			;    endm 
9b58			 
9b58			 
9b58			 
9b58			 
9b58			; op code 1 is a flag for user define words which are to be handled differently 
9b58			 
9b58			 
9b58			; 
9b58			; 
9b58			;    TODO on entry to a word this should be the expected environment 
9b58			;    hl - tos value if number then held, if string this is the ptr 
9b58			;    de -  
9b58			 
9b58			 
9b58			; opcode ranges 
9b58			; 0 - end of word dict 
9b58			; 255 - user define words 
9b58			 
9b58			sysdict: 
9b58			include "forth_opcodes.asm" 
9b58			; op codes for forth keywords 
9b58			; free to use code 0  
9b58				OPCODE_HEAP: equ  1 
9b58				OPCODE_EXEC: equ 2 
9b58				OPCODE_DUP: equ 3 
9b58				OPCODE_SWAP: equ 4 
9b58				OPCODE_COLN: equ 5 
9b58				OPCODE_SCOLN: equ 6 
9b58				OPCODE_DROP: equ 7 
9b58				OPCODE_DUP2: equ 8 
9b58				OPCODE_DROP2: equ 9 
9b58				OPCODE_SWAP2: equ 10 
9b58				OPCODE_AT: equ 11 
9b58				OPCODE_CAT: equ 12 
9b58				OPCODE_BANG: equ 13 
9b58				OPCODE_CBANG: equ 14 
9b58				OPCODE_SCALL: equ 15 
9b58				OPCODE_DEPTH: equ 16 
9b58				OPCODE_OVER: equ 17 
9b58				OPCODE_PAUSE: equ 18 
9b58				OPCODE_PAUSES: equ 19 
9b58				OPCODE_ROT: equ 20 
9b58			;free to reuse	OPCODE_WORDS: equ 21 
9b58			        OPCODE_NOT: equ 21 
9b58				OPCODE_UWORDS: equ 22 
9b58				OPCODE_BP: equ 23 
9b58				OPCODE_MONITOR: equ 24  
9b58				OPCODE_MALLOC: equ 25 
9b58				OPCODE_FREE: equ 26 
9b58				OPCODE_LIST: equ 27 
9b58				OPCODE_FORGET: equ 28 
9b58				OPCODE_NOP: equ 29 
9b58				OPCODE_COMO: equ 30 
9b58				OPCODE_COMC: equ 31 
9b58			;free to reuse	OPCODE_ENDCORE: equ 32 
9b58				OPCODE_AFTERSOUND: equ 33 
9b58				OPCODE_GP2: equ 34 
9b58				OPCODE_GP3: equ 35 
9b58				OPCODE_GP4: equ 36 
9b58				OPCODE_SIN: equ 37 
9b58				OPCODE_SOUT: equ 38 
9b58				OPCODE_SPIO: equ 39 
9b58				OPCODE_SPICEH: equ 40 
9b58				OPCODE_SPIOb: equ 41 
9b58				OPCODE_SPII: equ 42 
9b58				OPCODE_SESEL: equ 43 
9b58				OPCODE_CARTDEV: equ 44 
9b58			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9b58				OPCODE_FB: equ 46 
9b58				OPCODE_EMIT: equ 47 
9b58				OPCODE_DOTH: equ 48 
9b58				OPCODE_DOTF: equ 49 
9b58				OPCODE_DOT: equ 50 
9b58				OPCODE_CLS: equ 51 
9b58				OPCODE_DRAW: equ 52 
9b58				OPCODE_DUMP: equ 53 
9b58				OPCODE_CDUMP: equ 54 
9b58				OPCODE_DAT: equ 55 
9b58				OPCODE_HOME: equ 56 
9b58				OPCODE_SPACE: equ 57 
9b58				OPCODE_SPACES: equ 58 
9b58				OPCODE_SCROLL: equ 59 
9b58				OPCODE_ATQ: equ 60 
9b58				OPCODE_AUTODSP: equ 61 
9b58				OPCODE_MENU: equ 62 
9b58			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9b58				OPCODE_THEN: equ 64 
9b58				OPCODE_ELSE: equ 65 
9b58				OPCODE_DO: equ 66 
9b58				OPCODE_LOOP: equ 67 
9b58				OPCODE_I: equ 68 
9b58				OPCODE_DLOOP: equ 69  
9b58				OPCODE_REPEAT: equ 70  
9b58				OPCODE_UNTIL: equ 71 
9b58				OPCODE_ENDFLOW: equ 72 
9b58				OPCODE_WAITK: equ 73 
9b58				OPCODE_ACCEPT: equ 74 
9b58				OPCODE_EDIT: equ 75 
9b58			;free to reuse	OPCODE_ENDKEY: equ 76 
9b58				OPCODE_LZERO: equ 77 
9b58				OPCODE_TZERO: equ 78 
9b58				OPCODE_LESS: equ 79 
9b58				OPCODE_GT: equ 80 
9b58				OPCODE_EQUAL: equ 81  
9b58			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9b58				OPCODE_NEG: equ 83 
9b58				OPCODE_DIV: equ 84 
9b58				OPCODE_MUL: equ 85 
9b58				OPCODE_MIN: equ 86 
9b58				OPCODE_MAX: equ 87 
9b58				OPCODE_RND16: equ 88 
9b58				OPCODE_RND8: equ 89 
9b58				OPCODE_RND: equ 90 
9b58			;free to reuse	OPCODE_ENDMATHS: equ 91  
9b58				OPCODE_BYNAME: equ 92 
9b58				OPCODE_DIR: equ 93 
9b58				OPCODE_SAVE: equ 94 
9b58				OPCODE_LOAD: equ 95 
9b58				OPCODE_BSAVE: equ 96 
9b58				OPCODE_BLOAD: equ 97 
9b58				OPCODE_SEO: equ 98  
9b58				OPCODE_SEI: equ 99 
9b58				OPCODE_SFREE: equ 100 
9b58				OPCODE_SIZE: equ 101 
9b58				OPCODE_CREATE: equ 102 
9b58				OPCODE_APPEND: equ 103 
9b58				OPCODE_SDEL: equ 104 
9b58				OPCODE_OPEN: equ 105 
9b58				OPCODE_READ: equ 106 
9b58				OPCODE_EOF: equ 106 
9b58				OPCODE_FORMAT: equ 107 
9b58				OPCODE_LABEL: equ 108 
9b58				OPCODE_LABELS: equ 109 
9b58			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9b58				OPCODE_UPPER: equ 111 
9b58				OPCODE_LOWER: equ 112 
9b58				OPCODE_SUBSTR: equ 113 
9b58				OPCODE_LEFT: equ 114 
9b58				OPCODE_RIGHT: equ 115 
9b58				OPCODE_STR2NUM: equ 116 
9b58				OPCODE_NUM2STR: equ 117 
9b58				OPCODE_CONCAT: equ 118 
9b58				OPCODE_FIND: equ 119 
9b58				OPCODE_LEN: equ 120 
9b58				OPCODE_CHAR: equ 121 
9b58			; free to reuse	OPCODE_STRLEN: equ 122 
9b58			; free to reuse	OPCODE_ENDSTR: equ 123 
9b58				OPCODE_V0S: equ 124 
9b58				OPCODE_V0Q: equ 125 
9b58				OPCODE_V1S: equ 126 
9b58				OPCODE_V1Q: equ 127 
9b58				OPCODE_V2S: equ 128 
9b58				OPCODE_V2Q: equ 129 
9b58				OPCODE_V3S: equ 130 
9b58				OPCODE_V3Q: equ 131 
9b58			;free to reuse	OPCODE_END: equ 132 
9b58				OPCODE_ZDUP: equ 133 
9b58			 
9b58			; eof 
# End of file forth_opcodes.asm
9b58			 
9b58			include "forth_words_core.asm" 
9b58			 
9b58			; | ## Core Words 
9b58			 
9b58			;if MALLOC_4 
9b58			 
9b58			.HEAP: 
9b58				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9b58 15				db WORD_SYS_CORE+OPCODE_HEAP             
9b59 97 9b			dw .EXEC            
9b5b 05				db 4 + 1 
9b5c .. 00			db "HEAP",0              
9b61				endm 
# End of macro CWHEAD
9b61			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9b61			; | | u1 - Current number of bytes in the heap 
9b61			; | | u2 - Remaining bytes left on the heap 
9b61			; | |  
9b61			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9b61			 
9b61			 
9b61					if DEBUG_FORTH_WORDS_KEY 
9b61						DMARK "HEP" 
9b61 f5				push af  
9b62 3a 76 9b			ld a, (.dmark)  
9b65 32 7a ee			ld (debug_mark),a  
9b68 3a 77 9b			ld a, (.dmark+1)  
9b6b 32 7b ee			ld (debug_mark+1),a  
9b6e 3a 78 9b			ld a, (.dmark+2)  
9b71 32 7c ee			ld (debug_mark+2),a  
9b74 18 03			jr .pastdmark  
9b76 ..			.dmark: db "HEP"  
9b79 f1			.pastdmark: pop af  
9b7a			endm  
# End of macro DMARK
9b7a						CALLMONITOR 
9b7a cd 75 92			call break_point_state  
9b7d				endm  
# End of macro CALLMONITOR
9b7d					endif 
9b7d 2a 94 d6				ld hl, (free_list )      
9b80 11 99 d6				ld de, heap_start 
9b83			 
9b83 ed 52				sbc hl, de  
9b85			 
9b85 cd 0f 98				call forth_push_numhl 
9b88			 
9b88			 
9b88 ed 5b 94 d6			ld de, (free_list )      
9b8c 21 69 e3				ld hl, heap_end 
9b8f			 
9b8f ed 52				sbc hl, de 
9b91			 
9b91 cd 0f 98				call forth_push_numhl 
9b94					 
9b94			 
9b94					 
9b94			 
9b94			 
9b94			 
9b94					NEXTW 
9b94 c3 00 9a			jp macro_next 
9b97				endm 
# End of macro NEXTW
9b97			;endif 
9b97			 
9b97			.EXEC: 
9b97				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9b97 16				db WORD_SYS_CORE+OPCODE_EXEC             
9b98 33 9c			dw .STKEXEC            
9b9a 05				db 4 + 1 
9b9b .. 00			db "EXEC",0              
9ba0				endm 
# End of macro CWHEAD
9ba0			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
9ba0			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9ba0			; | | 
9ba0			; | |   
9ba0				STACKFRAME OFF $5efe $5f9f 
9ba0				if DEBUG_STACK_IMB 
9ba0					if OFF 
9ba0						exx 
9ba0						ld de, $5efe 
9ba0						ld a, d 
9ba0						ld hl, curframe 
9ba0						call hexout 
9ba0						ld a, e 
9ba0						ld hl, curframe+2 
9ba0						call hexout 
9ba0						ld hl, $5efe 
9ba0						push hl 
9ba0						ld hl, $5f9f 
9ba0						push hl 
9ba0						exx 
9ba0					endif 
9ba0				endif 
9ba0			endm 
# End of macro STACKFRAME
9ba0			 
9ba0					if DEBUG_FORTH_WORDS_KEY 
9ba0						DMARK "EXE" 
9ba0 f5				push af  
9ba1 3a b5 9b			ld a, (.dmark)  
9ba4 32 7a ee			ld (debug_mark),a  
9ba7 3a b6 9b			ld a, (.dmark+1)  
9baa 32 7b ee			ld (debug_mark+1),a  
9bad 3a b7 9b			ld a, (.dmark+2)  
9bb0 32 7c ee			ld (debug_mark+2),a  
9bb3 18 03			jr .pastdmark  
9bb5 ..			.dmark: db "EXE"  
9bb8 f1			.pastdmark: pop af  
9bb9			endm  
# End of macro DMARK
9bb9						CALLMONITOR 
9bb9 cd 75 92			call break_point_state  
9bbc				endm  
# End of macro CALLMONITOR
9bbc					endif 
9bbc			 
9bbc				FORTH_DSP_VALUEHL 
9bbc cd aa 98			call macro_dsp_valuehl 
9bbf				endm 
# End of macro FORTH_DSP_VALUEHL
9bbf			 
9bbf				FORTH_DSP_POP 
9bbf cd 46 99			call macro_forth_dsp_pop 
9bc2				endm 
# End of macro FORTH_DSP_POP
9bc2			 
9bc2					if DEBUG_FORTH_WORDS 
9bc2						DMARK "EX1" 
9bc2 f5				push af  
9bc3 3a d7 9b			ld a, (.dmark)  
9bc6 32 7a ee			ld (debug_mark),a  
9bc9 3a d8 9b			ld a, (.dmark+1)  
9bcc 32 7b ee			ld (debug_mark+1),a  
9bcf 3a d9 9b			ld a, (.dmark+2)  
9bd2 32 7c ee			ld (debug_mark+2),a  
9bd5 18 03			jr .pastdmark  
9bd7 ..			.dmark: db "EX1"  
9bda f1			.pastdmark: pop af  
9bdb			endm  
# End of macro DMARK
9bdb						CALLMONITOR 
9bdb cd 75 92			call break_point_state  
9bde				endm  
# End of macro CALLMONITOR
9bde					endif 
9bde			;	ld e,(hl) 
9bde			;	inc hl 
9bde			;	ld d,(hl) 
9bde			;	ex de,hl 
9bde			 
9bde			;		if DEBUG_FORTH_WORDS 
9bde			;			DMARK "EX2" 
9bde			;			CALLMONITOR 
9bde			;		endif 
9bde e5				push hl 
9bdf			 
9bdf				;ld a, 0 
9bdf				;ld a, FORTH_END_BUFFER 
9bdf cd bb 8e			call strlenz 
9be2 23				inc hl   ; include zero term to copy 
9be3 23				inc hl   ; include term 
9be4 23				inc hl   ; include term 
9be5 06 00			ld b,0 
9be7 4d				ld c,l 
9be8 e1				pop hl 
9be9 11 74 e4			ld de, execscratch 
9bec					if DEBUG_FORTH_WORDS 
9bec						DMARK "EX3" 
9bec f5				push af  
9bed 3a 01 9c			ld a, (.dmark)  
9bf0 32 7a ee			ld (debug_mark),a  
9bf3 3a 02 9c			ld a, (.dmark+1)  
9bf6 32 7b ee			ld (debug_mark+1),a  
9bf9 3a 03 9c			ld a, (.dmark+2)  
9bfc 32 7c ee			ld (debug_mark+2),a  
9bff 18 03			jr .pastdmark  
9c01 ..			.dmark: db "EX3"  
9c04 f1			.pastdmark: pop af  
9c05			endm  
# End of macro DMARK
9c05						CALLMONITOR 
9c05 cd 75 92			call break_point_state  
9c08				endm  
# End of macro CALLMONITOR
9c08					endif 
9c08 ed b0			ldir 
9c0a			 
9c0a			 
9c0a 21 74 e4			ld hl, execscratch 
9c0d			 
9c0d					if DEBUG_FORTH_WORDS 
9c0d						DMARK "EXe" 
9c0d f5				push af  
9c0e 3a 22 9c			ld a, (.dmark)  
9c11 32 7a ee			ld (debug_mark),a  
9c14 3a 23 9c			ld a, (.dmark+1)  
9c17 32 7b ee			ld (debug_mark+1),a  
9c1a 3a 24 9c			ld a, (.dmark+2)  
9c1d 32 7c ee			ld (debug_mark+2),a  
9c20 18 03			jr .pastdmark  
9c22 ..			.dmark: db "EXe"  
9c25 f1			.pastdmark: pop af  
9c26			endm  
# End of macro DMARK
9c26						CALLMONITOR 
9c26 cd 75 92			call break_point_state  
9c29				endm  
# End of macro CALLMONITOR
9c29					endif 
9c29			 
9c29 cd 4e 9a			call forthparse 
9c2c cd 8e 9a			call forthexec 
9c2f			;	call forthexec_cleanup 
9c2f			;	call forthparse 
9c2f			;	call forthexec 
9c2f			 
9c2f				STACKFRAMECHK OFF $5efe $5f9f 
9c2f				if DEBUG_STACK_IMB 
9c2f					if OFF 
9c2f						exx 
9c2f						ld hl, $5f9f 
9c2f						pop de   ; $5f9f 
9c2f						call cmp16 
9c2f						jr nz, .spnosame 
9c2f						ld hl, $5efe 
9c2f						pop de   ; $5efe 
9c2f						call cmp16 
9c2f						jr z, .spfrsame 
9c2f						.spnosame: call showsperror 
9c2f						.spfrsame: nop 
9c2f						exx 
9c2f					endif 
9c2f				endif 
9c2f			endm 
# End of macro STACKFRAMECHK
9c2f			 
9c2f				; an immediate word so no need to process any more words 
9c2f c9				ret 
9c30				NEXTW 
9c30 c3 00 9a			jp macro_next 
9c33				endm 
# End of macro NEXTW
9c33			 
9c33			; dead code - old version  
9c33			;	FORTH_RSP_NEXT 
9c33			 
9c33			;  
9c33			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c33			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c33			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c33			;	push hl 
9c33			;	push de 
9c33			;	push bc 
9c33			; 
9c33			; 
9c33			;		if DEBUG_FORTH_WORDS_KEY 
9c33			;			DMARK "EXR" 
9c33			;			CALLMONITOR 
9c33			;		endif 
9c33			; 
9c33			; 
9c33			; 
9c33			;	;v5 FORTH_DSP_VALUE 
9c33			;	FORTH_DSP_VALUEHL 
9c33			; 
9c33			;	; TODO do string type checks 
9c33			; 
9c33			;;v5	inc hl   ; skip type 
9c33			; 
9c33			;	push hl  ; source code  
9c33			;		if DEBUG_FORTH_WORDS 
9c33			;			DMARK "EX1" 
9c33			;			CALLMONITOR 
9c33			;		endif 
9c33			;	ld a, 0 
9c33			;	call strlent 
9c33			; 
9c33			;	inc hl 
9c33			;	inc hl 
9c33			;	inc hl 
9c33			;	inc hl 
9c33			; 
9c33			;	push hl    ; size 
9c33			; 
9c33			;		if DEBUG_FORTH_WORDS 
9c33			;			DMARK "EX2" 
9c33			;			CALLMONITOR 
9c33			;		endif 
9c33			;	call malloc 
9c33			; 
9c33			;	ex de, hl    ; de now contains malloc area 
9c33			;	pop bc   	; get byte count 
9c33			;	pop hl      ; get string to copy 
9c33			; 
9c33			;	push de     ; save malloc for free later 
9c33			; 
9c33			;		if DEBUG_FORTH_WORDS 
9c33			;			DMARK "EX3" 
9c33			;			CALLMONITOR 
9c33			;		endif 
9c33			;	ldir       ; duplicate string 
9c33			; 
9c33			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9c33			;	 
9c33			;	; TODO fix the parse would be better than this...  
9c33			;	ex de, hl 
9c33			;	dec hl 
9c33			;	ld a, 0 
9c33			;	ld (hl), a 
9c33			;	dec hl 
9c33			;	ld a, ' ' 
9c33			;	ld (hl), a 
9c33			;	dec hl 
9c33			;	ld (hl), a 
9c33			; 
9c33			;	dec hl 
9c33			;	ld (hl), a 
9c33			; 
9c33			; 
9c33			;	FORTH_DSP_POP  
9c33			; 
9c33			;	pop hl     
9c33			;	push hl    ; save malloc area 
9c33			; 
9c33			;		if DEBUG_FORTH_WORDS 
9c33			;			DMARK "EX4" 
9c33			;			CALLMONITOR 
9c33			;		endif 
9c33			; 
9c33			;	call forthparse 
9c33			;	call forthexec 
9c33			;	 
9c33			;	pop hl 
9c33			;	if DEBUG_FORTH_WORDS 
9c33			;		DMARK "EX5" 
9c33			;		CALLMONITOR 
9c33			;	endif 
9c33			; 
9c33			;	if FORTH_ENABLE_FREE 
9c33			;	call free 
9c33			;	endif 
9c33			; 
9c33			;	if DEBUG_FORTH_WORDS 
9c33			;		DMARK "EX6" 
9c33			;		CALLMONITOR 
9c33			;	endif 
9c33			; 
9c33			;	pop bc 
9c33			;	pop de 
9c33			;	pop hl 
9c33			;;	FORTH_RSP_POP	  
9c33			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9c33			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9c33			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9c33			; 
9c33			;	if DEBUG_FORTH_WORDS 
9c33			;		DMARK "EX7" 
9c33			;		CALLMONITOR 
9c33			;	endif 
9c33			;	NEXTW 
9c33			 
9c33			.STKEXEC: 
9c33				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9c33 3f				db WORD_SYS_CORE+43             
9c34 7b 9d			dw .ZDUP            
9c36 08				db 7 + 1 
9c37 .. 00			db "STKEXEC",0              
9c3f				endm 
# End of macro CWHEAD
9c3f			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
9c3f			 
9c3f			 
9c3f					if DEBUG_FORTH_WORDS_KEY 
9c3f						DMARK "STX" 
9c3f f5				push af  
9c40 3a 54 9c			ld a, (.dmark)  
9c43 32 7a ee			ld (debug_mark),a  
9c46 3a 55 9c			ld a, (.dmark+1)  
9c49 32 7b ee			ld (debug_mark+1),a  
9c4c 3a 56 9c			ld a, (.dmark+2)  
9c4f 32 7c ee			ld (debug_mark+2),a  
9c52 18 03			jr .pastdmark  
9c54 ..			.dmark: db "STX"  
9c57 f1			.pastdmark: pop af  
9c58			endm  
# End of macro DMARK
9c58						CALLMONITOR 
9c58 cd 75 92			call break_point_state  
9c5b				endm  
# End of macro CALLMONITOR
9c5b					endif 
9c5b			 
9c5b				FORTH_DSP_VALUEHL 
9c5b cd aa 98			call macro_dsp_valuehl 
9c5e				endm 
# End of macro FORTH_DSP_VALUEHL
9c5e			 
9c5e 22 63 eb			ld (store_tmp1), hl    ; count 
9c61			 
9c61				FORTH_DSP_POP 
9c61 cd 46 99			call macro_forth_dsp_pop 
9c64				endm 
# End of macro FORTH_DSP_POP
9c64			.stkexec1: 
9c64 2a 63 eb			ld hl, (store_tmp1)   ; count 
9c67 3e 00			ld a, 0 
9c69 bd				cp l 
9c6a c8				ret z 
9c6b			 
9c6b 2b				dec hl 
9c6c 22 63 eb			ld (store_tmp1), hl    ; count 
9c6f				 
9c6f				FORTH_DSP_VALUEHL 
9c6f cd aa 98			call macro_dsp_valuehl 
9c72				endm 
# End of macro FORTH_DSP_VALUEHL
9c72 e5				push hl 
9c73				 
9c73					if DEBUG_FORTH_WORDS 
9c73						DMARK "EXp" 
9c73 f5				push af  
9c74 3a 88 9c			ld a, (.dmark)  
9c77 32 7a ee			ld (debug_mark),a  
9c7a 3a 89 9c			ld a, (.dmark+1)  
9c7d 32 7b ee			ld (debug_mark+1),a  
9c80 3a 8a 9c			ld a, (.dmark+2)  
9c83 32 7c ee			ld (debug_mark+2),a  
9c86 18 03			jr .pastdmark  
9c88 ..			.dmark: db "EXp"  
9c8b f1			.pastdmark: pop af  
9c8c			endm  
# End of macro DMARK
9c8c						CALLMONITOR 
9c8c cd 75 92			call break_point_state  
9c8f				endm  
# End of macro CALLMONITOR
9c8f					endif 
9c8f				FORTH_DSP_POP 
9c8f cd 46 99			call macro_forth_dsp_pop 
9c92				endm 
# End of macro FORTH_DSP_POP
9c92			 
9c92 cd bb 8e			call strlenz 
9c95 23				inc hl   ; include zero term to copy 
9c96 23				inc hl   ; include zero term to copy 
9c97 23				inc hl   ; include zero term to copy 
9c98 06 00			ld b,0 
9c9a 4d				ld c,l 
9c9b e1				pop hl 
9c9c 11 74 e4			ld de, execscratch 
9c9f					if DEBUG_FORTH_WORDS 
9c9f						DMARK "EX3" 
9c9f f5				push af  
9ca0 3a b4 9c			ld a, (.dmark)  
9ca3 32 7a ee			ld (debug_mark),a  
9ca6 3a b5 9c			ld a, (.dmark+1)  
9ca9 32 7b ee			ld (debug_mark+1),a  
9cac 3a b6 9c			ld a, (.dmark+2)  
9caf 32 7c ee			ld (debug_mark+2),a  
9cb2 18 03			jr .pastdmark  
9cb4 ..			.dmark: db "EX3"  
9cb7 f1			.pastdmark: pop af  
9cb8			endm  
# End of macro DMARK
9cb8						CALLMONITOR 
9cb8 cd 75 92			call break_point_state  
9cbb				endm  
# End of macro CALLMONITOR
9cbb					endif 
9cbb ed b0			ldir 
9cbd			 
9cbd			 
9cbd 21 74 e4			ld hl, execscratch 
9cc0			 
9cc0					if DEBUG_FORTH_WORDS 
9cc0						DMARK "EXP" 
9cc0 f5				push af  
9cc1 3a d5 9c			ld a, (.dmark)  
9cc4 32 7a ee			ld (debug_mark),a  
9cc7 3a d6 9c			ld a, (.dmark+1)  
9cca 32 7b ee			ld (debug_mark+1),a  
9ccd 3a d7 9c			ld a, (.dmark+2)  
9cd0 32 7c ee			ld (debug_mark+2),a  
9cd3 18 03			jr .pastdmark  
9cd5 ..			.dmark: db "EXP"  
9cd8 f1			.pastdmark: pop af  
9cd9			endm  
# End of macro DMARK
9cd9						CALLMONITOR 
9cd9 cd 75 92			call break_point_state  
9cdc				endm  
# End of macro CALLMONITOR
9cdc					endif 
9cdc			 
9cdc cd 4e 9a			call forthparse 
9cdf 21 74 e4			ld hl, execscratch 
9ce2					if DEBUG_FORTH_WORDS 
9ce2						DMARK "EXx" 
9ce2 f5				push af  
9ce3 3a f7 9c			ld a, (.dmark)  
9ce6 32 7a ee			ld (debug_mark),a  
9ce9 3a f8 9c			ld a, (.dmark+1)  
9cec 32 7b ee			ld (debug_mark+1),a  
9cef 3a f9 9c			ld a, (.dmark+2)  
9cf2 32 7c ee			ld (debug_mark+2),a  
9cf5 18 03			jr .pastdmark  
9cf7 ..			.dmark: db "EXx"  
9cfa f1			.pastdmark: pop af  
9cfb			endm  
# End of macro DMARK
9cfb						CALLMONITOR 
9cfb cd 75 92			call break_point_state  
9cfe				endm  
# End of macro CALLMONITOR
9cfe					endif 
9cfe cd 8e 9a			call forthexec 
9d01			 
9d01 c3 64 9c			jp .stkexec1 
9d04			 
9d04 c9				ret 
9d05			 
9d05			 
9d05			.DUP: 
9d05				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9d05 17				db WORD_SYS_CORE+OPCODE_DUP             
9d06 7b 9d			dw .ZDUP            
9d08 04				db 3 + 1 
9d09 .. 00			db "DUP",0              
9d0d				endm 
# End of macro CWHEAD
9d0d			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9d0d			 
9d0d					if DEBUG_FORTH_WORDS_KEY 
9d0d						DMARK "DUP" 
9d0d f5				push af  
9d0e 3a 22 9d			ld a, (.dmark)  
9d11 32 7a ee			ld (debug_mark),a  
9d14 3a 23 9d			ld a, (.dmark+1)  
9d17 32 7b ee			ld (debug_mark+1),a  
9d1a 3a 24 9d			ld a, (.dmark+2)  
9d1d 32 7c ee			ld (debug_mark+2),a  
9d20 18 03			jr .pastdmark  
9d22 ..			.dmark: db "DUP"  
9d25 f1			.pastdmark: pop af  
9d26			endm  
# End of macro DMARK
9d26						CALLMONITOR 
9d26 cd 75 92			call break_point_state  
9d29				endm  
# End of macro CALLMONITOR
9d29					endif 
9d29			 
9d29					FORTH_DSP 
9d29 cd 8f 98			call macro_forth_dsp 
9d2c				endm 
# End of macro FORTH_DSP
9d2c			 
9d2c 7e					ld a, (HL) 
9d2d fe 01				cp DS_TYPE_STR 
9d2f 20 25				jr nz, .dupinum 
9d31			 
9d31					; push another string 
9d31			 
9d31					FORTH_DSP_VALUEHL     		 
9d31 cd aa 98			call macro_dsp_valuehl 
9d34				endm 
# End of macro FORTH_DSP_VALUEHL
9d34			 
9d34				if DEBUG_FORTH_WORDS 
9d34					DMARK "DUs" 
9d34 f5				push af  
9d35 3a 49 9d			ld a, (.dmark)  
9d38 32 7a ee			ld (debug_mark),a  
9d3b 3a 4a 9d			ld a, (.dmark+1)  
9d3e 32 7b ee			ld (debug_mark+1),a  
9d41 3a 4b 9d			ld a, (.dmark+2)  
9d44 32 7c ee			ld (debug_mark+2),a  
9d47 18 03			jr .pastdmark  
9d49 ..			.dmark: db "DUs"  
9d4c f1			.pastdmark: pop af  
9d4d			endm  
# End of macro DMARK
9d4d					CALLMONITOR 
9d4d cd 75 92			call break_point_state  
9d50				endm  
# End of macro CALLMONITOR
9d50				endif 
9d50 cd 21 98				call forth_push_str 
9d53			 
9d53					NEXTW 
9d53 c3 00 9a			jp macro_next 
9d56				endm 
# End of macro NEXTW
9d56			 
9d56			 
9d56			.dupinum: 
9d56					 
9d56			 
9d56			 
9d56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9d56 cd aa 98			call macro_dsp_valuehl 
9d59				endm 
# End of macro FORTH_DSP_VALUEHL
9d59			 
9d59				; TODO add floating point number detection 
9d59			 
9d59				if DEBUG_FORTH_WORDS 
9d59					DMARK "DUi" 
9d59 f5				push af  
9d5a 3a 6e 9d			ld a, (.dmark)  
9d5d 32 7a ee			ld (debug_mark),a  
9d60 3a 6f 9d			ld a, (.dmark+1)  
9d63 32 7b ee			ld (debug_mark+1),a  
9d66 3a 70 9d			ld a, (.dmark+2)  
9d69 32 7c ee			ld (debug_mark+2),a  
9d6c 18 03			jr .pastdmark  
9d6e ..			.dmark: db "DUi"  
9d71 f1			.pastdmark: pop af  
9d72			endm  
# End of macro DMARK
9d72					CALLMONITOR 
9d72 cd 75 92			call break_point_state  
9d75				endm  
# End of macro CALLMONITOR
9d75				endif 
9d75			 
9d75 cd 0f 98				call forth_push_numhl 
9d78					NEXTW 
9d78 c3 00 9a			jp macro_next 
9d7b				endm 
# End of macro NEXTW
9d7b			.ZDUP: 
9d7b				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9d7b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9d7c b3 9d			dw .SWAP            
9d7e 05				db 4 + 1 
9d7f .. 00			db "?DUP",0              
9d84				endm 
# End of macro CWHEAD
9d84			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9d84			 
9d84					if DEBUG_FORTH_WORDS_KEY 
9d84						DMARK "qDU" 
9d84 f5				push af  
9d85 3a 99 9d			ld a, (.dmark)  
9d88 32 7a ee			ld (debug_mark),a  
9d8b 3a 9a 9d			ld a, (.dmark+1)  
9d8e 32 7b ee			ld (debug_mark+1),a  
9d91 3a 9b 9d			ld a, (.dmark+2)  
9d94 32 7c ee			ld (debug_mark+2),a  
9d97 18 03			jr .pastdmark  
9d99 ..			.dmark: db "qDU"  
9d9c f1			.pastdmark: pop af  
9d9d			endm  
# End of macro DMARK
9d9d						CALLMONITOR 
9d9d cd 75 92			call break_point_state  
9da0				endm  
# End of macro CALLMONITOR
9da0					endif 
9da0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9da0 cd aa 98			call macro_dsp_valuehl 
9da3				endm 
# End of macro FORTH_DSP_VALUEHL
9da3			 
9da3 e5					push hl 
9da4			 
9da4					; is it a zero? 
9da4			 
9da4 3e 00				ld a, 0 
9da6 84					add h 
9da7 85					add l 
9da8			 
9da8 e1					pop hl 
9da9			 
9da9 fe 00				cp 0 
9dab 28 03				jr z, .dup2orig 
9dad			 
9dad			 
9dad cd 0f 98				call forth_push_numhl 
9db0			 
9db0			 
9db0				; TODO add floating point number detection 
9db0			 
9db0			.dup2orig: 
9db0			 
9db0					NEXTW 
9db0 c3 00 9a			jp macro_next 
9db3				endm 
# End of macro NEXTW
9db3			.SWAP: 
9db3				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9db3 18				db WORD_SYS_CORE+OPCODE_SWAP             
9db4 f2 9d			dw .COLN            
9db6 05				db 4 + 1 
9db7 .. 00			db "SWAP",0              
9dbc				endm 
# End of macro CWHEAD
9dbc			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9dbc					if DEBUG_FORTH_WORDS_KEY 
9dbc						DMARK "SWP" 
9dbc f5				push af  
9dbd 3a d1 9d			ld a, (.dmark)  
9dc0 32 7a ee			ld (debug_mark),a  
9dc3 3a d2 9d			ld a, (.dmark+1)  
9dc6 32 7b ee			ld (debug_mark+1),a  
9dc9 3a d3 9d			ld a, (.dmark+2)  
9dcc 32 7c ee			ld (debug_mark+2),a  
9dcf 18 03			jr .pastdmark  
9dd1 ..			.dmark: db "SWP"  
9dd4 f1			.pastdmark: pop af  
9dd5			endm  
# End of macro DMARK
9dd5						CALLMONITOR 
9dd5 cd 75 92			call break_point_state  
9dd8				endm  
# End of macro CALLMONITOR
9dd8					endif 
9dd8			 
9dd8					FORTH_DSP_VALUEHL 
9dd8 cd aa 98			call macro_dsp_valuehl 
9ddb				endm 
# End of macro FORTH_DSP_VALUEHL
9ddb e5					push hl     ; w2 
9ddc			 
9ddc					FORTH_DSP_POP 
9ddc cd 46 99			call macro_forth_dsp_pop 
9ddf				endm 
# End of macro FORTH_DSP_POP
9ddf			 
9ddf					FORTH_DSP_VALUEHL 
9ddf cd aa 98			call macro_dsp_valuehl 
9de2				endm 
# End of macro FORTH_DSP_VALUEHL
9de2			 
9de2					FORTH_DSP_POP 
9de2 cd 46 99			call macro_forth_dsp_pop 
9de5				endm 
# End of macro FORTH_DSP_POP
9de5			 
9de5 d1					pop de     ; w2	, hl = w1 
9de6			 
9de6 eb					ex de, hl 
9de7 d5					push de 
9de8			 
9de8 cd 0f 98				call forth_push_numhl 
9deb			 
9deb e1					pop hl 
9dec			 
9dec cd 0f 98				call forth_push_numhl 
9def					 
9def			 
9def					NEXTW 
9def c3 00 9a			jp macro_next 
9df2				endm 
# End of macro NEXTW
9df2			.COLN: 
9df2				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9df2 19				db WORD_SYS_CORE+OPCODE_COLN             
9df3 7e 9f			dw .SCOLN            
9df5 02				db 1 + 1 
9df6 .. 00			db ":",0              
9df8				endm 
# End of macro CWHEAD
9df8			; | : ( -- )         Create new word | DONE 
9df8			 
9df8					if DEBUG_FORTH_WORDS_KEY 
9df8						DMARK "CLN" 
9df8 f5				push af  
9df9 3a 0d 9e			ld a, (.dmark)  
9dfc 32 7a ee			ld (debug_mark),a  
9dff 3a 0e 9e			ld a, (.dmark+1)  
9e02 32 7b ee			ld (debug_mark+1),a  
9e05 3a 0f 9e			ld a, (.dmark+2)  
9e08 32 7c ee			ld (debug_mark+2),a  
9e0b 18 03			jr .pastdmark  
9e0d ..			.dmark: db "CLN"  
9e10 f1			.pastdmark: pop af  
9e11			endm  
# End of macro DMARK
9e11						CALLMONITOR 
9e11 cd 75 92			call break_point_state  
9e14				endm  
# End of macro CALLMONITOR
9e14					endif 
9e14				STACKFRAME OFF $8efe $989f 
9e14				if DEBUG_STACK_IMB 
9e14					if OFF 
9e14						exx 
9e14						ld de, $8efe 
9e14						ld a, d 
9e14						ld hl, curframe 
9e14						call hexout 
9e14						ld a, e 
9e14						ld hl, curframe+2 
9e14						call hexout 
9e14						ld hl, $8efe 
9e14						push hl 
9e14						ld hl, $989f 
9e14						push hl 
9e14						exx 
9e14					endif 
9e14				endif 
9e14			endm 
# End of macro STACKFRAME
9e14				; get parser buffer length  of new word 
9e14			 
9e14				 
9e14			 
9e14					; move tok past this to start of name defintition 
9e14					; TODO get word to define 
9e14					; TODO Move past word token 
9e14					; TODO get length of string up to the ';' 
9e14			 
9e14 2a 76 e6			ld hl, (os_tok_ptr) 
9e17 23				inc hl 
9e18 23				inc hl 
9e19			 
9e19 3e 3b			ld a, ';' 
9e1b cd c6 8e			call strlent 
9e1e			 
9e1e 7d				ld a,l 
9e1f 32 75 e5			ld (os_new_parse_len), a 
9e22			 
9e22			 
9e22			if DEBUG_FORTH_UWORD 
9e22 ed 5b 76 e6		ld de, (os_tok_ptr) 
9e26						DMARK ":01" 
9e26 f5				push af  
9e27 3a 3b 9e			ld a, (.dmark)  
9e2a 32 7a ee			ld (debug_mark),a  
9e2d 3a 3c 9e			ld a, (.dmark+1)  
9e30 32 7b ee			ld (debug_mark+1),a  
9e33 3a 3d 9e			ld a, (.dmark+2)  
9e36 32 7c ee			ld (debug_mark+2),a  
9e39 18 03			jr .pastdmark  
9e3b ..			.dmark: db ":01"  
9e3e f1			.pastdmark: pop af  
9e3f			endm  
# End of macro DMARK
9e3f				CALLMONITOR 
9e3f cd 75 92			call break_point_state  
9e42				endm  
# End of macro CALLMONITOR
9e42			endif 
9e42			 
9e42			; 
9e42			;  new word memory layout: 
9e42			;  
9e42			;    : adg 6666 ;  
9e42			; 
9e42			;    db   1     ; user defined word  
9e42 23				inc hl    
9e43			;    dw   sysdict 
9e43 23				inc hl 
9e44 23				inc hl 
9e45			;    db <word len>+1 (for null) 
9e45 23				inc hl 
9e46			;    db .... <word> 
9e46			; 
9e46			 
9e46 23				inc hl    ; some extras for the word preamble before the above 
9e47 23				inc hl 
9e48 23				inc hl 
9e49 23				inc hl 
9e4a 23				inc hl 
9e4b 23				inc hl 
9e4c 23				inc hl  
9e4d 23				inc hl 
9e4e 23				inc hl 
9e4f 23				inc hl 
9e50 23				inc hl 
9e51 23				inc hl 
9e52 23				inc hl 
9e53 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9e54			;       exec word buffer 
9e54			;	<ptr word>   
9e54 23				inc hl 
9e55 23				inc hl 
9e56			;       <word list><null term> 7F final term 
9e56			 
9e56			 
9e56			if DEBUG_FORTH_UWORD 
9e56						DMARK ":02" 
9e56 f5				push af  
9e57 3a 6b 9e			ld a, (.dmark)  
9e5a 32 7a ee			ld (debug_mark),a  
9e5d 3a 6c 9e			ld a, (.dmark+1)  
9e60 32 7b ee			ld (debug_mark+1),a  
9e63 3a 6d 9e			ld a, (.dmark+2)  
9e66 32 7c ee			ld (debug_mark+2),a  
9e69 18 03			jr .pastdmark  
9e6b ..			.dmark: db ":02"  
9e6e f1			.pastdmark: pop af  
9e6f			endm  
# End of macro DMARK
9e6f				CALLMONITOR 
9e6f cd 75 92			call break_point_state  
9e72				endm  
# End of macro CALLMONITOR
9e72			endif 
9e72			 
9e72				 
9e72					; malloc the size 
9e72			 
9e72 cd 24 8f				call malloc 
9e75 22 73 e5				ld (os_new_malloc), hl     ; save malloc start 
9e78			 
9e78			;    db   1     ; user defined word  
9e78 3e 01				ld a, WORD_SYS_UWORD  
9e7a 77					ld (hl), a 
9e7b				 
9e7b 23				inc hl    
9e7c			;    dw   sysdict 
9e7c 11 58 9b			ld de, sysdict       ; continue on with the scan to the system dict 
9e7f 73				ld (hl), e 
9e80 23				inc hl 
9e81 72				ld (hl), d 
9e82 23				inc hl 
9e83			 
9e83			 
9e83			;    Setup dict word 
9e83			 
9e83 23				inc hl 
9e84 22 79 e5			ld (os_new_work_ptr), hl     ; save start of dict word  
9e87			 
9e87				; 1. get length of dict word 
9e87			 
9e87			 
9e87 2a 76 e6			ld hl, (os_tok_ptr) 
9e8a 23				inc hl 
9e8b 23				inc hl    ; position to start of dict word 
9e8c 3e 00			ld a, 0 
9e8e cd c6 8e			call strlent 
9e91			 
9e91			 
9e91 23				inc hl    ; to include null??? 
9e92			 
9e92				; write length of dict word 
9e92			 
9e92 ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9e96 1b				dec de 
9e97 eb				ex de, hl 
9e98 73				ld (hl), e 
9e99 eb				ex de, hl 
9e9a			 
9e9a				 
9e9a			 
9e9a				; copy  
9e9a 4d				ld c, l 
9e9b 06 00			ld b, 0 
9e9d ed 5b 79 e5		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9ea1 2a 76 e6			ld hl, (os_tok_ptr) 
9ea4 23				inc hl 
9ea5 23				inc hl    ; position to start of dict word 
9ea6				 
9ea6			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9ea6				 
9ea6				; TODO need to convert word to upper case 
9ea6			 
9ea6			ucasetok:	 
9ea6 7e				ld a,(hl) 
9ea7 cd b2 8e			call toUpper 
9eaa 77				ld (hl),a 
9eab ed a0			ldi 
9ead f2 a6 9e		 	jp p, ucasetok 
9eb0			 
9eb0			 
9eb0			 
9eb0				; de now points to start of where the word body code should be placed 
9eb0 ed 53 79 e5		ld (os_new_work_ptr), de 
9eb4				; hl now points to the words to throw at forthexec which needs to be copied 
9eb4 22 7b e5			ld (os_new_src_ptr), hl 
9eb7			 
9eb7				; TODO add 'call to forthexec' 
9eb7			 
9eb7			if DEBUG_FORTH_UWORD 
9eb7 c5				push bc 
9eb8 ed 4b 73 e5		ld bc, (os_new_malloc) 
9ebc						DMARK ":0x" 
9ebc f5				push af  
9ebd 3a d1 9e			ld a, (.dmark)  
9ec0 32 7a ee			ld (debug_mark),a  
9ec3 3a d2 9e			ld a, (.dmark+1)  
9ec6 32 7b ee			ld (debug_mark+1),a  
9ec9 3a d3 9e			ld a, (.dmark+2)  
9ecc 32 7c ee			ld (debug_mark+2),a  
9ecf 18 03			jr .pastdmark  
9ed1 ..			.dmark: db ":0x"  
9ed4 f1			.pastdmark: pop af  
9ed5			endm  
# End of macro DMARK
9ed5				CALLMONITOR 
9ed5 cd 75 92			call break_point_state  
9ed8				endm  
# End of macro CALLMONITOR
9ed8 c1				pop bc 
9ed9			endif 
9ed9			 
9ed9			 
9ed9				; create word preamble which should be: 
9ed9			 
9ed9			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9ed9			 
9ed9				;    ld hl, <word code> 
9ed9				;    jp user_exec 
9ed9			        ;    <word code bytes> 
9ed9			 
9ed9			 
9ed9			;	inc de     ; TODO ??? or are we already past the word's null 
9ed9 eb				ex de, hl 
9eda			 
9eda 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9edc			 
9edc 23				inc hl 
9edd 22 7f e5			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9ee0 23				inc hl 
9ee1			 
9ee1 23				inc hl 
9ee2 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9ee4			 
9ee4 01 6d c2			ld bc, user_exec 
9ee7 23				inc hl 
9ee8 71				ld (hl), c     ; poke address of user_exec 
9ee9 23				inc hl 
9eea 70				ld (hl), b     
9eeb			 ; 
9eeb			;	inc hl 
9eeb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9eeb			; 
9eeb			; 
9eeb			;	ld bc, macro_forth_rsp_next 
9eeb			;	inc hl 
9eeb			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9eeb			;	inc hl 
9eeb			;	ld (hl), b     
9eeb			 ; 
9eeb			;	inc hl 
9eeb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9eeb			; 
9eeb			; 
9eeb			;	inc hl 
9eeb			;	ld bc, forthexec 
9eeb			;	ld (hl), c     ; poke address of forthexec 
9eeb			;	inc hl 
9eeb			;	ld (hl), b      
9eeb			; 
9eeb			;	inc hl 
9eeb			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9eeb			; 
9eeb			;	ld bc, user_dict_next 
9eeb			;	inc hl 
9eeb			;	ld (hl), c     ; poke address of forthexec 
9eeb			;	inc hl 
9eeb			;	ld (hl), b      
9eeb			 
9eeb				; hl is now where we need to copy the word byte data to save this 
9eeb			 
9eeb 23				inc hl 
9eec 22 7d e5			ld (os_new_exec), hl 
9eef				 
9eef				; copy definition 
9eef			 
9eef eb				ex de, hl 
9ef0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9ef0			;	inc de    ; skip the PC for this parse 
9ef0 3a 75 e5			ld a, (os_new_parse_len) 
9ef3 4f				ld c, a 
9ef4 06 00			ld b, 0 
9ef6 ed b0			ldir		 ; copy defintion 
9ef8			 
9ef8			 
9ef8				; poke the address of where the new word bytes live for forthexec 
9ef8			 
9ef8 2a 7f e5			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9efb			 
9efb ed 5b 7d e5		ld de, (os_new_exec)      
9eff				 
9eff 73				ld (hl), e 
9f00 23				inc hl 
9f01 72				ld (hl), d 
9f02			 
9f02					; TODO copy last user dict word next link to this word 
9f02					; TODO update last user dict word to point to this word 
9f02			; 
9f02			; hl f923 de 812a ; bc 811a 
9f02			 
9f02			if DEBUG_FORTH_UWORD 
9f02 c5				push bc 
9f03 ed 4b 73 e5		ld bc, (os_new_malloc) 
9f07						DMARK ":0A" 
9f07 f5				push af  
9f08 3a 1c 9f			ld a, (.dmark)  
9f0b 32 7a ee			ld (debug_mark),a  
9f0e 3a 1d 9f			ld a, (.dmark+1)  
9f11 32 7b ee			ld (debug_mark+1),a  
9f14 3a 1e 9f			ld a, (.dmark+2)  
9f17 32 7c ee			ld (debug_mark+2),a  
9f1a 18 03			jr .pastdmark  
9f1c ..			.dmark: db ":0A"  
9f1f f1			.pastdmark: pop af  
9f20			endm  
# End of macro DMARK
9f20				CALLMONITOR 
9f20 cd 75 92			call break_point_state  
9f23				endm  
# End of macro CALLMONITOR
9f23 c1				pop bc 
9f24			endif 
9f24			if DEBUG_FORTH_UWORD 
9f24 c5				push bc 
9f25 ed 4b 73 e5		ld bc, (os_new_malloc) 
9f29 03				inc bc 
9f2a 03				inc bc 
9f2b 03				inc bc 
9f2c 03				inc bc 
9f2d 03				inc bc 
9f2e 03				inc bc 
9f2f 03				inc bc 
9f30 03				inc bc 
9f31			 
9f31						DMARK ":0B" 
9f31 f5				push af  
9f32 3a 46 9f			ld a, (.dmark)  
9f35 32 7a ee			ld (debug_mark),a  
9f38 3a 47 9f			ld a, (.dmark+1)  
9f3b 32 7b ee			ld (debug_mark+1),a  
9f3e 3a 48 9f			ld a, (.dmark+2)  
9f41 32 7c ee			ld (debug_mark+2),a  
9f44 18 03			jr .pastdmark  
9f46 ..			.dmark: db ":0B"  
9f49 f1			.pastdmark: pop af  
9f4a			endm  
# End of macro DMARK
9f4a				CALLMONITOR 
9f4a cd 75 92			call break_point_state  
9f4d				endm  
# End of macro CALLMONITOR
9f4d c1				pop bc 
9f4e			endif 
9f4e			 
9f4e			; update word dict linked list for new word 
9f4e			 
9f4e			 
9f4e 2a 72 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
9f51 23			inc hl     ; move to next work linked list ptr 
9f52			 
9f52 ed 5b 73 e5	ld de, (os_new_malloc)		 ; new next word 
9f56 73			ld (hl), e 
9f57 23			inc hl 
9f58 72			ld (hl), d 
9f59			 
9f59			if DEBUG_FORTH_UWORD 
9f59 ed 4b 72 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
9f5d			endif 
9f5d			 
9f5d ed 53 72 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
9f61			 
9f61			 
9f61			if DEBUG_FORTH_UWORD 
9f61						DMARK ":0+" 
9f61 f5				push af  
9f62 3a 76 9f			ld a, (.dmark)  
9f65 32 7a ee			ld (debug_mark),a  
9f68 3a 77 9f			ld a, (.dmark+1)  
9f6b 32 7b ee			ld (debug_mark+1),a  
9f6e 3a 78 9f			ld a, (.dmark+2)  
9f71 32 7c ee			ld (debug_mark+2),a  
9f74 18 03			jr .pastdmark  
9f76 ..			.dmark: db ":0+"  
9f79 f1			.pastdmark: pop af  
9f7a			endm  
# End of macro DMARK
9f7a				CALLMONITOR 
9f7a cd 75 92			call break_point_state  
9f7d				endm  
# End of macro CALLMONITOR
9f7d			endif 
9f7d			 
9f7d				STACKFRAMECHK OFF $8efe $989f 
9f7d				if DEBUG_STACK_IMB 
9f7d					if OFF 
9f7d						exx 
9f7d						ld hl, $989f 
9f7d						pop de   ; $989f 
9f7d						call cmp16 
9f7d						jr nz, .spnosame 
9f7d						ld hl, $8efe 
9f7d						pop de   ; $8efe 
9f7d						call cmp16 
9f7d						jr z, .spfrsame 
9f7d						.spnosame: call showsperror 
9f7d						.spfrsame: nop 
9f7d						exx 
9f7d					endif 
9f7d				endif 
9f7d			endm 
# End of macro STACKFRAMECHK
9f7d			 
9f7d c9			ret    ; dont process any remaining parser tokens as they form new word 
9f7e			 
9f7e			 
9f7e			 
9f7e			 
9f7e			;		NEXT 
9f7e			.SCOLN: 
9f7e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
9f7e 06				db OPCODE_SCOLN 
9f7f ca 9f			dw .DROP 
9f81 02				db 2 
9f82 .. 00			db ";",0           
9f84			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
9f84					if DEBUG_FORTH_WORDS_KEY 
9f84						DMARK "SCN" 
9f84 f5				push af  
9f85 3a 99 9f			ld a, (.dmark)  
9f88 32 7a ee			ld (debug_mark),a  
9f8b 3a 9a 9f			ld a, (.dmark+1)  
9f8e 32 7b ee			ld (debug_mark+1),a  
9f91 3a 9b 9f			ld a, (.dmark+2)  
9f94 32 7c ee			ld (debug_mark+2),a  
9f97 18 03			jr .pastdmark  
9f99 ..			.dmark: db "SCN"  
9f9c f1			.pastdmark: pop af  
9f9d			endm  
# End of macro DMARK
9f9d						CALLMONITOR 
9f9d cd 75 92			call break_point_state  
9fa0				endm  
# End of macro CALLMONITOR
9fa0					endif 
9fa0					FORTH_RSP_TOS 
9fa0 cd cd 97			call macro_forth_rsp_tos 
9fa3				endm 
# End of macro FORTH_RSP_TOS
9fa3 e5					push hl 
9fa4					FORTH_RSP_POP 
9fa4 cd d7 97			call macro_forth_rsp_pop 
9fa7				endm 
# End of macro FORTH_RSP_POP
9fa7 e1					pop hl 
9fa8			;		ex de,hl 
9fa8 22 76 e6				ld (os_tok_ptr),hl 
9fab			 
9fab			if DEBUG_FORTH_UWORD 
9fab						DMARK "SCL" 
9fab f5				push af  
9fac 3a c0 9f			ld a, (.dmark)  
9faf 32 7a ee			ld (debug_mark),a  
9fb2 3a c1 9f			ld a, (.dmark+1)  
9fb5 32 7b ee			ld (debug_mark+1),a  
9fb8 3a c2 9f			ld a, (.dmark+2)  
9fbb 32 7c ee			ld (debug_mark+2),a  
9fbe 18 03			jr .pastdmark  
9fc0 ..			.dmark: db "SCL"  
9fc3 f1			.pastdmark: pop af  
9fc4			endm  
# End of macro DMARK
9fc4				CALLMONITOR 
9fc4 cd 75 92			call break_point_state  
9fc7				endm  
# End of macro CALLMONITOR
9fc7			endif 
9fc7					NEXTW 
9fc7 c3 00 9a			jp macro_next 
9fca				endm 
# End of macro NEXTW
9fca			 
9fca			.DROP: 
9fca				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
9fca 1b				db WORD_SYS_CORE+OPCODE_DROP             
9fcb f5 9f			dw .DUP2            
9fcd 05				db 4 + 1 
9fce .. 00			db "DROP",0              
9fd3				endm 
# End of macro CWHEAD
9fd3			; | DROP ( w -- )   drop the TOS item   | DONE 
9fd3					if DEBUG_FORTH_WORDS_KEY 
9fd3						DMARK "DRP" 
9fd3 f5				push af  
9fd4 3a e8 9f			ld a, (.dmark)  
9fd7 32 7a ee			ld (debug_mark),a  
9fda 3a e9 9f			ld a, (.dmark+1)  
9fdd 32 7b ee			ld (debug_mark+1),a  
9fe0 3a ea 9f			ld a, (.dmark+2)  
9fe3 32 7c ee			ld (debug_mark+2),a  
9fe6 18 03			jr .pastdmark  
9fe8 ..			.dmark: db "DRP"  
9feb f1			.pastdmark: pop af  
9fec			endm  
# End of macro DMARK
9fec						CALLMONITOR 
9fec cd 75 92			call break_point_state  
9fef				endm  
# End of macro CALLMONITOR
9fef					endif 
9fef					FORTH_DSP_POP 
9fef cd 46 99			call macro_forth_dsp_pop 
9ff2				endm 
# End of macro FORTH_DSP_POP
9ff2					NEXTW 
9ff2 c3 00 9a			jp macro_next 
9ff5				endm 
# End of macro NEXTW
9ff5			.DUP2: 
9ff5				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
9ff5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
9ff6 3a a0			dw .DROP2            
9ff8 05				db 4 + 1 
9ff9 .. 00			db "2DUP",0              
9ffe				endm 
# End of macro CWHEAD
9ffe			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
9ffe					if DEBUG_FORTH_WORDS_KEY 
9ffe						DMARK "2DU" 
9ffe f5				push af  
9fff 3a 13 a0			ld a, (.dmark)  
a002 32 7a ee			ld (debug_mark),a  
a005 3a 14 a0			ld a, (.dmark+1)  
a008 32 7b ee			ld (debug_mark+1),a  
a00b 3a 15 a0			ld a, (.dmark+2)  
a00e 32 7c ee			ld (debug_mark+2),a  
a011 18 03			jr .pastdmark  
a013 ..			.dmark: db "2DU"  
a016 f1			.pastdmark: pop af  
a017			endm  
# End of macro DMARK
a017						CALLMONITOR 
a017 cd 75 92			call break_point_state  
a01a				endm  
# End of macro CALLMONITOR
a01a					endif 
a01a					FORTH_DSP_VALUEHL 
a01a cd aa 98			call macro_dsp_valuehl 
a01d				endm 
# End of macro FORTH_DSP_VALUEHL
a01d e5					push hl      ; 2 
a01e			 
a01e					FORTH_DSP_POP 
a01e cd 46 99			call macro_forth_dsp_pop 
a021				endm 
# End of macro FORTH_DSP_POP
a021					 
a021					FORTH_DSP_VALUEHL 
a021 cd aa 98			call macro_dsp_valuehl 
a024				endm 
# End of macro FORTH_DSP_VALUEHL
a024			;		push hl      ; 1 
a024			 
a024					FORTH_DSP_POP 
a024 cd 46 99			call macro_forth_dsp_pop 
a027				endm 
# End of macro FORTH_DSP_POP
a027			 
a027			;		pop hl       ; 1 
a027 d1					pop de       ; 2 
a028			 
a028 cd 0f 98				call forth_push_numhl 
a02b eb					ex de, hl 
a02c cd 0f 98				call forth_push_numhl 
a02f			 
a02f					 
a02f eb					ex de, hl 
a030			 
a030 cd 0f 98				call forth_push_numhl 
a033 eb					ex de, hl 
a034 cd 0f 98				call forth_push_numhl 
a037			 
a037			 
a037					NEXTW 
a037 c3 00 9a			jp macro_next 
a03a				endm 
# End of macro NEXTW
a03a			.DROP2: 
a03a				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a03a 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a03b 69 a0			dw .SWAP2            
a03d 06				db 5 + 1 
a03e .. 00			db "2DROP",0              
a044				endm 
# End of macro CWHEAD
a044			; | 2DROP ( w w -- )    Double drop | DONE 
a044					if DEBUG_FORTH_WORDS_KEY 
a044						DMARK "2DR" 
a044 f5				push af  
a045 3a 59 a0			ld a, (.dmark)  
a048 32 7a ee			ld (debug_mark),a  
a04b 3a 5a a0			ld a, (.dmark+1)  
a04e 32 7b ee			ld (debug_mark+1),a  
a051 3a 5b a0			ld a, (.dmark+2)  
a054 32 7c ee			ld (debug_mark+2),a  
a057 18 03			jr .pastdmark  
a059 ..			.dmark: db "2DR"  
a05c f1			.pastdmark: pop af  
a05d			endm  
# End of macro DMARK
a05d						CALLMONITOR 
a05d cd 75 92			call break_point_state  
a060				endm  
# End of macro CALLMONITOR
a060					endif 
a060					FORTH_DSP_POP 
a060 cd 46 99			call macro_forth_dsp_pop 
a063				endm 
# End of macro FORTH_DSP_POP
a063					FORTH_DSP_POP 
a063 cd 46 99			call macro_forth_dsp_pop 
a066				endm 
# End of macro FORTH_DSP_POP
a066					NEXTW 
a066 c3 00 9a			jp macro_next 
a069				endm 
# End of macro NEXTW
a069			.SWAP2: 
a069				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a069 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a06a 92 a0			dw .AT            
a06c 06				db 5 + 1 
a06d .. 00			db "2SWAP",0              
a073				endm 
# End of macro CWHEAD
a073			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a073					if DEBUG_FORTH_WORDS_KEY 
a073						DMARK "2SW" 
a073 f5				push af  
a074 3a 88 a0			ld a, (.dmark)  
a077 32 7a ee			ld (debug_mark),a  
a07a 3a 89 a0			ld a, (.dmark+1)  
a07d 32 7b ee			ld (debug_mark+1),a  
a080 3a 8a a0			ld a, (.dmark+2)  
a083 32 7c ee			ld (debug_mark+2),a  
a086 18 03			jr .pastdmark  
a088 ..			.dmark: db "2SW"  
a08b f1			.pastdmark: pop af  
a08c			endm  
# End of macro DMARK
a08c						CALLMONITOR 
a08c cd 75 92			call break_point_state  
a08f				endm  
# End of macro CALLMONITOR
a08f					endif 
a08f					NEXTW 
a08f c3 00 9a			jp macro_next 
a092				endm 
# End of macro NEXTW
a092			.AT: 
a092				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a092 1f				db WORD_SYS_CORE+OPCODE_AT             
a093 c4 a0			dw .CAT            
a095 02				db 1 + 1 
a096 .. 00			db "@",0              
a098				endm 
# End of macro CWHEAD
a098			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a098			 
a098					if DEBUG_FORTH_WORDS_KEY 
a098						DMARK "AT." 
a098 f5				push af  
a099 3a ad a0			ld a, (.dmark)  
a09c 32 7a ee			ld (debug_mark),a  
a09f 3a ae a0			ld a, (.dmark+1)  
a0a2 32 7b ee			ld (debug_mark+1),a  
a0a5 3a af a0			ld a, (.dmark+2)  
a0a8 32 7c ee			ld (debug_mark+2),a  
a0ab 18 03			jr .pastdmark  
a0ad ..			.dmark: db "AT."  
a0b0 f1			.pastdmark: pop af  
a0b1			endm  
# End of macro DMARK
a0b1						CALLMONITOR 
a0b1 cd 75 92			call break_point_state  
a0b4				endm  
# End of macro CALLMONITOR
a0b4					endif 
a0b4			.getbyteat:	 
a0b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0b4 cd aa 98			call macro_dsp_valuehl 
a0b7				endm 
# End of macro FORTH_DSP_VALUEHL
a0b7					 
a0b7			;		push hl 
a0b7				 
a0b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a0b7 cd 46 99			call macro_forth_dsp_pop 
a0ba				endm 
# End of macro FORTH_DSP_POP
a0ba			 
a0ba			;		pop hl 
a0ba			 
a0ba 7e					ld a, (hl) 
a0bb			 
a0bb 6f					ld l, a 
a0bc 26 00				ld h, 0 
a0be cd 0f 98				call forth_push_numhl 
a0c1			 
a0c1					NEXTW 
a0c1 c3 00 9a			jp macro_next 
a0c4				endm 
# End of macro NEXTW
a0c4			.CAT: 
a0c4				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a0c4 20				db WORD_SYS_CORE+OPCODE_CAT             
a0c5 ed a0			dw .BANG            
a0c7 03				db 2 + 1 
a0c8 .. 00			db "C@",0              
a0cb				endm 
# End of macro CWHEAD
a0cb			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a0cb					if DEBUG_FORTH_WORDS_KEY 
a0cb						DMARK "CAA" 
a0cb f5				push af  
a0cc 3a e0 a0			ld a, (.dmark)  
a0cf 32 7a ee			ld (debug_mark),a  
a0d2 3a e1 a0			ld a, (.dmark+1)  
a0d5 32 7b ee			ld (debug_mark+1),a  
a0d8 3a e2 a0			ld a, (.dmark+2)  
a0db 32 7c ee			ld (debug_mark+2),a  
a0de 18 03			jr .pastdmark  
a0e0 ..			.dmark: db "CAA"  
a0e3 f1			.pastdmark: pop af  
a0e4			endm  
# End of macro DMARK
a0e4						CALLMONITOR 
a0e4 cd 75 92			call break_point_state  
a0e7				endm  
# End of macro CALLMONITOR
a0e7					endif 
a0e7 c3 b4 a0				jp .getbyteat 
a0ea					NEXTW 
a0ea c3 00 9a			jp macro_next 
a0ed				endm 
# End of macro NEXTW
a0ed			.BANG: 
a0ed				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a0ed 21				db WORD_SYS_CORE+OPCODE_BANG             
a0ee 23 a1			dw .CBANG            
a0f0 02				db 1 + 1 
a0f1 .. 00			db "!",0              
a0f3				endm 
# End of macro CWHEAD
a0f3			; | ! ( x w -- ) Store x at address w      | DONE 
a0f3					if DEBUG_FORTH_WORDS_KEY 
a0f3						DMARK "BNG" 
a0f3 f5				push af  
a0f4 3a 08 a1			ld a, (.dmark)  
a0f7 32 7a ee			ld (debug_mark),a  
a0fa 3a 09 a1			ld a, (.dmark+1)  
a0fd 32 7b ee			ld (debug_mark+1),a  
a100 3a 0a a1			ld a, (.dmark+2)  
a103 32 7c ee			ld (debug_mark+2),a  
a106 18 03			jr .pastdmark  
a108 ..			.dmark: db "BNG"  
a10b f1			.pastdmark: pop af  
a10c			endm  
# End of macro DMARK
a10c						CALLMONITOR 
a10c cd 75 92			call break_point_state  
a10f				endm  
# End of macro CALLMONITOR
a10f					endif 
a10f			 
a10f			.storebyteat:		 
a10f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a10f cd aa 98			call macro_dsp_valuehl 
a112				endm 
# End of macro FORTH_DSP_VALUEHL
a112					 
a112 e5					push hl 
a113				 
a113					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a113 cd 46 99			call macro_forth_dsp_pop 
a116				endm 
# End of macro FORTH_DSP_POP
a116			 
a116					; get byte to poke 
a116			 
a116					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a116 cd aa 98			call macro_dsp_valuehl 
a119				endm 
# End of macro FORTH_DSP_VALUEHL
a119 e5					push hl 
a11a			 
a11a			 
a11a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a11a cd 46 99			call macro_forth_dsp_pop 
a11d				endm 
# End of macro FORTH_DSP_POP
a11d			 
a11d			 
a11d d1					pop de 
a11e e1					pop hl 
a11f			 
a11f 73					ld (hl),e 
a120			 
a120			 
a120					NEXTW 
a120 c3 00 9a			jp macro_next 
a123				endm 
# End of macro NEXTW
a123			.CBANG: 
a123				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a123 22				db WORD_SYS_CORE+OPCODE_CBANG             
a124 4c a1			dw .SCALL            
a126 03				db 2 + 1 
a127 .. 00			db "C!",0              
a12a				endm 
# End of macro CWHEAD
a12a			; | C!  ( x w -- ) Store x at address w  | DONE 
a12a					if DEBUG_FORTH_WORDS_KEY 
a12a						DMARK "CBA" 
a12a f5				push af  
a12b 3a 3f a1			ld a, (.dmark)  
a12e 32 7a ee			ld (debug_mark),a  
a131 3a 40 a1			ld a, (.dmark+1)  
a134 32 7b ee			ld (debug_mark+1),a  
a137 3a 41 a1			ld a, (.dmark+2)  
a13a 32 7c ee			ld (debug_mark+2),a  
a13d 18 03			jr .pastdmark  
a13f ..			.dmark: db "CBA"  
a142 f1			.pastdmark: pop af  
a143			endm  
# End of macro DMARK
a143						CALLMONITOR 
a143 cd 75 92			call break_point_state  
a146				endm  
# End of macro CALLMONITOR
a146					endif 
a146 c3 0f a1				jp .storebyteat 
a149					NEXTW 
a149 c3 00 9a			jp macro_next 
a14c				endm 
# End of macro NEXTW
a14c			.SCALL: 
a14c				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a14c 23				db WORD_SYS_CORE+OPCODE_SCALL             
a14d 80 a1			dw .DEPTH            
a14f 05				db 4 + 1 
a150 .. 00			db "CALL",0              
a155				endm 
# End of macro CWHEAD
a155			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a155					if DEBUG_FORTH_WORDS_KEY 
a155						DMARK "CLL" 
a155 f5				push af  
a156 3a 6a a1			ld a, (.dmark)  
a159 32 7a ee			ld (debug_mark),a  
a15c 3a 6b a1			ld a, (.dmark+1)  
a15f 32 7b ee			ld (debug_mark+1),a  
a162 3a 6c a1			ld a, (.dmark+2)  
a165 32 7c ee			ld (debug_mark+2),a  
a168 18 03			jr .pastdmark  
a16a ..			.dmark: db "CLL"  
a16d f1			.pastdmark: pop af  
a16e			endm  
# End of macro DMARK
a16e						CALLMONITOR 
a16e cd 75 92			call break_point_state  
a171				endm  
# End of macro CALLMONITOR
a171					endif 
a171			 
a171					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a171 cd aa 98			call macro_dsp_valuehl 
a174				endm 
# End of macro FORTH_DSP_VALUEHL
a174			 
a174			;		push hl 
a174			 
a174					; destroy value TOS 
a174			 
a174					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a174 cd 46 99			call macro_forth_dsp_pop 
a177				endm 
# End of macro FORTH_DSP_POP
a177			 
a177						 
a177			;		pop hl 
a177			 
a177					; how to do a call with hl???? save SP? 
a177 cd a9 99				call forth_call_hl 
a17a			 
a17a			 
a17a					; TODO push value back onto stack for another op etc 
a17a			 
a17a cd 0f 98				call forth_push_numhl 
a17d					NEXTW 
a17d c3 00 9a			jp macro_next 
a180				endm 
# End of macro NEXTW
a180			.DEPTH: 
a180				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a180 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a181 bd a1			dw .OVER            
a183 06				db 5 + 1 
a184 .. 00			db "DEPTH",0              
a18a				endm 
# End of macro CWHEAD
a18a			; | DEPTH ( -- u ) Push count of stack | DONE 
a18a					; take current TOS and remove from base value div by two to get count 
a18a					if DEBUG_FORTH_WORDS_KEY 
a18a						DMARK "DEP" 
a18a f5				push af  
a18b 3a 9f a1			ld a, (.dmark)  
a18e 32 7a ee			ld (debug_mark),a  
a191 3a a0 a1			ld a, (.dmark+1)  
a194 32 7b ee			ld (debug_mark+1),a  
a197 3a a1 a1			ld a, (.dmark+2)  
a19a 32 7c ee			ld (debug_mark+2),a  
a19d 18 03			jr .pastdmark  
a19f ..			.dmark: db "DEP"  
a1a2 f1			.pastdmark: pop af  
a1a3			endm  
# End of macro DMARK
a1a3						CALLMONITOR 
a1a3 cd 75 92			call break_point_state  
a1a6				endm  
# End of macro CALLMONITOR
a1a6					endif 
a1a6			 
a1a6			 
a1a6 2a 22 eb			ld hl, (cli_data_sp) 
a1a9 11 dc e8			ld de, cli_data_stack 
a1ac ed 52			sbc hl,de 
a1ae				 
a1ae				; div by size of stack item 
a1ae			 
a1ae 5d				ld e,l 
a1af 0e 03			ld c, 3 
a1b1 cd ed 89			call Div8 
a1b4			 
a1b4 6f				ld l,a 
a1b5 26 00			ld h,0 
a1b7			 
a1b7				;srl h 
a1b7				;rr l 
a1b7			 
a1b7 cd 0f 98				call forth_push_numhl 
a1ba					NEXTW 
a1ba c3 00 9a			jp macro_next 
a1bd				endm 
# End of macro NEXTW
a1bd			.OVER: 
a1bd				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a1bd 42				db WORD_SYS_CORE+46             
a1be 04 a2			dw .PAUSE            
a1c0 05				db 4 + 1 
a1c1 .. 00			db "OVER",0              
a1c6				endm 
# End of macro CWHEAD
a1c6			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a1c6					if DEBUG_FORTH_WORDS_KEY 
a1c6						DMARK "OVR" 
a1c6 f5				push af  
a1c7 3a db a1			ld a, (.dmark)  
a1ca 32 7a ee			ld (debug_mark),a  
a1cd 3a dc a1			ld a, (.dmark+1)  
a1d0 32 7b ee			ld (debug_mark+1),a  
a1d3 3a dd a1			ld a, (.dmark+2)  
a1d6 32 7c ee			ld (debug_mark+2),a  
a1d9 18 03			jr .pastdmark  
a1db ..			.dmark: db "OVR"  
a1de f1			.pastdmark: pop af  
a1df			endm  
# End of macro DMARK
a1df						CALLMONITOR 
a1df cd 75 92			call break_point_state  
a1e2				endm  
# End of macro CALLMONITOR
a1e2					endif 
a1e2			 
a1e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1e2 cd aa 98			call macro_dsp_valuehl 
a1e5				endm 
# End of macro FORTH_DSP_VALUEHL
a1e5 e5					push hl    ; n2 
a1e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1e6 cd 46 99			call macro_forth_dsp_pop 
a1e9				endm 
# End of macro FORTH_DSP_POP
a1e9			 
a1e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1e9 cd aa 98			call macro_dsp_valuehl 
a1ec				endm 
# End of macro FORTH_DSP_VALUEHL
a1ec e5					push hl    ; n1 
a1ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1ed cd 46 99			call macro_forth_dsp_pop 
a1f0				endm 
# End of macro FORTH_DSP_POP
a1f0			 
a1f0 d1					pop de     ; n1 
a1f1 e1					pop hl     ; n2 
a1f2			 
a1f2 d5					push de 
a1f3 e5					push hl 
a1f4 d5					push de 
a1f5			 
a1f5					; push back  
a1f5			 
a1f5 e1					pop hl 
a1f6 cd 0f 98				call forth_push_numhl 
a1f9 e1					pop hl 
a1fa cd 0f 98				call forth_push_numhl 
a1fd e1					pop hl 
a1fe cd 0f 98				call forth_push_numhl 
a201					NEXTW 
a201 c3 00 9a			jp macro_next 
a204				endm 
# End of macro NEXTW
a204			 
a204			.PAUSE: 
a204				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a204 43				db WORD_SYS_CORE+47             
a205 39 a2			dw .PAUSES            
a207 08				db 7 + 1 
a208 .. 00			db "PAUSEMS",0              
a210				endm 
# End of macro CWHEAD
a210			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a210					if DEBUG_FORTH_WORDS_KEY 
a210						DMARK "PMS" 
a210 f5				push af  
a211 3a 25 a2			ld a, (.dmark)  
a214 32 7a ee			ld (debug_mark),a  
a217 3a 26 a2			ld a, (.dmark+1)  
a21a 32 7b ee			ld (debug_mark+1),a  
a21d 3a 27 a2			ld a, (.dmark+2)  
a220 32 7c ee			ld (debug_mark+2),a  
a223 18 03			jr .pastdmark  
a225 ..			.dmark: db "PMS"  
a228 f1			.pastdmark: pop af  
a229			endm  
# End of macro DMARK
a229						CALLMONITOR 
a229 cd 75 92			call break_point_state  
a22c				endm  
# End of macro CALLMONITOR
a22c					endif 
a22c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a22c cd aa 98			call macro_dsp_valuehl 
a22f				endm 
# End of macro FORTH_DSP_VALUEHL
a22f			;		push hl    ; n2 
a22f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a22f cd 46 99			call macro_forth_dsp_pop 
a232				endm 
# End of macro FORTH_DSP_POP
a232			;		pop hl 
a232			 
a232 7d					ld a, l 
a233 cd c7 87				call aDelayInMS 
a236				       NEXTW 
a236 c3 00 9a			jp macro_next 
a239				endm 
# End of macro NEXTW
a239			.PAUSES:  
a239				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a239 44				db WORD_SYS_CORE+48             
a23a a8 a2			dw .ROT            
a23c 06				db 5 + 1 
a23d .. 00			db "PAUSE",0              
a243				endm 
# End of macro CWHEAD
a243			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a243					if DEBUG_FORTH_WORDS_KEY 
a243						DMARK "PAU" 
a243 f5				push af  
a244 3a 58 a2			ld a, (.dmark)  
a247 32 7a ee			ld (debug_mark),a  
a24a 3a 59 a2			ld a, (.dmark+1)  
a24d 32 7b ee			ld (debug_mark+1),a  
a250 3a 5a a2			ld a, (.dmark+2)  
a253 32 7c ee			ld (debug_mark+2),a  
a256 18 03			jr .pastdmark  
a258 ..			.dmark: db "PAU"  
a25b f1			.pastdmark: pop af  
a25c			endm  
# End of macro DMARK
a25c						CALLMONITOR 
a25c cd 75 92			call break_point_state  
a25f				endm  
# End of macro CALLMONITOR
a25f					endif 
a25f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a25f cd aa 98			call macro_dsp_valuehl 
a262				endm 
# End of macro FORTH_DSP_VALUEHL
a262			;		push hl    ; n2 
a262					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a262 cd 46 99			call macro_forth_dsp_pop 
a265				endm 
# End of macro FORTH_DSP_POP
a265			;		pop hl 
a265 45					ld b, l 
a266					if DEBUG_FORTH_WORDS 
a266						DMARK "PAU" 
a266 f5				push af  
a267 3a 7b a2			ld a, (.dmark)  
a26a 32 7a ee			ld (debug_mark),a  
a26d 3a 7c a2			ld a, (.dmark+1)  
a270 32 7b ee			ld (debug_mark+1),a  
a273 3a 7d a2			ld a, (.dmark+2)  
a276 32 7c ee			ld (debug_mark+2),a  
a279 18 03			jr .pastdmark  
a27b ..			.dmark: db "PAU"  
a27e f1			.pastdmark: pop af  
a27f			endm  
# End of macro DMARK
a27f						CALLMONITOR 
a27f cd 75 92			call break_point_state  
a282				endm  
# End of macro CALLMONITOR
a282					endif 
a282 c5			.pauses1:	push bc 
a283 cd e2 87				call delay1s 
a286 c1					pop bc 
a287					if DEBUG_FORTH_WORDS 
a287						DMARK "PA1" 
a287 f5				push af  
a288 3a 9c a2			ld a, (.dmark)  
a28b 32 7a ee			ld (debug_mark),a  
a28e 3a 9d a2			ld a, (.dmark+1)  
a291 32 7b ee			ld (debug_mark+1),a  
a294 3a 9e a2			ld a, (.dmark+2)  
a297 32 7c ee			ld (debug_mark+2),a  
a29a 18 03			jr .pastdmark  
a29c ..			.dmark: db "PA1"  
a29f f1			.pastdmark: pop af  
a2a0			endm  
# End of macro DMARK
a2a0						CALLMONITOR 
a2a0 cd 75 92			call break_point_state  
a2a3				endm  
# End of macro CALLMONITOR
a2a3					endif 
a2a3 10 dd				djnz .pauses1 
a2a5			 
a2a5				       NEXTW 
a2a5 c3 00 9a			jp macro_next 
a2a8				endm 
# End of macro NEXTW
a2a8			.ROT: 
a2a8				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a2a8 45				db WORD_SYS_CORE+49             
a2a9 f6 a2			dw .UWORDS            
a2ab 04				db 3 + 1 
a2ac .. 00			db "ROT",0              
a2b0				endm 
# End of macro CWHEAD
a2b0			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a2b0					if DEBUG_FORTH_WORDS_KEY 
a2b0						DMARK "ROT" 
a2b0 f5				push af  
a2b1 3a c5 a2			ld a, (.dmark)  
a2b4 32 7a ee			ld (debug_mark),a  
a2b7 3a c6 a2			ld a, (.dmark+1)  
a2ba 32 7b ee			ld (debug_mark+1),a  
a2bd 3a c7 a2			ld a, (.dmark+2)  
a2c0 32 7c ee			ld (debug_mark+2),a  
a2c3 18 03			jr .pastdmark  
a2c5 ..			.dmark: db "ROT"  
a2c8 f1			.pastdmark: pop af  
a2c9			endm  
# End of macro DMARK
a2c9						CALLMONITOR 
a2c9 cd 75 92			call break_point_state  
a2cc				endm  
# End of macro CALLMONITOR
a2cc					endif 
a2cc			 
a2cc					FORTH_DSP_VALUEHL 
a2cc cd aa 98			call macro_dsp_valuehl 
a2cf				endm 
# End of macro FORTH_DSP_VALUEHL
a2cf e5					push hl    ; u3  
a2d0			 
a2d0					FORTH_DSP_POP 
a2d0 cd 46 99			call macro_forth_dsp_pop 
a2d3				endm 
# End of macro FORTH_DSP_POP
a2d3			   
a2d3					FORTH_DSP_VALUEHL 
a2d3 cd aa 98			call macro_dsp_valuehl 
a2d6				endm 
# End of macro FORTH_DSP_VALUEHL
a2d6 e5					push hl     ; u2 
a2d7			 
a2d7					FORTH_DSP_POP 
a2d7 cd 46 99			call macro_forth_dsp_pop 
a2da				endm 
# End of macro FORTH_DSP_POP
a2da			 
a2da					FORTH_DSP_VALUEHL 
a2da cd aa 98			call macro_dsp_valuehl 
a2dd				endm 
# End of macro FORTH_DSP_VALUEHL
a2dd e5					push hl     ; u1 
a2de			 
a2de					FORTH_DSP_POP 
a2de cd 46 99			call macro_forth_dsp_pop 
a2e1				endm 
# End of macro FORTH_DSP_POP
a2e1			 
a2e1 c1					pop bc      ; u1 
a2e2 e1					pop hl      ; u2 
a2e3 d1					pop de      ; u3 
a2e4			 
a2e4			 
a2e4 c5					push bc 
a2e5 d5					push de 
a2e6 e5					push hl 
a2e7			 
a2e7			 
a2e7 e1					pop hl 
a2e8 cd 0f 98				call forth_push_numhl 
a2eb			 
a2eb e1					pop hl 
a2ec cd 0f 98				call forth_push_numhl 
a2ef			 
a2ef e1					pop hl 
a2f0 cd 0f 98				call forth_push_numhl 
a2f3					 
a2f3			 
a2f3			 
a2f3			 
a2f3			 
a2f3			 
a2f3				       NEXTW 
a2f3 c3 00 9a			jp macro_next 
a2f6				endm 
# End of macro NEXTW
a2f6			 
a2f6			.UWORDS: 
a2f6				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a2f6 50				db WORD_SYS_CORE+60             
a2f7 b8 a3			dw .BP            
a2f9 07				db 6 + 1 
a2fa .. 00			db "UWORDS",0              
a301				endm 
# End of macro CWHEAD
a301			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a301			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a301			; | | Following the count are the individual words. 
a301			; | | 
a301			; | | e.g. UWORDS 
a301			; | | BOX DIRLIST 2 
a301			; | |  
a301			; | | Can be used to save the words to storage via: 
a301			; | | UWORDS $01 DO $01 APPEND LOOP 
a301				if DEBUG_FORTH_WORDS_KEY 
a301					DMARK "UWR" 
a301 f5				push af  
a302 3a 16 a3			ld a, (.dmark)  
a305 32 7a ee			ld (debug_mark),a  
a308 3a 17 a3			ld a, (.dmark+1)  
a30b 32 7b ee			ld (debug_mark+1),a  
a30e 3a 18 a3			ld a, (.dmark+2)  
a311 32 7c ee			ld (debug_mark+2),a  
a314 18 03			jr .pastdmark  
a316 ..			.dmark: db "UWR"  
a319 f1			.pastdmark: pop af  
a31a			endm  
# End of macro DMARK
a31a					CALLMONITOR 
a31a cd 75 92			call break_point_state  
a31d				endm  
# End of macro CALLMONITOR
a31d				endif 
a31d 21 8a d6				ld hl, baseram 
a320					;ld hl, baseusermem 
a320 01 00 00				ld bc, 0    ; start a counter 
a323			 
a323				; skip dict stub 
a323			 
a323 cd 51 9b				call forth_tok_next 
a326			 
a326			 
a326			; while we have words to look for 
a326			 
a326 7e			.douscan:	ld a, (hl)      
a327				if DEBUG_FORTH_WORDS 
a327					DMARK "UWs" 
a327 f5				push af  
a328 3a 3c a3			ld a, (.dmark)  
a32b 32 7a ee			ld (debug_mark),a  
a32e 3a 3d a3			ld a, (.dmark+1)  
a331 32 7b ee			ld (debug_mark+1),a  
a334 3a 3e a3			ld a, (.dmark+2)  
a337 32 7c ee			ld (debug_mark+2),a  
a33a 18 03			jr .pastdmark  
a33c ..			.dmark: db "UWs"  
a33f f1			.pastdmark: pop af  
a340			endm  
# End of macro DMARK
a340					CALLMONITOR 
a340 cd 75 92			call break_point_state  
a343				endm  
# End of macro CALLMONITOR
a343				endif 
a343 fe 00				cp WORD_SYS_END 
a345 28 4d				jr z, .udone 
a347 fe 01				cp WORD_SYS_UWORD 
a349 20 44				jr nz, .nuword 
a34b			 
a34b				if DEBUG_FORTH_WORDS 
a34b					DMARK "UWu" 
a34b f5				push af  
a34c 3a 60 a3			ld a, (.dmark)  
a34f 32 7a ee			ld (debug_mark),a  
a352 3a 61 a3			ld a, (.dmark+1)  
a355 32 7b ee			ld (debug_mark+1),a  
a358 3a 62 a3			ld a, (.dmark+2)  
a35b 32 7c ee			ld (debug_mark+2),a  
a35e 18 03			jr .pastdmark  
a360 ..			.dmark: db "UWu"  
a363 f1			.pastdmark: pop af  
a364			endm  
# End of macro DMARK
a364					CALLMONITOR 
a364 cd 75 92			call break_point_state  
a367				endm  
# End of macro CALLMONITOR
a367				endif 
a367					; we have a uword so push its name to the stack 
a367			 
a367 e5				   	push hl  ; save so we can move to next dict block 
a368			 
a368					; skip opcode 
a368 23					inc hl  
a369					; skip next ptr 
a369 23					inc hl  
a36a 23					inc hl 
a36b					; skip len 
a36b 23					inc hl 
a36c				if DEBUG_FORTH_WORDS 
a36c					DMARK "UWt" 
a36c f5				push af  
a36d 3a 81 a3			ld a, (.dmark)  
a370 32 7a ee			ld (debug_mark),a  
a373 3a 82 a3			ld a, (.dmark+1)  
a376 32 7b ee			ld (debug_mark+1),a  
a379 3a 83 a3			ld a, (.dmark+2)  
a37c 32 7c ee			ld (debug_mark+2),a  
a37f 18 03			jr .pastdmark  
a381 ..			.dmark: db "UWt"  
a384 f1			.pastdmark: pop af  
a385			endm  
# End of macro DMARK
a385					CALLMONITOR 
a385 cd 75 92			call break_point_state  
a388				endm  
# End of macro CALLMONITOR
a388				endif 
a388 03					inc bc 
a389			 
a389 c5					push bc 
a38a cd 21 98				call forth_push_str 
a38d c1					pop bc 
a38e			 
a38e e1					pop hl 	 
a38f			 
a38f cd 51 9b		.nuword:	call forth_tok_next 
a392 18 92				jr .douscan  
a394			 
a394			.udone:		 ; push count of uwords found 
a394 c5					push bc 
a395 e1					pop hl 
a396			 
a396				if DEBUG_FORTH_WORDS 
a396					DMARK "UWc" 
a396 f5				push af  
a397 3a ab a3			ld a, (.dmark)  
a39a 32 7a ee			ld (debug_mark),a  
a39d 3a ac a3			ld a, (.dmark+1)  
a3a0 32 7b ee			ld (debug_mark+1),a  
a3a3 3a ad a3			ld a, (.dmark+2)  
a3a6 32 7c ee			ld (debug_mark+2),a  
a3a9 18 03			jr .pastdmark  
a3ab ..			.dmark: db "UWc"  
a3ae f1			.pastdmark: pop af  
a3af			endm  
# End of macro DMARK
a3af					CALLMONITOR 
a3af cd 75 92			call break_point_state  
a3b2				endm  
# End of macro CALLMONITOR
a3b2				endif 
a3b2 cd 0f 98				call forth_push_numhl 
a3b5			 
a3b5			 
a3b5				       NEXTW 
a3b5 c3 00 9a			jp macro_next 
a3b8				endm 
# End of macro NEXTW
a3b8			 
a3b8			.BP: 
a3b8				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a3b8 54				db WORD_SYS_CORE+64             
a3b9 ee a3			dw .MONITOR            
a3bb 03				db 2 + 1 
a3bc .. 00			db "BP",0              
a3bf				endm 
# End of macro CWHEAD
a3bf			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a3bf			; | | $00 Will enable the break points within specific code paths 
a3bf			; | | $01 Will disable break points 
a3bf			; | |  
a3bf			; | | By default break points are off. Either the above can be used to enable them 
a3bf			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a3bf			; | | and on release of the pressed key a message will be disaplayed to notify 
a3bf			; | | that break points are enabled. Pressing any key will then continue boot process. 
a3bf					; get byte count 
a3bf					if DEBUG_FORTH_WORDS_KEY 
a3bf						DMARK "BP." 
a3bf f5				push af  
a3c0 3a d4 a3			ld a, (.dmark)  
a3c3 32 7a ee			ld (debug_mark),a  
a3c6 3a d5 a3			ld a, (.dmark+1)  
a3c9 32 7b ee			ld (debug_mark+1),a  
a3cc 3a d6 a3			ld a, (.dmark+2)  
a3cf 32 7c ee			ld (debug_mark+2),a  
a3d2 18 03			jr .pastdmark  
a3d4 ..			.dmark: db "BP."  
a3d7 f1			.pastdmark: pop af  
a3d8			endm  
# End of macro DMARK
a3d8						CALLMONITOR 
a3d8 cd 75 92			call break_point_state  
a3db				endm  
# End of macro CALLMONITOR
a3db					endif 
a3db			 
a3db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3db cd aa 98			call macro_dsp_valuehl 
a3de				endm 
# End of macro FORTH_DSP_VALUEHL
a3de			 
a3de			;		push hl 
a3de			 
a3de					; destroy value TOS 
a3de			 
a3de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3de cd 46 99			call macro_forth_dsp_pop 
a3e1				endm 
# End of macro FORTH_DSP_POP
a3e1			 
a3e1			;		pop hl 
a3e1			 
a3e1 3e 00				ld a,0 
a3e3 bd					cp l 
a3e4 28 02				jr z, .bpset 
a3e6 3e 2a				ld a, '*' 
a3e8			 
a3e8 32 74 e3		.bpset:		ld (os_view_disable), a 
a3eb			 
a3eb			 
a3eb					NEXTW 
a3eb c3 00 9a			jp macro_next 
a3ee				endm 
# End of macro NEXTW
a3ee			 
a3ee			 
a3ee			.MONITOR: 
a3ee				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a3ee 55				db WORD_SYS_CORE+65             
a3ef 21 a4			dw .MALLOC            
a3f1 08				db 7 + 1 
a3f2 .. 00			db "MONITOR",0              
a3fa				endm 
# End of macro CWHEAD
a3fa			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a3fa			; | | At start the current various registers will be displayed with contents. 
a3fa			; | | Top right corner will show the most recent debug marker seen. 
a3fa			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a3fa			; | | and the return stack pointer (RSP). 
a3fa			; | | Pressing: 
a3fa			; | |    1 - Initial screen 
a3fa			; | |    2 - Display a data dump of HL 
a3fa			; | |    3 - Display a data dump of DE 
a3fa			; | |    4 - Display a data dump of BC 
a3fa			; | |    5 - Display a data dump of HL 
a3fa			; | |    6 - Display a data dump of DSP 
a3fa			; | |    7 - Display a data dump of RSP 
a3fa			; | |    8 - Display a data dump of what is at DSP 
a3fa			; | |    9 - Display a data dump of what is at RSP 
a3fa			; | |    0 - Exit monitor and continue running. This will also enable break points 
a3fa			; | |    * - Disable break points 
a3fa			; | |    # - Enter traditional monitor mode 
a3fa			; | | 
a3fa			; | | Monitor Mode 
a3fa			; | | ------------ 
a3fa			; | | A prompt of '>' will be shown for various commands: 
a3fa			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a3fa			; | |    C - Continue display a data dump from the last set address 
a3fa			; | |    M xxxx - Set start of memory edit at address xx 
a3fa			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a3fa			; | |    Q - Return to previous 
a3fa					if DEBUG_FORTH_WORDS_KEY 
a3fa						DMARK "MON" 
a3fa f5				push af  
a3fb 3a 0f a4			ld a, (.dmark)  
a3fe 32 7a ee			ld (debug_mark),a  
a401 3a 10 a4			ld a, (.dmark+1)  
a404 32 7b ee			ld (debug_mark+1),a  
a407 3a 11 a4			ld a, (.dmark+2)  
a40a 32 7c ee			ld (debug_mark+2),a  
a40d 18 03			jr .pastdmark  
a40f ..			.dmark: db "MON"  
a412 f1			.pastdmark: pop af  
a413			endm  
# End of macro DMARK
a413						CALLMONITOR 
a413 cd 75 92			call break_point_state  
a416				endm  
# End of macro CALLMONITOR
a416					endif 
a416 3e 00				ld a, 0 
a418 32 74 e3				ld (os_view_disable), a 
a41b			 
a41b					CALLMONITOR 
a41b cd 75 92			call break_point_state  
a41e				endm  
# End of macro CALLMONITOR
a41e			 
a41e			;	call monitor 
a41e			 
a41e					NEXTW 
a41e c3 00 9a			jp macro_next 
a421				endm 
# End of macro NEXTW
a421			 
a421			 
a421			.MALLOC: 
a421				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a421 56				db WORD_SYS_CORE+66             
a422 4a a4			dw .MALLOC2            
a424 06				db 5 + 1 
a425 .. 00			db "ALLOT",0              
a42b				endm 
# End of macro CWHEAD
a42b			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a42b					if DEBUG_FORTH_WORDS_KEY 
a42b						DMARK "ALL" 
a42b f5				push af  
a42c 3a 40 a4			ld a, (.dmark)  
a42f 32 7a ee			ld (debug_mark),a  
a432 3a 41 a4			ld a, (.dmark+1)  
a435 32 7b ee			ld (debug_mark+1),a  
a438 3a 42 a4			ld a, (.dmark+2)  
a43b 32 7c ee			ld (debug_mark+2),a  
a43e 18 03			jr .pastdmark  
a440 ..			.dmark: db "ALL"  
a443 f1			.pastdmark: pop af  
a444			endm  
# End of macro DMARK
a444						CALLMONITOR 
a444 cd 75 92			call break_point_state  
a447				endm  
# End of macro CALLMONITOR
a447					endif 
a447 c3 71 a4				jp .mallocc 
a44a			.MALLOC2: 
a44a				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a44a 56				db WORD_SYS_CORE+66             
a44b 88 a4			dw .FREE            
a44d 07				db 6 + 1 
a44e .. 00			db "MALLOC",0              
a455				endm 
# End of macro CWHEAD
a455			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a455					; get byte count 
a455					if DEBUG_FORTH_WORDS_KEY 
a455						DMARK "MAL" 
a455 f5				push af  
a456 3a 6a a4			ld a, (.dmark)  
a459 32 7a ee			ld (debug_mark),a  
a45c 3a 6b a4			ld a, (.dmark+1)  
a45f 32 7b ee			ld (debug_mark+1),a  
a462 3a 6c a4			ld a, (.dmark+2)  
a465 32 7c ee			ld (debug_mark+2),a  
a468 18 03			jr .pastdmark  
a46a ..			.dmark: db "MAL"  
a46d f1			.pastdmark: pop af  
a46e			endm  
# End of macro DMARK
a46e						CALLMONITOR 
a46e cd 75 92			call break_point_state  
a471				endm  
# End of macro CALLMONITOR
a471					endif 
a471			.mallocc: 
a471					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a471 cd aa 98			call macro_dsp_valuehl 
a474				endm 
# End of macro FORTH_DSP_VALUEHL
a474			 
a474			;		push hl 
a474			 
a474					; destroy value TOS 
a474			 
a474					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a474 cd 46 99			call macro_forth_dsp_pop 
a477				endm 
# End of macro FORTH_DSP_POP
a477			 
a477			;		pop hl 
a477 cd 24 8f				call malloc 
a47a				if DEBUG_FORTH_MALLOC_GUARD 
a47a f5					push af 
a47b cd 86 8a				call ishlzero 
a47e			;		ld a, l 
a47e			;		add h 
a47e			;		cp 0 
a47e f1					pop af 
a47f					 
a47f cc 3f c3				call z,malloc_error 
a482				endif 
a482			 
a482 cd 0f 98				call forth_push_numhl 
a485					NEXTW 
a485 c3 00 9a			jp macro_next 
a488				endm 
# End of macro NEXTW
a488			 
a488			.FREE: 
a488				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a488 57				db WORD_SYS_CORE+67             
a489 b9 a4			dw .LIST            
a48b 05				db 4 + 1 
a48c .. 00			db "FREE",0              
a491				endm 
# End of macro CWHEAD
a491			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a491					if DEBUG_FORTH_WORDS_KEY 
a491						DMARK "FRE" 
a491 f5				push af  
a492 3a a6 a4			ld a, (.dmark)  
a495 32 7a ee			ld (debug_mark),a  
a498 3a a7 a4			ld a, (.dmark+1)  
a49b 32 7b ee			ld (debug_mark+1),a  
a49e 3a a8 a4			ld a, (.dmark+2)  
a4a1 32 7c ee			ld (debug_mark+2),a  
a4a4 18 03			jr .pastdmark  
a4a6 ..			.dmark: db "FRE"  
a4a9 f1			.pastdmark: pop af  
a4aa			endm  
# End of macro DMARK
a4aa						CALLMONITOR 
a4aa cd 75 92			call break_point_state  
a4ad				endm  
# End of macro CALLMONITOR
a4ad					endif 
a4ad					; get address 
a4ad			 
a4ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4ad cd aa 98			call macro_dsp_valuehl 
a4b0				endm 
# End of macro FORTH_DSP_VALUEHL
a4b0			 
a4b0			;		push hl 
a4b0			 
a4b0					; destroy value TOS 
a4b0			 
a4b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4b0 cd 46 99			call macro_forth_dsp_pop 
a4b3				endm 
# End of macro FORTH_DSP_POP
a4b3			 
a4b3			;		pop hl 
a4b3			if FORTH_ENABLE_MALLOCFREE 
a4b3 cd ee 8f				call free 
a4b6			endif 
a4b6					NEXTW 
a4b6 c3 00 9a			jp macro_next 
a4b9				endm 
# End of macro NEXTW
a4b9			.LIST: 
a4b9				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a4b9 5c				db WORD_SYS_CORE+72             
a4ba 7c a6			dw .FORGET            
a4bc 05				db 4 + 1 
a4bd .. 00			db "LIST",0              
a4c2				endm 
# End of macro CWHEAD
a4c2			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a4c2			; | | The quoted word must be in upper case. 
a4c2				if DEBUG_FORTH_WORDS_KEY 
a4c2					DMARK "LST" 
a4c2 f5				push af  
a4c3 3a d7 a4			ld a, (.dmark)  
a4c6 32 7a ee			ld (debug_mark),a  
a4c9 3a d8 a4			ld a, (.dmark+1)  
a4cc 32 7b ee			ld (debug_mark+1),a  
a4cf 3a d9 a4			ld a, (.dmark+2)  
a4d2 32 7c ee			ld (debug_mark+2),a  
a4d5 18 03			jr .pastdmark  
a4d7 ..			.dmark: db "LST"  
a4da f1			.pastdmark: pop af  
a4db			endm  
# End of macro DMARK
a4db					CALLMONITOR 
a4db cd 75 92			call break_point_state  
a4de				endm  
# End of macro CALLMONITOR
a4de				endif 
a4de			 
a4de					FORTH_DSP_VALUEHL 
a4de cd aa 98			call macro_dsp_valuehl 
a4e1				endm 
# End of macro FORTH_DSP_VALUEHL
a4e1			 
a4e1 e5					push hl 
a4e2 c1					pop bc 
a4e3			 
a4e3			; Start format of scratch string 
a4e3			 
a4e3 21 75 e3				ld hl, scratch 
a4e6			 
a4e6 3e 3a				ld a, ':' 
a4e8 77					ld (hl),a 
a4e9 23					inc hl 
a4ea 3e 20				ld a, ' ' 
a4ec 77					ld (hl), a 
a4ed			 
a4ed					; Get ptr to the word we need to look up 
a4ed			 
a4ed			;		FORTH_DSP_VALUEHL 
a4ed					;v5 FORTH_DSP_VALUE 
a4ed				; TODO type check 
a4ed			;		inc hl    ; Skip type check  
a4ed			;		push hl 
a4ed			;		ex de, hl    ; put into DE 
a4ed			 
a4ed			 
a4ed 21 8a d6				ld hl, baseram 
a4f0					;ld hl, baseusermem 
a4f0			 
a4f0 e5			push hl   ; sacreifical push 
a4f1			 
a4f1			.ldouscanm: 
a4f1 e1				pop hl 
a4f2			.ldouscan: 
a4f2				if DEBUG_FORTH_WORDS 
a4f2					DMARK "LSs" 
a4f2 f5				push af  
a4f3 3a 07 a5			ld a, (.dmark)  
a4f6 32 7a ee			ld (debug_mark),a  
a4f9 3a 08 a5			ld a, (.dmark+1)  
a4fc 32 7b ee			ld (debug_mark+1),a  
a4ff 3a 09 a5			ld a, (.dmark+2)  
a502 32 7c ee			ld (debug_mark+2),a  
a505 18 03			jr .pastdmark  
a507 ..			.dmark: db "LSs"  
a50a f1			.pastdmark: pop af  
a50b			endm  
# End of macro DMARK
a50b					CALLMONITOR 
a50b cd 75 92			call break_point_state  
a50e				endm  
# End of macro CALLMONITOR
a50e				endif 
a50e				; skip dict stub 
a50e cd 51 9b				call forth_tok_next 
a511			 
a511			 
a511			; while we have words to look for 
a511			 
a511 7e				ld a, (hl)      
a512				if DEBUG_FORTH_WORDS 
a512					DMARK "LSk" 
a512 f5				push af  
a513 3a 27 a5			ld a, (.dmark)  
a516 32 7a ee			ld (debug_mark),a  
a519 3a 28 a5			ld a, (.dmark+1)  
a51c 32 7b ee			ld (debug_mark+1),a  
a51f 3a 29 a5			ld a, (.dmark+2)  
a522 32 7c ee			ld (debug_mark+2),a  
a525 18 03			jr .pastdmark  
a527 ..			.dmark: db "LSk"  
a52a f1			.pastdmark: pop af  
a52b			endm  
# End of macro DMARK
a52b					CALLMONITOR 
a52b cd 75 92			call break_point_state  
a52e				endm  
# End of macro CALLMONITOR
a52e				endif 
a52e fe 00				cp WORD_SYS_END 
a530 ca 63 a6				jp z, .lunotfound 
a533 fe 01				cp WORD_SYS_UWORD 
a535 c2 f2 a4				jp nz, .ldouscan 
a538			 
a538				if DEBUG_FORTH_WORDS 
a538					DMARK "LSu" 
a538 f5				push af  
a539 3a 4d a5			ld a, (.dmark)  
a53c 32 7a ee			ld (debug_mark),a  
a53f 3a 4e a5			ld a, (.dmark+1)  
a542 32 7b ee			ld (debug_mark+1),a  
a545 3a 4f a5			ld a, (.dmark+2)  
a548 32 7c ee			ld (debug_mark+2),a  
a54b 18 03			jr .pastdmark  
a54d ..			.dmark: db "LSu"  
a550 f1			.pastdmark: pop af  
a551			endm  
# End of macro DMARK
a551					CALLMONITOR 
a551 cd 75 92			call break_point_state  
a554				endm  
# End of macro CALLMONITOR
a554				endif 
a554			 
a554					; found a uword but is it the one we want... 
a554			 
a554 c5					push bc     ; uword to find is on bc 
a555 d1					pop de 
a556			 
a556 e5					push hl  ; to save the ptr 
a557			 
a557					; skip opcode 
a557 23					inc hl  
a558					; skip next ptr 
a558 23					inc hl  
a559 23					inc hl 
a55a					; skip len 
a55a 23					inc hl 
a55b			 
a55b				if DEBUG_FORTH_WORDS 
a55b					DMARK "LSc" 
a55b f5				push af  
a55c 3a 70 a5			ld a, (.dmark)  
a55f 32 7a ee			ld (debug_mark),a  
a562 3a 71 a5			ld a, (.dmark+1)  
a565 32 7b ee			ld (debug_mark+1),a  
a568 3a 72 a5			ld a, (.dmark+2)  
a56b 32 7c ee			ld (debug_mark+2),a  
a56e 18 03			jr .pastdmark  
a570 ..			.dmark: db "LSc"  
a573 f1			.pastdmark: pop af  
a574			endm  
# End of macro DMARK
a574					CALLMONITOR 
a574 cd 75 92			call break_point_state  
a577				endm  
# End of macro CALLMONITOR
a577				endif 
a577 cd f3 8e				call strcmp 
a57a c2 f1 a4				jp nz, .ldouscanm 
a57d				 
a57d			 
a57d			 
a57d					; we have a uword so push its name to the stack 
a57d			 
a57d			;	   	push hl  ; save so we can move to next dict block 
a57d e1			pop hl 
a57e			 
a57e				if DEBUG_FORTH_WORDS 
a57e					DMARK "LSm" 
a57e f5				push af  
a57f 3a 93 a5			ld a, (.dmark)  
a582 32 7a ee			ld (debug_mark),a  
a585 3a 94 a5			ld a, (.dmark+1)  
a588 32 7b ee			ld (debug_mark+1),a  
a58b 3a 95 a5			ld a, (.dmark+2)  
a58e 32 7c ee			ld (debug_mark+2),a  
a591 18 03			jr .pastdmark  
a593 ..			.dmark: db "LSm"  
a596 f1			.pastdmark: pop af  
a597			endm  
# End of macro DMARK
a597					CALLMONITOR 
a597 cd 75 92			call break_point_state  
a59a				endm  
# End of macro CALLMONITOR
a59a				endif 
a59a			 
a59a					; skip opcode 
a59a 23					inc hl  
a59b					; skip next ptr 
a59b 23					inc hl  
a59c 23					inc hl 
a59d					; skip len 
a59d 7e					ld a, (hl)   ; save length to add 
a59e				if DEBUG_FORTH_WORDS 
a59e					DMARK "LS2" 
a59e f5				push af  
a59f 3a b3 a5			ld a, (.dmark)  
a5a2 32 7a ee			ld (debug_mark),a  
a5a5 3a b4 a5			ld a, (.dmark+1)  
a5a8 32 7b ee			ld (debug_mark+1),a  
a5ab 3a b5 a5			ld a, (.dmark+2)  
a5ae 32 7c ee			ld (debug_mark+2),a  
a5b1 18 03			jr .pastdmark  
a5b3 ..			.dmark: db "LS2"  
a5b6 f1			.pastdmark: pop af  
a5b7			endm  
# End of macro DMARK
a5b7					CALLMONITOR 
a5b7 cd 75 92			call break_point_state  
a5ba				endm  
# End of macro CALLMONITOR
a5ba				endif 
a5ba			 
a5ba					; save this location 
a5ba				 
a5ba e5					push hl 
a5bb			 
a5bb 23					inc hl 
a5bc 11 77 e3				ld de, scratch+2 
a5bf 4f					ld c, a 
a5c0 06 00				ld b, 0 
a5c2			 
a5c2				if DEBUG_FORTH_WORDS 
a5c2					DMARK "LSn" 
a5c2 f5				push af  
a5c3 3a d7 a5			ld a, (.dmark)  
a5c6 32 7a ee			ld (debug_mark),a  
a5c9 3a d8 a5			ld a, (.dmark+1)  
a5cc 32 7b ee			ld (debug_mark+1),a  
a5cf 3a d9 a5			ld a, (.dmark+2)  
a5d2 32 7c ee			ld (debug_mark+2),a  
a5d5 18 03			jr .pastdmark  
a5d7 ..			.dmark: db "LSn"  
a5da f1			.pastdmark: pop af  
a5db			endm  
# End of macro DMARK
a5db					CALLMONITOR 
a5db cd 75 92			call break_point_state  
a5de				endm  
# End of macro CALLMONITOR
a5de				endif 
a5de			 
a5de					; copy uword name to scratch 
a5de			 
a5de ed b0				ldir 
a5e0			 
a5e0 1b					dec de 
a5e1 3e 20				ld a, ' '    ; change null to space 
a5e3 12					ld (de), a 
a5e4			 
a5e4 13					inc de 
a5e5			 
a5e5 d5					push de 
a5e6 c1					pop bc     ; move scratch pointer to end of word name and save it 
a5e7			 
a5e7 e1					pop hl 
a5e8 7e					ld a, (hl) 
a5e9					;inc hl 
a5e9					; skip word string 
a5e9 cd 5d 8a				call addatohl 
a5ec			 
a5ec 23					inc hl 
a5ed			 
a5ed				if DEBUG_FORTH_WORDS 
a5ed					DMARK "LS3" 
a5ed f5				push af  
a5ee 3a 02 a6			ld a, (.dmark)  
a5f1 32 7a ee			ld (debug_mark),a  
a5f4 3a 03 a6			ld a, (.dmark+1)  
a5f7 32 7b ee			ld (debug_mark+1),a  
a5fa 3a 04 a6			ld a, (.dmark+2)  
a5fd 32 7c ee			ld (debug_mark+2),a  
a600 18 03			jr .pastdmark  
a602 ..			.dmark: db "LS3"  
a605 f1			.pastdmark: pop af  
a606			endm  
# End of macro DMARK
a606					CALLMONITOR 
a606 cd 75 92			call break_point_state  
a609				endm  
# End of macro CALLMONITOR
a609				endif 
a609					; should now be at the start of the machine code to setup the eval of the uword 
a609					; now locate the ptr to the string defintion 
a609			 
a609					; skip ld hl, 
a609					; then load the ptr 
a609			 
a609 23					inc hl 
a60a 5e					ld e, (hl) 
a60b 23					inc hl 
a60c 56					ld d, (hl) 
a60d eb					ex de, hl 
a60e			 
a60e			 
a60e				if DEBUG_FORTH_WORDS 
a60e					DMARK "LSt" 
a60e f5				push af  
a60f 3a 23 a6			ld a, (.dmark)  
a612 32 7a ee			ld (debug_mark),a  
a615 3a 24 a6			ld a, (.dmark+1)  
a618 32 7b ee			ld (debug_mark+1),a  
a61b 3a 25 a6			ld a, (.dmark+2)  
a61e 32 7c ee			ld (debug_mark+2),a  
a621 18 03			jr .pastdmark  
a623 ..			.dmark: db "LSt"  
a626 f1			.pastdmark: pop af  
a627			endm  
# End of macro DMARK
a627					CALLMONITOR 
a627 cd 75 92			call break_point_state  
a62a				endm  
# End of macro CALLMONITOR
a62a				endif 
a62a			 
a62a			; cant push right now due to tokenised strings  
a62a			 
a62a			; get the destination of where to copy this definition to. 
a62a			 
a62a c5					push bc 
a62b d1					pop de 
a62c			 
a62c 7e			.listl:         ld a,(hl) 
a62d fe 00				cp 0 
a62f 28 09				jr z, .lreplsp     ; replace zero with space 
a631 fe 7f				cp FORTH_END_BUFFER 
a633 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a635				 
a635					; just copy this char as is then 
a635			 
a635 12					ld (de), a 
a636			 
a636 23			.listnxt:	inc hl 
a637 13					inc de 
a638 18 f2				jr .listl 
a63a			 
a63a 3e 20		.lreplsp:	ld a,' ' 
a63c 12					ld (de), a 
a63d 18 f7				jr .listnxt 
a63f			 
a63f			; close up uword def 
a63f			 
a63f			.listdone: 
a63f 3e 00				ld a, 0 
a641 12					ld (de), a 
a642			 
a642			; now have def so clean up and push to stack 
a642			 
a642 21 75 e3				ld hl, scratch 
a645				if DEBUG_FORTH_WORDS 
a645					DMARK "Ltp" 
a645 f5				push af  
a646 3a 5a a6			ld a, (.dmark)  
a649 32 7a ee			ld (debug_mark),a  
a64c 3a 5b a6			ld a, (.dmark+1)  
a64f 32 7b ee			ld (debug_mark+1),a  
a652 3a 5c a6			ld a, (.dmark+2)  
a655 32 7c ee			ld (debug_mark+2),a  
a658 18 03			jr .pastdmark  
a65a ..			.dmark: db "Ltp"  
a65d f1			.pastdmark: pop af  
a65e			endm  
# End of macro DMARK
a65e					CALLMONITOR 
a65e cd 75 92			call break_point_state  
a661				endm  
# End of macro CALLMONITOR
a661				endif 
a661			 
a661 18 06			jr .listpush 
a663			 
a663			;.lnuword:	pop hl 
a663			;		call forth_tok_next 
a663			;		jp .ldouscan  
a663			 
a663			.lunotfound:		  
a663			 
a663			 
a663					 
a663					FORTH_DSP_POP 
a663 cd 46 99			call macro_forth_dsp_pop 
a666				endm 
# End of macro FORTH_DSP_POP
a666 21 6f a6				ld hl, .luno 
a669						 
a669			 
a669			.listpush: 
a669 cd 21 98				call forth_push_str 
a66c			 
a66c			 
a66c			 
a66c					NEXTW 
a66c c3 00 9a			jp macro_next 
a66f				endm 
# End of macro NEXTW
a66f			 
a66f .. 00		.luno:    db "Not found",0 
a679			 
a679			 
a679			 
a679			 
a679			 
a679			;		push hl   ; save pointer to start of uword def string 
a679			; 
a679			;; look for FORTH_EOL_LINE 
a679			;		ld a, FORTH_END_BUFFER 
a679			;		call strlent 
a679			; 
a679			;		inc hl		 ; space for coln def 
a679			;		inc hl 
a679			;		inc hl          ; space for terms 
a679			;		inc hl 
a679			; 
a679			;		ld a, 20   ; TODO get actual length 
a679			;		call addatohl    ; include a random amount of room for the uword name 
a679			; 
a679			;		 
a679			;	if DEBUG_FORTH_WORDS 
a679			;		DMARK "Lt1" 
a679			;		CALLMONITOR 
a679			;	endif 
a679			;		 
a679			; 
a679			;; malloc space for the string because we cant change it 
a679			; 
a679			;		call malloc 
a679			;	if DEBUG_FORTH_MALLOC_GUARD 
a679			;		push af 
a679			;		call ishlzero 
a679			;		pop af 
a679			;		 
a679			;		call z,malloc_error 
a679			;	endif 
a679			; 
a679			;	if DEBUG_FORTH_WORDS 
a679			;		DMARK "Lt2" 
a679			;		CALLMONITOR 
a679			;	endif 
a679			;		pop de 
a679			;		push hl    ; push the malloc to release later 
a679			;		push hl   ;  push back a copy for the later stack push 
a679			;		 
a679			;; copy the string swapping out the zero terms for spaces 
a679			; 
a679			;		; de has our source 
a679			;		; hl has our dest 
a679			; 
a679			;; add the coln def 
a679			; 
a679			;		ld a, ':' 
a679			;		ld (hl), a 
a679			;		inc hl 
a679			;		ld a, ' ' 
a679			;		ld (hl), a 
a679			;		inc hl 
a679			; 
a679			;; add the uname word 
a679			;		push de   ; save our string for now 
a679			;		ex de, hl 
a679			; 
a679			;		FORTH_DSP_VALUE 
a679			;		;v5 FORTH_DSP_VALUE 
a679			; 
a679			;		inc hl   ; skip type but we know by now this is OK 
a679			; 
a679			;.luword:	ld a,(hl) 
a679			;		cp 0 
a679			;		jr z, .luword2 
a679			;		ld (de), a 
a679			;		inc de 
a679			;		inc hl 
a679			;		jr .luword 
a679			; 
a679			;.luword2:	ld a, ' ' 
a679			;		ld (de), a 
a679			;;		inc hl 
a679			;;		inc de 
a679			;;		ld (de), a 
a679			;;		inc hl 
a679			;		inc de 
a679			; 
a679			;		ex de, hl 
a679			;		pop de 
a679			;		 
a679			;		 
a679			; 
a679			;; detoken that string and copy it 
a679			; 
a679			;	if DEBUG_FORTH_WORDS 
a679			;		DMARK "Lt2" 
a679			;		CALLMONITOR 
a679			;	endif 
a679			;.ldetok:	ld a, (de) 
a679			;		cp FORTH_END_BUFFER 
a679			;		jr z, .ldetokend 
a679			;		; swap out any zero term for space 
a679			;		cp 0 
a679			;		jr nz, .ldetoknext 
a679			;		ld a, ' ' 
a679			; 
a679			;	if DEBUG_FORTH_WORDS 
a679			;		DMARK "LtS" 
a679			;		CALLMONITOR 
a679			;	endif 
a679			;.ldetoknext:	ld (hl), a 
a679			;		inc de 
a679			;		inc hl 
a679			;		jr .ldetok 
a679			; 
a679			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a679			;		ld (hl), a  
a679			; 
a679			;; free that temp malloc 
a679			; 
a679			;		pop hl    
a679			; 
a679			;	if DEBUG_FORTH_WORDS 
a679			;		DMARK "Lt4" 
a679			;		CALLMONITOR 
a679			;	endif 
a679			;		call forth_apushstrhl 
a679			; 
a679			;		; get rid of temp malloc area 
a679			; 
a679			;		pop hl 
a679			;		call free 
a679			; 
a679			;		jr .ludone 
a679			; 
a679			;.lnuword:	pop hl 
a679			;		call forth_tok_next 
a679			;		jp .ldouscan  
a679			; 
a679			;.ludone:		 pop hl 
a679			; 
a679					NEXTW 
a679 c3 00 9a			jp macro_next 
a67c				endm 
# End of macro NEXTW
a67c			 
a67c			.FORGET: 
a67c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a67c 5d				db WORD_SYS_CORE+73             
a67d f5 a6			dw .NOP            
a67f 07				db 6 + 1 
a680 .. 00			db "FORGET",0              
a687				endm 
# End of macro CWHEAD
a687			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a687			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a687			; | |  
a687			; | | e.g. "MORE" forget 
a687					if DEBUG_FORTH_WORDS_KEY 
a687						DMARK "FRG" 
a687 f5				push af  
a688 3a 9c a6			ld a, (.dmark)  
a68b 32 7a ee			ld (debug_mark),a  
a68e 3a 9d a6			ld a, (.dmark+1)  
a691 32 7b ee			ld (debug_mark+1),a  
a694 3a 9e a6			ld a, (.dmark+2)  
a697 32 7c ee			ld (debug_mark+2),a  
a69a 18 03			jr .pastdmark  
a69c ..			.dmark: db "FRG"  
a69f f1			.pastdmark: pop af  
a6a0			endm  
# End of macro DMARK
a6a0						CALLMONITOR 
a6a0 cd 75 92			call break_point_state  
a6a3				endm  
# End of macro CALLMONITOR
a6a3					endif 
a6a3			 
a6a3				; find uword 
a6a3			        ; update start of word with "_" 
a6a3				; replace uword with deleted flag 
a6a3			 
a6a3			 
a6a3			;	if DEBUG_FORTH_WORDS 
a6a3			;		DMARK "FOG" 
a6a3			;		CALLMONITOR 
a6a3			;	endif 
a6a3			 
a6a3			 
a6a3					; Get ptr to the word we need to look up 
a6a3			 
a6a3					FORTH_DSP_VALUEHL 
a6a3 cd aa 98			call macro_dsp_valuehl 
a6a6				endm 
# End of macro FORTH_DSP_VALUEHL
a6a6					;v5 FORTH_DSP_VALUE 
a6a6				; TODO type check 
a6a6			;		inc hl    ; Skip type check  
a6a6 e5					push hl 
a6a7 c1					pop bc 
a6a8			;		ex de, hl    ; put into DE 
a6a8			 
a6a8			 
a6a8 21 8a d6				ld hl, baseram 
a6ab					;ld hl, baseusermem 
a6ab			 
a6ab				; skip dict stub 
a6ab			;	call forth_tok_next 
a6ab e5			push hl   ; sacreifical push 
a6ac			 
a6ac			.fldouscanm: 
a6ac e1				pop hl 
a6ad			.fldouscan: 
a6ad			;	if DEBUG_FORTH_WORDS 
a6ad			;		DMARK "LSs" 
a6ad			;		CALLMONITOR 
a6ad			;	endif 
a6ad				; skip dict stub 
a6ad cd 51 9b				call forth_tok_next 
a6b0			 
a6b0			 
a6b0			; while we have words to look for 
a6b0			 
a6b0 7e				ld a, (hl)      
a6b1			;	if DEBUG_FORTH_WORDS 
a6b1			;		DMARK "LSk" 
a6b1			;		CALLMONITOR 
a6b1			;	endif 
a6b1 fe 00				cp WORD_SYS_END 
a6b3 ca ef a6				jp z, .flunotfound 
a6b6 fe 01				cp WORD_SYS_UWORD 
a6b8 c2 ad a6				jp nz, .fldouscan 
a6bb			 
a6bb			;	if DEBUG_FORTH_WORDS 
a6bb			;		DMARK "LSu" 
a6bb			;		CALLMONITOR 
a6bb			;	endif 
a6bb			 
a6bb					; found a uword but is it the one we want... 
a6bb			 
a6bb c5					push bc     ; uword to find is on bc 
a6bc d1					pop de 
a6bd			 
a6bd e5					push hl  ; to save the ptr 
a6be			 
a6be					; skip opcode 
a6be 23					inc hl  
a6bf					; skip next ptr 
a6bf 23					inc hl  
a6c0 23					inc hl 
a6c1					; skip len 
a6c1 23					inc hl 
a6c2			 
a6c2			;	if DEBUG_FORTH_WORDS 
a6c2			;		DMARK "LSc" 
a6c2			;		CALLMONITOR 
a6c2			;	endif 
a6c2 cd f3 8e				call strcmp 
a6c5 c2 ac a6				jp nz, .fldouscanm 
a6c8			; 
a6c8			; 
a6c8			;; while we have words to look for 
a6c8			; 
a6c8			;.fdouscan:	ld a, (hl)      
a6c8			;	if DEBUG_FORTH_WORDS 
a6c8			;		DMARK "LSs" 
a6c8			;		CALLMONITOR 
a6c8			;	endif 
a6c8			;		cp WORD_SYS_END 
a6c8			;		jp z, .fudone 
a6c8			;		cp WORD_SYS_UWORD 
a6c8			;		jp nz, .fnuword 
a6c8			; 
a6c8			;	if DEBUG_FORTH_WORDS 
a6c8			;		DMARK "FGu" 
a6c8			;		CALLMONITOR 
a6c8			;	endif 
a6c8			; 
a6c8			;		; found a uword but is it the one we want... 
a6c8			; 
a6c8			; 
a6c8			;	        pop de   ; get back the dsp name 
a6c8			;		push de 
a6c8			; 
a6c8			;		push hl  ; to save the ptr 
a6c8			; 
a6c8			;		; skip opcode 
a6c8			;		inc hl  
a6c8			;		; skip next ptr 
a6c8			;		inc hl  
a6c8			;		inc hl 
a6c8			;		; skip len 
a6c8			;		inc hl 
a6c8			; 
a6c8			;	if DEBUG_FORTH_WORDS 
a6c8			;		DMARK "FGc" 
a6c8			;		CALLMONITOR 
a6c8			;	endif 
a6c8			;		call strcmp 
a6c8			;		jp nz, .fnuword 
a6c8			 
a6c8			 
a6c8 e1			pop hl 
a6c9			 
a6c9				 
a6c9				if DEBUG_FORTH_WORDS 
a6c9					DMARK "FGm" 
a6c9 f5				push af  
a6ca 3a de a6			ld a, (.dmark)  
a6cd 32 7a ee			ld (debug_mark),a  
a6d0 3a df a6			ld a, (.dmark+1)  
a6d3 32 7b ee			ld (debug_mark+1),a  
a6d6 3a e0 a6			ld a, (.dmark+2)  
a6d9 32 7c ee			ld (debug_mark+2),a  
a6dc 18 03			jr .pastdmark  
a6de ..			.dmark: db "FGm"  
a6e1 f1			.pastdmark: pop af  
a6e2			endm  
# End of macro DMARK
a6e2					CALLMONITOR 
a6e2 cd 75 92			call break_point_state  
a6e5				endm  
# End of macro CALLMONITOR
a6e5				endif 
a6e5			 
a6e5			 
a6e5			 
a6e5					; we have a uword so push its name to the stack 
a6e5			 
a6e5			;	   	push hl  ; save so we can move to next dict block 
a6e5			;pop hl 
a6e5			 
a6e5					; update opcode to deleted 
a6e5 3e 03				ld a, WORD_SYS_DELETED 
a6e7 77					ld (hl), a 
a6e8			 
a6e8 23					inc hl  
a6e9					; skip next ptr 
a6e9 23					inc hl  
a6ea 23					inc hl 
a6eb					; skip len 
a6eb 23					inc hl 
a6ec			 
a6ec					; TODO change parser to skip deleted words but for now mark it out 
a6ec 3e 5f				ld a, "_" 
a6ee 77					ld  (hl),a 
a6ef			 
a6ef			;		jr .fudone 
a6ef			; 
a6ef			;.fnuword:	pop hl 
a6ef			;		call forth_tok_next 
a6ef			;		jp .fdouscan  
a6ef			 
a6ef			.flunotfound:		  
a6ef			 
a6ef			 
a6ef					 
a6ef					FORTH_DSP_POP 
a6ef cd 46 99			call macro_forth_dsp_pop 
a6f2				endm 
# End of macro FORTH_DSP_POP
a6f2			;		ld hl, .luno 
a6f2			;.fudone:		 pop hl 
a6f2					NEXTW 
a6f2 c3 00 9a			jp macro_next 
a6f5				endm 
# End of macro NEXTW
a6f5			.NOP: 
a6f5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a6f5 61				db WORD_SYS_CORE+77             
a6f6 1c a7			dw .COMO            
a6f8 04				db 3 + 1 
a6f9 .. 00			db "NOP",0              
a6fd				endm 
# End of macro CWHEAD
a6fd			; | NOP (  --  ) Do nothing | DONE 
a6fd					if DEBUG_FORTH_WORDS_KEY 
a6fd						DMARK "NOP" 
a6fd f5				push af  
a6fe 3a 12 a7			ld a, (.dmark)  
a701 32 7a ee			ld (debug_mark),a  
a704 3a 13 a7			ld a, (.dmark+1)  
a707 32 7b ee			ld (debug_mark+1),a  
a70a 3a 14 a7			ld a, (.dmark+2)  
a70d 32 7c ee			ld (debug_mark+2),a  
a710 18 03			jr .pastdmark  
a712 ..			.dmark: db "NOP"  
a715 f1			.pastdmark: pop af  
a716			endm  
# End of macro DMARK
a716						CALLMONITOR 
a716 cd 75 92			call break_point_state  
a719				endm  
# End of macro CALLMONITOR
a719					endif 
a719				       NEXTW 
a719 c3 00 9a			jp macro_next 
a71c				endm 
# End of macro NEXTW
a71c			.COMO: 
a71c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a71c 6e				db WORD_SYS_CORE+90             
a71d 6e a7			dw .COMC            
a71f 02				db 1 + 1 
a720 .. 00			db "(",0              
a722				endm 
# End of macro CWHEAD
a722			; | ( ( -- )  Start of comment | DONE 
a722			 
a722			 
a722 2a 76 e6				ld hl, ( os_tok_ptr) 
a725 11 69 a7			ld de, .closepar 
a728					 
a728					if DEBUG_FORTH_WORDS 
a728						DMARK ").." 
a728 f5				push af  
a729 3a 3d a7			ld a, (.dmark)  
a72c 32 7a ee			ld (debug_mark),a  
a72f 3a 3e a7			ld a, (.dmark+1)  
a732 32 7b ee			ld (debug_mark+1),a  
a735 3a 3f a7			ld a, (.dmark+2)  
a738 32 7c ee			ld (debug_mark+2),a  
a73b 18 03			jr .pastdmark  
a73d ..			.dmark: db ").."  
a740 f1			.pastdmark: pop af  
a741			endm  
# End of macro DMARK
a741						CALLMONITOR 
a741 cd 75 92			call break_point_state  
a744				endm  
# End of macro CALLMONITOR
a744					endif 
a744 cd 1b 9b			call findnexttok  
a747			 
a747					if DEBUG_FORTH_WORDS 
a747						DMARK "IF5" 
a747 f5				push af  
a748 3a 5c a7			ld a, (.dmark)  
a74b 32 7a ee			ld (debug_mark),a  
a74e 3a 5d a7			ld a, (.dmark+1)  
a751 32 7b ee			ld (debug_mark+1),a  
a754 3a 5e a7			ld a, (.dmark+2)  
a757 32 7c ee			ld (debug_mark+2),a  
a75a 18 03			jr .pastdmark  
a75c ..			.dmark: db "IF5"  
a75f f1			.pastdmark: pop af  
a760			endm  
# End of macro DMARK
a760						CALLMONITOR 
a760 cd 75 92			call break_point_state  
a763				endm  
# End of macro CALLMONITOR
a763					endif 
a763				; replace below with ) exec using tok_ptr 
a763 22 76 e6			ld (os_tok_ptr), hl 
a766 c3 91 9a			jp exec1 
a769			 
a769 .. 00			.closepar:   db ")",0 
a76b			 
a76b				       NEXTW 
a76b c3 00 9a			jp macro_next 
a76e				endm 
# End of macro NEXTW
a76e			.COMC: 
a76e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a76e 6f				db WORD_SYS_CORE+91             
a76f 77 a7			dw .SCRATCH            
a771 02				db 1 + 1 
a772 .. 00			db ")",0              
a774				endm 
# End of macro CWHEAD
a774			; | ) ( -- )  End of comment |  DONE  
a774				       NEXTW 
a774 c3 00 9a			jp macro_next 
a777				endm 
# End of macro NEXTW
a777			 
a777			.SCRATCH: 
a777				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a777 6f				db WORD_SYS_CORE+91             
a778 b2 a7			dw .INC            
a77a 08				db 7 + 1 
a77b .. 00			db "SCRATCH",0              
a783				endm 
# End of macro CWHEAD
a783			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a783			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a783			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a783			; | |  
a783			; | | e.g.    : score $00 scratch ; 
a783			; | |  
a783			; | | $00 score ! 
a783			; | | $01 score +! 
a783			; | |  
a783			; | | e.g.   : varword $0a scratch ;  
a783			; | | 
a783			; | | $8000 varword ! 
a783					if DEBUG_FORTH_WORDS_KEY 
a783						DMARK "SCR" 
a783 f5				push af  
a784 3a 98 a7			ld a, (.dmark)  
a787 32 7a ee			ld (debug_mark),a  
a78a 3a 99 a7			ld a, (.dmark+1)  
a78d 32 7b ee			ld (debug_mark+1),a  
a790 3a 9a a7			ld a, (.dmark+2)  
a793 32 7c ee			ld (debug_mark+2),a  
a796 18 03			jr .pastdmark  
a798 ..			.dmark: db "SCR"  
a79b f1			.pastdmark: pop af  
a79c			endm  
# End of macro DMARK
a79c						CALLMONITOR 
a79c cd 75 92			call break_point_state  
a79f				endm  
# End of macro CALLMONITOR
a79f					endif 
a79f			 
a79f					FORTH_DSP_VALUEHL 
a79f cd aa 98			call macro_dsp_valuehl 
a7a2				endm 
# End of macro FORTH_DSP_VALUEHL
a7a2				 
a7a2					FORTH_DSP_POP 
a7a2 cd 46 99			call macro_forth_dsp_pop 
a7a5				endm 
# End of macro FORTH_DSP_POP
a7a5			 
a7a5 7d					ld a, l 
a7a6 21 9a e8				ld hl, os_var_array 
a7a9 cd 5d 8a				call addatohl 
a7ac			 
a7ac cd 0f 98				call forth_push_numhl 
a7af			 
a7af				       NEXTW 
a7af c3 00 9a			jp macro_next 
a7b2				endm 
# End of macro NEXTW
a7b2			 
a7b2			.INC: 
a7b2				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a7b2 6f				db WORD_SYS_CORE+91             
a7b3 06 a8			dw .DEC            
a7b5 03				db 2 + 1 
a7b6 .. 00			db "+!",0              
a7b9				endm 
# End of macro CWHEAD
a7b9			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a7b9					if DEBUG_FORTH_WORDS_KEY 
a7b9						DMARK "+s_" 
a7b9 f5				push af  
a7ba 3a ce a7			ld a, (.dmark)  
a7bd 32 7a ee			ld (debug_mark),a  
a7c0 3a cf a7			ld a, (.dmark+1)  
a7c3 32 7b ee			ld (debug_mark+1),a  
a7c6 3a d0 a7			ld a, (.dmark+2)  
a7c9 32 7c ee			ld (debug_mark+2),a  
a7cc 18 03			jr .pastdmark  
a7ce ..			.dmark: db "+s_"  
a7d1 f1			.pastdmark: pop af  
a7d2			endm  
# End of macro DMARK
a7d2						CALLMONITOR 
a7d2 cd 75 92			call break_point_state  
a7d5				endm  
# End of macro CALLMONITOR
a7d5					endif 
a7d5			 
a7d5					FORTH_DSP_VALUEHL 
a7d5 cd aa 98			call macro_dsp_valuehl 
a7d8				endm 
# End of macro FORTH_DSP_VALUEHL
a7d8			 
a7d8 e5					push hl   ; save address 
a7d9			 
a7d9					FORTH_DSP_POP 
a7d9 cd 46 99			call macro_forth_dsp_pop 
a7dc				endm 
# End of macro FORTH_DSP_POP
a7dc			 
a7dc					FORTH_DSP_VALUEHL 
a7dc cd aa 98			call macro_dsp_valuehl 
a7df				endm 
# End of macro FORTH_DSP_VALUEHL
a7df			 
a7df					FORTH_DSP_POP 
a7df cd 46 99			call macro_forth_dsp_pop 
a7e2				endm 
# End of macro FORTH_DSP_POP
a7e2			 
a7e2					; hl contains value to add to byte at a 
a7e2				 
a7e2 eb					ex de, hl 
a7e3			 
a7e3 e1					pop hl 
a7e4			 
a7e4					if DEBUG_FORTH_WORDS 
a7e4						DMARK "INC" 
a7e4 f5				push af  
a7e5 3a f9 a7			ld a, (.dmark)  
a7e8 32 7a ee			ld (debug_mark),a  
a7eb 3a fa a7			ld a, (.dmark+1)  
a7ee 32 7b ee			ld (debug_mark+1),a  
a7f1 3a fb a7			ld a, (.dmark+2)  
a7f4 32 7c ee			ld (debug_mark+2),a  
a7f7 18 03			jr .pastdmark  
a7f9 ..			.dmark: db "INC"  
a7fc f1			.pastdmark: pop af  
a7fd			endm  
# End of macro DMARK
a7fd						CALLMONITOR 
a7fd cd 75 92			call break_point_state  
a800				endm  
# End of macro CALLMONITOR
a800					endif 
a800			 
a800 7e					ld a,(hl) 
a801 83					add e 
a802 77					ld (hl),a 
a803			 
a803			 
a803			 
a803				       NEXTW 
a803 c3 00 9a			jp macro_next 
a806				endm 
# End of macro NEXTW
a806			 
a806			.DEC: 
a806				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a806 6f				db WORD_SYS_CORE+91             
a807 57 a8			dw .INC2            
a809 03				db 2 + 1 
a80a .. 00			db "-!",0              
a80d				endm 
# End of macro CWHEAD
a80d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a80d					if DEBUG_FORTH_WORDS_KEY 
a80d						DMARK "-s_" 
a80d f5				push af  
a80e 3a 22 a8			ld a, (.dmark)  
a811 32 7a ee			ld (debug_mark),a  
a814 3a 23 a8			ld a, (.dmark+1)  
a817 32 7b ee			ld (debug_mark+1),a  
a81a 3a 24 a8			ld a, (.dmark+2)  
a81d 32 7c ee			ld (debug_mark+2),a  
a820 18 03			jr .pastdmark  
a822 ..			.dmark: db "-s_"  
a825 f1			.pastdmark: pop af  
a826			endm  
# End of macro DMARK
a826						CALLMONITOR 
a826 cd 75 92			call break_point_state  
a829				endm  
# End of macro CALLMONITOR
a829					endif 
a829			 
a829					FORTH_DSP_VALUEHL 
a829 cd aa 98			call macro_dsp_valuehl 
a82c				endm 
# End of macro FORTH_DSP_VALUEHL
a82c			 
a82c e5					push hl   ; save address 
a82d			 
a82d					FORTH_DSP_POP 
a82d cd 46 99			call macro_forth_dsp_pop 
a830				endm 
# End of macro FORTH_DSP_POP
a830			 
a830					FORTH_DSP_VALUEHL 
a830 cd aa 98			call macro_dsp_valuehl 
a833				endm 
# End of macro FORTH_DSP_VALUEHL
a833			 
a833					; hl contains value to add to byte at a 
a833				 
a833 eb					ex de, hl 
a834			 
a834 e1					pop hl 
a835			 
a835					if DEBUG_FORTH_WORDS 
a835						DMARK "DEC" 
a835 f5				push af  
a836 3a 4a a8			ld a, (.dmark)  
a839 32 7a ee			ld (debug_mark),a  
a83c 3a 4b a8			ld a, (.dmark+1)  
a83f 32 7b ee			ld (debug_mark+1),a  
a842 3a 4c a8			ld a, (.dmark+2)  
a845 32 7c ee			ld (debug_mark+2),a  
a848 18 03			jr .pastdmark  
a84a ..			.dmark: db "DEC"  
a84d f1			.pastdmark: pop af  
a84e			endm  
# End of macro DMARK
a84e						CALLMONITOR 
a84e cd 75 92			call break_point_state  
a851				endm  
# End of macro CALLMONITOR
a851					endif 
a851			 
a851 7e					ld a,(hl) 
a852 93					sub e 
a853 77					ld (hl),a 
a854			 
a854			 
a854			 
a854				       NEXTW 
a854 c3 00 9a			jp macro_next 
a857				endm 
# End of macro NEXTW
a857			 
a857			.INC2: 
a857				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a857 6f				db WORD_SYS_CORE+91             
a858 01 a9			dw .DEC2            
a85a 04				db 3 + 1 
a85b .. 00			db "+2!",0              
a85f				endm 
# End of macro CWHEAD
a85f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a85f			 
a85f					if DEBUG_FORTH_WORDS_KEY 
a85f						DMARK "+2s" 
a85f f5				push af  
a860 3a 74 a8			ld a, (.dmark)  
a863 32 7a ee			ld (debug_mark),a  
a866 3a 75 a8			ld a, (.dmark+1)  
a869 32 7b ee			ld (debug_mark+1),a  
a86c 3a 76 a8			ld a, (.dmark+2)  
a86f 32 7c ee			ld (debug_mark+2),a  
a872 18 03			jr .pastdmark  
a874 ..			.dmark: db "+2s"  
a877 f1			.pastdmark: pop af  
a878			endm  
# End of macro DMARK
a878						CALLMONITOR 
a878 cd 75 92			call break_point_state  
a87b				endm  
# End of macro CALLMONITOR
a87b					endif 
a87b			 
a87b					; Address 
a87b			 
a87b					FORTH_DSP_VALUEHL 
a87b cd aa 98			call macro_dsp_valuehl 
a87e				endm 
# End of macro FORTH_DSP_VALUEHL
a87e			 
a87e e5					push hl    ; save address 
a87f			 
a87f					; load content into de 
a87f			 
a87f 5e					ld e,(hl) 
a880 23					inc hl 
a881 56					ld d, (hl) 
a882			 
a882					if DEBUG_FORTH_WORDS 
a882						DMARK "+2a" 
a882 f5				push af  
a883 3a 97 a8			ld a, (.dmark)  
a886 32 7a ee			ld (debug_mark),a  
a889 3a 98 a8			ld a, (.dmark+1)  
a88c 32 7b ee			ld (debug_mark+1),a  
a88f 3a 99 a8			ld a, (.dmark+2)  
a892 32 7c ee			ld (debug_mark+2),a  
a895 18 03			jr .pastdmark  
a897 ..			.dmark: db "+2a"  
a89a f1			.pastdmark: pop af  
a89b			endm  
# End of macro DMARK
a89b						CALLMONITOR 
a89b cd 75 92			call break_point_state  
a89e				endm  
# End of macro CALLMONITOR
a89e					endif 
a89e			 
a89e					FORTH_DSP_POP 
a89e cd 46 99			call macro_forth_dsp_pop 
a8a1				endm 
# End of macro FORTH_DSP_POP
a8a1			 
a8a1					; Get value to add 
a8a1			 
a8a1					FORTH_DSP_VALUE 
a8a1 cd 93 98			call macro_forth_dsp_value 
a8a4				endm 
# End of macro FORTH_DSP_VALUE
a8a4			 
a8a4					if DEBUG_FORTH_WORDS 
a8a4						DMARK "+2v" 
a8a4 f5				push af  
a8a5 3a b9 a8			ld a, (.dmark)  
a8a8 32 7a ee			ld (debug_mark),a  
a8ab 3a ba a8			ld a, (.dmark+1)  
a8ae 32 7b ee			ld (debug_mark+1),a  
a8b1 3a bb a8			ld a, (.dmark+2)  
a8b4 32 7c ee			ld (debug_mark+2),a  
a8b7 18 03			jr .pastdmark  
a8b9 ..			.dmark: db "+2v"  
a8bc f1			.pastdmark: pop af  
a8bd			endm  
# End of macro DMARK
a8bd						CALLMONITOR 
a8bd cd 75 92			call break_point_state  
a8c0				endm  
# End of macro CALLMONITOR
a8c0					endif 
a8c0			 
a8c0 19					add hl, de 
a8c1			 
a8c1					if DEBUG_FORTH_WORDS 
a8c1						DMARK "+2+" 
a8c1 f5				push af  
a8c2 3a d6 a8			ld a, (.dmark)  
a8c5 32 7a ee			ld (debug_mark),a  
a8c8 3a d7 a8			ld a, (.dmark+1)  
a8cb 32 7b ee			ld (debug_mark+1),a  
a8ce 3a d8 a8			ld a, (.dmark+2)  
a8d1 32 7c ee			ld (debug_mark+2),a  
a8d4 18 03			jr .pastdmark  
a8d6 ..			.dmark: db "+2+"  
a8d9 f1			.pastdmark: pop af  
a8da			endm  
# End of macro DMARK
a8da						CALLMONITOR 
a8da cd 75 92			call break_point_state  
a8dd				endm  
# End of macro CALLMONITOR
a8dd					endif 
a8dd			 
a8dd					; move result to de 
a8dd			 
a8dd eb					ex de, hl 
a8de			 
a8de					; Address 
a8de			 
a8de e1					pop hl 
a8df			 
a8df					; save it back 
a8df			 
a8df 73					ld (hl), e 
a8e0 23					inc hl 
a8e1 72					ld (hl), d 
a8e2			 
a8e2					if DEBUG_FORTH_WORDS 
a8e2						DMARK "+2e" 
a8e2 f5				push af  
a8e3 3a f7 a8			ld a, (.dmark)  
a8e6 32 7a ee			ld (debug_mark),a  
a8e9 3a f8 a8			ld a, (.dmark+1)  
a8ec 32 7b ee			ld (debug_mark+1),a  
a8ef 3a f9 a8			ld a, (.dmark+2)  
a8f2 32 7c ee			ld (debug_mark+2),a  
a8f5 18 03			jr .pastdmark  
a8f7 ..			.dmark: db "+2e"  
a8fa f1			.pastdmark: pop af  
a8fb			endm  
# End of macro DMARK
a8fb						CALLMONITOR 
a8fb cd 75 92			call break_point_state  
a8fe				endm  
# End of macro CALLMONITOR
a8fe					endif 
a8fe			 
a8fe			 
a8fe			 
a8fe			 
a8fe			 
a8fe				       NEXTW 
a8fe c3 00 9a			jp macro_next 
a901				endm 
# End of macro NEXTW
a901			 
a901			.DEC2: 
a901				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a901 6f				db WORD_SYS_CORE+91             
a902 ad a9			dw .GET2            
a904 04				db 3 + 1 
a905 .. 00			db "-2!",0              
a909				endm 
# End of macro CWHEAD
a909			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a909			 
a909			 
a909					if DEBUG_FORTH_WORDS_KEY 
a909						DMARK "-2s" 
a909 f5				push af  
a90a 3a 1e a9			ld a, (.dmark)  
a90d 32 7a ee			ld (debug_mark),a  
a910 3a 1f a9			ld a, (.dmark+1)  
a913 32 7b ee			ld (debug_mark+1),a  
a916 3a 20 a9			ld a, (.dmark+2)  
a919 32 7c ee			ld (debug_mark+2),a  
a91c 18 03			jr .pastdmark  
a91e ..			.dmark: db "-2s"  
a921 f1			.pastdmark: pop af  
a922			endm  
# End of macro DMARK
a922						CALLMONITOR 
a922 cd 75 92			call break_point_state  
a925				endm  
# End of macro CALLMONITOR
a925					endif 
a925			 
a925					; Address 
a925			 
a925					FORTH_DSP_VALUEHL 
a925 cd aa 98			call macro_dsp_valuehl 
a928				endm 
# End of macro FORTH_DSP_VALUEHL
a928			 
a928 e5					push hl    ; save address 
a929			 
a929					; load content into de 
a929			 
a929 5e					ld e,(hl) 
a92a 23					inc hl 
a92b 56					ld d, (hl) 
a92c			 
a92c					if DEBUG_FORTH_WORDS 
a92c						DMARK "-2a" 
a92c f5				push af  
a92d 3a 41 a9			ld a, (.dmark)  
a930 32 7a ee			ld (debug_mark),a  
a933 3a 42 a9			ld a, (.dmark+1)  
a936 32 7b ee			ld (debug_mark+1),a  
a939 3a 43 a9			ld a, (.dmark+2)  
a93c 32 7c ee			ld (debug_mark+2),a  
a93f 18 03			jr .pastdmark  
a941 ..			.dmark: db "-2a"  
a944 f1			.pastdmark: pop af  
a945			endm  
# End of macro DMARK
a945						CALLMONITOR 
a945 cd 75 92			call break_point_state  
a948				endm  
# End of macro CALLMONITOR
a948					endif 
a948			 
a948					FORTH_DSP_POP 
a948 cd 46 99			call macro_forth_dsp_pop 
a94b				endm 
# End of macro FORTH_DSP_POP
a94b			 
a94b					; Get value to remove 
a94b			 
a94b					FORTH_DSP_VALUE 
a94b cd 93 98			call macro_forth_dsp_value 
a94e				endm 
# End of macro FORTH_DSP_VALUE
a94e			 
a94e					if DEBUG_FORTH_WORDS 
a94e						DMARK "-2v" 
a94e f5				push af  
a94f 3a 63 a9			ld a, (.dmark)  
a952 32 7a ee			ld (debug_mark),a  
a955 3a 64 a9			ld a, (.dmark+1)  
a958 32 7b ee			ld (debug_mark+1),a  
a95b 3a 65 a9			ld a, (.dmark+2)  
a95e 32 7c ee			ld (debug_mark+2),a  
a961 18 03			jr .pastdmark  
a963 ..			.dmark: db "-2v"  
a966 f1			.pastdmark: pop af  
a967			endm  
# End of macro DMARK
a967						CALLMONITOR 
a967 cd 75 92			call break_point_state  
a96a				endm  
# End of macro CALLMONITOR
a96a					endif 
a96a			 
a96a eb					ex de, hl 
a96b ed 52				sbc hl, de 
a96d			 
a96d					if DEBUG_FORTH_WORDS 
a96d						DMARK "-2d" 
a96d f5				push af  
a96e 3a 82 a9			ld a, (.dmark)  
a971 32 7a ee			ld (debug_mark),a  
a974 3a 83 a9			ld a, (.dmark+1)  
a977 32 7b ee			ld (debug_mark+1),a  
a97a 3a 84 a9			ld a, (.dmark+2)  
a97d 32 7c ee			ld (debug_mark+2),a  
a980 18 03			jr .pastdmark  
a982 ..			.dmark: db "-2d"  
a985 f1			.pastdmark: pop af  
a986			endm  
# End of macro DMARK
a986						CALLMONITOR 
a986 cd 75 92			call break_point_state  
a989				endm  
# End of macro CALLMONITOR
a989					endif 
a989			 
a989					; move result to de 
a989			 
a989 eb					ex de, hl 
a98a			 
a98a					; Address 
a98a			 
a98a e1					pop hl 
a98b			 
a98b					; save it back 
a98b			 
a98b 73					ld (hl), e 
a98c 23					inc hl 
a98d 72					ld (hl), d 
a98e			 
a98e					if DEBUG_FORTH_WORDS 
a98e						DMARK "-2e" 
a98e f5				push af  
a98f 3a a3 a9			ld a, (.dmark)  
a992 32 7a ee			ld (debug_mark),a  
a995 3a a4 a9			ld a, (.dmark+1)  
a998 32 7b ee			ld (debug_mark+1),a  
a99b 3a a5 a9			ld a, (.dmark+2)  
a99e 32 7c ee			ld (debug_mark+2),a  
a9a1 18 03			jr .pastdmark  
a9a3 ..			.dmark: db "-2e"  
a9a6 f1			.pastdmark: pop af  
a9a7			endm  
# End of macro DMARK
a9a7						CALLMONITOR 
a9a7 cd 75 92			call break_point_state  
a9aa				endm  
# End of macro CALLMONITOR
a9aa					endif 
a9aa			 
a9aa			 
a9aa			 
a9aa			 
a9aa			 
a9aa				       NEXTW 
a9aa c3 00 9a			jp macro_next 
a9ad				endm 
# End of macro NEXTW
a9ad			.GET2: 
a9ad				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
a9ad 6f				db WORD_SYS_CORE+91             
a9ae dd a9			dw .BANG2            
a9b0 03				db 2 + 1 
a9b1 .. 00			db "2@",0              
a9b4				endm 
# End of macro CWHEAD
a9b4			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
a9b4					if DEBUG_FORTH_WORDS_KEY 
a9b4						DMARK "2A_" 
a9b4 f5				push af  
a9b5 3a c9 a9			ld a, (.dmark)  
a9b8 32 7a ee			ld (debug_mark),a  
a9bb 3a ca a9			ld a, (.dmark+1)  
a9be 32 7b ee			ld (debug_mark+1),a  
a9c1 3a cb a9			ld a, (.dmark+2)  
a9c4 32 7c ee			ld (debug_mark+2),a  
a9c7 18 03			jr .pastdmark  
a9c9 ..			.dmark: db "2A_"  
a9cc f1			.pastdmark: pop af  
a9cd			endm  
# End of macro DMARK
a9cd						CALLMONITOR 
a9cd cd 75 92			call break_point_state  
a9d0				endm  
# End of macro CALLMONITOR
a9d0					endif 
a9d0			 
a9d0					FORTH_DSP_VALUEHL 
a9d0 cd aa 98			call macro_dsp_valuehl 
a9d3				endm 
# End of macro FORTH_DSP_VALUEHL
a9d3			 
a9d3 5e					ld e, (hl) 
a9d4 23					inc hl 
a9d5 56					ld d, (hl) 
a9d6			 
a9d6 eb					ex de, hl 
a9d7			 
a9d7 cd 0f 98				call forth_push_numhl 
a9da			 
a9da				       NEXTW 
a9da c3 00 9a			jp macro_next 
a9dd				endm 
# End of macro NEXTW
a9dd			.BANG2: 
a9dd				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
a9dd 6f				db WORD_SYS_CORE+91             
a9de 15 aa			dw .CONFIG            
a9e0 03				db 2 + 1 
a9e1 .. 00			db "2!",0              
a9e4				endm 
# End of macro CWHEAD
a9e4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
a9e4					if DEBUG_FORTH_WORDS_KEY 
a9e4						DMARK "2S_" 
a9e4 f5				push af  
a9e5 3a f9 a9			ld a, (.dmark)  
a9e8 32 7a ee			ld (debug_mark),a  
a9eb 3a fa a9			ld a, (.dmark+1)  
a9ee 32 7b ee			ld (debug_mark+1),a  
a9f1 3a fb a9			ld a, (.dmark+2)  
a9f4 32 7c ee			ld (debug_mark+2),a  
a9f7 18 03			jr .pastdmark  
a9f9 ..			.dmark: db "2S_"  
a9fc f1			.pastdmark: pop af  
a9fd			endm  
# End of macro DMARK
a9fd						CALLMONITOR 
a9fd cd 75 92			call break_point_state  
aa00				endm  
# End of macro CALLMONITOR
aa00					endif 
aa00			 
aa00					FORTH_DSP_VALUEHL 
aa00 cd aa 98			call macro_dsp_valuehl 
aa03				endm 
# End of macro FORTH_DSP_VALUEHL
aa03			 
aa03 e5					push hl   ; save address 
aa04			 
aa04			 
aa04					FORTH_DSP_POP 
aa04 cd 46 99			call macro_forth_dsp_pop 
aa07				endm 
# End of macro FORTH_DSP_POP
aa07			 
aa07					 
aa07					FORTH_DSP_VALUEHL 
aa07 cd aa 98			call macro_dsp_valuehl 
aa0a				endm 
# End of macro FORTH_DSP_VALUEHL
aa0a			 
aa0a					FORTH_DSP_POP 
aa0a cd 46 99			call macro_forth_dsp_pop 
aa0d				endm 
# End of macro FORTH_DSP_POP
aa0d			 
aa0d eb					ex de, hl    ; value now in de 
aa0e			 
aa0e e1					pop hl 
aa0f			 
aa0f 73					ld (hl), e 
aa10			 
aa10 23					inc hl 
aa11			 
aa11 72					ld (hl), d 
aa12			 
aa12			 
aa12				       NEXTW 
aa12 c3 00 9a			jp macro_next 
aa15				endm 
# End of macro NEXTW
aa15			.CONFIG: 
aa15				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
aa15 6f				db WORD_SYS_CORE+91             
aa16 26 aa			dw .ENDCORE            
aa18 07				db 6 + 1 
aa19 .. 00			db "CONFIG",0              
aa20				endm 
# End of macro CWHEAD
aa20			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
aa20			 
aa20 cd bd 90				call config 
aa23					NEXTW 
aa23 c3 00 9a			jp macro_next 
aa26				endm 
# End of macro NEXTW
aa26			.ENDCORE: 
aa26			 
aa26			; eof 
aa26			 
aa26			 
# End of file forth_words_core.asm
aa26			include "forth_words_flow.asm" 
aa26			 
aa26			; | ## Program Flow Words 
aa26			 
aa26			.IF: 
aa26				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
aa26 1e				db WORD_SYS_CORE+10             
aa27 1b ab			dw .THEN            
aa29 03				db 2 + 1 
aa2a .. 00			db "IF",0              
aa2d				endm 
# End of macro CWHEAD
aa2d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
aa2d			; 
aa2d					if DEBUG_FORTH_WORDS_KEY 
aa2d						DMARK "IF." 
aa2d f5				push af  
aa2e 3a 42 aa			ld a, (.dmark)  
aa31 32 7a ee			ld (debug_mark),a  
aa34 3a 43 aa			ld a, (.dmark+1)  
aa37 32 7b ee			ld (debug_mark+1),a  
aa3a 3a 44 aa			ld a, (.dmark+2)  
aa3d 32 7c ee			ld (debug_mark+2),a  
aa40 18 03			jr .pastdmark  
aa42 ..			.dmark: db "IF."  
aa45 f1			.pastdmark: pop af  
aa46			endm  
# End of macro DMARK
aa46						CALLMONITOR 
aa46 cd 75 92			call break_point_state  
aa49				endm  
# End of macro CALLMONITOR
aa49					endif 
aa49			; eval TOS 
aa49			 
aa49				FORTH_DSP_VALUEHL 
aa49 cd aa 98			call macro_dsp_valuehl 
aa4c				endm 
# End of macro FORTH_DSP_VALUEHL
aa4c			 
aa4c			;	push hl 
aa4c				FORTH_DSP_POP 
aa4c cd 46 99			call macro_forth_dsp_pop 
aa4f				endm 
# End of macro FORTH_DSP_POP
aa4f			;	pop hl 
aa4f			 
aa4f					if DEBUG_FORTH_WORDS 
aa4f						DMARK "IF1" 
aa4f f5				push af  
aa50 3a 64 aa			ld a, (.dmark)  
aa53 32 7a ee			ld (debug_mark),a  
aa56 3a 65 aa			ld a, (.dmark+1)  
aa59 32 7b ee			ld (debug_mark+1),a  
aa5c 3a 66 aa			ld a, (.dmark+2)  
aa5f 32 7c ee			ld (debug_mark+2),a  
aa62 18 03			jr .pastdmark  
aa64 ..			.dmark: db "IF1"  
aa67 f1			.pastdmark: pop af  
aa68			endm  
# End of macro DMARK
aa68						CALLMONITOR 
aa68 cd 75 92			call break_point_state  
aa6b				endm  
# End of macro CALLMONITOR
aa6b					endif 
aa6b b7				or a        ; clear carry flag 
aa6c 11 00 00			ld de, 0 
aa6f eb				ex de,hl 
aa70 ed 52			sbc hl, de 
aa72 c2 fc aa			jp nz, .iftrue 
aa75			 
aa75					if DEBUG_FORTH_WORDS 
aa75						DMARK "IF2" 
aa75 f5				push af  
aa76 3a 8a aa			ld a, (.dmark)  
aa79 32 7a ee			ld (debug_mark),a  
aa7c 3a 8b aa			ld a, (.dmark+1)  
aa7f 32 7b ee			ld (debug_mark+1),a  
aa82 3a 8c aa			ld a, (.dmark+2)  
aa85 32 7c ee			ld (debug_mark+2),a  
aa88 18 03			jr .pastdmark  
aa8a ..			.dmark: db "IF2"  
aa8d f1			.pastdmark: pop af  
aa8e			endm  
# End of macro DMARK
aa8e						CALLMONITOR 
aa8e cd 75 92			call break_point_state  
aa91				endm  
# End of macro CALLMONITOR
aa91					endif 
aa91			 
aa91			; if not true then skip to THEN 
aa91			 
aa91				; TODO get tok_ptr 
aa91				; TODO consume toks until we get to THEN 
aa91			 
aa91 2a 76 e6			ld hl, (os_tok_ptr) 
aa94					if DEBUG_FORTH_WORDS 
aa94						DMARK "IF3" 
aa94 f5				push af  
aa95 3a a9 aa			ld a, (.dmark)  
aa98 32 7a ee			ld (debug_mark),a  
aa9b 3a aa aa			ld a, (.dmark+1)  
aa9e 32 7b ee			ld (debug_mark+1),a  
aaa1 3a ab aa			ld a, (.dmark+2)  
aaa4 32 7c ee			ld (debug_mark+2),a  
aaa7 18 03			jr .pastdmark  
aaa9 ..			.dmark: db "IF3"  
aaac f1			.pastdmark: pop af  
aaad			endm  
# End of macro DMARK
aaad						CALLMONITOR 
aaad cd 75 92			call break_point_state  
aab0				endm  
# End of macro CALLMONITOR
aab0						 
aab0					endif 
aab0 11 f7 aa			ld de, .ifthen 
aab3					if DEBUG_FORTH_WORDS 
aab3						DMARK "IF4" 
aab3 f5				push af  
aab4 3a c8 aa			ld a, (.dmark)  
aab7 32 7a ee			ld (debug_mark),a  
aaba 3a c9 aa			ld a, (.dmark+1)  
aabd 32 7b ee			ld (debug_mark+1),a  
aac0 3a ca aa			ld a, (.dmark+2)  
aac3 32 7c ee			ld (debug_mark+2),a  
aac6 18 03			jr .pastdmark  
aac8 ..			.dmark: db "IF4"  
aacb f1			.pastdmark: pop af  
aacc			endm  
# End of macro DMARK
aacc						CALLMONITOR 
aacc cd 75 92			call break_point_state  
aacf				endm  
# End of macro CALLMONITOR
aacf					endif 
aacf cd 1b 9b			call findnexttok  
aad2			 
aad2					if DEBUG_FORTH_WORDS 
aad2						DMARK "IF5" 
aad2 f5				push af  
aad3 3a e7 aa			ld a, (.dmark)  
aad6 32 7a ee			ld (debug_mark),a  
aad9 3a e8 aa			ld a, (.dmark+1)  
aadc 32 7b ee			ld (debug_mark+1),a  
aadf 3a e9 aa			ld a, (.dmark+2)  
aae2 32 7c ee			ld (debug_mark+2),a  
aae5 18 03			jr .pastdmark  
aae7 ..			.dmark: db "IF5"  
aaea f1			.pastdmark: pop af  
aaeb			endm  
# End of macro DMARK
aaeb						CALLMONITOR 
aaeb cd 75 92			call break_point_state  
aaee				endm  
# End of macro CALLMONITOR
aaee					endif 
aaee				; TODO replace below with ; exec using tok_ptr 
aaee 22 76 e6			ld (os_tok_ptr), hl 
aaf1 c3 91 9a			jp exec1 
aaf4				NEXTW 
aaf4 c3 00 9a			jp macro_next 
aaf7				endm 
# End of macro NEXTW
aaf7			 
aaf7 .. 00		.ifthen:  db "THEN",0 
aafc			 
aafc			.iftrue:		 
aafc				; Exec next words normally 
aafc			 
aafc				; if true then exec following IF as normal 
aafc					if DEBUG_FORTH_WORDS 
aafc						DMARK "IFT" 
aafc f5				push af  
aafd 3a 11 ab			ld a, (.dmark)  
ab00 32 7a ee			ld (debug_mark),a  
ab03 3a 12 ab			ld a, (.dmark+1)  
ab06 32 7b ee			ld (debug_mark+1),a  
ab09 3a 13 ab			ld a, (.dmark+2)  
ab0c 32 7c ee			ld (debug_mark+2),a  
ab0f 18 03			jr .pastdmark  
ab11 ..			.dmark: db "IFT"  
ab14 f1			.pastdmark: pop af  
ab15			endm  
# End of macro DMARK
ab15						CALLMONITOR 
ab15 cd 75 92			call break_point_state  
ab18				endm  
# End of macro CALLMONITOR
ab18					endif 
ab18			 
ab18					NEXTW 
ab18 c3 00 9a			jp macro_next 
ab1b				endm 
# End of macro NEXTW
ab1b			.THEN: 
ab1b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ab1b 1f				db WORD_SYS_CORE+11             
ab1c 43 ab			dw .ELSE            
ab1e 05				db 4 + 1 
ab1f .. 00			db "THEN",0              
ab24				endm 
# End of macro CWHEAD
ab24			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ab24					if DEBUG_FORTH_WORDS_KEY 
ab24						DMARK "THN" 
ab24 f5				push af  
ab25 3a 39 ab			ld a, (.dmark)  
ab28 32 7a ee			ld (debug_mark),a  
ab2b 3a 3a ab			ld a, (.dmark+1)  
ab2e 32 7b ee			ld (debug_mark+1),a  
ab31 3a 3b ab			ld a, (.dmark+2)  
ab34 32 7c ee			ld (debug_mark+2),a  
ab37 18 03			jr .pastdmark  
ab39 ..			.dmark: db "THN"  
ab3c f1			.pastdmark: pop af  
ab3d			endm  
# End of macro DMARK
ab3d						CALLMONITOR 
ab3d cd 75 92			call break_point_state  
ab40				endm  
# End of macro CALLMONITOR
ab40					endif 
ab40					NEXTW 
ab40 c3 00 9a			jp macro_next 
ab43				endm 
# End of macro NEXTW
ab43			.ELSE: 
ab43				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ab43 20				db WORD_SYS_CORE+12             
ab44 6b ab			dw .DO            
ab46 03				db 2 + 1 
ab47 .. 00			db "ELSE",0              
ab4c				endm 
# End of macro CWHEAD
ab4c			; | ELSE ( -- ) Not supported - does nothing | TODO 
ab4c			 
ab4c					if DEBUG_FORTH_WORDS_KEY 
ab4c						DMARK "ELS" 
ab4c f5				push af  
ab4d 3a 61 ab			ld a, (.dmark)  
ab50 32 7a ee			ld (debug_mark),a  
ab53 3a 62 ab			ld a, (.dmark+1)  
ab56 32 7b ee			ld (debug_mark+1),a  
ab59 3a 63 ab			ld a, (.dmark+2)  
ab5c 32 7c ee			ld (debug_mark+2),a  
ab5f 18 03			jr .pastdmark  
ab61 ..			.dmark: db "ELS"  
ab64 f1			.pastdmark: pop af  
ab65			endm  
# End of macro DMARK
ab65						CALLMONITOR 
ab65 cd 75 92			call break_point_state  
ab68				endm  
# End of macro CALLMONITOR
ab68					endif 
ab68			 
ab68			 
ab68					NEXTW 
ab68 c3 00 9a			jp macro_next 
ab6b				endm 
# End of macro NEXTW
ab6b			.DO: 
ab6b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ab6b 21				db WORD_SYS_CORE+13             
ab6c 92 ac			dw .LOOP            
ab6e 03				db 2 + 1 
ab6f .. 00			db "DO",0              
ab72				endm 
# End of macro CWHEAD
ab72			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ab72			 
ab72					if DEBUG_FORTH_WORDS_KEY 
ab72						DMARK "DO." 
ab72 f5				push af  
ab73 3a 87 ab			ld a, (.dmark)  
ab76 32 7a ee			ld (debug_mark),a  
ab79 3a 88 ab			ld a, (.dmark+1)  
ab7c 32 7b ee			ld (debug_mark+1),a  
ab7f 3a 89 ab			ld a, (.dmark+2)  
ab82 32 7c ee			ld (debug_mark+2),a  
ab85 18 03			jr .pastdmark  
ab87 ..			.dmark: db "DO."  
ab8a f1			.pastdmark: pop af  
ab8b			endm  
# End of macro DMARK
ab8b						CALLMONITOR 
ab8b cd 75 92			call break_point_state  
ab8e				endm  
# End of macro CALLMONITOR
ab8e					endif 
ab8e			;  push pc to rsp stack past the DO 
ab8e			 
ab8e 2a 76 e6				ld hl, (os_tok_ptr) 
ab91 23					inc hl   ; D 
ab92 23					inc hl  ; O 
ab93 23					inc hl   ; null 
ab94					if DEBUG_FORTH_WORDS 
ab94						DMARK "DO2" 
ab94 f5				push af  
ab95 3a a9 ab			ld a, (.dmark)  
ab98 32 7a ee			ld (debug_mark),a  
ab9b 3a aa ab			ld a, (.dmark+1)  
ab9e 32 7b ee			ld (debug_mark+1),a  
aba1 3a ab ab			ld a, (.dmark+2)  
aba4 32 7c ee			ld (debug_mark+2),a  
aba7 18 03			jr .pastdmark  
aba9 ..			.dmark: db "DO2"  
abac f1			.pastdmark: pop af  
abad			endm  
# End of macro DMARK
abad						CALLMONITOR 
abad cd 75 92			call break_point_state  
abb0				endm  
# End of macro CALLMONITOR
abb0					endif 
abb0					FORTH_RSP_NEXT 
abb0 cd b6 97			call macro_forth_rsp_next 
abb3				endm 
# End of macro FORTH_RSP_NEXT
abb3					if DEBUG_FORTH_WORDS 
abb3						DMARK "DO3" 
abb3 f5				push af  
abb4 3a c8 ab			ld a, (.dmark)  
abb7 32 7a ee			ld (debug_mark),a  
abba 3a c9 ab			ld a, (.dmark+1)  
abbd 32 7b ee			ld (debug_mark+1),a  
abc0 3a ca ab			ld a, (.dmark+2)  
abc3 32 7c ee			ld (debug_mark+2),a  
abc6 18 03			jr .pastdmark  
abc8 ..			.dmark: db "DO3"  
abcb f1			.pastdmark: pop af  
abcc			endm  
# End of macro DMARK
abcc						CALLMONITOR 
abcc cd 75 92			call break_point_state  
abcf				endm  
# End of macro CALLMONITOR
abcf					endif 
abcf			 
abcf					;if DEBUG_FORTH_WORDS 
abcf				;		push hl 
abcf			;		endif  
abcf			 
abcf			; get counters from data stack 
abcf			 
abcf			 
abcf					FORTH_DSP_VALUEHL 
abcf cd aa 98			call macro_dsp_valuehl 
abd2				endm 
# End of macro FORTH_DSP_VALUEHL
abd2 e5					push hl		 ; hl now has starting counter which needs to be tos 
abd3			 
abd3					if DEBUG_FORTH_WORDS 
abd3						DMARK "DO4" 
abd3 f5				push af  
abd4 3a e8 ab			ld a, (.dmark)  
abd7 32 7a ee			ld (debug_mark),a  
abda 3a e9 ab			ld a, (.dmark+1)  
abdd 32 7b ee			ld (debug_mark+1),a  
abe0 3a ea ab			ld a, (.dmark+2)  
abe3 32 7c ee			ld (debug_mark+2),a  
abe6 18 03			jr .pastdmark  
abe8 ..			.dmark: db "DO4"  
abeb f1			.pastdmark: pop af  
abec			endm  
# End of macro DMARK
abec						CALLMONITOR 
abec cd 75 92			call break_point_state  
abef				endm  
# End of macro CALLMONITOR
abef					endif 
abef					FORTH_DSP_POP 
abef cd 46 99			call macro_forth_dsp_pop 
abf2				endm 
# End of macro FORTH_DSP_POP
abf2			 
abf2					if DEBUG_FORTH_WORDS 
abf2						DMARK "DO5" 
abf2 f5				push af  
abf3 3a 07 ac			ld a, (.dmark)  
abf6 32 7a ee			ld (debug_mark),a  
abf9 3a 08 ac			ld a, (.dmark+1)  
abfc 32 7b ee			ld (debug_mark+1),a  
abff 3a 09 ac			ld a, (.dmark+2)  
ac02 32 7c ee			ld (debug_mark+2),a  
ac05 18 03			jr .pastdmark  
ac07 ..			.dmark: db "DO5"  
ac0a f1			.pastdmark: pop af  
ac0b			endm  
# End of macro DMARK
ac0b						CALLMONITOR 
ac0b cd 75 92			call break_point_state  
ac0e				endm  
# End of macro CALLMONITOR
ac0e					endif 
ac0e			 
ac0e					FORTH_DSP_VALUEHL 
ac0e cd aa 98			call macro_dsp_valuehl 
ac11				endm 
# End of macro FORTH_DSP_VALUEHL
ac11			;		push hl		 ; hl now has starting limit counter 
ac11			 
ac11					if DEBUG_FORTH_WORDS 
ac11						DMARK "DO6" 
ac11 f5				push af  
ac12 3a 26 ac			ld a, (.dmark)  
ac15 32 7a ee			ld (debug_mark),a  
ac18 3a 27 ac			ld a, (.dmark+1)  
ac1b 32 7b ee			ld (debug_mark+1),a  
ac1e 3a 28 ac			ld a, (.dmark+2)  
ac21 32 7c ee			ld (debug_mark+2),a  
ac24 18 03			jr .pastdmark  
ac26 ..			.dmark: db "DO6"  
ac29 f1			.pastdmark: pop af  
ac2a			endm  
# End of macro DMARK
ac2a						CALLMONITOR 
ac2a cd 75 92			call break_point_state  
ac2d				endm  
# End of macro CALLMONITOR
ac2d					endif 
ac2d					FORTH_DSP_POP 
ac2d cd 46 99			call macro_forth_dsp_pop 
ac30				endm 
# End of macro FORTH_DSP_POP
ac30			 
ac30			; put counters on the loop stack 
ac30			 
ac30			;		pop hl			 ; limit counter 
ac30 d1					pop de			; start counter 
ac31			 
ac31					; push limit counter 
ac31			 
ac31					if DEBUG_FORTH_WORDS 
ac31						DMARK "DO7" 
ac31 f5				push af  
ac32 3a 46 ac			ld a, (.dmark)  
ac35 32 7a ee			ld (debug_mark),a  
ac38 3a 47 ac			ld a, (.dmark+1)  
ac3b 32 7b ee			ld (debug_mark+1),a  
ac3e 3a 48 ac			ld a, (.dmark+2)  
ac41 32 7c ee			ld (debug_mark+2),a  
ac44 18 03			jr .pastdmark  
ac46 ..			.dmark: db "DO7"  
ac49 f1			.pastdmark: pop af  
ac4a			endm  
# End of macro DMARK
ac4a						CALLMONITOR 
ac4a cd 75 92			call break_point_state  
ac4d				endm  
# End of macro CALLMONITOR
ac4d					endif 
ac4d					FORTH_LOOP_NEXT 
ac4d cd bf 98			call macro_forth_loop_next 
ac50				endm 
# End of macro FORTH_LOOP_NEXT
ac50			 
ac50					; push start counter 
ac50			 
ac50 eb					ex de, hl 
ac51					if DEBUG_FORTH_WORDS 
ac51						DMARK "DO7" 
ac51 f5				push af  
ac52 3a 66 ac			ld a, (.dmark)  
ac55 32 7a ee			ld (debug_mark),a  
ac58 3a 67 ac			ld a, (.dmark+1)  
ac5b 32 7b ee			ld (debug_mark+1),a  
ac5e 3a 68 ac			ld a, (.dmark+2)  
ac61 32 7c ee			ld (debug_mark+2),a  
ac64 18 03			jr .pastdmark  
ac66 ..			.dmark: db "DO7"  
ac69 f1			.pastdmark: pop af  
ac6a			endm  
# End of macro DMARK
ac6a						CALLMONITOR 
ac6a cd 75 92			call break_point_state  
ac6d				endm  
# End of macro CALLMONITOR
ac6d					endif 
ac6d					FORTH_LOOP_NEXT 
ac6d cd bf 98			call macro_forth_loop_next 
ac70				endm 
# End of macro FORTH_LOOP_NEXT
ac70			 
ac70			 
ac70					; init first round of I counter 
ac70			 
ac70 22 9a e6				ld (os_current_i), hl 
ac73			 
ac73					if DEBUG_FORTH_WORDS 
ac73						DMARK "DO8" 
ac73 f5				push af  
ac74 3a 88 ac			ld a, (.dmark)  
ac77 32 7a ee			ld (debug_mark),a  
ac7a 3a 89 ac			ld a, (.dmark+1)  
ac7d 32 7b ee			ld (debug_mark+1),a  
ac80 3a 8a ac			ld a, (.dmark+2)  
ac83 32 7c ee			ld (debug_mark+2),a  
ac86 18 03			jr .pastdmark  
ac88 ..			.dmark: db "DO8"  
ac8b f1			.pastdmark: pop af  
ac8c			endm  
# End of macro DMARK
ac8c						CALLMONITOR 
ac8c cd 75 92			call break_point_state  
ac8f				endm  
# End of macro CALLMONITOR
ac8f					endif 
ac8f			 
ac8f					NEXTW 
ac8f c3 00 9a			jp macro_next 
ac92				endm 
# End of macro NEXTW
ac92			.LOOP: 
ac92				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ac92 22				db WORD_SYS_CORE+14             
ac93 aa ad			dw .I            
ac95 05				db 4 + 1 
ac96 .. 00			db "LOOP",0              
ac9b				endm 
# End of macro CWHEAD
ac9b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ac9b			 
ac9b				; pop tos as current loop count to hl 
ac9b			 
ac9b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ac9b			 
ac9b				FORTH_LOOP_TOS 
ac9b cd f2 98			call macro_forth_loop_tos 
ac9e				endm 
# End of macro FORTH_LOOP_TOS
ac9e e5				push hl 
ac9f			 
ac9f					if DEBUG_FORTH_WORDS_KEY 
ac9f						DMARK "LOP" 
ac9f f5				push af  
aca0 3a b4 ac			ld a, (.dmark)  
aca3 32 7a ee			ld (debug_mark),a  
aca6 3a b5 ac			ld a, (.dmark+1)  
aca9 32 7b ee			ld (debug_mark+1),a  
acac 3a b6 ac			ld a, (.dmark+2)  
acaf 32 7c ee			ld (debug_mark+2),a  
acb2 18 03			jr .pastdmark  
acb4 ..			.dmark: db "LOP"  
acb7 f1			.pastdmark: pop af  
acb8			endm  
# End of macro DMARK
acb8						CALLMONITOR 
acb8 cd 75 92			call break_point_state  
acbb				endm  
# End of macro CALLMONITOR
acbb					endif 
acbb				; next item on the stack is the limit. get it 
acbb			 
acbb			 
acbb				FORTH_LOOP_POP 
acbb cd fc 98			call macro_forth_loop_pop 
acbe				endm 
# End of macro FORTH_LOOP_POP
acbe			 
acbe				FORTH_LOOP_TOS 
acbe cd f2 98			call macro_forth_loop_tos 
acc1				endm 
# End of macro FORTH_LOOP_TOS
acc1			 
acc1 d1				pop de		 ; de = i, hl = limit 
acc2			 
acc2					if DEBUG_FORTH_WORDS 
acc2						DMARK "LP1" 
acc2 f5				push af  
acc3 3a d7 ac			ld a, (.dmark)  
acc6 32 7a ee			ld (debug_mark),a  
acc9 3a d8 ac			ld a, (.dmark+1)  
accc 32 7b ee			ld (debug_mark+1),a  
accf 3a d9 ac			ld a, (.dmark+2)  
acd2 32 7c ee			ld (debug_mark+2),a  
acd5 18 03			jr .pastdmark  
acd7 ..			.dmark: db "LP1"  
acda f1			.pastdmark: pop af  
acdb			endm  
# End of macro DMARK
acdb						CALLMONITOR 
acdb cd 75 92			call break_point_state  
acde				endm  
# End of macro CALLMONITOR
acde					endif 
acde			 
acde				; go back to previous word 
acde			 
acde d5				push de    ; save I for inc later 
acdf			 
acdf			 
acdf				; get limit 
acdf				;  is I at limit? 
acdf			 
acdf			 
acdf					if DEBUG_FORTH_WORDS 
acdf						DMARK "LP1" 
acdf f5				push af  
ace0 3a f4 ac			ld a, (.dmark)  
ace3 32 7a ee			ld (debug_mark),a  
ace6 3a f5 ac			ld a, (.dmark+1)  
ace9 32 7b ee			ld (debug_mark+1),a  
acec 3a f6 ac			ld a, (.dmark+2)  
acef 32 7c ee			ld (debug_mark+2),a  
acf2 18 03			jr .pastdmark  
acf4 ..			.dmark: db "LP1"  
acf7 f1			.pastdmark: pop af  
acf8			endm  
# End of macro DMARK
acf8						CALLMONITOR 
acf8 cd 75 92			call break_point_state  
acfb				endm  
# End of macro CALLMONITOR
acfb					endif 
acfb			 
acfb ed 52			sbc hl, de 
acfd			 
acfd			 
acfd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
acfd			 
acfd 20 26				jr nz, .loopnotdone 
acff			 
acff e1				pop hl   ; get rid of saved I 
ad00				FORTH_LOOP_POP     ; get rid of limit 
ad00 cd fc 98			call macro_forth_loop_pop 
ad03				endm 
# End of macro FORTH_LOOP_POP
ad03			 
ad03				FORTH_RSP_POP     ; get rid of DO ptr 
ad03 cd d7 97			call macro_forth_rsp_pop 
ad06				endm 
# End of macro FORTH_RSP_POP
ad06			 
ad06			if DEBUG_FORTH_WORDS 
ad06						DMARK "LP>" 
ad06 f5				push af  
ad07 3a 1b ad			ld a, (.dmark)  
ad0a 32 7a ee			ld (debug_mark),a  
ad0d 3a 1c ad			ld a, (.dmark+1)  
ad10 32 7b ee			ld (debug_mark+1),a  
ad13 3a 1d ad			ld a, (.dmark+2)  
ad16 32 7c ee			ld (debug_mark+2),a  
ad19 18 03			jr .pastdmark  
ad1b ..			.dmark: db "LP>"  
ad1e f1			.pastdmark: pop af  
ad1f			endm  
# End of macro DMARK
ad1f				CALLMONITOR 
ad1f cd 75 92			call break_point_state  
ad22				endm  
# End of macro CALLMONITOR
ad22			endif 
ad22			 
ad22					NEXTW 
ad22 c3 00 9a			jp macro_next 
ad25				endm 
# End of macro NEXTW
ad25				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ad25			 
ad25			.loopnotdone: 
ad25			 
ad25 e1				pop hl    ; get I 
ad26 23				inc hl 
ad27			 
ad27			   	; save new I 
ad27			 
ad27			 
ad27					; set I counter 
ad27			 
ad27 22 9a e6				ld (os_current_i), hl 
ad2a			 
ad2a					if DEBUG_FORTH_WORDS 
ad2a						DMARK "LPN" 
ad2a f5				push af  
ad2b 3a 3f ad			ld a, (.dmark)  
ad2e 32 7a ee			ld (debug_mark),a  
ad31 3a 40 ad			ld a, (.dmark+1)  
ad34 32 7b ee			ld (debug_mark+1),a  
ad37 3a 41 ad			ld a, (.dmark+2)  
ad3a 32 7c ee			ld (debug_mark+2),a  
ad3d 18 03			jr .pastdmark  
ad3f ..			.dmark: db "LPN"  
ad42 f1			.pastdmark: pop af  
ad43			endm  
# End of macro DMARK
ad43					CALLMONITOR 
ad43 cd 75 92			call break_point_state  
ad46				endm  
# End of macro CALLMONITOR
ad46					endif 
ad46					 
ad46				FORTH_LOOP_NEXT 
ad46 cd bf 98			call macro_forth_loop_next 
ad49				endm 
# End of macro FORTH_LOOP_NEXT
ad49			 
ad49			 
ad49					if DEBUG_FORTH_WORDS 
ad49 eb						ex de,hl 
ad4a					endif 
ad4a			 
ad4a			;	; get DO ptr 
ad4a			; 
ad4a					if DEBUG_FORTH_WORDS 
ad4a						DMARK "LP7" 
ad4a f5				push af  
ad4b 3a 5f ad			ld a, (.dmark)  
ad4e 32 7a ee			ld (debug_mark),a  
ad51 3a 60 ad			ld a, (.dmark+1)  
ad54 32 7b ee			ld (debug_mark+1),a  
ad57 3a 61 ad			ld a, (.dmark+2)  
ad5a 32 7c ee			ld (debug_mark+2),a  
ad5d 18 03			jr .pastdmark  
ad5f ..			.dmark: db "LP7"  
ad62 f1			.pastdmark: pop af  
ad63			endm  
# End of macro DMARK
ad63					CALLMONITOR 
ad63 cd 75 92			call break_point_state  
ad66				endm  
# End of macro CALLMONITOR
ad66					endif 
ad66				FORTH_RSP_TOS 
ad66 cd cd 97			call macro_forth_rsp_tos 
ad69				endm 
# End of macro FORTH_RSP_TOS
ad69			 
ad69					if DEBUG_FORTH_WORDS 
ad69						DMARK "LP8" 
ad69 f5				push af  
ad6a 3a 7e ad			ld a, (.dmark)  
ad6d 32 7a ee			ld (debug_mark),a  
ad70 3a 7f ad			ld a, (.dmark+1)  
ad73 32 7b ee			ld (debug_mark+1),a  
ad76 3a 80 ad			ld a, (.dmark+2)  
ad79 32 7c ee			ld (debug_mark+2),a  
ad7c 18 03			jr .pastdmark  
ad7e ..			.dmark: db "LP8"  
ad81 f1			.pastdmark: pop af  
ad82			endm  
# End of macro DMARK
ad82					CALLMONITOR 
ad82 cd 75 92			call break_point_state  
ad85				endm  
# End of macro CALLMONITOR
ad85					endif 
ad85				;push hl 
ad85			 
ad85				; not going to DO any more 
ad85				; get rid of the RSP pointer as DO will add it back in 
ad85				;FORTH_RSP_POP 
ad85				;pop hl 
ad85			 
ad85				;ld hl,(cli_ret_sp) 
ad85				;ld e, (hl) 
ad85				;inc hl 
ad85				;ld d, (hl) 
ad85				;ex de,hl 
ad85 22 76 e6			ld (os_tok_ptr), hl 
ad88					if DEBUG_FORTH_WORDS 
ad88						DMARK "LP<" 
ad88 f5				push af  
ad89 3a 9d ad			ld a, (.dmark)  
ad8c 32 7a ee			ld (debug_mark),a  
ad8f 3a 9e ad			ld a, (.dmark+1)  
ad92 32 7b ee			ld (debug_mark+1),a  
ad95 3a 9f ad			ld a, (.dmark+2)  
ad98 32 7c ee			ld (debug_mark+2),a  
ad9b 18 03			jr .pastdmark  
ad9d ..			.dmark: db "LP<"  
ada0 f1			.pastdmark: pop af  
ada1			endm  
# End of macro DMARK
ada1					CALLMONITOR 
ada1 cd 75 92			call break_point_state  
ada4				endm  
# End of macro CALLMONITOR
ada4				endif 
ada4 c3 91 9a			jp exec1 
ada7			 
ada7					 
ada7			 
ada7			 
ada7					NEXTW 
ada7 c3 00 9a			jp macro_next 
adaa				endm 
# End of macro NEXTW
adaa			.I:  
adaa			 
adaa				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
adaa 5e				db WORD_SYS_CORE+74             
adab d5 ad			dw .DLOOP            
adad 02				db 1 + 1 
adae .. 00			db "I",0              
adb0				endm 
# End of macro CWHEAD
adb0			; | I ( -- ) Current loop counter | DONE 
adb0					if DEBUG_FORTH_WORDS_KEY 
adb0						DMARK "I.." 
adb0 f5				push af  
adb1 3a c5 ad			ld a, (.dmark)  
adb4 32 7a ee			ld (debug_mark),a  
adb7 3a c6 ad			ld a, (.dmark+1)  
adba 32 7b ee			ld (debug_mark+1),a  
adbd 3a c7 ad			ld a, (.dmark+2)  
adc0 32 7c ee			ld (debug_mark+2),a  
adc3 18 03			jr .pastdmark  
adc5 ..			.dmark: db "I.."  
adc8 f1			.pastdmark: pop af  
adc9			endm  
# End of macro DMARK
adc9						CALLMONITOR 
adc9 cd 75 92			call break_point_state  
adcc				endm  
# End of macro CALLMONITOR
adcc					endif 
adcc			 
adcc 2a 9a e6				ld hl,(os_current_i) 
adcf cd 0f 98				call forth_push_numhl 
add2			 
add2					NEXTW 
add2 c3 00 9a			jp macro_next 
add5				endm 
# End of macro NEXTW
add5			.DLOOP: 
add5				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
add5 5f				db WORD_SYS_CORE+75             
add6 b6 ae			dw .REPEAT            
add8 06				db 5 + 1 
add9 .. 00			db "-LOOP",0              
addf				endm 
# End of macro CWHEAD
addf			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
addf				; pop tos as current loop count to hl 
addf					if DEBUG_FORTH_WORDS_KEY 
addf						DMARK "-LP" 
addf f5				push af  
ade0 3a f4 ad			ld a, (.dmark)  
ade3 32 7a ee			ld (debug_mark),a  
ade6 3a f5 ad			ld a, (.dmark+1)  
ade9 32 7b ee			ld (debug_mark+1),a  
adec 3a f6 ad			ld a, (.dmark+2)  
adef 32 7c ee			ld (debug_mark+2),a  
adf2 18 03			jr .pastdmark  
adf4 ..			.dmark: db "-LP"  
adf7 f1			.pastdmark: pop af  
adf8			endm  
# End of macro DMARK
adf8						CALLMONITOR 
adf8 cd 75 92			call break_point_state  
adfb				endm  
# End of macro CALLMONITOR
adfb					endif 
adfb			 
adfb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
adfb			 
adfb				FORTH_LOOP_TOS 
adfb cd f2 98			call macro_forth_loop_tos 
adfe				endm 
# End of macro FORTH_LOOP_TOS
adfe e5				push hl 
adff			 
adff					if DEBUG_FORTH_WORDS 
adff						DMARK "-LP" 
adff f5				push af  
ae00 3a 14 ae			ld a, (.dmark)  
ae03 32 7a ee			ld (debug_mark),a  
ae06 3a 15 ae			ld a, (.dmark+1)  
ae09 32 7b ee			ld (debug_mark+1),a  
ae0c 3a 16 ae			ld a, (.dmark+2)  
ae0f 32 7c ee			ld (debug_mark+2),a  
ae12 18 03			jr .pastdmark  
ae14 ..			.dmark: db "-LP"  
ae17 f1			.pastdmark: pop af  
ae18			endm  
# End of macro DMARK
ae18						CALLMONITOR 
ae18 cd 75 92			call break_point_state  
ae1b				endm  
# End of macro CALLMONITOR
ae1b					endif 
ae1b				; next item on the stack is the limit. get it 
ae1b			 
ae1b			 
ae1b				FORTH_LOOP_POP 
ae1b cd fc 98			call macro_forth_loop_pop 
ae1e				endm 
# End of macro FORTH_LOOP_POP
ae1e			 
ae1e				FORTH_LOOP_TOS 
ae1e cd f2 98			call macro_forth_loop_tos 
ae21				endm 
# End of macro FORTH_LOOP_TOS
ae21			 
ae21 d1				pop de		 ; de = i, hl = limit 
ae22			 
ae22					if DEBUG_FORTH_WORDS 
ae22						DMARK "-L1" 
ae22 f5				push af  
ae23 3a 37 ae			ld a, (.dmark)  
ae26 32 7a ee			ld (debug_mark),a  
ae29 3a 38 ae			ld a, (.dmark+1)  
ae2c 32 7b ee			ld (debug_mark+1),a  
ae2f 3a 39 ae			ld a, (.dmark+2)  
ae32 32 7c ee			ld (debug_mark+2),a  
ae35 18 03			jr .pastdmark  
ae37 ..			.dmark: db "-L1"  
ae3a f1			.pastdmark: pop af  
ae3b			endm  
# End of macro DMARK
ae3b						CALLMONITOR 
ae3b cd 75 92			call break_point_state  
ae3e				endm  
# End of macro CALLMONITOR
ae3e					endif 
ae3e			 
ae3e				; go back to previous word 
ae3e			 
ae3e d5				push de    ; save I for inc later 
ae3f			 
ae3f			 
ae3f				; get limit 
ae3f				;  is I at limit? 
ae3f			 
ae3f			 
ae3f					if DEBUG_FORTH_WORDS 
ae3f						DMARK "-L1" 
ae3f f5				push af  
ae40 3a 54 ae			ld a, (.dmark)  
ae43 32 7a ee			ld (debug_mark),a  
ae46 3a 55 ae			ld a, (.dmark+1)  
ae49 32 7b ee			ld (debug_mark+1),a  
ae4c 3a 56 ae			ld a, (.dmark+2)  
ae4f 32 7c ee			ld (debug_mark+2),a  
ae52 18 03			jr .pastdmark  
ae54 ..			.dmark: db "-L1"  
ae57 f1			.pastdmark: pop af  
ae58			endm  
# End of macro DMARK
ae58						CALLMONITOR 
ae58 cd 75 92			call break_point_state  
ae5b				endm  
# End of macro CALLMONITOR
ae5b					endif 
ae5b			 
ae5b ed 52			sbc hl, de 
ae5d			 
ae5d			 
ae5d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ae5d			 
ae5d 20 26				jr nz, .mloopnotdone 
ae5f			 
ae5f e1				pop hl   ; get rid of saved I 
ae60				FORTH_LOOP_POP     ; get rid of limit 
ae60 cd fc 98			call macro_forth_loop_pop 
ae63				endm 
# End of macro FORTH_LOOP_POP
ae63			 
ae63				FORTH_RSP_POP     ; get rid of DO ptr 
ae63 cd d7 97			call macro_forth_rsp_pop 
ae66				endm 
# End of macro FORTH_RSP_POP
ae66			 
ae66			if DEBUG_FORTH_WORDS 
ae66						DMARK "-L>" 
ae66 f5				push af  
ae67 3a 7b ae			ld a, (.dmark)  
ae6a 32 7a ee			ld (debug_mark),a  
ae6d 3a 7c ae			ld a, (.dmark+1)  
ae70 32 7b ee			ld (debug_mark+1),a  
ae73 3a 7d ae			ld a, (.dmark+2)  
ae76 32 7c ee			ld (debug_mark+2),a  
ae79 18 03			jr .pastdmark  
ae7b ..			.dmark: db "-L>"  
ae7e f1			.pastdmark: pop af  
ae7f			endm  
# End of macro DMARK
ae7f				CALLMONITOR 
ae7f cd 75 92			call break_point_state  
ae82				endm  
# End of macro CALLMONITOR
ae82			endif 
ae82			 
ae82					NEXTW 
ae82 c3 00 9a			jp macro_next 
ae85				endm 
# End of macro NEXTW
ae85				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae85			 
ae85			.mloopnotdone: 
ae85			 
ae85 e1				pop hl    ; get I 
ae86 2b				dec hl 
ae87			 
ae87			   	; save new I 
ae87			 
ae87			 
ae87					; set I counter 
ae87			 
ae87 22 9a e6				ld (os_current_i), hl 
ae8a			 
ae8a					 
ae8a				FORTH_LOOP_NEXT 
ae8a cd bf 98			call macro_forth_loop_next 
ae8d				endm 
# End of macro FORTH_LOOP_NEXT
ae8d			 
ae8d			 
ae8d					if DEBUG_FORTH_WORDS 
ae8d eb						ex de,hl 
ae8e					endif 
ae8e			 
ae8e			;	; get DO ptr 
ae8e			; 
ae8e				FORTH_RSP_TOS 
ae8e cd cd 97			call macro_forth_rsp_tos 
ae91				endm 
# End of macro FORTH_RSP_TOS
ae91			 
ae91				;push hl 
ae91			 
ae91				; not going to DO any more 
ae91				; get rid of the RSP pointer as DO will add it back in 
ae91				;FORTH_RSP_POP 
ae91				;pop hl 
ae91			 
ae91			 
ae91 22 76 e6			ld (os_tok_ptr), hl 
ae94					if DEBUG_FORTH_WORDS 
ae94						DMARK "-L<" 
ae94 f5				push af  
ae95 3a a9 ae			ld a, (.dmark)  
ae98 32 7a ee			ld (debug_mark),a  
ae9b 3a aa ae			ld a, (.dmark+1)  
ae9e 32 7b ee			ld (debug_mark+1),a  
aea1 3a ab ae			ld a, (.dmark+2)  
aea4 32 7c ee			ld (debug_mark+2),a  
aea7 18 03			jr .pastdmark  
aea9 ..			.dmark: db "-L<"  
aeac f1			.pastdmark: pop af  
aead			endm  
# End of macro DMARK
aead					CALLMONITOR 
aead cd 75 92			call break_point_state  
aeb0				endm  
# End of macro CALLMONITOR
aeb0				endif 
aeb0 c3 91 9a			jp exec1 
aeb3			 
aeb3					 
aeb3			 
aeb3			 
aeb3			 
aeb3				NEXTW 
aeb3 c3 00 9a			jp macro_next 
aeb6				endm 
# End of macro NEXTW
aeb6			 
aeb6			 
aeb6			 
aeb6			 
aeb6			.REPEAT: 
aeb6				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
aeb6 71				db WORD_SYS_CORE+93             
aeb7 09 af			dw .UNTIL            
aeb9 06				db 5 + 1 
aeba .. 00			db "REPEAT",0              
aec1				endm 
# End of macro CWHEAD
aec1			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
aec1			;  push pc to rsp stack past the REPEAT 
aec1					if DEBUG_FORTH_WORDS_KEY 
aec1						DMARK "REP" 
aec1 f5				push af  
aec2 3a d6 ae			ld a, (.dmark)  
aec5 32 7a ee			ld (debug_mark),a  
aec8 3a d7 ae			ld a, (.dmark+1)  
aecb 32 7b ee			ld (debug_mark+1),a  
aece 3a d8 ae			ld a, (.dmark+2)  
aed1 32 7c ee			ld (debug_mark+2),a  
aed4 18 03			jr .pastdmark  
aed6 ..			.dmark: db "REP"  
aed9 f1			.pastdmark: pop af  
aeda			endm  
# End of macro DMARK
aeda						CALLMONITOR 
aeda cd 75 92			call break_point_state  
aedd				endm  
# End of macro CALLMONITOR
aedd					endif 
aedd			 
aedd 2a 76 e6				ld hl, (os_tok_ptr) 
aee0 23					inc hl   ; R 
aee1 23					inc hl  ; E 
aee2 23					inc hl   ; P 
aee3 23					inc hl   ; E 
aee4 23					inc hl   ; A 
aee5 23					inc hl   ; T 
aee6 23					inc hl   ; zero 
aee7					FORTH_RSP_NEXT 
aee7 cd b6 97			call macro_forth_rsp_next 
aeea				endm 
# End of macro FORTH_RSP_NEXT
aeea			 
aeea			 
aeea					if DEBUG_FORTH_WORDS 
aeea						DMARK "REP" 
aeea f5				push af  
aeeb 3a ff ae			ld a, (.dmark)  
aeee 32 7a ee			ld (debug_mark),a  
aef1 3a 00 af			ld a, (.dmark+1)  
aef4 32 7b ee			ld (debug_mark+1),a  
aef7 3a 01 af			ld a, (.dmark+2)  
aefa 32 7c ee			ld (debug_mark+2),a  
aefd 18 03			jr .pastdmark  
aeff ..			.dmark: db "REP"  
af02 f1			.pastdmark: pop af  
af03			endm  
# End of macro DMARK
af03						;pop bc    ; TODO BUG ?????? what is this for???? 
af03						CALLMONITOR 
af03 cd 75 92			call break_point_state  
af06				endm  
# End of macro CALLMONITOR
af06					endif 
af06			 
af06					NEXTW 
af06 c3 00 9a			jp macro_next 
af09				endm 
# End of macro NEXTW
af09			;	       NEXTW 
af09			 
af09			.UNTIL: 
af09				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
af09 72				db WORD_SYS_CORE+94             
af0a a0 af			dw .ENDFLOW            
af0c 06				db 5 + 1 
af0d .. 00			db "UNTIL",0              
af13				endm 
# End of macro CWHEAD
af13			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
af13			 
af13				; pop tos as check 
af13			 
af13				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
af13			 
af13				FORTH_DSP_VALUEHL 
af13 cd aa 98			call macro_dsp_valuehl 
af16				endm 
# End of macro FORTH_DSP_VALUEHL
af16			 
af16					if DEBUG_FORTH_WORDS_KEY 
af16						DMARK "UNT" 
af16 f5				push af  
af17 3a 2b af			ld a, (.dmark)  
af1a 32 7a ee			ld (debug_mark),a  
af1d 3a 2c af			ld a, (.dmark+1)  
af20 32 7b ee			ld (debug_mark+1),a  
af23 3a 2d af			ld a, (.dmark+2)  
af26 32 7c ee			ld (debug_mark+2),a  
af29 18 03			jr .pastdmark  
af2b ..			.dmark: db "UNT"  
af2e f1			.pastdmark: pop af  
af2f			endm  
# End of macro DMARK
af2f						CALLMONITOR 
af2f cd 75 92			call break_point_state  
af32				endm  
# End of macro CALLMONITOR
af32					endif 
af32			 
af32			;	push hl 
af32				FORTH_DSP_POP 
af32 cd 46 99			call macro_forth_dsp_pop 
af35				endm 
# End of macro FORTH_DSP_POP
af35			 
af35			;	pop hl 
af35			 
af35				; test if true 
af35			 
af35 cd 86 8a			call ishlzero 
af38			;	ld a,l 
af38			;	add h 
af38			; 
af38			;	cp 0 
af38			 
af38 20 3e			jr nz, .untilnotdone 
af3a			 
af3a					if DEBUG_FORTH_WORDS 
af3a						DMARK "UNf" 
af3a f5				push af  
af3b 3a 4f af			ld a, (.dmark)  
af3e 32 7a ee			ld (debug_mark),a  
af41 3a 50 af			ld a, (.dmark+1)  
af44 32 7b ee			ld (debug_mark+1),a  
af47 3a 51 af			ld a, (.dmark+2)  
af4a 32 7c ee			ld (debug_mark+2),a  
af4d 18 03			jr .pastdmark  
af4f ..			.dmark: db "UNf"  
af52 f1			.pastdmark: pop af  
af53			endm  
# End of macro DMARK
af53						CALLMONITOR 
af53 cd 75 92			call break_point_state  
af56				endm  
# End of macro CALLMONITOR
af56					endif 
af56			 
af56			 
af56			 
af56				FORTH_RSP_POP     ; get rid of DO ptr 
af56 cd d7 97			call macro_forth_rsp_pop 
af59				endm 
# End of macro FORTH_RSP_POP
af59			 
af59			if DEBUG_FORTH_WORDS 
af59						DMARK "UN>" 
af59 f5				push af  
af5a 3a 6e af			ld a, (.dmark)  
af5d 32 7a ee			ld (debug_mark),a  
af60 3a 6f af			ld a, (.dmark+1)  
af63 32 7b ee			ld (debug_mark+1),a  
af66 3a 70 af			ld a, (.dmark+2)  
af69 32 7c ee			ld (debug_mark+2),a  
af6c 18 03			jr .pastdmark  
af6e ..			.dmark: db "UN>"  
af71 f1			.pastdmark: pop af  
af72			endm  
# End of macro DMARK
af72				CALLMONITOR 
af72 cd 75 92			call break_point_state  
af75				endm  
# End of macro CALLMONITOR
af75			endif 
af75			 
af75					NEXTW 
af75 c3 00 9a			jp macro_next 
af78				endm 
# End of macro NEXTW
af78				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af78			 
af78			.untilnotdone: 
af78			 
af78			 
af78			;	; get DO ptr 
af78			; 
af78				FORTH_RSP_TOS 
af78 cd cd 97			call macro_forth_rsp_tos 
af7b				endm 
# End of macro FORTH_RSP_TOS
af7b			 
af7b				;push hl 
af7b			 
af7b				; not going to DO any more 
af7b				; get rid of the RSP pointer as DO will add it back in 
af7b				;FORTH_RSP_POP 
af7b				;pop hl 
af7b			 
af7b			 
af7b 22 76 e6			ld (os_tok_ptr), hl 
af7e					if DEBUG_FORTH_WORDS 
af7e						DMARK "UN<" 
af7e f5				push af  
af7f 3a 93 af			ld a, (.dmark)  
af82 32 7a ee			ld (debug_mark),a  
af85 3a 94 af			ld a, (.dmark+1)  
af88 32 7b ee			ld (debug_mark+1),a  
af8b 3a 95 af			ld a, (.dmark+2)  
af8e 32 7c ee			ld (debug_mark+2),a  
af91 18 03			jr .pastdmark  
af93 ..			.dmark: db "UN<"  
af96 f1			.pastdmark: pop af  
af97			endm  
# End of macro DMARK
af97					CALLMONITOR 
af97 cd 75 92			call break_point_state  
af9a				endm  
# End of macro CALLMONITOR
af9a				endif 
af9a c3 91 9a			jp exec1 
af9d			 
af9d					 
af9d			 
af9d			 
af9d					NEXTW 
af9d c3 00 9a			jp macro_next 
afa0				endm 
# End of macro NEXTW
afa0			 
afa0			 
afa0			.ENDFLOW: 
afa0			 
afa0			; eof 
afa0			 
# End of file forth_words_flow.asm
afa0			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
afa0			include "forth_words_logic.asm" 
afa0			 
afa0			; | ## Logic Words 
afa0			 
afa0			.NOT: 
afa0				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
afa0 2d				db WORD_SYS_CORE+25             
afa1 e8 af			dw .IS            
afa3 04				db 3 + 1 
afa4 .. 00			db "NOT",0              
afa8				endm 
# End of macro CWHEAD
afa8			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
afa8					if DEBUG_FORTH_WORDS_KEY 
afa8						DMARK "NOT" 
afa8 f5				push af  
afa9 3a bd af			ld a, (.dmark)  
afac 32 7a ee			ld (debug_mark),a  
afaf 3a be af			ld a, (.dmark+1)  
afb2 32 7b ee			ld (debug_mark+1),a  
afb5 3a bf af			ld a, (.dmark+2)  
afb8 32 7c ee			ld (debug_mark+2),a  
afbb 18 03			jr .pastdmark  
afbd ..			.dmark: db "NOT"  
afc0 f1			.pastdmark: pop af  
afc1			endm  
# End of macro DMARK
afc1						CALLMONITOR 
afc1 cd 75 92			call break_point_state  
afc4				endm  
# End of macro CALLMONITOR
afc4					endif 
afc4					FORTH_DSP 
afc4 cd 8f 98			call macro_forth_dsp 
afc7				endm 
# End of macro FORTH_DSP
afc7 7e					ld a,(hl)	; get type of value on TOS 
afc8 fe 02				cp DS_TYPE_INUM  
afca 28 03				jr z, .noti 
afcc					NEXTW 
afcc c3 00 9a			jp macro_next 
afcf				endm 
# End of macro NEXTW
afcf			.noti:          FORTH_DSP_VALUEHL 
afcf cd aa 98			call macro_dsp_valuehl 
afd2				endm 
# End of macro FORTH_DSP_VALUEHL
afd2			;		push hl 
afd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
afd2 cd 46 99			call macro_forth_dsp_pop 
afd5				endm 
# End of macro FORTH_DSP_POP
afd5			;		pop hl 
afd5 3e 00				ld a,0 
afd7 bd					cp l 
afd8 28 04				jr z, .not2t 
afda 2e 00				ld l, 0 
afdc 18 02				jr .notip 
afde			 
afde 2e ff		.not2t:		ld l, 255 
afe0			 
afe0 26 00		.notip:		ld h, 0	 
afe2			 
afe2 cd 0f 98				call forth_push_numhl 
afe5					NEXTW 
afe5 c3 00 9a			jp macro_next 
afe8				endm 
# End of macro NEXTW
afe8			 
afe8			.IS: 
afe8				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
afe8 2d				db WORD_SYS_CORE+25             
afe9 0e b0			dw .LZERO            
afeb 03				db 2 + 1 
afec .. 00			db "IS",0              
afef				endm 
# End of macro CWHEAD
afef			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
afef					if DEBUG_FORTH_WORDS_KEY 
afef						DMARK "IS." 
afef f5				push af  
aff0 3a 04 b0			ld a, (.dmark)  
aff3 32 7a ee			ld (debug_mark),a  
aff6 3a 05 b0			ld a, (.dmark+1)  
aff9 32 7b ee			ld (debug_mark+1),a  
affc 3a 06 b0			ld a, (.dmark+2)  
afff 32 7c ee			ld (debug_mark+2),a  
b002 18 03			jr .pastdmark  
b004 ..			.dmark: db "IS."  
b007 f1			.pastdmark: pop af  
b008			endm  
# End of macro DMARK
b008						CALLMONITOR 
b008 cd 75 92			call break_point_state  
b00b				endm  
# End of macro CALLMONITOR
b00b					endif 
b00b					NEXTW 
b00b c3 00 9a			jp macro_next 
b00e				endm 
# End of macro NEXTW
b00e			.LZERO: 
b00e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b00e 2d				db WORD_SYS_CORE+25             
b00f 18 b0			dw .TZERO            
b011 03				db 2 + 1 
b012 .. 00			db "0<",0              
b015				endm 
# End of macro CWHEAD
b015			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b015					NEXTW 
b015 c3 00 9a			jp macro_next 
b018				endm 
# End of macro NEXTW
b018			.TZERO: 
b018				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b018 2e				db WORD_SYS_CORE+26             
b019 5f b0			dw .LESS            
b01b 03				db 2 + 1 
b01c .. 00			db "0=",0              
b01f				endm 
# End of macro CWHEAD
b01f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b01f				; TODO add floating point number detection 
b01f					;v5 FORTH_DSP_VALUE 
b01f					if DEBUG_FORTH_WORDS_KEY 
b01f						DMARK "0=." 
b01f f5				push af  
b020 3a 34 b0			ld a, (.dmark)  
b023 32 7a ee			ld (debug_mark),a  
b026 3a 35 b0			ld a, (.dmark+1)  
b029 32 7b ee			ld (debug_mark+1),a  
b02c 3a 36 b0			ld a, (.dmark+2)  
b02f 32 7c ee			ld (debug_mark+2),a  
b032 18 03			jr .pastdmark  
b034 ..			.dmark: db "0=."  
b037 f1			.pastdmark: pop af  
b038			endm  
# End of macro DMARK
b038						CALLMONITOR 
b038 cd 75 92			call break_point_state  
b03b				endm  
# End of macro CALLMONITOR
b03b					endif 
b03b					FORTH_DSP 
b03b cd 8f 98			call macro_forth_dsp 
b03e				endm 
# End of macro FORTH_DSP
b03e 7e					ld a,(hl)	; get type of value on TOS 
b03f fe 02				cp DS_TYPE_INUM  
b041 28 00				jr z, .tz_inum 
b043			 
b043				if FORTH_ENABLE_FLOATMATH 
b043					jr .tz_done 
b043			 
b043				endif 
b043					 
b043			 
b043			.tz_inum: 
b043					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b043 cd aa 98			call macro_dsp_valuehl 
b046				endm 
# End of macro FORTH_DSP_VALUEHL
b046			 
b046			;		push hl 
b046			 
b046					; destroy value TOS 
b046			 
b046					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b046 cd 46 99			call macro_forth_dsp_pop 
b049				endm 
# End of macro FORTH_DSP_POP
b049			 
b049			;		pop hl 
b049			 
b049 3e 00				ld a,0 
b04b			 
b04b bd					cp l 
b04c 20 08				jr nz, .tz_notzero 
b04e			 
b04e bc					cp h 
b04f			 
b04f 20 05				jr nz, .tz_notzero 
b051			 
b051			 
b051 21 01 00				ld hl, FORTH_TRUE 
b054 18 03				jr .tz_done 
b056			 
b056 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b059			 
b059					; push value back onto stack for another op etc 
b059			 
b059			.tz_done: 
b059 cd 0f 98				call forth_push_numhl 
b05c			 
b05c					NEXTW 
b05c c3 00 9a			jp macro_next 
b05f				endm 
# End of macro NEXTW
b05f			.LESS: 
b05f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b05f 2f				db WORD_SYS_CORE+27             
b060 c8 b0			dw .GT            
b062 02				db 1 + 1 
b063 .. 00			db "<",0              
b065				endm 
# End of macro CWHEAD
b065			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b065				; TODO add floating point number detection 
b065					if DEBUG_FORTH_WORDS_KEY 
b065						DMARK "LES" 
b065 f5				push af  
b066 3a 7a b0			ld a, (.dmark)  
b069 32 7a ee			ld (debug_mark),a  
b06c 3a 7b b0			ld a, (.dmark+1)  
b06f 32 7b ee			ld (debug_mark+1),a  
b072 3a 7c b0			ld a, (.dmark+2)  
b075 32 7c ee			ld (debug_mark+2),a  
b078 18 03			jr .pastdmark  
b07a ..			.dmark: db "LES"  
b07d f1			.pastdmark: pop af  
b07e			endm  
# End of macro DMARK
b07e						CALLMONITOR 
b07e cd 75 92			call break_point_state  
b081				endm  
# End of macro CALLMONITOR
b081					endif 
b081					FORTH_DSP 
b081 cd 8f 98			call macro_forth_dsp 
b084				endm 
# End of macro FORTH_DSP
b084					;v5 FORTH_DSP_VALUE 
b084 7e					ld a,(hl)	; get type of value on TOS 
b085 fe 02				cp DS_TYPE_INUM  
b087 28 00				jr z, .less_inum 
b089			 
b089				if FORTH_ENABLE_FLOATMATH 
b089					jr .less_done 
b089			 
b089				endif 
b089					 
b089			 
b089			.less_inum: 
b089					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b089 cd aa 98			call macro_dsp_valuehl 
b08c				endm 
# End of macro FORTH_DSP_VALUEHL
b08c			 
b08c e5					push hl  ; u2 
b08d			 
b08d					; destroy value TOS 
b08d			 
b08d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b08d cd 46 99			call macro_forth_dsp_pop 
b090				endm 
# End of macro FORTH_DSP_POP
b090			 
b090			 
b090					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b090 cd aa 98			call macro_dsp_valuehl 
b093				endm 
# End of macro FORTH_DSP_VALUEHL
b093			 
b093 e5					push hl    ; u1 
b094			 
b094					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b094 cd 46 99			call macro_forth_dsp_pop 
b097				endm 
# End of macro FORTH_DSP_POP
b097			 
b097			 
b097 b7			 or a      ;clear carry flag 
b098 01 00 00		 ld bc, FORTH_FALSE 
b09b e1			  pop hl    ; u1 
b09c d1			  pop de    ; u2 
b09d ed 52		  sbc hl,de 
b09f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b0a1			 
b0a1 01 01 00		 ld bc, FORTH_TRUE 
b0a4			.lscont:  
b0a4 c5					push bc 
b0a5 e1					pop hl 
b0a6			 
b0a6					if DEBUG_FORTH_WORDS 
b0a6						DMARK "LT1" 
b0a6 f5				push af  
b0a7 3a bb b0			ld a, (.dmark)  
b0aa 32 7a ee			ld (debug_mark),a  
b0ad 3a bc b0			ld a, (.dmark+1)  
b0b0 32 7b ee			ld (debug_mark+1),a  
b0b3 3a bd b0			ld a, (.dmark+2)  
b0b6 32 7c ee			ld (debug_mark+2),a  
b0b9 18 03			jr .pastdmark  
b0bb ..			.dmark: db "LT1"  
b0be f1			.pastdmark: pop af  
b0bf			endm  
# End of macro DMARK
b0bf						CALLMONITOR 
b0bf cd 75 92			call break_point_state  
b0c2				endm  
# End of macro CALLMONITOR
b0c2					endif 
b0c2 cd 0f 98				call forth_push_numhl 
b0c5			 
b0c5					NEXTW 
b0c5 c3 00 9a			jp macro_next 
b0c8				endm 
# End of macro NEXTW
b0c8			.GT: 
b0c8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b0c8 30				db WORD_SYS_CORE+28             
b0c9 31 b1			dw .EQUAL            
b0cb 02				db 1 + 1 
b0cc .. 00			db ">",0              
b0ce				endm 
# End of macro CWHEAD
b0ce			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b0ce				; TODO add floating point number detection 
b0ce					if DEBUG_FORTH_WORDS_KEY 
b0ce						DMARK "GRT" 
b0ce f5				push af  
b0cf 3a e3 b0			ld a, (.dmark)  
b0d2 32 7a ee			ld (debug_mark),a  
b0d5 3a e4 b0			ld a, (.dmark+1)  
b0d8 32 7b ee			ld (debug_mark+1),a  
b0db 3a e5 b0			ld a, (.dmark+2)  
b0de 32 7c ee			ld (debug_mark+2),a  
b0e1 18 03			jr .pastdmark  
b0e3 ..			.dmark: db "GRT"  
b0e6 f1			.pastdmark: pop af  
b0e7			endm  
# End of macro DMARK
b0e7						CALLMONITOR 
b0e7 cd 75 92			call break_point_state  
b0ea				endm  
# End of macro CALLMONITOR
b0ea					endif 
b0ea					FORTH_DSP 
b0ea cd 8f 98			call macro_forth_dsp 
b0ed				endm 
# End of macro FORTH_DSP
b0ed					;FORTH_DSP_VALUE 
b0ed 7e					ld a,(hl)	; get type of value on TOS 
b0ee fe 02				cp DS_TYPE_INUM  
b0f0 28 00				jr z, .gt_inum 
b0f2			 
b0f2				if FORTH_ENABLE_FLOATMATH 
b0f2					jr .gt_done 
b0f2			 
b0f2				endif 
b0f2					 
b0f2			 
b0f2			.gt_inum: 
b0f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0f2 cd aa 98			call macro_dsp_valuehl 
b0f5				endm 
# End of macro FORTH_DSP_VALUEHL
b0f5			 
b0f5 e5					push hl  ; u2 
b0f6			 
b0f6					; destroy value TOS 
b0f6			 
b0f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0f6 cd 46 99			call macro_forth_dsp_pop 
b0f9				endm 
# End of macro FORTH_DSP_POP
b0f9			 
b0f9			 
b0f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0f9 cd aa 98			call macro_dsp_valuehl 
b0fc				endm 
# End of macro FORTH_DSP_VALUEHL
b0fc			 
b0fc e5					push hl    ; u1 
b0fd			 
b0fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0fd cd 46 99			call macro_forth_dsp_pop 
b100				endm 
# End of macro FORTH_DSP_POP
b100			 
b100			 
b100 b7			 or a      ;clear carry flag 
b101 01 00 00		 ld bc, FORTH_FALSE 
b104 e1			  pop hl    ; u1 
b105 d1			  pop de    ; u2 
b106 ed 52		  sbc hl,de 
b108 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b10a			 
b10a 01 01 00		 ld bc, FORTH_TRUE 
b10d			.gtcont:  
b10d c5					push bc 
b10e e1					pop hl 
b10f			 
b10f					if DEBUG_FORTH_WORDS 
b10f						DMARK "GT1" 
b10f f5				push af  
b110 3a 24 b1			ld a, (.dmark)  
b113 32 7a ee			ld (debug_mark),a  
b116 3a 25 b1			ld a, (.dmark+1)  
b119 32 7b ee			ld (debug_mark+1),a  
b11c 3a 26 b1			ld a, (.dmark+2)  
b11f 32 7c ee			ld (debug_mark+2),a  
b122 18 03			jr .pastdmark  
b124 ..			.dmark: db "GT1"  
b127 f1			.pastdmark: pop af  
b128			endm  
# End of macro DMARK
b128						CALLMONITOR 
b128 cd 75 92			call break_point_state  
b12b				endm  
# End of macro CALLMONITOR
b12b					endif 
b12b cd 0f 98				call forth_push_numhl 
b12e			 
b12e					NEXTW 
b12e c3 00 9a			jp macro_next 
b131				endm 
# End of macro NEXTW
b131			.EQUAL: 
b131				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b131 31				db WORD_SYS_CORE+29             
b132 9c b1			dw .ENDLOGIC            
b134 02				db 1 + 1 
b135 .. 00			db "=",0              
b137				endm 
# End of macro CWHEAD
b137			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b137				; TODO add floating point number detection 
b137					if DEBUG_FORTH_WORDS_KEY 
b137						DMARK "EQ." 
b137 f5				push af  
b138 3a 4c b1			ld a, (.dmark)  
b13b 32 7a ee			ld (debug_mark),a  
b13e 3a 4d b1			ld a, (.dmark+1)  
b141 32 7b ee			ld (debug_mark+1),a  
b144 3a 4e b1			ld a, (.dmark+2)  
b147 32 7c ee			ld (debug_mark+2),a  
b14a 18 03			jr .pastdmark  
b14c ..			.dmark: db "EQ."  
b14f f1			.pastdmark: pop af  
b150			endm  
# End of macro DMARK
b150						CALLMONITOR 
b150 cd 75 92			call break_point_state  
b153				endm  
# End of macro CALLMONITOR
b153					endif 
b153					FORTH_DSP 
b153 cd 8f 98			call macro_forth_dsp 
b156				endm 
# End of macro FORTH_DSP
b156					;v5 FORTH_DSP_VALUE 
b156 7e					ld a,(hl)	; get type of value on TOS 
b157 fe 02				cp DS_TYPE_INUM  
b159 28 00				jr z, .eq_inum 
b15b			 
b15b				if FORTH_ENABLE_FLOATMATH 
b15b					jr .eq_done 
b15b			 
b15b				endif 
b15b					 
b15b			 
b15b			.eq_inum: 
b15b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b15b cd aa 98			call macro_dsp_valuehl 
b15e				endm 
# End of macro FORTH_DSP_VALUEHL
b15e			 
b15e e5					push hl 
b15f			 
b15f					; destroy value TOS 
b15f			 
b15f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b15f cd 46 99			call macro_forth_dsp_pop 
b162				endm 
# End of macro FORTH_DSP_POP
b162			 
b162			 
b162					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b162 cd aa 98			call macro_dsp_valuehl 
b165				endm 
# End of macro FORTH_DSP_VALUEHL
b165			 
b165					; one value on hl get other one back 
b165			 
b165 e5					push hl 
b166			 
b166					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b166 cd 46 99			call macro_forth_dsp_pop 
b169				endm 
# End of macro FORTH_DSP_POP
b169			 
b169 0e 00				ld c, FORTH_FALSE 
b16b			 
b16b e1					pop hl 
b16c d1					pop de 
b16d			 
b16d 7b					ld a, e 
b16e bd					cp l 
b16f			 
b16f 20 06				jr nz, .eq_done 
b171			 
b171 7a					ld a, d 
b172 bc					cp h 
b173			 
b173 20 02				jr nz, .eq_done 
b175			 
b175 0e 01				ld c, FORTH_TRUE 
b177					 
b177			 
b177			 
b177			.eq_done: 
b177			 
b177					; TODO push value back onto stack for another op etc 
b177			 
b177 26 00				ld h, 0 
b179 69					ld l, c 
b17a					if DEBUG_FORTH_WORDS 
b17a						DMARK "EQ1" 
b17a f5				push af  
b17b 3a 8f b1			ld a, (.dmark)  
b17e 32 7a ee			ld (debug_mark),a  
b181 3a 90 b1			ld a, (.dmark+1)  
b184 32 7b ee			ld (debug_mark+1),a  
b187 3a 91 b1			ld a, (.dmark+2)  
b18a 32 7c ee			ld (debug_mark+2),a  
b18d 18 03			jr .pastdmark  
b18f ..			.dmark: db "EQ1"  
b192 f1			.pastdmark: pop af  
b193			endm  
# End of macro DMARK
b193						CALLMONITOR 
b193 cd 75 92			call break_point_state  
b196				endm  
# End of macro CALLMONITOR
b196					endif 
b196 cd 0f 98				call forth_push_numhl 
b199			 
b199					NEXTW 
b199 c3 00 9a			jp macro_next 
b19c				endm 
# End of macro NEXTW
b19c			 
b19c			 
b19c			.ENDLOGIC: 
b19c			; eof 
b19c			 
b19c			 
# End of file forth_words_logic.asm
b19c			include "forth_words_maths.asm" 
b19c			 
b19c			; | ## Maths Words 
b19c			 
b19c			.PLUS:	 
b19c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b19c 15				db WORD_SYS_CORE+1             
b19d de b1			dw .NEG            
b19f 02				db 1 + 1 
b1a0 .. 00			db "+",0              
b1a2				endm 
# End of macro CWHEAD
b1a2			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b1a2					if DEBUG_FORTH_WORDS_KEY 
b1a2						DMARK "PLU" 
b1a2 f5				push af  
b1a3 3a b7 b1			ld a, (.dmark)  
b1a6 32 7a ee			ld (debug_mark),a  
b1a9 3a b8 b1			ld a, (.dmark+1)  
b1ac 32 7b ee			ld (debug_mark+1),a  
b1af 3a b9 b1			ld a, (.dmark+2)  
b1b2 32 7c ee			ld (debug_mark+2),a  
b1b5 18 03			jr .pastdmark  
b1b7 ..			.dmark: db "PLU"  
b1ba f1			.pastdmark: pop af  
b1bb			endm  
# End of macro DMARK
b1bb						CALLMONITOR 
b1bb cd 75 92			call break_point_state  
b1be				endm  
# End of macro CALLMONITOR
b1be					endif 
b1be					; add top two values and push back result 
b1be			 
b1be					;for v5 FORTH_DSP_VALUE 
b1be					FORTH_DSP 
b1be cd 8f 98			call macro_forth_dsp 
b1c1				endm 
# End of macro FORTH_DSP
b1c1 7e					ld a,(hl)	; get type of value on TOS 
b1c2 fe 02				cp DS_TYPE_INUM  
b1c4 28 03				jr z, .dot_inum 
b1c6			 
b1c6					NEXTW 
b1c6 c3 00 9a			jp macro_next 
b1c9				endm 
# End of macro NEXTW
b1c9			 
b1c9			; float maths 
b1c9			 
b1c9				if FORTH_ENABLE_FLOATMATH 
b1c9						inc hl      ; now at start of numeric as string 
b1c9			 
b1c9					if DEBUG_FORTH_MATHS 
b1c9						DMARK "ADD" 
b1c9				CALLMONITOR 
b1c9					endif 
b1c9			 
b1c9					;ld ix, hl 
b1c9					call CON 
b1c9			 
b1c9			 
b1c9					push hl 
b1c9					 
b1c9					 
b1c9			 
b1c9						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b1c9			 
b1c9					; get next number 
b1c9			 
b1c9						FORTH_DSP_VALUE 
b1c9			 
b1c9						inc hl      ; now at start of numeric as string 
b1c9			 
b1c9					;ld ix, hl 
b1c9					call CON 
b1c9			 
b1c9					push hl 
b1c9			 
b1c9			 
b1c9						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1c9			 
b1c9						; TODO do add 
b1c9			 
b1c9						call IADD 
b1c9			 
b1c9						; TODO get result back as ascii 
b1c9			 
b1c9						; TODO push result  
b1c9			 
b1c9			 
b1c9			 
b1c9						jr .dot_done 
b1c9				endif 
b1c9			 
b1c9			.dot_inum: 
b1c9			 
b1c9			 
b1c9					if DEBUG_FORTH_DOT 
b1c9						DMARK "+IT" 
b1c9				CALLMONITOR 
b1c9					endif 
b1c9			 
b1c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1c9 cd aa 98			call macro_dsp_valuehl 
b1cc				endm 
# End of macro FORTH_DSP_VALUEHL
b1cc			 
b1cc				; TODO add floating point number detection 
b1cc			 
b1cc e5					push hl 
b1cd			 
b1cd					; destroy value TOS 
b1cd			 
b1cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1cd cd 46 99			call macro_forth_dsp_pop 
b1d0				endm 
# End of macro FORTH_DSP_POP
b1d0			 
b1d0			 
b1d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1d0 cd aa 98			call macro_dsp_valuehl 
b1d3				endm 
# End of macro FORTH_DSP_VALUEHL
b1d3			 
b1d3					; one value on hl get other one back 
b1d3			 
b1d3 d1					pop de 
b1d4			 
b1d4					; do the add 
b1d4			 
b1d4 19					add hl,de 
b1d5			 
b1d5					; save it 
b1d5			 
b1d5			;		push hl	 
b1d5			 
b1d5					; 
b1d5			 
b1d5					; destroy value TOS 
b1d5			 
b1d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1d5 cd 46 99			call macro_forth_dsp_pop 
b1d8				endm 
# End of macro FORTH_DSP_POP
b1d8			 
b1d8					; TODO push value back onto stack for another op etc 
b1d8			 
b1d8			;		pop hl 
b1d8			 
b1d8			.dot_done: 
b1d8 cd 0f 98				call forth_push_numhl 
b1db			 
b1db					NEXTW 
b1db c3 00 9a			jp macro_next 
b1de				endm 
# End of macro NEXTW
b1de			.NEG: 
b1de			 
b1de				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b1de 17				db WORD_SYS_CORE+3             
b1df 21 b2			dw .DIV            
b1e1 02				db 1 + 1 
b1e2 .. 00			db "-",0              
b1e4				endm 
# End of macro CWHEAD
b1e4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b1e4					if DEBUG_FORTH_WORDS_KEY 
b1e4						DMARK "SUB" 
b1e4 f5				push af  
b1e5 3a f9 b1			ld a, (.dmark)  
b1e8 32 7a ee			ld (debug_mark),a  
b1eb 3a fa b1			ld a, (.dmark+1)  
b1ee 32 7b ee			ld (debug_mark+1),a  
b1f1 3a fb b1			ld a, (.dmark+2)  
b1f4 32 7c ee			ld (debug_mark+2),a  
b1f7 18 03			jr .pastdmark  
b1f9 ..			.dmark: db "SUB"  
b1fc f1			.pastdmark: pop af  
b1fd			endm  
# End of macro DMARK
b1fd						CALLMONITOR 
b1fd cd 75 92			call break_point_state  
b200				endm  
# End of macro CALLMONITOR
b200					endif 
b200			 
b200			 
b200				; TODO add floating point number detection 
b200					; v5 FORTH_DSP_VALUE 
b200					FORTH_DSP 
b200 cd 8f 98			call macro_forth_dsp 
b203				endm 
# End of macro FORTH_DSP
b203 7e					ld a,(hl)	; get type of value on TOS 
b204 fe 02				cp DS_TYPE_INUM  
b206 28 03				jr z, .neg_inum 
b208			 
b208					NEXTW 
b208 c3 00 9a			jp macro_next 
b20b				endm 
# End of macro NEXTW
b20b			 
b20b			; float maths 
b20b			 
b20b				if FORTH_ENABLE_FLOATMATH 
b20b					jr .neg_done 
b20b			 
b20b				endif 
b20b					 
b20b			 
b20b			.neg_inum: 
b20b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b20b cd aa 98			call macro_dsp_valuehl 
b20e				endm 
# End of macro FORTH_DSP_VALUEHL
b20e			 
b20e e5					push hl 
b20f			 
b20f					; destroy value TOS 
b20f			 
b20f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b20f cd 46 99			call macro_forth_dsp_pop 
b212				endm 
# End of macro FORTH_DSP_POP
b212			 
b212			 
b212					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b212 cd aa 98			call macro_dsp_valuehl 
b215				endm 
# End of macro FORTH_DSP_VALUEHL
b215			 
b215					; one value on hl get other one back 
b215			 
b215 d1					pop de 
b216			 
b216					; do the sub 
b216			;		ex de, hl 
b216			 
b216 ed 52				sbc hl,de 
b218			 
b218					; save it 
b218			 
b218			;		push hl	 
b218			 
b218					; 
b218			 
b218					; destroy value TOS 
b218			 
b218					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b218 cd 46 99			call macro_forth_dsp_pop 
b21b				endm 
# End of macro FORTH_DSP_POP
b21b			 
b21b					; TODO push value back onto stack for another op etc 
b21b			 
b21b			;		pop hl 
b21b			 
b21b cd 0f 98				call forth_push_numhl 
b21e			.neg_done: 
b21e			 
b21e					NEXTW 
b21e c3 00 9a			jp macro_next 
b221				endm 
# End of macro NEXTW
b221			.DIV: 
b221				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b221 18				db WORD_SYS_CORE+4             
b222 6e b2			dw .MUL            
b224 02				db 1 + 1 
b225 .. 00			db "/",0              
b227				endm 
# End of macro CWHEAD
b227			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b227					if DEBUG_FORTH_WORDS_KEY 
b227						DMARK "DIV" 
b227 f5				push af  
b228 3a 3c b2			ld a, (.dmark)  
b22b 32 7a ee			ld (debug_mark),a  
b22e 3a 3d b2			ld a, (.dmark+1)  
b231 32 7b ee			ld (debug_mark+1),a  
b234 3a 3e b2			ld a, (.dmark+2)  
b237 32 7c ee			ld (debug_mark+2),a  
b23a 18 03			jr .pastdmark  
b23c ..			.dmark: db "DIV"  
b23f f1			.pastdmark: pop af  
b240			endm  
# End of macro DMARK
b240						CALLMONITOR 
b240 cd 75 92			call break_point_state  
b243				endm  
# End of macro CALLMONITOR
b243					endif 
b243				; TODO add floating point number detection 
b243					; v5 FORTH_DSP_VALUE 
b243					FORTH_DSP 
b243 cd 8f 98			call macro_forth_dsp 
b246				endm 
# End of macro FORTH_DSP
b246 7e					ld a,(hl)	; get type of value on TOS 
b247 fe 02				cp DS_TYPE_INUM  
b249 28 03				jr z, .div_inum 
b24b			 
b24b				if FORTH_ENABLE_FLOATMATH 
b24b					jr .div_done 
b24b			 
b24b				endif 
b24b					NEXTW 
b24b c3 00 9a			jp macro_next 
b24e				endm 
# End of macro NEXTW
b24e			.div_inum: 
b24e			 
b24e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b24e cd aa 98			call macro_dsp_valuehl 
b251				endm 
# End of macro FORTH_DSP_VALUEHL
b251			 
b251 e5					push hl    ; to go to bc 
b252			 
b252					; destroy value TOS 
b252			 
b252					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b252 cd 46 99			call macro_forth_dsp_pop 
b255				endm 
# End of macro FORTH_DSP_POP
b255			 
b255			 
b255					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b255 cd aa 98			call macro_dsp_valuehl 
b258				endm 
# End of macro FORTH_DSP_VALUEHL
b258			 
b258					; hl to go to de 
b258			 
b258 e5					push hl 
b259			 
b259 c1					pop bc 
b25a d1					pop de		 
b25b			 
b25b			 
b25b					if DEBUG_FORTH_MATHS 
b25b						DMARK "DIV" 
b25b				CALLMONITOR 
b25b					endif 
b25b					; one value on hl but move to a get other one back 
b25b			 
b25b			        
b25b cd ba 89			call Div16 
b25e			 
b25e			;	push af	 
b25e e5				push hl 
b25f c5				push bc 
b260			 
b260					if DEBUG_FORTH_MATHS 
b260						DMARK "DI1" 
b260				CALLMONITOR 
b260					endif 
b260			 
b260					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b260 cd 46 99			call macro_forth_dsp_pop 
b263				endm 
# End of macro FORTH_DSP_POP
b263			 
b263			 
b263			 
b263 e1					pop hl    ; result 
b264			 
b264 cd 0f 98				call forth_push_numhl 
b267			 
b267 e1					pop hl    ; reminder 
b268			;		ld h,0 
b268			;		ld l,d 
b268			 
b268 cd 0f 98				call forth_push_numhl 
b26b			.div_done: 
b26b					NEXTW 
b26b c3 00 9a			jp macro_next 
b26e				endm 
# End of macro NEXTW
b26e			.MUL: 
b26e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b26e 19				db WORD_SYS_CORE+5             
b26f b3 b2			dw .MIN            
b271 02				db 1 + 1 
b272 .. 00			db "*",0              
b274				endm 
# End of macro CWHEAD
b274			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b274				; TODO add floating point number detection 
b274					if DEBUG_FORTH_WORDS_KEY 
b274						DMARK "MUL" 
b274 f5				push af  
b275 3a 89 b2			ld a, (.dmark)  
b278 32 7a ee			ld (debug_mark),a  
b27b 3a 8a b2			ld a, (.dmark+1)  
b27e 32 7b ee			ld (debug_mark+1),a  
b281 3a 8b b2			ld a, (.dmark+2)  
b284 32 7c ee			ld (debug_mark+2),a  
b287 18 03			jr .pastdmark  
b289 ..			.dmark: db "MUL"  
b28c f1			.pastdmark: pop af  
b28d			endm  
# End of macro DMARK
b28d						CALLMONITOR 
b28d cd 75 92			call break_point_state  
b290				endm  
# End of macro CALLMONITOR
b290					endif 
b290					FORTH_DSP 
b290 cd 8f 98			call macro_forth_dsp 
b293				endm 
# End of macro FORTH_DSP
b293					; v5 FORTH_DSP_VALUE 
b293 7e					ld a,(hl)	; get type of value on TOS 
b294 fe 02				cp DS_TYPE_INUM  
b296 28 03				jr z, .mul_inum 
b298			 
b298				if FORTH_ENABLE_FLOATMATH 
b298					jr .mul_done 
b298			 
b298				endif 
b298			 
b298					NEXTW 
b298 c3 00 9a			jp macro_next 
b29b				endm 
# End of macro NEXTW
b29b			.mul_inum:	 
b29b			 
b29b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b29b cd aa 98			call macro_dsp_valuehl 
b29e				endm 
# End of macro FORTH_DSP_VALUEHL
b29e			 
b29e e5					push hl 
b29f			 
b29f					; destroy value TOS 
b29f			 
b29f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b29f cd 46 99			call macro_forth_dsp_pop 
b2a2				endm 
# End of macro FORTH_DSP_POP
b2a2			 
b2a2			 
b2a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2a2 cd aa 98			call macro_dsp_valuehl 
b2a5				endm 
# End of macro FORTH_DSP_VALUEHL
b2a5			 
b2a5					; one value on hl but move to a get other one back 
b2a5			 
b2a5 7d					ld a, l 
b2a6			 
b2a6 d1					pop de 
b2a7			 
b2a7					; do the mull 
b2a7			;		ex de, hl 
b2a7			 
b2a7 cd e0 89				call Mult16 
b2aa					; save it 
b2aa			 
b2aa			;		push hl	 
b2aa			 
b2aa					; 
b2aa			 
b2aa					; destroy value TOS 
b2aa			 
b2aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2aa cd 46 99			call macro_forth_dsp_pop 
b2ad				endm 
# End of macro FORTH_DSP_POP
b2ad			 
b2ad					; TODO push value back onto stack for another op etc 
b2ad			 
b2ad			;		pop hl 
b2ad			 
b2ad cd 0f 98				call forth_push_numhl 
b2b0			 
b2b0			.mul_done: 
b2b0					NEXTW 
b2b0 c3 00 9a			jp macro_next 
b2b3				endm 
# End of macro NEXTW
b2b3			 
b2b3			 
b2b3			 
b2b3			 
b2b3			.MIN: 
b2b3				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b2b3 49				db WORD_SYS_CORE+53             
b2b4 34 b3			dw .MAX            
b2b6 04				db 3 + 1 
b2b7 .. 00			db "MIN",0              
b2bb				endm 
# End of macro CWHEAD
b2bb			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b2bb					if DEBUG_FORTH_WORDS_KEY 
b2bb						DMARK "MIN" 
b2bb f5				push af  
b2bc 3a d0 b2			ld a, (.dmark)  
b2bf 32 7a ee			ld (debug_mark),a  
b2c2 3a d1 b2			ld a, (.dmark+1)  
b2c5 32 7b ee			ld (debug_mark+1),a  
b2c8 3a d2 b2			ld a, (.dmark+2)  
b2cb 32 7c ee			ld (debug_mark+2),a  
b2ce 18 03			jr .pastdmark  
b2d0 ..			.dmark: db "MIN"  
b2d3 f1			.pastdmark: pop af  
b2d4			endm  
# End of macro DMARK
b2d4						CALLMONITOR 
b2d4 cd 75 92			call break_point_state  
b2d7				endm  
# End of macro CALLMONITOR
b2d7					endif 
b2d7					; get u2 
b2d7			 
b2d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2d7 cd aa 98			call macro_dsp_valuehl 
b2da				endm 
# End of macro FORTH_DSP_VALUEHL
b2da			 
b2da e5					push hl   ; u2 
b2db			 
b2db					; destroy value TOS 
b2db			 
b2db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2db cd 46 99			call macro_forth_dsp_pop 
b2de				endm 
# End of macro FORTH_DSP_POP
b2de			 
b2de					; get u1 
b2de			 
b2de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2de cd aa 98			call macro_dsp_valuehl 
b2e1				endm 
# End of macro FORTH_DSP_VALUEHL
b2e1			 
b2e1 e5					push hl  ; u1 
b2e2			 
b2e2					; destroy value TOS 
b2e2			 
b2e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2e2 cd 46 99			call macro_forth_dsp_pop 
b2e5				endm 
# End of macro FORTH_DSP_POP
b2e5			 
b2e5 b7			 or a      ;clear carry flag 
b2e6 e1			  pop hl    ; u1 
b2e7 d1			  pop de    ; u2 
b2e8 e5				push hl   ; saved in case hl is lowest 
b2e9 ed 52		  sbc hl,de 
b2eb 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b2ed			 
b2ed e1				pop hl 
b2ee					if DEBUG_FORTH_WORDS 
b2ee						DMARK "MIN" 
b2ee f5				push af  
b2ef 3a 03 b3			ld a, (.dmark)  
b2f2 32 7a ee			ld (debug_mark),a  
b2f5 3a 04 b3			ld a, (.dmark+1)  
b2f8 32 7b ee			ld (debug_mark+1),a  
b2fb 3a 05 b3			ld a, (.dmark+2)  
b2fe 32 7c ee			ld (debug_mark+2),a  
b301 18 03			jr .pastdmark  
b303 ..			.dmark: db "MIN"  
b306 f1			.pastdmark: pop af  
b307			endm  
# End of macro DMARK
b307						CALLMONITOR 
b307 cd 75 92			call break_point_state  
b30a				endm  
# End of macro CALLMONITOR
b30a					endif 
b30a cd 0f 98				call forth_push_numhl 
b30d			 
b30d				       NEXTW 
b30d c3 00 9a			jp macro_next 
b310				endm 
# End of macro NEXTW
b310			 
b310			.mincont:  
b310 c1				pop bc   ; tidy up 
b311 eb				ex de , hl  
b312					if DEBUG_FORTH_WORDS 
b312						DMARK "MI1" 
b312 f5				push af  
b313 3a 27 b3			ld a, (.dmark)  
b316 32 7a ee			ld (debug_mark),a  
b319 3a 28 b3			ld a, (.dmark+1)  
b31c 32 7b ee			ld (debug_mark+1),a  
b31f 3a 29 b3			ld a, (.dmark+2)  
b322 32 7c ee			ld (debug_mark+2),a  
b325 18 03			jr .pastdmark  
b327 ..			.dmark: db "MI1"  
b32a f1			.pastdmark: pop af  
b32b			endm  
# End of macro DMARK
b32b						CALLMONITOR 
b32b cd 75 92			call break_point_state  
b32e				endm  
# End of macro CALLMONITOR
b32e					endif 
b32e cd 0f 98				call forth_push_numhl 
b331			 
b331				       NEXTW 
b331 c3 00 9a			jp macro_next 
b334				endm 
# End of macro NEXTW
b334			.MAX: 
b334				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b334 4a				db WORD_SYS_CORE+54             
b335 b5 b3			dw .RND16            
b337 04				db 3 + 1 
b338 .. 00			db "MAX",0              
b33c				endm 
# End of macro CWHEAD
b33c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b33c					if DEBUG_FORTH_WORDS_KEY 
b33c						DMARK "MAX" 
b33c f5				push af  
b33d 3a 51 b3			ld a, (.dmark)  
b340 32 7a ee			ld (debug_mark),a  
b343 3a 52 b3			ld a, (.dmark+1)  
b346 32 7b ee			ld (debug_mark+1),a  
b349 3a 53 b3			ld a, (.dmark+2)  
b34c 32 7c ee			ld (debug_mark+2),a  
b34f 18 03			jr .pastdmark  
b351 ..			.dmark: db "MAX"  
b354 f1			.pastdmark: pop af  
b355			endm  
# End of macro DMARK
b355						CALLMONITOR 
b355 cd 75 92			call break_point_state  
b358				endm  
# End of macro CALLMONITOR
b358					endif 
b358					; get u2 
b358			 
b358					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b358 cd aa 98			call macro_dsp_valuehl 
b35b				endm 
# End of macro FORTH_DSP_VALUEHL
b35b			 
b35b e5					push hl   ; u2 
b35c			 
b35c					; destroy value TOS 
b35c			 
b35c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b35c cd 46 99			call macro_forth_dsp_pop 
b35f				endm 
# End of macro FORTH_DSP_POP
b35f			 
b35f					; get u1 
b35f			 
b35f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b35f cd aa 98			call macro_dsp_valuehl 
b362				endm 
# End of macro FORTH_DSP_VALUEHL
b362			 
b362 e5					push hl  ; u1 
b363			 
b363					; destroy value TOS 
b363			 
b363					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b363 cd 46 99			call macro_forth_dsp_pop 
b366				endm 
# End of macro FORTH_DSP_POP
b366			 
b366 b7			 or a      ;clear carry flag 
b367 e1			  pop hl    ; u1 
b368 d1			  pop de    ; u2 
b369 e5				push hl   ; saved in case hl is lowest 
b36a ed 52		  sbc hl,de 
b36c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b36e			 
b36e e1				pop hl 
b36f					if DEBUG_FORTH_WORDS 
b36f						DMARK "MAX" 
b36f f5				push af  
b370 3a 84 b3			ld a, (.dmark)  
b373 32 7a ee			ld (debug_mark),a  
b376 3a 85 b3			ld a, (.dmark+1)  
b379 32 7b ee			ld (debug_mark+1),a  
b37c 3a 86 b3			ld a, (.dmark+2)  
b37f 32 7c ee			ld (debug_mark+2),a  
b382 18 03			jr .pastdmark  
b384 ..			.dmark: db "MAX"  
b387 f1			.pastdmark: pop af  
b388			endm  
# End of macro DMARK
b388						CALLMONITOR 
b388 cd 75 92			call break_point_state  
b38b				endm  
# End of macro CALLMONITOR
b38b					endif 
b38b cd 0f 98				call forth_push_numhl 
b38e			 
b38e				       NEXTW 
b38e c3 00 9a			jp macro_next 
b391				endm 
# End of macro NEXTW
b391			 
b391			.maxcont:  
b391 c1				pop bc   ; tidy up 
b392 eb				ex de , hl  
b393					if DEBUG_FORTH_WORDS 
b393						DMARK "MA1" 
b393 f5				push af  
b394 3a a8 b3			ld a, (.dmark)  
b397 32 7a ee			ld (debug_mark),a  
b39a 3a a9 b3			ld a, (.dmark+1)  
b39d 32 7b ee			ld (debug_mark+1),a  
b3a0 3a aa b3			ld a, (.dmark+2)  
b3a3 32 7c ee			ld (debug_mark+2),a  
b3a6 18 03			jr .pastdmark  
b3a8 ..			.dmark: db "MA1"  
b3ab f1			.pastdmark: pop af  
b3ac			endm  
# End of macro DMARK
b3ac						CALLMONITOR 
b3ac cd 75 92			call break_point_state  
b3af				endm  
# End of macro CALLMONITOR
b3af					endif 
b3af cd 0f 98				call forth_push_numhl 
b3b2				       NEXTW 
b3b2 c3 00 9a			jp macro_next 
b3b5				endm 
# End of macro NEXTW
b3b5			 
b3b5			.RND16: 
b3b5				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b3b5 4e				db WORD_SYS_CORE+58             
b3b6 e4 b3			dw .RND8            
b3b8 06				db 5 + 1 
b3b9 .. 00			db "RND16",0              
b3bf				endm 
# End of macro CWHEAD
b3bf			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b3bf					if DEBUG_FORTH_WORDS_KEY 
b3bf						DMARK "R16" 
b3bf f5				push af  
b3c0 3a d4 b3			ld a, (.dmark)  
b3c3 32 7a ee			ld (debug_mark),a  
b3c6 3a d5 b3			ld a, (.dmark+1)  
b3c9 32 7b ee			ld (debug_mark+1),a  
b3cc 3a d6 b3			ld a, (.dmark+2)  
b3cf 32 7c ee			ld (debug_mark+2),a  
b3d2 18 03			jr .pastdmark  
b3d4 ..			.dmark: db "R16"  
b3d7 f1			.pastdmark: pop af  
b3d8			endm  
# End of macro DMARK
b3d8						CALLMONITOR 
b3d8 cd 75 92			call break_point_state  
b3db				endm  
# End of macro CALLMONITOR
b3db					endif 
b3db cd 84 89				call prng16  
b3de cd 0f 98				call forth_push_numhl 
b3e1				       NEXTW 
b3e1 c3 00 9a			jp macro_next 
b3e4				endm 
# End of macro NEXTW
b3e4			.RND8: 
b3e4				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b3e4 60				db WORD_SYS_CORE+76             
b3e5 19 b4			dw .RND            
b3e7 05				db 4 + 1 
b3e8 .. 00			db "RND8",0              
b3ed				endm 
# End of macro CWHEAD
b3ed			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b3ed					if DEBUG_FORTH_WORDS_KEY 
b3ed						DMARK "RN8" 
b3ed f5				push af  
b3ee 3a 02 b4			ld a, (.dmark)  
b3f1 32 7a ee			ld (debug_mark),a  
b3f4 3a 03 b4			ld a, (.dmark+1)  
b3f7 32 7b ee			ld (debug_mark+1),a  
b3fa 3a 04 b4			ld a, (.dmark+2)  
b3fd 32 7c ee			ld (debug_mark+2),a  
b400 18 03			jr .pastdmark  
b402 ..			.dmark: db "RN8"  
b405 f1			.pastdmark: pop af  
b406			endm  
# End of macro DMARK
b406						CALLMONITOR 
b406 cd 75 92			call break_point_state  
b409				endm  
# End of macro CALLMONITOR
b409					endif 
b409 2a bb eb				ld hl,(xrandc) 
b40c 23					inc hl 
b40d cd 9e 89				call xrnd 
b410 6f					ld l,a	 
b411 26 00				ld h,0 
b413 cd 0f 98				call forth_push_numhl 
b416				       NEXTW 
b416 c3 00 9a			jp macro_next 
b419				endm 
# End of macro NEXTW
b419			.RND: 
b419				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b419 60				db WORD_SYS_CORE+76             
b41a 1f b5			dw .ENDMATHS            
b41c 04				db 3 + 1 
b41d .. 00			db "RND",0              
b421				endm 
# End of macro CWHEAD
b421			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b421			 
b421					if DEBUG_FORTH_WORDS_KEY 
b421						DMARK "RND" 
b421 f5				push af  
b422 3a 36 b4			ld a, (.dmark)  
b425 32 7a ee			ld (debug_mark),a  
b428 3a 37 b4			ld a, (.dmark+1)  
b42b 32 7b ee			ld (debug_mark+1),a  
b42e 3a 38 b4			ld a, (.dmark+2)  
b431 32 7c ee			ld (debug_mark+2),a  
b434 18 03			jr .pastdmark  
b436 ..			.dmark: db "RND"  
b439 f1			.pastdmark: pop af  
b43a			endm  
# End of macro DMARK
b43a						CALLMONITOR 
b43a cd 75 92			call break_point_state  
b43d				endm  
# End of macro CALLMONITOR
b43d					endif 
b43d					 
b43d					FORTH_DSP_VALUEHL    ; upper range 
b43d cd aa 98			call macro_dsp_valuehl 
b440				endm 
# End of macro FORTH_DSP_VALUEHL
b440			 
b440 22 bf eb				ld (LFSRSeed), hl	 
b443			 
b443					if DEBUG_FORTH_WORDS 
b443						DMARK "RN1" 
b443 f5				push af  
b444 3a 58 b4			ld a, (.dmark)  
b447 32 7a ee			ld (debug_mark),a  
b44a 3a 59 b4			ld a, (.dmark+1)  
b44d 32 7b ee			ld (debug_mark+1),a  
b450 3a 5a b4			ld a, (.dmark+2)  
b453 32 7c ee			ld (debug_mark+2),a  
b456 18 03			jr .pastdmark  
b458 ..			.dmark: db "RN1"  
b45b f1			.pastdmark: pop af  
b45c			endm  
# End of macro DMARK
b45c						CALLMONITOR 
b45c cd 75 92			call break_point_state  
b45f				endm  
# End of macro CALLMONITOR
b45f					endif 
b45f					FORTH_DSP_POP 
b45f cd 46 99			call macro_forth_dsp_pop 
b462				endm 
# End of macro FORTH_DSP_POP
b462			 
b462					FORTH_DSP_VALUEHL    ; low range 
b462 cd aa 98			call macro_dsp_valuehl 
b465				endm 
# End of macro FORTH_DSP_VALUEHL
b465			 
b465					if DEBUG_FORTH_WORDS 
b465						DMARK "RN2" 
b465 f5				push af  
b466 3a 7a b4			ld a, (.dmark)  
b469 32 7a ee			ld (debug_mark),a  
b46c 3a 7b b4			ld a, (.dmark+1)  
b46f 32 7b ee			ld (debug_mark+1),a  
b472 3a 7c b4			ld a, (.dmark+2)  
b475 32 7c ee			ld (debug_mark+2),a  
b478 18 03			jr .pastdmark  
b47a ..			.dmark: db "RN2"  
b47d f1			.pastdmark: pop af  
b47e			endm  
# End of macro DMARK
b47e						CALLMONITOR 
b47e cd 75 92			call break_point_state  
b481				endm  
# End of macro CALLMONITOR
b481					endif 
b481 22 c1 eb				ld (LFSRSeed+2), hl 
b484			 
b484					FORTH_DSP_POP 
b484 cd 46 99			call macro_forth_dsp_pop 
b487				endm 
# End of macro FORTH_DSP_POP
b487			 
b487 e5					push hl 
b488			 
b488 e1			.inrange:	pop hl 
b489 cd 84 89				call prng16  
b48c					if DEBUG_FORTH_WORDS 
b48c						DMARK "RN3" 
b48c f5				push af  
b48d 3a a1 b4			ld a, (.dmark)  
b490 32 7a ee			ld (debug_mark),a  
b493 3a a2 b4			ld a, (.dmark+1)  
b496 32 7b ee			ld (debug_mark+1),a  
b499 3a a3 b4			ld a, (.dmark+2)  
b49c 32 7c ee			ld (debug_mark+2),a  
b49f 18 03			jr .pastdmark  
b4a1 ..			.dmark: db "RN3"  
b4a4 f1			.pastdmark: pop af  
b4a5			endm  
# End of macro DMARK
b4a5						CALLMONITOR 
b4a5 cd 75 92			call break_point_state  
b4a8				endm  
# End of macro CALLMONITOR
b4a8					endif 
b4a8					 
b4a8					; if the range is 8bit knock out the high byte 
b4a8			 
b4a8 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
b4ac			 
b4ac 3e 00				ld a, 0 
b4ae ba					cp d  
b4af 20 1e				jr nz, .hirange 
b4b1 26 00				ld h, 0   ; knock it down to 8bit 
b4b3			 
b4b3					if DEBUG_FORTH_WORDS 
b4b3						DMARK "RNk" 
b4b3 f5				push af  
b4b4 3a c8 b4			ld a, (.dmark)  
b4b7 32 7a ee			ld (debug_mark),a  
b4ba 3a c9 b4			ld a, (.dmark+1)  
b4bd 32 7b ee			ld (debug_mark+1),a  
b4c0 3a ca b4			ld a, (.dmark+2)  
b4c3 32 7c ee			ld (debug_mark+2),a  
b4c6 18 03			jr .pastdmark  
b4c8 ..			.dmark: db "RNk"  
b4cb f1			.pastdmark: pop af  
b4cc			endm  
# End of macro DMARK
b4cc						CALLMONITOR 
b4cc cd 75 92			call break_point_state  
b4cf				endm  
# End of macro CALLMONITOR
b4cf					endif 
b4cf			.hirange:   
b4cf e5					push hl  
b4d0 b7					or a  
b4d1 ed 52		                sbc hl, de 
b4d3			 
b4d3					;call cmp16 
b4d3			 
b4d3 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b4d5 e1					pop hl 
b4d6 e5					push hl 
b4d7			 
b4d7					if DEBUG_FORTH_WORDS 
b4d7						DMARK "RN4" 
b4d7 f5				push af  
b4d8 3a ec b4			ld a, (.dmark)  
b4db 32 7a ee			ld (debug_mark),a  
b4de 3a ed b4			ld a, (.dmark+1)  
b4e1 32 7b ee			ld (debug_mark+1),a  
b4e4 3a ee b4			ld a, (.dmark+2)  
b4e7 32 7c ee			ld (debug_mark+2),a  
b4ea 18 03			jr .pastdmark  
b4ec ..			.dmark: db "RN4"  
b4ef f1			.pastdmark: pop af  
b4f0			endm  
# End of macro DMARK
b4f0						CALLMONITOR 
b4f0 cd 75 92			call break_point_state  
b4f3				endm  
# End of macro CALLMONITOR
b4f3					endif 
b4f3 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
b4f7					;call cmp16 
b4f7				 
b4f7 b7					or a  
b4f8 ed 52		                sbc hl, de 
b4fa 38 8c				jr c, .inrange 
b4fc			 
b4fc e1					pop hl 
b4fd					 
b4fd					if DEBUG_FORTH_WORDS 
b4fd						DMARK "RNd" 
b4fd f5				push af  
b4fe 3a 12 b5			ld a, (.dmark)  
b501 32 7a ee			ld (debug_mark),a  
b504 3a 13 b5			ld a, (.dmark+1)  
b507 32 7b ee			ld (debug_mark+1),a  
b50a 3a 14 b5			ld a, (.dmark+2)  
b50d 32 7c ee			ld (debug_mark+2),a  
b510 18 03			jr .pastdmark  
b512 ..			.dmark: db "RNd"  
b515 f1			.pastdmark: pop af  
b516			endm  
# End of macro DMARK
b516						CALLMONITOR 
b516 cd 75 92			call break_point_state  
b519				endm  
# End of macro CALLMONITOR
b519					endif 
b519			 
b519			 
b519 cd 0f 98				call forth_push_numhl 
b51c				       NEXTW 
b51c c3 00 9a			jp macro_next 
b51f				endm 
# End of macro NEXTW
b51f			 
b51f			.ENDMATHS: 
b51f			 
b51f			; eof 
b51f			 
# End of file forth_words_maths.asm
b51f			include "forth_words_display.asm" 
b51f			 
b51f			; | ## Display Words 
b51f			 
b51f			.ATP: 
b51f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b51f 62				db WORD_SYS_CORE+78             
b520 96 b5			dw .FB            
b522 04				db 3 + 1 
b523 .. 00			db "AT?",0              
b527				endm 
# End of macro CWHEAD
b527			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b527					if DEBUG_FORTH_WORDS_KEY 
b527						DMARK "AT?" 
b527 f5				push af  
b528 3a 3c b5			ld a, (.dmark)  
b52b 32 7a ee			ld (debug_mark),a  
b52e 3a 3d b5			ld a, (.dmark+1)  
b531 32 7b ee			ld (debug_mark+1),a  
b534 3a 3e b5			ld a, (.dmark+2)  
b537 32 7c ee			ld (debug_mark+2),a  
b53a 18 03			jr .pastdmark  
b53c ..			.dmark: db "AT?"  
b53f f1			.pastdmark: pop af  
b540			endm  
# End of macro DMARK
b540						CALLMONITOR 
b540 cd 75 92			call break_point_state  
b543				endm  
# End of macro CALLMONITOR
b543					endif 
b543 3a 5e eb				ld a, (f_cursor_ptr) 
b546			 
b546			if DEBUG_FORTH_WORDS 
b546				DMARK "AT?" 
b546 f5				push af  
b547 3a 5b b5			ld a, (.dmark)  
b54a 32 7a ee			ld (debug_mark),a  
b54d 3a 5c b5			ld a, (.dmark+1)  
b550 32 7b ee			ld (debug_mark+1),a  
b553 3a 5d b5			ld a, (.dmark+2)  
b556 32 7c ee			ld (debug_mark+2),a  
b559 18 03			jr .pastdmark  
b55b ..			.dmark: db "AT?"  
b55e f1			.pastdmark: pop af  
b55f			endm  
# End of macro DMARK
b55f				CALLMONITOR 
b55f cd 75 92			call break_point_state  
b562				endm  
# End of macro CALLMONITOR
b562			endif	 
b562					; count the number of rows 
b562			 
b562 06 00				ld b, 0 
b564 4f			.atpr:		ld c, a    ; save in case we go below zero 
b565 d6 28				sub display_cols 
b567 f2 6d b5				jp p, .atprunder 
b56a 04					inc b 
b56b 18 f7				jr .atpr 
b56d			.atprunder:	 
b56d			if DEBUG_FORTH_WORDS 
b56d				DMARK "A?2" 
b56d f5				push af  
b56e 3a 82 b5			ld a, (.dmark)  
b571 32 7a ee			ld (debug_mark),a  
b574 3a 83 b5			ld a, (.dmark+1)  
b577 32 7b ee			ld (debug_mark+1),a  
b57a 3a 84 b5			ld a, (.dmark+2)  
b57d 32 7c ee			ld (debug_mark+2),a  
b580 18 03			jr .pastdmark  
b582 ..			.dmark: db "A?2"  
b585 f1			.pastdmark: pop af  
b586			endm  
# End of macro DMARK
b586				CALLMONITOR 
b586 cd 75 92			call break_point_state  
b589				endm  
# End of macro CALLMONITOR
b589			endif	 
b589 26 00				ld h, 0 
b58b 69					ld l, c 
b58c cd 0f 98				call forth_push_numhl 
b58f 68					ld l, b  
b590 cd 0f 98				call forth_push_numhl 
b593			 
b593			 
b593				NEXTW 
b593 c3 00 9a			jp macro_next 
b596				endm 
# End of macro NEXTW
b596			 
b596			.FB: 
b596				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b596 1b				db WORD_SYS_CORE+7             
b597 e4 b5			dw .EMIT            
b599 03				db 2 + 1 
b59a .. 00			db "FB",0              
b59d				endm 
# End of macro CWHEAD
b59d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b59d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b59d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b59d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b59d					if DEBUG_FORTH_WORDS_KEY 
b59d						DMARK "FB." 
b59d f5				push af  
b59e 3a b2 b5			ld a, (.dmark)  
b5a1 32 7a ee			ld (debug_mark),a  
b5a4 3a b3 b5			ld a, (.dmark+1)  
b5a7 32 7b ee			ld (debug_mark+1),a  
b5aa 3a b4 b5			ld a, (.dmark+2)  
b5ad 32 7c ee			ld (debug_mark+2),a  
b5b0 18 03			jr .pastdmark  
b5b2 ..			.dmark: db "FB."  
b5b5 f1			.pastdmark: pop af  
b5b6			endm  
# End of macro DMARK
b5b6						CALLMONITOR 
b5b6 cd 75 92			call break_point_state  
b5b9				endm  
# End of macro CALLMONITOR
b5b9					endif 
b5b9			 
b5b9					FORTH_DSP_VALUEHL 
b5b9 cd aa 98			call macro_dsp_valuehl 
b5bc				endm 
# End of macro FORTH_DSP_VALUEHL
b5bc			 
b5bc 7d					ld a, l 
b5bd fe 01				cp 1 
b5bf 20 05				jr nz, .fbn1 
b5c1 21 1f ed				ld hl, display_fb1 
b5c4 18 15				jr .fbset 
b5c6 fe 02		.fbn1:		cp 2 
b5c8 20 05				jr nz, .fbn2 
b5ca 21 dd eb				ld hl, display_fb2 
b5cd 18 0c				jr .fbset 
b5cf fe 03		.fbn2:		cp 3 
b5d1 20 05				jr nz, .fbn3 
b5d3 21 7e ec				ld hl, display_fb3 
b5d6 18 03				jr .fbset 
b5d8			.fbn3:		 ; if invalid number select first 
b5d8 21 1f ed				ld hl, display_fb1 
b5db 22 db eb		.fbset:		ld (display_fb_active), hl 
b5de			 
b5de					FORTH_DSP_POP 
b5de cd 46 99			call macro_forth_dsp_pop 
b5e1				endm 
# End of macro FORTH_DSP_POP
b5e1			 
b5e1					NEXTW 
b5e1 c3 00 9a			jp macro_next 
b5e4				endm 
# End of macro NEXTW
b5e4			 
b5e4			 
b5e4			.EMIT: 
b5e4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b5e4 1b				db WORD_SYS_CORE+7             
b5e5 35 b6			dw .DOTH            
b5e7 05				db 4 + 1 
b5e8 .. 00			db "EMIT",0              
b5ed				endm 
# End of macro CWHEAD
b5ed			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b5ed					; get value off TOS and display it 
b5ed			 
b5ed					if DEBUG_FORTH_WORDS_KEY 
b5ed						DMARK "EMT" 
b5ed f5				push af  
b5ee 3a 02 b6			ld a, (.dmark)  
b5f1 32 7a ee			ld (debug_mark),a  
b5f4 3a 03 b6			ld a, (.dmark+1)  
b5f7 32 7b ee			ld (debug_mark+1),a  
b5fa 3a 04 b6			ld a, (.dmark+2)  
b5fd 32 7c ee			ld (debug_mark+2),a  
b600 18 03			jr .pastdmark  
b602 ..			.dmark: db "EMT"  
b605 f1			.pastdmark: pop af  
b606			endm  
# End of macro DMARK
b606						CALLMONITOR 
b606 cd 75 92			call break_point_state  
b609				endm  
# End of macro CALLMONITOR
b609					endif 
b609			 
b609					FORTH_DSP_VALUEHL 
b609 cd aa 98			call macro_dsp_valuehl 
b60c				endm 
# End of macro FORTH_DSP_VALUEHL
b60c			 
b60c 7d					ld a,l 
b60d			 
b60d					; TODO write to display 
b60d			 
b60d 32 73 e5				ld (os_input), a 
b610 3e 00				ld a, 0 
b612 32 74 e5				ld (os_input+1), a 
b615					 
b615 3a 5e eb				ld a, (f_cursor_ptr) 
b618 11 73 e5				ld de, os_input 
b61b cd 47 88				call str_at_display 
b61e			 
b61e			 
b61e 3a 3c eb				ld a,(cli_autodisplay) 
b621 fe 00				cp 0 
b623 28 03				jr z, .enoupdate 
b625 cd 57 88						call update_display 
b628					.enoupdate: 
b628			 
b628 3a 5e eb				ld a, (f_cursor_ptr) 
b62b 3c					inc a 
b62c 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
b62f			 
b62f			 
b62f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b62f cd 46 99			call macro_forth_dsp_pop 
b632				endm 
# End of macro FORTH_DSP_POP
b632			  
b632			 
b632					NEXTW 
b632 c3 00 9a			jp macro_next 
b635				endm 
# End of macro NEXTW
b635			.DOTH: 
b635				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b635 1c				db WORD_SYS_CORE+8             
b636 65 b6			dw .DOTF            
b638 03				db 2 + 1 
b639 .. 00			db ".-",0              
b63c				endm 
# End of macro CWHEAD
b63c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b63c					; get value off TOS and display it 
b63c					if DEBUG_FORTH_WORDS_KEY 
b63c						DMARK "DTD" 
b63c f5				push af  
b63d 3a 51 b6			ld a, (.dmark)  
b640 32 7a ee			ld (debug_mark),a  
b643 3a 52 b6			ld a, (.dmark+1)  
b646 32 7b ee			ld (debug_mark+1),a  
b649 3a 53 b6			ld a, (.dmark+2)  
b64c 32 7c ee			ld (debug_mark+2),a  
b64f 18 03			jr .pastdmark  
b651 ..			.dmark: db "DTD"  
b654 f1			.pastdmark: pop af  
b655			endm  
# End of macro DMARK
b655						CALLMONITOR 
b655 cd 75 92			call break_point_state  
b658				endm  
# End of macro CALLMONITOR
b658					endif 
b658 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b65a 3e 00			ld a, 0 
b65c 32 3d eb			ld (cli_mvdot), a 
b65f c3 bc b6			jp .dotgo 
b662				NEXTW 
b662 c3 00 9a			jp macro_next 
b665				endm 
# End of macro NEXTW
b665			.DOTF: 
b665				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b665 1c				db WORD_SYS_CORE+8             
b666 93 b6			dw .DOT            
b668 03				db 2 + 1 
b669 .. 00			db ".>",0              
b66c				endm 
# End of macro CWHEAD
b66c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b66c					; get value off TOS and display it 
b66c			        ; TODO BUG adds extra spaces 
b66c			        ; TODO BUG handle numerics? 
b66c					if DEBUG_FORTH_WORDS_KEY 
b66c						DMARK "DTC" 
b66c f5				push af  
b66d 3a 81 b6			ld a, (.dmark)  
b670 32 7a ee			ld (debug_mark),a  
b673 3a 82 b6			ld a, (.dmark+1)  
b676 32 7b ee			ld (debug_mark+1),a  
b679 3a 83 b6			ld a, (.dmark+2)  
b67c 32 7c ee			ld (debug_mark+2),a  
b67f 18 03			jr .pastdmark  
b681 ..			.dmark: db "DTC"  
b684 f1			.pastdmark: pop af  
b685			endm  
# End of macro DMARK
b685						CALLMONITOR 
b685 cd 75 92			call break_point_state  
b688				endm  
# End of macro CALLMONITOR
b688					endif 
b688 3e 01			ld a, 1 
b68a 32 3d eb			ld (cli_mvdot), a 
b68d c3 bc b6			jp .dotgo 
b690				NEXTW 
b690 c3 00 9a			jp macro_next 
b693				endm 
# End of macro NEXTW
b693			 
b693			.DOT: 
b693				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b693 1c				db WORD_SYS_CORE+8             
b694 1f b7			dw .CLS            
b696 02				db 1 + 1 
b697 .. 00			db ".",0              
b699				endm 
# End of macro CWHEAD
b699			        ; | . ( u -- ) Display TOS | DONE 
b699					; get value off TOS and display it 
b699			 
b699					if DEBUG_FORTH_WORDS_KEY 
b699						DMARK "DOT" 
b699 f5				push af  
b69a 3a ae b6			ld a, (.dmark)  
b69d 32 7a ee			ld (debug_mark),a  
b6a0 3a af b6			ld a, (.dmark+1)  
b6a3 32 7b ee			ld (debug_mark+1),a  
b6a6 3a b0 b6			ld a, (.dmark+2)  
b6a9 32 7c ee			ld (debug_mark+2),a  
b6ac 18 03			jr .pastdmark  
b6ae ..			.dmark: db "DOT"  
b6b1 f1			.pastdmark: pop af  
b6b2			endm  
# End of macro DMARK
b6b2						CALLMONITOR 
b6b2 cd 75 92			call break_point_state  
b6b5				endm  
# End of macro CALLMONITOR
b6b5					endif 
b6b5 3e 00			ld a, 0 
b6b7 32 3d eb			ld (cli_mvdot), a 
b6ba 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b6bc				 
b6bc			 
b6bc			.dotgo: 
b6bc			 
b6bc			; move up type to on stack for parserv5 
b6bc					FORTH_DSP 
b6bc cd 8f 98			call macro_forth_dsp 
b6bf				endm 
# End of macro FORTH_DSP
b6bf				;FORTH_DSP_VALUE  
b6bf			 
b6bf			if DEBUG_FORTH_DOT 
b6bf				DMARK "DOT" 
b6bf				CALLMONITOR 
b6bf			endif	 
b6bf			;		.print: 
b6bf			 
b6bf 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b6c0 23				inc hl   ; position to the actual value 
b6c1 fe 01			cp DS_TYPE_STR 
b6c3 20 06			jr nz, .dotnum1  
b6c5			 
b6c5			; display string 
b6c5				FORTH_DSP_VALUE  
b6c5 cd 93 98			call macro_forth_dsp_value 
b6c8				endm 
# End of macro FORTH_DSP_VALUE
b6c8 eb				ex de,hl 
b6c9 18 11			jr .dotwrite 
b6cb			 
b6cb			.dotnum1: 
b6cb fe 02			cp DS_TYPE_INUM 
b6cd 20 0c			jr nz, .dotflot 
b6cf			 
b6cf			 
b6cf			; display number 
b6cf			 
b6cf			;	push hl 
b6cf			;	call clear_display 
b6cf			;	pop hl 
b6cf			 
b6cf 5e				ld e, (hl) 
b6d0 23				inc hl 
b6d1 56				ld d, (hl) 
b6d2 21 75 e3			ld hl, scratch 
b6d5			if DEBUG_FORTH_DOT 
b6d5				DMARK "DT1" 
b6d5				CALLMONITOR 
b6d5			endif	 
b6d5			 
b6d5 cd 6a 8e			call uitoa_16 
b6d8 eb				ex de,hl 
b6d9			 
b6d9			if DEBUG_FORTH_DOT 
b6d9				DMARK "DT2" 
b6d9				CALLMONITOR 
b6d9			endif	 
b6d9			 
b6d9			;	ld de, os_word_scratch 
b6d9 18 01			jr .dotwrite 
b6db			 
b6db 00			.dotflot:   nop 
b6dc			; TODO print floating point number 
b6dc			 
b6dc			.dotwrite:		 
b6dc			 
b6dc					; if c is set then set all '-' to spaces 
b6dc					; need to also take into account .>  
b6dc			 
b6dc 3e 01				ld a, 1 
b6de b9					cp c 
b6df 20 13				jr nz, .nodashswap 
b6e1			 
b6e1					; DE has the string to write, working with HL 
b6e1			 
b6e1 06 ff				ld b, 255 
b6e3 d5					push de 
b6e4 e1					pop hl 
b6e5			 
b6e5			if DEBUG_FORTH_DOT 
b6e5				DMARK "DT-" 
b6e5				CALLMONITOR 
b6e5			endif	 
b6e5 7e			.dashscan:	ld a, (hl) 
b6e6 fe 00				cp 0 
b6e8 28 0a				jr z, .nodashswap 
b6ea fe 2d				cp '-' 
b6ec 20 03				jr nz, .dashskip 
b6ee 3e 20				ld a, ' ' 
b6f0 77					ld (hl), a 
b6f1 23			.dashskip:	inc hl 
b6f2			if DEBUG_FORTH_DOT 
b6f2				DMARK "D-2" 
b6f2				CALLMONITOR 
b6f2			endif	 
b6f2 10 f1				djnz .dashscan 
b6f4			 
b6f4			if DEBUG_FORTH_DOT 
b6f4				DMARK "D-1" 
b6f4				CALLMONITOR 
b6f4			endif	 
b6f4			 
b6f4			.nodashswap: 
b6f4			 
b6f4 e5					push hl   ; save string start in case we need to advance print 
b6f5			 
b6f5 3a 5e eb				ld a, (f_cursor_ptr) 
b6f8 cd 47 88				call str_at_display 
b6fb 3a 3c eb				ld a,(cli_autodisplay) 
b6fe fe 00				cp 0 
b700 28 03				jr z, .noupdate 
b702 cd 57 88						call update_display 
b705					.noupdate: 
b705			 
b705			 
b705					; see if we need to advance the print position 
b705			 
b705 e1					pop hl   ; get back string 
b706			 
b706 3a 3d eb				ld a, (cli_mvdot) 
b709			if DEBUG_FORTH_DOT 
b709					ld e,a 
b709				DMARK "D>1" 
b709				CALLMONITOR 
b709			endif	 
b709 fe 00				cp 0 
b70b 28 0c				jr z, .noadv 
b70d					; yes, lets advance the print position 
b70d 3e 00				ld a, 0 
b70f cd c6 8e				call strlent 
b712 3a 5e eb				ld a, (f_cursor_ptr) 
b715 85					add a,l 
b716					;call addatohl 
b716					;ld a, l 
b716 32 5e eb				ld (f_cursor_ptr), a   ; save new pos 
b719			 
b719			if DEBUG_FORTH_DOT 
b719				DMARK "D->" 
b719				CALLMONITOR 
b719			endif	 
b719			 
b719			.noadv:	 
b719			 
b719					if DEBUG_FORTH_DOT_WAIT 
b719							call next_page_prompt 
b719					endif	 
b719			; TODO this pop off the stack causes a crash. i dont know why 
b719			 
b719			 
b719			if DEBUG_FORTH_DOT 
b719				DMARK "DTh" 
b719				CALLMONITOR 
b719			endif	 
b719			 
b719					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b719 cd 46 99			call macro_forth_dsp_pop 
b71c				endm 
# End of macro FORTH_DSP_POP
b71c			 
b71c			if DEBUG_FORTH_DOT 
b71c				DMARK "DTi" 
b71c				CALLMONITOR 
b71c			endif	 
b71c			 
b71c			 
b71c					NEXTW 
b71c c3 00 9a			jp macro_next 
b71f				endm 
# End of macro NEXTW
b71f			 
b71f			.CLS: 
b71f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b71f 35				db WORD_SYS_CORE+33             
b720 4c b7			dw .DRAW            
b722 04				db 3 + 1 
b723 .. 00			db "CLS",0              
b727				endm 
# End of macro CWHEAD
b727			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b727					if DEBUG_FORTH_WORDS_KEY 
b727						DMARK "CLS" 
b727 f5				push af  
b728 3a 3c b7			ld a, (.dmark)  
b72b 32 7a ee			ld (debug_mark),a  
b72e 3a 3d b7			ld a, (.dmark+1)  
b731 32 7b ee			ld (debug_mark+1),a  
b734 3a 3e b7			ld a, (.dmark+2)  
b737 32 7c ee			ld (debug_mark+2),a  
b73a 18 03			jr .pastdmark  
b73c ..			.dmark: db "CLS"  
b73f f1			.pastdmark: pop af  
b740			endm  
# End of macro DMARK
b740						CALLMONITOR 
b740 cd 75 92			call break_point_state  
b743				endm  
# End of macro CALLMONITOR
b743					endif 
b743 cd 34 88				call clear_display 
b746 c3 5a b8				jp .home		; and home cursor 
b749					NEXTW 
b749 c3 00 9a			jp macro_next 
b74c				endm 
# End of macro NEXTW
b74c			 
b74c			.DRAW: 
b74c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b74c 36				db WORD_SYS_CORE+34             
b74d 77 b7			dw .DUMP            
b74f 05				db 4 + 1 
b750 .. 00			db "DRAW",0              
b755				endm 
# End of macro CWHEAD
b755			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b755					if DEBUG_FORTH_WORDS_KEY 
b755						DMARK "DRW" 
b755 f5				push af  
b756 3a 6a b7			ld a, (.dmark)  
b759 32 7a ee			ld (debug_mark),a  
b75c 3a 6b b7			ld a, (.dmark+1)  
b75f 32 7b ee			ld (debug_mark+1),a  
b762 3a 6c b7			ld a, (.dmark+2)  
b765 32 7c ee			ld (debug_mark+2),a  
b768 18 03			jr .pastdmark  
b76a ..			.dmark: db "DRW"  
b76d f1			.pastdmark: pop af  
b76e			endm  
# End of macro DMARK
b76e						CALLMONITOR 
b76e cd 75 92			call break_point_state  
b771				endm  
# End of macro CALLMONITOR
b771					endif 
b771 cd 57 88				call update_display 
b774					NEXTW 
b774 c3 00 9a			jp macro_next 
b777				endm 
# End of macro NEXTW
b777			 
b777			.DUMP: 
b777				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b777 37				db WORD_SYS_CORE+35             
b778 af b7			dw .CDUMP            
b77a 05				db 4 + 1 
b77b .. 00			db "DUMP",0              
b780				endm 
# End of macro CWHEAD
b780			; | DUMP ( x -- ) With address x display dump   | DONE 
b780			; TODO pop address to use off of the stack 
b780					if DEBUG_FORTH_WORDS_KEY 
b780						DMARK "DUM" 
b780 f5				push af  
b781 3a 95 b7			ld a, (.dmark)  
b784 32 7a ee			ld (debug_mark),a  
b787 3a 96 b7			ld a, (.dmark+1)  
b78a 32 7b ee			ld (debug_mark+1),a  
b78d 3a 97 b7			ld a, (.dmark+2)  
b790 32 7c ee			ld (debug_mark+2),a  
b793 18 03			jr .pastdmark  
b795 ..			.dmark: db "DUM"  
b798 f1			.pastdmark: pop af  
b799			endm  
# End of macro DMARK
b799						CALLMONITOR 
b799 cd 75 92			call break_point_state  
b79c				endm  
# End of macro CALLMONITOR
b79c					endif 
b79c cd 34 88				call clear_display 
b79f			 
b79f					; get address 
b79f			 
b79f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b79f cd aa 98			call macro_dsp_valuehl 
b7a2				endm 
# End of macro FORTH_DSP_VALUEHL
b7a2				 
b7a2					; save it for cdump 
b7a2			 
b7a2 22 98 e6				ld (os_cur_ptr),hl 
b7a5			 
b7a5					; destroy value TOS 
b7a5			 
b7a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7a5 cd 46 99			call macro_forth_dsp_pop 
b7a8				endm 
# End of macro FORTH_DSP_POP
b7a8			 
b7a8 cd 8f 96				call dumpcont	; skip old style of param parsing	 
b7ab c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b7ac					NEXTW 
b7ac c3 00 9a			jp macro_next 
b7af				endm 
# End of macro NEXTW
b7af			.CDUMP: 
b7af				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b7af 38				db WORD_SYS_CORE+36             
b7b0 df b7			dw .DAT            
b7b2 06				db 5 + 1 
b7b3 .. 00			db "CDUMP",0              
b7b9				endm 
# End of macro CWHEAD
b7b9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b7b9					if DEBUG_FORTH_WORDS_KEY 
b7b9						DMARK "CDP" 
b7b9 f5				push af  
b7ba 3a ce b7			ld a, (.dmark)  
b7bd 32 7a ee			ld (debug_mark),a  
b7c0 3a cf b7			ld a, (.dmark+1)  
b7c3 32 7b ee			ld (debug_mark+1),a  
b7c6 3a d0 b7			ld a, (.dmark+2)  
b7c9 32 7c ee			ld (debug_mark+2),a  
b7cc 18 03			jr .pastdmark  
b7ce ..			.dmark: db "CDP"  
b7d1 f1			.pastdmark: pop af  
b7d2			endm  
# End of macro DMARK
b7d2						CALLMONITOR 
b7d2 cd 75 92			call break_point_state  
b7d5				endm  
# End of macro CALLMONITOR
b7d5					endif 
b7d5 cd 34 88				call clear_display 
b7d8 cd 8f 96				call dumpcont	 
b7db c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b7dc					NEXTW 
b7dc c3 00 9a			jp macro_next 
b7df				endm 
# End of macro NEXTW
b7df			 
b7df			 
b7df			 
b7df			 
b7df			.DAT: 
b7df				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b7df 3d				db WORD_SYS_CORE+41             
b7e0 35 b8			dw .HOME            
b7e2 03				db 2 + 1 
b7e3 .. 00			db "AT",0              
b7e6				endm 
# End of macro CWHEAD
b7e6			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b7e6					if DEBUG_FORTH_WORDS_KEY 
b7e6						DMARK "AT." 
b7e6 f5				push af  
b7e7 3a fb b7			ld a, (.dmark)  
b7ea 32 7a ee			ld (debug_mark),a  
b7ed 3a fc b7			ld a, (.dmark+1)  
b7f0 32 7b ee			ld (debug_mark+1),a  
b7f3 3a fd b7			ld a, (.dmark+2)  
b7f6 32 7c ee			ld (debug_mark+2),a  
b7f9 18 03			jr .pastdmark  
b7fb ..			.dmark: db "AT."  
b7fe f1			.pastdmark: pop af  
b7ff			endm  
# End of macro DMARK
b7ff						CALLMONITOR 
b7ff cd 75 92			call break_point_state  
b802				endm  
# End of macro CALLMONITOR
b802					endif 
b802					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b802 cd aa 98			call macro_dsp_valuehl 
b805				endm 
# End of macro FORTH_DSP_VALUEHL
b805			 
b805			 
b805					; TODO save cursor row 
b805 7d					ld a,l 
b806 fe 02				cp 2 
b808 20 04				jr nz, .crow3 
b80a 3e 28				ld a, display_row_2 
b80c 18 12				jr .ccol1 
b80e fe 03		.crow3:		cp 3 
b810 20 04				jr nz, .crow4 
b812 3e 50				ld a, display_row_3 
b814 18 0a				jr .ccol1 
b816 fe 04		.crow4:		cp 4 
b818 20 04				jr nz, .crow1 
b81a 3e 78				ld a, display_row_4 
b81c 18 02				jr .ccol1 
b81e 3e 00		.crow1:		ld a,display_row_1 
b820 f5			.ccol1:		push af			; got row offset 
b821 6f					ld l,a 
b822 26 00				ld h,0 
b824					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b824 cd 46 99			call macro_forth_dsp_pop 
b827				endm 
# End of macro FORTH_DSP_POP
b827					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b827 cd aa 98			call macro_dsp_valuehl 
b82a				endm 
# End of macro FORTH_DSP_VALUEHL
b82a					; TODO save cursor col 
b82a f1					pop af 
b82b 85					add l		; add col offset 
b82c 32 5e eb				ld (f_cursor_ptr), a 
b82f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b82f cd 46 99			call macro_forth_dsp_pop 
b832				endm 
# End of macro FORTH_DSP_POP
b832			 
b832					; calculate  
b832			 
b832					NEXTW 
b832 c3 00 9a			jp macro_next 
b835				endm 
# End of macro NEXTW
b835			 
b835			 
b835			.HOME: 
b835				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b835 41				db WORD_SYS_CORE+45             
b836 62 b8			dw .SPACE            
b838 05				db 4 + 1 
b839 .. 00			db "HOME",0              
b83e				endm 
# End of macro CWHEAD
b83e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b83e					if DEBUG_FORTH_WORDS_KEY 
b83e						DMARK "HOM" 
b83e f5				push af  
b83f 3a 53 b8			ld a, (.dmark)  
b842 32 7a ee			ld (debug_mark),a  
b845 3a 54 b8			ld a, (.dmark+1)  
b848 32 7b ee			ld (debug_mark+1),a  
b84b 3a 55 b8			ld a, (.dmark+2)  
b84e 32 7c ee			ld (debug_mark+2),a  
b851 18 03			jr .pastdmark  
b853 ..			.dmark: db "HOM"  
b856 f1			.pastdmark: pop af  
b857			endm  
# End of macro DMARK
b857						CALLMONITOR 
b857 cd 75 92			call break_point_state  
b85a				endm  
# End of macro CALLMONITOR
b85a					endif 
b85a 3e 00		.home:		ld a, 0		; and home cursor 
b85c 32 5e eb				ld (f_cursor_ptr), a 
b85f					NEXTW 
b85f c3 00 9a			jp macro_next 
b862				endm 
# End of macro NEXTW
b862			 
b862			 
b862			.SPACE: 
b862				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b862 46				db WORD_SYS_CORE+50             
b863 90 b8			dw .SPACES            
b865 03				db 2 + 1 
b866 .. 00			db "BL",0              
b869				endm 
# End of macro CWHEAD
b869			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b869					if DEBUG_FORTH_WORDS_KEY 
b869						DMARK "BL." 
b869 f5				push af  
b86a 3a 7e b8			ld a, (.dmark)  
b86d 32 7a ee			ld (debug_mark),a  
b870 3a 7f b8			ld a, (.dmark+1)  
b873 32 7b ee			ld (debug_mark+1),a  
b876 3a 80 b8			ld a, (.dmark+2)  
b879 32 7c ee			ld (debug_mark+2),a  
b87c 18 03			jr .pastdmark  
b87e ..			.dmark: db "BL."  
b881 f1			.pastdmark: pop af  
b882			endm  
# End of macro DMARK
b882						CALLMONITOR 
b882 cd 75 92			call break_point_state  
b885				endm  
# End of macro CALLMONITOR
b885					endif 
b885 21 8e b8				ld hl, .blstr 
b888 cd 21 98				call forth_push_str 
b88b					 
b88b				       NEXTW 
b88b c3 00 9a			jp macro_next 
b88e				endm 
# End of macro NEXTW
b88e			 
b88e .. 00		.blstr: db " ", 0 
b890			 
b890			.SPACES: 
b890				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b890 47				db WORD_SYS_CORE+51             
b891 2b b9			dw .SCROLL            
b893 07				db 6 + 1 
b894 .. 00			db "SPACES",0              
b89b				endm 
# End of macro CWHEAD
b89b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b89b					if DEBUG_FORTH_WORDS_KEY 
b89b						DMARK "SPS" 
b89b f5				push af  
b89c 3a b0 b8			ld a, (.dmark)  
b89f 32 7a ee			ld (debug_mark),a  
b8a2 3a b1 b8			ld a, (.dmark+1)  
b8a5 32 7b ee			ld (debug_mark+1),a  
b8a8 3a b2 b8			ld a, (.dmark+2)  
b8ab 32 7c ee			ld (debug_mark+2),a  
b8ae 18 03			jr .pastdmark  
b8b0 ..			.dmark: db "SPS"  
b8b3 f1			.pastdmark: pop af  
b8b4			endm  
# End of macro DMARK
b8b4						CALLMONITOR 
b8b4 cd 75 92			call break_point_state  
b8b7				endm  
# End of macro CALLMONITOR
b8b7					endif 
b8b7			 
b8b7			 
b8b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8b7 cd aa 98			call macro_dsp_valuehl 
b8ba				endm 
# End of macro FORTH_DSP_VALUEHL
b8ba			 
b8ba			;		push hl    ; u 
b8ba					if DEBUG_FORTH_WORDS 
b8ba						DMARK "SPA" 
b8ba f5				push af  
b8bb 3a cf b8			ld a, (.dmark)  
b8be 32 7a ee			ld (debug_mark),a  
b8c1 3a d0 b8			ld a, (.dmark+1)  
b8c4 32 7b ee			ld (debug_mark+1),a  
b8c7 3a d1 b8			ld a, (.dmark+2)  
b8ca 32 7c ee			ld (debug_mark+2),a  
b8cd 18 03			jr .pastdmark  
b8cf ..			.dmark: db "SPA"  
b8d2 f1			.pastdmark: pop af  
b8d3			endm  
# End of macro DMARK
b8d3						CALLMONITOR 
b8d3 cd 75 92			call break_point_state  
b8d6				endm  
# End of macro CALLMONITOR
b8d6					endif 
b8d6			 
b8d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8d6 cd 46 99			call macro_forth_dsp_pop 
b8d9				endm 
# End of macro FORTH_DSP_POP
b8d9			;		pop hl 
b8d9 4d					ld c, l 
b8da 06 00				ld b, 0 
b8dc 21 75 e3				ld hl, scratch  
b8df			 
b8df					if DEBUG_FORTH_WORDS 
b8df						DMARK "SP2" 
b8df f5				push af  
b8e0 3a f4 b8			ld a, (.dmark)  
b8e3 32 7a ee			ld (debug_mark),a  
b8e6 3a f5 b8			ld a, (.dmark+1)  
b8e9 32 7b ee			ld (debug_mark+1),a  
b8ec 3a f6 b8			ld a, (.dmark+2)  
b8ef 32 7c ee			ld (debug_mark+2),a  
b8f2 18 03			jr .pastdmark  
b8f4 ..			.dmark: db "SP2"  
b8f7 f1			.pastdmark: pop af  
b8f8			endm  
# End of macro DMARK
b8f8						CALLMONITOR 
b8f8 cd 75 92			call break_point_state  
b8fb				endm  
# End of macro CALLMONITOR
b8fb					endif 
b8fb 3e 20				ld a, ' ' 
b8fd c5			.spaces1:	push bc 
b8fe 77					ld (hl),a 
b8ff 23					inc hl 
b900 c1					pop bc 
b901 10 fa				djnz .spaces1 
b903 3e 00				ld a,0 
b905 77					ld (hl),a 
b906 21 75 e3				ld hl, scratch 
b909					if DEBUG_FORTH_WORDS 
b909						DMARK "SP3" 
b909 f5				push af  
b90a 3a 1e b9			ld a, (.dmark)  
b90d 32 7a ee			ld (debug_mark),a  
b910 3a 1f b9			ld a, (.dmark+1)  
b913 32 7b ee			ld (debug_mark+1),a  
b916 3a 20 b9			ld a, (.dmark+2)  
b919 32 7c ee			ld (debug_mark+2),a  
b91c 18 03			jr .pastdmark  
b91e ..			.dmark: db "SP3"  
b921 f1			.pastdmark: pop af  
b922			endm  
# End of macro DMARK
b922						CALLMONITOR 
b922 cd 75 92			call break_point_state  
b925				endm  
# End of macro CALLMONITOR
b925					endif 
b925 cd 57 98				call forth_apush 
b928			 
b928				       NEXTW 
b928 c3 00 9a			jp macro_next 
b92b				endm 
# End of macro NEXTW
b92b			 
b92b			 
b92b			 
b92b			.SCROLL: 
b92b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
b92b 53				db WORD_SYS_CORE+63             
b92c 58 b9			dw .SCROLLD            
b92e 07				db 6 + 1 
b92f .. 00			db "SCROLL",0              
b936				endm 
# End of macro CWHEAD
b936			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
b936					if DEBUG_FORTH_WORDS_KEY 
b936						DMARK "SCR" 
b936 f5				push af  
b937 3a 4b b9			ld a, (.dmark)  
b93a 32 7a ee			ld (debug_mark),a  
b93d 3a 4c b9			ld a, (.dmark+1)  
b940 32 7b ee			ld (debug_mark+1),a  
b943 3a 4d b9			ld a, (.dmark+2)  
b946 32 7c ee			ld (debug_mark+2),a  
b949 18 03			jr .pastdmark  
b94b ..			.dmark: db "SCR"  
b94e f1			.pastdmark: pop af  
b94f			endm  
# End of macro DMARK
b94f						CALLMONITOR 
b94f cd 75 92			call break_point_state  
b952				endm  
# End of macro CALLMONITOR
b952					endif 
b952			 
b952 cd f6 87			call scroll_up 
b955			;	call update_display 
b955			 
b955					NEXTW 
b955 c3 00 9a			jp macro_next 
b958				endm 
# End of macro NEXTW
b958			 
b958			 
b958			 
b958			;		; get dir 
b958			; 
b958			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b958			; 
b958			;		push hl 
b958			; 
b958			;		; destroy value TOS 
b958			; 
b958			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b958			; 
b958			;		; get count 
b958			; 
b958			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b958			; 
b958			;		push hl 
b958			; 
b958			;		; destroy value TOS 
b958			; 
b958			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b958			; 
b958			;		; one value on hl get other one back 
b958			; 
b958			;		pop bc    ; count 
b958			; 
b958			;		pop de   ; dir 
b958			; 
b958			; 
b958			;		ld b, c 
b958			; 
b958			;.scrolldir:     push bc 
b958			;		push de 
b958			; 
b958			;		ld a, 0 
b958			;		cp e 
b958			;		jr z, .scrollup  
b958			;		call scroll_down 
b958			;		jr .scrollnext 
b958			;.scrollup:	call scroll_up 
b958			; 
b958			;		 
b958			;.scrollnext: 
b958			;		pop de 
b958			;		pop bc 
b958			;		djnz .scrolldir 
b958			; 
b958			; 
b958			; 
b958			; 
b958			; 
b958			;		NEXTW 
b958			 
b958			.SCROLLD: 
b958				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
b958 53				db WORD_SYS_CORE+63             
b959 86 b9			dw .ATQ            
b95b 08				db 7 + 1 
b95c .. 00			db "SCROLLD",0              
b964				endm 
# End of macro CWHEAD
b964			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
b964					if DEBUG_FORTH_WORDS_KEY 
b964						DMARK "SCD" 
b964 f5				push af  
b965 3a 79 b9			ld a, (.dmark)  
b968 32 7a ee			ld (debug_mark),a  
b96b 3a 7a b9			ld a, (.dmark+1)  
b96e 32 7b ee			ld (debug_mark+1),a  
b971 3a 7b b9			ld a, (.dmark+2)  
b974 32 7c ee			ld (debug_mark+2),a  
b977 18 03			jr .pastdmark  
b979 ..			.dmark: db "SCD"  
b97c f1			.pastdmark: pop af  
b97d			endm  
# End of macro DMARK
b97d						CALLMONITOR 
b97d cd 75 92			call break_point_state  
b980				endm  
# End of macro CALLMONITOR
b980					endif 
b980			 
b980 cd 1a 88			call scroll_down 
b983			;	call update_display 
b983			 
b983					NEXTW 
b983 c3 00 9a			jp macro_next 
b986				endm 
# End of macro NEXTW
b986			 
b986			 
b986			.ATQ: 
b986				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
b986 62				db WORD_SYS_CORE+78             
b987 e4 b9			dw .AUTODSP            
b989 04				db 3 + 1 
b98a .. 00			db "AT@",0              
b98e				endm 
# End of macro CWHEAD
b98e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
b98e					if DEBUG_FORTH_WORDS_KEY 
b98e						DMARK "ATA" 
b98e f5				push af  
b98f 3a a3 b9			ld a, (.dmark)  
b992 32 7a ee			ld (debug_mark),a  
b995 3a a4 b9			ld a, (.dmark+1)  
b998 32 7b ee			ld (debug_mark+1),a  
b99b 3a a5 b9			ld a, (.dmark+2)  
b99e 32 7c ee			ld (debug_mark+2),a  
b9a1 18 03			jr .pastdmark  
b9a3 ..			.dmark: db "ATA"  
b9a6 f1			.pastdmark: pop af  
b9a7			endm  
# End of macro DMARK
b9a7						CALLMONITOR 
b9a7 cd 75 92			call break_point_state  
b9aa				endm  
# End of macro CALLMONITOR
b9aa					endif 
b9aa			 
b9aa			 
b9aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9aa cd aa 98			call macro_dsp_valuehl 
b9ad				endm 
# End of macro FORTH_DSP_VALUEHL
b9ad			 
b9ad					; TODO save cursor row 
b9ad 7d					ld a,l 
b9ae fe 02				cp 2 
b9b0 20 04				jr nz, .crow3aq 
b9b2 3e 28				ld a, display_row_2 
b9b4 18 12				jr .ccol1aq 
b9b6 fe 03		.crow3aq:		cp 3 
b9b8 20 04				jr nz, .crow4aq 
b9ba 3e 50				ld a, display_row_3 
b9bc 18 0a				jr .ccol1aq 
b9be fe 04		.crow4aq:		cp 4 
b9c0 20 04				jr nz, .crow1aq 
b9c2 3e 78				ld a, display_row_4 
b9c4 18 02				jr .ccol1aq 
b9c6 3e 00		.crow1aq:		ld a,display_row_1 
b9c8 f5			.ccol1aq:		push af			; got row offset 
b9c9 6f					ld l,a 
b9ca 26 00				ld h,0 
b9cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9cc cd 46 99			call macro_forth_dsp_pop 
b9cf				endm 
# End of macro FORTH_DSP_POP
b9cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9cf cd aa 98			call macro_dsp_valuehl 
b9d2				endm 
# End of macro FORTH_DSP_VALUEHL
b9d2					; TODO save cursor col 
b9d2 f1					pop af 
b9d3 85					add l		; add col offset 
b9d4			 
b9d4					; add current frame buffer address 
b9d4 2a db eb				ld hl, (display_fb_active) 
b9d7 cd 5d 8a				call addatohl 
b9da			 
b9da			 
b9da			 
b9da			 
b9da					; get char frame buffer location offset in hl 
b9da			 
b9da 7e					ld a,(hl) 
b9db 26 00				ld h, 0 
b9dd 6f					ld l, a 
b9de			 
b9de cd 0f 98				call forth_push_numhl 
b9e1			 
b9e1			 
b9e1					NEXTW 
b9e1 c3 00 9a			jp macro_next 
b9e4				endm 
# End of macro NEXTW
b9e4			 
b9e4			.AUTODSP: 
b9e4				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
b9e4 63				db WORD_SYS_CORE+79             
b9e5 fa b9			dw .MENU            
b9e7 05				db 4 + 1 
b9e8 .. 00			db "ADSP",0              
b9ed				endm 
# End of macro CWHEAD
b9ed			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
b9ed			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
b9ed			 
b9ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9ed cd aa 98			call macro_dsp_valuehl 
b9f0				endm 
# End of macro FORTH_DSP_VALUEHL
b9f0			 
b9f0			;		push hl 
b9f0			 
b9f0					; destroy value TOS 
b9f0			 
b9f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9f0 cd 46 99			call macro_forth_dsp_pop 
b9f3				endm 
# End of macro FORTH_DSP_POP
b9f3			 
b9f3			;		pop hl 
b9f3			 
b9f3 7d					ld a,l 
b9f4 32 3c eb				ld (cli_autodisplay), a 
b9f7				       NEXTW 
b9f7 c3 00 9a			jp macro_next 
b9fa				endm 
# End of macro NEXTW
b9fa			 
b9fa			.MENU: 
b9fa				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
b9fa 70				db WORD_SYS_CORE+92             
b9fb a3 ba			dw .ENDDISPLAY            
b9fd 05				db 4 + 1 
b9fe .. 00			db "MENU",0              
ba03				endm 
# End of macro CWHEAD
ba03			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
ba03			 
ba03			;		; get number of items on the stack 
ba03			; 
ba03				 
ba03					FORTH_DSP_VALUEHL 
ba03 cd aa 98			call macro_dsp_valuehl 
ba06				endm 
# End of macro FORTH_DSP_VALUEHL
ba06				 
ba06					if DEBUG_FORTH_WORDS_KEY 
ba06						DMARK "MNU" 
ba06 f5				push af  
ba07 3a 1b ba			ld a, (.dmark)  
ba0a 32 7a ee			ld (debug_mark),a  
ba0d 3a 1c ba			ld a, (.dmark+1)  
ba10 32 7b ee			ld (debug_mark+1),a  
ba13 3a 1d ba			ld a, (.dmark+2)  
ba16 32 7c ee			ld (debug_mark+2),a  
ba19 18 03			jr .pastdmark  
ba1b ..			.dmark: db "MNU"  
ba1e f1			.pastdmark: pop af  
ba1f			endm  
# End of macro DMARK
ba1f						CALLMONITOR 
ba1f cd 75 92			call break_point_state  
ba22				endm  
# End of macro CALLMONITOR
ba22					endif 
ba22			 
ba22 45					ld b, l	 
ba23 05					dec b 
ba24			 
ba24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba24 cd 46 99			call macro_forth_dsp_pop 
ba27				endm 
# End of macro FORTH_DSP_POP
ba27			 
ba27			 
ba27					; go directly through the stack to pluck out the string pointers and build an array 
ba27			 
ba27			;		FORTH_DSP 
ba27			 
ba27					; hl contains top most stack item 
ba27				 
ba27 11 75 e3				ld de, scratch 
ba2a			 
ba2a			.mbuild: 
ba2a			 
ba2a					FORTH_DSP_VALUEHL 
ba2a cd aa 98			call macro_dsp_valuehl 
ba2d				endm 
# End of macro FORTH_DSP_VALUEHL
ba2d			 
ba2d					if DEBUG_FORTH_WORDS 
ba2d						DMARK "MN3" 
ba2d f5				push af  
ba2e 3a 42 ba			ld a, (.dmark)  
ba31 32 7a ee			ld (debug_mark),a  
ba34 3a 43 ba			ld a, (.dmark+1)  
ba37 32 7b ee			ld (debug_mark+1),a  
ba3a 3a 44 ba			ld a, (.dmark+2)  
ba3d 32 7c ee			ld (debug_mark+2),a  
ba40 18 03			jr .pastdmark  
ba42 ..			.dmark: db "MN3"  
ba45 f1			.pastdmark: pop af  
ba46			endm  
# End of macro DMARK
ba46						CALLMONITOR 
ba46 cd 75 92			call break_point_state  
ba49				endm  
# End of macro CALLMONITOR
ba49					endif 
ba49 eb					ex de, hl 
ba4a 73					ld (hl), e 
ba4b 23					inc hl 
ba4c 72					ld (hl), d 
ba4d 23					inc hl 
ba4e eb					ex de, hl 
ba4f			 
ba4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba4f cd 46 99			call macro_forth_dsp_pop 
ba52				endm 
# End of macro FORTH_DSP_POP
ba52			 
ba52 10 d6				djnz .mbuild 
ba54			 
ba54					; done add term 
ba54			 
ba54 eb					ex de, hl 
ba55 36 00				ld (hl), 0 
ba57 23					inc hl 
ba58 36 00				ld (hl), 0 
ba5a			 
ba5a				 
ba5a					 
ba5a 21 75 e3				ld hl, scratch 
ba5d			 
ba5d					if DEBUG_FORTH_WORDS 
ba5d						DMARK "MNx" 
ba5d f5				push af  
ba5e 3a 72 ba			ld a, (.dmark)  
ba61 32 7a ee			ld (debug_mark),a  
ba64 3a 73 ba			ld a, (.dmark+1)  
ba67 32 7b ee			ld (debug_mark+1),a  
ba6a 3a 74 ba			ld a, (.dmark+2)  
ba6d 32 7c ee			ld (debug_mark+2),a  
ba70 18 03			jr .pastdmark  
ba72 ..			.dmark: db "MNx"  
ba75 f1			.pastdmark: pop af  
ba76			endm  
# End of macro DMARK
ba76						CALLMONITOR 
ba76 cd 75 92			call break_point_state  
ba79				endm  
# End of macro CALLMONITOR
ba79					endif 
ba79			 
ba79			 
ba79			 
ba79 3e 00				ld a, 0 
ba7b cd 65 88				call menu 
ba7e			 
ba7e			 
ba7e 6f					ld l, a 
ba7f 26 00				ld h, 0 
ba81			 
ba81					if DEBUG_FORTH_WORDS 
ba81						DMARK "MNr" 
ba81 f5				push af  
ba82 3a 96 ba			ld a, (.dmark)  
ba85 32 7a ee			ld (debug_mark),a  
ba88 3a 97 ba			ld a, (.dmark+1)  
ba8b 32 7b ee			ld (debug_mark+1),a  
ba8e 3a 98 ba			ld a, (.dmark+2)  
ba91 32 7c ee			ld (debug_mark+2),a  
ba94 18 03			jr .pastdmark  
ba96 ..			.dmark: db "MNr"  
ba99 f1			.pastdmark: pop af  
ba9a			endm  
# End of macro DMARK
ba9a						CALLMONITOR 
ba9a cd 75 92			call break_point_state  
ba9d				endm  
# End of macro CALLMONITOR
ba9d					endif 
ba9d			 
ba9d cd 0f 98				call forth_push_numhl 
baa0			 
baa0			 
baa0			 
baa0			 
baa0				       NEXTW 
baa0 c3 00 9a			jp macro_next 
baa3				endm 
# End of macro NEXTW
baa3			 
baa3			 
baa3			.ENDDISPLAY: 
baa3			 
baa3			; eof 
# End of file forth_words_display.asm
baa3			include "forth_words_str.asm" 
baa3			 
baa3			; | ## String Words 
baa3			 
baa3			.PTR:   
baa3			 
baa3				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
baa3 48				db WORD_SYS_CORE+52             
baa4 d0 ba			dw .STYPE            
baa6 04				db 3 + 1 
baa7 .. 00			db "PTR",0              
baab				endm 
# End of macro CWHEAD
baab			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
baab			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
baab			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
baab			 
baab					if DEBUG_FORTH_WORDS_KEY 
baab						DMARK "PTR" 
baab f5				push af  
baac 3a c0 ba			ld a, (.dmark)  
baaf 32 7a ee			ld (debug_mark),a  
bab2 3a c1 ba			ld a, (.dmark+1)  
bab5 32 7b ee			ld (debug_mark+1),a  
bab8 3a c2 ba			ld a, (.dmark+2)  
babb 32 7c ee			ld (debug_mark+2),a  
babe 18 03			jr .pastdmark  
bac0 ..			.dmark: db "PTR"  
bac3 f1			.pastdmark: pop af  
bac4			endm  
# End of macro DMARK
bac4						CALLMONITOR 
bac4 cd 75 92			call break_point_state  
bac7				endm  
# End of macro CALLMONITOR
bac7					endif 
bac7					FORTH_DSP_VALUEHL 
bac7 cd aa 98			call macro_dsp_valuehl 
baca				endm 
# End of macro FORTH_DSP_VALUEHL
baca cd 0f 98				call forth_push_numhl 
bacd			 
bacd			 
bacd					NEXTW 
bacd c3 00 9a			jp macro_next 
bad0				endm 
# End of macro NEXTW
bad0			.STYPE: 
bad0				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bad0 48				db WORD_SYS_CORE+52             
bad1 1f bb			dw .UPPER            
bad3 06				db 5 + 1 
bad4 .. 00			db "STYPE",0              
bada				endm 
# End of macro CWHEAD
bada			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bada					if DEBUG_FORTH_WORDS_KEY 
bada						DMARK "STY" 
bada f5				push af  
badb 3a ef ba			ld a, (.dmark)  
bade 32 7a ee			ld (debug_mark),a  
bae1 3a f0 ba			ld a, (.dmark+1)  
bae4 32 7b ee			ld (debug_mark+1),a  
bae7 3a f1 ba			ld a, (.dmark+2)  
baea 32 7c ee			ld (debug_mark+2),a  
baed 18 03			jr .pastdmark  
baef ..			.dmark: db "STY"  
baf2 f1			.pastdmark: pop af  
baf3			endm  
# End of macro DMARK
baf3						CALLMONITOR 
baf3 cd 75 92			call break_point_state  
baf6				endm  
# End of macro CALLMONITOR
baf6					endif 
baf6					FORTH_DSP 
baf6 cd 8f 98			call macro_forth_dsp 
baf9				endm 
# End of macro FORTH_DSP
baf9					;v5 FORTH_DSP_VALUE 
baf9			 
baf9 7e					ld a, (hl) 
bafa			 
bafa f5					push af 
bafb			 
bafb			; Dont destroy TOS		FORTH_DSP_POP 
bafb			 
bafb f1					pop af 
bafc			 
bafc fe 01				cp DS_TYPE_STR 
bafe 28 09				jr z, .typestr 
bb00			 
bb00 fe 02				cp DS_TYPE_INUM 
bb02 28 0a				jr z, .typeinum 
bb04			 
bb04 21 1d bb				ld hl, .tna 
bb07 18 0a				jr .tpush 
bb09			 
bb09 21 19 bb		.typestr:	ld hl, .tstr 
bb0c 18 05				jr .tpush 
bb0e 21 1b bb		.typeinum:	ld hl, .tinum 
bb11 18 00				jr .tpush 
bb13			 
bb13			.tpush: 
bb13			 
bb13 cd 21 98				call forth_push_str 
bb16			 
bb16					NEXTW 
bb16 c3 00 9a			jp macro_next 
bb19				endm 
# End of macro NEXTW
bb19 .. 00		.tstr:	db "s",0 
bb1b .. 00		.tinum:  db "i",0 
bb1d .. 00		.tna:   db "?", 0 
bb1f			 
bb1f			 
bb1f			.UPPER: 
bb1f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bb1f 48				db WORD_SYS_CORE+52             
bb20 5a bb			dw .LOWER            
bb22 06				db 5 + 1 
bb23 .. 00			db "UPPER",0              
bb29				endm 
# End of macro CWHEAD
bb29			; | UPPER ( s -- s ) Upper case string s  | DONE 
bb29					if DEBUG_FORTH_WORDS_KEY 
bb29						DMARK "UPR" 
bb29 f5				push af  
bb2a 3a 3e bb			ld a, (.dmark)  
bb2d 32 7a ee			ld (debug_mark),a  
bb30 3a 3f bb			ld a, (.dmark+1)  
bb33 32 7b ee			ld (debug_mark+1),a  
bb36 3a 40 bb			ld a, (.dmark+2)  
bb39 32 7c ee			ld (debug_mark+2),a  
bb3c 18 03			jr .pastdmark  
bb3e ..			.dmark: db "UPR"  
bb41 f1			.pastdmark: pop af  
bb42			endm  
# End of macro DMARK
bb42						CALLMONITOR 
bb42 cd 75 92			call break_point_state  
bb45				endm  
# End of macro CALLMONITOR
bb45					endif 
bb45			 
bb45					FORTH_DSP 
bb45 cd 8f 98			call macro_forth_dsp 
bb48				endm 
# End of macro FORTH_DSP
bb48					 
bb48			; TODO check is string type 
bb48			 
bb48					FORTH_DSP_VALUEHL 
bb48 cd aa 98			call macro_dsp_valuehl 
bb4b				endm 
# End of macro FORTH_DSP_VALUEHL
bb4b			; get pointer to string in hl 
bb4b			 
bb4b 7e			.toup:		ld a, (hl) 
bb4c fe 00				cp 0 
bb4e 28 07				jr z, .toupdone 
bb50			 
bb50 cd ca 8d				call to_upper 
bb53			 
bb53 77					ld (hl), a 
bb54 23					inc hl 
bb55 18 f4				jr .toup 
bb57			 
bb57					 
bb57			 
bb57			 
bb57			; for each char convert to upper 
bb57					 
bb57			.toupdone: 
bb57			 
bb57			 
bb57					NEXTW 
bb57 c3 00 9a			jp macro_next 
bb5a				endm 
# End of macro NEXTW
bb5a			.LOWER: 
bb5a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bb5a 48				db WORD_SYS_CORE+52             
bb5b 95 bb			dw .TCASE            
bb5d 06				db 5 + 1 
bb5e .. 00			db "LOWER",0              
bb64				endm 
# End of macro CWHEAD
bb64			; | LOWER ( s -- s ) Lower case string s  | DONE 
bb64					if DEBUG_FORTH_WORDS_KEY 
bb64						DMARK "LWR" 
bb64 f5				push af  
bb65 3a 79 bb			ld a, (.dmark)  
bb68 32 7a ee			ld (debug_mark),a  
bb6b 3a 7a bb			ld a, (.dmark+1)  
bb6e 32 7b ee			ld (debug_mark+1),a  
bb71 3a 7b bb			ld a, (.dmark+2)  
bb74 32 7c ee			ld (debug_mark+2),a  
bb77 18 03			jr .pastdmark  
bb79 ..			.dmark: db "LWR"  
bb7c f1			.pastdmark: pop af  
bb7d			endm  
# End of macro DMARK
bb7d						CALLMONITOR 
bb7d cd 75 92			call break_point_state  
bb80				endm  
# End of macro CALLMONITOR
bb80					endif 
bb80			 
bb80					FORTH_DSP 
bb80 cd 8f 98			call macro_forth_dsp 
bb83				endm 
# End of macro FORTH_DSP
bb83					 
bb83			; TODO check is string type 
bb83			 
bb83					FORTH_DSP_VALUEHL 
bb83 cd aa 98			call macro_dsp_valuehl 
bb86				endm 
# End of macro FORTH_DSP_VALUEHL
bb86			; get pointer to string in hl 
bb86			 
bb86 7e			.tolow:		ld a, (hl) 
bb87 fe 00				cp 0 
bb89 28 07				jr z, .tolowdone 
bb8b			 
bb8b cd d3 8d				call to_lower 
bb8e			 
bb8e 77					ld (hl), a 
bb8f 23					inc hl 
bb90 18 f4				jr .tolow 
bb92			 
bb92					 
bb92			 
bb92			 
bb92			; for each char convert to low 
bb92					 
bb92			.tolowdone: 
bb92					NEXTW 
bb92 c3 00 9a			jp macro_next 
bb95				endm 
# End of macro NEXTW
bb95			.TCASE: 
bb95				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bb95 48				db WORD_SYS_CORE+52             
bb96 cb bc			dw .SUBSTR            
bb98 06				db 5 + 1 
bb99 .. 00			db "TCASE",0              
bb9f				endm 
# End of macro CWHEAD
bb9f			; | TCASE ( s -- s ) Title case string s  | DONE 
bb9f					if DEBUG_FORTH_WORDS_KEY 
bb9f						DMARK "TCS" 
bb9f f5				push af  
bba0 3a b4 bb			ld a, (.dmark)  
bba3 32 7a ee			ld (debug_mark),a  
bba6 3a b5 bb			ld a, (.dmark+1)  
bba9 32 7b ee			ld (debug_mark+1),a  
bbac 3a b6 bb			ld a, (.dmark+2)  
bbaf 32 7c ee			ld (debug_mark+2),a  
bbb2 18 03			jr .pastdmark  
bbb4 ..			.dmark: db "TCS"  
bbb7 f1			.pastdmark: pop af  
bbb8			endm  
# End of macro DMARK
bbb8						CALLMONITOR 
bbb8 cd 75 92			call break_point_state  
bbbb				endm  
# End of macro CALLMONITOR
bbbb					endif 
bbbb			 
bbbb					FORTH_DSP 
bbbb cd 8f 98			call macro_forth_dsp 
bbbe				endm 
# End of macro FORTH_DSP
bbbe					 
bbbe			; TODO check is string type 
bbbe			 
bbbe					FORTH_DSP_VALUEHL 
bbbe cd aa 98			call macro_dsp_valuehl 
bbc1				endm 
# End of macro FORTH_DSP_VALUEHL
bbc1			; get pointer to string in hl 
bbc1			 
bbc1					if DEBUG_FORTH_WORDS 
bbc1						DMARK "TC1" 
bbc1 f5				push af  
bbc2 3a d6 bb			ld a, (.dmark)  
bbc5 32 7a ee			ld (debug_mark),a  
bbc8 3a d7 bb			ld a, (.dmark+1)  
bbcb 32 7b ee			ld (debug_mark+1),a  
bbce 3a d8 bb			ld a, (.dmark+2)  
bbd1 32 7c ee			ld (debug_mark+2),a  
bbd4 18 03			jr .pastdmark  
bbd6 ..			.dmark: db "TC1"  
bbd9 f1			.pastdmark: pop af  
bbda			endm  
# End of macro DMARK
bbda						CALLMONITOR 
bbda cd 75 92			call break_point_state  
bbdd				endm  
# End of macro CALLMONITOR
bbdd					endif 
bbdd			 
bbdd					; first time in turn to upper case first char 
bbdd			 
bbdd 7e					ld a, (hl) 
bbde c3 68 bc				jp .totsiptou 
bbe1			 
bbe1			 
bbe1 7e			.tot:		ld a, (hl) 
bbe2 fe 00				cp 0 
bbe4 ca ac bc				jp z, .totdone 
bbe7			 
bbe7					if DEBUG_FORTH_WORDS 
bbe7						DMARK "TC2" 
bbe7 f5				push af  
bbe8 3a fc bb			ld a, (.dmark)  
bbeb 32 7a ee			ld (debug_mark),a  
bbee 3a fd bb			ld a, (.dmark+1)  
bbf1 32 7b ee			ld (debug_mark+1),a  
bbf4 3a fe bb			ld a, (.dmark+2)  
bbf7 32 7c ee			ld (debug_mark+2),a  
bbfa 18 03			jr .pastdmark  
bbfc ..			.dmark: db "TC2"  
bbff f1			.pastdmark: pop af  
bc00			endm  
# End of macro DMARK
bc00						CALLMONITOR 
bc00 cd 75 92			call break_point_state  
bc03				endm  
# End of macro CALLMONITOR
bc03					endif 
bc03					; check to see if current char is a space 
bc03			 
bc03 fe 20				cp ' ' 
bc05 28 21				jr z, .totsp 
bc07 cd d3 8d				call to_lower 
bc0a					if DEBUG_FORTH_WORDS 
bc0a						DMARK "TC3" 
bc0a f5				push af  
bc0b 3a 1f bc			ld a, (.dmark)  
bc0e 32 7a ee			ld (debug_mark),a  
bc11 3a 20 bc			ld a, (.dmark+1)  
bc14 32 7b ee			ld (debug_mark+1),a  
bc17 3a 21 bc			ld a, (.dmark+2)  
bc1a 32 7c ee			ld (debug_mark+2),a  
bc1d 18 03			jr .pastdmark  
bc1f ..			.dmark: db "TC3"  
bc22 f1			.pastdmark: pop af  
bc23			endm  
# End of macro DMARK
bc23						CALLMONITOR 
bc23 cd 75 92			call break_point_state  
bc26				endm  
# End of macro CALLMONITOR
bc26					endif 
bc26 18 63				jr .totnxt 
bc28			 
bc28			.totsp:         ; on a space, find next char which should be upper 
bc28			 
bc28					if DEBUG_FORTH_WORDS 
bc28						DMARK "TC4" 
bc28 f5				push af  
bc29 3a 3d bc			ld a, (.dmark)  
bc2c 32 7a ee			ld (debug_mark),a  
bc2f 3a 3e bc			ld a, (.dmark+1)  
bc32 32 7b ee			ld (debug_mark+1),a  
bc35 3a 3f bc			ld a, (.dmark+2)  
bc38 32 7c ee			ld (debug_mark+2),a  
bc3b 18 03			jr .pastdmark  
bc3d ..			.dmark: db "TC4"  
bc40 f1			.pastdmark: pop af  
bc41			endm  
# End of macro DMARK
bc41						CALLMONITOR 
bc41 cd 75 92			call break_point_state  
bc44				endm  
# End of macro CALLMONITOR
bc44					endif 
bc44					;; 
bc44			 
bc44 fe 20				cp ' ' 
bc46 20 20				jr nz, .totsiptou 
bc48 23					inc hl 
bc49 7e					ld a, (hl) 
bc4a					if DEBUG_FORTH_WORDS 
bc4a						DMARK "TC5" 
bc4a f5				push af  
bc4b 3a 5f bc			ld a, (.dmark)  
bc4e 32 7a ee			ld (debug_mark),a  
bc51 3a 60 bc			ld a, (.dmark+1)  
bc54 32 7b ee			ld (debug_mark+1),a  
bc57 3a 61 bc			ld a, (.dmark+2)  
bc5a 32 7c ee			ld (debug_mark+2),a  
bc5d 18 03			jr .pastdmark  
bc5f ..			.dmark: db "TC5"  
bc62 f1			.pastdmark: pop af  
bc63			endm  
# End of macro DMARK
bc63						CALLMONITOR 
bc63 cd 75 92			call break_point_state  
bc66				endm  
# End of macro CALLMONITOR
bc66					endif 
bc66 18 c0				jr .totsp 
bc68 fe 00		.totsiptou:    cp 0 
bc6a 28 40				jr z, .totdone 
bc6c					; not space and not zero term so upper case it 
bc6c cd ca 8d				call to_upper 
bc6f			 
bc6f					if DEBUG_FORTH_WORDS 
bc6f						DMARK "TC6" 
bc6f f5				push af  
bc70 3a 84 bc			ld a, (.dmark)  
bc73 32 7a ee			ld (debug_mark),a  
bc76 3a 85 bc			ld a, (.dmark+1)  
bc79 32 7b ee			ld (debug_mark+1),a  
bc7c 3a 86 bc			ld a, (.dmark+2)  
bc7f 32 7c ee			ld (debug_mark+2),a  
bc82 18 03			jr .pastdmark  
bc84 ..			.dmark: db "TC6"  
bc87 f1			.pastdmark: pop af  
bc88			endm  
# End of macro DMARK
bc88						CALLMONITOR 
bc88 cd 75 92			call break_point_state  
bc8b				endm  
# End of macro CALLMONITOR
bc8b					endif 
bc8b			 
bc8b			 
bc8b			.totnxt: 
bc8b			 
bc8b 77					ld (hl), a 
bc8c 23					inc hl 
bc8d					if DEBUG_FORTH_WORDS 
bc8d						DMARK "TC7" 
bc8d f5				push af  
bc8e 3a a2 bc			ld a, (.dmark)  
bc91 32 7a ee			ld (debug_mark),a  
bc94 3a a3 bc			ld a, (.dmark+1)  
bc97 32 7b ee			ld (debug_mark+1),a  
bc9a 3a a4 bc			ld a, (.dmark+2)  
bc9d 32 7c ee			ld (debug_mark+2),a  
bca0 18 03			jr .pastdmark  
bca2 ..			.dmark: db "TC7"  
bca5 f1			.pastdmark: pop af  
bca6			endm  
# End of macro DMARK
bca6						CALLMONITOR 
bca6 cd 75 92			call break_point_state  
bca9				endm  
# End of macro CALLMONITOR
bca9					endif 
bca9 c3 e1 bb				jp .tot 
bcac			 
bcac					 
bcac			 
bcac			 
bcac			; for each char convert to low 
bcac					 
bcac			.totdone: 
bcac					if DEBUG_FORTH_WORDS 
bcac						DMARK "TCd" 
bcac f5				push af  
bcad 3a c1 bc			ld a, (.dmark)  
bcb0 32 7a ee			ld (debug_mark),a  
bcb3 3a c2 bc			ld a, (.dmark+1)  
bcb6 32 7b ee			ld (debug_mark+1),a  
bcb9 3a c3 bc			ld a, (.dmark+2)  
bcbc 32 7c ee			ld (debug_mark+2),a  
bcbf 18 03			jr .pastdmark  
bcc1 ..			.dmark: db "TCd"  
bcc4 f1			.pastdmark: pop af  
bcc5			endm  
# End of macro DMARK
bcc5						CALLMONITOR 
bcc5 cd 75 92			call break_point_state  
bcc8				endm  
# End of macro CALLMONITOR
bcc8					endif 
bcc8					NEXTW 
bcc8 c3 00 9a			jp macro_next 
bccb				endm 
# End of macro NEXTW
bccb			 
bccb			.SUBSTR: 
bccb				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bccb 48				db WORD_SYS_CORE+52             
bccc 29 bd			dw .LEFT            
bcce 07				db 6 + 1 
bccf .. 00			db "SUBSTR",0              
bcd6				endm 
# End of macro CWHEAD
bcd6			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bcd6			 
bcd6					if DEBUG_FORTH_WORDS_KEY 
bcd6						DMARK "SST" 
bcd6 f5				push af  
bcd7 3a eb bc			ld a, (.dmark)  
bcda 32 7a ee			ld (debug_mark),a  
bcdd 3a ec bc			ld a, (.dmark+1)  
bce0 32 7b ee			ld (debug_mark+1),a  
bce3 3a ed bc			ld a, (.dmark+2)  
bce6 32 7c ee			ld (debug_mark+2),a  
bce9 18 03			jr .pastdmark  
bceb ..			.dmark: db "SST"  
bcee f1			.pastdmark: pop af  
bcef			endm  
# End of macro DMARK
bcef						CALLMONITOR 
bcef cd 75 92			call break_point_state  
bcf2				endm  
# End of macro CALLMONITOR
bcf2					endif 
bcf2			; TODO check string type 
bcf2					FORTH_DSP_VALUEHL 
bcf2 cd aa 98			call macro_dsp_valuehl 
bcf5				endm 
# End of macro FORTH_DSP_VALUEHL
bcf5			 
bcf5 e5					push hl      ; string length 
bcf6			 
bcf6					FORTH_DSP_POP 
bcf6 cd 46 99			call macro_forth_dsp_pop 
bcf9				endm 
# End of macro FORTH_DSP_POP
bcf9			 
bcf9					FORTH_DSP_VALUEHL 
bcf9 cd aa 98			call macro_dsp_valuehl 
bcfc				endm 
# End of macro FORTH_DSP_VALUEHL
bcfc			 
bcfc e5					push hl     ; start char 
bcfd			 
bcfd					FORTH_DSP_POP 
bcfd cd 46 99			call macro_forth_dsp_pop 
bd00				endm 
# End of macro FORTH_DSP_POP
bd00			 
bd00			 
bd00					FORTH_DSP_VALUE 
bd00 cd 93 98			call macro_forth_dsp_value 
bd03				endm 
# End of macro FORTH_DSP_VALUE
bd03			 
bd03 d1					pop de    ; get start post offset 
bd04			 
bd04 19					add hl, de    ; starting offset 
bd05			 
bd05 c1					pop bc 
bd06 c5					push bc      ; grab size of string 
bd07			 
bd07 e5					push hl    ; save string start  
bd08			 
bd08 26 00				ld h, 0 
bd0a 69					ld l, c 
bd0b 23					inc hl 
bd0c 23					inc hl 
bd0d			 
bd0d cd 24 8f				call malloc 
bd10				if DEBUG_FORTH_MALLOC_GUARD 
bd10 cc 3f c3				call z,malloc_error 
bd13				endif 
bd13			 
bd13 eb					ex de, hl      ; save malloc area for string copy 
bd14 e1					pop hl    ; get back source 
bd15 c1					pop bc    ; get length of string back 
bd16			 
bd16 d5					push de    ; save malloc area for after we push 
bd17 ed b0				ldir     ; copy substr 
bd19			 
bd19			 
bd19 eb					ex de, hl 
bd1a 3e 00				ld a, 0 
bd1c 77					ld (hl), a   ; term substr 
bd1d			 
bd1d					 
bd1d e1					pop hl    ; get malloc so we can push it 
bd1e e5					push hl   ; save so we can free it afterwards 
bd1f			 
bd1f cd 21 98				call forth_push_str 
bd22			 
bd22 e1					pop hl 
bd23 cd ee 8f				call free 
bd26			 
bd26					 
bd26					 
bd26			 
bd26			 
bd26					NEXTW 
bd26 c3 00 9a			jp macro_next 
bd29				endm 
# End of macro NEXTW
bd29			 
bd29			.LEFT: 
bd29				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bd29 48				db WORD_SYS_CORE+52             
bd2a 51 bd			dw .RIGHT            
bd2c 05				db 4 + 1 
bd2d .. 00			db "LEFT",0              
bd32				endm 
# End of macro CWHEAD
bd32			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bd32					if DEBUG_FORTH_WORDS_KEY 
bd32						DMARK "LEF" 
bd32 f5				push af  
bd33 3a 47 bd			ld a, (.dmark)  
bd36 32 7a ee			ld (debug_mark),a  
bd39 3a 48 bd			ld a, (.dmark+1)  
bd3c 32 7b ee			ld (debug_mark+1),a  
bd3f 3a 49 bd			ld a, (.dmark+2)  
bd42 32 7c ee			ld (debug_mark+2),a  
bd45 18 03			jr .pastdmark  
bd47 ..			.dmark: db "LEF"  
bd4a f1			.pastdmark: pop af  
bd4b			endm  
# End of macro DMARK
bd4b						CALLMONITOR 
bd4b cd 75 92			call break_point_state  
bd4e				endm  
# End of macro CALLMONITOR
bd4e					endif 
bd4e			 
bd4e					NEXTW 
bd4e c3 00 9a			jp macro_next 
bd51				endm 
# End of macro NEXTW
bd51			.RIGHT: 
bd51				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bd51 48				db WORD_SYS_CORE+52             
bd52 7a bd			dw .STR2NUM            
bd54 06				db 5 + 1 
bd55 .. 00			db "RIGHT",0              
bd5b				endm 
# End of macro CWHEAD
bd5b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bd5b					if DEBUG_FORTH_WORDS_KEY 
bd5b						DMARK "RIG" 
bd5b f5				push af  
bd5c 3a 70 bd			ld a, (.dmark)  
bd5f 32 7a ee			ld (debug_mark),a  
bd62 3a 71 bd			ld a, (.dmark+1)  
bd65 32 7b ee			ld (debug_mark+1),a  
bd68 3a 72 bd			ld a, (.dmark+2)  
bd6b 32 7c ee			ld (debug_mark+2),a  
bd6e 18 03			jr .pastdmark  
bd70 ..			.dmark: db "RIG"  
bd73 f1			.pastdmark: pop af  
bd74			endm  
# End of macro DMARK
bd74						CALLMONITOR 
bd74 cd 75 92			call break_point_state  
bd77				endm  
# End of macro CALLMONITOR
bd77					endif 
bd77			 
bd77					NEXTW 
bd77 c3 00 9a			jp macro_next 
bd7a				endm 
# End of macro NEXTW
bd7a			 
bd7a			 
bd7a			.STR2NUM: 
bd7a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bd7a 48				db WORD_SYS_CORE+52             
bd7b 06 be			dw .NUM2STR            
bd7d 08				db 7 + 1 
bd7e .. 00			db "STR2NUM",0              
bd86				endm 
# End of macro CWHEAD
bd86			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bd86			 
bd86			 
bd86			; TODO STR type check to do 
bd86					if DEBUG_FORTH_WORDS_KEY 
bd86						DMARK "S2N" 
bd86 f5				push af  
bd87 3a 9b bd			ld a, (.dmark)  
bd8a 32 7a ee			ld (debug_mark),a  
bd8d 3a 9c bd			ld a, (.dmark+1)  
bd90 32 7b ee			ld (debug_mark+1),a  
bd93 3a 9d bd			ld a, (.dmark+2)  
bd96 32 7c ee			ld (debug_mark+2),a  
bd99 18 03			jr .pastdmark  
bd9b ..			.dmark: db "S2N"  
bd9e f1			.pastdmark: pop af  
bd9f			endm  
# End of macro DMARK
bd9f						CALLMONITOR 
bd9f cd 75 92			call break_point_state  
bda2				endm  
# End of macro CALLMONITOR
bda2					endif 
bda2			 
bda2					;FORTH_DSP 
bda2					FORTH_DSP_VALUE 
bda2 cd 93 98			call macro_forth_dsp_value 
bda5				endm 
# End of macro FORTH_DSP_VALUE
bda5					;inc hl 
bda5			 
bda5 eb					ex de, hl 
bda6					if DEBUG_FORTH_WORDS 
bda6						DMARK "S2a" 
bda6 f5				push af  
bda7 3a bb bd			ld a, (.dmark)  
bdaa 32 7a ee			ld (debug_mark),a  
bdad 3a bc bd			ld a, (.dmark+1)  
bdb0 32 7b ee			ld (debug_mark+1),a  
bdb3 3a bd bd			ld a, (.dmark+2)  
bdb6 32 7c ee			ld (debug_mark+2),a  
bdb9 18 03			jr .pastdmark  
bdbb ..			.dmark: db "S2a"  
bdbe f1			.pastdmark: pop af  
bdbf			endm  
# End of macro DMARK
bdbf						CALLMONITOR 
bdbf cd 75 92			call break_point_state  
bdc2				endm  
# End of macro CALLMONITOR
bdc2					endif 
bdc2 cd 52 8e				call string_to_uint16 
bdc5			 
bdc5					if DEBUG_FORTH_WORDS 
bdc5						DMARK "S2b" 
bdc5 f5				push af  
bdc6 3a da bd			ld a, (.dmark)  
bdc9 32 7a ee			ld (debug_mark),a  
bdcc 3a db bd			ld a, (.dmark+1)  
bdcf 32 7b ee			ld (debug_mark+1),a  
bdd2 3a dc bd			ld a, (.dmark+2)  
bdd5 32 7c ee			ld (debug_mark+2),a  
bdd8 18 03			jr .pastdmark  
bdda ..			.dmark: db "S2b"  
bddd f1			.pastdmark: pop af  
bdde			endm  
# End of macro DMARK
bdde						CALLMONITOR 
bdde cd 75 92			call break_point_state  
bde1				endm  
# End of macro CALLMONITOR
bde1					endif 
bde1			;		push hl 
bde1					FORTH_DSP_POP 
bde1 cd 46 99			call macro_forth_dsp_pop 
bde4				endm 
# End of macro FORTH_DSP_POP
bde4			;		pop hl 
bde4					 
bde4					if DEBUG_FORTH_WORDS 
bde4						DMARK "S2b" 
bde4 f5				push af  
bde5 3a f9 bd			ld a, (.dmark)  
bde8 32 7a ee			ld (debug_mark),a  
bdeb 3a fa bd			ld a, (.dmark+1)  
bdee 32 7b ee			ld (debug_mark+1),a  
bdf1 3a fb bd			ld a, (.dmark+2)  
bdf4 32 7c ee			ld (debug_mark+2),a  
bdf7 18 03			jr .pastdmark  
bdf9 ..			.dmark: db "S2b"  
bdfc f1			.pastdmark: pop af  
bdfd			endm  
# End of macro DMARK
bdfd						CALLMONITOR 
bdfd cd 75 92			call break_point_state  
be00				endm  
# End of macro CALLMONITOR
be00					endif 
be00 cd 0f 98				call forth_push_numhl	 
be03			 
be03				 
be03				       NEXTW 
be03 c3 00 9a			jp macro_next 
be06				endm 
# End of macro NEXTW
be06			.NUM2STR: 
be06				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
be06 48				db WORD_SYS_CORE+52             
be07 15 be			dw .CONCAT            
be09 08				db 7 + 1 
be0a .. 00			db "NUM2STR",0              
be12				endm 
# End of macro CWHEAD
be12			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
be12			 
be12			;		; malloc a string to target 
be12			;		ld hl, 10     ; TODO max string size should be fine 
be12			;		call malloc 
be12			;		push hl    ; save malloc location 
be12			; 
be12			; 
be12			;; TODO check int type 
be12			;		FORTH_DSP_VALUEHL 
be12			;		ld a, l 
be12			;		call DispAToASCII   
be12			;;TODO need to chage above call to dump into string 
be12			; 
be12			; 
be12			 
be12				       NEXTW 
be12 c3 00 9a			jp macro_next 
be15				endm 
# End of macro NEXTW
be15			 
be15			.CONCAT: 
be15				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
be15 48				db WORD_SYS_CORE+52             
be16 c8 be			dw .FIND            
be18 07				db 6 + 1 
be19 .. 00			db "CONCAT",0              
be20				endm 
# End of macro CWHEAD
be20			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
be20			 
be20			; TODO check string type 
be20			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
be20			 
be20					if DEBUG_FORTH_WORDS_KEY 
be20						DMARK "CON" 
be20 f5				push af  
be21 3a 35 be			ld a, (.dmark)  
be24 32 7a ee			ld (debug_mark),a  
be27 3a 36 be			ld a, (.dmark+1)  
be2a 32 7b ee			ld (debug_mark+1),a  
be2d 3a 37 be			ld a, (.dmark+2)  
be30 32 7c ee			ld (debug_mark+2),a  
be33 18 03			jr .pastdmark  
be35 ..			.dmark: db "CON"  
be38 f1			.pastdmark: pop af  
be39			endm  
# End of macro DMARK
be39						CALLMONITOR 
be39 cd 75 92			call break_point_state  
be3c				endm  
# End of macro CALLMONITOR
be3c					endif 
be3c			 
be3c			 
be3c					FORTH_DSP_VALUE 
be3c cd 93 98			call macro_forth_dsp_value 
be3f				endm 
# End of macro FORTH_DSP_VALUE
be3f e5					push hl   ; s2 
be40			 
be40					FORTH_DSP_POP 
be40 cd 46 99			call macro_forth_dsp_pop 
be43				endm 
# End of macro FORTH_DSP_POP
be43			 
be43					FORTH_DSP_VALUE 
be43 cd 93 98			call macro_forth_dsp_value 
be46				endm 
# End of macro FORTH_DSP_VALUE
be46			 
be46 e5					push hl   ; s1 
be47			 
be47					FORTH_DSP_POP 
be47 cd 46 99			call macro_forth_dsp_pop 
be4a				endm 
# End of macro FORTH_DSP_POP
be4a					 
be4a			 
be4a					; copy s1 
be4a			 
be4a				 
be4a					; save ptr 
be4a e1					pop hl  
be4b e5					push hl 
be4c 3e 00				ld a, 0 
be4e cd c6 8e				call strlent 
be51					;inc hl    ; zer0 
be51 06 00				ld b, 0 
be53 4d					ld c, l 
be54 e1					pop hl		 
be55 11 75 e3				ld de, scratch	 
be58					if DEBUG_FORTH_WORDS 
be58						DMARK "CO1" 
be58 f5				push af  
be59 3a 6d be			ld a, (.dmark)  
be5c 32 7a ee			ld (debug_mark),a  
be5f 3a 6e be			ld a, (.dmark+1)  
be62 32 7b ee			ld (debug_mark+1),a  
be65 3a 6f be			ld a, (.dmark+2)  
be68 32 7c ee			ld (debug_mark+2),a  
be6b 18 03			jr .pastdmark  
be6d ..			.dmark: db "CO1"  
be70 f1			.pastdmark: pop af  
be71			endm  
# End of macro DMARK
be71						CALLMONITOR 
be71 cd 75 92			call break_point_state  
be74				endm  
# End of macro CALLMONITOR
be74					endif 
be74 ed b0				ldir 
be76			 
be76 e1					pop hl 
be77 e5					push hl 
be78 d5					push de 
be79			 
be79			 
be79 3e 00				ld a, 0 
be7b cd c6 8e				call strlent 
be7e 23					inc hl    ; zer0 
be7f 23					inc hl 
be80 06 00				ld b, 0 
be82 4d					ld c, l 
be83 d1					pop de 
be84 e1					pop hl		 
be85					if DEBUG_FORTH_WORDS 
be85						DMARK "CO2" 
be85 f5				push af  
be86 3a 9a be			ld a, (.dmark)  
be89 32 7a ee			ld (debug_mark),a  
be8c 3a 9b be			ld a, (.dmark+1)  
be8f 32 7b ee			ld (debug_mark+1),a  
be92 3a 9c be			ld a, (.dmark+2)  
be95 32 7c ee			ld (debug_mark+2),a  
be98 18 03			jr .pastdmark  
be9a ..			.dmark: db "CO2"  
be9d f1			.pastdmark: pop af  
be9e			endm  
# End of macro DMARK
be9e						CALLMONITOR 
be9e cd 75 92			call break_point_state  
bea1				endm  
# End of macro CALLMONITOR
bea1					endif 
bea1 ed b0				ldir 
bea3			 
bea3			 
bea3			 
bea3 21 75 e3				ld hl, scratch 
bea6					if DEBUG_FORTH_WORDS 
bea6						DMARK "CO5" 
bea6 f5				push af  
bea7 3a bb be			ld a, (.dmark)  
beaa 32 7a ee			ld (debug_mark),a  
bead 3a bc be			ld a, (.dmark+1)  
beb0 32 7b ee			ld (debug_mark+1),a  
beb3 3a bd be			ld a, (.dmark+2)  
beb6 32 7c ee			ld (debug_mark+2),a  
beb9 18 03			jr .pastdmark  
bebb ..			.dmark: db "CO5"  
bebe f1			.pastdmark: pop af  
bebf			endm  
# End of macro DMARK
bebf						CALLMONITOR 
bebf cd 75 92			call break_point_state  
bec2				endm  
# End of macro CALLMONITOR
bec2					endif 
bec2			 
bec2 cd 21 98				call forth_push_str 
bec5			 
bec5			 
bec5			 
bec5			 
bec5				       NEXTW 
bec5 c3 00 9a			jp macro_next 
bec8				endm 
# End of macro NEXTW
bec8			 
bec8			 
bec8			.FIND: 
bec8				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bec8 4b				db WORD_SYS_CORE+55             
bec9 86 bf			dw .LEN            
becb 05				db 4 + 1 
becc .. 00			db "FIND",0              
bed1				endm 
# End of macro CWHEAD
bed1			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bed1			 
bed1					if DEBUG_FORTH_WORDS_KEY 
bed1						DMARK "FND" 
bed1 f5				push af  
bed2 3a e6 be			ld a, (.dmark)  
bed5 32 7a ee			ld (debug_mark),a  
bed8 3a e7 be			ld a, (.dmark+1)  
bedb 32 7b ee			ld (debug_mark+1),a  
bede 3a e8 be			ld a, (.dmark+2)  
bee1 32 7c ee			ld (debug_mark+2),a  
bee4 18 03			jr .pastdmark  
bee6 ..			.dmark: db "FND"  
bee9 f1			.pastdmark: pop af  
beea			endm  
# End of macro DMARK
beea						CALLMONITOR 
beea cd 75 92			call break_point_state  
beed				endm  
# End of macro CALLMONITOR
beed					endif 
beed			 
beed			; TODO check string type 
beed					FORTH_DSP_VALUE 
beed cd 93 98			call macro_forth_dsp_value 
bef0				endm 
# End of macro FORTH_DSP_VALUE
bef0			 
bef0 e5					push hl    
bef1 7e					ld a,(hl)    ; char to find   
bef2			; TODO change char to substr 
bef2			 
bef2 f5					push af 
bef3					 
bef3			 
bef3			 
bef3					if DEBUG_FORTH_WORDS 
bef3						DMARK "FN1" 
bef3 f5				push af  
bef4 3a 08 bf			ld a, (.dmark)  
bef7 32 7a ee			ld (debug_mark),a  
befa 3a 09 bf			ld a, (.dmark+1)  
befd 32 7b ee			ld (debug_mark+1),a  
bf00 3a 0a bf			ld a, (.dmark+2)  
bf03 32 7c ee			ld (debug_mark+2),a  
bf06 18 03			jr .pastdmark  
bf08 ..			.dmark: db "FN1"  
bf0b f1			.pastdmark: pop af  
bf0c			endm  
# End of macro DMARK
bf0c						CALLMONITOR 
bf0c cd 75 92			call break_point_state  
bf0f				endm  
# End of macro CALLMONITOR
bf0f					endif 
bf0f			 
bf0f					FORTH_DSP_POP 
bf0f cd 46 99			call macro_forth_dsp_pop 
bf12				endm 
# End of macro FORTH_DSP_POP
bf12			 
bf12					; string to search 
bf12			 
bf12					FORTH_DSP_VALUE 
bf12 cd 93 98			call macro_forth_dsp_value 
bf15				endm 
# End of macro FORTH_DSP_VALUE
bf15			 
bf15 d1					pop de  ; d is char to find  
bf16			 
bf16					if DEBUG_FORTH_WORDS 
bf16						DMARK "FN2" 
bf16 f5				push af  
bf17 3a 2b bf			ld a, (.dmark)  
bf1a 32 7a ee			ld (debug_mark),a  
bf1d 3a 2c bf			ld a, (.dmark+1)  
bf20 32 7b ee			ld (debug_mark+1),a  
bf23 3a 2d bf			ld a, (.dmark+2)  
bf26 32 7c ee			ld (debug_mark+2),a  
bf29 18 03			jr .pastdmark  
bf2b ..			.dmark: db "FN2"  
bf2e f1			.pastdmark: pop af  
bf2f			endm  
# End of macro DMARK
bf2f						CALLMONITOR 
bf2f cd 75 92			call break_point_state  
bf32				endm  
# End of macro CALLMONITOR
bf32					endif 
bf32					 
bf32 01 00 00				ld bc, 0 
bf35 7e			.findchar:      ld a,(hl) 
bf36 fe 00				cp 0   		 
bf38 28 27				jr z, .finddone     
bf3a ba					cp d 
bf3b 28 20				jr z, .foundchar 
bf3d 03					inc bc 
bf3e 23					inc hl 
bf3f					if DEBUG_FORTH_WORDS 
bf3f						DMARK "FN3" 
bf3f f5				push af  
bf40 3a 54 bf			ld a, (.dmark)  
bf43 32 7a ee			ld (debug_mark),a  
bf46 3a 55 bf			ld a, (.dmark+1)  
bf49 32 7b ee			ld (debug_mark+1),a  
bf4c 3a 56 bf			ld a, (.dmark+2)  
bf4f 32 7c ee			ld (debug_mark+2),a  
bf52 18 03			jr .pastdmark  
bf54 ..			.dmark: db "FN3"  
bf57 f1			.pastdmark: pop af  
bf58			endm  
# End of macro DMARK
bf58						CALLMONITOR 
bf58 cd 75 92			call break_point_state  
bf5b				endm  
# End of macro CALLMONITOR
bf5b					endif 
bf5b 18 d8				jr .findchar 
bf5d			 
bf5d			 
bf5d c5			.foundchar:	push bc 
bf5e e1					pop hl 
bf5f 18 03				jr .findexit 
bf61			 
bf61			 
bf61							 
bf61			 
bf61			.finddone:     ; got to end of string with no find 
bf61 21 00 00				ld hl, 0 
bf64			.findexit: 
bf64			 
bf64					if DEBUG_FORTH_WORDS 
bf64						DMARK "FNd" 
bf64 f5				push af  
bf65 3a 79 bf			ld a, (.dmark)  
bf68 32 7a ee			ld (debug_mark),a  
bf6b 3a 7a bf			ld a, (.dmark+1)  
bf6e 32 7b ee			ld (debug_mark+1),a  
bf71 3a 7b bf			ld a, (.dmark+2)  
bf74 32 7c ee			ld (debug_mark+2),a  
bf77 18 03			jr .pastdmark  
bf79 ..			.dmark: db "FNd"  
bf7c f1			.pastdmark: pop af  
bf7d			endm  
# End of macro DMARK
bf7d						CALLMONITOR 
bf7d cd 75 92			call break_point_state  
bf80				endm  
# End of macro CALLMONITOR
bf80					endif 
bf80 cd 0f 98			call forth_push_numhl 
bf83			 
bf83				       NEXTW 
bf83 c3 00 9a			jp macro_next 
bf86				endm 
# End of macro NEXTW
bf86			 
bf86			.LEN: 
bf86				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
bf86 4c				db WORD_SYS_CORE+56             
bf87 bb bf			dw .CHAR            
bf89 06				db 5 + 1 
bf8a .. 00			db "COUNT",0              
bf90				endm 
# End of macro CWHEAD
bf90			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
bf90			 
bf90					if DEBUG_FORTH_WORDS_KEY 
bf90						DMARK "CNT" 
bf90 f5				push af  
bf91 3a a5 bf			ld a, (.dmark)  
bf94 32 7a ee			ld (debug_mark),a  
bf97 3a a6 bf			ld a, (.dmark+1)  
bf9a 32 7b ee			ld (debug_mark+1),a  
bf9d 3a a7 bf			ld a, (.dmark+2)  
bfa0 32 7c ee			ld (debug_mark+2),a  
bfa3 18 03			jr .pastdmark  
bfa5 ..			.dmark: db "CNT"  
bfa8 f1			.pastdmark: pop af  
bfa9			endm  
# End of macro DMARK
bfa9						CALLMONITOR 
bfa9 cd 75 92			call break_point_state  
bfac				endm  
# End of macro CALLMONITOR
bfac					endif 
bfac			; TODO check string type 
bfac					FORTH_DSP 
bfac cd 8f 98			call macro_forth_dsp 
bfaf				endm 
# End of macro FORTH_DSP
bfaf					;v5FORTH_DSP_VALUE 
bfaf			 
bfaf 23					inc hl 
bfb0			 
bfb0 3e 00				ld a, 0 
bfb2 cd c6 8e				call strlent 
bfb5			 
bfb5 cd 0f 98				call forth_push_numhl 
bfb8			 
bfb8			 
bfb8			 
bfb8				       NEXTW 
bfb8 c3 00 9a			jp macro_next 
bfbb				endm 
# End of macro NEXTW
bfbb			.CHAR: 
bfbb				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
bfbb 4d				db WORD_SYS_CORE+57             
bfbc f1 bf			dw .ENDSTR            
bfbe 05				db 4 + 1 
bfbf .. 00			db "CHAR",0              
bfc4				endm 
# End of macro CWHEAD
bfc4			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
bfc4					if DEBUG_FORTH_WORDS_KEY 
bfc4						DMARK "CHR" 
bfc4 f5				push af  
bfc5 3a d9 bf			ld a, (.dmark)  
bfc8 32 7a ee			ld (debug_mark),a  
bfcb 3a da bf			ld a, (.dmark+1)  
bfce 32 7b ee			ld (debug_mark+1),a  
bfd1 3a db bf			ld a, (.dmark+2)  
bfd4 32 7c ee			ld (debug_mark+2),a  
bfd7 18 03			jr .pastdmark  
bfd9 ..			.dmark: db "CHR"  
bfdc f1			.pastdmark: pop af  
bfdd			endm  
# End of macro DMARK
bfdd						CALLMONITOR 
bfdd cd 75 92			call break_point_state  
bfe0				endm  
# End of macro CALLMONITOR
bfe0					endif 
bfe0					FORTH_DSP 
bfe0 cd 8f 98			call macro_forth_dsp 
bfe3				endm 
# End of macro FORTH_DSP
bfe3					;v5 FORTH_DSP_VALUE 
bfe3 23					inc hl      ; now at start of numeric as string 
bfe4			 
bfe4			;		push hl 
bfe4			 
bfe4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe4 cd 46 99			call macro_forth_dsp_pop 
bfe7				endm 
# End of macro FORTH_DSP_POP
bfe7			 
bfe7			;		pop hl 
bfe7			 
bfe7					; push the content of a onto the stack as a value 
bfe7			 
bfe7 7e					ld a,(hl)   ; get char 
bfe8 26 00				ld h,0 
bfea 6f					ld l,a 
bfeb cd 0f 98				call forth_push_numhl 
bfee			 
bfee				       NEXTW 
bfee c3 00 9a			jp macro_next 
bff1				endm 
# End of macro NEXTW
bff1			 
bff1			 
bff1			 
bff1			 
bff1			.ENDSTR: 
bff1			; eof 
bff1			 
# End of file forth_words_str.asm
bff1			include "forth_words_key.asm" 
bff1			 
bff1			; | ## Keyboard Words 
bff1			 
bff1			.KEY: 
bff1				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
bff1 3e				db WORD_SYS_CORE+42             
bff2 21 c0			dw .WAITK            
bff4 04				db 3 + 1 
bff5 .. 00			db "KEY",0              
bff9				endm 
# End of macro CWHEAD
bff9			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
bff9			 
bff9					if DEBUG_FORTH_WORDS_KEY 
bff9						DMARK "KEY" 
bff9 f5				push af  
bffa 3a 0e c0			ld a, (.dmark)  
bffd 32 7a ee			ld (debug_mark),a  
c000 3a 0f c0			ld a, (.dmark+1)  
c003 32 7b ee			ld (debug_mark+1),a  
c006 3a 10 c0			ld a, (.dmark+2)  
c009 32 7c ee			ld (debug_mark+2),a  
c00c 18 03			jr .pastdmark  
c00e ..			.dmark: db "KEY"  
c011 f1			.pastdmark: pop af  
c012			endm  
# End of macro DMARK
c012						CALLMONITOR 
c012 cd 75 92			call break_point_state  
c015				endm  
# End of macro CALLMONITOR
c015					endif 
c015			; TODO currently waits 
c015 cd 7b d6				call cin 
c018					;call cin_wait 
c018 6f					ld l, a 
c019 26 00				ld h, 0 
c01b cd 0f 98				call forth_push_numhl 
c01e					NEXTW 
c01e c3 00 9a			jp macro_next 
c021				endm 
# End of macro NEXTW
c021			.WAITK: 
c021				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c021 3f				db WORD_SYS_CORE+43             
c022 53 c0			dw .ACCEPT            
c024 06				db 5 + 1 
c025 .. 00			db "WAITK",0              
c02b				endm 
# End of macro CWHEAD
c02b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c02b					if DEBUG_FORTH_WORDS_KEY 
c02b						DMARK "WAI" 
c02b f5				push af  
c02c 3a 40 c0			ld a, (.dmark)  
c02f 32 7a ee			ld (debug_mark),a  
c032 3a 41 c0			ld a, (.dmark+1)  
c035 32 7b ee			ld (debug_mark+1),a  
c038 3a 42 c0			ld a, (.dmark+2)  
c03b 32 7c ee			ld (debug_mark+2),a  
c03e 18 03			jr .pastdmark  
c040 ..			.dmark: db "WAI"  
c043 f1			.pastdmark: pop af  
c044			endm  
# End of macro DMARK
c044						CALLMONITOR 
c044 cd 75 92			call break_point_state  
c047				endm  
# End of macro CALLMONITOR
c047					endif 
c047 cd 75 d6				call cin_wait 
c04a 6f					ld l, a 
c04b 26 00				ld h, 0 
c04d cd 0f 98				call forth_push_numhl 
c050					NEXTW 
c050 c3 00 9a			jp macro_next 
c053				endm 
# End of macro NEXTW
c053			.ACCEPT: 
c053				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c053 40				db WORD_SYS_CORE+44             
c054 b1 c0			dw .EDIT            
c056 07				db 6 + 1 
c057 .. 00			db "ACCEPT",0              
c05e				endm 
# End of macro CWHEAD
c05e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c05e					; TODO crashes on push 
c05e					if DEBUG_FORTH_WORDS_KEY 
c05e						DMARK "ACC" 
c05e f5				push af  
c05f 3a 73 c0			ld a, (.dmark)  
c062 32 7a ee			ld (debug_mark),a  
c065 3a 74 c0			ld a, (.dmark+1)  
c068 32 7b ee			ld (debug_mark+1),a  
c06b 3a 75 c0			ld a, (.dmark+2)  
c06e 32 7c ee			ld (debug_mark+2),a  
c071 18 03			jr .pastdmark  
c073 ..			.dmark: db "ACC"  
c076 f1			.pastdmark: pop af  
c077			endm  
# End of macro DMARK
c077						CALLMONITOR 
c077 cd 75 92			call break_point_state  
c07a				endm  
# End of macro CALLMONITOR
c07a					endif 
c07a 21 73 e5				ld hl, os_input 
c07d 3e 00				ld a, 0 
c07f 77					ld (hl),a 
c080 3a 5e eb				ld a,(f_cursor_ptr) 
c083 16 64				ld d, 100 
c085 0e 00				ld c, 0 
c087 1e 28				ld e, 40 
c089 cd 8a 8a				call input_str 
c08c					; TODO perhaps do a type check and wrap in quotes if not a number 
c08c 21 73 e5				ld hl, os_input 
c08f					if DEBUG_FORTH_WORDS 
c08f						DMARK "AC1" 
c08f f5				push af  
c090 3a a4 c0			ld a, (.dmark)  
c093 32 7a ee			ld (debug_mark),a  
c096 3a a5 c0			ld a, (.dmark+1)  
c099 32 7b ee			ld (debug_mark+1),a  
c09c 3a a6 c0			ld a, (.dmark+2)  
c09f 32 7c ee			ld (debug_mark+2),a  
c0a2 18 03			jr .pastdmark  
c0a4 ..			.dmark: db "AC1"  
c0a7 f1			.pastdmark: pop af  
c0a8			endm  
# End of macro DMARK
c0a8						CALLMONITOR 
c0a8 cd 75 92			call break_point_state  
c0ab				endm  
# End of macro CALLMONITOR
c0ab					endif 
c0ab cd 21 98				call forth_push_str 
c0ae					NEXTW 
c0ae c3 00 9a			jp macro_next 
c0b1				endm 
# End of macro NEXTW
c0b1			 
c0b1			.EDIT: 
c0b1				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c0b1 40				db WORD_SYS_CORE+44             
c0b2 3a c1			dw .ENDKEY            
c0b4 05				db 4 + 1 
c0b5 .. 00			db "EDIT",0              
c0ba				endm 
# End of macro CWHEAD
c0ba			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c0ba			 
c0ba					; TODO does not copy from stack 
c0ba					if DEBUG_FORTH_WORDS_KEY 
c0ba						DMARK "EDT" 
c0ba f5				push af  
c0bb 3a cf c0			ld a, (.dmark)  
c0be 32 7a ee			ld (debug_mark),a  
c0c1 3a d0 c0			ld a, (.dmark+1)  
c0c4 32 7b ee			ld (debug_mark+1),a  
c0c7 3a d1 c0			ld a, (.dmark+2)  
c0ca 32 7c ee			ld (debug_mark+2),a  
c0cd 18 03			jr .pastdmark  
c0cf ..			.dmark: db "EDT"  
c0d2 f1			.pastdmark: pop af  
c0d3			endm  
# End of macro DMARK
c0d3						CALLMONITOR 
c0d3 cd 75 92			call break_point_state  
c0d6				endm  
# End of macro CALLMONITOR
c0d6					endif 
c0d6			 
c0d6					FORTH_DSP 
c0d6 cd 8f 98			call macro_forth_dsp 
c0d9				endm 
# End of macro FORTH_DSP
c0d9					;v5 FORTH_DSP_VALUE 
c0d9 23					inc hl    ; TODO do type check 
c0da			 
c0da e5					push hl 
c0db 3e 00				ld a, 0 
c0dd cd c6 8e				call strlent 
c0e0 23					inc hl 
c0e1			 
c0e1 06 00				ld b, 0 
c0e3 4d					ld c, l 
c0e4			 
c0e4 e1					pop hl 
c0e5 11 73 e5				ld de, os_input 
c0e8					if DEBUG_FORTH_WORDS_KEY 
c0e8						DMARK "EDc" 
c0e8 f5				push af  
c0e9 3a fd c0			ld a, (.dmark)  
c0ec 32 7a ee			ld (debug_mark),a  
c0ef 3a fe c0			ld a, (.dmark+1)  
c0f2 32 7b ee			ld (debug_mark+1),a  
c0f5 3a ff c0			ld a, (.dmark+2)  
c0f8 32 7c ee			ld (debug_mark+2),a  
c0fb 18 03			jr .pastdmark  
c0fd ..			.dmark: db "EDc"  
c100 f1			.pastdmark: pop af  
c101			endm  
# End of macro DMARK
c101						CALLMONITOR 
c101 cd 75 92			call break_point_state  
c104				endm  
# End of macro CALLMONITOR
c104					endif 
c104 ed b0				ldir 
c106			 
c106			 
c106 21 73 e5				ld hl, os_input 
c109					;ld a, 0 
c109					;ld (hl),a 
c109 3a 5e eb				ld a,(f_cursor_ptr) 
c10c 16 64				ld d, 100 
c10e 0e 00				ld c, 0 
c110 1e 28				ld e, 40 
c112 cd 8a 8a				call input_str 
c115					; TODO perhaps do a type check and wrap in quotes if not a number 
c115 21 73 e5				ld hl, os_input 
c118					if DEBUG_FORTH_WORDS 
c118						DMARK "ED1" 
c118 f5				push af  
c119 3a 2d c1			ld a, (.dmark)  
c11c 32 7a ee			ld (debug_mark),a  
c11f 3a 2e c1			ld a, (.dmark+1)  
c122 32 7b ee			ld (debug_mark+1),a  
c125 3a 2f c1			ld a, (.dmark+2)  
c128 32 7c ee			ld (debug_mark+2),a  
c12b 18 03			jr .pastdmark  
c12d ..			.dmark: db "ED1"  
c130 f1			.pastdmark: pop af  
c131			endm  
# End of macro DMARK
c131						CALLMONITOR 
c131 cd 75 92			call break_point_state  
c134				endm  
# End of macro CALLMONITOR
c134					endif 
c134 cd 21 98				call forth_push_str 
c137					NEXTW 
c137 c3 00 9a			jp macro_next 
c13a				endm 
# End of macro NEXTW
c13a			 
c13a			 
c13a			 
c13a			.ENDKEY: 
c13a			; eof 
c13a			 
# End of file forth_words_key.asm
c13a			 
c13a			if STORAGE_SE 
c13a			   	include "forth_words_storage.asm" 
c13a			endif 
c13a				include "forth_words_device.asm" 
c13a			; Device related words 
c13a			 
c13a			; | ## Device Words 
c13a			 
c13a			if SOUND_ENABLE 
c13a			.NOTE: 
c13a				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c13a			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c13a					if DEBUG_FORTH_WORDS_KEY 
c13a						DMARK "NTE" 
c13a						CALLMONITOR 
c13a					endif 
c13a			 
c13a				 
c13a			 
c13a					NEXTW 
c13a			.AFTERSOUND: 
c13a			endif 
c13a			 
c13a			 
c13a			USE_GPIO: equ 0 
c13a			 
c13a			if USE_GPIO 
c13a			.GP1: 
c13a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c13a			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c13a					NEXTW 
c13a			.GP2: 
c13a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c13a			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c13a			 
c13a					NEXTW 
c13a			 
c13a			.GP3: 
c13a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c13a			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c13a			 
c13a					NEXTW 
c13a			 
c13a			.GP4: 
c13a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c13a			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c13a			 
c13a					NEXTW 
c13a			.SIN: 
c13a			 
c13a			 
c13a			endif 
c13a			 
c13a			 
c13a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c13a 33				db WORD_SYS_CORE+31             
c13b 6f c1			dw .SOUT            
c13d 03				db 2 + 1 
c13e .. 00			db "IN",0              
c141				endm 
# End of macro CWHEAD
c141			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c141					if DEBUG_FORTH_WORDS_KEY 
c141						DMARK "IN." 
c141 f5				push af  
c142 3a 56 c1			ld a, (.dmark)  
c145 32 7a ee			ld (debug_mark),a  
c148 3a 57 c1			ld a, (.dmark+1)  
c14b 32 7b ee			ld (debug_mark+1),a  
c14e 3a 58 c1			ld a, (.dmark+2)  
c151 32 7c ee			ld (debug_mark+2),a  
c154 18 03			jr .pastdmark  
c156 ..			.dmark: db "IN."  
c159 f1			.pastdmark: pop af  
c15a			endm  
# End of macro DMARK
c15a						CALLMONITOR 
c15a cd 75 92			call break_point_state  
c15d				endm  
# End of macro CALLMONITOR
c15d					endif 
c15d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c15d cd aa 98			call macro_dsp_valuehl 
c160				endm 
# End of macro FORTH_DSP_VALUEHL
c160			 
c160 e5					push hl 
c161			 
c161					; destroy value TOS 
c161			 
c161					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c161 cd 46 99			call macro_forth_dsp_pop 
c164				endm 
# End of macro FORTH_DSP_POP
c164			 
c164					; one value on hl get other one back 
c164			 
c164 c1					pop bc 
c165			 
c165					; do the sub 
c165			;		ex de, hl 
c165			 
c165 ed 68				in l,(c) 
c167			 
c167					; save it 
c167			 
c167 26 00				ld h,0 
c169			 
c169					; TODO push value back onto stack for another op etc 
c169			 
c169 cd 0f 98				call forth_push_numhl 
c16c					NEXTW 
c16c c3 00 9a			jp macro_next 
c16f				endm 
# End of macro NEXTW
c16f			.SOUT: 
c16f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c16f 34				db WORD_SYS_CORE+32             
c170 c2 c1			dw .SPIO            
c172 04				db 3 + 1 
c173 .. 00			db "OUT",0              
c177				endm 
# End of macro CWHEAD
c177			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c177					if DEBUG_FORTH_WORDS_KEY 
c177						DMARK "OUT" 
c177 f5				push af  
c178 3a 8c c1			ld a, (.dmark)  
c17b 32 7a ee			ld (debug_mark),a  
c17e 3a 8d c1			ld a, (.dmark+1)  
c181 32 7b ee			ld (debug_mark+1),a  
c184 3a 8e c1			ld a, (.dmark+2)  
c187 32 7c ee			ld (debug_mark+2),a  
c18a 18 03			jr .pastdmark  
c18c ..			.dmark: db "OUT"  
c18f f1			.pastdmark: pop af  
c190			endm  
# End of macro DMARK
c190						CALLMONITOR 
c190 cd 75 92			call break_point_state  
c193				endm  
# End of macro CALLMONITOR
c193					endif 
c193			 
c193					; get port 
c193			 
c193					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c193 cd aa 98			call macro_dsp_valuehl 
c196				endm 
# End of macro FORTH_DSP_VALUEHL
c196			 
c196 e5					push hl 
c197			 
c197					; destroy value TOS 
c197			 
c197					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c197 cd 46 99			call macro_forth_dsp_pop 
c19a				endm 
# End of macro FORTH_DSP_POP
c19a			 
c19a					; get byte to send 
c19a			 
c19a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c19a cd aa 98			call macro_dsp_valuehl 
c19d				endm 
# End of macro FORTH_DSP_VALUEHL
c19d			 
c19d			;		push hl 
c19d			 
c19d					; destroy value TOS 
c19d			 
c19d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c19d cd 46 99			call macro_forth_dsp_pop 
c1a0				endm 
# End of macro FORTH_DSP_POP
c1a0			 
c1a0					; one value on hl get other one back 
c1a0			 
c1a0			;		pop hl 
c1a0			 
c1a0 c1					pop bc 
c1a1			 
c1a1					if DEBUG_FORTH_WORDS 
c1a1						DMARK "OUT" 
c1a1 f5				push af  
c1a2 3a b6 c1			ld a, (.dmark)  
c1a5 32 7a ee			ld (debug_mark),a  
c1a8 3a b7 c1			ld a, (.dmark+1)  
c1ab 32 7b ee			ld (debug_mark+1),a  
c1ae 3a b8 c1			ld a, (.dmark+2)  
c1b1 32 7c ee			ld (debug_mark+2),a  
c1b4 18 03			jr .pastdmark  
c1b6 ..			.dmark: db "OUT"  
c1b9 f1			.pastdmark: pop af  
c1ba			endm  
# End of macro DMARK
c1ba						CALLMONITOR 
c1ba cd 75 92			call break_point_state  
c1bd				endm  
# End of macro CALLMONITOR
c1bd					endif 
c1bd			 
c1bd ed 69				out (c), l 
c1bf			 
c1bf					NEXTW 
c1bf c3 00 9a			jp macro_next 
c1c2				endm 
# End of macro NEXTW
c1c2			 
c1c2			 
c1c2			.SPIO: 
c1c2			 
c1c2			if STORAGE_SE 
c1c2				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c1c2			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c1c2			 
c1c2					call spi_ce_low 
c1c2			    NEXTW 
c1c2			 
c1c2			.SPICEH: 
c1c2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c1c2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c1c2			 
c1c2					call spi_ce_high 
c1c2			    NEXTW 
c1c2			 
c1c2			 
c1c2			.SPIOb: 
c1c2			 
c1c2				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c1c2			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c1c2			 
c1c2					; get port 
c1c2			 
c1c2			 
c1c2					; get byte to send 
c1c2			 
c1c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1c2			 
c1c2			;		push hl    ; u1  
c1c2			 
c1c2					; destroy value TOS 
c1c2			 
c1c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1c2			 
c1c2					; one value on hl get other one back 
c1c2			 
c1c2			;		pop hl   ; u2 - addr 
c1c2			 
c1c2					; TODO Send SPI byte 
c1c2			 
c1c2					ld a, l 
c1c2					call spi_send_byte 
c1c2			 
c1c2					NEXTW 
c1c2			 
c1c2			.SPII: 
c1c2				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c1c2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c1c2			 
c1c2					; TODO Get SPI byte 
c1c2			 
c1c2					call spi_read_byte 
c1c2			 
c1c2					ld h, 0 
c1c2					ld l, a 
c1c2					call forth_push_numhl 
c1c2			 
c1c2					NEXTW 
c1c2			 
c1c2			 
c1c2			 
c1c2			.SESEL: 
c1c2				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c1c2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c1c2					if DEBUG_FORTH_WORDS_KEY 
c1c2						DMARK "BNK" 
c1c2						CALLMONITOR 
c1c2					endif 
c1c2			 
c1c2					ld a, 255 
c1c2					ld (spi_cartdev), a 
c1c2			 
c1c2					; get bank 
c1c2			 
c1c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1c2			 
c1c2			;		push hl 
c1c2			 
c1c2					; destroy value TOS 
c1c2			 
c1c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1c2			 
c1c2					; one value on hl get other one back 
c1c2			 
c1c2			;		pop hl 
c1c2			 
c1c2			 
c1c2					ld c, SPI_CE_HIGH 
c1c2			 
c1c2					ld a, l 
c1c2			 
c1c2					if DEBUG_FORTH_WORDS 
c1c2						DMARK "BNK" 
c1c2						CALLMONITOR 
c1c2					endif 
c1c2			 
c1c2					; active low 
c1c2			 
c1c2					cp 0 
c1c2					jr z, .bset 
c1c2					cp 1 
c1c2					jr nz, .b2 
c1c2					res 0, c 
c1c2			.b2:		cp 2 
c1c2					jr nz, .b3 
c1c2					res 1, c 
c1c2			.b3:		cp 3 
c1c2					jr nz, .b4 
c1c2					res 2, c 
c1c2			.b4:		cp 4 
c1c2					jr nz, .b5 
c1c2					res 3, c 
c1c2			.b5:		cp 5 
c1c2					jr nz, .bset 
c1c2					res 4, c 
c1c2			 
c1c2			.bset: 
c1c2					ld a, c 
c1c2					ld (spi_device),a 
c1c2					if DEBUG_FORTH_WORDS 
c1c2						DMARK "BN2" 
c1c2						CALLMONITOR 
c1c2					endif 
c1c2			 
c1c2					NEXTW 
c1c2			 
c1c2			.CARTDEV: 
c1c2				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c1c2			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c1c2					if DEBUG_FORTH_WORDS_KEY 
c1c2						DMARK "CDV" 
c1c2						CALLMONITOR 
c1c2					endif 
c1c2			 
c1c2					; disable se storage bank selection 
c1c2			 
c1c2					ld a, SPI_CE_HIGH		; ce high 
c1c2					ld (spi_device), a 
c1c2			 
c1c2					; get bank 
c1c2			 
c1c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1c2			 
c1c2			;		push hl 
c1c2			 
c1c2					; destroy value TOS 
c1c2			 
c1c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1c2			 
c1c2					; one value on hl get other one back 
c1c2			 
c1c2			;		pop hl 
c1c2			 
c1c2					; active low 
c1c2			 
c1c2					ld c, 255 
c1c2			 
c1c2					ld a, l 
c1c2					if DEBUG_FORTH_WORDS 
c1c2						DMARK "CDV" 
c1c2						CALLMONITOR 
c1c2					endif 
c1c2					cp 0 
c1c2					jr z, .cset 
c1c2					cp 1 
c1c2					jr nz, .c2 
c1c2					res 0, c 
c1c2			.c2:		cp 2 
c1c2					jr nz, .c3 
c1c2					res 1, c 
c1c2			.c3:		cp 3 
c1c2					jr nz, .c4 
c1c2					res 2, c 
c1c2			.c4:		cp 4 
c1c2					jr nz, .c5 
c1c2					res 3, c 
c1c2			.c5:		cp 5 
c1c2					jr nz, .c6 
c1c2					res 4, c 
c1c2			.c6:		cp 6 
c1c2					jr nz, .c7 
c1c2					res 5, c 
c1c2			.c7:		cp 7 
c1c2					jr nz, .c8 
c1c2					res 6, c 
c1c2			.c8:		cp 8 
c1c2					jr nz, .cset 
c1c2					res 7, c 
c1c2			.cset:		ld a, c 
c1c2					ld (spi_cartdev),a 
c1c2			 
c1c2					if DEBUG_FORTH_WORDS 
c1c2						DMARK "CD2" 
c1c2						CALLMONITOR 
c1c2					endif 
c1c2					NEXTW 
c1c2			endif 
c1c2			 
c1c2			.ENDDEVICE: 
c1c2			; eof 
c1c2			 
# End of file forth_words_device.asm
c1c2			 
c1c2			; var handler 
c1c2			 
c1c2			 
c1c2			.VARS: 
c1c2				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c1c2 78				db WORD_SYS_CORE+100             
c1c3 da c1			dw .V0Q            
c1c5 04				db 3 + 1 
c1c6 .. 00			db "V0!",0              
c1ca				endm 
# End of macro CWHEAD
c1ca			;| V0! ( u1 -- )  Store value to v0  | DONE 
c1ca			 
c1ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1ca cd aa 98			call macro_dsp_valuehl 
c1cd				endm 
# End of macro FORTH_DSP_VALUEHL
c1cd			 
c1cd 11 28 eb				ld de, cli_var_array 
c1d0			 
c1d0 eb					ex de, hl 
c1d1 73					ld (hl), e 
c1d2 23					inc hl 
c1d3 72					ld (hl), d 
c1d4			 
c1d4					; destroy value TOS 
c1d4			 
c1d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1d4 cd 46 99			call macro_forth_dsp_pop 
c1d7				endm 
# End of macro FORTH_DSP_POP
c1d7			 
c1d7				       NEXTW 
c1d7 c3 00 9a			jp macro_next 
c1da				endm 
# End of macro NEXTW
c1da			.V0Q: 
c1da				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c1da 79				db WORD_SYS_CORE+101             
c1db eb c1			dw .V1S            
c1dd 04				db 3 + 1 
c1de .. 00			db "V0@",0              
c1e2				endm 
# End of macro CWHEAD
c1e2			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c1e2 2a 28 eb				ld hl, (cli_var_array) 
c1e5 cd 0f 98				call forth_push_numhl 
c1e8			 
c1e8				       NEXTW 
c1e8 c3 00 9a			jp macro_next 
c1eb				endm 
# End of macro NEXTW
c1eb			.V1S: 
c1eb				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c1eb 7a				db WORD_SYS_CORE+102             
c1ec 03 c2			dw .V1Q            
c1ee 04				db 3 + 1 
c1ef .. 00			db "V1!",0              
c1f3				endm 
# End of macro CWHEAD
c1f3			;| V1! ( u1 -- )  Store value to v1 | DONE 
c1f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1f3 cd aa 98			call macro_dsp_valuehl 
c1f6				endm 
# End of macro FORTH_DSP_VALUEHL
c1f6			 
c1f6 11 2a eb				ld de, cli_var_array+2 
c1f9				 
c1f9 eb					ex de, hl 
c1fa 73					ld (hl), e 
c1fb 23					inc hl 
c1fc 72					ld (hl), d 
c1fd			 
c1fd					; destroy value TOS 
c1fd			 
c1fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1fd cd 46 99			call macro_forth_dsp_pop 
c200				endm 
# End of macro FORTH_DSP_POP
c200				       NEXTW 
c200 c3 00 9a			jp macro_next 
c203				endm 
# End of macro NEXTW
c203			.V1Q: 
c203				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c203 7b				db WORD_SYS_CORE+103             
c204 14 c2			dw .V2S            
c206 04				db 3 + 1 
c207 .. 00			db "V1@",0              
c20b				endm 
# End of macro CWHEAD
c20b			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c20b 2a 2a eb				ld hl, (cli_var_array+2) 
c20e cd 0f 98				call forth_push_numhl 
c211				       NEXTW 
c211 c3 00 9a			jp macro_next 
c214				endm 
# End of macro NEXTW
c214			.V2S: 
c214				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c214 7c				db WORD_SYS_CORE+104             
c215 2c c2			dw .V2Q            
c217 04				db 3 + 1 
c218 .. 00			db "V2!",0              
c21c				endm 
# End of macro CWHEAD
c21c			;| V2! ( u1 -- )  Store value to v2 | DONE 
c21c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c21c cd aa 98			call macro_dsp_valuehl 
c21f				endm 
# End of macro FORTH_DSP_VALUEHL
c21f			 
c21f 11 2c eb				ld de, cli_var_array+4 
c222				 
c222 eb					ex de, hl 
c223 73					ld (hl), e 
c224 23					inc hl 
c225 72					ld (hl), d 
c226			 
c226					; destroy value TOS 
c226			 
c226					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c226 cd 46 99			call macro_forth_dsp_pop 
c229				endm 
# End of macro FORTH_DSP_POP
c229				       NEXTW 
c229 c3 00 9a			jp macro_next 
c22c				endm 
# End of macro NEXTW
c22c			.V2Q: 
c22c				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c22c 7d				db WORD_SYS_CORE+105             
c22d 3d c2			dw .V3S            
c22f 04				db 3 + 1 
c230 .. 00			db "V2@",0              
c234				endm 
# End of macro CWHEAD
c234			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c234 2a 2c eb				ld hl, (cli_var_array+4) 
c237 cd 0f 98				call forth_push_numhl 
c23a				       NEXTW 
c23a c3 00 9a			jp macro_next 
c23d				endm 
# End of macro NEXTW
c23d			.V3S: 
c23d				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c23d 7c				db WORD_SYS_CORE+104             
c23e 55 c2			dw .V3Q            
c240 04				db 3 + 1 
c241 .. 00			db "V3!",0              
c245				endm 
# End of macro CWHEAD
c245			;| V3! ( u1 -- )  Store value to v3 | DONE 
c245					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c245 cd aa 98			call macro_dsp_valuehl 
c248				endm 
# End of macro FORTH_DSP_VALUEHL
c248			 
c248 11 2e eb				ld de, cli_var_array+6 
c24b				 
c24b eb					ex de, hl 
c24c 73					ld (hl), e 
c24d 23					inc hl 
c24e 72					ld (hl), d 
c24f			 
c24f					; destroy value TOS 
c24f			 
c24f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c24f cd 46 99			call macro_forth_dsp_pop 
c252				endm 
# End of macro FORTH_DSP_POP
c252				       NEXTW 
c252 c3 00 9a			jp macro_next 
c255				endm 
# End of macro NEXTW
c255			.V3Q: 
c255				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c255 7d				db WORD_SYS_CORE+105             
c256 66 c2			dw .END            
c258 04				db 3 + 1 
c259 .. 00			db "V3@",0              
c25d				endm 
# End of macro CWHEAD
c25d			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c25d 2a 2e eb				ld hl, (cli_var_array+6) 
c260 cd 0f 98				call forth_push_numhl 
c263				       NEXTW 
c263 c3 00 9a			jp macro_next 
c266				endm 
# End of macro NEXTW
c266			 
c266			 
c266			 
c266			 
c266			 
c266			; end of dict marker 
c266			 
c266 00			.END:    db WORD_SYS_END 
c267 00 00			dw 0 
c269 00				db 0 
c26a			 
c26a			; use to jp here for user dict words to save on macro expansion  
c26a			 
c26a			user_dict_next: 
c26a				NEXTW 
c26a c3 00 9a			jp macro_next 
c26d				endm 
# End of macro NEXTW
c26d			 
c26d			 
c26d			user_exec: 
c26d				;    ld hl, <word code> 
c26d				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c26d				;    call forthexec 
c26d				;    jp user_dict_next   (NEXT) 
c26d			        ;    <word code bytes> 
c26d eb				ex de, hl 
c26e 2a 76 e6			ld hl,(os_tok_ptr) 
c271				 
c271				FORTH_RSP_NEXT 
c271 cd b6 97			call macro_forth_rsp_next 
c274				endm 
# End of macro FORTH_RSP_NEXT
c274			 
c274			if DEBUG_FORTH_UWORD 
c274						DMARK "UEX" 
c274 f5				push af  
c275 3a 89 c2			ld a, (.dmark)  
c278 32 7a ee			ld (debug_mark),a  
c27b 3a 8a c2			ld a, (.dmark+1)  
c27e 32 7b ee			ld (debug_mark+1),a  
c281 3a 8b c2			ld a, (.dmark+2)  
c284 32 7c ee			ld (debug_mark+2),a  
c287 18 03			jr .pastdmark  
c289 ..			.dmark: db "UEX"  
c28c f1			.pastdmark: pop af  
c28d			endm  
# End of macro DMARK
c28d				CALLMONITOR 
c28d cd 75 92			call break_point_state  
c290				endm  
# End of macro CALLMONITOR
c290			endif 
c290			 
c290			 
c290			 
c290 eb				ex de, hl 
c291 22 76 e6			ld (os_tok_ptr), hl 
c294				 
c294				; Don't use next - Skips the first word in uword. 
c294			 
c294 c3 91 9a			jp exec1 
c297			;	NEXT 
c297			 
c297			 
c297			; eof 
# End of file forth_wordsv4.asm
c297			endif 
c297			;;;;;;;;;;;;;; Debug code 
c297			 
c297			 
c297			;if DEBUG_FORTH_PARSE 
c297 .. 00		.nowordfound: db "No match",0 
c2a0 .. 00		.compword:	db "Comparing word ",0 
c2b0 .. 00		.nextwordat:	db "Next word at",0 
c2bd .. 00		.charmatch:	db "Char match",0 
c2c8			;endif 
c2c8			if DEBUG_FORTH_JP 
c2c8			.foundword:	db "Word match. Exec..",0 
c2c8			endif 
c2c8			;if DEBUG_FORTH_PUSH 
c2c8 .. 00		.enddict:	db "Dict end. Push.",0 
c2d8 .. 00		.push_str:	db "Pushing string",0 
c2e7 .. 00		.push_num:	db "Pushing number",0 
c2f6 .. 00		.data_sp:	db "SP:",0 
c2fa .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c30c .. 00		.wordinde:	db "Word in DE (3/0):",0 
c31e .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c330			;endif 
c330			;if DEBUG_FORTH_MALLOC 
c330 .. 00		.push_malloc:	db "Malloc address",0 
c33f			;endif 
c33f			 
c33f			 
c33f			 
c33f			; display malloc address and current data stack pointer  
c33f			 
c33f			malloc_error: 
c33f d5				push de 
c340 f5				push af 
c341 e5				push hl 
c342 cd 34 88			call clear_display 
c345 11 67 c3			ld de, .mallocerr 
c348 3e 00			ld a,0 
c34a			;	ld de,os_word_scratch 
c34a cd 47 88			call str_at_display 
c34d 3e 11			ld a, display_row_1+17 
c34f 11 7a ee			ld de, debug_mark 
c352 cd 47 88			call str_at_display 
c355 cd 57 88			call update_display 
c358				;call break_point_state 
c358 cd 75 d6			call cin_wait 
c35b			 
c35b 3e 20			ld a, ' ' 
c35d 32 74 e3			ld (os_view_disable), a 
c360 e1				pop hl 
c361 f1				pop af 
c362 d1				pop de	 
c363				CALLMONITOR 
c363 cd 75 92			call break_point_state  
c366				endm  
# End of macro CALLMONITOR
c366 c9				ret 
c367			 
c367 .. 00		.mallocerr: 	db "Malloc Error",0 
c374			;if DEBUG_FORTH_PUSH 
c374			display_data_sp: 
c374 f5				push af 
c375			 
c375				; see if disabled 
c375			 
c375 3a 74 e3			ld a, (os_view_disable) 
c378 fe 2a			cp '*' 
c37a 28 67			jr z, .skipdsp 
c37c			 
c37c e5				push hl 
c37d e5				push hl 
c37e e5			push hl 
c37f cd 34 88			call clear_display 
c382 e1			pop hl 
c383 7c				ld a,h 
c384 21 7a e6			ld hl, os_word_scratch 
c387 cd 5e 8d			call hexout 
c38a e1				pop hl 
c38b 7d				ld a,l 
c38c 21 7c e6			ld hl, os_word_scratch+2 
c38f cd 5e 8d			call hexout 
c392 21 7e e6			ld hl, os_word_scratch+4 
c395 3e 00			ld a,0 
c397 77				ld (hl),a 
c398 11 7a e6			ld de,os_word_scratch 
c39b 3e 28				ld a, display_row_2 
c39d cd 47 88				call str_at_display 
c3a0 11 fa c2			ld de, .wordinhl 
c3a3 3e 00			ld a, display_row_1 
c3a5			 
c3a5 cd 47 88				call str_at_display 
c3a8 11 7a ee			ld de, debug_mark 
c3ab 3e 11			ld a, display_row_1+17 
c3ad			 
c3ad cd 47 88				call str_at_display 
c3b0			 
c3b0				; display current data stack pointer 
c3b0 11 f6 c2			ld de,.data_sp 
c3b3 3e 30				ld a, display_row_2 + 8 
c3b5 cd 47 88				call str_at_display 
c3b8			 
c3b8 2a 22 eb			ld hl,(cli_data_sp) 
c3bb e5				push hl 
c3bc 7c				ld a,h 
c3bd 21 7a e6			ld hl, os_word_scratch 
c3c0 cd 5e 8d			call hexout 
c3c3 e1				pop hl 
c3c4 7d				ld a,l 
c3c5 21 7c e6			ld hl, os_word_scratch+2 
c3c8 cd 5e 8d			call hexout 
c3cb 21 7e e6			ld hl, os_word_scratch+4 
c3ce 3e 00			ld a,0 
c3d0 77				ld (hl),a 
c3d1 11 7a e6			ld de,os_word_scratch 
c3d4 3e 33				ld a, display_row_2 + 11 
c3d6 cd 47 88				call str_at_display 
c3d9			 
c3d9			 
c3d9 cd 57 88			call update_display 
c3dc cd e2 87			call delay1s 
c3df cd e2 87			call delay1s 
c3e2 e1				pop hl 
c3e3			.skipdsp: 
c3e3 f1				pop af 
c3e4 c9				ret 
c3e5			 
c3e5			display_data_malloc: 
c3e5			 
c3e5 f5				push af 
c3e6 e5				push hl 
c3e7 e5				push hl 
c3e8 e5			push hl 
c3e9 cd 34 88			call clear_display 
c3ec e1			pop hl 
c3ed 7c				ld a,h 
c3ee 21 7a e6			ld hl, os_word_scratch 
c3f1 cd 5e 8d			call hexout 
c3f4 e1				pop hl 
c3f5 7d				ld a,l 
c3f6 21 7c e6			ld hl, os_word_scratch+2 
c3f9 cd 5e 8d			call hexout 
c3fc 21 7e e6			ld hl, os_word_scratch+4 
c3ff 3e 00			ld a,0 
c401 77				ld (hl),a 
c402 11 7a e6			ld de,os_word_scratch 
c405 3e 28				ld a, display_row_2 
c407 cd 47 88				call str_at_display 
c40a 11 30 c3			ld de, .push_malloc 
c40d 3e 00			ld a, display_row_1 
c40f			 
c40f cd 47 88				call str_at_display 
c412			 
c412				; display current data stack pointer 
c412 11 f6 c2			ld de,.data_sp 
c415 3e 30				ld a, display_row_2 + 8 
c417 cd 47 88				call str_at_display 
c41a			 
c41a 2a 22 eb			ld hl,(cli_data_sp) 
c41d e5				push hl 
c41e 7c				ld a,h 
c41f 21 7a e6			ld hl, os_word_scratch 
c422 cd 5e 8d			call hexout 
c425 e1				pop hl 
c426 7d				ld a,l 
c427 21 7c e6			ld hl, os_word_scratch+2 
c42a cd 5e 8d			call hexout 
c42d 21 7e e6			ld hl, os_word_scratch+4 
c430 3e 00			ld a,0 
c432 77				ld (hl),a 
c433 11 7a e6			ld de,os_word_scratch 
c436 3e 33				ld a, display_row_2 + 11 
c438 cd 47 88				call str_at_display 
c43b			 
c43b cd 57 88			call update_display 
c43e cd e2 87			call delay1s 
c441 cd e2 87			call delay1s 
c444 e1				pop hl 
c445 f1				pop af 
c446 c9				ret 
c447			;endif 
c447			 
c447			include "forth_autostart.asm" 
c447			; list of commands to perform at system start up 
c447			 
c447			startcmds: 
c447			;	dw test11 
c447			;	dw test12 
c447			;	dw test13 
c447			;	dw test14 
c447			;	dw test15 
c447			;	dw test16 
c447			;	dw test17 
c447			;	dw ifthtest1 
c447			;	dw ifthtest2 
c447			;	dw ifthtest3 
c447			;	dw mmtest1 
c447			;	dw mmtest2 
c447			;	dw mmtest3 
c447			;	dw mmtest4 
c447			;	dw mmtest5 
c447			;	dw mmtest6 
c447			;	dw iftest1 
c447			;	dw iftest2 
c447			;	dw iftest3 
c447			;	dw looptest1 
c447			;	dw looptest2 
c447			;	dw test1 
c447			;	dw test2 
c447			;	dw test3 
c447			;	dw test4 
c447			;	dw game2r 
c447			;	dw game2b1 
c447			;	dw game2b2 
c447			 
c447				; start up words that are actually useful 
c447			 
c447 a5 c4			dw clrstack 
c449 d8 c4			dw type 
c44b 99 c6			dw stest 
c44d fc c4			dw strncpy 
c44f 3a c6			dw list 
c451 5d c5			dw start1 
c453 6f c5			dw start2 
c455			;	dw start3 
c455 82 c5			dw start3b 
c457 da c5			dw start3c 
c459			 
c459				; (unit) testing words 
c459			 
c459 10 c7			dw mtesta 
c45b c5 c7			dw mtestb 
c45d 68 c8			dw mtestc 
c45f 1d c9			dw mtestd 
c461 c1 c9			dw mteste 
c463			 
c463				; demo/game words 
c463			 
c463 cd d0		        dw game3w 
c465 fb d0		        dw game3p 
c467 19 d1		        dw game3sc 
c469 4a d1		        dw game3vsi 
c46b 76 d1		        dw game3vs 
c46d				 
c46d c0 ce			dw game2b 
c46f 2e cf			dw game2bf 
c471 78 cf			dw game2mba 
c473 0e d0			dw game2mbas 
c475 50 d0			dw game2mb 
c477			 
c477 81 cb			dw game1 
c479 92 cb			dw game1a 
c47b f4 cb			dw game1b 
c47d 29 cc			dw game1c 
c47f 5f cc			dw game1d 
c481 90 cc			dw game1s 
c483 a4 cc			dw game1t 
c485 b9 cc			dw game1f 
c487 ed cc			dw game1z 
c489 31 cd			dw game1zz 
c48b			 
c48b 77 ca			dw test5 
c48d af ca			dw test6 
c48f e7 ca			dw test7 
c491 fb ca			dw test8 
c493 27 cb			dw test9 
c495 3d cb			dw test10 
c497				 
c497 08 ce		        dw ssv5 
c499 ec cd		        dw ssv4 
c49b d0 cd		        dw ssv3 
c49d 9a cd		        dw ssv2 
c49f 21 ce		        dw ssv1 
c4a1 69 ce		        dw ssv1cpm 
c4a3			;	dw keyup 
c4a3			;	dw keydown 
c4a3			;	dw keyleft 
c4a3			;	dw keyright 
c4a3			;	dw 	keyf1 
c4a3			;	dw keyf2 
c4a3			;	dw keyf3 
c4a3			;	dw keyf4 
c4a3			;	dw keyf5 
c4a3			;	dw keyf6 
c4a3			;	dw keyf7 
c4a3			;	dw keyf8 
c4a3			;	dw keyf9 
c4a3			;	dw keyf10 
c4a3			;	dw keyf11 
c4a3			;	dw keyf12 
c4a3			;	dw keytab 
c4a3			;	dw keycr 
c4a3			;	dw keyhome 
c4a3			;	dw keyend 
c4a3			;	dw keybs 
c4a3 00 00			db 0, 0	 
c4a5			 
c4a5			 
c4a5			; clear stack  
c4a5			 
c4a5 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c4d8			 
c4d8			; type ( addr count - ) 
c4d8 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c4fc			 
c4fc			; some direct memory words 
c4fc			; strncpy ( len t f -- t ) 
c4fc			 
c4fc .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c55d			 
c55d .. 00		start1:     	db ": bpon $0000 bp ;",0 
c56f .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c582			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c582 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c5da .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c63a			 
c63a			 
c63a			; a handy word to list items on the stack 
c63a			 
c63a .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c699			 
c699			 
c699			; test stack  
c699			; rnd8 stest 
c699			 
c699 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c710			 
c710			; random malloc and free cycles 
c710			 
c710 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c7c5			 
c7c5			; fixed malloc and free cycles 
c7c5			 
c7c5 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c868			 
c868			; fixed double string push and drop cycle  
c868			 
c868 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
c91d			 
c91d			; consistent fixed string push and drop cycle  
c91d			 
c91d .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
c9c1			 
c9c1 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ca77			 
ca77			;test1:		db ": aa 1 2 3 ;", 0 
ca77			;test2:     	db "111 aa 888 999",0 
ca77			;test3:     	db ": bb 77 ;",0 
ca77			;test4:     	db "$02 $01 do i . loop bb",0 
ca77			 
ca77 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
caaf .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cae7 .. 00		test7:     	db ": box hline vline ;",0 
cafb .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cb27 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cb3d .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cb62 .. 00		test11:     	db "hello create .",0 
cb71 .. 00		test12:     	db "hello2 create .",0 
cb81			 
cb81			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cb81			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cb81			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cb81			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cb81			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cb81			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cb81			 
cb81			;iftest1:     	db "$0001 IF cls .",0 
cb81			;iftest2:     	db "$0000 IF cls .",0 
cb81			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cb81			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cb81			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cb81			 
cb81			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cb81			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cb81			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cb81			 
cb81			 
cb81			 
cb81			; a small guess the number game 
cb81			 
cb81 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cb92 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cbf4			 
cbf4 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cc29 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cc5f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cc90 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cca4 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
ccb9 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cced .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cd31			 
cd31			; Using 'ga' save a high score across multiple runs using external storage 
cd31			 
cd31 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cd9a			 
cd9a			 
cd9a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cd9a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cd9a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cd9a			 
cd9a			; simple screen saver to test code memory reuse to destruction 
cd9a			 
cd9a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cdd0 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cdec .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
ce08 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
ce21 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
ce69 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
cec0			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
cec0			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
cec0			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
cec0			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
cec0			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
cec0			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
cec0			 
cec0			 
cec0			 
cec0			; minesweeper/battleship finding game 
cec0			; draws a game board of random ship/mine positions 
cec0			; user enters coords to see if it hits on 
cec0			; game ends when all are hit 
cec0			; when hit or miss says how many may be in the area 
cec0			 
cec0			; setup the game board and then hide it 
cec0 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
cf2e .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
cf78			; prompt for where to target 
cf78 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d00e .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d033			; TODO see if the entered coords hits or misses pushes char hit of miss 
d033 .. 00		game2mbht:      db ": mbckht nop ;",0 
d042 .. 00		game2mbms:      db ": mbcms nop ;",0 
d050			; TODO how many might be near by 
d050 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d0cd			 
d0cd			; Game 3 
d0cd			 
d0cd			; Vert scroller ski game - avoid the trees! 
d0cd			 
d0cd			; v0 score (ie turns) 
d0cd			; v1 player pos 
d0cd			; v2 left wall 
d0cd			; v3 right wall 
d0cd			 
d0cd			; Draw side walls randomly 
d0cd			 
d0cd .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d0fb			 
d0fb			; Draw player 
d0fb .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d119			 
d119			; TODO Get Key 
d119			 
d119			; TODO Move left right 
d119			 
d119			; scroll and move walls a bit 
d119			 
d119 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d14a			 
d14a			; main game loop 
d14a			 
d14a .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d176 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d1b5			 
d1b5			; key board defs 
d1b5			 
d1b5 .. 00		keyup:       db ": keyup $05 ;",0 
d1c3 .. 00		keydown:       db ": keydown $0a ;",0 
d1d3 .. 00		keyleft:       db ": keyleft $0b ;",0 
d1e3 .. 00		keyright:       db ": keyright $0c ;",0 
d1f4 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d202 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d210 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d21e .. 00		keyf4:       db ": keyf4 $13 ;",0 
d22c .. 00		keyf5:       db ": keyf5 $14 ;",0 
d23a .. 00		keyf6:       db ": keyf6 $15 ;",0 
d248 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d256 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d264 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d272 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d281 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d290 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d29f			 
d29f .. 00		keytab:       db ": keytab $09 ;",0 
d2ae .. 00		keycr:       db ": keycr $0d ;",0 
d2bc .. 00		keyhome:       db ": keyhome $0e ;",0 
d2cc .. 00		keyend:       db ": keyend $0f ;",0 
d2db .. 00		keybs:       db ": keybs $08 ;",0 
d2e9			 
d2e9			   
d2e9			 
d2e9			 
d2e9			 
d2e9			; eof 
# End of file forth_autostart.asm
d2e9			 
d2e9 .. 00		sprompt1: db "Startup load...",0 
d2f9 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d30f			 
d30f			forth_startup: 
d30f 21 47 c4			ld hl, startcmds 
d312 3e 00			ld a, 0 
d314 32 9b e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d317			 
d317 e5			.start1:	push hl 
d318 cd 34 88			call clear_display 
d31b 11 e9 d2			ld de, sprompt1 
d31e 3e 00		        ld a, display_row_1 
d320 cd 47 88			call str_at_display 
d323 11 f9 d2			ld de, sprompt2 
d326 3e 28		        ld a, display_row_2 
d328 cd 47 88			call str_at_display 
d32b e1				pop hl 
d32c e5				push hl 
d32d 5e				ld e,(hl) 
d32e 23				inc hl 
d32f 56				ld d,(hl) 
d330 3e 50		        ld a, display_row_3 
d332 cd 47 88			call str_at_display 
d335 cd 57 88			call update_display 
d338			 
d338			 
d338 3a 9b e7			ld a, (os_last_cmd) 
d33b fe 00			cp 0 
d33d 28 05			jr z, .startprompt 
d33f cd d6 87			call delay250ms 
d342 18 24			jr .startdo 
d344				 
d344				 
d344			 
d344			.startprompt: 
d344			 
d344 3e 9f			ld a,display_row_4 + display_cols - 1 
d346 11 85 97		        ld de, endprg 
d349 cd 47 88			call str_at_display 
d34c cd 57 88			call update_display 
d34f cd e2 87			call delay1s 
d352 cd 75 d6			call cin_wait 
d355						 
d355 fe 2a			cp '*' 
d357 28 5e			jr z, .startupend1 
d359 fe 23			cp '#' 
d35b 20 07			jr nz, .startno 
d35d 3e 01			ld a, 1 
d35f 32 9b e7			ld (os_last_cmd),a 
d362 18 04			jr .startdo 
d364 fe 31		.startno:	cp '1' 
d366 28 3a			jr z,.startnxt  
d368			 
d368				; exec startup line 
d368			.startdo:	 
d368 e1				pop hl 
d369 e5				push hl 
d36a				 
d36a 5e				ld e,(hl) 
d36b 23				inc hl 
d36c 56				ld d,(hl) 
d36d eb				ex de,hl 
d36e			 
d36e e5				push hl 
d36f			 
d36f 3e 00			ld a, 0 
d371				;ld a, FORTH_END_BUFFER 
d371 cd c6 8e			call strlent 
d374 23				inc hl   ; include zero term to copy 
d375 06 00			ld b,0 
d377 4d				ld c,l 
d378 e1				pop hl 
d379 11 75 e3			ld de, scratch 
d37c ed b0			ldir 
d37e			 
d37e			 
d37e 21 75 e3			ld hl, scratch 
d381 cd 4e 9a			call forthparse 
d384 cd 8e 9a			call forthexec 
d387 cd a5 99			call forthexec_cleanup 
d38a			 
d38a 3e 78			ld a, display_row_4 
d38c 11 29 95			ld de, endprog 
d38f			 
d38f cd 57 88			call update_display		 
d392			 
d392 3a 9b e7			ld a, (os_last_cmd) 
d395 fe 00			cp 0 
d397 20 09			jr nz, .startnxt 
d399 cd 87 97			call next_page_prompt 
d39c cd 34 88		        call clear_display 
d39f cd 57 88			call update_display		 
d3a2			 
d3a2				; move onto next startup line? 
d3a2			.startnxt: 
d3a2			 
d3a2 cd d6 87			call delay250ms 
d3a5 e1				pop hl 
d3a6			 
d3a6 23				inc hl 
d3a7 23				inc hl 
d3a8			 
d3a8 e5				push hl 
d3a9 5e				ld e, (hl) 
d3aa 23				inc hl 
d3ab 56				ld d, (hl) 
d3ac e1				pop hl 
d3ad				; TODO replace 0 test 
d3ad			 
d3ad eb				ex de, hl 
d3ae cd 86 8a			call ishlzero 
d3b1			;	ld a,e 
d3b1			;	add d 
d3b1			;	cp 0    ; any left to do? 
d3b1 eb				ex de, hl 
d3b2 c2 17 d3			jp nz, .start1 
d3b5 18 01			jr .startupend 
d3b7			 
d3b7 e1			.startupend1: pop hl 
d3b8			.startupend: 
d3b8			 
d3b8 cd 34 88			call clear_display 
d3bb cd 57 88			call update_display 
d3be c9				ret 
d3bf			 
d3bf			 
d3bf			; stack over and underflow checks 
d3bf			 
d3bf			; init the words to detect the under/overflow 
d3bf			 
d3bf			chk_stk_init: 
d3bf				; a vague random number to check so we dont get any "lucky" hits 
d3bf 3e 2d			ld a, 45 
d3c1 6f				ld l, a 
d3c2 00				nop 
d3c3 3e 17			ld a, 23 
d3c5 67				ld h, a 
d3c6			 
d3c6 22 6a e3			ld (chk_word), hl     ; the word we need to check against 
d3c9			 
d3c9			;	ld (chk_stund), hl	; stack points.... 
d3c9 22 00 ef			ld (chk_stovr), hl 
d3cc 22 20 eb			ld (chk_ret_und), hl 
d3cf 22 de ea			ld (chk_ret_ovr), hl 
d3d2 22 dc e9			ld (chk_loop_ovr), hl 
d3d5 22 da e8			ld (chk_data_ovr), hl 
d3d8 c9				ret 
d3d9				 
d3d9			check_stacks: 
d3d9				; check all stack words 
d3d9			 
d3d9 e5				push hl 
d3da d5				push de 
d3db			 
d3db			;	ld de,(chk_word) 
d3db			;	ld hl, (chk_stund)	; stack points.... 
d3db			;	if DEBUG_STK_FAULT 
d3db			;		DMARK "FAa" 
d3db			;		CALLMONITOR 
d3db			;	endif 
d3db			;	call cmp16 
d3db			;	jp z, .chk_faulta 
d3db			; 
d3db			;	ld de, sfaultsu 
d3db			;	jp .chk_fault 
d3db			 
d3db 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d3de ed 5b 6a e3		ld de,(chk_word) 
d3e2				if DEBUG_STK_FAULT 
d3e2					DMARK "FAb" 
d3e2					CALLMONITOR 
d3e2				endif 
d3e2 cd 7b 8a			call cmp16 
d3e5 28 06			jr z, .chk_fault1 
d3e7 11 88 d4			ld de, sfaultso 
d3ea c3 3c d4			jp .chk_fault 
d3ed			.chk_fault1:  
d3ed 2a 20 eb			ld hl, (chk_ret_und) 
d3f0 ed 5b 6a e3		ld de,(chk_word) 
d3f4				if DEBUG_STK_FAULT 
d3f4					DMARK "FAU" 
d3f4					CALLMONITOR 
d3f4				endif 
d3f4 cd 7b 8a			call cmp16 
d3f7 ca 00 d4			jp z, .chk_fault2 
d3fa 11 98 d4			ld de, sfaultru 
d3fd c3 3c d4			jp .chk_fault 
d400			.chk_fault2:  
d400 2a de ea			ld hl, (chk_ret_ovr) 
d403 ed 5b 6a e3		ld de,(chk_word) 
d407				if DEBUG_STK_FAULT 
d407					DMARK "FA1" 
d407					CALLMONITOR 
d407				endif 
d407 cd 7b 8a			call cmp16 
d40a ca 13 d4			jp z, .chk_fault3 
d40d 11 a6 d4			ld de, sfaultro 
d410 c3 3c d4			jp .chk_fault 
d413			.chk_fault3:  
d413 2a dc e9			ld hl, (chk_loop_ovr) 
d416 ed 5b 6a e3		ld de,(chk_word) 
d41a				if DEBUG_STK_FAULT 
d41a					DMARK "FA2" 
d41a					CALLMONITOR 
d41a				endif 
d41a cd 7b 8a			call cmp16 
d41d ca 26 d4			jp z, .chk_fault4 
d420 11 c0 d4			ld de, sfaultlo 
d423 c3 3c d4			jp .chk_fault 
d426			.chk_fault4:  
d426 2a da e8			ld hl, (chk_data_ovr) 
d429 ed 5b 6a e3		ld de,(chk_word) 
d42d				if DEBUG_STK_FAULT 
d42d					DMARK "FA3" 
d42d					CALLMONITOR 
d42d				endif 
d42d cd 7b 8a			call cmp16 
d430 ca 39 d4			jp z, .chk_fault5 
d433 11 da d4			ld de, sfaultdo 
d436 c3 3c d4			jp .chk_fault 
d439			 
d439			 
d439			.chk_fault5:  
d439 d1				pop de 
d43a e1				pop hl 
d43b			 
d43b c9				ret 
d43c			 
d43c cd 34 88		.chk_fault: 	call clear_display 
d43f 3e 28				ld a, display_row_2 
d441 cd 47 88				call str_at_display 
d444 11 6a d4				   ld de, .stackfault 
d447 3e 00				ld a, display_row_1 
d449 cd 47 88				call str_at_display 
d44c 11 7a ee				    ld de, debug_mark 
d44f 3e 11				ld a, display_row_1+17 
d451 cd 47 88				call str_at_display 
d454 cd 57 88				call update_display 
d457			 
d457				; prompt before entering montior for investigating issue 
d457			 
d457 3e 78			ld a, display_row_4 
d459 11 29 95			ld de, endprog 
d45c			 
d45c cd 57 88			call update_display		 
d45f			 
d45f cd 87 97			call next_page_prompt 
d462			 
d462 d1				pop de 
d463 e1				pop hl 
d464 cd 7d 95				call monitor 
d467 c3 6a 94				jp warmstart 
d46a					;jp 0 
d46a					;halt 
d46a			 
d46a			 
d46a			 
d46a .. 00		.stackfault: 	db "Stack fault:",0 
d477			 
d477 .. 00		sfaultsu: 	db	"Stack under flow",0 
d488 .. 00		sfaultso: 	db	"Stack over flow",0 
d498 .. 00		sfaultru:	db "RTS underflow",0 
d4a6 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d4c0 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d4da .. 00		sfaultdo:	db "DTS overflow", 0 
d4e7			 
d4e7			 
d4e7			fault_dsp_under: 
d4e7 11 f9 d4			ld de, .dsp_under 
d4ea c3 a9 d5			jp .show_fault 
d4ed			 
d4ed			fault_rsp_under: 
d4ed 11 07 d5			ld de, .rsp_under 
d4f0 c3 a9 d5			jp .show_fault 
d4f3			fault_loop_under: 
d4f3 11 15 d5			ld de, .loop_under 
d4f6 c3 a9 d5			jp .show_fault 
d4f9			 
d4f9 .. 00		.dsp_under: db "DSP Underflow",0 
d507 .. 00		.rsp_under: db "RSP Underflow",0 
d515 .. 00		.loop_under: db "LOOP Underflow",0 
d524			 
d524			 
d524 d5			type_faultn: 	push de 
d525 e5					push hl 
d526 cd 34 88				call clear_display 
d529 11 50 d5				   ld de, .typefaultn 
d52c 3e 00				ld a, display_row_1 
d52e cd 47 88				call str_at_display 
d531 11 7a ee				    ld de, debug_mark 
d534 3e 11				ld a, display_row_1+17 
d536 cd 47 88				call str_at_display 
d539 cd 57 88				call update_display 
d53c			 
d53c				; prompt before entering montior for investigating issue 
d53c			 
d53c 3e 78			ld a, display_row_4 
d53e 11 29 95			ld de, endprog 
d541			 
d541 cd 57 88			call update_display		 
d544			 
d544 cd 87 97			call next_page_prompt 
d547			 
d547 e5					push hl 
d548 d5					push de 
d549 cd 7d 95				call monitor 
d54c c3 6a 94				jp warmstart 
d54f 76					halt 
d550			 
d550			 
d550 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d567			 
d567 d5			type_faults: 	push de 
d568 e5					push hl 
d569 cd 34 88				call clear_display 
d56c 11 92 d5				   ld de, .typefaults 
d56f 3e 00				ld a, display_row_1 
d571 cd 47 88				call str_at_display 
d574 11 7a ee				    ld de, debug_mark 
d577 3e 11				ld a, display_row_1+17 
d579 cd 47 88				call str_at_display 
d57c cd 57 88				call update_display 
d57f			 
d57f				; prompt before entering montior for investigating issue 
d57f			 
d57f 3e 78			ld a, display_row_4 
d581 11 29 95			ld de, endprog 
d584			 
d584 cd 57 88			call update_display		 
d587			 
d587 cd 87 97			call next_page_prompt 
d58a			 
d58a e1					pop hl 
d58b d1					pop de 
d58c cd 7d 95				call monitor 
d58f c3 6a 94				jp warmstart 
d592			 
d592			 
d592 .. 00		.typefaults: db "STR Type Expected TOS!",0 
d5a9			 
d5a9			.show_fault: 	 
d5a9 d5					push de 
d5aa cd 34 88				call clear_display 
d5ad d1					pop de 
d5ae 3e 00				ld a, display_row_1 
d5b0 cd 47 88				call str_at_display 
d5b3 11 7a ee				    ld de, debug_mark 
d5b6 3e 11				ld a, display_row_1+17 
d5b8 cd 47 88				call str_at_display 
d5bb cd 57 88				call update_display 
d5be			 
d5be				; prompt before entering montior for investigating issue 
d5be			 
d5be 3e 78			ld a, display_row_4 
d5c0 11 29 95			ld de, endprog 
d5c3			 
d5c3 cd 57 88			call update_display		 
d5c6			 
d5c6 cd 87 97			call next_page_prompt 
d5c9			 
d5c9 e1					pop hl 
d5ca d1					pop de 
d5cb cd 7d 95				call monitor 
d5ce			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d5ce			; TODO Make optional fault restart to cli or warm boot? 
d5ce					;jp warmstart 
d5ce c3 c2 94				jp cli 
d5d1 76					halt 
d5d2			; eof 
# End of file forth_kernel.asm
d5d2			;include "nascombasic.asm" 
d5d2			 
d5d2			 
d5d2			; find out where the code ends if loaded into RAM (for SC114) 
d5d2			;endofcode:  
d5d2			;	nop 
d5d2			 
d5d2			 
d5d2			; eof 
d5d2			 
# End of file main.asm
d5d2			;include "firmware_lcd_4x40.asm" 
d5d2			;;include "firmware_lcd_4x20.asm" 
d5d2			include "firmware_serial_display.asm" 
d5d2			 
d5d2			; Serial display interface for SC114 
d5d2			 
d5d2			 
d5d2			display_row_1: equ 0 
d5d2			display_row_2: equ display_row_1+display_cols 
d5d2			display_row_3: equ display_row_2 + display_cols 
d5d2			display_row_4: equ display_row_3 + display_cols 
d5d2			 
d5d2			kLCDWidth:  EQU display_cols             ;Width in characters 
d5d2			kLCD_Line1: EQU 0x00  
d5d2			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d5d2			; E1 
d5d2			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d5d2			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d5d2			 
d5d2			lcd_init: 
d5d2				; no init as handled by the SCM bios 
d5d2 c9				ret 
d5d3			 
d5d3			 
d5d3			; low level functions for direct screen writes 
d5d3			 
d5d3			; output char at pos? 
d5d3			fLCD_Str: 
d5d3			        ;out (SC114_SIO_1_OUT),a 
d5d3 c5				push bc 
d5d4 0e 02			ld c, $02 
d5d6 f7				rst $30 
d5d7 c1				pop bc 
d5d8 c9				ret 
d5d9			 
d5d9			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d5d9			fLCD_Pos: 
d5d9				; use ASCII escape to position 
d5d9			        ;out (SC114_SIO_1_OUT),a 
d5d9 c5				push bc 
d5da 0e 02			ld c, $02 
d5dc f7				rst $30 
d5dd c1				pop bc 
d5de			 
d5de c9				ret 
d5df			 
d5df			; output char at pos 
d5df			fLCD_Data: 
d5df			      ;  out (SC114_SIO_1_OUT),a 
d5df c5				push bc 
d5e0 0e 02			ld c, $02 
d5e2 f7				rst $30 
d5e3 c1				pop bc 
d5e4			 
d5e4 c9				ret 
d5e5			 
d5e5			; ascii cls  
d5e5			 
d5e5 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d5e9			 
d5e9			; write the frame buffer given in hl to hardware  
d5e9			write_display: 
d5e9			 
d5e9			API: equ 0 
d5e9			 
d5e9			if API 
d5e9				push bc 
d5e9				ld b, 4 
d5e9			 
d5e9			        ld (display_write_tmp), hl 	  
d5e9			 
d5e9				; clear and home cursor 
d5e9			 
d5e9				ld c, 6 
d5e9				ld de, .cls 
d5e9				rst $30 
d5e9			 
d5e9			 
d5e9			.writeln: 
d5e9			 
d5e9				ld de, (display_write_tmp) 
d5e9				ld c, 6 
d5e9				rst $30 
d5e9				ld c, 7 
d5e9				rst $30 
d5e9			 
d5e9				ld hl, (display_write_tmp) 
d5e9				ld de, display_cols 
d5e9				add hl,de 
d5e9				ld (display_write_tmp),hl 
d5e9			 
d5e9				djnz  .writeln 
d5e9			 
d5e9				pop bc 
d5e9			 
d5e9			 
d5e9				ret 
d5e9			endif 
d5e9 e5				push hl 
d5ea c5				push bc 
d5eb d5				push de 
d5ec			 
d5ec			;	ld c, 2 
d5ec			;	;ld de, .cls 
d5ec			;	ld a, 27 
d5ec			;	rst $30 
d5ec			;	ld c, 2 
d5ec			;	;ld de, .cls 
d5ec			;	ld a, '[' 
d5ec			;	rst $30 
d5ec			; 
d5ec			;	ld c, 2 
d5ec			;	;ld de, .cls 
d5ec			;	ld a, 'H' 
d5ec			;	rst $30 
d5ec			; 
d5ec			 
d5ec 0e 02			ld c, 2 
d5ee				;ld de, .cls 
d5ee 3e 1b			ld a, 27 
d5f0 f7				rst $30 
d5f1			 
d5f1			 
d5f1 0e 02			ld c, 2 
d5f3				;ld de, .cls 
d5f3 3e 5b			ld a, '[' 
d5f5 f7				rst $30 
d5f6 0e 02			ld c, 2 
d5f8				;ld de, .cls 
d5f8 3e 32			ld a, '2' 
d5fa f7				rst $30 
d5fb 0e 02			ld c, 2 
d5fd				;ld de, .cls 
d5fd 3e 4a			ld a, 'J' 
d5ff f7				rst $30 
d600 d1				pop de 
d601 c1				pop bc 
d602 e1				pop hl 
d603			 
d603			 
d603 22 d8 eb		        ld (display_write_tmp), hl 	  
d606 3e 00			ld a, kLCD_Line1 
d608			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d608 06 28			ld b, display_cols 
d60a ed 5b d8 eb		ld de, (display_write_tmp) 
d60e cd 6c d6			call write_len_string 
d611				 
d611			 
d611 e5			push hl 
d612 d5			push de 
d613 c5			push bc 
d614 0e 07			ld c, 7 
d616 f7				rst $30 
d617 c1			pop bc 
d618 d1			pop de 
d619 e1			pop hl 
d61a			 
d61a				 
d61a 2a d8 eb			ld hl, (display_write_tmp) 
d61d 11 28 00			ld de, display_cols 
d620 19				add hl,de 
d621 22 d8 eb			ld (display_write_tmp),hl 
d624			 
d624				 
d624 3e 28			ld a, kLCD_Line2 
d626			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d626 06 28			ld b, display_cols 
d628 ed 5b d8 eb		ld de, (display_write_tmp) 
d62c cd 6c d6			call write_len_string 
d62f				 
d62f 2a d8 eb			ld hl, (display_write_tmp) 
d632 11 28 00			ld de, display_cols 
d635 19				add hl,de 
d636 22 d8 eb			ld (display_write_tmp),hl 
d639			 
d639 e5			push hl 
d63a d5			push de 
d63b c5			push bc 
d63c 0e 07			ld c, 7 
d63e f7				rst $30 
d63f c1			pop bc 
d640 d1			pop de 
d641 e1			pop hl 
d642			 
d642				 
d642 3e 50			ld a, kLCD_Line3 
d644			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d644 06 28			ld b, display_cols 
d646 ed 5b d8 eb		ld de, (display_write_tmp) 
d64a cd 6c d6			call write_len_string 
d64d				 
d64d 2a d8 eb			ld hl, (display_write_tmp) 
d650 11 28 00			ld de, display_cols 
d653 19				add hl,de 
d654 22 d8 eb			ld (display_write_tmp),hl 
d657			 
d657 e5			push hl 
d658 d5			push de 
d659 c5			push bc 
d65a 0e 07			ld c, 7 
d65c f7				rst $30 
d65d c1			pop bc 
d65e d1			pop de 
d65f e1			pop hl 
d660			 
d660				 
d660 3e 78			ld a, kLCD_Line4 
d662			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d662 06 28			ld b, display_cols 
d664 ed 5b d8 eb		ld de, (display_write_tmp) 
d668 cd 6c d6			call write_len_string 
d66b c9					ret 
d66c			 
d66c			 
d66c				; write out a fixed length string given in b from de 
d66c			 
d66c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d66d cd df d5		            CALL fLCD_Data      ;Write character to display 
d670 13				inc de 
d671 10 f9			djnz write_len_string 
d673 c9				ret 
d674			 
d674			 
d674			; eof 
# End of file firmware_serial_display.asm
d674			;include "firmware_key_5x10.asm" 
d674			;;include "firmware_key_4x10.asm" 
d674			include "firmware_key_serial.asm" 
d674			; Serial keyboard interface for SC114 
d674			 
d674			key_init: 
d674				; no init as handled by the SCM bios 
d674 c9				ret 
d675			 
d675			 
d675			cin_wait: 
d675			;	ld a, 0 
d675			;	ret 
d675			 
d675				;in a,(SC114_SIO_1_IN) 
d675			        ; Use SCM API to get from whatever console device we are using 
d675 c5				push bc 
d676 0e 01			ld c, $01 
d678 f7				rst $30 
d679 c1				pop bc 
d67a c9				ret 
d67b			 
d67b			cin: 
d67b			 
d67b			 
d67b c5				push bc 
d67c			 
d67c				; any key waiting to process? 
d67c 0e 03			ld c, $03 
d67e f7				rst $30 
d67f 28 05			jr z, .cin_skip 
d681			 
d681				; yep, get it 
d681			 
d681 0e 01			ld c, $01 
d683 f7				rst $30 
d684 c1				pop bc 
d685 c9				ret 
d686			.cin_skip: 
d686 3e 00			ld a, 0 
d688 c1				pop bc 
d689 c9				ret 
d68a			 
d68a			 
d68a			 
d68a			 
# End of file firmware_key_serial.asm
d68a			endofcode:  
d68a			baseram:  
d68a 00				nop 
d68b			 
d68b			heap_start: equ baseram+15  ; Starting address of heap 
d68b			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d68b			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d68b			;VDU:  EQU     endofcode           ; BASIC Work space 
d68b			; eof 
d68b			 
# End of file os_mega_sc114.asm
d68b
