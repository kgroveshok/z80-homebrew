# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 4f 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			if BASE_KEV = 1  
801c			 
801c				; need to be at $66 for nmi support 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255 
801c				jp nmi 
801c			endif 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 0       
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c			;	call break_point_state  
801c			; now use the break point debug vector  
801c				call debug_vector  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801c			  
801c			debug_mark: equ debug_vector - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			os_stack_1: equ scratch - 3       ; stack holding area 1  
801c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ os_stack_4-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			;os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_new_exec_ptr - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c			;	ld a, ' ' 
801c			;	ld (os_view_disable), a 
801c				call bp_on 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 10 ed				ld hl, display_fb1  
801f 22 cc eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 ce eb				ld hl, display_fb2  
8028 22 cc eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b1 ed				ld hl, display_fb0  
8031 22 cc eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd 76 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 18 e4			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 ad 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c2 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 6b ee		ld (debug_mark),a  
8091 32 6c ee		ld (debug_mark+1),a  
8094 32 6d ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 6e ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 73 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 6b ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 6c ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 6d ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 6f ee			call debug_vector  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 7a ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 6b ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 6c ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 6d ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 6f ee			call debug_vector  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 7a ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 6b ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 6c ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 6d ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 6f ee			call debug_vector  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 73 ea				ld hl, (store_tmp1) 
8110 11 7d ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 6b ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 6c ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 6d ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 6f ee			call debug_vector  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 6b ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 6c ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 6d ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 6f ee			call debug_vector  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 6b ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 6c ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 6d ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 6f ee			call debug_vector  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 6b ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 6c ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 6d ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 6f ee			call debug_vector  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 6b ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 6c ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 6d ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 6f ee			call debug_vector  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 7a ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 6b ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 6c ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 6d ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 6f ee			call debug_vector  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 6b ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 6c ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 6d ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 6f ee			call debug_vector  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 7a ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 6b ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 6c ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 6d ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 7a ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 6f ee			call debug_vector  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 7b ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 6b ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 6c ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 6d ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 6f ee			call debug_vector  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 6b ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 6c ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 6d ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 6f ee			call debug_vector  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 7a ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 7b ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 7d ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 86 ea			ld hl, store_page+3+9 
82b5 3a 5f ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 7a ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 6b ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 6c ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 6d ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 6f ee			call debug_vector  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 6b ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 6c ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 6d ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 6f ee			call debug_vector  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 6b ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 6c ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 6d ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 6f ee			call debug_vector  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 7d ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 6b ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 6c ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 6d ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 6f ee			call debug_vector  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 7a ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 6b ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 6c ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 6d ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 6f ee			call debug_vector  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 6b ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 6c ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 6d ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 6f ee			call debug_vector  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 7a ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 6b ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 6c ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 6d ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 6f ee			call debug_vector  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 7a ea			ld a, (store_page)	; get file id 
8410 32 6e ea			ld (store_tmpid), a 
8413			 
8413 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8416 32 6d ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 7a ea			ld (store_page), a 
841f 32 7b ea			ld (store_page+1),a 
8422 11 7a ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 6b ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 6c ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 6d ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 6f ee			call debug_vector  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 6d ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 6e ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 6b ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 6c ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 6d ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 6f ee			call debug_vector  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 7a ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 7a ea			ld (store_page), a 
8482 32 7b ea			ld (store_page+1),a 
8485 11 7a ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 6b ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 6c ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 6d ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 6f ee			call debug_vector  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 6b ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 6c ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 6d ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 6f ee			call debug_vector  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 6b ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 6c ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 6d ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 6f ee			call debug_vector  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 6b ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 6c ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 6d ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 6f ee			call debug_vector  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 6b ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 6c ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 6d ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 6f ee			call debug_vector  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 7a ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 7a ea			ld (store_page),a 
85a3				 
85a3 32 6e ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 7a ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 6b ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 6c ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 6d ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 6f ee			call debug_vector  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 7a ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 6b ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 6c ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 6d ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 6f ee			call debug_vector  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 6b ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 6c ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 6d ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 6f ee			call debug_vector  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 65 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 7a ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 7b ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 6b ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 6c ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 6d ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 6f ee			call debug_vector  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 6b ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 6c ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 6d ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 6f ee			call debug_vector  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 6b ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 6c ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 6d ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 6f ee			call debug_vector  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 65 ea			ld hl,(store_tmppageid) 
868b 11 7a ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 6b ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 6c ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 6d ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 6f ee			call debug_vector  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 6e ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 6b ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 6c ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 6d ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 6f ee			call debug_vector  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 6b ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 6c ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 6d ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 6f ee			call debug_vector  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 6b ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 6c ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 6d ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 6f ee			call debug_vector  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 6b ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 6b ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 6c ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 6d ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd 6f ee			call debug_vector  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 6d ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 6b ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 6c ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 6d ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd 6f ee			call debug_vector  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 75 ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 6b ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 6c ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 6d ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd 6f ee			call debug_vector  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 6b ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 6c ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 6d ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd 6f ee			call debug_vector  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 6b ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 6c ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 6d ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd 6f ee			call debug_vector  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 6b ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 6b ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 6c ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 6d ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd 6f ee			call debug_vector  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 6b ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 6c ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 6d ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd 6f ee			call debug_vector  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 6b ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 6c ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 6d ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd 6f ee			call debug_vector  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 6b ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 6c ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 6d ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd 6f ee			call debug_vector  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 6e ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 6e ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 65 ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 6b ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 6c ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 6d ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd 6f ee			call debug_vector  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 7a ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 6b ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 6c ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 6d ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd 6f ee			call debug_vector  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 7c ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 7c ea			ld (store_page+2), a 
88e3 32 6d ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 6b ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 6c ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 6d ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd 6f ee			call debug_vector  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 65 ea			ld hl, (store_tmppageid) 
8905 11 7a ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 65 ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 6b ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 6c ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 6d ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd 6f ee			call debug_vector  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 7a ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 6e ea				ld a, (store_tmpid) 
894b 32 7a ea				ld (store_page), a   ; file id 
894e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 7b ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 7c ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 6b ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 6c ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 6d ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd 6f ee			call debug_vector  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 65 ea			ld hl, (store_tmppageid) 
8985 11 7a ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 6b ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 6c ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 6d ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6f ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 6e ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 7a ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 7b ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a c6 eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 c6 eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd 6b 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 c7 eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 c7 eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a cc eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b1 ed				ld hl, display_fb0 
8a48 22 cc eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd b4 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 10 ed				ld hl, display_fb1 
8a69 22 cc eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a cc eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a cc eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a cc eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a cc eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a cc eb			ld hl, (display_fb_active) 
8ad6 cd 8d e3			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 73 ea				ld (store_tmp1), hl 
8ae3 32 71 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b1 ed				ld hl, display_fb0 
8ae9 22 cc eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 6f ea				ld (store_tmp3), a   ; display row count 
8af7 3a 71 ea				ld a,( store_tmp2) 
8afa 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 72 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 73 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 6f ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 72 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 6f ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 6f ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 19 e4				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 71 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 71 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 71 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 71 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 71 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 10 ed				ld hl, display_fb1 
8ba6 22 cc eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a ab eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 ab eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b1 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b3 eb		        ld hl,LFSRSeed+6 
8bf9 11 b4 eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a a5 eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 a5 eb		    ld (seed1),hl 
8c0f 2a a3 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a3 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 a9 eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c1 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 60 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 5f ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 60 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 60 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 5f ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 5f ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 60 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 69 ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 67 ee			ld de, (input_start) 
8d5e 3a 64 ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 5f ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 62 ee				ld a,(input_at_cursor) 
8d6e 11 c1 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 67 ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 5a ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd 1f e4				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 67 ee				ld hl, (input_start) 
8d8d 3a 55 ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 69 ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 64 ee				ld a, (input_at_pos) 
8d9e 32 62 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 55 ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 69 ee				ld (input_ptr), hl 
8dc6 3a 62 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 62 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 69 ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 69 ee				ld (input_ptr), hl 
8de5 3a 62 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 62 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 55 ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 55 ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 69 ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 69 ee				ld (input_ptr), hl 
8e05					 
8e05 3a 62 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 62 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 5f ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 60 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 55 ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 55 ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 62 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 62 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 69 ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 69 ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 5f ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 60 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 67 ee				ld hl, (input_start) 
8e4e 22 69 ee				ld (input_ptr), hl 
8e51			 
8e51 3a 64 ee				ld a, (input_at_pos) 
8e54 32 62 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 55 ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 e8 e5				ld hl, os_cli_cmd 
8e5f 11 e7 e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 55 ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 55 ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 69 ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 69 ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 62 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 62 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 5f ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 60 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 62 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 55 ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 55 ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 62 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 62 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 69 ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 69 ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 69 ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 69 ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 5f ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 60 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 67 ee				ld hl, (input_start) 
8eef 3a 5a ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 5a ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 55 ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 55 ee				ld (input_cursor), a 
8f17			 
8f17 3a 62 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 62 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 67 ee				ld hl, (input_start) 
8f24 3a 5a ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 64 ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 67 ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 69 ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 66 ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 55 ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 69 ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c1 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 64 ee				ld a,(input_at_pos) 
8f58 cd 7d e3		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 67 ee	            	LD   de, (input_start) 
8f5f cd 77 e3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd 1f e4				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 69 ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c1 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 69 ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 69 ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 69 ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 69 ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 69 ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c1 e2			ld hl, scratch 
8fb2 11 e7 e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c1 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 69 ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 2b 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 f5 e2			ld (scratch+52),a 
90b3				 
90b3 21 f3 e2			ld hl,scratch+50 
90b6 22 e4 e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				call bp_on 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 3d e4		      ld    HL, heap_start 
9183 22 38 e4		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 3a e4		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 98 e2		      ld    HL, heap_start+heap_size-4 
918f 22 3d e4		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 5b fe		      ld    HL, heap_size-4 
9195 22 3f e4		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 9a e2		      ld    (heap_start+heap_size-2), HL 
919e 22 98 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 38 e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 38 e4		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			; Now handled by SPI  
933c			;if SOUND_ENABLE  
933c			;	include "firmware_sound.asm"  
933c			;endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 62 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347			;	cp 1 
9347			;	call z, .savetostore 
9347			 
9347 fe 01			cp 1 
9349			if STARTUP_V1 
9349 cc 78 93			call z, .selautoload 
934c			endif 
934c			 
934c			if STARTUP_V2 
934c				call z, .enautoload 
934c			endif 
934c fe 02			cp 2 
934e cc 6e 93			call z, .disautoload 
9351			;	cp 3 
9351			;	call z, .selbank 
9351 fe 03			cp 3 
9353 cc 96 93			call z, .debug_tog 
9356 fe 04			cp 4 
9358 cc e4 94			call z, .bpsgo 
935b fe 05			cp 5 
935d cc bf 93			call z, hardware_diags 
9360			if STARTUP_V2 
9360				cp 6 
9360				call z, create_startup 
9360			endif 
9360 18 da			jr config 
9362			 
9362			.configmn: 
9362			;	dw prom_c3 
9362 d2 96			dw prom_c2 
9364 e7 96			dw prom_c2a 
9366			;	dw prom_c2b 
9366			;	dw prom_c4 
9366 06 97			dw prom_m4 
9368 21 97			dw prom_m4b 
936a 29 97			dw prom_c1 
936c			if STARTUP_V2 
936c				dw prom_c9 
936c			endif 
936c 00 00			dw 0 
936e				 
936e			 
936e			if STARTUP_V2 
936e			.enautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 1 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e				ld hl, prom_notav 
936e				ld de, prom_empty 
936e				call info_panel 
936e				endif 
936e			 
936e			 
936e				ret 
936e			endif 
936e			 
936e			.disautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 0 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e 21 38 97			ld hl, prom_notav 
9371 11 4e 97			ld de, prom_empty 
9374 cd 40 8a			call info_panel 
9377				endif 
9377			 
9377			 
9377 c9				ret 
9378			 
9378			if STARTUP_V1 
9378			 
9378			; Select auto start 
9378			 
9378			.selautoload: 
9378			 
9378				 
9378				if STORAGE_SE 
9378			 
9378					call config_dir 
9378				        ld hl, scratch 
9378					ld a, 0 
9378					call menu 
9378			 
9378					cp 0 
9378					ret z 
9378			 
9378					dec a 
9378			 
9378			 
9378					; locate menu option 
9378			 
9378					ld hl, scratch 
9378					call table_lookup 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALl" 
9378						CALLMONITOR 
9378					endif 
9378					; with the pointer to the menu it, the byte following the zero term is the file id 
9378			 
9378					ld a, 0 
9378					ld bc, 50   ; max of bytes to look at 
9378					cpir  
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALb" 
9378						CALLMONITOR 
9378					endif 
9378					;inc hl 
9378			 
9378					ld a, (hl)   ; file id 
9378					 
9378				        ; save bank and file ids 
9378			 
9378					push af 
9378			 
9378			; TODO need to save to block 0 on bank 1	 
9378			 
9378					call storage_get_block_0 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "AL0" 
9378						CALLMONITOR 
9378					endif 
9378					pop af 
9378			 
9378					ld (store_page+STORE_0_FILERUN),a 
9378					 
9378					; save bank id 
9378			 
9378					ld a,(spi_device) 
9378					ld (store_page+STORE_0_BANKRUN),a 
9378			 
9378					; enable auto run of store file 
9378			 
9378					ld a, 1 
9378					ld (store_page+STORE_0_AUTOFILE),a 
9378			 
9378					; save buffer 
9378			 
9378					ld hl, 0 
9378					ld de, store_page 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALw" 
9378						CALLMONITOR 
9378					endif 
9378				call storage_write_block	 ; save update 
9378			  
9378			 
9378			 
9378			 
9378					ld hl, scratch 
9378					call config_fdir 
9378			 
9378				else 
9378			 
9378 21 38 97			ld hl, prom_notav 
937b 11 4e 97			ld de, prom_empty 
937e cd 40 8a			call info_panel 
9381			 
9381				endif 
9381 c9				ret 
9382			endif 
9382			 
9382			 
9382			; Select storage bank 
9382			 
9382			.selbank: 
9382			 
9382			;	if STORAGE_SE 
9382			;	else 
9382			 
9382 21 38 97			ld hl, prom_notav 
9385 11 4e 97			ld de, prom_empty 
9388 cd 40 8a			call info_panel 
938b			;	endif 
938b				 
938b c9				ret 
938c			 
938c			if STORAGE_SE 
938c			 
938c			.config_ldir:   
938c				; Load storage bank labels into menu array 
938c			 
938c				 
938c			 
938c			 
938c				ret 
938c			 
938c			 
938c			endif 
938c			 
938c			 
938c			; Save user words to storage 
938c			 
938c			.savetostore: 
938c			 
938c			;	if STORAGE_SE 
938c			; 
938c			;		call config_dir 
938c			;	        ld hl, scratch 
938c			;		ld a, 0 
938c			;		call menu 
938c			;		 
938c			;		ld hl, scratch 
938c			;		call config_fdir 
938c			; 
938c			;	else 
938c			 
938c 21 38 97			ld hl, prom_notav 
938f 11 4e 97			ld de, prom_empty 
9392 cd 40 8a			call info_panel 
9395			 
9395			;	endif 
9395			 
9395 c9				ret 
9396			 
9396			if STARTUP_V2 
9396			 
9396			create_startup: 
9396			 
9396				ld a, 0 
9396				ld hl, .crstart 
9396				call menu 
9396			 
9396				cp 0 
9396				ret z 
9396			 
9396				cp 1 
9396				call z, .genlsword 
9396				cp 2 
9396				call z, .genedword 
9396			 
9396				cp 3 
9396				call z, .gendemword 
9396			 
9396				cp 4 
9396				call z, .genutlword 
9396				cp 5 
9396				call z, .genspiword 
9396				cp 6 
9396				call z, .genkeyword 
9396				cp 7 
9396				call z, .gensoundword 
9396				jr create_startup 
9396			 
9396			.gensoundword: 
9396				ld hl, crs_sound 
9396				ld de, .soundworddef 
9396				call .genfile 
9396				ret 
9396			.genlsword: 
9396				ld hl, crs_s1 
9396				ld de, .lsworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			.genedword: 
9396				ld de, .edworddef 
9396				ld hl, crs_s2 
9396				call .genfile 
9396				ret 
9396			 
9396			.gendemword: 
9396				ld de, .demoworddef 
9396				ld hl, crs_s3 
9396				call .genfile 
9396				ret 
9396			 
9396			.genutlword: 
9396				ld hl, crs_s4 
9396				ld de, .utilwordef 
9396				call .genfile 
9396				ret 
9396			.genspiword: 
9396				ld hl, crs_s5 
9396				ld de, .spiworddef 
9396				call .genfile 
9396				ret 
9396			.genkeyword: 
9396				ld hl, crs_s6 
9396				ld de, .keyworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			; hl - points to file name 
9396			; de - points to strings to add to file 
9396			 
9396			.genfile: 
9396				push hl 
9396				push de 
9396			 
9396				call clear_display 
9396				ld a, display_row_1 
9396				ld de, .genfiletxt 
9396				call str_at_display 
9396				call update_display 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396			 
9396				push de 
9396				call storage_create 
9396				; id in hl 
9396				pop de   ; table of strings to add 
9396			 
9396			.genloop: 
9396			 
9396				push hl ; save id for next time around 
9396				push de ; save de for next time around 
9396			 
9396				ex de, hl 
9396				call loadwordinhl 
9396				ex de, hl 
9396			 
9396				; need hl to be the id 
9396				; need de to be the string ptr 
9396				 
9396				call storage_append 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396				inc de 
9396				inc de 
9396			 
9396				ld a,(de) 
9396				cp 0 
9396				jr nz, .genloop 
9396				inc de 
9396				ld a, (de) 
9396				dec de 
9396				cp 0 
9396				jr nz, .genloop	 
9396			 
9396				ret 
9396			 
9396			.genfiletxt:  db "Creating file...",0 
9396			 
9396			.soundworddef: 
9396				dw sound1 
9396				dw sound2 
9396				dw sound3 
9396				dw sound4 
9396				dw sound5 
9396				dw sound6 
9396				dw sound7 
9396				dw sound8 
9396				dw sound9 
9396				dw 0 
9396			 
9396			.utilwordef: 
9396				dw strncpy 
9396				dw type 
9396				dw clrstack 
9396				dw longread 
9396				dw start1 
9396				dw start2 
9396				dw start3b 
9396				dw start3c 
9396				dw list 
9396				dw 0 
9396			 
9396			.lsworddef: 
9396				dw start3b 
9396				dw 0 
9396			 
9396			.edworddef: 
9396				dw edit1 
9396				dw edit2 
9396				dw edit3 
9396				dw 0 
9396			 
9396			.demoworddef: 
9396				dw test5 
9396				dw test6 
9396				dw test7 
9396				dw test8 
9396				dw test9 
9396				dw test10 
9396				dw game1 
9396				dw game1a 
9396				dw game1b 
9396				dw game1c 
9396				dw game1d 
9396				dw game1s 
9396				dw game1t 
9396				dw game1f 
9396				dw game1z 
9396				dw game1zz 
9396				dw ssv2 
9396				dw ssv3 
9396				dw ssv4 
9396				dw ssv5 
9396				dw ssv1 
9396				dw ssv1cpm	 
9396				dw game2b 
9396				dw game2bf 
9396				dw game2mba 
9396				dw game2mbas	 
9396				dw game2mbht 
9396				dw game2mbms 
9396				dw game2mb 
9396				dw game3w 
9396				dw game3p 
9396				dw game3sc 
9396				dw game3vsi 
9396				dw game3vs 
9396				dw 0 
9396			 
9396			 
9396			.spiworddef: 
9396			 
9396			    dw spi1 
9396			    dw spi2 
9396			    dw spi3 
9396			    dw spi4 
9396			    dw spi5 
9396			    dw spi6 
9396			    dw spi7 
9396			 
9396			    dw spi8 
9396			    dw spi9 
9396			    dw spi10 
9396			    dw 0 
9396			 
9396			.keyworddef: 
9396			 
9396				dw keyup 
9396				dw keydown 
9396				dw keyleft 
9396				dw keyright 
9396				dw 	keyf1 
9396				dw keyf2 
9396				dw keyf3 
9396				dw keyf4 
9396				dw keyf5 
9396				dw keyf6 
9396				dw keyf7 
9396				dw keyf8 
9396				dw keyf9 
9396				dw keyf10 
9396				dw keyf11 
9396				dw keyf12 
9396				dw keytab 
9396				dw keycr 
9396				dw keyhome 
9396				dw keyend 
9396				dw keybs 
9396				dw 0 
9396			 
9396			.crstart: 
9396				dw crs_s1 
9396				dw crs_s2 
9396				dw crs_s3 
9396				dw crs_s4 
9396				dw crs_s5 
9396				dw crs_s6 
9396				dw crs_sound 
9396				dw 0 
9396			 
9396			endif 
9396			 
9396			 
9396			if STORAGE_SE 
9396			 
9396			config_fdir: 
9396				; using the scratch dir go through and release the memory allocated for each string 
9396				 
9396				ld hl, scratch 
9396			.cfdir:	ld e,(hl) 
9396				inc hl 
9396				ld d,(hl) 
9396				inc hl 
9396			 
9396				ex de, hl 
9396				call ishlzero 
9396				ret z     ; return on null pointer 
9396				call free 
9396				ex de, hl 
9396				jr .cfdir 
9396			 
9396			 
9396				ret 
9396			 
9396			 
9396			config_dir: 
9396			 
9396				; for the config menus that need to build a directory of storage call this routine 
9396				; it will construct a menu in scratch to pass to menu 
9396			 
9396				; open storage device 
9396			 
9396				; execute DIR to build a list of files and their ids into scratch in menu format 
9396				; once the menu has finished then will need to call config_fdir to release the strings 
9396				 
9396				; c = number items 
9396			 
9396				 
9396				call storage_get_block_0 
9396			 
9396				ld hl, store_page     ; get current id count 
9396				ld b, (hl) 
9396				ld c, 0    ; count of files   
9396			 
9396			 
9396				ld hl, scratch 
9396				ld (store_tmp2), hl    ; location to poke strings 
9396			 
9396				; check for empty drive 
9396			 
9396				ld a, 0 
9396				cp b 
9396				jp z, .dirdone 
9396			 
9396				 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdc" 
9396						CALLMONITOR 
9396					endif 
9396			 
9396			 
9396			.diritem:	 
9396				push bc 
9396				; for each of the current ids do a search for them and if found push to stack 
9396			 
9396					ld hl, STORE_BLOCK_PHY 
9396					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9396					ld e,b 
9396			 
9396					call storage_findnextid 
9396			 
9396			 
9396					; if found hl will be non zero 
9396			 
9396					call ishlzero 
9396					jr z, .dirnotfound 
9396			 
9396					; increase count 
9396			 
9396					pop bc	 
9396					inc c 
9396					push bc 
9396					 
9396			 
9396					; get file header and push the file name 
9396			 
9396					ld de, store_page 
9396					call storage_read_block 
9396			 
9396					; push file id to stack 
9396				 
9396					ld a, (store_page) 
9396					ld h, 0 
9396					ld l, a 
9396			 
9396					;call forth_push_numhl 
9396					; TODO store id 
9396			 
9396					push hl 
9396			 
9396					; push extent count to stack  
9396				 
9396					ld hl, store_page+3 
9396			 
9396					; get file name length 
9396			 
9396					call strlenz   
9396			 
9396					inc hl   ; cover zero term 
9396					inc hl  ; stick the id at the end of the area 
9396			 
9396					push hl 
9396					pop bc    ; move length to bc 
9396			 
9396					call malloc 
9396			 
9396					; TODO save malloc area to scratch 
9396			 
9396					ex de, hl 
9396					ld hl, (store_tmp2) 
9396					ld (hl), e 
9396					inc hl 
9396					ld (hl), d 
9396					inc hl 
9396					ld (store_tmp2), hl 
9396			 
9396					 
9396			 
9396					;pop hl   ; get source 
9396			;		ex de, hl    ; swap aronund	 
9396			 
9396					ld hl, store_page+3 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "CFd" 
9396						CALLMONITOR 
9396					endif 
9396					ldir 
9396			 
9396					; de is past string, move back one and store id 
9396					 
9396					dec de 
9396			 
9396					; store file id 
9396			 
9396					pop hl 
9396					ex de,hl 
9396					ld (hl), e 
9396			 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdi" 
9396						CALLMONITOR 
9396					endif 
9396					 
9396			.dirnotfound: 
9396					pop bc     
9396					djnz .diritem 
9396				 
9396			.dirdone:	 
9396			 
9396					ld a, 0 
9396					ld hl, (store_tmp2) 
9396					ld (hl), a 
9396					inc hl 
9396					ld (hl), a 
9396					inc hl 
9396					; push a count of the dir items found 
9396			 
9396			;		ld h, 0 
9396			;		ld l, c 
9396			 
9396				ret 
9396			 
9396			endif 
9396			 
9396			 
9396			; Settings 
9396			; Run  
9396			 
9396			 
9396			 
9396			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9396			;;hd_menu2:   db "        2: Editor",0   
9396			;hd_menu2:   db "        2: Editor       6: Menu",0   
9396			;hd_menu3:   db "        3: Storage",0 
9396			;hd_menu4:   db "0=quit  4: Debug",0 
9396			;hd_don:     db "ON",0 
9396			;hd_doff:     db "OFF",0 
9396			; 
9396			; 
9396			; 
9396			;hardware_diags_old:       
9396			; 
9396			;.diagmenu: 
9396			;	call clear_display 
9396			;	ld a, display_row_1 
9396			;	ld de, hd_menu1 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_2 
9396			;	ld de, hd_menu2 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_3 
9396			;	ld de, hd_menu3 
9396			;	call str_at_display 
9396			; 
9396			;	ld a,  display_row_4 
9396			;	ld de, hd_menu4 
9396			;	call str_at_display 
9396			; 
9396			;	; display debug state 
9396			; 
9396			;	ld de, hd_don 
9396			;	ld a, (os_view_disable) 
9396			;	cp 0 
9396			;	jr z, .distog 
9396			;	ld de, hd_doff 
9396			;.distog: ld a, display_row_4+17 
9396			;	call str_at_display 
9396			; 
9396			;	call update_display 
9396			; 
9396			;	call cin_wait 
9396			; 
9396			; 
9396			; 
9396			;	cp '4' 
9396			;	jr nz, .diagn1 
9396			; 
9396			;	; debug toggle 
9396			; 
9396			;	ld a, (os_view_disable) 
9396			;	ld b, '*' 
9396			;	cp 0 
9396			;	jr z, .debtog 
9396			;	ld b, 0 
9396			;.debtog:	 
9396			;	ld a,b 
9396			;	ld (os_view_disable),a 
9396			; 
9396			;.diagn1: cp '0' 
9396			;	 ret z 
9396			; 
9396			;;	cp '1' 
9396			;;       jp z, matrix	 
9396			;;   TODO keyboard matrix test 
9396			; 
9396			;	cp '2' 
9396			;	jp z, .diagedit 
9396			; 
9396			;;	cp '6' 
9396			;;	jp z, .menutest 
9396			;;if ENABLE_BASIC 
9396			;;	cp '6' 
9396			;;	jp z, basic 
9396			;;endif 
9396			 ; 
9396			;	jp .diagmenu 
9396			; 
9396			; 
9396			;	ret 
9396			 
9396			 
9396			.debug_tog: 
9396 21 e0 93			ld hl, .menudebug 
9399				 
9399			;	ld a, (os_view_disable) 
9399			;	cp '*' 
9399 3a 6f ee			ld a,(debug_vector) 
939c fe c9			cp $C9   ; RET 
939e 20 04			jr nz,.tdon  
93a0 3e 01			ld a, 1 
93a2 18 02			jr .tog1 
93a4 3e 00		.tdon: ld a, 0 
93a6			 
93a6			.tog1: 
93a6 cd e0 8a			call menu 
93a9 fe 00			cp 0 
93ab c8				ret z 
93ac fe 01			cp 1    ; disable debug 
93ae 28 04			jr z, .dtog0 
93b0 3e 2a			ld a, '*' 
93b2 18 05			jr .dtogset 
93b4			.dtog0:  
93b4				;ld a, 0 
93b4 cd d2 94			call bp_on 
93b7 18 dd			jr .debug_tog 
93b9			.dtogset:  
93b9				; ld (os_view_disable), a 
93b9 cd de 94			call bp_off 
93bc c3 96 93			jp .debug_tog 
93bf			 
93bf			 
93bf			hardware_diags:       
93bf			 
93bf			.diagm: 
93bf 21 d2 93			ld hl, .menuitems 
93c2 3e 00			ld a, 0 
93c4 cd e0 8a			call menu 
93c7			 
93c7 fe 00		         cp 0 
93c9 c8				 ret z 
93ca			 
93ca fe 02			cp 2 
93cc ca 2b 94			jp z, .diagedit 
93cf			 
93cf			;	cp '6' 
93cf			;	jp z, .menutest 
93cf			;if ENABLE_BASIC 
93cf			;	cp '6' 
93cf			;	jp z, basic 
93cf			;endif 
93cf			  
93cf c3 bf 93			jp .diagm 
93d2			 
93d2				 
93d2 e6 93		.menuitems:   	dw .m1 
93d4 f1 93				dw .m2 
93d6 f8 93				dw .m3 
93d8 00 94				dw .m5 
93da 06 94				dw .m5a 
93dc 0f 94				dw .m5b 
93de 00 00				dw 0 
93e0			 
93e0			.menudebug: 
93e0 18 94				dw .m6 
93e2 21 94				dw .m7 
93e4 00 00				dw 0 
93e6			 
93e6 .. 00		.m1:   db "Key Matrix",0 
93f1 .. 00		.m2:   db "Editor",0 
93f8 .. 00		.m3:   db "Storage",0 
9400 .. 00		.m5:   db "Sound",0 
9406 .. 00		.m5a:  db "RAM Test",0 
940f .. 00		.m5b:  db "LCD Test",0 
9418			 
9418 .. 00		.m6:   db "Debug ON",0 
9421 .. 00		.m7:   db "Debug OFF",0 
942b			 
942b			; debug editor 
942b			 
942b			.diagedit: 
942b			 
942b 21 c1 e2			ld hl, scratch 
942e			;	ld bc, 250 
942e			;	ldir 
942e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
942e 3e 00			ld a, 0 
9430 77				ld (hl), a 
9431 23				inc hl 
9432 77				ld (hl), a 
9433 23				inc hl 
9434 77				ld (hl), a 
9435			 
9435 cd af 8a		        call clear_display 
9438 cd d2 8a			call update_display 
943b				;ld a, 1 
943b				;ld (hardware_diag), a 
943b			.diloop: 
943b 3e 00			ld a, display_row_1 
943d 0e 00			ld c, 0 
943f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9441 1e 28			ld e, 40 
9443			 
9443 21 c1 e2			ld hl, scratch	 
9446 cd 09 8d			call input_str 
9449			 
9449 3e 28			ld a, display_row_2 
944b 11 c1 e2			ld de, scratch 
944e cd c2 8a			call str_at_display 
9451 cd d2 8a			call update_display 
9454			 
9454 c3 3b 94			jp .diloop 
9457			 
9457			 
9457			; pass word in hl 
9457			; a has display location 
9457			display_word_at: 
9457 f5				push af 
9458 e5				push hl 
9459 7c				ld a,h 
945a 21 c6 e5			ld hl, os_word_scratch 
945d cd dd 8f			call hexout 
9460 e1				pop hl 
9461 7d				ld a,l 
9462 21 c8 e5			ld hl, os_word_scratch+2 
9465 cd dd 8f			call hexout 
9468 21 ca e5			ld hl, os_word_scratch+4 
946b 3e 00			ld a,0 
946d 77				ld (hl),a 
946e 11 c6 e5			ld de,os_word_scratch 
9471 f1				pop af 
9472 cd c2 8a				call str_at_display 
9475 c9				ret 
9476			 
9476			display_ptr_state: 
9476			 
9476				; to restore afterwards 
9476			 
9476 d5				push de 
9477 c5				push bc 
9478 e5				push hl 
9479 f5				push af 
947a			 
947a				; for use in here 
947a			 
947a			;	push bc 
947a			;	push de 
947a			;	push hl 
947a			;	push af 
947a			 
947a cd af 8a			call clear_display 
947d			 
947d 11 55 96			ld de, .ptrstate 
9480 3e 00			ld a, display_row_1 
9482 cd c2 8a			call str_at_display 
9485			 
9485				; display debug step 
9485			 
9485			 
9485 11 6b ee			ld de, debug_mark 
9488 3e 26			ld a, display_row_1+display_cols-2 
948a cd c2 8a			call str_at_display 
948d			 
948d				; display a 
948d 11 5f 96			ld de, .ptrcliptr 
9490 3e 28			ld a, display_row_2 
9492 cd c2 8a			call str_at_display 
9495			 
9495 f1				pop af 
9496 2a 40 ea			ld hl,(cli_ptr) 
9499 3e 30			ld a, display_row_2+8 
949b cd 57 94			call display_word_at 
949e			 
949e			 
949e				; display hl 
949e			 
949e			 
949e 11 67 96			ld de, .ptrclioptr 
94a1 3e 32			ld a, display_row_2+10 
94a3 cd c2 8a			call str_at_display 
94a6			; 
94a6			;	pop hl 
94a6 3e 35			ld a, display_row_2+13 
94a8 2a 3e ea			ld hl,(cli_origptr) 
94ab cd 57 94			call display_word_at 
94ae			; 
94ae			;	 
94ae			;	; display de 
94ae			 
94ae			;	ld de, .regstatede 
94ae			;	ld a, display_row_3 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop de 
94ae			;	ld h,d 
94ae			;	ld l, e 
94ae			;	ld a, display_row_3+3 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display bc 
94ae			 
94ae			;	ld de, .regstatebc 
94ae			;	ld a, display_row_3+10 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop bc 
94ae			;	ld h,b 
94ae			;	ld l, c 
94ae			;	ld a, display_row_3+13 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display dsp 
94ae			 
94ae			;	ld de, .regstatedsp 
94ae			;	ld a, display_row_4 
94ae			;	call str_at_display 
94ae			 
94ae				 
94ae			;	ld hl,(cli_data_sp) 
94ae			;	ld a, display_row_4+4 
94ae			;	call display_word_at 
94ae			 
94ae				; display rsp 
94ae			 
94ae 11 96 96			ld de, .regstatersp 
94b1 3e 82			ld a, display_row_4+10 
94b3 cd c2 8a			call str_at_display 
94b6			 
94b6				 
94b6 2a f2 e9			ld hl,(cli_ret_sp) 
94b9 3e 86			ld a, display_row_4+14 
94bb cd 57 94			call display_word_at 
94be			 
94be cd d2 8a			call update_display 
94c1			 
94c1 cd f2 89			call delay1s 
94c4 cd f2 89			call delay1s 
94c7 cd f2 89			call delay1s 
94ca			 
94ca			 
94ca cd b4 9a			call next_page_prompt 
94cd			 
94cd				; restore  
94cd			 
94cd f1				pop af 
94ce e1				pop hl 
94cf c1				pop bc 
94d0 d1				pop de 
94d1 c9				ret 
94d2			 
94d2			; Update the break point vector so that the user can hook a new routine 
94d2			 
94d2			bp_on: 
94d2 3e c3			ld a, $c3    ; JP 
94d4 32 6f ee			ld (debug_vector), a 
94d7 21 e4 94			ld hl, break_point_state 
94da 22 70 ee			ld (debug_vector+1), hl 
94dd c9				ret 
94de			 
94de			bp_off: 
94de 3e c9			ld a, $c9    ; RET 
94e0 32 6f ee			ld (debug_vector), a 
94e3 c9				ret 
94e4			 
94e4			 
94e4			break_point_state: 
94e4			;	push af 
94e4			; 
94e4			;	; see if disabled 
94e4			; 
94e4			;	ld a, (os_view_disable) 
94e4			;	cp '*' 
94e4			;	jr nz, .bpsgo 
94e4			;	pop af 
94e4			;	ret 
94e4			 
94e4			.bpsgo: 
94e4			;	pop af 
94e4 f5				push af 
94e5 22 a3 e2			ld (os_view_hl), hl 
94e8 ed 53 a1 e2		ld (os_view_de), de 
94ec ed 43 9f e2		ld (os_view_bc), bc 
94f0 e5				push hl 
94f1 6f				ld l, a 
94f2 26 00			ld h, 0 
94f4 22 a5 e2			ld (os_view_af),hl 
94f7			 
94f7 21 b1 ed				ld hl, display_fb0 
94fa 22 cc eb				ld (display_fb_active), hl 
94fd e1				pop hl	 
94fe			 
94fe 3e 31			ld a, '1' 
9500 fe 2a		.bps1:  cp '*' 
9502 cc de 94			call z, bp_off 
9505			;	jr nz, .bps1b 
9505			;	ld (os_view_disable),a 
9505 fe 31		.bps1b:  cp '1' 
9507 20 14			jr nz, .bps2 
9509			 
9509				; display reg 
9509			 
9509				 
9509			 
9509 3a a5 e2			ld a, (os_view_af) 
950c 2a a3 e2			ld hl, (os_view_hl) 
950f ed 5b a1 e2		ld de, (os_view_de) 
9513 ed 4b 9f e2		ld bc, (os_view_bc) 
9517 cd b1 95			call display_reg_state 
951a c3 9d 95			jp .bpschk 
951d			 
951d fe 32		.bps2:  cp '2' 
951f 20 08			jr nz, .bps3 
9521				 
9521				; display hl 
9521 2a a3 e2			ld hl, (os_view_hl) 
9524 cd 9b 96			call display_dump_at_hl 
9527			 
9527 18 74			jr .bpschk 
9529			 
9529 fe 33		.bps3:  cp '3' 
952b 20 08			jr nz, .bps4 
952d			 
952d			        ; display de 
952d 2a a1 e2			ld hl, (os_view_de) 
9530 cd 9b 96			call display_dump_at_hl 
9533			 
9533 18 68			jr .bpschk 
9535 fe 34		.bps4:  cp '4' 
9537 20 08			jr nz, .bps5 
9539			 
9539			        ; display bc 
9539 2a 9f e2			ld hl, (os_view_bc) 
953c cd 9b 96			call display_dump_at_hl 
953f			 
953f 18 5c			jr .bpschk 
9541 fe 35		.bps5:  cp '5' 
9543 20 08		        jr nz, .bps7 
9545			 
9545				; display cur ptr 
9545 2a 40 ea			ld hl, (cli_ptr) 
9548 cd 9b 96			call display_dump_at_hl 
954b			 
954b 18 50			jr .bpschk 
954d fe 36		.bps7:  cp '6' 
954f 20 08			jr nz, .bps8b 
9551				 
9551				; display cur orig ptr 
9551 2a 3e ea			ld hl, (cli_origptr) 
9554 cd 9b 96			call display_dump_at_hl 
9557 18 44			jr .bpschk 
9559 fe 37		.bps8b:  cp '7' 
955b 20 08			jr nz, .bps9 
955d				 
955d				; display dsp 
955d 2a ee e9			ld hl, (cli_data_sp) 
9560 cd 9b 96			call display_dump_at_hl 
9563			 
9563 18 38			jr .bpschk 
9565 fe 39		.bps9:  cp '9' 
9567 20 05			jr nz, .bps8c 
9569				 
9569				; display SP 
9569			;	ld hl, sp 
9569 cd 9b 96			call display_dump_at_hl 
956c			 
956c 18 2f			jr .bpschk 
956e fe 38		.bps8c:  cp '8' 
9570 20 08			jr nz, .bps8d 
9572				 
9572				; display rsp 
9572 2a f2 e9			ld hl, (cli_ret_sp) 
9575 cd 9b 96			call display_dump_at_hl 
9578			 
9578 18 23			jr .bpschk 
957a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
957c 20 05			jr nz, .bps8 
957e cd 82 98			call monitor 
9581			 
9581 18 1a			jr .bpschk 
9583 fe 30		.bps8:  cp '0' 
9585 20 16			jr nz, .bpschk 
9587			 
9587 21 10 ed				ld hl, display_fb1 
958a 22 cc eb				ld (display_fb_active), hl 
958d cd d2 8a				call update_display 
9590			 
9590				;ld a, (os_view_af) 
9590 2a a3 e2			ld hl, (os_view_hl) 
9593 ed 5b a1 e2		ld de, (os_view_de) 
9597 ed 4b 9f e2		ld bc, (os_view_bc) 
959b f1				pop af 
959c c9				ret 
959d			 
959d			.bpschk:   
959d cd f2 89			call delay1s 
95a0 3e 9f		ld a,display_row_4 + display_cols - 1 
95a2 11 b2 9a		        ld de, endprg 
95a5 cd c2 8a			call str_at_display 
95a8 cd d2 8a			call update_display 
95ab cd 19 e4			call cin_wait 
95ae			 
95ae c3 00 95			jp .bps1 
95b1			 
95b1			 
95b1			display_reg_state: 
95b1			 
95b1				; to restore afterwards 
95b1			 
95b1 d5				push de 
95b2 c5				push bc 
95b3 e5				push hl 
95b4 f5				push af 
95b5			 
95b5				; for use in here 
95b5			 
95b5 c5				push bc 
95b6 d5				push de 
95b7 e5				push hl 
95b8 f5				push af 
95b9			 
95b9 cd af 8a			call clear_display 
95bc			 
95bc 11 71 96			ld de, .regstate 
95bf 3e 00			ld a, display_row_1 
95c1 cd c2 8a			call str_at_display 
95c4			 
95c4				; display debug step 
95c4			 
95c4			 
95c4 11 6b ee			ld de, debug_mark 
95c7 3e 25			ld a, display_row_1+display_cols-3 
95c9 cd c2 8a			call str_at_display 
95cc			 
95cc				; display a 
95cc 11 8d 96			ld de, .regstatea 
95cf 3e 28			ld a, display_row_2 
95d1 cd c2 8a			call str_at_display 
95d4			 
95d4 e1				pop hl 
95d5			;	ld h,0 
95d5			;	ld l, a 
95d5 3e 2b			ld a, display_row_2+3 
95d7 cd 57 94			call display_word_at 
95da			 
95da			 
95da				; display hl 
95da			 
95da			 
95da 11 81 96			ld de, .regstatehl 
95dd 3e 32			ld a, display_row_2+10 
95df cd c2 8a			call str_at_display 
95e2			 
95e2 e1				pop hl 
95e3 3e 35			ld a, display_row_2+13 
95e5 cd 57 94			call display_word_at 
95e8			 
95e8				 
95e8				; display de 
95e8			 
95e8 11 85 96			ld de, .regstatede 
95eb 3e 50			ld a, display_row_3 
95ed cd c2 8a			call str_at_display 
95f0			 
95f0 e1				pop hl 
95f1			;	ld h,d 
95f1			;	ld l, e 
95f1 3e 53			ld a, display_row_3+3 
95f3 cd 57 94			call display_word_at 
95f6			 
95f6			 
95f6				; display bc 
95f6			 
95f6 11 89 96			ld de, .regstatebc 
95f9 3e 5a			ld a, display_row_3+10 
95fb cd c2 8a			call str_at_display 
95fe			 
95fe e1				pop hl 
95ff			;	ld h,b 
95ff			;	ld l, c 
95ff 3e 5d			ld a, display_row_3+13 
9601 cd 57 94			call display_word_at 
9604			 
9604			 
9604				; display dsp 
9604			 
9604 11 91 96			ld de, .regstatedsp 
9607 3e 78			ld a, display_row_4 
9609 cd c2 8a			call str_at_display 
960c			 
960c				 
960c 2a ee e9			ld hl,(cli_data_sp) 
960f 3e 7c			ld a, display_row_4+4 
9611 cd 57 94			call display_word_at 
9614			 
9614				; display rsp 
9614			 
9614 11 96 96			ld de, .regstatersp 
9617 3e 82			ld a, display_row_4+10 
9619 cd c2 8a			call str_at_display 
961c			 
961c				 
961c 2a f2 e9			ld hl,(cli_ret_sp) 
961f 3e 86			ld a, display_row_4+14 
9621 cd 57 94			call display_word_at 
9624			 
9624 cd d2 8a			call update_display 
9627			 
9627			;	call delay1s 
9627			;	call delay1s 
9627			;	call delay1s 
9627			 
9627			 
9627			;	call next_page_prompt 
9627			 
9627				; restore  
9627			 
9627 f1				pop af 
9628 e1				pop hl 
9629 c1				pop bc 
962a d1				pop de 
962b c9				ret 
962c			 
962c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9640 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9655 .. 00		.ptrstate:	db "Ptr State",0 
965f .. 00		.ptrcliptr:     db "cli_ptr",0 
9667 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9671 .. 00		.regstate:	db "Reg State (1/0)",0 
9681 .. 00		.regstatehl:	db "HL:",0 
9685 .. 00		.regstatede:	db "DE:",0 
9689 .. 00		.regstatebc:	db "BC:",0 
968d .. 00		.regstatea:	db "A :",0 
9691 .. 00		.regstatedsp:	db "DSP:",0 
9696 .. 00		.regstatersp:	db "RSP:",0 
969b			 
969b			display_dump_at_hl: 
969b e5				push hl 
969c d5				push de 
969d c5				push bc 
969e f5				push af 
969f			 
969f 22 e4 e5			ld (os_cur_ptr),hl	 
96a2 cd af 8a			call clear_display 
96a5 cd bc 99			call dumpcont 
96a8			;	call delay1s 
96a8			;	call next_page_prompt 
96a8			 
96a8			 
96a8 f1				pop af 
96a9 c1				pop bc 
96aa d1				pop de 
96ab e1				pop hl 
96ac c9				ret 
96ad			 
96ad			;if ENABLE_BASIC 
96ad			;	include "nascombasic.asm" 
96ad			;	basic: 
96ad			;	include "forth/FORTH.ASM" 
96ad			;endif 
96ad			 
96ad			; eof 
96ad			 
96ad			 
# End of file firmware_diags.asm
96ad			  
96ad			include "firmware_prompts.asm"  
96ad			; Prompts  
96ad			 
96ad			; boot messages 
96ad			 
96ad .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c2 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d2			 
96d2			 
96d2			; config menus 
96d2			 
96d2			;prom_c3: db "Add Dictionary To File",0 
96d2			 
96d2			if STARTUP_V1 
96d2 .. 00		prom_c2: db "Select Autoload File",0 
96e7 .. 00		prom_c2a: db "Disable Autoload File", 0 
96fd			endif 
96fd			 
96fd			if STARTUP_V2 
96fd			prom_c2: db "Enable Autoload Files",0 
96fd			prom_c2a: db "Disable Autoload Files", 0 
96fd			 
96fd			crs_s1: db "*ls-word", 0 
96fd			crs_s2: db "*ed-word", 0 
96fd			crs_s3: db "*Demo-Programs", 0 
96fd			crs_s4: db "*Utils", 0 
96fd			crs_s5: db "*SPI-Addons", 0 
96fd			crs_s6: db "*Key-constants", 0 
96fd			crs_sound: db "*Sound-Util", 0 
96fd			 
96fd			 
96fd			 
96fd			endif 
96fd			;prom_c2b: db "Select Storage Bank",0 
96fd .. 00		prom_c4: db "Settings",0 
9706 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9721 .. 00		prom_m4b:   db "Monitor",0 
9729 .. 00		prom_c1: db "Hardware Diags",0 
9738			 
9738			 
9738			if STARTUP_V2 
9738			prom_c9: db "Create Startup Files",0 
9738			endif 
9738			 
9738 .. 00		prom_notav:    db "Feature not available",0 
974e .. 00		prom_empty:    db "",0 
974f			 
974f			; eof 
974f			 
# End of file firmware_prompts.asm
974f			  
974f			  
974f			; eof  
974f			  
# End of file firmware.asm
974f			 
974f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
974f			;if BASE_KEV  
974f			;baseram: equ 08000h 
974f			;endif 
974f			 
974f			;if BASE_SC114 
974f			;baseram:     equ    endofcode 
974f			;endif 
974f			 
974f			 
974f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
974f			 
974f			; start system 
974f			 
974f			coldstart: 
974f				; set sp 
974f				; di/ei 
974f			 
974f f3				di 
9750 31 00 f0			ld sp, tos 
9753 cd 63 e3			call init_nmi 
9756			;	ei 
9756			 
9756				; init spinner 
9756 3e 00			ld a,0 
9758 32 c6 eb			ld (display_active), a 
975b			 
975b				; disable breakpoint by default 
975b			 
975b				;ld a,'*' 
975b			;	ld a,' ' 
975b			;	ld (os_view_disable),a 
975b			 
975b				; set break point vector as new break point on or off 
975b cd de 94			call bp_off 
975e			 
975e				; init hardware 
975e			 
975e				; init keyboard and screen hardware 
975e			 
975e cd 1c 80			call hardware_init 
9761			 
9761			 
9761 cd f2 89			call delay1s 
9764 3e 58			ld a, display_row_3+8 
9766 11 03 80			ld de, buildtime 
9769 cd c2 8a			call str_at_display 
976c cd d2 8a			call update_display 
976f			 
976f cd f2 89			call delay1s 
9772 cd f2 89			call delay1s 
9775 cd f2 89			call delay1s 
9778			 
9778				; detect if any keys are held down to enable breakpoints at start up 
9778			 
9778 cd 1f e4			call cin  
977b fe 00			cp 0 
977d 28 03			jr z, .nokeys 
977f			 
977f				;call hardware_diags 
977f cd 3c 93			call config 
9782			 
9782			;	ld de, .bpen 
9782			;	ld a, display_row_4 
9782			;	call str_at_display 
9782			;	call update_display 
9782			; 
9782			;	ld a,0 
9782			;	ld (os_view_disable),a 
9782			; 
9782			;.bpwait: 
9782			;	call cin 
9782			;	cp 0 
9782			;	jr z, .bpwait 
9782			;	jr .nokeys 
9782			; 
9782			; 
9782			;.bpen:  db "Break points enabled!",0 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			.nokeys: 
9782			 
9782			 
9782				 
9782			 
9782			;jp  testkey 
9782			 
9782			;call storage_get_block_0 
9782			; 
9782			;ld hl, 0 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782				 
9782			;ld hl, 10 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			;stop:	nop 
9782			;	jp stop 
9782			 
9782			 
9782			 
9782			main: 
9782 cd af 8a			call clear_display 
9785 cd d2 8a			call update_display 
9788			 
9788			 
9788			 
9788			;	call testlcd 
9788			 
9788			 
9788			 
9788 cd b9 9e			call forth_init 
978b			 
978b			 
978b			warmstart: 
978b cd 8f 9e			call forth_warmstart 
978e			 
978e				; run startup word load 
978e			        ; TODO prevent this running at warmstart after crash  
978e			 
978e				if STARTUP_ENABLE 
978e			 
978e					if STARTUP_V1 
978e			 
978e						if STORAGE_SE 
978e							call forth_autoload 
978e						endif 
978e cd b3 e2					call forth_startup 
9791					endif 
9791			 
9791					if STARTUP_V2 
9791			 
9791						if STORAGE_SE 
9791							call forth_autoload 
9791						else 
9791							call forth_startup 
9791						endif 
9791			 
9791			 
9791					endif 
9791			 
9791				endif 
9791			 
9791				; show free memory after boot 
9791 11 1d 98			ld de, freeram 
9794 3e 00			ld a, display_row_1 
9796 cd c2 8a			call str_at_display 
9799			 
9799				; get current heap start after loading any uwords 
9799			 
9799				;ld de, (os_last_new_uword) 
9799				;ex de, hl 
9799			 
9799			; Or use heap_size word???? 
9799				;ld hl, heap_end 
9799				;ld hl, heap_size 
9799				;ld de, topusermem 
9799				;ld de, heap_start 
9799 ed 5b 38 e4			ld de, (free_list )      
979d 21 9c e2				ld hl, heap_end 
97a0 ed 52			sbc hl, de 
97a2				;push hl 
97a2				;ld a,h	         	 
97a2				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97a2				;call hexout 
97a2			   	;pop hl 
97a2			; 
97a2			;	ld a,l 
97a2			;	ld hl, os_word_scratch+2 
97a2			;	call hexout 
97a2			;	ld hl, os_word_scratch+4 
97a2			;	ld a, 0 
97a2			;	ld (hl),a 
97a2 eb				ex de, hl 
97a3 21 c6 e5			ld hl, os_word_scratch 
97a6 cd e9 90			call uitoa_16 
97a9			 
97a9			 
97a9 11 c6 e5			ld de, os_word_scratch 
97ac 3e 0d			ld a, display_row_1 + 13 
97ae cd c2 8a			call str_at_display 
97b1 cd d2 8a			call update_display 
97b4			 
97b4			 
97b4				;call demo 
97b4			 
97b4			 
97b4				; init scratch input area for cli commands 
97b4			 
97b4 21 e8 e5			ld hl, os_cli_cmd 
97b7 3e 00			ld a,0 
97b9 77				ld (hl),a 
97ba 23				inc hl 
97bb 77				ld (hl),a 
97bc			 
97bc 3e 00			ld a,0 
97be 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97c1			 
97c1 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c4 32 e5 e5			ld (os_cur_ptr+1),a	 
97c7			 
97c7 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97ca 32 c7 e5			ld (os_word_scratch+1),a	 
97cd				 
97cd			 
97cd				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cd 21 e8 e5			ld hl, os_cli_cmd 
97d0			 
97d0 3e 00			ld a, 0		 ; init cli input 
97d2 77				ld (hl), a 
97d3 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d5			cli: 
97d5				; show cli prompt 
97d5				;push af 
97d5				;ld a, 0 
97d5				;ld de, prompt 
97d5				;call str_at_display 
97d5			 
97d5				;call update_display 
97d5				;pop af 
97d5				;inc a 
97d5				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d5 0e 00			ld c, 0 
97d7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d9 1e 28			ld e, 40 
97db			 
97db 21 e8 e5			ld hl, os_cli_cmd 
97de			 
97de				STACKFRAME OFF $fefe $9f9f 
97de				if DEBUG_STACK_IMB 
97de					if OFF 
97de						exx 
97de						ld de, $fefe 
97de						ld a, d 
97de						ld hl, curframe 
97de						call hexout 
97de						ld a, e 
97de						ld hl, curframe+2 
97de						call hexout 
97de						ld hl, $fefe 
97de						push hl 
97de						ld hl, $9f9f 
97de						push hl 
97de						exx 
97de					endif 
97de				endif 
97de			endm 
# End of macro STACKFRAME
97de			 
97de cd 09 8d			call input_str 
97e1			 
97e1				STACKFRAMECHK OFF $fefe $9f9f 
97e1				if DEBUG_STACK_IMB 
97e1					if OFF 
97e1						exx 
97e1						ld hl, $9f9f 
97e1						pop de   ; $9f9f 
97e1						call cmp16 
97e1						jr nz, .spnosame 
97e1						ld hl, $fefe 
97e1						pop de   ; $fefe 
97e1						call cmp16 
97e1						jr z, .spfrsame 
97e1						.spnosame: call showsperror 
97e1						.spfrsame: nop 
97e1						exx 
97e1					endif 
97e1				endif 
97e1			endm 
# End of macro STACKFRAMECHK
97e1			 
97e1				; copy input to last command 
97e1			 
97e1 21 e8 e5			ld hl, os_cli_cmd 
97e4 11 e7 e6			ld de, os_last_cmd 
97e7 01 ff 00			ld bc, 255 
97ea ed b0			ldir 
97ec			 
97ec				; wipe current buffer 
97ec			 
97ec			;	ld a, 0 
97ec			;	ld hl, os_cli_cmd 
97ec			;	ld de, os_cli_cmd+1 
97ec			;	ld bc, 254 
97ec			;	ldir 
97ec				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97ec			;	call strcpy 
97ec			;	ld a, 0 
97ec			;	ld (hl), a 
97ec			;	inc hl 
97ec			;	ld (hl), a 
97ec			;	inc hl 
97ec			;	ld (hl), a 
97ec			 
97ec				; switch frame buffer to program  
97ec			 
97ec 21 10 ed				ld hl, display_fb1 
97ef 22 cc eb				ld (display_fb_active), hl 
97f2			 
97f2			;	nop 
97f2				STACKFRAME ON $fbfe $8f9f 
97f2				if DEBUG_STACK_IMB 
97f2					if ON 
97f2						exx 
97f2						ld de, $fbfe 
97f2						ld a, d 
97f2						ld hl, curframe 
97f2						call hexout 
97f2						ld a, e 
97f2						ld hl, curframe+2 
97f2						call hexout 
97f2						ld hl, $fbfe 
97f2						push hl 
97f2						ld hl, $8f9f 
97f2						push hl 
97f2						exx 
97f2					endif 
97f2				endif 
97f2			endm 
# End of macro STACKFRAME
97f2				; first time into the parser so pass over the current scratch pad 
97f2 21 e8 e5			ld hl,os_cli_cmd 
97f5				; tokenise the entered statement(s) in HL 
97f5 cd 37 9f			call forthparse 
97f8			        ; exec forth statements in top of return stack 
97f8 cd 77 9f			call forthexec 
97fb				;call forthexec_cleanup 
97fb			;	call parsenext 
97fb			 
97fb				STACKFRAMECHK ON $fbfe $8f9f 
97fb				if DEBUG_STACK_IMB 
97fb					if ON 
97fb						exx 
97fb						ld hl, $8f9f 
97fb						pop de   ; $8f9f 
97fb						call cmp16 
97fb						jr nz, .spnosame 
97fb						ld hl, $fbfe 
97fb						pop de   ; $fbfe 
97fb						call cmp16 
97fb						jr z, .spfrsame 
97fb						.spnosame: call showsperror 
97fb						.spfrsame: nop 
97fb						exx 
97fb					endif 
97fb				endif 
97fb			endm 
# End of macro STACKFRAMECHK
97fb				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97fb			 
97fb 3e 78			ld a, display_row_4 
97fd 11 2e 98			ld de, endprog 
9800			 
9800 cd d2 8a			call update_display		 
9803			 
9803 cd b4 9a			call next_page_prompt 
9806			 
9806				; switch frame buffer to cli 
9806			 
9806 21 b1 ed				ld hl, display_fb0 
9809 22 cc eb				ld (display_fb_active), hl 
980c			 
980c			 
980c cd af 8a		        call clear_display 
980f cd d2 8a			call update_display		 
9812			 
9812 21 e8 e5			ld hl, os_cli_cmd 
9815			 
9815 3e 00			ld a, 0		 ; init cli input 
9817 77				ld (hl), a 
9818			 
9818				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9818			 
9818				; now on last line 
9818			 
9818				; TODO scroll screen up 
9818			 
9818				; TODO instead just clear screen and place at top of screen 
9818			 
9818			;	ld a, 0 
9818			;	ld (f_cursor_ptr),a 
9818			 
9818				;call clear_display 
9818				;call update_display 
9818			 
9818				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9818 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
981a c3 d5 97			jp cli 
981d			 
981d .. 00		freeram: db "Free bytes: ",0 
982a ..			asc: db "1A2F" 
982e .. 00		endprog: db "End prog...",0 
983a			 
983a			testenter2:   
983a 21 f3 e2			ld hl,scratch+50 
983d 22 e4 e5			ld (os_cur_ptr),hl 
9840 c3 d5 97			jp cli 
9843			 
9843			testenter:  
9843			 
9843 21 2a 98			ld hl,asc 
9846			;	ld a,(hl) 
9846			;	call nibble2val 
9846 cd 33 90			call get_byte 
9849			 
9849			 
9849			;	ld a,(hl) 
9849			;	call atohex 
9849			 
9849			;	call fourehexhl 
9849 32 f3 e2			ld (scratch+50),a 
984c			 
984c			 
984c			 
984c 21 2c 98			ld hl,asc+2 
984f			;	ld a, (hl) 
984f			;	call nibble2val 
984f cd 33 90			call get_byte 
9852			 
9852			;	call fourehexhl 
9852 32 f5 e2			ld (scratch+52),a 
9855				 
9855 21 f3 e2			ld hl,scratch+50 
9858 22 e4 e5			ld (os_cur_ptr),hl 
985b c3 d5 97			jp cli 
985e			 
985e			enter:	 
985e 3a c5 e2			ld a,(scratch+4) 
9861 fe 00			cp 0 
9863 28 0c			jr z, .entercont 
9865				; no, not a null term line so has an address to work out.... 
9865			 
9865 21 c3 e2			ld hl,scratch+2 
9868 cd 93 90			call get_word_hl 
986b			 
986b 22 e4 e5			ld (os_cur_ptr),hl	 
986e c3 d5 97			jp cli 
9871			 
9871			 
9871			.entercont:  
9871			 
9871 21 c3 e2			ld hl, scratch+2 
9874 cd 33 90			call get_byte 
9877			 
9877 2a e4 e5		   	ld hl,(os_cur_ptr) 
987a 77					ld (hl),a 
987b 23					inc hl 
987c 22 e4 e5				ld (os_cur_ptr),hl 
987f				 
987f			; get byte  
987f			 
987f			 
987f c3 d5 97			jp cli 
9882			 
9882			 
9882			; basic monitor support 
9882			 
9882			monitor: 
9882				;  
9882 cd af 8a			call clear_display 
9885 3e 00			ld a, 0 
9887 11 d6 98			ld de, .monprompt 
988a cd c2 8a			call str_at_display 
988d cd d2 8a			call update_display 
9890			 
9890				; get a monitor command 
9890			 
9890 0e 00			ld c, 0     ; entry at top left 
9892 16 64			ld d, 100   ; max buffer size 
9894 1e 0f			ld e, 15    ; input scroll area 
9896 3e 00			ld a, 0     ; init string 
9898 21 bf e4			ld hl, os_input 
989b 77				ld (hl), a 
989c 23				inc hl 
989d 77				ld (hl), a 
989e 21 bf e4			ld hl, os_input 
98a1 3e 01			ld a, 1     ; init string 
98a3 cd 09 8d			call input_str 
98a6			 
98a6 cd af 8a		        call clear_display 
98a9 cd d2 8a			call update_display		 
98ac			 
98ac 3a bf e4			ld a, (os_input) 
98af cd 31 91			call toUpper 
98b2 fe 48		        cp 'H' 
98b4 ca 3b 99		        jp z, .monhelp 
98b7 fe 44			cp 'D'		; dump 
98b9 ca 6e 99			jp z, .mondump	 
98bc fe 43			cp 'C'		; dump 
98be ca 88 99			jp z, .moncdump	 
98c1 fe 4d			cp 'M'		; dump 
98c3 ca d8 98			jp z, .moneditstart 
98c6 fe 55			cp 'U'		; dump 
98c8 ca e4 98			jp z, .monedit	 
98cb fe 47			cp 'G'		; dump 
98cd ca 64 99			jp z, .monjump 
98d0 fe 51			cp 'Q'		; dump 
98d2 c8				ret z	 
98d3			 
98d3			 
98d3				; TODO "S" to access symbol by name and not need the address 
98d3				; TODO "F" to find a string in memory 
98d3			 
98d3 c3 82 98			jp monitor 
98d6			 
98d6 .. 00		.monprompt: db ">", 0 
98d8			 
98d8			.moneditstart: 
98d8				; get starting address 
98d8			 
98d8 21 c1 e4			ld hl,os_input+2 
98db cd 93 90			call get_word_hl 
98de			 
98de 22 e4 e5			ld (os_cur_ptr),hl	 
98e1			 
98e1 c3 82 98			jp monitor 
98e4			 
98e4			.monedit: 
98e4				; get byte to load 
98e4			 
98e4 21 c1 e4			ld hl,os_input+2 
98e7 cd 33 90			call get_byte 
98ea			 
98ea				; get address to update 
98ea 2a e4 e5			ld hl, (os_cur_ptr) 
98ed			 
98ed				; update byte 
98ed			 
98ed 77				ld (hl), a 
98ee			 
98ee				; move to next address and save it 
98ee			 
98ee 23				inc hl 
98ef 22 e4 e5			ld (os_cur_ptr),hl	 
98f2			 
98f2 c3 82 98			jp monitor 
98f5			 
98f5			 
98f5 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9909 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9925 .. 00		.monhelptext3:  db "G-Call address",0 
9934 .. 00		.monhelptext4:  db "Q-Quit",0 
993b			        
993b			.monhelp: 
993b 3e 00			ld a, display_row_1 
993d 11 f5 98		        ld de, .monhelptext1 
9940			 
9940 cd c2 8a			call str_at_display 
9943 3e 28			ld a, display_row_2 
9945 11 09 99		        ld de, .monhelptext2 
9948					 
9948 cd c2 8a			call str_at_display 
994b 3e 50			ld a, display_row_3 
994d 11 25 99		        ld de, .monhelptext3 
9950					 
9950 cd c2 8a			call str_at_display 
9953 3e 78			ld a, display_row_4 
9955 11 34 99		        ld de, .monhelptext4 
9958 cd c2 8a			call str_at_display 
995b			 
995b cd d2 8a			call update_display		 
995e			 
995e cd b4 9a			call next_page_prompt 
9961 c3 82 98			jp monitor 
9964			 
9964			.monjump:    
9964 21 c1 e4			ld hl,os_input+2 
9967 cd 93 90			call get_word_hl 
996a			 
996a e9				jp (hl) 
996b c3 82 98			jp monitor 
996e			 
996e			.mondump:    
996e 21 c1 e4			ld hl,os_input+2 
9971 cd 93 90			call get_word_hl 
9974			 
9974 22 e4 e5			ld (os_cur_ptr),hl	 
9977 cd bc 99			call dumpcont 
997a 3e 78			ld a, display_row_4 
997c 11 2e 98			ld de, endprog 
997f			 
997f cd d2 8a			call update_display		 
9982			 
9982 cd b4 9a			call next_page_prompt 
9985 c3 82 98			jp monitor 
9988			.moncdump: 
9988 cd bc 99			call dumpcont 
998b 3e 78			ld a, display_row_4 
998d 11 2e 98			ld de, endprog 
9990			 
9990 cd d2 8a			call update_display		 
9993			 
9993 cd b4 9a			call next_page_prompt 
9996 c3 82 98			jp monitor 
9999			 
9999			 
9999			; TODO symbol access  
9999			 
9999			.symbols:     ;; A list of symbols that can be called up  
9999 b1 ed			dw display_fb0 
999b .. 00			db "fb0",0  
999f 7a ea		     	dw store_page 
99a1 .. 00			db "store_page",0 
99ac			 
99ac			 
99ac			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99ac			 
99ac 3a c2 e2			ld a,(scratch+1) 
99af fe 00			cp 0 
99b1 28 09			jr z, dumpcont 
99b3			 
99b3				; no, not a null term line so has an address to work out.... 
99b3			 
99b3 21 c3 e2			ld hl,scratch+2 
99b6 cd 93 90			call get_word_hl 
99b9			 
99b9 22 e4 e5			ld (os_cur_ptr),hl	 
99bc			 
99bc			 
99bc			 
99bc			dumpcont: 
99bc			 
99bc				; dump bytes at ptr 
99bc			 
99bc			 
99bc 3e 00			ld a, display_row_1 
99be 2a cc eb			ld hl, (display_fb_active) 
99c1 cd dc 8c			call addatohl 
99c4 cd ec 99			call .dumpbyterow 
99c7			 
99c7 3e 28			ld a, display_row_2 
99c9 2a cc eb			ld hl, (display_fb_active) 
99cc cd dc 8c			call addatohl 
99cf cd ec 99			call .dumpbyterow 
99d2			 
99d2			 
99d2 3e 50			ld a, display_row_3 
99d4 2a cc eb			ld hl, (display_fb_active) 
99d7 cd dc 8c			call addatohl 
99da cd ec 99			call .dumpbyterow 
99dd			 
99dd 3e 78			ld a, display_row_4 
99df 2a cc eb			ld hl, (display_fb_active) 
99e2 cd dc 8c			call addatohl 
99e5 cd ec 99			call .dumpbyterow 
99e8			 
99e8 cd d2 8a			call update_display 
99eb			;		jp cli 
99eb c9				ret 
99ec			 
99ec			.dumpbyterow: 
99ec			 
99ec				;push af 
99ec			 
99ec e5				push hl 
99ed			 
99ed				; calc where to poke the ascii 
99ed			if display_cols == 20 
99ed				ld a, 16 
99ed			else 
99ed 3e 1f			ld a, 31 
99ef			endif 
99ef			 
99ef cd dc 8c			call addatohl 
99f2 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
99f5			 
99f5			 
99f5			; display decoding address 
99f5 2a e4 e5		   	ld hl,(os_cur_ptr) 
99f8			 
99f8 7c				ld a,h 
99f9 e1				pop hl 
99fa e5				push hl 
99fb			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99fb cd dd 8f			call hexout 
99fe 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a01			 
9a01 7d				ld a,l 
9a02 e1				pop hl 
9a03 23				inc hl 
9a04 23				inc hl 
9a05 e5				push hl 
9a06			;	ld hl, os_word_scratch+2 
9a06 cd dd 8f			call hexout 
9a09 e1				pop hl 
9a0a 23				inc hl 
9a0b 23				inc hl 
9a0c				;ld hl, os_word_scratch+4 
9a0c 3e 3a			ld a, ':' 
9a0e 77				ld (hl),a 
9a0f 23				inc hl 
9a10				;ld a, 0 
9a10				;ld (hl),a 
9a10				;ld de, os_word_scratch 
9a10				;pop af 
9a10				;push af 
9a10			;		ld a, display_row_2 
9a10			;		call str_at_display 
9a10			;		call update_display 
9a10			 
9a10			 
9a10			;pop af 
9a10			;	add 5 
9a10			 
9a10			if display_cols == 20 
9a10				ld b, 4 
9a10			else 
9a10 06 08			ld b, 8 
9a12			endif	 
9a12			 
9a12			.dumpbyte: 
9a12 c5				push bc 
9a13 e5				push hl 
9a14			 
9a14			 
9a14 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a17 7e					ld a,(hl) 
9a18			 
9a18					; poke the ascii to display 
9a18 2a c6 e5				ld hl,(os_word_scratch) 
9a1b 77					ld (hl),a 
9a1c 23					inc hl 
9a1d 22 c6 e5				ld (os_word_scratch),hl 
9a20			 
9a20					 
9a20			 
9a20			 
9a20 e1					pop hl 
9a21 e5					push hl 
9a22			 
9a22 cd dd 8f				call hexout 
9a25			 
9a25					 
9a25 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a28 23				inc hl 
9a29 22 e4 e5		   	ld (os_cur_ptr),hl 
9a2c			 
9a2c e1					pop hl 
9a2d 23					inc hl 
9a2e 23					inc hl 
9a2f 23					inc hl 
9a30			 
9a30			 
9a30			 
9a30					;ld a,0 
9a30					;ld (os_word_scratch+2),a 
9a30					;pop af 
9a30					;push af 
9a30			 
9a30					;ld de, os_word_scratch 
9a30					;call str_at_display 
9a30			;		call update_display 
9a30			;		pop af 
9a30 c1					pop bc 
9a31 c6 03				add 3 
9a33 10 dd			djnz .dumpbyte 
9a35			 
9a35				 
9a35			 
9a35 c9				ret 
9a36			 
9a36			jump:	 
9a36			 
9a36 21 c3 e2			ld hl,scratch+2 
9a39 cd 93 90			call get_word_hl 
9a3c				;ld hl,(scratch+2) 
9a3c				;call fourehexhl 
9a3c			 
9a3c 22 e4 e5			ld (os_cur_ptr),hl	 
9a3f			 
9a3f e9				jp (hl) 
9a40			 
9a40			 
9a40			 
9a40			; TODO implement a basic monitor mode to start with 
9a40			 
9a40			 
9a40			 
9a40			 
9a40			 
9a40			 
9a40			 
9a40			 
9a40			 
9a40			; testing and demo code during development 
9a40			 
9a40			 
9a40 .. 00		str1: db "Enter some text...",0 
9a53 .. 00		clear: db "                    ",0 
9a68			 
9a68			demo: 
9a68			 
9a68			 
9a68			 
9a68			;	call update_display 
9a68			 
9a68				; init scratch input area for testing 
9a68 21 c1 e2			ld hl, scratch	 
9a6b 3e 00			ld a,0 
9a6d 77				ld (hl),a 
9a6e			 
9a6e			 
9a6e 3e 28		            LD   A, display_row_2 
9a70			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a70 11 40 9a		            LD   DE, str1 
9a73 cd c2 8a			call str_at_display 
9a76			 
9a76			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a76			cloop:	 
9a76 3e 50		            LD   A, display_row_3 
9a78			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a78 11 53 9a		            LD   DE, clear 
9a7b			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a7b cd c2 8a				call str_at_display 
9a7e 3e 78			ld a, display_row_4 
9a80 11 b0 9a			ld de, prompt 
9a83			 
9a83 cd c2 8a				call str_at_display 
9a86 cd d2 8a			call update_display 
9a89			 
9a89 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a8b 16 0a			ld d, 10 
9a8d 21 c1 e2			ld hl, scratch	 
9a90 cd 09 8d			call input_str 
9a93			 
9a93			;	call clear_display 
9a93			;'	call update_display 
9a93			 
9a93 3e 00		            LD   A, display_row_1 
9a95			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a95 11 53 9a		            LD   DE, clear 
9a98 cd c2 8a				call str_at_display 
9a9b			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a9b 3e 00		            LD   A, display_row_1 
9a9d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a9d 11 c1 e2		            LD   DE, scratch 
9aa0			;            CALL fLCD_Str       ;Display string pointed to by DE 
9aa0 cd c2 8a				call str_at_display 
9aa3 cd d2 8a			call update_display 
9aa6			 
9aa6 3e 00				ld a,0 
9aa8 21 c1 e2			ld hl, scratch 
9aab 77				ld (hl),a 
9aac			 
9aac 00				nop 
9aad c3 76 9a			jp cloop 
9ab0			 
9ab0			 
9ab0			 
9ab0			; OS Prompt 
9ab0			 
9ab0 .. 00		prompt: db ">",0 
9ab2 .. 00		endprg: db "?",0 
9ab4			 
9ab4			 
9ab4			; handy next page prompt 
9ab4			next_page_prompt: 
9ab4 e5				push hl 
9ab5 d5				push de 
9ab6 f5				push af 
9ab7 c5				push bc 
9ab8			 
9ab8 3e 9f			ld a,display_row_4 + display_cols - 1 
9aba 11 b2 9a		        ld de, endprg 
9abd cd c2 8a			call str_at_display 
9ac0 cd d2 8a			call update_display 
9ac3 cd 19 e4			call cin_wait 
9ac6 c1				pop bc 
9ac7 f1				pop af 
9ac8 d1				pop de 
9ac9 e1				pop hl 
9aca			 
9aca			 
9aca c9				ret 
9acb			 
9acb			 
9acb			; forth parser 
9acb			 
9acb			; My forth kernel 
9acb			include "forth_kernel.asm" 
9acb			; 
9acb			; kernel to the forth OS 
9acb			 
9acb			DS_TYPE_STR: equ 1     ; string type 
9acb			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9acb			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9acb			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9acb			 
9acb			FORTH_PARSEV1: equ 0 
9acb			FORTH_PARSEV2: equ 0 
9acb			FORTH_PARSEV3: equ 0 
9acb			FORTH_PARSEV4: equ 0 
9acb			FORTH_PARSEV5: equ 1 
9acb			 
9acb			;if FORTH_PARSEV5 
9acb			;	FORTH_END_BUFFER: equ 0 
9acb			;else 
9acb			FORTH_END_BUFFER: equ 127 
9acb			;endif 
9acb			 
9acb			FORTH_TRUE: equ 1 
9acb			FORTH_FALSE: equ 0 
9acb			 
9acb			if FORTH_PARSEV4 
9acb			include "forth_stackops.asm" 
9acb			endif 
9acb			 
9acb			if FORTH_PARSEV5 
9acb			include "forth_stackopsv5.asm" 
9acb			 
9acb			; Stack operations for v5 parser on wards 
9acb			; * DATA stack 
9acb			; * LOOP stack 
9acb			; * RETURN stack 
9acb			 
9acb			 
9acb			 
9acb			FORTH_CHK_DSP_UNDER: macro 
9acb				push hl 
9acb				push de 
9acb				ld hl,(cli_data_sp) 
9acb				ld de, cli_data_stack 
9acb				call cmp16 
9acb				jp c, fault_dsp_under 
9acb				pop de 
9acb				pop hl 
9acb				endm 
9acb			 
9acb			 
9acb			FORTH_CHK_RSP_UNDER: macro 
9acb				push hl 
9acb				push de 
9acb				ld hl,(cli_ret_sp) 
9acb				ld de, cli_ret_stack 
9acb				call cmp16 
9acb				jp c, fault_rsp_under 
9acb				pop de 
9acb				pop hl 
9acb				endm 
9acb			 
9acb			FORTH_CHK_LOOP_UNDER: macro 
9acb				push hl 
9acb				push de 
9acb				ld hl,(cli_loop_sp) 
9acb				ld de, cli_loop_stack 
9acb				call cmp16 
9acb				jp c, fault_loop_under 
9acb				pop de 
9acb				pop hl 
9acb				endm 
9acb			 
9acb			FORTH_ERR_TOS_NOTSTR: macro 
9acb				; TOSO might need more for checks when used 
9acb				push af 
9acb				ld a,(hl) 
9acb				cp DS_TYPE_STR 
9acb				jp nz, type_faultn   
9acb				pop af 
9acb				endm 
9acb			 
9acb			FORTH_ERR_TOS_NOTNUM: macro 
9acb				push af 
9acb				ld a,(hl) 
9acb				cp DS_TYPE_INUM 
9acb				jp nz, type_faultn   
9acb				pop af 
9acb				endm 
9acb			 
9acb			 
9acb			; increase data stack pointer and save hl to it 
9acb				 
9acb			FORTH_DSP_NEXT: macro 
9acb				call macro_forth_dsp_next 
9acb				endm 
9acb			 
9acb			 
9acb			macro_forth_dsp_next: 
9acb				if DEBUG_FORTH_STACK_GUARD 
9acb cd 94 e0				call check_stacks 
9ace				endif 
9ace e5				push hl 
9acf d5				push de 
9ad0 eb				ex de,hl 
9ad1 2a ee e9			ld hl,(cli_data_sp) 
9ad4 23				inc hl 
9ad5 23				inc hl 
9ad6			 
9ad6			; PARSEV5 
9ad6 23				inc hl 
9ad7 22 ee e9			ld (cli_data_sp),hl 
9ada 73				ld (hl), e 
9adb 23				inc hl 
9adc 72				ld (hl), d 
9add d1				pop de 
9ade e1				pop hl 
9adf				if DEBUG_FORTH_STACK_GUARD 
9adf cd 94 e0				call check_stacks 
9ae2				endif 
9ae2 c9				ret 
9ae3			 
9ae3			 
9ae3			; increase ret stack pointer and save hl to it 
9ae3				 
9ae3			FORTH_RSP_NEXT: macro 
9ae3				call macro_forth_rsp_next 
9ae3				endm 
9ae3			 
9ae3			macro_forth_rsp_next: 
9ae3				if DEBUG_FORTH_STACK_GUARD 
9ae3 cd 94 e0				call check_stacks 
9ae6				endif 
9ae6 e5				push hl 
9ae7 d5				push de 
9ae8 eb				ex de,hl 
9ae9 2a f2 e9			ld hl,(cli_ret_sp) 
9aec 23				inc hl 
9aed 23				inc hl 
9aee 22 f2 e9			ld (cli_ret_sp),hl 
9af1 73				ld (hl), e 
9af2 23				inc hl 
9af3 72				ld (hl), d 
9af4 d1				pop de 
9af5 e1				pop hl 
9af6				if DEBUG_FORTH_STACK_GUARD 
9af6 cd 94 e0				call check_stacks 
9af9				endif 
9af9 c9				ret 
9afa			 
9afa			; get current ret stack pointer and save to hl  
9afa				 
9afa			FORTH_RSP_TOS: macro 
9afa				call macro_forth_rsp_tos 
9afa				endm 
9afa			 
9afa			macro_forth_rsp_tos: 
9afa				;push de 
9afa 2a f2 e9			ld hl,(cli_ret_sp) 
9afd cd 35 9b			call loadhlptrtohl 
9b00				;ld e, (hl) 
9b00				;inc hl 
9b00				;ld d, (hl) 
9b00				;ex de, hl 
9b00					if DEBUG_FORTH_WORDS 
9b00			;			DMARK "RST" 
9b00						CALLMONITOR 
9b00 cd 6f ee			call debug_vector  
9b03				endm  
# End of macro CALLMONITOR
9b03					endif 
9b03				;pop de 
9b03 c9				ret 
9b04			 
9b04			; pop ret stack pointer 
9b04				 
9b04			FORTH_RSP_POP: macro 
9b04				call macro_forth_rsp_pop 
9b04				endm 
9b04			 
9b04			 
9b04			macro_forth_rsp_pop: 
9b04				if DEBUG_FORTH_STACK_GUARD 
9b04			;		DMARK "RPP" 
9b04 cd 94 e0				call check_stacks 
9b07					FORTH_CHK_RSP_UNDER 
9b07 e5				push hl 
9b08 d5				push de 
9b09 2a f2 e9			ld hl,(cli_ret_sp) 
9b0c 11 ac e9			ld de, cli_ret_stack 
9b0f cd fa 8c			call cmp16 
9b12 da a8 e1			jp c, fault_rsp_under 
9b15 d1				pop de 
9b16 e1				pop hl 
9b17				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b17				endif 
9b17 e5				push hl 
9b18 2a f2 e9			ld hl,(cli_ret_sp) 
9b1b			 
9b1b			 
9b1b				if FORTH_ENABLE_FREE 
9b1b			 
9b1b					; get pointer 
9b1b			 
9b1b					push de 
9b1b					push hl 
9b1b			 
9b1b					ld e, (hl) 
9b1b					inc hl 
9b1b					ld d, (hl) 
9b1b			 
9b1b					ex de, hl 
9b1b					call free 
9b1b			 
9b1b					pop hl 
9b1b					pop de 
9b1b			 
9b1b			 
9b1b				endif 
9b1b			 
9b1b			 
9b1b 2b				dec hl 
9b1c 2b				dec hl 
9b1d 22 f2 e9			ld (cli_ret_sp), hl 
9b20				; do stack underflow checks 
9b20 e1				pop hl 
9b21				if DEBUG_FORTH_STACK_GUARD 
9b21 cd 94 e0				call check_stacks 
9b24					FORTH_CHK_RSP_UNDER 
9b24 e5				push hl 
9b25 d5				push de 
9b26 2a f2 e9			ld hl,(cli_ret_sp) 
9b29 11 ac e9			ld de, cli_ret_stack 
9b2c cd fa 8c			call cmp16 
9b2f da a8 e1			jp c, fault_rsp_under 
9b32 d1				pop de 
9b33 e1				pop hl 
9b34				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b34				endif 
9b34 c9				ret 
9b35			 
9b35			 
9b35			 
9b35			; routine to load word pointed to by hl into hl 
9b35			 
9b35			loadhlptrtohl: 
9b35			 
9b35 d5				push de 
9b36 5e				ld e, (hl) 
9b37 23				inc hl 
9b38 56				ld d, (hl) 
9b39 eb				ex de, hl 
9b3a d1				pop de 
9b3b			 
9b3b c9				ret 
9b3c			 
9b3c			 
9b3c			 
9b3c			 
9b3c			 
9b3c			; push a number held in HL onto the data stack 
9b3c			; entry point for pushing a value when already in hl used in function above 
9b3c			 
9b3c			forth_push_numhl: 
9b3c			 
9b3c e5				push hl    ; save value to push 
9b3d			 
9b3d			if DEBUG_FORTH_PUSH 
9b3d				; see if disabled 
9b3d			 
9b3d			 
9b3d f5				push af 
9b3e 3a 6f ee			ld a,(debug_vector) 
9b41 fe c9			cp $c9   ; ret 
9b43			;	ld a, (os_view_disable) 
9b43			;	cp '*' 
9b43 28 34			jr z, .pskip2 
9b45 e5				push hl 
9b46 e5			push hl 
9b47 cd af 8a			call clear_display 
9b4a e1			pop hl 
9b4b 7c				ld a,h 
9b4c 21 c6 e5			ld hl, os_word_scratch 
9b4f cd dd 8f			call hexout 
9b52 e1				pop hl 
9b53 7d				ld a,l 
9b54 21 c8 e5			ld hl, os_word_scratch+2 
9b57 cd dd 8f			call hexout 
9b5a			 
9b5a 21 ca e5			ld hl, os_word_scratch+4 
9b5d 3e 00			ld a,0 
9b5f 77				ld (hl),a 
9b60 11 c6 e5			ld de,os_word_scratch 
9b63 3e 28				ld a, display_row_2 
9b65 cd c2 8a				call str_at_display 
9b68 11 d0 cb			ld de, .push_num 
9b6b 3e 00			ld a, display_row_1 
9b6d			 
9b6d cd c2 8a				call str_at_display 
9b70			 
9b70			 
9b70 cd d2 8a			call update_display 
9b73 cd f2 89			call delay1s 
9b76 cd f2 89			call delay1s 
9b79			.pskip2:  
9b79			 
9b79 f1				pop af 
9b7a			endif	 
9b7a			 
9b7a			 
9b7a				FORTH_DSP_NEXT 
9b7a cd cb 9a			call macro_forth_dsp_next 
9b7d				endm 
# End of macro FORTH_DSP_NEXT
9b7d			 
9b7d 2a ee e9			ld hl, (cli_data_sp) 
9b80			 
9b80				; save item type 
9b80 3e 02			ld a,  DS_TYPE_INUM 
9b82 77				ld (hl), a 
9b83 23				inc hl 
9b84			 
9b84				; get word off stack 
9b84 d1				pop de 
9b85 7b				ld a,e 
9b86 77				ld (hl), a 
9b87 23				inc hl 
9b88 7a				ld a,d 
9b89 77				ld (hl), a 
9b8a			 
9b8a			if DEBUG_FORTH_PUSH 
9b8a 2b				dec hl 
9b8b 2b				dec hl 
9b8c 2b				dec hl 
9b8d						DMARK "PH5" 
9b8d f5				push af  
9b8e 3a a2 9b			ld a, (.dmark)  
9b91 32 6b ee			ld (debug_mark),a  
9b94 3a a3 9b			ld a, (.dmark+1)  
9b97 32 6c ee			ld (debug_mark+1),a  
9b9a 3a a4 9b			ld a, (.dmark+2)  
9b9d 32 6d ee			ld (debug_mark+2),a  
9ba0 18 03			jr .pastdmark  
9ba2 ..			.dmark: db "PH5"  
9ba5 f1			.pastdmark: pop af  
9ba6			endm  
# End of macro DMARK
9ba6				CALLMONITOR 
9ba6 cd 6f ee			call debug_vector  
9ba9				endm  
# End of macro CALLMONITOR
9ba9			endif	 
9ba9			 
9ba9 c9				ret 
9baa			 
9baa			 
9baa			; Push a string to stack pointed to by hl 
9baa			 
9baa			forth_push_str: 
9baa			 
9baa			if DEBUG_FORTH_PUSH 
9baa						DMARK "PSQ" 
9baa f5				push af  
9bab 3a bf 9b			ld a, (.dmark)  
9bae 32 6b ee			ld (debug_mark),a  
9bb1 3a c0 9b			ld a, (.dmark+1)  
9bb4 32 6c ee			ld (debug_mark+1),a  
9bb7 3a c1 9b			ld a, (.dmark+2)  
9bba 32 6d ee			ld (debug_mark+2),a  
9bbd 18 03			jr .pastdmark  
9bbf ..			.dmark: db "PSQ"  
9bc2 f1			.pastdmark: pop af  
9bc3			endm  
# End of macro DMARK
9bc3				CALLMONITOR 
9bc3 cd 6f ee			call debug_vector  
9bc6				endm  
# End of macro CALLMONITOR
9bc6			endif	 
9bc6			    
9bc6 e5				push hl 
9bc7 e5				push hl 
9bc8			 
9bc8			;	ld a, 0   ; find end of string 
9bc8 cd 3a 91			call strlenz 
9bcb			if DEBUG_FORTH_PUSH 
9bcb						DMARK "PQ2" 
9bcb f5				push af  
9bcc 3a e0 9b			ld a, (.dmark)  
9bcf 32 6b ee			ld (debug_mark),a  
9bd2 3a e1 9b			ld a, (.dmark+1)  
9bd5 32 6c ee			ld (debug_mark+1),a  
9bd8 3a e2 9b			ld a, (.dmark+2)  
9bdb 32 6d ee			ld (debug_mark+2),a  
9bde 18 03			jr .pastdmark  
9be0 ..			.dmark: db "PQ2"  
9be3 f1			.pastdmark: pop af  
9be4			endm  
# End of macro DMARK
9be4				CALLMONITOR 
9be4 cd 6f ee			call debug_vector  
9be7				endm  
# End of macro CALLMONITOR
9be7			endif	 
9be7 eb				ex de, hl 
9be8 e1				pop hl   ; get ptr to start of string 
9be9			if DEBUG_FORTH_PUSH 
9be9						DMARK "PQ3" 
9be9 f5				push af  
9bea 3a fe 9b			ld a, (.dmark)  
9bed 32 6b ee			ld (debug_mark),a  
9bf0 3a ff 9b			ld a, (.dmark+1)  
9bf3 32 6c ee			ld (debug_mark+1),a  
9bf6 3a 00 9c			ld a, (.dmark+2)  
9bf9 32 6d ee			ld (debug_mark+2),a  
9bfc 18 03			jr .pastdmark  
9bfe ..			.dmark: db "PQ3"  
9c01 f1			.pastdmark: pop af  
9c02			endm  
# End of macro DMARK
9c02				CALLMONITOR 
9c02 cd 6f ee			call debug_vector  
9c05				endm  
# End of macro CALLMONITOR
9c05			endif	 
9c05 19				add hl,de 
9c06			if DEBUG_FORTH_PUSH 
9c06						DMARK "PQE" 
9c06 f5				push af  
9c07 3a 1b 9c			ld a, (.dmark)  
9c0a 32 6b ee			ld (debug_mark),a  
9c0d 3a 1c 9c			ld a, (.dmark+1)  
9c10 32 6c ee			ld (debug_mark+1),a  
9c13 3a 1d 9c			ld a, (.dmark+2)  
9c16 32 6d ee			ld (debug_mark+2),a  
9c19 18 03			jr .pastdmark  
9c1b ..			.dmark: db "PQE"  
9c1e f1			.pastdmark: pop af  
9c1f			endm  
# End of macro DMARK
9c1f				CALLMONITOR 
9c1f cd 6f ee			call debug_vector  
9c22				endm  
# End of macro CALLMONITOR
9c22			endif	 
9c22			 
9c22 2b				dec hl    ; see if there is an optional trailing double quote 
9c23 7e				ld a,(hl) 
9c24 fe 22			cp '"' 
9c26 20 03			jr nz, .strnoq 
9c28 3e 00			ld a, 0      ; get rid of double quote 
9c2a 77				ld (hl), a 
9c2b 23			.strnoq: inc hl 
9c2c			 
9c2c 3e 00			ld a, 0 
9c2e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c2f			 
9c2f 13				inc de ; add one for the type string 
9c30 13				inc de ; add one for null term??? 
9c31			 
9c31				; tos is get string pointer again 
9c31				; de contains space to allocate 
9c31				 
9c31 d5				push de 
9c32			 
9c32 eb				ex de, hl 
9c33			 
9c33				;push af 
9c33			 
9c33			if DEBUG_FORTH_PUSH 
9c33						DMARK "PHm" 
9c33 f5				push af  
9c34 3a 48 9c			ld a, (.dmark)  
9c37 32 6b ee			ld (debug_mark),a  
9c3a 3a 49 9c			ld a, (.dmark+1)  
9c3d 32 6c ee			ld (debug_mark+1),a  
9c40 3a 4a 9c			ld a, (.dmark+2)  
9c43 32 6d ee			ld (debug_mark+2),a  
9c46 18 03			jr .pastdmark  
9c48 ..			.dmark: db "PHm"  
9c4b f1			.pastdmark: pop af  
9c4c			endm  
# End of macro DMARK
9c4c				CALLMONITOR 
9c4c cd 6f ee			call debug_vector  
9c4f				endm  
# End of macro CALLMONITOR
9c4f			endif	 
9c4f cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c52				if DEBUG_FORTH_MALLOC_GUARD 
9c52 cc 28 cc				call z,malloc_error 
9c55				endif 
9c55			 
9c55				 
9c55 c1				pop bc    ; get length 
9c56 d1				pop de   ;  get string start    
9c57			 
9c57				; hl has destination from malloc 
9c57			 
9c57 eb				ex de, hl    ; prep for ldir 
9c58			 
9c58 d5				push de   ; save malloc area for DSP later 
9c59				;push hl   ; save malloc area for DSP later 
9c59			 
9c59			if DEBUG_FORTH_PUSH 
9c59						DMARK "PHc" 
9c59 f5				push af  
9c5a 3a 6e 9c			ld a, (.dmark)  
9c5d 32 6b ee			ld (debug_mark),a  
9c60 3a 6f 9c			ld a, (.dmark+1)  
9c63 32 6c ee			ld (debug_mark+1),a  
9c66 3a 70 9c			ld a, (.dmark+2)  
9c69 32 6d ee			ld (debug_mark+2),a  
9c6c 18 03			jr .pastdmark  
9c6e ..			.dmark: db "PHc"  
9c71 f1			.pastdmark: pop af  
9c72			endm  
# End of macro DMARK
9c72				CALLMONITOR 
9c72 cd 6f ee			call debug_vector  
9c75				endm  
# End of macro CALLMONITOR
9c75			endif	 
9c75			 
9c75			 
9c75 ed b0			ldir 
9c77			 
9c77			 
9c77				; push malloc to data stack     macro?????  
9c77			 
9c77				FORTH_DSP_NEXT 
9c77 cd cb 9a			call macro_forth_dsp_next 
9c7a				endm 
# End of macro FORTH_DSP_NEXT
9c7a			 
9c7a				; save value and type 
9c7a			 
9c7a 2a ee e9			ld hl, (cli_data_sp) 
9c7d			 
9c7d				; save item type 
9c7d 3e 01			ld a,  DS_TYPE_STR 
9c7f 77				ld (hl), a 
9c80 23				inc hl 
9c81			 
9c81				; get malloc word off stack 
9c81 d1				pop de 
9c82 73				ld (hl), e 
9c83 23				inc hl 
9c84 72				ld (hl), d 
9c85			 
9c85			 
9c85			 
9c85			if DEBUG_FORTH_PUSH 
9c85 2a ee e9			ld hl, (cli_data_sp) 
9c88						DMARK "PHS" 
9c88 f5				push af  
9c89 3a 9d 9c			ld a, (.dmark)  
9c8c 32 6b ee			ld (debug_mark),a  
9c8f 3a 9e 9c			ld a, (.dmark+1)  
9c92 32 6c ee			ld (debug_mark+1),a  
9c95 3a 9f 9c			ld a, (.dmark+2)  
9c98 32 6d ee			ld (debug_mark+2),a  
9c9b 18 03			jr .pastdmark  
9c9d ..			.dmark: db "PHS"  
9ca0 f1			.pastdmark: pop af  
9ca1			endm  
# End of macro DMARK
9ca1				CALLMONITOR 
9ca1 cd 6f ee			call debug_vector  
9ca4				endm  
# End of macro CALLMONITOR
9ca4			;	ex de,hl 
9ca4			endif	 
9ca4				; in case of spaces, skip the ptr past the copied string 
9ca4				;pop af 
9ca4				;ld (cli_origptr),hl 
9ca4			 
9ca4 c9				ret 
9ca5			 
9ca5			 
9ca5			 
9ca5			; TODO ascii push input onto stack given hl to start of input 
9ca5			 
9ca5			; identify type 
9ca5			; if starts with a " then a string 
9ca5			; otherwise it is a number 
9ca5			;  
9ca5			; if a string 
9ca5			;     scan for ending " to get length of string to malloc for + 1 
9ca5			;     malloc 
9ca5			;     put pointer to string on stack first byte flags as string 
9ca5			; 
9ca5			; else a number 
9ca5			;    look for number format identifier 
9ca5			;    $xx hex 
9ca5			;    %xxxxx bin 
9ca5			;    xxxxx decimal 
9ca5			;    convert number to 16bit word.  
9ca5			;    malloc word + 1 with flag to identiy as num 
9ca5			;    put pointer to number on stack 
9ca5			;   
9ca5			;  
9ca5			  
9ca5			forth_apush: 
9ca5				; kernel push 
9ca5			 
9ca5			if DEBUG_FORTH_PUSH 
9ca5						DMARK "PSH" 
9ca5 f5				push af  
9ca6 3a ba 9c			ld a, (.dmark)  
9ca9 32 6b ee			ld (debug_mark),a  
9cac 3a bb 9c			ld a, (.dmark+1)  
9caf 32 6c ee			ld (debug_mark+1),a  
9cb2 3a bc 9c			ld a, (.dmark+2)  
9cb5 32 6d ee			ld (debug_mark+2),a  
9cb8 18 03			jr .pastdmark  
9cba ..			.dmark: db "PSH"  
9cbd f1			.pastdmark: pop af  
9cbe			endm  
# End of macro DMARK
9cbe				CALLMONITOR 
9cbe cd 6f ee			call debug_vector  
9cc1				endm  
# End of macro CALLMONITOR
9cc1			endif	 
9cc1				; identify input type 
9cc1			 
9cc1 7e				ld a,(hl) 
9cc2 fe 22			cp '"' 
9cc4 28 0a			jr z, .fapstr 
9cc6 fe 24			cp '$' 
9cc8 ca f0 9c			jp z, .faphex 
9ccb fe 25			cp '%' 
9ccd ca d8 9c			jp z, .fapbin 
9cd0			;	cp 'b' 
9cd0			;	jp z, .fabin 
9cd0				; else decimal 
9cd0			 
9cd0				; TODO do decimal conversion 
9cd0				; decimal is stored as a 16bit word 
9cd0			 
9cd0				; by default everything is a string if type is not detected 
9cd0			.fapstr: ; 
9cd0 fe 22			cp '"' 
9cd2 20 01			jr nz, .strnoqu 
9cd4 23				inc hl 
9cd5			.strnoqu: 
9cd5 c3 aa 9b			jp forth_push_str 
9cd8			 
9cd8			 
9cd8			 
9cd8			.fapbin:    ; push a binary string.  
9cd8 11 00 00			ld de, 0   ; hold a 16bit value 
9cdb			 
9cdb 23			.fapbinshift:	inc hl  
9cdc 7e				ld a,(hl) 
9cdd fe 00			cp 0     ; done scanning  
9cdf 28 0b			jr z, .fapbdone  	; got it in HL so push  
9ce1			 
9ce1				; left shift de 
9ce1 eb				ex de, hl	 
9ce2 29				add hl, hl 
9ce3			 
9ce3				; is 1 
9ce3 fe 31			cp '1' 
9ce5 20 02			jr nz, .binzero 
9ce7 cb 4d			bit 1, l 
9ce9			.binzero: 
9ce9 eb				ex de, hl	 ; save current de 
9cea 18 ef			jr .fapbinshift 
9cec			 
9cec			.fapbdone: 
9cec eb				ex de, hl 
9ced c3 3c 9b			jp forth_push_numhl 
9cf0			 
9cf0			 
9cf0			.faphex:   ; hex is always stored as a 16bit word 
9cf0				; skip number prefix 
9cf0 23				inc hl 
9cf1				; turn ascii into number 
9cf1 cd 93 90			call get_word_hl	; ret 16bit word in hl 
9cf4			 
9cf4 c3 3c 9b			jp forth_push_numhl 
9cf7			 
9cf7 00				 nop 
9cf8			 
9cf8			.fabin:   ; TODO bin conversion 
9cf8			 
9cf8			 
9cf8 c9				ret 
9cf9			 
9cf9			 
9cf9			; get either a string ptr or a 16bit word from the data stack 
9cf9			 
9cf9			FORTH_DSP: macro 
9cf9				call macro_forth_dsp 
9cf9				endm 
9cf9			 
9cf9			macro_forth_dsp: 
9cf9				; data stack pointer points to current word on tos 
9cf9			 
9cf9 2a ee e9			ld hl,(cli_data_sp) 
9cfc			 
9cfc				if DEBUG_FORTH_PUSH 
9cfc						DMARK "DSP" 
9cfc f5				push af  
9cfd 3a 11 9d			ld a, (.dmark)  
9d00 32 6b ee			ld (debug_mark),a  
9d03 3a 12 9d			ld a, (.dmark+1)  
9d06 32 6c ee			ld (debug_mark+1),a  
9d09 3a 13 9d			ld a, (.dmark+2)  
9d0c 32 6d ee			ld (debug_mark+2),a  
9d0f 18 03			jr .pastdmark  
9d11 ..			.dmark: db "DSP"  
9d14 f1			.pastdmark: pop af  
9d15			endm  
# End of macro DMARK
9d15			 
9d15 cd 5b cc				call display_data_sp 
9d18				;call break_point_state 
9d18				;rst 030h 
9d18				CALLMONITOR 
9d18 cd 6f ee			call debug_vector  
9d1b				endm  
# End of macro CALLMONITOR
9d1b				endif 
9d1b			 
9d1b c9				ret 
9d1c			 
9d1c			; return hl to start of value on stack 
9d1c			 
9d1c			FORTH_DSP_VALUE: macro 
9d1c				call macro_forth_dsp_value 
9d1c				endm 
9d1c			 
9d1c			macro_forth_dsp_value: 
9d1c			 
9d1c				FORTH_DSP 
9d1c cd f9 9c			call macro_forth_dsp 
9d1f				endm 
# End of macro FORTH_DSP
9d1f			 
9d1f d5				push de 
9d20			 
9d20 23				inc hl ; skip type 
9d21			 
9d21 5e				ld e, (hl) 
9d22 23				inc hl 
9d23 56				ld d, (hl) 
9d24 eb				ex de,hl  
9d25			 
9d25 d1				pop de 
9d26			 
9d26 c9				ret 
9d27			 
9d27			; return hl to start of value to second item on stack 
9d27			 
9d27			FORTH_DSP_VALUEM1: macro 
9d27				call macro_forth_dsp_value_m1 
9d27				endm 
9d27			 
9d27			macro_forth_dsp_value_m1: 
9d27			 
9d27				FORTH_DSP 
9d27 cd f9 9c			call macro_forth_dsp 
9d2a				endm 
# End of macro FORTH_DSP
9d2a			 
9d2a 2b				dec hl 
9d2b 2b				dec hl 
9d2c			;	dec hl 
9d2c			 
9d2c d5				push de 
9d2d			 
9d2d 5e				ld e, (hl) 
9d2e 23				inc hl 
9d2f 56				ld d, (hl) 
9d30 eb				ex de,hl  
9d31			 
9d31 d1				pop de 
9d32			 
9d32 c9				ret 
9d33			 
9d33				 
9d33			 
9d33			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d33			 
9d33			FORTH_DSP_POP: macro 
9d33				call macro_forth_dsp_pop 
9d33				endm 
9d33			 
9d33			 
9d33			; get the tos data type 
9d33			 
9d33			FORTH_DSP_TYPE:   macro 
9d33			 
9d33				;FORTH_DSP_VALUE 
9d33				FORTH_DSP 
9d33				 
9d33				; hl points to value 
9d33				; check type 
9d33			 
9d33				ld a,(hl) 
9d33			 
9d33				endm 
9d33			 
9d33			; load the tos value into hl 
9d33			 
9d33			 
9d33			FORTH_DSP_VALUEHL:  macro 
9d33				call macro_dsp_valuehl 
9d33				endm 
9d33			 
9d33			 
9d33			 
9d33			macro_dsp_valuehl: 
9d33				FORTH_DSP_VALUE 
9d33 cd 1c 9d			call macro_forth_dsp_value 
9d36				endm 
# End of macro FORTH_DSP_VALUE
9d36			 
9d36				;FORTH_ERR_TOS_NOTNUM 
9d36			 
9d36				;inc hl   ; skip type id 
9d36			 
9d36			;	push de 
9d36			; 
9d36			;	ld e, (hl) 
9d36			;	inc hl 
9d36			;	ld d, (hl) 
9d36			;	ex de,hl  
9d36			 
9d36			;	pop de 
9d36			 
9d36				if DEBUG_FORTH_PUSH 
9d36						DMARK "DVL" 
9d36 f5				push af  
9d37 3a 4b 9d			ld a, (.dmark)  
9d3a 32 6b ee			ld (debug_mark),a  
9d3d 3a 4c 9d			ld a, (.dmark+1)  
9d40 32 6c ee			ld (debug_mark+1),a  
9d43 3a 4d 9d			ld a, (.dmark+2)  
9d46 32 6d ee			ld (debug_mark+2),a  
9d49 18 03			jr .pastdmark  
9d4b ..			.dmark: db "DVL"  
9d4e f1			.pastdmark: pop af  
9d4f			endm  
# End of macro DMARK
9d4f				CALLMONITOR 
9d4f cd 6f ee			call debug_vector  
9d52				endm  
# End of macro CALLMONITOR
9d52				endif 
9d52 c9				ret 
9d53			 
9d53			forth_apushstrhl:      
9d53				; push of string requires use of cli_origptr 
9d53				; bodge use 
9d53			 
9d53				; get current cli_origptr, save, update with temp pointer  
9d53 ed 5b 3e ea		ld de, (cli_origptr) 
9d57 22 3e ea			ld (cli_origptr), hl 
9d5a d5				push de 
9d5b cd a5 9c			call forth_apush 
9d5e d1				pop de 
9d5f ed 53 3e ea		ld (cli_origptr), de 
9d63 c9			        ret	 
9d64			 
9d64			 
9d64			; increase loop stack pointer and save hl to it 
9d64				 
9d64			FORTH_LOOP_NEXT: macro 
9d64				call macro_forth_loop_next 
9d64				;nop 
9d64				endm 
9d64			 
9d64			macro_forth_loop_next: 
9d64				if DEBUG_FORTH_STACK_GUARD 
9d64 cd 94 e0				call check_stacks 
9d67				endif 
9d67 e5				push hl 
9d68 d5				push de 
9d69 eb				ex de,hl 
9d6a 2a f0 e9			ld hl,(cli_loop_sp) 
9d6d 23				inc hl 
9d6e 23				inc hl 
9d6f					if DEBUG_FORTH_WORDS 
9d6f						DMARK "LNX" 
9d6f f5				push af  
9d70 3a 84 9d			ld a, (.dmark)  
9d73 32 6b ee			ld (debug_mark),a  
9d76 3a 85 9d			ld a, (.dmark+1)  
9d79 32 6c ee			ld (debug_mark+1),a  
9d7c 3a 86 9d			ld a, (.dmark+2)  
9d7f 32 6d ee			ld (debug_mark+2),a  
9d82 18 03			jr .pastdmark  
9d84 ..			.dmark: db "LNX"  
9d87 f1			.pastdmark: pop af  
9d88			endm  
# End of macro DMARK
9d88						CALLMONITOR 
9d88 cd 6f ee			call debug_vector  
9d8b				endm  
# End of macro CALLMONITOR
9d8b					endif 
9d8b 22 f0 e9			ld (cli_loop_sp),hl 
9d8e 73				ld (hl), e 
9d8f 23				inc hl 
9d90 72				ld (hl), d 
9d91 d1				pop de    ; been reversed so save a swap on restore 
9d92 e1				pop hl 
9d93				if DEBUG_FORTH_STACK_GUARD 
9d93 cd 94 e0				call check_stacks 
9d96				endif 
9d96 c9				ret 
9d97			 
9d97			; get current ret stack pointer and save to hl  
9d97				 
9d97			FORTH_LOOP_TOS: macro 
9d97				call macro_forth_loop_tos 
9d97				endm 
9d97			 
9d97			macro_forth_loop_tos: 
9d97 d5				push de 
9d98 2a f0 e9			ld hl,(cli_loop_sp) 
9d9b 5e				ld e, (hl) 
9d9c 23				inc hl 
9d9d 56				ld d, (hl) 
9d9e eb				ex de, hl 
9d9f d1				pop de 
9da0 c9				ret 
9da1			 
9da1			; pop loop stack pointer 
9da1				 
9da1			FORTH_LOOP_POP: macro 
9da1				call macro_forth_loop_pop 
9da1				endm 
9da1			 
9da1			 
9da1			macro_forth_loop_pop: 
9da1				if DEBUG_FORTH_STACK_GUARD 
9da1					DMARK "LPP" 
9da1 f5				push af  
9da2 3a b6 9d			ld a, (.dmark)  
9da5 32 6b ee			ld (debug_mark),a  
9da8 3a b7 9d			ld a, (.dmark+1)  
9dab 32 6c ee			ld (debug_mark+1),a  
9dae 3a b8 9d			ld a, (.dmark+2)  
9db1 32 6d ee			ld (debug_mark+2),a  
9db4 18 03			jr .pastdmark  
9db6 ..			.dmark: db "LPP"  
9db9 f1			.pastdmark: pop af  
9dba			endm  
# End of macro DMARK
9dba cd 94 e0				call check_stacks 
9dbd					FORTH_CHK_LOOP_UNDER 
9dbd e5				push hl 
9dbe d5				push de 
9dbf 2a f0 e9			ld hl,(cli_loop_sp) 
9dc2 11 2a e9			ld de, cli_loop_stack 
9dc5 cd fa 8c			call cmp16 
9dc8 da ae e1			jp c, fault_loop_under 
9dcb d1				pop de 
9dcc e1				pop hl 
9dcd				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dcd				endif 
9dcd e5				push hl 
9dce 2a f0 e9			ld hl,(cli_loop_sp) 
9dd1 2b				dec hl 
9dd2 2b				dec hl 
9dd3 22 f0 e9			ld (cli_loop_sp), hl 
9dd6				; TODO do stack underflow checks 
9dd6 e1				pop hl 
9dd7				if DEBUG_FORTH_STACK_GUARD 
9dd7 cd 94 e0				call check_stacks 
9dda					FORTH_CHK_LOOP_UNDER 
9dda e5				push hl 
9ddb d5				push de 
9ddc 2a f0 e9			ld hl,(cli_loop_sp) 
9ddf 11 2a e9			ld de, cli_loop_stack 
9de2 cd fa 8c			call cmp16 
9de5 da ae e1			jp c, fault_loop_under 
9de8 d1				pop de 
9de9 e1				pop hl 
9dea				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dea				endif 
9dea c9				ret 
9deb			 
9deb			macro_forth_dsp_pop: 
9deb			 
9deb e5				push hl 
9dec			 
9dec				; release malloc data 
9dec			 
9dec				if DEBUG_FORTH_STACK_GUARD 
9dec cd 94 e0				call check_stacks 
9def					FORTH_CHK_DSP_UNDER 
9def e5				push hl 
9df0 d5				push de 
9df1 2a ee e9			ld hl,(cli_data_sp) 
9df4 11 28 e8			ld de, cli_data_stack 
9df7 cd fa 8c			call cmp16 
9dfa da a2 e1			jp c, fault_dsp_under 
9dfd d1				pop de 
9dfe e1				pop hl 
9dff				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dff				endif 
9dff				;ld hl,(cli_data_sp) 
9dff			if DEBUG_FORTH_DOT 
9dff				DMARK "DPP" 
9dff f5				push af  
9e00 3a 14 9e			ld a, (.dmark)  
9e03 32 6b ee			ld (debug_mark),a  
9e06 3a 15 9e			ld a, (.dmark+1)  
9e09 32 6c ee			ld (debug_mark+1),a  
9e0c 3a 16 9e			ld a, (.dmark+2)  
9e0f 32 6d ee			ld (debug_mark+2),a  
9e12 18 03			jr .pastdmark  
9e14 ..			.dmark: db "DPP"  
9e17 f1			.pastdmark: pop af  
9e18			endm  
# End of macro DMARK
9e18				CALLMONITOR 
9e18 cd 6f ee			call debug_vector  
9e1b				endm  
# End of macro CALLMONITOR
9e1b			endif	 
9e1b			 
9e1b			 
9e1b			if FORTH_ENABLE_DSPPOPFREE 
9e1b			 
9e1b				FORTH_DSP 
9e1b cd f9 9c			call macro_forth_dsp 
9e1e				endm 
# End of macro FORTH_DSP
9e1e			 
9e1e 7e				ld a, (hl) 
9e1f fe 01			cp DS_TYPE_STR 
9e21 20 23			jr nz, .skippopfree 
9e23			 
9e23				FORTH_DSP_VALUEHL 
9e23 cd 33 9d			call macro_dsp_valuehl 
9e26				endm 
# End of macro FORTH_DSP_VALUEHL
9e26 00				nop 
9e27			if DEBUG_FORTH_DOT 
9e27				DMARK "DPf" 
9e27 f5				push af  
9e28 3a 3c 9e			ld a, (.dmark)  
9e2b 32 6b ee			ld (debug_mark),a  
9e2e 3a 3d 9e			ld a, (.dmark+1)  
9e31 32 6c ee			ld (debug_mark+1),a  
9e34 3a 3e 9e			ld a, (.dmark+2)  
9e37 32 6d ee			ld (debug_mark+2),a  
9e3a 18 03			jr .pastdmark  
9e3c ..			.dmark: db "DPf"  
9e3f f1			.pastdmark: pop af  
9e40			endm  
# End of macro DMARK
9e40				CALLMONITOR 
9e40 cd 6f ee			call debug_vector  
9e43				endm  
# End of macro CALLMONITOR
9e43			endif	 
9e43 cd 6d 92			call free 
9e46			.skippopfree: 
9e46				 
9e46			 
9e46			endif 
9e46			 
9e46			if DEBUG_FORTH_DOT_KEY 
9e46				DMARK "DP2" 
9e46				CALLMONITOR 
9e46			endif	 
9e46			 
9e46				; move pointer down 
9e46			 
9e46 2a ee e9			ld hl,(cli_data_sp) 
9e49 2b				dec hl 
9e4a 2b				dec hl 
9e4b			; PARSEV5 
9e4b 2b				dec hl 
9e4c 22 ee e9			ld (cli_data_sp), hl 
9e4f			 
9e4f				if DEBUG_FORTH_STACK_GUARD 
9e4f cd 94 e0				call check_stacks 
9e52					FORTH_CHK_DSP_UNDER 
9e52 e5				push hl 
9e53 d5				push de 
9e54 2a ee e9			ld hl,(cli_data_sp) 
9e57 11 28 e8			ld de, cli_data_stack 
9e5a cd fa 8c			call cmp16 
9e5d da a2 e1			jp c, fault_dsp_under 
9e60 d1				pop de 
9e61 e1				pop hl 
9e62				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e62				endif 
9e62			 
9e62 e1				pop hl 
9e63			 
9e63 c9				ret 
9e64			 
9e64			getwordathl: 
9e64				; hl points to an address 
9e64				; load hl with the word at that address 
9e64			 
9e64 d5				push de 
9e65			 
9e65 5e				ld e, (hl) 
9e66 23				inc hl 
9e67 56				ld d, (hl) 
9e68 eb				ex de, hl 
9e69			 
9e69 d1				pop de 
9e6a c9				ret 
9e6b			 
9e6b			 
9e6b			 
9e6b			 
9e6b			 
9e6b			; eof 
9e6b			 
# End of file forth_stackopsv5.asm
9e6b			endif 
9e6b			 
9e6b			loadwordinhl:	 
9e6b			 
9e6b d5				push de 
9e6c			 
9e6c 5e				ld e, (hl) 
9e6d 23				inc hl 
9e6e 56				ld d, (hl) 
9e6f eb				ex de,hl  
9e70			 
9e70 d1				pop de 
9e71			 
9e71 c9				ret 
9e72			 
9e72			user_word_eol:  
9e72				; hl contains the pointer to where to create a linked list item from the end 
9e72				; of the user dict to continue on at the system word dict 
9e72				 
9e72				; poke the stub of the word list linked list to repoint to rom words 
9e72			 
9e72				; stub format 
9e72				; db   word id 
9e72				; dw    link to next word 
9e72			        ; db char length of token 
9e72				; db string + 0 term 
9e72				; db exec code....  
9e72			 
9e72 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e74 77				ld (hl), a		; word id 
9e75 23				inc hl 
9e76			 
9e76 11 41 a0			ld de, sysdict 
9e79 73				ld (hl), e		; next word link ie system dict 
9e7a 23				inc hl 
9e7b 72				ld (hl), d		; next word link ie system dict 
9e7c 23				inc hl	 
9e7d			 
9e7d			;	ld (hl), sysdict		; next word link ie system dict 
9e7d			;	inc hl 
9e7d			;	inc hl 
9e7d			 
9e7d			;	inc hl 
9e7d			;	inc hl 
9e7d			 
9e7d 3e 02			ld a, 2			; word length is 0 
9e7f 77				ld (hl), a	 
9e80 23				inc hl 
9e81			 
9e81 3e 7e			ld a, '~'			; word length is 0 
9e83 77				ld (hl), a	 
9e84 23				inc hl 
9e85 3e 00			ld a, 0			; save empty word 
9e87 77				ld (hl), a 
9e88			 
9e88 c9				ret 
9e89			 
9e89				 
9e89			 
9e89			forthexec_cleanup: 
9e89				FORTH_RSP_POP 
9e89 cd 04 9b			call macro_forth_rsp_pop 
9e8c				endm 
# End of macro FORTH_RSP_POP
9e8c c9				ret 
9e8d			 
9e8d			forth_call_hl: 
9e8d				; taking hl 
9e8d e5				push hl 
9e8e c9				ret 
9e8f			 
9e8f			; this is called to reset Forth system but keep existing uwords etc 
9e8f			 
9e8f			forth_warmstart: 
9e8f				; setup stack over/under flow checks 
9e8f				if DEBUG_FORTH_STACK_GUARD 
9e8f cd 7a e0				call chk_stk_init 
9e92				endif 
9e92			 
9e92				; init stack pointers  - * these stacks go upwards *  
9e92 21 ac e9			ld hl, cli_ret_stack 
9e95 22 f2 e9			ld (cli_ret_sp), hl	 
9e98				; set bottom of stack 
9e98 3e 00			ld a,0 
9e9a 77				ld (hl),a 
9e9b 23				inc hl 
9e9c 77				ld (hl),a 
9e9d			 
9e9d 21 28 e8			ld hl, cli_data_stack 
9ea0 22 ee e9			ld (cli_data_sp), hl	 
9ea3				; set bottom of stack 
9ea3 3e 00			ld a,0 
9ea5 77				ld (hl),a 
9ea6 23				inc hl 
9ea7 77				ld (hl),a 
9ea8			 
9ea8 21 2a e9			ld hl, cli_loop_stack 
9eab 22 f0 e9			ld (cli_loop_sp), hl	 
9eae				; set bottom of stack 
9eae 3e 00			ld a,0 
9eb0 77				ld (hl),a 
9eb1 23				inc hl 
9eb2 77				ld (hl),a 
9eb3			 
9eb3				; init extent of current open file 
9eb3			 
9eb3 3e 00			ld a, 0 
9eb5 32 6a ea			ld (store_openext), a 
9eb8			 
9eb8 c9				ret 
9eb9			 
9eb9			 
9eb9			 
9eb9			; Cold Start - this is called to setup the whole Forth system 
9eb9			 
9eb9			forth_init: 
9eb9			 
9eb9				; setup stack over/under flow checks 
9eb9			 
9eb9			;	if DEBUG_FORTH_STACK_GUARD 
9eb9			;		call chk_stk_init 
9eb9			;	endif 
9eb9			 
9eb9				; enable auto display updates (slow.....) 
9eb9			 
9eb9 3e 01			ld a, 1 
9ebb 32 3c ea			ld (cli_autodisplay), a 
9ebe			 
9ebe				; if storage is in use disable long reads for now 
9ebe 3e 00			ld a, 0 
9ec0 32 75 ea			ld (store_longread), a 
9ec3			 
9ec3			 
9ec3				; show start up screen 
9ec3			 
9ec3 cd af 8a			call clear_display 
9ec6			 
9ec6 3e 00			ld a,0 
9ec8 32 5e ea			ld (f_cursor_ptr), a 
9ecb			 
9ecb				; set start of word list in start of ram - for use when creating user words 
9ecb			 
9ecb 21 2e e4			ld hl, baseram 
9ece 22 be e5			ld (os_last_new_uword), hl 
9ed1 cd 72 9e			call user_word_eol 
9ed4				 
9ed4			;		call display_data_sp 
9ed4			;		call next_page_prompt 
9ed4			 
9ed4			 
9ed4			 
9ed4			 
9ed4 c9				ret 
9ed5			 
9ed5 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ee9			 
9ee9			; TODO push to stack 
9ee9			 
9ee9			;  
9ee9			 
9ee9			if FORTH_PARSEV2 
9ee9			 
9ee9			 
9ee9				include "forth_parserv2.asm" 
9ee9			 
9ee9			endif 
9ee9			 
9ee9			 
9ee9			; parse cli version 1 
9ee9			 
9ee9			if FORTH_PARSEV1 
9ee9			 
9ee9			 
9ee9			 
9ee9			      include "forth_parserv1.asm" 
9ee9			endif 
9ee9				 
9ee9			if FORTH_PARSEV3 
9ee9			 
9ee9			 
9ee9			 
9ee9			      include "forth_parserv3.asm" 
9ee9				include "forth_wordsv3.asm" 
9ee9			endif 
9ee9			 
9ee9			if FORTH_PARSEV4 
9ee9			 
9ee9			 
9ee9			 
9ee9			      include "forth_parserv4.asm" 
9ee9				include "forth_wordsv4.asm" 
9ee9			endif 
9ee9			 
9ee9			if FORTH_PARSEV5 
9ee9			 
9ee9			 
9ee9			 
9ee9			      include "forth_parserv5.asm" 
9ee9			 
9ee9			 
9ee9			; A better parser without using malloc and string copies all over the place.  
9ee9			; Exec in situ should be faster 
9ee9			 
9ee9			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ee9			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ee9			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ee9			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ee9			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ee9			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ee9			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ee9			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ee9			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ee9			 
9ee9			; Core word preamble macro 
9ee9			 
9ee9			CWHEAD:   macro nxtword opcode lit len opflags 
9ee9				db WORD_SYS_CORE+opcode             
9ee9				; internal op code number 
9ee9				dw nxtword            
9ee9				; link to next dict word block 
9ee9				db len + 1 
9ee9				; literal length of dict word inc zero term 
9ee9				db lit,0              
9ee9				; literal dict word 
9ee9			        ; TODO db opflags        
9ee9				endm 
9ee9			 
9ee9			 
9ee9			NEXTW: macro  
9ee9				jp macro_next 
9ee9				endm 
9ee9			 
9ee9			macro_next: 
9ee9			if DEBUG_FORTH_PARSE_KEY 
9ee9				DMARK "NXT" 
9ee9				CALLMONITOR 
9ee9			endif	 
9ee9			;	inc hl  ; skip token null term  
9ee9 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9eed ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ef1 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ef4			if DEBUG_FORTH_PARSE_KEY 
9ef4				DMARK "}AA" 
9ef4				CALLMONITOR 
9ef4			endif	 
9ef4 c3 f7 9f			jp execnext 
9ef7				;jp exec1 
9ef7			       
9ef7			 
9ef7			 
9ef7			; Another go at the parser to compile  
9ef7			 
9ef7			 
9ef7			; TODO rework parser to change all of the string words to byte tokens 
9ef7			; TODO do a search for  
9ef7			 
9ef7			; TODO first run normal parser to zero term sections 
9ef7			; TODO for each word do a token look up to get the op code 
9ef7			; TODO need some means to flag to the exec that this is a byte code form    
9ef7			 
9ef7			 
9ef7			forthcompile: 
9ef7			 
9ef7			; 
9ef7			; line parse: 
9ef7			;       parse raw input buffer 
9ef7			;       tokenise the words 
9ef7			;       malloc new copy (for looping etc) 
9ef7			;       copy to malloc + current pc in line to start of string and add line term 
9ef7			;       save on new rsp 
9ef7			; 
9ef7			 
9ef7			; hl to point to the line to tokenise 
9ef7			 
9ef7			;	push hl 
9ef7 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9efa			 
9efa			;	ld a,0		; string term on input 
9efa			;	call strlent 
9efa			 
9efa			;	ld (os_tok_len), hl	 ; save string length 
9efa			 
9efa			;if DEBUG_FORTH_TOK 
9efa			;	ex de,hl		 
9efa			;endif 
9efa			 
9efa			;	pop hl 		; get back string pointer 
9efa			 
9efa			if DEBUG_FORTH_TOK 
9efa						DMARK "TOc" 
9efa				CALLMONITOR 
9efa			endif 
9efa 7e			.cptoken2:    ld a,(hl) 
9efb 23				inc hl 
9efc fe 7f			cp FORTH_END_BUFFER 
9efe 28 29			jr z, .cptokendone2 
9f00 fe 00			cp 0 
9f02 28 25			jr z, .cptokendone2 
9f04 fe 22			cp '"' 
9f06 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f08 fe 20			cp ' ' 
9f0a 20 ee			jr nz,  .cptoken2 
9f0c			 
9f0c			; TODO consume comments held between ( and ) 
9f0c			 
9f0c				; we have a space so change to zero term for dict match later 
9f0c 2b				dec hl 
9f0d 3e 00			ld a,0 
9f0f 77				ld (hl), a 
9f10 23				inc hl 
9f11 18 e7			jr .cptoken2 
9f13				 
9f13			 
9f13			.cptokenstr2: 
9f13				; skip all white space until either eol (because forgot to term) or end double quote 
9f13			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f13				;inc hl ; skip current double quote 
9f13 7e				ld a,(hl) 
9f14 23				inc hl 
9f15 fe 22			cp '"' 
9f17 28 e1			jr z, .cptoken2 
9f19 fe 7f			cp FORTH_END_BUFFER 
9f1b 28 0c			jr z, .cptokendone2 
9f1d fe 00			cp 0 
9f1f 28 08			jr z, .cptokendone2 
9f21 fe 20			cp ' ' 
9f23 28 02			jr z, .cptmp2 
9f25 18 ec			jr .cptokenstr2 
9f27			 
9f27			.cptmp2:	; we have a space so change to zero term for dict match later 
9f27				;dec hl 
9f27				;ld a,"-"	; TODO remove this when working 
9f27				;ld (hl), a 
9f27				;inc hl 
9f27 18 ea			jr .cptokenstr2 
9f29			 
9f29			.cptokendone2: 
9f29				;inc hl 
9f29 3e 7f			ld a, FORTH_END_BUFFER 
9f2b 77				ld (hl),a 
9f2c 23				inc hl 
9f2d 3e 21			ld a, '!' 
9f2f 77				ld (hl),a 
9f30			 
9f30 2a c2 e5			ld hl,(os_tok_ptr) 
9f33			         
9f33			if DEBUG_FORTH_TOK 
9f33						DMARK "Tc1" 
9f33				CALLMONITOR 
9f33			endif 
9f33			 
9f33				; push exec string to top of return stack 
9f33				FORTH_RSP_NEXT 
9f33 cd e3 9a			call macro_forth_rsp_next 
9f36				endm 
# End of macro FORTH_RSP_NEXT
9f36 c9				ret 
9f37			 
9f37			; Another go at the parser need to simplify the process 
9f37			 
9f37			forthparse: 
9f37			 
9f37			; 
9f37			; line parse: 
9f37			;       parse raw input buffer 
9f37			;       tokenise the words 
9f37			;       malloc new copy (for looping etc) 
9f37			;       copy to malloc + current pc in line to start of string and add line term 
9f37			;       save on new rsp 
9f37			; 
9f37			 
9f37			; hl to point to the line to tokenise 
9f37			 
9f37			;	push hl 
9f37 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f3a			 
9f3a			;	ld a,0		; string term on input 
9f3a			;	call strlent 
9f3a			 
9f3a			;	ld (os_tok_len), hl	 ; save string length 
9f3a			 
9f3a			;if DEBUG_FORTH_TOK 
9f3a			;	ex de,hl		 
9f3a			;endif 
9f3a			 
9f3a			;	pop hl 		; get back string pointer 
9f3a			 
9f3a			if DEBUG_FORTH_TOK 
9f3a						DMARK "TOK" 
9f3a				CALLMONITOR 
9f3a			endif 
9f3a 7e			.ptoken2:    ld a,(hl) 
9f3b 23				inc hl 
9f3c fe 7f			cp FORTH_END_BUFFER 
9f3e 28 29			jr z, .ptokendone2 
9f40 fe 00			cp 0 
9f42 28 25			jr z, .ptokendone2 
9f44 fe 22			cp '"' 
9f46 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f48 fe 20			cp ' ' 
9f4a 20 ee			jr nz,  .ptoken2 
9f4c			 
9f4c			; TODO consume comments held between ( and ) 
9f4c			 
9f4c				; we have a space so change to zero term for dict match later 
9f4c 2b				dec hl 
9f4d 3e 00			ld a,0 
9f4f 77				ld (hl), a 
9f50 23				inc hl 
9f51 18 e7			jr .ptoken2 
9f53				 
9f53			 
9f53			.ptokenstr2: 
9f53				; skip all white space until either eol (because forgot to term) or end double quote 
9f53			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f53				;inc hl ; skip current double quote 
9f53 7e				ld a,(hl) 
9f54 23				inc hl 
9f55 fe 22			cp '"' 
9f57 28 e1			jr z, .ptoken2 
9f59 fe 7f			cp FORTH_END_BUFFER 
9f5b 28 0c			jr z, .ptokendone2 
9f5d fe 00			cp 0 
9f5f 28 08			jr z, .ptokendone2 
9f61 fe 20			cp ' ' 
9f63 28 02			jr z, .ptmp2 
9f65 18 ec			jr .ptokenstr2 
9f67			 
9f67			.ptmp2:	; we have a space so change to zero term for dict match later 
9f67				;dec hl 
9f67				;ld a,"-"	; TODO remove this when working 
9f67				;ld (hl), a 
9f67				;inc hl 
9f67 18 ea			jr .ptokenstr2 
9f69			 
9f69			.ptokendone2: 
9f69				;inc hl 
9f69 3e 7f			ld a, FORTH_END_BUFFER 
9f6b 77				ld (hl),a 
9f6c 23				inc hl 
9f6d 3e 21			ld a, '!' 
9f6f 77				ld (hl),a 
9f70			 
9f70 2a c2 e5			ld hl,(os_tok_ptr) 
9f73			         
9f73			if DEBUG_FORTH_TOK 
9f73						DMARK "TK1" 
9f73				CALLMONITOR 
9f73			endif 
9f73			 
9f73				; push exec string to top of return stack 
9f73				FORTH_RSP_NEXT 
9f73 cd e3 9a			call macro_forth_rsp_next 
9f76				endm 
# End of macro FORTH_RSP_NEXT
9f76 c9				ret 
9f77			 
9f77			; 
9f77			;	; malloc size + buffer pointer + if is loop flag 
9f77			;	ld hl,(os_tok_len) 		 ; get string length 
9f77			; 
9f77			;	ld a,l 
9f77			; 
9f77			;	cp 0			; we dont want to use a null string 
9f77			;	ret z 
9f77			; 
9f77			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f77			; 
9f77			;	add 5     ; TODO when certain not over writing memory remove 
9f77			; 
9f77			;		 
9f77			; 
9f77			;if DEBUG_FORTH_TOK 
9f77			;			DMARK "TKE" 
9f77			;	CALLMONITOR 
9f77			;endif 
9f77			; 
9f77			;	ld l,a 
9f77			;	ld h,0 
9f77			;;	push hl   ; save required space for the copy later 
9f77			;	call malloc 
9f77			;if DEBUG_FORTH_TOK 
9f77			;			DMARK "TKM" 
9f77			;	CALLMONITOR 
9f77			;endif 
9f77			;	if DEBUG_FORTH_MALLOC_GUARD 
9f77			;		push af 
9f77			;		call ishlzero 
9f77			;;		ld a, l 
9f77			;;		add h 
9f77			;;		cp 0 
9f77			;		pop af 
9f77			;		 
9f77			;		call z,malloc_error 
9f77			;	endif 
9f77			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f77			; 
9f77			; 
9f77			;if DEBUG_FORTH_TOK 
9f77			;			DMARK "TKR" 
9f77			;	CALLMONITOR 
9f77			;endif 
9f77			; 
9f77			;	FORTH_RSP_NEXT 
9f77			; 
9f77			;	;inc hl	 ; go past current buffer pointer 
9f77			;	;inc hl 
9f77			;	;inc hl   ; and past if loop flag 
9f77			;		; TODO Need to set flag  
9f77			; 
9f77			;	 
9f77			;	 
9f77			;	ex de,hl	; malloc is dest 
9f77			;	ld hl, (os_tok_len) 
9f77			;;	pop bc 
9f77			;	ld c, l                
9f77			;	ld b,0 
9f77			;	ld hl, (os_tok_ptr) 
9f77			; 
9f77			;if DEBUG_FORTH_TOK 
9f77			;			DMARK "TKT" 
9f77			;	CALLMONITOR 
9f77			;endif 
9f77			; 
9f77			;	; do str cpy 
9f77			; 
9f77			;	ldir      ; copy byte in hl to de 
9f77			; 
9f77			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f77			; 
9f77			;if DEBUG_FORTH_TOK 
9f77			; 
9f77			;			DMARK "TKY" 
9f77			;	CALLMONITOR 
9f77			;endif 
9f77			;	;ld a,0 
9f77			;	;ld a,FORTH_END_BUFFER 
9f77			;	ex de, hl 
9f77			;	;dec hl			 ; go back over the space delim at the end of word 
9f77			;	;ld (hl),a 
9f77			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f77			;	ld a,FORTH_END_BUFFER 
9f77			;	ld (hl),a 
9f77			;	inc hl 
9f77			;	ld a,FORTH_END_BUFFER 
9f77			;	ld (hl),a 
9f77			; 
9f77			;	; init the malloc area data 
9f77			;	; set pc for in current area 
9f77			;	;ld hl, (os_tok_malloc) 
9f77			;	;inc hl 
9f77			;	;inc hl 
9f77			;	;inc hl 
9f77			;	;ex de,hl 
9f77			;	;ld hl, (os_tok_malloc) 
9f77			;	;ld (hl),e 
9f77			;	;inc hl 
9f77			;	;ld (hl),d 
9f77			; 
9f77			; 
9f77			;	ld hl,(os_tok_malloc) 
9f77			;if DEBUG_FORTH_PARSE_KEY 
9f77			;			DMARK "TKU" 
9f77			;	CALLMONITOR 
9f77			;endif 
9f77			; 
9f77			;	ret 
9f77			 
9f77			forthexec: 
9f77			 
9f77			; line exec: 
9f77			; forth parser 
9f77			 
9f77			; 
9f77			;       get current exec line on rsp 
9f77			 
9f77				FORTH_RSP_TOS 
9f77 cd fa 9a			call macro_forth_rsp_tos 
9f7a				endm 
# End of macro FORTH_RSP_TOS
9f7a			 
9f7a			;       restore current pc - hl points to malloc of data 
9f7a			 
9f7a				;ld e, (hl) 
9f7a				;inc hl 
9f7a				;ld d, (hl) 
9f7a				;ex de,hl 
9f7a			 
9f7a			 
9f7a			exec1: 
9f7a 22 c2 e5			ld (os_tok_ptr), hl 
9f7d			 
9f7d				; copy our PC to working vars  
9f7d 22 40 ea			ld (cli_ptr), hl 
9f80 22 3e ea			ld (cli_origptr), hl 
9f83			 
9f83 7e				ld a,(hl) 
9f84 fe 7f			cp FORTH_END_BUFFER 
9f86 c8				ret z 
9f87			 
9f87				; skip any nulls 
9f87			 
9f87 fe 00			cp 0 
9f89 20 03			jr nz, .execword 
9f8b 23				inc hl 
9f8c 18 ec			jr exec1 
9f8e			 
9f8e			 
9f8e			.execword: 
9f8e			 
9f8e			 
9f8e			 
9f8e			if DEBUG_FORTH_PARSE_KEY 
9f8e						DMARK "KYQ" 
9f8e				CALLMONITOR 
9f8e			endif 
9f8e			;       while at start of word: 
9f8e			; get start of dict (in user area first) 
9f8e			 
9f8e 21 2e e4		ld hl, baseram 
9f91			;ld hl, sysdict 
9f91 22 42 ea		ld (cli_nextword),hl 
9f94			;           match word at pc 
9f94			;           exec word 
9f94			;           or push to dsp 
9f94			;           forward to next token 
9f94			;           if line term pop rsp and exit 
9f94			;        
9f94			 
9f94			if DEBUG_FORTH_PARSE_KEY 
9f94						DMARK "KYq" 
9f94				CALLMONITOR 
9f94			endif 
9f94			 
9f94			; 
9f94			; word comp 
9f94			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f94			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f94			;    move to start of word  
9f94			;    compare word to cli_token 
9f94			 
9f94			.execpnword:	; HL at start of a word in the dictionary to check 
9f94			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f94			;	ld (cli_ptr), hl 
9f94			 
9f94 2a 42 ea			ld hl,(cli_nextword) 
9f97			 
9f97 cd 3a a0			call forth_tok_next 
9f9a			; tok next start here 
9f9a			;	; TODO skip compiled symbol for now 
9f9a			;	inc hl 
9f9a			; 
9f9a			;	; save pointer to next word 
9f9a			; 
9f9a			;	; hl now points to the address of the next word pointer  
9f9a			;	ld e, (hl) 
9f9a			;	inc hl 
9f9a			;	ld d, (hl) 
9f9a			;	inc l 
9f9a			; 
9f9a			;	ex de,hl 
9f9a			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f9a			;	push bc 
9f9a			;	ld bc, (cli_nextword) 
9f9a			;			DMARK "NXW" 
9f9a			;	CALLMONITOR 
9f9a			;	pop bc 
9f9a			;endif 
9f9a			; tok next end here 
9f9a 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f9d eb				ex de, hl 
9f9e			 
9f9e			 
9f9e				; save the pointer of the current token - 1 to check against 
9f9e				 
9f9e 22 46 ea			ld (cli_token), hl   
9fa1				; TODO maybe remove below save if no debug 
9fa1				; save token string ptr for any debug later 
9fa1 23				inc hl  
9fa2 22 48 ea			ld (cli_origtoken), hl 
9fa5 2b				dec hl 
9fa6				; save pointer to the start of the next dictionay word 
9fa6 7e				ld a,(hl)   ; get string length 
9fa7 47				ld b,a 
9fa8			.execpnwordinc:  
9fa8 23				inc hl 
9fa9 10 fd			djnz .execpnwordinc 
9fab 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9fae			 
9fae				; now check the word token against the string being parsed 
9fae			 
9fae 2a 46 ea			ld hl,(cli_token) 
9fb1 23				inc hl     ; skip string length (use zero term instead to end) 
9fb2 22 46 ea			ld (cli_token), hl 
9fb5			 
9fb5			if DEBUG_FORTH_PARSE_KEY 
9fb5						DMARK "KY2" 
9fb5			endif 
9fb5			if DEBUG_FORTH_PARSE_EXEC 
9fb5				; see if disabled 
9fb5			 
9fb5			;	ld a, (os_view_disable) 
9fb5			;	cp '*' 
9fb5				ld a, (debug_vector) 
9fb5				cp $c9   ; RET  
9fb5				jr z, .skip 
9fb5			 
9fb5				push hl 
9fb5				push hl 
9fb5				call clear_display 
9fb5				ld de, .compword 
9fb5				ld a, display_row_1 
9fb5				call str_at_display 
9fb5				pop de 
9fb5				ld a, display_row_2 
9fb5				call str_at_display 
9fb5				ld hl,(cli_ptr) 
9fb5				ld a,(hl) 
9fb5			        ld hl, os_word_scratch 
9fb5				ld (hl),a 
9fb5				ld a,0 
9fb5				inc hl 
9fb5				ld (hl),a 	 
9fb5				ld de, os_word_scratch 
9fb5				ld a, display_row_2+10 
9fb5				call str_at_display 
9fb5				call update_display 
9fb5				ld a, 100 
9fb5				call aDelayInMS 
9fb5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fb5				call delay250ms 
9fb5				endif 
9fb5				pop hl 
9fb5			.skip:  
9fb5			endif	 
9fb5			.execpnchar:    ; compare char between token and string to parse 
9fb5			 
9fb5			if DEBUG_FORTH_PARSE_KEY 
9fb5						DMARK "Ky3" 
9fb5			endif 
9fb5			if DEBUG_FORTH_PARSE_EXEC 
9fb5				; see if disabled 
9fb5			 
9fb5			;	ld a, (os_view_disable) 
9fb5			;	cp '*' 
9fb5				ld a, (debug_vector) 
9fb5				cp $C9  ; RET 
9fb5				jr z, .skip2 
9fb5			 
9fb5			;	call clear_display 
9fb5			ld hl,(cli_token) 
9fb5			ld a,(hl) 
9fb5			ld (os_word_scratch),a 
9fb5				ld hl,(cli_ptr) 
9fb5			ld a,(hl) 
9fb5				ld (os_word_scratch+1),a 
9fb5				ld a,0 
9fb5				ld (os_word_scratch+2),a 
9fb5				ld de,os_word_scratch 
9fb5				ld a,display_row_4 
9fb5				call str_at_display 
9fb5				call update_display 
9fb5			.skip2:  
9fb5			endif 
9fb5 2a 46 ea			ld hl,(cli_token) 
9fb8 7e				ld a, (hl)	 ; char in word token 
9fb9 23				inc hl 		; move to next char 
9fba 22 46 ea			ld (cli_token), hl ; and save it 
9fbd 47				ld b,a 
9fbe			 
9fbe 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fc1 7e				ld a,(hl) 
9fc2 23				inc hl 
9fc3 22 40 ea			ld (cli_ptr), hl		; move to next char 
9fc6 cd 31 91			call toUpper 		; make sure the input string matches case 
9fc9			 
9fc9			if DEBUG_FORTH_PARSE 
9fc9			endif 
9fc9			 
9fc9				; input stream end of token is a space so get rid of it 
9fc9			 
9fc9			;	cp ' ' 
9fc9			;	jr nz, .pnskipspace 
9fc9			; 
9fc9			;	ld a, 0		; make same term as word token term 
9fc9			; 
9fc9			;.pnskipspace: 
9fc9			 
9fc9			if DEBUG_FORTH_PARSE_KEY 
9fc9						DMARK "KY7" 
9fc9			endif 
9fc9 b8				cp b 
9fca c2 e0 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fcd				 
9fcd			;    if same 
9fcd			;       scan for string terms 0 for token and 32 for input 
9fcd			 
9fcd				 
9fcd			if DEBUG_FORTH_PARSE_KEY 
9fcd						DMARK "KY8" 
9fcd			endif 
9fcd			 
9fcd 80				add b			 
9fce fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fd0							; TODO need to make sure last word in zero term string is accounted for 
9fd0 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fd2			 
9fd2			 
9fd2				; at end of both strings so both are exact match 
9fd2			 
9fd2			;       skip ptr for next word 
9fd2			 
9fd2 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9fd5 23				inc hl			 ; at next char 
9fd6 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fd9 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fdc				 
9fdc				 
9fdc			if DEBUG_FORTH_PARSE_KEY 
9fdc						DMARK "KY3" 
9fdc			endif 
9fdc			 
9fdc			 
9fdc			 
9fdc			;       exec code block 
9fdc			if DEBUG_FORTH_JP 
9fdc				call clear_display 
9fdc				call update_display 
9fdc				call delay1s 
9fdc				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fdc				ld a,h 
9fdc				ld hl, os_word_scratch 
9fdc				call hexout 
9fdc				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fdc				ld a,l 
9fdc				ld hl, os_word_scratch+2 
9fdc				call hexout 
9fdc				ld hl, os_word_scratch+4 
9fdc				ld a,0 
9fdc				ld (hl),a 
9fdc				ld de,os_word_scratch 
9fdc				call str_at_display 
9fdc					ld a, display_row_2 
9fdc					call str_at_display 
9fdc				ld de, (cli_origtoken) 
9fdc				ld a, display_row_1+10 
9fdc					call str_at_display 
9fdc			 
9fdc				ld a,display_row_1 
9fdc				ld de, .foundword 
9fdc				ld a, display_row_3 
9fdc				call str_at_display 
9fdc				call update_display 
9fdc				call delay1s 
9fdc				call delay1s 
9fdc				call delay1s 
9fdc			endif 
9fdc			 
9fdc			if DEBUG_FORTH_PARSE_KEY 
9fdc						DMARK "KYj" 
9fdc			endif 
9fdc				; TODO save the word pointer in this exec 
9fdc			 
9fdc 2a 44 ea			ld hl,(cli_execword) 
9fdf e9				jp (hl) 
9fe0			 
9fe0			 
9fe0			;    if not same 
9fe0			;	scan for zero term 
9fe0			;	get ptr for next word 
9fe0			;	goto word comp 
9fe0			 
9fe0			.execpnskipword:	; get pointer to next word 
9fe0 2a 42 ea			ld hl,(cli_nextword) 
9fe3			 
9fe3 7e				ld a,(hl) 
9fe4 fe 00			cp WORD_SYS_END 
9fe6			;	cp 0 
9fe6 28 09			jr z, .execendofdict			 ; at end of words 
9fe8			 
9fe8			if DEBUG_FORTH_PARSE_KEY 
9fe8						DMARK "KY4" 
9fe8			endif 
9fe8			if DEBUG_FORTH_PARSE_EXEC 
9fe8			 
9fe8				; see if disabled 
9fe8			 
9fe8			;	ld a, (os_view_disable) 
9fe8			;	cp '*' 
9fe8				ld a,(debug_vector) 
9fe8				cp $c9   ; RET 
9fe8				jr z, .noskip 
9fe8			 
9fe8			 
9fe8				ld de, .nowordfound 
9fe8				ld a, display_row_3 
9fe8				call str_at_display 
9fe8				call update_display 
9fe8				ld a, 100 
9fe8				call aDelayInMS 
9fe8				 
9fe8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fe8					call delay250ms 
9fe8				endif 
9fe8			.noskip:  
9fe8			 
9fe8			endif	 
9fe8			 
9fe8 2a 3e ea			ld hl,(cli_origptr) 
9feb 22 40 ea			ld (cli_ptr),hl 
9fee			 
9fee			if DEBUG_FORTH_PARSE_KEY 
9fee						DMARK "KY5" 
9fee			endif 
9fee c3 94 9f			jp .execpnword			; else go to next word 
9ff1			 
9ff1			.execendofdict:  
9ff1			 
9ff1			if DEBUG_FORTH_PARSE_KEY 
9ff1						DMARK "KYe" 
9ff1			endif 
9ff1			if DEBUG_FORTH_PARSE_EXEC 
9ff1				; see if disabled 
9ff1			 
9ff1			;	ld a, (os_view_disable) 
9ff1			;	cp '*' 
9ff1				ld a,(debug_vector) 
9ff1				cp $c9   ; ret 
9ff1				jr z, .ispskip 
9ff1			 
9ff1				call clear_display 
9ff1				call update_display 
9ff1				call delay1s 
9ff1				ld de, (cli_origptr) 
9ff1				ld a, display_row_1 
9ff1				call str_at_display 
9ff1				 
9ff1				ld de, .enddict 
9ff1				ld a, display_row_3 
9ff1				call str_at_display 
9ff1				call update_display 
9ff1				ld a, 100 
9ff1				call aDelayInMS 
9ff1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff1				call delay1s 
9ff1				call delay1s 
9ff1				call delay1s 
9ff1				endif 
9ff1			.ispskip:  
9ff1				 
9ff1			endif	 
9ff1			 
9ff1			 
9ff1			 
9ff1				; if the word is not a keyword then must be a literal so push it to stack 
9ff1			 
9ff1			; push token to stack to end of word 
9ff1			 
9ff1				STACKFRAME ON $1efe $2f9f 
9ff1				if DEBUG_STACK_IMB 
9ff1					if ON 
9ff1						exx 
9ff1						ld de, $1efe 
9ff1						ld a, d 
9ff1						ld hl, curframe 
9ff1						call hexout 
9ff1						ld a, e 
9ff1						ld hl, curframe+2 
9ff1						call hexout 
9ff1						ld hl, $1efe 
9ff1						push hl 
9ff1						ld hl, $2f9f 
9ff1						push hl 
9ff1						exx 
9ff1					endif 
9ff1				endif 
9ff1			endm 
# End of macro STACKFRAME
9ff1			 
9ff1 2a c2 e5		ld hl,(os_tok_ptr) 
9ff4 cd a5 9c		call forth_apush 
9ff7			 
9ff7				STACKFRAMECHK ON $1efe $2f9f 
9ff7				if DEBUG_STACK_IMB 
9ff7					if ON 
9ff7						exx 
9ff7						ld hl, $2f9f 
9ff7						pop de   ; $2f9f 
9ff7						call cmp16 
9ff7						jr nz, .spnosame 
9ff7						ld hl, $1efe 
9ff7						pop de   ; $1efe 
9ff7						call cmp16 
9ff7						jr z, .spfrsame 
9ff7						.spnosame: call showsperror 
9ff7						.spfrsame: nop 
9ff7						exx 
9ff7					endif 
9ff7				endif 
9ff7			endm 
# End of macro STACKFRAMECHK
9ff7			 
9ff7			execnext: 
9ff7			 
9ff7			if DEBUG_FORTH_PARSE_KEY 
9ff7						DMARK "KY>" 
9ff7			endif 
9ff7			; move past token to next word 
9ff7			 
9ff7 2a c2 e5		ld hl, (os_tok_ptr) 
9ffa 3e 00		ld a, 0 
9ffc 01 ff 00		ld bc, 255     ; input buffer size 
9fff ed b1		cpir 
a001			 
a001			if DEBUG_FORTH_PARSE_KEY 
a001						DMARK "KY!" 
a001				CALLMONITOR 
a001			endif	 
a001			; TODO this might place hl on the null, so will need to forward on??? 
a001			;inc hl   ; see if this gets onto the next item 
a001			 
a001			 
a001			; TODO pass a pointer to the buffer to push 
a001			; TODO call function to push 
a001			 
a001			; look for end of input 
a001			 
a001			;inc hl 
a001			;ld a,(hl) 
a001			;cp FORTH_END_BUFFER 
a001			;ret z 
a001			 
a001			 
a001 c3 7a 9f		jp exec1 
a004			 
a004			 
a004			 
a004			 
a004			 
a004			 
a004			 
a004			 
a004			 
a004			findnexttok: 
a004			 
a004				; hl is pointer to move 
a004				; de is the token to locate 
a004			 
a004					if DEBUG_FORTH 
a004						DMARK "NTK" 
a004						CALLMONITOR 
a004					endif 
a004 d5				push de 
a005			 
a005			.fnt1:	 
a005				; find first char of token to locate 
a005			 
a005 1a				ld a, (de) 
a006 4f				ld c,a 
a007 7e				ld a,(hl) 
a008 cd 31 91			call toUpper 
a00b					if DEBUG_FORTH 
a00b						DMARK "NT1" 
a00b						CALLMONITOR 
a00b					endif 
a00b b9				cp c 
a00c			 
a00c 28 03			jr z, .fnt2cmpmorefirst	 
a00e			 
a00e				; first char not found move to next char 
a00e			 
a00e 23				inc hl 
a00f 18 f4			jr .fnt1 
a011			 
a011			.fnt2cmpmorefirst:	 
a011				; first char of token found.  
a011			 
a011 e5				push hl     ; save start of token just in case it is the right one 
a012 d9				exx 
a013 e1				pop hl        ; save it to hl' 
a014 d9				exx 
a015			 
a015			 
a015			.fnt2cmpmore:	 
a015				; compare the rest 
a015				 
a015 23				inc hl 
a016 13				inc de 
a017				 
a017 1a				ld a, (de) 
a018 4f				ld c,a 
a019 7e				ld a,(hl) 
a01a cd 31 91			call toUpper 
a01d			 
a01d					if DEBUG_FORTH 
a01d						DMARK "NT2" 
a01d						CALLMONITOR 
a01d					endif 
a01d				; c has the token to find char 
a01d				; a has the mem to scan char 
a01d			 
a01d b9				cp c 
a01e 28 04			jr z,.fntmatch1 
a020			 
a020				; they are not the same 
a020			 
a020					if DEBUG_FORTH 
a020						DMARK "NT3" 
a020						CALLMONITOR 
a020					endif 
a020 d1				pop de	; reset de token to look for 
a021 d5				push de 
a022 18 e1			jr .fnt1 
a024				 
a024			.fntmatch1: 
a024			 
a024				; is the same char a null which means we might have a full hit? 
a024					if DEBUG_FORTH 
a024						DMARK "NT4" 
a024						CALLMONITOR 
a024					endif 
a024			 
a024 fe 00			cp 0 
a026 28 0b			jr z, .fntmatchyes 
a028			 
a028				; are we at the end of the token to find? 
a028			 
a028					if DEBUG_FORTH 
a028						DMARK "NT5" 
a028						CALLMONITOR 
a028					endif 
a028 3e 00			ld a, 0 
a02a b9				cp c 
a02b			 
a02b c2 15 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a02e			 
a02e					if DEBUG_FORTH 
a02e						DMARK "NT6" 
a02e						CALLMONITOR 
a02e					endif 
a02e				; token to find is exhusted but no match to stream 
a02e			 
a02e				; restore tok pointer and continue on 
a02e d1				pop de 
a02f d5				push de 
a030 c3 05 a0			jp .fnt1 
a033			 
a033			 
a033			.fntmatchyes: 
a033			 
a033				; hl now contains the end of the found token 
a033			 
a033				; get rid of saved token pointer to find 
a033			 
a033 d1				pop de 
a034			 
a034					if DEBUG_FORTH 
a034						DMARK "NT9" 
a034						CALLMONITOR 
a034					endif 
a034			 
a034				; hl will be on the null term so forward on 
a034			 
a034				; get back the saved start of the token 
a034			 
a034 d9				exx 
a035 e5				push hl     ; save start of token just in case it is the right one 
a036 d9				exx 
a037 e1				pop hl        ; save it to hl 
a038			 
a038 c9				ret 
a039			 
a039			 
a039			; LIST needs to find a specific token   
a039			; FORGET needs to find a spefici token 
a039			 
a039			; SAVE needs to find all tokens by flag 
a039			; WORDS just needs to scan through all  by flag 
a039			; UWORDS needs to scan through all by flag 
a039			 
a039			 
a039			; given hl as pointer to start of dict look up string 
a039			; return hl as pointer to start of word block 
a039			; or 0 if not found 
a039			 
a039			forth_find_tok: 
a039 c9				ret 
a03a			 
a03a			; given hl as pointer to dict structure 
a03a			; move to the next dict block structure 
a03a			 
a03a			forth_tok_next: 
a03a				; hl now points to the address of the next word pointer  
a03a				; TODO skip compiled symbol for now 
a03a			;	push de 
a03a 23				inc hl 
a03b 5e				ld e, (hl) 
a03c 23				inc hl 
a03d 56				ld d, (hl) 
a03e 23				inc hl 
a03f			 
a03f eb				ex de,hl 
a040			if DEBUG_FORTH_PARSE_NEXTWORD 
a040				push bc 
a040				ld bc, (cli_nextword) 
a040						DMARK "NXW" 
a040				CALLMONITOR 
a040				pop bc 
a040			endif 
a040			;	pop de	 
a040 c9				ret 
a041			 
a041			 
a041			 
a041			; eof 
# End of file forth_parserv5.asm
a041				include "forth_wordsv4.asm" 
a041			 
a041			; the core word dictionary v4 
a041			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a041			 
a041			; this is a linked list for each of the system words used 
a041			; user defined words will follow the same format but will be in ram 
a041			 
a041			 
a041			; 
a041			; 
a041			; define linked list: 
a041			; 
a041			; 1. compiled byte op code 
a041			; 2. len of text word 
a041			; 3. text word 
a041			; 4. ptr to next dictionary word 
a041			; 5. asm, calls etc for the word 
a041			; 
a041			;  if 1 == 0 then last word in dict  
a041			;   
a041			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a041			;  
a041			;  
a041			; create basic standard set of words 
a041			; 
a041			;  
a041			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a041			; 2DUP 2DROP 2SWAP  
a041			; @ C@ - get byte  
a041			; ! C! - store byte 
a041			; 0< true if less than zero 
a041			; 0= true if zero 
a041			; < >  
a041			; = true if same 
a041			; variables 
a041			 
a041			 
a041			; Hardware specific words I may need 
a041			; 
a041			; IN OUT  
a041			; calls to key util functions 
a041			; calls to hardward abstraction stuff 
a041			; easy control of frame buffers and lcd i/o 
a041			; keyboard  
a041			 
a041			 
a041			;DICT: macro 
a041			; op_code, len, word, next 
a041			;    word: 
a041			;    db op_code 
a041			;    ds word zero term 
a041			;    dw next 
a041			;    endm 
a041			 
a041			 
a041			 
a041			 
a041			; op code 1 is a flag for user define words which are to be handled differently 
a041			 
a041			 
a041			; 
a041			; 
a041			;    TODO on entry to a word this should be the expected environment 
a041			;    hl - tos value if number then held, if string this is the ptr 
a041			;    de -  
a041			 
a041			 
a041			; opcode ranges 
a041			; 0 - end of word dict 
a041			; 255 - user define words 
a041			 
a041			sysdict: 
a041			include "forth_opcodes.asm" 
a041			; op codes for forth keywords 
a041			; free to use code 0  
a041				OPCODE_HEAP: equ  1 
a041				OPCODE_EXEC: equ 2 
a041				OPCODE_DUP: equ 3 
a041				OPCODE_SWAP: equ 4 
a041				OPCODE_COLN: equ 5 
a041				OPCODE_SCOLN: equ 6 
a041				OPCODE_DROP: equ 7 
a041				OPCODE_DUP2: equ 8 
a041				OPCODE_DROP2: equ 9 
a041				OPCODE_SWAP2: equ 10 
a041				OPCODE_AT: equ 11 
a041				OPCODE_CAT: equ 12 
a041				OPCODE_BANG: equ 13 
a041				OPCODE_CBANG: equ 14 
a041				OPCODE_SCALL: equ 15 
a041				OPCODE_DEPTH: equ 16 
a041				OPCODE_OVER: equ 17 
a041				OPCODE_PAUSE: equ 18 
a041				OPCODE_PAUSES: equ 19 
a041				OPCODE_ROT: equ 20 
a041			;free to reuse	OPCODE_WORDS: equ 21 
a041			        OPCODE_NOT: equ 21 
a041				OPCODE_UWORDS: equ 22 
a041				OPCODE_BP: equ 23 
a041				OPCODE_MONITOR: equ 24  
a041				OPCODE_MALLOC: equ 25 
a041				OPCODE_FREE: equ 26 
a041				OPCODE_LIST: equ 27 
a041				OPCODE_FORGET: equ 28 
a041				OPCODE_NOP: equ 29 
a041				OPCODE_COMO: equ 30 
a041				OPCODE_COMC: equ 31 
a041			;free to reuse	OPCODE_ENDCORE: equ 32 
a041				OPCODE_AFTERSOUND: equ 33 
a041				OPCODE_GP2: equ 34 
a041				OPCODE_GP3: equ 35 
a041				OPCODE_GP4: equ 36 
a041				OPCODE_SIN: equ 37 
a041				OPCODE_SOUT: equ 38 
a041				OPCODE_SPIO: equ 39 
a041				OPCODE_SPICEH: equ 40 
a041				OPCODE_SPIOb: equ 41 
a041				OPCODE_SPII: equ 42 
a041				OPCODE_SESEL: equ 43 
a041				OPCODE_CARTDEV: equ 44 
a041			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a041				OPCODE_FB: equ 46 
a041				OPCODE_EMIT: equ 47 
a041				OPCODE_DOTH: equ 48 
a041				OPCODE_DOTF: equ 49 
a041				OPCODE_DOT: equ 50 
a041				OPCODE_CLS: equ 51 
a041				OPCODE_DRAW: equ 52 
a041				OPCODE_DUMP: equ 53 
a041				OPCODE_CDUMP: equ 54 
a041				OPCODE_DAT: equ 55 
a041				OPCODE_HOME: equ 56 
a041				OPCODE_SPACE: equ 57 
a041				OPCODE_SPACES: equ 58 
a041				OPCODE_SCROLL: equ 59 
a041				OPCODE_ATQ: equ 60 
a041				OPCODE_AUTODSP: equ 61 
a041				OPCODE_MENU: equ 62 
a041			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a041				OPCODE_THEN: equ 64 
a041				OPCODE_ELSE: equ 65 
a041				OPCODE_DO: equ 66 
a041				OPCODE_LOOP: equ 67 
a041				OPCODE_I: equ 68 
a041				OPCODE_DLOOP: equ 69  
a041				OPCODE_REPEAT: equ 70  
a041				OPCODE_UNTIL: equ 71 
a041				OPCODE_ENDFLOW: equ 72 
a041				OPCODE_WAITK: equ 73 
a041				OPCODE_ACCEPT: equ 74 
a041				OPCODE_EDIT: equ 75 
a041			;free to reuse	OPCODE_ENDKEY: equ 76 
a041				OPCODE_LZERO: equ 77 
a041				OPCODE_TZERO: equ 78 
a041				OPCODE_LESS: equ 79 
a041				OPCODE_GT: equ 80 
a041				OPCODE_EQUAL: equ 81  
a041			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a041				OPCODE_NEG: equ 83 
a041				OPCODE_DIV: equ 84 
a041				OPCODE_MUL: equ 85 
a041				OPCODE_MIN: equ 86 
a041				OPCODE_MAX: equ 87 
a041				OPCODE_RND16: equ 88 
a041				OPCODE_RND8: equ 89 
a041				OPCODE_RND: equ 90 
a041			;free to reuse	OPCODE_ENDMATHS: equ 91  
a041				OPCODE_BYNAME: equ 92 
a041				OPCODE_DIR: equ 93 
a041				OPCODE_SAVE: equ 94 
a041				OPCODE_LOAD: equ 95 
a041				OPCODE_BSAVE: equ 96 
a041				OPCODE_BLOAD: equ 97 
a041				OPCODE_SEO: equ 98  
a041				OPCODE_SEI: equ 99 
a041				OPCODE_SFREE: equ 100 
a041				OPCODE_SIZE: equ 101 
a041				OPCODE_CREATE: equ 102 
a041				OPCODE_APPEND: equ 103 
a041				OPCODE_SDEL: equ 104 
a041				OPCODE_OPEN: equ 105 
a041				OPCODE_READ: equ 106 
a041				OPCODE_EOF: equ 106 
a041				OPCODE_FORMAT: equ 107 
a041				OPCODE_LABEL: equ 108 
a041				OPCODE_LABELS: equ 109 
a041			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a041				OPCODE_UPPER: equ 111 
a041				OPCODE_LOWER: equ 112 
a041				OPCODE_SUBSTR: equ 113 
a041				OPCODE_LEFT: equ 114 
a041				OPCODE_RIGHT: equ 115 
a041				OPCODE_STR2NUM: equ 116 
a041				OPCODE_NUM2STR: equ 117 
a041				OPCODE_CONCAT: equ 118 
a041				OPCODE_FIND: equ 119 
a041				OPCODE_LEN: equ 120 
a041				OPCODE_CHAR: equ 121 
a041			; free to reuse	OPCODE_STRLEN: equ 122 
a041			; free to reuse	OPCODE_ENDSTR: equ 123 
a041				OPCODE_V0S: equ 124 
a041				OPCODE_V0Q: equ 125 
a041				OPCODE_V1S: equ 126 
a041				OPCODE_V1Q: equ 127 
a041				OPCODE_V2S: equ 128 
a041				OPCODE_V2Q: equ 129 
a041				OPCODE_V3S: equ 130 
a041				OPCODE_V3Q: equ 131 
a041			;free to reuse	OPCODE_END: equ 132 
a041				OPCODE_ZDUP: equ 133 
a041			 
a041			; eof 
# End of file forth_opcodes.asm
a041			 
a041			include "forth_words_core.asm" 
a041			 
a041			; | ## Core Words 
a041			 
a041			;if MALLOC_4 
a041			 
a041			.HEAP: 
a041				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a041 15				db WORD_SYS_CORE+OPCODE_HEAP             
a042 80 a0			dw .EXEC            
a044 05				db 4 + 1 
a045 .. 00			db "HEAP",0              
a04a				endm 
# End of macro CWHEAD
a04a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a04a			; | | u1 - Current number of bytes in the heap 
a04a			; | | u2 - Remaining bytes left on the heap 
a04a			; | |  
a04a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a04a			 
a04a			 
a04a					if DEBUG_FORTH_WORDS_KEY 
a04a						DMARK "HEP" 
a04a f5				push af  
a04b 3a 5f a0			ld a, (.dmark)  
a04e 32 6b ee			ld (debug_mark),a  
a051 3a 60 a0			ld a, (.dmark+1)  
a054 32 6c ee			ld (debug_mark+1),a  
a057 3a 61 a0			ld a, (.dmark+2)  
a05a 32 6d ee			ld (debug_mark+2),a  
a05d 18 03			jr .pastdmark  
a05f ..			.dmark: db "HEP"  
a062 f1			.pastdmark: pop af  
a063			endm  
# End of macro DMARK
a063						CALLMONITOR 
a063 cd 6f ee			call debug_vector  
a066				endm  
# End of macro CALLMONITOR
a066					endif 
a066 2a 38 e4				ld hl, (free_list )      
a069 11 3d e4				ld de, heap_start 
a06c			 
a06c ed 52				sbc hl, de  
a06e			 
a06e cd 3c 9b				call forth_push_numhl 
a071			 
a071			 
a071 ed 5b 38 e4			ld de, (free_list )      
a075 21 9c e2				ld hl, heap_end 
a078			 
a078 ed 52				sbc hl, de 
a07a			 
a07a cd 3c 9b				call forth_push_numhl 
a07d					 
a07d			 
a07d					 
a07d			 
a07d			 
a07d			 
a07d					NEXTW 
a07d c3 e9 9e			jp macro_next 
a080				endm 
# End of macro NEXTW
a080			;endif 
a080			 
a080			.EXEC: 
a080			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a080			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a080			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a080			;; > > 
a080			;; > >   
a080			;	STACKFRAME OFF $5efe $5f9f 
a080			; 
a080			;		if DEBUG_FORTH_WORDS_KEY 
a080			;			DMARK "EXE" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			; 
a080			;	FORTH_DSP_VALUEHL 
a080			; 
a080			;	FORTH_DSP_POP 
a080			; 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX1" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;;	ld e,(hl) 
a080			;;	inc hl 
a080			;;	ld d,(hl) 
a080			;;	ex de,hl 
a080			; 
a080			;;		if DEBUG_FORTH_WORDS 
a080			;;			DMARK "EX2" 
a080			;;			CALLMONITOR 
a080			;;		endif 
a080			;	push hl 
a080			; 
a080			;	;ld a, 0 
a080			;	;ld a, FORTH_END_BUFFER 
a080			;	call strlenz 
a080			;	inc hl   ; include zero term to copy 
a080			;	inc hl   ; include term 
a080			;	inc hl   ; include term 
a080			;	ld b,0 
a080			;	ld c,l 
a080			;	pop hl 
a080			;	ld de, execscratch 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX3" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	ldir 
a080			; 
a080			; 
a080			;	ld hl, execscratch 
a080			; 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EXe" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			; 
a080			;	call forthparse 
a080			;	call forthexec 
a080			;;	call forthexec_cleanup 
a080			;;	call forthparse 
a080			;;	call forthexec 
a080			; 
a080			;	STACKFRAMECHK OFF $5efe $5f9f 
a080			; 
a080			;	; an immediate word so no need to process any more words 
a080			;	ret 
a080			;	NEXTW 
a080			 
a080			; dead code - old version  
a080			;	FORTH_RSP_NEXT 
a080			 
a080			;  
a080			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a080			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a080			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a080			;	push hl 
a080			;	push de 
a080			;	push bc 
a080			; 
a080			; 
a080			;		if DEBUG_FORTH_WORDS_KEY 
a080			;			DMARK "EXR" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			; 
a080			; 
a080			; 
a080			;	;v5 FORTH_DSP_VALUE 
a080			;	FORTH_DSP_VALUEHL 
a080			; 
a080			;	; TODO do string type checks 
a080			; 
a080			;;v5	inc hl   ; skip type 
a080			; 
a080			;	push hl  ; source code  
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX1" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	ld a, 0 
a080			;	call strlent 
a080			; 
a080			;	inc hl 
a080			;	inc hl 
a080			;	inc hl 
a080			;	inc hl 
a080			; 
a080			;	push hl    ; size 
a080			; 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX2" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	call malloc 
a080			; 
a080			;	ex de, hl    ; de now contains malloc area 
a080			;	pop bc   	; get byte count 
a080			;	pop hl      ; get string to copy 
a080			; 
a080			;	push de     ; save malloc for free later 
a080			; 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX3" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	ldir       ; duplicate string 
a080			; 
a080			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a080			;	 
a080			;	; TODO fix the parse would be better than this...  
a080			;	ex de, hl 
a080			;	dec hl 
a080			;	ld a, 0 
a080			;	ld (hl), a 
a080			;	dec hl 
a080			;	ld a, ' ' 
a080			;	ld (hl), a 
a080			;	dec hl 
a080			;	ld (hl), a 
a080			; 
a080			;	dec hl 
a080			;	ld (hl), a 
a080			; 
a080			; 
a080			;	FORTH_DSP_POP  
a080			; 
a080			;	pop hl     
a080			;	push hl    ; save malloc area 
a080			; 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX4" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			; 
a080			;	call forthparse 
a080			;	call forthexec 
a080			;	 
a080			;	pop hl 
a080			;	if DEBUG_FORTH_WORDS 
a080			;		DMARK "EX5" 
a080			;		CALLMONITOR 
a080			;	endif 
a080			; 
a080			;	if FORTH_ENABLE_FREE 
a080			;	call free 
a080			;	endif 
a080			; 
a080			;	if DEBUG_FORTH_WORDS 
a080			;		DMARK "EX6" 
a080			;		CALLMONITOR 
a080			;	endif 
a080			; 
a080			;	pop bc 
a080			;	pop de 
a080			;	pop hl 
a080			;;	FORTH_RSP_POP	  
a080			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a080			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a080			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a080			; 
a080			;	if DEBUG_FORTH_WORDS 
a080			;		DMARK "EX7" 
a080			;		CALLMONITOR 
a080			;	endif 
a080			;	NEXTW 
a080			 
a080			;.STKEXEC: 
a080			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a080			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a080			; 
a080			; 
a080			;		if DEBUG_FORTH_WORDS_KEY 
a080			;			DMARK "STX" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			; 
a080			;	FORTH_DSP_VALUEHL 
a080			; 
a080			;	ld (store_tmp1), hl    ; count 
a080			; 
a080			;	FORTH_DSP_POP 
a080			;.stkexec1: 
a080			;	ld hl, (store_tmp1)   ; count 
a080			;	ld a, 0 
a080			;	cp l 
a080			;	ret z 
a080			; 
a080			;	dec hl 
a080			;	ld (store_tmp1), hl    ; count 
a080			;	 
a080			;	FORTH_DSP_VALUEHL 
a080			;	push hl 
a080			;	 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EXp" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	FORTH_DSP_POP 
a080			; 
a080			;	call strlenz 
a080			;	inc hl   ; include zero term to copy 
a080			;	inc hl   ; include zero term to copy 
a080			;	inc hl   ; include zero term to copy 
a080			;	ld b,0 
a080			;	ld c,l 
a080			;	pop hl 
a080			;	ld de, execscratch 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EX3" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	ldir 
a080			; 
a080			; 
a080			;	ld hl, execscratch 
a080			; 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EXP" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			; 
a080			;	call forthparse 
a080			;	ld hl, execscratch 
a080			;		if DEBUG_FORTH_WORDS 
a080			;			DMARK "EXx" 
a080			;			CALLMONITOR 
a080			;		endif 
a080			;	call forthexec 
a080			; 
a080			;	jp .stkexec1 
a080			; 
a080			;	ret 
a080			 
a080			 
a080			.DUP: 
a080				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a080 17				db WORD_SYS_CORE+OPCODE_DUP             
a081 f6 a0			dw .ZDUP            
a083 04				db 3 + 1 
a084 .. 00			db "DUP",0              
a088				endm 
# End of macro CWHEAD
a088			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a088			 
a088					if DEBUG_FORTH_WORDS_KEY 
a088						DMARK "DUP" 
a088 f5				push af  
a089 3a 9d a0			ld a, (.dmark)  
a08c 32 6b ee			ld (debug_mark),a  
a08f 3a 9e a0			ld a, (.dmark+1)  
a092 32 6c ee			ld (debug_mark+1),a  
a095 3a 9f a0			ld a, (.dmark+2)  
a098 32 6d ee			ld (debug_mark+2),a  
a09b 18 03			jr .pastdmark  
a09d ..			.dmark: db "DUP"  
a0a0 f1			.pastdmark: pop af  
a0a1			endm  
# End of macro DMARK
a0a1						CALLMONITOR 
a0a1 cd 6f ee			call debug_vector  
a0a4				endm  
# End of macro CALLMONITOR
a0a4					endif 
a0a4			 
a0a4					FORTH_DSP 
a0a4 cd f9 9c			call macro_forth_dsp 
a0a7				endm 
# End of macro FORTH_DSP
a0a7			 
a0a7 7e					ld a, (HL) 
a0a8 fe 01				cp DS_TYPE_STR 
a0aa 20 25				jr nz, .dupinum 
a0ac			 
a0ac					; push another string 
a0ac			 
a0ac					FORTH_DSP_VALUEHL     		 
a0ac cd 33 9d			call macro_dsp_valuehl 
a0af				endm 
# End of macro FORTH_DSP_VALUEHL
a0af			 
a0af				if DEBUG_FORTH_WORDS 
a0af					DMARK "DUs" 
a0af f5				push af  
a0b0 3a c4 a0			ld a, (.dmark)  
a0b3 32 6b ee			ld (debug_mark),a  
a0b6 3a c5 a0			ld a, (.dmark+1)  
a0b9 32 6c ee			ld (debug_mark+1),a  
a0bc 3a c6 a0			ld a, (.dmark+2)  
a0bf 32 6d ee			ld (debug_mark+2),a  
a0c2 18 03			jr .pastdmark  
a0c4 ..			.dmark: db "DUs"  
a0c7 f1			.pastdmark: pop af  
a0c8			endm  
# End of macro DMARK
a0c8					CALLMONITOR 
a0c8 cd 6f ee			call debug_vector  
a0cb				endm  
# End of macro CALLMONITOR
a0cb				endif 
a0cb cd aa 9b				call forth_push_str 
a0ce			 
a0ce					NEXTW 
a0ce c3 e9 9e			jp macro_next 
a0d1				endm 
# End of macro NEXTW
a0d1			 
a0d1			 
a0d1			.dupinum: 
a0d1					 
a0d1			 
a0d1			 
a0d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0d1 cd 33 9d			call macro_dsp_valuehl 
a0d4				endm 
# End of macro FORTH_DSP_VALUEHL
a0d4			 
a0d4				; TODO add floating point number detection 
a0d4			 
a0d4				if DEBUG_FORTH_WORDS 
a0d4					DMARK "DUi" 
a0d4 f5				push af  
a0d5 3a e9 a0			ld a, (.dmark)  
a0d8 32 6b ee			ld (debug_mark),a  
a0db 3a ea a0			ld a, (.dmark+1)  
a0de 32 6c ee			ld (debug_mark+1),a  
a0e1 3a eb a0			ld a, (.dmark+2)  
a0e4 32 6d ee			ld (debug_mark+2),a  
a0e7 18 03			jr .pastdmark  
a0e9 ..			.dmark: db "DUi"  
a0ec f1			.pastdmark: pop af  
a0ed			endm  
# End of macro DMARK
a0ed					CALLMONITOR 
a0ed cd 6f ee			call debug_vector  
a0f0				endm  
# End of macro CALLMONITOR
a0f0				endif 
a0f0			 
a0f0 cd 3c 9b				call forth_push_numhl 
a0f3					NEXTW 
a0f3 c3 e9 9e			jp macro_next 
a0f6				endm 
# End of macro NEXTW
a0f6			.ZDUP: 
a0f6				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a0f6 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0f7 2e a1			dw .SWAP            
a0f9 05				db 4 + 1 
a0fa .. 00			db "?DUP",0              
a0ff				endm 
# End of macro CWHEAD
a0ff			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a0ff			 
a0ff					if DEBUG_FORTH_WORDS_KEY 
a0ff						DMARK "qDU" 
a0ff f5				push af  
a100 3a 14 a1			ld a, (.dmark)  
a103 32 6b ee			ld (debug_mark),a  
a106 3a 15 a1			ld a, (.dmark+1)  
a109 32 6c ee			ld (debug_mark+1),a  
a10c 3a 16 a1			ld a, (.dmark+2)  
a10f 32 6d ee			ld (debug_mark+2),a  
a112 18 03			jr .pastdmark  
a114 ..			.dmark: db "qDU"  
a117 f1			.pastdmark: pop af  
a118			endm  
# End of macro DMARK
a118						CALLMONITOR 
a118 cd 6f ee			call debug_vector  
a11b				endm  
# End of macro CALLMONITOR
a11b					endif 
a11b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a11b cd 33 9d			call macro_dsp_valuehl 
a11e				endm 
# End of macro FORTH_DSP_VALUEHL
a11e			 
a11e e5					push hl 
a11f			 
a11f					; is it a zero? 
a11f			 
a11f 3e 00				ld a, 0 
a121 84					add h 
a122 85					add l 
a123			 
a123 e1					pop hl 
a124			 
a124 fe 00				cp 0 
a126 28 03				jr z, .dup2orig 
a128			 
a128			 
a128 cd 3c 9b				call forth_push_numhl 
a12b			 
a12b			 
a12b				; TODO add floating point number detection 
a12b			 
a12b			.dup2orig: 
a12b			 
a12b					NEXTW 
a12b c3 e9 9e			jp macro_next 
a12e				endm 
# End of macro NEXTW
a12e			.SWAP: 
a12e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a12e 18				db WORD_SYS_CORE+OPCODE_SWAP             
a12f 6d a1			dw .COLN            
a131 05				db 4 + 1 
a132 .. 00			db "SWAP",0              
a137				endm 
# End of macro CWHEAD
a137			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a137					if DEBUG_FORTH_WORDS_KEY 
a137						DMARK "SWP" 
a137 f5				push af  
a138 3a 4c a1			ld a, (.dmark)  
a13b 32 6b ee			ld (debug_mark),a  
a13e 3a 4d a1			ld a, (.dmark+1)  
a141 32 6c ee			ld (debug_mark+1),a  
a144 3a 4e a1			ld a, (.dmark+2)  
a147 32 6d ee			ld (debug_mark+2),a  
a14a 18 03			jr .pastdmark  
a14c ..			.dmark: db "SWP"  
a14f f1			.pastdmark: pop af  
a150			endm  
# End of macro DMARK
a150						CALLMONITOR 
a150 cd 6f ee			call debug_vector  
a153				endm  
# End of macro CALLMONITOR
a153					endif 
a153			 
a153					FORTH_DSP_VALUEHL 
a153 cd 33 9d			call macro_dsp_valuehl 
a156				endm 
# End of macro FORTH_DSP_VALUEHL
a156 e5					push hl     ; w2 
a157			 
a157					FORTH_DSP_POP 
a157 cd eb 9d			call macro_forth_dsp_pop 
a15a				endm 
# End of macro FORTH_DSP_POP
a15a			 
a15a					FORTH_DSP_VALUEHL 
a15a cd 33 9d			call macro_dsp_valuehl 
a15d				endm 
# End of macro FORTH_DSP_VALUEHL
a15d			 
a15d					FORTH_DSP_POP 
a15d cd eb 9d			call macro_forth_dsp_pop 
a160				endm 
# End of macro FORTH_DSP_POP
a160			 
a160 d1					pop de     ; w2	, hl = w1 
a161			 
a161 eb					ex de, hl 
a162 d5					push de 
a163			 
a163 cd 3c 9b				call forth_push_numhl 
a166			 
a166 e1					pop hl 
a167			 
a167 cd 3c 9b				call forth_push_numhl 
a16a					 
a16a			 
a16a					NEXTW 
a16a c3 e9 9e			jp macro_next 
a16d				endm 
# End of macro NEXTW
a16d			.COLN: 
a16d				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a16d 19				db WORD_SYS_CORE+OPCODE_COLN             
a16e f9 a2			dw .SCOLN            
a170 02				db 1 + 1 
a171 .. 00			db ":",0              
a173				endm 
# End of macro CWHEAD
a173			; | : ( -- )         Create new word | DONE 
a173			 
a173					if DEBUG_FORTH_WORDS_KEY 
a173						DMARK "CLN" 
a173 f5				push af  
a174 3a 88 a1			ld a, (.dmark)  
a177 32 6b ee			ld (debug_mark),a  
a17a 3a 89 a1			ld a, (.dmark+1)  
a17d 32 6c ee			ld (debug_mark+1),a  
a180 3a 8a a1			ld a, (.dmark+2)  
a183 32 6d ee			ld (debug_mark+2),a  
a186 18 03			jr .pastdmark  
a188 ..			.dmark: db "CLN"  
a18b f1			.pastdmark: pop af  
a18c			endm  
# End of macro DMARK
a18c						CALLMONITOR 
a18c cd 6f ee			call debug_vector  
a18f				endm  
# End of macro CALLMONITOR
a18f					endif 
a18f				STACKFRAME OFF $8efe $989f 
a18f				if DEBUG_STACK_IMB 
a18f					if OFF 
a18f						exx 
a18f						ld de, $8efe 
a18f						ld a, d 
a18f						ld hl, curframe 
a18f						call hexout 
a18f						ld a, e 
a18f						ld hl, curframe+2 
a18f						call hexout 
a18f						ld hl, $8efe 
a18f						push hl 
a18f						ld hl, $989f 
a18f						push hl 
a18f						exx 
a18f					endif 
a18f				endif 
a18f			endm 
# End of macro STACKFRAME
a18f				; get parser buffer length  of new word 
a18f			 
a18f				 
a18f			 
a18f					; move tok past this to start of name defintition 
a18f					; TODO get word to define 
a18f					; TODO Move past word token 
a18f					; TODO get length of string up to the ';' 
a18f			 
a18f 2a c2 e5			ld hl, (os_tok_ptr) 
a192 23				inc hl 
a193 23				inc hl 
a194			 
a194 3e 3b			ld a, ';' 
a196 cd 45 91			call strlent 
a199			 
a199 7d				ld a,l 
a19a 32 b1 e2			ld (os_new_parse_len), a 
a19d			 
a19d			 
a19d			if DEBUG_FORTH_UWORD 
a19d ed 5b c2 e5		ld de, (os_tok_ptr) 
a1a1						DMARK ":01" 
a1a1 f5				push af  
a1a2 3a b6 a1			ld a, (.dmark)  
a1a5 32 6b ee			ld (debug_mark),a  
a1a8 3a b7 a1			ld a, (.dmark+1)  
a1ab 32 6c ee			ld (debug_mark+1),a  
a1ae 3a b8 a1			ld a, (.dmark+2)  
a1b1 32 6d ee			ld (debug_mark+2),a  
a1b4 18 03			jr .pastdmark  
a1b6 ..			.dmark: db ":01"  
a1b9 f1			.pastdmark: pop af  
a1ba			endm  
# End of macro DMARK
a1ba				CALLMONITOR 
a1ba cd 6f ee			call debug_vector  
a1bd				endm  
# End of macro CALLMONITOR
a1bd			endif 
a1bd			 
a1bd			; 
a1bd			;  new word memory layout: 
a1bd			;  
a1bd			;    : adg 6666 ;  
a1bd			; 
a1bd			;    db   1     ; user defined word  
a1bd 23				inc hl    
a1be			;    dw   sysdict 
a1be 23				inc hl 
a1bf 23				inc hl 
a1c0			;    db <word len>+1 (for null) 
a1c0 23				inc hl 
a1c1			;    db .... <word> 
a1c1			; 
a1c1			 
a1c1 23				inc hl    ; some extras for the word preamble before the above 
a1c2 23				inc hl 
a1c3 23				inc hl 
a1c4 23				inc hl 
a1c5 23				inc hl 
a1c6 23				inc hl 
a1c7 23				inc hl  
a1c8 23				inc hl 
a1c9 23				inc hl 
a1ca 23				inc hl 
a1cb 23				inc hl 
a1cc 23				inc hl 
a1cd 23				inc hl 
a1ce 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1cf			;       exec word buffer 
a1cf			;	<ptr word>   
a1cf 23				inc hl 
a1d0 23				inc hl 
a1d1			;       <word list><null term> 7F final term 
a1d1			 
a1d1			 
a1d1			if DEBUG_FORTH_UWORD 
a1d1						DMARK ":02" 
a1d1 f5				push af  
a1d2 3a e6 a1			ld a, (.dmark)  
a1d5 32 6b ee			ld (debug_mark),a  
a1d8 3a e7 a1			ld a, (.dmark+1)  
a1db 32 6c ee			ld (debug_mark+1),a  
a1de 3a e8 a1			ld a, (.dmark+2)  
a1e1 32 6d ee			ld (debug_mark+2),a  
a1e4 18 03			jr .pastdmark  
a1e6 ..			.dmark: db ":02"  
a1e9 f1			.pastdmark: pop af  
a1ea			endm  
# End of macro DMARK
a1ea				CALLMONITOR 
a1ea cd 6f ee			call debug_vector  
a1ed				endm  
# End of macro CALLMONITOR
a1ed			endif 
a1ed			 
a1ed				 
a1ed					; malloc the size 
a1ed			 
a1ed cd a3 91				call malloc 
a1f0 22 b3 e2				ld (os_new_malloc), hl     ; save malloc start 
a1f3			 
a1f3			;    db   1     ; user defined word  
a1f3 3e 01				ld a, WORD_SYS_UWORD  
a1f5 77					ld (hl), a 
a1f6				 
a1f6 23				inc hl    
a1f7			;    dw   sysdict 
a1f7 11 41 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a1fa 73				ld (hl), e 
a1fb 23				inc hl 
a1fc 72				ld (hl), d 
a1fd 23				inc hl 
a1fe			 
a1fe			 
a1fe			;    Setup dict word 
a1fe			 
a1fe 23				inc hl 
a1ff 22 ad e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a202			 
a202				; 1. get length of dict word 
a202			 
a202			 
a202 2a c2 e5			ld hl, (os_tok_ptr) 
a205 23				inc hl 
a206 23				inc hl    ; position to start of dict word 
a207 3e 00			ld a, 0 
a209 cd 45 91			call strlent 
a20c			 
a20c			 
a20c 23				inc hl    ; to include null??? 
a20d			 
a20d				; write length of dict word 
a20d			 
a20d ed 5b ad e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a211 1b				dec de 
a212 eb				ex de, hl 
a213 73				ld (hl), e 
a214 eb				ex de, hl 
a215			 
a215				 
a215			 
a215				; copy  
a215 4d				ld c, l 
a216 06 00			ld b, 0 
a218 ed 5b ad e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a21c 2a c2 e5			ld hl, (os_tok_ptr) 
a21f 23				inc hl 
a220 23				inc hl    ; position to start of dict word 
a221				 
a221			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a221				 
a221				; TODO need to convert word to upper case 
a221			 
a221			ucasetok:	 
a221 7e				ld a,(hl) 
a222 cd 31 91			call toUpper 
a225 77				ld (hl),a 
a226 ed a0			ldi 
a228 f2 21 a2		 	jp p, ucasetok 
a22b			 
a22b			 
a22b			 
a22b				; de now points to start of where the word body code should be placed 
a22b ed 53 ad e2		ld (os_new_work_ptr), de 
a22f				; hl now points to the words to throw at forthexec which needs to be copied 
a22f 22 ab e2			ld (os_new_src_ptr), hl 
a232			 
a232				; TODO add 'call to forthexec' 
a232			 
a232			if DEBUG_FORTH_UWORD 
a232 c5				push bc 
a233 ed 4b b3 e2		ld bc, (os_new_malloc) 
a237						DMARK ":0x" 
a237 f5				push af  
a238 3a 4c a2			ld a, (.dmark)  
a23b 32 6b ee			ld (debug_mark),a  
a23e 3a 4d a2			ld a, (.dmark+1)  
a241 32 6c ee			ld (debug_mark+1),a  
a244 3a 4e a2			ld a, (.dmark+2)  
a247 32 6d ee			ld (debug_mark+2),a  
a24a 18 03			jr .pastdmark  
a24c ..			.dmark: db ":0x"  
a24f f1			.pastdmark: pop af  
a250			endm  
# End of macro DMARK
a250				CALLMONITOR 
a250 cd 6f ee			call debug_vector  
a253				endm  
# End of macro CALLMONITOR
a253 c1				pop bc 
a254			endif 
a254			 
a254			 
a254				; create word preamble which should be: 
a254			 
a254			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a254			 
a254				;    ld hl, <word code> 
a254				;    jp user_exec 
a254			        ;    <word code bytes> 
a254			 
a254			 
a254			;	inc de     ; TODO ??? or are we already past the word's null 
a254 eb				ex de, hl 
a255			 
a255 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a257			 
a257 23				inc hl 
a258 22 a7 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a25b 23				inc hl 
a25c			 
a25c 23				inc hl 
a25d 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a25f			 
a25f 01 56 cb			ld bc, user_exec 
a262 23				inc hl 
a263 71				ld (hl), c     ; poke address of user_exec 
a264 23				inc hl 
a265 70				ld (hl), b     
a266			 ; 
a266			;	inc hl 
a266			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a266			; 
a266			; 
a266			;	ld bc, macro_forth_rsp_next 
a266			;	inc hl 
a266			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a266			;	inc hl 
a266			;	ld (hl), b     
a266			 ; 
a266			;	inc hl 
a266			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a266			; 
a266			; 
a266			;	inc hl 
a266			;	ld bc, forthexec 
a266			;	ld (hl), c     ; poke address of forthexec 
a266			;	inc hl 
a266			;	ld (hl), b      
a266			; 
a266			;	inc hl 
a266			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a266			; 
a266			;	ld bc, user_dict_next 
a266			;	inc hl 
a266			;	ld (hl), c     ; poke address of forthexec 
a266			;	inc hl 
a266			;	ld (hl), b      
a266			 
a266				; hl is now where we need to copy the word byte data to save this 
a266			 
a266 23				inc hl 
a267 22 a9 e2			ld (os_new_exec), hl 
a26a				 
a26a				; copy definition 
a26a			 
a26a eb				ex de, hl 
a26b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a26b			;	inc de    ; skip the PC for this parse 
a26b 3a b1 e2			ld a, (os_new_parse_len) 
a26e 4f				ld c, a 
a26f 06 00			ld b, 0 
a271 ed b0			ldir		 ; copy defintion 
a273			 
a273			 
a273				; poke the address of where the new word bytes live for forthexec 
a273			 
a273 2a a7 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a276			 
a276 ed 5b a9 e2		ld de, (os_new_exec)      
a27a				 
a27a 73				ld (hl), e 
a27b 23				inc hl 
a27c 72				ld (hl), d 
a27d			 
a27d					; TODO copy last user dict word next link to this word 
a27d					; TODO update last user dict word to point to this word 
a27d			; 
a27d			; hl f923 de 812a ; bc 811a 
a27d			 
a27d			if DEBUG_FORTH_UWORD 
a27d c5				push bc 
a27e ed 4b b3 e2		ld bc, (os_new_malloc) 
a282						DMARK ":0A" 
a282 f5				push af  
a283 3a 97 a2			ld a, (.dmark)  
a286 32 6b ee			ld (debug_mark),a  
a289 3a 98 a2			ld a, (.dmark+1)  
a28c 32 6c ee			ld (debug_mark+1),a  
a28f 3a 99 a2			ld a, (.dmark+2)  
a292 32 6d ee			ld (debug_mark+2),a  
a295 18 03			jr .pastdmark  
a297 ..			.dmark: db ":0A"  
a29a f1			.pastdmark: pop af  
a29b			endm  
# End of macro DMARK
a29b				CALLMONITOR 
a29b cd 6f ee			call debug_vector  
a29e				endm  
# End of macro CALLMONITOR
a29e c1				pop bc 
a29f			endif 
a29f			if DEBUG_FORTH_UWORD 
a29f c5				push bc 
a2a0 ed 4b b3 e2		ld bc, (os_new_malloc) 
a2a4 03				inc bc 
a2a5 03				inc bc 
a2a6 03				inc bc 
a2a7 03				inc bc 
a2a8 03				inc bc 
a2a9 03				inc bc 
a2aa 03				inc bc 
a2ab 03				inc bc 
a2ac			 
a2ac						DMARK ":0B" 
a2ac f5				push af  
a2ad 3a c1 a2			ld a, (.dmark)  
a2b0 32 6b ee			ld (debug_mark),a  
a2b3 3a c2 a2			ld a, (.dmark+1)  
a2b6 32 6c ee			ld (debug_mark+1),a  
a2b9 3a c3 a2			ld a, (.dmark+2)  
a2bc 32 6d ee			ld (debug_mark+2),a  
a2bf 18 03			jr .pastdmark  
a2c1 ..			.dmark: db ":0B"  
a2c4 f1			.pastdmark: pop af  
a2c5			endm  
# End of macro DMARK
a2c5				CALLMONITOR 
a2c5 cd 6f ee			call debug_vector  
a2c8				endm  
# End of macro CALLMONITOR
a2c8 c1				pop bc 
a2c9			endif 
a2c9			 
a2c9			; update word dict linked list for new word 
a2c9			 
a2c9			 
a2c9 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2cc 23			inc hl     ; move to next work linked list ptr 
a2cd			 
a2cd ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a2d1 73			ld (hl), e 
a2d2 23			inc hl 
a2d3 72			ld (hl), d 
a2d4			 
a2d4			if DEBUG_FORTH_UWORD 
a2d4 ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2d8			endif 
a2d8			 
a2d8 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2dc			 
a2dc			 
a2dc			if DEBUG_FORTH_UWORD 
a2dc						DMARK ":0+" 
a2dc f5				push af  
a2dd 3a f1 a2			ld a, (.dmark)  
a2e0 32 6b ee			ld (debug_mark),a  
a2e3 3a f2 a2			ld a, (.dmark+1)  
a2e6 32 6c ee			ld (debug_mark+1),a  
a2e9 3a f3 a2			ld a, (.dmark+2)  
a2ec 32 6d ee			ld (debug_mark+2),a  
a2ef 18 03			jr .pastdmark  
a2f1 ..			.dmark: db ":0+"  
a2f4 f1			.pastdmark: pop af  
a2f5			endm  
# End of macro DMARK
a2f5				CALLMONITOR 
a2f5 cd 6f ee			call debug_vector  
a2f8				endm  
# End of macro CALLMONITOR
a2f8			endif 
a2f8			 
a2f8				STACKFRAMECHK OFF $8efe $989f 
a2f8				if DEBUG_STACK_IMB 
a2f8					if OFF 
a2f8						exx 
a2f8						ld hl, $989f 
a2f8						pop de   ; $989f 
a2f8						call cmp16 
a2f8						jr nz, .spnosame 
a2f8						ld hl, $8efe 
a2f8						pop de   ; $8efe 
a2f8						call cmp16 
a2f8						jr z, .spfrsame 
a2f8						.spnosame: call showsperror 
a2f8						.spfrsame: nop 
a2f8						exx 
a2f8					endif 
a2f8				endif 
a2f8			endm 
# End of macro STACKFRAMECHK
a2f8			 
a2f8 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2f9			 
a2f9			 
a2f9			 
a2f9			 
a2f9			;		NEXT 
a2f9			.SCOLN: 
a2f9			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2f9 06				db OPCODE_SCOLN 
a2fa 45 a3			dw .DROP 
a2fc 02				db 2 
a2fd .. 00			db ";",0           
a2ff			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2ff					if DEBUG_FORTH_WORDS_KEY 
a2ff						DMARK "SCN" 
a2ff f5				push af  
a300 3a 14 a3			ld a, (.dmark)  
a303 32 6b ee			ld (debug_mark),a  
a306 3a 15 a3			ld a, (.dmark+1)  
a309 32 6c ee			ld (debug_mark+1),a  
a30c 3a 16 a3			ld a, (.dmark+2)  
a30f 32 6d ee			ld (debug_mark+2),a  
a312 18 03			jr .pastdmark  
a314 ..			.dmark: db "SCN"  
a317 f1			.pastdmark: pop af  
a318			endm  
# End of macro DMARK
a318						CALLMONITOR 
a318 cd 6f ee			call debug_vector  
a31b				endm  
# End of macro CALLMONITOR
a31b					endif 
a31b					FORTH_RSP_TOS 
a31b cd fa 9a			call macro_forth_rsp_tos 
a31e				endm 
# End of macro FORTH_RSP_TOS
a31e e5					push hl 
a31f					FORTH_RSP_POP 
a31f cd 04 9b			call macro_forth_rsp_pop 
a322				endm 
# End of macro FORTH_RSP_POP
a322 e1					pop hl 
a323			;		ex de,hl 
a323 22 c2 e5				ld (os_tok_ptr),hl 
a326			 
a326			if DEBUG_FORTH_UWORD 
a326						DMARK "SCL" 
a326 f5				push af  
a327 3a 3b a3			ld a, (.dmark)  
a32a 32 6b ee			ld (debug_mark),a  
a32d 3a 3c a3			ld a, (.dmark+1)  
a330 32 6c ee			ld (debug_mark+1),a  
a333 3a 3d a3			ld a, (.dmark+2)  
a336 32 6d ee			ld (debug_mark+2),a  
a339 18 03			jr .pastdmark  
a33b ..			.dmark: db "SCL"  
a33e f1			.pastdmark: pop af  
a33f			endm  
# End of macro DMARK
a33f				CALLMONITOR 
a33f cd 6f ee			call debug_vector  
a342				endm  
# End of macro CALLMONITOR
a342			endif 
a342					NEXTW 
a342 c3 e9 9e			jp macro_next 
a345				endm 
# End of macro NEXTW
a345			 
a345			.DROP: 
a345				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a345 1b				db WORD_SYS_CORE+OPCODE_DROP             
a346 70 a3			dw .DUP2            
a348 05				db 4 + 1 
a349 .. 00			db "DROP",0              
a34e				endm 
# End of macro CWHEAD
a34e			; | DROP ( w -- )   drop the TOS item   | DONE 
a34e					if DEBUG_FORTH_WORDS_KEY 
a34e						DMARK "DRP" 
a34e f5				push af  
a34f 3a 63 a3			ld a, (.dmark)  
a352 32 6b ee			ld (debug_mark),a  
a355 3a 64 a3			ld a, (.dmark+1)  
a358 32 6c ee			ld (debug_mark+1),a  
a35b 3a 65 a3			ld a, (.dmark+2)  
a35e 32 6d ee			ld (debug_mark+2),a  
a361 18 03			jr .pastdmark  
a363 ..			.dmark: db "DRP"  
a366 f1			.pastdmark: pop af  
a367			endm  
# End of macro DMARK
a367						CALLMONITOR 
a367 cd 6f ee			call debug_vector  
a36a				endm  
# End of macro CALLMONITOR
a36a					endif 
a36a					FORTH_DSP_POP 
a36a cd eb 9d			call macro_forth_dsp_pop 
a36d				endm 
# End of macro FORTH_DSP_POP
a36d					NEXTW 
a36d c3 e9 9e			jp macro_next 
a370				endm 
# End of macro NEXTW
a370			.DUP2: 
a370				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a370 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a371 b5 a3			dw .DROP2            
a373 05				db 4 + 1 
a374 .. 00			db "2DUP",0              
a379				endm 
# End of macro CWHEAD
a379			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a379					if DEBUG_FORTH_WORDS_KEY 
a379						DMARK "2DU" 
a379 f5				push af  
a37a 3a 8e a3			ld a, (.dmark)  
a37d 32 6b ee			ld (debug_mark),a  
a380 3a 8f a3			ld a, (.dmark+1)  
a383 32 6c ee			ld (debug_mark+1),a  
a386 3a 90 a3			ld a, (.dmark+2)  
a389 32 6d ee			ld (debug_mark+2),a  
a38c 18 03			jr .pastdmark  
a38e ..			.dmark: db "2DU"  
a391 f1			.pastdmark: pop af  
a392			endm  
# End of macro DMARK
a392						CALLMONITOR 
a392 cd 6f ee			call debug_vector  
a395				endm  
# End of macro CALLMONITOR
a395					endif 
a395					FORTH_DSP_VALUEHL 
a395 cd 33 9d			call macro_dsp_valuehl 
a398				endm 
# End of macro FORTH_DSP_VALUEHL
a398 e5					push hl      ; 2 
a399			 
a399					FORTH_DSP_POP 
a399 cd eb 9d			call macro_forth_dsp_pop 
a39c				endm 
# End of macro FORTH_DSP_POP
a39c					 
a39c					FORTH_DSP_VALUEHL 
a39c cd 33 9d			call macro_dsp_valuehl 
a39f				endm 
# End of macro FORTH_DSP_VALUEHL
a39f			;		push hl      ; 1 
a39f			 
a39f					FORTH_DSP_POP 
a39f cd eb 9d			call macro_forth_dsp_pop 
a3a2				endm 
# End of macro FORTH_DSP_POP
a3a2			 
a3a2			;		pop hl       ; 1 
a3a2 d1					pop de       ; 2 
a3a3			 
a3a3 cd 3c 9b				call forth_push_numhl 
a3a6 eb					ex de, hl 
a3a7 cd 3c 9b				call forth_push_numhl 
a3aa			 
a3aa					 
a3aa eb					ex de, hl 
a3ab			 
a3ab cd 3c 9b				call forth_push_numhl 
a3ae eb					ex de, hl 
a3af cd 3c 9b				call forth_push_numhl 
a3b2			 
a3b2			 
a3b2					NEXTW 
a3b2 c3 e9 9e			jp macro_next 
a3b5				endm 
# End of macro NEXTW
a3b5			.DROP2: 
a3b5				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3b5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3b6 e4 a3			dw .SWAP2            
a3b8 06				db 5 + 1 
a3b9 .. 00			db "2DROP",0              
a3bf				endm 
# End of macro CWHEAD
a3bf			; | 2DROP ( w w -- )    Double drop | DONE 
a3bf					if DEBUG_FORTH_WORDS_KEY 
a3bf						DMARK "2DR" 
a3bf f5				push af  
a3c0 3a d4 a3			ld a, (.dmark)  
a3c3 32 6b ee			ld (debug_mark),a  
a3c6 3a d5 a3			ld a, (.dmark+1)  
a3c9 32 6c ee			ld (debug_mark+1),a  
a3cc 3a d6 a3			ld a, (.dmark+2)  
a3cf 32 6d ee			ld (debug_mark+2),a  
a3d2 18 03			jr .pastdmark  
a3d4 ..			.dmark: db "2DR"  
a3d7 f1			.pastdmark: pop af  
a3d8			endm  
# End of macro DMARK
a3d8						CALLMONITOR 
a3d8 cd 6f ee			call debug_vector  
a3db				endm  
# End of macro CALLMONITOR
a3db					endif 
a3db					FORTH_DSP_POP 
a3db cd eb 9d			call macro_forth_dsp_pop 
a3de				endm 
# End of macro FORTH_DSP_POP
a3de					FORTH_DSP_POP 
a3de cd eb 9d			call macro_forth_dsp_pop 
a3e1				endm 
# End of macro FORTH_DSP_POP
a3e1					NEXTW 
a3e1 c3 e9 9e			jp macro_next 
a3e4				endm 
# End of macro NEXTW
a3e4			.SWAP2: 
a3e4				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3e4 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3e5 0d a4			dw .AT            
a3e7 06				db 5 + 1 
a3e8 .. 00			db "2SWAP",0              
a3ee				endm 
# End of macro CWHEAD
a3ee			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3ee					if DEBUG_FORTH_WORDS_KEY 
a3ee						DMARK "2SW" 
a3ee f5				push af  
a3ef 3a 03 a4			ld a, (.dmark)  
a3f2 32 6b ee			ld (debug_mark),a  
a3f5 3a 04 a4			ld a, (.dmark+1)  
a3f8 32 6c ee			ld (debug_mark+1),a  
a3fb 3a 05 a4			ld a, (.dmark+2)  
a3fe 32 6d ee			ld (debug_mark+2),a  
a401 18 03			jr .pastdmark  
a403 ..			.dmark: db "2SW"  
a406 f1			.pastdmark: pop af  
a407			endm  
# End of macro DMARK
a407						CALLMONITOR 
a407 cd 6f ee			call debug_vector  
a40a				endm  
# End of macro CALLMONITOR
a40a					endif 
a40a					NEXTW 
a40a c3 e9 9e			jp macro_next 
a40d				endm 
# End of macro NEXTW
a40d			.AT: 
a40d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a40d 1f				db WORD_SYS_CORE+OPCODE_AT             
a40e 3f a4			dw .CAT            
a410 02				db 1 + 1 
a411 .. 00			db "@",0              
a413				endm 
# End of macro CWHEAD
a413			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a413			 
a413					if DEBUG_FORTH_WORDS_KEY 
a413						DMARK "AT." 
a413 f5				push af  
a414 3a 28 a4			ld a, (.dmark)  
a417 32 6b ee			ld (debug_mark),a  
a41a 3a 29 a4			ld a, (.dmark+1)  
a41d 32 6c ee			ld (debug_mark+1),a  
a420 3a 2a a4			ld a, (.dmark+2)  
a423 32 6d ee			ld (debug_mark+2),a  
a426 18 03			jr .pastdmark  
a428 ..			.dmark: db "AT."  
a42b f1			.pastdmark: pop af  
a42c			endm  
# End of macro DMARK
a42c						CALLMONITOR 
a42c cd 6f ee			call debug_vector  
a42f				endm  
# End of macro CALLMONITOR
a42f					endif 
a42f			.getbyteat:	 
a42f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a42f cd 33 9d			call macro_dsp_valuehl 
a432				endm 
# End of macro FORTH_DSP_VALUEHL
a432					 
a432			;		push hl 
a432				 
a432					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a432 cd eb 9d			call macro_forth_dsp_pop 
a435				endm 
# End of macro FORTH_DSP_POP
a435			 
a435			;		pop hl 
a435			 
a435 7e					ld a, (hl) 
a436			 
a436 6f					ld l, a 
a437 26 00				ld h, 0 
a439 cd 3c 9b				call forth_push_numhl 
a43c			 
a43c					NEXTW 
a43c c3 e9 9e			jp macro_next 
a43f				endm 
# End of macro NEXTW
a43f			.CAT: 
a43f				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a43f 20				db WORD_SYS_CORE+OPCODE_CAT             
a440 68 a4			dw .BANG            
a442 03				db 2 + 1 
a443 .. 00			db "C@",0              
a446				endm 
# End of macro CWHEAD
a446			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a446					if DEBUG_FORTH_WORDS_KEY 
a446						DMARK "CAA" 
a446 f5				push af  
a447 3a 5b a4			ld a, (.dmark)  
a44a 32 6b ee			ld (debug_mark),a  
a44d 3a 5c a4			ld a, (.dmark+1)  
a450 32 6c ee			ld (debug_mark+1),a  
a453 3a 5d a4			ld a, (.dmark+2)  
a456 32 6d ee			ld (debug_mark+2),a  
a459 18 03			jr .pastdmark  
a45b ..			.dmark: db "CAA"  
a45e f1			.pastdmark: pop af  
a45f			endm  
# End of macro DMARK
a45f						CALLMONITOR 
a45f cd 6f ee			call debug_vector  
a462				endm  
# End of macro CALLMONITOR
a462					endif 
a462 c3 2f a4				jp .getbyteat 
a465					NEXTW 
a465 c3 e9 9e			jp macro_next 
a468				endm 
# End of macro NEXTW
a468			.BANG: 
a468				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a468 21				db WORD_SYS_CORE+OPCODE_BANG             
a469 9e a4			dw .CBANG            
a46b 02				db 1 + 1 
a46c .. 00			db "!",0              
a46e				endm 
# End of macro CWHEAD
a46e			; | ! ( x w -- ) Store x at address w      | DONE 
a46e					if DEBUG_FORTH_WORDS_KEY 
a46e						DMARK "BNG" 
a46e f5				push af  
a46f 3a 83 a4			ld a, (.dmark)  
a472 32 6b ee			ld (debug_mark),a  
a475 3a 84 a4			ld a, (.dmark+1)  
a478 32 6c ee			ld (debug_mark+1),a  
a47b 3a 85 a4			ld a, (.dmark+2)  
a47e 32 6d ee			ld (debug_mark+2),a  
a481 18 03			jr .pastdmark  
a483 ..			.dmark: db "BNG"  
a486 f1			.pastdmark: pop af  
a487			endm  
# End of macro DMARK
a487						CALLMONITOR 
a487 cd 6f ee			call debug_vector  
a48a				endm  
# End of macro CALLMONITOR
a48a					endif 
a48a			 
a48a			.storebyteat:		 
a48a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a48a cd 33 9d			call macro_dsp_valuehl 
a48d				endm 
# End of macro FORTH_DSP_VALUEHL
a48d					 
a48d e5					push hl 
a48e				 
a48e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a48e cd eb 9d			call macro_forth_dsp_pop 
a491				endm 
# End of macro FORTH_DSP_POP
a491			 
a491					; get byte to poke 
a491			 
a491					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a491 cd 33 9d			call macro_dsp_valuehl 
a494				endm 
# End of macro FORTH_DSP_VALUEHL
a494 e5					push hl 
a495			 
a495			 
a495					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a495 cd eb 9d			call macro_forth_dsp_pop 
a498				endm 
# End of macro FORTH_DSP_POP
a498			 
a498			 
a498 d1					pop de 
a499 e1					pop hl 
a49a			 
a49a 73					ld (hl),e 
a49b			 
a49b			 
a49b					NEXTW 
a49b c3 e9 9e			jp macro_next 
a49e				endm 
# End of macro NEXTW
a49e			.CBANG: 
a49e				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a49e 22				db WORD_SYS_CORE+OPCODE_CBANG             
a49f c7 a4			dw .SCALL            
a4a1 03				db 2 + 1 
a4a2 .. 00			db "C!",0              
a4a5				endm 
# End of macro CWHEAD
a4a5			; | C!  ( x w -- ) Store x at address w  | DONE 
a4a5					if DEBUG_FORTH_WORDS_KEY 
a4a5						DMARK "CBA" 
a4a5 f5				push af  
a4a6 3a ba a4			ld a, (.dmark)  
a4a9 32 6b ee			ld (debug_mark),a  
a4ac 3a bb a4			ld a, (.dmark+1)  
a4af 32 6c ee			ld (debug_mark+1),a  
a4b2 3a bc a4			ld a, (.dmark+2)  
a4b5 32 6d ee			ld (debug_mark+2),a  
a4b8 18 03			jr .pastdmark  
a4ba ..			.dmark: db "CBA"  
a4bd f1			.pastdmark: pop af  
a4be			endm  
# End of macro DMARK
a4be						CALLMONITOR 
a4be cd 6f ee			call debug_vector  
a4c1				endm  
# End of macro CALLMONITOR
a4c1					endif 
a4c1 c3 8a a4				jp .storebyteat 
a4c4					NEXTW 
a4c4 c3 e9 9e			jp macro_next 
a4c7				endm 
# End of macro NEXTW
a4c7			.SCALL: 
a4c7				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4c7 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4c8 fb a4			dw .DEPTH            
a4ca 05				db 4 + 1 
a4cb .. 00			db "CALL",0              
a4d0				endm 
# End of macro CWHEAD
a4d0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4d0					if DEBUG_FORTH_WORDS_KEY 
a4d0						DMARK "CLL" 
a4d0 f5				push af  
a4d1 3a e5 a4			ld a, (.dmark)  
a4d4 32 6b ee			ld (debug_mark),a  
a4d7 3a e6 a4			ld a, (.dmark+1)  
a4da 32 6c ee			ld (debug_mark+1),a  
a4dd 3a e7 a4			ld a, (.dmark+2)  
a4e0 32 6d ee			ld (debug_mark+2),a  
a4e3 18 03			jr .pastdmark  
a4e5 ..			.dmark: db "CLL"  
a4e8 f1			.pastdmark: pop af  
a4e9			endm  
# End of macro DMARK
a4e9						CALLMONITOR 
a4e9 cd 6f ee			call debug_vector  
a4ec				endm  
# End of macro CALLMONITOR
a4ec					endif 
a4ec			 
a4ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4ec cd 33 9d			call macro_dsp_valuehl 
a4ef				endm 
# End of macro FORTH_DSP_VALUEHL
a4ef			 
a4ef			;		push hl 
a4ef			 
a4ef					; destroy value TOS 
a4ef			 
a4ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ef cd eb 9d			call macro_forth_dsp_pop 
a4f2				endm 
# End of macro FORTH_DSP_POP
a4f2			 
a4f2						 
a4f2			;		pop hl 
a4f2			 
a4f2					; how to do a call with hl???? save SP? 
a4f2 cd 8d 9e				call forth_call_hl 
a4f5			 
a4f5			 
a4f5					; TODO push value back onto stack for another op etc 
a4f5			 
a4f5 cd 3c 9b				call forth_push_numhl 
a4f8					NEXTW 
a4f8 c3 e9 9e			jp macro_next 
a4fb				endm 
# End of macro NEXTW
a4fb			.DEPTH: 
a4fb				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4fb 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4fc 38 a5			dw .OVER            
a4fe 06				db 5 + 1 
a4ff .. 00			db "DEPTH",0              
a505				endm 
# End of macro CWHEAD
a505			; | DEPTH ( -- u ) Push count of stack | DONE 
a505					; take current TOS and remove from base value div by two to get count 
a505					if DEBUG_FORTH_WORDS_KEY 
a505						DMARK "DEP" 
a505 f5				push af  
a506 3a 1a a5			ld a, (.dmark)  
a509 32 6b ee			ld (debug_mark),a  
a50c 3a 1b a5			ld a, (.dmark+1)  
a50f 32 6c ee			ld (debug_mark+1),a  
a512 3a 1c a5			ld a, (.dmark+2)  
a515 32 6d ee			ld (debug_mark+2),a  
a518 18 03			jr .pastdmark  
a51a ..			.dmark: db "DEP"  
a51d f1			.pastdmark: pop af  
a51e			endm  
# End of macro DMARK
a51e						CALLMONITOR 
a51e cd 6f ee			call debug_vector  
a521				endm  
# End of macro CALLMONITOR
a521					endif 
a521			 
a521			 
a521 2a ee e9			ld hl, (cli_data_sp) 
a524 11 28 e8			ld de, cli_data_stack 
a527 ed 52			sbc hl,de 
a529				 
a529				; div by size of stack item 
a529			 
a529 5d				ld e,l 
a52a 0e 03			ld c, 3 
a52c cd 6c 8c			call Div8 
a52f			 
a52f 6f				ld l,a 
a530 26 00			ld h,0 
a532			 
a532				;srl h 
a532				;rr l 
a532			 
a532 cd 3c 9b				call forth_push_numhl 
a535					NEXTW 
a535 c3 e9 9e			jp macro_next 
a538				endm 
# End of macro NEXTW
a538			.OVER: 
a538				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a538 42				db WORD_SYS_CORE+46             
a539 7f a5			dw .PAUSE            
a53b 05				db 4 + 1 
a53c .. 00			db "OVER",0              
a541				endm 
# End of macro CWHEAD
a541			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a541					if DEBUG_FORTH_WORDS_KEY 
a541						DMARK "OVR" 
a541 f5				push af  
a542 3a 56 a5			ld a, (.dmark)  
a545 32 6b ee			ld (debug_mark),a  
a548 3a 57 a5			ld a, (.dmark+1)  
a54b 32 6c ee			ld (debug_mark+1),a  
a54e 3a 58 a5			ld a, (.dmark+2)  
a551 32 6d ee			ld (debug_mark+2),a  
a554 18 03			jr .pastdmark  
a556 ..			.dmark: db "OVR"  
a559 f1			.pastdmark: pop af  
a55a			endm  
# End of macro DMARK
a55a						CALLMONITOR 
a55a cd 6f ee			call debug_vector  
a55d				endm  
# End of macro CALLMONITOR
a55d					endif 
a55d			 
a55d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a55d cd 33 9d			call macro_dsp_valuehl 
a560				endm 
# End of macro FORTH_DSP_VALUEHL
a560 e5					push hl    ; n2 
a561					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a561 cd eb 9d			call macro_forth_dsp_pop 
a564				endm 
# End of macro FORTH_DSP_POP
a564			 
a564					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a564 cd 33 9d			call macro_dsp_valuehl 
a567				endm 
# End of macro FORTH_DSP_VALUEHL
a567 e5					push hl    ; n1 
a568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a568 cd eb 9d			call macro_forth_dsp_pop 
a56b				endm 
# End of macro FORTH_DSP_POP
a56b			 
a56b d1					pop de     ; n1 
a56c e1					pop hl     ; n2 
a56d			 
a56d d5					push de 
a56e e5					push hl 
a56f d5					push de 
a570			 
a570					; push back  
a570			 
a570 e1					pop hl 
a571 cd 3c 9b				call forth_push_numhl 
a574 e1					pop hl 
a575 cd 3c 9b				call forth_push_numhl 
a578 e1					pop hl 
a579 cd 3c 9b				call forth_push_numhl 
a57c					NEXTW 
a57c c3 e9 9e			jp macro_next 
a57f				endm 
# End of macro NEXTW
a57f			 
a57f			.PAUSE: 
a57f				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a57f 43				db WORD_SYS_CORE+47             
a580 b4 a5			dw .PAUSES            
a582 08				db 7 + 1 
a583 .. 00			db "PAUSEMS",0              
a58b				endm 
# End of macro CWHEAD
a58b			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a58b					if DEBUG_FORTH_WORDS_KEY 
a58b						DMARK "PMS" 
a58b f5				push af  
a58c 3a a0 a5			ld a, (.dmark)  
a58f 32 6b ee			ld (debug_mark),a  
a592 3a a1 a5			ld a, (.dmark+1)  
a595 32 6c ee			ld (debug_mark+1),a  
a598 3a a2 a5			ld a, (.dmark+2)  
a59b 32 6d ee			ld (debug_mark+2),a  
a59e 18 03			jr .pastdmark  
a5a0 ..			.dmark: db "PMS"  
a5a3 f1			.pastdmark: pop af  
a5a4			endm  
# End of macro DMARK
a5a4						CALLMONITOR 
a5a4 cd 6f ee			call debug_vector  
a5a7				endm  
# End of macro CALLMONITOR
a5a7					endif 
a5a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a7 cd 33 9d			call macro_dsp_valuehl 
a5aa				endm 
# End of macro FORTH_DSP_VALUEHL
a5aa			;		push hl    ; n2 
a5aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5aa cd eb 9d			call macro_forth_dsp_pop 
a5ad				endm 
# End of macro FORTH_DSP_POP
a5ad			;		pop hl 
a5ad			 
a5ad 7d					ld a, l 
a5ae cd d7 89				call aDelayInMS 
a5b1				       NEXTW 
a5b1 c3 e9 9e			jp macro_next 
a5b4				endm 
# End of macro NEXTW
a5b4			.PAUSES:  
a5b4				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5b4 44				db WORD_SYS_CORE+48             
a5b5 23 a6			dw .ROT            
a5b7 06				db 5 + 1 
a5b8 .. 00			db "PAUSE",0              
a5be				endm 
# End of macro CWHEAD
a5be			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5be					if DEBUG_FORTH_WORDS_KEY 
a5be						DMARK "PAU" 
a5be f5				push af  
a5bf 3a d3 a5			ld a, (.dmark)  
a5c2 32 6b ee			ld (debug_mark),a  
a5c5 3a d4 a5			ld a, (.dmark+1)  
a5c8 32 6c ee			ld (debug_mark+1),a  
a5cb 3a d5 a5			ld a, (.dmark+2)  
a5ce 32 6d ee			ld (debug_mark+2),a  
a5d1 18 03			jr .pastdmark  
a5d3 ..			.dmark: db "PAU"  
a5d6 f1			.pastdmark: pop af  
a5d7			endm  
# End of macro DMARK
a5d7						CALLMONITOR 
a5d7 cd 6f ee			call debug_vector  
a5da				endm  
# End of macro CALLMONITOR
a5da					endif 
a5da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5da cd 33 9d			call macro_dsp_valuehl 
a5dd				endm 
# End of macro FORTH_DSP_VALUEHL
a5dd			;		push hl    ; n2 
a5dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5dd cd eb 9d			call macro_forth_dsp_pop 
a5e0				endm 
# End of macro FORTH_DSP_POP
a5e0			;		pop hl 
a5e0 45					ld b, l 
a5e1					if DEBUG_FORTH_WORDS 
a5e1						DMARK "PAU" 
a5e1 f5				push af  
a5e2 3a f6 a5			ld a, (.dmark)  
a5e5 32 6b ee			ld (debug_mark),a  
a5e8 3a f7 a5			ld a, (.dmark+1)  
a5eb 32 6c ee			ld (debug_mark+1),a  
a5ee 3a f8 a5			ld a, (.dmark+2)  
a5f1 32 6d ee			ld (debug_mark+2),a  
a5f4 18 03			jr .pastdmark  
a5f6 ..			.dmark: db "PAU"  
a5f9 f1			.pastdmark: pop af  
a5fa			endm  
# End of macro DMARK
a5fa						CALLMONITOR 
a5fa cd 6f ee			call debug_vector  
a5fd				endm  
# End of macro CALLMONITOR
a5fd					endif 
a5fd c5			.pauses1:	push bc 
a5fe cd f2 89				call delay1s 
a601 c1					pop bc 
a602					if DEBUG_FORTH_WORDS 
a602						DMARK "PA1" 
a602 f5				push af  
a603 3a 17 a6			ld a, (.dmark)  
a606 32 6b ee			ld (debug_mark),a  
a609 3a 18 a6			ld a, (.dmark+1)  
a60c 32 6c ee			ld (debug_mark+1),a  
a60f 3a 19 a6			ld a, (.dmark+2)  
a612 32 6d ee			ld (debug_mark+2),a  
a615 18 03			jr .pastdmark  
a617 ..			.dmark: db "PA1"  
a61a f1			.pastdmark: pop af  
a61b			endm  
# End of macro DMARK
a61b						CALLMONITOR 
a61b cd 6f ee			call debug_vector  
a61e				endm  
# End of macro CALLMONITOR
a61e					endif 
a61e 10 dd				djnz .pauses1 
a620			 
a620				       NEXTW 
a620 c3 e9 9e			jp macro_next 
a623				endm 
# End of macro NEXTW
a623			.ROT: 
a623				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a623 45				db WORD_SYS_CORE+49             
a624 71 a6			dw .UWORDS            
a626 04				db 3 + 1 
a627 .. 00			db "ROT",0              
a62b				endm 
# End of macro CWHEAD
a62b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a62b					if DEBUG_FORTH_WORDS_KEY 
a62b						DMARK "ROT" 
a62b f5				push af  
a62c 3a 40 a6			ld a, (.dmark)  
a62f 32 6b ee			ld (debug_mark),a  
a632 3a 41 a6			ld a, (.dmark+1)  
a635 32 6c ee			ld (debug_mark+1),a  
a638 3a 42 a6			ld a, (.dmark+2)  
a63b 32 6d ee			ld (debug_mark+2),a  
a63e 18 03			jr .pastdmark  
a640 ..			.dmark: db "ROT"  
a643 f1			.pastdmark: pop af  
a644			endm  
# End of macro DMARK
a644						CALLMONITOR 
a644 cd 6f ee			call debug_vector  
a647				endm  
# End of macro CALLMONITOR
a647					endif 
a647			 
a647					FORTH_DSP_VALUEHL 
a647 cd 33 9d			call macro_dsp_valuehl 
a64a				endm 
# End of macro FORTH_DSP_VALUEHL
a64a e5					push hl    ; u3  
a64b			 
a64b					FORTH_DSP_POP 
a64b cd eb 9d			call macro_forth_dsp_pop 
a64e				endm 
# End of macro FORTH_DSP_POP
a64e			   
a64e					FORTH_DSP_VALUEHL 
a64e cd 33 9d			call macro_dsp_valuehl 
a651				endm 
# End of macro FORTH_DSP_VALUEHL
a651 e5					push hl     ; u2 
a652			 
a652					FORTH_DSP_POP 
a652 cd eb 9d			call macro_forth_dsp_pop 
a655				endm 
# End of macro FORTH_DSP_POP
a655			 
a655					FORTH_DSP_VALUEHL 
a655 cd 33 9d			call macro_dsp_valuehl 
a658				endm 
# End of macro FORTH_DSP_VALUEHL
a658 e5					push hl     ; u1 
a659			 
a659					FORTH_DSP_POP 
a659 cd eb 9d			call macro_forth_dsp_pop 
a65c				endm 
# End of macro FORTH_DSP_POP
a65c			 
a65c c1					pop bc      ; u1 
a65d e1					pop hl      ; u2 
a65e d1					pop de      ; u3 
a65f			 
a65f			 
a65f c5					push bc 
a660 d5					push de 
a661 e5					push hl 
a662			 
a662			 
a662 e1					pop hl 
a663 cd 3c 9b				call forth_push_numhl 
a666			 
a666 e1					pop hl 
a667 cd 3c 9b				call forth_push_numhl 
a66a			 
a66a e1					pop hl 
a66b cd 3c 9b				call forth_push_numhl 
a66e					 
a66e			 
a66e			 
a66e			 
a66e			 
a66e			 
a66e				       NEXTW 
a66e c3 e9 9e			jp macro_next 
a671				endm 
# End of macro NEXTW
a671			 
a671			.UWORDS: 
a671				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a671 50				db WORD_SYS_CORE+60             
a672 33 a7			dw .BP            
a674 07				db 6 + 1 
a675 .. 00			db "UWORDS",0              
a67c				endm 
# End of macro CWHEAD
a67c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a67c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a67c			; | | Following the count are the individual words. 
a67c			; | | 
a67c			; | | e.g. UWORDS 
a67c			; | | BOX DIRLIST 2 
a67c			; | |  
a67c			; | | Can be used to save the words to storage via: 
a67c			; | | UWORDS $01 DO $01 APPEND LOOP 
a67c				if DEBUG_FORTH_WORDS_KEY 
a67c					DMARK "UWR" 
a67c f5				push af  
a67d 3a 91 a6			ld a, (.dmark)  
a680 32 6b ee			ld (debug_mark),a  
a683 3a 92 a6			ld a, (.dmark+1)  
a686 32 6c ee			ld (debug_mark+1),a  
a689 3a 93 a6			ld a, (.dmark+2)  
a68c 32 6d ee			ld (debug_mark+2),a  
a68f 18 03			jr .pastdmark  
a691 ..			.dmark: db "UWR"  
a694 f1			.pastdmark: pop af  
a695			endm  
# End of macro DMARK
a695					CALLMONITOR 
a695 cd 6f ee			call debug_vector  
a698				endm  
# End of macro CALLMONITOR
a698				endif 
a698 21 2e e4				ld hl, baseram 
a69b					;ld hl, baseusermem 
a69b 01 00 00				ld bc, 0    ; start a counter 
a69e			 
a69e				; skip dict stub 
a69e			 
a69e cd 3a a0				call forth_tok_next 
a6a1			 
a6a1			 
a6a1			; while we have words to look for 
a6a1			 
a6a1 7e			.douscan:	ld a, (hl)      
a6a2				if DEBUG_FORTH_WORDS 
a6a2					DMARK "UWs" 
a6a2 f5				push af  
a6a3 3a b7 a6			ld a, (.dmark)  
a6a6 32 6b ee			ld (debug_mark),a  
a6a9 3a b8 a6			ld a, (.dmark+1)  
a6ac 32 6c ee			ld (debug_mark+1),a  
a6af 3a b9 a6			ld a, (.dmark+2)  
a6b2 32 6d ee			ld (debug_mark+2),a  
a6b5 18 03			jr .pastdmark  
a6b7 ..			.dmark: db "UWs"  
a6ba f1			.pastdmark: pop af  
a6bb			endm  
# End of macro DMARK
a6bb					CALLMONITOR 
a6bb cd 6f ee			call debug_vector  
a6be				endm  
# End of macro CALLMONITOR
a6be				endif 
a6be fe 00				cp WORD_SYS_END 
a6c0 28 4d				jr z, .udone 
a6c2 fe 01				cp WORD_SYS_UWORD 
a6c4 20 44				jr nz, .nuword 
a6c6			 
a6c6				if DEBUG_FORTH_WORDS 
a6c6					DMARK "UWu" 
a6c6 f5				push af  
a6c7 3a db a6			ld a, (.dmark)  
a6ca 32 6b ee			ld (debug_mark),a  
a6cd 3a dc a6			ld a, (.dmark+1)  
a6d0 32 6c ee			ld (debug_mark+1),a  
a6d3 3a dd a6			ld a, (.dmark+2)  
a6d6 32 6d ee			ld (debug_mark+2),a  
a6d9 18 03			jr .pastdmark  
a6db ..			.dmark: db "UWu"  
a6de f1			.pastdmark: pop af  
a6df			endm  
# End of macro DMARK
a6df					CALLMONITOR 
a6df cd 6f ee			call debug_vector  
a6e2				endm  
# End of macro CALLMONITOR
a6e2				endif 
a6e2					; we have a uword so push its name to the stack 
a6e2			 
a6e2 e5				   	push hl  ; save so we can move to next dict block 
a6e3			 
a6e3					; skip opcode 
a6e3 23					inc hl  
a6e4					; skip next ptr 
a6e4 23					inc hl  
a6e5 23					inc hl 
a6e6					; skip len 
a6e6 23					inc hl 
a6e7				if DEBUG_FORTH_WORDS 
a6e7					DMARK "UWt" 
a6e7 f5				push af  
a6e8 3a fc a6			ld a, (.dmark)  
a6eb 32 6b ee			ld (debug_mark),a  
a6ee 3a fd a6			ld a, (.dmark+1)  
a6f1 32 6c ee			ld (debug_mark+1),a  
a6f4 3a fe a6			ld a, (.dmark+2)  
a6f7 32 6d ee			ld (debug_mark+2),a  
a6fa 18 03			jr .pastdmark  
a6fc ..			.dmark: db "UWt"  
a6ff f1			.pastdmark: pop af  
a700			endm  
# End of macro DMARK
a700					CALLMONITOR 
a700 cd 6f ee			call debug_vector  
a703				endm  
# End of macro CALLMONITOR
a703				endif 
a703 03					inc bc 
a704			 
a704 c5					push bc 
a705 cd aa 9b				call forth_push_str 
a708 c1					pop bc 
a709			 
a709 e1					pop hl 	 
a70a			 
a70a cd 3a a0		.nuword:	call forth_tok_next 
a70d 18 92				jr .douscan  
a70f			 
a70f			.udone:		 ; push count of uwords found 
a70f c5					push bc 
a710 e1					pop hl 
a711			 
a711				if DEBUG_FORTH_WORDS 
a711					DMARK "UWc" 
a711 f5				push af  
a712 3a 26 a7			ld a, (.dmark)  
a715 32 6b ee			ld (debug_mark),a  
a718 3a 27 a7			ld a, (.dmark+1)  
a71b 32 6c ee			ld (debug_mark+1),a  
a71e 3a 28 a7			ld a, (.dmark+2)  
a721 32 6d ee			ld (debug_mark+2),a  
a724 18 03			jr .pastdmark  
a726 ..			.dmark: db "UWc"  
a729 f1			.pastdmark: pop af  
a72a			endm  
# End of macro DMARK
a72a					CALLMONITOR 
a72a cd 6f ee			call debug_vector  
a72d				endm  
# End of macro CALLMONITOR
a72d				endif 
a72d cd 3c 9b				call forth_push_numhl 
a730			 
a730			 
a730				       NEXTW 
a730 c3 e9 9e			jp macro_next 
a733				endm 
# End of macro NEXTW
a733			 
a733			.BP: 
a733				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a733 54				db WORD_SYS_CORE+64             
a734 6d a7			dw .MONITOR            
a736 03				db 2 + 1 
a737 .. 00			db "BP",0              
a73a				endm 
# End of macro CWHEAD
a73a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a73a			; | | $00 Will enable the break points within specific code paths 
a73a			; | | $01 Will disable break points 
a73a			; | |  
a73a			; | | By default break points are off. Either the above can be used to enable them 
a73a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a73a			; | | and on release of the pressed key a message will be disaplayed to notify 
a73a			; | | that break points are enabled. Pressing any key will then continue boot process. 
a73a					; get byte count 
a73a					if DEBUG_FORTH_WORDS_KEY 
a73a						DMARK "BP." 
a73a f5				push af  
a73b 3a 4f a7			ld a, (.dmark)  
a73e 32 6b ee			ld (debug_mark),a  
a741 3a 50 a7			ld a, (.dmark+1)  
a744 32 6c ee			ld (debug_mark+1),a  
a747 3a 51 a7			ld a, (.dmark+2)  
a74a 32 6d ee			ld (debug_mark+2),a  
a74d 18 03			jr .pastdmark  
a74f ..			.dmark: db "BP."  
a752 f1			.pastdmark: pop af  
a753			endm  
# End of macro DMARK
a753						CALLMONITOR 
a753 cd 6f ee			call debug_vector  
a756				endm  
# End of macro CALLMONITOR
a756					endif 
a756			 
a756					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a756 cd 33 9d			call macro_dsp_valuehl 
a759				endm 
# End of macro FORTH_DSP_VALUEHL
a759			 
a759			;		push hl 
a759			 
a759					; destroy value TOS 
a759			 
a759					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a759 cd eb 9d			call macro_forth_dsp_pop 
a75c				endm 
# End of macro FORTH_DSP_POP
a75c			 
a75c			;		pop hl 
a75c			 
a75c 3e 00				ld a,0 
a75e bd					cp l 
a75f 28 06				jr z, .bpset 
a761			;		ld a, '*' 
a761 cd de 94				call bp_off 
a764					NEXTW 
a764 c3 e9 9e			jp macro_next 
a767				endm 
# End of macro NEXTW
a767			 
a767			.bpset:	 
a767					;	ld (os_view_disable), a 
a767 cd d2 94				call bp_on 
a76a			 
a76a			 
a76a					NEXTW 
a76a c3 e9 9e			jp macro_next 
a76d				endm 
# End of macro NEXTW
a76d			 
a76d			 
a76d			.MONITOR: 
a76d				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a76d 55				db WORD_SYS_CORE+65             
a76e 9e a7			dw .MALLOC            
a770 08				db 7 + 1 
a771 .. 00			db "MONITOR",0              
a779				endm 
# End of macro CWHEAD
a779			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a779			; | | At start the current various registers will be displayed with contents. 
a779			; | | Top right corner will show the most recent debug marker seen. 
a779			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a779			; | | and the return stack pointer (RSP). 
a779			; | | Pressing: 
a779			; | |    1 - Initial screen 
a779			; | |    2 - Display a data dump of HL 
a779			; | |    3 - Display a data dump of DE 
a779			; | |    4 - Display a data dump of BC 
a779			; | |    5 - Display a data dump of HL 
a779			; | |    6 - Display a data dump of DSP 
a779			; | |    7 - Display a data dump of RSP 
a779			; | |    8 - Display a data dump of what is at DSP 
a779			; | |    9 - Display a data dump of what is at RSP 
a779			; | |    0 - Exit monitor and continue running. This will also enable break points 
a779			; | |    * - Disable break points 
a779			; | |    # - Enter traditional monitor mode 
a779			; | | 
a779			; | | Monitor Mode 
a779			; | | ------------ 
a779			; | | A prompt of '>' will be shown for various commands: 
a779			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a779			; | |    C - Continue display a data dump from the last set address 
a779			; | |    M xxxx - Set start of memory edit at address xx 
a779			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a779			; | |    Q - Return to previous 
a779					if DEBUG_FORTH_WORDS_KEY 
a779						DMARK "MON" 
a779 f5				push af  
a77a 3a 8e a7			ld a, (.dmark)  
a77d 32 6b ee			ld (debug_mark),a  
a780 3a 8f a7			ld a, (.dmark+1)  
a783 32 6c ee			ld (debug_mark+1),a  
a786 3a 90 a7			ld a, (.dmark+2)  
a789 32 6d ee			ld (debug_mark+2),a  
a78c 18 03			jr .pastdmark  
a78e ..			.dmark: db "MON"  
a791 f1			.pastdmark: pop af  
a792			endm  
# End of macro DMARK
a792						CALLMONITOR 
a792 cd 6f ee			call debug_vector  
a795				endm  
# End of macro CALLMONITOR
a795					endif 
a795			;		ld a, 0 
a795			;		ld (os_view_disable), a 
a795 cd d2 94				call bp_on 
a798			 
a798					CALLMONITOR 
a798 cd 6f ee			call debug_vector  
a79b				endm  
# End of macro CALLMONITOR
a79b			 
a79b			;	call monitor 
a79b			 
a79b					NEXTW 
a79b c3 e9 9e			jp macro_next 
a79e				endm 
# End of macro NEXTW
a79e			 
a79e			 
a79e			.MALLOC: 
a79e				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a79e 56				db WORD_SYS_CORE+66             
a79f c7 a7			dw .MALLOC2            
a7a1 06				db 5 + 1 
a7a2 .. 00			db "ALLOT",0              
a7a8				endm 
# End of macro CWHEAD
a7a8			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7a8					if DEBUG_FORTH_WORDS_KEY 
a7a8						DMARK "ALL" 
a7a8 f5				push af  
a7a9 3a bd a7			ld a, (.dmark)  
a7ac 32 6b ee			ld (debug_mark),a  
a7af 3a be a7			ld a, (.dmark+1)  
a7b2 32 6c ee			ld (debug_mark+1),a  
a7b5 3a bf a7			ld a, (.dmark+2)  
a7b8 32 6d ee			ld (debug_mark+2),a  
a7bb 18 03			jr .pastdmark  
a7bd ..			.dmark: db "ALL"  
a7c0 f1			.pastdmark: pop af  
a7c1			endm  
# End of macro DMARK
a7c1						CALLMONITOR 
a7c1 cd 6f ee			call debug_vector  
a7c4				endm  
# End of macro CALLMONITOR
a7c4					endif 
a7c4 c3 ee a7				jp .mallocc 
a7c7			.MALLOC2: 
a7c7				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7c7 56				db WORD_SYS_CORE+66             
a7c8 05 a8			dw .FREE            
a7ca 07				db 6 + 1 
a7cb .. 00			db "MALLOC",0              
a7d2				endm 
# End of macro CWHEAD
a7d2			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7d2					; get byte count 
a7d2					if DEBUG_FORTH_WORDS_KEY 
a7d2						DMARK "MAL" 
a7d2 f5				push af  
a7d3 3a e7 a7			ld a, (.dmark)  
a7d6 32 6b ee			ld (debug_mark),a  
a7d9 3a e8 a7			ld a, (.dmark+1)  
a7dc 32 6c ee			ld (debug_mark+1),a  
a7df 3a e9 a7			ld a, (.dmark+2)  
a7e2 32 6d ee			ld (debug_mark+2),a  
a7e5 18 03			jr .pastdmark  
a7e7 ..			.dmark: db "MAL"  
a7ea f1			.pastdmark: pop af  
a7eb			endm  
# End of macro DMARK
a7eb						CALLMONITOR 
a7eb cd 6f ee			call debug_vector  
a7ee				endm  
# End of macro CALLMONITOR
a7ee					endif 
a7ee			.mallocc: 
a7ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7ee cd 33 9d			call macro_dsp_valuehl 
a7f1				endm 
# End of macro FORTH_DSP_VALUEHL
a7f1			 
a7f1			;		push hl 
a7f1			 
a7f1					; destroy value TOS 
a7f1			 
a7f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7f1 cd eb 9d			call macro_forth_dsp_pop 
a7f4				endm 
# End of macro FORTH_DSP_POP
a7f4			 
a7f4			;		pop hl 
a7f4 cd a3 91				call malloc 
a7f7				if DEBUG_FORTH_MALLOC_GUARD 
a7f7 f5					push af 
a7f8 cd 05 8d				call ishlzero 
a7fb			;		ld a, l 
a7fb			;		add h 
a7fb			;		cp 0 
a7fb f1					pop af 
a7fc					 
a7fc cc 28 cc				call z,malloc_error 
a7ff				endif 
a7ff			 
a7ff cd 3c 9b				call forth_push_numhl 
a802					NEXTW 
a802 c3 e9 9e			jp macro_next 
a805				endm 
# End of macro NEXTW
a805			 
a805			.FREE: 
a805				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a805 57				db WORD_SYS_CORE+67             
a806 36 a8			dw .LIST            
a808 05				db 4 + 1 
a809 .. 00			db "FREE",0              
a80e				endm 
# End of macro CWHEAD
a80e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a80e					if DEBUG_FORTH_WORDS_KEY 
a80e						DMARK "FRE" 
a80e f5				push af  
a80f 3a 23 a8			ld a, (.dmark)  
a812 32 6b ee			ld (debug_mark),a  
a815 3a 24 a8			ld a, (.dmark+1)  
a818 32 6c ee			ld (debug_mark+1),a  
a81b 3a 25 a8			ld a, (.dmark+2)  
a81e 32 6d ee			ld (debug_mark+2),a  
a821 18 03			jr .pastdmark  
a823 ..			.dmark: db "FRE"  
a826 f1			.pastdmark: pop af  
a827			endm  
# End of macro DMARK
a827						CALLMONITOR 
a827 cd 6f ee			call debug_vector  
a82a				endm  
# End of macro CALLMONITOR
a82a					endif 
a82a					; get address 
a82a			 
a82a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a82a cd 33 9d			call macro_dsp_valuehl 
a82d				endm 
# End of macro FORTH_DSP_VALUEHL
a82d			 
a82d			;		push hl 
a82d			 
a82d					; destroy value TOS 
a82d			 
a82d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a82d cd eb 9d			call macro_forth_dsp_pop 
a830				endm 
# End of macro FORTH_DSP_POP
a830			 
a830			;		pop hl 
a830			if FORTH_ENABLE_MALLOCFREE 
a830 cd 6d 92				call free 
a833			endif 
a833					NEXTW 
a833 c3 e9 9e			jp macro_next 
a836				endm 
# End of macro NEXTW
a836			.LIST: 
a836				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a836 5c				db WORD_SYS_CORE+72             
a837 24 aa			dw .FORGET            
a839 05				db 4 + 1 
a83a .. 00			db "LIST",0              
a83f				endm 
# End of macro CWHEAD
a83f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a83f			; | | The quoted word must be in upper case. 
a83f				if DEBUG_FORTH_WORDS_KEY 
a83f					DMARK "LST" 
a83f f5				push af  
a840 3a 54 a8			ld a, (.dmark)  
a843 32 6b ee			ld (debug_mark),a  
a846 3a 55 a8			ld a, (.dmark+1)  
a849 32 6c ee			ld (debug_mark+1),a  
a84c 3a 56 a8			ld a, (.dmark+2)  
a84f 32 6d ee			ld (debug_mark+2),a  
a852 18 03			jr .pastdmark  
a854 ..			.dmark: db "LST"  
a857 f1			.pastdmark: pop af  
a858			endm  
# End of macro DMARK
a858					CALLMONITOR 
a858 cd 6f ee			call debug_vector  
a85b				endm  
# End of macro CALLMONITOR
a85b				endif 
a85b			 
a85b					FORTH_DSP_VALUEHL 
a85b cd 33 9d			call macro_dsp_valuehl 
a85e				endm 
# End of macro FORTH_DSP_VALUEHL
a85e			 
a85e e5					push hl 
a85f					FORTH_DSP_POP 
a85f cd eb 9d			call macro_forth_dsp_pop 
a862				endm 
# End of macro FORTH_DSP_POP
a862 c1					pop bc 
a863			 
a863			; Start format of scratch string 
a863			 
a863 21 c1 e2				ld hl, scratch 
a866			 
a866 3e 3a				ld a, ':' 
a868 77					ld (hl),a 
a869 23					inc hl 
a86a 3e 20				ld a, ' ' 
a86c 77					ld (hl), a 
a86d			 
a86d					; Get ptr to the word we need to look up 
a86d			 
a86d			;		FORTH_DSP_VALUEHL 
a86d					;v5 FORTH_DSP_VALUE 
a86d				; TODO type check 
a86d			;		inc hl    ; Skip type check  
a86d			;		push hl 
a86d			;		ex de, hl    ; put into DE 
a86d			 
a86d			 
a86d 21 2e e4				ld hl, baseram 
a870					;ld hl, baseusermem 
a870			 
a870 e5			push hl   ; sacreifical push 
a871			 
a871			.ldouscanm: 
a871 e1				pop hl 
a872			.ldouscan: 
a872				if DEBUG_FORTH_WORDS 
a872					DMARK "LSs" 
a872 f5				push af  
a873 3a 87 a8			ld a, (.dmark)  
a876 32 6b ee			ld (debug_mark),a  
a879 3a 88 a8			ld a, (.dmark+1)  
a87c 32 6c ee			ld (debug_mark+1),a  
a87f 3a 89 a8			ld a, (.dmark+2)  
a882 32 6d ee			ld (debug_mark+2),a  
a885 18 03			jr .pastdmark  
a887 ..			.dmark: db "LSs"  
a88a f1			.pastdmark: pop af  
a88b			endm  
# End of macro DMARK
a88b					CALLMONITOR 
a88b cd 6f ee			call debug_vector  
a88e				endm  
# End of macro CALLMONITOR
a88e				endif 
a88e				; skip dict stub 
a88e cd 3a a0				call forth_tok_next 
a891			 
a891			 
a891			; while we have words to look for 
a891			 
a891 7e				ld a, (hl)      
a892				if DEBUG_FORTH_WORDS 
a892					DMARK "LSk" 
a892 f5				push af  
a893 3a a7 a8			ld a, (.dmark)  
a896 32 6b ee			ld (debug_mark),a  
a899 3a a8 a8			ld a, (.dmark+1)  
a89c 32 6c ee			ld (debug_mark+1),a  
a89f 3a a9 a8			ld a, (.dmark+2)  
a8a2 32 6d ee			ld (debug_mark+2),a  
a8a5 18 03			jr .pastdmark  
a8a7 ..			.dmark: db "LSk"  
a8aa f1			.pastdmark: pop af  
a8ab			endm  
# End of macro DMARK
a8ab					CALLMONITOR 
a8ab cd 6f ee			call debug_vector  
a8ae				endm  
# End of macro CALLMONITOR
a8ae				endif 
a8ae					;cp WORD_SYS_END 
a8ae					;jp z, .lunotfound 
a8ae			 
a8ae					; if we hit non uwords then gone too far 
a8ae fe 01				cp WORD_SYS_UWORD 
a8b0 c2 e0 a9				jp nz, .lunotfound 
a8b3			 
a8b3				if DEBUG_FORTH_WORDS 
a8b3					DMARK "LSu" 
a8b3 f5				push af  
a8b4 3a c8 a8			ld a, (.dmark)  
a8b7 32 6b ee			ld (debug_mark),a  
a8ba 3a c9 a8			ld a, (.dmark+1)  
a8bd 32 6c ee			ld (debug_mark+1),a  
a8c0 3a ca a8			ld a, (.dmark+2)  
a8c3 32 6d ee			ld (debug_mark+2),a  
a8c6 18 03			jr .pastdmark  
a8c8 ..			.dmark: db "LSu"  
a8cb f1			.pastdmark: pop af  
a8cc			endm  
# End of macro DMARK
a8cc					CALLMONITOR 
a8cc cd 6f ee			call debug_vector  
a8cf				endm  
# End of macro CALLMONITOR
a8cf				endif 
a8cf			 
a8cf					; found a uword but is it the one we want... 
a8cf			 
a8cf c5					push bc     ; uword to find is on bc 
a8d0 d1					pop de 
a8d1			 
a8d1 e5					push hl  ; to save the ptr 
a8d2			 
a8d2					; skip opcode 
a8d2 23					inc hl  
a8d3					; skip next ptr 
a8d3 23					inc hl  
a8d4 23					inc hl 
a8d5					; skip len 
a8d5 23					inc hl 
a8d6			 
a8d6				if DEBUG_FORTH_WORDS 
a8d6					DMARK "LSc" 
a8d6 f5				push af  
a8d7 3a eb a8			ld a, (.dmark)  
a8da 32 6b ee			ld (debug_mark),a  
a8dd 3a ec a8			ld a, (.dmark+1)  
a8e0 32 6c ee			ld (debug_mark+1),a  
a8e3 3a ed a8			ld a, (.dmark+2)  
a8e6 32 6d ee			ld (debug_mark+2),a  
a8e9 18 03			jr .pastdmark  
a8eb ..			.dmark: db "LSc"  
a8ee f1			.pastdmark: pop af  
a8ef			endm  
# End of macro DMARK
a8ef					CALLMONITOR 
a8ef cd 6f ee			call debug_vector  
a8f2				endm  
# End of macro CALLMONITOR
a8f2				endif 
a8f2 cd 72 91				call strcmp 
a8f5 c2 71 a8				jp nz, .ldouscanm 
a8f8				 
a8f8			 
a8f8			 
a8f8					; we have a uword so push its name to the stack 
a8f8			 
a8f8			;	   	push hl  ; save so we can move to next dict block 
a8f8 e1			pop hl 
a8f9			 
a8f9				if DEBUG_FORTH_WORDS 
a8f9					DMARK "LSm" 
a8f9 f5				push af  
a8fa 3a 0e a9			ld a, (.dmark)  
a8fd 32 6b ee			ld (debug_mark),a  
a900 3a 0f a9			ld a, (.dmark+1)  
a903 32 6c ee			ld (debug_mark+1),a  
a906 3a 10 a9			ld a, (.dmark+2)  
a909 32 6d ee			ld (debug_mark+2),a  
a90c 18 03			jr .pastdmark  
a90e ..			.dmark: db "LSm"  
a911 f1			.pastdmark: pop af  
a912			endm  
# End of macro DMARK
a912					CALLMONITOR 
a912 cd 6f ee			call debug_vector  
a915				endm  
# End of macro CALLMONITOR
a915				endif 
a915			 
a915					; skip opcode 
a915 23					inc hl  
a916					; skip next ptr 
a916 23					inc hl  
a917 23					inc hl 
a918					; skip len 
a918 7e					ld a, (hl)   ; save length to add 
a919				if DEBUG_FORTH_WORDS 
a919					DMARK "LS2" 
a919 f5				push af  
a91a 3a 2e a9			ld a, (.dmark)  
a91d 32 6b ee			ld (debug_mark),a  
a920 3a 2f a9			ld a, (.dmark+1)  
a923 32 6c ee			ld (debug_mark+1),a  
a926 3a 30 a9			ld a, (.dmark+2)  
a929 32 6d ee			ld (debug_mark+2),a  
a92c 18 03			jr .pastdmark  
a92e ..			.dmark: db "LS2"  
a931 f1			.pastdmark: pop af  
a932			endm  
# End of macro DMARK
a932					CALLMONITOR 
a932 cd 6f ee			call debug_vector  
a935				endm  
# End of macro CALLMONITOR
a935				endif 
a935			 
a935					; save this location 
a935				 
a935 e5					push hl 
a936			 
a936 23					inc hl 
a937 11 c3 e2				ld de, scratch+2 
a93a 4f					ld c, a 
a93b 06 00				ld b, 0 
a93d			 
a93d				if DEBUG_FORTH_WORDS 
a93d					DMARK "LSn" 
a93d f5				push af  
a93e 3a 52 a9			ld a, (.dmark)  
a941 32 6b ee			ld (debug_mark),a  
a944 3a 53 a9			ld a, (.dmark+1)  
a947 32 6c ee			ld (debug_mark+1),a  
a94a 3a 54 a9			ld a, (.dmark+2)  
a94d 32 6d ee			ld (debug_mark+2),a  
a950 18 03			jr .pastdmark  
a952 ..			.dmark: db "LSn"  
a955 f1			.pastdmark: pop af  
a956			endm  
# End of macro DMARK
a956					CALLMONITOR 
a956 cd 6f ee			call debug_vector  
a959				endm  
# End of macro CALLMONITOR
a959				endif 
a959			 
a959					; copy uword name to scratch 
a959			 
a959 ed b0				ldir 
a95b			 
a95b 1b					dec de 
a95c 3e 20				ld a, ' '    ; change null to space 
a95e 12					ld (de), a 
a95f			 
a95f 13					inc de 
a960			 
a960 d5					push de 
a961 c1					pop bc     ; move scratch pointer to end of word name and save it 
a962			 
a962 e1					pop hl 
a963 7e					ld a, (hl) 
a964					;inc hl 
a964					; skip word string 
a964 cd dc 8c				call addatohl 
a967			 
a967 23					inc hl 
a968			 
a968				if DEBUG_FORTH_WORDS 
a968					DMARK "LS3" 
a968 f5				push af  
a969 3a 7d a9			ld a, (.dmark)  
a96c 32 6b ee			ld (debug_mark),a  
a96f 3a 7e a9			ld a, (.dmark+1)  
a972 32 6c ee			ld (debug_mark+1),a  
a975 3a 7f a9			ld a, (.dmark+2)  
a978 32 6d ee			ld (debug_mark+2),a  
a97b 18 03			jr .pastdmark  
a97d ..			.dmark: db "LS3"  
a980 f1			.pastdmark: pop af  
a981			endm  
# End of macro DMARK
a981					CALLMONITOR 
a981 cd 6f ee			call debug_vector  
a984				endm  
# End of macro CALLMONITOR
a984				endif 
a984					; should now be at the start of the machine code to setup the eval of the uword 
a984					; now locate the ptr to the string defintion 
a984			 
a984					; skip ld hl, 
a984					; then load the ptr 
a984			; TODO use get from hl ptr 
a984 23					inc hl 
a985 5e					ld e, (hl) 
a986 23					inc hl 
a987 56					ld d, (hl) 
a988 eb					ex de, hl 
a989			 
a989			 
a989				if DEBUG_FORTH_WORDS 
a989					DMARK "LSt" 
a989 f5				push af  
a98a 3a 9e a9			ld a, (.dmark)  
a98d 32 6b ee			ld (debug_mark),a  
a990 3a 9f a9			ld a, (.dmark+1)  
a993 32 6c ee			ld (debug_mark+1),a  
a996 3a a0 a9			ld a, (.dmark+2)  
a999 32 6d ee			ld (debug_mark+2),a  
a99c 18 03			jr .pastdmark  
a99e ..			.dmark: db "LSt"  
a9a1 f1			.pastdmark: pop af  
a9a2			endm  
# End of macro DMARK
a9a2					CALLMONITOR 
a9a2 cd 6f ee			call debug_vector  
a9a5				endm  
# End of macro CALLMONITOR
a9a5				endif 
a9a5			 
a9a5			; cant push right now due to tokenised strings  
a9a5			 
a9a5			; get the destination of where to copy this definition to. 
a9a5			 
a9a5 c5					push bc 
a9a6 d1					pop de 
a9a7			 
a9a7 7e			.listl:         ld a,(hl) 
a9a8 fe 00				cp 0 
a9aa 28 09				jr z, .lreplsp     ; replace zero with space 
a9ac					;cp FORTH_END_BUFFER 
a9ac fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9ae 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9b0				 
a9b0					; just copy this char as is then 
a9b0			 
a9b0 12					ld (de), a 
a9b1			 
a9b1 23			.listnxt:	inc hl 
a9b2 13					inc de 
a9b3 18 f2				jr .listl 
a9b5			 
a9b5 3e 20		.lreplsp:	ld a,' ' 
a9b7 12					ld (de), a 
a9b8 18 f7				jr .listnxt 
a9ba			 
a9ba			; close up uword def 
a9ba			 
a9ba			.listdone: 
a9ba 12					ld (de), a 
a9bb 13					inc de 
a9bc 3e 00				ld a, 0 
a9be 12					ld (de), a 
a9bf			 
a9bf			; now have def so clean up and push to stack 
a9bf			 
a9bf 21 c1 e2				ld hl, scratch 
a9c2				if DEBUG_FORTH_WORDS 
a9c2					DMARK "Ltp" 
a9c2 f5				push af  
a9c3 3a d7 a9			ld a, (.dmark)  
a9c6 32 6b ee			ld (debug_mark),a  
a9c9 3a d8 a9			ld a, (.dmark+1)  
a9cc 32 6c ee			ld (debug_mark+1),a  
a9cf 3a d9 a9			ld a, (.dmark+2)  
a9d2 32 6d ee			ld (debug_mark+2),a  
a9d5 18 03			jr .pastdmark  
a9d7 ..			.dmark: db "Ltp"  
a9da f1			.pastdmark: pop af  
a9db			endm  
# End of macro DMARK
a9db					CALLMONITOR 
a9db cd 6f ee			call debug_vector  
a9de				endm  
# End of macro CALLMONITOR
a9de				endif 
a9de			 
a9de 18 1f			jr .listpush 
a9e0			 
a9e0			;.lnuword:	pop hl 
a9e0			;		call forth_tok_next 
a9e0			;		jp .ldouscan  
a9e0			 
a9e0			.lunotfound:		  
a9e0			 
a9e0				if DEBUG_FORTH_WORDS 
a9e0					DMARK "LSn" 
a9e0 f5				push af  
a9e1 3a f5 a9			ld a, (.dmark)  
a9e4 32 6b ee			ld (debug_mark),a  
a9e7 3a f6 a9			ld a, (.dmark+1)  
a9ea 32 6c ee			ld (debug_mark+1),a  
a9ed 3a f7 a9			ld a, (.dmark+2)  
a9f0 32 6d ee			ld (debug_mark+2),a  
a9f3 18 03			jr .pastdmark  
a9f5 ..			.dmark: db "LSn"  
a9f8 f1			.pastdmark: pop af  
a9f9			endm  
# End of macro DMARK
a9f9					CALLMONITOR 
a9f9 cd 6f ee			call debug_vector  
a9fc				endm  
# End of macro CALLMONITOR
a9fc				endif 
a9fc			 
a9fc					 
a9fc			;		FORTH_DSP_POP 
a9fc			;		ld hl, .luno 
a9fc			 
a9fc					NEXTW			 
a9fc c3 e9 9e			jp macro_next 
a9ff				endm 
# End of macro NEXTW
a9ff			 
a9ff			.listpush: 
a9ff				if DEBUG_FORTH_WORDS 
a9ff					DMARK "LS>" 
a9ff f5				push af  
aa00 3a 14 aa			ld a, (.dmark)  
aa03 32 6b ee			ld (debug_mark),a  
aa06 3a 15 aa			ld a, (.dmark+1)  
aa09 32 6c ee			ld (debug_mark+1),a  
aa0c 3a 16 aa			ld a, (.dmark+2)  
aa0f 32 6d ee			ld (debug_mark+2),a  
aa12 18 03			jr .pastdmark  
aa14 ..			.dmark: db "LS>"  
aa17 f1			.pastdmark: pop af  
aa18			endm  
# End of macro DMARK
aa18					CALLMONITOR 
aa18 cd 6f ee			call debug_vector  
aa1b				endm  
# End of macro CALLMONITOR
aa1b				endif 
aa1b cd aa 9b				call forth_push_str 
aa1e			 
aa1e			 
aa1e			 
aa1e					NEXTW 
aa1e c3 e9 9e			jp macro_next 
aa21				endm 
# End of macro NEXTW
aa21			 
aa21			;.luno:    db "Word not found",0 
aa21			 
aa21			 
aa21			 
aa21			 
aa21			 
aa21			;		push hl   ; save pointer to start of uword def string 
aa21			; 
aa21			;; look for FORTH_EOL_LINE 
aa21			;		ld a, FORTH_END_BUFFER 
aa21			;		call strlent 
aa21			; 
aa21			;		inc hl		 ; space for coln def 
aa21			;		inc hl 
aa21			;		inc hl          ; space for terms 
aa21			;		inc hl 
aa21			; 
aa21			;		ld a, 20   ; TODO get actual length 
aa21			;		call addatohl    ; include a random amount of room for the uword name 
aa21			; 
aa21			;		 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "Lt1" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			;		 
aa21			; 
aa21			;; malloc space for the string because we cant change it 
aa21			; 
aa21			;		call malloc 
aa21			;	if DEBUG_FORTH_MALLOC_GUARD 
aa21			;		push af 
aa21			;		call ishlzero 
aa21			;		pop af 
aa21			;		 
aa21			;		call z,malloc_error 
aa21			;	endif 
aa21			; 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "Lt2" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			;		pop de 
aa21			;		push hl    ; push the malloc to release later 
aa21			;		push hl   ;  push back a copy for the later stack push 
aa21			;		 
aa21			;; copy the string swapping out the zero terms for spaces 
aa21			; 
aa21			;		; de has our source 
aa21			;		; hl has our dest 
aa21			; 
aa21			;; add the coln def 
aa21			; 
aa21			;		ld a, ':' 
aa21			;		ld (hl), a 
aa21			;		inc hl 
aa21			;		ld a, ' ' 
aa21			;		ld (hl), a 
aa21			;		inc hl 
aa21			; 
aa21			;; add the uname word 
aa21			;		push de   ; save our string for now 
aa21			;		ex de, hl 
aa21			; 
aa21			;		FORTH_DSP_VALUE 
aa21			;		;v5 FORTH_DSP_VALUE 
aa21			; 
aa21			;		inc hl   ; skip type but we know by now this is OK 
aa21			; 
aa21			;.luword:	ld a,(hl) 
aa21			;		cp 0 
aa21			;		jr z, .luword2 
aa21			;		ld (de), a 
aa21			;		inc de 
aa21			;		inc hl 
aa21			;		jr .luword 
aa21			; 
aa21			;.luword2:	ld a, ' ' 
aa21			;		ld (de), a 
aa21			;;		inc hl 
aa21			;;		inc de 
aa21			;;		ld (de), a 
aa21			;;		inc hl 
aa21			;		inc de 
aa21			; 
aa21			;		ex de, hl 
aa21			;		pop de 
aa21			;		 
aa21			;		 
aa21			; 
aa21			;; detoken that string and copy it 
aa21			; 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "Lt2" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			;.ldetok:	ld a, (de) 
aa21			;		cp FORTH_END_BUFFER 
aa21			;		jr z, .ldetokend 
aa21			;		; swap out any zero term for space 
aa21			;		cp 0 
aa21			;		jr nz, .ldetoknext 
aa21			;		ld a, ' ' 
aa21			; 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "LtS" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			;.ldetoknext:	ld (hl), a 
aa21			;		inc de 
aa21			;		inc hl 
aa21			;		jr .ldetok 
aa21			; 
aa21			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa21			;		ld (hl), a  
aa21			; 
aa21			;; free that temp malloc 
aa21			; 
aa21			;		pop hl    
aa21			; 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "Lt4" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			;		call forth_apushstrhl 
aa21			; 
aa21			;		; get rid of temp malloc area 
aa21			; 
aa21			;		pop hl 
aa21			;		call free 
aa21			; 
aa21			;		jr .ludone 
aa21			; 
aa21			;.lnuword:	pop hl 
aa21			;		call forth_tok_next 
aa21			;		jp .ldouscan  
aa21			; 
aa21			;.ludone:		 pop hl 
aa21			; 
aa21					NEXTW 
aa21 c3 e9 9e			jp macro_next 
aa24				endm 
# End of macro NEXTW
aa24			 
aa24			.FORGET: 
aa24				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa24 5d				db WORD_SYS_CORE+73             
aa25 9d aa			dw .NOP            
aa27 07				db 6 + 1 
aa28 .. 00			db "FORGET",0              
aa2f				endm 
# End of macro CWHEAD
aa2f			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa2f			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa2f			; | |  
aa2f			; | | e.g. "MORE" forget 
aa2f					if DEBUG_FORTH_WORDS_KEY 
aa2f						DMARK "FRG" 
aa2f f5				push af  
aa30 3a 44 aa			ld a, (.dmark)  
aa33 32 6b ee			ld (debug_mark),a  
aa36 3a 45 aa			ld a, (.dmark+1)  
aa39 32 6c ee			ld (debug_mark+1),a  
aa3c 3a 46 aa			ld a, (.dmark+2)  
aa3f 32 6d ee			ld (debug_mark+2),a  
aa42 18 03			jr .pastdmark  
aa44 ..			.dmark: db "FRG"  
aa47 f1			.pastdmark: pop af  
aa48			endm  
# End of macro DMARK
aa48						CALLMONITOR 
aa48 cd 6f ee			call debug_vector  
aa4b				endm  
# End of macro CALLMONITOR
aa4b					endif 
aa4b			 
aa4b				; find uword 
aa4b			        ; update start of word with "_" 
aa4b				; replace uword with deleted flag 
aa4b			 
aa4b			 
aa4b			;	if DEBUG_FORTH_WORDS 
aa4b			;		DMARK "FOG" 
aa4b			;		CALLMONITOR 
aa4b			;	endif 
aa4b			 
aa4b			 
aa4b					; Get ptr to the word we need to look up 
aa4b			 
aa4b					FORTH_DSP_VALUEHL 
aa4b cd 33 9d			call macro_dsp_valuehl 
aa4e				endm 
# End of macro FORTH_DSP_VALUEHL
aa4e					;v5 FORTH_DSP_VALUE 
aa4e				; TODO type check 
aa4e			;		inc hl    ; Skip type check  
aa4e e5					push hl 
aa4f c1					pop bc 
aa50			;		ex de, hl    ; put into DE 
aa50			 
aa50			 
aa50 21 2e e4				ld hl, baseram 
aa53					;ld hl, baseusermem 
aa53			 
aa53				; skip dict stub 
aa53			;	call forth_tok_next 
aa53 e5			push hl   ; sacreifical push 
aa54			 
aa54			.fldouscanm: 
aa54 e1				pop hl 
aa55			.fldouscan: 
aa55			;	if DEBUG_FORTH_WORDS 
aa55			;		DMARK "LSs" 
aa55			;		CALLMONITOR 
aa55			;	endif 
aa55				; skip dict stub 
aa55 cd 3a a0				call forth_tok_next 
aa58			 
aa58			 
aa58			; while we have words to look for 
aa58			 
aa58 7e				ld a, (hl)      
aa59			;	if DEBUG_FORTH_WORDS 
aa59			;		DMARK "LSk" 
aa59			;		CALLMONITOR 
aa59			;	endif 
aa59 fe 00				cp WORD_SYS_END 
aa5b ca 97 aa				jp z, .flunotfound 
aa5e fe 01				cp WORD_SYS_UWORD 
aa60 c2 55 aa				jp nz, .fldouscan 
aa63			 
aa63			;	if DEBUG_FORTH_WORDS 
aa63			;		DMARK "LSu" 
aa63			;		CALLMONITOR 
aa63			;	endif 
aa63			 
aa63					; found a uword but is it the one we want... 
aa63			 
aa63 c5					push bc     ; uword to find is on bc 
aa64 d1					pop de 
aa65			 
aa65 e5					push hl  ; to save the ptr 
aa66			 
aa66					; skip opcode 
aa66 23					inc hl  
aa67					; skip next ptr 
aa67 23					inc hl  
aa68 23					inc hl 
aa69					; skip len 
aa69 23					inc hl 
aa6a			 
aa6a			;	if DEBUG_FORTH_WORDS 
aa6a			;		DMARK "LSc" 
aa6a			;		CALLMONITOR 
aa6a			;	endif 
aa6a cd 72 91				call strcmp 
aa6d c2 54 aa				jp nz, .fldouscanm 
aa70			; 
aa70			; 
aa70			;; while we have words to look for 
aa70			; 
aa70			;.fdouscan:	ld a, (hl)      
aa70			;	if DEBUG_FORTH_WORDS 
aa70			;		DMARK "LSs" 
aa70			;		CALLMONITOR 
aa70			;	endif 
aa70			;		cp WORD_SYS_END 
aa70			;		jp z, .fudone 
aa70			;		cp WORD_SYS_UWORD 
aa70			;		jp nz, .fnuword 
aa70			; 
aa70			;	if DEBUG_FORTH_WORDS 
aa70			;		DMARK "FGu" 
aa70			;		CALLMONITOR 
aa70			;	endif 
aa70			; 
aa70			;		; found a uword but is it the one we want... 
aa70			; 
aa70			; 
aa70			;	        pop de   ; get back the dsp name 
aa70			;		push de 
aa70			; 
aa70			;		push hl  ; to save the ptr 
aa70			; 
aa70			;		; skip opcode 
aa70			;		inc hl  
aa70			;		; skip next ptr 
aa70			;		inc hl  
aa70			;		inc hl 
aa70			;		; skip len 
aa70			;		inc hl 
aa70			; 
aa70			;	if DEBUG_FORTH_WORDS 
aa70			;		DMARK "FGc" 
aa70			;		CALLMONITOR 
aa70			;	endif 
aa70			;		call strcmp 
aa70			;		jp nz, .fnuword 
aa70			 
aa70			 
aa70 e1			pop hl 
aa71			 
aa71				 
aa71				if DEBUG_FORTH_WORDS 
aa71					DMARK "FGm" 
aa71 f5				push af  
aa72 3a 86 aa			ld a, (.dmark)  
aa75 32 6b ee			ld (debug_mark),a  
aa78 3a 87 aa			ld a, (.dmark+1)  
aa7b 32 6c ee			ld (debug_mark+1),a  
aa7e 3a 88 aa			ld a, (.dmark+2)  
aa81 32 6d ee			ld (debug_mark+2),a  
aa84 18 03			jr .pastdmark  
aa86 ..			.dmark: db "FGm"  
aa89 f1			.pastdmark: pop af  
aa8a			endm  
# End of macro DMARK
aa8a					CALLMONITOR 
aa8a cd 6f ee			call debug_vector  
aa8d				endm  
# End of macro CALLMONITOR
aa8d				endif 
aa8d			 
aa8d			 
aa8d			 
aa8d					; we have a uword so push its name to the stack 
aa8d			 
aa8d			;	   	push hl  ; save so we can move to next dict block 
aa8d			;pop hl 
aa8d			 
aa8d					; update opcode to deleted 
aa8d 3e 03				ld a, WORD_SYS_DELETED 
aa8f 77					ld (hl), a 
aa90			 
aa90 23					inc hl  
aa91					; skip next ptr 
aa91 23					inc hl  
aa92 23					inc hl 
aa93					; skip len 
aa93 23					inc hl 
aa94			 
aa94					; TODO change parser to skip deleted words but for now mark it out 
aa94 3e 5f				ld a, "_" 
aa96 77					ld  (hl),a 
aa97			 
aa97			;		jr .fudone 
aa97			; 
aa97			;.fnuword:	pop hl 
aa97			;		call forth_tok_next 
aa97			;		jp .fdouscan  
aa97			 
aa97			.flunotfound:		  
aa97			 
aa97			 
aa97					 
aa97					FORTH_DSP_POP 
aa97 cd eb 9d			call macro_forth_dsp_pop 
aa9a				endm 
# End of macro FORTH_DSP_POP
aa9a			;		ld hl, .luno 
aa9a			;.fudone:		 pop hl 
aa9a					NEXTW 
aa9a c3 e9 9e			jp macro_next 
aa9d				endm 
# End of macro NEXTW
aa9d			.NOP: 
aa9d				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa9d 61				db WORD_SYS_CORE+77             
aa9e c4 aa			dw .COMO            
aaa0 04				db 3 + 1 
aaa1 .. 00			db "NOP",0              
aaa5				endm 
# End of macro CWHEAD
aaa5			; | NOP (  --  ) Do nothing | DONE 
aaa5					if DEBUG_FORTH_WORDS_KEY 
aaa5						DMARK "NOP" 
aaa5 f5				push af  
aaa6 3a ba aa			ld a, (.dmark)  
aaa9 32 6b ee			ld (debug_mark),a  
aaac 3a bb aa			ld a, (.dmark+1)  
aaaf 32 6c ee			ld (debug_mark+1),a  
aab2 3a bc aa			ld a, (.dmark+2)  
aab5 32 6d ee			ld (debug_mark+2),a  
aab8 18 03			jr .pastdmark  
aaba ..			.dmark: db "NOP"  
aabd f1			.pastdmark: pop af  
aabe			endm  
# End of macro DMARK
aabe						CALLMONITOR 
aabe cd 6f ee			call debug_vector  
aac1				endm  
# End of macro CALLMONITOR
aac1					endif 
aac1				       NEXTW 
aac1 c3 e9 9e			jp macro_next 
aac4				endm 
# End of macro NEXTW
aac4			.COMO: 
aac4				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aac4 6e				db WORD_SYS_CORE+90             
aac5 16 ab			dw .COMC            
aac7 02				db 1 + 1 
aac8 .. 00			db "(",0              
aaca				endm 
# End of macro CWHEAD
aaca			; | ( ( -- )  Start of comment | DONE 
aaca			 
aaca			 
aaca 2a c2 e5				ld hl, ( os_tok_ptr) 
aacd 11 11 ab			ld de, .closepar 
aad0					 
aad0					if DEBUG_FORTH_WORDS 
aad0						DMARK ").." 
aad0 f5				push af  
aad1 3a e5 aa			ld a, (.dmark)  
aad4 32 6b ee			ld (debug_mark),a  
aad7 3a e6 aa			ld a, (.dmark+1)  
aada 32 6c ee			ld (debug_mark+1),a  
aadd 3a e7 aa			ld a, (.dmark+2)  
aae0 32 6d ee			ld (debug_mark+2),a  
aae3 18 03			jr .pastdmark  
aae5 ..			.dmark: db ").."  
aae8 f1			.pastdmark: pop af  
aae9			endm  
# End of macro DMARK
aae9						CALLMONITOR 
aae9 cd 6f ee			call debug_vector  
aaec				endm  
# End of macro CALLMONITOR
aaec					endif 
aaec cd 04 a0			call findnexttok  
aaef			 
aaef					if DEBUG_FORTH_WORDS 
aaef						DMARK "IF5" 
aaef f5				push af  
aaf0 3a 04 ab			ld a, (.dmark)  
aaf3 32 6b ee			ld (debug_mark),a  
aaf6 3a 05 ab			ld a, (.dmark+1)  
aaf9 32 6c ee			ld (debug_mark+1),a  
aafc 3a 06 ab			ld a, (.dmark+2)  
aaff 32 6d ee			ld (debug_mark+2),a  
ab02 18 03			jr .pastdmark  
ab04 ..			.dmark: db "IF5"  
ab07 f1			.pastdmark: pop af  
ab08			endm  
# End of macro DMARK
ab08						CALLMONITOR 
ab08 cd 6f ee			call debug_vector  
ab0b				endm  
# End of macro CALLMONITOR
ab0b					endif 
ab0b				; replace below with ) exec using tok_ptr 
ab0b 22 c2 e5			ld (os_tok_ptr), hl 
ab0e c3 7a 9f			jp exec1 
ab11			 
ab11 .. 00			.closepar:   db ")",0 
ab13			 
ab13				       NEXTW 
ab13 c3 e9 9e			jp macro_next 
ab16				endm 
# End of macro NEXTW
ab16			.COMC: 
ab16				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab16 6f				db WORD_SYS_CORE+91             
ab17 1f ab			dw .SCRATCH            
ab19 02				db 1 + 1 
ab1a .. 00			db ")",0              
ab1c				endm 
# End of macro CWHEAD
ab1c			; | ) ( -- )  End of comment |  DONE  
ab1c				       NEXTW 
ab1c c3 e9 9e			jp macro_next 
ab1f				endm 
# End of macro NEXTW
ab1f			 
ab1f			.SCRATCH: 
ab1f				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab1f 6f				db WORD_SYS_CORE+91             
ab20 5a ab			dw .INC            
ab22 08				db 7 + 1 
ab23 .. 00			db "SCRATCH",0              
ab2b				endm 
# End of macro CWHEAD
ab2b			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab2b			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab2b			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab2b			; | |  
ab2b			; | | e.g.    : score $00 scratch ; 
ab2b			; | |  
ab2b			; | | $00 score ! 
ab2b			; | | $01 score +! 
ab2b			; | |  
ab2b			; | | e.g.   : varword $0a scratch ;  
ab2b			; | | 
ab2b			; | | $8000 varword ! 
ab2b					if DEBUG_FORTH_WORDS_KEY 
ab2b						DMARK "SCR" 
ab2b f5				push af  
ab2c 3a 40 ab			ld a, (.dmark)  
ab2f 32 6b ee			ld (debug_mark),a  
ab32 3a 41 ab			ld a, (.dmark+1)  
ab35 32 6c ee			ld (debug_mark+1),a  
ab38 3a 42 ab			ld a, (.dmark+2)  
ab3b 32 6d ee			ld (debug_mark+2),a  
ab3e 18 03			jr .pastdmark  
ab40 ..			.dmark: db "SCR"  
ab43 f1			.pastdmark: pop af  
ab44			endm  
# End of macro DMARK
ab44						CALLMONITOR 
ab44 cd 6f ee			call debug_vector  
ab47				endm  
# End of macro CALLMONITOR
ab47					endif 
ab47			 
ab47					FORTH_DSP_VALUEHL 
ab47 cd 33 9d			call macro_dsp_valuehl 
ab4a				endm 
# End of macro FORTH_DSP_VALUEHL
ab4a				 
ab4a					FORTH_DSP_POP 
ab4a cd eb 9d			call macro_forth_dsp_pop 
ab4d				endm 
# End of macro FORTH_DSP_POP
ab4d			 
ab4d 7d					ld a, l 
ab4e 21 e6 e7				ld hl, os_var_array 
ab51 cd dc 8c				call addatohl 
ab54			 
ab54 cd 3c 9b				call forth_push_numhl 
ab57			 
ab57				       NEXTW 
ab57 c3 e9 9e			jp macro_next 
ab5a				endm 
# End of macro NEXTW
ab5a			 
ab5a			.INC: 
ab5a				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab5a 6f				db WORD_SYS_CORE+91             
ab5b ae ab			dw .DEC            
ab5d 03				db 2 + 1 
ab5e .. 00			db "+!",0              
ab61				endm 
# End of macro CWHEAD
ab61			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab61					if DEBUG_FORTH_WORDS_KEY 
ab61						DMARK "+s_" 
ab61 f5				push af  
ab62 3a 76 ab			ld a, (.dmark)  
ab65 32 6b ee			ld (debug_mark),a  
ab68 3a 77 ab			ld a, (.dmark+1)  
ab6b 32 6c ee			ld (debug_mark+1),a  
ab6e 3a 78 ab			ld a, (.dmark+2)  
ab71 32 6d ee			ld (debug_mark+2),a  
ab74 18 03			jr .pastdmark  
ab76 ..			.dmark: db "+s_"  
ab79 f1			.pastdmark: pop af  
ab7a			endm  
# End of macro DMARK
ab7a						CALLMONITOR 
ab7a cd 6f ee			call debug_vector  
ab7d				endm  
# End of macro CALLMONITOR
ab7d					endif 
ab7d			 
ab7d					FORTH_DSP_VALUEHL 
ab7d cd 33 9d			call macro_dsp_valuehl 
ab80				endm 
# End of macro FORTH_DSP_VALUEHL
ab80			 
ab80 e5					push hl   ; save address 
ab81			 
ab81					FORTH_DSP_POP 
ab81 cd eb 9d			call macro_forth_dsp_pop 
ab84				endm 
# End of macro FORTH_DSP_POP
ab84			 
ab84					FORTH_DSP_VALUEHL 
ab84 cd 33 9d			call macro_dsp_valuehl 
ab87				endm 
# End of macro FORTH_DSP_VALUEHL
ab87			 
ab87					FORTH_DSP_POP 
ab87 cd eb 9d			call macro_forth_dsp_pop 
ab8a				endm 
# End of macro FORTH_DSP_POP
ab8a			 
ab8a					; hl contains value to add to byte at a 
ab8a				 
ab8a eb					ex de, hl 
ab8b			 
ab8b e1					pop hl 
ab8c			 
ab8c					if DEBUG_FORTH_WORDS 
ab8c						DMARK "INC" 
ab8c f5				push af  
ab8d 3a a1 ab			ld a, (.dmark)  
ab90 32 6b ee			ld (debug_mark),a  
ab93 3a a2 ab			ld a, (.dmark+1)  
ab96 32 6c ee			ld (debug_mark+1),a  
ab99 3a a3 ab			ld a, (.dmark+2)  
ab9c 32 6d ee			ld (debug_mark+2),a  
ab9f 18 03			jr .pastdmark  
aba1 ..			.dmark: db "INC"  
aba4 f1			.pastdmark: pop af  
aba5			endm  
# End of macro DMARK
aba5						CALLMONITOR 
aba5 cd 6f ee			call debug_vector  
aba8				endm  
# End of macro CALLMONITOR
aba8					endif 
aba8			 
aba8 7e					ld a,(hl) 
aba9 83					add e 
abaa 77					ld (hl),a 
abab			 
abab			 
abab			 
abab				       NEXTW 
abab c3 e9 9e			jp macro_next 
abae				endm 
# End of macro NEXTW
abae			 
abae			.DEC: 
abae				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abae 6f				db WORD_SYS_CORE+91             
abaf ff ab			dw .INC2            
abb1 03				db 2 + 1 
abb2 .. 00			db "-!",0              
abb5				endm 
# End of macro CWHEAD
abb5			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abb5					if DEBUG_FORTH_WORDS_KEY 
abb5						DMARK "-s_" 
abb5 f5				push af  
abb6 3a ca ab			ld a, (.dmark)  
abb9 32 6b ee			ld (debug_mark),a  
abbc 3a cb ab			ld a, (.dmark+1)  
abbf 32 6c ee			ld (debug_mark+1),a  
abc2 3a cc ab			ld a, (.dmark+2)  
abc5 32 6d ee			ld (debug_mark+2),a  
abc8 18 03			jr .pastdmark  
abca ..			.dmark: db "-s_"  
abcd f1			.pastdmark: pop af  
abce			endm  
# End of macro DMARK
abce						CALLMONITOR 
abce cd 6f ee			call debug_vector  
abd1				endm  
# End of macro CALLMONITOR
abd1					endif 
abd1			 
abd1					FORTH_DSP_VALUEHL 
abd1 cd 33 9d			call macro_dsp_valuehl 
abd4				endm 
# End of macro FORTH_DSP_VALUEHL
abd4			 
abd4 e5					push hl   ; save address 
abd5			 
abd5					FORTH_DSP_POP 
abd5 cd eb 9d			call macro_forth_dsp_pop 
abd8				endm 
# End of macro FORTH_DSP_POP
abd8			 
abd8					FORTH_DSP_VALUEHL 
abd8 cd 33 9d			call macro_dsp_valuehl 
abdb				endm 
# End of macro FORTH_DSP_VALUEHL
abdb			 
abdb					; hl contains value to add to byte at a 
abdb				 
abdb eb					ex de, hl 
abdc			 
abdc e1					pop hl 
abdd			 
abdd					if DEBUG_FORTH_WORDS 
abdd						DMARK "DEC" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 6b ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 6c ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 6d ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "DEC"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd 6f ee			call debug_vector  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9 7e					ld a,(hl) 
abfa 93					sub e 
abfb 77					ld (hl),a 
abfc			 
abfc			 
abfc			 
abfc				       NEXTW 
abfc c3 e9 9e			jp macro_next 
abff				endm 
# End of macro NEXTW
abff			 
abff			.INC2: 
abff				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
abff 6f				db WORD_SYS_CORE+91             
ac00 a9 ac			dw .DEC2            
ac02 04				db 3 + 1 
ac03 .. 00			db "+2!",0              
ac07				endm 
# End of macro CWHEAD
ac07			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac07			 
ac07					if DEBUG_FORTH_WORDS_KEY 
ac07						DMARK "+2s" 
ac07 f5				push af  
ac08 3a 1c ac			ld a, (.dmark)  
ac0b 32 6b ee			ld (debug_mark),a  
ac0e 3a 1d ac			ld a, (.dmark+1)  
ac11 32 6c ee			ld (debug_mark+1),a  
ac14 3a 1e ac			ld a, (.dmark+2)  
ac17 32 6d ee			ld (debug_mark+2),a  
ac1a 18 03			jr .pastdmark  
ac1c ..			.dmark: db "+2s"  
ac1f f1			.pastdmark: pop af  
ac20			endm  
# End of macro DMARK
ac20						CALLMONITOR 
ac20 cd 6f ee			call debug_vector  
ac23				endm  
# End of macro CALLMONITOR
ac23					endif 
ac23			 
ac23					; Address 
ac23			 
ac23					FORTH_DSP_VALUEHL 
ac23 cd 33 9d			call macro_dsp_valuehl 
ac26				endm 
# End of macro FORTH_DSP_VALUEHL
ac26			 
ac26 e5					push hl    ; save address 
ac27			 
ac27					; load content into de 
ac27			 
ac27 5e					ld e,(hl) 
ac28 23					inc hl 
ac29 56					ld d, (hl) 
ac2a			 
ac2a					if DEBUG_FORTH_WORDS 
ac2a						DMARK "+2a" 
ac2a f5				push af  
ac2b 3a 3f ac			ld a, (.dmark)  
ac2e 32 6b ee			ld (debug_mark),a  
ac31 3a 40 ac			ld a, (.dmark+1)  
ac34 32 6c ee			ld (debug_mark+1),a  
ac37 3a 41 ac			ld a, (.dmark+2)  
ac3a 32 6d ee			ld (debug_mark+2),a  
ac3d 18 03			jr .pastdmark  
ac3f ..			.dmark: db "+2a"  
ac42 f1			.pastdmark: pop af  
ac43			endm  
# End of macro DMARK
ac43						CALLMONITOR 
ac43 cd 6f ee			call debug_vector  
ac46				endm  
# End of macro CALLMONITOR
ac46					endif 
ac46			 
ac46					FORTH_DSP_POP 
ac46 cd eb 9d			call macro_forth_dsp_pop 
ac49				endm 
# End of macro FORTH_DSP_POP
ac49			 
ac49					; Get value to add 
ac49			 
ac49					FORTH_DSP_VALUE 
ac49 cd 1c 9d			call macro_forth_dsp_value 
ac4c				endm 
# End of macro FORTH_DSP_VALUE
ac4c			 
ac4c					if DEBUG_FORTH_WORDS 
ac4c						DMARK "+2v" 
ac4c f5				push af  
ac4d 3a 61 ac			ld a, (.dmark)  
ac50 32 6b ee			ld (debug_mark),a  
ac53 3a 62 ac			ld a, (.dmark+1)  
ac56 32 6c ee			ld (debug_mark+1),a  
ac59 3a 63 ac			ld a, (.dmark+2)  
ac5c 32 6d ee			ld (debug_mark+2),a  
ac5f 18 03			jr .pastdmark  
ac61 ..			.dmark: db "+2v"  
ac64 f1			.pastdmark: pop af  
ac65			endm  
# End of macro DMARK
ac65						CALLMONITOR 
ac65 cd 6f ee			call debug_vector  
ac68				endm  
# End of macro CALLMONITOR
ac68					endif 
ac68			 
ac68 19					add hl, de 
ac69			 
ac69					if DEBUG_FORTH_WORDS 
ac69						DMARK "+2+" 
ac69 f5				push af  
ac6a 3a 7e ac			ld a, (.dmark)  
ac6d 32 6b ee			ld (debug_mark),a  
ac70 3a 7f ac			ld a, (.dmark+1)  
ac73 32 6c ee			ld (debug_mark+1),a  
ac76 3a 80 ac			ld a, (.dmark+2)  
ac79 32 6d ee			ld (debug_mark+2),a  
ac7c 18 03			jr .pastdmark  
ac7e ..			.dmark: db "+2+"  
ac81 f1			.pastdmark: pop af  
ac82			endm  
# End of macro DMARK
ac82						CALLMONITOR 
ac82 cd 6f ee			call debug_vector  
ac85				endm  
# End of macro CALLMONITOR
ac85					endif 
ac85			 
ac85					; move result to de 
ac85			 
ac85 eb					ex de, hl 
ac86			 
ac86					; Address 
ac86			 
ac86 e1					pop hl 
ac87			 
ac87					; save it back 
ac87			 
ac87 73					ld (hl), e 
ac88 23					inc hl 
ac89 72					ld (hl), d 
ac8a			 
ac8a					if DEBUG_FORTH_WORDS 
ac8a						DMARK "+2e" 
ac8a f5				push af  
ac8b 3a 9f ac			ld a, (.dmark)  
ac8e 32 6b ee			ld (debug_mark),a  
ac91 3a a0 ac			ld a, (.dmark+1)  
ac94 32 6c ee			ld (debug_mark+1),a  
ac97 3a a1 ac			ld a, (.dmark+2)  
ac9a 32 6d ee			ld (debug_mark+2),a  
ac9d 18 03			jr .pastdmark  
ac9f ..			.dmark: db "+2e"  
aca2 f1			.pastdmark: pop af  
aca3			endm  
# End of macro DMARK
aca3						CALLMONITOR 
aca3 cd 6f ee			call debug_vector  
aca6				endm  
# End of macro CALLMONITOR
aca6					endif 
aca6			 
aca6			 
aca6			 
aca6			 
aca6			 
aca6				       NEXTW 
aca6 c3 e9 9e			jp macro_next 
aca9				endm 
# End of macro NEXTW
aca9			 
aca9			.DEC2: 
aca9				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aca9 6f				db WORD_SYS_CORE+91             
acaa 55 ad			dw .GET2            
acac 04				db 3 + 1 
acad .. 00			db "-2!",0              
acb1				endm 
# End of macro CWHEAD
acb1			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acb1			 
acb1			 
acb1					if DEBUG_FORTH_WORDS_KEY 
acb1						DMARK "-2s" 
acb1 f5				push af  
acb2 3a c6 ac			ld a, (.dmark)  
acb5 32 6b ee			ld (debug_mark),a  
acb8 3a c7 ac			ld a, (.dmark+1)  
acbb 32 6c ee			ld (debug_mark+1),a  
acbe 3a c8 ac			ld a, (.dmark+2)  
acc1 32 6d ee			ld (debug_mark+2),a  
acc4 18 03			jr .pastdmark  
acc6 ..			.dmark: db "-2s"  
acc9 f1			.pastdmark: pop af  
acca			endm  
# End of macro DMARK
acca						CALLMONITOR 
acca cd 6f ee			call debug_vector  
accd				endm  
# End of macro CALLMONITOR
accd					endif 
accd			 
accd					; Address 
accd			 
accd					FORTH_DSP_VALUEHL 
accd cd 33 9d			call macro_dsp_valuehl 
acd0				endm 
# End of macro FORTH_DSP_VALUEHL
acd0			 
acd0 e5					push hl    ; save address 
acd1			 
acd1					; load content into de 
acd1			 
acd1 5e					ld e,(hl) 
acd2 23					inc hl 
acd3 56					ld d, (hl) 
acd4			 
acd4					if DEBUG_FORTH_WORDS 
acd4						DMARK "-2a" 
acd4 f5				push af  
acd5 3a e9 ac			ld a, (.dmark)  
acd8 32 6b ee			ld (debug_mark),a  
acdb 3a ea ac			ld a, (.dmark+1)  
acde 32 6c ee			ld (debug_mark+1),a  
ace1 3a eb ac			ld a, (.dmark+2)  
ace4 32 6d ee			ld (debug_mark+2),a  
ace7 18 03			jr .pastdmark  
ace9 ..			.dmark: db "-2a"  
acec f1			.pastdmark: pop af  
aced			endm  
# End of macro DMARK
aced						CALLMONITOR 
aced cd 6f ee			call debug_vector  
acf0				endm  
# End of macro CALLMONITOR
acf0					endif 
acf0			 
acf0					FORTH_DSP_POP 
acf0 cd eb 9d			call macro_forth_dsp_pop 
acf3				endm 
# End of macro FORTH_DSP_POP
acf3			 
acf3					; Get value to remove 
acf3			 
acf3					FORTH_DSP_VALUE 
acf3 cd 1c 9d			call macro_forth_dsp_value 
acf6				endm 
# End of macro FORTH_DSP_VALUE
acf6			 
acf6					if DEBUG_FORTH_WORDS 
acf6						DMARK "-2v" 
acf6 f5				push af  
acf7 3a 0b ad			ld a, (.dmark)  
acfa 32 6b ee			ld (debug_mark),a  
acfd 3a 0c ad			ld a, (.dmark+1)  
ad00 32 6c ee			ld (debug_mark+1),a  
ad03 3a 0d ad			ld a, (.dmark+2)  
ad06 32 6d ee			ld (debug_mark+2),a  
ad09 18 03			jr .pastdmark  
ad0b ..			.dmark: db "-2v"  
ad0e f1			.pastdmark: pop af  
ad0f			endm  
# End of macro DMARK
ad0f						CALLMONITOR 
ad0f cd 6f ee			call debug_vector  
ad12				endm  
# End of macro CALLMONITOR
ad12					endif 
ad12			 
ad12 eb					ex de, hl 
ad13 ed 52				sbc hl, de 
ad15			 
ad15					if DEBUG_FORTH_WORDS 
ad15						DMARK "-2d" 
ad15 f5				push af  
ad16 3a 2a ad			ld a, (.dmark)  
ad19 32 6b ee			ld (debug_mark),a  
ad1c 3a 2b ad			ld a, (.dmark+1)  
ad1f 32 6c ee			ld (debug_mark+1),a  
ad22 3a 2c ad			ld a, (.dmark+2)  
ad25 32 6d ee			ld (debug_mark+2),a  
ad28 18 03			jr .pastdmark  
ad2a ..			.dmark: db "-2d"  
ad2d f1			.pastdmark: pop af  
ad2e			endm  
# End of macro DMARK
ad2e						CALLMONITOR 
ad2e cd 6f ee			call debug_vector  
ad31				endm  
# End of macro CALLMONITOR
ad31					endif 
ad31			 
ad31					; move result to de 
ad31			 
ad31 eb					ex de, hl 
ad32			 
ad32					; Address 
ad32			 
ad32 e1					pop hl 
ad33			 
ad33					; save it back 
ad33			 
ad33 73					ld (hl), e 
ad34 23					inc hl 
ad35 72					ld (hl), d 
ad36			 
ad36					if DEBUG_FORTH_WORDS 
ad36						DMARK "-2e" 
ad36 f5				push af  
ad37 3a 4b ad			ld a, (.dmark)  
ad3a 32 6b ee			ld (debug_mark),a  
ad3d 3a 4c ad			ld a, (.dmark+1)  
ad40 32 6c ee			ld (debug_mark+1),a  
ad43 3a 4d ad			ld a, (.dmark+2)  
ad46 32 6d ee			ld (debug_mark+2),a  
ad49 18 03			jr .pastdmark  
ad4b ..			.dmark: db "-2e"  
ad4e f1			.pastdmark: pop af  
ad4f			endm  
# End of macro DMARK
ad4f						CALLMONITOR 
ad4f cd 6f ee			call debug_vector  
ad52				endm  
# End of macro CALLMONITOR
ad52					endif 
ad52			 
ad52			 
ad52			 
ad52			 
ad52			 
ad52				       NEXTW 
ad52 c3 e9 9e			jp macro_next 
ad55				endm 
# End of macro NEXTW
ad55			.GET2: 
ad55				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad55 6f				db WORD_SYS_CORE+91             
ad56 85 ad			dw .BANG2            
ad58 03				db 2 + 1 
ad59 .. 00			db "2@",0              
ad5c				endm 
# End of macro CWHEAD
ad5c			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad5c					if DEBUG_FORTH_WORDS_KEY 
ad5c						DMARK "2A_" 
ad5c f5				push af  
ad5d 3a 71 ad			ld a, (.dmark)  
ad60 32 6b ee			ld (debug_mark),a  
ad63 3a 72 ad			ld a, (.dmark+1)  
ad66 32 6c ee			ld (debug_mark+1),a  
ad69 3a 73 ad			ld a, (.dmark+2)  
ad6c 32 6d ee			ld (debug_mark+2),a  
ad6f 18 03			jr .pastdmark  
ad71 ..			.dmark: db "2A_"  
ad74 f1			.pastdmark: pop af  
ad75			endm  
# End of macro DMARK
ad75						CALLMONITOR 
ad75 cd 6f ee			call debug_vector  
ad78				endm  
# End of macro CALLMONITOR
ad78					endif 
ad78			 
ad78					FORTH_DSP_VALUEHL 
ad78 cd 33 9d			call macro_dsp_valuehl 
ad7b				endm 
# End of macro FORTH_DSP_VALUEHL
ad7b			 
ad7b 5e					ld e, (hl) 
ad7c 23					inc hl 
ad7d 56					ld d, (hl) 
ad7e			 
ad7e eb					ex de, hl 
ad7f			 
ad7f cd 3c 9b				call forth_push_numhl 
ad82			 
ad82				       NEXTW 
ad82 c3 e9 9e			jp macro_next 
ad85				endm 
# End of macro NEXTW
ad85			.BANG2: 
ad85				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad85 6f				db WORD_SYS_CORE+91             
ad86 bd ad			dw .CONFIG            
ad88 03				db 2 + 1 
ad89 .. 00			db "2!",0              
ad8c				endm 
# End of macro CWHEAD
ad8c			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad8c					if DEBUG_FORTH_WORDS_KEY 
ad8c						DMARK "2S_" 
ad8c f5				push af  
ad8d 3a a1 ad			ld a, (.dmark)  
ad90 32 6b ee			ld (debug_mark),a  
ad93 3a a2 ad			ld a, (.dmark+1)  
ad96 32 6c ee			ld (debug_mark+1),a  
ad99 3a a3 ad			ld a, (.dmark+2)  
ad9c 32 6d ee			ld (debug_mark+2),a  
ad9f 18 03			jr .pastdmark  
ada1 ..			.dmark: db "2S_"  
ada4 f1			.pastdmark: pop af  
ada5			endm  
# End of macro DMARK
ada5						CALLMONITOR 
ada5 cd 6f ee			call debug_vector  
ada8				endm  
# End of macro CALLMONITOR
ada8					endif 
ada8			 
ada8					FORTH_DSP_VALUEHL 
ada8 cd 33 9d			call macro_dsp_valuehl 
adab				endm 
# End of macro FORTH_DSP_VALUEHL
adab			 
adab e5					push hl   ; save address 
adac			 
adac			 
adac					FORTH_DSP_POP 
adac cd eb 9d			call macro_forth_dsp_pop 
adaf				endm 
# End of macro FORTH_DSP_POP
adaf			 
adaf					 
adaf					FORTH_DSP_VALUEHL 
adaf cd 33 9d			call macro_dsp_valuehl 
adb2				endm 
# End of macro FORTH_DSP_VALUEHL
adb2			 
adb2					FORTH_DSP_POP 
adb2 cd eb 9d			call macro_forth_dsp_pop 
adb5				endm 
# End of macro FORTH_DSP_POP
adb5			 
adb5 eb					ex de, hl    ; value now in de 
adb6			 
adb6 e1					pop hl 
adb7			 
adb7 73					ld (hl), e 
adb8			 
adb8 23					inc hl 
adb9			 
adb9 72					ld (hl), d 
adba			 
adba			 
adba				       NEXTW 
adba c3 e9 9e			jp macro_next 
adbd				endm 
# End of macro NEXTW
adbd			.CONFIG: 
adbd				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
adbd 6f				db WORD_SYS_CORE+91             
adbe ce ad			dw .ADTOS            
adc0 07				db 6 + 1 
adc1 .. 00			db "CONFIG",0              
adc8				endm 
# End of macro CWHEAD
adc8			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
adc8			 
adc8 cd 3c 93				call config 
adcb					NEXTW 
adcb c3 e9 9e			jp macro_next 
adce				endm 
# End of macro NEXTW
adce			 
adce			.ADTOS: 
adce				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
adce 6f				db WORD_SYS_CORE+91             
adcf e4 ad			dw .SBTOS            
add1 03				db 2 + 1 
add2 .. 00			db "1+",0              
add5				endm 
# End of macro CWHEAD
add5			; | 1+ ( u -- u )  Increment value on TOS | DONE 
add5			 
add5					FORTH_DSP_VALUEHL 
add5 cd 33 9d			call macro_dsp_valuehl 
add8				endm 
# End of macro FORTH_DSP_VALUEHL
add8 e5					push hl 
add9			 
add9					FORTH_DSP_POP 
add9 cd eb 9d			call macro_forth_dsp_pop 
addc				endm 
# End of macro FORTH_DSP_POP
addc e1					pop hl 
addd			 
addd 23					inc hl 
adde cd 3c 9b				call forth_push_numhl 
ade1					 
ade1					NEXTW 
ade1 c3 e9 9e			jp macro_next 
ade4				endm 
# End of macro NEXTW
ade4			.SBTOS: 
ade4				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ade4 6f				db WORD_SYS_CORE+91             
ade5 fa ad			dw .ADSTORE            
ade7 03				db 2 + 1 
ade8 .. 00			db "1-",0              
adeb				endm 
# End of macro CWHEAD
adeb			; | 1- ( u -- u )  Decrement value on TOS | DONE 
adeb			 
adeb					FORTH_DSP_VALUEHL 
adeb cd 33 9d			call macro_dsp_valuehl 
adee				endm 
# End of macro FORTH_DSP_VALUEHL
adee e5					push hl 
adef			 
adef					FORTH_DSP_POP 
adef cd eb 9d			call macro_forth_dsp_pop 
adf2				endm 
# End of macro FORTH_DSP_POP
adf2 e1					pop hl 
adf3			 
adf3 2b					dec hl 
adf4 cd 3c 9b				call forth_push_numhl 
adf7					 
adf7					NEXTW 
adf7 c3 e9 9e			jp macro_next 
adfa				endm 
# End of macro NEXTW
adfa			.ADSTORE: 
adfa				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
adfa 6f				db WORD_SYS_CORE+91             
adfb 10 ae			dw .ADWSTORE            
adfd 04				db 3 + 1 
adfe .. 00			db "1+!",0              
ae02				endm 
# End of macro CWHEAD
ae02			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ae02			 
ae02					FORTH_DSP_VALUEHL 
ae02 cd 33 9d			call macro_dsp_valuehl 
ae05				endm 
# End of macro FORTH_DSP_VALUEHL
ae05 e5					push hl 
ae06			 
ae06					FORTH_DSP_POP 
ae06 cd eb 9d			call macro_forth_dsp_pop 
ae09				endm 
# End of macro FORTH_DSP_POP
ae09 e1					pop hl 
ae0a			 
ae0a 7e					ld a, (hl) 
ae0b 3c					inc a 
ae0c 77					ld (hl), a 
ae0d					 
ae0d					NEXTW 
ae0d c3 e9 9e			jp macro_next 
ae10				endm 
# End of macro NEXTW
ae10			.ADWSTORE: 
ae10				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
ae10 6f				db WORD_SYS_CORE+91             
ae11 2e ae			dw .ENDCORE            
ae13 05				db 4 + 1 
ae14 .. 00			db "1+2!",0              
ae19				endm 
# End of macro CWHEAD
ae19			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ae19			 
ae19					FORTH_DSP_VALUEHL 
ae19 cd 33 9d			call macro_dsp_valuehl 
ae1c				endm 
# End of macro FORTH_DSP_VALUEHL
ae1c e5					push hl 
ae1d			 
ae1d					FORTH_DSP_POP 
ae1d cd eb 9d			call macro_forth_dsp_pop 
ae20				endm 
# End of macro FORTH_DSP_POP
ae20 e1					pop hl 
ae21			 
ae21 e5					push hl 
ae22			 
ae22 cd 6b 9e				call loadwordinhl 
ae25 23					inc hl 
ae26			 
ae26 d1					pop de 
ae27 eb					ex de, hl 
ae28 73					ld (hl), e 
ae29 23					inc hl 
ae2a 72					ld (hl), d 
ae2b					 
ae2b					NEXTW 
ae2b c3 e9 9e			jp macro_next 
ae2e				endm 
# End of macro NEXTW
ae2e			.ENDCORE: 
ae2e			 
ae2e			; eof 
ae2e			 
ae2e			 
# End of file forth_words_core.asm
ae2e			include "forth_words_flow.asm" 
ae2e			 
ae2e			; | ## Program Flow Words 
ae2e			 
ae2e			.IF: 
ae2e				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae2e 1e				db WORD_SYS_CORE+10             
ae2f 23 af			dw .THEN            
ae31 03				db 2 + 1 
ae32 .. 00			db "IF",0              
ae35				endm 
# End of macro CWHEAD
ae35			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae35			; 
ae35					if DEBUG_FORTH_WORDS_KEY 
ae35						DMARK "IF." 
ae35 f5				push af  
ae36 3a 4a ae			ld a, (.dmark)  
ae39 32 6b ee			ld (debug_mark),a  
ae3c 3a 4b ae			ld a, (.dmark+1)  
ae3f 32 6c ee			ld (debug_mark+1),a  
ae42 3a 4c ae			ld a, (.dmark+2)  
ae45 32 6d ee			ld (debug_mark+2),a  
ae48 18 03			jr .pastdmark  
ae4a ..			.dmark: db "IF."  
ae4d f1			.pastdmark: pop af  
ae4e			endm  
# End of macro DMARK
ae4e						CALLMONITOR 
ae4e cd 6f ee			call debug_vector  
ae51				endm  
# End of macro CALLMONITOR
ae51					endif 
ae51			; eval TOS 
ae51			 
ae51				FORTH_DSP_VALUEHL 
ae51 cd 33 9d			call macro_dsp_valuehl 
ae54				endm 
# End of macro FORTH_DSP_VALUEHL
ae54			 
ae54			;	push hl 
ae54				FORTH_DSP_POP 
ae54 cd eb 9d			call macro_forth_dsp_pop 
ae57				endm 
# End of macro FORTH_DSP_POP
ae57			;	pop hl 
ae57			 
ae57					if DEBUG_FORTH_WORDS 
ae57						DMARK "IF1" 
ae57 f5				push af  
ae58 3a 6c ae			ld a, (.dmark)  
ae5b 32 6b ee			ld (debug_mark),a  
ae5e 3a 6d ae			ld a, (.dmark+1)  
ae61 32 6c ee			ld (debug_mark+1),a  
ae64 3a 6e ae			ld a, (.dmark+2)  
ae67 32 6d ee			ld (debug_mark+2),a  
ae6a 18 03			jr .pastdmark  
ae6c ..			.dmark: db "IF1"  
ae6f f1			.pastdmark: pop af  
ae70			endm  
# End of macro DMARK
ae70						CALLMONITOR 
ae70 cd 6f ee			call debug_vector  
ae73				endm  
# End of macro CALLMONITOR
ae73					endif 
ae73 b7				or a        ; clear carry flag 
ae74 11 00 00			ld de, 0 
ae77 eb				ex de,hl 
ae78 ed 52			sbc hl, de 
ae7a c2 04 af			jp nz, .iftrue 
ae7d			 
ae7d					if DEBUG_FORTH_WORDS 
ae7d						DMARK "IF2" 
ae7d f5				push af  
ae7e 3a 92 ae			ld a, (.dmark)  
ae81 32 6b ee			ld (debug_mark),a  
ae84 3a 93 ae			ld a, (.dmark+1)  
ae87 32 6c ee			ld (debug_mark+1),a  
ae8a 3a 94 ae			ld a, (.dmark+2)  
ae8d 32 6d ee			ld (debug_mark+2),a  
ae90 18 03			jr .pastdmark  
ae92 ..			.dmark: db "IF2"  
ae95 f1			.pastdmark: pop af  
ae96			endm  
# End of macro DMARK
ae96						CALLMONITOR 
ae96 cd 6f ee			call debug_vector  
ae99				endm  
# End of macro CALLMONITOR
ae99					endif 
ae99			 
ae99			; if not true then skip to THEN 
ae99			 
ae99				; TODO get tok_ptr 
ae99				; TODO consume toks until we get to THEN 
ae99			 
ae99 2a c2 e5			ld hl, (os_tok_ptr) 
ae9c					if DEBUG_FORTH_WORDS 
ae9c						DMARK "IF3" 
ae9c f5				push af  
ae9d 3a b1 ae			ld a, (.dmark)  
aea0 32 6b ee			ld (debug_mark),a  
aea3 3a b2 ae			ld a, (.dmark+1)  
aea6 32 6c ee			ld (debug_mark+1),a  
aea9 3a b3 ae			ld a, (.dmark+2)  
aeac 32 6d ee			ld (debug_mark+2),a  
aeaf 18 03			jr .pastdmark  
aeb1 ..			.dmark: db "IF3"  
aeb4 f1			.pastdmark: pop af  
aeb5			endm  
# End of macro DMARK
aeb5						CALLMONITOR 
aeb5 cd 6f ee			call debug_vector  
aeb8				endm  
# End of macro CALLMONITOR
aeb8						 
aeb8					endif 
aeb8 11 ff ae			ld de, .ifthen 
aebb					if DEBUG_FORTH_WORDS 
aebb						DMARK "IF4" 
aebb f5				push af  
aebc 3a d0 ae			ld a, (.dmark)  
aebf 32 6b ee			ld (debug_mark),a  
aec2 3a d1 ae			ld a, (.dmark+1)  
aec5 32 6c ee			ld (debug_mark+1),a  
aec8 3a d2 ae			ld a, (.dmark+2)  
aecb 32 6d ee			ld (debug_mark+2),a  
aece 18 03			jr .pastdmark  
aed0 ..			.dmark: db "IF4"  
aed3 f1			.pastdmark: pop af  
aed4			endm  
# End of macro DMARK
aed4						CALLMONITOR 
aed4 cd 6f ee			call debug_vector  
aed7				endm  
# End of macro CALLMONITOR
aed7					endif 
aed7 cd 04 a0			call findnexttok  
aeda			 
aeda					if DEBUG_FORTH_WORDS 
aeda						DMARK "IF5" 
aeda f5				push af  
aedb 3a ef ae			ld a, (.dmark)  
aede 32 6b ee			ld (debug_mark),a  
aee1 3a f0 ae			ld a, (.dmark+1)  
aee4 32 6c ee			ld (debug_mark+1),a  
aee7 3a f1 ae			ld a, (.dmark+2)  
aeea 32 6d ee			ld (debug_mark+2),a  
aeed 18 03			jr .pastdmark  
aeef ..			.dmark: db "IF5"  
aef2 f1			.pastdmark: pop af  
aef3			endm  
# End of macro DMARK
aef3						CALLMONITOR 
aef3 cd 6f ee			call debug_vector  
aef6				endm  
# End of macro CALLMONITOR
aef6					endif 
aef6				; TODO replace below with ; exec using tok_ptr 
aef6 22 c2 e5			ld (os_tok_ptr), hl 
aef9 c3 7a 9f			jp exec1 
aefc				NEXTW 
aefc c3 e9 9e			jp macro_next 
aeff				endm 
# End of macro NEXTW
aeff			 
aeff .. 00		.ifthen:  db "THEN",0 
af04			 
af04			.iftrue:		 
af04				; Exec next words normally 
af04			 
af04				; if true then exec following IF as normal 
af04					if DEBUG_FORTH_WORDS 
af04						DMARK "IFT" 
af04 f5				push af  
af05 3a 19 af			ld a, (.dmark)  
af08 32 6b ee			ld (debug_mark),a  
af0b 3a 1a af			ld a, (.dmark+1)  
af0e 32 6c ee			ld (debug_mark+1),a  
af11 3a 1b af			ld a, (.dmark+2)  
af14 32 6d ee			ld (debug_mark+2),a  
af17 18 03			jr .pastdmark  
af19 ..			.dmark: db "IFT"  
af1c f1			.pastdmark: pop af  
af1d			endm  
# End of macro DMARK
af1d						CALLMONITOR 
af1d cd 6f ee			call debug_vector  
af20				endm  
# End of macro CALLMONITOR
af20					endif 
af20			 
af20					NEXTW 
af20 c3 e9 9e			jp macro_next 
af23				endm 
# End of macro NEXTW
af23			.THEN: 
af23				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af23 1f				db WORD_SYS_CORE+11             
af24 4b af			dw .ELSE            
af26 05				db 4 + 1 
af27 .. 00			db "THEN",0              
af2c				endm 
# End of macro CWHEAD
af2c			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af2c					if DEBUG_FORTH_WORDS_KEY 
af2c						DMARK "THN" 
af2c f5				push af  
af2d 3a 41 af			ld a, (.dmark)  
af30 32 6b ee			ld (debug_mark),a  
af33 3a 42 af			ld a, (.dmark+1)  
af36 32 6c ee			ld (debug_mark+1),a  
af39 3a 43 af			ld a, (.dmark+2)  
af3c 32 6d ee			ld (debug_mark+2),a  
af3f 18 03			jr .pastdmark  
af41 ..			.dmark: db "THN"  
af44 f1			.pastdmark: pop af  
af45			endm  
# End of macro DMARK
af45						CALLMONITOR 
af45 cd 6f ee			call debug_vector  
af48				endm  
# End of macro CALLMONITOR
af48					endif 
af48					NEXTW 
af48 c3 e9 9e			jp macro_next 
af4b				endm 
# End of macro NEXTW
af4b			.ELSE: 
af4b				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af4b 20				db WORD_SYS_CORE+12             
af4c 73 af			dw .DO            
af4e 03				db 2 + 1 
af4f .. 00			db "ELSE",0              
af54				endm 
# End of macro CWHEAD
af54			; | ELSE ( -- ) Not supported - does nothing | TODO 
af54			 
af54					if DEBUG_FORTH_WORDS_KEY 
af54						DMARK "ELS" 
af54 f5				push af  
af55 3a 69 af			ld a, (.dmark)  
af58 32 6b ee			ld (debug_mark),a  
af5b 3a 6a af			ld a, (.dmark+1)  
af5e 32 6c ee			ld (debug_mark+1),a  
af61 3a 6b af			ld a, (.dmark+2)  
af64 32 6d ee			ld (debug_mark+2),a  
af67 18 03			jr .pastdmark  
af69 ..			.dmark: db "ELS"  
af6c f1			.pastdmark: pop af  
af6d			endm  
# End of macro DMARK
af6d						CALLMONITOR 
af6d cd 6f ee			call debug_vector  
af70				endm  
# End of macro CALLMONITOR
af70					endif 
af70			 
af70			 
af70					NEXTW 
af70 c3 e9 9e			jp macro_next 
af73				endm 
# End of macro NEXTW
af73			.DO: 
af73				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af73 21				db WORD_SYS_CORE+13             
af74 9a b0			dw .LOOP            
af76 03				db 2 + 1 
af77 .. 00			db "DO",0              
af7a				endm 
# End of macro CWHEAD
af7a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af7a			 
af7a					if DEBUG_FORTH_WORDS_KEY 
af7a						DMARK "DO." 
af7a f5				push af  
af7b 3a 8f af			ld a, (.dmark)  
af7e 32 6b ee			ld (debug_mark),a  
af81 3a 90 af			ld a, (.dmark+1)  
af84 32 6c ee			ld (debug_mark+1),a  
af87 3a 91 af			ld a, (.dmark+2)  
af8a 32 6d ee			ld (debug_mark+2),a  
af8d 18 03			jr .pastdmark  
af8f ..			.dmark: db "DO."  
af92 f1			.pastdmark: pop af  
af93			endm  
# End of macro DMARK
af93						CALLMONITOR 
af93 cd 6f ee			call debug_vector  
af96				endm  
# End of macro CALLMONITOR
af96					endif 
af96			;  push pc to rsp stack past the DO 
af96			 
af96 2a c2 e5				ld hl, (os_tok_ptr) 
af99 23					inc hl   ; D 
af9a 23					inc hl  ; O 
af9b 23					inc hl   ; null 
af9c					if DEBUG_FORTH_WORDS 
af9c						DMARK "DO2" 
af9c f5				push af  
af9d 3a b1 af			ld a, (.dmark)  
afa0 32 6b ee			ld (debug_mark),a  
afa3 3a b2 af			ld a, (.dmark+1)  
afa6 32 6c ee			ld (debug_mark+1),a  
afa9 3a b3 af			ld a, (.dmark+2)  
afac 32 6d ee			ld (debug_mark+2),a  
afaf 18 03			jr .pastdmark  
afb1 ..			.dmark: db "DO2"  
afb4 f1			.pastdmark: pop af  
afb5			endm  
# End of macro DMARK
afb5						CALLMONITOR 
afb5 cd 6f ee			call debug_vector  
afb8				endm  
# End of macro CALLMONITOR
afb8					endif 
afb8					FORTH_RSP_NEXT 
afb8 cd e3 9a			call macro_forth_rsp_next 
afbb				endm 
# End of macro FORTH_RSP_NEXT
afbb					if DEBUG_FORTH_WORDS 
afbb						DMARK "DO3" 
afbb f5				push af  
afbc 3a d0 af			ld a, (.dmark)  
afbf 32 6b ee			ld (debug_mark),a  
afc2 3a d1 af			ld a, (.dmark+1)  
afc5 32 6c ee			ld (debug_mark+1),a  
afc8 3a d2 af			ld a, (.dmark+2)  
afcb 32 6d ee			ld (debug_mark+2),a  
afce 18 03			jr .pastdmark  
afd0 ..			.dmark: db "DO3"  
afd3 f1			.pastdmark: pop af  
afd4			endm  
# End of macro DMARK
afd4						CALLMONITOR 
afd4 cd 6f ee			call debug_vector  
afd7				endm  
# End of macro CALLMONITOR
afd7					endif 
afd7			 
afd7					;if DEBUG_FORTH_WORDS 
afd7				;		push hl 
afd7			;		endif  
afd7			 
afd7			; get counters from data stack 
afd7			 
afd7			 
afd7					FORTH_DSP_VALUEHL 
afd7 cd 33 9d			call macro_dsp_valuehl 
afda				endm 
# End of macro FORTH_DSP_VALUEHL
afda e5					push hl		 ; hl now has starting counter which needs to be tos 
afdb			 
afdb					if DEBUG_FORTH_WORDS 
afdb						DMARK "DO4" 
afdb f5				push af  
afdc 3a f0 af			ld a, (.dmark)  
afdf 32 6b ee			ld (debug_mark),a  
afe2 3a f1 af			ld a, (.dmark+1)  
afe5 32 6c ee			ld (debug_mark+1),a  
afe8 3a f2 af			ld a, (.dmark+2)  
afeb 32 6d ee			ld (debug_mark+2),a  
afee 18 03			jr .pastdmark  
aff0 ..			.dmark: db "DO4"  
aff3 f1			.pastdmark: pop af  
aff4			endm  
# End of macro DMARK
aff4						CALLMONITOR 
aff4 cd 6f ee			call debug_vector  
aff7				endm  
# End of macro CALLMONITOR
aff7					endif 
aff7					FORTH_DSP_POP 
aff7 cd eb 9d			call macro_forth_dsp_pop 
affa				endm 
# End of macro FORTH_DSP_POP
affa			 
affa					if DEBUG_FORTH_WORDS 
affa						DMARK "DO5" 
affa f5				push af  
affb 3a 0f b0			ld a, (.dmark)  
affe 32 6b ee			ld (debug_mark),a  
b001 3a 10 b0			ld a, (.dmark+1)  
b004 32 6c ee			ld (debug_mark+1),a  
b007 3a 11 b0			ld a, (.dmark+2)  
b00a 32 6d ee			ld (debug_mark+2),a  
b00d 18 03			jr .pastdmark  
b00f ..			.dmark: db "DO5"  
b012 f1			.pastdmark: pop af  
b013			endm  
# End of macro DMARK
b013						CALLMONITOR 
b013 cd 6f ee			call debug_vector  
b016				endm  
# End of macro CALLMONITOR
b016					endif 
b016			 
b016					FORTH_DSP_VALUEHL 
b016 cd 33 9d			call macro_dsp_valuehl 
b019				endm 
# End of macro FORTH_DSP_VALUEHL
b019			;		push hl		 ; hl now has starting limit counter 
b019			 
b019					if DEBUG_FORTH_WORDS 
b019						DMARK "DO6" 
b019 f5				push af  
b01a 3a 2e b0			ld a, (.dmark)  
b01d 32 6b ee			ld (debug_mark),a  
b020 3a 2f b0			ld a, (.dmark+1)  
b023 32 6c ee			ld (debug_mark+1),a  
b026 3a 30 b0			ld a, (.dmark+2)  
b029 32 6d ee			ld (debug_mark+2),a  
b02c 18 03			jr .pastdmark  
b02e ..			.dmark: db "DO6"  
b031 f1			.pastdmark: pop af  
b032			endm  
# End of macro DMARK
b032						CALLMONITOR 
b032 cd 6f ee			call debug_vector  
b035				endm  
# End of macro CALLMONITOR
b035					endif 
b035					FORTH_DSP_POP 
b035 cd eb 9d			call macro_forth_dsp_pop 
b038				endm 
# End of macro FORTH_DSP_POP
b038			 
b038			; put counters on the loop stack 
b038			 
b038			;		pop hl			 ; limit counter 
b038 d1					pop de			; start counter 
b039			 
b039					; push limit counter 
b039			 
b039					if DEBUG_FORTH_WORDS 
b039						DMARK "DO7" 
b039 f5				push af  
b03a 3a 4e b0			ld a, (.dmark)  
b03d 32 6b ee			ld (debug_mark),a  
b040 3a 4f b0			ld a, (.dmark+1)  
b043 32 6c ee			ld (debug_mark+1),a  
b046 3a 50 b0			ld a, (.dmark+2)  
b049 32 6d ee			ld (debug_mark+2),a  
b04c 18 03			jr .pastdmark  
b04e ..			.dmark: db "DO7"  
b051 f1			.pastdmark: pop af  
b052			endm  
# End of macro DMARK
b052						CALLMONITOR 
b052 cd 6f ee			call debug_vector  
b055				endm  
# End of macro CALLMONITOR
b055					endif 
b055					FORTH_LOOP_NEXT 
b055 cd 64 9d			call macro_forth_loop_next 
b058				endm 
# End of macro FORTH_LOOP_NEXT
b058			 
b058					; push start counter 
b058			 
b058 eb					ex de, hl 
b059					if DEBUG_FORTH_WORDS 
b059						DMARK "DO7" 
b059 f5				push af  
b05a 3a 6e b0			ld a, (.dmark)  
b05d 32 6b ee			ld (debug_mark),a  
b060 3a 6f b0			ld a, (.dmark+1)  
b063 32 6c ee			ld (debug_mark+1),a  
b066 3a 70 b0			ld a, (.dmark+2)  
b069 32 6d ee			ld (debug_mark+2),a  
b06c 18 03			jr .pastdmark  
b06e ..			.dmark: db "DO7"  
b071 f1			.pastdmark: pop af  
b072			endm  
# End of macro DMARK
b072						CALLMONITOR 
b072 cd 6f ee			call debug_vector  
b075				endm  
# End of macro CALLMONITOR
b075					endif 
b075					FORTH_LOOP_NEXT 
b075 cd 64 9d			call macro_forth_loop_next 
b078				endm 
# End of macro FORTH_LOOP_NEXT
b078			 
b078			 
b078					; init first round of I counter 
b078			 
b078 22 e6 e5				ld (os_current_i), hl 
b07b			 
b07b					if DEBUG_FORTH_WORDS 
b07b						DMARK "DO8" 
b07b f5				push af  
b07c 3a 90 b0			ld a, (.dmark)  
b07f 32 6b ee			ld (debug_mark),a  
b082 3a 91 b0			ld a, (.dmark+1)  
b085 32 6c ee			ld (debug_mark+1),a  
b088 3a 92 b0			ld a, (.dmark+2)  
b08b 32 6d ee			ld (debug_mark+2),a  
b08e 18 03			jr .pastdmark  
b090 ..			.dmark: db "DO8"  
b093 f1			.pastdmark: pop af  
b094			endm  
# End of macro DMARK
b094						CALLMONITOR 
b094 cd 6f ee			call debug_vector  
b097				endm  
# End of macro CALLMONITOR
b097					endif 
b097			 
b097					NEXTW 
b097 c3 e9 9e			jp macro_next 
b09a				endm 
# End of macro NEXTW
b09a			.LOOP: 
b09a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b09a 22				db WORD_SYS_CORE+14             
b09b b2 b1			dw .I            
b09d 05				db 4 + 1 
b09e .. 00			db "LOOP",0              
b0a3				endm 
# End of macro CWHEAD
b0a3			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b0a3			 
b0a3				; pop tos as current loop count to hl 
b0a3			 
b0a3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0a3			 
b0a3				FORTH_LOOP_TOS 
b0a3 cd 97 9d			call macro_forth_loop_tos 
b0a6				endm 
# End of macro FORTH_LOOP_TOS
b0a6 e5				push hl 
b0a7			 
b0a7					if DEBUG_FORTH_WORDS_KEY 
b0a7						DMARK "LOP" 
b0a7 f5				push af  
b0a8 3a bc b0			ld a, (.dmark)  
b0ab 32 6b ee			ld (debug_mark),a  
b0ae 3a bd b0			ld a, (.dmark+1)  
b0b1 32 6c ee			ld (debug_mark+1),a  
b0b4 3a be b0			ld a, (.dmark+2)  
b0b7 32 6d ee			ld (debug_mark+2),a  
b0ba 18 03			jr .pastdmark  
b0bc ..			.dmark: db "LOP"  
b0bf f1			.pastdmark: pop af  
b0c0			endm  
# End of macro DMARK
b0c0						CALLMONITOR 
b0c0 cd 6f ee			call debug_vector  
b0c3				endm  
# End of macro CALLMONITOR
b0c3					endif 
b0c3				; next item on the stack is the limit. get it 
b0c3			 
b0c3			 
b0c3				FORTH_LOOP_POP 
b0c3 cd a1 9d			call macro_forth_loop_pop 
b0c6				endm 
# End of macro FORTH_LOOP_POP
b0c6			 
b0c6				FORTH_LOOP_TOS 
b0c6 cd 97 9d			call macro_forth_loop_tos 
b0c9				endm 
# End of macro FORTH_LOOP_TOS
b0c9			 
b0c9 d1				pop de		 ; de = i, hl = limit 
b0ca			 
b0ca					if DEBUG_FORTH_WORDS 
b0ca						DMARK "LP1" 
b0ca f5				push af  
b0cb 3a df b0			ld a, (.dmark)  
b0ce 32 6b ee			ld (debug_mark),a  
b0d1 3a e0 b0			ld a, (.dmark+1)  
b0d4 32 6c ee			ld (debug_mark+1),a  
b0d7 3a e1 b0			ld a, (.dmark+2)  
b0da 32 6d ee			ld (debug_mark+2),a  
b0dd 18 03			jr .pastdmark  
b0df ..			.dmark: db "LP1"  
b0e2 f1			.pastdmark: pop af  
b0e3			endm  
# End of macro DMARK
b0e3						CALLMONITOR 
b0e3 cd 6f ee			call debug_vector  
b0e6				endm  
# End of macro CALLMONITOR
b0e6					endif 
b0e6			 
b0e6				; go back to previous word 
b0e6			 
b0e6 d5				push de    ; save I for inc later 
b0e7			 
b0e7			 
b0e7				; get limit 
b0e7				;  is I at limit? 
b0e7			 
b0e7			 
b0e7					if DEBUG_FORTH_WORDS 
b0e7						DMARK "LP1" 
b0e7 f5				push af  
b0e8 3a fc b0			ld a, (.dmark)  
b0eb 32 6b ee			ld (debug_mark),a  
b0ee 3a fd b0			ld a, (.dmark+1)  
b0f1 32 6c ee			ld (debug_mark+1),a  
b0f4 3a fe b0			ld a, (.dmark+2)  
b0f7 32 6d ee			ld (debug_mark+2),a  
b0fa 18 03			jr .pastdmark  
b0fc ..			.dmark: db "LP1"  
b0ff f1			.pastdmark: pop af  
b100			endm  
# End of macro DMARK
b100						CALLMONITOR 
b100 cd 6f ee			call debug_vector  
b103				endm  
# End of macro CALLMONITOR
b103					endif 
b103			 
b103 ed 52			sbc hl, de 
b105			 
b105			 
b105				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b105			 
b105 20 26				jr nz, .loopnotdone 
b107			 
b107 e1				pop hl   ; get rid of saved I 
b108				FORTH_LOOP_POP     ; get rid of limit 
b108 cd a1 9d			call macro_forth_loop_pop 
b10b				endm 
# End of macro FORTH_LOOP_POP
b10b			 
b10b				FORTH_RSP_POP     ; get rid of DO ptr 
b10b cd 04 9b			call macro_forth_rsp_pop 
b10e				endm 
# End of macro FORTH_RSP_POP
b10e			 
b10e			if DEBUG_FORTH_WORDS 
b10e						DMARK "LP>" 
b10e f5				push af  
b10f 3a 23 b1			ld a, (.dmark)  
b112 32 6b ee			ld (debug_mark),a  
b115 3a 24 b1			ld a, (.dmark+1)  
b118 32 6c ee			ld (debug_mark+1),a  
b11b 3a 25 b1			ld a, (.dmark+2)  
b11e 32 6d ee			ld (debug_mark+2),a  
b121 18 03			jr .pastdmark  
b123 ..			.dmark: db "LP>"  
b126 f1			.pastdmark: pop af  
b127			endm  
# End of macro DMARK
b127				CALLMONITOR 
b127 cd 6f ee			call debug_vector  
b12a				endm  
# End of macro CALLMONITOR
b12a			endif 
b12a			 
b12a					NEXTW 
b12a c3 e9 9e			jp macro_next 
b12d				endm 
# End of macro NEXTW
b12d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b12d			 
b12d			.loopnotdone: 
b12d			 
b12d e1				pop hl    ; get I 
b12e 23				inc hl 
b12f			 
b12f			   	; save new I 
b12f			 
b12f			 
b12f					; set I counter 
b12f			 
b12f 22 e6 e5				ld (os_current_i), hl 
b132			 
b132					if DEBUG_FORTH_WORDS 
b132						DMARK "LPN" 
b132 f5				push af  
b133 3a 47 b1			ld a, (.dmark)  
b136 32 6b ee			ld (debug_mark),a  
b139 3a 48 b1			ld a, (.dmark+1)  
b13c 32 6c ee			ld (debug_mark+1),a  
b13f 3a 49 b1			ld a, (.dmark+2)  
b142 32 6d ee			ld (debug_mark+2),a  
b145 18 03			jr .pastdmark  
b147 ..			.dmark: db "LPN"  
b14a f1			.pastdmark: pop af  
b14b			endm  
# End of macro DMARK
b14b					CALLMONITOR 
b14b cd 6f ee			call debug_vector  
b14e				endm  
# End of macro CALLMONITOR
b14e					endif 
b14e					 
b14e				FORTH_LOOP_NEXT 
b14e cd 64 9d			call macro_forth_loop_next 
b151				endm 
# End of macro FORTH_LOOP_NEXT
b151			 
b151			 
b151					if DEBUG_FORTH_WORDS 
b151 eb						ex de,hl 
b152					endif 
b152			 
b152			;	; get DO ptr 
b152			; 
b152					if DEBUG_FORTH_WORDS 
b152						DMARK "LP7" 
b152 f5				push af  
b153 3a 67 b1			ld a, (.dmark)  
b156 32 6b ee			ld (debug_mark),a  
b159 3a 68 b1			ld a, (.dmark+1)  
b15c 32 6c ee			ld (debug_mark+1),a  
b15f 3a 69 b1			ld a, (.dmark+2)  
b162 32 6d ee			ld (debug_mark+2),a  
b165 18 03			jr .pastdmark  
b167 ..			.dmark: db "LP7"  
b16a f1			.pastdmark: pop af  
b16b			endm  
# End of macro DMARK
b16b					CALLMONITOR 
b16b cd 6f ee			call debug_vector  
b16e				endm  
# End of macro CALLMONITOR
b16e					endif 
b16e				FORTH_RSP_TOS 
b16e cd fa 9a			call macro_forth_rsp_tos 
b171				endm 
# End of macro FORTH_RSP_TOS
b171			 
b171					if DEBUG_FORTH_WORDS 
b171						DMARK "LP8" 
b171 f5				push af  
b172 3a 86 b1			ld a, (.dmark)  
b175 32 6b ee			ld (debug_mark),a  
b178 3a 87 b1			ld a, (.dmark+1)  
b17b 32 6c ee			ld (debug_mark+1),a  
b17e 3a 88 b1			ld a, (.dmark+2)  
b181 32 6d ee			ld (debug_mark+2),a  
b184 18 03			jr .pastdmark  
b186 ..			.dmark: db "LP8"  
b189 f1			.pastdmark: pop af  
b18a			endm  
# End of macro DMARK
b18a					CALLMONITOR 
b18a cd 6f ee			call debug_vector  
b18d				endm  
# End of macro CALLMONITOR
b18d					endif 
b18d				;push hl 
b18d			 
b18d				; not going to DO any more 
b18d				; get rid of the RSP pointer as DO will add it back in 
b18d				;FORTH_RSP_POP 
b18d				;pop hl 
b18d			 
b18d				;ld hl,(cli_ret_sp) 
b18d				;ld e, (hl) 
b18d				;inc hl 
b18d				;ld d, (hl) 
b18d				;ex de,hl 
b18d 22 c2 e5			ld (os_tok_ptr), hl 
b190					if DEBUG_FORTH_WORDS 
b190						DMARK "LP<" 
b190 f5				push af  
b191 3a a5 b1			ld a, (.dmark)  
b194 32 6b ee			ld (debug_mark),a  
b197 3a a6 b1			ld a, (.dmark+1)  
b19a 32 6c ee			ld (debug_mark+1),a  
b19d 3a a7 b1			ld a, (.dmark+2)  
b1a0 32 6d ee			ld (debug_mark+2),a  
b1a3 18 03			jr .pastdmark  
b1a5 ..			.dmark: db "LP<"  
b1a8 f1			.pastdmark: pop af  
b1a9			endm  
# End of macro DMARK
b1a9					CALLMONITOR 
b1a9 cd 6f ee			call debug_vector  
b1ac				endm  
# End of macro CALLMONITOR
b1ac				endif 
b1ac c3 7a 9f			jp exec1 
b1af			 
b1af					 
b1af			 
b1af			 
b1af					NEXTW 
b1af c3 e9 9e			jp macro_next 
b1b2				endm 
# End of macro NEXTW
b1b2			.I:  
b1b2			 
b1b2				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b1b2 5e				db WORD_SYS_CORE+74             
b1b3 dd b1			dw .DLOOP            
b1b5 02				db 1 + 1 
b1b6 .. 00			db "I",0              
b1b8				endm 
# End of macro CWHEAD
b1b8			; | I ( -- ) Current loop counter | DONE 
b1b8					if DEBUG_FORTH_WORDS_KEY 
b1b8						DMARK "I.." 
b1b8 f5				push af  
b1b9 3a cd b1			ld a, (.dmark)  
b1bc 32 6b ee			ld (debug_mark),a  
b1bf 3a ce b1			ld a, (.dmark+1)  
b1c2 32 6c ee			ld (debug_mark+1),a  
b1c5 3a cf b1			ld a, (.dmark+2)  
b1c8 32 6d ee			ld (debug_mark+2),a  
b1cb 18 03			jr .pastdmark  
b1cd ..			.dmark: db "I.."  
b1d0 f1			.pastdmark: pop af  
b1d1			endm  
# End of macro DMARK
b1d1						CALLMONITOR 
b1d1 cd 6f ee			call debug_vector  
b1d4				endm  
# End of macro CALLMONITOR
b1d4					endif 
b1d4			 
b1d4 2a e6 e5				ld hl,(os_current_i) 
b1d7 cd 3c 9b				call forth_push_numhl 
b1da			 
b1da					NEXTW 
b1da c3 e9 9e			jp macro_next 
b1dd				endm 
# End of macro NEXTW
b1dd			.DLOOP: 
b1dd				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b1dd 5f				db WORD_SYS_CORE+75             
b1de be b2			dw .REPEAT            
b1e0 06				db 5 + 1 
b1e1 .. 00			db "-LOOP",0              
b1e7				endm 
# End of macro CWHEAD
b1e7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b1e7				; pop tos as current loop count to hl 
b1e7					if DEBUG_FORTH_WORDS_KEY 
b1e7						DMARK "-LP" 
b1e7 f5				push af  
b1e8 3a fc b1			ld a, (.dmark)  
b1eb 32 6b ee			ld (debug_mark),a  
b1ee 3a fd b1			ld a, (.dmark+1)  
b1f1 32 6c ee			ld (debug_mark+1),a  
b1f4 3a fe b1			ld a, (.dmark+2)  
b1f7 32 6d ee			ld (debug_mark+2),a  
b1fa 18 03			jr .pastdmark  
b1fc ..			.dmark: db "-LP"  
b1ff f1			.pastdmark: pop af  
b200			endm  
# End of macro DMARK
b200						CALLMONITOR 
b200 cd 6f ee			call debug_vector  
b203				endm  
# End of macro CALLMONITOR
b203					endif 
b203			 
b203				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b203			 
b203				FORTH_LOOP_TOS 
b203 cd 97 9d			call macro_forth_loop_tos 
b206				endm 
# End of macro FORTH_LOOP_TOS
b206 e5				push hl 
b207			 
b207					if DEBUG_FORTH_WORDS 
b207						DMARK "-LP" 
b207 f5				push af  
b208 3a 1c b2			ld a, (.dmark)  
b20b 32 6b ee			ld (debug_mark),a  
b20e 3a 1d b2			ld a, (.dmark+1)  
b211 32 6c ee			ld (debug_mark+1),a  
b214 3a 1e b2			ld a, (.dmark+2)  
b217 32 6d ee			ld (debug_mark+2),a  
b21a 18 03			jr .pastdmark  
b21c ..			.dmark: db "-LP"  
b21f f1			.pastdmark: pop af  
b220			endm  
# End of macro DMARK
b220						CALLMONITOR 
b220 cd 6f ee			call debug_vector  
b223				endm  
# End of macro CALLMONITOR
b223					endif 
b223				; next item on the stack is the limit. get it 
b223			 
b223			 
b223				FORTH_LOOP_POP 
b223 cd a1 9d			call macro_forth_loop_pop 
b226				endm 
# End of macro FORTH_LOOP_POP
b226			 
b226				FORTH_LOOP_TOS 
b226 cd 97 9d			call macro_forth_loop_tos 
b229				endm 
# End of macro FORTH_LOOP_TOS
b229			 
b229 d1				pop de		 ; de = i, hl = limit 
b22a			 
b22a					if DEBUG_FORTH_WORDS 
b22a						DMARK "-L1" 
b22a f5				push af  
b22b 3a 3f b2			ld a, (.dmark)  
b22e 32 6b ee			ld (debug_mark),a  
b231 3a 40 b2			ld a, (.dmark+1)  
b234 32 6c ee			ld (debug_mark+1),a  
b237 3a 41 b2			ld a, (.dmark+2)  
b23a 32 6d ee			ld (debug_mark+2),a  
b23d 18 03			jr .pastdmark  
b23f ..			.dmark: db "-L1"  
b242 f1			.pastdmark: pop af  
b243			endm  
# End of macro DMARK
b243						CALLMONITOR 
b243 cd 6f ee			call debug_vector  
b246				endm  
# End of macro CALLMONITOR
b246					endif 
b246			 
b246				; go back to previous word 
b246			 
b246 d5				push de    ; save I for inc later 
b247			 
b247			 
b247				; get limit 
b247				;  is I at limit? 
b247			 
b247			 
b247					if DEBUG_FORTH_WORDS 
b247						DMARK "-L1" 
b247 f5				push af  
b248 3a 5c b2			ld a, (.dmark)  
b24b 32 6b ee			ld (debug_mark),a  
b24e 3a 5d b2			ld a, (.dmark+1)  
b251 32 6c ee			ld (debug_mark+1),a  
b254 3a 5e b2			ld a, (.dmark+2)  
b257 32 6d ee			ld (debug_mark+2),a  
b25a 18 03			jr .pastdmark  
b25c ..			.dmark: db "-L1"  
b25f f1			.pastdmark: pop af  
b260			endm  
# End of macro DMARK
b260						CALLMONITOR 
b260 cd 6f ee			call debug_vector  
b263				endm  
# End of macro CALLMONITOR
b263					endif 
b263			 
b263 ed 52			sbc hl, de 
b265			 
b265			 
b265				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b265			 
b265 20 26				jr nz, .mloopnotdone 
b267			 
b267 e1				pop hl   ; get rid of saved I 
b268				FORTH_LOOP_POP     ; get rid of limit 
b268 cd a1 9d			call macro_forth_loop_pop 
b26b				endm 
# End of macro FORTH_LOOP_POP
b26b			 
b26b				FORTH_RSP_POP     ; get rid of DO ptr 
b26b cd 04 9b			call macro_forth_rsp_pop 
b26e				endm 
# End of macro FORTH_RSP_POP
b26e			 
b26e			if DEBUG_FORTH_WORDS 
b26e						DMARK "-L>" 
b26e f5				push af  
b26f 3a 83 b2			ld a, (.dmark)  
b272 32 6b ee			ld (debug_mark),a  
b275 3a 84 b2			ld a, (.dmark+1)  
b278 32 6c ee			ld (debug_mark+1),a  
b27b 3a 85 b2			ld a, (.dmark+2)  
b27e 32 6d ee			ld (debug_mark+2),a  
b281 18 03			jr .pastdmark  
b283 ..			.dmark: db "-L>"  
b286 f1			.pastdmark: pop af  
b287			endm  
# End of macro DMARK
b287				CALLMONITOR 
b287 cd 6f ee			call debug_vector  
b28a				endm  
# End of macro CALLMONITOR
b28a			endif 
b28a			 
b28a					NEXTW 
b28a c3 e9 9e			jp macro_next 
b28d				endm 
# End of macro NEXTW
b28d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b28d			 
b28d			.mloopnotdone: 
b28d			 
b28d e1				pop hl    ; get I 
b28e 2b				dec hl 
b28f			 
b28f			   	; save new I 
b28f			 
b28f			 
b28f					; set I counter 
b28f			 
b28f 22 e6 e5				ld (os_current_i), hl 
b292			 
b292					 
b292				FORTH_LOOP_NEXT 
b292 cd 64 9d			call macro_forth_loop_next 
b295				endm 
# End of macro FORTH_LOOP_NEXT
b295			 
b295			 
b295					if DEBUG_FORTH_WORDS 
b295 eb						ex de,hl 
b296					endif 
b296			 
b296			;	; get DO ptr 
b296			; 
b296				FORTH_RSP_TOS 
b296 cd fa 9a			call macro_forth_rsp_tos 
b299				endm 
# End of macro FORTH_RSP_TOS
b299			 
b299				;push hl 
b299			 
b299				; not going to DO any more 
b299				; get rid of the RSP pointer as DO will add it back in 
b299				;FORTH_RSP_POP 
b299				;pop hl 
b299			 
b299			 
b299 22 c2 e5			ld (os_tok_ptr), hl 
b29c					if DEBUG_FORTH_WORDS 
b29c						DMARK "-L<" 
b29c f5				push af  
b29d 3a b1 b2			ld a, (.dmark)  
b2a0 32 6b ee			ld (debug_mark),a  
b2a3 3a b2 b2			ld a, (.dmark+1)  
b2a6 32 6c ee			ld (debug_mark+1),a  
b2a9 3a b3 b2			ld a, (.dmark+2)  
b2ac 32 6d ee			ld (debug_mark+2),a  
b2af 18 03			jr .pastdmark  
b2b1 ..			.dmark: db "-L<"  
b2b4 f1			.pastdmark: pop af  
b2b5			endm  
# End of macro DMARK
b2b5					CALLMONITOR 
b2b5 cd 6f ee			call debug_vector  
b2b8				endm  
# End of macro CALLMONITOR
b2b8				endif 
b2b8 c3 7a 9f			jp exec1 
b2bb			 
b2bb					 
b2bb			 
b2bb			 
b2bb			 
b2bb				NEXTW 
b2bb c3 e9 9e			jp macro_next 
b2be				endm 
# End of macro NEXTW
b2be			 
b2be			 
b2be			 
b2be			 
b2be			.REPEAT: 
b2be				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b2be 71				db WORD_SYS_CORE+93             
b2bf 11 b3			dw .UNTIL            
b2c1 06				db 5 + 1 
b2c2 .. 00			db "REPEAT",0              
b2c9				endm 
# End of macro CWHEAD
b2c9			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b2c9			;  push pc to rsp stack past the REPEAT 
b2c9					if DEBUG_FORTH_WORDS_KEY 
b2c9						DMARK "REP" 
b2c9 f5				push af  
b2ca 3a de b2			ld a, (.dmark)  
b2cd 32 6b ee			ld (debug_mark),a  
b2d0 3a df b2			ld a, (.dmark+1)  
b2d3 32 6c ee			ld (debug_mark+1),a  
b2d6 3a e0 b2			ld a, (.dmark+2)  
b2d9 32 6d ee			ld (debug_mark+2),a  
b2dc 18 03			jr .pastdmark  
b2de ..			.dmark: db "REP"  
b2e1 f1			.pastdmark: pop af  
b2e2			endm  
# End of macro DMARK
b2e2						CALLMONITOR 
b2e2 cd 6f ee			call debug_vector  
b2e5				endm  
# End of macro CALLMONITOR
b2e5					endif 
b2e5			 
b2e5 2a c2 e5				ld hl, (os_tok_ptr) 
b2e8 23					inc hl   ; R 
b2e9 23					inc hl  ; E 
b2ea 23					inc hl   ; P 
b2eb 23					inc hl   ; E 
b2ec 23					inc hl   ; A 
b2ed 23					inc hl   ; T 
b2ee 23					inc hl   ; zero 
b2ef					FORTH_RSP_NEXT 
b2ef cd e3 9a			call macro_forth_rsp_next 
b2f2				endm 
# End of macro FORTH_RSP_NEXT
b2f2			 
b2f2			 
b2f2					if DEBUG_FORTH_WORDS 
b2f2						DMARK "REP" 
b2f2 f5				push af  
b2f3 3a 07 b3			ld a, (.dmark)  
b2f6 32 6b ee			ld (debug_mark),a  
b2f9 3a 08 b3			ld a, (.dmark+1)  
b2fc 32 6c ee			ld (debug_mark+1),a  
b2ff 3a 09 b3			ld a, (.dmark+2)  
b302 32 6d ee			ld (debug_mark+2),a  
b305 18 03			jr .pastdmark  
b307 ..			.dmark: db "REP"  
b30a f1			.pastdmark: pop af  
b30b			endm  
# End of macro DMARK
b30b						;pop bc    ; TODO BUG ?????? what is this for???? 
b30b						CALLMONITOR 
b30b cd 6f ee			call debug_vector  
b30e				endm  
# End of macro CALLMONITOR
b30e					endif 
b30e			 
b30e					NEXTW 
b30e c3 e9 9e			jp macro_next 
b311				endm 
# End of macro NEXTW
b311			;	       NEXTW 
b311			 
b311			.UNTIL: 
b311				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b311 72				db WORD_SYS_CORE+94             
b312 a8 b3			dw .ENDFLOW            
b314 06				db 5 + 1 
b315 .. 00			db "UNTIL",0              
b31b				endm 
# End of macro CWHEAD
b31b			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b31b			 
b31b				; pop tos as check 
b31b			 
b31b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b31b			 
b31b				FORTH_DSP_VALUEHL 
b31b cd 33 9d			call macro_dsp_valuehl 
b31e				endm 
# End of macro FORTH_DSP_VALUEHL
b31e			 
b31e					if DEBUG_FORTH_WORDS_KEY 
b31e						DMARK "UNT" 
b31e f5				push af  
b31f 3a 33 b3			ld a, (.dmark)  
b322 32 6b ee			ld (debug_mark),a  
b325 3a 34 b3			ld a, (.dmark+1)  
b328 32 6c ee			ld (debug_mark+1),a  
b32b 3a 35 b3			ld a, (.dmark+2)  
b32e 32 6d ee			ld (debug_mark+2),a  
b331 18 03			jr .pastdmark  
b333 ..			.dmark: db "UNT"  
b336 f1			.pastdmark: pop af  
b337			endm  
# End of macro DMARK
b337						CALLMONITOR 
b337 cd 6f ee			call debug_vector  
b33a				endm  
# End of macro CALLMONITOR
b33a					endif 
b33a			 
b33a			;	push hl 
b33a				FORTH_DSP_POP 
b33a cd eb 9d			call macro_forth_dsp_pop 
b33d				endm 
# End of macro FORTH_DSP_POP
b33d			 
b33d			;	pop hl 
b33d			 
b33d				; test if true 
b33d			 
b33d cd 05 8d			call ishlzero 
b340			;	ld a,l 
b340			;	add h 
b340			; 
b340			;	cp 0 
b340			 
b340 20 3e			jr nz, .untilnotdone 
b342			 
b342					if DEBUG_FORTH_WORDS 
b342						DMARK "UNf" 
b342 f5				push af  
b343 3a 57 b3			ld a, (.dmark)  
b346 32 6b ee			ld (debug_mark),a  
b349 3a 58 b3			ld a, (.dmark+1)  
b34c 32 6c ee			ld (debug_mark+1),a  
b34f 3a 59 b3			ld a, (.dmark+2)  
b352 32 6d ee			ld (debug_mark+2),a  
b355 18 03			jr .pastdmark  
b357 ..			.dmark: db "UNf"  
b35a f1			.pastdmark: pop af  
b35b			endm  
# End of macro DMARK
b35b						CALLMONITOR 
b35b cd 6f ee			call debug_vector  
b35e				endm  
# End of macro CALLMONITOR
b35e					endif 
b35e			 
b35e			 
b35e			 
b35e				FORTH_RSP_POP     ; get rid of DO ptr 
b35e cd 04 9b			call macro_forth_rsp_pop 
b361				endm 
# End of macro FORTH_RSP_POP
b361			 
b361			if DEBUG_FORTH_WORDS 
b361						DMARK "UN>" 
b361 f5				push af  
b362 3a 76 b3			ld a, (.dmark)  
b365 32 6b ee			ld (debug_mark),a  
b368 3a 77 b3			ld a, (.dmark+1)  
b36b 32 6c ee			ld (debug_mark+1),a  
b36e 3a 78 b3			ld a, (.dmark+2)  
b371 32 6d ee			ld (debug_mark+2),a  
b374 18 03			jr .pastdmark  
b376 ..			.dmark: db "UN>"  
b379 f1			.pastdmark: pop af  
b37a			endm  
# End of macro DMARK
b37a				CALLMONITOR 
b37a cd 6f ee			call debug_vector  
b37d				endm  
# End of macro CALLMONITOR
b37d			endif 
b37d			 
b37d					NEXTW 
b37d c3 e9 9e			jp macro_next 
b380				endm 
# End of macro NEXTW
b380				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b380			 
b380			.untilnotdone: 
b380			 
b380			 
b380			;	; get DO ptr 
b380			; 
b380				FORTH_RSP_TOS 
b380 cd fa 9a			call macro_forth_rsp_tos 
b383				endm 
# End of macro FORTH_RSP_TOS
b383			 
b383				;push hl 
b383			 
b383				; not going to DO any more 
b383				; get rid of the RSP pointer as DO will add it back in 
b383				;FORTH_RSP_POP 
b383				;pop hl 
b383			 
b383			 
b383 22 c2 e5			ld (os_tok_ptr), hl 
b386					if DEBUG_FORTH_WORDS 
b386						DMARK "UN<" 
b386 f5				push af  
b387 3a 9b b3			ld a, (.dmark)  
b38a 32 6b ee			ld (debug_mark),a  
b38d 3a 9c b3			ld a, (.dmark+1)  
b390 32 6c ee			ld (debug_mark+1),a  
b393 3a 9d b3			ld a, (.dmark+2)  
b396 32 6d ee			ld (debug_mark+2),a  
b399 18 03			jr .pastdmark  
b39b ..			.dmark: db "UN<"  
b39e f1			.pastdmark: pop af  
b39f			endm  
# End of macro DMARK
b39f					CALLMONITOR 
b39f cd 6f ee			call debug_vector  
b3a2				endm  
# End of macro CALLMONITOR
b3a2				endif 
b3a2 c3 7a 9f			jp exec1 
b3a5			 
b3a5					 
b3a5			 
b3a5			 
b3a5					NEXTW 
b3a5 c3 e9 9e			jp macro_next 
b3a8				endm 
# End of macro NEXTW
b3a8			 
b3a8			 
b3a8			.ENDFLOW: 
b3a8			 
b3a8			; eof 
b3a8			 
# End of file forth_words_flow.asm
b3a8			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b3a8			include "forth_words_logic.asm" 
b3a8			 
b3a8			; | ## Logic Words 
b3a8			 
b3a8			.NOT: 
b3a8				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b3a8 2d				db WORD_SYS_CORE+25             
b3a9 f0 b3			dw .IS            
b3ab 04				db 3 + 1 
b3ac .. 00			db "NOT",0              
b3b0				endm 
# End of macro CWHEAD
b3b0			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b3b0					if DEBUG_FORTH_WORDS_KEY 
b3b0						DMARK "NOT" 
b3b0 f5				push af  
b3b1 3a c5 b3			ld a, (.dmark)  
b3b4 32 6b ee			ld (debug_mark),a  
b3b7 3a c6 b3			ld a, (.dmark+1)  
b3ba 32 6c ee			ld (debug_mark+1),a  
b3bd 3a c7 b3			ld a, (.dmark+2)  
b3c0 32 6d ee			ld (debug_mark+2),a  
b3c3 18 03			jr .pastdmark  
b3c5 ..			.dmark: db "NOT"  
b3c8 f1			.pastdmark: pop af  
b3c9			endm  
# End of macro DMARK
b3c9						CALLMONITOR 
b3c9 cd 6f ee			call debug_vector  
b3cc				endm  
# End of macro CALLMONITOR
b3cc					endif 
b3cc					FORTH_DSP 
b3cc cd f9 9c			call macro_forth_dsp 
b3cf				endm 
# End of macro FORTH_DSP
b3cf 7e					ld a,(hl)	; get type of value on TOS 
b3d0 fe 02				cp DS_TYPE_INUM  
b3d2 28 03				jr z, .noti 
b3d4					NEXTW 
b3d4 c3 e9 9e			jp macro_next 
b3d7				endm 
# End of macro NEXTW
b3d7			.noti:          FORTH_DSP_VALUEHL 
b3d7 cd 33 9d			call macro_dsp_valuehl 
b3da				endm 
# End of macro FORTH_DSP_VALUEHL
b3da			;		push hl 
b3da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3da cd eb 9d			call macro_forth_dsp_pop 
b3dd				endm 
# End of macro FORTH_DSP_POP
b3dd			;		pop hl 
b3dd 3e 00				ld a,0 
b3df bd					cp l 
b3e0 28 04				jr z, .not2t 
b3e2 2e 00				ld l, 0 
b3e4 18 02				jr .notip 
b3e6			 
b3e6 2e ff		.not2t:		ld l, 255 
b3e8			 
b3e8 26 00		.notip:		ld h, 0	 
b3ea			 
b3ea cd 3c 9b				call forth_push_numhl 
b3ed					NEXTW 
b3ed c3 e9 9e			jp macro_next 
b3f0				endm 
# End of macro NEXTW
b3f0			 
b3f0			.IS: 
b3f0				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b3f0 2d				db WORD_SYS_CORE+25             
b3f1 16 b4			dw .LZERO            
b3f3 03				db 2 + 1 
b3f4 .. 00			db "IS",0              
b3f7				endm 
# End of macro CWHEAD
b3f7			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3f7					if DEBUG_FORTH_WORDS_KEY 
b3f7						DMARK "IS." 
b3f7 f5				push af  
b3f8 3a 0c b4			ld a, (.dmark)  
b3fb 32 6b ee			ld (debug_mark),a  
b3fe 3a 0d b4			ld a, (.dmark+1)  
b401 32 6c ee			ld (debug_mark+1),a  
b404 3a 0e b4			ld a, (.dmark+2)  
b407 32 6d ee			ld (debug_mark+2),a  
b40a 18 03			jr .pastdmark  
b40c ..			.dmark: db "IS."  
b40f f1			.pastdmark: pop af  
b410			endm  
# End of macro DMARK
b410						CALLMONITOR 
b410 cd 6f ee			call debug_vector  
b413				endm  
# End of macro CALLMONITOR
b413					endif 
b413					NEXTW 
b413 c3 e9 9e			jp macro_next 
b416				endm 
# End of macro NEXTW
b416			.LZERO: 
b416				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b416 2d				db WORD_SYS_CORE+25             
b417 20 b4			dw .TZERO            
b419 03				db 2 + 1 
b41a .. 00			db "0<",0              
b41d				endm 
# End of macro CWHEAD
b41d			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b41d					NEXTW 
b41d c3 e9 9e			jp macro_next 
b420				endm 
# End of macro NEXTW
b420			.TZERO: 
b420				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b420 2e				db WORD_SYS_CORE+26             
b421 67 b4			dw .LESS            
b423 03				db 2 + 1 
b424 .. 00			db "0=",0              
b427				endm 
# End of macro CWHEAD
b427			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b427				; TODO add floating point number detection 
b427					;v5 FORTH_DSP_VALUE 
b427					if DEBUG_FORTH_WORDS_KEY 
b427						DMARK "0=." 
b427 f5				push af  
b428 3a 3c b4			ld a, (.dmark)  
b42b 32 6b ee			ld (debug_mark),a  
b42e 3a 3d b4			ld a, (.dmark+1)  
b431 32 6c ee			ld (debug_mark+1),a  
b434 3a 3e b4			ld a, (.dmark+2)  
b437 32 6d ee			ld (debug_mark+2),a  
b43a 18 03			jr .pastdmark  
b43c ..			.dmark: db "0=."  
b43f f1			.pastdmark: pop af  
b440			endm  
# End of macro DMARK
b440						CALLMONITOR 
b440 cd 6f ee			call debug_vector  
b443				endm  
# End of macro CALLMONITOR
b443					endif 
b443					FORTH_DSP 
b443 cd f9 9c			call macro_forth_dsp 
b446				endm 
# End of macro FORTH_DSP
b446 7e					ld a,(hl)	; get type of value on TOS 
b447 fe 02				cp DS_TYPE_INUM  
b449 28 00				jr z, .tz_inum 
b44b			 
b44b				if FORTH_ENABLE_FLOATMATH 
b44b					jr .tz_done 
b44b			 
b44b				endif 
b44b					 
b44b			 
b44b			.tz_inum: 
b44b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b44b cd 33 9d			call macro_dsp_valuehl 
b44e				endm 
# End of macro FORTH_DSP_VALUEHL
b44e			 
b44e			;		push hl 
b44e			 
b44e					; destroy value TOS 
b44e			 
b44e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44e cd eb 9d			call macro_forth_dsp_pop 
b451				endm 
# End of macro FORTH_DSP_POP
b451			 
b451			;		pop hl 
b451			 
b451 3e 00				ld a,0 
b453			 
b453 bd					cp l 
b454 20 08				jr nz, .tz_notzero 
b456			 
b456 bc					cp h 
b457			 
b457 20 05				jr nz, .tz_notzero 
b459			 
b459			 
b459 21 01 00				ld hl, FORTH_TRUE 
b45c 18 03				jr .tz_done 
b45e			 
b45e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b461			 
b461					; push value back onto stack for another op etc 
b461			 
b461			.tz_done: 
b461 cd 3c 9b				call forth_push_numhl 
b464			 
b464					NEXTW 
b464 c3 e9 9e			jp macro_next 
b467				endm 
# End of macro NEXTW
b467			.LESS: 
b467				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b467 2f				db WORD_SYS_CORE+27             
b468 d0 b4			dw .GT            
b46a 02				db 1 + 1 
b46b .. 00			db "<",0              
b46d				endm 
# End of macro CWHEAD
b46d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b46d				; TODO add floating point number detection 
b46d					if DEBUG_FORTH_WORDS_KEY 
b46d						DMARK "LES" 
b46d f5				push af  
b46e 3a 82 b4			ld a, (.dmark)  
b471 32 6b ee			ld (debug_mark),a  
b474 3a 83 b4			ld a, (.dmark+1)  
b477 32 6c ee			ld (debug_mark+1),a  
b47a 3a 84 b4			ld a, (.dmark+2)  
b47d 32 6d ee			ld (debug_mark+2),a  
b480 18 03			jr .pastdmark  
b482 ..			.dmark: db "LES"  
b485 f1			.pastdmark: pop af  
b486			endm  
# End of macro DMARK
b486						CALLMONITOR 
b486 cd 6f ee			call debug_vector  
b489				endm  
# End of macro CALLMONITOR
b489					endif 
b489					FORTH_DSP 
b489 cd f9 9c			call macro_forth_dsp 
b48c				endm 
# End of macro FORTH_DSP
b48c					;v5 FORTH_DSP_VALUE 
b48c 7e					ld a,(hl)	; get type of value on TOS 
b48d fe 02				cp DS_TYPE_INUM  
b48f 28 00				jr z, .less_inum 
b491			 
b491				if FORTH_ENABLE_FLOATMATH 
b491					jr .less_done 
b491			 
b491				endif 
b491					 
b491			 
b491			.less_inum: 
b491					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b491 cd 33 9d			call macro_dsp_valuehl 
b494				endm 
# End of macro FORTH_DSP_VALUEHL
b494			 
b494 e5					push hl  ; u2 
b495			 
b495					; destroy value TOS 
b495			 
b495					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b495 cd eb 9d			call macro_forth_dsp_pop 
b498				endm 
# End of macro FORTH_DSP_POP
b498			 
b498			 
b498					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b498 cd 33 9d			call macro_dsp_valuehl 
b49b				endm 
# End of macro FORTH_DSP_VALUEHL
b49b			 
b49b e5					push hl    ; u1 
b49c			 
b49c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b49c cd eb 9d			call macro_forth_dsp_pop 
b49f				endm 
# End of macro FORTH_DSP_POP
b49f			 
b49f			 
b49f b7			 or a      ;clear carry flag 
b4a0 01 00 00		 ld bc, FORTH_FALSE 
b4a3 e1			  pop hl    ; u1 
b4a4 d1			  pop de    ; u2 
b4a5 ed 52		  sbc hl,de 
b4a7 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b4a9			 
b4a9 01 01 00		 ld bc, FORTH_TRUE 
b4ac			.lscont:  
b4ac c5					push bc 
b4ad e1					pop hl 
b4ae			 
b4ae					if DEBUG_FORTH_WORDS 
b4ae						DMARK "LT1" 
b4ae f5				push af  
b4af 3a c3 b4			ld a, (.dmark)  
b4b2 32 6b ee			ld (debug_mark),a  
b4b5 3a c4 b4			ld a, (.dmark+1)  
b4b8 32 6c ee			ld (debug_mark+1),a  
b4bb 3a c5 b4			ld a, (.dmark+2)  
b4be 32 6d ee			ld (debug_mark+2),a  
b4c1 18 03			jr .pastdmark  
b4c3 ..			.dmark: db "LT1"  
b4c6 f1			.pastdmark: pop af  
b4c7			endm  
# End of macro DMARK
b4c7						CALLMONITOR 
b4c7 cd 6f ee			call debug_vector  
b4ca				endm  
# End of macro CALLMONITOR
b4ca					endif 
b4ca cd 3c 9b				call forth_push_numhl 
b4cd			 
b4cd					NEXTW 
b4cd c3 e9 9e			jp macro_next 
b4d0				endm 
# End of macro NEXTW
b4d0			.GT: 
b4d0				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b4d0 30				db WORD_SYS_CORE+28             
b4d1 39 b5			dw .EQUAL            
b4d3 02				db 1 + 1 
b4d4 .. 00			db ">",0              
b4d6				endm 
# End of macro CWHEAD
b4d6			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b4d6				; TODO add floating point number detection 
b4d6					if DEBUG_FORTH_WORDS_KEY 
b4d6						DMARK "GRT" 
b4d6 f5				push af  
b4d7 3a eb b4			ld a, (.dmark)  
b4da 32 6b ee			ld (debug_mark),a  
b4dd 3a ec b4			ld a, (.dmark+1)  
b4e0 32 6c ee			ld (debug_mark+1),a  
b4e3 3a ed b4			ld a, (.dmark+2)  
b4e6 32 6d ee			ld (debug_mark+2),a  
b4e9 18 03			jr .pastdmark  
b4eb ..			.dmark: db "GRT"  
b4ee f1			.pastdmark: pop af  
b4ef			endm  
# End of macro DMARK
b4ef						CALLMONITOR 
b4ef cd 6f ee			call debug_vector  
b4f2				endm  
# End of macro CALLMONITOR
b4f2					endif 
b4f2					FORTH_DSP 
b4f2 cd f9 9c			call macro_forth_dsp 
b4f5				endm 
# End of macro FORTH_DSP
b4f5					;FORTH_DSP_VALUE 
b4f5 7e					ld a,(hl)	; get type of value on TOS 
b4f6 fe 02				cp DS_TYPE_INUM  
b4f8 28 00				jr z, .gt_inum 
b4fa			 
b4fa				if FORTH_ENABLE_FLOATMATH 
b4fa					jr .gt_done 
b4fa			 
b4fa				endif 
b4fa					 
b4fa			 
b4fa			.gt_inum: 
b4fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4fa cd 33 9d			call macro_dsp_valuehl 
b4fd				endm 
# End of macro FORTH_DSP_VALUEHL
b4fd			 
b4fd e5					push hl  ; u2 
b4fe			 
b4fe					; destroy value TOS 
b4fe			 
b4fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4fe cd eb 9d			call macro_forth_dsp_pop 
b501				endm 
# End of macro FORTH_DSP_POP
b501			 
b501			 
b501					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b501 cd 33 9d			call macro_dsp_valuehl 
b504				endm 
# End of macro FORTH_DSP_VALUEHL
b504			 
b504 e5					push hl    ; u1 
b505			 
b505					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b505 cd eb 9d			call macro_forth_dsp_pop 
b508				endm 
# End of macro FORTH_DSP_POP
b508			 
b508			 
b508 b7			 or a      ;clear carry flag 
b509 01 00 00		 ld bc, FORTH_FALSE 
b50c e1			  pop hl    ; u1 
b50d d1			  pop de    ; u2 
b50e ed 52		  sbc hl,de 
b510 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b512			 
b512 01 01 00		 ld bc, FORTH_TRUE 
b515			.gtcont:  
b515 c5					push bc 
b516 e1					pop hl 
b517			 
b517					if DEBUG_FORTH_WORDS 
b517						DMARK "GT1" 
b517 f5				push af  
b518 3a 2c b5			ld a, (.dmark)  
b51b 32 6b ee			ld (debug_mark),a  
b51e 3a 2d b5			ld a, (.dmark+1)  
b521 32 6c ee			ld (debug_mark+1),a  
b524 3a 2e b5			ld a, (.dmark+2)  
b527 32 6d ee			ld (debug_mark+2),a  
b52a 18 03			jr .pastdmark  
b52c ..			.dmark: db "GT1"  
b52f f1			.pastdmark: pop af  
b530			endm  
# End of macro DMARK
b530						CALLMONITOR 
b530 cd 6f ee			call debug_vector  
b533				endm  
# End of macro CALLMONITOR
b533					endif 
b533 cd 3c 9b				call forth_push_numhl 
b536			 
b536					NEXTW 
b536 c3 e9 9e			jp macro_next 
b539				endm 
# End of macro NEXTW
b539			.EQUAL: 
b539				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b539 31				db WORD_SYS_CORE+29             
b53a a4 b5			dw .ENDLOGIC            
b53c 02				db 1 + 1 
b53d .. 00			db "=",0              
b53f				endm 
# End of macro CWHEAD
b53f			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b53f				; TODO add floating point number detection 
b53f					if DEBUG_FORTH_WORDS_KEY 
b53f						DMARK "EQ." 
b53f f5				push af  
b540 3a 54 b5			ld a, (.dmark)  
b543 32 6b ee			ld (debug_mark),a  
b546 3a 55 b5			ld a, (.dmark+1)  
b549 32 6c ee			ld (debug_mark+1),a  
b54c 3a 56 b5			ld a, (.dmark+2)  
b54f 32 6d ee			ld (debug_mark+2),a  
b552 18 03			jr .pastdmark  
b554 ..			.dmark: db "EQ."  
b557 f1			.pastdmark: pop af  
b558			endm  
# End of macro DMARK
b558						CALLMONITOR 
b558 cd 6f ee			call debug_vector  
b55b				endm  
# End of macro CALLMONITOR
b55b					endif 
b55b					FORTH_DSP 
b55b cd f9 9c			call macro_forth_dsp 
b55e				endm 
# End of macro FORTH_DSP
b55e					;v5 FORTH_DSP_VALUE 
b55e 7e					ld a,(hl)	; get type of value on TOS 
b55f fe 02				cp DS_TYPE_INUM  
b561 28 00				jr z, .eq_inum 
b563			 
b563				if FORTH_ENABLE_FLOATMATH 
b563					jr .eq_done 
b563			 
b563				endif 
b563					 
b563			 
b563			.eq_inum: 
b563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b563 cd 33 9d			call macro_dsp_valuehl 
b566				endm 
# End of macro FORTH_DSP_VALUEHL
b566			 
b566 e5					push hl 
b567			 
b567					; destroy value TOS 
b567			 
b567					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b567 cd eb 9d			call macro_forth_dsp_pop 
b56a				endm 
# End of macro FORTH_DSP_POP
b56a			 
b56a			 
b56a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b56a cd 33 9d			call macro_dsp_valuehl 
b56d				endm 
# End of macro FORTH_DSP_VALUEHL
b56d			 
b56d					; one value on hl get other one back 
b56d			 
b56d e5					push hl 
b56e			 
b56e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b56e cd eb 9d			call macro_forth_dsp_pop 
b571				endm 
# End of macro FORTH_DSP_POP
b571			 
b571 0e 00				ld c, FORTH_FALSE 
b573			 
b573 e1					pop hl 
b574 d1					pop de 
b575			 
b575 7b					ld a, e 
b576 bd					cp l 
b577			 
b577 20 06				jr nz, .eq_done 
b579			 
b579 7a					ld a, d 
b57a bc					cp h 
b57b			 
b57b 20 02				jr nz, .eq_done 
b57d			 
b57d 0e 01				ld c, FORTH_TRUE 
b57f					 
b57f			 
b57f			 
b57f			.eq_done: 
b57f			 
b57f					; TODO push value back onto stack for another op etc 
b57f			 
b57f 26 00				ld h, 0 
b581 69					ld l, c 
b582					if DEBUG_FORTH_WORDS 
b582						DMARK "EQ1" 
b582 f5				push af  
b583 3a 97 b5			ld a, (.dmark)  
b586 32 6b ee			ld (debug_mark),a  
b589 3a 98 b5			ld a, (.dmark+1)  
b58c 32 6c ee			ld (debug_mark+1),a  
b58f 3a 99 b5			ld a, (.dmark+2)  
b592 32 6d ee			ld (debug_mark+2),a  
b595 18 03			jr .pastdmark  
b597 ..			.dmark: db "EQ1"  
b59a f1			.pastdmark: pop af  
b59b			endm  
# End of macro DMARK
b59b						CALLMONITOR 
b59b cd 6f ee			call debug_vector  
b59e				endm  
# End of macro CALLMONITOR
b59e					endif 
b59e cd 3c 9b				call forth_push_numhl 
b5a1			 
b5a1					NEXTW 
b5a1 c3 e9 9e			jp macro_next 
b5a4				endm 
# End of macro NEXTW
b5a4			 
b5a4			 
b5a4			.ENDLOGIC: 
b5a4			; eof 
b5a4			 
b5a4			 
# End of file forth_words_logic.asm
b5a4			include "forth_words_maths.asm" 
b5a4			 
b5a4			; | ## Maths Words 
b5a4			 
b5a4			.PLUS:	 
b5a4				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b5a4 15				db WORD_SYS_CORE+1             
b5a5 02 b6			dw .NEG            
b5a7 02				db 1 + 1 
b5a8 .. 00			db "+",0              
b5aa				endm 
# End of macro CWHEAD
b5aa			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b5aa					if DEBUG_FORTH_WORDS_KEY 
b5aa						DMARK "PLU" 
b5aa f5				push af  
b5ab 3a bf b5			ld a, (.dmark)  
b5ae 32 6b ee			ld (debug_mark),a  
b5b1 3a c0 b5			ld a, (.dmark+1)  
b5b4 32 6c ee			ld (debug_mark+1),a  
b5b7 3a c1 b5			ld a, (.dmark+2)  
b5ba 32 6d ee			ld (debug_mark+2),a  
b5bd 18 03			jr .pastdmark  
b5bf ..			.dmark: db "PLU"  
b5c2 f1			.pastdmark: pop af  
b5c3			endm  
# End of macro DMARK
b5c3						CALLMONITOR 
b5c3 cd 6f ee			call debug_vector  
b5c6				endm  
# End of macro CALLMONITOR
b5c6					endif 
b5c6					; add top two values and push back result 
b5c6			 
b5c6					;for v5 FORTH_DSP_VALUE 
b5c6					FORTH_DSP 
b5c6 cd f9 9c			call macro_forth_dsp 
b5c9				endm 
# End of macro FORTH_DSP
b5c9 7e					ld a,(hl)	; get type of value on TOS 
b5ca fe 02				cp DS_TYPE_INUM  
b5cc 28 03				jr z, .dot_inum 
b5ce			 
b5ce					NEXTW 
b5ce c3 e9 9e			jp macro_next 
b5d1				endm 
# End of macro NEXTW
b5d1			 
b5d1			; float maths 
b5d1			 
b5d1				if FORTH_ENABLE_FLOATMATH 
b5d1						inc hl      ; now at start of numeric as string 
b5d1			 
b5d1					if DEBUG_FORTH_MATHS 
b5d1						DMARK "ADD" 
b5d1				CALLMONITOR 
b5d1					endif 
b5d1			 
b5d1					;ld ix, hl 
b5d1					call CON 
b5d1			 
b5d1			 
b5d1					push hl 
b5d1					 
b5d1					 
b5d1			 
b5d1						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b5d1			 
b5d1					; get next number 
b5d1			 
b5d1						FORTH_DSP_VALUE 
b5d1			 
b5d1						inc hl      ; now at start of numeric as string 
b5d1			 
b5d1					;ld ix, hl 
b5d1					call CON 
b5d1			 
b5d1					push hl 
b5d1			 
b5d1			 
b5d1						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5d1			 
b5d1						; TODO do add 
b5d1			 
b5d1						call IADD 
b5d1			 
b5d1						; TODO get result back as ascii 
b5d1			 
b5d1						; TODO push result  
b5d1			 
b5d1			 
b5d1			 
b5d1						jr .dot_done 
b5d1				endif 
b5d1			 
b5d1			.dot_inum: 
b5d1			 
b5d1			 
b5d1					if DEBUG_FORTH_DOT 
b5d1						DMARK "+IT" 
b5d1 f5				push af  
b5d2 3a e6 b5			ld a, (.dmark)  
b5d5 32 6b ee			ld (debug_mark),a  
b5d8 3a e7 b5			ld a, (.dmark+1)  
b5db 32 6c ee			ld (debug_mark+1),a  
b5de 3a e8 b5			ld a, (.dmark+2)  
b5e1 32 6d ee			ld (debug_mark+2),a  
b5e4 18 03			jr .pastdmark  
b5e6 ..			.dmark: db "+IT"  
b5e9 f1			.pastdmark: pop af  
b5ea			endm  
# End of macro DMARK
b5ea				CALLMONITOR 
b5ea cd 6f ee			call debug_vector  
b5ed				endm  
# End of macro CALLMONITOR
b5ed					endif 
b5ed			 
b5ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ed cd 33 9d			call macro_dsp_valuehl 
b5f0				endm 
# End of macro FORTH_DSP_VALUEHL
b5f0			 
b5f0				; TODO add floating point number detection 
b5f0			 
b5f0 e5					push hl 
b5f1			 
b5f1					; destroy value TOS 
b5f1			 
b5f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5f1 cd eb 9d			call macro_forth_dsp_pop 
b5f4				endm 
# End of macro FORTH_DSP_POP
b5f4			 
b5f4			 
b5f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5f4 cd 33 9d			call macro_dsp_valuehl 
b5f7				endm 
# End of macro FORTH_DSP_VALUEHL
b5f7			 
b5f7					; one value on hl get other one back 
b5f7			 
b5f7 d1					pop de 
b5f8			 
b5f8					; do the add 
b5f8			 
b5f8 19					add hl,de 
b5f9			 
b5f9					; save it 
b5f9			 
b5f9			;		push hl	 
b5f9			 
b5f9					; 
b5f9			 
b5f9					; destroy value TOS 
b5f9			 
b5f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5f9 cd eb 9d			call macro_forth_dsp_pop 
b5fc				endm 
# End of macro FORTH_DSP_POP
b5fc			 
b5fc					; TODO push value back onto stack for another op etc 
b5fc			 
b5fc			;		pop hl 
b5fc			 
b5fc			.dot_done: 
b5fc cd 3c 9b				call forth_push_numhl 
b5ff			 
b5ff					NEXTW 
b5ff c3 e9 9e			jp macro_next 
b602				endm 
# End of macro NEXTW
b602			.NEG: 
b602			 
b602				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b602 17				db WORD_SYS_CORE+3             
b603 45 b6			dw .DIV            
b605 02				db 1 + 1 
b606 .. 00			db "-",0              
b608				endm 
# End of macro CWHEAD
b608			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b608					if DEBUG_FORTH_WORDS_KEY 
b608						DMARK "SUB" 
b608 f5				push af  
b609 3a 1d b6			ld a, (.dmark)  
b60c 32 6b ee			ld (debug_mark),a  
b60f 3a 1e b6			ld a, (.dmark+1)  
b612 32 6c ee			ld (debug_mark+1),a  
b615 3a 1f b6			ld a, (.dmark+2)  
b618 32 6d ee			ld (debug_mark+2),a  
b61b 18 03			jr .pastdmark  
b61d ..			.dmark: db "SUB"  
b620 f1			.pastdmark: pop af  
b621			endm  
# End of macro DMARK
b621						CALLMONITOR 
b621 cd 6f ee			call debug_vector  
b624				endm  
# End of macro CALLMONITOR
b624					endif 
b624			 
b624			 
b624				; TODO add floating point number detection 
b624					; v5 FORTH_DSP_VALUE 
b624					FORTH_DSP 
b624 cd f9 9c			call macro_forth_dsp 
b627				endm 
# End of macro FORTH_DSP
b627 7e					ld a,(hl)	; get type of value on TOS 
b628 fe 02				cp DS_TYPE_INUM  
b62a 28 03				jr z, .neg_inum 
b62c			 
b62c					NEXTW 
b62c c3 e9 9e			jp macro_next 
b62f				endm 
# End of macro NEXTW
b62f			 
b62f			; float maths 
b62f			 
b62f				if FORTH_ENABLE_FLOATMATH 
b62f					jr .neg_done 
b62f			 
b62f				endif 
b62f					 
b62f			 
b62f			.neg_inum: 
b62f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b62f cd 33 9d			call macro_dsp_valuehl 
b632				endm 
# End of macro FORTH_DSP_VALUEHL
b632			 
b632 e5					push hl 
b633			 
b633					; destroy value TOS 
b633			 
b633					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b633 cd eb 9d			call macro_forth_dsp_pop 
b636				endm 
# End of macro FORTH_DSP_POP
b636			 
b636			 
b636					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b636 cd 33 9d			call macro_dsp_valuehl 
b639				endm 
# End of macro FORTH_DSP_VALUEHL
b639			 
b639					; one value on hl get other one back 
b639			 
b639 d1					pop de 
b63a			 
b63a					; do the sub 
b63a			;		ex de, hl 
b63a			 
b63a ed 52				sbc hl,de 
b63c			 
b63c					; save it 
b63c			 
b63c			;		push hl	 
b63c			 
b63c					; 
b63c			 
b63c					; destroy value TOS 
b63c			 
b63c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b63c cd eb 9d			call macro_forth_dsp_pop 
b63f				endm 
# End of macro FORTH_DSP_POP
b63f			 
b63f					; TODO push value back onto stack for another op etc 
b63f			 
b63f			;		pop hl 
b63f			 
b63f cd 3c 9b				call forth_push_numhl 
b642			.neg_done: 
b642			 
b642					NEXTW 
b642 c3 e9 9e			jp macro_next 
b645				endm 
# End of macro NEXTW
b645			.DIV: 
b645				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b645 18				db WORD_SYS_CORE+4             
b646 92 b6			dw .MUL            
b648 02				db 1 + 1 
b649 .. 00			db "/",0              
b64b				endm 
# End of macro CWHEAD
b64b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b64b					if DEBUG_FORTH_WORDS_KEY 
b64b						DMARK "DIV" 
b64b f5				push af  
b64c 3a 60 b6			ld a, (.dmark)  
b64f 32 6b ee			ld (debug_mark),a  
b652 3a 61 b6			ld a, (.dmark+1)  
b655 32 6c ee			ld (debug_mark+1),a  
b658 3a 62 b6			ld a, (.dmark+2)  
b65b 32 6d ee			ld (debug_mark+2),a  
b65e 18 03			jr .pastdmark  
b660 ..			.dmark: db "DIV"  
b663 f1			.pastdmark: pop af  
b664			endm  
# End of macro DMARK
b664						CALLMONITOR 
b664 cd 6f ee			call debug_vector  
b667				endm  
# End of macro CALLMONITOR
b667					endif 
b667				; TODO add floating point number detection 
b667					; v5 FORTH_DSP_VALUE 
b667					FORTH_DSP 
b667 cd f9 9c			call macro_forth_dsp 
b66a				endm 
# End of macro FORTH_DSP
b66a 7e					ld a,(hl)	; get type of value on TOS 
b66b fe 02				cp DS_TYPE_INUM  
b66d 28 03				jr z, .div_inum 
b66f			 
b66f				if FORTH_ENABLE_FLOATMATH 
b66f					jr .div_done 
b66f			 
b66f				endif 
b66f					NEXTW 
b66f c3 e9 9e			jp macro_next 
b672				endm 
# End of macro NEXTW
b672			.div_inum: 
b672			 
b672					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b672 cd 33 9d			call macro_dsp_valuehl 
b675				endm 
# End of macro FORTH_DSP_VALUEHL
b675			 
b675 e5					push hl    ; to go to bc 
b676			 
b676					; destroy value TOS 
b676			 
b676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b676 cd eb 9d			call macro_forth_dsp_pop 
b679				endm 
# End of macro FORTH_DSP_POP
b679			 
b679			 
b679					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b679 cd 33 9d			call macro_dsp_valuehl 
b67c				endm 
# End of macro FORTH_DSP_VALUEHL
b67c			 
b67c					; hl to go to de 
b67c			 
b67c e5					push hl 
b67d			 
b67d c1					pop bc 
b67e d1					pop de		 
b67f			 
b67f			 
b67f					if DEBUG_FORTH_MATHS 
b67f						DMARK "DIV" 
b67f				CALLMONITOR 
b67f					endif 
b67f					; one value on hl but move to a get other one back 
b67f			 
b67f			        
b67f cd 39 8c			call Div16 
b682			 
b682			;	push af	 
b682 e5				push hl 
b683 c5				push bc 
b684			 
b684					if DEBUG_FORTH_MATHS 
b684						DMARK "DI1" 
b684				CALLMONITOR 
b684					endif 
b684			 
b684					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b684 cd eb 9d			call macro_forth_dsp_pop 
b687				endm 
# End of macro FORTH_DSP_POP
b687			 
b687			 
b687			 
b687 e1					pop hl    ; result 
b688			 
b688 cd 3c 9b				call forth_push_numhl 
b68b			 
b68b e1					pop hl    ; reminder 
b68c			;		ld h,0 
b68c			;		ld l,d 
b68c			 
b68c cd 3c 9b				call forth_push_numhl 
b68f			.div_done: 
b68f					NEXTW 
b68f c3 e9 9e			jp macro_next 
b692				endm 
# End of macro NEXTW
b692			.MUL: 
b692				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b692 19				db WORD_SYS_CORE+5             
b693 d7 b6			dw .MIN            
b695 02				db 1 + 1 
b696 .. 00			db "*",0              
b698				endm 
# End of macro CWHEAD
b698			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b698				; TODO add floating point number detection 
b698					if DEBUG_FORTH_WORDS_KEY 
b698						DMARK "MUL" 
b698 f5				push af  
b699 3a ad b6			ld a, (.dmark)  
b69c 32 6b ee			ld (debug_mark),a  
b69f 3a ae b6			ld a, (.dmark+1)  
b6a2 32 6c ee			ld (debug_mark+1),a  
b6a5 3a af b6			ld a, (.dmark+2)  
b6a8 32 6d ee			ld (debug_mark+2),a  
b6ab 18 03			jr .pastdmark  
b6ad ..			.dmark: db "MUL"  
b6b0 f1			.pastdmark: pop af  
b6b1			endm  
# End of macro DMARK
b6b1						CALLMONITOR 
b6b1 cd 6f ee			call debug_vector  
b6b4				endm  
# End of macro CALLMONITOR
b6b4					endif 
b6b4					FORTH_DSP 
b6b4 cd f9 9c			call macro_forth_dsp 
b6b7				endm 
# End of macro FORTH_DSP
b6b7					; v5 FORTH_DSP_VALUE 
b6b7 7e					ld a,(hl)	; get type of value on TOS 
b6b8 fe 02				cp DS_TYPE_INUM  
b6ba 28 03				jr z, .mul_inum 
b6bc			 
b6bc				if FORTH_ENABLE_FLOATMATH 
b6bc					jr .mul_done 
b6bc			 
b6bc				endif 
b6bc			 
b6bc					NEXTW 
b6bc c3 e9 9e			jp macro_next 
b6bf				endm 
# End of macro NEXTW
b6bf			.mul_inum:	 
b6bf			 
b6bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6bf cd 33 9d			call macro_dsp_valuehl 
b6c2				endm 
# End of macro FORTH_DSP_VALUEHL
b6c2			 
b6c2 e5					push hl 
b6c3			 
b6c3					; destroy value TOS 
b6c3			 
b6c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6c3 cd eb 9d			call macro_forth_dsp_pop 
b6c6				endm 
# End of macro FORTH_DSP_POP
b6c6			 
b6c6			 
b6c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6c6 cd 33 9d			call macro_dsp_valuehl 
b6c9				endm 
# End of macro FORTH_DSP_VALUEHL
b6c9			 
b6c9					; one value on hl but move to a get other one back 
b6c9			 
b6c9 7d					ld a, l 
b6ca			 
b6ca d1					pop de 
b6cb			 
b6cb					; do the mull 
b6cb			;		ex de, hl 
b6cb			 
b6cb cd 5f 8c				call Mult16 
b6ce					; save it 
b6ce			 
b6ce			;		push hl	 
b6ce			 
b6ce					; 
b6ce			 
b6ce					; destroy value TOS 
b6ce			 
b6ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ce cd eb 9d			call macro_forth_dsp_pop 
b6d1				endm 
# End of macro FORTH_DSP_POP
b6d1			 
b6d1					; TODO push value back onto stack for another op etc 
b6d1			 
b6d1			;		pop hl 
b6d1			 
b6d1 cd 3c 9b				call forth_push_numhl 
b6d4			 
b6d4			.mul_done: 
b6d4					NEXTW 
b6d4 c3 e9 9e			jp macro_next 
b6d7				endm 
# End of macro NEXTW
b6d7			 
b6d7			 
b6d7			 
b6d7			 
b6d7			.MIN: 
b6d7				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b6d7 49				db WORD_SYS_CORE+53             
b6d8 58 b7			dw .MAX            
b6da 04				db 3 + 1 
b6db .. 00			db "MIN",0              
b6df				endm 
# End of macro CWHEAD
b6df			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b6df					if DEBUG_FORTH_WORDS_KEY 
b6df						DMARK "MIN" 
b6df f5				push af  
b6e0 3a f4 b6			ld a, (.dmark)  
b6e3 32 6b ee			ld (debug_mark),a  
b6e6 3a f5 b6			ld a, (.dmark+1)  
b6e9 32 6c ee			ld (debug_mark+1),a  
b6ec 3a f6 b6			ld a, (.dmark+2)  
b6ef 32 6d ee			ld (debug_mark+2),a  
b6f2 18 03			jr .pastdmark  
b6f4 ..			.dmark: db "MIN"  
b6f7 f1			.pastdmark: pop af  
b6f8			endm  
# End of macro DMARK
b6f8						CALLMONITOR 
b6f8 cd 6f ee			call debug_vector  
b6fb				endm  
# End of macro CALLMONITOR
b6fb					endif 
b6fb					; get u2 
b6fb			 
b6fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6fb cd 33 9d			call macro_dsp_valuehl 
b6fe				endm 
# End of macro FORTH_DSP_VALUEHL
b6fe			 
b6fe e5					push hl   ; u2 
b6ff			 
b6ff					; destroy value TOS 
b6ff			 
b6ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ff cd eb 9d			call macro_forth_dsp_pop 
b702				endm 
# End of macro FORTH_DSP_POP
b702			 
b702					; get u1 
b702			 
b702					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b702 cd 33 9d			call macro_dsp_valuehl 
b705				endm 
# End of macro FORTH_DSP_VALUEHL
b705			 
b705 e5					push hl  ; u1 
b706			 
b706					; destroy value TOS 
b706			 
b706					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b706 cd eb 9d			call macro_forth_dsp_pop 
b709				endm 
# End of macro FORTH_DSP_POP
b709			 
b709 b7			 or a      ;clear carry flag 
b70a e1			  pop hl    ; u1 
b70b d1			  pop de    ; u2 
b70c e5				push hl   ; saved in case hl is lowest 
b70d ed 52		  sbc hl,de 
b70f 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b711			 
b711 e1				pop hl 
b712					if DEBUG_FORTH_WORDS 
b712						DMARK "MIN" 
b712 f5				push af  
b713 3a 27 b7			ld a, (.dmark)  
b716 32 6b ee			ld (debug_mark),a  
b719 3a 28 b7			ld a, (.dmark+1)  
b71c 32 6c ee			ld (debug_mark+1),a  
b71f 3a 29 b7			ld a, (.dmark+2)  
b722 32 6d ee			ld (debug_mark+2),a  
b725 18 03			jr .pastdmark  
b727 ..			.dmark: db "MIN"  
b72a f1			.pastdmark: pop af  
b72b			endm  
# End of macro DMARK
b72b						CALLMONITOR 
b72b cd 6f ee			call debug_vector  
b72e				endm  
# End of macro CALLMONITOR
b72e					endif 
b72e cd 3c 9b				call forth_push_numhl 
b731			 
b731				       NEXTW 
b731 c3 e9 9e			jp macro_next 
b734				endm 
# End of macro NEXTW
b734			 
b734			.mincont:  
b734 c1				pop bc   ; tidy up 
b735 eb				ex de , hl  
b736					if DEBUG_FORTH_WORDS 
b736						DMARK "MI1" 
b736 f5				push af  
b737 3a 4b b7			ld a, (.dmark)  
b73a 32 6b ee			ld (debug_mark),a  
b73d 3a 4c b7			ld a, (.dmark+1)  
b740 32 6c ee			ld (debug_mark+1),a  
b743 3a 4d b7			ld a, (.dmark+2)  
b746 32 6d ee			ld (debug_mark+2),a  
b749 18 03			jr .pastdmark  
b74b ..			.dmark: db "MI1"  
b74e f1			.pastdmark: pop af  
b74f			endm  
# End of macro DMARK
b74f						CALLMONITOR 
b74f cd 6f ee			call debug_vector  
b752				endm  
# End of macro CALLMONITOR
b752					endif 
b752 cd 3c 9b				call forth_push_numhl 
b755			 
b755				       NEXTW 
b755 c3 e9 9e			jp macro_next 
b758				endm 
# End of macro NEXTW
b758			.MAX: 
b758				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b758 4a				db WORD_SYS_CORE+54             
b759 d9 b7			dw .RND16            
b75b 04				db 3 + 1 
b75c .. 00			db "MAX",0              
b760				endm 
# End of macro CWHEAD
b760			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b760					if DEBUG_FORTH_WORDS_KEY 
b760						DMARK "MAX" 
b760 f5				push af  
b761 3a 75 b7			ld a, (.dmark)  
b764 32 6b ee			ld (debug_mark),a  
b767 3a 76 b7			ld a, (.dmark+1)  
b76a 32 6c ee			ld (debug_mark+1),a  
b76d 3a 77 b7			ld a, (.dmark+2)  
b770 32 6d ee			ld (debug_mark+2),a  
b773 18 03			jr .pastdmark  
b775 ..			.dmark: db "MAX"  
b778 f1			.pastdmark: pop af  
b779			endm  
# End of macro DMARK
b779						CALLMONITOR 
b779 cd 6f ee			call debug_vector  
b77c				endm  
# End of macro CALLMONITOR
b77c					endif 
b77c					; get u2 
b77c			 
b77c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b77c cd 33 9d			call macro_dsp_valuehl 
b77f				endm 
# End of macro FORTH_DSP_VALUEHL
b77f			 
b77f e5					push hl   ; u2 
b780			 
b780					; destroy value TOS 
b780			 
b780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b780 cd eb 9d			call macro_forth_dsp_pop 
b783				endm 
# End of macro FORTH_DSP_POP
b783			 
b783					; get u1 
b783			 
b783					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b783 cd 33 9d			call macro_dsp_valuehl 
b786				endm 
# End of macro FORTH_DSP_VALUEHL
b786			 
b786 e5					push hl  ; u1 
b787			 
b787					; destroy value TOS 
b787			 
b787					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b787 cd eb 9d			call macro_forth_dsp_pop 
b78a				endm 
# End of macro FORTH_DSP_POP
b78a			 
b78a b7			 or a      ;clear carry flag 
b78b e1			  pop hl    ; u1 
b78c d1			  pop de    ; u2 
b78d e5				push hl   ; saved in case hl is lowest 
b78e ed 52		  sbc hl,de 
b790 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b792			 
b792 e1				pop hl 
b793					if DEBUG_FORTH_WORDS 
b793						DMARK "MAX" 
b793 f5				push af  
b794 3a a8 b7			ld a, (.dmark)  
b797 32 6b ee			ld (debug_mark),a  
b79a 3a a9 b7			ld a, (.dmark+1)  
b79d 32 6c ee			ld (debug_mark+1),a  
b7a0 3a aa b7			ld a, (.dmark+2)  
b7a3 32 6d ee			ld (debug_mark+2),a  
b7a6 18 03			jr .pastdmark  
b7a8 ..			.dmark: db "MAX"  
b7ab f1			.pastdmark: pop af  
b7ac			endm  
# End of macro DMARK
b7ac						CALLMONITOR 
b7ac cd 6f ee			call debug_vector  
b7af				endm  
# End of macro CALLMONITOR
b7af					endif 
b7af cd 3c 9b				call forth_push_numhl 
b7b2			 
b7b2				       NEXTW 
b7b2 c3 e9 9e			jp macro_next 
b7b5				endm 
# End of macro NEXTW
b7b5			 
b7b5			.maxcont:  
b7b5 c1				pop bc   ; tidy up 
b7b6 eb				ex de , hl  
b7b7					if DEBUG_FORTH_WORDS 
b7b7						DMARK "MA1" 
b7b7 f5				push af  
b7b8 3a cc b7			ld a, (.dmark)  
b7bb 32 6b ee			ld (debug_mark),a  
b7be 3a cd b7			ld a, (.dmark+1)  
b7c1 32 6c ee			ld (debug_mark+1),a  
b7c4 3a ce b7			ld a, (.dmark+2)  
b7c7 32 6d ee			ld (debug_mark+2),a  
b7ca 18 03			jr .pastdmark  
b7cc ..			.dmark: db "MA1"  
b7cf f1			.pastdmark: pop af  
b7d0			endm  
# End of macro DMARK
b7d0						CALLMONITOR 
b7d0 cd 6f ee			call debug_vector  
b7d3				endm  
# End of macro CALLMONITOR
b7d3					endif 
b7d3 cd 3c 9b				call forth_push_numhl 
b7d6				       NEXTW 
b7d6 c3 e9 9e			jp macro_next 
b7d9				endm 
# End of macro NEXTW
b7d9			 
b7d9			.RND16: 
b7d9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b7d9 4e				db WORD_SYS_CORE+58             
b7da 08 b8			dw .RND8            
b7dc 06				db 5 + 1 
b7dd .. 00			db "RND16",0              
b7e3				endm 
# End of macro CWHEAD
b7e3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b7e3					if DEBUG_FORTH_WORDS_KEY 
b7e3						DMARK "R16" 
b7e3 f5				push af  
b7e4 3a f8 b7			ld a, (.dmark)  
b7e7 32 6b ee			ld (debug_mark),a  
b7ea 3a f9 b7			ld a, (.dmark+1)  
b7ed 32 6c ee			ld (debug_mark+1),a  
b7f0 3a fa b7			ld a, (.dmark+2)  
b7f3 32 6d ee			ld (debug_mark+2),a  
b7f6 18 03			jr .pastdmark  
b7f8 ..			.dmark: db "R16"  
b7fb f1			.pastdmark: pop af  
b7fc			endm  
# End of macro DMARK
b7fc						CALLMONITOR 
b7fc cd 6f ee			call debug_vector  
b7ff				endm  
# End of macro CALLMONITOR
b7ff					endif 
b7ff cd 03 8c				call prng16  
b802 cd 3c 9b				call forth_push_numhl 
b805				       NEXTW 
b805 c3 e9 9e			jp macro_next 
b808				endm 
# End of macro NEXTW
b808			.RND8: 
b808				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b808 60				db WORD_SYS_CORE+76             
b809 3d b8			dw .RND            
b80b 05				db 4 + 1 
b80c .. 00			db "RND8",0              
b811				endm 
# End of macro CWHEAD
b811			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b811					if DEBUG_FORTH_WORDS_KEY 
b811						DMARK "RN8" 
b811 f5				push af  
b812 3a 26 b8			ld a, (.dmark)  
b815 32 6b ee			ld (debug_mark),a  
b818 3a 27 b8			ld a, (.dmark+1)  
b81b 32 6c ee			ld (debug_mark+1),a  
b81e 3a 28 b8			ld a, (.dmark+2)  
b821 32 6d ee			ld (debug_mark+2),a  
b824 18 03			jr .pastdmark  
b826 ..			.dmark: db "RN8"  
b829 f1			.pastdmark: pop af  
b82a			endm  
# End of macro DMARK
b82a						CALLMONITOR 
b82a cd 6f ee			call debug_vector  
b82d				endm  
# End of macro CALLMONITOR
b82d					endif 
b82d 2a a9 eb				ld hl,(xrandc) 
b830 23					inc hl 
b831 cd 1d 8c				call xrnd 
b834 6f					ld l,a	 
b835 26 00				ld h,0 
b837 cd 3c 9b				call forth_push_numhl 
b83a				       NEXTW 
b83a c3 e9 9e			jp macro_next 
b83d				endm 
# End of macro NEXTW
b83d			.RND: 
b83d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b83d 60				db WORD_SYS_CORE+76             
b83e 43 b9			dw .ENDMATHS            
b840 04				db 3 + 1 
b841 .. 00			db "RND",0              
b845				endm 
# End of macro CWHEAD
b845			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b845			 
b845					if DEBUG_FORTH_WORDS_KEY 
b845						DMARK "RND" 
b845 f5				push af  
b846 3a 5a b8			ld a, (.dmark)  
b849 32 6b ee			ld (debug_mark),a  
b84c 3a 5b b8			ld a, (.dmark+1)  
b84f 32 6c ee			ld (debug_mark+1),a  
b852 3a 5c b8			ld a, (.dmark+2)  
b855 32 6d ee			ld (debug_mark+2),a  
b858 18 03			jr .pastdmark  
b85a ..			.dmark: db "RND"  
b85d f1			.pastdmark: pop af  
b85e			endm  
# End of macro DMARK
b85e						CALLMONITOR 
b85e cd 6f ee			call debug_vector  
b861				endm  
# End of macro CALLMONITOR
b861					endif 
b861					 
b861					FORTH_DSP_VALUEHL    ; upper range 
b861 cd 33 9d			call macro_dsp_valuehl 
b864				endm 
# End of macro FORTH_DSP_VALUEHL
b864			 
b864 22 ad eb				ld (LFSRSeed), hl	 
b867			 
b867					if DEBUG_FORTH_WORDS 
b867						DMARK "RN1" 
b867 f5				push af  
b868 3a 7c b8			ld a, (.dmark)  
b86b 32 6b ee			ld (debug_mark),a  
b86e 3a 7d b8			ld a, (.dmark+1)  
b871 32 6c ee			ld (debug_mark+1),a  
b874 3a 7e b8			ld a, (.dmark+2)  
b877 32 6d ee			ld (debug_mark+2),a  
b87a 18 03			jr .pastdmark  
b87c ..			.dmark: db "RN1"  
b87f f1			.pastdmark: pop af  
b880			endm  
# End of macro DMARK
b880						CALLMONITOR 
b880 cd 6f ee			call debug_vector  
b883				endm  
# End of macro CALLMONITOR
b883					endif 
b883					FORTH_DSP_POP 
b883 cd eb 9d			call macro_forth_dsp_pop 
b886				endm 
# End of macro FORTH_DSP_POP
b886			 
b886					FORTH_DSP_VALUEHL    ; low range 
b886 cd 33 9d			call macro_dsp_valuehl 
b889				endm 
# End of macro FORTH_DSP_VALUEHL
b889			 
b889					if DEBUG_FORTH_WORDS 
b889						DMARK "RN2" 
b889 f5				push af  
b88a 3a 9e b8			ld a, (.dmark)  
b88d 32 6b ee			ld (debug_mark),a  
b890 3a 9f b8			ld a, (.dmark+1)  
b893 32 6c ee			ld (debug_mark+1),a  
b896 3a a0 b8			ld a, (.dmark+2)  
b899 32 6d ee			ld (debug_mark+2),a  
b89c 18 03			jr .pastdmark  
b89e ..			.dmark: db "RN2"  
b8a1 f1			.pastdmark: pop af  
b8a2			endm  
# End of macro DMARK
b8a2						CALLMONITOR 
b8a2 cd 6f ee			call debug_vector  
b8a5				endm  
# End of macro CALLMONITOR
b8a5					endif 
b8a5 22 af eb				ld (LFSRSeed+2), hl 
b8a8			 
b8a8					FORTH_DSP_POP 
b8a8 cd eb 9d			call macro_forth_dsp_pop 
b8ab				endm 
# End of macro FORTH_DSP_POP
b8ab			 
b8ab e5					push hl 
b8ac			 
b8ac e1			.inrange:	pop hl 
b8ad cd 03 8c				call prng16  
b8b0					if DEBUG_FORTH_WORDS 
b8b0						DMARK "RN3" 
b8b0 f5				push af  
b8b1 3a c5 b8			ld a, (.dmark)  
b8b4 32 6b ee			ld (debug_mark),a  
b8b7 3a c6 b8			ld a, (.dmark+1)  
b8ba 32 6c ee			ld (debug_mark+1),a  
b8bd 3a c7 b8			ld a, (.dmark+2)  
b8c0 32 6d ee			ld (debug_mark+2),a  
b8c3 18 03			jr .pastdmark  
b8c5 ..			.dmark: db "RN3"  
b8c8 f1			.pastdmark: pop af  
b8c9			endm  
# End of macro DMARK
b8c9						CALLMONITOR 
b8c9 cd 6f ee			call debug_vector  
b8cc				endm  
# End of macro CALLMONITOR
b8cc					endif 
b8cc					 
b8cc					; if the range is 8bit knock out the high byte 
b8cc			 
b8cc ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b8d0			 
b8d0 3e 00				ld a, 0 
b8d2 ba					cp d  
b8d3 20 1e				jr nz, .hirange 
b8d5 26 00				ld h, 0   ; knock it down to 8bit 
b8d7			 
b8d7					if DEBUG_FORTH_WORDS 
b8d7						DMARK "RNk" 
b8d7 f5				push af  
b8d8 3a ec b8			ld a, (.dmark)  
b8db 32 6b ee			ld (debug_mark),a  
b8de 3a ed b8			ld a, (.dmark+1)  
b8e1 32 6c ee			ld (debug_mark+1),a  
b8e4 3a ee b8			ld a, (.dmark+2)  
b8e7 32 6d ee			ld (debug_mark+2),a  
b8ea 18 03			jr .pastdmark  
b8ec ..			.dmark: db "RNk"  
b8ef f1			.pastdmark: pop af  
b8f0			endm  
# End of macro DMARK
b8f0						CALLMONITOR 
b8f0 cd 6f ee			call debug_vector  
b8f3				endm  
# End of macro CALLMONITOR
b8f3					endif 
b8f3			.hirange:   
b8f3 e5					push hl  
b8f4 b7					or a  
b8f5 ed 52		                sbc hl, de 
b8f7			 
b8f7					;call cmp16 
b8f7			 
b8f7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8f9 e1					pop hl 
b8fa e5					push hl 
b8fb			 
b8fb					if DEBUG_FORTH_WORDS 
b8fb						DMARK "RN4" 
b8fb f5				push af  
b8fc 3a 10 b9			ld a, (.dmark)  
b8ff 32 6b ee			ld (debug_mark),a  
b902 3a 11 b9			ld a, (.dmark+1)  
b905 32 6c ee			ld (debug_mark+1),a  
b908 3a 12 b9			ld a, (.dmark+2)  
b90b 32 6d ee			ld (debug_mark+2),a  
b90e 18 03			jr .pastdmark  
b910 ..			.dmark: db "RN4"  
b913 f1			.pastdmark: pop af  
b914			endm  
# End of macro DMARK
b914						CALLMONITOR 
b914 cd 6f ee			call debug_vector  
b917				endm  
# End of macro CALLMONITOR
b917					endif 
b917 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b91b					;call cmp16 
b91b				 
b91b b7					or a  
b91c ed 52		                sbc hl, de 
b91e 38 8c				jr c, .inrange 
b920			 
b920 e1					pop hl 
b921					 
b921					if DEBUG_FORTH_WORDS 
b921						DMARK "RNd" 
b921 f5				push af  
b922 3a 36 b9			ld a, (.dmark)  
b925 32 6b ee			ld (debug_mark),a  
b928 3a 37 b9			ld a, (.dmark+1)  
b92b 32 6c ee			ld (debug_mark+1),a  
b92e 3a 38 b9			ld a, (.dmark+2)  
b931 32 6d ee			ld (debug_mark+2),a  
b934 18 03			jr .pastdmark  
b936 ..			.dmark: db "RNd"  
b939 f1			.pastdmark: pop af  
b93a			endm  
# End of macro DMARK
b93a						CALLMONITOR 
b93a cd 6f ee			call debug_vector  
b93d				endm  
# End of macro CALLMONITOR
b93d					endif 
b93d			 
b93d			 
b93d cd 3c 9b				call forth_push_numhl 
b940				       NEXTW 
b940 c3 e9 9e			jp macro_next 
b943				endm 
# End of macro NEXTW
b943			 
b943			.ENDMATHS: 
b943			 
b943			; eof 
b943			 
# End of file forth_words_maths.asm
b943			include "forth_words_display.asm" 
b943			 
b943			; | ## Display Words 
b943			 
b943			.ACT: 
b943			 
b943				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b943 62				db WORD_SYS_CORE+78             
b944 8f b9			dw .INFO            
b946 07				db 6 + 1 
b947 .. 00			db "ACTIVE",0              
b94e				endm 
# End of macro CWHEAD
b94e			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b94e			;  
b94e			; | | e.g. $ff $00 do active . $01 pause loop 
b94e			 
b94e					if DEBUG_FORTH_WORDS_KEY 
b94e						DMARK "ACT" 
b94e f5				push af  
b94f 3a 63 b9			ld a, (.dmark)  
b952 32 6b ee			ld (debug_mark),a  
b955 3a 64 b9			ld a, (.dmark+1)  
b958 32 6c ee			ld (debug_mark+1),a  
b95b 3a 65 b9			ld a, (.dmark+2)  
b95e 32 6d ee			ld (debug_mark+2),a  
b961 18 03			jr .pastdmark  
b963 ..			.dmark: db "ACT"  
b966 f1			.pastdmark: pop af  
b967			endm  
# End of macro DMARK
b967						CALLMONITOR 
b967 cd 6f ee			call debug_vector  
b96a				endm  
# End of macro CALLMONITOR
b96a					endif 
b96a cd 06 8a				call active 
b96d					if DEBUG_FORTH_WORDS 
b96d						DMARK "ACp" 
b96d f5				push af  
b96e 3a 82 b9			ld a, (.dmark)  
b971 32 6b ee			ld (debug_mark),a  
b974 3a 83 b9			ld a, (.dmark+1)  
b977 32 6c ee			ld (debug_mark+1),a  
b97a 3a 84 b9			ld a, (.dmark+2)  
b97d 32 6d ee			ld (debug_mark+2),a  
b980 18 03			jr .pastdmark  
b982 ..			.dmark: db "ACp"  
b985 f1			.pastdmark: pop af  
b986			endm  
# End of macro DMARK
b986						CALLMONITOR 
b986 cd 6f ee			call debug_vector  
b989				endm  
# End of macro CALLMONITOR
b989					endif 
b989 cd aa 9b				call forth_push_str 
b98c			 
b98c					NEXTW 
b98c c3 e9 9e			jp macro_next 
b98f				endm 
# End of macro NEXTW
b98f			.INFO: 
b98f			 
b98f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b98f 62				db WORD_SYS_CORE+78             
b990 ac b9			dw .ATP            
b992 05				db 4 + 1 
b993 .. 00			db "INFO",0              
b998				endm 
# End of macro CWHEAD
b998			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b998					FORTH_DSP_VALUEHL 
b998 cd 33 9d			call macro_dsp_valuehl 
b99b				endm 
# End of macro FORTH_DSP_VALUEHL
b99b			 
b99b					FORTH_DSP_POP 
b99b cd eb 9d			call macro_forth_dsp_pop 
b99e				endm 
# End of macro FORTH_DSP_POP
b99e			 
b99e e5					push hl 
b99f			 
b99f					FORTH_DSP_VALUEHL 
b99f cd 33 9d			call macro_dsp_valuehl 
b9a2				endm 
# End of macro FORTH_DSP_VALUEHL
b9a2			 
b9a2					FORTH_DSP_POP 
b9a2 cd eb 9d			call macro_forth_dsp_pop 
b9a5				endm 
# End of macro FORTH_DSP_POP
b9a5			 
b9a5 d1					pop de 
b9a6			 
b9a6 cd 40 8a				call info_panel 
b9a9			 
b9a9			 
b9a9					NEXTW 
b9a9 c3 e9 9e			jp macro_next 
b9ac				endm 
# End of macro NEXTW
b9ac			.ATP: 
b9ac				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b9ac 62				db WORD_SYS_CORE+78             
b9ad 23 ba			dw .FB            
b9af 04				db 3 + 1 
b9b0 .. 00			db "AT?",0              
b9b4				endm 
# End of macro CWHEAD
b9b4			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b9b4					if DEBUG_FORTH_WORDS_KEY 
b9b4						DMARK "AT?" 
b9b4 f5				push af  
b9b5 3a c9 b9			ld a, (.dmark)  
b9b8 32 6b ee			ld (debug_mark),a  
b9bb 3a ca b9			ld a, (.dmark+1)  
b9be 32 6c ee			ld (debug_mark+1),a  
b9c1 3a cb b9			ld a, (.dmark+2)  
b9c4 32 6d ee			ld (debug_mark+2),a  
b9c7 18 03			jr .pastdmark  
b9c9 ..			.dmark: db "AT?"  
b9cc f1			.pastdmark: pop af  
b9cd			endm  
# End of macro DMARK
b9cd						CALLMONITOR 
b9cd cd 6f ee			call debug_vector  
b9d0				endm  
# End of macro CALLMONITOR
b9d0					endif 
b9d0 3a 5e ea				ld a, (f_cursor_ptr) 
b9d3			 
b9d3			if DEBUG_FORTH_WORDS 
b9d3				DMARK "AT?" 
b9d3 f5				push af  
b9d4 3a e8 b9			ld a, (.dmark)  
b9d7 32 6b ee			ld (debug_mark),a  
b9da 3a e9 b9			ld a, (.dmark+1)  
b9dd 32 6c ee			ld (debug_mark+1),a  
b9e0 3a ea b9			ld a, (.dmark+2)  
b9e3 32 6d ee			ld (debug_mark+2),a  
b9e6 18 03			jr .pastdmark  
b9e8 ..			.dmark: db "AT?"  
b9eb f1			.pastdmark: pop af  
b9ec			endm  
# End of macro DMARK
b9ec				CALLMONITOR 
b9ec cd 6f ee			call debug_vector  
b9ef				endm  
# End of macro CALLMONITOR
b9ef			endif	 
b9ef					; count the number of rows 
b9ef			 
b9ef 06 00				ld b, 0 
b9f1 4f			.atpr:		ld c, a    ; save in case we go below zero 
b9f2 d6 28				sub display_cols 
b9f4 f2 fa b9				jp p, .atprunder 
b9f7 04					inc b 
b9f8 18 f7				jr .atpr 
b9fa			.atprunder:	 
b9fa			if DEBUG_FORTH_WORDS 
b9fa				DMARK "A?2" 
b9fa f5				push af  
b9fb 3a 0f ba			ld a, (.dmark)  
b9fe 32 6b ee			ld (debug_mark),a  
ba01 3a 10 ba			ld a, (.dmark+1)  
ba04 32 6c ee			ld (debug_mark+1),a  
ba07 3a 11 ba			ld a, (.dmark+2)  
ba0a 32 6d ee			ld (debug_mark+2),a  
ba0d 18 03			jr .pastdmark  
ba0f ..			.dmark: db "A?2"  
ba12 f1			.pastdmark: pop af  
ba13			endm  
# End of macro DMARK
ba13				CALLMONITOR 
ba13 cd 6f ee			call debug_vector  
ba16				endm  
# End of macro CALLMONITOR
ba16			endif	 
ba16 26 00				ld h, 0 
ba18 69					ld l, c 
ba19 cd 3c 9b				call forth_push_numhl 
ba1c 68					ld l, b  
ba1d cd 3c 9b				call forth_push_numhl 
ba20			 
ba20			 
ba20				NEXTW 
ba20 c3 e9 9e			jp macro_next 
ba23				endm 
# End of macro NEXTW
ba23			 
ba23			.FB: 
ba23				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba23 1b				db WORD_SYS_CORE+7             
ba24 71 ba			dw .EMIT            
ba26 03				db 2 + 1 
ba27 .. 00			db "FB",0              
ba2a				endm 
# End of macro CWHEAD
ba2a			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba2a			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba2a			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba2a			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba2a					if DEBUG_FORTH_WORDS_KEY 
ba2a						DMARK "FB." 
ba2a f5				push af  
ba2b 3a 3f ba			ld a, (.dmark)  
ba2e 32 6b ee			ld (debug_mark),a  
ba31 3a 40 ba			ld a, (.dmark+1)  
ba34 32 6c ee			ld (debug_mark+1),a  
ba37 3a 41 ba			ld a, (.dmark+2)  
ba3a 32 6d ee			ld (debug_mark+2),a  
ba3d 18 03			jr .pastdmark  
ba3f ..			.dmark: db "FB."  
ba42 f1			.pastdmark: pop af  
ba43			endm  
# End of macro DMARK
ba43						CALLMONITOR 
ba43 cd 6f ee			call debug_vector  
ba46				endm  
# End of macro CALLMONITOR
ba46					endif 
ba46			 
ba46					FORTH_DSP_VALUEHL 
ba46 cd 33 9d			call macro_dsp_valuehl 
ba49				endm 
# End of macro FORTH_DSP_VALUEHL
ba49			 
ba49 7d					ld a, l 
ba4a fe 01				cp 1 
ba4c 20 05				jr nz, .fbn1 
ba4e 21 10 ed				ld hl, display_fb1 
ba51 18 15				jr .fbset 
ba53 fe 02		.fbn1:		cp 2 
ba55 20 05				jr nz, .fbn2 
ba57 21 ce eb				ld hl, display_fb2 
ba5a 18 0c				jr .fbset 
ba5c fe 03		.fbn2:		cp 3 
ba5e 20 05				jr nz, .fbn3 
ba60 21 6f ec				ld hl, display_fb3 
ba63 18 03				jr .fbset 
ba65			.fbn3:		 ; if invalid number select first 
ba65 21 10 ed				ld hl, display_fb1 
ba68 22 cc eb		.fbset:		ld (display_fb_active), hl 
ba6b			 
ba6b					FORTH_DSP_POP 
ba6b cd eb 9d			call macro_forth_dsp_pop 
ba6e				endm 
# End of macro FORTH_DSP_POP
ba6e			 
ba6e					NEXTW 
ba6e c3 e9 9e			jp macro_next 
ba71				endm 
# End of macro NEXTW
ba71			 
ba71			 
ba71			.EMIT: 
ba71				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba71 1b				db WORD_SYS_CORE+7             
ba72 c2 ba			dw .DOTH            
ba74 05				db 4 + 1 
ba75 .. 00			db "EMIT",0              
ba7a				endm 
# End of macro CWHEAD
ba7a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba7a					; get value off TOS and display it 
ba7a			 
ba7a					if DEBUG_FORTH_WORDS_KEY 
ba7a						DMARK "EMT" 
ba7a f5				push af  
ba7b 3a 8f ba			ld a, (.dmark)  
ba7e 32 6b ee			ld (debug_mark),a  
ba81 3a 90 ba			ld a, (.dmark+1)  
ba84 32 6c ee			ld (debug_mark+1),a  
ba87 3a 91 ba			ld a, (.dmark+2)  
ba8a 32 6d ee			ld (debug_mark+2),a  
ba8d 18 03			jr .pastdmark  
ba8f ..			.dmark: db "EMT"  
ba92 f1			.pastdmark: pop af  
ba93			endm  
# End of macro DMARK
ba93						CALLMONITOR 
ba93 cd 6f ee			call debug_vector  
ba96				endm  
# End of macro CALLMONITOR
ba96					endif 
ba96			 
ba96					FORTH_DSP_VALUEHL 
ba96 cd 33 9d			call macro_dsp_valuehl 
ba99				endm 
# End of macro FORTH_DSP_VALUEHL
ba99			 
ba99 7d					ld a,l 
ba9a			 
ba9a					; TODO write to display 
ba9a			 
ba9a 32 bf e4				ld (os_input), a 
ba9d 3e 00				ld a, 0 
ba9f 32 c0 e4				ld (os_input+1), a 
baa2					 
baa2 3a 5e ea				ld a, (f_cursor_ptr) 
baa5 11 bf e4				ld de, os_input 
baa8 cd c2 8a				call str_at_display 
baab			 
baab			 
baab 3a 3c ea				ld a,(cli_autodisplay) 
baae fe 00				cp 0 
bab0 28 03				jr z, .enoupdate 
bab2 cd d2 8a						call update_display 
bab5					.enoupdate: 
bab5			 
bab5 3a 5e ea				ld a, (f_cursor_ptr) 
bab8 3c					inc a 
bab9 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
babc			 
babc			 
babc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
babc cd eb 9d			call macro_forth_dsp_pop 
babf				endm 
# End of macro FORTH_DSP_POP
babf			  
babf			 
babf					NEXTW 
babf c3 e9 9e			jp macro_next 
bac2				endm 
# End of macro NEXTW
bac2			.DOTH: 
bac2				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bac2 1c				db WORD_SYS_CORE+8             
bac3 f2 ba			dw .DOTF            
bac5 03				db 2 + 1 
bac6 .. 00			db ".-",0              
bac9				endm 
# End of macro CWHEAD
bac9			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bac9					; get value off TOS and display it 
bac9					if DEBUG_FORTH_WORDS_KEY 
bac9						DMARK "DTD" 
bac9 f5				push af  
baca 3a de ba			ld a, (.dmark)  
bacd 32 6b ee			ld (debug_mark),a  
bad0 3a df ba			ld a, (.dmark+1)  
bad3 32 6c ee			ld (debug_mark+1),a  
bad6 3a e0 ba			ld a, (.dmark+2)  
bad9 32 6d ee			ld (debug_mark+2),a  
badc 18 03			jr .pastdmark  
bade ..			.dmark: db "DTD"  
bae1 f1			.pastdmark: pop af  
bae2			endm  
# End of macro DMARK
bae2						CALLMONITOR 
bae2 cd 6f ee			call debug_vector  
bae5				endm  
# End of macro CALLMONITOR
bae5					endif 
bae5 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bae7 3e 00			ld a, 0 
bae9 32 3d ea			ld (cli_mvdot), a 
baec c3 49 bb			jp .dotgo 
baef				NEXTW 
baef c3 e9 9e			jp macro_next 
baf2				endm 
# End of macro NEXTW
baf2			.DOTF: 
baf2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
baf2 1c				db WORD_SYS_CORE+8             
baf3 20 bb			dw .DOT            
baf5 03				db 2 + 1 
baf6 .. 00			db ".>",0              
baf9				endm 
# End of macro CWHEAD
baf9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
baf9					; get value off TOS and display it 
baf9			        ; TODO BUG adds extra spaces 
baf9			        ; TODO BUG handle numerics? 
baf9					if DEBUG_FORTH_WORDS_KEY 
baf9						DMARK "DTC" 
baf9 f5				push af  
bafa 3a 0e bb			ld a, (.dmark)  
bafd 32 6b ee			ld (debug_mark),a  
bb00 3a 0f bb			ld a, (.dmark+1)  
bb03 32 6c ee			ld (debug_mark+1),a  
bb06 3a 10 bb			ld a, (.dmark+2)  
bb09 32 6d ee			ld (debug_mark+2),a  
bb0c 18 03			jr .pastdmark  
bb0e ..			.dmark: db "DTC"  
bb11 f1			.pastdmark: pop af  
bb12			endm  
# End of macro DMARK
bb12						CALLMONITOR 
bb12 cd 6f ee			call debug_vector  
bb15				endm  
# End of macro CALLMONITOR
bb15					endif 
bb15 3e 01			ld a, 1 
bb17 32 3d ea			ld (cli_mvdot), a 
bb1a c3 49 bb			jp .dotgo 
bb1d				NEXTW 
bb1d c3 e9 9e			jp macro_next 
bb20				endm 
# End of macro NEXTW
bb20			 
bb20			.DOT: 
bb20				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bb20 1c				db WORD_SYS_CORE+8             
bb21 fc bc			dw .CLS            
bb23 02				db 1 + 1 
bb24 .. 00			db ".",0              
bb26				endm 
# End of macro CWHEAD
bb26			        ; | . ( u -- ) Display TOS | DONE 
bb26					; get value off TOS and display it 
bb26			 
bb26					if DEBUG_FORTH_WORDS_KEY 
bb26						DMARK "DOT" 
bb26 f5				push af  
bb27 3a 3b bb			ld a, (.dmark)  
bb2a 32 6b ee			ld (debug_mark),a  
bb2d 3a 3c bb			ld a, (.dmark+1)  
bb30 32 6c ee			ld (debug_mark+1),a  
bb33 3a 3d bb			ld a, (.dmark+2)  
bb36 32 6d ee			ld (debug_mark+2),a  
bb39 18 03			jr .pastdmark  
bb3b ..			.dmark: db "DOT"  
bb3e f1			.pastdmark: pop af  
bb3f			endm  
# End of macro DMARK
bb3f						CALLMONITOR 
bb3f cd 6f ee			call debug_vector  
bb42				endm  
# End of macro CALLMONITOR
bb42					endif 
bb42 3e 00			ld a, 0 
bb44 32 3d ea			ld (cli_mvdot), a 
bb47 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb49				 
bb49			 
bb49			.dotgo: 
bb49			 
bb49			; move up type to on stack for parserv5 
bb49					FORTH_DSP 
bb49 cd f9 9c			call macro_forth_dsp 
bb4c				endm 
# End of macro FORTH_DSP
bb4c				;FORTH_DSP_VALUE  
bb4c			 
bb4c			if DEBUG_FORTH_DOT 
bb4c				DMARK "DOT" 
bb4c f5				push af  
bb4d 3a 61 bb			ld a, (.dmark)  
bb50 32 6b ee			ld (debug_mark),a  
bb53 3a 62 bb			ld a, (.dmark+1)  
bb56 32 6c ee			ld (debug_mark+1),a  
bb59 3a 63 bb			ld a, (.dmark+2)  
bb5c 32 6d ee			ld (debug_mark+2),a  
bb5f 18 03			jr .pastdmark  
bb61 ..			.dmark: db "DOT"  
bb64 f1			.pastdmark: pop af  
bb65			endm  
# End of macro DMARK
bb65				CALLMONITOR 
bb65 cd 6f ee			call debug_vector  
bb68				endm  
# End of macro CALLMONITOR
bb68			endif	 
bb68			;		.print: 
bb68			 
bb68 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb69 23				inc hl   ; position to the actual value 
bb6a fe 01			cp DS_TYPE_STR 
bb6c 20 06			jr nz, .dotnum1  
bb6e			 
bb6e			; display string 
bb6e				FORTH_DSP_VALUE  
bb6e cd 1c 9d			call macro_forth_dsp_value 
bb71				endm 
# End of macro FORTH_DSP_VALUE
bb71 eb				ex de,hl 
bb72 18 49			jr .dotwrite 
bb74			 
bb74			.dotnum1: 
bb74 fe 02			cp DS_TYPE_INUM 
bb76 20 44			jr nz, .dotflot 
bb78			 
bb78			 
bb78			; display number 
bb78			 
bb78			;	push hl 
bb78			;	call clear_display 
bb78			;	pop hl 
bb78			 
bb78 5e				ld e, (hl) 
bb79 23				inc hl 
bb7a 56				ld d, (hl) 
bb7b 21 c1 e2			ld hl, scratch 
bb7e			if DEBUG_FORTH_DOT 
bb7e				DMARK "DT1" 
bb7e f5				push af  
bb7f 3a 93 bb			ld a, (.dmark)  
bb82 32 6b ee			ld (debug_mark),a  
bb85 3a 94 bb			ld a, (.dmark+1)  
bb88 32 6c ee			ld (debug_mark+1),a  
bb8b 3a 95 bb			ld a, (.dmark+2)  
bb8e 32 6d ee			ld (debug_mark+2),a  
bb91 18 03			jr .pastdmark  
bb93 ..			.dmark: db "DT1"  
bb96 f1			.pastdmark: pop af  
bb97			endm  
# End of macro DMARK
bb97				CALLMONITOR 
bb97 cd 6f ee			call debug_vector  
bb9a				endm  
# End of macro CALLMONITOR
bb9a			endif	 
bb9a			 
bb9a cd e9 90			call uitoa_16 
bb9d eb				ex de,hl 
bb9e			 
bb9e			if DEBUG_FORTH_DOT 
bb9e				DMARK "DT2" 
bb9e f5				push af  
bb9f 3a b3 bb			ld a, (.dmark)  
bba2 32 6b ee			ld (debug_mark),a  
bba5 3a b4 bb			ld a, (.dmark+1)  
bba8 32 6c ee			ld (debug_mark+1),a  
bbab 3a b5 bb			ld a, (.dmark+2)  
bbae 32 6d ee			ld (debug_mark+2),a  
bbb1 18 03			jr .pastdmark  
bbb3 ..			.dmark: db "DT2"  
bbb6 f1			.pastdmark: pop af  
bbb7			endm  
# End of macro DMARK
bbb7				CALLMONITOR 
bbb7 cd 6f ee			call debug_vector  
bbba				endm  
# End of macro CALLMONITOR
bbba			endif	 
bbba			 
bbba			;	ld de, os_word_scratch 
bbba 18 01			jr .dotwrite 
bbbc			 
bbbc 00			.dotflot:   nop 
bbbd			; TODO print floating point number 
bbbd			 
bbbd			.dotwrite:		 
bbbd			 
bbbd					; if c is set then set all '-' to spaces 
bbbd					; need to also take into account .>  
bbbd			 
bbbd 3e 01				ld a, 1 
bbbf b9					cp c 
bbc0 20 67				jr nz, .nodashswap 
bbc2			 
bbc2					; DE has the string to write, working with HL 
bbc2			 
bbc2 06 ff				ld b, 255 
bbc4 d5					push de 
bbc5 e1					pop hl 
bbc6			 
bbc6			if DEBUG_FORTH_DOT 
bbc6				DMARK "DT-" 
bbc6 f5				push af  
bbc7 3a db bb			ld a, (.dmark)  
bbca 32 6b ee			ld (debug_mark),a  
bbcd 3a dc bb			ld a, (.dmark+1)  
bbd0 32 6c ee			ld (debug_mark+1),a  
bbd3 3a dd bb			ld a, (.dmark+2)  
bbd6 32 6d ee			ld (debug_mark+2),a  
bbd9 18 03			jr .pastdmark  
bbdb ..			.dmark: db "DT-"  
bbde f1			.pastdmark: pop af  
bbdf			endm  
# End of macro DMARK
bbdf				CALLMONITOR 
bbdf cd 6f ee			call debug_vector  
bbe2				endm  
# End of macro CALLMONITOR
bbe2			endif	 
bbe2 7e			.dashscan:	ld a, (hl) 
bbe3 fe 00				cp 0 
bbe5 28 42				jr z, .nodashswap 
bbe7 fe 2d				cp '-' 
bbe9 20 03				jr nz, .dashskip 
bbeb 3e 20				ld a, ' ' 
bbed 77					ld (hl), a 
bbee 23			.dashskip:	inc hl 
bbef			if DEBUG_FORTH_DOT 
bbef				DMARK "D-2" 
bbef f5				push af  
bbf0 3a 04 bc			ld a, (.dmark)  
bbf3 32 6b ee			ld (debug_mark),a  
bbf6 3a 05 bc			ld a, (.dmark+1)  
bbf9 32 6c ee			ld (debug_mark+1),a  
bbfc 3a 06 bc			ld a, (.dmark+2)  
bbff 32 6d ee			ld (debug_mark+2),a  
bc02 18 03			jr .pastdmark  
bc04 ..			.dmark: db "D-2"  
bc07 f1			.pastdmark: pop af  
bc08			endm  
# End of macro DMARK
bc08				CALLMONITOR 
bc08 cd 6f ee			call debug_vector  
bc0b				endm  
# End of macro CALLMONITOR
bc0b			endif	 
bc0b 10 d5				djnz .dashscan 
bc0d			 
bc0d			if DEBUG_FORTH_DOT 
bc0d				DMARK "D-1" 
bc0d f5				push af  
bc0e 3a 22 bc			ld a, (.dmark)  
bc11 32 6b ee			ld (debug_mark),a  
bc14 3a 23 bc			ld a, (.dmark+1)  
bc17 32 6c ee			ld (debug_mark+1),a  
bc1a 3a 24 bc			ld a, (.dmark+2)  
bc1d 32 6d ee			ld (debug_mark+2),a  
bc20 18 03			jr .pastdmark  
bc22 ..			.dmark: db "D-1"  
bc25 f1			.pastdmark: pop af  
bc26			endm  
# End of macro DMARK
bc26				CALLMONITOR 
bc26 cd 6f ee			call debug_vector  
bc29				endm  
# End of macro CALLMONITOR
bc29			endif	 
bc29			 
bc29			.nodashswap: 
bc29			 
bc29			if DEBUG_FORTH_DOT 
bc29				DMARK "D-o" 
bc29 f5				push af  
bc2a 3a 3e bc			ld a, (.dmark)  
bc2d 32 6b ee			ld (debug_mark),a  
bc30 3a 3f bc			ld a, (.dmark+1)  
bc33 32 6c ee			ld (debug_mark+1),a  
bc36 3a 40 bc			ld a, (.dmark+2)  
bc39 32 6d ee			ld (debug_mark+2),a  
bc3c 18 03			jr .pastdmark  
bc3e ..			.dmark: db "D-o"  
bc41 f1			.pastdmark: pop af  
bc42			endm  
# End of macro DMARK
bc42				CALLMONITOR 
bc42 cd 6f ee			call debug_vector  
bc45				endm  
# End of macro CALLMONITOR
bc45			endif	 
bc45			 
bc45 d5					push de   ; save string start in case we need to advance print 
bc46			 
bc46 3a 5e ea				ld a, (f_cursor_ptr) 
bc49 cd c2 8a				call str_at_display 
bc4c 3a 3c ea				ld a,(cli_autodisplay) 
bc4f fe 00				cp 0 
bc51 28 03				jr z, .noupdate 
bc53 cd d2 8a						call update_display 
bc56					.noupdate: 
bc56			 
bc56			 
bc56					; see if we need to advance the print position 
bc56			 
bc56 e1					pop hl   ; get back string 
bc57			;		ex de,hl 
bc57			 
bc57 3a 3d ea				ld a, (cli_mvdot) 
bc5a			if DEBUG_FORTH_DOT 
bc5a			;		ld e,a 
bc5a				DMARK "D>1" 
bc5a f5				push af  
bc5b 3a 6f bc			ld a, (.dmark)  
bc5e 32 6b ee			ld (debug_mark),a  
bc61 3a 70 bc			ld a, (.dmark+1)  
bc64 32 6c ee			ld (debug_mark+1),a  
bc67 3a 71 bc			ld a, (.dmark+2)  
bc6a 32 6d ee			ld (debug_mark+2),a  
bc6d 18 03			jr .pastdmark  
bc6f ..			.dmark: db "D>1"  
bc72 f1			.pastdmark: pop af  
bc73			endm  
# End of macro DMARK
bc73				CALLMONITOR 
bc73 cd 6f ee			call debug_vector  
bc76				endm  
# End of macro CALLMONITOR
bc76			endif	 
bc76 fe 00				cp 0 
bc78 28 44				jr z, .noadv 
bc7a					; yes, lets advance the print position 
bc7a 3e 00				ld a, 0 
bc7c cd 45 91				call strlent 
bc7f			if DEBUG_FORTH_DOT 
bc7f				DMARK "D-?" 
bc7f f5				push af  
bc80 3a 94 bc			ld a, (.dmark)  
bc83 32 6b ee			ld (debug_mark),a  
bc86 3a 95 bc			ld a, (.dmark+1)  
bc89 32 6c ee			ld (debug_mark+1),a  
bc8c 3a 96 bc			ld a, (.dmark+2)  
bc8f 32 6d ee			ld (debug_mark+2),a  
bc92 18 03			jr .pastdmark  
bc94 ..			.dmark: db "D-?"  
bc97 f1			.pastdmark: pop af  
bc98			endm  
# End of macro DMARK
bc98				CALLMONITOR 
bc98 cd 6f ee			call debug_vector  
bc9b				endm  
# End of macro CALLMONITOR
bc9b			endif	 
bc9b 3a 5e ea				ld a, (f_cursor_ptr) 
bc9e 85					add a,l 
bc9f					;call addatohl 
bc9f					;ld a, l 
bc9f 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bca2			 
bca2			if DEBUG_FORTH_DOT 
bca2				DMARK "D->" 
bca2 f5				push af  
bca3 3a b7 bc			ld a, (.dmark)  
bca6 32 6b ee			ld (debug_mark),a  
bca9 3a b8 bc			ld a, (.dmark+1)  
bcac 32 6c ee			ld (debug_mark+1),a  
bcaf 3a b9 bc			ld a, (.dmark+2)  
bcb2 32 6d ee			ld (debug_mark+2),a  
bcb5 18 03			jr .pastdmark  
bcb7 ..			.dmark: db "D->"  
bcba f1			.pastdmark: pop af  
bcbb			endm  
# End of macro DMARK
bcbb				CALLMONITOR 
bcbb cd 6f ee			call debug_vector  
bcbe				endm  
# End of macro CALLMONITOR
bcbe			endif	 
bcbe			 
bcbe			.noadv:	 
bcbe			 
bcbe					if DEBUG_FORTH_DOT_WAIT 
bcbe							call next_page_prompt 
bcbe					endif	 
bcbe			; TODO this pop off the stack causes a crash. i dont know why 
bcbe			 
bcbe			 
bcbe			if DEBUG_FORTH_DOT 
bcbe				DMARK "DTh" 
bcbe f5				push af  
bcbf 3a d3 bc			ld a, (.dmark)  
bcc2 32 6b ee			ld (debug_mark),a  
bcc5 3a d4 bc			ld a, (.dmark+1)  
bcc8 32 6c ee			ld (debug_mark+1),a  
bccb 3a d5 bc			ld a, (.dmark+2)  
bcce 32 6d ee			ld (debug_mark+2),a  
bcd1 18 03			jr .pastdmark  
bcd3 ..			.dmark: db "DTh"  
bcd6 f1			.pastdmark: pop af  
bcd7			endm  
# End of macro DMARK
bcd7				CALLMONITOR 
bcd7 cd 6f ee			call debug_vector  
bcda				endm  
# End of macro CALLMONITOR
bcda			endif	 
bcda			 
bcda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcda cd eb 9d			call macro_forth_dsp_pop 
bcdd				endm 
# End of macro FORTH_DSP_POP
bcdd			 
bcdd			if DEBUG_FORTH_DOT 
bcdd				DMARK "DTi" 
bcdd f5				push af  
bcde 3a f2 bc			ld a, (.dmark)  
bce1 32 6b ee			ld (debug_mark),a  
bce4 3a f3 bc			ld a, (.dmark+1)  
bce7 32 6c ee			ld (debug_mark+1),a  
bcea 3a f4 bc			ld a, (.dmark+2)  
bced 32 6d ee			ld (debug_mark+2),a  
bcf0 18 03			jr .pastdmark  
bcf2 ..			.dmark: db "DTi"  
bcf5 f1			.pastdmark: pop af  
bcf6			endm  
# End of macro DMARK
bcf6				CALLMONITOR 
bcf6 cd 6f ee			call debug_vector  
bcf9				endm  
# End of macro CALLMONITOR
bcf9			endif	 
bcf9			 
bcf9			 
bcf9					NEXTW 
bcf9 c3 e9 9e			jp macro_next 
bcfc				endm 
# End of macro NEXTW
bcfc			 
bcfc			.CLS: 
bcfc				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bcfc 35				db WORD_SYS_CORE+33             
bcfd 29 bd			dw .DRAW            
bcff 04				db 3 + 1 
bd00 .. 00			db "CLS",0              
bd04				endm 
# End of macro CWHEAD
bd04			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bd04					if DEBUG_FORTH_WORDS_KEY 
bd04						DMARK "CLS" 
bd04 f5				push af  
bd05 3a 19 bd			ld a, (.dmark)  
bd08 32 6b ee			ld (debug_mark),a  
bd0b 3a 1a bd			ld a, (.dmark+1)  
bd0e 32 6c ee			ld (debug_mark+1),a  
bd11 3a 1b bd			ld a, (.dmark+2)  
bd14 32 6d ee			ld (debug_mark+2),a  
bd17 18 03			jr .pastdmark  
bd19 ..			.dmark: db "CLS"  
bd1c f1			.pastdmark: pop af  
bd1d			endm  
# End of macro DMARK
bd1d						CALLMONITOR 
bd1d cd 6f ee			call debug_vector  
bd20				endm  
# End of macro CALLMONITOR
bd20					endif 
bd20 cd af 8a				call clear_display 
bd23 c3 37 be				jp .home		; and home cursor 
bd26					NEXTW 
bd26 c3 e9 9e			jp macro_next 
bd29				endm 
# End of macro NEXTW
bd29			 
bd29			.DRAW: 
bd29				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd29 36				db WORD_SYS_CORE+34             
bd2a 54 bd			dw .DUMP            
bd2c 05				db 4 + 1 
bd2d .. 00			db "DRAW",0              
bd32				endm 
# End of macro CWHEAD
bd32			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd32					if DEBUG_FORTH_WORDS_KEY 
bd32						DMARK "DRW" 
bd32 f5				push af  
bd33 3a 47 bd			ld a, (.dmark)  
bd36 32 6b ee			ld (debug_mark),a  
bd39 3a 48 bd			ld a, (.dmark+1)  
bd3c 32 6c ee			ld (debug_mark+1),a  
bd3f 3a 49 bd			ld a, (.dmark+2)  
bd42 32 6d ee			ld (debug_mark+2),a  
bd45 18 03			jr .pastdmark  
bd47 ..			.dmark: db "DRW"  
bd4a f1			.pastdmark: pop af  
bd4b			endm  
# End of macro DMARK
bd4b						CALLMONITOR 
bd4b cd 6f ee			call debug_vector  
bd4e				endm  
# End of macro CALLMONITOR
bd4e					endif 
bd4e cd d2 8a				call update_display 
bd51					NEXTW 
bd51 c3 e9 9e			jp macro_next 
bd54				endm 
# End of macro NEXTW
bd54			 
bd54			.DUMP: 
bd54				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd54 37				db WORD_SYS_CORE+35             
bd55 8c bd			dw .CDUMP            
bd57 05				db 4 + 1 
bd58 .. 00			db "DUMP",0              
bd5d				endm 
# End of macro CWHEAD
bd5d			; | DUMP ( x -- ) With address x display dump   | DONE 
bd5d			; TODO pop address to use off of the stack 
bd5d					if DEBUG_FORTH_WORDS_KEY 
bd5d						DMARK "DUM" 
bd5d f5				push af  
bd5e 3a 72 bd			ld a, (.dmark)  
bd61 32 6b ee			ld (debug_mark),a  
bd64 3a 73 bd			ld a, (.dmark+1)  
bd67 32 6c ee			ld (debug_mark+1),a  
bd6a 3a 74 bd			ld a, (.dmark+2)  
bd6d 32 6d ee			ld (debug_mark+2),a  
bd70 18 03			jr .pastdmark  
bd72 ..			.dmark: db "DUM"  
bd75 f1			.pastdmark: pop af  
bd76			endm  
# End of macro DMARK
bd76						CALLMONITOR 
bd76 cd 6f ee			call debug_vector  
bd79				endm  
# End of macro CALLMONITOR
bd79					endif 
bd79 cd af 8a				call clear_display 
bd7c			 
bd7c					; get address 
bd7c			 
bd7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd7c cd 33 9d			call macro_dsp_valuehl 
bd7f				endm 
# End of macro FORTH_DSP_VALUEHL
bd7f				 
bd7f					; save it for cdump 
bd7f			 
bd7f 22 e4 e5				ld (os_cur_ptr),hl 
bd82			 
bd82					; destroy value TOS 
bd82			 
bd82					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd82 cd eb 9d			call macro_forth_dsp_pop 
bd85				endm 
# End of macro FORTH_DSP_POP
bd85			 
bd85 cd bc 99				call dumpcont	; skip old style of param parsing	 
bd88 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd89					NEXTW 
bd89 c3 e9 9e			jp macro_next 
bd8c				endm 
# End of macro NEXTW
bd8c			.CDUMP: 
bd8c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd8c 38				db WORD_SYS_CORE+36             
bd8d bc bd			dw .DAT            
bd8f 06				db 5 + 1 
bd90 .. 00			db "CDUMP",0              
bd96				endm 
# End of macro CWHEAD
bd96			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd96					if DEBUG_FORTH_WORDS_KEY 
bd96						DMARK "CDP" 
bd96 f5				push af  
bd97 3a ab bd			ld a, (.dmark)  
bd9a 32 6b ee			ld (debug_mark),a  
bd9d 3a ac bd			ld a, (.dmark+1)  
bda0 32 6c ee			ld (debug_mark+1),a  
bda3 3a ad bd			ld a, (.dmark+2)  
bda6 32 6d ee			ld (debug_mark+2),a  
bda9 18 03			jr .pastdmark  
bdab ..			.dmark: db "CDP"  
bdae f1			.pastdmark: pop af  
bdaf			endm  
# End of macro DMARK
bdaf						CALLMONITOR 
bdaf cd 6f ee			call debug_vector  
bdb2				endm  
# End of macro CALLMONITOR
bdb2					endif 
bdb2 cd af 8a				call clear_display 
bdb5 cd bc 99				call dumpcont	 
bdb8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bdb9					NEXTW 
bdb9 c3 e9 9e			jp macro_next 
bdbc				endm 
# End of macro NEXTW
bdbc			 
bdbc			 
bdbc			 
bdbc			 
bdbc			.DAT: 
bdbc				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bdbc 3d				db WORD_SYS_CORE+41             
bdbd 12 be			dw .HOME            
bdbf 03				db 2 + 1 
bdc0 .. 00			db "AT",0              
bdc3				endm 
# End of macro CWHEAD
bdc3			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bdc3					if DEBUG_FORTH_WORDS_KEY 
bdc3						DMARK "AT." 
bdc3 f5				push af  
bdc4 3a d8 bd			ld a, (.dmark)  
bdc7 32 6b ee			ld (debug_mark),a  
bdca 3a d9 bd			ld a, (.dmark+1)  
bdcd 32 6c ee			ld (debug_mark+1),a  
bdd0 3a da bd			ld a, (.dmark+2)  
bdd3 32 6d ee			ld (debug_mark+2),a  
bdd6 18 03			jr .pastdmark  
bdd8 ..			.dmark: db "AT."  
bddb f1			.pastdmark: pop af  
bddc			endm  
# End of macro DMARK
bddc						CALLMONITOR 
bddc cd 6f ee			call debug_vector  
bddf				endm  
# End of macro CALLMONITOR
bddf					endif 
bddf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bddf cd 33 9d			call macro_dsp_valuehl 
bde2				endm 
# End of macro FORTH_DSP_VALUEHL
bde2			 
bde2			 
bde2					; TODO save cursor row 
bde2 7d					ld a,l 
bde3 fe 02				cp 2 
bde5 20 04				jr nz, .crow3 
bde7 3e 28				ld a, display_row_2 
bde9 18 12				jr .ccol1 
bdeb fe 03		.crow3:		cp 3 
bded 20 04				jr nz, .crow4 
bdef 3e 50				ld a, display_row_3 
bdf1 18 0a				jr .ccol1 
bdf3 fe 04		.crow4:		cp 4 
bdf5 20 04				jr nz, .crow1 
bdf7 3e 78				ld a, display_row_4 
bdf9 18 02				jr .ccol1 
bdfb 3e 00		.crow1:		ld a,display_row_1 
bdfd f5			.ccol1:		push af			; got row offset 
bdfe 6f					ld l,a 
bdff 26 00				ld h,0 
be01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be01 cd eb 9d			call macro_forth_dsp_pop 
be04				endm 
# End of macro FORTH_DSP_POP
be04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be04 cd 33 9d			call macro_dsp_valuehl 
be07				endm 
# End of macro FORTH_DSP_VALUEHL
be07					; TODO save cursor col 
be07 f1					pop af 
be08 85					add l		; add col offset 
be09 32 5e ea				ld (f_cursor_ptr), a 
be0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be0c cd eb 9d			call macro_forth_dsp_pop 
be0f				endm 
# End of macro FORTH_DSP_POP
be0f			 
be0f					; calculate  
be0f			 
be0f					NEXTW 
be0f c3 e9 9e			jp macro_next 
be12				endm 
# End of macro NEXTW
be12			 
be12			 
be12			.HOME: 
be12				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
be12 41				db WORD_SYS_CORE+45             
be13 3f be			dw .SPACE            
be15 05				db 4 + 1 
be16 .. 00			db "HOME",0              
be1b				endm 
# End of macro CWHEAD
be1b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
be1b					if DEBUG_FORTH_WORDS_KEY 
be1b						DMARK "HOM" 
be1b f5				push af  
be1c 3a 30 be			ld a, (.dmark)  
be1f 32 6b ee			ld (debug_mark),a  
be22 3a 31 be			ld a, (.dmark+1)  
be25 32 6c ee			ld (debug_mark+1),a  
be28 3a 32 be			ld a, (.dmark+2)  
be2b 32 6d ee			ld (debug_mark+2),a  
be2e 18 03			jr .pastdmark  
be30 ..			.dmark: db "HOM"  
be33 f1			.pastdmark: pop af  
be34			endm  
# End of macro DMARK
be34						CALLMONITOR 
be34 cd 6f ee			call debug_vector  
be37				endm  
# End of macro CALLMONITOR
be37					endif 
be37 3e 00		.home:		ld a, 0		; and home cursor 
be39 32 5e ea				ld (f_cursor_ptr), a 
be3c					NEXTW 
be3c c3 e9 9e			jp macro_next 
be3f				endm 
# End of macro NEXTW
be3f			 
be3f			 
be3f			.SPACE: 
be3f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be3f 46				db WORD_SYS_CORE+50             
be40 75 be			dw .SPACES            
be42 03				db 2 + 1 
be43 .. 00			db "BL",0              
be46				endm 
# End of macro CWHEAD
be46			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be46					if DEBUG_FORTH_WORDS_KEY 
be46						DMARK "BL." 
be46 f5				push af  
be47 3a 5b be			ld a, (.dmark)  
be4a 32 6b ee			ld (debug_mark),a  
be4d 3a 5c be			ld a, (.dmark+1)  
be50 32 6c ee			ld (debug_mark+1),a  
be53 3a 5d be			ld a, (.dmark+2)  
be56 32 6d ee			ld (debug_mark+2),a  
be59 18 03			jr .pastdmark  
be5b ..			.dmark: db "BL."  
be5e f1			.pastdmark: pop af  
be5f			endm  
# End of macro DMARK
be5f						CALLMONITOR 
be5f cd 6f ee			call debug_vector  
be62				endm  
# End of macro CALLMONITOR
be62					endif 
be62 3e 20				ld a, " " 
be64 32 c1 e2				ld (scratch),a 
be67 3e 00				ld a, 0 
be69 32 c2 e2				ld (scratch+1),a 
be6c 21 c1 e2				ld hl, scratch 
be6f cd aa 9b				call forth_push_str 
be72					 
be72				       NEXTW 
be72 c3 e9 9e			jp macro_next 
be75				endm 
# End of macro NEXTW
be75			 
be75			;.blstr: db " ", 0 
be75			 
be75			.SPACES: 
be75				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be75 47				db WORD_SYS_CORE+51             
be76 10 bf			dw .SCROLL            
be78 07				db 6 + 1 
be79 .. 00			db "SPACES",0              
be80				endm 
# End of macro CWHEAD
be80			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be80					if DEBUG_FORTH_WORDS_KEY 
be80						DMARK "SPS" 
be80 f5				push af  
be81 3a 95 be			ld a, (.dmark)  
be84 32 6b ee			ld (debug_mark),a  
be87 3a 96 be			ld a, (.dmark+1)  
be8a 32 6c ee			ld (debug_mark+1),a  
be8d 3a 97 be			ld a, (.dmark+2)  
be90 32 6d ee			ld (debug_mark+2),a  
be93 18 03			jr .pastdmark  
be95 ..			.dmark: db "SPS"  
be98 f1			.pastdmark: pop af  
be99			endm  
# End of macro DMARK
be99						CALLMONITOR 
be99 cd 6f ee			call debug_vector  
be9c				endm  
# End of macro CALLMONITOR
be9c					endif 
be9c			 
be9c			 
be9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be9c cd 33 9d			call macro_dsp_valuehl 
be9f				endm 
# End of macro FORTH_DSP_VALUEHL
be9f			 
be9f e5					push hl    ; u 
bea0					if DEBUG_FORTH_WORDS 
bea0						DMARK "SPA" 
bea0 f5				push af  
bea1 3a b5 be			ld a, (.dmark)  
bea4 32 6b ee			ld (debug_mark),a  
bea7 3a b6 be			ld a, (.dmark+1)  
beaa 32 6c ee			ld (debug_mark+1),a  
bead 3a b7 be			ld a, (.dmark+2)  
beb0 32 6d ee			ld (debug_mark+2),a  
beb3 18 03			jr .pastdmark  
beb5 ..			.dmark: db "SPA"  
beb8 f1			.pastdmark: pop af  
beb9			endm  
# End of macro DMARK
beb9						CALLMONITOR 
beb9 cd 6f ee			call debug_vector  
bebc				endm  
# End of macro CALLMONITOR
bebc					endif 
bebc			 
bebc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bebc cd eb 9d			call macro_forth_dsp_pop 
bebf				endm 
# End of macro FORTH_DSP_POP
bebf e1					pop hl 
bec0 0e 00				ld c, 0 
bec2 45					ld b, l 
bec3 21 c1 e2				ld hl, scratch  
bec6			 
bec6					if DEBUG_FORTH_WORDS 
bec6						DMARK "SP2" 
bec6 f5				push af  
bec7 3a db be			ld a, (.dmark)  
beca 32 6b ee			ld (debug_mark),a  
becd 3a dc be			ld a, (.dmark+1)  
bed0 32 6c ee			ld (debug_mark+1),a  
bed3 3a dd be			ld a, (.dmark+2)  
bed6 32 6d ee			ld (debug_mark+2),a  
bed9 18 03			jr .pastdmark  
bedb ..			.dmark: db "SP2"  
bede f1			.pastdmark: pop af  
bedf			endm  
# End of macro DMARK
bedf						CALLMONITOR 
bedf cd 6f ee			call debug_vector  
bee2				endm  
# End of macro CALLMONITOR
bee2					endif 
bee2 3e 20				ld a, ' ' 
bee4			.spaces1:	 
bee4 77					ld (hl),a 
bee5 23					inc hl 
bee6					 
bee6 10 fc				djnz .spaces1 
bee8 3e 00				ld a,0 
beea 77					ld (hl),a 
beeb 21 c1 e2				ld hl, scratch 
beee					if DEBUG_FORTH_WORDS 
beee						DMARK "SP3" 
beee f5				push af  
beef 3a 03 bf			ld a, (.dmark)  
bef2 32 6b ee			ld (debug_mark),a  
bef5 3a 04 bf			ld a, (.dmark+1)  
bef8 32 6c ee			ld (debug_mark+1),a  
befb 3a 05 bf			ld a, (.dmark+2)  
befe 32 6d ee			ld (debug_mark+2),a  
bf01 18 03			jr .pastdmark  
bf03 ..			.dmark: db "SP3"  
bf06 f1			.pastdmark: pop af  
bf07			endm  
# End of macro DMARK
bf07						CALLMONITOR 
bf07 cd 6f ee			call debug_vector  
bf0a				endm  
# End of macro CALLMONITOR
bf0a					endif 
bf0a cd aa 9b				call forth_push_str 
bf0d			 
bf0d				       NEXTW 
bf0d c3 e9 9e			jp macro_next 
bf10				endm 
# End of macro NEXTW
bf10			 
bf10			 
bf10			 
bf10			.SCROLL: 
bf10				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bf10 53				db WORD_SYS_CORE+63             
bf11 3d bf			dw .SCROLLD            
bf13 07				db 6 + 1 
bf14 .. 00			db "SCROLL",0              
bf1b				endm 
# End of macro CWHEAD
bf1b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bf1b					if DEBUG_FORTH_WORDS_KEY 
bf1b						DMARK "SCR" 
bf1b f5				push af  
bf1c 3a 30 bf			ld a, (.dmark)  
bf1f 32 6b ee			ld (debug_mark),a  
bf22 3a 31 bf			ld a, (.dmark+1)  
bf25 32 6c ee			ld (debug_mark+1),a  
bf28 3a 32 bf			ld a, (.dmark+2)  
bf2b 32 6d ee			ld (debug_mark+2),a  
bf2e 18 03			jr .pastdmark  
bf30 ..			.dmark: db "SCR"  
bf33 f1			.pastdmark: pop af  
bf34			endm  
# End of macro DMARK
bf34						CALLMONITOR 
bf34 cd 6f ee			call debug_vector  
bf37				endm  
# End of macro CALLMONITOR
bf37					endif 
bf37			 
bf37 cd 71 8a			call scroll_up 
bf3a			;	call update_display 
bf3a			 
bf3a					NEXTW 
bf3a c3 e9 9e			jp macro_next 
bf3d				endm 
# End of macro NEXTW
bf3d			 
bf3d			 
bf3d			 
bf3d			;		; get dir 
bf3d			; 
bf3d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf3d			; 
bf3d			;		push hl 
bf3d			; 
bf3d			;		; destroy value TOS 
bf3d			; 
bf3d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf3d			; 
bf3d			;		; get count 
bf3d			; 
bf3d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf3d			; 
bf3d			;		push hl 
bf3d			; 
bf3d			;		; destroy value TOS 
bf3d			; 
bf3d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf3d			; 
bf3d			;		; one value on hl get other one back 
bf3d			; 
bf3d			;		pop bc    ; count 
bf3d			; 
bf3d			;		pop de   ; dir 
bf3d			; 
bf3d			; 
bf3d			;		ld b, c 
bf3d			; 
bf3d			;.scrolldir:     push bc 
bf3d			;		push de 
bf3d			; 
bf3d			;		ld a, 0 
bf3d			;		cp e 
bf3d			;		jr z, .scrollup  
bf3d			;		call scroll_down 
bf3d			;		jr .scrollnext 
bf3d			;.scrollup:	call scroll_up 
bf3d			; 
bf3d			;		 
bf3d			;.scrollnext: 
bf3d			;		pop de 
bf3d			;		pop bc 
bf3d			;		djnz .scrolldir 
bf3d			; 
bf3d			; 
bf3d			; 
bf3d			; 
bf3d			; 
bf3d			;		NEXTW 
bf3d			 
bf3d			.SCROLLD: 
bf3d				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf3d 53				db WORD_SYS_CORE+63             
bf3e 6b bf			dw .ATQ            
bf40 08				db 7 + 1 
bf41 .. 00			db "SCROLLD",0              
bf49				endm 
# End of macro CWHEAD
bf49			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf49					if DEBUG_FORTH_WORDS_KEY 
bf49						DMARK "SCD" 
bf49 f5				push af  
bf4a 3a 5e bf			ld a, (.dmark)  
bf4d 32 6b ee			ld (debug_mark),a  
bf50 3a 5f bf			ld a, (.dmark+1)  
bf53 32 6c ee			ld (debug_mark+1),a  
bf56 3a 60 bf			ld a, (.dmark+2)  
bf59 32 6d ee			ld (debug_mark+2),a  
bf5c 18 03			jr .pastdmark  
bf5e ..			.dmark: db "SCD"  
bf61 f1			.pastdmark: pop af  
bf62			endm  
# End of macro DMARK
bf62						CALLMONITOR 
bf62 cd 6f ee			call debug_vector  
bf65				endm  
# End of macro CALLMONITOR
bf65					endif 
bf65			 
bf65 cd 95 8a			call scroll_down 
bf68			;	call update_display 
bf68			 
bf68					NEXTW 
bf68 c3 e9 9e			jp macro_next 
bf6b				endm 
# End of macro NEXTW
bf6b			 
bf6b			 
bf6b			.ATQ: 
bf6b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf6b 62				db WORD_SYS_CORE+78             
bf6c c9 bf			dw .AUTODSP            
bf6e 04				db 3 + 1 
bf6f .. 00			db "AT@",0              
bf73				endm 
# End of macro CWHEAD
bf73			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf73					if DEBUG_FORTH_WORDS_KEY 
bf73						DMARK "ATA" 
bf73 f5				push af  
bf74 3a 88 bf			ld a, (.dmark)  
bf77 32 6b ee			ld (debug_mark),a  
bf7a 3a 89 bf			ld a, (.dmark+1)  
bf7d 32 6c ee			ld (debug_mark+1),a  
bf80 3a 8a bf			ld a, (.dmark+2)  
bf83 32 6d ee			ld (debug_mark+2),a  
bf86 18 03			jr .pastdmark  
bf88 ..			.dmark: db "ATA"  
bf8b f1			.pastdmark: pop af  
bf8c			endm  
# End of macro DMARK
bf8c						CALLMONITOR 
bf8c cd 6f ee			call debug_vector  
bf8f				endm  
# End of macro CALLMONITOR
bf8f					endif 
bf8f			 
bf8f			 
bf8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf8f cd 33 9d			call macro_dsp_valuehl 
bf92				endm 
# End of macro FORTH_DSP_VALUEHL
bf92			 
bf92					; TODO save cursor row 
bf92 7d					ld a,l 
bf93 fe 02				cp 2 
bf95 20 04				jr nz, .crow3aq 
bf97 3e 28				ld a, display_row_2 
bf99 18 12				jr .ccol1aq 
bf9b fe 03		.crow3aq:		cp 3 
bf9d 20 04				jr nz, .crow4aq 
bf9f 3e 50				ld a, display_row_3 
bfa1 18 0a				jr .ccol1aq 
bfa3 fe 04		.crow4aq:		cp 4 
bfa5 20 04				jr nz, .crow1aq 
bfa7 3e 78				ld a, display_row_4 
bfa9 18 02				jr .ccol1aq 
bfab 3e 00		.crow1aq:		ld a,display_row_1 
bfad f5			.ccol1aq:		push af			; got row offset 
bfae 6f					ld l,a 
bfaf 26 00				ld h,0 
bfb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfb1 cd eb 9d			call macro_forth_dsp_pop 
bfb4				endm 
# End of macro FORTH_DSP_POP
bfb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb4 cd 33 9d			call macro_dsp_valuehl 
bfb7				endm 
# End of macro FORTH_DSP_VALUEHL
bfb7					; TODO save cursor col 
bfb7 f1					pop af 
bfb8 85					add l		; add col offset 
bfb9			 
bfb9					; add current frame buffer address 
bfb9 2a cc eb				ld hl, (display_fb_active) 
bfbc cd dc 8c				call addatohl 
bfbf			 
bfbf			 
bfbf			 
bfbf			 
bfbf					; get char frame buffer location offset in hl 
bfbf			 
bfbf 7e					ld a,(hl) 
bfc0 26 00				ld h, 0 
bfc2 6f					ld l, a 
bfc3			 
bfc3 cd 3c 9b				call forth_push_numhl 
bfc6			 
bfc6			 
bfc6					NEXTW 
bfc6 c3 e9 9e			jp macro_next 
bfc9				endm 
# End of macro NEXTW
bfc9			 
bfc9			.AUTODSP: 
bfc9				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bfc9 63				db WORD_SYS_CORE+79             
bfca df bf			dw .MENU            
bfcc 05				db 4 + 1 
bfcd .. 00			db "ADSP",0              
bfd2				endm 
# End of macro CWHEAD
bfd2			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bfd2			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bfd2			 
bfd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfd2 cd 33 9d			call macro_dsp_valuehl 
bfd5				endm 
# End of macro FORTH_DSP_VALUEHL
bfd5			 
bfd5			;		push hl 
bfd5			 
bfd5					; destroy value TOS 
bfd5			 
bfd5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfd5 cd eb 9d			call macro_forth_dsp_pop 
bfd8				endm 
# End of macro FORTH_DSP_POP
bfd8			 
bfd8			;		pop hl 
bfd8			 
bfd8 7d					ld a,l 
bfd9 32 3c ea				ld (cli_autodisplay), a 
bfdc				       NEXTW 
bfdc c3 e9 9e			jp macro_next 
bfdf				endm 
# End of macro NEXTW
bfdf			 
bfdf			.MENU: 
bfdf				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfdf 70				db WORD_SYS_CORE+92             
bfe0 88 c0			dw .ENDDISPLAY            
bfe2 05				db 4 + 1 
bfe3 .. 00			db "MENU",0              
bfe8				endm 
# End of macro CWHEAD
bfe8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bfe8			 
bfe8			;		; get number of items on the stack 
bfe8			; 
bfe8				 
bfe8					FORTH_DSP_VALUEHL 
bfe8 cd 33 9d			call macro_dsp_valuehl 
bfeb				endm 
# End of macro FORTH_DSP_VALUEHL
bfeb				 
bfeb					if DEBUG_FORTH_WORDS_KEY 
bfeb						DMARK "MNU" 
bfeb f5				push af  
bfec 3a 00 c0			ld a, (.dmark)  
bfef 32 6b ee			ld (debug_mark),a  
bff2 3a 01 c0			ld a, (.dmark+1)  
bff5 32 6c ee			ld (debug_mark+1),a  
bff8 3a 02 c0			ld a, (.dmark+2)  
bffb 32 6d ee			ld (debug_mark+2),a  
bffe 18 03			jr .pastdmark  
c000 ..			.dmark: db "MNU"  
c003 f1			.pastdmark: pop af  
c004			endm  
# End of macro DMARK
c004						CALLMONITOR 
c004 cd 6f ee			call debug_vector  
c007				endm  
# End of macro CALLMONITOR
c007					endif 
c007			 
c007 45					ld b, l	 
c008 05					dec b 
c009			 
c009					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c009 cd eb 9d			call macro_forth_dsp_pop 
c00c				endm 
# End of macro FORTH_DSP_POP
c00c			 
c00c			 
c00c					; go directly through the stack to pluck out the string pointers and build an array 
c00c			 
c00c			;		FORTH_DSP 
c00c			 
c00c					; hl contains top most stack item 
c00c				 
c00c 11 c1 e2				ld de, scratch 
c00f			 
c00f			.mbuild: 
c00f			 
c00f					FORTH_DSP_VALUEHL 
c00f cd 33 9d			call macro_dsp_valuehl 
c012				endm 
# End of macro FORTH_DSP_VALUEHL
c012			 
c012					if DEBUG_FORTH_WORDS 
c012						DMARK "MN3" 
c012 f5				push af  
c013 3a 27 c0			ld a, (.dmark)  
c016 32 6b ee			ld (debug_mark),a  
c019 3a 28 c0			ld a, (.dmark+1)  
c01c 32 6c ee			ld (debug_mark+1),a  
c01f 3a 29 c0			ld a, (.dmark+2)  
c022 32 6d ee			ld (debug_mark+2),a  
c025 18 03			jr .pastdmark  
c027 ..			.dmark: db "MN3"  
c02a f1			.pastdmark: pop af  
c02b			endm  
# End of macro DMARK
c02b						CALLMONITOR 
c02b cd 6f ee			call debug_vector  
c02e				endm  
# End of macro CALLMONITOR
c02e					endif 
c02e eb					ex de, hl 
c02f 73					ld (hl), e 
c030 23					inc hl 
c031 72					ld (hl), d 
c032 23					inc hl 
c033 eb					ex de, hl 
c034			 
c034					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c034 cd eb 9d			call macro_forth_dsp_pop 
c037				endm 
# End of macro FORTH_DSP_POP
c037			 
c037 10 d6				djnz .mbuild 
c039			 
c039					; done add term 
c039			 
c039 eb					ex de, hl 
c03a 36 00				ld (hl), 0 
c03c 23					inc hl 
c03d 36 00				ld (hl), 0 
c03f			 
c03f				 
c03f					 
c03f 21 c1 e2				ld hl, scratch 
c042			 
c042					if DEBUG_FORTH_WORDS 
c042						DMARK "MNx" 
c042 f5				push af  
c043 3a 57 c0			ld a, (.dmark)  
c046 32 6b ee			ld (debug_mark),a  
c049 3a 58 c0			ld a, (.dmark+1)  
c04c 32 6c ee			ld (debug_mark+1),a  
c04f 3a 59 c0			ld a, (.dmark+2)  
c052 32 6d ee			ld (debug_mark+2),a  
c055 18 03			jr .pastdmark  
c057 ..			.dmark: db "MNx"  
c05a f1			.pastdmark: pop af  
c05b			endm  
# End of macro DMARK
c05b						CALLMONITOR 
c05b cd 6f ee			call debug_vector  
c05e				endm  
# End of macro CALLMONITOR
c05e					endif 
c05e			 
c05e			 
c05e			 
c05e 3e 00				ld a, 0 
c060 cd e0 8a				call menu 
c063			 
c063			 
c063 6f					ld l, a 
c064 26 00				ld h, 0 
c066			 
c066					if DEBUG_FORTH_WORDS 
c066						DMARK "MNr" 
c066 f5				push af  
c067 3a 7b c0			ld a, (.dmark)  
c06a 32 6b ee			ld (debug_mark),a  
c06d 3a 7c c0			ld a, (.dmark+1)  
c070 32 6c ee			ld (debug_mark+1),a  
c073 3a 7d c0			ld a, (.dmark+2)  
c076 32 6d ee			ld (debug_mark+2),a  
c079 18 03			jr .pastdmark  
c07b ..			.dmark: db "MNr"  
c07e f1			.pastdmark: pop af  
c07f			endm  
# End of macro DMARK
c07f						CALLMONITOR 
c07f cd 6f ee			call debug_vector  
c082				endm  
# End of macro CALLMONITOR
c082					endif 
c082			 
c082 cd 3c 9b				call forth_push_numhl 
c085			 
c085			 
c085			 
c085			 
c085				       NEXTW 
c085 c3 e9 9e			jp macro_next 
c088				endm 
# End of macro NEXTW
c088			 
c088			 
c088			.ENDDISPLAY: 
c088			 
c088			; eof 
# End of file forth_words_display.asm
c088			include "forth_words_str.asm" 
c088			 
c088			; | ## String Words 
c088			 
c088			.PTR:   
c088			 
c088				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c088 48				db WORD_SYS_CORE+52             
c089 b5 c0			dw .STYPE            
c08b 04				db 3 + 1 
c08c .. 00			db "PTR",0              
c090				endm 
# End of macro CWHEAD
c090			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c090			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c090			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c090			 
c090					if DEBUG_FORTH_WORDS_KEY 
c090						DMARK "PTR" 
c090 f5				push af  
c091 3a a5 c0			ld a, (.dmark)  
c094 32 6b ee			ld (debug_mark),a  
c097 3a a6 c0			ld a, (.dmark+1)  
c09a 32 6c ee			ld (debug_mark+1),a  
c09d 3a a7 c0			ld a, (.dmark+2)  
c0a0 32 6d ee			ld (debug_mark+2),a  
c0a3 18 03			jr .pastdmark  
c0a5 ..			.dmark: db "PTR"  
c0a8 f1			.pastdmark: pop af  
c0a9			endm  
# End of macro DMARK
c0a9						CALLMONITOR 
c0a9 cd 6f ee			call debug_vector  
c0ac				endm  
# End of macro CALLMONITOR
c0ac					endif 
c0ac					FORTH_DSP_VALUEHL 
c0ac cd 33 9d			call macro_dsp_valuehl 
c0af				endm 
# End of macro FORTH_DSP_VALUEHL
c0af cd 3c 9b				call forth_push_numhl 
c0b2			 
c0b2			 
c0b2					NEXTW 
c0b2 c3 e9 9e			jp macro_next 
c0b5				endm 
# End of macro NEXTW
c0b5			.STYPE: 
c0b5				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c0b5 48				db WORD_SYS_CORE+52             
c0b6 04 c1			dw .UPPER            
c0b8 06				db 5 + 1 
c0b9 .. 00			db "STYPE",0              
c0bf				endm 
# End of macro CWHEAD
c0bf			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c0bf					if DEBUG_FORTH_WORDS_KEY 
c0bf						DMARK "STY" 
c0bf f5				push af  
c0c0 3a d4 c0			ld a, (.dmark)  
c0c3 32 6b ee			ld (debug_mark),a  
c0c6 3a d5 c0			ld a, (.dmark+1)  
c0c9 32 6c ee			ld (debug_mark+1),a  
c0cc 3a d6 c0			ld a, (.dmark+2)  
c0cf 32 6d ee			ld (debug_mark+2),a  
c0d2 18 03			jr .pastdmark  
c0d4 ..			.dmark: db "STY"  
c0d7 f1			.pastdmark: pop af  
c0d8			endm  
# End of macro DMARK
c0d8						CALLMONITOR 
c0d8 cd 6f ee			call debug_vector  
c0db				endm  
# End of macro CALLMONITOR
c0db					endif 
c0db					FORTH_DSP 
c0db cd f9 9c			call macro_forth_dsp 
c0de				endm 
# End of macro FORTH_DSP
c0de					;v5 FORTH_DSP_VALUE 
c0de			 
c0de 7e					ld a, (hl) 
c0df			 
c0df f5					push af 
c0e0			 
c0e0			; Dont destroy TOS		FORTH_DSP_POP 
c0e0			 
c0e0 f1					pop af 
c0e1			 
c0e1 fe 01				cp DS_TYPE_STR 
c0e3 28 09				jr z, .typestr 
c0e5			 
c0e5 fe 02				cp DS_TYPE_INUM 
c0e7 28 0a				jr z, .typeinum 
c0e9			 
c0e9 21 02 c1				ld hl, .tna 
c0ec 18 0a				jr .tpush 
c0ee			 
c0ee 21 fe c0		.typestr:	ld hl, .tstr 
c0f1 18 05				jr .tpush 
c0f3 21 00 c1		.typeinum:	ld hl, .tinum 
c0f6 18 00				jr .tpush 
c0f8			 
c0f8			.tpush: 
c0f8			 
c0f8 cd aa 9b				call forth_push_str 
c0fb			 
c0fb					NEXTW 
c0fb c3 e9 9e			jp macro_next 
c0fe				endm 
# End of macro NEXTW
c0fe .. 00		.tstr:	db "s",0 
c100 .. 00		.tinum:  db "i",0 
c102 .. 00		.tna:   db "?", 0 
c104			 
c104			 
c104			.UPPER: 
c104				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c104 48				db WORD_SYS_CORE+52             
c105 3f c1			dw .LOWER            
c107 06				db 5 + 1 
c108 .. 00			db "UPPER",0              
c10e				endm 
# End of macro CWHEAD
c10e			; | UPPER ( s -- s ) Upper case string s  | DONE 
c10e					if DEBUG_FORTH_WORDS_KEY 
c10e						DMARK "UPR" 
c10e f5				push af  
c10f 3a 23 c1			ld a, (.dmark)  
c112 32 6b ee			ld (debug_mark),a  
c115 3a 24 c1			ld a, (.dmark+1)  
c118 32 6c ee			ld (debug_mark+1),a  
c11b 3a 25 c1			ld a, (.dmark+2)  
c11e 32 6d ee			ld (debug_mark+2),a  
c121 18 03			jr .pastdmark  
c123 ..			.dmark: db "UPR"  
c126 f1			.pastdmark: pop af  
c127			endm  
# End of macro DMARK
c127						CALLMONITOR 
c127 cd 6f ee			call debug_vector  
c12a				endm  
# End of macro CALLMONITOR
c12a					endif 
c12a			 
c12a					FORTH_DSP 
c12a cd f9 9c			call macro_forth_dsp 
c12d				endm 
# End of macro FORTH_DSP
c12d					 
c12d			; TODO check is string type 
c12d			 
c12d					FORTH_DSP_VALUEHL 
c12d cd 33 9d			call macro_dsp_valuehl 
c130				endm 
# End of macro FORTH_DSP_VALUEHL
c130			; get pointer to string in hl 
c130			 
c130 7e			.toup:		ld a, (hl) 
c131 fe 00				cp 0 
c133 28 07				jr z, .toupdone 
c135			 
c135 cd 49 90				call to_upper 
c138			 
c138 77					ld (hl), a 
c139 23					inc hl 
c13a 18 f4				jr .toup 
c13c			 
c13c					 
c13c			 
c13c			 
c13c			; for each char convert to upper 
c13c					 
c13c			.toupdone: 
c13c			 
c13c			 
c13c					NEXTW 
c13c c3 e9 9e			jp macro_next 
c13f				endm 
# End of macro NEXTW
c13f			.LOWER: 
c13f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c13f 48				db WORD_SYS_CORE+52             
c140 7a c1			dw .TCASE            
c142 06				db 5 + 1 
c143 .. 00			db "LOWER",0              
c149				endm 
# End of macro CWHEAD
c149			; | LOWER ( s -- s ) Lower case string s  | DONE 
c149					if DEBUG_FORTH_WORDS_KEY 
c149						DMARK "LWR" 
c149 f5				push af  
c14a 3a 5e c1			ld a, (.dmark)  
c14d 32 6b ee			ld (debug_mark),a  
c150 3a 5f c1			ld a, (.dmark+1)  
c153 32 6c ee			ld (debug_mark+1),a  
c156 3a 60 c1			ld a, (.dmark+2)  
c159 32 6d ee			ld (debug_mark+2),a  
c15c 18 03			jr .pastdmark  
c15e ..			.dmark: db "LWR"  
c161 f1			.pastdmark: pop af  
c162			endm  
# End of macro DMARK
c162						CALLMONITOR 
c162 cd 6f ee			call debug_vector  
c165				endm  
# End of macro CALLMONITOR
c165					endif 
c165			 
c165					FORTH_DSP 
c165 cd f9 9c			call macro_forth_dsp 
c168				endm 
# End of macro FORTH_DSP
c168					 
c168			; TODO check is string type 
c168			 
c168					FORTH_DSP_VALUEHL 
c168 cd 33 9d			call macro_dsp_valuehl 
c16b				endm 
# End of macro FORTH_DSP_VALUEHL
c16b			; get pointer to string in hl 
c16b			 
c16b 7e			.tolow:		ld a, (hl) 
c16c fe 00				cp 0 
c16e 28 07				jr z, .tolowdone 
c170			 
c170 cd 52 90				call to_lower 
c173			 
c173 77					ld (hl), a 
c174 23					inc hl 
c175 18 f4				jr .tolow 
c177			 
c177					 
c177			 
c177			 
c177			; for each char convert to low 
c177					 
c177			.tolowdone: 
c177					NEXTW 
c177 c3 e9 9e			jp macro_next 
c17a				endm 
# End of macro NEXTW
c17a			.TCASE: 
c17a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c17a 48				db WORD_SYS_CORE+52             
c17b b0 c2			dw .SUBSTR            
c17d 06				db 5 + 1 
c17e .. 00			db "TCASE",0              
c184				endm 
# End of macro CWHEAD
c184			; | TCASE ( s -- s ) Title case string s  | DONE 
c184					if DEBUG_FORTH_WORDS_KEY 
c184						DMARK "TCS" 
c184 f5				push af  
c185 3a 99 c1			ld a, (.dmark)  
c188 32 6b ee			ld (debug_mark),a  
c18b 3a 9a c1			ld a, (.dmark+1)  
c18e 32 6c ee			ld (debug_mark+1),a  
c191 3a 9b c1			ld a, (.dmark+2)  
c194 32 6d ee			ld (debug_mark+2),a  
c197 18 03			jr .pastdmark  
c199 ..			.dmark: db "TCS"  
c19c f1			.pastdmark: pop af  
c19d			endm  
# End of macro DMARK
c19d						CALLMONITOR 
c19d cd 6f ee			call debug_vector  
c1a0				endm  
# End of macro CALLMONITOR
c1a0					endif 
c1a0			 
c1a0					FORTH_DSP 
c1a0 cd f9 9c			call macro_forth_dsp 
c1a3				endm 
# End of macro FORTH_DSP
c1a3					 
c1a3			; TODO check is string type 
c1a3			 
c1a3					FORTH_DSP_VALUEHL 
c1a3 cd 33 9d			call macro_dsp_valuehl 
c1a6				endm 
# End of macro FORTH_DSP_VALUEHL
c1a6			; get pointer to string in hl 
c1a6			 
c1a6					if DEBUG_FORTH_WORDS 
c1a6						DMARK "TC1" 
c1a6 f5				push af  
c1a7 3a bb c1			ld a, (.dmark)  
c1aa 32 6b ee			ld (debug_mark),a  
c1ad 3a bc c1			ld a, (.dmark+1)  
c1b0 32 6c ee			ld (debug_mark+1),a  
c1b3 3a bd c1			ld a, (.dmark+2)  
c1b6 32 6d ee			ld (debug_mark+2),a  
c1b9 18 03			jr .pastdmark  
c1bb ..			.dmark: db "TC1"  
c1be f1			.pastdmark: pop af  
c1bf			endm  
# End of macro DMARK
c1bf						CALLMONITOR 
c1bf cd 6f ee			call debug_vector  
c1c2				endm  
# End of macro CALLMONITOR
c1c2					endif 
c1c2			 
c1c2					; first time in turn to upper case first char 
c1c2			 
c1c2 7e					ld a, (hl) 
c1c3 c3 4d c2				jp .totsiptou 
c1c6			 
c1c6			 
c1c6 7e			.tot:		ld a, (hl) 
c1c7 fe 00				cp 0 
c1c9 ca 91 c2				jp z, .totdone 
c1cc			 
c1cc					if DEBUG_FORTH_WORDS 
c1cc						DMARK "TC2" 
c1cc f5				push af  
c1cd 3a e1 c1			ld a, (.dmark)  
c1d0 32 6b ee			ld (debug_mark),a  
c1d3 3a e2 c1			ld a, (.dmark+1)  
c1d6 32 6c ee			ld (debug_mark+1),a  
c1d9 3a e3 c1			ld a, (.dmark+2)  
c1dc 32 6d ee			ld (debug_mark+2),a  
c1df 18 03			jr .pastdmark  
c1e1 ..			.dmark: db "TC2"  
c1e4 f1			.pastdmark: pop af  
c1e5			endm  
# End of macro DMARK
c1e5						CALLMONITOR 
c1e5 cd 6f ee			call debug_vector  
c1e8				endm  
# End of macro CALLMONITOR
c1e8					endif 
c1e8					; check to see if current char is a space 
c1e8			 
c1e8 fe 20				cp ' ' 
c1ea 28 21				jr z, .totsp 
c1ec cd 52 90				call to_lower 
c1ef					if DEBUG_FORTH_WORDS 
c1ef						DMARK "TC3" 
c1ef f5				push af  
c1f0 3a 04 c2			ld a, (.dmark)  
c1f3 32 6b ee			ld (debug_mark),a  
c1f6 3a 05 c2			ld a, (.dmark+1)  
c1f9 32 6c ee			ld (debug_mark+1),a  
c1fc 3a 06 c2			ld a, (.dmark+2)  
c1ff 32 6d ee			ld (debug_mark+2),a  
c202 18 03			jr .pastdmark  
c204 ..			.dmark: db "TC3"  
c207 f1			.pastdmark: pop af  
c208			endm  
# End of macro DMARK
c208						CALLMONITOR 
c208 cd 6f ee			call debug_vector  
c20b				endm  
# End of macro CALLMONITOR
c20b					endif 
c20b 18 63				jr .totnxt 
c20d			 
c20d			.totsp:         ; on a space, find next char which should be upper 
c20d			 
c20d					if DEBUG_FORTH_WORDS 
c20d						DMARK "TC4" 
c20d f5				push af  
c20e 3a 22 c2			ld a, (.dmark)  
c211 32 6b ee			ld (debug_mark),a  
c214 3a 23 c2			ld a, (.dmark+1)  
c217 32 6c ee			ld (debug_mark+1),a  
c21a 3a 24 c2			ld a, (.dmark+2)  
c21d 32 6d ee			ld (debug_mark+2),a  
c220 18 03			jr .pastdmark  
c222 ..			.dmark: db "TC4"  
c225 f1			.pastdmark: pop af  
c226			endm  
# End of macro DMARK
c226						CALLMONITOR 
c226 cd 6f ee			call debug_vector  
c229				endm  
# End of macro CALLMONITOR
c229					endif 
c229					;; 
c229			 
c229 fe 20				cp ' ' 
c22b 20 20				jr nz, .totsiptou 
c22d 23					inc hl 
c22e 7e					ld a, (hl) 
c22f					if DEBUG_FORTH_WORDS 
c22f						DMARK "TC5" 
c22f f5				push af  
c230 3a 44 c2			ld a, (.dmark)  
c233 32 6b ee			ld (debug_mark),a  
c236 3a 45 c2			ld a, (.dmark+1)  
c239 32 6c ee			ld (debug_mark+1),a  
c23c 3a 46 c2			ld a, (.dmark+2)  
c23f 32 6d ee			ld (debug_mark+2),a  
c242 18 03			jr .pastdmark  
c244 ..			.dmark: db "TC5"  
c247 f1			.pastdmark: pop af  
c248			endm  
# End of macro DMARK
c248						CALLMONITOR 
c248 cd 6f ee			call debug_vector  
c24b				endm  
# End of macro CALLMONITOR
c24b					endif 
c24b 18 c0				jr .totsp 
c24d fe 00		.totsiptou:    cp 0 
c24f 28 40				jr z, .totdone 
c251					; not space and not zero term so upper case it 
c251 cd 49 90				call to_upper 
c254			 
c254					if DEBUG_FORTH_WORDS 
c254						DMARK "TC6" 
c254 f5				push af  
c255 3a 69 c2			ld a, (.dmark)  
c258 32 6b ee			ld (debug_mark),a  
c25b 3a 6a c2			ld a, (.dmark+1)  
c25e 32 6c ee			ld (debug_mark+1),a  
c261 3a 6b c2			ld a, (.dmark+2)  
c264 32 6d ee			ld (debug_mark+2),a  
c267 18 03			jr .pastdmark  
c269 ..			.dmark: db "TC6"  
c26c f1			.pastdmark: pop af  
c26d			endm  
# End of macro DMARK
c26d						CALLMONITOR 
c26d cd 6f ee			call debug_vector  
c270				endm  
# End of macro CALLMONITOR
c270					endif 
c270			 
c270			 
c270			.totnxt: 
c270			 
c270 77					ld (hl), a 
c271 23					inc hl 
c272					if DEBUG_FORTH_WORDS 
c272						DMARK "TC7" 
c272 f5				push af  
c273 3a 87 c2			ld a, (.dmark)  
c276 32 6b ee			ld (debug_mark),a  
c279 3a 88 c2			ld a, (.dmark+1)  
c27c 32 6c ee			ld (debug_mark+1),a  
c27f 3a 89 c2			ld a, (.dmark+2)  
c282 32 6d ee			ld (debug_mark+2),a  
c285 18 03			jr .pastdmark  
c287 ..			.dmark: db "TC7"  
c28a f1			.pastdmark: pop af  
c28b			endm  
# End of macro DMARK
c28b						CALLMONITOR 
c28b cd 6f ee			call debug_vector  
c28e				endm  
# End of macro CALLMONITOR
c28e					endif 
c28e c3 c6 c1				jp .tot 
c291			 
c291					 
c291			 
c291			 
c291			; for each char convert to low 
c291					 
c291			.totdone: 
c291					if DEBUG_FORTH_WORDS 
c291						DMARK "TCd" 
c291 f5				push af  
c292 3a a6 c2			ld a, (.dmark)  
c295 32 6b ee			ld (debug_mark),a  
c298 3a a7 c2			ld a, (.dmark+1)  
c29b 32 6c ee			ld (debug_mark+1),a  
c29e 3a a8 c2			ld a, (.dmark+2)  
c2a1 32 6d ee			ld (debug_mark+2),a  
c2a4 18 03			jr .pastdmark  
c2a6 ..			.dmark: db "TCd"  
c2a9 f1			.pastdmark: pop af  
c2aa			endm  
# End of macro DMARK
c2aa						CALLMONITOR 
c2aa cd 6f ee			call debug_vector  
c2ad				endm  
# End of macro CALLMONITOR
c2ad					endif 
c2ad					NEXTW 
c2ad c3 e9 9e			jp macro_next 
c2b0				endm 
# End of macro NEXTW
c2b0			 
c2b0			.SUBSTR: 
c2b0				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c2b0 48				db WORD_SYS_CORE+52             
c2b1 0e c3			dw .LEFT            
c2b3 07				db 6 + 1 
c2b4 .. 00			db "SUBSTR",0              
c2bb				endm 
# End of macro CWHEAD
c2bb			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c2bb			 
c2bb					if DEBUG_FORTH_WORDS_KEY 
c2bb						DMARK "SST" 
c2bb f5				push af  
c2bc 3a d0 c2			ld a, (.dmark)  
c2bf 32 6b ee			ld (debug_mark),a  
c2c2 3a d1 c2			ld a, (.dmark+1)  
c2c5 32 6c ee			ld (debug_mark+1),a  
c2c8 3a d2 c2			ld a, (.dmark+2)  
c2cb 32 6d ee			ld (debug_mark+2),a  
c2ce 18 03			jr .pastdmark  
c2d0 ..			.dmark: db "SST"  
c2d3 f1			.pastdmark: pop af  
c2d4			endm  
# End of macro DMARK
c2d4						CALLMONITOR 
c2d4 cd 6f ee			call debug_vector  
c2d7				endm  
# End of macro CALLMONITOR
c2d7					endif 
c2d7			; TODO check string type 
c2d7					FORTH_DSP_VALUEHL 
c2d7 cd 33 9d			call macro_dsp_valuehl 
c2da				endm 
# End of macro FORTH_DSP_VALUEHL
c2da			 
c2da e5					push hl      ; string length 
c2db			 
c2db					FORTH_DSP_POP 
c2db cd eb 9d			call macro_forth_dsp_pop 
c2de				endm 
# End of macro FORTH_DSP_POP
c2de			 
c2de					FORTH_DSP_VALUEHL 
c2de cd 33 9d			call macro_dsp_valuehl 
c2e1				endm 
# End of macro FORTH_DSP_VALUEHL
c2e1			 
c2e1 e5					push hl     ; start char 
c2e2			 
c2e2					FORTH_DSP_POP 
c2e2 cd eb 9d			call macro_forth_dsp_pop 
c2e5				endm 
# End of macro FORTH_DSP_POP
c2e5			 
c2e5			 
c2e5					FORTH_DSP_VALUE 
c2e5 cd 1c 9d			call macro_forth_dsp_value 
c2e8				endm 
# End of macro FORTH_DSP_VALUE
c2e8			 
c2e8 d1					pop de    ; get start post offset 
c2e9			 
c2e9 19					add hl, de    ; starting offset 
c2ea			 
c2ea c1					pop bc 
c2eb c5					push bc      ; grab size of string 
c2ec			 
c2ec e5					push hl    ; save string start  
c2ed			 
c2ed 26 00				ld h, 0 
c2ef 69					ld l, c 
c2f0 23					inc hl 
c2f1 23					inc hl 
c2f2			 
c2f2 cd a3 91				call malloc 
c2f5				if DEBUG_FORTH_MALLOC_GUARD 
c2f5 cc 28 cc				call z,malloc_error 
c2f8				endif 
c2f8			 
c2f8 eb					ex de, hl      ; save malloc area for string copy 
c2f9 e1					pop hl    ; get back source 
c2fa c1					pop bc    ; get length of string back 
c2fb			 
c2fb d5					push de    ; save malloc area for after we push 
c2fc ed b0				ldir     ; copy substr 
c2fe			 
c2fe			 
c2fe eb					ex de, hl 
c2ff 3e 00				ld a, 0 
c301 77					ld (hl), a   ; term substr 
c302			 
c302					 
c302 e1					pop hl    ; get malloc so we can push it 
c303 e5					push hl   ; save so we can free it afterwards 
c304			 
c304 cd aa 9b				call forth_push_str 
c307			 
c307 e1					pop hl 
c308 cd 6d 92				call free 
c30b			 
c30b					 
c30b					 
c30b			 
c30b			 
c30b					NEXTW 
c30b c3 e9 9e			jp macro_next 
c30e				endm 
# End of macro NEXTW
c30e			 
c30e			.LEFT: 
c30e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c30e 48				db WORD_SYS_CORE+52             
c30f 36 c3			dw .RIGHT            
c311 05				db 4 + 1 
c312 .. 00			db "LEFT",0              
c317				endm 
# End of macro CWHEAD
c317			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c317					if DEBUG_FORTH_WORDS_KEY 
c317						DMARK "LEF" 
c317 f5				push af  
c318 3a 2c c3			ld a, (.dmark)  
c31b 32 6b ee			ld (debug_mark),a  
c31e 3a 2d c3			ld a, (.dmark+1)  
c321 32 6c ee			ld (debug_mark+1),a  
c324 3a 2e c3			ld a, (.dmark+2)  
c327 32 6d ee			ld (debug_mark+2),a  
c32a 18 03			jr .pastdmark  
c32c ..			.dmark: db "LEF"  
c32f f1			.pastdmark: pop af  
c330			endm  
# End of macro DMARK
c330						CALLMONITOR 
c330 cd 6f ee			call debug_vector  
c333				endm  
# End of macro CALLMONITOR
c333					endif 
c333			 
c333					NEXTW 
c333 c3 e9 9e			jp macro_next 
c336				endm 
# End of macro NEXTW
c336			.RIGHT: 
c336				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c336 48				db WORD_SYS_CORE+52             
c337 5f c3			dw .STR2NUM            
c339 06				db 5 + 1 
c33a .. 00			db "RIGHT",0              
c340				endm 
# End of macro CWHEAD
c340			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c340					if DEBUG_FORTH_WORDS_KEY 
c340						DMARK "RIG" 
c340 f5				push af  
c341 3a 55 c3			ld a, (.dmark)  
c344 32 6b ee			ld (debug_mark),a  
c347 3a 56 c3			ld a, (.dmark+1)  
c34a 32 6c ee			ld (debug_mark+1),a  
c34d 3a 57 c3			ld a, (.dmark+2)  
c350 32 6d ee			ld (debug_mark+2),a  
c353 18 03			jr .pastdmark  
c355 ..			.dmark: db "RIG"  
c358 f1			.pastdmark: pop af  
c359			endm  
# End of macro DMARK
c359						CALLMONITOR 
c359 cd 6f ee			call debug_vector  
c35c				endm  
# End of macro CALLMONITOR
c35c					endif 
c35c			 
c35c					NEXTW 
c35c c3 e9 9e			jp macro_next 
c35f				endm 
# End of macro NEXTW
c35f			 
c35f			 
c35f			.STR2NUM: 
c35f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c35f 48				db WORD_SYS_CORE+52             
c360 eb c3			dw .NUM2STR            
c362 08				db 7 + 1 
c363 .. 00			db "STR2NUM",0              
c36b				endm 
# End of macro CWHEAD
c36b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c36b			 
c36b			 
c36b			; TODO STR type check to do 
c36b					if DEBUG_FORTH_WORDS_KEY 
c36b						DMARK "S2N" 
c36b f5				push af  
c36c 3a 80 c3			ld a, (.dmark)  
c36f 32 6b ee			ld (debug_mark),a  
c372 3a 81 c3			ld a, (.dmark+1)  
c375 32 6c ee			ld (debug_mark+1),a  
c378 3a 82 c3			ld a, (.dmark+2)  
c37b 32 6d ee			ld (debug_mark+2),a  
c37e 18 03			jr .pastdmark  
c380 ..			.dmark: db "S2N"  
c383 f1			.pastdmark: pop af  
c384			endm  
# End of macro DMARK
c384						CALLMONITOR 
c384 cd 6f ee			call debug_vector  
c387				endm  
# End of macro CALLMONITOR
c387					endif 
c387			 
c387					;FORTH_DSP 
c387					FORTH_DSP_VALUE 
c387 cd 1c 9d			call macro_forth_dsp_value 
c38a				endm 
# End of macro FORTH_DSP_VALUE
c38a					;inc hl 
c38a			 
c38a eb					ex de, hl 
c38b					if DEBUG_FORTH_WORDS 
c38b						DMARK "S2a" 
c38b f5				push af  
c38c 3a a0 c3			ld a, (.dmark)  
c38f 32 6b ee			ld (debug_mark),a  
c392 3a a1 c3			ld a, (.dmark+1)  
c395 32 6c ee			ld (debug_mark+1),a  
c398 3a a2 c3			ld a, (.dmark+2)  
c39b 32 6d ee			ld (debug_mark+2),a  
c39e 18 03			jr .pastdmark  
c3a0 ..			.dmark: db "S2a"  
c3a3 f1			.pastdmark: pop af  
c3a4			endm  
# End of macro DMARK
c3a4						CALLMONITOR 
c3a4 cd 6f ee			call debug_vector  
c3a7				endm  
# End of macro CALLMONITOR
c3a7					endif 
c3a7 cd d1 90				call string_to_uint16 
c3aa			 
c3aa					if DEBUG_FORTH_WORDS 
c3aa						DMARK "S2b" 
c3aa f5				push af  
c3ab 3a bf c3			ld a, (.dmark)  
c3ae 32 6b ee			ld (debug_mark),a  
c3b1 3a c0 c3			ld a, (.dmark+1)  
c3b4 32 6c ee			ld (debug_mark+1),a  
c3b7 3a c1 c3			ld a, (.dmark+2)  
c3ba 32 6d ee			ld (debug_mark+2),a  
c3bd 18 03			jr .pastdmark  
c3bf ..			.dmark: db "S2b"  
c3c2 f1			.pastdmark: pop af  
c3c3			endm  
# End of macro DMARK
c3c3						CALLMONITOR 
c3c3 cd 6f ee			call debug_vector  
c3c6				endm  
# End of macro CALLMONITOR
c3c6					endif 
c3c6			;		push hl 
c3c6					FORTH_DSP_POP 
c3c6 cd eb 9d			call macro_forth_dsp_pop 
c3c9				endm 
# End of macro FORTH_DSP_POP
c3c9			;		pop hl 
c3c9					 
c3c9					if DEBUG_FORTH_WORDS 
c3c9						DMARK "S2b" 
c3c9 f5				push af  
c3ca 3a de c3			ld a, (.dmark)  
c3cd 32 6b ee			ld (debug_mark),a  
c3d0 3a df c3			ld a, (.dmark+1)  
c3d3 32 6c ee			ld (debug_mark+1),a  
c3d6 3a e0 c3			ld a, (.dmark+2)  
c3d9 32 6d ee			ld (debug_mark+2),a  
c3dc 18 03			jr .pastdmark  
c3de ..			.dmark: db "S2b"  
c3e1 f1			.pastdmark: pop af  
c3e2			endm  
# End of macro DMARK
c3e2						CALLMONITOR 
c3e2 cd 6f ee			call debug_vector  
c3e5				endm  
# End of macro CALLMONITOR
c3e5					endif 
c3e5 cd 3c 9b				call forth_push_numhl	 
c3e8			 
c3e8				 
c3e8				       NEXTW 
c3e8 c3 e9 9e			jp macro_next 
c3eb				endm 
# End of macro NEXTW
c3eb			.NUM2STR: 
c3eb				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3eb 48				db WORD_SYS_CORE+52             
c3ec fa c3			dw .CONCAT            
c3ee 08				db 7 + 1 
c3ef .. 00			db "NUM2STR",0              
c3f7				endm 
# End of macro CWHEAD
c3f7			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c3f7			 
c3f7			;		; malloc a string to target 
c3f7			;		ld hl, 10     ; TODO max string size should be fine 
c3f7			;		call malloc 
c3f7			;		push hl    ; save malloc location 
c3f7			; 
c3f7			; 
c3f7			;; TODO check int type 
c3f7			;		FORTH_DSP_VALUEHL 
c3f7			;		ld a, l 
c3f7			;		call DispAToASCII   
c3f7			;;TODO need to chage above call to dump into string 
c3f7			; 
c3f7			; 
c3f7			 
c3f7				       NEXTW 
c3f7 c3 e9 9e			jp macro_next 
c3fa				endm 
# End of macro NEXTW
c3fa			 
c3fa			.CONCAT: 
c3fa				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3fa 48				db WORD_SYS_CORE+52             
c3fb ad c4			dw .FIND            
c3fd 07				db 6 + 1 
c3fe .. 00			db "CONCAT",0              
c405				endm 
# End of macro CWHEAD
c405			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c405			 
c405			; TODO check string type 
c405			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c405			 
c405					if DEBUG_FORTH_WORDS_KEY 
c405						DMARK "CON" 
c405 f5				push af  
c406 3a 1a c4			ld a, (.dmark)  
c409 32 6b ee			ld (debug_mark),a  
c40c 3a 1b c4			ld a, (.dmark+1)  
c40f 32 6c ee			ld (debug_mark+1),a  
c412 3a 1c c4			ld a, (.dmark+2)  
c415 32 6d ee			ld (debug_mark+2),a  
c418 18 03			jr .pastdmark  
c41a ..			.dmark: db "CON"  
c41d f1			.pastdmark: pop af  
c41e			endm  
# End of macro DMARK
c41e						CALLMONITOR 
c41e cd 6f ee			call debug_vector  
c421				endm  
# End of macro CALLMONITOR
c421					endif 
c421			 
c421			 
c421					FORTH_DSP_VALUE 
c421 cd 1c 9d			call macro_forth_dsp_value 
c424				endm 
# End of macro FORTH_DSP_VALUE
c424 e5					push hl   ; s2 
c425			 
c425					FORTH_DSP_POP 
c425 cd eb 9d			call macro_forth_dsp_pop 
c428				endm 
# End of macro FORTH_DSP_POP
c428			 
c428					FORTH_DSP_VALUE 
c428 cd 1c 9d			call macro_forth_dsp_value 
c42b				endm 
# End of macro FORTH_DSP_VALUE
c42b			 
c42b e5					push hl   ; s1 
c42c			 
c42c					FORTH_DSP_POP 
c42c cd eb 9d			call macro_forth_dsp_pop 
c42f				endm 
# End of macro FORTH_DSP_POP
c42f					 
c42f			 
c42f					; copy s1 
c42f			 
c42f				 
c42f					; save ptr 
c42f e1					pop hl  
c430 e5					push hl 
c431 3e 00				ld a, 0 
c433 cd 45 91				call strlent 
c436					;inc hl    ; zer0 
c436 06 00				ld b, 0 
c438 4d					ld c, l 
c439 e1					pop hl		 
c43a 11 c1 e2				ld de, scratch	 
c43d					if DEBUG_FORTH_WORDS 
c43d						DMARK "CO1" 
c43d f5				push af  
c43e 3a 52 c4			ld a, (.dmark)  
c441 32 6b ee			ld (debug_mark),a  
c444 3a 53 c4			ld a, (.dmark+1)  
c447 32 6c ee			ld (debug_mark+1),a  
c44a 3a 54 c4			ld a, (.dmark+2)  
c44d 32 6d ee			ld (debug_mark+2),a  
c450 18 03			jr .pastdmark  
c452 ..			.dmark: db "CO1"  
c455 f1			.pastdmark: pop af  
c456			endm  
# End of macro DMARK
c456						CALLMONITOR 
c456 cd 6f ee			call debug_vector  
c459				endm  
# End of macro CALLMONITOR
c459					endif 
c459 ed b0				ldir 
c45b			 
c45b e1					pop hl 
c45c e5					push hl 
c45d d5					push de 
c45e			 
c45e			 
c45e 3e 00				ld a, 0 
c460 cd 45 91				call strlent 
c463 23					inc hl    ; zer0 
c464 23					inc hl 
c465 06 00				ld b, 0 
c467 4d					ld c, l 
c468 d1					pop de 
c469 e1					pop hl		 
c46a					if DEBUG_FORTH_WORDS 
c46a						DMARK "CO2" 
c46a f5				push af  
c46b 3a 7f c4			ld a, (.dmark)  
c46e 32 6b ee			ld (debug_mark),a  
c471 3a 80 c4			ld a, (.dmark+1)  
c474 32 6c ee			ld (debug_mark+1),a  
c477 3a 81 c4			ld a, (.dmark+2)  
c47a 32 6d ee			ld (debug_mark+2),a  
c47d 18 03			jr .pastdmark  
c47f ..			.dmark: db "CO2"  
c482 f1			.pastdmark: pop af  
c483			endm  
# End of macro DMARK
c483						CALLMONITOR 
c483 cd 6f ee			call debug_vector  
c486				endm  
# End of macro CALLMONITOR
c486					endif 
c486 ed b0				ldir 
c488			 
c488			 
c488			 
c488 21 c1 e2				ld hl, scratch 
c48b					if DEBUG_FORTH_WORDS 
c48b						DMARK "CO5" 
c48b f5				push af  
c48c 3a a0 c4			ld a, (.dmark)  
c48f 32 6b ee			ld (debug_mark),a  
c492 3a a1 c4			ld a, (.dmark+1)  
c495 32 6c ee			ld (debug_mark+1),a  
c498 3a a2 c4			ld a, (.dmark+2)  
c49b 32 6d ee			ld (debug_mark+2),a  
c49e 18 03			jr .pastdmark  
c4a0 ..			.dmark: db "CO5"  
c4a3 f1			.pastdmark: pop af  
c4a4			endm  
# End of macro DMARK
c4a4						CALLMONITOR 
c4a4 cd 6f ee			call debug_vector  
c4a7				endm  
# End of macro CALLMONITOR
c4a7					endif 
c4a7			 
c4a7 cd aa 9b				call forth_push_str 
c4aa			 
c4aa			 
c4aa			 
c4aa			 
c4aa				       NEXTW 
c4aa c3 e9 9e			jp macro_next 
c4ad				endm 
# End of macro NEXTW
c4ad			 
c4ad			 
c4ad			.FIND: 
c4ad				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c4ad 4b				db WORD_SYS_CORE+55             
c4ae 6b c5			dw .LEN            
c4b0 05				db 4 + 1 
c4b1 .. 00			db "FIND",0              
c4b6				endm 
# End of macro CWHEAD
c4b6			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c4b6			 
c4b6					if DEBUG_FORTH_WORDS_KEY 
c4b6						DMARK "FND" 
c4b6 f5				push af  
c4b7 3a cb c4			ld a, (.dmark)  
c4ba 32 6b ee			ld (debug_mark),a  
c4bd 3a cc c4			ld a, (.dmark+1)  
c4c0 32 6c ee			ld (debug_mark+1),a  
c4c3 3a cd c4			ld a, (.dmark+2)  
c4c6 32 6d ee			ld (debug_mark+2),a  
c4c9 18 03			jr .pastdmark  
c4cb ..			.dmark: db "FND"  
c4ce f1			.pastdmark: pop af  
c4cf			endm  
# End of macro DMARK
c4cf						CALLMONITOR 
c4cf cd 6f ee			call debug_vector  
c4d2				endm  
# End of macro CALLMONITOR
c4d2					endif 
c4d2			 
c4d2			; TODO check string type 
c4d2					FORTH_DSP_VALUE 
c4d2 cd 1c 9d			call macro_forth_dsp_value 
c4d5				endm 
# End of macro FORTH_DSP_VALUE
c4d5			 
c4d5 e5					push hl    
c4d6 7e					ld a,(hl)    ; char to find   
c4d7			; TODO change char to substr 
c4d7			 
c4d7 f5					push af 
c4d8					 
c4d8			 
c4d8			 
c4d8					if DEBUG_FORTH_WORDS 
c4d8						DMARK "FN1" 
c4d8 f5				push af  
c4d9 3a ed c4			ld a, (.dmark)  
c4dc 32 6b ee			ld (debug_mark),a  
c4df 3a ee c4			ld a, (.dmark+1)  
c4e2 32 6c ee			ld (debug_mark+1),a  
c4e5 3a ef c4			ld a, (.dmark+2)  
c4e8 32 6d ee			ld (debug_mark+2),a  
c4eb 18 03			jr .pastdmark  
c4ed ..			.dmark: db "FN1"  
c4f0 f1			.pastdmark: pop af  
c4f1			endm  
# End of macro DMARK
c4f1						CALLMONITOR 
c4f1 cd 6f ee			call debug_vector  
c4f4				endm  
# End of macro CALLMONITOR
c4f4					endif 
c4f4			 
c4f4					FORTH_DSP_POP 
c4f4 cd eb 9d			call macro_forth_dsp_pop 
c4f7				endm 
# End of macro FORTH_DSP_POP
c4f7			 
c4f7					; string to search 
c4f7			 
c4f7					FORTH_DSP_VALUE 
c4f7 cd 1c 9d			call macro_forth_dsp_value 
c4fa				endm 
# End of macro FORTH_DSP_VALUE
c4fa			 
c4fa d1					pop de  ; d is char to find  
c4fb			 
c4fb					if DEBUG_FORTH_WORDS 
c4fb						DMARK "FN2" 
c4fb f5				push af  
c4fc 3a 10 c5			ld a, (.dmark)  
c4ff 32 6b ee			ld (debug_mark),a  
c502 3a 11 c5			ld a, (.dmark+1)  
c505 32 6c ee			ld (debug_mark+1),a  
c508 3a 12 c5			ld a, (.dmark+2)  
c50b 32 6d ee			ld (debug_mark+2),a  
c50e 18 03			jr .pastdmark  
c510 ..			.dmark: db "FN2"  
c513 f1			.pastdmark: pop af  
c514			endm  
# End of macro DMARK
c514						CALLMONITOR 
c514 cd 6f ee			call debug_vector  
c517				endm  
# End of macro CALLMONITOR
c517					endif 
c517					 
c517 01 00 00				ld bc, 0 
c51a 7e			.findchar:      ld a,(hl) 
c51b fe 00				cp 0   		 
c51d 28 27				jr z, .finddone     
c51f ba					cp d 
c520 28 20				jr z, .foundchar 
c522 03					inc bc 
c523 23					inc hl 
c524					if DEBUG_FORTH_WORDS 
c524						DMARK "FN3" 
c524 f5				push af  
c525 3a 39 c5			ld a, (.dmark)  
c528 32 6b ee			ld (debug_mark),a  
c52b 3a 3a c5			ld a, (.dmark+1)  
c52e 32 6c ee			ld (debug_mark+1),a  
c531 3a 3b c5			ld a, (.dmark+2)  
c534 32 6d ee			ld (debug_mark+2),a  
c537 18 03			jr .pastdmark  
c539 ..			.dmark: db "FN3"  
c53c f1			.pastdmark: pop af  
c53d			endm  
# End of macro DMARK
c53d						CALLMONITOR 
c53d cd 6f ee			call debug_vector  
c540				endm  
# End of macro CALLMONITOR
c540					endif 
c540 18 d8				jr .findchar 
c542			 
c542			 
c542 c5			.foundchar:	push bc 
c543 e1					pop hl 
c544 18 03				jr .findexit 
c546			 
c546			 
c546							 
c546			 
c546			.finddone:     ; got to end of string with no find 
c546 21 00 00				ld hl, 0 
c549			.findexit: 
c549			 
c549					if DEBUG_FORTH_WORDS 
c549						DMARK "FNd" 
c549 f5				push af  
c54a 3a 5e c5			ld a, (.dmark)  
c54d 32 6b ee			ld (debug_mark),a  
c550 3a 5f c5			ld a, (.dmark+1)  
c553 32 6c ee			ld (debug_mark+1),a  
c556 3a 60 c5			ld a, (.dmark+2)  
c559 32 6d ee			ld (debug_mark+2),a  
c55c 18 03			jr .pastdmark  
c55e ..			.dmark: db "FNd"  
c561 f1			.pastdmark: pop af  
c562			endm  
# End of macro DMARK
c562						CALLMONITOR 
c562 cd 6f ee			call debug_vector  
c565				endm  
# End of macro CALLMONITOR
c565					endif 
c565 cd 3c 9b			call forth_push_numhl 
c568			 
c568				       NEXTW 
c568 c3 e9 9e			jp macro_next 
c56b				endm 
# End of macro NEXTW
c56b			 
c56b			.LEN: 
c56b				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c56b 4c				db WORD_SYS_CORE+56             
c56c d5 c5			dw .ASC            
c56e 06				db 5 + 1 
c56f .. 00			db "COUNT",0              
c575				endm 
# End of macro CWHEAD
c575			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c575			 
c575					if DEBUG_FORTH_WORDS_KEY 
c575						DMARK "CNT" 
c575 f5				push af  
c576 3a 8a c5			ld a, (.dmark)  
c579 32 6b ee			ld (debug_mark),a  
c57c 3a 8b c5			ld a, (.dmark+1)  
c57f 32 6c ee			ld (debug_mark+1),a  
c582 3a 8c c5			ld a, (.dmark+2)  
c585 32 6d ee			ld (debug_mark+2),a  
c588 18 03			jr .pastdmark  
c58a ..			.dmark: db "CNT"  
c58d f1			.pastdmark: pop af  
c58e			endm  
# End of macro DMARK
c58e						CALLMONITOR 
c58e cd 6f ee			call debug_vector  
c591				endm  
# End of macro CALLMONITOR
c591					endif 
c591			; TODO check string type 
c591					FORTH_DSP_VALUE 
c591 cd 1c 9d			call macro_forth_dsp_value 
c594				endm 
# End of macro FORTH_DSP_VALUE
c594			 
c594			 
c594					if DEBUG_FORTH_WORDS 
c594						DMARK "CN?" 
c594 f5				push af  
c595 3a a9 c5			ld a, (.dmark)  
c598 32 6b ee			ld (debug_mark),a  
c59b 3a aa c5			ld a, (.dmark+1)  
c59e 32 6c ee			ld (debug_mark+1),a  
c5a1 3a ab c5			ld a, (.dmark+2)  
c5a4 32 6d ee			ld (debug_mark+2),a  
c5a7 18 03			jr .pastdmark  
c5a9 ..			.dmark: db "CN?"  
c5ac f1			.pastdmark: pop af  
c5ad			endm  
# End of macro DMARK
c5ad						CALLMONITOR 
c5ad cd 6f ee			call debug_vector  
c5b0				endm  
# End of macro CALLMONITOR
c5b0					endif 
c5b0 cd 3a 91				call strlenz 
c5b3					if DEBUG_FORTH_WORDS 
c5b3						DMARK "CNl" 
c5b3 f5				push af  
c5b4 3a c8 c5			ld a, (.dmark)  
c5b7 32 6b ee			ld (debug_mark),a  
c5ba 3a c9 c5			ld a, (.dmark+1)  
c5bd 32 6c ee			ld (debug_mark+1),a  
c5c0 3a ca c5			ld a, (.dmark+2)  
c5c3 32 6d ee			ld (debug_mark+2),a  
c5c6 18 03			jr .pastdmark  
c5c8 ..			.dmark: db "CNl"  
c5cb f1			.pastdmark: pop af  
c5cc			endm  
# End of macro DMARK
c5cc						CALLMONITOR 
c5cc cd 6f ee			call debug_vector  
c5cf				endm  
# End of macro CALLMONITOR
c5cf					endif 
c5cf			 
c5cf cd 3c 9b				call forth_push_numhl 
c5d2			 
c5d2			 
c5d2			 
c5d2				       NEXTW 
c5d2 c3 e9 9e			jp macro_next 
c5d5				endm 
# End of macro NEXTW
c5d5			.ASC: 
c5d5				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c5d5 4d				db WORD_SYS_CORE+57             
c5d6 43 c6			dw .CHR            
c5d8 04				db 3 + 1 
c5d9 .. 00			db "ASC",0              
c5dd				endm 
# End of macro CWHEAD
c5dd			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c5dd					if DEBUG_FORTH_WORDS_KEY 
c5dd						DMARK "ASC" 
c5dd f5				push af  
c5de 3a f2 c5			ld a, (.dmark)  
c5e1 32 6b ee			ld (debug_mark),a  
c5e4 3a f3 c5			ld a, (.dmark+1)  
c5e7 32 6c ee			ld (debug_mark+1),a  
c5ea 3a f4 c5			ld a, (.dmark+2)  
c5ed 32 6d ee			ld (debug_mark+2),a  
c5f0 18 03			jr .pastdmark  
c5f2 ..			.dmark: db "ASC"  
c5f5 f1			.pastdmark: pop af  
c5f6			endm  
# End of macro DMARK
c5f6						CALLMONITOR 
c5f6 cd 6f ee			call debug_vector  
c5f9				endm  
# End of macro CALLMONITOR
c5f9					endif 
c5f9					FORTH_DSP_VALUE 
c5f9 cd 1c 9d			call macro_forth_dsp_value 
c5fc				endm 
# End of macro FORTH_DSP_VALUE
c5fc					;v5 FORTH_DSP_VALUE 
c5fc			;		inc hl      ; now at start of numeric as string 
c5fc			 
c5fc e5					push hl 
c5fd			 
c5fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5fd cd eb 9d			call macro_forth_dsp_pop 
c600				endm 
# End of macro FORTH_DSP_POP
c600			 
c600 e1					pop hl 
c601			 
c601					if DEBUG_FORTH_WORDS 
c601						DMARK "AS1" 
c601 f5				push af  
c602 3a 16 c6			ld a, (.dmark)  
c605 32 6b ee			ld (debug_mark),a  
c608 3a 17 c6			ld a, (.dmark+1)  
c60b 32 6c ee			ld (debug_mark+1),a  
c60e 3a 18 c6			ld a, (.dmark+2)  
c611 32 6d ee			ld (debug_mark+2),a  
c614 18 03			jr .pastdmark  
c616 ..			.dmark: db "AS1"  
c619 f1			.pastdmark: pop af  
c61a			endm  
# End of macro DMARK
c61a						CALLMONITOR 
c61a cd 6f ee			call debug_vector  
c61d				endm  
# End of macro CALLMONITOR
c61d					endif 
c61d					; push the content of a onto the stack as a value 
c61d			 
c61d 7e					ld a,(hl)   ; get char 
c61e 26 00				ld h,0 
c620 6f					ld l,a 
c621					if DEBUG_FORTH_WORDS 
c621						DMARK "AS2" 
c621 f5				push af  
c622 3a 36 c6			ld a, (.dmark)  
c625 32 6b ee			ld (debug_mark),a  
c628 3a 37 c6			ld a, (.dmark+1)  
c62b 32 6c ee			ld (debug_mark+1),a  
c62e 3a 38 c6			ld a, (.dmark+2)  
c631 32 6d ee			ld (debug_mark+2),a  
c634 18 03			jr .pastdmark  
c636 ..			.dmark: db "AS2"  
c639 f1			.pastdmark: pop af  
c63a			endm  
# End of macro DMARK
c63a						CALLMONITOR 
c63a cd 6f ee			call debug_vector  
c63d				endm  
# End of macro CALLMONITOR
c63d					endif 
c63d cd 3c 9b				call forth_push_numhl 
c640			 
c640				       NEXTW 
c640 c3 e9 9e			jp macro_next 
c643				endm 
# End of macro NEXTW
c643			 
c643			.CHR: 
c643				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c643 4d				db WORD_SYS_CORE+57             
c644 7f c6			dw .ENDSTR            
c646 04				db 3 + 1 
c647 .. 00			db "CHR",0              
c64b				endm 
# End of macro CWHEAD
c64b			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c64b					if DEBUG_FORTH_WORDS_KEY 
c64b						DMARK "CHR" 
c64b f5				push af  
c64c 3a 60 c6			ld a, (.dmark)  
c64f 32 6b ee			ld (debug_mark),a  
c652 3a 61 c6			ld a, (.dmark+1)  
c655 32 6c ee			ld (debug_mark+1),a  
c658 3a 62 c6			ld a, (.dmark+2)  
c65b 32 6d ee			ld (debug_mark+2),a  
c65e 18 03			jr .pastdmark  
c660 ..			.dmark: db "CHR"  
c663 f1			.pastdmark: pop af  
c664			endm  
# End of macro DMARK
c664						CALLMONITOR 
c664 cd 6f ee			call debug_vector  
c667				endm  
# End of macro CALLMONITOR
c667					endif 
c667					FORTH_DSP_VALUEHL 
c667 cd 33 9d			call macro_dsp_valuehl 
c66a				endm 
# End of macro FORTH_DSP_VALUEHL
c66a			 
c66a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c66a cd eb 9d			call macro_forth_dsp_pop 
c66d				endm 
# End of macro FORTH_DSP_POP
c66d			 
c66d					; save asci byte as a zero term string and push string 
c66d			 
c66d 7d					ld a,l 
c66e 32 c1 e2				ld (scratch), a 
c671			 
c671 3e 00				ld a, 0 
c673 32 c2 e2				ld (scratch+1), a 
c676			 
c676 21 c1 e2				ld hl, scratch 
c679 cd aa 9b				call forth_push_str 
c67c			 
c67c			 
c67c				       NEXTW 
c67c c3 e9 9e			jp macro_next 
c67f				endm 
# End of macro NEXTW
c67f			 
c67f			 
c67f			 
c67f			 
c67f			.ENDSTR: 
c67f			; eof 
c67f			 
# End of file forth_words_str.asm
c67f			include "forth_words_key.asm" 
c67f			 
c67f			; | ## Keyboard Words 
c67f			 
c67f			.KEY: 
c67f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c67f 3e				db WORD_SYS_CORE+42             
c680 af c6			dw .WAITK            
c682 04				db 3 + 1 
c683 .. 00			db "KEY",0              
c687				endm 
# End of macro CWHEAD
c687			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c687			 
c687					if DEBUG_FORTH_WORDS_KEY 
c687						DMARK "KEY" 
c687 f5				push af  
c688 3a 9c c6			ld a, (.dmark)  
c68b 32 6b ee			ld (debug_mark),a  
c68e 3a 9d c6			ld a, (.dmark+1)  
c691 32 6c ee			ld (debug_mark+1),a  
c694 3a 9e c6			ld a, (.dmark+2)  
c697 32 6d ee			ld (debug_mark+2),a  
c69a 18 03			jr .pastdmark  
c69c ..			.dmark: db "KEY"  
c69f f1			.pastdmark: pop af  
c6a0			endm  
# End of macro DMARK
c6a0						CALLMONITOR 
c6a0 cd 6f ee			call debug_vector  
c6a3				endm  
# End of macro CALLMONITOR
c6a3					endif 
c6a3			; TODO currently waits 
c6a3 cd 1f e4				call cin 
c6a6					;call cin_wait 
c6a6 6f					ld l, a 
c6a7 26 00				ld h, 0 
c6a9 cd 3c 9b				call forth_push_numhl 
c6ac					NEXTW 
c6ac c3 e9 9e			jp macro_next 
c6af				endm 
# End of macro NEXTW
c6af			.WAITK: 
c6af				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c6af 3f				db WORD_SYS_CORE+43             
c6b0 e1 c6			dw .ACCEPT            
c6b2 06				db 5 + 1 
c6b3 .. 00			db "WAITK",0              
c6b9				endm 
# End of macro CWHEAD
c6b9			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c6b9					if DEBUG_FORTH_WORDS_KEY 
c6b9						DMARK "WAI" 
c6b9 f5				push af  
c6ba 3a ce c6			ld a, (.dmark)  
c6bd 32 6b ee			ld (debug_mark),a  
c6c0 3a cf c6			ld a, (.dmark+1)  
c6c3 32 6c ee			ld (debug_mark+1),a  
c6c6 3a d0 c6			ld a, (.dmark+2)  
c6c9 32 6d ee			ld (debug_mark+2),a  
c6cc 18 03			jr .pastdmark  
c6ce ..			.dmark: db "WAI"  
c6d1 f1			.pastdmark: pop af  
c6d2			endm  
# End of macro DMARK
c6d2						CALLMONITOR 
c6d2 cd 6f ee			call debug_vector  
c6d5				endm  
# End of macro CALLMONITOR
c6d5					endif 
c6d5 cd 19 e4				call cin_wait 
c6d8 6f					ld l, a 
c6d9 26 00				ld h, 0 
c6db cd 3c 9b				call forth_push_numhl 
c6de					NEXTW 
c6de c3 e9 9e			jp macro_next 
c6e1				endm 
# End of macro NEXTW
c6e1			.ACCEPT: 
c6e1				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6e1 40				db WORD_SYS_CORE+44             
c6e2 3f c7			dw .EDIT            
c6e4 07				db 6 + 1 
c6e5 .. 00			db "ACCEPT",0              
c6ec				endm 
# End of macro CWHEAD
c6ec			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6ec					; TODO crashes on push 
c6ec					if DEBUG_FORTH_WORDS_KEY 
c6ec						DMARK "ACC" 
c6ec f5				push af  
c6ed 3a 01 c7			ld a, (.dmark)  
c6f0 32 6b ee			ld (debug_mark),a  
c6f3 3a 02 c7			ld a, (.dmark+1)  
c6f6 32 6c ee			ld (debug_mark+1),a  
c6f9 3a 03 c7			ld a, (.dmark+2)  
c6fc 32 6d ee			ld (debug_mark+2),a  
c6ff 18 03			jr .pastdmark  
c701 ..			.dmark: db "ACC"  
c704 f1			.pastdmark: pop af  
c705			endm  
# End of macro DMARK
c705						CALLMONITOR 
c705 cd 6f ee			call debug_vector  
c708				endm  
# End of macro CALLMONITOR
c708					endif 
c708 21 bf e4				ld hl, os_input 
c70b 3e 00				ld a, 0 
c70d 77					ld (hl),a 
c70e 3a 5e ea				ld a,(f_cursor_ptr) 
c711 16 64				ld d, 100 
c713 0e 00				ld c, 0 
c715 1e 28				ld e, 40 
c717 cd 09 8d				call input_str 
c71a					; TODO perhaps do a type check and wrap in quotes if not a number 
c71a 21 bf e4				ld hl, os_input 
c71d					if DEBUG_FORTH_WORDS 
c71d						DMARK "AC1" 
c71d f5				push af  
c71e 3a 32 c7			ld a, (.dmark)  
c721 32 6b ee			ld (debug_mark),a  
c724 3a 33 c7			ld a, (.dmark+1)  
c727 32 6c ee			ld (debug_mark+1),a  
c72a 3a 34 c7			ld a, (.dmark+2)  
c72d 32 6d ee			ld (debug_mark+2),a  
c730 18 03			jr .pastdmark  
c732 ..			.dmark: db "AC1"  
c735 f1			.pastdmark: pop af  
c736			endm  
# End of macro DMARK
c736						CALLMONITOR 
c736 cd 6f ee			call debug_vector  
c739				endm  
# End of macro CALLMONITOR
c739					endif 
c739 cd aa 9b				call forth_push_str 
c73c					NEXTW 
c73c c3 e9 9e			jp macro_next 
c73f				endm 
# End of macro NEXTW
c73f			 
c73f			.EDIT: 
c73f				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c73f 40				db WORD_SYS_CORE+44             
c740 e1 c7			dw .DEDIT            
c742 05				db 4 + 1 
c743 .. 00			db "EDIT",0              
c748				endm 
# End of macro CWHEAD
c748			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c748			 
c748					; TODO does not copy from stack 
c748					if DEBUG_FORTH_WORDS_KEY 
c748						DMARK "EDT" 
c748 f5				push af  
c749 3a 5d c7			ld a, (.dmark)  
c74c 32 6b ee			ld (debug_mark),a  
c74f 3a 5e c7			ld a, (.dmark+1)  
c752 32 6c ee			ld (debug_mark+1),a  
c755 3a 5f c7			ld a, (.dmark+2)  
c758 32 6d ee			ld (debug_mark+2),a  
c75b 18 03			jr .pastdmark  
c75d ..			.dmark: db "EDT"  
c760 f1			.pastdmark: pop af  
c761			endm  
# End of macro DMARK
c761						CALLMONITOR 
c761 cd 6f ee			call debug_vector  
c764				endm  
# End of macro CALLMONITOR
c764					endif 
c764			 
c764					;FORTH_DSP 
c764					FORTH_DSP_VALUEHL 
c764 cd 33 9d			call macro_dsp_valuehl 
c767				endm 
# End of macro FORTH_DSP_VALUEHL
c767			;		inc hl    ; TODO do type check 
c767			 
c767			;		call get_word_hl 
c767 e5					push hl 
c768					if DEBUG_FORTH_WORDS 
c768						DMARK "EDp" 
c768 f5				push af  
c769 3a 7d c7			ld a, (.dmark)  
c76c 32 6b ee			ld (debug_mark),a  
c76f 3a 7e c7			ld a, (.dmark+1)  
c772 32 6c ee			ld (debug_mark+1),a  
c775 3a 7f c7			ld a, (.dmark+2)  
c778 32 6d ee			ld (debug_mark+2),a  
c77b 18 03			jr .pastdmark  
c77d ..			.dmark: db "EDp"  
c780 f1			.pastdmark: pop af  
c781			endm  
# End of macro DMARK
c781						CALLMONITOR 
c781 cd 6f ee			call debug_vector  
c784				endm  
# End of macro CALLMONITOR
c784					endif 
c784				;	ld a, 0 
c784 cd 3a 91				call strlenz 
c787 23					inc hl 
c788			 
c788 06 00				ld b, 0 
c78a 4d					ld c, l 
c78b			 
c78b e1					pop hl 
c78c 11 bf e4				ld de, os_input 
c78f					if DEBUG_FORTH_WORDS_KEY 
c78f						DMARK "EDc" 
c78f f5				push af  
c790 3a a4 c7			ld a, (.dmark)  
c793 32 6b ee			ld (debug_mark),a  
c796 3a a5 c7			ld a, (.dmark+1)  
c799 32 6c ee			ld (debug_mark+1),a  
c79c 3a a6 c7			ld a, (.dmark+2)  
c79f 32 6d ee			ld (debug_mark+2),a  
c7a2 18 03			jr .pastdmark  
c7a4 ..			.dmark: db "EDc"  
c7a7 f1			.pastdmark: pop af  
c7a8			endm  
# End of macro DMARK
c7a8						CALLMONITOR 
c7a8 cd 6f ee			call debug_vector  
c7ab				endm  
# End of macro CALLMONITOR
c7ab					endif 
c7ab ed b0				ldir 
c7ad			 
c7ad			 
c7ad 21 bf e4				ld hl, os_input 
c7b0					;ld a, 0 
c7b0					;ld (hl),a 
c7b0 3a 5e ea				ld a,(f_cursor_ptr) 
c7b3 16 64				ld d, 100 
c7b5 0e 00				ld c, 0 
c7b7 1e 28				ld e, 40 
c7b9 cd 09 8d				call input_str 
c7bc					; TODO perhaps do a type check and wrap in quotes if not a number 
c7bc 21 bf e4				ld hl, os_input 
c7bf					if DEBUG_FORTH_WORDS 
c7bf						DMARK "ED1" 
c7bf f5				push af  
c7c0 3a d4 c7			ld a, (.dmark)  
c7c3 32 6b ee			ld (debug_mark),a  
c7c6 3a d5 c7			ld a, (.dmark+1)  
c7c9 32 6c ee			ld (debug_mark+1),a  
c7cc 3a d6 c7			ld a, (.dmark+2)  
c7cf 32 6d ee			ld (debug_mark+2),a  
c7d2 18 03			jr .pastdmark  
c7d4 ..			.dmark: db "ED1"  
c7d7 f1			.pastdmark: pop af  
c7d8			endm  
# End of macro DMARK
c7d8						CALLMONITOR 
c7d8 cd 6f ee			call debug_vector  
c7db				endm  
# End of macro CALLMONITOR
c7db					endif 
c7db cd aa 9b				call forth_push_str 
c7de					NEXTW 
c7de c3 e9 9e			jp macro_next 
c7e1				endm 
# End of macro NEXTW
c7e1			 
c7e1			.DEDIT: 
c7e1				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7e1 40				db WORD_SYS_CORE+44             
c7e2 43 c8			dw .ENDKEY            
c7e4 06				db 5 + 1 
c7e5 .. 00			db "DEDIT",0              
c7eb				endm 
# End of macro CWHEAD
c7eb			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7eb			 
c7eb					; TODO does not copy from stack 
c7eb					if DEBUG_FORTH_WORDS_KEY 
c7eb						DMARK "DED" 
c7eb f5				push af  
c7ec 3a 00 c8			ld a, (.dmark)  
c7ef 32 6b ee			ld (debug_mark),a  
c7f2 3a 01 c8			ld a, (.dmark+1)  
c7f5 32 6c ee			ld (debug_mark+1),a  
c7f8 3a 02 c8			ld a, (.dmark+2)  
c7fb 32 6d ee			ld (debug_mark+2),a  
c7fe 18 03			jr .pastdmark  
c800 ..			.dmark: db "DED"  
c803 f1			.pastdmark: pop af  
c804			endm  
# End of macro DMARK
c804						CALLMONITOR 
c804 cd 6f ee			call debug_vector  
c807				endm  
# End of macro CALLMONITOR
c807					endif 
c807			 
c807					;FORTH_DSP 
c807					FORTH_DSP_VALUEHL 
c807 cd 33 9d			call macro_dsp_valuehl 
c80a				endm 
# End of macro FORTH_DSP_VALUEHL
c80a			;		inc hl    ; TODO do type check 
c80a			 
c80a			;		call get_word_hl 
c80a e5					push hl 
c80b e5					push hl 
c80c					FORTH_DSP_POP 
c80c cd eb 9d			call macro_forth_dsp_pop 
c80f				endm 
# End of macro FORTH_DSP_POP
c80f e1					pop hl 
c810					if DEBUG_FORTH_WORDS 
c810						DMARK "EDp" 
c810 f5				push af  
c811 3a 25 c8			ld a, (.dmark)  
c814 32 6b ee			ld (debug_mark),a  
c817 3a 26 c8			ld a, (.dmark+1)  
c81a 32 6c ee			ld (debug_mark+1),a  
c81d 3a 27 c8			ld a, (.dmark+2)  
c820 32 6d ee			ld (debug_mark+2),a  
c823 18 03			jr .pastdmark  
c825 ..			.dmark: db "EDp"  
c828 f1			.pastdmark: pop af  
c829			endm  
# End of macro DMARK
c829						CALLMONITOR 
c829 cd 6f ee			call debug_vector  
c82c				endm  
# End of macro CALLMONITOR
c82c					endif 
c82c				;	ld a, 0 
c82c cd 3a 91				call strlenz 
c82f 23					inc hl 
c830			 
c830 06 00				ld b, 0 
c832 4d					ld c, l 
c833			 
c833 e1					pop hl 
c834			 
c834					;ld a, 0 
c834					;ld (hl),a 
c834 3a 5e ea				ld a,(f_cursor_ptr) 
c837 16 64				ld d, 100 
c839 0e 00				ld c, 0 
c83b 1e 28				ld e, 40 
c83d cd 09 8d				call input_str 
c840					; TODO perhaps do a type check and wrap in quotes if not a number 
c840					NEXTW 
c840 c3 e9 9e			jp macro_next 
c843				endm 
# End of macro NEXTW
c843			 
c843			 
c843			.ENDKEY: 
c843			; eof 
c843			 
# End of file forth_words_key.asm
c843			include "forth_words_const.asm" 
c843			 
c843			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c843			 
c843			 
c843			.SPITIME: 
c843				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c843 77				db WORD_SYS_CORE+99             
c844 58 c8			dw .VA            
c846 08				db 7 + 1 
c847 .. 00			db "SPITIME",0              
c84f				endm 
# End of macro CWHEAD
c84f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c84f			; 
c84f			; | If using BANK devices then leave as is. 
c84f			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c84f			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c84f			 
c84f 21 64 ea				ld hl, spi_clktime  
c852 cd 3c 9b				call forth_push_numhl 
c855			 
c855					NEXTW 
c855 c3 e9 9e			jp macro_next 
c858				endm 
# End of macro NEXTW
c858			 
c858			 
c858			.VA: 
c858				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c858 77				db WORD_SYS_CORE+99             
c859 68 c8			dw .SYMBOL            
c85b 03				db 2 + 1 
c85c .. 00			db "VA",0              
c85f				endm 
# End of macro CWHEAD
c85f			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c85f 21 28 ea				ld hl, cli_var_array 
c862 cd 3c 9b				call forth_push_numhl 
c865			 
c865					NEXTW 
c865 c3 e9 9e			jp macro_next 
c868				endm 
# End of macro NEXTW
c868			 
c868			.SYMBOL: 
c868				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c868 77				db WORD_SYS_CORE+99             
c869 72 c9			dw .ENDCONST            
c86b 07				db 6 + 1 
c86c .. 00			db "SYMBOL",0              
c873				endm 
# End of macro CWHEAD
c873			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c873			; | 
c873			; | The value is the number reference and the final address is pushed to stack 
c873			 
c873			; | dw sym_table 
c873			; | dw nmi_vector 
c873			; | dw cli_autodisplay 
c873			; | dw cli_data_sp 
c873			; | dw cli_data_stack 
c873			; | dw cli_loop_sp 
c873			; | dw cli_loop_stack 
c873			; | dw cli_var_array 
c873			; | dw cursor_col 
c873			; | dw cursor_ptr 
c873			; | ; 10 
c873			; | dw cursor_row 
c873			; | dw debug_mark 
c873			; | dw display_fb0 
c873			; | dw display_fb1 
c873			; | dw display_fb2 
c873			; | dw display_fb3 
c873			; | dw display_fb_active 
c873			; | dw execscratch 
c873			; | dw f_cursor_ptr 
c873			; | dw hardware_word 
c873			; | ;20 
c873			; | dw input_at_cursor 
c873			; | dw input_at_pos 
c873			; | dw input_cur_flash 
c873			; | dw input_cur_onoff 
c873			; | dw input_cursor 
c873			; | dw input_display_size 
c873			; | dw input_len 
c873			; | dw input_ptr 
c873			; | dw input_size 
c873			; | dw input_start 
c873			; | ; 30 
c873			; | dw input_str 
c873			; | dw input_under_cursor 
c873			; | dw os_cli_cmd 
c873			; | dw os_cur_ptr 
c873			; | dw os_current_i 
c873			; | dw os_input 
c873			; | dw os_last_cmd 
c873			; | dw os_last_new_uword 
c873			; | dw debug_vector 
c873			; | dw os_view_hl 
c873			; | ;40 
c873			; | dw os_word_scratch 
c873			; | dw portbctl 
c873			; | dw portbdata 
c873			; | dw spi_cartdev 
c873			; | dw spi_cartdev2 
c873			; | dw spi_clktime 
c873			; | dw spi_device 
c873			; | dw spi_device_id 
c873			; | dw spi_portbyte 
c873			; | dw stackstore 
c873			; | ; 50 
c873			; | if STORAGE_SE 
c873			; | dw storage_actl 
c873			; | dw storage_adata 
c873			; | else 
c873			; | dw 0 
c873			; | dw 0 
c873			; | endif 
c873			; | dw storage_append 
c873			; | if STORAGE_SE 
c873			; | dw storage_bctl 
c873			; | else 
c873			; | dw 0 
c873			; | endif 
c873			; | dw store_bank_active 
c873			; | dw store_filecache 
c873			; | dw store_longread 
c873			; | dw store_openaddr 
c873			; | dw store_openext 
c873			; | dw store_openmaxext 
c873			; | ; 60 
c873			; | dw store_page 
c873			; | dw store_readbuf 
c873			; | dw store_readcont 
c873			; | dw store_readptr 
c873			; | dw store_tmpext 
c873			; | dw store_tmpid 
c873			; | dw store_tmppageid 
c873			; | dw malloc 
c873			; | dw free 
c873			; | dw cin 
c873			; | ; 70 
c873			; | dw cin_wait 
c873			; | dw forth_push_numhl 
c873			; | dw forth_push_str 
c873			 
c873					if DEBUG_FORTH_WORDS_KEY 
c873						DMARK "SYM" 
c873 f5				push af  
c874 3a 88 c8			ld a, (.dmark)  
c877 32 6b ee			ld (debug_mark),a  
c87a 3a 89 c8			ld a, (.dmark+1)  
c87d 32 6c ee			ld (debug_mark+1),a  
c880 3a 8a c8			ld a, (.dmark+2)  
c883 32 6d ee			ld (debug_mark+2),a  
c886 18 03			jr .pastdmark  
c888 ..			.dmark: db "SYM"  
c88b f1			.pastdmark: pop af  
c88c			endm  
# End of macro DMARK
c88c						CALLMONITOR 
c88c cd 6f ee			call debug_vector  
c88f				endm  
# End of macro CALLMONITOR
c88f					endif 
c88f			 
c88f					FORTH_DSP_VALUEHL 
c88f cd 33 9d			call macro_dsp_valuehl 
c892				endm 
# End of macro FORTH_DSP_VALUEHL
c892			 
c892 7d					ld a, l     
c893			 
c893			 
c893					if DEBUG_FORTH_WORDS 
c893						DMARK "SY1" 
c893 f5				push af  
c894 3a a8 c8			ld a, (.dmark)  
c897 32 6b ee			ld (debug_mark),a  
c89a 3a a9 c8			ld a, (.dmark+1)  
c89d 32 6c ee			ld (debug_mark+1),a  
c8a0 3a aa c8			ld a, (.dmark+2)  
c8a3 32 6d ee			ld (debug_mark+2),a  
c8a6 18 03			jr .pastdmark  
c8a8 ..			.dmark: db "SY1"  
c8ab f1			.pastdmark: pop af  
c8ac			endm  
# End of macro DMARK
c8ac						CALLMONITOR 
c8ac cd 6f ee			call debug_vector  
c8af				endm  
# End of macro CALLMONITOR
c8af					endif 
c8af					 
c8af f5					push af	 
c8b0					FORTH_DSP_POP 
c8b0 cd eb 9d			call macro_forth_dsp_pop 
c8b3				endm 
# End of macro FORTH_DSP_POP
c8b3 f1					pop af 
c8b4			 
c8b4 cb 27				sla a  
c8b6				 
c8b6					 
c8b6					if DEBUG_FORTH_WORDS 
c8b6						DMARK "SY" 
c8b6 f5				push af  
c8b7 3a cb c8			ld a, (.dmark)  
c8ba 32 6b ee			ld (debug_mark),a  
c8bd 3a cc c8			ld a, (.dmark+1)  
c8c0 32 6c ee			ld (debug_mark+1),a  
c8c3 3a cd c8			ld a, (.dmark+2)  
c8c6 32 6d ee			ld (debug_mark+2),a  
c8c9 18 02			jr .pastdmark  
c8cb ..			.dmark: db "SY"  
c8cd f1			.pastdmark: pop af  
c8ce			endm  
# End of macro DMARK
c8ce						CALLMONITOR 
c8ce cd 6f ee			call debug_vector  
c8d1				endm  
# End of macro CALLMONITOR
c8d1					endif 
c8d1			 
c8d1 21 e0 c8				ld hl, sym_table 
c8d4 cd dc 8c				call addatohl 
c8d7 cd 6b 9e				call loadwordinhl 
c8da cd 3c 9b				call forth_push_numhl 
c8dd			 
c8dd			 
c8dd				       NEXTW 
c8dd c3 e9 9e			jp macro_next 
c8e0				endm 
# End of macro NEXTW
c8e0			 
c8e0			sym_table: 
c8e0			 
c8e0			; 0 
c8e0 e0 c8		dw sym_table 
c8e2 72 ee		dw nmi_vector 
c8e4 3c ea		dw cli_autodisplay 
c8e6 ee e9		dw cli_data_sp 
c8e8 28 e8		dw cli_data_stack 
c8ea f0 e9		dw cli_loop_sp 
c8ec 2a e9		dw cli_loop_stack 
c8ee 28 ea		dw cli_var_array 
c8f0 c5 eb		dw cursor_col 
c8f2 c3 eb		dw cursor_ptr 
c8f4			; 10 
c8f4 c4 eb		dw cursor_row 
c8f6 6b ee		dw debug_mark 
c8f8 b1 ed		dw display_fb0 
c8fa 10 ed		dw display_fb1 
c8fc ce eb		dw display_fb2 
c8fe 6f ec		dw display_fb3 
c900 cc eb		dw display_fb_active 
c902 c0 e3		dw execscratch 
c904 5e ea		dw f_cursor_ptr 
c906 75 ee		dw hardware_word 
c908			;20 
c908 62 ee		dw input_at_cursor 
c90a 64 ee		dw input_at_pos 
c90c 60 ee		dw input_cur_flash 
c90e 5f ee		dw input_cur_onoff 
c910 55 ee		dw input_cursor 
c912 65 ee		dw input_display_size 
c914 5a ee		dw input_len 
c916 69 ee		dw input_ptr 
c918 66 ee		dw input_size 
c91a 67 ee		dw input_start 
c91c			; 30 
c91c 09 8d		dw input_str 
c91e 63 ee		dw input_under_cursor 
c920 e8 e5		dw os_cli_cmd 
c922 e4 e5		dw os_cur_ptr 
c924 e6 e5		dw os_current_i 
c926 bf e4		dw os_input 
c928 e7 e6		dw os_last_cmd 
c92a be e5		dw os_last_new_uword 
c92c 6f ee		dw debug_vector 
c92e a3 e2		dw os_view_hl 
c930			;40 
c930 c6 e5		dw os_word_scratch 
c932 c3 00		dw portbctl 
c934 c1 00		dw portbdata 
c936 63 ea		dw spi_cartdev 
c938 62 ea		dw spi_cartdev2 
c93a 64 ea		dw spi_clktime 
c93c 60 ea		dw spi_device 
c93e 5f ea		dw spi_device_id 
c940 61 ea		dw spi_portbyte 
c942 a7 eb		dw stackstore 
c944			; 50 
c944			if STORAGE_SE 
c944			dw storage_actl 
c944			dw storage_adata 
c944			else 
c944 00 00		dw 0 
c946 00 00		dw 0 
c948			endif 
c948 69 88		dw storage_append 
c94a			if STORAGE_SE 
c94a			dw storage_bctl 
c94a			else 
c94a 00 00		dw 0 
c94c			endif 
c94c 93 eb		dw store_bank_active 
c94e 67 ea		dw store_filecache 
c950 75 ea		dw store_longread 
c952 6b ea		dw store_openaddr 
c954 6a ea		dw store_openext 
c956 69 ea		dw store_openmaxext 
c958			; 60 
c958 7a ea		dw store_page 
c95a 76 ea		dw store_readbuf 
c95c 6d ea		dw store_readcont 
c95e 78 ea		dw store_readptr 
c960 6d ea		dw store_tmpext 
c962 6e ea		dw store_tmpid 
c964 65 ea		dw store_tmppageid 
c966 a3 91		dw malloc 
c968 6d 92		dw free 
c96a 1f e4		dw cin 
c96c			; 70 
c96c 19 e4		dw cin_wait 
c96e 3c 9b		dw forth_push_numhl 
c970 aa 9b		dw forth_push_str 
c972			 
c972			 
c972			.ENDCONST: 
c972			 
c972			; eof 
c972			 
c972			 
# End of file forth_words_const.asm
c972			 
c972			if STORAGE_SE 
c972			   	include "forth_words_storage.asm" 
c972			endif 
c972				include "forth_words_device.asm" 
c972			; Device related words 
c972			 
c972			; | ## Device Words 
c972			 
c972			;if SOUND_ENABLE 
c972			;.NOTE: 
c972			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c972			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c972			;		if DEBUG_FORTH_WORDS_KEY 
c972			;			DMARK "NTE" 
c972			;			CALLMONITOR 
c972			;		endif 
c972			; 
c972			;	 
c972			; 
c972			;		NEXTW 
c972			;.AFTERSOUND: 
c972			;endif 
c972			 
c972			 
c972			USE_GPIO: equ 0 
c972			 
c972			if USE_GPIO 
c972			.GP1: 
c972				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c972			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c972					NEXTW 
c972			.GP2: 
c972				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c972			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c972			 
c972					NEXTW 
c972			 
c972			.GP3: 
c972				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c972			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c972			 
c972					NEXTW 
c972			 
c972			.GP4: 
c972				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c972			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c972			 
c972					NEXTW 
c972			.SIN: 
c972			 
c972			 
c972			endif 
c972			 
c972			 
c972				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c972 33				db WORD_SYS_CORE+31             
c973 a7 c9			dw .SOUT            
c975 03				db 2 + 1 
c976 .. 00			db "IN",0              
c979				endm 
# End of macro CWHEAD
c979			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c979					if DEBUG_FORTH_WORDS_KEY 
c979						DMARK "IN." 
c979 f5				push af  
c97a 3a 8e c9			ld a, (.dmark)  
c97d 32 6b ee			ld (debug_mark),a  
c980 3a 8f c9			ld a, (.dmark+1)  
c983 32 6c ee			ld (debug_mark+1),a  
c986 3a 90 c9			ld a, (.dmark+2)  
c989 32 6d ee			ld (debug_mark+2),a  
c98c 18 03			jr .pastdmark  
c98e ..			.dmark: db "IN."  
c991 f1			.pastdmark: pop af  
c992			endm  
# End of macro DMARK
c992						CALLMONITOR 
c992 cd 6f ee			call debug_vector  
c995				endm  
# End of macro CALLMONITOR
c995					endif 
c995					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c995 cd 33 9d			call macro_dsp_valuehl 
c998				endm 
# End of macro FORTH_DSP_VALUEHL
c998			 
c998 e5					push hl 
c999			 
c999					; destroy value TOS 
c999			 
c999					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c999 cd eb 9d			call macro_forth_dsp_pop 
c99c				endm 
# End of macro FORTH_DSP_POP
c99c			 
c99c					; one value on hl get other one back 
c99c			 
c99c c1					pop bc 
c99d			 
c99d					; do the sub 
c99d			;		ex de, hl 
c99d			 
c99d ed 68				in l,(c) 
c99f			 
c99f					; save it 
c99f			 
c99f 26 00				ld h,0 
c9a1			 
c9a1					; TODO push value back onto stack for another op etc 
c9a1			 
c9a1 cd 3c 9b				call forth_push_numhl 
c9a4					NEXTW 
c9a4 c3 e9 9e			jp macro_next 
c9a7				endm 
# End of macro NEXTW
c9a7			.SOUT: 
c9a7				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c9a7 34				db WORD_SYS_CORE+32             
c9a8 fa c9			dw .SPIO            
c9aa 04				db 3 + 1 
c9ab .. 00			db "OUT",0              
c9af				endm 
# End of macro CWHEAD
c9af			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c9af					if DEBUG_FORTH_WORDS_KEY 
c9af						DMARK "OUT" 
c9af f5				push af  
c9b0 3a c4 c9			ld a, (.dmark)  
c9b3 32 6b ee			ld (debug_mark),a  
c9b6 3a c5 c9			ld a, (.dmark+1)  
c9b9 32 6c ee			ld (debug_mark+1),a  
c9bc 3a c6 c9			ld a, (.dmark+2)  
c9bf 32 6d ee			ld (debug_mark+2),a  
c9c2 18 03			jr .pastdmark  
c9c4 ..			.dmark: db "OUT"  
c9c7 f1			.pastdmark: pop af  
c9c8			endm  
# End of macro DMARK
c9c8						CALLMONITOR 
c9c8 cd 6f ee			call debug_vector  
c9cb				endm  
# End of macro CALLMONITOR
c9cb					endif 
c9cb			 
c9cb					; get port 
c9cb			 
c9cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9cb cd 33 9d			call macro_dsp_valuehl 
c9ce				endm 
# End of macro FORTH_DSP_VALUEHL
c9ce			 
c9ce e5					push hl 
c9cf			 
c9cf					; destroy value TOS 
c9cf			 
c9cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9cf cd eb 9d			call macro_forth_dsp_pop 
c9d2				endm 
# End of macro FORTH_DSP_POP
c9d2			 
c9d2					; get byte to send 
c9d2			 
c9d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d2 cd 33 9d			call macro_dsp_valuehl 
c9d5				endm 
# End of macro FORTH_DSP_VALUEHL
c9d5			 
c9d5			;		push hl 
c9d5			 
c9d5					; destroy value TOS 
c9d5			 
c9d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9d5 cd eb 9d			call macro_forth_dsp_pop 
c9d8				endm 
# End of macro FORTH_DSP_POP
c9d8			 
c9d8					; one value on hl get other one back 
c9d8			 
c9d8			;		pop hl 
c9d8			 
c9d8 c1					pop bc 
c9d9			 
c9d9					if DEBUG_FORTH_WORDS 
c9d9						DMARK "OUT" 
c9d9 f5				push af  
c9da 3a ee c9			ld a, (.dmark)  
c9dd 32 6b ee			ld (debug_mark),a  
c9e0 3a ef c9			ld a, (.dmark+1)  
c9e3 32 6c ee			ld (debug_mark+1),a  
c9e6 3a f0 c9			ld a, (.dmark+2)  
c9e9 32 6d ee			ld (debug_mark+2),a  
c9ec 18 03			jr .pastdmark  
c9ee ..			.dmark: db "OUT"  
c9f1 f1			.pastdmark: pop af  
c9f2			endm  
# End of macro DMARK
c9f2						CALLMONITOR 
c9f2 cd 6f ee			call debug_vector  
c9f5				endm  
# End of macro CALLMONITOR
c9f5					endif 
c9f5			 
c9f5 ed 69				out (c), l 
c9f7			 
c9f7					NEXTW 
c9f7 c3 e9 9e			jp macro_next 
c9fa				endm 
# End of macro NEXTW
c9fa			 
c9fa			 
c9fa			.SPIO: 
c9fa			 
c9fa			if STORAGE_SE 
c9fa				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9fa			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9fa			 
c9fa					call spi_ce_low 
c9fa			    NEXTW 
c9fa			 
c9fa			.SPICEH: 
c9fa				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9fa			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9fa			 
c9fa					call spi_ce_high 
c9fa			    NEXTW 
c9fa			 
c9fa			 
c9fa			.SPIOb: 
c9fa			 
c9fa				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9fa			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9fa			 
c9fa					if DEBUG_FORTH_WORDS_KEY 
c9fa						DMARK "SPo" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa					; get port 
c9fa			 
c9fa			 
c9fa					; get byte to send 
c9fa			 
c9fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9fa			 
c9fa			;		push hl    ; u1  
c9fa			 
c9fa					; destroy value TOS 
c9fa			 
c9fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9fa			 
c9fa					; one value on hl get other one back 
c9fa			 
c9fa			;		pop hl   ; u2 - addr 
c9fa			 
c9fa					; TODO Send SPI byte 
c9fa			 
c9fa			;		push hl 
c9fa			;		call spi_ce_low 
c9fa			;		pop hl 
c9fa					ld a, l 
c9fa					call spi_send_byte 
c9fa			;		call spi_ce_high 
c9fa			 
c9fa					NEXTW 
c9fa			 
c9fa			.SPII: 
c9fa				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9fa			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9fa					if DEBUG_FORTH_WORDS_KEY 
c9fa						DMARK "SPi" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa			 
c9fa					; TODO Get SPI byte 
c9fa			 
c9fa					call spi_read_byte 
c9fa			 
c9fa					if DEBUG_FORTH_WORDS 
c9fa						DMARK "Si2" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa					ld h, 0 
c9fa					ld l, a 
c9fa					if DEBUG_FORTH_WORDS 
c9fa						DMARK "Si3" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa					call forth_push_numhl 
c9fa			 
c9fa					NEXTW 
c9fa			 
c9fa			 
c9fa			 
c9fa			.SESEL: 
c9fa				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9fa			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9fa					if DEBUG_FORTH_WORDS_KEY 
c9fa						DMARK "BNK" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa			 
c9fa					ld a, 255 
c9fa					ld (spi_cartdev), a 
c9fa			 
c9fa					; get bank 
c9fa			 
c9fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9fa			 
c9fa			;		push hl 
c9fa			 
c9fa					; destroy value TOS 
c9fa			 
c9fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9fa			 
c9fa					; one value on hl get other one back 
c9fa			 
c9fa			;		pop hl 
c9fa			 
c9fa			 
c9fa					ld c, SPI_CE_HIGH 
c9fa					ld b, '0'    ; human readable bank number 
c9fa			 
c9fa					ld a, l 
c9fa			 
c9fa					if DEBUG_FORTH_WORDS 
c9fa						DMARK "BNK" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa			 
c9fa					; active low 
c9fa			 
c9fa					cp 0 
c9fa					jr z, .bset 
c9fa					cp 1 
c9fa					jr nz, .b2 
c9fa					res 0, c 
c9fa					ld b, '1'    ; human readable bank number 
c9fa			.b2:		cp 2 
c9fa					jr nz, .b3 
c9fa					res 1, c 
c9fa					ld b, '2'    ; human readable bank number 
c9fa			.b3:		cp 3 
c9fa					jr nz, .b4 
c9fa					res 2, c 
c9fa					ld b, '3'    ; human readable bank number 
c9fa			.b4:		cp 4 
c9fa					jr nz, .b5 
c9fa					res 3, c 
c9fa					ld b, '4'    ; human readable bank number 
c9fa			.b5:		cp 5 
c9fa					jr nz, .bset 
c9fa					res 4, c 
c9fa					ld b, '5'    ; human readable bank number 
c9fa			 
c9fa			.bset: 
c9fa					ld a, c 
c9fa					ld (spi_device),a 
c9fa					ld a, b 
c9fa					ld (spi_device_id),a 
c9fa					if DEBUG_FORTH_WORDS 
c9fa						DMARK "BN2" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa			 
c9fa					; set default SPI clk pulse time as disabled for BANK use 
c9fa			 
c9fa					ld a, 0 
c9fa					ld (spi_clktime), a 
c9fa			 
c9fa					NEXTW 
c9fa			 
c9fa			.CARTDEV: 
c9fa				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9fa			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9fa					if DEBUG_FORTH_WORDS_KEY 
c9fa						DMARK "CDV" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa			 
c9fa					; disable se storage bank selection 
c9fa			 
c9fa					ld a, SPI_CE_HIGH		; ce high 
c9fa					ld (spi_device), a 
c9fa			 
c9fa					; get bank 
c9fa			 
c9fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9fa			 
c9fa			;		push hl 
c9fa			 
c9fa					; destroy value TOS 
c9fa			 
c9fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9fa			 
c9fa					; one value on hl get other one back 
c9fa			 
c9fa			;		pop hl 
c9fa			 
c9fa					; active low 
c9fa			 
c9fa					ld c, 255 
c9fa			 
c9fa					ld a, l 
c9fa					if DEBUG_FORTH_WORDS 
c9fa						DMARK "CDV" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa					cp 0 
c9fa					jr z, .cset 
c9fa					cp 1 
c9fa					jr nz, .c2 
c9fa					res 0, c 
c9fa			.c2:		cp 2 
c9fa					jr nz, .c3 
c9fa					res 1, c 
c9fa			.c3:		cp 3 
c9fa					jr nz, .c4 
c9fa					res 2, c 
c9fa			.c4:		cp 4 
c9fa					jr nz, .c5 
c9fa					res 3, c 
c9fa			.c5:		cp 5 
c9fa					jr nz, .c6 
c9fa					res 4, c 
c9fa			.c6:		cp 6 
c9fa					jr nz, .c7 
c9fa					res 5, c 
c9fa			.c7:		cp 7 
c9fa					jr nz, .c8 
c9fa					res 6, c 
c9fa			.c8:		cp 8 
c9fa					jr nz, .cset 
c9fa					res 7, c 
c9fa			.cset:		ld a, c 
c9fa					ld (spi_cartdev),a 
c9fa			 
c9fa					if DEBUG_FORTH_WORDS 
c9fa						DMARK "CD2" 
c9fa						CALLMONITOR 
c9fa					endif 
c9fa			 
c9fa					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9fa			 
c9fa					ld a, $0a 
c9fa					ld (spi_clktime), a 
c9fa					NEXTW 
c9fa			endif 
c9fa			 
c9fa			.ENDDEVICE: 
c9fa			; eof 
c9fa			 
# End of file forth_words_device.asm
c9fa			 
c9fa			; var handler 
c9fa			 
c9fa			 
c9fa			.VARS: 
c9fa				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9fa 77				db WORD_SYS_CORE+99             
c9fb ab ca			dw .V0            
c9fd 04				db 3 + 1 
c9fe .. 00			db "VAR",0              
ca02				endm 
# End of macro CWHEAD
ca02			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
ca02			;| 
ca02			;| The variable name should consist of a single letter. e.g. "a" 
ca02			;! If a full string is passed then only the first char is looked at 
ca02			;| Any other char could exceed bounds checks!  
ca02			 
ca02					if DEBUG_FORTH_WORDS_KEY 
ca02						DMARK "VAR" 
ca02 f5				push af  
ca03 3a 17 ca			ld a, (.dmark)  
ca06 32 6b ee			ld (debug_mark),a  
ca09 3a 18 ca			ld a, (.dmark+1)  
ca0c 32 6c ee			ld (debug_mark+1),a  
ca0f 3a 19 ca			ld a, (.dmark+2)  
ca12 32 6d ee			ld (debug_mark+2),a  
ca15 18 03			jr .pastdmark  
ca17 ..			.dmark: db "VAR"  
ca1a f1			.pastdmark: pop af  
ca1b			endm  
# End of macro DMARK
ca1b						CALLMONITOR 
ca1b cd 6f ee			call debug_vector  
ca1e				endm  
# End of macro CALLMONITOR
ca1e					endif 
ca1e			 
ca1e					FORTH_DSP_VALUEHL 
ca1e cd 33 9d			call macro_dsp_valuehl 
ca21				endm 
# End of macro FORTH_DSP_VALUEHL
ca21			 
ca21 7e					ld a, (hl)    ; get first char on of the string 
ca22			 
ca22			 
ca22					if DEBUG_FORTH_WORDS 
ca22						DMARK "VR1" 
ca22 f5				push af  
ca23 3a 37 ca			ld a, (.dmark)  
ca26 32 6b ee			ld (debug_mark),a  
ca29 3a 38 ca			ld a, (.dmark+1)  
ca2c 32 6c ee			ld (debug_mark+1),a  
ca2f 3a 39 ca			ld a, (.dmark+2)  
ca32 32 6d ee			ld (debug_mark+2),a  
ca35 18 03			jr .pastdmark  
ca37 ..			.dmark: db "VR1"  
ca3a f1			.pastdmark: pop af  
ca3b			endm  
# End of macro DMARK
ca3b						CALLMONITOR 
ca3b cd 6f ee			call debug_vector  
ca3e				endm  
# End of macro CALLMONITOR
ca3e					endif 
ca3e					 
ca3e f5					push af	 
ca3f					FORTH_DSP_POP 
ca3f cd eb 9d			call macro_forth_dsp_pop 
ca42				endm 
# End of macro FORTH_DSP_POP
ca42 f1					pop af 
ca43			 
ca43					; convert to upper 
ca43			 
ca43 cd 49 90				call to_upper 
ca46					if DEBUG_FORTH_WORDS 
ca46						DMARK "Vaa" 
ca46 f5				push af  
ca47 3a 5b ca			ld a, (.dmark)  
ca4a 32 6b ee			ld (debug_mark),a  
ca4d 3a 5c ca			ld a, (.dmark+1)  
ca50 32 6c ee			ld (debug_mark+1),a  
ca53 3a 5d ca			ld a, (.dmark+2)  
ca56 32 6d ee			ld (debug_mark+2),a  
ca59 18 03			jr .pastdmark  
ca5b ..			.dmark: db "Vaa"  
ca5e f1			.pastdmark: pop af  
ca5f			endm  
# End of macro DMARK
ca5f						CALLMONITOR 
ca5f cd 6f ee			call debug_vector  
ca62				endm  
# End of macro CALLMONITOR
ca62					endif 
ca62 06 41				ld b, 'A' 
ca64 90					sub b			; set offset 
ca65					if DEBUG_FORTH_WORDS 
ca65						DMARK "Vbb" 
ca65 f5				push af  
ca66 3a 7a ca			ld a, (.dmark)  
ca69 32 6b ee			ld (debug_mark),a  
ca6c 3a 7b ca			ld a, (.dmark+1)  
ca6f 32 6c ee			ld (debug_mark+1),a  
ca72 3a 7c ca			ld a, (.dmark+2)  
ca75 32 6d ee			ld (debug_mark+2),a  
ca78 18 03			jr .pastdmark  
ca7a ..			.dmark: db "Vbb"  
ca7d f1			.pastdmark: pop af  
ca7e			endm  
# End of macro DMARK
ca7e						CALLMONITOR 
ca7e cd 6f ee			call debug_vector  
ca81				endm  
# End of macro CALLMONITOR
ca81					endif 
ca81 cb 27				sla a  
ca83				 
ca83					 
ca83					if DEBUG_FORTH_WORDS 
ca83						DMARK "VR2" 
ca83 f5				push af  
ca84 3a 98 ca			ld a, (.dmark)  
ca87 32 6b ee			ld (debug_mark),a  
ca8a 3a 99 ca			ld a, (.dmark+1)  
ca8d 32 6c ee			ld (debug_mark+1),a  
ca90 3a 9a ca			ld a, (.dmark+2)  
ca93 32 6d ee			ld (debug_mark+2),a  
ca96 18 03			jr .pastdmark  
ca98 ..			.dmark: db "VR2"  
ca9b f1			.pastdmark: pop af  
ca9c			endm  
# End of macro DMARK
ca9c						CALLMONITOR 
ca9c cd 6f ee			call debug_vector  
ca9f				endm  
# End of macro CALLMONITOR
ca9f					endif 
ca9f			 
ca9f 21 f4 e9				ld hl, cli_var_array2 
caa2 cd dc 8c				call addatohl 
caa5 cd 3c 9b				call forth_push_numhl 
caa8			 
caa8			 
caa8				       NEXTW 
caa8 c3 e9 9e			jp macro_next 
caab				endm 
# End of macro NEXTW
caab			.V0: 
caab				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
caab 78				db WORD_SYS_CORE+100             
caac c3 ca			dw .V0Q            
caae 04				db 3 + 1 
caaf .. 00			db "V0!",0              
cab3				endm 
# End of macro CWHEAD
cab3			;| V0! ( u1 -- )  Store value to v0  | DONE 
cab3			 
cab3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cab3 cd 33 9d			call macro_dsp_valuehl 
cab6				endm 
# End of macro FORTH_DSP_VALUEHL
cab6			 
cab6 11 28 ea				ld de, cli_var_array 
cab9			 
cab9 eb					ex de, hl 
caba 73					ld (hl), e 
cabb 23					inc hl 
cabc 72					ld (hl), d 
cabd			 
cabd					; destroy value TOS 
cabd			 
cabd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cabd cd eb 9d			call macro_forth_dsp_pop 
cac0				endm 
# End of macro FORTH_DSP_POP
cac0			 
cac0				       NEXTW 
cac0 c3 e9 9e			jp macro_next 
cac3				endm 
# End of macro NEXTW
cac3			.V0Q: 
cac3				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cac3 79				db WORD_SYS_CORE+101             
cac4 d4 ca			dw .V1S            
cac6 04				db 3 + 1 
cac7 .. 00			db "V0@",0              
cacb				endm 
# End of macro CWHEAD
cacb			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cacb 2a 28 ea				ld hl, (cli_var_array) 
cace cd 3c 9b				call forth_push_numhl 
cad1			 
cad1				       NEXTW 
cad1 c3 e9 9e			jp macro_next 
cad4				endm 
# End of macro NEXTW
cad4			.V1S: 
cad4				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cad4 7a				db WORD_SYS_CORE+102             
cad5 ec ca			dw .V1Q            
cad7 04				db 3 + 1 
cad8 .. 00			db "V1!",0              
cadc				endm 
# End of macro CWHEAD
cadc			;| V1! ( u1 -- )  Store value to v1 | DONE 
cadc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cadc cd 33 9d			call macro_dsp_valuehl 
cadf				endm 
# End of macro FORTH_DSP_VALUEHL
cadf			 
cadf 11 2a ea				ld de, cli_var_array+2 
cae2				 
cae2 eb					ex de, hl 
cae3 73					ld (hl), e 
cae4 23					inc hl 
cae5 72					ld (hl), d 
cae6			 
cae6					; destroy value TOS 
cae6			 
cae6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cae6 cd eb 9d			call macro_forth_dsp_pop 
cae9				endm 
# End of macro FORTH_DSP_POP
cae9				       NEXTW 
cae9 c3 e9 9e			jp macro_next 
caec				endm 
# End of macro NEXTW
caec			.V1Q: 
caec				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
caec 7b				db WORD_SYS_CORE+103             
caed fd ca			dw .V2S            
caef 04				db 3 + 1 
caf0 .. 00			db "V1@",0              
caf4				endm 
# End of macro CWHEAD
caf4			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
caf4 2a 2a ea				ld hl, (cli_var_array+2) 
caf7 cd 3c 9b				call forth_push_numhl 
cafa				       NEXTW 
cafa c3 e9 9e			jp macro_next 
cafd				endm 
# End of macro NEXTW
cafd			.V2S: 
cafd				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cafd 7c				db WORD_SYS_CORE+104             
cafe 15 cb			dw .V2Q            
cb00 04				db 3 + 1 
cb01 .. 00			db "V2!",0              
cb05				endm 
# End of macro CWHEAD
cb05			;| V2! ( u1 -- )  Store value to v2 | DONE 
cb05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb05 cd 33 9d			call macro_dsp_valuehl 
cb08				endm 
# End of macro FORTH_DSP_VALUEHL
cb08			 
cb08 11 2c ea				ld de, cli_var_array+4 
cb0b				 
cb0b eb					ex de, hl 
cb0c 73					ld (hl), e 
cb0d 23					inc hl 
cb0e 72					ld (hl), d 
cb0f			 
cb0f					; destroy value TOS 
cb0f			 
cb0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb0f cd eb 9d			call macro_forth_dsp_pop 
cb12				endm 
# End of macro FORTH_DSP_POP
cb12				       NEXTW 
cb12 c3 e9 9e			jp macro_next 
cb15				endm 
# End of macro NEXTW
cb15			.V2Q: 
cb15				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cb15 7d				db WORD_SYS_CORE+105             
cb16 26 cb			dw .V3S            
cb18 04				db 3 + 1 
cb19 .. 00			db "V2@",0              
cb1d				endm 
# End of macro CWHEAD
cb1d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb1d 2a 2c ea				ld hl, (cli_var_array+4) 
cb20 cd 3c 9b				call forth_push_numhl 
cb23				       NEXTW 
cb23 c3 e9 9e			jp macro_next 
cb26				endm 
# End of macro NEXTW
cb26			.V3S: 
cb26				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb26 7c				db WORD_SYS_CORE+104             
cb27 3e cb			dw .V3Q            
cb29 04				db 3 + 1 
cb2a .. 00			db "V3!",0              
cb2e				endm 
# End of macro CWHEAD
cb2e			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb2e cd 33 9d			call macro_dsp_valuehl 
cb31				endm 
# End of macro FORTH_DSP_VALUEHL
cb31			 
cb31 11 2e ea				ld de, cli_var_array+6 
cb34				 
cb34 eb					ex de, hl 
cb35 73					ld (hl), e 
cb36 23					inc hl 
cb37 72					ld (hl), d 
cb38			 
cb38					; destroy value TOS 
cb38			 
cb38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb38 cd eb 9d			call macro_forth_dsp_pop 
cb3b				endm 
# End of macro FORTH_DSP_POP
cb3b				       NEXTW 
cb3b c3 e9 9e			jp macro_next 
cb3e				endm 
# End of macro NEXTW
cb3e			.V3Q: 
cb3e				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb3e 7d				db WORD_SYS_CORE+105             
cb3f 4f cb			dw .END            
cb41 04				db 3 + 1 
cb42 .. 00			db "V3@",0              
cb46				endm 
# End of macro CWHEAD
cb46			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb46 2a 2e ea				ld hl, (cli_var_array+6) 
cb49 cd 3c 9b				call forth_push_numhl 
cb4c				       NEXTW 
cb4c c3 e9 9e			jp macro_next 
cb4f				endm 
# End of macro NEXTW
cb4f			 
cb4f			 
cb4f			 
cb4f			 
cb4f			 
cb4f			; end of dict marker 
cb4f			 
cb4f 00			.END:    db WORD_SYS_END 
cb50 00 00			dw 0 
cb52 00				db 0 
cb53			 
cb53			; use to jp here for user dict words to save on macro expansion  
cb53			 
cb53			user_dict_next: 
cb53				NEXTW 
cb53 c3 e9 9e			jp macro_next 
cb56				endm 
# End of macro NEXTW
cb56			 
cb56			 
cb56			user_exec: 
cb56				;    ld hl, <word code> 
cb56				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb56				;    call forthexec 
cb56				;    jp user_dict_next   (NEXT) 
cb56			        ;    <word code bytes> 
cb56 eb				ex de, hl 
cb57 2a c2 e5			ld hl,(os_tok_ptr) 
cb5a				 
cb5a				FORTH_RSP_NEXT 
cb5a cd e3 9a			call macro_forth_rsp_next 
cb5d				endm 
# End of macro FORTH_RSP_NEXT
cb5d			 
cb5d			if DEBUG_FORTH_UWORD 
cb5d						DMARK "UEX" 
cb5d f5				push af  
cb5e 3a 72 cb			ld a, (.dmark)  
cb61 32 6b ee			ld (debug_mark),a  
cb64 3a 73 cb			ld a, (.dmark+1)  
cb67 32 6c ee			ld (debug_mark+1),a  
cb6a 3a 74 cb			ld a, (.dmark+2)  
cb6d 32 6d ee			ld (debug_mark+2),a  
cb70 18 03			jr .pastdmark  
cb72 ..			.dmark: db "UEX"  
cb75 f1			.pastdmark: pop af  
cb76			endm  
# End of macro DMARK
cb76				CALLMONITOR 
cb76 cd 6f ee			call debug_vector  
cb79				endm  
# End of macro CALLMONITOR
cb79			endif 
cb79			 
cb79			 
cb79			 
cb79 eb				ex de, hl 
cb7a 22 c2 e5			ld (os_tok_ptr), hl 
cb7d				 
cb7d				; Don't use next - Skips the first word in uword. 
cb7d			 
cb7d c3 7a 9f			jp exec1 
cb80			;	NEXT 
cb80			 
cb80			 
cb80			; eof 
# End of file forth_wordsv4.asm
cb80			endif 
cb80			;;;;;;;;;;;;;; Debug code 
cb80			 
cb80			 
cb80			;if DEBUG_FORTH_PARSE 
cb80 .. 00		.nowordfound: db "No match",0 
cb89 .. 00		.compword:	db "Comparing word ",0 
cb99 .. 00		.nextwordat:	db "Next word at",0 
cba6 .. 00		.charmatch:	db "Char match",0 
cbb1			;endif 
cbb1			if DEBUG_FORTH_JP 
cbb1			.foundword:	db "Word match. Exec..",0 
cbb1			endif 
cbb1			;if DEBUG_FORTH_PUSH 
cbb1 .. 00		.enddict:	db "Dict end. Push.",0 
cbc1 .. 00		.push_str:	db "Pushing string",0 
cbd0 .. 00		.push_num:	db "Pushing number",0 
cbdf .. 00		.data_sp:	db "SP:",0 
cbe3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbf5 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cc07 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cc19			;endif 
cc19			;if DEBUG_FORTH_MALLOC 
cc19 .. 00		.push_malloc:	db "Malloc address",0 
cc28			;endif 
cc28			 
cc28			 
cc28			 
cc28			; display malloc address and current data stack pointer  
cc28			 
cc28			malloc_error: 
cc28 d5				push de 
cc29 f5				push af 
cc2a e5				push hl 
cc2b cd af 8a			call clear_display 
cc2e 11 4e cc			ld de, .mallocerr 
cc31 3e 00			ld a,0 
cc33			;	ld de,os_word_scratch 
cc33 cd c2 8a			call str_at_display 
cc36 3e 11			ld a, display_row_1+17 
cc38 11 6b ee			ld de, debug_mark 
cc3b cd c2 8a			call str_at_display 
cc3e cd d2 8a			call update_display 
cc41				;call break_point_state 
cc41 cd 19 e4			call cin_wait 
cc44			 
cc44			;	ld a, ' ' 
cc44			;	ld (os_view_disable), a 
cc44 cd d2 94			call bp_on 
cc47 e1				pop hl 
cc48 f1				pop af 
cc49 d1				pop de	 
cc4a				CALLMONITOR 
cc4a cd 6f ee			call debug_vector  
cc4d				endm  
# End of macro CALLMONITOR
cc4d c9				ret 
cc4e			 
cc4e .. 00		.mallocerr: 	db "Malloc Error",0 
cc5b			;if DEBUG_FORTH_PUSH 
cc5b			display_data_sp: 
cc5b f5				push af 
cc5c			 
cc5c				; see if disabled 
cc5c			 
cc5c			 
cc5c 3a 6f ee			ld a, (debug_vector) 
cc5f fe c9			cp $C9  ; RET 
cc61				;ld a, (os_view_disable) 
cc61				;cp '*' 
cc61 28 67			jr z, .skipdsp 
cc63			 
cc63 e5				push hl 
cc64 e5				push hl 
cc65 e5			push hl 
cc66 cd af 8a			call clear_display 
cc69 e1			pop hl 
cc6a 7c				ld a,h 
cc6b 21 c6 e5			ld hl, os_word_scratch 
cc6e cd dd 8f			call hexout 
cc71 e1				pop hl 
cc72 7d				ld a,l 
cc73 21 c8 e5			ld hl, os_word_scratch+2 
cc76 cd dd 8f			call hexout 
cc79 21 ca e5			ld hl, os_word_scratch+4 
cc7c 3e 00			ld a,0 
cc7e 77				ld (hl),a 
cc7f 11 c6 e5			ld de,os_word_scratch 
cc82 3e 28				ld a, display_row_2 
cc84 cd c2 8a				call str_at_display 
cc87 11 e3 cb			ld de, .wordinhl 
cc8a 3e 00			ld a, display_row_1 
cc8c			 
cc8c cd c2 8a				call str_at_display 
cc8f 11 6b ee			ld de, debug_mark 
cc92 3e 11			ld a, display_row_1+17 
cc94			 
cc94 cd c2 8a				call str_at_display 
cc97			 
cc97				; display current data stack pointer 
cc97 11 df cb			ld de,.data_sp 
cc9a 3e 30				ld a, display_row_2 + 8 
cc9c cd c2 8a				call str_at_display 
cc9f			 
cc9f 2a ee e9			ld hl,(cli_data_sp) 
cca2 e5				push hl 
cca3 7c				ld a,h 
cca4 21 c6 e5			ld hl, os_word_scratch 
cca7 cd dd 8f			call hexout 
ccaa e1				pop hl 
ccab 7d				ld a,l 
ccac 21 c8 e5			ld hl, os_word_scratch+2 
ccaf cd dd 8f			call hexout 
ccb2 21 ca e5			ld hl, os_word_scratch+4 
ccb5 3e 00			ld a,0 
ccb7 77				ld (hl),a 
ccb8 11 c6 e5			ld de,os_word_scratch 
ccbb 3e 33				ld a, display_row_2 + 11 
ccbd cd c2 8a				call str_at_display 
ccc0			 
ccc0			 
ccc0 cd d2 8a			call update_display 
ccc3 cd f2 89			call delay1s 
ccc6 cd f2 89			call delay1s 
ccc9 e1				pop hl 
ccca			.skipdsp: 
ccca f1				pop af 
cccb c9				ret 
cccc			 
cccc			display_data_malloc: 
cccc			 
cccc f5				push af 
cccd e5				push hl 
ccce e5				push hl 
cccf e5			push hl 
ccd0 cd af 8a			call clear_display 
ccd3 e1			pop hl 
ccd4 7c				ld a,h 
ccd5 21 c6 e5			ld hl, os_word_scratch 
ccd8 cd dd 8f			call hexout 
ccdb e1				pop hl 
ccdc 7d				ld a,l 
ccdd 21 c8 e5			ld hl, os_word_scratch+2 
cce0 cd dd 8f			call hexout 
cce3 21 ca e5			ld hl, os_word_scratch+4 
cce6 3e 00			ld a,0 
cce8 77				ld (hl),a 
cce9 11 c6 e5			ld de,os_word_scratch 
ccec 3e 28				ld a, display_row_2 
ccee cd c2 8a				call str_at_display 
ccf1 11 19 cc			ld de, .push_malloc 
ccf4 3e 00			ld a, display_row_1 
ccf6			 
ccf6 cd c2 8a				call str_at_display 
ccf9			 
ccf9				; display current data stack pointer 
ccf9 11 df cb			ld de,.data_sp 
ccfc 3e 30				ld a, display_row_2 + 8 
ccfe cd c2 8a				call str_at_display 
cd01			 
cd01 2a ee e9			ld hl,(cli_data_sp) 
cd04 e5				push hl 
cd05 7c				ld a,h 
cd06 21 c6 e5			ld hl, os_word_scratch 
cd09 cd dd 8f			call hexout 
cd0c e1				pop hl 
cd0d 7d				ld a,l 
cd0e 21 c8 e5			ld hl, os_word_scratch+2 
cd11 cd dd 8f			call hexout 
cd14 21 ca e5			ld hl, os_word_scratch+4 
cd17 3e 00			ld a,0 
cd19 77				ld (hl),a 
cd1a 11 c6 e5			ld de,os_word_scratch 
cd1d 3e 33				ld a, display_row_2 + 11 
cd1f cd c2 8a				call str_at_display 
cd22			 
cd22 cd d2 8a			call update_display 
cd25 cd f2 89			call delay1s 
cd28 cd f2 89			call delay1s 
cd2b e1				pop hl 
cd2c f1				pop af 
cd2d c9				ret 
cd2e			;endif 
cd2e			 
cd2e			include "forth_autostart.asm" 
cd2e			; list of commands to perform at system start up 
cd2e			 
cd2e			startcmds: 
cd2e			;	dw test11 
cd2e			;	dw test12 
cd2e			;	dw test13 
cd2e			;	dw test14 
cd2e			;	dw test15 
cd2e			;	dw test16 
cd2e			;	dw test17 
cd2e			;	dw ifthtest1 
cd2e			;	dw ifthtest2 
cd2e			;	dw ifthtest3 
cd2e			;	dw mmtest1 
cd2e			;	dw mmtest2 
cd2e			;	dw mmtest3 
cd2e			;	dw mmtest4 
cd2e			;	dw mmtest5 
cd2e			;	dw mmtest6 
cd2e			;	dw iftest1 
cd2e			;	dw iftest2 
cd2e			;	dw iftest3 
cd2e			;	dw looptest1 
cd2e			;	dw looptest2 
cd2e			;	dw test1 
cd2e			;	dw test2 
cd2e			;	dw test3 
cd2e			;	dw test4 
cd2e			;	dw game2r 
cd2e			;	dw game2b1 
cd2e			;	dw game2b2 
cd2e			 
cd2e				; start up words that are actually useful 
cd2e			 
cd2e			;    dw spi1 
cd2e			;    dw spi2 
cd2e			;    dw spi3 
cd2e			;    dw spi4 
cd2e			;    dw spi5 
cd2e			;    dw spi6 
cd2e			;    dw spi7 
cd2e			; 
cd2e			;    dw spi8 
cd2e			;    dw spi9 
cd2e			;    dw spi10 
cd2e			 
cd2e			; file editor 
cd2e			;	dw edit1 
cd2e			;	dw edit2 
cd2e			;	dw edit3 
cd2e			 
cd2e			;	dw longread 
cd2e 2e d1			dw clrstack 
cd30 62 d1			dw type 
cd32			;	dw stest 
cd32 87 d1			dw strncpy 
cd34			;	dw list 
cd34 e8 d1			dw start1 
cd36 f8 d1			dw start2 
cd38			;	dw start3 
cd38			;	dw start3b 
cd38			;	dw start3c 
cd38			 
cd38				; (unit) testing words 
cd38			 
cd38			;	dw mtesta 
cd38			;	dw mtestb 
cd38			;	dw mtestc 
cd38			;	dw mtestd 
cd38			;	dw mteste 
cd38			 
cd38				; demo/game words 
cd38			 
cd38			;        dw game3w 
cd38			;        dw game3p 
cd38			;        dw game3sc 
cd38			;        dw game3vsi 
cd38			;        dw game3vs 
cd38				 
cd38 51 dc			dw game2b 
cd3a bf dc			dw game2bf 
cd3c 09 dd			dw game2mba 
cd3e 9f dd			dw game2mbas 
cd40 e1 dd			dw game2mb 
cd42			 
cd42 12 d9			dw game1 
cd44 23 d9			dw game1a 
cd46 85 d9			dw game1b 
cd48 ba d9			dw game1c 
cd4a f0 d9			dw game1d 
cd4c 21 da			dw game1s 
cd4e 35 da			dw game1t 
cd50 4a da			dw game1f 
cd52 7e da			dw game1z 
cd54 c2 da			dw game1zz 
cd56			 
cd56 2c d7			dw test5 
cd58 64 d7			dw test6 
cd5a 9c d7			dw test7 
cd5c b0 d7			dw test8 
cd5e dc d7			dw test9 
cd60 f2 d7			dw test10 
cd62				 
cd62 99 db		        dw ssv5 
cd64 7d db		        dw ssv4 
cd66 61 db		        dw ssv3 
cd68 2b db		        dw ssv2 
cd6a b2 db		        dw ssv1 
cd6c fa db		        dw ssv1cpm 
cd6e			;	dw keyup 
cd6e			;	dw keydown 
cd6e			;	dw keyleft 
cd6e			;	dw keyright 
cd6e			;	dw 	keyf1 
cd6e			;	dw keyf2 
cd6e			;	dw keyf3 
cd6e			;	dw keyf4 
cd6e			;	dw keyf5 
cd6e			;	dw keyf6 
cd6e			;	dw keyf7 
cd6e			;	dw keyf8 
cd6e			;	dw keyf9 
cd6e			;	dw keyf10 
cd6e			;	dw keyf11 
cd6e			;	dw keyf12 
cd6e			;	dw keytab 
cd6e			;	dw keycr 
cd6e			;	dw keyhome 
cd6e			;	dw keyend 
cd6e			;	dw keybs 
cd6e 00 00			db 0, 0	 
cd70			 
cd70			 
cd70			; File Editor 
cd70			 
cd70			; ( id - ) use 'e' to edit the displayed line 
cd70 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd91 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdc6			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdc6 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cdfe			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cdfe			 
cdfe			; SPI Net support words 
cdfe			 
cdfe			; v0! = node to send to 
cdfe			; ( str count - ) 
cdfe .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce57			 
ce57			; spiputchr ( char node - ) 
ce57 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce8d			 
ce8d			; spigetchr ( - n ) 
ce8d .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
ceb8			 
ceb8			; getnode ( - n ) 
ceb8 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cee5			 
cee5			; ( str node - )  
cee5 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf4b			; store string ( str i - ) 
cf4b			 
cf4b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf4b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfa0			 
cfa0			; get string ( addr i -  )    TO FIX 
cfa0			 
cfa0 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cff8			 
cff8			 
cff8			; NETCHAT (TODO) 
cff8			; Program to allow two nodes to chat with eachother 
cff8			; 
cff8			; v0 - target node 
cff8			;  
cff8			; accept input at 0,0 
cff8			; if input is string send spitype to target node 
cff8			; starting at row 2,0 , while spigetchr is not zero ->  
cff8			; 
cff8			; 
cff8			; TODO add paging of get request 
cff8			 
cff8			; ( node - ) 
cff8 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d017 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d06f .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0e7			 
d0e7			 
d0e7			; Long read of currently open file 
d0e7 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d12e			 
d12e			; clear stack  
d12e			 
d12e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d162			 
d162			; type ( addr count - ) 
d162 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d187			 
d187			; some direct memory words 
d187			; strncpy ( len t f -- t ) 
d187			 
d187 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1e8			 
d1e8 .. 00		start1:     	db ": bpon $00 bp ;",0 
d1f8 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d209 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d284 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2e4			 
d2e4			 
d2e4			; a handy word to list items on the stack 
d2e4			 
d2e4 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d34e			 
d34e			 
d34e			; test stack  
d34e			; rnd8 stest 
d34e			 
d34e .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d3c5			 
d3c5			; random malloc and free cycles 
d3c5			 
d3c5 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d47a			 
d47a			; fixed malloc and free cycles 
d47a			 
d47a .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d51d			 
d51d			; fixed double string push and drop cycle  
d51d			 
d51d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5d2			 
d5d2			; consistent fixed string push and drop cycle  
d5d2			 
d5d2 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d676			 
d676 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d72c			 
d72c			;test1:		db ": aa 1 2 3 ;", 0 
d72c			;test2:     	db "111 aa 888 999",0 
d72c			;test3:     	db ": bb 77 ;",0 
d72c			;test4:     	db "$02 $01 do i . loop bb",0 
d72c			 
d72c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d764 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d79c .. 00		test7:     	db ": box hline vline ;",0 
d7b0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7dc .. 00		test9:     	db ": sw $01 adsp world ;",0 
d7f2 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d817 .. 00		test11:     	db "hello create .",0 
d826 .. 00		test12:     	db "hello2 create .",0 
d836			 
d836			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d836			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d836			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d836			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d836			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d836			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d836			 
d836			;iftest1:     	db "$0001 IF cls .",0 
d836			;iftest2:     	db "$0000 IF cls .",0 
d836			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d836			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d836			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d836			 
d836			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d836			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d836			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d836			 
d836			 
d836 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d85a .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d88a .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d8af .. 00		sound4: db ": cha $00 ; ",0 
d8bc .. 00		sound5: db ": chb $20 ; ",0 
d8c9 .. 00		sound6: db ": chc $40 ; ",0 
d8d6 .. 00		sound7: db ": chd $60 ; ",0 
d8e3 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d8fb .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d912			 
d912			 
d912			 
d912			 
d912			; a small guess the number game 
d912			 
d912 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d923 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d985			 
d985 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d9ba .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d9f0 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
da21 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
da35 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
da4a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
da7e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dac2			 
dac2			; Using 'ga' save a high score across multiple runs using external storage 
dac2			 
dac2 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
db2b			 
db2b			 
db2b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
db2b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
db2b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
db2b			 
db2b			; simple screen saver to test code memory reuse to destruction 
db2b			 
db2b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
db61 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
db7d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
db99 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dbb2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dbfa .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc51			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc51			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc51			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc51			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc51			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc51			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc51			 
dc51			 
dc51			 
dc51			; minesweeper/battleship finding game 
dc51			; draws a game board of random ship/mine positions 
dc51			; user enters coords to see if it hits on 
dc51			; game ends when all are hit 
dc51			; when hit or miss says how many may be in the area 
dc51			 
dc51			; setup the game board and then hide it 
dc51 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dcbf .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dd09			; prompt for where to target 
dd09 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dd9f .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ddc4			; TODO see if the entered coords hits or misses pushes char hit of miss 
ddc4 .. 00		game2mbht:      db ": mbckht nop ;",0 
ddd3 .. 00		game2mbms:      db ": mbcms nop ;",0 
dde1			; TODO how many might be near by 
dde1 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
de5e			 
de5e			; Game 3 
de5e			 
de5e			; Vert scroller ski game - avoid the trees! 
de5e			 
de5e			; v0 score (ie turns) 
de5e			; v1 player pos 
de5e			; v2 left wall 
de5e			; v3 right wall 
de5e			 
de5e			; Draw side walls randomly 
de5e			 
de5e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
de8c			 
de8c			; Draw player 
de8c .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
deaa			 
deaa			; TODO Get Key 
deaa			 
deaa			; TODO Move left right 
deaa			 
deaa			; scroll and move walls a bit 
deaa			 
deaa .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
dedb			 
dedb			; main game loop 
dedb			 
dedb .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
df07 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df46			 
df46			; key board defs 
df46			 
df46 .. 00		keyup:       db ": keyup $05 ;",0 
df54 .. 00		keydown:       db ": keydown $0a ;",0 
df64 .. 00		keyleft:       db ": keyleft $0b ;",0 
df74 .. 00		keyright:       db ": keyright $0c ;",0 
df85 .. 00		keyf1:       db ": keyf1 $10 ;",0 
df93 .. 00		keyf2:       db ": keyf2 $11 ;",0 
dfa1 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dfaf .. 00		keyf4:       db ": keyf4 $13 ;",0 
dfbd .. 00		keyf5:       db ": keyf5 $14 ;",0 
dfcb .. 00		keyf6:       db ": keyf6 $15 ;",0 
dfd9 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dfe7 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dff5 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e003 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e012 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e021 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e030			 
e030 .. 00		keytab:       db ": keytab $09 ;",0 
e03f .. 00		keycr:       db ": keycr $0d ;",0 
e04d .. 00		keyhome:       db ": keyhome $0e ;",0 
e05d .. 00		keyend:       db ": keyend $0f ;",0 
e06c .. 00		keybs:       db ": keybs $08 ;",0 
e07a			 
e07a			   
e07a			 
e07a			 
e07a			 
e07a			; eof 
# End of file forth_autostart.asm
e07a			 
e07a			 
e07a			 
e07a			; stack over and underflow checks 
e07a			 
e07a			; init the words to detect the under/overflow 
e07a			 
e07a			chk_stk_init: 
e07a				; a vague random number to check so we dont get any "lucky" hits 
e07a 3e 2d			ld a, 45 
e07c 6f				ld l, a 
e07d 00				nop 
e07e 3e 17			ld a, 23 
e080 67				ld h, a 
e081			 
e081 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e084			 
e084			;	ld (chk_stund), hl	; stack points.... 
e084 22 00 ef			ld (chk_stovr), hl 
e087 22 ec e9			ld (chk_ret_und), hl 
e08a 22 aa e9			ld (chk_ret_ovr), hl 
e08d 22 28 e9			ld (chk_loop_ovr), hl 
e090 22 26 e8			ld (chk_data_ovr), hl 
e093 c9				ret 
e094				 
e094			check_stacks: 
e094				; check all stack words 
e094			 
e094 e5				push hl 
e095 d5				push de 
e096			 
e096			;	ld de,(chk_word) 
e096			;	ld hl, (chk_stund)	; stack points.... 
e096			;	if DEBUG_STK_FAULT 
e096			;		DMARK "FAa" 
e096			;		CALLMONITOR 
e096			;	endif 
e096			;	call cmp16 
e096			;	jp z, .chk_faulta 
e096			; 
e096			;	ld de, sfaultsu 
e096			;	jp .chk_fault 
e096			 
e096 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e099 ed 5b 9d e2		ld de,(chk_word) 
e09d				if DEBUG_STK_FAULT 
e09d					DMARK "FAb" 
e09d					CALLMONITOR 
e09d				endif 
e09d cd fa 8c			call cmp16 
e0a0 28 06			jr z, .chk_fault1 
e0a2 11 43 e1			ld de, sfaultso 
e0a5 c3 f7 e0			jp .chk_fault 
e0a8			.chk_fault1:  
e0a8 2a ec e9			ld hl, (chk_ret_und) 
e0ab ed 5b 9d e2		ld de,(chk_word) 
e0af				if DEBUG_STK_FAULT 
e0af					DMARK "FAU" 
e0af					CALLMONITOR 
e0af				endif 
e0af cd fa 8c			call cmp16 
e0b2 ca bb e0			jp z, .chk_fault2 
e0b5 11 53 e1			ld de, sfaultru 
e0b8 c3 f7 e0			jp .chk_fault 
e0bb			.chk_fault2:  
e0bb 2a aa e9			ld hl, (chk_ret_ovr) 
e0be ed 5b 9d e2		ld de,(chk_word) 
e0c2				if DEBUG_STK_FAULT 
e0c2					DMARK "FA1" 
e0c2					CALLMONITOR 
e0c2				endif 
e0c2 cd fa 8c			call cmp16 
e0c5 ca ce e0			jp z, .chk_fault3 
e0c8 11 61 e1			ld de, sfaultro 
e0cb c3 f7 e0			jp .chk_fault 
e0ce			.chk_fault3:  
e0ce 2a 28 e9			ld hl, (chk_loop_ovr) 
e0d1 ed 5b 9d e2		ld de,(chk_word) 
e0d5				if DEBUG_STK_FAULT 
e0d5					DMARK "FA2" 
e0d5					CALLMONITOR 
e0d5				endif 
e0d5 cd fa 8c			call cmp16 
e0d8 ca e1 e0			jp z, .chk_fault4 
e0db 11 7b e1			ld de, sfaultlo 
e0de c3 f7 e0			jp .chk_fault 
e0e1			.chk_fault4:  
e0e1 2a 26 e8			ld hl, (chk_data_ovr) 
e0e4 ed 5b 9d e2		ld de,(chk_word) 
e0e8				if DEBUG_STK_FAULT 
e0e8					DMARK "FA3" 
e0e8					CALLMONITOR 
e0e8				endif 
e0e8 cd fa 8c			call cmp16 
e0eb ca f4 e0			jp z, .chk_fault5 
e0ee 11 95 e1			ld de, sfaultdo 
e0f1 c3 f7 e0			jp .chk_fault 
e0f4			 
e0f4			 
e0f4			.chk_fault5:  
e0f4 d1				pop de 
e0f5 e1				pop hl 
e0f6			 
e0f6 c9				ret 
e0f7			 
e0f7 cd af 8a		.chk_fault: 	call clear_display 
e0fa 3e 28				ld a, display_row_2 
e0fc cd c2 8a				call str_at_display 
e0ff 11 25 e1				   ld de, .stackfault 
e102 3e 00				ld a, display_row_1 
e104 cd c2 8a				call str_at_display 
e107 11 6b ee				    ld de, debug_mark 
e10a 3e 11				ld a, display_row_1+17 
e10c cd c2 8a				call str_at_display 
e10f cd d2 8a				call update_display 
e112			 
e112				; prompt before entering montior for investigating issue 
e112			 
e112 3e 78			ld a, display_row_4 
e114 11 2e 98			ld de, endprog 
e117			 
e117 cd d2 8a			call update_display		 
e11a			 
e11a cd b4 9a			call next_page_prompt 
e11d			 
e11d d1				pop de 
e11e e1				pop hl 
e11f cd 82 98				call monitor 
e122 c3 8b 97				jp warmstart 
e125					;jp 0 
e125					;halt 
e125			 
e125			 
e125			 
e125 .. 00		.stackfault: 	db "Stack fault:",0 
e132			 
e132 .. 00		sfaultsu: 	db	"Stack under flow",0 
e143 .. 00		sfaultso: 	db	"Stack over flow",0 
e153 .. 00		sfaultru:	db "RTS underflow",0 
e161 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e17b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e195 .. 00		sfaultdo:	db "DTS overflow", 0 
e1a2			 
e1a2			 
e1a2			fault_dsp_under: 
e1a2 11 b4 e1			ld de, .dsp_under 
e1a5 c3 64 e2			jp .show_fault 
e1a8			 
e1a8			fault_rsp_under: 
e1a8 11 c2 e1			ld de, .rsp_under 
e1ab c3 64 e2			jp .show_fault 
e1ae			fault_loop_under: 
e1ae 11 d0 e1			ld de, .loop_under 
e1b1 c3 64 e2			jp .show_fault 
e1b4			 
e1b4 .. 00		.dsp_under: db "DSP Underflow",0 
e1c2 .. 00		.rsp_under: db "RSP Underflow",0 
e1d0 .. 00		.loop_under: db "LOOP Underflow",0 
e1df			 
e1df			 
e1df d5			type_faultn: 	push de 
e1e0 e5					push hl 
e1e1 cd af 8a				call clear_display 
e1e4 11 0b e2				   ld de, .typefaultn 
e1e7 3e 00				ld a, display_row_1 
e1e9 cd c2 8a				call str_at_display 
e1ec 11 6b ee				    ld de, debug_mark 
e1ef 3e 11				ld a, display_row_1+17 
e1f1 cd c2 8a				call str_at_display 
e1f4 cd d2 8a				call update_display 
e1f7			 
e1f7				; prompt before entering montior for investigating issue 
e1f7			 
e1f7 3e 78			ld a, display_row_4 
e1f9 11 2e 98			ld de, endprog 
e1fc			 
e1fc cd d2 8a			call update_display		 
e1ff			 
e1ff cd b4 9a			call next_page_prompt 
e202			 
e202 e5					push hl 
e203 d5					push de 
e204 cd 82 98				call monitor 
e207 c3 8b 97				jp warmstart 
e20a 76					halt 
e20b			 
e20b			 
e20b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e222			 
e222 d5			type_faults: 	push de 
e223 e5					push hl 
e224 cd af 8a				call clear_display 
e227 11 4d e2				   ld de, .typefaults 
e22a 3e 00				ld a, display_row_1 
e22c cd c2 8a				call str_at_display 
e22f 11 6b ee				    ld de, debug_mark 
e232 3e 11				ld a, display_row_1+17 
e234 cd c2 8a				call str_at_display 
e237 cd d2 8a				call update_display 
e23a			 
e23a				; prompt before entering montior for investigating issue 
e23a			 
e23a 3e 78			ld a, display_row_4 
e23c 11 2e 98			ld de, endprog 
e23f			 
e23f cd d2 8a			call update_display		 
e242			 
e242 cd b4 9a			call next_page_prompt 
e245			 
e245 e1					pop hl 
e246 d1					pop de 
e247 cd 82 98				call monitor 
e24a c3 8b 97				jp warmstart 
e24d			 
e24d			 
e24d .. 00		.typefaults: db "STR Type Expected TOS!",0 
e264			 
e264			.show_fault: 	 
e264 d5					push de 
e265 cd af 8a				call clear_display 
e268 d1					pop de 
e269 3e 00				ld a, display_row_1 
e26b cd c2 8a				call str_at_display 
e26e 11 6b ee				    ld de, debug_mark 
e271 3e 11				ld a, display_row_1+17 
e273 cd c2 8a				call str_at_display 
e276 cd d2 8a				call update_display 
e279			 
e279				; prompt before entering montior for investigating issue 
e279			 
e279 3e 78			ld a, display_row_4 
e27b 11 2e 98			ld de, endprog 
e27e			 
e27e cd d2 8a			call update_display		 
e281			 
e281 cd b4 9a			call next_page_prompt 
e284			 
e284 e1					pop hl 
e285 d1					pop de 
e286 cd 82 98				call monitor 
e289			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e289			; TODO Make optional fault restart to cli or warm boot? 
e289					;jp warmstart 
e289 c3 d5 97				jp cli 
e28c 76					halt 
e28d			 
e28d			; handle the auto run of code from files in storage 
e28d			 
e28d			 
e28d			include "forth_startup.asm" 
e28d			; Which startup method to use? 
e28d			; 
e28d			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e28d			; followed by loading of a list of scripts in eeprom 
e28d			 
e28d			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e28d			; from eeprom 
e28d			 
e28d			; Select with define in main stubs 
e28d			 
e28d			if STARTUP_V1 
e28d				include "forth_startupv1.asm" 
e28d			; Startup script loading version 1 
e28d			 
e28d			; If SE storage is available first stage is to use the selected file 
e28d			; then go through the eeprom list 
e28d			 
e28d .. 00		sprompt1: db "Startup load...",0 
e29d .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e2b3			 
e2b3			 
e2b3			 
e2b3			 
e2b3			forth_startup: 
e2b3 21 2e cd			ld hl, startcmds 
e2b6 3e 00			ld a, 0 
e2b8 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e2bb			 
e2bb e5			.start1:	push hl 
e2bc cd af 8a			call clear_display 
e2bf 11 8d e2			ld de, sprompt1 
e2c2 3e 00		        ld a, display_row_1 
e2c4 cd c2 8a			call str_at_display 
e2c7 11 9d e2			ld de, sprompt2 
e2ca 3e 28		        ld a, display_row_2 
e2cc cd c2 8a			call str_at_display 
e2cf e1				pop hl 
e2d0 e5				push hl 
e2d1 5e				ld e,(hl) 
e2d2 23				inc hl 
e2d3 56				ld d,(hl) 
e2d4 3e 50		        ld a, display_row_3 
e2d6 cd c2 8a			call str_at_display 
e2d9 cd d2 8a			call update_display 
e2dc			 
e2dc			 
e2dc 3a e7 e6			ld a, (os_last_cmd) 
e2df fe 00			cp 0 
e2e1 28 05			jr z, .startprompt 
e2e3 cd e6 89			call delay250ms 
e2e6 18 24			jr .startdo 
e2e8				 
e2e8				 
e2e8			 
e2e8			.startprompt: 
e2e8			 
e2e8 3e 9f			ld a,display_row_4 + display_cols - 1 
e2ea 11 b2 9a		        ld de, endprg 
e2ed cd c2 8a			call str_at_display 
e2f0 cd d2 8a			call update_display 
e2f3 cd f2 89			call delay1s 
e2f6 cd 19 e4			call cin_wait 
e2f9						 
e2f9 fe 2a			cp '*' 
e2fb 28 5e			jr z, .startupend1 
e2fd fe 23			cp '#' 
e2ff 20 07			jr nz, .startno 
e301 3e 01			ld a, 1 
e303 32 e7 e6			ld (os_last_cmd),a 
e306 18 04			jr .startdo 
e308 fe 31		.startno:	cp '1' 
e30a 28 3a			jr z,.startnxt  
e30c			 
e30c				; exec startup line 
e30c			.startdo:	 
e30c e1				pop hl 
e30d e5				push hl 
e30e				 
e30e 5e				ld e,(hl) 
e30f 23				inc hl 
e310 56				ld d,(hl) 
e311 eb				ex de,hl 
e312			 
e312 e5				push hl 
e313			 
e313 3e 00			ld a, 0 
e315				;ld a, FORTH_END_BUFFER 
e315 cd 45 91			call strlent 
e318 23				inc hl   ; include zero term to copy 
e319 06 00			ld b,0 
e31b 4d				ld c,l 
e31c e1				pop hl 
e31d 11 c1 e2			ld de, scratch 
e320 ed b0			ldir 
e322			 
e322			 
e322 21 c1 e2			ld hl, scratch 
e325 cd 37 9f			call forthparse 
e328 cd 77 9f			call forthexec 
e32b cd 89 9e			call forthexec_cleanup 
e32e			 
e32e 3e 78			ld a, display_row_4 
e330 11 2e 98			ld de, endprog 
e333			 
e333 cd d2 8a			call update_display		 
e336			 
e336 3a e7 e6			ld a, (os_last_cmd) 
e339 fe 00			cp 0 
e33b 20 09			jr nz, .startnxt 
e33d cd b4 9a			call next_page_prompt 
e340 cd af 8a		        call clear_display 
e343 cd d2 8a			call update_display		 
e346			 
e346				; move onto next startup line? 
e346			.startnxt: 
e346			 
e346 cd e6 89			call delay250ms 
e349 e1				pop hl 
e34a			 
e34a 23				inc hl 
e34b 23				inc hl 
e34c			 
e34c e5				push hl 
e34d 5e				ld e, (hl) 
e34e 23				inc hl 
e34f 56				ld d, (hl) 
e350 e1				pop hl 
e351				; TODO replace 0 test 
e351			 
e351 eb				ex de, hl 
e352 cd 05 8d			call ishlzero 
e355			;	ld a,e 
e355			;	add d 
e355			;	cp 0    ; any left to do? 
e355 eb				ex de, hl 
e356 c2 bb e2			jp nz, .start1 
e359 18 01			jr .startupend 
e35b			 
e35b e1			.startupend1: pop hl 
e35c			.startupend: 
e35c			 
e35c cd af 8a			call clear_display 
e35f cd d2 8a			call update_display 
e362 c9				ret 
e363			if STORAGE_SE 
e363			 
e363			sprompt3: db "Loading from start-up file?:",0 
e363			sprompt4: db "(Y=Any key/N=No)",0 
e363			 
e363			 
e363			forth_autoload: 
e363			 
e363				; load block 0 of store 1 
e363				 
e363				ld a, $fe      ; bit 0 clear 
e363				ld (spi_device), a 
e363			 
e363				call storage_get_block_0 
e363			 
e363				ld a, (store_page+STORE_0_AUTOFILE) 
e363			 
e363				cp 0 
e363				ret z     ; auto start not enabled 
e363			 
e363				call clear_display 
e363			 
e363				; set bank 
e363			 
e363					ld a, (store_page+STORE_0_BANKRUN) 
e363					ld (spi_device), a 
e363			 
e363				; get file id to load from and get the file name to display 
e363			 
e363					ld a, (store_page+STORE_0_FILERUN) 
e363			 
e363					ld l, 0 
e363					ld h, a 
e363					ld de, store_page 
e363			 
e363					if DEBUG_FORTH_WORDS 
e363						DMARK "ASp" 
e363						CALLMONITOR 
e363					endif 
e363					call storage_read 
e363			 
e363					if DEBUG_FORTH_WORDS 
e363						DMARK "ASr" 
e363						CALLMONITOR 
e363					endif 
e363			 
e363					call ishlzero 
e363					ret z             ; file not found 
e363			 
e363					ld a, display_row_2 + 10 
e363					ld de, store_page+3 
e363					call str_at_display 
e363				 
e363			; 
e363			 
e363				ld a, display_row_1+5 
e363				ld de, sprompt3 
e363				call str_at_display 
e363				ld a, display_row_3+15 
e363				ld de, sprompt4 
e363				call str_at_display 
e363			 
e363				call update_display 
e363			 
e363				call cin_wait 
e363				cp 'n' 
e363				ret z 
e363				cp 'N' 
e363				ret z 
e363			 
e363				call delay1s 
e363			 
e363				ld a, (store_page+2) 
e363				ld (store_openmaxext), a    ; save count of ext 
e363				ld a, 1  
e363				ld (store_openext), a    ; save count of ext 
e363			 
e363			.autof:  
e363				ld l , a 
e363				 
e363				ld a, (store_page) 
e363				ld h, a	 
e363				ld de, store_page 
e363					if DEBUG_FORTH_WORDS 
e363						DMARK "ASl" 
e363						CALLMONITOR 
e363					endif 
e363					call storage_read 
e363				call ishlzero 
e363				ret z 
e363			;	jr z, .autoend 
e363			 
e363					if DEBUG_FORTH_WORDS 
e363						DMARK "ASc" 
e363						CALLMONITOR 
e363					endif 
e363				ld de, store_page+2 
e363				ld a, display_row_4 
e363				call str_at_display 
e363			 
e363				call update_display 
e363				call delay250ms 
e363			 
e363			 
e363			 
e363				ld hl, store_page+2 
e363				call forthparse 
e363				call forthexec 
e363				call forthexec_cleanup 
e363			 
e363				 
e363				ld a, (store_openext) 
e363				inc a 
e363				ld (store_openext), a    ; save count of ext 
e363			 
e363				jr .autof 
e363			;.autofdone: 
e363			; 
e363			;		if DEBUG_FORTH_WORDS 
e363			;			DMARK "ASx" 
e363			;			CALLMONITOR 
e363			;		endif 
e363			;;	call clear_display 
e363			;	ret 
e363			 
e363			 
e363			 
e363			endif 
# End of file forth_startupv1.asm
e363			endif 
e363			if STARTUP_V2 
e363				include "forth_startupv2.asm" 
e363			endif 
e363			 
# End of file forth_startup.asm
e363			 
e363			; eof 
# End of file forth_kernel.asm
e363			;include "nascombasic.asm" 
e363			 
e363			 
e363			; find out where the code ends if loaded into RAM (for SC114) 
e363			;endofcode:  
e363			;	nop 
e363			 
e363			 
e363			; jump to nmi vector 
e363			 
e363			init_nmi: 
e363 3e c9			ld a, $c9   ; RET 
e365 32 72 ee			ld (nmi_vector), a 
e368 c9				ret 
e369			nmi: 
e369 e5				push hl 
e36a d5				push de 
e36b c5				push bc 
e36c f5				push af 
e36d cd 72 ee			call nmi_vector 
e370 f5				push af 
e371 c5				push bc 
e372 d5				push de 
e373 e5				push hl 
e374 ed 4d			reti 
e376			 
e376			 
e376			; eof 
e376			 
# End of file main.asm
e376			;include "firmware_lcd_4x40.asm" 
e376			;;include "firmware_lcd_4x20.asm" 
e376			include "firmware_serial_display.asm" 
e376			 
e376			; Serial display interface for SC114 
e376			 
e376			 
e376			display_row_1: equ 0 
e376			display_row_2: equ display_row_1+display_cols 
e376			display_row_3: equ display_row_2 + display_cols 
e376			display_row_4: equ display_row_3 + display_cols 
e376			 
e376			kLCDWidth:  EQU display_cols             ;Width in characters 
e376			kLCD_Line1: EQU 0x00  
e376			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e376			; E1 
e376			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e376			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e376			 
e376			lcd_init: 
e376				; no init as handled by the SCM bios 
e376 c9				ret 
e377			 
e377			 
e377			; low level functions for direct screen writes 
e377			 
e377			; output char at pos? 
e377			fLCD_Str: 
e377			        ;out (SC114_SIO_1_OUT),a 
e377 c5				push bc 
e378 0e 02			ld c, $02 
e37a f7				rst $30 
e37b c1				pop bc 
e37c c9				ret 
e37d			 
e37d			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e37d			fLCD_Pos: 
e37d				; use ASCII escape to position 
e37d			        ;out (SC114_SIO_1_OUT),a 
e37d c5				push bc 
e37e 0e 02			ld c, $02 
e380 f7				rst $30 
e381 c1				pop bc 
e382			 
e382 c9				ret 
e383			 
e383			; output char at pos 
e383			fLCD_Data: 
e383			      ;  out (SC114_SIO_1_OUT),a 
e383 c5				push bc 
e384 0e 02			ld c, $02 
e386 f7				rst $30 
e387 c1				pop bc 
e388			 
e388 c9				ret 
e389			 
e389			; ascii cls  
e389			 
e389 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e38d			 
e38d			; write the frame buffer given in hl to hardware  
e38d			write_display: 
e38d			 
e38d			API: equ 0 
e38d			 
e38d			if API 
e38d				push bc 
e38d				ld b, 4 
e38d			 
e38d			        ld (display_write_tmp), hl 	  
e38d			 
e38d				; clear and home cursor 
e38d			 
e38d				ld c, 6 
e38d				ld de, .cls 
e38d				rst $30 
e38d			 
e38d			 
e38d			.writeln: 
e38d			 
e38d				ld de, (display_write_tmp) 
e38d				ld c, 6 
e38d				rst $30 
e38d				ld c, 7 
e38d				rst $30 
e38d			 
e38d				ld hl, (display_write_tmp) 
e38d				ld de, display_cols 
e38d				add hl,de 
e38d				ld (display_write_tmp),hl 
e38d			 
e38d				djnz  .writeln 
e38d			 
e38d				pop bc 
e38d			 
e38d			 
e38d				ret 
e38d			endif 
e38d e5				push hl 
e38e c5				push bc 
e38f d5				push de 
e390			 
e390			;	ld c, 2 
e390			;	;ld de, .cls 
e390			;	ld a, 27 
e390			;	rst $30 
e390			;	ld c, 2 
e390			;	;ld de, .cls 
e390			;	ld a, '[' 
e390			;	rst $30 
e390			; 
e390			;	ld c, 2 
e390			;	;ld de, .cls 
e390			;	ld a, 'H' 
e390			;	rst $30 
e390			; 
e390			 
e390 0e 02			ld c, 2 
e392				;ld de, .cls 
e392 3e 1b			ld a, 27 
e394 f7				rst $30 
e395			 
e395			 
e395 0e 02			ld c, 2 
e397				;ld de, .cls 
e397 3e 5b			ld a, '[' 
e399 f7				rst $30 
e39a 0e 02			ld c, 2 
e39c				;ld de, .cls 
e39c 3e 32			ld a, '2' 
e39e f7				rst $30 
e39f 0e 02			ld c, 2 
e3a1				;ld de, .cls 
e3a1 3e 4a			ld a, 'J' 
e3a3 f7				rst $30 
e3a4 d1				pop de 
e3a5 c1				pop bc 
e3a6 e1				pop hl 
e3a7			 
e3a7			 
e3a7 22 c9 eb		        ld (display_write_tmp), hl 	  
e3aa 3e 00			ld a, kLCD_Line1 
e3ac			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3ac 06 28			ld b, display_cols 
e3ae ed 5b c9 eb		ld de, (display_write_tmp) 
e3b2 cd 10 e4			call write_len_string 
e3b5				 
e3b5			 
e3b5 e5			push hl 
e3b6 d5			push de 
e3b7 c5			push bc 
e3b8 0e 07			ld c, 7 
e3ba f7				rst $30 
e3bb c1			pop bc 
e3bc d1			pop de 
e3bd e1			pop hl 
e3be			 
e3be				 
e3be 2a c9 eb			ld hl, (display_write_tmp) 
e3c1 11 28 00			ld de, display_cols 
e3c4 19				add hl,de 
e3c5 22 c9 eb			ld (display_write_tmp),hl 
e3c8			 
e3c8				 
e3c8 3e 28			ld a, kLCD_Line2 
e3ca			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3ca 06 28			ld b, display_cols 
e3cc ed 5b c9 eb		ld de, (display_write_tmp) 
e3d0 cd 10 e4			call write_len_string 
e3d3				 
e3d3 2a c9 eb			ld hl, (display_write_tmp) 
e3d6 11 28 00			ld de, display_cols 
e3d9 19				add hl,de 
e3da 22 c9 eb			ld (display_write_tmp),hl 
e3dd			 
e3dd e5			push hl 
e3de d5			push de 
e3df c5			push bc 
e3e0 0e 07			ld c, 7 
e3e2 f7				rst $30 
e3e3 c1			pop bc 
e3e4 d1			pop de 
e3e5 e1			pop hl 
e3e6			 
e3e6				 
e3e6 3e 50			ld a, kLCD_Line3 
e3e8			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e3e8 06 28			ld b, display_cols 
e3ea ed 5b c9 eb		ld de, (display_write_tmp) 
e3ee cd 10 e4			call write_len_string 
e3f1				 
e3f1 2a c9 eb			ld hl, (display_write_tmp) 
e3f4 11 28 00			ld de, display_cols 
e3f7 19				add hl,de 
e3f8 22 c9 eb			ld (display_write_tmp),hl 
e3fb			 
e3fb e5			push hl 
e3fc d5			push de 
e3fd c5			push bc 
e3fe 0e 07			ld c, 7 
e400 f7				rst $30 
e401 c1			pop bc 
e402 d1			pop de 
e403 e1			pop hl 
e404			 
e404				 
e404 3e 78			ld a, kLCD_Line4 
e406			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e406 06 28			ld b, display_cols 
e408 ed 5b c9 eb		ld de, (display_write_tmp) 
e40c cd 10 e4			call write_len_string 
e40f c9					ret 
e410			 
e410			 
e410				; write out a fixed length string given in b from de 
e410			 
e410 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e411 cd 83 e3		            CALL fLCD_Data      ;Write character to display 
e414 13				inc de 
e415 10 f9			djnz write_len_string 
e417 c9				ret 
e418			 
e418			 
e418			; eof 
# End of file firmware_serial_display.asm
e418			;include "firmware_key_5x10.asm" 
e418			;;include "firmware_key_4x10.asm" 
e418			include "firmware_key_serial.asm" 
e418			; Serial keyboard interface for SC114 
e418			 
e418			key_init: 
e418				; no init as handled by the SCM bios 
e418 c9				ret 
e419			 
e419			 
e419			cin_wait: 
e419			;	ld a, 0 
e419			;	ret 
e419			 
e419				;in a,(SC114_SIO_1_IN) 
e419			        ; Use SCM API to get from whatever console device we are using 
e419 c5				push bc 
e41a 0e 01			ld c, $01 
e41c f7				rst $30 
e41d c1				pop bc 
e41e c9				ret 
e41f			 
e41f			cin: 
e41f			 
e41f			 
e41f c5				push bc 
e420			 
e420				; any key waiting to process? 
e420 0e 03			ld c, $03 
e422 f7				rst $30 
e423 28 05			jr z, .cin_skip 
e425			 
e425				; yep, get it 
e425			 
e425 0e 01			ld c, $01 
e427 f7				rst $30 
e428 c1				pop bc 
e429 c9				ret 
e42a			.cin_skip: 
e42a 3e 00			ld a, 0 
e42c c1				pop bc 
e42d c9				ret 
e42e			 
e42e			 
e42e			 
e42e			 
# End of file firmware_key_serial.asm
e42e			endofcode:  
e42e			baseram:  
e42e 00				nop 
e42f			 
e42f			heap_start: equ baseram+15  ; Starting address of heap 
e42f			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e42f			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e42f			;VDU:  EQU     endofcode           ; BASIC Work space 
e42f			; eof 
e42f			 
# End of file os_mega_sc114.asm
e42f
