# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 6f 96			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-09 10:42' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			;stacksize: equ 256  
801b			; each stack entry is three bytes (type + word)  
801b			stacksize: equ 3*150  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			; cursor blink rate  
801b			CUR_BLINK_RATE: equ $09  
801b			;CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd 41 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd e3 e3			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd 9f 90				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 cd 95			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 e2 95			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd 86 90				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd 59 90			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd 8b 9d			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd d4 99			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd 58 e3			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd e4 e3				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored and edited directly 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO use LCD cursor? 
8d08			 
8d08			EDIT_V1: equ 0 
8d08			EDIT_V2: equ 1 
8d08			 
8d08			 
8d08			 
8d08			if EDIT_V2 
8d08			input_str: 
8d08			 
8d08 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d0b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d0b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d0e			;		ld a, c 
8d0e			;		call addatohl 
8d0e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d0e 7a					ld a,d 
8d0f 32 66 ee			        ld (input_size), a       ; save length of input area 
8d12 79					ld a, c 
8d13 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d16 7b					ld a,e 
8d17 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d1a			 
8d1a			 
8d1a					; add a trailing space to make screen refresh nicer 
8d1a			 
8d1a					;ld hl, (input_start) 
8d1a					;push hl 
8d1a					;ld a, 0 
8d1a					;call strlent 
8d1a					;ld a, l 
8d1a					;pop hl 
8d1a					;call addatohl 
8d1a					;dec hl 
8d1a					;ld a, ' ' 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld a, 0 
8d1a					;ld (hl), a 
8d1a			 
8d1a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d1a					; init cursor shape if not set by the cin routines 
8d1a 21 c1 eb				ld hl, cursor_shape 
8d1d			if BASE_KEV 
8d1d					ld a, 255 
8d1d			else 
8d1d 3e 23				ld a, '#' 
8d1f			endif 
8d1f 77					ld (hl), a 
8d20 23					inc hl 
8d21 3e 00				ld a, 0 
8d23 77					ld (hl), a 
8d24			 
8d24 3e 09				ld a, CUR_BLINK_RATE 
8d26 32 60 ee				ld (input_cur_flash), a 
8d29 3e 01				ld a, 1 
8d2b 32 5f ee				ld (input_cur_onoff),a 
8d2e			.inmain:	 
8d2e			 
8d2e cd 63 8e				call input_disp_ref 
8d31			 
8d31					; save current length of string 
8d31			 
8d31 2a 67 ee				ld hl, (input_start) 
8d34 3e 00				ld a, 0 
8d36 cd 59 90				call strlent 
8d39 7d					ld a,l 
8d3a 32 5a ee				ld (input_len), a 
8d3d			 
8d3d					;call input_disp_oncur 
8d3d			 
8d3d					; display current state of input buffer 
8d3d			 
8d3d					; clean any backspace chars 
8d3d			 
8d3d 3e 20				ld a, " " 
8d3f 32 c1 e2				ld (scratch),a 
8d42 3e 00				ld a, 0 
8d44 32 c2 e2				ld (scratch+1),a 
8d47 3a 64 ee				ld a,(input_at_pos) 
8d4a 85					add l 
8d4b 11 c1 e2				ld de, scratch 
8d4e cd c1 8a				call str_at_display 
8d51			 
8d51					; pause 1ms 
8d51			 
8d51 3e 01				ld a, 1 
8d53 cd d6 89				call aDelayInMS 
8d56			 
8d56			; display cursor if visible on this cycle 
8d56			 
8d56					; dec flash counter 
8d56 3a 60 ee				ld a, (input_cur_flash) 
8d59 3d					dec a 
8d5a 32 60 ee				ld (input_cur_flash), a 
8d5d fe 00				cp 0 
8d5f 20 0d				jr nz, .inochgstate 
8d61			 
8d61			 
8d61					; reset on change of state 
8d61 3e 09				ld a, CUR_BLINK_RATE 
8d63 32 60 ee				ld (input_cur_flash), a 
8d66			 
8d66					; change state 
8d66 3a 5f ee				ld a,(input_cur_onoff) 
8d69 ed 44				neg 
8d6b 32 5f ee				ld (input_cur_onoff),a 
8d6e			 
8d6e			 
8d6e			 
8d6e			 
8d6e					; TODO is cursor visible? 
8d6e					; TODO if so then over write the char at curspos pos with the cursor shape 
8d6e			 
8d6e								 
8d6e			 
8d6e			.inochgstate: 
8d6e 3a 5f ee				ld a,(input_cur_onoff) 
8d71 fe ff				cp 255 
8d73 28 0e				jr z, .skipcursor 
8d75 3a 64 ee				ld a, (input_at_pos) 
8d78 47					ld b, a 
8d79 3a 55 ee				ld a, (input_cursor) 
8d7c 80					add b 
8d7d 11 c1 eb				ld de, cursor_shape 
8d80					 
8d80 cd c1 8a				call str_at_display 
8d83			 
8d83			.skipcursor: 
8d83				if DEBUG_INPUTV2 
8d83			 
8d83					ld a,(input_at_pos) 
8d83					ld hl, LFSRSeed 
8d83					call hexout 
8d83					ld a, (input_cursor) 
8d83					ld hl, LFSRSeed+2 
8d83					call hexout 
8d83					ld a,(input_size) 
8d83					ld hl, LFSRSeed+4 
8d83					call hexout 
8d83			 
8d83					ld a,(input_cur_onoff) 
8d83					ld hl, LFSRSeed+6 
8d83					call hexout 
8d83			 
8d83					ld a,(input_cur_flash) 
8d83					ld hl, LFSRSeed+8 
8d83					call hexout 
8d83			 
8d83					ld a,(input_len) 
8d83					ld hl, LFSRSeed+10 
8d83					call hexout 
8d83					ld hl, LFSRSeed+12 
8d83					ld a, 0 
8d83					ld (hl),a 
8d83					ld a, display_row_4 
8d83					ld de, LFSRSeed 
8d83					call str_at_display 
8d83				endif 
8d83 cd d1 8a				call update_display 
8d86			 
8d86					; TODO keyboard processing 
8d86			 
8d86			if BASE_CPM 
8d86					call cin_wait 
8d86			else 
8d86 cd ea e3				call cin    ; _wait 
8d89			endif 
8d89 fe 00				cp 0 
8d8b ca 2e 8d				jp z, .inmain 
8d8e			 
8d8e fe 0b				cp KEY_LEFT    ; cursor left 
8d90 ca 55 8e				jp z, input_left 
8d93				 
8d93 fe 0c				cp KEY_RIGHT      ; cursor right 
8d95 ca 5c 8e				jp z, input_right 
8d98			 
8d98 fe 0d				cp KEY_CR 
8d9a c8					ret z 
8d9b			 
8d9b fe 08				cp KEY_BS 
8d9d ca ca 8e				jp z, input_delchar 
8da0			 
8da0 fe 06				cp KEY_NEXTWORD 
8da2 ca d6 8d				jp z, input_nxtword 
8da5			 
8da5 fe 07				cp KEY_PREVWORD 
8da7 ca fd 8d				jp z, input_prvword 
8daa			 
8daa fe 0e				cp KEY_HOME    ; jump to start of line 
8dac 20 08				jr nz, .ikh 
8dae 3e 00				ld a, 0 
8db0 32 55 ee				ld (input_cursor), a 
8db3 ca 2e 8d				jp z, .inmain 
8db6			.ikh: 
8db6			 
8db6 fe 0f				cp KEY_END     ; jump to end of line 
8db8 20 09				jr nz, .ike 
8dba 3a 5a ee				ld a, (input_len) 
8dbd 32 55 ee				ld (input_cursor),a 
8dc0 ca 2e 8d				jp z, .inmain 
8dc3			.ike: 
8dc3 fe 05			        cp KEY_UP      ; recall last command 
8dc5 20 0c				jr nz, .irec 
8dc7			; TODO next word 
8dc7			; TODO prev word 
8dc7			;  
8dc7			; 
8dc7 21 c1 e2			ld hl, scratch 
8dca 11 e7 e6			ld de, os_last_cmd 
8dcd cd e7 8e			call strcpy 
8dd0 ca 2e 8d				jp z, .inmain 
8dd3			.irec: 
8dd3			;		jr .instr1 
8dd3			 
8dd3			 
8dd3					; if no special key then insert as a char 
8dd3			 
8dd3 c3 9c 8e				jp input_inschr 
8dd6			 
8dd6				 
8dd6			input_nxtword: 
8dd6				; jump to start next word after the cursor 
8dd6			 
8dd6			.insknwn:	 
8dd6 cd 92 8e				call input_curptr	 
8dd9 7e					ld a,(hl)	 
8dda fe 00				cp 0 
8ddc ca 2e 8d				jp z, .inmain    ; end of string 
8ddf			 
8ddf			; if we are on a word, then move off of it 
8ddf			 
8ddf fe 20				cp ' ' 
8de1 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8de3 21 55 ee				ld hl, input_cursor 
8de6 34					inc (hl) 
8de7 18 ed				jr .insknwn 
8de9			 
8de9			.inspace: 
8de9			 
8de9 cd 92 8e				call input_curptr	 
8dec 7e					ld a,(hl)	 
8ded fe 00				cp 0 
8def ca 2e 8d				jp z, .inmain    ; end of string 
8df2			 
8df2			; if we are on a word, then move off of it 
8df2			 
8df2 fe 20				cp ' ' 
8df4 c2 2e 8d				jp nz, .inmain     ; we are on non space so at next word 
8df7 21 55 ee				ld hl, input_cursor 
8dfa 34					inc (hl) 
8dfb 18 ec				jr .inspace 
8dfd			 
8dfd			 
8dfd			 
8dfd			 
8dfd			input_prvword: 
8dfd				; jump to the start of previous word before the cursor 
8dfd			 
8dfd			; where are we to start with currently? 
8dfd			 
8dfd cd 92 8e				call input_curptr	 
8e00 7e					ld a, (hl) 
8e01 fe 20				cp ' ' 
8e03 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e05			 
8e05			 
8e05			 
8e05			.inskpwn:	 
8e05 3a 55 ee				ld a,(input_cursor) 
8e08 fe 00				cp 0 
8e0a ca 2e 8d				jp z, .inmain    ; start of string 
8e0d			 
8e0d			;if we are on a word, then move off of it 
8e0d			 
8e0d cd 92 8e				call input_curptr	 
8e10 7e					ld a, (hl) 
8e11 fe 20				cp ' ' 
8e13 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8e15					;jp z, .inmain    ; start of string 
8e15 21 55 ee				ld hl, input_cursor 
8e18 35					dec (hl) 
8e19 18 ea				jr .inskpwn 
8e1b			.iwstart: 
8e1b 21 55 ee				ld hl, input_cursor 
8e1e 34					inc (hl) 
8e1f c3 2e 8d				jp .inmain 
8e22					 
8e22			 
8e22			.inspacep: 
8e22			 
8e22					;jp .inmain    ; start of string 
8e22			 
8e22			 
8e22			 
8e22 3a 55 ee				ld a,(input_cursor) 
8e25 fe 00				cp 0 
8e27 ca 2e 8d				jp z, .inmain    ; start of string 
8e2a			 
8e2a			; if we are on a word, then move off of it 
8e2a			 
8e2a cd 92 8e				call input_curptr	 
8e2d 7e					ld a, (hl) 
8e2e fe 20				cp ' ' 
8e30 c2 39 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e33 21 55 ee				ld hl, input_cursor 
8e36 35					dec (hl) 
8e37 18 e9				jr .inspacep 
8e39			 
8e39			 
8e39			.incharp:	 
8e39					; eat the word to get to the start 
8e39 3a 55 ee				ld a,(input_cursor) 
8e3c fe 00				cp 0 
8e3e ca 2e 8d				jp z, .inmain    ; start of string 
8e41			 
8e41			; if we are on a word, then move off of it 
8e41			 
8e41 cd 92 8e				call input_curptr	 
8e44 7e					ld a, (hl) 
8e45 fe 20				cp ' ' 
8e47 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e49 21 55 ee				ld hl, input_cursor 
8e4c 35					dec (hl) 
8e4d 18 ea				jr .incharp 
8e4f			.ipwordst: 
8e4f					; at space before the prev word so reposition over it 
8e4f 21 55 ee				ld hl, input_cursor 
8e52 34					inc (hl) 
8e53 18 b0				jr .inskpwn 
8e55					 
8e55			 
8e55			 
8e55			input_left: 
8e55				; move cursor left 
8e55 21 55 ee			ld hl, input_cursor 
8e58 35				dec (hl) 
8e59			;	cp 0 
8e59			;	jp z, .inmain    ; ignore left as at the start of the string 
8e59 c3 2e 8d			jp .inmain 
8e5c			 
8e5c			input_right: 
8e5c				; move cursor right 
8e5c				 
8e5c				;ld a, (input_size) 
8e5c				;ld b, a 
8e5c 21 55 ee			ld hl, input_cursor 
8e5f 34				inc (hl) 
8e60				;dec b 
8e60				;cp 0 
8e60				;jp z, .inmain   ; ignore as at end of the string buffer 
8e60				;ld a, b 
8e60				;inc a 
8e60				;ld (input_cursor), a 
8e60 c3 2e 8d			jp .inmain 
8e63			 
8e63			 
8e63			 
8e63			input_disp_ref: 
8e63				; display the text from start of buffer (ie full refresh) 
8e63 3a 64 ee			ld a, (input_at_pos) 
8e66 2a 67 ee			ld hl,(input_start) 
8e69 eb				ex de, hl 
8e6a cd c1 8a			call str_at_display  
8e6d c9				ret 
8e6e			input_disp_oncur: 
8e6e				; display the text from cursor position to end of buffer 
8e6e				; TODO position start of string at cursor position on screen 
8e6e				; TODO draw from that point on 
8e6e 3a 55 ee			ld a, (input_cursor) 
8e71 47				ld b, a 
8e72 3a 64 ee			ld a, (input_at_pos) 
8e75 80				add b 
8e76 48				ld c, b     ; save a 
8e77 78				ld a, b     ; inc string start for cursor 
8e78 2a 67 ee			ld hl,(input_start) 
8e7b cd db 8c			call addatohl 
8e7e eb				ex de, hl 
8e7f 79				ld a, c 
8e80 cd c1 8a			call str_at_display  
8e83 c9				ret 
8e84			 
8e84			input_nxtw: 
8e84				; Find next word 
8e84 c9				ret 
8e85			 
8e85			input_prvw: 
8e85				; Find previous word 
8e85 c9				ret 
8e86			 
8e86			input_lenrem:   
8e86				; Calculate the length of string remaining from current cursor 
8e86				; position to end of buffer (exc null term) 
8e86				 
8e86 3a 55 ee			ld a, (input_cursor) 
8e89 4f				ld c, a 
8e8a 3a 66 ee			ld a, (input_size) 
8e8d 91				sub c 
8e8e 06 00			ld b, 0 
8e90 0d				dec c 
8e91 c9				ret	 
8e92			 
8e92			input_curptr: 
8e92				; calc address of the character under the cursor 
8e92				 
8e92 2a 67 ee			ld hl, (input_start) 
8e95 3a 55 ee			ld a, (input_cursor) 
8e98 cd db 8c			call addatohl 
8e9b c9				ret 
8e9c			 
8e9c			input_inschr: 
8e9c				; Insert char at cursor position 
8e9c f5				push af   ; save char 
8e9d				;call input_lenrem    ; get bc length of remaining string 
8e9d			 
8e9d				 
8e9d cd 92 8e			call input_curptr 
8ea0			;	ld hl, (input_start) 
8ea0			;	ld a, (input_cursor) 
8ea0			;	call addatohl 
8ea0				;push hl   ; save to come back to 
8ea0			 
8ea0				; shift everything up one to end of buffer 
8ea0			 
8ea0				;push hl 
8ea0				;dec de 
8ea0				;inc de 
8ea0			;	ldir 
8ea0				 
8ea0				;pop hl 
8ea0			 
8ea0				; are we adding to the end of line? 
8ea0			 
8ea0 3a 55 ee			ld a, (input_cursor) 
8ea3 47				ld b, a 
8ea4 3a 5a ee			ld a, (input_len) 
8ea7 b8				cp b 
8ea8 20 09			jr nz, .insmid   ; no, insert in middle of text 
8eaa			 
8eaa				; tack on the end of the line 
8eaa f1				pop af 
8eab 77				ld (hl), a   ; save new char 
8eac 23				inc hl 
8ead 3e 00			ld a, 0 
8eaf 77				ld (hl), a 
8eb0 c3 5c 8e			jp input_right 
8eb3				 
8eb3			.insmid: 
8eb3				; hl has insertion point so move everything up one to allow for insertion 
8eb3				;call input_shiftright 
8eb3 f1				pop af 
8eb4			 
8eb4			.shufinsmid: 
8eb4 47				ld b, a     ; b contains new char, c prev char at this position  
8eb5 7e				ld a, (hl) 
8eb6			 
8eb6 fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eb8 28 07			jr z, .endinsmid 
8eba 4f				ld c, a 
8ebb 78				ld a, b 
8ebc 77				ld (hl), a 
8ebd 23				inc hl 
8ebe 79				ld a, c 
8ebf 18 f3			jr .shufinsmid 
8ec1				 
8ec1			 
8ec1			 
8ec1			 
8ec1			.endinsmid: 
8ec1 78				ld a, b 
8ec2 77				ld (hl), a 
8ec3 23				inc hl 
8ec4 3e 00			ld a, 0 
8ec6 77				ld (hl), a 
8ec7			 
8ec7			 
8ec7			;	ld (hl), a   ; save new char 
8ec7			 
8ec7 c3 5c 8e			jp input_right 
8eca			 
8eca			;input_shiftright: 
8eca			;	; shift text right at cursor, hl has shift start 
8eca			;	push hl 
8eca			;	push de 
8eca			;	push bc 
8eca			; 
8eca			; 
8eca			;	; move to end of string past zero term 
8eca			;	ld hl,(input_start) 
8eca			;	ld a, (input_len) 
8eca			;	call addatohl 
8eca			;	inc hl 
8eca			;;	inc hl 
8eca			;;	inc hl 
8eca			;	ld a, 0 
8eca			;	ld (hl), a 
8eca			;;	dec hl 
8eca			;	 
8eca			;;	ld (hl), a 
8eca			;;	dec hl 
8eca			; 
8eca			;	push hl 
8eca			;	pop de 
8eca			;	inc de 
8eca			;	 
8eca			; 
8eca			;;	ld hl,(input_start) 
8eca			;;	ld a, (input_cursor) 
8eca			;;	call addatohl 
8eca			; 
8eca			; 
8eca			;	; calc how many bytes from cursor pos to end of string we need to shift 
8eca			;	call input_lenrem    ; get bc length of remaining string 
8eca			;	;ld a, (input_cursor) 
8eca			;	;ld c, a 
8eca			;	ld a, (input_len) 
8eca			;	cp 2 
8eca			;	jr z, .iskipzero	 
8eca			;	;sub c 
8eca			;	;inc a 
8eca			;	;ld c, a 
8eca			;	;ld b, 0 
8eca			;	inc c 
8eca			;	inc c 
8eca			;	; move data 
8eca			;	lddr 
8eca			;.iskipzero: 
8eca			; 
8eca			;	pop bc 
8eca			;	pop de 
8eca			;	pop hl 
8eca			;	ret	 
8eca			 
8eca			input_delchar: 
8eca				; Delete char at cursor position 
8eca cd 86 8e			call input_lenrem    ; get bc length of remaining string 
8ecd 2a 67 ee			ld hl, (input_start) 
8ed0 3a 55 ee			ld a, (input_cursor) 
8ed3 cd db 8c			call addatohl 
8ed6			 
8ed6 e5				push hl 
8ed7 d1				pop de 
8ed8 1b				dec de 
8ed9			 
8ed9			.dl:	 
8ed9 ed a0			ldi  
8edb 7e				ld a, (hl) 
8edc fe 00			cp 0 
8ede 28 02			jr z, .dldone 
8ee0 18 f7			jr .dl 
8ee2			.dldone: 
8ee2 ed a0			ldi 
8ee4			 
8ee4 c3 55 8e			jp input_left 
8ee7			 
8ee7			 
8ee7			endif 
8ee7			 
8ee7			 
8ee7			 
8ee7			if EDIT_V1 
8ee7			input_str: 
8ee7			 
8ee7				    	ld (input_at_pos),a      ; save display position to start 
8ee7					add c 
8ee7					ld (input_at_cursor),a	; save draw pos of cursor 
8ee7					ld (input_start), hl     ; save ptr to buffer 
8ee7					ld a, c 
8ee7					call addatohl 
8ee7					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ee7					ld a,d 
8ee7				        ld (input_size), a       ; save length of input area 
8ee7					ld a, c 
8ee7					ld (input_cursor),a      ; init cursor start position  
8ee7					ld a,e 
8ee7				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ee7					 
8ee7					 
8ee7			 
8ee7			;		ld a,(input_ptr) 
8ee7			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ee7			 
8ee7			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ee7					; init cursor shape if not set by the cin routines 
8ee7					ld hl, cursor_shape 
8ee7			if BASE_KEV 
8ee7					ld a, 255 
8ee7			else 
8ee7					ld a, '#' 
8ee7			endif 
8ee7					ld (hl), a 
8ee7					inc hl 
8ee7					ld a, 0 
8ee7					ld (hl), a 
8ee7			 
8ee7					ld a, CUR_BLINK_RATE 
8ee7					ld (input_cur_flash), a 
8ee7					ld a, 1 
8ee7					ld (input_cur_onoff),a 
8ee7			 
8ee7			;	if DEBUG_INPUT 
8ee7			;		push af 
8ee7			;		ld a, 'I' 
8ee7			;		ld (debug_mark),a 
8ee7			;		pop af 
8ee7			;		CALLMONITOR 
8ee7			;	endif 
8ee7			.is1:		; main entry loop 
8ee7			 
8ee7			 
8ee7			 
8ee7					; pause 1ms 
8ee7			 
8ee7					ld a, 1 
8ee7					call aDelayInMS 
8ee7			 
8ee7					; dec flash counter 
8ee7					ld a, (input_cur_flash) 
8ee7					dec a 
8ee7					ld (input_cur_flash), a 
8ee7					cp 0 
8ee7					jr nz, .nochgstate 
8ee7			 
8ee7			 
8ee7					; change state 
8ee7					ld a,(input_cur_onoff) 
8ee7					neg 
8ee7					ld (input_cur_onoff),a 
8ee7			 
8ee7			 
8ee7					; reset on change of state 
8ee7					ld a, CUR_BLINK_RATE 
8ee7					ld (input_cur_flash), a 
8ee7			 
8ee7			.nochgstate: 
8ee7					 
8ee7					 
8ee7			 
8ee7					; display cursor  
8ee7			 
8ee7			;		ld hl, (input_start) 
8ee7			;		ld a, (input_cursor) 
8ee7			;		call addatohl 
8ee7			 
8ee7					; get char under cursor and replace with cursor 
8ee7			ld hl, (input_ptr) 
8ee7			;		ld a, (hl) 
8ee7			;		ld (input_under_cursor),a 
8ee7			;		ld a, '_' 
8ee7			;		ld (hl), a 
8ee7			 
8ee7					; display string 
8ee7			 
8ee7					ld de, (input_start) 
8ee7					ld a, (input_at_pos) 
8ee7					call str_at_display 
8ee7			;	        call update_display 
8ee7			 
8ee7					; find place to put the cursor 
8ee7			;		add h 
8ee7			;		ld l, display_row_1 
8ee7			;		sub l 
8ee7			; (input_at_pos) 
8ee7					;ld c, a 
8ee7			;		ld a, (input_cursor) 
8ee7			;		ld l, (input_at_pos) 
8ee7			;		;ld b, h 
8ee7			;		add l 
8ee7			;		ld (input_at_cursor),a 
8ee7					;ld l,h 
8ee7			 
8ee7			;		ld h, 0 
8ee7			;		ld l,(input_at_pos) 
8ee7			;		ld a, (input_cursor) 
8ee7			;		call addatohl 
8ee7			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ee7			;		call subafromhl 
8ee7			;		ld a,l 
8ee7			;		ld (input_at_cursor), a 
8ee7			 
8ee7				if DEBUG_INPUT 
8ee7					ld a, (hardware_diag) 
8ee7					cp 0 
8ee7					jr z, .skip_input_diag 
8ee7			 
8ee7					ld a,(input_at_pos) 
8ee7					ld hl, LFSRSeed 
8ee7					call hexout 
8ee7					ld a, (input_cursor) 
8ee7					ld hl, LFSRSeed+2 
8ee7					call hexout 
8ee7					ld a,(input_at_cursor) 
8ee7					ld hl, LFSRSeed+4 
8ee7					call hexout 
8ee7			 
8ee7					ld a,(input_cur_onoff) 
8ee7					ld hl, LFSRSeed+6 
8ee7					call hexout 
8ee7			 
8ee7					ld a,(input_cur_flash) 
8ee7					ld hl, LFSRSeed+8 
8ee7					call hexout 
8ee7			 
8ee7					ld a,(input_len) 
8ee7					ld hl, LFSRSeed+10 
8ee7					call hexout 
8ee7					ld hl, LFSRSeed+12 
8ee7					ld a, 0 
8ee7					ld (hl),a 
8ee7					ld a, display_row_4 
8ee7					ld de, LFSRSeed 
8ee7					call str_at_display 
8ee7					.skip_input_diag: 
8ee7				endif 
8ee7			 
8ee7					; decide on if we are showing the cursor this time round 
8ee7			 
8ee7					ld a, (input_cur_onoff) 
8ee7					cp 255 
8ee7					jr z, .skipcur 
8ee7			 
8ee7			 
8ee7					ld a,(input_at_cursor) 
8ee7					ld de, cursor_shape 
8ee7					call str_at_display 
8ee7			 
8ee7					; save length of current input string 
8ee7					ld hl, (input_start) 
8ee7					ld a, 0 
8ee7					call strlent 
8ee7					ld a,l 
8ee7					ld (input_len),a 
8ee7			 
8ee7			.skipcur: 
8ee7			 
8ee7				        call update_display 
8ee7					 
8ee7			 
8ee7			 
8ee7					; wait 
8ee7				 
8ee7					; TODO loop without wait to flash the cursor and char under cursor	 
8ee7					call cin    ; _wait 
8ee7			 
8ee7					cp 0 
8ee7					jp z, .is1 
8ee7			 
8ee7					; get ptr to char to input into 
8ee7			 
8ee7					ld c,a 
8ee7					ld hl, (input_start) 
8ee7					ld a, (input_cursor) 
8ee7					call addatohl 
8ee7					ld (input_ptr), hl 
8ee7					ld a,c 
8ee7			 
8ee7					; replace char under cursor 
8ee7			 
8ee7			;		ld hl, (input_ptr) 
8ee7			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ee7			;		ld (hl), a 
8ee7			 
8ee7			;	if DEBUG_INPUT 
8ee7			;		push af 
8ee7			;		ld a, 'i' 
8ee7			;		ld (debug_mark),a 
8ee7			;		pop af 
8ee7			;		CALLMONITOR 
8ee7			;	endif 
8ee7					cp KEY_HOME 
8ee7					jr nz, .iske 
8ee7			 
8ee7					ld a, (input_at_pos) 
8ee7					ld (input_at_cursor),a 
8ee7					ld a, 0 
8ee7					ld (input_cursor), a 
8ee7					jp .is1 
8ee7					 
8ee7			.iske:		cp KEY_END 
8ee7					jr nz, .isknw 
8ee7					jp .is1 
8ee7			 
8ee7			.isknw:		cp KEY_NEXTWORD 
8ee7					jr nz, .iskpw 
8ee7			 
8ee7			.isknwm:	ld hl, (input_ptr) 
8ee7					ld a,(hl)	 
8ee7					cp 0 
8ee7					jp z, .is1    ; end of string 
8ee7					cp ' ' 
8ee7					jp z, .is1    ; end of word 
8ee7					inc hl 
8ee7					ld (input_ptr), hl 
8ee7					ld a, (input_at_cursor) 
8ee7					inc a 
8ee7					ld (input_at_cursor), a 
8ee7					jr .isknwm 
8ee7			 
8ee7			.iskpw:		cp KEY_PREVWORD 
8ee7					jr nz, .iskl 
8ee7			.iskpwm:	 
8ee7					ld hl, (input_ptr) 
8ee7					ld a,(hl)	 
8ee7					cp 0  
8ee7					jp z, .is1    ; end of string 
8ee7					cp ' ' 
8ee7					jp z, .is1    ; end of word 
8ee7					dec hl 
8ee7					ld (input_ptr), hl 
8ee7					ld a, (input_at_cursor) 
8ee7					dec a 
8ee7					ld (input_at_cursor), a 
8ee7					jr .iskpwm 
8ee7			 
8ee7			 
8ee7			.iskl:		cp KEY_LEFT 
8ee7					jr nz, .isk1 
8ee7			 
8ee7					ld a, (input_cursor) 
8ee7			 
8ee7					cp 0 
8ee7					jp z, .is1 		; at start of line to ignore  
8ee7			 
8ee7					dec  a 		; TODO check underflow 
8ee7					ld (input_cursor), a 
8ee7			 
8ee7					ld hl, (input_ptr) 
8ee7					dec hl 
8ee7					ld (input_ptr), hl 
8ee7					 
8ee7					ld a, (input_at_cursor) 
8ee7					dec a 
8ee7					ld (input_at_cursor), a 
8ee7			 
8ee7					ld a, 1		; show cursor moving 
8ee7					ld (input_cur_onoff),a 
8ee7					ld a, CUR_BLINK_RATE 
8ee7					ld (input_cur_flash), a 
8ee7			 
8ee7					jp .is1 
8ee7			 
8ee7			.isk1:		cp KEY_RIGHT 
8ee7					jr nz, .isk2 
8ee7			 
8ee7					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ee7					ld e,a 
8ee7					ld a, (input_cursor) 
8ee7					cp e 
8ee7					jp z, .is1		; at the end of string so dont go right 
8ee7			 
8ee7					inc  a 		; TODO check overflow 
8ee7					ld (input_cursor), a 
8ee7			 
8ee7					ld a, (input_at_cursor) 
8ee7					inc a 
8ee7					ld (input_at_cursor), a 
8ee7			 
8ee7					ld hl, (input_ptr) 
8ee7					inc hl 
8ee7					ld (input_ptr), hl 
8ee7			 
8ee7					ld a, 1		; show cursor moving 
8ee7					ld (input_cur_onoff),a 
8ee7					ld a, CUR_BLINK_RATE 
8ee7					ld (input_cur_flash), a 
8ee7			 
8ee7					jp .is1 
8ee7			 
8ee7			.isk2:		cp KEY_UP 
8ee7			 
8ee7					jr nz, .isk3 
8ee7			 
8ee7					; swap last command with the current on 
8ee7			 
8ee7					; move cursor to start of string 
8ee7					ld hl, (input_start) 
8ee7					ld (input_ptr), hl 
8ee7			 
8ee7					ld a, (input_at_pos) 
8ee7					ld (input_at_cursor), a 
8ee7			 
8ee7					ld a, 0 
8ee7					ld (input_cursor), a 
8ee7					 
8ee7					; swap input and last command buffers 
8ee7			 
8ee7					ld hl, os_cli_cmd 
8ee7					ld de, os_last_cmd 
8ee7					ld b, 255 
8ee7			.swap1:		ld a, (hl) 
8ee7					ld c,a 
8ee7					ld a, (de) 
8ee7					ld (hl), a 
8ee7					ld a,c 
8ee7					ld (de),a 
8ee7					inc hl 
8ee7					inc de 
8ee7					djnz .swap1 
8ee7			 
8ee7			 
8ee7			 
8ee7			 
8ee7			 
8ee7					jp .is1 
8ee7			 
8ee7			.isk3:		cp KEY_BS 
8ee7					jr nz, .isk4 
8ee7			 
8ee7					ld a, (input_cursor) 
8ee7			 
8ee7					cp 0 
8ee7					jp z, .is1 		; at start of line to ignore  
8ee7			 
8ee7					dec  a 		; TODO check underflow 
8ee7					ld (input_cursor), a 
8ee7			 
8ee7					; hl is source 
8ee7					; de needs to be source - 1 
8ee7			 
8ee7			;		ld a, 0 
8ee7			;		dec hl 
8ee7			;		ld (hl), a 
8ee7			 
8ee7					ld hl, (input_ptr) 
8ee7					dec hl 
8ee7					ld (input_ptr), hl 
8ee7			 
8ee7					; shift all data 
8ee7			 
8ee7					push hl 
8ee7					inc hl 
8ee7					pop de 
8ee7					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ee7					ld c,a 
8ee7					ld b,0 
8ee7					ldir  
8ee7			 
8ee7			 
8ee7			 
8ee7			 
8ee7					ld a, (input_at_cursor) 
8ee7					dec a 
8ee7					ld (input_at_cursor), a 
8ee7			 
8ee7			 
8ee7					ld a, 1		; show cursor moving 
8ee7					ld (input_cur_onoff),a 
8ee7					ld a, CUR_BLINK_RATE 
8ee7					ld (input_cur_flash), a 
8ee7			 
8ee7					; remove char 
8ee7					ld a, (input_at_cursor) 
8ee7					inc a 
8ee7					ld de,.iblank 
8ee7					call str_at_display 
8ee7			 
8ee7					jp .is1 
8ee7			 
8ee7			.isk4:		cp KEY_CR 
8ee7					jr z, .endinput 
8ee7			 
8ee7					; else add the key press to the end 
8ee7			 
8ee7					ld c, a			; save key pressed 
8ee7			 
8ee7					ld a,(hl)		; get what is currently under char 
8ee7			 
8ee7					cp 0			; we are at the end of the string 
8ee7					jr nz, .onchar 
8ee7					 
8ee7					; add a char to the end of the string 
8ee7				 
8ee7					ld (hl),c 
8ee7					inc hl 
8ee7			;		ld a,' ' 
8ee7			;		ld (hl),a 
8ee7			;		inc hl 
8ee7					ld a,0 
8ee7					ld (hl),a 
8ee7					dec hl 
8ee7			 
8ee7					ld a, (input_cursor) 
8ee7					inc a				; TODO check max string length and scroll  
8ee7					ld (input_cursor), a		; inc cursor pos 
8ee7							 
8ee7					ld a, (input_at_cursor) 
8ee7					inc a 
8ee7					ld (input_at_cursor), a 
8ee7			 
8ee7					ld hl, (input_ptr) 
8ee7					inc hl 
8ee7					ld (input_ptr), hl 
8ee7			 
8ee7					ld hl, (input_ptr) 
8ee7					inc hl 
8ee7					ld (input_ptr), hl 
8ee7			;	if DEBUG_INPUT 
8ee7			;		push af 
8ee7			;		ld a, '+' 
8ee7			;		ld (debug_mark),a 
8ee7			;		pop af 
8ee7			;		CALLMONITOR 
8ee7			;	endif 
8ee7					ld a, 1		; show cursor moving 
8ee7					ld (input_cur_onoff),a 
8ee7					ld a, CUR_BLINK_RATE 
8ee7					ld (input_cur_flash), a 
8ee7					jp .is1 
8ee7					 
8ee7			 
8ee7			 
8ee7					; if on a char then insert 
8ee7			.onchar: 
8ee7			 
8ee7					; TODO over flow check: make sure insert does not blow out buffer 
8ee7			 
8ee7					; need to do some maths to use lddr 
8ee7			 
8ee7					push hl   ; save char pos 
8ee7					push bc 
8ee7			 
8ee7					ld hl, (input_start) 
8ee7					ld a, (input_len) 
8ee7					call addatohl  		; end of string 
8ee7					inc hl 
8ee7					inc hl		; past zero term 
8ee7					push hl 
8ee7					inc hl 
8ee7					push hl  
8ee7			 
8ee7								; start and end of lddr set, now how much to move? 
8ee7			 
8ee7							 
8ee7					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ee7					ld b,a 
8ee7					ld a,(input_len) 
8ee7					ld e,a 
8ee7					sub b 
8ee7					inc a		;?? 
8ee7					inc a		;?? 
8ee7					inc a		;?? 
8ee7			 
8ee7					ld b,0 
8ee7					ld c,a 
8ee7			 
8ee7				if DEBUG_INPUT 
8ee7					push af 
8ee7					ld a, 'i' 
8ee7					ld (debug_mark),a 
8ee7					pop af 
8ee7			;		CALLMONITOR 
8ee7				endif 
8ee7					pop de 
8ee7					pop hl 
8ee7				if DEBUG_INPUT 
8ee7					push af 
8ee7					ld a, 'I' 
8ee7					ld (debug_mark),a 
8ee7					pop af 
8ee7			;		CALLMONITOR 
8ee7				endif 
8ee7					lddr 
8ee7				 
8ee7			 
8ee7			 
8ee7					; TODO have a key for insert/overwrite mode???? 
8ee7					pop bc 
8ee7					pop hl 
8ee7					ld (hl), c		; otherwise overwrite current char 
8ee7					 
8ee7			 
8ee7			 
8ee7			 
8ee7					ld a, (input_cursor) 
8ee7					inc  a 		; TODO check overflow 
8ee7					ld (input_cursor), a 
8ee7			 
8ee7					ld a, (input_at_cursor) 
8ee7					inc a 
8ee7					ld (input_at_cursor), a 
8ee7			 
8ee7					jp .is1 
8ee7			 
8ee7			.endinput:	; TODO look for end of string 
8ee7			 
8ee7					; add trailing space for end of token 
8ee7			 
8ee7					ld hl, (input_start) 
8ee7					ld a,(input_len) 
8ee7					call addatohl 
8ee7					ld a, ' ' 
8ee7					ld (hl),a 
8ee7					; TODO eof of parse marker 
8ee7			 
8ee7					inc hl 
8ee7					ld a, 0 
8ee7					ld (hl),a 
8ee7			 
8ee7			 
8ee7					ret 
8ee7			 
8ee7			.iblank: db " ",0 
8ee7			 
8ee7			 
8ee7			input_str_prev:	ld (input_at_pos), a 
8ee7					ld (input_start), hl 
8ee7					ld a,1			; add cursor 
8ee7					ld (hl),a 
8ee7					inc hl 
8ee7					ld a,0 
8ee7					ld (hl),a 
8ee7					ld (input_ptr), hl 
8ee7					ld a,d 
8ee7					ld (input_size), a 
8ee7					ld a,0 
8ee7					ld (input_cursor),a 
8ee7			.instr1:	 
8ee7			 
8ee7					; TODO do block cursor 
8ee7					; TODO switch cursor depending on the modifer key 
8ee7			 
8ee7					; update cursor shape change on key hold 
8ee7			 
8ee7					ld hl, (input_ptr) 
8ee7					dec hl 
8ee7					ld a,(cursor_shape) 
8ee7					ld (hl), a 
8ee7			 
8ee7					; display entered text 
8ee7					ld a,(input_at_pos) 
8ee7			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ee7			            	LD   de, (input_start) 
8ee7			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ee7			 
8ee7					call cin 
8ee7					cp 0 
8ee7					jr z, .instr1 
8ee7			 
8ee7					; proecess keyboard controls first 
8ee7			 
8ee7					ld hl,(input_ptr) 
8ee7			 
8ee7					cp KEY_CR	 ; pressing enter ends input 
8ee7					jr z, .instrcr 
8ee7			 
8ee7					cp KEY_BS 	; back space 
8ee7					jr nz, .instr2 
8ee7					; process back space 
8ee7			 
8ee7					; TODO stop back space if at start of string 
8ee7					dec hl 
8ee7					dec hl ; to over write cursor 
8ee7					ld a,(cursor_shape) 
8ee7					;ld a,0 
8ee7					ld (hl),a 
8ee7					inc hl 
8ee7					ld a," " 
8ee7					ld (hl),a 
8ee7					ld (input_ptr),hl 
8ee7					 
8ee7			 
8ee7					jr .instr1 
8ee7			 
8ee7			.instr2:	cp KEY_LEFT    ; cursor left 
8ee7					jr nz, .instr3 
8ee7					dec hl 
8ee7					ld (input_ptr),hl 
8ee7					jr .instr1 
8ee7				 
8ee7			.instr3:	cp KEY_RIGHT      ; cursor right 
8ee7					jr nz, .instr4 
8ee7					inc hl 
8ee7					ld (input_ptr),hl 
8ee7					jr .instr1 
8ee7			 
8ee7			.instr4:	cp KEY_HOME    ; jump to start of line 
8ee7					jr nz, .instr5 
8ee7					dec hl 
8ee7					ld (input_ptr),hl 
8ee7					jr .instr1 
8ee7			 
8ee7			.instr5:	cp KEY_END     ; jump to end of line 
8ee7					jr nz, .instr6 
8ee7					dec hl 
8ee7					ld (input_ptr),hl 
8ee7					jr .instr1 
8ee7			.instr6:        cp KEY_UP      ; recall last command 
8ee7					jr nz, .instrnew 
8ee7			 
8ee7				ld hl, scratch 
8ee7				ld de, os_last_cmd 
8ee7				call strcpy 
8ee7					jr .instr1 
8ee7			 
8ee7			 
8ee7			.instrnew:	; no special key pressed to see if we have room to store it 
8ee7			 
8ee7					; TODO do string size test 
8ee7			 
8ee7					dec hl ; to over write cursor 
8ee7					ld (hl),a 
8ee7					inc hl 
8ee7					ld a,(cursor_shape) 
8ee7					ld (hl),a 
8ee7					inc hl 
8ee7					ld a,0 
8ee7					ld (hl),a 
8ee7			 
8ee7					ld (input_ptr),hl 
8ee7					 
8ee7					jr .instr1 
8ee7			.instrcr:	dec hl		; remove cursor 
8ee7					ld a,' '	; TODO add a trailing space for safety 
8ee7					ld (hl),a 
8ee7					inc hl 
8ee7					ld a,0 
8ee7					ld (hl),a 
8ee7			 
8ee7			 
8ee7					; if at end of line scroll up    
8ee7					; TODO detecting only end of line 4 for scroll up  
8ee7			 
8ee7					;ld   
8ee7			 
8ee7					ret 
8ee7			 
8ee7			 
8ee7			endif 
8ee7			; strcpy hl = dest, de source 
8ee7			 
8ee7 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8ee8 b7			            OR   A              ;Null terminator? 
8ee9 c8			            RET  Z              ;Yes, so finished 
8eea 1a					ld a,(de) 
8eeb 77					ld (hl),a 
8eec 13			            INC  DE             ;Point to next character 
8eed 23					inc hl 
8eee 18 f7		            JR   strcpy       ;Repeat 
8ef0 c9					ret 
8ef1			 
8ef1			 
8ef1			; TODO string_at  
8ef1			; pass string which starts with lcd offset address and then null term string 
8ef1			 
8ef1			; TODO string to dec 
8ef1			; TODO string to hex 
8ef1			; TODO byte to string hex 
8ef1			; TODO byte to string dec 
8ef1			 
8ef1			 
8ef1			 
8ef1			; from z80uartmonitor 
8ef1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef1			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ef1			; pass hl for where to put the text 
8ef1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ef1 c5			hexout:	PUSH BC 
8ef2 f5					PUSH AF 
8ef3 47					LD B, A 
8ef4					; Upper nybble 
8ef4 cb 3f				SRL A 
8ef6 cb 3f				SRL A 
8ef8 cb 3f				SRL A 
8efa cb 3f				SRL A 
8efc cd 0c 8f				CALL tohex 
8eff 77					ld (hl),a 
8f00 23					inc hl	 
8f01					 
8f01					; Lower nybble 
8f01 78					LD A, B 
8f02 e6 0f				AND 0FH 
8f04 cd 0c 8f				CALL tohex 
8f07 77					ld (hl),a 
8f08 23					inc hl	 
8f09					 
8f09 f1					POP AF 
8f0a c1					POP BC 
8f0b c9					RET 
8f0c					 
8f0c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0c			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8f0c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f0c			tohex: 
8f0c e5					PUSH HL 
8f0d d5					PUSH DE 
8f0e 16 00				LD D, 0 
8f10 5f					LD E, A 
8f11 21 19 8f				LD HL, .DATA 
8f14 19					ADD HL, DE 
8f15 7e					LD A, (HL) 
8f16 d1					POP DE 
8f17 e1					POP HL 
8f18 c9					RET 
8f19			 
8f19			.DATA: 
8f19 30					DEFB	30h	; 0 
8f1a 31					DEFB	31h	; 1 
8f1b 32					DEFB	32h	; 2 
8f1c 33					DEFB	33h	; 3 
8f1d 34					DEFB	34h	; 4 
8f1e 35					DEFB	35h	; 5 
8f1f 36					DEFB	36h	; 6 
8f20 37					DEFB	37h	; 7 
8f21 38					DEFB	38h	; 8 
8f22 39					DEFB	39h	; 9 
8f23 41					DEFB	41h	; A 
8f24 42					DEFB	42h	; B 
8f25 43					DEFB	43h	; C 
8f26 44					DEFB	44h	; D 
8f27 45					DEFB	45h	; E 
8f28 46					DEFB	46h	; F 
8f29			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f29			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f29			;;    subtract $30, if result > 9 then subtract $7 more 
8f29			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f29			atohex: 
8f29 d6 30				SUB $30 
8f2b fe 0a				CP 10 
8f2d f8					RET M		; If result negative it was 0-9 so we're done 
8f2e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f30 c9					RET		 
8f31			 
8f31			 
8f31			 
8f31			 
8f31			; Get 2 ASCII characters as hex byte from pointer in hl 
8f31			 
8f31			BYTERD: 
8f31 16 00			LD	D,00h		;Set up 
8f33 cd 3b 8f			CALL	HEXCON		;Get byte and convert to hex 
8f36 87				ADD	A,A		;First nibble so 
8f37 87				ADD	A,A		;multiply by 16 
8f38 87				ADD	A,A		; 
8f39 87				ADD	A,A		; 
8f3a 57				LD	D,A		;Save hi nibble in D 
8f3b			HEXCON: 
8f3b 7e				ld a, (hl)		;Get next chr 
8f3c 23				inc hl 
8f3d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f3f fe 0a			CP	00Ah		;Is it 0-9 ? 
8f41 38 02			JR	C,NALPHA	;If so miss next bit 
8f43 d6 07			SUB	007h		;Else convert alpha 
8f45			NALPHA: 
8f45 b2				OR	D		;Add hi nibble back 
8f46 c9				RET			; 
8f47			 
8f47			 
8f47			; 
8f47			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f47			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f47			; characters (0-9a-f) are accepted. 
8f47			; 
8f47			;get_word        push    af 
8f47			;                call    get_byte        ; Get the upper byte 
8f47			;                ld      h, a 
8f47			;                call    get_byte        ; Get the lower byte 
8f47			;                ld      l, a 
8f47			;                pop     af 
8f47			;                ret 
8f47			; 
8f47			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f47			; the routine get_nibble is used only valid characters are accepted - the  
8f47			; input routine only accepts characters 0-9a-f. 
8f47			; 
8f47 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f48 7e					ld a,(hl) 
8f49 23					inc hl 
8f4a cd 6f 8f		                call    nibble2val      ; Get upper nibble 
8f4d cb 07		                rlc     a 
8f4f cb 07		                rlc     a 
8f51 cb 07		                rlc     a 
8f53 cb 07		                rlc     a 
8f55 47			                ld      b, a            ; Save upper four bits 
8f56 7e					ld a,(hl) 
8f57 cd 6f 8f		                call    nibble2val      ; Get lower nibble 
8f5a b0			                or      b               ; Combine both nibbles 
8f5b c1			                pop     bc              ; Restore B (and C) 
8f5c c9			                ret 
8f5d			; 
8f5d			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f5d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f5d			; to the serial line interface. The lower 4 bits of A contain the value of  
8f5d			; that particular digit. 
8f5d			; 
8f5d			;get_nibble      ld a,(hl)           ; Read a character 
8f5d			;                call    to_upper        ; Convert to upper case 
8f5d			;                call    is_hex          ; Was it a hex digit? 
8f5d			;                jr      nc, get_nibble  ; No, get another character 
8f5d			 ;               call    nibble2val      ; Convert nibble to value 
8f5d			 ;               call    print_nibble 
8f5d			 ;               ret 
8f5d			; 
8f5d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f5d			; A valid hexadecimal digit is denoted by a set C flag. 
8f5d			; 
8f5d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f5d			;                ret     nc              ; Yes 
8f5d			;                cp      '0'             ; Less than '0'? 
8f5d			;                jr      nc, is_hex_1    ; No, continue 
8f5d			;                ccf                     ; Complement carry (i.e. clear it) 
8f5d			;                ret 
8f5d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f5d			;                ret     c               ; Yes 
8f5d			;                cp      'A'             ; Less than 'A'? 
8f5d			;                jr      nc, is_hex_2    ; No, continue 
8f5d			;                ccf                     ; Yes - clear carry and return 
8f5d			;                ret 
8f5d			;is_hex_2        scf                     ; Set carry 
8f5d			;                ret 
8f5d			; 
8f5d			; Convert a single character contained in A to upper case: 
8f5d			; 
8f5d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f5f d8			                ret     c 
8f60 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f62 d0			                ret     nc              ; Nothing to do, either 
8f63 e6 5f		                and     $5f             ; Convert to upper case 
8f65 c9			                ret 
8f66			 
8f66			 
8f66			to_lower: 
8f66			 
8f66			   ; if char is in [A-Z] make it lower case 
8f66			 
8f66			   ; enter : a = char 
8f66			   ; exit  : a = lower case char 
8f66			   ; uses  : af 
8f66			 
8f66 fe 41		   cp 'A' 
8f68 d8			   ret c 
8f69			    
8f69 fe 5b		   cp 'Z'+1 
8f6b d0			   ret nc 
8f6c			    
8f6c f6 20		   or $20 
8f6e c9			   ret 
8f6f			 
8f6f			; 
8f6f			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f6f			; corresponding value in A. 
8f6f			; 
8f6f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f71 38 02		                jr      c, nibble2val_1 ; Yes 
8f73 d6 07		                sub     7               ; Adjust for A-F 
8f75 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f77 e6 0f		                and     $f              ; Only return lower 4 bits 
8f79 c9			                ret 
8f7a			; 
8f7a			; Print_nibble prints a single hex nibble which is contained in the lower  
8f7a			; four bits of A: 
8f7a			; 
8f7a			;print_nibble    push    af              ; We won't destroy the contents of A 
8f7a			;                and     $f              ; Just in case... 
8f7a			;                add     a, '0'             ; If we have a digit we are done here. 
8f7a			;                cp      '9' + 1         ; Is the result > 9? 
8f7a			;                jr      c, print_nibble_1 
8f7a			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f7a			;print_nibble_1  call    putc            ; Print the nibble and 
8f7a			;                pop     af              ; restore the original value of A 
8f7a			;                ret 
8f7a			;; 
8f7a			;; Send a CR/LF pair: 
8f7a			; 
8f7a			;crlf            push    af 
8f7a			;                ld      a, cr 
8f7a			;                call    putc 
8f7a			;                ld      a, lf 
8f7a			;                call    putc 
8f7a			;                pop     af 
8f7a			;                ret 
8f7a			; 
8f7a			; Print_word prints the four hex digits of a word to the serial line. The  
8f7a			; word is expected to be in HL. 
8f7a			; 
8f7a			;print_word      push    hl 
8f7a			;                push    af 
8f7a			;                ld      a, h 
8f7a			;                call    print_byte 
8f7a			;                ld      a, l 
8f7a			;                call    print_byte 
8f7a			;                pop     af 
8f7a			;                pop     hl 
8f7a			;                ret 
8f7a			; 
8f7a			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f7a			; The byte to be printed is expected to be in A. 
8f7a			; 
8f7a			;print_byte      push    af              ; Save the contents of the registers 
8f7a			;                push    bc 
8f7a			;                ld      b, a 
8f7a			;                rrca 
8f7a			;                rrca 
8f7a			;                rrca 
8f7a			;                rrca 
8f7a			;                call    print_nibble    ; Print high nibble 
8f7a			;                ld      a, b 
8f7a			;                call    print_nibble    ; Print low nibble 
8f7a			;                pop     bc              ; Restore original register contents 
8f7a			;                pop     af 
8f7a			;                ret 
8f7a			 
8f7a			 
8f7a			 
8f7a			 
8f7a			 
8f7a			fourehexhl:  
8f7a 7e				ld a,(hl) 
8f7b cd 29 8f			call atohex 
8f7e cb 3f				SRL A 
8f80 cb 3f				SRL A 
8f82 cb 3f				SRL A 
8f84 cb 3f				SRL A 
8f86 47				ld b, a 
8f87 23				inc hl 
8f88 7e				ld a,(hl) 
8f89 23				inc hl 
8f8a cd 29 8f			call atohex 
8f8d 80				add b 
8f8e 57				ld d,a 
8f8f 7e				ld a,(hl) 
8f90 cd 29 8f			call atohex 
8f93 cb 3f				SRL A 
8f95 cb 3f				SRL A 
8f97 cb 3f				SRL A 
8f99 cb 3f				SRL A 
8f9b 47				ld b, a 
8f9c 23				inc hl 
8f9d 7e				ld a,(hl) 
8f9e 23				inc hl 
8f9f cd 29 8f			call atohex 
8fa2 80				add b 
8fa3 5f				ld e, a 
8fa4 d5				push de 
8fa5 e1				pop hl 
8fa6 c9				ret 
8fa7			 
8fa7			; pass hl. returns z set if the byte at hl is a digit 
8fa7			;isdigithl:  
8fa7			;	push bc 
8fa7			;	ld a,(hl) 
8fa7			;	cp ':' 
8fa7			;	jr nc, .isdf 		; > 
8fa7			;	cp '0' 
8fa7			;	jr c, .isdf		; < 
8fa7			; 
8fa7			;	; TODO find a better way to set z 
8fa7			; 
8fa7			;	ld b,a 
8fa7			;	cp b 
8fa7			;	pop bc 
8fa7			;	ret 
8fa7			; 
8fa7			;.isdf:	; not digit so clear z 
8fa7			; 
8fa7			;	; TODO find a better way to unset z 
8fa7			; 
8fa7			;	ld b,a 
8fa7			;	inc b 
8fa7			;	cp b 
8fa7			; 
8fa7			;	pop bc 
8fa7			;	ret 
8fa7				 
8fa7				 
8fa7			 
8fa7			 
8fa7			; pass hl as the four byte address to load 
8fa7			 
8fa7			get_word_hl:  
8fa7 e5				push hl 
8fa8 cd 47 8f			call get_byte 
8fab				 
8fab 47				ld b, a 
8fac			 
8fac e1				pop hl 
8fad 23				inc hl 
8fae 23				inc hl 
8faf			 
8faf			; TODO not able to handle a-f  
8faf 7e				ld a,(hl) 
8fb0			;	;cp ':' 
8fb0			;	cp 'g' 
8fb0			;	jr nc, .single_byte_hl 		; > 
8fb0			;	cp 'G' 
8fb0			;	jr nc, .single_byte_hl 		; > 
8fb0			;	cp '0' 
8fb0			;	jr c, .single_byte_hl		; < 
8fb0			 
8fb0				;call isdigithl 
8fb0 fe 00			cp 0 
8fb2 28 06			jr z, .single_byte_hl 
8fb4			 
8fb4			.getwhln:   ; hex word so get next byte 
8fb4			 
8fb4 cd 47 8f			call get_byte 
8fb7 6f				ld l, a 
8fb8 60				ld h,b 
8fb9 c9				ret 
8fba 68			.single_byte_hl:   ld l,b 
8fbb 26 00				ld h,0 
8fbd c9					ret 
8fbe			 
8fbe			 
8fbe			 
8fbe			 
8fbe 21 4b 97			ld hl,asc+1 
8fc1			;	ld a, (hl) 
8fc1			;	call nibble2val 
8fc1 cd 47 8f			call get_byte 
8fc4			 
8fc4			;	call fourehexhl 
8fc4 32 f5 e2			ld (scratch+52),a 
8fc7				 
8fc7 21 f3 e2			ld hl,scratch+50 
8fca 22 e4 e5			ld (os_cur_ptr),hl 
8fcd			 
8fcd c9				ret 
8fce			 
8fce			 
8fce			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fce			 
8fce			; Decimal Unsigned Version 
8fce			 
8fce			;Number in a to decimal ASCII 
8fce			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fce			;Example: display a=56 as "056" 
8fce			;input: a = number 
8fce			;Output: a=0,value of a in the screen 
8fce			;destroys af,bc (don't know about hl and de) 
8fce			DispAToASCII: 
8fce 0e 9c			ld	c,-100 
8fd0 cd da 8f			call	.Na1 
8fd3 0e f6			ld	c,-10 
8fd5 cd da 8f			call	.Na1 
8fd8 0e ff			ld	c,-1 
8fda 06 2f		.Na1:	ld	b,'0'-1 
8fdc 04			.Na2:	inc	b 
8fdd 81				add	a,c 
8fde 38 fc			jr	c,.Na2 
8fe0 91				sub	c		;works as add 100/10/1 
8fe1 f5				push af		;safer than ld c,a 
8fe2 78				ld	a,b		;char is in b 
8fe3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fe3 f1				pop af		;safer than ld a,c 
8fe4 c9				ret 
8fe5			 
8fe5			; Decimal Signed Version 
8fe5			 
8fe5			; DispA 
8fe5			; -------------------------------------------------------------- 
8fe5			; Converts a signed integer value to a zero-terminated ASCII 
8fe5			; string representative of that value (using radix 10). 
8fe5			; -------------------------------------------------------------- 
8fe5			; INPUTS: 
8fe5			;     HL     Value to convert (two's complement integer). 
8fe5			;     DE     Base address of string destination. (pointer). 
8fe5			; -------------------------------------------------------------- 
8fe5			; OUTPUTS: 
8fe5			;     None 
8fe5			; -------------------------------------------------------------- 
8fe5			; REGISTERS/MEMORY DESTROYED 
8fe5			; AF HL 
8fe5			; -------------------------------------------------------------- 
8fe5			 
8fe5			;DispHLToASCII: 
8fe5			;   push    de 
8fe5			;   push    bc 
8fe5			; 
8fe5			;; Detect sign of HL. 
8fe5			;    bit    7, h 
8fe5			;    jr     z, ._DoConvert 
8fe5			; 
8fe5			;; HL is negative. Output '-' to string and negate HL. 
8fe5			;    ld     a, '-' 
8fe5			;    ld     (de), a 
8fe5			;    inc    de 
8fe5			; 
8fe5			;; Negate HL (using two's complement) 
8fe5			;    xor    a 
8fe5			;    sub    l 
8fe5			;    ld     l, a 
8fe5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fe5			;    sbc    a, h 
8fe5			;    ld     h, a 
8fe5			; 
8fe5			;; Convert HL to digit characters 
8fe5			;._DoConvert: 
8fe5			;    ld     b, 0     ; B will count character length of number 
8fe5			;-   ld     a, 10 
8fe5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fe5			;    push   af 
8fe5			;    inc    b 
8fe5			;    ld     a, h 
8fe5			;    or     l 
8fe5			;    jr     nz, - 
8fe5			; 
8fe5			;; Retrieve digits from stack 
8fe5			;-   pop    af 
8fe5			;    or     $30 
8fe5			;    ld     (de), a 
8fe5			;    inc    de 
8fe5			;    djnz   - 
8fe5			; 
8fe5			;; Terminate string with NULL 
8fe5			;    xor    a 
8fe5			;    ld     (de), a 
8fe5			; 
8fe5			;    pop    bc 
8fe5			;    pop    de 
8fe5			;    ret 
8fe5			 
8fe5			;Comments 
8fe5			; 
8fe5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fe5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fe5			;    Note that the output string will not be fixed-width. 
8fe5			; 
8fe5			;Example Usage 
8fe5			; 
8fe5			;    ld    hl, -1004 
8fe5			;    ld    de, OP1 
8fe5			;    call  DispA 
8fe5			;    ld    hl, OP1 
8fe5			;    syscall  PutS 
8fe5			 
8fe5			 
8fe5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fe5			 
8fe5			 
8fe5			;Converts an ASCII string to an unsigned 16-bit integer 
8fe5			;Quits when it reaches a non-decimal digit 
8fe5			 
8fe5			string_to_uint16: 
8fe5			atoui_16: 
8fe5			;Input: 
8fe5			;     DE points to the string 
8fe5			;Outputs: 
8fe5			;     HL is the result 
8fe5			;     A is the 8-bit value of the number 
8fe5			;     DE points to the byte after the number 
8fe5			;Destroys: 
8fe5			;     BC 
8fe5			;       if the string is non-empty, BC is HL/10 
8fe5			;Size:  24 bytes 
8fe5			;Speed: 42+d(104+{0,9}) 
8fe5			;       d is the number of digits in the number 
8fe5			;       max is 640 cycles for a 5 digit number 
8fe5			;Assuming no leading zeros: 
8fe5			;1 digit:  146cc 
8fe5			;2 digit:  250cc 
8fe5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fe5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fe5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fe5			;avg: 544.81158447265625cc (544+13297/16384) 
8fe5			;=============================================================== 
8fe5 21 00 00		  ld hl,0 
8fe8			.u16a: 
8fe8 1a			  ld a,(de) 
8fe9 d6 30		  sub 30h 
8feb fe 0a		  cp 10 
8fed d0			  ret nc 
8fee 13			  inc de 
8fef 44			  ld b,h 
8ff0 4d			  ld c,l 
8ff1 29			  add hl,hl 
8ff2 29			  add hl,hl 
8ff3 09			  add hl,bc 
8ff4 29			  add hl,hl 
8ff5 85			  add a,l 
8ff6 6f			  ld l,a 
8ff7 30 ef		  jr nc,.u16a 
8ff9 24			  inc h 
8ffa c3 e8 8f		  jp .u16a 
8ffd			 
8ffd			 
8ffd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ffd			 
8ffd			;written by Zeda 
8ffd			;Converts a 16-bit unsigned integer to an ASCII string. 
8ffd			 
8ffd			uitoa_16: 
8ffd			;Input: 
8ffd			;   DE is the number to convert 
8ffd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ffd			;Output: 
8ffd			;   HL points to the null-terminated ASCII string 
8ffd			;      NOTE: This isn't necessarily the same as the input HL. 
8ffd d5			  push de 
8ffe c5			  push bc 
8fff f5			  push af 
9000 eb			  ex de,hl 
9001			 
9001 01 f0 d8		  ld bc,-10000 
9004 3e 2f		  ld a,'0'-1 
9006 3c			  inc a 
9007 09			  add hl,bc  
9008 38 fc		   jr c,$-2 
900a 12			  ld (de),a 
900b 13			  inc de 
900c			 
900c 01 e8 03		  ld bc,1000 
900f 3e 3a		  ld a,'9'+1 
9011 3d			  dec a  
9012 09			  add hl,bc  
9013 30 fc		   jr nc,$-2 
9015 12			  ld (de),a 
9016 13			  inc de 
9017			 
9017 01 9c ff		  ld bc,-100 
901a 3e 2f		  ld a,'0'-1 
901c 3c			  inc a  
901d 09			  add hl,bc  
901e 38 fc		   jr c,$-2 
9020 12			  ld (de),a 
9021 13			  inc de 
9022			 
9022 7d			  ld a,l 
9023 26 3a		  ld h,'9'+1 
9025 25			  dec h  
9026 c6 0a		  add a,10  
9028 30 fb		   jr nc,$-3 
902a c6 30		  add a,'0' 
902c eb			  ex de,hl 
902d 72			  ld (hl),d 
902e 23			  inc hl 
902f 77			  ld (hl),a 
9030 23			  inc hl 
9031 36 00		  ld (hl),0 
9033			 
9033			;Now strip the leading zeros 
9033 0e fa		  ld c,-6 
9035 09			  add hl,bc 
9036 3e 30		  ld a,'0' 
9038 23			  inc hl  
9039 be			  cp (hl)  
903a 28 fc		  jr z,$-2 
903c			 
903c			;Make sure that the string is non-empty! 
903c 7e			  ld a,(hl) 
903d b7			  or a 
903e 20 01		  jr nz,.atoub 
9040 2b			  dec hl 
9041			.atoub: 
9041			 
9041 f1			  pop af 
9042 c1			  pop bc 
9043 d1			  pop de 
9044 c9			  ret 
9045			 
9045			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9045			 
9045			toUpper: 
9045			;A is the char. 
9045			;If A is a lowercase letter, this sets it to the matching uppercase 
9045			;18cc or 30cc or 41cc 
9045			;avg: 26.75cc 
9045 fe 61		  cp 'a' 
9047 d8			  ret c 
9048 fe 7b		  cp 'z'+1 
904a d0			  ret nc 
904b d6 20		  sub 'a'-'A' 
904d c9			  ret 
904e			 
904e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
904e			 
904e			; String Length 
904e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
904e			 
904e			; Get the length of the null-terminated string starting at $8000 hl 
904e			;    LD     HL, $8000 
904e			 
904e			strlenz: 
904e			 
904e af			    XOR    A               ; Zero is the value we are looking for. 
904f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9050 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9051			                           ; 65, 536 bytes (the entire addressable memory space). 
9051 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9053			 
9053			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9053 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9054 6f			    LD     L, A             ; number of bytes 
9055 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9057 2b			    DEC    HL              ; Compensate for null. 
9058 c9				ret 
9059			 
9059			; Get the length of the A terminated string starting at $8000 hl 
9059			;    LD     HL, $8000 
9059			 
9059			strlent: 
9059			 
9059			                  ; A is the value we are looking for. 
9059 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
905b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
905d			                           ; 65, 536 bytes (the entire addressable memory space). 
905d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
905f			 
905f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
905f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9061 2e 00		    LD     L, 0             ; number of bytes 
9063 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9065 2b			    DEC    HL              ; Compensate for null. 
9066 c9				ret 
9067			 
9067			 
9067			;Comparing Strings 
9067			 
9067			;IN    HL     Address of string1. 
9067			;      DE     Address of string2. 
9067			 
9067			; doc given but wrong??? 
9067			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9067			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9067			; tested 
9067			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9067			 
9067			strcmp_old: 
9067 e5			    PUSH   HL 
9068 d5			    PUSH   DE 
9069			 
9069 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
906a be			    CP     (HL)            ; (want to minimize work). 
906b 38 01		    JR     C, Str1IsBigger 
906d 7e			    LD     A, (HL) 
906e			 
906e			Str1IsBigger: 
906e 4f			    LD     C, A             ; Put length in BC 
906f 06 00		    LD     B, 0 
9071 13			    INC    DE              ; Increment pointers to meat of string. 
9072 23			    INC    HL 
9073			 
9073			CmpLoop: 
9073 1a			    LD     A, (DE)          ; Compare bytes. 
9074 ed a1		    CPI 
9076 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9078 13			    INC    DE              ; Update pointer. 
9079 ea 73 90		    JP     PE, CmpLoop 
907c			 
907c d1			    POP    DE 
907d e1			    POP    HL 
907e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
907f be			    CP     (HL) 
9080 c9			    RET 
9081			 
9081			NoMatch: 
9081 2b			    DEC    HL 
9082 be			    CP     (HL)            ; Compare again to affect carry. 
9083 d1			    POP    DE 
9084 e1			    POP    HL 
9085 c9			    RET 
9086			 
9086			;; test strmp 
9086			; 
9086			;ld de, .str1 
9086			;ld hl, .str2 
9086			;call strcmp 
9086			;jr z, .z1 
9086			;;this 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "NZ1" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			;.z1: 
9086			; 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "ZZ1" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			; 
9086			;ld de, .str1 
9086			;ld hl, .str1 
9086			;call strcmp 
9086			;jr z, .z2 
9086			;;this 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "NZ2" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			;.z2: 
9086			; 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "ZZ2" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			; 
9086			;ld de, .str1 
9086			;ld hl, .str2 
9086			;call strcmp 
9086			;jr c, .c1 
9086			; 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "Nc1" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			;.c1: 
9086			;;this 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "cc1" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			; 
9086			;ld de, .str1 
9086			;ld hl, .str1 
9086			;call strcmp 
9086			;jr c, .c2 
9086			;;this 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "Nc2" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			;.c2: 
9086			; 
9086			;	if DEBUG_FORTH_WORDS 
9086			;		DMARK "cc2" 
9086			;		CALLMONITOR 
9086			;	endif 
9086			;	NEXTW 
9086			;.str1:   db "string1",0 
9086			;.str2:   db "string2",0 
9086			 
9086			; only care about direct match or not 
9086			; hl and de strings 
9086			; zero set if the same 
9086			 
9086			strcmp: 
9086 1a				ld a, (de) 
9087 be				cp (hl) 
9088 28 02			jr z, .ssame 
908a b7				or a 
908b c9				ret 
908c			 
908c			.ssame:  
908c fe 00			cp 0 
908e c8				ret z 
908f			 
908f 23				inc hl 
9090 13				inc de 
9091 18 f3			jr strcmp 
9093				 
9093				 
9093			 
9093			;Copyright (c) 2014, Luke Maurits 
9093			;All rights reserved. 
9093			; 
9093			;Redistribution and use in source and binary forms, with or without 
9093			;modification, are permitted provided that the following conditions are met: 
9093			; 
9093			;* Redistributions of source code must retain the above copyright notice, this 
9093			;  list of conditions and the following disclaimer. 
9093			; 
9093			;* Redistributions in binary form must reproduce the above copyright notice, 
9093			;  this list of conditions and the following disclaimer in the documentation 
9093			;  and/or other materials provided with the distribution. 
9093			; 
9093			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9093			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9093			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9093			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9093			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9093			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9093			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9093			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9093			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9093			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9093			 
9093			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9093			 
9093			StrictStrCmp: 
9093				; Load next chars of each string 
9093 1a				ld a, (de) 
9094 47				ld b, a 
9095 7e				ld a, (hl) 
9096				; Compare 
9096 b8				cp b 
9097				; Return non-zero if chars don't match 
9097 c0				ret nz 
9098				; Check for end of both strings 
9098 fe 00			cp "\0" 
909a				; Return if strings have ended 
909a c8				ret z 
909b				; Otherwise, advance to next chars 
909b 23				inc hl 
909c 13				inc de 
909d 18 f4			jr StrictStrCmp 
909f			 
909f			;end 
909f			; eof 
909f			 
909f			 
909f			 
909f			 
909f			 
909f			 
# End of file firmware_strings.asm
909f			include "firmware_memory.asm"   ; malloc and free  
909f			 
909f			if DEBUG_FORTH_MALLOC_HIGH 
909f			.mallocsize: db "Wants malloc >256",0 
909f			.mallocasize: db "MALLOC gives >256",0 
909f			.malloczero: db "MALLOC gives zero",0 
909f			 
909f			malloc_guard_zerolen: 
909f				push hl 
909f				push de 
909f				push af 
909f			 
909f				ld de, 0 
909f			        call cmp16 
909f				jr nz, .lowalloz 
909f			 
909f				push hl 
909f				push de 
909f					ld hl, display_fb0 
909f					ld (display_fb_active), hl 
909f				call clear_display 
909f				ld a, 0 
909f				ld de, .malloczero 
909f				call str_at_display 
909f				call update_display 
909f				call delay1s 
909f				call delay1s 
909f				call bp_on 
909f			;	ld a, 0 
909f			;	ld (os_view_disable), a 
909f			 
909f				pop de 
909f				pop hl 
909f			 
909f				 
909f			 
909f				CALLMONITOR 
909f			.lowalloz: 
909f			 
909f			 
909f				pop af 
909f				pop de 
909f				pop hl 
909f			ret 
909f			 
909f			malloc_guard_entry: 
909f				push hl 
909f				push de 
909f				push af 
909f			 
909f			 	or a      ;clear carry flag 
909f				push hl 
909f				ld de, 255 
909f				sbc hl, de 
909f				jr c, .lowalloc 
909f			 
909f				push de 
909f					ld hl, display_fb0 
909f					ld (display_fb_active), hl 
909f				call clear_display 
909f				ld a, 0 
909f				ld de, .mallocsize 
909f				call str_at_display 
909f				call update_display 
909f				call delay1s 
909f				call delay1s 
909f			;	ld a, 0 
909f			;	ld (os_view_disable), a 
909f				call bp_on 
909f			 
909f				pop de 
909f				pop hl 
909f			 
909f				 
909f			 
909f				CALLMONITOR 
909f				jr .lowdone 
909f			.lowalloc: 
909f			 
909f			 
909f				pop hl 
909f			.lowdone:	pop af 
909f				pop de 
909f				pop hl 
909f			ret 
909f			 
909f			malloc_guard_exit: 
909f				push hl 
909f				push de 
909f				push af 
909f			 
909f			 	or a      ;clear carry flag 
909f				push hl 
909f				ld de, 255 
909f				sbc hl, de 
909f				jr c, .lowallocx 
909f			 
909f				push de 
909f					ld hl, display_fb0 
909f					ld (display_fb_active), hl 
909f				call clear_display 
909f				ld a, 0 
909f				ld de, .mallocasize 
909f				call str_at_display 
909f				call update_display 
909f				call delay1s 
909f				call delay1s 
909f			;	ld a, 0 
909f			;	ld (os_view_disable), a 
909f				call bp_on 
909f				pop de 
909f				pop hl 
909f			 
909f				CALLMONITOR 
909f				jr .lowdonex 
909f			.lowallocx: 
909f			 
909f				pop hl 
909f			.lowdonex:	pop af 
909f				pop de 
909f				pop hl 
909f			ret 
909f			endif 
909f			 
909f			if MALLOC_2 
909f			; Z80 Malloc and Free Functions 
909f			 
909f			; Malloc Function: 
909f			; Input: 
909f			;   HL: Size of block to allocate 
909f			; Output: 
909f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
909f			 
909f			malloc: 
909f				 
909f			if DEBUG_FORTH_MALLOC_HIGH 
909f			call malloc_guard_entry 
909f			endif 
909f			 
909f			 
909f			 
909f			 
909f					if DEBUG_FORTH_MALLOC 
909f						DMARK "mal" 
909f						CALLMONITOR 
909f					endif 
909f			    push af            ; Save AF register 
909f			    ld a, l            ; Load low byte of size into A 
909f			    or h               ; Check if size is zero 
909f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
909f			 
909f			    ; Allocate memory 
909f			    ld hl, (heap_start) ; Load start of heap into HL 
909f					if DEBUG_FORTH_MALLOC 
909f						DMARK "ma1" 
909f						CALLMONITOR 
909f					endif 
909f			    call malloc_internal ; Call internal malloc function 
909f			    pop af             ; Restore AF register 
909f			if DEBUG_FORTH_MALLOC_HIGH 
909f			call malloc_guard_exit 
909f			call malloc_guard_zerolen 
909f			endif 
909f			    ret                ; Return 
909f			 
909f			; Free Function: 
909f			; Input: 
909f			;   HL: Pointer to memory block to free 
909f			; Output: 
909f			;   None 
909f			 
909f			free: 
909f			    push af            ; Save AF register 
909f			    ld a, l            ; Load low byte of pointer into A 
909f			    or h               ; Check if pointer is NULL 
909f			    jp z, free_exit    ; If pointer is NULL, exit 
909f			 
909f			    ; Free memory 
909f			    ld hl, (heap_start) ; Load start of heap into HL 
909f			    call free_internal  ; Call internal free function 
909f			    pop af             ; Restore AF register 
909f			    ret                ; Return 
909f			 
909f			; Internal Malloc Function: 
909f			; Input: 
909f			;   HL: Size of block to allocate 
909f			; Output: 
909f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
909f			 
909f			malloc_internal: 
909f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
909f			    add hl, bc         ; Add management overhead to requested size 
909f			    ex de, hl          ; Save total size in DE, and keep it in HL 
909f					if DEBUG_FORTH_MALLOC 
909f						DMARK "ma2" 
909f						CALLMONITOR 
909f					endif 
909f			 
909f			    ; Search for free memory block 
909f			    ld de, (heap_end)  ; Load end of heap into DE 
909f			    ld bc, 0           ; Initialize counter 
909f			 
909f					if DEBUG_FORTH_MALLOC 
909f						DMARK "ma2" 
909f						CALLMONITOR 
909f					endif 
909f			malloc_search_loop: 
909f			    ; Check if current block is free 
909f			    ld a, (hl)         ; Load current block's status (free or used) 
909f			    cp 0               ; Compare with zero (free) 
909f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
909f			 
909f			    ; Check if current block is large enough 
909f			    ld a, (hl+1)       ; Load high byte of block size 
909f			    cp l               ; Compare with low byte of requested size 
909f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
909f			 
909f			    ld a, (hl+2)       ; Load low byte of block size 
909f			    cp h               ; Compare with high byte of requested size 
909f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
909f			 
909f			    ; Mark block as used 
909f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
909f			 
909f			    ; Calculate remaining space in block 
909f			    ld bc, 0           ; Clear BC 
909f			    add hl, bc         ; Increment HL to point to start of data block 
909f			    add hl, de         ; HL = HL + DE (total size) 
909f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
909f			    add hl, bc         ; Add management overhead to start of data block 
909f			 
909f			    ; Save pointer to allocated block in HL 
909f			if DEBUG_FORTH_MALLOC_HIGH 
909f						DMARK "ma5" 
909f			call malloc_guard_exit 
909f			call malloc_guard_zerolen 
909f			endif 
909f			    ret 
909f			 
909f			malloc_skip_block_check: 
909f			    ; Move to the next block 
909f			    ld bc, 3           ; Size of management overhead 
909f			    add hl, bc         ; Move to the next block 
909f			    inc de             ; Increment counter 
909f			 
909f			    ; Check if we have reached the end of heap 
909f			    ld a, e            ; Load low byte of heap end address 
909f			    cp (hl)            ; Compare with low byte of current address 
909f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
909f			    ld a, d            ; Load high byte of heap end address 
909f			    cp 0               ; Check if it's zero (end of memory) 
909f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
909f			 
909f			    ; If we reached here, allocation failed 
909f			    xor a              ; Set result to NULL 
909f			if DEBUG_FORTH_MALLOC_HIGH 
909f						DMARK "ma6" 
909f			call malloc_guard_exit 
909f			call malloc_guard_zerolen 
909f			endif 
909f			    ret 
909f			malloc_exit: 
909f			if DEBUG_FORTH_MALLOC_HIGH 
909f						DMARK "ma7" 
909f			call malloc_guard_exit 
909f			call malloc_guard_zerolen 
909f			endif 
909f			    ret 
909f			 
909f			; Internal Free Function: 
909f			; Input: 
909f			;   HL: Pointer to memory block to free 
909f			; Output: 
909f			;   None 
909f			 
909f			free_internal: 
909f			    ld de, (heap_start) ; Load start of heap into DE 
909f			    ld bc, 0            ; Initialize counter 
909f			 
909f			free_search_loop: 
909f			    ; Check if current block contains the pointer 
909f			    ld a, l             ; Load low byte of pointer 
909f			    cp (hl+1)           ; Compare with high byte of current block's address 
909f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
909f			    ld a, h             ; Load high byte of pointer 
909f			    cp (hl+2)           ; Compare with low byte of current block's address 
909f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
909f			 
909f			    ; Mark block as free 
909f			    ld (hl), 0          ; Set status byte to indicate free block 
909f			    ret                 ; Return 
909f			 
909f			free_skip_block_check: 
909f			    ; Move to the next block 
909f			    ld bc, 3            ; Size of management overhead 
909f			    add hl, bc          ; Move to the next block 
909f			    inc de              ; Increment counter 
909f			 
909f			    ; Check if we have reached the end of heap 
909f			    ld a, e             ; Load low byte of heap end address 
909f			    cp (hl)             ; Compare with low byte of current address 
909f			    jr nz, free_search_loop  ; If not equal, continue searching 
909f			    ld a, d             ; Load high byte of heap end address 
909f			    cp 0                ; Check if it's zero (end of memory) 
909f			    jr nz, free_search_loop  ; If not zero, continue searching 
909f			 
909f			    ; If we reached here, pointer is not found in heap 
909f			    ret 
909f			 
909f			free_exit: 
909f			    ret                 ; Return 
909f			 
909f			; Define heap start and end addresses 
909f			;heap_start:    .dw 0xC000   ; Start of heap 
909f			;heap_end:      .dw 0xE000   ; End of heap 
909f			 
909f			endif 
909f			 
909f			 
909f			if MALLOC_1 
909f			 
909f			 
909f			 
909f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
909f			 
909f			;moved to firmware.asm 
909f			;heap_start        .equ  0x9000      ; Starting address of heap 
909f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
909f			 
909f			;      .org 0 
909f			;      jp    main 
909f			 
909f			 
909f			;      .org  0x100 
909f			;main: 
909f			;      ld    HL, 0x8100 
909f			;      ld    SP, HL 
909f			; 
909f			;      call  heap_init 
909f			; 
909f			;      ; Make some allocations 
909f			;      ld    HL, 12 
909f			;      call  malloc            ; Allocates 0x9004 
909f			; 
909f			;      ld    HL, 12 
909f			;      call  malloc            ; Allocates 0x9014 
909f			; 
909f			;      ld    HL, 12 
909f			;      call  malloc            ; Allocates 0x9024 
909f			; 
909f			;      ; Free some allocations 
909f			;      ld    HL, 0x9014 
909f			;      call  free 
909f			; 
909f			;      ld    HL, 0x9004 
909f			;      call  free 
909f			; 
909f			;      ld    HL, 0x9024 
909f			;      call  free 
909f			; 
909f			; 
909f			;      halt 
909f			 
909f			 
909f			;------------------------------------------------------------------------------ 
909f			;     heap_init                                                               : 
909f			;                                                                             : 
909f			; Description                                                                 : 
909f			;     Initialise the heap and make it ready for malloc and free operations.   : 
909f			;                                                                             : 
909f			;     The heap is maintained as a linked list, starting with an initial       : 
909f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
909f			;     the first free block in the heap. Each block then points to the next    : 
909f			;     free block within the heap, and the free list ends at the first block   : 
909f			;     with a null pointer to the next free block.                             : 
909f			;                                                                             : 
909f			; Parameters                                                                  : 
909f			;     Inputs are compile-time only. Two defines which specify the starting    : 
909f			;     address of the heap and its size are required, along with a memory      : 
909f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
909f			;     principally stores a pointer to the first free block in the heap.       : 
909f			;                                                                             : 
909f			; Returns                                                                     : 
909f			;     Nothing                                                                 : 
909f			;------------------------------------------------------------------------------ 
909f			heap_init: 
909f e5			      push  HL 
90a0			 
90a0			      ; Initialise free list struct 
90a0 21 08 e4		      ld    HL, heap_start 
90a3 22 03 e4		      ld    (free_list), HL 
90a6 21 00 00		      ld    HL, 0 
90a9 22 05 e4		      ld    (free_list+2), HL 
90ac			 
90ac			      ; Insert first free block at bottom of heap, consumes entire heap 
90ac 21 98 e2		      ld    HL, heap_start+heap_size-4 
90af 22 08 e4		      ld    (heap_start), HL        ; Next block (end of free list) 
90b2 21 90 fe		      ld    HL, heap_size-4 
90b5 22 0a e4		      ld    (heap_start+2), HL      ; Block size 
90b8			 
90b8			      ; Insert end of free list block at top of heap - two null words will 
90b8			      ; terminate the free list 
90b8 21 00 00		      ld    HL, 0 
90bb 22 9a e2		      ld    (heap_start+heap_size-2), HL 
90be 22 98 e2		      ld    (heap_start+heap_size-4), HL 
90c1			 
90c1 e1			      pop   HL 
90c2			 
90c2 c9			      ret 
90c3			 
90c3			 
90c3			;------------------------------------------------------------------------------ 
90c3			;     malloc                                                                  : 
90c3			;                                                                             : 
90c3			; Description                                                                 : 
90c3			;     Allocates the wanted space from the heap and returns the address of the : 
90c3			;     first useable byte of the allocation.                                   : 
90c3			;                                                                             : 
90c3			;     Allocations can happen in one of two ways:                              : 
90c3			;                                                                             : 
90c3			;     1. A free block may be found which is the exact size wanted. In this    : 
90c3			;        case the block is removed from the free list and retuedn to the      : 
90c3			;        caller.                                                              : 
90c3			;     2. A free block may be found which is larger than the size wanted. In   : 
90c3			;        this case, the larger block is split into two. The first portion of  : 
90c3			;        this block will become the requested space by the malloc call and    : 
90c3			;        is returned to the caller. The second portion becomes a new free     : 
90c3			;        block, and the free list is adjusted to maintain continuity via this : 
90c3			;        newly created block.                                                 : 
90c3			;                                                                             : 
90c3			;     malloc does not set any initial value in the allocated space, the       : 
90c3			;     caller is required to do this as required.                              : 
90c3			;                                                                             : 
90c3			;     This implementation of malloc uses the stack exclusively, and is        : 
90c3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c3			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c3			;     to avoid the use of malloc inside ISRs in general.                      : 
90c3			;                                                                             : 
90c3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c3			;                                                                             : 
90c3			; Parameters                                                                  : 
90c3			;     HL  Number of bytes wanted                                              : 
90c3			;                                                                             : 
90c3			; Returns                                                                     : 
90c3			;     HL  Address of the first useable byte of the allocation                 : 
90c3			;                                                                             : 
90c3			; Flags                                                                       : 
90c3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c3			;                                                                             : 
90c3			; Stack frame                                                                 : 
90c3			;       |             |                                                       : 
90c3			;       +-------------+                                                       : 
90c3			;       |     BC      |                                                       : 
90c3			;       +-------------+                                                       : 
90c3			;       |     DE      |                                                       : 
90c3			;       +-------------+                                                       : 
90c3			;       |     IX      |                                                       : 
90c3			;       +-------------+                                                       : 
90c3			;       |  prev_free  |                                                       : 
90c3			;   +4  +-------------+                                                       : 
90c3			;       |  this_free  |                                                       : 
90c3			;   +2  +-------------+                                                       : 
90c3			;       |  next_free  |                                                       : 
90c3			;   +0  +-------------+                                                       : 
90c3			;       |             |                                                       : 
90c3			;                                                                             : 
90c3			;------------------------------------------------------------------------------ 
90c3			 
90c3			 
90c3			;malloc: 
90c3			; 
90c3			;	SAVESP ON 1 
90c3			; 
90c3			;	call malloc_code 
90c3			; 
90c3			;	CHECKSP ON 1 
90c3			;	ret 
90c3			 
90c3			 
90c3			malloc: 
90c3 c5			      push  BC 
90c4 d5			      push  DE 
90c5 dd e5		      push  IX 
90c7			if DEBUG_FORTH_MALLOC_HIGH 
90c7			call malloc_guard_entry 
90c7			endif 
90c7			 
90c7					if DEBUG_FORTH_MALLOC 
90c7						DMARK "mal" 
90c7						CALLMONITOR 
90c7					endif 
90c7 7c			      ld    A, H                    ; Exit if no space requested 
90c8 b5			      or    L 
90c9 ca 88 91		      jp    Z, malloc_early_exit 
90cc			 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			; 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			;inc hl 
90cc			 
90cc			 
90cc			 
90cc			 
90cc					if DEBUG_FORTH_MALLOC 
90cc						DMARK "maA" 
90cc						CALLMONITOR 
90cc					endif 
90cc			      ; Set up stack frame 
90cc eb			      ex    DE, HL 
90cd 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90d0 39			      add   HL, SP 
90d1 f9			      ld    SP, HL 
90d2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90d6 dd 39		      add   IX, SP 
90d8			 
90d8			      ; Setup initial state 
90d8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90db 19			      add   HL, DE 
90dc			 
90dc 44			      ld    B, H                    ; Move want to BC 
90dd 4d			      ld    C, L 
90de			 
90de 21 03 e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
90e1 dd 75 04		      ld    (IX+4), L 
90e4 dd 74 05		      ld    (IX+5), H 
90e7			 
90e7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90e8 23			      inc   HL 
90e9 56			      ld    D, (HL) 
90ea dd 73 02		      ld    (IX+2), E 
90ed dd 72 03		      ld    (IX+3), D 
90f0 eb			      ex    DE, HL                  ; this_free ptr into HL 
90f1			 
90f1					if DEBUG_FORTH_MALLOC 
90f1						DMARK "maB" 
90f1						CALLMONITOR 
90f1					endif 
90f1			      ; Loop through free block list to find some space 
90f1			malloc_find_space: 
90f1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90f2 23			      inc   HL 
90f3 56			      ld    D, (HL) 
90f4			 
90f4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90f5 b3			      or    E 
90f6 ca 82 91		      jp    Z, malloc_no_space 
90f9			 
90f9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90fc dd 72 01		      ld    (IX+1), D 
90ff			 
90ff			      ; Does this block have enough space to make the allocation? 
90ff 23			      inc   HL                      ; Load free block size into DE 
9100 5e			      ld    E, (HL) 
9101 23			      inc   HL 
9102 56			      ld    D, (HL) 
9103			 
9103 eb			      ex    DE, HL                  ; Check size of block against want 
9104 b7			      or    A                       ; Ensure carry flag clear 
9105 ed 42		      sbc   HL, BC 
9107 e5			      push  HL                      ; Store the result for later (new block size) 
9108			 
9108 ca 57 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910d			 
910d			      ; this_free block is not big enough, setup ptrs to test next free block 
910d e1			      pop   HL                      ; Discard previous result 
910e			 
910e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9111 dd 66 03		      ld    H, (IX+3) 
9114 dd 75 04		      ld    (IX+4), L 
9117 dd 74 05		      ld    (IX+5), H 
911a			 
911a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911d dd 66 01		      ld    H, (IX+1) 
9120 dd 75 02		      ld    (IX+2), L 
9123 dd 74 03		      ld    (IX+3), H 
9126			 
9126					if DEBUG_FORTH_MALLOC 
9126						DMARK "MA>" 
9126						CALLMONITOR 
9126					endif 
9126 18 c9		      jr    malloc_find_space 
9128			 
9128			      ; split a bigger block into two - requested size and remaining size 
9128			malloc_alloc_split: 
9128					if DEBUG_FORTH_MALLOC 
9128						DMARK "MAs" 
9128						CALLMONITOR 
9128					endif 
9128 eb			      ex    DE, HL                  ; Calculate address of new free block 
9129 2b			      dec   HL 
912a 2b			      dec   HL 
912b 2b			      dec   HL 
912c 09			      add   HL, BC 
912d			 
912d			      ; Create a new block and point it at next_free 
912d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9130 dd 56 01		      ld    D, (IX+1) 
9133			 
9133 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9134 23			      inc   HL 
9135 72			      ld    (HL), D 
9136			 
9136 d1			      pop   DE                      ; Store size of new block into new block 
9137 23			      inc   HL 
9138 73			      ld    (HL), E 
9139 23			      inc   HL 
913a 72			      ld    (HL), D 
913b			 
913b			      ; Update this_free ptr to point to new block 
913b 2b			      dec   HL 
913c 2b			      dec   HL 
913d 2b			      dec   HL 
913e			 
913e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9141 dd 56 03		      ld    D, (IX+3) 
9144			 
9144 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9147 dd 74 03		      ld    (IX+3), H 
914a			 
914a			      ; Modify this_free block to be allocation 
914a eb			      ex    DE, HL 
914b af			      xor   A                       ; Null the next block ptr of allocated block 
914c 77			      ld    (HL), A 
914d 23			      inc   HL 
914e 77			      ld    (HL), A 
914f			 
914f 23			      inc   HL                      ; Store want size into allocated block 
9150 71			      ld    (HL), C 
9151 23			      inc   HL 
9152 70			      ld    (HL), B 
9153 23			      inc   HL 
9154 e5			      push  HL                      ; Address of allocation to return 
9155			 
9155 18 19		      jr    malloc_update_links 
9157			 
9157			malloc_alloc_fit: 
9157 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9158			 
9158					if DEBUG_FORTH_MALLOC 
9158						DMARK "MAf" 
9158						CALLMONITOR 
9158					endif 
9158			      ; Modify this_free block to be allocation 
9158 eb			      ex    DE, HL 
9159 2b			      dec   HL 
915a 2b			      dec   HL 
915b 2b			      dec   HL 
915c			 
915c af			      xor   A                       ; Null the next block ptr of allocated block 
915d 77			      ld    (HL), A 
915e 23			      inc   HL 
915f 77			      ld    (HL), A 
9160			 
9160 23			      inc   HL                      ; Store address of allocation to return 
9161 23			      inc   HL 
9162 23			      inc   HL 
9163 e5			      push  HL 
9164			 
9164			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9164 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9167 dd 66 01		      ld    H, (IX+1) 
916a			 
916a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
916d dd 74 03		      ld    (IX+3), H 
9170			 
9170			 
9170			malloc_update_links: 
9170			      ; Update prev_free ptr to point to this_free 
9170 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9173 dd 66 05		      ld    H, (IX+5) 
9176			 
9176 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9179 dd 56 03		      ld    D, (IX+3) 
917c			 
917c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
917d 23			      inc   HL 
917e 72			      ld    (HL), D 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "Mul" 
917f						CALLMONITOR 
917f					endif 
917f			      ; Clear the Z flag to indicate successful allocation 
917f 7a			      ld    A, D 
9180 b3			      or    E 
9181			 
9181 d1			      pop   DE                      ; Address of allocation 
9182					if DEBUG_FORTH_MALLOC 
9182						DMARK "MAu" 
9182						CALLMONITOR 
9182					endif 
9182			 
9182			malloc_no_space: 
9182 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9185 39			      add   HL, SP 
9186 f9			      ld    SP, HL 
9187			 
9187 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9188					if DEBUG_FORTH_MALLOC 
9188						DMARK "MAN" 
9188						CALLMONITOR 
9188					endif 
9188			 
9188			malloc_early_exit: 
9188					if DEBUG_FORTH_MALLOC 
9188						DMARK "MAx" 
9188						CALLMONITOR 
9188					endif 
9188 dd e1		      pop   IX 
918a d1			      pop   DE 
918b c1			      pop   BC 
918c			 
918c			if DEBUG_FORTH_MALLOC_HIGH 
918c			call malloc_guard_exit 
918c			call malloc_guard_zerolen 
918c			endif 
918c c9			      ret 
918d			 
918d			 
918d			;------------------------------------------------------------------------------ 
918d			;     free                                                                    : 
918d			;                                                                             : 
918d			; Description                                                                 : 
918d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
918d			;     returned by malloc, otherwise the behaviour is undefined.               : 
918d			;                                                                             : 
918d			;     Where possible, directly adjacent free blocks will be merged together   : 
918d			;     into larger blocks to help ensure that the heap does not become         : 
918d			;     excessively fragmented.                                                 : 
918d			;                                                                             : 
918d			;     free does not clear or set any other value into the freed space, and    : 
918d			;     therefore its contents may be visible through subsequent malloc's. The  : 
918d			;     caller should clear the freed space as required.                        : 
918d			;                                                                             : 
918d			;     This implementation of free uses the stack exclusively, and is          : 
918d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
918d			;     advisable to disable interrupts before calling free, and recommended    : 
918d			;     to avoid the use of free inside ISRs in general.                        : 
918d			;                                                                             : 
918d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
918d			;                                                                             : 
918d			; Parameters                                                                  : 
918d			;     HL  Pointer to address of first byte of allocation to be freed          : 
918d			;                                                                             : 
918d			; Returns                                                                     : 
918d			;     Nothing                                                                 : 
918d			;                                                                             : 
918d			; Stack frame                                                                 : 
918d			;       |             |                                                       : 
918d			;       +-------------+                                                       : 
918d			;       |     BC      |                                                       : 
918d			;       +-------------+                                                       : 
918d			;       |     DE      |                                                       : 
918d			;       +-------------+                                                       : 
918d			;       |     IX      |                                                       : 
918d			;       +-------------+                                                       : 
918d			;       |  prev_free  |                                                       : 
918d			;   +2  +-------------+                                                       : 
918d			;       |  next_free  |                                                       : 
918d			;   +0  +-------------+                                                       : 
918d			;       |             |                                                       : 
918d			;                                                                             : 
918d			;------------------------------------------------------------------------------ 
918d			free: 
918d c5			      push  BC 
918e d5			      push  DE 
918f dd e5		      push  IX 
9191			 
9191 7c			      ld    A, H                    ; Exit if ptr is null 
9192 b5			      or    L 
9193 ca 57 92		      jp    Z, free_early_exit 
9196			 
9196			      ; Set up stack frame 
9196 eb			      ex    DE, HL 
9197 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
919a 39			      add   HL, SP 
919b f9			      ld    SP, HL 
919c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91a0 dd 39		      add   IX, SP 
91a2			 
91a2			      ; The address in HL points to the start of the useable allocated space, 
91a2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
91a2			      ; address of the block itself. 
91a2 eb			      ex    DE, HL 
91a3 11 fc ff		      ld    DE, -4 
91a6 19			      add   HL, DE 
91a7			 
91a7			      ; An allocated block must have a null next block pointer in it 
91a7 7e			      ld    A, (HL) 
91a8 23			      inc   HL 
91a9 b6			      or    (HL) 
91aa c2 52 92		      jp    NZ, free_done 
91ad			 
91ad 2b			      dec   HL 
91ae			 
91ae 44			      ld    B, H                    ; Copy HL to BC 
91af 4d			      ld    C, L 
91b0			 
91b0			      ; Loop through the free list to find the first block with an address 
91b0			      ; higher than the block being freed 
91b0 21 03 e4		      ld    HL, free_list 
91b3			 
91b3			free_find_higher_block: 
91b3 5e			      ld    E, (HL)                 ; Load next ptr from free block 
91b4 23			      inc   HL 
91b5 56			      ld    D, (HL) 
91b6 2b			      dec   HL 
91b7			 
91b7 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
91ba dd 72 01		      ld    (IX+1), D 
91bd dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
91c0 dd 74 03		      ld    (IX+3), H 
91c3			 
91c3 78			      ld    A, B                    ; Check if DE is greater than BC 
91c4 ba			      cp    D                       ; Compare MSB first 
91c5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91c7 30 04		      jr    NC, free_find_higher_block_skip 
91c9 79			      ld    A, C 
91ca bb			      cp    E                       ; Then compare LSB 
91cb 38 08		      jr    C, free_found_higher_block 
91cd			 
91cd			free_find_higher_block_skip: 
91cd 7a			      ld    A, D                    ; Reached the end of the free list? 
91ce b3			      or    E 
91cf ca 52 92		      jp    Z, free_done 
91d2			 
91d2 eb			      ex    DE, HL 
91d3			 
91d3 18 de		      jr    free_find_higher_block 
91d5			 
91d5			free_found_higher_block: 
91d5			      ; Insert freed block between prev and next free blocks 
91d5 71			      ld    (HL), C                 ; Point prev free block to freed block 
91d6 23			      inc   HL 
91d7 70			      ld    (HL), B 
91d8			 
91d8 60			      ld    H, B                    ; Point freed block at next free block 
91d9 69			      ld    L, C 
91da 73			      ld    (HL), E 
91db 23			      inc   HL 
91dc 72			      ld    (HL), D 
91dd			 
91dd			      ; Check if the freed block is adjacent to the next free block 
91dd 23			      inc   HL                      ; Load size of freed block into HL 
91de 5e			      ld    E, (HL) 
91df 23			      inc   HL 
91e0 56			      ld    D, (HL) 
91e1 eb			      ex    DE, HL 
91e2			 
91e2 09			      add   HL, BC                  ; Add addr of freed block and its size 
91e3			 
91e3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91e6 dd 56 01		      ld    D, (IX+1) 
91e9			 
91e9 b7			      or    A                       ; Clear the carry flag 
91ea ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91ec 20 22		      jr    NZ, free_check_adjacent_to_prev 
91ee			 
91ee			      ; Freed block is adjacent to next, merge into one bigger block 
91ee eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91ef 5e			      ld    E, (HL) 
91f0 23			      inc   HL 
91f1 56			      ld    D, (HL) 
91f2 e5			      push  HL                      ; Save ptr to next block for later 
91f3			 
91f3 60			      ld    H, B                    ; Store ptr from next block into freed block 
91f4 69			      ld    L, C 
91f5 73			      ld    (HL), E 
91f6 23			      inc   HL 
91f7 72			      ld    (HL), D 
91f8			 
91f8 e1			      pop   HL                      ; Restore ptr to next block 
91f9 23			      inc   HL                      ; Load size of next block into DE 
91fa 5e			      ld    E, (HL) 
91fb 23			      inc   HL 
91fc 56			      ld    D, (HL) 
91fd d5			      push  DE                      ; Save next block size for later 
91fe			 
91fe 60			      ld    H, B                    ; Load size of freed block into HL 
91ff 69			      ld    L, C 
9200 23			      inc   HL 
9201 23			      inc   HL 
9202 5e			      ld    E, (HL) 
9203 23			      inc   HL 
9204 56			      ld    D, (HL) 
9205 eb			      ex    DE, HL 
9206			 
9206 d1			      pop   DE                      ; Restore size of next block 
9207 19			      add   HL, DE                  ; Add sizes of both blocks 
9208 eb			      ex    DE, HL 
9209			 
9209 60			      ld    H, B                    ; Store new bigger size into freed block 
920a 69			      ld    L, C 
920b 23			      inc   HL 
920c 23			      inc   HL 
920d 73			      ld    (HL), E 
920e 23			      inc   HL 
920f 72			      ld    (HL), D 
9210			 
9210			free_check_adjacent_to_prev: 
9210			      ; Check if the freed block is adjacent to the prev free block 
9210 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9213 dd 66 03		      ld    H, (IX+3) 
9216			 
9216 23			      inc   HL                      ; Size of prev free block into DE 
9217 23			      inc   HL 
9218 5e			      ld    E, (HL) 
9219 23			      inc   HL 
921a 56			      ld    D, (HL) 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e 19			      add   HL, DE                  ; Add prev block addr and size 
921f			 
921f b7			      or    A                       ; Clear the carry flag 
9220 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9222 20 2e		      jr    NZ, free_done 
9224			 
9224			      ; Freed block is adjacent to prev, merge into one bigger block 
9224 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9225 69			      ld    L, C 
9226 5e			      ld    E, (HL) 
9227 23			      inc   HL 
9228 56			      ld    D, (HL) 
9229 e5			      push  HL                      ; Save freed block ptr for later 
922a			 
922a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
922d dd 66 03		      ld    H, (IX+3) 
9230 73			      ld    (HL), E 
9231 23			      inc   HL 
9232 72			      ld    (HL), D 
9233			 
9233 e1			      pop   HL                      ; Restore freed block ptr 
9234 23			      inc   HL                      ; Load size of freed block into DE 
9235 5e			      ld    E, (HL) 
9236 23			      inc   HL 
9237 56			      ld    D, (HL) 
9238 d5			      push  DE                      ; Save freed block size for later 
9239			 
9239 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
923c dd 66 03		      ld    H, (IX+3) 
923f 23			      inc   HL 
9240 23			      inc   HL 
9241 5e			      ld    E, (HL) 
9242 23			      inc   HL 
9243 56			      ld    D, (HL) 
9244			 
9244 e1			      pop   HL                      ; Add sizes of both blocks 
9245 19			      add   HL, DE 
9246 eb			      ex    DE, HL 
9247			 
9247 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
924a dd 66 03		      ld    H, (IX+3) 
924d 23			      inc   HL 
924e 23			      inc   HL 
924f 73			      ld    (HL), E 
9250 23			      inc   HL 
9251 72			      ld    (HL), D 
9252			 
9252			free_done: 
9252 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9255 39			      add   HL, SP 
9256 f9			      ld    SP, HL 
9257			 
9257			free_early_exit: 
9257 dd e1		      pop   IX 
9259 d1			      pop   DE 
925a c1			      pop   BC 
925b			 
925b c9			      ret 
925c			 
925c			; moved to firmware.asm 
925c			; 
925c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925c			;                  .dw   0 
925c			 
925c			 
925c			endif 
925c			 
925c			 
925c			if MALLOC_3 
925c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
925c			;heap_start        .equ  0x9000      ; Starting address of heap 
925c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
925c			; 
925c			 ;     .org 0 
925c			  ;    jp    main 
925c			; 
925c			; 
925c			 ;     .org  0x100 
925c			;main: 
925c			 ;     ld    HL, 0x8100 
925c			  ;    ld    SP, HL 
925c			; 
925c			;      call  heap_init 
925c			 
925c			      ; Make some allocations 
925c			;      ld    HL, 12 
925c			;      call  malloc            ; Allocates 0x9004 
925c			; 
925c			 ;     ld    HL, 12 
925c			;      call  malloc            ; Allocates 0x9014 
925c			 
925c			;      ld    HL, 12 
925c			;      call  malloc            ; Allocates 0x9024 
925c			 
925c			      ; Free some allocations 
925c			;      ld    HL, 0x9014 
925c			;      call  free 
925c			 
925c			;      ld    HL, 0x9004 
925c			;      call  free 
925c			; 
925c			;      ld    HL, 0x9024 
925c			;      call  free 
925c			 
925c			 
925c			 ;     halt 
925c			 
925c			 
925c			;------------------------------------------------------------------------------ 
925c			;     heap_init                                                               : 
925c			;                                                                             : 
925c			; Description                                                                 : 
925c			;     Initialise the heap and make it ready for malloc and free operations.   : 
925c			;                                                                             : 
925c			;     The heap is maintained as a linked list, starting with an initial       : 
925c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
925c			;     the first free block in the heap. Each block then points to the next    : 
925c			;     free block within the heap, and the free list ends at the first block   : 
925c			;     with a null pointer to the next free block.                             : 
925c			;                                                                             : 
925c			; Parameters                                                                  : 
925c			;     Inputs are compile-time only. Two defines which specify the starting    : 
925c			;     address of the heap and its size are required, along with a memory      : 
925c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
925c			;     principally stores a pointer to the first free block in the heap.       : 
925c			;                                                                             : 
925c			; Returns                                                                     : 
925c			;     Nothing                                                                 : 
925c			;------------------------------------------------------------------------------ 
925c			heap_init: 
925c			      push  HL 
925c			 
925c			      ; Initialise free list struct 
925c			      ld    HL, heap_start 
925c			      ld    (free_list), HL 
925c			      ld    HL, 0 
925c			      ld    (free_list+2), HL 
925c			 
925c			      ; Insert first free block at bottom of heap, consumes entire heap 
925c			      ld    HL, heap_start+heap_size-4 
925c			      ld    (heap_start), HL        ; Next block (end of free list) 
925c			      ld    HL, heap_size-4 
925c			      ld    (heap_start+2), HL      ; Block size 
925c			 
925c			      ; Insert end of free list block at top of heap - two null words will 
925c			      ; terminate the free list 
925c			      ld    HL, 0 
925c			      ld    (heap_start+heap_size-2), HL 
925c			      ld    (heap_start+heap_size-4), HL 
925c			 
925c			      pop   HL 
925c			 
925c			      ret 
925c			 
925c			 
925c			;------------------------------------------------------------------------------ 
925c			;     malloc                                                                  : 
925c			;                                                                             : 
925c			; Description                                                                 : 
925c			;     Allocates the wanted space from the heap and returns the address of the : 
925c			;     first useable byte of the allocation.                                   : 
925c			;                                                                             : 
925c			;     Allocations can happen in one of two ways:                              : 
925c			;                                                                             : 
925c			;     1. A free block may be found which is the exact size wanted. In this    : 
925c			;        case the block is removed from the free list and retuedn to the      : 
925c			;        caller.                                                              : 
925c			;     2. A free block may be found which is larger than the size wanted. In   : 
925c			;        this case, the larger block is split into two. The first portion of  : 
925c			;        this block will become the requested space by the malloc call and    : 
925c			;        is returned to the caller. The second portion becomes a new free     : 
925c			;        block, and the free list is adjusted to maintain continuity via this : 
925c			;        newly created block.                                                 : 
925c			;                                                                             : 
925c			;     malloc does not set any initial value in the allocated space, the       : 
925c			;     caller is required to do this as required.                              : 
925c			;                                                                             : 
925c			;     This implementation of malloc uses the stack exclusively, and is        : 
925c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925c			;     advisable to disable interrupts before calling malloc, and recommended  : 
925c			;     to avoid the use of malloc inside ISRs in general.                      : 
925c			;                                                                             : 
925c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925c			;                                                                             : 
925c			; Parameters                                                                  : 
925c			;     HL  Number of bytes wanted                                              : 
925c			;                                                                             : 
925c			; Returns                                                                     : 
925c			;     HL  Address of the first useable byte of the allocation                 : 
925c			;                                                                             : 
925c			; Flags                                                                       : 
925c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
925c			;                                                                             : 
925c			; Stack frame                                                                 : 
925c			;       |             |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |     BC      |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |     DE      |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |     IX      |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |  prev_free  |                                                       : 
925c			;   +4  +-------------+                                                       : 
925c			;       |  this_free  |                                                       : 
925c			;   +2  +-------------+                                                       : 
925c			;       |  next_free  |                                                       : 
925c			;   +0  +-------------+                                                       : 
925c			;       |             |                                                       : 
925c			;                                                                             : 
925c			;------------------------------------------------------------------------------ 
925c			malloc: 
925c			      push  BC 
925c			      push  DE 
925c			      push  IX 
925c			 
925c			      ld    A, H                    ; Exit if no space requested 
925c			      or    L 
925c			      jp    Z, malloc_early_exit 
925c			 
925c			      ; Set up stack frame 
925c			      ex    DE, HL 
925c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
925c			      add   HL, SP 
925c			      ld    SP, HL 
925c			      ld    IX, 0                   ; Use IX as a frame pointer 
925c			      add   IX, SP 
925c			 
925c			      ; Setup initial state 
925c			      ld    HL, 4                   ; want must also include space used by block struct 
925c			      add   HL, DE 
925c			 
925c			      ld    B, H                    ; Move want to BC 
925c			      ld    C, L 
925c			 
925c			      ld    HL, free_list           ; Store prev_free ptr to stack 
925c			      ld    (IX+4), L 
925c			      ld    (IX+5), H 
925c			 
925c			      ld    E, (HL)                 ; Store this_free ptr to stack 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      ld    (IX+2), E 
925c			      ld    (IX+3), D 
925c			      ex    DE, HL                  ; this_free ptr into HL 
925c			 
925c			      ; Loop through free block list to find some space 
925c			malloc_find_space: 
925c			      ld    E, (HL)                 ; Load next_free ptr into DE 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			 
925c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
925c			      or    E 
925c			      jp    Z, malloc_no_space 
925c			 
925c			      ld    (IX+0), E               ; Store next_free ptr to stack 
925c			      ld    (IX+1), D 
925c			 
925c			      ; Does this block have enough space to make the allocation? 
925c			      inc   HL                      ; Load free block size into DE 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			 
925c			      ex    DE, HL                  ; Check size of block against want 
925c			      or    A                       ; Ensure carry flag clear 
925c			      sbc   HL, BC 
925c			      push  HL                      ; Store the result for later (new block size) 
925c			 
925c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
925c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
925c			 
925c			      ; this_free block is not big enough, setup ptrs to test next free block 
925c			      pop   HL                      ; Discard previous result 
925c			 
925c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
925c			      ld    H, (IX+3) 
925c			      ld    (IX+4), L 
925c			      ld    (IX+5), H 
925c			 
925c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
925c			      ld    H, (IX+1) 
925c			      ld    (IX+2), L 
925c			      ld    (IX+3), H 
925c			 
925c			      jr    malloc_find_space 
925c			 
925c			      ; split a bigger block into two - requested size and remaining size 
925c			malloc_alloc_split: 
925c			      ex    DE, HL                  ; Calculate address of new free block 
925c			      dec   HL 
925c			      dec   HL 
925c			      dec   HL 
925c			      add   HL, BC 
925c			 
925c			      ; Create a new block and point it at next_free 
925c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
925c			      ld    D, (IX+1) 
925c			 
925c			      ld    (HL), E                 ; Store next_free ptr into new block 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			      pop   DE                      ; Store size of new block into new block 
925c			      inc   HL 
925c			      ld    (HL), E 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			      ; Update this_free ptr to point to new block 
925c			      dec   HL 
925c			      dec   HL 
925c			      dec   HL 
925c			 
925c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
925c			      ld    D, (IX+3) 
925c			 
925c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
925c			      ld    (IX+3), H 
925c			 
925c			      ; Modify this_free block to be allocation 
925c			      ex    DE, HL 
925c			      xor   A                       ; Null the next block ptr of allocated block 
925c			      ld    (HL), A 
925c			      inc   HL 
925c			      ld    (HL), A 
925c			 
925c			      inc   HL                      ; Store want size into allocated block 
925c			      ld    (HL), C 
925c			      inc   HL 
925c			      ld    (HL), B 
925c			      inc   HL 
925c			      push  HL                      ; Address of allocation to return 
925c			 
925c			      jr    malloc_update_links 
925c			 
925c			malloc_alloc_fit: 
925c			      pop   HL                      ; Dont need new block size, want is exact fit 
925c			 
925c			      ; Modify this_free block to be allocation 
925c			      ex    DE, HL 
925c			      dec   HL 
925c			      dec   HL 
925c			      dec   HL 
925c			 
925c			      xor   A                       ; Null the next block ptr of allocated block 
925c			      ld    (HL), A 
925c			      inc   HL 
925c			      ld    (HL), A 
925c			 
925c			      inc   HL                      ; Store address of allocation to return 
925c			      inc   HL 
925c			      inc   HL 
925c			      push  HL 
925c			 
925c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
925c			      ld    L, (IX+0)               ; next_free to HL 
925c			      ld    H, (IX+1) 
925c			 
925c			      ld    (IX+2), L               ; HL to this_free 
925c			      ld    (IX+3), H 
925c			 
925c			 
925c			malloc_update_links: 
925c			      ; Update prev_free ptr to point to this_free 
925c			      ld    L, (IX+4)               ; prev_free ptr to HL 
925c			      ld    H, (IX+5) 
925c			 
925c			      ld    E, (IX+2)               ; this_free ptr to DE 
925c			      ld    D, (IX+3) 
925c			 
925c			      ld    (HL), E                 ; this_free ptr into prev_free 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			      ; Clear the Z flag to indicate successful allocation 
925c			      ld    A, D 
925c			      or    E 
925c			 
925c			      pop   DE                      ; Address of allocation 
925c			 
925c			malloc_no_space: 
925c			      ld    HL, 6                   ; Clean up stack frame 
925c			      add   HL, SP 
925c			      ld    SP, HL 
925c			 
925c			      ex    DE, HL                  ; Alloc addr into HL for return 
925c			 
925c			malloc_early_exit: 
925c			      pop   IX 
925c			      pop   DE 
925c			      pop   BC 
925c			 
925c			      ret 
925c			 
925c			 
925c			;------------------------------------------------------------------------------ 
925c			;     free                                                                    : 
925c			;                                                                             : 
925c			; Description                                                                 : 
925c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
925c			;     returned by malloc, otherwise the behaviour is undefined.               : 
925c			;                                                                             : 
925c			;     Where possible, directly adjacent free blocks will be merged together   : 
925c			;     into larger blocks to help ensure that the heap does not become         : 
925c			;     excessively fragmented.                                                 : 
925c			;                                                                             : 
925c			;     free does not clear or set any other value into the freed space, and    : 
925c			;     therefore its contents may be visible through subsequent malloc's. The  : 
925c			;     caller should clear the freed space as required.                        : 
925c			;                                                                             : 
925c			;     This implementation of free uses the stack exclusively, and is          : 
925c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
925c			;     advisable to disable interrupts before calling free, and recommended    : 
925c			;     to avoid the use of free inside ISRs in general.                        : 
925c			;                                                                             : 
925c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
925c			;                                                                             : 
925c			; Parameters                                                                  : 
925c			;     HL  Pointer to address of first byte of allocation to be freed          : 
925c			;                                                                             : 
925c			; Returns                                                                     : 
925c			;     Nothing                                                                 : 
925c			;                                                                             : 
925c			; Stack frame                                                                 : 
925c			;       |             |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |     BC      |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |     DE      |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |     IX      |                                                       : 
925c			;       +-------------+                                                       : 
925c			;       |  prev_free  |                                                       : 
925c			;   +2  +-------------+                                                       : 
925c			;       |  next_free  |                                                       : 
925c			;   +0  +-------------+                                                       : 
925c			;       |             |                                                       : 
925c			;                                                                             : 
925c			;------------------------------------------------------------------------------ 
925c			free: 
925c			      push  BC 
925c			      push  DE 
925c			      push  IX 
925c			 
925c			      ld    A, H                    ; Exit if ptr is null 
925c			      or    L 
925c			      jp    Z, free_early_exit 
925c			 
925c			      ; Set up stack frame 
925c			      ex    DE, HL 
925c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
925c			      add   HL, SP 
925c			      ld    SP, HL 
925c			      ld    IX, 0                   ; Use IX as a frame pointer 
925c			      add   IX, SP 
925c			 
925c			      ; The address in HL points to the start of the useable allocated space, 
925c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
925c			      ; address of the block itself. 
925c			      ex    DE, HL 
925c			      ld    DE, -4 
925c			      add   HL, DE 
925c			 
925c			      ; An allocated block must have a null next block pointer in it 
925c			      ld    A, (HL) 
925c			      inc   HL 
925c			      or    (HL) 
925c			      jp    NZ, free_done 
925c			 
925c			      dec   HL 
925c			 
925c			      ld    B, H                    ; Copy HL to BC 
925c			      ld    C, L 
925c			 
925c			      ; Loop through the free list to find the first block with an address 
925c			      ; higher than the block being freed 
925c			      ld    HL, free_list 
925c			 
925c			free_find_higher_block: 
925c			      ld    E, (HL)                 ; Load next ptr from free block 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      dec   HL 
925c			 
925c			      ld    (IX+0), E               ; Save ptr to next free block 
925c			      ld    (IX+1), D 
925c			      ld    (IX+2), L               ; Save ptr to prev free block 
925c			      ld    (IX+3), H 
925c			 
925c			      ld    A, B                    ; Check if DE is greater than BC 
925c			      cp    D                       ; Compare MSB first 
925c			      jr    Z, $+4                  ; MSB the same, compare LSB 
925c			      jr    NC, free_find_higher_block_skip 
925c			      ld    A, C 
925c			      cp    E                       ; Then compare LSB 
925c			      jr    C, free_found_higher_block 
925c			 
925c			free_find_higher_block_skip: 
925c			      ld    A, D                    ; Reached the end of the free list? 
925c			      or    E 
925c			      jp    Z, free_done 
925c			 
925c			      ex    DE, HL 
925c			 
925c			      jr    free_find_higher_block 
925c			 
925c			free_found_higher_block: 
925c			      ; Insert freed block between prev and next free blocks 
925c			      ld    (HL), C                 ; Point prev free block to freed block 
925c			      inc   HL 
925c			      ld    (HL), B 
925c			 
925c			      ld    H, B                    ; Point freed block at next free block 
925c			      ld    L, C 
925c			      ld    (HL), E 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			      ; Check if the freed block is adjacent to the next free block 
925c			      inc   HL                      ; Load size of freed block into HL 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      ex    DE, HL 
925c			 
925c			      add   HL, BC                  ; Add addr of freed block and its size 
925c			 
925c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
925c			      ld    D, (IX+1) 
925c			 
925c			      or    A                       ; Clear the carry flag 
925c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
925c			      jr    NZ, free_check_adjacent_to_prev 
925c			 
925c			      ; Freed block is adjacent to next, merge into one bigger block 
925c			      ex    DE, HL                  ; Load next ptr from next block into DE 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      push  HL                      ; Save ptr to next block for later 
925c			 
925c			      ld    H, B                    ; Store ptr from next block into freed block 
925c			      ld    L, C 
925c			      ld    (HL), E 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			      pop   HL                      ; Restore ptr to next block 
925c			      inc   HL                      ; Load size of next block into DE 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      push  DE                      ; Save next block size for later 
925c			 
925c			      ld    H, B                    ; Load size of freed block into HL 
925c			      ld    L, C 
925c			      inc   HL 
925c			      inc   HL 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      ex    DE, HL 
925c			 
925c			      pop   DE                      ; Restore size of next block 
925c			      add   HL, DE                  ; Add sizes of both blocks 
925c			      ex    DE, HL 
925c			 
925c			      ld    H, B                    ; Store new bigger size into freed block 
925c			      ld    L, C 
925c			      inc   HL 
925c			      inc   HL 
925c			      ld    (HL), E 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			free_check_adjacent_to_prev: 
925c			      ; Check if the freed block is adjacent to the prev free block 
925c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
925c			      ld    H, (IX+3) 
925c			 
925c			      inc   HL                      ; Size of prev free block into DE 
925c			      inc   HL 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      dec   HL 
925c			      dec   HL 
925c			      dec   HL 
925c			 
925c			      add   HL, DE                  ; Add prev block addr and size 
925c			 
925c			      or    A                       ; Clear the carry flag 
925c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
925c			      jr    NZ, free_done 
925c			 
925c			      ; Freed block is adjacent to prev, merge into one bigger block 
925c			      ld    H, B                    ; Load next ptr from freed block into DE 
925c			      ld    L, C 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      push  HL                      ; Save freed block ptr for later 
925c			 
925c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
925c			      ld    H, (IX+3) 
925c			      ld    (HL), E 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			      pop   HL                      ; Restore freed block ptr 
925c			      inc   HL                      ; Load size of freed block into DE 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			      push  DE                      ; Save freed block size for later 
925c			 
925c			      ld    L, (IX+2)               ; Load size of prev block into DE 
925c			      ld    H, (IX+3) 
925c			      inc   HL 
925c			      inc   HL 
925c			      ld    E, (HL) 
925c			      inc   HL 
925c			      ld    D, (HL) 
925c			 
925c			      pop   HL                      ; Add sizes of both blocks 
925c			      add   HL, DE 
925c			      ex    DE, HL 
925c			 
925c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
925c			      ld    H, (IX+3) 
925c			      inc   HL 
925c			      inc   HL 
925c			      ld    (HL), E 
925c			      inc   HL 
925c			      ld    (HL), D 
925c			 
925c			free_done: 
925c			      ld    HL, 4                   ; Clean up stack frame 
925c			      add   HL, SP 
925c			      ld    SP, HL 
925c			 
925c			free_early_exit: 
925c			      pop   IX 
925c			      pop   DE 
925c			      pop   BC 
925c			 
925c			      ret 
925c			 
925c			 
925c			;      .org 0x8000 
925c			; 
925c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
925c			 ;                 .dw   0 
925c			 
925c			endif 
925c			 
925c			 
925c			if MALLOC_4 
925c			 
925c			; My memory allocation code. Very very simple.... 
925c			; allocate space under 250 chars 
925c			 
925c			heap_init: 
925c				; init start of heap as zero 
925c				;  
925c			 
925c				ld hl, heap_start 
925c				ld a, 0 
925c				ld (hl), a      ; empty block 
925c				inc hl 
925c				ld a, 0 
925c				ld (hl), a      ; length of block 
925c				; write end of list 
925c				inc hl 
925c				ld a,(hl) 
925c				inc hl 
925c				ld a,(hl) 
925c				 
925c			 
925c				; init some malloc vars 
925c			 
925c				ld hl, 0 
925c				ld (free_list), hl       ; store last malloc location 
925c			 
925c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
925c				ld a, 0 
925c				ld (hl), a 
925c			 
925c			 
925c				ld hl, heap_start 
925c				;  
925c				  
925c				ret 
925c			 
925c			 
925c			;    free block marker 
925c			;    requested size  
925c			;    pointer to next block 
925c			;    .... 
925c			;    next block marker 
925c			 
925c			 
925c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
925c			; 
925c			 
925c			 
925c			malloc:  
925c				push de 
925c				push bc 
925c				push af 
925c			 
925c				; hl space required 
925c				 
925c				ld c, l    ; hold space   (TODO only a max of 255) 
925c			 
925c			;	inc c     ; TODO BUG need to fix memory leak on push str 
925c			;	inc c 
925c			;	inc c 
925c			;	inc c 
925c			;	inc c 
925c			;	inc c 
925c			;	inc c 
925c			 
925c			 
925c			 
925c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
925c			 
925c				ld a, (free_list+3) 
925c				cp 0 
925c				jr z, .contheap 
925c			 
925c				ld hl, (free_list)     ; get last alloc 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "mrs" 
925c						CALLMONITOR 
925c					endif 
925c				jr .startalloc 
925c			 
925c			.contheap: 
925c				ld hl, heap_start 
925c			 
925c			.startalloc: 
925c			 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "mym" 
925c						CALLMONITOR 
925c					endif 
925c			.findblock: 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "mmf" 
925c						CALLMONITOR 
925c					endif 
925c			 
925c				ld a,(hl)  
925c				; if byte is zero then clear to use 
925c			 
925c				cp 0 
925c				jr z, .foundemptyblock 
925c			 
925c				; if byte is not clear 
925c				;     then byte is offset to next block 
925c			 
925c				inc hl 
925c				ld a, (hl) ; get size 
925c			.nextblock:	inc hl 
925c					ld e, (hl) 
925c					inc hl 
925c					ld d, (hl) 
925c					ex de, hl 
925c			;	inc hl  ; move past the store space 
925c			;	inc hl  ; move past zero index  
925c			 
925c				; TODO detect no more space 
925c			 
925c				push hl 
925c				ld de, heap_end 
925c				call cmp16 
925c				pop hl 
925c				jr nc, .nospace 
925c			 
925c				jr .findblock 
925c			 
925c			.nospace: ld hl, 0 
925c				jp .exit 
925c			 
925c			 
925c			.foundemptyblock:	 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "mme" 
925c						CALLMONITOR 
925c					endif 
925c			 
925c			; TODO has block enough space if reusing??? 
925c			 
925c				;  
925c			 
925c			; see if this block has been previously used 
925c				inc hl 
925c				ld a, (hl) 
925c				dec hl 
925c				cp 0 
925c				jr z, .newblock 
925c			 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "meR" 
925c						CALLMONITOR 
925c					endif 
925c			 
925c			; no reusing previously allocated block 
925c			 
925c			; is it smaller than previously used? 
925c				 
925c				inc hl    ; move to size 
925c				ld a, c 
925c				sub (hl)        ; we want c < (hl) 
925c				dec hl    ; move back to marker 
925c			        jr z, .findblock 
925c			 
925c				; update with the new size which should be lower 
925c			 
925c			        ;inc  hl   ; negate next move. move back to size  
925c			 
925c			.newblock: 
925c				; need to be at marker here 
925c			 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "meN" 
925c						CALLMONITOR 
925c					endif 
925c			 
925c			 
925c				ld a, c 
925c			 
925c				ld (free_list+3), a	 ; flag resume from last malloc  
925c				ld (free_list), hl    ; save out last location 
925c			 
925c			 
925c				;inc a     ; space for length byte 
925c				ld (hl), a     ; save block in use marker 
925c			 
925c				inc hl   ; move to space marker 
925c				ld (hl), a    ; save new space 
925c			 
925c				inc hl   ; move to start of allocated area 
925c				 
925c			;	push hl     ; save where we are - 1  
925c			 
925c			;	inc hl  ; move past zero index  
925c				; skip space to set down new marker 
925c			 
925c				; provide some extra space for now 
925c			 
925c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
925c				inc a 
925c				inc a 
925c			 
925c				push hl   ; save where we are in the node block 
925c			 
925c				call addatohl 
925c			 
925c				; write linked list point 
925c			 
925c				pop de     ; get our node position 
925c				ex de, hl 
925c			 
925c				ld (hl), e 
925c				inc hl 
925c				ld (hl), d 
925c			 
925c				inc hl 
925c			 
925c				; now at start of allocated data so save pointer 
925c			 
925c				push hl 
925c			 
925c				; jump to position of next node and setup empty header in DE 
925c			 
925c				ex de, hl 
925c			 
925c			;	inc hl ; move past end of block 
925c			 
925c				ld a, 0 
925c				ld (hl), a   ; empty marker 
925c				inc hl 
925c				ld (hl), a   ; size 
925c				inc hl  
925c				ld (hl), a   ; ptr 
925c				inc hl 
925c				ld (hl), a   ; ptr 
925c			 
925c			 
925c				pop hl 
925c			 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "mmr" 
925c						CALLMONITOR 
925c					endif 
925c			 
925c			.exit: 
925c				pop af 
925c				pop bc 
925c				pop de  
925c				ret 
925c			 
925c			 
925c			 
925c			 
925c			free:  
925c				push hl 
925c				push af 
925c				; get address in hl 
925c			 
925c					if DEBUG_FORTH_MALLOC_INT 
925c						DMARK "fre" 
925c						CALLMONITOR 
925c					endif 
925c				; data is at hl - move to block count 
925c				dec hl 
925c				dec hl    ; get past pointer 
925c				dec hl 
925c			 
925c				ld a, (hl)    ; need this for a validation check 
925c			 
925c				dec hl    ; move to block marker 
925c			 
925c				; now check that the block count and block marker are the same  
925c			        ; this checks that we are on a malloc node and not random memory 
925c			        ; OK a faint chance this could be a problem but rare - famous last words! 
925c			 
925c				ld c, a 
925c				ld a, (hl)    
925c			 
925c				cp c 
925c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
925c			 
925c				; yes good chance we are on a malloc node 
925c			 
925c				ld a, 0      
925c				ld (hl), a   ; mark as free 
925c			 
925c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
925c			 
925c			.freeignore:  
925c			 
925c				pop af 
925c				pop hl 
925c			 
925c				ret 
925c			 
925c			 
925c			 
925c			endif 
925c			 
925c			; eof 
# End of file firmware_memory.asm
925c			  
925c			; device C  
925c			; Now handled by SPI  
925c			;if SOUND_ENABLE  
925c			;	include "firmware_sound.asm"  
925c			;endif  
925c			  
925c			include "firmware_diags.asm"  
925c			; Hardware diags menu 
925c			 
925c			 
925c			config: 
925c			 
925c 3e 00			ld a, 0 
925e 21 82 92			ld hl, .configmn 
9261 cd df 8a			call menu 
9264			 
9264 fe 00			cp 0 
9266 c8				ret z 
9267			 
9267			;	cp 1 
9267			;	call z, .savetostore 
9267			 
9267 fe 01			cp 1 
9269			if STARTUP_V1 
9269 cc 98 92			call z, .selautoload 
926c			endif 
926c			 
926c			if STARTUP_V2 
926c				call z, .enautoload 
926c			endif 
926c fe 02			cp 2 
926e cc 8e 92			call z, .disautoload 
9271			;	cp 3 
9271			;	call z, .selbank 
9271 fe 03			cp 3 
9273 cc b6 92			call z, .debug_tog 
9276 fe 04			cp 4 
9278 cc 04 94			call z, .bpsgo 
927b fe 05			cp 5 
927d cc df 92			call z, hardware_diags 
9280			if STARTUP_V2 
9280				cp 6 
9280				call z, create_startup 
9280			endif 
9280 18 da			jr config 
9282			 
9282			.configmn: 
9282			;	dw prom_c3 
9282 f2 95			dw prom_c2 
9284 07 96			dw prom_c2a 
9286			;	dw prom_c2b 
9286			;	dw prom_c4 
9286 26 96			dw prom_m4 
9288 41 96			dw prom_m4b 
928a 49 96			dw prom_c1 
928c			if STARTUP_V2 
928c				dw prom_c9 
928c			endif 
928c 00 00			dw 0 
928e				 
928e			 
928e			if STARTUP_V2 
928e			.enautoload: 
928e				if STORAGE_SE 
928e				ld a, $fe      ; bit 0 clear 
928e				ld (spi_device), a 
928e			 
928e				call storage_get_block_0 
928e			 
928e				ld a, 1 
928e				ld (store_page+STORE_0_AUTOFILE), a 
928e			 
928e					ld hl, 0 
928e					ld de, store_page 
928e				call storage_write_block	 ; save update 
928e				else 
928e			 
928e				ld hl, prom_notav 
928e				ld de, prom_empty 
928e				call info_panel 
928e				endif 
928e			 
928e			 
928e				ret 
928e			endif 
928e			 
928e			.disautoload: 
928e				if STORAGE_SE 
928e				ld a, $fe      ; bit 0 clear 
928e				ld (spi_device), a 
928e			 
928e				call storage_get_block_0 
928e			 
928e				ld a, 0 
928e				ld (store_page+STORE_0_AUTOFILE), a 
928e			 
928e					ld hl, 0 
928e					ld de, store_page 
928e				call storage_write_block	 ; save update 
928e				else 
928e			 
928e 21 58 96			ld hl, prom_notav 
9291 11 6e 96			ld de, prom_empty 
9294 cd 3f 8a			call info_panel 
9297				endif 
9297			 
9297			 
9297 c9				ret 
9298			 
9298			if STARTUP_V1 
9298			 
9298			; Select auto start 
9298			 
9298			.selautoload: 
9298			 
9298				 
9298				if STORAGE_SE 
9298			 
9298					call config_dir 
9298				        ld hl, scratch 
9298					ld a, 0 
9298					call menu 
9298			 
9298					cp 0 
9298					ret z 
9298			 
9298					dec a 
9298			 
9298			 
9298					; locate menu option 
9298			 
9298					ld hl, scratch 
9298					call table_lookup 
9298			 
9298					if DEBUG_FORTH_WORDS 
9298						DMARK "ALl" 
9298						CALLMONITOR 
9298					endif 
9298					; with the pointer to the menu it, the byte following the zero term is the file id 
9298			 
9298					ld a, 0 
9298					ld bc, 50   ; max of bytes to look at 
9298					cpir  
9298			 
9298					if DEBUG_FORTH_WORDS 
9298						DMARK "ALb" 
9298						CALLMONITOR 
9298					endif 
9298					;inc hl 
9298			 
9298					ld a, (hl)   ; file id 
9298					 
9298				        ; save bank and file ids 
9298			 
9298					push af 
9298			 
9298			; TODO need to save to block 0 on bank 1	 
9298			 
9298					call storage_get_block_0 
9298			 
9298					if DEBUG_FORTH_WORDS 
9298						DMARK "AL0" 
9298						CALLMONITOR 
9298					endif 
9298					pop af 
9298			 
9298					ld (store_page+STORE_0_FILERUN),a 
9298					 
9298					; save bank id 
9298			 
9298					ld a,(spi_device) 
9298					ld (store_page+STORE_0_BANKRUN),a 
9298			 
9298					; enable auto run of store file 
9298			 
9298					ld a, 1 
9298					ld (store_page+STORE_0_AUTOFILE),a 
9298			 
9298					; save buffer 
9298			 
9298					ld hl, 0 
9298					ld de, store_page 
9298					if DEBUG_FORTH_WORDS 
9298						DMARK "ALw" 
9298						CALLMONITOR 
9298					endif 
9298				call storage_write_block	 ; save update 
9298			  
9298			 
9298			 
9298			 
9298					ld hl, scratch 
9298					call config_fdir 
9298			 
9298				else 
9298			 
9298 21 58 96			ld hl, prom_notav 
929b 11 6e 96			ld de, prom_empty 
929e cd 3f 8a			call info_panel 
92a1			 
92a1				endif 
92a1 c9				ret 
92a2			endif 
92a2			 
92a2			 
92a2			; Select storage bank 
92a2			 
92a2			.selbank: 
92a2			 
92a2			;	if STORAGE_SE 
92a2			;	else 
92a2			 
92a2 21 58 96			ld hl, prom_notav 
92a5 11 6e 96			ld de, prom_empty 
92a8 cd 3f 8a			call info_panel 
92ab			;	endif 
92ab				 
92ab c9				ret 
92ac			 
92ac			if STORAGE_SE 
92ac			 
92ac			.config_ldir:   
92ac				; Load storage bank labels into menu array 
92ac			 
92ac				 
92ac			 
92ac			 
92ac				ret 
92ac			 
92ac			 
92ac			endif 
92ac			 
92ac			 
92ac			; Save user words to storage 
92ac			 
92ac			.savetostore: 
92ac			 
92ac			;	if STORAGE_SE 
92ac			; 
92ac			;		call config_dir 
92ac			;	        ld hl, scratch 
92ac			;		ld a, 0 
92ac			;		call menu 
92ac			;		 
92ac			;		ld hl, scratch 
92ac			;		call config_fdir 
92ac			; 
92ac			;	else 
92ac			 
92ac 21 58 96			ld hl, prom_notav 
92af 11 6e 96			ld de, prom_empty 
92b2 cd 3f 8a			call info_panel 
92b5			 
92b5			;	endif 
92b5			 
92b5 c9				ret 
92b6			 
92b6			if STARTUP_V2 
92b6			 
92b6			create_startup: 
92b6			 
92b6				ld a, 0 
92b6				ld hl, .crstart 
92b6				call menu 
92b6			 
92b6				cp 0 
92b6				ret z 
92b6			 
92b6				cp 1 
92b6				call z, .genlsword 
92b6				cp 2 
92b6				call z, .genedword 
92b6			 
92b6				cp 3 
92b6				call z, .gendemword 
92b6			 
92b6				cp 4 
92b6				call z, .genutlword 
92b6				cp 5 
92b6				call z, .genspiword 
92b6				cp 6 
92b6				call z, .genkeyword 
92b6				cp 7 
92b6				call z, .gensoundword 
92b6				jr create_startup 
92b6			 
92b6			.gensoundword: 
92b6				ld hl, crs_sound 
92b6				ld de, .soundworddef 
92b6				call .genfile 
92b6				ret 
92b6			.genlsword: 
92b6				ld hl, crs_s1 
92b6				ld de, .lsworddef 
92b6				call .genfile 
92b6				ret 
92b6			 
92b6			.genedword: 
92b6				ld de, .edworddef 
92b6				ld hl, crs_s2 
92b6				call .genfile 
92b6				ret 
92b6			 
92b6			.gendemword: 
92b6				ld de, .demoworddef 
92b6				ld hl, crs_s3 
92b6				call .genfile 
92b6				ret 
92b6			 
92b6			.genutlword: 
92b6				ld hl, crs_s4 
92b6				ld de, .utilwordef 
92b6				call .genfile 
92b6				ret 
92b6			.genspiword: 
92b6				ld hl, crs_s5 
92b6				ld de, .spiworddef 
92b6				call .genfile 
92b6				ret 
92b6			.genkeyword: 
92b6				ld hl, crs_s6 
92b6				ld de, .keyworddef 
92b6				call .genfile 
92b6				ret 
92b6			 
92b6			; hl - points to file name 
92b6			; de - points to strings to add to file 
92b6			 
92b6			.genfile: 
92b6				push hl 
92b6				push de 
92b6			 
92b6				call clear_display 
92b6				ld a, display_row_1 
92b6				ld de, .genfiletxt 
92b6				call str_at_display 
92b6				call update_display 
92b6			 
92b6				pop de 
92b6				pop hl 
92b6			 
92b6			 
92b6				push de 
92b6				call storage_create 
92b6				; id in hl 
92b6				pop de   ; table of strings to add 
92b6			 
92b6			.genloop: 
92b6			 
92b6				push hl ; save id for next time around 
92b6				push de ; save de for next time around 
92b6			 
92b6				ex de, hl 
92b6				call loadwordinhl 
92b6				ex de, hl 
92b6			 
92b6				; need hl to be the id 
92b6				; need de to be the string ptr 
92b6				 
92b6				call storage_append 
92b6			 
92b6				pop de 
92b6				pop hl 
92b6			 
92b6				inc de 
92b6				inc de 
92b6			 
92b6				ld a,(de) 
92b6				cp 0 
92b6				jr nz, .genloop 
92b6				inc de 
92b6				ld a, (de) 
92b6				dec de 
92b6				cp 0 
92b6				jr nz, .genloop	 
92b6			 
92b6				ret 
92b6			 
92b6			.genfiletxt:  db "Creating file...",0 
92b6			 
92b6			.soundworddef: 
92b6				dw sound1 
92b6				dw sound2 
92b6				dw sound3 
92b6				dw sound4 
92b6				dw sound5 
92b6				dw sound6 
92b6				dw sound7 
92b6				dw sound8 
92b6				dw sound9 
92b6				dw 0 
92b6			 
92b6			.utilwordef: 
92b6				dw strncpy 
92b6				dw type 
92b6				dw clrstack 
92b6				dw longread 
92b6				dw start1 
92b6				dw start2 
92b6			; duplicated 
92b6			;	dw start3b 
92b6			;	dw start3c 
92b6				dw list 
92b6				dw 0 
92b6			 
92b6			.lsworddef: 
92b6				dw start3b 
92b6				dw 0 
92b6			 
92b6			.edworddef: 
92b6				dw edit1 
92b6				dw edit2 
92b6				dw edit3 
92b6				dw 0 
92b6			 
92b6			.demoworddef: 
92b6				dw test5 
92b6				dw test6 
92b6				dw test7 
92b6				dw test8 
92b6				dw test9 
92b6				dw test10 
92b6				dw game1 
92b6				dw game1a 
92b6				dw game1b 
92b6				dw game1c 
92b6				dw game1d 
92b6				dw game1s 
92b6				dw game1t 
92b6				dw game1f 
92b6				dw game1z 
92b6				dw game1zz 
92b6				dw ssv2 
92b6				dw ssv3 
92b6				dw ssv4 
92b6				dw ssv5 
92b6				dw ssv1 
92b6				dw ssv1cpm	 
92b6				dw game2b 
92b6				dw game2bf 
92b6				dw game2mba 
92b6				dw game2mbas	 
92b6				dw game2mbht 
92b6				dw game2mbms 
92b6				dw game2mb 
92b6				dw game3w 
92b6				dw game3p 
92b6				dw game3sc 
92b6				dw game3vsi 
92b6				dw game3vs 
92b6				dw 0 
92b6			 
92b6			 
92b6			.spiworddef: 
92b6			 
92b6			    dw spi1 
92b6			    dw spi2 
92b6			    dw spi2b 
92b6			    dw spi3 
92b6			    dw spi4 
92b6			    dw spi5 
92b6			;    dw spi6 
92b6			;    dw spi7 
92b6			 
92b6			;    dw spi8 
92b6			;    dw spi9 
92b6			;    dw spi10 
92b6			    dw 0 
92b6			 
92b6			.keyworddef: 
92b6			 
92b6				dw keyup 
92b6				dw keydown 
92b6				dw keyleft 
92b6				dw keyright 
92b6				dw 	keyf1 
92b6				dw keyf2 
92b6				dw keyf3 
92b6				dw keyf4 
92b6				dw keyf5 
92b6				dw keyf6 
92b6				dw keyf7 
92b6				dw keyf8 
92b6				dw keyf9 
92b6				dw keyf10 
92b6				dw keyf11 
92b6				dw keyf12 
92b6				dw keytab 
92b6				dw keycr 
92b6				dw keyhome 
92b6				dw keyend 
92b6				dw keybs 
92b6				dw 0 
92b6			 
92b6			.crstart: 
92b6				dw crs_s1 
92b6				dw crs_s2 
92b6				dw crs_s3 
92b6				dw crs_s4 
92b6				dw crs_s5 
92b6				dw crs_s6 
92b6				dw crs_sound 
92b6				dw 0 
92b6			 
92b6			endif 
92b6			 
92b6			 
92b6			if STORAGE_SE 
92b6			 
92b6			config_fdir: 
92b6				; using the scratch dir go through and release the memory allocated for each string 
92b6				 
92b6				ld hl, scratch 
92b6			.cfdir:	ld e,(hl) 
92b6				inc hl 
92b6				ld d,(hl) 
92b6				inc hl 
92b6			 
92b6				ex de, hl 
92b6				call ishlzero 
92b6				ret z     ; return on null pointer 
92b6				call free 
92b6				ex de, hl 
92b6				jr .cfdir 
92b6			 
92b6			 
92b6				ret 
92b6			 
92b6			 
92b6			config_dir: 
92b6			 
92b6				; for the config menus that need to build a directory of storage call this routine 
92b6				; it will construct a menu in scratch to pass to menu 
92b6			 
92b6				; open storage device 
92b6			 
92b6				; execute DIR to build a list of files and their ids into scratch in menu format 
92b6				; once the menu has finished then will need to call config_fdir to release the strings 
92b6				 
92b6				; c = number items 
92b6			 
92b6				 
92b6				call storage_get_block_0 
92b6			 
92b6				ld hl, store_page     ; get current id count 
92b6				ld b, (hl) 
92b6				ld c, 0    ; count of files   
92b6			 
92b6			 
92b6				ld hl, scratch 
92b6				ld (store_tmp2), hl    ; location to poke strings 
92b6			 
92b6				; check for empty drive 
92b6			 
92b6				ld a, 0 
92b6				cp b 
92b6				jp z, .dirdone 
92b6			 
92b6				 
92b6					if DEBUG_FORTH_WORDS 
92b6						DMARK "Cdc" 
92b6						CALLMONITOR 
92b6					endif 
92b6			 
92b6			 
92b6			.diritem:	 
92b6				push bc 
92b6				; for each of the current ids do a search for them and if found push to stack 
92b6			 
92b6					ld hl, STORE_BLOCK_PHY 
92b6					ld d, 0		 ; look for extent 0 of block id as this contains file name 
92b6					ld e,b 
92b6			 
92b6					call storage_findnextid 
92b6			 
92b6			 
92b6					; if found hl will be non zero 
92b6			 
92b6					call ishlzero 
92b6					jr z, .dirnotfound 
92b6			 
92b6					; increase count 
92b6			 
92b6					pop bc	 
92b6					inc c 
92b6					push bc 
92b6					 
92b6			 
92b6					; get file header and push the file name 
92b6			 
92b6					ld de, store_page 
92b6					call storage_read_block 
92b6			 
92b6					; push file id to stack 
92b6				 
92b6					ld a, (store_page) 
92b6					ld h, 0 
92b6					ld l, a 
92b6			 
92b6					;call forth_push_numhl 
92b6					; TODO store id 
92b6			 
92b6					push hl 
92b6			 
92b6					; push extent count to stack  
92b6				 
92b6					ld hl, store_page+3 
92b6			 
92b6					; get file name length 
92b6			 
92b6					call strlenz   
92b6			 
92b6					inc hl   ; cover zero term 
92b6					inc hl  ; stick the id at the end of the area 
92b6			 
92b6					push hl 
92b6					pop bc    ; move length to bc 
92b6			 
92b6					call malloc 
92b6			 
92b6					; TODO save malloc area to scratch 
92b6			 
92b6					ex de, hl 
92b6					ld hl, (store_tmp2) 
92b6					ld (hl), e 
92b6					inc hl 
92b6					ld (hl), d 
92b6					inc hl 
92b6					ld (store_tmp2), hl 
92b6			 
92b6					 
92b6			 
92b6					;pop hl   ; get source 
92b6			;		ex de, hl    ; swap aronund	 
92b6			 
92b6					ld hl, store_page+3 
92b6					if DEBUG_FORTH_WORDS 
92b6						DMARK "CFd" 
92b6						CALLMONITOR 
92b6					endif 
92b6					ldir 
92b6			 
92b6					; de is past string, move back one and store id 
92b6					 
92b6					dec de 
92b6			 
92b6					; store file id 
92b6			 
92b6					pop hl 
92b6					ex de,hl 
92b6					ld (hl), e 
92b6			 
92b6					if DEBUG_FORTH_WORDS 
92b6						DMARK "Cdi" 
92b6						CALLMONITOR 
92b6					endif 
92b6					 
92b6			.dirnotfound: 
92b6					pop bc     
92b6					djnz .diritem 
92b6				 
92b6			.dirdone:	 
92b6			 
92b6					ld a, 0 
92b6					ld hl, (store_tmp2) 
92b6					ld (hl), a 
92b6					inc hl 
92b6					ld (hl), a 
92b6					inc hl 
92b6					; push a count of the dir items found 
92b6			 
92b6			;		ld h, 0 
92b6			;		ld l, c 
92b6			 
92b6				ret 
92b6			 
92b6			endif 
92b6			 
92b6			 
92b6			; Settings 
92b6			; Run  
92b6			 
92b6			 
92b6			 
92b6			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
92b6			;;hd_menu2:   db "        2: Editor",0   
92b6			;hd_menu2:   db "        2: Editor       6: Menu",0   
92b6			;hd_menu3:   db "        3: Storage",0 
92b6			;hd_menu4:   db "0=quit  4: Debug",0 
92b6			;hd_don:     db "ON",0 
92b6			;hd_doff:     db "OFF",0 
92b6			; 
92b6			; 
92b6			; 
92b6			;hardware_diags_old:       
92b6			; 
92b6			;.diagmenu: 
92b6			;	call clear_display 
92b6			;	ld a, display_row_1 
92b6			;	ld de, hd_menu1 
92b6			;	call str_at_display 
92b6			; 
92b6			;	ld a, display_row_2 
92b6			;	ld de, hd_menu2 
92b6			;	call str_at_display 
92b6			; 
92b6			;	ld a, display_row_3 
92b6			;	ld de, hd_menu3 
92b6			;	call str_at_display 
92b6			; 
92b6			;	ld a,  display_row_4 
92b6			;	ld de, hd_menu4 
92b6			;	call str_at_display 
92b6			; 
92b6			;	; display debug state 
92b6			; 
92b6			;	ld de, hd_don 
92b6			;	ld a, (os_view_disable) 
92b6			;	cp 0 
92b6			;	jr z, .distog 
92b6			;	ld de, hd_doff 
92b6			;.distog: ld a, display_row_4+17 
92b6			;	call str_at_display 
92b6			; 
92b6			;	call update_display 
92b6			; 
92b6			;	call cin_wait 
92b6			; 
92b6			; 
92b6			; 
92b6			;	cp '4' 
92b6			;	jr nz, .diagn1 
92b6			; 
92b6			;	; debug toggle 
92b6			; 
92b6			;	ld a, (os_view_disable) 
92b6			;	ld b, '*' 
92b6			;	cp 0 
92b6			;	jr z, .debtog 
92b6			;	ld b, 0 
92b6			;.debtog:	 
92b6			;	ld a,b 
92b6			;	ld (os_view_disable),a 
92b6			; 
92b6			;.diagn1: cp '0' 
92b6			;	 ret z 
92b6			; 
92b6			;;	cp '1' 
92b6			;;       jp z, matrix	 
92b6			;;   TODO keyboard matrix test 
92b6			; 
92b6			;	cp '2' 
92b6			;	jp z, .diagedit 
92b6			; 
92b6			;;	cp '6' 
92b6			;;	jp z, .menutest 
92b6			;;if ENABLE_BASIC 
92b6			;;	cp '6' 
92b6			;;	jp z, basic 
92b6			;;endif 
92b6			 ; 
92b6			;	jp .diagmenu 
92b6			; 
92b6			; 
92b6			;	ret 
92b6			 
92b6			 
92b6			.debug_tog: 
92b6 21 00 93			ld hl, .menudebug 
92b9				 
92b9			;	ld a, (os_view_disable) 
92b9			;	cp '*' 
92b9 3a 6f ee			ld a,(debug_vector) 
92bc fe c9			cp $C9   ; RET 
92be 20 04			jr nz,.tdon  
92c0 3e 01			ld a, 1 
92c2 18 02			jr .tog1 
92c4 3e 00		.tdon: ld a, 0 
92c6			 
92c6			.tog1: 
92c6 cd df 8a			call menu 
92c9 fe 00			cp 0 
92cb c8				ret z 
92cc fe 01			cp 1    ; disable debug 
92ce 28 04			jr z, .dtog0 
92d0 3e 2a			ld a, '*' 
92d2 18 05			jr .dtogset 
92d4			.dtog0:  
92d4				;ld a, 0 
92d4 cd f2 93			call bp_on 
92d7 18 dd			jr .debug_tog 
92d9			.dtogset:  
92d9				; ld (os_view_disable), a 
92d9 cd fe 93			call bp_off 
92dc c3 b6 92			jp .debug_tog 
92df			 
92df			 
92df			hardware_diags:       
92df			 
92df			.diagm: 
92df 21 f2 92			ld hl, .menuitems 
92e2 3e 00			ld a, 0 
92e4 cd df 8a			call menu 
92e7			 
92e7 fe 00		         cp 0 
92e9 c8				 ret z 
92ea			 
92ea fe 02			cp 2 
92ec ca 4b 93			jp z, .diagedit 
92ef			 
92ef			;	cp '6' 
92ef			;	jp z, .menutest 
92ef			;if ENABLE_BASIC 
92ef			;	cp '6' 
92ef			;	jp z, basic 
92ef			;endif 
92ef			  
92ef c3 df 92			jp .diagm 
92f2			 
92f2				 
92f2 06 93		.menuitems:   	dw .m1 
92f4 11 93				dw .m2 
92f6 18 93				dw .m3 
92f8 20 93				dw .m5 
92fa 26 93				dw .m5a 
92fc 2f 93				dw .m5b 
92fe 00 00				dw 0 
9300			 
9300			.menudebug: 
9300 38 93				dw .m6 
9302 41 93				dw .m7 
9304 00 00				dw 0 
9306			 
9306 .. 00		.m1:   db "Key Matrix",0 
9311 .. 00		.m2:   db "Editor",0 
9318 .. 00		.m3:   db "Storage",0 
9320 .. 00		.m5:   db "Sound",0 
9326 .. 00		.m5a:  db "RAM Test",0 
932f .. 00		.m5b:  db "LCD Test",0 
9338			 
9338 .. 00		.m6:   db "Debug ON",0 
9341 .. 00		.m7:   db "Debug OFF",0 
934b			 
934b			; debug editor 
934b			 
934b			.diagedit: 
934b			 
934b 21 c1 e2			ld hl, scratch 
934e			;	ld bc, 250 
934e			;	ldir 
934e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
934e 3e 00			ld a, 0 
9350 77				ld (hl), a 
9351 23				inc hl 
9352 77				ld (hl), a 
9353 23				inc hl 
9354 77				ld (hl), a 
9355			 
9355 cd ae 8a		        call clear_display 
9358 cd d1 8a			call update_display 
935b				;ld a, 1 
935b				;ld (hardware_diag), a 
935b			.diloop: 
935b 3e 00			ld a, display_row_1 
935d 0e 00			ld c, 0 
935f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9361 1e 28			ld e, 40 
9363			 
9363 21 c1 e2			ld hl, scratch	 
9366 cd 08 8d			call input_str 
9369			 
9369 3e 28			ld a, display_row_2 
936b 11 c1 e2			ld de, scratch 
936e cd c1 8a			call str_at_display 
9371 cd d1 8a			call update_display 
9374			 
9374 c3 5b 93			jp .diloop 
9377			 
9377			 
9377			; pass word in hl 
9377			; a has display location 
9377			display_word_at: 
9377 f5				push af 
9378 e5				push hl 
9379 7c				ld a,h 
937a 21 c6 e5			ld hl, os_word_scratch 
937d cd f1 8e			call hexout 
9380 e1				pop hl 
9381 7d				ld a,l 
9382 21 c8 e5			ld hl, os_word_scratch+2 
9385 cd f1 8e			call hexout 
9388 21 ca e5			ld hl, os_word_scratch+4 
938b 3e 00			ld a,0 
938d 77				ld (hl),a 
938e 11 c6 e5			ld de,os_word_scratch 
9391 f1				pop af 
9392 cd c1 8a				call str_at_display 
9395 c9				ret 
9396			 
9396			display_ptr_state: 
9396			 
9396				; to restore afterwards 
9396			 
9396 d5				push de 
9397 c5				push bc 
9398 e5				push hl 
9399 f5				push af 
939a			 
939a				; for use in here 
939a			 
939a			;	push bc 
939a			;	push de 
939a			;	push hl 
939a			;	push af 
939a			 
939a cd ae 8a			call clear_display 
939d			 
939d 11 75 95			ld de, .ptrstate 
93a0 3e 00			ld a, display_row_1 
93a2 cd c1 8a			call str_at_display 
93a5			 
93a5				; display debug step 
93a5			 
93a5			 
93a5 11 6b ee			ld de, debug_mark 
93a8 3e 26			ld a, display_row_1+display_cols-2 
93aa cd c1 8a			call str_at_display 
93ad			 
93ad				; display a 
93ad 11 7f 95			ld de, .ptrcliptr 
93b0 3e 28			ld a, display_row_2 
93b2 cd c1 8a			call str_at_display 
93b5			 
93b5 f1				pop af 
93b6 2a 40 ea			ld hl,(cli_ptr) 
93b9 3e 30			ld a, display_row_2+8 
93bb cd 77 93			call display_word_at 
93be			 
93be			 
93be				; display hl 
93be			 
93be			 
93be 11 87 95			ld de, .ptrclioptr 
93c1 3e 32			ld a, display_row_2+10 
93c3 cd c1 8a			call str_at_display 
93c6			; 
93c6			;	pop hl 
93c6 3e 35			ld a, display_row_2+13 
93c8 2a 3e ea			ld hl,(cli_origptr) 
93cb cd 77 93			call display_word_at 
93ce			; 
93ce			;	 
93ce			;	; display de 
93ce			 
93ce			;	ld de, .regstatede 
93ce			;	ld a, display_row_3 
93ce			;	call str_at_display 
93ce			 
93ce			;	pop de 
93ce			;	ld h,d 
93ce			;	ld l, e 
93ce			;	ld a, display_row_3+3 
93ce			;	call display_word_at 
93ce			 
93ce			 
93ce				; display bc 
93ce			 
93ce			;	ld de, .regstatebc 
93ce			;	ld a, display_row_3+10 
93ce			;	call str_at_display 
93ce			 
93ce			;	pop bc 
93ce			;	ld h,b 
93ce			;	ld l, c 
93ce			;	ld a, display_row_3+13 
93ce			;	call display_word_at 
93ce			 
93ce			 
93ce				; display dsp 
93ce			 
93ce			;	ld de, .regstatedsp 
93ce			;	ld a, display_row_4 
93ce			;	call str_at_display 
93ce			 
93ce				 
93ce			;	ld hl,(cli_data_sp) 
93ce			;	ld a, display_row_4+4 
93ce			;	call display_word_at 
93ce			 
93ce				; display rsp 
93ce			 
93ce 11 b6 95			ld de, .regstatersp 
93d1 3e 82			ld a, display_row_4+10 
93d3 cd c1 8a			call str_at_display 
93d6			 
93d6				 
93d6 2a f2 e9			ld hl,(cli_ret_sp) 
93d9 3e 86			ld a, display_row_4+14 
93db cd 77 93			call display_word_at 
93de			 
93de cd d1 8a			call update_display 
93e1			 
93e1 cd f1 89			call delay1s 
93e4 cd f1 89			call delay1s 
93e7 cd f1 89			call delay1s 
93ea			 
93ea			 
93ea cd d4 99			call next_page_prompt 
93ed			 
93ed				; restore  
93ed			 
93ed f1				pop af 
93ee e1				pop hl 
93ef c1				pop bc 
93f0 d1				pop de 
93f1 c9				ret 
93f2			 
93f2			; Update the break point vector so that the user can hook a new routine 
93f2			 
93f2			bp_on: 
93f2 3e c3			ld a, $c3    ; JP 
93f4 32 6f ee			ld (debug_vector), a 
93f7 21 04 94			ld hl, break_point_state 
93fa 22 70 ee			ld (debug_vector+1), hl 
93fd c9				ret 
93fe			 
93fe			bp_off: 
93fe 3e c9			ld a, $c9    ; RET 
9400 32 6f ee			ld (debug_vector), a 
9403 c9				ret 
9404			 
9404			 
9404			break_point_state: 
9404			;	push af 
9404			; 
9404			;	; see if disabled 
9404			; 
9404			;	ld a, (os_view_disable) 
9404			;	cp '*' 
9404			;	jr nz, .bpsgo 
9404			;	pop af 
9404			;	ret 
9404			 
9404			.bpsgo: 
9404			;	pop af 
9404 f5				push af 
9405 22 a3 e2			ld (os_view_hl), hl 
9408 ed 53 a1 e2		ld (os_view_de), de 
940c ed 43 9f e2		ld (os_view_bc), bc 
9410 e5				push hl 
9411 6f				ld l, a 
9412 26 00			ld h, 0 
9414 22 a5 e2			ld (os_view_af),hl 
9417			 
9417 21 b1 ed				ld hl, display_fb0 
941a 22 cc eb				ld (display_fb_active), hl 
941d e1				pop hl	 
941e			 
941e 3e 31			ld a, '1' 
9420 fe 2a		.bps1:  cp '*' 
9422 cc fe 93			call z, bp_off 
9425			;	jr nz, .bps1b 
9425			;	ld (os_view_disable),a 
9425 fe 31		.bps1b:  cp '1' 
9427 20 14			jr nz, .bps2 
9429			 
9429				; display reg 
9429			 
9429				 
9429			 
9429 3a a5 e2			ld a, (os_view_af) 
942c 2a a3 e2			ld hl, (os_view_hl) 
942f ed 5b a1 e2		ld de, (os_view_de) 
9433 ed 4b 9f e2		ld bc, (os_view_bc) 
9437 cd d1 94			call display_reg_state 
943a c3 bd 94			jp .bpschk 
943d			 
943d fe 32		.bps2:  cp '2' 
943f 20 08			jr nz, .bps3 
9441				 
9441				; display hl 
9441 2a a3 e2			ld hl, (os_view_hl) 
9444 cd bb 95			call display_dump_at_hl 
9447			 
9447 18 74			jr .bpschk 
9449			 
9449 fe 33		.bps3:  cp '3' 
944b 20 08			jr nz, .bps4 
944d			 
944d			        ; display de 
944d 2a a1 e2			ld hl, (os_view_de) 
9450 cd bb 95			call display_dump_at_hl 
9453			 
9453 18 68			jr .bpschk 
9455 fe 34		.bps4:  cp '4' 
9457 20 08			jr nz, .bps5 
9459			 
9459			        ; display bc 
9459 2a 9f e2			ld hl, (os_view_bc) 
945c cd bb 95			call display_dump_at_hl 
945f			 
945f 18 5c			jr .bpschk 
9461 fe 35		.bps5:  cp '5' 
9463 20 08		        jr nz, .bps7 
9465			 
9465				; display cur ptr 
9465 2a 40 ea			ld hl, (cli_ptr) 
9468 cd bb 95			call display_dump_at_hl 
946b			 
946b 18 50			jr .bpschk 
946d fe 36		.bps7:  cp '6' 
946f 20 08			jr nz, .bps8b 
9471				 
9471				; display cur orig ptr 
9471 2a 3e ea			ld hl, (cli_origptr) 
9474 cd bb 95			call display_dump_at_hl 
9477 18 44			jr .bpschk 
9479 fe 37		.bps8b:  cp '7' 
947b 20 08			jr nz, .bps9 
947d				 
947d				; display dsp 
947d 2a ee e9			ld hl, (cli_data_sp) 
9480 cd bb 95			call display_dump_at_hl 
9483			 
9483 18 38			jr .bpschk 
9485 fe 39		.bps9:  cp '9' 
9487 20 05			jr nz, .bps8c 
9489				 
9489				; display SP 
9489			;	ld hl, sp 
9489 cd bb 95			call display_dump_at_hl 
948c			 
948c 18 2f			jr .bpschk 
948e fe 38		.bps8c:  cp '8' 
9490 20 08			jr nz, .bps8d 
9492				 
9492				; display rsp 
9492 2a f2 e9			ld hl, (cli_ret_sp) 
9495 cd bb 95			call display_dump_at_hl 
9498			 
9498 18 23			jr .bpschk 
949a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
949c 20 05			jr nz, .bps8 
949e cd a2 97			call monitor 
94a1			 
94a1 18 1a			jr .bpschk 
94a3 fe 30		.bps8:  cp '0' 
94a5 20 16			jr nz, .bpschk 
94a7			 
94a7 21 10 ed				ld hl, display_fb1 
94aa 22 cc eb				ld (display_fb_active), hl 
94ad cd d1 8a				call update_display 
94b0			 
94b0				;ld a, (os_view_af) 
94b0 2a a3 e2			ld hl, (os_view_hl) 
94b3 ed 5b a1 e2		ld de, (os_view_de) 
94b7 ed 4b 9f e2		ld bc, (os_view_bc) 
94bb f1				pop af 
94bc c9				ret 
94bd			 
94bd			.bpschk:   
94bd cd f1 89			call delay1s 
94c0 3e 9f		ld a,display_row_4 + display_cols - 1 
94c2 11 d2 99		        ld de, endprg 
94c5 cd c1 8a			call str_at_display 
94c8 cd d1 8a			call update_display 
94cb cd e4 e3			call cin_wait 
94ce			 
94ce c3 20 94			jp .bps1 
94d1			 
94d1			 
94d1			display_reg_state: 
94d1			 
94d1				; to restore afterwards 
94d1			 
94d1 d5				push de 
94d2 c5				push bc 
94d3 e5				push hl 
94d4 f5				push af 
94d5			 
94d5				; for use in here 
94d5			 
94d5 c5				push bc 
94d6 d5				push de 
94d7 e5				push hl 
94d8 f5				push af 
94d9			 
94d9 cd ae 8a			call clear_display 
94dc			 
94dc 11 91 95			ld de, .regstate 
94df 3e 00			ld a, display_row_1 
94e1 cd c1 8a			call str_at_display 
94e4			 
94e4				; display debug step 
94e4			 
94e4			 
94e4 11 6b ee			ld de, debug_mark 
94e7 3e 25			ld a, display_row_1+display_cols-3 
94e9 cd c1 8a			call str_at_display 
94ec			 
94ec				; display a 
94ec 11 ad 95			ld de, .regstatea 
94ef 3e 28			ld a, display_row_2 
94f1 cd c1 8a			call str_at_display 
94f4			 
94f4 e1				pop hl 
94f5			;	ld h,0 
94f5			;	ld l, a 
94f5 3e 2b			ld a, display_row_2+3 
94f7 cd 77 93			call display_word_at 
94fa			 
94fa			 
94fa				; display hl 
94fa			 
94fa			 
94fa 11 a1 95			ld de, .regstatehl 
94fd 3e 32			ld a, display_row_2+10 
94ff cd c1 8a			call str_at_display 
9502			 
9502 e1				pop hl 
9503 3e 35			ld a, display_row_2+13 
9505 cd 77 93			call display_word_at 
9508			 
9508				 
9508				; display de 
9508			 
9508 11 a5 95			ld de, .regstatede 
950b 3e 50			ld a, display_row_3 
950d cd c1 8a			call str_at_display 
9510			 
9510 e1				pop hl 
9511			;	ld h,d 
9511			;	ld l, e 
9511 3e 53			ld a, display_row_3+3 
9513 cd 77 93			call display_word_at 
9516			 
9516			 
9516				; display bc 
9516			 
9516 11 a9 95			ld de, .regstatebc 
9519 3e 5a			ld a, display_row_3+10 
951b cd c1 8a			call str_at_display 
951e			 
951e e1				pop hl 
951f			;	ld h,b 
951f			;	ld l, c 
951f 3e 5d			ld a, display_row_3+13 
9521 cd 77 93			call display_word_at 
9524			 
9524			 
9524				; display dsp 
9524			 
9524 11 b1 95			ld de, .regstatedsp 
9527 3e 78			ld a, display_row_4 
9529 cd c1 8a			call str_at_display 
952c			 
952c				 
952c 2a ee e9			ld hl,(cli_data_sp) 
952f 3e 7c			ld a, display_row_4+4 
9531 cd 77 93			call display_word_at 
9534			 
9534				; display rsp 
9534			 
9534 11 b6 95			ld de, .regstatersp 
9537 3e 82			ld a, display_row_4+10 
9539 cd c1 8a			call str_at_display 
953c			 
953c				 
953c 2a f2 e9			ld hl,(cli_ret_sp) 
953f 3e 86			ld a, display_row_4+14 
9541 cd 77 93			call display_word_at 
9544			 
9544 cd d1 8a			call update_display 
9547			 
9547			;	call delay1s 
9547			;	call delay1s 
9547			;	call delay1s 
9547			 
9547			 
9547			;	call next_page_prompt 
9547			 
9547				; restore  
9547			 
9547 f1				pop af 
9548 e1				pop hl 
9549 c1				pop bc 
954a d1				pop de 
954b c9				ret 
954c			 
954c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9560 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9575 .. 00		.ptrstate:	db "Ptr State",0 
957f .. 00		.ptrcliptr:     db "cli_ptr",0 
9587 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9591 .. 00		.regstate:	db "Reg State (1/0)",0 
95a1 .. 00		.regstatehl:	db "HL:",0 
95a5 .. 00		.regstatede:	db "DE:",0 
95a9 .. 00		.regstatebc:	db "BC:",0 
95ad .. 00		.regstatea:	db "A :",0 
95b1 .. 00		.regstatedsp:	db "DSP:",0 
95b6 .. 00		.regstatersp:	db "RSP:",0 
95bb			 
95bb			display_dump_at_hl: 
95bb e5				push hl 
95bc d5				push de 
95bd c5				push bc 
95be f5				push af 
95bf			 
95bf 22 e4 e5			ld (os_cur_ptr),hl	 
95c2 cd ae 8a			call clear_display 
95c5 cd dc 98			call dumpcont 
95c8			;	call delay1s 
95c8			;	call next_page_prompt 
95c8			 
95c8			 
95c8 f1				pop af 
95c9 c1				pop bc 
95ca d1				pop de 
95cb e1				pop hl 
95cc c9				ret 
95cd			 
95cd			;if ENABLE_BASIC 
95cd			;	include "nascombasic.asm" 
95cd			;	basic: 
95cd			;	include "forth/FORTH.ASM" 
95cd			;endif 
95cd			 
95cd			; eof 
95cd			 
95cd			 
# End of file firmware_diags.asm
95cd			  
95cd			include "firmware_prompts.asm"  
95cd			; Prompts  
95cd			 
95cd			; boot messages 
95cd			 
95cd .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
95e2 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
95f2			 
95f2			 
95f2			; config menus 
95f2			 
95f2			;prom_c3: db "Add Dictionary To File",0 
95f2			 
95f2			if STARTUP_V1 
95f2 .. 00		prom_c2: db "Select Autoload File",0 
9607 .. 00		prom_c2a: db "Disable Autoload File", 0 
961d			endif 
961d			 
961d			if STARTUP_V2 
961d			prom_c2: db "Enable Autoload Files",0 
961d			prom_c2a: db "Disable Autoload Files", 0 
961d			 
961d			crs_s1: db "*ls-word", 0 
961d			crs_s2: db "*ed-word", 0 
961d			crs_s3: db "*Demo-Programs", 0 
961d			crs_s4: db "*Utils", 0 
961d			crs_s5: db "*SPI-Util", 0 
961d			crs_s6: db "*Key-constants", 0 
961d			crs_sound: db "*Sound-Util", 0 
961d			 
961d			 
961d			 
961d			endif 
961d			;prom_c2b: db "Select Storage Bank",0 
961d .. 00		prom_c4: db "Settings",0 
9626 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9641 .. 00		prom_m4b:   db "Monitor",0 
9649 .. 00		prom_c1: db "Hardware Diags",0 
9658			 
9658			 
9658			if STARTUP_V2 
9658			prom_c9: db "Create Startup Files",0 
9658			endif 
9658			 
9658 .. 00		prom_notav:    db "Feature not available",0 
966e .. 00		prom_empty:    db "",0 
966f			 
966f			; eof 
966f			 
# End of file firmware_prompts.asm
966f			  
966f			  
966f			; eof  
966f			  
# End of file firmware.asm
966f			 
966f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
966f			;if BASE_KEV  
966f			;baseram: equ 08000h 
966f			;endif 
966f			 
966f			;if BASE_SC114 
966f			;baseram:     equ    endofcode 
966f			;endif 
966f			 
966f			 
966f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
966f			 
966f			; start system 
966f			 
966f			coldstart: 
966f				; set sp 
966f				; di/ei 
966f			 
966f f3				di 
9670 31 00 f0			ld sp, tos 
9673 cd 2e e3			call init_nmi 
9676			;	ei 
9676			 
9676				; init spinner 
9676 3e 00			ld a,0 
9678 32 c6 eb			ld (display_active), a 
967b			 
967b				; disable breakpoint by default 
967b			 
967b				;ld a,'*' 
967b			;	ld a,' ' 
967b			;	ld (os_view_disable),a 
967b			 
967b				; set break point vector as new break point on or off 
967b cd fe 93			call bp_off 
967e			 
967e				; init hardware 
967e			 
967e				; init keyboard and screen hardware 
967e			 
967e cd 1b 80			call hardware_init 
9681			 
9681			 
9681 cd f1 89			call delay1s 
9684 3e 58			ld a, display_row_3+8 
9686 11 03 80			ld de, buildtime 
9689 cd c1 8a			call str_at_display 
968c cd d1 8a			call update_display 
968f			 
968f cd f1 89			call delay1s 
9692 cd f1 89			call delay1s 
9695 cd f1 89			call delay1s 
9698			 
9698				; detect if any keys are held down to enable breakpoints at start up 
9698			 
9698 cd ea e3			call cin  
969b fe 00			cp 0 
969d 28 03			jr z, .nokeys 
969f			 
969f				;call hardware_diags 
969f cd 5c 92			call config 
96a2			 
96a2			;	ld de, .bpen 
96a2			;	ld a, display_row_4 
96a2			;	call str_at_display 
96a2			;	call update_display 
96a2			; 
96a2			;	ld a,0 
96a2			;	ld (os_view_disable),a 
96a2			; 
96a2			;.bpwait: 
96a2			;	call cin 
96a2			;	cp 0 
96a2			;	jr z, .bpwait 
96a2			;	jr .nokeys 
96a2			; 
96a2			; 
96a2			;.bpen:  db "Break points enabled!",0 
96a2			 
96a2			 
96a2			 
96a2			 
96a2			 
96a2			 
96a2			.nokeys: 
96a2			 
96a2			 
96a2				 
96a2			 
96a2			;jp  testkey 
96a2			 
96a2			;call storage_get_block_0 
96a2			; 
96a2			;ld hl, 0 
96a2			;ld de, store_page 
96a2			;call storage_read_block 
96a2			 
96a2				 
96a2			;ld hl, 10 
96a2			;ld de, store_page 
96a2			;call storage_read_block 
96a2			 
96a2			 
96a2			 
96a2			 
96a2			 
96a2			;stop:	nop 
96a2			;	jp stop 
96a2			 
96a2			 
96a2			 
96a2			main: 
96a2 cd ae 8a			call clear_display 
96a5 cd d1 8a			call update_display 
96a8			 
96a8			 
96a8			 
96a8			;	call testlcd 
96a8			 
96a8			 
96a8			 
96a8 cd d9 9d			call forth_init 
96ab			 
96ab			 
96ab			warmstart: 
96ab cd af 9d			call forth_warmstart 
96ae			 
96ae				; run startup word load 
96ae			        ; TODO prevent this running at warmstart after crash  
96ae			 
96ae				if STARTUP_ENABLE 
96ae			 
96ae					if STARTUP_V1 
96ae			 
96ae						if STORAGE_SE 
96ae							call forth_autoload 
96ae						endif 
96ae cd 7e e2					call forth_startup 
96b1					endif 
96b1			 
96b1					if STARTUP_V2 
96b1			 
96b1						if STORAGE_SE 
96b1							call forth_autoload 
96b1						else 
96b1							call forth_startup 
96b1						endif 
96b1			 
96b1			 
96b1					endif 
96b1			 
96b1				endif 
96b1			 
96b1				; show free memory after boot 
96b1 11 3d 97			ld de, freeram 
96b4 3e 00			ld a, display_row_1 
96b6 cd c1 8a			call str_at_display 
96b9			 
96b9				; get current heap start after loading any uwords 
96b9			 
96b9				;ld de, (os_last_new_uword) 
96b9				;ex de, hl 
96b9			 
96b9			; Or use heap_size word???? 
96b9				;ld hl, heap_end 
96b9				;ld hl, heap_size 
96b9				;ld de, topusermem 
96b9				;ld de, heap_start 
96b9 ed 5b 03 e4			ld de, (free_list )      
96bd 21 9c e2				ld hl, heap_end 
96c0 ed 52			sbc hl, de 
96c2				;push hl 
96c2				;ld a,h	         	 
96c2				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96c2				;call hexout 
96c2			   	;pop hl 
96c2			; 
96c2			;	ld a,l 
96c2			;	ld hl, os_word_scratch+2 
96c2			;	call hexout 
96c2			;	ld hl, os_word_scratch+4 
96c2			;	ld a, 0 
96c2			;	ld (hl),a 
96c2 eb				ex de, hl 
96c3 21 c6 e5			ld hl, os_word_scratch 
96c6 cd fd 8f			call uitoa_16 
96c9			 
96c9			 
96c9 11 c6 e5			ld de, os_word_scratch 
96cc 3e 0d			ld a, display_row_1 + 13 
96ce cd c1 8a			call str_at_display 
96d1 cd d1 8a			call update_display 
96d4			 
96d4			 
96d4				;call demo 
96d4			 
96d4			 
96d4				; init scratch input area for cli commands 
96d4			 
96d4 21 e8 e5			ld hl, os_cli_cmd 
96d7 3e 00			ld a,0 
96d9 77				ld (hl),a 
96da 23				inc hl 
96db 77				ld (hl),a 
96dc			 
96dc 3e 00			ld a,0 
96de 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
96e1			 
96e1 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
96e4 32 e5 e5			ld (os_cur_ptr+1),a	 
96e7			 
96e7 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
96ea 32 c7 e5			ld (os_word_scratch+1),a	 
96ed				 
96ed			 
96ed				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96ed 21 e8 e5			ld hl, os_cli_cmd 
96f0			 
96f0 3e 00			ld a, 0		 ; init cli input 
96f2 77				ld (hl), a 
96f3 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
96f5			cli: 
96f5				; show cli prompt 
96f5				;push af 
96f5				;ld a, 0 
96f5				;ld de, prompt 
96f5				;call str_at_display 
96f5			 
96f5				;call update_display 
96f5				;pop af 
96f5				;inc a 
96f5				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
96f5 0e 00			ld c, 0 
96f7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
96f9 1e 28			ld e, 40 
96fb			 
96fb 21 e8 e5			ld hl, os_cli_cmd 
96fe			 
96fe				STACKFRAME OFF $fefe $9f9f 
96fe				if DEBUG_STACK_IMB 
96fe					if OFF 
96fe						exx 
96fe						ld de, $fefe 
96fe						ld a, d 
96fe						ld hl, curframe 
96fe						call hexout 
96fe						ld a, e 
96fe						ld hl, curframe+2 
96fe						call hexout 
96fe						ld hl, $fefe 
96fe						push hl 
96fe						ld hl, $9f9f 
96fe						push hl 
96fe						exx 
96fe					endif 
96fe				endif 
96fe			endm 
# End of macro STACKFRAME
96fe			 
96fe cd 08 8d			call input_str 
9701			 
9701				STACKFRAMECHK OFF $fefe $9f9f 
9701				if DEBUG_STACK_IMB 
9701					if OFF 
9701						exx 
9701						ld hl, $9f9f 
9701						pop de   ; $9f9f 
9701						call cmp16 
9701						jr nz, .spnosame 
9701						ld hl, $fefe 
9701						pop de   ; $fefe 
9701						call cmp16 
9701						jr z, .spfrsame 
9701						.spnosame: call showsperror 
9701						.spfrsame: nop 
9701						exx 
9701					endif 
9701				endif 
9701			endm 
# End of macro STACKFRAMECHK
9701			 
9701				; copy input to last command 
9701			 
9701 21 e8 e5			ld hl, os_cli_cmd 
9704 11 e7 e6			ld de, os_last_cmd 
9707 01 ff 00			ld bc, 255 
970a ed b0			ldir 
970c			 
970c				; wipe current buffer 
970c			 
970c			;	ld a, 0 
970c			;	ld hl, os_cli_cmd 
970c			;	ld de, os_cli_cmd+1 
970c			;	ld bc, 254 
970c			;	ldir 
970c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
970c			;	call strcpy 
970c			;	ld a, 0 
970c			;	ld (hl), a 
970c			;	inc hl 
970c			;	ld (hl), a 
970c			;	inc hl 
970c			;	ld (hl), a 
970c			 
970c				; switch frame buffer to program  
970c			 
970c 21 10 ed				ld hl, display_fb1 
970f 22 cc eb				ld (display_fb_active), hl 
9712			 
9712			;	nop 
9712				STACKFRAME ON $fbfe $8f9f 
9712				if DEBUG_STACK_IMB 
9712					if ON 
9712						exx 
9712						ld de, $fbfe 
9712						ld a, d 
9712						ld hl, curframe 
9712						call hexout 
9712						ld a, e 
9712						ld hl, curframe+2 
9712						call hexout 
9712						ld hl, $fbfe 
9712						push hl 
9712						ld hl, $8f9f 
9712						push hl 
9712						exx 
9712					endif 
9712				endif 
9712			endm 
# End of macro STACKFRAME
9712				; first time into the parser so pass over the current scratch pad 
9712 21 e8 e5			ld hl,os_cli_cmd 
9715				; tokenise the entered statement(s) in HL 
9715 cd 57 9e			call forthparse 
9718			        ; exec forth statements in top of return stack 
9718 cd 97 9e			call forthexec 
971b				;call forthexec_cleanup 
971b			;	call parsenext 
971b			 
971b				STACKFRAMECHK ON $fbfe $8f9f 
971b				if DEBUG_STACK_IMB 
971b					if ON 
971b						exx 
971b						ld hl, $8f9f 
971b						pop de   ; $8f9f 
971b						call cmp16 
971b						jr nz, .spnosame 
971b						ld hl, $fbfe 
971b						pop de   ; $fbfe 
971b						call cmp16 
971b						jr z, .spfrsame 
971b						.spnosame: call showsperror 
971b						.spfrsame: nop 
971b						exx 
971b					endif 
971b				endif 
971b			endm 
# End of macro STACKFRAMECHK
971b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
971b			 
971b 3e 78			ld a, display_row_4 
971d 11 4e 97			ld de, endprog 
9720			 
9720 cd d1 8a			call update_display		 
9723			 
9723 cd d4 99			call next_page_prompt 
9726			 
9726				; switch frame buffer to cli 
9726			 
9726 21 b1 ed				ld hl, display_fb0 
9729 22 cc eb				ld (display_fb_active), hl 
972c			 
972c			 
972c cd ae 8a		        call clear_display 
972f cd d1 8a			call update_display		 
9732			 
9732 21 e8 e5			ld hl, os_cli_cmd 
9735			 
9735 3e 00			ld a, 0		 ; init cli input 
9737 77				ld (hl), a 
9738			 
9738				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9738			 
9738				; now on last line 
9738			 
9738				; TODO scroll screen up 
9738			 
9738				; TODO instead just clear screen and place at top of screen 
9738			 
9738			;	ld a, 0 
9738			;	ld (f_cursor_ptr),a 
9738			 
9738				;call clear_display 
9738				;call update_display 
9738			 
9738				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9738 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
973a c3 f5 96			jp cli 
973d			 
973d .. 00		freeram: db "Free bytes: ",0 
974a ..			asc: db "1A2F" 
974e .. 00		endprog: db "End prog...",0 
975a			 
975a			testenter2:   
975a 21 f3 e2			ld hl,scratch+50 
975d 22 e4 e5			ld (os_cur_ptr),hl 
9760 c3 f5 96			jp cli 
9763			 
9763			testenter:  
9763			 
9763 21 4a 97			ld hl,asc 
9766			;	ld a,(hl) 
9766			;	call nibble2val 
9766 cd 47 8f			call get_byte 
9769			 
9769			 
9769			;	ld a,(hl) 
9769			;	call atohex 
9769			 
9769			;	call fourehexhl 
9769 32 f3 e2			ld (scratch+50),a 
976c			 
976c			 
976c			 
976c 21 4c 97			ld hl,asc+2 
976f			;	ld a, (hl) 
976f			;	call nibble2val 
976f cd 47 8f			call get_byte 
9772			 
9772			;	call fourehexhl 
9772 32 f5 e2			ld (scratch+52),a 
9775				 
9775 21 f3 e2			ld hl,scratch+50 
9778 22 e4 e5			ld (os_cur_ptr),hl 
977b c3 f5 96			jp cli 
977e			 
977e			enter:	 
977e 3a c5 e2			ld a,(scratch+4) 
9781 fe 00			cp 0 
9783 28 0c			jr z, .entercont 
9785				; no, not a null term line so has an address to work out.... 
9785			 
9785 21 c3 e2			ld hl,scratch+2 
9788 cd a7 8f			call get_word_hl 
978b			 
978b 22 e4 e5			ld (os_cur_ptr),hl	 
978e c3 f5 96			jp cli 
9791			 
9791			 
9791			.entercont:  
9791			 
9791 21 c3 e2			ld hl, scratch+2 
9794 cd 47 8f			call get_byte 
9797			 
9797 2a e4 e5		   	ld hl,(os_cur_ptr) 
979a 77					ld (hl),a 
979b 23					inc hl 
979c 22 e4 e5				ld (os_cur_ptr),hl 
979f				 
979f			; get byte  
979f			 
979f			 
979f c3 f5 96			jp cli 
97a2			 
97a2			 
97a2			; basic monitor support 
97a2			 
97a2			monitor: 
97a2				;  
97a2 cd ae 8a			call clear_display 
97a5 3e 00			ld a, 0 
97a7 11 f6 97			ld de, .monprompt 
97aa cd c1 8a			call str_at_display 
97ad cd d1 8a			call update_display 
97b0			 
97b0				; get a monitor command 
97b0			 
97b0 0e 00			ld c, 0     ; entry at top left 
97b2 16 64			ld d, 100   ; max buffer size 
97b4 1e 0f			ld e, 15    ; input scroll area 
97b6 3e 00			ld a, 0     ; init string 
97b8 21 bf e4			ld hl, os_input 
97bb 77				ld (hl), a 
97bc 23				inc hl 
97bd 77				ld (hl), a 
97be 21 bf e4			ld hl, os_input 
97c1 3e 01			ld a, 1     ; init string 
97c3 cd 08 8d			call input_str 
97c6			 
97c6 cd ae 8a		        call clear_display 
97c9 cd d1 8a			call update_display		 
97cc			 
97cc 3a bf e4			ld a, (os_input) 
97cf cd 45 90			call toUpper 
97d2 fe 48		        cp 'H' 
97d4 ca 5b 98		        jp z, .monhelp 
97d7 fe 44			cp 'D'		; dump 
97d9 ca 8e 98			jp z, .mondump	 
97dc fe 43			cp 'C'		; dump 
97de ca a8 98			jp z, .moncdump	 
97e1 fe 4d			cp 'M'		; dump 
97e3 ca f8 97			jp z, .moneditstart 
97e6 fe 55			cp 'U'		; dump 
97e8 ca 04 98			jp z, .monedit	 
97eb fe 47			cp 'G'		; dump 
97ed ca 84 98			jp z, .monjump 
97f0 fe 51			cp 'Q'		; dump 
97f2 c8				ret z	 
97f3			 
97f3			 
97f3				; TODO "S" to access symbol by name and not need the address 
97f3				; TODO "F" to find a string in memory 
97f3			 
97f3 c3 a2 97			jp monitor 
97f6			 
97f6 .. 00		.monprompt: db ">", 0 
97f8			 
97f8			.moneditstart: 
97f8				; get starting address 
97f8			 
97f8 21 c1 e4			ld hl,os_input+2 
97fb cd a7 8f			call get_word_hl 
97fe			 
97fe 22 e4 e5			ld (os_cur_ptr),hl	 
9801			 
9801 c3 a2 97			jp monitor 
9804			 
9804			.monedit: 
9804				; get byte to load 
9804			 
9804 21 c1 e4			ld hl,os_input+2 
9807 cd 47 8f			call get_byte 
980a			 
980a				; get address to update 
980a 2a e4 e5			ld hl, (os_cur_ptr) 
980d			 
980d				; update byte 
980d			 
980d 77				ld (hl), a 
980e			 
980e				; move to next address and save it 
980e			 
980e 23				inc hl 
980f 22 e4 e5			ld (os_cur_ptr),hl	 
9812			 
9812 c3 a2 97			jp monitor 
9815			 
9815			 
9815 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9829 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9845 .. 00		.monhelptext3:  db "G-Call address",0 
9854 .. 00		.monhelptext4:  db "Q-Quit",0 
985b			        
985b			.monhelp: 
985b 3e 00			ld a, display_row_1 
985d 11 15 98		        ld de, .monhelptext1 
9860			 
9860 cd c1 8a			call str_at_display 
9863 3e 28			ld a, display_row_2 
9865 11 29 98		        ld de, .monhelptext2 
9868					 
9868 cd c1 8a			call str_at_display 
986b 3e 50			ld a, display_row_3 
986d 11 45 98		        ld de, .monhelptext3 
9870					 
9870 cd c1 8a			call str_at_display 
9873 3e 78			ld a, display_row_4 
9875 11 54 98		        ld de, .monhelptext4 
9878 cd c1 8a			call str_at_display 
987b			 
987b cd d1 8a			call update_display		 
987e			 
987e cd d4 99			call next_page_prompt 
9881 c3 a2 97			jp monitor 
9884			 
9884			.monjump:    
9884 21 c1 e4			ld hl,os_input+2 
9887 cd a7 8f			call get_word_hl 
988a			 
988a e9				jp (hl) 
988b c3 a2 97			jp monitor 
988e			 
988e			.mondump:    
988e 21 c1 e4			ld hl,os_input+2 
9891 cd a7 8f			call get_word_hl 
9894			 
9894 22 e4 e5			ld (os_cur_ptr),hl	 
9897 cd dc 98			call dumpcont 
989a 3e 78			ld a, display_row_4 
989c 11 4e 97			ld de, endprog 
989f			 
989f cd d1 8a			call update_display		 
98a2			 
98a2 cd d4 99			call next_page_prompt 
98a5 c3 a2 97			jp monitor 
98a8			.moncdump: 
98a8 cd dc 98			call dumpcont 
98ab 3e 78			ld a, display_row_4 
98ad 11 4e 97			ld de, endprog 
98b0			 
98b0 cd d1 8a			call update_display		 
98b3			 
98b3 cd d4 99			call next_page_prompt 
98b6 c3 a2 97			jp monitor 
98b9			 
98b9			 
98b9			; TODO symbol access  
98b9			 
98b9			.symbols:     ;; A list of symbols that can be called up  
98b9 b1 ed			dw display_fb0 
98bb .. 00			db "fb0",0  
98bf 7a ea		     	dw store_page 
98c1 .. 00			db "store_page",0 
98cc			 
98cc			 
98cc			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
98cc			 
98cc 3a c2 e2			ld a,(scratch+1) 
98cf fe 00			cp 0 
98d1 28 09			jr z, dumpcont 
98d3			 
98d3				; no, not a null term line so has an address to work out.... 
98d3			 
98d3 21 c3 e2			ld hl,scratch+2 
98d6 cd a7 8f			call get_word_hl 
98d9			 
98d9 22 e4 e5			ld (os_cur_ptr),hl	 
98dc			 
98dc			 
98dc			 
98dc			dumpcont: 
98dc			 
98dc				; dump bytes at ptr 
98dc			 
98dc			 
98dc 3e 00			ld a, display_row_1 
98de 2a cc eb			ld hl, (display_fb_active) 
98e1 cd db 8c			call addatohl 
98e4 cd 0c 99			call .dumpbyterow 
98e7			 
98e7 3e 28			ld a, display_row_2 
98e9 2a cc eb			ld hl, (display_fb_active) 
98ec cd db 8c			call addatohl 
98ef cd 0c 99			call .dumpbyterow 
98f2			 
98f2			 
98f2 3e 50			ld a, display_row_3 
98f4 2a cc eb			ld hl, (display_fb_active) 
98f7 cd db 8c			call addatohl 
98fa cd 0c 99			call .dumpbyterow 
98fd			 
98fd 3e 78			ld a, display_row_4 
98ff 2a cc eb			ld hl, (display_fb_active) 
9902 cd db 8c			call addatohl 
9905 cd 0c 99			call .dumpbyterow 
9908			 
9908 cd d1 8a			call update_display 
990b			;		jp cli 
990b c9				ret 
990c			 
990c			.dumpbyterow: 
990c			 
990c				;push af 
990c			 
990c e5				push hl 
990d			 
990d				; calc where to poke the ascii 
990d			if display_cols == 20 
990d				ld a, 16 
990d			else 
990d 3e 1f			ld a, 31 
990f			endif 
990f			 
990f cd db 8c			call addatohl 
9912 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9915			 
9915			 
9915			; display decoding address 
9915 2a e4 e5		   	ld hl,(os_cur_ptr) 
9918			 
9918 7c				ld a,h 
9919 e1				pop hl 
991a e5				push hl 
991b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
991b cd f1 8e			call hexout 
991e 2a e4 e5		   	ld hl,(os_cur_ptr) 
9921			 
9921 7d				ld a,l 
9922 e1				pop hl 
9923 23				inc hl 
9924 23				inc hl 
9925 e5				push hl 
9926			;	ld hl, os_word_scratch+2 
9926 cd f1 8e			call hexout 
9929 e1				pop hl 
992a 23				inc hl 
992b 23				inc hl 
992c				;ld hl, os_word_scratch+4 
992c 3e 3a			ld a, ':' 
992e 77				ld (hl),a 
992f 23				inc hl 
9930				;ld a, 0 
9930				;ld (hl),a 
9930				;ld de, os_word_scratch 
9930				;pop af 
9930				;push af 
9930			;		ld a, display_row_2 
9930			;		call str_at_display 
9930			;		call update_display 
9930			 
9930			 
9930			;pop af 
9930			;	add 5 
9930			 
9930			if display_cols == 20 
9930				ld b, 4 
9930			else 
9930 06 08			ld b, 8 
9932			endif	 
9932			 
9932			.dumpbyte: 
9932 c5				push bc 
9933 e5				push hl 
9934			 
9934			 
9934 2a e4 e5		   	ld hl,(os_cur_ptr) 
9937 7e					ld a,(hl) 
9938			 
9938					; poke the ascii to display 
9938 2a c6 e5				ld hl,(os_word_scratch) 
993b 77					ld (hl),a 
993c 23					inc hl 
993d 22 c6 e5				ld (os_word_scratch),hl 
9940			 
9940					 
9940			 
9940			 
9940 e1					pop hl 
9941 e5					push hl 
9942			 
9942 cd f1 8e				call hexout 
9945			 
9945					 
9945 2a e4 e5		   	ld hl,(os_cur_ptr) 
9948 23				inc hl 
9949 22 e4 e5		   	ld (os_cur_ptr),hl 
994c			 
994c e1					pop hl 
994d 23					inc hl 
994e 23					inc hl 
994f 23					inc hl 
9950			 
9950			 
9950			 
9950					;ld a,0 
9950					;ld (os_word_scratch+2),a 
9950					;pop af 
9950					;push af 
9950			 
9950					;ld de, os_word_scratch 
9950					;call str_at_display 
9950			;		call update_display 
9950			;		pop af 
9950 c1					pop bc 
9951 c6 03				add 3 
9953 10 dd			djnz .dumpbyte 
9955			 
9955				 
9955			 
9955 c9				ret 
9956			 
9956			jump:	 
9956			 
9956 21 c3 e2			ld hl,scratch+2 
9959 cd a7 8f			call get_word_hl 
995c				;ld hl,(scratch+2) 
995c				;call fourehexhl 
995c			 
995c 22 e4 e5			ld (os_cur_ptr),hl	 
995f			 
995f e9				jp (hl) 
9960			 
9960			 
9960			 
9960			; TODO implement a basic monitor mode to start with 
9960			 
9960			 
9960			 
9960			 
9960			 
9960			 
9960			 
9960			 
9960			 
9960			; testing and demo code during development 
9960			 
9960			 
9960 .. 00		str1: db "Enter some text...",0 
9973 .. 00		clear: db "                    ",0 
9988			 
9988			demo: 
9988			 
9988			 
9988			 
9988			;	call update_display 
9988			 
9988				; init scratch input area for testing 
9988 21 c1 e2			ld hl, scratch	 
998b 3e 00			ld a,0 
998d 77				ld (hl),a 
998e			 
998e			 
998e 3e 28		            LD   A, display_row_2 
9990			;            CALL fLCD_Pos       ;Position cursor to location in A 
9990 11 60 99		            LD   DE, str1 
9993 cd c1 8a			call str_at_display 
9996			 
9996			;            CALL fLCD_Str       ;Display string pointed to by DE 
9996			cloop:	 
9996 3e 50		            LD   A, display_row_3 
9998			;            CALL fLCD_Pos       ;Position cursor to location in A 
9998 11 73 99		            LD   DE, clear 
999b			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
999b cd c1 8a				call str_at_display 
999e 3e 78			ld a, display_row_4 
99a0 11 d0 99			ld de, prompt 
99a3			 
99a3 cd c1 8a				call str_at_display 
99a6 cd d1 8a			call update_display 
99a9			 
99a9 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99ab 16 0a			ld d, 10 
99ad 21 c1 e2			ld hl, scratch	 
99b0 cd 08 8d			call input_str 
99b3			 
99b3			;	call clear_display 
99b3			;'	call update_display 
99b3			 
99b3 3e 00		            LD   A, display_row_1 
99b5			;            CALL fLCD_Pos       ;Position cursor to location in A 
99b5 11 73 99		            LD   DE, clear 
99b8 cd c1 8a				call str_at_display 
99bb			;            CALL fLCD_Str       ;Display string pointed to by DE 
99bb 3e 00		            LD   A, display_row_1 
99bd			;            CALL fLCD_Pos       ;Position cursor to location in A 
99bd 11 c1 e2		            LD   DE, scratch 
99c0			;            CALL fLCD_Str       ;Display string pointed to by DE 
99c0 cd c1 8a				call str_at_display 
99c3 cd d1 8a			call update_display 
99c6			 
99c6 3e 00				ld a,0 
99c8 21 c1 e2			ld hl, scratch 
99cb 77				ld (hl),a 
99cc			 
99cc 00				nop 
99cd c3 96 99			jp cloop 
99d0			 
99d0			 
99d0			 
99d0			; OS Prompt 
99d0			 
99d0 .. 00		prompt: db ">",0 
99d2 .. 00		endprg: db "?",0 
99d4			 
99d4			 
99d4			; handy next page prompt 
99d4			next_page_prompt: 
99d4 e5				push hl 
99d5 d5				push de 
99d6 f5				push af 
99d7 c5				push bc 
99d8			 
99d8 3e 9f			ld a,display_row_4 + display_cols - 1 
99da 11 d2 99		        ld de, endprg 
99dd cd c1 8a			call str_at_display 
99e0 cd d1 8a			call update_display 
99e3 cd e4 e3			call cin_wait 
99e6 c1				pop bc 
99e7 f1				pop af 
99e8 d1				pop de 
99e9 e1				pop hl 
99ea			 
99ea			 
99ea c9				ret 
99eb			 
99eb			 
99eb			; forth parser 
99eb			 
99eb			; My forth kernel 
99eb			include "forth_kernel.asm" 
99eb			; 
99eb			; kernel to the forth OS 
99eb			 
99eb			DS_TYPE_STR: equ 1     ; string type 
99eb			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
99eb			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
99eb			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
99eb			 
99eb			FORTH_PARSEV1: equ 0 
99eb			FORTH_PARSEV2: equ 0 
99eb			FORTH_PARSEV3: equ 0 
99eb			FORTH_PARSEV4: equ 0 
99eb			FORTH_PARSEV5: equ 1 
99eb			 
99eb			;if FORTH_PARSEV5 
99eb			;	FORTH_END_BUFFER: equ 0 
99eb			;else 
99eb			FORTH_END_BUFFER: equ 127 
99eb			;endif 
99eb			 
99eb			FORTH_TRUE: equ 1 
99eb			FORTH_FALSE: equ 0 
99eb			 
99eb			if FORTH_PARSEV4 
99eb			include "forth_stackops.asm" 
99eb			endif 
99eb			 
99eb			if FORTH_PARSEV5 
99eb			include "forth_stackopsv5.asm" 
99eb			 
99eb			; Stack operations for v5 parser on wards 
99eb			; * DATA stack 
99eb			; * LOOP stack 
99eb			; * RETURN stack 
99eb			 
99eb			 
99eb			 
99eb			FORTH_CHK_DSP_UNDER: macro 
99eb				push hl 
99eb				push de 
99eb				ld hl,(cli_data_sp) 
99eb				ld de, cli_data_stack 
99eb				call cmp16 
99eb				jp c, fault_dsp_under 
99eb				pop de 
99eb				pop hl 
99eb				endm 
99eb			 
99eb			 
99eb			FORTH_CHK_RSP_UNDER: macro 
99eb				push hl 
99eb				push de 
99eb				ld hl,(cli_ret_sp) 
99eb				ld de, cli_ret_stack 
99eb				call cmp16 
99eb				jp c, fault_rsp_under 
99eb				pop de 
99eb				pop hl 
99eb				endm 
99eb			 
99eb			FORTH_CHK_LOOP_UNDER: macro 
99eb				push hl 
99eb				push de 
99eb				ld hl,(cli_loop_sp) 
99eb				ld de, cli_loop_stack 
99eb				call cmp16 
99eb				jp c, fault_loop_under 
99eb				pop de 
99eb				pop hl 
99eb				endm 
99eb			 
99eb			FORTH_ERR_TOS_NOTSTR: macro 
99eb				; TOSO might need more for checks when used 
99eb				push af 
99eb				ld a,(hl) 
99eb				cp DS_TYPE_STR 
99eb				jp nz, type_faultn   
99eb				pop af 
99eb				endm 
99eb			 
99eb			FORTH_ERR_TOS_NOTNUM: macro 
99eb				push af 
99eb				ld a,(hl) 
99eb				cp DS_TYPE_INUM 
99eb				jp nz, type_faultn   
99eb				pop af 
99eb				endm 
99eb			 
99eb			 
99eb			; increase data stack pointer and save hl to it 
99eb				 
99eb			FORTH_DSP_NEXT: macro 
99eb				call macro_forth_dsp_next 
99eb				endm 
99eb			 
99eb			 
99eb			macro_forth_dsp_next: 
99eb				if DEBUG_FORTH_STACK_GUARD 
99eb cd 5f e0				call check_stacks 
99ee				endif 
99ee e5				push hl 
99ef d5				push de 
99f0 eb				ex de,hl 
99f1 2a ee e9			ld hl,(cli_data_sp) 
99f4 23				inc hl 
99f5 23				inc hl 
99f6			 
99f6			; PARSEV5 
99f6 23				inc hl 
99f7 22 ee e9			ld (cli_data_sp),hl 
99fa 73				ld (hl), e 
99fb 23				inc hl 
99fc 72				ld (hl), d 
99fd d1				pop de 
99fe e1				pop hl 
99ff				if DEBUG_FORTH_STACK_GUARD 
99ff cd 5f e0				call check_stacks 
9a02				endif 
9a02 c9				ret 
9a03			 
9a03			 
9a03			; increase ret stack pointer and save hl to it 
9a03				 
9a03			FORTH_RSP_NEXT: macro 
9a03				call macro_forth_rsp_next 
9a03				endm 
9a03			 
9a03			macro_forth_rsp_next: 
9a03				if DEBUG_FORTH_STACK_GUARD 
9a03 cd 5f e0				call check_stacks 
9a06				endif 
9a06 e5				push hl 
9a07 d5				push de 
9a08 eb				ex de,hl 
9a09 2a f2 e9			ld hl,(cli_ret_sp) 
9a0c 23				inc hl 
9a0d 23				inc hl 
9a0e 22 f2 e9			ld (cli_ret_sp),hl 
9a11 73				ld (hl), e 
9a12 23				inc hl 
9a13 72				ld (hl), d 
9a14 d1				pop de 
9a15 e1				pop hl 
9a16				if DEBUG_FORTH_STACK_GUARD 
9a16 cd 5f e0				call check_stacks 
9a19				endif 
9a19 c9				ret 
9a1a			 
9a1a			; get current ret stack pointer and save to hl  
9a1a				 
9a1a			FORTH_RSP_TOS: macro 
9a1a				call macro_forth_rsp_tos 
9a1a				endm 
9a1a			 
9a1a			macro_forth_rsp_tos: 
9a1a				;push de 
9a1a 2a f2 e9			ld hl,(cli_ret_sp) 
9a1d cd 55 9a			call loadhlptrtohl 
9a20				;ld e, (hl) 
9a20				;inc hl 
9a20				;ld d, (hl) 
9a20				;ex de, hl 
9a20					if DEBUG_FORTH_WORDS 
9a20			;			DMARK "RST" 
9a20						CALLMONITOR 
9a20 cd 6f ee			call debug_vector  
9a23				endm  
# End of macro CALLMONITOR
9a23					endif 
9a23				;pop de 
9a23 c9				ret 
9a24			 
9a24			; pop ret stack pointer 
9a24				 
9a24			FORTH_RSP_POP: macro 
9a24				call macro_forth_rsp_pop 
9a24				endm 
9a24			 
9a24			 
9a24			macro_forth_rsp_pop: 
9a24				if DEBUG_FORTH_STACK_GUARD 
9a24			;		DMARK "RPP" 
9a24 cd 5f e0				call check_stacks 
9a27					FORTH_CHK_RSP_UNDER 
9a27 e5				push hl 
9a28 d5				push de 
9a29 2a f2 e9			ld hl,(cli_ret_sp) 
9a2c 11 ac e9			ld de, cli_ret_stack 
9a2f cd f9 8c			call cmp16 
9a32 da 73 e1			jp c, fault_rsp_under 
9a35 d1				pop de 
9a36 e1				pop hl 
9a37				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a37				endif 
9a37 e5				push hl 
9a38 2a f2 e9			ld hl,(cli_ret_sp) 
9a3b			 
9a3b			 
9a3b				if FORTH_ENABLE_FREE 
9a3b			 
9a3b					; get pointer 
9a3b			 
9a3b					push de 
9a3b					push hl 
9a3b			 
9a3b					ld e, (hl) 
9a3b					inc hl 
9a3b					ld d, (hl) 
9a3b			 
9a3b					ex de, hl 
9a3b					call free 
9a3b			 
9a3b					pop hl 
9a3b					pop de 
9a3b			 
9a3b			 
9a3b				endif 
9a3b			 
9a3b			 
9a3b 2b				dec hl 
9a3c 2b				dec hl 
9a3d 22 f2 e9			ld (cli_ret_sp), hl 
9a40				; do stack underflow checks 
9a40 e1				pop hl 
9a41				if DEBUG_FORTH_STACK_GUARD 
9a41 cd 5f e0				call check_stacks 
9a44					FORTH_CHK_RSP_UNDER 
9a44 e5				push hl 
9a45 d5				push de 
9a46 2a f2 e9			ld hl,(cli_ret_sp) 
9a49 11 ac e9			ld de, cli_ret_stack 
9a4c cd f9 8c			call cmp16 
9a4f da 73 e1			jp c, fault_rsp_under 
9a52 d1				pop de 
9a53 e1				pop hl 
9a54				endm 
# End of macro FORTH_CHK_RSP_UNDER
9a54				endif 
9a54 c9				ret 
9a55			 
9a55			 
9a55			 
9a55			; routine to load word pointed to by hl into hl 
9a55			 
9a55			loadhlptrtohl: 
9a55			 
9a55 d5				push de 
9a56 5e				ld e, (hl) 
9a57 23				inc hl 
9a58 56				ld d, (hl) 
9a59 eb				ex de, hl 
9a5a d1				pop de 
9a5b			 
9a5b c9				ret 
9a5c			 
9a5c			 
9a5c			 
9a5c			 
9a5c			 
9a5c			; push a number held in HL onto the data stack 
9a5c			; entry point for pushing a value when already in hl used in function above 
9a5c			 
9a5c			forth_push_numhl: 
9a5c			 
9a5c e5				push hl    ; save value to push 
9a5d			 
9a5d			if DEBUG_FORTH_PUSH 
9a5d				; see if disabled 
9a5d			 
9a5d			 
9a5d f5				push af 
9a5e 3a 6f ee			ld a,(debug_vector) 
9a61 fe c9			cp $c9   ; ret 
9a63			;	ld a, (os_view_disable) 
9a63			;	cp '*' 
9a63 28 34			jr z, .pskip2 
9a65 e5				push hl 
9a66 e5			push hl 
9a67 cd ae 8a			call clear_display 
9a6a e1			pop hl 
9a6b 7c				ld a,h 
9a6c 21 c6 e5			ld hl, os_word_scratch 
9a6f cd f1 8e			call hexout 
9a72 e1				pop hl 
9a73 7d				ld a,l 
9a74 21 c8 e5			ld hl, os_word_scratch+2 
9a77 cd f1 8e			call hexout 
9a7a			 
9a7a 21 ca e5			ld hl, os_word_scratch+4 
9a7d 3e 00			ld a,0 
9a7f 77				ld (hl),a 
9a80 11 c6 e5			ld de,os_word_scratch 
9a83 3e 28				ld a, display_row_2 
9a85 cd c1 8a				call str_at_display 
9a88 11 71 cb			ld de, .push_num 
9a8b 3e 00			ld a, display_row_1 
9a8d			 
9a8d cd c1 8a				call str_at_display 
9a90			 
9a90			 
9a90 cd d1 8a			call update_display 
9a93 cd f1 89			call delay1s 
9a96 cd f1 89			call delay1s 
9a99			.pskip2:  
9a99			 
9a99 f1				pop af 
9a9a			endif	 
9a9a			 
9a9a			 
9a9a				FORTH_DSP_NEXT 
9a9a cd eb 99			call macro_forth_dsp_next 
9a9d				endm 
# End of macro FORTH_DSP_NEXT
9a9d			 
9a9d 2a ee e9			ld hl, (cli_data_sp) 
9aa0			 
9aa0				; save item type 
9aa0 3e 02			ld a,  DS_TYPE_INUM 
9aa2 77				ld (hl), a 
9aa3 23				inc hl 
9aa4			 
9aa4				; get word off stack 
9aa4 d1				pop de 
9aa5 7b				ld a,e 
9aa6 77				ld (hl), a 
9aa7 23				inc hl 
9aa8 7a				ld a,d 
9aa9 77				ld (hl), a 
9aaa			 
9aaa			if DEBUG_FORTH_PUSH 
9aaa 2b				dec hl 
9aab 2b				dec hl 
9aac 2b				dec hl 
9aad						DMARK "PH5" 
9aad f5				push af  
9aae 3a c2 9a			ld a, (.dmark)  
9ab1 32 6b ee			ld (debug_mark),a  
9ab4 3a c3 9a			ld a, (.dmark+1)  
9ab7 32 6c ee			ld (debug_mark+1),a  
9aba 3a c4 9a			ld a, (.dmark+2)  
9abd 32 6d ee			ld (debug_mark+2),a  
9ac0 18 03			jr .pastdmark  
9ac2 ..			.dmark: db "PH5"  
9ac5 f1			.pastdmark: pop af  
9ac6			endm  
# End of macro DMARK
9ac6				CALLMONITOR 
9ac6 cd 6f ee			call debug_vector  
9ac9				endm  
# End of macro CALLMONITOR
9ac9			endif	 
9ac9			 
9ac9 c9				ret 
9aca			 
9aca			 
9aca			; Push a string to stack pointed to by hl 
9aca			 
9aca			forth_push_str: 
9aca			 
9aca			if DEBUG_FORTH_PUSH 
9aca						DMARK "PSQ" 
9aca f5				push af  
9acb 3a df 9a			ld a, (.dmark)  
9ace 32 6b ee			ld (debug_mark),a  
9ad1 3a e0 9a			ld a, (.dmark+1)  
9ad4 32 6c ee			ld (debug_mark+1),a  
9ad7 3a e1 9a			ld a, (.dmark+2)  
9ada 32 6d ee			ld (debug_mark+2),a  
9add 18 03			jr .pastdmark  
9adf ..			.dmark: db "PSQ"  
9ae2 f1			.pastdmark: pop af  
9ae3			endm  
# End of macro DMARK
9ae3				CALLMONITOR 
9ae3 cd 6f ee			call debug_vector  
9ae6				endm  
# End of macro CALLMONITOR
9ae6			endif	 
9ae6			    
9ae6 e5				push hl 
9ae7 e5				push hl 
9ae8			 
9ae8			;	ld a, 0   ; find end of string 
9ae8 cd 4e 90			call strlenz 
9aeb			if DEBUG_FORTH_PUSH 
9aeb						DMARK "PQ2" 
9aeb f5				push af  
9aec 3a 00 9b			ld a, (.dmark)  
9aef 32 6b ee			ld (debug_mark),a  
9af2 3a 01 9b			ld a, (.dmark+1)  
9af5 32 6c ee			ld (debug_mark+1),a  
9af8 3a 02 9b			ld a, (.dmark+2)  
9afb 32 6d ee			ld (debug_mark+2),a  
9afe 18 03			jr .pastdmark  
9b00 ..			.dmark: db "PQ2"  
9b03 f1			.pastdmark: pop af  
9b04			endm  
# End of macro DMARK
9b04				CALLMONITOR 
9b04 cd 6f ee			call debug_vector  
9b07				endm  
# End of macro CALLMONITOR
9b07			endif	 
9b07 eb				ex de, hl 
9b08 e1				pop hl   ; get ptr to start of string 
9b09			if DEBUG_FORTH_PUSH 
9b09						DMARK "PQ3" 
9b09 f5				push af  
9b0a 3a 1e 9b			ld a, (.dmark)  
9b0d 32 6b ee			ld (debug_mark),a  
9b10 3a 1f 9b			ld a, (.dmark+1)  
9b13 32 6c ee			ld (debug_mark+1),a  
9b16 3a 20 9b			ld a, (.dmark+2)  
9b19 32 6d ee			ld (debug_mark+2),a  
9b1c 18 03			jr .pastdmark  
9b1e ..			.dmark: db "PQ3"  
9b21 f1			.pastdmark: pop af  
9b22			endm  
# End of macro DMARK
9b22				CALLMONITOR 
9b22 cd 6f ee			call debug_vector  
9b25				endm  
# End of macro CALLMONITOR
9b25			endif	 
9b25 19				add hl,de 
9b26			if DEBUG_FORTH_PUSH 
9b26						DMARK "PQE" 
9b26 f5				push af  
9b27 3a 3b 9b			ld a, (.dmark)  
9b2a 32 6b ee			ld (debug_mark),a  
9b2d 3a 3c 9b			ld a, (.dmark+1)  
9b30 32 6c ee			ld (debug_mark+1),a  
9b33 3a 3d 9b			ld a, (.dmark+2)  
9b36 32 6d ee			ld (debug_mark+2),a  
9b39 18 03			jr .pastdmark  
9b3b ..			.dmark: db "PQE"  
9b3e f1			.pastdmark: pop af  
9b3f			endm  
# End of macro DMARK
9b3f				CALLMONITOR 
9b3f cd 6f ee			call debug_vector  
9b42				endm  
# End of macro CALLMONITOR
9b42			endif	 
9b42			 
9b42 2b				dec hl    ; see if there is an optional trailing double quote 
9b43 7e				ld a,(hl) 
9b44 fe 22			cp '"' 
9b46 20 03			jr nz, .strnoq 
9b48 3e 00			ld a, 0      ; get rid of double quote 
9b4a 77				ld (hl), a 
9b4b 23			.strnoq: inc hl 
9b4c			 
9b4c 3e 00			ld a, 0 
9b4e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9b4f			 
9b4f 13				inc de ; add one for the type string 
9b50 13				inc de ; add one for null term??? 
9b51			 
9b51				; tos is get string pointer again 
9b51				; de contains space to allocate 
9b51				 
9b51 d5				push de 
9b52			 
9b52 eb				ex de, hl 
9b53			 
9b53				;push af 
9b53			 
9b53			if DEBUG_FORTH_PUSH 
9b53						DMARK "PHm" 
9b53 f5				push af  
9b54 3a 68 9b			ld a, (.dmark)  
9b57 32 6b ee			ld (debug_mark),a  
9b5a 3a 69 9b			ld a, (.dmark+1)  
9b5d 32 6c ee			ld (debug_mark+1),a  
9b60 3a 6a 9b			ld a, (.dmark+2)  
9b63 32 6d ee			ld (debug_mark+2),a  
9b66 18 03			jr .pastdmark  
9b68 ..			.dmark: db "PHm"  
9b6b f1			.pastdmark: pop af  
9b6c			endm  
# End of macro DMARK
9b6c				CALLMONITOR 
9b6c cd 6f ee			call debug_vector  
9b6f				endm  
# End of macro CALLMONITOR
9b6f			endif	 
9b6f cd c3 90			call malloc	; on ret hl now contains allocated memory 
9b72				if DEBUG_FORTH_MALLOC_GUARD 
9b72 cc c9 cb				call z,malloc_error 
9b75				endif 
9b75			 
9b75				 
9b75 c1				pop bc    ; get length 
9b76 d1				pop de   ;  get string start    
9b77			 
9b77				; hl has destination from malloc 
9b77			 
9b77 eb				ex de, hl    ; prep for ldir 
9b78			 
9b78 d5				push de   ; save malloc area for DSP later 
9b79				;push hl   ; save malloc area for DSP later 
9b79			 
9b79			if DEBUG_FORTH_PUSH 
9b79						DMARK "PHc" 
9b79 f5				push af  
9b7a 3a 8e 9b			ld a, (.dmark)  
9b7d 32 6b ee			ld (debug_mark),a  
9b80 3a 8f 9b			ld a, (.dmark+1)  
9b83 32 6c ee			ld (debug_mark+1),a  
9b86 3a 90 9b			ld a, (.dmark+2)  
9b89 32 6d ee			ld (debug_mark+2),a  
9b8c 18 03			jr .pastdmark  
9b8e ..			.dmark: db "PHc"  
9b91 f1			.pastdmark: pop af  
9b92			endm  
# End of macro DMARK
9b92				CALLMONITOR 
9b92 cd 6f ee			call debug_vector  
9b95				endm  
# End of macro CALLMONITOR
9b95			endif	 
9b95			 
9b95			 
9b95 ed b0			ldir 
9b97			 
9b97			 
9b97				; push malloc to data stack     macro?????  
9b97			 
9b97				FORTH_DSP_NEXT 
9b97 cd eb 99			call macro_forth_dsp_next 
9b9a				endm 
# End of macro FORTH_DSP_NEXT
9b9a			 
9b9a				; save value and type 
9b9a			 
9b9a 2a ee e9			ld hl, (cli_data_sp) 
9b9d			 
9b9d				; save item type 
9b9d 3e 01			ld a,  DS_TYPE_STR 
9b9f 77				ld (hl), a 
9ba0 23				inc hl 
9ba1			 
9ba1				; get malloc word off stack 
9ba1 d1				pop de 
9ba2 73				ld (hl), e 
9ba3 23				inc hl 
9ba4 72				ld (hl), d 
9ba5			 
9ba5			 
9ba5			 
9ba5			if DEBUG_FORTH_PUSH 
9ba5 2a ee e9			ld hl, (cli_data_sp) 
9ba8						DMARK "PHS" 
9ba8 f5				push af  
9ba9 3a bd 9b			ld a, (.dmark)  
9bac 32 6b ee			ld (debug_mark),a  
9baf 3a be 9b			ld a, (.dmark+1)  
9bb2 32 6c ee			ld (debug_mark+1),a  
9bb5 3a bf 9b			ld a, (.dmark+2)  
9bb8 32 6d ee			ld (debug_mark+2),a  
9bbb 18 03			jr .pastdmark  
9bbd ..			.dmark: db "PHS"  
9bc0 f1			.pastdmark: pop af  
9bc1			endm  
# End of macro DMARK
9bc1				CALLMONITOR 
9bc1 cd 6f ee			call debug_vector  
9bc4				endm  
# End of macro CALLMONITOR
9bc4			;	ex de,hl 
9bc4			endif	 
9bc4				; in case of spaces, skip the ptr past the copied string 
9bc4				;pop af 
9bc4				;ld (cli_origptr),hl 
9bc4			 
9bc4 c9				ret 
9bc5			 
9bc5			 
9bc5			 
9bc5			; TODO ascii push input onto stack given hl to start of input 
9bc5			 
9bc5			; identify type 
9bc5			; if starts with a " then a string 
9bc5			; otherwise it is a number 
9bc5			;  
9bc5			; if a string 
9bc5			;     scan for ending " to get length of string to malloc for + 1 
9bc5			;     malloc 
9bc5			;     put pointer to string on stack first byte flags as string 
9bc5			; 
9bc5			; else a number 
9bc5			;    look for number format identifier 
9bc5			;    $xx hex 
9bc5			;    %xxxxx bin 
9bc5			;    xxxxx decimal 
9bc5			;    convert number to 16bit word.  
9bc5			;    malloc word + 1 with flag to identiy as num 
9bc5			;    put pointer to number on stack 
9bc5			;   
9bc5			;  
9bc5			  
9bc5			forth_apush: 
9bc5				; kernel push 
9bc5			 
9bc5			if DEBUG_FORTH_PUSH 
9bc5						DMARK "PSH" 
9bc5 f5				push af  
9bc6 3a da 9b			ld a, (.dmark)  
9bc9 32 6b ee			ld (debug_mark),a  
9bcc 3a db 9b			ld a, (.dmark+1)  
9bcf 32 6c ee			ld (debug_mark+1),a  
9bd2 3a dc 9b			ld a, (.dmark+2)  
9bd5 32 6d ee			ld (debug_mark+2),a  
9bd8 18 03			jr .pastdmark  
9bda ..			.dmark: db "PSH"  
9bdd f1			.pastdmark: pop af  
9bde			endm  
# End of macro DMARK
9bde				CALLMONITOR 
9bde cd 6f ee			call debug_vector  
9be1				endm  
# End of macro CALLMONITOR
9be1			endif	 
9be1				; identify input type 
9be1			 
9be1 7e				ld a,(hl) 
9be2 fe 22			cp '"' 
9be4 28 0a			jr z, .fapstr 
9be6 fe 24			cp '$' 
9be8 ca 10 9c			jp z, .faphex 
9beb fe 25			cp '%' 
9bed ca f8 9b			jp z, .fapbin 
9bf0			;	cp 'b' 
9bf0			;	jp z, .fabin 
9bf0				; else decimal 
9bf0			 
9bf0				; TODO do decimal conversion 
9bf0				; decimal is stored as a 16bit word 
9bf0			 
9bf0				; by default everything is a string if type is not detected 
9bf0			.fapstr: ; 
9bf0 fe 22			cp '"' 
9bf2 20 01			jr nz, .strnoqu 
9bf4 23				inc hl 
9bf5			.strnoqu: 
9bf5 c3 ca 9a			jp forth_push_str 
9bf8			 
9bf8			 
9bf8			 
9bf8			.fapbin:    ; push a binary string.  
9bf8 11 00 00			ld de, 0   ; hold a 16bit value 
9bfb			 
9bfb 23			.fapbinshift:	inc hl  
9bfc 7e				ld a,(hl) 
9bfd fe 00			cp 0     ; done scanning  
9bff 28 0b			jr z, .fapbdone  	; got it in HL so push  
9c01			 
9c01				; left shift de 
9c01 eb				ex de, hl	 
9c02 29				add hl, hl 
9c03			 
9c03				; is 1 
9c03 fe 31			cp '1' 
9c05 20 02			jr nz, .binzero 
9c07 cb 4d			bit 1, l 
9c09			.binzero: 
9c09 eb				ex de, hl	 ; save current de 
9c0a 18 ef			jr .fapbinshift 
9c0c			 
9c0c			.fapbdone: 
9c0c eb				ex de, hl 
9c0d c3 5c 9a			jp forth_push_numhl 
9c10			 
9c10			 
9c10			.faphex:   ; hex is always stored as a 16bit word 
9c10				; skip number prefix 
9c10 23				inc hl 
9c11				; turn ascii into number 
9c11 cd a7 8f			call get_word_hl	; ret 16bit word in hl 
9c14			 
9c14 c3 5c 9a			jp forth_push_numhl 
9c17			 
9c17 00				 nop 
9c18			 
9c18			.fabin:   ; TODO bin conversion 
9c18			 
9c18			 
9c18 c9				ret 
9c19			 
9c19			 
9c19			; get either a string ptr or a 16bit word from the data stack 
9c19			 
9c19			FORTH_DSP: macro 
9c19				call macro_forth_dsp 
9c19				endm 
9c19			 
9c19			macro_forth_dsp: 
9c19				; data stack pointer points to current word on tos 
9c19			 
9c19 2a ee e9			ld hl,(cli_data_sp) 
9c1c			 
9c1c				if DEBUG_FORTH_PUSH 
9c1c						DMARK "DSP" 
9c1c f5				push af  
9c1d 3a 31 9c			ld a, (.dmark)  
9c20 32 6b ee			ld (debug_mark),a  
9c23 3a 32 9c			ld a, (.dmark+1)  
9c26 32 6c ee			ld (debug_mark+1),a  
9c29 3a 33 9c			ld a, (.dmark+2)  
9c2c 32 6d ee			ld (debug_mark+2),a  
9c2f 18 03			jr .pastdmark  
9c31 ..			.dmark: db "DSP"  
9c34 f1			.pastdmark: pop af  
9c35			endm  
# End of macro DMARK
9c35			 
9c35 cd fc cb				call display_data_sp 
9c38				;call break_point_state 
9c38				;rst 030h 
9c38				CALLMONITOR 
9c38 cd 6f ee			call debug_vector  
9c3b				endm  
# End of macro CALLMONITOR
9c3b				endif 
9c3b			 
9c3b c9				ret 
9c3c			 
9c3c			; return hl to start of value on stack 
9c3c			 
9c3c			FORTH_DSP_VALUE: macro 
9c3c				call macro_forth_dsp_value 
9c3c				endm 
9c3c			 
9c3c			macro_forth_dsp_value: 
9c3c			 
9c3c				FORTH_DSP 
9c3c cd 19 9c			call macro_forth_dsp 
9c3f				endm 
# End of macro FORTH_DSP
9c3f			 
9c3f d5				push de 
9c40			 
9c40 23				inc hl ; skip type 
9c41			 
9c41 5e				ld e, (hl) 
9c42 23				inc hl 
9c43 56				ld d, (hl) 
9c44 eb				ex de,hl  
9c45			 
9c45 d1				pop de 
9c46			 
9c46 c9				ret 
9c47			 
9c47			; return hl to start of value to second item on stack 
9c47			 
9c47			FORTH_DSP_VALUEM1: macro 
9c47				call macro_forth_dsp_value_m1 
9c47				endm 
9c47			 
9c47			macro_forth_dsp_value_m1: 
9c47			 
9c47				FORTH_DSP 
9c47 cd 19 9c			call macro_forth_dsp 
9c4a				endm 
# End of macro FORTH_DSP
9c4a			 
9c4a 2b				dec hl 
9c4b 2b				dec hl 
9c4c			;	dec hl 
9c4c			 
9c4c d5				push de 
9c4d			 
9c4d 5e				ld e, (hl) 
9c4e 23				inc hl 
9c4f 56				ld d, (hl) 
9c50 eb				ex de,hl  
9c51			 
9c51 d1				pop de 
9c52			 
9c52 c9				ret 
9c53			 
9c53				 
9c53			 
9c53			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9c53			 
9c53			FORTH_DSP_POP: macro 
9c53				call macro_forth_dsp_pop 
9c53				endm 
9c53			 
9c53			 
9c53			; get the tos data type 
9c53			 
9c53			FORTH_DSP_TYPE:   macro 
9c53			 
9c53				;FORTH_DSP_VALUE 
9c53				FORTH_DSP 
9c53				 
9c53				; hl points to value 
9c53				; check type 
9c53			 
9c53				ld a,(hl) 
9c53			 
9c53				endm 
9c53			 
9c53			; load the tos value into hl 
9c53			 
9c53			 
9c53			FORTH_DSP_VALUEHL:  macro 
9c53				call macro_dsp_valuehl 
9c53				endm 
9c53			 
9c53			 
9c53			 
9c53			macro_dsp_valuehl: 
9c53				FORTH_DSP_VALUE 
9c53 cd 3c 9c			call macro_forth_dsp_value 
9c56				endm 
# End of macro FORTH_DSP_VALUE
9c56			 
9c56				;FORTH_ERR_TOS_NOTNUM 
9c56			 
9c56				;inc hl   ; skip type id 
9c56			 
9c56			;	push de 
9c56			; 
9c56			;	ld e, (hl) 
9c56			;	inc hl 
9c56			;	ld d, (hl) 
9c56			;	ex de,hl  
9c56			 
9c56			;	pop de 
9c56			 
9c56				if DEBUG_FORTH_PUSH 
9c56						DMARK "DVL" 
9c56 f5				push af  
9c57 3a 6b 9c			ld a, (.dmark)  
9c5a 32 6b ee			ld (debug_mark),a  
9c5d 3a 6c 9c			ld a, (.dmark+1)  
9c60 32 6c ee			ld (debug_mark+1),a  
9c63 3a 6d 9c			ld a, (.dmark+2)  
9c66 32 6d ee			ld (debug_mark+2),a  
9c69 18 03			jr .pastdmark  
9c6b ..			.dmark: db "DVL"  
9c6e f1			.pastdmark: pop af  
9c6f			endm  
# End of macro DMARK
9c6f				CALLMONITOR 
9c6f cd 6f ee			call debug_vector  
9c72				endm  
# End of macro CALLMONITOR
9c72				endif 
9c72 c9				ret 
9c73			 
9c73			forth_apushstrhl:      
9c73				; push of string requires use of cli_origptr 
9c73				; bodge use 
9c73			 
9c73				; get current cli_origptr, save, update with temp pointer  
9c73 ed 5b 3e ea		ld de, (cli_origptr) 
9c77 22 3e ea			ld (cli_origptr), hl 
9c7a d5				push de 
9c7b cd c5 9b			call forth_apush 
9c7e d1				pop de 
9c7f ed 53 3e ea		ld (cli_origptr), de 
9c83 c9			        ret	 
9c84			 
9c84			 
9c84			; increase loop stack pointer and save hl to it 
9c84				 
9c84			FORTH_LOOP_NEXT: macro 
9c84				call macro_forth_loop_next 
9c84				;nop 
9c84				endm 
9c84			 
9c84			macro_forth_loop_next: 
9c84				if DEBUG_FORTH_STACK_GUARD 
9c84 cd 5f e0				call check_stacks 
9c87				endif 
9c87 e5				push hl 
9c88 d5				push de 
9c89 eb				ex de,hl 
9c8a 2a f0 e9			ld hl,(cli_loop_sp) 
9c8d 23				inc hl 
9c8e 23				inc hl 
9c8f					if DEBUG_FORTH_WORDS 
9c8f						DMARK "LNX" 
9c8f f5				push af  
9c90 3a a4 9c			ld a, (.dmark)  
9c93 32 6b ee			ld (debug_mark),a  
9c96 3a a5 9c			ld a, (.dmark+1)  
9c99 32 6c ee			ld (debug_mark+1),a  
9c9c 3a a6 9c			ld a, (.dmark+2)  
9c9f 32 6d ee			ld (debug_mark+2),a  
9ca2 18 03			jr .pastdmark  
9ca4 ..			.dmark: db "LNX"  
9ca7 f1			.pastdmark: pop af  
9ca8			endm  
# End of macro DMARK
9ca8						CALLMONITOR 
9ca8 cd 6f ee			call debug_vector  
9cab				endm  
# End of macro CALLMONITOR
9cab					endif 
9cab 22 f0 e9			ld (cli_loop_sp),hl 
9cae 73				ld (hl), e 
9caf 23				inc hl 
9cb0 72				ld (hl), d 
9cb1 d1				pop de    ; been reversed so save a swap on restore 
9cb2 e1				pop hl 
9cb3				if DEBUG_FORTH_STACK_GUARD 
9cb3 cd 5f e0				call check_stacks 
9cb6				endif 
9cb6 c9				ret 
9cb7			 
9cb7			; get current ret stack pointer and save to hl  
9cb7				 
9cb7			FORTH_LOOP_TOS: macro 
9cb7				call macro_forth_loop_tos 
9cb7				endm 
9cb7			 
9cb7			macro_forth_loop_tos: 
9cb7 d5				push de 
9cb8 2a f0 e9			ld hl,(cli_loop_sp) 
9cbb 5e				ld e, (hl) 
9cbc 23				inc hl 
9cbd 56				ld d, (hl) 
9cbe eb				ex de, hl 
9cbf d1				pop de 
9cc0 c9				ret 
9cc1			 
9cc1			; pop loop stack pointer 
9cc1				 
9cc1			FORTH_LOOP_POP: macro 
9cc1				call macro_forth_loop_pop 
9cc1				endm 
9cc1			 
9cc1			 
9cc1			macro_forth_loop_pop: 
9cc1				if DEBUG_FORTH_STACK_GUARD 
9cc1					DMARK "LPP" 
9cc1 f5				push af  
9cc2 3a d6 9c			ld a, (.dmark)  
9cc5 32 6b ee			ld (debug_mark),a  
9cc8 3a d7 9c			ld a, (.dmark+1)  
9ccb 32 6c ee			ld (debug_mark+1),a  
9cce 3a d8 9c			ld a, (.dmark+2)  
9cd1 32 6d ee			ld (debug_mark+2),a  
9cd4 18 03			jr .pastdmark  
9cd6 ..			.dmark: db "LPP"  
9cd9 f1			.pastdmark: pop af  
9cda			endm  
# End of macro DMARK
9cda cd 5f e0				call check_stacks 
9cdd					FORTH_CHK_LOOP_UNDER 
9cdd e5				push hl 
9cde d5				push de 
9cdf 2a f0 e9			ld hl,(cli_loop_sp) 
9ce2 11 2a e9			ld de, cli_loop_stack 
9ce5 cd f9 8c			call cmp16 
9ce8 da 79 e1			jp c, fault_loop_under 
9ceb d1				pop de 
9cec e1				pop hl 
9ced				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9ced				endif 
9ced e5				push hl 
9cee 2a f0 e9			ld hl,(cli_loop_sp) 
9cf1 2b				dec hl 
9cf2 2b				dec hl 
9cf3 22 f0 e9			ld (cli_loop_sp), hl 
9cf6				; TODO do stack underflow checks 
9cf6 e1				pop hl 
9cf7				if DEBUG_FORTH_STACK_GUARD 
9cf7 cd 5f e0				call check_stacks 
9cfa					FORTH_CHK_LOOP_UNDER 
9cfa e5				push hl 
9cfb d5				push de 
9cfc 2a f0 e9			ld hl,(cli_loop_sp) 
9cff 11 2a e9			ld de, cli_loop_stack 
9d02 cd f9 8c			call cmp16 
9d05 da 79 e1			jp c, fault_loop_under 
9d08 d1				pop de 
9d09 e1				pop hl 
9d0a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d0a				endif 
9d0a c9				ret 
9d0b			 
9d0b			macro_forth_dsp_pop: 
9d0b			 
9d0b e5				push hl 
9d0c			 
9d0c				; release malloc data 
9d0c			 
9d0c				if DEBUG_FORTH_STACK_GUARD 
9d0c cd 5f e0				call check_stacks 
9d0f					FORTH_CHK_DSP_UNDER 
9d0f e5				push hl 
9d10 d5				push de 
9d11 2a ee e9			ld hl,(cli_data_sp) 
9d14 11 28 e8			ld de, cli_data_stack 
9d17 cd f9 8c			call cmp16 
9d1a da 6d e1			jp c, fault_dsp_under 
9d1d d1				pop de 
9d1e e1				pop hl 
9d1f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d1f				endif 
9d1f				;ld hl,(cli_data_sp) 
9d1f			if DEBUG_FORTH_DOT 
9d1f				DMARK "DPP" 
9d1f f5				push af  
9d20 3a 34 9d			ld a, (.dmark)  
9d23 32 6b ee			ld (debug_mark),a  
9d26 3a 35 9d			ld a, (.dmark+1)  
9d29 32 6c ee			ld (debug_mark+1),a  
9d2c 3a 36 9d			ld a, (.dmark+2)  
9d2f 32 6d ee			ld (debug_mark+2),a  
9d32 18 03			jr .pastdmark  
9d34 ..			.dmark: db "DPP"  
9d37 f1			.pastdmark: pop af  
9d38			endm  
# End of macro DMARK
9d38				CALLMONITOR 
9d38 cd 6f ee			call debug_vector  
9d3b				endm  
# End of macro CALLMONITOR
9d3b			endif	 
9d3b			 
9d3b			 
9d3b			if FORTH_ENABLE_DSPPOPFREE 
9d3b			 
9d3b				FORTH_DSP 
9d3b cd 19 9c			call macro_forth_dsp 
9d3e				endm 
# End of macro FORTH_DSP
9d3e			 
9d3e 7e				ld a, (hl) 
9d3f fe 01			cp DS_TYPE_STR 
9d41 20 23			jr nz, .skippopfree 
9d43			 
9d43				FORTH_DSP_VALUEHL 
9d43 cd 53 9c			call macro_dsp_valuehl 
9d46				endm 
# End of macro FORTH_DSP_VALUEHL
9d46 00				nop 
9d47			if DEBUG_FORTH_DOT 
9d47				DMARK "DPf" 
9d47 f5				push af  
9d48 3a 5c 9d			ld a, (.dmark)  
9d4b 32 6b ee			ld (debug_mark),a  
9d4e 3a 5d 9d			ld a, (.dmark+1)  
9d51 32 6c ee			ld (debug_mark+1),a  
9d54 3a 5e 9d			ld a, (.dmark+2)  
9d57 32 6d ee			ld (debug_mark+2),a  
9d5a 18 03			jr .pastdmark  
9d5c ..			.dmark: db "DPf"  
9d5f f1			.pastdmark: pop af  
9d60			endm  
# End of macro DMARK
9d60				CALLMONITOR 
9d60 cd 6f ee			call debug_vector  
9d63				endm  
# End of macro CALLMONITOR
9d63			endif	 
9d63 cd 8d 91			call free 
9d66			.skippopfree: 
9d66				 
9d66			 
9d66			endif 
9d66			 
9d66			if DEBUG_FORTH_DOT_KEY 
9d66				DMARK "DP2" 
9d66				CALLMONITOR 
9d66			endif	 
9d66			 
9d66				; move pointer down 
9d66			 
9d66 2a ee e9			ld hl,(cli_data_sp) 
9d69 2b				dec hl 
9d6a 2b				dec hl 
9d6b			; PARSEV5 
9d6b 2b				dec hl 
9d6c 22 ee e9			ld (cli_data_sp), hl 
9d6f			 
9d6f				if DEBUG_FORTH_STACK_GUARD 
9d6f cd 5f e0				call check_stacks 
9d72					FORTH_CHK_DSP_UNDER 
9d72 e5				push hl 
9d73 d5				push de 
9d74 2a ee e9			ld hl,(cli_data_sp) 
9d77 11 28 e8			ld de, cli_data_stack 
9d7a cd f9 8c			call cmp16 
9d7d da 6d e1			jp c, fault_dsp_under 
9d80 d1				pop de 
9d81 e1				pop hl 
9d82				endm 
# End of macro FORTH_CHK_DSP_UNDER
9d82				endif 
9d82			 
9d82 e1				pop hl 
9d83			 
9d83 c9				ret 
9d84			 
9d84			getwordathl: 
9d84				; hl points to an address 
9d84				; load hl with the word at that address 
9d84			 
9d84 d5				push de 
9d85			 
9d85 5e				ld e, (hl) 
9d86 23				inc hl 
9d87 56				ld d, (hl) 
9d88 eb				ex de, hl 
9d89			 
9d89 d1				pop de 
9d8a c9				ret 
9d8b			 
9d8b			 
9d8b			 
9d8b			 
9d8b			 
9d8b			; eof 
9d8b			 
# End of file forth_stackopsv5.asm
9d8b			endif 
9d8b			 
9d8b			loadwordinhl:	 
9d8b			 
9d8b d5				push de 
9d8c			 
9d8c 5e				ld e, (hl) 
9d8d 23				inc hl 
9d8e 56				ld d, (hl) 
9d8f eb				ex de,hl  
9d90			 
9d90 d1				pop de 
9d91			 
9d91 c9				ret 
9d92			 
9d92			user_word_eol:  
9d92				; hl contains the pointer to where to create a linked list item from the end 
9d92				; of the user dict to continue on at the system word dict 
9d92				 
9d92				; poke the stub of the word list linked list to repoint to rom words 
9d92			 
9d92				; stub format 
9d92				; db   word id 
9d92				; dw    link to next word 
9d92			        ; db char length of token 
9d92				; db string + 0 term 
9d92				; db exec code....  
9d92			 
9d92 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9d94 77				ld (hl), a		; word id 
9d95 23				inc hl 
9d96			 
9d96 11 61 9f			ld de, sysdict 
9d99 73				ld (hl), e		; next word link ie system dict 
9d9a 23				inc hl 
9d9b 72				ld (hl), d		; next word link ie system dict 
9d9c 23				inc hl	 
9d9d			 
9d9d			;	ld (hl), sysdict		; next word link ie system dict 
9d9d			;	inc hl 
9d9d			;	inc hl 
9d9d			 
9d9d			;	inc hl 
9d9d			;	inc hl 
9d9d			 
9d9d 3e 02			ld a, 2			; word length is 0 
9d9f 77				ld (hl), a	 
9da0 23				inc hl 
9da1			 
9da1 3e 7e			ld a, '~'			; word length is 0 
9da3 77				ld (hl), a	 
9da4 23				inc hl 
9da5 3e 00			ld a, 0			; save empty word 
9da7 77				ld (hl), a 
9da8			 
9da8 c9				ret 
9da9			 
9da9				 
9da9			 
9da9			forthexec_cleanup: 
9da9				FORTH_RSP_POP 
9da9 cd 24 9a			call macro_forth_rsp_pop 
9dac				endm 
# End of macro FORTH_RSP_POP
9dac c9				ret 
9dad			 
9dad			forth_call_hl: 
9dad				; taking hl 
9dad e5				push hl 
9dae c9				ret 
9daf			 
9daf			; this is called to reset Forth system but keep existing uwords etc 
9daf			 
9daf			forth_warmstart: 
9daf				; setup stack over/under flow checks 
9daf				if DEBUG_FORTH_STACK_GUARD 
9daf cd 45 e0				call chk_stk_init 
9db2				endif 
9db2			 
9db2				; init stack pointers  - * these stacks go upwards *  
9db2 21 ac e9			ld hl, cli_ret_stack 
9db5 22 f2 e9			ld (cli_ret_sp), hl	 
9db8				; set bottom of stack 
9db8 3e 00			ld a,0 
9dba 77				ld (hl),a 
9dbb 23				inc hl 
9dbc 77				ld (hl),a 
9dbd			 
9dbd 21 28 e8			ld hl, cli_data_stack 
9dc0 22 ee e9			ld (cli_data_sp), hl	 
9dc3				; set bottom of stack 
9dc3 3e 00			ld a,0 
9dc5 77				ld (hl),a 
9dc6 23				inc hl 
9dc7 77				ld (hl),a 
9dc8			 
9dc8 21 2a e9			ld hl, cli_loop_stack 
9dcb 22 f0 e9			ld (cli_loop_sp), hl	 
9dce				; set bottom of stack 
9dce 3e 00			ld a,0 
9dd0 77				ld (hl),a 
9dd1 23				inc hl 
9dd2 77				ld (hl),a 
9dd3			 
9dd3				; init extent of current open file 
9dd3			 
9dd3 3e 00			ld a, 0 
9dd5 32 6a ea			ld (store_openext), a 
9dd8			 
9dd8 c9				ret 
9dd9			 
9dd9			 
9dd9			 
9dd9			; Cold Start - this is called to setup the whole Forth system 
9dd9			 
9dd9			forth_init: 
9dd9			 
9dd9				; setup stack over/under flow checks 
9dd9			 
9dd9			;	if DEBUG_FORTH_STACK_GUARD 
9dd9			;		call chk_stk_init 
9dd9			;	endif 
9dd9			 
9dd9				; enable auto display updates (slow.....) 
9dd9			 
9dd9 3e 01			ld a, 1 
9ddb 32 3c ea			ld (cli_autodisplay), a 
9dde			 
9dde				; if storage is in use disable long reads for now 
9dde 3e 00			ld a, 0 
9de0 32 75 ea			ld (store_longread), a 
9de3			 
9de3			 
9de3				; show start up screen 
9de3			 
9de3 cd ae 8a			call clear_display 
9de6			 
9de6 3e 00			ld a,0 
9de8 32 5e ea			ld (f_cursor_ptr), a 
9deb			 
9deb				; set start of word list in start of ram - for use when creating user words 
9deb			 
9deb 21 f9 e3			ld hl, baseram 
9dee 22 be e5			ld (os_last_new_uword), hl 
9df1 cd 92 9d			call user_word_eol 
9df4				 
9df4			;		call display_data_sp 
9df4			;		call next_page_prompt 
9df4			 
9df4			 
9df4			 
9df4			 
9df4 c9				ret 
9df5			 
9df5 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e09			 
9e09			; TODO push to stack 
9e09			 
9e09			;  
9e09			 
9e09			if FORTH_PARSEV2 
9e09			 
9e09			 
9e09				include "forth_parserv2.asm" 
9e09			 
9e09			endif 
9e09			 
9e09			 
9e09			; parse cli version 1 
9e09			 
9e09			if FORTH_PARSEV1 
9e09			 
9e09			 
9e09			 
9e09			      include "forth_parserv1.asm" 
9e09			endif 
9e09				 
9e09			if FORTH_PARSEV3 
9e09			 
9e09			 
9e09			 
9e09			      include "forth_parserv3.asm" 
9e09				include "forth_wordsv3.asm" 
9e09			endif 
9e09			 
9e09			if FORTH_PARSEV4 
9e09			 
9e09			 
9e09			 
9e09			      include "forth_parserv4.asm" 
9e09				include "forth_wordsv4.asm" 
9e09			endif 
9e09			 
9e09			if FORTH_PARSEV5 
9e09			 
9e09			 
9e09			 
9e09			      include "forth_parserv5.asm" 
9e09			 
9e09			 
9e09			; A better parser without using malloc and string copies all over the place.  
9e09			; Exec in situ should be faster 
9e09			 
9e09			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e09			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e09			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e09			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e09			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e09			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e09			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e09			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e09			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e09			 
9e09			; Core word preamble macro 
9e09			 
9e09			CWHEAD:   macro nxtword opcode lit len opflags 
9e09				db WORD_SYS_CORE+opcode             
9e09				; internal op code number 
9e09				dw nxtword            
9e09				; link to next dict word block 
9e09				db len + 1 
9e09				; literal length of dict word inc zero term 
9e09				db lit,0              
9e09				; literal dict word 
9e09			        ; TODO db opflags        
9e09				endm 
9e09			 
9e09			 
9e09			NEXTW: macro  
9e09				jp macro_next 
9e09				endm 
9e09			 
9e09			macro_next: 
9e09			if DEBUG_FORTH_PARSE_KEY 
9e09				DMARK "NXT" 
9e09				CALLMONITOR 
9e09			endif	 
9e09			;	inc hl  ; skip token null term  
9e09 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e0d ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e11 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e14			if DEBUG_FORTH_PARSE_KEY 
9e14				DMARK "}AA" 
9e14				CALLMONITOR 
9e14			endif	 
9e14 c3 17 9f			jp execnext 
9e17				;jp exec1 
9e17			       
9e17			 
9e17			 
9e17			; Another go at the parser to compile  
9e17			 
9e17			 
9e17			; TODO rework parser to change all of the string words to byte tokens 
9e17			; TODO do a search for  
9e17			 
9e17			; TODO first run normal parser to zero term sections 
9e17			; TODO for each word do a token look up to get the op code 
9e17			; TODO need some means to flag to the exec that this is a byte code form    
9e17			 
9e17			 
9e17			forthcompile: 
9e17			 
9e17			; 
9e17			; line parse: 
9e17			;       parse raw input buffer 
9e17			;       tokenise the words 
9e17			;       malloc new copy (for looping etc) 
9e17			;       copy to malloc + current pc in line to start of string and add line term 
9e17			;       save on new rsp 
9e17			; 
9e17			 
9e17			; hl to point to the line to tokenise 
9e17			 
9e17			;	push hl 
9e17 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e1a			 
9e1a			;	ld a,0		; string term on input 
9e1a			;	call strlent 
9e1a			 
9e1a			;	ld (os_tok_len), hl	 ; save string length 
9e1a			 
9e1a			;if DEBUG_FORTH_TOK 
9e1a			;	ex de,hl		 
9e1a			;endif 
9e1a			 
9e1a			;	pop hl 		; get back string pointer 
9e1a			 
9e1a			if DEBUG_FORTH_TOK 
9e1a						DMARK "TOc" 
9e1a				CALLMONITOR 
9e1a			endif 
9e1a 7e			.cptoken2:    ld a,(hl) 
9e1b 23				inc hl 
9e1c fe 7f			cp FORTH_END_BUFFER 
9e1e 28 29			jr z, .cptokendone2 
9e20 fe 00			cp 0 
9e22 28 25			jr z, .cptokendone2 
9e24 fe 22			cp '"' 
9e26 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e28 fe 20			cp ' ' 
9e2a 20 ee			jr nz,  .cptoken2 
9e2c			 
9e2c			; TODO consume comments held between ( and ) 
9e2c			 
9e2c				; we have a space so change to zero term for dict match later 
9e2c 2b				dec hl 
9e2d 3e 00			ld a,0 
9e2f 77				ld (hl), a 
9e30 23				inc hl 
9e31 18 e7			jr .cptoken2 
9e33				 
9e33			 
9e33			.cptokenstr2: 
9e33				; skip all white space until either eol (because forgot to term) or end double quote 
9e33			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e33				;inc hl ; skip current double quote 
9e33 7e				ld a,(hl) 
9e34 23				inc hl 
9e35 fe 22			cp '"' 
9e37 28 e1			jr z, .cptoken2 
9e39 fe 7f			cp FORTH_END_BUFFER 
9e3b 28 0c			jr z, .cptokendone2 
9e3d fe 00			cp 0 
9e3f 28 08			jr z, .cptokendone2 
9e41 fe 20			cp ' ' 
9e43 28 02			jr z, .cptmp2 
9e45 18 ec			jr .cptokenstr2 
9e47			 
9e47			.cptmp2:	; we have a space so change to zero term for dict match later 
9e47				;dec hl 
9e47				;ld a,"-"	; TODO remove this when working 
9e47				;ld (hl), a 
9e47				;inc hl 
9e47 18 ea			jr .cptokenstr2 
9e49			 
9e49			.cptokendone2: 
9e49				;inc hl 
9e49 3e 7f			ld a, FORTH_END_BUFFER 
9e4b 77				ld (hl),a 
9e4c 23				inc hl 
9e4d 3e 21			ld a, '!' 
9e4f 77				ld (hl),a 
9e50			 
9e50 2a c2 e5			ld hl,(os_tok_ptr) 
9e53			         
9e53			if DEBUG_FORTH_TOK 
9e53						DMARK "Tc1" 
9e53				CALLMONITOR 
9e53			endif 
9e53			 
9e53				; push exec string to top of return stack 
9e53				FORTH_RSP_NEXT 
9e53 cd 03 9a			call macro_forth_rsp_next 
9e56				endm 
# End of macro FORTH_RSP_NEXT
9e56 c9				ret 
9e57			 
9e57			; Another go at the parser need to simplify the process 
9e57			 
9e57			forthparse: 
9e57			 
9e57			; 
9e57			; line parse: 
9e57			;       parse raw input buffer 
9e57			;       tokenise the words 
9e57			;       malloc new copy (for looping etc) 
9e57			;       copy to malloc + current pc in line to start of string and add line term 
9e57			;       save on new rsp 
9e57			; 
9e57			 
9e57			; hl to point to the line to tokenise 
9e57			 
9e57			;	push hl 
9e57 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9e5a			 
9e5a			;	ld a,0		; string term on input 
9e5a			;	call strlent 
9e5a			 
9e5a			;	ld (os_tok_len), hl	 ; save string length 
9e5a			 
9e5a			;if DEBUG_FORTH_TOK 
9e5a			;	ex de,hl		 
9e5a			;endif 
9e5a			 
9e5a			;	pop hl 		; get back string pointer 
9e5a			 
9e5a			if DEBUG_FORTH_TOK 
9e5a						DMARK "TOK" 
9e5a				CALLMONITOR 
9e5a			endif 
9e5a 7e			.ptoken2:    ld a,(hl) 
9e5b 23				inc hl 
9e5c fe 7f			cp FORTH_END_BUFFER 
9e5e 28 29			jr z, .ptokendone2 
9e60 fe 00			cp 0 
9e62 28 25			jr z, .ptokendone2 
9e64 fe 22			cp '"' 
9e66 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e68 fe 20			cp ' ' 
9e6a 20 ee			jr nz,  .ptoken2 
9e6c			 
9e6c			; TODO consume comments held between ( and ) 
9e6c			 
9e6c				; we have a space so change to zero term for dict match later 
9e6c 2b				dec hl 
9e6d 3e 00			ld a,0 
9e6f 77				ld (hl), a 
9e70 23				inc hl 
9e71 18 e7			jr .ptoken2 
9e73				 
9e73			 
9e73			.ptokenstr2: 
9e73				; skip all white space until either eol (because forgot to term) or end double quote 
9e73			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e73				;inc hl ; skip current double quote 
9e73 7e				ld a,(hl) 
9e74 23				inc hl 
9e75 fe 22			cp '"' 
9e77 28 e1			jr z, .ptoken2 
9e79 fe 7f			cp FORTH_END_BUFFER 
9e7b 28 0c			jr z, .ptokendone2 
9e7d fe 00			cp 0 
9e7f 28 08			jr z, .ptokendone2 
9e81 fe 20			cp ' ' 
9e83 28 02			jr z, .ptmp2 
9e85 18 ec			jr .ptokenstr2 
9e87			 
9e87			.ptmp2:	; we have a space so change to zero term for dict match later 
9e87				;dec hl 
9e87				;ld a,"-"	; TODO remove this when working 
9e87				;ld (hl), a 
9e87				;inc hl 
9e87 18 ea			jr .ptokenstr2 
9e89			 
9e89			.ptokendone2: 
9e89				;inc hl 
9e89 3e 7f			ld a, FORTH_END_BUFFER 
9e8b 77				ld (hl),a 
9e8c 23				inc hl 
9e8d 3e 21			ld a, '!' 
9e8f 77				ld (hl),a 
9e90			 
9e90 2a c2 e5			ld hl,(os_tok_ptr) 
9e93			         
9e93			if DEBUG_FORTH_TOK 
9e93						DMARK "TK1" 
9e93				CALLMONITOR 
9e93			endif 
9e93			 
9e93				; push exec string to top of return stack 
9e93				FORTH_RSP_NEXT 
9e93 cd 03 9a			call macro_forth_rsp_next 
9e96				endm 
# End of macro FORTH_RSP_NEXT
9e96 c9				ret 
9e97			 
9e97			; 
9e97			;	; malloc size + buffer pointer + if is loop flag 
9e97			;	ld hl,(os_tok_len) 		 ; get string length 
9e97			; 
9e97			;	ld a,l 
9e97			; 
9e97			;	cp 0			; we dont want to use a null string 
9e97			;	ret z 
9e97			; 
9e97			;;	add 3    ; prefix malloc with buffer for current word ptr 
9e97			; 
9e97			;	add 5     ; TODO when certain not over writing memory remove 
9e97			; 
9e97			;		 
9e97			; 
9e97			;if DEBUG_FORTH_TOK 
9e97			;			DMARK "TKE" 
9e97			;	CALLMONITOR 
9e97			;endif 
9e97			; 
9e97			;	ld l,a 
9e97			;	ld h,0 
9e97			;;	push hl   ; save required space for the copy later 
9e97			;	call malloc 
9e97			;if DEBUG_FORTH_TOK 
9e97			;			DMARK "TKM" 
9e97			;	CALLMONITOR 
9e97			;endif 
9e97			;	if DEBUG_FORTH_MALLOC_GUARD 
9e97			;		push af 
9e97			;		call ishlzero 
9e97			;;		ld a, l 
9e97			;;		add h 
9e97			;;		cp 0 
9e97			;		pop af 
9e97			;		 
9e97			;		call z,malloc_error 
9e97			;	endif 
9e97			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9e97			; 
9e97			; 
9e97			;if DEBUG_FORTH_TOK 
9e97			;			DMARK "TKR" 
9e97			;	CALLMONITOR 
9e97			;endif 
9e97			; 
9e97			;	FORTH_RSP_NEXT 
9e97			; 
9e97			;	;inc hl	 ; go past current buffer pointer 
9e97			;	;inc hl 
9e97			;	;inc hl   ; and past if loop flag 
9e97			;		; TODO Need to set flag  
9e97			; 
9e97			;	 
9e97			;	 
9e97			;	ex de,hl	; malloc is dest 
9e97			;	ld hl, (os_tok_len) 
9e97			;;	pop bc 
9e97			;	ld c, l                
9e97			;	ld b,0 
9e97			;	ld hl, (os_tok_ptr) 
9e97			; 
9e97			;if DEBUG_FORTH_TOK 
9e97			;			DMARK "TKT" 
9e97			;	CALLMONITOR 
9e97			;endif 
9e97			; 
9e97			;	; do str cpy 
9e97			; 
9e97			;	ldir      ; copy byte in hl to de 
9e97			; 
9e97			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9e97			; 
9e97			;if DEBUG_FORTH_TOK 
9e97			; 
9e97			;			DMARK "TKY" 
9e97			;	CALLMONITOR 
9e97			;endif 
9e97			;	;ld a,0 
9e97			;	;ld a,FORTH_END_BUFFER 
9e97			;	ex de, hl 
9e97			;	;dec hl			 ; go back over the space delim at the end of word 
9e97			;	;ld (hl),a 
9e97			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9e97			;	ld a,FORTH_END_BUFFER 
9e97			;	ld (hl),a 
9e97			;	inc hl 
9e97			;	ld a,FORTH_END_BUFFER 
9e97			;	ld (hl),a 
9e97			; 
9e97			;	; init the malloc area data 
9e97			;	; set pc for in current area 
9e97			;	;ld hl, (os_tok_malloc) 
9e97			;	;inc hl 
9e97			;	;inc hl 
9e97			;	;inc hl 
9e97			;	;ex de,hl 
9e97			;	;ld hl, (os_tok_malloc) 
9e97			;	;ld (hl),e 
9e97			;	;inc hl 
9e97			;	;ld (hl),d 
9e97			; 
9e97			; 
9e97			;	ld hl,(os_tok_malloc) 
9e97			;if DEBUG_FORTH_PARSE_KEY 
9e97			;			DMARK "TKU" 
9e97			;	CALLMONITOR 
9e97			;endif 
9e97			; 
9e97			;	ret 
9e97			 
9e97			forthexec: 
9e97			 
9e97			; line exec: 
9e97			; forth parser 
9e97			 
9e97			; 
9e97			;       get current exec line on rsp 
9e97			 
9e97				FORTH_RSP_TOS 
9e97 cd 1a 9a			call macro_forth_rsp_tos 
9e9a				endm 
# End of macro FORTH_RSP_TOS
9e9a			 
9e9a			;       restore current pc - hl points to malloc of data 
9e9a			 
9e9a				;ld e, (hl) 
9e9a				;inc hl 
9e9a				;ld d, (hl) 
9e9a				;ex de,hl 
9e9a			 
9e9a			 
9e9a			exec1: 
9e9a 22 c2 e5			ld (os_tok_ptr), hl 
9e9d			 
9e9d				; copy our PC to working vars  
9e9d 22 40 ea			ld (cli_ptr), hl 
9ea0 22 3e ea			ld (cli_origptr), hl 
9ea3			 
9ea3 7e				ld a,(hl) 
9ea4 fe 7f			cp FORTH_END_BUFFER 
9ea6 c8				ret z 
9ea7			 
9ea7				; skip any nulls 
9ea7			 
9ea7 fe 00			cp 0 
9ea9 20 03			jr nz, .execword 
9eab 23				inc hl 
9eac 18 ec			jr exec1 
9eae			 
9eae			 
9eae			.execword: 
9eae			 
9eae			 
9eae			 
9eae			if DEBUG_FORTH_PARSE_KEY 
9eae						DMARK "KYQ" 
9eae				CALLMONITOR 
9eae			endif 
9eae			;       while at start of word: 
9eae			; get start of dict (in user area first) 
9eae			 
9eae 21 f9 e3		ld hl, baseram 
9eb1			;ld hl, sysdict 
9eb1 22 42 ea		ld (cli_nextword),hl 
9eb4			;           match word at pc 
9eb4			;           exec word 
9eb4			;           or push to dsp 
9eb4			;           forward to next token 
9eb4			;           if line term pop rsp and exit 
9eb4			;        
9eb4			 
9eb4			if DEBUG_FORTH_PARSE_KEY 
9eb4						DMARK "KYq" 
9eb4				CALLMONITOR 
9eb4			endif 
9eb4			 
9eb4			; 
9eb4			; word comp 
9eb4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9eb4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9eb4			;    move to start of word  
9eb4			;    compare word to cli_token 
9eb4			 
9eb4			.execpnword:	; HL at start of a word in the dictionary to check 
9eb4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9eb4			;	ld (cli_ptr), hl 
9eb4			 
9eb4 2a 42 ea			ld hl,(cli_nextword) 
9eb7			 
9eb7 cd 5a 9f			call forth_tok_next 
9eba			; tok next start here 
9eba			;	; TODO skip compiled symbol for now 
9eba			;	inc hl 
9eba			; 
9eba			;	; save pointer to next word 
9eba			; 
9eba			;	; hl now points to the address of the next word pointer  
9eba			;	ld e, (hl) 
9eba			;	inc hl 
9eba			;	ld d, (hl) 
9eba			;	inc l 
9eba			; 
9eba			;	ex de,hl 
9eba			;if DEBUG_FORTH_PARSE_NEXTWORD 
9eba			;	push bc 
9eba			;	ld bc, (cli_nextword) 
9eba			;			DMARK "NXW" 
9eba			;	CALLMONITOR 
9eba			;	pop bc 
9eba			;endif 
9eba			; tok next end here 
9eba 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9ebd eb				ex de, hl 
9ebe			 
9ebe			 
9ebe				; save the pointer of the current token - 1 to check against 
9ebe				 
9ebe 22 46 ea			ld (cli_token), hl   
9ec1				; TODO maybe remove below save if no debug 
9ec1				; save token string ptr for any debug later 
9ec1 23				inc hl  
9ec2 22 48 ea			ld (cli_origtoken), hl 
9ec5 2b				dec hl 
9ec6				; save pointer to the start of the next dictionay word 
9ec6 7e				ld a,(hl)   ; get string length 
9ec7 47				ld b,a 
9ec8			.execpnwordinc:  
9ec8 23				inc hl 
9ec9 10 fd			djnz .execpnwordinc 
9ecb 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9ece			 
9ece				; now check the word token against the string being parsed 
9ece			 
9ece 2a 46 ea			ld hl,(cli_token) 
9ed1 23				inc hl     ; skip string length (use zero term instead to end) 
9ed2 22 46 ea			ld (cli_token), hl 
9ed5			 
9ed5			if DEBUG_FORTH_PARSE_KEY 
9ed5						DMARK "KY2" 
9ed5			endif 
9ed5			if DEBUG_FORTH_PARSE_EXEC 
9ed5				; see if disabled 
9ed5			 
9ed5			;	ld a, (os_view_disable) 
9ed5			;	cp '*' 
9ed5				ld a, (debug_vector) 
9ed5				cp $c9   ; RET  
9ed5				jr z, .skip 
9ed5			 
9ed5				push hl 
9ed5				push hl 
9ed5				call clear_display 
9ed5				ld de, .compword 
9ed5				ld a, display_row_1 
9ed5				call str_at_display 
9ed5				pop de 
9ed5				ld a, display_row_2 
9ed5				call str_at_display 
9ed5				ld hl,(cli_ptr) 
9ed5				ld a,(hl) 
9ed5			        ld hl, os_word_scratch 
9ed5				ld (hl),a 
9ed5				ld a,0 
9ed5				inc hl 
9ed5				ld (hl),a 	 
9ed5				ld de, os_word_scratch 
9ed5				ld a, display_row_2+10 
9ed5				call str_at_display 
9ed5				call update_display 
9ed5				ld a, 100 
9ed5				call aDelayInMS 
9ed5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ed5				call delay250ms 
9ed5				endif 
9ed5				pop hl 
9ed5			.skip:  
9ed5			endif	 
9ed5			.execpnchar:    ; compare char between token and string to parse 
9ed5			 
9ed5			if DEBUG_FORTH_PARSE_KEY 
9ed5						DMARK "Ky3" 
9ed5			endif 
9ed5			if DEBUG_FORTH_PARSE_EXEC 
9ed5				; see if disabled 
9ed5			 
9ed5			;	ld a, (os_view_disable) 
9ed5			;	cp '*' 
9ed5				ld a, (debug_vector) 
9ed5				cp $C9  ; RET 
9ed5				jr z, .skip2 
9ed5			 
9ed5			;	call clear_display 
9ed5			ld hl,(cli_token) 
9ed5			ld a,(hl) 
9ed5			ld (os_word_scratch),a 
9ed5				ld hl,(cli_ptr) 
9ed5			ld a,(hl) 
9ed5				ld (os_word_scratch+1),a 
9ed5				ld a,0 
9ed5				ld (os_word_scratch+2),a 
9ed5				ld de,os_word_scratch 
9ed5				ld a,display_row_4 
9ed5				call str_at_display 
9ed5				call update_display 
9ed5			.skip2:  
9ed5			endif 
9ed5 2a 46 ea			ld hl,(cli_token) 
9ed8 7e				ld a, (hl)	 ; char in word token 
9ed9 23				inc hl 		; move to next char 
9eda 22 46 ea			ld (cli_token), hl ; and save it 
9edd 47				ld b,a 
9ede			 
9ede 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9ee1 7e				ld a,(hl) 
9ee2 23				inc hl 
9ee3 22 40 ea			ld (cli_ptr), hl		; move to next char 
9ee6 cd 45 90			call toUpper 		; make sure the input string matches case 
9ee9			 
9ee9			if DEBUG_FORTH_PARSE 
9ee9			endif 
9ee9			 
9ee9				; input stream end of token is a space so get rid of it 
9ee9			 
9ee9			;	cp ' ' 
9ee9			;	jr nz, .pnskipspace 
9ee9			; 
9ee9			;	ld a, 0		; make same term as word token term 
9ee9			; 
9ee9			;.pnskipspace: 
9ee9			 
9ee9			if DEBUG_FORTH_PARSE_KEY 
9ee9						DMARK "KY7" 
9ee9			endif 
9ee9 b8				cp b 
9eea c2 00 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9eed				 
9eed			;    if same 
9eed			;       scan for string terms 0 for token and 32 for input 
9eed			 
9eed				 
9eed			if DEBUG_FORTH_PARSE_KEY 
9eed						DMARK "KY8" 
9eed			endif 
9eed			 
9eed 80				add b			 
9eee fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9ef0							; TODO need to make sure last word in zero term string is accounted for 
9ef0 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9ef2			 
9ef2			 
9ef2				; at end of both strings so both are exact match 
9ef2			 
9ef2			;       skip ptr for next word 
9ef2			 
9ef2 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9ef5 23				inc hl			 ; at next char 
9ef6 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9ef9 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9efc				 
9efc				 
9efc			if DEBUG_FORTH_PARSE_KEY 
9efc						DMARK "KY3" 
9efc			endif 
9efc			 
9efc			 
9efc			 
9efc			;       exec code block 
9efc			if DEBUG_FORTH_JP 
9efc				call clear_display 
9efc				call update_display 
9efc				call delay1s 
9efc				ld hl, (cli_execword)     ; save for next check if no match on this word 
9efc				ld a,h 
9efc				ld hl, os_word_scratch 
9efc				call hexout 
9efc				ld hl, (cli_execword)     ; save for next check if no match on this word 
9efc				ld a,l 
9efc				ld hl, os_word_scratch+2 
9efc				call hexout 
9efc				ld hl, os_word_scratch+4 
9efc				ld a,0 
9efc				ld (hl),a 
9efc				ld de,os_word_scratch 
9efc				call str_at_display 
9efc					ld a, display_row_2 
9efc					call str_at_display 
9efc				ld de, (cli_origtoken) 
9efc				ld a, display_row_1+10 
9efc					call str_at_display 
9efc			 
9efc				ld a,display_row_1 
9efc				ld de, .foundword 
9efc				ld a, display_row_3 
9efc				call str_at_display 
9efc				call update_display 
9efc				call delay1s 
9efc				call delay1s 
9efc				call delay1s 
9efc			endif 
9efc			 
9efc			if DEBUG_FORTH_PARSE_KEY 
9efc						DMARK "KYj" 
9efc			endif 
9efc				; TODO save the word pointer in this exec 
9efc			 
9efc 2a 44 ea			ld hl,(cli_execword) 
9eff e9				jp (hl) 
9f00			 
9f00			 
9f00			;    if not same 
9f00			;	scan for zero term 
9f00			;	get ptr for next word 
9f00			;	goto word comp 
9f00			 
9f00			.execpnskipword:	; get pointer to next word 
9f00 2a 42 ea			ld hl,(cli_nextword) 
9f03			 
9f03 7e				ld a,(hl) 
9f04 fe 00			cp WORD_SYS_END 
9f06			;	cp 0 
9f06 28 09			jr z, .execendofdict			 ; at end of words 
9f08			 
9f08			if DEBUG_FORTH_PARSE_KEY 
9f08						DMARK "KY4" 
9f08			endif 
9f08			if DEBUG_FORTH_PARSE_EXEC 
9f08			 
9f08				; see if disabled 
9f08			 
9f08			;	ld a, (os_view_disable) 
9f08			;	cp '*' 
9f08				ld a,(debug_vector) 
9f08				cp $c9   ; RET 
9f08				jr z, .noskip 
9f08			 
9f08			 
9f08				ld de, .nowordfound 
9f08				ld a, display_row_3 
9f08				call str_at_display 
9f08				call update_display 
9f08				ld a, 100 
9f08				call aDelayInMS 
9f08				 
9f08				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f08					call delay250ms 
9f08				endif 
9f08			.noskip:  
9f08			 
9f08			endif	 
9f08			 
9f08 2a 3e ea			ld hl,(cli_origptr) 
9f0b 22 40 ea			ld (cli_ptr),hl 
9f0e			 
9f0e			if DEBUG_FORTH_PARSE_KEY 
9f0e						DMARK "KY5" 
9f0e			endif 
9f0e c3 b4 9e			jp .execpnword			; else go to next word 
9f11			 
9f11			.execendofdict:  
9f11			 
9f11			if DEBUG_FORTH_PARSE_KEY 
9f11						DMARK "KYe" 
9f11			endif 
9f11			if DEBUG_FORTH_PARSE_EXEC 
9f11				; see if disabled 
9f11			 
9f11			;	ld a, (os_view_disable) 
9f11			;	cp '*' 
9f11				ld a,(debug_vector) 
9f11				cp $c9   ; ret 
9f11				jr z, .ispskip 
9f11			 
9f11				call clear_display 
9f11				call update_display 
9f11				call delay1s 
9f11				ld de, (cli_origptr) 
9f11				ld a, display_row_1 
9f11				call str_at_display 
9f11				 
9f11				ld de, .enddict 
9f11				ld a, display_row_3 
9f11				call str_at_display 
9f11				call update_display 
9f11				ld a, 100 
9f11				call aDelayInMS 
9f11				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f11				call delay1s 
9f11				call delay1s 
9f11				call delay1s 
9f11				endif 
9f11			.ispskip:  
9f11				 
9f11			endif	 
9f11			 
9f11			 
9f11			 
9f11				; if the word is not a keyword then must be a literal so push it to stack 
9f11			 
9f11			; push token to stack to end of word 
9f11			 
9f11				STACKFRAME ON $1efe $2f9f 
9f11				if DEBUG_STACK_IMB 
9f11					if ON 
9f11						exx 
9f11						ld de, $1efe 
9f11						ld a, d 
9f11						ld hl, curframe 
9f11						call hexout 
9f11						ld a, e 
9f11						ld hl, curframe+2 
9f11						call hexout 
9f11						ld hl, $1efe 
9f11						push hl 
9f11						ld hl, $2f9f 
9f11						push hl 
9f11						exx 
9f11					endif 
9f11				endif 
9f11			endm 
# End of macro STACKFRAME
9f11			 
9f11 2a c2 e5		ld hl,(os_tok_ptr) 
9f14 cd c5 9b		call forth_apush 
9f17			 
9f17				STACKFRAMECHK ON $1efe $2f9f 
9f17				if DEBUG_STACK_IMB 
9f17					if ON 
9f17						exx 
9f17						ld hl, $2f9f 
9f17						pop de   ; $2f9f 
9f17						call cmp16 
9f17						jr nz, .spnosame 
9f17						ld hl, $1efe 
9f17						pop de   ; $1efe 
9f17						call cmp16 
9f17						jr z, .spfrsame 
9f17						.spnosame: call showsperror 
9f17						.spfrsame: nop 
9f17						exx 
9f17					endif 
9f17				endif 
9f17			endm 
# End of macro STACKFRAMECHK
9f17			 
9f17			execnext: 
9f17			 
9f17			if DEBUG_FORTH_PARSE_KEY 
9f17						DMARK "KY>" 
9f17			endif 
9f17			; move past token to next word 
9f17			 
9f17 2a c2 e5		ld hl, (os_tok_ptr) 
9f1a 3e 00		ld a, 0 
9f1c 01 ff 00		ld bc, 255     ; input buffer size 
9f1f ed b1		cpir 
9f21			 
9f21			if DEBUG_FORTH_PARSE_KEY 
9f21						DMARK "KY!" 
9f21				CALLMONITOR 
9f21			endif	 
9f21			; TODO this might place hl on the null, so will need to forward on??? 
9f21			;inc hl   ; see if this gets onto the next item 
9f21			 
9f21			 
9f21			; TODO pass a pointer to the buffer to push 
9f21			; TODO call function to push 
9f21			 
9f21			; look for end of input 
9f21			 
9f21			;inc hl 
9f21			;ld a,(hl) 
9f21			;cp FORTH_END_BUFFER 
9f21			;ret z 
9f21			 
9f21			 
9f21 c3 9a 9e		jp exec1 
9f24			 
9f24			 
9f24			 
9f24			 
9f24			 
9f24			 
9f24			 
9f24			 
9f24			 
9f24			findnexttok: 
9f24			 
9f24				; hl is pointer to move 
9f24				; de is the token to locate 
9f24			 
9f24					if DEBUG_FORTH 
9f24						DMARK "NTK" 
9f24						CALLMONITOR 
9f24					endif 
9f24 d5				push de 
9f25			 
9f25			.fnt1:	 
9f25				; find first char of token to locate 
9f25			 
9f25 1a				ld a, (de) 
9f26 4f				ld c,a 
9f27 7e				ld a,(hl) 
9f28 cd 45 90			call toUpper 
9f2b					if DEBUG_FORTH 
9f2b						DMARK "NT1" 
9f2b						CALLMONITOR 
9f2b					endif 
9f2b b9				cp c 
9f2c			 
9f2c 28 03			jr z, .fnt2cmpmorefirst	 
9f2e			 
9f2e				; first char not found move to next char 
9f2e			 
9f2e 23				inc hl 
9f2f 18 f4			jr .fnt1 
9f31			 
9f31			.fnt2cmpmorefirst:	 
9f31				; first char of token found.  
9f31			 
9f31 e5				push hl     ; save start of token just in case it is the right one 
9f32 d9				exx 
9f33 e1				pop hl        ; save it to hl' 
9f34 d9				exx 
9f35			 
9f35			 
9f35			.fnt2cmpmore:	 
9f35				; compare the rest 
9f35				 
9f35 23				inc hl 
9f36 13				inc de 
9f37				 
9f37 1a				ld a, (de) 
9f38 4f				ld c,a 
9f39 7e				ld a,(hl) 
9f3a cd 45 90			call toUpper 
9f3d			 
9f3d					if DEBUG_FORTH 
9f3d						DMARK "NT2" 
9f3d						CALLMONITOR 
9f3d					endif 
9f3d				; c has the token to find char 
9f3d				; a has the mem to scan char 
9f3d			 
9f3d b9				cp c 
9f3e 28 04			jr z,.fntmatch1 
9f40			 
9f40				; they are not the same 
9f40			 
9f40					if DEBUG_FORTH 
9f40						DMARK "NT3" 
9f40						CALLMONITOR 
9f40					endif 
9f40 d1				pop de	; reset de token to look for 
9f41 d5				push de 
9f42 18 e1			jr .fnt1 
9f44				 
9f44			.fntmatch1: 
9f44			 
9f44				; is the same char a null which means we might have a full hit? 
9f44					if DEBUG_FORTH 
9f44						DMARK "NT4" 
9f44						CALLMONITOR 
9f44					endif 
9f44			 
9f44 fe 00			cp 0 
9f46 28 0b			jr z, .fntmatchyes 
9f48			 
9f48				; are we at the end of the token to find? 
9f48			 
9f48					if DEBUG_FORTH 
9f48						DMARK "NT5" 
9f48						CALLMONITOR 
9f48					endif 
9f48 3e 00			ld a, 0 
9f4a b9				cp c 
9f4b			 
9f4b c2 35 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9f4e			 
9f4e					if DEBUG_FORTH 
9f4e						DMARK "NT6" 
9f4e						CALLMONITOR 
9f4e					endif 
9f4e				; token to find is exhusted but no match to stream 
9f4e			 
9f4e				; restore tok pointer and continue on 
9f4e d1				pop de 
9f4f d5				push de 
9f50 c3 25 9f			jp .fnt1 
9f53			 
9f53			 
9f53			.fntmatchyes: 
9f53			 
9f53				; hl now contains the end of the found token 
9f53			 
9f53				; get rid of saved token pointer to find 
9f53			 
9f53 d1				pop de 
9f54			 
9f54					if DEBUG_FORTH 
9f54						DMARK "NT9" 
9f54						CALLMONITOR 
9f54					endif 
9f54			 
9f54				; hl will be on the null term so forward on 
9f54			 
9f54				; get back the saved start of the token 
9f54			 
9f54 d9				exx 
9f55 e5				push hl     ; save start of token just in case it is the right one 
9f56 d9				exx 
9f57 e1				pop hl        ; save it to hl 
9f58			 
9f58 c9				ret 
9f59			 
9f59			 
9f59			; LIST needs to find a specific token   
9f59			; FORGET needs to find a spefici token 
9f59			 
9f59			; SAVE needs to find all tokens by flag 
9f59			; WORDS just needs to scan through all  by flag 
9f59			; UWORDS needs to scan through all by flag 
9f59			 
9f59			 
9f59			; given hl as pointer to start of dict look up string 
9f59			; return hl as pointer to start of word block 
9f59			; or 0 if not found 
9f59			 
9f59			forth_find_tok: 
9f59 c9				ret 
9f5a			 
9f5a			; given hl as pointer to dict structure 
9f5a			; move to the next dict block structure 
9f5a			 
9f5a			forth_tok_next: 
9f5a				; hl now points to the address of the next word pointer  
9f5a				; TODO skip compiled symbol for now 
9f5a			;	push de 
9f5a 23				inc hl 
9f5b 5e				ld e, (hl) 
9f5c 23				inc hl 
9f5d 56				ld d, (hl) 
9f5e 23				inc hl 
9f5f			 
9f5f eb				ex de,hl 
9f60			if DEBUG_FORTH_PARSE_NEXTWORD 
9f60				push bc 
9f60				ld bc, (cli_nextword) 
9f60						DMARK "NXW" 
9f60				CALLMONITOR 
9f60				pop bc 
9f60			endif 
9f60			;	pop de	 
9f60 c9				ret 
9f61			 
9f61			 
9f61			 
9f61			; eof 
# End of file forth_parserv5.asm
9f61				include "forth_wordsv4.asm" 
9f61			 
9f61			; the core word dictionary v4 
9f61			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9f61			 
9f61			; this is a linked list for each of the system words used 
9f61			; user defined words will follow the same format but will be in ram 
9f61			 
9f61			 
9f61			; 
9f61			; 
9f61			; define linked list: 
9f61			; 
9f61			; 1. compiled byte op code 
9f61			; 2. len of text word 
9f61			; 3. text word 
9f61			; 4. ptr to next dictionary word 
9f61			; 5. asm, calls etc for the word 
9f61			; 
9f61			;  if 1 == 0 then last word in dict  
9f61			;   
9f61			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9f61			;  
9f61			;  
9f61			; create basic standard set of words 
9f61			; 
9f61			;  
9f61			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9f61			; 2DUP 2DROP 2SWAP  
9f61			; @ C@ - get byte  
9f61			; ! C! - store byte 
9f61			; 0< true if less than zero 
9f61			; 0= true if zero 
9f61			; < >  
9f61			; = true if same 
9f61			; variables 
9f61			 
9f61			 
9f61			; Hardware specific words I may need 
9f61			; 
9f61			; IN OUT  
9f61			; calls to key util functions 
9f61			; calls to hardward abstraction stuff 
9f61			; easy control of frame buffers and lcd i/o 
9f61			; keyboard  
9f61			 
9f61			 
9f61			;DICT: macro 
9f61			; op_code, len, word, next 
9f61			;    word: 
9f61			;    db op_code 
9f61			;    ds word zero term 
9f61			;    dw next 
9f61			;    endm 
9f61			 
9f61			 
9f61			 
9f61			 
9f61			; op code 1 is a flag for user define words which are to be handled differently 
9f61			 
9f61			 
9f61			; 
9f61			; 
9f61			;    TODO on entry to a word this should be the expected environment 
9f61			;    hl - tos value if number then held, if string this is the ptr 
9f61			;    de -  
9f61			 
9f61			 
9f61			; opcode ranges 
9f61			; 0 - end of word dict 
9f61			; 255 - user define words 
9f61			 
9f61			sysdict: 
9f61			include "forth_opcodes.asm" 
9f61			; op codes for forth keywords 
9f61			; free to use code 0  
9f61				OPCODE_HEAP: equ  1 
9f61				OPCODE_EXEC: equ 2 
9f61				OPCODE_DUP: equ 3 
9f61				OPCODE_SWAP: equ 4 
9f61				OPCODE_COLN: equ 5 
9f61				OPCODE_SCOLN: equ 6 
9f61				OPCODE_DROP: equ 7 
9f61				OPCODE_DUP2: equ 8 
9f61				OPCODE_DROP2: equ 9 
9f61				OPCODE_SWAP2: equ 10 
9f61				OPCODE_AT: equ 11 
9f61				OPCODE_CAT: equ 12 
9f61				OPCODE_BANG: equ 13 
9f61				OPCODE_CBANG: equ 14 
9f61				OPCODE_SCALL: equ 15 
9f61				OPCODE_DEPTH: equ 16 
9f61				OPCODE_OVER: equ 17 
9f61				OPCODE_PAUSE: equ 18 
9f61				OPCODE_PAUSES: equ 19 
9f61				OPCODE_ROT: equ 20 
9f61			;free to reuse	OPCODE_WORDS: equ 21 
9f61			        OPCODE_NOT: equ 21 
9f61				OPCODE_UWORDS: equ 22 
9f61				OPCODE_BP: equ 23 
9f61				OPCODE_MONITOR: equ 24  
9f61				OPCODE_MALLOC: equ 25 
9f61				OPCODE_FREE: equ 26 
9f61				OPCODE_LIST: equ 27 
9f61				OPCODE_FORGET: equ 28 
9f61				OPCODE_NOP: equ 29 
9f61				OPCODE_COMO: equ 30 
9f61				OPCODE_COMC: equ 31 
9f61			;free to reuse	OPCODE_ENDCORE: equ 32 
9f61				OPCODE_AFTERSOUND: equ 33 
9f61				OPCODE_GP2: equ 34 
9f61				OPCODE_GP3: equ 35 
9f61				OPCODE_GP4: equ 36 
9f61				OPCODE_SIN: equ 37 
9f61				OPCODE_SOUT: equ 38 
9f61				OPCODE_SPIO: equ 39 
9f61				OPCODE_SPICEH: equ 40 
9f61				OPCODE_SPIOb: equ 41 
9f61				OPCODE_SPII: equ 42 
9f61				OPCODE_SESEL: equ 43 
9f61				OPCODE_CARTDEV: equ 44 
9f61			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9f61				OPCODE_FB: equ 46 
9f61				OPCODE_EMIT: equ 47 
9f61				OPCODE_DOTH: equ 48 
9f61				OPCODE_DOTF: equ 49 
9f61				OPCODE_DOT: equ 50 
9f61				OPCODE_CLS: equ 51 
9f61				OPCODE_DRAW: equ 52 
9f61				OPCODE_DUMP: equ 53 
9f61				OPCODE_CDUMP: equ 54 
9f61				OPCODE_DAT: equ 55 
9f61				OPCODE_HOME: equ 56 
9f61				OPCODE_SPACE: equ 57 
9f61				OPCODE_SPACES: equ 58 
9f61				OPCODE_SCROLL: equ 59 
9f61				OPCODE_ATQ: equ 60 
9f61				OPCODE_AUTODSP: equ 61 
9f61				OPCODE_MENU: equ 62 
9f61			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9f61				OPCODE_THEN: equ 64 
9f61				OPCODE_ELSE: equ 65 
9f61				OPCODE_DO: equ 66 
9f61				OPCODE_LOOP: equ 67 
9f61				OPCODE_I: equ 68 
9f61				OPCODE_DLOOP: equ 69  
9f61				OPCODE_REPEAT: equ 70  
9f61				OPCODE_UNTIL: equ 71 
9f61				OPCODE_ENDFLOW: equ 72 
9f61				OPCODE_WAITK: equ 73 
9f61				OPCODE_ACCEPT: equ 74 
9f61				OPCODE_EDIT: equ 75 
9f61			;free to reuse	OPCODE_ENDKEY: equ 76 
9f61				OPCODE_LZERO: equ 77 
9f61				OPCODE_TZERO: equ 78 
9f61				OPCODE_LESS: equ 79 
9f61				OPCODE_GT: equ 80 
9f61				OPCODE_EQUAL: equ 81  
9f61			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9f61				OPCODE_NEG: equ 83 
9f61				OPCODE_DIV: equ 84 
9f61				OPCODE_MUL: equ 85 
9f61				OPCODE_MIN: equ 86 
9f61				OPCODE_MAX: equ 87 
9f61				OPCODE_RND16: equ 88 
9f61				OPCODE_RND8: equ 89 
9f61				OPCODE_RND: equ 90 
9f61			;free to reuse	OPCODE_ENDMATHS: equ 91  
9f61				OPCODE_BYNAME: equ 92 
9f61				OPCODE_DIR: equ 93 
9f61				OPCODE_SAVE: equ 94 
9f61				OPCODE_LOAD: equ 95 
9f61				OPCODE_BSAVE: equ 96 
9f61				OPCODE_BLOAD: equ 97 
9f61				OPCODE_SEO: equ 98  
9f61				OPCODE_SEI: equ 99 
9f61				OPCODE_SFREE: equ 100 
9f61				OPCODE_SIZE: equ 101 
9f61				OPCODE_CREATE: equ 102 
9f61				OPCODE_APPEND: equ 103 
9f61				OPCODE_SDEL: equ 104 
9f61				OPCODE_OPEN: equ 105 
9f61				OPCODE_READ: equ 106 
9f61				OPCODE_EOF: equ 106 
9f61				OPCODE_FORMAT: equ 107 
9f61				OPCODE_LABEL: equ 108 
9f61				OPCODE_LABELS: equ 109 
9f61			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9f61				OPCODE_UPPER: equ 111 
9f61				OPCODE_LOWER: equ 112 
9f61				OPCODE_SUBSTR: equ 113 
9f61				OPCODE_LEFT: equ 114 
9f61				OPCODE_RIGHT: equ 115 
9f61				OPCODE_STR2NUM: equ 116 
9f61				OPCODE_NUM2STR: equ 117 
9f61				OPCODE_CONCAT: equ 118 
9f61				OPCODE_FIND: equ 119 
9f61				OPCODE_LEN: equ 120 
9f61				OPCODE_CHAR: equ 121 
9f61			; free to reuse	OPCODE_STRLEN: equ 122 
9f61			; free to reuse	OPCODE_ENDSTR: equ 123 
9f61				OPCODE_V0S: equ 124 
9f61				OPCODE_V0Q: equ 125 
9f61				OPCODE_V1S: equ 126 
9f61				OPCODE_V1Q: equ 127 
9f61				OPCODE_V2S: equ 128 
9f61				OPCODE_V2Q: equ 129 
9f61				OPCODE_V3S: equ 130 
9f61				OPCODE_V3Q: equ 131 
9f61			;free to reuse	OPCODE_END: equ 132 
9f61				OPCODE_ZDUP: equ 133 
9f61			 
9f61			; eof 
# End of file forth_opcodes.asm
9f61			 
9f61			include "forth_words_core.asm" 
9f61			 
9f61			; | ## Core Words 
9f61			 
9f61			;if MALLOC_4 
9f61			 
9f61			.HEAP: 
9f61			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9f61 15				db WORD_SYS_CORE+OPCODE_HEAP             
9f62 a0 9f			dw .EXEC            
9f64 05				db 4 + 1 
9f65 .. 00			db "HEAP",0              
9f6a				endm 
# End of macro CWHEAD
9f6a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9f6a			; | | u1 - Current number of bytes in the heap 
9f6a			; | | u2 - Remaining bytes left on the heap 
9f6a			; | |  
9f6a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9f6a			 
9f6a			 
9f6a				if DEBUG_FORTH_WORDS_KEY 
9f6a					DMARK "HEP" 
9f6a f5				push af  
9f6b 3a 7f 9f			ld a, (.dmark)  
9f6e 32 6b ee			ld (debug_mark),a  
9f71 3a 80 9f			ld a, (.dmark+1)  
9f74 32 6c ee			ld (debug_mark+1),a  
9f77 3a 81 9f			ld a, (.dmark+2)  
9f7a 32 6d ee			ld (debug_mark+2),a  
9f7d 18 03			jr .pastdmark  
9f7f ..			.dmark: db "HEP"  
9f82 f1			.pastdmark: pop af  
9f83			endm  
# End of macro DMARK
9f83					CALLMONITOR 
9f83 cd 6f ee			call debug_vector  
9f86				endm  
# End of macro CALLMONITOR
9f86				endif 
9f86 2a 03 e4			ld hl, (free_list )      
9f89 11 08 e4			ld de, heap_start 
9f8c			 
9f8c ed 52			sbc hl, de  
9f8e			 
9f8e cd 5c 9a			call forth_push_numhl 
9f91			 
9f91			 
9f91 ed 5b 03 e4		ld de, (free_list )      
9f95 21 9c e2			ld hl, heap_end 
9f98			 
9f98 ed 52			sbc hl, de 
9f9a			 
9f9a cd 5c 9a			call forth_push_numhl 
9f9d				 
9f9d			 
9f9d				 
9f9d			 
9f9d			 
9f9d			 
9f9d				NEXTW 
9f9d c3 09 9e			jp macro_next 
9fa0				endm 
# End of macro NEXTW
9fa0			;endif 
9fa0			 
9fa0			.EXEC: 
9fa0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9fa0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9fa0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9fa0			;; > > 
9fa0			;; > >   
9fa0			;	STACKFRAME OFF $5efe $5f9f 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS_KEY 
9fa0			;			DMARK "EXE" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			; 
9fa0			;	FORTH_DSP_VALUEHL 
9fa0			; 
9fa0			;	FORTH_DSP_POP 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX1" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;;	ld e,(hl) 
9fa0			;;	inc hl 
9fa0			;;	ld d,(hl) 
9fa0			;;	ex de,hl 
9fa0			; 
9fa0			;;		if DEBUG_FORTH_WORDS 
9fa0			;;			DMARK "EX2" 
9fa0			;;			CALLMONITOR 
9fa0			;;		endif 
9fa0			;	push hl 
9fa0			; 
9fa0			;	;ld a, 0 
9fa0			;	;ld a, FORTH_END_BUFFER 
9fa0			;	call strlenz 
9fa0			;	inc hl   ; include zero term to copy 
9fa0			;	inc hl   ; include term 
9fa0			;	inc hl   ; include term 
9fa0			;	ld b,0 
9fa0			;	ld c,l 
9fa0			;	pop hl 
9fa0			;	ld de, execscratch 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX3" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	ldir 
9fa0			; 
9fa0			; 
9fa0			;	ld hl, execscratch 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EXe" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			; 
9fa0			;	call forthparse 
9fa0			;	call forthexec 
9fa0			;;	call forthexec_cleanup 
9fa0			;;	call forthparse 
9fa0			;;	call forthexec 
9fa0			; 
9fa0			;	STACKFRAMECHK OFF $5efe $5f9f 
9fa0			; 
9fa0			;	; an immediate word so no need to process any more words 
9fa0			;	ret 
9fa0			;	NEXTW 
9fa0			 
9fa0			; dead code - old version  
9fa0			;	FORTH_RSP_NEXT 
9fa0			 
9fa0			;  
9fa0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9fa0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9fa0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9fa0			;	push hl 
9fa0			;	push de 
9fa0			;	push bc 
9fa0			; 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS_KEY 
9fa0			;			DMARK "EXR" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			; 
9fa0			; 
9fa0			; 
9fa0			;	;v5 FORTH_DSP_VALUE 
9fa0			;	FORTH_DSP_VALUEHL 
9fa0			; 
9fa0			;	; TODO do string type checks 
9fa0			; 
9fa0			;;v5	inc hl   ; skip type 
9fa0			; 
9fa0			;	push hl  ; source code  
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX1" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	ld a, 0 
9fa0			;	call strlent 
9fa0			; 
9fa0			;	inc hl 
9fa0			;	inc hl 
9fa0			;	inc hl 
9fa0			;	inc hl 
9fa0			; 
9fa0			;	push hl    ; size 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX2" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	call malloc 
9fa0			; 
9fa0			;	ex de, hl    ; de now contains malloc area 
9fa0			;	pop bc   	; get byte count 
9fa0			;	pop hl      ; get string to copy 
9fa0			; 
9fa0			;	push de     ; save malloc for free later 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX3" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	ldir       ; duplicate string 
9fa0			; 
9fa0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9fa0			;	 
9fa0			;	; TODO fix the parse would be better than this...  
9fa0			;	ex de, hl 
9fa0			;	dec hl 
9fa0			;	ld a, 0 
9fa0			;	ld (hl), a 
9fa0			;	dec hl 
9fa0			;	ld a, ' ' 
9fa0			;	ld (hl), a 
9fa0			;	dec hl 
9fa0			;	ld (hl), a 
9fa0			; 
9fa0			;	dec hl 
9fa0			;	ld (hl), a 
9fa0			; 
9fa0			; 
9fa0			;	FORTH_DSP_POP  
9fa0			; 
9fa0			;	pop hl     
9fa0			;	push hl    ; save malloc area 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX4" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			; 
9fa0			;	call forthparse 
9fa0			;	call forthexec 
9fa0			;	 
9fa0			;	pop hl 
9fa0			;	if DEBUG_FORTH_WORDS 
9fa0			;		DMARK "EX5" 
9fa0			;		CALLMONITOR 
9fa0			;	endif 
9fa0			; 
9fa0			;	if FORTH_ENABLE_FREE 
9fa0			;	call free 
9fa0			;	endif 
9fa0			; 
9fa0			;	if DEBUG_FORTH_WORDS 
9fa0			;		DMARK "EX6" 
9fa0			;		CALLMONITOR 
9fa0			;	endif 
9fa0			; 
9fa0			;	pop bc 
9fa0			;	pop de 
9fa0			;	pop hl 
9fa0			;;	FORTH_RSP_POP	  
9fa0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9fa0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9fa0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9fa0			; 
9fa0			;	if DEBUG_FORTH_WORDS 
9fa0			;		DMARK "EX7" 
9fa0			;		CALLMONITOR 
9fa0			;	endif 
9fa0			;	NEXTW 
9fa0			 
9fa0			;.STKEXEC: 
9fa0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9fa0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9fa0			; 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS_KEY 
9fa0			;			DMARK "STX" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			; 
9fa0			;	FORTH_DSP_VALUEHL 
9fa0			; 
9fa0			;	ld (store_tmp1), hl    ; count 
9fa0			; 
9fa0			;	FORTH_DSP_POP 
9fa0			;.stkexec1: 
9fa0			;	ld hl, (store_tmp1)   ; count 
9fa0			;	ld a, 0 
9fa0			;	cp l 
9fa0			;	ret z 
9fa0			; 
9fa0			;	dec hl 
9fa0			;	ld (store_tmp1), hl    ; count 
9fa0			;	 
9fa0			;	FORTH_DSP_VALUEHL 
9fa0			;	push hl 
9fa0			;	 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EXp" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	FORTH_DSP_POP 
9fa0			; 
9fa0			;	call strlenz 
9fa0			;	inc hl   ; include zero term to copy 
9fa0			;	inc hl   ; include zero term to copy 
9fa0			;	inc hl   ; include zero term to copy 
9fa0			;	ld b,0 
9fa0			;	ld c,l 
9fa0			;	pop hl 
9fa0			;	ld de, execscratch 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EX3" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	ldir 
9fa0			; 
9fa0			; 
9fa0			;	ld hl, execscratch 
9fa0			; 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EXP" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			; 
9fa0			;	call forthparse 
9fa0			;	ld hl, execscratch 
9fa0			;		if DEBUG_FORTH_WORDS 
9fa0			;			DMARK "EXx" 
9fa0			;			CALLMONITOR 
9fa0			;		endif 
9fa0			;	call forthexec 
9fa0			; 
9fa0			;	jp .stkexec1 
9fa0			; 
9fa0			;	ret 
9fa0			 
9fa0			 
9fa0			.DUP: 
9fa0			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9fa0 17				db WORD_SYS_CORE+OPCODE_DUP             
9fa1 16 a0			dw .ZDUP            
9fa3 04				db 3 + 1 
9fa4 .. 00			db "DUP",0              
9fa8				endm 
# End of macro CWHEAD
9fa8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9fa8			 
9fa8				if DEBUG_FORTH_WORDS_KEY 
9fa8					DMARK "DUP" 
9fa8 f5				push af  
9fa9 3a bd 9f			ld a, (.dmark)  
9fac 32 6b ee			ld (debug_mark),a  
9faf 3a be 9f			ld a, (.dmark+1)  
9fb2 32 6c ee			ld (debug_mark+1),a  
9fb5 3a bf 9f			ld a, (.dmark+2)  
9fb8 32 6d ee			ld (debug_mark+2),a  
9fbb 18 03			jr .pastdmark  
9fbd ..			.dmark: db "DUP"  
9fc0 f1			.pastdmark: pop af  
9fc1			endm  
# End of macro DMARK
9fc1					CALLMONITOR 
9fc1 cd 6f ee			call debug_vector  
9fc4				endm  
# End of macro CALLMONITOR
9fc4				endif 
9fc4			 
9fc4				FORTH_DSP 
9fc4 cd 19 9c			call macro_forth_dsp 
9fc7				endm 
# End of macro FORTH_DSP
9fc7			 
9fc7 7e				ld a, (HL) 
9fc8 fe 01			cp DS_TYPE_STR 
9fca 20 25			jr nz, .dupinum 
9fcc			 
9fcc				; push another string 
9fcc			 
9fcc				FORTH_DSP_VALUEHL     		 
9fcc cd 53 9c			call macro_dsp_valuehl 
9fcf				endm 
# End of macro FORTH_DSP_VALUEHL
9fcf			 
9fcf			if DEBUG_FORTH_WORDS 
9fcf				DMARK "DUs" 
9fcf f5				push af  
9fd0 3a e4 9f			ld a, (.dmark)  
9fd3 32 6b ee			ld (debug_mark),a  
9fd6 3a e5 9f			ld a, (.dmark+1)  
9fd9 32 6c ee			ld (debug_mark+1),a  
9fdc 3a e6 9f			ld a, (.dmark+2)  
9fdf 32 6d ee			ld (debug_mark+2),a  
9fe2 18 03			jr .pastdmark  
9fe4 ..			.dmark: db "DUs"  
9fe7 f1			.pastdmark: pop af  
9fe8			endm  
# End of macro DMARK
9fe8				CALLMONITOR 
9fe8 cd 6f ee			call debug_vector  
9feb				endm  
# End of macro CALLMONITOR
9feb			endif 
9feb cd ca 9a			call forth_push_str 
9fee			 
9fee				NEXTW 
9fee c3 09 9e			jp macro_next 
9ff1				endm 
# End of macro NEXTW
9ff1			 
9ff1			 
9ff1			.dupinum: 
9ff1				 
9ff1			 
9ff1			 
9ff1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9ff1 cd 53 9c			call macro_dsp_valuehl 
9ff4				endm 
# End of macro FORTH_DSP_VALUEHL
9ff4			 
9ff4			; TODO add floating point number detection 
9ff4			 
9ff4			if DEBUG_FORTH_WORDS 
9ff4				DMARK "DUi" 
9ff4 f5				push af  
9ff5 3a 09 a0			ld a, (.dmark)  
9ff8 32 6b ee			ld (debug_mark),a  
9ffb 3a 0a a0			ld a, (.dmark+1)  
9ffe 32 6c ee			ld (debug_mark+1),a  
a001 3a 0b a0			ld a, (.dmark+2)  
a004 32 6d ee			ld (debug_mark+2),a  
a007 18 03			jr .pastdmark  
a009 ..			.dmark: db "DUi"  
a00c f1			.pastdmark: pop af  
a00d			endm  
# End of macro DMARK
a00d				CALLMONITOR 
a00d cd 6f ee			call debug_vector  
a010				endm  
# End of macro CALLMONITOR
a010			endif 
a010			 
a010 cd 5c 9a			call forth_push_numhl 
a013				NEXTW 
a013 c3 09 9e			jp macro_next 
a016				endm 
# End of macro NEXTW
a016			.ZDUP: 
a016			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a016 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a017 4e a0			dw .SWAP            
a019 05				db 4 + 1 
a01a .. 00			db "?DUP",0              
a01f				endm 
# End of macro CWHEAD
a01f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a01f			 
a01f				if DEBUG_FORTH_WORDS_KEY 
a01f					DMARK "qDU" 
a01f f5				push af  
a020 3a 34 a0			ld a, (.dmark)  
a023 32 6b ee			ld (debug_mark),a  
a026 3a 35 a0			ld a, (.dmark+1)  
a029 32 6c ee			ld (debug_mark+1),a  
a02c 3a 36 a0			ld a, (.dmark+2)  
a02f 32 6d ee			ld (debug_mark+2),a  
a032 18 03			jr .pastdmark  
a034 ..			.dmark: db "qDU"  
a037 f1			.pastdmark: pop af  
a038			endm  
# End of macro DMARK
a038					CALLMONITOR 
a038 cd 6f ee			call debug_vector  
a03b				endm  
# End of macro CALLMONITOR
a03b				endif 
a03b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a03b cd 53 9c			call macro_dsp_valuehl 
a03e				endm 
# End of macro FORTH_DSP_VALUEHL
a03e			 
a03e e5				push hl 
a03f			 
a03f				; is it a zero? 
a03f			 
a03f 3e 00			ld a, 0 
a041 84				add h 
a042 85				add l 
a043			 
a043 e1				pop hl 
a044			 
a044 fe 00			cp 0 
a046 28 03			jr z, .dup2orig 
a048			 
a048			 
a048 cd 5c 9a			call forth_push_numhl 
a04b			 
a04b			 
a04b			; TODO add floating point number detection 
a04b			 
a04b			.dup2orig: 
a04b			 
a04b				NEXTW 
a04b c3 09 9e			jp macro_next 
a04e				endm 
# End of macro NEXTW
a04e			.SWAP: 
a04e			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a04e 18				db WORD_SYS_CORE+OPCODE_SWAP             
a04f 8d a0			dw .COLN            
a051 05				db 4 + 1 
a052 .. 00			db "SWAP",0              
a057				endm 
# End of macro CWHEAD
a057			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a057				if DEBUG_FORTH_WORDS_KEY 
a057					DMARK "SWP" 
a057 f5				push af  
a058 3a 6c a0			ld a, (.dmark)  
a05b 32 6b ee			ld (debug_mark),a  
a05e 3a 6d a0			ld a, (.dmark+1)  
a061 32 6c ee			ld (debug_mark+1),a  
a064 3a 6e a0			ld a, (.dmark+2)  
a067 32 6d ee			ld (debug_mark+2),a  
a06a 18 03			jr .pastdmark  
a06c ..			.dmark: db "SWP"  
a06f f1			.pastdmark: pop af  
a070			endm  
# End of macro DMARK
a070					CALLMONITOR 
a070 cd 6f ee			call debug_vector  
a073				endm  
# End of macro CALLMONITOR
a073				endif 
a073			 
a073			; TODO Use os stack swap memory 
a073				FORTH_DSP_VALUEHL 
a073 cd 53 9c			call macro_dsp_valuehl 
a076				endm 
# End of macro FORTH_DSP_VALUEHL
a076 e5				push hl     ; w2 
a077			 
a077				FORTH_DSP_POP 
a077 cd 0b 9d			call macro_forth_dsp_pop 
a07a				endm 
# End of macro FORTH_DSP_POP
a07a			 
a07a				FORTH_DSP_VALUEHL 
a07a cd 53 9c			call macro_dsp_valuehl 
a07d				endm 
# End of macro FORTH_DSP_VALUEHL
a07d			 
a07d				FORTH_DSP_POP 
a07d cd 0b 9d			call macro_forth_dsp_pop 
a080				endm 
# End of macro FORTH_DSP_POP
a080			 
a080 d1				pop de     ; w2	, hl = w1 
a081			 
a081 eb				ex de, hl 
a082 d5				push de 
a083			 
a083 cd 5c 9a			call forth_push_numhl 
a086			 
a086 e1				pop hl 
a087			 
a087 cd 5c 9a			call forth_push_numhl 
a08a				 
a08a			 
a08a				NEXTW 
a08a c3 09 9e			jp macro_next 
a08d				endm 
# End of macro NEXTW
a08d			.COLN: 
a08d			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a08d 19				db WORD_SYS_CORE+OPCODE_COLN             
a08e 19 a2			dw .SCOLN            
a090 02				db 1 + 1 
a091 .. 00			db ":",0              
a093				endm 
# End of macro CWHEAD
a093			; | : ( -- )         Create new word | DONE 
a093			 
a093				if DEBUG_FORTH_WORDS_KEY 
a093					DMARK "CLN" 
a093 f5				push af  
a094 3a a8 a0			ld a, (.dmark)  
a097 32 6b ee			ld (debug_mark),a  
a09a 3a a9 a0			ld a, (.dmark+1)  
a09d 32 6c ee			ld (debug_mark+1),a  
a0a0 3a aa a0			ld a, (.dmark+2)  
a0a3 32 6d ee			ld (debug_mark+2),a  
a0a6 18 03			jr .pastdmark  
a0a8 ..			.dmark: db "CLN"  
a0ab f1			.pastdmark: pop af  
a0ac			endm  
# End of macro DMARK
a0ac					CALLMONITOR 
a0ac cd 6f ee			call debug_vector  
a0af				endm  
# End of macro CALLMONITOR
a0af				endif 
a0af			STACKFRAME OFF $8efe $989f 
a0af				if DEBUG_STACK_IMB 
a0af					if OFF 
a0af						exx 
a0af						ld de, $8efe 
a0af						ld a, d 
a0af						ld hl, curframe 
a0af						call hexout 
a0af						ld a, e 
a0af						ld hl, curframe+2 
a0af						call hexout 
a0af						ld hl, $8efe 
a0af						push hl 
a0af						ld hl, $989f 
a0af						push hl 
a0af						exx 
a0af					endif 
a0af				endif 
a0af			endm 
# End of macro STACKFRAME
a0af			; get parser buffer length  of new word 
a0af			 
a0af			 
a0af			 
a0af				; move tok past this to start of name defintition 
a0af				; TODO get word to define 
a0af				; TODO Move past word token 
a0af				; TODO get length of string up to the ';' 
a0af			 
a0af 2a c2 e5		ld hl, (os_tok_ptr) 
a0b2 23			inc hl 
a0b3 23			inc hl 
a0b4			 
a0b4 3e 3b		ld a, ';' 
a0b6 cd 59 90		call strlent 
a0b9			 
a0b9 7d			ld a,l 
a0ba 32 b1 e2		ld (os_new_parse_len), a 
a0bd			 
a0bd			 
a0bd			if DEBUG_FORTH_UWORD 
a0bd ed 5b c2 e5	ld de, (os_tok_ptr) 
a0c1					DMARK ":01" 
a0c1 f5				push af  
a0c2 3a d6 a0			ld a, (.dmark)  
a0c5 32 6b ee			ld (debug_mark),a  
a0c8 3a d7 a0			ld a, (.dmark+1)  
a0cb 32 6c ee			ld (debug_mark+1),a  
a0ce 3a d8 a0			ld a, (.dmark+2)  
a0d1 32 6d ee			ld (debug_mark+2),a  
a0d4 18 03			jr .pastdmark  
a0d6 ..			.dmark: db ":01"  
a0d9 f1			.pastdmark: pop af  
a0da			endm  
# End of macro DMARK
a0da			CALLMONITOR 
a0da cd 6f ee			call debug_vector  
a0dd				endm  
# End of macro CALLMONITOR
a0dd			endif 
a0dd			 
a0dd			; 
a0dd			;  new word memory layout: 
a0dd			;  
a0dd			;    : adg 6666 ;  
a0dd			; 
a0dd			;    db   1     ; user defined word  
a0dd 23			inc hl    
a0de			;    dw   sysdict 
a0de 23			inc hl 
a0df 23			inc hl 
a0e0			;    db <word len>+1 (for null) 
a0e0 23			inc hl 
a0e1			;    db .... <word> 
a0e1			; 
a0e1			 
a0e1 23			inc hl    ; some extras for the word preamble before the above 
a0e2 23			inc hl 
a0e3 23			inc hl 
a0e4 23			inc hl 
a0e5 23			inc hl 
a0e6 23			inc hl 
a0e7 23			inc hl  
a0e8 23			inc hl 
a0e9 23			inc hl 
a0ea 23			inc hl 
a0eb 23			inc hl 
a0ec 23			inc hl 
a0ed 23			inc hl 
a0ee 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a0ef			;       exec word buffer 
a0ef			;	<ptr word>   
a0ef 23			inc hl 
a0f0 23			inc hl 
a0f1			;       <word list><null term> 7F final term 
a0f1			 
a0f1			 
a0f1			if DEBUG_FORTH_UWORD 
a0f1					DMARK ":02" 
a0f1 f5				push af  
a0f2 3a 06 a1			ld a, (.dmark)  
a0f5 32 6b ee			ld (debug_mark),a  
a0f8 3a 07 a1			ld a, (.dmark+1)  
a0fb 32 6c ee			ld (debug_mark+1),a  
a0fe 3a 08 a1			ld a, (.dmark+2)  
a101 32 6d ee			ld (debug_mark+2),a  
a104 18 03			jr .pastdmark  
a106 ..			.dmark: db ":02"  
a109 f1			.pastdmark: pop af  
a10a			endm  
# End of macro DMARK
a10a			CALLMONITOR 
a10a cd 6f ee			call debug_vector  
a10d				endm  
# End of macro CALLMONITOR
a10d			endif 
a10d			 
a10d			 
a10d				; malloc the size 
a10d			 
a10d cd c3 90			call malloc 
a110 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a113			 
a113			;    db   1     ; user defined word  
a113 3e 01			ld a, WORD_SYS_UWORD  
a115 77				ld (hl), a 
a116			 
a116 23			inc hl    
a117			;    dw   sysdict 
a117 11 61 9f		ld de, sysdict       ; continue on with the scan to the system dict 
a11a 73			ld (hl), e 
a11b 23			inc hl 
a11c 72			ld (hl), d 
a11d 23			inc hl 
a11e			 
a11e			 
a11e			;    Setup dict word 
a11e			 
a11e 23			inc hl 
a11f 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a122			 
a122			; 1. get length of dict word 
a122			 
a122			 
a122 2a c2 e5		ld hl, (os_tok_ptr) 
a125 23			inc hl 
a126 23			inc hl    ; position to start of dict word 
a127 3e 00		ld a, 0 
a129 cd 59 90		call strlent 
a12c			 
a12c			 
a12c 23			inc hl    ; to include null??? 
a12d			 
a12d			; write length of dict word 
a12d			 
a12d ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a131 1b			dec de 
a132 eb			ex de, hl 
a133 73			ld (hl), e 
a134 eb			ex de, hl 
a135			 
a135			 
a135			 
a135			; copy  
a135 4d			ld c, l 
a136 06 00		ld b, 0 
a138 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a13c 2a c2 e5		ld hl, (os_tok_ptr) 
a13f 23			inc hl 
a140 23			inc hl    ; position to start of dict word 
a141			 
a141			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a141			 
a141			; TODO need to convert word to upper case 
a141			 
a141			ucasetok:	 
a141 7e			ld a,(hl) 
a142 cd 45 90		call toUpper 
a145 77			ld (hl),a 
a146 ed a0		ldi 
a148 f2 41 a1		jp p, ucasetok 
a14b			 
a14b			 
a14b			 
a14b			; de now points to start of where the word body code should be placed 
a14b ed 53 ad e2	ld (os_new_work_ptr), de 
a14f			; hl now points to the words to throw at forthexec which needs to be copied 
a14f 22 ab e2		ld (os_new_src_ptr), hl 
a152			 
a152			; TODO add 'call to forthexec' 
a152			 
a152			if DEBUG_FORTH_UWORD 
a152 c5			push bc 
a153 ed 4b b3 e2	ld bc, (os_new_malloc) 
a157					DMARK ":0x" 
a157 f5				push af  
a158 3a 6c a1			ld a, (.dmark)  
a15b 32 6b ee			ld (debug_mark),a  
a15e 3a 6d a1			ld a, (.dmark+1)  
a161 32 6c ee			ld (debug_mark+1),a  
a164 3a 6e a1			ld a, (.dmark+2)  
a167 32 6d ee			ld (debug_mark+2),a  
a16a 18 03			jr .pastdmark  
a16c ..			.dmark: db ":0x"  
a16f f1			.pastdmark: pop af  
a170			endm  
# End of macro DMARK
a170			CALLMONITOR 
a170 cd 6f ee			call debug_vector  
a173				endm  
# End of macro CALLMONITOR
a173 c1			pop bc 
a174			endif 
a174			 
a174			 
a174			; create word preamble which should be: 
a174			 
a174			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a174			 
a174			;    ld hl, <word code> 
a174			;    jp user_exec 
a174			;    <word code bytes> 
a174			 
a174			 
a174			;	inc de     ; TODO ??? or are we already past the word's null 
a174 eb			ex de, hl 
a175			 
a175 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a177			 
a177 23			inc hl 
a178 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a17b 23			inc hl 
a17c			 
a17c 23			inc hl 
a17d 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a17f			 
a17f 01 f7 ca		ld bc, user_exec 
a182 23			inc hl 
a183 71			ld (hl), c     ; poke address of user_exec 
a184 23			inc hl 
a185 70			ld (hl), b     
a186			; 
a186			;	inc hl 
a186			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a186			; 
a186			; 
a186			;	ld bc, macro_forth_rsp_next 
a186			;	inc hl 
a186			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a186			;	inc hl 
a186			;	ld (hl), b     
a186			; 
a186			;	inc hl 
a186			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a186			; 
a186			; 
a186			;	inc hl 
a186			;	ld bc, forthexec 
a186			;	ld (hl), c     ; poke address of forthexec 
a186			;	inc hl 
a186			;	ld (hl), b      
a186			; 
a186			;	inc hl 
a186			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a186			; 
a186			;	ld bc, user_dict_next 
a186			;	inc hl 
a186			;	ld (hl), c     ; poke address of forthexec 
a186			;	inc hl 
a186			;	ld (hl), b      
a186			 
a186			; hl is now where we need to copy the word byte data to save this 
a186			 
a186 23			inc hl 
a187 22 a9 e2		ld (os_new_exec), hl 
a18a			 
a18a			; copy definition 
a18a			 
a18a eb			ex de, hl 
a18b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a18b			;	inc de    ; skip the PC for this parse 
a18b 3a b1 e2		ld a, (os_new_parse_len) 
a18e 4f			ld c, a 
a18f 06 00		ld b, 0 
a191 ed b0		ldir		 ; copy defintion 
a193			 
a193			 
a193			; poke the address of where the new word bytes live for forthexec 
a193			 
a193 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a196			 
a196 ed 5b a9 e2	ld de, (os_new_exec)      
a19a			 
a19a 73			ld (hl), e 
a19b 23			inc hl 
a19c 72			ld (hl), d 
a19d			 
a19d				; TODO copy last user dict word next link to this word 
a19d				; TODO update last user dict word to point to this word 
a19d			; 
a19d			; hl f923 de 812a ; bc 811a 
a19d			 
a19d			if DEBUG_FORTH_UWORD 
a19d c5			push bc 
a19e ed 4b b3 e2	ld bc, (os_new_malloc) 
a1a2					DMARK ":0A" 
a1a2 f5				push af  
a1a3 3a b7 a1			ld a, (.dmark)  
a1a6 32 6b ee			ld (debug_mark),a  
a1a9 3a b8 a1			ld a, (.dmark+1)  
a1ac 32 6c ee			ld (debug_mark+1),a  
a1af 3a b9 a1			ld a, (.dmark+2)  
a1b2 32 6d ee			ld (debug_mark+2),a  
a1b5 18 03			jr .pastdmark  
a1b7 ..			.dmark: db ":0A"  
a1ba f1			.pastdmark: pop af  
a1bb			endm  
# End of macro DMARK
a1bb			CALLMONITOR 
a1bb cd 6f ee			call debug_vector  
a1be				endm  
# End of macro CALLMONITOR
a1be c1			pop bc 
a1bf			endif 
a1bf			if DEBUG_FORTH_UWORD 
a1bf c5			push bc 
a1c0 ed 4b b3 e2	ld bc, (os_new_malloc) 
a1c4 03			inc bc 
a1c5 03			inc bc 
a1c6 03			inc bc 
a1c7 03			inc bc 
a1c8 03			inc bc 
a1c9 03			inc bc 
a1ca 03			inc bc 
a1cb 03			inc bc 
a1cc			 
a1cc					DMARK ":0B" 
a1cc f5				push af  
a1cd 3a e1 a1			ld a, (.dmark)  
a1d0 32 6b ee			ld (debug_mark),a  
a1d3 3a e2 a1			ld a, (.dmark+1)  
a1d6 32 6c ee			ld (debug_mark+1),a  
a1d9 3a e3 a1			ld a, (.dmark+2)  
a1dc 32 6d ee			ld (debug_mark+2),a  
a1df 18 03			jr .pastdmark  
a1e1 ..			.dmark: db ":0B"  
a1e4 f1			.pastdmark: pop af  
a1e5			endm  
# End of macro DMARK
a1e5			CALLMONITOR 
a1e5 cd 6f ee			call debug_vector  
a1e8				endm  
# End of macro CALLMONITOR
a1e8 c1			pop bc 
a1e9			endif 
a1e9			 
a1e9			; update word dict linked list for new word 
a1e9			 
a1e9			 
a1e9 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a1ec 23			inc hl     ; move to next work linked list ptr 
a1ed			 
a1ed ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a1f1 73			ld (hl), e 
a1f2 23			inc hl 
a1f3 72			ld (hl), d 
a1f4			 
a1f4			if DEBUG_FORTH_UWORD 
a1f4 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a1f8			endif 
a1f8			 
a1f8 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a1fc			 
a1fc			 
a1fc			if DEBUG_FORTH_UWORD 
a1fc					DMARK ":0+" 
a1fc f5				push af  
a1fd 3a 11 a2			ld a, (.dmark)  
a200 32 6b ee			ld (debug_mark),a  
a203 3a 12 a2			ld a, (.dmark+1)  
a206 32 6c ee			ld (debug_mark+1),a  
a209 3a 13 a2			ld a, (.dmark+2)  
a20c 32 6d ee			ld (debug_mark+2),a  
a20f 18 03			jr .pastdmark  
a211 ..			.dmark: db ":0+"  
a214 f1			.pastdmark: pop af  
a215			endm  
# End of macro DMARK
a215			CALLMONITOR 
a215 cd 6f ee			call debug_vector  
a218				endm  
# End of macro CALLMONITOR
a218			endif 
a218			 
a218			STACKFRAMECHK OFF $8efe $989f 
a218				if DEBUG_STACK_IMB 
a218					if OFF 
a218						exx 
a218						ld hl, $989f 
a218						pop de   ; $989f 
a218						call cmp16 
a218						jr nz, .spnosame 
a218						ld hl, $8efe 
a218						pop de   ; $8efe 
a218						call cmp16 
a218						jr z, .spfrsame 
a218						.spnosame: call showsperror 
a218						.spfrsame: nop 
a218						exx 
a218					endif 
a218				endif 
a218			endm 
# End of macro STACKFRAMECHK
a218			 
a218 c9			ret    ; dont process any remaining parser tokens as they form new word 
a219			 
a219			 
a219			 
a219			 
a219			;		NEXT 
a219			.SCOLN: 
a219			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a219 06			db OPCODE_SCOLN 
a21a 65 a2		dw .DROP 
a21c 02			db 2 
a21d .. 00		db ";",0           
a21f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a21f				if DEBUG_FORTH_WORDS_KEY 
a21f					DMARK "SCN" 
a21f f5				push af  
a220 3a 34 a2			ld a, (.dmark)  
a223 32 6b ee			ld (debug_mark),a  
a226 3a 35 a2			ld a, (.dmark+1)  
a229 32 6c ee			ld (debug_mark+1),a  
a22c 3a 36 a2			ld a, (.dmark+2)  
a22f 32 6d ee			ld (debug_mark+2),a  
a232 18 03			jr .pastdmark  
a234 ..			.dmark: db "SCN"  
a237 f1			.pastdmark: pop af  
a238			endm  
# End of macro DMARK
a238					CALLMONITOR 
a238 cd 6f ee			call debug_vector  
a23b				endm  
# End of macro CALLMONITOR
a23b				endif 
a23b				FORTH_RSP_TOS 
a23b cd 1a 9a			call macro_forth_rsp_tos 
a23e				endm 
# End of macro FORTH_RSP_TOS
a23e e5				push hl 
a23f				FORTH_RSP_POP 
a23f cd 24 9a			call macro_forth_rsp_pop 
a242				endm 
# End of macro FORTH_RSP_POP
a242 e1				pop hl 
a243			;		ex de,hl 
a243 22 c2 e5			ld (os_tok_ptr),hl 
a246			 
a246			if DEBUG_FORTH_UWORD 
a246					DMARK "SCL" 
a246 f5				push af  
a247 3a 5b a2			ld a, (.dmark)  
a24a 32 6b ee			ld (debug_mark),a  
a24d 3a 5c a2			ld a, (.dmark+1)  
a250 32 6c ee			ld (debug_mark+1),a  
a253 3a 5d a2			ld a, (.dmark+2)  
a256 32 6d ee			ld (debug_mark+2),a  
a259 18 03			jr .pastdmark  
a25b ..			.dmark: db "SCL"  
a25e f1			.pastdmark: pop af  
a25f			endm  
# End of macro DMARK
a25f			CALLMONITOR 
a25f cd 6f ee			call debug_vector  
a262				endm  
# End of macro CALLMONITOR
a262			endif 
a262				NEXTW 
a262 c3 09 9e			jp macro_next 
a265				endm 
# End of macro NEXTW
a265			 
a265			.DROP: 
a265			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a265 1b				db WORD_SYS_CORE+OPCODE_DROP             
a266 90 a2			dw .DUP2            
a268 05				db 4 + 1 
a269 .. 00			db "DROP",0              
a26e				endm 
# End of macro CWHEAD
a26e			; | DROP ( w -- )   drop the TOS item   | DONE 
a26e				if DEBUG_FORTH_WORDS_KEY 
a26e					DMARK "DRP" 
a26e f5				push af  
a26f 3a 83 a2			ld a, (.dmark)  
a272 32 6b ee			ld (debug_mark),a  
a275 3a 84 a2			ld a, (.dmark+1)  
a278 32 6c ee			ld (debug_mark+1),a  
a27b 3a 85 a2			ld a, (.dmark+2)  
a27e 32 6d ee			ld (debug_mark+2),a  
a281 18 03			jr .pastdmark  
a283 ..			.dmark: db "DRP"  
a286 f1			.pastdmark: pop af  
a287			endm  
# End of macro DMARK
a287					CALLMONITOR 
a287 cd 6f ee			call debug_vector  
a28a				endm  
# End of macro CALLMONITOR
a28a				endif 
a28a				FORTH_DSP_POP 
a28a cd 0b 9d			call macro_forth_dsp_pop 
a28d				endm 
# End of macro FORTH_DSP_POP
a28d				NEXTW 
a28d c3 09 9e			jp macro_next 
a290				endm 
# End of macro NEXTW
a290			.DUP2: 
a290			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a290 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a291 d5 a2			dw .DROP2            
a293 05				db 4 + 1 
a294 .. 00			db "2DUP",0              
a299				endm 
# End of macro CWHEAD
a299			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a299				if DEBUG_FORTH_WORDS_KEY 
a299					DMARK "2DU" 
a299 f5				push af  
a29a 3a ae a2			ld a, (.dmark)  
a29d 32 6b ee			ld (debug_mark),a  
a2a0 3a af a2			ld a, (.dmark+1)  
a2a3 32 6c ee			ld (debug_mark+1),a  
a2a6 3a b0 a2			ld a, (.dmark+2)  
a2a9 32 6d ee			ld (debug_mark+2),a  
a2ac 18 03			jr .pastdmark  
a2ae ..			.dmark: db "2DU"  
a2b1 f1			.pastdmark: pop af  
a2b2			endm  
# End of macro DMARK
a2b2					CALLMONITOR 
a2b2 cd 6f ee			call debug_vector  
a2b5				endm  
# End of macro CALLMONITOR
a2b5				endif 
a2b5				FORTH_DSP_VALUEHL 
a2b5 cd 53 9c			call macro_dsp_valuehl 
a2b8				endm 
# End of macro FORTH_DSP_VALUEHL
a2b8 e5				push hl      ; 2 
a2b9			 
a2b9				FORTH_DSP_POP 
a2b9 cd 0b 9d			call macro_forth_dsp_pop 
a2bc				endm 
# End of macro FORTH_DSP_POP
a2bc				 
a2bc				FORTH_DSP_VALUEHL 
a2bc cd 53 9c			call macro_dsp_valuehl 
a2bf				endm 
# End of macro FORTH_DSP_VALUEHL
a2bf			;		push hl      ; 1 
a2bf			 
a2bf				FORTH_DSP_POP 
a2bf cd 0b 9d			call macro_forth_dsp_pop 
a2c2				endm 
# End of macro FORTH_DSP_POP
a2c2			 
a2c2			;		pop hl       ; 1 
a2c2 d1				pop de       ; 2 
a2c3			 
a2c3 cd 5c 9a			call forth_push_numhl 
a2c6 eb				ex de, hl 
a2c7 cd 5c 9a			call forth_push_numhl 
a2ca			 
a2ca				 
a2ca eb				ex de, hl 
a2cb			 
a2cb cd 5c 9a			call forth_push_numhl 
a2ce eb				ex de, hl 
a2cf cd 5c 9a			call forth_push_numhl 
a2d2			 
a2d2			 
a2d2				NEXTW 
a2d2 c3 09 9e			jp macro_next 
a2d5				endm 
# End of macro NEXTW
a2d5			.DROP2: 
a2d5			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a2d5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a2d6 04 a3			dw .SWAP2            
a2d8 06				db 5 + 1 
a2d9 .. 00			db "2DROP",0              
a2df				endm 
# End of macro CWHEAD
a2df			; | 2DROP ( w w -- )    Double drop | DONE 
a2df				if DEBUG_FORTH_WORDS_KEY 
a2df					DMARK "2DR" 
a2df f5				push af  
a2e0 3a f4 a2			ld a, (.dmark)  
a2e3 32 6b ee			ld (debug_mark),a  
a2e6 3a f5 a2			ld a, (.dmark+1)  
a2e9 32 6c ee			ld (debug_mark+1),a  
a2ec 3a f6 a2			ld a, (.dmark+2)  
a2ef 32 6d ee			ld (debug_mark+2),a  
a2f2 18 03			jr .pastdmark  
a2f4 ..			.dmark: db "2DR"  
a2f7 f1			.pastdmark: pop af  
a2f8			endm  
# End of macro DMARK
a2f8					CALLMONITOR 
a2f8 cd 6f ee			call debug_vector  
a2fb				endm  
# End of macro CALLMONITOR
a2fb				endif 
a2fb				FORTH_DSP_POP 
a2fb cd 0b 9d			call macro_forth_dsp_pop 
a2fe				endm 
# End of macro FORTH_DSP_POP
a2fe				FORTH_DSP_POP 
a2fe cd 0b 9d			call macro_forth_dsp_pop 
a301				endm 
# End of macro FORTH_DSP_POP
a301				NEXTW 
a301 c3 09 9e			jp macro_next 
a304				endm 
# End of macro NEXTW
a304			.SWAP2: 
a304			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a304 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a305 2d a3			dw .AT            
a307 06				db 5 + 1 
a308 .. 00			db "2SWAP",0              
a30e				endm 
# End of macro CWHEAD
a30e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a30e				if DEBUG_FORTH_WORDS_KEY 
a30e					DMARK "2SW" 
a30e f5				push af  
a30f 3a 23 a3			ld a, (.dmark)  
a312 32 6b ee			ld (debug_mark),a  
a315 3a 24 a3			ld a, (.dmark+1)  
a318 32 6c ee			ld (debug_mark+1),a  
a31b 3a 25 a3			ld a, (.dmark+2)  
a31e 32 6d ee			ld (debug_mark+2),a  
a321 18 03			jr .pastdmark  
a323 ..			.dmark: db "2SW"  
a326 f1			.pastdmark: pop af  
a327			endm  
# End of macro DMARK
a327					CALLMONITOR 
a327 cd 6f ee			call debug_vector  
a32a				endm  
# End of macro CALLMONITOR
a32a				endif 
a32a			; TODO Use os stack swap memory 
a32a				NEXTW 
a32a c3 09 9e			jp macro_next 
a32d				endm 
# End of macro NEXTW
a32d			.AT: 
a32d			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a32d 1f				db WORD_SYS_CORE+OPCODE_AT             
a32e 5f a3			dw .CAT            
a330 02				db 1 + 1 
a331 .. 00			db "@",0              
a333				endm 
# End of macro CWHEAD
a333			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a333			 
a333				if DEBUG_FORTH_WORDS_KEY 
a333					DMARK "AT." 
a333 f5				push af  
a334 3a 48 a3			ld a, (.dmark)  
a337 32 6b ee			ld (debug_mark),a  
a33a 3a 49 a3			ld a, (.dmark+1)  
a33d 32 6c ee			ld (debug_mark+1),a  
a340 3a 4a a3			ld a, (.dmark+2)  
a343 32 6d ee			ld (debug_mark+2),a  
a346 18 03			jr .pastdmark  
a348 ..			.dmark: db "AT."  
a34b f1			.pastdmark: pop af  
a34c			endm  
# End of macro DMARK
a34c					CALLMONITOR 
a34c cd 6f ee			call debug_vector  
a34f				endm  
# End of macro CALLMONITOR
a34f				endif 
a34f			.getbyteat:	 
a34f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a34f cd 53 9c			call macro_dsp_valuehl 
a352				endm 
# End of macro FORTH_DSP_VALUEHL
a352				 
a352			;		push hl 
a352			 
a352				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a352 cd 0b 9d			call macro_forth_dsp_pop 
a355				endm 
# End of macro FORTH_DSP_POP
a355			 
a355			;		pop hl 
a355			 
a355 7e				ld a, (hl) 
a356			 
a356 6f				ld l, a 
a357 26 00			ld h, 0 
a359 cd 5c 9a			call forth_push_numhl 
a35c			 
a35c				NEXTW 
a35c c3 09 9e			jp macro_next 
a35f				endm 
# End of macro NEXTW
a35f			.CAT: 
a35f			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a35f 20				db WORD_SYS_CORE+OPCODE_CAT             
a360 88 a3			dw .BANG            
a362 03				db 2 + 1 
a363 .. 00			db "C@",0              
a366				endm 
# End of macro CWHEAD
a366			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a366				if DEBUG_FORTH_WORDS_KEY 
a366					DMARK "CAA" 
a366 f5				push af  
a367 3a 7b a3			ld a, (.dmark)  
a36a 32 6b ee			ld (debug_mark),a  
a36d 3a 7c a3			ld a, (.dmark+1)  
a370 32 6c ee			ld (debug_mark+1),a  
a373 3a 7d a3			ld a, (.dmark+2)  
a376 32 6d ee			ld (debug_mark+2),a  
a379 18 03			jr .pastdmark  
a37b ..			.dmark: db "CAA"  
a37e f1			.pastdmark: pop af  
a37f			endm  
# End of macro DMARK
a37f					CALLMONITOR 
a37f cd 6f ee			call debug_vector  
a382				endm  
# End of macro CALLMONITOR
a382				endif 
a382 c3 4f a3			jp .getbyteat 
a385				NEXTW 
a385 c3 09 9e			jp macro_next 
a388				endm 
# End of macro NEXTW
a388			.BANG: 
a388			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a388 21				db WORD_SYS_CORE+OPCODE_BANG             
a389 be a3			dw .CBANG            
a38b 02				db 1 + 1 
a38c .. 00			db "!",0              
a38e				endm 
# End of macro CWHEAD
a38e			; | ! ( x w -- ) Store x at address w      | DONE 
a38e				if DEBUG_FORTH_WORDS_KEY 
a38e					DMARK "BNG" 
a38e f5				push af  
a38f 3a a3 a3			ld a, (.dmark)  
a392 32 6b ee			ld (debug_mark),a  
a395 3a a4 a3			ld a, (.dmark+1)  
a398 32 6c ee			ld (debug_mark+1),a  
a39b 3a a5 a3			ld a, (.dmark+2)  
a39e 32 6d ee			ld (debug_mark+2),a  
a3a1 18 03			jr .pastdmark  
a3a3 ..			.dmark: db "BNG"  
a3a6 f1			.pastdmark: pop af  
a3a7			endm  
# End of macro DMARK
a3a7					CALLMONITOR 
a3a7 cd 6f ee			call debug_vector  
a3aa				endm  
# End of macro CALLMONITOR
a3aa				endif 
a3aa			 
a3aa			.storebyteat:		 
a3aa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3aa cd 53 9c			call macro_dsp_valuehl 
a3ad				endm 
# End of macro FORTH_DSP_VALUEHL
a3ad				 
a3ad e5				push hl 
a3ae			 
a3ae				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3ae cd 0b 9d			call macro_forth_dsp_pop 
a3b1				endm 
# End of macro FORTH_DSP_POP
a3b1			 
a3b1				; get byte to poke 
a3b1			 
a3b1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3b1 cd 53 9c			call macro_dsp_valuehl 
a3b4				endm 
# End of macro FORTH_DSP_VALUEHL
a3b4 e5				push hl 
a3b5			 
a3b5			 
a3b5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3b5 cd 0b 9d			call macro_forth_dsp_pop 
a3b8				endm 
# End of macro FORTH_DSP_POP
a3b8			 
a3b8			 
a3b8 d1				pop de 
a3b9 e1				pop hl 
a3ba			 
a3ba 73				ld (hl),e 
a3bb			 
a3bb			 
a3bb				NEXTW 
a3bb c3 09 9e			jp macro_next 
a3be				endm 
# End of macro NEXTW
a3be			.CBANG: 
a3be			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a3be 22				db WORD_SYS_CORE+OPCODE_CBANG             
a3bf e7 a3			dw .SCALL            
a3c1 03				db 2 + 1 
a3c2 .. 00			db "C!",0              
a3c5				endm 
# End of macro CWHEAD
a3c5			; | C!  ( x w -- ) Store x at address w  | DONE 
a3c5				if DEBUG_FORTH_WORDS_KEY 
a3c5					DMARK "CBA" 
a3c5 f5				push af  
a3c6 3a da a3			ld a, (.dmark)  
a3c9 32 6b ee			ld (debug_mark),a  
a3cc 3a db a3			ld a, (.dmark+1)  
a3cf 32 6c ee			ld (debug_mark+1),a  
a3d2 3a dc a3			ld a, (.dmark+2)  
a3d5 32 6d ee			ld (debug_mark+2),a  
a3d8 18 03			jr .pastdmark  
a3da ..			.dmark: db "CBA"  
a3dd f1			.pastdmark: pop af  
a3de			endm  
# End of macro DMARK
a3de					CALLMONITOR 
a3de cd 6f ee			call debug_vector  
a3e1				endm  
# End of macro CALLMONITOR
a3e1				endif 
a3e1 c3 aa a3			jp .storebyteat 
a3e4				NEXTW 
a3e4 c3 09 9e			jp macro_next 
a3e7				endm 
# End of macro NEXTW
a3e7			.SCALL: 
a3e7			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a3e7 23				db WORD_SYS_CORE+OPCODE_SCALL             
a3e8 1b a4			dw .DEPTH            
a3ea 05				db 4 + 1 
a3eb .. 00			db "CALL",0              
a3f0				endm 
# End of macro CWHEAD
a3f0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a3f0				if DEBUG_FORTH_WORDS_KEY 
a3f0					DMARK "CLL" 
a3f0 f5				push af  
a3f1 3a 05 a4			ld a, (.dmark)  
a3f4 32 6b ee			ld (debug_mark),a  
a3f7 3a 06 a4			ld a, (.dmark+1)  
a3fa 32 6c ee			ld (debug_mark+1),a  
a3fd 3a 07 a4			ld a, (.dmark+2)  
a400 32 6d ee			ld (debug_mark+2),a  
a403 18 03			jr .pastdmark  
a405 ..			.dmark: db "CLL"  
a408 f1			.pastdmark: pop af  
a409			endm  
# End of macro DMARK
a409					CALLMONITOR 
a409 cd 6f ee			call debug_vector  
a40c				endm  
# End of macro CALLMONITOR
a40c				endif 
a40c			 
a40c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a40c cd 53 9c			call macro_dsp_valuehl 
a40f				endm 
# End of macro FORTH_DSP_VALUEHL
a40f			 
a40f			;		push hl 
a40f			 
a40f				; destroy value TOS 
a40f			 
a40f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a40f cd 0b 9d			call macro_forth_dsp_pop 
a412				endm 
# End of macro FORTH_DSP_POP
a412			 
a412					 
a412			;		pop hl 
a412			 
a412				; how to do a call with hl???? save SP? 
a412 cd ad 9d			call forth_call_hl 
a415			 
a415			 
a415				; TODO push value back onto stack for another op etc 
a415			 
a415 cd 5c 9a			call forth_push_numhl 
a418				NEXTW 
a418 c3 09 9e			jp macro_next 
a41b				endm 
# End of macro NEXTW
a41b			.DEPTH: 
a41b			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a41b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a41c 58 a4			dw .OVER            
a41e 06				db 5 + 1 
a41f .. 00			db "DEPTH",0              
a425				endm 
# End of macro CWHEAD
a425			; | DEPTH ( -- u ) Push count of stack | DONE 
a425				; take current TOS and remove from base value div by two to get count 
a425				if DEBUG_FORTH_WORDS_KEY 
a425					DMARK "DEP" 
a425 f5				push af  
a426 3a 3a a4			ld a, (.dmark)  
a429 32 6b ee			ld (debug_mark),a  
a42c 3a 3b a4			ld a, (.dmark+1)  
a42f 32 6c ee			ld (debug_mark+1),a  
a432 3a 3c a4			ld a, (.dmark+2)  
a435 32 6d ee			ld (debug_mark+2),a  
a438 18 03			jr .pastdmark  
a43a ..			.dmark: db "DEP"  
a43d f1			.pastdmark: pop af  
a43e			endm  
# End of macro DMARK
a43e					CALLMONITOR 
a43e cd 6f ee			call debug_vector  
a441				endm  
# End of macro CALLMONITOR
a441				endif 
a441			 
a441			 
a441 2a ee e9		ld hl, (cli_data_sp) 
a444 11 28 e8		ld de, cli_data_stack 
a447 ed 52		sbc hl,de 
a449			 
a449			; div by size of stack item 
a449			 
a449 5d			ld e,l 
a44a 0e 03		ld c, 3 
a44c cd 6b 8c		call Div8 
a44f			 
a44f 6f			ld l,a 
a450 26 00		ld h,0 
a452			 
a452			;srl h 
a452			;rr l 
a452			 
a452 cd 5c 9a			call forth_push_numhl 
a455				NEXTW 
a455 c3 09 9e			jp macro_next 
a458				endm 
# End of macro NEXTW
a458			.OVER: 
a458			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a458 42				db WORD_SYS_CORE+46             
a459 9f a4			dw .PAUSE            
a45b 05				db 4 + 1 
a45c .. 00			db "OVER",0              
a461				endm 
# End of macro CWHEAD
a461			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a461				if DEBUG_FORTH_WORDS_KEY 
a461					DMARK "OVR" 
a461 f5				push af  
a462 3a 76 a4			ld a, (.dmark)  
a465 32 6b ee			ld (debug_mark),a  
a468 3a 77 a4			ld a, (.dmark+1)  
a46b 32 6c ee			ld (debug_mark+1),a  
a46e 3a 78 a4			ld a, (.dmark+2)  
a471 32 6d ee			ld (debug_mark+2),a  
a474 18 03			jr .pastdmark  
a476 ..			.dmark: db "OVR"  
a479 f1			.pastdmark: pop af  
a47a			endm  
# End of macro DMARK
a47a					CALLMONITOR 
a47a cd 6f ee			call debug_vector  
a47d				endm  
# End of macro CALLMONITOR
a47d				endif 
a47d			 
a47d			; TODO Use os stack swap memory 
a47d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a47d cd 53 9c			call macro_dsp_valuehl 
a480				endm 
# End of macro FORTH_DSP_VALUEHL
a480 e5				push hl    ; n2 
a481				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a481 cd 0b 9d			call macro_forth_dsp_pop 
a484				endm 
# End of macro FORTH_DSP_POP
a484			 
a484				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a484 cd 53 9c			call macro_dsp_valuehl 
a487				endm 
# End of macro FORTH_DSP_VALUEHL
a487 e5				push hl    ; n1 
a488				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a488 cd 0b 9d			call macro_forth_dsp_pop 
a48b				endm 
# End of macro FORTH_DSP_POP
a48b			 
a48b d1				pop de     ; n1 
a48c e1				pop hl     ; n2 
a48d			 
a48d d5				push de 
a48e e5				push hl 
a48f d5				push de 
a490			 
a490				; push back  
a490			 
a490 e1				pop hl 
a491 cd 5c 9a			call forth_push_numhl 
a494 e1				pop hl 
a495 cd 5c 9a			call forth_push_numhl 
a498 e1				pop hl 
a499 cd 5c 9a			call forth_push_numhl 
a49c				NEXTW 
a49c c3 09 9e			jp macro_next 
a49f				endm 
# End of macro NEXTW
a49f			 
a49f			.PAUSE: 
a49f			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a49f 43				db WORD_SYS_CORE+47             
a4a0 d4 a4			dw .PAUSES            
a4a2 08				db 7 + 1 
a4a3 .. 00			db "PAUSEMS",0              
a4ab				endm 
# End of macro CWHEAD
a4ab			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a4ab				if DEBUG_FORTH_WORDS_KEY 
a4ab					DMARK "PMS" 
a4ab f5				push af  
a4ac 3a c0 a4			ld a, (.dmark)  
a4af 32 6b ee			ld (debug_mark),a  
a4b2 3a c1 a4			ld a, (.dmark+1)  
a4b5 32 6c ee			ld (debug_mark+1),a  
a4b8 3a c2 a4			ld a, (.dmark+2)  
a4bb 32 6d ee			ld (debug_mark+2),a  
a4be 18 03			jr .pastdmark  
a4c0 ..			.dmark: db "PMS"  
a4c3 f1			.pastdmark: pop af  
a4c4			endm  
# End of macro DMARK
a4c4					CALLMONITOR 
a4c4 cd 6f ee			call debug_vector  
a4c7				endm  
# End of macro CALLMONITOR
a4c7				endif 
a4c7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c7 cd 53 9c			call macro_dsp_valuehl 
a4ca				endm 
# End of macro FORTH_DSP_VALUEHL
a4ca			;		push hl    ; n2 
a4ca				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ca cd 0b 9d			call macro_forth_dsp_pop 
a4cd				endm 
# End of macro FORTH_DSP_POP
a4cd			;		pop hl 
a4cd			 
a4cd 7d				ld a, l 
a4ce cd d6 89			call aDelayInMS 
a4d1			       NEXTW 
a4d1 c3 09 9e			jp macro_next 
a4d4				endm 
# End of macro NEXTW
a4d4			.PAUSES:  
a4d4			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a4d4 44				db WORD_SYS_CORE+48             
a4d5 43 a5			dw .ROT            
a4d7 06				db 5 + 1 
a4d8 .. 00			db "PAUSE",0              
a4de				endm 
# End of macro CWHEAD
a4de			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a4de				if DEBUG_FORTH_WORDS_KEY 
a4de					DMARK "PAU" 
a4de f5				push af  
a4df 3a f3 a4			ld a, (.dmark)  
a4e2 32 6b ee			ld (debug_mark),a  
a4e5 3a f4 a4			ld a, (.dmark+1)  
a4e8 32 6c ee			ld (debug_mark+1),a  
a4eb 3a f5 a4			ld a, (.dmark+2)  
a4ee 32 6d ee			ld (debug_mark+2),a  
a4f1 18 03			jr .pastdmark  
a4f3 ..			.dmark: db "PAU"  
a4f6 f1			.pastdmark: pop af  
a4f7			endm  
# End of macro DMARK
a4f7					CALLMONITOR 
a4f7 cd 6f ee			call debug_vector  
a4fa				endm  
# End of macro CALLMONITOR
a4fa				endif 
a4fa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4fa cd 53 9c			call macro_dsp_valuehl 
a4fd				endm 
# End of macro FORTH_DSP_VALUEHL
a4fd			;		push hl    ; n2 
a4fd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fd cd 0b 9d			call macro_forth_dsp_pop 
a500				endm 
# End of macro FORTH_DSP_POP
a500			;		pop hl 
a500 45				ld b, l 
a501				if DEBUG_FORTH_WORDS 
a501					DMARK "PAU" 
a501 f5				push af  
a502 3a 16 a5			ld a, (.dmark)  
a505 32 6b ee			ld (debug_mark),a  
a508 3a 17 a5			ld a, (.dmark+1)  
a50b 32 6c ee			ld (debug_mark+1),a  
a50e 3a 18 a5			ld a, (.dmark+2)  
a511 32 6d ee			ld (debug_mark+2),a  
a514 18 03			jr .pastdmark  
a516 ..			.dmark: db "PAU"  
a519 f1			.pastdmark: pop af  
a51a			endm  
# End of macro DMARK
a51a					CALLMONITOR 
a51a cd 6f ee			call debug_vector  
a51d				endm  
# End of macro CALLMONITOR
a51d				endif 
a51d c5			.pauses1:	push bc 
a51e cd f1 89			call delay1s 
a521 c1				pop bc 
a522				if DEBUG_FORTH_WORDS 
a522					DMARK "PA1" 
a522 f5				push af  
a523 3a 37 a5			ld a, (.dmark)  
a526 32 6b ee			ld (debug_mark),a  
a529 3a 38 a5			ld a, (.dmark+1)  
a52c 32 6c ee			ld (debug_mark+1),a  
a52f 3a 39 a5			ld a, (.dmark+2)  
a532 32 6d ee			ld (debug_mark+2),a  
a535 18 03			jr .pastdmark  
a537 ..			.dmark: db "PA1"  
a53a f1			.pastdmark: pop af  
a53b			endm  
# End of macro DMARK
a53b					CALLMONITOR 
a53b cd 6f ee			call debug_vector  
a53e				endm  
# End of macro CALLMONITOR
a53e				endif 
a53e 10 dd			djnz .pauses1 
a540			 
a540			       NEXTW 
a540 c3 09 9e			jp macro_next 
a543				endm 
# End of macro NEXTW
a543			.ROT: 
a543			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a543 45				db WORD_SYS_CORE+49             
a544 91 a5			dw .UWORDS            
a546 04				db 3 + 1 
a547 .. 00			db "ROT",0              
a54b				endm 
# End of macro CWHEAD
a54b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a54b				if DEBUG_FORTH_WORDS_KEY 
a54b					DMARK "ROT" 
a54b f5				push af  
a54c 3a 60 a5			ld a, (.dmark)  
a54f 32 6b ee			ld (debug_mark),a  
a552 3a 61 a5			ld a, (.dmark+1)  
a555 32 6c ee			ld (debug_mark+1),a  
a558 3a 62 a5			ld a, (.dmark+2)  
a55b 32 6d ee			ld (debug_mark+2),a  
a55e 18 03			jr .pastdmark  
a560 ..			.dmark: db "ROT"  
a563 f1			.pastdmark: pop af  
a564			endm  
# End of macro DMARK
a564					CALLMONITOR 
a564 cd 6f ee			call debug_vector  
a567				endm  
# End of macro CALLMONITOR
a567				endif 
a567			 
a567			; TODO Use os stack swap memory 
a567				FORTH_DSP_VALUEHL 
a567 cd 53 9c			call macro_dsp_valuehl 
a56a				endm 
# End of macro FORTH_DSP_VALUEHL
a56a e5				push hl    ; u3  
a56b			 
a56b				FORTH_DSP_POP 
a56b cd 0b 9d			call macro_forth_dsp_pop 
a56e				endm 
# End of macro FORTH_DSP_POP
a56e			 
a56e				FORTH_DSP_VALUEHL 
a56e cd 53 9c			call macro_dsp_valuehl 
a571				endm 
# End of macro FORTH_DSP_VALUEHL
a571 e5				push hl     ; u2 
a572			 
a572				FORTH_DSP_POP 
a572 cd 0b 9d			call macro_forth_dsp_pop 
a575				endm 
# End of macro FORTH_DSP_POP
a575			 
a575				FORTH_DSP_VALUEHL 
a575 cd 53 9c			call macro_dsp_valuehl 
a578				endm 
# End of macro FORTH_DSP_VALUEHL
a578 e5				push hl     ; u1 
a579			 
a579				FORTH_DSP_POP 
a579 cd 0b 9d			call macro_forth_dsp_pop 
a57c				endm 
# End of macro FORTH_DSP_POP
a57c			 
a57c c1				pop bc      ; u1 
a57d e1				pop hl      ; u2 
a57e d1				pop de      ; u3 
a57f			 
a57f			 
a57f c5				push bc 
a580 d5				push de 
a581 e5				push hl 
a582			 
a582			 
a582 e1				pop hl 
a583 cd 5c 9a			call forth_push_numhl 
a586			 
a586 e1				pop hl 
a587 cd 5c 9a			call forth_push_numhl 
a58a			 
a58a e1				pop hl 
a58b cd 5c 9a			call forth_push_numhl 
a58e				 
a58e			 
a58e			 
a58e			 
a58e			 
a58e			 
a58e			       NEXTW 
a58e c3 09 9e			jp macro_next 
a591				endm 
# End of macro NEXTW
a591			 
a591			.UWORDS: 
a591			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a591 50				db WORD_SYS_CORE+60             
a592 53 a6			dw .BP            
a594 07				db 6 + 1 
a595 .. 00			db "UWORDS",0              
a59c				endm 
# End of macro CWHEAD
a59c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a59c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a59c			; | | Following the count are the individual words. 
a59c			; | | 
a59c			; | | e.g. UWORDS 
a59c			; | | BOX DIRLIST 2 
a59c			; | |  
a59c			; | | Can be used to save the words to storage via: 
a59c			; | | UWORDS $01 DO $01 APPEND LOOP 
a59c			if DEBUG_FORTH_WORDS_KEY 
a59c				DMARK "UWR" 
a59c f5				push af  
a59d 3a b1 a5			ld a, (.dmark)  
a5a0 32 6b ee			ld (debug_mark),a  
a5a3 3a b2 a5			ld a, (.dmark+1)  
a5a6 32 6c ee			ld (debug_mark+1),a  
a5a9 3a b3 a5			ld a, (.dmark+2)  
a5ac 32 6d ee			ld (debug_mark+2),a  
a5af 18 03			jr .pastdmark  
a5b1 ..			.dmark: db "UWR"  
a5b4 f1			.pastdmark: pop af  
a5b5			endm  
# End of macro DMARK
a5b5				CALLMONITOR 
a5b5 cd 6f ee			call debug_vector  
a5b8				endm  
# End of macro CALLMONITOR
a5b8			endif 
a5b8 21 f9 e3			ld hl, baseram 
a5bb				;ld hl, baseusermem 
a5bb 01 00 00			ld bc, 0    ; start a counter 
a5be			 
a5be			; skip dict stub 
a5be			 
a5be cd 5a 9f			call forth_tok_next 
a5c1			 
a5c1			 
a5c1			; while we have words to look for 
a5c1			 
a5c1 7e			.douscan:	ld a, (hl)      
a5c2			if DEBUG_FORTH_WORDS 
a5c2				DMARK "UWs" 
a5c2 f5				push af  
a5c3 3a d7 a5			ld a, (.dmark)  
a5c6 32 6b ee			ld (debug_mark),a  
a5c9 3a d8 a5			ld a, (.dmark+1)  
a5cc 32 6c ee			ld (debug_mark+1),a  
a5cf 3a d9 a5			ld a, (.dmark+2)  
a5d2 32 6d ee			ld (debug_mark+2),a  
a5d5 18 03			jr .pastdmark  
a5d7 ..			.dmark: db "UWs"  
a5da f1			.pastdmark: pop af  
a5db			endm  
# End of macro DMARK
a5db				CALLMONITOR 
a5db cd 6f ee			call debug_vector  
a5de				endm  
# End of macro CALLMONITOR
a5de			endif 
a5de fe 00			cp WORD_SYS_END 
a5e0 28 4d			jr z, .udone 
a5e2 fe 01			cp WORD_SYS_UWORD 
a5e4 20 44			jr nz, .nuword 
a5e6			 
a5e6			if DEBUG_FORTH_WORDS 
a5e6				DMARK "UWu" 
a5e6 f5				push af  
a5e7 3a fb a5			ld a, (.dmark)  
a5ea 32 6b ee			ld (debug_mark),a  
a5ed 3a fc a5			ld a, (.dmark+1)  
a5f0 32 6c ee			ld (debug_mark+1),a  
a5f3 3a fd a5			ld a, (.dmark+2)  
a5f6 32 6d ee			ld (debug_mark+2),a  
a5f9 18 03			jr .pastdmark  
a5fb ..			.dmark: db "UWu"  
a5fe f1			.pastdmark: pop af  
a5ff			endm  
# End of macro DMARK
a5ff				CALLMONITOR 
a5ff cd 6f ee			call debug_vector  
a602				endm  
# End of macro CALLMONITOR
a602			endif 
a602				; we have a uword so push its name to the stack 
a602			 
a602 e5				push hl  ; save so we can move to next dict block 
a603			 
a603				; skip opcode 
a603 23				inc hl  
a604				; skip next ptr 
a604 23				inc hl  
a605 23				inc hl 
a606				; skip len 
a606 23				inc hl 
a607			if DEBUG_FORTH_WORDS 
a607				DMARK "UWt" 
a607 f5				push af  
a608 3a 1c a6			ld a, (.dmark)  
a60b 32 6b ee			ld (debug_mark),a  
a60e 3a 1d a6			ld a, (.dmark+1)  
a611 32 6c ee			ld (debug_mark+1),a  
a614 3a 1e a6			ld a, (.dmark+2)  
a617 32 6d ee			ld (debug_mark+2),a  
a61a 18 03			jr .pastdmark  
a61c ..			.dmark: db "UWt"  
a61f f1			.pastdmark: pop af  
a620			endm  
# End of macro DMARK
a620				CALLMONITOR 
a620 cd 6f ee			call debug_vector  
a623				endm  
# End of macro CALLMONITOR
a623			endif 
a623 03				inc bc 
a624			 
a624 c5				push bc 
a625 cd ca 9a			call forth_push_str 
a628 c1				pop bc 
a629			 
a629 e1				pop hl 	 
a62a			 
a62a cd 5a 9f		.nuword:	call forth_tok_next 
a62d 18 92			jr .douscan  
a62f			 
a62f			.udone:		 ; push count of uwords found 
a62f c5				push bc 
a630 e1				pop hl 
a631			 
a631			if DEBUG_FORTH_WORDS 
a631				DMARK "UWc" 
a631 f5				push af  
a632 3a 46 a6			ld a, (.dmark)  
a635 32 6b ee			ld (debug_mark),a  
a638 3a 47 a6			ld a, (.dmark+1)  
a63b 32 6c ee			ld (debug_mark+1),a  
a63e 3a 48 a6			ld a, (.dmark+2)  
a641 32 6d ee			ld (debug_mark+2),a  
a644 18 03			jr .pastdmark  
a646 ..			.dmark: db "UWc"  
a649 f1			.pastdmark: pop af  
a64a			endm  
# End of macro DMARK
a64a				CALLMONITOR 
a64a cd 6f ee			call debug_vector  
a64d				endm  
# End of macro CALLMONITOR
a64d			endif 
a64d cd 5c 9a			call forth_push_numhl 
a650			 
a650			 
a650			       NEXTW 
a650 c3 09 9e			jp macro_next 
a653				endm 
# End of macro NEXTW
a653			 
a653			.BP: 
a653			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a653 54				db WORD_SYS_CORE+64             
a654 8d a6			dw .MONITOR            
a656 03				db 2 + 1 
a657 .. 00			db "BP",0              
a65a				endm 
# End of macro CWHEAD
a65a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a65a			; | | $00 Will enable the break points within specific code paths 
a65a			; | | $01 Will disable break points 
a65a			; | |  
a65a			; | | By default break points are off. Either the above can be used to enable them 
a65a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a65a			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a65a			; | | can disable break points. Exiting will then continue boot process. 
a65a				; get byte count 
a65a				if DEBUG_FORTH_WORDS_KEY 
a65a					DMARK "BP." 
a65a f5				push af  
a65b 3a 6f a6			ld a, (.dmark)  
a65e 32 6b ee			ld (debug_mark),a  
a661 3a 70 a6			ld a, (.dmark+1)  
a664 32 6c ee			ld (debug_mark+1),a  
a667 3a 71 a6			ld a, (.dmark+2)  
a66a 32 6d ee			ld (debug_mark+2),a  
a66d 18 03			jr .pastdmark  
a66f ..			.dmark: db "BP."  
a672 f1			.pastdmark: pop af  
a673			endm  
# End of macro DMARK
a673					CALLMONITOR 
a673 cd 6f ee			call debug_vector  
a676				endm  
# End of macro CALLMONITOR
a676				endif 
a676			 
a676				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a676 cd 53 9c			call macro_dsp_valuehl 
a679				endm 
# End of macro FORTH_DSP_VALUEHL
a679			 
a679			;		push hl 
a679			 
a679				; destroy value TOS 
a679			 
a679				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a679 cd 0b 9d			call macro_forth_dsp_pop 
a67c				endm 
# End of macro FORTH_DSP_POP
a67c			 
a67c			;		pop hl 
a67c			 
a67c 3e 00			ld a,0 
a67e bd				cp l 
a67f 28 06			jr z, .bpset 
a681			;		ld a, '*' 
a681 cd fe 93			call bp_off 
a684				NEXTW 
a684 c3 09 9e			jp macro_next 
a687				endm 
# End of macro NEXTW
a687			 
a687			.bpset:	 
a687				;	ld (os_view_disable), a 
a687 cd f2 93			call bp_on 
a68a			 
a68a			 
a68a				NEXTW 
a68a c3 09 9e			jp macro_next 
a68d				endm 
# End of macro NEXTW
a68d			 
a68d			 
a68d			.MONITOR: 
a68d			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a68d 55				db WORD_SYS_CORE+65             
a68e be a6			dw .MALLOC            
a690 08				db 7 + 1 
a691 .. 00			db "MONITOR",0              
a699				endm 
# End of macro CWHEAD
a699			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a699			; | | At start the current various registers will be displayed with contents. 
a699			; | | Top right corner will show the most recent debug marker seen. 
a699			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a699			; | | and the return stack pointer (RSP). 
a699			; | | Pressing: 
a699			; | |    1 - Initial screen 
a699			; | |    2 - Display a data dump of HL 
a699			; | |    3 - Display a data dump of DE 
a699			; | |    4 - Display a data dump of BC 
a699			; | |    5 - Display a data dump of HL 
a699			; | |    6 - Display a data dump of DSP 
a699			; | |    7 - Display a data dump of RSP 
a699			; | |    8 - Display a data dump of what is at DSP 
a699			; | |    9 - Display a data dump of what is at RSP 
a699			; | |    0 - Exit monitor and continue running. This will also enable break points 
a699			; | |    * - Disable break points 
a699			; | |    # - Enter traditional monitor mode 
a699			; | | 
a699			; | | Monitor Mode 
a699			; | | ------------ 
a699			; | | A prompt of '>' will be shown for various commands: 
a699			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a699			; | |    C - Continue display a data dump from the last set address 
a699			; | |    M xxxx - Set start of memory edit at address xx 
a699			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a699			; | |    G xxxx - Exec code at specific address 
a699			; | |    Q - Return to previous 
a699				if DEBUG_FORTH_WORDS_KEY 
a699					DMARK "MON" 
a699 f5				push af  
a69a 3a ae a6			ld a, (.dmark)  
a69d 32 6b ee			ld (debug_mark),a  
a6a0 3a af a6			ld a, (.dmark+1)  
a6a3 32 6c ee			ld (debug_mark+1),a  
a6a6 3a b0 a6			ld a, (.dmark+2)  
a6a9 32 6d ee			ld (debug_mark+2),a  
a6ac 18 03			jr .pastdmark  
a6ae ..			.dmark: db "MON"  
a6b1 f1			.pastdmark: pop af  
a6b2			endm  
# End of macro DMARK
a6b2					CALLMONITOR 
a6b2 cd 6f ee			call debug_vector  
a6b5				endm  
# End of macro CALLMONITOR
a6b5				endif 
a6b5			;		ld a, 0 
a6b5			;		ld (os_view_disable), a 
a6b5 cd f2 93			call bp_on 
a6b8			 
a6b8				CALLMONITOR 
a6b8 cd 6f ee			call debug_vector  
a6bb				endm  
# End of macro CALLMONITOR
a6bb			 
a6bb			;	call monitor 
a6bb			 
a6bb				NEXTW 
a6bb c3 09 9e			jp macro_next 
a6be				endm 
# End of macro NEXTW
a6be			 
a6be			 
a6be			.MALLOC: 
a6be			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a6be 56				db WORD_SYS_CORE+66             
a6bf e7 a6			dw .MALLOC2            
a6c1 06				db 5 + 1 
a6c2 .. 00			db "ALLOT",0              
a6c8				endm 
# End of macro CWHEAD
a6c8			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a6c8				if DEBUG_FORTH_WORDS_KEY 
a6c8					DMARK "ALL" 
a6c8 f5				push af  
a6c9 3a dd a6			ld a, (.dmark)  
a6cc 32 6b ee			ld (debug_mark),a  
a6cf 3a de a6			ld a, (.dmark+1)  
a6d2 32 6c ee			ld (debug_mark+1),a  
a6d5 3a df a6			ld a, (.dmark+2)  
a6d8 32 6d ee			ld (debug_mark+2),a  
a6db 18 03			jr .pastdmark  
a6dd ..			.dmark: db "ALL"  
a6e0 f1			.pastdmark: pop af  
a6e1			endm  
# End of macro DMARK
a6e1					CALLMONITOR 
a6e1 cd 6f ee			call debug_vector  
a6e4				endm  
# End of macro CALLMONITOR
a6e4				endif 
a6e4 c3 0e a7			jp .mallocc 
a6e7			.MALLOC2: 
a6e7			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a6e7 56				db WORD_SYS_CORE+66             
a6e8 25 a7			dw .FREE            
a6ea 07				db 6 + 1 
a6eb .. 00			db "MALLOC",0              
a6f2				endm 
# End of macro CWHEAD
a6f2			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a6f2				; get byte count 
a6f2				if DEBUG_FORTH_WORDS_KEY 
a6f2					DMARK "MAL" 
a6f2 f5				push af  
a6f3 3a 07 a7			ld a, (.dmark)  
a6f6 32 6b ee			ld (debug_mark),a  
a6f9 3a 08 a7			ld a, (.dmark+1)  
a6fc 32 6c ee			ld (debug_mark+1),a  
a6ff 3a 09 a7			ld a, (.dmark+2)  
a702 32 6d ee			ld (debug_mark+2),a  
a705 18 03			jr .pastdmark  
a707 ..			.dmark: db "MAL"  
a70a f1			.pastdmark: pop af  
a70b			endm  
# End of macro DMARK
a70b					CALLMONITOR 
a70b cd 6f ee			call debug_vector  
a70e				endm  
# End of macro CALLMONITOR
a70e				endif 
a70e			.mallocc: 
a70e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a70e cd 53 9c			call macro_dsp_valuehl 
a711				endm 
# End of macro FORTH_DSP_VALUEHL
a711			 
a711			;		push hl 
a711			 
a711				; destroy value TOS 
a711			 
a711				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a711 cd 0b 9d			call macro_forth_dsp_pop 
a714				endm 
# End of macro FORTH_DSP_POP
a714			 
a714			;		pop hl 
a714 cd c3 90			call malloc 
a717			if DEBUG_FORTH_MALLOC_GUARD 
a717 f5				push af 
a718 cd 04 8d			call ishlzero 
a71b			;		ld a, l 
a71b			;		add h 
a71b			;		cp 0 
a71b f1				pop af 
a71c				 
a71c cc c9 cb			call z,malloc_error 
a71f			endif 
a71f			 
a71f cd 5c 9a			call forth_push_numhl 
a722				NEXTW 
a722 c3 09 9e			jp macro_next 
a725				endm 
# End of macro NEXTW
a725			 
a725			.FREE: 
a725			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a725 57				db WORD_SYS_CORE+67             
a726 56 a7			dw .LIST            
a728 05				db 4 + 1 
a729 .. 00			db "FREE",0              
a72e				endm 
# End of macro CWHEAD
a72e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a72e				if DEBUG_FORTH_WORDS_KEY 
a72e					DMARK "FRE" 
a72e f5				push af  
a72f 3a 43 a7			ld a, (.dmark)  
a732 32 6b ee			ld (debug_mark),a  
a735 3a 44 a7			ld a, (.dmark+1)  
a738 32 6c ee			ld (debug_mark+1),a  
a73b 3a 45 a7			ld a, (.dmark+2)  
a73e 32 6d ee			ld (debug_mark+2),a  
a741 18 03			jr .pastdmark  
a743 ..			.dmark: db "FRE"  
a746 f1			.pastdmark: pop af  
a747			endm  
# End of macro DMARK
a747					CALLMONITOR 
a747 cd 6f ee			call debug_vector  
a74a				endm  
# End of macro CALLMONITOR
a74a				endif 
a74a				; get address 
a74a			 
a74a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a74a cd 53 9c			call macro_dsp_valuehl 
a74d				endm 
# End of macro FORTH_DSP_VALUEHL
a74d			 
a74d			;		push hl 
a74d			 
a74d				; destroy value TOS 
a74d			 
a74d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a74d cd 0b 9d			call macro_forth_dsp_pop 
a750				endm 
# End of macro FORTH_DSP_POP
a750			 
a750			;		pop hl 
a750			if FORTH_ENABLE_MALLOCFREE 
a750 cd 8d 91			call free 
a753			endif 
a753				NEXTW 
a753 c3 09 9e			jp macro_next 
a756				endm 
# End of macro NEXTW
a756			.LIST: 
a756			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a756 5c				db WORD_SYS_CORE+72             
a757 46 a9			dw .FORGET            
a759 05				db 4 + 1 
a75a .. 00			db "LIST",0              
a75f				endm 
# End of macro CWHEAD
a75f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a75f			; | | The quoted word must be in upper case. 
a75f			if DEBUG_FORTH_WORDS_KEY 
a75f				DMARK "LST" 
a75f f5				push af  
a760 3a 74 a7			ld a, (.dmark)  
a763 32 6b ee			ld (debug_mark),a  
a766 3a 75 a7			ld a, (.dmark+1)  
a769 32 6c ee			ld (debug_mark+1),a  
a76c 3a 76 a7			ld a, (.dmark+2)  
a76f 32 6d ee			ld (debug_mark+2),a  
a772 18 03			jr .pastdmark  
a774 ..			.dmark: db "LST"  
a777 f1			.pastdmark: pop af  
a778			endm  
# End of macro DMARK
a778				CALLMONITOR 
a778 cd 6f ee			call debug_vector  
a77b				endm  
# End of macro CALLMONITOR
a77b			endif 
a77b			 
a77b				FORTH_DSP_VALUEHL 
a77b cd 53 9c			call macro_dsp_valuehl 
a77e				endm 
# End of macro FORTH_DSP_VALUEHL
a77e			 
a77e e5				push hl 
a77f				FORTH_DSP_POP 
a77f cd 0b 9d			call macro_forth_dsp_pop 
a782				endm 
# End of macro FORTH_DSP_POP
a782 c1				pop bc 
a783			 
a783			; Start format of scratch string 
a783			 
a783 21 c1 e2			ld hl, scratch 
a786			 
a786 3e 3a			ld a, ':' 
a788 77				ld (hl),a 
a789 23				inc hl 
a78a 3e 20			ld a, ' ' 
a78c 77				ld (hl), a 
a78d			 
a78d				; Get ptr to the word we need to look up 
a78d			 
a78d			;		FORTH_DSP_VALUEHL 
a78d				;v5 FORTH_DSP_VALUE 
a78d			; TODO type check 
a78d			;		inc hl    ; Skip type check  
a78d			;		push hl 
a78d			;		ex de, hl    ; put into DE 
a78d			 
a78d			 
a78d 21 f9 e3			ld hl, baseram 
a790				;ld hl, baseusermem 
a790			 
a790 e5			push hl   ; sacreifical push 
a791			 
a791			.ldouscanm: 
a791 e1			pop hl 
a792			.ldouscan: 
a792			if DEBUG_FORTH_WORDS 
a792				DMARK "LSs" 
a792 f5				push af  
a793 3a a7 a7			ld a, (.dmark)  
a796 32 6b ee			ld (debug_mark),a  
a799 3a a8 a7			ld a, (.dmark+1)  
a79c 32 6c ee			ld (debug_mark+1),a  
a79f 3a a9 a7			ld a, (.dmark+2)  
a7a2 32 6d ee			ld (debug_mark+2),a  
a7a5 18 03			jr .pastdmark  
a7a7 ..			.dmark: db "LSs"  
a7aa f1			.pastdmark: pop af  
a7ab			endm  
# End of macro DMARK
a7ab				CALLMONITOR 
a7ab cd 6f ee			call debug_vector  
a7ae				endm  
# End of macro CALLMONITOR
a7ae			endif 
a7ae			; skip dict stub 
a7ae cd 5a 9f			call forth_tok_next 
a7b1			 
a7b1			 
a7b1			; while we have words to look for 
a7b1			 
a7b1 7e			ld a, (hl)      
a7b2			if DEBUG_FORTH_WORDS 
a7b2				DMARK "LSk" 
a7b2 f5				push af  
a7b3 3a c7 a7			ld a, (.dmark)  
a7b6 32 6b ee			ld (debug_mark),a  
a7b9 3a c8 a7			ld a, (.dmark+1)  
a7bc 32 6c ee			ld (debug_mark+1),a  
a7bf 3a c9 a7			ld a, (.dmark+2)  
a7c2 32 6d ee			ld (debug_mark+2),a  
a7c5 18 03			jr .pastdmark  
a7c7 ..			.dmark: db "LSk"  
a7ca f1			.pastdmark: pop af  
a7cb			endm  
# End of macro DMARK
a7cb				CALLMONITOR 
a7cb cd 6f ee			call debug_vector  
a7ce				endm  
# End of macro CALLMONITOR
a7ce			endif 
a7ce				;cp WORD_SYS_END 
a7ce				;jp z, .lunotfound 
a7ce			 
a7ce					; if we hit non uwords then gone too far 
a7ce fe 01				cp WORD_SYS_UWORD 
a7d0 c2 02 a9				jp nz, .lunotfound 
a7d3			 
a7d3				if DEBUG_FORTH_WORDS 
a7d3					DMARK "LSu" 
a7d3 f5				push af  
a7d4 3a e8 a7			ld a, (.dmark)  
a7d7 32 6b ee			ld (debug_mark),a  
a7da 3a e9 a7			ld a, (.dmark+1)  
a7dd 32 6c ee			ld (debug_mark+1),a  
a7e0 3a ea a7			ld a, (.dmark+2)  
a7e3 32 6d ee			ld (debug_mark+2),a  
a7e6 18 03			jr .pastdmark  
a7e8 ..			.dmark: db "LSu"  
a7eb f1			.pastdmark: pop af  
a7ec			endm  
# End of macro DMARK
a7ec					CALLMONITOR 
a7ec cd 6f ee			call debug_vector  
a7ef				endm  
# End of macro CALLMONITOR
a7ef				endif 
a7ef			 
a7ef					; found a uword but is it the one we want... 
a7ef			 
a7ef c5					push bc     ; uword to find is on bc 
a7f0 d1					pop de 
a7f1			 
a7f1 e5					push hl  ; to save the ptr 
a7f2			 
a7f2					; skip opcode 
a7f2 23					inc hl  
a7f3					; skip next ptr 
a7f3 23					inc hl  
a7f4 23					inc hl 
a7f5					; skip len 
a7f5 23					inc hl 
a7f6			 
a7f6				if DEBUG_FORTH_WORDS 
a7f6					DMARK "LSc" 
a7f6 f5				push af  
a7f7 3a 0b a8			ld a, (.dmark)  
a7fa 32 6b ee			ld (debug_mark),a  
a7fd 3a 0c a8			ld a, (.dmark+1)  
a800 32 6c ee			ld (debug_mark+1),a  
a803 3a 0d a8			ld a, (.dmark+2)  
a806 32 6d ee			ld (debug_mark+2),a  
a809 18 03			jr .pastdmark  
a80b ..			.dmark: db "LSc"  
a80e f1			.pastdmark: pop af  
a80f			endm  
# End of macro DMARK
a80f					CALLMONITOR 
a80f cd 6f ee			call debug_vector  
a812				endm  
# End of macro CALLMONITOR
a812				endif 
a812			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a812			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a812			; Nope that has gone the other way. It needs to be exact not on first zero 
a812			;		call strcmp 
a812 c5					push bc 
a813 cd 93 90				call StrictStrCmp 
a816 c1					pop bc 
a817 c2 91 a7				jp nz, .ldouscanm 
a81a				 
a81a			 
a81a			 
a81a					; we have a uword so push its name to the stack 
a81a			 
a81a			;	   	push hl  ; save so we can move to next dict block 
a81a e1			pop hl 
a81b			 
a81b				if DEBUG_FORTH_WORDS 
a81b					DMARK "LSm" 
a81b f5				push af  
a81c 3a 30 a8			ld a, (.dmark)  
a81f 32 6b ee			ld (debug_mark),a  
a822 3a 31 a8			ld a, (.dmark+1)  
a825 32 6c ee			ld (debug_mark+1),a  
a828 3a 32 a8			ld a, (.dmark+2)  
a82b 32 6d ee			ld (debug_mark+2),a  
a82e 18 03			jr .pastdmark  
a830 ..			.dmark: db "LSm"  
a833 f1			.pastdmark: pop af  
a834			endm  
# End of macro DMARK
a834					CALLMONITOR 
a834 cd 6f ee			call debug_vector  
a837				endm  
# End of macro CALLMONITOR
a837				endif 
a837			 
a837					; skip opcode 
a837 23					inc hl  
a838					; skip next ptr 
a838 23					inc hl  
a839 23					inc hl 
a83a					; skip len 
a83a 7e					ld a, (hl)   ; save length to add 
a83b				if DEBUG_FORTH_WORDS 
a83b					DMARK "LS2" 
a83b f5				push af  
a83c 3a 50 a8			ld a, (.dmark)  
a83f 32 6b ee			ld (debug_mark),a  
a842 3a 51 a8			ld a, (.dmark+1)  
a845 32 6c ee			ld (debug_mark+1),a  
a848 3a 52 a8			ld a, (.dmark+2)  
a84b 32 6d ee			ld (debug_mark+2),a  
a84e 18 03			jr .pastdmark  
a850 ..			.dmark: db "LS2"  
a853 f1			.pastdmark: pop af  
a854			endm  
# End of macro DMARK
a854					CALLMONITOR 
a854 cd 6f ee			call debug_vector  
a857				endm  
# End of macro CALLMONITOR
a857				endif 
a857			 
a857					; save this location 
a857				 
a857 e5					push hl 
a858			 
a858 23					inc hl 
a859 11 c3 e2				ld de, scratch+2 
a85c 4f					ld c, a 
a85d 06 00				ld b, 0 
a85f			 
a85f				if DEBUG_FORTH_WORDS 
a85f					DMARK "LSn" 
a85f f5				push af  
a860 3a 74 a8			ld a, (.dmark)  
a863 32 6b ee			ld (debug_mark),a  
a866 3a 75 a8			ld a, (.dmark+1)  
a869 32 6c ee			ld (debug_mark+1),a  
a86c 3a 76 a8			ld a, (.dmark+2)  
a86f 32 6d ee			ld (debug_mark+2),a  
a872 18 03			jr .pastdmark  
a874 ..			.dmark: db "LSn"  
a877 f1			.pastdmark: pop af  
a878			endm  
# End of macro DMARK
a878					CALLMONITOR 
a878 cd 6f ee			call debug_vector  
a87b				endm  
# End of macro CALLMONITOR
a87b				endif 
a87b			 
a87b					; copy uword name to scratch 
a87b			 
a87b ed b0				ldir 
a87d			 
a87d 1b					dec de 
a87e 3e 20				ld a, ' '    ; change null to space 
a880 12					ld (de), a 
a881			 
a881 13					inc de 
a882			 
a882 d5					push de 
a883 c1					pop bc     ; move scratch pointer to end of word name and save it 
a884			 
a884 e1					pop hl 
a885 7e					ld a, (hl) 
a886					;inc hl 
a886					; skip word string 
a886 cd db 8c				call addatohl 
a889			 
a889 23					inc hl 
a88a			 
a88a				if DEBUG_FORTH_WORDS 
a88a					DMARK "LS3" 
a88a f5				push af  
a88b 3a 9f a8			ld a, (.dmark)  
a88e 32 6b ee			ld (debug_mark),a  
a891 3a a0 a8			ld a, (.dmark+1)  
a894 32 6c ee			ld (debug_mark+1),a  
a897 3a a1 a8			ld a, (.dmark+2)  
a89a 32 6d ee			ld (debug_mark+2),a  
a89d 18 03			jr .pastdmark  
a89f ..			.dmark: db "LS3"  
a8a2 f1			.pastdmark: pop af  
a8a3			endm  
# End of macro DMARK
a8a3					CALLMONITOR 
a8a3 cd 6f ee			call debug_vector  
a8a6				endm  
# End of macro CALLMONITOR
a8a6				endif 
a8a6					; should now be at the start of the machine code to setup the eval of the uword 
a8a6					; now locate the ptr to the string defintion 
a8a6			 
a8a6					; skip ld hl, 
a8a6					; then load the ptr 
a8a6			; TODO use get from hl ptr 
a8a6 23					inc hl 
a8a7 5e					ld e, (hl) 
a8a8 23					inc hl 
a8a9 56					ld d, (hl) 
a8aa eb					ex de, hl 
a8ab			 
a8ab			 
a8ab				if DEBUG_FORTH_WORDS 
a8ab					DMARK "LSt" 
a8ab f5				push af  
a8ac 3a c0 a8			ld a, (.dmark)  
a8af 32 6b ee			ld (debug_mark),a  
a8b2 3a c1 a8			ld a, (.dmark+1)  
a8b5 32 6c ee			ld (debug_mark+1),a  
a8b8 3a c2 a8			ld a, (.dmark+2)  
a8bb 32 6d ee			ld (debug_mark+2),a  
a8be 18 03			jr .pastdmark  
a8c0 ..			.dmark: db "LSt"  
a8c3 f1			.pastdmark: pop af  
a8c4			endm  
# End of macro DMARK
a8c4					CALLMONITOR 
a8c4 cd 6f ee			call debug_vector  
a8c7				endm  
# End of macro CALLMONITOR
a8c7				endif 
a8c7			 
a8c7			; cant push right now due to tokenised strings  
a8c7			 
a8c7			; get the destination of where to copy this definition to. 
a8c7			 
a8c7 c5					push bc 
a8c8 d1					pop de 
a8c9			 
a8c9 7e			.listl:         ld a,(hl) 
a8ca fe 00				cp 0 
a8cc 28 09				jr z, .lreplsp     ; replace zero with space 
a8ce					;cp FORTH_END_BUFFER 
a8ce fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a8d0 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a8d2				 
a8d2					; just copy this char as is then 
a8d2			 
a8d2 12					ld (de), a 
a8d3			 
a8d3 23			.listnxt:	inc hl 
a8d4 13					inc de 
a8d5 18 f2				jr .listl 
a8d7			 
a8d7 3e 20		.lreplsp:	ld a,' ' 
a8d9 12					ld (de), a 
a8da 18 f7				jr .listnxt 
a8dc			 
a8dc			; close up uword def 
a8dc			 
a8dc			.listdone: 
a8dc 12					ld (de), a 
a8dd 13					inc de 
a8de 3e 00				ld a, 0 
a8e0 12					ld (de), a 
a8e1			 
a8e1			; now have def so clean up and push to stack 
a8e1			 
a8e1 21 c1 e2				ld hl, scratch 
a8e4				if DEBUG_FORTH_WORDS 
a8e4					DMARK "Ltp" 
a8e4 f5				push af  
a8e5 3a f9 a8			ld a, (.dmark)  
a8e8 32 6b ee			ld (debug_mark),a  
a8eb 3a fa a8			ld a, (.dmark+1)  
a8ee 32 6c ee			ld (debug_mark+1),a  
a8f1 3a fb a8			ld a, (.dmark+2)  
a8f4 32 6d ee			ld (debug_mark+2),a  
a8f7 18 03			jr .pastdmark  
a8f9 ..			.dmark: db "Ltp"  
a8fc f1			.pastdmark: pop af  
a8fd			endm  
# End of macro DMARK
a8fd					CALLMONITOR 
a8fd cd 6f ee			call debug_vector  
a900				endm  
# End of macro CALLMONITOR
a900				endif 
a900			 
a900 18 1f			jr .listpush 
a902			 
a902			;.lnuword:	pop hl 
a902			;		call forth_tok_next 
a902			;		jp .ldouscan  
a902			 
a902			.lunotfound:		  
a902			 
a902				if DEBUG_FORTH_WORDS 
a902					DMARK "LSn" 
a902 f5				push af  
a903 3a 17 a9			ld a, (.dmark)  
a906 32 6b ee			ld (debug_mark),a  
a909 3a 18 a9			ld a, (.dmark+1)  
a90c 32 6c ee			ld (debug_mark+1),a  
a90f 3a 19 a9			ld a, (.dmark+2)  
a912 32 6d ee			ld (debug_mark+2),a  
a915 18 03			jr .pastdmark  
a917 ..			.dmark: db "LSn"  
a91a f1			.pastdmark: pop af  
a91b			endm  
# End of macro DMARK
a91b					CALLMONITOR 
a91b cd 6f ee			call debug_vector  
a91e				endm  
# End of macro CALLMONITOR
a91e				endif 
a91e			 
a91e					 
a91e			;		FORTH_DSP_POP 
a91e			;		ld hl, .luno 
a91e			 
a91e					NEXTW			 
a91e c3 09 9e			jp macro_next 
a921				endm 
# End of macro NEXTW
a921			 
a921			.listpush: 
a921				if DEBUG_FORTH_WORDS 
a921					DMARK "LS>" 
a921 f5				push af  
a922 3a 36 a9			ld a, (.dmark)  
a925 32 6b ee			ld (debug_mark),a  
a928 3a 37 a9			ld a, (.dmark+1)  
a92b 32 6c ee			ld (debug_mark+1),a  
a92e 3a 38 a9			ld a, (.dmark+2)  
a931 32 6d ee			ld (debug_mark+2),a  
a934 18 03			jr .pastdmark  
a936 ..			.dmark: db "LS>"  
a939 f1			.pastdmark: pop af  
a93a			endm  
# End of macro DMARK
a93a					CALLMONITOR 
a93a cd 6f ee			call debug_vector  
a93d				endm  
# End of macro CALLMONITOR
a93d				endif 
a93d cd ca 9a				call forth_push_str 
a940			 
a940			 
a940			 
a940					NEXTW 
a940 c3 09 9e			jp macro_next 
a943				endm 
# End of macro NEXTW
a943			 
a943			;.luno:    db "Word not found",0 
a943			 
a943			 
a943			 
a943			 
a943			 
a943			;		push hl   ; save pointer to start of uword def string 
a943			; 
a943			;; look for FORTH_EOL_LINE 
a943			;		ld a, FORTH_END_BUFFER 
a943			;		call strlent 
a943			; 
a943			;		inc hl		 ; space for coln def 
a943			;		inc hl 
a943			;		inc hl          ; space for terms 
a943			;		inc hl 
a943			; 
a943			;		ld a, 20   ; TODO get actual length 
a943			;		call addatohl    ; include a random amount of room for the uword name 
a943			; 
a943			;		 
a943			;	if DEBUG_FORTH_WORDS 
a943			;		DMARK "Lt1" 
a943			;		CALLMONITOR 
a943			;	endif 
a943			;		 
a943			; 
a943			;; malloc space for the string because we cant change it 
a943			; 
a943			;		call malloc 
a943			;	if DEBUG_FORTH_MALLOC_GUARD 
a943			;		push af 
a943			;		call ishlzero 
a943			;		pop af 
a943			;		 
a943			;		call z,malloc_error 
a943			;	endif 
a943			; 
a943			;	if DEBUG_FORTH_WORDS 
a943			;		DMARK "Lt2" 
a943			;		CALLMONITOR 
a943			;	endif 
a943			;		pop de 
a943			;		push hl    ; push the malloc to release later 
a943			;		push hl   ;  push back a copy for the later stack push 
a943			;		 
a943			;; copy the string swapping out the zero terms for spaces 
a943			; 
a943			;		; de has our source 
a943			;		; hl has our dest 
a943			; 
a943			;; add the coln def 
a943			; 
a943			;		ld a, ':' 
a943			;		ld (hl), a 
a943			;		inc hl 
a943			;		ld a, ' ' 
a943			;		ld (hl), a 
a943			;		inc hl 
a943			; 
a943			;; add the uname word 
a943			;		push de   ; save our string for now 
a943			;		ex de, hl 
a943			; 
a943			;		FORTH_DSP_VALUE 
a943			;		;v5 FORTH_DSP_VALUE 
a943			; 
a943			;		inc hl   ; skip type but we know by now this is OK 
a943			; 
a943			;.luword:	ld a,(hl) 
a943			;		cp 0 
a943			;		jr z, .luword2 
a943			;		ld (de), a 
a943			;		inc de 
a943			;		inc hl 
a943			;		jr .luword 
a943			; 
a943			;.luword2:	ld a, ' ' 
a943			;		ld (de), a 
a943			;;		inc hl 
a943			;;		inc de 
a943			;;		ld (de), a 
a943			;;		inc hl 
a943			;		inc de 
a943			; 
a943			;		ex de, hl 
a943			;		pop de 
a943			;		 
a943			;		 
a943			; 
a943			;; detoken that string and copy it 
a943			; 
a943			;	if DEBUG_FORTH_WORDS 
a943			;		DMARK "Lt2" 
a943			;		CALLMONITOR 
a943			;	endif 
a943			;.ldetok:	ld a, (de) 
a943			;		cp FORTH_END_BUFFER 
a943			;		jr z, .ldetokend 
a943			;		; swap out any zero term for space 
a943			;		cp 0 
a943			;		jr nz, .ldetoknext 
a943			;		ld a, ' ' 
a943			; 
a943			;	if DEBUG_FORTH_WORDS 
a943			;		DMARK "LtS" 
a943			;		CALLMONITOR 
a943			;	endif 
a943			;.ldetoknext:	ld (hl), a 
a943			;		inc de 
a943			;		inc hl 
a943			;		jr .ldetok 
a943			; 
a943			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a943			;		ld (hl), a  
a943			; 
a943			;; free that temp malloc 
a943			; 
a943			;		pop hl    
a943			; 
a943			;	if DEBUG_FORTH_WORDS 
a943			;		DMARK "Lt4" 
a943			;		CALLMONITOR 
a943			;	endif 
a943			;		call forth_apushstrhl 
a943			; 
a943			;		; get rid of temp malloc area 
a943			; 
a943			;		pop hl 
a943			;		call free 
a943			; 
a943			;		jr .ludone 
a943			; 
a943			;.lnuword:	pop hl 
a943			;		call forth_tok_next 
a943			;		jp .ldouscan  
a943			; 
a943			;.ludone:		 pop hl 
a943			; 
a943					NEXTW 
a943 c3 09 9e			jp macro_next 
a946				endm 
# End of macro NEXTW
a946			 
a946			.FORGET: 
a946				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a946 5d				db WORD_SYS_CORE+73             
a947 bf a9			dw .NOP            
a949 07				db 6 + 1 
a94a .. 00			db "FORGET",0              
a951				endm 
# End of macro CWHEAD
a951			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a951			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
a951			; | |  
a951			; | | e.g. "MORE" forget 
a951					if DEBUG_FORTH_WORDS_KEY 
a951						DMARK "FRG" 
a951 f5				push af  
a952 3a 66 a9			ld a, (.dmark)  
a955 32 6b ee			ld (debug_mark),a  
a958 3a 67 a9			ld a, (.dmark+1)  
a95b 32 6c ee			ld (debug_mark+1),a  
a95e 3a 68 a9			ld a, (.dmark+2)  
a961 32 6d ee			ld (debug_mark+2),a  
a964 18 03			jr .pastdmark  
a966 ..			.dmark: db "FRG"  
a969 f1			.pastdmark: pop af  
a96a			endm  
# End of macro DMARK
a96a						CALLMONITOR 
a96a cd 6f ee			call debug_vector  
a96d				endm  
# End of macro CALLMONITOR
a96d					endif 
a96d			 
a96d				; find uword 
a96d			        ; update start of word with "_" 
a96d				; replace uword with deleted flag 
a96d			 
a96d			 
a96d			;	if DEBUG_FORTH_WORDS 
a96d			;		DMARK "FOG" 
a96d			;		CALLMONITOR 
a96d			;	endif 
a96d			 
a96d			 
a96d					; Get ptr to the word we need to look up 
a96d			 
a96d					FORTH_DSP_VALUEHL 
a96d cd 53 9c			call macro_dsp_valuehl 
a970				endm 
# End of macro FORTH_DSP_VALUEHL
a970					;v5 FORTH_DSP_VALUE 
a970				; TODO type check 
a970			;		inc hl    ; Skip type check  
a970 e5					push hl 
a971 c1					pop bc 
a972			;		ex de, hl    ; put into DE 
a972			 
a972			 
a972 21 f9 e3				ld hl, baseram 
a975					;ld hl, baseusermem 
a975			 
a975				; skip dict stub 
a975			;	call forth_tok_next 
a975 e5			push hl   ; sacreifical push 
a976			 
a976			.fldouscanm: 
a976 e1				pop hl 
a977			.fldouscan: 
a977			;	if DEBUG_FORTH_WORDS 
a977			;		DMARK "LSs" 
a977			;		CALLMONITOR 
a977			;	endif 
a977				; skip dict stub 
a977 cd 5a 9f				call forth_tok_next 
a97a			 
a97a			 
a97a			; while we have words to look for 
a97a			 
a97a 7e				ld a, (hl)      
a97b			;	if DEBUG_FORTH_WORDS 
a97b			;		DMARK "LSk" 
a97b			;		CALLMONITOR 
a97b			;	endif 
a97b fe 00				cp WORD_SYS_END 
a97d ca b9 a9				jp z, .flunotfound 
a980 fe 01				cp WORD_SYS_UWORD 
a982 c2 77 a9				jp nz, .fldouscan 
a985			 
a985			;	if DEBUG_FORTH_WORDS 
a985			;		DMARK "LSu" 
a985			;		CALLMONITOR 
a985			;	endif 
a985			 
a985					; found a uword but is it the one we want... 
a985			 
a985 c5					push bc     ; uword to find is on bc 
a986 d1					pop de 
a987			 
a987 e5					push hl  ; to save the ptr 
a988			 
a988					; skip opcode 
a988 23					inc hl  
a989					; skip next ptr 
a989 23					inc hl  
a98a 23					inc hl 
a98b					; skip len 
a98b 23					inc hl 
a98c			 
a98c			;	if DEBUG_FORTH_WORDS 
a98c			;		DMARK "LSc" 
a98c			;		CALLMONITOR 
a98c			;	endif 
a98c cd 86 90				call strcmp 
a98f c2 76 a9				jp nz, .fldouscanm 
a992			; 
a992			; 
a992			;; while we have words to look for 
a992			; 
a992			;.fdouscan:	ld a, (hl)      
a992			;	if DEBUG_FORTH_WORDS 
a992			;		DMARK "LSs" 
a992			;		CALLMONITOR 
a992			;	endif 
a992			;		cp WORD_SYS_END 
a992			;		jp z, .fudone 
a992			;		cp WORD_SYS_UWORD 
a992			;		jp nz, .fnuword 
a992			; 
a992			;	if DEBUG_FORTH_WORDS 
a992			;		DMARK "FGu" 
a992			;		CALLMONITOR 
a992			;	endif 
a992			; 
a992			;		; found a uword but is it the one we want... 
a992			; 
a992			; 
a992			;	        pop de   ; get back the dsp name 
a992			;		push de 
a992			; 
a992			;		push hl  ; to save the ptr 
a992			; 
a992			;		; skip opcode 
a992			;		inc hl  
a992			;		; skip next ptr 
a992			;		inc hl  
a992			;		inc hl 
a992			;		; skip len 
a992			;		inc hl 
a992			; 
a992			;	if DEBUG_FORTH_WORDS 
a992			;		DMARK "FGc" 
a992			;		CALLMONITOR 
a992			;	endif 
a992			;		call strcmp 
a992			;		jp nz, .fnuword 
a992			 
a992			 
a992 e1			pop hl 
a993			 
a993				 
a993				if DEBUG_FORTH_WORDS 
a993					DMARK "FGm" 
a993 f5				push af  
a994 3a a8 a9			ld a, (.dmark)  
a997 32 6b ee			ld (debug_mark),a  
a99a 3a a9 a9			ld a, (.dmark+1)  
a99d 32 6c ee			ld (debug_mark+1),a  
a9a0 3a aa a9			ld a, (.dmark+2)  
a9a3 32 6d ee			ld (debug_mark+2),a  
a9a6 18 03			jr .pastdmark  
a9a8 ..			.dmark: db "FGm"  
a9ab f1			.pastdmark: pop af  
a9ac			endm  
# End of macro DMARK
a9ac					CALLMONITOR 
a9ac cd 6f ee			call debug_vector  
a9af				endm  
# End of macro CALLMONITOR
a9af				endif 
a9af			 
a9af			 
a9af			 
a9af					; we have a uword so push its name to the stack 
a9af			 
a9af			;	   	push hl  ; save so we can move to next dict block 
a9af			;pop hl 
a9af			 
a9af					; update opcode to deleted 
a9af 3e 03				ld a, WORD_SYS_DELETED 
a9b1 77					ld (hl), a 
a9b2			 
a9b2 23					inc hl  
a9b3					; skip next ptr 
a9b3 23					inc hl  
a9b4 23					inc hl 
a9b5					; skip len 
a9b5 23					inc hl 
a9b6			 
a9b6					; TODO change parser to skip deleted words but for now mark it out 
a9b6 3e 5f				ld a, "_" 
a9b8 77					ld  (hl),a 
a9b9			 
a9b9			;		jr .fudone 
a9b9			; 
a9b9			;.fnuword:	pop hl 
a9b9			;		call forth_tok_next 
a9b9			;		jp .fdouscan  
a9b9			 
a9b9			.flunotfound:		  
a9b9			 
a9b9			 
a9b9					 
a9b9					FORTH_DSP_POP 
a9b9 cd 0b 9d			call macro_forth_dsp_pop 
a9bc				endm 
# End of macro FORTH_DSP_POP
a9bc			;		ld hl, .luno 
a9bc			;.fudone:		 pop hl 
a9bc					NEXTW 
a9bc c3 09 9e			jp macro_next 
a9bf				endm 
# End of macro NEXTW
a9bf			.NOP: 
a9bf				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a9bf 61				db WORD_SYS_CORE+77             
a9c0 e6 a9			dw .COMO            
a9c2 04				db 3 + 1 
a9c3 .. 00			db "NOP",0              
a9c7				endm 
# End of macro CWHEAD
a9c7			; | NOP (  --  ) Do nothing | DONE 
a9c7					if DEBUG_FORTH_WORDS_KEY 
a9c7						DMARK "NOP" 
a9c7 f5				push af  
a9c8 3a dc a9			ld a, (.dmark)  
a9cb 32 6b ee			ld (debug_mark),a  
a9ce 3a dd a9			ld a, (.dmark+1)  
a9d1 32 6c ee			ld (debug_mark+1),a  
a9d4 3a de a9			ld a, (.dmark+2)  
a9d7 32 6d ee			ld (debug_mark+2),a  
a9da 18 03			jr .pastdmark  
a9dc ..			.dmark: db "NOP"  
a9df f1			.pastdmark: pop af  
a9e0			endm  
# End of macro DMARK
a9e0						CALLMONITOR 
a9e0 cd 6f ee			call debug_vector  
a9e3				endm  
# End of macro CALLMONITOR
a9e3					endif 
a9e3				       NEXTW 
a9e3 c3 09 9e			jp macro_next 
a9e6				endm 
# End of macro NEXTW
a9e6			.COMO: 
a9e6				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a9e6 6e				db WORD_SYS_CORE+90             
a9e7 38 aa			dw .COMC            
a9e9 02				db 1 + 1 
a9ea .. 00			db "(",0              
a9ec				endm 
# End of macro CWHEAD
a9ec			; | ( ( -- )  Start of comment | DONE 
a9ec			 
a9ec			 
a9ec 2a c2 e5				ld hl, ( os_tok_ptr) 
a9ef 11 33 aa			ld de, .closepar 
a9f2					 
a9f2					if DEBUG_FORTH_WORDS 
a9f2						DMARK ").." 
a9f2 f5				push af  
a9f3 3a 07 aa			ld a, (.dmark)  
a9f6 32 6b ee			ld (debug_mark),a  
a9f9 3a 08 aa			ld a, (.dmark+1)  
a9fc 32 6c ee			ld (debug_mark+1),a  
a9ff 3a 09 aa			ld a, (.dmark+2)  
aa02 32 6d ee			ld (debug_mark+2),a  
aa05 18 03			jr .pastdmark  
aa07 ..			.dmark: db ").."  
aa0a f1			.pastdmark: pop af  
aa0b			endm  
# End of macro DMARK
aa0b						CALLMONITOR 
aa0b cd 6f ee			call debug_vector  
aa0e				endm  
# End of macro CALLMONITOR
aa0e					endif 
aa0e cd 24 9f			call findnexttok  
aa11			 
aa11					if DEBUG_FORTH_WORDS 
aa11						DMARK "IF5" 
aa11 f5				push af  
aa12 3a 26 aa			ld a, (.dmark)  
aa15 32 6b ee			ld (debug_mark),a  
aa18 3a 27 aa			ld a, (.dmark+1)  
aa1b 32 6c ee			ld (debug_mark+1),a  
aa1e 3a 28 aa			ld a, (.dmark+2)  
aa21 32 6d ee			ld (debug_mark+2),a  
aa24 18 03			jr .pastdmark  
aa26 ..			.dmark: db "IF5"  
aa29 f1			.pastdmark: pop af  
aa2a			endm  
# End of macro DMARK
aa2a						CALLMONITOR 
aa2a cd 6f ee			call debug_vector  
aa2d				endm  
# End of macro CALLMONITOR
aa2d					endif 
aa2d				; replace below with ) exec using tok_ptr 
aa2d 22 c2 e5			ld (os_tok_ptr), hl 
aa30 c3 9a 9e			jp exec1 
aa33			 
aa33 .. 00			.closepar:   db ")",0 
aa35			 
aa35				       NEXTW 
aa35 c3 09 9e			jp macro_next 
aa38				endm 
# End of macro NEXTW
aa38			.COMC: 
aa38				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aa38 6f				db WORD_SYS_CORE+91             
aa39 41 aa			dw .SCRATCH            
aa3b 02				db 1 + 1 
aa3c .. 00			db ")",0              
aa3e				endm 
# End of macro CWHEAD
aa3e			; | ) ( -- )  End of comment |  DONE  
aa3e				       NEXTW 
aa3e c3 09 9e			jp macro_next 
aa41				endm 
# End of macro NEXTW
aa41			 
aa41			.SCRATCH: 
aa41				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aa41 6f				db WORD_SYS_CORE+91             
aa42 7c aa			dw .INC            
aa44 08				db 7 + 1 
aa45 .. 00			db "SCRATCH",0              
aa4d				endm 
# End of macro CWHEAD
aa4d			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aa4d			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aa4d			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aa4d			; | |  
aa4d			; | | e.g.    : score $00 scratch ; 
aa4d			; | |  
aa4d			; | | $00 score ! 
aa4d			; | | $01 score +! 
aa4d			; | |  
aa4d			; | | e.g.   : varword $0a scratch ;  
aa4d			; | | 
aa4d			; | | $8000 varword ! 
aa4d					if DEBUG_FORTH_WORDS_KEY 
aa4d						DMARK "SCR" 
aa4d f5				push af  
aa4e 3a 62 aa			ld a, (.dmark)  
aa51 32 6b ee			ld (debug_mark),a  
aa54 3a 63 aa			ld a, (.dmark+1)  
aa57 32 6c ee			ld (debug_mark+1),a  
aa5a 3a 64 aa			ld a, (.dmark+2)  
aa5d 32 6d ee			ld (debug_mark+2),a  
aa60 18 03			jr .pastdmark  
aa62 ..			.dmark: db "SCR"  
aa65 f1			.pastdmark: pop af  
aa66			endm  
# End of macro DMARK
aa66						CALLMONITOR 
aa66 cd 6f ee			call debug_vector  
aa69				endm  
# End of macro CALLMONITOR
aa69					endif 
aa69			 
aa69					FORTH_DSP_VALUEHL 
aa69 cd 53 9c			call macro_dsp_valuehl 
aa6c				endm 
# End of macro FORTH_DSP_VALUEHL
aa6c				 
aa6c					FORTH_DSP_POP 
aa6c cd 0b 9d			call macro_forth_dsp_pop 
aa6f				endm 
# End of macro FORTH_DSP_POP
aa6f			 
aa6f 7d					ld a, l 
aa70 21 e6 e7				ld hl, os_var_array 
aa73 cd db 8c				call addatohl 
aa76			 
aa76 cd 5c 9a				call forth_push_numhl 
aa79			 
aa79				       NEXTW 
aa79 c3 09 9e			jp macro_next 
aa7c				endm 
# End of macro NEXTW
aa7c			 
aa7c			.INC: 
aa7c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aa7c 6f				db WORD_SYS_CORE+91             
aa7d d2 aa			dw .DEC            
aa7f 03				db 2 + 1 
aa80 .. 00			db "+!",0              
aa83				endm 
# End of macro CWHEAD
aa83			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aa83					if DEBUG_FORTH_WORDS_KEY 
aa83						DMARK "+s_" 
aa83 f5				push af  
aa84 3a 98 aa			ld a, (.dmark)  
aa87 32 6b ee			ld (debug_mark),a  
aa8a 3a 99 aa			ld a, (.dmark+1)  
aa8d 32 6c ee			ld (debug_mark+1),a  
aa90 3a 9a aa			ld a, (.dmark+2)  
aa93 32 6d ee			ld (debug_mark+2),a  
aa96 18 03			jr .pastdmark  
aa98 ..			.dmark: db "+s_"  
aa9b f1			.pastdmark: pop af  
aa9c			endm  
# End of macro DMARK
aa9c						CALLMONITOR 
aa9c cd 6f ee			call debug_vector  
aa9f				endm  
# End of macro CALLMONITOR
aa9f					endif 
aa9f			 
aa9f					FORTH_DSP_VALUEHL 
aa9f cd 53 9c			call macro_dsp_valuehl 
aaa2				endm 
# End of macro FORTH_DSP_VALUEHL
aaa2			 
aaa2 e5					push hl   ; save address 
aaa3			 
aaa3					FORTH_DSP_POP 
aaa3 cd 0b 9d			call macro_forth_dsp_pop 
aaa6				endm 
# End of macro FORTH_DSP_POP
aaa6			 
aaa6					FORTH_DSP_VALUEHL 
aaa6 cd 53 9c			call macro_dsp_valuehl 
aaa9				endm 
# End of macro FORTH_DSP_VALUEHL
aaa9			 
aaa9 e5					push hl 
aaaa					FORTH_DSP_POP 
aaaa cd 0b 9d			call macro_forth_dsp_pop 
aaad				endm 
# End of macro FORTH_DSP_POP
aaad e1					pop hl 
aaae			 
aaae					; hl contains value to add to byte at a 
aaae				 
aaae eb					ex de, hl 
aaaf			 
aaaf e1					pop hl 
aab0			 
aab0					if DEBUG_FORTH_WORDS 
aab0						DMARK "INC" 
aab0 f5				push af  
aab1 3a c5 aa			ld a, (.dmark)  
aab4 32 6b ee			ld (debug_mark),a  
aab7 3a c6 aa			ld a, (.dmark+1)  
aaba 32 6c ee			ld (debug_mark+1),a  
aabd 3a c7 aa			ld a, (.dmark+2)  
aac0 32 6d ee			ld (debug_mark+2),a  
aac3 18 03			jr .pastdmark  
aac5 ..			.dmark: db "INC"  
aac8 f1			.pastdmark: pop af  
aac9			endm  
# End of macro DMARK
aac9						CALLMONITOR 
aac9 cd 6f ee			call debug_vector  
aacc				endm  
# End of macro CALLMONITOR
aacc					endif 
aacc			 
aacc 7e					ld a,(hl) 
aacd 83					add e 
aace 77					ld (hl),a 
aacf			 
aacf			 
aacf			 
aacf				       NEXTW 
aacf c3 09 9e			jp macro_next 
aad2				endm 
# End of macro NEXTW
aad2			 
aad2			.DEC: 
aad2				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
aad2 6f				db WORD_SYS_CORE+91             
aad3 26 ab			dw .INC2            
aad5 03				db 2 + 1 
aad6 .. 00			db "-!",0              
aad9				endm 
# End of macro CWHEAD
aad9			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
aad9					if DEBUG_FORTH_WORDS_KEY 
aad9						DMARK "-s_" 
aad9 f5				push af  
aada 3a ee aa			ld a, (.dmark)  
aadd 32 6b ee			ld (debug_mark),a  
aae0 3a ef aa			ld a, (.dmark+1)  
aae3 32 6c ee			ld (debug_mark+1),a  
aae6 3a f0 aa			ld a, (.dmark+2)  
aae9 32 6d ee			ld (debug_mark+2),a  
aaec 18 03			jr .pastdmark  
aaee ..			.dmark: db "-s_"  
aaf1 f1			.pastdmark: pop af  
aaf2			endm  
# End of macro DMARK
aaf2						CALLMONITOR 
aaf2 cd 6f ee			call debug_vector  
aaf5				endm  
# End of macro CALLMONITOR
aaf5					endif 
aaf5			 
aaf5					FORTH_DSP_VALUEHL 
aaf5 cd 53 9c			call macro_dsp_valuehl 
aaf8				endm 
# End of macro FORTH_DSP_VALUEHL
aaf8			 
aaf8 e5					push hl   ; save address 
aaf9			 
aaf9					FORTH_DSP_POP 
aaf9 cd 0b 9d			call macro_forth_dsp_pop 
aafc				endm 
# End of macro FORTH_DSP_POP
aafc			 
aafc					FORTH_DSP_VALUEHL 
aafc cd 53 9c			call macro_dsp_valuehl 
aaff				endm 
# End of macro FORTH_DSP_VALUEHL
aaff			 
aaff					; hl contains value to add to byte at a 
aaff				 
aaff eb					ex de, hl 
ab00			 
ab00 e1					pop hl 
ab01			 
ab01					if DEBUG_FORTH_WORDS 
ab01						DMARK "DEC" 
ab01 f5				push af  
ab02 3a 16 ab			ld a, (.dmark)  
ab05 32 6b ee			ld (debug_mark),a  
ab08 3a 17 ab			ld a, (.dmark+1)  
ab0b 32 6c ee			ld (debug_mark+1),a  
ab0e 3a 18 ab			ld a, (.dmark+2)  
ab11 32 6d ee			ld (debug_mark+2),a  
ab14 18 03			jr .pastdmark  
ab16 ..			.dmark: db "DEC"  
ab19 f1			.pastdmark: pop af  
ab1a			endm  
# End of macro DMARK
ab1a						CALLMONITOR 
ab1a cd 6f ee			call debug_vector  
ab1d				endm  
# End of macro CALLMONITOR
ab1d					endif 
ab1d			 
ab1d 7e					ld a,(hl) 
ab1e 93					sub e 
ab1f 77					ld (hl),a 
ab20			 
ab20			 
ab20					FORTH_DSP_POP 
ab20 cd 0b 9d			call macro_forth_dsp_pop 
ab23				endm 
# End of macro FORTH_DSP_POP
ab23			 
ab23				       NEXTW 
ab23 c3 09 9e			jp macro_next 
ab26				endm 
# End of macro NEXTW
ab26			 
ab26			.INC2: 
ab26				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab26 6f				db WORD_SYS_CORE+91             
ab27 d3 ab			dw .DEC2            
ab29 04				db 3 + 1 
ab2a .. 00			db "+2!",0              
ab2e				endm 
# End of macro CWHEAD
ab2e			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab2e			 
ab2e					if DEBUG_FORTH_WORDS_KEY 
ab2e						DMARK "+2s" 
ab2e f5				push af  
ab2f 3a 43 ab			ld a, (.dmark)  
ab32 32 6b ee			ld (debug_mark),a  
ab35 3a 44 ab			ld a, (.dmark+1)  
ab38 32 6c ee			ld (debug_mark+1),a  
ab3b 3a 45 ab			ld a, (.dmark+2)  
ab3e 32 6d ee			ld (debug_mark+2),a  
ab41 18 03			jr .pastdmark  
ab43 ..			.dmark: db "+2s"  
ab46 f1			.pastdmark: pop af  
ab47			endm  
# End of macro DMARK
ab47						CALLMONITOR 
ab47 cd 6f ee			call debug_vector  
ab4a				endm  
# End of macro CALLMONITOR
ab4a					endif 
ab4a			 
ab4a					; Address 
ab4a			 
ab4a					FORTH_DSP_VALUEHL 
ab4a cd 53 9c			call macro_dsp_valuehl 
ab4d				endm 
# End of macro FORTH_DSP_VALUEHL
ab4d			 
ab4d e5					push hl    ; save address 
ab4e			 
ab4e					; load content into de 
ab4e			 
ab4e 5e					ld e,(hl) 
ab4f 23					inc hl 
ab50 56					ld d, (hl) 
ab51			 
ab51					if DEBUG_FORTH_WORDS 
ab51						DMARK "+2a" 
ab51 f5				push af  
ab52 3a 66 ab			ld a, (.dmark)  
ab55 32 6b ee			ld (debug_mark),a  
ab58 3a 67 ab			ld a, (.dmark+1)  
ab5b 32 6c ee			ld (debug_mark+1),a  
ab5e 3a 68 ab			ld a, (.dmark+2)  
ab61 32 6d ee			ld (debug_mark+2),a  
ab64 18 03			jr .pastdmark  
ab66 ..			.dmark: db "+2a"  
ab69 f1			.pastdmark: pop af  
ab6a			endm  
# End of macro DMARK
ab6a						CALLMONITOR 
ab6a cd 6f ee			call debug_vector  
ab6d				endm  
# End of macro CALLMONITOR
ab6d					endif 
ab6d			 
ab6d					FORTH_DSP_POP 
ab6d cd 0b 9d			call macro_forth_dsp_pop 
ab70				endm 
# End of macro FORTH_DSP_POP
ab70			 
ab70					; Get value to add 
ab70			 
ab70					FORTH_DSP_VALUE 
ab70 cd 3c 9c			call macro_forth_dsp_value 
ab73				endm 
# End of macro FORTH_DSP_VALUE
ab73			 
ab73					if DEBUG_FORTH_WORDS 
ab73						DMARK "+2v" 
ab73 f5				push af  
ab74 3a 88 ab			ld a, (.dmark)  
ab77 32 6b ee			ld (debug_mark),a  
ab7a 3a 89 ab			ld a, (.dmark+1)  
ab7d 32 6c ee			ld (debug_mark+1),a  
ab80 3a 8a ab			ld a, (.dmark+2)  
ab83 32 6d ee			ld (debug_mark+2),a  
ab86 18 03			jr .pastdmark  
ab88 ..			.dmark: db "+2v"  
ab8b f1			.pastdmark: pop af  
ab8c			endm  
# End of macro DMARK
ab8c						CALLMONITOR 
ab8c cd 6f ee			call debug_vector  
ab8f				endm  
# End of macro CALLMONITOR
ab8f					endif 
ab8f			 
ab8f 19					add hl, de 
ab90			 
ab90					if DEBUG_FORTH_WORDS 
ab90						DMARK "+2+" 
ab90 f5				push af  
ab91 3a a5 ab			ld a, (.dmark)  
ab94 32 6b ee			ld (debug_mark),a  
ab97 3a a6 ab			ld a, (.dmark+1)  
ab9a 32 6c ee			ld (debug_mark+1),a  
ab9d 3a a7 ab			ld a, (.dmark+2)  
aba0 32 6d ee			ld (debug_mark+2),a  
aba3 18 03			jr .pastdmark  
aba5 ..			.dmark: db "+2+"  
aba8 f1			.pastdmark: pop af  
aba9			endm  
# End of macro DMARK
aba9						CALLMONITOR 
aba9 cd 6f ee			call debug_vector  
abac				endm  
# End of macro CALLMONITOR
abac					endif 
abac			 
abac					; move result to de 
abac			 
abac eb					ex de, hl 
abad			 
abad					; Address 
abad			 
abad e1					pop hl 
abae			 
abae					; save it back 
abae			 
abae 73					ld (hl), e 
abaf 23					inc hl 
abb0 72					ld (hl), d 
abb1			 
abb1					if DEBUG_FORTH_WORDS 
abb1						DMARK "+2e" 
abb1 f5				push af  
abb2 3a c6 ab			ld a, (.dmark)  
abb5 32 6b ee			ld (debug_mark),a  
abb8 3a c7 ab			ld a, (.dmark+1)  
abbb 32 6c ee			ld (debug_mark+1),a  
abbe 3a c8 ab			ld a, (.dmark+2)  
abc1 32 6d ee			ld (debug_mark+2),a  
abc4 18 03			jr .pastdmark  
abc6 ..			.dmark: db "+2e"  
abc9 f1			.pastdmark: pop af  
abca			endm  
# End of macro DMARK
abca						CALLMONITOR 
abca cd 6f ee			call debug_vector  
abcd				endm  
# End of macro CALLMONITOR
abcd					endif 
abcd			 
abcd			 
abcd			 
abcd					FORTH_DSP_POP 
abcd cd 0b 9d			call macro_forth_dsp_pop 
abd0				endm 
# End of macro FORTH_DSP_POP
abd0			 
abd0			 
abd0				       NEXTW 
abd0 c3 09 9e			jp macro_next 
abd3				endm 
# End of macro NEXTW
abd3			 
abd3			.DEC2: 
abd3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
abd3 6f				db WORD_SYS_CORE+91             
abd4 82 ac			dw .GET2            
abd6 04				db 3 + 1 
abd7 .. 00			db "-2!",0              
abdb				endm 
# End of macro CWHEAD
abdb			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
abdb			 
abdb			 
abdb					if DEBUG_FORTH_WORDS_KEY 
abdb						DMARK "-2s" 
abdb f5				push af  
abdc 3a f0 ab			ld a, (.dmark)  
abdf 32 6b ee			ld (debug_mark),a  
abe2 3a f1 ab			ld a, (.dmark+1)  
abe5 32 6c ee			ld (debug_mark+1),a  
abe8 3a f2 ab			ld a, (.dmark+2)  
abeb 32 6d ee			ld (debug_mark+2),a  
abee 18 03			jr .pastdmark  
abf0 ..			.dmark: db "-2s"  
abf3 f1			.pastdmark: pop af  
abf4			endm  
# End of macro DMARK
abf4						CALLMONITOR 
abf4 cd 6f ee			call debug_vector  
abf7				endm  
# End of macro CALLMONITOR
abf7					endif 
abf7			 
abf7					; Address 
abf7			 
abf7					FORTH_DSP_VALUEHL 
abf7 cd 53 9c			call macro_dsp_valuehl 
abfa				endm 
# End of macro FORTH_DSP_VALUEHL
abfa			 
abfa e5					push hl    ; save address 
abfb			 
abfb					; load content into de 
abfb			 
abfb 5e					ld e,(hl) 
abfc 23					inc hl 
abfd 56					ld d, (hl) 
abfe			 
abfe					if DEBUG_FORTH_WORDS 
abfe						DMARK "-2a" 
abfe f5				push af  
abff 3a 13 ac			ld a, (.dmark)  
ac02 32 6b ee			ld (debug_mark),a  
ac05 3a 14 ac			ld a, (.dmark+1)  
ac08 32 6c ee			ld (debug_mark+1),a  
ac0b 3a 15 ac			ld a, (.dmark+2)  
ac0e 32 6d ee			ld (debug_mark+2),a  
ac11 18 03			jr .pastdmark  
ac13 ..			.dmark: db "-2a"  
ac16 f1			.pastdmark: pop af  
ac17			endm  
# End of macro DMARK
ac17						CALLMONITOR 
ac17 cd 6f ee			call debug_vector  
ac1a				endm  
# End of macro CALLMONITOR
ac1a					endif 
ac1a			 
ac1a					FORTH_DSP_POP 
ac1a cd 0b 9d			call macro_forth_dsp_pop 
ac1d				endm 
# End of macro FORTH_DSP_POP
ac1d			 
ac1d					; Get value to remove 
ac1d			 
ac1d					FORTH_DSP_VALUE 
ac1d cd 3c 9c			call macro_forth_dsp_value 
ac20				endm 
# End of macro FORTH_DSP_VALUE
ac20			 
ac20					if DEBUG_FORTH_WORDS 
ac20						DMARK "-2v" 
ac20 f5				push af  
ac21 3a 35 ac			ld a, (.dmark)  
ac24 32 6b ee			ld (debug_mark),a  
ac27 3a 36 ac			ld a, (.dmark+1)  
ac2a 32 6c ee			ld (debug_mark+1),a  
ac2d 3a 37 ac			ld a, (.dmark+2)  
ac30 32 6d ee			ld (debug_mark+2),a  
ac33 18 03			jr .pastdmark  
ac35 ..			.dmark: db "-2v"  
ac38 f1			.pastdmark: pop af  
ac39			endm  
# End of macro DMARK
ac39						CALLMONITOR 
ac39 cd 6f ee			call debug_vector  
ac3c				endm  
# End of macro CALLMONITOR
ac3c					endif 
ac3c			 
ac3c eb					ex de, hl 
ac3d ed 52				sbc hl, de 
ac3f			 
ac3f					if DEBUG_FORTH_WORDS 
ac3f						DMARK "-2d" 
ac3f f5				push af  
ac40 3a 54 ac			ld a, (.dmark)  
ac43 32 6b ee			ld (debug_mark),a  
ac46 3a 55 ac			ld a, (.dmark+1)  
ac49 32 6c ee			ld (debug_mark+1),a  
ac4c 3a 56 ac			ld a, (.dmark+2)  
ac4f 32 6d ee			ld (debug_mark+2),a  
ac52 18 03			jr .pastdmark  
ac54 ..			.dmark: db "-2d"  
ac57 f1			.pastdmark: pop af  
ac58			endm  
# End of macro DMARK
ac58						CALLMONITOR 
ac58 cd 6f ee			call debug_vector  
ac5b				endm  
# End of macro CALLMONITOR
ac5b					endif 
ac5b			 
ac5b					; move result to de 
ac5b			 
ac5b eb					ex de, hl 
ac5c			 
ac5c					; Address 
ac5c			 
ac5c e1					pop hl 
ac5d			 
ac5d					; save it back 
ac5d			 
ac5d 73					ld (hl), e 
ac5e 23					inc hl 
ac5f 72					ld (hl), d 
ac60			 
ac60					if DEBUG_FORTH_WORDS 
ac60						DMARK "-2e" 
ac60 f5				push af  
ac61 3a 75 ac			ld a, (.dmark)  
ac64 32 6b ee			ld (debug_mark),a  
ac67 3a 76 ac			ld a, (.dmark+1)  
ac6a 32 6c ee			ld (debug_mark+1),a  
ac6d 3a 77 ac			ld a, (.dmark+2)  
ac70 32 6d ee			ld (debug_mark+2),a  
ac73 18 03			jr .pastdmark  
ac75 ..			.dmark: db "-2e"  
ac78 f1			.pastdmark: pop af  
ac79			endm  
# End of macro DMARK
ac79						CALLMONITOR 
ac79 cd 6f ee			call debug_vector  
ac7c				endm  
# End of macro CALLMONITOR
ac7c					endif 
ac7c			 
ac7c			 
ac7c					FORTH_DSP_POP 
ac7c cd 0b 9d			call macro_forth_dsp_pop 
ac7f				endm 
# End of macro FORTH_DSP_POP
ac7f			 
ac7f			 
ac7f			 
ac7f				       NEXTW 
ac7f c3 09 9e			jp macro_next 
ac82				endm 
# End of macro NEXTW
ac82			.GET2: 
ac82				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ac82 6f				db WORD_SYS_CORE+91             
ac83 b7 ac			dw .BANG2            
ac85 03				db 2 + 1 
ac86 .. 00			db "2@",0              
ac89				endm 
# End of macro CWHEAD
ac89			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ac89					if DEBUG_FORTH_WORDS_KEY 
ac89						DMARK "2A_" 
ac89 f5				push af  
ac8a 3a 9e ac			ld a, (.dmark)  
ac8d 32 6b ee			ld (debug_mark),a  
ac90 3a 9f ac			ld a, (.dmark+1)  
ac93 32 6c ee			ld (debug_mark+1),a  
ac96 3a a0 ac			ld a, (.dmark+2)  
ac99 32 6d ee			ld (debug_mark+2),a  
ac9c 18 03			jr .pastdmark  
ac9e ..			.dmark: db "2A_"  
aca1 f1			.pastdmark: pop af  
aca2			endm  
# End of macro DMARK
aca2						CALLMONITOR 
aca2 cd 6f ee			call debug_vector  
aca5				endm  
# End of macro CALLMONITOR
aca5					endif 
aca5			 
aca5					FORTH_DSP_VALUEHL 
aca5 cd 53 9c			call macro_dsp_valuehl 
aca8				endm 
# End of macro FORTH_DSP_VALUEHL
aca8			 
aca8 e5					push hl   ; save address 
aca9			 
aca9					FORTH_DSP_POP 
aca9 cd 0b 9d			call macro_forth_dsp_pop 
acac				endm 
# End of macro FORTH_DSP_POP
acac			 
acac e1					pop hl 
acad			 
acad 5e					ld e, (hl) 
acae 23					inc hl 
acaf 56					ld d, (hl) 
acb0			 
acb0 eb					ex de, hl 
acb1			 
acb1 cd 5c 9a				call forth_push_numhl 
acb4			 
acb4				       NEXTW 
acb4 c3 09 9e			jp macro_next 
acb7				endm 
# End of macro NEXTW
acb7			.BANG2: 
acb7				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
acb7 6f				db WORD_SYS_CORE+91             
acb8 ef ac			dw .CONFIG            
acba 03				db 2 + 1 
acbb .. 00			db "2!",0              
acbe				endm 
# End of macro CWHEAD
acbe			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
acbe					if DEBUG_FORTH_WORDS_KEY 
acbe						DMARK "2S_" 
acbe f5				push af  
acbf 3a d3 ac			ld a, (.dmark)  
acc2 32 6b ee			ld (debug_mark),a  
acc5 3a d4 ac			ld a, (.dmark+1)  
acc8 32 6c ee			ld (debug_mark+1),a  
accb 3a d5 ac			ld a, (.dmark+2)  
acce 32 6d ee			ld (debug_mark+2),a  
acd1 18 03			jr .pastdmark  
acd3 ..			.dmark: db "2S_"  
acd6 f1			.pastdmark: pop af  
acd7			endm  
# End of macro DMARK
acd7						CALLMONITOR 
acd7 cd 6f ee			call debug_vector  
acda				endm  
# End of macro CALLMONITOR
acda					endif 
acda			 
acda					FORTH_DSP_VALUEHL 
acda cd 53 9c			call macro_dsp_valuehl 
acdd				endm 
# End of macro FORTH_DSP_VALUEHL
acdd			 
acdd e5					push hl   ; save address 
acde			 
acde			 
acde					FORTH_DSP_POP 
acde cd 0b 9d			call macro_forth_dsp_pop 
ace1				endm 
# End of macro FORTH_DSP_POP
ace1			 
ace1					 
ace1					FORTH_DSP_VALUEHL 
ace1 cd 53 9c			call macro_dsp_valuehl 
ace4				endm 
# End of macro FORTH_DSP_VALUEHL
ace4			 
ace4					FORTH_DSP_POP 
ace4 cd 0b 9d			call macro_forth_dsp_pop 
ace7				endm 
# End of macro FORTH_DSP_POP
ace7			 
ace7 eb					ex de, hl    ; value now in de 
ace8			 
ace8 e1					pop hl 
ace9			 
ace9 73					ld (hl), e 
acea			 
acea 23					inc hl 
aceb			 
aceb 72					ld (hl), d 
acec			 
acec			 
acec				       NEXTW 
acec c3 09 9e			jp macro_next 
acef				endm 
# End of macro NEXTW
acef			.CONFIG: 
acef				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
acef 6f				db WORD_SYS_CORE+91             
acf0 00 ad			dw .ADTOS            
acf2 07				db 6 + 1 
acf3 .. 00			db "CONFIG",0              
acfa				endm 
# End of macro CWHEAD
acfa			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
acfa			 
acfa cd 5c 92				call config 
acfd					NEXTW 
acfd c3 09 9e			jp macro_next 
ad00				endm 
# End of macro NEXTW
ad00			 
ad00			.ADTOS: 
ad00				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
ad00 6f				db WORD_SYS_CORE+91             
ad01 16 ad			dw .SBTOS            
ad03 03				db 2 + 1 
ad04 .. 00			db "1+",0              
ad07				endm 
# End of macro CWHEAD
ad07			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ad07			 
ad07					FORTH_DSP_VALUEHL 
ad07 cd 53 9c			call macro_dsp_valuehl 
ad0a				endm 
# End of macro FORTH_DSP_VALUEHL
ad0a e5					push hl 
ad0b			 
ad0b					FORTH_DSP_POP 
ad0b cd 0b 9d			call macro_forth_dsp_pop 
ad0e				endm 
# End of macro FORTH_DSP_POP
ad0e e1					pop hl 
ad0f			 
ad0f 23					inc hl 
ad10 cd 5c 9a				call forth_push_numhl 
ad13					 
ad13					NEXTW 
ad13 c3 09 9e			jp macro_next 
ad16				endm 
# End of macro NEXTW
ad16			.SBTOS: 
ad16				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ad16 6f				db WORD_SYS_CORE+91             
ad17 2c ad			dw .ADSTORE            
ad19 03				db 2 + 1 
ad1a .. 00			db "1-",0              
ad1d				endm 
# End of macro CWHEAD
ad1d			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ad1d			 
ad1d					FORTH_DSP_VALUEHL 
ad1d cd 53 9c			call macro_dsp_valuehl 
ad20				endm 
# End of macro FORTH_DSP_VALUEHL
ad20 e5					push hl 
ad21			 
ad21					FORTH_DSP_POP 
ad21 cd 0b 9d			call macro_forth_dsp_pop 
ad24				endm 
# End of macro FORTH_DSP_POP
ad24 e1					pop hl 
ad25			 
ad25 2b					dec hl 
ad26 cd 5c 9a				call forth_push_numhl 
ad29					 
ad29					NEXTW 
ad29 c3 09 9e			jp macro_next 
ad2c				endm 
# End of macro NEXTW
ad2c			.ADSTORE: 
ad2c				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ad2c 6f				db WORD_SYS_CORE+91             
ad2d 42 ad			dw .ADWSTORE            
ad2f 04				db 3 + 1 
ad30 .. 00			db "1+!",0              
ad34				endm 
# End of macro CWHEAD
ad34			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ad34			 
ad34					FORTH_DSP_VALUEHL 
ad34 cd 53 9c			call macro_dsp_valuehl 
ad37				endm 
# End of macro FORTH_DSP_VALUEHL
ad37 e5					push hl 
ad38			 
ad38					FORTH_DSP_POP 
ad38 cd 0b 9d			call macro_forth_dsp_pop 
ad3b				endm 
# End of macro FORTH_DSP_POP
ad3b e1					pop hl 
ad3c			 
ad3c 7e					ld a, (hl) 
ad3d 3c					inc a 
ad3e 77					ld (hl), a 
ad3f					 
ad3f					NEXTW 
ad3f c3 09 9e			jp macro_next 
ad42				endm 
# End of macro NEXTW
ad42			.ADWSTORE: 
ad42				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ad42 6f				db WORD_SYS_CORE+91             
ad43 60 ad			dw .SBSTORE            
ad45 05				db 4 + 1 
ad46 .. 00			db "1+2!",0              
ad4b				endm 
# End of macro CWHEAD
ad4b			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ad4b			 
ad4b					FORTH_DSP_VALUEHL 
ad4b cd 53 9c			call macro_dsp_valuehl 
ad4e				endm 
# End of macro FORTH_DSP_VALUEHL
ad4e e5					push hl 
ad4f			 
ad4f					FORTH_DSP_POP 
ad4f cd 0b 9d			call macro_forth_dsp_pop 
ad52				endm 
# End of macro FORTH_DSP_POP
ad52 e1					pop hl 
ad53			 
ad53 e5					push hl 
ad54			 
ad54 cd 8b 9d				call loadwordinhl 
ad57 23					inc hl 
ad58			 
ad58 d1					pop de 
ad59 eb					ex de, hl 
ad5a 73					ld (hl), e 
ad5b 23					inc hl 
ad5c 72					ld (hl), d 
ad5d					 
ad5d					NEXTW 
ad5d c3 09 9e			jp macro_next 
ad60				endm 
# End of macro NEXTW
ad60			.SBSTORE: 
ad60				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ad60 6f				db WORD_SYS_CORE+91             
ad61 76 ad			dw .SBWSTORE            
ad63 04				db 3 + 1 
ad64 .. 00			db "1-!",0              
ad68				endm 
# End of macro CWHEAD
ad68			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ad68			 
ad68					FORTH_DSP_VALUEHL 
ad68 cd 53 9c			call macro_dsp_valuehl 
ad6b				endm 
# End of macro FORTH_DSP_VALUEHL
ad6b e5					push hl 
ad6c			 
ad6c					FORTH_DSP_POP 
ad6c cd 0b 9d			call macro_forth_dsp_pop 
ad6f				endm 
# End of macro FORTH_DSP_POP
ad6f e1					pop hl 
ad70			 
ad70 7e					ld a, (hl) 
ad71 3d					dec a 
ad72 77					ld (hl), a 
ad73					 
ad73					NEXTW 
ad73 c3 09 9e			jp macro_next 
ad76				endm 
# End of macro NEXTW
ad76			.SBWSTORE: 
ad76				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ad76 6f				db WORD_SYS_CORE+91             
ad77 94 ad			dw .ENDCORE            
ad79 05				db 4 + 1 
ad7a .. 00			db "1-2!",0              
ad7f				endm 
# End of macro CWHEAD
ad7f			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
ad7f			 
ad7f					FORTH_DSP_VALUEHL 
ad7f cd 53 9c			call macro_dsp_valuehl 
ad82				endm 
# End of macro FORTH_DSP_VALUEHL
ad82 e5					push hl 
ad83			 
ad83					FORTH_DSP_POP 
ad83 cd 0b 9d			call macro_forth_dsp_pop 
ad86				endm 
# End of macro FORTH_DSP_POP
ad86 e1					pop hl 
ad87			 
ad87 e5					push hl 
ad88			 
ad88 cd 8b 9d				call loadwordinhl 
ad8b 2b					dec hl 
ad8c			 
ad8c d1					pop de 
ad8d eb					ex de, hl 
ad8e 73					ld (hl), e 
ad8f 23					inc hl 
ad90 72					ld (hl), d 
ad91					 
ad91					NEXTW 
ad91 c3 09 9e			jp macro_next 
ad94				endm 
# End of macro NEXTW
ad94			.ENDCORE: 
ad94			 
ad94			; eof 
ad94			 
ad94			 
# End of file forth_words_core.asm
ad94			include "forth_words_flow.asm" 
ad94			 
ad94			; | ## Program Flow Words 
ad94			 
ad94			.IF: 
ad94				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ad94 1e				db WORD_SYS_CORE+10             
ad95 89 ae			dw .THEN            
ad97 03				db 2 + 1 
ad98 .. 00			db "IF",0              
ad9b				endm 
# End of macro CWHEAD
ad9b			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ad9b			; 
ad9b					if DEBUG_FORTH_WORDS_KEY 
ad9b						DMARK "IF." 
ad9b f5				push af  
ad9c 3a b0 ad			ld a, (.dmark)  
ad9f 32 6b ee			ld (debug_mark),a  
ada2 3a b1 ad			ld a, (.dmark+1)  
ada5 32 6c ee			ld (debug_mark+1),a  
ada8 3a b2 ad			ld a, (.dmark+2)  
adab 32 6d ee			ld (debug_mark+2),a  
adae 18 03			jr .pastdmark  
adb0 ..			.dmark: db "IF."  
adb3 f1			.pastdmark: pop af  
adb4			endm  
# End of macro DMARK
adb4						CALLMONITOR 
adb4 cd 6f ee			call debug_vector  
adb7				endm  
# End of macro CALLMONITOR
adb7					endif 
adb7			; eval TOS 
adb7			 
adb7				FORTH_DSP_VALUEHL 
adb7 cd 53 9c			call macro_dsp_valuehl 
adba				endm 
# End of macro FORTH_DSP_VALUEHL
adba			 
adba			;	push hl 
adba				FORTH_DSP_POP 
adba cd 0b 9d			call macro_forth_dsp_pop 
adbd				endm 
# End of macro FORTH_DSP_POP
adbd			;	pop hl 
adbd			 
adbd					if DEBUG_FORTH_WORDS 
adbd						DMARK "IF1" 
adbd f5				push af  
adbe 3a d2 ad			ld a, (.dmark)  
adc1 32 6b ee			ld (debug_mark),a  
adc4 3a d3 ad			ld a, (.dmark+1)  
adc7 32 6c ee			ld (debug_mark+1),a  
adca 3a d4 ad			ld a, (.dmark+2)  
adcd 32 6d ee			ld (debug_mark+2),a  
add0 18 03			jr .pastdmark  
add2 ..			.dmark: db "IF1"  
add5 f1			.pastdmark: pop af  
add6			endm  
# End of macro DMARK
add6						CALLMONITOR 
add6 cd 6f ee			call debug_vector  
add9				endm  
# End of macro CALLMONITOR
add9					endif 
add9 b7				or a        ; clear carry flag 
adda 11 00 00			ld de, 0 
addd eb				ex de,hl 
adde ed 52			sbc hl, de 
ade0 c2 6a ae			jp nz, .iftrue 
ade3			 
ade3					if DEBUG_FORTH_WORDS 
ade3						DMARK "IF2" 
ade3 f5				push af  
ade4 3a f8 ad			ld a, (.dmark)  
ade7 32 6b ee			ld (debug_mark),a  
adea 3a f9 ad			ld a, (.dmark+1)  
aded 32 6c ee			ld (debug_mark+1),a  
adf0 3a fa ad			ld a, (.dmark+2)  
adf3 32 6d ee			ld (debug_mark+2),a  
adf6 18 03			jr .pastdmark  
adf8 ..			.dmark: db "IF2"  
adfb f1			.pastdmark: pop af  
adfc			endm  
# End of macro DMARK
adfc						CALLMONITOR 
adfc cd 6f ee			call debug_vector  
adff				endm  
# End of macro CALLMONITOR
adff					endif 
adff			 
adff			; if not true then skip to THEN 
adff			 
adff				; TODO get tok_ptr 
adff				; TODO consume toks until we get to THEN 
adff			 
adff 2a c2 e5			ld hl, (os_tok_ptr) 
ae02					if DEBUG_FORTH_WORDS 
ae02						DMARK "IF3" 
ae02 f5				push af  
ae03 3a 17 ae			ld a, (.dmark)  
ae06 32 6b ee			ld (debug_mark),a  
ae09 3a 18 ae			ld a, (.dmark+1)  
ae0c 32 6c ee			ld (debug_mark+1),a  
ae0f 3a 19 ae			ld a, (.dmark+2)  
ae12 32 6d ee			ld (debug_mark+2),a  
ae15 18 03			jr .pastdmark  
ae17 ..			.dmark: db "IF3"  
ae1a f1			.pastdmark: pop af  
ae1b			endm  
# End of macro DMARK
ae1b						CALLMONITOR 
ae1b cd 6f ee			call debug_vector  
ae1e				endm  
# End of macro CALLMONITOR
ae1e						 
ae1e					endif 
ae1e 11 65 ae			ld de, .ifthen 
ae21					if DEBUG_FORTH_WORDS 
ae21						DMARK "IF4" 
ae21 f5				push af  
ae22 3a 36 ae			ld a, (.dmark)  
ae25 32 6b ee			ld (debug_mark),a  
ae28 3a 37 ae			ld a, (.dmark+1)  
ae2b 32 6c ee			ld (debug_mark+1),a  
ae2e 3a 38 ae			ld a, (.dmark+2)  
ae31 32 6d ee			ld (debug_mark+2),a  
ae34 18 03			jr .pastdmark  
ae36 ..			.dmark: db "IF4"  
ae39 f1			.pastdmark: pop af  
ae3a			endm  
# End of macro DMARK
ae3a						CALLMONITOR 
ae3a cd 6f ee			call debug_vector  
ae3d				endm  
# End of macro CALLMONITOR
ae3d					endif 
ae3d cd 24 9f			call findnexttok  
ae40			 
ae40					if DEBUG_FORTH_WORDS 
ae40						DMARK "IF5" 
ae40 f5				push af  
ae41 3a 55 ae			ld a, (.dmark)  
ae44 32 6b ee			ld (debug_mark),a  
ae47 3a 56 ae			ld a, (.dmark+1)  
ae4a 32 6c ee			ld (debug_mark+1),a  
ae4d 3a 57 ae			ld a, (.dmark+2)  
ae50 32 6d ee			ld (debug_mark+2),a  
ae53 18 03			jr .pastdmark  
ae55 ..			.dmark: db "IF5"  
ae58 f1			.pastdmark: pop af  
ae59			endm  
# End of macro DMARK
ae59						CALLMONITOR 
ae59 cd 6f ee			call debug_vector  
ae5c				endm  
# End of macro CALLMONITOR
ae5c					endif 
ae5c				; TODO replace below with ; exec using tok_ptr 
ae5c 22 c2 e5			ld (os_tok_ptr), hl 
ae5f c3 9a 9e			jp exec1 
ae62				NEXTW 
ae62 c3 09 9e			jp macro_next 
ae65				endm 
# End of macro NEXTW
ae65			 
ae65 .. 00		.ifthen:  db "THEN",0 
ae6a			 
ae6a			.iftrue:		 
ae6a				; Exec next words normally 
ae6a			 
ae6a				; if true then exec following IF as normal 
ae6a					if DEBUG_FORTH_WORDS 
ae6a						DMARK "IFT" 
ae6a f5				push af  
ae6b 3a 7f ae			ld a, (.dmark)  
ae6e 32 6b ee			ld (debug_mark),a  
ae71 3a 80 ae			ld a, (.dmark+1)  
ae74 32 6c ee			ld (debug_mark+1),a  
ae77 3a 81 ae			ld a, (.dmark+2)  
ae7a 32 6d ee			ld (debug_mark+2),a  
ae7d 18 03			jr .pastdmark  
ae7f ..			.dmark: db "IFT"  
ae82 f1			.pastdmark: pop af  
ae83			endm  
# End of macro DMARK
ae83						CALLMONITOR 
ae83 cd 6f ee			call debug_vector  
ae86				endm  
# End of macro CALLMONITOR
ae86					endif 
ae86			 
ae86					NEXTW 
ae86 c3 09 9e			jp macro_next 
ae89				endm 
# End of macro NEXTW
ae89			.THEN: 
ae89				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae89 1f				db WORD_SYS_CORE+11             
ae8a b1 ae			dw .ELSE            
ae8c 05				db 4 + 1 
ae8d .. 00			db "THEN",0              
ae92				endm 
# End of macro CWHEAD
ae92			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ae92					if DEBUG_FORTH_WORDS_KEY 
ae92						DMARK "THN" 
ae92 f5				push af  
ae93 3a a7 ae			ld a, (.dmark)  
ae96 32 6b ee			ld (debug_mark),a  
ae99 3a a8 ae			ld a, (.dmark+1)  
ae9c 32 6c ee			ld (debug_mark+1),a  
ae9f 3a a9 ae			ld a, (.dmark+2)  
aea2 32 6d ee			ld (debug_mark+2),a  
aea5 18 03			jr .pastdmark  
aea7 ..			.dmark: db "THN"  
aeaa f1			.pastdmark: pop af  
aeab			endm  
# End of macro DMARK
aeab						CALLMONITOR 
aeab cd 6f ee			call debug_vector  
aeae				endm  
# End of macro CALLMONITOR
aeae					endif 
aeae					NEXTW 
aeae c3 09 9e			jp macro_next 
aeb1				endm 
# End of macro NEXTW
aeb1			.ELSE: 
aeb1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aeb1 20				db WORD_SYS_CORE+12             
aeb2 d9 ae			dw .DO            
aeb4 03				db 2 + 1 
aeb5 .. 00			db "ELSE",0              
aeba				endm 
# End of macro CWHEAD
aeba			; | ELSE ( -- ) Not supported - does nothing | TODO 
aeba			 
aeba					if DEBUG_FORTH_WORDS_KEY 
aeba						DMARK "ELS" 
aeba f5				push af  
aebb 3a cf ae			ld a, (.dmark)  
aebe 32 6b ee			ld (debug_mark),a  
aec1 3a d0 ae			ld a, (.dmark+1)  
aec4 32 6c ee			ld (debug_mark+1),a  
aec7 3a d1 ae			ld a, (.dmark+2)  
aeca 32 6d ee			ld (debug_mark+2),a  
aecd 18 03			jr .pastdmark  
aecf ..			.dmark: db "ELS"  
aed2 f1			.pastdmark: pop af  
aed3			endm  
# End of macro DMARK
aed3						CALLMONITOR 
aed3 cd 6f ee			call debug_vector  
aed6				endm  
# End of macro CALLMONITOR
aed6					endif 
aed6			 
aed6			 
aed6					NEXTW 
aed6 c3 09 9e			jp macro_next 
aed9				endm 
# End of macro NEXTW
aed9			.DO: 
aed9				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aed9 21				db WORD_SYS_CORE+13             
aeda 00 b0			dw .LOOP            
aedc 03				db 2 + 1 
aedd .. 00			db "DO",0              
aee0				endm 
# End of macro CWHEAD
aee0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aee0			 
aee0					if DEBUG_FORTH_WORDS_KEY 
aee0						DMARK "DO." 
aee0 f5				push af  
aee1 3a f5 ae			ld a, (.dmark)  
aee4 32 6b ee			ld (debug_mark),a  
aee7 3a f6 ae			ld a, (.dmark+1)  
aeea 32 6c ee			ld (debug_mark+1),a  
aeed 3a f7 ae			ld a, (.dmark+2)  
aef0 32 6d ee			ld (debug_mark+2),a  
aef3 18 03			jr .pastdmark  
aef5 ..			.dmark: db "DO."  
aef8 f1			.pastdmark: pop af  
aef9			endm  
# End of macro DMARK
aef9						CALLMONITOR 
aef9 cd 6f ee			call debug_vector  
aefc				endm  
# End of macro CALLMONITOR
aefc					endif 
aefc			;  push pc to rsp stack past the DO 
aefc			 
aefc 2a c2 e5				ld hl, (os_tok_ptr) 
aeff 23					inc hl   ; D 
af00 23					inc hl  ; O 
af01 23					inc hl   ; null 
af02					if DEBUG_FORTH_WORDS 
af02						DMARK "DO2" 
af02 f5				push af  
af03 3a 17 af			ld a, (.dmark)  
af06 32 6b ee			ld (debug_mark),a  
af09 3a 18 af			ld a, (.dmark+1)  
af0c 32 6c ee			ld (debug_mark+1),a  
af0f 3a 19 af			ld a, (.dmark+2)  
af12 32 6d ee			ld (debug_mark+2),a  
af15 18 03			jr .pastdmark  
af17 ..			.dmark: db "DO2"  
af1a f1			.pastdmark: pop af  
af1b			endm  
# End of macro DMARK
af1b						CALLMONITOR 
af1b cd 6f ee			call debug_vector  
af1e				endm  
# End of macro CALLMONITOR
af1e					endif 
af1e					FORTH_RSP_NEXT 
af1e cd 03 9a			call macro_forth_rsp_next 
af21				endm 
# End of macro FORTH_RSP_NEXT
af21					if DEBUG_FORTH_WORDS 
af21						DMARK "DO3" 
af21 f5				push af  
af22 3a 36 af			ld a, (.dmark)  
af25 32 6b ee			ld (debug_mark),a  
af28 3a 37 af			ld a, (.dmark+1)  
af2b 32 6c ee			ld (debug_mark+1),a  
af2e 3a 38 af			ld a, (.dmark+2)  
af31 32 6d ee			ld (debug_mark+2),a  
af34 18 03			jr .pastdmark  
af36 ..			.dmark: db "DO3"  
af39 f1			.pastdmark: pop af  
af3a			endm  
# End of macro DMARK
af3a						CALLMONITOR 
af3a cd 6f ee			call debug_vector  
af3d				endm  
# End of macro CALLMONITOR
af3d					endif 
af3d			 
af3d					;if DEBUG_FORTH_WORDS 
af3d				;		push hl 
af3d			;		endif  
af3d			 
af3d			; get counters from data stack 
af3d			 
af3d			 
af3d					FORTH_DSP_VALUEHL 
af3d cd 53 9c			call macro_dsp_valuehl 
af40				endm 
# End of macro FORTH_DSP_VALUEHL
af40 e5					push hl		 ; hl now has starting counter which needs to be tos 
af41			 
af41					if DEBUG_FORTH_WORDS 
af41						DMARK "DO4" 
af41 f5				push af  
af42 3a 56 af			ld a, (.dmark)  
af45 32 6b ee			ld (debug_mark),a  
af48 3a 57 af			ld a, (.dmark+1)  
af4b 32 6c ee			ld (debug_mark+1),a  
af4e 3a 58 af			ld a, (.dmark+2)  
af51 32 6d ee			ld (debug_mark+2),a  
af54 18 03			jr .pastdmark  
af56 ..			.dmark: db "DO4"  
af59 f1			.pastdmark: pop af  
af5a			endm  
# End of macro DMARK
af5a						CALLMONITOR 
af5a cd 6f ee			call debug_vector  
af5d				endm  
# End of macro CALLMONITOR
af5d					endif 
af5d					FORTH_DSP_POP 
af5d cd 0b 9d			call macro_forth_dsp_pop 
af60				endm 
# End of macro FORTH_DSP_POP
af60			 
af60					if DEBUG_FORTH_WORDS 
af60						DMARK "DO5" 
af60 f5				push af  
af61 3a 75 af			ld a, (.dmark)  
af64 32 6b ee			ld (debug_mark),a  
af67 3a 76 af			ld a, (.dmark+1)  
af6a 32 6c ee			ld (debug_mark+1),a  
af6d 3a 77 af			ld a, (.dmark+2)  
af70 32 6d ee			ld (debug_mark+2),a  
af73 18 03			jr .pastdmark  
af75 ..			.dmark: db "DO5"  
af78 f1			.pastdmark: pop af  
af79			endm  
# End of macro DMARK
af79						CALLMONITOR 
af79 cd 6f ee			call debug_vector  
af7c				endm  
# End of macro CALLMONITOR
af7c					endif 
af7c			 
af7c					FORTH_DSP_VALUEHL 
af7c cd 53 9c			call macro_dsp_valuehl 
af7f				endm 
# End of macro FORTH_DSP_VALUEHL
af7f			;		push hl		 ; hl now has starting limit counter 
af7f			 
af7f					if DEBUG_FORTH_WORDS 
af7f						DMARK "DO6" 
af7f f5				push af  
af80 3a 94 af			ld a, (.dmark)  
af83 32 6b ee			ld (debug_mark),a  
af86 3a 95 af			ld a, (.dmark+1)  
af89 32 6c ee			ld (debug_mark+1),a  
af8c 3a 96 af			ld a, (.dmark+2)  
af8f 32 6d ee			ld (debug_mark+2),a  
af92 18 03			jr .pastdmark  
af94 ..			.dmark: db "DO6"  
af97 f1			.pastdmark: pop af  
af98			endm  
# End of macro DMARK
af98						CALLMONITOR 
af98 cd 6f ee			call debug_vector  
af9b				endm  
# End of macro CALLMONITOR
af9b					endif 
af9b					FORTH_DSP_POP 
af9b cd 0b 9d			call macro_forth_dsp_pop 
af9e				endm 
# End of macro FORTH_DSP_POP
af9e			 
af9e			; put counters on the loop stack 
af9e			 
af9e			;		pop hl			 ; limit counter 
af9e d1					pop de			; start counter 
af9f			 
af9f					; push limit counter 
af9f			 
af9f					if DEBUG_FORTH_WORDS 
af9f						DMARK "DO7" 
af9f f5				push af  
afa0 3a b4 af			ld a, (.dmark)  
afa3 32 6b ee			ld (debug_mark),a  
afa6 3a b5 af			ld a, (.dmark+1)  
afa9 32 6c ee			ld (debug_mark+1),a  
afac 3a b6 af			ld a, (.dmark+2)  
afaf 32 6d ee			ld (debug_mark+2),a  
afb2 18 03			jr .pastdmark  
afb4 ..			.dmark: db "DO7"  
afb7 f1			.pastdmark: pop af  
afb8			endm  
# End of macro DMARK
afb8						CALLMONITOR 
afb8 cd 6f ee			call debug_vector  
afbb				endm  
# End of macro CALLMONITOR
afbb					endif 
afbb					FORTH_LOOP_NEXT 
afbb cd 84 9c			call macro_forth_loop_next 
afbe				endm 
# End of macro FORTH_LOOP_NEXT
afbe			 
afbe					; push start counter 
afbe			 
afbe eb					ex de, hl 
afbf					if DEBUG_FORTH_WORDS 
afbf						DMARK "DO7" 
afbf f5				push af  
afc0 3a d4 af			ld a, (.dmark)  
afc3 32 6b ee			ld (debug_mark),a  
afc6 3a d5 af			ld a, (.dmark+1)  
afc9 32 6c ee			ld (debug_mark+1),a  
afcc 3a d6 af			ld a, (.dmark+2)  
afcf 32 6d ee			ld (debug_mark+2),a  
afd2 18 03			jr .pastdmark  
afd4 ..			.dmark: db "DO7"  
afd7 f1			.pastdmark: pop af  
afd8			endm  
# End of macro DMARK
afd8						CALLMONITOR 
afd8 cd 6f ee			call debug_vector  
afdb				endm  
# End of macro CALLMONITOR
afdb					endif 
afdb					FORTH_LOOP_NEXT 
afdb cd 84 9c			call macro_forth_loop_next 
afde				endm 
# End of macro FORTH_LOOP_NEXT
afde			 
afde			 
afde					; init first round of I counter 
afde			 
afde 22 e6 e5				ld (os_current_i), hl 
afe1			 
afe1					if DEBUG_FORTH_WORDS 
afe1						DMARK "DO8" 
afe1 f5				push af  
afe2 3a f6 af			ld a, (.dmark)  
afe5 32 6b ee			ld (debug_mark),a  
afe8 3a f7 af			ld a, (.dmark+1)  
afeb 32 6c ee			ld (debug_mark+1),a  
afee 3a f8 af			ld a, (.dmark+2)  
aff1 32 6d ee			ld (debug_mark+2),a  
aff4 18 03			jr .pastdmark  
aff6 ..			.dmark: db "DO8"  
aff9 f1			.pastdmark: pop af  
affa			endm  
# End of macro DMARK
affa						CALLMONITOR 
affa cd 6f ee			call debug_vector  
affd				endm  
# End of macro CALLMONITOR
affd					endif 
affd			 
affd					NEXTW 
affd c3 09 9e			jp macro_next 
b000				endm 
# End of macro NEXTW
b000			.LOOP: 
b000				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b000 22				db WORD_SYS_CORE+14             
b001 18 b1			dw .I            
b003 05				db 4 + 1 
b004 .. 00			db "LOOP",0              
b009				endm 
# End of macro CWHEAD
b009			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b009			 
b009				; pop tos as current loop count to hl 
b009			 
b009				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b009			 
b009				FORTH_LOOP_TOS 
b009 cd b7 9c			call macro_forth_loop_tos 
b00c				endm 
# End of macro FORTH_LOOP_TOS
b00c e5				push hl 
b00d			 
b00d					if DEBUG_FORTH_WORDS_KEY 
b00d						DMARK "LOP" 
b00d f5				push af  
b00e 3a 22 b0			ld a, (.dmark)  
b011 32 6b ee			ld (debug_mark),a  
b014 3a 23 b0			ld a, (.dmark+1)  
b017 32 6c ee			ld (debug_mark+1),a  
b01a 3a 24 b0			ld a, (.dmark+2)  
b01d 32 6d ee			ld (debug_mark+2),a  
b020 18 03			jr .pastdmark  
b022 ..			.dmark: db "LOP"  
b025 f1			.pastdmark: pop af  
b026			endm  
# End of macro DMARK
b026						CALLMONITOR 
b026 cd 6f ee			call debug_vector  
b029				endm  
# End of macro CALLMONITOR
b029					endif 
b029				; next item on the stack is the limit. get it 
b029			 
b029			 
b029				FORTH_LOOP_POP 
b029 cd c1 9c			call macro_forth_loop_pop 
b02c				endm 
# End of macro FORTH_LOOP_POP
b02c			 
b02c				FORTH_LOOP_TOS 
b02c cd b7 9c			call macro_forth_loop_tos 
b02f				endm 
# End of macro FORTH_LOOP_TOS
b02f			 
b02f d1				pop de		 ; de = i, hl = limit 
b030			 
b030					if DEBUG_FORTH_WORDS 
b030						DMARK "LP1" 
b030 f5				push af  
b031 3a 45 b0			ld a, (.dmark)  
b034 32 6b ee			ld (debug_mark),a  
b037 3a 46 b0			ld a, (.dmark+1)  
b03a 32 6c ee			ld (debug_mark+1),a  
b03d 3a 47 b0			ld a, (.dmark+2)  
b040 32 6d ee			ld (debug_mark+2),a  
b043 18 03			jr .pastdmark  
b045 ..			.dmark: db "LP1"  
b048 f1			.pastdmark: pop af  
b049			endm  
# End of macro DMARK
b049						CALLMONITOR 
b049 cd 6f ee			call debug_vector  
b04c				endm  
# End of macro CALLMONITOR
b04c					endif 
b04c			 
b04c				; go back to previous word 
b04c			 
b04c d5				push de    ; save I for inc later 
b04d			 
b04d			 
b04d				; get limit 
b04d				;  is I at limit? 
b04d			 
b04d			 
b04d					if DEBUG_FORTH_WORDS 
b04d						DMARK "LP1" 
b04d f5				push af  
b04e 3a 62 b0			ld a, (.dmark)  
b051 32 6b ee			ld (debug_mark),a  
b054 3a 63 b0			ld a, (.dmark+1)  
b057 32 6c ee			ld (debug_mark+1),a  
b05a 3a 64 b0			ld a, (.dmark+2)  
b05d 32 6d ee			ld (debug_mark+2),a  
b060 18 03			jr .pastdmark  
b062 ..			.dmark: db "LP1"  
b065 f1			.pastdmark: pop af  
b066			endm  
# End of macro DMARK
b066						CALLMONITOR 
b066 cd 6f ee			call debug_vector  
b069				endm  
# End of macro CALLMONITOR
b069					endif 
b069			 
b069 ed 52			sbc hl, de 
b06b			 
b06b			 
b06b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b06b			 
b06b 20 26				jr nz, .loopnotdone 
b06d			 
b06d e1				pop hl   ; get rid of saved I 
b06e				FORTH_LOOP_POP     ; get rid of limit 
b06e cd c1 9c			call macro_forth_loop_pop 
b071				endm 
# End of macro FORTH_LOOP_POP
b071			 
b071				FORTH_RSP_POP     ; get rid of DO ptr 
b071 cd 24 9a			call macro_forth_rsp_pop 
b074				endm 
# End of macro FORTH_RSP_POP
b074			 
b074			if DEBUG_FORTH_WORDS 
b074						DMARK "LP>" 
b074 f5				push af  
b075 3a 89 b0			ld a, (.dmark)  
b078 32 6b ee			ld (debug_mark),a  
b07b 3a 8a b0			ld a, (.dmark+1)  
b07e 32 6c ee			ld (debug_mark+1),a  
b081 3a 8b b0			ld a, (.dmark+2)  
b084 32 6d ee			ld (debug_mark+2),a  
b087 18 03			jr .pastdmark  
b089 ..			.dmark: db "LP>"  
b08c f1			.pastdmark: pop af  
b08d			endm  
# End of macro DMARK
b08d				CALLMONITOR 
b08d cd 6f ee			call debug_vector  
b090				endm  
# End of macro CALLMONITOR
b090			endif 
b090			 
b090					NEXTW 
b090 c3 09 9e			jp macro_next 
b093				endm 
# End of macro NEXTW
b093				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b093			 
b093			.loopnotdone: 
b093			 
b093 e1				pop hl    ; get I 
b094 23				inc hl 
b095			 
b095			   	; save new I 
b095			 
b095			 
b095					; set I counter 
b095			 
b095 22 e6 e5				ld (os_current_i), hl 
b098			 
b098					if DEBUG_FORTH_WORDS 
b098						DMARK "LPN" 
b098 f5				push af  
b099 3a ad b0			ld a, (.dmark)  
b09c 32 6b ee			ld (debug_mark),a  
b09f 3a ae b0			ld a, (.dmark+1)  
b0a2 32 6c ee			ld (debug_mark+1),a  
b0a5 3a af b0			ld a, (.dmark+2)  
b0a8 32 6d ee			ld (debug_mark+2),a  
b0ab 18 03			jr .pastdmark  
b0ad ..			.dmark: db "LPN"  
b0b0 f1			.pastdmark: pop af  
b0b1			endm  
# End of macro DMARK
b0b1					CALLMONITOR 
b0b1 cd 6f ee			call debug_vector  
b0b4				endm  
# End of macro CALLMONITOR
b0b4					endif 
b0b4					 
b0b4				FORTH_LOOP_NEXT 
b0b4 cd 84 9c			call macro_forth_loop_next 
b0b7				endm 
# End of macro FORTH_LOOP_NEXT
b0b7			 
b0b7			 
b0b7					if DEBUG_FORTH_WORDS 
b0b7 eb						ex de,hl 
b0b8					endif 
b0b8			 
b0b8			;	; get DO ptr 
b0b8			; 
b0b8					if DEBUG_FORTH_WORDS 
b0b8						DMARK "LP7" 
b0b8 f5				push af  
b0b9 3a cd b0			ld a, (.dmark)  
b0bc 32 6b ee			ld (debug_mark),a  
b0bf 3a ce b0			ld a, (.dmark+1)  
b0c2 32 6c ee			ld (debug_mark+1),a  
b0c5 3a cf b0			ld a, (.dmark+2)  
b0c8 32 6d ee			ld (debug_mark+2),a  
b0cb 18 03			jr .pastdmark  
b0cd ..			.dmark: db "LP7"  
b0d0 f1			.pastdmark: pop af  
b0d1			endm  
# End of macro DMARK
b0d1					CALLMONITOR 
b0d1 cd 6f ee			call debug_vector  
b0d4				endm  
# End of macro CALLMONITOR
b0d4					endif 
b0d4				FORTH_RSP_TOS 
b0d4 cd 1a 9a			call macro_forth_rsp_tos 
b0d7				endm 
# End of macro FORTH_RSP_TOS
b0d7			 
b0d7					if DEBUG_FORTH_WORDS 
b0d7						DMARK "LP8" 
b0d7 f5				push af  
b0d8 3a ec b0			ld a, (.dmark)  
b0db 32 6b ee			ld (debug_mark),a  
b0de 3a ed b0			ld a, (.dmark+1)  
b0e1 32 6c ee			ld (debug_mark+1),a  
b0e4 3a ee b0			ld a, (.dmark+2)  
b0e7 32 6d ee			ld (debug_mark+2),a  
b0ea 18 03			jr .pastdmark  
b0ec ..			.dmark: db "LP8"  
b0ef f1			.pastdmark: pop af  
b0f0			endm  
# End of macro DMARK
b0f0					CALLMONITOR 
b0f0 cd 6f ee			call debug_vector  
b0f3				endm  
# End of macro CALLMONITOR
b0f3					endif 
b0f3				;push hl 
b0f3			 
b0f3				; not going to DO any more 
b0f3				; get rid of the RSP pointer as DO will add it back in 
b0f3				;FORTH_RSP_POP 
b0f3				;pop hl 
b0f3			 
b0f3				;ld hl,(cli_ret_sp) 
b0f3				;ld e, (hl) 
b0f3				;inc hl 
b0f3				;ld d, (hl) 
b0f3				;ex de,hl 
b0f3 22 c2 e5			ld (os_tok_ptr), hl 
b0f6					if DEBUG_FORTH_WORDS 
b0f6						DMARK "LP<" 
b0f6 f5				push af  
b0f7 3a 0b b1			ld a, (.dmark)  
b0fa 32 6b ee			ld (debug_mark),a  
b0fd 3a 0c b1			ld a, (.dmark+1)  
b100 32 6c ee			ld (debug_mark+1),a  
b103 3a 0d b1			ld a, (.dmark+2)  
b106 32 6d ee			ld (debug_mark+2),a  
b109 18 03			jr .pastdmark  
b10b ..			.dmark: db "LP<"  
b10e f1			.pastdmark: pop af  
b10f			endm  
# End of macro DMARK
b10f					CALLMONITOR 
b10f cd 6f ee			call debug_vector  
b112				endm  
# End of macro CALLMONITOR
b112				endif 
b112 c3 9a 9e			jp exec1 
b115			 
b115					 
b115			 
b115			 
b115					NEXTW 
b115 c3 09 9e			jp macro_next 
b118				endm 
# End of macro NEXTW
b118			.I:  
b118			 
b118				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b118 5e				db WORD_SYS_CORE+74             
b119 43 b1			dw .DLOOP            
b11b 02				db 1 + 1 
b11c .. 00			db "I",0              
b11e				endm 
# End of macro CWHEAD
b11e			; | I ( -- ) Current loop counter | DONE 
b11e					if DEBUG_FORTH_WORDS_KEY 
b11e						DMARK "I.." 
b11e f5				push af  
b11f 3a 33 b1			ld a, (.dmark)  
b122 32 6b ee			ld (debug_mark),a  
b125 3a 34 b1			ld a, (.dmark+1)  
b128 32 6c ee			ld (debug_mark+1),a  
b12b 3a 35 b1			ld a, (.dmark+2)  
b12e 32 6d ee			ld (debug_mark+2),a  
b131 18 03			jr .pastdmark  
b133 ..			.dmark: db "I.."  
b136 f1			.pastdmark: pop af  
b137			endm  
# End of macro DMARK
b137						CALLMONITOR 
b137 cd 6f ee			call debug_vector  
b13a				endm  
# End of macro CALLMONITOR
b13a					endif 
b13a			 
b13a 2a e6 e5				ld hl,(os_current_i) 
b13d cd 5c 9a				call forth_push_numhl 
b140			 
b140					NEXTW 
b140 c3 09 9e			jp macro_next 
b143				endm 
# End of macro NEXTW
b143			.DLOOP: 
b143				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b143 5f				db WORD_SYS_CORE+75             
b144 24 b2			dw .REPEAT            
b146 06				db 5 + 1 
b147 .. 00			db "-LOOP",0              
b14d				endm 
# End of macro CWHEAD
b14d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b14d				; pop tos as current loop count to hl 
b14d					if DEBUG_FORTH_WORDS_KEY 
b14d						DMARK "-LP" 
b14d f5				push af  
b14e 3a 62 b1			ld a, (.dmark)  
b151 32 6b ee			ld (debug_mark),a  
b154 3a 63 b1			ld a, (.dmark+1)  
b157 32 6c ee			ld (debug_mark+1),a  
b15a 3a 64 b1			ld a, (.dmark+2)  
b15d 32 6d ee			ld (debug_mark+2),a  
b160 18 03			jr .pastdmark  
b162 ..			.dmark: db "-LP"  
b165 f1			.pastdmark: pop af  
b166			endm  
# End of macro DMARK
b166						CALLMONITOR 
b166 cd 6f ee			call debug_vector  
b169				endm  
# End of macro CALLMONITOR
b169					endif 
b169			 
b169				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b169			 
b169				FORTH_LOOP_TOS 
b169 cd b7 9c			call macro_forth_loop_tos 
b16c				endm 
# End of macro FORTH_LOOP_TOS
b16c e5				push hl 
b16d			 
b16d					if DEBUG_FORTH_WORDS 
b16d						DMARK "-LP" 
b16d f5				push af  
b16e 3a 82 b1			ld a, (.dmark)  
b171 32 6b ee			ld (debug_mark),a  
b174 3a 83 b1			ld a, (.dmark+1)  
b177 32 6c ee			ld (debug_mark+1),a  
b17a 3a 84 b1			ld a, (.dmark+2)  
b17d 32 6d ee			ld (debug_mark+2),a  
b180 18 03			jr .pastdmark  
b182 ..			.dmark: db "-LP"  
b185 f1			.pastdmark: pop af  
b186			endm  
# End of macro DMARK
b186						CALLMONITOR 
b186 cd 6f ee			call debug_vector  
b189				endm  
# End of macro CALLMONITOR
b189					endif 
b189				; next item on the stack is the limit. get it 
b189			 
b189			 
b189				FORTH_LOOP_POP 
b189 cd c1 9c			call macro_forth_loop_pop 
b18c				endm 
# End of macro FORTH_LOOP_POP
b18c			 
b18c				FORTH_LOOP_TOS 
b18c cd b7 9c			call macro_forth_loop_tos 
b18f				endm 
# End of macro FORTH_LOOP_TOS
b18f			 
b18f d1				pop de		 ; de = i, hl = limit 
b190			 
b190					if DEBUG_FORTH_WORDS 
b190						DMARK "-L1" 
b190 f5				push af  
b191 3a a5 b1			ld a, (.dmark)  
b194 32 6b ee			ld (debug_mark),a  
b197 3a a6 b1			ld a, (.dmark+1)  
b19a 32 6c ee			ld (debug_mark+1),a  
b19d 3a a7 b1			ld a, (.dmark+2)  
b1a0 32 6d ee			ld (debug_mark+2),a  
b1a3 18 03			jr .pastdmark  
b1a5 ..			.dmark: db "-L1"  
b1a8 f1			.pastdmark: pop af  
b1a9			endm  
# End of macro DMARK
b1a9						CALLMONITOR 
b1a9 cd 6f ee			call debug_vector  
b1ac				endm  
# End of macro CALLMONITOR
b1ac					endif 
b1ac			 
b1ac				; go back to previous word 
b1ac			 
b1ac d5				push de    ; save I for inc later 
b1ad			 
b1ad			 
b1ad				; get limit 
b1ad				;  is I at limit? 
b1ad			 
b1ad			 
b1ad					if DEBUG_FORTH_WORDS 
b1ad						DMARK "-L1" 
b1ad f5				push af  
b1ae 3a c2 b1			ld a, (.dmark)  
b1b1 32 6b ee			ld (debug_mark),a  
b1b4 3a c3 b1			ld a, (.dmark+1)  
b1b7 32 6c ee			ld (debug_mark+1),a  
b1ba 3a c4 b1			ld a, (.dmark+2)  
b1bd 32 6d ee			ld (debug_mark+2),a  
b1c0 18 03			jr .pastdmark  
b1c2 ..			.dmark: db "-L1"  
b1c5 f1			.pastdmark: pop af  
b1c6			endm  
# End of macro DMARK
b1c6						CALLMONITOR 
b1c6 cd 6f ee			call debug_vector  
b1c9				endm  
# End of macro CALLMONITOR
b1c9					endif 
b1c9			 
b1c9 ed 52			sbc hl, de 
b1cb			 
b1cb			 
b1cb				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1cb			 
b1cb 20 26				jr nz, .mloopnotdone 
b1cd			 
b1cd e1				pop hl   ; get rid of saved I 
b1ce				FORTH_LOOP_POP     ; get rid of limit 
b1ce cd c1 9c			call macro_forth_loop_pop 
b1d1				endm 
# End of macro FORTH_LOOP_POP
b1d1			 
b1d1				FORTH_RSP_POP     ; get rid of DO ptr 
b1d1 cd 24 9a			call macro_forth_rsp_pop 
b1d4				endm 
# End of macro FORTH_RSP_POP
b1d4			 
b1d4			if DEBUG_FORTH_WORDS 
b1d4						DMARK "-L>" 
b1d4 f5				push af  
b1d5 3a e9 b1			ld a, (.dmark)  
b1d8 32 6b ee			ld (debug_mark),a  
b1db 3a ea b1			ld a, (.dmark+1)  
b1de 32 6c ee			ld (debug_mark+1),a  
b1e1 3a eb b1			ld a, (.dmark+2)  
b1e4 32 6d ee			ld (debug_mark+2),a  
b1e7 18 03			jr .pastdmark  
b1e9 ..			.dmark: db "-L>"  
b1ec f1			.pastdmark: pop af  
b1ed			endm  
# End of macro DMARK
b1ed				CALLMONITOR 
b1ed cd 6f ee			call debug_vector  
b1f0				endm  
# End of macro CALLMONITOR
b1f0			endif 
b1f0			 
b1f0					NEXTW 
b1f0 c3 09 9e			jp macro_next 
b1f3				endm 
# End of macro NEXTW
b1f3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b1f3			 
b1f3			.mloopnotdone: 
b1f3			 
b1f3 e1				pop hl    ; get I 
b1f4 2b				dec hl 
b1f5			 
b1f5			   	; save new I 
b1f5			 
b1f5			 
b1f5					; set I counter 
b1f5			 
b1f5 22 e6 e5				ld (os_current_i), hl 
b1f8			 
b1f8					 
b1f8				FORTH_LOOP_NEXT 
b1f8 cd 84 9c			call macro_forth_loop_next 
b1fb				endm 
# End of macro FORTH_LOOP_NEXT
b1fb			 
b1fb			 
b1fb					if DEBUG_FORTH_WORDS 
b1fb eb						ex de,hl 
b1fc					endif 
b1fc			 
b1fc			;	; get DO ptr 
b1fc			; 
b1fc				FORTH_RSP_TOS 
b1fc cd 1a 9a			call macro_forth_rsp_tos 
b1ff				endm 
# End of macro FORTH_RSP_TOS
b1ff			 
b1ff				;push hl 
b1ff			 
b1ff				; not going to DO any more 
b1ff				; get rid of the RSP pointer as DO will add it back in 
b1ff				;FORTH_RSP_POP 
b1ff				;pop hl 
b1ff			 
b1ff			 
b1ff 22 c2 e5			ld (os_tok_ptr), hl 
b202					if DEBUG_FORTH_WORDS 
b202						DMARK "-L<" 
b202 f5				push af  
b203 3a 17 b2			ld a, (.dmark)  
b206 32 6b ee			ld (debug_mark),a  
b209 3a 18 b2			ld a, (.dmark+1)  
b20c 32 6c ee			ld (debug_mark+1),a  
b20f 3a 19 b2			ld a, (.dmark+2)  
b212 32 6d ee			ld (debug_mark+2),a  
b215 18 03			jr .pastdmark  
b217 ..			.dmark: db "-L<"  
b21a f1			.pastdmark: pop af  
b21b			endm  
# End of macro DMARK
b21b					CALLMONITOR 
b21b cd 6f ee			call debug_vector  
b21e				endm  
# End of macro CALLMONITOR
b21e				endif 
b21e c3 9a 9e			jp exec1 
b221			 
b221					 
b221			 
b221			 
b221			 
b221				NEXTW 
b221 c3 09 9e			jp macro_next 
b224				endm 
# End of macro NEXTW
b224			 
b224			 
b224			 
b224			 
b224			.REPEAT: 
b224				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b224 71				db WORD_SYS_CORE+93             
b225 77 b2			dw .UNTIL            
b227 06				db 5 + 1 
b228 .. 00			db "REPEAT",0              
b22f				endm 
# End of macro CWHEAD
b22f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b22f			;  push pc to rsp stack past the REPEAT 
b22f					if DEBUG_FORTH_WORDS_KEY 
b22f						DMARK "REP" 
b22f f5				push af  
b230 3a 44 b2			ld a, (.dmark)  
b233 32 6b ee			ld (debug_mark),a  
b236 3a 45 b2			ld a, (.dmark+1)  
b239 32 6c ee			ld (debug_mark+1),a  
b23c 3a 46 b2			ld a, (.dmark+2)  
b23f 32 6d ee			ld (debug_mark+2),a  
b242 18 03			jr .pastdmark  
b244 ..			.dmark: db "REP"  
b247 f1			.pastdmark: pop af  
b248			endm  
# End of macro DMARK
b248						CALLMONITOR 
b248 cd 6f ee			call debug_vector  
b24b				endm  
# End of macro CALLMONITOR
b24b					endif 
b24b			 
b24b 2a c2 e5				ld hl, (os_tok_ptr) 
b24e 23					inc hl   ; R 
b24f 23					inc hl  ; E 
b250 23					inc hl   ; P 
b251 23					inc hl   ; E 
b252 23					inc hl   ; A 
b253 23					inc hl   ; T 
b254 23					inc hl   ; zero 
b255					FORTH_RSP_NEXT 
b255 cd 03 9a			call macro_forth_rsp_next 
b258				endm 
# End of macro FORTH_RSP_NEXT
b258			 
b258			 
b258					if DEBUG_FORTH_WORDS 
b258						DMARK "REP" 
b258 f5				push af  
b259 3a 6d b2			ld a, (.dmark)  
b25c 32 6b ee			ld (debug_mark),a  
b25f 3a 6e b2			ld a, (.dmark+1)  
b262 32 6c ee			ld (debug_mark+1),a  
b265 3a 6f b2			ld a, (.dmark+2)  
b268 32 6d ee			ld (debug_mark+2),a  
b26b 18 03			jr .pastdmark  
b26d ..			.dmark: db "REP"  
b270 f1			.pastdmark: pop af  
b271			endm  
# End of macro DMARK
b271						;pop bc    ; TODO BUG ?????? what is this for???? 
b271						CALLMONITOR 
b271 cd 6f ee			call debug_vector  
b274				endm  
# End of macro CALLMONITOR
b274					endif 
b274			 
b274					NEXTW 
b274 c3 09 9e			jp macro_next 
b277				endm 
# End of macro NEXTW
b277			;	       NEXTW 
b277			 
b277			.UNTIL: 
b277				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b277 72				db WORD_SYS_CORE+94             
b278 0e b3			dw .ENDFLOW            
b27a 06				db 5 + 1 
b27b .. 00			db "UNTIL",0              
b281				endm 
# End of macro CWHEAD
b281			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b281			 
b281				; pop tos as check 
b281			 
b281				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b281			 
b281				FORTH_DSP_VALUEHL 
b281 cd 53 9c			call macro_dsp_valuehl 
b284				endm 
# End of macro FORTH_DSP_VALUEHL
b284			 
b284					if DEBUG_FORTH_WORDS_KEY 
b284						DMARK "UNT" 
b284 f5				push af  
b285 3a 99 b2			ld a, (.dmark)  
b288 32 6b ee			ld (debug_mark),a  
b28b 3a 9a b2			ld a, (.dmark+1)  
b28e 32 6c ee			ld (debug_mark+1),a  
b291 3a 9b b2			ld a, (.dmark+2)  
b294 32 6d ee			ld (debug_mark+2),a  
b297 18 03			jr .pastdmark  
b299 ..			.dmark: db "UNT"  
b29c f1			.pastdmark: pop af  
b29d			endm  
# End of macro DMARK
b29d						CALLMONITOR 
b29d cd 6f ee			call debug_vector  
b2a0				endm  
# End of macro CALLMONITOR
b2a0					endif 
b2a0			 
b2a0			;	push hl 
b2a0				FORTH_DSP_POP 
b2a0 cd 0b 9d			call macro_forth_dsp_pop 
b2a3				endm 
# End of macro FORTH_DSP_POP
b2a3			 
b2a3			;	pop hl 
b2a3			 
b2a3				; test if true 
b2a3			 
b2a3 cd 04 8d			call ishlzero 
b2a6			;	ld a,l 
b2a6			;	add h 
b2a6			; 
b2a6			;	cp 0 
b2a6			 
b2a6 20 3e			jr nz, .untilnotdone 
b2a8			 
b2a8					if DEBUG_FORTH_WORDS 
b2a8						DMARK "UNf" 
b2a8 f5				push af  
b2a9 3a bd b2			ld a, (.dmark)  
b2ac 32 6b ee			ld (debug_mark),a  
b2af 3a be b2			ld a, (.dmark+1)  
b2b2 32 6c ee			ld (debug_mark+1),a  
b2b5 3a bf b2			ld a, (.dmark+2)  
b2b8 32 6d ee			ld (debug_mark+2),a  
b2bb 18 03			jr .pastdmark  
b2bd ..			.dmark: db "UNf"  
b2c0 f1			.pastdmark: pop af  
b2c1			endm  
# End of macro DMARK
b2c1						CALLMONITOR 
b2c1 cd 6f ee			call debug_vector  
b2c4				endm  
# End of macro CALLMONITOR
b2c4					endif 
b2c4			 
b2c4			 
b2c4			 
b2c4				FORTH_RSP_POP     ; get rid of DO ptr 
b2c4 cd 24 9a			call macro_forth_rsp_pop 
b2c7				endm 
# End of macro FORTH_RSP_POP
b2c7			 
b2c7			if DEBUG_FORTH_WORDS 
b2c7						DMARK "UN>" 
b2c7 f5				push af  
b2c8 3a dc b2			ld a, (.dmark)  
b2cb 32 6b ee			ld (debug_mark),a  
b2ce 3a dd b2			ld a, (.dmark+1)  
b2d1 32 6c ee			ld (debug_mark+1),a  
b2d4 3a de b2			ld a, (.dmark+2)  
b2d7 32 6d ee			ld (debug_mark+2),a  
b2da 18 03			jr .pastdmark  
b2dc ..			.dmark: db "UN>"  
b2df f1			.pastdmark: pop af  
b2e0			endm  
# End of macro DMARK
b2e0				CALLMONITOR 
b2e0 cd 6f ee			call debug_vector  
b2e3				endm  
# End of macro CALLMONITOR
b2e3			endif 
b2e3			 
b2e3					NEXTW 
b2e3 c3 09 9e			jp macro_next 
b2e6				endm 
# End of macro NEXTW
b2e6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2e6			 
b2e6			.untilnotdone: 
b2e6			 
b2e6			 
b2e6			;	; get DO ptr 
b2e6			; 
b2e6				FORTH_RSP_TOS 
b2e6 cd 1a 9a			call macro_forth_rsp_tos 
b2e9				endm 
# End of macro FORTH_RSP_TOS
b2e9			 
b2e9				;push hl 
b2e9			 
b2e9				; not going to DO any more 
b2e9				; get rid of the RSP pointer as DO will add it back in 
b2e9				;FORTH_RSP_POP 
b2e9				;pop hl 
b2e9			 
b2e9			 
b2e9 22 c2 e5			ld (os_tok_ptr), hl 
b2ec					if DEBUG_FORTH_WORDS 
b2ec						DMARK "UN<" 
b2ec f5				push af  
b2ed 3a 01 b3			ld a, (.dmark)  
b2f0 32 6b ee			ld (debug_mark),a  
b2f3 3a 02 b3			ld a, (.dmark+1)  
b2f6 32 6c ee			ld (debug_mark+1),a  
b2f9 3a 03 b3			ld a, (.dmark+2)  
b2fc 32 6d ee			ld (debug_mark+2),a  
b2ff 18 03			jr .pastdmark  
b301 ..			.dmark: db "UN<"  
b304 f1			.pastdmark: pop af  
b305			endm  
# End of macro DMARK
b305					CALLMONITOR 
b305 cd 6f ee			call debug_vector  
b308				endm  
# End of macro CALLMONITOR
b308				endif 
b308 c3 9a 9e			jp exec1 
b30b			 
b30b					 
b30b			 
b30b			 
b30b					NEXTW 
b30b c3 09 9e			jp macro_next 
b30e				endm 
# End of macro NEXTW
b30e			 
b30e			 
b30e			.ENDFLOW: 
b30e			 
b30e			; eof 
b30e			 
# End of file forth_words_flow.asm
b30e			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b30e			include "forth_words_logic.asm" 
b30e			 
b30e			; | ## Logic Words 
b30e			 
b30e			.NOT: 
b30e				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b30e 2d				db WORD_SYS_CORE+25             
b30f 56 b3			dw .IS            
b311 04				db 3 + 1 
b312 .. 00			db "NOT",0              
b316				endm 
# End of macro CWHEAD
b316			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b316					if DEBUG_FORTH_WORDS_KEY 
b316						DMARK "NOT" 
b316 f5				push af  
b317 3a 2b b3			ld a, (.dmark)  
b31a 32 6b ee			ld (debug_mark),a  
b31d 3a 2c b3			ld a, (.dmark+1)  
b320 32 6c ee			ld (debug_mark+1),a  
b323 3a 2d b3			ld a, (.dmark+2)  
b326 32 6d ee			ld (debug_mark+2),a  
b329 18 03			jr .pastdmark  
b32b ..			.dmark: db "NOT"  
b32e f1			.pastdmark: pop af  
b32f			endm  
# End of macro DMARK
b32f						CALLMONITOR 
b32f cd 6f ee			call debug_vector  
b332				endm  
# End of macro CALLMONITOR
b332					endif 
b332					FORTH_DSP 
b332 cd 19 9c			call macro_forth_dsp 
b335				endm 
# End of macro FORTH_DSP
b335 7e					ld a,(hl)	; get type of value on TOS 
b336 fe 02				cp DS_TYPE_INUM  
b338 28 03				jr z, .noti 
b33a					NEXTW 
b33a c3 09 9e			jp macro_next 
b33d				endm 
# End of macro NEXTW
b33d			.noti:          FORTH_DSP_VALUEHL 
b33d cd 53 9c			call macro_dsp_valuehl 
b340				endm 
# End of macro FORTH_DSP_VALUEHL
b340			;		push hl 
b340					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b340 cd 0b 9d			call macro_forth_dsp_pop 
b343				endm 
# End of macro FORTH_DSP_POP
b343			;		pop hl 
b343 3e 00				ld a,0 
b345 bd					cp l 
b346 28 04				jr z, .not2t 
b348 2e 00				ld l, 0 
b34a 18 02				jr .notip 
b34c			 
b34c 2e ff		.not2t:		ld l, 255 
b34e			 
b34e 26 00		.notip:		ld h, 0	 
b350			 
b350 cd 5c 9a				call forth_push_numhl 
b353					NEXTW 
b353 c3 09 9e			jp macro_next 
b356				endm 
# End of macro NEXTW
b356			 
b356			.IS: 
b356				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b356 2d				db WORD_SYS_CORE+25             
b357 7c b3			dw .LZERO            
b359 03				db 2 + 1 
b35a .. 00			db "IS",0              
b35d				endm 
# End of macro CWHEAD
b35d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b35d					if DEBUG_FORTH_WORDS_KEY 
b35d						DMARK "IS." 
b35d f5				push af  
b35e 3a 72 b3			ld a, (.dmark)  
b361 32 6b ee			ld (debug_mark),a  
b364 3a 73 b3			ld a, (.dmark+1)  
b367 32 6c ee			ld (debug_mark+1),a  
b36a 3a 74 b3			ld a, (.dmark+2)  
b36d 32 6d ee			ld (debug_mark+2),a  
b370 18 03			jr .pastdmark  
b372 ..			.dmark: db "IS."  
b375 f1			.pastdmark: pop af  
b376			endm  
# End of macro DMARK
b376						CALLMONITOR 
b376 cd 6f ee			call debug_vector  
b379				endm  
# End of macro CALLMONITOR
b379					endif 
b379					NEXTW 
b379 c3 09 9e			jp macro_next 
b37c				endm 
# End of macro NEXTW
b37c			.LZERO: 
b37c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b37c 2d				db WORD_SYS_CORE+25             
b37d 86 b3			dw .TZERO            
b37f 03				db 2 + 1 
b380 .. 00			db "0<",0              
b383				endm 
# End of macro CWHEAD
b383			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b383					NEXTW 
b383 c3 09 9e			jp macro_next 
b386				endm 
# End of macro NEXTW
b386			.TZERO: 
b386				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b386 2e				db WORD_SYS_CORE+26             
b387 cd b3			dw .LESS            
b389 03				db 2 + 1 
b38a .. 00			db "0=",0              
b38d				endm 
# End of macro CWHEAD
b38d			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b38d				; TODO add floating point number detection 
b38d					;v5 FORTH_DSP_VALUE 
b38d					if DEBUG_FORTH_WORDS_KEY 
b38d						DMARK "0=." 
b38d f5				push af  
b38e 3a a2 b3			ld a, (.dmark)  
b391 32 6b ee			ld (debug_mark),a  
b394 3a a3 b3			ld a, (.dmark+1)  
b397 32 6c ee			ld (debug_mark+1),a  
b39a 3a a4 b3			ld a, (.dmark+2)  
b39d 32 6d ee			ld (debug_mark+2),a  
b3a0 18 03			jr .pastdmark  
b3a2 ..			.dmark: db "0=."  
b3a5 f1			.pastdmark: pop af  
b3a6			endm  
# End of macro DMARK
b3a6						CALLMONITOR 
b3a6 cd 6f ee			call debug_vector  
b3a9				endm  
# End of macro CALLMONITOR
b3a9					endif 
b3a9					FORTH_DSP 
b3a9 cd 19 9c			call macro_forth_dsp 
b3ac				endm 
# End of macro FORTH_DSP
b3ac 7e					ld a,(hl)	; get type of value on TOS 
b3ad fe 02				cp DS_TYPE_INUM  
b3af 28 00				jr z, .tz_inum 
b3b1			 
b3b1				if FORTH_ENABLE_FLOATMATH 
b3b1					jr .tz_done 
b3b1			 
b3b1				endif 
b3b1					 
b3b1			 
b3b1			.tz_inum: 
b3b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b1 cd 53 9c			call macro_dsp_valuehl 
b3b4				endm 
# End of macro FORTH_DSP_VALUEHL
b3b4			 
b3b4			;		push hl 
b3b4			 
b3b4					; destroy value TOS 
b3b4			 
b3b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b4 cd 0b 9d			call macro_forth_dsp_pop 
b3b7				endm 
# End of macro FORTH_DSP_POP
b3b7			 
b3b7			;		pop hl 
b3b7			 
b3b7 3e 00				ld a,0 
b3b9			 
b3b9 bd					cp l 
b3ba 20 08				jr nz, .tz_notzero 
b3bc			 
b3bc bc					cp h 
b3bd			 
b3bd 20 05				jr nz, .tz_notzero 
b3bf			 
b3bf			 
b3bf 21 01 00				ld hl, FORTH_TRUE 
b3c2 18 03				jr .tz_done 
b3c4			 
b3c4 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3c7			 
b3c7					; push value back onto stack for another op etc 
b3c7			 
b3c7			.tz_done: 
b3c7 cd 5c 9a				call forth_push_numhl 
b3ca			 
b3ca					NEXTW 
b3ca c3 09 9e			jp macro_next 
b3cd				endm 
# End of macro NEXTW
b3cd			.LESS: 
b3cd				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3cd 2f				db WORD_SYS_CORE+27             
b3ce 36 b4			dw .GT            
b3d0 02				db 1 + 1 
b3d1 .. 00			db "<",0              
b3d3				endm 
# End of macro CWHEAD
b3d3			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3d3				; TODO add floating point number detection 
b3d3					if DEBUG_FORTH_WORDS_KEY 
b3d3						DMARK "LES" 
b3d3 f5				push af  
b3d4 3a e8 b3			ld a, (.dmark)  
b3d7 32 6b ee			ld (debug_mark),a  
b3da 3a e9 b3			ld a, (.dmark+1)  
b3dd 32 6c ee			ld (debug_mark+1),a  
b3e0 3a ea b3			ld a, (.dmark+2)  
b3e3 32 6d ee			ld (debug_mark+2),a  
b3e6 18 03			jr .pastdmark  
b3e8 ..			.dmark: db "LES"  
b3eb f1			.pastdmark: pop af  
b3ec			endm  
# End of macro DMARK
b3ec						CALLMONITOR 
b3ec cd 6f ee			call debug_vector  
b3ef				endm  
# End of macro CALLMONITOR
b3ef					endif 
b3ef					FORTH_DSP 
b3ef cd 19 9c			call macro_forth_dsp 
b3f2				endm 
# End of macro FORTH_DSP
b3f2					;v5 FORTH_DSP_VALUE 
b3f2 7e					ld a,(hl)	; get type of value on TOS 
b3f3 fe 02				cp DS_TYPE_INUM  
b3f5 28 00				jr z, .less_inum 
b3f7			 
b3f7				if FORTH_ENABLE_FLOATMATH 
b3f7					jr .less_done 
b3f7			 
b3f7				endif 
b3f7					 
b3f7			 
b3f7			.less_inum: 
b3f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f7 cd 53 9c			call macro_dsp_valuehl 
b3fa				endm 
# End of macro FORTH_DSP_VALUEHL
b3fa			 
b3fa e5					push hl  ; u2 
b3fb			 
b3fb					; destroy value TOS 
b3fb			 
b3fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fb cd 0b 9d			call macro_forth_dsp_pop 
b3fe				endm 
# End of macro FORTH_DSP_POP
b3fe			 
b3fe			 
b3fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fe cd 53 9c			call macro_dsp_valuehl 
b401				endm 
# End of macro FORTH_DSP_VALUEHL
b401			 
b401 e5					push hl    ; u1 
b402			 
b402					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b402 cd 0b 9d			call macro_forth_dsp_pop 
b405				endm 
# End of macro FORTH_DSP_POP
b405			 
b405			 
b405 b7			 or a      ;clear carry flag 
b406 01 00 00		 ld bc, FORTH_FALSE 
b409 e1			  pop hl    ; u1 
b40a d1			  pop de    ; u2 
b40b ed 52		  sbc hl,de 
b40d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b40f			 
b40f 01 01 00		 ld bc, FORTH_TRUE 
b412			.lscont:  
b412 c5					push bc 
b413 e1					pop hl 
b414			 
b414					if DEBUG_FORTH_WORDS 
b414						DMARK "LT1" 
b414 f5				push af  
b415 3a 29 b4			ld a, (.dmark)  
b418 32 6b ee			ld (debug_mark),a  
b41b 3a 2a b4			ld a, (.dmark+1)  
b41e 32 6c ee			ld (debug_mark+1),a  
b421 3a 2b b4			ld a, (.dmark+2)  
b424 32 6d ee			ld (debug_mark+2),a  
b427 18 03			jr .pastdmark  
b429 ..			.dmark: db "LT1"  
b42c f1			.pastdmark: pop af  
b42d			endm  
# End of macro DMARK
b42d						CALLMONITOR 
b42d cd 6f ee			call debug_vector  
b430				endm  
# End of macro CALLMONITOR
b430					endif 
b430 cd 5c 9a				call forth_push_numhl 
b433			 
b433					NEXTW 
b433 c3 09 9e			jp macro_next 
b436				endm 
# End of macro NEXTW
b436			.GT: 
b436				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b436 30				db WORD_SYS_CORE+28             
b437 9f b4			dw .EQUAL            
b439 02				db 1 + 1 
b43a .. 00			db ">",0              
b43c				endm 
# End of macro CWHEAD
b43c			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b43c				; TODO add floating point number detection 
b43c					if DEBUG_FORTH_WORDS_KEY 
b43c						DMARK "GRT" 
b43c f5				push af  
b43d 3a 51 b4			ld a, (.dmark)  
b440 32 6b ee			ld (debug_mark),a  
b443 3a 52 b4			ld a, (.dmark+1)  
b446 32 6c ee			ld (debug_mark+1),a  
b449 3a 53 b4			ld a, (.dmark+2)  
b44c 32 6d ee			ld (debug_mark+2),a  
b44f 18 03			jr .pastdmark  
b451 ..			.dmark: db "GRT"  
b454 f1			.pastdmark: pop af  
b455			endm  
# End of macro DMARK
b455						CALLMONITOR 
b455 cd 6f ee			call debug_vector  
b458				endm  
# End of macro CALLMONITOR
b458					endif 
b458					FORTH_DSP 
b458 cd 19 9c			call macro_forth_dsp 
b45b				endm 
# End of macro FORTH_DSP
b45b					;FORTH_DSP_VALUE 
b45b 7e					ld a,(hl)	; get type of value on TOS 
b45c fe 02				cp DS_TYPE_INUM  
b45e 28 00				jr z, .gt_inum 
b460			 
b460				if FORTH_ENABLE_FLOATMATH 
b460					jr .gt_done 
b460			 
b460				endif 
b460					 
b460			 
b460			.gt_inum: 
b460					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b460 cd 53 9c			call macro_dsp_valuehl 
b463				endm 
# End of macro FORTH_DSP_VALUEHL
b463			 
b463 e5					push hl  ; u2 
b464			 
b464					; destroy value TOS 
b464			 
b464					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b464 cd 0b 9d			call macro_forth_dsp_pop 
b467				endm 
# End of macro FORTH_DSP_POP
b467			 
b467			 
b467					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b467 cd 53 9c			call macro_dsp_valuehl 
b46a				endm 
# End of macro FORTH_DSP_VALUEHL
b46a			 
b46a e5					push hl    ; u1 
b46b			 
b46b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b46b cd 0b 9d			call macro_forth_dsp_pop 
b46e				endm 
# End of macro FORTH_DSP_POP
b46e			 
b46e			 
b46e b7			 or a      ;clear carry flag 
b46f 01 00 00		 ld bc, FORTH_FALSE 
b472 e1			  pop hl    ; u1 
b473 d1			  pop de    ; u2 
b474 ed 52		  sbc hl,de 
b476 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b478			 
b478 01 01 00		 ld bc, FORTH_TRUE 
b47b			.gtcont:  
b47b c5					push bc 
b47c e1					pop hl 
b47d			 
b47d					if DEBUG_FORTH_WORDS 
b47d						DMARK "GT1" 
b47d f5				push af  
b47e 3a 92 b4			ld a, (.dmark)  
b481 32 6b ee			ld (debug_mark),a  
b484 3a 93 b4			ld a, (.dmark+1)  
b487 32 6c ee			ld (debug_mark+1),a  
b48a 3a 94 b4			ld a, (.dmark+2)  
b48d 32 6d ee			ld (debug_mark+2),a  
b490 18 03			jr .pastdmark  
b492 ..			.dmark: db "GT1"  
b495 f1			.pastdmark: pop af  
b496			endm  
# End of macro DMARK
b496						CALLMONITOR 
b496 cd 6f ee			call debug_vector  
b499				endm  
# End of macro CALLMONITOR
b499					endif 
b499 cd 5c 9a				call forth_push_numhl 
b49c			 
b49c					NEXTW 
b49c c3 09 9e			jp macro_next 
b49f				endm 
# End of macro NEXTW
b49f			.EQUAL: 
b49f				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b49f 31				db WORD_SYS_CORE+29             
b4a0 0a b5			dw .ENDLOGIC            
b4a2 02				db 1 + 1 
b4a3 .. 00			db "=",0              
b4a5				endm 
# End of macro CWHEAD
b4a5			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4a5				; TODO add floating point number detection 
b4a5					if DEBUG_FORTH_WORDS_KEY 
b4a5						DMARK "EQ." 
b4a5 f5				push af  
b4a6 3a ba b4			ld a, (.dmark)  
b4a9 32 6b ee			ld (debug_mark),a  
b4ac 3a bb b4			ld a, (.dmark+1)  
b4af 32 6c ee			ld (debug_mark+1),a  
b4b2 3a bc b4			ld a, (.dmark+2)  
b4b5 32 6d ee			ld (debug_mark+2),a  
b4b8 18 03			jr .pastdmark  
b4ba ..			.dmark: db "EQ."  
b4bd f1			.pastdmark: pop af  
b4be			endm  
# End of macro DMARK
b4be						CALLMONITOR 
b4be cd 6f ee			call debug_vector  
b4c1				endm  
# End of macro CALLMONITOR
b4c1					endif 
b4c1					FORTH_DSP 
b4c1 cd 19 9c			call macro_forth_dsp 
b4c4				endm 
# End of macro FORTH_DSP
b4c4					;v5 FORTH_DSP_VALUE 
b4c4 7e					ld a,(hl)	; get type of value on TOS 
b4c5 fe 02				cp DS_TYPE_INUM  
b4c7 28 00				jr z, .eq_inum 
b4c9			 
b4c9				if FORTH_ENABLE_FLOATMATH 
b4c9					jr .eq_done 
b4c9			 
b4c9				endif 
b4c9					 
b4c9			 
b4c9			.eq_inum: 
b4c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4c9 cd 53 9c			call macro_dsp_valuehl 
b4cc				endm 
# End of macro FORTH_DSP_VALUEHL
b4cc			 
b4cc e5					push hl 
b4cd			 
b4cd					; destroy value TOS 
b4cd			 
b4cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4cd cd 0b 9d			call macro_forth_dsp_pop 
b4d0				endm 
# End of macro FORTH_DSP_POP
b4d0			 
b4d0			 
b4d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d0 cd 53 9c			call macro_dsp_valuehl 
b4d3				endm 
# End of macro FORTH_DSP_VALUEHL
b4d3			 
b4d3					; one value on hl get other one back 
b4d3			 
b4d3 e5					push hl 
b4d4			 
b4d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d4 cd 0b 9d			call macro_forth_dsp_pop 
b4d7				endm 
# End of macro FORTH_DSP_POP
b4d7			 
b4d7 0e 00				ld c, FORTH_FALSE 
b4d9			 
b4d9 e1					pop hl 
b4da d1					pop de 
b4db			 
b4db 7b					ld a, e 
b4dc bd					cp l 
b4dd			 
b4dd 20 06				jr nz, .eq_done 
b4df			 
b4df 7a					ld a, d 
b4e0 bc					cp h 
b4e1			 
b4e1 20 02				jr nz, .eq_done 
b4e3			 
b4e3 0e 01				ld c, FORTH_TRUE 
b4e5					 
b4e5			 
b4e5			 
b4e5			.eq_done: 
b4e5			 
b4e5					; TODO push value back onto stack for another op etc 
b4e5			 
b4e5 26 00				ld h, 0 
b4e7 69					ld l, c 
b4e8					if DEBUG_FORTH_WORDS 
b4e8						DMARK "EQ1" 
b4e8 f5				push af  
b4e9 3a fd b4			ld a, (.dmark)  
b4ec 32 6b ee			ld (debug_mark),a  
b4ef 3a fe b4			ld a, (.dmark+1)  
b4f2 32 6c ee			ld (debug_mark+1),a  
b4f5 3a ff b4			ld a, (.dmark+2)  
b4f8 32 6d ee			ld (debug_mark+2),a  
b4fb 18 03			jr .pastdmark  
b4fd ..			.dmark: db "EQ1"  
b500 f1			.pastdmark: pop af  
b501			endm  
# End of macro DMARK
b501						CALLMONITOR 
b501 cd 6f ee			call debug_vector  
b504				endm  
# End of macro CALLMONITOR
b504					endif 
b504 cd 5c 9a				call forth_push_numhl 
b507			 
b507					NEXTW 
b507 c3 09 9e			jp macro_next 
b50a				endm 
# End of macro NEXTW
b50a			 
b50a			 
b50a			.ENDLOGIC: 
b50a			; eof 
b50a			 
b50a			 
# End of file forth_words_logic.asm
b50a			include "forth_words_maths.asm" 
b50a			 
b50a			; | ## Maths Words 
b50a			 
b50a			.PLUS:	 
b50a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b50a 15				db WORD_SYS_CORE+1             
b50b 68 b5			dw .NEG            
b50d 02				db 1 + 1 
b50e .. 00			db "+",0              
b510				endm 
# End of macro CWHEAD
b510			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b510					if DEBUG_FORTH_WORDS_KEY 
b510						DMARK "PLU" 
b510 f5				push af  
b511 3a 25 b5			ld a, (.dmark)  
b514 32 6b ee			ld (debug_mark),a  
b517 3a 26 b5			ld a, (.dmark+1)  
b51a 32 6c ee			ld (debug_mark+1),a  
b51d 3a 27 b5			ld a, (.dmark+2)  
b520 32 6d ee			ld (debug_mark+2),a  
b523 18 03			jr .pastdmark  
b525 ..			.dmark: db "PLU"  
b528 f1			.pastdmark: pop af  
b529			endm  
# End of macro DMARK
b529						CALLMONITOR 
b529 cd 6f ee			call debug_vector  
b52c				endm  
# End of macro CALLMONITOR
b52c					endif 
b52c					; add top two values and push back result 
b52c			 
b52c					;for v5 FORTH_DSP_VALUE 
b52c					FORTH_DSP 
b52c cd 19 9c			call macro_forth_dsp 
b52f				endm 
# End of macro FORTH_DSP
b52f 7e					ld a,(hl)	; get type of value on TOS 
b530 fe 02				cp DS_TYPE_INUM  
b532 28 03				jr z, .dot_inum 
b534			 
b534					NEXTW 
b534 c3 09 9e			jp macro_next 
b537				endm 
# End of macro NEXTW
b537			 
b537			; float maths 
b537			 
b537				if FORTH_ENABLE_FLOATMATH 
b537						inc hl      ; now at start of numeric as string 
b537			 
b537					if DEBUG_FORTH_MATHS 
b537						DMARK "ADD" 
b537				CALLMONITOR 
b537					endif 
b537			 
b537					;ld ix, hl 
b537					call CON 
b537			 
b537			 
b537					push hl 
b537					 
b537					 
b537			 
b537						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b537			 
b537					; get next number 
b537			 
b537						FORTH_DSP_VALUE 
b537			 
b537						inc hl      ; now at start of numeric as string 
b537			 
b537					;ld ix, hl 
b537					call CON 
b537			 
b537					push hl 
b537			 
b537			 
b537						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b537			 
b537						; TODO do add 
b537			 
b537						call IADD 
b537			 
b537						; TODO get result back as ascii 
b537			 
b537						; TODO push result  
b537			 
b537			 
b537			 
b537						jr .dot_done 
b537				endif 
b537			 
b537			.dot_inum: 
b537			 
b537			 
b537					if DEBUG_FORTH_DOT 
b537						DMARK "+IT" 
b537 f5				push af  
b538 3a 4c b5			ld a, (.dmark)  
b53b 32 6b ee			ld (debug_mark),a  
b53e 3a 4d b5			ld a, (.dmark+1)  
b541 32 6c ee			ld (debug_mark+1),a  
b544 3a 4e b5			ld a, (.dmark+2)  
b547 32 6d ee			ld (debug_mark+2),a  
b54a 18 03			jr .pastdmark  
b54c ..			.dmark: db "+IT"  
b54f f1			.pastdmark: pop af  
b550			endm  
# End of macro DMARK
b550				CALLMONITOR 
b550 cd 6f ee			call debug_vector  
b553				endm  
# End of macro CALLMONITOR
b553					endif 
b553			 
b553					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b553 cd 53 9c			call macro_dsp_valuehl 
b556				endm 
# End of macro FORTH_DSP_VALUEHL
b556			 
b556				; TODO add floating point number detection 
b556			 
b556 e5					push hl 
b557			 
b557					; destroy value TOS 
b557			 
b557					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b557 cd 0b 9d			call macro_forth_dsp_pop 
b55a				endm 
# End of macro FORTH_DSP_POP
b55a			 
b55a			 
b55a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b55a cd 53 9c			call macro_dsp_valuehl 
b55d				endm 
# End of macro FORTH_DSP_VALUEHL
b55d			 
b55d					; one value on hl get other one back 
b55d			 
b55d d1					pop de 
b55e			 
b55e					; do the add 
b55e			 
b55e 19					add hl,de 
b55f			 
b55f					; save it 
b55f			 
b55f			;		push hl	 
b55f			 
b55f					; 
b55f			 
b55f					; destroy value TOS 
b55f			 
b55f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b55f cd 0b 9d			call macro_forth_dsp_pop 
b562				endm 
# End of macro FORTH_DSP_POP
b562			 
b562					; TODO push value back onto stack for another op etc 
b562			 
b562			;		pop hl 
b562			 
b562			.dot_done: 
b562 cd 5c 9a				call forth_push_numhl 
b565			 
b565					NEXTW 
b565 c3 09 9e			jp macro_next 
b568				endm 
# End of macro NEXTW
b568			.NEG: 
b568			 
b568				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b568 17				db WORD_SYS_CORE+3             
b569 ab b5			dw .DIV            
b56b 02				db 1 + 1 
b56c .. 00			db "-",0              
b56e				endm 
# End of macro CWHEAD
b56e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b56e					if DEBUG_FORTH_WORDS_KEY 
b56e						DMARK "SUB" 
b56e f5				push af  
b56f 3a 83 b5			ld a, (.dmark)  
b572 32 6b ee			ld (debug_mark),a  
b575 3a 84 b5			ld a, (.dmark+1)  
b578 32 6c ee			ld (debug_mark+1),a  
b57b 3a 85 b5			ld a, (.dmark+2)  
b57e 32 6d ee			ld (debug_mark+2),a  
b581 18 03			jr .pastdmark  
b583 ..			.dmark: db "SUB"  
b586 f1			.pastdmark: pop af  
b587			endm  
# End of macro DMARK
b587						CALLMONITOR 
b587 cd 6f ee			call debug_vector  
b58a				endm  
# End of macro CALLMONITOR
b58a					endif 
b58a			 
b58a			 
b58a				; TODO add floating point number detection 
b58a					; v5 FORTH_DSP_VALUE 
b58a					FORTH_DSP 
b58a cd 19 9c			call macro_forth_dsp 
b58d				endm 
# End of macro FORTH_DSP
b58d 7e					ld a,(hl)	; get type of value on TOS 
b58e fe 02				cp DS_TYPE_INUM  
b590 28 03				jr z, .neg_inum 
b592			 
b592					NEXTW 
b592 c3 09 9e			jp macro_next 
b595				endm 
# End of macro NEXTW
b595			 
b595			; float maths 
b595			 
b595				if FORTH_ENABLE_FLOATMATH 
b595					jr .neg_done 
b595			 
b595				endif 
b595					 
b595			 
b595			.neg_inum: 
b595					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b595 cd 53 9c			call macro_dsp_valuehl 
b598				endm 
# End of macro FORTH_DSP_VALUEHL
b598			 
b598 e5					push hl 
b599			 
b599					; destroy value TOS 
b599			 
b599					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b599 cd 0b 9d			call macro_forth_dsp_pop 
b59c				endm 
# End of macro FORTH_DSP_POP
b59c			 
b59c			 
b59c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b59c cd 53 9c			call macro_dsp_valuehl 
b59f				endm 
# End of macro FORTH_DSP_VALUEHL
b59f			 
b59f					; one value on hl get other one back 
b59f			 
b59f d1					pop de 
b5a0			 
b5a0					; do the sub 
b5a0			;		ex de, hl 
b5a0			 
b5a0 ed 52				sbc hl,de 
b5a2			 
b5a2					; save it 
b5a2			 
b5a2			;		push hl	 
b5a2			 
b5a2					; 
b5a2			 
b5a2					; destroy value TOS 
b5a2			 
b5a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a2 cd 0b 9d			call macro_forth_dsp_pop 
b5a5				endm 
# End of macro FORTH_DSP_POP
b5a5			 
b5a5					; TODO push value back onto stack for another op etc 
b5a5			 
b5a5			;		pop hl 
b5a5			 
b5a5 cd 5c 9a				call forth_push_numhl 
b5a8			.neg_done: 
b5a8			 
b5a8					NEXTW 
b5a8 c3 09 9e			jp macro_next 
b5ab				endm 
# End of macro NEXTW
b5ab			.DIV: 
b5ab				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5ab 18				db WORD_SYS_CORE+4             
b5ac f8 b5			dw .MUL            
b5ae 02				db 1 + 1 
b5af .. 00			db "/",0              
b5b1				endm 
# End of macro CWHEAD
b5b1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5b1					if DEBUG_FORTH_WORDS_KEY 
b5b1						DMARK "DIV" 
b5b1 f5				push af  
b5b2 3a c6 b5			ld a, (.dmark)  
b5b5 32 6b ee			ld (debug_mark),a  
b5b8 3a c7 b5			ld a, (.dmark+1)  
b5bb 32 6c ee			ld (debug_mark+1),a  
b5be 3a c8 b5			ld a, (.dmark+2)  
b5c1 32 6d ee			ld (debug_mark+2),a  
b5c4 18 03			jr .pastdmark  
b5c6 ..			.dmark: db "DIV"  
b5c9 f1			.pastdmark: pop af  
b5ca			endm  
# End of macro DMARK
b5ca						CALLMONITOR 
b5ca cd 6f ee			call debug_vector  
b5cd				endm  
# End of macro CALLMONITOR
b5cd					endif 
b5cd				; TODO add floating point number detection 
b5cd					; v5 FORTH_DSP_VALUE 
b5cd					FORTH_DSP 
b5cd cd 19 9c			call macro_forth_dsp 
b5d0				endm 
# End of macro FORTH_DSP
b5d0 7e					ld a,(hl)	; get type of value on TOS 
b5d1 fe 02				cp DS_TYPE_INUM  
b5d3 28 03				jr z, .div_inum 
b5d5			 
b5d5				if FORTH_ENABLE_FLOATMATH 
b5d5					jr .div_done 
b5d5			 
b5d5				endif 
b5d5					NEXTW 
b5d5 c3 09 9e			jp macro_next 
b5d8				endm 
# End of macro NEXTW
b5d8			.div_inum: 
b5d8			 
b5d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5d8 cd 53 9c			call macro_dsp_valuehl 
b5db				endm 
# End of macro FORTH_DSP_VALUEHL
b5db			 
b5db e5					push hl    ; to go to bc 
b5dc			 
b5dc					; destroy value TOS 
b5dc			 
b5dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5dc cd 0b 9d			call macro_forth_dsp_pop 
b5df				endm 
# End of macro FORTH_DSP_POP
b5df			 
b5df			 
b5df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5df cd 53 9c			call macro_dsp_valuehl 
b5e2				endm 
# End of macro FORTH_DSP_VALUEHL
b5e2			 
b5e2					; hl to go to de 
b5e2			 
b5e2 e5					push hl 
b5e3			 
b5e3 c1					pop bc 
b5e4 d1					pop de		 
b5e5			 
b5e5			 
b5e5					if DEBUG_FORTH_MATHS 
b5e5						DMARK "DIV" 
b5e5				CALLMONITOR 
b5e5					endif 
b5e5					; one value on hl but move to a get other one back 
b5e5			 
b5e5			        
b5e5 cd 38 8c			call Div16 
b5e8			 
b5e8			;	push af	 
b5e8 e5				push hl 
b5e9 c5				push bc 
b5ea			 
b5ea					if DEBUG_FORTH_MATHS 
b5ea						DMARK "DI1" 
b5ea				CALLMONITOR 
b5ea					endif 
b5ea			 
b5ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ea cd 0b 9d			call macro_forth_dsp_pop 
b5ed				endm 
# End of macro FORTH_DSP_POP
b5ed			 
b5ed			 
b5ed			 
b5ed e1					pop hl    ; result 
b5ee			 
b5ee cd 5c 9a				call forth_push_numhl 
b5f1			 
b5f1 e1					pop hl    ; reminder 
b5f2			;		ld h,0 
b5f2			;		ld l,d 
b5f2			 
b5f2 cd 5c 9a				call forth_push_numhl 
b5f5			.div_done: 
b5f5					NEXTW 
b5f5 c3 09 9e			jp macro_next 
b5f8				endm 
# End of macro NEXTW
b5f8			.MUL: 
b5f8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b5f8 19				db WORD_SYS_CORE+5             
b5f9 3d b6			dw .MIN            
b5fb 02				db 1 + 1 
b5fc .. 00			db "*",0              
b5fe				endm 
# End of macro CWHEAD
b5fe			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b5fe				; TODO add floating point number detection 
b5fe					if DEBUG_FORTH_WORDS_KEY 
b5fe						DMARK "MUL" 
b5fe f5				push af  
b5ff 3a 13 b6			ld a, (.dmark)  
b602 32 6b ee			ld (debug_mark),a  
b605 3a 14 b6			ld a, (.dmark+1)  
b608 32 6c ee			ld (debug_mark+1),a  
b60b 3a 15 b6			ld a, (.dmark+2)  
b60e 32 6d ee			ld (debug_mark+2),a  
b611 18 03			jr .pastdmark  
b613 ..			.dmark: db "MUL"  
b616 f1			.pastdmark: pop af  
b617			endm  
# End of macro DMARK
b617						CALLMONITOR 
b617 cd 6f ee			call debug_vector  
b61a				endm  
# End of macro CALLMONITOR
b61a					endif 
b61a					FORTH_DSP 
b61a cd 19 9c			call macro_forth_dsp 
b61d				endm 
# End of macro FORTH_DSP
b61d					; v5 FORTH_DSP_VALUE 
b61d 7e					ld a,(hl)	; get type of value on TOS 
b61e fe 02				cp DS_TYPE_INUM  
b620 28 03				jr z, .mul_inum 
b622			 
b622				if FORTH_ENABLE_FLOATMATH 
b622					jr .mul_done 
b622			 
b622				endif 
b622			 
b622					NEXTW 
b622 c3 09 9e			jp macro_next 
b625				endm 
# End of macro NEXTW
b625			.mul_inum:	 
b625			 
b625					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b625 cd 53 9c			call macro_dsp_valuehl 
b628				endm 
# End of macro FORTH_DSP_VALUEHL
b628			 
b628 e5					push hl 
b629			 
b629					; destroy value TOS 
b629			 
b629					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b629 cd 0b 9d			call macro_forth_dsp_pop 
b62c				endm 
# End of macro FORTH_DSP_POP
b62c			 
b62c			 
b62c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b62c cd 53 9c			call macro_dsp_valuehl 
b62f				endm 
# End of macro FORTH_DSP_VALUEHL
b62f			 
b62f					; one value on hl but move to a get other one back 
b62f			 
b62f 7d					ld a, l 
b630			 
b630 d1					pop de 
b631			 
b631					; do the mull 
b631			;		ex de, hl 
b631			 
b631 cd 5e 8c				call Mult16 
b634					; save it 
b634			 
b634			;		push hl	 
b634			 
b634					; 
b634			 
b634					; destroy value TOS 
b634			 
b634					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b634 cd 0b 9d			call macro_forth_dsp_pop 
b637				endm 
# End of macro FORTH_DSP_POP
b637			 
b637					; TODO push value back onto stack for another op etc 
b637			 
b637			;		pop hl 
b637			 
b637 cd 5c 9a				call forth_push_numhl 
b63a			 
b63a			.mul_done: 
b63a					NEXTW 
b63a c3 09 9e			jp macro_next 
b63d				endm 
# End of macro NEXTW
b63d			 
b63d			 
b63d			 
b63d			 
b63d			.MIN: 
b63d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b63d 49				db WORD_SYS_CORE+53             
b63e be b6			dw .MAX            
b640 04				db 3 + 1 
b641 .. 00			db "MIN",0              
b645				endm 
# End of macro CWHEAD
b645			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b645					if DEBUG_FORTH_WORDS_KEY 
b645						DMARK "MIN" 
b645 f5				push af  
b646 3a 5a b6			ld a, (.dmark)  
b649 32 6b ee			ld (debug_mark),a  
b64c 3a 5b b6			ld a, (.dmark+1)  
b64f 32 6c ee			ld (debug_mark+1),a  
b652 3a 5c b6			ld a, (.dmark+2)  
b655 32 6d ee			ld (debug_mark+2),a  
b658 18 03			jr .pastdmark  
b65a ..			.dmark: db "MIN"  
b65d f1			.pastdmark: pop af  
b65e			endm  
# End of macro DMARK
b65e						CALLMONITOR 
b65e cd 6f ee			call debug_vector  
b661				endm  
# End of macro CALLMONITOR
b661					endif 
b661					; get u2 
b661			 
b661					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b661 cd 53 9c			call macro_dsp_valuehl 
b664				endm 
# End of macro FORTH_DSP_VALUEHL
b664			 
b664 e5					push hl   ; u2 
b665			 
b665					; destroy value TOS 
b665			 
b665					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b665 cd 0b 9d			call macro_forth_dsp_pop 
b668				endm 
# End of macro FORTH_DSP_POP
b668			 
b668					; get u1 
b668			 
b668					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b668 cd 53 9c			call macro_dsp_valuehl 
b66b				endm 
# End of macro FORTH_DSP_VALUEHL
b66b			 
b66b e5					push hl  ; u1 
b66c			 
b66c					; destroy value TOS 
b66c			 
b66c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b66c cd 0b 9d			call macro_forth_dsp_pop 
b66f				endm 
# End of macro FORTH_DSP_POP
b66f			 
b66f b7			 or a      ;clear carry flag 
b670 e1			  pop hl    ; u1 
b671 d1			  pop de    ; u2 
b672 e5				push hl   ; saved in case hl is lowest 
b673 ed 52		  sbc hl,de 
b675 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b677			 
b677 e1				pop hl 
b678					if DEBUG_FORTH_WORDS 
b678						DMARK "MIN" 
b678 f5				push af  
b679 3a 8d b6			ld a, (.dmark)  
b67c 32 6b ee			ld (debug_mark),a  
b67f 3a 8e b6			ld a, (.dmark+1)  
b682 32 6c ee			ld (debug_mark+1),a  
b685 3a 8f b6			ld a, (.dmark+2)  
b688 32 6d ee			ld (debug_mark+2),a  
b68b 18 03			jr .pastdmark  
b68d ..			.dmark: db "MIN"  
b690 f1			.pastdmark: pop af  
b691			endm  
# End of macro DMARK
b691						CALLMONITOR 
b691 cd 6f ee			call debug_vector  
b694				endm  
# End of macro CALLMONITOR
b694					endif 
b694 cd 5c 9a				call forth_push_numhl 
b697			 
b697				       NEXTW 
b697 c3 09 9e			jp macro_next 
b69a				endm 
# End of macro NEXTW
b69a			 
b69a			.mincont:  
b69a c1				pop bc   ; tidy up 
b69b eb				ex de , hl  
b69c					if DEBUG_FORTH_WORDS 
b69c						DMARK "MI1" 
b69c f5				push af  
b69d 3a b1 b6			ld a, (.dmark)  
b6a0 32 6b ee			ld (debug_mark),a  
b6a3 3a b2 b6			ld a, (.dmark+1)  
b6a6 32 6c ee			ld (debug_mark+1),a  
b6a9 3a b3 b6			ld a, (.dmark+2)  
b6ac 32 6d ee			ld (debug_mark+2),a  
b6af 18 03			jr .pastdmark  
b6b1 ..			.dmark: db "MI1"  
b6b4 f1			.pastdmark: pop af  
b6b5			endm  
# End of macro DMARK
b6b5						CALLMONITOR 
b6b5 cd 6f ee			call debug_vector  
b6b8				endm  
# End of macro CALLMONITOR
b6b8					endif 
b6b8 cd 5c 9a				call forth_push_numhl 
b6bb			 
b6bb				       NEXTW 
b6bb c3 09 9e			jp macro_next 
b6be				endm 
# End of macro NEXTW
b6be			.MAX: 
b6be				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6be 4a				db WORD_SYS_CORE+54             
b6bf 3f b7			dw .RND16            
b6c1 04				db 3 + 1 
b6c2 .. 00			db "MAX",0              
b6c6				endm 
# End of macro CWHEAD
b6c6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6c6					if DEBUG_FORTH_WORDS_KEY 
b6c6						DMARK "MAX" 
b6c6 f5				push af  
b6c7 3a db b6			ld a, (.dmark)  
b6ca 32 6b ee			ld (debug_mark),a  
b6cd 3a dc b6			ld a, (.dmark+1)  
b6d0 32 6c ee			ld (debug_mark+1),a  
b6d3 3a dd b6			ld a, (.dmark+2)  
b6d6 32 6d ee			ld (debug_mark+2),a  
b6d9 18 03			jr .pastdmark  
b6db ..			.dmark: db "MAX"  
b6de f1			.pastdmark: pop af  
b6df			endm  
# End of macro DMARK
b6df						CALLMONITOR 
b6df cd 6f ee			call debug_vector  
b6e2				endm  
# End of macro CALLMONITOR
b6e2					endif 
b6e2					; get u2 
b6e2			 
b6e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6e2 cd 53 9c			call macro_dsp_valuehl 
b6e5				endm 
# End of macro FORTH_DSP_VALUEHL
b6e5			 
b6e5 e5					push hl   ; u2 
b6e6			 
b6e6					; destroy value TOS 
b6e6			 
b6e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6e6 cd 0b 9d			call macro_forth_dsp_pop 
b6e9				endm 
# End of macro FORTH_DSP_POP
b6e9			 
b6e9					; get u1 
b6e9			 
b6e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6e9 cd 53 9c			call macro_dsp_valuehl 
b6ec				endm 
# End of macro FORTH_DSP_VALUEHL
b6ec			 
b6ec e5					push hl  ; u1 
b6ed			 
b6ed					; destroy value TOS 
b6ed			 
b6ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6ed cd 0b 9d			call macro_forth_dsp_pop 
b6f0				endm 
# End of macro FORTH_DSP_POP
b6f0			 
b6f0 b7			 or a      ;clear carry flag 
b6f1 e1			  pop hl    ; u1 
b6f2 d1			  pop de    ; u2 
b6f3 e5				push hl   ; saved in case hl is lowest 
b6f4 ed 52		  sbc hl,de 
b6f6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b6f8			 
b6f8 e1				pop hl 
b6f9					if DEBUG_FORTH_WORDS 
b6f9						DMARK "MAX" 
b6f9 f5				push af  
b6fa 3a 0e b7			ld a, (.dmark)  
b6fd 32 6b ee			ld (debug_mark),a  
b700 3a 0f b7			ld a, (.dmark+1)  
b703 32 6c ee			ld (debug_mark+1),a  
b706 3a 10 b7			ld a, (.dmark+2)  
b709 32 6d ee			ld (debug_mark+2),a  
b70c 18 03			jr .pastdmark  
b70e ..			.dmark: db "MAX"  
b711 f1			.pastdmark: pop af  
b712			endm  
# End of macro DMARK
b712						CALLMONITOR 
b712 cd 6f ee			call debug_vector  
b715				endm  
# End of macro CALLMONITOR
b715					endif 
b715 cd 5c 9a				call forth_push_numhl 
b718			 
b718				       NEXTW 
b718 c3 09 9e			jp macro_next 
b71b				endm 
# End of macro NEXTW
b71b			 
b71b			.maxcont:  
b71b c1				pop bc   ; tidy up 
b71c eb				ex de , hl  
b71d					if DEBUG_FORTH_WORDS 
b71d						DMARK "MA1" 
b71d f5				push af  
b71e 3a 32 b7			ld a, (.dmark)  
b721 32 6b ee			ld (debug_mark),a  
b724 3a 33 b7			ld a, (.dmark+1)  
b727 32 6c ee			ld (debug_mark+1),a  
b72a 3a 34 b7			ld a, (.dmark+2)  
b72d 32 6d ee			ld (debug_mark+2),a  
b730 18 03			jr .pastdmark  
b732 ..			.dmark: db "MA1"  
b735 f1			.pastdmark: pop af  
b736			endm  
# End of macro DMARK
b736						CALLMONITOR 
b736 cd 6f ee			call debug_vector  
b739				endm  
# End of macro CALLMONITOR
b739					endif 
b739 cd 5c 9a				call forth_push_numhl 
b73c				       NEXTW 
b73c c3 09 9e			jp macro_next 
b73f				endm 
# End of macro NEXTW
b73f			 
b73f			.RND16: 
b73f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b73f 4e				db WORD_SYS_CORE+58             
b740 6e b7			dw .RND8            
b742 06				db 5 + 1 
b743 .. 00			db "RND16",0              
b749				endm 
# End of macro CWHEAD
b749			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b749					if DEBUG_FORTH_WORDS_KEY 
b749						DMARK "R16" 
b749 f5				push af  
b74a 3a 5e b7			ld a, (.dmark)  
b74d 32 6b ee			ld (debug_mark),a  
b750 3a 5f b7			ld a, (.dmark+1)  
b753 32 6c ee			ld (debug_mark+1),a  
b756 3a 60 b7			ld a, (.dmark+2)  
b759 32 6d ee			ld (debug_mark+2),a  
b75c 18 03			jr .pastdmark  
b75e ..			.dmark: db "R16"  
b761 f1			.pastdmark: pop af  
b762			endm  
# End of macro DMARK
b762						CALLMONITOR 
b762 cd 6f ee			call debug_vector  
b765				endm  
# End of macro CALLMONITOR
b765					endif 
b765 cd 02 8c				call prng16  
b768 cd 5c 9a				call forth_push_numhl 
b76b				       NEXTW 
b76b c3 09 9e			jp macro_next 
b76e				endm 
# End of macro NEXTW
b76e			.RND8: 
b76e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b76e 60				db WORD_SYS_CORE+76             
b76f a3 b7			dw .RND            
b771 05				db 4 + 1 
b772 .. 00			db "RND8",0              
b777				endm 
# End of macro CWHEAD
b777			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b777					if DEBUG_FORTH_WORDS_KEY 
b777						DMARK "RN8" 
b777 f5				push af  
b778 3a 8c b7			ld a, (.dmark)  
b77b 32 6b ee			ld (debug_mark),a  
b77e 3a 8d b7			ld a, (.dmark+1)  
b781 32 6c ee			ld (debug_mark+1),a  
b784 3a 8e b7			ld a, (.dmark+2)  
b787 32 6d ee			ld (debug_mark+2),a  
b78a 18 03			jr .pastdmark  
b78c ..			.dmark: db "RN8"  
b78f f1			.pastdmark: pop af  
b790			endm  
# End of macro DMARK
b790						CALLMONITOR 
b790 cd 6f ee			call debug_vector  
b793				endm  
# End of macro CALLMONITOR
b793					endif 
b793 2a a9 eb				ld hl,(xrandc) 
b796 23					inc hl 
b797 cd 1c 8c				call xrnd 
b79a 6f					ld l,a	 
b79b 26 00				ld h,0 
b79d cd 5c 9a				call forth_push_numhl 
b7a0				       NEXTW 
b7a0 c3 09 9e			jp macro_next 
b7a3				endm 
# End of macro NEXTW
b7a3			.RND: 
b7a3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7a3 60				db WORD_SYS_CORE+76             
b7a4 a9 b8			dw .ENDMATHS            
b7a6 04				db 3 + 1 
b7a7 .. 00			db "RND",0              
b7ab				endm 
# End of macro CWHEAD
b7ab			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7ab			 
b7ab					if DEBUG_FORTH_WORDS_KEY 
b7ab						DMARK "RND" 
b7ab f5				push af  
b7ac 3a c0 b7			ld a, (.dmark)  
b7af 32 6b ee			ld (debug_mark),a  
b7b2 3a c1 b7			ld a, (.dmark+1)  
b7b5 32 6c ee			ld (debug_mark+1),a  
b7b8 3a c2 b7			ld a, (.dmark+2)  
b7bb 32 6d ee			ld (debug_mark+2),a  
b7be 18 03			jr .pastdmark  
b7c0 ..			.dmark: db "RND"  
b7c3 f1			.pastdmark: pop af  
b7c4			endm  
# End of macro DMARK
b7c4						CALLMONITOR 
b7c4 cd 6f ee			call debug_vector  
b7c7				endm  
# End of macro CALLMONITOR
b7c7					endif 
b7c7					 
b7c7					FORTH_DSP_VALUEHL    ; upper range 
b7c7 cd 53 9c			call macro_dsp_valuehl 
b7ca				endm 
# End of macro FORTH_DSP_VALUEHL
b7ca			 
b7ca 22 ad eb				ld (LFSRSeed), hl	 
b7cd			 
b7cd					if DEBUG_FORTH_WORDS 
b7cd						DMARK "RN1" 
b7cd f5				push af  
b7ce 3a e2 b7			ld a, (.dmark)  
b7d1 32 6b ee			ld (debug_mark),a  
b7d4 3a e3 b7			ld a, (.dmark+1)  
b7d7 32 6c ee			ld (debug_mark+1),a  
b7da 3a e4 b7			ld a, (.dmark+2)  
b7dd 32 6d ee			ld (debug_mark+2),a  
b7e0 18 03			jr .pastdmark  
b7e2 ..			.dmark: db "RN1"  
b7e5 f1			.pastdmark: pop af  
b7e6			endm  
# End of macro DMARK
b7e6						CALLMONITOR 
b7e6 cd 6f ee			call debug_vector  
b7e9				endm  
# End of macro CALLMONITOR
b7e9					endif 
b7e9					FORTH_DSP_POP 
b7e9 cd 0b 9d			call macro_forth_dsp_pop 
b7ec				endm 
# End of macro FORTH_DSP_POP
b7ec			 
b7ec					FORTH_DSP_VALUEHL    ; low range 
b7ec cd 53 9c			call macro_dsp_valuehl 
b7ef				endm 
# End of macro FORTH_DSP_VALUEHL
b7ef			 
b7ef					if DEBUG_FORTH_WORDS 
b7ef						DMARK "RN2" 
b7ef f5				push af  
b7f0 3a 04 b8			ld a, (.dmark)  
b7f3 32 6b ee			ld (debug_mark),a  
b7f6 3a 05 b8			ld a, (.dmark+1)  
b7f9 32 6c ee			ld (debug_mark+1),a  
b7fc 3a 06 b8			ld a, (.dmark+2)  
b7ff 32 6d ee			ld (debug_mark+2),a  
b802 18 03			jr .pastdmark  
b804 ..			.dmark: db "RN2"  
b807 f1			.pastdmark: pop af  
b808			endm  
# End of macro DMARK
b808						CALLMONITOR 
b808 cd 6f ee			call debug_vector  
b80b				endm  
# End of macro CALLMONITOR
b80b					endif 
b80b 22 af eb				ld (LFSRSeed+2), hl 
b80e			 
b80e					FORTH_DSP_POP 
b80e cd 0b 9d			call macro_forth_dsp_pop 
b811				endm 
# End of macro FORTH_DSP_POP
b811			 
b811 e5					push hl 
b812			 
b812 e1			.inrange:	pop hl 
b813 cd 02 8c				call prng16  
b816					if DEBUG_FORTH_WORDS 
b816						DMARK "RN3" 
b816 f5				push af  
b817 3a 2b b8			ld a, (.dmark)  
b81a 32 6b ee			ld (debug_mark),a  
b81d 3a 2c b8			ld a, (.dmark+1)  
b820 32 6c ee			ld (debug_mark+1),a  
b823 3a 2d b8			ld a, (.dmark+2)  
b826 32 6d ee			ld (debug_mark+2),a  
b829 18 03			jr .pastdmark  
b82b ..			.dmark: db "RN3"  
b82e f1			.pastdmark: pop af  
b82f			endm  
# End of macro DMARK
b82f						CALLMONITOR 
b82f cd 6f ee			call debug_vector  
b832				endm  
# End of macro CALLMONITOR
b832					endif 
b832					 
b832					; if the range is 8bit knock out the high byte 
b832			 
b832 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b836			 
b836 3e 00				ld a, 0 
b838 ba					cp d  
b839 20 1e				jr nz, .hirange 
b83b 26 00				ld h, 0   ; knock it down to 8bit 
b83d			 
b83d					if DEBUG_FORTH_WORDS 
b83d						DMARK "RNk" 
b83d f5				push af  
b83e 3a 52 b8			ld a, (.dmark)  
b841 32 6b ee			ld (debug_mark),a  
b844 3a 53 b8			ld a, (.dmark+1)  
b847 32 6c ee			ld (debug_mark+1),a  
b84a 3a 54 b8			ld a, (.dmark+2)  
b84d 32 6d ee			ld (debug_mark+2),a  
b850 18 03			jr .pastdmark  
b852 ..			.dmark: db "RNk"  
b855 f1			.pastdmark: pop af  
b856			endm  
# End of macro DMARK
b856						CALLMONITOR 
b856 cd 6f ee			call debug_vector  
b859				endm  
# End of macro CALLMONITOR
b859					endif 
b859			.hirange:   
b859 e5					push hl  
b85a b7					or a  
b85b ed 52		                sbc hl, de 
b85d			 
b85d					;call cmp16 
b85d			 
b85d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b85f e1					pop hl 
b860 e5					push hl 
b861			 
b861					if DEBUG_FORTH_WORDS 
b861						DMARK "RN4" 
b861 f5				push af  
b862 3a 76 b8			ld a, (.dmark)  
b865 32 6b ee			ld (debug_mark),a  
b868 3a 77 b8			ld a, (.dmark+1)  
b86b 32 6c ee			ld (debug_mark+1),a  
b86e 3a 78 b8			ld a, (.dmark+2)  
b871 32 6d ee			ld (debug_mark+2),a  
b874 18 03			jr .pastdmark  
b876 ..			.dmark: db "RN4"  
b879 f1			.pastdmark: pop af  
b87a			endm  
# End of macro DMARK
b87a						CALLMONITOR 
b87a cd 6f ee			call debug_vector  
b87d				endm  
# End of macro CALLMONITOR
b87d					endif 
b87d ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b881					;call cmp16 
b881				 
b881 b7					or a  
b882 ed 52		                sbc hl, de 
b884 38 8c				jr c, .inrange 
b886			 
b886 e1					pop hl 
b887					 
b887					if DEBUG_FORTH_WORDS 
b887						DMARK "RNd" 
b887 f5				push af  
b888 3a 9c b8			ld a, (.dmark)  
b88b 32 6b ee			ld (debug_mark),a  
b88e 3a 9d b8			ld a, (.dmark+1)  
b891 32 6c ee			ld (debug_mark+1),a  
b894 3a 9e b8			ld a, (.dmark+2)  
b897 32 6d ee			ld (debug_mark+2),a  
b89a 18 03			jr .pastdmark  
b89c ..			.dmark: db "RNd"  
b89f f1			.pastdmark: pop af  
b8a0			endm  
# End of macro DMARK
b8a0						CALLMONITOR 
b8a0 cd 6f ee			call debug_vector  
b8a3				endm  
# End of macro CALLMONITOR
b8a3					endif 
b8a3			 
b8a3			 
b8a3 cd 5c 9a				call forth_push_numhl 
b8a6				       NEXTW 
b8a6 c3 09 9e			jp macro_next 
b8a9				endm 
# End of macro NEXTW
b8a9			 
b8a9			.ENDMATHS: 
b8a9			 
b8a9			; eof 
b8a9			 
# End of file forth_words_maths.asm
b8a9			include "forth_words_display.asm" 
b8a9			 
b8a9			; | ## Display Words 
b8a9			 
b8a9			.ACT: 
b8a9			 
b8a9				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8a9 62				db WORD_SYS_CORE+78             
b8aa f5 b8			dw .INFO            
b8ac 07				db 6 + 1 
b8ad .. 00			db "ACTIVE",0              
b8b4				endm 
# End of macro CWHEAD
b8b4			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b8b4			;  
b8b4			; | | To display a pulsing activity indicator in a processing loop do this... 
b8b4			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
b8b4			 
b8b4					if DEBUG_FORTH_WORDS_KEY 
b8b4						DMARK "ACT" 
b8b4 f5				push af  
b8b5 3a c9 b8			ld a, (.dmark)  
b8b8 32 6b ee			ld (debug_mark),a  
b8bb 3a ca b8			ld a, (.dmark+1)  
b8be 32 6c ee			ld (debug_mark+1),a  
b8c1 3a cb b8			ld a, (.dmark+2)  
b8c4 32 6d ee			ld (debug_mark+2),a  
b8c7 18 03			jr .pastdmark  
b8c9 ..			.dmark: db "ACT"  
b8cc f1			.pastdmark: pop af  
b8cd			endm  
# End of macro DMARK
b8cd						CALLMONITOR 
b8cd cd 6f ee			call debug_vector  
b8d0				endm  
# End of macro CALLMONITOR
b8d0					endif 
b8d0 cd 05 8a				call active 
b8d3					if DEBUG_FORTH_WORDS 
b8d3						DMARK "ACp" 
b8d3 f5				push af  
b8d4 3a e8 b8			ld a, (.dmark)  
b8d7 32 6b ee			ld (debug_mark),a  
b8da 3a e9 b8			ld a, (.dmark+1)  
b8dd 32 6c ee			ld (debug_mark+1),a  
b8e0 3a ea b8			ld a, (.dmark+2)  
b8e3 32 6d ee			ld (debug_mark+2),a  
b8e6 18 03			jr .pastdmark  
b8e8 ..			.dmark: db "ACp"  
b8eb f1			.pastdmark: pop af  
b8ec			endm  
# End of macro DMARK
b8ec						CALLMONITOR 
b8ec cd 6f ee			call debug_vector  
b8ef				endm  
# End of macro CALLMONITOR
b8ef					endif 
b8ef cd ca 9a				call forth_push_str 
b8f2			 
b8f2					NEXTW 
b8f2 c3 09 9e			jp macro_next 
b8f5				endm 
# End of macro NEXTW
b8f5			.INFO: 
b8f5			 
b8f5				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b8f5 62				db WORD_SYS_CORE+78             
b8f6 12 b9			dw .ATP            
b8f8 05				db 4 + 1 
b8f9 .. 00			db "INFO",0              
b8fe				endm 
# End of macro CWHEAD
b8fe			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b8fe					FORTH_DSP_VALUEHL 
b8fe cd 53 9c			call macro_dsp_valuehl 
b901				endm 
# End of macro FORTH_DSP_VALUEHL
b901			 
b901					FORTH_DSP_POP 
b901 cd 0b 9d			call macro_forth_dsp_pop 
b904				endm 
# End of macro FORTH_DSP_POP
b904			 
b904 e5					push hl 
b905			 
b905					FORTH_DSP_VALUEHL 
b905 cd 53 9c			call macro_dsp_valuehl 
b908				endm 
# End of macro FORTH_DSP_VALUEHL
b908			 
b908					FORTH_DSP_POP 
b908 cd 0b 9d			call macro_forth_dsp_pop 
b90b				endm 
# End of macro FORTH_DSP_POP
b90b			 
b90b d1					pop de 
b90c			 
b90c cd 3f 8a				call info_panel 
b90f			 
b90f			 
b90f					NEXTW 
b90f c3 09 9e			jp macro_next 
b912				endm 
# End of macro NEXTW
b912			.ATP: 
b912				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b912 62				db WORD_SYS_CORE+78             
b913 89 b9			dw .FB            
b915 04				db 3 + 1 
b916 .. 00			db "AT?",0              
b91a				endm 
# End of macro CWHEAD
b91a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b91a					if DEBUG_FORTH_WORDS_KEY 
b91a						DMARK "AT?" 
b91a f5				push af  
b91b 3a 2f b9			ld a, (.dmark)  
b91e 32 6b ee			ld (debug_mark),a  
b921 3a 30 b9			ld a, (.dmark+1)  
b924 32 6c ee			ld (debug_mark+1),a  
b927 3a 31 b9			ld a, (.dmark+2)  
b92a 32 6d ee			ld (debug_mark+2),a  
b92d 18 03			jr .pastdmark  
b92f ..			.dmark: db "AT?"  
b932 f1			.pastdmark: pop af  
b933			endm  
# End of macro DMARK
b933						CALLMONITOR 
b933 cd 6f ee			call debug_vector  
b936				endm  
# End of macro CALLMONITOR
b936					endif 
b936 3a 5e ea				ld a, (f_cursor_ptr) 
b939			 
b939			if DEBUG_FORTH_WORDS 
b939				DMARK "AT?" 
b939 f5				push af  
b93a 3a 4e b9			ld a, (.dmark)  
b93d 32 6b ee			ld (debug_mark),a  
b940 3a 4f b9			ld a, (.dmark+1)  
b943 32 6c ee			ld (debug_mark+1),a  
b946 3a 50 b9			ld a, (.dmark+2)  
b949 32 6d ee			ld (debug_mark+2),a  
b94c 18 03			jr .pastdmark  
b94e ..			.dmark: db "AT?"  
b951 f1			.pastdmark: pop af  
b952			endm  
# End of macro DMARK
b952				CALLMONITOR 
b952 cd 6f ee			call debug_vector  
b955				endm  
# End of macro CALLMONITOR
b955			endif	 
b955					; count the number of rows 
b955			 
b955 06 00				ld b, 0 
b957 4f			.atpr:		ld c, a    ; save in case we go below zero 
b958 d6 28				sub display_cols 
b95a f2 60 b9				jp p, .atprunder 
b95d 04					inc b 
b95e 18 f7				jr .atpr 
b960			.atprunder:	 
b960			if DEBUG_FORTH_WORDS 
b960				DMARK "A?2" 
b960 f5				push af  
b961 3a 75 b9			ld a, (.dmark)  
b964 32 6b ee			ld (debug_mark),a  
b967 3a 76 b9			ld a, (.dmark+1)  
b96a 32 6c ee			ld (debug_mark+1),a  
b96d 3a 77 b9			ld a, (.dmark+2)  
b970 32 6d ee			ld (debug_mark+2),a  
b973 18 03			jr .pastdmark  
b975 ..			.dmark: db "A?2"  
b978 f1			.pastdmark: pop af  
b979			endm  
# End of macro DMARK
b979				CALLMONITOR 
b979 cd 6f ee			call debug_vector  
b97c				endm  
# End of macro CALLMONITOR
b97c			endif	 
b97c 26 00				ld h, 0 
b97e 69					ld l, c 
b97f cd 5c 9a				call forth_push_numhl 
b982 68					ld l, b  
b983 cd 5c 9a				call forth_push_numhl 
b986			 
b986			 
b986				NEXTW 
b986 c3 09 9e			jp macro_next 
b989				endm 
# End of macro NEXTW
b989			 
b989			.FB: 
b989				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b989 1b				db WORD_SYS_CORE+7             
b98a d7 b9			dw .EMIT            
b98c 03				db 2 + 1 
b98d .. 00			db "FB",0              
b990				endm 
# End of macro CWHEAD
b990			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b990			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b990			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b990			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b990					if DEBUG_FORTH_WORDS_KEY 
b990						DMARK "FB." 
b990 f5				push af  
b991 3a a5 b9			ld a, (.dmark)  
b994 32 6b ee			ld (debug_mark),a  
b997 3a a6 b9			ld a, (.dmark+1)  
b99a 32 6c ee			ld (debug_mark+1),a  
b99d 3a a7 b9			ld a, (.dmark+2)  
b9a0 32 6d ee			ld (debug_mark+2),a  
b9a3 18 03			jr .pastdmark  
b9a5 ..			.dmark: db "FB."  
b9a8 f1			.pastdmark: pop af  
b9a9			endm  
# End of macro DMARK
b9a9						CALLMONITOR 
b9a9 cd 6f ee			call debug_vector  
b9ac				endm  
# End of macro CALLMONITOR
b9ac					endif 
b9ac			 
b9ac					FORTH_DSP_VALUEHL 
b9ac cd 53 9c			call macro_dsp_valuehl 
b9af				endm 
# End of macro FORTH_DSP_VALUEHL
b9af			 
b9af 7d					ld a, l 
b9b0 fe 01				cp 1 
b9b2 20 05				jr nz, .fbn1 
b9b4 21 10 ed				ld hl, display_fb1 
b9b7 18 15				jr .fbset 
b9b9 fe 02		.fbn1:		cp 2 
b9bb 20 05				jr nz, .fbn2 
b9bd 21 ce eb				ld hl, display_fb2 
b9c0 18 0c				jr .fbset 
b9c2 fe 03		.fbn2:		cp 3 
b9c4 20 05				jr nz, .fbn3 
b9c6 21 6f ec				ld hl, display_fb3 
b9c9 18 03				jr .fbset 
b9cb			.fbn3:		 ; if invalid number select first 
b9cb 21 10 ed				ld hl, display_fb1 
b9ce 22 cc eb		.fbset:		ld (display_fb_active), hl 
b9d1			 
b9d1					FORTH_DSP_POP 
b9d1 cd 0b 9d			call macro_forth_dsp_pop 
b9d4				endm 
# End of macro FORTH_DSP_POP
b9d4			 
b9d4					NEXTW 
b9d4 c3 09 9e			jp macro_next 
b9d7				endm 
# End of macro NEXTW
b9d7			 
b9d7			 
b9d7			.EMIT: 
b9d7				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b9d7 1b				db WORD_SYS_CORE+7             
b9d8 28 ba			dw .DOTH            
b9da 05				db 4 + 1 
b9db .. 00			db "EMIT",0              
b9e0				endm 
# End of macro CWHEAD
b9e0			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b9e0					; get value off TOS and display it 
b9e0			 
b9e0					if DEBUG_FORTH_WORDS_KEY 
b9e0						DMARK "EMT" 
b9e0 f5				push af  
b9e1 3a f5 b9			ld a, (.dmark)  
b9e4 32 6b ee			ld (debug_mark),a  
b9e7 3a f6 b9			ld a, (.dmark+1)  
b9ea 32 6c ee			ld (debug_mark+1),a  
b9ed 3a f7 b9			ld a, (.dmark+2)  
b9f0 32 6d ee			ld (debug_mark+2),a  
b9f3 18 03			jr .pastdmark  
b9f5 ..			.dmark: db "EMT"  
b9f8 f1			.pastdmark: pop af  
b9f9			endm  
# End of macro DMARK
b9f9						CALLMONITOR 
b9f9 cd 6f ee			call debug_vector  
b9fc				endm  
# End of macro CALLMONITOR
b9fc					endif 
b9fc			 
b9fc					FORTH_DSP_VALUEHL 
b9fc cd 53 9c			call macro_dsp_valuehl 
b9ff				endm 
# End of macro FORTH_DSP_VALUEHL
b9ff			 
b9ff 7d					ld a,l 
ba00			 
ba00					; TODO write to display 
ba00			 
ba00 32 bf e4				ld (os_input), a 
ba03 3e 00				ld a, 0 
ba05 32 c0 e4				ld (os_input+1), a 
ba08					 
ba08 3a 5e ea				ld a, (f_cursor_ptr) 
ba0b 11 bf e4				ld de, os_input 
ba0e cd c1 8a				call str_at_display 
ba11			 
ba11			 
ba11 3a 3c ea				ld a,(cli_autodisplay) 
ba14 fe 00				cp 0 
ba16 28 03				jr z, .enoupdate 
ba18 cd d1 8a						call update_display 
ba1b					.enoupdate: 
ba1b			 
ba1b 3a 5e ea				ld a, (f_cursor_ptr) 
ba1e 3c					inc a 
ba1f 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
ba22			 
ba22			 
ba22					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba22 cd 0b 9d			call macro_forth_dsp_pop 
ba25				endm 
# End of macro FORTH_DSP_POP
ba25			  
ba25			 
ba25					NEXTW 
ba25 c3 09 9e			jp macro_next 
ba28				endm 
# End of macro NEXTW
ba28			.DOTH: 
ba28				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba28 1c				db WORD_SYS_CORE+8             
ba29 58 ba			dw .DOTF            
ba2b 03				db 2 + 1 
ba2c .. 00			db ".-",0              
ba2f				endm 
# End of macro CWHEAD
ba2f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba2f					; get value off TOS and display it 
ba2f					if DEBUG_FORTH_WORDS_KEY 
ba2f						DMARK "DTD" 
ba2f f5				push af  
ba30 3a 44 ba			ld a, (.dmark)  
ba33 32 6b ee			ld (debug_mark),a  
ba36 3a 45 ba			ld a, (.dmark+1)  
ba39 32 6c ee			ld (debug_mark+1),a  
ba3c 3a 46 ba			ld a, (.dmark+2)  
ba3f 32 6d ee			ld (debug_mark+2),a  
ba42 18 03			jr .pastdmark  
ba44 ..			.dmark: db "DTD"  
ba47 f1			.pastdmark: pop af  
ba48			endm  
# End of macro DMARK
ba48						CALLMONITOR 
ba48 cd 6f ee			call debug_vector  
ba4b				endm  
# End of macro CALLMONITOR
ba4b					endif 
ba4b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba4d 3e 00			ld a, 0 
ba4f 32 3d ea			ld (cli_mvdot), a 
ba52 c3 af ba			jp .dotgo 
ba55				NEXTW 
ba55 c3 09 9e			jp macro_next 
ba58				endm 
# End of macro NEXTW
ba58			.DOTF: 
ba58				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba58 1c				db WORD_SYS_CORE+8             
ba59 86 ba			dw .DOT            
ba5b 03				db 2 + 1 
ba5c .. 00			db ".>",0              
ba5f				endm 
# End of macro CWHEAD
ba5f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
ba5f					; get value off TOS and display it 
ba5f			        ; TODO BUG adds extra spaces 
ba5f			        ; TODO BUG handle numerics? 
ba5f					if DEBUG_FORTH_WORDS_KEY 
ba5f						DMARK "DTC" 
ba5f f5				push af  
ba60 3a 74 ba			ld a, (.dmark)  
ba63 32 6b ee			ld (debug_mark),a  
ba66 3a 75 ba			ld a, (.dmark+1)  
ba69 32 6c ee			ld (debug_mark+1),a  
ba6c 3a 76 ba			ld a, (.dmark+2)  
ba6f 32 6d ee			ld (debug_mark+2),a  
ba72 18 03			jr .pastdmark  
ba74 ..			.dmark: db "DTC"  
ba77 f1			.pastdmark: pop af  
ba78			endm  
# End of macro DMARK
ba78						CALLMONITOR 
ba78 cd 6f ee			call debug_vector  
ba7b				endm  
# End of macro CALLMONITOR
ba7b					endif 
ba7b 3e 01			ld a, 1 
ba7d 32 3d ea			ld (cli_mvdot), a 
ba80 c3 af ba			jp .dotgo 
ba83				NEXTW 
ba83 c3 09 9e			jp macro_next 
ba86				endm 
# End of macro NEXTW
ba86			 
ba86			.DOT: 
ba86				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
ba86 1c				db WORD_SYS_CORE+8             
ba87 62 bc			dw .CLS            
ba89 02				db 1 + 1 
ba8a .. 00			db ".",0              
ba8c				endm 
# End of macro CWHEAD
ba8c			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
ba8c					; get value off TOS and display it 
ba8c			 
ba8c					if DEBUG_FORTH_WORDS_KEY 
ba8c						DMARK "DOT" 
ba8c f5				push af  
ba8d 3a a1 ba			ld a, (.dmark)  
ba90 32 6b ee			ld (debug_mark),a  
ba93 3a a2 ba			ld a, (.dmark+1)  
ba96 32 6c ee			ld (debug_mark+1),a  
ba99 3a a3 ba			ld a, (.dmark+2)  
ba9c 32 6d ee			ld (debug_mark+2),a  
ba9f 18 03			jr .pastdmark  
baa1 ..			.dmark: db "DOT"  
baa4 f1			.pastdmark: pop af  
baa5			endm  
# End of macro DMARK
baa5						CALLMONITOR 
baa5 cd 6f ee			call debug_vector  
baa8				endm  
# End of macro CALLMONITOR
baa8					endif 
baa8 3e 00			ld a, 0 
baaa 32 3d ea			ld (cli_mvdot), a 
baad 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
baaf				 
baaf			 
baaf			.dotgo: 
baaf			 
baaf			; move up type to on stack for parserv5 
baaf					FORTH_DSP 
baaf cd 19 9c			call macro_forth_dsp 
bab2				endm 
# End of macro FORTH_DSP
bab2				;FORTH_DSP_VALUE  
bab2			 
bab2			if DEBUG_FORTH_DOT 
bab2				DMARK "DOT" 
bab2 f5				push af  
bab3 3a c7 ba			ld a, (.dmark)  
bab6 32 6b ee			ld (debug_mark),a  
bab9 3a c8 ba			ld a, (.dmark+1)  
babc 32 6c ee			ld (debug_mark+1),a  
babf 3a c9 ba			ld a, (.dmark+2)  
bac2 32 6d ee			ld (debug_mark+2),a  
bac5 18 03			jr .pastdmark  
bac7 ..			.dmark: db "DOT"  
baca f1			.pastdmark: pop af  
bacb			endm  
# End of macro DMARK
bacb				CALLMONITOR 
bacb cd 6f ee			call debug_vector  
bace				endm  
# End of macro CALLMONITOR
bace			endif	 
bace			;		.print: 
bace			 
bace 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bacf 23				inc hl   ; position to the actual value 
bad0 fe 01			cp DS_TYPE_STR 
bad2 20 06			jr nz, .dotnum1  
bad4			 
bad4			; display string 
bad4				FORTH_DSP_VALUE  
bad4 cd 3c 9c			call macro_forth_dsp_value 
bad7				endm 
# End of macro FORTH_DSP_VALUE
bad7 eb				ex de,hl 
bad8 18 49			jr .dotwrite 
bada			 
bada			.dotnum1: 
bada fe 02			cp DS_TYPE_INUM 
badc 20 44			jr nz, .dotflot 
bade			 
bade			 
bade			; display number 
bade			 
bade			;	push hl 
bade			;	call clear_display 
bade			;	pop hl 
bade			 
bade 5e				ld e, (hl) 
badf 23				inc hl 
bae0 56				ld d, (hl) 
bae1 21 c1 e2			ld hl, scratch 
bae4			if DEBUG_FORTH_DOT 
bae4				DMARK "DT1" 
bae4 f5				push af  
bae5 3a f9 ba			ld a, (.dmark)  
bae8 32 6b ee			ld (debug_mark),a  
baeb 3a fa ba			ld a, (.dmark+1)  
baee 32 6c ee			ld (debug_mark+1),a  
baf1 3a fb ba			ld a, (.dmark+2)  
baf4 32 6d ee			ld (debug_mark+2),a  
baf7 18 03			jr .pastdmark  
baf9 ..			.dmark: db "DT1"  
bafc f1			.pastdmark: pop af  
bafd			endm  
# End of macro DMARK
bafd				CALLMONITOR 
bafd cd 6f ee			call debug_vector  
bb00				endm  
# End of macro CALLMONITOR
bb00			endif	 
bb00			 
bb00 cd fd 8f			call uitoa_16 
bb03 eb				ex de,hl 
bb04			 
bb04			if DEBUG_FORTH_DOT 
bb04				DMARK "DT2" 
bb04 f5				push af  
bb05 3a 19 bb			ld a, (.dmark)  
bb08 32 6b ee			ld (debug_mark),a  
bb0b 3a 1a bb			ld a, (.dmark+1)  
bb0e 32 6c ee			ld (debug_mark+1),a  
bb11 3a 1b bb			ld a, (.dmark+2)  
bb14 32 6d ee			ld (debug_mark+2),a  
bb17 18 03			jr .pastdmark  
bb19 ..			.dmark: db "DT2"  
bb1c f1			.pastdmark: pop af  
bb1d			endm  
# End of macro DMARK
bb1d				CALLMONITOR 
bb1d cd 6f ee			call debug_vector  
bb20				endm  
# End of macro CALLMONITOR
bb20			endif	 
bb20			 
bb20			;	ld de, os_word_scratch 
bb20 18 01			jr .dotwrite 
bb22			 
bb22 00			.dotflot:   nop 
bb23			; TODO print floating point number 
bb23			 
bb23			.dotwrite:		 
bb23			 
bb23					; if c is set then set all '-' to spaces 
bb23					; need to also take into account .>  
bb23			 
bb23 3e 01				ld a, 1 
bb25 b9					cp c 
bb26 20 67				jr nz, .nodashswap 
bb28			 
bb28					; DE has the string to write, working with HL 
bb28			 
bb28 06 ff				ld b, 255 
bb2a d5					push de 
bb2b e1					pop hl 
bb2c			 
bb2c			if DEBUG_FORTH_DOT 
bb2c				DMARK "DT-" 
bb2c f5				push af  
bb2d 3a 41 bb			ld a, (.dmark)  
bb30 32 6b ee			ld (debug_mark),a  
bb33 3a 42 bb			ld a, (.dmark+1)  
bb36 32 6c ee			ld (debug_mark+1),a  
bb39 3a 43 bb			ld a, (.dmark+2)  
bb3c 32 6d ee			ld (debug_mark+2),a  
bb3f 18 03			jr .pastdmark  
bb41 ..			.dmark: db "DT-"  
bb44 f1			.pastdmark: pop af  
bb45			endm  
# End of macro DMARK
bb45				CALLMONITOR 
bb45 cd 6f ee			call debug_vector  
bb48				endm  
# End of macro CALLMONITOR
bb48			endif	 
bb48 7e			.dashscan:	ld a, (hl) 
bb49 fe 00				cp 0 
bb4b 28 42				jr z, .nodashswap 
bb4d fe 2d				cp '-' 
bb4f 20 03				jr nz, .dashskip 
bb51 3e 20				ld a, ' ' 
bb53 77					ld (hl), a 
bb54 23			.dashskip:	inc hl 
bb55			if DEBUG_FORTH_DOT 
bb55				DMARK "D-2" 
bb55 f5				push af  
bb56 3a 6a bb			ld a, (.dmark)  
bb59 32 6b ee			ld (debug_mark),a  
bb5c 3a 6b bb			ld a, (.dmark+1)  
bb5f 32 6c ee			ld (debug_mark+1),a  
bb62 3a 6c bb			ld a, (.dmark+2)  
bb65 32 6d ee			ld (debug_mark+2),a  
bb68 18 03			jr .pastdmark  
bb6a ..			.dmark: db "D-2"  
bb6d f1			.pastdmark: pop af  
bb6e			endm  
# End of macro DMARK
bb6e				CALLMONITOR 
bb6e cd 6f ee			call debug_vector  
bb71				endm  
# End of macro CALLMONITOR
bb71			endif	 
bb71 10 d5				djnz .dashscan 
bb73			 
bb73			if DEBUG_FORTH_DOT 
bb73				DMARK "D-1" 
bb73 f5				push af  
bb74 3a 88 bb			ld a, (.dmark)  
bb77 32 6b ee			ld (debug_mark),a  
bb7a 3a 89 bb			ld a, (.dmark+1)  
bb7d 32 6c ee			ld (debug_mark+1),a  
bb80 3a 8a bb			ld a, (.dmark+2)  
bb83 32 6d ee			ld (debug_mark+2),a  
bb86 18 03			jr .pastdmark  
bb88 ..			.dmark: db "D-1"  
bb8b f1			.pastdmark: pop af  
bb8c			endm  
# End of macro DMARK
bb8c				CALLMONITOR 
bb8c cd 6f ee			call debug_vector  
bb8f				endm  
# End of macro CALLMONITOR
bb8f			endif	 
bb8f			 
bb8f			.nodashswap: 
bb8f			 
bb8f			if DEBUG_FORTH_DOT 
bb8f				DMARK "D-o" 
bb8f f5				push af  
bb90 3a a4 bb			ld a, (.dmark)  
bb93 32 6b ee			ld (debug_mark),a  
bb96 3a a5 bb			ld a, (.dmark+1)  
bb99 32 6c ee			ld (debug_mark+1),a  
bb9c 3a a6 bb			ld a, (.dmark+2)  
bb9f 32 6d ee			ld (debug_mark+2),a  
bba2 18 03			jr .pastdmark  
bba4 ..			.dmark: db "D-o"  
bba7 f1			.pastdmark: pop af  
bba8			endm  
# End of macro DMARK
bba8				CALLMONITOR 
bba8 cd 6f ee			call debug_vector  
bbab				endm  
# End of macro CALLMONITOR
bbab			endif	 
bbab			 
bbab d5					push de   ; save string start in case we need to advance print 
bbac			 
bbac 3a 5e ea				ld a, (f_cursor_ptr) 
bbaf cd c1 8a				call str_at_display 
bbb2 3a 3c ea				ld a,(cli_autodisplay) 
bbb5 fe 00				cp 0 
bbb7 28 03				jr z, .noupdate 
bbb9 cd d1 8a						call update_display 
bbbc					.noupdate: 
bbbc			 
bbbc			 
bbbc					; see if we need to advance the print position 
bbbc			 
bbbc e1					pop hl   ; get back string 
bbbd			;		ex de,hl 
bbbd			 
bbbd 3a 3d ea				ld a, (cli_mvdot) 
bbc0			if DEBUG_FORTH_DOT 
bbc0			;		ld e,a 
bbc0				DMARK "D>1" 
bbc0 f5				push af  
bbc1 3a d5 bb			ld a, (.dmark)  
bbc4 32 6b ee			ld (debug_mark),a  
bbc7 3a d6 bb			ld a, (.dmark+1)  
bbca 32 6c ee			ld (debug_mark+1),a  
bbcd 3a d7 bb			ld a, (.dmark+2)  
bbd0 32 6d ee			ld (debug_mark+2),a  
bbd3 18 03			jr .pastdmark  
bbd5 ..			.dmark: db "D>1"  
bbd8 f1			.pastdmark: pop af  
bbd9			endm  
# End of macro DMARK
bbd9				CALLMONITOR 
bbd9 cd 6f ee			call debug_vector  
bbdc				endm  
# End of macro CALLMONITOR
bbdc			endif	 
bbdc fe 00				cp 0 
bbde 28 44				jr z, .noadv 
bbe0					; yes, lets advance the print position 
bbe0 3e 00				ld a, 0 
bbe2 cd 59 90				call strlent 
bbe5			if DEBUG_FORTH_DOT 
bbe5				DMARK "D-?" 
bbe5 f5				push af  
bbe6 3a fa bb			ld a, (.dmark)  
bbe9 32 6b ee			ld (debug_mark),a  
bbec 3a fb bb			ld a, (.dmark+1)  
bbef 32 6c ee			ld (debug_mark+1),a  
bbf2 3a fc bb			ld a, (.dmark+2)  
bbf5 32 6d ee			ld (debug_mark+2),a  
bbf8 18 03			jr .pastdmark  
bbfa ..			.dmark: db "D-?"  
bbfd f1			.pastdmark: pop af  
bbfe			endm  
# End of macro DMARK
bbfe				CALLMONITOR 
bbfe cd 6f ee			call debug_vector  
bc01				endm  
# End of macro CALLMONITOR
bc01			endif	 
bc01 3a 5e ea				ld a, (f_cursor_ptr) 
bc04 85					add a,l 
bc05					;call addatohl 
bc05					;ld a, l 
bc05 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bc08			 
bc08			if DEBUG_FORTH_DOT 
bc08				DMARK "D->" 
bc08 f5				push af  
bc09 3a 1d bc			ld a, (.dmark)  
bc0c 32 6b ee			ld (debug_mark),a  
bc0f 3a 1e bc			ld a, (.dmark+1)  
bc12 32 6c ee			ld (debug_mark+1),a  
bc15 3a 1f bc			ld a, (.dmark+2)  
bc18 32 6d ee			ld (debug_mark+2),a  
bc1b 18 03			jr .pastdmark  
bc1d ..			.dmark: db "D->"  
bc20 f1			.pastdmark: pop af  
bc21			endm  
# End of macro DMARK
bc21				CALLMONITOR 
bc21 cd 6f ee			call debug_vector  
bc24				endm  
# End of macro CALLMONITOR
bc24			endif	 
bc24			 
bc24			.noadv:	 
bc24			 
bc24					if DEBUG_FORTH_DOT_WAIT 
bc24							call next_page_prompt 
bc24					endif	 
bc24			; TODO this pop off the stack causes a crash. i dont know why 
bc24			 
bc24			 
bc24			if DEBUG_FORTH_DOT 
bc24				DMARK "DTh" 
bc24 f5				push af  
bc25 3a 39 bc			ld a, (.dmark)  
bc28 32 6b ee			ld (debug_mark),a  
bc2b 3a 3a bc			ld a, (.dmark+1)  
bc2e 32 6c ee			ld (debug_mark+1),a  
bc31 3a 3b bc			ld a, (.dmark+2)  
bc34 32 6d ee			ld (debug_mark+2),a  
bc37 18 03			jr .pastdmark  
bc39 ..			.dmark: db "DTh"  
bc3c f1			.pastdmark: pop af  
bc3d			endm  
# End of macro DMARK
bc3d				CALLMONITOR 
bc3d cd 6f ee			call debug_vector  
bc40				endm  
# End of macro CALLMONITOR
bc40			endif	 
bc40			 
bc40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc40 cd 0b 9d			call macro_forth_dsp_pop 
bc43				endm 
# End of macro FORTH_DSP_POP
bc43			 
bc43			if DEBUG_FORTH_DOT 
bc43				DMARK "DTi" 
bc43 f5				push af  
bc44 3a 58 bc			ld a, (.dmark)  
bc47 32 6b ee			ld (debug_mark),a  
bc4a 3a 59 bc			ld a, (.dmark+1)  
bc4d 32 6c ee			ld (debug_mark+1),a  
bc50 3a 5a bc			ld a, (.dmark+2)  
bc53 32 6d ee			ld (debug_mark+2),a  
bc56 18 03			jr .pastdmark  
bc58 ..			.dmark: db "DTi"  
bc5b f1			.pastdmark: pop af  
bc5c			endm  
# End of macro DMARK
bc5c				CALLMONITOR 
bc5c cd 6f ee			call debug_vector  
bc5f				endm  
# End of macro CALLMONITOR
bc5f			endif	 
bc5f			 
bc5f			 
bc5f					NEXTW 
bc5f c3 09 9e			jp macro_next 
bc62				endm 
# End of macro NEXTW
bc62			 
bc62			.CLS: 
bc62				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc62 35				db WORD_SYS_CORE+33             
bc63 8f bc			dw .DRAW            
bc65 04				db 3 + 1 
bc66 .. 00			db "CLS",0              
bc6a				endm 
# End of macro CWHEAD
bc6a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc6a					if DEBUG_FORTH_WORDS_KEY 
bc6a						DMARK "CLS" 
bc6a f5				push af  
bc6b 3a 7f bc			ld a, (.dmark)  
bc6e 32 6b ee			ld (debug_mark),a  
bc71 3a 80 bc			ld a, (.dmark+1)  
bc74 32 6c ee			ld (debug_mark+1),a  
bc77 3a 81 bc			ld a, (.dmark+2)  
bc7a 32 6d ee			ld (debug_mark+2),a  
bc7d 18 03			jr .pastdmark  
bc7f ..			.dmark: db "CLS"  
bc82 f1			.pastdmark: pop af  
bc83			endm  
# End of macro DMARK
bc83						CALLMONITOR 
bc83 cd 6f ee			call debug_vector  
bc86				endm  
# End of macro CALLMONITOR
bc86					endif 
bc86 cd ae 8a				call clear_display 
bc89 c3 9d bd				jp .home		; and home cursor 
bc8c					NEXTW 
bc8c c3 09 9e			jp macro_next 
bc8f				endm 
# End of macro NEXTW
bc8f			 
bc8f			.DRAW: 
bc8f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bc8f 36				db WORD_SYS_CORE+34             
bc90 ba bc			dw .DUMP            
bc92 05				db 4 + 1 
bc93 .. 00			db "DRAW",0              
bc98				endm 
# End of macro CWHEAD
bc98			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bc98					if DEBUG_FORTH_WORDS_KEY 
bc98						DMARK "DRW" 
bc98 f5				push af  
bc99 3a ad bc			ld a, (.dmark)  
bc9c 32 6b ee			ld (debug_mark),a  
bc9f 3a ae bc			ld a, (.dmark+1)  
bca2 32 6c ee			ld (debug_mark+1),a  
bca5 3a af bc			ld a, (.dmark+2)  
bca8 32 6d ee			ld (debug_mark+2),a  
bcab 18 03			jr .pastdmark  
bcad ..			.dmark: db "DRW"  
bcb0 f1			.pastdmark: pop af  
bcb1			endm  
# End of macro DMARK
bcb1						CALLMONITOR 
bcb1 cd 6f ee			call debug_vector  
bcb4				endm  
# End of macro CALLMONITOR
bcb4					endif 
bcb4 cd d1 8a				call update_display 
bcb7					NEXTW 
bcb7 c3 09 9e			jp macro_next 
bcba				endm 
# End of macro NEXTW
bcba			 
bcba			.DUMP: 
bcba				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bcba 37				db WORD_SYS_CORE+35             
bcbb f2 bc			dw .CDUMP            
bcbd 05				db 4 + 1 
bcbe .. 00			db "DUMP",0              
bcc3				endm 
# End of macro CWHEAD
bcc3			; | DUMP ( x -- ) With address x display dump   | DONE 
bcc3			; TODO pop address to use off of the stack 
bcc3					if DEBUG_FORTH_WORDS_KEY 
bcc3						DMARK "DUM" 
bcc3 f5				push af  
bcc4 3a d8 bc			ld a, (.dmark)  
bcc7 32 6b ee			ld (debug_mark),a  
bcca 3a d9 bc			ld a, (.dmark+1)  
bccd 32 6c ee			ld (debug_mark+1),a  
bcd0 3a da bc			ld a, (.dmark+2)  
bcd3 32 6d ee			ld (debug_mark+2),a  
bcd6 18 03			jr .pastdmark  
bcd8 ..			.dmark: db "DUM"  
bcdb f1			.pastdmark: pop af  
bcdc			endm  
# End of macro DMARK
bcdc						CALLMONITOR 
bcdc cd 6f ee			call debug_vector  
bcdf				endm  
# End of macro CALLMONITOR
bcdf					endif 
bcdf cd ae 8a				call clear_display 
bce2			 
bce2					; get address 
bce2			 
bce2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bce2 cd 53 9c			call macro_dsp_valuehl 
bce5				endm 
# End of macro FORTH_DSP_VALUEHL
bce5				 
bce5					; save it for cdump 
bce5			 
bce5 22 e4 e5				ld (os_cur_ptr),hl 
bce8			 
bce8					; destroy value TOS 
bce8			 
bce8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bce8 cd 0b 9d			call macro_forth_dsp_pop 
bceb				endm 
# End of macro FORTH_DSP_POP
bceb			 
bceb cd dc 98				call dumpcont	; skip old style of param parsing	 
bcee c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bcef					NEXTW 
bcef c3 09 9e			jp macro_next 
bcf2				endm 
# End of macro NEXTW
bcf2			.CDUMP: 
bcf2				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bcf2 38				db WORD_SYS_CORE+36             
bcf3 22 bd			dw .DAT            
bcf5 06				db 5 + 1 
bcf6 .. 00			db "CDUMP",0              
bcfc				endm 
# End of macro CWHEAD
bcfc			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bcfc					if DEBUG_FORTH_WORDS_KEY 
bcfc						DMARK "CDP" 
bcfc f5				push af  
bcfd 3a 11 bd			ld a, (.dmark)  
bd00 32 6b ee			ld (debug_mark),a  
bd03 3a 12 bd			ld a, (.dmark+1)  
bd06 32 6c ee			ld (debug_mark+1),a  
bd09 3a 13 bd			ld a, (.dmark+2)  
bd0c 32 6d ee			ld (debug_mark+2),a  
bd0f 18 03			jr .pastdmark  
bd11 ..			.dmark: db "CDP"  
bd14 f1			.pastdmark: pop af  
bd15			endm  
# End of macro DMARK
bd15						CALLMONITOR 
bd15 cd 6f ee			call debug_vector  
bd18				endm  
# End of macro CALLMONITOR
bd18					endif 
bd18 cd ae 8a				call clear_display 
bd1b cd dc 98				call dumpcont	 
bd1e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd1f					NEXTW 
bd1f c3 09 9e			jp macro_next 
bd22				endm 
# End of macro NEXTW
bd22			 
bd22			 
bd22			 
bd22			 
bd22			.DAT: 
bd22				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd22 3d				db WORD_SYS_CORE+41             
bd23 78 bd			dw .HOME            
bd25 03				db 2 + 1 
bd26 .. 00			db "AT",0              
bd29				endm 
# End of macro CWHEAD
bd29			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd29					if DEBUG_FORTH_WORDS_KEY 
bd29						DMARK "AT." 
bd29 f5				push af  
bd2a 3a 3e bd			ld a, (.dmark)  
bd2d 32 6b ee			ld (debug_mark),a  
bd30 3a 3f bd			ld a, (.dmark+1)  
bd33 32 6c ee			ld (debug_mark+1),a  
bd36 3a 40 bd			ld a, (.dmark+2)  
bd39 32 6d ee			ld (debug_mark+2),a  
bd3c 18 03			jr .pastdmark  
bd3e ..			.dmark: db "AT."  
bd41 f1			.pastdmark: pop af  
bd42			endm  
# End of macro DMARK
bd42						CALLMONITOR 
bd42 cd 6f ee			call debug_vector  
bd45				endm  
# End of macro CALLMONITOR
bd45					endif 
bd45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd45 cd 53 9c			call macro_dsp_valuehl 
bd48				endm 
# End of macro FORTH_DSP_VALUEHL
bd48			 
bd48			 
bd48					; TODO save cursor row 
bd48 7d					ld a,l 
bd49 fe 02				cp 2 
bd4b 20 04				jr nz, .crow3 
bd4d 3e 28				ld a, display_row_2 
bd4f 18 12				jr .ccol1 
bd51 fe 03		.crow3:		cp 3 
bd53 20 04				jr nz, .crow4 
bd55 3e 50				ld a, display_row_3 
bd57 18 0a				jr .ccol1 
bd59 fe 04		.crow4:		cp 4 
bd5b 20 04				jr nz, .crow1 
bd5d 3e 78				ld a, display_row_4 
bd5f 18 02				jr .ccol1 
bd61 3e 00		.crow1:		ld a,display_row_1 
bd63 f5			.ccol1:		push af			; got row offset 
bd64 6f					ld l,a 
bd65 26 00				ld h,0 
bd67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd67 cd 0b 9d			call macro_forth_dsp_pop 
bd6a				endm 
# End of macro FORTH_DSP_POP
bd6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd6a cd 53 9c			call macro_dsp_valuehl 
bd6d				endm 
# End of macro FORTH_DSP_VALUEHL
bd6d					; TODO save cursor col 
bd6d f1					pop af 
bd6e 85					add l		; add col offset 
bd6f 32 5e ea				ld (f_cursor_ptr), a 
bd72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd72 cd 0b 9d			call macro_forth_dsp_pop 
bd75				endm 
# End of macro FORTH_DSP_POP
bd75			 
bd75					; calculate  
bd75			 
bd75					NEXTW 
bd75 c3 09 9e			jp macro_next 
bd78				endm 
# End of macro NEXTW
bd78			 
bd78			 
bd78			.HOME: 
bd78				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
bd78 41				db WORD_SYS_CORE+45             
bd79 a5 bd			dw .CR            
bd7b 05				db 4 + 1 
bd7c .. 00			db "HOME",0              
bd81				endm 
# End of macro CWHEAD
bd81			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bd81					if DEBUG_FORTH_WORDS_KEY 
bd81						DMARK "HOM" 
bd81 f5				push af  
bd82 3a 96 bd			ld a, (.dmark)  
bd85 32 6b ee			ld (debug_mark),a  
bd88 3a 97 bd			ld a, (.dmark+1)  
bd8b 32 6c ee			ld (debug_mark+1),a  
bd8e 3a 98 bd			ld a, (.dmark+2)  
bd91 32 6d ee			ld (debug_mark+2),a  
bd94 18 03			jr .pastdmark  
bd96 ..			.dmark: db "HOM"  
bd99 f1			.pastdmark: pop af  
bd9a			endm  
# End of macro DMARK
bd9a						CALLMONITOR 
bd9a cd 6f ee			call debug_vector  
bd9d				endm  
# End of macro CALLMONITOR
bd9d					endif 
bd9d 3e 00		.home:		ld a, 0		; and home cursor 
bd9f 32 5e ea				ld (f_cursor_ptr), a 
bda2					NEXTW 
bda2 c3 09 9e			jp macro_next 
bda5				endm 
# End of macro NEXTW
bda5			 
bda5			 
bda5			.CR: 
bda5				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
bda5 46				db WORD_SYS_CORE+50             
bda6 e0 bd			dw .SPACE            
bda8 03				db 2 + 1 
bda9 .. 00			db "CR",0              
bdac				endm 
# End of macro CWHEAD
bdac			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
bdac					if DEBUG_FORTH_WORDS_KEY 
bdac						DMARK "CR." 
bdac f5				push af  
bdad 3a c1 bd			ld a, (.dmark)  
bdb0 32 6b ee			ld (debug_mark),a  
bdb3 3a c2 bd			ld a, (.dmark+1)  
bdb6 32 6c ee			ld (debug_mark+1),a  
bdb9 3a c3 bd			ld a, (.dmark+2)  
bdbc 32 6d ee			ld (debug_mark+2),a  
bdbf 18 03			jr .pastdmark  
bdc1 ..			.dmark: db "CR."  
bdc4 f1			.pastdmark: pop af  
bdc5			endm  
# End of macro DMARK
bdc5						CALLMONITOR 
bdc5 cd 6f ee			call debug_vector  
bdc8				endm  
# End of macro CALLMONITOR
bdc8					endif 
bdc8 3e 0d				ld a, 13 
bdca 32 c1 e2				ld (scratch),a 
bdcd 3e 0a				ld a, 10 
bdcf 32 c2 e2				ld (scratch+1),a 
bdd2 3e 00				ld a, 0 
bdd4 32 c3 e2				ld (scratch+2),a 
bdd7 21 c1 e2				ld hl, scratch 
bdda cd ca 9a				call forth_push_str 
bddd					 
bddd				       NEXTW 
bddd c3 09 9e			jp macro_next 
bde0				endm 
# End of macro NEXTW
bde0			.SPACE: 
bde0				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bde0 46				db WORD_SYS_CORE+50             
bde1 16 be			dw .SPACES            
bde3 03				db 2 + 1 
bde4 .. 00			db "BL",0              
bde7				endm 
# End of macro CWHEAD
bde7			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bde7					if DEBUG_FORTH_WORDS_KEY 
bde7						DMARK "BL." 
bde7 f5				push af  
bde8 3a fc bd			ld a, (.dmark)  
bdeb 32 6b ee			ld (debug_mark),a  
bdee 3a fd bd			ld a, (.dmark+1)  
bdf1 32 6c ee			ld (debug_mark+1),a  
bdf4 3a fe bd			ld a, (.dmark+2)  
bdf7 32 6d ee			ld (debug_mark+2),a  
bdfa 18 03			jr .pastdmark  
bdfc ..			.dmark: db "BL."  
bdff f1			.pastdmark: pop af  
be00			endm  
# End of macro DMARK
be00						CALLMONITOR 
be00 cd 6f ee			call debug_vector  
be03				endm  
# End of macro CALLMONITOR
be03					endif 
be03 3e 20				ld a, " " 
be05 32 c1 e2				ld (scratch),a 
be08 3e 00				ld a, 0 
be0a 32 c2 e2				ld (scratch+1),a 
be0d 21 c1 e2				ld hl, scratch 
be10 cd ca 9a				call forth_push_str 
be13					 
be13				       NEXTW 
be13 c3 09 9e			jp macro_next 
be16				endm 
# End of macro NEXTW
be16			 
be16			;.blstr: db " ", 0 
be16			 
be16			.SPACES: 
be16				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be16 47				db WORD_SYS_CORE+51             
be17 b1 be			dw .SCROLL            
be19 07				db 6 + 1 
be1a .. 00			db "SPACES",0              
be21				endm 
# End of macro CWHEAD
be21			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be21					if DEBUG_FORTH_WORDS_KEY 
be21						DMARK "SPS" 
be21 f5				push af  
be22 3a 36 be			ld a, (.dmark)  
be25 32 6b ee			ld (debug_mark),a  
be28 3a 37 be			ld a, (.dmark+1)  
be2b 32 6c ee			ld (debug_mark+1),a  
be2e 3a 38 be			ld a, (.dmark+2)  
be31 32 6d ee			ld (debug_mark+2),a  
be34 18 03			jr .pastdmark  
be36 ..			.dmark: db "SPS"  
be39 f1			.pastdmark: pop af  
be3a			endm  
# End of macro DMARK
be3a						CALLMONITOR 
be3a cd 6f ee			call debug_vector  
be3d				endm  
# End of macro CALLMONITOR
be3d					endif 
be3d			 
be3d			 
be3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be3d cd 53 9c			call macro_dsp_valuehl 
be40				endm 
# End of macro FORTH_DSP_VALUEHL
be40			 
be40 e5					push hl    ; u 
be41					if DEBUG_FORTH_WORDS 
be41						DMARK "SPA" 
be41 f5				push af  
be42 3a 56 be			ld a, (.dmark)  
be45 32 6b ee			ld (debug_mark),a  
be48 3a 57 be			ld a, (.dmark+1)  
be4b 32 6c ee			ld (debug_mark+1),a  
be4e 3a 58 be			ld a, (.dmark+2)  
be51 32 6d ee			ld (debug_mark+2),a  
be54 18 03			jr .pastdmark  
be56 ..			.dmark: db "SPA"  
be59 f1			.pastdmark: pop af  
be5a			endm  
# End of macro DMARK
be5a						CALLMONITOR 
be5a cd 6f ee			call debug_vector  
be5d				endm  
# End of macro CALLMONITOR
be5d					endif 
be5d			 
be5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be5d cd 0b 9d			call macro_forth_dsp_pop 
be60				endm 
# End of macro FORTH_DSP_POP
be60 e1					pop hl 
be61 0e 00				ld c, 0 
be63 45					ld b, l 
be64 21 c1 e2				ld hl, scratch  
be67			 
be67					if DEBUG_FORTH_WORDS 
be67						DMARK "SP2" 
be67 f5				push af  
be68 3a 7c be			ld a, (.dmark)  
be6b 32 6b ee			ld (debug_mark),a  
be6e 3a 7d be			ld a, (.dmark+1)  
be71 32 6c ee			ld (debug_mark+1),a  
be74 3a 7e be			ld a, (.dmark+2)  
be77 32 6d ee			ld (debug_mark+2),a  
be7a 18 03			jr .pastdmark  
be7c ..			.dmark: db "SP2"  
be7f f1			.pastdmark: pop af  
be80			endm  
# End of macro DMARK
be80						CALLMONITOR 
be80 cd 6f ee			call debug_vector  
be83				endm  
# End of macro CALLMONITOR
be83					endif 
be83 3e 20				ld a, ' ' 
be85			.spaces1:	 
be85 77					ld (hl),a 
be86 23					inc hl 
be87					 
be87 10 fc				djnz .spaces1 
be89 3e 00				ld a,0 
be8b 77					ld (hl),a 
be8c 21 c1 e2				ld hl, scratch 
be8f					if DEBUG_FORTH_WORDS 
be8f						DMARK "SP3" 
be8f f5				push af  
be90 3a a4 be			ld a, (.dmark)  
be93 32 6b ee			ld (debug_mark),a  
be96 3a a5 be			ld a, (.dmark+1)  
be99 32 6c ee			ld (debug_mark+1),a  
be9c 3a a6 be			ld a, (.dmark+2)  
be9f 32 6d ee			ld (debug_mark+2),a  
bea2 18 03			jr .pastdmark  
bea4 ..			.dmark: db "SP3"  
bea7 f1			.pastdmark: pop af  
bea8			endm  
# End of macro DMARK
bea8						CALLMONITOR 
bea8 cd 6f ee			call debug_vector  
beab				endm  
# End of macro CALLMONITOR
beab					endif 
beab cd ca 9a				call forth_push_str 
beae			 
beae				       NEXTW 
beae c3 09 9e			jp macro_next 
beb1				endm 
# End of macro NEXTW
beb1			 
beb1			 
beb1			 
beb1			.SCROLL: 
beb1				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
beb1 53				db WORD_SYS_CORE+63             
beb2 de be			dw .SCROLLD            
beb4 07				db 6 + 1 
beb5 .. 00			db "SCROLL",0              
bebc				endm 
# End of macro CWHEAD
bebc			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bebc					if DEBUG_FORTH_WORDS_KEY 
bebc						DMARK "SCR" 
bebc f5				push af  
bebd 3a d1 be			ld a, (.dmark)  
bec0 32 6b ee			ld (debug_mark),a  
bec3 3a d2 be			ld a, (.dmark+1)  
bec6 32 6c ee			ld (debug_mark+1),a  
bec9 3a d3 be			ld a, (.dmark+2)  
becc 32 6d ee			ld (debug_mark+2),a  
becf 18 03			jr .pastdmark  
bed1 ..			.dmark: db "SCR"  
bed4 f1			.pastdmark: pop af  
bed5			endm  
# End of macro DMARK
bed5						CALLMONITOR 
bed5 cd 6f ee			call debug_vector  
bed8				endm  
# End of macro CALLMONITOR
bed8					endif 
bed8			 
bed8 cd 70 8a			call scroll_up 
bedb			;	call update_display 
bedb			 
bedb					NEXTW 
bedb c3 09 9e			jp macro_next 
bede				endm 
# End of macro NEXTW
bede			 
bede			 
bede			 
bede			;		; get dir 
bede			; 
bede			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bede			; 
bede			;		push hl 
bede			; 
bede			;		; destroy value TOS 
bede			; 
bede			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bede			; 
bede			;		; get count 
bede			; 
bede			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bede			; 
bede			;		push hl 
bede			; 
bede			;		; destroy value TOS 
bede			; 
bede			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bede			; 
bede			;		; one value on hl get other one back 
bede			; 
bede			;		pop bc    ; count 
bede			; 
bede			;		pop de   ; dir 
bede			; 
bede			; 
bede			;		ld b, c 
bede			; 
bede			;.scrolldir:     push bc 
bede			;		push de 
bede			; 
bede			;		ld a, 0 
bede			;		cp e 
bede			;		jr z, .scrollup  
bede			;		call scroll_down 
bede			;		jr .scrollnext 
bede			;.scrollup:	call scroll_up 
bede			; 
bede			;		 
bede			;.scrollnext: 
bede			;		pop de 
bede			;		pop bc 
bede			;		djnz .scrolldir 
bede			; 
bede			; 
bede			; 
bede			; 
bede			; 
bede			;		NEXTW 
bede			 
bede			.SCROLLD: 
bede				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bede 53				db WORD_SYS_CORE+63             
bedf 0c bf			dw .ATQ            
bee1 08				db 7 + 1 
bee2 .. 00			db "SCROLLD",0              
beea				endm 
# End of macro CWHEAD
beea			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
beea					if DEBUG_FORTH_WORDS_KEY 
beea						DMARK "SCD" 
beea f5				push af  
beeb 3a ff be			ld a, (.dmark)  
beee 32 6b ee			ld (debug_mark),a  
bef1 3a 00 bf			ld a, (.dmark+1)  
bef4 32 6c ee			ld (debug_mark+1),a  
bef7 3a 01 bf			ld a, (.dmark+2)  
befa 32 6d ee			ld (debug_mark+2),a  
befd 18 03			jr .pastdmark  
beff ..			.dmark: db "SCD"  
bf02 f1			.pastdmark: pop af  
bf03			endm  
# End of macro DMARK
bf03						CALLMONITOR 
bf03 cd 6f ee			call debug_vector  
bf06				endm  
# End of macro CALLMONITOR
bf06					endif 
bf06			 
bf06 cd 94 8a			call scroll_down 
bf09			;	call update_display 
bf09			 
bf09					NEXTW 
bf09 c3 09 9e			jp macro_next 
bf0c				endm 
# End of macro NEXTW
bf0c			 
bf0c			 
bf0c			.ATQ: 
bf0c				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf0c 62				db WORD_SYS_CORE+78             
bf0d 6a bf			dw .AUTODSP            
bf0f 04				db 3 + 1 
bf10 .. 00			db "AT@",0              
bf14				endm 
# End of macro CWHEAD
bf14			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf14					if DEBUG_FORTH_WORDS_KEY 
bf14						DMARK "ATA" 
bf14 f5				push af  
bf15 3a 29 bf			ld a, (.dmark)  
bf18 32 6b ee			ld (debug_mark),a  
bf1b 3a 2a bf			ld a, (.dmark+1)  
bf1e 32 6c ee			ld (debug_mark+1),a  
bf21 3a 2b bf			ld a, (.dmark+2)  
bf24 32 6d ee			ld (debug_mark+2),a  
bf27 18 03			jr .pastdmark  
bf29 ..			.dmark: db "ATA"  
bf2c f1			.pastdmark: pop af  
bf2d			endm  
# End of macro DMARK
bf2d						CALLMONITOR 
bf2d cd 6f ee			call debug_vector  
bf30				endm  
# End of macro CALLMONITOR
bf30					endif 
bf30			 
bf30			 
bf30					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf30 cd 53 9c			call macro_dsp_valuehl 
bf33				endm 
# End of macro FORTH_DSP_VALUEHL
bf33			 
bf33					; TODO save cursor row 
bf33 7d					ld a,l 
bf34 fe 02				cp 2 
bf36 20 04				jr nz, .crow3aq 
bf38 3e 28				ld a, display_row_2 
bf3a 18 12				jr .ccol1aq 
bf3c fe 03		.crow3aq:		cp 3 
bf3e 20 04				jr nz, .crow4aq 
bf40 3e 50				ld a, display_row_3 
bf42 18 0a				jr .ccol1aq 
bf44 fe 04		.crow4aq:		cp 4 
bf46 20 04				jr nz, .crow1aq 
bf48 3e 78				ld a, display_row_4 
bf4a 18 02				jr .ccol1aq 
bf4c 3e 00		.crow1aq:		ld a,display_row_1 
bf4e f5			.ccol1aq:		push af			; got row offset 
bf4f 6f					ld l,a 
bf50 26 00				ld h,0 
bf52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf52 cd 0b 9d			call macro_forth_dsp_pop 
bf55				endm 
# End of macro FORTH_DSP_POP
bf55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf55 cd 53 9c			call macro_dsp_valuehl 
bf58				endm 
# End of macro FORTH_DSP_VALUEHL
bf58					; TODO save cursor col 
bf58 f1					pop af 
bf59 85					add l		; add col offset 
bf5a			 
bf5a					; add current frame buffer address 
bf5a 2a cc eb				ld hl, (display_fb_active) 
bf5d cd db 8c				call addatohl 
bf60			 
bf60			 
bf60			 
bf60			 
bf60					; get char frame buffer location offset in hl 
bf60			 
bf60 7e					ld a,(hl) 
bf61 26 00				ld h, 0 
bf63 6f					ld l, a 
bf64			 
bf64 cd 5c 9a				call forth_push_numhl 
bf67			 
bf67			 
bf67					NEXTW 
bf67 c3 09 9e			jp macro_next 
bf6a				endm 
# End of macro NEXTW
bf6a			 
bf6a			.AUTODSP: 
bf6a				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf6a 63				db WORD_SYS_CORE+79             
bf6b 80 bf			dw .MENU            
bf6d 05				db 4 + 1 
bf6e .. 00			db "ADSP",0              
bf73				endm 
# End of macro CWHEAD
bf73			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf73			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf73			 
bf73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf73 cd 53 9c			call macro_dsp_valuehl 
bf76				endm 
# End of macro FORTH_DSP_VALUEHL
bf76			 
bf76			;		push hl 
bf76			 
bf76					; destroy value TOS 
bf76			 
bf76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf76 cd 0b 9d			call macro_forth_dsp_pop 
bf79				endm 
# End of macro FORTH_DSP_POP
bf79			 
bf79			;		pop hl 
bf79			 
bf79 7d					ld a,l 
bf7a 32 3c ea				ld (cli_autodisplay), a 
bf7d				       NEXTW 
bf7d c3 09 9e			jp macro_next 
bf80				endm 
# End of macro NEXTW
bf80			 
bf80			.MENU: 
bf80				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf80 70				db WORD_SYS_CORE+92             
bf81 29 c0			dw .ENDDISPLAY            
bf83 05				db 4 + 1 
bf84 .. 00			db "MENU",0              
bf89				endm 
# End of macro CWHEAD
bf89			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
bf89			 
bf89			;		; get number of items on the stack 
bf89			; 
bf89				 
bf89					FORTH_DSP_VALUEHL 
bf89 cd 53 9c			call macro_dsp_valuehl 
bf8c				endm 
# End of macro FORTH_DSP_VALUEHL
bf8c				 
bf8c					if DEBUG_FORTH_WORDS_KEY 
bf8c						DMARK "MNU" 
bf8c f5				push af  
bf8d 3a a1 bf			ld a, (.dmark)  
bf90 32 6b ee			ld (debug_mark),a  
bf93 3a a2 bf			ld a, (.dmark+1)  
bf96 32 6c ee			ld (debug_mark+1),a  
bf99 3a a3 bf			ld a, (.dmark+2)  
bf9c 32 6d ee			ld (debug_mark+2),a  
bf9f 18 03			jr .pastdmark  
bfa1 ..			.dmark: db "MNU"  
bfa4 f1			.pastdmark: pop af  
bfa5			endm  
# End of macro DMARK
bfa5						CALLMONITOR 
bfa5 cd 6f ee			call debug_vector  
bfa8				endm  
# End of macro CALLMONITOR
bfa8					endif 
bfa8			 
bfa8 45					ld b, l	 
bfa9 05					dec b 
bfaa			 
bfaa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfaa cd 0b 9d			call macro_forth_dsp_pop 
bfad				endm 
# End of macro FORTH_DSP_POP
bfad			 
bfad			 
bfad					; go directly through the stack to pluck out the string pointers and build an array 
bfad			 
bfad			;		FORTH_DSP 
bfad			 
bfad					; hl contains top most stack item 
bfad				 
bfad 11 c1 e2				ld de, scratch 
bfb0			 
bfb0			.mbuild: 
bfb0			 
bfb0					FORTH_DSP_VALUEHL 
bfb0 cd 53 9c			call macro_dsp_valuehl 
bfb3				endm 
# End of macro FORTH_DSP_VALUEHL
bfb3			 
bfb3					if DEBUG_FORTH_WORDS 
bfb3						DMARK "MN3" 
bfb3 f5				push af  
bfb4 3a c8 bf			ld a, (.dmark)  
bfb7 32 6b ee			ld (debug_mark),a  
bfba 3a c9 bf			ld a, (.dmark+1)  
bfbd 32 6c ee			ld (debug_mark+1),a  
bfc0 3a ca bf			ld a, (.dmark+2)  
bfc3 32 6d ee			ld (debug_mark+2),a  
bfc6 18 03			jr .pastdmark  
bfc8 ..			.dmark: db "MN3"  
bfcb f1			.pastdmark: pop af  
bfcc			endm  
# End of macro DMARK
bfcc						CALLMONITOR 
bfcc cd 6f ee			call debug_vector  
bfcf				endm  
# End of macro CALLMONITOR
bfcf					endif 
bfcf eb					ex de, hl 
bfd0 73					ld (hl), e 
bfd1 23					inc hl 
bfd2 72					ld (hl), d 
bfd3 23					inc hl 
bfd4 eb					ex de, hl 
bfd5			 
bfd5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfd5 cd 0b 9d			call macro_forth_dsp_pop 
bfd8				endm 
# End of macro FORTH_DSP_POP
bfd8			 
bfd8 10 d6				djnz .mbuild 
bfda			 
bfda					; done add term 
bfda			 
bfda eb					ex de, hl 
bfdb 36 00				ld (hl), 0 
bfdd 23					inc hl 
bfde 36 00				ld (hl), 0 
bfe0			 
bfe0				 
bfe0					 
bfe0 21 c1 e2				ld hl, scratch 
bfe3			 
bfe3					if DEBUG_FORTH_WORDS 
bfe3						DMARK "MNx" 
bfe3 f5				push af  
bfe4 3a f8 bf			ld a, (.dmark)  
bfe7 32 6b ee			ld (debug_mark),a  
bfea 3a f9 bf			ld a, (.dmark+1)  
bfed 32 6c ee			ld (debug_mark+1),a  
bff0 3a fa bf			ld a, (.dmark+2)  
bff3 32 6d ee			ld (debug_mark+2),a  
bff6 18 03			jr .pastdmark  
bff8 ..			.dmark: db "MNx"  
bffb f1			.pastdmark: pop af  
bffc			endm  
# End of macro DMARK
bffc						CALLMONITOR 
bffc cd 6f ee			call debug_vector  
bfff				endm  
# End of macro CALLMONITOR
bfff					endif 
bfff			 
bfff			 
bfff			 
bfff 3e 00				ld a, 0 
c001 cd df 8a				call menu 
c004			 
c004			 
c004 6f					ld l, a 
c005 26 00				ld h, 0 
c007			 
c007					if DEBUG_FORTH_WORDS 
c007						DMARK "MNr" 
c007 f5				push af  
c008 3a 1c c0			ld a, (.dmark)  
c00b 32 6b ee			ld (debug_mark),a  
c00e 3a 1d c0			ld a, (.dmark+1)  
c011 32 6c ee			ld (debug_mark+1),a  
c014 3a 1e c0			ld a, (.dmark+2)  
c017 32 6d ee			ld (debug_mark+2),a  
c01a 18 03			jr .pastdmark  
c01c ..			.dmark: db "MNr"  
c01f f1			.pastdmark: pop af  
c020			endm  
# End of macro DMARK
c020						CALLMONITOR 
c020 cd 6f ee			call debug_vector  
c023				endm  
# End of macro CALLMONITOR
c023					endif 
c023			 
c023 cd 5c 9a				call forth_push_numhl 
c026			 
c026			 
c026			 
c026			 
c026				       NEXTW 
c026 c3 09 9e			jp macro_next 
c029				endm 
# End of macro NEXTW
c029			 
c029			 
c029			.ENDDISPLAY: 
c029			 
c029			; eof 
# End of file forth_words_display.asm
c029			include "forth_words_str.asm" 
c029			 
c029			; | ## String Words 
c029			 
c029			.PTR:   
c029			 
c029				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c029 48				db WORD_SYS_CORE+52             
c02a 56 c0			dw .STYPE            
c02c 04				db 3 + 1 
c02d .. 00			db "PTR",0              
c031				endm 
# End of macro CWHEAD
c031			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c031			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c031			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c031			 
c031					if DEBUG_FORTH_WORDS_KEY 
c031						DMARK "PTR" 
c031 f5				push af  
c032 3a 46 c0			ld a, (.dmark)  
c035 32 6b ee			ld (debug_mark),a  
c038 3a 47 c0			ld a, (.dmark+1)  
c03b 32 6c ee			ld (debug_mark+1),a  
c03e 3a 48 c0			ld a, (.dmark+2)  
c041 32 6d ee			ld (debug_mark+2),a  
c044 18 03			jr .pastdmark  
c046 ..			.dmark: db "PTR"  
c049 f1			.pastdmark: pop af  
c04a			endm  
# End of macro DMARK
c04a						CALLMONITOR 
c04a cd 6f ee			call debug_vector  
c04d				endm  
# End of macro CALLMONITOR
c04d					endif 
c04d					FORTH_DSP_VALUEHL 
c04d cd 53 9c			call macro_dsp_valuehl 
c050				endm 
# End of macro FORTH_DSP_VALUEHL
c050 cd 5c 9a				call forth_push_numhl 
c053			 
c053			 
c053					NEXTW 
c053 c3 09 9e			jp macro_next 
c056				endm 
# End of macro NEXTW
c056			.STYPE: 
c056				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c056 48				db WORD_SYS_CORE+52             
c057 a5 c0			dw .UPPER            
c059 06				db 5 + 1 
c05a .. 00			db "STYPE",0              
c060				endm 
# End of macro CWHEAD
c060			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c060					if DEBUG_FORTH_WORDS_KEY 
c060						DMARK "STY" 
c060 f5				push af  
c061 3a 75 c0			ld a, (.dmark)  
c064 32 6b ee			ld (debug_mark),a  
c067 3a 76 c0			ld a, (.dmark+1)  
c06a 32 6c ee			ld (debug_mark+1),a  
c06d 3a 77 c0			ld a, (.dmark+2)  
c070 32 6d ee			ld (debug_mark+2),a  
c073 18 03			jr .pastdmark  
c075 ..			.dmark: db "STY"  
c078 f1			.pastdmark: pop af  
c079			endm  
# End of macro DMARK
c079						CALLMONITOR 
c079 cd 6f ee			call debug_vector  
c07c				endm  
# End of macro CALLMONITOR
c07c					endif 
c07c					FORTH_DSP 
c07c cd 19 9c			call macro_forth_dsp 
c07f				endm 
# End of macro FORTH_DSP
c07f					;v5 FORTH_DSP_VALUE 
c07f			 
c07f 7e					ld a, (hl) 
c080			 
c080 f5					push af 
c081			 
c081			; Dont destroy TOS		FORTH_DSP_POP 
c081			 
c081 f1					pop af 
c082			 
c082 fe 01				cp DS_TYPE_STR 
c084 28 09				jr z, .typestr 
c086			 
c086 fe 02				cp DS_TYPE_INUM 
c088 28 0a				jr z, .typeinum 
c08a			 
c08a 21 a3 c0				ld hl, .tna 
c08d 18 0a				jr .tpush 
c08f			 
c08f 21 9f c0		.typestr:	ld hl, .tstr 
c092 18 05				jr .tpush 
c094 21 a1 c0		.typeinum:	ld hl, .tinum 
c097 18 00				jr .tpush 
c099			 
c099			.tpush: 
c099			 
c099 cd ca 9a				call forth_push_str 
c09c			 
c09c					NEXTW 
c09c c3 09 9e			jp macro_next 
c09f				endm 
# End of macro NEXTW
c09f .. 00		.tstr:	db "s",0 
c0a1 .. 00		.tinum:  db "i",0 
c0a3 .. 00		.tna:   db "?", 0 
c0a5			 
c0a5			 
c0a5			.UPPER: 
c0a5				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0a5 48				db WORD_SYS_CORE+52             
c0a6 e0 c0			dw .LOWER            
c0a8 06				db 5 + 1 
c0a9 .. 00			db "UPPER",0              
c0af				endm 
# End of macro CWHEAD
c0af			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0af					if DEBUG_FORTH_WORDS_KEY 
c0af						DMARK "UPR" 
c0af f5				push af  
c0b0 3a c4 c0			ld a, (.dmark)  
c0b3 32 6b ee			ld (debug_mark),a  
c0b6 3a c5 c0			ld a, (.dmark+1)  
c0b9 32 6c ee			ld (debug_mark+1),a  
c0bc 3a c6 c0			ld a, (.dmark+2)  
c0bf 32 6d ee			ld (debug_mark+2),a  
c0c2 18 03			jr .pastdmark  
c0c4 ..			.dmark: db "UPR"  
c0c7 f1			.pastdmark: pop af  
c0c8			endm  
# End of macro DMARK
c0c8						CALLMONITOR 
c0c8 cd 6f ee			call debug_vector  
c0cb				endm  
# End of macro CALLMONITOR
c0cb					endif 
c0cb			 
c0cb					FORTH_DSP 
c0cb cd 19 9c			call macro_forth_dsp 
c0ce				endm 
# End of macro FORTH_DSP
c0ce					 
c0ce			; TODO check is string type 
c0ce			 
c0ce					FORTH_DSP_VALUEHL 
c0ce cd 53 9c			call macro_dsp_valuehl 
c0d1				endm 
# End of macro FORTH_DSP_VALUEHL
c0d1			; get pointer to string in hl 
c0d1			 
c0d1 7e			.toup:		ld a, (hl) 
c0d2 fe 00				cp 0 
c0d4 28 07				jr z, .toupdone 
c0d6			 
c0d6 cd 5d 8f				call to_upper 
c0d9			 
c0d9 77					ld (hl), a 
c0da 23					inc hl 
c0db 18 f4				jr .toup 
c0dd			 
c0dd					 
c0dd			 
c0dd			 
c0dd			; for each char convert to upper 
c0dd					 
c0dd			.toupdone: 
c0dd			 
c0dd			 
c0dd					NEXTW 
c0dd c3 09 9e			jp macro_next 
c0e0				endm 
# End of macro NEXTW
c0e0			.LOWER: 
c0e0				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c0e0 48				db WORD_SYS_CORE+52             
c0e1 1b c1			dw .TCASE            
c0e3 06				db 5 + 1 
c0e4 .. 00			db "LOWER",0              
c0ea				endm 
# End of macro CWHEAD
c0ea			; | LOWER ( s -- s ) Lower case string s  | DONE 
c0ea					if DEBUG_FORTH_WORDS_KEY 
c0ea						DMARK "LWR" 
c0ea f5				push af  
c0eb 3a ff c0			ld a, (.dmark)  
c0ee 32 6b ee			ld (debug_mark),a  
c0f1 3a 00 c1			ld a, (.dmark+1)  
c0f4 32 6c ee			ld (debug_mark+1),a  
c0f7 3a 01 c1			ld a, (.dmark+2)  
c0fa 32 6d ee			ld (debug_mark+2),a  
c0fd 18 03			jr .pastdmark  
c0ff ..			.dmark: db "LWR"  
c102 f1			.pastdmark: pop af  
c103			endm  
# End of macro DMARK
c103						CALLMONITOR 
c103 cd 6f ee			call debug_vector  
c106				endm  
# End of macro CALLMONITOR
c106					endif 
c106			 
c106					FORTH_DSP 
c106 cd 19 9c			call macro_forth_dsp 
c109				endm 
# End of macro FORTH_DSP
c109					 
c109			; TODO check is string type 
c109			 
c109					FORTH_DSP_VALUEHL 
c109 cd 53 9c			call macro_dsp_valuehl 
c10c				endm 
# End of macro FORTH_DSP_VALUEHL
c10c			; get pointer to string in hl 
c10c			 
c10c 7e			.tolow:		ld a, (hl) 
c10d fe 00				cp 0 
c10f 28 07				jr z, .tolowdone 
c111			 
c111 cd 66 8f				call to_lower 
c114			 
c114 77					ld (hl), a 
c115 23					inc hl 
c116 18 f4				jr .tolow 
c118			 
c118					 
c118			 
c118			 
c118			; for each char convert to low 
c118					 
c118			.tolowdone: 
c118					NEXTW 
c118 c3 09 9e			jp macro_next 
c11b				endm 
# End of macro NEXTW
c11b			.TCASE: 
c11b				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c11b 48				db WORD_SYS_CORE+52             
c11c 51 c2			dw .SUBSTR            
c11e 06				db 5 + 1 
c11f .. 00			db "TCASE",0              
c125				endm 
# End of macro CWHEAD
c125			; | TCASE ( s -- s ) Title case string s  | DONE 
c125					if DEBUG_FORTH_WORDS_KEY 
c125						DMARK "TCS" 
c125 f5				push af  
c126 3a 3a c1			ld a, (.dmark)  
c129 32 6b ee			ld (debug_mark),a  
c12c 3a 3b c1			ld a, (.dmark+1)  
c12f 32 6c ee			ld (debug_mark+1),a  
c132 3a 3c c1			ld a, (.dmark+2)  
c135 32 6d ee			ld (debug_mark+2),a  
c138 18 03			jr .pastdmark  
c13a ..			.dmark: db "TCS"  
c13d f1			.pastdmark: pop af  
c13e			endm  
# End of macro DMARK
c13e						CALLMONITOR 
c13e cd 6f ee			call debug_vector  
c141				endm  
# End of macro CALLMONITOR
c141					endif 
c141			 
c141					FORTH_DSP 
c141 cd 19 9c			call macro_forth_dsp 
c144				endm 
# End of macro FORTH_DSP
c144					 
c144			; TODO check is string type 
c144			 
c144					FORTH_DSP_VALUEHL 
c144 cd 53 9c			call macro_dsp_valuehl 
c147				endm 
# End of macro FORTH_DSP_VALUEHL
c147			; get pointer to string in hl 
c147			 
c147					if DEBUG_FORTH_WORDS 
c147						DMARK "TC1" 
c147 f5				push af  
c148 3a 5c c1			ld a, (.dmark)  
c14b 32 6b ee			ld (debug_mark),a  
c14e 3a 5d c1			ld a, (.dmark+1)  
c151 32 6c ee			ld (debug_mark+1),a  
c154 3a 5e c1			ld a, (.dmark+2)  
c157 32 6d ee			ld (debug_mark+2),a  
c15a 18 03			jr .pastdmark  
c15c ..			.dmark: db "TC1"  
c15f f1			.pastdmark: pop af  
c160			endm  
# End of macro DMARK
c160						CALLMONITOR 
c160 cd 6f ee			call debug_vector  
c163				endm  
# End of macro CALLMONITOR
c163					endif 
c163			 
c163					; first time in turn to upper case first char 
c163			 
c163 7e					ld a, (hl) 
c164 c3 ee c1				jp .totsiptou 
c167			 
c167			 
c167 7e			.tot:		ld a, (hl) 
c168 fe 00				cp 0 
c16a ca 32 c2				jp z, .totdone 
c16d			 
c16d					if DEBUG_FORTH_WORDS 
c16d						DMARK "TC2" 
c16d f5				push af  
c16e 3a 82 c1			ld a, (.dmark)  
c171 32 6b ee			ld (debug_mark),a  
c174 3a 83 c1			ld a, (.dmark+1)  
c177 32 6c ee			ld (debug_mark+1),a  
c17a 3a 84 c1			ld a, (.dmark+2)  
c17d 32 6d ee			ld (debug_mark+2),a  
c180 18 03			jr .pastdmark  
c182 ..			.dmark: db "TC2"  
c185 f1			.pastdmark: pop af  
c186			endm  
# End of macro DMARK
c186						CALLMONITOR 
c186 cd 6f ee			call debug_vector  
c189				endm  
# End of macro CALLMONITOR
c189					endif 
c189					; check to see if current char is a space 
c189			 
c189 fe 20				cp ' ' 
c18b 28 21				jr z, .totsp 
c18d cd 66 8f				call to_lower 
c190					if DEBUG_FORTH_WORDS 
c190						DMARK "TC3" 
c190 f5				push af  
c191 3a a5 c1			ld a, (.dmark)  
c194 32 6b ee			ld (debug_mark),a  
c197 3a a6 c1			ld a, (.dmark+1)  
c19a 32 6c ee			ld (debug_mark+1),a  
c19d 3a a7 c1			ld a, (.dmark+2)  
c1a0 32 6d ee			ld (debug_mark+2),a  
c1a3 18 03			jr .pastdmark  
c1a5 ..			.dmark: db "TC3"  
c1a8 f1			.pastdmark: pop af  
c1a9			endm  
# End of macro DMARK
c1a9						CALLMONITOR 
c1a9 cd 6f ee			call debug_vector  
c1ac				endm  
# End of macro CALLMONITOR
c1ac					endif 
c1ac 18 63				jr .totnxt 
c1ae			 
c1ae			.totsp:         ; on a space, find next char which should be upper 
c1ae			 
c1ae					if DEBUG_FORTH_WORDS 
c1ae						DMARK "TC4" 
c1ae f5				push af  
c1af 3a c3 c1			ld a, (.dmark)  
c1b2 32 6b ee			ld (debug_mark),a  
c1b5 3a c4 c1			ld a, (.dmark+1)  
c1b8 32 6c ee			ld (debug_mark+1),a  
c1bb 3a c5 c1			ld a, (.dmark+2)  
c1be 32 6d ee			ld (debug_mark+2),a  
c1c1 18 03			jr .pastdmark  
c1c3 ..			.dmark: db "TC4"  
c1c6 f1			.pastdmark: pop af  
c1c7			endm  
# End of macro DMARK
c1c7						CALLMONITOR 
c1c7 cd 6f ee			call debug_vector  
c1ca				endm  
# End of macro CALLMONITOR
c1ca					endif 
c1ca					;; 
c1ca			 
c1ca fe 20				cp ' ' 
c1cc 20 20				jr nz, .totsiptou 
c1ce 23					inc hl 
c1cf 7e					ld a, (hl) 
c1d0					if DEBUG_FORTH_WORDS 
c1d0						DMARK "TC5" 
c1d0 f5				push af  
c1d1 3a e5 c1			ld a, (.dmark)  
c1d4 32 6b ee			ld (debug_mark),a  
c1d7 3a e6 c1			ld a, (.dmark+1)  
c1da 32 6c ee			ld (debug_mark+1),a  
c1dd 3a e7 c1			ld a, (.dmark+2)  
c1e0 32 6d ee			ld (debug_mark+2),a  
c1e3 18 03			jr .pastdmark  
c1e5 ..			.dmark: db "TC5"  
c1e8 f1			.pastdmark: pop af  
c1e9			endm  
# End of macro DMARK
c1e9						CALLMONITOR 
c1e9 cd 6f ee			call debug_vector  
c1ec				endm  
# End of macro CALLMONITOR
c1ec					endif 
c1ec 18 c0				jr .totsp 
c1ee fe 00		.totsiptou:    cp 0 
c1f0 28 40				jr z, .totdone 
c1f2					; not space and not zero term so upper case it 
c1f2 cd 5d 8f				call to_upper 
c1f5			 
c1f5					if DEBUG_FORTH_WORDS 
c1f5						DMARK "TC6" 
c1f5 f5				push af  
c1f6 3a 0a c2			ld a, (.dmark)  
c1f9 32 6b ee			ld (debug_mark),a  
c1fc 3a 0b c2			ld a, (.dmark+1)  
c1ff 32 6c ee			ld (debug_mark+1),a  
c202 3a 0c c2			ld a, (.dmark+2)  
c205 32 6d ee			ld (debug_mark+2),a  
c208 18 03			jr .pastdmark  
c20a ..			.dmark: db "TC6"  
c20d f1			.pastdmark: pop af  
c20e			endm  
# End of macro DMARK
c20e						CALLMONITOR 
c20e cd 6f ee			call debug_vector  
c211				endm  
# End of macro CALLMONITOR
c211					endif 
c211			 
c211			 
c211			.totnxt: 
c211			 
c211 77					ld (hl), a 
c212 23					inc hl 
c213					if DEBUG_FORTH_WORDS 
c213						DMARK "TC7" 
c213 f5				push af  
c214 3a 28 c2			ld a, (.dmark)  
c217 32 6b ee			ld (debug_mark),a  
c21a 3a 29 c2			ld a, (.dmark+1)  
c21d 32 6c ee			ld (debug_mark+1),a  
c220 3a 2a c2			ld a, (.dmark+2)  
c223 32 6d ee			ld (debug_mark+2),a  
c226 18 03			jr .pastdmark  
c228 ..			.dmark: db "TC7"  
c22b f1			.pastdmark: pop af  
c22c			endm  
# End of macro DMARK
c22c						CALLMONITOR 
c22c cd 6f ee			call debug_vector  
c22f				endm  
# End of macro CALLMONITOR
c22f					endif 
c22f c3 67 c1				jp .tot 
c232			 
c232					 
c232			 
c232			 
c232			; for each char convert to low 
c232					 
c232			.totdone: 
c232					if DEBUG_FORTH_WORDS 
c232						DMARK "TCd" 
c232 f5				push af  
c233 3a 47 c2			ld a, (.dmark)  
c236 32 6b ee			ld (debug_mark),a  
c239 3a 48 c2			ld a, (.dmark+1)  
c23c 32 6c ee			ld (debug_mark+1),a  
c23f 3a 49 c2			ld a, (.dmark+2)  
c242 32 6d ee			ld (debug_mark+2),a  
c245 18 03			jr .pastdmark  
c247 ..			.dmark: db "TCd"  
c24a f1			.pastdmark: pop af  
c24b			endm  
# End of macro DMARK
c24b						CALLMONITOR 
c24b cd 6f ee			call debug_vector  
c24e				endm  
# End of macro CALLMONITOR
c24e					endif 
c24e					NEXTW 
c24e c3 09 9e			jp macro_next 
c251				endm 
# End of macro NEXTW
c251			 
c251			.SUBSTR: 
c251				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c251 48				db WORD_SYS_CORE+52             
c252 af c2			dw .LEFT            
c254 07				db 6 + 1 
c255 .. 00			db "SUBSTR",0              
c25c				endm 
# End of macro CWHEAD
c25c			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c25c			 
c25c					if DEBUG_FORTH_WORDS_KEY 
c25c						DMARK "SST" 
c25c f5				push af  
c25d 3a 71 c2			ld a, (.dmark)  
c260 32 6b ee			ld (debug_mark),a  
c263 3a 72 c2			ld a, (.dmark+1)  
c266 32 6c ee			ld (debug_mark+1),a  
c269 3a 73 c2			ld a, (.dmark+2)  
c26c 32 6d ee			ld (debug_mark+2),a  
c26f 18 03			jr .pastdmark  
c271 ..			.dmark: db "SST"  
c274 f1			.pastdmark: pop af  
c275			endm  
# End of macro DMARK
c275						CALLMONITOR 
c275 cd 6f ee			call debug_vector  
c278				endm  
# End of macro CALLMONITOR
c278					endif 
c278			; TODO check string type 
c278					FORTH_DSP_VALUEHL 
c278 cd 53 9c			call macro_dsp_valuehl 
c27b				endm 
# End of macro FORTH_DSP_VALUEHL
c27b			 
c27b e5					push hl      ; string length 
c27c			 
c27c					FORTH_DSP_POP 
c27c cd 0b 9d			call macro_forth_dsp_pop 
c27f				endm 
# End of macro FORTH_DSP_POP
c27f			 
c27f					FORTH_DSP_VALUEHL 
c27f cd 53 9c			call macro_dsp_valuehl 
c282				endm 
# End of macro FORTH_DSP_VALUEHL
c282			 
c282 e5					push hl     ; start char 
c283			 
c283					FORTH_DSP_POP 
c283 cd 0b 9d			call macro_forth_dsp_pop 
c286				endm 
# End of macro FORTH_DSP_POP
c286			 
c286			 
c286					FORTH_DSP_VALUE 
c286 cd 3c 9c			call macro_forth_dsp_value 
c289				endm 
# End of macro FORTH_DSP_VALUE
c289			 
c289 d1					pop de    ; get start post offset 
c28a			 
c28a 19					add hl, de    ; starting offset 
c28b			 
c28b c1					pop bc 
c28c c5					push bc      ; grab size of string 
c28d			 
c28d e5					push hl    ; save string start  
c28e			 
c28e 26 00				ld h, 0 
c290 69					ld l, c 
c291 23					inc hl 
c292 23					inc hl 
c293			 
c293 cd c3 90				call malloc 
c296				if DEBUG_FORTH_MALLOC_GUARD 
c296 cc c9 cb				call z,malloc_error 
c299				endif 
c299			 
c299 eb					ex de, hl      ; save malloc area for string copy 
c29a e1					pop hl    ; get back source 
c29b c1					pop bc    ; get length of string back 
c29c			 
c29c d5					push de    ; save malloc area for after we push 
c29d ed b0				ldir     ; copy substr 
c29f			 
c29f			 
c29f eb					ex de, hl 
c2a0 3e 00				ld a, 0 
c2a2 77					ld (hl), a   ; term substr 
c2a3			 
c2a3					 
c2a3 e1					pop hl    ; get malloc so we can push it 
c2a4 e5					push hl   ; save so we can free it afterwards 
c2a5			 
c2a5 cd ca 9a				call forth_push_str 
c2a8			 
c2a8 e1					pop hl 
c2a9 cd 8d 91				call free 
c2ac			 
c2ac					 
c2ac					 
c2ac			 
c2ac			 
c2ac					NEXTW 
c2ac c3 09 9e			jp macro_next 
c2af				endm 
# End of macro NEXTW
c2af			 
c2af			.LEFT: 
c2af				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2af 48				db WORD_SYS_CORE+52             
c2b0 d7 c2			dw .RIGHT            
c2b2 05				db 4 + 1 
c2b3 .. 00			db "LEFT",0              
c2b8				endm 
# End of macro CWHEAD
c2b8			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2b8					if DEBUG_FORTH_WORDS_KEY 
c2b8						DMARK "LEF" 
c2b8 f5				push af  
c2b9 3a cd c2			ld a, (.dmark)  
c2bc 32 6b ee			ld (debug_mark),a  
c2bf 3a ce c2			ld a, (.dmark+1)  
c2c2 32 6c ee			ld (debug_mark+1),a  
c2c5 3a cf c2			ld a, (.dmark+2)  
c2c8 32 6d ee			ld (debug_mark+2),a  
c2cb 18 03			jr .pastdmark  
c2cd ..			.dmark: db "LEF"  
c2d0 f1			.pastdmark: pop af  
c2d1			endm  
# End of macro DMARK
c2d1						CALLMONITOR 
c2d1 cd 6f ee			call debug_vector  
c2d4				endm  
# End of macro CALLMONITOR
c2d4					endif 
c2d4			 
c2d4					NEXTW 
c2d4 c3 09 9e			jp macro_next 
c2d7				endm 
# End of macro NEXTW
c2d7			.RIGHT: 
c2d7				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c2d7 48				db WORD_SYS_CORE+52             
c2d8 00 c3			dw .STR2NUM            
c2da 06				db 5 + 1 
c2db .. 00			db "RIGHT",0              
c2e1				endm 
# End of macro CWHEAD
c2e1			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c2e1					if DEBUG_FORTH_WORDS_KEY 
c2e1						DMARK "RIG" 
c2e1 f5				push af  
c2e2 3a f6 c2			ld a, (.dmark)  
c2e5 32 6b ee			ld (debug_mark),a  
c2e8 3a f7 c2			ld a, (.dmark+1)  
c2eb 32 6c ee			ld (debug_mark+1),a  
c2ee 3a f8 c2			ld a, (.dmark+2)  
c2f1 32 6d ee			ld (debug_mark+2),a  
c2f4 18 03			jr .pastdmark  
c2f6 ..			.dmark: db "RIG"  
c2f9 f1			.pastdmark: pop af  
c2fa			endm  
# End of macro DMARK
c2fa						CALLMONITOR 
c2fa cd 6f ee			call debug_vector  
c2fd				endm  
# End of macro CALLMONITOR
c2fd					endif 
c2fd			 
c2fd					NEXTW 
c2fd c3 09 9e			jp macro_next 
c300				endm 
# End of macro NEXTW
c300			 
c300			 
c300			.STR2NUM: 
c300				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c300 48				db WORD_SYS_CORE+52             
c301 8c c3			dw .NUM2STR            
c303 08				db 7 + 1 
c304 .. 00			db "STR2NUM",0              
c30c				endm 
# End of macro CWHEAD
c30c			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c30c			 
c30c			 
c30c			; TODO STR type check to do 
c30c					if DEBUG_FORTH_WORDS_KEY 
c30c						DMARK "S2N" 
c30c f5				push af  
c30d 3a 21 c3			ld a, (.dmark)  
c310 32 6b ee			ld (debug_mark),a  
c313 3a 22 c3			ld a, (.dmark+1)  
c316 32 6c ee			ld (debug_mark+1),a  
c319 3a 23 c3			ld a, (.dmark+2)  
c31c 32 6d ee			ld (debug_mark+2),a  
c31f 18 03			jr .pastdmark  
c321 ..			.dmark: db "S2N"  
c324 f1			.pastdmark: pop af  
c325			endm  
# End of macro DMARK
c325						CALLMONITOR 
c325 cd 6f ee			call debug_vector  
c328				endm  
# End of macro CALLMONITOR
c328					endif 
c328			 
c328					;FORTH_DSP 
c328					FORTH_DSP_VALUE 
c328 cd 3c 9c			call macro_forth_dsp_value 
c32b				endm 
# End of macro FORTH_DSP_VALUE
c32b					;inc hl 
c32b			 
c32b eb					ex de, hl 
c32c					if DEBUG_FORTH_WORDS 
c32c						DMARK "S2a" 
c32c f5				push af  
c32d 3a 41 c3			ld a, (.dmark)  
c330 32 6b ee			ld (debug_mark),a  
c333 3a 42 c3			ld a, (.dmark+1)  
c336 32 6c ee			ld (debug_mark+1),a  
c339 3a 43 c3			ld a, (.dmark+2)  
c33c 32 6d ee			ld (debug_mark+2),a  
c33f 18 03			jr .pastdmark  
c341 ..			.dmark: db "S2a"  
c344 f1			.pastdmark: pop af  
c345			endm  
# End of macro DMARK
c345						CALLMONITOR 
c345 cd 6f ee			call debug_vector  
c348				endm  
# End of macro CALLMONITOR
c348					endif 
c348 cd e5 8f				call string_to_uint16 
c34b			 
c34b					if DEBUG_FORTH_WORDS 
c34b						DMARK "S2b" 
c34b f5				push af  
c34c 3a 60 c3			ld a, (.dmark)  
c34f 32 6b ee			ld (debug_mark),a  
c352 3a 61 c3			ld a, (.dmark+1)  
c355 32 6c ee			ld (debug_mark+1),a  
c358 3a 62 c3			ld a, (.dmark+2)  
c35b 32 6d ee			ld (debug_mark+2),a  
c35e 18 03			jr .pastdmark  
c360 ..			.dmark: db "S2b"  
c363 f1			.pastdmark: pop af  
c364			endm  
# End of macro DMARK
c364						CALLMONITOR 
c364 cd 6f ee			call debug_vector  
c367				endm  
# End of macro CALLMONITOR
c367					endif 
c367			;		push hl 
c367					FORTH_DSP_POP 
c367 cd 0b 9d			call macro_forth_dsp_pop 
c36a				endm 
# End of macro FORTH_DSP_POP
c36a			;		pop hl 
c36a					 
c36a					if DEBUG_FORTH_WORDS 
c36a						DMARK "S2b" 
c36a f5				push af  
c36b 3a 7f c3			ld a, (.dmark)  
c36e 32 6b ee			ld (debug_mark),a  
c371 3a 80 c3			ld a, (.dmark+1)  
c374 32 6c ee			ld (debug_mark+1),a  
c377 3a 81 c3			ld a, (.dmark+2)  
c37a 32 6d ee			ld (debug_mark+2),a  
c37d 18 03			jr .pastdmark  
c37f ..			.dmark: db "S2b"  
c382 f1			.pastdmark: pop af  
c383			endm  
# End of macro DMARK
c383						CALLMONITOR 
c383 cd 6f ee			call debug_vector  
c386				endm  
# End of macro CALLMONITOR
c386					endif 
c386 cd 5c 9a				call forth_push_numhl	 
c389			 
c389				 
c389				       NEXTW 
c389 c3 09 9e			jp macro_next 
c38c				endm 
# End of macro NEXTW
c38c			.NUM2STR: 
c38c				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c38c 48				db WORD_SYS_CORE+52             
c38d 9b c3			dw .CONCAT            
c38f 08				db 7 + 1 
c390 .. 00			db "NUM2STR",0              
c398				endm 
# End of macro CWHEAD
c398			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c398			 
c398			;		; malloc a string to target 
c398			;		ld hl, 10     ; TODO max string size should be fine 
c398			;		call malloc 
c398			;		push hl    ; save malloc location 
c398			; 
c398			; 
c398			;; TODO check int type 
c398			;		FORTH_DSP_VALUEHL 
c398			;		ld a, l 
c398			;		call DispAToASCII   
c398			;;TODO need to chage above call to dump into string 
c398			; 
c398			; 
c398			 
c398				       NEXTW 
c398 c3 09 9e			jp macro_next 
c39b				endm 
# End of macro NEXTW
c39b			 
c39b			.CONCAT: 
c39b				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c39b 48				db WORD_SYS_CORE+52             
c39c 4e c4			dw .FIND            
c39e 07				db 6 + 1 
c39f .. 00			db "CONCAT",0              
c3a6				endm 
# End of macro CWHEAD
c3a6			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3a6			 
c3a6			; TODO check string type 
c3a6			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3a6			 
c3a6					if DEBUG_FORTH_WORDS_KEY 
c3a6						DMARK "CON" 
c3a6 f5				push af  
c3a7 3a bb c3			ld a, (.dmark)  
c3aa 32 6b ee			ld (debug_mark),a  
c3ad 3a bc c3			ld a, (.dmark+1)  
c3b0 32 6c ee			ld (debug_mark+1),a  
c3b3 3a bd c3			ld a, (.dmark+2)  
c3b6 32 6d ee			ld (debug_mark+2),a  
c3b9 18 03			jr .pastdmark  
c3bb ..			.dmark: db "CON"  
c3be f1			.pastdmark: pop af  
c3bf			endm  
# End of macro DMARK
c3bf						CALLMONITOR 
c3bf cd 6f ee			call debug_vector  
c3c2				endm  
# End of macro CALLMONITOR
c3c2					endif 
c3c2			 
c3c2			 
c3c2					FORTH_DSP_VALUE 
c3c2 cd 3c 9c			call macro_forth_dsp_value 
c3c5				endm 
# End of macro FORTH_DSP_VALUE
c3c5 e5					push hl   ; s2 
c3c6			 
c3c6					FORTH_DSP_POP 
c3c6 cd 0b 9d			call macro_forth_dsp_pop 
c3c9				endm 
# End of macro FORTH_DSP_POP
c3c9			 
c3c9					FORTH_DSP_VALUE 
c3c9 cd 3c 9c			call macro_forth_dsp_value 
c3cc				endm 
# End of macro FORTH_DSP_VALUE
c3cc			 
c3cc e5					push hl   ; s1 
c3cd			 
c3cd					FORTH_DSP_POP 
c3cd cd 0b 9d			call macro_forth_dsp_pop 
c3d0				endm 
# End of macro FORTH_DSP_POP
c3d0					 
c3d0			 
c3d0					; copy s1 
c3d0			 
c3d0				 
c3d0					; save ptr 
c3d0 e1					pop hl  
c3d1 e5					push hl 
c3d2 3e 00				ld a, 0 
c3d4 cd 59 90				call strlent 
c3d7					;inc hl    ; zer0 
c3d7 06 00				ld b, 0 
c3d9 4d					ld c, l 
c3da e1					pop hl		 
c3db 11 c1 e2				ld de, scratch	 
c3de					if DEBUG_FORTH_WORDS 
c3de						DMARK "CO1" 
c3de f5				push af  
c3df 3a f3 c3			ld a, (.dmark)  
c3e2 32 6b ee			ld (debug_mark),a  
c3e5 3a f4 c3			ld a, (.dmark+1)  
c3e8 32 6c ee			ld (debug_mark+1),a  
c3eb 3a f5 c3			ld a, (.dmark+2)  
c3ee 32 6d ee			ld (debug_mark+2),a  
c3f1 18 03			jr .pastdmark  
c3f3 ..			.dmark: db "CO1"  
c3f6 f1			.pastdmark: pop af  
c3f7			endm  
# End of macro DMARK
c3f7						CALLMONITOR 
c3f7 cd 6f ee			call debug_vector  
c3fa				endm  
# End of macro CALLMONITOR
c3fa					endif 
c3fa ed b0				ldir 
c3fc			 
c3fc e1					pop hl 
c3fd e5					push hl 
c3fe d5					push de 
c3ff			 
c3ff			 
c3ff 3e 00				ld a, 0 
c401 cd 59 90				call strlent 
c404 23					inc hl    ; zer0 
c405 23					inc hl 
c406 06 00				ld b, 0 
c408 4d					ld c, l 
c409 d1					pop de 
c40a e1					pop hl		 
c40b					if DEBUG_FORTH_WORDS 
c40b						DMARK "CO2" 
c40b f5				push af  
c40c 3a 20 c4			ld a, (.dmark)  
c40f 32 6b ee			ld (debug_mark),a  
c412 3a 21 c4			ld a, (.dmark+1)  
c415 32 6c ee			ld (debug_mark+1),a  
c418 3a 22 c4			ld a, (.dmark+2)  
c41b 32 6d ee			ld (debug_mark+2),a  
c41e 18 03			jr .pastdmark  
c420 ..			.dmark: db "CO2"  
c423 f1			.pastdmark: pop af  
c424			endm  
# End of macro DMARK
c424						CALLMONITOR 
c424 cd 6f ee			call debug_vector  
c427				endm  
# End of macro CALLMONITOR
c427					endif 
c427 ed b0				ldir 
c429			 
c429			 
c429			 
c429 21 c1 e2				ld hl, scratch 
c42c					if DEBUG_FORTH_WORDS 
c42c						DMARK "CO5" 
c42c f5				push af  
c42d 3a 41 c4			ld a, (.dmark)  
c430 32 6b ee			ld (debug_mark),a  
c433 3a 42 c4			ld a, (.dmark+1)  
c436 32 6c ee			ld (debug_mark+1),a  
c439 3a 43 c4			ld a, (.dmark+2)  
c43c 32 6d ee			ld (debug_mark+2),a  
c43f 18 03			jr .pastdmark  
c441 ..			.dmark: db "CO5"  
c444 f1			.pastdmark: pop af  
c445			endm  
# End of macro DMARK
c445						CALLMONITOR 
c445 cd 6f ee			call debug_vector  
c448				endm  
# End of macro CALLMONITOR
c448					endif 
c448			 
c448 cd ca 9a				call forth_push_str 
c44b			 
c44b			 
c44b			 
c44b			 
c44b				       NEXTW 
c44b c3 09 9e			jp macro_next 
c44e				endm 
# End of macro NEXTW
c44e			 
c44e			 
c44e			.FIND: 
c44e				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c44e 4b				db WORD_SYS_CORE+55             
c44f 0c c5			dw .LEN            
c451 05				db 4 + 1 
c452 .. 00			db "FIND",0              
c457				endm 
# End of macro CWHEAD
c457			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c457			 
c457					if DEBUG_FORTH_WORDS_KEY 
c457						DMARK "FND" 
c457 f5				push af  
c458 3a 6c c4			ld a, (.dmark)  
c45b 32 6b ee			ld (debug_mark),a  
c45e 3a 6d c4			ld a, (.dmark+1)  
c461 32 6c ee			ld (debug_mark+1),a  
c464 3a 6e c4			ld a, (.dmark+2)  
c467 32 6d ee			ld (debug_mark+2),a  
c46a 18 03			jr .pastdmark  
c46c ..			.dmark: db "FND"  
c46f f1			.pastdmark: pop af  
c470			endm  
# End of macro DMARK
c470						CALLMONITOR 
c470 cd 6f ee			call debug_vector  
c473				endm  
# End of macro CALLMONITOR
c473					endif 
c473			 
c473			; TODO check string type 
c473					FORTH_DSP_VALUE 
c473 cd 3c 9c			call macro_forth_dsp_value 
c476				endm 
# End of macro FORTH_DSP_VALUE
c476			 
c476 e5					push hl    
c477 7e					ld a,(hl)    ; char to find   
c478			; TODO change char to substr 
c478			 
c478 f5					push af 
c479					 
c479			 
c479			 
c479					if DEBUG_FORTH_WORDS 
c479						DMARK "FN1" 
c479 f5				push af  
c47a 3a 8e c4			ld a, (.dmark)  
c47d 32 6b ee			ld (debug_mark),a  
c480 3a 8f c4			ld a, (.dmark+1)  
c483 32 6c ee			ld (debug_mark+1),a  
c486 3a 90 c4			ld a, (.dmark+2)  
c489 32 6d ee			ld (debug_mark+2),a  
c48c 18 03			jr .pastdmark  
c48e ..			.dmark: db "FN1"  
c491 f1			.pastdmark: pop af  
c492			endm  
# End of macro DMARK
c492						CALLMONITOR 
c492 cd 6f ee			call debug_vector  
c495				endm  
# End of macro CALLMONITOR
c495					endif 
c495			 
c495					FORTH_DSP_POP 
c495 cd 0b 9d			call macro_forth_dsp_pop 
c498				endm 
# End of macro FORTH_DSP_POP
c498			 
c498					; string to search 
c498			 
c498					FORTH_DSP_VALUE 
c498 cd 3c 9c			call macro_forth_dsp_value 
c49b				endm 
# End of macro FORTH_DSP_VALUE
c49b			 
c49b d1					pop de  ; d is char to find  
c49c			 
c49c					if DEBUG_FORTH_WORDS 
c49c						DMARK "FN2" 
c49c f5				push af  
c49d 3a b1 c4			ld a, (.dmark)  
c4a0 32 6b ee			ld (debug_mark),a  
c4a3 3a b2 c4			ld a, (.dmark+1)  
c4a6 32 6c ee			ld (debug_mark+1),a  
c4a9 3a b3 c4			ld a, (.dmark+2)  
c4ac 32 6d ee			ld (debug_mark+2),a  
c4af 18 03			jr .pastdmark  
c4b1 ..			.dmark: db "FN2"  
c4b4 f1			.pastdmark: pop af  
c4b5			endm  
# End of macro DMARK
c4b5						CALLMONITOR 
c4b5 cd 6f ee			call debug_vector  
c4b8				endm  
# End of macro CALLMONITOR
c4b8					endif 
c4b8					 
c4b8 01 00 00				ld bc, 0 
c4bb 7e			.findchar:      ld a,(hl) 
c4bc fe 00				cp 0   		 
c4be 28 27				jr z, .finddone     
c4c0 ba					cp d 
c4c1 28 20				jr z, .foundchar 
c4c3 03					inc bc 
c4c4 23					inc hl 
c4c5					if DEBUG_FORTH_WORDS 
c4c5						DMARK "FN3" 
c4c5 f5				push af  
c4c6 3a da c4			ld a, (.dmark)  
c4c9 32 6b ee			ld (debug_mark),a  
c4cc 3a db c4			ld a, (.dmark+1)  
c4cf 32 6c ee			ld (debug_mark+1),a  
c4d2 3a dc c4			ld a, (.dmark+2)  
c4d5 32 6d ee			ld (debug_mark+2),a  
c4d8 18 03			jr .pastdmark  
c4da ..			.dmark: db "FN3"  
c4dd f1			.pastdmark: pop af  
c4de			endm  
# End of macro DMARK
c4de						CALLMONITOR 
c4de cd 6f ee			call debug_vector  
c4e1				endm  
# End of macro CALLMONITOR
c4e1					endif 
c4e1 18 d8				jr .findchar 
c4e3			 
c4e3			 
c4e3 c5			.foundchar:	push bc 
c4e4 e1					pop hl 
c4e5 18 03				jr .findexit 
c4e7			 
c4e7			 
c4e7							 
c4e7			 
c4e7			.finddone:     ; got to end of string with no find 
c4e7 21 00 00				ld hl, 0 
c4ea			.findexit: 
c4ea			 
c4ea					if DEBUG_FORTH_WORDS 
c4ea						DMARK "FNd" 
c4ea f5				push af  
c4eb 3a ff c4			ld a, (.dmark)  
c4ee 32 6b ee			ld (debug_mark),a  
c4f1 3a 00 c5			ld a, (.dmark+1)  
c4f4 32 6c ee			ld (debug_mark+1),a  
c4f7 3a 01 c5			ld a, (.dmark+2)  
c4fa 32 6d ee			ld (debug_mark+2),a  
c4fd 18 03			jr .pastdmark  
c4ff ..			.dmark: db "FNd"  
c502 f1			.pastdmark: pop af  
c503			endm  
# End of macro DMARK
c503						CALLMONITOR 
c503 cd 6f ee			call debug_vector  
c506				endm  
# End of macro CALLMONITOR
c506					endif 
c506 cd 5c 9a			call forth_push_numhl 
c509			 
c509				       NEXTW 
c509 c3 09 9e			jp macro_next 
c50c				endm 
# End of macro NEXTW
c50c			 
c50c			.LEN: 
c50c				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c50c 4c				db WORD_SYS_CORE+56             
c50d 76 c5			dw .ASC            
c50f 06				db 5 + 1 
c510 .. 00			db "COUNT",0              
c516				endm 
# End of macro CWHEAD
c516			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c516			 
c516					if DEBUG_FORTH_WORDS_KEY 
c516						DMARK "CNT" 
c516 f5				push af  
c517 3a 2b c5			ld a, (.dmark)  
c51a 32 6b ee			ld (debug_mark),a  
c51d 3a 2c c5			ld a, (.dmark+1)  
c520 32 6c ee			ld (debug_mark+1),a  
c523 3a 2d c5			ld a, (.dmark+2)  
c526 32 6d ee			ld (debug_mark+2),a  
c529 18 03			jr .pastdmark  
c52b ..			.dmark: db "CNT"  
c52e f1			.pastdmark: pop af  
c52f			endm  
# End of macro DMARK
c52f						CALLMONITOR 
c52f cd 6f ee			call debug_vector  
c532				endm  
# End of macro CALLMONITOR
c532					endif 
c532			; TODO check string type 
c532					FORTH_DSP_VALUE 
c532 cd 3c 9c			call macro_forth_dsp_value 
c535				endm 
# End of macro FORTH_DSP_VALUE
c535			 
c535			 
c535					if DEBUG_FORTH_WORDS 
c535						DMARK "CN?" 
c535 f5				push af  
c536 3a 4a c5			ld a, (.dmark)  
c539 32 6b ee			ld (debug_mark),a  
c53c 3a 4b c5			ld a, (.dmark+1)  
c53f 32 6c ee			ld (debug_mark+1),a  
c542 3a 4c c5			ld a, (.dmark+2)  
c545 32 6d ee			ld (debug_mark+2),a  
c548 18 03			jr .pastdmark  
c54a ..			.dmark: db "CN?"  
c54d f1			.pastdmark: pop af  
c54e			endm  
# End of macro DMARK
c54e						CALLMONITOR 
c54e cd 6f ee			call debug_vector  
c551				endm  
# End of macro CALLMONITOR
c551					endif 
c551 cd 4e 90				call strlenz 
c554					if DEBUG_FORTH_WORDS 
c554						DMARK "CNl" 
c554 f5				push af  
c555 3a 69 c5			ld a, (.dmark)  
c558 32 6b ee			ld (debug_mark),a  
c55b 3a 6a c5			ld a, (.dmark+1)  
c55e 32 6c ee			ld (debug_mark+1),a  
c561 3a 6b c5			ld a, (.dmark+2)  
c564 32 6d ee			ld (debug_mark+2),a  
c567 18 03			jr .pastdmark  
c569 ..			.dmark: db "CNl"  
c56c f1			.pastdmark: pop af  
c56d			endm  
# End of macro DMARK
c56d						CALLMONITOR 
c56d cd 6f ee			call debug_vector  
c570				endm  
# End of macro CALLMONITOR
c570					endif 
c570			 
c570 cd 5c 9a				call forth_push_numhl 
c573			 
c573			 
c573			 
c573				       NEXTW 
c573 c3 09 9e			jp macro_next 
c576				endm 
# End of macro NEXTW
c576			.ASC: 
c576				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c576 4d				db WORD_SYS_CORE+57             
c577 e4 c5			dw .CHR            
c579 04				db 3 + 1 
c57a .. 00			db "ASC",0              
c57e				endm 
# End of macro CWHEAD
c57e			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c57e					if DEBUG_FORTH_WORDS_KEY 
c57e						DMARK "ASC" 
c57e f5				push af  
c57f 3a 93 c5			ld a, (.dmark)  
c582 32 6b ee			ld (debug_mark),a  
c585 3a 94 c5			ld a, (.dmark+1)  
c588 32 6c ee			ld (debug_mark+1),a  
c58b 3a 95 c5			ld a, (.dmark+2)  
c58e 32 6d ee			ld (debug_mark+2),a  
c591 18 03			jr .pastdmark  
c593 ..			.dmark: db "ASC"  
c596 f1			.pastdmark: pop af  
c597			endm  
# End of macro DMARK
c597						CALLMONITOR 
c597 cd 6f ee			call debug_vector  
c59a				endm  
# End of macro CALLMONITOR
c59a					endif 
c59a					FORTH_DSP_VALUE 
c59a cd 3c 9c			call macro_forth_dsp_value 
c59d				endm 
# End of macro FORTH_DSP_VALUE
c59d					;v5 FORTH_DSP_VALUE 
c59d			;		inc hl      ; now at start of numeric as string 
c59d			 
c59d e5					push hl 
c59e			 
c59e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c59e cd 0b 9d			call macro_forth_dsp_pop 
c5a1				endm 
# End of macro FORTH_DSP_POP
c5a1			 
c5a1 e1					pop hl 
c5a2			 
c5a2					if DEBUG_FORTH_WORDS 
c5a2						DMARK "AS1" 
c5a2 f5				push af  
c5a3 3a b7 c5			ld a, (.dmark)  
c5a6 32 6b ee			ld (debug_mark),a  
c5a9 3a b8 c5			ld a, (.dmark+1)  
c5ac 32 6c ee			ld (debug_mark+1),a  
c5af 3a b9 c5			ld a, (.dmark+2)  
c5b2 32 6d ee			ld (debug_mark+2),a  
c5b5 18 03			jr .pastdmark  
c5b7 ..			.dmark: db "AS1"  
c5ba f1			.pastdmark: pop af  
c5bb			endm  
# End of macro DMARK
c5bb						CALLMONITOR 
c5bb cd 6f ee			call debug_vector  
c5be				endm  
# End of macro CALLMONITOR
c5be					endif 
c5be					; push the content of a onto the stack as a value 
c5be			 
c5be 7e					ld a,(hl)   ; get char 
c5bf 26 00				ld h,0 
c5c1 6f					ld l,a 
c5c2					if DEBUG_FORTH_WORDS 
c5c2						DMARK "AS2" 
c5c2 f5				push af  
c5c3 3a d7 c5			ld a, (.dmark)  
c5c6 32 6b ee			ld (debug_mark),a  
c5c9 3a d8 c5			ld a, (.dmark+1)  
c5cc 32 6c ee			ld (debug_mark+1),a  
c5cf 3a d9 c5			ld a, (.dmark+2)  
c5d2 32 6d ee			ld (debug_mark+2),a  
c5d5 18 03			jr .pastdmark  
c5d7 ..			.dmark: db "AS2"  
c5da f1			.pastdmark: pop af  
c5db			endm  
# End of macro DMARK
c5db						CALLMONITOR 
c5db cd 6f ee			call debug_vector  
c5de				endm  
# End of macro CALLMONITOR
c5de					endif 
c5de cd 5c 9a				call forth_push_numhl 
c5e1			 
c5e1				       NEXTW 
c5e1 c3 09 9e			jp macro_next 
c5e4				endm 
# End of macro NEXTW
c5e4			 
c5e4			.CHR: 
c5e4				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c5e4 4d				db WORD_SYS_CORE+57             
c5e5 20 c6			dw .ENDSTR            
c5e7 04				db 3 + 1 
c5e8 .. 00			db "CHR",0              
c5ec				endm 
# End of macro CWHEAD
c5ec			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c5ec					if DEBUG_FORTH_WORDS_KEY 
c5ec						DMARK "CHR" 
c5ec f5				push af  
c5ed 3a 01 c6			ld a, (.dmark)  
c5f0 32 6b ee			ld (debug_mark),a  
c5f3 3a 02 c6			ld a, (.dmark+1)  
c5f6 32 6c ee			ld (debug_mark+1),a  
c5f9 3a 03 c6			ld a, (.dmark+2)  
c5fc 32 6d ee			ld (debug_mark+2),a  
c5ff 18 03			jr .pastdmark  
c601 ..			.dmark: db "CHR"  
c604 f1			.pastdmark: pop af  
c605			endm  
# End of macro DMARK
c605						CALLMONITOR 
c605 cd 6f ee			call debug_vector  
c608				endm  
# End of macro CALLMONITOR
c608					endif 
c608					FORTH_DSP_VALUEHL 
c608 cd 53 9c			call macro_dsp_valuehl 
c60b				endm 
# End of macro FORTH_DSP_VALUEHL
c60b			 
c60b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c60b cd 0b 9d			call macro_forth_dsp_pop 
c60e				endm 
# End of macro FORTH_DSP_POP
c60e			 
c60e					; save asci byte as a zero term string and push string 
c60e			 
c60e 7d					ld a,l 
c60f 32 c1 e2				ld (scratch), a 
c612			 
c612 3e 00				ld a, 0 
c614 32 c2 e2				ld (scratch+1), a 
c617			 
c617 21 c1 e2				ld hl, scratch 
c61a cd ca 9a				call forth_push_str 
c61d			 
c61d			 
c61d				       NEXTW 
c61d c3 09 9e			jp macro_next 
c620				endm 
# End of macro NEXTW
c620			 
c620			 
c620			 
c620			 
c620			.ENDSTR: 
c620			; eof 
c620			 
# End of file forth_words_str.asm
c620			include "forth_words_key.asm" 
c620			 
c620			; | ## Keyboard Words 
c620			 
c620			.KEY: 
c620				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c620 3e				db WORD_SYS_CORE+42             
c621 50 c6			dw .WAITK            
c623 04				db 3 + 1 
c624 .. 00			db "KEY",0              
c628				endm 
# End of macro CWHEAD
c628			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c628			 
c628					if DEBUG_FORTH_WORDS_KEY 
c628						DMARK "KEY" 
c628 f5				push af  
c629 3a 3d c6			ld a, (.dmark)  
c62c 32 6b ee			ld (debug_mark),a  
c62f 3a 3e c6			ld a, (.dmark+1)  
c632 32 6c ee			ld (debug_mark+1),a  
c635 3a 3f c6			ld a, (.dmark+2)  
c638 32 6d ee			ld (debug_mark+2),a  
c63b 18 03			jr .pastdmark  
c63d ..			.dmark: db "KEY"  
c640 f1			.pastdmark: pop af  
c641			endm  
# End of macro DMARK
c641						CALLMONITOR 
c641 cd 6f ee			call debug_vector  
c644				endm  
# End of macro CALLMONITOR
c644					endif 
c644			; TODO currently waits 
c644 cd ea e3				call cin 
c647					;call cin_wait 
c647 6f					ld l, a 
c648 26 00				ld h, 0 
c64a cd 5c 9a				call forth_push_numhl 
c64d					NEXTW 
c64d c3 09 9e			jp macro_next 
c650				endm 
# End of macro NEXTW
c650			.WAITK: 
c650				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c650 3f				db WORD_SYS_CORE+43             
c651 82 c6			dw .ACCEPT            
c653 06				db 5 + 1 
c654 .. 00			db "WAITK",0              
c65a				endm 
# End of macro CWHEAD
c65a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c65a					if DEBUG_FORTH_WORDS_KEY 
c65a						DMARK "WAI" 
c65a f5				push af  
c65b 3a 6f c6			ld a, (.dmark)  
c65e 32 6b ee			ld (debug_mark),a  
c661 3a 70 c6			ld a, (.dmark+1)  
c664 32 6c ee			ld (debug_mark+1),a  
c667 3a 71 c6			ld a, (.dmark+2)  
c66a 32 6d ee			ld (debug_mark+2),a  
c66d 18 03			jr .pastdmark  
c66f ..			.dmark: db "WAI"  
c672 f1			.pastdmark: pop af  
c673			endm  
# End of macro DMARK
c673						CALLMONITOR 
c673 cd 6f ee			call debug_vector  
c676				endm  
# End of macro CALLMONITOR
c676					endif 
c676 cd e4 e3				call cin_wait 
c679 6f					ld l, a 
c67a 26 00				ld h, 0 
c67c cd 5c 9a				call forth_push_numhl 
c67f					NEXTW 
c67f c3 09 9e			jp macro_next 
c682				endm 
# End of macro NEXTW
c682			.ACCEPT: 
c682				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c682 40				db WORD_SYS_CORE+44             
c683 e0 c6			dw .EDIT            
c685 07				db 6 + 1 
c686 .. 00			db "ACCEPT",0              
c68d				endm 
# End of macro CWHEAD
c68d			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c68d					; TODO crashes on push 
c68d					if DEBUG_FORTH_WORDS_KEY 
c68d						DMARK "ACC" 
c68d f5				push af  
c68e 3a a2 c6			ld a, (.dmark)  
c691 32 6b ee			ld (debug_mark),a  
c694 3a a3 c6			ld a, (.dmark+1)  
c697 32 6c ee			ld (debug_mark+1),a  
c69a 3a a4 c6			ld a, (.dmark+2)  
c69d 32 6d ee			ld (debug_mark+2),a  
c6a0 18 03			jr .pastdmark  
c6a2 ..			.dmark: db "ACC"  
c6a5 f1			.pastdmark: pop af  
c6a6			endm  
# End of macro DMARK
c6a6						CALLMONITOR 
c6a6 cd 6f ee			call debug_vector  
c6a9				endm  
# End of macro CALLMONITOR
c6a9					endif 
c6a9 21 bf e4				ld hl, os_input 
c6ac 3e 00				ld a, 0 
c6ae 77					ld (hl),a 
c6af 3a 5e ea				ld a,(f_cursor_ptr) 
c6b2 16 64				ld d, 100 
c6b4 0e 00				ld c, 0 
c6b6 1e 28				ld e, 40 
c6b8 cd 08 8d				call input_str 
c6bb					; TODO perhaps do a type check and wrap in quotes if not a number 
c6bb 21 bf e4				ld hl, os_input 
c6be					if DEBUG_FORTH_WORDS 
c6be						DMARK "AC1" 
c6be f5				push af  
c6bf 3a d3 c6			ld a, (.dmark)  
c6c2 32 6b ee			ld (debug_mark),a  
c6c5 3a d4 c6			ld a, (.dmark+1)  
c6c8 32 6c ee			ld (debug_mark+1),a  
c6cb 3a d5 c6			ld a, (.dmark+2)  
c6ce 32 6d ee			ld (debug_mark+2),a  
c6d1 18 03			jr .pastdmark  
c6d3 ..			.dmark: db "AC1"  
c6d6 f1			.pastdmark: pop af  
c6d7			endm  
# End of macro DMARK
c6d7						CALLMONITOR 
c6d7 cd 6f ee			call debug_vector  
c6da				endm  
# End of macro CALLMONITOR
c6da					endif 
c6da cd ca 9a				call forth_push_str 
c6dd					NEXTW 
c6dd c3 09 9e			jp macro_next 
c6e0				endm 
# End of macro NEXTW
c6e0			 
c6e0			.EDIT: 
c6e0				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c6e0 40				db WORD_SYS_CORE+44             
c6e1 82 c7			dw .DEDIT            
c6e3 05				db 4 + 1 
c6e4 .. 00			db "EDIT",0              
c6e9				endm 
# End of macro CWHEAD
c6e9			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c6e9			 
c6e9					; TODO does not copy from stack 
c6e9					if DEBUG_FORTH_WORDS_KEY 
c6e9						DMARK "EDT" 
c6e9 f5				push af  
c6ea 3a fe c6			ld a, (.dmark)  
c6ed 32 6b ee			ld (debug_mark),a  
c6f0 3a ff c6			ld a, (.dmark+1)  
c6f3 32 6c ee			ld (debug_mark+1),a  
c6f6 3a 00 c7			ld a, (.dmark+2)  
c6f9 32 6d ee			ld (debug_mark+2),a  
c6fc 18 03			jr .pastdmark  
c6fe ..			.dmark: db "EDT"  
c701 f1			.pastdmark: pop af  
c702			endm  
# End of macro DMARK
c702						CALLMONITOR 
c702 cd 6f ee			call debug_vector  
c705				endm  
# End of macro CALLMONITOR
c705					endif 
c705			 
c705					;FORTH_DSP 
c705					FORTH_DSP_VALUEHL 
c705 cd 53 9c			call macro_dsp_valuehl 
c708				endm 
# End of macro FORTH_DSP_VALUEHL
c708			;		inc hl    ; TODO do type check 
c708			 
c708			;		call get_word_hl 
c708 e5					push hl 
c709					if DEBUG_FORTH_WORDS 
c709						DMARK "EDp" 
c709 f5				push af  
c70a 3a 1e c7			ld a, (.dmark)  
c70d 32 6b ee			ld (debug_mark),a  
c710 3a 1f c7			ld a, (.dmark+1)  
c713 32 6c ee			ld (debug_mark+1),a  
c716 3a 20 c7			ld a, (.dmark+2)  
c719 32 6d ee			ld (debug_mark+2),a  
c71c 18 03			jr .pastdmark  
c71e ..			.dmark: db "EDp"  
c721 f1			.pastdmark: pop af  
c722			endm  
# End of macro DMARK
c722						CALLMONITOR 
c722 cd 6f ee			call debug_vector  
c725				endm  
# End of macro CALLMONITOR
c725					endif 
c725				;	ld a, 0 
c725 cd 4e 90				call strlenz 
c728 23					inc hl 
c729			 
c729 06 00				ld b, 0 
c72b 4d					ld c, l 
c72c			 
c72c e1					pop hl 
c72d 11 bf e4				ld de, os_input 
c730					if DEBUG_FORTH_WORDS_KEY 
c730						DMARK "EDc" 
c730 f5				push af  
c731 3a 45 c7			ld a, (.dmark)  
c734 32 6b ee			ld (debug_mark),a  
c737 3a 46 c7			ld a, (.dmark+1)  
c73a 32 6c ee			ld (debug_mark+1),a  
c73d 3a 47 c7			ld a, (.dmark+2)  
c740 32 6d ee			ld (debug_mark+2),a  
c743 18 03			jr .pastdmark  
c745 ..			.dmark: db "EDc"  
c748 f1			.pastdmark: pop af  
c749			endm  
# End of macro DMARK
c749						CALLMONITOR 
c749 cd 6f ee			call debug_vector  
c74c				endm  
# End of macro CALLMONITOR
c74c					endif 
c74c ed b0				ldir 
c74e			 
c74e			 
c74e 21 bf e4				ld hl, os_input 
c751					;ld a, 0 
c751					;ld (hl),a 
c751 3a 5e ea				ld a,(f_cursor_ptr) 
c754 16 64				ld d, 100 
c756 0e 00				ld c, 0 
c758 1e 28				ld e, 40 
c75a cd 08 8d				call input_str 
c75d					; TODO perhaps do a type check and wrap in quotes if not a number 
c75d 21 bf e4				ld hl, os_input 
c760					if DEBUG_FORTH_WORDS 
c760						DMARK "ED1" 
c760 f5				push af  
c761 3a 75 c7			ld a, (.dmark)  
c764 32 6b ee			ld (debug_mark),a  
c767 3a 76 c7			ld a, (.dmark+1)  
c76a 32 6c ee			ld (debug_mark+1),a  
c76d 3a 77 c7			ld a, (.dmark+2)  
c770 32 6d ee			ld (debug_mark+2),a  
c773 18 03			jr .pastdmark  
c775 ..			.dmark: db "ED1"  
c778 f1			.pastdmark: pop af  
c779			endm  
# End of macro DMARK
c779						CALLMONITOR 
c779 cd 6f ee			call debug_vector  
c77c				endm  
# End of macro CALLMONITOR
c77c					endif 
c77c cd ca 9a				call forth_push_str 
c77f					NEXTW 
c77f c3 09 9e			jp macro_next 
c782				endm 
# End of macro NEXTW
c782			 
c782			.DEDIT: 
c782				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c782 40				db WORD_SYS_CORE+44             
c783 e4 c7			dw .ENDKEY            
c785 06				db 5 + 1 
c786 .. 00			db "DEDIT",0              
c78c				endm 
# End of macro CWHEAD
c78c			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c78c			 
c78c					; TODO does not copy from stack 
c78c					if DEBUG_FORTH_WORDS_KEY 
c78c						DMARK "DED" 
c78c f5				push af  
c78d 3a a1 c7			ld a, (.dmark)  
c790 32 6b ee			ld (debug_mark),a  
c793 3a a2 c7			ld a, (.dmark+1)  
c796 32 6c ee			ld (debug_mark+1),a  
c799 3a a3 c7			ld a, (.dmark+2)  
c79c 32 6d ee			ld (debug_mark+2),a  
c79f 18 03			jr .pastdmark  
c7a1 ..			.dmark: db "DED"  
c7a4 f1			.pastdmark: pop af  
c7a5			endm  
# End of macro DMARK
c7a5						CALLMONITOR 
c7a5 cd 6f ee			call debug_vector  
c7a8				endm  
# End of macro CALLMONITOR
c7a8					endif 
c7a8			 
c7a8					;FORTH_DSP 
c7a8					FORTH_DSP_VALUEHL 
c7a8 cd 53 9c			call macro_dsp_valuehl 
c7ab				endm 
# End of macro FORTH_DSP_VALUEHL
c7ab			;		inc hl    ; TODO do type check 
c7ab			 
c7ab			;		call get_word_hl 
c7ab e5					push hl 
c7ac e5					push hl 
c7ad					FORTH_DSP_POP 
c7ad cd 0b 9d			call macro_forth_dsp_pop 
c7b0				endm 
# End of macro FORTH_DSP_POP
c7b0 e1					pop hl 
c7b1					if DEBUG_FORTH_WORDS 
c7b1						DMARK "EDp" 
c7b1 f5				push af  
c7b2 3a c6 c7			ld a, (.dmark)  
c7b5 32 6b ee			ld (debug_mark),a  
c7b8 3a c7 c7			ld a, (.dmark+1)  
c7bb 32 6c ee			ld (debug_mark+1),a  
c7be 3a c8 c7			ld a, (.dmark+2)  
c7c1 32 6d ee			ld (debug_mark+2),a  
c7c4 18 03			jr .pastdmark  
c7c6 ..			.dmark: db "EDp"  
c7c9 f1			.pastdmark: pop af  
c7ca			endm  
# End of macro DMARK
c7ca						CALLMONITOR 
c7ca cd 6f ee			call debug_vector  
c7cd				endm  
# End of macro CALLMONITOR
c7cd					endif 
c7cd				;	ld a, 0 
c7cd cd 4e 90				call strlenz 
c7d0 23					inc hl 
c7d1			 
c7d1 06 00				ld b, 0 
c7d3 4d					ld c, l 
c7d4			 
c7d4 e1					pop hl 
c7d5			 
c7d5					;ld a, 0 
c7d5					;ld (hl),a 
c7d5 3a 5e ea				ld a,(f_cursor_ptr) 
c7d8 16 64				ld d, 100 
c7da 0e 00				ld c, 0 
c7dc 1e 28				ld e, 40 
c7de cd 08 8d				call input_str 
c7e1					; TODO perhaps do a type check and wrap in quotes if not a number 
c7e1					NEXTW 
c7e1 c3 09 9e			jp macro_next 
c7e4				endm 
# End of macro NEXTW
c7e4			 
c7e4			 
c7e4			.ENDKEY: 
c7e4			; eof 
c7e4			 
# End of file forth_words_key.asm
c7e4			include "forth_words_const.asm" 
c7e4			 
c7e4			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c7e4			 
c7e4			 
c7e4			.SPITIME: 
c7e4				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c7e4 77				db WORD_SYS_CORE+99             
c7e5 f9 c7			dw .VA            
c7e7 08				db 7 + 1 
c7e8 .. 00			db "SPITIME",0              
c7f0				endm 
# End of macro CWHEAD
c7f0			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
c7f0			; 
c7f0			; | | If using BANK devices then leave as is. 
c7f0			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
c7f0			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
c7f0			 
c7f0 21 64 ea				ld hl, spi_clktime  
c7f3 cd 5c 9a				call forth_push_numhl 
c7f6			 
c7f6					NEXTW 
c7f6 c3 09 9e			jp macro_next 
c7f9				endm 
# End of macro NEXTW
c7f9			 
c7f9			 
c7f9			.VA: 
c7f9				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c7f9 77				db WORD_SYS_CORE+99             
c7fa 09 c8			dw .SYMBOL            
c7fc 03				db 2 + 1 
c7fd .. 00			db "VA",0              
c800				endm 
# End of macro CWHEAD
c800			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
c800 21 28 ea				ld hl, cli_var_array 
c803 cd 5c 9a				call forth_push_numhl 
c806			 
c806					NEXTW 
c806 c3 09 9e			jp macro_next 
c809				endm 
# End of macro NEXTW
c809			 
c809			.SYMBOL: 
c809				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c809 77				db WORD_SYS_CORE+99             
c80a 13 c9			dw .ENDCONST            
c80c 07				db 6 + 1 
c80d .. 00			db "SYMBOL",0              
c814				endm 
# End of macro CWHEAD
c814			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c814			; | 
c814			; | | The value is the number reference and the final address is pushed to stack 
c814			 
c814			; | | ``` 
c814			; | | dw sym_table 
c814			; | | dw nmi_vector 
c814			; | | dw cli_autodisplay 
c814			; | | dw cli_data_sp 
c814			; | | dw cli_data_stack 
c814			; | | dw cli_loop_sp 
c814			; | | dw cli_loop_stack 
c814			; | | dw cli_var_array 
c814			; | | dw cursor_col 
c814			; | | dw cursor_ptr 
c814			; | | ; 10 
c814			; | | dw cursor_row 
c814			; | | dw debug_mark 
c814			; | | dw display_fb0 
c814			; | | dw display_fb1 
c814			; | | dw display_fb2 
c814			; | | dw display_fb3 
c814			; | | dw display_fb_active 
c814			; | | dw execscratch 
c814			; | | dw f_cursor_ptr 
c814			; | | dw hardware_word 
c814			; | | ;20 
c814			; | | dw input_at_cursor 
c814			; | | dw input_at_pos 
c814			; | | dw input_cur_flash 
c814			; | | dw input_cur_onoff 
c814			; | | dw input_cursor 
c814			; | | dw input_display_size 
c814			; | | dw input_len 
c814			; | | dw input_ptr 
c814			; | | dw input_size 
c814			; | | dw input_start 
c814			; | | ; 30 
c814			; | | dw input_str 
c814			; | | dw input_under_cursor 
c814			; | | dw os_cli_cmd 
c814			; | | dw os_cur_ptr 
c814			; | | dw os_current_i 
c814			; | | dw os_input 
c814			; | | dw os_last_cmd 
c814			; | | dw os_last_new_uword 
c814			; | | dw debug_vector 
c814			; | | dw os_view_hl 
c814			; | | ;40 
c814			; | | dw os_word_scratch 
c814			; | | dw portbctl 
c814			; | | dw portbdata 
c814			; | | dw spi_cartdev 
c814			; | | dw spi_cartdev2 
c814			; | | dw spi_clktime 
c814			; | | dw spi_device 
c814			; | | dw spi_device_id 
c814			; | | dw spi_portbyte 
c814			; | | dw stackstore 
c814			; | | ; 50 
c814			; | | if STORAGE_SE 
c814			; | | dw storage_actl 
c814			; | | dw storage_adata 
c814			; | | else 
c814			; | | dw 0 
c814			; | | dw 0 
c814			; | | endif 
c814			; | | dw storage_append 
c814			; | | if STORAGE_SE 
c814			; | | dw storage_bctl 
c814			; | | else 
c814			; | | dw 0 
c814			; | | endif 
c814			; | | dw store_bank_active 
c814			; | | dw store_filecache 
c814			; | | dw store_longread 
c814			; | | dw store_openaddr 
c814			; | | dw store_openext 
c814			; | | dw store_openmaxext 
c814			; | | ; 60 
c814			; | | dw store_page 
c814			; | | dw store_readbuf 
c814			; | | dw store_readcont 
c814			; | | dw store_readptr 
c814			; | | dw store_tmpext 
c814			; | | dw store_tmpid 
c814			; | | dw store_tmppageid 
c814			; | | dw malloc 
c814			; | | dw free 
c814			; | | dw cin 
c814			; | | ; 70 
c814			; | | dw cin_wait 
c814			; | | dw forth_push_numhl 
c814			; | | dw forth_push_str 
c814			; | | ``` 
c814			 
c814					if DEBUG_FORTH_WORDS_KEY 
c814						DMARK "SYM" 
c814 f5				push af  
c815 3a 29 c8			ld a, (.dmark)  
c818 32 6b ee			ld (debug_mark),a  
c81b 3a 2a c8			ld a, (.dmark+1)  
c81e 32 6c ee			ld (debug_mark+1),a  
c821 3a 2b c8			ld a, (.dmark+2)  
c824 32 6d ee			ld (debug_mark+2),a  
c827 18 03			jr .pastdmark  
c829 ..			.dmark: db "SYM"  
c82c f1			.pastdmark: pop af  
c82d			endm  
# End of macro DMARK
c82d						CALLMONITOR 
c82d cd 6f ee			call debug_vector  
c830				endm  
# End of macro CALLMONITOR
c830					endif 
c830			 
c830					FORTH_DSP_VALUEHL 
c830 cd 53 9c			call macro_dsp_valuehl 
c833				endm 
# End of macro FORTH_DSP_VALUEHL
c833			 
c833 7d					ld a, l     
c834			 
c834			 
c834					if DEBUG_FORTH_WORDS 
c834						DMARK "SY1" 
c834 f5				push af  
c835 3a 49 c8			ld a, (.dmark)  
c838 32 6b ee			ld (debug_mark),a  
c83b 3a 4a c8			ld a, (.dmark+1)  
c83e 32 6c ee			ld (debug_mark+1),a  
c841 3a 4b c8			ld a, (.dmark+2)  
c844 32 6d ee			ld (debug_mark+2),a  
c847 18 03			jr .pastdmark  
c849 ..			.dmark: db "SY1"  
c84c f1			.pastdmark: pop af  
c84d			endm  
# End of macro DMARK
c84d						CALLMONITOR 
c84d cd 6f ee			call debug_vector  
c850				endm  
# End of macro CALLMONITOR
c850					endif 
c850					 
c850 f5					push af	 
c851					FORTH_DSP_POP 
c851 cd 0b 9d			call macro_forth_dsp_pop 
c854				endm 
# End of macro FORTH_DSP_POP
c854 f1					pop af 
c855			 
c855 cb 27				sla a  
c857				 
c857					 
c857					if DEBUG_FORTH_WORDS 
c857						DMARK "SY" 
c857 f5				push af  
c858 3a 6c c8			ld a, (.dmark)  
c85b 32 6b ee			ld (debug_mark),a  
c85e 3a 6d c8			ld a, (.dmark+1)  
c861 32 6c ee			ld (debug_mark+1),a  
c864 3a 6e c8			ld a, (.dmark+2)  
c867 32 6d ee			ld (debug_mark+2),a  
c86a 18 02			jr .pastdmark  
c86c ..			.dmark: db "SY"  
c86e f1			.pastdmark: pop af  
c86f			endm  
# End of macro DMARK
c86f						CALLMONITOR 
c86f cd 6f ee			call debug_vector  
c872				endm  
# End of macro CALLMONITOR
c872					endif 
c872			 
c872 21 81 c8				ld hl, sym_table 
c875 cd db 8c				call addatohl 
c878 cd 8b 9d				call loadwordinhl 
c87b cd 5c 9a				call forth_push_numhl 
c87e			 
c87e			 
c87e				       NEXTW 
c87e c3 09 9e			jp macro_next 
c881				endm 
# End of macro NEXTW
c881			 
c881			sym_table: 
c881			 
c881			; 0 
c881 81 c8		dw sym_table 
c883 72 ee		dw nmi_vector 
c885 3c ea		dw cli_autodisplay 
c887 ee e9		dw cli_data_sp 
c889 28 e8		dw cli_data_stack 
c88b f0 e9		dw cli_loop_sp 
c88d 2a e9		dw cli_loop_stack 
c88f 28 ea		dw cli_var_array 
c891 c5 eb		dw cursor_col 
c893 c3 eb		dw cursor_ptr 
c895			; 10 
c895 c4 eb		dw cursor_row 
c897 6b ee		dw debug_mark 
c899 b1 ed		dw display_fb0 
c89b 10 ed		dw display_fb1 
c89d ce eb		dw display_fb2 
c89f 6f ec		dw display_fb3 
c8a1 cc eb		dw display_fb_active 
c8a3 c0 e3		dw execscratch 
c8a5 5e ea		dw f_cursor_ptr 
c8a7 75 ee		dw hardware_word 
c8a9			;20 
c8a9 62 ee		dw input_at_cursor 
c8ab 64 ee		dw input_at_pos 
c8ad 60 ee		dw input_cur_flash 
c8af 5f ee		dw input_cur_onoff 
c8b1 55 ee		dw input_cursor 
c8b3 65 ee		dw input_display_size 
c8b5 5a ee		dw input_len 
c8b7 69 ee		dw input_ptr 
c8b9 66 ee		dw input_size 
c8bb 67 ee		dw input_start 
c8bd			; 30 
c8bd 08 8d		dw input_str 
c8bf 63 ee		dw input_under_cursor 
c8c1 e8 e5		dw os_cli_cmd 
c8c3 e4 e5		dw os_cur_ptr 
c8c5 e6 e5		dw os_current_i 
c8c7 bf e4		dw os_input 
c8c9 e7 e6		dw os_last_cmd 
c8cb be e5		dw os_last_new_uword 
c8cd 6f ee		dw debug_vector 
c8cf a3 e2		dw os_view_hl 
c8d1			;40 
c8d1 c6 e5		dw os_word_scratch 
c8d3 c3 00		dw portbctl 
c8d5 c1 00		dw portbdata 
c8d7 63 ea		dw spi_cartdev 
c8d9 62 ea		dw spi_cartdev2 
c8db 64 ea		dw spi_clktime 
c8dd 60 ea		dw spi_device 
c8df 5f ea		dw spi_device_id 
c8e1 61 ea		dw spi_portbyte 
c8e3 a7 eb		dw stackstore 
c8e5			; 50 
c8e5			if STORAGE_SE 
c8e5			dw storage_actl 
c8e5			dw storage_adata 
c8e5			else 
c8e5 00 00		dw 0 
c8e7 00 00		dw 0 
c8e9			endif 
c8e9 68 88		dw storage_append 
c8eb			if STORAGE_SE 
c8eb			dw storage_bctl 
c8eb			else 
c8eb 00 00		dw 0 
c8ed			endif 
c8ed 93 eb		dw store_bank_active 
c8ef 67 ea		dw store_filecache 
c8f1 75 ea		dw store_longread 
c8f3 6b ea		dw store_openaddr 
c8f5 6a ea		dw store_openext 
c8f7 69 ea		dw store_openmaxext 
c8f9			; 60 
c8f9 7a ea		dw store_page 
c8fb 76 ea		dw store_readbuf 
c8fd 6d ea		dw store_readcont 
c8ff 78 ea		dw store_readptr 
c901 6d ea		dw store_tmpext 
c903 6e ea		dw store_tmpid 
c905 65 ea		dw store_tmppageid 
c907 c3 90		dw malloc 
c909 8d 91		dw free 
c90b ea e3		dw cin 
c90d			; 70 
c90d e4 e3		dw cin_wait 
c90f 5c 9a		dw forth_push_numhl 
c911 ca 9a		dw forth_push_str 
c913			 
c913			 
c913			.ENDCONST: 
c913			 
c913			; eof 
c913			 
c913			 
# End of file forth_words_const.asm
c913			 
c913			if STORAGE_SE 
c913			   	include "forth_words_storage.asm" 
c913			endif 
c913				include "forth_words_device.asm" 
c913			; Device related words 
c913			 
c913			; | ## Device Words 
c913			 
c913			;if SOUND_ENABLE 
c913			;.NOTE: 
c913			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c913			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
c913			;		if DEBUG_FORTH_WORDS_KEY 
c913			;			DMARK "NTE" 
c913			;			CALLMONITOR 
c913			;		endif 
c913			; 
c913			;	 
c913			; 
c913			;		NEXTW 
c913			;.AFTERSOUND: 
c913			;endif 
c913			 
c913			 
c913			USE_GPIO: equ 0 
c913			 
c913			if USE_GPIO 
c913			.GP1: 
c913				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c913			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
c913					NEXTW 
c913			.GP2: 
c913				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c913			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
c913			 
c913					NEXTW 
c913			 
c913			.GP3: 
c913				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c913			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
c913			 
c913					NEXTW 
c913			 
c913			.GP4: 
c913				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c913			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
c913			 
c913					NEXTW 
c913			.SIN: 
c913			 
c913			 
c913			endif 
c913			 
c913			 
c913				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c913 33				db WORD_SYS_CORE+31             
c914 48 c9			dw .SOUT            
c916 03				db 2 + 1 
c917 .. 00			db "IN",0              
c91a				endm 
# End of macro CWHEAD
c91a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c91a					if DEBUG_FORTH_WORDS_KEY 
c91a						DMARK "IN." 
c91a f5				push af  
c91b 3a 2f c9			ld a, (.dmark)  
c91e 32 6b ee			ld (debug_mark),a  
c921 3a 30 c9			ld a, (.dmark+1)  
c924 32 6c ee			ld (debug_mark+1),a  
c927 3a 31 c9			ld a, (.dmark+2)  
c92a 32 6d ee			ld (debug_mark+2),a  
c92d 18 03			jr .pastdmark  
c92f ..			.dmark: db "IN."  
c932 f1			.pastdmark: pop af  
c933			endm  
# End of macro DMARK
c933						CALLMONITOR 
c933 cd 6f ee			call debug_vector  
c936				endm  
# End of macro CALLMONITOR
c936					endif 
c936					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c936 cd 53 9c			call macro_dsp_valuehl 
c939				endm 
# End of macro FORTH_DSP_VALUEHL
c939			 
c939 e5					push hl 
c93a			 
c93a					; destroy value TOS 
c93a			 
c93a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c93a cd 0b 9d			call macro_forth_dsp_pop 
c93d				endm 
# End of macro FORTH_DSP_POP
c93d			 
c93d					; one value on hl get other one back 
c93d			 
c93d c1					pop bc 
c93e			 
c93e					; do the sub 
c93e			;		ex de, hl 
c93e			 
c93e ed 68				in l,(c) 
c940			 
c940					; save it 
c940			 
c940 26 00				ld h,0 
c942			 
c942					; TODO push value back onto stack for another op etc 
c942			 
c942 cd 5c 9a				call forth_push_numhl 
c945					NEXTW 
c945 c3 09 9e			jp macro_next 
c948				endm 
# End of macro NEXTW
c948			.SOUT: 
c948				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c948 34				db WORD_SYS_CORE+32             
c949 9b c9			dw .SPIO            
c94b 04				db 3 + 1 
c94c .. 00			db "OUT",0              
c950				endm 
# End of macro CWHEAD
c950			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c950					if DEBUG_FORTH_WORDS_KEY 
c950						DMARK "OUT" 
c950 f5				push af  
c951 3a 65 c9			ld a, (.dmark)  
c954 32 6b ee			ld (debug_mark),a  
c957 3a 66 c9			ld a, (.dmark+1)  
c95a 32 6c ee			ld (debug_mark+1),a  
c95d 3a 67 c9			ld a, (.dmark+2)  
c960 32 6d ee			ld (debug_mark+2),a  
c963 18 03			jr .pastdmark  
c965 ..			.dmark: db "OUT"  
c968 f1			.pastdmark: pop af  
c969			endm  
# End of macro DMARK
c969						CALLMONITOR 
c969 cd 6f ee			call debug_vector  
c96c				endm  
# End of macro CALLMONITOR
c96c					endif 
c96c			 
c96c					; get port 
c96c			 
c96c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c96c cd 53 9c			call macro_dsp_valuehl 
c96f				endm 
# End of macro FORTH_DSP_VALUEHL
c96f			 
c96f e5					push hl 
c970			 
c970					; destroy value TOS 
c970			 
c970					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c970 cd 0b 9d			call macro_forth_dsp_pop 
c973				endm 
# End of macro FORTH_DSP_POP
c973			 
c973					; get byte to send 
c973			 
c973					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c973 cd 53 9c			call macro_dsp_valuehl 
c976				endm 
# End of macro FORTH_DSP_VALUEHL
c976			 
c976			;		push hl 
c976			 
c976					; destroy value TOS 
c976			 
c976					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c976 cd 0b 9d			call macro_forth_dsp_pop 
c979				endm 
# End of macro FORTH_DSP_POP
c979			 
c979					; one value on hl get other one back 
c979			 
c979			;		pop hl 
c979			 
c979 c1					pop bc 
c97a			 
c97a					if DEBUG_FORTH_WORDS 
c97a						DMARK "OUT" 
c97a f5				push af  
c97b 3a 8f c9			ld a, (.dmark)  
c97e 32 6b ee			ld (debug_mark),a  
c981 3a 90 c9			ld a, (.dmark+1)  
c984 32 6c ee			ld (debug_mark+1),a  
c987 3a 91 c9			ld a, (.dmark+2)  
c98a 32 6d ee			ld (debug_mark+2),a  
c98d 18 03			jr .pastdmark  
c98f ..			.dmark: db "OUT"  
c992 f1			.pastdmark: pop af  
c993			endm  
# End of macro DMARK
c993						CALLMONITOR 
c993 cd 6f ee			call debug_vector  
c996				endm  
# End of macro CALLMONITOR
c996					endif 
c996			 
c996 ed 69				out (c), l 
c998			 
c998					NEXTW 
c998 c3 09 9e			jp macro_next 
c99b				endm 
# End of macro NEXTW
c99b			 
c99b			 
c99b			.SPIO: 
c99b			 
c99b			if STORAGE_SE 
c99b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c99b			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c99b			 
c99b					call spi_ce_low 
c99b			    NEXTW 
c99b			 
c99b			.SPICEH: 
c99b				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c99b			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c99b			 
c99b					call spi_ce_high 
c99b			    NEXTW 
c99b			 
c99b			 
c99b			.SPIOb: 
c99b			 
c99b				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c99b			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c99b			 
c99b					if DEBUG_FORTH_WORDS_KEY 
c99b						DMARK "SPo" 
c99b						CALLMONITOR 
c99b					endif 
c99b					; get port 
c99b			 
c99b			 
c99b					; get byte to send 
c99b			 
c99b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c99b			 
c99b			;		push hl    ; u1  
c99b			 
c99b					; destroy value TOS 
c99b			 
c99b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c99b			 
c99b					; one value on hl get other one back 
c99b			 
c99b			;		pop hl   ; u2 - addr 
c99b			 
c99b					; TODO Send SPI byte 
c99b			 
c99b			;		push hl 
c99b			;		call spi_ce_low 
c99b			;		pop hl 
c99b					ld a, l 
c99b					call spi_send_byte 
c99b			;		call spi_ce_high 
c99b			 
c99b					NEXTW 
c99b			 
c99b			.SPII: 
c99b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c99b			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c99b					if DEBUG_FORTH_WORDS_KEY 
c99b						DMARK "SPi" 
c99b						CALLMONITOR 
c99b					endif 
c99b			 
c99b					; TODO Get SPI byte 
c99b			 
c99b					call spi_read_byte 
c99b			 
c99b					if DEBUG_FORTH_WORDS 
c99b						DMARK "Si2" 
c99b						CALLMONITOR 
c99b					endif 
c99b					ld h, 0 
c99b					ld l, a 
c99b					if DEBUG_FORTH_WORDS 
c99b						DMARK "Si3" 
c99b						CALLMONITOR 
c99b					endif 
c99b					call forth_push_numhl 
c99b			 
c99b					NEXTW 
c99b			 
c99b			 
c99b			 
c99b			.SESEL: 
c99b				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c99b			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c99b					if DEBUG_FORTH_WORDS_KEY 
c99b						DMARK "BNK" 
c99b						CALLMONITOR 
c99b					endif 
c99b			 
c99b					ld a, 255 
c99b					ld (spi_cartdev), a 
c99b			 
c99b					; get bank 
c99b			 
c99b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c99b			 
c99b			;		push hl 
c99b			 
c99b					; destroy value TOS 
c99b			 
c99b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c99b			 
c99b					; one value on hl get other one back 
c99b			 
c99b			;		pop hl 
c99b			 
c99b			 
c99b					ld c, SPI_CE_HIGH 
c99b					ld b, '0'    ; human readable bank number 
c99b			 
c99b					ld a, l 
c99b			 
c99b					if DEBUG_FORTH_WORDS 
c99b						DMARK "BNK" 
c99b						CALLMONITOR 
c99b					endif 
c99b			 
c99b					; active low 
c99b			 
c99b					cp 0 
c99b					jr z, .bset 
c99b					cp 1 
c99b					jr nz, .b2 
c99b					res 0, c 
c99b					ld b, '1'    ; human readable bank number 
c99b			.b2:		cp 2 
c99b					jr nz, .b3 
c99b					res 1, c 
c99b					ld b, '2'    ; human readable bank number 
c99b			.b3:		cp 3 
c99b					jr nz, .b4 
c99b					res 2, c 
c99b					ld b, '3'    ; human readable bank number 
c99b			.b4:		cp 4 
c99b					jr nz, .b5 
c99b					res 3, c 
c99b					ld b, '4'    ; human readable bank number 
c99b			.b5:		cp 5 
c99b					jr nz, .bset 
c99b					res 4, c 
c99b					ld b, '5'    ; human readable bank number 
c99b			 
c99b			.bset: 
c99b					ld a, c 
c99b					ld (spi_device),a 
c99b					ld a, b 
c99b					ld (spi_device_id),a 
c99b					if DEBUG_FORTH_WORDS 
c99b						DMARK "BN2" 
c99b						CALLMONITOR 
c99b					endif 
c99b			 
c99b					; set default SPI clk pulse time as disabled for BANK use 
c99b			 
c99b					ld a, 0 
c99b					ld (spi_clktime), a 
c99b			 
c99b					NEXTW 
c99b			 
c99b			.CARTDEV: 
c99b				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c99b			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c99b					if DEBUG_FORTH_WORDS_KEY 
c99b						DMARK "CDV" 
c99b						CALLMONITOR 
c99b					endif 
c99b			 
c99b					; disable se storage bank selection 
c99b			 
c99b					ld a, SPI_CE_HIGH		; ce high 
c99b					ld (spi_device), a 
c99b			 
c99b					; get bank 
c99b			 
c99b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c99b			 
c99b			;		push hl 
c99b			 
c99b					; destroy value TOS 
c99b			 
c99b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c99b			 
c99b					; one value on hl get other one back 
c99b			 
c99b			;		pop hl 
c99b			 
c99b					; active low 
c99b			 
c99b					ld c, 255 
c99b			 
c99b					ld a, l 
c99b					if DEBUG_FORTH_WORDS 
c99b						DMARK "CDV" 
c99b						CALLMONITOR 
c99b					endif 
c99b					cp 0 
c99b					jr z, .cset 
c99b					cp 1 
c99b					jr nz, .c2 
c99b					res 0, c 
c99b			.c2:		cp 2 
c99b					jr nz, .c3 
c99b					res 1, c 
c99b			.c3:		cp 3 
c99b					jr nz, .c4 
c99b					res 2, c 
c99b			.c4:		cp 4 
c99b					jr nz, .c5 
c99b					res 3, c 
c99b			.c5:		cp 5 
c99b					jr nz, .c6 
c99b					res 4, c 
c99b			.c6:		cp 6 
c99b					jr nz, .c7 
c99b					res 5, c 
c99b			.c7:		cp 7 
c99b					jr nz, .c8 
c99b					res 6, c 
c99b			.c8:		cp 8 
c99b					jr nz, .cset 
c99b					res 7, c 
c99b			.cset:		ld a, c 
c99b					ld (spi_cartdev),a 
c99b			 
c99b					if DEBUG_FORTH_WORDS 
c99b						DMARK "CD2" 
c99b						CALLMONITOR 
c99b					endif 
c99b			 
c99b					; set default SPI clk pulse time as 10ms for CARTDEV use 
c99b			 
c99b					ld a, $0a 
c99b					ld (spi_clktime), a 
c99b					NEXTW 
c99b			endif 
c99b			 
c99b			.ENDDEVICE: 
c99b			; eof 
c99b			 
# End of file forth_words_device.asm
c99b			 
c99b			; var handler 
c99b			 
c99b			 
c99b			.VARS: 
c99b				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c99b 77				db WORD_SYS_CORE+99             
c99c 4c ca			dw .V0            
c99e 04				db 3 + 1 
c99f .. 00			db "VAR",0              
c9a3				endm 
# End of macro CWHEAD
c9a3			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9a3			;| 
c9a3			;| The variable name should consist of a single letter. e.g. "a" 
c9a3			;! If a full string is passed then only the first char is looked at 
c9a3			;| Any other char could exceed bounds checks!  
c9a3			 
c9a3					if DEBUG_FORTH_WORDS_KEY 
c9a3						DMARK "VAR" 
c9a3 f5				push af  
c9a4 3a b8 c9			ld a, (.dmark)  
c9a7 32 6b ee			ld (debug_mark),a  
c9aa 3a b9 c9			ld a, (.dmark+1)  
c9ad 32 6c ee			ld (debug_mark+1),a  
c9b0 3a ba c9			ld a, (.dmark+2)  
c9b3 32 6d ee			ld (debug_mark+2),a  
c9b6 18 03			jr .pastdmark  
c9b8 ..			.dmark: db "VAR"  
c9bb f1			.pastdmark: pop af  
c9bc			endm  
# End of macro DMARK
c9bc						CALLMONITOR 
c9bc cd 6f ee			call debug_vector  
c9bf				endm  
# End of macro CALLMONITOR
c9bf					endif 
c9bf			 
c9bf					FORTH_DSP_VALUEHL 
c9bf cd 53 9c			call macro_dsp_valuehl 
c9c2				endm 
# End of macro FORTH_DSP_VALUEHL
c9c2			 
c9c2 7e					ld a, (hl)    ; get first char on of the string 
c9c3			 
c9c3			 
c9c3					if DEBUG_FORTH_WORDS 
c9c3						DMARK "VR1" 
c9c3 f5				push af  
c9c4 3a d8 c9			ld a, (.dmark)  
c9c7 32 6b ee			ld (debug_mark),a  
c9ca 3a d9 c9			ld a, (.dmark+1)  
c9cd 32 6c ee			ld (debug_mark+1),a  
c9d0 3a da c9			ld a, (.dmark+2)  
c9d3 32 6d ee			ld (debug_mark+2),a  
c9d6 18 03			jr .pastdmark  
c9d8 ..			.dmark: db "VR1"  
c9db f1			.pastdmark: pop af  
c9dc			endm  
# End of macro DMARK
c9dc						CALLMONITOR 
c9dc cd 6f ee			call debug_vector  
c9df				endm  
# End of macro CALLMONITOR
c9df					endif 
c9df					 
c9df f5					push af	 
c9e0					FORTH_DSP_POP 
c9e0 cd 0b 9d			call macro_forth_dsp_pop 
c9e3				endm 
# End of macro FORTH_DSP_POP
c9e3 f1					pop af 
c9e4			 
c9e4					; convert to upper 
c9e4			 
c9e4 cd 5d 8f				call to_upper 
c9e7					if DEBUG_FORTH_WORDS 
c9e7						DMARK "Vaa" 
c9e7 f5				push af  
c9e8 3a fc c9			ld a, (.dmark)  
c9eb 32 6b ee			ld (debug_mark),a  
c9ee 3a fd c9			ld a, (.dmark+1)  
c9f1 32 6c ee			ld (debug_mark+1),a  
c9f4 3a fe c9			ld a, (.dmark+2)  
c9f7 32 6d ee			ld (debug_mark+2),a  
c9fa 18 03			jr .pastdmark  
c9fc ..			.dmark: db "Vaa"  
c9ff f1			.pastdmark: pop af  
ca00			endm  
# End of macro DMARK
ca00						CALLMONITOR 
ca00 cd 6f ee			call debug_vector  
ca03				endm  
# End of macro CALLMONITOR
ca03					endif 
ca03 06 41				ld b, 'A' 
ca05 90					sub b			; set offset 
ca06					if DEBUG_FORTH_WORDS 
ca06						DMARK "Vbb" 
ca06 f5				push af  
ca07 3a 1b ca			ld a, (.dmark)  
ca0a 32 6b ee			ld (debug_mark),a  
ca0d 3a 1c ca			ld a, (.dmark+1)  
ca10 32 6c ee			ld (debug_mark+1),a  
ca13 3a 1d ca			ld a, (.dmark+2)  
ca16 32 6d ee			ld (debug_mark+2),a  
ca19 18 03			jr .pastdmark  
ca1b ..			.dmark: db "Vbb"  
ca1e f1			.pastdmark: pop af  
ca1f			endm  
# End of macro DMARK
ca1f						CALLMONITOR 
ca1f cd 6f ee			call debug_vector  
ca22				endm  
# End of macro CALLMONITOR
ca22					endif 
ca22 cb 27				sla a  
ca24				 
ca24					 
ca24					if DEBUG_FORTH_WORDS 
ca24						DMARK "VR2" 
ca24 f5				push af  
ca25 3a 39 ca			ld a, (.dmark)  
ca28 32 6b ee			ld (debug_mark),a  
ca2b 3a 3a ca			ld a, (.dmark+1)  
ca2e 32 6c ee			ld (debug_mark+1),a  
ca31 3a 3b ca			ld a, (.dmark+2)  
ca34 32 6d ee			ld (debug_mark+2),a  
ca37 18 03			jr .pastdmark  
ca39 ..			.dmark: db "VR2"  
ca3c f1			.pastdmark: pop af  
ca3d			endm  
# End of macro DMARK
ca3d						CALLMONITOR 
ca3d cd 6f ee			call debug_vector  
ca40				endm  
# End of macro CALLMONITOR
ca40					endif 
ca40			 
ca40 21 f4 e9				ld hl, cli_var_array2 
ca43 cd db 8c				call addatohl 
ca46 cd 5c 9a				call forth_push_numhl 
ca49			 
ca49			 
ca49				       NEXTW 
ca49 c3 09 9e			jp macro_next 
ca4c				endm 
# End of macro NEXTW
ca4c			.V0: 
ca4c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca4c 78				db WORD_SYS_CORE+100             
ca4d 64 ca			dw .V0Q            
ca4f 04				db 3 + 1 
ca50 .. 00			db "V0!",0              
ca54				endm 
# End of macro CWHEAD
ca54			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca54			 
ca54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca54 cd 53 9c			call macro_dsp_valuehl 
ca57				endm 
# End of macro FORTH_DSP_VALUEHL
ca57			 
ca57 11 28 ea				ld de, cli_var_array 
ca5a			 
ca5a eb					ex de, hl 
ca5b 73					ld (hl), e 
ca5c 23					inc hl 
ca5d 72					ld (hl), d 
ca5e			 
ca5e					; destroy value TOS 
ca5e			 
ca5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca5e cd 0b 9d			call macro_forth_dsp_pop 
ca61				endm 
# End of macro FORTH_DSP_POP
ca61			 
ca61				       NEXTW 
ca61 c3 09 9e			jp macro_next 
ca64				endm 
# End of macro NEXTW
ca64			.V0Q: 
ca64				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca64 79				db WORD_SYS_CORE+101             
ca65 75 ca			dw .V1S            
ca67 04				db 3 + 1 
ca68 .. 00			db "V0@",0              
ca6c				endm 
# End of macro CWHEAD
ca6c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ca6c 2a 28 ea				ld hl, (cli_var_array) 
ca6f cd 5c 9a				call forth_push_numhl 
ca72			 
ca72				       NEXTW 
ca72 c3 09 9e			jp macro_next 
ca75				endm 
# End of macro NEXTW
ca75			.V1S: 
ca75				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ca75 7a				db WORD_SYS_CORE+102             
ca76 8d ca			dw .V1Q            
ca78 04				db 3 + 1 
ca79 .. 00			db "V1!",0              
ca7d				endm 
# End of macro CWHEAD
ca7d			;| V1! ( u1 -- )  Store value to v1 | DONE 
ca7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca7d cd 53 9c			call macro_dsp_valuehl 
ca80				endm 
# End of macro FORTH_DSP_VALUEHL
ca80			 
ca80 11 2a ea				ld de, cli_var_array+2 
ca83				 
ca83 eb					ex de, hl 
ca84 73					ld (hl), e 
ca85 23					inc hl 
ca86 72					ld (hl), d 
ca87			 
ca87					; destroy value TOS 
ca87			 
ca87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca87 cd 0b 9d			call macro_forth_dsp_pop 
ca8a				endm 
# End of macro FORTH_DSP_POP
ca8a				       NEXTW 
ca8a c3 09 9e			jp macro_next 
ca8d				endm 
# End of macro NEXTW
ca8d			.V1Q: 
ca8d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
ca8d 7b				db WORD_SYS_CORE+103             
ca8e 9e ca			dw .V2S            
ca90 04				db 3 + 1 
ca91 .. 00			db "V1@",0              
ca95				endm 
# End of macro CWHEAD
ca95			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
ca95 2a 2a ea				ld hl, (cli_var_array+2) 
ca98 cd 5c 9a				call forth_push_numhl 
ca9b				       NEXTW 
ca9b c3 09 9e			jp macro_next 
ca9e				endm 
# End of macro NEXTW
ca9e			.V2S: 
ca9e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
ca9e 7c				db WORD_SYS_CORE+104             
ca9f b6 ca			dw .V2Q            
caa1 04				db 3 + 1 
caa2 .. 00			db "V2!",0              
caa6				endm 
# End of macro CWHEAD
caa6			;| V2! ( u1 -- )  Store value to v2 | DONE 
caa6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caa6 cd 53 9c			call macro_dsp_valuehl 
caa9				endm 
# End of macro FORTH_DSP_VALUEHL
caa9			 
caa9 11 2c ea				ld de, cli_var_array+4 
caac				 
caac eb					ex de, hl 
caad 73					ld (hl), e 
caae 23					inc hl 
caaf 72					ld (hl), d 
cab0			 
cab0					; destroy value TOS 
cab0			 
cab0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cab0 cd 0b 9d			call macro_forth_dsp_pop 
cab3				endm 
# End of macro FORTH_DSP_POP
cab3				       NEXTW 
cab3 c3 09 9e			jp macro_next 
cab6				endm 
# End of macro NEXTW
cab6			.V2Q: 
cab6				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cab6 7d				db WORD_SYS_CORE+105             
cab7 c7 ca			dw .V3S            
cab9 04				db 3 + 1 
caba .. 00			db "V2@",0              
cabe				endm 
# End of macro CWHEAD
cabe			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cabe 2a 2c ea				ld hl, (cli_var_array+4) 
cac1 cd 5c 9a				call forth_push_numhl 
cac4				       NEXTW 
cac4 c3 09 9e			jp macro_next 
cac7				endm 
# End of macro NEXTW
cac7			.V3S: 
cac7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cac7 7c				db WORD_SYS_CORE+104             
cac8 df ca			dw .V3Q            
caca 04				db 3 + 1 
cacb .. 00			db "V3!",0              
cacf				endm 
# End of macro CWHEAD
cacf			;| V3! ( u1 -- )  Store value to v3 | DONE 
cacf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cacf cd 53 9c			call macro_dsp_valuehl 
cad2				endm 
# End of macro FORTH_DSP_VALUEHL
cad2			 
cad2 11 2e ea				ld de, cli_var_array+6 
cad5				 
cad5 eb					ex de, hl 
cad6 73					ld (hl), e 
cad7 23					inc hl 
cad8 72					ld (hl), d 
cad9			 
cad9					; destroy value TOS 
cad9			 
cad9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cad9 cd 0b 9d			call macro_forth_dsp_pop 
cadc				endm 
# End of macro FORTH_DSP_POP
cadc				       NEXTW 
cadc c3 09 9e			jp macro_next 
cadf				endm 
# End of macro NEXTW
cadf			.V3Q: 
cadf				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cadf 7d				db WORD_SYS_CORE+105             
cae0 f0 ca			dw .END            
cae2 04				db 3 + 1 
cae3 .. 00			db "V3@",0              
cae7				endm 
# End of macro CWHEAD
cae7			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cae7 2a 2e ea				ld hl, (cli_var_array+6) 
caea cd 5c 9a				call forth_push_numhl 
caed				       NEXTW 
caed c3 09 9e			jp macro_next 
caf0				endm 
# End of macro NEXTW
caf0			 
caf0			 
caf0			 
caf0			 
caf0			 
caf0			; end of dict marker 
caf0			 
caf0 00			.END:    db WORD_SYS_END 
caf1 00 00			dw 0 
caf3 00				db 0 
caf4			 
caf4			; use to jp here for user dict words to save on macro expansion  
caf4			 
caf4			user_dict_next: 
caf4				NEXTW 
caf4 c3 09 9e			jp macro_next 
caf7				endm 
# End of macro NEXTW
caf7			 
caf7			 
caf7			user_exec: 
caf7				;    ld hl, <word code> 
caf7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
caf7				;    call forthexec 
caf7				;    jp user_dict_next   (NEXT) 
caf7			        ;    <word code bytes> 
caf7 eb				ex de, hl 
caf8 2a c2 e5			ld hl,(os_tok_ptr) 
cafb				 
cafb				FORTH_RSP_NEXT 
cafb cd 03 9a			call macro_forth_rsp_next 
cafe				endm 
# End of macro FORTH_RSP_NEXT
cafe			 
cafe			if DEBUG_FORTH_UWORD 
cafe						DMARK "UEX" 
cafe f5				push af  
caff 3a 13 cb			ld a, (.dmark)  
cb02 32 6b ee			ld (debug_mark),a  
cb05 3a 14 cb			ld a, (.dmark+1)  
cb08 32 6c ee			ld (debug_mark+1),a  
cb0b 3a 15 cb			ld a, (.dmark+2)  
cb0e 32 6d ee			ld (debug_mark+2),a  
cb11 18 03			jr .pastdmark  
cb13 ..			.dmark: db "UEX"  
cb16 f1			.pastdmark: pop af  
cb17			endm  
# End of macro DMARK
cb17				CALLMONITOR 
cb17 cd 6f ee			call debug_vector  
cb1a				endm  
# End of macro CALLMONITOR
cb1a			endif 
cb1a			 
cb1a			 
cb1a			 
cb1a eb				ex de, hl 
cb1b 22 c2 e5			ld (os_tok_ptr), hl 
cb1e				 
cb1e				; Don't use next - Skips the first word in uword. 
cb1e			 
cb1e c3 9a 9e			jp exec1 
cb21			;	NEXT 
cb21			 
cb21			 
cb21			; eof 
# End of file forth_wordsv4.asm
cb21			endif 
cb21			;;;;;;;;;;;;;; Debug code 
cb21			 
cb21			 
cb21			;if DEBUG_FORTH_PARSE 
cb21 .. 00		.nowordfound: db "No match",0 
cb2a .. 00		.compword:	db "Comparing word ",0 
cb3a .. 00		.nextwordat:	db "Next word at",0 
cb47 .. 00		.charmatch:	db "Char match",0 
cb52			;endif 
cb52			if DEBUG_FORTH_JP 
cb52			.foundword:	db "Word match. Exec..",0 
cb52			endif 
cb52			;if DEBUG_FORTH_PUSH 
cb52 .. 00		.enddict:	db "Dict end. Push.",0 
cb62 .. 00		.push_str:	db "Pushing string",0 
cb71 .. 00		.push_num:	db "Pushing number",0 
cb80 .. 00		.data_sp:	db "SP:",0 
cb84 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cb96 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cba8 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbba			;endif 
cbba			;if DEBUG_FORTH_MALLOC 
cbba .. 00		.push_malloc:	db "Malloc address",0 
cbc9			;endif 
cbc9			 
cbc9			 
cbc9			 
cbc9			; display malloc address and current data stack pointer  
cbc9			 
cbc9			malloc_error: 
cbc9 d5				push de 
cbca f5				push af 
cbcb e5				push hl 
cbcc cd ae 8a			call clear_display 
cbcf 11 ef cb			ld de, .mallocerr 
cbd2 3e 00			ld a,0 
cbd4			;	ld de,os_word_scratch 
cbd4 cd c1 8a			call str_at_display 
cbd7 3e 11			ld a, display_row_1+17 
cbd9 11 6b ee			ld de, debug_mark 
cbdc cd c1 8a			call str_at_display 
cbdf cd d1 8a			call update_display 
cbe2				;call break_point_state 
cbe2 cd e4 e3			call cin_wait 
cbe5			 
cbe5			;	ld a, ' ' 
cbe5			;	ld (os_view_disable), a 
cbe5 cd f2 93			call bp_on 
cbe8 e1				pop hl 
cbe9 f1				pop af 
cbea d1				pop de	 
cbeb				CALLMONITOR 
cbeb cd 6f ee			call debug_vector  
cbee				endm  
# End of macro CALLMONITOR
cbee c9				ret 
cbef			 
cbef .. 00		.mallocerr: 	db "Malloc Error",0 
cbfc			;if DEBUG_FORTH_PUSH 
cbfc			display_data_sp: 
cbfc f5				push af 
cbfd			 
cbfd				; see if disabled 
cbfd			 
cbfd			 
cbfd 3a 6f ee			ld a, (debug_vector) 
cc00 fe c9			cp $C9  ; RET 
cc02				;ld a, (os_view_disable) 
cc02				;cp '*' 
cc02 28 67			jr z, .skipdsp 
cc04			 
cc04 e5				push hl 
cc05 e5				push hl 
cc06 e5			push hl 
cc07 cd ae 8a			call clear_display 
cc0a e1			pop hl 
cc0b 7c				ld a,h 
cc0c 21 c6 e5			ld hl, os_word_scratch 
cc0f cd f1 8e			call hexout 
cc12 e1				pop hl 
cc13 7d				ld a,l 
cc14 21 c8 e5			ld hl, os_word_scratch+2 
cc17 cd f1 8e			call hexout 
cc1a 21 ca e5			ld hl, os_word_scratch+4 
cc1d 3e 00			ld a,0 
cc1f 77				ld (hl),a 
cc20 11 c6 e5			ld de,os_word_scratch 
cc23 3e 28				ld a, display_row_2 
cc25 cd c1 8a				call str_at_display 
cc28 11 84 cb			ld de, .wordinhl 
cc2b 3e 00			ld a, display_row_1 
cc2d			 
cc2d cd c1 8a				call str_at_display 
cc30 11 6b ee			ld de, debug_mark 
cc33 3e 11			ld a, display_row_1+17 
cc35			 
cc35 cd c1 8a				call str_at_display 
cc38			 
cc38				; display current data stack pointer 
cc38 11 80 cb			ld de,.data_sp 
cc3b 3e 30				ld a, display_row_2 + 8 
cc3d cd c1 8a				call str_at_display 
cc40			 
cc40 2a ee e9			ld hl,(cli_data_sp) 
cc43 e5				push hl 
cc44 7c				ld a,h 
cc45 21 c6 e5			ld hl, os_word_scratch 
cc48 cd f1 8e			call hexout 
cc4b e1				pop hl 
cc4c 7d				ld a,l 
cc4d 21 c8 e5			ld hl, os_word_scratch+2 
cc50 cd f1 8e			call hexout 
cc53 21 ca e5			ld hl, os_word_scratch+4 
cc56 3e 00			ld a,0 
cc58 77				ld (hl),a 
cc59 11 c6 e5			ld de,os_word_scratch 
cc5c 3e 33				ld a, display_row_2 + 11 
cc5e cd c1 8a				call str_at_display 
cc61			 
cc61			 
cc61 cd d1 8a			call update_display 
cc64 cd f1 89			call delay1s 
cc67 cd f1 89			call delay1s 
cc6a e1				pop hl 
cc6b			.skipdsp: 
cc6b f1				pop af 
cc6c c9				ret 
cc6d			 
cc6d			display_data_malloc: 
cc6d			 
cc6d f5				push af 
cc6e e5				push hl 
cc6f e5				push hl 
cc70 e5			push hl 
cc71 cd ae 8a			call clear_display 
cc74 e1			pop hl 
cc75 7c				ld a,h 
cc76 21 c6 e5			ld hl, os_word_scratch 
cc79 cd f1 8e			call hexout 
cc7c e1				pop hl 
cc7d 7d				ld a,l 
cc7e 21 c8 e5			ld hl, os_word_scratch+2 
cc81 cd f1 8e			call hexout 
cc84 21 ca e5			ld hl, os_word_scratch+4 
cc87 3e 00			ld a,0 
cc89 77				ld (hl),a 
cc8a 11 c6 e5			ld de,os_word_scratch 
cc8d 3e 28				ld a, display_row_2 
cc8f cd c1 8a				call str_at_display 
cc92 11 ba cb			ld de, .push_malloc 
cc95 3e 00			ld a, display_row_1 
cc97			 
cc97 cd c1 8a				call str_at_display 
cc9a			 
cc9a				; display current data stack pointer 
cc9a 11 80 cb			ld de,.data_sp 
cc9d 3e 30				ld a, display_row_2 + 8 
cc9f cd c1 8a				call str_at_display 
cca2			 
cca2 2a ee e9			ld hl,(cli_data_sp) 
cca5 e5				push hl 
cca6 7c				ld a,h 
cca7 21 c6 e5			ld hl, os_word_scratch 
ccaa cd f1 8e			call hexout 
ccad e1				pop hl 
ccae 7d				ld a,l 
ccaf 21 c8 e5			ld hl, os_word_scratch+2 
ccb2 cd f1 8e			call hexout 
ccb5 21 ca e5			ld hl, os_word_scratch+4 
ccb8 3e 00			ld a,0 
ccba 77				ld (hl),a 
ccbb 11 c6 e5			ld de,os_word_scratch 
ccbe 3e 33				ld a, display_row_2 + 11 
ccc0 cd c1 8a				call str_at_display 
ccc3			 
ccc3 cd d1 8a			call update_display 
ccc6 cd f1 89			call delay1s 
ccc9 cd f1 89			call delay1s 
cccc e1				pop hl 
cccd f1				pop af 
ccce c9				ret 
cccf			;endif 
cccf			 
cccf			include "forth_autostart.asm" 
cccf			; list of commands to perform at system start up 
cccf			 
cccf			startcmds: 
cccf			;	dw test11 
cccf			;	dw test12 
cccf			;	dw test13 
cccf			;	dw test14 
cccf			;	dw test15 
cccf			;	dw test16 
cccf			;	dw test17 
cccf			;	dw ifthtest1 
cccf			;	dw ifthtest2 
cccf			;	dw ifthtest3 
cccf			;	dw mmtest1 
cccf			;	dw mmtest2 
cccf			;	dw mmtest3 
cccf			;	dw mmtest4 
cccf			;	dw mmtest5 
cccf			;	dw mmtest6 
cccf			;	dw iftest1 
cccf			;	dw iftest2 
cccf			;	dw iftest3 
cccf			;	dw looptest1 
cccf			;	dw looptest2 
cccf			;	dw test1 
cccf			;	dw test2 
cccf			;	dw test3 
cccf			;	dw test4 
cccf			;	dw game2r 
cccf			;	dw game2b1 
cccf			;	dw game2b2 
cccf			 
cccf				; start up words that are actually useful 
cccf			 
cccf			;    dw spi1 
cccf			;    dw spi2 
cccf			;    dw spi3 
cccf			;    dw spi4 
cccf			;    dw spi5 
cccf			;    dw spi6 
cccf			;    dw spi7 
cccf			; 
cccf			;    dw spi8 
cccf			;    dw spi9 
cccf			;    dw spi10 
cccf			 
cccf			; file editor 
cccf			;	dw edit1 
cccf			;	dw edit2 
cccf			;	dw edit3 
cccf			 
cccf			;	dw longread 
cccf f9 d0			dw clrstack 
ccd1 2d d1			dw type 
ccd3			;	dw stest 
ccd3 52 d1			dw strncpy 
ccd5			;	dw list 
ccd5 b3 d1			dw start1 
ccd7 c3 d1			dw start2 
ccd9			;	dw start3 
ccd9			;	dw start3b 
ccd9			;	dw start3c 
ccd9			 
ccd9				; (unit) testing words 
ccd9			 
ccd9			;	dw mtesta 
ccd9			;	dw mtestb 
ccd9			;	dw mtestc 
ccd9			;	dw mtestd 
ccd9			;	dw mteste 
ccd9			 
ccd9				; demo/game words 
ccd9			 
ccd9			;        dw game3w 
ccd9			;        dw game3p 
ccd9			;        dw game3sc 
ccd9			;        dw game3vsi 
ccd9			;        dw game3vs 
ccd9				 
ccd9 1c dc			dw game2b 
ccdb 8a dc			dw game2bf 
ccdd d4 dc			dw game2mba 
ccdf 6a dd			dw game2mbas 
cce1 ac dd			dw game2mb 
cce3			 
cce3 dd d8			dw game1 
cce5 ee d8			dw game1a 
cce7 50 d9			dw game1b 
cce9 85 d9			dw game1c 
cceb bb d9			dw game1d 
cced ec d9			dw game1s 
ccef 00 da			dw game1t 
ccf1 15 da			dw game1f 
ccf3 49 da			dw game1z 
ccf5 8d da			dw game1zz 
ccf7			 
ccf7 f7 d6			dw test5 
ccf9 2f d7			dw test6 
ccfb 67 d7			dw test7 
ccfd 7b d7			dw test8 
ccff a7 d7			dw test9 
cd01 bd d7			dw test10 
cd03				 
cd03 64 db		        dw ssv5 
cd05 48 db		        dw ssv4 
cd07 2c db		        dw ssv3 
cd09 f6 da		        dw ssv2 
cd0b 7d db		        dw ssv1 
cd0d c5 db		        dw ssv1cpm 
cd0f			;	dw keyup 
cd0f			;	dw keydown 
cd0f			;	dw keyleft 
cd0f			;	dw keyright 
cd0f			;	dw 	keyf1 
cd0f			;	dw keyf2 
cd0f			;	dw keyf3 
cd0f			;	dw keyf4 
cd0f			;	dw keyf5 
cd0f			;	dw keyf6 
cd0f			;	dw keyf7 
cd0f			;	dw keyf8 
cd0f			;	dw keyf9 
cd0f			;	dw keyf10 
cd0f			;	dw keyf11 
cd0f			;	dw keyf12 
cd0f			;	dw keytab 
cd0f			;	dw keycr 
cd0f			;	dw keyhome 
cd0f			;	dw keyend 
cd0f			;	dw keybs 
cd0f 00 00			db 0, 0	 
cd11			 
cd11			 
cd11			; File Editor 
cd11			 
cd11			; ( id - ) use 'e' to edit the displayed line 
cd11 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd32 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd67			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd67 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cd9f			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cd9f			 
cd9f			; SPI Net support words 
cd9f			 
cd9f			; v0! = node to send to 
cd9f			; ( str count - ) 
cd9f .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
cdf8			 
cdf8			; spiputc ( char node - ) 
cdf8 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce2c			; spiputc ( u node - ) 
ce2c .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
ce5a			 
ce5a			; spigetc ( - n ) 
ce5a .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
ce83			 
ce83			; getnode ( - n ) 
ce83 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
ceb0			 
ceb0			; ( str node - )  
ceb0 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf16			; store string ( str i - ) 
cf16			 
cf16			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf16 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf6b			 
cf6b			; get string ( addr i -  )    TO FIX 
cf6b			 
cf6b .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cfc3			 
cfc3			 
cfc3			; NETCHAT (TODO) 
cfc3			; Program to allow two nodes to chat with eachother 
cfc3			; 
cfc3			; v0 - target node 
cfc3			;  
cfc3			; accept input at 0,0 
cfc3			; if input is string send spitype to target node 
cfc3			; starting at row 2,0 , while spigetchr is not zero ->  
cfc3			; 
cfc3			; 
cfc3			; TODO add paging of get request 
cfc3			 
cfc3			; ( node - ) 
cfc3 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cfe2 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d03a .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0b2			 
d0b2			 
d0b2			; Long read of currently open file 
d0b2 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d0f9			 
d0f9			; clear stack  
d0f9			 
d0f9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d12d			 
d12d			; type ( addr count - ) 
d12d .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d152			 
d152			; some direct memory words 
d152			; strncpy ( len t f -- t ) 
d152			 
d152 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1b3			 
d1b3 .. 00		start1:     	db ": bpon $00 bp ;",0 
d1c3 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d1d4 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d24f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2af			 
d2af			 
d2af			; a handy word to list items on the stack 
d2af			 
d2af .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d319			 
d319			 
d319			; test stack  
d319			; rnd8 stest 
d319			 
d319 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d390			 
d390			; random malloc and free cycles 
d390			 
d390 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d445			 
d445			; fixed malloc and free cycles 
d445			 
d445 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d4e8			 
d4e8			; fixed double string push and drop cycle  
d4e8			 
d4e8 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d59d			 
d59d			; consistent fixed string push and drop cycle  
d59d			 
d59d .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d641			 
d641 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d6f7			 
d6f7			;test1:		db ": aa 1 2 3 ;", 0 
d6f7			;test2:     	db "111 aa 888 999",0 
d6f7			;test3:     	db ": bb 77 ;",0 
d6f7			;test4:     	db "$02 $01 do i . loop bb",0 
d6f7			 
d6f7 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d72f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d767 .. 00		test7:     	db ": box hline vline ;",0 
d77b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7a7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d7bd .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d7e2 .. 00		test11:     	db "hello create .",0 
d7f1 .. 00		test12:     	db "hello2 create .",0 
d801			 
d801			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d801			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d801			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d801			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d801			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d801			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d801			 
d801			;iftest1:     	db "$0001 IF cls .",0 
d801			;iftest2:     	db "$0000 IF cls .",0 
d801			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d801			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d801			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d801			 
d801			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d801			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d801			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d801			 
d801			 
d801 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d825 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d855 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d87a .. 00		sound4: db ": cha $00 ; ",0 
d887 .. 00		sound5: db ": chb $20 ; ",0 
d894 .. 00		sound6: db ": chc $40 ; ",0 
d8a1 .. 00		sound7: db ": chd $60 ; ",0 
d8ae .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d8c6 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d8dd			 
d8dd			 
d8dd			 
d8dd			 
d8dd			; a small guess the number game 
d8dd			 
d8dd .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d8ee .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d950			 
d950 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d985 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d9bb .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d9ec .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
da00 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
da15 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
da49 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
da8d			 
da8d			; Using 'ga' save a high score across multiple runs using external storage 
da8d			 
da8d .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
daf6			 
daf6			 
daf6			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
daf6			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
daf6			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
daf6			 
daf6			; simple screen saver to test code memory reuse to destruction 
daf6			 
daf6 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
db2c .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
db48 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
db64 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
db7d .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dbc5 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc1c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc1c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc1c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc1c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc1c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc1c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc1c			 
dc1c			 
dc1c			 
dc1c			; minesweeper/battleship finding game 
dc1c			; draws a game board of random ship/mine positions 
dc1c			; user enters coords to see if it hits on 
dc1c			; game ends when all are hit 
dc1c			; when hit or miss says how many may be in the area 
dc1c			 
dc1c			; setup the game board and then hide it 
dc1c .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dc8a .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dcd4			; prompt for where to target 
dcd4 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dd6a .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dd8f			; TODO see if the entered coords hits or misses pushes char hit of miss 
dd8f .. 00		game2mbht:      db ": mbckht nop ;",0 
dd9e .. 00		game2mbms:      db ": mbcms nop ;",0 
ddac			; TODO how many might be near by 
ddac .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
de29			 
de29			; Game 3 
de29			 
de29			; Vert scroller ski game - avoid the trees! 
de29			 
de29			; v0 score (ie turns) 
de29			; v1 player pos 
de29			; v2 left wall 
de29			; v3 right wall 
de29			 
de29			; Draw side walls randomly 
de29			 
de29 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
de57			 
de57			; Draw player 
de57 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
de75			 
de75			; TODO Get Key 
de75			 
de75			; TODO Move left right 
de75			 
de75			; scroll and move walls a bit 
de75			 
de75 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
dea6			 
dea6			; main game loop 
dea6			 
dea6 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
ded2 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df11			 
df11			; key board defs 
df11			 
df11 .. 00		keyup:       db ": keyup $05 ;",0 
df1f .. 00		keydown:       db ": keydown $0a ;",0 
df2f .. 00		keyleft:       db ": keyleft $0b ;",0 
df3f .. 00		keyright:       db ": keyright $0c ;",0 
df50 .. 00		keyf1:       db ": keyf1 $10 ;",0 
df5e .. 00		keyf2:       db ": keyf2 $11 ;",0 
df6c .. 00		keyf3:       db ": keyf3 $12 ;",0 
df7a .. 00		keyf4:       db ": keyf4 $13 ;",0 
df88 .. 00		keyf5:       db ": keyf5 $14 ;",0 
df96 .. 00		keyf6:       db ": keyf6 $15 ;",0 
dfa4 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dfb2 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dfc0 .. 00		keyf9:       db ": keyf9 $18 ;",0 
dfce .. 00		keyf10:       db ": keyf10 $19 ;",0 
dfdd .. 00		keyf11:       db ": keyf11 $1a ;",0 
dfec .. 00		keyf12:       db ": keyf12 $1b ;",0 
dffb			 
dffb .. 00		keytab:       db ": keytab $09 ;",0 
e00a .. 00		keycr:       db ": keycr $0d ;",0 
e018 .. 00		keyhome:       db ": keyhome $0e ;",0 
e028 .. 00		keyend:       db ": keyend $0f ;",0 
e037 .. 00		keybs:       db ": keybs $08 ;",0 
e045			 
e045			   
e045			 
e045			 
e045			 
e045			; eof 
# End of file forth_autostart.asm
e045			 
e045			 
e045			 
e045			; stack over and underflow checks 
e045			 
e045			; init the words to detect the under/overflow 
e045			 
e045			chk_stk_init: 
e045				; a vague random number to check so we dont get any "lucky" hits 
e045 3e 2d			ld a, 45 
e047 6f				ld l, a 
e048 00				nop 
e049 3e 17			ld a, 23 
e04b 67				ld h, a 
e04c			 
e04c 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e04f			 
e04f			;	ld (chk_stund), hl	; stack points.... 
e04f 22 00 ef			ld (chk_stovr), hl 
e052 22 ec e9			ld (chk_ret_und), hl 
e055 22 aa e9			ld (chk_ret_ovr), hl 
e058 22 28 e9			ld (chk_loop_ovr), hl 
e05b 22 26 e8			ld (chk_data_ovr), hl 
e05e c9				ret 
e05f				 
e05f			check_stacks: 
e05f				; check all stack words 
e05f			 
e05f e5				push hl 
e060 d5				push de 
e061			 
e061			;	ld de,(chk_word) 
e061			;	ld hl, (chk_stund)	; stack points.... 
e061			;	if DEBUG_STK_FAULT 
e061			;		DMARK "FAa" 
e061			;		CALLMONITOR 
e061			;	endif 
e061			;	call cmp16 
e061			;	jp z, .chk_faulta 
e061			; 
e061			;	ld de, sfaultsu 
e061			;	jp .chk_fault 
e061			 
e061 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e064 ed 5b 9d e2		ld de,(chk_word) 
e068				if DEBUG_STK_FAULT 
e068					DMARK "FAb" 
e068					CALLMONITOR 
e068				endif 
e068 cd f9 8c			call cmp16 
e06b 28 06			jr z, .chk_fault1 
e06d 11 0e e1			ld de, sfaultso 
e070 c3 c2 e0			jp .chk_fault 
e073			.chk_fault1:  
e073 2a ec e9			ld hl, (chk_ret_und) 
e076 ed 5b 9d e2		ld de,(chk_word) 
e07a				if DEBUG_STK_FAULT 
e07a					DMARK "FAU" 
e07a					CALLMONITOR 
e07a				endif 
e07a cd f9 8c			call cmp16 
e07d ca 86 e0			jp z, .chk_fault2 
e080 11 1e e1			ld de, sfaultru 
e083 c3 c2 e0			jp .chk_fault 
e086			.chk_fault2:  
e086 2a aa e9			ld hl, (chk_ret_ovr) 
e089 ed 5b 9d e2		ld de,(chk_word) 
e08d				if DEBUG_STK_FAULT 
e08d					DMARK "FA1" 
e08d					CALLMONITOR 
e08d				endif 
e08d cd f9 8c			call cmp16 
e090 ca 99 e0			jp z, .chk_fault3 
e093 11 2c e1			ld de, sfaultro 
e096 c3 c2 e0			jp .chk_fault 
e099			.chk_fault3:  
e099 2a 28 e9			ld hl, (chk_loop_ovr) 
e09c ed 5b 9d e2		ld de,(chk_word) 
e0a0				if DEBUG_STK_FAULT 
e0a0					DMARK "FA2" 
e0a0					CALLMONITOR 
e0a0				endif 
e0a0 cd f9 8c			call cmp16 
e0a3 ca ac e0			jp z, .chk_fault4 
e0a6 11 46 e1			ld de, sfaultlo 
e0a9 c3 c2 e0			jp .chk_fault 
e0ac			.chk_fault4:  
e0ac 2a 26 e8			ld hl, (chk_data_ovr) 
e0af ed 5b 9d e2		ld de,(chk_word) 
e0b3				if DEBUG_STK_FAULT 
e0b3					DMARK "FA3" 
e0b3					CALLMONITOR 
e0b3				endif 
e0b3 cd f9 8c			call cmp16 
e0b6 ca bf e0			jp z, .chk_fault5 
e0b9 11 60 e1			ld de, sfaultdo 
e0bc c3 c2 e0			jp .chk_fault 
e0bf			 
e0bf			 
e0bf			.chk_fault5:  
e0bf d1				pop de 
e0c0 e1				pop hl 
e0c1			 
e0c1 c9				ret 
e0c2			 
e0c2 cd ae 8a		.chk_fault: 	call clear_display 
e0c5 3e 28				ld a, display_row_2 
e0c7 cd c1 8a				call str_at_display 
e0ca 11 f0 e0				   ld de, .stackfault 
e0cd 3e 00				ld a, display_row_1 
e0cf cd c1 8a				call str_at_display 
e0d2 11 6b ee				    ld de, debug_mark 
e0d5 3e 11				ld a, display_row_1+17 
e0d7 cd c1 8a				call str_at_display 
e0da cd d1 8a				call update_display 
e0dd			 
e0dd				; prompt before entering montior for investigating issue 
e0dd			 
e0dd 3e 78			ld a, display_row_4 
e0df 11 4e 97			ld de, endprog 
e0e2			 
e0e2 cd d1 8a			call update_display		 
e0e5			 
e0e5 cd d4 99			call next_page_prompt 
e0e8			 
e0e8 d1				pop de 
e0e9 e1				pop hl 
e0ea cd a2 97				call monitor 
e0ed c3 ab 96				jp warmstart 
e0f0					;jp 0 
e0f0					;halt 
e0f0			 
e0f0			 
e0f0			 
e0f0 .. 00		.stackfault: 	db "Stack fault:",0 
e0fd			 
e0fd .. 00		sfaultsu: 	db	"Stack under flow",0 
e10e .. 00		sfaultso: 	db	"Stack over flow",0 
e11e .. 00		sfaultru:	db "RTS underflow",0 
e12c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e146 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e160 .. 00		sfaultdo:	db "DTS overflow", 0 
e16d			 
e16d			 
e16d			fault_dsp_under: 
e16d 11 7f e1			ld de, .dsp_under 
e170 c3 2f e2			jp .show_fault 
e173			 
e173			fault_rsp_under: 
e173 11 8d e1			ld de, .rsp_under 
e176 c3 2f e2			jp .show_fault 
e179			fault_loop_under: 
e179 11 9b e1			ld de, .loop_under 
e17c c3 2f e2			jp .show_fault 
e17f			 
e17f .. 00		.dsp_under: db "DSP Underflow",0 
e18d .. 00		.rsp_under: db "RSP Underflow",0 
e19b .. 00		.loop_under: db "LOOP Underflow",0 
e1aa			 
e1aa			 
e1aa d5			type_faultn: 	push de 
e1ab e5					push hl 
e1ac cd ae 8a				call clear_display 
e1af 11 d6 e1				   ld de, .typefaultn 
e1b2 3e 00				ld a, display_row_1 
e1b4 cd c1 8a				call str_at_display 
e1b7 11 6b ee				    ld de, debug_mark 
e1ba 3e 11				ld a, display_row_1+17 
e1bc cd c1 8a				call str_at_display 
e1bf cd d1 8a				call update_display 
e1c2			 
e1c2				; prompt before entering montior for investigating issue 
e1c2			 
e1c2 3e 78			ld a, display_row_4 
e1c4 11 4e 97			ld de, endprog 
e1c7			 
e1c7 cd d1 8a			call update_display		 
e1ca			 
e1ca cd d4 99			call next_page_prompt 
e1cd			 
e1cd e5					push hl 
e1ce d5					push de 
e1cf cd a2 97				call monitor 
e1d2 c3 ab 96				jp warmstart 
e1d5 76					halt 
e1d6			 
e1d6			 
e1d6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e1ed			 
e1ed d5			type_faults: 	push de 
e1ee e5					push hl 
e1ef cd ae 8a				call clear_display 
e1f2 11 18 e2				   ld de, .typefaults 
e1f5 3e 00				ld a, display_row_1 
e1f7 cd c1 8a				call str_at_display 
e1fa 11 6b ee				    ld de, debug_mark 
e1fd 3e 11				ld a, display_row_1+17 
e1ff cd c1 8a				call str_at_display 
e202 cd d1 8a				call update_display 
e205			 
e205				; prompt before entering montior for investigating issue 
e205			 
e205 3e 78			ld a, display_row_4 
e207 11 4e 97			ld de, endprog 
e20a			 
e20a cd d1 8a			call update_display		 
e20d			 
e20d cd d4 99			call next_page_prompt 
e210			 
e210 e1					pop hl 
e211 d1					pop de 
e212 cd a2 97				call monitor 
e215 c3 ab 96				jp warmstart 
e218			 
e218			 
e218 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e22f			 
e22f			.show_fault: 	 
e22f d5					push de 
e230 cd ae 8a				call clear_display 
e233 d1					pop de 
e234 3e 00				ld a, display_row_1 
e236 cd c1 8a				call str_at_display 
e239 11 6b ee				    ld de, debug_mark 
e23c 3e 11				ld a, display_row_1+17 
e23e cd c1 8a				call str_at_display 
e241 cd d1 8a				call update_display 
e244			 
e244				; prompt before entering montior for investigating issue 
e244			 
e244 3e 78			ld a, display_row_4 
e246 11 4e 97			ld de, endprog 
e249			 
e249 cd d1 8a			call update_display		 
e24c			 
e24c cd d4 99			call next_page_prompt 
e24f			 
e24f e1					pop hl 
e250 d1					pop de 
e251 cd a2 97				call monitor 
e254			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e254			; TODO Make optional fault restart to cli or warm boot? 
e254					;jp warmstart 
e254 c3 f5 96				jp cli 
e257 76					halt 
e258			 
e258			; handle the auto run of code from files in storage 
e258			 
e258			 
e258			include "forth_startup.asm" 
e258			; Which startup method to use? 
e258			; 
e258			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e258			; followed by loading of a list of scripts in eeprom 
e258			 
e258			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e258			; from eeprom 
e258			 
e258			; Select with define in main stubs 
e258			 
e258			if STARTUP_V1 
e258				include "forth_startupv1.asm" 
e258			; Startup script loading version 1 
e258			 
e258			; If SE storage is available first stage is to use the selected file 
e258			; then go through the eeprom list 
e258			 
e258 .. 00		sprompt1: db "Startup load...",0 
e268 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e27e			 
e27e			 
e27e			 
e27e			 
e27e			forth_startup: 
e27e 21 cf cc			ld hl, startcmds 
e281 3e 00			ld a, 0 
e283 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e286			 
e286 e5			.start1:	push hl 
e287 cd ae 8a			call clear_display 
e28a 11 58 e2			ld de, sprompt1 
e28d 3e 00		        ld a, display_row_1 
e28f cd c1 8a			call str_at_display 
e292 11 68 e2			ld de, sprompt2 
e295 3e 28		        ld a, display_row_2 
e297 cd c1 8a			call str_at_display 
e29a e1				pop hl 
e29b e5				push hl 
e29c 5e				ld e,(hl) 
e29d 23				inc hl 
e29e 56				ld d,(hl) 
e29f 3e 50		        ld a, display_row_3 
e2a1 cd c1 8a			call str_at_display 
e2a4 cd d1 8a			call update_display 
e2a7			 
e2a7			 
e2a7 3a e7 e6			ld a, (os_last_cmd) 
e2aa fe 00			cp 0 
e2ac 28 05			jr z, .startprompt 
e2ae cd e5 89			call delay250ms 
e2b1 18 24			jr .startdo 
e2b3				 
e2b3				 
e2b3			 
e2b3			.startprompt: 
e2b3			 
e2b3 3e 9f			ld a,display_row_4 + display_cols - 1 
e2b5 11 d2 99		        ld de, endprg 
e2b8 cd c1 8a			call str_at_display 
e2bb cd d1 8a			call update_display 
e2be cd f1 89			call delay1s 
e2c1 cd e4 e3			call cin_wait 
e2c4						 
e2c4 fe 2a			cp '*' 
e2c6 28 5e			jr z, .startupend1 
e2c8 fe 23			cp '#' 
e2ca 20 07			jr nz, .startno 
e2cc 3e 01			ld a, 1 
e2ce 32 e7 e6			ld (os_last_cmd),a 
e2d1 18 04			jr .startdo 
e2d3 fe 31		.startno:	cp '1' 
e2d5 28 3a			jr z,.startnxt  
e2d7			 
e2d7				; exec startup line 
e2d7			.startdo:	 
e2d7 e1				pop hl 
e2d8 e5				push hl 
e2d9				 
e2d9 5e				ld e,(hl) 
e2da 23				inc hl 
e2db 56				ld d,(hl) 
e2dc eb				ex de,hl 
e2dd			 
e2dd e5				push hl 
e2de			 
e2de 3e 00			ld a, 0 
e2e0				;ld a, FORTH_END_BUFFER 
e2e0 cd 59 90			call strlent 
e2e3 23				inc hl   ; include zero term to copy 
e2e4 06 00			ld b,0 
e2e6 4d				ld c,l 
e2e7 e1				pop hl 
e2e8 11 c1 e2			ld de, scratch 
e2eb ed b0			ldir 
e2ed			 
e2ed			 
e2ed 21 c1 e2			ld hl, scratch 
e2f0 cd 57 9e			call forthparse 
e2f3 cd 97 9e			call forthexec 
e2f6 cd a9 9d			call forthexec_cleanup 
e2f9			 
e2f9 3e 78			ld a, display_row_4 
e2fb 11 4e 97			ld de, endprog 
e2fe			 
e2fe cd d1 8a			call update_display		 
e301			 
e301 3a e7 e6			ld a, (os_last_cmd) 
e304 fe 00			cp 0 
e306 20 09			jr nz, .startnxt 
e308 cd d4 99			call next_page_prompt 
e30b cd ae 8a		        call clear_display 
e30e cd d1 8a			call update_display		 
e311			 
e311				; move onto next startup line? 
e311			.startnxt: 
e311			 
e311 cd e5 89			call delay250ms 
e314 e1				pop hl 
e315			 
e315 23				inc hl 
e316 23				inc hl 
e317			 
e317 e5				push hl 
e318 5e				ld e, (hl) 
e319 23				inc hl 
e31a 56				ld d, (hl) 
e31b e1				pop hl 
e31c				; TODO replace 0 test 
e31c			 
e31c eb				ex de, hl 
e31d cd 04 8d			call ishlzero 
e320			;	ld a,e 
e320			;	add d 
e320			;	cp 0    ; any left to do? 
e320 eb				ex de, hl 
e321 c2 86 e2			jp nz, .start1 
e324 18 01			jr .startupend 
e326			 
e326 e1			.startupend1: pop hl 
e327			.startupend: 
e327			 
e327 cd ae 8a			call clear_display 
e32a cd d1 8a			call update_display 
e32d c9				ret 
e32e			if STORAGE_SE 
e32e			 
e32e			sprompt3: db "Loading from start-up file?:",0 
e32e			sprompt4: db "(Y=Any key/N=No)",0 
e32e			 
e32e			 
e32e			forth_autoload: 
e32e			 
e32e				; load block 0 of store 1 
e32e				 
e32e				ld a, $fe      ; bit 0 clear 
e32e				ld (spi_device), a 
e32e			 
e32e				call storage_get_block_0 
e32e			 
e32e				ld a, (store_page+STORE_0_AUTOFILE) 
e32e			 
e32e				cp 0 
e32e				ret z     ; auto start not enabled 
e32e			 
e32e				call clear_display 
e32e			 
e32e				; set bank 
e32e			 
e32e					ld a, (store_page+STORE_0_BANKRUN) 
e32e					ld (spi_device), a 
e32e			 
e32e				; get file id to load from and get the file name to display 
e32e			 
e32e					ld a, (store_page+STORE_0_FILERUN) 
e32e			 
e32e					ld l, 0 
e32e					ld h, a 
e32e					ld de, store_page 
e32e			 
e32e					if DEBUG_FORTH_WORDS 
e32e						DMARK "ASp" 
e32e						CALLMONITOR 
e32e					endif 
e32e					call storage_read 
e32e			 
e32e					if DEBUG_FORTH_WORDS 
e32e						DMARK "ASr" 
e32e						CALLMONITOR 
e32e					endif 
e32e			 
e32e					call ishlzero 
e32e					ret z             ; file not found 
e32e			 
e32e					ld a, display_row_2 + 10 
e32e					ld de, store_page+3 
e32e					call str_at_display 
e32e				 
e32e			; 
e32e			 
e32e				ld a, display_row_1+5 
e32e				ld de, sprompt3 
e32e				call str_at_display 
e32e				ld a, display_row_3+15 
e32e				ld de, sprompt4 
e32e				call str_at_display 
e32e			 
e32e				call update_display 
e32e			 
e32e				call cin_wait 
e32e				cp 'n' 
e32e				ret z 
e32e				cp 'N' 
e32e				ret z 
e32e			 
e32e				call delay1s 
e32e			 
e32e				ld a, (store_page+2) 
e32e				ld (store_openmaxext), a    ; save count of ext 
e32e				ld a, 1  
e32e				ld (store_openext), a    ; save count of ext 
e32e			 
e32e			.autof:  
e32e				ld l , a 
e32e				 
e32e				ld a, (store_page) 
e32e				ld h, a	 
e32e				ld de, store_page 
e32e					if DEBUG_FORTH_WORDS 
e32e						DMARK "ASl" 
e32e						CALLMONITOR 
e32e					endif 
e32e					call storage_read 
e32e				call ishlzero 
e32e				ret z 
e32e			;	jr z, .autoend 
e32e			 
e32e					if DEBUG_FORTH_WORDS 
e32e						DMARK "ASc" 
e32e						CALLMONITOR 
e32e					endif 
e32e				ld de, store_page+2 
e32e				ld a, display_row_4 
e32e				call str_at_display 
e32e			 
e32e				call update_display 
e32e				call delay250ms 
e32e			 
e32e			 
e32e			 
e32e				ld hl, store_page+2 
e32e				call forthparse 
e32e				call forthexec 
e32e				call forthexec_cleanup 
e32e			 
e32e				 
e32e				ld a, (store_openext) 
e32e				inc a 
e32e				ld (store_openext), a    ; save count of ext 
e32e			 
e32e				jr .autof 
e32e			;.autofdone: 
e32e			; 
e32e			;		if DEBUG_FORTH_WORDS 
e32e			;			DMARK "ASx" 
e32e			;			CALLMONITOR 
e32e			;		endif 
e32e			;;	call clear_display 
e32e			;	ret 
e32e			 
e32e			 
e32e			 
e32e			endif 
# End of file forth_startupv1.asm
e32e			endif 
e32e			if STARTUP_V2 
e32e				include "forth_startupv2.asm" 
e32e			endif 
e32e			 
# End of file forth_startup.asm
e32e			 
e32e			; eof 
# End of file forth_kernel.asm
e32e			;include "nascombasic.asm" 
e32e			 
e32e			 
e32e			; find out where the code ends if loaded into RAM (for SC114) 
e32e			;endofcode:  
e32e			;	nop 
e32e			 
e32e			 
e32e			; jump to nmi vector 
e32e			 
e32e			init_nmi: 
e32e 3e c9			ld a, $c9   ; RET 
e330 32 72 ee			ld (nmi_vector), a 
e333 c9				ret 
e334			nmi: 
e334 e5				push hl 
e335 d5				push de 
e336 c5				push bc 
e337 f5				push af 
e338 cd 72 ee			call nmi_vector 
e33b f5				push af 
e33c c5				push bc 
e33d d5				push de 
e33e e5				push hl 
e33f ed 4d			reti 
e341			 
e341			 
e341			; eof 
e341			 
# End of file main.asm
e341			;include "firmware_lcd_4x40.asm" 
e341			;;include "firmware_lcd_4x20.asm" 
e341			include "firmware_serial_display.asm" 
e341			 
e341			; Serial display interface for SC114 
e341			 
e341			 
e341			display_row_1: equ 0 
e341			display_row_2: equ display_row_1+display_cols 
e341			display_row_3: equ display_row_2 + display_cols 
e341			display_row_4: equ display_row_3 + display_cols 
e341			 
e341			kLCDWidth:  EQU display_cols             ;Width in characters 
e341			kLCD_Line1: EQU 0x00  
e341			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e341			; E1 
e341			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e341			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e341			 
e341			lcd_init: 
e341				; no init as handled by the SCM bios 
e341 c9				ret 
e342			 
e342			 
e342			; low level functions for direct screen writes 
e342			 
e342			; output char at pos? 
e342			fLCD_Str: 
e342			        ;out (SC114_SIO_1_OUT),a 
e342 c5				push bc 
e343 0e 02			ld c, $02 
e345 f7				rst $30 
e346 c1				pop bc 
e347 c9				ret 
e348			 
e348			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e348			fLCD_Pos: 
e348				; use ASCII escape to position 
e348			        ;out (SC114_SIO_1_OUT),a 
e348 c5				push bc 
e349 0e 02			ld c, $02 
e34b f7				rst $30 
e34c c1				pop bc 
e34d			 
e34d c9				ret 
e34e			 
e34e			; output char at pos 
e34e			fLCD_Data: 
e34e			      ;  out (SC114_SIO_1_OUT),a 
e34e c5				push bc 
e34f 0e 02			ld c, $02 
e351 f7				rst $30 
e352 c1				pop bc 
e353			 
e353 c9				ret 
e354			 
e354			; ascii cls  
e354			 
e354 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e358			 
e358			; write the frame buffer given in hl to hardware  
e358			write_display: 
e358			 
e358			API: equ 0 
e358			 
e358			if API 
e358				push bc 
e358				ld b, 4 
e358			 
e358			        ld (display_write_tmp), hl 	  
e358			 
e358				; clear and home cursor 
e358			 
e358				ld c, 6 
e358				ld de, .cls 
e358				rst $30 
e358			 
e358			 
e358			.writeln: 
e358			 
e358				ld de, (display_write_tmp) 
e358				ld c, 6 
e358				rst $30 
e358				ld c, 7 
e358				rst $30 
e358			 
e358				ld hl, (display_write_tmp) 
e358				ld de, display_cols 
e358				add hl,de 
e358				ld (display_write_tmp),hl 
e358			 
e358				djnz  .writeln 
e358			 
e358				pop bc 
e358			 
e358			 
e358				ret 
e358			endif 
e358 e5				push hl 
e359 c5				push bc 
e35a d5				push de 
e35b			 
e35b			;	ld c, 2 
e35b			;	;ld de, .cls 
e35b			;	ld a, 27 
e35b			;	rst $30 
e35b			;	ld c, 2 
e35b			;	;ld de, .cls 
e35b			;	ld a, '[' 
e35b			;	rst $30 
e35b			; 
e35b			;	ld c, 2 
e35b			;	;ld de, .cls 
e35b			;	ld a, 'H' 
e35b			;	rst $30 
e35b			; 
e35b			 
e35b 0e 02			ld c, 2 
e35d				;ld de, .cls 
e35d 3e 1b			ld a, 27 
e35f f7				rst $30 
e360			 
e360			 
e360 0e 02			ld c, 2 
e362				;ld de, .cls 
e362 3e 5b			ld a, '[' 
e364 f7				rst $30 
e365 0e 02			ld c, 2 
e367				;ld de, .cls 
e367 3e 32			ld a, '2' 
e369 f7				rst $30 
e36a 0e 02			ld c, 2 
e36c				;ld de, .cls 
e36c 3e 4a			ld a, 'J' 
e36e f7				rst $30 
e36f d1				pop de 
e370 c1				pop bc 
e371 e1				pop hl 
e372			 
e372			 
e372 22 c9 eb		        ld (display_write_tmp), hl 	  
e375 3e 00			ld a, kLCD_Line1 
e377			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e377 06 28			ld b, display_cols 
e379 ed 5b c9 eb		ld de, (display_write_tmp) 
e37d cd db e3			call write_len_string 
e380				 
e380			 
e380 e5			push hl 
e381 d5			push de 
e382 c5			push bc 
e383 0e 07			ld c, 7 
e385 f7				rst $30 
e386 c1			pop bc 
e387 d1			pop de 
e388 e1			pop hl 
e389			 
e389				 
e389 2a c9 eb			ld hl, (display_write_tmp) 
e38c 11 28 00			ld de, display_cols 
e38f 19				add hl,de 
e390 22 c9 eb			ld (display_write_tmp),hl 
e393			 
e393				 
e393 3e 28			ld a, kLCD_Line2 
e395			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e395 06 28			ld b, display_cols 
e397 ed 5b c9 eb		ld de, (display_write_tmp) 
e39b cd db e3			call write_len_string 
e39e				 
e39e 2a c9 eb			ld hl, (display_write_tmp) 
e3a1 11 28 00			ld de, display_cols 
e3a4 19				add hl,de 
e3a5 22 c9 eb			ld (display_write_tmp),hl 
e3a8			 
e3a8 e5			push hl 
e3a9 d5			push de 
e3aa c5			push bc 
e3ab 0e 07			ld c, 7 
e3ad f7				rst $30 
e3ae c1			pop bc 
e3af d1			pop de 
e3b0 e1			pop hl 
e3b1			 
e3b1				 
e3b1 3e 50			ld a, kLCD_Line3 
e3b3			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e3b3 06 28			ld b, display_cols 
e3b5 ed 5b c9 eb		ld de, (display_write_tmp) 
e3b9 cd db e3			call write_len_string 
e3bc				 
e3bc 2a c9 eb			ld hl, (display_write_tmp) 
e3bf 11 28 00			ld de, display_cols 
e3c2 19				add hl,de 
e3c3 22 c9 eb			ld (display_write_tmp),hl 
e3c6			 
e3c6 e5			push hl 
e3c7 d5			push de 
e3c8 c5			push bc 
e3c9 0e 07			ld c, 7 
e3cb f7				rst $30 
e3cc c1			pop bc 
e3cd d1			pop de 
e3ce e1			pop hl 
e3cf			 
e3cf				 
e3cf 3e 78			ld a, kLCD_Line4 
e3d1			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e3d1 06 28			ld b, display_cols 
e3d3 ed 5b c9 eb		ld de, (display_write_tmp) 
e3d7 cd db e3			call write_len_string 
e3da c9					ret 
e3db			 
e3db			 
e3db				; write out a fixed length string given in b from de 
e3db			 
e3db 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e3dc cd 4e e3		            CALL fLCD_Data      ;Write character to display 
e3df 13				inc de 
e3e0 10 f9			djnz write_len_string 
e3e2 c9				ret 
e3e3			 
e3e3			 
e3e3			; eof 
# End of file firmware_serial_display.asm
e3e3			;include "firmware_key_5x10.asm" 
e3e3			;;include "firmware_key_4x10.asm" 
e3e3			include "firmware_key_serial.asm" 
e3e3			; Serial keyboard interface for SC114 
e3e3			 
e3e3			key_init: 
e3e3				; no init as handled by the SCM bios 
e3e3 c9				ret 
e3e4			 
e3e4			 
e3e4			cin_wait: 
e3e4			;	ld a, 0 
e3e4			;	ret 
e3e4			 
e3e4				;in a,(SC114_SIO_1_IN) 
e3e4			        ; Use SCM API to get from whatever console device we are using 
e3e4 c5				push bc 
e3e5 0e 01			ld c, $01 
e3e7 f7				rst $30 
e3e8 c1				pop bc 
e3e9 c9				ret 
e3ea			 
e3ea			cin: 
e3ea			 
e3ea			 
e3ea c5				push bc 
e3eb			 
e3eb				; any key waiting to process? 
e3eb 0e 03			ld c, $03 
e3ed f7				rst $30 
e3ee 28 05			jr z, .cin_skip 
e3f0			 
e3f0				; yep, get it 
e3f0			 
e3f0 0e 01			ld c, $01 
e3f2 f7				rst $30 
e3f3 c1				pop bc 
e3f4 c9				ret 
e3f5			.cin_skip: 
e3f5 3e 00			ld a, 0 
e3f7 c1				pop bc 
e3f8 c9				ret 
e3f9			 
e3f9			 
e3f9			 
e3f9			 
# End of file firmware_key_serial.asm
e3f9			endofcode:  
e3f9			baseram:  
e3f9 00				nop 
e3fa			 
e3fa			heap_start: equ baseram+15  ; Starting address of heap 
e3fa			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e3fa			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e3fa			;VDU:  EQU     endofcode           ; BASIC Work space 
e3fa			; eof 
e3fa			 
# End of file os_mega_sc114.asm
e3fa
