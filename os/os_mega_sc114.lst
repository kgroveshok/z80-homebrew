# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 46 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd 75 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd 75 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd 75 8a				call clear_display  
8037			  
8037			  
8037 cd 12 e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd b4 e2			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 45 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 98 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 7a 8a			call fill_display  
804e cd 98 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 7a 8a			call fill_display  
8059 cd 98 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 7a 8a			call fill_display  
8064 cd 98 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 79 96			ld de, prom_bootmsg  
806f cd 88 8a			call str_at_display  
8072 cd 98 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 8e 96			ld de, prom_bootmsg1  
8080 cd 88 8a			call str_at_display  
8083 cd 98 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 7d ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd a3 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 84 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd a3 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 84 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd a3 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd cb 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 7d ea				ld hl, (store_tmp1) 
8110 11 87 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd a3 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 38 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd a3 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd a3 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd a3 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd a3 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd cb 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 84 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd a3 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd a3 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 84 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 84 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd a3 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 85 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd a3 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd a3 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 84 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 85 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 87 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 90 ea			ld hl, store_page+3+9 
82b5 3a 69 ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 84 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd a3 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd a3 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd a2 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd a2 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd a3 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 87 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd a3 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 84 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd a3 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd a3 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd cb 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 84 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd cb 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd a3 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 84 ea			ld a, (store_page)	; get file id 
8410 32 78 ea			ld (store_tmpid), a 
8413			 
8413 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 77 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 84 ea			ld (store_page), a 
841f 32 85 ea			ld (store_page+1),a 
8422 11 84 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd a3 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 77 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 78 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd a3 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd cb 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 84 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 84 ea			ld (store_page), a 
8482 32 85 ea			ld (store_page+1),a 
8485 11 84 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd a3 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd a3 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd c0 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd a2 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd c0 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd a2 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd a3 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd a3 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd a2 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd a2 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd a3 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 84 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 84 ea			ld (store_page),a 
85a3				 
85a3 32 78 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 84 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd a3 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 84 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd a3 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 6f ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd a3 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 6f ea			ld (store_tmppageid), hl 
8615				 
8615 3a 78 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 84 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 85 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 86 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd a3 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 0b 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd a3 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd a3 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 6f ea			ld hl,(store_tmppageid) 
868b 11 84 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd a3 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 78 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd a3 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd a3 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd a3 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd cb 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 75 ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 71 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 72 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 73 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd a3 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd a2 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 77 ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 71 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 72 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 73 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd a3 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 7f ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd a2 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 71 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 72 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 73 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd a3 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 71 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 72 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 73 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd a3 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 71 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 72 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 73 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd a3 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd cb 8c			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 75 ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 71 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 72 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 73 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd a3 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 71 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 72 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 73 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd a3 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 71 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 72 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 73 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd a3 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 71 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 72 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 73 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd a3 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 78 ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 78 ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd cb 8c			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 6f ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 71 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 72 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 73 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd a3 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 84 ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 71 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 72 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 73 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd a3 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 86 ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 86 ea			ld (store_page+2), a 
88e3 32 77 ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 71 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 72 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 73 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd a3 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 6f ea			ld hl, (store_tmppageid) 
8905 11 84 ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd cb 8c			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 6f ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 71 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 72 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 73 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd a3 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 84 ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 78 ea				ld a, (store_tmpid) 
894b 32 84 ea				ld (store_page), a   ; file id 
894e 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 85 ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 86 ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 71 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 72 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 73 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd a3 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 6f ea			ld hl, (store_tmppageid) 
8985 11 84 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 71 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 72 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 73 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd a3 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 78 ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 84 ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 85 ea			ld de, store_page+1 
89c1 01 18 01			ld bc, STORE_BLOCK_LOG 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; information window 
8a06			 
8a06			; pass hl with 1st string to display 
8a06			; pass de with 2nd string to display 
8a06			 
8a06			info_panel: 
8a06 e5				push hl 
8a07			 
8a07 2a d2 eb			ld hl, (display_fb_active) 
8a0a e5				push hl    ; future de destination 
8a0b 21 b7 ed				ld hl, display_fb0 
8a0e 22 d2 eb				ld (display_fb_active), hl 
8a11			 
8a11			;	call clear_display 
8a11			 
8a11				if BASE_CPM 
8a11				ld a, '.' 
8a11				else 
8a11 3e a5			ld a, 165 
8a13				endif 
8a13 cd 7a 8a			call fill_display 
8a16			 
8a16			 
8a16 3e 55			ld a, display_row_3 + 5 
8a18 cd 88 8a			call str_at_display 
8a1b			 
8a1b e1				pop hl 
8a1c d1				pop de 
8a1d			 
8a1d e5				push hl 
8a1e			 
8a1e			 
8a1e 3e 2d			ld a, display_row_2 + 5 
8a20 cd 88 8a			call str_at_display 
8a23			 
8a23			 
8a23 cd 98 8a			call update_display 
8a26 cd 8c 9a			call next_page_prompt 
8a29 cd 75 8a			call clear_display 
8a2c			 
8a2c				 
8a2c 21 16 ed				ld hl, display_fb1 
8a2f 22 d2 eb				ld (display_fb_active), hl 
8a32 cd 98 8a			call update_display 
8a35			 
8a35 e1				pop hl 
8a36			 
8a36 c9				ret 
8a37			 
8a37			 
8a37			 
8a37			 
8a37			; TODO windowing? 
8a37			 
8a37			; TODO scroll line up 
8a37			 
8a37			scroll_up: 
8a37			 
8a37 e5				push hl 
8a38 d5				push de 
8a39 c5				push bc 
8a3a			 
8a3a				; get frame buffer  
8a3a			 
8a3a 2a d2 eb			ld hl, (display_fb_active) 
8a3d e5				push hl    ; future de destination 
8a3e			 
8a3e 11 28 00			ld  de, display_cols 
8a41 19				add hl, de 
8a42			 
8a42 d1				pop de 
8a43			 
8a43				;ex de, hl 
8a43 01 9f 00			ld bc, display_fb_len -1  
8a46			;if DEBUG_FORTH_WORDS 
8a46			;	DMARK "SCL" 
8a46			;	CALLMONITOR 
8a46			;endif	 
8a46 ed b0			ldir 
8a48			 
8a48				; wipe bottom row 
8a48			 
8a48			 
8a48 2a d2 eb			ld hl, (display_fb_active) 
8a4b 11 a0 00			ld de, display_cols*display_rows 
8a4e 19				add hl, de 
8a4f 06 28			ld b, display_cols 
8a51 3e 20			ld a, ' ' 
8a53			.scwipe: 
8a53 77				ld (hl), a 
8a54 2b				dec hl 
8a55 10 fc			djnz .scwipe 
8a57			 
8a57				;pop hl 
8a57			 
8a57 c1				pop bc 
8a58 d1				pop de 
8a59 e1				pop hl 
8a5a			 
8a5a c9				ret 
8a5b			 
8a5b			 
8a5b			;scroll_upo: 
8a5b			;	ld de, display_row_1 
8a5b			 ;	ld hl, display_row_2 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_2 
8a5b			 ;	ld hl, display_row_3 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			;	ld de, display_row_3 
8a5b			 ;	ld hl, display_row_4 
8a5b			;	ld bc, display_cols 
8a5b			;	ldir 
8a5b			 
8a5b			; TODO clear row 4 
8a5b			 
8a5b			;	ret 
8a5b			 
8a5b				 
8a5b			scroll_down: 
8a5b			 
8a5b e5				push hl 
8a5c d5				push de 
8a5d c5				push bc 
8a5e			 
8a5e				; get frame buffer  
8a5e			 
8a5e 2a d2 eb			ld hl, (display_fb_active) 
8a61			 
8a61 11 9f 00			ld de, display_fb_len - 1 
8a64 19				add hl, de 
8a65			 
8a65 e5			push hl    ; future de destination 
8a66			 
8a66 11 28 00			ld  de, display_cols 
8a69 ed 52			sbc hl, de 
8a6b			 
8a6b			 
8a6b d1				pop de 
8a6c			 
8a6c			;	ex de, hl 
8a6c 01 9f 00			ld bc, display_fb_len -1  
8a6f			 
8a6f			 
8a6f				 
8a6f			 
8a6f ed b0			ldir 
8a71			 
8a71				; wipe bottom row 
8a71			 
8a71			 
8a71			;	ld hl, (display_fb_active) 
8a71			;;	ld de, display_cols*display_rows 
8a71			;;	add hl, de 
8a71			;	ld b, display_cols 
8a71			;	ld a, ' ' 
8a71			;.scwiped: 
8a71			;	ld (hl), a 
8a71			;	dec hl 
8a71			;	djnz .scwiped 
8a71			 
8a71				;pop hl 
8a71			 
8a71 c1				pop bc 
8a72 d1				pop de 
8a73 e1				pop hl 
8a74			 
8a74 c9				ret 
8a75			;scroll_down: 
8a75			;	ld de, display_row_4 
8a75			;	ld hl, display_row_3 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_3 
8a75			; 	ld hl, display_row_2 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;	ld de, display_row_2 
8a75			;	ld hl, display_row_1 
8a75			;	ld bc, display_cols 
8a75			;	ldir 
8a75			;;; TODO clear row 1 
8a75			;	ret 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			 
8a75			; clear active frame buffer 
8a75			 
8a75			clear_display: 
8a75 3e 20			ld a, ' ' 
8a77 c3 7a 8a			jp fill_display 
8a7a			 
8a7a			; fill active frame buffer with a char in A 
8a7a			 
8a7a			fill_display: 
8a7a 06 a0			ld b,display_fb_len 
8a7c 2a d2 eb			ld hl, (display_fb_active) 
8a7f 77			.fd1:	ld (hl),a 
8a80 23				inc hl 
8a81 10 fc			djnz .fd1 
8a83 23				inc hl 
8a84 3e 00			ld a,0 
8a86 77				ld (hl),a 
8a87			 
8a87			 
8a87 c9				ret 
8a88			; Write string (DE) at pos (A) to active frame buffer 
8a88			 
8a88 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8a8b 06 00					ld b,0 
8a8d 4f					ld c,a 
8a8e 09					add hl,bc 
8a8f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a90 b7			            OR   A              ;Null terminator? 
8a91 c8			            RET  Z              ;Yes, so finished 
8a92 77					ld (hl),a 
8a93 23				inc hl 
8a94 13			            INC  DE             ;Point to next character 
8a95 18 f8		            JR   .sad1     ;Repeat 
8a97 c9					ret 
8a98			 
8a98			; using current frame buffer write to physical display 
8a98			 
8a98			update_display: 
8a98 e5				push hl 
8a99 2a d2 eb			ld hl, (display_fb_active) 
8a9c cd 29 e2			call write_display 
8a9f e1				pop hl 
8aa0 c9				ret 
8aa1			 
8aa1			; TODO scrolling 
8aa1			 
8aa1			 
8aa1			; move cursor right one char 
8aa1			cursor_right: 
8aa1			 
8aa1				; TODO shift right 
8aa1				; TODO if beyond max col 
8aa1				; TODO       cursor_next_line 
8aa1			 
8aa1 c9				ret 
8aa2			 
8aa2			 
8aa2			cursor_next_line: 
8aa2				; TODO first char 
8aa2				; TODO line down 
8aa2				; TODO if past last row 
8aa2				; TODO    scroll up 
8aa2			 
8aa2 c9				ret 
8aa3			 
8aa3			cursor_left: 
8aa3				; TODO shift left 
8aa3				; TODO if beyond left  
8aa3				; TODO     cursor prev line 
8aa3				 
8aa3 c9				ret 
8aa4			 
8aa4			cursor_prev_line: 
8aa4				; TODO last char 
8aa4				; TODO line up 
8aa4				; TODO if past first row 
8aa4				; TODO   scroll down 
8aa4			 
8aa4 c9				ret 
8aa5			 
8aa5			 
8aa5			cout: 
8aa5				; A - char 
8aa5 c9				ret 
8aa6			 
8aa6			 
8aa6			; Display a menu and allow item selection (optional toggle items) 
8aa6			; 
8aa6			; format: 
8aa6			; hl pointer to word array with zero term for items 
8aa6			; e.g.    db item1 
8aa6			;         db .... 
8aa6			;         db 0 
8aa6			; 
8aa6			; a = starting menu item  
8aa6			; 
8aa6			; de = pointer item toggle array   (todo) 
8aa6			; 
8aa6			; returns item selected in a 1-... 
8aa6			; returns 0 if back button pressed 
8aa6			; 
8aa6			; NOTE: Uses system frame buffer to display 
8aa6			; 
8aa6			; LEFT, Q = go back 
8aa6			; RIGHT, SPACE, CR = select 
8aa6			; UP, A - Up 
8aa6			; DOWN, Z - Down 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			 
8aa6			menu: 
8aa6			 
8aa6					; keep array pointer 
8aa6			 
8aa6 22 7d ea				ld (store_tmp1), hl 
8aa9 32 7b ea				ld (store_tmp2), a 
8aac			 
8aac					; check for key bounce 
8aac			 
8aac			if BASE_KEV 
8aac			 
8aac			.mbounce:	call cin 
8aac					cp 0 
8aac					jr nz, .mbounce 
8aac			endif 
8aac					; for ease use ex 
8aac			 
8aac					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8aac 21 b7 ed				ld hl, display_fb0 
8aaf 22 d2 eb				ld (display_fb_active), hl 
8ab2			 
8ab2 cd 75 8a		.mloop:		call clear_display 
8ab5 cd 98 8a				call update_display 
8ab8			 
8ab8					; draw selection id '>' at 1 
8ab8			 
8ab8					; init start of list display 
8ab8			 
8ab8 3e 05				ld a, 5 
8aba 32 79 ea				ld (store_tmp3), a   ; display row count 
8abd 3a 7b ea				ld a,( store_tmp2) 
8ac0 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ac3			 
8ac3					 
8ac3			.mitem:	 
8ac3			 
8ac3			 
8ac3 3a 7c ea				ld a,(store_tmp2+1) 
8ac6 6f					ld l, a 
8ac7 26 00				ld h, 0 
8ac9 29					add hl, hl 
8aca ed 5b 7d ea			ld de, (store_tmp1) 
8ace 19					add hl, de 
8acf 7e					ld a, (hl) 
8ad0 23					inc hl 
8ad1 66					ld h,(hl) 
8ad2 6f					ld l, a 
8ad3			 
8ad3 cd cb 8c				call ishlzero 
8ad6 28 1a				jr z, .mdone 
8ad8			 
8ad8 eb					ex de, hl 
8ad9 3a 79 ea				ld a, (store_tmp3) 
8adc cd 88 8a				call str_at_display 
8adf					 
8adf			 
8adf					; next item 
8adf 3a 7c ea				ld a, (store_tmp2+1) 
8ae2 3c					inc a 
8ae3 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ae6			 
8ae6			 		; next row 
8ae6			 
8ae6 3a 79 ea				ld a, (store_tmp3) 
8ae9 c6 28				add display_cols 
8aeb 32 79 ea				ld (store_tmp3), a 
8aee			 
8aee					; at end of screen? 
8aee			 
8aee fe 10				cp display_rows*4 
8af0 20 d1				jr nz, .mitem 
8af2			 
8af2			 
8af2			.mdone: 
8af2 cd cb 8c				call ishlzero 
8af5 28 08				jr z, .nodn 
8af7			 
8af7 3e 78				ld a, display_row_4 
8af9 11 78 8b				ld de, .mdown 
8afc cd 88 8a				call str_at_display 
8aff			 
8aff					; draw options to fill the screens with active item on line 1 
8aff					; if current option is 2 or more then display ^ in top 
8aff			 
8aff 3a 7b ea		.nodn:		ld a, (store_tmp2) 
8b02 fe 00				cp 0 
8b04 28 08				jr z, .noup 
8b06			 
8b06 3e 00				ld a, 0 
8b08 11 76 8b				ld de, .mup 
8b0b cd 88 8a				call str_at_display 
8b0e			 
8b0e 3e 02		.noup:		ld a, 2 
8b10 11 74 8b				ld de, .msel 
8b13 cd 88 8a				call str_at_display 
8b16			 
8b16					; if current option + 1 is not null then display V in bottom 
8b16					; get key 
8b16 cd 98 8a				call update_display 
8b19			 
8b19			 
8b19					; handle key 
8b19			 
8b19 cd b5 e2				call cin_wait 
8b1c			 
8b1c fe 05				cp KEY_UP 
8b1e 28 2b				jr z, .mgoup 
8b20 fe 61				cp 'a' 
8b22 28 27				jr z, .mgoup 
8b24 fe 0a				cp KEY_DOWN 
8b26 28 32				jr z, .mgod 
8b28 fe 7a				cp 'z' 
8b2a 28 2e				jr z, .mgod 
8b2c fe 20				cp ' ' 
8b2e 28 34				jr z, .goend 
8b30 fe 0c				cp KEY_RIGHT 
8b32 28 30				jr z, .goend 
8b34 fe 0d				cp KEY_CR 
8b36 28 2c				jr z, .goend 
8b38 fe 71				cp 'q' 
8b3a 28 0b				jr z, .goback 
8b3c			 
8b3c fe 0b				cp KEY_LEFT 
8b3e 28 07				jr z, .goback 
8b40 fe 08				cp KEY_BS 
8b42 28 03				jr z, .goback 
8b44 c3 b2 8a				jp .mloop 
8b47			 
8b47			.goback: 
8b47 3e 00			ld a, 0 
8b49 18 1d			jr .goend2 
8b4b			 
8b4b				; move up one 
8b4b			.mgoup: 
8b4b 3a 7b ea				ld a, (store_tmp2) 
8b4e fe 00				cp 0 
8b50 ca b2 8a				jp z, .mloop 
8b53 3d					dec a 
8b54 32 7b ea				ld (store_tmp2), a 
8b57 c3 b2 8a				jp .mloop 
8b5a			 
8b5a				; move down one 
8b5a			.mgod: 
8b5a 3a 7b ea				ld a, (store_tmp2) 
8b5d 3c					inc a 
8b5e 32 7b ea				ld (store_tmp2), a 
8b61 c3 b2 8a				jp .mloop 
8b64			 
8b64			 
8b64			.goend: 
8b64					; get selected item number 
8b64			 
8b64 3a 7b ea				ld a, (store_tmp2) 
8b67 3c					inc a 
8b68			 
8b68			.goend2: 
8b68 f5					push af 
8b69			 
8b69					; restore active fb 
8b69					; TODO BUG assumes fb1 
8b69			 
8b69 21 16 ed				ld hl, display_fb1 
8b6c 22 d2 eb				ld (display_fb_active), hl 
8b6f			 
8b6f					; restore main regs 
8b6f			 
8b6f			 
8b6f cd 98 8a				call update_display 
8b72			 
8b72 f1					pop af 
8b73			 
8b73 c9				ret 
8b74			 
8b74 .. 00		.msel:   db ">",0 
8b76 .. 00		.mup:   db "^",0 
8b78 .. 00		.mdown:   db "v",0 
8b7a			 
8b7a			 
8b7a			; eof 
8b7a			 
# End of file firmware_display.asm
8b7a			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b7a			; random number generators 
8b7a			 
8b7a			 
8b7a			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b7a			 
8b7a			 
8b7a			;-----> Generate a random number 
8b7a			; output a=answer 0<=a<=255 
8b7a			; all registers are preserved except: af 
8b7a			random: 
8b7a e5			        push    hl 
8b7b d5			        push    de 
8b7c 2a b4 eb		        ld      hl,(randData) 
8b7f ed 5f		        ld      a,r 
8b81 57			        ld      d,a 
8b82 5e			        ld      e,(hl) 
8b83 19			        add     hl,de 
8b84 85			        add     a,l 
8b85 ac			        xor     h 
8b86 22 b4 eb		        ld      (randData),hl 
8b89 d1			        pop     de 
8b8a e1			        pop     hl 
8b8b c9			        ret 
8b8c			 
8b8c			 
8b8c			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b8c			 
8b8c			 
8b8c			 
8b8c			;------LFSR------ 
8b8c			;James Montelongo 
8b8c			;optimized by Spencer Putt 
8b8c			;out: 
8b8c			; a = 8 bit random number 
8b8c			RandLFSR: 
8b8c 21 ba eb		        ld hl,LFSRSeed+4 
8b8f 5e			        ld e,(hl) 
8b90 23			        inc hl 
8b91 56			        ld d,(hl) 
8b92 23			        inc hl 
8b93 4e			        ld c,(hl) 
8b94 23			        inc hl 
8b95 7e			        ld a,(hl) 
8b96 47			        ld b,a 
8b97 cb 13		        rl e  
8b99 cb 12			rl d 
8b9b cb 11		        rl c  
8b9d 17				rla 
8b9e cb 13		        rl e  
8ba0 cb 12			rl d 
8ba2 cb 11		        rl c  
8ba4 17				rla 
8ba5 cb 13		        rl e  
8ba7 cb 12			rl d 
8ba9 cb 11		        rl c  
8bab 17				rla 
8bac 67			        ld h,a 
8bad cb 13		        rl e  
8baf cb 12			rl d 
8bb1 cb 11		        rl c  
8bb3 17				rla 
8bb4 a8			        xor b 
8bb5 cb 13		        rl e  
8bb7 cb 12			rl d 
8bb9 ac			        xor h 
8bba a9			        xor c 
8bbb aa			        xor d 
8bbc 21 bc eb		        ld hl,LFSRSeed+6 
8bbf 11 bd eb		        ld de,LFSRSeed+7 
8bc2 01 07 00		        ld bc,7 
8bc5 ed b8		        lddr 
8bc7 12			        ld (de),a 
8bc8 c9			        ret 
8bc9			 
8bc9			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bc9			 
8bc9			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bc9			 
8bc9			 
8bc9			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bc9			 
8bc9			prng16: 
8bc9			;Inputs: 
8bc9			;   (seed1) contains a 16-bit seed value 
8bc9			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bc9			;Outputs: 
8bc9			;   HL is the result 
8bc9			;   BC is the result of the LCG, so not that great of quality 
8bc9			;   DE is preserved 
8bc9			;Destroys: 
8bc9			;   AF 
8bc9			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bc9			;160cc 
8bc9			;26 bytes 
8bc9 2a ae eb		    ld hl,(seed1) 
8bcc 44			    ld b,h 
8bcd 4d			    ld c,l 
8bce 29			    add hl,hl 
8bcf 29			    add hl,hl 
8bd0 2c			    inc l 
8bd1 09			    add hl,bc 
8bd2 22 ae eb		    ld (seed1),hl 
8bd5 2a ac eb		    ld hl,(seed2) 
8bd8 29			    add hl,hl 
8bd9 9f			    sbc a,a 
8bda e6 2d		    and %00101101 
8bdc ad			    xor l 
8bdd 6f			    ld l,a 
8bde 22 ac eb		    ld (seed2),hl 
8be1 09			    add hl,bc 
8be2 c9			    ret 
8be3			 
8be3			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8be3			 
8be3			rand32: 
8be3			;Inputs: 
8be3			;   (seed1_0) holds the lower 16 bits of the first seed 
8be3			;   (seed1_1) holds the upper 16 bits of the first seed 
8be3			;   (seed2_0) holds the lower 16 bits of the second seed 
8be3			;   (seed2_1) holds the upper 16 bits of the second seed 
8be3			;   **NOTE: seed2 must be non-zero 
8be3			;Outputs: 
8be3			;   HL is the result 
8be3			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8be3			;Destroys: 
8be3			;   AF 
8be3			;Tested and passes all CAcert tests 
8be3			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8be3			;it has a period of 18,446,744,069,414,584,320 
8be3			;roughly 18.4 quintillion. 
8be3			;LFSR taps: 0,2,6,7  = 11000101 
8be3			;291cc 
8be3			;seed1_0=$+1 
8be3			;    ld hl,12345 
8be3			;seed1_1=$+1 
8be3			;    ld de,6789 
8be3			;    ld b,h 
8be3			;    ld c,l 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    add hl,hl \ rl e \ rl d 
8be3			;    inc l 
8be3			;    add hl,bc 
8be3			;    ld (seed1_0),hl 
8be3			;    ld hl,(seed1_1) 
8be3			;    adc hl,de 
8be3			;    ld (seed1_1),hl 
8be3			;    ex de,hl 
8be3			;seed2_0=$+1 
8be3			;    ld hl,9876 
8be3			;seed2_1=$+1 
8be3			;    ld bc,54321 
8be3			;    add hl,hl \ rl c \ rl b 
8be3			;    ld (seed2_1),bc 
8be3			;    sbc a,a 
8be3			;    and %11000101 
8be3			;    xor l 
8be3			;    ld l,a 
8be3			;    ld (seed2_0),hl 
8be3			;    ex de,hl 
8be3			;    add hl,bc 
8be3			;    ret 
8be3			; 
8be3			 
8be3			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8be3			; 20 bytes, 86 cycles (excluding ret) 
8be3			 
8be3			; returns   hl = pseudorandom number 
8be3			; corrupts   a 
8be3			 
8be3			; generates 16-bit pseudorandom numbers with a period of 65535 
8be3			; using the xorshift method: 
8be3			 
8be3			; hl ^= hl << 7 
8be3			; hl ^= hl >> 9 
8be3			; hl ^= hl << 8 
8be3			 
8be3			; some alternative shift triplets which also perform well are: 
8be3			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8be3			 
8be3			;  org 32768 
8be3			 
8be3			xrnd: 
8be3 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8be6 3e 00		  ld a,0 
8be8 bd			  cp l 
8be9 20 02		  jr nz, .xrnd1 
8beb 2e 01		  ld l, 1 
8bed			.xrnd1: 
8bed			 
8bed 7c			  ld a,h 
8bee 1f			  rra 
8bef 7d			  ld a,l 
8bf0 1f			  rra 
8bf1 ac			  xor h 
8bf2 67			  ld h,a 
8bf3 7d			  ld a,l 
8bf4 1f			  rra 
8bf5 7c			  ld a,h 
8bf6 1f			  rra 
8bf7 ad			  xor l 
8bf8 6f			  ld l,a 
8bf9 ac			  xor h 
8bfa 67			  ld h,a 
8bfb			 
8bfb 22 b2 eb		  ld (xrandc),hl 
8bfe			 
8bfe c9			  ret 
8bff			;  
8bff			 
8bff			 
8bff			;;;; int maths 
8bff			 
8bff			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bff			; Divide 16-bit values (with 16-bit result) 
8bff			; In: Divide BC by divider DE 
8bff			; Out: BC = result, HL = rest 
8bff			; 
8bff			Div16: 
8bff 21 00 00		    ld hl,0 
8c02 78			    ld a,b 
8c03 06 08		    ld b,8 
8c05			Div16_Loop1: 
8c05 17			    rla 
8c06 ed 6a		    adc hl,hl 
8c08 ed 52		    sbc hl,de 
8c0a 30 01		    jr nc,Div16_NoAdd1 
8c0c 19			    add hl,de 
8c0d			Div16_NoAdd1: 
8c0d 10 f6		    djnz Div16_Loop1 
8c0f 17			    rla 
8c10 2f			    cpl 
8c11 47			    ld b,a 
8c12 79			    ld a,c 
8c13 48			    ld c,b 
8c14 06 08		    ld b,8 
8c16			Div16_Loop2: 
8c16 17			    rla 
8c17 ed 6a		    adc hl,hl 
8c19 ed 52		    sbc hl,de 
8c1b 30 01		    jr nc,Div16_NoAdd2 
8c1d 19			    add hl,de 
8c1e			Div16_NoAdd2: 
8c1e 10 f6		    djnz Div16_Loop2 
8c20 17			    rla 
8c21 2f			    cpl 
8c22 41			    ld b,c 
8c23 4f			    ld c,a 
8c24 c9			ret 
8c25			 
8c25			 
8c25			;http://z80-heaven.wikidot.com/math 
8c25			; 
8c25			;Inputs: 
8c25			;     DE and A are factors 
8c25			;Outputs: 
8c25			;     A is not changed 
8c25			;     B is 0 
8c25			;     C is not changed 
8c25			;     DE is not changed 
8c25			;     HL is the product 
8c25			;Time: 
8c25			;     342+6x 
8c25			; 
8c25			Mult16: 
8c25			 
8c25 06 08		     ld b,8          ;7           7 
8c27 21 00 00		     ld hl,0         ;10         10 
8c2a 29			       add hl,hl     ;11*8       88 
8c2b 07			       rlca          ;4*8        32 
8c2c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c2e 19			         add hl,de   ;--         -- 
8c2f 10 f9		       djnz $-5      ;13*7+8     99 
8c31 c9			ret 
8c32			 
8c32			; 
8c32			; Square root of 16-bit value 
8c32			; In:  HL = value 
8c32			; Out:  D = result (rounded down) 
8c32			; 
8c32			;Sqr16: 
8c32			;    ld de,#0040 
8c32			;    ld a,l 
8c32			;    ld l,h 
8c32			;    ld h,d 
8c32			;    or a 
8c32			;    ld b,8 
8c32			;Sqr16_Loop: 
8c32			;    sbc hl,de 
8c32			;    jr nc,Sqr16_Skip 
8c32			;    add hl,de 
8c32			;Sqr16_Skip: 
8c32			;    ccf 
8c32			;    rl d 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    add a,a 
8c32			;    adc hl,hl 
8c32			;    djnz Sqr16_Loop 
8c32			;    ret 
8c32			; 
8c32			; 
8c32			; Divide 8-bit values 
8c32			; In: Divide E by divider C 
8c32			; Out: A = result, B = rest 
8c32			; 
8c32			Div8: 
8c32 af			    xor a 
8c33 06 08		    ld b,8 
8c35			Div8_Loop: 
8c35 cb 13		    rl e 
8c37 17			    rla 
8c38 91			    sub c 
8c39 30 01		    jr nc,Div8_NoAdd 
8c3b 81			    add a,c 
8c3c			Div8_NoAdd: 
8c3c 10 f7		    djnz Div8_Loop 
8c3e 47			    ld b,a 
8c3f 7b			    ld a,e 
8c40 17			    rla 
8c41 2f			    cpl 
8c42 c9			    ret 
8c43			 
8c43			; 
8c43			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c43			; In: Multiply A with DE 
8c43			; Out: HL = result 
8c43			; 
8c43			Mult12U: 
8c43 2e 00		    ld l,0 
8c45 87			    add a,a 
8c46 30 01		    jr nc,Mult12U_NoAdd0 
8c48 19			    add hl,de 
8c49			Mult12U_NoAdd0: 
8c49 29			    add hl,hl 
8c4a 87			    add a,a 
8c4b 30 01		    jr nc,Mult12U_NoAdd1 
8c4d 19			    add hl,de 
8c4e			Mult12U_NoAdd1: 
8c4e 29			    add hl,hl 
8c4f 87			    add a,a 
8c50 30 01		    jr nc,Mult12U_NoAdd2 
8c52 19			    add hl,de 
8c53			Mult12U_NoAdd2: 
8c53 29			    add hl,hl 
8c54 87			    add a,a 
8c55 30 01		    jr nc,Mult12U_NoAdd3 
8c57 19			    add hl,de 
8c58			Mult12U_NoAdd3: 
8c58 29			    add hl,hl 
8c59 87			    add a,a 
8c5a 30 01		    jr nc,Mult12U_NoAdd4 
8c5c 19			    add hl,de 
8c5d			Mult12U_NoAdd4: 
8c5d 29			    add hl,hl 
8c5e 87			    add a,a 
8c5f 30 01		    jr nc,Mult12U_NoAdd5 
8c61 19			    add hl,de 
8c62			Mult12U_NoAdd5: 
8c62 29			    add hl,hl 
8c63 87			    add a,a 
8c64 30 01		    jr nc,Mult12U_NoAdd6 
8c66 19			    add hl,de 
8c67			Mult12U_NoAdd6: 
8c67 29			    add hl,hl 
8c68 87			    add a,a 
8c69 d0			    ret nc 
8c6a 19			    add hl,de 
8c6b c9			    ret 
8c6c			 
8c6c			; 
8c6c			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c6c			; In: Multiply A with DE 
8c6c			;      Put lowest value in A for most efficient calculation 
8c6c			; Out: HL = result 
8c6c			; 
8c6c			Mult12R: 
8c6c 21 00 00		    ld hl,0 
8c6f			Mult12R_Loop: 
8c6f cb 3f		    srl a 
8c71 30 01		    jr nc,Mult12R_NoAdd 
8c73 19			    add hl,de 
8c74			Mult12R_NoAdd: 
8c74 cb 23		    sla e 
8c76 cb 12		    rl d 
8c78 b7			    or a 
8c79 c2 6f 8c		    jp nz,Mult12R_Loop 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 16-bit values (with 32-bit result) 
8c7d			; In: Multiply BC with DE 
8c7d			; Out: BCHL = result 
8c7d			; 
8c7d			Mult32: 
8c7d 79			    ld a,c 
8c7e 48			    ld c,b 
8c7f 21 00 00		    ld hl,0 
8c82 06 10		    ld b,16 
8c84			Mult32_Loop: 
8c84 29			    add hl,hl 
8c85 17			    rla 
8c86 cb 11		    rl c 
8c88 30 07		    jr nc,Mult32_NoAdd 
8c8a 19			    add hl,de 
8c8b ce 00		    adc a,0 
8c8d d2 91 8c		    jp nc,Mult32_NoAdd 
8c90 0c			    inc c 
8c91			Mult32_NoAdd: 
8c91 10 f1		    djnz Mult32_Loop 
8c93 41			    ld b,c 
8c94 4f			    ld c,a 
8c95 c9			    ret 
8c96			 
8c96			 
8c96			 
8c96			; 
8c96			; Multiply 8-bit values 
8c96			; In:  Multiply H with E 
8c96			; Out: HL = result 
8c96			; 
8c96			Mult8: 
8c96 16 00		    ld d,0 
8c98 6a			    ld l,d 
8c99 06 08		    ld b,8 
8c9b			Mult8_Loop: 
8c9b 29			    add hl,hl 
8c9c 30 01		    jr nc,Mult8_NoAdd 
8c9e 19			    add hl,de 
8c9f			Mult8_NoAdd: 
8c9f 10 fa		    djnz Mult8_Loop 
8ca1 c9			    ret 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			 
8ca2			;;http://z80-heaven.wikidot.com/math 
8ca2			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ca2			; 
8ca2			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ca2			;     ld a,16        ;7 
8ca2			;     ld hl,0        ;10 
8ca2			;     jp $+5         ;10 
8ca2			;.DivLoop: 
8ca2			;       add hl,bc    ;-- 
8ca2			;       dec a        ;64 
8ca2			;       jr z,.DivLoopEnd        ;86 
8ca2			; 
8ca2			;       sla e        ;128 
8ca2			;       rl d         ;128 
8ca2			;       adc hl,hl    ;240 
8ca2			;       sbc hl,bc    ;240 
8ca2			;       jr nc,.DivLoop ;23|21 
8ca2			;       inc e        ;-- 
8ca2			;       jp .DivLoop+1 
8ca2			; 
8ca2			;.DivLoopEnd: 
8ca2			 
8ca2			;HL_Div_C: 
8ca2			;Inputs: 
8ca2			;     HL is the numerator 
8ca2			;     C is the denominator 
8ca2			;Outputs: 
8ca2			;     A is the remainder 
8ca2			;     B is 0 
8ca2			;     C is not changed 
8ca2			;     DE is not changed 
8ca2			;     HL is the quotient 
8ca2			; 
8ca2			;       ld b,16 
8ca2			;       xor a 
8ca2			;         add hl,hl 
8ca2			;         rla 
8ca2			;         cp c 
8ca2			;         jr c,$+4 
8ca2			;           inc l 
8ca2			;           sub c 
8ca2			;         djnz $-7 
8ca2			 
8ca2			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ca2			 
8ca2			addatohl: 
8ca2 85			    add   a, l    ; A = A+L 
8ca3 6f			    ld    l, a    ; L = A+L 
8ca4 8c			    adc   a, h    ; A = A+L+H+carry 
8ca5 95			    sub   l       ; A = H+carry 
8ca6 67			    ld    h, a    ; H = H+carry 
8ca7 c9			ret 
8ca8			 
8ca8			addatode: 
8ca8 83			    add   a, e    ; A = A+L 
8ca9 5f			    ld    e, a    ; L = A+L 
8caa 8a			    adc   a, d    ; A = A+L+H+carry 
8cab 93			    sub   e       ; A = H+carry 
8cac 57			    ld    d, a    ; H = H+carry 
8cad c9			ret 
8cae			 
8cae			 
8cae			addatobc: 
8cae 81			    add   a, c    ; A = A+L 
8caf 4f			    ld    c, a    ; L = A+L 
8cb0 88			    adc   a, b    ; A = A+L+H+carry 
8cb1 91			    sub   c       ; A = H+carry 
8cb2 47			    ld    b, a    ; H = H+carry 
8cb3 c9			ret 
8cb4			 
8cb4			subafromhl: 
8cb4			   ; If A=0 do nothing 
8cb4			    ; Otherwise flip A's sign. Since 
8cb4			    ; the upper byte becomes -1, also 
8cb4			    ; substract 1 from H. 
8cb4 ed 44		    neg 
8cb6 ca bf 8c		    jp    z, Skip 
8cb9 25			    dec   h 
8cba			     
8cba			    ; Now add the low byte as usual 
8cba			    ; Two's complement takes care of 
8cba			    ; ensuring the result is correct 
8cba 85			    add   a, l 
8cbb 6f			    ld    l, a 
8cbc 8c			    adc   a, h 
8cbd 95			    sub   l 
8cbe 67			    ld    h, a 
8cbf			Skip: 
8cbf c9				ret 
8cc0			 
8cc0			 
8cc0			; compare hl and de 
8cc0			; returns:  
8cc0			; if hl = de, z=1, s=0, c0=0 
8cc0			; if hl > de, z=0, s=0, c=0 
8cc0			; if hl < de, z=0, s=1, c=1 
8cc0			cmp16:	 
8cc0 b7				or a 
8cc1 ed 52			sbc hl,de 
8cc3 e0				ret po 
8cc4 7c				ld a,h 
8cc5 1f				rra 
8cc6 ee 40			xor 01000000B 
8cc8 37				scf 
8cc9 8f				adc a,a 
8cca c9				ret 
8ccb			 
8ccb			 
8ccb			; test if hl contains zero   - A is destroyed 
8ccb			 
8ccb			ishlzero:    
8ccb b7				or a     ; reset flags 
8ccc 7c				ld a, h 
8ccd b5				or l        	 
8cce			 
8cce c9				ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			 
8ccf			if FORTH_ENABLE_FLOATMATH 
8ccf			;include "float/bbcmath.z80" 
8ccf			include "float/lpfpcalc.asm" 
8ccf			endif 
8ccf			 
8ccf			 
8ccf			; eof 
8ccf			 
# End of file firmware_maths.asm
8ccf			include "firmware_strings.asm"   ; string handling  
8ccf			 
8ccf			 
8ccf			; TODO string len 
8ccf			; input text string, end on cr with zero term 
8ccf			; a offset into frame buffer to start prompt 
8ccf			; d is max length 
8ccf			; e is display size TODO 
8ccf			; c is current cursor position 
8ccf			; hl is ptr to where string will be stored 
8ccf			 
8ccf			 
8ccf			; TODO check limit of buffer for new inserts 
8ccf			; TODO check insert does not push beyond buffer 
8ccf			; TODO scroll in a limited display area 
8ccf			; TODO scroll whole screen on page wrap 
8ccf			 
8ccf			 
8ccf			; TODO handle KEY_PREVWORD 
8ccf			; TODO handle KEY_NEXTWORD 
8ccf			; TODO handle KEY_HOME 
8ccf			; TODO handle KEY_END 
8ccf			; TODO use LCD cursor? 
8ccf			 
8ccf 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8cd2 81					add c 
8cd3 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8cd6 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8cd9 79					ld a, c 
8cda cd a2 8c				call addatohl 
8cdd 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ce0 7a					ld a,d 
8ce1 32 6c ee			        ld (input_size), a       ; save length of input area 
8ce4 79					ld a, c 
8ce5 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8ce8 7b					ld a,e 
8ce9 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8cec					 
8cec					 
8cec			 
8cec			;		ld a,(input_ptr) 
8cec			;		ld (input_under_cursor),a 	; save what is under the cursor 
8cec			 
8cec			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8cec					; init cursor shape if not set by the cin routines 
8cec 21 ca eb				ld hl, cursor_shape 
8cef 3e ff				ld a, 255 
8cf1 77					ld (hl), a 
8cf2 23					inc hl 
8cf3 3e 00				ld a, 0 
8cf5 77					ld (hl), a 
8cf6			 
8cf6 3e 0f				ld a, CUR_BLINK_RATE 
8cf8 32 66 ee				ld (input_cur_flash), a 
8cfb 3e 01				ld a, 1 
8cfd 32 65 ee				ld (input_cur_onoff),a 
8d00			 
8d00			;	if DEBUG_INPUT 
8d00			;		push af 
8d00			;		ld a, 'I' 
8d00			;		ld (debug_mark),a 
8d00			;		pop af 
8d00			;		CALLMONITOR 
8d00			;	endif 
8d00			.is1:		; main entry loop 
8d00			 
8d00			 
8d00			 
8d00					; pause 1ms 
8d00			 
8d00 3e 01				ld a, 1 
8d02 cd d7 89				call aDelayInMS 
8d05			 
8d05					; dec flash counter 
8d05 3a 66 ee				ld a, (input_cur_flash) 
8d08 3d					dec a 
8d09 32 66 ee				ld (input_cur_flash), a 
8d0c fe 00				cp 0 
8d0e 20 0d				jr nz, .nochgstate 
8d10			 
8d10			 
8d10					; change state 
8d10 3a 65 ee				ld a,(input_cur_onoff) 
8d13 ed 44				neg 
8d15 32 65 ee				ld (input_cur_onoff),a 
8d18			 
8d18			 
8d18					; reset on change of state 
8d18 3e 0f				ld a, CUR_BLINK_RATE 
8d1a 32 66 ee				ld (input_cur_flash), a 
8d1d			 
8d1d			.nochgstate: 
8d1d					 
8d1d					 
8d1d			 
8d1d					; display cursor  
8d1d			 
8d1d			;		ld hl, (input_start) 
8d1d			;		ld a, (input_cursor) 
8d1d			;		call addatohl 
8d1d			 
8d1d					; get char under cursor and replace with cursor 
8d1d 2a 6f ee		ld hl, (input_ptr) 
8d20			;		ld a, (hl) 
8d20			;		ld (input_under_cursor),a 
8d20			;		ld a, '_' 
8d20			;		ld (hl), a 
8d20			 
8d20					; display string 
8d20			 
8d20 ed 5b 6d ee			ld de, (input_start) 
8d24 3a 6a ee				ld a, (input_at_pos) 
8d27 cd 88 8a				call str_at_display 
8d2a			;	        call update_display 
8d2a			 
8d2a					; find place to put the cursor 
8d2a			;		add h 
8d2a			;		ld l, display_row_1 
8d2a			;		sub l 
8d2a			; (input_at_pos) 
8d2a					;ld c, a 
8d2a			;		ld a, (input_cursor) 
8d2a			;		ld l, (input_at_pos) 
8d2a			;		;ld b, h 
8d2a			;		add l 
8d2a			;		ld (input_at_cursor),a 
8d2a					;ld l,h 
8d2a			 
8d2a			;		ld h, 0 
8d2a			;		ld l,(input_at_pos) 
8d2a			;		ld a, (input_cursor) 
8d2a			;		call addatohl 
8d2a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d2a			;		call subafromhl 
8d2a			;		ld a,l 
8d2a			;		ld (input_at_cursor), a 
8d2a			 
8d2a				if DEBUG_INPUT 
8d2a					ld a, (hardware_diag) 
8d2a					cp 0 
8d2a					jr z, .skip_input_diag 
8d2a			 
8d2a					ld a,(input_at_pos) 
8d2a					ld hl, LFSRSeed 
8d2a					call hexout 
8d2a					ld a, (input_cursor) 
8d2a					ld hl, LFSRSeed+2 
8d2a					call hexout 
8d2a					ld a,(input_at_cursor) 
8d2a					ld hl, LFSRSeed+4 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_onoff) 
8d2a					ld hl, LFSRSeed+6 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_cur_flash) 
8d2a					ld hl, LFSRSeed+8 
8d2a					call hexout 
8d2a			 
8d2a					ld a,(input_len) 
8d2a					ld hl, LFSRSeed+10 
8d2a					call hexout 
8d2a					ld hl, LFSRSeed+12 
8d2a					ld a, 0 
8d2a					ld (hl),a 
8d2a					ld a, display_row_4 
8d2a					ld de, LFSRSeed 
8d2a					call str_at_display 
8d2a					.skip_input_diag: 
8d2a				endif 
8d2a			 
8d2a					; decide on if we are showing the cursor this time round 
8d2a			 
8d2a 3a 65 ee				ld a, (input_cur_onoff) 
8d2d fe ff				cp 255 
8d2f 28 13				jr z, .skipcur 
8d31			 
8d31			 
8d31 3a 68 ee				ld a,(input_at_cursor) 
8d34 11 ca eb				ld de, cursor_shape 
8d37 cd 88 8a				call str_at_display 
8d3a			 
8d3a					; save length of current input string 
8d3a 2a 6d ee				ld hl, (input_start) 
8d3d cd 00 91				call strlenz 
8d40 7d					ld a,l 
8d41 32 60 ee				ld (input_len),a 
8d44			 
8d44			.skipcur: 
8d44			 
8d44 cd 98 8a			        call update_display 
8d47					 
8d47			 
8d47			 
8d47					; wait 
8d47				 
8d47					; TODO loop without wait to flash the cursor and char under cursor	 
8d47 cd bb e2				call cin    ; _wait 
8d4a			 
8d4a fe 00				cp 0 
8d4c ca 00 8d				jp z, .is1 
8d4f			 
8d4f					; get ptr to char to input into 
8d4f			 
8d4f 4f					ld c,a 
8d50 2a 6d ee				ld hl, (input_start) 
8d53 3a 5b ee				ld a, (input_cursor) 
8d56 cd a2 8c				call addatohl 
8d59 22 6f ee				ld (input_ptr), hl 
8d5c 79					ld a,c 
8d5d			 
8d5d					; replace char under cursor 
8d5d			 
8d5d			;		ld hl, (input_ptr) 
8d5d			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d5d			;		ld (hl), a 
8d5d			 
8d5d			;	if DEBUG_INPUT 
8d5d			;		push af 
8d5d			;		ld a, 'i' 
8d5d			;		ld (debug_mark),a 
8d5d			;		pop af 
8d5d			;		CALLMONITOR 
8d5d			;	endif 
8d5d fe 0e				cp KEY_HOME 
8d5f 20 0e				jr nz, .iske 
8d61			 
8d61 3a 6a ee				ld a, (input_at_pos) 
8d64 32 68 ee				ld (input_at_cursor),a 
8d67 3e 00				ld a, 0 
8d69 32 5b ee				ld (input_cursor), a 
8d6c c3 00 8d				jp .is1 
8d6f					 
8d6f fe 0f		.iske:		cp KEY_END 
8d71 20 03				jr nz, .isknw 
8d73 c3 00 8d				jp .is1 
8d76			 
8d76 fe 06		.isknw:		cp KEY_NEXTWORD 
8d78 20 1b				jr nz, .iskpw 
8d7a			 
8d7a 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8d7d 7e					ld a,(hl)	 
8d7e fe 00				cp 0 
8d80 ca 00 8d				jp z, .is1    ; end of string 
8d83 fe 20				cp ' ' 
8d85 ca 00 8d				jp z, .is1    ; end of word 
8d88 23					inc hl 
8d89 22 6f ee				ld (input_ptr), hl 
8d8c 3a 68 ee				ld a, (input_at_cursor) 
8d8f 3c					inc a 
8d90 32 68 ee				ld (input_at_cursor), a 
8d93 18 e5				jr .isknwm 
8d95			 
8d95 fe 07		.iskpw:		cp KEY_PREVWORD 
8d97 20 1b				jr nz, .iskl 
8d99			.iskpwm:	 
8d99 2a 6f ee				ld hl, (input_ptr) 
8d9c 7e					ld a,(hl)	 
8d9d fe 00				cp 0  
8d9f ca 00 8d				jp z, .is1    ; end of string 
8da2 fe 20				cp ' ' 
8da4 ca 00 8d				jp z, .is1    ; end of word 
8da7 2b					dec hl 
8da8 22 6f ee				ld (input_ptr), hl 
8dab 3a 68 ee				ld a, (input_at_cursor) 
8dae 3d					dec a 
8daf 32 68 ee				ld (input_at_cursor), a 
8db2 18 e5				jr .iskpwm 
8db4			 
8db4			 
8db4 fe 0b		.iskl:		cp KEY_LEFT 
8db6 20 27				jr nz, .isk1 
8db8			 
8db8 3a 5b ee				ld a, (input_cursor) 
8dbb			 
8dbb fe 00				cp 0 
8dbd ca 00 8d				jp z, .is1 		; at start of line to ignore  
8dc0			 
8dc0 3d					dec  a 		; TODO check underflow 
8dc1 32 5b ee				ld (input_cursor), a 
8dc4			 
8dc4 2a 6f ee				ld hl, (input_ptr) 
8dc7 2b					dec hl 
8dc8 22 6f ee				ld (input_ptr), hl 
8dcb					 
8dcb 3a 68 ee				ld a, (input_at_cursor) 
8dce 3d					dec a 
8dcf 32 68 ee				ld (input_at_cursor), a 
8dd2			 
8dd2 3e 01				ld a, 1		; show cursor moving 
8dd4 32 65 ee				ld (input_cur_onoff),a 
8dd7 3e 0f				ld a, CUR_BLINK_RATE 
8dd9 32 66 ee				ld (input_cur_flash), a 
8ddc			 
8ddc c3 00 8d				jp .is1 
8ddf			 
8ddf fe 0c		.isk1:		cp KEY_RIGHT 
8de1 20 2a				jr nz, .isk2 
8de3			 
8de3 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8de6 5f					ld e,a 
8de7 3a 5b ee				ld a, (input_cursor) 
8dea bb					cp e 
8deb ca 00 8d				jp z, .is1		; at the end of string so dont go right 
8dee			 
8dee 3c					inc  a 		; TODO check overflow 
8def 32 5b ee				ld (input_cursor), a 
8df2			 
8df2 3a 68 ee				ld a, (input_at_cursor) 
8df5 3c					inc a 
8df6 32 68 ee				ld (input_at_cursor), a 
8df9			 
8df9 2a 6f ee				ld hl, (input_ptr) 
8dfc 23					inc hl 
8dfd 22 6f ee				ld (input_ptr), hl 
8e00			 
8e00 3e 01				ld a, 1		; show cursor moving 
8e02 32 65 ee				ld (input_cur_onoff),a 
8e05 3e 0f				ld a, CUR_BLINK_RATE 
8e07 32 66 ee				ld (input_cur_flash), a 
8e0a			 
8e0a c3 00 8d				jp .is1 
8e0d			 
8e0d fe 05		.isk2:		cp KEY_UP 
8e0f			 
8e0f 20 26				jr nz, .isk3 
8e11			 
8e11					; swap last command with the current on 
8e11			 
8e11					; move cursor to start of string 
8e11 2a 6d ee				ld hl, (input_start) 
8e14 22 6f ee				ld (input_ptr), hl 
8e17			 
8e17 3a 6a ee				ld a, (input_at_pos) 
8e1a 32 68 ee				ld (input_at_cursor), a 
8e1d			 
8e1d 3e 00				ld a, 0 
8e1f 32 5b ee				ld (input_cursor), a 
8e22					 
8e22					; swap input and last command buffers 
8e22			 
8e22 21 f2 e5				ld hl, os_cli_cmd 
8e25 11 f1 e6				ld de, os_last_cmd 
8e28 06 ff				ld b, 255 
8e2a 7e			.swap1:		ld a, (hl) 
8e2b 4f					ld c,a 
8e2c 1a					ld a, (de) 
8e2d 77					ld (hl), a 
8e2e 79					ld a,c 
8e2f 12					ld (de),a 
8e30 23					inc hl 
8e31 13					inc de 
8e32 10 f6				djnz .swap1 
8e34			 
8e34			 
8e34			 
8e34			 
8e34			 
8e34 c3 00 8d				jp .is1 
8e37			 
8e37 fe 08		.isk3:		cp KEY_BS 
8e39 20 3c				jr nz, .isk4 
8e3b			 
8e3b 3a 5b ee				ld a, (input_cursor) 
8e3e			 
8e3e fe 00				cp 0 
8e40 ca 00 8d				jp z, .is1 		; at start of line to ignore  
8e43			 
8e43 3d					dec  a 		; TODO check underflow 
8e44 32 5b ee				ld (input_cursor), a 
8e47			 
8e47					; hl is source 
8e47					; de needs to be source - 1 
8e47			 
8e47			;		ld a, 0 
8e47			;		dec hl 
8e47			;		ld (hl), a 
8e47			 
8e47 2a 6f ee				ld hl, (input_ptr) 
8e4a 2b					dec hl 
8e4b 22 6f ee				ld (input_ptr), hl 
8e4e			 
8e4e					; shift all data 
8e4e			 
8e4e e5					push hl 
8e4f 23					inc hl 
8e50 d1					pop de 
8e51 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e54 4f					ld c,a 
8e55 06 00				ld b,0 
8e57 ed b0				ldir  
8e59			 
8e59			 
8e59			 
8e59			 
8e59 3a 68 ee				ld a, (input_at_cursor) 
8e5c 3d					dec a 
8e5d 32 68 ee				ld (input_at_cursor), a 
8e60			 
8e60			 
8e60 3e 01				ld a, 1		; show cursor moving 
8e62 32 65 ee				ld (input_cur_onoff),a 
8e65 3e 0f				ld a, CUR_BLINK_RATE 
8e67 32 66 ee				ld (input_cur_flash), a 
8e6a			 
8e6a					; remove char 
8e6a 3a 68 ee				ld a, (input_at_cursor) 
8e6d 3c					inc a 
8e6e 11 f8 8e				ld de,.iblank 
8e71 cd 88 8a				call str_at_display 
8e74			 
8e74 c3 00 8d				jp .is1 
8e77			 
8e77 fe 0d		.isk4:		cp KEY_CR 
8e79 28 6c				jr z, .endinput 
8e7b			 
8e7b					; else add the key press to the end 
8e7b			 
8e7b 4f					ld c, a			; save key pressed 
8e7c			 
8e7c 7e					ld a,(hl)		; get what is currently under char 
8e7d			 
8e7d fe 00				cp 0			; we are at the end of the string 
8e7f 20 2f				jr nz, .onchar 
8e81					 
8e81					; add a char to the end of the string 
8e81				 
8e81 71					ld (hl),c 
8e82 23					inc hl 
8e83			;		ld a,' ' 
8e83			;		ld (hl),a 
8e83			;		inc hl 
8e83 3e 00				ld a,0 
8e85 77					ld (hl),a 
8e86 2b					dec hl 
8e87			 
8e87 3a 5b ee				ld a, (input_cursor) 
8e8a 3c					inc a				; TODO check max string length and scroll  
8e8b 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8e8e							 
8e8e 3a 68 ee				ld a, (input_at_cursor) 
8e91 3c					inc a 
8e92 32 68 ee				ld (input_at_cursor), a 
8e95			 
8e95 2a 6f ee				ld hl, (input_ptr) 
8e98 23					inc hl 
8e99 22 6f ee				ld (input_ptr), hl 
8e9c			 
8e9c 2a 6f ee				ld hl, (input_ptr) 
8e9f 23					inc hl 
8ea0 22 6f ee				ld (input_ptr), hl 
8ea3			;	if DEBUG_INPUT 
8ea3			;		push af 
8ea3			;		ld a, '+' 
8ea3			;		ld (debug_mark),a 
8ea3			;		pop af 
8ea3			;		CALLMONITOR 
8ea3			;	endif 
8ea3 3e 01				ld a, 1		; show cursor moving 
8ea5 32 65 ee				ld (input_cur_onoff),a 
8ea8 3e 0f				ld a, CUR_BLINK_RATE 
8eaa 32 66 ee				ld (input_cur_flash), a 
8ead c3 00 8d				jp .is1 
8eb0					 
8eb0			 
8eb0			 
8eb0					; if on a char then insert 
8eb0			.onchar: 
8eb0			 
8eb0					; TODO over flow check: make sure insert does not blow out buffer 
8eb0			 
8eb0					; need to do some maths to use lddr 
8eb0			 
8eb0 e5					push hl   ; save char pos 
8eb1 c5					push bc 
8eb2			 
8eb2 2a 6d ee				ld hl, (input_start) 
8eb5 3a 60 ee				ld a, (input_len) 
8eb8 cd a2 8c				call addatohl  		; end of string 
8ebb 23					inc hl 
8ebc 23					inc hl		; past zero term 
8ebd e5					push hl 
8ebe 23					inc hl 
8ebf e5					push hl  
8ec0			 
8ec0								; start and end of lddr set, now how much to move? 
8ec0			 
8ec0							 
8ec0 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ec3 47					ld b,a 
8ec4 3a 60 ee				ld a,(input_len) 
8ec7 5f					ld e,a 
8ec8 90					sub b 
8ec9 3c					inc a		;?? 
8eca 3c					inc a		;?? 
8ecb 3c					inc a		;?? 
8ecc			 
8ecc 06 00				ld b,0 
8ece 4f					ld c,a 
8ecf			 
8ecf				if DEBUG_INPUT 
8ecf					push af 
8ecf					ld a, 'i' 
8ecf					ld (debug_mark),a 
8ecf					pop af 
8ecf			;		CALLMONITOR 
8ecf				endif 
8ecf d1					pop de 
8ed0 e1					pop hl 
8ed1				if DEBUG_INPUT 
8ed1					push af 
8ed1					ld a, 'I' 
8ed1					ld (debug_mark),a 
8ed1					pop af 
8ed1			;		CALLMONITOR 
8ed1				endif 
8ed1 ed b8				lddr 
8ed3				 
8ed3			 
8ed3			 
8ed3					; TODO have a key for insert/overwrite mode???? 
8ed3 c1					pop bc 
8ed4 e1					pop hl 
8ed5 71					ld (hl), c		; otherwise overwrite current char 
8ed6					 
8ed6			 
8ed6			 
8ed6			 
8ed6 3a 5b ee				ld a, (input_cursor) 
8ed9 3c					inc  a 		; TODO check overflow 
8eda 32 5b ee				ld (input_cursor), a 
8edd			 
8edd 3a 68 ee				ld a, (input_at_cursor) 
8ee0 3c					inc a 
8ee1 32 68 ee				ld (input_at_cursor), a 
8ee4			 
8ee4 c3 00 8d				jp .is1 
8ee7			 
8ee7			.endinput:	; TODO look for end of string 
8ee7			 
8ee7					; add trailing space for end of token 
8ee7			 
8ee7 2a 6d ee				ld hl, (input_start) 
8eea 3a 60 ee				ld a,(input_len) 
8eed cd a2 8c				call addatohl 
8ef0 3e 20				ld a, ' ' 
8ef2 77					ld (hl),a 
8ef3					; TODO eof of parse marker 
8ef3			 
8ef3 23					inc hl 
8ef4 3e 00				ld a, 0 
8ef6 77					ld (hl),a 
8ef7			 
8ef7			 
8ef7 c9					ret 
8ef8			 
8ef8 .. 00		.iblank: db " ",0 
8efa			 
8efa			 
8efa 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8efd 22 6d ee				ld (input_start), hl 
8f00 3e 01				ld a,1			; add cursor 
8f02 77					ld (hl),a 
8f03 23					inc hl 
8f04 3e 00				ld a,0 
8f06 77					ld (hl),a 
8f07 22 6f ee				ld (input_ptr), hl 
8f0a 7a					ld a,d 
8f0b 32 6c ee				ld (input_size), a 
8f0e 3e 00				ld a,0 
8f10 32 5b ee				ld (input_cursor),a 
8f13			.instr1:	 
8f13			 
8f13					; TODO do block cursor 
8f13					; TODO switch cursor depending on the modifer key 
8f13			 
8f13					; update cursor shape change on key hold 
8f13			 
8f13 2a 6f ee				ld hl, (input_ptr) 
8f16 2b					dec hl 
8f17 3a ca eb				ld a,(cursor_shape) 
8f1a 77					ld (hl), a 
8f1b			 
8f1b					; display entered text 
8f1b 3a 6a ee				ld a,(input_at_pos) 
8f1e cd 19 e2		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f21 ed 5b 6d ee	            	LD   de, (input_start) 
8f25 cd 13 e2		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f28			 
8f28 cd bb e2				call cin 
8f2b fe 00				cp 0 
8f2d 28 e4				jr z, .instr1 
8f2f			 
8f2f					; proecess keyboard controls first 
8f2f			 
8f2f 2a 6f ee				ld hl,(input_ptr) 
8f32			 
8f32 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f34 28 5a				jr z, .instrcr 
8f36			 
8f36 fe 08				cp KEY_BS 	; back space 
8f38 20 0f				jr nz, .instr2 
8f3a					; process back space 
8f3a			 
8f3a					; TODO stop back space if at start of string 
8f3a 2b					dec hl 
8f3b 2b					dec hl ; to over write cursor 
8f3c 3a ca eb				ld a,(cursor_shape) 
8f3f					;ld a,0 
8f3f 77					ld (hl),a 
8f40 23					inc hl 
8f41 3e 20				ld a," " 
8f43 77					ld (hl),a 
8f44 22 6f ee				ld (input_ptr),hl 
8f47					 
8f47			 
8f47 18 ca				jr .instr1 
8f49			 
8f49 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f4b 20 06				jr nz, .instr3 
8f4d 2b					dec hl 
8f4e 22 6f ee				ld (input_ptr),hl 
8f51 18 c0				jr .instr1 
8f53				 
8f53 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f55 20 06				jr nz, .instr4 
8f57 23					inc hl 
8f58 22 6f ee				ld (input_ptr),hl 
8f5b 18 b6				jr .instr1 
8f5d			 
8f5d fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f5f 20 06				jr nz, .instr5 
8f61 2b					dec hl 
8f62 22 6f ee				ld (input_ptr),hl 
8f65 18 ac				jr .instr1 
8f67			 
8f67 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8f69 20 06				jr nz, .instr6 
8f6b 2b					dec hl 
8f6c 22 6f ee				ld (input_ptr),hl 
8f6f 18 a2				jr .instr1 
8f71 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8f73 20 0b				jr nz, .instrnew 
8f75			 
8f75 21 cb e2			ld hl, scratch 
8f78 11 f1 e6			ld de, os_last_cmd 
8f7b cd 99 8f			call strcpy 
8f7e 18 93				jr .instr1 
8f80			 
8f80			 
8f80			.instrnew:	; no special key pressed to see if we have room to store it 
8f80			 
8f80					; TODO do string size test 
8f80			 
8f80 2b					dec hl ; to over write cursor 
8f81 77					ld (hl),a 
8f82 23					inc hl 
8f83 3a ca eb				ld a,(cursor_shape) 
8f86 77					ld (hl),a 
8f87 23					inc hl 
8f88 3e 00				ld a,0 
8f8a 77					ld (hl),a 
8f8b			 
8f8b 22 6f ee				ld (input_ptr),hl 
8f8e					 
8f8e 18 83				jr .instr1 
8f90 2b			.instrcr:	dec hl		; remove cursor 
8f91 3e 20				ld a,' '	; TODO add a trailing space for safety 
8f93 77					ld (hl),a 
8f94 23					inc hl 
8f95 3e 00				ld a,0 
8f97 77					ld (hl),a 
8f98			 
8f98			 
8f98					; if at end of line scroll up    
8f98					; TODO detecting only end of line 4 for scroll up  
8f98			 
8f98					;ld   
8f98			 
8f98 c9					ret 
8f99			 
8f99			 
8f99			; strcpy hl = dest, de source 
8f99			 
8f99 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f9a b7			            OR   A              ;Null terminator? 
8f9b c8			            RET  Z              ;Yes, so finished 
8f9c 1a					ld a,(de) 
8f9d 77					ld (hl),a 
8f9e 13			            INC  DE             ;Point to next character 
8f9f 23					inc hl 
8fa0 18 f7		            JR   strcpy       ;Repeat 
8fa2 c9					ret 
8fa3			 
8fa3			 
8fa3			; TODO string_at  
8fa3			; pass string which starts with lcd offset address and then null term string 
8fa3			 
8fa3			; TODO string to dec 
8fa3			; TODO string to hex 
8fa3			; TODO byte to string hex 
8fa3			; TODO byte to string dec 
8fa3			 
8fa3			 
8fa3			 
8fa3			; from z80uartmonitor 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fa3			; pass hl for where to put the text 
8fa3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fa3 c5			hexout:	PUSH BC 
8fa4 f5					PUSH AF 
8fa5 47					LD B, A 
8fa6					; Upper nybble 
8fa6 cb 3f				SRL A 
8fa8 cb 3f				SRL A 
8faa cb 3f				SRL A 
8fac cb 3f				SRL A 
8fae cd be 8f				CALL tohex 
8fb1 77					ld (hl),a 
8fb2 23					inc hl	 
8fb3					 
8fb3					; Lower nybble 
8fb3 78					LD A, B 
8fb4 e6 0f				AND 0FH 
8fb6 cd be 8f				CALL tohex 
8fb9 77					ld (hl),a 
8fba 23					inc hl	 
8fbb					 
8fbb f1					POP AF 
8fbc c1					POP BC 
8fbd c9					RET 
8fbe					 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8fbe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fbe			tohex: 
8fbe e5					PUSH HL 
8fbf d5					PUSH DE 
8fc0 16 00				LD D, 0 
8fc2 5f					LD E, A 
8fc3 21 cb 8f				LD HL, .DATA 
8fc6 19					ADD HL, DE 
8fc7 7e					LD A, (HL) 
8fc8 d1					POP DE 
8fc9 e1					POP HL 
8fca c9					RET 
8fcb			 
8fcb			.DATA: 
8fcb 30					DEFB	30h	; 0 
8fcc 31					DEFB	31h	; 1 
8fcd 32					DEFB	32h	; 2 
8fce 33					DEFB	33h	; 3 
8fcf 34					DEFB	34h	; 4 
8fd0 35					DEFB	35h	; 5 
8fd1 36					DEFB	36h	; 6 
8fd2 37					DEFB	37h	; 7 
8fd3 38					DEFB	38h	; 8 
8fd4 39					DEFB	39h	; 9 
8fd5 41					DEFB	41h	; A 
8fd6 42					DEFB	42h	; B 
8fd7 43					DEFB	43h	; C 
8fd8 44					DEFB	44h	; D 
8fd9 45					DEFB	45h	; E 
8fda 46					DEFB	46h	; F 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8fdb			;;    subtract $30, if result > 9 then subtract $7 more 
8fdb			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fdb			atohex: 
8fdb d6 30				SUB $30 
8fdd fe 0a				CP 10 
8fdf f8					RET M		; If result negative it was 0-9 so we're done 
8fe0 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8fe2 c9					RET		 
8fe3			 
8fe3			 
8fe3			 
8fe3			 
8fe3			; Get 2 ASCII characters as hex byte from pointer in hl 
8fe3			 
8fe3			BYTERD: 
8fe3 16 00			LD	D,00h		;Set up 
8fe5 cd ed 8f			CALL	HEXCON		;Get byte and convert to hex 
8fe8 87				ADD	A,A		;First nibble so 
8fe9 87				ADD	A,A		;multiply by 16 
8fea 87				ADD	A,A		; 
8feb 87				ADD	A,A		; 
8fec 57				LD	D,A		;Save hi nibble in D 
8fed			HEXCON: 
8fed 7e				ld a, (hl)		;Get next chr 
8fee 23				inc hl 
8fef d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8ff1 fe 0a			CP	00Ah		;Is it 0-9 ? 
8ff3 38 02			JR	C,NALPHA	;If so miss next bit 
8ff5 d6 07			SUB	007h		;Else convert alpha 
8ff7			NALPHA: 
8ff7 b2				OR	D		;Add hi nibble back 
8ff8 c9				RET			; 
8ff9			 
8ff9			 
8ff9			; 
8ff9			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8ff9			; Since the routines get_byte and therefore get_nibble are called, only valid 
8ff9			; characters (0-9a-f) are accepted. 
8ff9			; 
8ff9			;get_word        push    af 
8ff9			;                call    get_byte        ; Get the upper byte 
8ff9			;                ld      h, a 
8ff9			;                call    get_byte        ; Get the lower byte 
8ff9			;                ld      l, a 
8ff9			;                pop     af 
8ff9			;                ret 
8ff9			; 
8ff9			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8ff9			; the routine get_nibble is used only valid characters are accepted - the  
8ff9			; input routine only accepts characters 0-9a-f. 
8ff9			; 
8ff9 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8ffa 7e					ld a,(hl) 
8ffb 23					inc hl 
8ffc cd 21 90		                call    nibble2val      ; Get upper nibble 
8fff cb 07		                rlc     a 
9001 cb 07		                rlc     a 
9003 cb 07		                rlc     a 
9005 cb 07		                rlc     a 
9007 47			                ld      b, a            ; Save upper four bits 
9008 7e					ld a,(hl) 
9009 cd 21 90		                call    nibble2val      ; Get lower nibble 
900c b0			                or      b               ; Combine both nibbles 
900d c1			                pop     bc              ; Restore B (and C) 
900e c9			                ret 
900f			; 
900f			; Get a hexadecimal digit from the serial line. This routine blocks until 
900f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
900f			; to the serial line interface. The lower 4 bits of A contain the value of  
900f			; that particular digit. 
900f			; 
900f			;get_nibble      ld a,(hl)           ; Read a character 
900f			;                call    to_upper        ; Convert to upper case 
900f			;                call    is_hex          ; Was it a hex digit? 
900f			;                jr      nc, get_nibble  ; No, get another character 
900f			 ;               call    nibble2val      ; Convert nibble to value 
900f			 ;               call    print_nibble 
900f			 ;               ret 
900f			; 
900f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
900f			; A valid hexadecimal digit is denoted by a set C flag. 
900f			; 
900f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
900f			;                ret     nc              ; Yes 
900f			;                cp      '0'             ; Less than '0'? 
900f			;                jr      nc, is_hex_1    ; No, continue 
900f			;                ccf                     ; Complement carry (i.e. clear it) 
900f			;                ret 
900f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
900f			;                ret     c               ; Yes 
900f			;                cp      'A'             ; Less than 'A'? 
900f			;                jr      nc, is_hex_2    ; No, continue 
900f			;                ccf                     ; Yes - clear carry and return 
900f			;                ret 
900f			;is_hex_2        scf                     ; Set carry 
900f			;                ret 
900f			; 
900f			; Convert a single character contained in A to upper case: 
900f			; 
900f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
9011 d8			                ret     c 
9012 fe 7b		                cp      'z' + 1         ; > 'z'? 
9014 d0			                ret     nc              ; Nothing to do, either 
9015 e6 5f		                and     $5f             ; Convert to upper case 
9017 c9			                ret 
9018			 
9018			 
9018			to_lower: 
9018			 
9018			   ; if char is in [A-Z] make it lower case 
9018			 
9018			   ; enter : a = char 
9018			   ; exit  : a = lower case char 
9018			   ; uses  : af 
9018			 
9018 fe 41		   cp 'A' 
901a d8			   ret c 
901b			    
901b fe 5b		   cp 'Z'+1 
901d d0			   ret nc 
901e			    
901e f6 20		   or $20 
9020 c9			   ret 
9021			 
9021			; 
9021			; Expects a hexadecimal digit (upper case!) in A and returns the 
9021			; corresponding value in A. 
9021			; 
9021 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
9023 38 02		                jr      c, nibble2val_1 ; Yes 
9025 d6 07		                sub     7               ; Adjust for A-F 
9027 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9029 e6 0f		                and     $f              ; Only return lower 4 bits 
902b c9			                ret 
902c			; 
902c			; Print_nibble prints a single hex nibble which is contained in the lower  
902c			; four bits of A: 
902c			; 
902c			;print_nibble    push    af              ; We won't destroy the contents of A 
902c			;                and     $f              ; Just in case... 
902c			;                add     a, '0'             ; If we have a digit we are done here. 
902c			;                cp      '9' + 1         ; Is the result > 9? 
902c			;                jr      c, print_nibble_1 
902c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
902c			;print_nibble_1  call    putc            ; Print the nibble and 
902c			;                pop     af              ; restore the original value of A 
902c			;                ret 
902c			;; 
902c			;; Send a CR/LF pair: 
902c			; 
902c			;crlf            push    af 
902c			;                ld      a, cr 
902c			;                call    putc 
902c			;                ld      a, lf 
902c			;                call    putc 
902c			;                pop     af 
902c			;                ret 
902c			; 
902c			; Print_word prints the four hex digits of a word to the serial line. The  
902c			; word is expected to be in HL. 
902c			; 
902c			;print_word      push    hl 
902c			;                push    af 
902c			;                ld      a, h 
902c			;                call    print_byte 
902c			;                ld      a, l 
902c			;                call    print_byte 
902c			;                pop     af 
902c			;                pop     hl 
902c			;                ret 
902c			; 
902c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
902c			; The byte to be printed is expected to be in A. 
902c			; 
902c			;print_byte      push    af              ; Save the contents of the registers 
902c			;                push    bc 
902c			;                ld      b, a 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                rrca 
902c			;                call    print_nibble    ; Print high nibble 
902c			;                ld      a, b 
902c			;                call    print_nibble    ; Print low nibble 
902c			;                pop     bc              ; Restore original register contents 
902c			;                pop     af 
902c			;                ret 
902c			 
902c			 
902c			 
902c			 
902c			 
902c			fourehexhl:  
902c 7e				ld a,(hl) 
902d cd db 8f			call atohex 
9030 cb 3f				SRL A 
9032 cb 3f				SRL A 
9034 cb 3f				SRL A 
9036 cb 3f				SRL A 
9038 47				ld b, a 
9039 23				inc hl 
903a 7e				ld a,(hl) 
903b 23				inc hl 
903c cd db 8f			call atohex 
903f 80				add b 
9040 57				ld d,a 
9041 7e				ld a,(hl) 
9042 cd db 8f			call atohex 
9045 cb 3f				SRL A 
9047 cb 3f				SRL A 
9049 cb 3f				SRL A 
904b cb 3f				SRL A 
904d 47				ld b, a 
904e 23				inc hl 
904f 7e				ld a,(hl) 
9050 23				inc hl 
9051 cd db 8f			call atohex 
9054 80				add b 
9055 5f				ld e, a 
9056 d5				push de 
9057 e1				pop hl 
9058 c9				ret 
9059			 
9059			; pass hl. returns z set if the byte at hl is a digit 
9059			;isdigithl:  
9059			;	push bc 
9059			;	ld a,(hl) 
9059			;	cp ':' 
9059			;	jr nc, .isdf 		; > 
9059			;	cp '0' 
9059			;	jr c, .isdf		; < 
9059			; 
9059			;	; TODO find a better way to set z 
9059			; 
9059			;	ld b,a 
9059			;	cp b 
9059			;	pop bc 
9059			;	ret 
9059			; 
9059			;.isdf:	; not digit so clear z 
9059			; 
9059			;	; TODO find a better way to unset z 
9059			; 
9059			;	ld b,a 
9059			;	inc b 
9059			;	cp b 
9059			; 
9059			;	pop bc 
9059			;	ret 
9059				 
9059				 
9059			 
9059			 
9059			; pass hl as the four byte address to load 
9059			 
9059			get_word_hl:  
9059 e5				push hl 
905a cd f9 8f			call get_byte 
905d				 
905d 47				ld b, a 
905e			 
905e e1				pop hl 
905f 23				inc hl 
9060 23				inc hl 
9061			 
9061			; TODO not able to handle a-f  
9061 7e				ld a,(hl) 
9062			;	;cp ':' 
9062			;	cp 'g' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp 'G' 
9062			;	jr nc, .single_byte_hl 		; > 
9062			;	cp '0' 
9062			;	jr c, .single_byte_hl		; < 
9062			 
9062				;call isdigithl 
9062 fe 00			cp 0 
9064 28 06			jr z, .single_byte_hl 
9066			 
9066			.getwhln:   ; hex word so get next byte 
9066			 
9066 cd f9 8f			call get_byte 
9069 6f				ld l, a 
906a 60				ld h,b 
906b c9				ret 
906c 68			.single_byte_hl:   ld l,b 
906d 26 00				ld h,0 
906f c9					ret 
9070			 
9070			 
9070			 
9070			 
9070 21 2b 98			ld hl,asc+1 
9073			;	ld a, (hl) 
9073			;	call nibble2val 
9073 cd f9 8f			call get_byte 
9076			 
9076			;	call fourehexhl 
9076 32 ff e2			ld (scratch+52),a 
9079				 
9079 21 fd e2			ld hl,scratch+50 
907c 22 ee e5			ld (os_cur_ptr),hl 
907f			 
907f c9				ret 
9080			 
9080			 
9080			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
9080			 
9080			; Decimal Unsigned Version 
9080			 
9080			;Number in a to decimal ASCII 
9080			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
9080			;Example: display a=56 as "056" 
9080			;input: a = number 
9080			;Output: a=0,value of a in the screen 
9080			;destroys af,bc (don't know about hl and de) 
9080			DispAToASCII: 
9080 0e 9c			ld	c,-100 
9082 cd 8c 90			call	.Na1 
9085 0e f6			ld	c,-10 
9087 cd 8c 90			call	.Na1 
908a 0e ff			ld	c,-1 
908c 06 2f		.Na1:	ld	b,'0'-1 
908e 04			.Na2:	inc	b 
908f 81				add	a,c 
9090 38 fc			jr	c,.Na2 
9092 91				sub	c		;works as add 100/10/1 
9093 f5				push af		;safer than ld c,a 
9094 78				ld	a,b		;char is in b 
9095			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
9095 f1				pop af		;safer than ld a,c 
9096 c9				ret 
9097			 
9097			; Decimal Signed Version 
9097			 
9097			; DispA 
9097			; -------------------------------------------------------------- 
9097			; Converts a signed integer value to a zero-terminated ASCII 
9097			; string representative of that value (using radix 10). 
9097			; -------------------------------------------------------------- 
9097			; INPUTS: 
9097			;     HL     Value to convert (two's complement integer). 
9097			;     DE     Base address of string destination. (pointer). 
9097			; -------------------------------------------------------------- 
9097			; OUTPUTS: 
9097			;     None 
9097			; -------------------------------------------------------------- 
9097			; REGISTERS/MEMORY DESTROYED 
9097			; AF HL 
9097			; -------------------------------------------------------------- 
9097			 
9097			;DispHLToASCII: 
9097			;   push    de 
9097			;   push    bc 
9097			; 
9097			;; Detect sign of HL. 
9097			;    bit    7, h 
9097			;    jr     z, ._DoConvert 
9097			; 
9097			;; HL is negative. Output '-' to string and negate HL. 
9097			;    ld     a, '-' 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			; 
9097			;; Negate HL (using two's complement) 
9097			;    xor    a 
9097			;    sub    l 
9097			;    ld     l, a 
9097			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
9097			;    sbc    a, h 
9097			;    ld     h, a 
9097			; 
9097			;; Convert HL to digit characters 
9097			;._DoConvert: 
9097			;    ld     b, 0     ; B will count character length of number 
9097			;-   ld     a, 10 
9097			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
9097			;    push   af 
9097			;    inc    b 
9097			;    ld     a, h 
9097			;    or     l 
9097			;    jr     nz, - 
9097			; 
9097			;; Retrieve digits from stack 
9097			;-   pop    af 
9097			;    or     $30 
9097			;    ld     (de), a 
9097			;    inc    de 
9097			;    djnz   - 
9097			; 
9097			;; Terminate string with NULL 
9097			;    xor    a 
9097			;    ld     (de), a 
9097			; 
9097			;    pop    bc 
9097			;    pop    de 
9097			;    ret 
9097			 
9097			;Comments 
9097			; 
9097			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
9097			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
9097			;    Note that the output string will not be fixed-width. 
9097			; 
9097			;Example Usage 
9097			; 
9097			;    ld    hl, -1004 
9097			;    ld    de, OP1 
9097			;    call  DispA 
9097			;    ld    hl, OP1 
9097			;    syscall  PutS 
9097			 
9097			 
9097			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9097			 
9097			 
9097			;Converts an ASCII string to an unsigned 16-bit integer 
9097			;Quits when it reaches a non-decimal digit 
9097			 
9097			string_to_uint16: 
9097			atoui_16: 
9097			;Input: 
9097			;     DE points to the string 
9097			;Outputs: 
9097			;     HL is the result 
9097			;     A is the 8-bit value of the number 
9097			;     DE points to the byte after the number 
9097			;Destroys: 
9097			;     BC 
9097			;       if the string is non-empty, BC is HL/10 
9097			;Size:  24 bytes 
9097			;Speed: 42+d(104+{0,9}) 
9097			;       d is the number of digits in the number 
9097			;       max is 640 cycles for a 5 digit number 
9097			;Assuming no leading zeros: 
9097			;1 digit:  146cc 
9097			;2 digit:  250cc 
9097			;3 digit:  354cc or 363cc (avg: 354.126cc) 
9097			;4 digit:  458cc or 467cc (avg: 458.27cc) 
9097			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
9097			;avg: 544.81158447265625cc (544+13297/16384) 
9097			;=============================================================== 
9097 21 00 00		  ld hl,0 
909a			.u16a: 
909a 1a			  ld a,(de) 
909b d6 30		  sub 30h 
909d fe 0a		  cp 10 
909f d0			  ret nc 
90a0 13			  inc de 
90a1 44			  ld b,h 
90a2 4d			  ld c,l 
90a3 29			  add hl,hl 
90a4 29			  add hl,hl 
90a5 09			  add hl,bc 
90a6 29			  add hl,hl 
90a7 85			  add a,l 
90a8 6f			  ld l,a 
90a9 30 ef		  jr nc,.u16a 
90ab 24			  inc h 
90ac c3 9a 90		  jp .u16a 
90af			 
90af			 
90af			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90af			 
90af			;written by Zeda 
90af			;Converts a 16-bit unsigned integer to an ASCII string. 
90af			 
90af			uitoa_16: 
90af			;Input: 
90af			;   DE is the number to convert 
90af			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90af			;Output: 
90af			;   HL points to the null-terminated ASCII string 
90af			;      NOTE: This isn't necessarily the same as the input HL. 
90af d5			  push de 
90b0 c5			  push bc 
90b1 f5			  push af 
90b2 eb			  ex de,hl 
90b3			 
90b3 01 f0 d8		  ld bc,-10000 
90b6 3e 2f		  ld a,'0'-1 
90b8 3c			  inc a 
90b9 09			  add hl,bc  
90ba 38 fc		   jr c,$-2 
90bc 12			  ld (de),a 
90bd 13			  inc de 
90be			 
90be 01 e8 03		  ld bc,1000 
90c1 3e 3a		  ld a,'9'+1 
90c3 3d			  dec a  
90c4 09			  add hl,bc  
90c5 30 fc		   jr nc,$-2 
90c7 12			  ld (de),a 
90c8 13			  inc de 
90c9			 
90c9 01 9c ff		  ld bc,-100 
90cc 3e 2f		  ld a,'0'-1 
90ce 3c			  inc a  
90cf 09			  add hl,bc  
90d0 38 fc		   jr c,$-2 
90d2 12			  ld (de),a 
90d3 13			  inc de 
90d4			 
90d4 7d			  ld a,l 
90d5 26 3a		  ld h,'9'+1 
90d7 25			  dec h  
90d8 c6 0a		  add a,10  
90da 30 fb		   jr nc,$-3 
90dc c6 30		  add a,'0' 
90de eb			  ex de,hl 
90df 72			  ld (hl),d 
90e0 23			  inc hl 
90e1 77			  ld (hl),a 
90e2 23			  inc hl 
90e3 36 00		  ld (hl),0 
90e5			 
90e5			;Now strip the leading zeros 
90e5 0e fa		  ld c,-6 
90e7 09			  add hl,bc 
90e8 3e 30		  ld a,'0' 
90ea 23			  inc hl  
90eb be			  cp (hl)  
90ec 28 fc		  jr z,$-2 
90ee			 
90ee			;Make sure that the string is non-empty! 
90ee 7e			  ld a,(hl) 
90ef b7			  or a 
90f0 20 01		  jr nz,.atoub 
90f2 2b			  dec hl 
90f3			.atoub: 
90f3			 
90f3 f1			  pop af 
90f4 c1			  pop bc 
90f5 d1			  pop de 
90f6 c9			  ret 
90f7			 
90f7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
90f7			 
90f7			toUpper: 
90f7			;A is the char. 
90f7			;If A is a lowercase letter, this sets it to the matching uppercase 
90f7			;18cc or 30cc or 41cc 
90f7			;avg: 26.75cc 
90f7 fe 61		  cp 'a' 
90f9 d8			  ret c 
90fa fe 7b		  cp 'z'+1 
90fc d0			  ret nc 
90fd d6 20		  sub 'a'-'A' 
90ff c9			  ret 
9100			 
9100			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9100			 
9100			; String Length 
9100			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9100			 
9100			; Get the length of the null-terminated string starting at $8000 hl 
9100			;    LD     HL, $8000 
9100			 
9100			strlenz: 
9100			 
9100 af			    XOR    A               ; Zero is the value we are looking for. 
9101 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9102 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9103			                           ; 65, 536 bytes (the entire addressable memory space). 
9103 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9105			 
9105			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9105 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9106 6f			    LD     L, A             ; number of bytes 
9107 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9109 2b			    DEC    HL              ; Compensate for null. 
910a c9				ret 
910b			 
910b			; Get the length of the A terminated string starting at $8000 hl 
910b			;    LD     HL, $8000 
910b			 
910b			strlent: 
910b			 
910b			                  ; A is the value we are looking for. 
910b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
910d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
910f			                           ; 65, 536 bytes (the entire addressable memory space). 
910f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9111			 
9111			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9111 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9113 2e 00		    LD     L, 0             ; number of bytes 
9115 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9117 2b			    DEC    HL              ; Compensate for null. 
9118 c9				ret 
9119			 
9119			 
9119			;Comparing Strings 
9119			 
9119			;IN    HL     Address of string1. 
9119			;      DE     Address of string2. 
9119			 
9119			; doc given but wrong??? 
9119			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9119			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9119			; tested 
9119			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9119			 
9119			strcmp_old: 
9119 e5			    PUSH   HL 
911a d5			    PUSH   DE 
911b			 
911b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
911c be			    CP     (HL)            ; (want to minimize work). 
911d 38 01		    JR     C, Str1IsBigger 
911f 7e			    LD     A, (HL) 
9120			 
9120			Str1IsBigger: 
9120 4f			    LD     C, A             ; Put length in BC 
9121 06 00		    LD     B, 0 
9123 13			    INC    DE              ; Increment pointers to meat of string. 
9124 23			    INC    HL 
9125			 
9125			CmpLoop: 
9125 1a			    LD     A, (DE)          ; Compare bytes. 
9126 ed a1		    CPI 
9128 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
912a 13			    INC    DE              ; Update pointer. 
912b ea 25 91		    JP     PE, CmpLoop 
912e			 
912e d1			    POP    DE 
912f e1			    POP    HL 
9130 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9131 be			    CP     (HL) 
9132 c9			    RET 
9133			 
9133			NoMatch: 
9133 2b			    DEC    HL 
9134 be			    CP     (HL)            ; Compare again to affect carry. 
9135 d1			    POP    DE 
9136 e1			    POP    HL 
9137 c9			    RET 
9138			 
9138			;; test strmp 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr z, .z1 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z1: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr z, .z2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "NZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.z2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "ZZ2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str2 
9138			;call strcmp 
9138			;jr c, .c1 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c1: 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc1" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			; 
9138			;ld de, .str1 
9138			;ld hl, .str1 
9138			;call strcmp 
9138			;jr c, .c2 
9138			;;this 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "Nc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;.c2: 
9138			; 
9138			;	if DEBUG_FORTH_WORDS 
9138			;		DMARK "cc2" 
9138			;		CALLMONITOR 
9138			;	endif 
9138			;	NEXTW 
9138			;.str1:   db "string1",0 
9138			;.str2:   db "string2",0 
9138			 
9138			; only care about direct match or not 
9138			; hl and de strings 
9138			; zero set if the same 
9138			 
9138			strcmp: 
9138 1a				ld a, (de) 
9139 be				cp (hl) 
913a 28 02			jr z, .ssame 
913c b7				or a 
913d c9				ret 
913e			 
913e			.ssame:  
913e fe 00			cp 0 
9140 c8				ret z 
9141			 
9141 23				inc hl 
9142 13				inc de 
9143 18 f3			jr strcmp 
9145				 
9145				 
9145			 
9145			 
9145			 
9145			 
9145			; eof 
9145			 
9145			 
9145			 
9145			 
9145			 
9145			 
# End of file firmware_strings.asm
9145			include "firmware_memory.asm"   ; malloc and free  
9145			 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			.mallocsize: db "Wants malloc >256",0 
9145			.mallocasize: db "MALLOC gives >256",0 
9145			.malloczero: db "MALLOC gives zero",0 
9145			 
9145			malloc_guard_zerolen: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145				ld de, 0 
9145			        call cmp16 
9145				jr nz, .lowalloz 
9145			 
9145				push hl 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .malloczero 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145			.lowalloz: 
9145			 
9145			 
9145				pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_entry: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowalloc 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocsize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145			 
9145				pop de 
9145				pop hl 
9145			 
9145				 
9145			 
9145				CALLMONITOR 
9145				jr .lowdone 
9145			.lowalloc: 
9145			 
9145			 
9145				pop hl 
9145			.lowdone:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			 
9145			malloc_guard_exit: 
9145				push hl 
9145				push de 
9145				push af 
9145			 
9145			 	or a      ;clear carry flag 
9145				push hl 
9145				ld de, 255 
9145				sbc hl, de 
9145				jr c, .lowallocx 
9145			 
9145				push de 
9145					ld hl, display_fb0 
9145					ld (display_fb_active), hl 
9145				call clear_display 
9145				ld a, 0 
9145				ld de, .mallocasize 
9145				call str_at_display 
9145				call update_display 
9145				call delay1s 
9145				call delay1s 
9145				ld a, 0 
9145				ld (os_view_disable), a 
9145				pop de 
9145				pop hl 
9145			 
9145				CALLMONITOR 
9145				jr .lowdonex 
9145			.lowallocx: 
9145			 
9145				pop hl 
9145			.lowdonex:	pop af 
9145				pop de 
9145				pop hl 
9145			ret 
9145			endif 
9145			 
9145			if MALLOC_2 
9145			; Z80 Malloc and Free Functions 
9145			 
9145			; Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc: 
9145				 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_entry 
9145			endif 
9145			 
9145			 
9145			 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "mal" 
9145						CALLMONITOR 
9145					endif 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of size into A 
9145			    or h               ; Check if size is zero 
9145			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
9145			 
9145			    ; Allocate memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma1" 
9145						CALLMONITOR 
9145					endif 
9145			    call malloc_internal ; Call internal malloc function 
9145			    pop af             ; Restore AF register 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret                ; Return 
9145			 
9145			; Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free: 
9145			    push af            ; Save AF register 
9145			    ld a, l            ; Load low byte of pointer into A 
9145			    or h               ; Check if pointer is NULL 
9145			    jp z, free_exit    ; If pointer is NULL, exit 
9145			 
9145			    ; Free memory 
9145			    ld hl, (heap_start) ; Load start of heap into HL 
9145			    call free_internal  ; Call internal free function 
9145			    pop af             ; Restore AF register 
9145			    ret                ; Return 
9145			 
9145			; Internal Malloc Function: 
9145			; Input: 
9145			;   HL: Size of block to allocate 
9145			; Output: 
9145			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
9145			 
9145			malloc_internal: 
9145			    ld bc, 2           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to requested size 
9145			    ex de, hl          ; Save total size in DE, and keep it in HL 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			 
9145			    ; Search for free memory block 
9145			    ld de, (heap_end)  ; Load end of heap into DE 
9145			    ld bc, 0           ; Initialize counter 
9145			 
9145					if DEBUG_FORTH_MALLOC 
9145						DMARK "ma2" 
9145						CALLMONITOR 
9145					endif 
9145			malloc_search_loop: 
9145			    ; Check if current block is free 
9145			    ld a, (hl)         ; Load current block's status (free or used) 
9145			    cp 0               ; Compare with zero (free) 
9145			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
9145			 
9145			    ; Check if current block is large enough 
9145			    ld a, (hl+1)       ; Load high byte of block size 
9145			    cp l               ; Compare with low byte of requested size 
9145			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
9145			 
9145			    ld a, (hl+2)       ; Load low byte of block size 
9145			    cp h               ; Compare with high byte of requested size 
9145			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
9145			 
9145			    ; Mark block as used 
9145			    ld (hl), 0xFF      ; Set status byte to indicate used block 
9145			 
9145			    ; Calculate remaining space in block 
9145			    ld bc, 0           ; Clear BC 
9145			    add hl, bc         ; Increment HL to point to start of data block 
9145			    add hl, de         ; HL = HL + DE (total size) 
9145			    ld bc, 1           ; Number of bytes to allocate for management overhead 
9145			    add hl, bc         ; Add management overhead to start of data block 
9145			 
9145			    ; Save pointer to allocated block in HL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma5" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			malloc_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3           ; Size of management overhead 
9145			    add hl, bc         ; Move to the next block 
9145			    inc de             ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e            ; Load low byte of heap end address 
9145			    cp (hl)            ; Compare with low byte of current address 
9145			    jr nz, malloc_search_loop  ; If not equal, continue searching 
9145			    ld a, d            ; Load high byte of heap end address 
9145			    cp 0               ; Check if it's zero (end of memory) 
9145			    jr nz, malloc_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, allocation failed 
9145			    xor a              ; Set result to NULL 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma6" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			malloc_exit: 
9145			if DEBUG_FORTH_MALLOC_HIGH 
9145						DMARK "ma7" 
9145			call malloc_guard_exit 
9145			call malloc_guard_zerolen 
9145			endif 
9145			    ret 
9145			 
9145			; Internal Free Function: 
9145			; Input: 
9145			;   HL: Pointer to memory block to free 
9145			; Output: 
9145			;   None 
9145			 
9145			free_internal: 
9145			    ld de, (heap_start) ; Load start of heap into DE 
9145			    ld bc, 0            ; Initialize counter 
9145			 
9145			free_search_loop: 
9145			    ; Check if current block contains the pointer 
9145			    ld a, l             ; Load low byte of pointer 
9145			    cp (hl+1)           ; Compare with high byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			    ld a, h             ; Load high byte of pointer 
9145			    cp (hl+2)           ; Compare with low byte of current block's address 
9145			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
9145			 
9145			    ; Mark block as free 
9145			    ld (hl), 0          ; Set status byte to indicate free block 
9145			    ret                 ; Return 
9145			 
9145			free_skip_block_check: 
9145			    ; Move to the next block 
9145			    ld bc, 3            ; Size of management overhead 
9145			    add hl, bc          ; Move to the next block 
9145			    inc de              ; Increment counter 
9145			 
9145			    ; Check if we have reached the end of heap 
9145			    ld a, e             ; Load low byte of heap end address 
9145			    cp (hl)             ; Compare with low byte of current address 
9145			    jr nz, free_search_loop  ; If not equal, continue searching 
9145			    ld a, d             ; Load high byte of heap end address 
9145			    cp 0                ; Check if it's zero (end of memory) 
9145			    jr nz, free_search_loop  ; If not zero, continue searching 
9145			 
9145			    ; If we reached here, pointer is not found in heap 
9145			    ret 
9145			 
9145			free_exit: 
9145			    ret                 ; Return 
9145			 
9145			; Define heap start and end addresses 
9145			;heap_start:    .dw 0xC000   ; Start of heap 
9145			;heap_end:      .dw 0xE000   ; End of heap 
9145			 
9145			endif 
9145			 
9145			 
9145			if MALLOC_1 
9145			 
9145			 
9145			 
9145			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
9145			 
9145			;moved to firmware.asm 
9145			;heap_start        .equ  0x9000      ; Starting address of heap 
9145			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9145			 
9145			;      .org 0 
9145			;      jp    main 
9145			 
9145			 
9145			;      .org  0x100 
9145			;main: 
9145			;      ld    HL, 0x8100 
9145			;      ld    SP, HL 
9145			; 
9145			;      call  heap_init 
9145			; 
9145			;      ; Make some allocations 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9004 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9014 
9145			; 
9145			;      ld    HL, 12 
9145			;      call  malloc            ; Allocates 0x9024 
9145			; 
9145			;      ; Free some allocations 
9145			;      ld    HL, 0x9014 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9004 
9145			;      call  free 
9145			; 
9145			;      ld    HL, 0x9024 
9145			;      call  free 
9145			; 
9145			; 
9145			;      halt 
9145			 
9145			 
9145			;------------------------------------------------------------------------------ 
9145			;     heap_init                                                               : 
9145			;                                                                             : 
9145			; Description                                                                 : 
9145			;     Initialise the heap and make it ready for malloc and free operations.   : 
9145			;                                                                             : 
9145			;     The heap is maintained as a linked list, starting with an initial       : 
9145			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9145			;     the first free block in the heap. Each block then points to the next    : 
9145			;     free block within the heap, and the free list ends at the first block   : 
9145			;     with a null pointer to the next free block.                             : 
9145			;                                                                             : 
9145			; Parameters                                                                  : 
9145			;     Inputs are compile-time only. Two defines which specify the starting    : 
9145			;     address of the heap and its size are required, along with a memory      : 
9145			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9145			;     principally stores a pointer to the first free block in the heap.       : 
9145			;                                                                             : 
9145			; Returns                                                                     : 
9145			;     Nothing                                                                 : 
9145			;------------------------------------------------------------------------------ 
9145			heap_init: 
9145 e5			      push  HL 
9146			 
9146			      ; Initialise free list struct 
9146 21 d9 e2		      ld    HL, heap_start 
9149 22 d4 e2		      ld    (free_list), HL 
914c 21 00 00		      ld    HL, 0 
914f 22 d6 e2		      ld    (free_list+2), HL 
9152			 
9152			      ; Insert first free block at bottom of heap, consumes entire heap 
9152 21 ad e2		      ld    HL, heap_start+heap_size-4 
9155 22 d9 e2		      ld    (heap_start), HL        ; Next block (end of free list) 
9158 21 d4 ff		      ld    HL, heap_size-4 
915b 22 db e2		      ld    (heap_start+2), HL      ; Block size 
915e			 
915e			      ; Insert end of free list block at top of heap - two null words will 
915e			      ; terminate the free list 
915e 21 00 00		      ld    HL, 0 
9161 22 af e2		      ld    (heap_start+heap_size-2), HL 
9164 22 ad e2		      ld    (heap_start+heap_size-4), HL 
9167			 
9167 e1			      pop   HL 
9168			 
9168 c9			      ret 
9169			 
9169			 
9169			;------------------------------------------------------------------------------ 
9169			;     malloc                                                                  : 
9169			;                                                                             : 
9169			; Description                                                                 : 
9169			;     Allocates the wanted space from the heap and returns the address of the : 
9169			;     first useable byte of the allocation.                                   : 
9169			;                                                                             : 
9169			;     Allocations can happen in one of two ways:                              : 
9169			;                                                                             : 
9169			;     1. A free block may be found which is the exact size wanted. In this    : 
9169			;        case the block is removed from the free list and retuedn to the      : 
9169			;        caller.                                                              : 
9169			;     2. A free block may be found which is larger than the size wanted. In   : 
9169			;        this case, the larger block is split into two. The first portion of  : 
9169			;        this block will become the requested space by the malloc call and    : 
9169			;        is returned to the caller. The second portion becomes a new free     : 
9169			;        block, and the free list is adjusted to maintain continuity via this : 
9169			;        newly created block.                                                 : 
9169			;                                                                             : 
9169			;     malloc does not set any initial value in the allocated space, the       : 
9169			;     caller is required to do this as required.                              : 
9169			;                                                                             : 
9169			;     This implementation of malloc uses the stack exclusively, and is        : 
9169			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9169			;     advisable to disable interrupts before calling malloc, and recommended  : 
9169			;     to avoid the use of malloc inside ISRs in general.                      : 
9169			;                                                                             : 
9169			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9169			;                                                                             : 
9169			; Parameters                                                                  : 
9169			;     HL  Number of bytes wanted                                              : 
9169			;                                                                             : 
9169			; Returns                                                                     : 
9169			;     HL  Address of the first useable byte of the allocation                 : 
9169			;                                                                             : 
9169			; Flags                                                                       : 
9169			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9169			;                                                                             : 
9169			; Stack frame                                                                 : 
9169			;       |             |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     BC      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     DE      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |     IX      |                                                       : 
9169			;       +-------------+                                                       : 
9169			;       |  prev_free  |                                                       : 
9169			;   +4  +-------------+                                                       : 
9169			;       |  this_free  |                                                       : 
9169			;   +2  +-------------+                                                       : 
9169			;       |  next_free  |                                                       : 
9169			;   +0  +-------------+                                                       : 
9169			;       |             |                                                       : 
9169			;                                                                             : 
9169			;------------------------------------------------------------------------------ 
9169			 
9169			 
9169			;malloc: 
9169			; 
9169			;	SAVESP ON 1 
9169			; 
9169			;	call malloc_code 
9169			; 
9169			;	CHECKSP ON 1 
9169			;	ret 
9169			 
9169			 
9169			malloc: 
9169 c5			      push  BC 
916a d5			      push  DE 
916b dd e5		      push  IX 
916d			if DEBUG_FORTH_MALLOC_HIGH 
916d			call malloc_guard_entry 
916d			endif 
916d			 
916d					if DEBUG_FORTH_MALLOC 
916d						DMARK "mal" 
916d						CALLMONITOR 
916d					endif 
916d 7c			      ld    A, H                    ; Exit if no space requested 
916e b5			      or    L 
916f ca 2e 92		      jp    Z, malloc_early_exit 
9172			 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			; 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			;inc hl 
9172			 
9172			 
9172			 
9172			 
9172					if DEBUG_FORTH_MALLOC 
9172						DMARK "maA" 
9172						CALLMONITOR 
9172					endif 
9172			      ; Set up stack frame 
9172 eb			      ex    DE, HL 
9173 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9176 39			      add   HL, SP 
9177 f9			      ld    SP, HL 
9178 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
917c dd 39		      add   IX, SP 
917e			 
917e			      ; Setup initial state 
917e 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
9181 19			      add   HL, DE 
9182			 
9182 44			      ld    B, H                    ; Move want to BC 
9183 4d			      ld    C, L 
9184			 
9184 21 d4 e2		      ld    HL, free_list           ; Store prev_free ptr to stack 
9187 dd 75 04		      ld    (IX+4), L 
918a dd 74 05		      ld    (IX+5), H 
918d			 
918d 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
918e 23			      inc   HL 
918f 56			      ld    D, (HL) 
9190 dd 73 02		      ld    (IX+2), E 
9193 dd 72 03		      ld    (IX+3), D 
9196 eb			      ex    DE, HL                  ; this_free ptr into HL 
9197			 
9197					if DEBUG_FORTH_MALLOC 
9197						DMARK "maB" 
9197						CALLMONITOR 
9197					endif 
9197			      ; Loop through free block list to find some space 
9197			malloc_find_space: 
9197 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9198 23			      inc   HL 
9199 56			      ld    D, (HL) 
919a			 
919a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
919b b3			      or    E 
919c ca 28 92		      jp    Z, malloc_no_space 
919f			 
919f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91a2 dd 72 01		      ld    (IX+1), D 
91a5			 
91a5			      ; Does this block have enough space to make the allocation? 
91a5 23			      inc   HL                      ; Load free block size into DE 
91a6 5e			      ld    E, (HL) 
91a7 23			      inc   HL 
91a8 56			      ld    D, (HL) 
91a9			 
91a9 eb			      ex    DE, HL                  ; Check size of block against want 
91aa b7			      or    A                       ; Ensure carry flag clear 
91ab ed 42		      sbc   HL, BC 
91ad e5			      push  HL                      ; Store the result for later (new block size) 
91ae			 
91ae ca fd 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91b1 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91b3			 
91b3			      ; this_free block is not big enough, setup ptrs to test next free block 
91b3 e1			      pop   HL                      ; Discard previous result 
91b4			 
91b4 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91b7 dd 66 03		      ld    H, (IX+3) 
91ba dd 75 04		      ld    (IX+4), L 
91bd dd 74 05		      ld    (IX+5), H 
91c0			 
91c0 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91c3 dd 66 01		      ld    H, (IX+1) 
91c6 dd 75 02		      ld    (IX+2), L 
91c9 dd 74 03		      ld    (IX+3), H 
91cc			 
91cc					if DEBUG_FORTH_MALLOC 
91cc						DMARK "MA>" 
91cc						CALLMONITOR 
91cc					endif 
91cc 18 c9		      jr    malloc_find_space 
91ce			 
91ce			      ; split a bigger block into two - requested size and remaining size 
91ce			malloc_alloc_split: 
91ce					if DEBUG_FORTH_MALLOC 
91ce						DMARK "MAs" 
91ce						CALLMONITOR 
91ce					endif 
91ce eb			      ex    DE, HL                  ; Calculate address of new free block 
91cf 2b			      dec   HL 
91d0 2b			      dec   HL 
91d1 2b			      dec   HL 
91d2 09			      add   HL, BC 
91d3			 
91d3			      ; Create a new block and point it at next_free 
91d3 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
91d6 dd 56 01		      ld    D, (IX+1) 
91d9			 
91d9 73			      ld    (HL), E                 ; Store next_free ptr into new block 
91da 23			      inc   HL 
91db 72			      ld    (HL), D 
91dc			 
91dc d1			      pop   DE                      ; Store size of new block into new block 
91dd 23			      inc   HL 
91de 73			      ld    (HL), E 
91df 23			      inc   HL 
91e0 72			      ld    (HL), D 
91e1			 
91e1			      ; Update this_free ptr to point to new block 
91e1 2b			      dec   HL 
91e2 2b			      dec   HL 
91e3 2b			      dec   HL 
91e4			 
91e4 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91e7 dd 56 03		      ld    D, (IX+3) 
91ea			 
91ea dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91ed dd 74 03		      ld    (IX+3), H 
91f0			 
91f0			      ; Modify this_free block to be allocation 
91f0 eb			      ex    DE, HL 
91f1 af			      xor   A                       ; Null the next block ptr of allocated block 
91f2 77			      ld    (HL), A 
91f3 23			      inc   HL 
91f4 77			      ld    (HL), A 
91f5			 
91f5 23			      inc   HL                      ; Store want size into allocated block 
91f6 71			      ld    (HL), C 
91f7 23			      inc   HL 
91f8 70			      ld    (HL), B 
91f9 23			      inc   HL 
91fa e5			      push  HL                      ; Address of allocation to return 
91fb			 
91fb 18 19		      jr    malloc_update_links 
91fd			 
91fd			malloc_alloc_fit: 
91fd e1			      pop   HL                      ; Dont need new block size, want is exact fit 
91fe			 
91fe					if DEBUG_FORTH_MALLOC 
91fe						DMARK "MAf" 
91fe						CALLMONITOR 
91fe					endif 
91fe			      ; Modify this_free block to be allocation 
91fe eb			      ex    DE, HL 
91ff 2b			      dec   HL 
9200 2b			      dec   HL 
9201 2b			      dec   HL 
9202			 
9202 af			      xor   A                       ; Null the next block ptr of allocated block 
9203 77			      ld    (HL), A 
9204 23			      inc   HL 
9205 77			      ld    (HL), A 
9206			 
9206 23			      inc   HL                      ; Store address of allocation to return 
9207 23			      inc   HL 
9208 23			      inc   HL 
9209 e5			      push  HL 
920a			 
920a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
920a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
920d dd 66 01		      ld    H, (IX+1) 
9210			 
9210 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9213 dd 74 03		      ld    (IX+3), H 
9216			 
9216			 
9216			malloc_update_links: 
9216			      ; Update prev_free ptr to point to this_free 
9216 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9219 dd 66 05		      ld    H, (IX+5) 
921c			 
921c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
921f dd 56 03		      ld    D, (IX+3) 
9222			 
9222 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9223 23			      inc   HL 
9224 72			      ld    (HL), D 
9225			 
9225					if DEBUG_FORTH_MALLOC 
9225						DMARK "Mul" 
9225						CALLMONITOR 
9225					endif 
9225			      ; Clear the Z flag to indicate successful allocation 
9225 7a			      ld    A, D 
9226 b3			      or    E 
9227			 
9227 d1			      pop   DE                      ; Address of allocation 
9228					if DEBUG_FORTH_MALLOC 
9228						DMARK "MAu" 
9228						CALLMONITOR 
9228					endif 
9228			 
9228			malloc_no_space: 
9228 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
922b 39			      add   HL, SP 
922c f9			      ld    SP, HL 
922d			 
922d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAN" 
922e						CALLMONITOR 
922e					endif 
922e			 
922e			malloc_early_exit: 
922e					if DEBUG_FORTH_MALLOC 
922e						DMARK "MAx" 
922e						CALLMONITOR 
922e					endif 
922e dd e1		      pop   IX 
9230 d1			      pop   DE 
9231 c1			      pop   BC 
9232			 
9232			if DEBUG_FORTH_MALLOC_HIGH 
9232			call malloc_guard_exit 
9232			call malloc_guard_zerolen 
9232			endif 
9232 c9			      ret 
9233			 
9233			 
9233			;------------------------------------------------------------------------------ 
9233			;     free                                                                    : 
9233			;                                                                             : 
9233			; Description                                                                 : 
9233			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9233			;     returned by malloc, otherwise the behaviour is undefined.               : 
9233			;                                                                             : 
9233			;     Where possible, directly adjacent free blocks will be merged together   : 
9233			;     into larger blocks to help ensure that the heap does not become         : 
9233			;     excessively fragmented.                                                 : 
9233			;                                                                             : 
9233			;     free does not clear or set any other value into the freed space, and    : 
9233			;     therefore its contents may be visible through subsequent malloc's. The  : 
9233			;     caller should clear the freed space as required.                        : 
9233			;                                                                             : 
9233			;     This implementation of free uses the stack exclusively, and is          : 
9233			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9233			;     advisable to disable interrupts before calling free, and recommended    : 
9233			;     to avoid the use of free inside ISRs in general.                        : 
9233			;                                                                             : 
9233			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9233			;                                                                             : 
9233			; Parameters                                                                  : 
9233			;     HL  Pointer to address of first byte of allocation to be freed          : 
9233			;                                                                             : 
9233			; Returns                                                                     : 
9233			;     Nothing                                                                 : 
9233			;                                                                             : 
9233			; Stack frame                                                                 : 
9233			;       |             |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     BC      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     DE      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |     IX      |                                                       : 
9233			;       +-------------+                                                       : 
9233			;       |  prev_free  |                                                       : 
9233			;   +2  +-------------+                                                       : 
9233			;       |  next_free  |                                                       : 
9233			;   +0  +-------------+                                                       : 
9233			;       |             |                                                       : 
9233			;                                                                             : 
9233			;------------------------------------------------------------------------------ 
9233			free: 
9233 c5			      push  BC 
9234 d5			      push  DE 
9235 dd e5		      push  IX 
9237			 
9237 7c			      ld    A, H                    ; Exit if ptr is null 
9238 b5			      or    L 
9239 ca fd 92		      jp    Z, free_early_exit 
923c			 
923c			      ; Set up stack frame 
923c eb			      ex    DE, HL 
923d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9240 39			      add   HL, SP 
9241 f9			      ld    SP, HL 
9242 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9246 dd 39		      add   IX, SP 
9248			 
9248			      ; The address in HL points to the start of the useable allocated space, 
9248			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9248			      ; address of the block itself. 
9248 eb			      ex    DE, HL 
9249 11 fc ff		      ld    DE, -4 
924c 19			      add   HL, DE 
924d			 
924d			      ; An allocated block must have a null next block pointer in it 
924d 7e			      ld    A, (HL) 
924e 23			      inc   HL 
924f b6			      or    (HL) 
9250 c2 f8 92		      jp    NZ, free_done 
9253			 
9253 2b			      dec   HL 
9254			 
9254 44			      ld    B, H                    ; Copy HL to BC 
9255 4d			      ld    C, L 
9256			 
9256			      ; Loop through the free list to find the first block with an address 
9256			      ; higher than the block being freed 
9256 21 d4 e2		      ld    HL, free_list 
9259			 
9259			free_find_higher_block: 
9259 5e			      ld    E, (HL)                 ; Load next ptr from free block 
925a 23			      inc   HL 
925b 56			      ld    D, (HL) 
925c 2b			      dec   HL 
925d			 
925d dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9260 dd 72 01		      ld    (IX+1), D 
9263 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9266 dd 74 03		      ld    (IX+3), H 
9269			 
9269 78			      ld    A, B                    ; Check if DE is greater than BC 
926a ba			      cp    D                       ; Compare MSB first 
926b 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
926d 30 04		      jr    NC, free_find_higher_block_skip 
926f 79			      ld    A, C 
9270 bb			      cp    E                       ; Then compare LSB 
9271 38 08		      jr    C, free_found_higher_block 
9273			 
9273			free_find_higher_block_skip: 
9273 7a			      ld    A, D                    ; Reached the end of the free list? 
9274 b3			      or    E 
9275 ca f8 92		      jp    Z, free_done 
9278			 
9278 eb			      ex    DE, HL 
9279			 
9279 18 de		      jr    free_find_higher_block 
927b			 
927b			free_found_higher_block: 
927b			      ; Insert freed block between prev and next free blocks 
927b 71			      ld    (HL), C                 ; Point prev free block to freed block 
927c 23			      inc   HL 
927d 70			      ld    (HL), B 
927e			 
927e 60			      ld    H, B                    ; Point freed block at next free block 
927f 69			      ld    L, C 
9280 73			      ld    (HL), E 
9281 23			      inc   HL 
9282 72			      ld    (HL), D 
9283			 
9283			      ; Check if the freed block is adjacent to the next free block 
9283 23			      inc   HL                      ; Load size of freed block into HL 
9284 5e			      ld    E, (HL) 
9285 23			      inc   HL 
9286 56			      ld    D, (HL) 
9287 eb			      ex    DE, HL 
9288			 
9288 09			      add   HL, BC                  ; Add addr of freed block and its size 
9289			 
9289 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
928c dd 56 01		      ld    D, (IX+1) 
928f			 
928f b7			      or    A                       ; Clear the carry flag 
9290 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9292 20 22		      jr    NZ, free_check_adjacent_to_prev 
9294			 
9294			      ; Freed block is adjacent to next, merge into one bigger block 
9294 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
9295 5e			      ld    E, (HL) 
9296 23			      inc   HL 
9297 56			      ld    D, (HL) 
9298 e5			      push  HL                      ; Save ptr to next block for later 
9299			 
9299 60			      ld    H, B                    ; Store ptr from next block into freed block 
929a 69			      ld    L, C 
929b 73			      ld    (HL), E 
929c 23			      inc   HL 
929d 72			      ld    (HL), D 
929e			 
929e e1			      pop   HL                      ; Restore ptr to next block 
929f 23			      inc   HL                      ; Load size of next block into DE 
92a0 5e			      ld    E, (HL) 
92a1 23			      inc   HL 
92a2 56			      ld    D, (HL) 
92a3 d5			      push  DE                      ; Save next block size for later 
92a4			 
92a4 60			      ld    H, B                    ; Load size of freed block into HL 
92a5 69			      ld    L, C 
92a6 23			      inc   HL 
92a7 23			      inc   HL 
92a8 5e			      ld    E, (HL) 
92a9 23			      inc   HL 
92aa 56			      ld    D, (HL) 
92ab eb			      ex    DE, HL 
92ac			 
92ac d1			      pop   DE                      ; Restore size of next block 
92ad 19			      add   HL, DE                  ; Add sizes of both blocks 
92ae eb			      ex    DE, HL 
92af			 
92af 60			      ld    H, B                    ; Store new bigger size into freed block 
92b0 69			      ld    L, C 
92b1 23			      inc   HL 
92b2 23			      inc   HL 
92b3 73			      ld    (HL), E 
92b4 23			      inc   HL 
92b5 72			      ld    (HL), D 
92b6			 
92b6			free_check_adjacent_to_prev: 
92b6			      ; Check if the freed block is adjacent to the prev free block 
92b6 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92b9 dd 66 03		      ld    H, (IX+3) 
92bc			 
92bc 23			      inc   HL                      ; Size of prev free block into DE 
92bd 23			      inc   HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 2b			      dec   HL 
92c2 2b			      dec   HL 
92c3 2b			      dec   HL 
92c4			 
92c4 19			      add   HL, DE                  ; Add prev block addr and size 
92c5			 
92c5 b7			      or    A                       ; Clear the carry flag 
92c6 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92c8 20 2e		      jr    NZ, free_done 
92ca			 
92ca			      ; Freed block is adjacent to prev, merge into one bigger block 
92ca 60			      ld    H, B                    ; Load next ptr from freed block into DE 
92cb 69			      ld    L, C 
92cc 5e			      ld    E, (HL) 
92cd 23			      inc   HL 
92ce 56			      ld    D, (HL) 
92cf e5			      push  HL                      ; Save freed block ptr for later 
92d0			 
92d0 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92d3 dd 66 03		      ld    H, (IX+3) 
92d6 73			      ld    (HL), E 
92d7 23			      inc   HL 
92d8 72			      ld    (HL), D 
92d9			 
92d9 e1			      pop   HL                      ; Restore freed block ptr 
92da 23			      inc   HL                      ; Load size of freed block into DE 
92db 5e			      ld    E, (HL) 
92dc 23			      inc   HL 
92dd 56			      ld    D, (HL) 
92de d5			      push  DE                      ; Save freed block size for later 
92df			 
92df dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
92e2 dd 66 03		      ld    H, (IX+3) 
92e5 23			      inc   HL 
92e6 23			      inc   HL 
92e7 5e			      ld    E, (HL) 
92e8 23			      inc   HL 
92e9 56			      ld    D, (HL) 
92ea			 
92ea e1			      pop   HL                      ; Add sizes of both blocks 
92eb 19			      add   HL, DE 
92ec eb			      ex    DE, HL 
92ed			 
92ed dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
92f0 dd 66 03		      ld    H, (IX+3) 
92f3 23			      inc   HL 
92f4 23			      inc   HL 
92f5 73			      ld    (HL), E 
92f6 23			      inc   HL 
92f7 72			      ld    (HL), D 
92f8			 
92f8			free_done: 
92f8 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
92fb 39			      add   HL, SP 
92fc f9			      ld    SP, HL 
92fd			 
92fd			free_early_exit: 
92fd dd e1		      pop   IX 
92ff d1			      pop   DE 
9300 c1			      pop   BC 
9301			 
9301 c9			      ret 
9302			 
9302			; moved to firmware.asm 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			;                  .dw   0 
9302			 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_3 
9302			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9302			;heap_start        .equ  0x9000      ; Starting address of heap 
9302			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9302			; 
9302			 ;     .org 0 
9302			  ;    jp    main 
9302			; 
9302			; 
9302			 ;     .org  0x100 
9302			;main: 
9302			 ;     ld    HL, 0x8100 
9302			  ;    ld    SP, HL 
9302			; 
9302			;      call  heap_init 
9302			 
9302			      ; Make some allocations 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9004 
9302			; 
9302			 ;     ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9014 
9302			 
9302			;      ld    HL, 12 
9302			;      call  malloc            ; Allocates 0x9024 
9302			 
9302			      ; Free some allocations 
9302			;      ld    HL, 0x9014 
9302			;      call  free 
9302			 
9302			;      ld    HL, 0x9004 
9302			;      call  free 
9302			; 
9302			;      ld    HL, 0x9024 
9302			;      call  free 
9302			 
9302			 
9302			 ;     halt 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     heap_init                                                               : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Initialise the heap and make it ready for malloc and free operations.   : 
9302			;                                                                             : 
9302			;     The heap is maintained as a linked list, starting with an initial       : 
9302			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9302			;     the first free block in the heap. Each block then points to the next    : 
9302			;     free block within the heap, and the free list ends at the first block   : 
9302			;     with a null pointer to the next free block.                             : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     Inputs are compile-time only. Two defines which specify the starting    : 
9302			;     address of the heap and its size are required, along with a memory      : 
9302			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9302			;     principally stores a pointer to the first free block in the heap.       : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;------------------------------------------------------------------------------ 
9302			heap_init: 
9302			      push  HL 
9302			 
9302			      ; Initialise free list struct 
9302			      ld    HL, heap_start 
9302			      ld    (free_list), HL 
9302			      ld    HL, 0 
9302			      ld    (free_list+2), HL 
9302			 
9302			      ; Insert first free block at bottom of heap, consumes entire heap 
9302			      ld    HL, heap_start+heap_size-4 
9302			      ld    (heap_start), HL        ; Next block (end of free list) 
9302			      ld    HL, heap_size-4 
9302			      ld    (heap_start+2), HL      ; Block size 
9302			 
9302			      ; Insert end of free list block at top of heap - two null words will 
9302			      ; terminate the free list 
9302			      ld    HL, 0 
9302			      ld    (heap_start+heap_size-2), HL 
9302			      ld    (heap_start+heap_size-4), HL 
9302			 
9302			      pop   HL 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     malloc                                                                  : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Allocates the wanted space from the heap and returns the address of the : 
9302			;     first useable byte of the allocation.                                   : 
9302			;                                                                             : 
9302			;     Allocations can happen in one of two ways:                              : 
9302			;                                                                             : 
9302			;     1. A free block may be found which is the exact size wanted. In this    : 
9302			;        case the block is removed from the free list and retuedn to the      : 
9302			;        caller.                                                              : 
9302			;     2. A free block may be found which is larger than the size wanted. In   : 
9302			;        this case, the larger block is split into two. The first portion of  : 
9302			;        this block will become the requested space by the malloc call and    : 
9302			;        is returned to the caller. The second portion becomes a new free     : 
9302			;        block, and the free list is adjusted to maintain continuity via this : 
9302			;        newly created block.                                                 : 
9302			;                                                                             : 
9302			;     malloc does not set any initial value in the allocated space, the       : 
9302			;     caller is required to do this as required.                              : 
9302			;                                                                             : 
9302			;     This implementation of malloc uses the stack exclusively, and is        : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling malloc, and recommended  : 
9302			;     to avoid the use of malloc inside ISRs in general.                      : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Number of bytes wanted                                              : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     HL  Address of the first useable byte of the allocation                 : 
9302			;                                                                             : 
9302			; Flags                                                                       : 
9302			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +4  +-------------+                                                       : 
9302			;       |  this_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			malloc: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if no space requested 
9302			      or    L 
9302			      jp    Z, malloc_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; Setup initial state 
9302			      ld    HL, 4                   ; want must also include space used by block struct 
9302			      add   HL, DE 
9302			 
9302			      ld    B, H                    ; Move want to BC 
9302			      ld    C, L 
9302			 
9302			      ld    HL, free_list           ; Store prev_free ptr to stack 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    E, (HL)                 ; Store this_free ptr to stack 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ld    (IX+2), E 
9302			      ld    (IX+3), D 
9302			      ex    DE, HL                  ; this_free ptr into HL 
9302			 
9302			      ; Loop through free block list to find some space 
9302			malloc_find_space: 
9302			      ld    E, (HL)                 ; Load next_free ptr into DE 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9302			      or    E 
9302			      jp    Z, malloc_no_space 
9302			 
9302			      ld    (IX+0), E               ; Store next_free ptr to stack 
9302			      ld    (IX+1), D 
9302			 
9302			      ; Does this block have enough space to make the allocation? 
9302			      inc   HL                      ; Load free block size into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      ex    DE, HL                  ; Check size of block against want 
9302			      or    A                       ; Ensure carry flag clear 
9302			      sbc   HL, BC 
9302			      push  HL                      ; Store the result for later (new block size) 
9302			 
9302			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9302			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9302			 
9302			      ; this_free block is not big enough, setup ptrs to test next free block 
9302			      pop   HL                      ; Discard previous result 
9302			 
9302			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9302			      ld    H, (IX+3) 
9302			      ld    (IX+4), L 
9302			      ld    (IX+5), H 
9302			 
9302			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9302			      ld    H, (IX+1) 
9302			      ld    (IX+2), L 
9302			      ld    (IX+3), H 
9302			 
9302			      jr    malloc_find_space 
9302			 
9302			      ; split a bigger block into two - requested size and remaining size 
9302			malloc_alloc_split: 
9302			      ex    DE, HL                  ; Calculate address of new free block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      add   HL, BC 
9302			 
9302			      ; Create a new block and point it at next_free 
9302			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      ld    (HL), E                 ; Store next_free ptr into new block 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   DE                      ; Store size of new block into new block 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Update this_free ptr to point to new block 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9302			      ld    (IX+3), H 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store want size into allocated block 
9302			      ld    (HL), C 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			      inc   HL 
9302			      push  HL                      ; Address of allocation to return 
9302			 
9302			      jr    malloc_update_links 
9302			 
9302			malloc_alloc_fit: 
9302			      pop   HL                      ; Dont need new block size, want is exact fit 
9302			 
9302			      ; Modify this_free block to be allocation 
9302			      ex    DE, HL 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      xor   A                       ; Null the next block ptr of allocated block 
9302			      ld    (HL), A 
9302			      inc   HL 
9302			      ld    (HL), A 
9302			 
9302			      inc   HL                      ; Store address of allocation to return 
9302			      inc   HL 
9302			      inc   HL 
9302			      push  HL 
9302			 
9302			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9302			      ld    L, (IX+0)               ; next_free to HL 
9302			      ld    H, (IX+1) 
9302			 
9302			      ld    (IX+2), L               ; HL to this_free 
9302			      ld    (IX+3), H 
9302			 
9302			 
9302			malloc_update_links: 
9302			      ; Update prev_free ptr to point to this_free 
9302			      ld    L, (IX+4)               ; prev_free ptr to HL 
9302			      ld    H, (IX+5) 
9302			 
9302			      ld    E, (IX+2)               ; this_free ptr to DE 
9302			      ld    D, (IX+3) 
9302			 
9302			      ld    (HL), E                 ; this_free ptr into prev_free 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Clear the Z flag to indicate successful allocation 
9302			      ld    A, D 
9302			      or    E 
9302			 
9302			      pop   DE                      ; Address of allocation 
9302			 
9302			malloc_no_space: 
9302			      ld    HL, 6                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			      ex    DE, HL                  ; Alloc addr into HL for return 
9302			 
9302			malloc_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;------------------------------------------------------------------------------ 
9302			;     free                                                                    : 
9302			;                                                                             : 
9302			; Description                                                                 : 
9302			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9302			;     returned by malloc, otherwise the behaviour is undefined.               : 
9302			;                                                                             : 
9302			;     Where possible, directly adjacent free blocks will be merged together   : 
9302			;     into larger blocks to help ensure that the heap does not become         : 
9302			;     excessively fragmented.                                                 : 
9302			;                                                                             : 
9302			;     free does not clear or set any other value into the freed space, and    : 
9302			;     therefore its contents may be visible through subsequent malloc's. The  : 
9302			;     caller should clear the freed space as required.                        : 
9302			;                                                                             : 
9302			;     This implementation of free uses the stack exclusively, and is          : 
9302			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9302			;     advisable to disable interrupts before calling free, and recommended    : 
9302			;     to avoid the use of free inside ISRs in general.                        : 
9302			;                                                                             : 
9302			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9302			;                                                                             : 
9302			; Parameters                                                                  : 
9302			;     HL  Pointer to address of first byte of allocation to be freed          : 
9302			;                                                                             : 
9302			; Returns                                                                     : 
9302			;     Nothing                                                                 : 
9302			;                                                                             : 
9302			; Stack frame                                                                 : 
9302			;       |             |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     BC      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     DE      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |     IX      |                                                       : 
9302			;       +-------------+                                                       : 
9302			;       |  prev_free  |                                                       : 
9302			;   +2  +-------------+                                                       : 
9302			;       |  next_free  |                                                       : 
9302			;   +0  +-------------+                                                       : 
9302			;       |             |                                                       : 
9302			;                                                                             : 
9302			;------------------------------------------------------------------------------ 
9302			free: 
9302			      push  BC 
9302			      push  DE 
9302			      push  IX 
9302			 
9302			      ld    A, H                    ; Exit if ptr is null 
9302			      or    L 
9302			      jp    Z, free_early_exit 
9302			 
9302			      ; Set up stack frame 
9302			      ex    DE, HL 
9302			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			      ld    IX, 0                   ; Use IX as a frame pointer 
9302			      add   IX, SP 
9302			 
9302			      ; The address in HL points to the start of the useable allocated space, 
9302			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9302			      ; address of the block itself. 
9302			      ex    DE, HL 
9302			      ld    DE, -4 
9302			      add   HL, DE 
9302			 
9302			      ; An allocated block must have a null next block pointer in it 
9302			      ld    A, (HL) 
9302			      inc   HL 
9302			      or    (HL) 
9302			      jp    NZ, free_done 
9302			 
9302			      dec   HL 
9302			 
9302			      ld    B, H                    ; Copy HL to BC 
9302			      ld    C, L 
9302			 
9302			      ; Loop through the free list to find the first block with an address 
9302			      ; higher than the block being freed 
9302			      ld    HL, free_list 
9302			 
9302			free_find_higher_block: 
9302			      ld    E, (HL)                 ; Load next ptr from free block 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			 
9302			      ld    (IX+0), E               ; Save ptr to next free block 
9302			      ld    (IX+1), D 
9302			      ld    (IX+2), L               ; Save ptr to prev free block 
9302			      ld    (IX+3), H 
9302			 
9302			      ld    A, B                    ; Check if DE is greater than BC 
9302			      cp    D                       ; Compare MSB first 
9302			      jr    Z, $+4                  ; MSB the same, compare LSB 
9302			      jr    NC, free_find_higher_block_skip 
9302			      ld    A, C 
9302			      cp    E                       ; Then compare LSB 
9302			      jr    C, free_found_higher_block 
9302			 
9302			free_find_higher_block_skip: 
9302			      ld    A, D                    ; Reached the end of the free list? 
9302			      or    E 
9302			      jp    Z, free_done 
9302			 
9302			      ex    DE, HL 
9302			 
9302			      jr    free_find_higher_block 
9302			 
9302			free_found_higher_block: 
9302			      ; Insert freed block between prev and next free blocks 
9302			      ld    (HL), C                 ; Point prev free block to freed block 
9302			      inc   HL 
9302			      ld    (HL), B 
9302			 
9302			      ld    H, B                    ; Point freed block at next free block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      ; Check if the freed block is adjacent to the next free block 
9302			      inc   HL                      ; Load size of freed block into HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      add   HL, BC                  ; Add addr of freed block and its size 
9302			 
9302			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9302			      ld    D, (IX+1) 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_check_adjacent_to_prev 
9302			 
9302			      ; Freed block is adjacent to next, merge into one bigger block 
9302			      ex    DE, HL                  ; Load next ptr from next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save ptr to next block for later 
9302			 
9302			      ld    H, B                    ; Store ptr from next block into freed block 
9302			      ld    L, C 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore ptr to next block 
9302			      inc   HL                      ; Load size of next block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save next block size for later 
9302			 
9302			      ld    H, B                    ; Load size of freed block into HL 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      ex    DE, HL 
9302			 
9302			      pop   DE                      ; Restore size of next block 
9302			      add   HL, DE                  ; Add sizes of both blocks 
9302			      ex    DE, HL 
9302			 
9302			      ld    H, B                    ; Store new bigger size into freed block 
9302			      ld    L, C 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_check_adjacent_to_prev: 
9302			      ; Check if the freed block is adjacent to the prev free block 
9302			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9302			      ld    H, (IX+3) 
9302			 
9302			      inc   HL                      ; Size of prev free block into DE 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      dec   HL 
9302			      dec   HL 
9302			      dec   HL 
9302			 
9302			      add   HL, DE                  ; Add prev block addr and size 
9302			 
9302			      or    A                       ; Clear the carry flag 
9302			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302			      jr    NZ, free_done 
9302			 
9302			      ; Freed block is adjacent to prev, merge into one bigger block 
9302			      ld    H, B                    ; Load next ptr from freed block into DE 
9302			      ld    L, C 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  HL                      ; Save freed block ptr for later 
9302			 
9302			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9302			      ld    H, (IX+3) 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			      pop   HL                      ; Restore freed block ptr 
9302			      inc   HL                      ; Load size of freed block into DE 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			      push  DE                      ; Save freed block size for later 
9302			 
9302			      ld    L, (IX+2)               ; Load size of prev block into DE 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    E, (HL) 
9302			      inc   HL 
9302			      ld    D, (HL) 
9302			 
9302			      pop   HL                      ; Add sizes of both blocks 
9302			      add   HL, DE 
9302			      ex    DE, HL 
9302			 
9302			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9302			      ld    H, (IX+3) 
9302			      inc   HL 
9302			      inc   HL 
9302			      ld    (HL), E 
9302			      inc   HL 
9302			      ld    (HL), D 
9302			 
9302			free_done: 
9302			      ld    HL, 4                   ; Clean up stack frame 
9302			      add   HL, SP 
9302			      ld    SP, HL 
9302			 
9302			free_early_exit: 
9302			      pop   IX 
9302			      pop   DE 
9302			      pop   BC 
9302			 
9302			      ret 
9302			 
9302			 
9302			;      .org 0x8000 
9302			; 
9302			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9302			 ;                 .dw   0 
9302			 
9302			endif 
9302			 
9302			 
9302			if MALLOC_4 
9302			 
9302			; My memory allocation code. Very very simple.... 
9302			; allocate space under 250 chars 
9302			 
9302			heap_init: 
9302				; init start of heap as zero 
9302				;  
9302			 
9302				ld hl, heap_start 
9302				ld a, 0 
9302				ld (hl), a      ; empty block 
9302				inc hl 
9302				ld a, 0 
9302				ld (hl), a      ; length of block 
9302				; write end of list 
9302				inc hl 
9302				ld a,(hl) 
9302				inc hl 
9302				ld a,(hl) 
9302				 
9302			 
9302				; init some malloc vars 
9302			 
9302				ld hl, 0 
9302				ld (free_list), hl       ; store last malloc location 
9302			 
9302				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9302				ld a, 0 
9302				ld (hl), a 
9302			 
9302			 
9302				ld hl, heap_start 
9302				;  
9302				  
9302				ret 
9302			 
9302			 
9302			;    free block marker 
9302			;    requested size  
9302			;    pointer to next block 
9302			;    .... 
9302			;    next block marker 
9302			 
9302			 
9302			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9302			; 
9302			 
9302			 
9302			malloc:  
9302				push de 
9302				push bc 
9302				push af 
9302			 
9302				; hl space required 
9302				 
9302				ld c, l    ; hold space   (TODO only a max of 255) 
9302			 
9302			;	inc c     ; TODO BUG need to fix memory leak on push str 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			;	inc c 
9302			 
9302			 
9302			 
9302				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9302			 
9302				ld a, (free_list+3) 
9302				cp 0 
9302				jr z, .contheap 
9302			 
9302				ld hl, (free_list)     ; get last alloc 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mrs" 
9302						CALLMONITOR 
9302					endif 
9302				jr .startalloc 
9302			 
9302			.contheap: 
9302				ld hl, heap_start 
9302			 
9302			.startalloc: 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mym" 
9302						CALLMONITOR 
9302					endif 
9302			.findblock: 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmf" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302				ld a,(hl)  
9302				; if byte is zero then clear to use 
9302			 
9302				cp 0 
9302				jr z, .foundemptyblock 
9302			 
9302				; if byte is not clear 
9302				;     then byte is offset to next block 
9302			 
9302				inc hl 
9302				ld a, (hl) ; get size 
9302			.nextblock:	inc hl 
9302					ld e, (hl) 
9302					inc hl 
9302					ld d, (hl) 
9302					ex de, hl 
9302			;	inc hl  ; move past the store space 
9302			;	inc hl  ; move past zero index  
9302			 
9302				; TODO detect no more space 
9302			 
9302				push hl 
9302				ld de, heap_end 
9302				call cmp16 
9302				pop hl 
9302				jr nc, .nospace 
9302			 
9302				jr .findblock 
9302			 
9302			.nospace: ld hl, 0 
9302				jp .exit 
9302			 
9302			 
9302			.foundemptyblock:	 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mme" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; TODO has block enough space if reusing??? 
9302			 
9302				;  
9302			 
9302			; see if this block has been previously used 
9302				inc hl 
9302				ld a, (hl) 
9302				dec hl 
9302				cp 0 
9302				jr z, .newblock 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meR" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			; no reusing previously allocated block 
9302			 
9302			; is it smaller than previously used? 
9302				 
9302				inc hl    ; move to size 
9302				ld a, c 
9302				sub (hl)        ; we want c < (hl) 
9302				dec hl    ; move back to marker 
9302			        jr z, .findblock 
9302			 
9302				; update with the new size which should be lower 
9302			 
9302			        ;inc  hl   ; negate next move. move back to size  
9302			 
9302			.newblock: 
9302				; need to be at marker here 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "meN" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			 
9302				ld a, c 
9302			 
9302				ld (free_list+3), a	 ; flag resume from last malloc  
9302				ld (free_list), hl    ; save out last location 
9302			 
9302			 
9302				;inc a     ; space for length byte 
9302				ld (hl), a     ; save block in use marker 
9302			 
9302				inc hl   ; move to space marker 
9302				ld (hl), a    ; save new space 
9302			 
9302				inc hl   ; move to start of allocated area 
9302				 
9302			;	push hl     ; save where we are - 1  
9302			 
9302			;	inc hl  ; move past zero index  
9302				; skip space to set down new marker 
9302			 
9302				; provide some extra space for now 
9302			 
9302				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9302				inc a 
9302				inc a 
9302			 
9302				push hl   ; save where we are in the node block 
9302			 
9302				call addatohl 
9302			 
9302				; write linked list point 
9302			 
9302				pop de     ; get our node position 
9302				ex de, hl 
9302			 
9302				ld (hl), e 
9302				inc hl 
9302				ld (hl), d 
9302			 
9302				inc hl 
9302			 
9302				; now at start of allocated data so save pointer 
9302			 
9302				push hl 
9302			 
9302				; jump to position of next node and setup empty header in DE 
9302			 
9302				ex de, hl 
9302			 
9302			;	inc hl ; move past end of block 
9302			 
9302				ld a, 0 
9302				ld (hl), a   ; empty marker 
9302				inc hl 
9302				ld (hl), a   ; size 
9302				inc hl  
9302				ld (hl), a   ; ptr 
9302				inc hl 
9302				ld (hl), a   ; ptr 
9302			 
9302			 
9302				pop hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "mmr" 
9302						CALLMONITOR 
9302					endif 
9302			 
9302			.exit: 
9302				pop af 
9302				pop bc 
9302				pop de  
9302				ret 
9302			 
9302			 
9302			 
9302			 
9302			free:  
9302				push hl 
9302				push af 
9302				; get address in hl 
9302			 
9302					if DEBUG_FORTH_MALLOC_INT 
9302						DMARK "fre" 
9302						CALLMONITOR 
9302					endif 
9302				; data is at hl - move to block count 
9302				dec hl 
9302				dec hl    ; get past pointer 
9302				dec hl 
9302			 
9302				ld a, (hl)    ; need this for a validation check 
9302			 
9302				dec hl    ; move to block marker 
9302			 
9302				; now check that the block count and block marker are the same  
9302			        ; this checks that we are on a malloc node and not random memory 
9302			        ; OK a faint chance this could be a problem but rare - famous last words! 
9302			 
9302				ld c, a 
9302				ld a, (hl)    
9302			 
9302				cp c 
9302				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9302			 
9302				; yes good chance we are on a malloc node 
9302			 
9302				ld a, 0      
9302				ld (hl), a   ; mark as free 
9302			 
9302				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9302			 
9302			.freeignore:  
9302			 
9302				pop af 
9302				pop hl 
9302			 
9302				ret 
9302			 
9302			 
9302			 
9302			endif 
9302			 
9302			; eof 
# End of file firmware_memory.asm
9302			  
9302			; device C  
9302			if SOUND_ENABLE  
9302				include "firmware_sound.asm"  
9302			endif  
9302			  
9302			include "firmware_diags.asm"  
9302			; Hardware diags menu 
9302			 
9302			 
9302			config: 
9302			 
9302 3e 00			ld a, 0 
9304 21 32 93			ld hl, .configmn 
9307 cd a6 8a			call menu 
930a			 
930a fe 00			cp 0 
930c c8				ret z 
930d			 
930d fe 01			cp 1 
930f cc 60 93			call z, .savetostore 
9312			 
9312 fe 02			cp 2 
9314			if STARTUP_V1 
9314 cc 4c 93			call z, .selautoload 
9317			endif 
9317			 
9317			if STARTUP_V2 
9317				call z, .enautoload 
9317			endif 
9317 fe 03			cp 3 
9319 cc 42 93			call z, .disautoload 
931c fe 04			cp 4 
931e cc 56 93			call z, .selbank 
9321 fe 05			cp 5 
9323 cc 6a 93			call z, .debug_tog 
9326 fe 06			cp 6 
9328 cc ad 94			call z, .bpsgo 
932b fe 07			cp 7 
932d cc 90 93			call z, hardware_diags 
9330			if STARTUP_V2 
9330				cp 8 
9330				call z, create_startup 
9330			endif 
9330 18 d0			jr config 
9332			 
9332			.configmn: 
9332 9e 96			dw prom_c3 
9334 b5 96			dw prom_c2 
9336 ca 96			dw prom_c2a 
9338 e0 96			dw prom_c2b 
933a			;	dw prom_c4 
933a fd 96			dw prom_m4 
933c 18 97			dw prom_m4b 
933e 20 97			dw prom_c1 
9340			if STARTUP_V2 
9340				dw prom_c9 
9340			endif 
9340 00 00			dw 0 
9342				 
9342			 
9342			if STARTUP_V2 
9342			.enautoload: 
9342				if STORAGE_SE 
9342				ld a, $fe      ; bit 0 clear 
9342				ld (spi_device), a 
9342			 
9342				call storage_get_block_0 
9342			 
9342				ld a, 1 
9342				ld (store_page+STORE_0_AUTOFILE), a 
9342			 
9342					ld hl, 0 
9342					ld de, store_page 
9342				call storage_write_block	 ; save update 
9342				else 
9342			 
9342				ld hl, prom_notav 
9342				ld de, prom_empty 
9342				call info_panel 
9342				endif 
9342			 
9342			 
9342				ret 
9342			endif 
9342			 
9342			.disautoload: 
9342				if STORAGE_SE 
9342				ld a, $fe      ; bit 0 clear 
9342				ld (spi_device), a 
9342			 
9342				call storage_get_block_0 
9342			 
9342				ld a, 0 
9342				ld (store_page+STORE_0_AUTOFILE), a 
9342			 
9342					ld hl, 0 
9342					ld de, store_page 
9342				call storage_write_block	 ; save update 
9342				else 
9342			 
9342 21 2f 97			ld hl, prom_notav 
9345 11 45 97			ld de, prom_empty 
9348 cd 06 8a			call info_panel 
934b				endif 
934b			 
934b			 
934b c9				ret 
934c			 
934c			if STARTUP_V1 
934c			 
934c			; Select auto start 
934c			 
934c			.selautoload: 
934c			 
934c				 
934c				if STORAGE_SE 
934c			 
934c					call config_dir 
934c				        ld hl, scratch 
934c					ld a, 0 
934c					call menu 
934c			 
934c					cp 0 
934c					ret z 
934c			 
934c					dec a 
934c			 
934c			 
934c					; locate menu option 
934c			 
934c					ld hl, scratch 
934c					call table_lookup 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALl" 
934c						CALLMONITOR 
934c					endif 
934c					; with the pointer to the menu it, the byte following the zero term is the file id 
934c			 
934c					ld a, 0 
934c					ld bc, 50   ; max of bytes to look at 
934c					cpir  
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALb" 
934c						CALLMONITOR 
934c					endif 
934c					;inc hl 
934c			 
934c					ld a, (hl)   ; file id 
934c					 
934c				        ; save bank and file ids 
934c			 
934c					push af 
934c			 
934c			; TODO need to save to block 0 on bank 1	 
934c			 
934c					call storage_get_block_0 
934c			 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "AL0" 
934c						CALLMONITOR 
934c					endif 
934c					pop af 
934c			 
934c					ld (store_page+STORE_0_FILERUN),a 
934c					 
934c					; save bank id 
934c			 
934c					ld a,(spi_device) 
934c					ld (store_page+STORE_0_BANKRUN),a 
934c			 
934c					; enable auto run of store file 
934c			 
934c					ld a, 1 
934c					ld (store_page+STORE_0_AUTOFILE),a 
934c			 
934c					; save buffer 
934c			 
934c					ld hl, 0 
934c					ld de, store_page 
934c					if DEBUG_FORTH_WORDS 
934c						DMARK "ALw" 
934c						CALLMONITOR 
934c					endif 
934c				call storage_write_block	 ; save update 
934c			  
934c			 
934c			 
934c			 
934c					ld hl, scratch 
934c					call config_fdir 
934c			 
934c				else 
934c			 
934c 21 2f 97			ld hl, prom_notav 
934f 11 45 97			ld de, prom_empty 
9352 cd 06 8a			call info_panel 
9355			 
9355				endif 
9355 c9				ret 
9356			endif 
9356			 
9356			 
9356			; Select storage bank 
9356			 
9356			.selbank: 
9356			 
9356				if STORAGE_SE 
9356				else 
9356			 
9356 21 2f 97			ld hl, prom_notav 
9359 11 45 97			ld de, prom_empty 
935c cd 06 8a			call info_panel 
935f				endif 
935f				 
935f c9				ret 
9360			 
9360			if STORAGE_SE 
9360			 
9360			.config_ldir:   
9360				; Load storage bank labels into menu array 
9360			 
9360				 
9360			 
9360			 
9360				ret 
9360			 
9360			 
9360			endif 
9360			 
9360			 
9360			; Save user words to storage 
9360			 
9360			.savetostore: 
9360			 
9360				if STORAGE_SE 
9360			 
9360					call config_dir 
9360				        ld hl, scratch 
9360					ld a, 0 
9360					call menu 
9360					 
9360					ld hl, scratch 
9360					call config_fdir 
9360			 
9360				else 
9360			 
9360 21 2f 97			ld hl, prom_notav 
9363 11 45 97			ld de, prom_empty 
9366 cd 06 8a			call info_panel 
9369			 
9369				endif 
9369			 
9369 c9				ret 
936a			 
936a			if STARTUP_V2 
936a			 
936a			create_startup: 
936a			 
936a				ld a, 0 
936a				ld hl, .crstart 
936a				call menu 
936a			 
936a				cp 0 
936a				ret z 
936a			 
936a				cp 1 
936a				call z, .genlsword 
936a				cp 2 
936a				call z, .genedword 
936a			 
936a				cp 3 
936a				call z, .gendemword 
936a			 
936a				cp 4 
936a				call z, .genutlword 
936a				cp 5 
936a				call z, .genspiword 
936a				cp 6 
936a				call z, .genkeyword 
936a				jr create_startup 
936a			 
936a			.genlsword: 
936a				ld hl, crs_s1 
936a				ld de, .lsworddef 
936a				call .genfile 
936a				ret 
936a			 
936a			.genedword: 
936a				ld de, .edworddef 
936a				ld hl, crs_s2 
936a				call .genfile 
936a				ret 
936a			 
936a			.gendemword: 
936a				ld de, .demoworddef 
936a				ld hl, crs_s3 
936a				call .genfile 
936a				ret 
936a			 
936a			.genutlword: 
936a				ld hl, crs_s4 
936a				ld de, .utilwordef 
936a				call .genfile 
936a				ret 
936a			.genspiword: 
936a				ld hl, crs_s5 
936a				ld de, .spiworddef 
936a				call .genfile 
936a				ret 
936a			.genkeyword: 
936a				ld hl, crs_s6 
936a				ld de, .keyworddef 
936a				call .genfile 
936a				ret 
936a			 
936a			; hl - points to file name 
936a			; de - points to strings to add to file 
936a			 
936a			.genfile: 
936a				push de 
936a				call storage_create 
936a				; id in hl 
936a				pop de   ; table of strings to add 
936a			 
936a			.genloop: 
936a			 
936a				push hl ; save id for next time around 
936a				push de ; save de for next time around 
936a			 
936a				ex de, hl 
936a				call loadwordinhl 
936a				ex de, hl 
936a			 
936a				; need hl to be the id 
936a				; need de to be the string ptr 
936a				 
936a				call storage_append 
936a			 
936a				pop de 
936a				pop hl 
936a			 
936a				inc de 
936a				inc de 
936a			 
936a				ld a,(de) 
936a				cp 0 
936a				jr nz, .genloop 
936a				inc de 
936a				ld a, (de) 
936a				dec de 
936a				cp 0 
936a				jr nz, .genloop	 
936a			 
936a				ret 
936a			 
936a			 
936a			.utilwordef: 
936a				dw strncpy 
936a				dw type 
936a				dw clrstack 
936a				dw longread 
936a				dw start1 
936a				dw start2 
936a				dw start3b 
936a				dw start3c 
936a				dw list 
936a				dw 0 
936a			 
936a			.lsworddef: 
936a				dw start3b 
936a				dw 0 
936a			 
936a			.edworddef: 
936a				dw edit1 
936a				dw edit2 
936a				dw edit3 
936a				dw 0 
936a			 
936a			.demoworddef: 
936a				dw test5 
936a				dw test6 
936a				dw test7 
936a				dw test8 
936a				dw test9 
936a				dw test10 
936a				dw game1 
936a				dw game1a 
936a				dw game1b 
936a				dw game1c 
936a				dw game1d 
936a				dw game1s 
936a				dw game1t 
936a				dw game1f 
936a				dw game1z 
936a				dw game1zz 
936a				dw ssv2 
936a				dw ssv3 
936a				dw ssv4 
936a				dw ssv5 
936a				dw ssv1 
936a				dw ssv1cpm	 
936a				dw game2b 
936a				dw game2bf 
936a				dw game2mba 
936a				dw game2mbas	 
936a				dw game2mbht 
936a				dw game2mbms 
936a				dw game2mb 
936a				dw game3w 
936a				dw game3p 
936a				dw game3sc 
936a				dw game3vsi 
936a				dw game3vs 
936a				dw 0 
936a			 
936a			 
936a			.spiworddef: 
936a			 
936a			    dw spi1 
936a			    dw spi2 
936a			    dw spi3 
936a			    dw spi4 
936a			    dw spi5 
936a			    dw spi6 
936a			    dw spi7 
936a			 
936a			    dw spi8 
936a			    dw spi9 
936a			    dw spi10 
936a			    dw 0 
936a			 
936a			.keyworddef: 
936a			 
936a				dw keyup 
936a				dw keydown 
936a				dw keyleft 
936a				dw keyright 
936a				dw 	keyf1 
936a				dw keyf2 
936a				dw keyf3 
936a				dw keyf4 
936a				dw keyf5 
936a				dw keyf6 
936a				dw keyf7 
936a				dw keyf8 
936a				dw keyf9 
936a				dw keyf10 
936a				dw keyf11 
936a				dw keyf12 
936a				dw keytab 
936a				dw keycr 
936a				dw keyhome 
936a				dw keyend 
936a				dw keybs 
936a				dw 0 
936a			 
936a			.crstart: 
936a				dw crs_s1 
936a				dw crs_s2 
936a				dw crs_s3 
936a				dw crs_s4 
936a				dw crs_s5 
936a				dw crs_s6 
936a				dw 0 
936a			 
936a			endif 
936a			 
936a			 
936a			if STORAGE_SE 
936a			 
936a			config_fdir: 
936a				; using the scratch dir go through and release the memory allocated for each string 
936a				 
936a				ld hl, scratch 
936a			.cfdir:	ld e,(hl) 
936a				inc hl 
936a				ld d,(hl) 
936a				inc hl 
936a			 
936a				ex de, hl 
936a				call ishlzero 
936a				ret z     ; return on null pointer 
936a				call free 
936a				ex de, hl 
936a				jr .cfdir 
936a			 
936a			 
936a				ret 
936a			 
936a			 
936a			config_dir: 
936a			 
936a				; for the config menus that need to build a directory of storage call this routine 
936a				; it will construct a menu in scratch to pass to menu 
936a			 
936a				; open storage device 
936a			 
936a				; execute DIR to build a list of files and their ids into scratch in menu format 
936a				; once the menu has finished then will need to call config_fdir to release the strings 
936a				 
936a				; c = number items 
936a			 
936a				 
936a				call storage_get_block_0 
936a			 
936a				ld hl, store_page     ; get current id count 
936a				ld b, (hl) 
936a				ld c, 0    ; count of files   
936a			 
936a			 
936a				ld hl, scratch 
936a				ld (store_tmp2), hl    ; location to poke strings 
936a			 
936a				; check for empty drive 
936a			 
936a				ld a, 0 
936a				cp b 
936a				jp z, .dirdone 
936a			 
936a				 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdc" 
936a						CALLMONITOR 
936a					endif 
936a			 
936a			 
936a			.diritem:	 
936a				push bc 
936a				; for each of the current ids do a search for them and if found push to stack 
936a			 
936a					ld hl, STORE_BLOCK_PHY 
936a					ld d, 0		 ; look for extent 0 of block id as this contains file name 
936a					ld e,b 
936a			 
936a					call storage_findnextid 
936a			 
936a			 
936a					; if found hl will be non zero 
936a			 
936a					call ishlzero 
936a					jr z, .dirnotfound 
936a			 
936a					; increase count 
936a			 
936a					pop bc	 
936a					inc c 
936a					push bc 
936a					 
936a			 
936a					; get file header and push the file name 
936a			 
936a					ld de, store_page 
936a					call storage_read_block 
936a			 
936a					; push file id to stack 
936a				 
936a					ld a, (store_page) 
936a					ld h, 0 
936a					ld l, a 
936a			 
936a					;call forth_push_numhl 
936a					; TODO store id 
936a			 
936a					push hl 
936a			 
936a					; push extent count to stack  
936a				 
936a					ld hl, store_page+3 
936a			 
936a					; get file name length 
936a			 
936a					call strlenz   
936a			 
936a					inc hl   ; cover zero term 
936a					inc hl  ; stick the id at the end of the area 
936a			 
936a					push hl 
936a					pop bc    ; move length to bc 
936a			 
936a					call malloc 
936a			 
936a					; TODO save malloc area to scratch 
936a			 
936a					ex de, hl 
936a					ld hl, (store_tmp2) 
936a					ld (hl), e 
936a					inc hl 
936a					ld (hl), d 
936a					inc hl 
936a					ld (store_tmp2), hl 
936a			 
936a					 
936a			 
936a					;pop hl   ; get source 
936a			;		ex de, hl    ; swap aronund	 
936a			 
936a					ld hl, store_page+3 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "CFd" 
936a						CALLMONITOR 
936a					endif 
936a					ldir 
936a			 
936a					; de is past string, move back one and store id 
936a					 
936a					dec de 
936a			 
936a					; store file id 
936a			 
936a					pop hl 
936a					ex de,hl 
936a					ld (hl), e 
936a			 
936a					if DEBUG_FORTH_WORDS 
936a						DMARK "Cdi" 
936a						CALLMONITOR 
936a					endif 
936a					 
936a			.dirnotfound: 
936a					pop bc     
936a					djnz .diritem 
936a				 
936a			.dirdone:	 
936a			 
936a					ld a, 0 
936a					ld hl, (store_tmp2) 
936a					ld (hl), a 
936a					inc hl 
936a					ld (hl), a 
936a					inc hl 
936a					; push a count of the dir items found 
936a			 
936a			;		ld h, 0 
936a			;		ld l, c 
936a			 
936a				ret 
936a			 
936a			endif 
936a			 
936a			 
936a			; Settings 
936a			; Run  
936a			 
936a			 
936a			 
936a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
936a			;;hd_menu2:   db "        2: Editor",0   
936a			;hd_menu2:   db "        2: Editor       6: Menu",0   
936a			;hd_menu3:   db "        3: Storage",0 
936a			;hd_menu4:   db "0=quit  4: Debug",0 
936a			;hd_don:     db "ON",0 
936a			;hd_doff:     db "OFF",0 
936a			; 
936a			; 
936a			; 
936a			;hardware_diags_old:       
936a			; 
936a			;.diagmenu: 
936a			;	call clear_display 
936a			;	ld a, display_row_1 
936a			;	ld de, hd_menu1 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_2 
936a			;	ld de, hd_menu2 
936a			;	call str_at_display 
936a			; 
936a			;	ld a, display_row_3 
936a			;	ld de, hd_menu3 
936a			;	call str_at_display 
936a			; 
936a			;	ld a,  display_row_4 
936a			;	ld de, hd_menu4 
936a			;	call str_at_display 
936a			; 
936a			;	; display debug state 
936a			; 
936a			;	ld de, hd_don 
936a			;	ld a, (os_view_disable) 
936a			;	cp 0 
936a			;	jr z, .distog 
936a			;	ld de, hd_doff 
936a			;.distog: ld a, display_row_4+17 
936a			;	call str_at_display 
936a			; 
936a			;	call update_display 
936a			; 
936a			;	call cin_wait 
936a			; 
936a			; 
936a			; 
936a			;	cp '4' 
936a			;	jr nz, .diagn1 
936a			; 
936a			;	; debug toggle 
936a			; 
936a			;	ld a, (os_view_disable) 
936a			;	ld b, '*' 
936a			;	cp 0 
936a			;	jr z, .debtog 
936a			;	ld b, 0 
936a			;.debtog:	 
936a			;	ld a,b 
936a			;	ld (os_view_disable),a 
936a			; 
936a			;.diagn1: cp '0' 
936a			;	 ret z 
936a			; 
936a			;;	cp '1' 
936a			;;       jp z, matrix	 
936a			;;   TODO keyboard matrix test 
936a			; 
936a			;	cp '2' 
936a			;	jp z, .diagedit 
936a			; 
936a			;;	cp '6' 
936a			;;	jp z, .menutest 
936a			;;if ENABLE_BASIC 
936a			;;	cp '6' 
936a			;;	jp z, basic 
936a			;;endif 
936a			 ; 
936a			;	jp .diagmenu 
936a			; 
936a			; 
936a			;	ret 
936a			 
936a			 
936a			.debug_tog: 
936a 21 b1 93			ld hl, .menudebug 
936d				 
936d 3a bc e2			ld a, (os_view_disable) 
9370 fe 2a			cp '*' 
9372 20 04			jr nz,.tdon  
9374 3e 01			ld a, 1 
9376 18 02			jr .tog1 
9378 3e 00		.tdon: ld a, 0 
937a			 
937a			.tog1: 
937a cd a6 8a			call menu 
937d fe 00			cp 0 
937f c8				ret z 
9380 fe 01			cp 1    ; disable debug 
9382 28 04			jr z, .dtog0 
9384 3e 2a			ld a, '*' 
9386 18 02			jr .dtogset 
9388 3e 00		.dtog0: ld a, 0 
938a 32 bc e2		.dtogset:  ld (os_view_disable), a 
938d c3 6a 93			jp .debug_tog 
9390			 
9390			 
9390			hardware_diags:       
9390			 
9390			.diagm: 
9390 21 a3 93			ld hl, .menuitems 
9393 3e 00			ld a, 0 
9395 cd a6 8a			call menu 
9398			 
9398 fe 00		         cp 0 
939a c8				 ret z 
939b			 
939b fe 02			cp 2 
939d ca fc 93			jp z, .diagedit 
93a0			 
93a0			;	cp '6' 
93a0			;	jp z, .menutest 
93a0			;if ENABLE_BASIC 
93a0			;	cp '6' 
93a0			;	jp z, basic 
93a0			;endif 
93a0			  
93a0 c3 90 93			jp .diagm 
93a3			 
93a3				 
93a3 b7 93		.menuitems:   	dw .m1 
93a5 c2 93				dw .m2 
93a7 c9 93				dw .m3 
93a9 d1 93				dw .m5 
93ab d7 93				dw .m5a 
93ad e0 93				dw .m5b 
93af 00 00				dw 0 
93b1			 
93b1			.menudebug: 
93b1 e9 93				dw .m6 
93b3 f2 93				dw .m7 
93b5 00 00				dw 0 
93b7			 
93b7 .. 00		.m1:   db "Key Matrix",0 
93c2 .. 00		.m2:   db "Editor",0 
93c9 .. 00		.m3:   db "Storage",0 
93d1 .. 00		.m5:   db "Sound",0 
93d7 .. 00		.m5a:  db "RAM Test",0 
93e0 .. 00		.m5b:  db "LCD Test",0 
93e9			 
93e9 .. 00		.m6:   db "Debug ON",0 
93f2 .. 00		.m7:   db "Debug OFF",0 
93fc			 
93fc			; debug editor 
93fc			 
93fc			.diagedit: 
93fc			 
93fc 21 cb e2			ld hl, scratch 
93ff			;	ld bc, 250 
93ff			;	ldir 
93ff				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93ff 3e 00			ld a, 0 
9401 77				ld (hl), a 
9402 23				inc hl 
9403 77				ld (hl), a 
9404 23				inc hl 
9405 77				ld (hl), a 
9406			 
9406 cd 75 8a		        call clear_display 
9409 cd 98 8a			call update_display 
940c				;ld a, 1 
940c				;ld (hardware_diag), a 
940c			.diloop: 
940c 3e 00			ld a, display_row_1 
940e 0e 00			ld c, 0 
9410 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9412 1e 28			ld e, 40 
9414			 
9414 21 cb e2			ld hl, scratch	 
9417 cd cf 8c			call input_str 
941a			 
941a 3e 28			ld a, display_row_2 
941c 11 cb e2			ld de, scratch 
941f cd 88 8a			call str_at_display 
9422 cd 98 8a			call update_display 
9425			 
9425 c3 0c 94			jp .diloop 
9428			 
9428			 
9428			; pass word in hl 
9428			; a has display location 
9428			display_word_at: 
9428 f5				push af 
9429 e5				push hl 
942a 7c				ld a,h 
942b 21 d0 e5			ld hl, os_word_scratch 
942e cd a3 8f			call hexout 
9431 e1				pop hl 
9432 7d				ld a,l 
9433 21 d2 e5			ld hl, os_word_scratch+2 
9436 cd a3 8f			call hexout 
9439 21 d4 e5			ld hl, os_word_scratch+4 
943c 3e 00			ld a,0 
943e 77				ld (hl),a 
943f 11 d0 e5			ld de,os_word_scratch 
9442 f1				pop af 
9443 cd 88 8a				call str_at_display 
9446 c9				ret 
9447			 
9447			display_ptr_state: 
9447			 
9447				; to restore afterwards 
9447			 
9447 d5				push de 
9448 c5				push bc 
9449 e5				push hl 
944a f5				push af 
944b			 
944b				; for use in here 
944b			 
944b			;	push bc 
944b			;	push de 
944b			;	push hl 
944b			;	push af 
944b			 
944b cd 75 8a			call clear_display 
944e			 
944e 11 21 96			ld de, .ptrstate 
9451 3e 00			ld a, display_row_1 
9453 cd 88 8a			call str_at_display 
9456			 
9456				; display debug step 
9456			 
9456			 
9456 11 71 ee			ld de, debug_mark 
9459 3e 26			ld a, display_row_1+display_cols-2 
945b cd 88 8a			call str_at_display 
945e			 
945e				; display a 
945e 11 2b 96			ld de, .ptrcliptr 
9461 3e 28			ld a, display_row_2 
9463 cd 88 8a			call str_at_display 
9466			 
9466 f1				pop af 
9467 2a 4a ea			ld hl,(cli_ptr) 
946a 3e 30			ld a, display_row_2+8 
946c cd 28 94			call display_word_at 
946f			 
946f			 
946f				; display hl 
946f			 
946f			 
946f 11 33 96			ld de, .ptrclioptr 
9472 3e 32			ld a, display_row_2+10 
9474 cd 88 8a			call str_at_display 
9477			; 
9477			;	pop hl 
9477 3e 35			ld a, display_row_2+13 
9479 2a 48 ea			ld hl,(cli_origptr) 
947c cd 28 94			call display_word_at 
947f			; 
947f			;	 
947f			;	; display de 
947f			 
947f			;	ld de, .regstatede 
947f			;	ld a, display_row_3 
947f			;	call str_at_display 
947f			 
947f			;	pop de 
947f			;	ld h,d 
947f			;	ld l, e 
947f			;	ld a, display_row_3+3 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display bc 
947f			 
947f			;	ld de, .regstatebc 
947f			;	ld a, display_row_3+10 
947f			;	call str_at_display 
947f			 
947f			;	pop bc 
947f			;	ld h,b 
947f			;	ld l, c 
947f			;	ld a, display_row_3+13 
947f			;	call display_word_at 
947f			 
947f			 
947f				; display dsp 
947f			 
947f			;	ld de, .regstatedsp 
947f			;	ld a, display_row_4 
947f			;	call str_at_display 
947f			 
947f				 
947f			;	ld hl,(cli_data_sp) 
947f			;	ld a, display_row_4+4 
947f			;	call display_word_at 
947f			 
947f				; display rsp 
947f			 
947f 11 62 96			ld de, .regstatersp 
9482 3e 82			ld a, display_row_4+10 
9484 cd 88 8a			call str_at_display 
9487			 
9487				 
9487 2a fc e9			ld hl,(cli_ret_sp) 
948a 3e 86			ld a, display_row_4+14 
948c cd 28 94			call display_word_at 
948f			 
948f cd 98 8a			call update_display 
9492			 
9492 cd f2 89			call delay1s 
9495 cd f2 89			call delay1s 
9498 cd f2 89			call delay1s 
949b			 
949b			 
949b cd 8c 9a			call next_page_prompt 
949e			 
949e				; restore  
949e			 
949e f1				pop af 
949f e1				pop hl 
94a0 c1				pop bc 
94a1 d1				pop de 
94a2 c9				ret 
94a3			 
94a3			break_point_state: 
94a3 f5				push af 
94a4			 
94a4				; see if disabled 
94a4			 
94a4 3a bc e2			ld a, (os_view_disable) 
94a7 fe 2a			cp '*' 
94a9 20 02			jr nz, .bpsgo 
94ab f1				pop af 
94ac c9				ret 
94ad			 
94ad			.bpsgo: 
94ad f1				pop af 
94ae f5				push af 
94af 22 b8 e2			ld (os_view_hl), hl 
94b2 ed 53 b6 e2		ld (os_view_de), de 
94b6 ed 43 b4 e2		ld (os_view_bc), bc 
94ba e5				push hl 
94bb 6f				ld l, a 
94bc 26 00			ld h, 0 
94be 22 ba e2			ld (os_view_af),hl 
94c1			 
94c1 21 b7 ed				ld hl, display_fb0 
94c4 22 d2 eb				ld (display_fb_active), hl 
94c7 e1				pop hl	 
94c8			 
94c8 3e 31			ld a, '1' 
94ca fe 2a		.bps1:  cp '*' 
94cc 20 03			jr nz, .bps1b 
94ce 32 bc e2			ld (os_view_disable),a 
94d1 fe 31		.bps1b:  cp '1' 
94d3 20 14			jr nz, .bps2 
94d5			 
94d5				; display reg 
94d5			 
94d5				 
94d5			 
94d5 3a ba e2			ld a, (os_view_af) 
94d8 2a b8 e2			ld hl, (os_view_hl) 
94db ed 5b b6 e2		ld de, (os_view_de) 
94df ed 4b b4 e2		ld bc, (os_view_bc) 
94e3 cd 7d 95			call display_reg_state 
94e6 c3 69 95			jp .bpschk 
94e9			 
94e9 fe 32		.bps2:  cp '2' 
94eb 20 08			jr nz, .bps3 
94ed				 
94ed				; display hl 
94ed 2a b8 e2			ld hl, (os_view_hl) 
94f0 cd 67 96			call display_dump_at_hl 
94f3			 
94f3 18 74			jr .bpschk 
94f5			 
94f5 fe 33		.bps3:  cp '3' 
94f7 20 08			jr nz, .bps4 
94f9			 
94f9			        ; display de 
94f9 2a b6 e2			ld hl, (os_view_de) 
94fc cd 67 96			call display_dump_at_hl 
94ff			 
94ff 18 68			jr .bpschk 
9501 fe 34		.bps4:  cp '4' 
9503 20 08			jr nz, .bps5 
9505			 
9505			        ; display bc 
9505 2a b4 e2			ld hl, (os_view_bc) 
9508 cd 67 96			call display_dump_at_hl 
950b			 
950b 18 5c			jr .bpschk 
950d fe 35		.bps5:  cp '5' 
950f 20 08		        jr nz, .bps7 
9511			 
9511				; display cur ptr 
9511 2a 4a ea			ld hl, (cli_ptr) 
9514 cd 67 96			call display_dump_at_hl 
9517			 
9517 18 50			jr .bpschk 
9519 fe 36		.bps7:  cp '6' 
951b 20 08			jr nz, .bps8b 
951d				 
951d				; display cur orig ptr 
951d 2a 48 ea			ld hl, (cli_origptr) 
9520 cd 67 96			call display_dump_at_hl 
9523 18 44			jr .bpschk 
9525 fe 37		.bps8b:  cp '7' 
9527 20 08			jr nz, .bps9 
9529				 
9529				; display dsp 
9529 2a f8 e9			ld hl, (cli_data_sp) 
952c cd 67 96			call display_dump_at_hl 
952f			 
952f 18 38			jr .bpschk 
9531 fe 39		.bps9:  cp '9' 
9533 20 05			jr nz, .bps8c 
9535				 
9535				; display SP 
9535			;	ld hl, sp 
9535 cd 67 96			call display_dump_at_hl 
9538			 
9538 18 2f			jr .bpschk 
953a fe 38		.bps8c:  cp '8' 
953c 20 08			jr nz, .bps8d 
953e				 
953e				; display rsp 
953e 2a fc e9			ld hl, (cli_ret_sp) 
9541 cd 67 96			call display_dump_at_hl 
9544			 
9544 18 23			jr .bpschk 
9546 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9548 20 05			jr nz, .bps8 
954a cd 82 98			call monitor 
954d			 
954d 18 1a			jr .bpschk 
954f fe 30		.bps8:  cp '0' 
9551 20 16			jr nz, .bpschk 
9553			 
9553 21 16 ed				ld hl, display_fb1 
9556 22 d2 eb				ld (display_fb_active), hl 
9559 cd 98 8a				call update_display 
955c			 
955c				;ld a, (os_view_af) 
955c 2a b8 e2			ld hl, (os_view_hl) 
955f ed 5b b6 e2		ld de, (os_view_de) 
9563 ed 4b b4 e2		ld bc, (os_view_bc) 
9567 f1				pop af 
9568 c9				ret 
9569			 
9569			.bpschk:   
9569 cd f2 89			call delay1s 
956c 3e 9f		ld a,display_row_4 + display_cols - 1 
956e 11 8a 9a		        ld de, endprg 
9571 cd 88 8a			call str_at_display 
9574 cd 98 8a			call update_display 
9577 cd b5 e2			call cin_wait 
957a			 
957a c3 ca 94			jp .bps1 
957d			 
957d			 
957d			display_reg_state: 
957d			 
957d				; to restore afterwards 
957d			 
957d d5				push de 
957e c5				push bc 
957f e5				push hl 
9580 f5				push af 
9581			 
9581				; for use in here 
9581			 
9581 c5				push bc 
9582 d5				push de 
9583 e5				push hl 
9584 f5				push af 
9585			 
9585 cd 75 8a			call clear_display 
9588			 
9588 11 3d 96			ld de, .regstate 
958b 3e 00			ld a, display_row_1 
958d cd 88 8a			call str_at_display 
9590			 
9590				; display debug step 
9590			 
9590			 
9590 11 71 ee			ld de, debug_mark 
9593 3e 25			ld a, display_row_1+display_cols-3 
9595 cd 88 8a			call str_at_display 
9598			 
9598				; display a 
9598 11 59 96			ld de, .regstatea 
959b 3e 28			ld a, display_row_2 
959d cd 88 8a			call str_at_display 
95a0			 
95a0 e1				pop hl 
95a1			;	ld h,0 
95a1			;	ld l, a 
95a1 3e 2b			ld a, display_row_2+3 
95a3 cd 28 94			call display_word_at 
95a6			 
95a6			 
95a6				; display hl 
95a6			 
95a6			 
95a6 11 4d 96			ld de, .regstatehl 
95a9 3e 32			ld a, display_row_2+10 
95ab cd 88 8a			call str_at_display 
95ae			 
95ae e1				pop hl 
95af 3e 35			ld a, display_row_2+13 
95b1 cd 28 94			call display_word_at 
95b4			 
95b4				 
95b4				; display de 
95b4			 
95b4 11 51 96			ld de, .regstatede 
95b7 3e 50			ld a, display_row_3 
95b9 cd 88 8a			call str_at_display 
95bc			 
95bc e1				pop hl 
95bd			;	ld h,d 
95bd			;	ld l, e 
95bd 3e 53			ld a, display_row_3+3 
95bf cd 28 94			call display_word_at 
95c2			 
95c2			 
95c2				; display bc 
95c2			 
95c2 11 55 96			ld de, .regstatebc 
95c5 3e 5a			ld a, display_row_3+10 
95c7 cd 88 8a			call str_at_display 
95ca			 
95ca e1				pop hl 
95cb			;	ld h,b 
95cb			;	ld l, c 
95cb 3e 5d			ld a, display_row_3+13 
95cd cd 28 94			call display_word_at 
95d0			 
95d0			 
95d0				; display dsp 
95d0			 
95d0 11 5d 96			ld de, .regstatedsp 
95d3 3e 78			ld a, display_row_4 
95d5 cd 88 8a			call str_at_display 
95d8			 
95d8				 
95d8 2a f8 e9			ld hl,(cli_data_sp) 
95db 3e 7c			ld a, display_row_4+4 
95dd cd 28 94			call display_word_at 
95e0			 
95e0				; display rsp 
95e0			 
95e0 11 62 96			ld de, .regstatersp 
95e3 3e 82			ld a, display_row_4+10 
95e5 cd 88 8a			call str_at_display 
95e8			 
95e8				 
95e8 2a fc e9			ld hl,(cli_ret_sp) 
95eb 3e 86			ld a, display_row_4+14 
95ed cd 28 94			call display_word_at 
95f0			 
95f0 cd 98 8a			call update_display 
95f3			 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			;	call delay1s 
95f3			 
95f3			 
95f3			;	call next_page_prompt 
95f3			 
95f3				; restore  
95f3			 
95f3 f1				pop af 
95f4 e1				pop hl 
95f5 c1				pop bc 
95f6 d1				pop de 
95f7 c9				ret 
95f8			 
95f8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
960c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9621 .. 00		.ptrstate:	db "Ptr State",0 
962b .. 00		.ptrcliptr:     db "cli_ptr",0 
9633 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
963d .. 00		.regstate:	db "Reg State (1/0)",0 
964d .. 00		.regstatehl:	db "HL:",0 
9651 .. 00		.regstatede:	db "DE:",0 
9655 .. 00		.regstatebc:	db "BC:",0 
9659 .. 00		.regstatea:	db "A :",0 
965d .. 00		.regstatedsp:	db "DSP:",0 
9662 .. 00		.regstatersp:	db "RSP:",0 
9667			 
9667			display_dump_at_hl: 
9667 e5				push hl 
9668 d5				push de 
9669 c5				push bc 
966a f5				push af 
966b			 
966b 22 ee e5			ld (os_cur_ptr),hl	 
966e cd 75 8a			call clear_display 
9671 cd 94 99			call dumpcont 
9674			;	call delay1s 
9674			;	call next_page_prompt 
9674			 
9674			 
9674 f1				pop af 
9675 c1				pop bc 
9676 d1				pop de 
9677 e1				pop hl 
9678 c9				ret 
9679			 
9679			;if ENABLE_BASIC 
9679			;	include "nascombasic.asm" 
9679			;	basic: 
9679			;	include "forth/FORTH.ASM" 
9679			;endif 
9679			 
9679			; eof 
9679			 
9679			 
# End of file firmware_diags.asm
9679			  
9679			include "firmware_prompts.asm"  
9679			; Prompts  
9679			 
9679			; boot messages 
9679			 
9679 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
968e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
969e			 
969e			 
969e			; config menus 
969e			 
969e .. 00		prom_c3: db "Add Dictionary To File",0 
96b5			 
96b5			if STARTUP_V1 
96b5 .. 00		prom_c2: db "Select Autoload File",0 
96ca .. 00		prom_c2a: db "Disable Autoload File", 0 
96e0			endif 
96e0			 
96e0			if STARTUP_V2 
96e0			prom_c2: db "Enable Autoload Files",0 
96e0			prom_c2a: db "Disable Autoload Files", 0 
96e0			 
96e0			crs_s1: db "*ls-word", 0 
96e0			crs_s2: db "*ed-word", 0 
96e0			crs_s3: db "*Demo-Programs", 0 
96e0			crs_s4: db "*Utils", 0 
96e0			crs_s5: db "*SPI-Addons", 0 
96e0			crs_s6: db "*Key-constants", 0 
96e0			 
96e0			 
96e0			 
96e0			endif 
96e0 .. 00		prom_c2b: db "Select Storage Bank",0 
96f4 .. 00		prom_c4: db "Settings",0 
96fd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9718 .. 00		prom_m4b:   db "Monitor",0 
9720 .. 00		prom_c1: db "Hardware Diags",0 
972f			 
972f			 
972f			if STARTUP_V2 
972f			prom_c9: db "Create Startup Files",0 
972f			endif 
972f			 
972f .. 00		prom_notav:    db "Feature not available",0 
9745 .. 00		prom_empty:    db "",0 
9746			 
9746			; eof 
9746			 
# End of file firmware_prompts.asm
9746			  
9746			  
9746			; eof  
9746			  
# End of file firmware.asm
9746			 
9746			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9746			;if BASE_KEV  
9746			;baseram: equ 08000h 
9746			;endif 
9746			 
9746			;if BASE_SC114 
9746			;baseram:     equ    endofcode 
9746			;endif 
9746			 
9746			 
9746			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9746			 
9746			; start system 
9746			 
9746			coldstart: 
9746				; set sp 
9746				; di/ei 
9746			 
9746 f3				di 
9747 31 00 f0			ld sp, tos 
974a			;	ei 
974a			 
974a			 
974a				; disable breakpoint by default 
974a			 
974a 3e 2a			ld a,'*' 
974c 32 bc e2			ld (os_view_disable),a 
974f			 
974f				; init hardware 
974f			 
974f				; init keyboard and screen hardware 
974f			 
974f cd 1c 80			call hardware_init 
9752			 
9752			 
9752 cd f2 89			call delay1s 
9755 3e 58			ld a, display_row_3+8 
9757 11 03 80			ld de, buildtime 
975a cd 88 8a			call str_at_display 
975d cd 98 8a			call update_display 
9760			 
9760 cd f2 89			call delay1s 
9763 cd f2 89			call delay1s 
9766 cd f2 89			call delay1s 
9769			 
9769				; detect if any keys are held down to enable breakpoints at start up 
9769			 
9769 cd bb e2			call cin  
976c fe 00			cp 0 
976e 28 03			jr z, .nokeys 
9770			 
9770				;call hardware_diags 
9770 cd 02 93			call config 
9773			 
9773			;	ld de, .bpen 
9773			;	ld a, display_row_4 
9773			;	call str_at_display 
9773			;	call update_display 
9773			; 
9773			;	ld a,0 
9773			;	ld (os_view_disable),a 
9773			; 
9773			;.bpwait: 
9773			;	call cin 
9773			;	cp 0 
9773			;	jr z, .bpwait 
9773			;	jr .nokeys 
9773			; 
9773			; 
9773			;.bpen:  db "Break points enabled!",0 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			.nokeys: 
9773			 
9773			 
9773				 
9773			 
9773			;jp  testkey 
9773			 
9773			;call storage_get_block_0 
9773			; 
9773			;ld hl, 0 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773				 
9773			;ld hl, 10 
9773			;ld de, store_page 
9773			;call storage_read_block 
9773			 
9773			 
9773			 
9773			 
9773			 
9773			;stop:	nop 
9773			;	jp stop 
9773			 
9773			 
9773			 
9773			main: 
9773 cd 75 8a			call clear_display 
9776 cd 98 8a			call update_display 
9779			 
9779			 
9779			 
9779			;	call testlcd 
9779			 
9779			 
9779			 
9779 cd 91 9e			call forth_init 
977c			 
977c			 
977c			warmstart: 
977c cd 67 9e			call forth_warmstart 
977f			 
977f				; run startup word load 
977f			        ; TODO prevent this running at warmstart after crash  
977f			 
977f				if STARTUP_ENABLE 
977f			 
977f					if STARTUP_V1 
977f			 
977f						if STORAGE_SE 
977f							call forth_autoload 
977f						endif 
977f cd 62 e1					call forth_startup 
9782					endif 
9782			 
9782					if STARTUP_V2 
9782			 
9782						if STORAGE_SE 
9782							call forth_autoload 
9782						else 
9782							call forth_startup 
9782						endif 
9782			 
9782			 
9782					endif 
9782			 
9782				endif 
9782			 
9782				; show free memory after boot 
9782 11 1c 98			ld de, freeram 
9785 3e 00			ld a, display_row_1 
9787 cd 88 8a			call str_at_display 
978a			 
978a			; Or use heap_size word???? 
978a 21 b1 e2			ld hl, heap_end 
978d 11 d9 e2			ld de, heap_start 
9790 ed 52			sbc hl, de 
9792 e5				push hl 
9793 7c				ld a,h	         	 
9794 21 d0 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9797 cd a3 8f			call hexout 
979a e1			   	pop hl 
979b			 
979b 7d				ld a,l 
979c 21 d2 e5			ld hl, os_word_scratch+2 
979f cd a3 8f			call hexout 
97a2 21 d4 e5			ld hl, os_word_scratch+4 
97a5 3e 00			ld a, 0 
97a7 77				ld (hl),a 
97a8 11 d0 e5			ld de, os_word_scratch 
97ab 3e 0d			ld a, display_row_1 + 13 
97ad cd 88 8a			call str_at_display 
97b0 cd 98 8a			call update_display 
97b3			 
97b3			 
97b3				;call demo 
97b3			 
97b3			 
97b3				; init scratch input area for cli commands 
97b3			 
97b3 21 f2 e5			ld hl, os_cli_cmd 
97b6 3e 00			ld a,0 
97b8 77				ld (hl),a 
97b9 23				inc hl 
97ba 77				ld (hl),a 
97bb			 
97bb 3e 00			ld a,0 
97bd 32 f1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97c0			 
97c0 32 ee e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c3 32 ef e5			ld (os_cur_ptr+1),a	 
97c6			 
97c6 32 d0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c9 32 d1 e5			ld (os_word_scratch+1),a	 
97cc				 
97cc			 
97cc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cc 21 f2 e5			ld hl, os_cli_cmd 
97cf			 
97cf 3e 00			ld a, 0		 ; init cli input 
97d1 77				ld (hl), a 
97d2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d4			cli: 
97d4				; show cli prompt 
97d4				;push af 
97d4				;ld a, 0 
97d4				;ld de, prompt 
97d4				;call str_at_display 
97d4			 
97d4				;call update_display 
97d4				;pop af 
97d4				;inc a 
97d4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d4 0e 00			ld c, 0 
97d6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d8 1e 28			ld e, 40 
97da			 
97da 21 f2 e5			ld hl, os_cli_cmd 
97dd			 
97dd				STACKFRAME OFF $fefe $9f9f 
97dd				if DEBUG_STACK_IMB 
97dd					if OFF 
97dd						exx 
97dd						ld de, $fefe 
97dd						ld a, d 
97dd						ld hl, curframe 
97dd						call hexout 
97dd						ld a, e 
97dd						ld hl, curframe+2 
97dd						call hexout 
97dd						ld hl, $fefe 
97dd						push hl 
97dd						ld hl, $9f9f 
97dd						push hl 
97dd						exx 
97dd					endif 
97dd				endif 
97dd			endm 
# End of macro STACKFRAME
97dd			 
97dd cd cf 8c			call input_str 
97e0			 
97e0				STACKFRAMECHK OFF $fefe $9f9f 
97e0				if DEBUG_STACK_IMB 
97e0					if OFF 
97e0						exx 
97e0						ld hl, $9f9f 
97e0						pop de   ; $9f9f 
97e0						call cmp16 
97e0						jr nz, .spnosame 
97e0						ld hl, $fefe 
97e0						pop de   ; $fefe 
97e0						call cmp16 
97e0						jr z, .spfrsame 
97e0						.spnosame: call showsperror 
97e0						.spfrsame: nop 
97e0						exx 
97e0					endif 
97e0				endif 
97e0			endm 
# End of macro STACKFRAMECHK
97e0			 
97e0				; copy input to last command 
97e0			 
97e0 21 f2 e5			ld hl, os_cli_cmd 
97e3 11 f1 e6			ld de, os_last_cmd 
97e6 01 ff 00			ld bc, 255 
97e9 ed b0			ldir 
97eb			 
97eb				; wipe current buffer 
97eb			 
97eb			;	ld a, 0 
97eb			;	ld hl, os_cli_cmd 
97eb			;	ld de, os_cli_cmd+1 
97eb			;	ld bc, 254 
97eb			;	ldir 
97eb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97eb			;	call strcpy 
97eb			;	ld a, 0 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			 
97eb				; switch frame buffer to program  
97eb			 
97eb 21 16 ed				ld hl, display_fb1 
97ee 22 d2 eb				ld (display_fb_active), hl 
97f1			 
97f1			;	nop 
97f1				STACKFRAME ON $fbfe $8f9f 
97f1				if DEBUG_STACK_IMB 
97f1					if ON 
97f1						exx 
97f1						ld de, $fbfe 
97f1						ld a, d 
97f1						ld hl, curframe 
97f1						call hexout 
97f1						ld a, e 
97f1						ld hl, curframe+2 
97f1						call hexout 
97f1						ld hl, $fbfe 
97f1						push hl 
97f1						ld hl, $8f9f 
97f1						push hl 
97f1						exx 
97f1					endif 
97f1				endif 
97f1			endm 
# End of macro STACKFRAME
97f1				; first time into the parser so pass over the current scratch pad 
97f1 21 f2 e5			ld hl,os_cli_cmd 
97f4				; tokenise the entered statement(s) in HL 
97f4 cd 0f 9f			call forthparse 
97f7			        ; exec forth statements in top of return stack 
97f7 cd 4f 9f			call forthexec 
97fa				;call forthexec_cleanup 
97fa			;	call parsenext 
97fa			 
97fa				STACKFRAMECHK ON $fbfe $8f9f 
97fa				if DEBUG_STACK_IMB 
97fa					if ON 
97fa						exx 
97fa						ld hl, $8f9f 
97fa						pop de   ; $8f9f 
97fa						call cmp16 
97fa						jr nz, .spnosame 
97fa						ld hl, $fbfe 
97fa						pop de   ; $fbfe 
97fa						call cmp16 
97fa						jr z, .spfrsame 
97fa						.spnosame: call showsperror 
97fa						.spfrsame: nop 
97fa						exx 
97fa					endif 
97fa				endif 
97fa			endm 
# End of macro STACKFRAMECHK
97fa				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97fa			 
97fa 3e 78			ld a, display_row_4 
97fc 11 2e 98			ld de, endprog 
97ff			 
97ff cd 98 8a			call update_display		 
9802			 
9802 cd 8c 9a			call next_page_prompt 
9805			 
9805				; switch frame buffer to cli 
9805			 
9805 21 b7 ed				ld hl, display_fb0 
9808 22 d2 eb				ld (display_fb_active), hl 
980b			 
980b			 
980b cd 75 8a		        call clear_display 
980e cd 98 8a			call update_display		 
9811			 
9811 21 f2 e5			ld hl, os_cli_cmd 
9814			 
9814 3e 00			ld a, 0		 ; init cli input 
9816 77				ld (hl), a 
9817			 
9817				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9817			 
9817				; now on last line 
9817			 
9817				; TODO scroll screen up 
9817			 
9817				; TODO instead just clear screen and place at top of screen 
9817			 
9817			;	ld a, 0 
9817			;	ld (f_cursor_ptr),a 
9817			 
9817				;call clear_display 
9817				;call update_display 
9817			 
9817				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9817 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9819 c3 d4 97			jp cli 
981c			 
981c .. 00		freeram: db "Free bytes: $",0 
982a ..			asc: db "1A2F" 
982e .. 00		endprog: db "End prog...",0 
983a			 
983a			testenter2:   
983a 21 fd e2			ld hl,scratch+50 
983d 22 ee e5			ld (os_cur_ptr),hl 
9840 c3 d4 97			jp cli 
9843			 
9843			testenter:  
9843			 
9843 21 2a 98			ld hl,asc 
9846			;	ld a,(hl) 
9846			;	call nibble2val 
9846 cd f9 8f			call get_byte 
9849			 
9849			 
9849			;	ld a,(hl) 
9849			;	call atohex 
9849			 
9849			;	call fourehexhl 
9849 32 fd e2			ld (scratch+50),a 
984c			 
984c			 
984c			 
984c 21 2c 98			ld hl,asc+2 
984f			;	ld a, (hl) 
984f			;	call nibble2val 
984f cd f9 8f			call get_byte 
9852			 
9852			;	call fourehexhl 
9852 32 ff e2			ld (scratch+52),a 
9855				 
9855 21 fd e2			ld hl,scratch+50 
9858 22 ee e5			ld (os_cur_ptr),hl 
985b c3 d4 97			jp cli 
985e			 
985e			enter:	 
985e 3a cf e2			ld a,(scratch+4) 
9861 fe 00			cp 0 
9863 28 0c			jr z, .entercont 
9865				; no, not a null term line so has an address to work out.... 
9865			 
9865 21 cd e2			ld hl,scratch+2 
9868 cd 59 90			call get_word_hl 
986b			 
986b 22 ee e5			ld (os_cur_ptr),hl	 
986e c3 d4 97			jp cli 
9871			 
9871			 
9871			.entercont:  
9871			 
9871 21 cd e2			ld hl, scratch+2 
9874 cd f9 8f			call get_byte 
9877			 
9877 2a ee e5		   	ld hl,(os_cur_ptr) 
987a 77					ld (hl),a 
987b 23					inc hl 
987c 22 ee e5				ld (os_cur_ptr),hl 
987f				 
987f			; get byte  
987f			 
987f			 
987f c3 d4 97			jp cli 
9882			 
9882			 
9882			; basic monitor support 
9882			 
9882			monitor: 
9882				;  
9882 cd 75 8a			call clear_display 
9885 3e 00			ld a, 0 
9887 11 cf 98			ld de, .monprompt 
988a cd 88 8a			call str_at_display 
988d cd 98 8a			call update_display 
9890			 
9890				; get a monitor command 
9890			 
9890 0e 00			ld c, 0     ; entry at top left 
9892 16 64			ld d, 100   ; max buffer size 
9894 1e 0f			ld e, 15    ; input scroll area 
9896 3e 00			ld a, 0     ; init string 
9898 21 c9 e4			ld hl, os_input 
989b 77				ld (hl), a 
989c 23				inc hl 
989d 77				ld (hl), a 
989e 21 c9 e4			ld hl, os_input 
98a1 3e 01			ld a, 1     ; init string 
98a3 cd cf 8c			call input_str 
98a6			 
98a6 cd 75 8a		        call clear_display 
98a9 cd 98 8a			call update_display		 
98ac			 
98ac 3a c9 e4			ld a, (os_input) 
98af cd f7 90			call toUpper 
98b2 fe 48		        cp 'H' 
98b4 28 6f		        jr z, .monhelp 
98b6 fe 44			cp 'D'		; dump 
98b8 ca 46 99			jp z, .mondump	 
98bb fe 43			cp 'C'		; dump 
98bd ca 60 99			jp z, .moncdump	 
98c0 fe 4d			cp 'M'		; dump 
98c2 ca d1 98			jp z, .moneditstart 
98c5 fe 55			cp 'U'		; dump 
98c7 28 14			jr z, .monedit	 
98c9 fe 51			cp 'Q'		; dump 
98cb c8				ret z	 
98cc			 
98cc			 
98cc				; TODO "S" to access symbol by name and not need the address 
98cc				; TODO "F" to find a string in memory 
98cc			 
98cc c3 82 98			jp monitor 
98cf			 
98cf .. 00		.monprompt: db ">", 0 
98d1			 
98d1			.moneditstart: 
98d1				; get starting address 
98d1			 
98d1 21 cb e4			ld hl,os_input+2 
98d4 cd 59 90			call get_word_hl 
98d7			 
98d7 22 ee e5			ld (os_cur_ptr),hl	 
98da			 
98da c3 82 98			jp monitor 
98dd			 
98dd			.monedit: 
98dd				; get byte to load 
98dd			 
98dd 21 cb e4			ld hl,os_input+2 
98e0 cd f9 8f			call get_byte 
98e3			 
98e3				; get address to update 
98e3 2a ee e5			ld hl, (os_cur_ptr) 
98e6			 
98e6				; update byte 
98e6			 
98e6 77				ld (hl), a 
98e7			 
98e7				; move to next address and save it 
98e7			 
98e7 23				inc hl 
98e8 22 ee e5			ld (os_cur_ptr),hl	 
98eb			 
98eb c3 82 98			jp monitor 
98ee			 
98ee			 
98ee .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9902 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
991e .. 00		.monhelptext3:  db "Q-Quit",0 
9925			        
9925			.monhelp: 
9925 3e 00			ld a, display_row_1 
9927 11 ee 98		        ld de, .monhelptext1 
992a			 
992a cd 88 8a			call str_at_display 
992d 3e 28			ld a, display_row_2 
992f 11 02 99		        ld de, .monhelptext2 
9932					 
9932 cd 88 8a			call str_at_display 
9935 3e 50			ld a, display_row_3 
9937 11 1e 99		        ld de, .monhelptext3 
993a					 
993a cd 88 8a			call str_at_display 
993d cd 98 8a			call update_display		 
9940			 
9940 cd 8c 9a			call next_page_prompt 
9943 c3 82 98			jp monitor 
9946			 
9946			.mondump:    
9946 21 cb e4			ld hl,os_input+2 
9949 cd 59 90			call get_word_hl 
994c			 
994c 22 ee e5			ld (os_cur_ptr),hl	 
994f cd 94 99			call dumpcont 
9952 3e 78			ld a, display_row_4 
9954 11 2e 98			ld de, endprog 
9957			 
9957 cd 98 8a			call update_display		 
995a			 
995a cd 8c 9a			call next_page_prompt 
995d c3 82 98			jp monitor 
9960			.moncdump: 
9960 cd 94 99			call dumpcont 
9963 3e 78			ld a, display_row_4 
9965 11 2e 98			ld de, endprog 
9968			 
9968 cd 98 8a			call update_display		 
996b			 
996b cd 8c 9a			call next_page_prompt 
996e c3 82 98			jp monitor 
9971			 
9971			 
9971			; TODO symbol access  
9971			 
9971			.symbols:     ;; A list of symbols that can be called up  
9971 b7 ed			dw display_fb0 
9973 .. 00			db "fb0",0  
9977 84 ea		     	dw store_page 
9979 .. 00			db "store_page",0 
9984			 
9984			 
9984			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9984			 
9984 3a cc e2			ld a,(scratch+1) 
9987 fe 00			cp 0 
9989 28 09			jr z, dumpcont 
998b			 
998b				; no, not a null term line so has an address to work out.... 
998b			 
998b 21 cd e2			ld hl,scratch+2 
998e cd 59 90			call get_word_hl 
9991			 
9991 22 ee e5			ld (os_cur_ptr),hl	 
9994			 
9994			 
9994			 
9994			dumpcont: 
9994			 
9994				; dump bytes at ptr 
9994			 
9994			 
9994 3e 00			ld a, display_row_1 
9996 2a d2 eb			ld hl, (display_fb_active) 
9999 cd a2 8c			call addatohl 
999c cd c4 99			call .dumpbyterow 
999f			 
999f 3e 28			ld a, display_row_2 
99a1 2a d2 eb			ld hl, (display_fb_active) 
99a4 cd a2 8c			call addatohl 
99a7 cd c4 99			call .dumpbyterow 
99aa			 
99aa			 
99aa 3e 50			ld a, display_row_3 
99ac 2a d2 eb			ld hl, (display_fb_active) 
99af cd a2 8c			call addatohl 
99b2 cd c4 99			call .dumpbyterow 
99b5			 
99b5 3e 78			ld a, display_row_4 
99b7 2a d2 eb			ld hl, (display_fb_active) 
99ba cd a2 8c			call addatohl 
99bd cd c4 99			call .dumpbyterow 
99c0			 
99c0 cd 98 8a			call update_display 
99c3			;		jp cli 
99c3 c9				ret 
99c4			 
99c4			.dumpbyterow: 
99c4			 
99c4				;push af 
99c4			 
99c4 e5				push hl 
99c5			 
99c5				; calc where to poke the ascii 
99c5			if display_cols == 20 
99c5				ld a, 16 
99c5			else 
99c5 3e 1f			ld a, 31 
99c7			endif 
99c7			 
99c7 cd a2 8c			call addatohl 
99ca 22 d0 e5			ld (os_word_scratch),hl  		; save pos for later 
99cd			 
99cd			 
99cd			; display decoding address 
99cd 2a ee e5		   	ld hl,(os_cur_ptr) 
99d0			 
99d0 7c				ld a,h 
99d1 e1				pop hl 
99d2 e5				push hl 
99d3			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99d3 cd a3 8f			call hexout 
99d6 2a ee e5		   	ld hl,(os_cur_ptr) 
99d9			 
99d9 7d				ld a,l 
99da e1				pop hl 
99db 23				inc hl 
99dc 23				inc hl 
99dd e5				push hl 
99de			;	ld hl, os_word_scratch+2 
99de cd a3 8f			call hexout 
99e1 e1				pop hl 
99e2 23				inc hl 
99e3 23				inc hl 
99e4				;ld hl, os_word_scratch+4 
99e4 3e 3a			ld a, ':' 
99e6 77				ld (hl),a 
99e7 23				inc hl 
99e8				;ld a, 0 
99e8				;ld (hl),a 
99e8				;ld de, os_word_scratch 
99e8				;pop af 
99e8				;push af 
99e8			;		ld a, display_row_2 
99e8			;		call str_at_display 
99e8			;		call update_display 
99e8			 
99e8			 
99e8			;pop af 
99e8			;	add 5 
99e8			 
99e8			if display_cols == 20 
99e8				ld b, 4 
99e8			else 
99e8 06 08			ld b, 8 
99ea			endif	 
99ea			 
99ea			.dumpbyte: 
99ea c5				push bc 
99eb e5				push hl 
99ec			 
99ec			 
99ec 2a ee e5		   	ld hl,(os_cur_ptr) 
99ef 7e					ld a,(hl) 
99f0			 
99f0					; poke the ascii to display 
99f0 2a d0 e5				ld hl,(os_word_scratch) 
99f3 77					ld (hl),a 
99f4 23					inc hl 
99f5 22 d0 e5				ld (os_word_scratch),hl 
99f8			 
99f8					 
99f8			 
99f8			 
99f8 e1					pop hl 
99f9 e5					push hl 
99fa			 
99fa cd a3 8f				call hexout 
99fd			 
99fd					 
99fd 2a ee e5		   	ld hl,(os_cur_ptr) 
9a00 23				inc hl 
9a01 22 ee e5		   	ld (os_cur_ptr),hl 
9a04			 
9a04 e1					pop hl 
9a05 23					inc hl 
9a06 23					inc hl 
9a07 23					inc hl 
9a08			 
9a08			 
9a08			 
9a08					;ld a,0 
9a08					;ld (os_word_scratch+2),a 
9a08					;pop af 
9a08					;push af 
9a08			 
9a08					;ld de, os_word_scratch 
9a08					;call str_at_display 
9a08			;		call update_display 
9a08			;		pop af 
9a08 c1					pop bc 
9a09 c6 03				add 3 
9a0b 10 dd			djnz .dumpbyte 
9a0d			 
9a0d				 
9a0d			 
9a0d c9				ret 
9a0e			 
9a0e			jump:	 
9a0e			 
9a0e 21 cd e2			ld hl,scratch+2 
9a11 cd 59 90			call get_word_hl 
9a14				;ld hl,(scratch+2) 
9a14				;call fourehexhl 
9a14			 
9a14 22 ee e5			ld (os_cur_ptr),hl	 
9a17			 
9a17 e9				jp (hl) 
9a18			 
9a18			 
9a18			 
9a18			; TODO implement a basic monitor mode to start with 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			 
9a18			; testing and demo code during development 
9a18			 
9a18			 
9a18 .. 00		str1: db "Enter some text...",0 
9a2b .. 00		clear: db "                    ",0 
9a40			 
9a40			demo: 
9a40			 
9a40			 
9a40			 
9a40			;	call update_display 
9a40			 
9a40				; init scratch input area for testing 
9a40 21 cb e2			ld hl, scratch	 
9a43 3e 00			ld a,0 
9a45 77				ld (hl),a 
9a46			 
9a46			 
9a46 3e 28		            LD   A, display_row_2 
9a48			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a48 11 18 9a		            LD   DE, str1 
9a4b cd 88 8a			call str_at_display 
9a4e			 
9a4e			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a4e			cloop:	 
9a4e 3e 50		            LD   A, display_row_3 
9a50			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a50 11 2b 9a		            LD   DE, clear 
9a53			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a53 cd 88 8a				call str_at_display 
9a56 3e 78			ld a, display_row_4 
9a58 11 88 9a			ld de, prompt 
9a5b			 
9a5b cd 88 8a				call str_at_display 
9a5e cd 98 8a			call update_display 
9a61			 
9a61 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a63 16 0a			ld d, 10 
9a65 21 cb e2			ld hl, scratch	 
9a68 cd cf 8c			call input_str 
9a6b			 
9a6b			;	call clear_display 
9a6b			;'	call update_display 
9a6b			 
9a6b 3e 00		            LD   A, display_row_1 
9a6d			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6d 11 2b 9a		            LD   DE, clear 
9a70 cd 88 8a				call str_at_display 
9a73			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a73 3e 00		            LD   A, display_row_1 
9a75			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a75 11 cb e2		            LD   DE, scratch 
9a78			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a78 cd 88 8a				call str_at_display 
9a7b cd 98 8a			call update_display 
9a7e			 
9a7e 3e 00				ld a,0 
9a80 21 cb e2			ld hl, scratch 
9a83 77				ld (hl),a 
9a84			 
9a84 00				nop 
9a85 c3 4e 9a			jp cloop 
9a88			 
9a88			 
9a88			 
9a88			; OS Prompt 
9a88			 
9a88 .. 00		prompt: db ">",0 
9a8a .. 00		endprg: db "?",0 
9a8c			 
9a8c			 
9a8c			; handy next page prompt 
9a8c			next_page_prompt: 
9a8c e5				push hl 
9a8d d5				push de 
9a8e f5				push af 
9a8f c5				push bc 
9a90			 
9a90 3e 9f			ld a,display_row_4 + display_cols - 1 
9a92 11 8a 9a		        ld de, endprg 
9a95 cd 88 8a			call str_at_display 
9a98 cd 98 8a			call update_display 
9a9b cd b5 e2			call cin_wait 
9a9e c1				pop bc 
9a9f f1				pop af 
9aa0 d1				pop de 
9aa1 e1				pop hl 
9aa2			 
9aa2			 
9aa2 c9				ret 
9aa3			 
9aa3			 
9aa3			; forth parser 
9aa3			 
9aa3			; My forth kernel 
9aa3			include "forth_kernel.asm" 
9aa3			; 
9aa3			; kernel to the forth OS 
9aa3			 
9aa3			DS_TYPE_STR: equ 1     ; string type 
9aa3			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9aa3			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9aa3			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9aa3			 
9aa3			FORTH_PARSEV1: equ 0 
9aa3			FORTH_PARSEV2: equ 0 
9aa3			FORTH_PARSEV3: equ 0 
9aa3			FORTH_PARSEV4: equ 0 
9aa3			FORTH_PARSEV5: equ 1 
9aa3			 
9aa3			;if FORTH_PARSEV5 
9aa3			;	FORTH_END_BUFFER: equ 0 
9aa3			;else 
9aa3			FORTH_END_BUFFER: equ 127 
9aa3			;endif 
9aa3			 
9aa3			FORTH_TRUE: equ 1 
9aa3			FORTH_FALSE: equ 0 
9aa3			 
9aa3			if FORTH_PARSEV4 
9aa3			include "forth_stackops.asm" 
9aa3			endif 
9aa3			 
9aa3			if FORTH_PARSEV5 
9aa3			include "forth_stackopsv5.asm" 
9aa3			 
9aa3			; Stack operations for v5 parser on wards 
9aa3			; * DATA stack 
9aa3			; * LOOP stack 
9aa3			; * RETURN stack 
9aa3			 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_DSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_data_sp) 
9aa3				ld de, cli_data_stack 
9aa3				call cmp16 
9aa3				jp c, fault_dsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			FORTH_CHK_RSP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_ret_sp) 
9aa3				ld de, cli_ret_stack 
9aa3				call cmp16 
9aa3				jp c, fault_rsp_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_CHK_LOOP_UNDER: macro 
9aa3				push hl 
9aa3				push de 
9aa3				ld hl,(cli_loop_sp) 
9aa3				ld de, cli_loop_stack 
9aa3				call cmp16 
9aa3				jp c, fault_loop_under 
9aa3				pop de 
9aa3				pop hl 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTSTR: macro 
9aa3				; TOSO might need more for checks when used 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_STR 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			FORTH_ERR_TOS_NOTNUM: macro 
9aa3				push af 
9aa3				ld a,(hl) 
9aa3				cp DS_TYPE_INUM 
9aa3				jp nz, type_faultn   
9aa3				pop af 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			; increase data stack pointer and save hl to it 
9aa3				 
9aa3			FORTH_DSP_NEXT: macro 
9aa3				call macro_forth_dsp_next 
9aa3				endm 
9aa3			 
9aa3			 
9aa3			macro_forth_dsp_next: 
9aa3				if DEBUG_FORTH_STACK_GUARD 
9aa3 cd 43 df				call check_stacks 
9aa6				endif 
9aa6 e5				push hl 
9aa7 d5				push de 
9aa8 eb				ex de,hl 
9aa9 2a f8 e9			ld hl,(cli_data_sp) 
9aac 23				inc hl 
9aad 23				inc hl 
9aae			 
9aae			; PARSEV5 
9aae 23				inc hl 
9aaf 22 f8 e9			ld (cli_data_sp),hl 
9ab2 73				ld (hl), e 
9ab3 23				inc hl 
9ab4 72				ld (hl), d 
9ab5 d1				pop de 
9ab6 e1				pop hl 
9ab7				if DEBUG_FORTH_STACK_GUARD 
9ab7 cd 43 df				call check_stacks 
9aba				endif 
9aba c9				ret 
9abb			 
9abb			 
9abb			; increase ret stack pointer and save hl to it 
9abb				 
9abb			FORTH_RSP_NEXT: macro 
9abb				call macro_forth_rsp_next 
9abb				endm 
9abb			 
9abb			macro_forth_rsp_next: 
9abb				if DEBUG_FORTH_STACK_GUARD 
9abb cd 43 df				call check_stacks 
9abe				endif 
9abe e5				push hl 
9abf d5				push de 
9ac0 eb				ex de,hl 
9ac1 2a fc e9			ld hl,(cli_ret_sp) 
9ac4 23				inc hl 
9ac5 23				inc hl 
9ac6 22 fc e9			ld (cli_ret_sp),hl 
9ac9 73				ld (hl), e 
9aca 23				inc hl 
9acb 72				ld (hl), d 
9acc d1				pop de 
9acd e1				pop hl 
9ace				if DEBUG_FORTH_STACK_GUARD 
9ace cd 43 df				call check_stacks 
9ad1				endif 
9ad1 c9				ret 
9ad2			 
9ad2			; get current ret stack pointer and save to hl  
9ad2				 
9ad2			FORTH_RSP_TOS: macro 
9ad2				call macro_forth_rsp_tos 
9ad2				endm 
9ad2			 
9ad2			macro_forth_rsp_tos: 
9ad2				;push de 
9ad2 2a fc e9			ld hl,(cli_ret_sp) 
9ad5 cd 0d 9b			call loadhlptrtohl 
9ad8				;ld e, (hl) 
9ad8				;inc hl 
9ad8				;ld d, (hl) 
9ad8				;ex de, hl 
9ad8					if DEBUG_FORTH_WORDS 
9ad8			;			DMARK "RST" 
9ad8						CALLMONITOR 
9ad8 cd a3 94			call break_point_state  
9adb				endm  
# End of macro CALLMONITOR
9adb					endif 
9adb				;pop de 
9adb c9				ret 
9adc			 
9adc			; pop ret stack pointer 
9adc				 
9adc			FORTH_RSP_POP: macro 
9adc				call macro_forth_rsp_pop 
9adc				endm 
9adc			 
9adc			 
9adc			macro_forth_rsp_pop: 
9adc				if DEBUG_FORTH_STACK_GUARD 
9adc			;		DMARK "RPP" 
9adc cd 43 df				call check_stacks 
9adf					FORTH_CHK_RSP_UNDER 
9adf e5				push hl 
9ae0 d5				push de 
9ae1 2a fc e9			ld hl,(cli_ret_sp) 
9ae4 11 b6 e9			ld de, cli_ret_stack 
9ae7 cd c0 8c			call cmp16 
9aea da 57 e0			jp c, fault_rsp_under 
9aed d1				pop de 
9aee e1				pop hl 
9aef				endm 
# End of macro FORTH_CHK_RSP_UNDER
9aef				endif 
9aef e5				push hl 
9af0 2a fc e9			ld hl,(cli_ret_sp) 
9af3			 
9af3			 
9af3				if FORTH_ENABLE_FREE 
9af3			 
9af3					; get pointer 
9af3			 
9af3					push de 
9af3					push hl 
9af3			 
9af3					ld e, (hl) 
9af3					inc hl 
9af3					ld d, (hl) 
9af3			 
9af3					ex de, hl 
9af3					call free 
9af3			 
9af3					pop hl 
9af3					pop de 
9af3			 
9af3			 
9af3				endif 
9af3			 
9af3			 
9af3 2b				dec hl 
9af4 2b				dec hl 
9af5 22 fc e9			ld (cli_ret_sp), hl 
9af8				; do stack underflow checks 
9af8 e1				pop hl 
9af9				if DEBUG_FORTH_STACK_GUARD 
9af9 cd 43 df				call check_stacks 
9afc					FORTH_CHK_RSP_UNDER 
9afc e5				push hl 
9afd d5				push de 
9afe 2a fc e9			ld hl,(cli_ret_sp) 
9b01 11 b6 e9			ld de, cli_ret_stack 
9b04 cd c0 8c			call cmp16 
9b07 da 57 e0			jp c, fault_rsp_under 
9b0a d1				pop de 
9b0b e1				pop hl 
9b0c				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b0c				endif 
9b0c c9				ret 
9b0d			 
9b0d			 
9b0d			 
9b0d			; routine to load word pointed to by hl into hl 
9b0d			 
9b0d			loadhlptrtohl: 
9b0d			 
9b0d d5				push de 
9b0e 5e				ld e, (hl) 
9b0f 23				inc hl 
9b10 56				ld d, (hl) 
9b11 eb				ex de, hl 
9b12 d1				pop de 
9b13			 
9b13 c9				ret 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			 
9b14			; push a number held in HL onto the data stack 
9b14			; entry point for pushing a value when already in hl used in function above 
9b14			 
9b14			forth_push_numhl: 
9b14			 
9b14 e5				push hl    ; save value to push 
9b15			 
9b15			if DEBUG_FORTH_PUSH 
9b15				; see if disabled 
9b15			 
9b15			 
9b15 f5				push af 
9b16 3a bc e2			ld a, (os_view_disable) 
9b19 fe 2a			cp '*' 
9b1b 28 34			jr z, .pskip2 
9b1d e5				push hl 
9b1e e5			push hl 
9b1f cd 75 8a			call clear_display 
9b22 e1			pop hl 
9b23 7c				ld a,h 
9b24 21 d0 e5			ld hl, os_word_scratch 
9b27 cd a3 8f			call hexout 
9b2a e1				pop hl 
9b2b 7d				ld a,l 
9b2c 21 d2 e5			ld hl, os_word_scratch+2 
9b2f cd a3 8f			call hexout 
9b32			 
9b32 21 d4 e5			ld hl, os_word_scratch+4 
9b35 3e 00			ld a,0 
9b37 77				ld (hl),a 
9b38 11 d0 e5			ld de,os_word_scratch 
9b3b 3e 28				ld a, display_row_2 
9b3d cd 88 8a				call str_at_display 
9b40 11 28 cb			ld de, .push_num 
9b43 3e 00			ld a, display_row_1 
9b45			 
9b45 cd 88 8a				call str_at_display 
9b48			 
9b48			 
9b48 cd 98 8a			call update_display 
9b4b cd f2 89			call delay1s 
9b4e cd f2 89			call delay1s 
9b51			.pskip2:  
9b51			 
9b51 f1				pop af 
9b52			endif	 
9b52			 
9b52			 
9b52				FORTH_DSP_NEXT 
9b52 cd a3 9a			call macro_forth_dsp_next 
9b55				endm 
# End of macro FORTH_DSP_NEXT
9b55			 
9b55 2a f8 e9			ld hl, (cli_data_sp) 
9b58			 
9b58				; save item type 
9b58 3e 02			ld a,  DS_TYPE_INUM 
9b5a 77				ld (hl), a 
9b5b 23				inc hl 
9b5c			 
9b5c				; get word off stack 
9b5c d1				pop de 
9b5d 7b				ld a,e 
9b5e 77				ld (hl), a 
9b5f 23				inc hl 
9b60 7a				ld a,d 
9b61 77				ld (hl), a 
9b62			 
9b62			if DEBUG_FORTH_PUSH 
9b62 2b				dec hl 
9b63 2b				dec hl 
9b64 2b				dec hl 
9b65						DMARK "PH5" 
9b65 f5				push af  
9b66 3a 7a 9b			ld a, (.dmark)  
9b69 32 71 ee			ld (debug_mark),a  
9b6c 3a 7b 9b			ld a, (.dmark+1)  
9b6f 32 72 ee			ld (debug_mark+1),a  
9b72 3a 7c 9b			ld a, (.dmark+2)  
9b75 32 73 ee			ld (debug_mark+2),a  
9b78 18 03			jr .pastdmark  
9b7a ..			.dmark: db "PH5"  
9b7d f1			.pastdmark: pop af  
9b7e			endm  
# End of macro DMARK
9b7e				CALLMONITOR 
9b7e cd a3 94			call break_point_state  
9b81				endm  
# End of macro CALLMONITOR
9b81			endif	 
9b81			 
9b81 c9				ret 
9b82			 
9b82			 
9b82			; Push a string to stack pointed to by hl 
9b82			 
9b82			forth_push_str: 
9b82			 
9b82			if DEBUG_FORTH_PUSH 
9b82						DMARK "PSQ" 
9b82 f5				push af  
9b83 3a 97 9b			ld a, (.dmark)  
9b86 32 71 ee			ld (debug_mark),a  
9b89 3a 98 9b			ld a, (.dmark+1)  
9b8c 32 72 ee			ld (debug_mark+1),a  
9b8f 3a 99 9b			ld a, (.dmark+2)  
9b92 32 73 ee			ld (debug_mark+2),a  
9b95 18 03			jr .pastdmark  
9b97 ..			.dmark: db "PSQ"  
9b9a f1			.pastdmark: pop af  
9b9b			endm  
# End of macro DMARK
9b9b				CALLMONITOR 
9b9b cd a3 94			call break_point_state  
9b9e				endm  
# End of macro CALLMONITOR
9b9e			endif	 
9b9e			    
9b9e e5				push hl 
9b9f e5				push hl 
9ba0			 
9ba0			;	ld a, 0   ; find end of string 
9ba0 cd 00 91			call strlenz 
9ba3			if DEBUG_FORTH_PUSH 
9ba3						DMARK "PQ2" 
9ba3 f5				push af  
9ba4 3a b8 9b			ld a, (.dmark)  
9ba7 32 71 ee			ld (debug_mark),a  
9baa 3a b9 9b			ld a, (.dmark+1)  
9bad 32 72 ee			ld (debug_mark+1),a  
9bb0 3a ba 9b			ld a, (.dmark+2)  
9bb3 32 73 ee			ld (debug_mark+2),a  
9bb6 18 03			jr .pastdmark  
9bb8 ..			.dmark: db "PQ2"  
9bbb f1			.pastdmark: pop af  
9bbc			endm  
# End of macro DMARK
9bbc				CALLMONITOR 
9bbc cd a3 94			call break_point_state  
9bbf				endm  
# End of macro CALLMONITOR
9bbf			endif	 
9bbf eb				ex de, hl 
9bc0 e1				pop hl   ; get ptr to start of string 
9bc1			if DEBUG_FORTH_PUSH 
9bc1						DMARK "PQ3" 
9bc1 f5				push af  
9bc2 3a d6 9b			ld a, (.dmark)  
9bc5 32 71 ee			ld (debug_mark),a  
9bc8 3a d7 9b			ld a, (.dmark+1)  
9bcb 32 72 ee			ld (debug_mark+1),a  
9bce 3a d8 9b			ld a, (.dmark+2)  
9bd1 32 73 ee			ld (debug_mark+2),a  
9bd4 18 03			jr .pastdmark  
9bd6 ..			.dmark: db "PQ3"  
9bd9 f1			.pastdmark: pop af  
9bda			endm  
# End of macro DMARK
9bda				CALLMONITOR 
9bda cd a3 94			call break_point_state  
9bdd				endm  
# End of macro CALLMONITOR
9bdd			endif	 
9bdd 19				add hl,de 
9bde			if DEBUG_FORTH_PUSH 
9bde						DMARK "PQE" 
9bde f5				push af  
9bdf 3a f3 9b			ld a, (.dmark)  
9be2 32 71 ee			ld (debug_mark),a  
9be5 3a f4 9b			ld a, (.dmark+1)  
9be8 32 72 ee			ld (debug_mark+1),a  
9beb 3a f5 9b			ld a, (.dmark+2)  
9bee 32 73 ee			ld (debug_mark+2),a  
9bf1 18 03			jr .pastdmark  
9bf3 ..			.dmark: db "PQE"  
9bf6 f1			.pastdmark: pop af  
9bf7			endm  
# End of macro DMARK
9bf7				CALLMONITOR 
9bf7 cd a3 94			call break_point_state  
9bfa				endm  
# End of macro CALLMONITOR
9bfa			endif	 
9bfa			 
9bfa 2b				dec hl    ; see if there is an optional trailing double quote 
9bfb 7e				ld a,(hl) 
9bfc fe 22			cp '"' 
9bfe 20 03			jr nz, .strnoq 
9c00 3e 00			ld a, 0      ; get rid of double quote 
9c02 77				ld (hl), a 
9c03 23			.strnoq: inc hl 
9c04			 
9c04 3e 00			ld a, 0 
9c06 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c07			 
9c07 13				inc de ; add one for the type string 
9c08 13				inc de ; add one for null term??? 
9c09			 
9c09				; tos is get string pointer again 
9c09				; de contains space to allocate 
9c09				 
9c09 d5				push de 
9c0a			 
9c0a eb				ex de, hl 
9c0b			 
9c0b				;push af 
9c0b			 
9c0b			if DEBUG_FORTH_PUSH 
9c0b						DMARK "PHm" 
9c0b f5				push af  
9c0c 3a 20 9c			ld a, (.dmark)  
9c0f 32 71 ee			ld (debug_mark),a  
9c12 3a 21 9c			ld a, (.dmark+1)  
9c15 32 72 ee			ld (debug_mark+1),a  
9c18 3a 22 9c			ld a, (.dmark+2)  
9c1b 32 73 ee			ld (debug_mark+2),a  
9c1e 18 03			jr .pastdmark  
9c20 ..			.dmark: db "PHm"  
9c23 f1			.pastdmark: pop af  
9c24			endm  
# End of macro DMARK
9c24				CALLMONITOR 
9c24 cd a3 94			call break_point_state  
9c27				endm  
# End of macro CALLMONITOR
9c27			endif	 
9c27 cd 69 91			call malloc	; on ret hl now contains allocated memory 
9c2a				if DEBUG_FORTH_MALLOC_GUARD 
9c2a cc 80 cb				call z,malloc_error 
9c2d				endif 
9c2d			 
9c2d				 
9c2d c1				pop bc    ; get length 
9c2e d1				pop de   ;  get string start    
9c2f			 
9c2f				; hl has destination from malloc 
9c2f			 
9c2f eb				ex de, hl    ; prep for ldir 
9c30			 
9c30 d5				push de   ; save malloc area for DSP later 
9c31				;push hl   ; save malloc area for DSP later 
9c31			 
9c31			if DEBUG_FORTH_PUSH 
9c31						DMARK "PHc" 
9c31 f5				push af  
9c32 3a 46 9c			ld a, (.dmark)  
9c35 32 71 ee			ld (debug_mark),a  
9c38 3a 47 9c			ld a, (.dmark+1)  
9c3b 32 72 ee			ld (debug_mark+1),a  
9c3e 3a 48 9c			ld a, (.dmark+2)  
9c41 32 73 ee			ld (debug_mark+2),a  
9c44 18 03			jr .pastdmark  
9c46 ..			.dmark: db "PHc"  
9c49 f1			.pastdmark: pop af  
9c4a			endm  
# End of macro DMARK
9c4a				CALLMONITOR 
9c4a cd a3 94			call break_point_state  
9c4d				endm  
# End of macro CALLMONITOR
9c4d			endif	 
9c4d			 
9c4d			 
9c4d ed b0			ldir 
9c4f			 
9c4f			 
9c4f				; push malloc to data stack     macro?????  
9c4f			 
9c4f				FORTH_DSP_NEXT 
9c4f cd a3 9a			call macro_forth_dsp_next 
9c52				endm 
# End of macro FORTH_DSP_NEXT
9c52			 
9c52				; save value and type 
9c52			 
9c52 2a f8 e9			ld hl, (cli_data_sp) 
9c55			 
9c55				; save item type 
9c55 3e 01			ld a,  DS_TYPE_STR 
9c57 77				ld (hl), a 
9c58 23				inc hl 
9c59			 
9c59				; get malloc word off stack 
9c59 d1				pop de 
9c5a 73				ld (hl), e 
9c5b 23				inc hl 
9c5c 72				ld (hl), d 
9c5d			 
9c5d			 
9c5d			 
9c5d			if DEBUG_FORTH_PUSH 
9c5d 2a f8 e9			ld hl, (cli_data_sp) 
9c60						DMARK "PHS" 
9c60 f5				push af  
9c61 3a 75 9c			ld a, (.dmark)  
9c64 32 71 ee			ld (debug_mark),a  
9c67 3a 76 9c			ld a, (.dmark+1)  
9c6a 32 72 ee			ld (debug_mark+1),a  
9c6d 3a 77 9c			ld a, (.dmark+2)  
9c70 32 73 ee			ld (debug_mark+2),a  
9c73 18 03			jr .pastdmark  
9c75 ..			.dmark: db "PHS"  
9c78 f1			.pastdmark: pop af  
9c79			endm  
# End of macro DMARK
9c79				CALLMONITOR 
9c79 cd a3 94			call break_point_state  
9c7c				endm  
# End of macro CALLMONITOR
9c7c			;	ex de,hl 
9c7c			endif	 
9c7c				; in case of spaces, skip the ptr past the copied string 
9c7c				;pop af 
9c7c				;ld (cli_origptr),hl 
9c7c			 
9c7c c9				ret 
9c7d			 
9c7d			 
9c7d			 
9c7d			; TODO ascii push input onto stack given hl to start of input 
9c7d			 
9c7d			; identify type 
9c7d			; if starts with a " then a string 
9c7d			; otherwise it is a number 
9c7d			;  
9c7d			; if a string 
9c7d			;     scan for ending " to get length of string to malloc for + 1 
9c7d			;     malloc 
9c7d			;     put pointer to string on stack first byte flags as string 
9c7d			; 
9c7d			; else a number 
9c7d			;    look for number format identifier 
9c7d			;    $xx hex 
9c7d			;    %xxxxx bin 
9c7d			;    xxxxx decimal 
9c7d			;    convert number to 16bit word.  
9c7d			;    malloc word + 1 with flag to identiy as num 
9c7d			;    put pointer to number on stack 
9c7d			;   
9c7d			;  
9c7d			  
9c7d			forth_apush: 
9c7d				; kernel push 
9c7d			 
9c7d			if DEBUG_FORTH_PUSH 
9c7d						DMARK "PSH" 
9c7d f5				push af  
9c7e 3a 92 9c			ld a, (.dmark)  
9c81 32 71 ee			ld (debug_mark),a  
9c84 3a 93 9c			ld a, (.dmark+1)  
9c87 32 72 ee			ld (debug_mark+1),a  
9c8a 3a 94 9c			ld a, (.dmark+2)  
9c8d 32 73 ee			ld (debug_mark+2),a  
9c90 18 03			jr .pastdmark  
9c92 ..			.dmark: db "PSH"  
9c95 f1			.pastdmark: pop af  
9c96			endm  
# End of macro DMARK
9c96				CALLMONITOR 
9c96 cd a3 94			call break_point_state  
9c99				endm  
# End of macro CALLMONITOR
9c99			endif	 
9c99				; identify input type 
9c99			 
9c99 7e				ld a,(hl) 
9c9a fe 22			cp '"' 
9c9c 28 0a			jr z, .fapstr 
9c9e fe 24			cp '$' 
9ca0 ca c8 9c			jp z, .faphex 
9ca3 fe 25			cp '%' 
9ca5 ca b0 9c			jp z, .fapbin 
9ca8			;	cp 'b' 
9ca8			;	jp z, .fabin 
9ca8				; else decimal 
9ca8			 
9ca8				; TODO do decimal conversion 
9ca8				; decimal is stored as a 16bit word 
9ca8			 
9ca8				; by default everything is a string if type is not detected 
9ca8			.fapstr: ; 
9ca8 fe 22			cp '"' 
9caa 20 01			jr nz, .strnoqu 
9cac 23				inc hl 
9cad			.strnoqu: 
9cad c3 82 9b			jp forth_push_str 
9cb0			 
9cb0			 
9cb0			 
9cb0			.fapbin:    ; push a binary string.  
9cb0 11 00 00			ld de, 0   ; hold a 16bit value 
9cb3			 
9cb3 23			.fapbinshift:	inc hl  
9cb4 7e				ld a,(hl) 
9cb5 fe 00			cp 0     ; done scanning  
9cb7 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cb9			 
9cb9				; left shift de 
9cb9 eb				ex de, hl	 
9cba 29				add hl, hl 
9cbb			 
9cbb				; is 1 
9cbb fe 31			cp '1' 
9cbd 20 02			jr nz, .binzero 
9cbf cb 4d			bit 1, l 
9cc1			.binzero: 
9cc1 eb				ex de, hl	 ; save current de 
9cc2 18 ef			jr .fapbinshift 
9cc4			 
9cc4			.fapbdone: 
9cc4 eb				ex de, hl 
9cc5 c3 14 9b			jp forth_push_numhl 
9cc8			 
9cc8			 
9cc8			.faphex:   ; hex is always stored as a 16bit word 
9cc8				; skip number prefix 
9cc8 23				inc hl 
9cc9				; turn ascii into number 
9cc9 cd 59 90			call get_word_hl	; ret 16bit word in hl 
9ccc			 
9ccc c3 14 9b			jp forth_push_numhl 
9ccf			 
9ccf 00				 nop 
9cd0			 
9cd0			.fabin:   ; TODO bin conversion 
9cd0			 
9cd0			 
9cd0 c9				ret 
9cd1			 
9cd1			 
9cd1			; get either a string ptr or a 16bit word from the data stack 
9cd1			 
9cd1			FORTH_DSP: macro 
9cd1				call macro_forth_dsp 
9cd1				endm 
9cd1			 
9cd1			macro_forth_dsp: 
9cd1				; data stack pointer points to current word on tos 
9cd1			 
9cd1 2a f8 e9			ld hl,(cli_data_sp) 
9cd4			 
9cd4				if DEBUG_FORTH_PUSH 
9cd4						DMARK "DSP" 
9cd4 f5				push af  
9cd5 3a e9 9c			ld a, (.dmark)  
9cd8 32 71 ee			ld (debug_mark),a  
9cdb 3a ea 9c			ld a, (.dmark+1)  
9cde 32 72 ee			ld (debug_mark+1),a  
9ce1 3a eb 9c			ld a, (.dmark+2)  
9ce4 32 73 ee			ld (debug_mark+2),a  
9ce7 18 03			jr .pastdmark  
9ce9 ..			.dmark: db "DSP"  
9cec f1			.pastdmark: pop af  
9ced			endm  
# End of macro DMARK
9ced			 
9ced cd b5 cb				call display_data_sp 
9cf0				;call break_point_state 
9cf0				;rst 030h 
9cf0				CALLMONITOR 
9cf0 cd a3 94			call break_point_state  
9cf3				endm  
# End of macro CALLMONITOR
9cf3				endif 
9cf3			 
9cf3 c9				ret 
9cf4			 
9cf4			; return hl to start of value on stack 
9cf4			 
9cf4			FORTH_DSP_VALUE: macro 
9cf4				call macro_forth_dsp_value 
9cf4				endm 
9cf4			 
9cf4			macro_forth_dsp_value: 
9cf4			 
9cf4				FORTH_DSP 
9cf4 cd d1 9c			call macro_forth_dsp 
9cf7				endm 
# End of macro FORTH_DSP
9cf7			 
9cf7 d5				push de 
9cf8			 
9cf8 23				inc hl ; skip type 
9cf9			 
9cf9 5e				ld e, (hl) 
9cfa 23				inc hl 
9cfb 56				ld d, (hl) 
9cfc eb				ex de,hl  
9cfd			 
9cfd d1				pop de 
9cfe			 
9cfe c9				ret 
9cff			 
9cff			; return hl to start of value to second item on stack 
9cff			 
9cff			FORTH_DSP_VALUEM1: macro 
9cff				call macro_forth_dsp_value_m1 
9cff				endm 
9cff			 
9cff			macro_forth_dsp_value_m1: 
9cff			 
9cff				FORTH_DSP 
9cff cd d1 9c			call macro_forth_dsp 
9d02				endm 
# End of macro FORTH_DSP
9d02			 
9d02 2b				dec hl 
9d03 2b				dec hl 
9d04			;	dec hl 
9d04			 
9d04 d5				push de 
9d05			 
9d05 5e				ld e, (hl) 
9d06 23				inc hl 
9d07 56				ld d, (hl) 
9d08 eb				ex de,hl  
9d09			 
9d09 d1				pop de 
9d0a			 
9d0a c9				ret 
9d0b			 
9d0b				 
9d0b			 
9d0b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d0b			 
9d0b			FORTH_DSP_POP: macro 
9d0b				call macro_forth_dsp_pop 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			; get the tos data type 
9d0b			 
9d0b			FORTH_DSP_TYPE:   macro 
9d0b			 
9d0b				;FORTH_DSP_VALUE 
9d0b				FORTH_DSP 
9d0b				 
9d0b				; hl points to value 
9d0b				; check type 
9d0b			 
9d0b				ld a,(hl) 
9d0b			 
9d0b				endm 
9d0b			 
9d0b			; load the tos value into hl 
9d0b			 
9d0b			 
9d0b			FORTH_DSP_VALUEHL:  macro 
9d0b				call macro_dsp_valuehl 
9d0b				endm 
9d0b			 
9d0b			 
9d0b			 
9d0b			macro_dsp_valuehl: 
9d0b				FORTH_DSP_VALUE 
9d0b cd f4 9c			call macro_forth_dsp_value 
9d0e				endm 
# End of macro FORTH_DSP_VALUE
9d0e			 
9d0e				;FORTH_ERR_TOS_NOTNUM 
9d0e			 
9d0e				;inc hl   ; skip type id 
9d0e			 
9d0e			;	push de 
9d0e			; 
9d0e			;	ld e, (hl) 
9d0e			;	inc hl 
9d0e			;	ld d, (hl) 
9d0e			;	ex de,hl  
9d0e			 
9d0e			;	pop de 
9d0e			 
9d0e				if DEBUG_FORTH_PUSH 
9d0e						DMARK "DVL" 
9d0e f5				push af  
9d0f 3a 23 9d			ld a, (.dmark)  
9d12 32 71 ee			ld (debug_mark),a  
9d15 3a 24 9d			ld a, (.dmark+1)  
9d18 32 72 ee			ld (debug_mark+1),a  
9d1b 3a 25 9d			ld a, (.dmark+2)  
9d1e 32 73 ee			ld (debug_mark+2),a  
9d21 18 03			jr .pastdmark  
9d23 ..			.dmark: db "DVL"  
9d26 f1			.pastdmark: pop af  
9d27			endm  
# End of macro DMARK
9d27				CALLMONITOR 
9d27 cd a3 94			call break_point_state  
9d2a				endm  
# End of macro CALLMONITOR
9d2a				endif 
9d2a c9				ret 
9d2b			 
9d2b			forth_apushstrhl:      
9d2b				; push of string requires use of cli_origptr 
9d2b				; bodge use 
9d2b			 
9d2b				; get current cli_origptr, save, update with temp pointer  
9d2b ed 5b 48 ea		ld de, (cli_origptr) 
9d2f 22 48 ea			ld (cli_origptr), hl 
9d32 d5				push de 
9d33 cd 7d 9c			call forth_apush 
9d36 d1				pop de 
9d37 ed 53 48 ea		ld (cli_origptr), de 
9d3b c9			        ret	 
9d3c			 
9d3c			 
9d3c			; increase loop stack pointer and save hl to it 
9d3c				 
9d3c			FORTH_LOOP_NEXT: macro 
9d3c				call macro_forth_loop_next 
9d3c				;nop 
9d3c				endm 
9d3c			 
9d3c			macro_forth_loop_next: 
9d3c				if DEBUG_FORTH_STACK_GUARD 
9d3c cd 43 df				call check_stacks 
9d3f				endif 
9d3f e5				push hl 
9d40 d5				push de 
9d41 eb				ex de,hl 
9d42 2a fa e9			ld hl,(cli_loop_sp) 
9d45 23				inc hl 
9d46 23				inc hl 
9d47					if DEBUG_FORTH_WORDS 
9d47						DMARK "LNX" 
9d47 f5				push af  
9d48 3a 5c 9d			ld a, (.dmark)  
9d4b 32 71 ee			ld (debug_mark),a  
9d4e 3a 5d 9d			ld a, (.dmark+1)  
9d51 32 72 ee			ld (debug_mark+1),a  
9d54 3a 5e 9d			ld a, (.dmark+2)  
9d57 32 73 ee			ld (debug_mark+2),a  
9d5a 18 03			jr .pastdmark  
9d5c ..			.dmark: db "LNX"  
9d5f f1			.pastdmark: pop af  
9d60			endm  
# End of macro DMARK
9d60						CALLMONITOR 
9d60 cd a3 94			call break_point_state  
9d63				endm  
# End of macro CALLMONITOR
9d63					endif 
9d63 22 fa e9			ld (cli_loop_sp),hl 
9d66 73				ld (hl), e 
9d67 23				inc hl 
9d68 72				ld (hl), d 
9d69 d1				pop de    ; been reversed so save a swap on restore 
9d6a e1				pop hl 
9d6b				if DEBUG_FORTH_STACK_GUARD 
9d6b cd 43 df				call check_stacks 
9d6e				endif 
9d6e c9				ret 
9d6f			 
9d6f			; get current ret stack pointer and save to hl  
9d6f				 
9d6f			FORTH_LOOP_TOS: macro 
9d6f				call macro_forth_loop_tos 
9d6f				endm 
9d6f			 
9d6f			macro_forth_loop_tos: 
9d6f d5				push de 
9d70 2a fa e9			ld hl,(cli_loop_sp) 
9d73 5e				ld e, (hl) 
9d74 23				inc hl 
9d75 56				ld d, (hl) 
9d76 eb				ex de, hl 
9d77 d1				pop de 
9d78 c9				ret 
9d79			 
9d79			; pop loop stack pointer 
9d79				 
9d79			FORTH_LOOP_POP: macro 
9d79				call macro_forth_loop_pop 
9d79				endm 
9d79			 
9d79			 
9d79			macro_forth_loop_pop: 
9d79				if DEBUG_FORTH_STACK_GUARD 
9d79					DMARK "LPP" 
9d79 f5				push af  
9d7a 3a 8e 9d			ld a, (.dmark)  
9d7d 32 71 ee			ld (debug_mark),a  
9d80 3a 8f 9d			ld a, (.dmark+1)  
9d83 32 72 ee			ld (debug_mark+1),a  
9d86 3a 90 9d			ld a, (.dmark+2)  
9d89 32 73 ee			ld (debug_mark+2),a  
9d8c 18 03			jr .pastdmark  
9d8e ..			.dmark: db "LPP"  
9d91 f1			.pastdmark: pop af  
9d92			endm  
# End of macro DMARK
9d92 cd 43 df				call check_stacks 
9d95					FORTH_CHK_LOOP_UNDER 
9d95 e5				push hl 
9d96 d5				push de 
9d97 2a fa e9			ld hl,(cli_loop_sp) 
9d9a 11 34 e9			ld de, cli_loop_stack 
9d9d cd c0 8c			call cmp16 
9da0 da 5d e0			jp c, fault_loop_under 
9da3 d1				pop de 
9da4 e1				pop hl 
9da5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9da5				endif 
9da5 e5				push hl 
9da6 2a fa e9			ld hl,(cli_loop_sp) 
9da9 2b				dec hl 
9daa 2b				dec hl 
9dab 22 fa e9			ld (cli_loop_sp), hl 
9dae				; TODO do stack underflow checks 
9dae e1				pop hl 
9daf				if DEBUG_FORTH_STACK_GUARD 
9daf cd 43 df				call check_stacks 
9db2					FORTH_CHK_LOOP_UNDER 
9db2 e5				push hl 
9db3 d5				push de 
9db4 2a fa e9			ld hl,(cli_loop_sp) 
9db7 11 34 e9			ld de, cli_loop_stack 
9dba cd c0 8c			call cmp16 
9dbd da 5d e0			jp c, fault_loop_under 
9dc0 d1				pop de 
9dc1 e1				pop hl 
9dc2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dc2				endif 
9dc2 c9				ret 
9dc3			 
9dc3			macro_forth_dsp_pop: 
9dc3			 
9dc3 e5				push hl 
9dc4			 
9dc4				; release malloc data 
9dc4			 
9dc4				if DEBUG_FORTH_STACK_GUARD 
9dc4 cd 43 df				call check_stacks 
9dc7					FORTH_CHK_DSP_UNDER 
9dc7 e5				push hl 
9dc8 d5				push de 
9dc9 2a f8 e9			ld hl,(cli_data_sp) 
9dcc 11 32 e8			ld de, cli_data_stack 
9dcf cd c0 8c			call cmp16 
9dd2 da 51 e0			jp c, fault_dsp_under 
9dd5 d1				pop de 
9dd6 e1				pop hl 
9dd7				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dd7				endif 
9dd7				;ld hl,(cli_data_sp) 
9dd7			if DEBUG_FORTH_DOT 
9dd7				DMARK "DPP" 
9dd7 f5				push af  
9dd8 3a ec 9d			ld a, (.dmark)  
9ddb 32 71 ee			ld (debug_mark),a  
9dde 3a ed 9d			ld a, (.dmark+1)  
9de1 32 72 ee			ld (debug_mark+1),a  
9de4 3a ee 9d			ld a, (.dmark+2)  
9de7 32 73 ee			ld (debug_mark+2),a  
9dea 18 03			jr .pastdmark  
9dec ..			.dmark: db "DPP"  
9def f1			.pastdmark: pop af  
9df0			endm  
# End of macro DMARK
9df0				CALLMONITOR 
9df0 cd a3 94			call break_point_state  
9df3				endm  
# End of macro CALLMONITOR
9df3			endif	 
9df3			 
9df3			 
9df3			if FORTH_ENABLE_DSPPOPFREE 
9df3			 
9df3				FORTH_DSP 
9df3 cd d1 9c			call macro_forth_dsp 
9df6				endm 
# End of macro FORTH_DSP
9df6			 
9df6 7e				ld a, (hl) 
9df7 fe 01			cp DS_TYPE_STR 
9df9 20 23			jr nz, .skippopfree 
9dfb			 
9dfb				FORTH_DSP_VALUEHL 
9dfb cd 0b 9d			call macro_dsp_valuehl 
9dfe				endm 
# End of macro FORTH_DSP_VALUEHL
9dfe 00				nop 
9dff			if DEBUG_FORTH_DOT 
9dff				DMARK "DPf" 
9dff f5				push af  
9e00 3a 14 9e			ld a, (.dmark)  
9e03 32 71 ee			ld (debug_mark),a  
9e06 3a 15 9e			ld a, (.dmark+1)  
9e09 32 72 ee			ld (debug_mark+1),a  
9e0c 3a 16 9e			ld a, (.dmark+2)  
9e0f 32 73 ee			ld (debug_mark+2),a  
9e12 18 03			jr .pastdmark  
9e14 ..			.dmark: db "DPf"  
9e17 f1			.pastdmark: pop af  
9e18			endm  
# End of macro DMARK
9e18				CALLMONITOR 
9e18 cd a3 94			call break_point_state  
9e1b				endm  
# End of macro CALLMONITOR
9e1b			endif	 
9e1b cd 33 92			call free 
9e1e			.skippopfree: 
9e1e				 
9e1e			 
9e1e			endif 
9e1e			 
9e1e			if DEBUG_FORTH_DOT_KEY 
9e1e				DMARK "DP2" 
9e1e				CALLMONITOR 
9e1e			endif	 
9e1e			 
9e1e				; move pointer down 
9e1e			 
9e1e 2a f8 e9			ld hl,(cli_data_sp) 
9e21 2b				dec hl 
9e22 2b				dec hl 
9e23			; PARSEV5 
9e23 2b				dec hl 
9e24 22 f8 e9			ld (cli_data_sp), hl 
9e27			 
9e27				if DEBUG_FORTH_STACK_GUARD 
9e27 cd 43 df				call check_stacks 
9e2a					FORTH_CHK_DSP_UNDER 
9e2a e5				push hl 
9e2b d5				push de 
9e2c 2a f8 e9			ld hl,(cli_data_sp) 
9e2f 11 32 e8			ld de, cli_data_stack 
9e32 cd c0 8c			call cmp16 
9e35 da 51 e0			jp c, fault_dsp_under 
9e38 d1				pop de 
9e39 e1				pop hl 
9e3a				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e3a				endif 
9e3a			 
9e3a e1				pop hl 
9e3b			 
9e3b c9				ret 
9e3c			 
9e3c			getwordathl: 
9e3c				; hl points to an address 
9e3c				; load hl with the word at that address 
9e3c			 
9e3c d5				push de 
9e3d			 
9e3d 5e				ld e, (hl) 
9e3e 23				inc hl 
9e3f 56				ld d, (hl) 
9e40 eb				ex de, hl 
9e41			 
9e41 d1				pop de 
9e42 c9				ret 
9e43			 
9e43			 
9e43			 
9e43			 
9e43			 
9e43			; eof 
9e43			 
# End of file forth_stackopsv5.asm
9e43			endif 
9e43			 
9e43			loadwordinhl:	 
9e43			 
9e43 d5				push de 
9e44			 
9e44 5e				ld e, (hl) 
9e45 23				inc hl 
9e46 56				ld d, (hl) 
9e47 eb				ex de,hl  
9e48			 
9e48 d1				pop de 
9e49			 
9e49 c9				ret 
9e4a			 
9e4a			user_word_eol:  
9e4a				; hl contains the pointer to where to create a linked list item from the end 
9e4a				; of the user dict to continue on at the system word dict 
9e4a				 
9e4a				; poke the stub of the word list linked list to repoint to rom words 
9e4a			 
9e4a				; stub format 
9e4a				; db   word id 
9e4a				; dw    link to next word 
9e4a			        ; db char length of token 
9e4a				; db string + 0 term 
9e4a				; db exec code....  
9e4a			 
9e4a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e4c 77				ld (hl), a		; word id 
9e4d 23				inc hl 
9e4e			 
9e4e 11 19 a0			ld de, sysdict 
9e51 73				ld (hl), e		; next word link ie system dict 
9e52 23				inc hl 
9e53 72				ld (hl), d		; next word link ie system dict 
9e54 23				inc hl	 
9e55			 
9e55			;	ld (hl), sysdict		; next word link ie system dict 
9e55			;	inc hl 
9e55			;	inc hl 
9e55			 
9e55			;	inc hl 
9e55			;	inc hl 
9e55			 
9e55 3e 02			ld a, 2			; word length is 0 
9e57 77				ld (hl), a	 
9e58 23				inc hl 
9e59			 
9e59 3e 7e			ld a, '~'			; word length is 0 
9e5b 77				ld (hl), a	 
9e5c 23				inc hl 
9e5d 3e 00			ld a, 0			; save empty word 
9e5f 77				ld (hl), a 
9e60			 
9e60 c9				ret 
9e61			 
9e61				 
9e61			 
9e61			forthexec_cleanup: 
9e61				FORTH_RSP_POP 
9e61 cd dc 9a			call macro_forth_rsp_pop 
9e64				endm 
# End of macro FORTH_RSP_POP
9e64 c9				ret 
9e65			 
9e65			forth_call_hl: 
9e65				; taking hl 
9e65 e5				push hl 
9e66 c9				ret 
9e67			 
9e67			; this is called to reset Forth system but keep existing uwords etc 
9e67			 
9e67			forth_warmstart: 
9e67				; setup stack over/under flow checks 
9e67				if DEBUG_FORTH_STACK_GUARD 
9e67 cd 29 df				call chk_stk_init 
9e6a				endif 
9e6a			 
9e6a				; init stack pointers  - * these stacks go upwards *  
9e6a 21 b6 e9			ld hl, cli_ret_stack 
9e6d 22 fc e9			ld (cli_ret_sp), hl	 
9e70				; set bottom of stack 
9e70 3e 00			ld a,0 
9e72 77				ld (hl),a 
9e73 23				inc hl 
9e74 77				ld (hl),a 
9e75			 
9e75 21 32 e8			ld hl, cli_data_stack 
9e78 22 f8 e9			ld (cli_data_sp), hl	 
9e7b				; set bottom of stack 
9e7b 3e 00			ld a,0 
9e7d 77				ld (hl),a 
9e7e 23				inc hl 
9e7f 77				ld (hl),a 
9e80			 
9e80 21 34 e9			ld hl, cli_loop_stack 
9e83 22 fa e9			ld (cli_loop_sp), hl	 
9e86				; set bottom of stack 
9e86 3e 00			ld a,0 
9e88 77				ld (hl),a 
9e89 23				inc hl 
9e8a 77				ld (hl),a 
9e8b			 
9e8b				; init extent of current open file 
9e8b			 
9e8b 3e 00			ld a, 0 
9e8d 32 74 ea			ld (store_openext), a 
9e90			 
9e90 c9				ret 
9e91			 
9e91			 
9e91			; Cold Start - this is called to setup the whole Forth system 
9e91			 
9e91			forth_init: 
9e91			 
9e91				; setup stack over/under flow checks 
9e91			 
9e91			;	if DEBUG_FORTH_STACK_GUARD 
9e91			;		call chk_stk_init 
9e91			;	endif 
9e91			 
9e91				; enable auto display updates (slow.....) 
9e91			 
9e91 3e 01			ld a, 1 
9e93 32 46 ea			ld (cli_autodisplay), a 
9e96			 
9e96				; if storage is in use disable long reads for now 
9e96 3e 00			ld a, 0 
9e98 32 7f ea			ld (store_longread), a 
9e9b			 
9e9b			 
9e9b				; show start up screen 
9e9b			 
9e9b cd 75 8a			call clear_display 
9e9e			 
9e9e 3e 00			ld a,0 
9ea0 32 68 ea			ld (f_cursor_ptr), a 
9ea3			 
9ea3				; set start of word list in start of ram - for use when creating user words 
9ea3			 
9ea3 21 ca e2			ld hl, baseram 
9ea6 22 c8 e5			ld (os_last_new_uword), hl 
9ea9 cd 4a 9e			call user_word_eol 
9eac				 
9eac			;		call display_data_sp 
9eac			;		call next_page_prompt 
9eac			 
9eac			 
9eac			 
9eac			 
9eac c9				ret 
9ead			 
9ead .. 00		.bootforth: db " Forth Kernel Init ",0 
9ec1			 
9ec1			; TODO push to stack 
9ec1			 
9ec1			;  
9ec1			 
9ec1			if FORTH_PARSEV2 
9ec1			 
9ec1			 
9ec1				include "forth_parserv2.asm" 
9ec1			 
9ec1			endif 
9ec1			 
9ec1			 
9ec1			; parse cli version 1 
9ec1			 
9ec1			if FORTH_PARSEV1 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv1.asm" 
9ec1			endif 
9ec1				 
9ec1			if FORTH_PARSEV3 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv3.asm" 
9ec1				include "forth_wordsv3.asm" 
9ec1			endif 
9ec1			 
9ec1			if FORTH_PARSEV4 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv4.asm" 
9ec1				include "forth_wordsv4.asm" 
9ec1			endif 
9ec1			 
9ec1			if FORTH_PARSEV5 
9ec1			 
9ec1			 
9ec1			 
9ec1			      include "forth_parserv5.asm" 
9ec1			 
9ec1			 
9ec1			; A better parser without using malloc and string copies all over the place.  
9ec1			; Exec in situ should be faster 
9ec1			 
9ec1			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ec1			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ec1			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ec1			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ec1			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ec1			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ec1			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ec1			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ec1			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ec1			 
9ec1			; Core word preamble macro 
9ec1			 
9ec1			CWHEAD:   macro nxtword opcode lit len opflags 
9ec1				db WORD_SYS_CORE+opcode             
9ec1				; internal op code number 
9ec1				dw nxtword            
9ec1				; link to next dict word block 
9ec1				db len + 1 
9ec1				; literal length of dict word inc zero term 
9ec1				db lit,0              
9ec1				; literal dict word 
9ec1			        ; TODO db opflags        
9ec1				endm 
9ec1			 
9ec1			 
9ec1			NEXTW: macro  
9ec1				jp macro_next 
9ec1				endm 
9ec1			 
9ec1			macro_next: 
9ec1			if DEBUG_FORTH_PARSE_KEY 
9ec1				DMARK "NXT" 
9ec1				CALLMONITOR 
9ec1			endif	 
9ec1			;	inc hl  ; skip token null term  
9ec1 ed 4b 4a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9ec5 ed 5b 48 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ec9 2a cc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ecc			if DEBUG_FORTH_PARSE_KEY 
9ecc				DMARK "}AA" 
9ecc				CALLMONITOR 
9ecc			endif	 
9ecc c3 cf 9f			jp execnext 
9ecf				;jp exec1 
9ecf			       
9ecf			 
9ecf			 
9ecf			; Another go at the parser to compile  
9ecf			 
9ecf			 
9ecf			; TODO rework parser to change all of the string words to byte tokens 
9ecf			; TODO do a search for  
9ecf			 
9ecf			; TODO first run normal parser to zero term sections 
9ecf			; TODO for each word do a token look up to get the op code 
9ecf			; TODO need some means to flag to the exec that this is a byte code form    
9ecf			 
9ecf			 
9ecf			forthcompile: 
9ecf			 
9ecf			; 
9ecf			; line parse: 
9ecf			;       parse raw input buffer 
9ecf			;       tokenise the words 
9ecf			;       malloc new copy (for looping etc) 
9ecf			;       copy to malloc + current pc in line to start of string and add line term 
9ecf			;       save on new rsp 
9ecf			; 
9ecf			 
9ecf			; hl to point to the line to tokenise 
9ecf			 
9ecf			;	push hl 
9ecf 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9ed2			 
9ed2			;	ld a,0		; string term on input 
9ed2			;	call strlent 
9ed2			 
9ed2			;	ld (os_tok_len), hl	 ; save string length 
9ed2			 
9ed2			;if DEBUG_FORTH_TOK 
9ed2			;	ex de,hl		 
9ed2			;endif 
9ed2			 
9ed2			;	pop hl 		; get back string pointer 
9ed2			 
9ed2			if DEBUG_FORTH_TOK 
9ed2						DMARK "TOc" 
9ed2				CALLMONITOR 
9ed2			endif 
9ed2 7e			.cptoken2:    ld a,(hl) 
9ed3 23				inc hl 
9ed4 fe 7f			cp FORTH_END_BUFFER 
9ed6 28 29			jr z, .cptokendone2 
9ed8 fe 00			cp 0 
9eda 28 25			jr z, .cptokendone2 
9edc fe 22			cp '"' 
9ede 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9ee0 fe 20			cp ' ' 
9ee2 20 ee			jr nz,  .cptoken2 
9ee4			 
9ee4			; TODO consume comments held between ( and ) 
9ee4			 
9ee4				; we have a space so change to zero term for dict match later 
9ee4 2b				dec hl 
9ee5 3e 00			ld a,0 
9ee7 77				ld (hl), a 
9ee8 23				inc hl 
9ee9 18 e7			jr .cptoken2 
9eeb				 
9eeb			 
9eeb			.cptokenstr2: 
9eeb				; skip all white space until either eol (because forgot to term) or end double quote 
9eeb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9eeb				;inc hl ; skip current double quote 
9eeb 7e				ld a,(hl) 
9eec 23				inc hl 
9eed fe 22			cp '"' 
9eef 28 e1			jr z, .cptoken2 
9ef1 fe 7f			cp FORTH_END_BUFFER 
9ef3 28 0c			jr z, .cptokendone2 
9ef5 fe 00			cp 0 
9ef7 28 08			jr z, .cptokendone2 
9ef9 fe 20			cp ' ' 
9efb 28 02			jr z, .cptmp2 
9efd 18 ec			jr .cptokenstr2 
9eff			 
9eff			.cptmp2:	; we have a space so change to zero term for dict match later 
9eff				;dec hl 
9eff				;ld a,"-"	; TODO remove this when working 
9eff				;ld (hl), a 
9eff				;inc hl 
9eff 18 ea			jr .cptokenstr2 
9f01			 
9f01			.cptokendone2: 
9f01				;inc hl 
9f01 3e 7f			ld a, FORTH_END_BUFFER 
9f03 77				ld (hl),a 
9f04 23				inc hl 
9f05 3e 21			ld a, '!' 
9f07 77				ld (hl),a 
9f08			 
9f08 2a cc e5			ld hl,(os_tok_ptr) 
9f0b			         
9f0b			if DEBUG_FORTH_TOK 
9f0b						DMARK "Tc1" 
9f0b				CALLMONITOR 
9f0b			endif 
9f0b			 
9f0b				; push exec string to top of return stack 
9f0b				FORTH_RSP_NEXT 
9f0b cd bb 9a			call macro_forth_rsp_next 
9f0e				endm 
# End of macro FORTH_RSP_NEXT
9f0e c9				ret 
9f0f			 
9f0f			; Another go at the parser need to simplify the process 
9f0f			 
9f0f			forthparse: 
9f0f			 
9f0f			; 
9f0f			; line parse: 
9f0f			;       parse raw input buffer 
9f0f			;       tokenise the words 
9f0f			;       malloc new copy (for looping etc) 
9f0f			;       copy to malloc + current pc in line to start of string and add line term 
9f0f			;       save on new rsp 
9f0f			; 
9f0f			 
9f0f			; hl to point to the line to tokenise 
9f0f			 
9f0f			;	push hl 
9f0f 22 cc e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f12			 
9f12			;	ld a,0		; string term on input 
9f12			;	call strlent 
9f12			 
9f12			;	ld (os_tok_len), hl	 ; save string length 
9f12			 
9f12			;if DEBUG_FORTH_TOK 
9f12			;	ex de,hl		 
9f12			;endif 
9f12			 
9f12			;	pop hl 		; get back string pointer 
9f12			 
9f12			if DEBUG_FORTH_TOK 
9f12						DMARK "TOK" 
9f12				CALLMONITOR 
9f12			endif 
9f12 7e			.ptoken2:    ld a,(hl) 
9f13 23				inc hl 
9f14 fe 7f			cp FORTH_END_BUFFER 
9f16 28 29			jr z, .ptokendone2 
9f18 fe 00			cp 0 
9f1a 28 25			jr z, .ptokendone2 
9f1c fe 22			cp '"' 
9f1e 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f20 fe 20			cp ' ' 
9f22 20 ee			jr nz,  .ptoken2 
9f24			 
9f24			; TODO consume comments held between ( and ) 
9f24			 
9f24				; we have a space so change to zero term for dict match later 
9f24 2b				dec hl 
9f25 3e 00			ld a,0 
9f27 77				ld (hl), a 
9f28 23				inc hl 
9f29 18 e7			jr .ptoken2 
9f2b				 
9f2b			 
9f2b			.ptokenstr2: 
9f2b				; skip all white space until either eol (because forgot to term) or end double quote 
9f2b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f2b				;inc hl ; skip current double quote 
9f2b 7e				ld a,(hl) 
9f2c 23				inc hl 
9f2d fe 22			cp '"' 
9f2f 28 e1			jr z, .ptoken2 
9f31 fe 7f			cp FORTH_END_BUFFER 
9f33 28 0c			jr z, .ptokendone2 
9f35 fe 00			cp 0 
9f37 28 08			jr z, .ptokendone2 
9f39 fe 20			cp ' ' 
9f3b 28 02			jr z, .ptmp2 
9f3d 18 ec			jr .ptokenstr2 
9f3f			 
9f3f			.ptmp2:	; we have a space so change to zero term for dict match later 
9f3f				;dec hl 
9f3f				;ld a,"-"	; TODO remove this when working 
9f3f				;ld (hl), a 
9f3f				;inc hl 
9f3f 18 ea			jr .ptokenstr2 
9f41			 
9f41			.ptokendone2: 
9f41				;inc hl 
9f41 3e 7f			ld a, FORTH_END_BUFFER 
9f43 77				ld (hl),a 
9f44 23				inc hl 
9f45 3e 21			ld a, '!' 
9f47 77				ld (hl),a 
9f48			 
9f48 2a cc e5			ld hl,(os_tok_ptr) 
9f4b			         
9f4b			if DEBUG_FORTH_TOK 
9f4b						DMARK "TK1" 
9f4b				CALLMONITOR 
9f4b			endif 
9f4b			 
9f4b				; push exec string to top of return stack 
9f4b				FORTH_RSP_NEXT 
9f4b cd bb 9a			call macro_forth_rsp_next 
9f4e				endm 
# End of macro FORTH_RSP_NEXT
9f4e c9				ret 
9f4f			 
9f4f			; 
9f4f			;	; malloc size + buffer pointer + if is loop flag 
9f4f			;	ld hl,(os_tok_len) 		 ; get string length 
9f4f			; 
9f4f			;	ld a,l 
9f4f			; 
9f4f			;	cp 0			; we dont want to use a null string 
9f4f			;	ret z 
9f4f			; 
9f4f			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f4f			; 
9f4f			;	add 5     ; TODO when certain not over writing memory remove 
9f4f			; 
9f4f			;		 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKE" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	ld l,a 
9f4f			;	ld h,0 
9f4f			;;	push hl   ; save required space for the copy later 
9f4f			;	call malloc 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKM" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			;	if DEBUG_FORTH_MALLOC_GUARD 
9f4f			;		push af 
9f4f			;		call ishlzero 
9f4f			;;		ld a, l 
9f4f			;;		add h 
9f4f			;;		cp 0 
9f4f			;		pop af 
9f4f			;		 
9f4f			;		call z,malloc_error 
9f4f			;	endif 
9f4f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f4f			; 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKR" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	FORTH_RSP_NEXT 
9f4f			; 
9f4f			;	;inc hl	 ; go past current buffer pointer 
9f4f			;	;inc hl 
9f4f			;	;inc hl   ; and past if loop flag 
9f4f			;		; TODO Need to set flag  
9f4f			; 
9f4f			;	 
9f4f			;	 
9f4f			;	ex de,hl	; malloc is dest 
9f4f			;	ld hl, (os_tok_len) 
9f4f			;;	pop bc 
9f4f			;	ld c, l                
9f4f			;	ld b,0 
9f4f			;	ld hl, (os_tok_ptr) 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			;			DMARK "TKT" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	; do str cpy 
9f4f			; 
9f4f			;	ldir      ; copy byte in hl to de 
9f4f			; 
9f4f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f4f			; 
9f4f			;if DEBUG_FORTH_TOK 
9f4f			; 
9f4f			;			DMARK "TKY" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			;	;ld a,0 
9f4f			;	;ld a,FORTH_END_BUFFER 
9f4f			;	ex de, hl 
9f4f			;	;dec hl			 ; go back over the space delim at the end of word 
9f4f			;	;ld (hl),a 
9f4f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f4f			;	ld a,FORTH_END_BUFFER 
9f4f			;	ld (hl),a 
9f4f			;	inc hl 
9f4f			;	ld a,FORTH_END_BUFFER 
9f4f			;	ld (hl),a 
9f4f			; 
9f4f			;	; init the malloc area data 
9f4f			;	; set pc for in current area 
9f4f			;	;ld hl, (os_tok_malloc) 
9f4f			;	;inc hl 
9f4f			;	;inc hl 
9f4f			;	;inc hl 
9f4f			;	;ex de,hl 
9f4f			;	;ld hl, (os_tok_malloc) 
9f4f			;	;ld (hl),e 
9f4f			;	;inc hl 
9f4f			;	;ld (hl),d 
9f4f			; 
9f4f			; 
9f4f			;	ld hl,(os_tok_malloc) 
9f4f			;if DEBUG_FORTH_PARSE_KEY 
9f4f			;			DMARK "TKU" 
9f4f			;	CALLMONITOR 
9f4f			;endif 
9f4f			; 
9f4f			;	ret 
9f4f			 
9f4f			forthexec: 
9f4f			 
9f4f			; line exec: 
9f4f			; forth parser 
9f4f			 
9f4f			; 
9f4f			;       get current exec line on rsp 
9f4f			 
9f4f				FORTH_RSP_TOS 
9f4f cd d2 9a			call macro_forth_rsp_tos 
9f52				endm 
# End of macro FORTH_RSP_TOS
9f52			 
9f52			;       restore current pc - hl points to malloc of data 
9f52			 
9f52				;ld e, (hl) 
9f52				;inc hl 
9f52				;ld d, (hl) 
9f52				;ex de,hl 
9f52			 
9f52			 
9f52			exec1: 
9f52 22 cc e5			ld (os_tok_ptr), hl 
9f55			 
9f55				; copy our PC to working vars  
9f55 22 4a ea			ld (cli_ptr), hl 
9f58 22 48 ea			ld (cli_origptr), hl 
9f5b			 
9f5b 7e				ld a,(hl) 
9f5c fe 7f			cp FORTH_END_BUFFER 
9f5e c8				ret z 
9f5f			 
9f5f				; skip any nulls 
9f5f			 
9f5f fe 00			cp 0 
9f61 20 03			jr nz, .execword 
9f63 23				inc hl 
9f64 18 ec			jr exec1 
9f66			 
9f66			 
9f66			.execword: 
9f66			 
9f66			 
9f66			 
9f66			if DEBUG_FORTH_PARSE_KEY 
9f66						DMARK "KYQ" 
9f66				CALLMONITOR 
9f66			endif 
9f66			;       while at start of word: 
9f66			; get start of dict (in user area first) 
9f66			 
9f66 21 ca e2		ld hl, baseram 
9f69			;ld hl, sysdict 
9f69 22 4c ea		ld (cli_nextword),hl 
9f6c			;           match word at pc 
9f6c			;           exec word 
9f6c			;           or push to dsp 
9f6c			;           forward to next token 
9f6c			;           if line term pop rsp and exit 
9f6c			;        
9f6c			 
9f6c			if DEBUG_FORTH_PARSE_KEY 
9f6c						DMARK "KYq" 
9f6c				CALLMONITOR 
9f6c			endif 
9f6c			 
9f6c			; 
9f6c			; word comp 
9f6c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f6c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f6c			;    move to start of word  
9f6c			;    compare word to cli_token 
9f6c			 
9f6c			.execpnword:	; HL at start of a word in the dictionary to check 
9f6c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f6c			;	ld (cli_ptr), hl 
9f6c			 
9f6c 2a 4c ea			ld hl,(cli_nextword) 
9f6f			 
9f6f cd 12 a0			call forth_tok_next 
9f72			; tok next start here 
9f72			;	; TODO skip compiled symbol for now 
9f72			;	inc hl 
9f72			; 
9f72			;	; save pointer to next word 
9f72			; 
9f72			;	; hl now points to the address of the next word pointer  
9f72			;	ld e, (hl) 
9f72			;	inc hl 
9f72			;	ld d, (hl) 
9f72			;	inc l 
9f72			; 
9f72			;	ex de,hl 
9f72			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f72			;	push bc 
9f72			;	ld bc, (cli_nextword) 
9f72			;			DMARK "NXW" 
9f72			;	CALLMONITOR 
9f72			;	pop bc 
9f72			;endif 
9f72			; tok next end here 
9f72 22 4c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f75 eb				ex de, hl 
9f76			 
9f76			 
9f76				; save the pointer of the current token - 1 to check against 
9f76				 
9f76 22 50 ea			ld (cli_token), hl   
9f79				; TODO maybe remove below save if no debug 
9f79				; save token string ptr for any debug later 
9f79 23				inc hl  
9f7a 22 52 ea			ld (cli_origtoken), hl 
9f7d 2b				dec hl 
9f7e				; save pointer to the start of the next dictionay word 
9f7e 7e				ld a,(hl)   ; get string length 
9f7f 47				ld b,a 
9f80			.execpnwordinc:  
9f80 23				inc hl 
9f81 10 fd			djnz .execpnwordinc 
9f83 22 4e ea			ld (cli_execword), hl      ; save start of this words code 
9f86			 
9f86				; now check the word token against the string being parsed 
9f86			 
9f86 2a 50 ea			ld hl,(cli_token) 
9f89 23				inc hl     ; skip string length (use zero term instead to end) 
9f8a 22 50 ea			ld (cli_token), hl 
9f8d			 
9f8d			if DEBUG_FORTH_PARSE_KEY 
9f8d						DMARK "KY2" 
9f8d			endif 
9f8d			if DEBUG_FORTH_PARSE_EXEC 
9f8d				; see if disabled 
9f8d			 
9f8d				ld a, (os_view_disable) 
9f8d				cp '*' 
9f8d				jr z, .skip 
9f8d			 
9f8d				push hl 
9f8d				push hl 
9f8d				call clear_display 
9f8d				ld de, .compword 
9f8d				ld a, display_row_1 
9f8d				call str_at_display 
9f8d				pop de 
9f8d				ld a, display_row_2 
9f8d				call str_at_display 
9f8d				ld hl,(cli_ptr) 
9f8d				ld a,(hl) 
9f8d			        ld hl, os_word_scratch 
9f8d				ld (hl),a 
9f8d				ld a,0 
9f8d				inc hl 
9f8d				ld (hl),a 	 
9f8d				ld de, os_word_scratch 
9f8d				ld a, display_row_2+10 
9f8d				call str_at_display 
9f8d				call update_display 
9f8d				ld a, 100 
9f8d				call aDelayInMS 
9f8d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f8d				call delay250ms 
9f8d				endif 
9f8d				pop hl 
9f8d			.skip:  
9f8d			endif	 
9f8d			.execpnchar:    ; compare char between token and string to parse 
9f8d			 
9f8d			if DEBUG_FORTH_PARSE_KEY 
9f8d						DMARK "Ky3" 
9f8d			endif 
9f8d			if DEBUG_FORTH_PARSE_EXEC 
9f8d				; see if disabled 
9f8d			 
9f8d				ld a, (os_view_disable) 
9f8d				cp '*' 
9f8d				jr z, .skip2 
9f8d			 
9f8d			;	call clear_display 
9f8d			ld hl,(cli_token) 
9f8d			ld a,(hl) 
9f8d			ld (os_word_scratch),a 
9f8d				ld hl,(cli_ptr) 
9f8d			ld a,(hl) 
9f8d				ld (os_word_scratch+1),a 
9f8d				ld a,0 
9f8d				ld (os_word_scratch+2),a 
9f8d				ld de,os_word_scratch 
9f8d				ld a,display_row_4 
9f8d				call str_at_display 
9f8d				call update_display 
9f8d			.skip2:  
9f8d			endif 
9f8d 2a 50 ea			ld hl,(cli_token) 
9f90 7e				ld a, (hl)	 ; char in word token 
9f91 23				inc hl 		; move to next char 
9f92 22 50 ea			ld (cli_token), hl ; and save it 
9f95 47				ld b,a 
9f96			 
9f96 2a 4a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f99 7e				ld a,(hl) 
9f9a 23				inc hl 
9f9b 22 4a ea			ld (cli_ptr), hl		; move to next char 
9f9e cd f7 90			call toUpper 		; make sure the input string matches case 
9fa1			 
9fa1			if DEBUG_FORTH_PARSE 
9fa1			endif 
9fa1			 
9fa1				; input stream end of token is a space so get rid of it 
9fa1			 
9fa1			;	cp ' ' 
9fa1			;	jr nz, .pnskipspace 
9fa1			; 
9fa1			;	ld a, 0		; make same term as word token term 
9fa1			; 
9fa1			;.pnskipspace: 
9fa1			 
9fa1			if DEBUG_FORTH_PARSE_KEY 
9fa1						DMARK "KY7" 
9fa1			endif 
9fa1 b8				cp b 
9fa2 c2 b8 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fa5				 
9fa5			;    if same 
9fa5			;       scan for string terms 0 for token and 32 for input 
9fa5			 
9fa5				 
9fa5			if DEBUG_FORTH_PARSE_KEY 
9fa5						DMARK "KY8" 
9fa5			endif 
9fa5			 
9fa5 80				add b			 
9fa6 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fa8							; TODO need to make sure last word in zero term string is accounted for 
9fa8 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9faa			 
9faa			 
9faa				; at end of both strings so both are exact match 
9faa			 
9faa			;       skip ptr for next word 
9faa			 
9faa 2a 4a ea			ld hl,(cli_ptr) 	; at input string term 
9fad 23				inc hl			 ; at next char 
9fae 22 4a ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fb1 22 48 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fb4				 
9fb4				 
9fb4			if DEBUG_FORTH_PARSE_KEY 
9fb4						DMARK "KY3" 
9fb4			endif 
9fb4			 
9fb4			 
9fb4			 
9fb4			;       exec code block 
9fb4			if DEBUG_FORTH_JP 
9fb4				call clear_display 
9fb4				call update_display 
9fb4				call delay1s 
9fb4				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fb4				ld a,h 
9fb4				ld hl, os_word_scratch 
9fb4				call hexout 
9fb4				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fb4				ld a,l 
9fb4				ld hl, os_word_scratch+2 
9fb4				call hexout 
9fb4				ld hl, os_word_scratch+4 
9fb4				ld a,0 
9fb4				ld (hl),a 
9fb4				ld de,os_word_scratch 
9fb4				call str_at_display 
9fb4					ld a, display_row_2 
9fb4					call str_at_display 
9fb4				ld de, (cli_origtoken) 
9fb4				ld a, display_row_1+10 
9fb4					call str_at_display 
9fb4			 
9fb4				ld a,display_row_1 
9fb4				ld de, .foundword 
9fb4				ld a, display_row_3 
9fb4				call str_at_display 
9fb4				call update_display 
9fb4				call delay1s 
9fb4				call delay1s 
9fb4				call delay1s 
9fb4			endif 
9fb4			 
9fb4			if DEBUG_FORTH_PARSE_KEY 
9fb4						DMARK "KYj" 
9fb4			endif 
9fb4				; TODO save the word pointer in this exec 
9fb4			 
9fb4 2a 4e ea			ld hl,(cli_execword) 
9fb7 e9				jp (hl) 
9fb8			 
9fb8			 
9fb8			;    if not same 
9fb8			;	scan for zero term 
9fb8			;	get ptr for next word 
9fb8			;	goto word comp 
9fb8			 
9fb8			.execpnskipword:	; get pointer to next word 
9fb8 2a 4c ea			ld hl,(cli_nextword) 
9fbb			 
9fbb 7e				ld a,(hl) 
9fbc fe 00			cp WORD_SYS_END 
9fbe			;	cp 0 
9fbe 28 09			jr z, .execendofdict			 ; at end of words 
9fc0			 
9fc0			if DEBUG_FORTH_PARSE_KEY 
9fc0						DMARK "KY4" 
9fc0			endif 
9fc0			if DEBUG_FORTH_PARSE_EXEC 
9fc0			 
9fc0				; see if disabled 
9fc0			 
9fc0				ld a, (os_view_disable) 
9fc0				cp '*' 
9fc0				jr z, .noskip 
9fc0			 
9fc0			 
9fc0				ld de, .nowordfound 
9fc0				ld a, display_row_3 
9fc0				call str_at_display 
9fc0				call update_display 
9fc0				ld a, 100 
9fc0				call aDelayInMS 
9fc0				 
9fc0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc0					call delay250ms 
9fc0				endif 
9fc0			.noskip:  
9fc0			 
9fc0			endif	 
9fc0			 
9fc0 2a 48 ea			ld hl,(cli_origptr) 
9fc3 22 4a ea			ld (cli_ptr),hl 
9fc6			 
9fc6			if DEBUG_FORTH_PARSE_KEY 
9fc6						DMARK "KY5" 
9fc6			endif 
9fc6 c3 6c 9f			jp .execpnword			; else go to next word 
9fc9			 
9fc9			.execendofdict:  
9fc9			 
9fc9			if DEBUG_FORTH_PARSE_KEY 
9fc9						DMARK "KYe" 
9fc9			endif 
9fc9			if DEBUG_FORTH_PARSE_EXEC 
9fc9				; see if disabled 
9fc9			 
9fc9				ld a, (os_view_disable) 
9fc9				cp '*' 
9fc9				jr z, .ispskip 
9fc9			 
9fc9				call clear_display 
9fc9				call update_display 
9fc9				call delay1s 
9fc9				ld de, (cli_origptr) 
9fc9				ld a, display_row_1 
9fc9				call str_at_display 
9fc9				 
9fc9				ld de, .enddict 
9fc9				ld a, display_row_3 
9fc9				call str_at_display 
9fc9				call update_display 
9fc9				ld a, 100 
9fc9				call aDelayInMS 
9fc9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fc9				call delay1s 
9fc9				call delay1s 
9fc9				call delay1s 
9fc9				endif 
9fc9			.ispskip:  
9fc9				 
9fc9			endif	 
9fc9			 
9fc9			 
9fc9			 
9fc9				; if the word is not a keyword then must be a literal so push it to stack 
9fc9			 
9fc9			; push token to stack to end of word 
9fc9			 
9fc9				STACKFRAME ON $1efe $2f9f 
9fc9				if DEBUG_STACK_IMB 
9fc9					if ON 
9fc9						exx 
9fc9						ld de, $1efe 
9fc9						ld a, d 
9fc9						ld hl, curframe 
9fc9						call hexout 
9fc9						ld a, e 
9fc9						ld hl, curframe+2 
9fc9						call hexout 
9fc9						ld hl, $1efe 
9fc9						push hl 
9fc9						ld hl, $2f9f 
9fc9						push hl 
9fc9						exx 
9fc9					endif 
9fc9				endif 
9fc9			endm 
# End of macro STACKFRAME
9fc9			 
9fc9 2a cc e5		ld hl,(os_tok_ptr) 
9fcc cd 7d 9c		call forth_apush 
9fcf			 
9fcf				STACKFRAMECHK ON $1efe $2f9f 
9fcf				if DEBUG_STACK_IMB 
9fcf					if ON 
9fcf						exx 
9fcf						ld hl, $2f9f 
9fcf						pop de   ; $2f9f 
9fcf						call cmp16 
9fcf						jr nz, .spnosame 
9fcf						ld hl, $1efe 
9fcf						pop de   ; $1efe 
9fcf						call cmp16 
9fcf						jr z, .spfrsame 
9fcf						.spnosame: call showsperror 
9fcf						.spfrsame: nop 
9fcf						exx 
9fcf					endif 
9fcf				endif 
9fcf			endm 
# End of macro STACKFRAMECHK
9fcf			 
9fcf			execnext: 
9fcf			 
9fcf			if DEBUG_FORTH_PARSE_KEY 
9fcf						DMARK "KY>" 
9fcf			endif 
9fcf			; move past token to next word 
9fcf			 
9fcf 2a cc e5		ld hl, (os_tok_ptr) 
9fd2 3e 00		ld a, 0 
9fd4 01 ff 00		ld bc, 255     ; input buffer size 
9fd7 ed b1		cpir 
9fd9			 
9fd9			if DEBUG_FORTH_PARSE_KEY 
9fd9						DMARK "KY!" 
9fd9				CALLMONITOR 
9fd9			endif	 
9fd9			; TODO this might place hl on the null, so will need to forward on??? 
9fd9			;inc hl   ; see if this gets onto the next item 
9fd9			 
9fd9			 
9fd9			; TODO pass a pointer to the buffer to push 
9fd9			; TODO call function to push 
9fd9			 
9fd9			; look for end of input 
9fd9			 
9fd9			;inc hl 
9fd9			;ld a,(hl) 
9fd9			;cp FORTH_END_BUFFER 
9fd9			;ret z 
9fd9			 
9fd9			 
9fd9 c3 52 9f		jp exec1 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			 
9fdc			findnexttok: 
9fdc			 
9fdc				; hl is pointer to move 
9fdc				; de is the token to locate 
9fdc			 
9fdc					if DEBUG_FORTH 
9fdc						DMARK "NTK" 
9fdc						CALLMONITOR 
9fdc					endif 
9fdc d5				push de 
9fdd			 
9fdd			.fnt1:	 
9fdd				; find first char of token to locate 
9fdd			 
9fdd 1a				ld a, (de) 
9fde 4f				ld c,a 
9fdf 7e				ld a,(hl) 
9fe0 cd f7 90			call toUpper 
9fe3					if DEBUG_FORTH 
9fe3						DMARK "NT1" 
9fe3						CALLMONITOR 
9fe3					endif 
9fe3 b9				cp c 
9fe4			 
9fe4 28 03			jr z, .fnt2cmpmorefirst	 
9fe6			 
9fe6				; first char not found move to next char 
9fe6			 
9fe6 23				inc hl 
9fe7 18 f4			jr .fnt1 
9fe9			 
9fe9			.fnt2cmpmorefirst:	 
9fe9				; first char of token found.  
9fe9			 
9fe9 e5				push hl     ; save start of token just in case it is the right one 
9fea d9				exx 
9feb e1				pop hl        ; save it to hl' 
9fec d9				exx 
9fed			 
9fed			 
9fed			.fnt2cmpmore:	 
9fed				; compare the rest 
9fed				 
9fed 23				inc hl 
9fee 13				inc de 
9fef				 
9fef 1a				ld a, (de) 
9ff0 4f				ld c,a 
9ff1 7e				ld a,(hl) 
9ff2 cd f7 90			call toUpper 
9ff5			 
9ff5					if DEBUG_FORTH 
9ff5						DMARK "NT2" 
9ff5						CALLMONITOR 
9ff5					endif 
9ff5				; c has the token to find char 
9ff5				; a has the mem to scan char 
9ff5			 
9ff5 b9				cp c 
9ff6 28 04			jr z,.fntmatch1 
9ff8			 
9ff8				; they are not the same 
9ff8			 
9ff8					if DEBUG_FORTH 
9ff8						DMARK "NT3" 
9ff8						CALLMONITOR 
9ff8					endif 
9ff8 d1				pop de	; reset de token to look for 
9ff9 d5				push de 
9ffa 18 e1			jr .fnt1 
9ffc				 
9ffc			.fntmatch1: 
9ffc			 
9ffc				; is the same char a null which means we might have a full hit? 
9ffc					if DEBUG_FORTH 
9ffc						DMARK "NT4" 
9ffc						CALLMONITOR 
9ffc					endif 
9ffc			 
9ffc fe 00			cp 0 
9ffe 28 0b			jr z, .fntmatchyes 
a000			 
a000				; are we at the end of the token to find? 
a000			 
a000					if DEBUG_FORTH 
a000						DMARK "NT5" 
a000						CALLMONITOR 
a000					endif 
a000 3e 00			ld a, 0 
a002 b9				cp c 
a003			 
a003 c2 ed 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a006			 
a006					if DEBUG_FORTH 
a006						DMARK "NT6" 
a006						CALLMONITOR 
a006					endif 
a006				; token to find is exhusted but no match to stream 
a006			 
a006				; restore tok pointer and continue on 
a006 d1				pop de 
a007 d5				push de 
a008 c3 dd 9f			jp .fnt1 
a00b			 
a00b			 
a00b			.fntmatchyes: 
a00b			 
a00b				; hl now contains the end of the found token 
a00b			 
a00b				; get rid of saved token pointer to find 
a00b			 
a00b d1				pop de 
a00c			 
a00c					if DEBUG_FORTH 
a00c						DMARK "NT9" 
a00c						CALLMONITOR 
a00c					endif 
a00c			 
a00c				; hl will be on the null term so forward on 
a00c			 
a00c				; get back the saved start of the token 
a00c			 
a00c d9				exx 
a00d e5				push hl     ; save start of token just in case it is the right one 
a00e d9				exx 
a00f e1				pop hl        ; save it to hl 
a010			 
a010 c9				ret 
a011			 
a011			 
a011			; LIST needs to find a specific token   
a011			; FORGET needs to find a spefici token 
a011			 
a011			; SAVE needs to find all tokens by flag 
a011			; WORDS just needs to scan through all  by flag 
a011			; UWORDS needs to scan through all by flag 
a011			 
a011			 
a011			; given hl as pointer to start of dict look up string 
a011			; return hl as pointer to start of word block 
a011			; or 0 if not found 
a011			 
a011			forth_find_tok: 
a011 c9				ret 
a012			 
a012			; given hl as pointer to dict structure 
a012			; move to the next dict block structure 
a012			 
a012			forth_tok_next: 
a012				; hl now points to the address of the next word pointer  
a012				; TODO skip compiled symbol for now 
a012			;	push de 
a012 23				inc hl 
a013 5e				ld e, (hl) 
a014 23				inc hl 
a015 56				ld d, (hl) 
a016 23				inc hl 
a017			 
a017 eb				ex de,hl 
a018			if DEBUG_FORTH_PARSE_NEXTWORD 
a018				push bc 
a018				ld bc, (cli_nextword) 
a018						DMARK "NXW" 
a018				CALLMONITOR 
a018				pop bc 
a018			endif 
a018			;	pop de	 
a018 c9				ret 
a019			 
a019			 
a019			 
a019			; eof 
# End of file forth_parserv5.asm
a019				include "forth_wordsv4.asm" 
a019			 
a019			; the core word dictionary v4 
a019			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a019			 
a019			; this is a linked list for each of the system words used 
a019			; user defined words will follow the same format but will be in ram 
a019			 
a019			 
a019			; 
a019			; 
a019			; define linked list: 
a019			; 
a019			; 1. compiled byte op code 
a019			; 2. len of text word 
a019			; 3. text word 
a019			; 4. ptr to next dictionary word 
a019			; 5. asm, calls etc for the word 
a019			; 
a019			;  if 1 == 0 then last word in dict  
a019			;   
a019			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a019			;  
a019			;  
a019			; create basic standard set of words 
a019			; 
a019			;  
a019			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a019			; 2DUP 2DROP 2SWAP  
a019			; @ C@ - get byte  
a019			; ! C! - store byte 
a019			; 0< true if less than zero 
a019			; 0= true if zero 
a019			; < >  
a019			; = true if same 
a019			; variables 
a019			 
a019			 
a019			; Hardware specific words I may need 
a019			; 
a019			; IN OUT  
a019			; calls to key util functions 
a019			; calls to hardward abstraction stuff 
a019			; easy control of frame buffers and lcd i/o 
a019			; keyboard  
a019			 
a019			 
a019			;DICT: macro 
a019			; op_code, len, word, next 
a019			;    word: 
a019			;    db op_code 
a019			;    ds word zero term 
a019			;    dw next 
a019			;    endm 
a019			 
a019			 
a019			 
a019			 
a019			; op code 1 is a flag for user define words which are to be handled differently 
a019			 
a019			 
a019			; 
a019			; 
a019			;    TODO on entry to a word this should be the expected environment 
a019			;    hl - tos value if number then held, if string this is the ptr 
a019			;    de -  
a019			 
a019			 
a019			; opcode ranges 
a019			; 0 - end of word dict 
a019			; 255 - user define words 
a019			 
a019			sysdict: 
a019			include "forth_opcodes.asm" 
a019			; op codes for forth keywords 
a019			; free to use code 0  
a019				OPCODE_HEAP: equ  1 
a019				OPCODE_EXEC: equ 2 
a019				OPCODE_DUP: equ 3 
a019				OPCODE_SWAP: equ 4 
a019				OPCODE_COLN: equ 5 
a019				OPCODE_SCOLN: equ 6 
a019				OPCODE_DROP: equ 7 
a019				OPCODE_DUP2: equ 8 
a019				OPCODE_DROP2: equ 9 
a019				OPCODE_SWAP2: equ 10 
a019				OPCODE_AT: equ 11 
a019				OPCODE_CAT: equ 12 
a019				OPCODE_BANG: equ 13 
a019				OPCODE_CBANG: equ 14 
a019				OPCODE_SCALL: equ 15 
a019				OPCODE_DEPTH: equ 16 
a019				OPCODE_OVER: equ 17 
a019				OPCODE_PAUSE: equ 18 
a019				OPCODE_PAUSES: equ 19 
a019				OPCODE_ROT: equ 20 
a019			;free to reuse	OPCODE_WORDS: equ 21 
a019			        OPCODE_NOT: equ 21 
a019				OPCODE_UWORDS: equ 22 
a019				OPCODE_BP: equ 23 
a019				OPCODE_MONITOR: equ 24  
a019				OPCODE_MALLOC: equ 25 
a019				OPCODE_FREE: equ 26 
a019				OPCODE_LIST: equ 27 
a019				OPCODE_FORGET: equ 28 
a019				OPCODE_NOP: equ 29 
a019				OPCODE_COMO: equ 30 
a019				OPCODE_COMC: equ 31 
a019			;free to reuse	OPCODE_ENDCORE: equ 32 
a019				OPCODE_AFTERSOUND: equ 33 
a019				OPCODE_GP2: equ 34 
a019				OPCODE_GP3: equ 35 
a019				OPCODE_GP4: equ 36 
a019				OPCODE_SIN: equ 37 
a019				OPCODE_SOUT: equ 38 
a019				OPCODE_SPIO: equ 39 
a019				OPCODE_SPICEH: equ 40 
a019				OPCODE_SPIOb: equ 41 
a019				OPCODE_SPII: equ 42 
a019				OPCODE_SESEL: equ 43 
a019				OPCODE_CARTDEV: equ 44 
a019			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a019				OPCODE_FB: equ 46 
a019				OPCODE_EMIT: equ 47 
a019				OPCODE_DOTH: equ 48 
a019				OPCODE_DOTF: equ 49 
a019				OPCODE_DOT: equ 50 
a019				OPCODE_CLS: equ 51 
a019				OPCODE_DRAW: equ 52 
a019				OPCODE_DUMP: equ 53 
a019				OPCODE_CDUMP: equ 54 
a019				OPCODE_DAT: equ 55 
a019				OPCODE_HOME: equ 56 
a019				OPCODE_SPACE: equ 57 
a019				OPCODE_SPACES: equ 58 
a019				OPCODE_SCROLL: equ 59 
a019				OPCODE_ATQ: equ 60 
a019				OPCODE_AUTODSP: equ 61 
a019				OPCODE_MENU: equ 62 
a019			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a019				OPCODE_THEN: equ 64 
a019				OPCODE_ELSE: equ 65 
a019				OPCODE_DO: equ 66 
a019				OPCODE_LOOP: equ 67 
a019				OPCODE_I: equ 68 
a019				OPCODE_DLOOP: equ 69  
a019				OPCODE_REPEAT: equ 70  
a019				OPCODE_UNTIL: equ 71 
a019				OPCODE_ENDFLOW: equ 72 
a019				OPCODE_WAITK: equ 73 
a019				OPCODE_ACCEPT: equ 74 
a019				OPCODE_EDIT: equ 75 
a019			;free to reuse	OPCODE_ENDKEY: equ 76 
a019				OPCODE_LZERO: equ 77 
a019				OPCODE_TZERO: equ 78 
a019				OPCODE_LESS: equ 79 
a019				OPCODE_GT: equ 80 
a019				OPCODE_EQUAL: equ 81  
a019			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a019				OPCODE_NEG: equ 83 
a019				OPCODE_DIV: equ 84 
a019				OPCODE_MUL: equ 85 
a019				OPCODE_MIN: equ 86 
a019				OPCODE_MAX: equ 87 
a019				OPCODE_RND16: equ 88 
a019				OPCODE_RND8: equ 89 
a019				OPCODE_RND: equ 90 
a019			;free to reuse	OPCODE_ENDMATHS: equ 91  
a019				OPCODE_BYNAME: equ 92 
a019				OPCODE_DIR: equ 93 
a019				OPCODE_SAVE: equ 94 
a019				OPCODE_LOAD: equ 95 
a019				OPCODE_BSAVE: equ 96 
a019				OPCODE_BLOAD: equ 97 
a019				OPCODE_SEO: equ 98  
a019				OPCODE_SEI: equ 99 
a019				OPCODE_SFREE: equ 100 
a019				OPCODE_SIZE: equ 101 
a019				OPCODE_CREATE: equ 102 
a019				OPCODE_APPEND: equ 103 
a019				OPCODE_SDEL: equ 104 
a019				OPCODE_OPEN: equ 105 
a019				OPCODE_READ: equ 106 
a019				OPCODE_EOF: equ 106 
a019				OPCODE_FORMAT: equ 107 
a019				OPCODE_LABEL: equ 108 
a019				OPCODE_LABELS: equ 109 
a019			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a019				OPCODE_UPPER: equ 111 
a019				OPCODE_LOWER: equ 112 
a019				OPCODE_SUBSTR: equ 113 
a019				OPCODE_LEFT: equ 114 
a019				OPCODE_RIGHT: equ 115 
a019				OPCODE_STR2NUM: equ 116 
a019				OPCODE_NUM2STR: equ 117 
a019				OPCODE_CONCAT: equ 118 
a019				OPCODE_FIND: equ 119 
a019				OPCODE_LEN: equ 120 
a019				OPCODE_CHAR: equ 121 
a019			; free to reuse	OPCODE_STRLEN: equ 122 
a019			; free to reuse	OPCODE_ENDSTR: equ 123 
a019				OPCODE_V0S: equ 124 
a019				OPCODE_V0Q: equ 125 
a019				OPCODE_V1S: equ 126 
a019				OPCODE_V1Q: equ 127 
a019				OPCODE_V2S: equ 128 
a019				OPCODE_V2Q: equ 129 
a019				OPCODE_V3S: equ 130 
a019				OPCODE_V3Q: equ 131 
a019			;free to reuse	OPCODE_END: equ 132 
a019				OPCODE_ZDUP: equ 133 
a019			 
a019			; eof 
# End of file forth_opcodes.asm
a019			 
a019			include "forth_words_core.asm" 
a019			 
a019			; | ## Core Words 
a019			 
a019			;if MALLOC_4 
a019			 
a019			.HEAP: 
a019				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a019 15				db WORD_SYS_CORE+OPCODE_HEAP             
a01a 58 a0			dw .EXEC            
a01c 05				db 4 + 1 
a01d .. 00			db "HEAP",0              
a022				endm 
# End of macro CWHEAD
a022			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a022			; | | u1 - Current number of bytes in the heap 
a022			; | | u2 - Remaining bytes left on the heap 
a022			; | |  
a022			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a022			 
a022			 
a022					if DEBUG_FORTH_WORDS_KEY 
a022						DMARK "HEP" 
a022 f5				push af  
a023 3a 37 a0			ld a, (.dmark)  
a026 32 71 ee			ld (debug_mark),a  
a029 3a 38 a0			ld a, (.dmark+1)  
a02c 32 72 ee			ld (debug_mark+1),a  
a02f 3a 39 a0			ld a, (.dmark+2)  
a032 32 73 ee			ld (debug_mark+2),a  
a035 18 03			jr .pastdmark  
a037 ..			.dmark: db "HEP"  
a03a f1			.pastdmark: pop af  
a03b			endm  
# End of macro DMARK
a03b						CALLMONITOR 
a03b cd a3 94			call break_point_state  
a03e				endm  
# End of macro CALLMONITOR
a03e					endif 
a03e 2a d4 e2				ld hl, (free_list )      
a041 11 d9 e2				ld de, heap_start 
a044			 
a044 ed 52				sbc hl, de  
a046			 
a046 cd 14 9b				call forth_push_numhl 
a049			 
a049			 
a049 ed 5b d4 e2			ld de, (free_list )      
a04d 21 b1 e2				ld hl, heap_end 
a050			 
a050 ed 52				sbc hl, de 
a052			 
a052 cd 14 9b				call forth_push_numhl 
a055					 
a055			 
a055					 
a055			 
a055			 
a055			 
a055					NEXTW 
a055 c3 c1 9e			jp macro_next 
a058				endm 
# End of macro NEXTW
a058			;endif 
a058			 
a058			.EXEC: 
a058			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a058			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a058			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a058			;; > > 
a058			;; > >   
a058			;	STACKFRAME OFF $5efe $5f9f 
a058			; 
a058			;		if DEBUG_FORTH_WORDS_KEY 
a058			;			DMARK "EXE" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	FORTH_DSP_VALUEHL 
a058			; 
a058			;	FORTH_DSP_POP 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX1" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;;	ld e,(hl) 
a058			;;	inc hl 
a058			;;	ld d,(hl) 
a058			;;	ex de,hl 
a058			; 
a058			;;		if DEBUG_FORTH_WORDS 
a058			;;			DMARK "EX2" 
a058			;;			CALLMONITOR 
a058			;;		endif 
a058			;	push hl 
a058			; 
a058			;	;ld a, 0 
a058			;	;ld a, FORTH_END_BUFFER 
a058			;	call strlenz 
a058			;	inc hl   ; include zero term to copy 
a058			;	inc hl   ; include term 
a058			;	inc hl   ; include term 
a058			;	ld b,0 
a058			;	ld c,l 
a058			;	pop hl 
a058			;	ld de, execscratch 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX3" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ldir 
a058			; 
a058			; 
a058			;	ld hl, execscratch 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXe" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	call forthparse 
a058			;	call forthexec 
a058			;;	call forthexec_cleanup 
a058			;;	call forthparse 
a058			;;	call forthexec 
a058			; 
a058			;	STACKFRAMECHK OFF $5efe $5f9f 
a058			; 
a058			;	; an immediate word so no need to process any more words 
a058			;	ret 
a058			;	NEXTW 
a058			 
a058			; dead code - old version  
a058			;	FORTH_RSP_NEXT 
a058			 
a058			;  
a058			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a058			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a058			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a058			;	push hl 
a058			;	push de 
a058			;	push bc 
a058			; 
a058			; 
a058			;		if DEBUG_FORTH_WORDS_KEY 
a058			;			DMARK "EXR" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			; 
a058			; 
a058			;	;v5 FORTH_DSP_VALUE 
a058			;	FORTH_DSP_VALUEHL 
a058			; 
a058			;	; TODO do string type checks 
a058			; 
a058			;;v5	inc hl   ; skip type 
a058			; 
a058			;	push hl  ; source code  
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX1" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ld a, 0 
a058			;	call strlent 
a058			; 
a058			;	inc hl 
a058			;	inc hl 
a058			;	inc hl 
a058			;	inc hl 
a058			; 
a058			;	push hl    ; size 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX2" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	call malloc 
a058			; 
a058			;	ex de, hl    ; de now contains malloc area 
a058			;	pop bc   	; get byte count 
a058			;	pop hl      ; get string to copy 
a058			; 
a058			;	push de     ; save malloc for free later 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX3" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ldir       ; duplicate string 
a058			; 
a058			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a058			;	 
a058			;	; TODO fix the parse would be better than this...  
a058			;	ex de, hl 
a058			;	dec hl 
a058			;	ld a, 0 
a058			;	ld (hl), a 
a058			;	dec hl 
a058			;	ld a, ' ' 
a058			;	ld (hl), a 
a058			;	dec hl 
a058			;	ld (hl), a 
a058			; 
a058			;	dec hl 
a058			;	ld (hl), a 
a058			; 
a058			; 
a058			;	FORTH_DSP_POP  
a058			; 
a058			;	pop hl     
a058			;	push hl    ; save malloc area 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX4" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	call forthparse 
a058			;	call forthexec 
a058			;	 
a058			;	pop hl 
a058			;	if DEBUG_FORTH_WORDS 
a058			;		DMARK "EX5" 
a058			;		CALLMONITOR 
a058			;	endif 
a058			; 
a058			;	if FORTH_ENABLE_FREE 
a058			;	call free 
a058			;	endif 
a058			; 
a058			;	if DEBUG_FORTH_WORDS 
a058			;		DMARK "EX6" 
a058			;		CALLMONITOR 
a058			;	endif 
a058			; 
a058			;	pop bc 
a058			;	pop de 
a058			;	pop hl 
a058			;;	FORTH_RSP_POP	  
a058			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a058			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a058			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a058			; 
a058			;	if DEBUG_FORTH_WORDS 
a058			;		DMARK "EX7" 
a058			;		CALLMONITOR 
a058			;	endif 
a058			;	NEXTW 
a058			 
a058			;.STKEXEC: 
a058			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a058			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a058			; 
a058			; 
a058			;		if DEBUG_FORTH_WORDS_KEY 
a058			;			DMARK "STX" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	FORTH_DSP_VALUEHL 
a058			; 
a058			;	ld (store_tmp1), hl    ; count 
a058			; 
a058			;	FORTH_DSP_POP 
a058			;.stkexec1: 
a058			;	ld hl, (store_tmp1)   ; count 
a058			;	ld a, 0 
a058			;	cp l 
a058			;	ret z 
a058			; 
a058			;	dec hl 
a058			;	ld (store_tmp1), hl    ; count 
a058			;	 
a058			;	FORTH_DSP_VALUEHL 
a058			;	push hl 
a058			;	 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXp" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	FORTH_DSP_POP 
a058			; 
a058			;	call strlenz 
a058			;	inc hl   ; include zero term to copy 
a058			;	inc hl   ; include zero term to copy 
a058			;	inc hl   ; include zero term to copy 
a058			;	ld b,0 
a058			;	ld c,l 
a058			;	pop hl 
a058			;	ld de, execscratch 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EX3" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	ldir 
a058			; 
a058			; 
a058			;	ld hl, execscratch 
a058			; 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXP" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			; 
a058			;	call forthparse 
a058			;	ld hl, execscratch 
a058			;		if DEBUG_FORTH_WORDS 
a058			;			DMARK "EXx" 
a058			;			CALLMONITOR 
a058			;		endif 
a058			;	call forthexec 
a058			; 
a058			;	jp .stkexec1 
a058			; 
a058			;	ret 
a058			 
a058			 
a058			.DUP: 
a058				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a058 17				db WORD_SYS_CORE+OPCODE_DUP             
a059 ce a0			dw .ZDUP            
a05b 04				db 3 + 1 
a05c .. 00			db "DUP",0              
a060				endm 
# End of macro CWHEAD
a060			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a060			 
a060					if DEBUG_FORTH_WORDS_KEY 
a060						DMARK "DUP" 
a060 f5				push af  
a061 3a 75 a0			ld a, (.dmark)  
a064 32 71 ee			ld (debug_mark),a  
a067 3a 76 a0			ld a, (.dmark+1)  
a06a 32 72 ee			ld (debug_mark+1),a  
a06d 3a 77 a0			ld a, (.dmark+2)  
a070 32 73 ee			ld (debug_mark+2),a  
a073 18 03			jr .pastdmark  
a075 ..			.dmark: db "DUP"  
a078 f1			.pastdmark: pop af  
a079			endm  
# End of macro DMARK
a079						CALLMONITOR 
a079 cd a3 94			call break_point_state  
a07c				endm  
# End of macro CALLMONITOR
a07c					endif 
a07c			 
a07c					FORTH_DSP 
a07c cd d1 9c			call macro_forth_dsp 
a07f				endm 
# End of macro FORTH_DSP
a07f			 
a07f 7e					ld a, (HL) 
a080 fe 01				cp DS_TYPE_STR 
a082 20 25				jr nz, .dupinum 
a084			 
a084					; push another string 
a084			 
a084					FORTH_DSP_VALUEHL     		 
a084 cd 0b 9d			call macro_dsp_valuehl 
a087				endm 
# End of macro FORTH_DSP_VALUEHL
a087			 
a087				if DEBUG_FORTH_WORDS 
a087					DMARK "DUs" 
a087 f5				push af  
a088 3a 9c a0			ld a, (.dmark)  
a08b 32 71 ee			ld (debug_mark),a  
a08e 3a 9d a0			ld a, (.dmark+1)  
a091 32 72 ee			ld (debug_mark+1),a  
a094 3a 9e a0			ld a, (.dmark+2)  
a097 32 73 ee			ld (debug_mark+2),a  
a09a 18 03			jr .pastdmark  
a09c ..			.dmark: db "DUs"  
a09f f1			.pastdmark: pop af  
a0a0			endm  
# End of macro DMARK
a0a0					CALLMONITOR 
a0a0 cd a3 94			call break_point_state  
a0a3				endm  
# End of macro CALLMONITOR
a0a3				endif 
a0a3 cd 82 9b				call forth_push_str 
a0a6			 
a0a6					NEXTW 
a0a6 c3 c1 9e			jp macro_next 
a0a9				endm 
# End of macro NEXTW
a0a9			 
a0a9			 
a0a9			.dupinum: 
a0a9					 
a0a9			 
a0a9			 
a0a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0a9 cd 0b 9d			call macro_dsp_valuehl 
a0ac				endm 
# End of macro FORTH_DSP_VALUEHL
a0ac			 
a0ac				; TODO add floating point number detection 
a0ac			 
a0ac				if DEBUG_FORTH_WORDS 
a0ac					DMARK "DUi" 
a0ac f5				push af  
a0ad 3a c1 a0			ld a, (.dmark)  
a0b0 32 71 ee			ld (debug_mark),a  
a0b3 3a c2 a0			ld a, (.dmark+1)  
a0b6 32 72 ee			ld (debug_mark+1),a  
a0b9 3a c3 a0			ld a, (.dmark+2)  
a0bc 32 73 ee			ld (debug_mark+2),a  
a0bf 18 03			jr .pastdmark  
a0c1 ..			.dmark: db "DUi"  
a0c4 f1			.pastdmark: pop af  
a0c5			endm  
# End of macro DMARK
a0c5					CALLMONITOR 
a0c5 cd a3 94			call break_point_state  
a0c8				endm  
# End of macro CALLMONITOR
a0c8				endif 
a0c8			 
a0c8 cd 14 9b				call forth_push_numhl 
a0cb					NEXTW 
a0cb c3 c1 9e			jp macro_next 
a0ce				endm 
# End of macro NEXTW
a0ce			.ZDUP: 
a0ce				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a0ce 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0cf 06 a1			dw .SWAP            
a0d1 05				db 4 + 1 
a0d2 .. 00			db "?DUP",0              
a0d7				endm 
# End of macro CWHEAD
a0d7			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a0d7			 
a0d7					if DEBUG_FORTH_WORDS_KEY 
a0d7						DMARK "qDU" 
a0d7 f5				push af  
a0d8 3a ec a0			ld a, (.dmark)  
a0db 32 71 ee			ld (debug_mark),a  
a0de 3a ed a0			ld a, (.dmark+1)  
a0e1 32 72 ee			ld (debug_mark+1),a  
a0e4 3a ee a0			ld a, (.dmark+2)  
a0e7 32 73 ee			ld (debug_mark+2),a  
a0ea 18 03			jr .pastdmark  
a0ec ..			.dmark: db "qDU"  
a0ef f1			.pastdmark: pop af  
a0f0			endm  
# End of macro DMARK
a0f0						CALLMONITOR 
a0f0 cd a3 94			call break_point_state  
a0f3				endm  
# End of macro CALLMONITOR
a0f3					endif 
a0f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0f3 cd 0b 9d			call macro_dsp_valuehl 
a0f6				endm 
# End of macro FORTH_DSP_VALUEHL
a0f6			 
a0f6 e5					push hl 
a0f7			 
a0f7					; is it a zero? 
a0f7			 
a0f7 3e 00				ld a, 0 
a0f9 84					add h 
a0fa 85					add l 
a0fb			 
a0fb e1					pop hl 
a0fc			 
a0fc fe 00				cp 0 
a0fe 28 03				jr z, .dup2orig 
a100			 
a100			 
a100 cd 14 9b				call forth_push_numhl 
a103			 
a103			 
a103				; TODO add floating point number detection 
a103			 
a103			.dup2orig: 
a103			 
a103					NEXTW 
a103 c3 c1 9e			jp macro_next 
a106				endm 
# End of macro NEXTW
a106			.SWAP: 
a106				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a106 18				db WORD_SYS_CORE+OPCODE_SWAP             
a107 45 a1			dw .COLN            
a109 05				db 4 + 1 
a10a .. 00			db "SWAP",0              
a10f				endm 
# End of macro CWHEAD
a10f			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a10f					if DEBUG_FORTH_WORDS_KEY 
a10f						DMARK "SWP" 
a10f f5				push af  
a110 3a 24 a1			ld a, (.dmark)  
a113 32 71 ee			ld (debug_mark),a  
a116 3a 25 a1			ld a, (.dmark+1)  
a119 32 72 ee			ld (debug_mark+1),a  
a11c 3a 26 a1			ld a, (.dmark+2)  
a11f 32 73 ee			ld (debug_mark+2),a  
a122 18 03			jr .pastdmark  
a124 ..			.dmark: db "SWP"  
a127 f1			.pastdmark: pop af  
a128			endm  
# End of macro DMARK
a128						CALLMONITOR 
a128 cd a3 94			call break_point_state  
a12b				endm  
# End of macro CALLMONITOR
a12b					endif 
a12b			 
a12b					FORTH_DSP_VALUEHL 
a12b cd 0b 9d			call macro_dsp_valuehl 
a12e				endm 
# End of macro FORTH_DSP_VALUEHL
a12e e5					push hl     ; w2 
a12f			 
a12f					FORTH_DSP_POP 
a12f cd c3 9d			call macro_forth_dsp_pop 
a132				endm 
# End of macro FORTH_DSP_POP
a132			 
a132					FORTH_DSP_VALUEHL 
a132 cd 0b 9d			call macro_dsp_valuehl 
a135				endm 
# End of macro FORTH_DSP_VALUEHL
a135			 
a135					FORTH_DSP_POP 
a135 cd c3 9d			call macro_forth_dsp_pop 
a138				endm 
# End of macro FORTH_DSP_POP
a138			 
a138 d1					pop de     ; w2	, hl = w1 
a139			 
a139 eb					ex de, hl 
a13a d5					push de 
a13b			 
a13b cd 14 9b				call forth_push_numhl 
a13e			 
a13e e1					pop hl 
a13f			 
a13f cd 14 9b				call forth_push_numhl 
a142					 
a142			 
a142					NEXTW 
a142 c3 c1 9e			jp macro_next 
a145				endm 
# End of macro NEXTW
a145			.COLN: 
a145				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a145 19				db WORD_SYS_CORE+OPCODE_COLN             
a146 d1 a2			dw .SCOLN            
a148 02				db 1 + 1 
a149 .. 00			db ":",0              
a14b				endm 
# End of macro CWHEAD
a14b			; | : ( -- )         Create new word | DONE 
a14b			 
a14b					if DEBUG_FORTH_WORDS_KEY 
a14b						DMARK "CLN" 
a14b f5				push af  
a14c 3a 60 a1			ld a, (.dmark)  
a14f 32 71 ee			ld (debug_mark),a  
a152 3a 61 a1			ld a, (.dmark+1)  
a155 32 72 ee			ld (debug_mark+1),a  
a158 3a 62 a1			ld a, (.dmark+2)  
a15b 32 73 ee			ld (debug_mark+2),a  
a15e 18 03			jr .pastdmark  
a160 ..			.dmark: db "CLN"  
a163 f1			.pastdmark: pop af  
a164			endm  
# End of macro DMARK
a164						CALLMONITOR 
a164 cd a3 94			call break_point_state  
a167				endm  
# End of macro CALLMONITOR
a167					endif 
a167				STACKFRAME OFF $8efe $989f 
a167				if DEBUG_STACK_IMB 
a167					if OFF 
a167						exx 
a167						ld de, $8efe 
a167						ld a, d 
a167						ld hl, curframe 
a167						call hexout 
a167						ld a, e 
a167						ld hl, curframe+2 
a167						call hexout 
a167						ld hl, $8efe 
a167						push hl 
a167						ld hl, $989f 
a167						push hl 
a167						exx 
a167					endif 
a167				endif 
a167			endm 
# End of macro STACKFRAME
a167				; get parser buffer length  of new word 
a167			 
a167				 
a167			 
a167					; move tok past this to start of name defintition 
a167					; TODO get word to define 
a167					; TODO Move past word token 
a167					; TODO get length of string up to the ';' 
a167			 
a167 2a cc e5			ld hl, (os_tok_ptr) 
a16a 23				inc hl 
a16b 23				inc hl 
a16c			 
a16c 3e 3b			ld a, ';' 
a16e cd 0b 91			call strlent 
a171			 
a171 7d				ld a,l 
a172 32 c7 e2			ld (os_new_parse_len), a 
a175			 
a175			 
a175			if DEBUG_FORTH_UWORD 
a175 ed 5b cc e5		ld de, (os_tok_ptr) 
a179						DMARK ":01" 
a179 f5				push af  
a17a 3a 8e a1			ld a, (.dmark)  
a17d 32 71 ee			ld (debug_mark),a  
a180 3a 8f a1			ld a, (.dmark+1)  
a183 32 72 ee			ld (debug_mark+1),a  
a186 3a 90 a1			ld a, (.dmark+2)  
a189 32 73 ee			ld (debug_mark+2),a  
a18c 18 03			jr .pastdmark  
a18e ..			.dmark: db ":01"  
a191 f1			.pastdmark: pop af  
a192			endm  
# End of macro DMARK
a192				CALLMONITOR 
a192 cd a3 94			call break_point_state  
a195				endm  
# End of macro CALLMONITOR
a195			endif 
a195			 
a195			; 
a195			;  new word memory layout: 
a195			;  
a195			;    : adg 6666 ;  
a195			; 
a195			;    db   1     ; user defined word  
a195 23				inc hl    
a196			;    dw   sysdict 
a196 23				inc hl 
a197 23				inc hl 
a198			;    db <word len>+1 (for null) 
a198 23				inc hl 
a199			;    db .... <word> 
a199			; 
a199			 
a199 23				inc hl    ; some extras for the word preamble before the above 
a19a 23				inc hl 
a19b 23				inc hl 
a19c 23				inc hl 
a19d 23				inc hl 
a19e 23				inc hl 
a19f 23				inc hl  
a1a0 23				inc hl 
a1a1 23				inc hl 
a1a2 23				inc hl 
a1a3 23				inc hl 
a1a4 23				inc hl 
a1a5 23				inc hl 
a1a6 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1a7			;       exec word buffer 
a1a7			;	<ptr word>   
a1a7 23				inc hl 
a1a8 23				inc hl 
a1a9			;       <word list><null term> 7F final term 
a1a9			 
a1a9			 
a1a9			if DEBUG_FORTH_UWORD 
a1a9						DMARK ":02" 
a1a9 f5				push af  
a1aa 3a be a1			ld a, (.dmark)  
a1ad 32 71 ee			ld (debug_mark),a  
a1b0 3a bf a1			ld a, (.dmark+1)  
a1b3 32 72 ee			ld (debug_mark+1),a  
a1b6 3a c0 a1			ld a, (.dmark+2)  
a1b9 32 73 ee			ld (debug_mark+2),a  
a1bc 18 03			jr .pastdmark  
a1be ..			.dmark: db ":02"  
a1c1 f1			.pastdmark: pop af  
a1c2			endm  
# End of macro DMARK
a1c2				CALLMONITOR 
a1c2 cd a3 94			call break_point_state  
a1c5				endm  
# End of macro CALLMONITOR
a1c5			endif 
a1c5			 
a1c5				 
a1c5					; malloc the size 
a1c5			 
a1c5 cd 69 91				call malloc 
a1c8 22 c9 e2				ld (os_new_malloc), hl     ; save malloc start 
a1cb			 
a1cb			;    db   1     ; user defined word  
a1cb 3e 01				ld a, WORD_SYS_UWORD  
a1cd 77					ld (hl), a 
a1ce				 
a1ce 23				inc hl    
a1cf			;    dw   sysdict 
a1cf 11 19 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a1d2 73				ld (hl), e 
a1d3 23				inc hl 
a1d4 72				ld (hl), d 
a1d5 23				inc hl 
a1d6			 
a1d6			 
a1d6			;    Setup dict word 
a1d6			 
a1d6 23				inc hl 
a1d7 22 c3 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a1da			 
a1da				; 1. get length of dict word 
a1da			 
a1da			 
a1da 2a cc e5			ld hl, (os_tok_ptr) 
a1dd 23				inc hl 
a1de 23				inc hl    ; position to start of dict word 
a1df 3e 00			ld a, 0 
a1e1 cd 0b 91			call strlent 
a1e4			 
a1e4			 
a1e4 23				inc hl    ; to include null??? 
a1e5			 
a1e5				; write length of dict word 
a1e5			 
a1e5 ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1e9 1b				dec de 
a1ea eb				ex de, hl 
a1eb 73				ld (hl), e 
a1ec eb				ex de, hl 
a1ed			 
a1ed				 
a1ed			 
a1ed				; copy  
a1ed 4d				ld c, l 
a1ee 06 00			ld b, 0 
a1f0 ed 5b c3 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1f4 2a cc e5			ld hl, (os_tok_ptr) 
a1f7 23				inc hl 
a1f8 23				inc hl    ; position to start of dict word 
a1f9				 
a1f9			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1f9				 
a1f9				; TODO need to convert word to upper case 
a1f9			 
a1f9			ucasetok:	 
a1f9 7e				ld a,(hl) 
a1fa cd f7 90			call toUpper 
a1fd 77				ld (hl),a 
a1fe ed a0			ldi 
a200 f2 f9 a1		 	jp p, ucasetok 
a203			 
a203			 
a203			 
a203				; de now points to start of where the word body code should be placed 
a203 ed 53 c3 e2		ld (os_new_work_ptr), de 
a207				; hl now points to the words to throw at forthexec which needs to be copied 
a207 22 c1 e2			ld (os_new_src_ptr), hl 
a20a			 
a20a				; TODO add 'call to forthexec' 
a20a			 
a20a			if DEBUG_FORTH_UWORD 
a20a c5				push bc 
a20b ed 4b c9 e2		ld bc, (os_new_malloc) 
a20f						DMARK ":0x" 
a20f f5				push af  
a210 3a 24 a2			ld a, (.dmark)  
a213 32 71 ee			ld (debug_mark),a  
a216 3a 25 a2			ld a, (.dmark+1)  
a219 32 72 ee			ld (debug_mark+1),a  
a21c 3a 26 a2			ld a, (.dmark+2)  
a21f 32 73 ee			ld (debug_mark+2),a  
a222 18 03			jr .pastdmark  
a224 ..			.dmark: db ":0x"  
a227 f1			.pastdmark: pop af  
a228			endm  
# End of macro DMARK
a228				CALLMONITOR 
a228 cd a3 94			call break_point_state  
a22b				endm  
# End of macro CALLMONITOR
a22b c1				pop bc 
a22c			endif 
a22c			 
a22c			 
a22c				; create word preamble which should be: 
a22c			 
a22c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a22c			 
a22c				;    ld hl, <word code> 
a22c				;    jp user_exec 
a22c			        ;    <word code bytes> 
a22c			 
a22c			 
a22c			;	inc de     ; TODO ??? or are we already past the word's null 
a22c eb				ex de, hl 
a22d			 
a22d 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a22f			 
a22f 23				inc hl 
a230 22 bd e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a233 23				inc hl 
a234			 
a234 23				inc hl 
a235 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a237			 
a237 01 ae ca			ld bc, user_exec 
a23a 23				inc hl 
a23b 71				ld (hl), c     ; poke address of user_exec 
a23c 23				inc hl 
a23d 70				ld (hl), b     
a23e			 ; 
a23e			;	inc hl 
a23e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a23e			; 
a23e			; 
a23e			;	ld bc, macro_forth_rsp_next 
a23e			;	inc hl 
a23e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a23e			;	inc hl 
a23e			;	ld (hl), b     
a23e			 ; 
a23e			;	inc hl 
a23e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a23e			; 
a23e			; 
a23e			;	inc hl 
a23e			;	ld bc, forthexec 
a23e			;	ld (hl), c     ; poke address of forthexec 
a23e			;	inc hl 
a23e			;	ld (hl), b      
a23e			; 
a23e			;	inc hl 
a23e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a23e			; 
a23e			;	ld bc, user_dict_next 
a23e			;	inc hl 
a23e			;	ld (hl), c     ; poke address of forthexec 
a23e			;	inc hl 
a23e			;	ld (hl), b      
a23e			 
a23e				; hl is now where we need to copy the word byte data to save this 
a23e			 
a23e 23				inc hl 
a23f 22 bf e2			ld (os_new_exec), hl 
a242				 
a242				; copy definition 
a242			 
a242 eb				ex de, hl 
a243			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a243			;	inc de    ; skip the PC for this parse 
a243 3a c7 e2			ld a, (os_new_parse_len) 
a246 4f				ld c, a 
a247 06 00			ld b, 0 
a249 ed b0			ldir		 ; copy defintion 
a24b			 
a24b			 
a24b				; poke the address of where the new word bytes live for forthexec 
a24b			 
a24b 2a bd e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a24e			 
a24e ed 5b bf e2		ld de, (os_new_exec)      
a252				 
a252 73				ld (hl), e 
a253 23				inc hl 
a254 72				ld (hl), d 
a255			 
a255					; TODO copy last user dict word next link to this word 
a255					; TODO update last user dict word to point to this word 
a255			; 
a255			; hl f923 de 812a ; bc 811a 
a255			 
a255			if DEBUG_FORTH_UWORD 
a255 c5				push bc 
a256 ed 4b c9 e2		ld bc, (os_new_malloc) 
a25a						DMARK ":0A" 
a25a f5				push af  
a25b 3a 6f a2			ld a, (.dmark)  
a25e 32 71 ee			ld (debug_mark),a  
a261 3a 70 a2			ld a, (.dmark+1)  
a264 32 72 ee			ld (debug_mark+1),a  
a267 3a 71 a2			ld a, (.dmark+2)  
a26a 32 73 ee			ld (debug_mark+2),a  
a26d 18 03			jr .pastdmark  
a26f ..			.dmark: db ":0A"  
a272 f1			.pastdmark: pop af  
a273			endm  
# End of macro DMARK
a273				CALLMONITOR 
a273 cd a3 94			call break_point_state  
a276				endm  
# End of macro CALLMONITOR
a276 c1				pop bc 
a277			endif 
a277			if DEBUG_FORTH_UWORD 
a277 c5				push bc 
a278 ed 4b c9 e2		ld bc, (os_new_malloc) 
a27c 03				inc bc 
a27d 03				inc bc 
a27e 03				inc bc 
a27f 03				inc bc 
a280 03				inc bc 
a281 03				inc bc 
a282 03				inc bc 
a283 03				inc bc 
a284			 
a284						DMARK ":0B" 
a284 f5				push af  
a285 3a 99 a2			ld a, (.dmark)  
a288 32 71 ee			ld (debug_mark),a  
a28b 3a 9a a2			ld a, (.dmark+1)  
a28e 32 72 ee			ld (debug_mark+1),a  
a291 3a 9b a2			ld a, (.dmark+2)  
a294 32 73 ee			ld (debug_mark+2),a  
a297 18 03			jr .pastdmark  
a299 ..			.dmark: db ":0B"  
a29c f1			.pastdmark: pop af  
a29d			endm  
# End of macro DMARK
a29d				CALLMONITOR 
a29d cd a3 94			call break_point_state  
a2a0				endm  
# End of macro CALLMONITOR
a2a0 c1				pop bc 
a2a1			endif 
a2a1			 
a2a1			; update word dict linked list for new word 
a2a1			 
a2a1			 
a2a1 2a c8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2a4 23			inc hl     ; move to next work linked list ptr 
a2a5			 
a2a5 ed 5b c9 e2	ld de, (os_new_malloc)		 ; new next word 
a2a9 73			ld (hl), e 
a2aa 23			inc hl 
a2ab 72			ld (hl), d 
a2ac			 
a2ac			if DEBUG_FORTH_UWORD 
a2ac ed 4b c8 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2b0			endif 
a2b0			 
a2b0 ed 53 c8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2b4			 
a2b4			 
a2b4			if DEBUG_FORTH_UWORD 
a2b4						DMARK ":0+" 
a2b4 f5				push af  
a2b5 3a c9 a2			ld a, (.dmark)  
a2b8 32 71 ee			ld (debug_mark),a  
a2bb 3a ca a2			ld a, (.dmark+1)  
a2be 32 72 ee			ld (debug_mark+1),a  
a2c1 3a cb a2			ld a, (.dmark+2)  
a2c4 32 73 ee			ld (debug_mark+2),a  
a2c7 18 03			jr .pastdmark  
a2c9 ..			.dmark: db ":0+"  
a2cc f1			.pastdmark: pop af  
a2cd			endm  
# End of macro DMARK
a2cd				CALLMONITOR 
a2cd cd a3 94			call break_point_state  
a2d0				endm  
# End of macro CALLMONITOR
a2d0			endif 
a2d0			 
a2d0				STACKFRAMECHK OFF $8efe $989f 
a2d0				if DEBUG_STACK_IMB 
a2d0					if OFF 
a2d0						exx 
a2d0						ld hl, $989f 
a2d0						pop de   ; $989f 
a2d0						call cmp16 
a2d0						jr nz, .spnosame 
a2d0						ld hl, $8efe 
a2d0						pop de   ; $8efe 
a2d0						call cmp16 
a2d0						jr z, .spfrsame 
a2d0						.spnosame: call showsperror 
a2d0						.spfrsame: nop 
a2d0						exx 
a2d0					endif 
a2d0				endif 
a2d0			endm 
# End of macro STACKFRAMECHK
a2d0			 
a2d0 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2d1			 
a2d1			 
a2d1			 
a2d1			 
a2d1			;		NEXT 
a2d1			.SCOLN: 
a2d1			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2d1 06				db OPCODE_SCOLN 
a2d2 1d a3			dw .DROP 
a2d4 02				db 2 
a2d5 .. 00			db ";",0           
a2d7			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2d7					if DEBUG_FORTH_WORDS_KEY 
a2d7						DMARK "SCN" 
a2d7 f5				push af  
a2d8 3a ec a2			ld a, (.dmark)  
a2db 32 71 ee			ld (debug_mark),a  
a2de 3a ed a2			ld a, (.dmark+1)  
a2e1 32 72 ee			ld (debug_mark+1),a  
a2e4 3a ee a2			ld a, (.dmark+2)  
a2e7 32 73 ee			ld (debug_mark+2),a  
a2ea 18 03			jr .pastdmark  
a2ec ..			.dmark: db "SCN"  
a2ef f1			.pastdmark: pop af  
a2f0			endm  
# End of macro DMARK
a2f0						CALLMONITOR 
a2f0 cd a3 94			call break_point_state  
a2f3				endm  
# End of macro CALLMONITOR
a2f3					endif 
a2f3					FORTH_RSP_TOS 
a2f3 cd d2 9a			call macro_forth_rsp_tos 
a2f6				endm 
# End of macro FORTH_RSP_TOS
a2f6 e5					push hl 
a2f7					FORTH_RSP_POP 
a2f7 cd dc 9a			call macro_forth_rsp_pop 
a2fa				endm 
# End of macro FORTH_RSP_POP
a2fa e1					pop hl 
a2fb			;		ex de,hl 
a2fb 22 cc e5				ld (os_tok_ptr),hl 
a2fe			 
a2fe			if DEBUG_FORTH_UWORD 
a2fe						DMARK "SCL" 
a2fe f5				push af  
a2ff 3a 13 a3			ld a, (.dmark)  
a302 32 71 ee			ld (debug_mark),a  
a305 3a 14 a3			ld a, (.dmark+1)  
a308 32 72 ee			ld (debug_mark+1),a  
a30b 3a 15 a3			ld a, (.dmark+2)  
a30e 32 73 ee			ld (debug_mark+2),a  
a311 18 03			jr .pastdmark  
a313 ..			.dmark: db "SCL"  
a316 f1			.pastdmark: pop af  
a317			endm  
# End of macro DMARK
a317				CALLMONITOR 
a317 cd a3 94			call break_point_state  
a31a				endm  
# End of macro CALLMONITOR
a31a			endif 
a31a					NEXTW 
a31a c3 c1 9e			jp macro_next 
a31d				endm 
# End of macro NEXTW
a31d			 
a31d			.DROP: 
a31d				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a31d 1b				db WORD_SYS_CORE+OPCODE_DROP             
a31e 48 a3			dw .DUP2            
a320 05				db 4 + 1 
a321 .. 00			db "DROP",0              
a326				endm 
# End of macro CWHEAD
a326			; | DROP ( w -- )   drop the TOS item   | DONE 
a326					if DEBUG_FORTH_WORDS_KEY 
a326						DMARK "DRP" 
a326 f5				push af  
a327 3a 3b a3			ld a, (.dmark)  
a32a 32 71 ee			ld (debug_mark),a  
a32d 3a 3c a3			ld a, (.dmark+1)  
a330 32 72 ee			ld (debug_mark+1),a  
a333 3a 3d a3			ld a, (.dmark+2)  
a336 32 73 ee			ld (debug_mark+2),a  
a339 18 03			jr .pastdmark  
a33b ..			.dmark: db "DRP"  
a33e f1			.pastdmark: pop af  
a33f			endm  
# End of macro DMARK
a33f						CALLMONITOR 
a33f cd a3 94			call break_point_state  
a342				endm  
# End of macro CALLMONITOR
a342					endif 
a342					FORTH_DSP_POP 
a342 cd c3 9d			call macro_forth_dsp_pop 
a345				endm 
# End of macro FORTH_DSP_POP
a345					NEXTW 
a345 c3 c1 9e			jp macro_next 
a348				endm 
# End of macro NEXTW
a348			.DUP2: 
a348				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a348 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a349 8d a3			dw .DROP2            
a34b 05				db 4 + 1 
a34c .. 00			db "2DUP",0              
a351				endm 
# End of macro CWHEAD
a351			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a351					if DEBUG_FORTH_WORDS_KEY 
a351						DMARK "2DU" 
a351 f5				push af  
a352 3a 66 a3			ld a, (.dmark)  
a355 32 71 ee			ld (debug_mark),a  
a358 3a 67 a3			ld a, (.dmark+1)  
a35b 32 72 ee			ld (debug_mark+1),a  
a35e 3a 68 a3			ld a, (.dmark+2)  
a361 32 73 ee			ld (debug_mark+2),a  
a364 18 03			jr .pastdmark  
a366 ..			.dmark: db "2DU"  
a369 f1			.pastdmark: pop af  
a36a			endm  
# End of macro DMARK
a36a						CALLMONITOR 
a36a cd a3 94			call break_point_state  
a36d				endm  
# End of macro CALLMONITOR
a36d					endif 
a36d					FORTH_DSP_VALUEHL 
a36d cd 0b 9d			call macro_dsp_valuehl 
a370				endm 
# End of macro FORTH_DSP_VALUEHL
a370 e5					push hl      ; 2 
a371			 
a371					FORTH_DSP_POP 
a371 cd c3 9d			call macro_forth_dsp_pop 
a374				endm 
# End of macro FORTH_DSP_POP
a374					 
a374					FORTH_DSP_VALUEHL 
a374 cd 0b 9d			call macro_dsp_valuehl 
a377				endm 
# End of macro FORTH_DSP_VALUEHL
a377			;		push hl      ; 1 
a377			 
a377					FORTH_DSP_POP 
a377 cd c3 9d			call macro_forth_dsp_pop 
a37a				endm 
# End of macro FORTH_DSP_POP
a37a			 
a37a			;		pop hl       ; 1 
a37a d1					pop de       ; 2 
a37b			 
a37b cd 14 9b				call forth_push_numhl 
a37e eb					ex de, hl 
a37f cd 14 9b				call forth_push_numhl 
a382			 
a382					 
a382 eb					ex de, hl 
a383			 
a383 cd 14 9b				call forth_push_numhl 
a386 eb					ex de, hl 
a387 cd 14 9b				call forth_push_numhl 
a38a			 
a38a			 
a38a					NEXTW 
a38a c3 c1 9e			jp macro_next 
a38d				endm 
# End of macro NEXTW
a38d			.DROP2: 
a38d				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a38d 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a38e bc a3			dw .SWAP2            
a390 06				db 5 + 1 
a391 .. 00			db "2DROP",0              
a397				endm 
# End of macro CWHEAD
a397			; | 2DROP ( w w -- )    Double drop | DONE 
a397					if DEBUG_FORTH_WORDS_KEY 
a397						DMARK "2DR" 
a397 f5				push af  
a398 3a ac a3			ld a, (.dmark)  
a39b 32 71 ee			ld (debug_mark),a  
a39e 3a ad a3			ld a, (.dmark+1)  
a3a1 32 72 ee			ld (debug_mark+1),a  
a3a4 3a ae a3			ld a, (.dmark+2)  
a3a7 32 73 ee			ld (debug_mark+2),a  
a3aa 18 03			jr .pastdmark  
a3ac ..			.dmark: db "2DR"  
a3af f1			.pastdmark: pop af  
a3b0			endm  
# End of macro DMARK
a3b0						CALLMONITOR 
a3b0 cd a3 94			call break_point_state  
a3b3				endm  
# End of macro CALLMONITOR
a3b3					endif 
a3b3					FORTH_DSP_POP 
a3b3 cd c3 9d			call macro_forth_dsp_pop 
a3b6				endm 
# End of macro FORTH_DSP_POP
a3b6					FORTH_DSP_POP 
a3b6 cd c3 9d			call macro_forth_dsp_pop 
a3b9				endm 
# End of macro FORTH_DSP_POP
a3b9					NEXTW 
a3b9 c3 c1 9e			jp macro_next 
a3bc				endm 
# End of macro NEXTW
a3bc			.SWAP2: 
a3bc				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3bc 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3bd e5 a3			dw .AT            
a3bf 06				db 5 + 1 
a3c0 .. 00			db "2SWAP",0              
a3c6				endm 
# End of macro CWHEAD
a3c6			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3c6					if DEBUG_FORTH_WORDS_KEY 
a3c6						DMARK "2SW" 
a3c6 f5				push af  
a3c7 3a db a3			ld a, (.dmark)  
a3ca 32 71 ee			ld (debug_mark),a  
a3cd 3a dc a3			ld a, (.dmark+1)  
a3d0 32 72 ee			ld (debug_mark+1),a  
a3d3 3a dd a3			ld a, (.dmark+2)  
a3d6 32 73 ee			ld (debug_mark+2),a  
a3d9 18 03			jr .pastdmark  
a3db ..			.dmark: db "2SW"  
a3de f1			.pastdmark: pop af  
a3df			endm  
# End of macro DMARK
a3df						CALLMONITOR 
a3df cd a3 94			call break_point_state  
a3e2				endm  
# End of macro CALLMONITOR
a3e2					endif 
a3e2					NEXTW 
a3e2 c3 c1 9e			jp macro_next 
a3e5				endm 
# End of macro NEXTW
a3e5			.AT: 
a3e5				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a3e5 1f				db WORD_SYS_CORE+OPCODE_AT             
a3e6 17 a4			dw .CAT            
a3e8 02				db 1 + 1 
a3e9 .. 00			db "@",0              
a3eb				endm 
# End of macro CWHEAD
a3eb			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a3eb			 
a3eb					if DEBUG_FORTH_WORDS_KEY 
a3eb						DMARK "AT." 
a3eb f5				push af  
a3ec 3a 00 a4			ld a, (.dmark)  
a3ef 32 71 ee			ld (debug_mark),a  
a3f2 3a 01 a4			ld a, (.dmark+1)  
a3f5 32 72 ee			ld (debug_mark+1),a  
a3f8 3a 02 a4			ld a, (.dmark+2)  
a3fb 32 73 ee			ld (debug_mark+2),a  
a3fe 18 03			jr .pastdmark  
a400 ..			.dmark: db "AT."  
a403 f1			.pastdmark: pop af  
a404			endm  
# End of macro DMARK
a404						CALLMONITOR 
a404 cd a3 94			call break_point_state  
a407				endm  
# End of macro CALLMONITOR
a407					endif 
a407			.getbyteat:	 
a407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a407 cd 0b 9d			call macro_dsp_valuehl 
a40a				endm 
# End of macro FORTH_DSP_VALUEHL
a40a					 
a40a			;		push hl 
a40a				 
a40a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a40a cd c3 9d			call macro_forth_dsp_pop 
a40d				endm 
# End of macro FORTH_DSP_POP
a40d			 
a40d			;		pop hl 
a40d			 
a40d 7e					ld a, (hl) 
a40e			 
a40e 6f					ld l, a 
a40f 26 00				ld h, 0 
a411 cd 14 9b				call forth_push_numhl 
a414			 
a414					NEXTW 
a414 c3 c1 9e			jp macro_next 
a417				endm 
# End of macro NEXTW
a417			.CAT: 
a417				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a417 20				db WORD_SYS_CORE+OPCODE_CAT             
a418 40 a4			dw .BANG            
a41a 03				db 2 + 1 
a41b .. 00			db "C@",0              
a41e				endm 
# End of macro CWHEAD
a41e			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a41e					if DEBUG_FORTH_WORDS_KEY 
a41e						DMARK "CAA" 
a41e f5				push af  
a41f 3a 33 a4			ld a, (.dmark)  
a422 32 71 ee			ld (debug_mark),a  
a425 3a 34 a4			ld a, (.dmark+1)  
a428 32 72 ee			ld (debug_mark+1),a  
a42b 3a 35 a4			ld a, (.dmark+2)  
a42e 32 73 ee			ld (debug_mark+2),a  
a431 18 03			jr .pastdmark  
a433 ..			.dmark: db "CAA"  
a436 f1			.pastdmark: pop af  
a437			endm  
# End of macro DMARK
a437						CALLMONITOR 
a437 cd a3 94			call break_point_state  
a43a				endm  
# End of macro CALLMONITOR
a43a					endif 
a43a c3 07 a4				jp .getbyteat 
a43d					NEXTW 
a43d c3 c1 9e			jp macro_next 
a440				endm 
# End of macro NEXTW
a440			.BANG: 
a440				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a440 21				db WORD_SYS_CORE+OPCODE_BANG             
a441 76 a4			dw .CBANG            
a443 02				db 1 + 1 
a444 .. 00			db "!",0              
a446				endm 
# End of macro CWHEAD
a446			; | ! ( x w -- ) Store x at address w      | DONE 
a446					if DEBUG_FORTH_WORDS_KEY 
a446						DMARK "BNG" 
a446 f5				push af  
a447 3a 5b a4			ld a, (.dmark)  
a44a 32 71 ee			ld (debug_mark),a  
a44d 3a 5c a4			ld a, (.dmark+1)  
a450 32 72 ee			ld (debug_mark+1),a  
a453 3a 5d a4			ld a, (.dmark+2)  
a456 32 73 ee			ld (debug_mark+2),a  
a459 18 03			jr .pastdmark  
a45b ..			.dmark: db "BNG"  
a45e f1			.pastdmark: pop af  
a45f			endm  
# End of macro DMARK
a45f						CALLMONITOR 
a45f cd a3 94			call break_point_state  
a462				endm  
# End of macro CALLMONITOR
a462					endif 
a462			 
a462			.storebyteat:		 
a462					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a462 cd 0b 9d			call macro_dsp_valuehl 
a465				endm 
# End of macro FORTH_DSP_VALUEHL
a465					 
a465 e5					push hl 
a466				 
a466					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a466 cd c3 9d			call macro_forth_dsp_pop 
a469				endm 
# End of macro FORTH_DSP_POP
a469			 
a469					; get byte to poke 
a469			 
a469					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a469 cd 0b 9d			call macro_dsp_valuehl 
a46c				endm 
# End of macro FORTH_DSP_VALUEHL
a46c e5					push hl 
a46d			 
a46d			 
a46d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a46d cd c3 9d			call macro_forth_dsp_pop 
a470				endm 
# End of macro FORTH_DSP_POP
a470			 
a470			 
a470 d1					pop de 
a471 e1					pop hl 
a472			 
a472 73					ld (hl),e 
a473			 
a473			 
a473					NEXTW 
a473 c3 c1 9e			jp macro_next 
a476				endm 
# End of macro NEXTW
a476			.CBANG: 
a476				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a476 22				db WORD_SYS_CORE+OPCODE_CBANG             
a477 9f a4			dw .SCALL            
a479 03				db 2 + 1 
a47a .. 00			db "C!",0              
a47d				endm 
# End of macro CWHEAD
a47d			; | C!  ( x w -- ) Store x at address w  | DONE 
a47d					if DEBUG_FORTH_WORDS_KEY 
a47d						DMARK "CBA" 
a47d f5				push af  
a47e 3a 92 a4			ld a, (.dmark)  
a481 32 71 ee			ld (debug_mark),a  
a484 3a 93 a4			ld a, (.dmark+1)  
a487 32 72 ee			ld (debug_mark+1),a  
a48a 3a 94 a4			ld a, (.dmark+2)  
a48d 32 73 ee			ld (debug_mark+2),a  
a490 18 03			jr .pastdmark  
a492 ..			.dmark: db "CBA"  
a495 f1			.pastdmark: pop af  
a496			endm  
# End of macro DMARK
a496						CALLMONITOR 
a496 cd a3 94			call break_point_state  
a499				endm  
# End of macro CALLMONITOR
a499					endif 
a499 c3 62 a4				jp .storebyteat 
a49c					NEXTW 
a49c c3 c1 9e			jp macro_next 
a49f				endm 
# End of macro NEXTW
a49f			.SCALL: 
a49f				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a49f 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4a0 d3 a4			dw .DEPTH            
a4a2 05				db 4 + 1 
a4a3 .. 00			db "CALL",0              
a4a8				endm 
# End of macro CWHEAD
a4a8			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4a8					if DEBUG_FORTH_WORDS_KEY 
a4a8						DMARK "CLL" 
a4a8 f5				push af  
a4a9 3a bd a4			ld a, (.dmark)  
a4ac 32 71 ee			ld (debug_mark),a  
a4af 3a be a4			ld a, (.dmark+1)  
a4b2 32 72 ee			ld (debug_mark+1),a  
a4b5 3a bf a4			ld a, (.dmark+2)  
a4b8 32 73 ee			ld (debug_mark+2),a  
a4bb 18 03			jr .pastdmark  
a4bd ..			.dmark: db "CLL"  
a4c0 f1			.pastdmark: pop af  
a4c1			endm  
# End of macro DMARK
a4c1						CALLMONITOR 
a4c1 cd a3 94			call break_point_state  
a4c4				endm  
# End of macro CALLMONITOR
a4c4					endif 
a4c4			 
a4c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c4 cd 0b 9d			call macro_dsp_valuehl 
a4c7				endm 
# End of macro FORTH_DSP_VALUEHL
a4c7			 
a4c7			;		push hl 
a4c7			 
a4c7					; destroy value TOS 
a4c7			 
a4c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c7 cd c3 9d			call macro_forth_dsp_pop 
a4ca				endm 
# End of macro FORTH_DSP_POP
a4ca			 
a4ca						 
a4ca			;		pop hl 
a4ca			 
a4ca					; how to do a call with hl???? save SP? 
a4ca cd 65 9e				call forth_call_hl 
a4cd			 
a4cd			 
a4cd					; TODO push value back onto stack for another op etc 
a4cd			 
a4cd cd 14 9b				call forth_push_numhl 
a4d0					NEXTW 
a4d0 c3 c1 9e			jp macro_next 
a4d3				endm 
# End of macro NEXTW
a4d3			.DEPTH: 
a4d3				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4d3 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4d4 10 a5			dw .OVER            
a4d6 06				db 5 + 1 
a4d7 .. 00			db "DEPTH",0              
a4dd				endm 
# End of macro CWHEAD
a4dd			; | DEPTH ( -- u ) Push count of stack | DONE 
a4dd					; take current TOS and remove from base value div by two to get count 
a4dd					if DEBUG_FORTH_WORDS_KEY 
a4dd						DMARK "DEP" 
a4dd f5				push af  
a4de 3a f2 a4			ld a, (.dmark)  
a4e1 32 71 ee			ld (debug_mark),a  
a4e4 3a f3 a4			ld a, (.dmark+1)  
a4e7 32 72 ee			ld (debug_mark+1),a  
a4ea 3a f4 a4			ld a, (.dmark+2)  
a4ed 32 73 ee			ld (debug_mark+2),a  
a4f0 18 03			jr .pastdmark  
a4f2 ..			.dmark: db "DEP"  
a4f5 f1			.pastdmark: pop af  
a4f6			endm  
# End of macro DMARK
a4f6						CALLMONITOR 
a4f6 cd a3 94			call break_point_state  
a4f9				endm  
# End of macro CALLMONITOR
a4f9					endif 
a4f9			 
a4f9			 
a4f9 2a f8 e9			ld hl, (cli_data_sp) 
a4fc 11 32 e8			ld de, cli_data_stack 
a4ff ed 52			sbc hl,de 
a501				 
a501				; div by size of stack item 
a501			 
a501 5d				ld e,l 
a502 0e 03			ld c, 3 
a504 cd 32 8c			call Div8 
a507			 
a507 6f				ld l,a 
a508 26 00			ld h,0 
a50a			 
a50a				;srl h 
a50a				;rr l 
a50a			 
a50a cd 14 9b				call forth_push_numhl 
a50d					NEXTW 
a50d c3 c1 9e			jp macro_next 
a510				endm 
# End of macro NEXTW
a510			.OVER: 
a510				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a510 42				db WORD_SYS_CORE+46             
a511 57 a5			dw .PAUSE            
a513 05				db 4 + 1 
a514 .. 00			db "OVER",0              
a519				endm 
# End of macro CWHEAD
a519			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a519					if DEBUG_FORTH_WORDS_KEY 
a519						DMARK "OVR" 
a519 f5				push af  
a51a 3a 2e a5			ld a, (.dmark)  
a51d 32 71 ee			ld (debug_mark),a  
a520 3a 2f a5			ld a, (.dmark+1)  
a523 32 72 ee			ld (debug_mark+1),a  
a526 3a 30 a5			ld a, (.dmark+2)  
a529 32 73 ee			ld (debug_mark+2),a  
a52c 18 03			jr .pastdmark  
a52e ..			.dmark: db "OVR"  
a531 f1			.pastdmark: pop af  
a532			endm  
# End of macro DMARK
a532						CALLMONITOR 
a532 cd a3 94			call break_point_state  
a535				endm  
# End of macro CALLMONITOR
a535					endif 
a535			 
a535					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a535 cd 0b 9d			call macro_dsp_valuehl 
a538				endm 
# End of macro FORTH_DSP_VALUEHL
a538 e5					push hl    ; n2 
a539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a539 cd c3 9d			call macro_forth_dsp_pop 
a53c				endm 
# End of macro FORTH_DSP_POP
a53c			 
a53c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a53c cd 0b 9d			call macro_dsp_valuehl 
a53f				endm 
# End of macro FORTH_DSP_VALUEHL
a53f e5					push hl    ; n1 
a540					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a540 cd c3 9d			call macro_forth_dsp_pop 
a543				endm 
# End of macro FORTH_DSP_POP
a543			 
a543 d1					pop de     ; n1 
a544 e1					pop hl     ; n2 
a545			 
a545 d5					push de 
a546 e5					push hl 
a547 d5					push de 
a548			 
a548					; push back  
a548			 
a548 e1					pop hl 
a549 cd 14 9b				call forth_push_numhl 
a54c e1					pop hl 
a54d cd 14 9b				call forth_push_numhl 
a550 e1					pop hl 
a551 cd 14 9b				call forth_push_numhl 
a554					NEXTW 
a554 c3 c1 9e			jp macro_next 
a557				endm 
# End of macro NEXTW
a557			 
a557			.PAUSE: 
a557				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a557 43				db WORD_SYS_CORE+47             
a558 8c a5			dw .PAUSES            
a55a 08				db 7 + 1 
a55b .. 00			db "PAUSEMS",0              
a563				endm 
# End of macro CWHEAD
a563			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a563					if DEBUG_FORTH_WORDS_KEY 
a563						DMARK "PMS" 
a563 f5				push af  
a564 3a 78 a5			ld a, (.dmark)  
a567 32 71 ee			ld (debug_mark),a  
a56a 3a 79 a5			ld a, (.dmark+1)  
a56d 32 72 ee			ld (debug_mark+1),a  
a570 3a 7a a5			ld a, (.dmark+2)  
a573 32 73 ee			ld (debug_mark+2),a  
a576 18 03			jr .pastdmark  
a578 ..			.dmark: db "PMS"  
a57b f1			.pastdmark: pop af  
a57c			endm  
# End of macro DMARK
a57c						CALLMONITOR 
a57c cd a3 94			call break_point_state  
a57f				endm  
# End of macro CALLMONITOR
a57f					endif 
a57f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a57f cd 0b 9d			call macro_dsp_valuehl 
a582				endm 
# End of macro FORTH_DSP_VALUEHL
a582			;		push hl    ; n2 
a582					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a582 cd c3 9d			call macro_forth_dsp_pop 
a585				endm 
# End of macro FORTH_DSP_POP
a585			;		pop hl 
a585			 
a585 7d					ld a, l 
a586 cd d7 89				call aDelayInMS 
a589				       NEXTW 
a589 c3 c1 9e			jp macro_next 
a58c				endm 
# End of macro NEXTW
a58c			.PAUSES:  
a58c				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a58c 44				db WORD_SYS_CORE+48             
a58d fb a5			dw .ROT            
a58f 06				db 5 + 1 
a590 .. 00			db "PAUSE",0              
a596				endm 
# End of macro CWHEAD
a596			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a596					if DEBUG_FORTH_WORDS_KEY 
a596						DMARK "PAU" 
a596 f5				push af  
a597 3a ab a5			ld a, (.dmark)  
a59a 32 71 ee			ld (debug_mark),a  
a59d 3a ac a5			ld a, (.dmark+1)  
a5a0 32 72 ee			ld (debug_mark+1),a  
a5a3 3a ad a5			ld a, (.dmark+2)  
a5a6 32 73 ee			ld (debug_mark+2),a  
a5a9 18 03			jr .pastdmark  
a5ab ..			.dmark: db "PAU"  
a5ae f1			.pastdmark: pop af  
a5af			endm  
# End of macro DMARK
a5af						CALLMONITOR 
a5af cd a3 94			call break_point_state  
a5b2				endm  
# End of macro CALLMONITOR
a5b2					endif 
a5b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5b2 cd 0b 9d			call macro_dsp_valuehl 
a5b5				endm 
# End of macro FORTH_DSP_VALUEHL
a5b5			;		push hl    ; n2 
a5b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5b5 cd c3 9d			call macro_forth_dsp_pop 
a5b8				endm 
# End of macro FORTH_DSP_POP
a5b8			;		pop hl 
a5b8 45					ld b, l 
a5b9					if DEBUG_FORTH_WORDS 
a5b9						DMARK "PAU" 
a5b9 f5				push af  
a5ba 3a ce a5			ld a, (.dmark)  
a5bd 32 71 ee			ld (debug_mark),a  
a5c0 3a cf a5			ld a, (.dmark+1)  
a5c3 32 72 ee			ld (debug_mark+1),a  
a5c6 3a d0 a5			ld a, (.dmark+2)  
a5c9 32 73 ee			ld (debug_mark+2),a  
a5cc 18 03			jr .pastdmark  
a5ce ..			.dmark: db "PAU"  
a5d1 f1			.pastdmark: pop af  
a5d2			endm  
# End of macro DMARK
a5d2						CALLMONITOR 
a5d2 cd a3 94			call break_point_state  
a5d5				endm  
# End of macro CALLMONITOR
a5d5					endif 
a5d5 c5			.pauses1:	push bc 
a5d6 cd f2 89				call delay1s 
a5d9 c1					pop bc 
a5da					if DEBUG_FORTH_WORDS 
a5da						DMARK "PA1" 
a5da f5				push af  
a5db 3a ef a5			ld a, (.dmark)  
a5de 32 71 ee			ld (debug_mark),a  
a5e1 3a f0 a5			ld a, (.dmark+1)  
a5e4 32 72 ee			ld (debug_mark+1),a  
a5e7 3a f1 a5			ld a, (.dmark+2)  
a5ea 32 73 ee			ld (debug_mark+2),a  
a5ed 18 03			jr .pastdmark  
a5ef ..			.dmark: db "PA1"  
a5f2 f1			.pastdmark: pop af  
a5f3			endm  
# End of macro DMARK
a5f3						CALLMONITOR 
a5f3 cd a3 94			call break_point_state  
a5f6				endm  
# End of macro CALLMONITOR
a5f6					endif 
a5f6 10 dd				djnz .pauses1 
a5f8			 
a5f8				       NEXTW 
a5f8 c3 c1 9e			jp macro_next 
a5fb				endm 
# End of macro NEXTW
a5fb			.ROT: 
a5fb				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a5fb 45				db WORD_SYS_CORE+49             
a5fc 49 a6			dw .UWORDS            
a5fe 04				db 3 + 1 
a5ff .. 00			db "ROT",0              
a603				endm 
# End of macro CWHEAD
a603			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a603					if DEBUG_FORTH_WORDS_KEY 
a603						DMARK "ROT" 
a603 f5				push af  
a604 3a 18 a6			ld a, (.dmark)  
a607 32 71 ee			ld (debug_mark),a  
a60a 3a 19 a6			ld a, (.dmark+1)  
a60d 32 72 ee			ld (debug_mark+1),a  
a610 3a 1a a6			ld a, (.dmark+2)  
a613 32 73 ee			ld (debug_mark+2),a  
a616 18 03			jr .pastdmark  
a618 ..			.dmark: db "ROT"  
a61b f1			.pastdmark: pop af  
a61c			endm  
# End of macro DMARK
a61c						CALLMONITOR 
a61c cd a3 94			call break_point_state  
a61f				endm  
# End of macro CALLMONITOR
a61f					endif 
a61f			 
a61f					FORTH_DSP_VALUEHL 
a61f cd 0b 9d			call macro_dsp_valuehl 
a622				endm 
# End of macro FORTH_DSP_VALUEHL
a622 e5					push hl    ; u3  
a623			 
a623					FORTH_DSP_POP 
a623 cd c3 9d			call macro_forth_dsp_pop 
a626				endm 
# End of macro FORTH_DSP_POP
a626			   
a626					FORTH_DSP_VALUEHL 
a626 cd 0b 9d			call macro_dsp_valuehl 
a629				endm 
# End of macro FORTH_DSP_VALUEHL
a629 e5					push hl     ; u2 
a62a			 
a62a					FORTH_DSP_POP 
a62a cd c3 9d			call macro_forth_dsp_pop 
a62d				endm 
# End of macro FORTH_DSP_POP
a62d			 
a62d					FORTH_DSP_VALUEHL 
a62d cd 0b 9d			call macro_dsp_valuehl 
a630				endm 
# End of macro FORTH_DSP_VALUEHL
a630 e5					push hl     ; u1 
a631			 
a631					FORTH_DSP_POP 
a631 cd c3 9d			call macro_forth_dsp_pop 
a634				endm 
# End of macro FORTH_DSP_POP
a634			 
a634 c1					pop bc      ; u1 
a635 e1					pop hl      ; u2 
a636 d1					pop de      ; u3 
a637			 
a637			 
a637 c5					push bc 
a638 d5					push de 
a639 e5					push hl 
a63a			 
a63a			 
a63a e1					pop hl 
a63b cd 14 9b				call forth_push_numhl 
a63e			 
a63e e1					pop hl 
a63f cd 14 9b				call forth_push_numhl 
a642			 
a642 e1					pop hl 
a643 cd 14 9b				call forth_push_numhl 
a646					 
a646			 
a646			 
a646			 
a646			 
a646			 
a646				       NEXTW 
a646 c3 c1 9e			jp macro_next 
a649				endm 
# End of macro NEXTW
a649			 
a649			.UWORDS: 
a649				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a649 50				db WORD_SYS_CORE+60             
a64a 0b a7			dw .BP            
a64c 07				db 6 + 1 
a64d .. 00			db "UWORDS",0              
a654				endm 
# End of macro CWHEAD
a654			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a654			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a654			; | | Following the count are the individual words. 
a654			; | | 
a654			; | | e.g. UWORDS 
a654			; | | BOX DIRLIST 2 
a654			; | |  
a654			; | | Can be used to save the words to storage via: 
a654			; | | UWORDS $01 DO $01 APPEND LOOP 
a654				if DEBUG_FORTH_WORDS_KEY 
a654					DMARK "UWR" 
a654 f5				push af  
a655 3a 69 a6			ld a, (.dmark)  
a658 32 71 ee			ld (debug_mark),a  
a65b 3a 6a a6			ld a, (.dmark+1)  
a65e 32 72 ee			ld (debug_mark+1),a  
a661 3a 6b a6			ld a, (.dmark+2)  
a664 32 73 ee			ld (debug_mark+2),a  
a667 18 03			jr .pastdmark  
a669 ..			.dmark: db "UWR"  
a66c f1			.pastdmark: pop af  
a66d			endm  
# End of macro DMARK
a66d					CALLMONITOR 
a66d cd a3 94			call break_point_state  
a670				endm  
# End of macro CALLMONITOR
a670				endif 
a670 21 ca e2				ld hl, baseram 
a673					;ld hl, baseusermem 
a673 01 00 00				ld bc, 0    ; start a counter 
a676			 
a676				; skip dict stub 
a676			 
a676 cd 12 a0				call forth_tok_next 
a679			 
a679			 
a679			; while we have words to look for 
a679			 
a679 7e			.douscan:	ld a, (hl)      
a67a				if DEBUG_FORTH_WORDS 
a67a					DMARK "UWs" 
a67a f5				push af  
a67b 3a 8f a6			ld a, (.dmark)  
a67e 32 71 ee			ld (debug_mark),a  
a681 3a 90 a6			ld a, (.dmark+1)  
a684 32 72 ee			ld (debug_mark+1),a  
a687 3a 91 a6			ld a, (.dmark+2)  
a68a 32 73 ee			ld (debug_mark+2),a  
a68d 18 03			jr .pastdmark  
a68f ..			.dmark: db "UWs"  
a692 f1			.pastdmark: pop af  
a693			endm  
# End of macro DMARK
a693					CALLMONITOR 
a693 cd a3 94			call break_point_state  
a696				endm  
# End of macro CALLMONITOR
a696				endif 
a696 fe 00				cp WORD_SYS_END 
a698 28 4d				jr z, .udone 
a69a fe 01				cp WORD_SYS_UWORD 
a69c 20 44				jr nz, .nuword 
a69e			 
a69e				if DEBUG_FORTH_WORDS 
a69e					DMARK "UWu" 
a69e f5				push af  
a69f 3a b3 a6			ld a, (.dmark)  
a6a2 32 71 ee			ld (debug_mark),a  
a6a5 3a b4 a6			ld a, (.dmark+1)  
a6a8 32 72 ee			ld (debug_mark+1),a  
a6ab 3a b5 a6			ld a, (.dmark+2)  
a6ae 32 73 ee			ld (debug_mark+2),a  
a6b1 18 03			jr .pastdmark  
a6b3 ..			.dmark: db "UWu"  
a6b6 f1			.pastdmark: pop af  
a6b7			endm  
# End of macro DMARK
a6b7					CALLMONITOR 
a6b7 cd a3 94			call break_point_state  
a6ba				endm  
# End of macro CALLMONITOR
a6ba				endif 
a6ba					; we have a uword so push its name to the stack 
a6ba			 
a6ba e5				   	push hl  ; save so we can move to next dict block 
a6bb			 
a6bb					; skip opcode 
a6bb 23					inc hl  
a6bc					; skip next ptr 
a6bc 23					inc hl  
a6bd 23					inc hl 
a6be					; skip len 
a6be 23					inc hl 
a6bf				if DEBUG_FORTH_WORDS 
a6bf					DMARK "UWt" 
a6bf f5				push af  
a6c0 3a d4 a6			ld a, (.dmark)  
a6c3 32 71 ee			ld (debug_mark),a  
a6c6 3a d5 a6			ld a, (.dmark+1)  
a6c9 32 72 ee			ld (debug_mark+1),a  
a6cc 3a d6 a6			ld a, (.dmark+2)  
a6cf 32 73 ee			ld (debug_mark+2),a  
a6d2 18 03			jr .pastdmark  
a6d4 ..			.dmark: db "UWt"  
a6d7 f1			.pastdmark: pop af  
a6d8			endm  
# End of macro DMARK
a6d8					CALLMONITOR 
a6d8 cd a3 94			call break_point_state  
a6db				endm  
# End of macro CALLMONITOR
a6db				endif 
a6db 03					inc bc 
a6dc			 
a6dc c5					push bc 
a6dd cd 82 9b				call forth_push_str 
a6e0 c1					pop bc 
a6e1			 
a6e1 e1					pop hl 	 
a6e2			 
a6e2 cd 12 a0		.nuword:	call forth_tok_next 
a6e5 18 92				jr .douscan  
a6e7			 
a6e7			.udone:		 ; push count of uwords found 
a6e7 c5					push bc 
a6e8 e1					pop hl 
a6e9			 
a6e9				if DEBUG_FORTH_WORDS 
a6e9					DMARK "UWc" 
a6e9 f5				push af  
a6ea 3a fe a6			ld a, (.dmark)  
a6ed 32 71 ee			ld (debug_mark),a  
a6f0 3a ff a6			ld a, (.dmark+1)  
a6f3 32 72 ee			ld (debug_mark+1),a  
a6f6 3a 00 a7			ld a, (.dmark+2)  
a6f9 32 73 ee			ld (debug_mark+2),a  
a6fc 18 03			jr .pastdmark  
a6fe ..			.dmark: db "UWc"  
a701 f1			.pastdmark: pop af  
a702			endm  
# End of macro DMARK
a702					CALLMONITOR 
a702 cd a3 94			call break_point_state  
a705				endm  
# End of macro CALLMONITOR
a705				endif 
a705 cd 14 9b				call forth_push_numhl 
a708			 
a708			 
a708				       NEXTW 
a708 c3 c1 9e			jp macro_next 
a70b				endm 
# End of macro NEXTW
a70b			 
a70b			.BP: 
a70b				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a70b 54				db WORD_SYS_CORE+64             
a70c 41 a7			dw .MONITOR            
a70e 03				db 2 + 1 
a70f .. 00			db "BP",0              
a712				endm 
# End of macro CWHEAD
a712			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a712			; | | $00 Will enable the break points within specific code paths 
a712			; | | $01 Will disable break points 
a712			; | |  
a712			; | | By default break points are off. Either the above can be used to enable them 
a712			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a712			; | | and on release of the pressed key a message will be disaplayed to notify 
a712			; | | that break points are enabled. Pressing any key will then continue boot process. 
a712					; get byte count 
a712					if DEBUG_FORTH_WORDS_KEY 
a712						DMARK "BP." 
a712 f5				push af  
a713 3a 27 a7			ld a, (.dmark)  
a716 32 71 ee			ld (debug_mark),a  
a719 3a 28 a7			ld a, (.dmark+1)  
a71c 32 72 ee			ld (debug_mark+1),a  
a71f 3a 29 a7			ld a, (.dmark+2)  
a722 32 73 ee			ld (debug_mark+2),a  
a725 18 03			jr .pastdmark  
a727 ..			.dmark: db "BP."  
a72a f1			.pastdmark: pop af  
a72b			endm  
# End of macro DMARK
a72b						CALLMONITOR 
a72b cd a3 94			call break_point_state  
a72e				endm  
# End of macro CALLMONITOR
a72e					endif 
a72e			 
a72e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a72e cd 0b 9d			call macro_dsp_valuehl 
a731				endm 
# End of macro FORTH_DSP_VALUEHL
a731			 
a731			;		push hl 
a731			 
a731					; destroy value TOS 
a731			 
a731					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a731 cd c3 9d			call macro_forth_dsp_pop 
a734				endm 
# End of macro FORTH_DSP_POP
a734			 
a734			;		pop hl 
a734			 
a734 3e 00				ld a,0 
a736 bd					cp l 
a737 28 02				jr z, .bpset 
a739 3e 2a				ld a, '*' 
a73b			 
a73b 32 bc e2		.bpset:		ld (os_view_disable), a 
a73e			 
a73e			 
a73e					NEXTW 
a73e c3 c1 9e			jp macro_next 
a741				endm 
# End of macro NEXTW
a741			 
a741			 
a741			.MONITOR: 
a741				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a741 55				db WORD_SYS_CORE+65             
a742 74 a7			dw .MALLOC            
a744 08				db 7 + 1 
a745 .. 00			db "MONITOR",0              
a74d				endm 
# End of macro CWHEAD
a74d			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a74d			; | | At start the current various registers will be displayed with contents. 
a74d			; | | Top right corner will show the most recent debug marker seen. 
a74d			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a74d			; | | and the return stack pointer (RSP). 
a74d			; | | Pressing: 
a74d			; | |    1 - Initial screen 
a74d			; | |    2 - Display a data dump of HL 
a74d			; | |    3 - Display a data dump of DE 
a74d			; | |    4 - Display a data dump of BC 
a74d			; | |    5 - Display a data dump of HL 
a74d			; | |    6 - Display a data dump of DSP 
a74d			; | |    7 - Display a data dump of RSP 
a74d			; | |    8 - Display a data dump of what is at DSP 
a74d			; | |    9 - Display a data dump of what is at RSP 
a74d			; | |    0 - Exit monitor and continue running. This will also enable break points 
a74d			; | |    * - Disable break points 
a74d			; | |    # - Enter traditional monitor mode 
a74d			; | | 
a74d			; | | Monitor Mode 
a74d			; | | ------------ 
a74d			; | | A prompt of '>' will be shown for various commands: 
a74d			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a74d			; | |    C - Continue display a data dump from the last set address 
a74d			; | |    M xxxx - Set start of memory edit at address xx 
a74d			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a74d			; | |    Q - Return to previous 
a74d					if DEBUG_FORTH_WORDS_KEY 
a74d						DMARK "MON" 
a74d f5				push af  
a74e 3a 62 a7			ld a, (.dmark)  
a751 32 71 ee			ld (debug_mark),a  
a754 3a 63 a7			ld a, (.dmark+1)  
a757 32 72 ee			ld (debug_mark+1),a  
a75a 3a 64 a7			ld a, (.dmark+2)  
a75d 32 73 ee			ld (debug_mark+2),a  
a760 18 03			jr .pastdmark  
a762 ..			.dmark: db "MON"  
a765 f1			.pastdmark: pop af  
a766			endm  
# End of macro DMARK
a766						CALLMONITOR 
a766 cd a3 94			call break_point_state  
a769				endm  
# End of macro CALLMONITOR
a769					endif 
a769 3e 00				ld a, 0 
a76b 32 bc e2				ld (os_view_disable), a 
a76e			 
a76e					CALLMONITOR 
a76e cd a3 94			call break_point_state  
a771				endm  
# End of macro CALLMONITOR
a771			 
a771			;	call monitor 
a771			 
a771					NEXTW 
a771 c3 c1 9e			jp macro_next 
a774				endm 
# End of macro NEXTW
a774			 
a774			 
a774			.MALLOC: 
a774				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a774 56				db WORD_SYS_CORE+66             
a775 9d a7			dw .MALLOC2            
a777 06				db 5 + 1 
a778 .. 00			db "ALLOT",0              
a77e				endm 
# End of macro CWHEAD
a77e			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a77e					if DEBUG_FORTH_WORDS_KEY 
a77e						DMARK "ALL" 
a77e f5				push af  
a77f 3a 93 a7			ld a, (.dmark)  
a782 32 71 ee			ld (debug_mark),a  
a785 3a 94 a7			ld a, (.dmark+1)  
a788 32 72 ee			ld (debug_mark+1),a  
a78b 3a 95 a7			ld a, (.dmark+2)  
a78e 32 73 ee			ld (debug_mark+2),a  
a791 18 03			jr .pastdmark  
a793 ..			.dmark: db "ALL"  
a796 f1			.pastdmark: pop af  
a797			endm  
# End of macro DMARK
a797						CALLMONITOR 
a797 cd a3 94			call break_point_state  
a79a				endm  
# End of macro CALLMONITOR
a79a					endif 
a79a c3 c4 a7				jp .mallocc 
a79d			.MALLOC2: 
a79d				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a79d 56				db WORD_SYS_CORE+66             
a79e db a7			dw .FREE            
a7a0 07				db 6 + 1 
a7a1 .. 00			db "MALLOC",0              
a7a8				endm 
# End of macro CWHEAD
a7a8			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7a8					; get byte count 
a7a8					if DEBUG_FORTH_WORDS_KEY 
a7a8						DMARK "MAL" 
a7a8 f5				push af  
a7a9 3a bd a7			ld a, (.dmark)  
a7ac 32 71 ee			ld (debug_mark),a  
a7af 3a be a7			ld a, (.dmark+1)  
a7b2 32 72 ee			ld (debug_mark+1),a  
a7b5 3a bf a7			ld a, (.dmark+2)  
a7b8 32 73 ee			ld (debug_mark+2),a  
a7bb 18 03			jr .pastdmark  
a7bd ..			.dmark: db "MAL"  
a7c0 f1			.pastdmark: pop af  
a7c1			endm  
# End of macro DMARK
a7c1						CALLMONITOR 
a7c1 cd a3 94			call break_point_state  
a7c4				endm  
# End of macro CALLMONITOR
a7c4					endif 
a7c4			.mallocc: 
a7c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7c4 cd 0b 9d			call macro_dsp_valuehl 
a7c7				endm 
# End of macro FORTH_DSP_VALUEHL
a7c7			 
a7c7			;		push hl 
a7c7			 
a7c7					; destroy value TOS 
a7c7			 
a7c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7c7 cd c3 9d			call macro_forth_dsp_pop 
a7ca				endm 
# End of macro FORTH_DSP_POP
a7ca			 
a7ca			;		pop hl 
a7ca cd 69 91				call malloc 
a7cd				if DEBUG_FORTH_MALLOC_GUARD 
a7cd f5					push af 
a7ce cd cb 8c				call ishlzero 
a7d1			;		ld a, l 
a7d1			;		add h 
a7d1			;		cp 0 
a7d1 f1					pop af 
a7d2					 
a7d2 cc 80 cb				call z,malloc_error 
a7d5				endif 
a7d5			 
a7d5 cd 14 9b				call forth_push_numhl 
a7d8					NEXTW 
a7d8 c3 c1 9e			jp macro_next 
a7db				endm 
# End of macro NEXTW
a7db			 
a7db			.FREE: 
a7db				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a7db 57				db WORD_SYS_CORE+67             
a7dc 0c a8			dw .LIST            
a7de 05				db 4 + 1 
a7df .. 00			db "FREE",0              
a7e4				endm 
# End of macro CWHEAD
a7e4			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a7e4					if DEBUG_FORTH_WORDS_KEY 
a7e4						DMARK "FRE" 
a7e4 f5				push af  
a7e5 3a f9 a7			ld a, (.dmark)  
a7e8 32 71 ee			ld (debug_mark),a  
a7eb 3a fa a7			ld a, (.dmark+1)  
a7ee 32 72 ee			ld (debug_mark+1),a  
a7f1 3a fb a7			ld a, (.dmark+2)  
a7f4 32 73 ee			ld (debug_mark+2),a  
a7f7 18 03			jr .pastdmark  
a7f9 ..			.dmark: db "FRE"  
a7fc f1			.pastdmark: pop af  
a7fd			endm  
# End of macro DMARK
a7fd						CALLMONITOR 
a7fd cd a3 94			call break_point_state  
a800				endm  
# End of macro CALLMONITOR
a800					endif 
a800					; get address 
a800			 
a800					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a800 cd 0b 9d			call macro_dsp_valuehl 
a803				endm 
# End of macro FORTH_DSP_VALUEHL
a803			 
a803			;		push hl 
a803			 
a803					; destroy value TOS 
a803			 
a803					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a803 cd c3 9d			call macro_forth_dsp_pop 
a806				endm 
# End of macro FORTH_DSP_POP
a806			 
a806			;		pop hl 
a806			if FORTH_ENABLE_MALLOCFREE 
a806 cd 33 92				call free 
a809			endif 
a809					NEXTW 
a809 c3 c1 9e			jp macro_next 
a80c				endm 
# End of macro NEXTW
a80c			.LIST: 
a80c				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a80c 5c				db WORD_SYS_CORE+72             
a80d fa a9			dw .FORGET            
a80f 05				db 4 + 1 
a810 .. 00			db "LIST",0              
a815				endm 
# End of macro CWHEAD
a815			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a815			; | | The quoted word must be in upper case. 
a815				if DEBUG_FORTH_WORDS_KEY 
a815					DMARK "LST" 
a815 f5				push af  
a816 3a 2a a8			ld a, (.dmark)  
a819 32 71 ee			ld (debug_mark),a  
a81c 3a 2b a8			ld a, (.dmark+1)  
a81f 32 72 ee			ld (debug_mark+1),a  
a822 3a 2c a8			ld a, (.dmark+2)  
a825 32 73 ee			ld (debug_mark+2),a  
a828 18 03			jr .pastdmark  
a82a ..			.dmark: db "LST"  
a82d f1			.pastdmark: pop af  
a82e			endm  
# End of macro DMARK
a82e					CALLMONITOR 
a82e cd a3 94			call break_point_state  
a831				endm  
# End of macro CALLMONITOR
a831				endif 
a831			 
a831					FORTH_DSP_VALUEHL 
a831 cd 0b 9d			call macro_dsp_valuehl 
a834				endm 
# End of macro FORTH_DSP_VALUEHL
a834			 
a834 e5					push hl 
a835					FORTH_DSP_POP 
a835 cd c3 9d			call macro_forth_dsp_pop 
a838				endm 
# End of macro FORTH_DSP_POP
a838 c1					pop bc 
a839			 
a839			; Start format of scratch string 
a839			 
a839 21 cb e2				ld hl, scratch 
a83c			 
a83c 3e 3a				ld a, ':' 
a83e 77					ld (hl),a 
a83f 23					inc hl 
a840 3e 20				ld a, ' ' 
a842 77					ld (hl), a 
a843			 
a843					; Get ptr to the word we need to look up 
a843			 
a843			;		FORTH_DSP_VALUEHL 
a843					;v5 FORTH_DSP_VALUE 
a843				; TODO type check 
a843			;		inc hl    ; Skip type check  
a843			;		push hl 
a843			;		ex de, hl    ; put into DE 
a843			 
a843			 
a843 21 ca e2				ld hl, baseram 
a846					;ld hl, baseusermem 
a846			 
a846 e5			push hl   ; sacreifical push 
a847			 
a847			.ldouscanm: 
a847 e1				pop hl 
a848			.ldouscan: 
a848				if DEBUG_FORTH_WORDS 
a848					DMARK "LSs" 
a848 f5				push af  
a849 3a 5d a8			ld a, (.dmark)  
a84c 32 71 ee			ld (debug_mark),a  
a84f 3a 5e a8			ld a, (.dmark+1)  
a852 32 72 ee			ld (debug_mark+1),a  
a855 3a 5f a8			ld a, (.dmark+2)  
a858 32 73 ee			ld (debug_mark+2),a  
a85b 18 03			jr .pastdmark  
a85d ..			.dmark: db "LSs"  
a860 f1			.pastdmark: pop af  
a861			endm  
# End of macro DMARK
a861					CALLMONITOR 
a861 cd a3 94			call break_point_state  
a864				endm  
# End of macro CALLMONITOR
a864				endif 
a864				; skip dict stub 
a864 cd 12 a0				call forth_tok_next 
a867			 
a867			 
a867			; while we have words to look for 
a867			 
a867 7e				ld a, (hl)      
a868				if DEBUG_FORTH_WORDS 
a868					DMARK "LSk" 
a868 f5				push af  
a869 3a 7d a8			ld a, (.dmark)  
a86c 32 71 ee			ld (debug_mark),a  
a86f 3a 7e a8			ld a, (.dmark+1)  
a872 32 72 ee			ld (debug_mark+1),a  
a875 3a 7f a8			ld a, (.dmark+2)  
a878 32 73 ee			ld (debug_mark+2),a  
a87b 18 03			jr .pastdmark  
a87d ..			.dmark: db "LSk"  
a880 f1			.pastdmark: pop af  
a881			endm  
# End of macro DMARK
a881					CALLMONITOR 
a881 cd a3 94			call break_point_state  
a884				endm  
# End of macro CALLMONITOR
a884				endif 
a884					;cp WORD_SYS_END 
a884					;jp z, .lunotfound 
a884			 
a884					; if we hit non uwords then gone too far 
a884 fe 01				cp WORD_SYS_UWORD 
a886 c2 b6 a9				jp nz, .lunotfound 
a889			 
a889				if DEBUG_FORTH_WORDS 
a889					DMARK "LSu" 
a889 f5				push af  
a88a 3a 9e a8			ld a, (.dmark)  
a88d 32 71 ee			ld (debug_mark),a  
a890 3a 9f a8			ld a, (.dmark+1)  
a893 32 72 ee			ld (debug_mark+1),a  
a896 3a a0 a8			ld a, (.dmark+2)  
a899 32 73 ee			ld (debug_mark+2),a  
a89c 18 03			jr .pastdmark  
a89e ..			.dmark: db "LSu"  
a8a1 f1			.pastdmark: pop af  
a8a2			endm  
# End of macro DMARK
a8a2					CALLMONITOR 
a8a2 cd a3 94			call break_point_state  
a8a5				endm  
# End of macro CALLMONITOR
a8a5				endif 
a8a5			 
a8a5					; found a uword but is it the one we want... 
a8a5			 
a8a5 c5					push bc     ; uword to find is on bc 
a8a6 d1					pop de 
a8a7			 
a8a7 e5					push hl  ; to save the ptr 
a8a8			 
a8a8					; skip opcode 
a8a8 23					inc hl  
a8a9					; skip next ptr 
a8a9 23					inc hl  
a8aa 23					inc hl 
a8ab					; skip len 
a8ab 23					inc hl 
a8ac			 
a8ac				if DEBUG_FORTH_WORDS 
a8ac					DMARK "LSc" 
a8ac f5				push af  
a8ad 3a c1 a8			ld a, (.dmark)  
a8b0 32 71 ee			ld (debug_mark),a  
a8b3 3a c2 a8			ld a, (.dmark+1)  
a8b6 32 72 ee			ld (debug_mark+1),a  
a8b9 3a c3 a8			ld a, (.dmark+2)  
a8bc 32 73 ee			ld (debug_mark+2),a  
a8bf 18 03			jr .pastdmark  
a8c1 ..			.dmark: db "LSc"  
a8c4 f1			.pastdmark: pop af  
a8c5			endm  
# End of macro DMARK
a8c5					CALLMONITOR 
a8c5 cd a3 94			call break_point_state  
a8c8				endm  
# End of macro CALLMONITOR
a8c8				endif 
a8c8 cd 38 91				call strcmp 
a8cb c2 47 a8				jp nz, .ldouscanm 
a8ce				 
a8ce			 
a8ce			 
a8ce					; we have a uword so push its name to the stack 
a8ce			 
a8ce			;	   	push hl  ; save so we can move to next dict block 
a8ce e1			pop hl 
a8cf			 
a8cf				if DEBUG_FORTH_WORDS 
a8cf					DMARK "LSm" 
a8cf f5				push af  
a8d0 3a e4 a8			ld a, (.dmark)  
a8d3 32 71 ee			ld (debug_mark),a  
a8d6 3a e5 a8			ld a, (.dmark+1)  
a8d9 32 72 ee			ld (debug_mark+1),a  
a8dc 3a e6 a8			ld a, (.dmark+2)  
a8df 32 73 ee			ld (debug_mark+2),a  
a8e2 18 03			jr .pastdmark  
a8e4 ..			.dmark: db "LSm"  
a8e7 f1			.pastdmark: pop af  
a8e8			endm  
# End of macro DMARK
a8e8					CALLMONITOR 
a8e8 cd a3 94			call break_point_state  
a8eb				endm  
# End of macro CALLMONITOR
a8eb				endif 
a8eb			 
a8eb					; skip opcode 
a8eb 23					inc hl  
a8ec					; skip next ptr 
a8ec 23					inc hl  
a8ed 23					inc hl 
a8ee					; skip len 
a8ee 7e					ld a, (hl)   ; save length to add 
a8ef				if DEBUG_FORTH_WORDS 
a8ef					DMARK "LS2" 
a8ef f5				push af  
a8f0 3a 04 a9			ld a, (.dmark)  
a8f3 32 71 ee			ld (debug_mark),a  
a8f6 3a 05 a9			ld a, (.dmark+1)  
a8f9 32 72 ee			ld (debug_mark+1),a  
a8fc 3a 06 a9			ld a, (.dmark+2)  
a8ff 32 73 ee			ld (debug_mark+2),a  
a902 18 03			jr .pastdmark  
a904 ..			.dmark: db "LS2"  
a907 f1			.pastdmark: pop af  
a908			endm  
# End of macro DMARK
a908					CALLMONITOR 
a908 cd a3 94			call break_point_state  
a90b				endm  
# End of macro CALLMONITOR
a90b				endif 
a90b			 
a90b					; save this location 
a90b				 
a90b e5					push hl 
a90c			 
a90c 23					inc hl 
a90d 11 cd e2				ld de, scratch+2 
a910 4f					ld c, a 
a911 06 00				ld b, 0 
a913			 
a913				if DEBUG_FORTH_WORDS 
a913					DMARK "LSn" 
a913 f5				push af  
a914 3a 28 a9			ld a, (.dmark)  
a917 32 71 ee			ld (debug_mark),a  
a91a 3a 29 a9			ld a, (.dmark+1)  
a91d 32 72 ee			ld (debug_mark+1),a  
a920 3a 2a a9			ld a, (.dmark+2)  
a923 32 73 ee			ld (debug_mark+2),a  
a926 18 03			jr .pastdmark  
a928 ..			.dmark: db "LSn"  
a92b f1			.pastdmark: pop af  
a92c			endm  
# End of macro DMARK
a92c					CALLMONITOR 
a92c cd a3 94			call break_point_state  
a92f				endm  
# End of macro CALLMONITOR
a92f				endif 
a92f			 
a92f					; copy uword name to scratch 
a92f			 
a92f ed b0				ldir 
a931			 
a931 1b					dec de 
a932 3e 20				ld a, ' '    ; change null to space 
a934 12					ld (de), a 
a935			 
a935 13					inc de 
a936			 
a936 d5					push de 
a937 c1					pop bc     ; move scratch pointer to end of word name and save it 
a938			 
a938 e1					pop hl 
a939 7e					ld a, (hl) 
a93a					;inc hl 
a93a					; skip word string 
a93a cd a2 8c				call addatohl 
a93d			 
a93d 23					inc hl 
a93e			 
a93e				if DEBUG_FORTH_WORDS 
a93e					DMARK "LS3" 
a93e f5				push af  
a93f 3a 53 a9			ld a, (.dmark)  
a942 32 71 ee			ld (debug_mark),a  
a945 3a 54 a9			ld a, (.dmark+1)  
a948 32 72 ee			ld (debug_mark+1),a  
a94b 3a 55 a9			ld a, (.dmark+2)  
a94e 32 73 ee			ld (debug_mark+2),a  
a951 18 03			jr .pastdmark  
a953 ..			.dmark: db "LS3"  
a956 f1			.pastdmark: pop af  
a957			endm  
# End of macro DMARK
a957					CALLMONITOR 
a957 cd a3 94			call break_point_state  
a95a				endm  
# End of macro CALLMONITOR
a95a				endif 
a95a					; should now be at the start of the machine code to setup the eval of the uword 
a95a					; now locate the ptr to the string defintion 
a95a			 
a95a					; skip ld hl, 
a95a					; then load the ptr 
a95a			; TODO use get from hl ptr 
a95a 23					inc hl 
a95b 5e					ld e, (hl) 
a95c 23					inc hl 
a95d 56					ld d, (hl) 
a95e eb					ex de, hl 
a95f			 
a95f			 
a95f				if DEBUG_FORTH_WORDS 
a95f					DMARK "LSt" 
a95f f5				push af  
a960 3a 74 a9			ld a, (.dmark)  
a963 32 71 ee			ld (debug_mark),a  
a966 3a 75 a9			ld a, (.dmark+1)  
a969 32 72 ee			ld (debug_mark+1),a  
a96c 3a 76 a9			ld a, (.dmark+2)  
a96f 32 73 ee			ld (debug_mark+2),a  
a972 18 03			jr .pastdmark  
a974 ..			.dmark: db "LSt"  
a977 f1			.pastdmark: pop af  
a978			endm  
# End of macro DMARK
a978					CALLMONITOR 
a978 cd a3 94			call break_point_state  
a97b				endm  
# End of macro CALLMONITOR
a97b				endif 
a97b			 
a97b			; cant push right now due to tokenised strings  
a97b			 
a97b			; get the destination of where to copy this definition to. 
a97b			 
a97b c5					push bc 
a97c d1					pop de 
a97d			 
a97d 7e			.listl:         ld a,(hl) 
a97e fe 00				cp 0 
a980 28 09				jr z, .lreplsp     ; replace zero with space 
a982					;cp FORTH_END_BUFFER 
a982 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a984 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a986				 
a986					; just copy this char as is then 
a986			 
a986 12					ld (de), a 
a987			 
a987 23			.listnxt:	inc hl 
a988 13					inc de 
a989 18 f2				jr .listl 
a98b			 
a98b 3e 20		.lreplsp:	ld a,' ' 
a98d 12					ld (de), a 
a98e 18 f7				jr .listnxt 
a990			 
a990			; close up uword def 
a990			 
a990			.listdone: 
a990 12					ld (de), a 
a991 13					inc de 
a992 3e 00				ld a, 0 
a994 12					ld (de), a 
a995			 
a995			; now have def so clean up and push to stack 
a995			 
a995 21 cb e2				ld hl, scratch 
a998				if DEBUG_FORTH_WORDS 
a998					DMARK "Ltp" 
a998 f5				push af  
a999 3a ad a9			ld a, (.dmark)  
a99c 32 71 ee			ld (debug_mark),a  
a99f 3a ae a9			ld a, (.dmark+1)  
a9a2 32 72 ee			ld (debug_mark+1),a  
a9a5 3a af a9			ld a, (.dmark+2)  
a9a8 32 73 ee			ld (debug_mark+2),a  
a9ab 18 03			jr .pastdmark  
a9ad ..			.dmark: db "Ltp"  
a9b0 f1			.pastdmark: pop af  
a9b1			endm  
# End of macro DMARK
a9b1					CALLMONITOR 
a9b1 cd a3 94			call break_point_state  
a9b4				endm  
# End of macro CALLMONITOR
a9b4				endif 
a9b4			 
a9b4 18 1f			jr .listpush 
a9b6			 
a9b6			;.lnuword:	pop hl 
a9b6			;		call forth_tok_next 
a9b6			;		jp .ldouscan  
a9b6			 
a9b6			.lunotfound:		  
a9b6			 
a9b6				if DEBUG_FORTH_WORDS 
a9b6					DMARK "LSn" 
a9b6 f5				push af  
a9b7 3a cb a9			ld a, (.dmark)  
a9ba 32 71 ee			ld (debug_mark),a  
a9bd 3a cc a9			ld a, (.dmark+1)  
a9c0 32 72 ee			ld (debug_mark+1),a  
a9c3 3a cd a9			ld a, (.dmark+2)  
a9c6 32 73 ee			ld (debug_mark+2),a  
a9c9 18 03			jr .pastdmark  
a9cb ..			.dmark: db "LSn"  
a9ce f1			.pastdmark: pop af  
a9cf			endm  
# End of macro DMARK
a9cf					CALLMONITOR 
a9cf cd a3 94			call break_point_state  
a9d2				endm  
# End of macro CALLMONITOR
a9d2				endif 
a9d2			 
a9d2					 
a9d2			;		FORTH_DSP_POP 
a9d2			;		ld hl, .luno 
a9d2			 
a9d2					NEXTW			 
a9d2 c3 c1 9e			jp macro_next 
a9d5				endm 
# End of macro NEXTW
a9d5			 
a9d5			.listpush: 
a9d5				if DEBUG_FORTH_WORDS 
a9d5					DMARK "LS>" 
a9d5 f5				push af  
a9d6 3a ea a9			ld a, (.dmark)  
a9d9 32 71 ee			ld (debug_mark),a  
a9dc 3a eb a9			ld a, (.dmark+1)  
a9df 32 72 ee			ld (debug_mark+1),a  
a9e2 3a ec a9			ld a, (.dmark+2)  
a9e5 32 73 ee			ld (debug_mark+2),a  
a9e8 18 03			jr .pastdmark  
a9ea ..			.dmark: db "LS>"  
a9ed f1			.pastdmark: pop af  
a9ee			endm  
# End of macro DMARK
a9ee					CALLMONITOR 
a9ee cd a3 94			call break_point_state  
a9f1				endm  
# End of macro CALLMONITOR
a9f1				endif 
a9f1 cd 82 9b				call forth_push_str 
a9f4			 
a9f4			 
a9f4			 
a9f4					NEXTW 
a9f4 c3 c1 9e			jp macro_next 
a9f7				endm 
# End of macro NEXTW
a9f7			 
a9f7			;.luno:    db "Word not found",0 
a9f7			 
a9f7			 
a9f7			 
a9f7			 
a9f7			 
a9f7			;		push hl   ; save pointer to start of uword def string 
a9f7			; 
a9f7			;; look for FORTH_EOL_LINE 
a9f7			;		ld a, FORTH_END_BUFFER 
a9f7			;		call strlent 
a9f7			; 
a9f7			;		inc hl		 ; space for coln def 
a9f7			;		inc hl 
a9f7			;		inc hl          ; space for terms 
a9f7			;		inc hl 
a9f7			; 
a9f7			;		ld a, 20   ; TODO get actual length 
a9f7			;		call addatohl    ; include a random amount of room for the uword name 
a9f7			; 
a9f7			;		 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt1" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;		 
a9f7			; 
a9f7			;; malloc space for the string because we cant change it 
a9f7			; 
a9f7			;		call malloc 
a9f7			;	if DEBUG_FORTH_MALLOC_GUARD 
a9f7			;		push af 
a9f7			;		call ishlzero 
a9f7			;		pop af 
a9f7			;		 
a9f7			;		call z,malloc_error 
a9f7			;	endif 
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt2" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;		pop de 
a9f7			;		push hl    ; push the malloc to release later 
a9f7			;		push hl   ;  push back a copy for the later stack push 
a9f7			;		 
a9f7			;; copy the string swapping out the zero terms for spaces 
a9f7			; 
a9f7			;		; de has our source 
a9f7			;		; hl has our dest 
a9f7			; 
a9f7			;; add the coln def 
a9f7			; 
a9f7			;		ld a, ':' 
a9f7			;		ld (hl), a 
a9f7			;		inc hl 
a9f7			;		ld a, ' ' 
a9f7			;		ld (hl), a 
a9f7			;		inc hl 
a9f7			; 
a9f7			;; add the uname word 
a9f7			;		push de   ; save our string for now 
a9f7			;		ex de, hl 
a9f7			; 
a9f7			;		FORTH_DSP_VALUE 
a9f7			;		;v5 FORTH_DSP_VALUE 
a9f7			; 
a9f7			;		inc hl   ; skip type but we know by now this is OK 
a9f7			; 
a9f7			;.luword:	ld a,(hl) 
a9f7			;		cp 0 
a9f7			;		jr z, .luword2 
a9f7			;		ld (de), a 
a9f7			;		inc de 
a9f7			;		inc hl 
a9f7			;		jr .luword 
a9f7			; 
a9f7			;.luword2:	ld a, ' ' 
a9f7			;		ld (de), a 
a9f7			;;		inc hl 
a9f7			;;		inc de 
a9f7			;;		ld (de), a 
a9f7			;;		inc hl 
a9f7			;		inc de 
a9f7			; 
a9f7			;		ex de, hl 
a9f7			;		pop de 
a9f7			;		 
a9f7			;		 
a9f7			; 
a9f7			;; detoken that string and copy it 
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt2" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;.ldetok:	ld a, (de) 
a9f7			;		cp FORTH_END_BUFFER 
a9f7			;		jr z, .ldetokend 
a9f7			;		; swap out any zero term for space 
a9f7			;		cp 0 
a9f7			;		jr nz, .ldetoknext 
a9f7			;		ld a, ' ' 
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "LtS" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;.ldetoknext:	ld (hl), a 
a9f7			;		inc de 
a9f7			;		inc hl 
a9f7			;		jr .ldetok 
a9f7			; 
a9f7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a9f7			;		ld (hl), a  
a9f7			; 
a9f7			;; free that temp malloc 
a9f7			; 
a9f7			;		pop hl    
a9f7			; 
a9f7			;	if DEBUG_FORTH_WORDS 
a9f7			;		DMARK "Lt4" 
a9f7			;		CALLMONITOR 
a9f7			;	endif 
a9f7			;		call forth_apushstrhl 
a9f7			; 
a9f7			;		; get rid of temp malloc area 
a9f7			; 
a9f7			;		pop hl 
a9f7			;		call free 
a9f7			; 
a9f7			;		jr .ludone 
a9f7			; 
a9f7			;.lnuword:	pop hl 
a9f7			;		call forth_tok_next 
a9f7			;		jp .ldouscan  
a9f7			; 
a9f7			;.ludone:		 pop hl 
a9f7			; 
a9f7					NEXTW 
a9f7 c3 c1 9e			jp macro_next 
a9fa				endm 
# End of macro NEXTW
a9fa			 
a9fa			.FORGET: 
a9fa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a9fa 5d				db WORD_SYS_CORE+73             
a9fb 73 aa			dw .NOP            
a9fd 07				db 6 + 1 
a9fe .. 00			db "FORGET",0              
aa05				endm 
# End of macro CWHEAD
aa05			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa05			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa05			; | |  
aa05			; | | e.g. "MORE" forget 
aa05					if DEBUG_FORTH_WORDS_KEY 
aa05						DMARK "FRG" 
aa05 f5				push af  
aa06 3a 1a aa			ld a, (.dmark)  
aa09 32 71 ee			ld (debug_mark),a  
aa0c 3a 1b aa			ld a, (.dmark+1)  
aa0f 32 72 ee			ld (debug_mark+1),a  
aa12 3a 1c aa			ld a, (.dmark+2)  
aa15 32 73 ee			ld (debug_mark+2),a  
aa18 18 03			jr .pastdmark  
aa1a ..			.dmark: db "FRG"  
aa1d f1			.pastdmark: pop af  
aa1e			endm  
# End of macro DMARK
aa1e						CALLMONITOR 
aa1e cd a3 94			call break_point_state  
aa21				endm  
# End of macro CALLMONITOR
aa21					endif 
aa21			 
aa21				; find uword 
aa21			        ; update start of word with "_" 
aa21				; replace uword with deleted flag 
aa21			 
aa21			 
aa21			;	if DEBUG_FORTH_WORDS 
aa21			;		DMARK "FOG" 
aa21			;		CALLMONITOR 
aa21			;	endif 
aa21			 
aa21			 
aa21					; Get ptr to the word we need to look up 
aa21			 
aa21					FORTH_DSP_VALUEHL 
aa21 cd 0b 9d			call macro_dsp_valuehl 
aa24				endm 
# End of macro FORTH_DSP_VALUEHL
aa24					;v5 FORTH_DSP_VALUE 
aa24				; TODO type check 
aa24			;		inc hl    ; Skip type check  
aa24 e5					push hl 
aa25 c1					pop bc 
aa26			;		ex de, hl    ; put into DE 
aa26			 
aa26			 
aa26 21 ca e2				ld hl, baseram 
aa29					;ld hl, baseusermem 
aa29			 
aa29				; skip dict stub 
aa29			;	call forth_tok_next 
aa29 e5			push hl   ; sacreifical push 
aa2a			 
aa2a			.fldouscanm: 
aa2a e1				pop hl 
aa2b			.fldouscan: 
aa2b			;	if DEBUG_FORTH_WORDS 
aa2b			;		DMARK "LSs" 
aa2b			;		CALLMONITOR 
aa2b			;	endif 
aa2b				; skip dict stub 
aa2b cd 12 a0				call forth_tok_next 
aa2e			 
aa2e			 
aa2e			; while we have words to look for 
aa2e			 
aa2e 7e				ld a, (hl)      
aa2f			;	if DEBUG_FORTH_WORDS 
aa2f			;		DMARK "LSk" 
aa2f			;		CALLMONITOR 
aa2f			;	endif 
aa2f fe 00				cp WORD_SYS_END 
aa31 ca 6d aa				jp z, .flunotfound 
aa34 fe 01				cp WORD_SYS_UWORD 
aa36 c2 2b aa				jp nz, .fldouscan 
aa39			 
aa39			;	if DEBUG_FORTH_WORDS 
aa39			;		DMARK "LSu" 
aa39			;		CALLMONITOR 
aa39			;	endif 
aa39			 
aa39					; found a uword but is it the one we want... 
aa39			 
aa39 c5					push bc     ; uword to find is on bc 
aa3a d1					pop de 
aa3b			 
aa3b e5					push hl  ; to save the ptr 
aa3c			 
aa3c					; skip opcode 
aa3c 23					inc hl  
aa3d					; skip next ptr 
aa3d 23					inc hl  
aa3e 23					inc hl 
aa3f					; skip len 
aa3f 23					inc hl 
aa40			 
aa40			;	if DEBUG_FORTH_WORDS 
aa40			;		DMARK "LSc" 
aa40			;		CALLMONITOR 
aa40			;	endif 
aa40 cd 38 91				call strcmp 
aa43 c2 2a aa				jp nz, .fldouscanm 
aa46			; 
aa46			; 
aa46			;; while we have words to look for 
aa46			; 
aa46			;.fdouscan:	ld a, (hl)      
aa46			;	if DEBUG_FORTH_WORDS 
aa46			;		DMARK "LSs" 
aa46			;		CALLMONITOR 
aa46			;	endif 
aa46			;		cp WORD_SYS_END 
aa46			;		jp z, .fudone 
aa46			;		cp WORD_SYS_UWORD 
aa46			;		jp nz, .fnuword 
aa46			; 
aa46			;	if DEBUG_FORTH_WORDS 
aa46			;		DMARK "FGu" 
aa46			;		CALLMONITOR 
aa46			;	endif 
aa46			; 
aa46			;		; found a uword but is it the one we want... 
aa46			; 
aa46			; 
aa46			;	        pop de   ; get back the dsp name 
aa46			;		push de 
aa46			; 
aa46			;		push hl  ; to save the ptr 
aa46			; 
aa46			;		; skip opcode 
aa46			;		inc hl  
aa46			;		; skip next ptr 
aa46			;		inc hl  
aa46			;		inc hl 
aa46			;		; skip len 
aa46			;		inc hl 
aa46			; 
aa46			;	if DEBUG_FORTH_WORDS 
aa46			;		DMARK "FGc" 
aa46			;		CALLMONITOR 
aa46			;	endif 
aa46			;		call strcmp 
aa46			;		jp nz, .fnuword 
aa46			 
aa46			 
aa46 e1			pop hl 
aa47			 
aa47				 
aa47				if DEBUG_FORTH_WORDS 
aa47					DMARK "FGm" 
aa47 f5				push af  
aa48 3a 5c aa			ld a, (.dmark)  
aa4b 32 71 ee			ld (debug_mark),a  
aa4e 3a 5d aa			ld a, (.dmark+1)  
aa51 32 72 ee			ld (debug_mark+1),a  
aa54 3a 5e aa			ld a, (.dmark+2)  
aa57 32 73 ee			ld (debug_mark+2),a  
aa5a 18 03			jr .pastdmark  
aa5c ..			.dmark: db "FGm"  
aa5f f1			.pastdmark: pop af  
aa60			endm  
# End of macro DMARK
aa60					CALLMONITOR 
aa60 cd a3 94			call break_point_state  
aa63				endm  
# End of macro CALLMONITOR
aa63				endif 
aa63			 
aa63			 
aa63			 
aa63					; we have a uword so push its name to the stack 
aa63			 
aa63			;	   	push hl  ; save so we can move to next dict block 
aa63			;pop hl 
aa63			 
aa63					; update opcode to deleted 
aa63 3e 03				ld a, WORD_SYS_DELETED 
aa65 77					ld (hl), a 
aa66			 
aa66 23					inc hl  
aa67					; skip next ptr 
aa67 23					inc hl  
aa68 23					inc hl 
aa69					; skip len 
aa69 23					inc hl 
aa6a			 
aa6a					; TODO change parser to skip deleted words but for now mark it out 
aa6a 3e 5f				ld a, "_" 
aa6c 77					ld  (hl),a 
aa6d			 
aa6d			;		jr .fudone 
aa6d			; 
aa6d			;.fnuword:	pop hl 
aa6d			;		call forth_tok_next 
aa6d			;		jp .fdouscan  
aa6d			 
aa6d			.flunotfound:		  
aa6d			 
aa6d			 
aa6d					 
aa6d					FORTH_DSP_POP 
aa6d cd c3 9d			call macro_forth_dsp_pop 
aa70				endm 
# End of macro FORTH_DSP_POP
aa70			;		ld hl, .luno 
aa70			;.fudone:		 pop hl 
aa70					NEXTW 
aa70 c3 c1 9e			jp macro_next 
aa73				endm 
# End of macro NEXTW
aa73			.NOP: 
aa73				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa73 61				db WORD_SYS_CORE+77             
aa74 9a aa			dw .COMO            
aa76 04				db 3 + 1 
aa77 .. 00			db "NOP",0              
aa7b				endm 
# End of macro CWHEAD
aa7b			; | NOP (  --  ) Do nothing | DONE 
aa7b					if DEBUG_FORTH_WORDS_KEY 
aa7b						DMARK "NOP" 
aa7b f5				push af  
aa7c 3a 90 aa			ld a, (.dmark)  
aa7f 32 71 ee			ld (debug_mark),a  
aa82 3a 91 aa			ld a, (.dmark+1)  
aa85 32 72 ee			ld (debug_mark+1),a  
aa88 3a 92 aa			ld a, (.dmark+2)  
aa8b 32 73 ee			ld (debug_mark+2),a  
aa8e 18 03			jr .pastdmark  
aa90 ..			.dmark: db "NOP"  
aa93 f1			.pastdmark: pop af  
aa94			endm  
# End of macro DMARK
aa94						CALLMONITOR 
aa94 cd a3 94			call break_point_state  
aa97				endm  
# End of macro CALLMONITOR
aa97					endif 
aa97				       NEXTW 
aa97 c3 c1 9e			jp macro_next 
aa9a				endm 
# End of macro NEXTW
aa9a			.COMO: 
aa9a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa9a 6e				db WORD_SYS_CORE+90             
aa9b ec aa			dw .COMC            
aa9d 02				db 1 + 1 
aa9e .. 00			db "(",0              
aaa0				endm 
# End of macro CWHEAD
aaa0			; | ( ( -- )  Start of comment | DONE 
aaa0			 
aaa0			 
aaa0 2a cc e5				ld hl, ( os_tok_ptr) 
aaa3 11 e7 aa			ld de, .closepar 
aaa6					 
aaa6					if DEBUG_FORTH_WORDS 
aaa6						DMARK ").." 
aaa6 f5				push af  
aaa7 3a bb aa			ld a, (.dmark)  
aaaa 32 71 ee			ld (debug_mark),a  
aaad 3a bc aa			ld a, (.dmark+1)  
aab0 32 72 ee			ld (debug_mark+1),a  
aab3 3a bd aa			ld a, (.dmark+2)  
aab6 32 73 ee			ld (debug_mark+2),a  
aab9 18 03			jr .pastdmark  
aabb ..			.dmark: db ").."  
aabe f1			.pastdmark: pop af  
aabf			endm  
# End of macro DMARK
aabf						CALLMONITOR 
aabf cd a3 94			call break_point_state  
aac2				endm  
# End of macro CALLMONITOR
aac2					endif 
aac2 cd dc 9f			call findnexttok  
aac5			 
aac5					if DEBUG_FORTH_WORDS 
aac5						DMARK "IF5" 
aac5 f5				push af  
aac6 3a da aa			ld a, (.dmark)  
aac9 32 71 ee			ld (debug_mark),a  
aacc 3a db aa			ld a, (.dmark+1)  
aacf 32 72 ee			ld (debug_mark+1),a  
aad2 3a dc aa			ld a, (.dmark+2)  
aad5 32 73 ee			ld (debug_mark+2),a  
aad8 18 03			jr .pastdmark  
aada ..			.dmark: db "IF5"  
aadd f1			.pastdmark: pop af  
aade			endm  
# End of macro DMARK
aade						CALLMONITOR 
aade cd a3 94			call break_point_state  
aae1				endm  
# End of macro CALLMONITOR
aae1					endif 
aae1				; replace below with ) exec using tok_ptr 
aae1 22 cc e5			ld (os_tok_ptr), hl 
aae4 c3 52 9f			jp exec1 
aae7			 
aae7 .. 00			.closepar:   db ")",0 
aae9			 
aae9				       NEXTW 
aae9 c3 c1 9e			jp macro_next 
aaec				endm 
# End of macro NEXTW
aaec			.COMC: 
aaec				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aaec 6f				db WORD_SYS_CORE+91             
aaed f5 aa			dw .SCRATCH            
aaef 02				db 1 + 1 
aaf0 .. 00			db ")",0              
aaf2				endm 
# End of macro CWHEAD
aaf2			; | ) ( -- )  End of comment |  DONE  
aaf2				       NEXTW 
aaf2 c3 c1 9e			jp macro_next 
aaf5				endm 
# End of macro NEXTW
aaf5			 
aaf5			.SCRATCH: 
aaf5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aaf5 6f				db WORD_SYS_CORE+91             
aaf6 30 ab			dw .INC            
aaf8 08				db 7 + 1 
aaf9 .. 00			db "SCRATCH",0              
ab01				endm 
# End of macro CWHEAD
ab01			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab01			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab01			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab01			; | |  
ab01			; | | e.g.    : score $00 scratch ; 
ab01			; | |  
ab01			; | | $00 score ! 
ab01			; | | $01 score +! 
ab01			; | |  
ab01			; | | e.g.   : varword $0a scratch ;  
ab01			; | | 
ab01			; | | $8000 varword ! 
ab01					if DEBUG_FORTH_WORDS_KEY 
ab01						DMARK "SCR" 
ab01 f5				push af  
ab02 3a 16 ab			ld a, (.dmark)  
ab05 32 71 ee			ld (debug_mark),a  
ab08 3a 17 ab			ld a, (.dmark+1)  
ab0b 32 72 ee			ld (debug_mark+1),a  
ab0e 3a 18 ab			ld a, (.dmark+2)  
ab11 32 73 ee			ld (debug_mark+2),a  
ab14 18 03			jr .pastdmark  
ab16 ..			.dmark: db "SCR"  
ab19 f1			.pastdmark: pop af  
ab1a			endm  
# End of macro DMARK
ab1a						CALLMONITOR 
ab1a cd a3 94			call break_point_state  
ab1d				endm  
# End of macro CALLMONITOR
ab1d					endif 
ab1d			 
ab1d					FORTH_DSP_VALUEHL 
ab1d cd 0b 9d			call macro_dsp_valuehl 
ab20				endm 
# End of macro FORTH_DSP_VALUEHL
ab20				 
ab20					FORTH_DSP_POP 
ab20 cd c3 9d			call macro_forth_dsp_pop 
ab23				endm 
# End of macro FORTH_DSP_POP
ab23			 
ab23 7d					ld a, l 
ab24 21 f0 e7				ld hl, os_var_array 
ab27 cd a2 8c				call addatohl 
ab2a			 
ab2a cd 14 9b				call forth_push_numhl 
ab2d			 
ab2d				       NEXTW 
ab2d c3 c1 9e			jp macro_next 
ab30				endm 
# End of macro NEXTW
ab30			 
ab30			.INC: 
ab30				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab30 6f				db WORD_SYS_CORE+91             
ab31 84 ab			dw .DEC            
ab33 03				db 2 + 1 
ab34 .. 00			db "+!",0              
ab37				endm 
# End of macro CWHEAD
ab37			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab37					if DEBUG_FORTH_WORDS_KEY 
ab37						DMARK "+s_" 
ab37 f5				push af  
ab38 3a 4c ab			ld a, (.dmark)  
ab3b 32 71 ee			ld (debug_mark),a  
ab3e 3a 4d ab			ld a, (.dmark+1)  
ab41 32 72 ee			ld (debug_mark+1),a  
ab44 3a 4e ab			ld a, (.dmark+2)  
ab47 32 73 ee			ld (debug_mark+2),a  
ab4a 18 03			jr .pastdmark  
ab4c ..			.dmark: db "+s_"  
ab4f f1			.pastdmark: pop af  
ab50			endm  
# End of macro DMARK
ab50						CALLMONITOR 
ab50 cd a3 94			call break_point_state  
ab53				endm  
# End of macro CALLMONITOR
ab53					endif 
ab53			 
ab53					FORTH_DSP_VALUEHL 
ab53 cd 0b 9d			call macro_dsp_valuehl 
ab56				endm 
# End of macro FORTH_DSP_VALUEHL
ab56			 
ab56 e5					push hl   ; save address 
ab57			 
ab57					FORTH_DSP_POP 
ab57 cd c3 9d			call macro_forth_dsp_pop 
ab5a				endm 
# End of macro FORTH_DSP_POP
ab5a			 
ab5a					FORTH_DSP_VALUEHL 
ab5a cd 0b 9d			call macro_dsp_valuehl 
ab5d				endm 
# End of macro FORTH_DSP_VALUEHL
ab5d			 
ab5d					FORTH_DSP_POP 
ab5d cd c3 9d			call macro_forth_dsp_pop 
ab60				endm 
# End of macro FORTH_DSP_POP
ab60			 
ab60					; hl contains value to add to byte at a 
ab60				 
ab60 eb					ex de, hl 
ab61			 
ab61 e1					pop hl 
ab62			 
ab62					if DEBUG_FORTH_WORDS 
ab62						DMARK "INC" 
ab62 f5				push af  
ab63 3a 77 ab			ld a, (.dmark)  
ab66 32 71 ee			ld (debug_mark),a  
ab69 3a 78 ab			ld a, (.dmark+1)  
ab6c 32 72 ee			ld (debug_mark+1),a  
ab6f 3a 79 ab			ld a, (.dmark+2)  
ab72 32 73 ee			ld (debug_mark+2),a  
ab75 18 03			jr .pastdmark  
ab77 ..			.dmark: db "INC"  
ab7a f1			.pastdmark: pop af  
ab7b			endm  
# End of macro DMARK
ab7b						CALLMONITOR 
ab7b cd a3 94			call break_point_state  
ab7e				endm  
# End of macro CALLMONITOR
ab7e					endif 
ab7e			 
ab7e 7e					ld a,(hl) 
ab7f 83					add e 
ab80 77					ld (hl),a 
ab81			 
ab81			 
ab81			 
ab81				       NEXTW 
ab81 c3 c1 9e			jp macro_next 
ab84				endm 
# End of macro NEXTW
ab84			 
ab84			.DEC: 
ab84				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab84 6f				db WORD_SYS_CORE+91             
ab85 d5 ab			dw .INC2            
ab87 03				db 2 + 1 
ab88 .. 00			db "-!",0              
ab8b				endm 
# End of macro CWHEAD
ab8b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab8b					if DEBUG_FORTH_WORDS_KEY 
ab8b						DMARK "-s_" 
ab8b f5				push af  
ab8c 3a a0 ab			ld a, (.dmark)  
ab8f 32 71 ee			ld (debug_mark),a  
ab92 3a a1 ab			ld a, (.dmark+1)  
ab95 32 72 ee			ld (debug_mark+1),a  
ab98 3a a2 ab			ld a, (.dmark+2)  
ab9b 32 73 ee			ld (debug_mark+2),a  
ab9e 18 03			jr .pastdmark  
aba0 ..			.dmark: db "-s_"  
aba3 f1			.pastdmark: pop af  
aba4			endm  
# End of macro DMARK
aba4						CALLMONITOR 
aba4 cd a3 94			call break_point_state  
aba7				endm  
# End of macro CALLMONITOR
aba7					endif 
aba7			 
aba7					FORTH_DSP_VALUEHL 
aba7 cd 0b 9d			call macro_dsp_valuehl 
abaa				endm 
# End of macro FORTH_DSP_VALUEHL
abaa			 
abaa e5					push hl   ; save address 
abab			 
abab					FORTH_DSP_POP 
abab cd c3 9d			call macro_forth_dsp_pop 
abae				endm 
# End of macro FORTH_DSP_POP
abae			 
abae					FORTH_DSP_VALUEHL 
abae cd 0b 9d			call macro_dsp_valuehl 
abb1				endm 
# End of macro FORTH_DSP_VALUEHL
abb1			 
abb1					; hl contains value to add to byte at a 
abb1				 
abb1 eb					ex de, hl 
abb2			 
abb2 e1					pop hl 
abb3			 
abb3					if DEBUG_FORTH_WORDS 
abb3						DMARK "DEC" 
abb3 f5				push af  
abb4 3a c8 ab			ld a, (.dmark)  
abb7 32 71 ee			ld (debug_mark),a  
abba 3a c9 ab			ld a, (.dmark+1)  
abbd 32 72 ee			ld (debug_mark+1),a  
abc0 3a ca ab			ld a, (.dmark+2)  
abc3 32 73 ee			ld (debug_mark+2),a  
abc6 18 03			jr .pastdmark  
abc8 ..			.dmark: db "DEC"  
abcb f1			.pastdmark: pop af  
abcc			endm  
# End of macro DMARK
abcc						CALLMONITOR 
abcc cd a3 94			call break_point_state  
abcf				endm  
# End of macro CALLMONITOR
abcf					endif 
abcf			 
abcf 7e					ld a,(hl) 
abd0 93					sub e 
abd1 77					ld (hl),a 
abd2			 
abd2			 
abd2			 
abd2				       NEXTW 
abd2 c3 c1 9e			jp macro_next 
abd5				endm 
# End of macro NEXTW
abd5			 
abd5			.INC2: 
abd5				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
abd5 6f				db WORD_SYS_CORE+91             
abd6 7f ac			dw .DEC2            
abd8 04				db 3 + 1 
abd9 .. 00			db "+2!",0              
abdd				endm 
# End of macro CWHEAD
abdd			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
abdd			 
abdd					if DEBUG_FORTH_WORDS_KEY 
abdd						DMARK "+2s" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 71 ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 72 ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 73 ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "+2s"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd a3 94			call break_point_state  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9					; Address 
abf9			 
abf9					FORTH_DSP_VALUEHL 
abf9 cd 0b 9d			call macro_dsp_valuehl 
abfc				endm 
# End of macro FORTH_DSP_VALUEHL
abfc			 
abfc e5					push hl    ; save address 
abfd			 
abfd					; load content into de 
abfd			 
abfd 5e					ld e,(hl) 
abfe 23					inc hl 
abff 56					ld d, (hl) 
ac00			 
ac00					if DEBUG_FORTH_WORDS 
ac00						DMARK "+2a" 
ac00 f5				push af  
ac01 3a 15 ac			ld a, (.dmark)  
ac04 32 71 ee			ld (debug_mark),a  
ac07 3a 16 ac			ld a, (.dmark+1)  
ac0a 32 72 ee			ld (debug_mark+1),a  
ac0d 3a 17 ac			ld a, (.dmark+2)  
ac10 32 73 ee			ld (debug_mark+2),a  
ac13 18 03			jr .pastdmark  
ac15 ..			.dmark: db "+2a"  
ac18 f1			.pastdmark: pop af  
ac19			endm  
# End of macro DMARK
ac19						CALLMONITOR 
ac19 cd a3 94			call break_point_state  
ac1c				endm  
# End of macro CALLMONITOR
ac1c					endif 
ac1c			 
ac1c					FORTH_DSP_POP 
ac1c cd c3 9d			call macro_forth_dsp_pop 
ac1f				endm 
# End of macro FORTH_DSP_POP
ac1f			 
ac1f					; Get value to add 
ac1f			 
ac1f					FORTH_DSP_VALUE 
ac1f cd f4 9c			call macro_forth_dsp_value 
ac22				endm 
# End of macro FORTH_DSP_VALUE
ac22			 
ac22					if DEBUG_FORTH_WORDS 
ac22						DMARK "+2v" 
ac22 f5				push af  
ac23 3a 37 ac			ld a, (.dmark)  
ac26 32 71 ee			ld (debug_mark),a  
ac29 3a 38 ac			ld a, (.dmark+1)  
ac2c 32 72 ee			ld (debug_mark+1),a  
ac2f 3a 39 ac			ld a, (.dmark+2)  
ac32 32 73 ee			ld (debug_mark+2),a  
ac35 18 03			jr .pastdmark  
ac37 ..			.dmark: db "+2v"  
ac3a f1			.pastdmark: pop af  
ac3b			endm  
# End of macro DMARK
ac3b						CALLMONITOR 
ac3b cd a3 94			call break_point_state  
ac3e				endm  
# End of macro CALLMONITOR
ac3e					endif 
ac3e			 
ac3e 19					add hl, de 
ac3f			 
ac3f					if DEBUG_FORTH_WORDS 
ac3f						DMARK "+2+" 
ac3f f5				push af  
ac40 3a 54 ac			ld a, (.dmark)  
ac43 32 71 ee			ld (debug_mark),a  
ac46 3a 55 ac			ld a, (.dmark+1)  
ac49 32 72 ee			ld (debug_mark+1),a  
ac4c 3a 56 ac			ld a, (.dmark+2)  
ac4f 32 73 ee			ld (debug_mark+2),a  
ac52 18 03			jr .pastdmark  
ac54 ..			.dmark: db "+2+"  
ac57 f1			.pastdmark: pop af  
ac58			endm  
# End of macro DMARK
ac58						CALLMONITOR 
ac58 cd a3 94			call break_point_state  
ac5b				endm  
# End of macro CALLMONITOR
ac5b					endif 
ac5b			 
ac5b					; move result to de 
ac5b			 
ac5b eb					ex de, hl 
ac5c			 
ac5c					; Address 
ac5c			 
ac5c e1					pop hl 
ac5d			 
ac5d					; save it back 
ac5d			 
ac5d 73					ld (hl), e 
ac5e 23					inc hl 
ac5f 72					ld (hl), d 
ac60			 
ac60					if DEBUG_FORTH_WORDS 
ac60						DMARK "+2e" 
ac60 f5				push af  
ac61 3a 75 ac			ld a, (.dmark)  
ac64 32 71 ee			ld (debug_mark),a  
ac67 3a 76 ac			ld a, (.dmark+1)  
ac6a 32 72 ee			ld (debug_mark+1),a  
ac6d 3a 77 ac			ld a, (.dmark+2)  
ac70 32 73 ee			ld (debug_mark+2),a  
ac73 18 03			jr .pastdmark  
ac75 ..			.dmark: db "+2e"  
ac78 f1			.pastdmark: pop af  
ac79			endm  
# End of macro DMARK
ac79						CALLMONITOR 
ac79 cd a3 94			call break_point_state  
ac7c				endm  
# End of macro CALLMONITOR
ac7c					endif 
ac7c			 
ac7c			 
ac7c			 
ac7c			 
ac7c			 
ac7c				       NEXTW 
ac7c c3 c1 9e			jp macro_next 
ac7f				endm 
# End of macro NEXTW
ac7f			 
ac7f			.DEC2: 
ac7f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac7f 6f				db WORD_SYS_CORE+91             
ac80 2b ad			dw .GET2            
ac82 04				db 3 + 1 
ac83 .. 00			db "-2!",0              
ac87				endm 
# End of macro CWHEAD
ac87			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac87			 
ac87			 
ac87					if DEBUG_FORTH_WORDS_KEY 
ac87						DMARK "-2s" 
ac87 f5				push af  
ac88 3a 9c ac			ld a, (.dmark)  
ac8b 32 71 ee			ld (debug_mark),a  
ac8e 3a 9d ac			ld a, (.dmark+1)  
ac91 32 72 ee			ld (debug_mark+1),a  
ac94 3a 9e ac			ld a, (.dmark+2)  
ac97 32 73 ee			ld (debug_mark+2),a  
ac9a 18 03			jr .pastdmark  
ac9c ..			.dmark: db "-2s"  
ac9f f1			.pastdmark: pop af  
aca0			endm  
# End of macro DMARK
aca0						CALLMONITOR 
aca0 cd a3 94			call break_point_state  
aca3				endm  
# End of macro CALLMONITOR
aca3					endif 
aca3			 
aca3					; Address 
aca3			 
aca3					FORTH_DSP_VALUEHL 
aca3 cd 0b 9d			call macro_dsp_valuehl 
aca6				endm 
# End of macro FORTH_DSP_VALUEHL
aca6			 
aca6 e5					push hl    ; save address 
aca7			 
aca7					; load content into de 
aca7			 
aca7 5e					ld e,(hl) 
aca8 23					inc hl 
aca9 56					ld d, (hl) 
acaa			 
acaa					if DEBUG_FORTH_WORDS 
acaa						DMARK "-2a" 
acaa f5				push af  
acab 3a bf ac			ld a, (.dmark)  
acae 32 71 ee			ld (debug_mark),a  
acb1 3a c0 ac			ld a, (.dmark+1)  
acb4 32 72 ee			ld (debug_mark+1),a  
acb7 3a c1 ac			ld a, (.dmark+2)  
acba 32 73 ee			ld (debug_mark+2),a  
acbd 18 03			jr .pastdmark  
acbf ..			.dmark: db "-2a"  
acc2 f1			.pastdmark: pop af  
acc3			endm  
# End of macro DMARK
acc3						CALLMONITOR 
acc3 cd a3 94			call break_point_state  
acc6				endm  
# End of macro CALLMONITOR
acc6					endif 
acc6			 
acc6					FORTH_DSP_POP 
acc6 cd c3 9d			call macro_forth_dsp_pop 
acc9				endm 
# End of macro FORTH_DSP_POP
acc9			 
acc9					; Get value to remove 
acc9			 
acc9					FORTH_DSP_VALUE 
acc9 cd f4 9c			call macro_forth_dsp_value 
accc				endm 
# End of macro FORTH_DSP_VALUE
accc			 
accc					if DEBUG_FORTH_WORDS 
accc						DMARK "-2v" 
accc f5				push af  
accd 3a e1 ac			ld a, (.dmark)  
acd0 32 71 ee			ld (debug_mark),a  
acd3 3a e2 ac			ld a, (.dmark+1)  
acd6 32 72 ee			ld (debug_mark+1),a  
acd9 3a e3 ac			ld a, (.dmark+2)  
acdc 32 73 ee			ld (debug_mark+2),a  
acdf 18 03			jr .pastdmark  
ace1 ..			.dmark: db "-2v"  
ace4 f1			.pastdmark: pop af  
ace5			endm  
# End of macro DMARK
ace5						CALLMONITOR 
ace5 cd a3 94			call break_point_state  
ace8				endm  
# End of macro CALLMONITOR
ace8					endif 
ace8			 
ace8 eb					ex de, hl 
ace9 ed 52				sbc hl, de 
aceb			 
aceb					if DEBUG_FORTH_WORDS 
aceb						DMARK "-2d" 
aceb f5				push af  
acec 3a 00 ad			ld a, (.dmark)  
acef 32 71 ee			ld (debug_mark),a  
acf2 3a 01 ad			ld a, (.dmark+1)  
acf5 32 72 ee			ld (debug_mark+1),a  
acf8 3a 02 ad			ld a, (.dmark+2)  
acfb 32 73 ee			ld (debug_mark+2),a  
acfe 18 03			jr .pastdmark  
ad00 ..			.dmark: db "-2d"  
ad03 f1			.pastdmark: pop af  
ad04			endm  
# End of macro DMARK
ad04						CALLMONITOR 
ad04 cd a3 94			call break_point_state  
ad07				endm  
# End of macro CALLMONITOR
ad07					endif 
ad07			 
ad07					; move result to de 
ad07			 
ad07 eb					ex de, hl 
ad08			 
ad08					; Address 
ad08			 
ad08 e1					pop hl 
ad09			 
ad09					; save it back 
ad09			 
ad09 73					ld (hl), e 
ad0a 23					inc hl 
ad0b 72					ld (hl), d 
ad0c			 
ad0c					if DEBUG_FORTH_WORDS 
ad0c						DMARK "-2e" 
ad0c f5				push af  
ad0d 3a 21 ad			ld a, (.dmark)  
ad10 32 71 ee			ld (debug_mark),a  
ad13 3a 22 ad			ld a, (.dmark+1)  
ad16 32 72 ee			ld (debug_mark+1),a  
ad19 3a 23 ad			ld a, (.dmark+2)  
ad1c 32 73 ee			ld (debug_mark+2),a  
ad1f 18 03			jr .pastdmark  
ad21 ..			.dmark: db "-2e"  
ad24 f1			.pastdmark: pop af  
ad25			endm  
# End of macro DMARK
ad25						CALLMONITOR 
ad25 cd a3 94			call break_point_state  
ad28				endm  
# End of macro CALLMONITOR
ad28					endif 
ad28			 
ad28			 
ad28			 
ad28			 
ad28			 
ad28				       NEXTW 
ad28 c3 c1 9e			jp macro_next 
ad2b				endm 
# End of macro NEXTW
ad2b			.GET2: 
ad2b				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad2b 6f				db WORD_SYS_CORE+91             
ad2c 5b ad			dw .BANG2            
ad2e 03				db 2 + 1 
ad2f .. 00			db "2@",0              
ad32				endm 
# End of macro CWHEAD
ad32			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad32					if DEBUG_FORTH_WORDS_KEY 
ad32						DMARK "2A_" 
ad32 f5				push af  
ad33 3a 47 ad			ld a, (.dmark)  
ad36 32 71 ee			ld (debug_mark),a  
ad39 3a 48 ad			ld a, (.dmark+1)  
ad3c 32 72 ee			ld (debug_mark+1),a  
ad3f 3a 49 ad			ld a, (.dmark+2)  
ad42 32 73 ee			ld (debug_mark+2),a  
ad45 18 03			jr .pastdmark  
ad47 ..			.dmark: db "2A_"  
ad4a f1			.pastdmark: pop af  
ad4b			endm  
# End of macro DMARK
ad4b						CALLMONITOR 
ad4b cd a3 94			call break_point_state  
ad4e				endm  
# End of macro CALLMONITOR
ad4e					endif 
ad4e			 
ad4e					FORTH_DSP_VALUEHL 
ad4e cd 0b 9d			call macro_dsp_valuehl 
ad51				endm 
# End of macro FORTH_DSP_VALUEHL
ad51			 
ad51 5e					ld e, (hl) 
ad52 23					inc hl 
ad53 56					ld d, (hl) 
ad54			 
ad54 eb					ex de, hl 
ad55			 
ad55 cd 14 9b				call forth_push_numhl 
ad58			 
ad58				       NEXTW 
ad58 c3 c1 9e			jp macro_next 
ad5b				endm 
# End of macro NEXTW
ad5b			.BANG2: 
ad5b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad5b 6f				db WORD_SYS_CORE+91             
ad5c 93 ad			dw .CONFIG            
ad5e 03				db 2 + 1 
ad5f .. 00			db "2!",0              
ad62				endm 
# End of macro CWHEAD
ad62			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad62					if DEBUG_FORTH_WORDS_KEY 
ad62						DMARK "2S_" 
ad62 f5				push af  
ad63 3a 77 ad			ld a, (.dmark)  
ad66 32 71 ee			ld (debug_mark),a  
ad69 3a 78 ad			ld a, (.dmark+1)  
ad6c 32 72 ee			ld (debug_mark+1),a  
ad6f 3a 79 ad			ld a, (.dmark+2)  
ad72 32 73 ee			ld (debug_mark+2),a  
ad75 18 03			jr .pastdmark  
ad77 ..			.dmark: db "2S_"  
ad7a f1			.pastdmark: pop af  
ad7b			endm  
# End of macro DMARK
ad7b						CALLMONITOR 
ad7b cd a3 94			call break_point_state  
ad7e				endm  
# End of macro CALLMONITOR
ad7e					endif 
ad7e			 
ad7e					FORTH_DSP_VALUEHL 
ad7e cd 0b 9d			call macro_dsp_valuehl 
ad81				endm 
# End of macro FORTH_DSP_VALUEHL
ad81			 
ad81 e5					push hl   ; save address 
ad82			 
ad82			 
ad82					FORTH_DSP_POP 
ad82 cd c3 9d			call macro_forth_dsp_pop 
ad85				endm 
# End of macro FORTH_DSP_POP
ad85			 
ad85					 
ad85					FORTH_DSP_VALUEHL 
ad85 cd 0b 9d			call macro_dsp_valuehl 
ad88				endm 
# End of macro FORTH_DSP_VALUEHL
ad88			 
ad88					FORTH_DSP_POP 
ad88 cd c3 9d			call macro_forth_dsp_pop 
ad8b				endm 
# End of macro FORTH_DSP_POP
ad8b			 
ad8b eb					ex de, hl    ; value now in de 
ad8c			 
ad8c e1					pop hl 
ad8d			 
ad8d 73					ld (hl), e 
ad8e			 
ad8e 23					inc hl 
ad8f			 
ad8f 72					ld (hl), d 
ad90			 
ad90			 
ad90				       NEXTW 
ad90 c3 c1 9e			jp macro_next 
ad93				endm 
# End of macro NEXTW
ad93			.CONFIG: 
ad93				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ad93 6f				db WORD_SYS_CORE+91             
ad94 a4 ad			dw .ENDCORE            
ad96 07				db 6 + 1 
ad97 .. 00			db "CONFIG",0              
ad9e				endm 
# End of macro CWHEAD
ad9e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad9e			 
ad9e cd 02 93				call config 
ada1					NEXTW 
ada1 c3 c1 9e			jp macro_next 
ada4				endm 
# End of macro NEXTW
ada4			.ENDCORE: 
ada4			 
ada4			; eof 
ada4			 
ada4			 
# End of file forth_words_core.asm
ada4			include "forth_words_flow.asm" 
ada4			 
ada4			; | ## Program Flow Words 
ada4			 
ada4			.IF: 
ada4				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ada4 1e				db WORD_SYS_CORE+10             
ada5 99 ae			dw .THEN            
ada7 03				db 2 + 1 
ada8 .. 00			db "IF",0              
adab				endm 
# End of macro CWHEAD
adab			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
adab			; 
adab					if DEBUG_FORTH_WORDS_KEY 
adab						DMARK "IF." 
adab f5				push af  
adac 3a c0 ad			ld a, (.dmark)  
adaf 32 71 ee			ld (debug_mark),a  
adb2 3a c1 ad			ld a, (.dmark+1)  
adb5 32 72 ee			ld (debug_mark+1),a  
adb8 3a c2 ad			ld a, (.dmark+2)  
adbb 32 73 ee			ld (debug_mark+2),a  
adbe 18 03			jr .pastdmark  
adc0 ..			.dmark: db "IF."  
adc3 f1			.pastdmark: pop af  
adc4			endm  
# End of macro DMARK
adc4						CALLMONITOR 
adc4 cd a3 94			call break_point_state  
adc7				endm  
# End of macro CALLMONITOR
adc7					endif 
adc7			; eval TOS 
adc7			 
adc7				FORTH_DSP_VALUEHL 
adc7 cd 0b 9d			call macro_dsp_valuehl 
adca				endm 
# End of macro FORTH_DSP_VALUEHL
adca			 
adca			;	push hl 
adca				FORTH_DSP_POP 
adca cd c3 9d			call macro_forth_dsp_pop 
adcd				endm 
# End of macro FORTH_DSP_POP
adcd			;	pop hl 
adcd			 
adcd					if DEBUG_FORTH_WORDS 
adcd						DMARK "IF1" 
adcd f5				push af  
adce 3a e2 ad			ld a, (.dmark)  
add1 32 71 ee			ld (debug_mark),a  
add4 3a e3 ad			ld a, (.dmark+1)  
add7 32 72 ee			ld (debug_mark+1),a  
adda 3a e4 ad			ld a, (.dmark+2)  
addd 32 73 ee			ld (debug_mark+2),a  
ade0 18 03			jr .pastdmark  
ade2 ..			.dmark: db "IF1"  
ade5 f1			.pastdmark: pop af  
ade6			endm  
# End of macro DMARK
ade6						CALLMONITOR 
ade6 cd a3 94			call break_point_state  
ade9				endm  
# End of macro CALLMONITOR
ade9					endif 
ade9 b7				or a        ; clear carry flag 
adea 11 00 00			ld de, 0 
aded eb				ex de,hl 
adee ed 52			sbc hl, de 
adf0 c2 7a ae			jp nz, .iftrue 
adf3			 
adf3					if DEBUG_FORTH_WORDS 
adf3						DMARK "IF2" 
adf3 f5				push af  
adf4 3a 08 ae			ld a, (.dmark)  
adf7 32 71 ee			ld (debug_mark),a  
adfa 3a 09 ae			ld a, (.dmark+1)  
adfd 32 72 ee			ld (debug_mark+1),a  
ae00 3a 0a ae			ld a, (.dmark+2)  
ae03 32 73 ee			ld (debug_mark+2),a  
ae06 18 03			jr .pastdmark  
ae08 ..			.dmark: db "IF2"  
ae0b f1			.pastdmark: pop af  
ae0c			endm  
# End of macro DMARK
ae0c						CALLMONITOR 
ae0c cd a3 94			call break_point_state  
ae0f				endm  
# End of macro CALLMONITOR
ae0f					endif 
ae0f			 
ae0f			; if not true then skip to THEN 
ae0f			 
ae0f				; TODO get tok_ptr 
ae0f				; TODO consume toks until we get to THEN 
ae0f			 
ae0f 2a cc e5			ld hl, (os_tok_ptr) 
ae12					if DEBUG_FORTH_WORDS 
ae12						DMARK "IF3" 
ae12 f5				push af  
ae13 3a 27 ae			ld a, (.dmark)  
ae16 32 71 ee			ld (debug_mark),a  
ae19 3a 28 ae			ld a, (.dmark+1)  
ae1c 32 72 ee			ld (debug_mark+1),a  
ae1f 3a 29 ae			ld a, (.dmark+2)  
ae22 32 73 ee			ld (debug_mark+2),a  
ae25 18 03			jr .pastdmark  
ae27 ..			.dmark: db "IF3"  
ae2a f1			.pastdmark: pop af  
ae2b			endm  
# End of macro DMARK
ae2b						CALLMONITOR 
ae2b cd a3 94			call break_point_state  
ae2e				endm  
# End of macro CALLMONITOR
ae2e						 
ae2e					endif 
ae2e 11 75 ae			ld de, .ifthen 
ae31					if DEBUG_FORTH_WORDS 
ae31						DMARK "IF4" 
ae31 f5				push af  
ae32 3a 46 ae			ld a, (.dmark)  
ae35 32 71 ee			ld (debug_mark),a  
ae38 3a 47 ae			ld a, (.dmark+1)  
ae3b 32 72 ee			ld (debug_mark+1),a  
ae3e 3a 48 ae			ld a, (.dmark+2)  
ae41 32 73 ee			ld (debug_mark+2),a  
ae44 18 03			jr .pastdmark  
ae46 ..			.dmark: db "IF4"  
ae49 f1			.pastdmark: pop af  
ae4a			endm  
# End of macro DMARK
ae4a						CALLMONITOR 
ae4a cd a3 94			call break_point_state  
ae4d				endm  
# End of macro CALLMONITOR
ae4d					endif 
ae4d cd dc 9f			call findnexttok  
ae50			 
ae50					if DEBUG_FORTH_WORDS 
ae50						DMARK "IF5" 
ae50 f5				push af  
ae51 3a 65 ae			ld a, (.dmark)  
ae54 32 71 ee			ld (debug_mark),a  
ae57 3a 66 ae			ld a, (.dmark+1)  
ae5a 32 72 ee			ld (debug_mark+1),a  
ae5d 3a 67 ae			ld a, (.dmark+2)  
ae60 32 73 ee			ld (debug_mark+2),a  
ae63 18 03			jr .pastdmark  
ae65 ..			.dmark: db "IF5"  
ae68 f1			.pastdmark: pop af  
ae69			endm  
# End of macro DMARK
ae69						CALLMONITOR 
ae69 cd a3 94			call break_point_state  
ae6c				endm  
# End of macro CALLMONITOR
ae6c					endif 
ae6c				; TODO replace below with ; exec using tok_ptr 
ae6c 22 cc e5			ld (os_tok_ptr), hl 
ae6f c3 52 9f			jp exec1 
ae72				NEXTW 
ae72 c3 c1 9e			jp macro_next 
ae75				endm 
# End of macro NEXTW
ae75			 
ae75 .. 00		.ifthen:  db "THEN",0 
ae7a			 
ae7a			.iftrue:		 
ae7a				; Exec next words normally 
ae7a			 
ae7a				; if true then exec following IF as normal 
ae7a					if DEBUG_FORTH_WORDS 
ae7a						DMARK "IFT" 
ae7a f5				push af  
ae7b 3a 8f ae			ld a, (.dmark)  
ae7e 32 71 ee			ld (debug_mark),a  
ae81 3a 90 ae			ld a, (.dmark+1)  
ae84 32 72 ee			ld (debug_mark+1),a  
ae87 3a 91 ae			ld a, (.dmark+2)  
ae8a 32 73 ee			ld (debug_mark+2),a  
ae8d 18 03			jr .pastdmark  
ae8f ..			.dmark: db "IFT"  
ae92 f1			.pastdmark: pop af  
ae93			endm  
# End of macro DMARK
ae93						CALLMONITOR 
ae93 cd a3 94			call break_point_state  
ae96				endm  
# End of macro CALLMONITOR
ae96					endif 
ae96			 
ae96					NEXTW 
ae96 c3 c1 9e			jp macro_next 
ae99				endm 
# End of macro NEXTW
ae99			.THEN: 
ae99				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae99 1f				db WORD_SYS_CORE+11             
ae9a c1 ae			dw .ELSE            
ae9c 05				db 4 + 1 
ae9d .. 00			db "THEN",0              
aea2				endm 
# End of macro CWHEAD
aea2			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aea2					if DEBUG_FORTH_WORDS_KEY 
aea2						DMARK "THN" 
aea2 f5				push af  
aea3 3a b7 ae			ld a, (.dmark)  
aea6 32 71 ee			ld (debug_mark),a  
aea9 3a b8 ae			ld a, (.dmark+1)  
aeac 32 72 ee			ld (debug_mark+1),a  
aeaf 3a b9 ae			ld a, (.dmark+2)  
aeb2 32 73 ee			ld (debug_mark+2),a  
aeb5 18 03			jr .pastdmark  
aeb7 ..			.dmark: db "THN"  
aeba f1			.pastdmark: pop af  
aebb			endm  
# End of macro DMARK
aebb						CALLMONITOR 
aebb cd a3 94			call break_point_state  
aebe				endm  
# End of macro CALLMONITOR
aebe					endif 
aebe					NEXTW 
aebe c3 c1 9e			jp macro_next 
aec1				endm 
# End of macro NEXTW
aec1			.ELSE: 
aec1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
aec1 20				db WORD_SYS_CORE+12             
aec2 e9 ae			dw .DO            
aec4 03				db 2 + 1 
aec5 .. 00			db "ELSE",0              
aeca				endm 
# End of macro CWHEAD
aeca			; | ELSE ( -- ) Not supported - does nothing | TODO 
aeca			 
aeca					if DEBUG_FORTH_WORDS_KEY 
aeca						DMARK "ELS" 
aeca f5				push af  
aecb 3a df ae			ld a, (.dmark)  
aece 32 71 ee			ld (debug_mark),a  
aed1 3a e0 ae			ld a, (.dmark+1)  
aed4 32 72 ee			ld (debug_mark+1),a  
aed7 3a e1 ae			ld a, (.dmark+2)  
aeda 32 73 ee			ld (debug_mark+2),a  
aedd 18 03			jr .pastdmark  
aedf ..			.dmark: db "ELS"  
aee2 f1			.pastdmark: pop af  
aee3			endm  
# End of macro DMARK
aee3						CALLMONITOR 
aee3 cd a3 94			call break_point_state  
aee6				endm  
# End of macro CALLMONITOR
aee6					endif 
aee6			 
aee6			 
aee6					NEXTW 
aee6 c3 c1 9e			jp macro_next 
aee9				endm 
# End of macro NEXTW
aee9			.DO: 
aee9				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aee9 21				db WORD_SYS_CORE+13             
aeea 10 b0			dw .LOOP            
aeec 03				db 2 + 1 
aeed .. 00			db "DO",0              
aef0				endm 
# End of macro CWHEAD
aef0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aef0			 
aef0					if DEBUG_FORTH_WORDS_KEY 
aef0						DMARK "DO." 
aef0 f5				push af  
aef1 3a 05 af			ld a, (.dmark)  
aef4 32 71 ee			ld (debug_mark),a  
aef7 3a 06 af			ld a, (.dmark+1)  
aefa 32 72 ee			ld (debug_mark+1),a  
aefd 3a 07 af			ld a, (.dmark+2)  
af00 32 73 ee			ld (debug_mark+2),a  
af03 18 03			jr .pastdmark  
af05 ..			.dmark: db "DO."  
af08 f1			.pastdmark: pop af  
af09			endm  
# End of macro DMARK
af09						CALLMONITOR 
af09 cd a3 94			call break_point_state  
af0c				endm  
# End of macro CALLMONITOR
af0c					endif 
af0c			;  push pc to rsp stack past the DO 
af0c			 
af0c 2a cc e5				ld hl, (os_tok_ptr) 
af0f 23					inc hl   ; D 
af10 23					inc hl  ; O 
af11 23					inc hl   ; null 
af12					if DEBUG_FORTH_WORDS 
af12						DMARK "DO2" 
af12 f5				push af  
af13 3a 27 af			ld a, (.dmark)  
af16 32 71 ee			ld (debug_mark),a  
af19 3a 28 af			ld a, (.dmark+1)  
af1c 32 72 ee			ld (debug_mark+1),a  
af1f 3a 29 af			ld a, (.dmark+2)  
af22 32 73 ee			ld (debug_mark+2),a  
af25 18 03			jr .pastdmark  
af27 ..			.dmark: db "DO2"  
af2a f1			.pastdmark: pop af  
af2b			endm  
# End of macro DMARK
af2b						CALLMONITOR 
af2b cd a3 94			call break_point_state  
af2e				endm  
# End of macro CALLMONITOR
af2e					endif 
af2e					FORTH_RSP_NEXT 
af2e cd bb 9a			call macro_forth_rsp_next 
af31				endm 
# End of macro FORTH_RSP_NEXT
af31					if DEBUG_FORTH_WORDS 
af31						DMARK "DO3" 
af31 f5				push af  
af32 3a 46 af			ld a, (.dmark)  
af35 32 71 ee			ld (debug_mark),a  
af38 3a 47 af			ld a, (.dmark+1)  
af3b 32 72 ee			ld (debug_mark+1),a  
af3e 3a 48 af			ld a, (.dmark+2)  
af41 32 73 ee			ld (debug_mark+2),a  
af44 18 03			jr .pastdmark  
af46 ..			.dmark: db "DO3"  
af49 f1			.pastdmark: pop af  
af4a			endm  
# End of macro DMARK
af4a						CALLMONITOR 
af4a cd a3 94			call break_point_state  
af4d				endm  
# End of macro CALLMONITOR
af4d					endif 
af4d			 
af4d					;if DEBUG_FORTH_WORDS 
af4d				;		push hl 
af4d			;		endif  
af4d			 
af4d			; get counters from data stack 
af4d			 
af4d			 
af4d					FORTH_DSP_VALUEHL 
af4d cd 0b 9d			call macro_dsp_valuehl 
af50				endm 
# End of macro FORTH_DSP_VALUEHL
af50 e5					push hl		 ; hl now has starting counter which needs to be tos 
af51			 
af51					if DEBUG_FORTH_WORDS 
af51						DMARK "DO4" 
af51 f5				push af  
af52 3a 66 af			ld a, (.dmark)  
af55 32 71 ee			ld (debug_mark),a  
af58 3a 67 af			ld a, (.dmark+1)  
af5b 32 72 ee			ld (debug_mark+1),a  
af5e 3a 68 af			ld a, (.dmark+2)  
af61 32 73 ee			ld (debug_mark+2),a  
af64 18 03			jr .pastdmark  
af66 ..			.dmark: db "DO4"  
af69 f1			.pastdmark: pop af  
af6a			endm  
# End of macro DMARK
af6a						CALLMONITOR 
af6a cd a3 94			call break_point_state  
af6d				endm  
# End of macro CALLMONITOR
af6d					endif 
af6d					FORTH_DSP_POP 
af6d cd c3 9d			call macro_forth_dsp_pop 
af70				endm 
# End of macro FORTH_DSP_POP
af70			 
af70					if DEBUG_FORTH_WORDS 
af70						DMARK "DO5" 
af70 f5				push af  
af71 3a 85 af			ld a, (.dmark)  
af74 32 71 ee			ld (debug_mark),a  
af77 3a 86 af			ld a, (.dmark+1)  
af7a 32 72 ee			ld (debug_mark+1),a  
af7d 3a 87 af			ld a, (.dmark+2)  
af80 32 73 ee			ld (debug_mark+2),a  
af83 18 03			jr .pastdmark  
af85 ..			.dmark: db "DO5"  
af88 f1			.pastdmark: pop af  
af89			endm  
# End of macro DMARK
af89						CALLMONITOR 
af89 cd a3 94			call break_point_state  
af8c				endm  
# End of macro CALLMONITOR
af8c					endif 
af8c			 
af8c					FORTH_DSP_VALUEHL 
af8c cd 0b 9d			call macro_dsp_valuehl 
af8f				endm 
# End of macro FORTH_DSP_VALUEHL
af8f			;		push hl		 ; hl now has starting limit counter 
af8f			 
af8f					if DEBUG_FORTH_WORDS 
af8f						DMARK "DO6" 
af8f f5				push af  
af90 3a a4 af			ld a, (.dmark)  
af93 32 71 ee			ld (debug_mark),a  
af96 3a a5 af			ld a, (.dmark+1)  
af99 32 72 ee			ld (debug_mark+1),a  
af9c 3a a6 af			ld a, (.dmark+2)  
af9f 32 73 ee			ld (debug_mark+2),a  
afa2 18 03			jr .pastdmark  
afa4 ..			.dmark: db "DO6"  
afa7 f1			.pastdmark: pop af  
afa8			endm  
# End of macro DMARK
afa8						CALLMONITOR 
afa8 cd a3 94			call break_point_state  
afab				endm  
# End of macro CALLMONITOR
afab					endif 
afab					FORTH_DSP_POP 
afab cd c3 9d			call macro_forth_dsp_pop 
afae				endm 
# End of macro FORTH_DSP_POP
afae			 
afae			; put counters on the loop stack 
afae			 
afae			;		pop hl			 ; limit counter 
afae d1					pop de			; start counter 
afaf			 
afaf					; push limit counter 
afaf			 
afaf					if DEBUG_FORTH_WORDS 
afaf						DMARK "DO7" 
afaf f5				push af  
afb0 3a c4 af			ld a, (.dmark)  
afb3 32 71 ee			ld (debug_mark),a  
afb6 3a c5 af			ld a, (.dmark+1)  
afb9 32 72 ee			ld (debug_mark+1),a  
afbc 3a c6 af			ld a, (.dmark+2)  
afbf 32 73 ee			ld (debug_mark+2),a  
afc2 18 03			jr .pastdmark  
afc4 ..			.dmark: db "DO7"  
afc7 f1			.pastdmark: pop af  
afc8			endm  
# End of macro DMARK
afc8						CALLMONITOR 
afc8 cd a3 94			call break_point_state  
afcb				endm  
# End of macro CALLMONITOR
afcb					endif 
afcb					FORTH_LOOP_NEXT 
afcb cd 3c 9d			call macro_forth_loop_next 
afce				endm 
# End of macro FORTH_LOOP_NEXT
afce			 
afce					; push start counter 
afce			 
afce eb					ex de, hl 
afcf					if DEBUG_FORTH_WORDS 
afcf						DMARK "DO7" 
afcf f5				push af  
afd0 3a e4 af			ld a, (.dmark)  
afd3 32 71 ee			ld (debug_mark),a  
afd6 3a e5 af			ld a, (.dmark+1)  
afd9 32 72 ee			ld (debug_mark+1),a  
afdc 3a e6 af			ld a, (.dmark+2)  
afdf 32 73 ee			ld (debug_mark+2),a  
afe2 18 03			jr .pastdmark  
afe4 ..			.dmark: db "DO7"  
afe7 f1			.pastdmark: pop af  
afe8			endm  
# End of macro DMARK
afe8						CALLMONITOR 
afe8 cd a3 94			call break_point_state  
afeb				endm  
# End of macro CALLMONITOR
afeb					endif 
afeb					FORTH_LOOP_NEXT 
afeb cd 3c 9d			call macro_forth_loop_next 
afee				endm 
# End of macro FORTH_LOOP_NEXT
afee			 
afee			 
afee					; init first round of I counter 
afee			 
afee 22 f0 e5				ld (os_current_i), hl 
aff1			 
aff1					if DEBUG_FORTH_WORDS 
aff1						DMARK "DO8" 
aff1 f5				push af  
aff2 3a 06 b0			ld a, (.dmark)  
aff5 32 71 ee			ld (debug_mark),a  
aff8 3a 07 b0			ld a, (.dmark+1)  
affb 32 72 ee			ld (debug_mark+1),a  
affe 3a 08 b0			ld a, (.dmark+2)  
b001 32 73 ee			ld (debug_mark+2),a  
b004 18 03			jr .pastdmark  
b006 ..			.dmark: db "DO8"  
b009 f1			.pastdmark: pop af  
b00a			endm  
# End of macro DMARK
b00a						CALLMONITOR 
b00a cd a3 94			call break_point_state  
b00d				endm  
# End of macro CALLMONITOR
b00d					endif 
b00d			 
b00d					NEXTW 
b00d c3 c1 9e			jp macro_next 
b010				endm 
# End of macro NEXTW
b010			.LOOP: 
b010				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b010 22				db WORD_SYS_CORE+14             
b011 28 b1			dw .I            
b013 05				db 4 + 1 
b014 .. 00			db "LOOP",0              
b019				endm 
# End of macro CWHEAD
b019			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b019			 
b019				; pop tos as current loop count to hl 
b019			 
b019				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b019			 
b019				FORTH_LOOP_TOS 
b019 cd 6f 9d			call macro_forth_loop_tos 
b01c				endm 
# End of macro FORTH_LOOP_TOS
b01c e5				push hl 
b01d			 
b01d					if DEBUG_FORTH_WORDS_KEY 
b01d						DMARK "LOP" 
b01d f5				push af  
b01e 3a 32 b0			ld a, (.dmark)  
b021 32 71 ee			ld (debug_mark),a  
b024 3a 33 b0			ld a, (.dmark+1)  
b027 32 72 ee			ld (debug_mark+1),a  
b02a 3a 34 b0			ld a, (.dmark+2)  
b02d 32 73 ee			ld (debug_mark+2),a  
b030 18 03			jr .pastdmark  
b032 ..			.dmark: db "LOP"  
b035 f1			.pastdmark: pop af  
b036			endm  
# End of macro DMARK
b036						CALLMONITOR 
b036 cd a3 94			call break_point_state  
b039				endm  
# End of macro CALLMONITOR
b039					endif 
b039				; next item on the stack is the limit. get it 
b039			 
b039			 
b039				FORTH_LOOP_POP 
b039 cd 79 9d			call macro_forth_loop_pop 
b03c				endm 
# End of macro FORTH_LOOP_POP
b03c			 
b03c				FORTH_LOOP_TOS 
b03c cd 6f 9d			call macro_forth_loop_tos 
b03f				endm 
# End of macro FORTH_LOOP_TOS
b03f			 
b03f d1				pop de		 ; de = i, hl = limit 
b040			 
b040					if DEBUG_FORTH_WORDS 
b040						DMARK "LP1" 
b040 f5				push af  
b041 3a 55 b0			ld a, (.dmark)  
b044 32 71 ee			ld (debug_mark),a  
b047 3a 56 b0			ld a, (.dmark+1)  
b04a 32 72 ee			ld (debug_mark+1),a  
b04d 3a 57 b0			ld a, (.dmark+2)  
b050 32 73 ee			ld (debug_mark+2),a  
b053 18 03			jr .pastdmark  
b055 ..			.dmark: db "LP1"  
b058 f1			.pastdmark: pop af  
b059			endm  
# End of macro DMARK
b059						CALLMONITOR 
b059 cd a3 94			call break_point_state  
b05c				endm  
# End of macro CALLMONITOR
b05c					endif 
b05c			 
b05c				; go back to previous word 
b05c			 
b05c d5				push de    ; save I for inc later 
b05d			 
b05d			 
b05d				; get limit 
b05d				;  is I at limit? 
b05d			 
b05d			 
b05d					if DEBUG_FORTH_WORDS 
b05d						DMARK "LP1" 
b05d f5				push af  
b05e 3a 72 b0			ld a, (.dmark)  
b061 32 71 ee			ld (debug_mark),a  
b064 3a 73 b0			ld a, (.dmark+1)  
b067 32 72 ee			ld (debug_mark+1),a  
b06a 3a 74 b0			ld a, (.dmark+2)  
b06d 32 73 ee			ld (debug_mark+2),a  
b070 18 03			jr .pastdmark  
b072 ..			.dmark: db "LP1"  
b075 f1			.pastdmark: pop af  
b076			endm  
# End of macro DMARK
b076						CALLMONITOR 
b076 cd a3 94			call break_point_state  
b079				endm  
# End of macro CALLMONITOR
b079					endif 
b079			 
b079 ed 52			sbc hl, de 
b07b			 
b07b			 
b07b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b07b			 
b07b 20 26				jr nz, .loopnotdone 
b07d			 
b07d e1				pop hl   ; get rid of saved I 
b07e				FORTH_LOOP_POP     ; get rid of limit 
b07e cd 79 9d			call macro_forth_loop_pop 
b081				endm 
# End of macro FORTH_LOOP_POP
b081			 
b081				FORTH_RSP_POP     ; get rid of DO ptr 
b081 cd dc 9a			call macro_forth_rsp_pop 
b084				endm 
# End of macro FORTH_RSP_POP
b084			 
b084			if DEBUG_FORTH_WORDS 
b084						DMARK "LP>" 
b084 f5				push af  
b085 3a 99 b0			ld a, (.dmark)  
b088 32 71 ee			ld (debug_mark),a  
b08b 3a 9a b0			ld a, (.dmark+1)  
b08e 32 72 ee			ld (debug_mark+1),a  
b091 3a 9b b0			ld a, (.dmark+2)  
b094 32 73 ee			ld (debug_mark+2),a  
b097 18 03			jr .pastdmark  
b099 ..			.dmark: db "LP>"  
b09c f1			.pastdmark: pop af  
b09d			endm  
# End of macro DMARK
b09d				CALLMONITOR 
b09d cd a3 94			call break_point_state  
b0a0				endm  
# End of macro CALLMONITOR
b0a0			endif 
b0a0			 
b0a0					NEXTW 
b0a0 c3 c1 9e			jp macro_next 
b0a3				endm 
# End of macro NEXTW
b0a3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0a3			 
b0a3			.loopnotdone: 
b0a3			 
b0a3 e1				pop hl    ; get I 
b0a4 23				inc hl 
b0a5			 
b0a5			   	; save new I 
b0a5			 
b0a5			 
b0a5					; set I counter 
b0a5			 
b0a5 22 f0 e5				ld (os_current_i), hl 
b0a8			 
b0a8					if DEBUG_FORTH_WORDS 
b0a8						DMARK "LPN" 
b0a8 f5				push af  
b0a9 3a bd b0			ld a, (.dmark)  
b0ac 32 71 ee			ld (debug_mark),a  
b0af 3a be b0			ld a, (.dmark+1)  
b0b2 32 72 ee			ld (debug_mark+1),a  
b0b5 3a bf b0			ld a, (.dmark+2)  
b0b8 32 73 ee			ld (debug_mark+2),a  
b0bb 18 03			jr .pastdmark  
b0bd ..			.dmark: db "LPN"  
b0c0 f1			.pastdmark: pop af  
b0c1			endm  
# End of macro DMARK
b0c1					CALLMONITOR 
b0c1 cd a3 94			call break_point_state  
b0c4				endm  
# End of macro CALLMONITOR
b0c4					endif 
b0c4					 
b0c4				FORTH_LOOP_NEXT 
b0c4 cd 3c 9d			call macro_forth_loop_next 
b0c7				endm 
# End of macro FORTH_LOOP_NEXT
b0c7			 
b0c7			 
b0c7					if DEBUG_FORTH_WORDS 
b0c7 eb						ex de,hl 
b0c8					endif 
b0c8			 
b0c8			;	; get DO ptr 
b0c8			; 
b0c8					if DEBUG_FORTH_WORDS 
b0c8						DMARK "LP7" 
b0c8 f5				push af  
b0c9 3a dd b0			ld a, (.dmark)  
b0cc 32 71 ee			ld (debug_mark),a  
b0cf 3a de b0			ld a, (.dmark+1)  
b0d2 32 72 ee			ld (debug_mark+1),a  
b0d5 3a df b0			ld a, (.dmark+2)  
b0d8 32 73 ee			ld (debug_mark+2),a  
b0db 18 03			jr .pastdmark  
b0dd ..			.dmark: db "LP7"  
b0e0 f1			.pastdmark: pop af  
b0e1			endm  
# End of macro DMARK
b0e1					CALLMONITOR 
b0e1 cd a3 94			call break_point_state  
b0e4				endm  
# End of macro CALLMONITOR
b0e4					endif 
b0e4				FORTH_RSP_TOS 
b0e4 cd d2 9a			call macro_forth_rsp_tos 
b0e7				endm 
# End of macro FORTH_RSP_TOS
b0e7			 
b0e7					if DEBUG_FORTH_WORDS 
b0e7						DMARK "LP8" 
b0e7 f5				push af  
b0e8 3a fc b0			ld a, (.dmark)  
b0eb 32 71 ee			ld (debug_mark),a  
b0ee 3a fd b0			ld a, (.dmark+1)  
b0f1 32 72 ee			ld (debug_mark+1),a  
b0f4 3a fe b0			ld a, (.dmark+2)  
b0f7 32 73 ee			ld (debug_mark+2),a  
b0fa 18 03			jr .pastdmark  
b0fc ..			.dmark: db "LP8"  
b0ff f1			.pastdmark: pop af  
b100			endm  
# End of macro DMARK
b100					CALLMONITOR 
b100 cd a3 94			call break_point_state  
b103				endm  
# End of macro CALLMONITOR
b103					endif 
b103				;push hl 
b103			 
b103				; not going to DO any more 
b103				; get rid of the RSP pointer as DO will add it back in 
b103				;FORTH_RSP_POP 
b103				;pop hl 
b103			 
b103				;ld hl,(cli_ret_sp) 
b103				;ld e, (hl) 
b103				;inc hl 
b103				;ld d, (hl) 
b103				;ex de,hl 
b103 22 cc e5			ld (os_tok_ptr), hl 
b106					if DEBUG_FORTH_WORDS 
b106						DMARK "LP<" 
b106 f5				push af  
b107 3a 1b b1			ld a, (.dmark)  
b10a 32 71 ee			ld (debug_mark),a  
b10d 3a 1c b1			ld a, (.dmark+1)  
b110 32 72 ee			ld (debug_mark+1),a  
b113 3a 1d b1			ld a, (.dmark+2)  
b116 32 73 ee			ld (debug_mark+2),a  
b119 18 03			jr .pastdmark  
b11b ..			.dmark: db "LP<"  
b11e f1			.pastdmark: pop af  
b11f			endm  
# End of macro DMARK
b11f					CALLMONITOR 
b11f cd a3 94			call break_point_state  
b122				endm  
# End of macro CALLMONITOR
b122				endif 
b122 c3 52 9f			jp exec1 
b125			 
b125					 
b125			 
b125			 
b125					NEXTW 
b125 c3 c1 9e			jp macro_next 
b128				endm 
# End of macro NEXTW
b128			.I:  
b128			 
b128				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b128 5e				db WORD_SYS_CORE+74             
b129 53 b1			dw .DLOOP            
b12b 02				db 1 + 1 
b12c .. 00			db "I",0              
b12e				endm 
# End of macro CWHEAD
b12e			; | I ( -- ) Current loop counter | DONE 
b12e					if DEBUG_FORTH_WORDS_KEY 
b12e						DMARK "I.." 
b12e f5				push af  
b12f 3a 43 b1			ld a, (.dmark)  
b132 32 71 ee			ld (debug_mark),a  
b135 3a 44 b1			ld a, (.dmark+1)  
b138 32 72 ee			ld (debug_mark+1),a  
b13b 3a 45 b1			ld a, (.dmark+2)  
b13e 32 73 ee			ld (debug_mark+2),a  
b141 18 03			jr .pastdmark  
b143 ..			.dmark: db "I.."  
b146 f1			.pastdmark: pop af  
b147			endm  
# End of macro DMARK
b147						CALLMONITOR 
b147 cd a3 94			call break_point_state  
b14a				endm  
# End of macro CALLMONITOR
b14a					endif 
b14a			 
b14a 2a f0 e5				ld hl,(os_current_i) 
b14d cd 14 9b				call forth_push_numhl 
b150			 
b150					NEXTW 
b150 c3 c1 9e			jp macro_next 
b153				endm 
# End of macro NEXTW
b153			.DLOOP: 
b153				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b153 5f				db WORD_SYS_CORE+75             
b154 34 b2			dw .REPEAT            
b156 06				db 5 + 1 
b157 .. 00			db "-LOOP",0              
b15d				endm 
# End of macro CWHEAD
b15d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b15d				; pop tos as current loop count to hl 
b15d					if DEBUG_FORTH_WORDS_KEY 
b15d						DMARK "-LP" 
b15d f5				push af  
b15e 3a 72 b1			ld a, (.dmark)  
b161 32 71 ee			ld (debug_mark),a  
b164 3a 73 b1			ld a, (.dmark+1)  
b167 32 72 ee			ld (debug_mark+1),a  
b16a 3a 74 b1			ld a, (.dmark+2)  
b16d 32 73 ee			ld (debug_mark+2),a  
b170 18 03			jr .pastdmark  
b172 ..			.dmark: db "-LP"  
b175 f1			.pastdmark: pop af  
b176			endm  
# End of macro DMARK
b176						CALLMONITOR 
b176 cd a3 94			call break_point_state  
b179				endm  
# End of macro CALLMONITOR
b179					endif 
b179			 
b179				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b179			 
b179				FORTH_LOOP_TOS 
b179 cd 6f 9d			call macro_forth_loop_tos 
b17c				endm 
# End of macro FORTH_LOOP_TOS
b17c e5				push hl 
b17d			 
b17d					if DEBUG_FORTH_WORDS 
b17d						DMARK "-LP" 
b17d f5				push af  
b17e 3a 92 b1			ld a, (.dmark)  
b181 32 71 ee			ld (debug_mark),a  
b184 3a 93 b1			ld a, (.dmark+1)  
b187 32 72 ee			ld (debug_mark+1),a  
b18a 3a 94 b1			ld a, (.dmark+2)  
b18d 32 73 ee			ld (debug_mark+2),a  
b190 18 03			jr .pastdmark  
b192 ..			.dmark: db "-LP"  
b195 f1			.pastdmark: pop af  
b196			endm  
# End of macro DMARK
b196						CALLMONITOR 
b196 cd a3 94			call break_point_state  
b199				endm  
# End of macro CALLMONITOR
b199					endif 
b199				; next item on the stack is the limit. get it 
b199			 
b199			 
b199				FORTH_LOOP_POP 
b199 cd 79 9d			call macro_forth_loop_pop 
b19c				endm 
# End of macro FORTH_LOOP_POP
b19c			 
b19c				FORTH_LOOP_TOS 
b19c cd 6f 9d			call macro_forth_loop_tos 
b19f				endm 
# End of macro FORTH_LOOP_TOS
b19f			 
b19f d1				pop de		 ; de = i, hl = limit 
b1a0			 
b1a0					if DEBUG_FORTH_WORDS 
b1a0						DMARK "-L1" 
b1a0 f5				push af  
b1a1 3a b5 b1			ld a, (.dmark)  
b1a4 32 71 ee			ld (debug_mark),a  
b1a7 3a b6 b1			ld a, (.dmark+1)  
b1aa 32 72 ee			ld (debug_mark+1),a  
b1ad 3a b7 b1			ld a, (.dmark+2)  
b1b0 32 73 ee			ld (debug_mark+2),a  
b1b3 18 03			jr .pastdmark  
b1b5 ..			.dmark: db "-L1"  
b1b8 f1			.pastdmark: pop af  
b1b9			endm  
# End of macro DMARK
b1b9						CALLMONITOR 
b1b9 cd a3 94			call break_point_state  
b1bc				endm  
# End of macro CALLMONITOR
b1bc					endif 
b1bc			 
b1bc				; go back to previous word 
b1bc			 
b1bc d5				push de    ; save I for inc later 
b1bd			 
b1bd			 
b1bd				; get limit 
b1bd				;  is I at limit? 
b1bd			 
b1bd			 
b1bd					if DEBUG_FORTH_WORDS 
b1bd						DMARK "-L1" 
b1bd f5				push af  
b1be 3a d2 b1			ld a, (.dmark)  
b1c1 32 71 ee			ld (debug_mark),a  
b1c4 3a d3 b1			ld a, (.dmark+1)  
b1c7 32 72 ee			ld (debug_mark+1),a  
b1ca 3a d4 b1			ld a, (.dmark+2)  
b1cd 32 73 ee			ld (debug_mark+2),a  
b1d0 18 03			jr .pastdmark  
b1d2 ..			.dmark: db "-L1"  
b1d5 f1			.pastdmark: pop af  
b1d6			endm  
# End of macro DMARK
b1d6						CALLMONITOR 
b1d6 cd a3 94			call break_point_state  
b1d9				endm  
# End of macro CALLMONITOR
b1d9					endif 
b1d9			 
b1d9 ed 52			sbc hl, de 
b1db			 
b1db			 
b1db				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b1db			 
b1db 20 26				jr nz, .mloopnotdone 
b1dd			 
b1dd e1				pop hl   ; get rid of saved I 
b1de				FORTH_LOOP_POP     ; get rid of limit 
b1de cd 79 9d			call macro_forth_loop_pop 
b1e1				endm 
# End of macro FORTH_LOOP_POP
b1e1			 
b1e1				FORTH_RSP_POP     ; get rid of DO ptr 
b1e1 cd dc 9a			call macro_forth_rsp_pop 
b1e4				endm 
# End of macro FORTH_RSP_POP
b1e4			 
b1e4			if DEBUG_FORTH_WORDS 
b1e4						DMARK "-L>" 
b1e4 f5				push af  
b1e5 3a f9 b1			ld a, (.dmark)  
b1e8 32 71 ee			ld (debug_mark),a  
b1eb 3a fa b1			ld a, (.dmark+1)  
b1ee 32 72 ee			ld (debug_mark+1),a  
b1f1 3a fb b1			ld a, (.dmark+2)  
b1f4 32 73 ee			ld (debug_mark+2),a  
b1f7 18 03			jr .pastdmark  
b1f9 ..			.dmark: db "-L>"  
b1fc f1			.pastdmark: pop af  
b1fd			endm  
# End of macro DMARK
b1fd				CALLMONITOR 
b1fd cd a3 94			call break_point_state  
b200				endm  
# End of macro CALLMONITOR
b200			endif 
b200			 
b200					NEXTW 
b200 c3 c1 9e			jp macro_next 
b203				endm 
# End of macro NEXTW
b203				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b203			 
b203			.mloopnotdone: 
b203			 
b203 e1				pop hl    ; get I 
b204 2b				dec hl 
b205			 
b205			   	; save new I 
b205			 
b205			 
b205					; set I counter 
b205			 
b205 22 f0 e5				ld (os_current_i), hl 
b208			 
b208					 
b208				FORTH_LOOP_NEXT 
b208 cd 3c 9d			call macro_forth_loop_next 
b20b				endm 
# End of macro FORTH_LOOP_NEXT
b20b			 
b20b			 
b20b					if DEBUG_FORTH_WORDS 
b20b eb						ex de,hl 
b20c					endif 
b20c			 
b20c			;	; get DO ptr 
b20c			; 
b20c				FORTH_RSP_TOS 
b20c cd d2 9a			call macro_forth_rsp_tos 
b20f				endm 
# End of macro FORTH_RSP_TOS
b20f			 
b20f				;push hl 
b20f			 
b20f				; not going to DO any more 
b20f				; get rid of the RSP pointer as DO will add it back in 
b20f				;FORTH_RSP_POP 
b20f				;pop hl 
b20f			 
b20f			 
b20f 22 cc e5			ld (os_tok_ptr), hl 
b212					if DEBUG_FORTH_WORDS 
b212						DMARK "-L<" 
b212 f5				push af  
b213 3a 27 b2			ld a, (.dmark)  
b216 32 71 ee			ld (debug_mark),a  
b219 3a 28 b2			ld a, (.dmark+1)  
b21c 32 72 ee			ld (debug_mark+1),a  
b21f 3a 29 b2			ld a, (.dmark+2)  
b222 32 73 ee			ld (debug_mark+2),a  
b225 18 03			jr .pastdmark  
b227 ..			.dmark: db "-L<"  
b22a f1			.pastdmark: pop af  
b22b			endm  
# End of macro DMARK
b22b					CALLMONITOR 
b22b cd a3 94			call break_point_state  
b22e				endm  
# End of macro CALLMONITOR
b22e				endif 
b22e c3 52 9f			jp exec1 
b231			 
b231					 
b231			 
b231			 
b231			 
b231				NEXTW 
b231 c3 c1 9e			jp macro_next 
b234				endm 
# End of macro NEXTW
b234			 
b234			 
b234			 
b234			 
b234			.REPEAT: 
b234				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b234 71				db WORD_SYS_CORE+93             
b235 87 b2			dw .UNTIL            
b237 06				db 5 + 1 
b238 .. 00			db "REPEAT",0              
b23f				endm 
# End of macro CWHEAD
b23f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b23f			;  push pc to rsp stack past the REPEAT 
b23f					if DEBUG_FORTH_WORDS_KEY 
b23f						DMARK "REP" 
b23f f5				push af  
b240 3a 54 b2			ld a, (.dmark)  
b243 32 71 ee			ld (debug_mark),a  
b246 3a 55 b2			ld a, (.dmark+1)  
b249 32 72 ee			ld (debug_mark+1),a  
b24c 3a 56 b2			ld a, (.dmark+2)  
b24f 32 73 ee			ld (debug_mark+2),a  
b252 18 03			jr .pastdmark  
b254 ..			.dmark: db "REP"  
b257 f1			.pastdmark: pop af  
b258			endm  
# End of macro DMARK
b258						CALLMONITOR 
b258 cd a3 94			call break_point_state  
b25b				endm  
# End of macro CALLMONITOR
b25b					endif 
b25b			 
b25b 2a cc e5				ld hl, (os_tok_ptr) 
b25e 23					inc hl   ; R 
b25f 23					inc hl  ; E 
b260 23					inc hl   ; P 
b261 23					inc hl   ; E 
b262 23					inc hl   ; A 
b263 23					inc hl   ; T 
b264 23					inc hl   ; zero 
b265					FORTH_RSP_NEXT 
b265 cd bb 9a			call macro_forth_rsp_next 
b268				endm 
# End of macro FORTH_RSP_NEXT
b268			 
b268			 
b268					if DEBUG_FORTH_WORDS 
b268						DMARK "REP" 
b268 f5				push af  
b269 3a 7d b2			ld a, (.dmark)  
b26c 32 71 ee			ld (debug_mark),a  
b26f 3a 7e b2			ld a, (.dmark+1)  
b272 32 72 ee			ld (debug_mark+1),a  
b275 3a 7f b2			ld a, (.dmark+2)  
b278 32 73 ee			ld (debug_mark+2),a  
b27b 18 03			jr .pastdmark  
b27d ..			.dmark: db "REP"  
b280 f1			.pastdmark: pop af  
b281			endm  
# End of macro DMARK
b281						;pop bc    ; TODO BUG ?????? what is this for???? 
b281						CALLMONITOR 
b281 cd a3 94			call break_point_state  
b284				endm  
# End of macro CALLMONITOR
b284					endif 
b284			 
b284					NEXTW 
b284 c3 c1 9e			jp macro_next 
b287				endm 
# End of macro NEXTW
b287			;	       NEXTW 
b287			 
b287			.UNTIL: 
b287				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b287 72				db WORD_SYS_CORE+94             
b288 1e b3			dw .ENDFLOW            
b28a 06				db 5 + 1 
b28b .. 00			db "UNTIL",0              
b291				endm 
# End of macro CWHEAD
b291			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b291			 
b291				; pop tos as check 
b291			 
b291				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b291			 
b291				FORTH_DSP_VALUEHL 
b291 cd 0b 9d			call macro_dsp_valuehl 
b294				endm 
# End of macro FORTH_DSP_VALUEHL
b294			 
b294					if DEBUG_FORTH_WORDS_KEY 
b294						DMARK "UNT" 
b294 f5				push af  
b295 3a a9 b2			ld a, (.dmark)  
b298 32 71 ee			ld (debug_mark),a  
b29b 3a aa b2			ld a, (.dmark+1)  
b29e 32 72 ee			ld (debug_mark+1),a  
b2a1 3a ab b2			ld a, (.dmark+2)  
b2a4 32 73 ee			ld (debug_mark+2),a  
b2a7 18 03			jr .pastdmark  
b2a9 ..			.dmark: db "UNT"  
b2ac f1			.pastdmark: pop af  
b2ad			endm  
# End of macro DMARK
b2ad						CALLMONITOR 
b2ad cd a3 94			call break_point_state  
b2b0				endm  
# End of macro CALLMONITOR
b2b0					endif 
b2b0			 
b2b0			;	push hl 
b2b0				FORTH_DSP_POP 
b2b0 cd c3 9d			call macro_forth_dsp_pop 
b2b3				endm 
# End of macro FORTH_DSP_POP
b2b3			 
b2b3			;	pop hl 
b2b3			 
b2b3				; test if true 
b2b3			 
b2b3 cd cb 8c			call ishlzero 
b2b6			;	ld a,l 
b2b6			;	add h 
b2b6			; 
b2b6			;	cp 0 
b2b6			 
b2b6 20 3e			jr nz, .untilnotdone 
b2b8			 
b2b8					if DEBUG_FORTH_WORDS 
b2b8						DMARK "UNf" 
b2b8 f5				push af  
b2b9 3a cd b2			ld a, (.dmark)  
b2bc 32 71 ee			ld (debug_mark),a  
b2bf 3a ce b2			ld a, (.dmark+1)  
b2c2 32 72 ee			ld (debug_mark+1),a  
b2c5 3a cf b2			ld a, (.dmark+2)  
b2c8 32 73 ee			ld (debug_mark+2),a  
b2cb 18 03			jr .pastdmark  
b2cd ..			.dmark: db "UNf"  
b2d0 f1			.pastdmark: pop af  
b2d1			endm  
# End of macro DMARK
b2d1						CALLMONITOR 
b2d1 cd a3 94			call break_point_state  
b2d4				endm  
# End of macro CALLMONITOR
b2d4					endif 
b2d4			 
b2d4			 
b2d4			 
b2d4				FORTH_RSP_POP     ; get rid of DO ptr 
b2d4 cd dc 9a			call macro_forth_rsp_pop 
b2d7				endm 
# End of macro FORTH_RSP_POP
b2d7			 
b2d7			if DEBUG_FORTH_WORDS 
b2d7						DMARK "UN>" 
b2d7 f5				push af  
b2d8 3a ec b2			ld a, (.dmark)  
b2db 32 71 ee			ld (debug_mark),a  
b2de 3a ed b2			ld a, (.dmark+1)  
b2e1 32 72 ee			ld (debug_mark+1),a  
b2e4 3a ee b2			ld a, (.dmark+2)  
b2e7 32 73 ee			ld (debug_mark+2),a  
b2ea 18 03			jr .pastdmark  
b2ec ..			.dmark: db "UN>"  
b2ef f1			.pastdmark: pop af  
b2f0			endm  
# End of macro DMARK
b2f0				CALLMONITOR 
b2f0 cd a3 94			call break_point_state  
b2f3				endm  
# End of macro CALLMONITOR
b2f3			endif 
b2f3			 
b2f3					NEXTW 
b2f3 c3 c1 9e			jp macro_next 
b2f6				endm 
# End of macro NEXTW
b2f6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2f6			 
b2f6			.untilnotdone: 
b2f6			 
b2f6			 
b2f6			;	; get DO ptr 
b2f6			; 
b2f6				FORTH_RSP_TOS 
b2f6 cd d2 9a			call macro_forth_rsp_tos 
b2f9				endm 
# End of macro FORTH_RSP_TOS
b2f9			 
b2f9				;push hl 
b2f9			 
b2f9				; not going to DO any more 
b2f9				; get rid of the RSP pointer as DO will add it back in 
b2f9				;FORTH_RSP_POP 
b2f9				;pop hl 
b2f9			 
b2f9			 
b2f9 22 cc e5			ld (os_tok_ptr), hl 
b2fc					if DEBUG_FORTH_WORDS 
b2fc						DMARK "UN<" 
b2fc f5				push af  
b2fd 3a 11 b3			ld a, (.dmark)  
b300 32 71 ee			ld (debug_mark),a  
b303 3a 12 b3			ld a, (.dmark+1)  
b306 32 72 ee			ld (debug_mark+1),a  
b309 3a 13 b3			ld a, (.dmark+2)  
b30c 32 73 ee			ld (debug_mark+2),a  
b30f 18 03			jr .pastdmark  
b311 ..			.dmark: db "UN<"  
b314 f1			.pastdmark: pop af  
b315			endm  
# End of macro DMARK
b315					CALLMONITOR 
b315 cd a3 94			call break_point_state  
b318				endm  
# End of macro CALLMONITOR
b318				endif 
b318 c3 52 9f			jp exec1 
b31b			 
b31b					 
b31b			 
b31b			 
b31b					NEXTW 
b31b c3 c1 9e			jp macro_next 
b31e				endm 
# End of macro NEXTW
b31e			 
b31e			 
b31e			.ENDFLOW: 
b31e			 
b31e			; eof 
b31e			 
# End of file forth_words_flow.asm
b31e			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b31e			include "forth_words_logic.asm" 
b31e			 
b31e			; | ## Logic Words 
b31e			 
b31e			.NOT: 
b31e				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b31e 2d				db WORD_SYS_CORE+25             
b31f 66 b3			dw .IS            
b321 04				db 3 + 1 
b322 .. 00			db "NOT",0              
b326				endm 
# End of macro CWHEAD
b326			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b326					if DEBUG_FORTH_WORDS_KEY 
b326						DMARK "NOT" 
b326 f5				push af  
b327 3a 3b b3			ld a, (.dmark)  
b32a 32 71 ee			ld (debug_mark),a  
b32d 3a 3c b3			ld a, (.dmark+1)  
b330 32 72 ee			ld (debug_mark+1),a  
b333 3a 3d b3			ld a, (.dmark+2)  
b336 32 73 ee			ld (debug_mark+2),a  
b339 18 03			jr .pastdmark  
b33b ..			.dmark: db "NOT"  
b33e f1			.pastdmark: pop af  
b33f			endm  
# End of macro DMARK
b33f						CALLMONITOR 
b33f cd a3 94			call break_point_state  
b342				endm  
# End of macro CALLMONITOR
b342					endif 
b342					FORTH_DSP 
b342 cd d1 9c			call macro_forth_dsp 
b345				endm 
# End of macro FORTH_DSP
b345 7e					ld a,(hl)	; get type of value on TOS 
b346 fe 02				cp DS_TYPE_INUM  
b348 28 03				jr z, .noti 
b34a					NEXTW 
b34a c3 c1 9e			jp macro_next 
b34d				endm 
# End of macro NEXTW
b34d			.noti:          FORTH_DSP_VALUEHL 
b34d cd 0b 9d			call macro_dsp_valuehl 
b350				endm 
# End of macro FORTH_DSP_VALUEHL
b350			;		push hl 
b350					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b350 cd c3 9d			call macro_forth_dsp_pop 
b353				endm 
# End of macro FORTH_DSP_POP
b353			;		pop hl 
b353 3e 00				ld a,0 
b355 bd					cp l 
b356 28 04				jr z, .not2t 
b358 2e 00				ld l, 0 
b35a 18 02				jr .notip 
b35c			 
b35c 2e ff		.not2t:		ld l, 255 
b35e			 
b35e 26 00		.notip:		ld h, 0	 
b360			 
b360 cd 14 9b				call forth_push_numhl 
b363					NEXTW 
b363 c3 c1 9e			jp macro_next 
b366				endm 
# End of macro NEXTW
b366			 
b366			.IS: 
b366				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b366 2d				db WORD_SYS_CORE+25             
b367 8c b3			dw .LZERO            
b369 03				db 2 + 1 
b36a .. 00			db "IS",0              
b36d				endm 
# End of macro CWHEAD
b36d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b36d					if DEBUG_FORTH_WORDS_KEY 
b36d						DMARK "IS." 
b36d f5				push af  
b36e 3a 82 b3			ld a, (.dmark)  
b371 32 71 ee			ld (debug_mark),a  
b374 3a 83 b3			ld a, (.dmark+1)  
b377 32 72 ee			ld (debug_mark+1),a  
b37a 3a 84 b3			ld a, (.dmark+2)  
b37d 32 73 ee			ld (debug_mark+2),a  
b380 18 03			jr .pastdmark  
b382 ..			.dmark: db "IS."  
b385 f1			.pastdmark: pop af  
b386			endm  
# End of macro DMARK
b386						CALLMONITOR 
b386 cd a3 94			call break_point_state  
b389				endm  
# End of macro CALLMONITOR
b389					endif 
b389					NEXTW 
b389 c3 c1 9e			jp macro_next 
b38c				endm 
# End of macro NEXTW
b38c			.LZERO: 
b38c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b38c 2d				db WORD_SYS_CORE+25             
b38d 96 b3			dw .TZERO            
b38f 03				db 2 + 1 
b390 .. 00			db "0<",0              
b393				endm 
# End of macro CWHEAD
b393			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b393					NEXTW 
b393 c3 c1 9e			jp macro_next 
b396				endm 
# End of macro NEXTW
b396			.TZERO: 
b396				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b396 2e				db WORD_SYS_CORE+26             
b397 dd b3			dw .LESS            
b399 03				db 2 + 1 
b39a .. 00			db "0=",0              
b39d				endm 
# End of macro CWHEAD
b39d			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b39d				; TODO add floating point number detection 
b39d					;v5 FORTH_DSP_VALUE 
b39d					if DEBUG_FORTH_WORDS_KEY 
b39d						DMARK "0=." 
b39d f5				push af  
b39e 3a b2 b3			ld a, (.dmark)  
b3a1 32 71 ee			ld (debug_mark),a  
b3a4 3a b3 b3			ld a, (.dmark+1)  
b3a7 32 72 ee			ld (debug_mark+1),a  
b3aa 3a b4 b3			ld a, (.dmark+2)  
b3ad 32 73 ee			ld (debug_mark+2),a  
b3b0 18 03			jr .pastdmark  
b3b2 ..			.dmark: db "0=."  
b3b5 f1			.pastdmark: pop af  
b3b6			endm  
# End of macro DMARK
b3b6						CALLMONITOR 
b3b6 cd a3 94			call break_point_state  
b3b9				endm  
# End of macro CALLMONITOR
b3b9					endif 
b3b9					FORTH_DSP 
b3b9 cd d1 9c			call macro_forth_dsp 
b3bc				endm 
# End of macro FORTH_DSP
b3bc 7e					ld a,(hl)	; get type of value on TOS 
b3bd fe 02				cp DS_TYPE_INUM  
b3bf 28 00				jr z, .tz_inum 
b3c1			 
b3c1				if FORTH_ENABLE_FLOATMATH 
b3c1					jr .tz_done 
b3c1			 
b3c1				endif 
b3c1					 
b3c1			 
b3c1			.tz_inum: 
b3c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c1 cd 0b 9d			call macro_dsp_valuehl 
b3c4				endm 
# End of macro FORTH_DSP_VALUEHL
b3c4			 
b3c4			;		push hl 
b3c4			 
b3c4					; destroy value TOS 
b3c4			 
b3c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c4 cd c3 9d			call macro_forth_dsp_pop 
b3c7				endm 
# End of macro FORTH_DSP_POP
b3c7			 
b3c7			;		pop hl 
b3c7			 
b3c7 3e 00				ld a,0 
b3c9			 
b3c9 bd					cp l 
b3ca 20 08				jr nz, .tz_notzero 
b3cc			 
b3cc bc					cp h 
b3cd			 
b3cd 20 05				jr nz, .tz_notzero 
b3cf			 
b3cf			 
b3cf 21 01 00				ld hl, FORTH_TRUE 
b3d2 18 03				jr .tz_done 
b3d4			 
b3d4 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b3d7			 
b3d7					; push value back onto stack for another op etc 
b3d7			 
b3d7			.tz_done: 
b3d7 cd 14 9b				call forth_push_numhl 
b3da			 
b3da					NEXTW 
b3da c3 c1 9e			jp macro_next 
b3dd				endm 
# End of macro NEXTW
b3dd			.LESS: 
b3dd				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b3dd 2f				db WORD_SYS_CORE+27             
b3de 46 b4			dw .GT            
b3e0 02				db 1 + 1 
b3e1 .. 00			db "<",0              
b3e3				endm 
# End of macro CWHEAD
b3e3			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b3e3				; TODO add floating point number detection 
b3e3					if DEBUG_FORTH_WORDS_KEY 
b3e3						DMARK "LES" 
b3e3 f5				push af  
b3e4 3a f8 b3			ld a, (.dmark)  
b3e7 32 71 ee			ld (debug_mark),a  
b3ea 3a f9 b3			ld a, (.dmark+1)  
b3ed 32 72 ee			ld (debug_mark+1),a  
b3f0 3a fa b3			ld a, (.dmark+2)  
b3f3 32 73 ee			ld (debug_mark+2),a  
b3f6 18 03			jr .pastdmark  
b3f8 ..			.dmark: db "LES"  
b3fb f1			.pastdmark: pop af  
b3fc			endm  
# End of macro DMARK
b3fc						CALLMONITOR 
b3fc cd a3 94			call break_point_state  
b3ff				endm  
# End of macro CALLMONITOR
b3ff					endif 
b3ff					FORTH_DSP 
b3ff cd d1 9c			call macro_forth_dsp 
b402				endm 
# End of macro FORTH_DSP
b402					;v5 FORTH_DSP_VALUE 
b402 7e					ld a,(hl)	; get type of value on TOS 
b403 fe 02				cp DS_TYPE_INUM  
b405 28 00				jr z, .less_inum 
b407			 
b407				if FORTH_ENABLE_FLOATMATH 
b407					jr .less_done 
b407			 
b407				endif 
b407					 
b407			 
b407			.less_inum: 
b407					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b407 cd 0b 9d			call macro_dsp_valuehl 
b40a				endm 
# End of macro FORTH_DSP_VALUEHL
b40a			 
b40a e5					push hl  ; u2 
b40b			 
b40b					; destroy value TOS 
b40b			 
b40b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b40b cd c3 9d			call macro_forth_dsp_pop 
b40e				endm 
# End of macro FORTH_DSP_POP
b40e			 
b40e			 
b40e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b40e cd 0b 9d			call macro_dsp_valuehl 
b411				endm 
# End of macro FORTH_DSP_VALUEHL
b411			 
b411 e5					push hl    ; u1 
b412			 
b412					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b412 cd c3 9d			call macro_forth_dsp_pop 
b415				endm 
# End of macro FORTH_DSP_POP
b415			 
b415			 
b415 b7			 or a      ;clear carry flag 
b416 01 00 00		 ld bc, FORTH_FALSE 
b419 e1			  pop hl    ; u1 
b41a d1			  pop de    ; u2 
b41b ed 52		  sbc hl,de 
b41d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b41f			 
b41f 01 01 00		 ld bc, FORTH_TRUE 
b422			.lscont:  
b422 c5					push bc 
b423 e1					pop hl 
b424			 
b424					if DEBUG_FORTH_WORDS 
b424						DMARK "LT1" 
b424 f5				push af  
b425 3a 39 b4			ld a, (.dmark)  
b428 32 71 ee			ld (debug_mark),a  
b42b 3a 3a b4			ld a, (.dmark+1)  
b42e 32 72 ee			ld (debug_mark+1),a  
b431 3a 3b b4			ld a, (.dmark+2)  
b434 32 73 ee			ld (debug_mark+2),a  
b437 18 03			jr .pastdmark  
b439 ..			.dmark: db "LT1"  
b43c f1			.pastdmark: pop af  
b43d			endm  
# End of macro DMARK
b43d						CALLMONITOR 
b43d cd a3 94			call break_point_state  
b440				endm  
# End of macro CALLMONITOR
b440					endif 
b440 cd 14 9b				call forth_push_numhl 
b443			 
b443					NEXTW 
b443 c3 c1 9e			jp macro_next 
b446				endm 
# End of macro NEXTW
b446			.GT: 
b446				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b446 30				db WORD_SYS_CORE+28             
b447 af b4			dw .EQUAL            
b449 02				db 1 + 1 
b44a .. 00			db ">",0              
b44c				endm 
# End of macro CWHEAD
b44c			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b44c				; TODO add floating point number detection 
b44c					if DEBUG_FORTH_WORDS_KEY 
b44c						DMARK "GRT" 
b44c f5				push af  
b44d 3a 61 b4			ld a, (.dmark)  
b450 32 71 ee			ld (debug_mark),a  
b453 3a 62 b4			ld a, (.dmark+1)  
b456 32 72 ee			ld (debug_mark+1),a  
b459 3a 63 b4			ld a, (.dmark+2)  
b45c 32 73 ee			ld (debug_mark+2),a  
b45f 18 03			jr .pastdmark  
b461 ..			.dmark: db "GRT"  
b464 f1			.pastdmark: pop af  
b465			endm  
# End of macro DMARK
b465						CALLMONITOR 
b465 cd a3 94			call break_point_state  
b468				endm  
# End of macro CALLMONITOR
b468					endif 
b468					FORTH_DSP 
b468 cd d1 9c			call macro_forth_dsp 
b46b				endm 
# End of macro FORTH_DSP
b46b					;FORTH_DSP_VALUE 
b46b 7e					ld a,(hl)	; get type of value on TOS 
b46c fe 02				cp DS_TYPE_INUM  
b46e 28 00				jr z, .gt_inum 
b470			 
b470				if FORTH_ENABLE_FLOATMATH 
b470					jr .gt_done 
b470			 
b470				endif 
b470					 
b470			 
b470			.gt_inum: 
b470					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b470 cd 0b 9d			call macro_dsp_valuehl 
b473				endm 
# End of macro FORTH_DSP_VALUEHL
b473			 
b473 e5					push hl  ; u2 
b474			 
b474					; destroy value TOS 
b474			 
b474					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b474 cd c3 9d			call macro_forth_dsp_pop 
b477				endm 
# End of macro FORTH_DSP_POP
b477			 
b477			 
b477					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b477 cd 0b 9d			call macro_dsp_valuehl 
b47a				endm 
# End of macro FORTH_DSP_VALUEHL
b47a			 
b47a e5					push hl    ; u1 
b47b			 
b47b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b47b cd c3 9d			call macro_forth_dsp_pop 
b47e				endm 
# End of macro FORTH_DSP_POP
b47e			 
b47e			 
b47e b7			 or a      ;clear carry flag 
b47f 01 00 00		 ld bc, FORTH_FALSE 
b482 e1			  pop hl    ; u1 
b483 d1			  pop de    ; u2 
b484 ed 52		  sbc hl,de 
b486 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b488			 
b488 01 01 00		 ld bc, FORTH_TRUE 
b48b			.gtcont:  
b48b c5					push bc 
b48c e1					pop hl 
b48d			 
b48d					if DEBUG_FORTH_WORDS 
b48d						DMARK "GT1" 
b48d f5				push af  
b48e 3a a2 b4			ld a, (.dmark)  
b491 32 71 ee			ld (debug_mark),a  
b494 3a a3 b4			ld a, (.dmark+1)  
b497 32 72 ee			ld (debug_mark+1),a  
b49a 3a a4 b4			ld a, (.dmark+2)  
b49d 32 73 ee			ld (debug_mark+2),a  
b4a0 18 03			jr .pastdmark  
b4a2 ..			.dmark: db "GT1"  
b4a5 f1			.pastdmark: pop af  
b4a6			endm  
# End of macro DMARK
b4a6						CALLMONITOR 
b4a6 cd a3 94			call break_point_state  
b4a9				endm  
# End of macro CALLMONITOR
b4a9					endif 
b4a9 cd 14 9b				call forth_push_numhl 
b4ac			 
b4ac					NEXTW 
b4ac c3 c1 9e			jp macro_next 
b4af				endm 
# End of macro NEXTW
b4af			.EQUAL: 
b4af				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4af 31				db WORD_SYS_CORE+29             
b4b0 1a b5			dw .ENDLOGIC            
b4b2 02				db 1 + 1 
b4b3 .. 00			db "=",0              
b4b5				endm 
# End of macro CWHEAD
b4b5			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4b5				; TODO add floating point number detection 
b4b5					if DEBUG_FORTH_WORDS_KEY 
b4b5						DMARK "EQ." 
b4b5 f5				push af  
b4b6 3a ca b4			ld a, (.dmark)  
b4b9 32 71 ee			ld (debug_mark),a  
b4bc 3a cb b4			ld a, (.dmark+1)  
b4bf 32 72 ee			ld (debug_mark+1),a  
b4c2 3a cc b4			ld a, (.dmark+2)  
b4c5 32 73 ee			ld (debug_mark+2),a  
b4c8 18 03			jr .pastdmark  
b4ca ..			.dmark: db "EQ."  
b4cd f1			.pastdmark: pop af  
b4ce			endm  
# End of macro DMARK
b4ce						CALLMONITOR 
b4ce cd a3 94			call break_point_state  
b4d1				endm  
# End of macro CALLMONITOR
b4d1					endif 
b4d1					FORTH_DSP 
b4d1 cd d1 9c			call macro_forth_dsp 
b4d4				endm 
# End of macro FORTH_DSP
b4d4					;v5 FORTH_DSP_VALUE 
b4d4 7e					ld a,(hl)	; get type of value on TOS 
b4d5 fe 02				cp DS_TYPE_INUM  
b4d7 28 00				jr z, .eq_inum 
b4d9			 
b4d9				if FORTH_ENABLE_FLOATMATH 
b4d9					jr .eq_done 
b4d9			 
b4d9				endif 
b4d9					 
b4d9			 
b4d9			.eq_inum: 
b4d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d9 cd 0b 9d			call macro_dsp_valuehl 
b4dc				endm 
# End of macro FORTH_DSP_VALUEHL
b4dc			 
b4dc e5					push hl 
b4dd			 
b4dd					; destroy value TOS 
b4dd			 
b4dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4dd cd c3 9d			call macro_forth_dsp_pop 
b4e0				endm 
# End of macro FORTH_DSP_POP
b4e0			 
b4e0			 
b4e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4e0 cd 0b 9d			call macro_dsp_valuehl 
b4e3				endm 
# End of macro FORTH_DSP_VALUEHL
b4e3			 
b4e3					; one value on hl get other one back 
b4e3			 
b4e3 e5					push hl 
b4e4			 
b4e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4e4 cd c3 9d			call macro_forth_dsp_pop 
b4e7				endm 
# End of macro FORTH_DSP_POP
b4e7			 
b4e7 0e 00				ld c, FORTH_FALSE 
b4e9			 
b4e9 e1					pop hl 
b4ea d1					pop de 
b4eb			 
b4eb 7b					ld a, e 
b4ec bd					cp l 
b4ed			 
b4ed 20 06				jr nz, .eq_done 
b4ef			 
b4ef 7a					ld a, d 
b4f0 bc					cp h 
b4f1			 
b4f1 20 02				jr nz, .eq_done 
b4f3			 
b4f3 0e 01				ld c, FORTH_TRUE 
b4f5					 
b4f5			 
b4f5			 
b4f5			.eq_done: 
b4f5			 
b4f5					; TODO push value back onto stack for another op etc 
b4f5			 
b4f5 26 00				ld h, 0 
b4f7 69					ld l, c 
b4f8					if DEBUG_FORTH_WORDS 
b4f8						DMARK "EQ1" 
b4f8 f5				push af  
b4f9 3a 0d b5			ld a, (.dmark)  
b4fc 32 71 ee			ld (debug_mark),a  
b4ff 3a 0e b5			ld a, (.dmark+1)  
b502 32 72 ee			ld (debug_mark+1),a  
b505 3a 0f b5			ld a, (.dmark+2)  
b508 32 73 ee			ld (debug_mark+2),a  
b50b 18 03			jr .pastdmark  
b50d ..			.dmark: db "EQ1"  
b510 f1			.pastdmark: pop af  
b511			endm  
# End of macro DMARK
b511						CALLMONITOR 
b511 cd a3 94			call break_point_state  
b514				endm  
# End of macro CALLMONITOR
b514					endif 
b514 cd 14 9b				call forth_push_numhl 
b517			 
b517					NEXTW 
b517 c3 c1 9e			jp macro_next 
b51a				endm 
# End of macro NEXTW
b51a			 
b51a			 
b51a			.ENDLOGIC: 
b51a			; eof 
b51a			 
b51a			 
# End of file forth_words_logic.asm
b51a			include "forth_words_maths.asm" 
b51a			 
b51a			; | ## Maths Words 
b51a			 
b51a			.PLUS:	 
b51a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b51a 15				db WORD_SYS_CORE+1             
b51b 78 b5			dw .NEG            
b51d 02				db 1 + 1 
b51e .. 00			db "+",0              
b520				endm 
# End of macro CWHEAD
b520			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b520					if DEBUG_FORTH_WORDS_KEY 
b520						DMARK "PLU" 
b520 f5				push af  
b521 3a 35 b5			ld a, (.dmark)  
b524 32 71 ee			ld (debug_mark),a  
b527 3a 36 b5			ld a, (.dmark+1)  
b52a 32 72 ee			ld (debug_mark+1),a  
b52d 3a 37 b5			ld a, (.dmark+2)  
b530 32 73 ee			ld (debug_mark+2),a  
b533 18 03			jr .pastdmark  
b535 ..			.dmark: db "PLU"  
b538 f1			.pastdmark: pop af  
b539			endm  
# End of macro DMARK
b539						CALLMONITOR 
b539 cd a3 94			call break_point_state  
b53c				endm  
# End of macro CALLMONITOR
b53c					endif 
b53c					; add top two values and push back result 
b53c			 
b53c					;for v5 FORTH_DSP_VALUE 
b53c					FORTH_DSP 
b53c cd d1 9c			call macro_forth_dsp 
b53f				endm 
# End of macro FORTH_DSP
b53f 7e					ld a,(hl)	; get type of value on TOS 
b540 fe 02				cp DS_TYPE_INUM  
b542 28 03				jr z, .dot_inum 
b544			 
b544					NEXTW 
b544 c3 c1 9e			jp macro_next 
b547				endm 
# End of macro NEXTW
b547			 
b547			; float maths 
b547			 
b547				if FORTH_ENABLE_FLOATMATH 
b547						inc hl      ; now at start of numeric as string 
b547			 
b547					if DEBUG_FORTH_MATHS 
b547						DMARK "ADD" 
b547				CALLMONITOR 
b547					endif 
b547			 
b547					;ld ix, hl 
b547					call CON 
b547			 
b547			 
b547					push hl 
b547					 
b547					 
b547			 
b547						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b547			 
b547					; get next number 
b547			 
b547						FORTH_DSP_VALUE 
b547			 
b547						inc hl      ; now at start of numeric as string 
b547			 
b547					;ld ix, hl 
b547					call CON 
b547			 
b547					push hl 
b547			 
b547			 
b547						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b547			 
b547						; TODO do add 
b547			 
b547						call IADD 
b547			 
b547						; TODO get result back as ascii 
b547			 
b547						; TODO push result  
b547			 
b547			 
b547			 
b547						jr .dot_done 
b547				endif 
b547			 
b547			.dot_inum: 
b547			 
b547			 
b547					if DEBUG_FORTH_DOT 
b547						DMARK "+IT" 
b547 f5				push af  
b548 3a 5c b5			ld a, (.dmark)  
b54b 32 71 ee			ld (debug_mark),a  
b54e 3a 5d b5			ld a, (.dmark+1)  
b551 32 72 ee			ld (debug_mark+1),a  
b554 3a 5e b5			ld a, (.dmark+2)  
b557 32 73 ee			ld (debug_mark+2),a  
b55a 18 03			jr .pastdmark  
b55c ..			.dmark: db "+IT"  
b55f f1			.pastdmark: pop af  
b560			endm  
# End of macro DMARK
b560				CALLMONITOR 
b560 cd a3 94			call break_point_state  
b563				endm  
# End of macro CALLMONITOR
b563					endif 
b563			 
b563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b563 cd 0b 9d			call macro_dsp_valuehl 
b566				endm 
# End of macro FORTH_DSP_VALUEHL
b566			 
b566				; TODO add floating point number detection 
b566			 
b566 e5					push hl 
b567			 
b567					; destroy value TOS 
b567			 
b567					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b567 cd c3 9d			call macro_forth_dsp_pop 
b56a				endm 
# End of macro FORTH_DSP_POP
b56a			 
b56a			 
b56a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b56a cd 0b 9d			call macro_dsp_valuehl 
b56d				endm 
# End of macro FORTH_DSP_VALUEHL
b56d			 
b56d					; one value on hl get other one back 
b56d			 
b56d d1					pop de 
b56e			 
b56e					; do the add 
b56e			 
b56e 19					add hl,de 
b56f			 
b56f					; save it 
b56f			 
b56f			;		push hl	 
b56f			 
b56f					; 
b56f			 
b56f					; destroy value TOS 
b56f			 
b56f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b56f cd c3 9d			call macro_forth_dsp_pop 
b572				endm 
# End of macro FORTH_DSP_POP
b572			 
b572					; TODO push value back onto stack for another op etc 
b572			 
b572			;		pop hl 
b572			 
b572			.dot_done: 
b572 cd 14 9b				call forth_push_numhl 
b575			 
b575					NEXTW 
b575 c3 c1 9e			jp macro_next 
b578				endm 
# End of macro NEXTW
b578			.NEG: 
b578			 
b578				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b578 17				db WORD_SYS_CORE+3             
b579 bb b5			dw .DIV            
b57b 02				db 1 + 1 
b57c .. 00			db "-",0              
b57e				endm 
# End of macro CWHEAD
b57e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b57e					if DEBUG_FORTH_WORDS_KEY 
b57e						DMARK "SUB" 
b57e f5				push af  
b57f 3a 93 b5			ld a, (.dmark)  
b582 32 71 ee			ld (debug_mark),a  
b585 3a 94 b5			ld a, (.dmark+1)  
b588 32 72 ee			ld (debug_mark+1),a  
b58b 3a 95 b5			ld a, (.dmark+2)  
b58e 32 73 ee			ld (debug_mark+2),a  
b591 18 03			jr .pastdmark  
b593 ..			.dmark: db "SUB"  
b596 f1			.pastdmark: pop af  
b597			endm  
# End of macro DMARK
b597						CALLMONITOR 
b597 cd a3 94			call break_point_state  
b59a				endm  
# End of macro CALLMONITOR
b59a					endif 
b59a			 
b59a			 
b59a				; TODO add floating point number detection 
b59a					; v5 FORTH_DSP_VALUE 
b59a					FORTH_DSP 
b59a cd d1 9c			call macro_forth_dsp 
b59d				endm 
# End of macro FORTH_DSP
b59d 7e					ld a,(hl)	; get type of value on TOS 
b59e fe 02				cp DS_TYPE_INUM  
b5a0 28 03				jr z, .neg_inum 
b5a2			 
b5a2					NEXTW 
b5a2 c3 c1 9e			jp macro_next 
b5a5				endm 
# End of macro NEXTW
b5a5			 
b5a5			; float maths 
b5a5			 
b5a5				if FORTH_ENABLE_FLOATMATH 
b5a5					jr .neg_done 
b5a5			 
b5a5				endif 
b5a5					 
b5a5			 
b5a5			.neg_inum: 
b5a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a5 cd 0b 9d			call macro_dsp_valuehl 
b5a8				endm 
# End of macro FORTH_DSP_VALUEHL
b5a8			 
b5a8 e5					push hl 
b5a9			 
b5a9					; destroy value TOS 
b5a9			 
b5a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a9 cd c3 9d			call macro_forth_dsp_pop 
b5ac				endm 
# End of macro FORTH_DSP_POP
b5ac			 
b5ac			 
b5ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ac cd 0b 9d			call macro_dsp_valuehl 
b5af				endm 
# End of macro FORTH_DSP_VALUEHL
b5af			 
b5af					; one value on hl get other one back 
b5af			 
b5af d1					pop de 
b5b0			 
b5b0					; do the sub 
b5b0			;		ex de, hl 
b5b0			 
b5b0 ed 52				sbc hl,de 
b5b2			 
b5b2					; save it 
b5b2			 
b5b2			;		push hl	 
b5b2			 
b5b2					; 
b5b2			 
b5b2					; destroy value TOS 
b5b2			 
b5b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b2 cd c3 9d			call macro_forth_dsp_pop 
b5b5				endm 
# End of macro FORTH_DSP_POP
b5b5			 
b5b5					; TODO push value back onto stack for another op etc 
b5b5			 
b5b5			;		pop hl 
b5b5			 
b5b5 cd 14 9b				call forth_push_numhl 
b5b8			.neg_done: 
b5b8			 
b5b8					NEXTW 
b5b8 c3 c1 9e			jp macro_next 
b5bb				endm 
# End of macro NEXTW
b5bb			.DIV: 
b5bb				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5bb 18				db WORD_SYS_CORE+4             
b5bc 08 b6			dw .MUL            
b5be 02				db 1 + 1 
b5bf .. 00			db "/",0              
b5c1				endm 
# End of macro CWHEAD
b5c1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b5c1					if DEBUG_FORTH_WORDS_KEY 
b5c1						DMARK "DIV" 
b5c1 f5				push af  
b5c2 3a d6 b5			ld a, (.dmark)  
b5c5 32 71 ee			ld (debug_mark),a  
b5c8 3a d7 b5			ld a, (.dmark+1)  
b5cb 32 72 ee			ld (debug_mark+1),a  
b5ce 3a d8 b5			ld a, (.dmark+2)  
b5d1 32 73 ee			ld (debug_mark+2),a  
b5d4 18 03			jr .pastdmark  
b5d6 ..			.dmark: db "DIV"  
b5d9 f1			.pastdmark: pop af  
b5da			endm  
# End of macro DMARK
b5da						CALLMONITOR 
b5da cd a3 94			call break_point_state  
b5dd				endm  
# End of macro CALLMONITOR
b5dd					endif 
b5dd				; TODO add floating point number detection 
b5dd					; v5 FORTH_DSP_VALUE 
b5dd					FORTH_DSP 
b5dd cd d1 9c			call macro_forth_dsp 
b5e0				endm 
# End of macro FORTH_DSP
b5e0 7e					ld a,(hl)	; get type of value on TOS 
b5e1 fe 02				cp DS_TYPE_INUM  
b5e3 28 03				jr z, .div_inum 
b5e5			 
b5e5				if FORTH_ENABLE_FLOATMATH 
b5e5					jr .div_done 
b5e5			 
b5e5				endif 
b5e5					NEXTW 
b5e5 c3 c1 9e			jp macro_next 
b5e8				endm 
# End of macro NEXTW
b5e8			.div_inum: 
b5e8			 
b5e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e8 cd 0b 9d			call macro_dsp_valuehl 
b5eb				endm 
# End of macro FORTH_DSP_VALUEHL
b5eb			 
b5eb e5					push hl    ; to go to bc 
b5ec			 
b5ec					; destroy value TOS 
b5ec			 
b5ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ec cd c3 9d			call macro_forth_dsp_pop 
b5ef				endm 
# End of macro FORTH_DSP_POP
b5ef			 
b5ef			 
b5ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ef cd 0b 9d			call macro_dsp_valuehl 
b5f2				endm 
# End of macro FORTH_DSP_VALUEHL
b5f2			 
b5f2					; hl to go to de 
b5f2			 
b5f2 e5					push hl 
b5f3			 
b5f3 c1					pop bc 
b5f4 d1					pop de		 
b5f5			 
b5f5			 
b5f5					if DEBUG_FORTH_MATHS 
b5f5						DMARK "DIV" 
b5f5				CALLMONITOR 
b5f5					endif 
b5f5					; one value on hl but move to a get other one back 
b5f5			 
b5f5			        
b5f5 cd ff 8b			call Div16 
b5f8			 
b5f8			;	push af	 
b5f8 e5				push hl 
b5f9 c5				push bc 
b5fa			 
b5fa					if DEBUG_FORTH_MATHS 
b5fa						DMARK "DI1" 
b5fa				CALLMONITOR 
b5fa					endif 
b5fa			 
b5fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5fa cd c3 9d			call macro_forth_dsp_pop 
b5fd				endm 
# End of macro FORTH_DSP_POP
b5fd			 
b5fd			 
b5fd			 
b5fd e1					pop hl    ; result 
b5fe			 
b5fe cd 14 9b				call forth_push_numhl 
b601			 
b601 e1					pop hl    ; reminder 
b602			;		ld h,0 
b602			;		ld l,d 
b602			 
b602 cd 14 9b				call forth_push_numhl 
b605			.div_done: 
b605					NEXTW 
b605 c3 c1 9e			jp macro_next 
b608				endm 
# End of macro NEXTW
b608			.MUL: 
b608				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b608 19				db WORD_SYS_CORE+5             
b609 4d b6			dw .MIN            
b60b 02				db 1 + 1 
b60c .. 00			db "*",0              
b60e				endm 
# End of macro CWHEAD
b60e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b60e				; TODO add floating point number detection 
b60e					if DEBUG_FORTH_WORDS_KEY 
b60e						DMARK "MUL" 
b60e f5				push af  
b60f 3a 23 b6			ld a, (.dmark)  
b612 32 71 ee			ld (debug_mark),a  
b615 3a 24 b6			ld a, (.dmark+1)  
b618 32 72 ee			ld (debug_mark+1),a  
b61b 3a 25 b6			ld a, (.dmark+2)  
b61e 32 73 ee			ld (debug_mark+2),a  
b621 18 03			jr .pastdmark  
b623 ..			.dmark: db "MUL"  
b626 f1			.pastdmark: pop af  
b627			endm  
# End of macro DMARK
b627						CALLMONITOR 
b627 cd a3 94			call break_point_state  
b62a				endm  
# End of macro CALLMONITOR
b62a					endif 
b62a					FORTH_DSP 
b62a cd d1 9c			call macro_forth_dsp 
b62d				endm 
# End of macro FORTH_DSP
b62d					; v5 FORTH_DSP_VALUE 
b62d 7e					ld a,(hl)	; get type of value on TOS 
b62e fe 02				cp DS_TYPE_INUM  
b630 28 03				jr z, .mul_inum 
b632			 
b632				if FORTH_ENABLE_FLOATMATH 
b632					jr .mul_done 
b632			 
b632				endif 
b632			 
b632					NEXTW 
b632 c3 c1 9e			jp macro_next 
b635				endm 
# End of macro NEXTW
b635			.mul_inum:	 
b635			 
b635					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b635 cd 0b 9d			call macro_dsp_valuehl 
b638				endm 
# End of macro FORTH_DSP_VALUEHL
b638			 
b638 e5					push hl 
b639			 
b639					; destroy value TOS 
b639			 
b639					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b639 cd c3 9d			call macro_forth_dsp_pop 
b63c				endm 
# End of macro FORTH_DSP_POP
b63c			 
b63c			 
b63c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b63c cd 0b 9d			call macro_dsp_valuehl 
b63f				endm 
# End of macro FORTH_DSP_VALUEHL
b63f			 
b63f					; one value on hl but move to a get other one back 
b63f			 
b63f 7d					ld a, l 
b640			 
b640 d1					pop de 
b641			 
b641					; do the mull 
b641			;		ex de, hl 
b641			 
b641 cd 25 8c				call Mult16 
b644					; save it 
b644			 
b644			;		push hl	 
b644			 
b644					; 
b644			 
b644					; destroy value TOS 
b644			 
b644					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b644 cd c3 9d			call macro_forth_dsp_pop 
b647				endm 
# End of macro FORTH_DSP_POP
b647			 
b647					; TODO push value back onto stack for another op etc 
b647			 
b647			;		pop hl 
b647			 
b647 cd 14 9b				call forth_push_numhl 
b64a			 
b64a			.mul_done: 
b64a					NEXTW 
b64a c3 c1 9e			jp macro_next 
b64d				endm 
# End of macro NEXTW
b64d			 
b64d			 
b64d			 
b64d			 
b64d			.MIN: 
b64d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b64d 49				db WORD_SYS_CORE+53             
b64e ce b6			dw .MAX            
b650 04				db 3 + 1 
b651 .. 00			db "MIN",0              
b655				endm 
# End of macro CWHEAD
b655			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b655					if DEBUG_FORTH_WORDS_KEY 
b655						DMARK "MIN" 
b655 f5				push af  
b656 3a 6a b6			ld a, (.dmark)  
b659 32 71 ee			ld (debug_mark),a  
b65c 3a 6b b6			ld a, (.dmark+1)  
b65f 32 72 ee			ld (debug_mark+1),a  
b662 3a 6c b6			ld a, (.dmark+2)  
b665 32 73 ee			ld (debug_mark+2),a  
b668 18 03			jr .pastdmark  
b66a ..			.dmark: db "MIN"  
b66d f1			.pastdmark: pop af  
b66e			endm  
# End of macro DMARK
b66e						CALLMONITOR 
b66e cd a3 94			call break_point_state  
b671				endm  
# End of macro CALLMONITOR
b671					endif 
b671					; get u2 
b671			 
b671					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b671 cd 0b 9d			call macro_dsp_valuehl 
b674				endm 
# End of macro FORTH_DSP_VALUEHL
b674			 
b674 e5					push hl   ; u2 
b675			 
b675					; destroy value TOS 
b675			 
b675					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b675 cd c3 9d			call macro_forth_dsp_pop 
b678				endm 
# End of macro FORTH_DSP_POP
b678			 
b678					; get u1 
b678			 
b678					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b678 cd 0b 9d			call macro_dsp_valuehl 
b67b				endm 
# End of macro FORTH_DSP_VALUEHL
b67b			 
b67b e5					push hl  ; u1 
b67c			 
b67c					; destroy value TOS 
b67c			 
b67c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b67c cd c3 9d			call macro_forth_dsp_pop 
b67f				endm 
# End of macro FORTH_DSP_POP
b67f			 
b67f b7			 or a      ;clear carry flag 
b680 e1			  pop hl    ; u1 
b681 d1			  pop de    ; u2 
b682 e5				push hl   ; saved in case hl is lowest 
b683 ed 52		  sbc hl,de 
b685 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b687			 
b687 e1				pop hl 
b688					if DEBUG_FORTH_WORDS 
b688						DMARK "MIN" 
b688 f5				push af  
b689 3a 9d b6			ld a, (.dmark)  
b68c 32 71 ee			ld (debug_mark),a  
b68f 3a 9e b6			ld a, (.dmark+1)  
b692 32 72 ee			ld (debug_mark+1),a  
b695 3a 9f b6			ld a, (.dmark+2)  
b698 32 73 ee			ld (debug_mark+2),a  
b69b 18 03			jr .pastdmark  
b69d ..			.dmark: db "MIN"  
b6a0 f1			.pastdmark: pop af  
b6a1			endm  
# End of macro DMARK
b6a1						CALLMONITOR 
b6a1 cd a3 94			call break_point_state  
b6a4				endm  
# End of macro CALLMONITOR
b6a4					endif 
b6a4 cd 14 9b				call forth_push_numhl 
b6a7			 
b6a7				       NEXTW 
b6a7 c3 c1 9e			jp macro_next 
b6aa				endm 
# End of macro NEXTW
b6aa			 
b6aa			.mincont:  
b6aa c1				pop bc   ; tidy up 
b6ab eb				ex de , hl  
b6ac					if DEBUG_FORTH_WORDS 
b6ac						DMARK "MI1" 
b6ac f5				push af  
b6ad 3a c1 b6			ld a, (.dmark)  
b6b0 32 71 ee			ld (debug_mark),a  
b6b3 3a c2 b6			ld a, (.dmark+1)  
b6b6 32 72 ee			ld (debug_mark+1),a  
b6b9 3a c3 b6			ld a, (.dmark+2)  
b6bc 32 73 ee			ld (debug_mark+2),a  
b6bf 18 03			jr .pastdmark  
b6c1 ..			.dmark: db "MI1"  
b6c4 f1			.pastdmark: pop af  
b6c5			endm  
# End of macro DMARK
b6c5						CALLMONITOR 
b6c5 cd a3 94			call break_point_state  
b6c8				endm  
# End of macro CALLMONITOR
b6c8					endif 
b6c8 cd 14 9b				call forth_push_numhl 
b6cb			 
b6cb				       NEXTW 
b6cb c3 c1 9e			jp macro_next 
b6ce				endm 
# End of macro NEXTW
b6ce			.MAX: 
b6ce				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b6ce 4a				db WORD_SYS_CORE+54             
b6cf 4f b7			dw .RND16            
b6d1 04				db 3 + 1 
b6d2 .. 00			db "MAX",0              
b6d6				endm 
# End of macro CWHEAD
b6d6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b6d6					if DEBUG_FORTH_WORDS_KEY 
b6d6						DMARK "MAX" 
b6d6 f5				push af  
b6d7 3a eb b6			ld a, (.dmark)  
b6da 32 71 ee			ld (debug_mark),a  
b6dd 3a ec b6			ld a, (.dmark+1)  
b6e0 32 72 ee			ld (debug_mark+1),a  
b6e3 3a ed b6			ld a, (.dmark+2)  
b6e6 32 73 ee			ld (debug_mark+2),a  
b6e9 18 03			jr .pastdmark  
b6eb ..			.dmark: db "MAX"  
b6ee f1			.pastdmark: pop af  
b6ef			endm  
# End of macro DMARK
b6ef						CALLMONITOR 
b6ef cd a3 94			call break_point_state  
b6f2				endm  
# End of macro CALLMONITOR
b6f2					endif 
b6f2					; get u2 
b6f2			 
b6f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f2 cd 0b 9d			call macro_dsp_valuehl 
b6f5				endm 
# End of macro FORTH_DSP_VALUEHL
b6f5			 
b6f5 e5					push hl   ; u2 
b6f6			 
b6f6					; destroy value TOS 
b6f6			 
b6f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6f6 cd c3 9d			call macro_forth_dsp_pop 
b6f9				endm 
# End of macro FORTH_DSP_POP
b6f9			 
b6f9					; get u1 
b6f9			 
b6f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f9 cd 0b 9d			call macro_dsp_valuehl 
b6fc				endm 
# End of macro FORTH_DSP_VALUEHL
b6fc			 
b6fc e5					push hl  ; u1 
b6fd			 
b6fd					; destroy value TOS 
b6fd			 
b6fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fd cd c3 9d			call macro_forth_dsp_pop 
b700				endm 
# End of macro FORTH_DSP_POP
b700			 
b700 b7			 or a      ;clear carry flag 
b701 e1			  pop hl    ; u1 
b702 d1			  pop de    ; u2 
b703 e5				push hl   ; saved in case hl is lowest 
b704 ed 52		  sbc hl,de 
b706 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b708			 
b708 e1				pop hl 
b709					if DEBUG_FORTH_WORDS 
b709						DMARK "MAX" 
b709 f5				push af  
b70a 3a 1e b7			ld a, (.dmark)  
b70d 32 71 ee			ld (debug_mark),a  
b710 3a 1f b7			ld a, (.dmark+1)  
b713 32 72 ee			ld (debug_mark+1),a  
b716 3a 20 b7			ld a, (.dmark+2)  
b719 32 73 ee			ld (debug_mark+2),a  
b71c 18 03			jr .pastdmark  
b71e ..			.dmark: db "MAX"  
b721 f1			.pastdmark: pop af  
b722			endm  
# End of macro DMARK
b722						CALLMONITOR 
b722 cd a3 94			call break_point_state  
b725				endm  
# End of macro CALLMONITOR
b725					endif 
b725 cd 14 9b				call forth_push_numhl 
b728			 
b728				       NEXTW 
b728 c3 c1 9e			jp macro_next 
b72b				endm 
# End of macro NEXTW
b72b			 
b72b			.maxcont:  
b72b c1				pop bc   ; tidy up 
b72c eb				ex de , hl  
b72d					if DEBUG_FORTH_WORDS 
b72d						DMARK "MA1" 
b72d f5				push af  
b72e 3a 42 b7			ld a, (.dmark)  
b731 32 71 ee			ld (debug_mark),a  
b734 3a 43 b7			ld a, (.dmark+1)  
b737 32 72 ee			ld (debug_mark+1),a  
b73a 3a 44 b7			ld a, (.dmark+2)  
b73d 32 73 ee			ld (debug_mark+2),a  
b740 18 03			jr .pastdmark  
b742 ..			.dmark: db "MA1"  
b745 f1			.pastdmark: pop af  
b746			endm  
# End of macro DMARK
b746						CALLMONITOR 
b746 cd a3 94			call break_point_state  
b749				endm  
# End of macro CALLMONITOR
b749					endif 
b749 cd 14 9b				call forth_push_numhl 
b74c				       NEXTW 
b74c c3 c1 9e			jp macro_next 
b74f				endm 
# End of macro NEXTW
b74f			 
b74f			.RND16: 
b74f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b74f 4e				db WORD_SYS_CORE+58             
b750 7e b7			dw .RND8            
b752 06				db 5 + 1 
b753 .. 00			db "RND16",0              
b759				endm 
# End of macro CWHEAD
b759			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b759					if DEBUG_FORTH_WORDS_KEY 
b759						DMARK "R16" 
b759 f5				push af  
b75a 3a 6e b7			ld a, (.dmark)  
b75d 32 71 ee			ld (debug_mark),a  
b760 3a 6f b7			ld a, (.dmark+1)  
b763 32 72 ee			ld (debug_mark+1),a  
b766 3a 70 b7			ld a, (.dmark+2)  
b769 32 73 ee			ld (debug_mark+2),a  
b76c 18 03			jr .pastdmark  
b76e ..			.dmark: db "R16"  
b771 f1			.pastdmark: pop af  
b772			endm  
# End of macro DMARK
b772						CALLMONITOR 
b772 cd a3 94			call break_point_state  
b775				endm  
# End of macro CALLMONITOR
b775					endif 
b775 cd c9 8b				call prng16  
b778 cd 14 9b				call forth_push_numhl 
b77b				       NEXTW 
b77b c3 c1 9e			jp macro_next 
b77e				endm 
# End of macro NEXTW
b77e			.RND8: 
b77e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b77e 60				db WORD_SYS_CORE+76             
b77f b3 b7			dw .RND            
b781 05				db 4 + 1 
b782 .. 00			db "RND8",0              
b787				endm 
# End of macro CWHEAD
b787			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b787					if DEBUG_FORTH_WORDS_KEY 
b787						DMARK "RN8" 
b787 f5				push af  
b788 3a 9c b7			ld a, (.dmark)  
b78b 32 71 ee			ld (debug_mark),a  
b78e 3a 9d b7			ld a, (.dmark+1)  
b791 32 72 ee			ld (debug_mark+1),a  
b794 3a 9e b7			ld a, (.dmark+2)  
b797 32 73 ee			ld (debug_mark+2),a  
b79a 18 03			jr .pastdmark  
b79c ..			.dmark: db "RN8"  
b79f f1			.pastdmark: pop af  
b7a0			endm  
# End of macro DMARK
b7a0						CALLMONITOR 
b7a0 cd a3 94			call break_point_state  
b7a3				endm  
# End of macro CALLMONITOR
b7a3					endif 
b7a3 2a b2 eb				ld hl,(xrandc) 
b7a6 23					inc hl 
b7a7 cd e3 8b				call xrnd 
b7aa 6f					ld l,a	 
b7ab 26 00				ld h,0 
b7ad cd 14 9b				call forth_push_numhl 
b7b0				       NEXTW 
b7b0 c3 c1 9e			jp macro_next 
b7b3				endm 
# End of macro NEXTW
b7b3			.RND: 
b7b3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7b3 60				db WORD_SYS_CORE+76             
b7b4 b9 b8			dw .ENDMATHS            
b7b6 04				db 3 + 1 
b7b7 .. 00			db "RND",0              
b7bb				endm 
# End of macro CWHEAD
b7bb			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7bb			 
b7bb					if DEBUG_FORTH_WORDS_KEY 
b7bb						DMARK "RND" 
b7bb f5				push af  
b7bc 3a d0 b7			ld a, (.dmark)  
b7bf 32 71 ee			ld (debug_mark),a  
b7c2 3a d1 b7			ld a, (.dmark+1)  
b7c5 32 72 ee			ld (debug_mark+1),a  
b7c8 3a d2 b7			ld a, (.dmark+2)  
b7cb 32 73 ee			ld (debug_mark+2),a  
b7ce 18 03			jr .pastdmark  
b7d0 ..			.dmark: db "RND"  
b7d3 f1			.pastdmark: pop af  
b7d4			endm  
# End of macro DMARK
b7d4						CALLMONITOR 
b7d4 cd a3 94			call break_point_state  
b7d7				endm  
# End of macro CALLMONITOR
b7d7					endif 
b7d7					 
b7d7					FORTH_DSP_VALUEHL    ; upper range 
b7d7 cd 0b 9d			call macro_dsp_valuehl 
b7da				endm 
# End of macro FORTH_DSP_VALUEHL
b7da			 
b7da 22 b6 eb				ld (LFSRSeed), hl	 
b7dd			 
b7dd					if DEBUG_FORTH_WORDS 
b7dd						DMARK "RN1" 
b7dd f5				push af  
b7de 3a f2 b7			ld a, (.dmark)  
b7e1 32 71 ee			ld (debug_mark),a  
b7e4 3a f3 b7			ld a, (.dmark+1)  
b7e7 32 72 ee			ld (debug_mark+1),a  
b7ea 3a f4 b7			ld a, (.dmark+2)  
b7ed 32 73 ee			ld (debug_mark+2),a  
b7f0 18 03			jr .pastdmark  
b7f2 ..			.dmark: db "RN1"  
b7f5 f1			.pastdmark: pop af  
b7f6			endm  
# End of macro DMARK
b7f6						CALLMONITOR 
b7f6 cd a3 94			call break_point_state  
b7f9				endm  
# End of macro CALLMONITOR
b7f9					endif 
b7f9					FORTH_DSP_POP 
b7f9 cd c3 9d			call macro_forth_dsp_pop 
b7fc				endm 
# End of macro FORTH_DSP_POP
b7fc			 
b7fc					FORTH_DSP_VALUEHL    ; low range 
b7fc cd 0b 9d			call macro_dsp_valuehl 
b7ff				endm 
# End of macro FORTH_DSP_VALUEHL
b7ff			 
b7ff					if DEBUG_FORTH_WORDS 
b7ff						DMARK "RN2" 
b7ff f5				push af  
b800 3a 14 b8			ld a, (.dmark)  
b803 32 71 ee			ld (debug_mark),a  
b806 3a 15 b8			ld a, (.dmark+1)  
b809 32 72 ee			ld (debug_mark+1),a  
b80c 3a 16 b8			ld a, (.dmark+2)  
b80f 32 73 ee			ld (debug_mark+2),a  
b812 18 03			jr .pastdmark  
b814 ..			.dmark: db "RN2"  
b817 f1			.pastdmark: pop af  
b818			endm  
# End of macro DMARK
b818						CALLMONITOR 
b818 cd a3 94			call break_point_state  
b81b				endm  
# End of macro CALLMONITOR
b81b					endif 
b81b 22 b8 eb				ld (LFSRSeed+2), hl 
b81e			 
b81e					FORTH_DSP_POP 
b81e cd c3 9d			call macro_forth_dsp_pop 
b821				endm 
# End of macro FORTH_DSP_POP
b821			 
b821 e5					push hl 
b822			 
b822 e1			.inrange:	pop hl 
b823 cd c9 8b				call prng16  
b826					if DEBUG_FORTH_WORDS 
b826						DMARK "RN3" 
b826 f5				push af  
b827 3a 3b b8			ld a, (.dmark)  
b82a 32 71 ee			ld (debug_mark),a  
b82d 3a 3c b8			ld a, (.dmark+1)  
b830 32 72 ee			ld (debug_mark+1),a  
b833 3a 3d b8			ld a, (.dmark+2)  
b836 32 73 ee			ld (debug_mark+2),a  
b839 18 03			jr .pastdmark  
b83b ..			.dmark: db "RN3"  
b83e f1			.pastdmark: pop af  
b83f			endm  
# End of macro DMARK
b83f						CALLMONITOR 
b83f cd a3 94			call break_point_state  
b842				endm  
# End of macro CALLMONITOR
b842					endif 
b842					 
b842					; if the range is 8bit knock out the high byte 
b842			 
b842 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
b846			 
b846 3e 00				ld a, 0 
b848 ba					cp d  
b849 20 1e				jr nz, .hirange 
b84b 26 00				ld h, 0   ; knock it down to 8bit 
b84d			 
b84d					if DEBUG_FORTH_WORDS 
b84d						DMARK "RNk" 
b84d f5				push af  
b84e 3a 62 b8			ld a, (.dmark)  
b851 32 71 ee			ld (debug_mark),a  
b854 3a 63 b8			ld a, (.dmark+1)  
b857 32 72 ee			ld (debug_mark+1),a  
b85a 3a 64 b8			ld a, (.dmark+2)  
b85d 32 73 ee			ld (debug_mark+2),a  
b860 18 03			jr .pastdmark  
b862 ..			.dmark: db "RNk"  
b865 f1			.pastdmark: pop af  
b866			endm  
# End of macro DMARK
b866						CALLMONITOR 
b866 cd a3 94			call break_point_state  
b869				endm  
# End of macro CALLMONITOR
b869					endif 
b869			.hirange:   
b869 e5					push hl  
b86a b7					or a  
b86b ed 52		                sbc hl, de 
b86d			 
b86d					;call cmp16 
b86d			 
b86d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b86f e1					pop hl 
b870 e5					push hl 
b871			 
b871					if DEBUG_FORTH_WORDS 
b871						DMARK "RN4" 
b871 f5				push af  
b872 3a 86 b8			ld a, (.dmark)  
b875 32 71 ee			ld (debug_mark),a  
b878 3a 87 b8			ld a, (.dmark+1)  
b87b 32 72 ee			ld (debug_mark+1),a  
b87e 3a 88 b8			ld a, (.dmark+2)  
b881 32 73 ee			ld (debug_mark+2),a  
b884 18 03			jr .pastdmark  
b886 ..			.dmark: db "RN4"  
b889 f1			.pastdmark: pop af  
b88a			endm  
# End of macro DMARK
b88a						CALLMONITOR 
b88a cd a3 94			call break_point_state  
b88d				endm  
# End of macro CALLMONITOR
b88d					endif 
b88d ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
b891					;call cmp16 
b891				 
b891 b7					or a  
b892 ed 52		                sbc hl, de 
b894 38 8c				jr c, .inrange 
b896			 
b896 e1					pop hl 
b897					 
b897					if DEBUG_FORTH_WORDS 
b897						DMARK "RNd" 
b897 f5				push af  
b898 3a ac b8			ld a, (.dmark)  
b89b 32 71 ee			ld (debug_mark),a  
b89e 3a ad b8			ld a, (.dmark+1)  
b8a1 32 72 ee			ld (debug_mark+1),a  
b8a4 3a ae b8			ld a, (.dmark+2)  
b8a7 32 73 ee			ld (debug_mark+2),a  
b8aa 18 03			jr .pastdmark  
b8ac ..			.dmark: db "RNd"  
b8af f1			.pastdmark: pop af  
b8b0			endm  
# End of macro DMARK
b8b0						CALLMONITOR 
b8b0 cd a3 94			call break_point_state  
b8b3				endm  
# End of macro CALLMONITOR
b8b3					endif 
b8b3			 
b8b3			 
b8b3 cd 14 9b				call forth_push_numhl 
b8b6				       NEXTW 
b8b6 c3 c1 9e			jp macro_next 
b8b9				endm 
# End of macro NEXTW
b8b9			 
b8b9			.ENDMATHS: 
b8b9			 
b8b9			; eof 
b8b9			 
# End of file forth_words_maths.asm
b8b9			include "forth_words_display.asm" 
b8b9			 
b8b9			; | ## Display Words 
b8b9			 
b8b9			.INFO: 
b8b9			 
b8b9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b8b9 62				db WORD_SYS_CORE+78             
b8ba d6 b8			dw .ATP            
b8bc 05				db 4 + 1 
b8bd .. 00			db "INFO",0              
b8c2				endm 
# End of macro CWHEAD
b8c2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b8c2					FORTH_DSP_VALUEHL 
b8c2 cd 0b 9d			call macro_dsp_valuehl 
b8c5				endm 
# End of macro FORTH_DSP_VALUEHL
b8c5			 
b8c5					FORTH_DSP_POP 
b8c5 cd c3 9d			call macro_forth_dsp_pop 
b8c8				endm 
# End of macro FORTH_DSP_POP
b8c8			 
b8c8 e5					push hl 
b8c9			 
b8c9					FORTH_DSP_VALUEHL 
b8c9 cd 0b 9d			call macro_dsp_valuehl 
b8cc				endm 
# End of macro FORTH_DSP_VALUEHL
b8cc			 
b8cc					FORTH_DSP_POP 
b8cc cd c3 9d			call macro_forth_dsp_pop 
b8cf				endm 
# End of macro FORTH_DSP_POP
b8cf			 
b8cf d1					pop de 
b8d0			 
b8d0 cd 06 8a				call info_panel 
b8d3			 
b8d3			 
b8d3					NEXTW 
b8d3 c3 c1 9e			jp macro_next 
b8d6				endm 
# End of macro NEXTW
b8d6			.ATP: 
b8d6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b8d6 62				db WORD_SYS_CORE+78             
b8d7 4d b9			dw .FB            
b8d9 04				db 3 + 1 
b8da .. 00			db "AT?",0              
b8de				endm 
# End of macro CWHEAD
b8de			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b8de					if DEBUG_FORTH_WORDS_KEY 
b8de						DMARK "AT?" 
b8de f5				push af  
b8df 3a f3 b8			ld a, (.dmark)  
b8e2 32 71 ee			ld (debug_mark),a  
b8e5 3a f4 b8			ld a, (.dmark+1)  
b8e8 32 72 ee			ld (debug_mark+1),a  
b8eb 3a f5 b8			ld a, (.dmark+2)  
b8ee 32 73 ee			ld (debug_mark+2),a  
b8f1 18 03			jr .pastdmark  
b8f3 ..			.dmark: db "AT?"  
b8f6 f1			.pastdmark: pop af  
b8f7			endm  
# End of macro DMARK
b8f7						CALLMONITOR 
b8f7 cd a3 94			call break_point_state  
b8fa				endm  
# End of macro CALLMONITOR
b8fa					endif 
b8fa 3a 68 ea				ld a, (f_cursor_ptr) 
b8fd			 
b8fd			if DEBUG_FORTH_WORDS 
b8fd				DMARK "AT?" 
b8fd f5				push af  
b8fe 3a 12 b9			ld a, (.dmark)  
b901 32 71 ee			ld (debug_mark),a  
b904 3a 13 b9			ld a, (.dmark+1)  
b907 32 72 ee			ld (debug_mark+1),a  
b90a 3a 14 b9			ld a, (.dmark+2)  
b90d 32 73 ee			ld (debug_mark+2),a  
b910 18 03			jr .pastdmark  
b912 ..			.dmark: db "AT?"  
b915 f1			.pastdmark: pop af  
b916			endm  
# End of macro DMARK
b916				CALLMONITOR 
b916 cd a3 94			call break_point_state  
b919				endm  
# End of macro CALLMONITOR
b919			endif	 
b919					; count the number of rows 
b919			 
b919 06 00				ld b, 0 
b91b 4f			.atpr:		ld c, a    ; save in case we go below zero 
b91c d6 28				sub display_cols 
b91e f2 24 b9				jp p, .atprunder 
b921 04					inc b 
b922 18 f7				jr .atpr 
b924			.atprunder:	 
b924			if DEBUG_FORTH_WORDS 
b924				DMARK "A?2" 
b924 f5				push af  
b925 3a 39 b9			ld a, (.dmark)  
b928 32 71 ee			ld (debug_mark),a  
b92b 3a 3a b9			ld a, (.dmark+1)  
b92e 32 72 ee			ld (debug_mark+1),a  
b931 3a 3b b9			ld a, (.dmark+2)  
b934 32 73 ee			ld (debug_mark+2),a  
b937 18 03			jr .pastdmark  
b939 ..			.dmark: db "A?2"  
b93c f1			.pastdmark: pop af  
b93d			endm  
# End of macro DMARK
b93d				CALLMONITOR 
b93d cd a3 94			call break_point_state  
b940				endm  
# End of macro CALLMONITOR
b940			endif	 
b940 26 00				ld h, 0 
b942 69					ld l, c 
b943 cd 14 9b				call forth_push_numhl 
b946 68					ld l, b  
b947 cd 14 9b				call forth_push_numhl 
b94a			 
b94a			 
b94a				NEXTW 
b94a c3 c1 9e			jp macro_next 
b94d				endm 
# End of macro NEXTW
b94d			 
b94d			.FB: 
b94d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b94d 1b				db WORD_SYS_CORE+7             
b94e 9b b9			dw .EMIT            
b950 03				db 2 + 1 
b951 .. 00			db "FB",0              
b954				endm 
# End of macro CWHEAD
b954			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b954			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b954			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b954			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b954					if DEBUG_FORTH_WORDS_KEY 
b954						DMARK "FB." 
b954 f5				push af  
b955 3a 69 b9			ld a, (.dmark)  
b958 32 71 ee			ld (debug_mark),a  
b95b 3a 6a b9			ld a, (.dmark+1)  
b95e 32 72 ee			ld (debug_mark+1),a  
b961 3a 6b b9			ld a, (.dmark+2)  
b964 32 73 ee			ld (debug_mark+2),a  
b967 18 03			jr .pastdmark  
b969 ..			.dmark: db "FB."  
b96c f1			.pastdmark: pop af  
b96d			endm  
# End of macro DMARK
b96d						CALLMONITOR 
b96d cd a3 94			call break_point_state  
b970				endm  
# End of macro CALLMONITOR
b970					endif 
b970			 
b970					FORTH_DSP_VALUEHL 
b970 cd 0b 9d			call macro_dsp_valuehl 
b973				endm 
# End of macro FORTH_DSP_VALUEHL
b973			 
b973 7d					ld a, l 
b974 fe 01				cp 1 
b976 20 05				jr nz, .fbn1 
b978 21 16 ed				ld hl, display_fb1 
b97b 18 15				jr .fbset 
b97d fe 02		.fbn1:		cp 2 
b97f 20 05				jr nz, .fbn2 
b981 21 d4 eb				ld hl, display_fb2 
b984 18 0c				jr .fbset 
b986 fe 03		.fbn2:		cp 3 
b988 20 05				jr nz, .fbn3 
b98a 21 75 ec				ld hl, display_fb3 
b98d 18 03				jr .fbset 
b98f			.fbn3:		 ; if invalid number select first 
b98f 21 16 ed				ld hl, display_fb1 
b992 22 d2 eb		.fbset:		ld (display_fb_active), hl 
b995			 
b995					FORTH_DSP_POP 
b995 cd c3 9d			call macro_forth_dsp_pop 
b998				endm 
# End of macro FORTH_DSP_POP
b998			 
b998					NEXTW 
b998 c3 c1 9e			jp macro_next 
b99b				endm 
# End of macro NEXTW
b99b			 
b99b			 
b99b			.EMIT: 
b99b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b99b 1b				db WORD_SYS_CORE+7             
b99c ec b9			dw .DOTH            
b99e 05				db 4 + 1 
b99f .. 00			db "EMIT",0              
b9a4				endm 
# End of macro CWHEAD
b9a4			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b9a4					; get value off TOS and display it 
b9a4			 
b9a4					if DEBUG_FORTH_WORDS_KEY 
b9a4						DMARK "EMT" 
b9a4 f5				push af  
b9a5 3a b9 b9			ld a, (.dmark)  
b9a8 32 71 ee			ld (debug_mark),a  
b9ab 3a ba b9			ld a, (.dmark+1)  
b9ae 32 72 ee			ld (debug_mark+1),a  
b9b1 3a bb b9			ld a, (.dmark+2)  
b9b4 32 73 ee			ld (debug_mark+2),a  
b9b7 18 03			jr .pastdmark  
b9b9 ..			.dmark: db "EMT"  
b9bc f1			.pastdmark: pop af  
b9bd			endm  
# End of macro DMARK
b9bd						CALLMONITOR 
b9bd cd a3 94			call break_point_state  
b9c0				endm  
# End of macro CALLMONITOR
b9c0					endif 
b9c0			 
b9c0					FORTH_DSP_VALUEHL 
b9c0 cd 0b 9d			call macro_dsp_valuehl 
b9c3				endm 
# End of macro FORTH_DSP_VALUEHL
b9c3			 
b9c3 7d					ld a,l 
b9c4			 
b9c4					; TODO write to display 
b9c4			 
b9c4 32 c9 e4				ld (os_input), a 
b9c7 3e 00				ld a, 0 
b9c9 32 ca e4				ld (os_input+1), a 
b9cc					 
b9cc 3a 68 ea				ld a, (f_cursor_ptr) 
b9cf 11 c9 e4				ld de, os_input 
b9d2 cd 88 8a				call str_at_display 
b9d5			 
b9d5			 
b9d5 3a 46 ea				ld a,(cli_autodisplay) 
b9d8 fe 00				cp 0 
b9da 28 03				jr z, .enoupdate 
b9dc cd 98 8a						call update_display 
b9df					.enoupdate: 
b9df			 
b9df 3a 68 ea				ld a, (f_cursor_ptr) 
b9e2 3c					inc a 
b9e3 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
b9e6			 
b9e6			 
b9e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9e6 cd c3 9d			call macro_forth_dsp_pop 
b9e9				endm 
# End of macro FORTH_DSP_POP
b9e9			  
b9e9			 
b9e9					NEXTW 
b9e9 c3 c1 9e			jp macro_next 
b9ec				endm 
# End of macro NEXTW
b9ec			.DOTH: 
b9ec				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b9ec 1c				db WORD_SYS_CORE+8             
b9ed 1c ba			dw .DOTF            
b9ef 03				db 2 + 1 
b9f0 .. 00			db ".-",0              
b9f3				endm 
# End of macro CWHEAD
b9f3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b9f3					; get value off TOS and display it 
b9f3					if DEBUG_FORTH_WORDS_KEY 
b9f3						DMARK "DTD" 
b9f3 f5				push af  
b9f4 3a 08 ba			ld a, (.dmark)  
b9f7 32 71 ee			ld (debug_mark),a  
b9fa 3a 09 ba			ld a, (.dmark+1)  
b9fd 32 72 ee			ld (debug_mark+1),a  
ba00 3a 0a ba			ld a, (.dmark+2)  
ba03 32 73 ee			ld (debug_mark+2),a  
ba06 18 03			jr .pastdmark  
ba08 ..			.dmark: db "DTD"  
ba0b f1			.pastdmark: pop af  
ba0c			endm  
# End of macro DMARK
ba0c						CALLMONITOR 
ba0c cd a3 94			call break_point_state  
ba0f				endm  
# End of macro CALLMONITOR
ba0f					endif 
ba0f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba11 3e 00			ld a, 0 
ba13 32 47 ea			ld (cli_mvdot), a 
ba16 c3 73 ba			jp .dotgo 
ba19				NEXTW 
ba19 c3 c1 9e			jp macro_next 
ba1c				endm 
# End of macro NEXTW
ba1c			.DOTF: 
ba1c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
ba1c 1c				db WORD_SYS_CORE+8             
ba1d 4a ba			dw .DOT            
ba1f 03				db 2 + 1 
ba20 .. 00			db ".>",0              
ba23				endm 
# End of macro CWHEAD
ba23			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
ba23					; get value off TOS and display it 
ba23			        ; TODO BUG adds extra spaces 
ba23			        ; TODO BUG handle numerics? 
ba23					if DEBUG_FORTH_WORDS_KEY 
ba23						DMARK "DTC" 
ba23 f5				push af  
ba24 3a 38 ba			ld a, (.dmark)  
ba27 32 71 ee			ld (debug_mark),a  
ba2a 3a 39 ba			ld a, (.dmark+1)  
ba2d 32 72 ee			ld (debug_mark+1),a  
ba30 3a 3a ba			ld a, (.dmark+2)  
ba33 32 73 ee			ld (debug_mark+2),a  
ba36 18 03			jr .pastdmark  
ba38 ..			.dmark: db "DTC"  
ba3b f1			.pastdmark: pop af  
ba3c			endm  
# End of macro DMARK
ba3c						CALLMONITOR 
ba3c cd a3 94			call break_point_state  
ba3f				endm  
# End of macro CALLMONITOR
ba3f					endif 
ba3f 3e 01			ld a, 1 
ba41 32 47 ea			ld (cli_mvdot), a 
ba44 c3 73 ba			jp .dotgo 
ba47				NEXTW 
ba47 c3 c1 9e			jp macro_next 
ba4a				endm 
# End of macro NEXTW
ba4a			 
ba4a			.DOT: 
ba4a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
ba4a 1c				db WORD_SYS_CORE+8             
ba4b 26 bc			dw .CLS            
ba4d 02				db 1 + 1 
ba4e .. 00			db ".",0              
ba50				endm 
# End of macro CWHEAD
ba50			        ; | . ( u -- ) Display TOS | DONE 
ba50					; get value off TOS and display it 
ba50			 
ba50					if DEBUG_FORTH_WORDS_KEY 
ba50						DMARK "DOT" 
ba50 f5				push af  
ba51 3a 65 ba			ld a, (.dmark)  
ba54 32 71 ee			ld (debug_mark),a  
ba57 3a 66 ba			ld a, (.dmark+1)  
ba5a 32 72 ee			ld (debug_mark+1),a  
ba5d 3a 67 ba			ld a, (.dmark+2)  
ba60 32 73 ee			ld (debug_mark+2),a  
ba63 18 03			jr .pastdmark  
ba65 ..			.dmark: db "DOT"  
ba68 f1			.pastdmark: pop af  
ba69			endm  
# End of macro DMARK
ba69						CALLMONITOR 
ba69 cd a3 94			call break_point_state  
ba6c				endm  
# End of macro CALLMONITOR
ba6c					endif 
ba6c 3e 00			ld a, 0 
ba6e 32 47 ea			ld (cli_mvdot), a 
ba71 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
ba73				 
ba73			 
ba73			.dotgo: 
ba73			 
ba73			; move up type to on stack for parserv5 
ba73					FORTH_DSP 
ba73 cd d1 9c			call macro_forth_dsp 
ba76				endm 
# End of macro FORTH_DSP
ba76				;FORTH_DSP_VALUE  
ba76			 
ba76			if DEBUG_FORTH_DOT 
ba76				DMARK "DOT" 
ba76 f5				push af  
ba77 3a 8b ba			ld a, (.dmark)  
ba7a 32 71 ee			ld (debug_mark),a  
ba7d 3a 8c ba			ld a, (.dmark+1)  
ba80 32 72 ee			ld (debug_mark+1),a  
ba83 3a 8d ba			ld a, (.dmark+2)  
ba86 32 73 ee			ld (debug_mark+2),a  
ba89 18 03			jr .pastdmark  
ba8b ..			.dmark: db "DOT"  
ba8e f1			.pastdmark: pop af  
ba8f			endm  
# End of macro DMARK
ba8f				CALLMONITOR 
ba8f cd a3 94			call break_point_state  
ba92				endm  
# End of macro CALLMONITOR
ba92			endif	 
ba92			;		.print: 
ba92			 
ba92 7e				ld a,(hl)  ; work out what type of value is on the TOS 
ba93 23				inc hl   ; position to the actual value 
ba94 fe 01			cp DS_TYPE_STR 
ba96 20 06			jr nz, .dotnum1  
ba98			 
ba98			; display string 
ba98				FORTH_DSP_VALUE  
ba98 cd f4 9c			call macro_forth_dsp_value 
ba9b				endm 
# End of macro FORTH_DSP_VALUE
ba9b eb				ex de,hl 
ba9c 18 49			jr .dotwrite 
ba9e			 
ba9e			.dotnum1: 
ba9e fe 02			cp DS_TYPE_INUM 
baa0 20 44			jr nz, .dotflot 
baa2			 
baa2			 
baa2			; display number 
baa2			 
baa2			;	push hl 
baa2			;	call clear_display 
baa2			;	pop hl 
baa2			 
baa2 5e				ld e, (hl) 
baa3 23				inc hl 
baa4 56				ld d, (hl) 
baa5 21 cb e2			ld hl, scratch 
baa8			if DEBUG_FORTH_DOT 
baa8				DMARK "DT1" 
baa8 f5				push af  
baa9 3a bd ba			ld a, (.dmark)  
baac 32 71 ee			ld (debug_mark),a  
baaf 3a be ba			ld a, (.dmark+1)  
bab2 32 72 ee			ld (debug_mark+1),a  
bab5 3a bf ba			ld a, (.dmark+2)  
bab8 32 73 ee			ld (debug_mark+2),a  
babb 18 03			jr .pastdmark  
babd ..			.dmark: db "DT1"  
bac0 f1			.pastdmark: pop af  
bac1			endm  
# End of macro DMARK
bac1				CALLMONITOR 
bac1 cd a3 94			call break_point_state  
bac4				endm  
# End of macro CALLMONITOR
bac4			endif	 
bac4			 
bac4 cd af 90			call uitoa_16 
bac7 eb				ex de,hl 
bac8			 
bac8			if DEBUG_FORTH_DOT 
bac8				DMARK "DT2" 
bac8 f5				push af  
bac9 3a dd ba			ld a, (.dmark)  
bacc 32 71 ee			ld (debug_mark),a  
bacf 3a de ba			ld a, (.dmark+1)  
bad2 32 72 ee			ld (debug_mark+1),a  
bad5 3a df ba			ld a, (.dmark+2)  
bad8 32 73 ee			ld (debug_mark+2),a  
badb 18 03			jr .pastdmark  
badd ..			.dmark: db "DT2"  
bae0 f1			.pastdmark: pop af  
bae1			endm  
# End of macro DMARK
bae1				CALLMONITOR 
bae1 cd a3 94			call break_point_state  
bae4				endm  
# End of macro CALLMONITOR
bae4			endif	 
bae4			 
bae4			;	ld de, os_word_scratch 
bae4 18 01			jr .dotwrite 
bae6			 
bae6 00			.dotflot:   nop 
bae7			; TODO print floating point number 
bae7			 
bae7			.dotwrite:		 
bae7			 
bae7					; if c is set then set all '-' to spaces 
bae7					; need to also take into account .>  
bae7			 
bae7 3e 01				ld a, 1 
bae9 b9					cp c 
baea 20 67				jr nz, .nodashswap 
baec			 
baec					; DE has the string to write, working with HL 
baec			 
baec 06 ff				ld b, 255 
baee d5					push de 
baef e1					pop hl 
baf0			 
baf0			if DEBUG_FORTH_DOT 
baf0				DMARK "DT-" 
baf0 f5				push af  
baf1 3a 05 bb			ld a, (.dmark)  
baf4 32 71 ee			ld (debug_mark),a  
baf7 3a 06 bb			ld a, (.dmark+1)  
bafa 32 72 ee			ld (debug_mark+1),a  
bafd 3a 07 bb			ld a, (.dmark+2)  
bb00 32 73 ee			ld (debug_mark+2),a  
bb03 18 03			jr .pastdmark  
bb05 ..			.dmark: db "DT-"  
bb08 f1			.pastdmark: pop af  
bb09			endm  
# End of macro DMARK
bb09				CALLMONITOR 
bb09 cd a3 94			call break_point_state  
bb0c				endm  
# End of macro CALLMONITOR
bb0c			endif	 
bb0c 7e			.dashscan:	ld a, (hl) 
bb0d fe 00				cp 0 
bb0f 28 42				jr z, .nodashswap 
bb11 fe 2d				cp '-' 
bb13 20 03				jr nz, .dashskip 
bb15 3e 20				ld a, ' ' 
bb17 77					ld (hl), a 
bb18 23			.dashskip:	inc hl 
bb19			if DEBUG_FORTH_DOT 
bb19				DMARK "D-2" 
bb19 f5				push af  
bb1a 3a 2e bb			ld a, (.dmark)  
bb1d 32 71 ee			ld (debug_mark),a  
bb20 3a 2f bb			ld a, (.dmark+1)  
bb23 32 72 ee			ld (debug_mark+1),a  
bb26 3a 30 bb			ld a, (.dmark+2)  
bb29 32 73 ee			ld (debug_mark+2),a  
bb2c 18 03			jr .pastdmark  
bb2e ..			.dmark: db "D-2"  
bb31 f1			.pastdmark: pop af  
bb32			endm  
# End of macro DMARK
bb32				CALLMONITOR 
bb32 cd a3 94			call break_point_state  
bb35				endm  
# End of macro CALLMONITOR
bb35			endif	 
bb35 10 d5				djnz .dashscan 
bb37			 
bb37			if DEBUG_FORTH_DOT 
bb37				DMARK "D-1" 
bb37 f5				push af  
bb38 3a 4c bb			ld a, (.dmark)  
bb3b 32 71 ee			ld (debug_mark),a  
bb3e 3a 4d bb			ld a, (.dmark+1)  
bb41 32 72 ee			ld (debug_mark+1),a  
bb44 3a 4e bb			ld a, (.dmark+2)  
bb47 32 73 ee			ld (debug_mark+2),a  
bb4a 18 03			jr .pastdmark  
bb4c ..			.dmark: db "D-1"  
bb4f f1			.pastdmark: pop af  
bb50			endm  
# End of macro DMARK
bb50				CALLMONITOR 
bb50 cd a3 94			call break_point_state  
bb53				endm  
# End of macro CALLMONITOR
bb53			endif	 
bb53			 
bb53			.nodashswap: 
bb53			 
bb53			if DEBUG_FORTH_DOT 
bb53				DMARK "D-o" 
bb53 f5				push af  
bb54 3a 68 bb			ld a, (.dmark)  
bb57 32 71 ee			ld (debug_mark),a  
bb5a 3a 69 bb			ld a, (.dmark+1)  
bb5d 32 72 ee			ld (debug_mark+1),a  
bb60 3a 6a bb			ld a, (.dmark+2)  
bb63 32 73 ee			ld (debug_mark+2),a  
bb66 18 03			jr .pastdmark  
bb68 ..			.dmark: db "D-o"  
bb6b f1			.pastdmark: pop af  
bb6c			endm  
# End of macro DMARK
bb6c				CALLMONITOR 
bb6c cd a3 94			call break_point_state  
bb6f				endm  
# End of macro CALLMONITOR
bb6f			endif	 
bb6f			 
bb6f d5					push de   ; save string start in case we need to advance print 
bb70			 
bb70 3a 68 ea				ld a, (f_cursor_ptr) 
bb73 cd 88 8a				call str_at_display 
bb76 3a 46 ea				ld a,(cli_autodisplay) 
bb79 fe 00				cp 0 
bb7b 28 03				jr z, .noupdate 
bb7d cd 98 8a						call update_display 
bb80					.noupdate: 
bb80			 
bb80			 
bb80					; see if we need to advance the print position 
bb80			 
bb80 e1					pop hl   ; get back string 
bb81			;		ex de,hl 
bb81			 
bb81 3a 47 ea				ld a, (cli_mvdot) 
bb84			if DEBUG_FORTH_DOT 
bb84			;		ld e,a 
bb84				DMARK "D>1" 
bb84 f5				push af  
bb85 3a 99 bb			ld a, (.dmark)  
bb88 32 71 ee			ld (debug_mark),a  
bb8b 3a 9a bb			ld a, (.dmark+1)  
bb8e 32 72 ee			ld (debug_mark+1),a  
bb91 3a 9b bb			ld a, (.dmark+2)  
bb94 32 73 ee			ld (debug_mark+2),a  
bb97 18 03			jr .pastdmark  
bb99 ..			.dmark: db "D>1"  
bb9c f1			.pastdmark: pop af  
bb9d			endm  
# End of macro DMARK
bb9d				CALLMONITOR 
bb9d cd a3 94			call break_point_state  
bba0				endm  
# End of macro CALLMONITOR
bba0			endif	 
bba0 fe 00				cp 0 
bba2 28 44				jr z, .noadv 
bba4					; yes, lets advance the print position 
bba4 3e 00				ld a, 0 
bba6 cd 0b 91				call strlent 
bba9			if DEBUG_FORTH_DOT 
bba9				DMARK "D-?" 
bba9 f5				push af  
bbaa 3a be bb			ld a, (.dmark)  
bbad 32 71 ee			ld (debug_mark),a  
bbb0 3a bf bb			ld a, (.dmark+1)  
bbb3 32 72 ee			ld (debug_mark+1),a  
bbb6 3a c0 bb			ld a, (.dmark+2)  
bbb9 32 73 ee			ld (debug_mark+2),a  
bbbc 18 03			jr .pastdmark  
bbbe ..			.dmark: db "D-?"  
bbc1 f1			.pastdmark: pop af  
bbc2			endm  
# End of macro DMARK
bbc2				CALLMONITOR 
bbc2 cd a3 94			call break_point_state  
bbc5				endm  
# End of macro CALLMONITOR
bbc5			endif	 
bbc5 3a 68 ea				ld a, (f_cursor_ptr) 
bbc8 85					add a,l 
bbc9					;call addatohl 
bbc9					;ld a, l 
bbc9 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
bbcc			 
bbcc			if DEBUG_FORTH_DOT 
bbcc				DMARK "D->" 
bbcc f5				push af  
bbcd 3a e1 bb			ld a, (.dmark)  
bbd0 32 71 ee			ld (debug_mark),a  
bbd3 3a e2 bb			ld a, (.dmark+1)  
bbd6 32 72 ee			ld (debug_mark+1),a  
bbd9 3a e3 bb			ld a, (.dmark+2)  
bbdc 32 73 ee			ld (debug_mark+2),a  
bbdf 18 03			jr .pastdmark  
bbe1 ..			.dmark: db "D->"  
bbe4 f1			.pastdmark: pop af  
bbe5			endm  
# End of macro DMARK
bbe5				CALLMONITOR 
bbe5 cd a3 94			call break_point_state  
bbe8				endm  
# End of macro CALLMONITOR
bbe8			endif	 
bbe8			 
bbe8			.noadv:	 
bbe8			 
bbe8					if DEBUG_FORTH_DOT_WAIT 
bbe8							call next_page_prompt 
bbe8					endif	 
bbe8			; TODO this pop off the stack causes a crash. i dont know why 
bbe8			 
bbe8			 
bbe8			if DEBUG_FORTH_DOT 
bbe8				DMARK "DTh" 
bbe8 f5				push af  
bbe9 3a fd bb			ld a, (.dmark)  
bbec 32 71 ee			ld (debug_mark),a  
bbef 3a fe bb			ld a, (.dmark+1)  
bbf2 32 72 ee			ld (debug_mark+1),a  
bbf5 3a ff bb			ld a, (.dmark+2)  
bbf8 32 73 ee			ld (debug_mark+2),a  
bbfb 18 03			jr .pastdmark  
bbfd ..			.dmark: db "DTh"  
bc00 f1			.pastdmark: pop af  
bc01			endm  
# End of macro DMARK
bc01				CALLMONITOR 
bc01 cd a3 94			call break_point_state  
bc04				endm  
# End of macro CALLMONITOR
bc04			endif	 
bc04			 
bc04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc04 cd c3 9d			call macro_forth_dsp_pop 
bc07				endm 
# End of macro FORTH_DSP_POP
bc07			 
bc07			if DEBUG_FORTH_DOT 
bc07				DMARK "DTi" 
bc07 f5				push af  
bc08 3a 1c bc			ld a, (.dmark)  
bc0b 32 71 ee			ld (debug_mark),a  
bc0e 3a 1d bc			ld a, (.dmark+1)  
bc11 32 72 ee			ld (debug_mark+1),a  
bc14 3a 1e bc			ld a, (.dmark+2)  
bc17 32 73 ee			ld (debug_mark+2),a  
bc1a 18 03			jr .pastdmark  
bc1c ..			.dmark: db "DTi"  
bc1f f1			.pastdmark: pop af  
bc20			endm  
# End of macro DMARK
bc20				CALLMONITOR 
bc20 cd a3 94			call break_point_state  
bc23				endm  
# End of macro CALLMONITOR
bc23			endif	 
bc23			 
bc23			 
bc23					NEXTW 
bc23 c3 c1 9e			jp macro_next 
bc26				endm 
# End of macro NEXTW
bc26			 
bc26			.CLS: 
bc26				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bc26 35				db WORD_SYS_CORE+33             
bc27 53 bc			dw .DRAW            
bc29 04				db 3 + 1 
bc2a .. 00			db "CLS",0              
bc2e				endm 
# End of macro CWHEAD
bc2e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bc2e					if DEBUG_FORTH_WORDS_KEY 
bc2e						DMARK "CLS" 
bc2e f5				push af  
bc2f 3a 43 bc			ld a, (.dmark)  
bc32 32 71 ee			ld (debug_mark),a  
bc35 3a 44 bc			ld a, (.dmark+1)  
bc38 32 72 ee			ld (debug_mark+1),a  
bc3b 3a 45 bc			ld a, (.dmark+2)  
bc3e 32 73 ee			ld (debug_mark+2),a  
bc41 18 03			jr .pastdmark  
bc43 ..			.dmark: db "CLS"  
bc46 f1			.pastdmark: pop af  
bc47			endm  
# End of macro DMARK
bc47						CALLMONITOR 
bc47 cd a3 94			call break_point_state  
bc4a				endm  
# End of macro CALLMONITOR
bc4a					endif 
bc4a cd 75 8a				call clear_display 
bc4d c3 61 bd				jp .home		; and home cursor 
bc50					NEXTW 
bc50 c3 c1 9e			jp macro_next 
bc53				endm 
# End of macro NEXTW
bc53			 
bc53			.DRAW: 
bc53				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bc53 36				db WORD_SYS_CORE+34             
bc54 7e bc			dw .DUMP            
bc56 05				db 4 + 1 
bc57 .. 00			db "DRAW",0              
bc5c				endm 
# End of macro CWHEAD
bc5c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bc5c					if DEBUG_FORTH_WORDS_KEY 
bc5c						DMARK "DRW" 
bc5c f5				push af  
bc5d 3a 71 bc			ld a, (.dmark)  
bc60 32 71 ee			ld (debug_mark),a  
bc63 3a 72 bc			ld a, (.dmark+1)  
bc66 32 72 ee			ld (debug_mark+1),a  
bc69 3a 73 bc			ld a, (.dmark+2)  
bc6c 32 73 ee			ld (debug_mark+2),a  
bc6f 18 03			jr .pastdmark  
bc71 ..			.dmark: db "DRW"  
bc74 f1			.pastdmark: pop af  
bc75			endm  
# End of macro DMARK
bc75						CALLMONITOR 
bc75 cd a3 94			call break_point_state  
bc78				endm  
# End of macro CALLMONITOR
bc78					endif 
bc78 cd 98 8a				call update_display 
bc7b					NEXTW 
bc7b c3 c1 9e			jp macro_next 
bc7e				endm 
# End of macro NEXTW
bc7e			 
bc7e			.DUMP: 
bc7e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bc7e 37				db WORD_SYS_CORE+35             
bc7f b6 bc			dw .CDUMP            
bc81 05				db 4 + 1 
bc82 .. 00			db "DUMP",0              
bc87				endm 
# End of macro CWHEAD
bc87			; | DUMP ( x -- ) With address x display dump   | DONE 
bc87			; TODO pop address to use off of the stack 
bc87					if DEBUG_FORTH_WORDS_KEY 
bc87						DMARK "DUM" 
bc87 f5				push af  
bc88 3a 9c bc			ld a, (.dmark)  
bc8b 32 71 ee			ld (debug_mark),a  
bc8e 3a 9d bc			ld a, (.dmark+1)  
bc91 32 72 ee			ld (debug_mark+1),a  
bc94 3a 9e bc			ld a, (.dmark+2)  
bc97 32 73 ee			ld (debug_mark+2),a  
bc9a 18 03			jr .pastdmark  
bc9c ..			.dmark: db "DUM"  
bc9f f1			.pastdmark: pop af  
bca0			endm  
# End of macro DMARK
bca0						CALLMONITOR 
bca0 cd a3 94			call break_point_state  
bca3				endm  
# End of macro CALLMONITOR
bca3					endif 
bca3 cd 75 8a				call clear_display 
bca6			 
bca6					; get address 
bca6			 
bca6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bca6 cd 0b 9d			call macro_dsp_valuehl 
bca9				endm 
# End of macro FORTH_DSP_VALUEHL
bca9				 
bca9					; save it for cdump 
bca9			 
bca9 22 ee e5				ld (os_cur_ptr),hl 
bcac			 
bcac					; destroy value TOS 
bcac			 
bcac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcac cd c3 9d			call macro_forth_dsp_pop 
bcaf				endm 
# End of macro FORTH_DSP_POP
bcaf			 
bcaf cd 94 99				call dumpcont	; skip old style of param parsing	 
bcb2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bcb3					NEXTW 
bcb3 c3 c1 9e			jp macro_next 
bcb6				endm 
# End of macro NEXTW
bcb6			.CDUMP: 
bcb6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bcb6 38				db WORD_SYS_CORE+36             
bcb7 e6 bc			dw .DAT            
bcb9 06				db 5 + 1 
bcba .. 00			db "CDUMP",0              
bcc0				endm 
# End of macro CWHEAD
bcc0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bcc0					if DEBUG_FORTH_WORDS_KEY 
bcc0						DMARK "CDP" 
bcc0 f5				push af  
bcc1 3a d5 bc			ld a, (.dmark)  
bcc4 32 71 ee			ld (debug_mark),a  
bcc7 3a d6 bc			ld a, (.dmark+1)  
bcca 32 72 ee			ld (debug_mark+1),a  
bccd 3a d7 bc			ld a, (.dmark+2)  
bcd0 32 73 ee			ld (debug_mark+2),a  
bcd3 18 03			jr .pastdmark  
bcd5 ..			.dmark: db "CDP"  
bcd8 f1			.pastdmark: pop af  
bcd9			endm  
# End of macro DMARK
bcd9						CALLMONITOR 
bcd9 cd a3 94			call break_point_state  
bcdc				endm  
# End of macro CALLMONITOR
bcdc					endif 
bcdc cd 75 8a				call clear_display 
bcdf cd 94 99				call dumpcont	 
bce2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bce3					NEXTW 
bce3 c3 c1 9e			jp macro_next 
bce6				endm 
# End of macro NEXTW
bce6			 
bce6			 
bce6			 
bce6			 
bce6			.DAT: 
bce6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bce6 3d				db WORD_SYS_CORE+41             
bce7 3c bd			dw .HOME            
bce9 03				db 2 + 1 
bcea .. 00			db "AT",0              
bced				endm 
# End of macro CWHEAD
bced			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bced					if DEBUG_FORTH_WORDS_KEY 
bced						DMARK "AT." 
bced f5				push af  
bcee 3a 02 bd			ld a, (.dmark)  
bcf1 32 71 ee			ld (debug_mark),a  
bcf4 3a 03 bd			ld a, (.dmark+1)  
bcf7 32 72 ee			ld (debug_mark+1),a  
bcfa 3a 04 bd			ld a, (.dmark+2)  
bcfd 32 73 ee			ld (debug_mark+2),a  
bd00 18 03			jr .pastdmark  
bd02 ..			.dmark: db "AT."  
bd05 f1			.pastdmark: pop af  
bd06			endm  
# End of macro DMARK
bd06						CALLMONITOR 
bd06 cd a3 94			call break_point_state  
bd09				endm  
# End of macro CALLMONITOR
bd09					endif 
bd09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd09 cd 0b 9d			call macro_dsp_valuehl 
bd0c				endm 
# End of macro FORTH_DSP_VALUEHL
bd0c			 
bd0c			 
bd0c					; TODO save cursor row 
bd0c 7d					ld a,l 
bd0d fe 02				cp 2 
bd0f 20 04				jr nz, .crow3 
bd11 3e 28				ld a, display_row_2 
bd13 18 12				jr .ccol1 
bd15 fe 03		.crow3:		cp 3 
bd17 20 04				jr nz, .crow4 
bd19 3e 50				ld a, display_row_3 
bd1b 18 0a				jr .ccol1 
bd1d fe 04		.crow4:		cp 4 
bd1f 20 04				jr nz, .crow1 
bd21 3e 78				ld a, display_row_4 
bd23 18 02				jr .ccol1 
bd25 3e 00		.crow1:		ld a,display_row_1 
bd27 f5			.ccol1:		push af			; got row offset 
bd28 6f					ld l,a 
bd29 26 00				ld h,0 
bd2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd2b cd c3 9d			call macro_forth_dsp_pop 
bd2e				endm 
# End of macro FORTH_DSP_POP
bd2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd2e cd 0b 9d			call macro_dsp_valuehl 
bd31				endm 
# End of macro FORTH_DSP_VALUEHL
bd31					; TODO save cursor col 
bd31 f1					pop af 
bd32 85					add l		; add col offset 
bd33 32 68 ea				ld (f_cursor_ptr), a 
bd36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd36 cd c3 9d			call macro_forth_dsp_pop 
bd39				endm 
# End of macro FORTH_DSP_POP
bd39			 
bd39					; calculate  
bd39			 
bd39					NEXTW 
bd39 c3 c1 9e			jp macro_next 
bd3c				endm 
# End of macro NEXTW
bd3c			 
bd3c			 
bd3c			.HOME: 
bd3c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bd3c 41				db WORD_SYS_CORE+45             
bd3d 69 bd			dw .SPACE            
bd3f 05				db 4 + 1 
bd40 .. 00			db "HOME",0              
bd45				endm 
# End of macro CWHEAD
bd45			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bd45					if DEBUG_FORTH_WORDS_KEY 
bd45						DMARK "HOM" 
bd45 f5				push af  
bd46 3a 5a bd			ld a, (.dmark)  
bd49 32 71 ee			ld (debug_mark),a  
bd4c 3a 5b bd			ld a, (.dmark+1)  
bd4f 32 72 ee			ld (debug_mark+1),a  
bd52 3a 5c bd			ld a, (.dmark+2)  
bd55 32 73 ee			ld (debug_mark+2),a  
bd58 18 03			jr .pastdmark  
bd5a ..			.dmark: db "HOM"  
bd5d f1			.pastdmark: pop af  
bd5e			endm  
# End of macro DMARK
bd5e						CALLMONITOR 
bd5e cd a3 94			call break_point_state  
bd61				endm  
# End of macro CALLMONITOR
bd61					endif 
bd61 3e 00		.home:		ld a, 0		; and home cursor 
bd63 32 68 ea				ld (f_cursor_ptr), a 
bd66					NEXTW 
bd66 c3 c1 9e			jp macro_next 
bd69				endm 
# End of macro NEXTW
bd69			 
bd69			 
bd69			.SPACE: 
bd69				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bd69 46				db WORD_SYS_CORE+50             
bd6a 9f bd			dw .SPACES            
bd6c 03				db 2 + 1 
bd6d .. 00			db "BL",0              
bd70				endm 
# End of macro CWHEAD
bd70			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bd70					if DEBUG_FORTH_WORDS_KEY 
bd70						DMARK "BL." 
bd70 f5				push af  
bd71 3a 85 bd			ld a, (.dmark)  
bd74 32 71 ee			ld (debug_mark),a  
bd77 3a 86 bd			ld a, (.dmark+1)  
bd7a 32 72 ee			ld (debug_mark+1),a  
bd7d 3a 87 bd			ld a, (.dmark+2)  
bd80 32 73 ee			ld (debug_mark+2),a  
bd83 18 03			jr .pastdmark  
bd85 ..			.dmark: db "BL."  
bd88 f1			.pastdmark: pop af  
bd89			endm  
# End of macro DMARK
bd89						CALLMONITOR 
bd89 cd a3 94			call break_point_state  
bd8c				endm  
# End of macro CALLMONITOR
bd8c					endif 
bd8c 3e 20				ld a, " " 
bd8e 32 cb e2				ld (scratch),a 
bd91 3e 00				ld a, 0 
bd93 32 cc e2				ld (scratch+1),a 
bd96 21 cb e2				ld hl, scratch 
bd99 cd 82 9b				call forth_push_str 
bd9c					 
bd9c				       NEXTW 
bd9c c3 c1 9e			jp macro_next 
bd9f				endm 
# End of macro NEXTW
bd9f			 
bd9f			;.blstr: db " ", 0 
bd9f			 
bd9f			.SPACES: 
bd9f				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bd9f 47				db WORD_SYS_CORE+51             
bda0 3a be			dw .SCROLL            
bda2 07				db 6 + 1 
bda3 .. 00			db "SPACES",0              
bdaa				endm 
# End of macro CWHEAD
bdaa			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
bdaa					if DEBUG_FORTH_WORDS_KEY 
bdaa						DMARK "SPS" 
bdaa f5				push af  
bdab 3a bf bd			ld a, (.dmark)  
bdae 32 71 ee			ld (debug_mark),a  
bdb1 3a c0 bd			ld a, (.dmark+1)  
bdb4 32 72 ee			ld (debug_mark+1),a  
bdb7 3a c1 bd			ld a, (.dmark+2)  
bdba 32 73 ee			ld (debug_mark+2),a  
bdbd 18 03			jr .pastdmark  
bdbf ..			.dmark: db "SPS"  
bdc2 f1			.pastdmark: pop af  
bdc3			endm  
# End of macro DMARK
bdc3						CALLMONITOR 
bdc3 cd a3 94			call break_point_state  
bdc6				endm  
# End of macro CALLMONITOR
bdc6					endif 
bdc6			 
bdc6			 
bdc6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdc6 cd 0b 9d			call macro_dsp_valuehl 
bdc9				endm 
# End of macro FORTH_DSP_VALUEHL
bdc9			 
bdc9 e5					push hl    ; u 
bdca					if DEBUG_FORTH_WORDS 
bdca						DMARK "SPA" 
bdca f5				push af  
bdcb 3a df bd			ld a, (.dmark)  
bdce 32 71 ee			ld (debug_mark),a  
bdd1 3a e0 bd			ld a, (.dmark+1)  
bdd4 32 72 ee			ld (debug_mark+1),a  
bdd7 3a e1 bd			ld a, (.dmark+2)  
bdda 32 73 ee			ld (debug_mark+2),a  
bddd 18 03			jr .pastdmark  
bddf ..			.dmark: db "SPA"  
bde2 f1			.pastdmark: pop af  
bde3			endm  
# End of macro DMARK
bde3						CALLMONITOR 
bde3 cd a3 94			call break_point_state  
bde6				endm  
# End of macro CALLMONITOR
bde6					endif 
bde6			 
bde6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bde6 cd c3 9d			call macro_forth_dsp_pop 
bde9				endm 
# End of macro FORTH_DSP_POP
bde9 e1					pop hl 
bdea 0e 00				ld c, 0 
bdec 45					ld b, l 
bded 21 cb e2				ld hl, scratch  
bdf0			 
bdf0					if DEBUG_FORTH_WORDS 
bdf0						DMARK "SP2" 
bdf0 f5				push af  
bdf1 3a 05 be			ld a, (.dmark)  
bdf4 32 71 ee			ld (debug_mark),a  
bdf7 3a 06 be			ld a, (.dmark+1)  
bdfa 32 72 ee			ld (debug_mark+1),a  
bdfd 3a 07 be			ld a, (.dmark+2)  
be00 32 73 ee			ld (debug_mark+2),a  
be03 18 03			jr .pastdmark  
be05 ..			.dmark: db "SP2"  
be08 f1			.pastdmark: pop af  
be09			endm  
# End of macro DMARK
be09						CALLMONITOR 
be09 cd a3 94			call break_point_state  
be0c				endm  
# End of macro CALLMONITOR
be0c					endif 
be0c 3e 20				ld a, ' ' 
be0e			.spaces1:	 
be0e 77					ld (hl),a 
be0f 23					inc hl 
be10					 
be10 10 fc				djnz .spaces1 
be12 3e 00				ld a,0 
be14 77					ld (hl),a 
be15 21 cb e2				ld hl, scratch 
be18					if DEBUG_FORTH_WORDS 
be18						DMARK "SP3" 
be18 f5				push af  
be19 3a 2d be			ld a, (.dmark)  
be1c 32 71 ee			ld (debug_mark),a  
be1f 3a 2e be			ld a, (.dmark+1)  
be22 32 72 ee			ld (debug_mark+1),a  
be25 3a 2f be			ld a, (.dmark+2)  
be28 32 73 ee			ld (debug_mark+2),a  
be2b 18 03			jr .pastdmark  
be2d ..			.dmark: db "SP3"  
be30 f1			.pastdmark: pop af  
be31			endm  
# End of macro DMARK
be31						CALLMONITOR 
be31 cd a3 94			call break_point_state  
be34				endm  
# End of macro CALLMONITOR
be34					endif 
be34 cd 82 9b				call forth_push_str 
be37			 
be37				       NEXTW 
be37 c3 c1 9e			jp macro_next 
be3a				endm 
# End of macro NEXTW
be3a			 
be3a			 
be3a			 
be3a			.SCROLL: 
be3a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
be3a 53				db WORD_SYS_CORE+63             
be3b 67 be			dw .SCROLLD            
be3d 07				db 6 + 1 
be3e .. 00			db "SCROLL",0              
be45				endm 
# End of macro CWHEAD
be45			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
be45					if DEBUG_FORTH_WORDS_KEY 
be45						DMARK "SCR" 
be45 f5				push af  
be46 3a 5a be			ld a, (.dmark)  
be49 32 71 ee			ld (debug_mark),a  
be4c 3a 5b be			ld a, (.dmark+1)  
be4f 32 72 ee			ld (debug_mark+1),a  
be52 3a 5c be			ld a, (.dmark+2)  
be55 32 73 ee			ld (debug_mark+2),a  
be58 18 03			jr .pastdmark  
be5a ..			.dmark: db "SCR"  
be5d f1			.pastdmark: pop af  
be5e			endm  
# End of macro DMARK
be5e						CALLMONITOR 
be5e cd a3 94			call break_point_state  
be61				endm  
# End of macro CALLMONITOR
be61					endif 
be61			 
be61 cd 37 8a			call scroll_up 
be64			;	call update_display 
be64			 
be64					NEXTW 
be64 c3 c1 9e			jp macro_next 
be67				endm 
# End of macro NEXTW
be67			 
be67			 
be67			 
be67			;		; get dir 
be67			; 
be67			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be67			; 
be67			;		push hl 
be67			; 
be67			;		; destroy value TOS 
be67			; 
be67			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be67			; 
be67			;		; get count 
be67			; 
be67			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be67			; 
be67			;		push hl 
be67			; 
be67			;		; destroy value TOS 
be67			; 
be67			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be67			; 
be67			;		; one value on hl get other one back 
be67			; 
be67			;		pop bc    ; count 
be67			; 
be67			;		pop de   ; dir 
be67			; 
be67			; 
be67			;		ld b, c 
be67			; 
be67			;.scrolldir:     push bc 
be67			;		push de 
be67			; 
be67			;		ld a, 0 
be67			;		cp e 
be67			;		jr z, .scrollup  
be67			;		call scroll_down 
be67			;		jr .scrollnext 
be67			;.scrollup:	call scroll_up 
be67			; 
be67			;		 
be67			;.scrollnext: 
be67			;		pop de 
be67			;		pop bc 
be67			;		djnz .scrolldir 
be67			; 
be67			; 
be67			; 
be67			; 
be67			; 
be67			;		NEXTW 
be67			 
be67			.SCROLLD: 
be67				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
be67 53				db WORD_SYS_CORE+63             
be68 95 be			dw .ATQ            
be6a 08				db 7 + 1 
be6b .. 00			db "SCROLLD",0              
be73				endm 
# End of macro CWHEAD
be73			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
be73					if DEBUG_FORTH_WORDS_KEY 
be73						DMARK "SCD" 
be73 f5				push af  
be74 3a 88 be			ld a, (.dmark)  
be77 32 71 ee			ld (debug_mark),a  
be7a 3a 89 be			ld a, (.dmark+1)  
be7d 32 72 ee			ld (debug_mark+1),a  
be80 3a 8a be			ld a, (.dmark+2)  
be83 32 73 ee			ld (debug_mark+2),a  
be86 18 03			jr .pastdmark  
be88 ..			.dmark: db "SCD"  
be8b f1			.pastdmark: pop af  
be8c			endm  
# End of macro DMARK
be8c						CALLMONITOR 
be8c cd a3 94			call break_point_state  
be8f				endm  
# End of macro CALLMONITOR
be8f					endif 
be8f			 
be8f cd 5b 8a			call scroll_down 
be92			;	call update_display 
be92			 
be92					NEXTW 
be92 c3 c1 9e			jp macro_next 
be95				endm 
# End of macro NEXTW
be95			 
be95			 
be95			.ATQ: 
be95				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
be95 62				db WORD_SYS_CORE+78             
be96 f3 be			dw .AUTODSP            
be98 04				db 3 + 1 
be99 .. 00			db "AT@",0              
be9d				endm 
# End of macro CWHEAD
be9d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
be9d					if DEBUG_FORTH_WORDS_KEY 
be9d						DMARK "ATA" 
be9d f5				push af  
be9e 3a b2 be			ld a, (.dmark)  
bea1 32 71 ee			ld (debug_mark),a  
bea4 3a b3 be			ld a, (.dmark+1)  
bea7 32 72 ee			ld (debug_mark+1),a  
beaa 3a b4 be			ld a, (.dmark+2)  
bead 32 73 ee			ld (debug_mark+2),a  
beb0 18 03			jr .pastdmark  
beb2 ..			.dmark: db "ATA"  
beb5 f1			.pastdmark: pop af  
beb6			endm  
# End of macro DMARK
beb6						CALLMONITOR 
beb6 cd a3 94			call break_point_state  
beb9				endm  
# End of macro CALLMONITOR
beb9					endif 
beb9			 
beb9			 
beb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
beb9 cd 0b 9d			call macro_dsp_valuehl 
bebc				endm 
# End of macro FORTH_DSP_VALUEHL
bebc			 
bebc					; TODO save cursor row 
bebc 7d					ld a,l 
bebd fe 02				cp 2 
bebf 20 04				jr nz, .crow3aq 
bec1 3e 28				ld a, display_row_2 
bec3 18 12				jr .ccol1aq 
bec5 fe 03		.crow3aq:		cp 3 
bec7 20 04				jr nz, .crow4aq 
bec9 3e 50				ld a, display_row_3 
becb 18 0a				jr .ccol1aq 
becd fe 04		.crow4aq:		cp 4 
becf 20 04				jr nz, .crow1aq 
bed1 3e 78				ld a, display_row_4 
bed3 18 02				jr .ccol1aq 
bed5 3e 00		.crow1aq:		ld a,display_row_1 
bed7 f5			.ccol1aq:		push af			; got row offset 
bed8 6f					ld l,a 
bed9 26 00				ld h,0 
bedb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bedb cd c3 9d			call macro_forth_dsp_pop 
bede				endm 
# End of macro FORTH_DSP_POP
bede					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bede cd 0b 9d			call macro_dsp_valuehl 
bee1				endm 
# End of macro FORTH_DSP_VALUEHL
bee1					; TODO save cursor col 
bee1 f1					pop af 
bee2 85					add l		; add col offset 
bee3			 
bee3					; add current frame buffer address 
bee3 2a d2 eb				ld hl, (display_fb_active) 
bee6 cd a2 8c				call addatohl 
bee9			 
bee9			 
bee9			 
bee9			 
bee9					; get char frame buffer location offset in hl 
bee9			 
bee9 7e					ld a,(hl) 
beea 26 00				ld h, 0 
beec 6f					ld l, a 
beed			 
beed cd 14 9b				call forth_push_numhl 
bef0			 
bef0			 
bef0					NEXTW 
bef0 c3 c1 9e			jp macro_next 
bef3				endm 
# End of macro NEXTW
bef3			 
bef3			.AUTODSP: 
bef3				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bef3 63				db WORD_SYS_CORE+79             
bef4 09 bf			dw .MENU            
bef6 05				db 4 + 1 
bef7 .. 00			db "ADSP",0              
befc				endm 
# End of macro CWHEAD
befc			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
befc			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
befc			 
befc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
befc cd 0b 9d			call macro_dsp_valuehl 
beff				endm 
# End of macro FORTH_DSP_VALUEHL
beff			 
beff			;		push hl 
beff			 
beff					; destroy value TOS 
beff			 
beff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beff cd c3 9d			call macro_forth_dsp_pop 
bf02				endm 
# End of macro FORTH_DSP_POP
bf02			 
bf02			;		pop hl 
bf02			 
bf02 7d					ld a,l 
bf03 32 46 ea				ld (cli_autodisplay), a 
bf06				       NEXTW 
bf06 c3 c1 9e			jp macro_next 
bf09				endm 
# End of macro NEXTW
bf09			 
bf09			.MENU: 
bf09				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf09 70				db WORD_SYS_CORE+92             
bf0a b2 bf			dw .ENDDISPLAY            
bf0c 05				db 4 + 1 
bf0d .. 00			db "MENU",0              
bf12				endm 
# End of macro CWHEAD
bf12			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bf12			 
bf12			;		; get number of items on the stack 
bf12			; 
bf12				 
bf12					FORTH_DSP_VALUEHL 
bf12 cd 0b 9d			call macro_dsp_valuehl 
bf15				endm 
# End of macro FORTH_DSP_VALUEHL
bf15				 
bf15					if DEBUG_FORTH_WORDS_KEY 
bf15						DMARK "MNU" 
bf15 f5				push af  
bf16 3a 2a bf			ld a, (.dmark)  
bf19 32 71 ee			ld (debug_mark),a  
bf1c 3a 2b bf			ld a, (.dmark+1)  
bf1f 32 72 ee			ld (debug_mark+1),a  
bf22 3a 2c bf			ld a, (.dmark+2)  
bf25 32 73 ee			ld (debug_mark+2),a  
bf28 18 03			jr .pastdmark  
bf2a ..			.dmark: db "MNU"  
bf2d f1			.pastdmark: pop af  
bf2e			endm  
# End of macro DMARK
bf2e						CALLMONITOR 
bf2e cd a3 94			call break_point_state  
bf31				endm  
# End of macro CALLMONITOR
bf31					endif 
bf31			 
bf31 45					ld b, l	 
bf32 05					dec b 
bf33			 
bf33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf33 cd c3 9d			call macro_forth_dsp_pop 
bf36				endm 
# End of macro FORTH_DSP_POP
bf36			 
bf36			 
bf36					; go directly through the stack to pluck out the string pointers and build an array 
bf36			 
bf36			;		FORTH_DSP 
bf36			 
bf36					; hl contains top most stack item 
bf36				 
bf36 11 cb e2				ld de, scratch 
bf39			 
bf39			.mbuild: 
bf39			 
bf39					FORTH_DSP_VALUEHL 
bf39 cd 0b 9d			call macro_dsp_valuehl 
bf3c				endm 
# End of macro FORTH_DSP_VALUEHL
bf3c			 
bf3c					if DEBUG_FORTH_WORDS 
bf3c						DMARK "MN3" 
bf3c f5				push af  
bf3d 3a 51 bf			ld a, (.dmark)  
bf40 32 71 ee			ld (debug_mark),a  
bf43 3a 52 bf			ld a, (.dmark+1)  
bf46 32 72 ee			ld (debug_mark+1),a  
bf49 3a 53 bf			ld a, (.dmark+2)  
bf4c 32 73 ee			ld (debug_mark+2),a  
bf4f 18 03			jr .pastdmark  
bf51 ..			.dmark: db "MN3"  
bf54 f1			.pastdmark: pop af  
bf55			endm  
# End of macro DMARK
bf55						CALLMONITOR 
bf55 cd a3 94			call break_point_state  
bf58				endm  
# End of macro CALLMONITOR
bf58					endif 
bf58 eb					ex de, hl 
bf59 73					ld (hl), e 
bf5a 23					inc hl 
bf5b 72					ld (hl), d 
bf5c 23					inc hl 
bf5d eb					ex de, hl 
bf5e			 
bf5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf5e cd c3 9d			call macro_forth_dsp_pop 
bf61				endm 
# End of macro FORTH_DSP_POP
bf61			 
bf61 10 d6				djnz .mbuild 
bf63			 
bf63					; done add term 
bf63			 
bf63 eb					ex de, hl 
bf64 36 00				ld (hl), 0 
bf66 23					inc hl 
bf67 36 00				ld (hl), 0 
bf69			 
bf69				 
bf69					 
bf69 21 cb e2				ld hl, scratch 
bf6c			 
bf6c					if DEBUG_FORTH_WORDS 
bf6c						DMARK "MNx" 
bf6c f5				push af  
bf6d 3a 81 bf			ld a, (.dmark)  
bf70 32 71 ee			ld (debug_mark),a  
bf73 3a 82 bf			ld a, (.dmark+1)  
bf76 32 72 ee			ld (debug_mark+1),a  
bf79 3a 83 bf			ld a, (.dmark+2)  
bf7c 32 73 ee			ld (debug_mark+2),a  
bf7f 18 03			jr .pastdmark  
bf81 ..			.dmark: db "MNx"  
bf84 f1			.pastdmark: pop af  
bf85			endm  
# End of macro DMARK
bf85						CALLMONITOR 
bf85 cd a3 94			call break_point_state  
bf88				endm  
# End of macro CALLMONITOR
bf88					endif 
bf88			 
bf88			 
bf88			 
bf88 3e 00				ld a, 0 
bf8a cd a6 8a				call menu 
bf8d			 
bf8d			 
bf8d 6f					ld l, a 
bf8e 26 00				ld h, 0 
bf90			 
bf90					if DEBUG_FORTH_WORDS 
bf90						DMARK "MNr" 
bf90 f5				push af  
bf91 3a a5 bf			ld a, (.dmark)  
bf94 32 71 ee			ld (debug_mark),a  
bf97 3a a6 bf			ld a, (.dmark+1)  
bf9a 32 72 ee			ld (debug_mark+1),a  
bf9d 3a a7 bf			ld a, (.dmark+2)  
bfa0 32 73 ee			ld (debug_mark+2),a  
bfa3 18 03			jr .pastdmark  
bfa5 ..			.dmark: db "MNr"  
bfa8 f1			.pastdmark: pop af  
bfa9			endm  
# End of macro DMARK
bfa9						CALLMONITOR 
bfa9 cd a3 94			call break_point_state  
bfac				endm  
# End of macro CALLMONITOR
bfac					endif 
bfac			 
bfac cd 14 9b				call forth_push_numhl 
bfaf			 
bfaf			 
bfaf			 
bfaf			 
bfaf				       NEXTW 
bfaf c3 c1 9e			jp macro_next 
bfb2				endm 
# End of macro NEXTW
bfb2			 
bfb2			 
bfb2			.ENDDISPLAY: 
bfb2			 
bfb2			; eof 
# End of file forth_words_display.asm
bfb2			include "forth_words_str.asm" 
bfb2			 
bfb2			; | ## String Words 
bfb2			 
bfb2			.PTR:   
bfb2			 
bfb2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bfb2 48				db WORD_SYS_CORE+52             
bfb3 df bf			dw .STYPE            
bfb5 04				db 3 + 1 
bfb6 .. 00			db "PTR",0              
bfba				endm 
# End of macro CWHEAD
bfba			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bfba			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bfba			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bfba			 
bfba					if DEBUG_FORTH_WORDS_KEY 
bfba						DMARK "PTR" 
bfba f5				push af  
bfbb 3a cf bf			ld a, (.dmark)  
bfbe 32 71 ee			ld (debug_mark),a  
bfc1 3a d0 bf			ld a, (.dmark+1)  
bfc4 32 72 ee			ld (debug_mark+1),a  
bfc7 3a d1 bf			ld a, (.dmark+2)  
bfca 32 73 ee			ld (debug_mark+2),a  
bfcd 18 03			jr .pastdmark  
bfcf ..			.dmark: db "PTR"  
bfd2 f1			.pastdmark: pop af  
bfd3			endm  
# End of macro DMARK
bfd3						CALLMONITOR 
bfd3 cd a3 94			call break_point_state  
bfd6				endm  
# End of macro CALLMONITOR
bfd6					endif 
bfd6					FORTH_DSP_VALUEHL 
bfd6 cd 0b 9d			call macro_dsp_valuehl 
bfd9				endm 
# End of macro FORTH_DSP_VALUEHL
bfd9 cd 14 9b				call forth_push_numhl 
bfdc			 
bfdc			 
bfdc					NEXTW 
bfdc c3 c1 9e			jp macro_next 
bfdf				endm 
# End of macro NEXTW
bfdf			.STYPE: 
bfdf				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bfdf 48				db WORD_SYS_CORE+52             
bfe0 2e c0			dw .UPPER            
bfe2 06				db 5 + 1 
bfe3 .. 00			db "STYPE",0              
bfe9				endm 
# End of macro CWHEAD
bfe9			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bfe9					if DEBUG_FORTH_WORDS_KEY 
bfe9						DMARK "STY" 
bfe9 f5				push af  
bfea 3a fe bf			ld a, (.dmark)  
bfed 32 71 ee			ld (debug_mark),a  
bff0 3a ff bf			ld a, (.dmark+1)  
bff3 32 72 ee			ld (debug_mark+1),a  
bff6 3a 00 c0			ld a, (.dmark+2)  
bff9 32 73 ee			ld (debug_mark+2),a  
bffc 18 03			jr .pastdmark  
bffe ..			.dmark: db "STY"  
c001 f1			.pastdmark: pop af  
c002			endm  
# End of macro DMARK
c002						CALLMONITOR 
c002 cd a3 94			call break_point_state  
c005				endm  
# End of macro CALLMONITOR
c005					endif 
c005					FORTH_DSP 
c005 cd d1 9c			call macro_forth_dsp 
c008				endm 
# End of macro FORTH_DSP
c008					;v5 FORTH_DSP_VALUE 
c008			 
c008 7e					ld a, (hl) 
c009			 
c009 f5					push af 
c00a			 
c00a			; Dont destroy TOS		FORTH_DSP_POP 
c00a			 
c00a f1					pop af 
c00b			 
c00b fe 01				cp DS_TYPE_STR 
c00d 28 09				jr z, .typestr 
c00f			 
c00f fe 02				cp DS_TYPE_INUM 
c011 28 0a				jr z, .typeinum 
c013			 
c013 21 2c c0				ld hl, .tna 
c016 18 0a				jr .tpush 
c018			 
c018 21 28 c0		.typestr:	ld hl, .tstr 
c01b 18 05				jr .tpush 
c01d 21 2a c0		.typeinum:	ld hl, .tinum 
c020 18 00				jr .tpush 
c022			 
c022			.tpush: 
c022			 
c022 cd 82 9b				call forth_push_str 
c025			 
c025					NEXTW 
c025 c3 c1 9e			jp macro_next 
c028				endm 
# End of macro NEXTW
c028 .. 00		.tstr:	db "s",0 
c02a .. 00		.tinum:  db "i",0 
c02c .. 00		.tna:   db "?", 0 
c02e			 
c02e			 
c02e			.UPPER: 
c02e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c02e 48				db WORD_SYS_CORE+52             
c02f 69 c0			dw .LOWER            
c031 06				db 5 + 1 
c032 .. 00			db "UPPER",0              
c038				endm 
# End of macro CWHEAD
c038			; | UPPER ( s -- s ) Upper case string s  | DONE 
c038					if DEBUG_FORTH_WORDS_KEY 
c038						DMARK "UPR" 
c038 f5				push af  
c039 3a 4d c0			ld a, (.dmark)  
c03c 32 71 ee			ld (debug_mark),a  
c03f 3a 4e c0			ld a, (.dmark+1)  
c042 32 72 ee			ld (debug_mark+1),a  
c045 3a 4f c0			ld a, (.dmark+2)  
c048 32 73 ee			ld (debug_mark+2),a  
c04b 18 03			jr .pastdmark  
c04d ..			.dmark: db "UPR"  
c050 f1			.pastdmark: pop af  
c051			endm  
# End of macro DMARK
c051						CALLMONITOR 
c051 cd a3 94			call break_point_state  
c054				endm  
# End of macro CALLMONITOR
c054					endif 
c054			 
c054					FORTH_DSP 
c054 cd d1 9c			call macro_forth_dsp 
c057				endm 
# End of macro FORTH_DSP
c057					 
c057			; TODO check is string type 
c057			 
c057					FORTH_DSP_VALUEHL 
c057 cd 0b 9d			call macro_dsp_valuehl 
c05a				endm 
# End of macro FORTH_DSP_VALUEHL
c05a			; get pointer to string in hl 
c05a			 
c05a 7e			.toup:		ld a, (hl) 
c05b fe 00				cp 0 
c05d 28 07				jr z, .toupdone 
c05f			 
c05f cd 0f 90				call to_upper 
c062			 
c062 77					ld (hl), a 
c063 23					inc hl 
c064 18 f4				jr .toup 
c066			 
c066					 
c066			 
c066			 
c066			; for each char convert to upper 
c066					 
c066			.toupdone: 
c066			 
c066			 
c066					NEXTW 
c066 c3 c1 9e			jp macro_next 
c069				endm 
# End of macro NEXTW
c069			.LOWER: 
c069				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c069 48				db WORD_SYS_CORE+52             
c06a a4 c0			dw .TCASE            
c06c 06				db 5 + 1 
c06d .. 00			db "LOWER",0              
c073				endm 
# End of macro CWHEAD
c073			; | LOWER ( s -- s ) Lower case string s  | DONE 
c073					if DEBUG_FORTH_WORDS_KEY 
c073						DMARK "LWR" 
c073 f5				push af  
c074 3a 88 c0			ld a, (.dmark)  
c077 32 71 ee			ld (debug_mark),a  
c07a 3a 89 c0			ld a, (.dmark+1)  
c07d 32 72 ee			ld (debug_mark+1),a  
c080 3a 8a c0			ld a, (.dmark+2)  
c083 32 73 ee			ld (debug_mark+2),a  
c086 18 03			jr .pastdmark  
c088 ..			.dmark: db "LWR"  
c08b f1			.pastdmark: pop af  
c08c			endm  
# End of macro DMARK
c08c						CALLMONITOR 
c08c cd a3 94			call break_point_state  
c08f				endm  
# End of macro CALLMONITOR
c08f					endif 
c08f			 
c08f					FORTH_DSP 
c08f cd d1 9c			call macro_forth_dsp 
c092				endm 
# End of macro FORTH_DSP
c092					 
c092			; TODO check is string type 
c092			 
c092					FORTH_DSP_VALUEHL 
c092 cd 0b 9d			call macro_dsp_valuehl 
c095				endm 
# End of macro FORTH_DSP_VALUEHL
c095			; get pointer to string in hl 
c095			 
c095 7e			.tolow:		ld a, (hl) 
c096 fe 00				cp 0 
c098 28 07				jr z, .tolowdone 
c09a			 
c09a cd 18 90				call to_lower 
c09d			 
c09d 77					ld (hl), a 
c09e 23					inc hl 
c09f 18 f4				jr .tolow 
c0a1			 
c0a1					 
c0a1			 
c0a1			 
c0a1			; for each char convert to low 
c0a1					 
c0a1			.tolowdone: 
c0a1					NEXTW 
c0a1 c3 c1 9e			jp macro_next 
c0a4				endm 
# End of macro NEXTW
c0a4			.TCASE: 
c0a4				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c0a4 48				db WORD_SYS_CORE+52             
c0a5 da c1			dw .SUBSTR            
c0a7 06				db 5 + 1 
c0a8 .. 00			db "TCASE",0              
c0ae				endm 
# End of macro CWHEAD
c0ae			; | TCASE ( s -- s ) Title case string s  | DONE 
c0ae					if DEBUG_FORTH_WORDS_KEY 
c0ae						DMARK "TCS" 
c0ae f5				push af  
c0af 3a c3 c0			ld a, (.dmark)  
c0b2 32 71 ee			ld (debug_mark),a  
c0b5 3a c4 c0			ld a, (.dmark+1)  
c0b8 32 72 ee			ld (debug_mark+1),a  
c0bb 3a c5 c0			ld a, (.dmark+2)  
c0be 32 73 ee			ld (debug_mark+2),a  
c0c1 18 03			jr .pastdmark  
c0c3 ..			.dmark: db "TCS"  
c0c6 f1			.pastdmark: pop af  
c0c7			endm  
# End of macro DMARK
c0c7						CALLMONITOR 
c0c7 cd a3 94			call break_point_state  
c0ca				endm  
# End of macro CALLMONITOR
c0ca					endif 
c0ca			 
c0ca					FORTH_DSP 
c0ca cd d1 9c			call macro_forth_dsp 
c0cd				endm 
# End of macro FORTH_DSP
c0cd					 
c0cd			; TODO check is string type 
c0cd			 
c0cd					FORTH_DSP_VALUEHL 
c0cd cd 0b 9d			call macro_dsp_valuehl 
c0d0				endm 
# End of macro FORTH_DSP_VALUEHL
c0d0			; get pointer to string in hl 
c0d0			 
c0d0					if DEBUG_FORTH_WORDS 
c0d0						DMARK "TC1" 
c0d0 f5				push af  
c0d1 3a e5 c0			ld a, (.dmark)  
c0d4 32 71 ee			ld (debug_mark),a  
c0d7 3a e6 c0			ld a, (.dmark+1)  
c0da 32 72 ee			ld (debug_mark+1),a  
c0dd 3a e7 c0			ld a, (.dmark+2)  
c0e0 32 73 ee			ld (debug_mark+2),a  
c0e3 18 03			jr .pastdmark  
c0e5 ..			.dmark: db "TC1"  
c0e8 f1			.pastdmark: pop af  
c0e9			endm  
# End of macro DMARK
c0e9						CALLMONITOR 
c0e9 cd a3 94			call break_point_state  
c0ec				endm  
# End of macro CALLMONITOR
c0ec					endif 
c0ec			 
c0ec					; first time in turn to upper case first char 
c0ec			 
c0ec 7e					ld a, (hl) 
c0ed c3 77 c1				jp .totsiptou 
c0f0			 
c0f0			 
c0f0 7e			.tot:		ld a, (hl) 
c0f1 fe 00				cp 0 
c0f3 ca bb c1				jp z, .totdone 
c0f6			 
c0f6					if DEBUG_FORTH_WORDS 
c0f6						DMARK "TC2" 
c0f6 f5				push af  
c0f7 3a 0b c1			ld a, (.dmark)  
c0fa 32 71 ee			ld (debug_mark),a  
c0fd 3a 0c c1			ld a, (.dmark+1)  
c100 32 72 ee			ld (debug_mark+1),a  
c103 3a 0d c1			ld a, (.dmark+2)  
c106 32 73 ee			ld (debug_mark+2),a  
c109 18 03			jr .pastdmark  
c10b ..			.dmark: db "TC2"  
c10e f1			.pastdmark: pop af  
c10f			endm  
# End of macro DMARK
c10f						CALLMONITOR 
c10f cd a3 94			call break_point_state  
c112				endm  
# End of macro CALLMONITOR
c112					endif 
c112					; check to see if current char is a space 
c112			 
c112 fe 20				cp ' ' 
c114 28 21				jr z, .totsp 
c116 cd 18 90				call to_lower 
c119					if DEBUG_FORTH_WORDS 
c119						DMARK "TC3" 
c119 f5				push af  
c11a 3a 2e c1			ld a, (.dmark)  
c11d 32 71 ee			ld (debug_mark),a  
c120 3a 2f c1			ld a, (.dmark+1)  
c123 32 72 ee			ld (debug_mark+1),a  
c126 3a 30 c1			ld a, (.dmark+2)  
c129 32 73 ee			ld (debug_mark+2),a  
c12c 18 03			jr .pastdmark  
c12e ..			.dmark: db "TC3"  
c131 f1			.pastdmark: pop af  
c132			endm  
# End of macro DMARK
c132						CALLMONITOR 
c132 cd a3 94			call break_point_state  
c135				endm  
# End of macro CALLMONITOR
c135					endif 
c135 18 63				jr .totnxt 
c137			 
c137			.totsp:         ; on a space, find next char which should be upper 
c137			 
c137					if DEBUG_FORTH_WORDS 
c137						DMARK "TC4" 
c137 f5				push af  
c138 3a 4c c1			ld a, (.dmark)  
c13b 32 71 ee			ld (debug_mark),a  
c13e 3a 4d c1			ld a, (.dmark+1)  
c141 32 72 ee			ld (debug_mark+1),a  
c144 3a 4e c1			ld a, (.dmark+2)  
c147 32 73 ee			ld (debug_mark+2),a  
c14a 18 03			jr .pastdmark  
c14c ..			.dmark: db "TC4"  
c14f f1			.pastdmark: pop af  
c150			endm  
# End of macro DMARK
c150						CALLMONITOR 
c150 cd a3 94			call break_point_state  
c153				endm  
# End of macro CALLMONITOR
c153					endif 
c153					;; 
c153			 
c153 fe 20				cp ' ' 
c155 20 20				jr nz, .totsiptou 
c157 23					inc hl 
c158 7e					ld a, (hl) 
c159					if DEBUG_FORTH_WORDS 
c159						DMARK "TC5" 
c159 f5				push af  
c15a 3a 6e c1			ld a, (.dmark)  
c15d 32 71 ee			ld (debug_mark),a  
c160 3a 6f c1			ld a, (.dmark+1)  
c163 32 72 ee			ld (debug_mark+1),a  
c166 3a 70 c1			ld a, (.dmark+2)  
c169 32 73 ee			ld (debug_mark+2),a  
c16c 18 03			jr .pastdmark  
c16e ..			.dmark: db "TC5"  
c171 f1			.pastdmark: pop af  
c172			endm  
# End of macro DMARK
c172						CALLMONITOR 
c172 cd a3 94			call break_point_state  
c175				endm  
# End of macro CALLMONITOR
c175					endif 
c175 18 c0				jr .totsp 
c177 fe 00		.totsiptou:    cp 0 
c179 28 40				jr z, .totdone 
c17b					; not space and not zero term so upper case it 
c17b cd 0f 90				call to_upper 
c17e			 
c17e					if DEBUG_FORTH_WORDS 
c17e						DMARK "TC6" 
c17e f5				push af  
c17f 3a 93 c1			ld a, (.dmark)  
c182 32 71 ee			ld (debug_mark),a  
c185 3a 94 c1			ld a, (.dmark+1)  
c188 32 72 ee			ld (debug_mark+1),a  
c18b 3a 95 c1			ld a, (.dmark+2)  
c18e 32 73 ee			ld (debug_mark+2),a  
c191 18 03			jr .pastdmark  
c193 ..			.dmark: db "TC6"  
c196 f1			.pastdmark: pop af  
c197			endm  
# End of macro DMARK
c197						CALLMONITOR 
c197 cd a3 94			call break_point_state  
c19a				endm  
# End of macro CALLMONITOR
c19a					endif 
c19a			 
c19a			 
c19a			.totnxt: 
c19a			 
c19a 77					ld (hl), a 
c19b 23					inc hl 
c19c					if DEBUG_FORTH_WORDS 
c19c						DMARK "TC7" 
c19c f5				push af  
c19d 3a b1 c1			ld a, (.dmark)  
c1a0 32 71 ee			ld (debug_mark),a  
c1a3 3a b2 c1			ld a, (.dmark+1)  
c1a6 32 72 ee			ld (debug_mark+1),a  
c1a9 3a b3 c1			ld a, (.dmark+2)  
c1ac 32 73 ee			ld (debug_mark+2),a  
c1af 18 03			jr .pastdmark  
c1b1 ..			.dmark: db "TC7"  
c1b4 f1			.pastdmark: pop af  
c1b5			endm  
# End of macro DMARK
c1b5						CALLMONITOR 
c1b5 cd a3 94			call break_point_state  
c1b8				endm  
# End of macro CALLMONITOR
c1b8					endif 
c1b8 c3 f0 c0				jp .tot 
c1bb			 
c1bb					 
c1bb			 
c1bb			 
c1bb			; for each char convert to low 
c1bb					 
c1bb			.totdone: 
c1bb					if DEBUG_FORTH_WORDS 
c1bb						DMARK "TCd" 
c1bb f5				push af  
c1bc 3a d0 c1			ld a, (.dmark)  
c1bf 32 71 ee			ld (debug_mark),a  
c1c2 3a d1 c1			ld a, (.dmark+1)  
c1c5 32 72 ee			ld (debug_mark+1),a  
c1c8 3a d2 c1			ld a, (.dmark+2)  
c1cb 32 73 ee			ld (debug_mark+2),a  
c1ce 18 03			jr .pastdmark  
c1d0 ..			.dmark: db "TCd"  
c1d3 f1			.pastdmark: pop af  
c1d4			endm  
# End of macro DMARK
c1d4						CALLMONITOR 
c1d4 cd a3 94			call break_point_state  
c1d7				endm  
# End of macro CALLMONITOR
c1d7					endif 
c1d7					NEXTW 
c1d7 c3 c1 9e			jp macro_next 
c1da				endm 
# End of macro NEXTW
c1da			 
c1da			.SUBSTR: 
c1da				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c1da 48				db WORD_SYS_CORE+52             
c1db 38 c2			dw .LEFT            
c1dd 07				db 6 + 1 
c1de .. 00			db "SUBSTR",0              
c1e5				endm 
# End of macro CWHEAD
c1e5			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c1e5			 
c1e5					if DEBUG_FORTH_WORDS_KEY 
c1e5						DMARK "SST" 
c1e5 f5				push af  
c1e6 3a fa c1			ld a, (.dmark)  
c1e9 32 71 ee			ld (debug_mark),a  
c1ec 3a fb c1			ld a, (.dmark+1)  
c1ef 32 72 ee			ld (debug_mark+1),a  
c1f2 3a fc c1			ld a, (.dmark+2)  
c1f5 32 73 ee			ld (debug_mark+2),a  
c1f8 18 03			jr .pastdmark  
c1fa ..			.dmark: db "SST"  
c1fd f1			.pastdmark: pop af  
c1fe			endm  
# End of macro DMARK
c1fe						CALLMONITOR 
c1fe cd a3 94			call break_point_state  
c201				endm  
# End of macro CALLMONITOR
c201					endif 
c201			; TODO check string type 
c201					FORTH_DSP_VALUEHL 
c201 cd 0b 9d			call macro_dsp_valuehl 
c204				endm 
# End of macro FORTH_DSP_VALUEHL
c204			 
c204 e5					push hl      ; string length 
c205			 
c205					FORTH_DSP_POP 
c205 cd c3 9d			call macro_forth_dsp_pop 
c208				endm 
# End of macro FORTH_DSP_POP
c208			 
c208					FORTH_DSP_VALUEHL 
c208 cd 0b 9d			call macro_dsp_valuehl 
c20b				endm 
# End of macro FORTH_DSP_VALUEHL
c20b			 
c20b e5					push hl     ; start char 
c20c			 
c20c					FORTH_DSP_POP 
c20c cd c3 9d			call macro_forth_dsp_pop 
c20f				endm 
# End of macro FORTH_DSP_POP
c20f			 
c20f			 
c20f					FORTH_DSP_VALUE 
c20f cd f4 9c			call macro_forth_dsp_value 
c212				endm 
# End of macro FORTH_DSP_VALUE
c212			 
c212 d1					pop de    ; get start post offset 
c213			 
c213 19					add hl, de    ; starting offset 
c214			 
c214 c1					pop bc 
c215 c5					push bc      ; grab size of string 
c216			 
c216 e5					push hl    ; save string start  
c217			 
c217 26 00				ld h, 0 
c219 69					ld l, c 
c21a 23					inc hl 
c21b 23					inc hl 
c21c			 
c21c cd 69 91				call malloc 
c21f				if DEBUG_FORTH_MALLOC_GUARD 
c21f cc 80 cb				call z,malloc_error 
c222				endif 
c222			 
c222 eb					ex de, hl      ; save malloc area for string copy 
c223 e1					pop hl    ; get back source 
c224 c1					pop bc    ; get length of string back 
c225			 
c225 d5					push de    ; save malloc area for after we push 
c226 ed b0				ldir     ; copy substr 
c228			 
c228			 
c228 eb					ex de, hl 
c229 3e 00				ld a, 0 
c22b 77					ld (hl), a   ; term substr 
c22c			 
c22c					 
c22c e1					pop hl    ; get malloc so we can push it 
c22d e5					push hl   ; save so we can free it afterwards 
c22e			 
c22e cd 82 9b				call forth_push_str 
c231			 
c231 e1					pop hl 
c232 cd 33 92				call free 
c235			 
c235					 
c235					 
c235			 
c235			 
c235					NEXTW 
c235 c3 c1 9e			jp macro_next 
c238				endm 
# End of macro NEXTW
c238			 
c238			.LEFT: 
c238				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c238 48				db WORD_SYS_CORE+52             
c239 60 c2			dw .RIGHT            
c23b 05				db 4 + 1 
c23c .. 00			db "LEFT",0              
c241				endm 
# End of macro CWHEAD
c241			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c241					if DEBUG_FORTH_WORDS_KEY 
c241						DMARK "LEF" 
c241 f5				push af  
c242 3a 56 c2			ld a, (.dmark)  
c245 32 71 ee			ld (debug_mark),a  
c248 3a 57 c2			ld a, (.dmark+1)  
c24b 32 72 ee			ld (debug_mark+1),a  
c24e 3a 58 c2			ld a, (.dmark+2)  
c251 32 73 ee			ld (debug_mark+2),a  
c254 18 03			jr .pastdmark  
c256 ..			.dmark: db "LEF"  
c259 f1			.pastdmark: pop af  
c25a			endm  
# End of macro DMARK
c25a						CALLMONITOR 
c25a cd a3 94			call break_point_state  
c25d				endm  
# End of macro CALLMONITOR
c25d					endif 
c25d			 
c25d					NEXTW 
c25d c3 c1 9e			jp macro_next 
c260				endm 
# End of macro NEXTW
c260			.RIGHT: 
c260				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c260 48				db WORD_SYS_CORE+52             
c261 89 c2			dw .STR2NUM            
c263 06				db 5 + 1 
c264 .. 00			db "RIGHT",0              
c26a				endm 
# End of macro CWHEAD
c26a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c26a					if DEBUG_FORTH_WORDS_KEY 
c26a						DMARK "RIG" 
c26a f5				push af  
c26b 3a 7f c2			ld a, (.dmark)  
c26e 32 71 ee			ld (debug_mark),a  
c271 3a 80 c2			ld a, (.dmark+1)  
c274 32 72 ee			ld (debug_mark+1),a  
c277 3a 81 c2			ld a, (.dmark+2)  
c27a 32 73 ee			ld (debug_mark+2),a  
c27d 18 03			jr .pastdmark  
c27f ..			.dmark: db "RIG"  
c282 f1			.pastdmark: pop af  
c283			endm  
# End of macro DMARK
c283						CALLMONITOR 
c283 cd a3 94			call break_point_state  
c286				endm  
# End of macro CALLMONITOR
c286					endif 
c286			 
c286					NEXTW 
c286 c3 c1 9e			jp macro_next 
c289				endm 
# End of macro NEXTW
c289			 
c289			 
c289			.STR2NUM: 
c289				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c289 48				db WORD_SYS_CORE+52             
c28a 15 c3			dw .NUM2STR            
c28c 08				db 7 + 1 
c28d .. 00			db "STR2NUM",0              
c295				endm 
# End of macro CWHEAD
c295			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c295			 
c295			 
c295			; TODO STR type check to do 
c295					if DEBUG_FORTH_WORDS_KEY 
c295						DMARK "S2N" 
c295 f5				push af  
c296 3a aa c2			ld a, (.dmark)  
c299 32 71 ee			ld (debug_mark),a  
c29c 3a ab c2			ld a, (.dmark+1)  
c29f 32 72 ee			ld (debug_mark+1),a  
c2a2 3a ac c2			ld a, (.dmark+2)  
c2a5 32 73 ee			ld (debug_mark+2),a  
c2a8 18 03			jr .pastdmark  
c2aa ..			.dmark: db "S2N"  
c2ad f1			.pastdmark: pop af  
c2ae			endm  
# End of macro DMARK
c2ae						CALLMONITOR 
c2ae cd a3 94			call break_point_state  
c2b1				endm  
# End of macro CALLMONITOR
c2b1					endif 
c2b1			 
c2b1					;FORTH_DSP 
c2b1					FORTH_DSP_VALUE 
c2b1 cd f4 9c			call macro_forth_dsp_value 
c2b4				endm 
# End of macro FORTH_DSP_VALUE
c2b4					;inc hl 
c2b4			 
c2b4 eb					ex de, hl 
c2b5					if DEBUG_FORTH_WORDS 
c2b5						DMARK "S2a" 
c2b5 f5				push af  
c2b6 3a ca c2			ld a, (.dmark)  
c2b9 32 71 ee			ld (debug_mark),a  
c2bc 3a cb c2			ld a, (.dmark+1)  
c2bf 32 72 ee			ld (debug_mark+1),a  
c2c2 3a cc c2			ld a, (.dmark+2)  
c2c5 32 73 ee			ld (debug_mark+2),a  
c2c8 18 03			jr .pastdmark  
c2ca ..			.dmark: db "S2a"  
c2cd f1			.pastdmark: pop af  
c2ce			endm  
# End of macro DMARK
c2ce						CALLMONITOR 
c2ce cd a3 94			call break_point_state  
c2d1				endm  
# End of macro CALLMONITOR
c2d1					endif 
c2d1 cd 97 90				call string_to_uint16 
c2d4			 
c2d4					if DEBUG_FORTH_WORDS 
c2d4						DMARK "S2b" 
c2d4 f5				push af  
c2d5 3a e9 c2			ld a, (.dmark)  
c2d8 32 71 ee			ld (debug_mark),a  
c2db 3a ea c2			ld a, (.dmark+1)  
c2de 32 72 ee			ld (debug_mark+1),a  
c2e1 3a eb c2			ld a, (.dmark+2)  
c2e4 32 73 ee			ld (debug_mark+2),a  
c2e7 18 03			jr .pastdmark  
c2e9 ..			.dmark: db "S2b"  
c2ec f1			.pastdmark: pop af  
c2ed			endm  
# End of macro DMARK
c2ed						CALLMONITOR 
c2ed cd a3 94			call break_point_state  
c2f0				endm  
# End of macro CALLMONITOR
c2f0					endif 
c2f0			;		push hl 
c2f0					FORTH_DSP_POP 
c2f0 cd c3 9d			call macro_forth_dsp_pop 
c2f3				endm 
# End of macro FORTH_DSP_POP
c2f3			;		pop hl 
c2f3					 
c2f3					if DEBUG_FORTH_WORDS 
c2f3						DMARK "S2b" 
c2f3 f5				push af  
c2f4 3a 08 c3			ld a, (.dmark)  
c2f7 32 71 ee			ld (debug_mark),a  
c2fa 3a 09 c3			ld a, (.dmark+1)  
c2fd 32 72 ee			ld (debug_mark+1),a  
c300 3a 0a c3			ld a, (.dmark+2)  
c303 32 73 ee			ld (debug_mark+2),a  
c306 18 03			jr .pastdmark  
c308 ..			.dmark: db "S2b"  
c30b f1			.pastdmark: pop af  
c30c			endm  
# End of macro DMARK
c30c						CALLMONITOR 
c30c cd a3 94			call break_point_state  
c30f				endm  
# End of macro CALLMONITOR
c30f					endif 
c30f cd 14 9b				call forth_push_numhl	 
c312			 
c312				 
c312				       NEXTW 
c312 c3 c1 9e			jp macro_next 
c315				endm 
# End of macro NEXTW
c315			.NUM2STR: 
c315				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c315 48				db WORD_SYS_CORE+52             
c316 24 c3			dw .CONCAT            
c318 08				db 7 + 1 
c319 .. 00			db "NUM2STR",0              
c321				endm 
# End of macro CWHEAD
c321			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c321			 
c321			;		; malloc a string to target 
c321			;		ld hl, 10     ; TODO max string size should be fine 
c321			;		call malloc 
c321			;		push hl    ; save malloc location 
c321			; 
c321			; 
c321			;; TODO check int type 
c321			;		FORTH_DSP_VALUEHL 
c321			;		ld a, l 
c321			;		call DispAToASCII   
c321			;;TODO need to chage above call to dump into string 
c321			; 
c321			; 
c321			 
c321				       NEXTW 
c321 c3 c1 9e			jp macro_next 
c324				endm 
# End of macro NEXTW
c324			 
c324			.CONCAT: 
c324				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c324 48				db WORD_SYS_CORE+52             
c325 d7 c3			dw .FIND            
c327 07				db 6 + 1 
c328 .. 00			db "CONCAT",0              
c32f				endm 
# End of macro CWHEAD
c32f			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c32f			 
c32f			; TODO check string type 
c32f			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c32f			 
c32f					if DEBUG_FORTH_WORDS_KEY 
c32f						DMARK "CON" 
c32f f5				push af  
c330 3a 44 c3			ld a, (.dmark)  
c333 32 71 ee			ld (debug_mark),a  
c336 3a 45 c3			ld a, (.dmark+1)  
c339 32 72 ee			ld (debug_mark+1),a  
c33c 3a 46 c3			ld a, (.dmark+2)  
c33f 32 73 ee			ld (debug_mark+2),a  
c342 18 03			jr .pastdmark  
c344 ..			.dmark: db "CON"  
c347 f1			.pastdmark: pop af  
c348			endm  
# End of macro DMARK
c348						CALLMONITOR 
c348 cd a3 94			call break_point_state  
c34b				endm  
# End of macro CALLMONITOR
c34b					endif 
c34b			 
c34b			 
c34b					FORTH_DSP_VALUE 
c34b cd f4 9c			call macro_forth_dsp_value 
c34e				endm 
# End of macro FORTH_DSP_VALUE
c34e e5					push hl   ; s2 
c34f			 
c34f					FORTH_DSP_POP 
c34f cd c3 9d			call macro_forth_dsp_pop 
c352				endm 
# End of macro FORTH_DSP_POP
c352			 
c352					FORTH_DSP_VALUE 
c352 cd f4 9c			call macro_forth_dsp_value 
c355				endm 
# End of macro FORTH_DSP_VALUE
c355			 
c355 e5					push hl   ; s1 
c356			 
c356					FORTH_DSP_POP 
c356 cd c3 9d			call macro_forth_dsp_pop 
c359				endm 
# End of macro FORTH_DSP_POP
c359					 
c359			 
c359					; copy s1 
c359			 
c359				 
c359					; save ptr 
c359 e1					pop hl  
c35a e5					push hl 
c35b 3e 00				ld a, 0 
c35d cd 0b 91				call strlent 
c360					;inc hl    ; zer0 
c360 06 00				ld b, 0 
c362 4d					ld c, l 
c363 e1					pop hl		 
c364 11 cb e2				ld de, scratch	 
c367					if DEBUG_FORTH_WORDS 
c367						DMARK "CO1" 
c367 f5				push af  
c368 3a 7c c3			ld a, (.dmark)  
c36b 32 71 ee			ld (debug_mark),a  
c36e 3a 7d c3			ld a, (.dmark+1)  
c371 32 72 ee			ld (debug_mark+1),a  
c374 3a 7e c3			ld a, (.dmark+2)  
c377 32 73 ee			ld (debug_mark+2),a  
c37a 18 03			jr .pastdmark  
c37c ..			.dmark: db "CO1"  
c37f f1			.pastdmark: pop af  
c380			endm  
# End of macro DMARK
c380						CALLMONITOR 
c380 cd a3 94			call break_point_state  
c383				endm  
# End of macro CALLMONITOR
c383					endif 
c383 ed b0				ldir 
c385			 
c385 e1					pop hl 
c386 e5					push hl 
c387 d5					push de 
c388			 
c388			 
c388 3e 00				ld a, 0 
c38a cd 0b 91				call strlent 
c38d 23					inc hl    ; zer0 
c38e 23					inc hl 
c38f 06 00				ld b, 0 
c391 4d					ld c, l 
c392 d1					pop de 
c393 e1					pop hl		 
c394					if DEBUG_FORTH_WORDS 
c394						DMARK "CO2" 
c394 f5				push af  
c395 3a a9 c3			ld a, (.dmark)  
c398 32 71 ee			ld (debug_mark),a  
c39b 3a aa c3			ld a, (.dmark+1)  
c39e 32 72 ee			ld (debug_mark+1),a  
c3a1 3a ab c3			ld a, (.dmark+2)  
c3a4 32 73 ee			ld (debug_mark+2),a  
c3a7 18 03			jr .pastdmark  
c3a9 ..			.dmark: db "CO2"  
c3ac f1			.pastdmark: pop af  
c3ad			endm  
# End of macro DMARK
c3ad						CALLMONITOR 
c3ad cd a3 94			call break_point_state  
c3b0				endm  
# End of macro CALLMONITOR
c3b0					endif 
c3b0 ed b0				ldir 
c3b2			 
c3b2			 
c3b2			 
c3b2 21 cb e2				ld hl, scratch 
c3b5					if DEBUG_FORTH_WORDS 
c3b5						DMARK "CO5" 
c3b5 f5				push af  
c3b6 3a ca c3			ld a, (.dmark)  
c3b9 32 71 ee			ld (debug_mark),a  
c3bc 3a cb c3			ld a, (.dmark+1)  
c3bf 32 72 ee			ld (debug_mark+1),a  
c3c2 3a cc c3			ld a, (.dmark+2)  
c3c5 32 73 ee			ld (debug_mark+2),a  
c3c8 18 03			jr .pastdmark  
c3ca ..			.dmark: db "CO5"  
c3cd f1			.pastdmark: pop af  
c3ce			endm  
# End of macro DMARK
c3ce						CALLMONITOR 
c3ce cd a3 94			call break_point_state  
c3d1				endm  
# End of macro CALLMONITOR
c3d1					endif 
c3d1			 
c3d1 cd 82 9b				call forth_push_str 
c3d4			 
c3d4			 
c3d4			 
c3d4			 
c3d4				       NEXTW 
c3d4 c3 c1 9e			jp macro_next 
c3d7				endm 
# End of macro NEXTW
c3d7			 
c3d7			 
c3d7			.FIND: 
c3d7				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c3d7 4b				db WORD_SYS_CORE+55             
c3d8 95 c4			dw .LEN            
c3da 05				db 4 + 1 
c3db .. 00			db "FIND",0              
c3e0				endm 
# End of macro CWHEAD
c3e0			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c3e0			 
c3e0					if DEBUG_FORTH_WORDS_KEY 
c3e0						DMARK "FND" 
c3e0 f5				push af  
c3e1 3a f5 c3			ld a, (.dmark)  
c3e4 32 71 ee			ld (debug_mark),a  
c3e7 3a f6 c3			ld a, (.dmark+1)  
c3ea 32 72 ee			ld (debug_mark+1),a  
c3ed 3a f7 c3			ld a, (.dmark+2)  
c3f0 32 73 ee			ld (debug_mark+2),a  
c3f3 18 03			jr .pastdmark  
c3f5 ..			.dmark: db "FND"  
c3f8 f1			.pastdmark: pop af  
c3f9			endm  
# End of macro DMARK
c3f9						CALLMONITOR 
c3f9 cd a3 94			call break_point_state  
c3fc				endm  
# End of macro CALLMONITOR
c3fc					endif 
c3fc			 
c3fc			; TODO check string type 
c3fc					FORTH_DSP_VALUE 
c3fc cd f4 9c			call macro_forth_dsp_value 
c3ff				endm 
# End of macro FORTH_DSP_VALUE
c3ff			 
c3ff e5					push hl    
c400 7e					ld a,(hl)    ; char to find   
c401			; TODO change char to substr 
c401			 
c401 f5					push af 
c402					 
c402			 
c402			 
c402					if DEBUG_FORTH_WORDS 
c402						DMARK "FN1" 
c402 f5				push af  
c403 3a 17 c4			ld a, (.dmark)  
c406 32 71 ee			ld (debug_mark),a  
c409 3a 18 c4			ld a, (.dmark+1)  
c40c 32 72 ee			ld (debug_mark+1),a  
c40f 3a 19 c4			ld a, (.dmark+2)  
c412 32 73 ee			ld (debug_mark+2),a  
c415 18 03			jr .pastdmark  
c417 ..			.dmark: db "FN1"  
c41a f1			.pastdmark: pop af  
c41b			endm  
# End of macro DMARK
c41b						CALLMONITOR 
c41b cd a3 94			call break_point_state  
c41e				endm  
# End of macro CALLMONITOR
c41e					endif 
c41e			 
c41e					FORTH_DSP_POP 
c41e cd c3 9d			call macro_forth_dsp_pop 
c421				endm 
# End of macro FORTH_DSP_POP
c421			 
c421					; string to search 
c421			 
c421					FORTH_DSP_VALUE 
c421 cd f4 9c			call macro_forth_dsp_value 
c424				endm 
# End of macro FORTH_DSP_VALUE
c424			 
c424 d1					pop de  ; d is char to find  
c425			 
c425					if DEBUG_FORTH_WORDS 
c425						DMARK "FN2" 
c425 f5				push af  
c426 3a 3a c4			ld a, (.dmark)  
c429 32 71 ee			ld (debug_mark),a  
c42c 3a 3b c4			ld a, (.dmark+1)  
c42f 32 72 ee			ld (debug_mark+1),a  
c432 3a 3c c4			ld a, (.dmark+2)  
c435 32 73 ee			ld (debug_mark+2),a  
c438 18 03			jr .pastdmark  
c43a ..			.dmark: db "FN2"  
c43d f1			.pastdmark: pop af  
c43e			endm  
# End of macro DMARK
c43e						CALLMONITOR 
c43e cd a3 94			call break_point_state  
c441				endm  
# End of macro CALLMONITOR
c441					endif 
c441					 
c441 01 00 00				ld bc, 0 
c444 7e			.findchar:      ld a,(hl) 
c445 fe 00				cp 0   		 
c447 28 27				jr z, .finddone     
c449 ba					cp d 
c44a 28 20				jr z, .foundchar 
c44c 03					inc bc 
c44d 23					inc hl 
c44e					if DEBUG_FORTH_WORDS 
c44e						DMARK "FN3" 
c44e f5				push af  
c44f 3a 63 c4			ld a, (.dmark)  
c452 32 71 ee			ld (debug_mark),a  
c455 3a 64 c4			ld a, (.dmark+1)  
c458 32 72 ee			ld (debug_mark+1),a  
c45b 3a 65 c4			ld a, (.dmark+2)  
c45e 32 73 ee			ld (debug_mark+2),a  
c461 18 03			jr .pastdmark  
c463 ..			.dmark: db "FN3"  
c466 f1			.pastdmark: pop af  
c467			endm  
# End of macro DMARK
c467						CALLMONITOR 
c467 cd a3 94			call break_point_state  
c46a				endm  
# End of macro CALLMONITOR
c46a					endif 
c46a 18 d8				jr .findchar 
c46c			 
c46c			 
c46c c5			.foundchar:	push bc 
c46d e1					pop hl 
c46e 18 03				jr .findexit 
c470			 
c470			 
c470							 
c470			 
c470			.finddone:     ; got to end of string with no find 
c470 21 00 00				ld hl, 0 
c473			.findexit: 
c473			 
c473					if DEBUG_FORTH_WORDS 
c473						DMARK "FNd" 
c473 f5				push af  
c474 3a 88 c4			ld a, (.dmark)  
c477 32 71 ee			ld (debug_mark),a  
c47a 3a 89 c4			ld a, (.dmark+1)  
c47d 32 72 ee			ld (debug_mark+1),a  
c480 3a 8a c4			ld a, (.dmark+2)  
c483 32 73 ee			ld (debug_mark+2),a  
c486 18 03			jr .pastdmark  
c488 ..			.dmark: db "FNd"  
c48b f1			.pastdmark: pop af  
c48c			endm  
# End of macro DMARK
c48c						CALLMONITOR 
c48c cd a3 94			call break_point_state  
c48f				endm  
# End of macro CALLMONITOR
c48f					endif 
c48f cd 14 9b			call forth_push_numhl 
c492			 
c492				       NEXTW 
c492 c3 c1 9e			jp macro_next 
c495				endm 
# End of macro NEXTW
c495			 
c495			.LEN: 
c495				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c495 4c				db WORD_SYS_CORE+56             
c496 ff c4			dw .ASC            
c498 06				db 5 + 1 
c499 .. 00			db "COUNT",0              
c49f				endm 
# End of macro CWHEAD
c49f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c49f			 
c49f					if DEBUG_FORTH_WORDS_KEY 
c49f						DMARK "CNT" 
c49f f5				push af  
c4a0 3a b4 c4			ld a, (.dmark)  
c4a3 32 71 ee			ld (debug_mark),a  
c4a6 3a b5 c4			ld a, (.dmark+1)  
c4a9 32 72 ee			ld (debug_mark+1),a  
c4ac 3a b6 c4			ld a, (.dmark+2)  
c4af 32 73 ee			ld (debug_mark+2),a  
c4b2 18 03			jr .pastdmark  
c4b4 ..			.dmark: db "CNT"  
c4b7 f1			.pastdmark: pop af  
c4b8			endm  
# End of macro DMARK
c4b8						CALLMONITOR 
c4b8 cd a3 94			call break_point_state  
c4bb				endm  
# End of macro CALLMONITOR
c4bb					endif 
c4bb			; TODO check string type 
c4bb					FORTH_DSP_VALUE 
c4bb cd f4 9c			call macro_forth_dsp_value 
c4be				endm 
# End of macro FORTH_DSP_VALUE
c4be			 
c4be			 
c4be					if DEBUG_FORTH_WORDS 
c4be						DMARK "CN?" 
c4be f5				push af  
c4bf 3a d3 c4			ld a, (.dmark)  
c4c2 32 71 ee			ld (debug_mark),a  
c4c5 3a d4 c4			ld a, (.dmark+1)  
c4c8 32 72 ee			ld (debug_mark+1),a  
c4cb 3a d5 c4			ld a, (.dmark+2)  
c4ce 32 73 ee			ld (debug_mark+2),a  
c4d1 18 03			jr .pastdmark  
c4d3 ..			.dmark: db "CN?"  
c4d6 f1			.pastdmark: pop af  
c4d7			endm  
# End of macro DMARK
c4d7						CALLMONITOR 
c4d7 cd a3 94			call break_point_state  
c4da				endm  
# End of macro CALLMONITOR
c4da					endif 
c4da cd 00 91				call strlenz 
c4dd					if DEBUG_FORTH_WORDS 
c4dd						DMARK "CNl" 
c4dd f5				push af  
c4de 3a f2 c4			ld a, (.dmark)  
c4e1 32 71 ee			ld (debug_mark),a  
c4e4 3a f3 c4			ld a, (.dmark+1)  
c4e7 32 72 ee			ld (debug_mark+1),a  
c4ea 3a f4 c4			ld a, (.dmark+2)  
c4ed 32 73 ee			ld (debug_mark+2),a  
c4f0 18 03			jr .pastdmark  
c4f2 ..			.dmark: db "CNl"  
c4f5 f1			.pastdmark: pop af  
c4f6			endm  
# End of macro DMARK
c4f6						CALLMONITOR 
c4f6 cd a3 94			call break_point_state  
c4f9				endm  
# End of macro CALLMONITOR
c4f9					endif 
c4f9			 
c4f9 cd 14 9b				call forth_push_numhl 
c4fc			 
c4fc			 
c4fc			 
c4fc				       NEXTW 
c4fc c3 c1 9e			jp macro_next 
c4ff				endm 
# End of macro NEXTW
c4ff			.ASC: 
c4ff				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c4ff 4d				db WORD_SYS_CORE+57             
c500 6d c5			dw .CHR            
c502 04				db 3 + 1 
c503 .. 00			db "ASC",0              
c507				endm 
# End of macro CWHEAD
c507			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c507					if DEBUG_FORTH_WORDS_KEY 
c507						DMARK "ASC" 
c507 f5				push af  
c508 3a 1c c5			ld a, (.dmark)  
c50b 32 71 ee			ld (debug_mark),a  
c50e 3a 1d c5			ld a, (.dmark+1)  
c511 32 72 ee			ld (debug_mark+1),a  
c514 3a 1e c5			ld a, (.dmark+2)  
c517 32 73 ee			ld (debug_mark+2),a  
c51a 18 03			jr .pastdmark  
c51c ..			.dmark: db "ASC"  
c51f f1			.pastdmark: pop af  
c520			endm  
# End of macro DMARK
c520						CALLMONITOR 
c520 cd a3 94			call break_point_state  
c523				endm  
# End of macro CALLMONITOR
c523					endif 
c523					FORTH_DSP_VALUE 
c523 cd f4 9c			call macro_forth_dsp_value 
c526				endm 
# End of macro FORTH_DSP_VALUE
c526					;v5 FORTH_DSP_VALUE 
c526			;		inc hl      ; now at start of numeric as string 
c526			 
c526 e5					push hl 
c527			 
c527					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c527 cd c3 9d			call macro_forth_dsp_pop 
c52a				endm 
# End of macro FORTH_DSP_POP
c52a			 
c52a e1					pop hl 
c52b			 
c52b					if DEBUG_FORTH_WORDS 
c52b						DMARK "AS1" 
c52b f5				push af  
c52c 3a 40 c5			ld a, (.dmark)  
c52f 32 71 ee			ld (debug_mark),a  
c532 3a 41 c5			ld a, (.dmark+1)  
c535 32 72 ee			ld (debug_mark+1),a  
c538 3a 42 c5			ld a, (.dmark+2)  
c53b 32 73 ee			ld (debug_mark+2),a  
c53e 18 03			jr .pastdmark  
c540 ..			.dmark: db "AS1"  
c543 f1			.pastdmark: pop af  
c544			endm  
# End of macro DMARK
c544						CALLMONITOR 
c544 cd a3 94			call break_point_state  
c547				endm  
# End of macro CALLMONITOR
c547					endif 
c547					; push the content of a onto the stack as a value 
c547			 
c547 7e					ld a,(hl)   ; get char 
c548 26 00				ld h,0 
c54a 6f					ld l,a 
c54b					if DEBUG_FORTH_WORDS 
c54b						DMARK "AS2" 
c54b f5				push af  
c54c 3a 60 c5			ld a, (.dmark)  
c54f 32 71 ee			ld (debug_mark),a  
c552 3a 61 c5			ld a, (.dmark+1)  
c555 32 72 ee			ld (debug_mark+1),a  
c558 3a 62 c5			ld a, (.dmark+2)  
c55b 32 73 ee			ld (debug_mark+2),a  
c55e 18 03			jr .pastdmark  
c560 ..			.dmark: db "AS2"  
c563 f1			.pastdmark: pop af  
c564			endm  
# End of macro DMARK
c564						CALLMONITOR 
c564 cd a3 94			call break_point_state  
c567				endm  
# End of macro CALLMONITOR
c567					endif 
c567 cd 14 9b				call forth_push_numhl 
c56a			 
c56a				       NEXTW 
c56a c3 c1 9e			jp macro_next 
c56d				endm 
# End of macro NEXTW
c56d			 
c56d			.CHR: 
c56d				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c56d 4d				db WORD_SYS_CORE+57             
c56e a9 c5			dw .ENDSTR            
c570 04				db 3 + 1 
c571 .. 00			db "CHR",0              
c575				endm 
# End of macro CWHEAD
c575			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c575					if DEBUG_FORTH_WORDS_KEY 
c575						DMARK "CHR" 
c575 f5				push af  
c576 3a 8a c5			ld a, (.dmark)  
c579 32 71 ee			ld (debug_mark),a  
c57c 3a 8b c5			ld a, (.dmark+1)  
c57f 32 72 ee			ld (debug_mark+1),a  
c582 3a 8c c5			ld a, (.dmark+2)  
c585 32 73 ee			ld (debug_mark+2),a  
c588 18 03			jr .pastdmark  
c58a ..			.dmark: db "CHR"  
c58d f1			.pastdmark: pop af  
c58e			endm  
# End of macro DMARK
c58e						CALLMONITOR 
c58e cd a3 94			call break_point_state  
c591				endm  
# End of macro CALLMONITOR
c591					endif 
c591					FORTH_DSP_VALUEHL 
c591 cd 0b 9d			call macro_dsp_valuehl 
c594				endm 
# End of macro FORTH_DSP_VALUEHL
c594			 
c594					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c594 cd c3 9d			call macro_forth_dsp_pop 
c597				endm 
# End of macro FORTH_DSP_POP
c597			 
c597					; save asci byte as a zero term string and push string 
c597			 
c597 7d					ld a,l 
c598 32 cb e2				ld (scratch), a 
c59b			 
c59b 3e 00				ld a, 0 
c59d 32 cc e2				ld (scratch+1), a 
c5a0			 
c5a0 21 cb e2				ld hl, scratch 
c5a3 cd 82 9b				call forth_push_str 
c5a6			 
c5a6			 
c5a6				       NEXTW 
c5a6 c3 c1 9e			jp macro_next 
c5a9				endm 
# End of macro NEXTW
c5a9			 
c5a9			 
c5a9			 
c5a9			 
c5a9			.ENDSTR: 
c5a9			; eof 
c5a9			 
# End of file forth_words_str.asm
c5a9			include "forth_words_key.asm" 
c5a9			 
c5a9			; | ## Keyboard Words 
c5a9			 
c5a9			.KEY: 
c5a9				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c5a9 3e				db WORD_SYS_CORE+42             
c5aa d9 c5			dw .WAITK            
c5ac 04				db 3 + 1 
c5ad .. 00			db "KEY",0              
c5b1				endm 
# End of macro CWHEAD
c5b1			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c5b1			 
c5b1					if DEBUG_FORTH_WORDS_KEY 
c5b1						DMARK "KEY" 
c5b1 f5				push af  
c5b2 3a c6 c5			ld a, (.dmark)  
c5b5 32 71 ee			ld (debug_mark),a  
c5b8 3a c7 c5			ld a, (.dmark+1)  
c5bb 32 72 ee			ld (debug_mark+1),a  
c5be 3a c8 c5			ld a, (.dmark+2)  
c5c1 32 73 ee			ld (debug_mark+2),a  
c5c4 18 03			jr .pastdmark  
c5c6 ..			.dmark: db "KEY"  
c5c9 f1			.pastdmark: pop af  
c5ca			endm  
# End of macro DMARK
c5ca						CALLMONITOR 
c5ca cd a3 94			call break_point_state  
c5cd				endm  
# End of macro CALLMONITOR
c5cd					endif 
c5cd			; TODO currently waits 
c5cd cd bb e2				call cin 
c5d0					;call cin_wait 
c5d0 6f					ld l, a 
c5d1 26 00				ld h, 0 
c5d3 cd 14 9b				call forth_push_numhl 
c5d6					NEXTW 
c5d6 c3 c1 9e			jp macro_next 
c5d9				endm 
# End of macro NEXTW
c5d9			.WAITK: 
c5d9				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c5d9 3f				db WORD_SYS_CORE+43             
c5da 0b c6			dw .ACCEPT            
c5dc 06				db 5 + 1 
c5dd .. 00			db "WAITK",0              
c5e3				endm 
# End of macro CWHEAD
c5e3			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c5e3					if DEBUG_FORTH_WORDS_KEY 
c5e3						DMARK "WAI" 
c5e3 f5				push af  
c5e4 3a f8 c5			ld a, (.dmark)  
c5e7 32 71 ee			ld (debug_mark),a  
c5ea 3a f9 c5			ld a, (.dmark+1)  
c5ed 32 72 ee			ld (debug_mark+1),a  
c5f0 3a fa c5			ld a, (.dmark+2)  
c5f3 32 73 ee			ld (debug_mark+2),a  
c5f6 18 03			jr .pastdmark  
c5f8 ..			.dmark: db "WAI"  
c5fb f1			.pastdmark: pop af  
c5fc			endm  
# End of macro DMARK
c5fc						CALLMONITOR 
c5fc cd a3 94			call break_point_state  
c5ff				endm  
# End of macro CALLMONITOR
c5ff					endif 
c5ff cd b5 e2				call cin_wait 
c602 6f					ld l, a 
c603 26 00				ld h, 0 
c605 cd 14 9b				call forth_push_numhl 
c608					NEXTW 
c608 c3 c1 9e			jp macro_next 
c60b				endm 
# End of macro NEXTW
c60b			.ACCEPT: 
c60b				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c60b 40				db WORD_SYS_CORE+44             
c60c 69 c6			dw .EDIT            
c60e 07				db 6 + 1 
c60f .. 00			db "ACCEPT",0              
c616				endm 
# End of macro CWHEAD
c616			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c616					; TODO crashes on push 
c616					if DEBUG_FORTH_WORDS_KEY 
c616						DMARK "ACC" 
c616 f5				push af  
c617 3a 2b c6			ld a, (.dmark)  
c61a 32 71 ee			ld (debug_mark),a  
c61d 3a 2c c6			ld a, (.dmark+1)  
c620 32 72 ee			ld (debug_mark+1),a  
c623 3a 2d c6			ld a, (.dmark+2)  
c626 32 73 ee			ld (debug_mark+2),a  
c629 18 03			jr .pastdmark  
c62b ..			.dmark: db "ACC"  
c62e f1			.pastdmark: pop af  
c62f			endm  
# End of macro DMARK
c62f						CALLMONITOR 
c62f cd a3 94			call break_point_state  
c632				endm  
# End of macro CALLMONITOR
c632					endif 
c632 21 c9 e4				ld hl, os_input 
c635 3e 00				ld a, 0 
c637 77					ld (hl),a 
c638 3a 68 ea				ld a,(f_cursor_ptr) 
c63b 16 64				ld d, 100 
c63d 0e 00				ld c, 0 
c63f 1e 28				ld e, 40 
c641 cd cf 8c				call input_str 
c644					; TODO perhaps do a type check and wrap in quotes if not a number 
c644 21 c9 e4				ld hl, os_input 
c647					if DEBUG_FORTH_WORDS 
c647						DMARK "AC1" 
c647 f5				push af  
c648 3a 5c c6			ld a, (.dmark)  
c64b 32 71 ee			ld (debug_mark),a  
c64e 3a 5d c6			ld a, (.dmark+1)  
c651 32 72 ee			ld (debug_mark+1),a  
c654 3a 5e c6			ld a, (.dmark+2)  
c657 32 73 ee			ld (debug_mark+2),a  
c65a 18 03			jr .pastdmark  
c65c ..			.dmark: db "AC1"  
c65f f1			.pastdmark: pop af  
c660			endm  
# End of macro DMARK
c660						CALLMONITOR 
c660 cd a3 94			call break_point_state  
c663				endm  
# End of macro CALLMONITOR
c663					endif 
c663 cd 82 9b				call forth_push_str 
c666					NEXTW 
c666 c3 c1 9e			jp macro_next 
c669				endm 
# End of macro NEXTW
c669			 
c669			.EDIT: 
c669				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c669 40				db WORD_SYS_CORE+44             
c66a 0b c7			dw .DEDIT            
c66c 05				db 4 + 1 
c66d .. 00			db "EDIT",0              
c672				endm 
# End of macro CWHEAD
c672			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c672			 
c672					; TODO does not copy from stack 
c672					if DEBUG_FORTH_WORDS_KEY 
c672						DMARK "EDT" 
c672 f5				push af  
c673 3a 87 c6			ld a, (.dmark)  
c676 32 71 ee			ld (debug_mark),a  
c679 3a 88 c6			ld a, (.dmark+1)  
c67c 32 72 ee			ld (debug_mark+1),a  
c67f 3a 89 c6			ld a, (.dmark+2)  
c682 32 73 ee			ld (debug_mark+2),a  
c685 18 03			jr .pastdmark  
c687 ..			.dmark: db "EDT"  
c68a f1			.pastdmark: pop af  
c68b			endm  
# End of macro DMARK
c68b						CALLMONITOR 
c68b cd a3 94			call break_point_state  
c68e				endm  
# End of macro CALLMONITOR
c68e					endif 
c68e			 
c68e					;FORTH_DSP 
c68e					FORTH_DSP_VALUEHL 
c68e cd 0b 9d			call macro_dsp_valuehl 
c691				endm 
# End of macro FORTH_DSP_VALUEHL
c691			;		inc hl    ; TODO do type check 
c691			 
c691			;		call get_word_hl 
c691 e5					push hl 
c692					if DEBUG_FORTH_WORDS 
c692						DMARK "EDp" 
c692 f5				push af  
c693 3a a7 c6			ld a, (.dmark)  
c696 32 71 ee			ld (debug_mark),a  
c699 3a a8 c6			ld a, (.dmark+1)  
c69c 32 72 ee			ld (debug_mark+1),a  
c69f 3a a9 c6			ld a, (.dmark+2)  
c6a2 32 73 ee			ld (debug_mark+2),a  
c6a5 18 03			jr .pastdmark  
c6a7 ..			.dmark: db "EDp"  
c6aa f1			.pastdmark: pop af  
c6ab			endm  
# End of macro DMARK
c6ab						CALLMONITOR 
c6ab cd a3 94			call break_point_state  
c6ae				endm  
# End of macro CALLMONITOR
c6ae					endif 
c6ae				;	ld a, 0 
c6ae cd 00 91				call strlenz 
c6b1 23					inc hl 
c6b2			 
c6b2 06 00				ld b, 0 
c6b4 4d					ld c, l 
c6b5			 
c6b5 e1					pop hl 
c6b6 11 c9 e4				ld de, os_input 
c6b9					if DEBUG_FORTH_WORDS_KEY 
c6b9						DMARK "EDc" 
c6b9 f5				push af  
c6ba 3a ce c6			ld a, (.dmark)  
c6bd 32 71 ee			ld (debug_mark),a  
c6c0 3a cf c6			ld a, (.dmark+1)  
c6c3 32 72 ee			ld (debug_mark+1),a  
c6c6 3a d0 c6			ld a, (.dmark+2)  
c6c9 32 73 ee			ld (debug_mark+2),a  
c6cc 18 03			jr .pastdmark  
c6ce ..			.dmark: db "EDc"  
c6d1 f1			.pastdmark: pop af  
c6d2			endm  
# End of macro DMARK
c6d2						CALLMONITOR 
c6d2 cd a3 94			call break_point_state  
c6d5				endm  
# End of macro CALLMONITOR
c6d5					endif 
c6d5 ed b0				ldir 
c6d7			 
c6d7			 
c6d7 21 c9 e4				ld hl, os_input 
c6da					;ld a, 0 
c6da					;ld (hl),a 
c6da 3a 68 ea				ld a,(f_cursor_ptr) 
c6dd 16 64				ld d, 100 
c6df 0e 00				ld c, 0 
c6e1 1e 28				ld e, 40 
c6e3 cd cf 8c				call input_str 
c6e6					; TODO perhaps do a type check and wrap in quotes if not a number 
c6e6 21 c9 e4				ld hl, os_input 
c6e9					if DEBUG_FORTH_WORDS 
c6e9						DMARK "ED1" 
c6e9 f5				push af  
c6ea 3a fe c6			ld a, (.dmark)  
c6ed 32 71 ee			ld (debug_mark),a  
c6f0 3a ff c6			ld a, (.dmark+1)  
c6f3 32 72 ee			ld (debug_mark+1),a  
c6f6 3a 00 c7			ld a, (.dmark+2)  
c6f9 32 73 ee			ld (debug_mark+2),a  
c6fc 18 03			jr .pastdmark  
c6fe ..			.dmark: db "ED1"  
c701 f1			.pastdmark: pop af  
c702			endm  
# End of macro DMARK
c702						CALLMONITOR 
c702 cd a3 94			call break_point_state  
c705				endm  
# End of macro CALLMONITOR
c705					endif 
c705 cd 82 9b				call forth_push_str 
c708					NEXTW 
c708 c3 c1 9e			jp macro_next 
c70b				endm 
# End of macro NEXTW
c70b			 
c70b			.DEDIT: 
c70b				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c70b 40				db WORD_SYS_CORE+44             
c70c 6d c7			dw .ENDKEY            
c70e 06				db 5 + 1 
c70f .. 00			db "DEDIT",0              
c715				endm 
# End of macro CWHEAD
c715			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c715			 
c715					; TODO does not copy from stack 
c715					if DEBUG_FORTH_WORDS_KEY 
c715						DMARK "DED" 
c715 f5				push af  
c716 3a 2a c7			ld a, (.dmark)  
c719 32 71 ee			ld (debug_mark),a  
c71c 3a 2b c7			ld a, (.dmark+1)  
c71f 32 72 ee			ld (debug_mark+1),a  
c722 3a 2c c7			ld a, (.dmark+2)  
c725 32 73 ee			ld (debug_mark+2),a  
c728 18 03			jr .pastdmark  
c72a ..			.dmark: db "DED"  
c72d f1			.pastdmark: pop af  
c72e			endm  
# End of macro DMARK
c72e						CALLMONITOR 
c72e cd a3 94			call break_point_state  
c731				endm  
# End of macro CALLMONITOR
c731					endif 
c731			 
c731					;FORTH_DSP 
c731					FORTH_DSP_VALUEHL 
c731 cd 0b 9d			call macro_dsp_valuehl 
c734				endm 
# End of macro FORTH_DSP_VALUEHL
c734			;		inc hl    ; TODO do type check 
c734			 
c734			;		call get_word_hl 
c734 e5					push hl 
c735 e5					push hl 
c736					FORTH_DSP_POP 
c736 cd c3 9d			call macro_forth_dsp_pop 
c739				endm 
# End of macro FORTH_DSP_POP
c739 e1					pop hl 
c73a					if DEBUG_FORTH_WORDS 
c73a						DMARK "EDp" 
c73a f5				push af  
c73b 3a 4f c7			ld a, (.dmark)  
c73e 32 71 ee			ld (debug_mark),a  
c741 3a 50 c7			ld a, (.dmark+1)  
c744 32 72 ee			ld (debug_mark+1),a  
c747 3a 51 c7			ld a, (.dmark+2)  
c74a 32 73 ee			ld (debug_mark+2),a  
c74d 18 03			jr .pastdmark  
c74f ..			.dmark: db "EDp"  
c752 f1			.pastdmark: pop af  
c753			endm  
# End of macro DMARK
c753						CALLMONITOR 
c753 cd a3 94			call break_point_state  
c756				endm  
# End of macro CALLMONITOR
c756					endif 
c756				;	ld a, 0 
c756 cd 00 91				call strlenz 
c759 23					inc hl 
c75a			 
c75a 06 00				ld b, 0 
c75c 4d					ld c, l 
c75d			 
c75d e1					pop hl 
c75e			 
c75e					;ld a, 0 
c75e					;ld (hl),a 
c75e 3a 68 ea				ld a,(f_cursor_ptr) 
c761 16 64				ld d, 100 
c763 0e 00				ld c, 0 
c765 1e 28				ld e, 40 
c767 cd cf 8c				call input_str 
c76a					; TODO perhaps do a type check and wrap in quotes if not a number 
c76a					NEXTW 
c76a c3 c1 9e			jp macro_next 
c76d				endm 
# End of macro NEXTW
c76d			 
c76d			 
c76d			.ENDKEY: 
c76d			; eof 
c76d			 
# End of file forth_words_key.asm
c76d			include "forth_words_const.asm" 
c76d			 
c76d			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c76d			 
c76d			 
c76d			.SPITIME: 
c76d				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c76d 77				db WORD_SYS_CORE+99             
c76e 82 c7			dw .VA            
c770 08				db 7 + 1 
c771 .. 00			db "SPITIME",0              
c779				endm 
# End of macro CWHEAD
c779			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c779			; 
c779			; | If using BANK devices then leave as is. 
c779			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c779			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c779			 
c779 21 6e ea				ld hl, spi_clktime  
c77c cd 14 9b				call forth_push_numhl 
c77f			 
c77f					NEXTW 
c77f c3 c1 9e			jp macro_next 
c782				endm 
# End of macro NEXTW
c782			 
c782			 
c782			.VA: 
c782				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c782 77				db WORD_SYS_CORE+99             
c783 92 c7			dw .SYMBOL            
c785 03				db 2 + 1 
c786 .. 00			db "VA",0              
c789				endm 
# End of macro CWHEAD
c789			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c789 21 32 ea				ld hl, cli_var_array 
c78c cd 14 9b				call forth_push_numhl 
c78f			 
c78f					NEXTW 
c78f c3 c1 9e			jp macro_next 
c792				endm 
# End of macro NEXTW
c792			 
c792			.SYMBOL: 
c792				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c792 77				db WORD_SYS_CORE+99             
c793 ca c8			dw .ENDCONST            
c795 07				db 6 + 1 
c796 .. 00			db "SYMBOL",0              
c79d				endm 
# End of macro CWHEAD
c79d			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c79d			; | 
c79d			; | The value is the number reference and the final address is pushed to stack 
c79d			 
c79d					if DEBUG_FORTH_WORDS_KEY 
c79d						DMARK "SYM" 
c79d f5				push af  
c79e 3a b2 c7			ld a, (.dmark)  
c7a1 32 71 ee			ld (debug_mark),a  
c7a4 3a b3 c7			ld a, (.dmark+1)  
c7a7 32 72 ee			ld (debug_mark+1),a  
c7aa 3a b4 c7			ld a, (.dmark+2)  
c7ad 32 73 ee			ld (debug_mark+2),a  
c7b0 18 03			jr .pastdmark  
c7b2 ..			.dmark: db "SYM"  
c7b5 f1			.pastdmark: pop af  
c7b6			endm  
# End of macro DMARK
c7b6						CALLMONITOR 
c7b6 cd a3 94			call break_point_state  
c7b9				endm  
# End of macro CALLMONITOR
c7b9					endif 
c7b9			 
c7b9					FORTH_DSP_VALUEHL 
c7b9 cd 0b 9d			call macro_dsp_valuehl 
c7bc				endm 
# End of macro FORTH_DSP_VALUEHL
c7bc			 
c7bc 7d					ld a, l     
c7bd			 
c7bd			 
c7bd					if DEBUG_FORTH_WORDS 
c7bd						DMARK "SY1" 
c7bd f5				push af  
c7be 3a d2 c7			ld a, (.dmark)  
c7c1 32 71 ee			ld (debug_mark),a  
c7c4 3a d3 c7			ld a, (.dmark+1)  
c7c7 32 72 ee			ld (debug_mark+1),a  
c7ca 3a d4 c7			ld a, (.dmark+2)  
c7cd 32 73 ee			ld (debug_mark+2),a  
c7d0 18 03			jr .pastdmark  
c7d2 ..			.dmark: db "SY1"  
c7d5 f1			.pastdmark: pop af  
c7d6			endm  
# End of macro DMARK
c7d6						CALLMONITOR 
c7d6 cd a3 94			call break_point_state  
c7d9				endm  
# End of macro CALLMONITOR
c7d9					endif 
c7d9					 
c7d9 f5					push af	 
c7da					FORTH_DSP_POP 
c7da cd c3 9d			call macro_forth_dsp_pop 
c7dd				endm 
# End of macro FORTH_DSP_POP
c7dd f1					pop af 
c7de			 
c7de cb 27				sla a  
c7e0				 
c7e0					 
c7e0					if DEBUG_FORTH_WORDS 
c7e0						DMARK "SY" 
c7e0 f5				push af  
c7e1 3a f5 c7			ld a, (.dmark)  
c7e4 32 71 ee			ld (debug_mark),a  
c7e7 3a f6 c7			ld a, (.dmark+1)  
c7ea 32 72 ee			ld (debug_mark+1),a  
c7ed 3a f7 c7			ld a, (.dmark+2)  
c7f0 32 73 ee			ld (debug_mark+2),a  
c7f3 18 02			jr .pastdmark  
c7f5 ..			.dmark: db "SY"  
c7f7 f1			.pastdmark: pop af  
c7f8			endm  
# End of macro DMARK
c7f8						CALLMONITOR 
c7f8 cd a3 94			call break_point_state  
c7fb				endm  
# End of macro CALLMONITOR
c7fb					endif 
c7fb			 
c7fb 21 0a c8				ld hl, sym_table 
c7fe cd a2 8c				call addatohl 
c801 cd 43 9e				call loadwordinhl 
c804 cd 14 9b				call forth_push_numhl 
c807			 
c807			 
c807				       NEXTW 
c807 c3 c1 9e			jp macro_next 
c80a				endm 
# End of macro NEXTW
c80a			 
c80a			sym_table: 
c80a			 
c80a			; 0 
c80a 46 ea		dw cli_autodisplay 
c80c 54 ea		dw cli_buffer 
c80e f8 e9		dw cli_data_sp 
c810 32 e8		dw cli_data_stack 
c812 4e ea		dw cli_execword 
c814 fa e9		dw cli_loop_sp 
c816 34 e9		dw cli_loop_stack 
c818 47 ea		dw cli_mvdot 
c81a 4c ea		dw cli_nextword 
c81c 48 ea		dw cli_origptr 
c81e 52 ea		dw cli_origtoken 
c820			; 11 
c820 4a ea		dw cli_ptr 
c822 fc e9		dw cli_ret_sp 
c824 b6 e9		dw cli_ret_stack 
c826 50 ea		dw cli_token 
c828 32 ea		dw cli_var_array 
c82a ce eb		dw cursor_col 
c82c cc eb		dw cursor_ptr 
c82e cd eb		dw cursor_row 
c830 ca eb		dw cursor_shape 
c832 71 ee		dw debug_mark 
c834			; 21 
c834 b7 ed		dw display_fb0 
c836 16 ed		dw display_fb1 
c838 d4 eb		dw display_fb2 
c83a 75 ec		dw display_fb3 
c83c d2 eb		dw display_fb_active 
c83e ca e3		dw execscratch 
c840 68 ea		dw f_cursor_ptr 
c842 75 ee		dw hardware_word 
c844 68 ee		dw input_at_cursor 
c846 6a ee		dw input_at_pos 
c848			; 31 
c848 66 ee		dw input_cur_flash 
c84a 65 ee		dw input_cur_onoff 
c84c 5b ee		dw input_cursor 
c84e 6b ee		dw input_display_size 
c850 60 ee		dw input_len 
c852 6f ee		dw input_ptr 
c854 6c ee		dw input_size 
c856 6d ee		dw input_start 
c858 cf 8c		dw input_str 
c85a 69 ee		dw input_under_cursor 
c85c			; 41 
c85c 5a ee		dw key_actual_pressed 
c85e 85 ee		dw key_fa 
c860 81 ee		dw key_face_held 
c862 84 ee		dw key_fb 
c864 83 ee		dw key_fc 
c866 82 ee		dw key_fd 
c868 8b ee		dw key_held 
c86a 8a ee		dw key_held_prev 
c86c b4 e2		dw key_init 
c86e 86 ee		dw key_repeat_ct 
c870			; 51 
c870 05 00		dw key_rows 
c872 58 ee		dw key_shift 
c874 59 ee		dw key_symbol 
c876 8c ee		dw keyscan_scancol 
c878 96 ee		dw keyscan_table 
c87a f5 ee		dw keyscan_table_row1 
c87c ea ee		dw keyscan_table_row2 
c87e df ee		dw keyscan_table_row3 
c880 d4 ee		dw keyscan_table_row4 
c882 c9 ee		dw keyscan_table_row5 
c884			; 61 
c884 f2 e5		dw os_cli_cmd 
c886 ee e5		dw os_cur_ptr 
c888 f0 e5		dw os_current_i 
c88a c9 e4		dw os_input 
c88c f1 e6		dw os_last_cmd 
c88e c8 e5		dw os_last_new_uword 
c890 bc e2		dw os_view_disable 
c892 b8 e2		dw os_view_hl 
c894 d0 e5		dw os_word_scratch 
c896 c3 00		dw portbctl 
c898			; 71 
c898 c1 00		dw portbdata 
c89a 6d ea		dw spi_cartdev 
c89c 6c ea		dw spi_cartdev2 
c89e 6e ea		dw spi_clktime 
c8a0 6a ea		dw spi_device 
c8a2 69 ea		dw spi_device_id 
c8a4 6b ea		dw spi_portbyte 
c8a6 b0 eb		dw stackstore 
c8a8			if STORAGE_SE 
c8a8			dw storage_actl 
c8a8			dw storage_adata 
c8a8			else 
c8a8 00 00		dw 0 
c8aa 00 00		dw 0 
c8ac			endif 
c8ac			; 81 
c8ac 69 88		dw storage_append 
c8ae			if STORAGE_SE 
c8ae			dw storage_bctl 
c8ae			else 
c8ae 00 00		dw 0 
c8b0			endif 
c8b0 9c eb		dw store_bank_active 
c8b2 71 ea		dw store_filecache 
c8b4 7f ea		dw store_longread 
c8b6 75 ea		dw store_openaddr 
c8b8 74 ea		dw store_openext 
c8ba 73 ea		dw store_openmaxext 
c8bc 84 ea		dw store_page 
c8be 80 ea		dw store_readbuf 
c8c0			; 91 
c8c0 77 ea		dw store_readcont 
c8c2 82 ea		dw store_readptr 
c8c4 77 ea		dw store_tmpext 
c8c6 78 ea		dw store_tmpid 
c8c8 6f ea		dw store_tmppageid 
c8ca			 
c8ca			 
c8ca			.ENDCONST: 
c8ca			 
c8ca			; eof 
c8ca			 
c8ca			 
# End of file forth_words_const.asm
c8ca			 
c8ca			if STORAGE_SE 
c8ca			   	include "forth_words_storage.asm" 
c8ca			endif 
c8ca				include "forth_words_device.asm" 
c8ca			; Device related words 
c8ca			 
c8ca			; | ## Device Words 
c8ca			 
c8ca			;if SOUND_ENABLE 
c8ca			;.NOTE: 
c8ca			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c8ca			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c8ca			;		if DEBUG_FORTH_WORDS_KEY 
c8ca			;			DMARK "NTE" 
c8ca			;			CALLMONITOR 
c8ca			;		endif 
c8ca			; 
c8ca			;	 
c8ca			; 
c8ca			;		NEXTW 
c8ca			;.AFTERSOUND: 
c8ca			;endif 
c8ca			 
c8ca			 
c8ca			USE_GPIO: equ 0 
c8ca			 
c8ca			if USE_GPIO 
c8ca			.GP1: 
c8ca				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c8ca			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c8ca					NEXTW 
c8ca			.GP2: 
c8ca				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c8ca			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c8ca			 
c8ca					NEXTW 
c8ca			 
c8ca			.GP3: 
c8ca				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c8ca			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c8ca			 
c8ca					NEXTW 
c8ca			 
c8ca			.GP4: 
c8ca				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c8ca			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c8ca			 
c8ca					NEXTW 
c8ca			.SIN: 
c8ca			 
c8ca			 
c8ca			endif 
c8ca			 
c8ca			 
c8ca				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c8ca 33				db WORD_SYS_CORE+31             
c8cb ff c8			dw .SOUT            
c8cd 03				db 2 + 1 
c8ce .. 00			db "IN",0              
c8d1				endm 
# End of macro CWHEAD
c8d1			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c8d1					if DEBUG_FORTH_WORDS_KEY 
c8d1						DMARK "IN." 
c8d1 f5				push af  
c8d2 3a e6 c8			ld a, (.dmark)  
c8d5 32 71 ee			ld (debug_mark),a  
c8d8 3a e7 c8			ld a, (.dmark+1)  
c8db 32 72 ee			ld (debug_mark+1),a  
c8de 3a e8 c8			ld a, (.dmark+2)  
c8e1 32 73 ee			ld (debug_mark+2),a  
c8e4 18 03			jr .pastdmark  
c8e6 ..			.dmark: db "IN."  
c8e9 f1			.pastdmark: pop af  
c8ea			endm  
# End of macro DMARK
c8ea						CALLMONITOR 
c8ea cd a3 94			call break_point_state  
c8ed				endm  
# End of macro CALLMONITOR
c8ed					endif 
c8ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c8ed cd 0b 9d			call macro_dsp_valuehl 
c8f0				endm 
# End of macro FORTH_DSP_VALUEHL
c8f0			 
c8f0 e5					push hl 
c8f1			 
c8f1					; destroy value TOS 
c8f1			 
c8f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8f1 cd c3 9d			call macro_forth_dsp_pop 
c8f4				endm 
# End of macro FORTH_DSP_POP
c8f4			 
c8f4					; one value on hl get other one back 
c8f4			 
c8f4 c1					pop bc 
c8f5			 
c8f5					; do the sub 
c8f5			;		ex de, hl 
c8f5			 
c8f5 ed 68				in l,(c) 
c8f7			 
c8f7					; save it 
c8f7			 
c8f7 26 00				ld h,0 
c8f9			 
c8f9					; TODO push value back onto stack for another op etc 
c8f9			 
c8f9 cd 14 9b				call forth_push_numhl 
c8fc					NEXTW 
c8fc c3 c1 9e			jp macro_next 
c8ff				endm 
# End of macro NEXTW
c8ff			.SOUT: 
c8ff				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c8ff 34				db WORD_SYS_CORE+32             
c900 52 c9			dw .SPIO            
c902 04				db 3 + 1 
c903 .. 00			db "OUT",0              
c907				endm 
# End of macro CWHEAD
c907			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c907					if DEBUG_FORTH_WORDS_KEY 
c907						DMARK "OUT" 
c907 f5				push af  
c908 3a 1c c9			ld a, (.dmark)  
c90b 32 71 ee			ld (debug_mark),a  
c90e 3a 1d c9			ld a, (.dmark+1)  
c911 32 72 ee			ld (debug_mark+1),a  
c914 3a 1e c9			ld a, (.dmark+2)  
c917 32 73 ee			ld (debug_mark+2),a  
c91a 18 03			jr .pastdmark  
c91c ..			.dmark: db "OUT"  
c91f f1			.pastdmark: pop af  
c920			endm  
# End of macro DMARK
c920						CALLMONITOR 
c920 cd a3 94			call break_point_state  
c923				endm  
# End of macro CALLMONITOR
c923					endif 
c923			 
c923					; get port 
c923			 
c923					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c923 cd 0b 9d			call macro_dsp_valuehl 
c926				endm 
# End of macro FORTH_DSP_VALUEHL
c926			 
c926 e5					push hl 
c927			 
c927					; destroy value TOS 
c927			 
c927					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c927 cd c3 9d			call macro_forth_dsp_pop 
c92a				endm 
# End of macro FORTH_DSP_POP
c92a			 
c92a					; get byte to send 
c92a			 
c92a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c92a cd 0b 9d			call macro_dsp_valuehl 
c92d				endm 
# End of macro FORTH_DSP_VALUEHL
c92d			 
c92d			;		push hl 
c92d			 
c92d					; destroy value TOS 
c92d			 
c92d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c92d cd c3 9d			call macro_forth_dsp_pop 
c930				endm 
# End of macro FORTH_DSP_POP
c930			 
c930					; one value on hl get other one back 
c930			 
c930			;		pop hl 
c930			 
c930 c1					pop bc 
c931			 
c931					if DEBUG_FORTH_WORDS 
c931						DMARK "OUT" 
c931 f5				push af  
c932 3a 46 c9			ld a, (.dmark)  
c935 32 71 ee			ld (debug_mark),a  
c938 3a 47 c9			ld a, (.dmark+1)  
c93b 32 72 ee			ld (debug_mark+1),a  
c93e 3a 48 c9			ld a, (.dmark+2)  
c941 32 73 ee			ld (debug_mark+2),a  
c944 18 03			jr .pastdmark  
c946 ..			.dmark: db "OUT"  
c949 f1			.pastdmark: pop af  
c94a			endm  
# End of macro DMARK
c94a						CALLMONITOR 
c94a cd a3 94			call break_point_state  
c94d				endm  
# End of macro CALLMONITOR
c94d					endif 
c94d			 
c94d ed 69				out (c), l 
c94f			 
c94f					NEXTW 
c94f c3 c1 9e			jp macro_next 
c952				endm 
# End of macro NEXTW
c952			 
c952			 
c952			.SPIO: 
c952			 
c952			if STORAGE_SE 
c952				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c952			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c952			 
c952					call spi_ce_low 
c952			    NEXTW 
c952			 
c952			.SPICEH: 
c952				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c952			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c952			 
c952					call spi_ce_high 
c952			    NEXTW 
c952			 
c952			 
c952			.SPIOb: 
c952			 
c952				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c952			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c952			 
c952					if DEBUG_FORTH_WORDS_KEY 
c952						DMARK "SPo" 
c952						CALLMONITOR 
c952					endif 
c952					; get port 
c952			 
c952			 
c952					; get byte to send 
c952			 
c952					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c952			 
c952			;		push hl    ; u1  
c952			 
c952					; destroy value TOS 
c952			 
c952					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c952			 
c952					; one value on hl get other one back 
c952			 
c952			;		pop hl   ; u2 - addr 
c952			 
c952					; TODO Send SPI byte 
c952			 
c952			;		push hl 
c952			;		call spi_ce_low 
c952			;		pop hl 
c952					ld a, l 
c952					call spi_send_byte 
c952			;		call spi_ce_high 
c952			 
c952					NEXTW 
c952			 
c952			.SPII: 
c952				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c952			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c952					if DEBUG_FORTH_WORDS_KEY 
c952						DMARK "SPi" 
c952						CALLMONITOR 
c952					endif 
c952			 
c952					; TODO Get SPI byte 
c952			 
c952					call spi_read_byte 
c952			 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "Si2" 
c952						CALLMONITOR 
c952					endif 
c952					ld h, 0 
c952					ld l, a 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "Si3" 
c952						CALLMONITOR 
c952					endif 
c952					call forth_push_numhl 
c952			 
c952					NEXTW 
c952			 
c952			 
c952			 
c952			.SESEL: 
c952				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c952			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c952					if DEBUG_FORTH_WORDS_KEY 
c952						DMARK "BNK" 
c952						CALLMONITOR 
c952					endif 
c952			 
c952					ld a, 255 
c952					ld (spi_cartdev), a 
c952			 
c952					; get bank 
c952			 
c952					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c952			 
c952			;		push hl 
c952			 
c952					; destroy value TOS 
c952			 
c952					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c952			 
c952					; one value on hl get other one back 
c952			 
c952			;		pop hl 
c952			 
c952			 
c952					ld c, SPI_CE_HIGH 
c952					ld b, '0'    ; human readable bank number 
c952			 
c952					ld a, l 
c952			 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "BNK" 
c952						CALLMONITOR 
c952					endif 
c952			 
c952					; active low 
c952			 
c952					cp 0 
c952					jr z, .bset 
c952					cp 1 
c952					jr nz, .b2 
c952					res 0, c 
c952					ld b, '1'    ; human readable bank number 
c952			.b2:		cp 2 
c952					jr nz, .b3 
c952					res 1, c 
c952					ld b, '2'    ; human readable bank number 
c952			.b3:		cp 3 
c952					jr nz, .b4 
c952					res 2, c 
c952					ld b, '3'    ; human readable bank number 
c952			.b4:		cp 4 
c952					jr nz, .b5 
c952					res 3, c 
c952					ld b, '4'    ; human readable bank number 
c952			.b5:		cp 5 
c952					jr nz, .bset 
c952					res 4, c 
c952					ld b, '5'    ; human readable bank number 
c952			 
c952			.bset: 
c952					ld a, c 
c952					ld (spi_device),a 
c952					ld a, b 
c952					ld (spi_device_id),a 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "BN2" 
c952						CALLMONITOR 
c952					endif 
c952			 
c952					; set default SPI clk pulse time as disabled for BANK use 
c952			 
c952					ld a, 0 
c952					ld (spi_clktime), a 
c952			 
c952					NEXTW 
c952			 
c952			.CARTDEV: 
c952				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c952			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c952					if DEBUG_FORTH_WORDS_KEY 
c952						DMARK "CDV" 
c952						CALLMONITOR 
c952					endif 
c952			 
c952					; disable se storage bank selection 
c952			 
c952					ld a, SPI_CE_HIGH		; ce high 
c952					ld (spi_device), a 
c952			 
c952					; get bank 
c952			 
c952					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c952			 
c952			;		push hl 
c952			 
c952					; destroy value TOS 
c952			 
c952					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c952			 
c952					; one value on hl get other one back 
c952			 
c952			;		pop hl 
c952			 
c952					; active low 
c952			 
c952					ld c, 255 
c952			 
c952					ld a, l 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "CDV" 
c952						CALLMONITOR 
c952					endif 
c952					cp 0 
c952					jr z, .cset 
c952					cp 1 
c952					jr nz, .c2 
c952					res 0, c 
c952			.c2:		cp 2 
c952					jr nz, .c3 
c952					res 1, c 
c952			.c3:		cp 3 
c952					jr nz, .c4 
c952					res 2, c 
c952			.c4:		cp 4 
c952					jr nz, .c5 
c952					res 3, c 
c952			.c5:		cp 5 
c952					jr nz, .c6 
c952					res 4, c 
c952			.c6:		cp 6 
c952					jr nz, .c7 
c952					res 5, c 
c952			.c7:		cp 7 
c952					jr nz, .c8 
c952					res 6, c 
c952			.c8:		cp 8 
c952					jr nz, .cset 
c952					res 7, c 
c952			.cset:		ld a, c 
c952					ld (spi_cartdev),a 
c952			 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "CD2" 
c952						CALLMONITOR 
c952					endif 
c952			 
c952					; set default SPI clk pulse time as 10ms for CARTDEV use 
c952			 
c952					ld a, $0a 
c952					ld (spi_clktime), a 
c952					NEXTW 
c952			endif 
c952			 
c952			.ENDDEVICE: 
c952			; eof 
c952			 
# End of file forth_words_device.asm
c952			 
c952			; var handler 
c952			 
c952			 
c952			.VARS: 
c952				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c952 77				db WORD_SYS_CORE+99             
c953 03 ca			dw .V0            
c955 04				db 3 + 1 
c956 .. 00			db "VAR",0              
c95a				endm 
# End of macro CWHEAD
c95a			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c95a			;| 
c95a			;| The variable name should consist of a single letter. e.g. "a" 
c95a			;! If a full string is passed then only the first char is looked at 
c95a			;| Any other char could exceed bounds checks!  
c95a			 
c95a					if DEBUG_FORTH_WORDS_KEY 
c95a						DMARK "VAR" 
c95a f5				push af  
c95b 3a 6f c9			ld a, (.dmark)  
c95e 32 71 ee			ld (debug_mark),a  
c961 3a 70 c9			ld a, (.dmark+1)  
c964 32 72 ee			ld (debug_mark+1),a  
c967 3a 71 c9			ld a, (.dmark+2)  
c96a 32 73 ee			ld (debug_mark+2),a  
c96d 18 03			jr .pastdmark  
c96f ..			.dmark: db "VAR"  
c972 f1			.pastdmark: pop af  
c973			endm  
# End of macro DMARK
c973						CALLMONITOR 
c973 cd a3 94			call break_point_state  
c976				endm  
# End of macro CALLMONITOR
c976					endif 
c976			 
c976					FORTH_DSP_VALUEHL 
c976 cd 0b 9d			call macro_dsp_valuehl 
c979				endm 
# End of macro FORTH_DSP_VALUEHL
c979			 
c979 7e					ld a, (hl)    ; get first char on of the string 
c97a			 
c97a			 
c97a					if DEBUG_FORTH_WORDS 
c97a						DMARK "VR1" 
c97a f5				push af  
c97b 3a 8f c9			ld a, (.dmark)  
c97e 32 71 ee			ld (debug_mark),a  
c981 3a 90 c9			ld a, (.dmark+1)  
c984 32 72 ee			ld (debug_mark+1),a  
c987 3a 91 c9			ld a, (.dmark+2)  
c98a 32 73 ee			ld (debug_mark+2),a  
c98d 18 03			jr .pastdmark  
c98f ..			.dmark: db "VR1"  
c992 f1			.pastdmark: pop af  
c993			endm  
# End of macro DMARK
c993						CALLMONITOR 
c993 cd a3 94			call break_point_state  
c996				endm  
# End of macro CALLMONITOR
c996					endif 
c996					 
c996 f5					push af	 
c997					FORTH_DSP_POP 
c997 cd c3 9d			call macro_forth_dsp_pop 
c99a				endm 
# End of macro FORTH_DSP_POP
c99a f1					pop af 
c99b			 
c99b					; convert to upper 
c99b			 
c99b cd 0f 90				call to_upper 
c99e					if DEBUG_FORTH_WORDS 
c99e						DMARK "Vaa" 
c99e f5				push af  
c99f 3a b3 c9			ld a, (.dmark)  
c9a2 32 71 ee			ld (debug_mark),a  
c9a5 3a b4 c9			ld a, (.dmark+1)  
c9a8 32 72 ee			ld (debug_mark+1),a  
c9ab 3a b5 c9			ld a, (.dmark+2)  
c9ae 32 73 ee			ld (debug_mark+2),a  
c9b1 18 03			jr .pastdmark  
c9b3 ..			.dmark: db "Vaa"  
c9b6 f1			.pastdmark: pop af  
c9b7			endm  
# End of macro DMARK
c9b7						CALLMONITOR 
c9b7 cd a3 94			call break_point_state  
c9ba				endm  
# End of macro CALLMONITOR
c9ba					endif 
c9ba 06 41				ld b, 'A' 
c9bc 90					sub b			; set offset 
c9bd					if DEBUG_FORTH_WORDS 
c9bd						DMARK "Vbb" 
c9bd f5				push af  
c9be 3a d2 c9			ld a, (.dmark)  
c9c1 32 71 ee			ld (debug_mark),a  
c9c4 3a d3 c9			ld a, (.dmark+1)  
c9c7 32 72 ee			ld (debug_mark+1),a  
c9ca 3a d4 c9			ld a, (.dmark+2)  
c9cd 32 73 ee			ld (debug_mark+2),a  
c9d0 18 03			jr .pastdmark  
c9d2 ..			.dmark: db "Vbb"  
c9d5 f1			.pastdmark: pop af  
c9d6			endm  
# End of macro DMARK
c9d6						CALLMONITOR 
c9d6 cd a3 94			call break_point_state  
c9d9				endm  
# End of macro CALLMONITOR
c9d9					endif 
c9d9 cb 27				sla a  
c9db				 
c9db					 
c9db					if DEBUG_FORTH_WORDS 
c9db						DMARK "VR2" 
c9db f5				push af  
c9dc 3a f0 c9			ld a, (.dmark)  
c9df 32 71 ee			ld (debug_mark),a  
c9e2 3a f1 c9			ld a, (.dmark+1)  
c9e5 32 72 ee			ld (debug_mark+1),a  
c9e8 3a f2 c9			ld a, (.dmark+2)  
c9eb 32 73 ee			ld (debug_mark+2),a  
c9ee 18 03			jr .pastdmark  
c9f0 ..			.dmark: db "VR2"  
c9f3 f1			.pastdmark: pop af  
c9f4			endm  
# End of macro DMARK
c9f4						CALLMONITOR 
c9f4 cd a3 94			call break_point_state  
c9f7				endm  
# End of macro CALLMONITOR
c9f7					endif 
c9f7			 
c9f7 21 fe e9				ld hl, cli_var_array2 
c9fa cd a2 8c				call addatohl 
c9fd cd 14 9b				call forth_push_numhl 
ca00			 
ca00			 
ca00				       NEXTW 
ca00 c3 c1 9e			jp macro_next 
ca03				endm 
# End of macro NEXTW
ca03			.V0: 
ca03				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca03 78				db WORD_SYS_CORE+100             
ca04 1b ca			dw .V0Q            
ca06 04				db 3 + 1 
ca07 .. 00			db "V0!",0              
ca0b				endm 
# End of macro CWHEAD
ca0b			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca0b			 
ca0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca0b cd 0b 9d			call macro_dsp_valuehl 
ca0e				endm 
# End of macro FORTH_DSP_VALUEHL
ca0e			 
ca0e 11 32 ea				ld de, cli_var_array 
ca11			 
ca11 eb					ex de, hl 
ca12 73					ld (hl), e 
ca13 23					inc hl 
ca14 72					ld (hl), d 
ca15			 
ca15					; destroy value TOS 
ca15			 
ca15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca15 cd c3 9d			call macro_forth_dsp_pop 
ca18				endm 
# End of macro FORTH_DSP_POP
ca18			 
ca18				       NEXTW 
ca18 c3 c1 9e			jp macro_next 
ca1b				endm 
# End of macro NEXTW
ca1b			.V0Q: 
ca1b				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
ca1b 79				db WORD_SYS_CORE+101             
ca1c 2c ca			dw .V1S            
ca1e 04				db 3 + 1 
ca1f .. 00			db "V0@",0              
ca23				endm 
# End of macro CWHEAD
ca23			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
ca23 2a 32 ea				ld hl, (cli_var_array) 
ca26 cd 14 9b				call forth_push_numhl 
ca29			 
ca29				       NEXTW 
ca29 c3 c1 9e			jp macro_next 
ca2c				endm 
# End of macro NEXTW
ca2c			.V1S: 
ca2c				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
ca2c 7a				db WORD_SYS_CORE+102             
ca2d 44 ca			dw .V1Q            
ca2f 04				db 3 + 1 
ca30 .. 00			db "V1!",0              
ca34				endm 
# End of macro CWHEAD
ca34			;| V1! ( u1 -- )  Store value to v1 | DONE 
ca34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca34 cd 0b 9d			call macro_dsp_valuehl 
ca37				endm 
# End of macro FORTH_DSP_VALUEHL
ca37			 
ca37 11 34 ea				ld de, cli_var_array+2 
ca3a				 
ca3a eb					ex de, hl 
ca3b 73					ld (hl), e 
ca3c 23					inc hl 
ca3d 72					ld (hl), d 
ca3e			 
ca3e					; destroy value TOS 
ca3e			 
ca3e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca3e cd c3 9d			call macro_forth_dsp_pop 
ca41				endm 
# End of macro FORTH_DSP_POP
ca41				       NEXTW 
ca41 c3 c1 9e			jp macro_next 
ca44				endm 
# End of macro NEXTW
ca44			.V1Q: 
ca44				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
ca44 7b				db WORD_SYS_CORE+103             
ca45 55 ca			dw .V2S            
ca47 04				db 3 + 1 
ca48 .. 00			db "V1@",0              
ca4c				endm 
# End of macro CWHEAD
ca4c			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
ca4c 2a 34 ea				ld hl, (cli_var_array+2) 
ca4f cd 14 9b				call forth_push_numhl 
ca52				       NEXTW 
ca52 c3 c1 9e			jp macro_next 
ca55				endm 
# End of macro NEXTW
ca55			.V2S: 
ca55				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
ca55 7c				db WORD_SYS_CORE+104             
ca56 6d ca			dw .V2Q            
ca58 04				db 3 + 1 
ca59 .. 00			db "V2!",0              
ca5d				endm 
# End of macro CWHEAD
ca5d			;| V2! ( u1 -- )  Store value to v2 | DONE 
ca5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca5d cd 0b 9d			call macro_dsp_valuehl 
ca60				endm 
# End of macro FORTH_DSP_VALUEHL
ca60			 
ca60 11 36 ea				ld de, cli_var_array+4 
ca63				 
ca63 eb					ex de, hl 
ca64 73					ld (hl), e 
ca65 23					inc hl 
ca66 72					ld (hl), d 
ca67			 
ca67					; destroy value TOS 
ca67			 
ca67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca67 cd c3 9d			call macro_forth_dsp_pop 
ca6a				endm 
# End of macro FORTH_DSP_POP
ca6a				       NEXTW 
ca6a c3 c1 9e			jp macro_next 
ca6d				endm 
# End of macro NEXTW
ca6d			.V2Q: 
ca6d				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
ca6d 7d				db WORD_SYS_CORE+105             
ca6e 7e ca			dw .V3S            
ca70 04				db 3 + 1 
ca71 .. 00			db "V2@",0              
ca75				endm 
# End of macro CWHEAD
ca75			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
ca75 2a 36 ea				ld hl, (cli_var_array+4) 
ca78 cd 14 9b				call forth_push_numhl 
ca7b				       NEXTW 
ca7b c3 c1 9e			jp macro_next 
ca7e				endm 
# End of macro NEXTW
ca7e			.V3S: 
ca7e				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
ca7e 7c				db WORD_SYS_CORE+104             
ca7f 96 ca			dw .V3Q            
ca81 04				db 3 + 1 
ca82 .. 00			db "V3!",0              
ca86				endm 
# End of macro CWHEAD
ca86			;| V3! ( u1 -- )  Store value to v3 | DONE 
ca86					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca86 cd 0b 9d			call macro_dsp_valuehl 
ca89				endm 
# End of macro FORTH_DSP_VALUEHL
ca89			 
ca89 11 38 ea				ld de, cli_var_array+6 
ca8c				 
ca8c eb					ex de, hl 
ca8d 73					ld (hl), e 
ca8e 23					inc hl 
ca8f 72					ld (hl), d 
ca90			 
ca90					; destroy value TOS 
ca90			 
ca90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca90 cd c3 9d			call macro_forth_dsp_pop 
ca93				endm 
# End of macro FORTH_DSP_POP
ca93				       NEXTW 
ca93 c3 c1 9e			jp macro_next 
ca96				endm 
# End of macro NEXTW
ca96			.V3Q: 
ca96				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
ca96 7d				db WORD_SYS_CORE+105             
ca97 a7 ca			dw .END            
ca99 04				db 3 + 1 
ca9a .. 00			db "V3@",0              
ca9e				endm 
# End of macro CWHEAD
ca9e			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
ca9e 2a 38 ea				ld hl, (cli_var_array+6) 
caa1 cd 14 9b				call forth_push_numhl 
caa4				       NEXTW 
caa4 c3 c1 9e			jp macro_next 
caa7				endm 
# End of macro NEXTW
caa7			 
caa7			 
caa7			 
caa7			 
caa7			 
caa7			; end of dict marker 
caa7			 
caa7 00			.END:    db WORD_SYS_END 
caa8 00 00			dw 0 
caaa 00				db 0 
caab			 
caab			; use to jp here for user dict words to save on macro expansion  
caab			 
caab			user_dict_next: 
caab				NEXTW 
caab c3 c1 9e			jp macro_next 
caae				endm 
# End of macro NEXTW
caae			 
caae			 
caae			user_exec: 
caae				;    ld hl, <word code> 
caae				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
caae				;    call forthexec 
caae				;    jp user_dict_next   (NEXT) 
caae			        ;    <word code bytes> 
caae eb				ex de, hl 
caaf 2a cc e5			ld hl,(os_tok_ptr) 
cab2				 
cab2				FORTH_RSP_NEXT 
cab2 cd bb 9a			call macro_forth_rsp_next 
cab5				endm 
# End of macro FORTH_RSP_NEXT
cab5			 
cab5			if DEBUG_FORTH_UWORD 
cab5						DMARK "UEX" 
cab5 f5				push af  
cab6 3a ca ca			ld a, (.dmark)  
cab9 32 71 ee			ld (debug_mark),a  
cabc 3a cb ca			ld a, (.dmark+1)  
cabf 32 72 ee			ld (debug_mark+1),a  
cac2 3a cc ca			ld a, (.dmark+2)  
cac5 32 73 ee			ld (debug_mark+2),a  
cac8 18 03			jr .pastdmark  
caca ..			.dmark: db "UEX"  
cacd f1			.pastdmark: pop af  
cace			endm  
# End of macro DMARK
cace				CALLMONITOR 
cace cd a3 94			call break_point_state  
cad1				endm  
# End of macro CALLMONITOR
cad1			endif 
cad1			 
cad1			 
cad1			 
cad1 eb				ex de, hl 
cad2 22 cc e5			ld (os_tok_ptr), hl 
cad5				 
cad5				; Don't use next - Skips the first word in uword. 
cad5			 
cad5 c3 52 9f			jp exec1 
cad8			;	NEXT 
cad8			 
cad8			 
cad8			; eof 
# End of file forth_wordsv4.asm
cad8			endif 
cad8			;;;;;;;;;;;;;; Debug code 
cad8			 
cad8			 
cad8			;if DEBUG_FORTH_PARSE 
cad8 .. 00		.nowordfound: db "No match",0 
cae1 .. 00		.compword:	db "Comparing word ",0 
caf1 .. 00		.nextwordat:	db "Next word at",0 
cafe .. 00		.charmatch:	db "Char match",0 
cb09			;endif 
cb09			if DEBUG_FORTH_JP 
cb09			.foundword:	db "Word match. Exec..",0 
cb09			endif 
cb09			;if DEBUG_FORTH_PUSH 
cb09 .. 00		.enddict:	db "Dict end. Push.",0 
cb19 .. 00		.push_str:	db "Pushing string",0 
cb28 .. 00		.push_num:	db "Pushing number",0 
cb37 .. 00		.data_sp:	db "SP:",0 
cb3b .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cb4d .. 00		.wordinde:	db "Word in DE (3/0):",0 
cb5f .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cb71			;endif 
cb71			;if DEBUG_FORTH_MALLOC 
cb71 .. 00		.push_malloc:	db "Malloc address",0 
cb80			;endif 
cb80			 
cb80			 
cb80			 
cb80			; display malloc address and current data stack pointer  
cb80			 
cb80			malloc_error: 
cb80 d5				push de 
cb81 f5				push af 
cb82 e5				push hl 
cb83 cd 75 8a			call clear_display 
cb86 11 a8 cb			ld de, .mallocerr 
cb89 3e 00			ld a,0 
cb8b			;	ld de,os_word_scratch 
cb8b cd 88 8a			call str_at_display 
cb8e 3e 11			ld a, display_row_1+17 
cb90 11 71 ee			ld de, debug_mark 
cb93 cd 88 8a			call str_at_display 
cb96 cd 98 8a			call update_display 
cb99				;call break_point_state 
cb99 cd b5 e2			call cin_wait 
cb9c			 
cb9c 3e 20			ld a, ' ' 
cb9e 32 bc e2			ld (os_view_disable), a 
cba1 e1				pop hl 
cba2 f1				pop af 
cba3 d1				pop de	 
cba4				CALLMONITOR 
cba4 cd a3 94			call break_point_state  
cba7				endm  
# End of macro CALLMONITOR
cba7 c9				ret 
cba8			 
cba8 .. 00		.mallocerr: 	db "Malloc Error",0 
cbb5			;if DEBUG_FORTH_PUSH 
cbb5			display_data_sp: 
cbb5 f5				push af 
cbb6			 
cbb6				; see if disabled 
cbb6			 
cbb6 3a bc e2			ld a, (os_view_disable) 
cbb9 fe 2a			cp '*' 
cbbb 28 67			jr z, .skipdsp 
cbbd			 
cbbd e5				push hl 
cbbe e5				push hl 
cbbf e5			push hl 
cbc0 cd 75 8a			call clear_display 
cbc3 e1			pop hl 
cbc4 7c				ld a,h 
cbc5 21 d0 e5			ld hl, os_word_scratch 
cbc8 cd a3 8f			call hexout 
cbcb e1				pop hl 
cbcc 7d				ld a,l 
cbcd 21 d2 e5			ld hl, os_word_scratch+2 
cbd0 cd a3 8f			call hexout 
cbd3 21 d4 e5			ld hl, os_word_scratch+4 
cbd6 3e 00			ld a,0 
cbd8 77				ld (hl),a 
cbd9 11 d0 e5			ld de,os_word_scratch 
cbdc 3e 28				ld a, display_row_2 
cbde cd 88 8a				call str_at_display 
cbe1 11 3b cb			ld de, .wordinhl 
cbe4 3e 00			ld a, display_row_1 
cbe6			 
cbe6 cd 88 8a				call str_at_display 
cbe9 11 71 ee			ld de, debug_mark 
cbec 3e 11			ld a, display_row_1+17 
cbee			 
cbee cd 88 8a				call str_at_display 
cbf1			 
cbf1				; display current data stack pointer 
cbf1 11 37 cb			ld de,.data_sp 
cbf4 3e 30				ld a, display_row_2 + 8 
cbf6 cd 88 8a				call str_at_display 
cbf9			 
cbf9 2a f8 e9			ld hl,(cli_data_sp) 
cbfc e5				push hl 
cbfd 7c				ld a,h 
cbfe 21 d0 e5			ld hl, os_word_scratch 
cc01 cd a3 8f			call hexout 
cc04 e1				pop hl 
cc05 7d				ld a,l 
cc06 21 d2 e5			ld hl, os_word_scratch+2 
cc09 cd a3 8f			call hexout 
cc0c 21 d4 e5			ld hl, os_word_scratch+4 
cc0f 3e 00			ld a,0 
cc11 77				ld (hl),a 
cc12 11 d0 e5			ld de,os_word_scratch 
cc15 3e 33				ld a, display_row_2 + 11 
cc17 cd 88 8a				call str_at_display 
cc1a			 
cc1a			 
cc1a cd 98 8a			call update_display 
cc1d cd f2 89			call delay1s 
cc20 cd f2 89			call delay1s 
cc23 e1				pop hl 
cc24			.skipdsp: 
cc24 f1				pop af 
cc25 c9				ret 
cc26			 
cc26			display_data_malloc: 
cc26			 
cc26 f5				push af 
cc27 e5				push hl 
cc28 e5				push hl 
cc29 e5			push hl 
cc2a cd 75 8a			call clear_display 
cc2d e1			pop hl 
cc2e 7c				ld a,h 
cc2f 21 d0 e5			ld hl, os_word_scratch 
cc32 cd a3 8f			call hexout 
cc35 e1				pop hl 
cc36 7d				ld a,l 
cc37 21 d2 e5			ld hl, os_word_scratch+2 
cc3a cd a3 8f			call hexout 
cc3d 21 d4 e5			ld hl, os_word_scratch+4 
cc40 3e 00			ld a,0 
cc42 77				ld (hl),a 
cc43 11 d0 e5			ld de,os_word_scratch 
cc46 3e 28				ld a, display_row_2 
cc48 cd 88 8a				call str_at_display 
cc4b 11 71 cb			ld de, .push_malloc 
cc4e 3e 00			ld a, display_row_1 
cc50			 
cc50 cd 88 8a				call str_at_display 
cc53			 
cc53				; display current data stack pointer 
cc53 11 37 cb			ld de,.data_sp 
cc56 3e 30				ld a, display_row_2 + 8 
cc58 cd 88 8a				call str_at_display 
cc5b			 
cc5b 2a f8 e9			ld hl,(cli_data_sp) 
cc5e e5				push hl 
cc5f 7c				ld a,h 
cc60 21 d0 e5			ld hl, os_word_scratch 
cc63 cd a3 8f			call hexout 
cc66 e1				pop hl 
cc67 7d				ld a,l 
cc68 21 d2 e5			ld hl, os_word_scratch+2 
cc6b cd a3 8f			call hexout 
cc6e 21 d4 e5			ld hl, os_word_scratch+4 
cc71 3e 00			ld a,0 
cc73 77				ld (hl),a 
cc74 11 d0 e5			ld de,os_word_scratch 
cc77 3e 33				ld a, display_row_2 + 11 
cc79 cd 88 8a				call str_at_display 
cc7c			 
cc7c cd 98 8a			call update_display 
cc7f cd f2 89			call delay1s 
cc82 cd f2 89			call delay1s 
cc85 e1				pop hl 
cc86 f1				pop af 
cc87 c9				ret 
cc88			;endif 
cc88			 
cc88			include "forth_autostart.asm" 
cc88			; list of commands to perform at system start up 
cc88			 
cc88			startcmds: 
cc88			;	dw test11 
cc88			;	dw test12 
cc88			;	dw test13 
cc88			;	dw test14 
cc88			;	dw test15 
cc88			;	dw test16 
cc88			;	dw test17 
cc88			;	dw ifthtest1 
cc88			;	dw ifthtest2 
cc88			;	dw ifthtest3 
cc88			;	dw mmtest1 
cc88			;	dw mmtest2 
cc88			;	dw mmtest3 
cc88			;	dw mmtest4 
cc88			;	dw mmtest5 
cc88			;	dw mmtest6 
cc88			;	dw iftest1 
cc88			;	dw iftest2 
cc88			;	dw iftest3 
cc88			;	dw looptest1 
cc88			;	dw looptest2 
cc88			;	dw test1 
cc88			;	dw test2 
cc88			;	dw test3 
cc88			;	dw test4 
cc88			;	dw game2r 
cc88			;	dw game2b1 
cc88			;	dw game2b2 
cc88			 
cc88				; start up words that are actually useful 
cc88			 
cc88 90 cd		    dw spi1 
cc8a e9 cd		    dw spi2 
cc8c 77 ce		    dw spi3 
cc8e 1f ce		    dw spi4 
cc90 4a ce		    dw spi5 
cc92 dd ce		    dw spi6 
cc94 32 cf		    dw spi7 
cc96			 
cc96 8a cf		    dw spi8 
cc98 a9 cf		    dw spi9 
cc9a 01 d0		    dw spi10 
cc9c			 
cc9c			; file editor 
cc9c 02 cd			dw edit1 
cc9e 23 cd			dw edit2 
cca0 58 cd			dw edit3 
cca2			 
cca2 74 d0			dw longread 
cca4 bb d0			dw clrstack 
cca6 ee d0			dw type 
cca8 d9 d2			dw stest 
ccaa 12 d1			dw strncpy 
ccac 6f d2			dw list 
ccae 73 d1			dw start1 
ccb0 83 d1			dw start2 
ccb2			;	dw start3 
ccb2 94 d1			dw start3b 
ccb4 0f d2			dw start3c 
ccb6			 
ccb6				; (unit) testing words 
ccb6			 
ccb6 50 d3			dw mtesta 
ccb8 05 d4			dw mtestb 
ccba a8 d4			dw mtestc 
ccbc 5d d5			dw mtestd 
ccbe 01 d6			dw mteste 
ccc0			 
ccc0				; demo/game words 
ccc0			 
ccc0 0d dd		        dw game3w 
ccc2 3b dd		        dw game3p 
ccc4 59 dd		        dw game3sc 
ccc6 8a dd		        dw game3vsi 
ccc8 b6 dd		        dw game3vs 
ccca				 
ccca 00 db			dw game2b 
cccc 6e db			dw game2bf 
ccce b8 db			dw game2mba 
ccd0 4e dc			dw game2mbas 
ccd2 90 dc			dw game2mb 
ccd4			 
ccd4 c1 d7			dw game1 
ccd6 d2 d7			dw game1a 
ccd8 34 d8			dw game1b 
ccda 69 d8			dw game1c 
ccdc 9f d8			dw game1d 
ccde d0 d8			dw game1s 
cce0 e4 d8			dw game1t 
cce2 f9 d8			dw game1f 
cce4 2d d9			dw game1z 
cce6 71 d9			dw game1zz 
cce8			 
cce8 b7 d6			dw test5 
ccea ef d6			dw test6 
ccec 27 d7			dw test7 
ccee 3b d7			dw test8 
ccf0 67 d7			dw test9 
ccf2 7d d7			dw test10 
ccf4				 
ccf4 48 da		        dw ssv5 
ccf6 2c da		        dw ssv4 
ccf8 10 da		        dw ssv3 
ccfa da d9		        dw ssv2 
ccfc 61 da		        dw ssv1 
ccfe a9 da		        dw ssv1cpm 
cd00			;	dw keyup 
cd00			;	dw keydown 
cd00			;	dw keyleft 
cd00			;	dw keyright 
cd00			;	dw 	keyf1 
cd00			;	dw keyf2 
cd00			;	dw keyf3 
cd00			;	dw keyf4 
cd00			;	dw keyf5 
cd00			;	dw keyf6 
cd00			;	dw keyf7 
cd00			;	dw keyf8 
cd00			;	dw keyf9 
cd00			;	dw keyf10 
cd00			;	dw keyf11 
cd00			;	dw keyf12 
cd00			;	dw keytab 
cd00			;	dw keycr 
cd00			;	dw keyhome 
cd00			;	dw keyend 
cd00			;	dw keybs 
cd00 00 00			db 0, 0	 
cd02			 
cd02			 
cd02			; File Editor 
cd02			 
cd02			; ( id - ) use 'e' to edit the displayed line 
cd02 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd23 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd58			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cd58 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cd90			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cd90			 
cd90			; SPI Net support words 
cd90			 
cd90			; v0! = node to send to 
cd90			; ( str count - ) 
cd90 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
cde9			 
cde9			; spiputchr ( char node - ) 
cde9 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce1f			 
ce1f			; spigetchr ( - n ) 
ce1f .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
ce4a			 
ce4a			; getnode ( - n ) 
ce4a .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
ce77			 
ce77			; ( str node - )  
ce77 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cedd			; store string ( str i - ) 
cedd			 
cedd			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cedd .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf32			 
cf32			; get string ( addr i -  )    TO FIX 
cf32			 
cf32 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cf8a			 
cf8a			 
cf8a			; NETCHAT (TODO) 
cf8a			; Program to allow two nodes to chat with eachother 
cf8a			; 
cf8a			; v0 - target node 
cf8a			;  
cf8a			; accept input at 0,0 
cf8a			; if input is string send spitype to target node 
cf8a			; starting at row 2,0 , while spigetchr is not zero ->  
cf8a			; 
cf8a			; 
cf8a			; TODO add paging of get request 
cf8a			 
cf8a			; ( node - ) 
cf8a .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
cfa9 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d001 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
d074			 
d074			 
d074			; Long read of currently open file 
d074 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d0bb			 
d0bb			; clear stack  
d0bb			 
d0bb .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
d0ee			 
d0ee			; type ( addr count - ) 
d0ee .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
d112			 
d112			; some direct memory words 
d112			; strncpy ( len t f -- t ) 
d112			 
d112 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d173			 
d173 .. 00		start1:     	db ": bpon $00 bp ;",0 
d183 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d194 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d20f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d26f			 
d26f			 
d26f			; a handy word to list items on the stack 
d26f			 
d26f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d2d9			 
d2d9			 
d2d9			; test stack  
d2d9			; rnd8 stest 
d2d9			 
d2d9 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d350			 
d350			; random malloc and free cycles 
d350			 
d350 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d405			 
d405			; fixed malloc and free cycles 
d405			 
d405 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d4a8			 
d4a8			; fixed double string push and drop cycle  
d4a8			 
d4a8 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d55d			 
d55d			; consistent fixed string push and drop cycle  
d55d			 
d55d .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d601			 
d601 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d6b7			 
d6b7			;test1:		db ": aa 1 2 3 ;", 0 
d6b7			;test2:     	db "111 aa 888 999",0 
d6b7			;test3:     	db ": bb 77 ;",0 
d6b7			;test4:     	db "$02 $01 do i . loop bb",0 
d6b7			 
d6b7 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d6ef .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d727 .. 00		test7:     	db ": box hline vline ;",0 
d73b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d767 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d77d .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d7a2 .. 00		test11:     	db "hello create .",0 
d7b1 .. 00		test12:     	db "hello2 create .",0 
d7c1			 
d7c1			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d7c1			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d7c1			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d7c1			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d7c1			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d7c1			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d7c1			 
d7c1			;iftest1:     	db "$0001 IF cls .",0 
d7c1			;iftest2:     	db "$0000 IF cls .",0 
d7c1			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d7c1			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d7c1			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d7c1			 
d7c1			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d7c1			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d7c1			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d7c1			 
d7c1			 
d7c1			 
d7c1			; a small guess the number game 
d7c1			 
d7c1 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d7d2 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d834			 
d834 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d869 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d89f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d8d0 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d8e4 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d8f9 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d92d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d971			 
d971			; Using 'ga' save a high score across multiple runs using external storage 
d971			 
d971 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d9da			 
d9da			 
d9da			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d9da			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d9da			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d9da			 
d9da			; simple screen saver to test code memory reuse to destruction 
d9da			 
d9da .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
da10 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
da2c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
da48 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
da61 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
daa9 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
db00			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
db00			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
db00			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
db00			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
db00			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
db00			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
db00			 
db00			 
db00			 
db00			; minesweeper/battleship finding game 
db00			; draws a game board of random ship/mine positions 
db00			; user enters coords to see if it hits on 
db00			; game ends when all are hit 
db00			; when hit or miss says how many may be in the area 
db00			 
db00			; setup the game board and then hide it 
db00 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
db6e .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dbb8			; prompt for where to target 
dbb8 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dc4e .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dc73			; TODO see if the entered coords hits or misses pushes char hit of miss 
dc73 .. 00		game2mbht:      db ": mbckht nop ;",0 
dc82 .. 00		game2mbms:      db ": mbcms nop ;",0 
dc90			; TODO how many might be near by 
dc90 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
dd0d			 
dd0d			; Game 3 
dd0d			 
dd0d			; Vert scroller ski game - avoid the trees! 
dd0d			 
dd0d			; v0 score (ie turns) 
dd0d			; v1 player pos 
dd0d			; v2 left wall 
dd0d			; v3 right wall 
dd0d			 
dd0d			; Draw side walls randomly 
dd0d			 
dd0d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
dd3b			 
dd3b			; Draw player 
dd3b .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
dd59			 
dd59			; TODO Get Key 
dd59			 
dd59			; TODO Move left right 
dd59			 
dd59			; scroll and move walls a bit 
dd59			 
dd59 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
dd8a			 
dd8a			; main game loop 
dd8a			 
dd8a .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
ddb6 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
ddf5			 
ddf5			; key board defs 
ddf5			 
ddf5 .. 00		keyup:       db ": keyup $05 ;",0 
de03 .. 00		keydown:       db ": keydown $0a ;",0 
de13 .. 00		keyleft:       db ": keyleft $0b ;",0 
de23 .. 00		keyright:       db ": keyright $0c ;",0 
de34 .. 00		keyf1:       db ": keyf1 $10 ;",0 
de42 .. 00		keyf2:       db ": keyf2 $11 ;",0 
de50 .. 00		keyf3:       db ": keyf3 $12 ;",0 
de5e .. 00		keyf4:       db ": keyf4 $13 ;",0 
de6c .. 00		keyf5:       db ": keyf5 $14 ;",0 
de7a .. 00		keyf6:       db ": keyf6 $15 ;",0 
de88 .. 00		keyf7:       db ": keyf7 $16 ;",0 
de96 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dea4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
deb2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
dec1 .. 00		keyf11:       db ": keyf11 $1a ;",0 
ded0 .. 00		keyf12:       db ": keyf12 $1b ;",0 
dedf			 
dedf .. 00		keytab:       db ": keytab $09 ;",0 
deee .. 00		keycr:       db ": keycr $0d ;",0 
defc .. 00		keyhome:       db ": keyhome $0e ;",0 
df0c .. 00		keyend:       db ": keyend $0f ;",0 
df1b .. 00		keybs:       db ": keybs $08 ;",0 
df29			 
df29			   
df29			 
df29			 
df29			 
df29			; eof 
# End of file forth_autostart.asm
df29			 
df29			 
df29			 
df29			; stack over and underflow checks 
df29			 
df29			; init the words to detect the under/overflow 
df29			 
df29			chk_stk_init: 
df29				; a vague random number to check so we dont get any "lucky" hits 
df29 3e 2d			ld a, 45 
df2b 6f				ld l, a 
df2c 00				nop 
df2d 3e 17			ld a, 23 
df2f 67				ld h, a 
df30			 
df30 22 b2 e2			ld (chk_word), hl     ; the word we need to check against 
df33			 
df33			;	ld (chk_stund), hl	; stack points.... 
df33 22 00 ef			ld (chk_stovr), hl 
df36 22 f6 e9			ld (chk_ret_und), hl 
df39 22 b4 e9			ld (chk_ret_ovr), hl 
df3c 22 32 e9			ld (chk_loop_ovr), hl 
df3f 22 30 e8			ld (chk_data_ovr), hl 
df42 c9				ret 
df43				 
df43			check_stacks: 
df43				; check all stack words 
df43			 
df43 e5				push hl 
df44 d5				push de 
df45			 
df45			;	ld de,(chk_word) 
df45			;	ld hl, (chk_stund)	; stack points.... 
df45			;	if DEBUG_STK_FAULT 
df45			;		DMARK "FAa" 
df45			;		CALLMONITOR 
df45			;	endif 
df45			;	call cmp16 
df45			;	jp z, .chk_faulta 
df45			; 
df45			;	ld de, sfaultsu 
df45			;	jp .chk_fault 
df45			 
df45 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
df48 ed 5b b2 e2		ld de,(chk_word) 
df4c				if DEBUG_STK_FAULT 
df4c					DMARK "FAb" 
df4c					CALLMONITOR 
df4c				endif 
df4c cd c0 8c			call cmp16 
df4f 28 06			jr z, .chk_fault1 
df51 11 f2 df			ld de, sfaultso 
df54 c3 a6 df			jp .chk_fault 
df57			.chk_fault1:  
df57 2a f6 e9			ld hl, (chk_ret_und) 
df5a ed 5b b2 e2		ld de,(chk_word) 
df5e				if DEBUG_STK_FAULT 
df5e					DMARK "FAU" 
df5e					CALLMONITOR 
df5e				endif 
df5e cd c0 8c			call cmp16 
df61 ca 6a df			jp z, .chk_fault2 
df64 11 02 e0			ld de, sfaultru 
df67 c3 a6 df			jp .chk_fault 
df6a			.chk_fault2:  
df6a 2a b4 e9			ld hl, (chk_ret_ovr) 
df6d ed 5b b2 e2		ld de,(chk_word) 
df71				if DEBUG_STK_FAULT 
df71					DMARK "FA1" 
df71					CALLMONITOR 
df71				endif 
df71 cd c0 8c			call cmp16 
df74 ca 7d df			jp z, .chk_fault3 
df77 11 10 e0			ld de, sfaultro 
df7a c3 a6 df			jp .chk_fault 
df7d			.chk_fault3:  
df7d 2a 32 e9			ld hl, (chk_loop_ovr) 
df80 ed 5b b2 e2		ld de,(chk_word) 
df84				if DEBUG_STK_FAULT 
df84					DMARK "FA2" 
df84					CALLMONITOR 
df84				endif 
df84 cd c0 8c			call cmp16 
df87 ca 90 df			jp z, .chk_fault4 
df8a 11 2a e0			ld de, sfaultlo 
df8d c3 a6 df			jp .chk_fault 
df90			.chk_fault4:  
df90 2a 30 e8			ld hl, (chk_data_ovr) 
df93 ed 5b b2 e2		ld de,(chk_word) 
df97				if DEBUG_STK_FAULT 
df97					DMARK "FA3" 
df97					CALLMONITOR 
df97				endif 
df97 cd c0 8c			call cmp16 
df9a ca a3 df			jp z, .chk_fault5 
df9d 11 44 e0			ld de, sfaultdo 
dfa0 c3 a6 df			jp .chk_fault 
dfa3			 
dfa3			 
dfa3			.chk_fault5:  
dfa3 d1				pop de 
dfa4 e1				pop hl 
dfa5			 
dfa5 c9				ret 
dfa6			 
dfa6 cd 75 8a		.chk_fault: 	call clear_display 
dfa9 3e 28				ld a, display_row_2 
dfab cd 88 8a				call str_at_display 
dfae 11 d4 df				   ld de, .stackfault 
dfb1 3e 00				ld a, display_row_1 
dfb3 cd 88 8a				call str_at_display 
dfb6 11 71 ee				    ld de, debug_mark 
dfb9 3e 11				ld a, display_row_1+17 
dfbb cd 88 8a				call str_at_display 
dfbe cd 98 8a				call update_display 
dfc1			 
dfc1				; prompt before entering montior for investigating issue 
dfc1			 
dfc1 3e 78			ld a, display_row_4 
dfc3 11 2e 98			ld de, endprog 
dfc6			 
dfc6 cd 98 8a			call update_display		 
dfc9			 
dfc9 cd 8c 9a			call next_page_prompt 
dfcc			 
dfcc d1				pop de 
dfcd e1				pop hl 
dfce cd 82 98				call monitor 
dfd1 c3 7c 97				jp warmstart 
dfd4					;jp 0 
dfd4					;halt 
dfd4			 
dfd4			 
dfd4			 
dfd4 .. 00		.stackfault: 	db "Stack fault:",0 
dfe1			 
dfe1 .. 00		sfaultsu: 	db	"Stack under flow",0 
dff2 .. 00		sfaultso: 	db	"Stack over flow",0 
e002 .. 00		sfaultru:	db "RTS underflow",0 
e010 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e02a .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e044 .. 00		sfaultdo:	db "DTS overflow", 0 
e051			 
e051			 
e051			fault_dsp_under: 
e051 11 63 e0			ld de, .dsp_under 
e054 c3 13 e1			jp .show_fault 
e057			 
e057			fault_rsp_under: 
e057 11 71 e0			ld de, .rsp_under 
e05a c3 13 e1			jp .show_fault 
e05d			fault_loop_under: 
e05d 11 7f e0			ld de, .loop_under 
e060 c3 13 e1			jp .show_fault 
e063			 
e063 .. 00		.dsp_under: db "DSP Underflow",0 
e071 .. 00		.rsp_under: db "RSP Underflow",0 
e07f .. 00		.loop_under: db "LOOP Underflow",0 
e08e			 
e08e			 
e08e d5			type_faultn: 	push de 
e08f e5					push hl 
e090 cd 75 8a				call clear_display 
e093 11 ba e0				   ld de, .typefaultn 
e096 3e 00				ld a, display_row_1 
e098 cd 88 8a				call str_at_display 
e09b 11 71 ee				    ld de, debug_mark 
e09e 3e 11				ld a, display_row_1+17 
e0a0 cd 88 8a				call str_at_display 
e0a3 cd 98 8a				call update_display 
e0a6			 
e0a6				; prompt before entering montior for investigating issue 
e0a6			 
e0a6 3e 78			ld a, display_row_4 
e0a8 11 2e 98			ld de, endprog 
e0ab			 
e0ab cd 98 8a			call update_display		 
e0ae			 
e0ae cd 8c 9a			call next_page_prompt 
e0b1			 
e0b1 e5					push hl 
e0b2 d5					push de 
e0b3 cd 82 98				call monitor 
e0b6 c3 7c 97				jp warmstart 
e0b9 76					halt 
e0ba			 
e0ba			 
e0ba .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e0d1			 
e0d1 d5			type_faults: 	push de 
e0d2 e5					push hl 
e0d3 cd 75 8a				call clear_display 
e0d6 11 fc e0				   ld de, .typefaults 
e0d9 3e 00				ld a, display_row_1 
e0db cd 88 8a				call str_at_display 
e0de 11 71 ee				    ld de, debug_mark 
e0e1 3e 11				ld a, display_row_1+17 
e0e3 cd 88 8a				call str_at_display 
e0e6 cd 98 8a				call update_display 
e0e9			 
e0e9				; prompt before entering montior for investigating issue 
e0e9			 
e0e9 3e 78			ld a, display_row_4 
e0eb 11 2e 98			ld de, endprog 
e0ee			 
e0ee cd 98 8a			call update_display		 
e0f1			 
e0f1 cd 8c 9a			call next_page_prompt 
e0f4			 
e0f4 e1					pop hl 
e0f5 d1					pop de 
e0f6 cd 82 98				call monitor 
e0f9 c3 7c 97				jp warmstart 
e0fc			 
e0fc			 
e0fc .. 00		.typefaults: db "STR Type Expected TOS!",0 
e113			 
e113			.show_fault: 	 
e113 d5					push de 
e114 cd 75 8a				call clear_display 
e117 d1					pop de 
e118 3e 00				ld a, display_row_1 
e11a cd 88 8a				call str_at_display 
e11d 11 71 ee				    ld de, debug_mark 
e120 3e 11				ld a, display_row_1+17 
e122 cd 88 8a				call str_at_display 
e125 cd 98 8a				call update_display 
e128			 
e128				; prompt before entering montior for investigating issue 
e128			 
e128 3e 78			ld a, display_row_4 
e12a 11 2e 98			ld de, endprog 
e12d			 
e12d cd 98 8a			call update_display		 
e130			 
e130 cd 8c 9a			call next_page_prompt 
e133			 
e133 e1					pop hl 
e134 d1					pop de 
e135 cd 82 98				call monitor 
e138			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e138			; TODO Make optional fault restart to cli or warm boot? 
e138					;jp warmstart 
e138 c3 d4 97				jp cli 
e13b 76					halt 
e13c			 
e13c			; handle the auto run of code from files in storage 
e13c			 
e13c			 
e13c			include "forth_startup.asm" 
e13c			; Which startup method to use? 
e13c			; 
e13c			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e13c			; followed by loading of a list of scripts in eeprom 
e13c			 
e13c			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e13c			; from eeprom 
e13c			 
e13c			; Select with define in main stubs 
e13c			 
e13c			if STARTUP_V1 
e13c				include "forth_startupv1.asm" 
e13c			; Startup script loading version 1 
e13c			 
e13c			; If SE storage is available first stage is to use the selected file 
e13c			; then go through the eeprom list 
e13c			 
e13c .. 00		sprompt1: db "Startup load...",0 
e14c .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e162			 
e162			 
e162			 
e162			 
e162			forth_startup: 
e162 21 88 cc			ld hl, startcmds 
e165 3e 00			ld a, 0 
e167 32 f1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e16a			 
e16a e5			.start1:	push hl 
e16b cd 75 8a			call clear_display 
e16e 11 3c e1			ld de, sprompt1 
e171 3e 00		        ld a, display_row_1 
e173 cd 88 8a			call str_at_display 
e176 11 4c e1			ld de, sprompt2 
e179 3e 28		        ld a, display_row_2 
e17b cd 88 8a			call str_at_display 
e17e e1				pop hl 
e17f e5				push hl 
e180 5e				ld e,(hl) 
e181 23				inc hl 
e182 56				ld d,(hl) 
e183 3e 50		        ld a, display_row_3 
e185 cd 88 8a			call str_at_display 
e188 cd 98 8a			call update_display 
e18b			 
e18b			 
e18b 3a f1 e6			ld a, (os_last_cmd) 
e18e fe 00			cp 0 
e190 28 05			jr z, .startprompt 
e192 cd e6 89			call delay250ms 
e195 18 24			jr .startdo 
e197				 
e197				 
e197			 
e197			.startprompt: 
e197			 
e197 3e 9f			ld a,display_row_4 + display_cols - 1 
e199 11 8a 9a		        ld de, endprg 
e19c cd 88 8a			call str_at_display 
e19f cd 98 8a			call update_display 
e1a2 cd f2 89			call delay1s 
e1a5 cd b5 e2			call cin_wait 
e1a8						 
e1a8 fe 2a			cp '*' 
e1aa 28 5e			jr z, .startupend1 
e1ac fe 23			cp '#' 
e1ae 20 07			jr nz, .startno 
e1b0 3e 01			ld a, 1 
e1b2 32 f1 e6			ld (os_last_cmd),a 
e1b5 18 04			jr .startdo 
e1b7 fe 31		.startno:	cp '1' 
e1b9 28 3a			jr z,.startnxt  
e1bb			 
e1bb				; exec startup line 
e1bb			.startdo:	 
e1bb e1				pop hl 
e1bc e5				push hl 
e1bd				 
e1bd 5e				ld e,(hl) 
e1be 23				inc hl 
e1bf 56				ld d,(hl) 
e1c0 eb				ex de,hl 
e1c1			 
e1c1 e5				push hl 
e1c2			 
e1c2 3e 00			ld a, 0 
e1c4				;ld a, FORTH_END_BUFFER 
e1c4 cd 0b 91			call strlent 
e1c7 23				inc hl   ; include zero term to copy 
e1c8 06 00			ld b,0 
e1ca 4d				ld c,l 
e1cb e1				pop hl 
e1cc 11 cb e2			ld de, scratch 
e1cf ed b0			ldir 
e1d1			 
e1d1			 
e1d1 21 cb e2			ld hl, scratch 
e1d4 cd 0f 9f			call forthparse 
e1d7 cd 4f 9f			call forthexec 
e1da cd 61 9e			call forthexec_cleanup 
e1dd			 
e1dd 3e 78			ld a, display_row_4 
e1df 11 2e 98			ld de, endprog 
e1e2			 
e1e2 cd 98 8a			call update_display		 
e1e5			 
e1e5 3a f1 e6			ld a, (os_last_cmd) 
e1e8 fe 00			cp 0 
e1ea 20 09			jr nz, .startnxt 
e1ec cd 8c 9a			call next_page_prompt 
e1ef cd 75 8a		        call clear_display 
e1f2 cd 98 8a			call update_display		 
e1f5			 
e1f5				; move onto next startup line? 
e1f5			.startnxt: 
e1f5			 
e1f5 cd e6 89			call delay250ms 
e1f8 e1				pop hl 
e1f9			 
e1f9 23				inc hl 
e1fa 23				inc hl 
e1fb			 
e1fb e5				push hl 
e1fc 5e				ld e, (hl) 
e1fd 23				inc hl 
e1fe 56				ld d, (hl) 
e1ff e1				pop hl 
e200				; TODO replace 0 test 
e200			 
e200 eb				ex de, hl 
e201 cd cb 8c			call ishlzero 
e204			;	ld a,e 
e204			;	add d 
e204			;	cp 0    ; any left to do? 
e204 eb				ex de, hl 
e205 c2 6a e1			jp nz, .start1 
e208 18 01			jr .startupend 
e20a			 
e20a e1			.startupend1: pop hl 
e20b			.startupend: 
e20b			 
e20b cd 75 8a			call clear_display 
e20e cd 98 8a			call update_display 
e211 c9				ret 
e212			if STORAGE_SE 
e212			 
e212			sprompt3: db "Loading from start-up file?:",0 
e212			sprompt4: db "(Y=Any key/N=No)",0 
e212			 
e212			 
e212			forth_autoload: 
e212			 
e212				; load block 0 of store 1 
e212				 
e212				ld a, $fe      ; bit 0 clear 
e212				ld (spi_device), a 
e212			 
e212				call storage_get_block_0 
e212			 
e212				ld a, (store_page+STORE_0_AUTOFILE) 
e212			 
e212				cp 0 
e212				ret z     ; auto start not enabled 
e212			 
e212				call clear_display 
e212			 
e212				; set bank 
e212			 
e212					ld a, (store_page+STORE_0_BANKRUN) 
e212					ld (spi_device), a 
e212			 
e212				; get file id to load from and get the file name to display 
e212			 
e212					ld a, (store_page+STORE_0_FILERUN) 
e212			 
e212					ld l, 0 
e212					ld h, a 
e212					ld de, store_page 
e212			 
e212					if DEBUG_FORTH_WORDS 
e212						DMARK "ASp" 
e212						CALLMONITOR 
e212					endif 
e212					call storage_read 
e212			 
e212					if DEBUG_FORTH_WORDS 
e212						DMARK "ASr" 
e212						CALLMONITOR 
e212					endif 
e212			 
e212					call ishlzero 
e212					ret z             ; file not found 
e212			 
e212					ld a, display_row_2 + 10 
e212					ld de, store_page+3 
e212					call str_at_display 
e212				 
e212			; 
e212			 
e212				ld a, display_row_1+5 
e212				ld de, sprompt3 
e212				call str_at_display 
e212				ld a, display_row_3+15 
e212				ld de, sprompt4 
e212				call str_at_display 
e212			 
e212				call update_display 
e212			 
e212				call cin_wait 
e212				cp 'n' 
e212				ret z 
e212				cp 'N' 
e212				ret z 
e212			 
e212				call delay1s 
e212			 
e212				ld a, (store_page+2) 
e212				ld (store_openmaxext), a    ; save count of ext 
e212				ld a, 1  
e212				ld (store_openext), a    ; save count of ext 
e212			 
e212			.autof:  
e212				ld l , a 
e212				 
e212				ld a, (store_page) 
e212				ld h, a	 
e212				ld de, store_page 
e212					if DEBUG_FORTH_WORDS 
e212						DMARK "ASl" 
e212						CALLMONITOR 
e212					endif 
e212					call storage_read 
e212				call ishlzero 
e212				ret z 
e212			;	jr z, .autoend 
e212			 
e212					if DEBUG_FORTH_WORDS 
e212						DMARK "ASc" 
e212						CALLMONITOR 
e212					endif 
e212				ld de, store_page+2 
e212				ld a, display_row_4 
e212				call str_at_display 
e212			 
e212				call update_display 
e212				call delay250ms 
e212			 
e212			 
e212			 
e212				ld hl, store_page+2 
e212				call forthparse 
e212				call forthexec 
e212				call forthexec_cleanup 
e212			 
e212				 
e212				ld a, (store_openext) 
e212				inc a 
e212				ld (store_openext), a    ; save count of ext 
e212			 
e212				jr .autof 
e212			;.autofdone: 
e212			; 
e212			;		if DEBUG_FORTH_WORDS 
e212			;			DMARK "ASx" 
e212			;			CALLMONITOR 
e212			;		endif 
e212			;;	call clear_display 
e212			;	ret 
e212			 
e212			 
e212			 
e212			endif 
# End of file forth_startupv1.asm
e212			endif 
e212			if STARTUP_V2 
e212				include "forth_startupv2.asm" 
e212			endif 
e212			 
# End of file forth_startup.asm
e212			 
e212			; eof 
# End of file forth_kernel.asm
e212			;include "nascombasic.asm" 
e212			 
e212			 
e212			; find out where the code ends if loaded into RAM (for SC114) 
e212			;endofcode:  
e212			;	nop 
e212			 
e212			 
e212			; eof 
e212			 
# End of file main.asm
e212			;include "firmware_lcd_4x40.asm" 
e212			;;include "firmware_lcd_4x20.asm" 
e212			include "firmware_serial_display.asm" 
e212			 
e212			; Serial display interface for SC114 
e212			 
e212			 
e212			display_row_1: equ 0 
e212			display_row_2: equ display_row_1+display_cols 
e212			display_row_3: equ display_row_2 + display_cols 
e212			display_row_4: equ display_row_3 + display_cols 
e212			 
e212			kLCDWidth:  EQU display_cols             ;Width in characters 
e212			kLCD_Line1: EQU 0x00  
e212			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e212			; E1 
e212			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e212			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e212			 
e212			lcd_init: 
e212				; no init as handled by the SCM bios 
e212 c9				ret 
e213			 
e213			 
e213			; low level functions for direct screen writes 
e213			 
e213			; output char at pos? 
e213			fLCD_Str: 
e213			        ;out (SC114_SIO_1_OUT),a 
e213 c5				push bc 
e214 0e 02			ld c, $02 
e216 f7				rst $30 
e217 c1				pop bc 
e218 c9				ret 
e219			 
e219			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e219			fLCD_Pos: 
e219				; use ASCII escape to position 
e219			        ;out (SC114_SIO_1_OUT),a 
e219 c5				push bc 
e21a 0e 02			ld c, $02 
e21c f7				rst $30 
e21d c1				pop bc 
e21e			 
e21e c9				ret 
e21f			 
e21f			; output char at pos 
e21f			fLCD_Data: 
e21f			      ;  out (SC114_SIO_1_OUT),a 
e21f c5				push bc 
e220 0e 02			ld c, $02 
e222 f7				rst $30 
e223 c1				pop bc 
e224			 
e224 c9				ret 
e225			 
e225			; ascii cls  
e225			 
e225 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e229			 
e229			; write the frame buffer given in hl to hardware  
e229			write_display: 
e229			 
e229			API: equ 0 
e229			 
e229			if API 
e229				push bc 
e229				ld b, 4 
e229			 
e229			        ld (display_write_tmp), hl 	  
e229			 
e229				; clear and home cursor 
e229			 
e229				ld c, 6 
e229				ld de, .cls 
e229				rst $30 
e229			 
e229			 
e229			.writeln: 
e229			 
e229				ld de, (display_write_tmp) 
e229				ld c, 6 
e229				rst $30 
e229				ld c, 7 
e229				rst $30 
e229			 
e229				ld hl, (display_write_tmp) 
e229				ld de, display_cols 
e229				add hl,de 
e229				ld (display_write_tmp),hl 
e229			 
e229				djnz  .writeln 
e229			 
e229				pop bc 
e229			 
e229			 
e229				ret 
e229			endif 
e229 e5				push hl 
e22a c5				push bc 
e22b d5				push de 
e22c			 
e22c			;	ld c, 2 
e22c			;	;ld de, .cls 
e22c			;	ld a, 27 
e22c			;	rst $30 
e22c			;	ld c, 2 
e22c			;	;ld de, .cls 
e22c			;	ld a, '[' 
e22c			;	rst $30 
e22c			; 
e22c			;	ld c, 2 
e22c			;	;ld de, .cls 
e22c			;	ld a, 'H' 
e22c			;	rst $30 
e22c			; 
e22c			 
e22c 0e 02			ld c, 2 
e22e				;ld de, .cls 
e22e 3e 1b			ld a, 27 
e230 f7				rst $30 
e231			 
e231			 
e231 0e 02			ld c, 2 
e233				;ld de, .cls 
e233 3e 5b			ld a, '[' 
e235 f7				rst $30 
e236 0e 02			ld c, 2 
e238				;ld de, .cls 
e238 3e 32			ld a, '2' 
e23a f7				rst $30 
e23b 0e 02			ld c, 2 
e23d				;ld de, .cls 
e23d 3e 4a			ld a, 'J' 
e23f f7				rst $30 
e240 d1				pop de 
e241 c1				pop bc 
e242 e1				pop hl 
e243			 
e243			 
e243 22 cf eb		        ld (display_write_tmp), hl 	  
e246 3e 00			ld a, kLCD_Line1 
e248			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e248 06 28			ld b, display_cols 
e24a ed 5b cf eb		ld de, (display_write_tmp) 
e24e cd ac e2			call write_len_string 
e251				 
e251			 
e251 e5			push hl 
e252 d5			push de 
e253 c5			push bc 
e254 0e 07			ld c, 7 
e256 f7				rst $30 
e257 c1			pop bc 
e258 d1			pop de 
e259 e1			pop hl 
e25a			 
e25a				 
e25a 2a cf eb			ld hl, (display_write_tmp) 
e25d 11 28 00			ld de, display_cols 
e260 19				add hl,de 
e261 22 cf eb			ld (display_write_tmp),hl 
e264			 
e264				 
e264 3e 28			ld a, kLCD_Line2 
e266			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e266 06 28			ld b, display_cols 
e268 ed 5b cf eb		ld de, (display_write_tmp) 
e26c cd ac e2			call write_len_string 
e26f				 
e26f 2a cf eb			ld hl, (display_write_tmp) 
e272 11 28 00			ld de, display_cols 
e275 19				add hl,de 
e276 22 cf eb			ld (display_write_tmp),hl 
e279			 
e279 e5			push hl 
e27a d5			push de 
e27b c5			push bc 
e27c 0e 07			ld c, 7 
e27e f7				rst $30 
e27f c1			pop bc 
e280 d1			pop de 
e281 e1			pop hl 
e282			 
e282				 
e282 3e 50			ld a, kLCD_Line3 
e284			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e284 06 28			ld b, display_cols 
e286 ed 5b cf eb		ld de, (display_write_tmp) 
e28a cd ac e2			call write_len_string 
e28d				 
e28d 2a cf eb			ld hl, (display_write_tmp) 
e290 11 28 00			ld de, display_cols 
e293 19				add hl,de 
e294 22 cf eb			ld (display_write_tmp),hl 
e297			 
e297 e5			push hl 
e298 d5			push de 
e299 c5			push bc 
e29a 0e 07			ld c, 7 
e29c f7				rst $30 
e29d c1			pop bc 
e29e d1			pop de 
e29f e1			pop hl 
e2a0			 
e2a0				 
e2a0 3e 78			ld a, kLCD_Line4 
e2a2			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e2a2 06 28			ld b, display_cols 
e2a4 ed 5b cf eb		ld de, (display_write_tmp) 
e2a8 cd ac e2			call write_len_string 
e2ab c9					ret 
e2ac			 
e2ac			 
e2ac				; write out a fixed length string given in b from de 
e2ac			 
e2ac 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e2ad cd 1f e2		            CALL fLCD_Data      ;Write character to display 
e2b0 13				inc de 
e2b1 10 f9			djnz write_len_string 
e2b3 c9				ret 
e2b4			 
e2b4			 
e2b4			; eof 
# End of file firmware_serial_display.asm
e2b4			;include "firmware_key_5x10.asm" 
e2b4			;;include "firmware_key_4x10.asm" 
e2b4			include "firmware_key_serial.asm" 
e2b4			; Serial keyboard interface for SC114 
e2b4			 
e2b4			key_init: 
e2b4				; no init as handled by the SCM bios 
e2b4 c9				ret 
e2b5			 
e2b5			 
e2b5			cin_wait: 
e2b5			;	ld a, 0 
e2b5			;	ret 
e2b5			 
e2b5				;in a,(SC114_SIO_1_IN) 
e2b5			        ; Use SCM API to get from whatever console device we are using 
e2b5 c5				push bc 
e2b6 0e 01			ld c, $01 
e2b8 f7				rst $30 
e2b9 c1				pop bc 
e2ba c9				ret 
e2bb			 
e2bb			cin: 
e2bb			 
e2bb			 
e2bb c5				push bc 
e2bc			 
e2bc				; any key waiting to process? 
e2bc 0e 03			ld c, $03 
e2be f7				rst $30 
e2bf 28 05			jr z, .cin_skip 
e2c1			 
e2c1				; yep, get it 
e2c1			 
e2c1 0e 01			ld c, $01 
e2c3 f7				rst $30 
e2c4 c1				pop bc 
e2c5 c9				ret 
e2c6			.cin_skip: 
e2c6 3e 00			ld a, 0 
e2c8 c1				pop bc 
e2c9 c9				ret 
e2ca			 
e2ca			 
e2ca			 
e2ca			 
# End of file firmware_key_serial.asm
e2ca			endofcode:  
e2ca			baseram:  
e2ca 00				nop 
e2cb			 
e2cb			heap_start: equ baseram+15  ; Starting address of heap 
e2cb			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e2cb			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e2cb			;VDU:  EQU     endofcode           ; BASIC Work space 
e2cb			; eof 
e2cb			 
# End of file os_mega_sc114.asm
e2cb
