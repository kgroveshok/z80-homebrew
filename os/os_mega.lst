# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 d6 15			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd b9 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd b9 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd b9 0a				call clear_display  
0023			  
0023			  
0023 cd 82 61				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 19 64			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b5 10				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 72 12				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd dc 0a			call update_display  
0035 cd 3d 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd be 0a			call fill_display  
003d cd dc 0a			call update_display  
0040 cd 3d 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd be 0a			call fill_display  
0048 cd dc 0a			call update_display  
004b cd 3d 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd be 0a			call fill_display  
0053 cd dc 0a			call update_display  
0056 cd 3d 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd cc 0a			call str_at_display  
0061 cd dc 0a			call update_display  
0064			  
0064			  
0064 cd 3d 0a			call delay1s  
0067 cd 3d 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd cc 0a			call str_at_display  
0072 cd dc 0a			call update_display  
0075 cd 3d 0a			call delay1s  
0078 cd 3d 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 5d f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 5d f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 5d f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 5d f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 5d f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 5f f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 5c f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 5c f8			ld (spi_device), a 
01e3 32 5f f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 5d f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 5d f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 5d f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 5d f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 5d f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 5d f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 5d f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 5d f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 22 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 5d f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 5d f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 5d f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 5d f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 5d f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 5d f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 5d f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 5d f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 22 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 5d f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 5d f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 5d f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 5d f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 34 ee			ld hl,scratch+2 
02be cd c9 0f			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 55 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 39 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 55 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 55 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 55 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 55 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 5a ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 5a ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 55 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 55 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 5a ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 55 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 00 14			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 00 14			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 22 06			call storage_findnextid 
0360			 
0360 cd 3b 0c			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 00 14			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 00 14			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 00 14			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 00 14			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 00 14			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b 21 62 f8			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 63 f8		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 cc 04			ld hl, .defaultbanklabl 
043a 11 65 f8		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; save default page 0 
0442			 
0442 21 00 00			ld hl, 0 
0445 11 62 f8			ld de, store_page 
0448				if DEBUG_STORESE 
0448					DMARK "SB3" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 77 fb			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 78 fb			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 79 fb			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SB3"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461			;		push af 
0461			;		ld a, 'F' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461					CALLMONITOR 
0461 cd 00 14			call break_point_state  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464 cd 71 03			call storage_write_block 
0467				if DEBUG_STORESE 
0467					DMARK "SB4" 
0467 f5				push af  
0468 3a 7c 04			ld a, (.dmark)  
046b 32 77 fb			ld (debug_mark),a  
046e 3a 7d 04			ld a, (.dmark+1)  
0471 32 78 fb			ld (debug_mark+1),a  
0474 3a 7e 04			ld a, (.dmark+2)  
0477 32 79 fb			ld (debug_mark+2),a  
047a 18 03			jr .pastdmark  
047c ..			.dmark: db "SB4"  
047f f1			.pastdmark: pop af  
0480			endm  
# End of macro DMARK
0480			;		push af 
0480			;		ld a, '>' 
0480			;		ld (debug_mark),a 
0480			;		pop af 
0480					CALLMONITOR 
0480 cd 00 14			call break_point_state  
0483				endm  
# End of macro CALLMONITOR
0483				endif 
0483			 
0483 00				nop 
0484 00				nop 
0485 00				nop 
0486			 
0486				; now set 0 in every page to mark as a free block 
0486			 
0486 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0488 21 40 00			ld hl, STORE_BLOCK_PHY 
048b			 
048b 3e 00		.setmark1:   	ld a,0 
048d e5					push hl 
048e c5					push bc 
048f cd ea 01				call se_writebyte 
0492 3e 0a			ld a, 10 
0494 cd 22 0a			call aDelayInMS 
0497 23				inc hl 
0498 cd ea 01				call se_writebyte 
049b 3e 0a			ld a, 10 
049d cd 22 0a			call aDelayInMS 
04a0 2b				dec hl 
04a1 c1					pop bc 
04a2 e1					pop hl 
04a3 3e 40				ld a, STORE_BLOCK_PHY 
04a5 cd 12 0c				call addatohl 
04a8 10 e1				djnz .setmark1 
04aa			 
04aa 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04ac 3e 00		.setmark2:   	ld a,0 
04ae e5					push hl 
04af c5					push bc 
04b0 cd ea 01				call se_writebyte 
04b3 3e 0a			ld a, 10 
04b5 cd 22 0a			call aDelayInMS 
04b8 23				inc hl 
04b9 cd ea 01				call se_writebyte 
04bc 3e 0a			ld a, 10 
04be cd 22 0a			call aDelayInMS 
04c1 2b				dec hl 
04c2 c1					pop bc 
04c3 e1					pop hl 
04c4 3e 40				ld a, STORE_BLOCK_PHY 
04c6 cd 12 0c				call addatohl 
04c9 10 e1				djnz .setmark2 
04cb			 
04cb					 
04cb			 
04cb			 
04cb c9				ret 
04cc			 
04cc			 
04cc			 
04cc			 
04cc .. 00		.defaultbanklabl:   db "BankLabel",0 
04d6			 
04d6			 
04d6			 
04d6			; Label Bank 
04d6			; ---------- 
04d6			; 
04d6			; With current bank 
04d6			; Read block 0 
04d6			; Set label 
04d6			; Write block 0 
04d6			 
04d6			; label str pointer in hl 
04d6			 
04d6			storage_label:     
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "LBL" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 77 fb			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 78 fb			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 79 fb			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "LBL"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef					CALLMONITOR 
04ef cd 00 14			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2 e5				push hl 
04f3			 
04f3 cd bd 03			call storage_get_block_0 
04f6			 
04f6				; set default label 
04f6			 
04f6 e1				pop hl 
04f7			 
04f7 11 65 f8		 	ld de, store_page+3 
04fa 01 0f 00			ld bc, 15 
04fd				if DEBUG_STORESE 
04fd					DMARK "LB3" 
04fd f5				push af  
04fe 3a 12 05			ld a, (.dmark)  
0501 32 77 fb			ld (debug_mark),a  
0504 3a 13 05			ld a, (.dmark+1)  
0507 32 78 fb			ld (debug_mark+1),a  
050a 3a 14 05			ld a, (.dmark+2)  
050d 32 79 fb			ld (debug_mark+2),a  
0510 18 03			jr .pastdmark  
0512 ..			.dmark: db "LB3"  
0515 f1			.pastdmark: pop af  
0516			endm  
# End of macro DMARK
0516					CALLMONITOR 
0516 cd 00 14			call break_point_state  
0519				endm  
# End of macro CALLMONITOR
0519				endif 
0519 ed b0			ldir 
051b				; save default page 0 
051b			 
051b 21 00 00			ld hl, 0 
051e 11 62 f8			ld de, store_page 
0521				if DEBUG_STORESE 
0521					DMARK "LBW" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 77 fb			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 78 fb			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 79 fb			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "LBW"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					CALLMONITOR 
053a cd 00 14			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d				endif 
053d cd 71 03			call storage_write_block 
0540			 
0540 c9				ret 
0541			 
0541			 
0541			 
0541			; Read Block 0 - Config 
0541			; --------------------- 
0541			; 
0541			; With current bank 
0541			; Call presence test 
0541			;    If not present format/init bank  
0541			; Read block 0  
0541			;  
0541			 
0541			 
0541			; Dir 
0541			; --- 
0541			; 
0541			; With current bank 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block read byte 2 
0541			;      if first block of file 
0541			;         Display file name 
0541			;         Display type flags for file 
0541			;        
0541			 
0541			; moving to words as this requires stack control 
0541			 
0541			 
0541			; Delete File 
0541			; ----------- 
0541			; 
0541			; With current bank 
0541			; 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block file id 
0541			;      If first block of file and dont have file id 
0541			;         if file to delete 
0541			;         Save file id 
0541			;         Null file id 
0541			;         Write this block back 
0541			;      If file id is one saved 
0541			;         Null file id 
0541			;         Write this block back 
0541			 
0541			storage_erase: 
0541			 
0541				; hl contains the file id 
0541			 
0541 5d				ld e, l 
0542 16 00			ld d, 0 
0544 21 40 00			ld hl, STORE_BLOCK_PHY 
0547					if DEBUG_FORTH_WORDS 
0547						DMARK "ERA" 
0547 f5				push af  
0548 3a 5c 05			ld a, (.dmark)  
054b 32 77 fb			ld (debug_mark),a  
054e 3a 5d 05			ld a, (.dmark+1)  
0551 32 78 fb			ld (debug_mark+1),a  
0554 3a 5e 05			ld a, (.dmark+2)  
0557 32 79 fb			ld (debug_mark+2),a  
055a 18 03			jr .pastdmark  
055c ..			.dmark: db "ERA"  
055f f1			.pastdmark: pop af  
0560			endm  
# End of macro DMARK
0560						CALLMONITOR 
0560 cd 00 14			call break_point_state  
0563				endm  
# End of macro CALLMONITOR
0563					endif 
0563 cd 22 06			call storage_findnextid 
0566			 
0566 e5				push hl 
0567			 
0567				; TODO check file not found 
0567			 
0567 11 62 f8			ld de, store_page 
056a cd 0c 03			call storage_read_block 
056d			 
056d					if DEBUG_FORTH_WORDS 
056d						DMARK "ER1" 
056d f5				push af  
056e 3a 82 05			ld a, (.dmark)  
0571 32 77 fb			ld (debug_mark),a  
0574 3a 83 05			ld a, (.dmark+1)  
0577 32 78 fb			ld (debug_mark+1),a  
057a 3a 84 05			ld a, (.dmark+2)  
057d 32 79 fb			ld (debug_mark+2),a  
0580 18 03			jr .pastdmark  
0582 ..			.dmark: db "ER1"  
0585 f1			.pastdmark: pop af  
0586			endm  
# End of macro DMARK
0586						CALLMONITOR 
0586 cd 00 14			call break_point_state  
0589				endm  
# End of macro CALLMONITOR
0589					endif 
0589 3a 62 f8			ld a, (store_page)	; get file id 
058c 32 5b f8			ld (store_tmpid), a 
058f			 
058f 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
0592 32 5a f8			ld (store_tmpext), a 
0595			 
0595				; wipe file header 
0595			 
0595 e1				pop hl 
0596 3e 00			ld a, 0 
0598 32 62 f8			ld (store_page), a 
059b 32 63 f8			ld (store_page+1),a 
059e 11 62 f8			ld de, store_page 
05a1					if DEBUG_FORTH_WORDS 
05a1						DMARK "ER2" 
05a1 f5				push af  
05a2 3a b6 05			ld a, (.dmark)  
05a5 32 77 fb			ld (debug_mark),a  
05a8 3a b7 05			ld a, (.dmark+1)  
05ab 32 78 fb			ld (debug_mark+1),a  
05ae 3a b8 05			ld a, (.dmark+2)  
05b1 32 79 fb			ld (debug_mark+2),a  
05b4 18 03			jr .pastdmark  
05b6 ..			.dmark: db "ER2"  
05b9 f1			.pastdmark: pop af  
05ba			endm  
# End of macro DMARK
05ba						CALLMONITOR 
05ba cd 00 14			call break_point_state  
05bd				endm  
# End of macro CALLMONITOR
05bd					endif 
05bd cd 71 03			call storage_write_block 
05c0			 
05c0			 
05c0				; wipe file extents 
05c0			 
05c0 3a 5a f8			ld a, (store_tmpext) 
05c3 47				ld b, a 
05c4			 
05c4			.eraext:	  
05c4 c5				push bc 
05c5			 
05c5 21 40 00			ld hl, STORE_BLOCK_PHY 
05c8 3a 5b f8			ld a,(store_tmpid) 
05cb 5f				ld e, a 
05cc 50				ld d, b	 
05cd					if DEBUG_FORTH_WORDS 
05cd						DMARK "ER3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 77 fb			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 78 fb			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 79 fb			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "ER3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6						CALLMONITOR 
05e6 cd 00 14			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9					endif 
05e9 cd 22 06			call storage_findnextid 
05ec			 
05ec e5				push hl 
05ed 11 62 f8			ld de, store_page 
05f0 cd 0c 03			call storage_read_block 
05f3			 
05f3				; free block	 
05f3			 
05f3 3e 00			ld a, 0 
05f5 32 62 f8			ld (store_page), a 
05f8 32 63 f8			ld (store_page+1),a 
05fb 11 62 f8			ld de, store_page 
05fe e1				pop hl 
05ff					if DEBUG_FORTH_WORDS 
05ff						DMARK "ER4" 
05ff f5				push af  
0600 3a 14 06			ld a, (.dmark)  
0603 32 77 fb			ld (debug_mark),a  
0606 3a 15 06			ld a, (.dmark+1)  
0609 32 78 fb			ld (debug_mark+1),a  
060c 3a 16 06			ld a, (.dmark+2)  
060f 32 79 fb			ld (debug_mark+2),a  
0612 18 03			jr .pastdmark  
0614 ..			.dmark: db "ER4"  
0617 f1			.pastdmark: pop af  
0618			endm  
# End of macro DMARK
0618						CALLMONITOR 
0618 cd 00 14			call break_point_state  
061b				endm  
# End of macro CALLMONITOR
061b					endif 
061b cd 71 03			call storage_write_block 
061e			 
061e c1				pop bc 
061f 10 a3			djnz .eraext 
0621			 
0621 c9				ret 
0622			 
0622			 
0622			; Find Free Block 
0622			; --------------- 
0622			; 
0622			; With current bank 
0622			;  
0622			; From given starting logical block 
0622			;    Read block  
0622			;    If no file id 
0622			;         Return block id 
0622			 
0622			 
0622			; hl starting page number 
0622			; hl contains free page number or zero if no pages free 
0622			; e contains the file id to locate 
0622			; d contains the block number 
0622			 
0622			; TODO change to find file id and use zero for free block 
0622			 
0622			storage_findnextid: 
0622			 
0622				; now locate first 0 page to mark as a free block 
0622			 
0622 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0624			;	ld hl, STORE_BLOCK_PHY 
0624			 
0624					if DEBUG_FORTH_WORDS 
0624					DMARK "FNI" 
0624 f5				push af  
0625 3a 39 06			ld a, (.dmark)  
0628 32 77 fb			ld (debug_mark),a  
062b 3a 3a 06			ld a, (.dmark+1)  
062e 32 78 fb			ld (debug_mark+1),a  
0631 3a 3b 06			ld a, (.dmark+2)  
0634 32 79 fb			ld (debug_mark+2),a  
0637 18 03			jr .pastdmark  
0639 ..			.dmark: db "FNI"  
063c f1			.pastdmark: pop af  
063d			endm  
# End of macro DMARK
063d						CALLMONITOR 
063d cd 00 14			call break_point_state  
0640				endm  
# End of macro CALLMONITOR
0640					endif 
0640			.ff1:   	 
0640 e5					push hl 
0641 c5					push bc 
0642 d5					push de 
0643 cd 8c 02				call se_readbyte 
0646 5f					ld e,a 
0647 23					inc hl 
0648 cd 8c 02				call se_readbyte 
064b 57					ld d, a 
064c e1					pop hl 
064d e5					push hl 
064e cd 30 0c				call cmp16 
0651 28 49				jr z, .fffound 
0653			 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is found? 
0656					;cp e 
0656					;ret z 
0656			 
0656 3e 40				ld a, STORE_BLOCK_PHY 
0658 cd 12 0c				call addatohl 
065b 10 e3				djnz .ff1 
065d			 
065d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065f			.ff2:   	 
065f			 
065f e5					push hl 
0660 c5					push bc 
0661 d5					push de 
0662 cd 8c 02				call se_readbyte 
0665 5f					ld e,a 
0666 23					inc hl 
0667 cd 8c 02				call se_readbyte 
066a 57					ld d, a 
066b			 
066b e1					pop hl 
066c e5					push hl 
066d cd 30 0c				call cmp16 
0670 28 2a				jr z, .fffound 
0672			 
0672 d1					pop de 
0673 c1					pop bc 
0674 e1					pop hl 
0675					; is found? 
0675					;cp e 
0675					;ret z 
0675			 
0675 3e 40				ld a, STORE_BLOCK_PHY 
0677 cd 12 0c				call addatohl 
067a 10 e3				djnz .ff2 
067c			 
067c			 
067c					if DEBUG_FORTH_WORDS 
067c					DMARK "FN-" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 77 fb			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 78 fb			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 79 fb			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "FN-"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					;	push af 
0695					;	ld a, 'n' 
0695					;	ld (debug_mark),a 
0695					;	pop af 
0695						CALLMONITOR 
0695 cd 00 14			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698					endif 
0698				; no free marks! 
0698 21 00 00				ld hl, 0 
069b c9				ret 
069c			.fffound: 
069c				 
069c			 
069c d1					pop de 
069d c1					pop bc 
069e e1					pop hl 
069f					if DEBUG_FORTH_WORDS 
069f					DMARK "FNF" 
069f f5				push af  
06a0 3a b4 06			ld a, (.dmark)  
06a3 32 77 fb			ld (debug_mark),a  
06a6 3a b5 06			ld a, (.dmark+1)  
06a9 32 78 fb			ld (debug_mark+1),a  
06ac 3a b6 06			ld a, (.dmark+2)  
06af 32 79 fb			ld (debug_mark+2),a  
06b2 18 03			jr .pastdmark  
06b4 ..			.dmark: db "FNF"  
06b7 f1			.pastdmark: pop af  
06b8			endm  
# End of macro DMARK
06b8					;	push af 
06b8					;	ld a, 'n' 
06b8					;	ld (debug_mark),a 
06b8					;	pop af 
06b8						CALLMONITOR 
06b8 cd 00 14			call break_point_state  
06bb				endm  
# End of macro CALLMONITOR
06bb					endif 
06bb c9				ret 
06bc			 
06bc			 
06bc			 
06bc			; Free Space 
06bc			; ---------- 
06bc			; 
06bc			; With current bank 
06bc			; 
06bc			; Set block count to zero 
06bc			; Starting with first logical block 
06bc			;      Find free block  
06bc			;      If block id given, increment block count 
06bc			; 
06bc			;  
06bc			 
06bc			 
06bc			; hl contains count of free blocks 
06bc			 
06bc			storage_freeblocks: 
06bc			 
06bc				; now locate first 0 page to mark as a free block 
06bc			 
06bc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06be 21 40 00			ld hl, STORE_BLOCK_PHY 
06c1 11 00 00			ld de, 0 
06c4			 
06c4			.fb1:   	 
06c4 e5					push hl 
06c5 c5					push bc 
06c6 d5					push de 
06c7 cd 8c 02				call se_readbyte 
06ca d1					pop de 
06cb c1					pop bc 
06cc e1					pop hl 
06cd			 
06cd					; is free? 
06cd fe 00				cp 0 
06cf 20 01				jr nz, .ff1cont 
06d1 13					inc de 
06d2			 
06d2			.ff1cont: 
06d2			 
06d2			 
06d2 3e 40				ld a, STORE_BLOCK_PHY 
06d4 cd 12 0c				call addatohl 
06d7 10 eb				djnz .fb1 
06d9			 
06d9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06db			.fb2:   	 
06db e5					push hl 
06dc c5					push bc 
06dd d5					push de 
06de cd 8c 02				call se_readbyte 
06e1 d1					pop de 
06e2 c1					pop bc 
06e3 e1					pop hl 
06e4			 
06e4					; is free? 
06e4 fe 00				cp 0 
06e6 20 01				jr nz, .ff2cont 
06e8 13					inc de 
06e9			 
06e9			.ff2cont: 
06e9			 
06e9 3e 40				ld a, STORE_BLOCK_PHY 
06eb cd 12 0c				call addatohl 
06ee 10 eb				djnz .fb2 
06f0			 
06f0 eb				ex de, hl 
06f1 c9				ret 
06f2			 
06f2			; Get File ID 
06f2			; ----------- 
06f2			; 
06f2			; With current bank 
06f2			;  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; For each logical block 
06f2			;    Read block file id 
06f2			;      If first block of file and dont have file id 
06f2			;         if file get id and exit 
06f2			 
06f2			 
06f2			 
06f2			 
06f2			; Create File 
06f2			; ----------- 
06f2			; 
06f2			; With current bank  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; Increment file id number 
06f2			; Save Config 
06f2			; Find free block 
06f2			; Set buffer with file name and file id 
06f2			; Write buffer to free block  
06f2			 
06f2			 
06f2			; hl point to file name 
06f2			; hl returns file id 
06f2			 
06f2			; file format: 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent number 
06f2			; byte 2-> data 
06f2			 
06f2			; format for extent number 0: 
06f2			; 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent 0 
06f2			; byte 2 - extent count 
06f2			; byte 3 -> file name and meta data 
06f2			 
06f2			 
06f2			storage_create: 
06f2				if DEBUG_STORESE 
06f2					DMARK "SCR" 
06f2 f5				push af  
06f3 3a 07 07			ld a, (.dmark)  
06f6 32 77 fb			ld (debug_mark),a  
06f9 3a 08 07			ld a, (.dmark+1)  
06fc 32 78 fb			ld (debug_mark+1),a  
06ff 3a 09 07			ld a, (.dmark+2)  
0702 32 79 fb			ld (debug_mark+2),a  
0705 18 03			jr .pastdmark  
0707 ..			.dmark: db "SCR"  
070a f1			.pastdmark: pop af  
070b			endm  
# End of macro DMARK
070b					CALLMONITOR 
070b cd 00 14			call break_point_state  
070e				endm  
# End of macro CALLMONITOR
070e				endif 
070e			 
070e e5				push hl		; save file name pointer 
070f			 
070f cd bd 03			call storage_get_block_0 
0712			 
0712 3a 62 f8			ld a,(store_page)	; get current file id 
0715 3c				inc a 
0716 32 62 f8			ld (store_page),a 
0719				 
0719 32 5b f8			ld (store_tmpid),a			; save id 
071c			 
071c 21 00 00			ld hl, 0 
071f 11 62 f8			ld de, store_page 
0722				if DEBUG_STORESE 
0722					DMARK "SCw" 
0722 f5				push af  
0723 3a 37 07			ld a, (.dmark)  
0726 32 77 fb			ld (debug_mark),a  
0729 3a 38 07			ld a, (.dmark+1)  
072c 32 78 fb			ld (debug_mark+1),a  
072f 3a 39 07			ld a, (.dmark+2)  
0732 32 79 fb			ld (debug_mark+2),a  
0735 18 03			jr .pastdmark  
0737 ..			.dmark: db "SCw"  
073a f1			.pastdmark: pop af  
073b			endm  
# End of macro DMARK
073b					CALLMONITOR 
073b cd 00 14			call break_point_state  
073e				endm  
# End of macro CALLMONITOR
073e				endif 
073e cd 71 03			call storage_write_block	 ; save update 
0741			 
0741				if DEBUG_STORESE 
0741 11 62 f8				ld de, store_page 
0744					DMARK "SCC" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 77 fb			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 78 fb			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 79 fb			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SCC"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 00 14			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760				;  
0760				 
0760 21 40 00			ld hl, STORE_BLOCK_PHY 
0763 11 00 00			ld de, 0 
0766 cd 22 06			call storage_findnextid 
0769			 
0769 22 60 f8			ld (store_tmppageid), hl    ; save page to use  
076c			 
076c				; TODO detect 0 = no spare blocks 
076c			 
076c				; hl now contains the free page to use for the file header page 
076c			 
076c				if DEBUG_STORESE 
076c				DMARK "SCF" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 77 fb			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 78 fb			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 79 fb			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCF"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 00 14			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788 22 60 f8			ld (store_tmppageid), hl 
078b				 
078b 3a 5b f8			ld a,(store_tmpid)    ; get file id 
078e			;	ld a, (store_filecache)			; save to cache 
078e			 
078e 32 62 f8			ld (store_page),a    ; set page id 
0791 3e 00			ld a, 0			 ; extent 0 is file header 
0793 32 63 f8			ld (store_page+1), a   ; set file extent 
0796			 
0796 32 64 f8			ld (store_page+2), a   ; extent count for the file 
0799			 
0799			;	inc hl 		; init block 0 of file 
0799			;	inc hl   		; skip file and extent id 
0799			 ;       ld a, 0 
0799			;	ld (hl),a 
0799			;	ld a, (store_filecache+1)  	; save to cache 
0799			 
0799			;	inc hl    ; file name 
0799				 
0799				 
0799 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
079c				if DEBUG_STORESE 
079c					DMARK "SCc" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 77 fb			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 78 fb			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 79 fb			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCc"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					CALLMONITOR 
07b5 cd 00 14			call break_point_state  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 e1				pop hl    ; get zero term string 
07b9 e5				push hl 
07ba 3e 00			ld a, 0 
07bc cd 7b 10			call strlent 
07bf 23				inc hl   ; cover zero term 
07c0 06 00			ld b,0 
07c2 4d				ld c,l 
07c3 e1				pop hl 
07c4				;ex de, hl 
07c4				if DEBUG_STORESE 
07c4					DMARK "SCa" 
07c4 f5				push af  
07c5 3a d9 07			ld a, (.dmark)  
07c8 32 77 fb			ld (debug_mark),a  
07cb 3a da 07			ld a, (.dmark+1)  
07ce 32 78 fb			ld (debug_mark+1),a  
07d1 3a db 07			ld a, (.dmark+2)  
07d4 32 79 fb			ld (debug_mark+2),a  
07d7 18 03			jr .pastdmark  
07d9 ..			.dmark: db "SCa"  
07dc f1			.pastdmark: pop af  
07dd			endm  
# End of macro DMARK
07dd					;push af 
07dd					;ld a, 'a' 
07dd					;ld (debug_mark),a 
07dd					;pop af 
07dd					CALLMONITOR 
07dd cd 00 14			call break_point_state  
07e0				endm  
# End of macro CALLMONITOR
07e0				endif 
07e0 ed b0			ldir    ; copy zero term string 
07e2				if DEBUG_STORESE 
07e2					DMARK "SCA" 
07e2 f5				push af  
07e3 3a f7 07			ld a, (.dmark)  
07e6 32 77 fb			ld (debug_mark),a  
07e9 3a f8 07			ld a, (.dmark+1)  
07ec 32 78 fb			ld (debug_mark+1),a  
07ef 3a f9 07			ld a, (.dmark+2)  
07f2 32 79 fb			ld (debug_mark+2),a  
07f5 18 03			jr .pastdmark  
07f7 ..			.dmark: db "SCA"  
07fa f1			.pastdmark: pop af  
07fb			endm  
# End of macro DMARK
07fb					CALLMONITOR 
07fb cd 00 14			call break_point_state  
07fe				endm  
# End of macro CALLMONITOR
07fe				endif 
07fe			 
07fe				; write file header page 
07fe			 
07fe 2a 60 f8			ld hl,(store_tmppageid) 
0801 11 62 f8			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCb" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 77 fb			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 78 fb			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 79 fb			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCb"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					;push af 
081d					;ld a, 'b' 
081d					;ld (debug_mark),a 
081d					;pop af 
081d					CALLMONITOR 
081d cd 00 14			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 71 03			call storage_write_block 
0823			 
0823 3a 5b f8			ld a, (store_tmpid) 
0826 6f				ld l, a 
0827 26 00			ld h,0 
0829				if DEBUG_STORESE 
0829					DMARK "SCz" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 77 fb			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 78 fb			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 79 fb			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCz"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd 00 14			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845 c9				ret 
0846				 
0846			 
0846			 
0846			; 
0846			; Read File 
0846			; 
0846			; h - file id to locate 
0846			; l - extent to locate 
0846			; de - pointer to string to read into 
0846			; 
0846			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0846			storage_read: 
0846 d5				push de 
0847			 
0847			; TODO BUG the above push is it popped before the RET Z? 
0847			 
0847			; TODO how to handle multiple part blocks 
0847			 
0847				; locate file extent to read 
0847			 
0847 5c				ld e, h 
0848 55				ld d, l 
0849 21 40 00			ld hl, STORE_BLOCK_PHY 
084c				if DEBUG_STORESE 
084c					DMARK "SRE" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 77 fb			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 78 fb			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 79 fb			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SRE"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd 00 14			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 22 06			call storage_findnextid 
086b			 
086b				if DEBUG_STORESE 
086b					DMARK "SRf" 
086b f5				push af  
086c 3a 80 08			ld a, (.dmark)  
086f 32 77 fb			ld (debug_mark),a  
0872 3a 81 08			ld a, (.dmark+1)  
0875 32 78 fb			ld (debug_mark+1),a  
0878 3a 82 08			ld a, (.dmark+2)  
087b 32 79 fb			ld (debug_mark+2),a  
087e 18 03			jr .pastdmark  
0880 ..			.dmark: db "SRf"  
0883 f1			.pastdmark: pop af  
0884			endm  
# End of macro DMARK
0884					CALLMONITOR 
0884 cd 00 14			call break_point_state  
0887				endm  
# End of macro CALLMONITOR
0887				endif 
0887 cd 3b 0c			call ishlzero 
088a			;	ld a, l 
088a			;	add h 
088a			;	cp 0 
088a c8				ret z			; block not found so EOF 
088b			 
088b				; hl contains page number to load 
088b d1				pop de   ; get storage 
088c d5				push de 
088d				if DEBUG_STORESE 
088d					DMARK "SRg" 
088d f5				push af  
088e 3a a2 08			ld a, (.dmark)  
0891 32 77 fb			ld (debug_mark),a  
0894 3a a3 08			ld a, (.dmark+1)  
0897 32 78 fb			ld (debug_mark+1),a  
089a 3a a4 08			ld a, (.dmark+2)  
089d 32 79 fb			ld (debug_mark+2),a  
08a0 18 03			jr .pastdmark  
08a2 ..			.dmark: db "SRg"  
08a5 f1			.pastdmark: pop af  
08a6			endm  
# End of macro DMARK
08a6					CALLMONITOR 
08a6 cd 00 14			call break_point_state  
08a9				endm  
# End of macro CALLMONITOR
08a9				endif 
08a9 cd 0c 03			call storage_read_block 
08ac			 
08ac			 
08ac			; TODO if block has no zeros then need to read next block  
08ac			 
08ac			 
08ac					 
08ac e1				pop hl 		 ; return start of data to show as not EOF 
08ad 23				inc hl   ; past file id 
08ae 23				inc hl   ; past ext 
08af				if DEBUG_STORESE 
08af					DMARK "SRe" 
08af f5				push af  
08b0 3a c4 08			ld a, (.dmark)  
08b3 32 77 fb			ld (debug_mark),a  
08b6 3a c5 08			ld a, (.dmark+1)  
08b9 32 78 fb			ld (debug_mark+1),a  
08bc 3a c6 08			ld a, (.dmark+2)  
08bf 32 79 fb			ld (debug_mark+2),a  
08c2 18 03			jr .pastdmark  
08c4 ..			.dmark: db "SRe"  
08c7 f1			.pastdmark: pop af  
08c8			endm  
# End of macro DMARK
08c8					CALLMONITOR 
08c8 cd 00 14			call break_point_state  
08cb				endm  
# End of macro CALLMONITOR
08cb				endif 
08cb c9					ret 
08cc			 
08cc			 
08cc			 
08cc			; 
08cc			; Append File 
08cc			; 
08cc			; hl - file id to locate 
08cc			; de - pointer to (multi block) string to write 
08cc			 
08cc			 
08cc			storage_append: 
08cc				; hl -  file id to append to 
08cc				; de - string to append 
08cc			 
08cc d5				push de 
08cd				 
08cd				if DEBUG_STORESE 
08cd					DMARK "AP1" 
08cd f5				push af  
08ce 3a e2 08			ld a, (.dmark)  
08d1 32 77 fb			ld (debug_mark),a  
08d4 3a e3 08			ld a, (.dmark+1)  
08d7 32 78 fb			ld (debug_mark+1),a  
08da 3a e4 08			ld a, (.dmark+2)  
08dd 32 79 fb			ld (debug_mark+2),a  
08e0 18 03			jr .pastdmark  
08e2 ..			.dmark: db "AP1"  
08e5 f1			.pastdmark: pop af  
08e6			endm  
# End of macro DMARK
08e6					CALLMONITOR 
08e6 cd 00 14			call break_point_state  
08e9				endm  
# End of macro CALLMONITOR
08e9				endif 
08e9			 
08e9 7d				ld a, l 
08ea 32 5b f8			ld (store_tmpid), a 
08ed			 
08ed				; get file header  
08ed			 
08ed 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ef 3a 5b f8			ld a, (store_tmpid) 
08f2 5f				ld e, a 
08f3			 
08f3 21 40 00				ld hl, STORE_BLOCK_PHY 
08f6 cd 22 06				call storage_findnextid 
08f9			 
08f9 22 60 f8			ld (store_tmppageid), hl 
08fc			 
08fc				; TODO handle file id not found 
08fc			 
08fc				if DEBUG_STORESE 
08fc					DMARK "AP2" 
08fc f5				push af  
08fd 3a 11 09			ld a, (.dmark)  
0900 32 77 fb			ld (debug_mark),a  
0903 3a 12 09			ld a, (.dmark+1)  
0906 32 78 fb			ld (debug_mark+1),a  
0909 3a 13 09			ld a, (.dmark+2)  
090c 32 79 fb			ld (debug_mark+2),a  
090f 18 03			jr .pastdmark  
0911 ..			.dmark: db "AP2"  
0914 f1			.pastdmark: pop af  
0915			endm  
# End of macro DMARK
0915					CALLMONITOR 
0915 cd 00 14			call break_point_state  
0918				endm  
# End of macro CALLMONITOR
0918				endif 
0918			 
0918				; update file extent count 
0918			 
0918 11 62 f8			ld de, store_page 
091b			 
091b cd 0c 03			call storage_read_block 
091e			 
091e				if DEBUG_STORESE 
091e					DMARK "AP3" 
091e f5				push af  
091f 3a 33 09			ld a, (.dmark)  
0922 32 77 fb			ld (debug_mark),a  
0925 3a 34 09			ld a, (.dmark+1)  
0928 32 78 fb			ld (debug_mark+1),a  
092b 3a 35 09			ld a, (.dmark+2)  
092e 32 79 fb			ld (debug_mark+2),a  
0931 18 03			jr .pastdmark  
0933 ..			.dmark: db "AP3"  
0936 f1			.pastdmark: pop af  
0937			endm  
# End of macro DMARK
0937					CALLMONITOR 
0937 cd 00 14			call break_point_state  
093a				endm  
# End of macro CALLMONITOR
093a				endif 
093a			;	ld (store_tmppageid), hl 
093a			 
093a 3a 64 f8			ld a, (store_page+2) 
093d 3c				inc a 
093e 32 64 f8			ld (store_page+2), a 
0941 32 5a f8			ld (store_tmpext), a 
0944				 
0944				if DEBUG_STORESE 
0944					DMARK "AP3" 
0944 f5				push af  
0945 3a 59 09			ld a, (.dmark)  
0948 32 77 fb			ld (debug_mark),a  
094b 3a 5a 09			ld a, (.dmark+1)  
094e 32 78 fb			ld (debug_mark+1),a  
0951 3a 5b 09			ld a, (.dmark+2)  
0954 32 79 fb			ld (debug_mark+2),a  
0957 18 03			jr .pastdmark  
0959 ..			.dmark: db "AP3"  
095c f1			.pastdmark: pop af  
095d			endm  
# End of macro DMARK
095d					CALLMONITOR 
095d cd 00 14			call break_point_state  
0960				endm  
# End of macro CALLMONITOR
0960				endif 
0960 2a 60 f8			ld hl, (store_tmppageid) 
0963 11 62 f8			ld de, store_page 
0966 cd 71 03			call storage_write_block 
0969			 
0969				; find free block 
0969			 
0969 11 00 00			ld de, 0			 ; file extent to locate 
096c			 
096c 21 40 00				ld hl, STORE_BLOCK_PHY 
096f cd 22 06				call storage_findnextid 
0972			 
0972					; TODO handle no space left 
0972					 
0972 22 60 f8				ld (store_tmppageid), hl 
0975			 
0975				if DEBUG_STORESE 
0975					DMARK "AP4" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 77 fb			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 78 fb			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 79 fb			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP4"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 00 14			call break_point_state  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991					; init the buffer with zeros so we can id if the buffer is full or not 
0991			 
0991 e5					push hl 
0992 c5					push bc 
0993			 
0993 21 62 f8				ld hl, store_page 
0996 06 40				ld b, STORE_BLOCK_PHY 
0998 3e 00				ld a, 0 
099a 77			.zeroblock:	ld (hl), a 
099b 23					inc hl 
099c 10 fc				djnz .zeroblock 
099e			 
099e c1					pop bc 
099f e1					pop hl 
09a0			 
09a0					; construct block 
09a0			 
09a0 3a 5b f8				ld a, (store_tmpid) 
09a3 32 62 f8				ld (store_page), a   ; file id 
09a6 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09a9 32 63 f8				ld (store_page+1), a 
09ac			 
09ac e1					pop hl    ; get string to write 
09ad 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09af 11 64 f8				ld de, store_page+2 
09b2			 
09b2				if DEBUG_STORESE 
09b2					DMARK "AP5" 
09b2 f5				push af  
09b3 3a c7 09			ld a, (.dmark)  
09b6 32 77 fb			ld (debug_mark),a  
09b9 3a c8 09			ld a, (.dmark+1)  
09bc 32 78 fb			ld (debug_mark+1),a  
09bf 3a c9 09			ld a, (.dmark+2)  
09c2 32 79 fb			ld (debug_mark+2),a  
09c5 18 03			jr .pastdmark  
09c7 ..			.dmark: db "AP5"  
09ca f1			.pastdmark: pop af  
09cb			endm  
# End of macro DMARK
09cb					CALLMONITOR 
09cb cd 00 14			call break_point_state  
09ce				endm  
# End of macro CALLMONITOR
09ce				endif 
09ce			 
09ce			 
09ce			 
09ce					; fill buffer with data until end of string or full block 
09ce			 
09ce 7e			.appd:		ld a, (hl) 
09cf 12					ld (de), a 
09d0 fe 00				cp 0 
09d2 28 04				jr z, .appdone 
09d4 23					inc hl 
09d5 13					inc de 
09d6 10 f6				djnz .appd 
09d8			 
09d8 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d9 f5					push af   		; save last byte dumped 
09da			 
09da			 
09da 2a 60 f8			ld hl, (store_tmppageid) 
09dd 11 62 f8			ld de, store_page 
09e0				if DEBUG_STORESE 
09e0					DMARK "AP6" 
09e0 f5				push af  
09e1 3a f5 09			ld a, (.dmark)  
09e4 32 77 fb			ld (debug_mark),a  
09e7 3a f6 09			ld a, (.dmark+1)  
09ea 32 78 fb			ld (debug_mark+1),a  
09ed 3a f7 09			ld a, (.dmark+2)  
09f0 32 79 fb			ld (debug_mark+2),a  
09f3 18 03			jr .pastdmark  
09f5 ..			.dmark: db "AP6"  
09f8 f1			.pastdmark: pop af  
09f9			endm  
# End of macro DMARK
09f9					CALLMONITOR 
09f9 cd 00 14			call break_point_state  
09fc				endm  
# End of macro CALLMONITOR
09fc				endif 
09fc cd 71 03				call storage_write_block 
09ff			 
09ff			 
09ff				; was that a full block of data written? 
09ff				; any more to write out? 
09ff			 
09ff				; if yes then set vars and jump to start of function again 
09ff			 
09ff f1					pop af 
0a00 d1					pop de 
0a01			 
0a01 fe 00				cp 0		 ; no, string was fully written 
0a03 c8					ret z 
0a04			 
0a04					; setup vars for next cycle 
0a04			 
0a04 3a 5b f8				ld a, (store_tmpid) 
0a07 6f					ld l, a 
0a08 26 00				ld h, 0 
0a0a			 
0a0a c3 cc 08			 	jp storage_append	 ; yes, need to write out some more 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			if DEBUG_STORECF 
0a0d			storageput:	 
0a0d					ret 
0a0d			storageread: 
0a0d					ld hl, store_page 
0a0d					ld b, 200 
0a0d					ld a,0 
0a0d			.src:		ld (hl),a 
0a0d					inc hl 
0a0d					djnz .src 
0a0d					 
0a0d			 
0a0d					ld de, 0 
0a0d					ld bc, 1 
0a0d					ld hl, store_page 
0a0d					call cfRead 
0a0d			 
0a0d				call cfGetError 
0a0d				ld hl,scratch 
0a0d				call hexout 
0a0d				ld hl, scratch+2 
0a0d				ld a, 0 
0a0d				ld (hl),a 
0a0d				ld de, scratch 
0a0d				ld a,display_row_1 
0a0d				call str_at_display 
0a0d				call update_display 
0a0d			 
0a0d					ld hl, store_page 
0a0d					ld (os_cur_ptr),hl 
0a0d			 
0a0d					ret 
0a0d			endif 
0a0d			 
0a0d			 
0a0d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0d			 
0a0d			storage_clear_page: 
0a0d e5				push hl 
0a0e d5				push de 
0a0f c5				push bc 
0a10 21 62 f8			ld hl, store_page 
0a13 3e 00			ld a, 0 
0a15 77				ld (hl), a 
0a16			 
0a16 11 63 f8			ld de, store_page+1 
0a19 01 40 00			ld bc, STORE_BLOCK_PHY 
0a1c			 
0a1c ed b0			ldir 
0a1e				 
0a1e c1				pop bc 
0a1f d1				pop de 
0a20 e1				pop hl 
0a21 c9				ret 
0a22			 
0a22			; eof 
# End of file firmware_storage.asm
0a22			  
0a22			; support routines for above hardware abstraction layer  
0a22			  
0a22			include "firmware_general.asm"        ; general support functions  
0a22			 
0a22			 
0a22			 
0a22			; Delay loops 
0a22			 
0a22			 
0a22			 
0a22			aDelayInMS: 
0a22 c5				push bc 
0a23 47				ld b,a 
0a24			msdelay: 
0a24 c5				push bc 
0a25				 
0a25			 
0a25 01 41 00			ld bc,041h 
0a28 cd 40 0a			call delayloop 
0a2b c1				pop bc 
0a2c 05				dec b 
0a2d 20 f5			jr nz,msdelay 
0a2f			 
0a2f			;if CPU_CLOCK_8MHZ 
0a2f			;msdelay8: 
0a2f			;	push bc 
0a2f			;	 
0a2f			; 
0a2f			;	ld bc,041h 
0a2f			;	call delayloop 
0a2f			;	pop bc 
0a2f			;	dec b 
0a2f			;	jr nz,msdelay8 
0a2f			;endif 
0a2f			 
0a2f			 
0a2f c1				pop bc 
0a30 c9				ret 
0a31			 
0a31			 
0a31			delay250ms: 
0a31				;push de 
0a31 01 00 40			ld bc, 04000h 
0a34 c3 40 0a			jp delayloop 
0a37			delay500ms: 
0a37				;push de 
0a37 01 00 80			ld bc, 08000h 
0a3a c3 40 0a			jp delayloop 
0a3d			delay1s: 
0a3d				;push bc 
0a3d			   ; Clobbers A, d and e 
0a3d 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a40			delayloop: 
0a40 c5			    push bc 
0a41			 
0a41			if BASE_CPM 
0a41				ld bc, CPM_DELAY_TUNE 
0a41			.cpmloop: 
0a41				push bc 
0a41			 
0a41			endif 
0a41			 
0a41			 
0a41			 
0a41			delayloopi: 
0a41			;	push bc 
0a41			;.dl: 
0a41 cb 47		    bit     0,a    	; 8 
0a43 cb 47		    bit     0,a    	; 8 
0a45 cb 47		    bit     0,a    	; 8 
0a47 e6 ff		    and     255  	; 7 
0a49 0b			    dec     bc      	; 6 
0a4a 79			    ld      a,c     	; 4 
0a4b b0			    or      b     	; 4 
0a4c c2 41 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4f				;pop de 
0a4f			;pop bc 
0a4f			 
0a4f			if BASE_CPM 
0a4f				pop bc 
0a4f				 
0a4f			    dec     bc      	; 6 
0a4f			    ld      a,c     	; 4 
0a4f			    or      b     	; 4 
0a4f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4f				 
0a4f			 
0a4f			endif 
0a4f			;if CPU_CLOCK_8MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f			 
0a4f			;if CPU_CLOCK_10MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f c1			    pop bc 
0a50			 
0a50 c9				ret 
0a51			 
0a51			 
0a51			 
0a51			; eof 
# End of file firmware_general.asm
0a51			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a51			; display routines that use the physical hardware abstraction layer 
0a51			 
0a51			 
0a51			; TODO windowing? 
0a51			 
0a51			; TODO scroll line up 
0a51			 
0a51			scroll_up: 
0a51			 
0a51 e5				push hl 
0a52 d5				push de 
0a53 c5				push bc 
0a54			 
0a54				; get frame buffer  
0a54			 
0a54 2a d8 f8			ld hl, (display_fb_active) 
0a57 e5				push hl    ; future de destination 
0a58			 
0a58 11 28 00			ld  de, display_cols 
0a5b 19				add hl, de 
0a5c			 
0a5c d1				pop de 
0a5d			 
0a5d				;ex de, hl 
0a5d 01 9f 00			ld bc, display_fb_len -1  
0a60			;if DEBUG_FORTH_WORDS 
0a60			;	DMARK "SCL" 
0a60			;	CALLMONITOR 
0a60			;endif	 
0a60 ed b0			ldir 
0a62			 
0a62				; wipe bottom row 
0a62			 
0a62			 
0a62 2a d8 f8			ld hl, (display_fb_active) 
0a65 11 a0 00			ld de, display_cols*display_rows 
0a68 19				add hl, de 
0a69 06 28			ld b, display_cols 
0a6b 3e 20			ld a, ' ' 
0a6d			.scwipe: 
0a6d 77				ld (hl), a 
0a6e 2b				dec hl 
0a6f 10 fc			djnz .scwipe 
0a71			 
0a71				;pop hl 
0a71			 
0a71 c1				pop bc 
0a72 d1				pop de 
0a73 e1				pop hl 
0a74			 
0a74 c9				ret 
0a75			 
0a75			 
0a75			scroll_upo: 
0a75 11 00 00			ld de, display_row_1 
0a78 21 28 00		 	ld hl, display_row_2 
0a7b 01 28 00			ld bc, display_cols 
0a7e ed b0			ldir 
0a80 11 28 00			ld de, display_row_2 
0a83 21 50 00		 	ld hl, display_row_3 
0a86 01 28 00			ld bc, display_cols 
0a89 ed b0			ldir 
0a8b 11 50 00			ld de, display_row_3 
0a8e 21 78 00		 	ld hl, display_row_4 
0a91 01 28 00			ld bc, display_cols 
0a94 ed b0			ldir 
0a96			 
0a96			; TODO clear row 4 
0a96			 
0a96 c9				ret 
0a97				 
0a97			scroll_down: 
0a97 11 78 00			ld de, display_row_4 
0a9a 21 50 00		 	ld hl, display_row_3 
0a9d 01 28 00			ld bc, display_cols 
0aa0 ed b0			ldir 
0aa2 11 50 00			ld de, display_row_3 
0aa5 21 28 00		 	ld hl, display_row_2 
0aa8 01 28 00			ld bc, display_cols 
0aab ed b0			ldir 
0aad 11 28 00			ld de, display_row_2 
0ab0 21 00 00		 	ld hl, display_row_1 
0ab3 01 28 00			ld bc, display_cols 
0ab6 ed b0			ldir 
0ab8			; TODO clear row 1 
0ab8 c9				ret 
0ab9			 
0ab9			 
0ab9			 
0ab9			 
0ab9			 
0ab9			; clear active frame buffer 
0ab9			 
0ab9			clear_display: 
0ab9 3e 20			ld a, ' ' 
0abb c3 be 0a			jp fill_display 
0abe			 
0abe			; fill active frame buffer with a char in A 
0abe			 
0abe			fill_display: 
0abe 06 a0			ld b,display_fb_len 
0ac0 2a d8 f8			ld hl, (display_fb_active) 
0ac3 77			.fd1:	ld (hl),a 
0ac4 23				inc hl 
0ac5 10 fc			djnz .fd1 
0ac7 23				inc hl 
0ac8 3e 00			ld a,0 
0aca 77				ld (hl),a 
0acb			 
0acb			 
0acb c9				ret 
0acc			; Write string (DE) at pos (A) to active frame buffer 
0acc			 
0acc 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0acf 06 00					ld b,0 
0ad1 4f					ld c,a 
0ad2 09					add hl,bc 
0ad3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ad4 b7			            OR   A              ;Null terminator? 
0ad5 c8			            RET  Z              ;Yes, so finished 
0ad6 77					ld (hl),a 
0ad7 23				inc hl 
0ad8 13			            INC  DE             ;Point to next character 
0ad9 18 f8		            JR   .sad1     ;Repeat 
0adb c9					ret 
0adc			 
0adc			; using current frame buffer write to physical display 
0adc			 
0adc			update_display: 
0adc e5				push hl 
0add 2a d8 f8			ld hl, (display_fb_active) 
0ae0 cd ae 61			call write_display 
0ae3 e1				pop hl 
0ae4 c9				ret 
0ae5			 
0ae5			; TODO scrolling 
0ae5			 
0ae5			 
0ae5			; move cursor right one char 
0ae5			cursor_right: 
0ae5			 
0ae5				; TODO shift right 
0ae5				; TODO if beyond max col 
0ae5				; TODO       cursor_next_line 
0ae5			 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			cursor_next_line: 
0ae6				; TODO first char 
0ae6				; TODO line down 
0ae6				; TODO if past last row 
0ae6				; TODO    scroll up 
0ae6			 
0ae6 c9				ret 
0ae7			 
0ae7			cursor_left: 
0ae7				; TODO shift left 
0ae7				; TODO if beyond left  
0ae7				; TODO     cursor prev line 
0ae7				 
0ae7 c9				ret 
0ae8			 
0ae8			cursor_prev_line: 
0ae8				; TODO last char 
0ae8				; TODO line up 
0ae8				; TODO if past first row 
0ae8				; TODO   scroll down 
0ae8			 
0ae8 c9				ret 
0ae9			 
0ae9			 
0ae9			cout: 
0ae9				; A - char 
0ae9 c9				ret 
0aea			 
0aea			; eof 
0aea			 
# End of file firmware_display.asm
0aea			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0aea			; random number generators 
0aea			 
0aea			 
0aea			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0aea			 
0aea			 
0aea			;-----> Generate a random number 
0aea			; output a=answer 0<=a<=255 
0aea			; all registers are preserved except: af 
0aea			random: 
0aea e5			        push    hl 
0aeb d5			        push    de 
0aec 2a ba f8		        ld      hl,(randData) 
0aef ed 5f		        ld      a,r 
0af1 57			        ld      d,a 
0af2 5e			        ld      e,(hl) 
0af3 19			        add     hl,de 
0af4 85			        add     a,l 
0af5 ac			        xor     h 
0af6 22 ba f8		        ld      (randData),hl 
0af9 d1			        pop     de 
0afa e1			        pop     hl 
0afb c9			        ret 
0afc			 
0afc			 
0afc			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0afc			 
0afc			 
0afc			 
0afc			;------LFSR------ 
0afc			;James Montelongo 
0afc			;optimized by Spencer Putt 
0afc			;out: 
0afc			; a = 8 bit random number 
0afc			RandLFSR: 
0afc 21 c0 f8		        ld hl,LFSRSeed+4 
0aff 5e			        ld e,(hl) 
0b00 23			        inc hl 
0b01 56			        ld d,(hl) 
0b02 23			        inc hl 
0b03 4e			        ld c,(hl) 
0b04 23			        inc hl 
0b05 7e			        ld a,(hl) 
0b06 47			        ld b,a 
0b07 cb 13		        rl e  
0b09 cb 12			rl d 
0b0b cb 11		        rl c  
0b0d 17				rla 
0b0e cb 13		        rl e  
0b10 cb 12			rl d 
0b12 cb 11		        rl c  
0b14 17				rla 
0b15 cb 13		        rl e  
0b17 cb 12			rl d 
0b19 cb 11		        rl c  
0b1b 17				rla 
0b1c 67			        ld h,a 
0b1d cb 13		        rl e  
0b1f cb 12			rl d 
0b21 cb 11		        rl c  
0b23 17				rla 
0b24 a8			        xor b 
0b25 cb 13		        rl e  
0b27 cb 12			rl d 
0b29 ac			        xor h 
0b2a a9			        xor c 
0b2b aa			        xor d 
0b2c 21 c2 f8		        ld hl,LFSRSeed+6 
0b2f 11 c3 f8		        ld de,LFSRSeed+7 
0b32 01 07 00		        ld bc,7 
0b35 ed b8		        lddr 
0b37 12			        ld (de),a 
0b38 c9			        ret 
0b39			 
0b39			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0b39			 
0b39			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0b39			 
0b39			 
0b39			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0b39			 
0b39			prng16: 
0b39			;Inputs: 
0b39			;   (seed1) contains a 16-bit seed value 
0b39			;   (seed2) contains a NON-ZERO 16-bit seed value 
0b39			;Outputs: 
0b39			;   HL is the result 
0b39			;   BC is the result of the LCG, so not that great of quality 
0b39			;   DE is preserved 
0b39			;Destroys: 
0b39			;   AF 
0b39			;cycle: 4,294,901,760 (almost 4.3 billion) 
0b39			;160cc 
0b39			;26 bytes 
0b39 2a b4 f8		    ld hl,(seed1) 
0b3c 44			    ld b,h 
0b3d 4d			    ld c,l 
0b3e 29			    add hl,hl 
0b3f 29			    add hl,hl 
0b40 2c			    inc l 
0b41 09			    add hl,bc 
0b42 22 b4 f8		    ld (seed1),hl 
0b45 2a b2 f8		    ld hl,(seed2) 
0b48 29			    add hl,hl 
0b49 9f			    sbc a,a 
0b4a e6 2d		    and %00101101 
0b4c ad			    xor l 
0b4d 6f			    ld l,a 
0b4e 22 b2 f8		    ld (seed2),hl 
0b51 09			    add hl,bc 
0b52 c9			    ret 
0b53			 
0b53			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b53			 
0b53			rand32: 
0b53			;Inputs: 
0b53			;   (seed1_0) holds the lower 16 bits of the first seed 
0b53			;   (seed1_1) holds the upper 16 bits of the first seed 
0b53			;   (seed2_0) holds the lower 16 bits of the second seed 
0b53			;   (seed2_1) holds the upper 16 bits of the second seed 
0b53			;   **NOTE: seed2 must be non-zero 
0b53			;Outputs: 
0b53			;   HL is the result 
0b53			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b53			;Destroys: 
0b53			;   AF 
0b53			;Tested and passes all CAcert tests 
0b53			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b53			;it has a period of 18,446,744,069,414,584,320 
0b53			;roughly 18.4 quintillion. 
0b53			;LFSR taps: 0,2,6,7  = 11000101 
0b53			;291cc 
0b53			;seed1_0=$+1 
0b53			;    ld hl,12345 
0b53			;seed1_1=$+1 
0b53			;    ld de,6789 
0b53			;    ld b,h 
0b53			;    ld c,l 
0b53			;    add hl,hl \ rl e \ rl d 
0b53			;    add hl,hl \ rl e \ rl d 
0b53			;    inc l 
0b53			;    add hl,bc 
0b53			;    ld (seed1_0),hl 
0b53			;    ld hl,(seed1_1) 
0b53			;    adc hl,de 
0b53			;    ld (seed1_1),hl 
0b53			;    ex de,hl 
0b53			;seed2_0=$+1 
0b53			;    ld hl,9876 
0b53			;seed2_1=$+1 
0b53			;    ld bc,54321 
0b53			;    add hl,hl \ rl c \ rl b 
0b53			;    ld (seed2_1),bc 
0b53			;    sbc a,a 
0b53			;    and %11000101 
0b53			;    xor l 
0b53			;    ld l,a 
0b53			;    ld (seed2_0),hl 
0b53			;    ex de,hl 
0b53			;    add hl,bc 
0b53			;    ret 
0b53			; 
0b53			 
0b53			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b53			; 20 bytes, 86 cycles (excluding ret) 
0b53			 
0b53			; returns   hl = pseudorandom number 
0b53			; corrupts   a 
0b53			 
0b53			; generates 16-bit pseudorandom numbers with a period of 65535 
0b53			; using the xorshift method: 
0b53			 
0b53			; hl ^= hl << 7 
0b53			; hl ^= hl >> 9 
0b53			; hl ^= hl << 8 
0b53			 
0b53			; some alternative shift triplets which also perform well are: 
0b53			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b53			 
0b53			;  org 32768 
0b53			 
0b53			xrnd: 
0b53 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0b56 3e 00		  ld a,0 
0b58 bd			  cp l 
0b59 20 02		  jr nz, .xrnd1 
0b5b 2e 01		  ld l, 1 
0b5d			.xrnd1: 
0b5d			 
0b5d 7c			  ld a,h 
0b5e 1f			  rra 
0b5f 7d			  ld a,l 
0b60 1f			  rra 
0b61 ac			  xor h 
0b62 67			  ld h,a 
0b63 7d			  ld a,l 
0b64 1f			  rra 
0b65 7c			  ld a,h 
0b66 1f			  rra 
0b67 ad			  xor l 
0b68 6f			  ld l,a 
0b69 ac			  xor h 
0b6a 67			  ld h,a 
0b6b			 
0b6b 22 b8 f8		  ld (xrandc),hl 
0b6e			 
0b6e c9			  ret 
0b6f			;  
0b6f			 
0b6f			 
0b6f			;;;; int maths 
0b6f			 
0b6f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b6f			; Divide 16-bit values (with 16-bit result) 
0b6f			; In: Divide BC by divider DE 
0b6f			; Out: BC = result, HL = rest 
0b6f			; 
0b6f			Div16: 
0b6f 21 00 00		    ld hl,0 
0b72 78			    ld a,b 
0b73 06 08		    ld b,8 
0b75			Div16_Loop1: 
0b75 17			    rla 
0b76 ed 6a		    adc hl,hl 
0b78 ed 52		    sbc hl,de 
0b7a 30 01		    jr nc,Div16_NoAdd1 
0b7c 19			    add hl,de 
0b7d			Div16_NoAdd1: 
0b7d 10 f6		    djnz Div16_Loop1 
0b7f 17			    rla 
0b80 2f			    cpl 
0b81 47			    ld b,a 
0b82 79			    ld a,c 
0b83 48			    ld c,b 
0b84 06 08		    ld b,8 
0b86			Div16_Loop2: 
0b86 17			    rla 
0b87 ed 6a		    adc hl,hl 
0b89 ed 52		    sbc hl,de 
0b8b 30 01		    jr nc,Div16_NoAdd2 
0b8d 19			    add hl,de 
0b8e			Div16_NoAdd2: 
0b8e 10 f6		    djnz Div16_Loop2 
0b90 17			    rla 
0b91 2f			    cpl 
0b92 41			    ld b,c 
0b93 4f			    ld c,a 
0b94 c9			ret 
0b95			 
0b95			 
0b95			;http://z80-heaven.wikidot.com/math 
0b95			; 
0b95			;Inputs: 
0b95			;     DE and A are factors 
0b95			;Outputs: 
0b95			;     A is not changed 
0b95			;     B is 0 
0b95			;     C is not changed 
0b95			;     DE is not changed 
0b95			;     HL is the product 
0b95			;Time: 
0b95			;     342+6x 
0b95			; 
0b95			Mult16: 
0b95			 
0b95 06 08		     ld b,8          ;7           7 
0b97 21 00 00		     ld hl,0         ;10         10 
0b9a 29			       add hl,hl     ;11*8       88 
0b9b 07			       rlca          ;4*8        32 
0b9c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b9e 19			         add hl,de   ;--         -- 
0b9f 10 f9		       djnz $-5      ;13*7+8     99 
0ba1 c9			ret 
0ba2			 
0ba2			; 
0ba2			; Square root of 16-bit value 
0ba2			; In:  HL = value 
0ba2			; Out:  D = result (rounded down) 
0ba2			; 
0ba2			;Sqr16: 
0ba2			;    ld de,#0040 
0ba2			;    ld a,l 
0ba2			;    ld l,h 
0ba2			;    ld h,d 
0ba2			;    or a 
0ba2			;    ld b,8 
0ba2			;Sqr16_Loop: 
0ba2			;    sbc hl,de 
0ba2			;    jr nc,Sqr16_Skip 
0ba2			;    add hl,de 
0ba2			;Sqr16_Skip: 
0ba2			;    ccf 
0ba2			;    rl d 
0ba2			;    add a,a 
0ba2			;    adc hl,hl 
0ba2			;    add a,a 
0ba2			;    adc hl,hl 
0ba2			;    djnz Sqr16_Loop 
0ba2			;    ret 
0ba2			; 
0ba2			; 
0ba2			; Divide 8-bit values 
0ba2			; In: Divide E by divider C 
0ba2			; Out: A = result, B = rest 
0ba2			; 
0ba2			Div8: 
0ba2 af			    xor a 
0ba3 06 08		    ld b,8 
0ba5			Div8_Loop: 
0ba5 cb 13		    rl e 
0ba7 17			    rla 
0ba8 91			    sub c 
0ba9 30 01		    jr nc,Div8_NoAdd 
0bab 81			    add a,c 
0bac			Div8_NoAdd: 
0bac 10 f7		    djnz Div8_Loop 
0bae 47			    ld b,a 
0baf 7b			    ld a,e 
0bb0 17			    rla 
0bb1 2f			    cpl 
0bb2 c9			    ret 
0bb3			 
0bb3			; 
0bb3			; Multiply 8-bit value with a 16-bit value (unrolled) 
0bb3			; In: Multiply A with DE 
0bb3			; Out: HL = result 
0bb3			; 
0bb3			Mult12U: 
0bb3 2e 00		    ld l,0 
0bb5 87			    add a,a 
0bb6 30 01		    jr nc,Mult12U_NoAdd0 
0bb8 19			    add hl,de 
0bb9			Mult12U_NoAdd0: 
0bb9 29			    add hl,hl 
0bba 87			    add a,a 
0bbb 30 01		    jr nc,Mult12U_NoAdd1 
0bbd 19			    add hl,de 
0bbe			Mult12U_NoAdd1: 
0bbe 29			    add hl,hl 
0bbf 87			    add a,a 
0bc0 30 01		    jr nc,Mult12U_NoAdd2 
0bc2 19			    add hl,de 
0bc3			Mult12U_NoAdd2: 
0bc3 29			    add hl,hl 
0bc4 87			    add a,a 
0bc5 30 01		    jr nc,Mult12U_NoAdd3 
0bc7 19			    add hl,de 
0bc8			Mult12U_NoAdd3: 
0bc8 29			    add hl,hl 
0bc9 87			    add a,a 
0bca 30 01		    jr nc,Mult12U_NoAdd4 
0bcc 19			    add hl,de 
0bcd			Mult12U_NoAdd4: 
0bcd 29			    add hl,hl 
0bce 87			    add a,a 
0bcf 30 01		    jr nc,Mult12U_NoAdd5 
0bd1 19			    add hl,de 
0bd2			Mult12U_NoAdd5: 
0bd2 29			    add hl,hl 
0bd3 87			    add a,a 
0bd4 30 01		    jr nc,Mult12U_NoAdd6 
0bd6 19			    add hl,de 
0bd7			Mult12U_NoAdd6: 
0bd7 29			    add hl,hl 
0bd8 87			    add a,a 
0bd9 d0			    ret nc 
0bda 19			    add hl,de 
0bdb c9			    ret 
0bdc			 
0bdc			; 
0bdc			; Multiply 8-bit value with a 16-bit value (right rotating) 
0bdc			; In: Multiply A with DE 
0bdc			;      Put lowest value in A for most efficient calculation 
0bdc			; Out: HL = result 
0bdc			; 
0bdc			Mult12R: 
0bdc 21 00 00		    ld hl,0 
0bdf			Mult12R_Loop: 
0bdf cb 3f		    srl a 
0be1 30 01		    jr nc,Mult12R_NoAdd 
0be3 19			    add hl,de 
0be4			Mult12R_NoAdd: 
0be4 cb 23		    sla e 
0be6 cb 12		    rl d 
0be8 b7			    or a 
0be9 c2 df 0b		    jp nz,Mult12R_Loop 
0bec c9			    ret 
0bed			 
0bed			; 
0bed			; Multiply 16-bit values (with 32-bit result) 
0bed			; In: Multiply BC with DE 
0bed			; Out: BCHL = result 
0bed			; 
0bed			Mult32: 
0bed 79			    ld a,c 
0bee 48			    ld c,b 
0bef 21 00 00		    ld hl,0 
0bf2 06 10		    ld b,16 
0bf4			Mult32_Loop: 
0bf4 29			    add hl,hl 
0bf5 17			    rla 
0bf6 cb 11		    rl c 
0bf8 30 07		    jr nc,Mult32_NoAdd 
0bfa 19			    add hl,de 
0bfb ce 00		    adc a,0 
0bfd d2 01 0c		    jp nc,Mult32_NoAdd 
0c00 0c			    inc c 
0c01			Mult32_NoAdd: 
0c01 10 f1		    djnz Mult32_Loop 
0c03 41			    ld b,c 
0c04 4f			    ld c,a 
0c05 c9			    ret 
0c06			 
0c06			 
0c06			 
0c06			; 
0c06			; Multiply 8-bit values 
0c06			; In:  Multiply H with E 
0c06			; Out: HL = result 
0c06			; 
0c06			Mult8: 
0c06 16 00		    ld d,0 
0c08 6a			    ld l,d 
0c09 06 08		    ld b,8 
0c0b			Mult8_Loop: 
0c0b 29			    add hl,hl 
0c0c 30 01		    jr nc,Mult8_NoAdd 
0c0e 19			    add hl,de 
0c0f			Mult8_NoAdd: 
0c0f 10 fa		    djnz Mult8_Loop 
0c11 c9			    ret 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			;;http://z80-heaven.wikidot.com/math 
0c12			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c12			; 
0c12			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c12			;     ld a,16        ;7 
0c12			;     ld hl,0        ;10 
0c12			;     jp $+5         ;10 
0c12			;.DivLoop: 
0c12			;       add hl,bc    ;-- 
0c12			;       dec a        ;64 
0c12			;       jr z,.DivLoopEnd        ;86 
0c12			; 
0c12			;       sla e        ;128 
0c12			;       rl d         ;128 
0c12			;       adc hl,hl    ;240 
0c12			;       sbc hl,bc    ;240 
0c12			;       jr nc,.DivLoop ;23|21 
0c12			;       inc e        ;-- 
0c12			;       jp .DivLoop+1 
0c12			; 
0c12			;.DivLoopEnd: 
0c12			 
0c12			;HL_Div_C: 
0c12			;Inputs: 
0c12			;     HL is the numerator 
0c12			;     C is the denominator 
0c12			;Outputs: 
0c12			;     A is the remainder 
0c12			;     B is 0 
0c12			;     C is not changed 
0c12			;     DE is not changed 
0c12			;     HL is the quotient 
0c12			; 
0c12			;       ld b,16 
0c12			;       xor a 
0c12			;         add hl,hl 
0c12			;         rla 
0c12			;         cp c 
0c12			;         jr c,$+4 
0c12			;           inc l 
0c12			;           sub c 
0c12			;         djnz $-7 
0c12			 
0c12			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c12			 
0c12			addatohl: 
0c12 85			    add   a, l    ; A = A+L 
0c13 6f			    ld    l, a    ; L = A+L 
0c14 8c			    adc   a, h    ; A = A+L+H+carry 
0c15 95			    sub   l       ; A = H+carry 
0c16 67			    ld    h, a    ; H = H+carry 
0c17 c9			ret 
0c18			 
0c18			addatode: 
0c18 83			    add   a, e    ; A = A+L 
0c19 5f			    ld    e, a    ; L = A+L 
0c1a 8a			    adc   a, d    ; A = A+L+H+carry 
0c1b 93			    sub   e       ; A = H+carry 
0c1c 57			    ld    d, a    ; H = H+carry 
0c1d c9			ret 
0c1e			 
0c1e			 
0c1e			addatobc: 
0c1e 81			    add   a, c    ; A = A+L 
0c1f 4f			    ld    c, a    ; L = A+L 
0c20 88			    adc   a, b    ; A = A+L+H+carry 
0c21 91			    sub   c       ; A = H+carry 
0c22 47			    ld    b, a    ; H = H+carry 
0c23 c9			ret 
0c24			 
0c24			subafromhl: 
0c24			   ; If A=0 do nothing 
0c24			    ; Otherwise flip A's sign. Since 
0c24			    ; the upper byte becomes -1, also 
0c24			    ; substract 1 from H. 
0c24 ed 44		    neg 
0c26 ca 2f 0c		    jp    z, Skip 
0c29 25			    dec   h 
0c2a			     
0c2a			    ; Now add the low byte as usual 
0c2a			    ; Two's complement takes care of 
0c2a			    ; ensuring the result is correct 
0c2a 85			    add   a, l 
0c2b 6f			    ld    l, a 
0c2c 8c			    adc   a, h 
0c2d 95			    sub   l 
0c2e 67			    ld    h, a 
0c2f			Skip: 
0c2f c9				ret 
0c30			 
0c30			 
0c30			; compare hl and de 
0c30			; returns:  
0c30			; if hl = de, z=1, s=0, c0=0 
0c30			; if hl > de, z=0, s=0, c=0 
0c30			; if hl < de, z=0, s=1, c=1 
0c30			cmp16:	 
0c30 b7				or a 
0c31 ed 52			sbc hl,de 
0c33 e0				ret po 
0c34 7c				ld a,h 
0c35 1f				rra 
0c36 ee 40			xor 01000000B 
0c38 37				scf 
0c39 8f				adc a,a 
0c3a c9				ret 
0c3b			 
0c3b			 
0c3b			; test if hl contains zero   - A is destroyed 
0c3b			 
0c3b			ishlzero:    
0c3b b7				or a     ; reset flags 
0c3c 7c				ld a, h 
0c3d b5				or l        	 
0c3e			 
0c3e c9				ret 
0c3f			 
0c3f			 
0c3f			 
0c3f			 
0c3f			if FORTH_ENABLE_FLOATMATH 
0c3f			;include "float/bbcmath.z80" 
0c3f			include "float/lpfpcalc.asm" 
0c3f			endif 
0c3f			 
0c3f			 
0c3f			; eof 
0c3f			 
# End of file firmware_maths.asm
0c3f			include "firmware_strings.asm"   ; string handling  
0c3f			 
0c3f			 
0c3f			; TODO string len 
0c3f			; input text string, end on cr with zero term 
0c3f			; a offset into frame buffer to start prompt 
0c3f			; d is max length 
0c3f			; e is display size TODO 
0c3f			; c is current cursor position 
0c3f			; hl is ptr to where string will be stored 
0c3f			 
0c3f			 
0c3f			; TODO check limit of buffer for new inserts 
0c3f			; TODO check insert does not push beyond buffer 
0c3f			; TODO scroll in a limited display area 
0c3f			; TODO scroll whole screen on page wrap 
0c3f			 
0c3f			 
0c3f			; TODO handle KEY_PREVWORD 
0c3f			; TODO handle KEY_NEXTWORD 
0c3f			; TODO handle KEY_HOME 
0c3f			; TODO handle KEY_END 
0c3f			; TODO use LCD cursor? 
0c3f			 
0c3f 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0c42 81					add c 
0c43 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0c46 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0c49 79					ld a, c 
0c4a cd 12 0c				call addatohl 
0c4d 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c50 7a					ld a,d 
0c51 32 72 fb			        ld (input_size), a       ; save length of input area 
0c54 79					ld a, c 
0c55 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0c58 7b					ld a,e 
0c59 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c5c					 
0c5c					 
0c5c			 
0c5c			;		ld a,(input_ptr) 
0c5c			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c5c			 
0c5c			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c5c					; init cursor shape if not set by the cin routines 
0c5c 21 d0 f8				ld hl, cursor_shape 
0c5f 3e ff				ld a, 255 
0c61 77					ld (hl), a 
0c62 23					inc hl 
0c63 3e 00				ld a, 0 
0c65 77					ld (hl), a 
0c66			 
0c66 3e 0f				ld a, CUR_BLINK_RATE 
0c68 32 6c fb				ld (input_cur_flash), a 
0c6b 3e 01				ld a, 1 
0c6d 32 6b fb				ld (input_cur_onoff),a 
0c70			 
0c70			;	if DEBUG_INPUT 
0c70			;		push af 
0c70			;		ld a, 'I' 
0c70			;		ld (debug_mark),a 
0c70			;		pop af 
0c70			;		CALLMONITOR 
0c70			;	endif 
0c70			.is1:		; main entry loop 
0c70			 
0c70			 
0c70			 
0c70					; pause 1ms 
0c70			 
0c70 3e 01				ld a, 1 
0c72 cd 22 0a				call aDelayInMS 
0c75			 
0c75					; dec flash counter 
0c75 3a 6c fb				ld a, (input_cur_flash) 
0c78 3d					dec a 
0c79 32 6c fb				ld (input_cur_flash), a 
0c7c fe 00				cp 0 
0c7e 20 0d				jr nz, .nochgstate 
0c80			 
0c80			 
0c80					; change state 
0c80 3a 6b fb				ld a,(input_cur_onoff) 
0c83 ed 44				neg 
0c85 32 6b fb				ld (input_cur_onoff),a 
0c88			 
0c88			 
0c88					; reset on change of state 
0c88 3e 0f				ld a, CUR_BLINK_RATE 
0c8a 32 6c fb				ld (input_cur_flash), a 
0c8d			 
0c8d			.nochgstate: 
0c8d					 
0c8d					 
0c8d			 
0c8d					; display cursor  
0c8d			 
0c8d			;		ld hl, (input_start) 
0c8d			;		ld a, (input_cursor) 
0c8d			;		call addatohl 
0c8d			 
0c8d					; get char under cursor and replace with cursor 
0c8d 2a 75 fb		ld hl, (input_ptr) 
0c90			;		ld a, (hl) 
0c90			;		ld (input_under_cursor),a 
0c90			;		ld a, '_' 
0c90			;		ld (hl), a 
0c90			 
0c90					; display string 
0c90			 
0c90 ed 5b 73 fb			ld de, (input_start) 
0c94 3a 70 fb				ld a, (input_at_pos) 
0c97 cd cc 0a				call str_at_display 
0c9a			;	        call update_display 
0c9a			 
0c9a					; find place to put the cursor 
0c9a			;		add h 
0c9a			;		ld l, display_row_1 
0c9a			;		sub l 
0c9a			; (input_at_pos) 
0c9a					;ld c, a 
0c9a			;		ld a, (input_cursor) 
0c9a			;		ld l, (input_at_pos) 
0c9a			;		;ld b, h 
0c9a			;		add l 
0c9a			;		ld (input_at_cursor),a 
0c9a					;ld l,h 
0c9a			 
0c9a			;		ld h, 0 
0c9a			;		ld l,(input_at_pos) 
0c9a			;		ld a, (input_cursor) 
0c9a			;		call addatohl 
0c9a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c9a			;		call subafromhl 
0c9a			;		ld a,l 
0c9a			;		ld (input_at_cursor), a 
0c9a			 
0c9a				if DEBUG_INPUT 
0c9a					ld a, (hardware_diag) 
0c9a					cp 0 
0c9a					jr z, .skip_input_diag 
0c9a			 
0c9a					ld a,(input_at_pos) 
0c9a					ld hl, LFSRSeed 
0c9a					call hexout 
0c9a					ld a, (input_cursor) 
0c9a					ld hl, LFSRSeed+2 
0c9a					call hexout 
0c9a					ld a,(input_at_cursor) 
0c9a					ld hl, LFSRSeed+4 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_cur_onoff) 
0c9a					ld hl, LFSRSeed+6 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_cur_flash) 
0c9a					ld hl, LFSRSeed+8 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_len) 
0c9a					ld hl, LFSRSeed+10 
0c9a					call hexout 
0c9a					ld hl, LFSRSeed+12 
0c9a					ld a, 0 
0c9a					ld (hl),a 
0c9a					ld a, display_row_4 
0c9a					ld de, LFSRSeed 
0c9a					call str_at_display 
0c9a					.skip_input_diag: 
0c9a				endif 
0c9a			 
0c9a					; decide on if we are showing the cursor this time round 
0c9a			 
0c9a 3a 6b fb				ld a, (input_cur_onoff) 
0c9d fe ff				cp 255 
0c9f 28 13				jr z, .skipcur 
0ca1			 
0ca1			 
0ca1 3a 6e fb				ld a,(input_at_cursor) 
0ca4 11 d0 f8				ld de, cursor_shape 
0ca7 cd cc 0a				call str_at_display 
0caa			 
0caa					; save length of current input string 
0caa 2a 73 fb				ld hl, (input_start) 
0cad cd 70 10				call strlenz 
0cb0 7d					ld a,l 
0cb1 32 66 fb				ld (input_len),a 
0cb4			 
0cb4			.skipcur: 
0cb4			 
0cb4 cd dc 0a			        call update_display 
0cb7					 
0cb7			 
0cb7			 
0cb7					; wait 
0cb7				 
0cb7					; TODO loop without wait to flash the cursor and char under cursor	 
0cb7 cd f9 64				call cin    ; _wait 
0cba			 
0cba fe 00				cp 0 
0cbc ca 70 0c				jp z, .is1 
0cbf			 
0cbf					; get ptr to char to input into 
0cbf			 
0cbf 4f					ld c,a 
0cc0 2a 73 fb				ld hl, (input_start) 
0cc3 3a 61 fb				ld a, (input_cursor) 
0cc6 cd 12 0c				call addatohl 
0cc9 22 75 fb				ld (input_ptr), hl 
0ccc 79					ld a,c 
0ccd			 
0ccd					; replace char under cursor 
0ccd			 
0ccd			;		ld hl, (input_ptr) 
0ccd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ccd			;		ld (hl), a 
0ccd			 
0ccd			;	if DEBUG_INPUT 
0ccd			;		push af 
0ccd			;		ld a, 'i' 
0ccd			;		ld (debug_mark),a 
0ccd			;		pop af 
0ccd			;		CALLMONITOR 
0ccd			;	endif 
0ccd fe 0e				cp KEY_HOME 
0ccf 20 0e				jr nz, .iske 
0cd1			 
0cd1 3a 70 fb				ld a, (input_at_pos) 
0cd4 32 6e fb				ld (input_at_cursor),a 
0cd7 3e 00				ld a, 0 
0cd9 32 61 fb				ld (input_cursor), a 
0cdc c3 70 0c				jp .is1 
0cdf					 
0cdf fe 0f		.iske:		cp KEY_END 
0ce1 20 03				jr nz, .isknw 
0ce3 c3 70 0c				jp .is1 
0ce6			 
0ce6 fe 06		.isknw:		cp KEY_NEXTWORD 
0ce8 20 1b				jr nz, .iskpw 
0cea			 
0cea 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0ced 7e					ld a,(hl)	 
0cee fe 00				cp 0 
0cf0 ca 70 0c				jp z, .is1    ; end of string 
0cf3 fe 20				cp ' ' 
0cf5 ca 70 0c				jp z, .is1    ; end of word 
0cf8 23					inc hl 
0cf9 22 75 fb				ld (input_ptr), hl 
0cfc 3a 6e fb				ld a, (input_at_cursor) 
0cff 3c					inc a 
0d00 32 6e fb				ld (input_at_cursor), a 
0d03 18 e5				jr .isknwm 
0d05			 
0d05 fe 07		.iskpw:		cp KEY_PREVWORD 
0d07 20 1b				jr nz, .iskl 
0d09			.iskpwm:	 
0d09 2a 75 fb				ld hl, (input_ptr) 
0d0c 7e					ld a,(hl)	 
0d0d fe 00				cp 0  
0d0f ca 70 0c				jp z, .is1    ; end of string 
0d12 fe 20				cp ' ' 
0d14 ca 70 0c				jp z, .is1    ; end of word 
0d17 2b					dec hl 
0d18 22 75 fb				ld (input_ptr), hl 
0d1b 3a 6e fb				ld a, (input_at_cursor) 
0d1e 3d					dec a 
0d1f 32 6e fb				ld (input_at_cursor), a 
0d22 18 e5				jr .iskpwm 
0d24			 
0d24			 
0d24 fe 0b		.iskl:		cp KEY_LEFT 
0d26 20 27				jr nz, .isk1 
0d28			 
0d28 3a 61 fb				ld a, (input_cursor) 
0d2b			 
0d2b fe 00				cp 0 
0d2d ca 70 0c				jp z, .is1 		; at start of line to ignore  
0d30			 
0d30 3d					dec  a 		; TODO check underflow 
0d31 32 61 fb				ld (input_cursor), a 
0d34			 
0d34 2a 75 fb				ld hl, (input_ptr) 
0d37 2b					dec hl 
0d38 22 75 fb				ld (input_ptr), hl 
0d3b					 
0d3b 3a 6e fb				ld a, (input_at_cursor) 
0d3e 3d					dec a 
0d3f 32 6e fb				ld (input_at_cursor), a 
0d42			 
0d42 3e 01				ld a, 1		; show cursor moving 
0d44 32 6b fb				ld (input_cur_onoff),a 
0d47 3e 0f				ld a, CUR_BLINK_RATE 
0d49 32 6c fb				ld (input_cur_flash), a 
0d4c			 
0d4c c3 70 0c				jp .is1 
0d4f			 
0d4f fe 0c		.isk1:		cp KEY_RIGHT 
0d51 20 2a				jr nz, .isk2 
0d53			 
0d53 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d56 5f					ld e,a 
0d57 3a 61 fb				ld a, (input_cursor) 
0d5a bb					cp e 
0d5b ca 70 0c				jp z, .is1		; at the end of string so dont go right 
0d5e			 
0d5e 3c					inc  a 		; TODO check overflow 
0d5f 32 61 fb				ld (input_cursor), a 
0d62			 
0d62 3a 6e fb				ld a, (input_at_cursor) 
0d65 3c					inc a 
0d66 32 6e fb				ld (input_at_cursor), a 
0d69			 
0d69 2a 75 fb				ld hl, (input_ptr) 
0d6c 23					inc hl 
0d6d 22 75 fb				ld (input_ptr), hl 
0d70			 
0d70 3e 01				ld a, 1		; show cursor moving 
0d72 32 6b fb				ld (input_cur_onoff),a 
0d75 3e 0f				ld a, CUR_BLINK_RATE 
0d77 32 6c fb				ld (input_cur_flash), a 
0d7a			 
0d7a c3 70 0c				jp .is1 
0d7d			 
0d7d fe 05		.isk2:		cp KEY_UP 
0d7f			 
0d7f 20 26				jr nz, .isk3 
0d81			 
0d81					; swap last command with the current on 
0d81			 
0d81					; move cursor to start of string 
0d81 2a 73 fb				ld hl, (input_start) 
0d84 22 75 fb				ld (input_ptr), hl 
0d87			 
0d87 3a 70 fb				ld a, (input_at_pos) 
0d8a 32 6e fb				ld (input_at_cursor), a 
0d8d			 
0d8d 3e 00				ld a, 0 
0d8f 32 61 fb				ld (input_cursor), a 
0d92					 
0d92					; swap input and last command buffers 
0d92			 
0d92 21 59 f1				ld hl, os_cli_cmd 
0d95 11 58 f2				ld de, os_last_cmd 
0d98 06 ff				ld b, 255 
0d9a 7e			.swap1:		ld a, (hl) 
0d9b 4f					ld c,a 
0d9c 1a					ld a, (de) 
0d9d 77					ld (hl), a 
0d9e 79					ld a,c 
0d9f 12					ld (de),a 
0da0 23					inc hl 
0da1 13					inc de 
0da2 10 f6				djnz .swap1 
0da4			 
0da4			 
0da4			 
0da4			 
0da4			 
0da4 c3 70 0c				jp .is1 
0da7			 
0da7 fe 08		.isk3:		cp KEY_BS 
0da9 20 3c				jr nz, .isk4 
0dab			 
0dab 3a 61 fb				ld a, (input_cursor) 
0dae			 
0dae fe 00				cp 0 
0db0 ca 70 0c				jp z, .is1 		; at start of line to ignore  
0db3			 
0db3 3d					dec  a 		; TODO check underflow 
0db4 32 61 fb				ld (input_cursor), a 
0db7			 
0db7					; hl is source 
0db7					; de needs to be source - 1 
0db7			 
0db7			;		ld a, 0 
0db7			;		dec hl 
0db7			;		ld (hl), a 
0db7			 
0db7 2a 75 fb				ld hl, (input_ptr) 
0dba 2b					dec hl 
0dbb 22 75 fb				ld (input_ptr), hl 
0dbe			 
0dbe					; shift all data 
0dbe			 
0dbe e5					push hl 
0dbf 23					inc hl 
0dc0 d1					pop de 
0dc1 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0dc4 4f					ld c,a 
0dc5 06 00				ld b,0 
0dc7 ed b0				ldir  
0dc9			 
0dc9			 
0dc9			 
0dc9			 
0dc9 3a 6e fb				ld a, (input_at_cursor) 
0dcc 3d					dec a 
0dcd 32 6e fb				ld (input_at_cursor), a 
0dd0			 
0dd0			 
0dd0 3e 01				ld a, 1		; show cursor moving 
0dd2 32 6b fb				ld (input_cur_onoff),a 
0dd5 3e 0f				ld a, CUR_BLINK_RATE 
0dd7 32 6c fb				ld (input_cur_flash), a 
0dda			 
0dda					; remove char 
0dda 3a 6e fb				ld a, (input_at_cursor) 
0ddd 3c					inc a 
0dde 11 68 0e				ld de,.iblank 
0de1 cd cc 0a				call str_at_display 
0de4			 
0de4 c3 70 0c				jp .is1 
0de7			 
0de7 fe 0d		.isk4:		cp KEY_CR 
0de9 28 6c				jr z, .endinput 
0deb			 
0deb					; else add the key press to the end 
0deb			 
0deb 4f					ld c, a			; save key pressed 
0dec			 
0dec 7e					ld a,(hl)		; get what is currently under char 
0ded			 
0ded fe 00				cp 0			; we are at the end of the string 
0def 20 2f				jr nz, .onchar 
0df1					 
0df1					; add a char to the end of the string 
0df1				 
0df1 71					ld (hl),c 
0df2 23					inc hl 
0df3			;		ld a,' ' 
0df3			;		ld (hl),a 
0df3			;		inc hl 
0df3 3e 00				ld a,0 
0df5 77					ld (hl),a 
0df6 2b					dec hl 
0df7			 
0df7 3a 61 fb				ld a, (input_cursor) 
0dfa 3c					inc a				; TODO check max string length and scroll  
0dfb 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0dfe							 
0dfe 3a 6e fb				ld a, (input_at_cursor) 
0e01 3c					inc a 
0e02 32 6e fb				ld (input_at_cursor), a 
0e05			 
0e05 2a 75 fb				ld hl, (input_ptr) 
0e08 23					inc hl 
0e09 22 75 fb				ld (input_ptr), hl 
0e0c			 
0e0c 2a 75 fb				ld hl, (input_ptr) 
0e0f 23					inc hl 
0e10 22 75 fb				ld (input_ptr), hl 
0e13			;	if DEBUG_INPUT 
0e13			;		push af 
0e13			;		ld a, '+' 
0e13			;		ld (debug_mark),a 
0e13			;		pop af 
0e13			;		CALLMONITOR 
0e13			;	endif 
0e13 3e 01				ld a, 1		; show cursor moving 
0e15 32 6b fb				ld (input_cur_onoff),a 
0e18 3e 0f				ld a, CUR_BLINK_RATE 
0e1a 32 6c fb				ld (input_cur_flash), a 
0e1d c3 70 0c				jp .is1 
0e20					 
0e20			 
0e20			 
0e20					; if on a char then insert 
0e20			.onchar: 
0e20			 
0e20					; TODO over flow check: make sure insert does not blow out buffer 
0e20			 
0e20					; need to do some maths to use lddr 
0e20			 
0e20 e5					push hl   ; save char pos 
0e21 c5					push bc 
0e22			 
0e22 2a 73 fb				ld hl, (input_start) 
0e25 3a 66 fb				ld a, (input_len) 
0e28 cd 12 0c				call addatohl  		; end of string 
0e2b 23					inc hl 
0e2c 23					inc hl		; past zero term 
0e2d e5					push hl 
0e2e 23					inc hl 
0e2f e5					push hl  
0e30			 
0e30								; start and end of lddr set, now how much to move? 
0e30			 
0e30							 
0e30 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0e33 47					ld b,a 
0e34 3a 66 fb				ld a,(input_len) 
0e37 5f					ld e,a 
0e38 90					sub b 
0e39 3c					inc a		;?? 
0e3a 3c					inc a		;?? 
0e3b 3c					inc a		;?? 
0e3c			 
0e3c 06 00				ld b,0 
0e3e 4f					ld c,a 
0e3f			 
0e3f				if DEBUG_INPUT 
0e3f					push af 
0e3f					ld a, 'i' 
0e3f					ld (debug_mark),a 
0e3f					pop af 
0e3f			;		CALLMONITOR 
0e3f				endif 
0e3f d1					pop de 
0e40 e1					pop hl 
0e41				if DEBUG_INPUT 
0e41					push af 
0e41					ld a, 'I' 
0e41					ld (debug_mark),a 
0e41					pop af 
0e41			;		CALLMONITOR 
0e41				endif 
0e41 ed b8				lddr 
0e43				 
0e43			 
0e43			 
0e43					; TODO have a key for insert/overwrite mode???? 
0e43 c1					pop bc 
0e44 e1					pop hl 
0e45 71					ld (hl), c		; otherwise overwrite current char 
0e46					 
0e46			 
0e46			 
0e46			 
0e46 3a 61 fb				ld a, (input_cursor) 
0e49 3c					inc  a 		; TODO check overflow 
0e4a 32 61 fb				ld (input_cursor), a 
0e4d			 
0e4d 3a 6e fb				ld a, (input_at_cursor) 
0e50 3c					inc a 
0e51 32 6e fb				ld (input_at_cursor), a 
0e54			 
0e54 c3 70 0c				jp .is1 
0e57			 
0e57			.endinput:	; TODO look for end of string 
0e57			 
0e57					; add trailing space for end of token 
0e57			 
0e57 2a 73 fb				ld hl, (input_start) 
0e5a 3a 66 fb				ld a,(input_len) 
0e5d cd 12 0c				call addatohl 
0e60 3e 20				ld a, ' ' 
0e62 77					ld (hl),a 
0e63					; TODO eof of parse marker 
0e63			 
0e63 23					inc hl 
0e64 3e 00				ld a, 0 
0e66 77					ld (hl),a 
0e67			 
0e67			 
0e67 c9					ret 
0e68			 
0e68 .. 00		.iblank: db " ",0 
0e6a			 
0e6a			 
0e6a 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0e6d 22 73 fb				ld (input_start), hl 
0e70 3e 01				ld a,1			; add cursor 
0e72 77					ld (hl),a 
0e73 23					inc hl 
0e74 3e 00				ld a,0 
0e76 77					ld (hl),a 
0e77 22 75 fb				ld (input_ptr), hl 
0e7a 7a					ld a,d 
0e7b 32 72 fb				ld (input_size), a 
0e7e 3e 00				ld a,0 
0e80 32 61 fb				ld (input_cursor),a 
0e83			.instr1:	 
0e83			 
0e83					; TODO do block cursor 
0e83					; TODO switch cursor depending on the modifer key 
0e83			 
0e83					; update cursor shape change on key hold 
0e83			 
0e83 2a 75 fb				ld hl, (input_ptr) 
0e86 2b					dec hl 
0e87 3a d0 f8				ld a,(cursor_shape) 
0e8a 77					ld (hl), a 
0e8b			 
0e8b					; display entered text 
0e8b 3a 70 fb				ld a,(input_at_pos) 
0e8e cd bd 62		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e91 ed 5b 73 fb	            	LD   de, (input_start) 
0e95 cd df 62		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e98			 
0e98 cd f9 64				call cin 
0e9b fe 00				cp 0 
0e9d 28 e4				jr z, .instr1 
0e9f			 
0e9f					; proecess keyboard controls first 
0e9f			 
0e9f 2a 75 fb				ld hl,(input_ptr) 
0ea2			 
0ea2 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0ea4 28 5a				jr z, .instrcr 
0ea6			 
0ea6 fe 08				cp KEY_BS 	; back space 
0ea8 20 0f				jr nz, .instr2 
0eaa					; process back space 
0eaa			 
0eaa					; TODO stop back space if at start of string 
0eaa 2b					dec hl 
0eab 2b					dec hl ; to over write cursor 
0eac 3a d0 f8				ld a,(cursor_shape) 
0eaf					;ld a,0 
0eaf 77					ld (hl),a 
0eb0 23					inc hl 
0eb1 3e 20				ld a," " 
0eb3 77					ld (hl),a 
0eb4 22 75 fb				ld (input_ptr),hl 
0eb7					 
0eb7			 
0eb7 18 ca				jr .instr1 
0eb9			 
0eb9 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0ebb 20 06				jr nz, .instr3 
0ebd 2b					dec hl 
0ebe 22 75 fb				ld (input_ptr),hl 
0ec1 18 c0				jr .instr1 
0ec3				 
0ec3 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0ec5 20 06				jr nz, .instr4 
0ec7 23					inc hl 
0ec8 22 75 fb				ld (input_ptr),hl 
0ecb 18 b6				jr .instr1 
0ecd			 
0ecd fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0ecf 20 06				jr nz, .instr5 
0ed1 2b					dec hl 
0ed2 22 75 fb				ld (input_ptr),hl 
0ed5 18 ac				jr .instr1 
0ed7			 
0ed7 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0ed9 20 06				jr nz, .instr6 
0edb 2b					dec hl 
0edc 22 75 fb				ld (input_ptr),hl 
0edf 18 a2				jr .instr1 
0ee1 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0ee3 20 0b				jr nz, .instrnew 
0ee5			 
0ee5 21 32 ee			ld hl, scratch 
0ee8 11 58 f2			ld de, os_last_cmd 
0eeb cd 09 0f			call strcpy 
0eee 18 93				jr .instr1 
0ef0			 
0ef0			 
0ef0			.instrnew:	; no special key pressed to see if we have room to store it 
0ef0			 
0ef0					; TODO do string size test 
0ef0			 
0ef0 2b					dec hl ; to over write cursor 
0ef1 77					ld (hl),a 
0ef2 23					inc hl 
0ef3 3a d0 f8				ld a,(cursor_shape) 
0ef6 77					ld (hl),a 
0ef7 23					inc hl 
0ef8 3e 00				ld a,0 
0efa 77					ld (hl),a 
0efb			 
0efb 22 75 fb				ld (input_ptr),hl 
0efe					 
0efe 18 83				jr .instr1 
0f00 2b			.instrcr:	dec hl		; remove cursor 
0f01 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f03 77					ld (hl),a 
0f04 23					inc hl 
0f05 3e 00				ld a,0 
0f07 77					ld (hl),a 
0f08			 
0f08			 
0f08					; if at end of line scroll up    
0f08					; TODO detecting only end of line 4 for scroll up  
0f08			 
0f08					;ld   
0f08			 
0f08 c9					ret 
0f09			 
0f09			 
0f09			; strcpy hl = dest, de source 
0f09			 
0f09 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f0a b7			            OR   A              ;Null terminator? 
0f0b c8			            RET  Z              ;Yes, so finished 
0f0c 1a					ld a,(de) 
0f0d 77					ld (hl),a 
0f0e 13			            INC  DE             ;Point to next character 
0f0f 23					inc hl 
0f10 18 f7		            JR   strcpy       ;Repeat 
0f12 c9					ret 
0f13			 
0f13			 
0f13			; TODO string_at  
0f13			; pass string which starts with lcd offset address and then null term string 
0f13			 
0f13			; TODO string to dec 
0f13			; TODO string to hex 
0f13			; TODO byte to string hex 
0f13			; TODO byte to string dec 
0f13			 
0f13			 
0f13			 
0f13			; from z80uartmonitor 
0f13			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f13			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0f13			; pass hl for where to put the text 
0f13			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f13 c5			hexout:	PUSH BC 
0f14 f5					PUSH AF 
0f15 47					LD B, A 
0f16					; Upper nybble 
0f16 cb 3f				SRL A 
0f18 cb 3f				SRL A 
0f1a cb 3f				SRL A 
0f1c cb 3f				SRL A 
0f1e cd 2e 0f				CALL tohex 
0f21 77					ld (hl),a 
0f22 23					inc hl	 
0f23					 
0f23					; Lower nybble 
0f23 78					LD A, B 
0f24 e6 0f				AND 0FH 
0f26 cd 2e 0f				CALL tohex 
0f29 77					ld (hl),a 
0f2a 23					inc hl	 
0f2b					 
0f2b f1					POP AF 
0f2c c1					POP BC 
0f2d c9					RET 
0f2e					 
0f2e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2e			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0f2e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2e			tohex: 
0f2e e5					PUSH HL 
0f2f d5					PUSH DE 
0f30 16 00				LD D, 0 
0f32 5f					LD E, A 
0f33 21 3b 0f				LD HL, .DATA 
0f36 19					ADD HL, DE 
0f37 7e					LD A, (HL) 
0f38 d1					POP DE 
0f39 e1					POP HL 
0f3a c9					RET 
0f3b			 
0f3b			.DATA: 
0f3b 30					DEFB	30h	; 0 
0f3c 31					DEFB	31h	; 1 
0f3d 32					DEFB	32h	; 2 
0f3e 33					DEFB	33h	; 3 
0f3f 34					DEFB	34h	; 4 
0f40 35					DEFB	35h	; 5 
0f41 36					DEFB	36h	; 6 
0f42 37					DEFB	37h	; 7 
0f43 38					DEFB	38h	; 8 
0f44 39					DEFB	39h	; 9 
0f45 41					DEFB	41h	; A 
0f46 42					DEFB	42h	; B 
0f47 43					DEFB	43h	; C 
0f48 44					DEFB	44h	; D 
0f49 45					DEFB	45h	; E 
0f4a 46					DEFB	46h	; F 
0f4b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f4b			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0f4b			;;    subtract $30, if result > 9 then subtract $7 more 
0f4b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f4b			atohex: 
0f4b d6 30				SUB $30 
0f4d fe 0a				CP 10 
0f4f f8					RET M		; If result negative it was 0-9 so we're done 
0f50 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f52 c9					RET		 
0f53			 
0f53			 
0f53			 
0f53			 
0f53			; Get 2 ASCII characters as hex byte from pointer in hl 
0f53			 
0f53			BYTERD: 
0f53 16 00			LD	D,00h		;Set up 
0f55 cd 5d 0f			CALL	HEXCON		;Get byte and convert to hex 
0f58 87				ADD	A,A		;First nibble so 
0f59 87				ADD	A,A		;multiply by 16 
0f5a 87				ADD	A,A		; 
0f5b 87				ADD	A,A		; 
0f5c 57				LD	D,A		;Save hi nibble in D 
0f5d			HEXCON: 
0f5d 7e				ld a, (hl)		;Get next chr 
0f5e 23				inc hl 
0f5f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f61 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f63 38 02			JR	C,NALPHA	;If so miss next bit 
0f65 d6 07			SUB	007h		;Else convert alpha 
0f67			NALPHA: 
0f67 b2				OR	D		;Add hi nibble back 
0f68 c9				RET			; 
0f69			 
0f69			 
0f69			; 
0f69			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f69			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f69			; characters (0-9a-f) are accepted. 
0f69			; 
0f69			;get_word        push    af 
0f69			;                call    get_byte        ; Get the upper byte 
0f69			;                ld      h, a 
0f69			;                call    get_byte        ; Get the lower byte 
0f69			;                ld      l, a 
0f69			;                pop     af 
0f69			;                ret 
0f69			; 
0f69			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f69			; the routine get_nibble is used only valid characters are accepted - the  
0f69			; input routine only accepts characters 0-9a-f. 
0f69			; 
0f69 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f6a 7e					ld a,(hl) 
0f6b 23					inc hl 
0f6c cd 91 0f		                call    nibble2val      ; Get upper nibble 
0f6f cb 07		                rlc     a 
0f71 cb 07		                rlc     a 
0f73 cb 07		                rlc     a 
0f75 cb 07		                rlc     a 
0f77 47			                ld      b, a            ; Save upper four bits 
0f78 7e					ld a,(hl) 
0f79 cd 91 0f		                call    nibble2val      ; Get lower nibble 
0f7c b0			                or      b               ; Combine both nibbles 
0f7d c1			                pop     bc              ; Restore B (and C) 
0f7e c9			                ret 
0f7f			; 
0f7f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f7f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f7f			; to the serial line interface. The lower 4 bits of A contain the value of  
0f7f			; that particular digit. 
0f7f			; 
0f7f			;get_nibble      ld a,(hl)           ; Read a character 
0f7f			;                call    to_upper        ; Convert to upper case 
0f7f			;                call    is_hex          ; Was it a hex digit? 
0f7f			;                jr      nc, get_nibble  ; No, get another character 
0f7f			 ;               call    nibble2val      ; Convert nibble to value 
0f7f			 ;               call    print_nibble 
0f7f			 ;               ret 
0f7f			; 
0f7f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f7f			; A valid hexadecimal digit is denoted by a set C flag. 
0f7f			; 
0f7f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f7f			;                ret     nc              ; Yes 
0f7f			;                cp      '0'             ; Less than '0'? 
0f7f			;                jr      nc, is_hex_1    ; No, continue 
0f7f			;                ccf                     ; Complement carry (i.e. clear it) 
0f7f			;                ret 
0f7f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f7f			;                ret     c               ; Yes 
0f7f			;                cp      'A'             ; Less than 'A'? 
0f7f			;                jr      nc, is_hex_2    ; No, continue 
0f7f			;                ccf                     ; Yes - clear carry and return 
0f7f			;                ret 
0f7f			;is_hex_2        scf                     ; Set carry 
0f7f			;                ret 
0f7f			; 
0f7f			; Convert a single character contained in A to upper case: 
0f7f			; 
0f7f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f81 d8			                ret     c 
0f82 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f84 d0			                ret     nc              ; Nothing to do, either 
0f85 e6 5f		                and     $5f             ; Convert to upper case 
0f87 c9			                ret 
0f88			 
0f88			 
0f88			to_lower: 
0f88			 
0f88			   ; if char is in [A-Z] make it lower case 
0f88			 
0f88			   ; enter : a = char 
0f88			   ; exit  : a = lower case char 
0f88			   ; uses  : af 
0f88			 
0f88 fe 41		   cp 'A' 
0f8a d8			   ret c 
0f8b			    
0f8b fe 5b		   cp 'Z'+1 
0f8d d0			   ret nc 
0f8e			    
0f8e f6 20		   or $20 
0f90 c9			   ret 
0f91			 
0f91			; 
0f91			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f91			; corresponding value in A. 
0f91			; 
0f91 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f93 38 02		                jr      c, nibble2val_1 ; Yes 
0f95 d6 07		                sub     7               ; Adjust for A-F 
0f97 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f99 e6 0f		                and     $f              ; Only return lower 4 bits 
0f9b c9			                ret 
0f9c			; 
0f9c			; Print_nibble prints a single hex nibble which is contained in the lower  
0f9c			; four bits of A: 
0f9c			; 
0f9c			;print_nibble    push    af              ; We won't destroy the contents of A 
0f9c			;                and     $f              ; Just in case... 
0f9c			;                add     a, '0'             ; If we have a digit we are done here. 
0f9c			;                cp      '9' + 1         ; Is the result > 9? 
0f9c			;                jr      c, print_nibble_1 
0f9c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f9c			;print_nibble_1  call    putc            ; Print the nibble and 
0f9c			;                pop     af              ; restore the original value of A 
0f9c			;                ret 
0f9c			;; 
0f9c			;; Send a CR/LF pair: 
0f9c			; 
0f9c			;crlf            push    af 
0f9c			;                ld      a, cr 
0f9c			;                call    putc 
0f9c			;                ld      a, lf 
0f9c			;                call    putc 
0f9c			;                pop     af 
0f9c			;                ret 
0f9c			; 
0f9c			; Print_word prints the four hex digits of a word to the serial line. The  
0f9c			; word is expected to be in HL. 
0f9c			; 
0f9c			;print_word      push    hl 
0f9c			;                push    af 
0f9c			;                ld      a, h 
0f9c			;                call    print_byte 
0f9c			;                ld      a, l 
0f9c			;                call    print_byte 
0f9c			;                pop     af 
0f9c			;                pop     hl 
0f9c			;                ret 
0f9c			; 
0f9c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f9c			; The byte to be printed is expected to be in A. 
0f9c			; 
0f9c			;print_byte      push    af              ; Save the contents of the registers 
0f9c			;                push    bc 
0f9c			;                ld      b, a 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                call    print_nibble    ; Print high nibble 
0f9c			;                ld      a, b 
0f9c			;                call    print_nibble    ; Print low nibble 
0f9c			;                pop     bc              ; Restore original register contents 
0f9c			;                pop     af 
0f9c			;                ret 
0f9c			 
0f9c			 
0f9c			 
0f9c			 
0f9c			 
0f9c			fourehexhl:  
0f9c 7e				ld a,(hl) 
0f9d cd 4b 0f			call atohex 
0fa0 cb 3f				SRL A 
0fa2 cb 3f				SRL A 
0fa4 cb 3f				SRL A 
0fa6 cb 3f				SRL A 
0fa8 47				ld b, a 
0fa9 23				inc hl 
0faa 7e				ld a,(hl) 
0fab 23				inc hl 
0fac cd 4b 0f			call atohex 
0faf 80				add b 
0fb0 57				ld d,a 
0fb1 7e				ld a,(hl) 
0fb2 cd 4b 0f			call atohex 
0fb5 cb 3f				SRL A 
0fb7 cb 3f				SRL A 
0fb9 cb 3f				SRL A 
0fbb cb 3f				SRL A 
0fbd 47				ld b, a 
0fbe 23				inc hl 
0fbf 7e				ld a,(hl) 
0fc0 23				inc hl 
0fc1 cd 4b 0f			call atohex 
0fc4 80				add b 
0fc5 5f				ld e, a 
0fc6 d5				push de 
0fc7 e1				pop hl 
0fc8 c9				ret 
0fc9			 
0fc9			; pass hl. returns z set if the byte at hl is a digit 
0fc9			;isdigithl:  
0fc9			;	push bc 
0fc9			;	ld a,(hl) 
0fc9			;	cp ':' 
0fc9			;	jr nc, .isdf 		; > 
0fc9			;	cp '0' 
0fc9			;	jr c, .isdf		; < 
0fc9			; 
0fc9			;	; TODO find a better way to set z 
0fc9			; 
0fc9			;	ld b,a 
0fc9			;	cp b 
0fc9			;	pop bc 
0fc9			;	ret 
0fc9			; 
0fc9			;.isdf:	; not digit so clear z 
0fc9			; 
0fc9			;	; TODO find a better way to unset z 
0fc9			; 
0fc9			;	ld b,a 
0fc9			;	inc b 
0fc9			;	cp b 
0fc9			; 
0fc9			;	pop bc 
0fc9			;	ret 
0fc9				 
0fc9				 
0fc9			 
0fc9			 
0fc9			; pass hl as the four byte address to load 
0fc9			 
0fc9			get_word_hl:  
0fc9 e5				push hl 
0fca cd 69 0f			call get_byte 
0fcd				 
0fcd 47				ld b, a 
0fce			 
0fce e1				pop hl 
0fcf 23				inc hl 
0fd0 23				inc hl 
0fd1			 
0fd1			; TODO not able to handle a-f  
0fd1 7e				ld a,(hl) 
0fd2			;	;cp ':' 
0fd2			;	cp 'g' 
0fd2			;	jr nc, .single_byte_hl 		; > 
0fd2			;	cp 'G' 
0fd2			;	jr nc, .single_byte_hl 		; > 
0fd2			;	cp '0' 
0fd2			;	jr c, .single_byte_hl		; < 
0fd2			 
0fd2				;call isdigithl 
0fd2 fe 00			cp 0 
0fd4 28 06			jr z, .single_byte_hl 
0fd6			 
0fd6			.getwhln:   ; hex word so get next byte 
0fd6			 
0fd6 cd 69 0f			call get_byte 
0fd9 6f				ld l, a 
0fda 60				ld h,b 
0fdb c9				ret 
0fdc 68			.single_byte_hl:   ld l,b 
0fdd 26 00				ld h,0 
0fdf c9					ret 
0fe0			 
0fe0			 
0fe0			 
0fe0			 
0fe0 21 a4 16			ld hl,asc+1 
0fe3			;	ld a, (hl) 
0fe3			;	call nibble2val 
0fe3 cd 69 0f			call get_byte 
0fe6			 
0fe6			;	call fourehexhl 
0fe6 32 66 ee			ld (scratch+52),a 
0fe9				 
0fe9 21 64 ee			ld hl,scratch+50 
0fec 22 55 f1			ld (os_cur_ptr),hl 
0fef			 
0fef c9				ret 
0ff0			 
0ff0			 
0ff0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ff0			 
0ff0			; Decimal Unsigned Version 
0ff0			 
0ff0			;Number in a to decimal ASCII 
0ff0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ff0			;Example: display a=56 as "056" 
0ff0			;input: a = number 
0ff0			;Output: a=0,value of a in the screen 
0ff0			;destroys af,bc (don't know about hl and de) 
0ff0			DispAToASCII: 
0ff0 0e 9c			ld	c,-100 
0ff2 cd fc 0f			call	.Na1 
0ff5 0e f6			ld	c,-10 
0ff7 cd fc 0f			call	.Na1 
0ffa 0e ff			ld	c,-1 
0ffc 06 2f		.Na1:	ld	b,'0'-1 
0ffe 04			.Na2:	inc	b 
0fff 81				add	a,c 
1000 38 fc			jr	c,.Na2 
1002 91				sub	c		;works as add 100/10/1 
1003 f5				push af		;safer than ld c,a 
1004 78				ld	a,b		;char is in b 
1005			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1005 f1				pop af		;safer than ld a,c 
1006 c9				ret 
1007			 
1007			; Decimal Signed Version 
1007			 
1007			; DispA 
1007			; -------------------------------------------------------------- 
1007			; Converts a signed integer value to a zero-terminated ASCII 
1007			; string representative of that value (using radix 10). 
1007			; -------------------------------------------------------------- 
1007			; INPUTS: 
1007			;     HL     Value to convert (two's complement integer). 
1007			;     DE     Base address of string destination. (pointer). 
1007			; -------------------------------------------------------------- 
1007			; OUTPUTS: 
1007			;     None 
1007			; -------------------------------------------------------------- 
1007			; REGISTERS/MEMORY DESTROYED 
1007			; AF HL 
1007			; -------------------------------------------------------------- 
1007			 
1007			;DispHLToASCII: 
1007			;   push    de 
1007			;   push    bc 
1007			; 
1007			;; Detect sign of HL. 
1007			;    bit    7, h 
1007			;    jr     z, ._DoConvert 
1007			; 
1007			;; HL is negative. Output '-' to string and negate HL. 
1007			;    ld     a, '-' 
1007			;    ld     (de), a 
1007			;    inc    de 
1007			; 
1007			;; Negate HL (using two's complement) 
1007			;    xor    a 
1007			;    sub    l 
1007			;    ld     l, a 
1007			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1007			;    sbc    a, h 
1007			;    ld     h, a 
1007			; 
1007			;; Convert HL to digit characters 
1007			;._DoConvert: 
1007			;    ld     b, 0     ; B will count character length of number 
1007			;-   ld     a, 10 
1007			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1007			;    push   af 
1007			;    inc    b 
1007			;    ld     a, h 
1007			;    or     l 
1007			;    jr     nz, - 
1007			; 
1007			;; Retrieve digits from stack 
1007			;-   pop    af 
1007			;    or     $30 
1007			;    ld     (de), a 
1007			;    inc    de 
1007			;    djnz   - 
1007			; 
1007			;; Terminate string with NULL 
1007			;    xor    a 
1007			;    ld     (de), a 
1007			; 
1007			;    pop    bc 
1007			;    pop    de 
1007			;    ret 
1007			 
1007			;Comments 
1007			; 
1007			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1007			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1007			;    Note that the output string will not be fixed-width. 
1007			; 
1007			;Example Usage 
1007			; 
1007			;    ld    hl, -1004 
1007			;    ld    de, OP1 
1007			;    call  DispA 
1007			;    ld    hl, OP1 
1007			;    syscall  PutS 
1007			 
1007			 
1007			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1007			 
1007			 
1007			;Converts an ASCII string to an unsigned 16-bit integer 
1007			;Quits when it reaches a non-decimal digit 
1007			 
1007			string_to_uint16: 
1007			atoui_16: 
1007			;Input: 
1007			;     DE points to the string 
1007			;Outputs: 
1007			;     HL is the result 
1007			;     A is the 8-bit value of the number 
1007			;     DE points to the byte after the number 
1007			;Destroys: 
1007			;     BC 
1007			;       if the string is non-empty, BC is HL/10 
1007			;Size:  24 bytes 
1007			;Speed: 42+d(104+{0,9}) 
1007			;       d is the number of digits in the number 
1007			;       max is 640 cycles for a 5 digit number 
1007			;Assuming no leading zeros: 
1007			;1 digit:  146cc 
1007			;2 digit:  250cc 
1007			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1007			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1007			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1007			;avg: 544.81158447265625cc (544+13297/16384) 
1007			;=============================================================== 
1007 21 00 00		  ld hl,0 
100a			.u16a: 
100a 1a			  ld a,(de) 
100b d6 30		  sub 30h 
100d fe 0a		  cp 10 
100f d0			  ret nc 
1010 13			  inc de 
1011 44			  ld b,h 
1012 4d			  ld c,l 
1013 29			  add hl,hl 
1014 29			  add hl,hl 
1015 09			  add hl,bc 
1016 29			  add hl,hl 
1017 85			  add a,l 
1018 6f			  ld l,a 
1019 30 ef		  jr nc,.u16a 
101b 24			  inc h 
101c c3 0a 10		  jp .u16a 
101f			 
101f			 
101f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
101f			 
101f			;written by Zeda 
101f			;Converts a 16-bit unsigned integer to an ASCII string. 
101f			 
101f			uitoa_16: 
101f			;Input: 
101f			;   DE is the number to convert 
101f			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
101f			;Output: 
101f			;   HL points to the null-terminated ASCII string 
101f			;      NOTE: This isn't necessarily the same as the input HL. 
101f d5			  push de 
1020 c5			  push bc 
1021 f5			  push af 
1022 eb			  ex de,hl 
1023			 
1023 01 f0 d8		  ld bc,-10000 
1026 3e 2f		  ld a,'0'-1 
1028 3c			  inc a 
1029 09			  add hl,bc  
102a 38 fc		   jr c,$-2 
102c 12			  ld (de),a 
102d 13			  inc de 
102e			 
102e 01 e8 03		  ld bc,1000 
1031 3e 3a		  ld a,'9'+1 
1033 3d			  dec a  
1034 09			  add hl,bc  
1035 30 fc		   jr nc,$-2 
1037 12			  ld (de),a 
1038 13			  inc de 
1039			 
1039 01 9c ff		  ld bc,-100 
103c 3e 2f		  ld a,'0'-1 
103e 3c			  inc a  
103f 09			  add hl,bc  
1040 38 fc		   jr c,$-2 
1042 12			  ld (de),a 
1043 13			  inc de 
1044			 
1044 7d			  ld a,l 
1045 26 3a		  ld h,'9'+1 
1047 25			  dec h  
1048 c6 0a		  add a,10  
104a 30 fb		   jr nc,$-3 
104c c6 30		  add a,'0' 
104e eb			  ex de,hl 
104f 72			  ld (hl),d 
1050 23			  inc hl 
1051 77			  ld (hl),a 
1052 23			  inc hl 
1053 36 00		  ld (hl),0 
1055			 
1055			;Now strip the leading zeros 
1055 0e fa		  ld c,-6 
1057 09			  add hl,bc 
1058 3e 30		  ld a,'0' 
105a 23			  inc hl  
105b be			  cp (hl)  
105c 28 fc		  jr z,$-2 
105e			 
105e			;Make sure that the string is non-empty! 
105e 7e			  ld a,(hl) 
105f b7			  or a 
1060 20 01		  jr nz,.atoub 
1062 2b			  dec hl 
1063			.atoub: 
1063			 
1063 f1			  pop af 
1064 c1			  pop bc 
1065 d1			  pop de 
1066 c9			  ret 
1067			 
1067			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1067			 
1067			toUpper: 
1067			;A is the char. 
1067			;If A is a lowercase letter, this sets it to the matching uppercase 
1067			;18cc or 30cc or 41cc 
1067			;avg: 26.75cc 
1067 fe 61		  cp 'a' 
1069 d8			  ret c 
106a fe 7b		  cp 'z'+1 
106c d0			  ret nc 
106d d6 20		  sub 'a'-'A' 
106f c9			  ret 
1070			 
1070			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1070			 
1070			; String Length 
1070			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1070			 
1070			; Get the length of the null-terminated string starting at $8000 hl 
1070			;    LD     HL, $8000 
1070			 
1070			strlenz: 
1070			 
1070 af			    XOR    A               ; Zero is the value we are looking for. 
1071 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1072 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1073			                           ; 65, 536 bytes (the entire addressable memory space). 
1073 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1075			 
1075			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1075 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1076 6f			    LD     L, A             ; number of bytes 
1077 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1079 2b			    DEC    HL              ; Compensate for null. 
107a c9				ret 
107b			 
107b			; Get the length of the A terminated string starting at $8000 hl 
107b			;    LD     HL, $8000 
107b			 
107b			strlent: 
107b			 
107b			                  ; A is the value we are looking for. 
107b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
107d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
107f			                           ; 65, 536 bytes (the entire addressable memory space). 
107f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1081			 
1081			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1081 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1083 2e 00		    LD     L, 0             ; number of bytes 
1085 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1087 2b			    DEC    HL              ; Compensate for null. 
1088 c9				ret 
1089			 
1089			 
1089			;Comparing Strings 
1089			 
1089			;IN    HL     Address of string1. 
1089			;      DE     Address of string2. 
1089			 
1089			; doc given but wrong??? 
1089			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1089			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1089			; tested 
1089			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1089			 
1089			strcmp_old: 
1089 e5			    PUSH   HL 
108a d5			    PUSH   DE 
108b			 
108b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
108c be			    CP     (HL)            ; (want to minimize work). 
108d 38 01		    JR     C, Str1IsBigger 
108f 7e			    LD     A, (HL) 
1090			 
1090			Str1IsBigger: 
1090 4f			    LD     C, A             ; Put length in BC 
1091 06 00		    LD     B, 0 
1093 13			    INC    DE              ; Increment pointers to meat of string. 
1094 23			    INC    HL 
1095			 
1095			CmpLoop: 
1095 1a			    LD     A, (DE)          ; Compare bytes. 
1096 ed a1		    CPI 
1098 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
109a 13			    INC    DE              ; Update pointer. 
109b ea 95 10		    JP     PE, CmpLoop 
109e			 
109e d1			    POP    DE 
109f e1			    POP    HL 
10a0 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
10a1 be			    CP     (HL) 
10a2 c9			    RET 
10a3			 
10a3			NoMatch: 
10a3 2b			    DEC    HL 
10a4 be			    CP     (HL)            ; Compare again to affect carry. 
10a5 d1			    POP    DE 
10a6 e1			    POP    HL 
10a7 c9			    RET 
10a8			 
10a8			;; test strmp 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str2 
10a8			;call strcmp 
10a8			;jr z, .z1 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "NZ1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.z1: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "ZZ1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str1 
10a8			;call strcmp 
10a8			;jr z, .z2 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "NZ2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.z2: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "ZZ2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str2 
10a8			;call strcmp 
10a8			;jr c, .c1 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "Nc1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.c1: 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "cc1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str1 
10a8			;call strcmp 
10a8			;jr c, .c2 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "Nc2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.c2: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "cc2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;	NEXTW 
10a8			;.str1:   db "string1",0 
10a8			;.str2:   db "string2",0 
10a8			 
10a8			; only care about direct match or not 
10a8			; hl and de strings 
10a8			; zero set if the same 
10a8			 
10a8			strcmp: 
10a8 1a				ld a, (de) 
10a9 be				cp (hl) 
10aa 28 02			jr z, .ssame 
10ac b7				or a 
10ad c9				ret 
10ae			 
10ae			.ssame:  
10ae fe 00			cp 0 
10b0 c8				ret z 
10b1			 
10b1 23				inc hl 
10b2 13				inc de 
10b3 18 f3			jr strcmp 
10b5				 
10b5				 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			; eof 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			 
# End of file firmware_strings.asm
10b5			include "firmware_memory.asm"   ; malloc and free  
10b5			 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			.mallocsize: db "Wants malloc >256",0 
10b5			.mallocasize: db "MALLOC gives >256",0 
10b5			.malloczero: db "MALLOC gives zero",0 
10b5			 
10b5			malloc_guard_zerolen: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5				ld de, 0 
10b5			        call cmp16 
10b5				jr nz, .lowalloz 
10b5			 
10b5				push hl 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .malloczero 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5			 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				 
10b5			 
10b5				CALLMONITOR 
10b5			.lowalloz: 
10b5			 
10b5			 
10b5				pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			 
10b5			malloc_guard_entry: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5			 	or a      ;clear carry flag 
10b5				push hl 
10b5				ld de, 255 
10b5				sbc hl, de 
10b5				jr c, .lowalloc 
10b5			 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .mallocsize 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5			 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				 
10b5			 
10b5				CALLMONITOR 
10b5				jr .lowdone 
10b5			.lowalloc: 
10b5			 
10b5			 
10b5				pop hl 
10b5			.lowdone:	pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			 
10b5			malloc_guard_exit: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5			 	or a      ;clear carry flag 
10b5				push hl 
10b5				ld de, 255 
10b5				sbc hl, de 
10b5				jr c, .lowallocx 
10b5			 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .mallocasize 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				CALLMONITOR 
10b5				jr .lowdonex 
10b5			.lowallocx: 
10b5			 
10b5				pop hl 
10b5			.lowdonex:	pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			endif 
10b5			 
10b5			if MALLOC_2 
10b5			; Z80 Malloc and Free Functions 
10b5			 
10b5			; Malloc Function: 
10b5			; Input: 
10b5			;   HL: Size of block to allocate 
10b5			; Output: 
10b5			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b5			 
10b5			malloc: 
10b5				 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			call malloc_guard_entry 
10b5			endif 
10b5			 
10b5			 
10b5			 
10b5			 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "mal" 
10b5						CALLMONITOR 
10b5					endif 
10b5			    push af            ; Save AF register 
10b5			    ld a, l            ; Load low byte of size into A 
10b5			    or h               ; Check if size is zero 
10b5			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
10b5			 
10b5			    ; Allocate memory 
10b5			    ld hl, (heap_start) ; Load start of heap into HL 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma1" 
10b5						CALLMONITOR 
10b5					endif 
10b5			    call malloc_internal ; Call internal malloc function 
10b5			    pop af             ; Restore AF register 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret                ; Return 
10b5			 
10b5			; Free Function: 
10b5			; Input: 
10b5			;   HL: Pointer to memory block to free 
10b5			; Output: 
10b5			;   None 
10b5			 
10b5			free: 
10b5			    push af            ; Save AF register 
10b5			    ld a, l            ; Load low byte of pointer into A 
10b5			    or h               ; Check if pointer is NULL 
10b5			    jp z, free_exit    ; If pointer is NULL, exit 
10b5			 
10b5			    ; Free memory 
10b5			    ld hl, (heap_start) ; Load start of heap into HL 
10b5			    call free_internal  ; Call internal free function 
10b5			    pop af             ; Restore AF register 
10b5			    ret                ; Return 
10b5			 
10b5			; Internal Malloc Function: 
10b5			; Input: 
10b5			;   HL: Size of block to allocate 
10b5			; Output: 
10b5			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b5			 
10b5			malloc_internal: 
10b5			    ld bc, 2           ; Number of bytes to allocate for management overhead 
10b5			    add hl, bc         ; Add management overhead to requested size 
10b5			    ex de, hl          ; Save total size in DE, and keep it in HL 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma2" 
10b5						CALLMONITOR 
10b5					endif 
10b5			 
10b5			    ; Search for free memory block 
10b5			    ld de, (heap_end)  ; Load end of heap into DE 
10b5			    ld bc, 0           ; Initialize counter 
10b5			 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma2" 
10b5						CALLMONITOR 
10b5					endif 
10b5			malloc_search_loop: 
10b5			    ; Check if current block is free 
10b5			    ld a, (hl)         ; Load current block's status (free or used) 
10b5			    cp 0               ; Compare with zero (free) 
10b5			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
10b5			 
10b5			    ; Check if current block is large enough 
10b5			    ld a, (hl+1)       ; Load high byte of block size 
10b5			    cp l               ; Compare with low byte of requested size 
10b5			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
10b5			 
10b5			    ld a, (hl+2)       ; Load low byte of block size 
10b5			    cp h               ; Compare with high byte of requested size 
10b5			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
10b5			 
10b5			    ; Mark block as used 
10b5			    ld (hl), 0xFF      ; Set status byte to indicate used block 
10b5			 
10b5			    ; Calculate remaining space in block 
10b5			    ld bc, 0           ; Clear BC 
10b5			    add hl, bc         ; Increment HL to point to start of data block 
10b5			    add hl, de         ; HL = HL + DE (total size) 
10b5			    ld bc, 1           ; Number of bytes to allocate for management overhead 
10b5			    add hl, bc         ; Add management overhead to start of data block 
10b5			 
10b5			    ; Save pointer to allocated block in HL 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma5" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			 
10b5			malloc_skip_block_check: 
10b5			    ; Move to the next block 
10b5			    ld bc, 3           ; Size of management overhead 
10b5			    add hl, bc         ; Move to the next block 
10b5			    inc de             ; Increment counter 
10b5			 
10b5			    ; Check if we have reached the end of heap 
10b5			    ld a, e            ; Load low byte of heap end address 
10b5			    cp (hl)            ; Compare with low byte of current address 
10b5			    jr nz, malloc_search_loop  ; If not equal, continue searching 
10b5			    ld a, d            ; Load high byte of heap end address 
10b5			    cp 0               ; Check if it's zero (end of memory) 
10b5			    jr nz, malloc_search_loop  ; If not zero, continue searching 
10b5			 
10b5			    ; If we reached here, allocation failed 
10b5			    xor a              ; Set result to NULL 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma6" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			malloc_exit: 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma7" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			 
10b5			; Internal Free Function: 
10b5			; Input: 
10b5			;   HL: Pointer to memory block to free 
10b5			; Output: 
10b5			;   None 
10b5			 
10b5			free_internal: 
10b5			    ld de, (heap_start) ; Load start of heap into DE 
10b5			    ld bc, 0            ; Initialize counter 
10b5			 
10b5			free_search_loop: 
10b5			    ; Check if current block contains the pointer 
10b5			    ld a, l             ; Load low byte of pointer 
10b5			    cp (hl+1)           ; Compare with high byte of current block's address 
10b5			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b5			    ld a, h             ; Load high byte of pointer 
10b5			    cp (hl+2)           ; Compare with low byte of current block's address 
10b5			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b5			 
10b5			    ; Mark block as free 
10b5			    ld (hl), 0          ; Set status byte to indicate free block 
10b5			    ret                 ; Return 
10b5			 
10b5			free_skip_block_check: 
10b5			    ; Move to the next block 
10b5			    ld bc, 3            ; Size of management overhead 
10b5			    add hl, bc          ; Move to the next block 
10b5			    inc de              ; Increment counter 
10b5			 
10b5			    ; Check if we have reached the end of heap 
10b5			    ld a, e             ; Load low byte of heap end address 
10b5			    cp (hl)             ; Compare with low byte of current address 
10b5			    jr nz, free_search_loop  ; If not equal, continue searching 
10b5			    ld a, d             ; Load high byte of heap end address 
10b5			    cp 0                ; Check if it's zero (end of memory) 
10b5			    jr nz, free_search_loop  ; If not zero, continue searching 
10b5			 
10b5			    ; If we reached here, pointer is not found in heap 
10b5			    ret 
10b5			 
10b5			free_exit: 
10b5			    ret                 ; Return 
10b5			 
10b5			; Define heap start and end addresses 
10b5			;heap_start:    .dw 0xC000   ; Start of heap 
10b5			;heap_end:      .dw 0xE000   ; End of heap 
10b5			 
10b5			endif 
10b5			 
10b5			 
10b5			if MALLOC_1 
10b5			 
10b5			 
10b5			 
10b5			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
10b5			 
10b5			;moved to firmware.asm 
10b5			;heap_start        .equ  0x9000      ; Starting address of heap 
10b5			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
10b5			 
10b5			;      .org 0 
10b5			;      jp    main 
10b5			 
10b5			 
10b5			;      .org  0x100 
10b5			;main: 
10b5			;      ld    HL, 0x8100 
10b5			;      ld    SP, HL 
10b5			; 
10b5			;      call  heap_init 
10b5			; 
10b5			;      ; Make some allocations 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9004 
10b5			; 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9014 
10b5			; 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9024 
10b5			; 
10b5			;      ; Free some allocations 
10b5			;      ld    HL, 0x9014 
10b5			;      call  free 
10b5			; 
10b5			;      ld    HL, 0x9004 
10b5			;      call  free 
10b5			; 
10b5			;      ld    HL, 0x9024 
10b5			;      call  free 
10b5			; 
10b5			; 
10b5			;      halt 
10b5			 
10b5			 
10b5			;------------------------------------------------------------------------------ 
10b5			;     heap_init                                                               : 
10b5			;                                                                             : 
10b5			; Description                                                                 : 
10b5			;     Initialise the heap and make it ready for malloc and free operations.   : 
10b5			;                                                                             : 
10b5			;     The heap is maintained as a linked list, starting with an initial       : 
10b5			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
10b5			;     the first free block in the heap. Each block then points to the next    : 
10b5			;     free block within the heap, and the free list ends at the first block   : 
10b5			;     with a null pointer to the next free block.                             : 
10b5			;                                                                             : 
10b5			; Parameters                                                                  : 
10b5			;     Inputs are compile-time only. Two defines which specify the starting    : 
10b5			;     address of the heap and its size are required, along with a memory      : 
10b5			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
10b5			;     principally stores a pointer to the first free block in the heap.       : 
10b5			;                                                                             : 
10b5			; Returns                                                                     : 
10b5			;     Nothing                                                                 : 
10b5			;------------------------------------------------------------------------------ 
10b5			heap_init: 
10b5 e5			      push  HL 
10b6			 
10b6			      ; Initialise free list struct 
10b6 21 0e 80		      ld    HL, heap_start 
10b9 22 0a 80		      ld    (free_list), HL 
10bc 21 00 00		      ld    HL, 0 
10bf 22 0c 80		      ld    (free_list+2), HL 
10c2			 
10c2			      ; Insert first free block at bottom of heap, consumes entire heap 
10c2 21 22 ee		      ld    HL, heap_start+heap_size-4 
10c5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
10c8 21 14 6e		      ld    HL, heap_size-4 
10cb 22 10 80		      ld    (heap_start+2), HL      ; Block size 
10ce			 
10ce			      ; Insert end of free list block at top of heap - two null words will 
10ce			      ; terminate the free list 
10ce 21 00 00		      ld    HL, 0 
10d1 22 24 ee		      ld    (heap_start+heap_size-2), HL 
10d4 22 22 ee		      ld    (heap_start+heap_size-4), HL 
10d7			 
10d7 e1			      pop   HL 
10d8			 
10d8 c9			      ret 
10d9			 
10d9			 
10d9			;------------------------------------------------------------------------------ 
10d9			;     malloc                                                                  : 
10d9			;                                                                             : 
10d9			; Description                                                                 : 
10d9			;     Allocates the wanted space from the heap and returns the address of the : 
10d9			;     first useable byte of the allocation.                                   : 
10d9			;                                                                             : 
10d9			;     Allocations can happen in one of two ways:                              : 
10d9			;                                                                             : 
10d9			;     1. A free block may be found which is the exact size wanted. In this    : 
10d9			;        case the block is removed from the free list and retuedn to the      : 
10d9			;        caller.                                                              : 
10d9			;     2. A free block may be found which is larger than the size wanted. In   : 
10d9			;        this case, the larger block is split into two. The first portion of  : 
10d9			;        this block will become the requested space by the malloc call and    : 
10d9			;        is returned to the caller. The second portion becomes a new free     : 
10d9			;        block, and the free list is adjusted to maintain continuity via this : 
10d9			;        newly created block.                                                 : 
10d9			;                                                                             : 
10d9			;     malloc does not set any initial value in the allocated space, the       : 
10d9			;     caller is required to do this as required.                              : 
10d9			;                                                                             : 
10d9			;     This implementation of malloc uses the stack exclusively, and is        : 
10d9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10d9			;     advisable to disable interrupts before calling malloc, and recommended  : 
10d9			;     to avoid the use of malloc inside ISRs in general.                      : 
10d9			;                                                                             : 
10d9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10d9			;                                                                             : 
10d9			; Parameters                                                                  : 
10d9			;     HL  Number of bytes wanted                                              : 
10d9			;                                                                             : 
10d9			; Returns                                                                     : 
10d9			;     HL  Address of the first useable byte of the allocation                 : 
10d9			;                                                                             : 
10d9			; Flags                                                                       : 
10d9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
10d9			;                                                                             : 
10d9			; Stack frame                                                                 : 
10d9			;       |             |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     BC      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     DE      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     IX      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |  prev_free  |                                                       : 
10d9			;   +4  +-------------+                                                       : 
10d9			;       |  this_free  |                                                       : 
10d9			;   +2  +-------------+                                                       : 
10d9			;       |  next_free  |                                                       : 
10d9			;   +0  +-------------+                                                       : 
10d9			;       |             |                                                       : 
10d9			;                                                                             : 
10d9			;------------------------------------------------------------------------------ 
10d9			 
10d9			 
10d9			;malloc: 
10d9			; 
10d9			;	SAVESP ON 1 
10d9			; 
10d9			;	call malloc_code 
10d9			; 
10d9			;	CHECKSP ON 1 
10d9			;	ret 
10d9			 
10d9			 
10d9			malloc: 
10d9 c5			      push  BC 
10da d5			      push  DE 
10db dd e5		      push  IX 
10dd			if DEBUG_FORTH_MALLOC_HIGH 
10dd			call malloc_guard_entry 
10dd			endif 
10dd			 
10dd					if DEBUG_FORTH_MALLOC 
10dd						DMARK "mal" 
10dd						CALLMONITOR 
10dd					endif 
10dd 7c			      ld    A, H                    ; Exit if no space requested 
10de b5			      or    L 
10df ca 9e 11		      jp    Z, malloc_early_exit 
10e2			 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			; 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			 
10e2			 
10e2			 
10e2			 
10e2					if DEBUG_FORTH_MALLOC 
10e2						DMARK "maA" 
10e2						CALLMONITOR 
10e2					endif 
10e2			      ; Set up stack frame 
10e2 eb			      ex    DE, HL 
10e3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
10e6 39			      add   HL, SP 
10e7 f9			      ld    SP, HL 
10e8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10ec dd 39		      add   IX, SP 
10ee			 
10ee			      ; Setup initial state 
10ee 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10f1 19			      add   HL, DE 
10f2			 
10f2 44			      ld    B, H                    ; Move want to BC 
10f3 4d			      ld    C, L 
10f4			 
10f4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
10f7 dd 75 04		      ld    (IX+4), L 
10fa dd 74 05		      ld    (IX+5), H 
10fd			 
10fd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10fe 23			      inc   HL 
10ff 56			      ld    D, (HL) 
1100 dd 73 02		      ld    (IX+2), E 
1103 dd 72 03		      ld    (IX+3), D 
1106 eb			      ex    DE, HL                  ; this_free ptr into HL 
1107			 
1107					if DEBUG_FORTH_MALLOC 
1107						DMARK "maB" 
1107						CALLMONITOR 
1107					endif 
1107			      ; Loop through free block list to find some space 
1107			malloc_find_space: 
1107 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1108 23			      inc   HL 
1109 56			      ld    D, (HL) 
110a			 
110a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
110b b3			      or    E 
110c ca 98 11		      jp    Z, malloc_no_space 
110f			 
110f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1112 dd 72 01		      ld    (IX+1), D 
1115			 
1115			      ; Does this block have enough space to make the allocation? 
1115 23			      inc   HL                      ; Load free block size into DE 
1116 5e			      ld    E, (HL) 
1117 23			      inc   HL 
1118 56			      ld    D, (HL) 
1119			 
1119 eb			      ex    DE, HL                  ; Check size of block against want 
111a b7			      or    A                       ; Ensure carry flag clear 
111b ed 42		      sbc   HL, BC 
111d e5			      push  HL                      ; Store the result for later (new block size) 
111e			 
111e ca 6d 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1121 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1123			 
1123			      ; this_free block is not big enough, setup ptrs to test next free block 
1123 e1			      pop   HL                      ; Discard previous result 
1124			 
1124 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1127 dd 66 03		      ld    H, (IX+3) 
112a dd 75 04		      ld    (IX+4), L 
112d dd 74 05		      ld    (IX+5), H 
1130			 
1130 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1133 dd 66 01		      ld    H, (IX+1) 
1136 dd 75 02		      ld    (IX+2), L 
1139 dd 74 03		      ld    (IX+3), H 
113c			 
113c					if DEBUG_FORTH_MALLOC 
113c						DMARK "MA>" 
113c						CALLMONITOR 
113c					endif 
113c 18 c9		      jr    malloc_find_space 
113e			 
113e			      ; split a bigger block into two - requested size and remaining size 
113e			malloc_alloc_split: 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAs" 
113e						CALLMONITOR 
113e					endif 
113e eb			      ex    DE, HL                  ; Calculate address of new free block 
113f 2b			      dec   HL 
1140 2b			      dec   HL 
1141 2b			      dec   HL 
1142 09			      add   HL, BC 
1143			 
1143			      ; Create a new block and point it at next_free 
1143 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1146 dd 56 01		      ld    D, (IX+1) 
1149			 
1149 73			      ld    (HL), E                 ; Store next_free ptr into new block 
114a 23			      inc   HL 
114b 72			      ld    (HL), D 
114c			 
114c d1			      pop   DE                      ; Store size of new block into new block 
114d 23			      inc   HL 
114e 73			      ld    (HL), E 
114f 23			      inc   HL 
1150 72			      ld    (HL), D 
1151			 
1151			      ; Update this_free ptr to point to new block 
1151 2b			      dec   HL 
1152 2b			      dec   HL 
1153 2b			      dec   HL 
1154			 
1154 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1157 dd 56 03		      ld    D, (IX+3) 
115a			 
115a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
115d dd 74 03		      ld    (IX+3), H 
1160			 
1160			      ; Modify this_free block to be allocation 
1160 eb			      ex    DE, HL 
1161 af			      xor   A                       ; Null the next block ptr of allocated block 
1162 77			      ld    (HL), A 
1163 23			      inc   HL 
1164 77			      ld    (HL), A 
1165			 
1165 23			      inc   HL                      ; Store want size into allocated block 
1166 71			      ld    (HL), C 
1167 23			      inc   HL 
1168 70			      ld    (HL), B 
1169 23			      inc   HL 
116a e5			      push  HL                      ; Address of allocation to return 
116b			 
116b 18 19		      jr    malloc_update_links 
116d			 
116d			malloc_alloc_fit: 
116d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
116e			 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "MAf" 
116e						CALLMONITOR 
116e					endif 
116e			      ; Modify this_free block to be allocation 
116e eb			      ex    DE, HL 
116f 2b			      dec   HL 
1170 2b			      dec   HL 
1171 2b			      dec   HL 
1172			 
1172 af			      xor   A                       ; Null the next block ptr of allocated block 
1173 77			      ld    (HL), A 
1174 23			      inc   HL 
1175 77			      ld    (HL), A 
1176			 
1176 23			      inc   HL                      ; Store address of allocation to return 
1177 23			      inc   HL 
1178 23			      inc   HL 
1179 e5			      push  HL 
117a			 
117a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
117a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
117d dd 66 01		      ld    H, (IX+1) 
1180			 
1180 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1183 dd 74 03		      ld    (IX+3), H 
1186			 
1186			 
1186			malloc_update_links: 
1186			      ; Update prev_free ptr to point to this_free 
1186 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1189 dd 66 05		      ld    H, (IX+5) 
118c			 
118c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
118f dd 56 03		      ld    D, (IX+3) 
1192			 
1192 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1193 23			      inc   HL 
1194 72			      ld    (HL), D 
1195			 
1195					if DEBUG_FORTH_MALLOC 
1195						DMARK "Mul" 
1195						CALLMONITOR 
1195					endif 
1195			      ; Clear the Z flag to indicate successful allocation 
1195 7a			      ld    A, D 
1196 b3			      or    E 
1197			 
1197 d1			      pop   DE                      ; Address of allocation 
1198					if DEBUG_FORTH_MALLOC 
1198						DMARK "MAu" 
1198						CALLMONITOR 
1198					endif 
1198			 
1198			malloc_no_space: 
1198 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
119b 39			      add   HL, SP 
119c f9			      ld    SP, HL 
119d			 
119d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
119e					if DEBUG_FORTH_MALLOC 
119e						DMARK "MAN" 
119e						CALLMONITOR 
119e					endif 
119e			 
119e			malloc_early_exit: 
119e					if DEBUG_FORTH_MALLOC 
119e						DMARK "MAx" 
119e						CALLMONITOR 
119e					endif 
119e dd e1		      pop   IX 
11a0 d1			      pop   DE 
11a1 c1			      pop   BC 
11a2			 
11a2			if DEBUG_FORTH_MALLOC_HIGH 
11a2			call malloc_guard_exit 
11a2			call malloc_guard_zerolen 
11a2			endif 
11a2 c9			      ret 
11a3			 
11a3			 
11a3			;------------------------------------------------------------------------------ 
11a3			;     free                                                                    : 
11a3			;                                                                             : 
11a3			; Description                                                                 : 
11a3			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11a3			;     returned by malloc, otherwise the behaviour is undefined.               : 
11a3			;                                                                             : 
11a3			;     Where possible, directly adjacent free blocks will be merged together   : 
11a3			;     into larger blocks to help ensure that the heap does not become         : 
11a3			;     excessively fragmented.                                                 : 
11a3			;                                                                             : 
11a3			;     free does not clear or set any other value into the freed space, and    : 
11a3			;     therefore its contents may be visible through subsequent malloc's. The  : 
11a3			;     caller should clear the freed space as required.                        : 
11a3			;                                                                             : 
11a3			;     This implementation of free uses the stack exclusively, and is          : 
11a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11a3			;     advisable to disable interrupts before calling free, and recommended    : 
11a3			;     to avoid the use of free inside ISRs in general.                        : 
11a3			;                                                                             : 
11a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11a3			;                                                                             : 
11a3			; Parameters                                                                  : 
11a3			;     HL  Pointer to address of first byte of allocation to be freed          : 
11a3			;                                                                             : 
11a3			; Returns                                                                     : 
11a3			;     Nothing                                                                 : 
11a3			;                                                                             : 
11a3			; Stack frame                                                                 : 
11a3			;       |             |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     BC      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     DE      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     IX      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |  prev_free  |                                                       : 
11a3			;   +2  +-------------+                                                       : 
11a3			;       |  next_free  |                                                       : 
11a3			;   +0  +-------------+                                                       : 
11a3			;       |             |                                                       : 
11a3			;                                                                             : 
11a3			;------------------------------------------------------------------------------ 
11a3			free: 
11a3 c5			      push  BC 
11a4 d5			      push  DE 
11a5 dd e5		      push  IX 
11a7			 
11a7 7c			      ld    A, H                    ; Exit if ptr is null 
11a8 b5			      or    L 
11a9 ca 6d 12		      jp    Z, free_early_exit 
11ac			 
11ac			      ; Set up stack frame 
11ac eb			      ex    DE, HL 
11ad 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11b0 39			      add   HL, SP 
11b1 f9			      ld    SP, HL 
11b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11b6 dd 39		      add   IX, SP 
11b8			 
11b8			      ; The address in HL points to the start of the useable allocated space, 
11b8			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11b8			      ; address of the block itself. 
11b8 eb			      ex    DE, HL 
11b9 11 fc ff		      ld    DE, -4 
11bc 19			      add   HL, DE 
11bd			 
11bd			      ; An allocated block must have a null next block pointer in it 
11bd 7e			      ld    A, (HL) 
11be 23			      inc   HL 
11bf b6			      or    (HL) 
11c0 c2 68 12		      jp    NZ, free_done 
11c3			 
11c3 2b			      dec   HL 
11c4			 
11c4 44			      ld    B, H                    ; Copy HL to BC 
11c5 4d			      ld    C, L 
11c6			 
11c6			      ; Loop through the free list to find the first block with an address 
11c6			      ; higher than the block being freed 
11c6 21 0a 80		      ld    HL, free_list 
11c9			 
11c9			free_find_higher_block: 
11c9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
11ca 23			      inc   HL 
11cb 56			      ld    D, (HL) 
11cc 2b			      dec   HL 
11cd			 
11cd dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
11d0 dd 72 01		      ld    (IX+1), D 
11d3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
11d6 dd 74 03		      ld    (IX+3), H 
11d9			 
11d9 78			      ld    A, B                    ; Check if DE is greater than BC 
11da ba			      cp    D                       ; Compare MSB first 
11db 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
11dd 30 04		      jr    NC, free_find_higher_block_skip 
11df 79			      ld    A, C 
11e0 bb			      cp    E                       ; Then compare LSB 
11e1 38 08		      jr    C, free_found_higher_block 
11e3			 
11e3			free_find_higher_block_skip: 
11e3 7a			      ld    A, D                    ; Reached the end of the free list? 
11e4 b3			      or    E 
11e5 ca 68 12		      jp    Z, free_done 
11e8			 
11e8 eb			      ex    DE, HL 
11e9			 
11e9 18 de		      jr    free_find_higher_block 
11eb			 
11eb			free_found_higher_block: 
11eb			      ; Insert freed block between prev and next free blocks 
11eb 71			      ld    (HL), C                 ; Point prev free block to freed block 
11ec 23			      inc   HL 
11ed 70			      ld    (HL), B 
11ee			 
11ee 60			      ld    H, B                    ; Point freed block at next free block 
11ef 69			      ld    L, C 
11f0 73			      ld    (HL), E 
11f1 23			      inc   HL 
11f2 72			      ld    (HL), D 
11f3			 
11f3			      ; Check if the freed block is adjacent to the next free block 
11f3 23			      inc   HL                      ; Load size of freed block into HL 
11f4 5e			      ld    E, (HL) 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 eb			      ex    DE, HL 
11f8			 
11f8 09			      add   HL, BC                  ; Add addr of freed block and its size 
11f9			 
11f9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11fc dd 56 01		      ld    D, (IX+1) 
11ff			 
11ff b7			      or    A                       ; Clear the carry flag 
1200 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1202 20 22		      jr    NZ, free_check_adjacent_to_prev 
1204			 
1204			      ; Freed block is adjacent to next, merge into one bigger block 
1204 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1205 5e			      ld    E, (HL) 
1206 23			      inc   HL 
1207 56			      ld    D, (HL) 
1208 e5			      push  HL                      ; Save ptr to next block for later 
1209			 
1209 60			      ld    H, B                    ; Store ptr from next block into freed block 
120a 69			      ld    L, C 
120b 73			      ld    (HL), E 
120c 23			      inc   HL 
120d 72			      ld    (HL), D 
120e			 
120e e1			      pop   HL                      ; Restore ptr to next block 
120f 23			      inc   HL                      ; Load size of next block into DE 
1210 5e			      ld    E, (HL) 
1211 23			      inc   HL 
1212 56			      ld    D, (HL) 
1213 d5			      push  DE                      ; Save next block size for later 
1214			 
1214 60			      ld    H, B                    ; Load size of freed block into HL 
1215 69			      ld    L, C 
1216 23			      inc   HL 
1217 23			      inc   HL 
1218 5e			      ld    E, (HL) 
1219 23			      inc   HL 
121a 56			      ld    D, (HL) 
121b eb			      ex    DE, HL 
121c			 
121c d1			      pop   DE                      ; Restore size of next block 
121d 19			      add   HL, DE                  ; Add sizes of both blocks 
121e eb			      ex    DE, HL 
121f			 
121f 60			      ld    H, B                    ; Store new bigger size into freed block 
1220 69			      ld    L, C 
1221 23			      inc   HL 
1222 23			      inc   HL 
1223 73			      ld    (HL), E 
1224 23			      inc   HL 
1225 72			      ld    (HL), D 
1226			 
1226			free_check_adjacent_to_prev: 
1226			      ; Check if the freed block is adjacent to the prev free block 
1226 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1229 dd 66 03		      ld    H, (IX+3) 
122c			 
122c 23			      inc   HL                      ; Size of prev free block into DE 
122d 23			      inc   HL 
122e 5e			      ld    E, (HL) 
122f 23			      inc   HL 
1230 56			      ld    D, (HL) 
1231 2b			      dec   HL 
1232 2b			      dec   HL 
1233 2b			      dec   HL 
1234			 
1234 19			      add   HL, DE                  ; Add prev block addr and size 
1235			 
1235 b7			      or    A                       ; Clear the carry flag 
1236 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1238 20 2e		      jr    NZ, free_done 
123a			 
123a			      ; Freed block is adjacent to prev, merge into one bigger block 
123a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
123b 69			      ld    L, C 
123c 5e			      ld    E, (HL) 
123d 23			      inc   HL 
123e 56			      ld    D, (HL) 
123f e5			      push  HL                      ; Save freed block ptr for later 
1240			 
1240 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1243 dd 66 03		      ld    H, (IX+3) 
1246 73			      ld    (HL), E 
1247 23			      inc   HL 
1248 72			      ld    (HL), D 
1249			 
1249 e1			      pop   HL                      ; Restore freed block ptr 
124a 23			      inc   HL                      ; Load size of freed block into DE 
124b 5e			      ld    E, (HL) 
124c 23			      inc   HL 
124d 56			      ld    D, (HL) 
124e d5			      push  DE                      ; Save freed block size for later 
124f			 
124f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1252 dd 66 03		      ld    H, (IX+3) 
1255 23			      inc   HL 
1256 23			      inc   HL 
1257 5e			      ld    E, (HL) 
1258 23			      inc   HL 
1259 56			      ld    D, (HL) 
125a			 
125a e1			      pop   HL                      ; Add sizes of both blocks 
125b 19			      add   HL, DE 
125c eb			      ex    DE, HL 
125d			 
125d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1260 dd 66 03		      ld    H, (IX+3) 
1263 23			      inc   HL 
1264 23			      inc   HL 
1265 73			      ld    (HL), E 
1266 23			      inc   HL 
1267 72			      ld    (HL), D 
1268			 
1268			free_done: 
1268 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
126b 39			      add   HL, SP 
126c f9			      ld    SP, HL 
126d			 
126d			free_early_exit: 
126d dd e1		      pop   IX 
126f d1			      pop   DE 
1270 c1			      pop   BC 
1271			 
1271 c9			      ret 
1272			 
1272			; moved to firmware.asm 
1272			; 
1272			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1272			;                  .dw   0 
1272			 
1272			 
1272			endif 
1272			 
1272			 
1272			if MALLOC_3 
1272			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1272			;heap_start        .equ  0x9000      ; Starting address of heap 
1272			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1272			; 
1272			 ;     .org 0 
1272			  ;    jp    main 
1272			; 
1272			; 
1272			 ;     .org  0x100 
1272			;main: 
1272			 ;     ld    HL, 0x8100 
1272			  ;    ld    SP, HL 
1272			; 
1272			;      call  heap_init 
1272			 
1272			      ; Make some allocations 
1272			;      ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9004 
1272			; 
1272			 ;     ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9014 
1272			 
1272			;      ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9024 
1272			 
1272			      ; Free some allocations 
1272			;      ld    HL, 0x9014 
1272			;      call  free 
1272			 
1272			;      ld    HL, 0x9004 
1272			;      call  free 
1272			; 
1272			;      ld    HL, 0x9024 
1272			;      call  free 
1272			 
1272			 
1272			 ;     halt 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     heap_init                                                               : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Initialise the heap and make it ready for malloc and free operations.   : 
1272			;                                                                             : 
1272			;     The heap is maintained as a linked list, starting with an initial       : 
1272			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1272			;     the first free block in the heap. Each block then points to the next    : 
1272			;     free block within the heap, and the free list ends at the first block   : 
1272			;     with a null pointer to the next free block.                             : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     Inputs are compile-time only. Two defines which specify the starting    : 
1272			;     address of the heap and its size are required, along with a memory      : 
1272			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1272			;     principally stores a pointer to the first free block in the heap.       : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     Nothing                                                                 : 
1272			;------------------------------------------------------------------------------ 
1272			heap_init: 
1272			      push  HL 
1272			 
1272			      ; Initialise free list struct 
1272			      ld    HL, heap_start 
1272			      ld    (free_list), HL 
1272			      ld    HL, 0 
1272			      ld    (free_list+2), HL 
1272			 
1272			      ; Insert first free block at bottom of heap, consumes entire heap 
1272			      ld    HL, heap_start+heap_size-4 
1272			      ld    (heap_start), HL        ; Next block (end of free list) 
1272			      ld    HL, heap_size-4 
1272			      ld    (heap_start+2), HL      ; Block size 
1272			 
1272			      ; Insert end of free list block at top of heap - two null words will 
1272			      ; terminate the free list 
1272			      ld    HL, 0 
1272			      ld    (heap_start+heap_size-2), HL 
1272			      ld    (heap_start+heap_size-4), HL 
1272			 
1272			      pop   HL 
1272			 
1272			      ret 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     malloc                                                                  : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Allocates the wanted space from the heap and returns the address of the : 
1272			;     first useable byte of the allocation.                                   : 
1272			;                                                                             : 
1272			;     Allocations can happen in one of two ways:                              : 
1272			;                                                                             : 
1272			;     1. A free block may be found which is the exact size wanted. In this    : 
1272			;        case the block is removed from the free list and retuedn to the      : 
1272			;        caller.                                                              : 
1272			;     2. A free block may be found which is larger than the size wanted. In   : 
1272			;        this case, the larger block is split into two. The first portion of  : 
1272			;        this block will become the requested space by the malloc call and    : 
1272			;        is returned to the caller. The second portion becomes a new free     : 
1272			;        block, and the free list is adjusted to maintain continuity via this : 
1272			;        newly created block.                                                 : 
1272			;                                                                             : 
1272			;     malloc does not set any initial value in the allocated space, the       : 
1272			;     caller is required to do this as required.                              : 
1272			;                                                                             : 
1272			;     This implementation of malloc uses the stack exclusively, and is        : 
1272			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1272			;     advisable to disable interrupts before calling malloc, and recommended  : 
1272			;     to avoid the use of malloc inside ISRs in general.                      : 
1272			;                                                                             : 
1272			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     HL  Number of bytes wanted                                              : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     HL  Address of the first useable byte of the allocation                 : 
1272			;                                                                             : 
1272			; Flags                                                                       : 
1272			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1272			;                                                                             : 
1272			; Stack frame                                                                 : 
1272			;       |             |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     BC      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     DE      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     IX      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |  prev_free  |                                                       : 
1272			;   +4  +-------------+                                                       : 
1272			;       |  this_free  |                                                       : 
1272			;   +2  +-------------+                                                       : 
1272			;       |  next_free  |                                                       : 
1272			;   +0  +-------------+                                                       : 
1272			;       |             |                                                       : 
1272			;                                                                             : 
1272			;------------------------------------------------------------------------------ 
1272			malloc: 
1272			      push  BC 
1272			      push  DE 
1272			      push  IX 
1272			 
1272			      ld    A, H                    ; Exit if no space requested 
1272			      or    L 
1272			      jp    Z, malloc_early_exit 
1272			 
1272			      ; Set up stack frame 
1272			      ex    DE, HL 
1272			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			      ld    IX, 0                   ; Use IX as a frame pointer 
1272			      add   IX, SP 
1272			 
1272			      ; Setup initial state 
1272			      ld    HL, 4                   ; want must also include space used by block struct 
1272			      add   HL, DE 
1272			 
1272			      ld    B, H                    ; Move want to BC 
1272			      ld    C, L 
1272			 
1272			      ld    HL, free_list           ; Store prev_free ptr to stack 
1272			      ld    (IX+4), L 
1272			      ld    (IX+5), H 
1272			 
1272			      ld    E, (HL)                 ; Store this_free ptr to stack 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ld    (IX+2), E 
1272			      ld    (IX+3), D 
1272			      ex    DE, HL                  ; this_free ptr into HL 
1272			 
1272			      ; Loop through free block list to find some space 
1272			malloc_find_space: 
1272			      ld    E, (HL)                 ; Load next_free ptr into DE 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1272			      or    E 
1272			      jp    Z, malloc_no_space 
1272			 
1272			      ld    (IX+0), E               ; Store next_free ptr to stack 
1272			      ld    (IX+1), D 
1272			 
1272			      ; Does this block have enough space to make the allocation? 
1272			      inc   HL                      ; Load free block size into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      ex    DE, HL                  ; Check size of block against want 
1272			      or    A                       ; Ensure carry flag clear 
1272			      sbc   HL, BC 
1272			      push  HL                      ; Store the result for later (new block size) 
1272			 
1272			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1272			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1272			 
1272			      ; this_free block is not big enough, setup ptrs to test next free block 
1272			      pop   HL                      ; Discard previous result 
1272			 
1272			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1272			      ld    H, (IX+3) 
1272			      ld    (IX+4), L 
1272			      ld    (IX+5), H 
1272			 
1272			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1272			      ld    H, (IX+1) 
1272			      ld    (IX+2), L 
1272			      ld    (IX+3), H 
1272			 
1272			      jr    malloc_find_space 
1272			 
1272			      ; split a bigger block into two - requested size and remaining size 
1272			malloc_alloc_split: 
1272			      ex    DE, HL                  ; Calculate address of new free block 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			      add   HL, BC 
1272			 
1272			      ; Create a new block and point it at next_free 
1272			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1272			      ld    D, (IX+1) 
1272			 
1272			      ld    (HL), E                 ; Store next_free ptr into new block 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   DE                      ; Store size of new block into new block 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Update this_free ptr to point to new block 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1272			      ld    D, (IX+3) 
1272			 
1272			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1272			      ld    (IX+3), H 
1272			 
1272			      ; Modify this_free block to be allocation 
1272			      ex    DE, HL 
1272			      xor   A                       ; Null the next block ptr of allocated block 
1272			      ld    (HL), A 
1272			      inc   HL 
1272			      ld    (HL), A 
1272			 
1272			      inc   HL                      ; Store want size into allocated block 
1272			      ld    (HL), C 
1272			      inc   HL 
1272			      ld    (HL), B 
1272			      inc   HL 
1272			      push  HL                      ; Address of allocation to return 
1272			 
1272			      jr    malloc_update_links 
1272			 
1272			malloc_alloc_fit: 
1272			      pop   HL                      ; Dont need new block size, want is exact fit 
1272			 
1272			      ; Modify this_free block to be allocation 
1272			      ex    DE, HL 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      xor   A                       ; Null the next block ptr of allocated block 
1272			      ld    (HL), A 
1272			      inc   HL 
1272			      ld    (HL), A 
1272			 
1272			      inc   HL                      ; Store address of allocation to return 
1272			      inc   HL 
1272			      inc   HL 
1272			      push  HL 
1272			 
1272			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1272			      ld    L, (IX+0)               ; next_free to HL 
1272			      ld    H, (IX+1) 
1272			 
1272			      ld    (IX+2), L               ; HL to this_free 
1272			      ld    (IX+3), H 
1272			 
1272			 
1272			malloc_update_links: 
1272			      ; Update prev_free ptr to point to this_free 
1272			      ld    L, (IX+4)               ; prev_free ptr to HL 
1272			      ld    H, (IX+5) 
1272			 
1272			      ld    E, (IX+2)               ; this_free ptr to DE 
1272			      ld    D, (IX+3) 
1272			 
1272			      ld    (HL), E                 ; this_free ptr into prev_free 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Clear the Z flag to indicate successful allocation 
1272			      ld    A, D 
1272			      or    E 
1272			 
1272			      pop   DE                      ; Address of allocation 
1272			 
1272			malloc_no_space: 
1272			      ld    HL, 6                   ; Clean up stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			 
1272			      ex    DE, HL                  ; Alloc addr into HL for return 
1272			 
1272			malloc_early_exit: 
1272			      pop   IX 
1272			      pop   DE 
1272			      pop   BC 
1272			 
1272			      ret 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     free                                                                    : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1272			;     returned by malloc, otherwise the behaviour is undefined.               : 
1272			;                                                                             : 
1272			;     Where possible, directly adjacent free blocks will be merged together   : 
1272			;     into larger blocks to help ensure that the heap does not become         : 
1272			;     excessively fragmented.                                                 : 
1272			;                                                                             : 
1272			;     free does not clear or set any other value into the freed space, and    : 
1272			;     therefore its contents may be visible through subsequent malloc's. The  : 
1272			;     caller should clear the freed space as required.                        : 
1272			;                                                                             : 
1272			;     This implementation of free uses the stack exclusively, and is          : 
1272			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1272			;     advisable to disable interrupts before calling free, and recommended    : 
1272			;     to avoid the use of free inside ISRs in general.                        : 
1272			;                                                                             : 
1272			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     HL  Pointer to address of first byte of allocation to be freed          : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     Nothing                                                                 : 
1272			;                                                                             : 
1272			; Stack frame                                                                 : 
1272			;       |             |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     BC      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     DE      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     IX      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |  prev_free  |                                                       : 
1272			;   +2  +-------------+                                                       : 
1272			;       |  next_free  |                                                       : 
1272			;   +0  +-------------+                                                       : 
1272			;       |             |                                                       : 
1272			;                                                                             : 
1272			;------------------------------------------------------------------------------ 
1272			free: 
1272			      push  BC 
1272			      push  DE 
1272			      push  IX 
1272			 
1272			      ld    A, H                    ; Exit if ptr is null 
1272			      or    L 
1272			      jp    Z, free_early_exit 
1272			 
1272			      ; Set up stack frame 
1272			      ex    DE, HL 
1272			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			      ld    IX, 0                   ; Use IX as a frame pointer 
1272			      add   IX, SP 
1272			 
1272			      ; The address in HL points to the start of the useable allocated space, 
1272			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1272			      ; address of the block itself. 
1272			      ex    DE, HL 
1272			      ld    DE, -4 
1272			      add   HL, DE 
1272			 
1272			      ; An allocated block must have a null next block pointer in it 
1272			      ld    A, (HL) 
1272			      inc   HL 
1272			      or    (HL) 
1272			      jp    NZ, free_done 
1272			 
1272			      dec   HL 
1272			 
1272			      ld    B, H                    ; Copy HL to BC 
1272			      ld    C, L 
1272			 
1272			      ; Loop through the free list to find the first block with an address 
1272			      ; higher than the block being freed 
1272			      ld    HL, free_list 
1272			 
1272			free_find_higher_block: 
1272			      ld    E, (HL)                 ; Load next ptr from free block 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      dec   HL 
1272			 
1272			      ld    (IX+0), E               ; Save ptr to next free block 
1272			      ld    (IX+1), D 
1272			      ld    (IX+2), L               ; Save ptr to prev free block 
1272			      ld    (IX+3), H 
1272			 
1272			      ld    A, B                    ; Check if DE is greater than BC 
1272			      cp    D                       ; Compare MSB first 
1272			      jr    Z, $+4                  ; MSB the same, compare LSB 
1272			      jr    NC, free_find_higher_block_skip 
1272			      ld    A, C 
1272			      cp    E                       ; Then compare LSB 
1272			      jr    C, free_found_higher_block 
1272			 
1272			free_find_higher_block_skip: 
1272			      ld    A, D                    ; Reached the end of the free list? 
1272			      or    E 
1272			      jp    Z, free_done 
1272			 
1272			      ex    DE, HL 
1272			 
1272			      jr    free_find_higher_block 
1272			 
1272			free_found_higher_block: 
1272			      ; Insert freed block between prev and next free blocks 
1272			      ld    (HL), C                 ; Point prev free block to freed block 
1272			      inc   HL 
1272			      ld    (HL), B 
1272			 
1272			      ld    H, B                    ; Point freed block at next free block 
1272			      ld    L, C 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Check if the freed block is adjacent to the next free block 
1272			      inc   HL                      ; Load size of freed block into HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ex    DE, HL 
1272			 
1272			      add   HL, BC                  ; Add addr of freed block and its size 
1272			 
1272			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1272			      ld    D, (IX+1) 
1272			 
1272			      or    A                       ; Clear the carry flag 
1272			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1272			      jr    NZ, free_check_adjacent_to_prev 
1272			 
1272			      ; Freed block is adjacent to next, merge into one bigger block 
1272			      ex    DE, HL                  ; Load next ptr from next block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  HL                      ; Save ptr to next block for later 
1272			 
1272			      ld    H, B                    ; Store ptr from next block into freed block 
1272			      ld    L, C 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   HL                      ; Restore ptr to next block 
1272			      inc   HL                      ; Load size of next block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  DE                      ; Save next block size for later 
1272			 
1272			      ld    H, B                    ; Load size of freed block into HL 
1272			      ld    L, C 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ex    DE, HL 
1272			 
1272			      pop   DE                      ; Restore size of next block 
1272			      add   HL, DE                  ; Add sizes of both blocks 
1272			      ex    DE, HL 
1272			 
1272			      ld    H, B                    ; Store new bigger size into freed block 
1272			      ld    L, C 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			free_check_adjacent_to_prev: 
1272			      ; Check if the freed block is adjacent to the prev free block 
1272			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1272			      ld    H, (IX+3) 
1272			 
1272			      inc   HL                      ; Size of prev free block into DE 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      add   HL, DE                  ; Add prev block addr and size 
1272			 
1272			      or    A                       ; Clear the carry flag 
1272			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1272			      jr    NZ, free_done 
1272			 
1272			      ; Freed block is adjacent to prev, merge into one bigger block 
1272			      ld    H, B                    ; Load next ptr from freed block into DE 
1272			      ld    L, C 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  HL                      ; Save freed block ptr for later 
1272			 
1272			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1272			      ld    H, (IX+3) 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   HL                      ; Restore freed block ptr 
1272			      inc   HL                      ; Load size of freed block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  DE                      ; Save freed block size for later 
1272			 
1272			      ld    L, (IX+2)               ; Load size of prev block into DE 
1272			      ld    H, (IX+3) 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      pop   HL                      ; Add sizes of both blocks 
1272			      add   HL, DE 
1272			      ex    DE, HL 
1272			 
1272			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1272			      ld    H, (IX+3) 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			free_done: 
1272			      ld    HL, 4                   ; Clean up stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			 
1272			free_early_exit: 
1272			      pop   IX 
1272			      pop   DE 
1272			      pop   BC 
1272			 
1272			      ret 
1272			 
1272			 
1272			;      .org 0x8000 
1272			; 
1272			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1272			 ;                 .dw   0 
1272			 
1272			endif 
1272			 
1272			 
1272			if MALLOC_4 
1272			 
1272			; My memory allocation code. Very very simple.... 
1272			; allocate space under 250 chars 
1272			 
1272			heap_init: 
1272				; init start of heap as zero 
1272				;  
1272			 
1272				ld hl, heap_start 
1272				ld a, 0 
1272				ld (hl), a      ; empty block 
1272				inc hl 
1272				ld a, 0 
1272				ld (hl), a      ; length of block 
1272				; write end of list 
1272				inc hl 
1272				ld a,(hl) 
1272				inc hl 
1272				ld a,(hl) 
1272				 
1272			 
1272				; init some malloc vars 
1272			 
1272				ld hl, 0 
1272				ld (free_list), hl       ; store last malloc location 
1272			 
1272				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1272				ld a, 0 
1272				ld (hl), a 
1272			 
1272			 
1272				ld hl, heap_start 
1272				;  
1272				  
1272				ret 
1272			 
1272			 
1272			;    free block marker 
1272			;    requested size  
1272			;    pointer to next block 
1272			;    .... 
1272			;    next block marker 
1272			 
1272			 
1272			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1272			; 
1272			 
1272			 
1272			malloc:  
1272				push de 
1272				push bc 
1272				push af 
1272			 
1272				; hl space required 
1272				 
1272				ld c, l    ; hold space   (TODO only a max of 255) 
1272			 
1272			;	inc c     ; TODO BUG need to fix memory leak on push str 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			 
1272			 
1272			 
1272				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1272			 
1272				ld a, (free_list+3) 
1272				cp 0 
1272				jr z, .contheap 
1272			 
1272				ld hl, (free_list)     ; get last alloc 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mrs" 
1272						CALLMONITOR 
1272					endif 
1272				jr .startalloc 
1272			 
1272			.contheap: 
1272				ld hl, heap_start 
1272			 
1272			.startalloc: 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mym" 
1272						CALLMONITOR 
1272					endif 
1272			.findblock: 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mmf" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272				ld a,(hl)  
1272				; if byte is zero then clear to use 
1272			 
1272				cp 0 
1272				jr z, .foundemptyblock 
1272			 
1272				; if byte is not clear 
1272				;     then byte is offset to next block 
1272			 
1272				inc hl 
1272				ld a, (hl) ; get size 
1272			.nextblock:	inc hl 
1272					ld e, (hl) 
1272					inc hl 
1272					ld d, (hl) 
1272					ex de, hl 
1272			;	inc hl  ; move past the store space 
1272			;	inc hl  ; move past zero index  
1272			 
1272				; TODO detect no more space 
1272			 
1272				push hl 
1272				ld de, heap_end 
1272				call cmp16 
1272				pop hl 
1272				jr nc, .nospace 
1272			 
1272				jr .findblock 
1272			 
1272			.nospace: ld hl, 0 
1272				jp .exit 
1272			 
1272			 
1272			.foundemptyblock:	 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mme" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			; TODO has block enough space if reusing??? 
1272			 
1272				;  
1272			 
1272			; see if this block has been previously used 
1272				inc hl 
1272				ld a, (hl) 
1272				dec hl 
1272				cp 0 
1272				jr z, .newblock 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "meR" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			; no reusing previously allocated block 
1272			 
1272			; is it smaller than previously used? 
1272				 
1272				inc hl    ; move to size 
1272				ld a, c 
1272				sub (hl)        ; we want c < (hl) 
1272				dec hl    ; move back to marker 
1272			        jr z, .findblock 
1272			 
1272				; update with the new size which should be lower 
1272			 
1272			        ;inc  hl   ; negate next move. move back to size  
1272			 
1272			.newblock: 
1272				; need to be at marker here 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "meN" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			 
1272				ld a, c 
1272			 
1272				ld (free_list+3), a	 ; flag resume from last malloc  
1272				ld (free_list), hl    ; save out last location 
1272			 
1272			 
1272				;inc a     ; space for length byte 
1272				ld (hl), a     ; save block in use marker 
1272			 
1272				inc hl   ; move to space marker 
1272				ld (hl), a    ; save new space 
1272			 
1272				inc hl   ; move to start of allocated area 
1272				 
1272			;	push hl     ; save where we are - 1  
1272			 
1272			;	inc hl  ; move past zero index  
1272				; skip space to set down new marker 
1272			 
1272				; provide some extra space for now 
1272			 
1272				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1272				inc a 
1272				inc a 
1272			 
1272				push hl   ; save where we are in the node block 
1272			 
1272				call addatohl 
1272			 
1272				; write linked list point 
1272			 
1272				pop de     ; get our node position 
1272				ex de, hl 
1272			 
1272				ld (hl), e 
1272				inc hl 
1272				ld (hl), d 
1272			 
1272				inc hl 
1272			 
1272				; now at start of allocated data so save pointer 
1272			 
1272				push hl 
1272			 
1272				; jump to position of next node and setup empty header in DE 
1272			 
1272				ex de, hl 
1272			 
1272			;	inc hl ; move past end of block 
1272			 
1272				ld a, 0 
1272				ld (hl), a   ; empty marker 
1272				inc hl 
1272				ld (hl), a   ; size 
1272				inc hl  
1272				ld (hl), a   ; ptr 
1272				inc hl 
1272				ld (hl), a   ; ptr 
1272			 
1272			 
1272				pop hl 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mmr" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			.exit: 
1272				pop af 
1272				pop bc 
1272				pop de  
1272				ret 
1272			 
1272			 
1272			 
1272			 
1272			free:  
1272				push hl 
1272				push af 
1272				; get address in hl 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "fre" 
1272						CALLMONITOR 
1272					endif 
1272				; data is at hl - move to block count 
1272				dec hl 
1272				dec hl    ; get past pointer 
1272				dec hl 
1272			 
1272				ld a, (hl)    ; need this for a validation check 
1272			 
1272				dec hl    ; move to block marker 
1272			 
1272				; now check that the block count and block marker are the same  
1272			        ; this checks that we are on a malloc node and not random memory 
1272			        ; OK a faint chance this could be a problem but rare - famous last words! 
1272			 
1272				ld c, a 
1272				ld a, (hl)    
1272			 
1272				cp c 
1272				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1272			 
1272				; yes good chance we are on a malloc node 
1272			 
1272				ld a, 0      
1272				ld (hl), a   ; mark as free 
1272			 
1272				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1272			 
1272			.freeignore:  
1272			 
1272				pop af 
1272				pop hl 
1272			 
1272				ret 
1272			 
1272			 
1272			 
1272			endif 
1272			 
1272			; eof 
# End of file firmware_memory.asm
1272			  
1272			; device C  
1272			if SOUND_ENABLE  
1272				include "firmware_sound.asm"  
1272			; Sound abstraction layer 
1272			 
1272			; support different sound chips through common interface 
1272			 
1272			SOUND_DEVICE_AY: equ 0 
1272			 
1272			SOUND_DEVICE: equ Device_A 
1272			 
1272			 
1272			 
1272			if SOUND_DEVICE_AY 
1272				include "firmware_sound_ay38910.asm" 
1272			else 
1272				include "firmware_sound_sn76489an.asm" 
1272			 
1272			; Device support for SN76489AN sound chip 
1272			 
1272			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1272			; http://danceswithferrets.org/geekblog/?p=93 
1272			; https://www.smspower.org/Development/SN76489 
1272			 
1272			; D0 [ 3] 
1272			; D1 [ 2] 
1272			; D2 [ 1] 
1272			; D3 [15] 
1272			; D4 [13] 
1272			; D5 [12] 
1272			; D6 [11] 
1272			; D7 [10] 
1272			; /WE [ 5] 
1272			; CLK [14] 
1272			; /OE [ 6] 
1272			; AUDIO [ 7] 
1272			; GND 8 
1272			; +5 16 
1272			; 
1272			 
1272			; Write sequence: 
1272			; CE low 
1272			; Data bus 
1272			; WE low then high 
1272			; 32 clock cycles / 8ns write time at 4mhz 
1272			; 
1272			; https://github.com/jblang/SN76489 
1272			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1272			; Tried: 
1272			; 
1272			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1272			; 
1272			; Connected WE to OR too 
1272			;  
1272			; That enabled the clock when required 
1272			; However still random bus corruption. Need further investigation 
1272			 
1272			 
1272			SOUND_LATCH: equ 10000000B 
1272			SOUND_DATA: equ 0B 
1272			SOUND_CH0:  equ 0B    ; Tone 
1272			SOUND_CH1: equ 0100000B        ; Tone 
1272			SOUND_CH2: equ 1000000B   ; Tone 
1272			SOUND_CH3: equ 1100000B    ; Noise 
1272			SOUND_VOL: equ 10000B 
1272			SOUND_TONE: equ 0B 
1272			 
1272			 
1272			sound_init: 
1272 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1274 cd 89 12			call note_send_byte 
1277 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1279 cd 89 12			call note_send_byte 
127c cd 31 0a			call delay250ms 
127f 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1281 cd 89 12			call note_send_byte 
1284 cd 31 0a			call delay250ms 
1287 c9				ret 
1288			 
1288			; Play a note 
1288			; h = note 
1288			; l = duration 
1288			; a = channel 
1288			 
1288			 
1288			;  frequ = clock / ( 2 x reg valu x 32 )  
1288			 
1288			note:  
1288				 
1288			 
1288 c9				ret 
1289			 
1289			note_send_byte: 
1289				; byte in a 
1289			 
1289				; we high 
1289 d3 40			out (Device_B), a 
128b			;	ld a, 1 
128b			;	call aDelayInMS 
128b 00				nop  
128c 00				nop  
128d 00				nop  
128e 00				nop  
128f				; we low 
128f d3 40			out (Device_B), a 
1291			;	ld a, 1 
1291			;	call aDelayInMS 
1291 00				nop  
1292 00				nop  
1293 00				nop  
1294 00				nop  
1295				; we high 
1295 d3 40			out (Device_B), a 
1297			;	ld a, 1 
1297			;	call aDelayInMS 
1297 00				nop  
1298 00				nop  
1299 00				nop  
129a 00				nop  
129b			 
129b			 
129b c9				ret 
129c			 
129c			;void SilenceAllChannels() 
129c			;{ 
129c			;  SendByte(0x9f); 
129c			;  SendByte(0xbf); 
129c			;  SendByte(0xdf); 
129c			;  SendByte(0xff); 
129c			;} 
129c			 
129c			 
129c			; eof 
129c			 
# End of file firmware_sound_sn76489an.asm
129c			endif 
129c			 
129c			 
129c			; Abstraction entry points 
129c			 
129c			; init  
129c			 
129c			; sound_init in specific hardware files 
129c			 
129c			; Play a note 
129c			; h = note 
129c			; l = duration 
129c			; a = channel 
129c			 
129c			;note:     
129c			;	ret 
129c			 
129c			 
129c			 
129c			 
129c			; eof 
129c			 
# End of file firmware_sound.asm
129c			endif  
129c			  
129c			include "firmware_diags.asm"  
129c			; Hardware diags menu 
129c			 
129c			 
129c .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12bd .. 00		hd_menu2:   db "        2: Editor",0   
12cf			;hd_menu2:   db "        2: Editor       6: BASIC",0   
12cf .. 00		hd_menu3:   db "        3: Storage",0 
12e2 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
12f3 .. 00		hd_don:     db "ON",0 
12f6 .. 00		hd_doff:     db "OFF",0 
12fa			 
12fa			 
12fa			 
12fa			hardware_diags:       
12fa			 
12fa			.diagmenu: 
12fa cd b9 0a			call clear_display 
12fd 3e 00			ld a, display_row_1 
12ff 11 9c 12			ld de, hd_menu1 
1302 cd cc 0a			call str_at_display 
1305			 
1305 3e 28			ld a, display_row_2 
1307 11 bd 12			ld de, hd_menu2 
130a cd cc 0a			call str_at_display 
130d			 
130d 3e 50			ld a, display_row_3 
130f 11 cf 12			ld de, hd_menu3 
1312 cd cc 0a			call str_at_display 
1315			 
1315 3e 78			ld a,  display_row_4 
1317 11 e2 12			ld de, hd_menu4 
131a cd cc 0a			call str_at_display 
131d			 
131d				; display debug state 
131d			 
131d 11 f3 12			ld de, hd_don 
1320 3a 31 ee			ld a, (os_view_disable) 
1323 fe 00			cp 0 
1325 28 03			jr z, .distog 
1327 11 f6 12			ld de, hd_doff 
132a 3e 89		.distog: ld a, display_row_4+17 
132c cd cc 0a			call str_at_display 
132f			 
132f cd dc 0a			call update_display 
1332			 
1332 cd e8 64			call cin_wait 
1335			 
1335			 
1335			 
1335 fe 34			cp '4' 
1337 20 0f			jr nz, .diagn1 
1339			 
1339				; debug toggle 
1339			 
1339 3a 31 ee			ld a, (os_view_disable) 
133c 06 2a			ld b, '*' 
133e fe 00			cp 0 
1340 28 02			jr z, .debtog 
1342 06 00			ld b, 0 
1344			.debtog:	 
1344 78				ld a,b 
1345 32 31 ee			ld (os_view_disable),a 
1348			 
1348 fe 30		.diagn1: cp '0' 
134a c8				 ret z 
134b			 
134b			;	cp '1' 
134b			;       jp z, matrix	 
134b			;   TODO keyboard matrix test 
134b			 
134b fe 32			cp '2' 
134d ca 54 13			jp z, .diagedit 
1350			 
1350			;if ENABLE_BASIC 
1350			;	cp '6' 
1350			;	jp z, basic 
1350			;endif 
1350			  
1350 c3 fa 12			jp .diagmenu 
1353			 
1353			 
1353 c9				ret 
1354			 
1354			; debug editor 
1354			 
1354			.diagedit: 
1354			 
1354 21 32 ee			ld hl, scratch 
1357			;	ld bc, 250 
1357			;	ldir 
1357				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1357 3e 00			ld a, 0 
1359 77				ld (hl), a 
135a 23				inc hl 
135b 77				ld (hl), a 
135c 23				inc hl 
135d 77				ld (hl), a 
135e			 
135e cd b9 0a		        call clear_display 
1361 cd dc 0a			call update_display 
1364 3e 01			ld a, 1 
1366 32 7d fb			ld (hardware_diag), a 
1369			.diloop: 
1369 3e 00			ld a, display_row_1 
136b 0e 00			ld c, 0 
136d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
136f 1e 28			ld e, 40 
1371			 
1371 21 32 ee			ld hl, scratch	 
1374 cd 3f 0c			call input_str 
1377			 
1377 3e 28			ld a, display_row_2 
1379 11 32 ee			ld de, scratch 
137c cd cc 0a			call str_at_display 
137f cd dc 0a			call update_display 
1382			 
1382 c3 69 13			jp .diloop 
1385			 
1385			 
1385			; pass word in hl 
1385			; a has display location 
1385			display_word_at: 
1385 f5				push af 
1386 e5				push hl 
1387 7c				ld a,h 
1388 21 37 f1			ld hl, os_word_scratch 
138b cd 13 0f			call hexout 
138e e1				pop hl 
138f 7d				ld a,l 
1390 21 39 f1			ld hl, os_word_scratch+2 
1393 cd 13 0f			call hexout 
1396 21 3b f1			ld hl, os_word_scratch+4 
1399 3e 00			ld a,0 
139b 77				ld (hl),a 
139c 11 37 f1			ld de,os_word_scratch 
139f f1				pop af 
13a0 cd cc 0a				call str_at_display 
13a3 c9				ret 
13a4			 
13a4			display_ptr_state: 
13a4			 
13a4				; to restore afterwards 
13a4			 
13a4 d5				push de 
13a5 c5				push bc 
13a6 e5				push hl 
13a7 f5				push af 
13a8			 
13a8				; for use in here 
13a8			 
13a8			;	push bc 
13a8			;	push de 
13a8			;	push hl 
13a8			;	push af 
13a8			 
13a8 cd b9 0a			call clear_display 
13ab			 
13ab 11 7e 15			ld de, .ptrstate 
13ae 3e 00			ld a, display_row_1 
13b0 cd cc 0a			call str_at_display 
13b3			 
13b3				; display debug step 
13b3			 
13b3			 
13b3 11 77 fb			ld de, debug_mark 
13b6 3e 26			ld a, display_row_1+display_cols-2 
13b8 cd cc 0a			call str_at_display 
13bb			 
13bb				; display a 
13bb 11 88 15			ld de, .ptrcliptr 
13be 3e 28			ld a, display_row_2 
13c0 cd cc 0a			call str_at_display 
13c3			 
13c3 f1				pop af 
13c4 2a 3d f8			ld hl,(cli_ptr) 
13c7 3e 30			ld a, display_row_2+8 
13c9 cd 85 13			call display_word_at 
13cc			 
13cc			 
13cc				; display hl 
13cc			 
13cc			 
13cc 11 90 15			ld de, .ptrclioptr 
13cf 3e 32			ld a, display_row_2+10 
13d1 cd cc 0a			call str_at_display 
13d4			; 
13d4			;	pop hl 
13d4 3e 35			ld a, display_row_2+13 
13d6 2a 3b f8			ld hl,(cli_origptr) 
13d9 cd 85 13			call display_word_at 
13dc			; 
13dc			;	 
13dc			;	; display de 
13dc			 
13dc			;	ld de, .regstatede 
13dc			;	ld a, display_row_3 
13dc			;	call str_at_display 
13dc			 
13dc			;	pop de 
13dc			;	ld h,d 
13dc			;	ld l, e 
13dc			;	ld a, display_row_3+3 
13dc			;	call display_word_at 
13dc			 
13dc			 
13dc				; display bc 
13dc			 
13dc			;	ld de, .regstatebc 
13dc			;	ld a, display_row_3+10 
13dc			;	call str_at_display 
13dc			 
13dc			;	pop bc 
13dc			;	ld h,b 
13dc			;	ld l, c 
13dc			;	ld a, display_row_3+13 
13dc			;	call display_word_at 
13dc			 
13dc			 
13dc				; display dsp 
13dc			 
13dc			;	ld de, .regstatedsp 
13dc			;	ld a, display_row_4 
13dc			;	call str_at_display 
13dc			 
13dc				 
13dc			;	ld hl,(cli_data_sp) 
13dc			;	ld a, display_row_4+4 
13dc			;	call display_word_at 
13dc			 
13dc				; display rsp 
13dc			 
13dc 11 bf 15			ld de, .regstatersp 
13df 3e 82			ld a, display_row_4+10 
13e1 cd cc 0a			call str_at_display 
13e4			 
13e4				 
13e4 2a 23 f8			ld hl,(cli_ret_sp) 
13e7 3e 86			ld a, display_row_4+14 
13e9 cd 85 13			call display_word_at 
13ec			 
13ec cd dc 0a			call update_display 
13ef			 
13ef cd 3d 0a			call delay1s 
13f2 cd 3d 0a			call delay1s 
13f5 cd 3d 0a			call delay1s 
13f8			 
13f8			 
13f8 cd 05 19			call next_page_prompt 
13fb			 
13fb				; restore  
13fb			 
13fb f1				pop af 
13fc e1				pop hl 
13fd c1				pop bc 
13fe d1				pop de 
13ff c9				ret 
1400			 
1400			break_point_state: 
1400 f5				push af 
1401			 
1401				; see if disabled 
1401			 
1401 3a 31 ee			ld a, (os_view_disable) 
1404 fe 2a			cp '*' 
1406 20 02			jr nz, .bpsgo 
1408 f1				pop af 
1409 c9				ret 
140a			 
140a			.bpsgo: 
140a f1				pop af 
140b f5				push af 
140c 22 2d ee			ld (os_view_hl), hl 
140f ed 53 2b ee		ld (os_view_de), de 
1413 ed 43 29 ee		ld (os_view_bc), bc 
1417 e5				push hl 
1418 6f				ld l, a 
1419 26 00			ld h, 0 
141b 22 2f ee			ld (os_view_af),hl 
141e			 
141e 21 bd fa				ld hl, display_fb0 
1421 22 d8 f8				ld (display_fb_active), hl 
1424 e1				pop hl	 
1425			 
1425 3e 31			ld a, '1' 
1427 fe 2a		.bps1:  cp '*' 
1429 20 03			jr nz, .bps1b 
142b 32 31 ee			ld (os_view_disable),a 
142e fe 31		.bps1b:  cp '1' 
1430 20 14			jr nz, .bps2 
1432			 
1432				; display reg 
1432			 
1432				 
1432			 
1432 3a 2f ee			ld a, (os_view_af) 
1435 2a 2d ee			ld hl, (os_view_hl) 
1438 ed 5b 2b ee		ld de, (os_view_de) 
143c ed 4b 29 ee		ld bc, (os_view_bc) 
1440 cd da 14			call display_reg_state 
1443 c3 c6 14			jp .bpschk 
1446			 
1446 fe 32		.bps2:  cp '2' 
1448 20 08			jr nz, .bps3 
144a				 
144a				; display hl 
144a 2a 2d ee			ld hl, (os_view_hl) 
144d cd c4 15			call display_dump_at_hl 
1450			 
1450 18 74			jr .bpschk 
1452			 
1452 fe 33		.bps3:  cp '3' 
1454 20 08			jr nz, .bps4 
1456			 
1456			        ; display de 
1456 2a 2b ee			ld hl, (os_view_de) 
1459 cd c4 15			call display_dump_at_hl 
145c			 
145c 18 68			jr .bpschk 
145e fe 34		.bps4:  cp '4' 
1460 20 08			jr nz, .bps5 
1462			 
1462			        ; display bc 
1462 2a 29 ee			ld hl, (os_view_bc) 
1465 cd c4 15			call display_dump_at_hl 
1468			 
1468 18 5c			jr .bpschk 
146a fe 35		.bps5:  cp '5' 
146c 20 08		        jr nz, .bps7 
146e			 
146e				; display cur ptr 
146e 2a 3d f8			ld hl, (cli_ptr) 
1471 cd c4 15			call display_dump_at_hl 
1474			 
1474 18 50			jr .bpschk 
1476 fe 36		.bps7:  cp '6' 
1478 20 08			jr nz, .bps8b 
147a				 
147a				; display cur orig ptr 
147a 2a 3b f8			ld hl, (cli_origptr) 
147d cd c4 15			call display_dump_at_hl 
1480 18 44			jr .bpschk 
1482 fe 37		.bps8b:  cp '7' 
1484 20 08			jr nz, .bps9 
1486				 
1486				; display dsp 
1486 2a 1f f8			ld hl, (cli_data_sp) 
1489 cd c4 15			call display_dump_at_hl 
148c			 
148c 18 38			jr .bpschk 
148e fe 39		.bps9:  cp '9' 
1490 20 05			jr nz, .bps8c 
1492				 
1492				; display SP 
1492			;	ld hl, sp 
1492 cd c4 15			call display_dump_at_hl 
1495			 
1495 18 2f			jr .bpschk 
1497 fe 38		.bps8c:  cp '8' 
1499 20 08			jr nz, .bps8d 
149b				 
149b				; display rsp 
149b 2a 23 f8			ld hl, (cli_ret_sp) 
149e cd c4 15			call display_dump_at_hl 
14a1			 
14a1 18 23			jr .bpschk 
14a3 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14a5 20 05			jr nz, .bps8 
14a7 cd fb 16			call monitor 
14aa			 
14aa 18 1a			jr .bpschk 
14ac fe 30		.bps8:  cp '0' 
14ae 20 16			jr nz, .bpschk 
14b0			 
14b0 21 1c fa				ld hl, display_fb1 
14b3 22 d8 f8				ld (display_fb_active), hl 
14b6 cd dc 0a				call update_display 
14b9			 
14b9				;ld a, (os_view_af) 
14b9 2a 2d ee			ld hl, (os_view_hl) 
14bc ed 5b 2b ee		ld de, (os_view_de) 
14c0 ed 4b 29 ee		ld bc, (os_view_bc) 
14c4 f1				pop af 
14c5 c9				ret 
14c6			 
14c6			.bpschk:   
14c6 cd 3d 0a			call delay1s 
14c9 3e 9f		ld a,display_row_4 + display_cols - 1 
14cb 11 03 19		        ld de, endprg 
14ce cd cc 0a			call str_at_display 
14d1 cd dc 0a			call update_display 
14d4 cd e8 64			call cin_wait 
14d7			 
14d7 c3 27 14			jp .bps1 
14da			 
14da			 
14da			display_reg_state: 
14da			 
14da				; to restore afterwards 
14da			 
14da d5				push de 
14db c5				push bc 
14dc e5				push hl 
14dd f5				push af 
14de			 
14de				; for use in here 
14de			 
14de c5				push bc 
14df d5				push de 
14e0 e5				push hl 
14e1 f5				push af 
14e2			 
14e2 cd b9 0a			call clear_display 
14e5			 
14e5 11 9a 15			ld de, .regstate 
14e8 3e 00			ld a, display_row_1 
14ea cd cc 0a			call str_at_display 
14ed			 
14ed				; display debug step 
14ed			 
14ed			 
14ed 11 77 fb			ld de, debug_mark 
14f0 3e 25			ld a, display_row_1+display_cols-3 
14f2 cd cc 0a			call str_at_display 
14f5			 
14f5				; display a 
14f5 11 b6 15			ld de, .regstatea 
14f8 3e 28			ld a, display_row_2 
14fa cd cc 0a			call str_at_display 
14fd			 
14fd e1				pop hl 
14fe			;	ld h,0 
14fe			;	ld l, a 
14fe 3e 2b			ld a, display_row_2+3 
1500 cd 85 13			call display_word_at 
1503			 
1503			 
1503				; display hl 
1503			 
1503			 
1503 11 aa 15			ld de, .regstatehl 
1506 3e 32			ld a, display_row_2+10 
1508 cd cc 0a			call str_at_display 
150b			 
150b e1				pop hl 
150c 3e 35			ld a, display_row_2+13 
150e cd 85 13			call display_word_at 
1511			 
1511				 
1511				; display de 
1511			 
1511 11 ae 15			ld de, .regstatede 
1514 3e 50			ld a, display_row_3 
1516 cd cc 0a			call str_at_display 
1519			 
1519 e1				pop hl 
151a			;	ld h,d 
151a			;	ld l, e 
151a 3e 53			ld a, display_row_3+3 
151c cd 85 13			call display_word_at 
151f			 
151f			 
151f				; display bc 
151f			 
151f 11 b2 15			ld de, .regstatebc 
1522 3e 5a			ld a, display_row_3+10 
1524 cd cc 0a			call str_at_display 
1527			 
1527 e1				pop hl 
1528			;	ld h,b 
1528			;	ld l, c 
1528 3e 5d			ld a, display_row_3+13 
152a cd 85 13			call display_word_at 
152d			 
152d			 
152d				; display dsp 
152d			 
152d 11 ba 15			ld de, .regstatedsp 
1530 3e 78			ld a, display_row_4 
1532 cd cc 0a			call str_at_display 
1535			 
1535				 
1535 2a 1f f8			ld hl,(cli_data_sp) 
1538 3e 7c			ld a, display_row_4+4 
153a cd 85 13			call display_word_at 
153d			 
153d				; display rsp 
153d			 
153d 11 bf 15			ld de, .regstatersp 
1540 3e 82			ld a, display_row_4+10 
1542 cd cc 0a			call str_at_display 
1545			 
1545				 
1545 2a 23 f8			ld hl,(cli_ret_sp) 
1548 3e 86			ld a, display_row_4+14 
154a cd 85 13			call display_word_at 
154d			 
154d cd dc 0a			call update_display 
1550			 
1550			;	call delay1s 
1550			;	call delay1s 
1550			;	call delay1s 
1550			 
1550			 
1550			;	call next_page_prompt 
1550			 
1550				; restore  
1550			 
1550 f1				pop af 
1551 e1				pop hl 
1552 c1				pop bc 
1553 d1				pop de 
1554 c9				ret 
1555			 
1555 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1569 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
157e .. 00		.ptrstate:	db "Ptr State",0 
1588 .. 00		.ptrcliptr:     db "cli_ptr",0 
1590 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
159a .. 00		.regstate:	db "Reg State (1/0)",0 
15aa .. 00		.regstatehl:	db "HL:",0 
15ae .. 00		.regstatede:	db "DE:",0 
15b2 .. 00		.regstatebc:	db "BC:",0 
15b6 .. 00		.regstatea:	db "A :",0 
15ba .. 00		.regstatedsp:	db "DSP:",0 
15bf .. 00		.regstatersp:	db "RSP:",0 
15c4			 
15c4			display_dump_at_hl: 
15c4 e5				push hl 
15c5 d5				push de 
15c6 c5				push bc 
15c7 f5				push af 
15c8			 
15c8 22 55 f1			ld (os_cur_ptr),hl	 
15cb cd b9 0a			call clear_display 
15ce cd 0d 18			call dumpcont 
15d1			;	call delay1s 
15d1			;	call next_page_prompt 
15d1			 
15d1			 
15d1 f1				pop af 
15d2 c1				pop bc 
15d3 d1				pop de 
15d4 e1				pop hl 
15d5 c9				ret 
15d6			 
15d6			;if ENABLE_BASIC 
15d6			;	include "nascombasic.asm" 
15d6			;	basic: 
15d6			;	include "forth/FORTH.ASM" 
15d6			;endif 
15d6			 
15d6			; eof 
15d6			 
15d6			 
# End of file firmware_diags.asm
15d6			  
15d6			  
15d6			  
15d6			  
15d6			; eof  
15d6			  
# End of file firmware.asm
15d6			 
15d6			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15d6			;if BASE_KEV  
15d6			;baseram: equ 08000h 
15d6			;endif 
15d6			 
15d6			;if BASE_SC114 
15d6			;baseram:     equ    endofcode 
15d6			;endif 
15d6			 
15d6			 
15d6			; start system 
15d6			 
15d6			coldstart: 
15d6				; set sp 
15d6				; di/ei 
15d6			 
15d6 f3				di 
15d7 31 fd ff			ld sp, tos 
15da			;	ei 
15da			 
15da			 
15da				; disable breakpoint by default 
15da			 
15da 3e 2a			ld a,'*' 
15dc 32 31 ee			ld (os_view_disable),a 
15df			 
15df				; init hardware 
15df			 
15df				; init keyboard and screen hardware 
15df			 
15df cd 03 00			call hardware_init 
15e2			 
15e2			 
15e2				; detect if any keys are held down to enable breakpoints at start up 
15e2			 
15e2 cd f9 64			call cin  
15e5 fe 00			cp 0 
15e7 28 03			jr z, .nokeys 
15e9			 
15e9 cd fa 12			call hardware_diags 
15ec			 
15ec			;	ld de, .bpen 
15ec			;	ld a, display_row_4 
15ec			;	call str_at_display 
15ec			;	call update_display 
15ec			; 
15ec			;	ld a,0 
15ec			;	ld (os_view_disable),a 
15ec			; 
15ec			;.bpwait: 
15ec			;	call cin 
15ec			;	cp 0 
15ec			;	jr z, .bpwait 
15ec			;	jr .nokeys 
15ec			; 
15ec			; 
15ec			;.bpen:  db "Break points enabled!",0 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			.nokeys: 
15ec			 
15ec			 
15ec				 
15ec			 
15ec			;jp  testkey 
15ec			 
15ec			;call storage_get_block_0 
15ec			; 
15ec			;ld hl, 0 
15ec			;ld de, store_page 
15ec			;call storage_read_block 
15ec			 
15ec				 
15ec			;ld hl, 10 
15ec			;ld de, store_page 
15ec			;call storage_read_block 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			;stop:	nop 
15ec			;	jp stop 
15ec			 
15ec			 
15ec			 
15ec			main: 
15ec cd b9 0a			call clear_display 
15ef cd dc 0a			call update_display 
15f2			 
15f2			 
15f2			 
15f2			;	call testlcd 
15f2			 
15f2			 
15f2			 
15f2 cd 53 1b			call forth_init 
15f5			 
15f5			 
15f5			warmstart: 
15f5 cd 29 1b			call forth_warmstart 
15f8			 
15f8				; run startup word load 
15f8			        ; TODO prevent this running at warmstart after crash  
15f8			 
15f8				if STARTUP_ENABLE 
15f8 cd bf 5e				call forth_startup 
15fb				endif 
15fb			 
15fb				; show free memory after boot 
15fb 11 95 16			ld de, freeram 
15fe 3e 00			ld a, display_row_1 
1600 cd cc 0a			call str_at_display 
1603			 
1603			; Or use heap_size word???? 
1603 21 26 ee			ld hl, heap_end 
1606 11 0e 80			ld de, heap_start 
1609 ed 52			sbc hl, de 
160b e5				push hl 
160c 7c				ld a,h	         	 
160d 21 37 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1610 cd 13 0f			call hexout 
1613 e1			   	pop hl 
1614			 
1614 7d				ld a,l 
1615 21 39 f1			ld hl, os_word_scratch+2 
1618 cd 13 0f			call hexout 
161b 21 3b f1			ld hl, os_word_scratch+4 
161e 3e 00			ld a, 0 
1620 77				ld (hl),a 
1621 11 37 f1			ld de, os_word_scratch 
1624 3e 0d			ld a, display_row_1 + 13 
1626 cd cc 0a			call str_at_display 
1629 cd dc 0a			call update_display 
162c			 
162c			 
162c				;call demo 
162c			 
162c			 
162c				; init scratch input area for cli commands 
162c			 
162c 21 59 f1			ld hl, os_cli_cmd 
162f 3e 00			ld a,0 
1631 77				ld (hl),a 
1632 23				inc hl 
1633 77				ld (hl),a 
1634			 
1634 3e 00			ld a,0 
1636 32 58 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1639			 
1639 32 55 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
163c 32 56 f1			ld (os_cur_ptr+1),a	 
163f			 
163f 32 37 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1642 32 38 f1			ld (os_word_scratch+1),a	 
1645				 
1645			 
1645				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1645 21 59 f1			ld hl, os_cli_cmd 
1648			 
1648 3e 00			ld a, 0		 ; init cli input 
164a 77				ld (hl), a 
164b 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
164d			cli: 
164d				; show cli prompt 
164d				;push af 
164d				;ld a, 0 
164d				;ld de, prompt 
164d				;call str_at_display 
164d			 
164d				;call update_display 
164d				;pop af 
164d				;inc a 
164d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
164d 0e 00			ld c, 0 
164f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1651 1e 28			ld e, 40 
1653			 
1653 21 59 f1			ld hl, os_cli_cmd 
1656			 
1656				STACKFRAME OFF $fefe $9f9f 
1656				if DEBUG_STACK_IMB 
1656					if OFF 
1656						exx 
1656						ld de, $fefe 
1656						ld a, d 
1656						ld hl, curframe 
1656						call hexout 
1656						ld a, e 
1656						ld hl, curframe+2 
1656						call hexout 
1656						ld hl, $fefe 
1656						push hl 
1656						ld hl, $9f9f 
1656						push hl 
1656						exx 
1656					endif 
1656				endif 
1656			endm 
# End of macro STACKFRAME
1656			 
1656 cd 3f 0c			call input_str 
1659			 
1659				STACKFRAMECHK OFF $fefe $9f9f 
1659				if DEBUG_STACK_IMB 
1659					if OFF 
1659						exx 
1659						ld hl, $9f9f 
1659						pop de   ; $9f9f 
1659						call cmp16 
1659						jr nz, .spnosame 
1659						ld hl, $fefe 
1659						pop de   ; $fefe 
1659						call cmp16 
1659						jr z, .spfrsame 
1659						.spnosame: call showsperror 
1659						.spfrsame: nop 
1659						exx 
1659					endif 
1659				endif 
1659			endm 
# End of macro STACKFRAMECHK
1659			 
1659				; copy input to last command 
1659			 
1659 21 59 f1			ld hl, os_cli_cmd 
165c 11 58 f2			ld de, os_last_cmd 
165f 01 ff 00			ld bc, 255 
1662 ed b0			ldir 
1664				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1664			;	call strcpy 
1664			;	ld a, 0 
1664			;	ld (hl), a 
1664			;	inc hl 
1664			;	ld (hl), a 
1664			;	inc hl 
1664			;	ld (hl), a 
1664			 
1664				; switch frame buffer to program  
1664			 
1664 21 1c fa				ld hl, display_fb1 
1667 22 d8 f8				ld (display_fb_active), hl 
166a			 
166a			;	nop 
166a				STACKFRAME ON $fbfe $8f9f 
166a				if DEBUG_STACK_IMB 
166a					if ON 
166a						exx 
166a						ld de, $fbfe 
166a						ld a, d 
166a						ld hl, curframe 
166a						call hexout 
166a						ld a, e 
166a						ld hl, curframe+2 
166a						call hexout 
166a						ld hl, $fbfe 
166a						push hl 
166a						ld hl, $8f9f 
166a						push hl 
166a						exx 
166a					endif 
166a				endif 
166a			endm 
# End of macro STACKFRAME
166a				; first time into the parser so pass over the current scratch pad 
166a 21 59 f1			ld hl,os_cli_cmd 
166d				; tokenise the entered statement(s) in HL 
166d cd cc 1b			call forthparse 
1670			        ; exec forth statements in top of return stack 
1670 cd 0c 1c			call forthexec 
1673				;call forthexec_cleanup 
1673			;	call parsenext 
1673			 
1673				STACKFRAMECHK ON $fbfe $8f9f 
1673				if DEBUG_STACK_IMB 
1673					if ON 
1673						exx 
1673						ld hl, $8f9f 
1673						pop de   ; $8f9f 
1673						call cmp16 
1673						jr nz, .spnosame 
1673						ld hl, $fbfe 
1673						pop de   ; $fbfe 
1673						call cmp16 
1673						jr z, .spfrsame 
1673						.spnosame: call showsperror 
1673						.spfrsame: nop 
1673						exx 
1673					endif 
1673				endif 
1673			endm 
# End of macro STACKFRAMECHK
1673				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1673			 
1673 3e 78			ld a, display_row_4 
1675 11 a7 16			ld de, endprog 
1678			 
1678 cd dc 0a			call update_display		 
167b			 
167b cd 05 19			call next_page_prompt 
167e			 
167e				; switch frame buffer to cli 
167e			 
167e 21 bd fa				ld hl, display_fb0 
1681 22 d8 f8				ld (display_fb_active), hl 
1684			 
1684			 
1684 cd b9 0a		        call clear_display 
1687 cd dc 0a			call update_display		 
168a			 
168a 21 59 f1			ld hl, os_cli_cmd 
168d			 
168d 3e 00			ld a, 0		 ; init cli input 
168f 77				ld (hl), a 
1690			 
1690				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1690			 
1690				; now on last line 
1690			 
1690				; TODO scroll screen up 
1690			 
1690				; TODO instead just clear screen and place at top of screen 
1690			 
1690			;	ld a, 0 
1690			;	ld (f_cursor_ptr),a 
1690			 
1690				;call clear_display 
1690				;call update_display 
1690			 
1690				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1690 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1692 c3 4d 16			jp cli 
1695			 
1695 .. 00		freeram: db "Free bytes: $",0 
16a3 ..			asc: db "1A2F" 
16a7 .. 00		endprog: db "End prog...",0 
16b3			 
16b3			testenter2:   
16b3 21 64 ee			ld hl,scratch+50 
16b6 22 55 f1			ld (os_cur_ptr),hl 
16b9 c3 4d 16			jp cli 
16bc			 
16bc			testenter:  
16bc			 
16bc 21 a3 16			ld hl,asc 
16bf			;	ld a,(hl) 
16bf			;	call nibble2val 
16bf cd 69 0f			call get_byte 
16c2			 
16c2			 
16c2			;	ld a,(hl) 
16c2			;	call atohex 
16c2			 
16c2			;	call fourehexhl 
16c2 32 64 ee			ld (scratch+50),a 
16c5			 
16c5			 
16c5			 
16c5 21 a5 16			ld hl,asc+2 
16c8			;	ld a, (hl) 
16c8			;	call nibble2val 
16c8 cd 69 0f			call get_byte 
16cb			 
16cb			;	call fourehexhl 
16cb 32 66 ee			ld (scratch+52),a 
16ce				 
16ce 21 64 ee			ld hl,scratch+50 
16d1 22 55 f1			ld (os_cur_ptr),hl 
16d4 c3 4d 16			jp cli 
16d7			 
16d7			enter:	 
16d7 3a 36 ee			ld a,(scratch+4) 
16da fe 00			cp 0 
16dc 28 0c			jr z, .entercont 
16de				; no, not a null term line so has an address to work out.... 
16de			 
16de 21 34 ee			ld hl,scratch+2 
16e1 cd c9 0f			call get_word_hl 
16e4			 
16e4 22 55 f1			ld (os_cur_ptr),hl	 
16e7 c3 4d 16			jp cli 
16ea			 
16ea			 
16ea			.entercont:  
16ea			 
16ea 21 34 ee			ld hl, scratch+2 
16ed cd 69 0f			call get_byte 
16f0			 
16f0 2a 55 f1		   	ld hl,(os_cur_ptr) 
16f3 77					ld (hl),a 
16f4 23					inc hl 
16f5 22 55 f1				ld (os_cur_ptr),hl 
16f8				 
16f8			; get byte  
16f8			 
16f8			 
16f8 c3 4d 16			jp cli 
16fb			 
16fb			 
16fb			; basic monitor support 
16fb			 
16fb			monitor: 
16fb				;  
16fb cd b9 0a			call clear_display 
16fe 3e 00			ld a, 0 
1700 11 48 17			ld de, .monprompt 
1703 cd cc 0a			call str_at_display 
1706 cd dc 0a			call update_display 
1709			 
1709				; get a monitor command 
1709			 
1709 0e 00			ld c, 0     ; entry at top left 
170b 16 64			ld d, 100   ; max buffer size 
170d 1e 0f			ld e, 15    ; input scroll area 
170f 3e 00			ld a, 0     ; init string 
1711 21 30 f0			ld hl, os_input 
1714 77				ld (hl), a 
1715 23				inc hl 
1716 77				ld (hl), a 
1717 21 30 f0			ld hl, os_input 
171a 3e 01			ld a, 1     ; init string 
171c cd 3f 0c			call input_str 
171f			 
171f cd b9 0a		        call clear_display 
1722 cd dc 0a			call update_display		 
1725			 
1725 3a 30 f0			ld a, (os_input) 
1728 cd 67 10			call toUpper 
172b fe 48		        cp 'H' 
172d 28 6f		        jr z, .monhelp 
172f fe 44			cp 'D'		; dump 
1731 ca bf 17			jp z, .mondump	 
1734 fe 43			cp 'C'		; dump 
1736 ca d9 17			jp z, .moncdump	 
1739 fe 4d			cp 'M'		; dump 
173b ca 4a 17			jp z, .moneditstart 
173e fe 55			cp 'U'		; dump 
1740 28 14			jr z, .monedit	 
1742 fe 51			cp 'Q'		; dump 
1744 c8				ret z	 
1745			 
1745			 
1745				; TODO "S" to access symbol by name and not need the address 
1745				; TODO "F" to find a string in memory 
1745			 
1745 c3 fb 16			jp monitor 
1748			 
1748 .. 00		.monprompt: db ">", 0 
174a			 
174a			.moneditstart: 
174a				; get starting address 
174a			 
174a 21 32 f0			ld hl,os_input+2 
174d cd c9 0f			call get_word_hl 
1750			 
1750 22 55 f1			ld (os_cur_ptr),hl	 
1753			 
1753 c3 fb 16			jp monitor 
1756			 
1756			.monedit: 
1756				; get byte to load 
1756			 
1756 21 32 f0			ld hl,os_input+2 
1759 cd 69 0f			call get_byte 
175c			 
175c				; get address to update 
175c 2a 55 f1			ld hl, (os_cur_ptr) 
175f			 
175f				; update byte 
175f			 
175f 77				ld (hl), a 
1760			 
1760				; move to next address and save it 
1760			 
1760 23				inc hl 
1761 22 55 f1			ld (os_cur_ptr),hl	 
1764			 
1764 c3 fb 16			jp monitor 
1767			 
1767			 
1767 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
177b .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1797 .. 00		.monhelptext3:  db "Q-Quit",0 
179e			        
179e			.monhelp: 
179e 3e 00			ld a, display_row_1 
17a0 11 67 17		        ld de, .monhelptext1 
17a3			 
17a3 cd cc 0a			call str_at_display 
17a6 3e 28			ld a, display_row_2 
17a8 11 7b 17		        ld de, .monhelptext2 
17ab					 
17ab cd cc 0a			call str_at_display 
17ae 3e 50			ld a, display_row_3 
17b0 11 97 17		        ld de, .monhelptext3 
17b3					 
17b3 cd cc 0a			call str_at_display 
17b6 cd dc 0a			call update_display		 
17b9			 
17b9 cd 05 19			call next_page_prompt 
17bc c3 fb 16			jp monitor 
17bf			 
17bf			.mondump:    
17bf 21 32 f0			ld hl,os_input+2 
17c2 cd c9 0f			call get_word_hl 
17c5			 
17c5 22 55 f1			ld (os_cur_ptr),hl	 
17c8 cd 0d 18			call dumpcont 
17cb 3e 78			ld a, display_row_4 
17cd 11 a7 16			ld de, endprog 
17d0			 
17d0 cd dc 0a			call update_display		 
17d3			 
17d3 cd 05 19			call next_page_prompt 
17d6 c3 fb 16			jp monitor 
17d9			.moncdump: 
17d9 cd 0d 18			call dumpcont 
17dc 3e 78			ld a, display_row_4 
17de 11 a7 16			ld de, endprog 
17e1			 
17e1 cd dc 0a			call update_display		 
17e4			 
17e4 cd 05 19			call next_page_prompt 
17e7 c3 fb 16			jp monitor 
17ea			 
17ea			 
17ea			; TODO symbol access  
17ea			 
17ea			.symbols:     ;; A list of symbols that can be called up  
17ea bd fa			dw display_fb0 
17ec .. 00			db "fb0",0  
17f0 62 f8		     	dw store_page 
17f2 .. 00			db "store_page",0 
17fd			 
17fd			 
17fd			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
17fd			 
17fd 3a 33 ee			ld a,(scratch+1) 
1800 fe 00			cp 0 
1802 28 09			jr z, dumpcont 
1804			 
1804				; no, not a null term line so has an address to work out.... 
1804			 
1804 21 34 ee			ld hl,scratch+2 
1807 cd c9 0f			call get_word_hl 
180a			 
180a 22 55 f1			ld (os_cur_ptr),hl	 
180d			 
180d			 
180d			 
180d			dumpcont: 
180d			 
180d				; dump bytes at ptr 
180d			 
180d			 
180d 3e 00			ld a, display_row_1 
180f 2a d8 f8			ld hl, (display_fb_active) 
1812 cd 12 0c			call addatohl 
1815 cd 3d 18			call .dumpbyterow 
1818			 
1818 3e 28			ld a, display_row_2 
181a 2a d8 f8			ld hl, (display_fb_active) 
181d cd 12 0c			call addatohl 
1820 cd 3d 18			call .dumpbyterow 
1823			 
1823			 
1823 3e 50			ld a, display_row_3 
1825 2a d8 f8			ld hl, (display_fb_active) 
1828 cd 12 0c			call addatohl 
182b cd 3d 18			call .dumpbyterow 
182e			 
182e 3e 78			ld a, display_row_4 
1830 2a d8 f8			ld hl, (display_fb_active) 
1833 cd 12 0c			call addatohl 
1836 cd 3d 18			call .dumpbyterow 
1839			 
1839 cd dc 0a			call update_display 
183c			;		jp cli 
183c c9				ret 
183d			 
183d			.dumpbyterow: 
183d			 
183d				;push af 
183d			 
183d e5				push hl 
183e			 
183e				; calc where to poke the ascii 
183e			if display_cols == 20 
183e				ld a, 16 
183e			else 
183e 3e 1f			ld a, 31 
1840			endif 
1840			 
1840 cd 12 0c			call addatohl 
1843 22 37 f1			ld (os_word_scratch),hl  		; save pos for later 
1846			 
1846			 
1846			; display decoding address 
1846 2a 55 f1		   	ld hl,(os_cur_ptr) 
1849			 
1849 7c				ld a,h 
184a e1				pop hl 
184b e5				push hl 
184c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
184c cd 13 0f			call hexout 
184f 2a 55 f1		   	ld hl,(os_cur_ptr) 
1852			 
1852 7d				ld a,l 
1853 e1				pop hl 
1854 23				inc hl 
1855 23				inc hl 
1856 e5				push hl 
1857			;	ld hl, os_word_scratch+2 
1857 cd 13 0f			call hexout 
185a e1				pop hl 
185b 23				inc hl 
185c 23				inc hl 
185d				;ld hl, os_word_scratch+4 
185d 3e 3a			ld a, ':' 
185f 77				ld (hl),a 
1860 23				inc hl 
1861				;ld a, 0 
1861				;ld (hl),a 
1861				;ld de, os_word_scratch 
1861				;pop af 
1861				;push af 
1861			;		ld a, display_row_2 
1861			;		call str_at_display 
1861			;		call update_display 
1861			 
1861			 
1861			;pop af 
1861			;	add 5 
1861			 
1861			if display_cols == 20 
1861				ld b, 4 
1861			else 
1861 06 08			ld b, 8 
1863			endif	 
1863			 
1863			.dumpbyte: 
1863 c5				push bc 
1864 e5				push hl 
1865			 
1865			 
1865 2a 55 f1		   	ld hl,(os_cur_ptr) 
1868 7e					ld a,(hl) 
1869			 
1869					; poke the ascii to display 
1869 2a 37 f1				ld hl,(os_word_scratch) 
186c 77					ld (hl),a 
186d 23					inc hl 
186e 22 37 f1				ld (os_word_scratch),hl 
1871			 
1871					 
1871			 
1871			 
1871 e1					pop hl 
1872 e5					push hl 
1873			 
1873 cd 13 0f				call hexout 
1876			 
1876					 
1876 2a 55 f1		   	ld hl,(os_cur_ptr) 
1879 23				inc hl 
187a 22 55 f1		   	ld (os_cur_ptr),hl 
187d			 
187d e1					pop hl 
187e 23					inc hl 
187f 23					inc hl 
1880 23					inc hl 
1881			 
1881			 
1881			 
1881					;ld a,0 
1881					;ld (os_word_scratch+2),a 
1881					;pop af 
1881					;push af 
1881			 
1881					;ld de, os_word_scratch 
1881					;call str_at_display 
1881			;		call update_display 
1881			;		pop af 
1881 c1					pop bc 
1882 c6 03				add 3 
1884 10 dd			djnz .dumpbyte 
1886			 
1886				 
1886			 
1886 c9				ret 
1887			 
1887			jump:	 
1887			 
1887 21 34 ee			ld hl,scratch+2 
188a cd c9 0f			call get_word_hl 
188d				;ld hl,(scratch+2) 
188d				;call fourehexhl 
188d			 
188d 22 55 f1			ld (os_cur_ptr),hl	 
1890			 
1890 e9				jp (hl) 
1891			 
1891			 
1891			 
1891			; TODO implement a basic monitor mode to start with 
1891			 
1891			 
1891			 
1891			 
1891			 
1891			 
1891			 
1891			 
1891			 
1891			; testing and demo code during development 
1891			 
1891			 
1891 .. 00		str1: db "Enter some text...",0 
18a4 .. 00		clear: db "                    ",0 
18b9			 
18b9			demo: 
18b9			 
18b9			 
18b9			 
18b9			;	call update_display 
18b9			 
18b9				; init scratch input area for testing 
18b9 21 32 ee			ld hl, scratch	 
18bc 3e 00			ld a,0 
18be 77				ld (hl),a 
18bf			 
18bf			 
18bf 3e 28		            LD   A, display_row_2 
18c1			;            CALL fLCD_Pos       ;Position cursor to location in A 
18c1 11 91 18		            LD   DE, str1 
18c4 cd cc 0a			call str_at_display 
18c7			 
18c7			;            CALL fLCD_Str       ;Display string pointed to by DE 
18c7			cloop:	 
18c7 3e 50		            LD   A, display_row_3 
18c9			;            CALL fLCD_Pos       ;Position cursor to location in A 
18c9 11 a4 18		            LD   DE, clear 
18cc			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18cc cd cc 0a				call str_at_display 
18cf 3e 78			ld a, display_row_4 
18d1 11 01 19			ld de, prompt 
18d4			 
18d4 cd cc 0a				call str_at_display 
18d7 cd dc 0a			call update_display 
18da			 
18da 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18dc 16 0a			ld d, 10 
18de 21 32 ee			ld hl, scratch	 
18e1 cd 3f 0c			call input_str 
18e4			 
18e4			;	call clear_display 
18e4			;'	call update_display 
18e4			 
18e4 3e 00		            LD   A, display_row_1 
18e6			;            CALL fLCD_Pos       ;Position cursor to location in A 
18e6 11 a4 18		            LD   DE, clear 
18e9 cd cc 0a				call str_at_display 
18ec			;            CALL fLCD_Str       ;Display string pointed to by DE 
18ec 3e 00		            LD   A, display_row_1 
18ee			;            CALL fLCD_Pos       ;Position cursor to location in A 
18ee 11 32 ee		            LD   DE, scratch 
18f1			;            CALL fLCD_Str       ;Display string pointed to by DE 
18f1 cd cc 0a				call str_at_display 
18f4 cd dc 0a			call update_display 
18f7			 
18f7 3e 00				ld a,0 
18f9 21 32 ee			ld hl, scratch 
18fc 77				ld (hl),a 
18fd			 
18fd 00				nop 
18fe c3 c7 18			jp cloop 
1901			 
1901			 
1901			 
1901			; OS Prompt 
1901			 
1901 .. 00		prompt: db ">",0 
1903 .. 00		endprg: db "?",0 
1905			 
1905			 
1905			; handy next page prompt 
1905			next_page_prompt: 
1905 e5				push hl 
1906 d5				push de 
1907 f5				push af 
1908 c5				push bc 
1909			 
1909 3e 9f			ld a,display_row_4 + display_cols - 1 
190b 11 03 19		        ld de, endprg 
190e cd cc 0a			call str_at_display 
1911 cd dc 0a			call update_display 
1914 cd e8 64			call cin_wait 
1917 c1				pop bc 
1918 f1				pop af 
1919 d1				pop de 
191a e1				pop hl 
191b			 
191b			 
191b c9				ret 
191c			 
191c			 
191c			; forth parser 
191c			 
191c			; My forth kernel 
191c			include "forth_kernel.asm" 
191c			; 
191c			; kernel to the forth OS 
191c			 
191c			DS_TYPE_STR: equ 1     ; string type 
191c			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
191c			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
191c			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
191c			 
191c			FORTH_PARSEV1: equ 0 
191c			FORTH_PARSEV2: equ 0 
191c			FORTH_PARSEV3: equ 0 
191c			FORTH_PARSEV4: equ 0 
191c			FORTH_PARSEV5: equ 1 
191c			 
191c			;if FORTH_PARSEV5 
191c			;	FORTH_END_BUFFER: equ 0 
191c			;else 
191c			FORTH_END_BUFFER: equ 127 
191c			;endif 
191c			 
191c			FORTH_TRUE: equ 1 
191c			FORTH_FALSE: equ 0 
191c			 
191c			if FORTH_PARSEV4 
191c			include "forth_stackops.asm" 
191c			endif 
191c			 
191c			if FORTH_PARSEV5 
191c			include "forth_stackopsv5.asm" 
191c			 
191c			; Stack operations for v5 parser on wards 
191c			; * DATA stack 
191c			; * LOOP stack 
191c			; * RETURN stack 
191c			 
191c			 
191c			 
191c			FORTH_CHK_DSP_UNDER: macro 
191c				push hl 
191c				push de 
191c				ld hl,(cli_data_sp) 
191c				ld de, cli_data_stack 
191c				call cmp16 
191c				jp c, fault_dsp_under 
191c				pop de 
191c				pop hl 
191c				endm 
191c			 
191c			 
191c			FORTH_CHK_RSP_UNDER: macro 
191c				push hl 
191c				push de 
191c				ld hl,(cli_ret_sp) 
191c				ld de, cli_ret_stack 
191c				call cmp16 
191c				jp c, fault_rsp_under 
191c				pop de 
191c				pop hl 
191c				endm 
191c			 
191c			FORTH_CHK_LOOP_UNDER: macro 
191c				push hl 
191c				push de 
191c				ld hl,(cli_loop_sp) 
191c				ld de, cli_loop_stack 
191c				call cmp16 
191c				jp c, fault_loop_under 
191c				pop de 
191c				pop hl 
191c				endm 
191c			 
191c			FORTH_ERR_TOS_NOTSTR: macro 
191c				; TOSO might need more for checks when used 
191c				push af 
191c				ld a,(hl) 
191c				cp DS_TYPE_STR 
191c				jp nz, type_faultn   
191c				pop af 
191c				endm 
191c			 
191c			FORTH_ERR_TOS_NOTNUM: macro 
191c				push af 
191c				ld a,(hl) 
191c				cp DS_TYPE_INUM 
191c				jp nz, type_faultn   
191c				pop af 
191c				endm 
191c			 
191c			 
191c			; increase data stack pointer and save hl to it 
191c				 
191c			FORTH_DSP_NEXT: macro 
191c				call macro_forth_dsp_next 
191c				endm 
191c			 
191c			 
191c			macro_forth_dsp_next: 
191c				if DEBUG_FORTH_STACK_GUARD 
191c cd 89 5f				call check_stacks 
191f				endif 
191f e5				push hl 
1920 d5				push de 
1921 eb				ex de,hl 
1922 2a 1f f8			ld hl,(cli_data_sp) 
1925 23				inc hl 
1926 23				inc hl 
1927			 
1927			; PARSEV5 
1927 23				inc hl 
1928 22 1f f8			ld (cli_data_sp),hl 
192b 73				ld (hl), e 
192c 23				inc hl 
192d 72				ld (hl), d 
192e d1				pop de 
192f e1				pop hl 
1930				if DEBUG_FORTH_STACK_GUARD 
1930 cd 89 5f				call check_stacks 
1933				endif 
1933 c9				ret 
1934			 
1934			 
1934			; increase ret stack pointer and save hl to it 
1934				 
1934			FORTH_RSP_NEXT: macro 
1934				call macro_forth_rsp_next 
1934				endm 
1934			 
1934			macro_forth_rsp_next: 
1934				if DEBUG_FORTH_STACK_GUARD 
1934 cd 89 5f				call check_stacks 
1937				endif 
1937 e5				push hl 
1938 d5				push de 
1939 eb				ex de,hl 
193a 2a 23 f8			ld hl,(cli_ret_sp) 
193d 23				inc hl 
193e 23				inc hl 
193f 22 23 f8			ld (cli_ret_sp),hl 
1942 73				ld (hl), e 
1943 23				inc hl 
1944 72				ld (hl), d 
1945 d1				pop de 
1946 e1				pop hl 
1947				if DEBUG_FORTH_STACK_GUARD 
1947 cd 89 5f				call check_stacks 
194a				endif 
194a c9				ret 
194b			 
194b			; get current ret stack pointer and save to hl  
194b				 
194b			FORTH_RSP_TOS: macro 
194b				call macro_forth_rsp_tos 
194b				endm 
194b			 
194b			macro_forth_rsp_tos: 
194b				;push de 
194b 2a 23 f8			ld hl,(cli_ret_sp) 
194e cd 86 19			call loadhlptrtohl 
1951				;ld e, (hl) 
1951				;inc hl 
1951				;ld d, (hl) 
1951				;ex de, hl 
1951					if DEBUG_FORTH_WORDS 
1951			;			DMARK "RST" 
1951						CALLMONITOR 
1951 cd 00 14			call break_point_state  
1954				endm  
# End of macro CALLMONITOR
1954					endif 
1954				;pop de 
1954 c9				ret 
1955			 
1955			; pop ret stack pointer 
1955				 
1955			FORTH_RSP_POP: macro 
1955				call macro_forth_rsp_pop 
1955				endm 
1955			 
1955			 
1955			macro_forth_rsp_pop: 
1955				if DEBUG_FORTH_STACK_GUARD 
1955			;		DMARK "RPP" 
1955 cd 89 5f				call check_stacks 
1958					FORTH_CHK_RSP_UNDER 
1958 e5				push hl 
1959 d5				push de 
195a 2a 23 f8			ld hl,(cli_ret_sp) 
195d 11 9d f7			ld de, cli_ret_stack 
1960 cd 30 0c			call cmp16 
1963 da 9d 60			jp c, fault_rsp_under 
1966 d1				pop de 
1967 e1				pop hl 
1968				endm 
# End of macro FORTH_CHK_RSP_UNDER
1968				endif 
1968 e5				push hl 
1969 2a 23 f8			ld hl,(cli_ret_sp) 
196c			 
196c			 
196c				if FORTH_ENABLE_FREE 
196c			 
196c					; get pointer 
196c			 
196c					push de 
196c					push hl 
196c			 
196c					ld e, (hl) 
196c					inc hl 
196c					ld d, (hl) 
196c			 
196c					ex de, hl 
196c					call free 
196c			 
196c					pop hl 
196c					pop de 
196c			 
196c			 
196c				endif 
196c			 
196c			 
196c 2b				dec hl 
196d 2b				dec hl 
196e 22 23 f8			ld (cli_ret_sp), hl 
1971				; do stack underflow checks 
1971 e1				pop hl 
1972				if DEBUG_FORTH_STACK_GUARD 
1972 cd 89 5f				call check_stacks 
1975					FORTH_CHK_RSP_UNDER 
1975 e5				push hl 
1976 d5				push de 
1977 2a 23 f8			ld hl,(cli_ret_sp) 
197a 11 9d f7			ld de, cli_ret_stack 
197d cd 30 0c			call cmp16 
1980 da 9d 60			jp c, fault_rsp_under 
1983 d1				pop de 
1984 e1				pop hl 
1985				endm 
# End of macro FORTH_CHK_RSP_UNDER
1985				endif 
1985 c9				ret 
1986			 
1986			 
1986			 
1986			; routine to load word pointed to by hl into hl 
1986			 
1986			loadhlptrtohl: 
1986			 
1986 d5				push de 
1987 5e				ld e, (hl) 
1988 23				inc hl 
1989 56				ld d, (hl) 
198a eb				ex de, hl 
198b d1				pop de 
198c			 
198c c9				ret 
198d			 
198d			 
198d			 
198d			 
198d			 
198d			; push a number held in HL onto the data stack 
198d			; entry point for pushing a value when already in hl used in function above 
198d			 
198d			forth_push_numhl: 
198d			 
198d e5				push hl    ; save value to push 
198e			 
198e			if DEBUG_FORTH_PUSH 
198e				; see if disabled 
198e			 
198e			 
198e				push af 
198e				ld a, (os_view_disable) 
198e				cp '*' 
198e				jr z, .pskip2 
198e				push hl 
198e			push hl 
198e				call clear_display 
198e			pop hl 
198e				ld a,h 
198e				ld hl, os_word_scratch 
198e				call hexout 
198e				pop hl 
198e				ld a,l 
198e				ld hl, os_word_scratch+2 
198e				call hexout 
198e			 
198e				ld hl, os_word_scratch+4 
198e				ld a,0 
198e				ld (hl),a 
198e				ld de,os_word_scratch 
198e					ld a, display_row_2 
198e					call str_at_display 
198e				ld de, .push_num 
198e				ld a, display_row_1 
198e			 
198e					call str_at_display 
198e			 
198e			 
198e				call update_display 
198e				call delay1s 
198e				call delay1s 
198e			.pskip2:  
198e			 
198e				pop af 
198e			endif	 
198e			 
198e			 
198e				FORTH_DSP_NEXT 
198e cd 1c 19			call macro_forth_dsp_next 
1991				endm 
# End of macro FORTH_DSP_NEXT
1991			 
1991 2a 1f f8			ld hl, (cli_data_sp) 
1994			 
1994				; save item type 
1994 3e 02			ld a,  DS_TYPE_INUM 
1996 77				ld (hl), a 
1997 23				inc hl 
1998			 
1998				; get word off stack 
1998 d1				pop de 
1999 7b				ld a,e 
199a 77				ld (hl), a 
199b 23				inc hl 
199c 7a				ld a,d 
199d 77				ld (hl), a 
199e			 
199e			if DEBUG_FORTH_PUSH 
199e				dec hl 
199e				dec hl 
199e				dec hl 
199e						DMARK "PH5" 
199e				CALLMONITOR 
199e			endif	 
199e			 
199e c9				ret 
199f			 
199f			 
199f			; Push a string to stack pointed to by hl 
199f			 
199f			forth_push_str: 
199f			 
199f			if DEBUG_FORTH_PUSH 
199f						DMARK "PSQ" 
199f				CALLMONITOR 
199f			endif	 
199f			    
199f e5				push hl 
19a0 e5				push hl 
19a1			 
19a1 3e 00			ld a, 0   ; find end of string 
19a3 cd 7b 10			call strlent       
19a6			if DEBUG_FORTH_PUSH 
19a6						DMARK "PQ2" 
19a6				CALLMONITOR 
19a6			endif	 
19a6 eb				ex de, hl 
19a7 e1				pop hl   ; get ptr to start of string 
19a8			if DEBUG_FORTH_PUSH 
19a8						DMARK "PQ3" 
19a8				CALLMONITOR 
19a8			endif	 
19a8 19				add hl,de 
19a9			if DEBUG_FORTH_PUSH 
19a9						DMARK "PQE" 
19a9				CALLMONITOR 
19a9			endif	 
19a9			 
19a9 2b				dec hl    ; see if there is an optional trailing double quote 
19aa 7e				ld a,(hl) 
19ab fe 22			cp '"' 
19ad 20 03			jr nz, .strnoq 
19af 3e 00			ld a, 0      ; get rid of double quote 
19b1 77				ld (hl), a 
19b2 23			.strnoq: inc hl 
19b3			 
19b3 3e 00			ld a, 0 
19b5 77				ld (hl), a     ; add null term and get rid of trailing double quote 
19b6			 
19b6 13				inc de ; add one for the type string 
19b7 13				inc de ; add one for null term??? 
19b8			 
19b8				; tos is get string pointer again 
19b8				; de contains space to allocate 
19b8				 
19b8 d5				push de 
19b9			 
19b9 eb				ex de, hl 
19ba			 
19ba				;push af 
19ba			 
19ba			if DEBUG_FORTH_PUSH 
19ba						DMARK "PHm" 
19ba				CALLMONITOR 
19ba			endif	 
19ba cd d9 10			call malloc	; on ret hl now contains allocated memory 
19bd				if DEBUG_FORTH_MALLOC_GUARD 
19bd cc ef 4e				call z,malloc_error 
19c0				endif 
19c0			 
19c0				 
19c0 c1				pop bc    ; get length 
19c1 d1				pop de   ;  get string start    
19c2			 
19c2				; hl has destination from malloc 
19c2			 
19c2 eb				ex de, hl    ; prep for ldir 
19c3			 
19c3 e5				push hl   ; save malloc area for DSP later 
19c4			 
19c4			if DEBUG_FORTH_PUSH 
19c4						DMARK "PHc" 
19c4				CALLMONITOR 
19c4			endif	 
19c4			 
19c4			 
19c4 ed b0			ldir 
19c6			 
19c6			 
19c6				; push malloc to data stack     macro?????  
19c6			 
19c6				FORTH_DSP_NEXT 
19c6 cd 1c 19			call macro_forth_dsp_next 
19c9				endm 
# End of macro FORTH_DSP_NEXT
19c9			 
19c9				; save value and type 
19c9			 
19c9 2a 1f f8			ld hl, (cli_data_sp) 
19cc			 
19cc				; save item type 
19cc 3e 01			ld a,  DS_TYPE_STR 
19ce 77				ld (hl), a 
19cf 23				inc hl 
19d0			 
19d0				; get malloc word off stack 
19d0 d1				pop de 
19d1 73				ld (hl), e 
19d2 23				inc hl 
19d3 72				ld (hl), d 
19d4			 
19d4			 
19d4			 
19d4			if DEBUG_FORTH_PUSH 
19d4				ld hl, (cli_data_sp) 
19d4						DMARK "PHS" 
19d4				CALLMONITOR 
19d4			;	ex de,hl 
19d4			endif	 
19d4				; in case of spaces, skip the ptr past the copied string 
19d4				;pop af 
19d4				;ld (cli_origptr),hl 
19d4			 
19d4 c9				ret 
19d5			 
19d5			 
19d5			 
19d5			; TODO ascii push input onto stack given hl to start of input 
19d5			 
19d5			; identify type 
19d5			; if starts with a " then a string 
19d5			; otherwise it is a number 
19d5			;  
19d5			; if a string 
19d5			;     scan for ending " to get length of string to malloc for + 1 
19d5			;     malloc 
19d5			;     put pointer to string on stack first byte flags as string 
19d5			; 
19d5			; else a number 
19d5			;    look for number format identifier 
19d5			;    $xx hex 
19d5			;    %xxxxx bin 
19d5			;    xxxxx decimal 
19d5			;    convert number to 16bit word.  
19d5			;    malloc word + 1 with flag to identiy as num 
19d5			;    put pointer to number on stack 
19d5			;   
19d5			;  
19d5			  
19d5			forth_apush: 
19d5				; kernel push 
19d5			 
19d5			if DEBUG_FORTH_PUSH 
19d5						DMARK "PSH" 
19d5				CALLMONITOR 
19d5			endif	 
19d5				; identify input type 
19d5			 
19d5 7e				ld a,(hl) 
19d6 fe 22			cp '"' 
19d8 28 0a			jr z, .fapstr 
19da fe 24			cp '$' 
19dc ca 04 1a			jp z, .faphex 
19df fe 25			cp '%' 
19e1 ca ec 19			jp z, .fapbin 
19e4			;	cp 'b' 
19e4			;	jp z, .fabin 
19e4				; else decimal 
19e4			 
19e4				; TODO do decimal conversion 
19e4				; decimal is stored as a 16bit word 
19e4			 
19e4				; by default everything is a string if type is not detected 
19e4			.fapstr: ; 
19e4 fe 22			cp '"' 
19e6 20 01			jr nz, .strnoqu 
19e8 23				inc hl 
19e9			.strnoqu: 
19e9 c3 9f 19			jp forth_push_str 
19ec			 
19ec			 
19ec			 
19ec			.fapbin:    ; push a binary string.  
19ec 11 00 00			ld de, 0   ; hold a 16bit value 
19ef			 
19ef 23			.fapbinshift:	inc hl  
19f0 7e				ld a,(hl) 
19f1 fe 00			cp 0     ; done scanning  
19f3 28 0b			jr z, .fapbdone  	; got it in HL so push  
19f5			 
19f5				; left shift de 
19f5 eb				ex de, hl	 
19f6 29				add hl, hl 
19f7			 
19f7				; is 1 
19f7 fe 31			cp '1' 
19f9 20 02			jr nz, .binzero 
19fb cb 4d			bit 1, l 
19fd			.binzero: 
19fd eb				ex de, hl	 ; save current de 
19fe 18 ef			jr .fapbinshift 
1a00			 
1a00			.fapbdone: 
1a00 eb				ex de, hl 
1a01 c3 8d 19			jp forth_push_numhl 
1a04			 
1a04			 
1a04			.faphex:   ; hex is always stored as a 16bit word 
1a04				; skip number prefix 
1a04 23				inc hl 
1a05				; turn ascii into number 
1a05 cd c9 0f			call get_word_hl	; ret 16bit word in hl 
1a08			 
1a08 c3 8d 19			jp forth_push_numhl 
1a0b			 
1a0b 00				 nop 
1a0c			 
1a0c			.fabin:   ; TODO bin conversion 
1a0c			 
1a0c			 
1a0c c9				ret 
1a0d			 
1a0d			 
1a0d			; get either a string ptr or a 16bit word from the data stack 
1a0d			 
1a0d			FORTH_DSP: macro 
1a0d				call macro_forth_dsp 
1a0d				endm 
1a0d			 
1a0d			macro_forth_dsp: 
1a0d				; data stack pointer points to current word on tos 
1a0d			 
1a0d 2a 1f f8			ld hl,(cli_data_sp) 
1a10			 
1a10				if DEBUG_FORTH_PUSH 
1a10						DMARK "DSP" 
1a10			 
1a10					call display_data_sp 
1a10				;call break_point_state 
1a10				;rst 030h 
1a10				CALLMONITOR 
1a10				endif 
1a10			 
1a10 c9				ret 
1a11			 
1a11			; return hl to start of value on stack 
1a11			 
1a11			FORTH_DSP_VALUE: macro 
1a11				call macro_forth_dsp_value 
1a11				endm 
1a11			 
1a11			macro_forth_dsp_value: 
1a11			 
1a11				FORTH_DSP 
1a11 cd 0d 1a			call macro_forth_dsp 
1a14				endm 
# End of macro FORTH_DSP
1a14			 
1a14 d5				push de 
1a15			 
1a15 23				inc hl ; skip type 
1a16			 
1a16 5e				ld e, (hl) 
1a17 23				inc hl 
1a18 56				ld d, (hl) 
1a19 eb				ex de,hl  
1a1a			 
1a1a d1				pop de 
1a1b			 
1a1b c9				ret 
1a1c			 
1a1c			; return hl to start of value to second item on stack 
1a1c			 
1a1c			FORTH_DSP_VALUEM1: macro 
1a1c				call macro_forth_dsp_value_m1 
1a1c				endm 
1a1c			 
1a1c			macro_forth_dsp_value_m1: 
1a1c			 
1a1c				FORTH_DSP 
1a1c cd 0d 1a			call macro_forth_dsp 
1a1f				endm 
# End of macro FORTH_DSP
1a1f			 
1a1f 2b				dec hl 
1a20 2b				dec hl 
1a21			;	dec hl 
1a21			 
1a21 d5				push de 
1a22			 
1a22 5e				ld e, (hl) 
1a23 23				inc hl 
1a24 56				ld d, (hl) 
1a25 eb				ex de,hl  
1a26			 
1a26 d1				pop de 
1a27			 
1a27 c9				ret 
1a28			 
1a28				 
1a28			 
1a28			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1a28			 
1a28			FORTH_DSP_POP: macro 
1a28				call macro_forth_dsp_pop 
1a28				endm 
1a28			 
1a28			 
1a28			; get the tos data type 
1a28			 
1a28			FORTH_DSP_TYPE:   macro 
1a28			 
1a28				;FORTH_DSP_VALUE 
1a28				FORTH_DSP 
1a28				 
1a28				; hl points to value 
1a28				; check type 
1a28			 
1a28				ld a,(hl) 
1a28			 
1a28				endm 
1a28			 
1a28			; load the tos value into hl 
1a28			 
1a28			 
1a28			FORTH_DSP_VALUEHL:  macro 
1a28				call macro_dsp_valuehl 
1a28				endm 
1a28			 
1a28			 
1a28			 
1a28			macro_dsp_valuehl: 
1a28				FORTH_DSP_VALUE 
1a28 cd 11 1a			call macro_forth_dsp_value 
1a2b				endm 
# End of macro FORTH_DSP_VALUE
1a2b			 
1a2b				;FORTH_ERR_TOS_NOTNUM 
1a2b			 
1a2b				;inc hl   ; skip type id 
1a2b			 
1a2b			;	push de 
1a2b			; 
1a2b			;	ld e, (hl) 
1a2b			;	inc hl 
1a2b			;	ld d, (hl) 
1a2b			;	ex de,hl  
1a2b			 
1a2b			;	pop de 
1a2b			 
1a2b				if DEBUG_FORTH_PUSH 
1a2b						DMARK "DVL" 
1a2b				CALLMONITOR 
1a2b				endif 
1a2b c9				ret 
1a2c			 
1a2c			forth_apushstrhl:      
1a2c				; push of string requires use of cli_origptr 
1a2c				; bodge use 
1a2c			 
1a2c				; get current cli_origptr, save, update with temp pointer  
1a2c ed 5b 3b f8		ld de, (cli_origptr) 
1a30 22 3b f8			ld (cli_origptr), hl 
1a33 d5				push de 
1a34 cd d5 19			call forth_apush 
1a37 d1				pop de 
1a38 ed 53 3b f8		ld (cli_origptr), de 
1a3c c9			        ret	 
1a3d			 
1a3d			 
1a3d			; increase loop stack pointer and save hl to it 
1a3d				 
1a3d			FORTH_LOOP_NEXT: macro 
1a3d				call macro_forth_loop_next 
1a3d				;nop 
1a3d				endm 
1a3d			 
1a3d			macro_forth_loop_next: 
1a3d				if DEBUG_FORTH_STACK_GUARD 
1a3d cd 89 5f				call check_stacks 
1a40				endif 
1a40 e5				push hl 
1a41 d5				push de 
1a42 eb				ex de,hl 
1a43 2a 21 f8			ld hl,(cli_loop_sp) 
1a46 23				inc hl 
1a47 23				inc hl 
1a48					if DEBUG_FORTH_WORDS 
1a48						DMARK "LNX" 
1a48 f5				push af  
1a49 3a 5d 1a			ld a, (.dmark)  
1a4c 32 77 fb			ld (debug_mark),a  
1a4f 3a 5e 1a			ld a, (.dmark+1)  
1a52 32 78 fb			ld (debug_mark+1),a  
1a55 3a 5f 1a			ld a, (.dmark+2)  
1a58 32 79 fb			ld (debug_mark+2),a  
1a5b 18 03			jr .pastdmark  
1a5d ..			.dmark: db "LNX"  
1a60 f1			.pastdmark: pop af  
1a61			endm  
# End of macro DMARK
1a61						CALLMONITOR 
1a61 cd 00 14			call break_point_state  
1a64				endm  
# End of macro CALLMONITOR
1a64					endif 
1a64 22 21 f8			ld (cli_loop_sp),hl 
1a67 73				ld (hl), e 
1a68 23				inc hl 
1a69 72				ld (hl), d 
1a6a d1				pop de    ; been reversed so save a swap on restore 
1a6b e1				pop hl 
1a6c				if DEBUG_FORTH_STACK_GUARD 
1a6c cd 89 5f				call check_stacks 
1a6f				endif 
1a6f c9				ret 
1a70			 
1a70			; get current ret stack pointer and save to hl  
1a70				 
1a70			FORTH_LOOP_TOS: macro 
1a70				call macro_forth_loop_tos 
1a70				endm 
1a70			 
1a70			macro_forth_loop_tos: 
1a70 d5				push de 
1a71 2a 21 f8			ld hl,(cli_loop_sp) 
1a74 5e				ld e, (hl) 
1a75 23				inc hl 
1a76 56				ld d, (hl) 
1a77 eb				ex de, hl 
1a78 d1				pop de 
1a79 c9				ret 
1a7a			 
1a7a			; pop loop stack pointer 
1a7a				 
1a7a			FORTH_LOOP_POP: macro 
1a7a				call macro_forth_loop_pop 
1a7a				endm 
1a7a			 
1a7a			 
1a7a			macro_forth_loop_pop: 
1a7a				if DEBUG_FORTH_STACK_GUARD 
1a7a					DMARK "LPP" 
1a7a f5				push af  
1a7b 3a 8f 1a			ld a, (.dmark)  
1a7e 32 77 fb			ld (debug_mark),a  
1a81 3a 90 1a			ld a, (.dmark+1)  
1a84 32 78 fb			ld (debug_mark+1),a  
1a87 3a 91 1a			ld a, (.dmark+2)  
1a8a 32 79 fb			ld (debug_mark+2),a  
1a8d 18 03			jr .pastdmark  
1a8f ..			.dmark: db "LPP"  
1a92 f1			.pastdmark: pop af  
1a93			endm  
# End of macro DMARK
1a93 cd 89 5f				call check_stacks 
1a96					FORTH_CHK_LOOP_UNDER 
1a96 e5				push hl 
1a97 d5				push de 
1a98 2a 21 f8			ld hl,(cli_loop_sp) 
1a9b 11 9b f5			ld de, cli_loop_stack 
1a9e cd 30 0c			call cmp16 
1aa1 da a3 60			jp c, fault_loop_under 
1aa4 d1				pop de 
1aa5 e1				pop hl 
1aa6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1aa6				endif 
1aa6 e5				push hl 
1aa7 2a 21 f8			ld hl,(cli_loop_sp) 
1aaa 2b				dec hl 
1aab 2b				dec hl 
1aac 22 21 f8			ld (cli_loop_sp), hl 
1aaf				; TODO do stack underflow checks 
1aaf e1				pop hl 
1ab0				if DEBUG_FORTH_STACK_GUARD 
1ab0 cd 89 5f				call check_stacks 
1ab3					FORTH_CHK_LOOP_UNDER 
1ab3 e5				push hl 
1ab4 d5				push de 
1ab5 2a 21 f8			ld hl,(cli_loop_sp) 
1ab8 11 9b f5			ld de, cli_loop_stack 
1abb cd 30 0c			call cmp16 
1abe da a3 60			jp c, fault_loop_under 
1ac1 d1				pop de 
1ac2 e1				pop hl 
1ac3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ac3				endif 
1ac3 c9				ret 
1ac4			 
1ac4			macro_forth_dsp_pop: 
1ac4			 
1ac4 e5				push hl 
1ac5			 
1ac5				; release malloc data 
1ac5			 
1ac5				if DEBUG_FORTH_STACK_GUARD 
1ac5 cd 89 5f				call check_stacks 
1ac8					FORTH_CHK_DSP_UNDER 
1ac8 e5				push hl 
1ac9 d5				push de 
1aca 2a 1f f8			ld hl,(cli_data_sp) 
1acd 11 99 f3			ld de, cli_data_stack 
1ad0 cd 30 0c			call cmp16 
1ad3 da 97 60			jp c, fault_dsp_under 
1ad6 d1				pop de 
1ad7 e1				pop hl 
1ad8				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ad8				endif 
1ad8				;ld hl,(cli_data_sp) 
1ad8			if DEBUG_FORTH_DOT 
1ad8				DMARK "DPP" 
1ad8				CALLMONITOR 
1ad8			endif	 
1ad8			 
1ad8			 
1ad8			if FORTH_ENABLE_DSPPOPFREE 
1ad8			 
1ad8				FORTH_DSP 
1ad8 cd 0d 1a			call macro_forth_dsp 
1adb				endm 
# End of macro FORTH_DSP
1adb			 
1adb 7e				ld a, (hl) 
1adc fe 01			cp DS_TYPE_STR 
1ade 20 07			jr nz, .skippopfree 
1ae0			 
1ae0				FORTH_DSP_VALUEHL 
1ae0 cd 28 1a			call macro_dsp_valuehl 
1ae3				endm 
# End of macro FORTH_DSP_VALUEHL
1ae3 00				nop 
1ae4			if DEBUG_FORTH_DOT 
1ae4				DMARK "DPf" 
1ae4				CALLMONITOR 
1ae4			endif	 
1ae4 cd a3 11			call free 
1ae7			.skippopfree: 
1ae7				 
1ae7			 
1ae7			endif 
1ae7			 
1ae7			if DEBUG_FORTH_DOT_KEY 
1ae7				DMARK "DP2" 
1ae7				CALLMONITOR 
1ae7			endif	 
1ae7			 
1ae7				; move pointer down 
1ae7			 
1ae7 2a 1f f8			ld hl,(cli_data_sp) 
1aea 2b				dec hl 
1aeb 2b				dec hl 
1aec			; PARSEV5 
1aec 2b				dec hl 
1aed 22 1f f8			ld (cli_data_sp), hl 
1af0			 
1af0				if DEBUG_FORTH_STACK_GUARD 
1af0 cd 89 5f				call check_stacks 
1af3					FORTH_CHK_DSP_UNDER 
1af3 e5				push hl 
1af4 d5				push de 
1af5 2a 1f f8			ld hl,(cli_data_sp) 
1af8 11 99 f3			ld de, cli_data_stack 
1afb cd 30 0c			call cmp16 
1afe da 97 60			jp c, fault_dsp_under 
1b01 d1				pop de 
1b02 e1				pop hl 
1b03				endm 
# End of macro FORTH_CHK_DSP_UNDER
1b03				endif 
1b03			 
1b03 e1				pop hl 
1b04			 
1b04 c9				ret 
1b05			 
1b05			getwordathl: 
1b05				; hl points to an address 
1b05				; load hl with the word at that address 
1b05			 
1b05 d5				push de 
1b06			 
1b06 5e				ld e, (hl) 
1b07 23				inc hl 
1b08 56				ld d, (hl) 
1b09 eb				ex de, hl 
1b0a			 
1b0a d1				pop de 
1b0b c9				ret 
1b0c			 
1b0c			 
1b0c			 
1b0c			 
1b0c			 
1b0c			; eof 
1b0c			 
# End of file forth_stackopsv5.asm
1b0c			endif 
1b0c			 
1b0c			user_word_eol:  
1b0c				; hl contains the pointer to where to create a linked list item from the end 
1b0c				; of the user dict to continue on at the system word dict 
1b0c				 
1b0c				; poke the stub of the word list linked list to repoint to rom words 
1b0c			 
1b0c				; stub format 
1b0c				; db   word id 
1b0c				; dw    link to next word 
1b0c			        ; db char length of token 
1b0c				; db string + 0 term 
1b0c				; db exec code....  
1b0c			 
1b0c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1b0e 77				ld (hl), a		; word id 
1b0f 23				inc hl 
1b10			 
1b10 11 d6 1c			ld de, sysdict 
1b13 73				ld (hl), e		; next word link ie system dict 
1b14 23				inc hl 
1b15 72				ld (hl), d		; next word link ie system dict 
1b16 23				inc hl	 
1b17			 
1b17			;	ld (hl), sysdict		; next word link ie system dict 
1b17			;	inc hl 
1b17			;	inc hl 
1b17			 
1b17			;	inc hl 
1b17			;	inc hl 
1b17			 
1b17 3e 02			ld a, 2			; word length is 0 
1b19 77				ld (hl), a	 
1b1a 23				inc hl 
1b1b			 
1b1b 3e 7e			ld a, '~'			; word length is 0 
1b1d 77				ld (hl), a	 
1b1e 23				inc hl 
1b1f 3e 00			ld a, 0			; save empty word 
1b21 77				ld (hl), a 
1b22			 
1b22 c9				ret 
1b23			 
1b23				 
1b23			 
1b23			forthexec_cleanup: 
1b23				FORTH_RSP_POP 
1b23 cd 55 19			call macro_forth_rsp_pop 
1b26				endm 
# End of macro FORTH_RSP_POP
1b26 c9				ret 
1b27			 
1b27			forth_call_hl: 
1b27				; taking hl 
1b27 e5				push hl 
1b28 c9				ret 
1b29			 
1b29			; this is called to reset Forth system but keep existing uwords etc 
1b29			 
1b29			forth_warmstart: 
1b29				; setup stack over/under flow checks 
1b29				if DEBUG_FORTH_STACK_GUARD 
1b29 cd 6f 5f				call chk_stk_init 
1b2c				endif 
1b2c			 
1b2c				; init stack pointers  - * these stacks go upwards *  
1b2c 21 9d f7			ld hl, cli_ret_stack 
1b2f 22 23 f8			ld (cli_ret_sp), hl	 
1b32				; set bottom of stack 
1b32 3e 00			ld a,0 
1b34 77				ld (hl),a 
1b35 23				inc hl 
1b36 77				ld (hl),a 
1b37			 
1b37 21 99 f3			ld hl, cli_data_stack 
1b3a 22 1f f8			ld (cli_data_sp), hl	 
1b3d				; set bottom of stack 
1b3d 3e 00			ld a,0 
1b3f 77				ld (hl),a 
1b40 23				inc hl 
1b41 77				ld (hl),a 
1b42			 
1b42 21 9b f5			ld hl, cli_loop_stack 
1b45 22 21 f8			ld (cli_loop_sp), hl	 
1b48				; set bottom of stack 
1b48 3e 00			ld a,0 
1b4a 77				ld (hl),a 
1b4b 23				inc hl 
1b4c 77				ld (hl),a 
1b4d			 
1b4d				; init extent of current open file 
1b4d			 
1b4d 3e 00			ld a, 0 
1b4f 32 59 f8			ld (store_openext), a 
1b52			 
1b52 c9				ret 
1b53			 
1b53			 
1b53			; Cold Start - this is called to setup the whole Forth system 
1b53			 
1b53			forth_init: 
1b53			 
1b53				; setup stack over/under flow checks 
1b53			 
1b53			;	if DEBUG_FORTH_STACK_GUARD 
1b53			;		call chk_stk_init 
1b53			;	endif 
1b53			 
1b53				; enable auto display updates (slow.....) 
1b53			 
1b53 3e 01			ld a, 1 
1b55 32 39 f8			ld (cli_autodisplay), a 
1b58			 
1b58			 
1b58			 
1b58				; show start up screen 
1b58			 
1b58 cd b9 0a			call clear_display 
1b5b			 
1b5b 3e 00			ld a,0 
1b5d 32 5b f8			ld (f_cursor_ptr), a 
1b60			 
1b60				; set start of word list in start of ram - for use when creating user words 
1b60			 
1b60 21 00 80			ld hl, baseram 
1b63 22 2f f1			ld (os_last_new_uword), hl 
1b66 cd 0c 1b			call user_word_eol 
1b69				 
1b69			;		call display_data_sp 
1b69			;		call next_page_prompt 
1b69			 
1b69			 
1b69			 
1b69			 
1b69 c9				ret 
1b6a			 
1b6a .. 00		.bootforth: db " Forth Kernel Init ",0 
1b7e			 
1b7e			; TODO push to stack 
1b7e			 
1b7e			;  
1b7e			 
1b7e			if FORTH_PARSEV2 
1b7e			 
1b7e			 
1b7e				include "forth_parserv2.asm" 
1b7e			 
1b7e			endif 
1b7e			 
1b7e			 
1b7e			; parse cli version 1 
1b7e			 
1b7e			if FORTH_PARSEV1 
1b7e			 
1b7e			 
1b7e			 
1b7e			      include "forth_parserv1.asm" 
1b7e			endif 
1b7e				 
1b7e			if FORTH_PARSEV3 
1b7e			 
1b7e			 
1b7e			 
1b7e			      include "forth_parserv3.asm" 
1b7e				include "forth_wordsv3.asm" 
1b7e			endif 
1b7e			 
1b7e			if FORTH_PARSEV4 
1b7e			 
1b7e			 
1b7e			 
1b7e			      include "forth_parserv4.asm" 
1b7e				include "forth_wordsv4.asm" 
1b7e			endif 
1b7e			 
1b7e			if FORTH_PARSEV5 
1b7e			 
1b7e			 
1b7e			 
1b7e			      include "forth_parserv5.asm" 
1b7e			 
1b7e			 
1b7e			; A better parser without using malloc and string copies all over the place.  
1b7e			; Exec in situ should be faster 
1b7e			 
1b7e			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1b7e			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1b7e			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1b7e			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1b7e			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1b7e			WORD_SYS_END: equ 0   ; Opcode for all user words 
1b7e			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1b7e			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1b7e			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1b7e			 
1b7e			; Core word preamble macro 
1b7e			 
1b7e			CWHEAD:   macro nxtword opcode lit len opflags 
1b7e				db WORD_SYS_CORE+opcode             
1b7e				; internal op code number 
1b7e				dw nxtword            
1b7e				; link to next dict word block 
1b7e				db len + 1 
1b7e				; literal length of dict word inc zero term 
1b7e				db lit,0              
1b7e				; literal dict word 
1b7e			        ; TODO db opflags        
1b7e				endm 
1b7e			 
1b7e			 
1b7e			NEXTW: macro  
1b7e				jp macro_next 
1b7e				endm 
1b7e			 
1b7e			macro_next: 
1b7e			if DEBUG_FORTH_PARSE_KEY 
1b7e				DMARK "NXT" 
1b7e				CALLMONITOR 
1b7e			endif	 
1b7e			;	inc hl  ; skip token null term  
1b7e ed 4b 3d f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1b82 ed 5b 3b f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1b86 2a 33 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1b89			if DEBUG_FORTH_PARSE_KEY 
1b89				DMARK "}AA" 
1b89				CALLMONITOR 
1b89			endif	 
1b89 c3 8c 1c			jp execnext 
1b8c				;jp exec1 
1b8c			       
1b8c			 
1b8c			 
1b8c			; Another go at the parser to compile  
1b8c			 
1b8c			 
1b8c			; TODO rework parser to change all of the string words to byte tokens 
1b8c			; TODO do a search for  
1b8c			 
1b8c			; TODO first run normal parser to zero term sections 
1b8c			; TODO for each word do a token look up to get the op code 
1b8c			; TODO need some means to flag to the exec that this is a byte code form    
1b8c			 
1b8c			 
1b8c			forthcompile: 
1b8c			 
1b8c			; 
1b8c			; line parse: 
1b8c			;       parse raw input buffer 
1b8c			;       tokenise the words 
1b8c			;       malloc new copy (for looping etc) 
1b8c			;       copy to malloc + current pc in line to start of string and add line term 
1b8c			;       save on new rsp 
1b8c			; 
1b8c			 
1b8c			; hl to point to the line to tokenise 
1b8c			 
1b8c			;	push hl 
1b8c 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1b8f			 
1b8f			;	ld a,0		; string term on input 
1b8f			;	call strlent 
1b8f			 
1b8f			;	ld (os_tok_len), hl	 ; save string length 
1b8f			 
1b8f			;if DEBUG_FORTH_TOK 
1b8f			;	ex de,hl		 
1b8f			;endif 
1b8f			 
1b8f			;	pop hl 		; get back string pointer 
1b8f			 
1b8f			if DEBUG_FORTH_TOK 
1b8f						DMARK "TOc" 
1b8f				CALLMONITOR 
1b8f			endif 
1b8f 7e			.cptoken2:    ld a,(hl) 
1b90 23				inc hl 
1b91 fe 7f			cp FORTH_END_BUFFER 
1b93 28 29			jr z, .cptokendone2 
1b95 fe 00			cp 0 
1b97 28 25			jr z, .cptokendone2 
1b99 fe 22			cp '"' 
1b9b 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1b9d fe 20			cp ' ' 
1b9f 20 ee			jr nz,  .cptoken2 
1ba1			 
1ba1			; TODO consume comments held between ( and ) 
1ba1			 
1ba1				; we have a space so change to zero term for dict match later 
1ba1 2b				dec hl 
1ba2 3e 00			ld a,0 
1ba4 77				ld (hl), a 
1ba5 23				inc hl 
1ba6 18 e7			jr .cptoken2 
1ba8				 
1ba8			 
1ba8			.cptokenstr2: 
1ba8				; skip all white space until either eol (because forgot to term) or end double quote 
1ba8			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ba8				;inc hl ; skip current double quote 
1ba8 7e				ld a,(hl) 
1ba9 23				inc hl 
1baa fe 22			cp '"' 
1bac 28 e1			jr z, .cptoken2 
1bae fe 7f			cp FORTH_END_BUFFER 
1bb0 28 0c			jr z, .cptokendone2 
1bb2 fe 00			cp 0 
1bb4 28 08			jr z, .cptokendone2 
1bb6 fe 20			cp ' ' 
1bb8 28 02			jr z, .cptmp2 
1bba 18 ec			jr .cptokenstr2 
1bbc			 
1bbc			.cptmp2:	; we have a space so change to zero term for dict match later 
1bbc				;dec hl 
1bbc				;ld a,"-"	; TODO remove this when working 
1bbc				;ld (hl), a 
1bbc				;inc hl 
1bbc 18 ea			jr .cptokenstr2 
1bbe			 
1bbe			.cptokendone2: 
1bbe				;inc hl 
1bbe 3e 7f			ld a, FORTH_END_BUFFER 
1bc0 77				ld (hl),a 
1bc1 23				inc hl 
1bc2 3e 21			ld a, '!' 
1bc4 77				ld (hl),a 
1bc5			 
1bc5 2a 33 f1			ld hl,(os_tok_ptr) 
1bc8			         
1bc8			if DEBUG_FORTH_TOK 
1bc8						DMARK "Tc1" 
1bc8				CALLMONITOR 
1bc8			endif 
1bc8			 
1bc8				; push exec string to top of return stack 
1bc8				FORTH_RSP_NEXT 
1bc8 cd 34 19			call macro_forth_rsp_next 
1bcb				endm 
# End of macro FORTH_RSP_NEXT
1bcb c9				ret 
1bcc			 
1bcc			; Another go at the parser need to simplify the process 
1bcc			 
1bcc			forthparse: 
1bcc			 
1bcc			; 
1bcc			; line parse: 
1bcc			;       parse raw input buffer 
1bcc			;       tokenise the words 
1bcc			;       malloc new copy (for looping etc) 
1bcc			;       copy to malloc + current pc in line to start of string and add line term 
1bcc			;       save on new rsp 
1bcc			; 
1bcc			 
1bcc			; hl to point to the line to tokenise 
1bcc			 
1bcc			;	push hl 
1bcc 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1bcf			 
1bcf			;	ld a,0		; string term on input 
1bcf			;	call strlent 
1bcf			 
1bcf			;	ld (os_tok_len), hl	 ; save string length 
1bcf			 
1bcf			;if DEBUG_FORTH_TOK 
1bcf			;	ex de,hl		 
1bcf			;endif 
1bcf			 
1bcf			;	pop hl 		; get back string pointer 
1bcf			 
1bcf			if DEBUG_FORTH_TOK 
1bcf						DMARK "TOK" 
1bcf				CALLMONITOR 
1bcf			endif 
1bcf 7e			.ptoken2:    ld a,(hl) 
1bd0 23				inc hl 
1bd1 fe 7f			cp FORTH_END_BUFFER 
1bd3 28 29			jr z, .ptokendone2 
1bd5 fe 00			cp 0 
1bd7 28 25			jr z, .ptokendone2 
1bd9 fe 22			cp '"' 
1bdb 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1bdd fe 20			cp ' ' 
1bdf 20 ee			jr nz,  .ptoken2 
1be1			 
1be1			; TODO consume comments held between ( and ) 
1be1			 
1be1				; we have a space so change to zero term for dict match later 
1be1 2b				dec hl 
1be2 3e 00			ld a,0 
1be4 77				ld (hl), a 
1be5 23				inc hl 
1be6 18 e7			jr .ptoken2 
1be8				 
1be8			 
1be8			.ptokenstr2: 
1be8				; skip all white space until either eol (because forgot to term) or end double quote 
1be8			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1be8				;inc hl ; skip current double quote 
1be8 7e				ld a,(hl) 
1be9 23				inc hl 
1bea fe 22			cp '"' 
1bec 28 e1			jr z, .ptoken2 
1bee fe 7f			cp FORTH_END_BUFFER 
1bf0 28 0c			jr z, .ptokendone2 
1bf2 fe 00			cp 0 
1bf4 28 08			jr z, .ptokendone2 
1bf6 fe 20			cp ' ' 
1bf8 28 02			jr z, .ptmp2 
1bfa 18 ec			jr .ptokenstr2 
1bfc			 
1bfc			.ptmp2:	; we have a space so change to zero term for dict match later 
1bfc				;dec hl 
1bfc				;ld a,"-"	; TODO remove this when working 
1bfc				;ld (hl), a 
1bfc				;inc hl 
1bfc 18 ea			jr .ptokenstr2 
1bfe			 
1bfe			.ptokendone2: 
1bfe				;inc hl 
1bfe 3e 7f			ld a, FORTH_END_BUFFER 
1c00 77				ld (hl),a 
1c01 23				inc hl 
1c02 3e 21			ld a, '!' 
1c04 77				ld (hl),a 
1c05			 
1c05 2a 33 f1			ld hl,(os_tok_ptr) 
1c08			         
1c08			if DEBUG_FORTH_TOK 
1c08						DMARK "TK1" 
1c08				CALLMONITOR 
1c08			endif 
1c08			 
1c08				; push exec string to top of return stack 
1c08				FORTH_RSP_NEXT 
1c08 cd 34 19			call macro_forth_rsp_next 
1c0b				endm 
# End of macro FORTH_RSP_NEXT
1c0b c9				ret 
1c0c			 
1c0c			; 
1c0c			;	; malloc size + buffer pointer + if is loop flag 
1c0c			;	ld hl,(os_tok_len) 		 ; get string length 
1c0c			; 
1c0c			;	ld a,l 
1c0c			; 
1c0c			;	cp 0			; we dont want to use a null string 
1c0c			;	ret z 
1c0c			; 
1c0c			;;	add 3    ; prefix malloc with buffer for current word ptr 
1c0c			; 
1c0c			;	add 5     ; TODO when certain not over writing memory remove 
1c0c			; 
1c0c			;		 
1c0c			; 
1c0c			;if DEBUG_FORTH_TOK 
1c0c			;			DMARK "TKE" 
1c0c			;	CALLMONITOR 
1c0c			;endif 
1c0c			; 
1c0c			;	ld l,a 
1c0c			;	ld h,0 
1c0c			;;	push hl   ; save required space for the copy later 
1c0c			;	call malloc 
1c0c			;if DEBUG_FORTH_TOK 
1c0c			;			DMARK "TKM" 
1c0c			;	CALLMONITOR 
1c0c			;endif 
1c0c			;	if DEBUG_FORTH_MALLOC_GUARD 
1c0c			;		push af 
1c0c			;		call ishlzero 
1c0c			;;		ld a, l 
1c0c			;;		add h 
1c0c			;;		cp 0 
1c0c			;		pop af 
1c0c			;		 
1c0c			;		call z,malloc_error 
1c0c			;	endif 
1c0c			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1c0c			; 
1c0c			; 
1c0c			;if DEBUG_FORTH_TOK 
1c0c			;			DMARK "TKR" 
1c0c			;	CALLMONITOR 
1c0c			;endif 
1c0c			; 
1c0c			;	FORTH_RSP_NEXT 
1c0c			; 
1c0c			;	;inc hl	 ; go past current buffer pointer 
1c0c			;	;inc hl 
1c0c			;	;inc hl   ; and past if loop flag 
1c0c			;		; TODO Need to set flag  
1c0c			; 
1c0c			;	 
1c0c			;	 
1c0c			;	ex de,hl	; malloc is dest 
1c0c			;	ld hl, (os_tok_len) 
1c0c			;;	pop bc 
1c0c			;	ld c, l                
1c0c			;	ld b,0 
1c0c			;	ld hl, (os_tok_ptr) 
1c0c			; 
1c0c			;if DEBUG_FORTH_TOK 
1c0c			;			DMARK "TKT" 
1c0c			;	CALLMONITOR 
1c0c			;endif 
1c0c			; 
1c0c			;	; do str cpy 
1c0c			; 
1c0c			;	ldir      ; copy byte in hl to de 
1c0c			; 
1c0c			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1c0c			; 
1c0c			;if DEBUG_FORTH_TOK 
1c0c			; 
1c0c			;			DMARK "TKY" 
1c0c			;	CALLMONITOR 
1c0c			;endif 
1c0c			;	;ld a,0 
1c0c			;	;ld a,FORTH_END_BUFFER 
1c0c			;	ex de, hl 
1c0c			;	;dec hl			 ; go back over the space delim at the end of word 
1c0c			;	;ld (hl),a 
1c0c			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1c0c			;	ld a,FORTH_END_BUFFER 
1c0c			;	ld (hl),a 
1c0c			;	inc hl 
1c0c			;	ld a,FORTH_END_BUFFER 
1c0c			;	ld (hl),a 
1c0c			; 
1c0c			;	; init the malloc area data 
1c0c			;	; set pc for in current area 
1c0c			;	;ld hl, (os_tok_malloc) 
1c0c			;	;inc hl 
1c0c			;	;inc hl 
1c0c			;	;inc hl 
1c0c			;	;ex de,hl 
1c0c			;	;ld hl, (os_tok_malloc) 
1c0c			;	;ld (hl),e 
1c0c			;	;inc hl 
1c0c			;	;ld (hl),d 
1c0c			; 
1c0c			; 
1c0c			;	ld hl,(os_tok_malloc) 
1c0c			;if DEBUG_FORTH_PARSE_KEY 
1c0c			;			DMARK "TKU" 
1c0c			;	CALLMONITOR 
1c0c			;endif 
1c0c			; 
1c0c			;	ret 
1c0c			 
1c0c			forthexec: 
1c0c			 
1c0c			; line exec: 
1c0c			; forth parser 
1c0c			 
1c0c			; 
1c0c			;       get current exec line on rsp 
1c0c			 
1c0c				FORTH_RSP_TOS 
1c0c cd 4b 19			call macro_forth_rsp_tos 
1c0f				endm 
# End of macro FORTH_RSP_TOS
1c0f			 
1c0f			;       restore current pc - hl points to malloc of data 
1c0f			 
1c0f				;ld e, (hl) 
1c0f				;inc hl 
1c0f				;ld d, (hl) 
1c0f				;ex de,hl 
1c0f			 
1c0f			 
1c0f			exec1: 
1c0f 22 33 f1			ld (os_tok_ptr), hl 
1c12			 
1c12				; copy our PC to working vars  
1c12 22 3d f8			ld (cli_ptr), hl 
1c15 22 3b f8			ld (cli_origptr), hl 
1c18			 
1c18 7e				ld a,(hl) 
1c19 fe 7f			cp FORTH_END_BUFFER 
1c1b c8				ret z 
1c1c			 
1c1c				; skip any nulls 
1c1c			 
1c1c fe 00			cp 0 
1c1e 20 03			jr nz, .execword 
1c20 23				inc hl 
1c21 18 ec			jr exec1 
1c23			 
1c23			 
1c23			.execword: 
1c23			 
1c23			 
1c23			 
1c23			if DEBUG_FORTH_PARSE_KEY 
1c23						DMARK "KYQ" 
1c23				CALLMONITOR 
1c23			endif 
1c23			;       while at start of word: 
1c23			; get start of dict (in user area first) 
1c23			 
1c23 21 00 80		ld hl, baseram 
1c26			;ld hl, sysdict 
1c26 22 3f f8		ld (cli_nextword),hl 
1c29			;           match word at pc 
1c29			;           exec word 
1c29			;           or push to dsp 
1c29			;           forward to next token 
1c29			;           if line term pop rsp and exit 
1c29			;        
1c29			 
1c29			if DEBUG_FORTH_PARSE_KEY 
1c29						DMARK "KYq" 
1c29				CALLMONITOR 
1c29			endif 
1c29			 
1c29			; 
1c29			; word comp 
1c29			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1c29			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1c29			;    move to start of word  
1c29			;    compare word to cli_token 
1c29			 
1c29			.execpnword:	; HL at start of a word in the dictionary to check 
1c29			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1c29			;	ld (cli_ptr), hl 
1c29			 
1c29 2a 3f f8			ld hl,(cli_nextword) 
1c2c			 
1c2c cd cf 1c			call forth_tok_next 
1c2f			; tok next start here 
1c2f			;	; TODO skip compiled symbol for now 
1c2f			;	inc hl 
1c2f			; 
1c2f			;	; save pointer to next word 
1c2f			; 
1c2f			;	; hl now points to the address of the next word pointer  
1c2f			;	ld e, (hl) 
1c2f			;	inc hl 
1c2f			;	ld d, (hl) 
1c2f			;	inc l 
1c2f			; 
1c2f			;	ex de,hl 
1c2f			;if DEBUG_FORTH_PARSE_NEXTWORD 
1c2f			;	push bc 
1c2f			;	ld bc, (cli_nextword) 
1c2f			;			DMARK "NXW" 
1c2f			;	CALLMONITOR 
1c2f			;	pop bc 
1c2f			;endif 
1c2f			; tok next end here 
1c2f 22 3f f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
1c32 eb				ex de, hl 
1c33			 
1c33			 
1c33				; save the pointer of the current token - 1 to check against 
1c33				 
1c33 22 43 f8			ld (cli_token), hl   
1c36				; TODO maybe remove below save if no debug 
1c36				; save token string ptr for any debug later 
1c36 23				inc hl  
1c37 22 45 f8			ld (cli_origtoken), hl 
1c3a 2b				dec hl 
1c3b				; save pointer to the start of the next dictionay word 
1c3b 7e				ld a,(hl)   ; get string length 
1c3c 47				ld b,a 
1c3d			.execpnwordinc:  
1c3d 23				inc hl 
1c3e 10 fd			djnz .execpnwordinc 
1c40 22 41 f8			ld (cli_execword), hl      ; save start of this words code 
1c43			 
1c43				; now check the word token against the string being parsed 
1c43			 
1c43 2a 43 f8			ld hl,(cli_token) 
1c46 23				inc hl     ; skip string length (use zero term instead to end) 
1c47 22 43 f8			ld (cli_token), hl 
1c4a			 
1c4a			if DEBUG_FORTH_PARSE_KEY 
1c4a						DMARK "KY2" 
1c4a			endif 
1c4a			if DEBUG_FORTH_PARSE_EXEC 
1c4a				; see if disabled 
1c4a			 
1c4a				ld a, (os_view_disable) 
1c4a				cp '*' 
1c4a				jr z, .skip 
1c4a			 
1c4a				push hl 
1c4a				push hl 
1c4a				call clear_display 
1c4a				ld de, .compword 
1c4a				ld a, display_row_1 
1c4a				call str_at_display 
1c4a				pop de 
1c4a				ld a, display_row_2 
1c4a				call str_at_display 
1c4a				ld hl,(cli_ptr) 
1c4a				ld a,(hl) 
1c4a			        ld hl, os_word_scratch 
1c4a				ld (hl),a 
1c4a				ld a,0 
1c4a				inc hl 
1c4a				ld (hl),a 	 
1c4a				ld de, os_word_scratch 
1c4a				ld a, display_row_2+10 
1c4a				call str_at_display 
1c4a				call update_display 
1c4a				ld a, 100 
1c4a				call aDelayInMS 
1c4a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c4a				call delay250ms 
1c4a				endif 
1c4a				pop hl 
1c4a			.skip:  
1c4a			endif	 
1c4a			.execpnchar:    ; compare char between token and string to parse 
1c4a			 
1c4a			if DEBUG_FORTH_PARSE_KEY 
1c4a						DMARK "Ky3" 
1c4a			endif 
1c4a			if DEBUG_FORTH_PARSE_EXEC 
1c4a				; see if disabled 
1c4a			 
1c4a				ld a, (os_view_disable) 
1c4a				cp '*' 
1c4a				jr z, .skip2 
1c4a			 
1c4a			;	call clear_display 
1c4a			ld hl,(cli_token) 
1c4a			ld a,(hl) 
1c4a			ld (os_word_scratch),a 
1c4a				ld hl,(cli_ptr) 
1c4a			ld a,(hl) 
1c4a				ld (os_word_scratch+1),a 
1c4a				ld a,0 
1c4a				ld (os_word_scratch+2),a 
1c4a				ld de,os_word_scratch 
1c4a				ld a,display_row_4 
1c4a				call str_at_display 
1c4a				call update_display 
1c4a			.skip2:  
1c4a			endif 
1c4a 2a 43 f8			ld hl,(cli_token) 
1c4d 7e				ld a, (hl)	 ; char in word token 
1c4e 23				inc hl 		; move to next char 
1c4f 22 43 f8			ld (cli_token), hl ; and save it 
1c52 47				ld b,a 
1c53			 
1c53 2a 3d f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
1c56 7e				ld a,(hl) 
1c57 23				inc hl 
1c58 22 3d f8			ld (cli_ptr), hl		; move to next char 
1c5b cd 67 10			call toUpper 		; make sure the input string matches case 
1c5e			 
1c5e			if DEBUG_FORTH_PARSE 
1c5e			endif 
1c5e			 
1c5e				; input stream end of token is a space so get rid of it 
1c5e			 
1c5e			;	cp ' ' 
1c5e			;	jr nz, .pnskipspace 
1c5e			; 
1c5e			;	ld a, 0		; make same term as word token term 
1c5e			; 
1c5e			;.pnskipspace: 
1c5e			 
1c5e			if DEBUG_FORTH_PARSE_KEY 
1c5e						DMARK "KY7" 
1c5e			endif 
1c5e b8				cp b 
1c5f c2 75 1c			jp nz, .execpnskipword	 ; no match so move to next word 
1c62				 
1c62			;    if same 
1c62			;       scan for string terms 0 for token and 32 for input 
1c62			 
1c62				 
1c62			if DEBUG_FORTH_PARSE_KEY 
1c62						DMARK "KY8" 
1c62			endif 
1c62			 
1c62 80				add b			 
1c63 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1c65							; TODO need to make sure last word in zero term string is accounted for 
1c65 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1c67			 
1c67			 
1c67				; at end of both strings so both are exact match 
1c67			 
1c67			;       skip ptr for next word 
1c67			 
1c67 2a 3d f8			ld hl,(cli_ptr) 	; at input string term 
1c6a 23				inc hl			 ; at next char 
1c6b 22 3d f8			ld (cli_ptr), hl     ; save for next round of the parser 
1c6e 22 3b f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1c71				 
1c71				 
1c71			if DEBUG_FORTH_PARSE_KEY 
1c71						DMARK "KY3" 
1c71			endif 
1c71			 
1c71			 
1c71			 
1c71			;       exec code block 
1c71			if DEBUG_FORTH_JP 
1c71				call clear_display 
1c71				call update_display 
1c71				call delay1s 
1c71				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c71				ld a,h 
1c71				ld hl, os_word_scratch 
1c71				call hexout 
1c71				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c71				ld a,l 
1c71				ld hl, os_word_scratch+2 
1c71				call hexout 
1c71				ld hl, os_word_scratch+4 
1c71				ld a,0 
1c71				ld (hl),a 
1c71				ld de,os_word_scratch 
1c71				call str_at_display 
1c71					ld a, display_row_2 
1c71					call str_at_display 
1c71				ld de, (cli_origtoken) 
1c71				ld a, display_row_1+10 
1c71					call str_at_display 
1c71			 
1c71				ld a,display_row_1 
1c71				ld de, .foundword 
1c71				ld a, display_row_3 
1c71				call str_at_display 
1c71				call update_display 
1c71				call delay1s 
1c71				call delay1s 
1c71				call delay1s 
1c71			endif 
1c71			 
1c71			if DEBUG_FORTH_PARSE_KEY 
1c71						DMARK "KYj" 
1c71			endif 
1c71				; TODO save the word pointer in this exec 
1c71			 
1c71 2a 41 f8			ld hl,(cli_execword) 
1c74 e9				jp (hl) 
1c75			 
1c75			 
1c75			;    if not same 
1c75			;	scan for zero term 
1c75			;	get ptr for next word 
1c75			;	goto word comp 
1c75			 
1c75			.execpnskipword:	; get pointer to next word 
1c75 2a 3f f8			ld hl,(cli_nextword) 
1c78			 
1c78 7e				ld a,(hl) 
1c79 fe 00			cp WORD_SYS_END 
1c7b			;	cp 0 
1c7b 28 09			jr z, .execendofdict			 ; at end of words 
1c7d			 
1c7d			if DEBUG_FORTH_PARSE_KEY 
1c7d						DMARK "KY4" 
1c7d			endif 
1c7d			if DEBUG_FORTH_PARSE_EXEC 
1c7d			 
1c7d				; see if disabled 
1c7d			 
1c7d				ld a, (os_view_disable) 
1c7d				cp '*' 
1c7d				jr z, .noskip 
1c7d			 
1c7d			 
1c7d				ld de, .nowordfound 
1c7d				ld a, display_row_3 
1c7d				call str_at_display 
1c7d				call update_display 
1c7d				ld a, 100 
1c7d				call aDelayInMS 
1c7d				 
1c7d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c7d					call delay250ms 
1c7d				endif 
1c7d			.noskip:  
1c7d			 
1c7d			endif	 
1c7d			 
1c7d 2a 3b f8			ld hl,(cli_origptr) 
1c80 22 3d f8			ld (cli_ptr),hl 
1c83			 
1c83			if DEBUG_FORTH_PARSE_KEY 
1c83						DMARK "KY5" 
1c83			endif 
1c83 c3 29 1c			jp .execpnword			; else go to next word 
1c86			 
1c86			.execendofdict:  
1c86			 
1c86			if DEBUG_FORTH_PARSE_KEY 
1c86						DMARK "KYe" 
1c86			endif 
1c86			if DEBUG_FORTH_PARSE_EXEC 
1c86				; see if disabled 
1c86			 
1c86				ld a, (os_view_disable) 
1c86				cp '*' 
1c86				jr z, .ispskip 
1c86			 
1c86				call clear_display 
1c86				call update_display 
1c86				call delay1s 
1c86				ld de, (cli_origptr) 
1c86				ld a, display_row_1 
1c86				call str_at_display 
1c86				 
1c86				ld de, .enddict 
1c86				ld a, display_row_3 
1c86				call str_at_display 
1c86				call update_display 
1c86				ld a, 100 
1c86				call aDelayInMS 
1c86				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c86				call delay1s 
1c86				call delay1s 
1c86				call delay1s 
1c86				endif 
1c86			.ispskip:  
1c86				 
1c86			endif	 
1c86			 
1c86			 
1c86			 
1c86				; if the word is not a keyword then must be a literal so push it to stack 
1c86			 
1c86			; push token to stack to end of word 
1c86			 
1c86				STACKFRAME ON $1efe $2f9f 
1c86				if DEBUG_STACK_IMB 
1c86					if ON 
1c86						exx 
1c86						ld de, $1efe 
1c86						ld a, d 
1c86						ld hl, curframe 
1c86						call hexout 
1c86						ld a, e 
1c86						ld hl, curframe+2 
1c86						call hexout 
1c86						ld hl, $1efe 
1c86						push hl 
1c86						ld hl, $2f9f 
1c86						push hl 
1c86						exx 
1c86					endif 
1c86				endif 
1c86			endm 
# End of macro STACKFRAME
1c86			 
1c86 2a 33 f1		ld hl,(os_tok_ptr) 
1c89 cd d5 19		call forth_apush 
1c8c			 
1c8c				STACKFRAMECHK ON $1efe $2f9f 
1c8c				if DEBUG_STACK_IMB 
1c8c					if ON 
1c8c						exx 
1c8c						ld hl, $2f9f 
1c8c						pop de   ; $2f9f 
1c8c						call cmp16 
1c8c						jr nz, .spnosame 
1c8c						ld hl, $1efe 
1c8c						pop de   ; $1efe 
1c8c						call cmp16 
1c8c						jr z, .spfrsame 
1c8c						.spnosame: call showsperror 
1c8c						.spfrsame: nop 
1c8c						exx 
1c8c					endif 
1c8c				endif 
1c8c			endm 
# End of macro STACKFRAMECHK
1c8c			 
1c8c			execnext: 
1c8c			 
1c8c			if DEBUG_FORTH_PARSE_KEY 
1c8c						DMARK "KY>" 
1c8c			endif 
1c8c			; move past token to next word 
1c8c			 
1c8c 2a 33 f1		ld hl, (os_tok_ptr) 
1c8f 3e 00		ld a, 0 
1c91 01 ff 00		ld bc, 255     ; input buffer size 
1c94 ed b1		cpir 
1c96			 
1c96			if DEBUG_FORTH_PARSE_KEY 
1c96						DMARK "KY!" 
1c96				CALLMONITOR 
1c96			endif	 
1c96			; TODO this might place hl on the null, so will need to forward on??? 
1c96			;inc hl   ; see if this gets onto the next item 
1c96			 
1c96			 
1c96			; TODO pass a pointer to the buffer to push 
1c96			; TODO call function to push 
1c96			 
1c96			; look for end of input 
1c96			 
1c96			;inc hl 
1c96			;ld a,(hl) 
1c96			;cp FORTH_END_BUFFER 
1c96			;ret z 
1c96			 
1c96			 
1c96 c3 0f 1c		jp exec1 
1c99			 
1c99			 
1c99			 
1c99			 
1c99			 
1c99			 
1c99			 
1c99			 
1c99			 
1c99			findnexttok: 
1c99			 
1c99				; hl is pointer to move 
1c99				; de is the token to locate 
1c99			 
1c99					if DEBUG_FORTH 
1c99						DMARK "NTK" 
1c99						CALLMONITOR 
1c99					endif 
1c99 d5				push de 
1c9a			 
1c9a			.fnt1:	 
1c9a				; find first char of token to locate 
1c9a			 
1c9a 1a				ld a, (de) 
1c9b 4f				ld c,a 
1c9c 7e				ld a,(hl) 
1c9d cd 67 10			call toUpper 
1ca0					if DEBUG_FORTH 
1ca0						DMARK "NT1" 
1ca0						CALLMONITOR 
1ca0					endif 
1ca0 b9				cp c 
1ca1			 
1ca1 28 03			jr z, .fnt2cmpmorefirst	 
1ca3			 
1ca3				; first char not found move to next char 
1ca3			 
1ca3 23				inc hl 
1ca4 18 f4			jr .fnt1 
1ca6			 
1ca6			.fnt2cmpmorefirst:	 
1ca6				; first char of token found.  
1ca6			 
1ca6 e5				push hl     ; save start of token just in case it is the right one 
1ca7 d9				exx 
1ca8 e1				pop hl        ; save it to hl' 
1ca9 d9				exx 
1caa			 
1caa			 
1caa			.fnt2cmpmore:	 
1caa				; compare the rest 
1caa				 
1caa 23				inc hl 
1cab 13				inc de 
1cac				 
1cac 1a				ld a, (de) 
1cad 4f				ld c,a 
1cae 7e				ld a,(hl) 
1caf cd 67 10			call toUpper 
1cb2			 
1cb2					if DEBUG_FORTH 
1cb2						DMARK "NT2" 
1cb2						CALLMONITOR 
1cb2					endif 
1cb2				; c has the token to find char 
1cb2				; a has the mem to scan char 
1cb2			 
1cb2 b9				cp c 
1cb3 28 04			jr z,.fntmatch1 
1cb5			 
1cb5				; they are not the same 
1cb5			 
1cb5					if DEBUG_FORTH 
1cb5						DMARK "NT3" 
1cb5						CALLMONITOR 
1cb5					endif 
1cb5 d1				pop de	; reset de token to look for 
1cb6 d5				push de 
1cb7 18 e1			jr .fnt1 
1cb9				 
1cb9			.fntmatch1: 
1cb9			 
1cb9				; is the same char a null which means we might have a full hit? 
1cb9					if DEBUG_FORTH 
1cb9						DMARK "NT4" 
1cb9						CALLMONITOR 
1cb9					endif 
1cb9			 
1cb9 fe 00			cp 0 
1cbb 28 0b			jr z, .fntmatchyes 
1cbd			 
1cbd				; are we at the end of the token to find? 
1cbd			 
1cbd					if DEBUG_FORTH 
1cbd						DMARK "NT5" 
1cbd						CALLMONITOR 
1cbd					endif 
1cbd 3e 00			ld a, 0 
1cbf b9				cp c 
1cc0			 
1cc0 c2 aa 1c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1cc3			 
1cc3					if DEBUG_FORTH 
1cc3						DMARK "NT6" 
1cc3						CALLMONITOR 
1cc3					endif 
1cc3				; token to find is exhusted but no match to stream 
1cc3			 
1cc3				; restore tok pointer and continue on 
1cc3 d1				pop de 
1cc4 d5				push de 
1cc5 c3 9a 1c			jp .fnt1 
1cc8			 
1cc8			 
1cc8			.fntmatchyes: 
1cc8			 
1cc8				; hl now contains the end of the found token 
1cc8			 
1cc8				; get rid of saved token pointer to find 
1cc8			 
1cc8 d1				pop de 
1cc9			 
1cc9					if DEBUG_FORTH 
1cc9						DMARK "NT9" 
1cc9						CALLMONITOR 
1cc9					endif 
1cc9			 
1cc9				; hl will be on the null term so forward on 
1cc9			 
1cc9				; get back the saved start of the token 
1cc9			 
1cc9 d9				exx 
1cca e5				push hl     ; save start of token just in case it is the right one 
1ccb d9				exx 
1ccc e1				pop hl        ; save it to hl 
1ccd			 
1ccd c9				ret 
1cce			 
1cce			 
1cce			; LIST needs to find a specific token   
1cce			; FORGET needs to find a spefici token 
1cce			 
1cce			; SAVE needs to find all tokens by flag 
1cce			; WORDS just needs to scan through all  by flag 
1cce			; UWORDS needs to scan through all by flag 
1cce			 
1cce			 
1cce			; given hl as pointer to start of dict look up string 
1cce			; return hl as pointer to start of word block 
1cce			; or 0 if not found 
1cce			 
1cce			forth_find_tok: 
1cce c9				ret 
1ccf			 
1ccf			; given hl as pointer to dict structure 
1ccf			; move to the next dict block structure 
1ccf			 
1ccf			forth_tok_next: 
1ccf				; hl now points to the address of the next word pointer  
1ccf				; TODO skip compiled symbol for now 
1ccf			;	push de 
1ccf 23				inc hl 
1cd0 5e				ld e, (hl) 
1cd1 23				inc hl 
1cd2 56				ld d, (hl) 
1cd3 23				inc hl 
1cd4			 
1cd4 eb				ex de,hl 
1cd5			if DEBUG_FORTH_PARSE_NEXTWORD 
1cd5				push bc 
1cd5				ld bc, (cli_nextword) 
1cd5						DMARK "NXW" 
1cd5				CALLMONITOR 
1cd5				pop bc 
1cd5			endif 
1cd5			;	pop de	 
1cd5 c9				ret 
1cd6			 
1cd6			 
1cd6			 
1cd6			; eof 
# End of file forth_parserv5.asm
1cd6				include "forth_wordsv4.asm" 
1cd6			 
1cd6			; the core word dictionary v4 
1cd6			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1cd6			 
1cd6			; this is a linked list for each of the system words used 
1cd6			; user defined words will follow the same format but will be in ram 
1cd6			 
1cd6			 
1cd6			; 
1cd6			; 
1cd6			; define linked list: 
1cd6			; 
1cd6			; 1. compiled byte op code 
1cd6			; 2. len of text word 
1cd6			; 3. text word 
1cd6			; 4. ptr to next dictionary word 
1cd6			; 5. asm, calls etc for the word 
1cd6			; 
1cd6			;  if 1 == 0 then last word in dict  
1cd6			;   
1cd6			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1cd6			;  
1cd6			;  
1cd6			; create basic standard set of words 
1cd6			; 
1cd6			;  
1cd6			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1cd6			; 2DUP 2DROP 2SWAP  
1cd6			; @ C@ - get byte  
1cd6			; ! C! - store byte 
1cd6			; 0< true if less than zero 
1cd6			; 0= true if zero 
1cd6			; < >  
1cd6			; = true if same 
1cd6			; variables 
1cd6			 
1cd6			 
1cd6			; Hardware specific words I may need 
1cd6			; 
1cd6			; IN OUT  
1cd6			; calls to key util functions 
1cd6			; calls to hardward abstraction stuff 
1cd6			; easy control of frame buffers and lcd i/o 
1cd6			; keyboard  
1cd6			 
1cd6			 
1cd6			;DICT: macro 
1cd6			; op_code, len, word, next 
1cd6			;    word: 
1cd6			;    db op_code 
1cd6			;    ds word zero term 
1cd6			;    dw next 
1cd6			;    endm 
1cd6			 
1cd6			 
1cd6			 
1cd6			 
1cd6			; op code 1 is a flag for user define words which are to be handled differently 
1cd6			 
1cd6			 
1cd6			; 
1cd6			; 
1cd6			;    TODO on entry to a word this should be the expected environment 
1cd6			;    hl - tos value if number then held, if string this is the ptr 
1cd6			;    de -  
1cd6			 
1cd6			 
1cd6			; opcode ranges 
1cd6			; 0 - end of word dict 
1cd6			; 255 - user define words 
1cd6			 
1cd6			sysdict: 
1cd6			include "forth_opcodes.asm" 
1cd6			; op codes for forth keywords 
1cd6			; free to use code 0  
1cd6				OPCODE_HEAP: equ  1 
1cd6				OPCODE_EXEC: equ 2 
1cd6				OPCODE_DUP: equ 3 
1cd6				OPCODE_SWAP: equ 4 
1cd6				OPCODE_COLN: equ 5 
1cd6				OPCODE_SCOLN: equ 6 
1cd6				OPCODE_DROP: equ 7 
1cd6				OPCODE_DUP2: equ 8 
1cd6				OPCODE_DROP2: equ 9 
1cd6				OPCODE_SWAP2: equ 10 
1cd6				OPCODE_AT: equ 11 
1cd6				OPCODE_CAT: equ 12 
1cd6				OPCODE_BANG: equ 13 
1cd6				OPCODE_CBANG: equ 14 
1cd6				OPCODE_SCALL: equ 15 
1cd6				OPCODE_DEPTH: equ 16 
1cd6				OPCODE_OVER: equ 17 
1cd6				OPCODE_PAUSE: equ 18 
1cd6				OPCODE_PAUSES: equ 19 
1cd6				OPCODE_ROT: equ 20 
1cd6			;free to reuse	OPCODE_WORDS: equ 21 
1cd6			        OPCODE_NOT: equ 21 
1cd6				OPCODE_UWORDS: equ 22 
1cd6				OPCODE_BP: equ 23 
1cd6				OPCODE_MONITOR: equ 24  
1cd6				OPCODE_MALLOC: equ 25 
1cd6				OPCODE_FREE: equ 26 
1cd6				OPCODE_LIST: equ 27 
1cd6				OPCODE_FORGET: equ 28 
1cd6				OPCODE_NOP: equ 29 
1cd6				OPCODE_COMO: equ 30 
1cd6				OPCODE_COMC: equ 31 
1cd6			;free to reuse	OPCODE_ENDCORE: equ 32 
1cd6				OPCODE_AFTERSOUND: equ 33 
1cd6				OPCODE_GP2: equ 34 
1cd6				OPCODE_GP3: equ 35 
1cd6				OPCODE_GP4: equ 36 
1cd6				OPCODE_SIN: equ 37 
1cd6				OPCODE_SOUT: equ 38 
1cd6				OPCODE_SPIO: equ 39 
1cd6				OPCODE_SPICEH: equ 40 
1cd6				OPCODE_SPIOb: equ 41 
1cd6				OPCODE_SPII: equ 42 
1cd6				OPCODE_SESEL: equ 43 
1cd6				OPCODE_CARTDEV: equ 44 
1cd6			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1cd6				OPCODE_FB: equ 46 
1cd6				OPCODE_EMIT: equ 47 
1cd6				OPCODE_DOTH: equ 48 
1cd6				OPCODE_DOTF: equ 49 
1cd6				OPCODE_DOT: equ 50 
1cd6				OPCODE_CLS: equ 51 
1cd6				OPCODE_DRAW: equ 52 
1cd6				OPCODE_DUMP: equ 53 
1cd6				OPCODE_CDUMP: equ 54 
1cd6				OPCODE_DAT: equ 55 
1cd6				OPCODE_HOME: equ 56 
1cd6				OPCODE_SPACE: equ 57 
1cd6				OPCODE_SPACES: equ 58 
1cd6				OPCODE_SCROLL: equ 59 
1cd6				OPCODE_ATQ: equ 60 
1cd6				OPCODE_AUTODSP: equ 61 
1cd6				OPCODE_MENU: equ 62 
1cd6			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1cd6				OPCODE_THEN: equ 64 
1cd6				OPCODE_ELSE: equ 65 
1cd6				OPCODE_DO: equ 66 
1cd6				OPCODE_LOOP: equ 67 
1cd6				OPCODE_I: equ 68 
1cd6				OPCODE_DLOOP: equ 69  
1cd6				OPCODE_REPEAT: equ 70  
1cd6				OPCODE_UNTIL: equ 71 
1cd6				OPCODE_ENDFLOW: equ 72 
1cd6				OPCODE_WAITK: equ 73 
1cd6				OPCODE_ACCEPT: equ 74 
1cd6				OPCODE_EDIT: equ 75 
1cd6			;free to reuse	OPCODE_ENDKEY: equ 76 
1cd6				OPCODE_LZERO: equ 77 
1cd6				OPCODE_TZERO: equ 78 
1cd6				OPCODE_LESS: equ 79 
1cd6				OPCODE_GT: equ 80 
1cd6				OPCODE_EQUAL: equ 81  
1cd6			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1cd6				OPCODE_NEG: equ 83 
1cd6				OPCODE_DIV: equ 84 
1cd6				OPCODE_MUL: equ 85 
1cd6				OPCODE_MIN: equ 86 
1cd6				OPCODE_MAX: equ 87 
1cd6				OPCODE_RND16: equ 88 
1cd6				OPCODE_RND8: equ 89 
1cd6				OPCODE_RND: equ 90 
1cd6			;free to reuse	OPCODE_ENDMATHS: equ 91  
1cd6				OPCODE_BYNAME: equ 92 
1cd6				OPCODE_DIR: equ 93 
1cd6				OPCODE_SAVE: equ 94 
1cd6				OPCODE_LOAD: equ 95 
1cd6				OPCODE_BSAVE: equ 96 
1cd6				OPCODE_BLOAD: equ 97 
1cd6				OPCODE_SEO: equ 98  
1cd6				OPCODE_SEI: equ 99 
1cd6				OPCODE_SFREE: equ 100 
1cd6				OPCODE_SIZE: equ 101 
1cd6				OPCODE_CREATE: equ 102 
1cd6				OPCODE_APPEND: equ 103 
1cd6				OPCODE_SDEL: equ 104 
1cd6				OPCODE_OPEN: equ 105 
1cd6				OPCODE_READ: equ 106 
1cd6				OPCODE_EOF: equ 106 
1cd6				OPCODE_FORMAT: equ 107 
1cd6				OPCODE_LABEL: equ 108 
1cd6				OPCODE_LABELS: equ 109 
1cd6			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1cd6				OPCODE_UPPER: equ 111 
1cd6				OPCODE_LOWER: equ 112 
1cd6				OPCODE_SUBSTR: equ 113 
1cd6				OPCODE_LEFT: equ 114 
1cd6				OPCODE_RIGHT: equ 115 
1cd6				OPCODE_STR2NUM: equ 116 
1cd6				OPCODE_NUM2STR: equ 117 
1cd6				OPCODE_CONCAT: equ 118 
1cd6				OPCODE_FIND: equ 119 
1cd6				OPCODE_LEN: equ 120 
1cd6				OPCODE_CHAR: equ 121 
1cd6			; free to reuse	OPCODE_STRLEN: equ 122 
1cd6			; free to reuse	OPCODE_ENDSTR: equ 123 
1cd6				OPCODE_V0S: equ 124 
1cd6				OPCODE_V0Q: equ 125 
1cd6				OPCODE_V1S: equ 126 
1cd6				OPCODE_V1Q: equ 127 
1cd6				OPCODE_V2S: equ 128 
1cd6				OPCODE_V2Q: equ 129 
1cd6				OPCODE_V3S: equ 130 
1cd6				OPCODE_V3Q: equ 131 
1cd6			;free to reuse	OPCODE_END: equ 132 
1cd6				OPCODE_ZDUP: equ 133 
1cd6			 
1cd6			; eof 
# End of file forth_opcodes.asm
1cd6			 
1cd6			include "forth_words_core.asm" 
1cd6			 
1cd6			; | ## Core Words 
1cd6			 
1cd6			;if MALLOC_4 
1cd6			 
1cd6			.HEAP: 
1cd6				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1cd6 15				db WORD_SYS_CORE+OPCODE_HEAP             
1cd7 15 1d			dw .EXEC            
1cd9 05				db 4 + 1 
1cda .. 00			db "HEAP",0              
1cdf				endm 
# End of macro CWHEAD
1cdf			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1cdf			; | | u1 - Current number of bytes in the heap 
1cdf			; | | u2 - Remaining bytes left on the heap 
1cdf			; | |  
1cdf			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1cdf			 
1cdf			 
1cdf					if DEBUG_FORTH_WORDS_KEY 
1cdf						DMARK "HEP" 
1cdf f5				push af  
1ce0 3a f4 1c			ld a, (.dmark)  
1ce3 32 77 fb			ld (debug_mark),a  
1ce6 3a f5 1c			ld a, (.dmark+1)  
1ce9 32 78 fb			ld (debug_mark+1),a  
1cec 3a f6 1c			ld a, (.dmark+2)  
1cef 32 79 fb			ld (debug_mark+2),a  
1cf2 18 03			jr .pastdmark  
1cf4 ..			.dmark: db "HEP"  
1cf7 f1			.pastdmark: pop af  
1cf8			endm  
# End of macro DMARK
1cf8						CALLMONITOR 
1cf8 cd 00 14			call break_point_state  
1cfb				endm  
# End of macro CALLMONITOR
1cfb					endif 
1cfb 2a 0a 80				ld hl, (free_list )      
1cfe 11 0e 80				ld de, heap_start 
1d01			 
1d01 ed 52				sbc hl, de  
1d03			 
1d03 cd 8d 19				call forth_push_numhl 
1d06			 
1d06			 
1d06 ed 5b 0a 80			ld de, (free_list )      
1d0a 21 26 ee				ld hl, heap_end 
1d0d			 
1d0d ed 52				sbc hl, de 
1d0f			 
1d0f cd 8d 19				call forth_push_numhl 
1d12					 
1d12			 
1d12					 
1d12			 
1d12			 
1d12			 
1d12					NEXTW 
1d12 c3 7e 1b			jp macro_next 
1d15				endm 
# End of macro NEXTW
1d15			;endif 
1d15			 
1d15			.EXEC: 
1d15				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1d15 16				db WORD_SYS_CORE+OPCODE_EXEC             
1d16 b1 1d			dw .STKEXEC            
1d18 05				db 4 + 1 
1d19 .. 00			db "EXEC",0              
1d1e				endm 
# End of macro CWHEAD
1d1e			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1d1e			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1d1e			; | | 
1d1e			; | |   
1d1e				STACKFRAME OFF $5efe $5f9f 
1d1e				if DEBUG_STACK_IMB 
1d1e					if OFF 
1d1e						exx 
1d1e						ld de, $5efe 
1d1e						ld a, d 
1d1e						ld hl, curframe 
1d1e						call hexout 
1d1e						ld a, e 
1d1e						ld hl, curframe+2 
1d1e						call hexout 
1d1e						ld hl, $5efe 
1d1e						push hl 
1d1e						ld hl, $5f9f 
1d1e						push hl 
1d1e						exx 
1d1e					endif 
1d1e				endif 
1d1e			endm 
# End of macro STACKFRAME
1d1e			 
1d1e					if DEBUG_FORTH_WORDS_KEY 
1d1e						DMARK "EXE" 
1d1e f5				push af  
1d1f 3a 33 1d			ld a, (.dmark)  
1d22 32 77 fb			ld (debug_mark),a  
1d25 3a 34 1d			ld a, (.dmark+1)  
1d28 32 78 fb			ld (debug_mark+1),a  
1d2b 3a 35 1d			ld a, (.dmark+2)  
1d2e 32 79 fb			ld (debug_mark+2),a  
1d31 18 03			jr .pastdmark  
1d33 ..			.dmark: db "EXE"  
1d36 f1			.pastdmark: pop af  
1d37			endm  
# End of macro DMARK
1d37						CALLMONITOR 
1d37 cd 00 14			call break_point_state  
1d3a				endm  
# End of macro CALLMONITOR
1d3a					endif 
1d3a			 
1d3a				FORTH_DSP_VALUEHL 
1d3a cd 28 1a			call macro_dsp_valuehl 
1d3d				endm 
# End of macro FORTH_DSP_VALUEHL
1d3d			 
1d3d				FORTH_DSP_POP 
1d3d cd c4 1a			call macro_forth_dsp_pop 
1d40				endm 
# End of macro FORTH_DSP_POP
1d40			 
1d40					if DEBUG_FORTH_WORDS 
1d40						DMARK "EX1" 
1d40 f5				push af  
1d41 3a 55 1d			ld a, (.dmark)  
1d44 32 77 fb			ld (debug_mark),a  
1d47 3a 56 1d			ld a, (.dmark+1)  
1d4a 32 78 fb			ld (debug_mark+1),a  
1d4d 3a 57 1d			ld a, (.dmark+2)  
1d50 32 79 fb			ld (debug_mark+2),a  
1d53 18 03			jr .pastdmark  
1d55 ..			.dmark: db "EX1"  
1d58 f1			.pastdmark: pop af  
1d59			endm  
# End of macro DMARK
1d59						CALLMONITOR 
1d59 cd 00 14			call break_point_state  
1d5c				endm  
# End of macro CALLMONITOR
1d5c					endif 
1d5c			;	ld e,(hl) 
1d5c			;	inc hl 
1d5c			;	ld d,(hl) 
1d5c			;	ex de,hl 
1d5c			 
1d5c			;		if DEBUG_FORTH_WORDS 
1d5c			;			DMARK "EX2" 
1d5c			;			CALLMONITOR 
1d5c			;		endif 
1d5c e5				push hl 
1d5d			 
1d5d				;ld a, 0 
1d5d				;ld a, FORTH_END_BUFFER 
1d5d cd 70 10			call strlenz 
1d60 23				inc hl   ; include zero term to copy 
1d61 23				inc hl   ; include term 
1d62 23				inc hl   ; include term 
1d63 06 00			ld b,0 
1d65 4d				ld c,l 
1d66 e1				pop hl 
1d67 11 31 ef			ld de, execscratch 
1d6a					if DEBUG_FORTH_WORDS 
1d6a						DMARK "EX3" 
1d6a f5				push af  
1d6b 3a 7f 1d			ld a, (.dmark)  
1d6e 32 77 fb			ld (debug_mark),a  
1d71 3a 80 1d			ld a, (.dmark+1)  
1d74 32 78 fb			ld (debug_mark+1),a  
1d77 3a 81 1d			ld a, (.dmark+2)  
1d7a 32 79 fb			ld (debug_mark+2),a  
1d7d 18 03			jr .pastdmark  
1d7f ..			.dmark: db "EX3"  
1d82 f1			.pastdmark: pop af  
1d83			endm  
# End of macro DMARK
1d83						CALLMONITOR 
1d83 cd 00 14			call break_point_state  
1d86				endm  
# End of macro CALLMONITOR
1d86					endif 
1d86 ed b0			ldir 
1d88			 
1d88			 
1d88 21 31 ef			ld hl, execscratch 
1d8b			 
1d8b					if DEBUG_FORTH_WORDS 
1d8b						DMARK "EXe" 
1d8b f5				push af  
1d8c 3a a0 1d			ld a, (.dmark)  
1d8f 32 77 fb			ld (debug_mark),a  
1d92 3a a1 1d			ld a, (.dmark+1)  
1d95 32 78 fb			ld (debug_mark+1),a  
1d98 3a a2 1d			ld a, (.dmark+2)  
1d9b 32 79 fb			ld (debug_mark+2),a  
1d9e 18 03			jr .pastdmark  
1da0 ..			.dmark: db "EXe"  
1da3 f1			.pastdmark: pop af  
1da4			endm  
# End of macro DMARK
1da4						CALLMONITOR 
1da4 cd 00 14			call break_point_state  
1da7				endm  
# End of macro CALLMONITOR
1da7					endif 
1da7			 
1da7 cd cc 1b			call forthparse 
1daa cd 0c 1c			call forthexec 
1dad			;	call forthexec_cleanup 
1dad			;	call forthparse 
1dad			;	call forthexec 
1dad			 
1dad				STACKFRAMECHK OFF $5efe $5f9f 
1dad				if DEBUG_STACK_IMB 
1dad					if OFF 
1dad						exx 
1dad						ld hl, $5f9f 
1dad						pop de   ; $5f9f 
1dad						call cmp16 
1dad						jr nz, .spnosame 
1dad						ld hl, $5efe 
1dad						pop de   ; $5efe 
1dad						call cmp16 
1dad						jr z, .spfrsame 
1dad						.spnosame: call showsperror 
1dad						.spfrsame: nop 
1dad						exx 
1dad					endif 
1dad				endif 
1dad			endm 
# End of macro STACKFRAMECHK
1dad			 
1dad				; an immediate word so no need to process any more words 
1dad c9				ret 
1dae				NEXTW 
1dae c3 7e 1b			jp macro_next 
1db1				endm 
# End of macro NEXTW
1db1			 
1db1			; dead code - old version  
1db1			;	FORTH_RSP_NEXT 
1db1			 
1db1			;  
1db1			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1db1			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1db1			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1db1			;	push hl 
1db1			;	push de 
1db1			;	push bc 
1db1			; 
1db1			; 
1db1			;		if DEBUG_FORTH_WORDS_KEY 
1db1			;			DMARK "EXR" 
1db1			;			CALLMONITOR 
1db1			;		endif 
1db1			; 
1db1			; 
1db1			; 
1db1			;	;v5 FORTH_DSP_VALUE 
1db1			;	FORTH_DSP_VALUEHL 
1db1			; 
1db1			;	; TODO do string type checks 
1db1			; 
1db1			;;v5	inc hl   ; skip type 
1db1			; 
1db1			;	push hl  ; source code  
1db1			;		if DEBUG_FORTH_WORDS 
1db1			;			DMARK "EX1" 
1db1			;			CALLMONITOR 
1db1			;		endif 
1db1			;	ld a, 0 
1db1			;	call strlent 
1db1			; 
1db1			;	inc hl 
1db1			;	inc hl 
1db1			;	inc hl 
1db1			;	inc hl 
1db1			; 
1db1			;	push hl    ; size 
1db1			; 
1db1			;		if DEBUG_FORTH_WORDS 
1db1			;			DMARK "EX2" 
1db1			;			CALLMONITOR 
1db1			;		endif 
1db1			;	call malloc 
1db1			; 
1db1			;	ex de, hl    ; de now contains malloc area 
1db1			;	pop bc   	; get byte count 
1db1			;	pop hl      ; get string to copy 
1db1			; 
1db1			;	push de     ; save malloc for free later 
1db1			; 
1db1			;		if DEBUG_FORTH_WORDS 
1db1			;			DMARK "EX3" 
1db1			;			CALLMONITOR 
1db1			;		endif 
1db1			;	ldir       ; duplicate string 
1db1			; 
1db1			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1db1			;	 
1db1			;	; TODO fix the parse would be better than this...  
1db1			;	ex de, hl 
1db1			;	dec hl 
1db1			;	ld a, 0 
1db1			;	ld (hl), a 
1db1			;	dec hl 
1db1			;	ld a, ' ' 
1db1			;	ld (hl), a 
1db1			;	dec hl 
1db1			;	ld (hl), a 
1db1			; 
1db1			;	dec hl 
1db1			;	ld (hl), a 
1db1			; 
1db1			; 
1db1			;	FORTH_DSP_POP  
1db1			; 
1db1			;	pop hl     
1db1			;	push hl    ; save malloc area 
1db1			; 
1db1			;		if DEBUG_FORTH_WORDS 
1db1			;			DMARK "EX4" 
1db1			;			CALLMONITOR 
1db1			;		endif 
1db1			; 
1db1			;	call forthparse 
1db1			;	call forthexec 
1db1			;	 
1db1			;	pop hl 
1db1			;	if DEBUG_FORTH_WORDS 
1db1			;		DMARK "EX5" 
1db1			;		CALLMONITOR 
1db1			;	endif 
1db1			; 
1db1			;	if FORTH_ENABLE_FREE 
1db1			;	call free 
1db1			;	endif 
1db1			; 
1db1			;	if DEBUG_FORTH_WORDS 
1db1			;		DMARK "EX6" 
1db1			;		CALLMONITOR 
1db1			;	endif 
1db1			; 
1db1			;	pop bc 
1db1			;	pop de 
1db1			;	pop hl 
1db1			;;	FORTH_RSP_POP	  
1db1			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1db1			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1db1			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1db1			; 
1db1			;	if DEBUG_FORTH_WORDS 
1db1			;		DMARK "EX7" 
1db1			;		CALLMONITOR 
1db1			;	endif 
1db1			;	NEXTW 
1db1			 
1db1			.STKEXEC: 
1db1				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1db1 3f				db WORD_SYS_CORE+43             
1db2 f9 1e			dw .ZDUP            
1db4 08				db 7 + 1 
1db5 .. 00			db "STKEXEC",0              
1dbd				endm 
# End of macro CWHEAD
1dbd			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1dbd			 
1dbd			 
1dbd					if DEBUG_FORTH_WORDS_KEY 
1dbd						DMARK "STX" 
1dbd f5				push af  
1dbe 3a d2 1d			ld a, (.dmark)  
1dc1 32 77 fb			ld (debug_mark),a  
1dc4 3a d3 1d			ld a, (.dmark+1)  
1dc7 32 78 fb			ld (debug_mark+1),a  
1dca 3a d4 1d			ld a, (.dmark+2)  
1dcd 32 79 fb			ld (debug_mark+2),a  
1dd0 18 03			jr .pastdmark  
1dd2 ..			.dmark: db "STX"  
1dd5 f1			.pastdmark: pop af  
1dd6			endm  
# End of macro DMARK
1dd6						CALLMONITOR 
1dd6 cd 00 14			call break_point_state  
1dd9				endm  
# End of macro CALLMONITOR
1dd9					endif 
1dd9			 
1dd9				FORTH_DSP_VALUEHL 
1dd9 cd 28 1a			call macro_dsp_valuehl 
1ddc				endm 
# End of macro FORTH_DSP_VALUEHL
1ddc			 
1ddc 22 60 f8			ld (store_tmp1), hl    ; count 
1ddf			 
1ddf				FORTH_DSP_POP 
1ddf cd c4 1a			call macro_forth_dsp_pop 
1de2				endm 
# End of macro FORTH_DSP_POP
1de2			.stkexec1: 
1de2 2a 60 f8			ld hl, (store_tmp1)   ; count 
1de5 3e 00			ld a, 0 
1de7 bd				cp l 
1de8 c8				ret z 
1de9			 
1de9 2b				dec hl 
1dea 22 60 f8			ld (store_tmp1), hl    ; count 
1ded				 
1ded				FORTH_DSP_VALUEHL 
1ded cd 28 1a			call macro_dsp_valuehl 
1df0				endm 
# End of macro FORTH_DSP_VALUEHL
1df0 e5				push hl 
1df1				 
1df1					if DEBUG_FORTH_WORDS 
1df1						DMARK "EXp" 
1df1 f5				push af  
1df2 3a 06 1e			ld a, (.dmark)  
1df5 32 77 fb			ld (debug_mark),a  
1df8 3a 07 1e			ld a, (.dmark+1)  
1dfb 32 78 fb			ld (debug_mark+1),a  
1dfe 3a 08 1e			ld a, (.dmark+2)  
1e01 32 79 fb			ld (debug_mark+2),a  
1e04 18 03			jr .pastdmark  
1e06 ..			.dmark: db "EXp"  
1e09 f1			.pastdmark: pop af  
1e0a			endm  
# End of macro DMARK
1e0a						CALLMONITOR 
1e0a cd 00 14			call break_point_state  
1e0d				endm  
# End of macro CALLMONITOR
1e0d					endif 
1e0d				FORTH_DSP_POP 
1e0d cd c4 1a			call macro_forth_dsp_pop 
1e10				endm 
# End of macro FORTH_DSP_POP
1e10			 
1e10 cd 70 10			call strlenz 
1e13 23				inc hl   ; include zero term to copy 
1e14 23				inc hl   ; include zero term to copy 
1e15 23				inc hl   ; include zero term to copy 
1e16 06 00			ld b,0 
1e18 4d				ld c,l 
1e19 e1				pop hl 
1e1a 11 31 ef			ld de, execscratch 
1e1d					if DEBUG_FORTH_WORDS 
1e1d						DMARK "EX3" 
1e1d f5				push af  
1e1e 3a 32 1e			ld a, (.dmark)  
1e21 32 77 fb			ld (debug_mark),a  
1e24 3a 33 1e			ld a, (.dmark+1)  
1e27 32 78 fb			ld (debug_mark+1),a  
1e2a 3a 34 1e			ld a, (.dmark+2)  
1e2d 32 79 fb			ld (debug_mark+2),a  
1e30 18 03			jr .pastdmark  
1e32 ..			.dmark: db "EX3"  
1e35 f1			.pastdmark: pop af  
1e36			endm  
# End of macro DMARK
1e36						CALLMONITOR 
1e36 cd 00 14			call break_point_state  
1e39				endm  
# End of macro CALLMONITOR
1e39					endif 
1e39 ed b0			ldir 
1e3b			 
1e3b			 
1e3b 21 31 ef			ld hl, execscratch 
1e3e			 
1e3e					if DEBUG_FORTH_WORDS 
1e3e						DMARK "EXP" 
1e3e f5				push af  
1e3f 3a 53 1e			ld a, (.dmark)  
1e42 32 77 fb			ld (debug_mark),a  
1e45 3a 54 1e			ld a, (.dmark+1)  
1e48 32 78 fb			ld (debug_mark+1),a  
1e4b 3a 55 1e			ld a, (.dmark+2)  
1e4e 32 79 fb			ld (debug_mark+2),a  
1e51 18 03			jr .pastdmark  
1e53 ..			.dmark: db "EXP"  
1e56 f1			.pastdmark: pop af  
1e57			endm  
# End of macro DMARK
1e57						CALLMONITOR 
1e57 cd 00 14			call break_point_state  
1e5a				endm  
# End of macro CALLMONITOR
1e5a					endif 
1e5a			 
1e5a cd cc 1b			call forthparse 
1e5d 21 31 ef			ld hl, execscratch 
1e60					if DEBUG_FORTH_WORDS 
1e60						DMARK "EXx" 
1e60 f5				push af  
1e61 3a 75 1e			ld a, (.dmark)  
1e64 32 77 fb			ld (debug_mark),a  
1e67 3a 76 1e			ld a, (.dmark+1)  
1e6a 32 78 fb			ld (debug_mark+1),a  
1e6d 3a 77 1e			ld a, (.dmark+2)  
1e70 32 79 fb			ld (debug_mark+2),a  
1e73 18 03			jr .pastdmark  
1e75 ..			.dmark: db "EXx"  
1e78 f1			.pastdmark: pop af  
1e79			endm  
# End of macro DMARK
1e79						CALLMONITOR 
1e79 cd 00 14			call break_point_state  
1e7c				endm  
# End of macro CALLMONITOR
1e7c					endif 
1e7c cd 0c 1c			call forthexec 
1e7f			 
1e7f c3 e2 1d			jp .stkexec1 
1e82			 
1e82 c9				ret 
1e83			 
1e83			 
1e83			.DUP: 
1e83				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1e83 17				db WORD_SYS_CORE+OPCODE_DUP             
1e84 f9 1e			dw .ZDUP            
1e86 04				db 3 + 1 
1e87 .. 00			db "DUP",0              
1e8b				endm 
# End of macro CWHEAD
1e8b			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1e8b			 
1e8b					if DEBUG_FORTH_WORDS_KEY 
1e8b						DMARK "DUP" 
1e8b f5				push af  
1e8c 3a a0 1e			ld a, (.dmark)  
1e8f 32 77 fb			ld (debug_mark),a  
1e92 3a a1 1e			ld a, (.dmark+1)  
1e95 32 78 fb			ld (debug_mark+1),a  
1e98 3a a2 1e			ld a, (.dmark+2)  
1e9b 32 79 fb			ld (debug_mark+2),a  
1e9e 18 03			jr .pastdmark  
1ea0 ..			.dmark: db "DUP"  
1ea3 f1			.pastdmark: pop af  
1ea4			endm  
# End of macro DMARK
1ea4						CALLMONITOR 
1ea4 cd 00 14			call break_point_state  
1ea7				endm  
# End of macro CALLMONITOR
1ea7					endif 
1ea7			 
1ea7					FORTH_DSP 
1ea7 cd 0d 1a			call macro_forth_dsp 
1eaa				endm 
# End of macro FORTH_DSP
1eaa			 
1eaa 7e					ld a, (HL) 
1eab fe 01				cp DS_TYPE_STR 
1ead 20 25				jr nz, .dupinum 
1eaf			 
1eaf					; push another string 
1eaf			 
1eaf					FORTH_DSP_VALUEHL     		 
1eaf cd 28 1a			call macro_dsp_valuehl 
1eb2				endm 
# End of macro FORTH_DSP_VALUEHL
1eb2			 
1eb2				if DEBUG_FORTH_WORDS 
1eb2					DMARK "DUs" 
1eb2 f5				push af  
1eb3 3a c7 1e			ld a, (.dmark)  
1eb6 32 77 fb			ld (debug_mark),a  
1eb9 3a c8 1e			ld a, (.dmark+1)  
1ebc 32 78 fb			ld (debug_mark+1),a  
1ebf 3a c9 1e			ld a, (.dmark+2)  
1ec2 32 79 fb			ld (debug_mark+2),a  
1ec5 18 03			jr .pastdmark  
1ec7 ..			.dmark: db "DUs"  
1eca f1			.pastdmark: pop af  
1ecb			endm  
# End of macro DMARK
1ecb					CALLMONITOR 
1ecb cd 00 14			call break_point_state  
1ece				endm  
# End of macro CALLMONITOR
1ece				endif 
1ece cd 9f 19				call forth_push_str 
1ed1			 
1ed1					NEXTW 
1ed1 c3 7e 1b			jp macro_next 
1ed4				endm 
# End of macro NEXTW
1ed4			 
1ed4			 
1ed4			.dupinum: 
1ed4					 
1ed4			 
1ed4			 
1ed4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ed4 cd 28 1a			call macro_dsp_valuehl 
1ed7				endm 
# End of macro FORTH_DSP_VALUEHL
1ed7			 
1ed7				; TODO add floating point number detection 
1ed7			 
1ed7				if DEBUG_FORTH_WORDS 
1ed7					DMARK "DUi" 
1ed7 f5				push af  
1ed8 3a ec 1e			ld a, (.dmark)  
1edb 32 77 fb			ld (debug_mark),a  
1ede 3a ed 1e			ld a, (.dmark+1)  
1ee1 32 78 fb			ld (debug_mark+1),a  
1ee4 3a ee 1e			ld a, (.dmark+2)  
1ee7 32 79 fb			ld (debug_mark+2),a  
1eea 18 03			jr .pastdmark  
1eec ..			.dmark: db "DUi"  
1eef f1			.pastdmark: pop af  
1ef0			endm  
# End of macro DMARK
1ef0					CALLMONITOR 
1ef0 cd 00 14			call break_point_state  
1ef3				endm  
# End of macro CALLMONITOR
1ef3				endif 
1ef3			 
1ef3 cd 8d 19				call forth_push_numhl 
1ef6					NEXTW 
1ef6 c3 7e 1b			jp macro_next 
1ef9				endm 
# End of macro NEXTW
1ef9			.ZDUP: 
1ef9				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1ef9 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1efa 31 1f			dw .SWAP            
1efc 05				db 4 + 1 
1efd .. 00			db "?DUP",0              
1f02				endm 
# End of macro CWHEAD
1f02			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f02			 
1f02					if DEBUG_FORTH_WORDS_KEY 
1f02						DMARK "qDU" 
1f02 f5				push af  
1f03 3a 17 1f			ld a, (.dmark)  
1f06 32 77 fb			ld (debug_mark),a  
1f09 3a 18 1f			ld a, (.dmark+1)  
1f0c 32 78 fb			ld (debug_mark+1),a  
1f0f 3a 19 1f			ld a, (.dmark+2)  
1f12 32 79 fb			ld (debug_mark+2),a  
1f15 18 03			jr .pastdmark  
1f17 ..			.dmark: db "qDU"  
1f1a f1			.pastdmark: pop af  
1f1b			endm  
# End of macro DMARK
1f1b						CALLMONITOR 
1f1b cd 00 14			call break_point_state  
1f1e				endm  
# End of macro CALLMONITOR
1f1e					endif 
1f1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f1e cd 28 1a			call macro_dsp_valuehl 
1f21				endm 
# End of macro FORTH_DSP_VALUEHL
1f21			 
1f21 e5					push hl 
1f22			 
1f22					; is it a zero? 
1f22			 
1f22 3e 00				ld a, 0 
1f24 84					add h 
1f25 85					add l 
1f26			 
1f26 e1					pop hl 
1f27			 
1f27 fe 00				cp 0 
1f29 28 03				jr z, .dup2orig 
1f2b			 
1f2b			 
1f2b cd 8d 19				call forth_push_numhl 
1f2e			 
1f2e			 
1f2e				; TODO add floating point number detection 
1f2e			 
1f2e			.dup2orig: 
1f2e			 
1f2e					NEXTW 
1f2e c3 7e 1b			jp macro_next 
1f31				endm 
# End of macro NEXTW
1f31			.SWAP: 
1f31				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f31 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f32 70 1f			dw .COLN            
1f34 05				db 4 + 1 
1f35 .. 00			db "SWAP",0              
1f3a				endm 
# End of macro CWHEAD
1f3a			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f3a					if DEBUG_FORTH_WORDS_KEY 
1f3a						DMARK "SWP" 
1f3a f5				push af  
1f3b 3a 4f 1f			ld a, (.dmark)  
1f3e 32 77 fb			ld (debug_mark),a  
1f41 3a 50 1f			ld a, (.dmark+1)  
1f44 32 78 fb			ld (debug_mark+1),a  
1f47 3a 51 1f			ld a, (.dmark+2)  
1f4a 32 79 fb			ld (debug_mark+2),a  
1f4d 18 03			jr .pastdmark  
1f4f ..			.dmark: db "SWP"  
1f52 f1			.pastdmark: pop af  
1f53			endm  
# End of macro DMARK
1f53						CALLMONITOR 
1f53 cd 00 14			call break_point_state  
1f56				endm  
# End of macro CALLMONITOR
1f56					endif 
1f56			 
1f56					FORTH_DSP_VALUEHL 
1f56 cd 28 1a			call macro_dsp_valuehl 
1f59				endm 
# End of macro FORTH_DSP_VALUEHL
1f59 e5					push hl     ; w2 
1f5a			 
1f5a					FORTH_DSP_POP 
1f5a cd c4 1a			call macro_forth_dsp_pop 
1f5d				endm 
# End of macro FORTH_DSP_POP
1f5d			 
1f5d					FORTH_DSP_VALUEHL 
1f5d cd 28 1a			call macro_dsp_valuehl 
1f60				endm 
# End of macro FORTH_DSP_VALUEHL
1f60			 
1f60					FORTH_DSP_POP 
1f60 cd c4 1a			call macro_forth_dsp_pop 
1f63				endm 
# End of macro FORTH_DSP_POP
1f63			 
1f63 d1					pop de     ; w2	, hl = w1 
1f64			 
1f64 eb					ex de, hl 
1f65 d5					push de 
1f66			 
1f66 cd 8d 19				call forth_push_numhl 
1f69			 
1f69 e1					pop hl 
1f6a			 
1f6a cd 8d 19				call forth_push_numhl 
1f6d					 
1f6d			 
1f6d					NEXTW 
1f6d c3 7e 1b			jp macro_next 
1f70				endm 
# End of macro NEXTW
1f70			.COLN: 
1f70				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1f70 19				db WORD_SYS_CORE+OPCODE_COLN             
1f71 fc 20			dw .SCOLN            
1f73 02				db 1 + 1 
1f74 .. 00			db ":",0              
1f76				endm 
# End of macro CWHEAD
1f76			; | : ( -- )         Create new word | DONE 
1f76			 
1f76					if DEBUG_FORTH_WORDS_KEY 
1f76						DMARK "CLN" 
1f76 f5				push af  
1f77 3a 8b 1f			ld a, (.dmark)  
1f7a 32 77 fb			ld (debug_mark),a  
1f7d 3a 8c 1f			ld a, (.dmark+1)  
1f80 32 78 fb			ld (debug_mark+1),a  
1f83 3a 8d 1f			ld a, (.dmark+2)  
1f86 32 79 fb			ld (debug_mark+2),a  
1f89 18 03			jr .pastdmark  
1f8b ..			.dmark: db "CLN"  
1f8e f1			.pastdmark: pop af  
1f8f			endm  
# End of macro DMARK
1f8f						CALLMONITOR 
1f8f cd 00 14			call break_point_state  
1f92				endm  
# End of macro CALLMONITOR
1f92					endif 
1f92				STACKFRAME OFF $8efe $989f 
1f92				if DEBUG_STACK_IMB 
1f92					if OFF 
1f92						exx 
1f92						ld de, $8efe 
1f92						ld a, d 
1f92						ld hl, curframe 
1f92						call hexout 
1f92						ld a, e 
1f92						ld hl, curframe+2 
1f92						call hexout 
1f92						ld hl, $8efe 
1f92						push hl 
1f92						ld hl, $989f 
1f92						push hl 
1f92						exx 
1f92					endif 
1f92				endif 
1f92			endm 
# End of macro STACKFRAME
1f92				; get parser buffer length  of new word 
1f92			 
1f92				 
1f92			 
1f92					; move tok past this to start of name defintition 
1f92					; TODO get word to define 
1f92					; TODO Move past word token 
1f92					; TODO get length of string up to the ';' 
1f92			 
1f92 2a 33 f1			ld hl, (os_tok_ptr) 
1f95 23				inc hl 
1f96 23				inc hl 
1f97			 
1f97 3e 3b			ld a, ';' 
1f99 cd 7b 10			call strlent 
1f9c			 
1f9c 7d				ld a,l 
1f9d 32 32 f0			ld (os_new_parse_len), a 
1fa0			 
1fa0			 
1fa0			if DEBUG_FORTH_UWORD 
1fa0 ed 5b 33 f1		ld de, (os_tok_ptr) 
1fa4						DMARK ":01" 
1fa4 f5				push af  
1fa5 3a b9 1f			ld a, (.dmark)  
1fa8 32 77 fb			ld (debug_mark),a  
1fab 3a ba 1f			ld a, (.dmark+1)  
1fae 32 78 fb			ld (debug_mark+1),a  
1fb1 3a bb 1f			ld a, (.dmark+2)  
1fb4 32 79 fb			ld (debug_mark+2),a  
1fb7 18 03			jr .pastdmark  
1fb9 ..			.dmark: db ":01"  
1fbc f1			.pastdmark: pop af  
1fbd			endm  
# End of macro DMARK
1fbd				CALLMONITOR 
1fbd cd 00 14			call break_point_state  
1fc0				endm  
# End of macro CALLMONITOR
1fc0			endif 
1fc0			 
1fc0			; 
1fc0			;  new word memory layout: 
1fc0			;  
1fc0			;    : adg 6666 ;  
1fc0			; 
1fc0			;    db   1     ; user defined word  
1fc0 23				inc hl    
1fc1			;    dw   sysdict 
1fc1 23				inc hl 
1fc2 23				inc hl 
1fc3			;    db <word len>+1 (for null) 
1fc3 23				inc hl 
1fc4			;    db .... <word> 
1fc4			; 
1fc4			 
1fc4 23				inc hl    ; some extras for the word preamble before the above 
1fc5 23				inc hl 
1fc6 23				inc hl 
1fc7 23				inc hl 
1fc8 23				inc hl 
1fc9 23				inc hl 
1fca 23				inc hl  
1fcb 23				inc hl 
1fcc 23				inc hl 
1fcd 23				inc hl 
1fce 23				inc hl 
1fcf 23				inc hl 
1fd0 23				inc hl 
1fd1 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1fd2			;       exec word buffer 
1fd2			;	<ptr word>   
1fd2 23				inc hl 
1fd3 23				inc hl 
1fd4			;       <word list><null term> 7F final term 
1fd4			 
1fd4			 
1fd4			if DEBUG_FORTH_UWORD 
1fd4						DMARK ":02" 
1fd4 f5				push af  
1fd5 3a e9 1f			ld a, (.dmark)  
1fd8 32 77 fb			ld (debug_mark),a  
1fdb 3a ea 1f			ld a, (.dmark+1)  
1fde 32 78 fb			ld (debug_mark+1),a  
1fe1 3a eb 1f			ld a, (.dmark+2)  
1fe4 32 79 fb			ld (debug_mark+2),a  
1fe7 18 03			jr .pastdmark  
1fe9 ..			.dmark: db ":02"  
1fec f1			.pastdmark: pop af  
1fed			endm  
# End of macro DMARK
1fed				CALLMONITOR 
1fed cd 00 14			call break_point_state  
1ff0				endm  
# End of macro CALLMONITOR
1ff0			endif 
1ff0			 
1ff0				 
1ff0					; malloc the size 
1ff0			 
1ff0 cd d9 10				call malloc 
1ff3 22 30 f0				ld (os_new_malloc), hl     ; save malloc start 
1ff6			 
1ff6			;    db   1     ; user defined word  
1ff6 3e 01				ld a, WORD_SYS_UWORD  
1ff8 77					ld (hl), a 
1ff9				 
1ff9 23				inc hl    
1ffa			;    dw   sysdict 
1ffa 11 d6 1c			ld de, sysdict       ; continue on with the scan to the system dict 
1ffd 73				ld (hl), e 
1ffe 23				inc hl 
1fff 72				ld (hl), d 
2000 23				inc hl 
2001			 
2001			 
2001			;    Setup dict word 
2001			 
2001 23				inc hl 
2002 22 36 f0			ld (os_new_work_ptr), hl     ; save start of dict word  
2005			 
2005				; 1. get length of dict word 
2005			 
2005			 
2005 2a 33 f1			ld hl, (os_tok_ptr) 
2008 23				inc hl 
2009 23				inc hl    ; position to start of dict word 
200a 3e 00			ld a, 0 
200c cd 7b 10			call strlent 
200f			 
200f			 
200f 23				inc hl    ; to include null??? 
2010			 
2010				; write length of dict word 
2010			 
2010 ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2014 1b				dec de 
2015 eb				ex de, hl 
2016 73				ld (hl), e 
2017 eb				ex de, hl 
2018			 
2018				 
2018			 
2018				; copy  
2018 4d				ld c, l 
2019 06 00			ld b, 0 
201b ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
201f 2a 33 f1			ld hl, (os_tok_ptr) 
2022 23				inc hl 
2023 23				inc hl    ; position to start of dict word 
2024				 
2024			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2024				 
2024				; TODO need to convert word to upper case 
2024			 
2024			ucasetok:	 
2024 7e				ld a,(hl) 
2025 cd 67 10			call toUpper 
2028 77				ld (hl),a 
2029 ed a0			ldi 
202b f2 24 20		 	jp p, ucasetok 
202e			 
202e			 
202e			 
202e				; de now points to start of where the word body code should be placed 
202e ed 53 36 f0		ld (os_new_work_ptr), de 
2032				; hl now points to the words to throw at forthexec which needs to be copied 
2032 22 38 f0			ld (os_new_src_ptr), hl 
2035			 
2035				; TODO add 'call to forthexec' 
2035			 
2035			if DEBUG_FORTH_UWORD 
2035 c5				push bc 
2036 ed 4b 30 f0		ld bc, (os_new_malloc) 
203a						DMARK ":0x" 
203a f5				push af  
203b 3a 4f 20			ld a, (.dmark)  
203e 32 77 fb			ld (debug_mark),a  
2041 3a 50 20			ld a, (.dmark+1)  
2044 32 78 fb			ld (debug_mark+1),a  
2047 3a 51 20			ld a, (.dmark+2)  
204a 32 79 fb			ld (debug_mark+2),a  
204d 18 03			jr .pastdmark  
204f ..			.dmark: db ":0x"  
2052 f1			.pastdmark: pop af  
2053			endm  
# End of macro DMARK
2053				CALLMONITOR 
2053 cd 00 14			call break_point_state  
2056				endm  
# End of macro CALLMONITOR
2056 c1				pop bc 
2057			endif 
2057			 
2057			 
2057				; create word preamble which should be: 
2057			 
2057			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2057			 
2057				;    ld hl, <word code> 
2057				;    jp user_exec 
2057			        ;    <word code bytes> 
2057			 
2057			 
2057			;	inc de     ; TODO ??? or are we already past the word's null 
2057 eb				ex de, hl 
2058			 
2058 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
205a			 
205a 23				inc hl 
205b 22 3c f0			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
205e 23				inc hl 
205f			 
205f 23				inc hl 
2060 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2062			 
2062 01 1d 4e			ld bc, user_exec 
2065 23				inc hl 
2066 71				ld (hl), c     ; poke address of user_exec 
2067 23				inc hl 
2068 70				ld (hl), b     
2069			 ; 
2069			;	inc hl 
2069			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2069			; 
2069			; 
2069			;	ld bc, macro_forth_rsp_next 
2069			;	inc hl 
2069			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2069			;	inc hl 
2069			;	ld (hl), b     
2069			 ; 
2069			;	inc hl 
2069			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2069			; 
2069			; 
2069			;	inc hl 
2069			;	ld bc, forthexec 
2069			;	ld (hl), c     ; poke address of forthexec 
2069			;	inc hl 
2069			;	ld (hl), b      
2069			; 
2069			;	inc hl 
2069			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2069			; 
2069			;	ld bc, user_dict_next 
2069			;	inc hl 
2069			;	ld (hl), c     ; poke address of forthexec 
2069			;	inc hl 
2069			;	ld (hl), b      
2069			 
2069				; hl is now where we need to copy the word byte data to save this 
2069			 
2069 23				inc hl 
206a 22 3a f0			ld (os_new_exec), hl 
206d				 
206d				; copy definition 
206d			 
206d eb				ex de, hl 
206e			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
206e			;	inc de    ; skip the PC for this parse 
206e 3a 32 f0			ld a, (os_new_parse_len) 
2071 4f				ld c, a 
2072 06 00			ld b, 0 
2074 ed b0			ldir		 ; copy defintion 
2076			 
2076			 
2076				; poke the address of where the new word bytes live for forthexec 
2076			 
2076 2a 3c f0			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2079			 
2079 ed 5b 3a f0		ld de, (os_new_exec)      
207d				 
207d 73				ld (hl), e 
207e 23				inc hl 
207f 72				ld (hl), d 
2080			 
2080					; TODO copy last user dict word next link to this word 
2080					; TODO update last user dict word to point to this word 
2080			; 
2080			; hl f923 de 812a ; bc 811a 
2080			 
2080			if DEBUG_FORTH_UWORD 
2080 c5				push bc 
2081 ed 4b 30 f0		ld bc, (os_new_malloc) 
2085						DMARK ":0A" 
2085 f5				push af  
2086 3a 9a 20			ld a, (.dmark)  
2089 32 77 fb			ld (debug_mark),a  
208c 3a 9b 20			ld a, (.dmark+1)  
208f 32 78 fb			ld (debug_mark+1),a  
2092 3a 9c 20			ld a, (.dmark+2)  
2095 32 79 fb			ld (debug_mark+2),a  
2098 18 03			jr .pastdmark  
209a ..			.dmark: db ":0A"  
209d f1			.pastdmark: pop af  
209e			endm  
# End of macro DMARK
209e				CALLMONITOR 
209e cd 00 14			call break_point_state  
20a1				endm  
# End of macro CALLMONITOR
20a1 c1				pop bc 
20a2			endif 
20a2			if DEBUG_FORTH_UWORD 
20a2 c5				push bc 
20a3 ed 4b 30 f0		ld bc, (os_new_malloc) 
20a7 03				inc bc 
20a8 03				inc bc 
20a9 03				inc bc 
20aa 03				inc bc 
20ab 03				inc bc 
20ac 03				inc bc 
20ad 03				inc bc 
20ae 03				inc bc 
20af			 
20af						DMARK ":0B" 
20af f5				push af  
20b0 3a c4 20			ld a, (.dmark)  
20b3 32 77 fb			ld (debug_mark),a  
20b6 3a c5 20			ld a, (.dmark+1)  
20b9 32 78 fb			ld (debug_mark+1),a  
20bc 3a c6 20			ld a, (.dmark+2)  
20bf 32 79 fb			ld (debug_mark+2),a  
20c2 18 03			jr .pastdmark  
20c4 ..			.dmark: db ":0B"  
20c7 f1			.pastdmark: pop af  
20c8			endm  
# End of macro DMARK
20c8				CALLMONITOR 
20c8 cd 00 14			call break_point_state  
20cb				endm  
# End of macro CALLMONITOR
20cb c1				pop bc 
20cc			endif 
20cc			 
20cc			; update word dict linked list for new word 
20cc			 
20cc			 
20cc 2a 2f f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
20cf 23			inc hl     ; move to next work linked list ptr 
20d0			 
20d0 ed 5b 30 f0	ld de, (os_new_malloc)		 ; new next word 
20d4 73			ld (hl), e 
20d5 23			inc hl 
20d6 72			ld (hl), d 
20d7			 
20d7			if DEBUG_FORTH_UWORD 
20d7 ed 4b 2f f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
20db			endif 
20db			 
20db ed 53 2f f1	ld (os_last_new_uword), de      ; update last new uword ptr 
20df			 
20df			 
20df			if DEBUG_FORTH_UWORD 
20df						DMARK ":0+" 
20df f5				push af  
20e0 3a f4 20			ld a, (.dmark)  
20e3 32 77 fb			ld (debug_mark),a  
20e6 3a f5 20			ld a, (.dmark+1)  
20e9 32 78 fb			ld (debug_mark+1),a  
20ec 3a f6 20			ld a, (.dmark+2)  
20ef 32 79 fb			ld (debug_mark+2),a  
20f2 18 03			jr .pastdmark  
20f4 ..			.dmark: db ":0+"  
20f7 f1			.pastdmark: pop af  
20f8			endm  
# End of macro DMARK
20f8				CALLMONITOR 
20f8 cd 00 14			call break_point_state  
20fb				endm  
# End of macro CALLMONITOR
20fb			endif 
20fb			 
20fb				STACKFRAMECHK OFF $8efe $989f 
20fb				if DEBUG_STACK_IMB 
20fb					if OFF 
20fb						exx 
20fb						ld hl, $989f 
20fb						pop de   ; $989f 
20fb						call cmp16 
20fb						jr nz, .spnosame 
20fb						ld hl, $8efe 
20fb						pop de   ; $8efe 
20fb						call cmp16 
20fb						jr z, .spfrsame 
20fb						.spnosame: call showsperror 
20fb						.spfrsame: nop 
20fb						exx 
20fb					endif 
20fb				endif 
20fb			endm 
# End of macro STACKFRAMECHK
20fb			 
20fb c9			ret    ; dont process any remaining parser tokens as they form new word 
20fc			 
20fc			 
20fc			 
20fc			 
20fc			;		NEXT 
20fc			.SCOLN: 
20fc			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
20fc 06				db OPCODE_SCOLN 
20fd 48 21			dw .DROP 
20ff 02				db 2 
2100 .. 00			db ";",0           
2102			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2102					if DEBUG_FORTH_WORDS_KEY 
2102						DMARK "SCN" 
2102 f5				push af  
2103 3a 17 21			ld a, (.dmark)  
2106 32 77 fb			ld (debug_mark),a  
2109 3a 18 21			ld a, (.dmark+1)  
210c 32 78 fb			ld (debug_mark+1),a  
210f 3a 19 21			ld a, (.dmark+2)  
2112 32 79 fb			ld (debug_mark+2),a  
2115 18 03			jr .pastdmark  
2117 ..			.dmark: db "SCN"  
211a f1			.pastdmark: pop af  
211b			endm  
# End of macro DMARK
211b						CALLMONITOR 
211b cd 00 14			call break_point_state  
211e				endm  
# End of macro CALLMONITOR
211e					endif 
211e					FORTH_RSP_TOS 
211e cd 4b 19			call macro_forth_rsp_tos 
2121				endm 
# End of macro FORTH_RSP_TOS
2121 e5					push hl 
2122					FORTH_RSP_POP 
2122 cd 55 19			call macro_forth_rsp_pop 
2125				endm 
# End of macro FORTH_RSP_POP
2125 e1					pop hl 
2126			;		ex de,hl 
2126 22 33 f1				ld (os_tok_ptr),hl 
2129			 
2129			if DEBUG_FORTH_UWORD 
2129						DMARK "SCL" 
2129 f5				push af  
212a 3a 3e 21			ld a, (.dmark)  
212d 32 77 fb			ld (debug_mark),a  
2130 3a 3f 21			ld a, (.dmark+1)  
2133 32 78 fb			ld (debug_mark+1),a  
2136 3a 40 21			ld a, (.dmark+2)  
2139 32 79 fb			ld (debug_mark+2),a  
213c 18 03			jr .pastdmark  
213e ..			.dmark: db "SCL"  
2141 f1			.pastdmark: pop af  
2142			endm  
# End of macro DMARK
2142				CALLMONITOR 
2142 cd 00 14			call break_point_state  
2145				endm  
# End of macro CALLMONITOR
2145			endif 
2145					NEXTW 
2145 c3 7e 1b			jp macro_next 
2148				endm 
# End of macro NEXTW
2148			 
2148			.DROP: 
2148				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2148 1b				db WORD_SYS_CORE+OPCODE_DROP             
2149 73 21			dw .DUP2            
214b 05				db 4 + 1 
214c .. 00			db "DROP",0              
2151				endm 
# End of macro CWHEAD
2151			; | DROP ( w -- )   drop the TOS item   | DONE 
2151					if DEBUG_FORTH_WORDS_KEY 
2151						DMARK "DRP" 
2151 f5				push af  
2152 3a 66 21			ld a, (.dmark)  
2155 32 77 fb			ld (debug_mark),a  
2158 3a 67 21			ld a, (.dmark+1)  
215b 32 78 fb			ld (debug_mark+1),a  
215e 3a 68 21			ld a, (.dmark+2)  
2161 32 79 fb			ld (debug_mark+2),a  
2164 18 03			jr .pastdmark  
2166 ..			.dmark: db "DRP"  
2169 f1			.pastdmark: pop af  
216a			endm  
# End of macro DMARK
216a						CALLMONITOR 
216a cd 00 14			call break_point_state  
216d				endm  
# End of macro CALLMONITOR
216d					endif 
216d					FORTH_DSP_POP 
216d cd c4 1a			call macro_forth_dsp_pop 
2170				endm 
# End of macro FORTH_DSP_POP
2170					NEXTW 
2170 c3 7e 1b			jp macro_next 
2173				endm 
# End of macro NEXTW
2173			.DUP2: 
2173				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2173 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2174 b8 21			dw .DROP2            
2176 05				db 4 + 1 
2177 .. 00			db "2DUP",0              
217c				endm 
# End of macro CWHEAD
217c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
217c					if DEBUG_FORTH_WORDS_KEY 
217c						DMARK "2DU" 
217c f5				push af  
217d 3a 91 21			ld a, (.dmark)  
2180 32 77 fb			ld (debug_mark),a  
2183 3a 92 21			ld a, (.dmark+1)  
2186 32 78 fb			ld (debug_mark+1),a  
2189 3a 93 21			ld a, (.dmark+2)  
218c 32 79 fb			ld (debug_mark+2),a  
218f 18 03			jr .pastdmark  
2191 ..			.dmark: db "2DU"  
2194 f1			.pastdmark: pop af  
2195			endm  
# End of macro DMARK
2195						CALLMONITOR 
2195 cd 00 14			call break_point_state  
2198				endm  
# End of macro CALLMONITOR
2198					endif 
2198					FORTH_DSP_VALUEHL 
2198 cd 28 1a			call macro_dsp_valuehl 
219b				endm 
# End of macro FORTH_DSP_VALUEHL
219b e5					push hl      ; 2 
219c			 
219c					FORTH_DSP_POP 
219c cd c4 1a			call macro_forth_dsp_pop 
219f				endm 
# End of macro FORTH_DSP_POP
219f					 
219f					FORTH_DSP_VALUEHL 
219f cd 28 1a			call macro_dsp_valuehl 
21a2				endm 
# End of macro FORTH_DSP_VALUEHL
21a2			;		push hl      ; 1 
21a2			 
21a2					FORTH_DSP_POP 
21a2 cd c4 1a			call macro_forth_dsp_pop 
21a5				endm 
# End of macro FORTH_DSP_POP
21a5			 
21a5			;		pop hl       ; 1 
21a5 d1					pop de       ; 2 
21a6			 
21a6 cd 8d 19				call forth_push_numhl 
21a9 eb					ex de, hl 
21aa cd 8d 19				call forth_push_numhl 
21ad			 
21ad					 
21ad eb					ex de, hl 
21ae			 
21ae cd 8d 19				call forth_push_numhl 
21b1 eb					ex de, hl 
21b2 cd 8d 19				call forth_push_numhl 
21b5			 
21b5			 
21b5					NEXTW 
21b5 c3 7e 1b			jp macro_next 
21b8				endm 
# End of macro NEXTW
21b8			.DROP2: 
21b8				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21b8 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21b9 e7 21			dw .SWAP2            
21bb 06				db 5 + 1 
21bc .. 00			db "2DROP",0              
21c2				endm 
# End of macro CWHEAD
21c2			; | 2DROP ( w w -- )    Double drop | DONE 
21c2					if DEBUG_FORTH_WORDS_KEY 
21c2						DMARK "2DR" 
21c2 f5				push af  
21c3 3a d7 21			ld a, (.dmark)  
21c6 32 77 fb			ld (debug_mark),a  
21c9 3a d8 21			ld a, (.dmark+1)  
21cc 32 78 fb			ld (debug_mark+1),a  
21cf 3a d9 21			ld a, (.dmark+2)  
21d2 32 79 fb			ld (debug_mark+2),a  
21d5 18 03			jr .pastdmark  
21d7 ..			.dmark: db "2DR"  
21da f1			.pastdmark: pop af  
21db			endm  
# End of macro DMARK
21db						CALLMONITOR 
21db cd 00 14			call break_point_state  
21de				endm  
# End of macro CALLMONITOR
21de					endif 
21de					FORTH_DSP_POP 
21de cd c4 1a			call macro_forth_dsp_pop 
21e1				endm 
# End of macro FORTH_DSP_POP
21e1					FORTH_DSP_POP 
21e1 cd c4 1a			call macro_forth_dsp_pop 
21e4				endm 
# End of macro FORTH_DSP_POP
21e4					NEXTW 
21e4 c3 7e 1b			jp macro_next 
21e7				endm 
# End of macro NEXTW
21e7			.SWAP2: 
21e7				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
21e7 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
21e8 10 22			dw .AT            
21ea 06				db 5 + 1 
21eb .. 00			db "2SWAP",0              
21f1				endm 
# End of macro CWHEAD
21f1			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
21f1					if DEBUG_FORTH_WORDS_KEY 
21f1						DMARK "2SW" 
21f1 f5				push af  
21f2 3a 06 22			ld a, (.dmark)  
21f5 32 77 fb			ld (debug_mark),a  
21f8 3a 07 22			ld a, (.dmark+1)  
21fb 32 78 fb			ld (debug_mark+1),a  
21fe 3a 08 22			ld a, (.dmark+2)  
2201 32 79 fb			ld (debug_mark+2),a  
2204 18 03			jr .pastdmark  
2206 ..			.dmark: db "2SW"  
2209 f1			.pastdmark: pop af  
220a			endm  
# End of macro DMARK
220a						CALLMONITOR 
220a cd 00 14			call break_point_state  
220d				endm  
# End of macro CALLMONITOR
220d					endif 
220d					NEXTW 
220d c3 7e 1b			jp macro_next 
2210				endm 
# End of macro NEXTW
2210			.AT: 
2210				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2210 1f				db WORD_SYS_CORE+OPCODE_AT             
2211 42 22			dw .CAT            
2213 02				db 1 + 1 
2214 .. 00			db "@",0              
2216				endm 
# End of macro CWHEAD
2216			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2216			 
2216					if DEBUG_FORTH_WORDS_KEY 
2216						DMARK "AT." 
2216 f5				push af  
2217 3a 2b 22			ld a, (.dmark)  
221a 32 77 fb			ld (debug_mark),a  
221d 3a 2c 22			ld a, (.dmark+1)  
2220 32 78 fb			ld (debug_mark+1),a  
2223 3a 2d 22			ld a, (.dmark+2)  
2226 32 79 fb			ld (debug_mark+2),a  
2229 18 03			jr .pastdmark  
222b ..			.dmark: db "AT."  
222e f1			.pastdmark: pop af  
222f			endm  
# End of macro DMARK
222f						CALLMONITOR 
222f cd 00 14			call break_point_state  
2232				endm  
# End of macro CALLMONITOR
2232					endif 
2232			.getbyteat:	 
2232					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2232 cd 28 1a			call macro_dsp_valuehl 
2235				endm 
# End of macro FORTH_DSP_VALUEHL
2235					 
2235			;		push hl 
2235				 
2235					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2235 cd c4 1a			call macro_forth_dsp_pop 
2238				endm 
# End of macro FORTH_DSP_POP
2238			 
2238			;		pop hl 
2238			 
2238 7e					ld a, (hl) 
2239			 
2239 6f					ld l, a 
223a 26 00				ld h, 0 
223c cd 8d 19				call forth_push_numhl 
223f			 
223f					NEXTW 
223f c3 7e 1b			jp macro_next 
2242				endm 
# End of macro NEXTW
2242			.CAT: 
2242				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2242 20				db WORD_SYS_CORE+OPCODE_CAT             
2243 6b 22			dw .BANG            
2245 03				db 2 + 1 
2246 .. 00			db "C@",0              
2249				endm 
# End of macro CWHEAD
2249			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2249					if DEBUG_FORTH_WORDS_KEY 
2249						DMARK "CAA" 
2249 f5				push af  
224a 3a 5e 22			ld a, (.dmark)  
224d 32 77 fb			ld (debug_mark),a  
2250 3a 5f 22			ld a, (.dmark+1)  
2253 32 78 fb			ld (debug_mark+1),a  
2256 3a 60 22			ld a, (.dmark+2)  
2259 32 79 fb			ld (debug_mark+2),a  
225c 18 03			jr .pastdmark  
225e ..			.dmark: db "CAA"  
2261 f1			.pastdmark: pop af  
2262			endm  
# End of macro DMARK
2262						CALLMONITOR 
2262 cd 00 14			call break_point_state  
2265				endm  
# End of macro CALLMONITOR
2265					endif 
2265 c3 32 22				jp .getbyteat 
2268					NEXTW 
2268 c3 7e 1b			jp macro_next 
226b				endm 
# End of macro NEXTW
226b			.BANG: 
226b				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
226b 21				db WORD_SYS_CORE+OPCODE_BANG             
226c a1 22			dw .CBANG            
226e 02				db 1 + 1 
226f .. 00			db "!",0              
2271				endm 
# End of macro CWHEAD
2271			; | ! ( x w -- ) Store x at address w      | DONE 
2271					if DEBUG_FORTH_WORDS_KEY 
2271						DMARK "BNG" 
2271 f5				push af  
2272 3a 86 22			ld a, (.dmark)  
2275 32 77 fb			ld (debug_mark),a  
2278 3a 87 22			ld a, (.dmark+1)  
227b 32 78 fb			ld (debug_mark+1),a  
227e 3a 88 22			ld a, (.dmark+2)  
2281 32 79 fb			ld (debug_mark+2),a  
2284 18 03			jr .pastdmark  
2286 ..			.dmark: db "BNG"  
2289 f1			.pastdmark: pop af  
228a			endm  
# End of macro DMARK
228a						CALLMONITOR 
228a cd 00 14			call break_point_state  
228d				endm  
# End of macro CALLMONITOR
228d					endif 
228d			 
228d			.storebyteat:		 
228d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
228d cd 28 1a			call macro_dsp_valuehl 
2290				endm 
# End of macro FORTH_DSP_VALUEHL
2290					 
2290 e5					push hl 
2291				 
2291					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2291 cd c4 1a			call macro_forth_dsp_pop 
2294				endm 
# End of macro FORTH_DSP_POP
2294			 
2294					; get byte to poke 
2294			 
2294					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2294 cd 28 1a			call macro_dsp_valuehl 
2297				endm 
# End of macro FORTH_DSP_VALUEHL
2297 e5					push hl 
2298			 
2298			 
2298					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2298 cd c4 1a			call macro_forth_dsp_pop 
229b				endm 
# End of macro FORTH_DSP_POP
229b			 
229b			 
229b d1					pop de 
229c e1					pop hl 
229d			 
229d 73					ld (hl),e 
229e			 
229e			 
229e					NEXTW 
229e c3 7e 1b			jp macro_next 
22a1				endm 
# End of macro NEXTW
22a1			.CBANG: 
22a1				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22a1 22				db WORD_SYS_CORE+OPCODE_CBANG             
22a2 ca 22			dw .SCALL            
22a4 03				db 2 + 1 
22a5 .. 00			db "C!",0              
22a8				endm 
# End of macro CWHEAD
22a8			; | C!  ( x w -- ) Store x at address w  | DONE 
22a8					if DEBUG_FORTH_WORDS_KEY 
22a8						DMARK "CBA" 
22a8 f5				push af  
22a9 3a bd 22			ld a, (.dmark)  
22ac 32 77 fb			ld (debug_mark),a  
22af 3a be 22			ld a, (.dmark+1)  
22b2 32 78 fb			ld (debug_mark+1),a  
22b5 3a bf 22			ld a, (.dmark+2)  
22b8 32 79 fb			ld (debug_mark+2),a  
22bb 18 03			jr .pastdmark  
22bd ..			.dmark: db "CBA"  
22c0 f1			.pastdmark: pop af  
22c1			endm  
# End of macro DMARK
22c1						CALLMONITOR 
22c1 cd 00 14			call break_point_state  
22c4				endm  
# End of macro CALLMONITOR
22c4					endif 
22c4 c3 8d 22				jp .storebyteat 
22c7					NEXTW 
22c7 c3 7e 1b			jp macro_next 
22ca				endm 
# End of macro NEXTW
22ca			.SCALL: 
22ca				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
22ca 23				db WORD_SYS_CORE+OPCODE_SCALL             
22cb fe 22			dw .DEPTH            
22cd 05				db 4 + 1 
22ce .. 00			db "CALL",0              
22d3				endm 
# End of macro CWHEAD
22d3			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
22d3					if DEBUG_FORTH_WORDS_KEY 
22d3						DMARK "CLL" 
22d3 f5				push af  
22d4 3a e8 22			ld a, (.dmark)  
22d7 32 77 fb			ld (debug_mark),a  
22da 3a e9 22			ld a, (.dmark+1)  
22dd 32 78 fb			ld (debug_mark+1),a  
22e0 3a ea 22			ld a, (.dmark+2)  
22e3 32 79 fb			ld (debug_mark+2),a  
22e6 18 03			jr .pastdmark  
22e8 ..			.dmark: db "CLL"  
22eb f1			.pastdmark: pop af  
22ec			endm  
# End of macro DMARK
22ec						CALLMONITOR 
22ec cd 00 14			call break_point_state  
22ef				endm  
# End of macro CALLMONITOR
22ef					endif 
22ef			 
22ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22ef cd 28 1a			call macro_dsp_valuehl 
22f2				endm 
# End of macro FORTH_DSP_VALUEHL
22f2			 
22f2			;		push hl 
22f2			 
22f2					; destroy value TOS 
22f2			 
22f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22f2 cd c4 1a			call macro_forth_dsp_pop 
22f5				endm 
# End of macro FORTH_DSP_POP
22f5			 
22f5						 
22f5			;		pop hl 
22f5			 
22f5					; how to do a call with hl???? save SP? 
22f5 cd 27 1b				call forth_call_hl 
22f8			 
22f8			 
22f8					; TODO push value back onto stack for another op etc 
22f8			 
22f8 cd 8d 19				call forth_push_numhl 
22fb					NEXTW 
22fb c3 7e 1b			jp macro_next 
22fe				endm 
# End of macro NEXTW
22fe			.DEPTH: 
22fe				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
22fe 24				db WORD_SYS_CORE+OPCODE_DEPTH             
22ff 3b 23			dw .OVER            
2301 06				db 5 + 1 
2302 .. 00			db "DEPTH",0              
2308				endm 
# End of macro CWHEAD
2308			; | DEPTH ( -- u ) Push count of stack | DONE 
2308					; take current TOS and remove from base value div by two to get count 
2308					if DEBUG_FORTH_WORDS_KEY 
2308						DMARK "DEP" 
2308 f5				push af  
2309 3a 1d 23			ld a, (.dmark)  
230c 32 77 fb			ld (debug_mark),a  
230f 3a 1e 23			ld a, (.dmark+1)  
2312 32 78 fb			ld (debug_mark+1),a  
2315 3a 1f 23			ld a, (.dmark+2)  
2318 32 79 fb			ld (debug_mark+2),a  
231b 18 03			jr .pastdmark  
231d ..			.dmark: db "DEP"  
2320 f1			.pastdmark: pop af  
2321			endm  
# End of macro DMARK
2321						CALLMONITOR 
2321 cd 00 14			call break_point_state  
2324				endm  
# End of macro CALLMONITOR
2324					endif 
2324			 
2324			 
2324 2a 1f f8			ld hl, (cli_data_sp) 
2327 11 99 f3			ld de, cli_data_stack 
232a ed 52			sbc hl,de 
232c				 
232c				; div by size of stack item 
232c			 
232c 5d				ld e,l 
232d 0e 03			ld c, 3 
232f cd a2 0b			call Div8 
2332			 
2332 6f				ld l,a 
2333 26 00			ld h,0 
2335			 
2335				;srl h 
2335				;rr l 
2335			 
2335 cd 8d 19				call forth_push_numhl 
2338					NEXTW 
2338 c3 7e 1b			jp macro_next 
233b				endm 
# End of macro NEXTW
233b			.OVER: 
233b				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
233b 42				db WORD_SYS_CORE+46             
233c 82 23			dw .PAUSE            
233e 05				db 4 + 1 
233f .. 00			db "OVER",0              
2344				endm 
# End of macro CWHEAD
2344			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2344					if DEBUG_FORTH_WORDS_KEY 
2344						DMARK "OVR" 
2344 f5				push af  
2345 3a 59 23			ld a, (.dmark)  
2348 32 77 fb			ld (debug_mark),a  
234b 3a 5a 23			ld a, (.dmark+1)  
234e 32 78 fb			ld (debug_mark+1),a  
2351 3a 5b 23			ld a, (.dmark+2)  
2354 32 79 fb			ld (debug_mark+2),a  
2357 18 03			jr .pastdmark  
2359 ..			.dmark: db "OVR"  
235c f1			.pastdmark: pop af  
235d			endm  
# End of macro DMARK
235d						CALLMONITOR 
235d cd 00 14			call break_point_state  
2360				endm  
# End of macro CALLMONITOR
2360					endif 
2360			 
2360					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2360 cd 28 1a			call macro_dsp_valuehl 
2363				endm 
# End of macro FORTH_DSP_VALUEHL
2363 e5					push hl    ; n2 
2364					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2364 cd c4 1a			call macro_forth_dsp_pop 
2367				endm 
# End of macro FORTH_DSP_POP
2367			 
2367					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2367 cd 28 1a			call macro_dsp_valuehl 
236a				endm 
# End of macro FORTH_DSP_VALUEHL
236a e5					push hl    ; n1 
236b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
236b cd c4 1a			call macro_forth_dsp_pop 
236e				endm 
# End of macro FORTH_DSP_POP
236e			 
236e d1					pop de     ; n1 
236f e1					pop hl     ; n2 
2370			 
2370 d5					push de 
2371 e5					push hl 
2372 d5					push de 
2373			 
2373					; push back  
2373			 
2373 e1					pop hl 
2374 cd 8d 19				call forth_push_numhl 
2377 e1					pop hl 
2378 cd 8d 19				call forth_push_numhl 
237b e1					pop hl 
237c cd 8d 19				call forth_push_numhl 
237f					NEXTW 
237f c3 7e 1b			jp macro_next 
2382				endm 
# End of macro NEXTW
2382			 
2382			.PAUSE: 
2382				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2382 43				db WORD_SYS_CORE+47             
2383 b7 23			dw .PAUSES            
2385 08				db 7 + 1 
2386 .. 00			db "PAUSEMS",0              
238e				endm 
# End of macro CWHEAD
238e			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
238e					if DEBUG_FORTH_WORDS_KEY 
238e						DMARK "PMS" 
238e f5				push af  
238f 3a a3 23			ld a, (.dmark)  
2392 32 77 fb			ld (debug_mark),a  
2395 3a a4 23			ld a, (.dmark+1)  
2398 32 78 fb			ld (debug_mark+1),a  
239b 3a a5 23			ld a, (.dmark+2)  
239e 32 79 fb			ld (debug_mark+2),a  
23a1 18 03			jr .pastdmark  
23a3 ..			.dmark: db "PMS"  
23a6 f1			.pastdmark: pop af  
23a7			endm  
# End of macro DMARK
23a7						CALLMONITOR 
23a7 cd 00 14			call break_point_state  
23aa				endm  
# End of macro CALLMONITOR
23aa					endif 
23aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23aa cd 28 1a			call macro_dsp_valuehl 
23ad				endm 
# End of macro FORTH_DSP_VALUEHL
23ad			;		push hl    ; n2 
23ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ad cd c4 1a			call macro_forth_dsp_pop 
23b0				endm 
# End of macro FORTH_DSP_POP
23b0			;		pop hl 
23b0			 
23b0 7d					ld a, l 
23b1 cd 22 0a				call aDelayInMS 
23b4				       NEXTW 
23b4 c3 7e 1b			jp macro_next 
23b7				endm 
# End of macro NEXTW
23b7			.PAUSES:  
23b7				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23b7 44				db WORD_SYS_CORE+48             
23b8 26 24			dw .ROT            
23ba 06				db 5 + 1 
23bb .. 00			db "PAUSE",0              
23c1				endm 
# End of macro CWHEAD
23c1			; | PAUSE ( n -- )  Pause for n seconds | DONE 
23c1					if DEBUG_FORTH_WORDS_KEY 
23c1						DMARK "PAU" 
23c1 f5				push af  
23c2 3a d6 23			ld a, (.dmark)  
23c5 32 77 fb			ld (debug_mark),a  
23c8 3a d7 23			ld a, (.dmark+1)  
23cb 32 78 fb			ld (debug_mark+1),a  
23ce 3a d8 23			ld a, (.dmark+2)  
23d1 32 79 fb			ld (debug_mark+2),a  
23d4 18 03			jr .pastdmark  
23d6 ..			.dmark: db "PAU"  
23d9 f1			.pastdmark: pop af  
23da			endm  
# End of macro DMARK
23da						CALLMONITOR 
23da cd 00 14			call break_point_state  
23dd				endm  
# End of macro CALLMONITOR
23dd					endif 
23dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23dd cd 28 1a			call macro_dsp_valuehl 
23e0				endm 
# End of macro FORTH_DSP_VALUEHL
23e0			;		push hl    ; n2 
23e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23e0 cd c4 1a			call macro_forth_dsp_pop 
23e3				endm 
# End of macro FORTH_DSP_POP
23e3			;		pop hl 
23e3 45					ld b, l 
23e4					if DEBUG_FORTH_WORDS 
23e4						DMARK "PAU" 
23e4 f5				push af  
23e5 3a f9 23			ld a, (.dmark)  
23e8 32 77 fb			ld (debug_mark),a  
23eb 3a fa 23			ld a, (.dmark+1)  
23ee 32 78 fb			ld (debug_mark+1),a  
23f1 3a fb 23			ld a, (.dmark+2)  
23f4 32 79 fb			ld (debug_mark+2),a  
23f7 18 03			jr .pastdmark  
23f9 ..			.dmark: db "PAU"  
23fc f1			.pastdmark: pop af  
23fd			endm  
# End of macro DMARK
23fd						CALLMONITOR 
23fd cd 00 14			call break_point_state  
2400				endm  
# End of macro CALLMONITOR
2400					endif 
2400 c5			.pauses1:	push bc 
2401 cd 3d 0a				call delay1s 
2404 c1					pop bc 
2405					if DEBUG_FORTH_WORDS 
2405						DMARK "PA1" 
2405 f5				push af  
2406 3a 1a 24			ld a, (.dmark)  
2409 32 77 fb			ld (debug_mark),a  
240c 3a 1b 24			ld a, (.dmark+1)  
240f 32 78 fb			ld (debug_mark+1),a  
2412 3a 1c 24			ld a, (.dmark+2)  
2415 32 79 fb			ld (debug_mark+2),a  
2418 18 03			jr .pastdmark  
241a ..			.dmark: db "PA1"  
241d f1			.pastdmark: pop af  
241e			endm  
# End of macro DMARK
241e						CALLMONITOR 
241e cd 00 14			call break_point_state  
2421				endm  
# End of macro CALLMONITOR
2421					endif 
2421 10 dd				djnz .pauses1 
2423			 
2423				       NEXTW 
2423 c3 7e 1b			jp macro_next 
2426				endm 
# End of macro NEXTW
2426			.ROT: 
2426				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2426 45				db WORD_SYS_CORE+49             
2427 74 24			dw .UWORDS            
2429 04				db 3 + 1 
242a .. 00			db "ROT",0              
242e				endm 
# End of macro CWHEAD
242e			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
242e					if DEBUG_FORTH_WORDS_KEY 
242e						DMARK "ROT" 
242e f5				push af  
242f 3a 43 24			ld a, (.dmark)  
2432 32 77 fb			ld (debug_mark),a  
2435 3a 44 24			ld a, (.dmark+1)  
2438 32 78 fb			ld (debug_mark+1),a  
243b 3a 45 24			ld a, (.dmark+2)  
243e 32 79 fb			ld (debug_mark+2),a  
2441 18 03			jr .pastdmark  
2443 ..			.dmark: db "ROT"  
2446 f1			.pastdmark: pop af  
2447			endm  
# End of macro DMARK
2447						CALLMONITOR 
2447 cd 00 14			call break_point_state  
244a				endm  
# End of macro CALLMONITOR
244a					endif 
244a			 
244a					FORTH_DSP_VALUEHL 
244a cd 28 1a			call macro_dsp_valuehl 
244d				endm 
# End of macro FORTH_DSP_VALUEHL
244d e5					push hl    ; u3  
244e			 
244e					FORTH_DSP_POP 
244e cd c4 1a			call macro_forth_dsp_pop 
2451				endm 
# End of macro FORTH_DSP_POP
2451			   
2451					FORTH_DSP_VALUEHL 
2451 cd 28 1a			call macro_dsp_valuehl 
2454				endm 
# End of macro FORTH_DSP_VALUEHL
2454 e5					push hl     ; u2 
2455			 
2455					FORTH_DSP_POP 
2455 cd c4 1a			call macro_forth_dsp_pop 
2458				endm 
# End of macro FORTH_DSP_POP
2458			 
2458					FORTH_DSP_VALUEHL 
2458 cd 28 1a			call macro_dsp_valuehl 
245b				endm 
# End of macro FORTH_DSP_VALUEHL
245b e5					push hl     ; u1 
245c			 
245c					FORTH_DSP_POP 
245c cd c4 1a			call macro_forth_dsp_pop 
245f				endm 
# End of macro FORTH_DSP_POP
245f			 
245f c1					pop bc      ; u1 
2460 e1					pop hl      ; u2 
2461 d1					pop de      ; u3 
2462			 
2462			 
2462 c5					push bc 
2463 d5					push de 
2464 e5					push hl 
2465			 
2465			 
2465 e1					pop hl 
2466 cd 8d 19				call forth_push_numhl 
2469			 
2469 e1					pop hl 
246a cd 8d 19				call forth_push_numhl 
246d			 
246d e1					pop hl 
246e cd 8d 19				call forth_push_numhl 
2471					 
2471			 
2471			 
2471			 
2471			 
2471			 
2471				       NEXTW 
2471 c3 7e 1b			jp macro_next 
2474				endm 
# End of macro NEXTW
2474			 
2474			.UWORDS: 
2474				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2474 50				db WORD_SYS_CORE+60             
2475 36 25			dw .BP            
2477 07				db 6 + 1 
2478 .. 00			db "UWORDS",0              
247f				endm 
# End of macro CWHEAD
247f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
247f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
247f			; | | Following the count are the individual words. 
247f			; | | 
247f			; | | e.g. UWORDS 
247f			; | | BOX DIRLIST 2 
247f			; | |  
247f			; | | Can be used to save the words to storage via: 
247f			; | | UWORDS $01 DO $01 APPEND LOOP 
247f				if DEBUG_FORTH_WORDS_KEY 
247f					DMARK "UWR" 
247f f5				push af  
2480 3a 94 24			ld a, (.dmark)  
2483 32 77 fb			ld (debug_mark),a  
2486 3a 95 24			ld a, (.dmark+1)  
2489 32 78 fb			ld (debug_mark+1),a  
248c 3a 96 24			ld a, (.dmark+2)  
248f 32 79 fb			ld (debug_mark+2),a  
2492 18 03			jr .pastdmark  
2494 ..			.dmark: db "UWR"  
2497 f1			.pastdmark: pop af  
2498			endm  
# End of macro DMARK
2498					CALLMONITOR 
2498 cd 00 14			call break_point_state  
249b				endm  
# End of macro CALLMONITOR
249b				endif 
249b 21 00 80				ld hl, baseram 
249e					;ld hl, baseusermem 
249e 01 00 00				ld bc, 0    ; start a counter 
24a1			 
24a1				; skip dict stub 
24a1			 
24a1 cd cf 1c				call forth_tok_next 
24a4			 
24a4			 
24a4			; while we have words to look for 
24a4			 
24a4 7e			.douscan:	ld a, (hl)      
24a5				if DEBUG_FORTH_WORDS 
24a5					DMARK "UWs" 
24a5 f5				push af  
24a6 3a ba 24			ld a, (.dmark)  
24a9 32 77 fb			ld (debug_mark),a  
24ac 3a bb 24			ld a, (.dmark+1)  
24af 32 78 fb			ld (debug_mark+1),a  
24b2 3a bc 24			ld a, (.dmark+2)  
24b5 32 79 fb			ld (debug_mark+2),a  
24b8 18 03			jr .pastdmark  
24ba ..			.dmark: db "UWs"  
24bd f1			.pastdmark: pop af  
24be			endm  
# End of macro DMARK
24be					CALLMONITOR 
24be cd 00 14			call break_point_state  
24c1				endm  
# End of macro CALLMONITOR
24c1				endif 
24c1 fe 00				cp WORD_SYS_END 
24c3 28 4d				jr z, .udone 
24c5 fe 01				cp WORD_SYS_UWORD 
24c7 20 44				jr nz, .nuword 
24c9			 
24c9				if DEBUG_FORTH_WORDS 
24c9					DMARK "UWu" 
24c9 f5				push af  
24ca 3a de 24			ld a, (.dmark)  
24cd 32 77 fb			ld (debug_mark),a  
24d0 3a df 24			ld a, (.dmark+1)  
24d3 32 78 fb			ld (debug_mark+1),a  
24d6 3a e0 24			ld a, (.dmark+2)  
24d9 32 79 fb			ld (debug_mark+2),a  
24dc 18 03			jr .pastdmark  
24de ..			.dmark: db "UWu"  
24e1 f1			.pastdmark: pop af  
24e2			endm  
# End of macro DMARK
24e2					CALLMONITOR 
24e2 cd 00 14			call break_point_state  
24e5				endm  
# End of macro CALLMONITOR
24e5				endif 
24e5					; we have a uword so push its name to the stack 
24e5			 
24e5 e5				   	push hl  ; save so we can move to next dict block 
24e6			 
24e6					; skip opcode 
24e6 23					inc hl  
24e7					; skip next ptr 
24e7 23					inc hl  
24e8 23					inc hl 
24e9					; skip len 
24e9 23					inc hl 
24ea				if DEBUG_FORTH_WORDS 
24ea					DMARK "UWt" 
24ea f5				push af  
24eb 3a ff 24			ld a, (.dmark)  
24ee 32 77 fb			ld (debug_mark),a  
24f1 3a 00 25			ld a, (.dmark+1)  
24f4 32 78 fb			ld (debug_mark+1),a  
24f7 3a 01 25			ld a, (.dmark+2)  
24fa 32 79 fb			ld (debug_mark+2),a  
24fd 18 03			jr .pastdmark  
24ff ..			.dmark: db "UWt"  
2502 f1			.pastdmark: pop af  
2503			endm  
# End of macro DMARK
2503					CALLMONITOR 
2503 cd 00 14			call break_point_state  
2506				endm  
# End of macro CALLMONITOR
2506				endif 
2506 03					inc bc 
2507			 
2507 c5					push bc 
2508 cd 9f 19				call forth_push_str 
250b c1					pop bc 
250c			 
250c e1					pop hl 	 
250d			 
250d cd cf 1c		.nuword:	call forth_tok_next 
2510 18 92				jr .douscan  
2512			 
2512			.udone:		 ; push count of uwords found 
2512 c5					push bc 
2513 e1					pop hl 
2514			 
2514				if DEBUG_FORTH_WORDS 
2514					DMARK "UWc" 
2514 f5				push af  
2515 3a 29 25			ld a, (.dmark)  
2518 32 77 fb			ld (debug_mark),a  
251b 3a 2a 25			ld a, (.dmark+1)  
251e 32 78 fb			ld (debug_mark+1),a  
2521 3a 2b 25			ld a, (.dmark+2)  
2524 32 79 fb			ld (debug_mark+2),a  
2527 18 03			jr .pastdmark  
2529 ..			.dmark: db "UWc"  
252c f1			.pastdmark: pop af  
252d			endm  
# End of macro DMARK
252d					CALLMONITOR 
252d cd 00 14			call break_point_state  
2530				endm  
# End of macro CALLMONITOR
2530				endif 
2530 cd 8d 19				call forth_push_numhl 
2533			 
2533			 
2533				       NEXTW 
2533 c3 7e 1b			jp macro_next 
2536				endm 
# End of macro NEXTW
2536			 
2536			.BP: 
2536				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2536 54				db WORD_SYS_CORE+64             
2537 6c 25			dw .MONITOR            
2539 03				db 2 + 1 
253a .. 00			db "BP",0              
253d				endm 
# End of macro CWHEAD
253d			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
253d			; | | $00 Will enable the break points within specific code paths 
253d			; | | $01 Will disable break points 
253d			; | |  
253d			; | | By default break points are off. Either the above can be used to enable them 
253d			; | | or if a key is held down during start up the spashscreen will appear to freeze 
253d			; | | and on release of the pressed key a message will be disaplayed to notify 
253d			; | | that break points are enabled. Pressing any key will then continue boot process. 
253d					; get byte count 
253d					if DEBUG_FORTH_WORDS_KEY 
253d						DMARK "BP." 
253d f5				push af  
253e 3a 52 25			ld a, (.dmark)  
2541 32 77 fb			ld (debug_mark),a  
2544 3a 53 25			ld a, (.dmark+1)  
2547 32 78 fb			ld (debug_mark+1),a  
254a 3a 54 25			ld a, (.dmark+2)  
254d 32 79 fb			ld (debug_mark+2),a  
2550 18 03			jr .pastdmark  
2552 ..			.dmark: db "BP."  
2555 f1			.pastdmark: pop af  
2556			endm  
# End of macro DMARK
2556						CALLMONITOR 
2556 cd 00 14			call break_point_state  
2559				endm  
# End of macro CALLMONITOR
2559					endif 
2559			 
2559					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2559 cd 28 1a			call macro_dsp_valuehl 
255c				endm 
# End of macro FORTH_DSP_VALUEHL
255c			 
255c			;		push hl 
255c			 
255c					; destroy value TOS 
255c			 
255c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
255c cd c4 1a			call macro_forth_dsp_pop 
255f				endm 
# End of macro FORTH_DSP_POP
255f			 
255f			;		pop hl 
255f			 
255f 3e 00				ld a,0 
2561 bd					cp l 
2562 28 02				jr z, .bpset 
2564 3e 2a				ld a, '*' 
2566			 
2566 32 31 ee		.bpset:		ld (os_view_disable), a 
2569			 
2569			 
2569					NEXTW 
2569 c3 7e 1b			jp macro_next 
256c				endm 
# End of macro NEXTW
256c			 
256c			 
256c			.MONITOR: 
256c				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
256c 55				db WORD_SYS_CORE+65             
256d 9f 25			dw .MALLOC            
256f 08				db 7 + 1 
2570 .. 00			db "MONITOR",0              
2578				endm 
# End of macro CWHEAD
2578			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2578			; | | At start the current various registers will be displayed with contents. 
2578			; | | Top right corner will show the most recent debug marker seen. 
2578			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2578			; | | and the return stack pointer (RSP). 
2578			; | | Pressing: 
2578			; | |    1 - Initial screen 
2578			; | |    2 - Display a data dump of HL 
2578			; | |    3 - Display a data dump of DE 
2578			; | |    4 - Display a data dump of BC 
2578			; | |    5 - Display a data dump of HL 
2578			; | |    6 - Display a data dump of DSP 
2578			; | |    7 - Display a data dump of RSP 
2578			; | |    8 - Display a data dump of what is at DSP 
2578			; | |    9 - Display a data dump of what is at RSP 
2578			; | |    0 - Exit monitor and continue running. This will also enable break points 
2578			; | |    * - Disable break points 
2578			; | |    # - Enter traditional monitor mode 
2578			; | | 
2578			; | | Monitor Mode 
2578			; | | ------------ 
2578			; | | A prompt of '>' will be shown for various commands: 
2578			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2578			; | |    C - Continue display a data dump from the last set address 
2578			; | |    M xxxx - Set start of memory edit at address xx 
2578			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2578			; | |    Q - Return to previous 
2578					if DEBUG_FORTH_WORDS_KEY 
2578						DMARK "MON" 
2578 f5				push af  
2579 3a 8d 25			ld a, (.dmark)  
257c 32 77 fb			ld (debug_mark),a  
257f 3a 8e 25			ld a, (.dmark+1)  
2582 32 78 fb			ld (debug_mark+1),a  
2585 3a 8f 25			ld a, (.dmark+2)  
2588 32 79 fb			ld (debug_mark+2),a  
258b 18 03			jr .pastdmark  
258d ..			.dmark: db "MON"  
2590 f1			.pastdmark: pop af  
2591			endm  
# End of macro DMARK
2591						CALLMONITOR 
2591 cd 00 14			call break_point_state  
2594				endm  
# End of macro CALLMONITOR
2594					endif 
2594 3e 00				ld a, 0 
2596 32 31 ee				ld (os_view_disable), a 
2599			 
2599					CALLMONITOR 
2599 cd 00 14			call break_point_state  
259c				endm  
# End of macro CALLMONITOR
259c			 
259c			;	call monitor 
259c			 
259c					NEXTW 
259c c3 7e 1b			jp macro_next 
259f				endm 
# End of macro NEXTW
259f			 
259f			 
259f			.MALLOC: 
259f				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
259f 56				db WORD_SYS_CORE+66             
25a0 c8 25			dw .MALLOC2            
25a2 06				db 5 + 1 
25a3 .. 00			db "ALLOT",0              
25a9				endm 
# End of macro CWHEAD
25a9			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25a9					if DEBUG_FORTH_WORDS_KEY 
25a9						DMARK "ALL" 
25a9 f5				push af  
25aa 3a be 25			ld a, (.dmark)  
25ad 32 77 fb			ld (debug_mark),a  
25b0 3a bf 25			ld a, (.dmark+1)  
25b3 32 78 fb			ld (debug_mark+1),a  
25b6 3a c0 25			ld a, (.dmark+2)  
25b9 32 79 fb			ld (debug_mark+2),a  
25bc 18 03			jr .pastdmark  
25be ..			.dmark: db "ALL"  
25c1 f1			.pastdmark: pop af  
25c2			endm  
# End of macro DMARK
25c2						CALLMONITOR 
25c2 cd 00 14			call break_point_state  
25c5				endm  
# End of macro CALLMONITOR
25c5					endif 
25c5 c3 ef 25				jp .mallocc 
25c8			.MALLOC2: 
25c8				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
25c8 56				db WORD_SYS_CORE+66             
25c9 06 26			dw .FREE            
25cb 07				db 6 + 1 
25cc .. 00			db "MALLOC",0              
25d3				endm 
# End of macro CWHEAD
25d3			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25d3					; get byte count 
25d3					if DEBUG_FORTH_WORDS_KEY 
25d3						DMARK "MAL" 
25d3 f5				push af  
25d4 3a e8 25			ld a, (.dmark)  
25d7 32 77 fb			ld (debug_mark),a  
25da 3a e9 25			ld a, (.dmark+1)  
25dd 32 78 fb			ld (debug_mark+1),a  
25e0 3a ea 25			ld a, (.dmark+2)  
25e3 32 79 fb			ld (debug_mark+2),a  
25e6 18 03			jr .pastdmark  
25e8 ..			.dmark: db "MAL"  
25eb f1			.pastdmark: pop af  
25ec			endm  
# End of macro DMARK
25ec						CALLMONITOR 
25ec cd 00 14			call break_point_state  
25ef				endm  
# End of macro CALLMONITOR
25ef					endif 
25ef			.mallocc: 
25ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ef cd 28 1a			call macro_dsp_valuehl 
25f2				endm 
# End of macro FORTH_DSP_VALUEHL
25f2			 
25f2			;		push hl 
25f2			 
25f2					; destroy value TOS 
25f2			 
25f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f2 cd c4 1a			call macro_forth_dsp_pop 
25f5				endm 
# End of macro FORTH_DSP_POP
25f5			 
25f5			;		pop hl 
25f5 cd d9 10				call malloc 
25f8				if DEBUG_FORTH_MALLOC_GUARD 
25f8 f5					push af 
25f9 cd 3b 0c				call ishlzero 
25fc			;		ld a, l 
25fc			;		add h 
25fc			;		cp 0 
25fc f1					pop af 
25fd					 
25fd cc ef 4e				call z,malloc_error 
2600				endif 
2600			 
2600 cd 8d 19				call forth_push_numhl 
2603					NEXTW 
2603 c3 7e 1b			jp macro_next 
2606				endm 
# End of macro NEXTW
2606			 
2606			.FREE: 
2606				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2606 57				db WORD_SYS_CORE+67             
2607 37 26			dw .LIST            
2609 05				db 4 + 1 
260a .. 00			db "FREE",0              
260f				endm 
# End of macro CWHEAD
260f			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
260f					if DEBUG_FORTH_WORDS_KEY 
260f						DMARK "FRE" 
260f f5				push af  
2610 3a 24 26			ld a, (.dmark)  
2613 32 77 fb			ld (debug_mark),a  
2616 3a 25 26			ld a, (.dmark+1)  
2619 32 78 fb			ld (debug_mark+1),a  
261c 3a 26 26			ld a, (.dmark+2)  
261f 32 79 fb			ld (debug_mark+2),a  
2622 18 03			jr .pastdmark  
2624 ..			.dmark: db "FRE"  
2627 f1			.pastdmark: pop af  
2628			endm  
# End of macro DMARK
2628						CALLMONITOR 
2628 cd 00 14			call break_point_state  
262b				endm  
# End of macro CALLMONITOR
262b					endif 
262b					; get address 
262b			 
262b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
262b cd 28 1a			call macro_dsp_valuehl 
262e				endm 
# End of macro FORTH_DSP_VALUEHL
262e			 
262e			;		push hl 
262e			 
262e					; destroy value TOS 
262e			 
262e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
262e cd c4 1a			call macro_forth_dsp_pop 
2631				endm 
# End of macro FORTH_DSP_POP
2631			 
2631			;		pop hl 
2631			if FORTH_ENABLE_MALLOCFREE 
2631 cd a3 11				call free 
2634			endif 
2634					NEXTW 
2634 c3 7e 1b			jp macro_next 
2637				endm 
# End of macro NEXTW
2637			.LIST: 
2637				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2637 5c				db WORD_SYS_CORE+72             
2638 fa 27			dw .FORGET            
263a 05				db 4 + 1 
263b .. 00			db "LIST",0              
2640				endm 
# End of macro CWHEAD
2640			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2640			; | | The quoted word must be in upper case. 
2640				if DEBUG_FORTH_WORDS_KEY 
2640					DMARK "LST" 
2640 f5				push af  
2641 3a 55 26			ld a, (.dmark)  
2644 32 77 fb			ld (debug_mark),a  
2647 3a 56 26			ld a, (.dmark+1)  
264a 32 78 fb			ld (debug_mark+1),a  
264d 3a 57 26			ld a, (.dmark+2)  
2650 32 79 fb			ld (debug_mark+2),a  
2653 18 03			jr .pastdmark  
2655 ..			.dmark: db "LST"  
2658 f1			.pastdmark: pop af  
2659			endm  
# End of macro DMARK
2659					CALLMONITOR 
2659 cd 00 14			call break_point_state  
265c				endm  
# End of macro CALLMONITOR
265c				endif 
265c			 
265c					FORTH_DSP_VALUEHL 
265c cd 28 1a			call macro_dsp_valuehl 
265f				endm 
# End of macro FORTH_DSP_VALUEHL
265f			 
265f e5					push hl 
2660 c1					pop bc 
2661			 
2661			; Start format of scratch string 
2661			 
2661 21 32 ee				ld hl, scratch 
2664			 
2664 3e 3a				ld a, ':' 
2666 77					ld (hl),a 
2667 23					inc hl 
2668 3e 20				ld a, ' ' 
266a 77					ld (hl), a 
266b			 
266b					; Get ptr to the word we need to look up 
266b			 
266b			;		FORTH_DSP_VALUEHL 
266b					;v5 FORTH_DSP_VALUE 
266b				; TODO type check 
266b			;		inc hl    ; Skip type check  
266b			;		push hl 
266b			;		ex de, hl    ; put into DE 
266b			 
266b			 
266b 21 00 80				ld hl, baseram 
266e					;ld hl, baseusermem 
266e			 
266e e5			push hl   ; sacreifical push 
266f			 
266f			.ldouscanm: 
266f e1				pop hl 
2670			.ldouscan: 
2670				if DEBUG_FORTH_WORDS 
2670					DMARK "LSs" 
2670 f5				push af  
2671 3a 85 26			ld a, (.dmark)  
2674 32 77 fb			ld (debug_mark),a  
2677 3a 86 26			ld a, (.dmark+1)  
267a 32 78 fb			ld (debug_mark+1),a  
267d 3a 87 26			ld a, (.dmark+2)  
2680 32 79 fb			ld (debug_mark+2),a  
2683 18 03			jr .pastdmark  
2685 ..			.dmark: db "LSs"  
2688 f1			.pastdmark: pop af  
2689			endm  
# End of macro DMARK
2689					CALLMONITOR 
2689 cd 00 14			call break_point_state  
268c				endm  
# End of macro CALLMONITOR
268c				endif 
268c				; skip dict stub 
268c cd cf 1c				call forth_tok_next 
268f			 
268f			 
268f			; while we have words to look for 
268f			 
268f 7e				ld a, (hl)      
2690				if DEBUG_FORTH_WORDS 
2690					DMARK "LSk" 
2690 f5				push af  
2691 3a a5 26			ld a, (.dmark)  
2694 32 77 fb			ld (debug_mark),a  
2697 3a a6 26			ld a, (.dmark+1)  
269a 32 78 fb			ld (debug_mark+1),a  
269d 3a a7 26			ld a, (.dmark+2)  
26a0 32 79 fb			ld (debug_mark+2),a  
26a3 18 03			jr .pastdmark  
26a5 ..			.dmark: db "LSk"  
26a8 f1			.pastdmark: pop af  
26a9			endm  
# End of macro DMARK
26a9					CALLMONITOR 
26a9 cd 00 14			call break_point_state  
26ac				endm  
# End of macro CALLMONITOR
26ac				endif 
26ac fe 00				cp WORD_SYS_END 
26ae ca e1 27				jp z, .lunotfound 
26b1 fe 01				cp WORD_SYS_UWORD 
26b3 c2 70 26				jp nz, .ldouscan 
26b6			 
26b6				if DEBUG_FORTH_WORDS 
26b6					DMARK "LSu" 
26b6 f5				push af  
26b7 3a cb 26			ld a, (.dmark)  
26ba 32 77 fb			ld (debug_mark),a  
26bd 3a cc 26			ld a, (.dmark+1)  
26c0 32 78 fb			ld (debug_mark+1),a  
26c3 3a cd 26			ld a, (.dmark+2)  
26c6 32 79 fb			ld (debug_mark+2),a  
26c9 18 03			jr .pastdmark  
26cb ..			.dmark: db "LSu"  
26ce f1			.pastdmark: pop af  
26cf			endm  
# End of macro DMARK
26cf					CALLMONITOR 
26cf cd 00 14			call break_point_state  
26d2				endm  
# End of macro CALLMONITOR
26d2				endif 
26d2			 
26d2					; found a uword but is it the one we want... 
26d2			 
26d2 c5					push bc     ; uword to find is on bc 
26d3 d1					pop de 
26d4			 
26d4 e5					push hl  ; to save the ptr 
26d5			 
26d5					; skip opcode 
26d5 23					inc hl  
26d6					; skip next ptr 
26d6 23					inc hl  
26d7 23					inc hl 
26d8					; skip len 
26d8 23					inc hl 
26d9			 
26d9				if DEBUG_FORTH_WORDS 
26d9					DMARK "LSc" 
26d9 f5				push af  
26da 3a ee 26			ld a, (.dmark)  
26dd 32 77 fb			ld (debug_mark),a  
26e0 3a ef 26			ld a, (.dmark+1)  
26e3 32 78 fb			ld (debug_mark+1),a  
26e6 3a f0 26			ld a, (.dmark+2)  
26e9 32 79 fb			ld (debug_mark+2),a  
26ec 18 03			jr .pastdmark  
26ee ..			.dmark: db "LSc"  
26f1 f1			.pastdmark: pop af  
26f2			endm  
# End of macro DMARK
26f2					CALLMONITOR 
26f2 cd 00 14			call break_point_state  
26f5				endm  
# End of macro CALLMONITOR
26f5				endif 
26f5 cd a8 10				call strcmp 
26f8 c2 6f 26				jp nz, .ldouscanm 
26fb				 
26fb			 
26fb			 
26fb					; we have a uword so push its name to the stack 
26fb			 
26fb			;	   	push hl  ; save so we can move to next dict block 
26fb e1			pop hl 
26fc			 
26fc				if DEBUG_FORTH_WORDS 
26fc					DMARK "LSm" 
26fc f5				push af  
26fd 3a 11 27			ld a, (.dmark)  
2700 32 77 fb			ld (debug_mark),a  
2703 3a 12 27			ld a, (.dmark+1)  
2706 32 78 fb			ld (debug_mark+1),a  
2709 3a 13 27			ld a, (.dmark+2)  
270c 32 79 fb			ld (debug_mark+2),a  
270f 18 03			jr .pastdmark  
2711 ..			.dmark: db "LSm"  
2714 f1			.pastdmark: pop af  
2715			endm  
# End of macro DMARK
2715					CALLMONITOR 
2715 cd 00 14			call break_point_state  
2718				endm  
# End of macro CALLMONITOR
2718				endif 
2718			 
2718					; skip opcode 
2718 23					inc hl  
2719					; skip next ptr 
2719 23					inc hl  
271a 23					inc hl 
271b					; skip len 
271b 7e					ld a, (hl)   ; save length to add 
271c				if DEBUG_FORTH_WORDS 
271c					DMARK "LS2" 
271c f5				push af  
271d 3a 31 27			ld a, (.dmark)  
2720 32 77 fb			ld (debug_mark),a  
2723 3a 32 27			ld a, (.dmark+1)  
2726 32 78 fb			ld (debug_mark+1),a  
2729 3a 33 27			ld a, (.dmark+2)  
272c 32 79 fb			ld (debug_mark+2),a  
272f 18 03			jr .pastdmark  
2731 ..			.dmark: db "LS2"  
2734 f1			.pastdmark: pop af  
2735			endm  
# End of macro DMARK
2735					CALLMONITOR 
2735 cd 00 14			call break_point_state  
2738				endm  
# End of macro CALLMONITOR
2738				endif 
2738			 
2738					; save this location 
2738				 
2738 e5					push hl 
2739			 
2739 23					inc hl 
273a 11 34 ee				ld de, scratch+2 
273d 4f					ld c, a 
273e 06 00				ld b, 0 
2740			 
2740				if DEBUG_FORTH_WORDS 
2740					DMARK "LSn" 
2740 f5				push af  
2741 3a 55 27			ld a, (.dmark)  
2744 32 77 fb			ld (debug_mark),a  
2747 3a 56 27			ld a, (.dmark+1)  
274a 32 78 fb			ld (debug_mark+1),a  
274d 3a 57 27			ld a, (.dmark+2)  
2750 32 79 fb			ld (debug_mark+2),a  
2753 18 03			jr .pastdmark  
2755 ..			.dmark: db "LSn"  
2758 f1			.pastdmark: pop af  
2759			endm  
# End of macro DMARK
2759					CALLMONITOR 
2759 cd 00 14			call break_point_state  
275c				endm  
# End of macro CALLMONITOR
275c				endif 
275c			 
275c					; copy uword name to scratch 
275c			 
275c ed b0				ldir 
275e			 
275e 1b					dec de 
275f 3e 20				ld a, ' '    ; change null to space 
2761 12					ld (de), a 
2762			 
2762 13					inc de 
2763			 
2763 d5					push de 
2764 c1					pop bc     ; move scratch pointer to end of word name and save it 
2765			 
2765 e1					pop hl 
2766 7e					ld a, (hl) 
2767					;inc hl 
2767					; skip word string 
2767 cd 12 0c				call addatohl 
276a			 
276a 23					inc hl 
276b			 
276b				if DEBUG_FORTH_WORDS 
276b					DMARK "LS3" 
276b f5				push af  
276c 3a 80 27			ld a, (.dmark)  
276f 32 77 fb			ld (debug_mark),a  
2772 3a 81 27			ld a, (.dmark+1)  
2775 32 78 fb			ld (debug_mark+1),a  
2778 3a 82 27			ld a, (.dmark+2)  
277b 32 79 fb			ld (debug_mark+2),a  
277e 18 03			jr .pastdmark  
2780 ..			.dmark: db "LS3"  
2783 f1			.pastdmark: pop af  
2784			endm  
# End of macro DMARK
2784					CALLMONITOR 
2784 cd 00 14			call break_point_state  
2787				endm  
# End of macro CALLMONITOR
2787				endif 
2787					; should now be at the start of the machine code to setup the eval of the uword 
2787					; now locate the ptr to the string defintion 
2787			 
2787					; skip ld hl, 
2787					; then load the ptr 
2787			 
2787 23					inc hl 
2788 5e					ld e, (hl) 
2789 23					inc hl 
278a 56					ld d, (hl) 
278b eb					ex de, hl 
278c			 
278c			 
278c				if DEBUG_FORTH_WORDS 
278c					DMARK "LSt" 
278c f5				push af  
278d 3a a1 27			ld a, (.dmark)  
2790 32 77 fb			ld (debug_mark),a  
2793 3a a2 27			ld a, (.dmark+1)  
2796 32 78 fb			ld (debug_mark+1),a  
2799 3a a3 27			ld a, (.dmark+2)  
279c 32 79 fb			ld (debug_mark+2),a  
279f 18 03			jr .pastdmark  
27a1 ..			.dmark: db "LSt"  
27a4 f1			.pastdmark: pop af  
27a5			endm  
# End of macro DMARK
27a5					CALLMONITOR 
27a5 cd 00 14			call break_point_state  
27a8				endm  
# End of macro CALLMONITOR
27a8				endif 
27a8			 
27a8			; cant push right now due to tokenised strings  
27a8			 
27a8			; get the destination of where to copy this definition to. 
27a8			 
27a8 c5					push bc 
27a9 d1					pop de 
27aa			 
27aa 7e			.listl:         ld a,(hl) 
27ab fe 00				cp 0 
27ad 28 09				jr z, .lreplsp     ; replace zero with space 
27af fe 7f				cp FORTH_END_BUFFER 
27b1 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27b3				 
27b3					; just copy this char as is then 
27b3			 
27b3 12					ld (de), a 
27b4			 
27b4 23			.listnxt:	inc hl 
27b5 13					inc de 
27b6 18 f2				jr .listl 
27b8			 
27b8 3e 20		.lreplsp:	ld a,' ' 
27ba 12					ld (de), a 
27bb 18 f7				jr .listnxt 
27bd			 
27bd			; close up uword def 
27bd			 
27bd			.listdone: 
27bd 3e 00				ld a, 0 
27bf 12					ld (de), a 
27c0			 
27c0			; now have def so clean up and push to stack 
27c0			 
27c0 21 32 ee				ld hl, scratch 
27c3				if DEBUG_FORTH_WORDS 
27c3					DMARK "Ltp" 
27c3 f5				push af  
27c4 3a d8 27			ld a, (.dmark)  
27c7 32 77 fb			ld (debug_mark),a  
27ca 3a d9 27			ld a, (.dmark+1)  
27cd 32 78 fb			ld (debug_mark+1),a  
27d0 3a da 27			ld a, (.dmark+2)  
27d3 32 79 fb			ld (debug_mark+2),a  
27d6 18 03			jr .pastdmark  
27d8 ..			.dmark: db "Ltp"  
27db f1			.pastdmark: pop af  
27dc			endm  
# End of macro DMARK
27dc					CALLMONITOR 
27dc cd 00 14			call break_point_state  
27df				endm  
# End of macro CALLMONITOR
27df				endif 
27df			 
27df 18 06			jr .listpush 
27e1			 
27e1			;.lnuword:	pop hl 
27e1			;		call forth_tok_next 
27e1			;		jp .ldouscan  
27e1			 
27e1			.lunotfound:		  
27e1			 
27e1			 
27e1					 
27e1					FORTH_DSP_POP 
27e1 cd c4 1a			call macro_forth_dsp_pop 
27e4				endm 
# End of macro FORTH_DSP_POP
27e4 21 ed 27				ld hl, .luno 
27e7						 
27e7			 
27e7			.listpush: 
27e7 cd 9f 19				call forth_push_str 
27ea			 
27ea			 
27ea			 
27ea					NEXTW 
27ea c3 7e 1b			jp macro_next 
27ed				endm 
# End of macro NEXTW
27ed			 
27ed .. 00		.luno:    db "Not found",0 
27f7			 
27f7			 
27f7			 
27f7			 
27f7			 
27f7			;		push hl   ; save pointer to start of uword def string 
27f7			; 
27f7			;; look for FORTH_EOL_LINE 
27f7			;		ld a, FORTH_END_BUFFER 
27f7			;		call strlent 
27f7			; 
27f7			;		inc hl		 ; space for coln def 
27f7			;		inc hl 
27f7			;		inc hl          ; space for terms 
27f7			;		inc hl 
27f7			; 
27f7			;		ld a, 20   ; TODO get actual length 
27f7			;		call addatohl    ; include a random amount of room for the uword name 
27f7			; 
27f7			;		 
27f7			;	if DEBUG_FORTH_WORDS 
27f7			;		DMARK "Lt1" 
27f7			;		CALLMONITOR 
27f7			;	endif 
27f7			;		 
27f7			; 
27f7			;; malloc space for the string because we cant change it 
27f7			; 
27f7			;		call malloc 
27f7			;	if DEBUG_FORTH_MALLOC_GUARD 
27f7			;		push af 
27f7			;		call ishlzero 
27f7			;		pop af 
27f7			;		 
27f7			;		call z,malloc_error 
27f7			;	endif 
27f7			; 
27f7			;	if DEBUG_FORTH_WORDS 
27f7			;		DMARK "Lt2" 
27f7			;		CALLMONITOR 
27f7			;	endif 
27f7			;		pop de 
27f7			;		push hl    ; push the malloc to release later 
27f7			;		push hl   ;  push back a copy for the later stack push 
27f7			;		 
27f7			;; copy the string swapping out the zero terms for spaces 
27f7			; 
27f7			;		; de has our source 
27f7			;		; hl has our dest 
27f7			; 
27f7			;; add the coln def 
27f7			; 
27f7			;		ld a, ':' 
27f7			;		ld (hl), a 
27f7			;		inc hl 
27f7			;		ld a, ' ' 
27f7			;		ld (hl), a 
27f7			;		inc hl 
27f7			; 
27f7			;; add the uname word 
27f7			;		push de   ; save our string for now 
27f7			;		ex de, hl 
27f7			; 
27f7			;		FORTH_DSP_VALUE 
27f7			;		;v5 FORTH_DSP_VALUE 
27f7			; 
27f7			;		inc hl   ; skip type but we know by now this is OK 
27f7			; 
27f7			;.luword:	ld a,(hl) 
27f7			;		cp 0 
27f7			;		jr z, .luword2 
27f7			;		ld (de), a 
27f7			;		inc de 
27f7			;		inc hl 
27f7			;		jr .luword 
27f7			; 
27f7			;.luword2:	ld a, ' ' 
27f7			;		ld (de), a 
27f7			;;		inc hl 
27f7			;;		inc de 
27f7			;;		ld (de), a 
27f7			;;		inc hl 
27f7			;		inc de 
27f7			; 
27f7			;		ex de, hl 
27f7			;		pop de 
27f7			;		 
27f7			;		 
27f7			; 
27f7			;; detoken that string and copy it 
27f7			; 
27f7			;	if DEBUG_FORTH_WORDS 
27f7			;		DMARK "Lt2" 
27f7			;		CALLMONITOR 
27f7			;	endif 
27f7			;.ldetok:	ld a, (de) 
27f7			;		cp FORTH_END_BUFFER 
27f7			;		jr z, .ldetokend 
27f7			;		; swap out any zero term for space 
27f7			;		cp 0 
27f7			;		jr nz, .ldetoknext 
27f7			;		ld a, ' ' 
27f7			; 
27f7			;	if DEBUG_FORTH_WORDS 
27f7			;		DMARK "LtS" 
27f7			;		CALLMONITOR 
27f7			;	endif 
27f7			;.ldetoknext:	ld (hl), a 
27f7			;		inc de 
27f7			;		inc hl 
27f7			;		jr .ldetok 
27f7			; 
27f7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
27f7			;		ld (hl), a  
27f7			; 
27f7			;; free that temp malloc 
27f7			; 
27f7			;		pop hl    
27f7			; 
27f7			;	if DEBUG_FORTH_WORDS 
27f7			;		DMARK "Lt4" 
27f7			;		CALLMONITOR 
27f7			;	endif 
27f7			;		call forth_apushstrhl 
27f7			; 
27f7			;		; get rid of temp malloc area 
27f7			; 
27f7			;		pop hl 
27f7			;		call free 
27f7			; 
27f7			;		jr .ludone 
27f7			; 
27f7			;.lnuword:	pop hl 
27f7			;		call forth_tok_next 
27f7			;		jp .ldouscan  
27f7			; 
27f7			;.ludone:		 pop hl 
27f7			; 
27f7					NEXTW 
27f7 c3 7e 1b			jp macro_next 
27fa				endm 
# End of macro NEXTW
27fa			 
27fa			.FORGET: 
27fa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
27fa 5d				db WORD_SYS_CORE+73             
27fb 73 28			dw .NOP            
27fd 07				db 6 + 1 
27fe .. 00			db "FORGET",0              
2805				endm 
# End of macro CWHEAD
2805			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2805			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2805			; | |  
2805			; | | e.g. "MORE" forget 
2805					if DEBUG_FORTH_WORDS_KEY 
2805						DMARK "FRG" 
2805 f5				push af  
2806 3a 1a 28			ld a, (.dmark)  
2809 32 77 fb			ld (debug_mark),a  
280c 3a 1b 28			ld a, (.dmark+1)  
280f 32 78 fb			ld (debug_mark+1),a  
2812 3a 1c 28			ld a, (.dmark+2)  
2815 32 79 fb			ld (debug_mark+2),a  
2818 18 03			jr .pastdmark  
281a ..			.dmark: db "FRG"  
281d f1			.pastdmark: pop af  
281e			endm  
# End of macro DMARK
281e						CALLMONITOR 
281e cd 00 14			call break_point_state  
2821				endm  
# End of macro CALLMONITOR
2821					endif 
2821			 
2821				; find uword 
2821			        ; update start of word with "_" 
2821				; replace uword with deleted flag 
2821			 
2821			 
2821			;	if DEBUG_FORTH_WORDS 
2821			;		DMARK "FOG" 
2821			;		CALLMONITOR 
2821			;	endif 
2821			 
2821			 
2821					; Get ptr to the word we need to look up 
2821			 
2821					FORTH_DSP_VALUEHL 
2821 cd 28 1a			call macro_dsp_valuehl 
2824				endm 
# End of macro FORTH_DSP_VALUEHL
2824					;v5 FORTH_DSP_VALUE 
2824				; TODO type check 
2824			;		inc hl    ; Skip type check  
2824 e5					push hl 
2825 c1					pop bc 
2826			;		ex de, hl    ; put into DE 
2826			 
2826			 
2826 21 00 80				ld hl, baseram 
2829					;ld hl, baseusermem 
2829			 
2829				; skip dict stub 
2829			;	call forth_tok_next 
2829 e5			push hl   ; sacreifical push 
282a			 
282a			.fldouscanm: 
282a e1				pop hl 
282b			.fldouscan: 
282b			;	if DEBUG_FORTH_WORDS 
282b			;		DMARK "LSs" 
282b			;		CALLMONITOR 
282b			;	endif 
282b				; skip dict stub 
282b cd cf 1c				call forth_tok_next 
282e			 
282e			 
282e			; while we have words to look for 
282e			 
282e 7e				ld a, (hl)      
282f			;	if DEBUG_FORTH_WORDS 
282f			;		DMARK "LSk" 
282f			;		CALLMONITOR 
282f			;	endif 
282f fe 00				cp WORD_SYS_END 
2831 ca 6d 28				jp z, .flunotfound 
2834 fe 01				cp WORD_SYS_UWORD 
2836 c2 2b 28				jp nz, .fldouscan 
2839			 
2839			;	if DEBUG_FORTH_WORDS 
2839			;		DMARK "LSu" 
2839			;		CALLMONITOR 
2839			;	endif 
2839			 
2839					; found a uword but is it the one we want... 
2839			 
2839 c5					push bc     ; uword to find is on bc 
283a d1					pop de 
283b			 
283b e5					push hl  ; to save the ptr 
283c			 
283c					; skip opcode 
283c 23					inc hl  
283d					; skip next ptr 
283d 23					inc hl  
283e 23					inc hl 
283f					; skip len 
283f 23					inc hl 
2840			 
2840			;	if DEBUG_FORTH_WORDS 
2840			;		DMARK "LSc" 
2840			;		CALLMONITOR 
2840			;	endif 
2840 cd a8 10				call strcmp 
2843 c2 2a 28				jp nz, .fldouscanm 
2846			; 
2846			; 
2846			;; while we have words to look for 
2846			; 
2846			;.fdouscan:	ld a, (hl)      
2846			;	if DEBUG_FORTH_WORDS 
2846			;		DMARK "LSs" 
2846			;		CALLMONITOR 
2846			;	endif 
2846			;		cp WORD_SYS_END 
2846			;		jp z, .fudone 
2846			;		cp WORD_SYS_UWORD 
2846			;		jp nz, .fnuword 
2846			; 
2846			;	if DEBUG_FORTH_WORDS 
2846			;		DMARK "FGu" 
2846			;		CALLMONITOR 
2846			;	endif 
2846			; 
2846			;		; found a uword but is it the one we want... 
2846			; 
2846			; 
2846			;	        pop de   ; get back the dsp name 
2846			;		push de 
2846			; 
2846			;		push hl  ; to save the ptr 
2846			; 
2846			;		; skip opcode 
2846			;		inc hl  
2846			;		; skip next ptr 
2846			;		inc hl  
2846			;		inc hl 
2846			;		; skip len 
2846			;		inc hl 
2846			; 
2846			;	if DEBUG_FORTH_WORDS 
2846			;		DMARK "FGc" 
2846			;		CALLMONITOR 
2846			;	endif 
2846			;		call strcmp 
2846			;		jp nz, .fnuword 
2846			 
2846			 
2846 e1			pop hl 
2847			 
2847				 
2847				if DEBUG_FORTH_WORDS 
2847					DMARK "FGm" 
2847 f5				push af  
2848 3a 5c 28			ld a, (.dmark)  
284b 32 77 fb			ld (debug_mark),a  
284e 3a 5d 28			ld a, (.dmark+1)  
2851 32 78 fb			ld (debug_mark+1),a  
2854 3a 5e 28			ld a, (.dmark+2)  
2857 32 79 fb			ld (debug_mark+2),a  
285a 18 03			jr .pastdmark  
285c ..			.dmark: db "FGm"  
285f f1			.pastdmark: pop af  
2860			endm  
# End of macro DMARK
2860					CALLMONITOR 
2860 cd 00 14			call break_point_state  
2863				endm  
# End of macro CALLMONITOR
2863				endif 
2863			 
2863			 
2863			 
2863					; we have a uword so push its name to the stack 
2863			 
2863			;	   	push hl  ; save so we can move to next dict block 
2863			;pop hl 
2863			 
2863					; update opcode to deleted 
2863 3e 03				ld a, WORD_SYS_DELETED 
2865 77					ld (hl), a 
2866			 
2866 23					inc hl  
2867					; skip next ptr 
2867 23					inc hl  
2868 23					inc hl 
2869					; skip len 
2869 23					inc hl 
286a			 
286a					; TODO change parser to skip deleted words but for now mark it out 
286a 3e 5f				ld a, "_" 
286c 77					ld  (hl),a 
286d			 
286d			;		jr .fudone 
286d			; 
286d			;.fnuword:	pop hl 
286d			;		call forth_tok_next 
286d			;		jp .fdouscan  
286d			 
286d			.flunotfound:		  
286d			 
286d			 
286d					 
286d					FORTH_DSP_POP 
286d cd c4 1a			call macro_forth_dsp_pop 
2870				endm 
# End of macro FORTH_DSP_POP
2870			;		ld hl, .luno 
2870			;.fudone:		 pop hl 
2870					NEXTW 
2870 c3 7e 1b			jp macro_next 
2873				endm 
# End of macro NEXTW
2873			.NOP: 
2873				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2873 61				db WORD_SYS_CORE+77             
2874 9a 28			dw .COMO            
2876 04				db 3 + 1 
2877 .. 00			db "NOP",0              
287b				endm 
# End of macro CWHEAD
287b			; | NOP (  --  ) Do nothing | DONE 
287b					if DEBUG_FORTH_WORDS_KEY 
287b						DMARK "NOP" 
287b f5				push af  
287c 3a 90 28			ld a, (.dmark)  
287f 32 77 fb			ld (debug_mark),a  
2882 3a 91 28			ld a, (.dmark+1)  
2885 32 78 fb			ld (debug_mark+1),a  
2888 3a 92 28			ld a, (.dmark+2)  
288b 32 79 fb			ld (debug_mark+2),a  
288e 18 03			jr .pastdmark  
2890 ..			.dmark: db "NOP"  
2893 f1			.pastdmark: pop af  
2894			endm  
# End of macro DMARK
2894						CALLMONITOR 
2894 cd 00 14			call break_point_state  
2897				endm  
# End of macro CALLMONITOR
2897					endif 
2897				       NEXTW 
2897 c3 7e 1b			jp macro_next 
289a				endm 
# End of macro NEXTW
289a			.COMO: 
289a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
289a 6e				db WORD_SYS_CORE+90             
289b ec 28			dw .COMC            
289d 02				db 1 + 1 
289e .. 00			db "(",0              
28a0				endm 
# End of macro CWHEAD
28a0			; | ( ( -- )  Start of comment | DONE 
28a0			 
28a0			 
28a0 2a 33 f1				ld hl, ( os_tok_ptr) 
28a3 11 e7 28			ld de, .closepar 
28a6					 
28a6					if DEBUG_FORTH_WORDS 
28a6						DMARK ").." 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 77 fb			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 78 fb			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 79 fb			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db ").."  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf						CALLMONITOR 
28bf cd 00 14			call break_point_state  
28c2				endm  
# End of macro CALLMONITOR
28c2					endif 
28c2 cd 99 1c			call findnexttok  
28c5			 
28c5					if DEBUG_FORTH_WORDS 
28c5						DMARK "IF5" 
28c5 f5				push af  
28c6 3a da 28			ld a, (.dmark)  
28c9 32 77 fb			ld (debug_mark),a  
28cc 3a db 28			ld a, (.dmark+1)  
28cf 32 78 fb			ld (debug_mark+1),a  
28d2 3a dc 28			ld a, (.dmark+2)  
28d5 32 79 fb			ld (debug_mark+2),a  
28d8 18 03			jr .pastdmark  
28da ..			.dmark: db "IF5"  
28dd f1			.pastdmark: pop af  
28de			endm  
# End of macro DMARK
28de						CALLMONITOR 
28de cd 00 14			call break_point_state  
28e1				endm  
# End of macro CALLMONITOR
28e1					endif 
28e1				; replace below with ) exec using tok_ptr 
28e1 22 33 f1			ld (os_tok_ptr), hl 
28e4 c3 0f 1c			jp exec1 
28e7			 
28e7 .. 00			.closepar:   db ")",0 
28e9			 
28e9				       NEXTW 
28e9 c3 7e 1b			jp macro_next 
28ec				endm 
# End of macro NEXTW
28ec			.COMC: 
28ec				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
28ec 6f				db WORD_SYS_CORE+91             
28ed f5 28			dw .SCRATCH            
28ef 02				db 1 + 1 
28f0 .. 00			db ")",0              
28f2				endm 
# End of macro CWHEAD
28f2			; | ) ( -- )  End of comment |  DONE  
28f2				       NEXTW 
28f2 c3 7e 1b			jp macro_next 
28f5				endm 
# End of macro NEXTW
28f5			 
28f5			.SCRATCH: 
28f5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
28f5 6f				db WORD_SYS_CORE+91             
28f6 30 29			dw .INC            
28f8 08				db 7 + 1 
28f9 .. 00			db "SCRATCH",0              
2901				endm 
# End of macro CWHEAD
2901			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2901			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2901			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2901			; | |  
2901			; | | e.g.    : score $00 scratch ; 
2901			; | |  
2901			; | | $00 score ! 
2901			; | | $01 score +! 
2901			; | |  
2901			; | | e.g.   : varword $0a scratch ;  
2901			; | | 
2901			; | | $8000 varword ! 
2901					if DEBUG_FORTH_WORDS_KEY 
2901						DMARK "SCR" 
2901 f5				push af  
2902 3a 16 29			ld a, (.dmark)  
2905 32 77 fb			ld (debug_mark),a  
2908 3a 17 29			ld a, (.dmark+1)  
290b 32 78 fb			ld (debug_mark+1),a  
290e 3a 18 29			ld a, (.dmark+2)  
2911 32 79 fb			ld (debug_mark+2),a  
2914 18 03			jr .pastdmark  
2916 ..			.dmark: db "SCR"  
2919 f1			.pastdmark: pop af  
291a			endm  
# End of macro DMARK
291a						CALLMONITOR 
291a cd 00 14			call break_point_state  
291d				endm  
# End of macro CALLMONITOR
291d					endif 
291d			 
291d					FORTH_DSP_VALUEHL 
291d cd 28 1a			call macro_dsp_valuehl 
2920				endm 
# End of macro FORTH_DSP_VALUEHL
2920				 
2920					FORTH_DSP_POP 
2920 cd c4 1a			call macro_forth_dsp_pop 
2923				endm 
# End of macro FORTH_DSP_POP
2923			 
2923 7d					ld a, l 
2924 21 57 f3				ld hl, os_var_array 
2927 cd 12 0c				call addatohl 
292a			 
292a cd 8d 19				call forth_push_numhl 
292d			 
292d				       NEXTW 
292d c3 7e 1b			jp macro_next 
2930				endm 
# End of macro NEXTW
2930			 
2930			.INC: 
2930				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2930 6f				db WORD_SYS_CORE+91             
2931 84 29			dw .DEC            
2933 03				db 2 + 1 
2934 .. 00			db "+!",0              
2937				endm 
# End of macro CWHEAD
2937			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2937					if DEBUG_FORTH_WORDS_KEY 
2937						DMARK "+s_" 
2937 f5				push af  
2938 3a 4c 29			ld a, (.dmark)  
293b 32 77 fb			ld (debug_mark),a  
293e 3a 4d 29			ld a, (.dmark+1)  
2941 32 78 fb			ld (debug_mark+1),a  
2944 3a 4e 29			ld a, (.dmark+2)  
2947 32 79 fb			ld (debug_mark+2),a  
294a 18 03			jr .pastdmark  
294c ..			.dmark: db "+s_"  
294f f1			.pastdmark: pop af  
2950			endm  
# End of macro DMARK
2950						CALLMONITOR 
2950 cd 00 14			call break_point_state  
2953				endm  
# End of macro CALLMONITOR
2953					endif 
2953			 
2953					FORTH_DSP_VALUEHL 
2953 cd 28 1a			call macro_dsp_valuehl 
2956				endm 
# End of macro FORTH_DSP_VALUEHL
2956			 
2956 e5					push hl   ; save address 
2957			 
2957					FORTH_DSP_POP 
2957 cd c4 1a			call macro_forth_dsp_pop 
295a				endm 
# End of macro FORTH_DSP_POP
295a			 
295a					FORTH_DSP_VALUEHL 
295a cd 28 1a			call macro_dsp_valuehl 
295d				endm 
# End of macro FORTH_DSP_VALUEHL
295d			 
295d					FORTH_DSP_POP 
295d cd c4 1a			call macro_forth_dsp_pop 
2960				endm 
# End of macro FORTH_DSP_POP
2960			 
2960					; hl contains value to add to byte at a 
2960				 
2960 eb					ex de, hl 
2961			 
2961 e1					pop hl 
2962			 
2962					if DEBUG_FORTH_WORDS 
2962						DMARK "INC" 
2962 f5				push af  
2963 3a 77 29			ld a, (.dmark)  
2966 32 77 fb			ld (debug_mark),a  
2969 3a 78 29			ld a, (.dmark+1)  
296c 32 78 fb			ld (debug_mark+1),a  
296f 3a 79 29			ld a, (.dmark+2)  
2972 32 79 fb			ld (debug_mark+2),a  
2975 18 03			jr .pastdmark  
2977 ..			.dmark: db "INC"  
297a f1			.pastdmark: pop af  
297b			endm  
# End of macro DMARK
297b						CALLMONITOR 
297b cd 00 14			call break_point_state  
297e				endm  
# End of macro CALLMONITOR
297e					endif 
297e			 
297e 7e					ld a,(hl) 
297f 83					add e 
2980 77					ld (hl),a 
2981			 
2981			 
2981			 
2981				       NEXTW 
2981 c3 7e 1b			jp macro_next 
2984				endm 
# End of macro NEXTW
2984			 
2984			.DEC: 
2984				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2984 6f				db WORD_SYS_CORE+91             
2985 d5 29			dw .INC2            
2987 03				db 2 + 1 
2988 .. 00			db "-!",0              
298b				endm 
# End of macro CWHEAD
298b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
298b					if DEBUG_FORTH_WORDS_KEY 
298b						DMARK "-s_" 
298b f5				push af  
298c 3a a0 29			ld a, (.dmark)  
298f 32 77 fb			ld (debug_mark),a  
2992 3a a1 29			ld a, (.dmark+1)  
2995 32 78 fb			ld (debug_mark+1),a  
2998 3a a2 29			ld a, (.dmark+2)  
299b 32 79 fb			ld (debug_mark+2),a  
299e 18 03			jr .pastdmark  
29a0 ..			.dmark: db "-s_"  
29a3 f1			.pastdmark: pop af  
29a4			endm  
# End of macro DMARK
29a4						CALLMONITOR 
29a4 cd 00 14			call break_point_state  
29a7				endm  
# End of macro CALLMONITOR
29a7					endif 
29a7			 
29a7					FORTH_DSP_VALUEHL 
29a7 cd 28 1a			call macro_dsp_valuehl 
29aa				endm 
# End of macro FORTH_DSP_VALUEHL
29aa			 
29aa e5					push hl   ; save address 
29ab			 
29ab					FORTH_DSP_POP 
29ab cd c4 1a			call macro_forth_dsp_pop 
29ae				endm 
# End of macro FORTH_DSP_POP
29ae			 
29ae					FORTH_DSP_VALUEHL 
29ae cd 28 1a			call macro_dsp_valuehl 
29b1				endm 
# End of macro FORTH_DSP_VALUEHL
29b1			 
29b1					; hl contains value to add to byte at a 
29b1				 
29b1 eb					ex de, hl 
29b2			 
29b2 e1					pop hl 
29b3			 
29b3					if DEBUG_FORTH_WORDS 
29b3						DMARK "DEC" 
29b3 f5				push af  
29b4 3a c8 29			ld a, (.dmark)  
29b7 32 77 fb			ld (debug_mark),a  
29ba 3a c9 29			ld a, (.dmark+1)  
29bd 32 78 fb			ld (debug_mark+1),a  
29c0 3a ca 29			ld a, (.dmark+2)  
29c3 32 79 fb			ld (debug_mark+2),a  
29c6 18 03			jr .pastdmark  
29c8 ..			.dmark: db "DEC"  
29cb f1			.pastdmark: pop af  
29cc			endm  
# End of macro DMARK
29cc						CALLMONITOR 
29cc cd 00 14			call break_point_state  
29cf				endm  
# End of macro CALLMONITOR
29cf					endif 
29cf			 
29cf 7e					ld a,(hl) 
29d0 93					sub e 
29d1 77					ld (hl),a 
29d2			 
29d2			 
29d2			 
29d2				       NEXTW 
29d2 c3 7e 1b			jp macro_next 
29d5				endm 
# End of macro NEXTW
29d5			 
29d5			.INC2: 
29d5				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
29d5 6f				db WORD_SYS_CORE+91             
29d6 7f 2a			dw .DEC2            
29d8 04				db 3 + 1 
29d9 .. 00			db "+2!",0              
29dd				endm 
# End of macro CWHEAD
29dd			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
29dd			 
29dd					if DEBUG_FORTH_WORDS_KEY 
29dd						DMARK "+2s" 
29dd f5				push af  
29de 3a f2 29			ld a, (.dmark)  
29e1 32 77 fb			ld (debug_mark),a  
29e4 3a f3 29			ld a, (.dmark+1)  
29e7 32 78 fb			ld (debug_mark+1),a  
29ea 3a f4 29			ld a, (.dmark+2)  
29ed 32 79 fb			ld (debug_mark+2),a  
29f0 18 03			jr .pastdmark  
29f2 ..			.dmark: db "+2s"  
29f5 f1			.pastdmark: pop af  
29f6			endm  
# End of macro DMARK
29f6						CALLMONITOR 
29f6 cd 00 14			call break_point_state  
29f9				endm  
# End of macro CALLMONITOR
29f9					endif 
29f9			 
29f9					; Address 
29f9			 
29f9					FORTH_DSP_VALUEHL 
29f9 cd 28 1a			call macro_dsp_valuehl 
29fc				endm 
# End of macro FORTH_DSP_VALUEHL
29fc			 
29fc e5					push hl    ; save address 
29fd			 
29fd					; load content into de 
29fd			 
29fd 5e					ld e,(hl) 
29fe 23					inc hl 
29ff 56					ld d, (hl) 
2a00			 
2a00					if DEBUG_FORTH_WORDS 
2a00						DMARK "+2a" 
2a00 f5				push af  
2a01 3a 15 2a			ld a, (.dmark)  
2a04 32 77 fb			ld (debug_mark),a  
2a07 3a 16 2a			ld a, (.dmark+1)  
2a0a 32 78 fb			ld (debug_mark+1),a  
2a0d 3a 17 2a			ld a, (.dmark+2)  
2a10 32 79 fb			ld (debug_mark+2),a  
2a13 18 03			jr .pastdmark  
2a15 ..			.dmark: db "+2a"  
2a18 f1			.pastdmark: pop af  
2a19			endm  
# End of macro DMARK
2a19						CALLMONITOR 
2a19 cd 00 14			call break_point_state  
2a1c				endm  
# End of macro CALLMONITOR
2a1c					endif 
2a1c			 
2a1c					FORTH_DSP_POP 
2a1c cd c4 1a			call macro_forth_dsp_pop 
2a1f				endm 
# End of macro FORTH_DSP_POP
2a1f			 
2a1f					; Get value to add 
2a1f			 
2a1f					FORTH_DSP_VALUE 
2a1f cd 11 1a			call macro_forth_dsp_value 
2a22				endm 
# End of macro FORTH_DSP_VALUE
2a22			 
2a22					if DEBUG_FORTH_WORDS 
2a22						DMARK "+2v" 
2a22 f5				push af  
2a23 3a 37 2a			ld a, (.dmark)  
2a26 32 77 fb			ld (debug_mark),a  
2a29 3a 38 2a			ld a, (.dmark+1)  
2a2c 32 78 fb			ld (debug_mark+1),a  
2a2f 3a 39 2a			ld a, (.dmark+2)  
2a32 32 79 fb			ld (debug_mark+2),a  
2a35 18 03			jr .pastdmark  
2a37 ..			.dmark: db "+2v"  
2a3a f1			.pastdmark: pop af  
2a3b			endm  
# End of macro DMARK
2a3b						CALLMONITOR 
2a3b cd 00 14			call break_point_state  
2a3e				endm  
# End of macro CALLMONITOR
2a3e					endif 
2a3e			 
2a3e 19					add hl, de 
2a3f			 
2a3f					if DEBUG_FORTH_WORDS 
2a3f						DMARK "+2+" 
2a3f f5				push af  
2a40 3a 54 2a			ld a, (.dmark)  
2a43 32 77 fb			ld (debug_mark),a  
2a46 3a 55 2a			ld a, (.dmark+1)  
2a49 32 78 fb			ld (debug_mark+1),a  
2a4c 3a 56 2a			ld a, (.dmark+2)  
2a4f 32 79 fb			ld (debug_mark+2),a  
2a52 18 03			jr .pastdmark  
2a54 ..			.dmark: db "+2+"  
2a57 f1			.pastdmark: pop af  
2a58			endm  
# End of macro DMARK
2a58						CALLMONITOR 
2a58 cd 00 14			call break_point_state  
2a5b				endm  
# End of macro CALLMONITOR
2a5b					endif 
2a5b			 
2a5b					; move result to de 
2a5b			 
2a5b eb					ex de, hl 
2a5c			 
2a5c					; Address 
2a5c			 
2a5c e1					pop hl 
2a5d			 
2a5d					; save it back 
2a5d			 
2a5d 73					ld (hl), e 
2a5e 23					inc hl 
2a5f 72					ld (hl), d 
2a60			 
2a60					if DEBUG_FORTH_WORDS 
2a60						DMARK "+2e" 
2a60 f5				push af  
2a61 3a 75 2a			ld a, (.dmark)  
2a64 32 77 fb			ld (debug_mark),a  
2a67 3a 76 2a			ld a, (.dmark+1)  
2a6a 32 78 fb			ld (debug_mark+1),a  
2a6d 3a 77 2a			ld a, (.dmark+2)  
2a70 32 79 fb			ld (debug_mark+2),a  
2a73 18 03			jr .pastdmark  
2a75 ..			.dmark: db "+2e"  
2a78 f1			.pastdmark: pop af  
2a79			endm  
# End of macro DMARK
2a79						CALLMONITOR 
2a79 cd 00 14			call break_point_state  
2a7c				endm  
# End of macro CALLMONITOR
2a7c					endif 
2a7c			 
2a7c			 
2a7c			 
2a7c			 
2a7c			 
2a7c				       NEXTW 
2a7c c3 7e 1b			jp macro_next 
2a7f				endm 
# End of macro NEXTW
2a7f			 
2a7f			.DEC2: 
2a7f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2a7f 6f				db WORD_SYS_CORE+91             
2a80 2b 2b			dw .GET2            
2a82 04				db 3 + 1 
2a83 .. 00			db "-2!",0              
2a87				endm 
# End of macro CWHEAD
2a87			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2a87			 
2a87			 
2a87					if DEBUG_FORTH_WORDS_KEY 
2a87						DMARK "-2s" 
2a87 f5				push af  
2a88 3a 9c 2a			ld a, (.dmark)  
2a8b 32 77 fb			ld (debug_mark),a  
2a8e 3a 9d 2a			ld a, (.dmark+1)  
2a91 32 78 fb			ld (debug_mark+1),a  
2a94 3a 9e 2a			ld a, (.dmark+2)  
2a97 32 79 fb			ld (debug_mark+2),a  
2a9a 18 03			jr .pastdmark  
2a9c ..			.dmark: db "-2s"  
2a9f f1			.pastdmark: pop af  
2aa0			endm  
# End of macro DMARK
2aa0						CALLMONITOR 
2aa0 cd 00 14			call break_point_state  
2aa3				endm  
# End of macro CALLMONITOR
2aa3					endif 
2aa3			 
2aa3					; Address 
2aa3			 
2aa3					FORTH_DSP_VALUEHL 
2aa3 cd 28 1a			call macro_dsp_valuehl 
2aa6				endm 
# End of macro FORTH_DSP_VALUEHL
2aa6			 
2aa6 e5					push hl    ; save address 
2aa7			 
2aa7					; load content into de 
2aa7			 
2aa7 5e					ld e,(hl) 
2aa8 23					inc hl 
2aa9 56					ld d, (hl) 
2aaa			 
2aaa					if DEBUG_FORTH_WORDS 
2aaa						DMARK "-2a" 
2aaa f5				push af  
2aab 3a bf 2a			ld a, (.dmark)  
2aae 32 77 fb			ld (debug_mark),a  
2ab1 3a c0 2a			ld a, (.dmark+1)  
2ab4 32 78 fb			ld (debug_mark+1),a  
2ab7 3a c1 2a			ld a, (.dmark+2)  
2aba 32 79 fb			ld (debug_mark+2),a  
2abd 18 03			jr .pastdmark  
2abf ..			.dmark: db "-2a"  
2ac2 f1			.pastdmark: pop af  
2ac3			endm  
# End of macro DMARK
2ac3						CALLMONITOR 
2ac3 cd 00 14			call break_point_state  
2ac6				endm  
# End of macro CALLMONITOR
2ac6					endif 
2ac6			 
2ac6					FORTH_DSP_POP 
2ac6 cd c4 1a			call macro_forth_dsp_pop 
2ac9				endm 
# End of macro FORTH_DSP_POP
2ac9			 
2ac9					; Get value to remove 
2ac9			 
2ac9					FORTH_DSP_VALUE 
2ac9 cd 11 1a			call macro_forth_dsp_value 
2acc				endm 
# End of macro FORTH_DSP_VALUE
2acc			 
2acc					if DEBUG_FORTH_WORDS 
2acc						DMARK "-2v" 
2acc f5				push af  
2acd 3a e1 2a			ld a, (.dmark)  
2ad0 32 77 fb			ld (debug_mark),a  
2ad3 3a e2 2a			ld a, (.dmark+1)  
2ad6 32 78 fb			ld (debug_mark+1),a  
2ad9 3a e3 2a			ld a, (.dmark+2)  
2adc 32 79 fb			ld (debug_mark+2),a  
2adf 18 03			jr .pastdmark  
2ae1 ..			.dmark: db "-2v"  
2ae4 f1			.pastdmark: pop af  
2ae5			endm  
# End of macro DMARK
2ae5						CALLMONITOR 
2ae5 cd 00 14			call break_point_state  
2ae8				endm  
# End of macro CALLMONITOR
2ae8					endif 
2ae8			 
2ae8 eb					ex de, hl 
2ae9 ed 52				sbc hl, de 
2aeb			 
2aeb					if DEBUG_FORTH_WORDS 
2aeb						DMARK "-2d" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 77 fb			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 78 fb			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 79 fb			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "-2d"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04						CALLMONITOR 
2b04 cd 00 14			call break_point_state  
2b07				endm  
# End of macro CALLMONITOR
2b07					endif 
2b07			 
2b07					; move result to de 
2b07			 
2b07 eb					ex de, hl 
2b08			 
2b08					; Address 
2b08			 
2b08 e1					pop hl 
2b09			 
2b09					; save it back 
2b09			 
2b09 73					ld (hl), e 
2b0a 23					inc hl 
2b0b 72					ld (hl), d 
2b0c			 
2b0c					if DEBUG_FORTH_WORDS 
2b0c						DMARK "-2e" 
2b0c f5				push af  
2b0d 3a 21 2b			ld a, (.dmark)  
2b10 32 77 fb			ld (debug_mark),a  
2b13 3a 22 2b			ld a, (.dmark+1)  
2b16 32 78 fb			ld (debug_mark+1),a  
2b19 3a 23 2b			ld a, (.dmark+2)  
2b1c 32 79 fb			ld (debug_mark+2),a  
2b1f 18 03			jr .pastdmark  
2b21 ..			.dmark: db "-2e"  
2b24 f1			.pastdmark: pop af  
2b25			endm  
# End of macro DMARK
2b25						CALLMONITOR 
2b25 cd 00 14			call break_point_state  
2b28				endm  
# End of macro CALLMONITOR
2b28					endif 
2b28			 
2b28			 
2b28			 
2b28			 
2b28			 
2b28				       NEXTW 
2b28 c3 7e 1b			jp macro_next 
2b2b				endm 
# End of macro NEXTW
2b2b			.GET2: 
2b2b				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b2b 6f				db WORD_SYS_CORE+91             
2b2c 5b 2b			dw .BANG2            
2b2e 03				db 2 + 1 
2b2f .. 00			db "2@",0              
2b32				endm 
# End of macro CWHEAD
2b32			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b32					if DEBUG_FORTH_WORDS_KEY 
2b32						DMARK "2A_" 
2b32 f5				push af  
2b33 3a 47 2b			ld a, (.dmark)  
2b36 32 77 fb			ld (debug_mark),a  
2b39 3a 48 2b			ld a, (.dmark+1)  
2b3c 32 78 fb			ld (debug_mark+1),a  
2b3f 3a 49 2b			ld a, (.dmark+2)  
2b42 32 79 fb			ld (debug_mark+2),a  
2b45 18 03			jr .pastdmark  
2b47 ..			.dmark: db "2A_"  
2b4a f1			.pastdmark: pop af  
2b4b			endm  
# End of macro DMARK
2b4b						CALLMONITOR 
2b4b cd 00 14			call break_point_state  
2b4e				endm  
# End of macro CALLMONITOR
2b4e					endif 
2b4e			 
2b4e					FORTH_DSP_VALUEHL 
2b4e cd 28 1a			call macro_dsp_valuehl 
2b51				endm 
# End of macro FORTH_DSP_VALUEHL
2b51			 
2b51 5e					ld e, (hl) 
2b52 23					inc hl 
2b53 56					ld d, (hl) 
2b54			 
2b54 eb					ex de, hl 
2b55			 
2b55 cd 8d 19				call forth_push_numhl 
2b58			 
2b58				       NEXTW 
2b58 c3 7e 1b			jp macro_next 
2b5b				endm 
# End of macro NEXTW
2b5b			.BANG2: 
2b5b				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
2b5b 6f				db WORD_SYS_CORE+91             
2b5c 93 2b			dw .ENDCORE            
2b5e 03				db 2 + 1 
2b5f .. 00			db "2!",0              
2b62				endm 
# End of macro CWHEAD
2b62			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b62					if DEBUG_FORTH_WORDS_KEY 
2b62						DMARK "2S_" 
2b62 f5				push af  
2b63 3a 77 2b			ld a, (.dmark)  
2b66 32 77 fb			ld (debug_mark),a  
2b69 3a 78 2b			ld a, (.dmark+1)  
2b6c 32 78 fb			ld (debug_mark+1),a  
2b6f 3a 79 2b			ld a, (.dmark+2)  
2b72 32 79 fb			ld (debug_mark+2),a  
2b75 18 03			jr .pastdmark  
2b77 ..			.dmark: db "2S_"  
2b7a f1			.pastdmark: pop af  
2b7b			endm  
# End of macro DMARK
2b7b						CALLMONITOR 
2b7b cd 00 14			call break_point_state  
2b7e				endm  
# End of macro CALLMONITOR
2b7e					endif 
2b7e			 
2b7e					FORTH_DSP_VALUEHL 
2b7e cd 28 1a			call macro_dsp_valuehl 
2b81				endm 
# End of macro FORTH_DSP_VALUEHL
2b81			 
2b81 e5					push hl   ; save address 
2b82			 
2b82			 
2b82					FORTH_DSP_POP 
2b82 cd c4 1a			call macro_forth_dsp_pop 
2b85				endm 
# End of macro FORTH_DSP_POP
2b85			 
2b85					 
2b85					FORTH_DSP_VALUEHL 
2b85 cd 28 1a			call macro_dsp_valuehl 
2b88				endm 
# End of macro FORTH_DSP_VALUEHL
2b88			 
2b88					FORTH_DSP_POP 
2b88 cd c4 1a			call macro_forth_dsp_pop 
2b8b				endm 
# End of macro FORTH_DSP_POP
2b8b			 
2b8b eb					ex de, hl    ; value now in de 
2b8c			 
2b8c e1					pop hl 
2b8d			 
2b8d 73					ld (hl), e 
2b8e			 
2b8e 23					inc hl 
2b8f			 
2b8f 72					ld (hl), d 
2b90			 
2b90			 
2b90				       NEXTW 
2b90 c3 7e 1b			jp macro_next 
2b93				endm 
# End of macro NEXTW
2b93			.ENDCORE: 
2b93			 
2b93			; eof 
2b93			 
2b93			 
# End of file forth_words_core.asm
2b93			include "forth_words_flow.asm" 
2b93			 
2b93			; | ## Program Flow Words 
2b93			 
2b93			.IF: 
2b93				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2b93 1e				db WORD_SYS_CORE+10             
2b94 88 2c			dw .THEN            
2b96 03				db 2 + 1 
2b97 .. 00			db "IF",0              
2b9a				endm 
# End of macro CWHEAD
2b9a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2b9a			; 
2b9a					if DEBUG_FORTH_WORDS_KEY 
2b9a						DMARK "IF." 
2b9a f5				push af  
2b9b 3a af 2b			ld a, (.dmark)  
2b9e 32 77 fb			ld (debug_mark),a  
2ba1 3a b0 2b			ld a, (.dmark+1)  
2ba4 32 78 fb			ld (debug_mark+1),a  
2ba7 3a b1 2b			ld a, (.dmark+2)  
2baa 32 79 fb			ld (debug_mark+2),a  
2bad 18 03			jr .pastdmark  
2baf ..			.dmark: db "IF."  
2bb2 f1			.pastdmark: pop af  
2bb3			endm  
# End of macro DMARK
2bb3						CALLMONITOR 
2bb3 cd 00 14			call break_point_state  
2bb6				endm  
# End of macro CALLMONITOR
2bb6					endif 
2bb6			; eval TOS 
2bb6			 
2bb6				FORTH_DSP_VALUEHL 
2bb6 cd 28 1a			call macro_dsp_valuehl 
2bb9				endm 
# End of macro FORTH_DSP_VALUEHL
2bb9			 
2bb9			;	push hl 
2bb9				FORTH_DSP_POP 
2bb9 cd c4 1a			call macro_forth_dsp_pop 
2bbc				endm 
# End of macro FORTH_DSP_POP
2bbc			;	pop hl 
2bbc			 
2bbc					if DEBUG_FORTH_WORDS 
2bbc						DMARK "IF1" 
2bbc f5				push af  
2bbd 3a d1 2b			ld a, (.dmark)  
2bc0 32 77 fb			ld (debug_mark),a  
2bc3 3a d2 2b			ld a, (.dmark+1)  
2bc6 32 78 fb			ld (debug_mark+1),a  
2bc9 3a d3 2b			ld a, (.dmark+2)  
2bcc 32 79 fb			ld (debug_mark+2),a  
2bcf 18 03			jr .pastdmark  
2bd1 ..			.dmark: db "IF1"  
2bd4 f1			.pastdmark: pop af  
2bd5			endm  
# End of macro DMARK
2bd5						CALLMONITOR 
2bd5 cd 00 14			call break_point_state  
2bd8				endm  
# End of macro CALLMONITOR
2bd8					endif 
2bd8 b7				or a        ; clear carry flag 
2bd9 11 00 00			ld de, 0 
2bdc eb				ex de,hl 
2bdd ed 52			sbc hl, de 
2bdf c2 69 2c			jp nz, .iftrue 
2be2			 
2be2					if DEBUG_FORTH_WORDS 
2be2						DMARK "IF2" 
2be2 f5				push af  
2be3 3a f7 2b			ld a, (.dmark)  
2be6 32 77 fb			ld (debug_mark),a  
2be9 3a f8 2b			ld a, (.dmark+1)  
2bec 32 78 fb			ld (debug_mark+1),a  
2bef 3a f9 2b			ld a, (.dmark+2)  
2bf2 32 79 fb			ld (debug_mark+2),a  
2bf5 18 03			jr .pastdmark  
2bf7 ..			.dmark: db "IF2"  
2bfa f1			.pastdmark: pop af  
2bfb			endm  
# End of macro DMARK
2bfb						CALLMONITOR 
2bfb cd 00 14			call break_point_state  
2bfe				endm  
# End of macro CALLMONITOR
2bfe					endif 
2bfe			 
2bfe			; if not true then skip to THEN 
2bfe			 
2bfe				; TODO get tok_ptr 
2bfe				; TODO consume toks until we get to THEN 
2bfe			 
2bfe 2a 33 f1			ld hl, (os_tok_ptr) 
2c01					if DEBUG_FORTH_WORDS 
2c01						DMARK "IF3" 
2c01 f5				push af  
2c02 3a 16 2c			ld a, (.dmark)  
2c05 32 77 fb			ld (debug_mark),a  
2c08 3a 17 2c			ld a, (.dmark+1)  
2c0b 32 78 fb			ld (debug_mark+1),a  
2c0e 3a 18 2c			ld a, (.dmark+2)  
2c11 32 79 fb			ld (debug_mark+2),a  
2c14 18 03			jr .pastdmark  
2c16 ..			.dmark: db "IF3"  
2c19 f1			.pastdmark: pop af  
2c1a			endm  
# End of macro DMARK
2c1a						CALLMONITOR 
2c1a cd 00 14			call break_point_state  
2c1d				endm  
# End of macro CALLMONITOR
2c1d						 
2c1d					endif 
2c1d 11 64 2c			ld de, .ifthen 
2c20					if DEBUG_FORTH_WORDS 
2c20						DMARK "IF4" 
2c20 f5				push af  
2c21 3a 35 2c			ld a, (.dmark)  
2c24 32 77 fb			ld (debug_mark),a  
2c27 3a 36 2c			ld a, (.dmark+1)  
2c2a 32 78 fb			ld (debug_mark+1),a  
2c2d 3a 37 2c			ld a, (.dmark+2)  
2c30 32 79 fb			ld (debug_mark+2),a  
2c33 18 03			jr .pastdmark  
2c35 ..			.dmark: db "IF4"  
2c38 f1			.pastdmark: pop af  
2c39			endm  
# End of macro DMARK
2c39						CALLMONITOR 
2c39 cd 00 14			call break_point_state  
2c3c				endm  
# End of macro CALLMONITOR
2c3c					endif 
2c3c cd 99 1c			call findnexttok  
2c3f			 
2c3f					if DEBUG_FORTH_WORDS 
2c3f						DMARK "IF5" 
2c3f f5				push af  
2c40 3a 54 2c			ld a, (.dmark)  
2c43 32 77 fb			ld (debug_mark),a  
2c46 3a 55 2c			ld a, (.dmark+1)  
2c49 32 78 fb			ld (debug_mark+1),a  
2c4c 3a 56 2c			ld a, (.dmark+2)  
2c4f 32 79 fb			ld (debug_mark+2),a  
2c52 18 03			jr .pastdmark  
2c54 ..			.dmark: db "IF5"  
2c57 f1			.pastdmark: pop af  
2c58			endm  
# End of macro DMARK
2c58						CALLMONITOR 
2c58 cd 00 14			call break_point_state  
2c5b				endm  
# End of macro CALLMONITOR
2c5b					endif 
2c5b				; TODO replace below with ; exec using tok_ptr 
2c5b 22 33 f1			ld (os_tok_ptr), hl 
2c5e c3 0f 1c			jp exec1 
2c61				NEXTW 
2c61 c3 7e 1b			jp macro_next 
2c64				endm 
# End of macro NEXTW
2c64			 
2c64 .. 00		.ifthen:  db "THEN",0 
2c69			 
2c69			.iftrue:		 
2c69				; Exec next words normally 
2c69			 
2c69				; if true then exec following IF as normal 
2c69					if DEBUG_FORTH_WORDS 
2c69						DMARK "IFT" 
2c69 f5				push af  
2c6a 3a 7e 2c			ld a, (.dmark)  
2c6d 32 77 fb			ld (debug_mark),a  
2c70 3a 7f 2c			ld a, (.dmark+1)  
2c73 32 78 fb			ld (debug_mark+1),a  
2c76 3a 80 2c			ld a, (.dmark+2)  
2c79 32 79 fb			ld (debug_mark+2),a  
2c7c 18 03			jr .pastdmark  
2c7e ..			.dmark: db "IFT"  
2c81 f1			.pastdmark: pop af  
2c82			endm  
# End of macro DMARK
2c82						CALLMONITOR 
2c82 cd 00 14			call break_point_state  
2c85				endm  
# End of macro CALLMONITOR
2c85					endif 
2c85			 
2c85					NEXTW 
2c85 c3 7e 1b			jp macro_next 
2c88				endm 
# End of macro NEXTW
2c88			.THEN: 
2c88				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2c88 1f				db WORD_SYS_CORE+11             
2c89 b0 2c			dw .ELSE            
2c8b 05				db 4 + 1 
2c8c .. 00			db "THEN",0              
2c91				endm 
# End of macro CWHEAD
2c91			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2c91					if DEBUG_FORTH_WORDS_KEY 
2c91						DMARK "THN" 
2c91 f5				push af  
2c92 3a a6 2c			ld a, (.dmark)  
2c95 32 77 fb			ld (debug_mark),a  
2c98 3a a7 2c			ld a, (.dmark+1)  
2c9b 32 78 fb			ld (debug_mark+1),a  
2c9e 3a a8 2c			ld a, (.dmark+2)  
2ca1 32 79 fb			ld (debug_mark+2),a  
2ca4 18 03			jr .pastdmark  
2ca6 ..			.dmark: db "THN"  
2ca9 f1			.pastdmark: pop af  
2caa			endm  
# End of macro DMARK
2caa						CALLMONITOR 
2caa cd 00 14			call break_point_state  
2cad				endm  
# End of macro CALLMONITOR
2cad					endif 
2cad					NEXTW 
2cad c3 7e 1b			jp macro_next 
2cb0				endm 
# End of macro NEXTW
2cb0			.ELSE: 
2cb0				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2cb0 20				db WORD_SYS_CORE+12             
2cb1 d8 2c			dw .DO            
2cb3 03				db 2 + 1 
2cb4 .. 00			db "ELSE",0              
2cb9				endm 
# End of macro CWHEAD
2cb9			; | ELSE ( -- ) Not supported - does nothing | TODO 
2cb9			 
2cb9					if DEBUG_FORTH_WORDS_KEY 
2cb9						DMARK "ELS" 
2cb9 f5				push af  
2cba 3a ce 2c			ld a, (.dmark)  
2cbd 32 77 fb			ld (debug_mark),a  
2cc0 3a cf 2c			ld a, (.dmark+1)  
2cc3 32 78 fb			ld (debug_mark+1),a  
2cc6 3a d0 2c			ld a, (.dmark+2)  
2cc9 32 79 fb			ld (debug_mark+2),a  
2ccc 18 03			jr .pastdmark  
2cce ..			.dmark: db "ELS"  
2cd1 f1			.pastdmark: pop af  
2cd2			endm  
# End of macro DMARK
2cd2						CALLMONITOR 
2cd2 cd 00 14			call break_point_state  
2cd5				endm  
# End of macro CALLMONITOR
2cd5					endif 
2cd5			 
2cd5			 
2cd5					NEXTW 
2cd5 c3 7e 1b			jp macro_next 
2cd8				endm 
# End of macro NEXTW
2cd8			.DO: 
2cd8				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2cd8 21				db WORD_SYS_CORE+13             
2cd9 ff 2d			dw .LOOP            
2cdb 03				db 2 + 1 
2cdc .. 00			db "DO",0              
2cdf				endm 
# End of macro CWHEAD
2cdf			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2cdf			 
2cdf					if DEBUG_FORTH_WORDS_KEY 
2cdf						DMARK "DO." 
2cdf f5				push af  
2ce0 3a f4 2c			ld a, (.dmark)  
2ce3 32 77 fb			ld (debug_mark),a  
2ce6 3a f5 2c			ld a, (.dmark+1)  
2ce9 32 78 fb			ld (debug_mark+1),a  
2cec 3a f6 2c			ld a, (.dmark+2)  
2cef 32 79 fb			ld (debug_mark+2),a  
2cf2 18 03			jr .pastdmark  
2cf4 ..			.dmark: db "DO."  
2cf7 f1			.pastdmark: pop af  
2cf8			endm  
# End of macro DMARK
2cf8						CALLMONITOR 
2cf8 cd 00 14			call break_point_state  
2cfb				endm  
# End of macro CALLMONITOR
2cfb					endif 
2cfb			;  push pc to rsp stack past the DO 
2cfb			 
2cfb 2a 33 f1				ld hl, (os_tok_ptr) 
2cfe 23					inc hl   ; D 
2cff 23					inc hl  ; O 
2d00 23					inc hl   ; null 
2d01					if DEBUG_FORTH_WORDS 
2d01						DMARK "DO2" 
2d01 f5				push af  
2d02 3a 16 2d			ld a, (.dmark)  
2d05 32 77 fb			ld (debug_mark),a  
2d08 3a 17 2d			ld a, (.dmark+1)  
2d0b 32 78 fb			ld (debug_mark+1),a  
2d0e 3a 18 2d			ld a, (.dmark+2)  
2d11 32 79 fb			ld (debug_mark+2),a  
2d14 18 03			jr .pastdmark  
2d16 ..			.dmark: db "DO2"  
2d19 f1			.pastdmark: pop af  
2d1a			endm  
# End of macro DMARK
2d1a						CALLMONITOR 
2d1a cd 00 14			call break_point_state  
2d1d				endm  
# End of macro CALLMONITOR
2d1d					endif 
2d1d					FORTH_RSP_NEXT 
2d1d cd 34 19			call macro_forth_rsp_next 
2d20				endm 
# End of macro FORTH_RSP_NEXT
2d20					if DEBUG_FORTH_WORDS 
2d20						DMARK "DO3" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 77 fb			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 78 fb			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 79 fb			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "DO3"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39						CALLMONITOR 
2d39 cd 00 14			call break_point_state  
2d3c				endm  
# End of macro CALLMONITOR
2d3c					endif 
2d3c			 
2d3c					;if DEBUG_FORTH_WORDS 
2d3c				;		push hl 
2d3c			;		endif  
2d3c			 
2d3c			; get counters from data stack 
2d3c			 
2d3c			 
2d3c					FORTH_DSP_VALUEHL 
2d3c cd 28 1a			call macro_dsp_valuehl 
2d3f				endm 
# End of macro FORTH_DSP_VALUEHL
2d3f e5					push hl		 ; hl now has starting counter which needs to be tos 
2d40			 
2d40					if DEBUG_FORTH_WORDS 
2d40						DMARK "DO4" 
2d40 f5				push af  
2d41 3a 55 2d			ld a, (.dmark)  
2d44 32 77 fb			ld (debug_mark),a  
2d47 3a 56 2d			ld a, (.dmark+1)  
2d4a 32 78 fb			ld (debug_mark+1),a  
2d4d 3a 57 2d			ld a, (.dmark+2)  
2d50 32 79 fb			ld (debug_mark+2),a  
2d53 18 03			jr .pastdmark  
2d55 ..			.dmark: db "DO4"  
2d58 f1			.pastdmark: pop af  
2d59			endm  
# End of macro DMARK
2d59						CALLMONITOR 
2d59 cd 00 14			call break_point_state  
2d5c				endm  
# End of macro CALLMONITOR
2d5c					endif 
2d5c					FORTH_DSP_POP 
2d5c cd c4 1a			call macro_forth_dsp_pop 
2d5f				endm 
# End of macro FORTH_DSP_POP
2d5f			 
2d5f					if DEBUG_FORTH_WORDS 
2d5f						DMARK "DO5" 
2d5f f5				push af  
2d60 3a 74 2d			ld a, (.dmark)  
2d63 32 77 fb			ld (debug_mark),a  
2d66 3a 75 2d			ld a, (.dmark+1)  
2d69 32 78 fb			ld (debug_mark+1),a  
2d6c 3a 76 2d			ld a, (.dmark+2)  
2d6f 32 79 fb			ld (debug_mark+2),a  
2d72 18 03			jr .pastdmark  
2d74 ..			.dmark: db "DO5"  
2d77 f1			.pastdmark: pop af  
2d78			endm  
# End of macro DMARK
2d78						CALLMONITOR 
2d78 cd 00 14			call break_point_state  
2d7b				endm  
# End of macro CALLMONITOR
2d7b					endif 
2d7b			 
2d7b					FORTH_DSP_VALUEHL 
2d7b cd 28 1a			call macro_dsp_valuehl 
2d7e				endm 
# End of macro FORTH_DSP_VALUEHL
2d7e			;		push hl		 ; hl now has starting limit counter 
2d7e			 
2d7e					if DEBUG_FORTH_WORDS 
2d7e						DMARK "DO6" 
2d7e f5				push af  
2d7f 3a 93 2d			ld a, (.dmark)  
2d82 32 77 fb			ld (debug_mark),a  
2d85 3a 94 2d			ld a, (.dmark+1)  
2d88 32 78 fb			ld (debug_mark+1),a  
2d8b 3a 95 2d			ld a, (.dmark+2)  
2d8e 32 79 fb			ld (debug_mark+2),a  
2d91 18 03			jr .pastdmark  
2d93 ..			.dmark: db "DO6"  
2d96 f1			.pastdmark: pop af  
2d97			endm  
# End of macro DMARK
2d97						CALLMONITOR 
2d97 cd 00 14			call break_point_state  
2d9a				endm  
# End of macro CALLMONITOR
2d9a					endif 
2d9a					FORTH_DSP_POP 
2d9a cd c4 1a			call macro_forth_dsp_pop 
2d9d				endm 
# End of macro FORTH_DSP_POP
2d9d			 
2d9d			; put counters on the loop stack 
2d9d			 
2d9d			;		pop hl			 ; limit counter 
2d9d d1					pop de			; start counter 
2d9e			 
2d9e					; push limit counter 
2d9e			 
2d9e					if DEBUG_FORTH_WORDS 
2d9e						DMARK "DO7" 
2d9e f5				push af  
2d9f 3a b3 2d			ld a, (.dmark)  
2da2 32 77 fb			ld (debug_mark),a  
2da5 3a b4 2d			ld a, (.dmark+1)  
2da8 32 78 fb			ld (debug_mark+1),a  
2dab 3a b5 2d			ld a, (.dmark+2)  
2dae 32 79 fb			ld (debug_mark+2),a  
2db1 18 03			jr .pastdmark  
2db3 ..			.dmark: db "DO7"  
2db6 f1			.pastdmark: pop af  
2db7			endm  
# End of macro DMARK
2db7						CALLMONITOR 
2db7 cd 00 14			call break_point_state  
2dba				endm  
# End of macro CALLMONITOR
2dba					endif 
2dba					FORTH_LOOP_NEXT 
2dba cd 3d 1a			call macro_forth_loop_next 
2dbd				endm 
# End of macro FORTH_LOOP_NEXT
2dbd			 
2dbd					; push start counter 
2dbd			 
2dbd eb					ex de, hl 
2dbe					if DEBUG_FORTH_WORDS 
2dbe						DMARK "DO7" 
2dbe f5				push af  
2dbf 3a d3 2d			ld a, (.dmark)  
2dc2 32 77 fb			ld (debug_mark),a  
2dc5 3a d4 2d			ld a, (.dmark+1)  
2dc8 32 78 fb			ld (debug_mark+1),a  
2dcb 3a d5 2d			ld a, (.dmark+2)  
2dce 32 79 fb			ld (debug_mark+2),a  
2dd1 18 03			jr .pastdmark  
2dd3 ..			.dmark: db "DO7"  
2dd6 f1			.pastdmark: pop af  
2dd7			endm  
# End of macro DMARK
2dd7						CALLMONITOR 
2dd7 cd 00 14			call break_point_state  
2dda				endm  
# End of macro CALLMONITOR
2dda					endif 
2dda					FORTH_LOOP_NEXT 
2dda cd 3d 1a			call macro_forth_loop_next 
2ddd				endm 
# End of macro FORTH_LOOP_NEXT
2ddd			 
2ddd			 
2ddd					; init first round of I counter 
2ddd			 
2ddd 22 57 f1				ld (os_current_i), hl 
2de0			 
2de0					if DEBUG_FORTH_WORDS 
2de0						DMARK "DO8" 
2de0 f5				push af  
2de1 3a f5 2d			ld a, (.dmark)  
2de4 32 77 fb			ld (debug_mark),a  
2de7 3a f6 2d			ld a, (.dmark+1)  
2dea 32 78 fb			ld (debug_mark+1),a  
2ded 3a f7 2d			ld a, (.dmark+2)  
2df0 32 79 fb			ld (debug_mark+2),a  
2df3 18 03			jr .pastdmark  
2df5 ..			.dmark: db "DO8"  
2df8 f1			.pastdmark: pop af  
2df9			endm  
# End of macro DMARK
2df9						CALLMONITOR 
2df9 cd 00 14			call break_point_state  
2dfc				endm  
# End of macro CALLMONITOR
2dfc					endif 
2dfc			 
2dfc					NEXTW 
2dfc c3 7e 1b			jp macro_next 
2dff				endm 
# End of macro NEXTW
2dff			.LOOP: 
2dff				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2dff 22				db WORD_SYS_CORE+14             
2e00 17 2f			dw .I            
2e02 05				db 4 + 1 
2e03 .. 00			db "LOOP",0              
2e08				endm 
# End of macro CWHEAD
2e08			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e08			 
2e08				; pop tos as current loop count to hl 
2e08			 
2e08				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e08			 
2e08				FORTH_LOOP_TOS 
2e08 cd 70 1a			call macro_forth_loop_tos 
2e0b				endm 
# End of macro FORTH_LOOP_TOS
2e0b e5				push hl 
2e0c			 
2e0c					if DEBUG_FORTH_WORDS_KEY 
2e0c						DMARK "LOP" 
2e0c f5				push af  
2e0d 3a 21 2e			ld a, (.dmark)  
2e10 32 77 fb			ld (debug_mark),a  
2e13 3a 22 2e			ld a, (.dmark+1)  
2e16 32 78 fb			ld (debug_mark+1),a  
2e19 3a 23 2e			ld a, (.dmark+2)  
2e1c 32 79 fb			ld (debug_mark+2),a  
2e1f 18 03			jr .pastdmark  
2e21 ..			.dmark: db "LOP"  
2e24 f1			.pastdmark: pop af  
2e25			endm  
# End of macro DMARK
2e25						CALLMONITOR 
2e25 cd 00 14			call break_point_state  
2e28				endm  
# End of macro CALLMONITOR
2e28					endif 
2e28				; next item on the stack is the limit. get it 
2e28			 
2e28			 
2e28				FORTH_LOOP_POP 
2e28 cd 7a 1a			call macro_forth_loop_pop 
2e2b				endm 
# End of macro FORTH_LOOP_POP
2e2b			 
2e2b				FORTH_LOOP_TOS 
2e2b cd 70 1a			call macro_forth_loop_tos 
2e2e				endm 
# End of macro FORTH_LOOP_TOS
2e2e			 
2e2e d1				pop de		 ; de = i, hl = limit 
2e2f			 
2e2f					if DEBUG_FORTH_WORDS 
2e2f						DMARK "LP1" 
2e2f f5				push af  
2e30 3a 44 2e			ld a, (.dmark)  
2e33 32 77 fb			ld (debug_mark),a  
2e36 3a 45 2e			ld a, (.dmark+1)  
2e39 32 78 fb			ld (debug_mark+1),a  
2e3c 3a 46 2e			ld a, (.dmark+2)  
2e3f 32 79 fb			ld (debug_mark+2),a  
2e42 18 03			jr .pastdmark  
2e44 ..			.dmark: db "LP1"  
2e47 f1			.pastdmark: pop af  
2e48			endm  
# End of macro DMARK
2e48						CALLMONITOR 
2e48 cd 00 14			call break_point_state  
2e4b				endm  
# End of macro CALLMONITOR
2e4b					endif 
2e4b			 
2e4b				; go back to previous word 
2e4b			 
2e4b d5				push de    ; save I for inc later 
2e4c			 
2e4c			 
2e4c				; get limit 
2e4c				;  is I at limit? 
2e4c			 
2e4c			 
2e4c					if DEBUG_FORTH_WORDS 
2e4c						DMARK "LP1" 
2e4c f5				push af  
2e4d 3a 61 2e			ld a, (.dmark)  
2e50 32 77 fb			ld (debug_mark),a  
2e53 3a 62 2e			ld a, (.dmark+1)  
2e56 32 78 fb			ld (debug_mark+1),a  
2e59 3a 63 2e			ld a, (.dmark+2)  
2e5c 32 79 fb			ld (debug_mark+2),a  
2e5f 18 03			jr .pastdmark  
2e61 ..			.dmark: db "LP1"  
2e64 f1			.pastdmark: pop af  
2e65			endm  
# End of macro DMARK
2e65						CALLMONITOR 
2e65 cd 00 14			call break_point_state  
2e68				endm  
# End of macro CALLMONITOR
2e68					endif 
2e68			 
2e68 ed 52			sbc hl, de 
2e6a			 
2e6a			 
2e6a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e6a			 
2e6a 20 26				jr nz, .loopnotdone 
2e6c			 
2e6c e1				pop hl   ; get rid of saved I 
2e6d				FORTH_LOOP_POP     ; get rid of limit 
2e6d cd 7a 1a			call macro_forth_loop_pop 
2e70				endm 
# End of macro FORTH_LOOP_POP
2e70			 
2e70				FORTH_RSP_POP     ; get rid of DO ptr 
2e70 cd 55 19			call macro_forth_rsp_pop 
2e73				endm 
# End of macro FORTH_RSP_POP
2e73			 
2e73			if DEBUG_FORTH_WORDS 
2e73						DMARK "LP>" 
2e73 f5				push af  
2e74 3a 88 2e			ld a, (.dmark)  
2e77 32 77 fb			ld (debug_mark),a  
2e7a 3a 89 2e			ld a, (.dmark+1)  
2e7d 32 78 fb			ld (debug_mark+1),a  
2e80 3a 8a 2e			ld a, (.dmark+2)  
2e83 32 79 fb			ld (debug_mark+2),a  
2e86 18 03			jr .pastdmark  
2e88 ..			.dmark: db "LP>"  
2e8b f1			.pastdmark: pop af  
2e8c			endm  
# End of macro DMARK
2e8c				CALLMONITOR 
2e8c cd 00 14			call break_point_state  
2e8f				endm  
# End of macro CALLMONITOR
2e8f			endif 
2e8f			 
2e8f					NEXTW 
2e8f c3 7e 1b			jp macro_next 
2e92				endm 
# End of macro NEXTW
2e92				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e92			 
2e92			.loopnotdone: 
2e92			 
2e92 e1				pop hl    ; get I 
2e93 23				inc hl 
2e94			 
2e94			   	; save new I 
2e94			 
2e94			 
2e94					; set I counter 
2e94			 
2e94 22 57 f1				ld (os_current_i), hl 
2e97			 
2e97					if DEBUG_FORTH_WORDS 
2e97						DMARK "LPN" 
2e97 f5				push af  
2e98 3a ac 2e			ld a, (.dmark)  
2e9b 32 77 fb			ld (debug_mark),a  
2e9e 3a ad 2e			ld a, (.dmark+1)  
2ea1 32 78 fb			ld (debug_mark+1),a  
2ea4 3a ae 2e			ld a, (.dmark+2)  
2ea7 32 79 fb			ld (debug_mark+2),a  
2eaa 18 03			jr .pastdmark  
2eac ..			.dmark: db "LPN"  
2eaf f1			.pastdmark: pop af  
2eb0			endm  
# End of macro DMARK
2eb0					CALLMONITOR 
2eb0 cd 00 14			call break_point_state  
2eb3				endm  
# End of macro CALLMONITOR
2eb3					endif 
2eb3					 
2eb3				FORTH_LOOP_NEXT 
2eb3 cd 3d 1a			call macro_forth_loop_next 
2eb6				endm 
# End of macro FORTH_LOOP_NEXT
2eb6			 
2eb6			 
2eb6					if DEBUG_FORTH_WORDS 
2eb6 eb						ex de,hl 
2eb7					endif 
2eb7			 
2eb7			;	; get DO ptr 
2eb7			; 
2eb7					if DEBUG_FORTH_WORDS 
2eb7						DMARK "LP7" 
2eb7 f5				push af  
2eb8 3a cc 2e			ld a, (.dmark)  
2ebb 32 77 fb			ld (debug_mark),a  
2ebe 3a cd 2e			ld a, (.dmark+1)  
2ec1 32 78 fb			ld (debug_mark+1),a  
2ec4 3a ce 2e			ld a, (.dmark+2)  
2ec7 32 79 fb			ld (debug_mark+2),a  
2eca 18 03			jr .pastdmark  
2ecc ..			.dmark: db "LP7"  
2ecf f1			.pastdmark: pop af  
2ed0			endm  
# End of macro DMARK
2ed0					CALLMONITOR 
2ed0 cd 00 14			call break_point_state  
2ed3				endm  
# End of macro CALLMONITOR
2ed3					endif 
2ed3				FORTH_RSP_TOS 
2ed3 cd 4b 19			call macro_forth_rsp_tos 
2ed6				endm 
# End of macro FORTH_RSP_TOS
2ed6			 
2ed6					if DEBUG_FORTH_WORDS 
2ed6						DMARK "LP8" 
2ed6 f5				push af  
2ed7 3a eb 2e			ld a, (.dmark)  
2eda 32 77 fb			ld (debug_mark),a  
2edd 3a ec 2e			ld a, (.dmark+1)  
2ee0 32 78 fb			ld (debug_mark+1),a  
2ee3 3a ed 2e			ld a, (.dmark+2)  
2ee6 32 79 fb			ld (debug_mark+2),a  
2ee9 18 03			jr .pastdmark  
2eeb ..			.dmark: db "LP8"  
2eee f1			.pastdmark: pop af  
2eef			endm  
# End of macro DMARK
2eef					CALLMONITOR 
2eef cd 00 14			call break_point_state  
2ef2				endm  
# End of macro CALLMONITOR
2ef2					endif 
2ef2				;push hl 
2ef2			 
2ef2				; not going to DO any more 
2ef2				; get rid of the RSP pointer as DO will add it back in 
2ef2				;FORTH_RSP_POP 
2ef2				;pop hl 
2ef2			 
2ef2				;ld hl,(cli_ret_sp) 
2ef2				;ld e, (hl) 
2ef2				;inc hl 
2ef2				;ld d, (hl) 
2ef2				;ex de,hl 
2ef2 22 33 f1			ld (os_tok_ptr), hl 
2ef5					if DEBUG_FORTH_WORDS 
2ef5						DMARK "LP<" 
2ef5 f5				push af  
2ef6 3a 0a 2f			ld a, (.dmark)  
2ef9 32 77 fb			ld (debug_mark),a  
2efc 3a 0b 2f			ld a, (.dmark+1)  
2eff 32 78 fb			ld (debug_mark+1),a  
2f02 3a 0c 2f			ld a, (.dmark+2)  
2f05 32 79 fb			ld (debug_mark+2),a  
2f08 18 03			jr .pastdmark  
2f0a ..			.dmark: db "LP<"  
2f0d f1			.pastdmark: pop af  
2f0e			endm  
# End of macro DMARK
2f0e					CALLMONITOR 
2f0e cd 00 14			call break_point_state  
2f11				endm  
# End of macro CALLMONITOR
2f11				endif 
2f11 c3 0f 1c			jp exec1 
2f14			 
2f14					 
2f14			 
2f14			 
2f14					NEXTW 
2f14 c3 7e 1b			jp macro_next 
2f17				endm 
# End of macro NEXTW
2f17			.I:  
2f17			 
2f17				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f17 5e				db WORD_SYS_CORE+74             
2f18 42 2f			dw .DLOOP            
2f1a 02				db 1 + 1 
2f1b .. 00			db "I",0              
2f1d				endm 
# End of macro CWHEAD
2f1d			; | I ( -- ) Current loop counter | DONE 
2f1d					if DEBUG_FORTH_WORDS_KEY 
2f1d						DMARK "I.." 
2f1d f5				push af  
2f1e 3a 32 2f			ld a, (.dmark)  
2f21 32 77 fb			ld (debug_mark),a  
2f24 3a 33 2f			ld a, (.dmark+1)  
2f27 32 78 fb			ld (debug_mark+1),a  
2f2a 3a 34 2f			ld a, (.dmark+2)  
2f2d 32 79 fb			ld (debug_mark+2),a  
2f30 18 03			jr .pastdmark  
2f32 ..			.dmark: db "I.."  
2f35 f1			.pastdmark: pop af  
2f36			endm  
# End of macro DMARK
2f36						CALLMONITOR 
2f36 cd 00 14			call break_point_state  
2f39				endm  
# End of macro CALLMONITOR
2f39					endif 
2f39			 
2f39 2a 57 f1				ld hl,(os_current_i) 
2f3c cd 8d 19				call forth_push_numhl 
2f3f			 
2f3f					NEXTW 
2f3f c3 7e 1b			jp macro_next 
2f42				endm 
# End of macro NEXTW
2f42			.DLOOP: 
2f42				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f42 5f				db WORD_SYS_CORE+75             
2f43 23 30			dw .REPEAT            
2f45 06				db 5 + 1 
2f46 .. 00			db "-LOOP",0              
2f4c				endm 
# End of macro CWHEAD
2f4c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f4c				; pop tos as current loop count to hl 
2f4c					if DEBUG_FORTH_WORDS_KEY 
2f4c						DMARK "-LP" 
2f4c f5				push af  
2f4d 3a 61 2f			ld a, (.dmark)  
2f50 32 77 fb			ld (debug_mark),a  
2f53 3a 62 2f			ld a, (.dmark+1)  
2f56 32 78 fb			ld (debug_mark+1),a  
2f59 3a 63 2f			ld a, (.dmark+2)  
2f5c 32 79 fb			ld (debug_mark+2),a  
2f5f 18 03			jr .pastdmark  
2f61 ..			.dmark: db "-LP"  
2f64 f1			.pastdmark: pop af  
2f65			endm  
# End of macro DMARK
2f65						CALLMONITOR 
2f65 cd 00 14			call break_point_state  
2f68				endm  
# End of macro CALLMONITOR
2f68					endif 
2f68			 
2f68				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f68			 
2f68				FORTH_LOOP_TOS 
2f68 cd 70 1a			call macro_forth_loop_tos 
2f6b				endm 
# End of macro FORTH_LOOP_TOS
2f6b e5				push hl 
2f6c			 
2f6c					if DEBUG_FORTH_WORDS 
2f6c						DMARK "-LP" 
2f6c f5				push af  
2f6d 3a 81 2f			ld a, (.dmark)  
2f70 32 77 fb			ld (debug_mark),a  
2f73 3a 82 2f			ld a, (.dmark+1)  
2f76 32 78 fb			ld (debug_mark+1),a  
2f79 3a 83 2f			ld a, (.dmark+2)  
2f7c 32 79 fb			ld (debug_mark+2),a  
2f7f 18 03			jr .pastdmark  
2f81 ..			.dmark: db "-LP"  
2f84 f1			.pastdmark: pop af  
2f85			endm  
# End of macro DMARK
2f85						CALLMONITOR 
2f85 cd 00 14			call break_point_state  
2f88				endm  
# End of macro CALLMONITOR
2f88					endif 
2f88				; next item on the stack is the limit. get it 
2f88			 
2f88			 
2f88				FORTH_LOOP_POP 
2f88 cd 7a 1a			call macro_forth_loop_pop 
2f8b				endm 
# End of macro FORTH_LOOP_POP
2f8b			 
2f8b				FORTH_LOOP_TOS 
2f8b cd 70 1a			call macro_forth_loop_tos 
2f8e				endm 
# End of macro FORTH_LOOP_TOS
2f8e			 
2f8e d1				pop de		 ; de = i, hl = limit 
2f8f			 
2f8f					if DEBUG_FORTH_WORDS 
2f8f						DMARK "-L1" 
2f8f f5				push af  
2f90 3a a4 2f			ld a, (.dmark)  
2f93 32 77 fb			ld (debug_mark),a  
2f96 3a a5 2f			ld a, (.dmark+1)  
2f99 32 78 fb			ld (debug_mark+1),a  
2f9c 3a a6 2f			ld a, (.dmark+2)  
2f9f 32 79 fb			ld (debug_mark+2),a  
2fa2 18 03			jr .pastdmark  
2fa4 ..			.dmark: db "-L1"  
2fa7 f1			.pastdmark: pop af  
2fa8			endm  
# End of macro DMARK
2fa8						CALLMONITOR 
2fa8 cd 00 14			call break_point_state  
2fab				endm  
# End of macro CALLMONITOR
2fab					endif 
2fab			 
2fab				; go back to previous word 
2fab			 
2fab d5				push de    ; save I for inc later 
2fac			 
2fac			 
2fac				; get limit 
2fac				;  is I at limit? 
2fac			 
2fac			 
2fac					if DEBUG_FORTH_WORDS 
2fac						DMARK "-L1" 
2fac f5				push af  
2fad 3a c1 2f			ld a, (.dmark)  
2fb0 32 77 fb			ld (debug_mark),a  
2fb3 3a c2 2f			ld a, (.dmark+1)  
2fb6 32 78 fb			ld (debug_mark+1),a  
2fb9 3a c3 2f			ld a, (.dmark+2)  
2fbc 32 79 fb			ld (debug_mark+2),a  
2fbf 18 03			jr .pastdmark  
2fc1 ..			.dmark: db "-L1"  
2fc4 f1			.pastdmark: pop af  
2fc5			endm  
# End of macro DMARK
2fc5						CALLMONITOR 
2fc5 cd 00 14			call break_point_state  
2fc8				endm  
# End of macro CALLMONITOR
2fc8					endif 
2fc8			 
2fc8 ed 52			sbc hl, de 
2fca			 
2fca			 
2fca				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2fca			 
2fca 20 26				jr nz, .mloopnotdone 
2fcc			 
2fcc e1				pop hl   ; get rid of saved I 
2fcd				FORTH_LOOP_POP     ; get rid of limit 
2fcd cd 7a 1a			call macro_forth_loop_pop 
2fd0				endm 
# End of macro FORTH_LOOP_POP
2fd0			 
2fd0				FORTH_RSP_POP     ; get rid of DO ptr 
2fd0 cd 55 19			call macro_forth_rsp_pop 
2fd3				endm 
# End of macro FORTH_RSP_POP
2fd3			 
2fd3			if DEBUG_FORTH_WORDS 
2fd3						DMARK "-L>" 
2fd3 f5				push af  
2fd4 3a e8 2f			ld a, (.dmark)  
2fd7 32 77 fb			ld (debug_mark),a  
2fda 3a e9 2f			ld a, (.dmark+1)  
2fdd 32 78 fb			ld (debug_mark+1),a  
2fe0 3a ea 2f			ld a, (.dmark+2)  
2fe3 32 79 fb			ld (debug_mark+2),a  
2fe6 18 03			jr .pastdmark  
2fe8 ..			.dmark: db "-L>"  
2feb f1			.pastdmark: pop af  
2fec			endm  
# End of macro DMARK
2fec				CALLMONITOR 
2fec cd 00 14			call break_point_state  
2fef				endm  
# End of macro CALLMONITOR
2fef			endif 
2fef			 
2fef					NEXTW 
2fef c3 7e 1b			jp macro_next 
2ff2				endm 
# End of macro NEXTW
2ff2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2ff2			 
2ff2			.mloopnotdone: 
2ff2			 
2ff2 e1				pop hl    ; get I 
2ff3 2b				dec hl 
2ff4			 
2ff4			   	; save new I 
2ff4			 
2ff4			 
2ff4					; set I counter 
2ff4			 
2ff4 22 57 f1				ld (os_current_i), hl 
2ff7			 
2ff7					 
2ff7				FORTH_LOOP_NEXT 
2ff7 cd 3d 1a			call macro_forth_loop_next 
2ffa				endm 
# End of macro FORTH_LOOP_NEXT
2ffa			 
2ffa			 
2ffa					if DEBUG_FORTH_WORDS 
2ffa eb						ex de,hl 
2ffb					endif 
2ffb			 
2ffb			;	; get DO ptr 
2ffb			; 
2ffb				FORTH_RSP_TOS 
2ffb cd 4b 19			call macro_forth_rsp_tos 
2ffe				endm 
# End of macro FORTH_RSP_TOS
2ffe			 
2ffe				;push hl 
2ffe			 
2ffe				; not going to DO any more 
2ffe				; get rid of the RSP pointer as DO will add it back in 
2ffe				;FORTH_RSP_POP 
2ffe				;pop hl 
2ffe			 
2ffe			 
2ffe 22 33 f1			ld (os_tok_ptr), hl 
3001					if DEBUG_FORTH_WORDS 
3001						DMARK "-L<" 
3001 f5				push af  
3002 3a 16 30			ld a, (.dmark)  
3005 32 77 fb			ld (debug_mark),a  
3008 3a 17 30			ld a, (.dmark+1)  
300b 32 78 fb			ld (debug_mark+1),a  
300e 3a 18 30			ld a, (.dmark+2)  
3011 32 79 fb			ld (debug_mark+2),a  
3014 18 03			jr .pastdmark  
3016 ..			.dmark: db "-L<"  
3019 f1			.pastdmark: pop af  
301a			endm  
# End of macro DMARK
301a					CALLMONITOR 
301a cd 00 14			call break_point_state  
301d				endm  
# End of macro CALLMONITOR
301d				endif 
301d c3 0f 1c			jp exec1 
3020			 
3020					 
3020			 
3020			 
3020			 
3020				NEXTW 
3020 c3 7e 1b			jp macro_next 
3023				endm 
# End of macro NEXTW
3023			 
3023			 
3023			 
3023			 
3023			.REPEAT: 
3023				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3023 71				db WORD_SYS_CORE+93             
3024 76 30			dw .UNTIL            
3026 06				db 5 + 1 
3027 .. 00			db "REPEAT",0              
302e				endm 
# End of macro CWHEAD
302e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
302e			;  push pc to rsp stack past the REPEAT 
302e					if DEBUG_FORTH_WORDS_KEY 
302e						DMARK "REP" 
302e f5				push af  
302f 3a 43 30			ld a, (.dmark)  
3032 32 77 fb			ld (debug_mark),a  
3035 3a 44 30			ld a, (.dmark+1)  
3038 32 78 fb			ld (debug_mark+1),a  
303b 3a 45 30			ld a, (.dmark+2)  
303e 32 79 fb			ld (debug_mark+2),a  
3041 18 03			jr .pastdmark  
3043 ..			.dmark: db "REP"  
3046 f1			.pastdmark: pop af  
3047			endm  
# End of macro DMARK
3047						CALLMONITOR 
3047 cd 00 14			call break_point_state  
304a				endm  
# End of macro CALLMONITOR
304a					endif 
304a			 
304a 2a 33 f1				ld hl, (os_tok_ptr) 
304d 23					inc hl   ; R 
304e 23					inc hl  ; E 
304f 23					inc hl   ; P 
3050 23					inc hl   ; E 
3051 23					inc hl   ; A 
3052 23					inc hl   ; T 
3053 23					inc hl   ; zero 
3054					FORTH_RSP_NEXT 
3054 cd 34 19			call macro_forth_rsp_next 
3057				endm 
# End of macro FORTH_RSP_NEXT
3057			 
3057			 
3057					if DEBUG_FORTH_WORDS 
3057						DMARK "REP" 
3057 f5				push af  
3058 3a 6c 30			ld a, (.dmark)  
305b 32 77 fb			ld (debug_mark),a  
305e 3a 6d 30			ld a, (.dmark+1)  
3061 32 78 fb			ld (debug_mark+1),a  
3064 3a 6e 30			ld a, (.dmark+2)  
3067 32 79 fb			ld (debug_mark+2),a  
306a 18 03			jr .pastdmark  
306c ..			.dmark: db "REP"  
306f f1			.pastdmark: pop af  
3070			endm  
# End of macro DMARK
3070						;pop bc    ; TODO BUG ?????? what is this for???? 
3070						CALLMONITOR 
3070 cd 00 14			call break_point_state  
3073				endm  
# End of macro CALLMONITOR
3073					endif 
3073			 
3073					NEXTW 
3073 c3 7e 1b			jp macro_next 
3076				endm 
# End of macro NEXTW
3076			;	       NEXTW 
3076			 
3076			.UNTIL: 
3076				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3076 72				db WORD_SYS_CORE+94             
3077 0d 31			dw .ENDFLOW            
3079 06				db 5 + 1 
307a .. 00			db "UNTIL",0              
3080				endm 
# End of macro CWHEAD
3080			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3080			 
3080				; pop tos as check 
3080			 
3080				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3080			 
3080				FORTH_DSP_VALUEHL 
3080 cd 28 1a			call macro_dsp_valuehl 
3083				endm 
# End of macro FORTH_DSP_VALUEHL
3083			 
3083					if DEBUG_FORTH_WORDS_KEY 
3083						DMARK "UNT" 
3083 f5				push af  
3084 3a 98 30			ld a, (.dmark)  
3087 32 77 fb			ld (debug_mark),a  
308a 3a 99 30			ld a, (.dmark+1)  
308d 32 78 fb			ld (debug_mark+1),a  
3090 3a 9a 30			ld a, (.dmark+2)  
3093 32 79 fb			ld (debug_mark+2),a  
3096 18 03			jr .pastdmark  
3098 ..			.dmark: db "UNT"  
309b f1			.pastdmark: pop af  
309c			endm  
# End of macro DMARK
309c						CALLMONITOR 
309c cd 00 14			call break_point_state  
309f				endm  
# End of macro CALLMONITOR
309f					endif 
309f			 
309f			;	push hl 
309f				FORTH_DSP_POP 
309f cd c4 1a			call macro_forth_dsp_pop 
30a2				endm 
# End of macro FORTH_DSP_POP
30a2			 
30a2			;	pop hl 
30a2			 
30a2				; test if true 
30a2			 
30a2 cd 3b 0c			call ishlzero 
30a5			;	ld a,l 
30a5			;	add h 
30a5			; 
30a5			;	cp 0 
30a5			 
30a5 20 3e			jr nz, .untilnotdone 
30a7			 
30a7					if DEBUG_FORTH_WORDS 
30a7						DMARK "UNf" 
30a7 f5				push af  
30a8 3a bc 30			ld a, (.dmark)  
30ab 32 77 fb			ld (debug_mark),a  
30ae 3a bd 30			ld a, (.dmark+1)  
30b1 32 78 fb			ld (debug_mark+1),a  
30b4 3a be 30			ld a, (.dmark+2)  
30b7 32 79 fb			ld (debug_mark+2),a  
30ba 18 03			jr .pastdmark  
30bc ..			.dmark: db "UNf"  
30bf f1			.pastdmark: pop af  
30c0			endm  
# End of macro DMARK
30c0						CALLMONITOR 
30c0 cd 00 14			call break_point_state  
30c3				endm  
# End of macro CALLMONITOR
30c3					endif 
30c3			 
30c3			 
30c3			 
30c3				FORTH_RSP_POP     ; get rid of DO ptr 
30c3 cd 55 19			call macro_forth_rsp_pop 
30c6				endm 
# End of macro FORTH_RSP_POP
30c6			 
30c6			if DEBUG_FORTH_WORDS 
30c6						DMARK "UN>" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 77 fb			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 78 fb			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 79 fb			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "UN>"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df				CALLMONITOR 
30df cd 00 14			call break_point_state  
30e2				endm  
# End of macro CALLMONITOR
30e2			endif 
30e2			 
30e2					NEXTW 
30e2 c3 7e 1b			jp macro_next 
30e5				endm 
# End of macro NEXTW
30e5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30e5			 
30e5			.untilnotdone: 
30e5			 
30e5			 
30e5			;	; get DO ptr 
30e5			; 
30e5				FORTH_RSP_TOS 
30e5 cd 4b 19			call macro_forth_rsp_tos 
30e8				endm 
# End of macro FORTH_RSP_TOS
30e8			 
30e8				;push hl 
30e8			 
30e8				; not going to DO any more 
30e8				; get rid of the RSP pointer as DO will add it back in 
30e8				;FORTH_RSP_POP 
30e8				;pop hl 
30e8			 
30e8			 
30e8 22 33 f1			ld (os_tok_ptr), hl 
30eb					if DEBUG_FORTH_WORDS 
30eb						DMARK "UN<" 
30eb f5				push af  
30ec 3a 00 31			ld a, (.dmark)  
30ef 32 77 fb			ld (debug_mark),a  
30f2 3a 01 31			ld a, (.dmark+1)  
30f5 32 78 fb			ld (debug_mark+1),a  
30f8 3a 02 31			ld a, (.dmark+2)  
30fb 32 79 fb			ld (debug_mark+2),a  
30fe 18 03			jr .pastdmark  
3100 ..			.dmark: db "UN<"  
3103 f1			.pastdmark: pop af  
3104			endm  
# End of macro DMARK
3104					CALLMONITOR 
3104 cd 00 14			call break_point_state  
3107				endm  
# End of macro CALLMONITOR
3107				endif 
3107 c3 0f 1c			jp exec1 
310a			 
310a					 
310a			 
310a			 
310a					NEXTW 
310a c3 7e 1b			jp macro_next 
310d				endm 
# End of macro NEXTW
310d			 
310d			 
310d			.ENDFLOW: 
310d			 
310d			; eof 
310d			 
# End of file forth_words_flow.asm
310d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
310d			include "forth_words_logic.asm" 
310d			 
310d			; | ## Logic Words 
310d			 
310d			.NOT: 
310d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
310d 2d				db WORD_SYS_CORE+25             
310e 55 31			dw .IS            
3110 04				db 3 + 1 
3111 .. 00			db "NOT",0              
3115				endm 
# End of macro CWHEAD
3115			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3115					if DEBUG_FORTH_WORDS_KEY 
3115						DMARK "NOT" 
3115 f5				push af  
3116 3a 2a 31			ld a, (.dmark)  
3119 32 77 fb			ld (debug_mark),a  
311c 3a 2b 31			ld a, (.dmark+1)  
311f 32 78 fb			ld (debug_mark+1),a  
3122 3a 2c 31			ld a, (.dmark+2)  
3125 32 79 fb			ld (debug_mark+2),a  
3128 18 03			jr .pastdmark  
312a ..			.dmark: db "NOT"  
312d f1			.pastdmark: pop af  
312e			endm  
# End of macro DMARK
312e						CALLMONITOR 
312e cd 00 14			call break_point_state  
3131				endm  
# End of macro CALLMONITOR
3131					endif 
3131					FORTH_DSP 
3131 cd 0d 1a			call macro_forth_dsp 
3134				endm 
# End of macro FORTH_DSP
3134 7e					ld a,(hl)	; get type of value on TOS 
3135 fe 02				cp DS_TYPE_INUM  
3137 28 03				jr z, .noti 
3139					NEXTW 
3139 c3 7e 1b			jp macro_next 
313c				endm 
# End of macro NEXTW
313c			.noti:          FORTH_DSP_VALUEHL 
313c cd 28 1a			call macro_dsp_valuehl 
313f				endm 
# End of macro FORTH_DSP_VALUEHL
313f			;		push hl 
313f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
313f cd c4 1a			call macro_forth_dsp_pop 
3142				endm 
# End of macro FORTH_DSP_POP
3142			;		pop hl 
3142 3e 00				ld a,0 
3144 bd					cp l 
3145 28 04				jr z, .not2t 
3147 2e 00				ld l, 0 
3149 18 02				jr .notip 
314b			 
314b 2e ff		.not2t:		ld l, 255 
314d			 
314d 26 00		.notip:		ld h, 0	 
314f			 
314f cd 8d 19				call forth_push_numhl 
3152					NEXTW 
3152 c3 7e 1b			jp macro_next 
3155				endm 
# End of macro NEXTW
3155			 
3155			.IS: 
3155				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3155 2d				db WORD_SYS_CORE+25             
3156 7b 31			dw .LZERO            
3158 03				db 2 + 1 
3159 .. 00			db "IS",0              
315c				endm 
# End of macro CWHEAD
315c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
315c					if DEBUG_FORTH_WORDS_KEY 
315c						DMARK "IS." 
315c f5				push af  
315d 3a 71 31			ld a, (.dmark)  
3160 32 77 fb			ld (debug_mark),a  
3163 3a 72 31			ld a, (.dmark+1)  
3166 32 78 fb			ld (debug_mark+1),a  
3169 3a 73 31			ld a, (.dmark+2)  
316c 32 79 fb			ld (debug_mark+2),a  
316f 18 03			jr .pastdmark  
3171 ..			.dmark: db "IS."  
3174 f1			.pastdmark: pop af  
3175			endm  
# End of macro DMARK
3175						CALLMONITOR 
3175 cd 00 14			call break_point_state  
3178				endm  
# End of macro CALLMONITOR
3178					endif 
3178					NEXTW 
3178 c3 7e 1b			jp macro_next 
317b				endm 
# End of macro NEXTW
317b			.LZERO: 
317b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
317b 2d				db WORD_SYS_CORE+25             
317c 85 31			dw .TZERO            
317e 03				db 2 + 1 
317f .. 00			db "0<",0              
3182				endm 
# End of macro CWHEAD
3182			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3182					NEXTW 
3182 c3 7e 1b			jp macro_next 
3185				endm 
# End of macro NEXTW
3185			.TZERO: 
3185				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3185 2e				db WORD_SYS_CORE+26             
3186 cc 31			dw .LESS            
3188 03				db 2 + 1 
3189 .. 00			db "0=",0              
318c				endm 
# End of macro CWHEAD
318c			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
318c				; TODO add floating point number detection 
318c					;v5 FORTH_DSP_VALUE 
318c					if DEBUG_FORTH_WORDS_KEY 
318c						DMARK "0=." 
318c f5				push af  
318d 3a a1 31			ld a, (.dmark)  
3190 32 77 fb			ld (debug_mark),a  
3193 3a a2 31			ld a, (.dmark+1)  
3196 32 78 fb			ld (debug_mark+1),a  
3199 3a a3 31			ld a, (.dmark+2)  
319c 32 79 fb			ld (debug_mark+2),a  
319f 18 03			jr .pastdmark  
31a1 ..			.dmark: db "0=."  
31a4 f1			.pastdmark: pop af  
31a5			endm  
# End of macro DMARK
31a5						CALLMONITOR 
31a5 cd 00 14			call break_point_state  
31a8				endm  
# End of macro CALLMONITOR
31a8					endif 
31a8					FORTH_DSP 
31a8 cd 0d 1a			call macro_forth_dsp 
31ab				endm 
# End of macro FORTH_DSP
31ab 7e					ld a,(hl)	; get type of value on TOS 
31ac fe 02				cp DS_TYPE_INUM  
31ae 28 00				jr z, .tz_inum 
31b0			 
31b0				if FORTH_ENABLE_FLOATMATH 
31b0					jr .tz_done 
31b0			 
31b0				endif 
31b0					 
31b0			 
31b0			.tz_inum: 
31b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31b0 cd 28 1a			call macro_dsp_valuehl 
31b3				endm 
# End of macro FORTH_DSP_VALUEHL
31b3			 
31b3			;		push hl 
31b3			 
31b3					; destroy value TOS 
31b3			 
31b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31b3 cd c4 1a			call macro_forth_dsp_pop 
31b6				endm 
# End of macro FORTH_DSP_POP
31b6			 
31b6			;		pop hl 
31b6			 
31b6 3e 00				ld a,0 
31b8			 
31b8 bd					cp l 
31b9 20 08				jr nz, .tz_notzero 
31bb			 
31bb bc					cp h 
31bc			 
31bc 20 05				jr nz, .tz_notzero 
31be			 
31be			 
31be 21 01 00				ld hl, FORTH_TRUE 
31c1 18 03				jr .tz_done 
31c3			 
31c3 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
31c6			 
31c6					; push value back onto stack for another op etc 
31c6			 
31c6			.tz_done: 
31c6 cd 8d 19				call forth_push_numhl 
31c9			 
31c9					NEXTW 
31c9 c3 7e 1b			jp macro_next 
31cc				endm 
# End of macro NEXTW
31cc			.LESS: 
31cc				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
31cc 2f				db WORD_SYS_CORE+27             
31cd 35 32			dw .GT            
31cf 02				db 1 + 1 
31d0 .. 00			db "<",0              
31d2				endm 
# End of macro CWHEAD
31d2			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
31d2				; TODO add floating point number detection 
31d2					if DEBUG_FORTH_WORDS_KEY 
31d2						DMARK "LES" 
31d2 f5				push af  
31d3 3a e7 31			ld a, (.dmark)  
31d6 32 77 fb			ld (debug_mark),a  
31d9 3a e8 31			ld a, (.dmark+1)  
31dc 32 78 fb			ld (debug_mark+1),a  
31df 3a e9 31			ld a, (.dmark+2)  
31e2 32 79 fb			ld (debug_mark+2),a  
31e5 18 03			jr .pastdmark  
31e7 ..			.dmark: db "LES"  
31ea f1			.pastdmark: pop af  
31eb			endm  
# End of macro DMARK
31eb						CALLMONITOR 
31eb cd 00 14			call break_point_state  
31ee				endm  
# End of macro CALLMONITOR
31ee					endif 
31ee					FORTH_DSP 
31ee cd 0d 1a			call macro_forth_dsp 
31f1				endm 
# End of macro FORTH_DSP
31f1					;v5 FORTH_DSP_VALUE 
31f1 7e					ld a,(hl)	; get type of value on TOS 
31f2 fe 02				cp DS_TYPE_INUM  
31f4 28 00				jr z, .less_inum 
31f6			 
31f6				if FORTH_ENABLE_FLOATMATH 
31f6					jr .less_done 
31f6			 
31f6				endif 
31f6					 
31f6			 
31f6			.less_inum: 
31f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31f6 cd 28 1a			call macro_dsp_valuehl 
31f9				endm 
# End of macro FORTH_DSP_VALUEHL
31f9			 
31f9 e5					push hl  ; u2 
31fa			 
31fa					; destroy value TOS 
31fa			 
31fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31fa cd c4 1a			call macro_forth_dsp_pop 
31fd				endm 
# End of macro FORTH_DSP_POP
31fd			 
31fd			 
31fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31fd cd 28 1a			call macro_dsp_valuehl 
3200				endm 
# End of macro FORTH_DSP_VALUEHL
3200			 
3200 e5					push hl    ; u1 
3201			 
3201					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3201 cd c4 1a			call macro_forth_dsp_pop 
3204				endm 
# End of macro FORTH_DSP_POP
3204			 
3204			 
3204 b7			 or a      ;clear carry flag 
3205 01 00 00		 ld bc, FORTH_FALSE 
3208 e1			  pop hl    ; u1 
3209 d1			  pop de    ; u2 
320a ed 52		  sbc hl,de 
320c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
320e			 
320e 01 01 00		 ld bc, FORTH_TRUE 
3211			.lscont:  
3211 c5					push bc 
3212 e1					pop hl 
3213			 
3213					if DEBUG_FORTH_WORDS 
3213						DMARK "LT1" 
3213 f5				push af  
3214 3a 28 32			ld a, (.dmark)  
3217 32 77 fb			ld (debug_mark),a  
321a 3a 29 32			ld a, (.dmark+1)  
321d 32 78 fb			ld (debug_mark+1),a  
3220 3a 2a 32			ld a, (.dmark+2)  
3223 32 79 fb			ld (debug_mark+2),a  
3226 18 03			jr .pastdmark  
3228 ..			.dmark: db "LT1"  
322b f1			.pastdmark: pop af  
322c			endm  
# End of macro DMARK
322c						CALLMONITOR 
322c cd 00 14			call break_point_state  
322f				endm  
# End of macro CALLMONITOR
322f					endif 
322f cd 8d 19				call forth_push_numhl 
3232			 
3232					NEXTW 
3232 c3 7e 1b			jp macro_next 
3235				endm 
# End of macro NEXTW
3235			.GT: 
3235				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3235 30				db WORD_SYS_CORE+28             
3236 9e 32			dw .EQUAL            
3238 02				db 1 + 1 
3239 .. 00			db ">",0              
323b				endm 
# End of macro CWHEAD
323b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
323b				; TODO add floating point number detection 
323b					if DEBUG_FORTH_WORDS_KEY 
323b						DMARK "GRT" 
323b f5				push af  
323c 3a 50 32			ld a, (.dmark)  
323f 32 77 fb			ld (debug_mark),a  
3242 3a 51 32			ld a, (.dmark+1)  
3245 32 78 fb			ld (debug_mark+1),a  
3248 3a 52 32			ld a, (.dmark+2)  
324b 32 79 fb			ld (debug_mark+2),a  
324e 18 03			jr .pastdmark  
3250 ..			.dmark: db "GRT"  
3253 f1			.pastdmark: pop af  
3254			endm  
# End of macro DMARK
3254						CALLMONITOR 
3254 cd 00 14			call break_point_state  
3257				endm  
# End of macro CALLMONITOR
3257					endif 
3257					FORTH_DSP 
3257 cd 0d 1a			call macro_forth_dsp 
325a				endm 
# End of macro FORTH_DSP
325a					;FORTH_DSP_VALUE 
325a 7e					ld a,(hl)	; get type of value on TOS 
325b fe 02				cp DS_TYPE_INUM  
325d 28 00				jr z, .gt_inum 
325f			 
325f				if FORTH_ENABLE_FLOATMATH 
325f					jr .gt_done 
325f			 
325f				endif 
325f					 
325f			 
325f			.gt_inum: 
325f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
325f cd 28 1a			call macro_dsp_valuehl 
3262				endm 
# End of macro FORTH_DSP_VALUEHL
3262			 
3262 e5					push hl  ; u2 
3263			 
3263					; destroy value TOS 
3263			 
3263					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3263 cd c4 1a			call macro_forth_dsp_pop 
3266				endm 
# End of macro FORTH_DSP_POP
3266			 
3266			 
3266					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3266 cd 28 1a			call macro_dsp_valuehl 
3269				endm 
# End of macro FORTH_DSP_VALUEHL
3269			 
3269 e5					push hl    ; u1 
326a			 
326a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
326a cd c4 1a			call macro_forth_dsp_pop 
326d				endm 
# End of macro FORTH_DSP_POP
326d			 
326d			 
326d b7			 or a      ;clear carry flag 
326e 01 00 00		 ld bc, FORTH_FALSE 
3271 e1			  pop hl    ; u1 
3272 d1			  pop de    ; u2 
3273 ed 52		  sbc hl,de 
3275 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3277			 
3277 01 01 00		 ld bc, FORTH_TRUE 
327a			.gtcont:  
327a c5					push bc 
327b e1					pop hl 
327c			 
327c					if DEBUG_FORTH_WORDS 
327c						DMARK "GT1" 
327c f5				push af  
327d 3a 91 32			ld a, (.dmark)  
3280 32 77 fb			ld (debug_mark),a  
3283 3a 92 32			ld a, (.dmark+1)  
3286 32 78 fb			ld (debug_mark+1),a  
3289 3a 93 32			ld a, (.dmark+2)  
328c 32 79 fb			ld (debug_mark+2),a  
328f 18 03			jr .pastdmark  
3291 ..			.dmark: db "GT1"  
3294 f1			.pastdmark: pop af  
3295			endm  
# End of macro DMARK
3295						CALLMONITOR 
3295 cd 00 14			call break_point_state  
3298				endm  
# End of macro CALLMONITOR
3298					endif 
3298 cd 8d 19				call forth_push_numhl 
329b			 
329b					NEXTW 
329b c3 7e 1b			jp macro_next 
329e				endm 
# End of macro NEXTW
329e			.EQUAL: 
329e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
329e 31				db WORD_SYS_CORE+29             
329f 09 33			dw .ENDLOGIC            
32a1 02				db 1 + 1 
32a2 .. 00			db "=",0              
32a4				endm 
# End of macro CWHEAD
32a4			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
32a4				; TODO add floating point number detection 
32a4					if DEBUG_FORTH_WORDS_KEY 
32a4						DMARK "EQ." 
32a4 f5				push af  
32a5 3a b9 32			ld a, (.dmark)  
32a8 32 77 fb			ld (debug_mark),a  
32ab 3a ba 32			ld a, (.dmark+1)  
32ae 32 78 fb			ld (debug_mark+1),a  
32b1 3a bb 32			ld a, (.dmark+2)  
32b4 32 79 fb			ld (debug_mark+2),a  
32b7 18 03			jr .pastdmark  
32b9 ..			.dmark: db "EQ."  
32bc f1			.pastdmark: pop af  
32bd			endm  
# End of macro DMARK
32bd						CALLMONITOR 
32bd cd 00 14			call break_point_state  
32c0				endm  
# End of macro CALLMONITOR
32c0					endif 
32c0					FORTH_DSP 
32c0 cd 0d 1a			call macro_forth_dsp 
32c3				endm 
# End of macro FORTH_DSP
32c3					;v5 FORTH_DSP_VALUE 
32c3 7e					ld a,(hl)	; get type of value on TOS 
32c4 fe 02				cp DS_TYPE_INUM  
32c6 28 00				jr z, .eq_inum 
32c8			 
32c8				if FORTH_ENABLE_FLOATMATH 
32c8					jr .eq_done 
32c8			 
32c8				endif 
32c8					 
32c8			 
32c8			.eq_inum: 
32c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32c8 cd 28 1a			call macro_dsp_valuehl 
32cb				endm 
# End of macro FORTH_DSP_VALUEHL
32cb			 
32cb e5					push hl 
32cc			 
32cc					; destroy value TOS 
32cc			 
32cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32cc cd c4 1a			call macro_forth_dsp_pop 
32cf				endm 
# End of macro FORTH_DSP_POP
32cf			 
32cf			 
32cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32cf cd 28 1a			call macro_dsp_valuehl 
32d2				endm 
# End of macro FORTH_DSP_VALUEHL
32d2			 
32d2					; one value on hl get other one back 
32d2			 
32d2 e5					push hl 
32d3			 
32d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d3 cd c4 1a			call macro_forth_dsp_pop 
32d6				endm 
# End of macro FORTH_DSP_POP
32d6			 
32d6 0e 00				ld c, FORTH_FALSE 
32d8			 
32d8 e1					pop hl 
32d9 d1					pop de 
32da			 
32da 7b					ld a, e 
32db bd					cp l 
32dc			 
32dc 20 06				jr nz, .eq_done 
32de			 
32de 7a					ld a, d 
32df bc					cp h 
32e0			 
32e0 20 02				jr nz, .eq_done 
32e2			 
32e2 0e 01				ld c, FORTH_TRUE 
32e4					 
32e4			 
32e4			 
32e4			.eq_done: 
32e4			 
32e4					; TODO push value back onto stack for another op etc 
32e4			 
32e4 26 00				ld h, 0 
32e6 69					ld l, c 
32e7					if DEBUG_FORTH_WORDS 
32e7						DMARK "EQ1" 
32e7 f5				push af  
32e8 3a fc 32			ld a, (.dmark)  
32eb 32 77 fb			ld (debug_mark),a  
32ee 3a fd 32			ld a, (.dmark+1)  
32f1 32 78 fb			ld (debug_mark+1),a  
32f4 3a fe 32			ld a, (.dmark+2)  
32f7 32 79 fb			ld (debug_mark+2),a  
32fa 18 03			jr .pastdmark  
32fc ..			.dmark: db "EQ1"  
32ff f1			.pastdmark: pop af  
3300			endm  
# End of macro DMARK
3300						CALLMONITOR 
3300 cd 00 14			call break_point_state  
3303				endm  
# End of macro CALLMONITOR
3303					endif 
3303 cd 8d 19				call forth_push_numhl 
3306			 
3306					NEXTW 
3306 c3 7e 1b			jp macro_next 
3309				endm 
# End of macro NEXTW
3309			 
3309			 
3309			.ENDLOGIC: 
3309			; eof 
3309			 
3309			 
# End of file forth_words_logic.asm
3309			include "forth_words_maths.asm" 
3309			 
3309			; | ## Maths Words 
3309			 
3309			.PLUS:	 
3309				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3309 15				db WORD_SYS_CORE+1             
330a 4b 33			dw .NEG            
330c 02				db 1 + 1 
330d .. 00			db "+",0              
330f				endm 
# End of macro CWHEAD
330f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
330f					if DEBUG_FORTH_WORDS_KEY 
330f						DMARK "PLU" 
330f f5				push af  
3310 3a 24 33			ld a, (.dmark)  
3313 32 77 fb			ld (debug_mark),a  
3316 3a 25 33			ld a, (.dmark+1)  
3319 32 78 fb			ld (debug_mark+1),a  
331c 3a 26 33			ld a, (.dmark+2)  
331f 32 79 fb			ld (debug_mark+2),a  
3322 18 03			jr .pastdmark  
3324 ..			.dmark: db "PLU"  
3327 f1			.pastdmark: pop af  
3328			endm  
# End of macro DMARK
3328						CALLMONITOR 
3328 cd 00 14			call break_point_state  
332b				endm  
# End of macro CALLMONITOR
332b					endif 
332b					; add top two values and push back result 
332b			 
332b					;for v5 FORTH_DSP_VALUE 
332b					FORTH_DSP 
332b cd 0d 1a			call macro_forth_dsp 
332e				endm 
# End of macro FORTH_DSP
332e 7e					ld a,(hl)	; get type of value on TOS 
332f fe 02				cp DS_TYPE_INUM  
3331 28 03				jr z, .dot_inum 
3333			 
3333					NEXTW 
3333 c3 7e 1b			jp macro_next 
3336				endm 
# End of macro NEXTW
3336			 
3336			; float maths 
3336			 
3336				if FORTH_ENABLE_FLOATMATH 
3336						inc hl      ; now at start of numeric as string 
3336			 
3336					if DEBUG_FORTH_MATHS 
3336						DMARK "ADD" 
3336				CALLMONITOR 
3336					endif 
3336			 
3336					;ld ix, hl 
3336					call CON 
3336			 
3336			 
3336					push hl 
3336					 
3336					 
3336			 
3336						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3336			 
3336					; get next number 
3336			 
3336						FORTH_DSP_VALUE 
3336			 
3336						inc hl      ; now at start of numeric as string 
3336			 
3336					;ld ix, hl 
3336					call CON 
3336			 
3336					push hl 
3336			 
3336			 
3336						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3336			 
3336						; TODO do add 
3336			 
3336						call IADD 
3336			 
3336						; TODO get result back as ascii 
3336			 
3336						; TODO push result  
3336			 
3336			 
3336			 
3336						jr .dot_done 
3336				endif 
3336			 
3336			.dot_inum: 
3336			 
3336			 
3336					if DEBUG_FORTH_DOT 
3336						DMARK "+IT" 
3336				CALLMONITOR 
3336					endif 
3336			 
3336					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3336 cd 28 1a			call macro_dsp_valuehl 
3339				endm 
# End of macro FORTH_DSP_VALUEHL
3339			 
3339				; TODO add floating point number detection 
3339			 
3339 e5					push hl 
333a			 
333a					; destroy value TOS 
333a			 
333a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
333a cd c4 1a			call macro_forth_dsp_pop 
333d				endm 
# End of macro FORTH_DSP_POP
333d			 
333d			 
333d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
333d cd 28 1a			call macro_dsp_valuehl 
3340				endm 
# End of macro FORTH_DSP_VALUEHL
3340			 
3340					; one value on hl get other one back 
3340			 
3340 d1					pop de 
3341			 
3341					; do the add 
3341			 
3341 19					add hl,de 
3342			 
3342					; save it 
3342			 
3342			;		push hl	 
3342			 
3342					; 
3342			 
3342					; destroy value TOS 
3342			 
3342					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3342 cd c4 1a			call macro_forth_dsp_pop 
3345				endm 
# End of macro FORTH_DSP_POP
3345			 
3345					; TODO push value back onto stack for another op etc 
3345			 
3345			;		pop hl 
3345			 
3345			.dot_done: 
3345 cd 8d 19				call forth_push_numhl 
3348			 
3348					NEXTW 
3348 c3 7e 1b			jp macro_next 
334b				endm 
# End of macro NEXTW
334b			.NEG: 
334b			 
334b				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
334b 17				db WORD_SYS_CORE+3             
334c 8e 33			dw .DIV            
334e 02				db 1 + 1 
334f .. 00			db "-",0              
3351				endm 
# End of macro CWHEAD
3351			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3351					if DEBUG_FORTH_WORDS_KEY 
3351						DMARK "SUB" 
3351 f5				push af  
3352 3a 66 33			ld a, (.dmark)  
3355 32 77 fb			ld (debug_mark),a  
3358 3a 67 33			ld a, (.dmark+1)  
335b 32 78 fb			ld (debug_mark+1),a  
335e 3a 68 33			ld a, (.dmark+2)  
3361 32 79 fb			ld (debug_mark+2),a  
3364 18 03			jr .pastdmark  
3366 ..			.dmark: db "SUB"  
3369 f1			.pastdmark: pop af  
336a			endm  
# End of macro DMARK
336a						CALLMONITOR 
336a cd 00 14			call break_point_state  
336d				endm  
# End of macro CALLMONITOR
336d					endif 
336d			 
336d			 
336d				; TODO add floating point number detection 
336d					; v5 FORTH_DSP_VALUE 
336d					FORTH_DSP 
336d cd 0d 1a			call macro_forth_dsp 
3370				endm 
# End of macro FORTH_DSP
3370 7e					ld a,(hl)	; get type of value on TOS 
3371 fe 02				cp DS_TYPE_INUM  
3373 28 03				jr z, .neg_inum 
3375			 
3375					NEXTW 
3375 c3 7e 1b			jp macro_next 
3378				endm 
# End of macro NEXTW
3378			 
3378			; float maths 
3378			 
3378				if FORTH_ENABLE_FLOATMATH 
3378					jr .neg_done 
3378			 
3378				endif 
3378					 
3378			 
3378			.neg_inum: 
3378					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3378 cd 28 1a			call macro_dsp_valuehl 
337b				endm 
# End of macro FORTH_DSP_VALUEHL
337b			 
337b e5					push hl 
337c			 
337c					; destroy value TOS 
337c			 
337c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
337c cd c4 1a			call macro_forth_dsp_pop 
337f				endm 
# End of macro FORTH_DSP_POP
337f			 
337f			 
337f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
337f cd 28 1a			call macro_dsp_valuehl 
3382				endm 
# End of macro FORTH_DSP_VALUEHL
3382			 
3382					; one value on hl get other one back 
3382			 
3382 d1					pop de 
3383			 
3383					; do the sub 
3383			;		ex de, hl 
3383			 
3383 ed 52				sbc hl,de 
3385			 
3385					; save it 
3385			 
3385			;		push hl	 
3385			 
3385					; 
3385			 
3385					; destroy value TOS 
3385			 
3385					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3385 cd c4 1a			call macro_forth_dsp_pop 
3388				endm 
# End of macro FORTH_DSP_POP
3388			 
3388					; TODO push value back onto stack for another op etc 
3388			 
3388			;		pop hl 
3388			 
3388 cd 8d 19				call forth_push_numhl 
338b			.neg_done: 
338b			 
338b					NEXTW 
338b c3 7e 1b			jp macro_next 
338e				endm 
# End of macro NEXTW
338e			.DIV: 
338e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
338e 18				db WORD_SYS_CORE+4             
338f db 33			dw .MUL            
3391 02				db 1 + 1 
3392 .. 00			db "/",0              
3394				endm 
# End of macro CWHEAD
3394			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3394					if DEBUG_FORTH_WORDS_KEY 
3394						DMARK "DIV" 
3394 f5				push af  
3395 3a a9 33			ld a, (.dmark)  
3398 32 77 fb			ld (debug_mark),a  
339b 3a aa 33			ld a, (.dmark+1)  
339e 32 78 fb			ld (debug_mark+1),a  
33a1 3a ab 33			ld a, (.dmark+2)  
33a4 32 79 fb			ld (debug_mark+2),a  
33a7 18 03			jr .pastdmark  
33a9 ..			.dmark: db "DIV"  
33ac f1			.pastdmark: pop af  
33ad			endm  
# End of macro DMARK
33ad						CALLMONITOR 
33ad cd 00 14			call break_point_state  
33b0				endm  
# End of macro CALLMONITOR
33b0					endif 
33b0				; TODO add floating point number detection 
33b0					; v5 FORTH_DSP_VALUE 
33b0					FORTH_DSP 
33b0 cd 0d 1a			call macro_forth_dsp 
33b3				endm 
# End of macro FORTH_DSP
33b3 7e					ld a,(hl)	; get type of value on TOS 
33b4 fe 02				cp DS_TYPE_INUM  
33b6 28 03				jr z, .div_inum 
33b8			 
33b8				if FORTH_ENABLE_FLOATMATH 
33b8					jr .div_done 
33b8			 
33b8				endif 
33b8					NEXTW 
33b8 c3 7e 1b			jp macro_next 
33bb				endm 
# End of macro NEXTW
33bb			.div_inum: 
33bb			 
33bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33bb cd 28 1a			call macro_dsp_valuehl 
33be				endm 
# End of macro FORTH_DSP_VALUEHL
33be			 
33be e5					push hl    ; to go to bc 
33bf			 
33bf					; destroy value TOS 
33bf			 
33bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33bf cd c4 1a			call macro_forth_dsp_pop 
33c2				endm 
# End of macro FORTH_DSP_POP
33c2			 
33c2			 
33c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c2 cd 28 1a			call macro_dsp_valuehl 
33c5				endm 
# End of macro FORTH_DSP_VALUEHL
33c5			 
33c5					; hl to go to de 
33c5			 
33c5 e5					push hl 
33c6			 
33c6 c1					pop bc 
33c7 d1					pop de		 
33c8			 
33c8			 
33c8					if DEBUG_FORTH_MATHS 
33c8						DMARK "DIV" 
33c8				CALLMONITOR 
33c8					endif 
33c8					; one value on hl but move to a get other one back 
33c8			 
33c8			        
33c8 cd 6f 0b			call Div16 
33cb			 
33cb			;	push af	 
33cb e5				push hl 
33cc c5				push bc 
33cd			 
33cd					if DEBUG_FORTH_MATHS 
33cd						DMARK "DI1" 
33cd				CALLMONITOR 
33cd					endif 
33cd			 
33cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33cd cd c4 1a			call macro_forth_dsp_pop 
33d0				endm 
# End of macro FORTH_DSP_POP
33d0			 
33d0			 
33d0			 
33d0 e1					pop hl    ; result 
33d1			 
33d1 cd 8d 19				call forth_push_numhl 
33d4			 
33d4 e1					pop hl    ; reminder 
33d5			;		ld h,0 
33d5			;		ld l,d 
33d5			 
33d5 cd 8d 19				call forth_push_numhl 
33d8			.div_done: 
33d8					NEXTW 
33d8 c3 7e 1b			jp macro_next 
33db				endm 
# End of macro NEXTW
33db			.MUL: 
33db				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
33db 19				db WORD_SYS_CORE+5             
33dc 20 34			dw .MIN            
33de 02				db 1 + 1 
33df .. 00			db "*",0              
33e1				endm 
# End of macro CWHEAD
33e1			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
33e1				; TODO add floating point number detection 
33e1					if DEBUG_FORTH_WORDS_KEY 
33e1						DMARK "MUL" 
33e1 f5				push af  
33e2 3a f6 33			ld a, (.dmark)  
33e5 32 77 fb			ld (debug_mark),a  
33e8 3a f7 33			ld a, (.dmark+1)  
33eb 32 78 fb			ld (debug_mark+1),a  
33ee 3a f8 33			ld a, (.dmark+2)  
33f1 32 79 fb			ld (debug_mark+2),a  
33f4 18 03			jr .pastdmark  
33f6 ..			.dmark: db "MUL"  
33f9 f1			.pastdmark: pop af  
33fa			endm  
# End of macro DMARK
33fa						CALLMONITOR 
33fa cd 00 14			call break_point_state  
33fd				endm  
# End of macro CALLMONITOR
33fd					endif 
33fd					FORTH_DSP 
33fd cd 0d 1a			call macro_forth_dsp 
3400				endm 
# End of macro FORTH_DSP
3400					; v5 FORTH_DSP_VALUE 
3400 7e					ld a,(hl)	; get type of value on TOS 
3401 fe 02				cp DS_TYPE_INUM  
3403 28 03				jr z, .mul_inum 
3405			 
3405				if FORTH_ENABLE_FLOATMATH 
3405					jr .mul_done 
3405			 
3405				endif 
3405			 
3405					NEXTW 
3405 c3 7e 1b			jp macro_next 
3408				endm 
# End of macro NEXTW
3408			.mul_inum:	 
3408			 
3408					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3408 cd 28 1a			call macro_dsp_valuehl 
340b				endm 
# End of macro FORTH_DSP_VALUEHL
340b			 
340b e5					push hl 
340c			 
340c					; destroy value TOS 
340c			 
340c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
340c cd c4 1a			call macro_forth_dsp_pop 
340f				endm 
# End of macro FORTH_DSP_POP
340f			 
340f			 
340f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
340f cd 28 1a			call macro_dsp_valuehl 
3412				endm 
# End of macro FORTH_DSP_VALUEHL
3412			 
3412					; one value on hl but move to a get other one back 
3412			 
3412 7d					ld a, l 
3413			 
3413 d1					pop de 
3414			 
3414					; do the mull 
3414			;		ex de, hl 
3414			 
3414 cd 95 0b				call Mult16 
3417					; save it 
3417			 
3417			;		push hl	 
3417			 
3417					; 
3417			 
3417					; destroy value TOS 
3417			 
3417					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3417 cd c4 1a			call macro_forth_dsp_pop 
341a				endm 
# End of macro FORTH_DSP_POP
341a			 
341a					; TODO push value back onto stack for another op etc 
341a			 
341a			;		pop hl 
341a			 
341a cd 8d 19				call forth_push_numhl 
341d			 
341d			.mul_done: 
341d					NEXTW 
341d c3 7e 1b			jp macro_next 
3420				endm 
# End of macro NEXTW
3420			 
3420			 
3420			 
3420			 
3420			.MIN: 
3420				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3420 49				db WORD_SYS_CORE+53             
3421 a1 34			dw .MAX            
3423 04				db 3 + 1 
3424 .. 00			db "MIN",0              
3428				endm 
# End of macro CWHEAD
3428			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3428					if DEBUG_FORTH_WORDS_KEY 
3428						DMARK "MIN" 
3428 f5				push af  
3429 3a 3d 34			ld a, (.dmark)  
342c 32 77 fb			ld (debug_mark),a  
342f 3a 3e 34			ld a, (.dmark+1)  
3432 32 78 fb			ld (debug_mark+1),a  
3435 3a 3f 34			ld a, (.dmark+2)  
3438 32 79 fb			ld (debug_mark+2),a  
343b 18 03			jr .pastdmark  
343d ..			.dmark: db "MIN"  
3440 f1			.pastdmark: pop af  
3441			endm  
# End of macro DMARK
3441						CALLMONITOR 
3441 cd 00 14			call break_point_state  
3444				endm  
# End of macro CALLMONITOR
3444					endif 
3444					; get u2 
3444			 
3444					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3444 cd 28 1a			call macro_dsp_valuehl 
3447				endm 
# End of macro FORTH_DSP_VALUEHL
3447			 
3447 e5					push hl   ; u2 
3448			 
3448					; destroy value TOS 
3448			 
3448					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3448 cd c4 1a			call macro_forth_dsp_pop 
344b				endm 
# End of macro FORTH_DSP_POP
344b			 
344b					; get u1 
344b			 
344b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
344b cd 28 1a			call macro_dsp_valuehl 
344e				endm 
# End of macro FORTH_DSP_VALUEHL
344e			 
344e e5					push hl  ; u1 
344f			 
344f					; destroy value TOS 
344f			 
344f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
344f cd c4 1a			call macro_forth_dsp_pop 
3452				endm 
# End of macro FORTH_DSP_POP
3452			 
3452 b7			 or a      ;clear carry flag 
3453 e1			  pop hl    ; u1 
3454 d1			  pop de    ; u2 
3455 e5				push hl   ; saved in case hl is lowest 
3456 ed 52		  sbc hl,de 
3458 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
345a			 
345a e1				pop hl 
345b					if DEBUG_FORTH_WORDS 
345b						DMARK "MIN" 
345b f5				push af  
345c 3a 70 34			ld a, (.dmark)  
345f 32 77 fb			ld (debug_mark),a  
3462 3a 71 34			ld a, (.dmark+1)  
3465 32 78 fb			ld (debug_mark+1),a  
3468 3a 72 34			ld a, (.dmark+2)  
346b 32 79 fb			ld (debug_mark+2),a  
346e 18 03			jr .pastdmark  
3470 ..			.dmark: db "MIN"  
3473 f1			.pastdmark: pop af  
3474			endm  
# End of macro DMARK
3474						CALLMONITOR 
3474 cd 00 14			call break_point_state  
3477				endm  
# End of macro CALLMONITOR
3477					endif 
3477 cd 8d 19				call forth_push_numhl 
347a			 
347a				       NEXTW 
347a c3 7e 1b			jp macro_next 
347d				endm 
# End of macro NEXTW
347d			 
347d			.mincont:  
347d c1				pop bc   ; tidy up 
347e eb				ex de , hl  
347f					if DEBUG_FORTH_WORDS 
347f						DMARK "MI1" 
347f f5				push af  
3480 3a 94 34			ld a, (.dmark)  
3483 32 77 fb			ld (debug_mark),a  
3486 3a 95 34			ld a, (.dmark+1)  
3489 32 78 fb			ld (debug_mark+1),a  
348c 3a 96 34			ld a, (.dmark+2)  
348f 32 79 fb			ld (debug_mark+2),a  
3492 18 03			jr .pastdmark  
3494 ..			.dmark: db "MI1"  
3497 f1			.pastdmark: pop af  
3498			endm  
# End of macro DMARK
3498						CALLMONITOR 
3498 cd 00 14			call break_point_state  
349b				endm  
# End of macro CALLMONITOR
349b					endif 
349b cd 8d 19				call forth_push_numhl 
349e			 
349e				       NEXTW 
349e c3 7e 1b			jp macro_next 
34a1				endm 
# End of macro NEXTW
34a1			.MAX: 
34a1				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
34a1 4a				db WORD_SYS_CORE+54             
34a2 22 35			dw .RND16            
34a4 04				db 3 + 1 
34a5 .. 00			db "MAX",0              
34a9				endm 
# End of macro CWHEAD
34a9			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
34a9					if DEBUG_FORTH_WORDS_KEY 
34a9						DMARK "MAX" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 77 fb			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 78 fb			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 79 fb			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "MAX"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd 00 14			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5					; get u2 
34c5			 
34c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c5 cd 28 1a			call macro_dsp_valuehl 
34c8				endm 
# End of macro FORTH_DSP_VALUEHL
34c8			 
34c8 e5					push hl   ; u2 
34c9			 
34c9					; destroy value TOS 
34c9			 
34c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34c9 cd c4 1a			call macro_forth_dsp_pop 
34cc				endm 
# End of macro FORTH_DSP_POP
34cc			 
34cc					; get u1 
34cc			 
34cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34cc cd 28 1a			call macro_dsp_valuehl 
34cf				endm 
# End of macro FORTH_DSP_VALUEHL
34cf			 
34cf e5					push hl  ; u1 
34d0			 
34d0					; destroy value TOS 
34d0			 
34d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d0 cd c4 1a			call macro_forth_dsp_pop 
34d3				endm 
# End of macro FORTH_DSP_POP
34d3			 
34d3 b7			 or a      ;clear carry flag 
34d4 e1			  pop hl    ; u1 
34d5 d1			  pop de    ; u2 
34d6 e5				push hl   ; saved in case hl is lowest 
34d7 ed 52		  sbc hl,de 
34d9 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
34db			 
34db e1				pop hl 
34dc					if DEBUG_FORTH_WORDS 
34dc						DMARK "MAX" 
34dc f5				push af  
34dd 3a f1 34			ld a, (.dmark)  
34e0 32 77 fb			ld (debug_mark),a  
34e3 3a f2 34			ld a, (.dmark+1)  
34e6 32 78 fb			ld (debug_mark+1),a  
34e9 3a f3 34			ld a, (.dmark+2)  
34ec 32 79 fb			ld (debug_mark+2),a  
34ef 18 03			jr .pastdmark  
34f1 ..			.dmark: db "MAX"  
34f4 f1			.pastdmark: pop af  
34f5			endm  
# End of macro DMARK
34f5						CALLMONITOR 
34f5 cd 00 14			call break_point_state  
34f8				endm  
# End of macro CALLMONITOR
34f8					endif 
34f8 cd 8d 19				call forth_push_numhl 
34fb			 
34fb				       NEXTW 
34fb c3 7e 1b			jp macro_next 
34fe				endm 
# End of macro NEXTW
34fe			 
34fe			.maxcont:  
34fe c1				pop bc   ; tidy up 
34ff eb				ex de , hl  
3500					if DEBUG_FORTH_WORDS 
3500						DMARK "MA1" 
3500 f5				push af  
3501 3a 15 35			ld a, (.dmark)  
3504 32 77 fb			ld (debug_mark),a  
3507 3a 16 35			ld a, (.dmark+1)  
350a 32 78 fb			ld (debug_mark+1),a  
350d 3a 17 35			ld a, (.dmark+2)  
3510 32 79 fb			ld (debug_mark+2),a  
3513 18 03			jr .pastdmark  
3515 ..			.dmark: db "MA1"  
3518 f1			.pastdmark: pop af  
3519			endm  
# End of macro DMARK
3519						CALLMONITOR 
3519 cd 00 14			call break_point_state  
351c				endm  
# End of macro CALLMONITOR
351c					endif 
351c cd 8d 19				call forth_push_numhl 
351f				       NEXTW 
351f c3 7e 1b			jp macro_next 
3522				endm 
# End of macro NEXTW
3522			 
3522			.RND16: 
3522				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3522 4e				db WORD_SYS_CORE+58             
3523 51 35			dw .RND8            
3525 06				db 5 + 1 
3526 .. 00			db "RND16",0              
352c				endm 
# End of macro CWHEAD
352c			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
352c					if DEBUG_FORTH_WORDS_KEY 
352c						DMARK "R16" 
352c f5				push af  
352d 3a 41 35			ld a, (.dmark)  
3530 32 77 fb			ld (debug_mark),a  
3533 3a 42 35			ld a, (.dmark+1)  
3536 32 78 fb			ld (debug_mark+1),a  
3539 3a 43 35			ld a, (.dmark+2)  
353c 32 79 fb			ld (debug_mark+2),a  
353f 18 03			jr .pastdmark  
3541 ..			.dmark: db "R16"  
3544 f1			.pastdmark: pop af  
3545			endm  
# End of macro DMARK
3545						CALLMONITOR 
3545 cd 00 14			call break_point_state  
3548				endm  
# End of macro CALLMONITOR
3548					endif 
3548 cd 39 0b				call prng16  
354b cd 8d 19				call forth_push_numhl 
354e				       NEXTW 
354e c3 7e 1b			jp macro_next 
3551				endm 
# End of macro NEXTW
3551			.RND8: 
3551				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3551 60				db WORD_SYS_CORE+76             
3552 86 35			dw .RND            
3554 05				db 4 + 1 
3555 .. 00			db "RND8",0              
355a				endm 
# End of macro CWHEAD
355a			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
355a					if DEBUG_FORTH_WORDS_KEY 
355a						DMARK "RN8" 
355a f5				push af  
355b 3a 6f 35			ld a, (.dmark)  
355e 32 77 fb			ld (debug_mark),a  
3561 3a 70 35			ld a, (.dmark+1)  
3564 32 78 fb			ld (debug_mark+1),a  
3567 3a 71 35			ld a, (.dmark+2)  
356a 32 79 fb			ld (debug_mark+2),a  
356d 18 03			jr .pastdmark  
356f ..			.dmark: db "RN8"  
3572 f1			.pastdmark: pop af  
3573			endm  
# End of macro DMARK
3573						CALLMONITOR 
3573 cd 00 14			call break_point_state  
3576				endm  
# End of macro CALLMONITOR
3576					endif 
3576 2a b8 f8				ld hl,(xrandc) 
3579 23					inc hl 
357a cd 53 0b				call xrnd 
357d 6f					ld l,a	 
357e 26 00				ld h,0 
3580 cd 8d 19				call forth_push_numhl 
3583				       NEXTW 
3583 c3 7e 1b			jp macro_next 
3586				endm 
# End of macro NEXTW
3586			.RND: 
3586				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3586 60				db WORD_SYS_CORE+76             
3587 8c 36			dw .ENDMATHS            
3589 04				db 3 + 1 
358a .. 00			db "RND",0              
358e				endm 
# End of macro CWHEAD
358e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
358e			 
358e					if DEBUG_FORTH_WORDS_KEY 
358e						DMARK "RND" 
358e f5				push af  
358f 3a a3 35			ld a, (.dmark)  
3592 32 77 fb			ld (debug_mark),a  
3595 3a a4 35			ld a, (.dmark+1)  
3598 32 78 fb			ld (debug_mark+1),a  
359b 3a a5 35			ld a, (.dmark+2)  
359e 32 79 fb			ld (debug_mark+2),a  
35a1 18 03			jr .pastdmark  
35a3 ..			.dmark: db "RND"  
35a6 f1			.pastdmark: pop af  
35a7			endm  
# End of macro DMARK
35a7						CALLMONITOR 
35a7 cd 00 14			call break_point_state  
35aa				endm  
# End of macro CALLMONITOR
35aa					endif 
35aa					 
35aa					FORTH_DSP_VALUEHL    ; upper range 
35aa cd 28 1a			call macro_dsp_valuehl 
35ad				endm 
# End of macro FORTH_DSP_VALUEHL
35ad			 
35ad 22 bc f8				ld (LFSRSeed), hl	 
35b0			 
35b0					if DEBUG_FORTH_WORDS 
35b0						DMARK "RN1" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 77 fb			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 78 fb			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 79 fb			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "RN1"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd 00 14			call break_point_state  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc					FORTH_DSP_POP 
35cc cd c4 1a			call macro_forth_dsp_pop 
35cf				endm 
# End of macro FORTH_DSP_POP
35cf			 
35cf					FORTH_DSP_VALUEHL    ; low range 
35cf cd 28 1a			call macro_dsp_valuehl 
35d2				endm 
# End of macro FORTH_DSP_VALUEHL
35d2			 
35d2					if DEBUG_FORTH_WORDS 
35d2						DMARK "RN2" 
35d2 f5				push af  
35d3 3a e7 35			ld a, (.dmark)  
35d6 32 77 fb			ld (debug_mark),a  
35d9 3a e8 35			ld a, (.dmark+1)  
35dc 32 78 fb			ld (debug_mark+1),a  
35df 3a e9 35			ld a, (.dmark+2)  
35e2 32 79 fb			ld (debug_mark+2),a  
35e5 18 03			jr .pastdmark  
35e7 ..			.dmark: db "RN2"  
35ea f1			.pastdmark: pop af  
35eb			endm  
# End of macro DMARK
35eb						CALLMONITOR 
35eb cd 00 14			call break_point_state  
35ee				endm  
# End of macro CALLMONITOR
35ee					endif 
35ee 22 be f8				ld (LFSRSeed+2), hl 
35f1			 
35f1					FORTH_DSP_POP 
35f1 cd c4 1a			call macro_forth_dsp_pop 
35f4				endm 
# End of macro FORTH_DSP_POP
35f4			 
35f4 e5					push hl 
35f5			 
35f5 e1			.inrange:	pop hl 
35f6 cd 39 0b				call prng16  
35f9					if DEBUG_FORTH_WORDS 
35f9						DMARK "RN3" 
35f9 f5				push af  
35fa 3a 0e 36			ld a, (.dmark)  
35fd 32 77 fb			ld (debug_mark),a  
3600 3a 0f 36			ld a, (.dmark+1)  
3603 32 78 fb			ld (debug_mark+1),a  
3606 3a 10 36			ld a, (.dmark+2)  
3609 32 79 fb			ld (debug_mark+2),a  
360c 18 03			jr .pastdmark  
360e ..			.dmark: db "RN3"  
3611 f1			.pastdmark: pop af  
3612			endm  
# End of macro DMARK
3612						CALLMONITOR 
3612 cd 00 14			call break_point_state  
3615				endm  
# End of macro CALLMONITOR
3615					endif 
3615					 
3615					; if the range is 8bit knock out the high byte 
3615			 
3615 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3619			 
3619 3e 00				ld a, 0 
361b ba					cp d  
361c 20 1e				jr nz, .hirange 
361e 26 00				ld h, 0   ; knock it down to 8bit 
3620			 
3620					if DEBUG_FORTH_WORDS 
3620						DMARK "RNk" 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 77 fb			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 78 fb			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 79 fb			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "RNk"  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639						CALLMONITOR 
3639 cd 00 14			call break_point_state  
363c				endm  
# End of macro CALLMONITOR
363c					endif 
363c			.hirange:   
363c e5					push hl  
363d b7					or a  
363e ed 52		                sbc hl, de 
3640			 
3640					;call cmp16 
3640			 
3640 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3642 e1					pop hl 
3643 e5					push hl 
3644			 
3644					if DEBUG_FORTH_WORDS 
3644						DMARK "RN4" 
3644 f5				push af  
3645 3a 59 36			ld a, (.dmark)  
3648 32 77 fb			ld (debug_mark),a  
364b 3a 5a 36			ld a, (.dmark+1)  
364e 32 78 fb			ld (debug_mark+1),a  
3651 3a 5b 36			ld a, (.dmark+2)  
3654 32 79 fb			ld (debug_mark+2),a  
3657 18 03			jr .pastdmark  
3659 ..			.dmark: db "RN4"  
365c f1			.pastdmark: pop af  
365d			endm  
# End of macro DMARK
365d						CALLMONITOR 
365d cd 00 14			call break_point_state  
3660				endm  
# End of macro CALLMONITOR
3660					endif 
3660 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3664					;call cmp16 
3664				 
3664 b7					or a  
3665 ed 52		                sbc hl, de 
3667 38 8c				jr c, .inrange 
3669			 
3669 e1					pop hl 
366a					 
366a					if DEBUG_FORTH_WORDS 
366a						DMARK "RNd" 
366a f5				push af  
366b 3a 7f 36			ld a, (.dmark)  
366e 32 77 fb			ld (debug_mark),a  
3671 3a 80 36			ld a, (.dmark+1)  
3674 32 78 fb			ld (debug_mark+1),a  
3677 3a 81 36			ld a, (.dmark+2)  
367a 32 79 fb			ld (debug_mark+2),a  
367d 18 03			jr .pastdmark  
367f ..			.dmark: db "RNd"  
3682 f1			.pastdmark: pop af  
3683			endm  
# End of macro DMARK
3683						CALLMONITOR 
3683 cd 00 14			call break_point_state  
3686				endm  
# End of macro CALLMONITOR
3686					endif 
3686			 
3686			 
3686 cd 8d 19				call forth_push_numhl 
3689				       NEXTW 
3689 c3 7e 1b			jp macro_next 
368c				endm 
# End of macro NEXTW
368c			 
368c			.ENDMATHS: 
368c			 
368c			; eof 
368c			 
# End of file forth_words_maths.asm
368c			include "forth_words_display.asm" 
368c			 
368c			; | ## Display Words 
368c			 
368c			.ATP: 
368c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
368c 62				db WORD_SYS_CORE+78             
368d 03 37			dw .FB            
368f 04				db 3 + 1 
3690 .. 00			db "AT?",0              
3694				endm 
# End of macro CWHEAD
3694			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3694					if DEBUG_FORTH_WORDS_KEY 
3694						DMARK "AT?" 
3694 f5				push af  
3695 3a a9 36			ld a, (.dmark)  
3698 32 77 fb			ld (debug_mark),a  
369b 3a aa 36			ld a, (.dmark+1)  
369e 32 78 fb			ld (debug_mark+1),a  
36a1 3a ab 36			ld a, (.dmark+2)  
36a4 32 79 fb			ld (debug_mark+2),a  
36a7 18 03			jr .pastdmark  
36a9 ..			.dmark: db "AT?"  
36ac f1			.pastdmark: pop af  
36ad			endm  
# End of macro DMARK
36ad						CALLMONITOR 
36ad cd 00 14			call break_point_state  
36b0				endm  
# End of macro CALLMONITOR
36b0					endif 
36b0 3a 5b f8				ld a, (f_cursor_ptr) 
36b3			 
36b3			if DEBUG_FORTH_WORDS 
36b3				DMARK "AT?" 
36b3 f5				push af  
36b4 3a c8 36			ld a, (.dmark)  
36b7 32 77 fb			ld (debug_mark),a  
36ba 3a c9 36			ld a, (.dmark+1)  
36bd 32 78 fb			ld (debug_mark+1),a  
36c0 3a ca 36			ld a, (.dmark+2)  
36c3 32 79 fb			ld (debug_mark+2),a  
36c6 18 03			jr .pastdmark  
36c8 ..			.dmark: db "AT?"  
36cb f1			.pastdmark: pop af  
36cc			endm  
# End of macro DMARK
36cc				CALLMONITOR 
36cc cd 00 14			call break_point_state  
36cf				endm  
# End of macro CALLMONITOR
36cf			endif	 
36cf					; count the number of rows 
36cf			 
36cf 06 00				ld b, 0 
36d1 4f			.atpr:		ld c, a    ; save in case we go below zero 
36d2 d6 28				sub display_cols 
36d4 f2 da 36				jp p, .atprunder 
36d7 04					inc b 
36d8 18 f7				jr .atpr 
36da			.atprunder:	 
36da			if DEBUG_FORTH_WORDS 
36da				DMARK "A?2" 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 77 fb			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 78 fb			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 79 fb			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "A?2"  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3				CALLMONITOR 
36f3 cd 00 14			call break_point_state  
36f6				endm  
# End of macro CALLMONITOR
36f6			endif	 
36f6 26 00				ld h, 0 
36f8 69					ld l, c 
36f9 cd 8d 19				call forth_push_numhl 
36fc 68					ld l, b  
36fd cd 8d 19				call forth_push_numhl 
3700			 
3700			 
3700				NEXTW 
3700 c3 7e 1b			jp macro_next 
3703				endm 
# End of macro NEXTW
3703			 
3703			.FB: 
3703				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3703 1b				db WORD_SYS_CORE+7             
3704 51 37			dw .EMIT            
3706 03				db 2 + 1 
3707 .. 00			db "FB",0              
370a				endm 
# End of macro CWHEAD
370a			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
370a			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
370a			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
370a			; | | If automatic display is off then updates will not be shown until DRAW is used. 
370a					if DEBUG_FORTH_WORDS_KEY 
370a						DMARK "FB." 
370a f5				push af  
370b 3a 1f 37			ld a, (.dmark)  
370e 32 77 fb			ld (debug_mark),a  
3711 3a 20 37			ld a, (.dmark+1)  
3714 32 78 fb			ld (debug_mark+1),a  
3717 3a 21 37			ld a, (.dmark+2)  
371a 32 79 fb			ld (debug_mark+2),a  
371d 18 03			jr .pastdmark  
371f ..			.dmark: db "FB."  
3722 f1			.pastdmark: pop af  
3723			endm  
# End of macro DMARK
3723						CALLMONITOR 
3723 cd 00 14			call break_point_state  
3726				endm  
# End of macro CALLMONITOR
3726					endif 
3726			 
3726					FORTH_DSP_VALUEHL 
3726 cd 28 1a			call macro_dsp_valuehl 
3729				endm 
# End of macro FORTH_DSP_VALUEHL
3729			 
3729 7d					ld a, l 
372a fe 01				cp 1 
372c 20 05				jr nz, .fbn1 
372e 21 1c fa				ld hl, display_fb1 
3731 18 15				jr .fbset 
3733 fe 02		.fbn1:		cp 2 
3735 20 05				jr nz, .fbn2 
3737 21 da f8				ld hl, display_fb2 
373a 18 0c				jr .fbset 
373c fe 03		.fbn2:		cp 3 
373e 20 05				jr nz, .fbn3 
3740 21 7b f9				ld hl, display_fb3 
3743 18 03				jr .fbset 
3745			.fbn3:		 ; if invalid number select first 
3745 21 1c fa				ld hl, display_fb1 
3748 22 d8 f8		.fbset:		ld (display_fb_active), hl 
374b			 
374b					FORTH_DSP_POP 
374b cd c4 1a			call macro_forth_dsp_pop 
374e				endm 
# End of macro FORTH_DSP_POP
374e			 
374e					NEXTW 
374e c3 7e 1b			jp macro_next 
3751				endm 
# End of macro NEXTW
3751			 
3751			 
3751			.EMIT: 
3751				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3751 1b				db WORD_SYS_CORE+7             
3752 a2 37			dw .DOTH            
3754 05				db 4 + 1 
3755 .. 00			db "EMIT",0              
375a				endm 
# End of macro CWHEAD
375a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
375a					; get value off TOS and display it 
375a			 
375a					if DEBUG_FORTH_WORDS_KEY 
375a						DMARK "EMT" 
375a f5				push af  
375b 3a 6f 37			ld a, (.dmark)  
375e 32 77 fb			ld (debug_mark),a  
3761 3a 70 37			ld a, (.dmark+1)  
3764 32 78 fb			ld (debug_mark+1),a  
3767 3a 71 37			ld a, (.dmark+2)  
376a 32 79 fb			ld (debug_mark+2),a  
376d 18 03			jr .pastdmark  
376f ..			.dmark: db "EMT"  
3772 f1			.pastdmark: pop af  
3773			endm  
# End of macro DMARK
3773						CALLMONITOR 
3773 cd 00 14			call break_point_state  
3776				endm  
# End of macro CALLMONITOR
3776					endif 
3776			 
3776					FORTH_DSP_VALUEHL 
3776 cd 28 1a			call macro_dsp_valuehl 
3779				endm 
# End of macro FORTH_DSP_VALUEHL
3779			 
3779 7d					ld a,l 
377a			 
377a					; TODO write to display 
377a			 
377a 32 30 f0				ld (os_input), a 
377d 3e 00				ld a, 0 
377f 32 31 f0				ld (os_input+1), a 
3782					 
3782 3a 5b f8				ld a, (f_cursor_ptr) 
3785 11 30 f0				ld de, os_input 
3788 cd cc 0a				call str_at_display 
378b			 
378b			 
378b 3a 39 f8				ld a,(cli_autodisplay) 
378e fe 00				cp 0 
3790 28 03				jr z, .enoupdate 
3792 cd dc 0a						call update_display 
3795					.enoupdate: 
3795			 
3795 3a 5b f8				ld a, (f_cursor_ptr) 
3798 3c					inc a 
3799 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
379c			 
379c			 
379c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379c cd c4 1a			call macro_forth_dsp_pop 
379f				endm 
# End of macro FORTH_DSP_POP
379f			  
379f			 
379f					NEXTW 
379f c3 7e 1b			jp macro_next 
37a2				endm 
# End of macro NEXTW
37a2			.DOTH: 
37a2				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
37a2 1c				db WORD_SYS_CORE+8             
37a3 d2 37			dw .DOTF            
37a5 03				db 2 + 1 
37a6 .. 00			db ".-",0              
37a9				endm 
# End of macro CWHEAD
37a9			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
37a9					; get value off TOS and display it 
37a9					if DEBUG_FORTH_WORDS_KEY 
37a9						DMARK "DTD" 
37a9 f5				push af  
37aa 3a be 37			ld a, (.dmark)  
37ad 32 77 fb			ld (debug_mark),a  
37b0 3a bf 37			ld a, (.dmark+1)  
37b3 32 78 fb			ld (debug_mark+1),a  
37b6 3a c0 37			ld a, (.dmark+2)  
37b9 32 79 fb			ld (debug_mark+2),a  
37bc 18 03			jr .pastdmark  
37be ..			.dmark: db "DTD"  
37c1 f1			.pastdmark: pop af  
37c2			endm  
# End of macro DMARK
37c2						CALLMONITOR 
37c2 cd 00 14			call break_point_state  
37c5				endm  
# End of macro CALLMONITOR
37c5					endif 
37c5 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
37c7 3e 00			ld a, 0 
37c9 32 3a f8			ld (cli_mvdot), a 
37cc c3 29 38			jp .dotgo 
37cf				NEXTW 
37cf c3 7e 1b			jp macro_next 
37d2				endm 
# End of macro NEXTW
37d2			.DOTF: 
37d2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
37d2 1c				db WORD_SYS_CORE+8             
37d3 00 38			dw .DOT            
37d5 03				db 2 + 1 
37d6 .. 00			db ".>",0              
37d9				endm 
# End of macro CWHEAD
37d9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
37d9					; get value off TOS and display it 
37d9			        ; TODO BUG adds extra spaces 
37d9			        ; TODO BUG handle numerics? 
37d9					if DEBUG_FORTH_WORDS_KEY 
37d9						DMARK "DTC" 
37d9 f5				push af  
37da 3a ee 37			ld a, (.dmark)  
37dd 32 77 fb			ld (debug_mark),a  
37e0 3a ef 37			ld a, (.dmark+1)  
37e3 32 78 fb			ld (debug_mark+1),a  
37e6 3a f0 37			ld a, (.dmark+2)  
37e9 32 79 fb			ld (debug_mark+2),a  
37ec 18 03			jr .pastdmark  
37ee ..			.dmark: db "DTC"  
37f1 f1			.pastdmark: pop af  
37f2			endm  
# End of macro DMARK
37f2						CALLMONITOR 
37f2 cd 00 14			call break_point_state  
37f5				endm  
# End of macro CALLMONITOR
37f5					endif 
37f5 3e 01			ld a, 1 
37f7 32 3a f8			ld (cli_mvdot), a 
37fa c3 29 38			jp .dotgo 
37fd				NEXTW 
37fd c3 7e 1b			jp macro_next 
3800				endm 
# End of macro NEXTW
3800			 
3800			.DOT: 
3800				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3800 1c				db WORD_SYS_CORE+8             
3801 8c 38			dw .CLS            
3803 02				db 1 + 1 
3804 .. 00			db ".",0              
3806				endm 
# End of macro CWHEAD
3806			        ; | . ( u -- ) Display TOS | DONE 
3806					; get value off TOS and display it 
3806			 
3806					if DEBUG_FORTH_WORDS_KEY 
3806						DMARK "DOT" 
3806 f5				push af  
3807 3a 1b 38			ld a, (.dmark)  
380a 32 77 fb			ld (debug_mark),a  
380d 3a 1c 38			ld a, (.dmark+1)  
3810 32 78 fb			ld (debug_mark+1),a  
3813 3a 1d 38			ld a, (.dmark+2)  
3816 32 79 fb			ld (debug_mark+2),a  
3819 18 03			jr .pastdmark  
381b ..			.dmark: db "DOT"  
381e f1			.pastdmark: pop af  
381f			endm  
# End of macro DMARK
381f						CALLMONITOR 
381f cd 00 14			call break_point_state  
3822				endm  
# End of macro CALLMONITOR
3822					endif 
3822 3e 00			ld a, 0 
3824 32 3a f8			ld (cli_mvdot), a 
3827 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3829				 
3829			 
3829			.dotgo: 
3829			 
3829			; move up type to on stack for parserv5 
3829					FORTH_DSP 
3829 cd 0d 1a			call macro_forth_dsp 
382c				endm 
# End of macro FORTH_DSP
382c				;FORTH_DSP_VALUE  
382c			 
382c			if DEBUG_FORTH_DOT 
382c				DMARK "DOT" 
382c				CALLMONITOR 
382c			endif	 
382c			;		.print: 
382c			 
382c 7e				ld a,(hl)  ; work out what type of value is on the TOS 
382d 23				inc hl   ; position to the actual value 
382e fe 01			cp DS_TYPE_STR 
3830 20 06			jr nz, .dotnum1  
3832			 
3832			; display string 
3832				FORTH_DSP_VALUE  
3832 cd 11 1a			call macro_forth_dsp_value 
3835				endm 
# End of macro FORTH_DSP_VALUE
3835 eb				ex de,hl 
3836 18 11			jr .dotwrite 
3838			 
3838			.dotnum1: 
3838 fe 02			cp DS_TYPE_INUM 
383a 20 0c			jr nz, .dotflot 
383c			 
383c			 
383c			; display number 
383c			 
383c			;	push hl 
383c			;	call clear_display 
383c			;	pop hl 
383c			 
383c 5e				ld e, (hl) 
383d 23				inc hl 
383e 56				ld d, (hl) 
383f 21 32 ee			ld hl, scratch 
3842			if DEBUG_FORTH_DOT 
3842				DMARK "DT1" 
3842				CALLMONITOR 
3842			endif	 
3842			 
3842 cd 1f 10			call uitoa_16 
3845 eb				ex de,hl 
3846			 
3846			if DEBUG_FORTH_DOT 
3846				DMARK "DT2" 
3846				CALLMONITOR 
3846			endif	 
3846			 
3846			;	ld de, os_word_scratch 
3846 18 01			jr .dotwrite 
3848			 
3848 00			.dotflot:   nop 
3849			; TODO print floating point number 
3849			 
3849			.dotwrite:		 
3849			 
3849					; if c is set then set all '-' to spaces 
3849					; need to also take into account .>  
3849			 
3849 3e 01				ld a, 1 
384b b9					cp c 
384c 20 13				jr nz, .nodashswap 
384e			 
384e					; DE has the string to write, working with HL 
384e			 
384e 06 ff				ld b, 255 
3850 d5					push de 
3851 e1					pop hl 
3852			 
3852			if DEBUG_FORTH_DOT 
3852				DMARK "DT-" 
3852				CALLMONITOR 
3852			endif	 
3852 7e			.dashscan:	ld a, (hl) 
3853 fe 00				cp 0 
3855 28 0a				jr z, .nodashswap 
3857 fe 2d				cp '-' 
3859 20 03				jr nz, .dashskip 
385b 3e 20				ld a, ' ' 
385d 77					ld (hl), a 
385e 23			.dashskip:	inc hl 
385f			if DEBUG_FORTH_DOT 
385f				DMARK "D-2" 
385f				CALLMONITOR 
385f			endif	 
385f 10 f1				djnz .dashscan 
3861			 
3861			if DEBUG_FORTH_DOT 
3861				DMARK "D-1" 
3861				CALLMONITOR 
3861			endif	 
3861			 
3861			.nodashswap: 
3861			 
3861 e5					push hl   ; save string start in case we need to advance print 
3862			 
3862 3a 5b f8				ld a, (f_cursor_ptr) 
3865 cd cc 0a				call str_at_display 
3868 3a 39 f8				ld a,(cli_autodisplay) 
386b fe 00				cp 0 
386d 28 03				jr z, .noupdate 
386f cd dc 0a						call update_display 
3872					.noupdate: 
3872			 
3872			 
3872					; see if we need to advance the print position 
3872			 
3872 e1					pop hl   ; get back string 
3873			 
3873 3a 3a f8				ld a, (cli_mvdot) 
3876			if DEBUG_FORTH_DOT 
3876					ld e,a 
3876				DMARK "D>1" 
3876				CALLMONITOR 
3876			endif	 
3876 fe 00				cp 0 
3878 28 0c				jr z, .noadv 
387a					; yes, lets advance the print position 
387a 3e 00				ld a, 0 
387c cd 7b 10				call strlent 
387f 3a 5b f8				ld a, (f_cursor_ptr) 
3882 85					add a,l 
3883					;call addatohl 
3883					;ld a, l 
3883 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
3886			 
3886			if DEBUG_FORTH_DOT 
3886				DMARK "D->" 
3886				CALLMONITOR 
3886			endif	 
3886			 
3886			.noadv:	 
3886			 
3886					if DEBUG_FORTH_DOT_WAIT 
3886							call next_page_prompt 
3886					endif	 
3886			; TODO this pop off the stack causes a crash. i dont know why 
3886			 
3886			 
3886			if DEBUG_FORTH_DOT 
3886				DMARK "DTh" 
3886				CALLMONITOR 
3886			endif	 
3886			 
3886					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3886 cd c4 1a			call macro_forth_dsp_pop 
3889				endm 
# End of macro FORTH_DSP_POP
3889			 
3889			if DEBUG_FORTH_DOT 
3889				DMARK "DTi" 
3889				CALLMONITOR 
3889			endif	 
3889			 
3889			 
3889					NEXTW 
3889 c3 7e 1b			jp macro_next 
388c				endm 
# End of macro NEXTW
388c			 
388c			.CLS: 
388c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
388c 35				db WORD_SYS_CORE+33             
388d b9 38			dw .DRAW            
388f 04				db 3 + 1 
3890 .. 00			db "CLS",0              
3894				endm 
# End of macro CWHEAD
3894			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3894					if DEBUG_FORTH_WORDS_KEY 
3894						DMARK "CLS" 
3894 f5				push af  
3895 3a a9 38			ld a, (.dmark)  
3898 32 77 fb			ld (debug_mark),a  
389b 3a aa 38			ld a, (.dmark+1)  
389e 32 78 fb			ld (debug_mark+1),a  
38a1 3a ab 38			ld a, (.dmark+2)  
38a4 32 79 fb			ld (debug_mark+2),a  
38a7 18 03			jr .pastdmark  
38a9 ..			.dmark: db "CLS"  
38ac f1			.pastdmark: pop af  
38ad			endm  
# End of macro DMARK
38ad						CALLMONITOR 
38ad cd 00 14			call break_point_state  
38b0				endm  
# End of macro CALLMONITOR
38b0					endif 
38b0 cd b9 0a				call clear_display 
38b3 c3 c7 39				jp .home		; and home cursor 
38b6					NEXTW 
38b6 c3 7e 1b			jp macro_next 
38b9				endm 
# End of macro NEXTW
38b9			 
38b9			.DRAW: 
38b9				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
38b9 36				db WORD_SYS_CORE+34             
38ba e4 38			dw .DUMP            
38bc 05				db 4 + 1 
38bd .. 00			db "DRAW",0              
38c2				endm 
# End of macro CWHEAD
38c2			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
38c2					if DEBUG_FORTH_WORDS_KEY 
38c2						DMARK "DRW" 
38c2 f5				push af  
38c3 3a d7 38			ld a, (.dmark)  
38c6 32 77 fb			ld (debug_mark),a  
38c9 3a d8 38			ld a, (.dmark+1)  
38cc 32 78 fb			ld (debug_mark+1),a  
38cf 3a d9 38			ld a, (.dmark+2)  
38d2 32 79 fb			ld (debug_mark+2),a  
38d5 18 03			jr .pastdmark  
38d7 ..			.dmark: db "DRW"  
38da f1			.pastdmark: pop af  
38db			endm  
# End of macro DMARK
38db						CALLMONITOR 
38db cd 00 14			call break_point_state  
38de				endm  
# End of macro CALLMONITOR
38de					endif 
38de cd dc 0a				call update_display 
38e1					NEXTW 
38e1 c3 7e 1b			jp macro_next 
38e4				endm 
# End of macro NEXTW
38e4			 
38e4			.DUMP: 
38e4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
38e4 37				db WORD_SYS_CORE+35             
38e5 1c 39			dw .CDUMP            
38e7 05				db 4 + 1 
38e8 .. 00			db "DUMP",0              
38ed				endm 
# End of macro CWHEAD
38ed			; | DUMP ( x -- ) With address x display dump   | DONE 
38ed			; TODO pop address to use off of the stack 
38ed					if DEBUG_FORTH_WORDS_KEY 
38ed						DMARK "DUM" 
38ed f5				push af  
38ee 3a 02 39			ld a, (.dmark)  
38f1 32 77 fb			ld (debug_mark),a  
38f4 3a 03 39			ld a, (.dmark+1)  
38f7 32 78 fb			ld (debug_mark+1),a  
38fa 3a 04 39			ld a, (.dmark+2)  
38fd 32 79 fb			ld (debug_mark+2),a  
3900 18 03			jr .pastdmark  
3902 ..			.dmark: db "DUM"  
3905 f1			.pastdmark: pop af  
3906			endm  
# End of macro DMARK
3906						CALLMONITOR 
3906 cd 00 14			call break_point_state  
3909				endm  
# End of macro CALLMONITOR
3909					endif 
3909 cd b9 0a				call clear_display 
390c			 
390c					; get address 
390c			 
390c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
390c cd 28 1a			call macro_dsp_valuehl 
390f				endm 
# End of macro FORTH_DSP_VALUEHL
390f				 
390f					; save it for cdump 
390f			 
390f 22 55 f1				ld (os_cur_ptr),hl 
3912			 
3912					; destroy value TOS 
3912			 
3912					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3912 cd c4 1a			call macro_forth_dsp_pop 
3915				endm 
# End of macro FORTH_DSP_POP
3915			 
3915 cd 0d 18				call dumpcont	; skip old style of param parsing	 
3918 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3919					NEXTW 
3919 c3 7e 1b			jp macro_next 
391c				endm 
# End of macro NEXTW
391c			.CDUMP: 
391c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
391c 38				db WORD_SYS_CORE+36             
391d 4c 39			dw .DAT            
391f 06				db 5 + 1 
3920 .. 00			db "CDUMP",0              
3926				endm 
# End of macro CWHEAD
3926			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3926					if DEBUG_FORTH_WORDS_KEY 
3926						DMARK "CDP" 
3926 f5				push af  
3927 3a 3b 39			ld a, (.dmark)  
392a 32 77 fb			ld (debug_mark),a  
392d 3a 3c 39			ld a, (.dmark+1)  
3930 32 78 fb			ld (debug_mark+1),a  
3933 3a 3d 39			ld a, (.dmark+2)  
3936 32 79 fb			ld (debug_mark+2),a  
3939 18 03			jr .pastdmark  
393b ..			.dmark: db "CDP"  
393e f1			.pastdmark: pop af  
393f			endm  
# End of macro DMARK
393f						CALLMONITOR 
393f cd 00 14			call break_point_state  
3942				endm  
# End of macro CALLMONITOR
3942					endif 
3942 cd b9 0a				call clear_display 
3945 cd 0d 18				call dumpcont	 
3948 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3949					NEXTW 
3949 c3 7e 1b			jp macro_next 
394c				endm 
# End of macro NEXTW
394c			 
394c			 
394c			 
394c			 
394c			.DAT: 
394c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
394c 3d				db WORD_SYS_CORE+41             
394d a2 39			dw .HOME            
394f 03				db 2 + 1 
3950 .. 00			db "AT",0              
3953				endm 
# End of macro CWHEAD
3953			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3953					if DEBUG_FORTH_WORDS_KEY 
3953						DMARK "AT." 
3953 f5				push af  
3954 3a 68 39			ld a, (.dmark)  
3957 32 77 fb			ld (debug_mark),a  
395a 3a 69 39			ld a, (.dmark+1)  
395d 32 78 fb			ld (debug_mark+1),a  
3960 3a 6a 39			ld a, (.dmark+2)  
3963 32 79 fb			ld (debug_mark+2),a  
3966 18 03			jr .pastdmark  
3968 ..			.dmark: db "AT."  
396b f1			.pastdmark: pop af  
396c			endm  
# End of macro DMARK
396c						CALLMONITOR 
396c cd 00 14			call break_point_state  
396f				endm  
# End of macro CALLMONITOR
396f					endif 
396f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396f cd 28 1a			call macro_dsp_valuehl 
3972				endm 
# End of macro FORTH_DSP_VALUEHL
3972			 
3972			 
3972					; TODO save cursor row 
3972 7d					ld a,l 
3973 fe 02				cp 2 
3975 20 04				jr nz, .crow3 
3977 3e 28				ld a, display_row_2 
3979 18 12				jr .ccol1 
397b fe 03		.crow3:		cp 3 
397d 20 04				jr nz, .crow4 
397f 3e 50				ld a, display_row_3 
3981 18 0a				jr .ccol1 
3983 fe 04		.crow4:		cp 4 
3985 20 04				jr nz, .crow1 
3987 3e 78				ld a, display_row_4 
3989 18 02				jr .ccol1 
398b 3e 00		.crow1:		ld a,display_row_1 
398d f5			.ccol1:		push af			; got row offset 
398e 6f					ld l,a 
398f 26 00				ld h,0 
3991					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3991 cd c4 1a			call macro_forth_dsp_pop 
3994				endm 
# End of macro FORTH_DSP_POP
3994					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3994 cd 28 1a			call macro_dsp_valuehl 
3997				endm 
# End of macro FORTH_DSP_VALUEHL
3997					; TODO save cursor col 
3997 f1					pop af 
3998 85					add l		; add col offset 
3999 32 5b f8				ld (f_cursor_ptr), a 
399c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399c cd c4 1a			call macro_forth_dsp_pop 
399f				endm 
# End of macro FORTH_DSP_POP
399f			 
399f					; calculate  
399f			 
399f					NEXTW 
399f c3 7e 1b			jp macro_next 
39a2				endm 
# End of macro NEXTW
39a2			 
39a2			 
39a2			.HOME: 
39a2				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
39a2 41				db WORD_SYS_CORE+45             
39a3 cf 39			dw .SPACE            
39a5 05				db 4 + 1 
39a6 .. 00			db "HOME",0              
39ab				endm 
# End of macro CWHEAD
39ab			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
39ab					if DEBUG_FORTH_WORDS_KEY 
39ab						DMARK "HOM" 
39ab f5				push af  
39ac 3a c0 39			ld a, (.dmark)  
39af 32 77 fb			ld (debug_mark),a  
39b2 3a c1 39			ld a, (.dmark+1)  
39b5 32 78 fb			ld (debug_mark+1),a  
39b8 3a c2 39			ld a, (.dmark+2)  
39bb 32 79 fb			ld (debug_mark+2),a  
39be 18 03			jr .pastdmark  
39c0 ..			.dmark: db "HOM"  
39c3 f1			.pastdmark: pop af  
39c4			endm  
# End of macro DMARK
39c4						CALLMONITOR 
39c4 cd 00 14			call break_point_state  
39c7				endm  
# End of macro CALLMONITOR
39c7					endif 
39c7 3e 00		.home:		ld a, 0		; and home cursor 
39c9 32 5b f8				ld (f_cursor_ptr), a 
39cc					NEXTW 
39cc c3 7e 1b			jp macro_next 
39cf				endm 
# End of macro NEXTW
39cf			 
39cf			 
39cf			.SPACE: 
39cf				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
39cf 46				db WORD_SYS_CORE+50             
39d0 fd 39			dw .SPACES            
39d2 03				db 2 + 1 
39d3 .. 00			db "BL",0              
39d6				endm 
# End of macro CWHEAD
39d6			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
39d6					if DEBUG_FORTH_WORDS_KEY 
39d6						DMARK "BL." 
39d6 f5				push af  
39d7 3a eb 39			ld a, (.dmark)  
39da 32 77 fb			ld (debug_mark),a  
39dd 3a ec 39			ld a, (.dmark+1)  
39e0 32 78 fb			ld (debug_mark+1),a  
39e3 3a ed 39			ld a, (.dmark+2)  
39e6 32 79 fb			ld (debug_mark+2),a  
39e9 18 03			jr .pastdmark  
39eb ..			.dmark: db "BL."  
39ee f1			.pastdmark: pop af  
39ef			endm  
# End of macro DMARK
39ef						CALLMONITOR 
39ef cd 00 14			call break_point_state  
39f2				endm  
# End of macro CALLMONITOR
39f2					endif 
39f2 21 fb 39				ld hl, .blstr 
39f5 cd 9f 19				call forth_push_str 
39f8					 
39f8				       NEXTW 
39f8 c3 7e 1b			jp macro_next 
39fb				endm 
# End of macro NEXTW
39fb			 
39fb .. 00		.blstr: db " ", 0 
39fd			 
39fd			.SPACES: 
39fd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
39fd 47				db WORD_SYS_CORE+51             
39fe 98 3a			dw .SCROLL            
3a00 07				db 6 + 1 
3a01 .. 00			db "SPACES",0              
3a08				endm 
# End of macro CWHEAD
3a08			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a08					if DEBUG_FORTH_WORDS_KEY 
3a08						DMARK "SPS" 
3a08 f5				push af  
3a09 3a 1d 3a			ld a, (.dmark)  
3a0c 32 77 fb			ld (debug_mark),a  
3a0f 3a 1e 3a			ld a, (.dmark+1)  
3a12 32 78 fb			ld (debug_mark+1),a  
3a15 3a 1f 3a			ld a, (.dmark+2)  
3a18 32 79 fb			ld (debug_mark+2),a  
3a1b 18 03			jr .pastdmark  
3a1d ..			.dmark: db "SPS"  
3a20 f1			.pastdmark: pop af  
3a21			endm  
# End of macro DMARK
3a21						CALLMONITOR 
3a21 cd 00 14			call break_point_state  
3a24				endm  
# End of macro CALLMONITOR
3a24					endif 
3a24			 
3a24			 
3a24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a24 cd 28 1a			call macro_dsp_valuehl 
3a27				endm 
# End of macro FORTH_DSP_VALUEHL
3a27			 
3a27			;		push hl    ; u 
3a27					if DEBUG_FORTH_WORDS 
3a27						DMARK "SPA" 
3a27 f5				push af  
3a28 3a 3c 3a			ld a, (.dmark)  
3a2b 32 77 fb			ld (debug_mark),a  
3a2e 3a 3d 3a			ld a, (.dmark+1)  
3a31 32 78 fb			ld (debug_mark+1),a  
3a34 3a 3e 3a			ld a, (.dmark+2)  
3a37 32 79 fb			ld (debug_mark+2),a  
3a3a 18 03			jr .pastdmark  
3a3c ..			.dmark: db "SPA"  
3a3f f1			.pastdmark: pop af  
3a40			endm  
# End of macro DMARK
3a40						CALLMONITOR 
3a40 cd 00 14			call break_point_state  
3a43				endm  
# End of macro CALLMONITOR
3a43					endif 
3a43			 
3a43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a43 cd c4 1a			call macro_forth_dsp_pop 
3a46				endm 
# End of macro FORTH_DSP_POP
3a46			;		pop hl 
3a46 4d					ld c, l 
3a47 06 00				ld b, 0 
3a49 21 32 ee				ld hl, scratch  
3a4c			 
3a4c					if DEBUG_FORTH_WORDS 
3a4c						DMARK "SP2" 
3a4c f5				push af  
3a4d 3a 61 3a			ld a, (.dmark)  
3a50 32 77 fb			ld (debug_mark),a  
3a53 3a 62 3a			ld a, (.dmark+1)  
3a56 32 78 fb			ld (debug_mark+1),a  
3a59 3a 63 3a			ld a, (.dmark+2)  
3a5c 32 79 fb			ld (debug_mark+2),a  
3a5f 18 03			jr .pastdmark  
3a61 ..			.dmark: db "SP2"  
3a64 f1			.pastdmark: pop af  
3a65			endm  
# End of macro DMARK
3a65						CALLMONITOR 
3a65 cd 00 14			call break_point_state  
3a68				endm  
# End of macro CALLMONITOR
3a68					endif 
3a68 3e 20				ld a, ' ' 
3a6a c5			.spaces1:	push bc 
3a6b 77					ld (hl),a 
3a6c 23					inc hl 
3a6d c1					pop bc 
3a6e 10 fa				djnz .spaces1 
3a70 3e 00				ld a,0 
3a72 77					ld (hl),a 
3a73 21 32 ee				ld hl, scratch 
3a76					if DEBUG_FORTH_WORDS 
3a76						DMARK "SP3" 
3a76 f5				push af  
3a77 3a 8b 3a			ld a, (.dmark)  
3a7a 32 77 fb			ld (debug_mark),a  
3a7d 3a 8c 3a			ld a, (.dmark+1)  
3a80 32 78 fb			ld (debug_mark+1),a  
3a83 3a 8d 3a			ld a, (.dmark+2)  
3a86 32 79 fb			ld (debug_mark+2),a  
3a89 18 03			jr .pastdmark  
3a8b ..			.dmark: db "SP3"  
3a8e f1			.pastdmark: pop af  
3a8f			endm  
# End of macro DMARK
3a8f						CALLMONITOR 
3a8f cd 00 14			call break_point_state  
3a92				endm  
# End of macro CALLMONITOR
3a92					endif 
3a92 cd d5 19				call forth_apush 
3a95			 
3a95				       NEXTW 
3a95 c3 7e 1b			jp macro_next 
3a98				endm 
# End of macro NEXTW
3a98			 
3a98			 
3a98			 
3a98			.SCROLL: 
3a98				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
3a98 53				db WORD_SYS_CORE+63             
3a99 c5 3a			dw .ATQ            
3a9b 07				db 6 + 1 
3a9c .. 00			db "SCROLL",0              
3aa3				endm 
# End of macro CWHEAD
3aa3			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3aa3					if DEBUG_FORTH_WORDS_KEY 
3aa3						DMARK "SCR" 
3aa3 f5				push af  
3aa4 3a b8 3a			ld a, (.dmark)  
3aa7 32 77 fb			ld (debug_mark),a  
3aaa 3a b9 3a			ld a, (.dmark+1)  
3aad 32 78 fb			ld (debug_mark+1),a  
3ab0 3a ba 3a			ld a, (.dmark+2)  
3ab3 32 79 fb			ld (debug_mark+2),a  
3ab6 18 03			jr .pastdmark  
3ab8 ..			.dmark: db "SCR"  
3abb f1			.pastdmark: pop af  
3abc			endm  
# End of macro DMARK
3abc						CALLMONITOR 
3abc cd 00 14			call break_point_state  
3abf				endm  
# End of macro CALLMONITOR
3abf					endif 
3abf			 
3abf cd 51 0a			call scroll_up 
3ac2			;	call update_display 
3ac2			 
3ac2					NEXTW 
3ac2 c3 7e 1b			jp macro_next 
3ac5				endm 
# End of macro NEXTW
3ac5			 
3ac5			 
3ac5			 
3ac5			;		; get dir 
3ac5			; 
3ac5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac5			; 
3ac5			;		push hl 
3ac5			; 
3ac5			;		; destroy value TOS 
3ac5			; 
3ac5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac5			; 
3ac5			;		; get count 
3ac5			; 
3ac5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac5			; 
3ac5			;		push hl 
3ac5			; 
3ac5			;		; destroy value TOS 
3ac5			; 
3ac5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac5			; 
3ac5			;		; one value on hl get other one back 
3ac5			; 
3ac5			;		pop bc    ; count 
3ac5			; 
3ac5			;		pop de   ; dir 
3ac5			; 
3ac5			; 
3ac5			;		ld b, c 
3ac5			; 
3ac5			;.scrolldir:     push bc 
3ac5			;		push de 
3ac5			; 
3ac5			;		ld a, 0 
3ac5			;		cp e 
3ac5			;		jr z, .scrollup  
3ac5			;		call scroll_down 
3ac5			;		jr .scrollnext 
3ac5			;.scrollup:	call scroll_up 
3ac5			; 
3ac5			;		 
3ac5			;.scrollnext: 
3ac5			;		pop de 
3ac5			;		pop bc 
3ac5			;		djnz .scrolldir 
3ac5			; 
3ac5			; 
3ac5			; 
3ac5			; 
3ac5			; 
3ac5			;		NEXTW 
3ac5			 
3ac5			 
3ac5			 
3ac5			 
3ac5			.ATQ: 
3ac5				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ac5 62				db WORD_SYS_CORE+78             
3ac6 23 3b			dw .AUTODSP            
3ac8 04				db 3 + 1 
3ac9 .. 00			db "AT@",0              
3acd				endm 
# End of macro CWHEAD
3acd			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3acd					if DEBUG_FORTH_WORDS_KEY 
3acd						DMARK "ATA" 
3acd f5				push af  
3ace 3a e2 3a			ld a, (.dmark)  
3ad1 32 77 fb			ld (debug_mark),a  
3ad4 3a e3 3a			ld a, (.dmark+1)  
3ad7 32 78 fb			ld (debug_mark+1),a  
3ada 3a e4 3a			ld a, (.dmark+2)  
3add 32 79 fb			ld (debug_mark+2),a  
3ae0 18 03			jr .pastdmark  
3ae2 ..			.dmark: db "ATA"  
3ae5 f1			.pastdmark: pop af  
3ae6			endm  
# End of macro DMARK
3ae6						CALLMONITOR 
3ae6 cd 00 14			call break_point_state  
3ae9				endm  
# End of macro CALLMONITOR
3ae9					endif 
3ae9			 
3ae9			 
3ae9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae9 cd 28 1a			call macro_dsp_valuehl 
3aec				endm 
# End of macro FORTH_DSP_VALUEHL
3aec			 
3aec					; TODO save cursor row 
3aec 7d					ld a,l 
3aed fe 02				cp 2 
3aef 20 04				jr nz, .crow3aq 
3af1 3e 28				ld a, display_row_2 
3af3 18 12				jr .ccol1aq 
3af5 fe 03		.crow3aq:		cp 3 
3af7 20 04				jr nz, .crow4aq 
3af9 3e 50				ld a, display_row_3 
3afb 18 0a				jr .ccol1aq 
3afd fe 04		.crow4aq:		cp 4 
3aff 20 04				jr nz, .crow1aq 
3b01 3e 78				ld a, display_row_4 
3b03 18 02				jr .ccol1aq 
3b05 3e 00		.crow1aq:		ld a,display_row_1 
3b07 f5			.ccol1aq:		push af			; got row offset 
3b08 6f					ld l,a 
3b09 26 00				ld h,0 
3b0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0b cd c4 1a			call macro_forth_dsp_pop 
3b0e				endm 
# End of macro FORTH_DSP_POP
3b0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0e cd 28 1a			call macro_dsp_valuehl 
3b11				endm 
# End of macro FORTH_DSP_VALUEHL
3b11					; TODO save cursor col 
3b11 f1					pop af 
3b12 85					add l		; add col offset 
3b13			 
3b13					; add current frame buffer address 
3b13 2a d8 f8				ld hl, (display_fb_active) 
3b16 cd 12 0c				call addatohl 
3b19			 
3b19			 
3b19			 
3b19			 
3b19					; get char frame buffer location offset in hl 
3b19			 
3b19 7e					ld a,(hl) 
3b1a 26 00				ld h, 0 
3b1c 6f					ld l, a 
3b1d			 
3b1d cd 8d 19				call forth_push_numhl 
3b20			 
3b20			 
3b20					NEXTW 
3b20 c3 7e 1b			jp macro_next 
3b23				endm 
# End of macro NEXTW
3b23			 
3b23			.AUTODSP: 
3b23				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3b23 63				db WORD_SYS_CORE+79             
3b24 39 3b			dw .MENU            
3b26 05				db 4 + 1 
3b27 .. 00			db "ADSP",0              
3b2c				endm 
# End of macro CWHEAD
3b2c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3b2c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3b2c			 
3b2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b2c cd 28 1a			call macro_dsp_valuehl 
3b2f				endm 
# End of macro FORTH_DSP_VALUEHL
3b2f			 
3b2f			;		push hl 
3b2f			 
3b2f					; destroy value TOS 
3b2f			 
3b2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2f cd c4 1a			call macro_forth_dsp_pop 
3b32				endm 
# End of macro FORTH_DSP_POP
3b32			 
3b32			;		pop hl 
3b32			 
3b32 7d					ld a,l 
3b33 32 39 f8				ld (cli_autodisplay), a 
3b36				       NEXTW 
3b36 c3 7e 1b			jp macro_next 
3b39				endm 
# End of macro NEXTW
3b39			 
3b39			.MENU: 
3b39				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3b39 70				db WORD_SYS_CORE+92             
3b3a 45 3b			dw .ENDDISPLAY            
3b3c 05				db 4 + 1 
3b3d .. 00			db "MENU",0              
3b42				endm 
# End of macro CWHEAD
3b42			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
3b42			 
3b42					; get the title address and save it 
3b42			 
3b42			;		FORTH_DSP_VALUEHL 
3b42			;		push hl 
3b42			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b42			; 
3b42			;		; get number of items on the stack 
3b42			; 
3b42			;	 
3b42			;		FORTH_DSP_VALUEHL 
3b42			;		push hl 
3b42			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b42			 
3b42			 
3b42			 
3b42			 
3b42				       NEXTW 
3b42 c3 7e 1b			jp macro_next 
3b45				endm 
# End of macro NEXTW
3b45			 
3b45			 
3b45			.ENDDISPLAY: 
3b45			 
3b45			; eof 
# End of file forth_words_display.asm
3b45			include "forth_words_str.asm" 
3b45			 
3b45			; | ## String Words 
3b45			 
3b45			.PTR:   
3b45			 
3b45				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3b45 48				db WORD_SYS_CORE+52             
3b46 72 3b			dw .STYPE            
3b48 04				db 3 + 1 
3b49 .. 00			db "PTR",0              
3b4d				endm 
# End of macro CWHEAD
3b4d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3b4d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3b4d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3b4d			 
3b4d					if DEBUG_FORTH_WORDS_KEY 
3b4d						DMARK "PTR" 
3b4d f5				push af  
3b4e 3a 62 3b			ld a, (.dmark)  
3b51 32 77 fb			ld (debug_mark),a  
3b54 3a 63 3b			ld a, (.dmark+1)  
3b57 32 78 fb			ld (debug_mark+1),a  
3b5a 3a 64 3b			ld a, (.dmark+2)  
3b5d 32 79 fb			ld (debug_mark+2),a  
3b60 18 03			jr .pastdmark  
3b62 ..			.dmark: db "PTR"  
3b65 f1			.pastdmark: pop af  
3b66			endm  
# End of macro DMARK
3b66						CALLMONITOR 
3b66 cd 00 14			call break_point_state  
3b69				endm  
# End of macro CALLMONITOR
3b69					endif 
3b69					FORTH_DSP_VALUEHL 
3b69 cd 28 1a			call macro_dsp_valuehl 
3b6c				endm 
# End of macro FORTH_DSP_VALUEHL
3b6c cd 8d 19				call forth_push_numhl 
3b6f			 
3b6f			 
3b6f					NEXTW 
3b6f c3 7e 1b			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			.STYPE: 
3b72				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3b72 48				db WORD_SYS_CORE+52             
3b73 c1 3b			dw .UPPER            
3b75 06				db 5 + 1 
3b76 .. 00			db "STYPE",0              
3b7c				endm 
# End of macro CWHEAD
3b7c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3b7c					if DEBUG_FORTH_WORDS_KEY 
3b7c						DMARK "STY" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 77 fb			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 78 fb			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 79 fb			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "STY"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						CALLMONITOR 
3b95 cd 00 14			call break_point_state  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98					FORTH_DSP 
3b98 cd 0d 1a			call macro_forth_dsp 
3b9b				endm 
# End of macro FORTH_DSP
3b9b					;v5 FORTH_DSP_VALUE 
3b9b			 
3b9b 7e					ld a, (hl) 
3b9c			 
3b9c f5					push af 
3b9d			 
3b9d			; Dont destroy TOS		FORTH_DSP_POP 
3b9d			 
3b9d f1					pop af 
3b9e			 
3b9e fe 01				cp DS_TYPE_STR 
3ba0 28 09				jr z, .typestr 
3ba2			 
3ba2 fe 02				cp DS_TYPE_INUM 
3ba4 28 0a				jr z, .typeinum 
3ba6			 
3ba6 21 bf 3b				ld hl, .tna 
3ba9 18 0a				jr .tpush 
3bab			 
3bab 21 bb 3b		.typestr:	ld hl, .tstr 
3bae 18 05				jr .tpush 
3bb0 21 bd 3b		.typeinum:	ld hl, .tinum 
3bb3 18 00				jr .tpush 
3bb5			 
3bb5			.tpush: 
3bb5			 
3bb5 cd 9f 19				call forth_push_str 
3bb8			 
3bb8					NEXTW 
3bb8 c3 7e 1b			jp macro_next 
3bbb				endm 
# End of macro NEXTW
3bbb .. 00		.tstr:	db "s",0 
3bbd .. 00		.tinum:  db "i",0 
3bbf .. 00		.tna:   db "?", 0 
3bc1			 
3bc1			 
3bc1			.UPPER: 
3bc1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3bc1 48				db WORD_SYS_CORE+52             
3bc2 fc 3b			dw .LOWER            
3bc4 06				db 5 + 1 
3bc5 .. 00			db "UPPER",0              
3bcb				endm 
# End of macro CWHEAD
3bcb			; | UPPER ( s -- s ) Upper case string s  | DONE 
3bcb					if DEBUG_FORTH_WORDS_KEY 
3bcb						DMARK "UPR" 
3bcb f5				push af  
3bcc 3a e0 3b			ld a, (.dmark)  
3bcf 32 77 fb			ld (debug_mark),a  
3bd2 3a e1 3b			ld a, (.dmark+1)  
3bd5 32 78 fb			ld (debug_mark+1),a  
3bd8 3a e2 3b			ld a, (.dmark+2)  
3bdb 32 79 fb			ld (debug_mark+2),a  
3bde 18 03			jr .pastdmark  
3be0 ..			.dmark: db "UPR"  
3be3 f1			.pastdmark: pop af  
3be4			endm  
# End of macro DMARK
3be4						CALLMONITOR 
3be4 cd 00 14			call break_point_state  
3be7				endm  
# End of macro CALLMONITOR
3be7					endif 
3be7			 
3be7					FORTH_DSP 
3be7 cd 0d 1a			call macro_forth_dsp 
3bea				endm 
# End of macro FORTH_DSP
3bea					 
3bea			; TODO check is string type 
3bea			 
3bea					FORTH_DSP_VALUEHL 
3bea cd 28 1a			call macro_dsp_valuehl 
3bed				endm 
# End of macro FORTH_DSP_VALUEHL
3bed			; get pointer to string in hl 
3bed			 
3bed 7e			.toup:		ld a, (hl) 
3bee fe 00				cp 0 
3bf0 28 07				jr z, .toupdone 
3bf2			 
3bf2 cd 7f 0f				call to_upper 
3bf5			 
3bf5 77					ld (hl), a 
3bf6 23					inc hl 
3bf7 18 f4				jr .toup 
3bf9			 
3bf9					 
3bf9			 
3bf9			 
3bf9			; for each char convert to upper 
3bf9					 
3bf9			.toupdone: 
3bf9			 
3bf9			 
3bf9					NEXTW 
3bf9 c3 7e 1b			jp macro_next 
3bfc				endm 
# End of macro NEXTW
3bfc			.LOWER: 
3bfc				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3bfc 48				db WORD_SYS_CORE+52             
3bfd 37 3c			dw .TCASE            
3bff 06				db 5 + 1 
3c00 .. 00			db "LOWER",0              
3c06				endm 
# End of macro CWHEAD
3c06			; | LOWER ( s -- s ) Lower case string s  | DONE 
3c06					if DEBUG_FORTH_WORDS_KEY 
3c06						DMARK "LWR" 
3c06 f5				push af  
3c07 3a 1b 3c			ld a, (.dmark)  
3c0a 32 77 fb			ld (debug_mark),a  
3c0d 3a 1c 3c			ld a, (.dmark+1)  
3c10 32 78 fb			ld (debug_mark+1),a  
3c13 3a 1d 3c			ld a, (.dmark+2)  
3c16 32 79 fb			ld (debug_mark+2),a  
3c19 18 03			jr .pastdmark  
3c1b ..			.dmark: db "LWR"  
3c1e f1			.pastdmark: pop af  
3c1f			endm  
# End of macro DMARK
3c1f						CALLMONITOR 
3c1f cd 00 14			call break_point_state  
3c22				endm  
# End of macro CALLMONITOR
3c22					endif 
3c22			 
3c22					FORTH_DSP 
3c22 cd 0d 1a			call macro_forth_dsp 
3c25				endm 
# End of macro FORTH_DSP
3c25					 
3c25			; TODO check is string type 
3c25			 
3c25					FORTH_DSP_VALUEHL 
3c25 cd 28 1a			call macro_dsp_valuehl 
3c28				endm 
# End of macro FORTH_DSP_VALUEHL
3c28			; get pointer to string in hl 
3c28			 
3c28 7e			.tolow:		ld a, (hl) 
3c29 fe 00				cp 0 
3c2b 28 07				jr z, .tolowdone 
3c2d			 
3c2d cd 88 0f				call to_lower 
3c30			 
3c30 77					ld (hl), a 
3c31 23					inc hl 
3c32 18 f4				jr .tolow 
3c34			 
3c34					 
3c34			 
3c34			 
3c34			; for each char convert to low 
3c34					 
3c34			.tolowdone: 
3c34					NEXTW 
3c34 c3 7e 1b			jp macro_next 
3c37				endm 
# End of macro NEXTW
3c37			.TCASE: 
3c37				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3c37 48				db WORD_SYS_CORE+52             
3c38 6d 3d			dw .SUBSTR            
3c3a 06				db 5 + 1 
3c3b .. 00			db "TCASE",0              
3c41				endm 
# End of macro CWHEAD
3c41			; | TCASE ( s -- s ) Title case string s  | DONE 
3c41					if DEBUG_FORTH_WORDS_KEY 
3c41						DMARK "TCS" 
3c41 f5				push af  
3c42 3a 56 3c			ld a, (.dmark)  
3c45 32 77 fb			ld (debug_mark),a  
3c48 3a 57 3c			ld a, (.dmark+1)  
3c4b 32 78 fb			ld (debug_mark+1),a  
3c4e 3a 58 3c			ld a, (.dmark+2)  
3c51 32 79 fb			ld (debug_mark+2),a  
3c54 18 03			jr .pastdmark  
3c56 ..			.dmark: db "TCS"  
3c59 f1			.pastdmark: pop af  
3c5a			endm  
# End of macro DMARK
3c5a						CALLMONITOR 
3c5a cd 00 14			call break_point_state  
3c5d				endm  
# End of macro CALLMONITOR
3c5d					endif 
3c5d			 
3c5d					FORTH_DSP 
3c5d cd 0d 1a			call macro_forth_dsp 
3c60				endm 
# End of macro FORTH_DSP
3c60					 
3c60			; TODO check is string type 
3c60			 
3c60					FORTH_DSP_VALUEHL 
3c60 cd 28 1a			call macro_dsp_valuehl 
3c63				endm 
# End of macro FORTH_DSP_VALUEHL
3c63			; get pointer to string in hl 
3c63			 
3c63					if DEBUG_FORTH_WORDS 
3c63						DMARK "TC1" 
3c63 f5				push af  
3c64 3a 78 3c			ld a, (.dmark)  
3c67 32 77 fb			ld (debug_mark),a  
3c6a 3a 79 3c			ld a, (.dmark+1)  
3c6d 32 78 fb			ld (debug_mark+1),a  
3c70 3a 7a 3c			ld a, (.dmark+2)  
3c73 32 79 fb			ld (debug_mark+2),a  
3c76 18 03			jr .pastdmark  
3c78 ..			.dmark: db "TC1"  
3c7b f1			.pastdmark: pop af  
3c7c			endm  
# End of macro DMARK
3c7c						CALLMONITOR 
3c7c cd 00 14			call break_point_state  
3c7f				endm  
# End of macro CALLMONITOR
3c7f					endif 
3c7f			 
3c7f					; first time in turn to upper case first char 
3c7f			 
3c7f 7e					ld a, (hl) 
3c80 c3 0a 3d				jp .totsiptou 
3c83			 
3c83			 
3c83 7e			.tot:		ld a, (hl) 
3c84 fe 00				cp 0 
3c86 ca 4e 3d				jp z, .totdone 
3c89			 
3c89					if DEBUG_FORTH_WORDS 
3c89						DMARK "TC2" 
3c89 f5				push af  
3c8a 3a 9e 3c			ld a, (.dmark)  
3c8d 32 77 fb			ld (debug_mark),a  
3c90 3a 9f 3c			ld a, (.dmark+1)  
3c93 32 78 fb			ld (debug_mark+1),a  
3c96 3a a0 3c			ld a, (.dmark+2)  
3c99 32 79 fb			ld (debug_mark+2),a  
3c9c 18 03			jr .pastdmark  
3c9e ..			.dmark: db "TC2"  
3ca1 f1			.pastdmark: pop af  
3ca2			endm  
# End of macro DMARK
3ca2						CALLMONITOR 
3ca2 cd 00 14			call break_point_state  
3ca5				endm  
# End of macro CALLMONITOR
3ca5					endif 
3ca5					; check to see if current char is a space 
3ca5			 
3ca5 fe 20				cp ' ' 
3ca7 28 21				jr z, .totsp 
3ca9 cd 88 0f				call to_lower 
3cac					if DEBUG_FORTH_WORDS 
3cac						DMARK "TC3" 
3cac f5				push af  
3cad 3a c1 3c			ld a, (.dmark)  
3cb0 32 77 fb			ld (debug_mark),a  
3cb3 3a c2 3c			ld a, (.dmark+1)  
3cb6 32 78 fb			ld (debug_mark+1),a  
3cb9 3a c3 3c			ld a, (.dmark+2)  
3cbc 32 79 fb			ld (debug_mark+2),a  
3cbf 18 03			jr .pastdmark  
3cc1 ..			.dmark: db "TC3"  
3cc4 f1			.pastdmark: pop af  
3cc5			endm  
# End of macro DMARK
3cc5						CALLMONITOR 
3cc5 cd 00 14			call break_point_state  
3cc8				endm  
# End of macro CALLMONITOR
3cc8					endif 
3cc8 18 63				jr .totnxt 
3cca			 
3cca			.totsp:         ; on a space, find next char which should be upper 
3cca			 
3cca					if DEBUG_FORTH_WORDS 
3cca						DMARK "TC4" 
3cca f5				push af  
3ccb 3a df 3c			ld a, (.dmark)  
3cce 32 77 fb			ld (debug_mark),a  
3cd1 3a e0 3c			ld a, (.dmark+1)  
3cd4 32 78 fb			ld (debug_mark+1),a  
3cd7 3a e1 3c			ld a, (.dmark+2)  
3cda 32 79 fb			ld (debug_mark+2),a  
3cdd 18 03			jr .pastdmark  
3cdf ..			.dmark: db "TC4"  
3ce2 f1			.pastdmark: pop af  
3ce3			endm  
# End of macro DMARK
3ce3						CALLMONITOR 
3ce3 cd 00 14			call break_point_state  
3ce6				endm  
# End of macro CALLMONITOR
3ce6					endif 
3ce6					;; 
3ce6			 
3ce6 fe 20				cp ' ' 
3ce8 20 20				jr nz, .totsiptou 
3cea 23					inc hl 
3ceb 7e					ld a, (hl) 
3cec					if DEBUG_FORTH_WORDS 
3cec						DMARK "TC5" 
3cec f5				push af  
3ced 3a 01 3d			ld a, (.dmark)  
3cf0 32 77 fb			ld (debug_mark),a  
3cf3 3a 02 3d			ld a, (.dmark+1)  
3cf6 32 78 fb			ld (debug_mark+1),a  
3cf9 3a 03 3d			ld a, (.dmark+2)  
3cfc 32 79 fb			ld (debug_mark+2),a  
3cff 18 03			jr .pastdmark  
3d01 ..			.dmark: db "TC5"  
3d04 f1			.pastdmark: pop af  
3d05			endm  
# End of macro DMARK
3d05						CALLMONITOR 
3d05 cd 00 14			call break_point_state  
3d08				endm  
# End of macro CALLMONITOR
3d08					endif 
3d08 18 c0				jr .totsp 
3d0a fe 00		.totsiptou:    cp 0 
3d0c 28 40				jr z, .totdone 
3d0e					; not space and not zero term so upper case it 
3d0e cd 7f 0f				call to_upper 
3d11			 
3d11					if DEBUG_FORTH_WORDS 
3d11						DMARK "TC6" 
3d11 f5				push af  
3d12 3a 26 3d			ld a, (.dmark)  
3d15 32 77 fb			ld (debug_mark),a  
3d18 3a 27 3d			ld a, (.dmark+1)  
3d1b 32 78 fb			ld (debug_mark+1),a  
3d1e 3a 28 3d			ld a, (.dmark+2)  
3d21 32 79 fb			ld (debug_mark+2),a  
3d24 18 03			jr .pastdmark  
3d26 ..			.dmark: db "TC6"  
3d29 f1			.pastdmark: pop af  
3d2a			endm  
# End of macro DMARK
3d2a						CALLMONITOR 
3d2a cd 00 14			call break_point_state  
3d2d				endm  
# End of macro CALLMONITOR
3d2d					endif 
3d2d			 
3d2d			 
3d2d			.totnxt: 
3d2d			 
3d2d 77					ld (hl), a 
3d2e 23					inc hl 
3d2f					if DEBUG_FORTH_WORDS 
3d2f						DMARK "TC7" 
3d2f f5				push af  
3d30 3a 44 3d			ld a, (.dmark)  
3d33 32 77 fb			ld (debug_mark),a  
3d36 3a 45 3d			ld a, (.dmark+1)  
3d39 32 78 fb			ld (debug_mark+1),a  
3d3c 3a 46 3d			ld a, (.dmark+2)  
3d3f 32 79 fb			ld (debug_mark+2),a  
3d42 18 03			jr .pastdmark  
3d44 ..			.dmark: db "TC7"  
3d47 f1			.pastdmark: pop af  
3d48			endm  
# End of macro DMARK
3d48						CALLMONITOR 
3d48 cd 00 14			call break_point_state  
3d4b				endm  
# End of macro CALLMONITOR
3d4b					endif 
3d4b c3 83 3c				jp .tot 
3d4e			 
3d4e					 
3d4e			 
3d4e			 
3d4e			; for each char convert to low 
3d4e					 
3d4e			.totdone: 
3d4e					if DEBUG_FORTH_WORDS 
3d4e						DMARK "TCd" 
3d4e f5				push af  
3d4f 3a 63 3d			ld a, (.dmark)  
3d52 32 77 fb			ld (debug_mark),a  
3d55 3a 64 3d			ld a, (.dmark+1)  
3d58 32 78 fb			ld (debug_mark+1),a  
3d5b 3a 65 3d			ld a, (.dmark+2)  
3d5e 32 79 fb			ld (debug_mark+2),a  
3d61 18 03			jr .pastdmark  
3d63 ..			.dmark: db "TCd"  
3d66 f1			.pastdmark: pop af  
3d67			endm  
# End of macro DMARK
3d67						CALLMONITOR 
3d67 cd 00 14			call break_point_state  
3d6a				endm  
# End of macro CALLMONITOR
3d6a					endif 
3d6a					NEXTW 
3d6a c3 7e 1b			jp macro_next 
3d6d				endm 
# End of macro NEXTW
3d6d			 
3d6d			.SUBSTR: 
3d6d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3d6d 48				db WORD_SYS_CORE+52             
3d6e cb 3d			dw .LEFT            
3d70 07				db 6 + 1 
3d71 .. 00			db "SUBSTR",0              
3d78				endm 
# End of macro CWHEAD
3d78			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3d78			 
3d78					if DEBUG_FORTH_WORDS_KEY 
3d78						DMARK "SST" 
3d78 f5				push af  
3d79 3a 8d 3d			ld a, (.dmark)  
3d7c 32 77 fb			ld (debug_mark),a  
3d7f 3a 8e 3d			ld a, (.dmark+1)  
3d82 32 78 fb			ld (debug_mark+1),a  
3d85 3a 8f 3d			ld a, (.dmark+2)  
3d88 32 79 fb			ld (debug_mark+2),a  
3d8b 18 03			jr .pastdmark  
3d8d ..			.dmark: db "SST"  
3d90 f1			.pastdmark: pop af  
3d91			endm  
# End of macro DMARK
3d91						CALLMONITOR 
3d91 cd 00 14			call break_point_state  
3d94				endm  
# End of macro CALLMONITOR
3d94					endif 
3d94			; TODO check string type 
3d94					FORTH_DSP_VALUEHL 
3d94 cd 28 1a			call macro_dsp_valuehl 
3d97				endm 
# End of macro FORTH_DSP_VALUEHL
3d97			 
3d97 e5					push hl      ; string length 
3d98			 
3d98					FORTH_DSP_POP 
3d98 cd c4 1a			call macro_forth_dsp_pop 
3d9b				endm 
# End of macro FORTH_DSP_POP
3d9b			 
3d9b					FORTH_DSP_VALUEHL 
3d9b cd 28 1a			call macro_dsp_valuehl 
3d9e				endm 
# End of macro FORTH_DSP_VALUEHL
3d9e			 
3d9e e5					push hl     ; start char 
3d9f			 
3d9f					FORTH_DSP_POP 
3d9f cd c4 1a			call macro_forth_dsp_pop 
3da2				endm 
# End of macro FORTH_DSP_POP
3da2			 
3da2			 
3da2					FORTH_DSP_VALUE 
3da2 cd 11 1a			call macro_forth_dsp_value 
3da5				endm 
# End of macro FORTH_DSP_VALUE
3da5			 
3da5 d1					pop de    ; get start post offset 
3da6			 
3da6 19					add hl, de    ; starting offset 
3da7			 
3da7 c1					pop bc 
3da8 c5					push bc      ; grab size of string 
3da9			 
3da9 e5					push hl    ; save string start  
3daa			 
3daa 26 00				ld h, 0 
3dac 69					ld l, c 
3dad 23					inc hl 
3dae 23					inc hl 
3daf			 
3daf cd d9 10				call malloc 
3db2				if DEBUG_FORTH_MALLOC_GUARD 
3db2 cc ef 4e				call z,malloc_error 
3db5				endif 
3db5			 
3db5 eb					ex de, hl      ; save malloc area for string copy 
3db6 e1					pop hl    ; get back source 
3db7 c1					pop bc    ; get length of string back 
3db8			 
3db8 d5					push de    ; save malloc area for after we push 
3db9 ed b0				ldir     ; copy substr 
3dbb			 
3dbb			 
3dbb eb					ex de, hl 
3dbc 3e 00				ld a, 0 
3dbe 77					ld (hl), a   ; term substr 
3dbf			 
3dbf					 
3dbf e1					pop hl    ; get malloc so we can push it 
3dc0 e5					push hl   ; save so we can free it afterwards 
3dc1			 
3dc1 cd 9f 19				call forth_push_str 
3dc4			 
3dc4 e1					pop hl 
3dc5 cd a3 11				call free 
3dc8			 
3dc8					 
3dc8					 
3dc8			 
3dc8			 
3dc8					NEXTW 
3dc8 c3 7e 1b			jp macro_next 
3dcb				endm 
# End of macro NEXTW
3dcb			 
3dcb			.LEFT: 
3dcb				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3dcb 48				db WORD_SYS_CORE+52             
3dcc f3 3d			dw .RIGHT            
3dce 05				db 4 + 1 
3dcf .. 00			db "LEFT",0              
3dd4				endm 
# End of macro CWHEAD
3dd4			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3dd4					if DEBUG_FORTH_WORDS_KEY 
3dd4						DMARK "LEF" 
3dd4 f5				push af  
3dd5 3a e9 3d			ld a, (.dmark)  
3dd8 32 77 fb			ld (debug_mark),a  
3ddb 3a ea 3d			ld a, (.dmark+1)  
3dde 32 78 fb			ld (debug_mark+1),a  
3de1 3a eb 3d			ld a, (.dmark+2)  
3de4 32 79 fb			ld (debug_mark+2),a  
3de7 18 03			jr .pastdmark  
3de9 ..			.dmark: db "LEF"  
3dec f1			.pastdmark: pop af  
3ded			endm  
# End of macro DMARK
3ded						CALLMONITOR 
3ded cd 00 14			call break_point_state  
3df0				endm  
# End of macro CALLMONITOR
3df0					endif 
3df0			 
3df0					NEXTW 
3df0 c3 7e 1b			jp macro_next 
3df3				endm 
# End of macro NEXTW
3df3			.RIGHT: 
3df3				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3df3 48				db WORD_SYS_CORE+52             
3df4 1c 3e			dw .STR2NUM            
3df6 06				db 5 + 1 
3df7 .. 00			db "RIGHT",0              
3dfd				endm 
# End of macro CWHEAD
3dfd			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3dfd					if DEBUG_FORTH_WORDS_KEY 
3dfd						DMARK "RIG" 
3dfd f5				push af  
3dfe 3a 12 3e			ld a, (.dmark)  
3e01 32 77 fb			ld (debug_mark),a  
3e04 3a 13 3e			ld a, (.dmark+1)  
3e07 32 78 fb			ld (debug_mark+1),a  
3e0a 3a 14 3e			ld a, (.dmark+2)  
3e0d 32 79 fb			ld (debug_mark+2),a  
3e10 18 03			jr .pastdmark  
3e12 ..			.dmark: db "RIG"  
3e15 f1			.pastdmark: pop af  
3e16			endm  
# End of macro DMARK
3e16						CALLMONITOR 
3e16 cd 00 14			call break_point_state  
3e19				endm  
# End of macro CALLMONITOR
3e19					endif 
3e19			 
3e19					NEXTW 
3e19 c3 7e 1b			jp macro_next 
3e1c				endm 
# End of macro NEXTW
3e1c			 
3e1c			 
3e1c			.STR2NUM: 
3e1c				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3e1c 48				db WORD_SYS_CORE+52             
3e1d a8 3e			dw .NUM2STR            
3e1f 08				db 7 + 1 
3e20 .. 00			db "STR2NUM",0              
3e28				endm 
# End of macro CWHEAD
3e28			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3e28			 
3e28			 
3e28			; TODO STR type check to do 
3e28					if DEBUG_FORTH_WORDS_KEY 
3e28						DMARK "S2N" 
3e28 f5				push af  
3e29 3a 3d 3e			ld a, (.dmark)  
3e2c 32 77 fb			ld (debug_mark),a  
3e2f 3a 3e 3e			ld a, (.dmark+1)  
3e32 32 78 fb			ld (debug_mark+1),a  
3e35 3a 3f 3e			ld a, (.dmark+2)  
3e38 32 79 fb			ld (debug_mark+2),a  
3e3b 18 03			jr .pastdmark  
3e3d ..			.dmark: db "S2N"  
3e40 f1			.pastdmark: pop af  
3e41			endm  
# End of macro DMARK
3e41						CALLMONITOR 
3e41 cd 00 14			call break_point_state  
3e44				endm  
# End of macro CALLMONITOR
3e44					endif 
3e44			 
3e44					;FORTH_DSP 
3e44					FORTH_DSP_VALUE 
3e44 cd 11 1a			call macro_forth_dsp_value 
3e47				endm 
# End of macro FORTH_DSP_VALUE
3e47					;inc hl 
3e47			 
3e47 eb					ex de, hl 
3e48					if DEBUG_FORTH_WORDS 
3e48						DMARK "S2a" 
3e48 f5				push af  
3e49 3a 5d 3e			ld a, (.dmark)  
3e4c 32 77 fb			ld (debug_mark),a  
3e4f 3a 5e 3e			ld a, (.dmark+1)  
3e52 32 78 fb			ld (debug_mark+1),a  
3e55 3a 5f 3e			ld a, (.dmark+2)  
3e58 32 79 fb			ld (debug_mark+2),a  
3e5b 18 03			jr .pastdmark  
3e5d ..			.dmark: db "S2a"  
3e60 f1			.pastdmark: pop af  
3e61			endm  
# End of macro DMARK
3e61						CALLMONITOR 
3e61 cd 00 14			call break_point_state  
3e64				endm  
# End of macro CALLMONITOR
3e64					endif 
3e64 cd 07 10				call string_to_uint16 
3e67			 
3e67					if DEBUG_FORTH_WORDS 
3e67						DMARK "S2b" 
3e67 f5				push af  
3e68 3a 7c 3e			ld a, (.dmark)  
3e6b 32 77 fb			ld (debug_mark),a  
3e6e 3a 7d 3e			ld a, (.dmark+1)  
3e71 32 78 fb			ld (debug_mark+1),a  
3e74 3a 7e 3e			ld a, (.dmark+2)  
3e77 32 79 fb			ld (debug_mark+2),a  
3e7a 18 03			jr .pastdmark  
3e7c ..			.dmark: db "S2b"  
3e7f f1			.pastdmark: pop af  
3e80			endm  
# End of macro DMARK
3e80						CALLMONITOR 
3e80 cd 00 14			call break_point_state  
3e83				endm  
# End of macro CALLMONITOR
3e83					endif 
3e83			;		push hl 
3e83					FORTH_DSP_POP 
3e83 cd c4 1a			call macro_forth_dsp_pop 
3e86				endm 
# End of macro FORTH_DSP_POP
3e86			;		pop hl 
3e86					 
3e86					if DEBUG_FORTH_WORDS 
3e86						DMARK "S2b" 
3e86 f5				push af  
3e87 3a 9b 3e			ld a, (.dmark)  
3e8a 32 77 fb			ld (debug_mark),a  
3e8d 3a 9c 3e			ld a, (.dmark+1)  
3e90 32 78 fb			ld (debug_mark+1),a  
3e93 3a 9d 3e			ld a, (.dmark+2)  
3e96 32 79 fb			ld (debug_mark+2),a  
3e99 18 03			jr .pastdmark  
3e9b ..			.dmark: db "S2b"  
3e9e f1			.pastdmark: pop af  
3e9f			endm  
# End of macro DMARK
3e9f						CALLMONITOR 
3e9f cd 00 14			call break_point_state  
3ea2				endm  
# End of macro CALLMONITOR
3ea2					endif 
3ea2 cd 8d 19				call forth_push_numhl	 
3ea5			 
3ea5				 
3ea5				       NEXTW 
3ea5 c3 7e 1b			jp macro_next 
3ea8				endm 
# End of macro NEXTW
3ea8			.NUM2STR: 
3ea8				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3ea8 48				db WORD_SYS_CORE+52             
3ea9 b7 3e			dw .CONCAT            
3eab 08				db 7 + 1 
3eac .. 00			db "NUM2STR",0              
3eb4				endm 
# End of macro CWHEAD
3eb4			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3eb4			 
3eb4			;		; malloc a string to target 
3eb4			;		ld hl, 10     ; TODO max string size should be fine 
3eb4			;		call malloc 
3eb4			;		push hl    ; save malloc location 
3eb4			; 
3eb4			; 
3eb4			;; TODO check int type 
3eb4			;		FORTH_DSP_VALUEHL 
3eb4			;		ld a, l 
3eb4			;		call DispAToASCII   
3eb4			;;TODO need to chage above call to dump into string 
3eb4			; 
3eb4			; 
3eb4			 
3eb4				       NEXTW 
3eb4 c3 7e 1b			jp macro_next 
3eb7				endm 
# End of macro NEXTW
3eb7			 
3eb7			.CONCAT: 
3eb7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3eb7 48				db WORD_SYS_CORE+52             
3eb8 6a 3f			dw .FIND            
3eba 07				db 6 + 1 
3ebb .. 00			db "CONCAT",0              
3ec2				endm 
# End of macro CWHEAD
3ec2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3ec2			 
3ec2			; TODO check string type 
3ec2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3ec2			 
3ec2					if DEBUG_FORTH_WORDS_KEY 
3ec2						DMARK "CON" 
3ec2 f5				push af  
3ec3 3a d7 3e			ld a, (.dmark)  
3ec6 32 77 fb			ld (debug_mark),a  
3ec9 3a d8 3e			ld a, (.dmark+1)  
3ecc 32 78 fb			ld (debug_mark+1),a  
3ecf 3a d9 3e			ld a, (.dmark+2)  
3ed2 32 79 fb			ld (debug_mark+2),a  
3ed5 18 03			jr .pastdmark  
3ed7 ..			.dmark: db "CON"  
3eda f1			.pastdmark: pop af  
3edb			endm  
# End of macro DMARK
3edb						CALLMONITOR 
3edb cd 00 14			call break_point_state  
3ede				endm  
# End of macro CALLMONITOR
3ede					endif 
3ede			 
3ede			 
3ede					FORTH_DSP_VALUE 
3ede cd 11 1a			call macro_forth_dsp_value 
3ee1				endm 
# End of macro FORTH_DSP_VALUE
3ee1 e5					push hl   ; s2 
3ee2			 
3ee2					FORTH_DSP_POP 
3ee2 cd c4 1a			call macro_forth_dsp_pop 
3ee5				endm 
# End of macro FORTH_DSP_POP
3ee5			 
3ee5					FORTH_DSP_VALUE 
3ee5 cd 11 1a			call macro_forth_dsp_value 
3ee8				endm 
# End of macro FORTH_DSP_VALUE
3ee8			 
3ee8 e5					push hl   ; s1 
3ee9			 
3ee9					FORTH_DSP_POP 
3ee9 cd c4 1a			call macro_forth_dsp_pop 
3eec				endm 
# End of macro FORTH_DSP_POP
3eec					 
3eec			 
3eec					; copy s1 
3eec			 
3eec				 
3eec					; save ptr 
3eec e1					pop hl  
3eed e5					push hl 
3eee 3e 00				ld a, 0 
3ef0 cd 7b 10				call strlent 
3ef3					;inc hl    ; zer0 
3ef3 06 00				ld b, 0 
3ef5 4d					ld c, l 
3ef6 e1					pop hl		 
3ef7 11 32 ee				ld de, scratch	 
3efa					if DEBUG_FORTH_WORDS 
3efa						DMARK "CO1" 
3efa f5				push af  
3efb 3a 0f 3f			ld a, (.dmark)  
3efe 32 77 fb			ld (debug_mark),a  
3f01 3a 10 3f			ld a, (.dmark+1)  
3f04 32 78 fb			ld (debug_mark+1),a  
3f07 3a 11 3f			ld a, (.dmark+2)  
3f0a 32 79 fb			ld (debug_mark+2),a  
3f0d 18 03			jr .pastdmark  
3f0f ..			.dmark: db "CO1"  
3f12 f1			.pastdmark: pop af  
3f13			endm  
# End of macro DMARK
3f13						CALLMONITOR 
3f13 cd 00 14			call break_point_state  
3f16				endm  
# End of macro CALLMONITOR
3f16					endif 
3f16 ed b0				ldir 
3f18			 
3f18 e1					pop hl 
3f19 e5					push hl 
3f1a d5					push de 
3f1b			 
3f1b			 
3f1b 3e 00				ld a, 0 
3f1d cd 7b 10				call strlent 
3f20 23					inc hl    ; zer0 
3f21 23					inc hl 
3f22 06 00				ld b, 0 
3f24 4d					ld c, l 
3f25 d1					pop de 
3f26 e1					pop hl		 
3f27					if DEBUG_FORTH_WORDS 
3f27						DMARK "CO2" 
3f27 f5				push af  
3f28 3a 3c 3f			ld a, (.dmark)  
3f2b 32 77 fb			ld (debug_mark),a  
3f2e 3a 3d 3f			ld a, (.dmark+1)  
3f31 32 78 fb			ld (debug_mark+1),a  
3f34 3a 3e 3f			ld a, (.dmark+2)  
3f37 32 79 fb			ld (debug_mark+2),a  
3f3a 18 03			jr .pastdmark  
3f3c ..			.dmark: db "CO2"  
3f3f f1			.pastdmark: pop af  
3f40			endm  
# End of macro DMARK
3f40						CALLMONITOR 
3f40 cd 00 14			call break_point_state  
3f43				endm  
# End of macro CALLMONITOR
3f43					endif 
3f43 ed b0				ldir 
3f45			 
3f45			 
3f45			 
3f45 21 32 ee				ld hl, scratch 
3f48					if DEBUG_FORTH_WORDS 
3f48						DMARK "CO5" 
3f48 f5				push af  
3f49 3a 5d 3f			ld a, (.dmark)  
3f4c 32 77 fb			ld (debug_mark),a  
3f4f 3a 5e 3f			ld a, (.dmark+1)  
3f52 32 78 fb			ld (debug_mark+1),a  
3f55 3a 5f 3f			ld a, (.dmark+2)  
3f58 32 79 fb			ld (debug_mark+2),a  
3f5b 18 03			jr .pastdmark  
3f5d ..			.dmark: db "CO5"  
3f60 f1			.pastdmark: pop af  
3f61			endm  
# End of macro DMARK
3f61						CALLMONITOR 
3f61 cd 00 14			call break_point_state  
3f64				endm  
# End of macro CALLMONITOR
3f64					endif 
3f64			 
3f64 cd 9f 19				call forth_push_str 
3f67			 
3f67			 
3f67			 
3f67			 
3f67				       NEXTW 
3f67 c3 7e 1b			jp macro_next 
3f6a				endm 
# End of macro NEXTW
3f6a			 
3f6a			 
3f6a			.FIND: 
3f6a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3f6a 4b				db WORD_SYS_CORE+55             
3f6b 28 40			dw .LEN            
3f6d 05				db 4 + 1 
3f6e .. 00			db "FIND",0              
3f73				endm 
# End of macro CWHEAD
3f73			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3f73			 
3f73					if DEBUG_FORTH_WORDS_KEY 
3f73						DMARK "FND" 
3f73 f5				push af  
3f74 3a 88 3f			ld a, (.dmark)  
3f77 32 77 fb			ld (debug_mark),a  
3f7a 3a 89 3f			ld a, (.dmark+1)  
3f7d 32 78 fb			ld (debug_mark+1),a  
3f80 3a 8a 3f			ld a, (.dmark+2)  
3f83 32 79 fb			ld (debug_mark+2),a  
3f86 18 03			jr .pastdmark  
3f88 ..			.dmark: db "FND"  
3f8b f1			.pastdmark: pop af  
3f8c			endm  
# End of macro DMARK
3f8c						CALLMONITOR 
3f8c cd 00 14			call break_point_state  
3f8f				endm  
# End of macro CALLMONITOR
3f8f					endif 
3f8f			 
3f8f			; TODO check string type 
3f8f					FORTH_DSP_VALUE 
3f8f cd 11 1a			call macro_forth_dsp_value 
3f92				endm 
# End of macro FORTH_DSP_VALUE
3f92			 
3f92 e5					push hl    
3f93 7e					ld a,(hl)    ; char to find   
3f94			; TODO change char to substr 
3f94			 
3f94 f5					push af 
3f95					 
3f95			 
3f95			 
3f95					if DEBUG_FORTH_WORDS 
3f95						DMARK "FN1" 
3f95 f5				push af  
3f96 3a aa 3f			ld a, (.dmark)  
3f99 32 77 fb			ld (debug_mark),a  
3f9c 3a ab 3f			ld a, (.dmark+1)  
3f9f 32 78 fb			ld (debug_mark+1),a  
3fa2 3a ac 3f			ld a, (.dmark+2)  
3fa5 32 79 fb			ld (debug_mark+2),a  
3fa8 18 03			jr .pastdmark  
3faa ..			.dmark: db "FN1"  
3fad f1			.pastdmark: pop af  
3fae			endm  
# End of macro DMARK
3fae						CALLMONITOR 
3fae cd 00 14			call break_point_state  
3fb1				endm  
# End of macro CALLMONITOR
3fb1					endif 
3fb1			 
3fb1					FORTH_DSP_POP 
3fb1 cd c4 1a			call macro_forth_dsp_pop 
3fb4				endm 
# End of macro FORTH_DSP_POP
3fb4			 
3fb4					; string to search 
3fb4			 
3fb4					FORTH_DSP_VALUE 
3fb4 cd 11 1a			call macro_forth_dsp_value 
3fb7				endm 
# End of macro FORTH_DSP_VALUE
3fb7			 
3fb7 d1					pop de  ; d is char to find  
3fb8			 
3fb8					if DEBUG_FORTH_WORDS 
3fb8						DMARK "FN2" 
3fb8 f5				push af  
3fb9 3a cd 3f			ld a, (.dmark)  
3fbc 32 77 fb			ld (debug_mark),a  
3fbf 3a ce 3f			ld a, (.dmark+1)  
3fc2 32 78 fb			ld (debug_mark+1),a  
3fc5 3a cf 3f			ld a, (.dmark+2)  
3fc8 32 79 fb			ld (debug_mark+2),a  
3fcb 18 03			jr .pastdmark  
3fcd ..			.dmark: db "FN2"  
3fd0 f1			.pastdmark: pop af  
3fd1			endm  
# End of macro DMARK
3fd1						CALLMONITOR 
3fd1 cd 00 14			call break_point_state  
3fd4				endm  
# End of macro CALLMONITOR
3fd4					endif 
3fd4					 
3fd4 01 00 00				ld bc, 0 
3fd7 7e			.findchar:      ld a,(hl) 
3fd8 fe 00				cp 0   		 
3fda 28 27				jr z, .finddone     
3fdc ba					cp d 
3fdd 28 20				jr z, .foundchar 
3fdf 03					inc bc 
3fe0 23					inc hl 
3fe1					if DEBUG_FORTH_WORDS 
3fe1						DMARK "FN3" 
3fe1 f5				push af  
3fe2 3a f6 3f			ld a, (.dmark)  
3fe5 32 77 fb			ld (debug_mark),a  
3fe8 3a f7 3f			ld a, (.dmark+1)  
3feb 32 78 fb			ld (debug_mark+1),a  
3fee 3a f8 3f			ld a, (.dmark+2)  
3ff1 32 79 fb			ld (debug_mark+2),a  
3ff4 18 03			jr .pastdmark  
3ff6 ..			.dmark: db "FN3"  
3ff9 f1			.pastdmark: pop af  
3ffa			endm  
# End of macro DMARK
3ffa						CALLMONITOR 
3ffa cd 00 14			call break_point_state  
3ffd				endm  
# End of macro CALLMONITOR
3ffd					endif 
3ffd 18 d8				jr .findchar 
3fff			 
3fff			 
3fff c5			.foundchar:	push bc 
4000 e1					pop hl 
4001 18 03				jr .findexit 
4003			 
4003			 
4003							 
4003			 
4003			.finddone:     ; got to end of string with no find 
4003 21 00 00				ld hl, 0 
4006			.findexit: 
4006			 
4006					if DEBUG_FORTH_WORDS 
4006						DMARK "FNd" 
4006 f5				push af  
4007 3a 1b 40			ld a, (.dmark)  
400a 32 77 fb			ld (debug_mark),a  
400d 3a 1c 40			ld a, (.dmark+1)  
4010 32 78 fb			ld (debug_mark+1),a  
4013 3a 1d 40			ld a, (.dmark+2)  
4016 32 79 fb			ld (debug_mark+2),a  
4019 18 03			jr .pastdmark  
401b ..			.dmark: db "FNd"  
401e f1			.pastdmark: pop af  
401f			endm  
# End of macro DMARK
401f						CALLMONITOR 
401f cd 00 14			call break_point_state  
4022				endm  
# End of macro CALLMONITOR
4022					endif 
4022 cd 8d 19			call forth_push_numhl 
4025			 
4025				       NEXTW 
4025 c3 7e 1b			jp macro_next 
4028				endm 
# End of macro NEXTW
4028			 
4028			.LEN: 
4028				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4028 4c				db WORD_SYS_CORE+56             
4029 5d 40			dw .CHAR            
402b 06				db 5 + 1 
402c .. 00			db "COUNT",0              
4032				endm 
# End of macro CWHEAD
4032			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4032			 
4032					if DEBUG_FORTH_WORDS_KEY 
4032						DMARK "CNT" 
4032 f5				push af  
4033 3a 47 40			ld a, (.dmark)  
4036 32 77 fb			ld (debug_mark),a  
4039 3a 48 40			ld a, (.dmark+1)  
403c 32 78 fb			ld (debug_mark+1),a  
403f 3a 49 40			ld a, (.dmark+2)  
4042 32 79 fb			ld (debug_mark+2),a  
4045 18 03			jr .pastdmark  
4047 ..			.dmark: db "CNT"  
404a f1			.pastdmark: pop af  
404b			endm  
# End of macro DMARK
404b						CALLMONITOR 
404b cd 00 14			call break_point_state  
404e				endm  
# End of macro CALLMONITOR
404e					endif 
404e			; TODO check string type 
404e					FORTH_DSP 
404e cd 0d 1a			call macro_forth_dsp 
4051				endm 
# End of macro FORTH_DSP
4051					;v5FORTH_DSP_VALUE 
4051			 
4051 23					inc hl 
4052			 
4052 3e 00				ld a, 0 
4054 cd 7b 10				call strlent 
4057			 
4057 cd 8d 19				call forth_push_numhl 
405a			 
405a			 
405a			 
405a				       NEXTW 
405a c3 7e 1b			jp macro_next 
405d				endm 
# End of macro NEXTW
405d			.CHAR: 
405d				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
405d 4d				db WORD_SYS_CORE+57             
405e 93 40			dw .ENDSTR            
4060 05				db 4 + 1 
4061 .. 00			db "CHAR",0              
4066				endm 
# End of macro CWHEAD
4066			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4066					if DEBUG_FORTH_WORDS_KEY 
4066						DMARK "CHR" 
4066 f5				push af  
4067 3a 7b 40			ld a, (.dmark)  
406a 32 77 fb			ld (debug_mark),a  
406d 3a 7c 40			ld a, (.dmark+1)  
4070 32 78 fb			ld (debug_mark+1),a  
4073 3a 7d 40			ld a, (.dmark+2)  
4076 32 79 fb			ld (debug_mark+2),a  
4079 18 03			jr .pastdmark  
407b ..			.dmark: db "CHR"  
407e f1			.pastdmark: pop af  
407f			endm  
# End of macro DMARK
407f						CALLMONITOR 
407f cd 00 14			call break_point_state  
4082				endm  
# End of macro CALLMONITOR
4082					endif 
4082					FORTH_DSP 
4082 cd 0d 1a			call macro_forth_dsp 
4085				endm 
# End of macro FORTH_DSP
4085					;v5 FORTH_DSP_VALUE 
4085 23					inc hl      ; now at start of numeric as string 
4086			 
4086			;		push hl 
4086			 
4086					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4086 cd c4 1a			call macro_forth_dsp_pop 
4089				endm 
# End of macro FORTH_DSP_POP
4089			 
4089			;		pop hl 
4089			 
4089					; push the content of a onto the stack as a value 
4089			 
4089 7e					ld a,(hl)   ; get char 
408a 26 00				ld h,0 
408c 6f					ld l,a 
408d cd 8d 19				call forth_push_numhl 
4090			 
4090				       NEXTW 
4090 c3 7e 1b			jp macro_next 
4093				endm 
# End of macro NEXTW
4093			 
4093			 
4093			 
4093			 
4093			.ENDSTR: 
4093			; eof 
4093			 
# End of file forth_words_str.asm
4093			include "forth_words_key.asm" 
4093			 
4093			; | ## Keyboard Words 
4093			 
4093			.KEY: 
4093				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4093 3e				db WORD_SYS_CORE+42             
4094 c3 40			dw .WAITK            
4096 04				db 3 + 1 
4097 .. 00			db "KEY",0              
409b				endm 
# End of macro CWHEAD
409b			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
409b			 
409b					if DEBUG_FORTH_WORDS_KEY 
409b						DMARK "KEY" 
409b f5				push af  
409c 3a b0 40			ld a, (.dmark)  
409f 32 77 fb			ld (debug_mark),a  
40a2 3a b1 40			ld a, (.dmark+1)  
40a5 32 78 fb			ld (debug_mark+1),a  
40a8 3a b2 40			ld a, (.dmark+2)  
40ab 32 79 fb			ld (debug_mark+2),a  
40ae 18 03			jr .pastdmark  
40b0 ..			.dmark: db "KEY"  
40b3 f1			.pastdmark: pop af  
40b4			endm  
# End of macro DMARK
40b4						CALLMONITOR 
40b4 cd 00 14			call break_point_state  
40b7				endm  
# End of macro CALLMONITOR
40b7					endif 
40b7			; TODO currently waits 
40b7 cd f9 64				call cin 
40ba					;call cin_wait 
40ba 6f					ld l, a 
40bb 26 00				ld h, 0 
40bd cd 8d 19				call forth_push_numhl 
40c0					NEXTW 
40c0 c3 7e 1b			jp macro_next 
40c3				endm 
# End of macro NEXTW
40c3			.WAITK: 
40c3				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
40c3 3f				db WORD_SYS_CORE+43             
40c4 f5 40			dw .ACCEPT            
40c6 06				db 5 + 1 
40c7 .. 00			db "WAITK",0              
40cd				endm 
# End of macro CWHEAD
40cd			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
40cd					if DEBUG_FORTH_WORDS_KEY 
40cd						DMARK "WAI" 
40cd f5				push af  
40ce 3a e2 40			ld a, (.dmark)  
40d1 32 77 fb			ld (debug_mark),a  
40d4 3a e3 40			ld a, (.dmark+1)  
40d7 32 78 fb			ld (debug_mark+1),a  
40da 3a e4 40			ld a, (.dmark+2)  
40dd 32 79 fb			ld (debug_mark+2),a  
40e0 18 03			jr .pastdmark  
40e2 ..			.dmark: db "WAI"  
40e5 f1			.pastdmark: pop af  
40e6			endm  
# End of macro DMARK
40e6						CALLMONITOR 
40e6 cd 00 14			call break_point_state  
40e9				endm  
# End of macro CALLMONITOR
40e9					endif 
40e9 cd e8 64				call cin_wait 
40ec 6f					ld l, a 
40ed 26 00				ld h, 0 
40ef cd 8d 19				call forth_push_numhl 
40f2					NEXTW 
40f2 c3 7e 1b			jp macro_next 
40f5				endm 
# End of macro NEXTW
40f5			.ACCEPT: 
40f5				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
40f5 40				db WORD_SYS_CORE+44             
40f6 53 41			dw .EDIT            
40f8 07				db 6 + 1 
40f9 .. 00			db "ACCEPT",0              
4100				endm 
# End of macro CWHEAD
4100			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4100					; TODO crashes on push 
4100					if DEBUG_FORTH_WORDS_KEY 
4100						DMARK "ACC" 
4100 f5				push af  
4101 3a 15 41			ld a, (.dmark)  
4104 32 77 fb			ld (debug_mark),a  
4107 3a 16 41			ld a, (.dmark+1)  
410a 32 78 fb			ld (debug_mark+1),a  
410d 3a 17 41			ld a, (.dmark+2)  
4110 32 79 fb			ld (debug_mark+2),a  
4113 18 03			jr .pastdmark  
4115 ..			.dmark: db "ACC"  
4118 f1			.pastdmark: pop af  
4119			endm  
# End of macro DMARK
4119						CALLMONITOR 
4119 cd 00 14			call break_point_state  
411c				endm  
# End of macro CALLMONITOR
411c					endif 
411c 21 30 f0				ld hl, os_input 
411f 3e 00				ld a, 0 
4121 77					ld (hl),a 
4122 3a 5b f8				ld a,(f_cursor_ptr) 
4125 16 64				ld d, 100 
4127 0e 00				ld c, 0 
4129 1e 28				ld e, 40 
412b cd 3f 0c				call input_str 
412e					; TODO perhaps do a type check and wrap in quotes if not a number 
412e 21 30 f0				ld hl, os_input 
4131					if DEBUG_FORTH_WORDS 
4131						DMARK "AC1" 
4131 f5				push af  
4132 3a 46 41			ld a, (.dmark)  
4135 32 77 fb			ld (debug_mark),a  
4138 3a 47 41			ld a, (.dmark+1)  
413b 32 78 fb			ld (debug_mark+1),a  
413e 3a 48 41			ld a, (.dmark+2)  
4141 32 79 fb			ld (debug_mark+2),a  
4144 18 03			jr .pastdmark  
4146 ..			.dmark: db "AC1"  
4149 f1			.pastdmark: pop af  
414a			endm  
# End of macro DMARK
414a						CALLMONITOR 
414a cd 00 14			call break_point_state  
414d				endm  
# End of macro CALLMONITOR
414d					endif 
414d cd 9f 19				call forth_push_str 
4150					NEXTW 
4150 c3 7e 1b			jp macro_next 
4153				endm 
# End of macro NEXTW
4153			 
4153			.EDIT: 
4153				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4153 40				db WORD_SYS_CORE+44             
4154 dc 41			dw .ENDKEY            
4156 05				db 4 + 1 
4157 .. 00			db "EDIT",0              
415c				endm 
# End of macro CWHEAD
415c			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
415c			 
415c					; TODO does not copy from stack 
415c					if DEBUG_FORTH_WORDS_KEY 
415c						DMARK "EDT" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 77 fb			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 78 fb			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 79 fb			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "EDT"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175						CALLMONITOR 
4175 cd 00 14			call break_point_state  
4178				endm  
# End of macro CALLMONITOR
4178					endif 
4178			 
4178					FORTH_DSP 
4178 cd 0d 1a			call macro_forth_dsp 
417b				endm 
# End of macro FORTH_DSP
417b					;v5 FORTH_DSP_VALUE 
417b 23					inc hl    ; TODO do type check 
417c			 
417c e5					push hl 
417d 3e 00				ld a, 0 
417f cd 7b 10				call strlent 
4182 23					inc hl 
4183			 
4183 06 00				ld b, 0 
4185 4d					ld c, l 
4186			 
4186 e1					pop hl 
4187 11 30 f0				ld de, os_input 
418a					if DEBUG_FORTH_WORDS_KEY 
418a						DMARK "EDc" 
418a f5				push af  
418b 3a 9f 41			ld a, (.dmark)  
418e 32 77 fb			ld (debug_mark),a  
4191 3a a0 41			ld a, (.dmark+1)  
4194 32 78 fb			ld (debug_mark+1),a  
4197 3a a1 41			ld a, (.dmark+2)  
419a 32 79 fb			ld (debug_mark+2),a  
419d 18 03			jr .pastdmark  
419f ..			.dmark: db "EDc"  
41a2 f1			.pastdmark: pop af  
41a3			endm  
# End of macro DMARK
41a3						CALLMONITOR 
41a3 cd 00 14			call break_point_state  
41a6				endm  
# End of macro CALLMONITOR
41a6					endif 
41a6 ed b0				ldir 
41a8			 
41a8			 
41a8 21 30 f0				ld hl, os_input 
41ab					;ld a, 0 
41ab					;ld (hl),a 
41ab 3a 5b f8				ld a,(f_cursor_ptr) 
41ae 16 64				ld d, 100 
41b0 0e 00				ld c, 0 
41b2 1e 28				ld e, 40 
41b4 cd 3f 0c				call input_str 
41b7					; TODO perhaps do a type check and wrap in quotes if not a number 
41b7 21 30 f0				ld hl, os_input 
41ba					if DEBUG_FORTH_WORDS 
41ba						DMARK "ED1" 
41ba f5				push af  
41bb 3a cf 41			ld a, (.dmark)  
41be 32 77 fb			ld (debug_mark),a  
41c1 3a d0 41			ld a, (.dmark+1)  
41c4 32 78 fb			ld (debug_mark+1),a  
41c7 3a d1 41			ld a, (.dmark+2)  
41ca 32 79 fb			ld (debug_mark+2),a  
41cd 18 03			jr .pastdmark  
41cf ..			.dmark: db "ED1"  
41d2 f1			.pastdmark: pop af  
41d3			endm  
# End of macro DMARK
41d3						CALLMONITOR 
41d3 cd 00 14			call break_point_state  
41d6				endm  
# End of macro CALLMONITOR
41d6					endif 
41d6 cd 9f 19				call forth_push_str 
41d9					NEXTW 
41d9 c3 7e 1b			jp macro_next 
41dc				endm 
# End of macro NEXTW
41dc			 
41dc			 
41dc			 
41dc			.ENDKEY: 
41dc			; eof 
41dc			 
# End of file forth_words_key.asm
41dc			 
41dc			if STORAGE_SE 
41dc			   	include "forth_words_storage.asm" 
41dc			 
41dc			; | ## Fixed Storage Words 
41dc			 
41dc			 
41dc			.BREAD: 
41dc			  
41dc				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
41dc 3a				db WORD_SYS_CORE+38             
41dd 55 42			dw .BWRITE            
41df 06				db 5 + 1 
41e0 .. 00			db "BREAD",0              
41e6				endm 
# End of macro CWHEAD
41e6			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
41e6				 
41e6					if DEBUG_FORTH_WORDS_KEY 
41e6						DMARK "BRD" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 77 fb			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 78 fb			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 79 fb			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "BRD"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff						CALLMONITOR 
41ff cd 00 14			call break_point_state  
4202				endm  
# End of macro CALLMONITOR
4202					endif 
4202			 
4202				FORTH_DSP_VALUEHL 
4202 cd 28 1a			call macro_dsp_valuehl 
4205				endm 
# End of macro FORTH_DSP_VALUEHL
4205			 
4205				FORTH_DSP_POP 
4205 cd c4 1a			call macro_forth_dsp_pop 
4208				endm 
# End of macro FORTH_DSP_POP
4208			 
4208				; calc block address 
4208			 
4208 eb				ex de, hl 
4209 3e 40			ld a, STORE_BLOCK_PHY 
420b cd 95 0b			call Mult16 
420e			 
420e			 
420e 11 62 f8			ld de, store_page 
4211			 
4211					if DEBUG_FORTH_WORDS 
4211						DMARK "BR1" 
4211 f5				push af  
4212 3a 26 42			ld a, (.dmark)  
4215 32 77 fb			ld (debug_mark),a  
4218 3a 27 42			ld a, (.dmark+1)  
421b 32 78 fb			ld (debug_mark+1),a  
421e 3a 28 42			ld a, (.dmark+2)  
4221 32 79 fb			ld (debug_mark+2),a  
4224 18 03			jr .pastdmark  
4226 ..			.dmark: db "BR1"  
4229 f1			.pastdmark: pop af  
422a			endm  
# End of macro DMARK
422a						CALLMONITOR 
422a cd 00 14			call break_point_state  
422d				endm  
# End of macro CALLMONITOR
422d					endif 
422d			 
422d cd 0c 03			call storage_read_block 
4230			 
4230 21 64 f8		        ld hl, store_page+2 
4233					if DEBUG_FORTH_WORDS 
4233						DMARK "BR2" 
4233 f5				push af  
4234 3a 48 42			ld a, (.dmark)  
4237 32 77 fb			ld (debug_mark),a  
423a 3a 49 42			ld a, (.dmark+1)  
423d 32 78 fb			ld (debug_mark+1),a  
4240 3a 4a 42			ld a, (.dmark+2)  
4243 32 79 fb			ld (debug_mark+2),a  
4246 18 03			jr .pastdmark  
4248 ..			.dmark: db "BR2"  
424b f1			.pastdmark: pop af  
424c			endm  
# End of macro DMARK
424c						CALLMONITOR 
424c cd 00 14			call break_point_state  
424f				endm  
# End of macro CALLMONITOR
424f					endif 
424f cd 9f 19			call forth_push_str 
4252			 
4252			 
4252					NEXTW 
4252 c3 7e 1b			jp macro_next 
4255				endm 
# End of macro NEXTW
4255			.BWRITE: 
4255				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4255 3a				db WORD_SYS_CORE+38             
4256 ea 42			dw .BUPD            
4258 07				db 6 + 1 
4259 .. 00			db "BWRITE",0              
4260				endm 
# End of macro CWHEAD
4260			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
4260			 
4260					if DEBUG_FORTH_WORDS_KEY 
4260						DMARK "BWR" 
4260 f5				push af  
4261 3a 75 42			ld a, (.dmark)  
4264 32 77 fb			ld (debug_mark),a  
4267 3a 76 42			ld a, (.dmark+1)  
426a 32 78 fb			ld (debug_mark+1),a  
426d 3a 77 42			ld a, (.dmark+2)  
4270 32 79 fb			ld (debug_mark+2),a  
4273 18 03			jr .pastdmark  
4275 ..			.dmark: db "BWR"  
4278 f1			.pastdmark: pop af  
4279			endm  
# End of macro DMARK
4279						CALLMONITOR 
4279 cd 00 14			call break_point_state  
427c				endm  
# End of macro CALLMONITOR
427c					endif 
427c			 
427c				FORTH_DSP_VALUEHL 
427c cd 28 1a			call macro_dsp_valuehl 
427f				endm 
# End of macro FORTH_DSP_VALUEHL
427f			 
427f				; calc block address 
427f			 
427f eb				ex de, hl 
4280 3e 40			ld a, STORE_BLOCK_PHY 
4282 cd 95 0b			call Mult16 
4285			 
4285 e5				push hl         ; address 
4286			 
4286				FORTH_DSP_POP 
4286 cd c4 1a			call macro_forth_dsp_pop 
4289				endm 
# End of macro FORTH_DSP_POP
4289			 
4289				FORTH_DSP_VALUEHL 
4289 cd 28 1a			call macro_dsp_valuehl 
428c				endm 
# End of macro FORTH_DSP_VALUEHL
428c			 
428c				FORTH_DSP_POP 
428c cd c4 1a			call macro_forth_dsp_pop 
428f				endm 
# End of macro FORTH_DSP_POP
428f			 
428f cd 0d 0a			call storage_clear_page 
4292			 
4292				; copy string to store page 
4292			 
4292 e5				push hl     ; save string address 
4293			 
4293 3e 00			ld a, 0 
4295 cd 7b 10			call strlent 
4298			 
4298 23				inc hl 
4299			 
4299 4d				ld c, l 
429a 06 00			ld b, 0 
429c			 
429c e1				pop hl 
429d 11 64 f8			ld de, store_page + 2 
42a0					if DEBUG_FORTH_WORDS 
42a0						DMARK "BW1" 
42a0 f5				push af  
42a1 3a b5 42			ld a, (.dmark)  
42a4 32 77 fb			ld (debug_mark),a  
42a7 3a b6 42			ld a, (.dmark+1)  
42aa 32 78 fb			ld (debug_mark+1),a  
42ad 3a b7 42			ld a, (.dmark+2)  
42b0 32 79 fb			ld (debug_mark+2),a  
42b3 18 03			jr .pastdmark  
42b5 ..			.dmark: db "BW1"  
42b8 f1			.pastdmark: pop af  
42b9			endm  
# End of macro DMARK
42b9						CALLMONITOR 
42b9 cd 00 14			call break_point_state  
42bc				endm  
# End of macro CALLMONITOR
42bc					endif 
42bc ed b0			ldir 
42be			 
42be			 
42be				; poke the start of the block with flags to prevent high level file ops hitting the block 
42be			 
42be 21 ff ff			ld hl, $ffff 
42c1			 
42c1 22 62 f8			ld (store_page), hl	 
42c4				 
42c4 e1				pop hl    ; get address 
42c5 11 62 f8			ld de, store_page 
42c8			 
42c8					if DEBUG_FORTH_WORDS 
42c8						DMARK "BW2" 
42c8 f5				push af  
42c9 3a dd 42			ld a, (.dmark)  
42cc 32 77 fb			ld (debug_mark),a  
42cf 3a de 42			ld a, (.dmark+1)  
42d2 32 78 fb			ld (debug_mark+1),a  
42d5 3a df 42			ld a, (.dmark+2)  
42d8 32 79 fb			ld (debug_mark+2),a  
42db 18 03			jr .pastdmark  
42dd ..			.dmark: db "BW2"  
42e0 f1			.pastdmark: pop af  
42e1			endm  
# End of macro DMARK
42e1						CALLMONITOR 
42e1 cd 00 14			call break_point_state  
42e4				endm  
# End of macro CALLMONITOR
42e4					endif 
42e4			 
42e4 cd 71 03			call storage_write_block 
42e7			 
42e7					NEXTW 
42e7 c3 7e 1b			jp macro_next 
42ea				endm 
# End of macro NEXTW
42ea			 
42ea			.BUPD: 
42ea				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
42ea 3a				db WORD_SYS_CORE+38             
42eb 40 43			dw .BYID            
42ed 05				db 4 + 1 
42ee .. 00			db "BUPD",0              
42f3				endm 
# End of macro CWHEAD
42f3			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
42f3			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
42f3			; | | or completely different file system structure. 
42f3			 
42f3					if DEBUG_FORTH_WORDS_KEY 
42f3						DMARK "BUD" 
42f3 f5				push af  
42f4 3a 08 43			ld a, (.dmark)  
42f7 32 77 fb			ld (debug_mark),a  
42fa 3a 09 43			ld a, (.dmark+1)  
42fd 32 78 fb			ld (debug_mark+1),a  
4300 3a 0a 43			ld a, (.dmark+2)  
4303 32 79 fb			ld (debug_mark+2),a  
4306 18 03			jr .pastdmark  
4308 ..			.dmark: db "BUD"  
430b f1			.pastdmark: pop af  
430c			endm  
# End of macro DMARK
430c						CALLMONITOR 
430c cd 00 14			call break_point_state  
430f				endm  
# End of macro CALLMONITOR
430f					endif 
430f			 
430f				FORTH_DSP_VALUEHL 
430f cd 28 1a			call macro_dsp_valuehl 
4312				endm 
# End of macro FORTH_DSP_VALUEHL
4312			 
4312				; calc block address 
4312			 
4312 eb				ex de, hl 
4313 3e 40			ld a, STORE_BLOCK_PHY 
4315 cd 95 0b			call Mult16 
4318			 
4318				FORTH_DSP_POP 
4318 cd c4 1a			call macro_forth_dsp_pop 
431b				endm 
# End of macro FORTH_DSP_POP
431b			 
431b			 
431b 11 62 f8			ld de, store_page 
431e			 
431e					if DEBUG_FORTH_WORDS 
431e						DMARK "BUe" 
431e f5				push af  
431f 3a 33 43			ld a, (.dmark)  
4322 32 77 fb			ld (debug_mark),a  
4325 3a 34 43			ld a, (.dmark+1)  
4328 32 78 fb			ld (debug_mark+1),a  
432b 3a 35 43			ld a, (.dmark+2)  
432e 32 79 fb			ld (debug_mark+2),a  
4331 18 03			jr .pastdmark  
4333 ..			.dmark: db "BUe"  
4336 f1			.pastdmark: pop af  
4337			endm  
# End of macro DMARK
4337						CALLMONITOR 
4337 cd 00 14			call break_point_state  
433a				endm  
# End of macro CALLMONITOR
433a					endif 
433a			 
433a cd 71 03			call storage_write_block 
433d			 
433d					NEXTW 
433d c3 7e 1b			jp macro_next 
4340				endm 
# End of macro NEXTW
4340			 
4340			.BYID: 
4340				CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4340 3a				db WORD_SYS_CORE+38             
4341 4c 43			dw .BYNAME            
4343 05				db 4 + 1 
4344 .. 00			db "BYID",0              
4349				endm 
# End of macro CWHEAD
4349			; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
4349					NEXTW 
4349 c3 7e 1b			jp macro_next 
434c				endm 
# End of macro NEXTW
434c			.BYNAME: 
434c				CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
434c 3a				db WORD_SYS_CORE+38             
434d 5a 43			dw .DIR            
434f 07				db 6 + 1 
4350 .. 00			db "BYNAME",0              
4357				endm 
# End of macro CWHEAD
4357			; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
4357					NEXTW 
4357 c3 7e 1b			jp macro_next 
435a				endm 
# End of macro NEXTW
435a			 
435a			.DIR: 
435a				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
435a 3a				db WORD_SYS_CORE+38             
435b 5e 44			dw .SAVE            
435d 04				db 3 + 1 
435e .. 00			db "DIR",0              
4362				endm 
# End of macro CWHEAD
4362			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4362			 
4362					if DEBUG_FORTH_WORDS_KEY 
4362						DMARK "DIR" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 77 fb			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 78 fb			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 79 fb			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "DIR"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd 00 14			call break_point_state  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e cd bd 03			call storage_get_block_0 
4381			 
4381 21 62 f8			ld hl, store_page     ; get current id count 
4384 46				ld b, (hl) 
4385 0e 00			ld c, 0    ; count of files   
4387					if DEBUG_FORTH_WORDS 
4387						DMARK "DI1" 
4387 f5				push af  
4388 3a 9c 43			ld a, (.dmark)  
438b 32 77 fb			ld (debug_mark),a  
438e 3a 9d 43			ld a, (.dmark+1)  
4391 32 78 fb			ld (debug_mark+1),a  
4394 3a 9e 43			ld a, (.dmark+2)  
4397 32 79 fb			ld (debug_mark+2),a  
439a 18 03			jr .pastdmark  
439c ..			.dmark: db "DI1"  
439f f1			.pastdmark: pop af  
43a0			endm  
# End of macro DMARK
43a0						CALLMONITOR 
43a0 cd 00 14			call break_point_state  
43a3				endm  
# End of macro CALLMONITOR
43a3					endif 
43a3			 
43a3				; check for empty drive 
43a3			 
43a3 3e 00			ld a, 0 
43a5 b8				cp b 
43a6 ca 14 44			jp z, .dirdone 
43a9			 
43a9				; for each of the current ids do a search for them and if found push to stack 
43a9			 
43a9 c5			.diritem:	push bc 
43aa 21 40 00				ld hl, STORE_BLOCK_PHY 
43ad 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
43af 58					ld e,b 
43b0			 
43b0			;		if DEBUG_FORTH_WORDS 
43b0			;			DMARK "DI2" 
43b0			;			CALLMONITOR 
43b0			;		endif 
43b0			 
43b0 cd 22 06				call storage_findnextid 
43b3			 
43b3			;		if DEBUG_FORTH_WORDS 
43b3			;			DMARK "DI3" 
43b3			;			CALLMONITOR 
43b3			;		endif 
43b3			 
43b3					; if found hl will be non zero 
43b3			 
43b3 cd 3b 0c				call ishlzero 
43b6			;		ld a, l 
43b6			;		add h 
43b6			; 
43b6			;		cp 0 
43b6 28 59				jr z, .dirnotfound 
43b8			 
43b8					; increase count 
43b8			 
43b8 c1					pop bc	 
43b9 0c					inc c 
43ba c5					push bc 
43bb					 
43bb			 
43bb					; get file header and push the file name 
43bb			 
43bb 11 62 f8				ld de, store_page 
43be cd 0c 03				call storage_read_block 
43c1			 
43c1					; push file id to stack 
43c1				 
43c1 3a 62 f8				ld a, (store_page) 
43c4 26 00				ld h, 0 
43c6 6f					ld l, a 
43c7 cd 8d 19				call forth_push_numhl 
43ca			 
43ca					; push extent count to stack  
43ca				 
43ca 3a 64 f8				ld a, (store_page+2) 
43cd 26 00				ld h, 0 
43cf 6f					ld l, a 
43d0 cd 8d 19				call forth_push_numhl 
43d3			 
43d3					; push file name 
43d3			 
43d3 21 65 f8				ld hl, store_page+3 
43d6					if DEBUG_FORTH_WORDS 
43d6						DMARK "DI5" 
43d6 f5				push af  
43d7 3a eb 43			ld a, (.dmark)  
43da 32 77 fb			ld (debug_mark),a  
43dd 3a ec 43			ld a, (.dmark+1)  
43e0 32 78 fb			ld (debug_mark+1),a  
43e3 3a ed 43			ld a, (.dmark+2)  
43e6 32 79 fb			ld (debug_mark+2),a  
43e9 18 03			jr .pastdmark  
43eb ..			.dmark: db "DI5"  
43ee f1			.pastdmark: pop af  
43ef			endm  
# End of macro DMARK
43ef						CALLMONITOR 
43ef cd 00 14			call break_point_state  
43f2				endm  
# End of macro CALLMONITOR
43f2					endif 
43f2 cd 9f 19				call forth_push_str 
43f5					if DEBUG_FORTH_WORDS 
43f5						DMARK "DI6" 
43f5 f5				push af  
43f6 3a 0a 44			ld a, (.dmark)  
43f9 32 77 fb			ld (debug_mark),a  
43fc 3a 0b 44			ld a, (.dmark+1)  
43ff 32 78 fb			ld (debug_mark+1),a  
4402 3a 0c 44			ld a, (.dmark+2)  
4405 32 79 fb			ld (debug_mark+2),a  
4408 18 03			jr .pastdmark  
440a ..			.dmark: db "DI6"  
440d f1			.pastdmark: pop af  
440e			endm  
# End of macro DMARK
440e						CALLMONITOR 
440e cd 00 14			call break_point_state  
4411				endm  
# End of macro CALLMONITOR
4411					endif 
4411			.dirnotfound: 
4411 c1					pop bc     
4412 10 95				djnz .diritem 
4414				 
4414			.dirdone:	 
4414					if DEBUG_FORTH_WORDS 
4414						DMARK "DI7" 
4414 f5				push af  
4415 3a 29 44			ld a, (.dmark)  
4418 32 77 fb			ld (debug_mark),a  
441b 3a 2a 44			ld a, (.dmark+1)  
441e 32 78 fb			ld (debug_mark+1),a  
4421 3a 2b 44			ld a, (.dmark+2)  
4424 32 79 fb			ld (debug_mark+2),a  
4427 18 03			jr .pastdmark  
4429 ..			.dmark: db "DI7"  
442c f1			.pastdmark: pop af  
442d			endm  
# End of macro DMARK
442d						CALLMONITOR 
442d cd 00 14			call break_point_state  
4430				endm  
# End of macro CALLMONITOR
4430					endif 
4430			 
4430					; push a count of the dir items found 
4430			 
4430 26 00				ld h, 0 
4432 69					ld l, c 
4433 cd 8d 19				call forth_push_numhl 
4436			 
4436					; push the bank label 
4436			 
4436 cd bd 03				call storage_get_block_0 
4439			 
4439				 
4439 21 65 f8		 		ld hl, store_page+3 
443c			 
443c					if DEBUG_FORTH_WORDS 
443c						DMARK "DI8" 
443c f5				push af  
443d 3a 51 44			ld a, (.dmark)  
4440 32 77 fb			ld (debug_mark),a  
4443 3a 52 44			ld a, (.dmark+1)  
4446 32 78 fb			ld (debug_mark+1),a  
4449 3a 53 44			ld a, (.dmark+2)  
444c 32 79 fb			ld (debug_mark+2),a  
444f 18 03			jr .pastdmark  
4451 ..			.dmark: db "DI8"  
4454 f1			.pastdmark: pop af  
4455			endm  
# End of macro DMARK
4455						CALLMONITOR 
4455 cd 00 14			call break_point_state  
4458				endm  
# End of macro CALLMONITOR
4458					endif 
4458 cd 9f 19				call forth_push_str 
445b			 
445b			 
445b				 
445b					NEXTW 
445b c3 7e 1b			jp macro_next 
445e				endm 
# End of macro NEXTW
445e			.SAVE: 
445e				CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
445e 3b				db WORD_SYS_CORE+39             
445f 6a 44			dw .LOAD            
4461 05				db 4 + 1 
4462 .. 00			db "SAVE",0              
4467				endm 
# End of macro CWHEAD
4467			; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
4467					NEXTW 
4467 c3 7e 1b			jp macro_next 
446a				endm 
# End of macro NEXTW
446a			.LOAD: 
446a				CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
446a 3c				db WORD_SYS_CORE+40             
446b cc 45			dw .BSAVE            
446d 05				db 4 + 1 
446e .. 00			db "LOAD",0              
4473				endm 
# End of macro CWHEAD
4473			; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
4473			; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
4473			; | | The LOAD command can not be used in any user words or compound lines. 
4473			 
4473					; store_openext use it. If zero it is EOF 
4473			 
4473					; read block from current stream id 
4473					; if the block does not contain zero term keep reading blocks until zero found 
4473					; push the block to stack 
4473					; save the block id to stream 
4473			 
4473			 
4473					FORTH_DSP_VALUEHL 
4473 cd 28 1a			call macro_dsp_valuehl 
4476				endm 
# End of macro FORTH_DSP_VALUEHL
4476			 
4476			;		push hl 
4476			 
4476				if DEBUG_STORESE 
4476					DMARK "LOA" 
4476 f5				push af  
4477 3a 8b 44			ld a, (.dmark)  
447a 32 77 fb			ld (debug_mark),a  
447d 3a 8c 44			ld a, (.dmark+1)  
4480 32 78 fb			ld (debug_mark+1),a  
4483 3a 8d 44			ld a, (.dmark+2)  
4486 32 79 fb			ld (debug_mark+2),a  
4489 18 03			jr .pastdmark  
448b ..			.dmark: db "LOA"  
448e f1			.pastdmark: pop af  
448f			endm  
# End of macro DMARK
448f					CALLMONITOR 
448f cd 00 14			call break_point_state  
4492				endm  
# End of macro CALLMONITOR
4492				endif 
4492					FORTH_DSP_POP 
4492 cd c4 1a			call macro_forth_dsp_pop 
4495				endm 
# End of macro FORTH_DSP_POP
4495			 
4495			;		pop hl 
4495			 
4495 65					ld h, l 
4496 2e 00				ld l, 0 
4498			 
4498 e5					push hl     ; stack holds current file id and extent to work with 
4499			 
4499			 
4499 11 62 f8				ld de, store_page      ; get block zero of file 
449c				if DEBUG_STORESE 
449c					DMARK "LO0" 
449c f5				push af  
449d 3a b1 44			ld a, (.dmark)  
44a0 32 77 fb			ld (debug_mark),a  
44a3 3a b2 44			ld a, (.dmark+1)  
44a6 32 78 fb			ld (debug_mark+1),a  
44a9 3a b3 44			ld a, (.dmark+2)  
44ac 32 79 fb			ld (debug_mark+2),a  
44af 18 03			jr .pastdmark  
44b1 ..			.dmark: db "LO0"  
44b4 f1			.pastdmark: pop af  
44b5			endm  
# End of macro DMARK
44b5					CALLMONITOR 
44b5 cd 00 14			call break_point_state  
44b8				endm  
# End of macro CALLMONITOR
44b8				endif 
44b8 cd 46 08				call storage_read 
44bb			 
44bb 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
44be 32 58 f8				ld  (store_openmaxext),a   ; get our limit 
44c1			 
44c1				if DEBUG_STORESE 
44c1					DMARK "LOE" 
44c1 f5				push af  
44c2 3a d6 44			ld a, (.dmark)  
44c5 32 77 fb			ld (debug_mark),a  
44c8 3a d7 44			ld a, (.dmark+1)  
44cb 32 78 fb			ld (debug_mark+1),a  
44ce 3a d8 44			ld a, (.dmark+2)  
44d1 32 79 fb			ld (debug_mark+2),a  
44d4 18 03			jr .pastdmark  
44d6 ..			.dmark: db "LOE"  
44d9 f1			.pastdmark: pop af  
44da			endm  
# End of macro DMARK
44da					CALLMONITOR 
44da cd 00 14			call break_point_state  
44dd				endm  
# End of macro CALLMONITOR
44dd				endif 
44dd			 
44dd			; TODO dont know why max extents are not present 
44dd			;		cp 0 
44dd			;		jp z, .loadeof     ; dont read past eof 
44dd			 
44dd			;		ld a, 1   ; start from the head of the file 
44dd			 
44dd e1			.loadline:	pop hl 
44de 23					inc hl 
44df 3a 58 f8				ld  a, (store_openmaxext)   ; get our limit 
44e2				if DEBUG_STORESE 
44e2					DMARK "LOx" 
44e2 f5				push af  
44e3 3a f7 44			ld a, (.dmark)  
44e6 32 77 fb			ld (debug_mark),a  
44e9 3a f8 44			ld a, (.dmark+1)  
44ec 32 78 fb			ld (debug_mark+1),a  
44ef 3a f9 44			ld a, (.dmark+2)  
44f2 32 79 fb			ld (debug_mark+2),a  
44f5 18 03			jr .pastdmark  
44f7 ..			.dmark: db "LOx"  
44fa f1			.pastdmark: pop af  
44fb			endm  
# End of macro DMARK
44fb					CALLMONITOR 
44fb cd 00 14			call break_point_state  
44fe				endm  
# End of macro CALLMONITOR
44fe				endif 
44fe 3c					inc a 
44ff bd					cp l 
4500 ca aa 45				jp z, .loadeof 
4503 e5					push hl    ; save current extent 
4504			 
4504 11 62 f8				ld de, store_page 
4507			 
4507				if DEBUG_STORESE 
4507					DMARK "LO1" 
4507 f5				push af  
4508 3a 1c 45			ld a, (.dmark)  
450b 32 77 fb			ld (debug_mark),a  
450e 3a 1d 45			ld a, (.dmark+1)  
4511 32 78 fb			ld (debug_mark+1),a  
4514 3a 1e 45			ld a, (.dmark+2)  
4517 32 79 fb			ld (debug_mark+2),a  
451a 18 03			jr .pastdmark  
451c ..			.dmark: db "LO1"  
451f f1			.pastdmark: pop af  
4520			endm  
# End of macro DMARK
4520					CALLMONITOR 
4520 cd 00 14			call break_point_state  
4523				endm  
# End of macro CALLMONITOR
4523				endif 
4523 cd 46 08				call storage_read 
4526			 
4526				if DEBUG_STORESE 
4526					DMARK "LO2" 
4526 f5				push af  
4527 3a 3b 45			ld a, (.dmark)  
452a 32 77 fb			ld (debug_mark),a  
452d 3a 3c 45			ld a, (.dmark+1)  
4530 32 78 fb			ld (debug_mark+1),a  
4533 3a 3d 45			ld a, (.dmark+2)  
4536 32 79 fb			ld (debug_mark+2),a  
4539 18 03			jr .pastdmark  
453b ..			.dmark: db "LO2"  
453e f1			.pastdmark: pop af  
453f			endm  
# End of macro DMARK
453f					CALLMONITOR 
453f cd 00 14			call break_point_state  
4542				endm  
# End of macro CALLMONITOR
4542				endif 
4542 cd 3b 0c			call ishlzero 
4545			;	ld a, l 
4545			;	add h 
4545			;	cp 0 
4545 28 63			jr z, .loadeof 
4547			 
4547				; not eof so hl should point to data to exec 
4547			 
4547				; will need to add the FORTH_END_BUFFER flag 
4547			  
4547 21 64 f8			ld hl, store_page+2 
454a 01 ff 00			ld bc, 255 
454d 3e 00			ld a, 0 
454f ed b1			cpir 
4551				if DEBUG_STORESE 
4551					DMARK "LOt" 
4551 f5				push af  
4552 3a 66 45			ld a, (.dmark)  
4555 32 77 fb			ld (debug_mark),a  
4558 3a 67 45			ld a, (.dmark+1)  
455b 32 78 fb			ld (debug_mark+1),a  
455e 3a 68 45			ld a, (.dmark+2)  
4561 32 79 fb			ld (debug_mark+2),a  
4564 18 03			jr .pastdmark  
4566 ..			.dmark: db "LOt"  
4569 f1			.pastdmark: pop af  
456a			endm  
# End of macro DMARK
456a					CALLMONITOR 
456a cd 00 14			call break_point_state  
456d				endm  
# End of macro CALLMONITOR
456d				endif 
456d 2b				dec hl 
456e 3e 20			ld a, ' ' 
4570 77				ld (hl), a 
4571 23				inc hl 
4572 77				ld (hl), a 
4573 23				inc hl 
4574 77				ld (hl), a 
4575 23				inc hl 
4576 3e 7f			ld a, FORTH_END_BUFFER 
4578 77				ld (hl), a 
4579			 
4579				; TODO handle more than a single block read 
4579			 
4579			 
4579 21 64 f8			ld hl, store_page+2 
457c			 
457c 22 33 f1			ld (os_tok_ptr), hl 
457f			 
457f				if DEBUG_STORESE 
457f					DMARK "LO3" 
457f f5				push af  
4580 3a 94 45			ld a, (.dmark)  
4583 32 77 fb			ld (debug_mark),a  
4586 3a 95 45			ld a, (.dmark+1)  
4589 32 78 fb			ld (debug_mark+1),a  
458c 3a 96 45			ld a, (.dmark+2)  
458f 32 79 fb			ld (debug_mark+2),a  
4592 18 03			jr .pastdmark  
4594 ..			.dmark: db "LO3"  
4597 f1			.pastdmark: pop af  
4598			endm  
# End of macro DMARK
4598					CALLMONITOR 
4598 cd 00 14			call break_point_state  
459b				endm  
# End of macro CALLMONITOR
459b				endif 
459b			 
459b cd cc 1b			call forthparse 
459e cd 0c 1c			call forthexec 
45a1 cd 23 1b			call forthexec_cleanup 
45a4			 
45a4				; go to next extent 
45a4			 
45a4				; get next block  or mark as eof 
45a4 c3 dd 44			jp .loadline 
45a7			 
45a7			 
45a7			 
45a7				       NEXTW 
45a7 c3 7e 1b			jp macro_next 
45aa				endm 
# End of macro NEXTW
45aa 3e 00		.loadeof:	ld a, 0 
45ac 32 59 f8				ld (store_openext), a 
45af			 
45af				if DEBUG_STORESE 
45af					DMARK "LOF" 
45af f5				push af  
45b0 3a c4 45			ld a, (.dmark)  
45b3 32 77 fb			ld (debug_mark),a  
45b6 3a c5 45			ld a, (.dmark+1)  
45b9 32 78 fb			ld (debug_mark+1),a  
45bc 3a c6 45			ld a, (.dmark+2)  
45bf 32 79 fb			ld (debug_mark+2),a  
45c2 18 03			jr .pastdmark  
45c4 ..			.dmark: db "LOF"  
45c7 f1			.pastdmark: pop af  
45c8			endm  
# End of macro DMARK
45c8					CALLMONITOR 
45c8 cd 00 14			call break_point_state  
45cb				endm  
# End of macro CALLMONITOR
45cb				endif 
45cb c9					ret 
45cc					;NEXTW 
45cc			.BSAVE:   
45cc			 
45cc				CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
45cc 5a				db WORD_SYS_CORE+70             
45cd d9 45			dw .BLOAD            
45cf 06				db 5 + 1 
45d0 .. 00			db "BSAVE",0              
45d6				endm 
# End of macro CWHEAD
45d6			; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
45d6					NEXTW 
45d6 c3 7e 1b			jp macro_next 
45d9				endm 
# End of macro NEXTW
45d9			.BLOAD: 
45d9				CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
45d9 5b				db WORD_SYS_CORE+71             
45da e6 45			dw .SEO            
45dc 06				db 5 + 1 
45dd .. 00			db "BLOAD",0              
45e3				endm 
# End of macro CWHEAD
45e3			; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
45e3					NEXTW 
45e3 c3 7e 1b			jp macro_next 
45e6				endm 
# End of macro NEXTW
45e6			;;;; counter gap 
45e6			 
45e6			 
45e6			.SEO: 
45e6				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
45e6 64				db WORD_SYS_CORE+80             
45e7 05 46			dw .SEI            
45e9 04				db 3 + 1 
45ea .. 00			db "SEO",0              
45ee				endm 
# End of macro CWHEAD
45ee			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
45ee			 
45ee					; get port 
45ee			 
45ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ee cd 28 1a			call macro_dsp_valuehl 
45f1				endm 
# End of macro FORTH_DSP_VALUEHL
45f1			 
45f1 e5					push hl    ; u2 - byte 
45f2			 
45f2					; destroy value TOS 
45f2			 
45f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45f2 cd c4 1a			call macro_forth_dsp_pop 
45f5				endm 
# End of macro FORTH_DSP_POP
45f5			 
45f5					; get byte to send 
45f5			 
45f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45f5 cd 28 1a			call macro_dsp_valuehl 
45f8				endm 
# End of macro FORTH_DSP_VALUEHL
45f8			 
45f8 e5					push hl    ; u1 - addr 
45f9			 
45f9					; destroy value TOS 
45f9			 
45f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45f9 cd c4 1a			call macro_forth_dsp_pop 
45fc				endm 
# End of macro FORTH_DSP_POP
45fc			 
45fc					; one value on hl get other one back 
45fc			 
45fc d1					pop de   ; u1 - byte 
45fd			 
45fd e1					pop hl   ; u2 - addr 
45fe			 
45fe					; TODO Send SPI byte 
45fe			 
45fe			 
45fe 7b					ld a, e 
45ff cd ea 01				call se_writebyte 
4602			 
4602					 
4602			 
4602					NEXTW 
4602 c3 7e 1b			jp macro_next 
4605				endm 
# End of macro NEXTW
4605			 
4605			.SEI: 
4605				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4605 65				db WORD_SYS_CORE+81             
4606 1f 46			dw .SFREE            
4608 04				db 3 + 1 
4609 .. 00			db "SEI",0              
460d				endm 
# End of macro CWHEAD
460d			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
460d			 
460d					; get port 
460d			 
460d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
460d cd 28 1a			call macro_dsp_valuehl 
4610				endm 
# End of macro FORTH_DSP_VALUEHL
4610			 
4610			;		push hl 
4610			 
4610					; destroy value TOS 
4610			 
4610					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4610 cd c4 1a			call macro_forth_dsp_pop 
4613				endm 
# End of macro FORTH_DSP_POP
4613			 
4613					; one value on hl get other one back 
4613			 
4613			;		pop hl 
4613			 
4613			 
4613					; TODO Get SPI byte 
4613			 
4613 cd 8c 02				call se_readbyte 
4616			 
4616 26 00				ld h, 0 
4618 6f					ld l, a 
4619 cd 8d 19				call forth_push_numhl 
461c			 
461c					NEXTW 
461c c3 7e 1b			jp macro_next 
461f				endm 
# End of macro NEXTW
461f			 
461f			.SFREE: 
461f				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
461f 67				db WORD_SYS_CORE+83             
4620 4e 46			dw .SIZE            
4622 06				db 5 + 1 
4623 .. 00			db "FFREE",0              
4629				endm 
# End of macro CWHEAD
4629			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4629					if DEBUG_FORTH_WORDS_KEY 
4629						DMARK "FFR" 
4629 f5				push af  
462a 3a 3e 46			ld a, (.dmark)  
462d 32 77 fb			ld (debug_mark),a  
4630 3a 3f 46			ld a, (.dmark+1)  
4633 32 78 fb			ld (debug_mark+1),a  
4636 3a 40 46			ld a, (.dmark+2)  
4639 32 79 fb			ld (debug_mark+2),a  
463c 18 03			jr .pastdmark  
463e ..			.dmark: db "FFR"  
4641 f1			.pastdmark: pop af  
4642			endm  
# End of macro DMARK
4642						CALLMONITOR 
4642 cd 00 14			call break_point_state  
4645				endm  
# End of macro CALLMONITOR
4645					endif 
4645			 
4645 cd bc 06				call storage_freeblocks 
4648			 
4648 cd 8d 19				call forth_push_numhl 
464b			 
464b				       NEXTW 
464b c3 7e 1b			jp macro_next 
464e				endm 
# End of macro NEXTW
464e			.SIZE: 
464e				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
464e 67				db WORD_SYS_CORE+83             
464f 82 46			dw .CREATE            
4651 05				db 4 + 1 
4652 .. 00			db "SIZE",0              
4657				endm 
# End of macro CWHEAD
4657			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4657					if DEBUG_FORTH_WORDS_KEY 
4657						DMARK "SIZ" 
4657 f5				push af  
4658 3a 6c 46			ld a, (.dmark)  
465b 32 77 fb			ld (debug_mark),a  
465e 3a 6d 46			ld a, (.dmark+1)  
4661 32 78 fb			ld (debug_mark+1),a  
4664 3a 6e 46			ld a, (.dmark+2)  
4667 32 79 fb			ld (debug_mark+2),a  
466a 18 03			jr .pastdmark  
466c ..			.dmark: db "SIZ"  
466f f1			.pastdmark: pop af  
4670			endm  
# End of macro DMARK
4670						CALLMONITOR 
4670 cd 00 14			call break_point_state  
4673				endm  
# End of macro CALLMONITOR
4673					endif 
4673			 
4673					FORTH_DSP_VALUEHL 
4673 cd 28 1a			call macro_dsp_valuehl 
4676				endm 
# End of macro FORTH_DSP_VALUEHL
4676			;		push hl 
4676					FORTH_DSP_POP 
4676 cd c4 1a			call macro_forth_dsp_pop 
4679				endm 
# End of macro FORTH_DSP_POP
4679			;		pop hl 
4679 cd 3b 03				call storage_file_size 
467c			 
467c cd 8d 19				call forth_push_numhl 
467f			  
467f			 
467f				       NEXTW 
467f c3 7e 1b			jp macro_next 
4682				endm 
# End of macro NEXTW
4682			 
4682			.CREATE: 
4682				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4682 68				db WORD_SYS_CORE+84             
4683 f0 46			dw .APPEND            
4685 07				db 6 + 1 
4686 .. 00			db "CREATE",0              
468d				endm 
# End of macro CWHEAD
468d			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | TO TEST 
468d			; | | e.g.  
468d			; | | TestProgram CREATE 
468d			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
468d			; | |  
468d			; | | Max file IDs are 255. 
468d			; | |  
468d					 
468d					if DEBUG_FORTH_WORDS_KEY 
468d						DMARK "CRT" 
468d f5				push af  
468e 3a a2 46			ld a, (.dmark)  
4691 32 77 fb			ld (debug_mark),a  
4694 3a a3 46			ld a, (.dmark+1)  
4697 32 78 fb			ld (debug_mark+1),a  
469a 3a a4 46			ld a, (.dmark+2)  
469d 32 79 fb			ld (debug_mark+2),a  
46a0 18 03			jr .pastdmark  
46a2 ..			.dmark: db "CRT"  
46a5 f1			.pastdmark: pop af  
46a6			endm  
# End of macro DMARK
46a6						CALLMONITOR 
46a6 cd 00 14			call break_point_state  
46a9				endm  
# End of macro CALLMONITOR
46a9					endif 
46a9			;		call storage_get_block_0 
46a9			 
46a9					; TODO pop hl 
46a9			 
46a9					;v5 FORTH_DSP_VALUE 
46a9					FORTH_DSP_VALUE 
46a9 cd 11 1a			call macro_forth_dsp_value 
46ac				endm 
# End of macro FORTH_DSP_VALUE
46ac			 
46ac				if DEBUG_STORESE 
46ac					DMARK "CR1" 
46ac f5				push af  
46ad 3a c1 46			ld a, (.dmark)  
46b0 32 77 fb			ld (debug_mark),a  
46b3 3a c2 46			ld a, (.dmark+1)  
46b6 32 78 fb			ld (debug_mark+1),a  
46b9 3a c3 46			ld a, (.dmark+2)  
46bc 32 79 fb			ld (debug_mark+2),a  
46bf 18 03			jr .pastdmark  
46c1 ..			.dmark: db "CR1"  
46c4 f1			.pastdmark: pop af  
46c5			endm  
# End of macro DMARK
46c5					CALLMONITOR 
46c5 cd 00 14			call break_point_state  
46c8				endm  
# End of macro CALLMONITOR
46c8				endif 
46c8			;		push hl 
46c8			;		FORTH_DSP_POP 
46c8			;		pop hl 
46c8			 
46c8			;		inc hl   ; move past the type marker 
46c8			 
46c8 cd f2 06				call storage_create 
46cb			 
46cb				if DEBUG_STORESE 
46cb					DMARK "CT1" 
46cb f5				push af  
46cc 3a e0 46			ld a, (.dmark)  
46cf 32 77 fb			ld (debug_mark),a  
46d2 3a e1 46			ld a, (.dmark+1)  
46d5 32 78 fb			ld (debug_mark+1),a  
46d8 3a e2 46			ld a, (.dmark+2)  
46db 32 79 fb			ld (debug_mark+2),a  
46de 18 03			jr .pastdmark  
46e0 ..			.dmark: db "CT1"  
46e3 f1			.pastdmark: pop af  
46e4			endm  
# End of macro DMARK
46e4					CALLMONITOR 
46e4 cd 00 14			call break_point_state  
46e7				endm  
# End of macro CALLMONITOR
46e7				endif 
46e7			;		push hl 
46e7					FORTH_DSP_POP 
46e7 cd c4 1a			call macro_forth_dsp_pop 
46ea				endm 
# End of macro FORTH_DSP_POP
46ea			;		pop hl 
46ea					; push file id to stack 
46ea cd 8d 19				call forth_push_numhl 
46ed			 
46ed			 
46ed			 
46ed				       NEXTW 
46ed c3 7e 1b			jp macro_next 
46f0				endm 
# End of macro NEXTW
46f0			 
46f0			.APPEND: 
46f0				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
46f0 69				db WORD_SYS_CORE+85             
46f1 81 47			dw .SDEL            
46f3 07				db 6 + 1 
46f4 .. 00			db "APPEND",0              
46fb				endm 
# End of macro CWHEAD
46fb			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | TO TEST 
46fb			; | | e.g. 
46fb			; | | Test CREATE      -> $01 
46fb			; | | "A string to add to file" $01 APPEND 
46fb			; | |  
46fb			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
46fb					if DEBUG_FORTH_WORDS_KEY 
46fb						DMARK "APP" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 77 fb			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 78 fb			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 79 fb			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "APP"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 00 14			call break_point_state  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717			 
4717					FORTH_DSP_VALUEHL 
4717 cd 28 1a			call macro_dsp_valuehl 
471a				endm 
# End of macro FORTH_DSP_VALUEHL
471a e5					push hl 	; save file id 
471b			 
471b				if DEBUG_STORESE 
471b					DMARK "AP1" 
471b f5				push af  
471c 3a 30 47			ld a, (.dmark)  
471f 32 77 fb			ld (debug_mark),a  
4722 3a 31 47			ld a, (.dmark+1)  
4725 32 78 fb			ld (debug_mark+1),a  
4728 3a 32 47			ld a, (.dmark+2)  
472b 32 79 fb			ld (debug_mark+2),a  
472e 18 03			jr .pastdmark  
4730 ..			.dmark: db "AP1"  
4733 f1			.pastdmark: pop af  
4734			endm  
# End of macro DMARK
4734					CALLMONITOR 
4734 cd 00 14			call break_point_state  
4737				endm  
# End of macro CALLMONITOR
4737				endif 
4737					FORTH_DSP_POP 
4737 cd c4 1a			call macro_forth_dsp_pop 
473a				endm 
# End of macro FORTH_DSP_POP
473a			 
473a					FORTH_DSP_VALUEHL 
473a cd 28 1a			call macro_dsp_valuehl 
473d				endm 
# End of macro FORTH_DSP_VALUEHL
473d					;v5 FORTH_DSP_VALUE 
473d e5					push hl 	; save ptr to string to save 
473e			 
473e				if DEBUG_STORESE 
473e					DMARK "AP1" 
473e f5				push af  
473f 3a 53 47			ld a, (.dmark)  
4742 32 77 fb			ld (debug_mark),a  
4745 3a 54 47			ld a, (.dmark+1)  
4748 32 78 fb			ld (debug_mark+1),a  
474b 3a 55 47			ld a, (.dmark+2)  
474e 32 79 fb			ld (debug_mark+2),a  
4751 18 03			jr .pastdmark  
4753 ..			.dmark: db "AP1"  
4756 f1			.pastdmark: pop af  
4757			endm  
# End of macro DMARK
4757					CALLMONITOR 
4757 cd 00 14			call break_point_state  
475a				endm  
# End of macro CALLMONITOR
475a				endif 
475a					FORTH_DSP_POP 
475a cd c4 1a			call macro_forth_dsp_pop 
475d				endm 
# End of macro FORTH_DSP_POP
475d			 
475d d1					pop de 
475e e1					pop hl 
475f				if DEBUG_STORESE 
475f					DMARK "AP2" 
475f f5				push af  
4760 3a 74 47			ld a, (.dmark)  
4763 32 77 fb			ld (debug_mark),a  
4766 3a 75 47			ld a, (.dmark+1)  
4769 32 78 fb			ld (debug_mark+1),a  
476c 3a 76 47			ld a, (.dmark+2)  
476f 32 79 fb			ld (debug_mark+2),a  
4772 18 03			jr .pastdmark  
4774 ..			.dmark: db "AP2"  
4777 f1			.pastdmark: pop af  
4778			endm  
# End of macro DMARK
4778					CALLMONITOR 
4778 cd 00 14			call break_point_state  
477b				endm  
# End of macro CALLMONITOR
477b				endif 
477b					;inc de ; skip var type indicator 
477b			 
477b					; TODO how to append numerics???? 
477b			 
477b cd cc 08				call storage_append		 
477e			 
477e				       NEXTW 
477e c3 7e 1b			jp macro_next 
4781				endm 
# End of macro NEXTW
4781			.SDEL: 
4781				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4781 6a				db WORD_SYS_CORE+86             
4782 cd 47			dw .OPEN            
4784 05				db 4 + 1 
4785 .. 00			db "ERA",0              
4789				endm 
# End of macro CWHEAD
4789			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4789					FORTH_DSP_VALUEHL 
4789 cd 28 1a			call macro_dsp_valuehl 
478c				endm 
# End of macro FORTH_DSP_VALUEHL
478c			;		push hl 	; save file id 
478c			 
478c					if DEBUG_FORTH_WORDS_KEY 
478c						DMARK "ERA" 
478c f5				push af  
478d 3a a1 47			ld a, (.dmark)  
4790 32 77 fb			ld (debug_mark),a  
4793 3a a2 47			ld a, (.dmark+1)  
4796 32 78 fb			ld (debug_mark+1),a  
4799 3a a3 47			ld a, (.dmark+2)  
479c 32 79 fb			ld (debug_mark+2),a  
479f 18 03			jr .pastdmark  
47a1 ..			.dmark: db "ERA"  
47a4 f1			.pastdmark: pop af  
47a5			endm  
# End of macro DMARK
47a5						CALLMONITOR 
47a5 cd 00 14			call break_point_state  
47a8				endm  
# End of macro CALLMONITOR
47a8					endif 
47a8				if DEBUG_STORESE 
47a8					DMARK "ER1" 
47a8 f5				push af  
47a9 3a bd 47			ld a, (.dmark)  
47ac 32 77 fb			ld (debug_mark),a  
47af 3a be 47			ld a, (.dmark+1)  
47b2 32 78 fb			ld (debug_mark+1),a  
47b5 3a bf 47			ld a, (.dmark+2)  
47b8 32 79 fb			ld (debug_mark+2),a  
47bb 18 03			jr .pastdmark  
47bd ..			.dmark: db "ER1"  
47c0 f1			.pastdmark: pop af  
47c1			endm  
# End of macro DMARK
47c1					CALLMONITOR 
47c1 cd 00 14			call break_point_state  
47c4				endm  
# End of macro CALLMONITOR
47c4				endif 
47c4					FORTH_DSP_POP 
47c4 cd c4 1a			call macro_forth_dsp_pop 
47c7				endm 
# End of macro FORTH_DSP_POP
47c7			 
47c7			;		pop hl 
47c7			 
47c7 cd 41 05				call storage_erase 
47ca				       NEXTW 
47ca c3 7e 1b			jp macro_next 
47cd				endm 
# End of macro NEXTW
47cd			 
47cd			.OPEN: 
47cd				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
47cd 6b				db WORD_SYS_CORE+87             
47ce 54 48			dw .READ            
47d0 05				db 4 + 1 
47d1 .. 00			db "OPEN",0              
47d6				endm 
# End of macro CWHEAD
47d6			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
47d6			; | | e.g. 
47d6			; | | $01 OPEN $01 DO $01 READ . LOOP 
47d6			 
47d6					if DEBUG_FORTH_WORDS_KEY 
47d6						DMARK "OPN" 
47d6 f5				push af  
47d7 3a eb 47			ld a, (.dmark)  
47da 32 77 fb			ld (debug_mark),a  
47dd 3a ec 47			ld a, (.dmark+1)  
47e0 32 78 fb			ld (debug_mark+1),a  
47e3 3a ed 47			ld a, (.dmark+2)  
47e6 32 79 fb			ld (debug_mark+2),a  
47e9 18 03			jr .pastdmark  
47eb ..			.dmark: db "OPN"  
47ee f1			.pastdmark: pop af  
47ef			endm  
# End of macro DMARK
47ef						CALLMONITOR 
47ef cd 00 14			call break_point_state  
47f2				endm  
# End of macro CALLMONITOR
47f2					endif 
47f2					; TODO handle multiple file opens 
47f2			 
47f2 3e 01			       	ld a, 1 
47f4 32 59 f8				ld (store_openext), a 
47f7			 
47f7					; get max extents for this file 
47f7				 
47f7								 
47f7					FORTH_DSP_VALUEHL 
47f7 cd 28 1a			call macro_dsp_valuehl 
47fa				endm 
# End of macro FORTH_DSP_VALUEHL
47fa			 
47fa 65					ld h, l 
47fb 2e 00				ld l, 0 
47fd			 
47fd				if DEBUG_STORESE 
47fd					DMARK "OPN" 
47fd f5				push af  
47fe 3a 12 48			ld a, (.dmark)  
4801 32 77 fb			ld (debug_mark),a  
4804 3a 13 48			ld a, (.dmark+1)  
4807 32 78 fb			ld (debug_mark+1),a  
480a 3a 14 48			ld a, (.dmark+2)  
480d 32 79 fb			ld (debug_mark+2),a  
4810 18 03			jr .pastdmark  
4812 ..			.dmark: db "OPN"  
4815 f1			.pastdmark: pop af  
4816			endm  
# End of macro DMARK
4816					CALLMONITOR 
4816 cd 00 14			call break_point_state  
4819				endm  
# End of macro CALLMONITOR
4819				endif 
4819			;		push hl 
4819					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4819 cd c4 1a			call macro_forth_dsp_pop 
481c				endm 
# End of macro FORTH_DSP_POP
481c			;		pop hl 
481c						 
481c 11 62 f8				ld de, store_page      ; get block zero of file 
481f cd 46 08				call storage_read 
4822			 
4822			 
4822 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4825 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4828					 
4828				if DEBUG_STORESE 
4828					DMARK "OPx" 
4828 f5				push af  
4829 3a 3d 48			ld a, (.dmark)  
482c 32 77 fb			ld (debug_mark),a  
482f 3a 3e 48			ld a, (.dmark+1)  
4832 32 78 fb			ld (debug_mark+1),a  
4835 3a 3f 48			ld a, (.dmark+2)  
4838 32 79 fb			ld (debug_mark+2),a  
483b 18 03			jr .pastdmark  
483d ..			.dmark: db "OPx"  
4840 f1			.pastdmark: pop af  
4841			endm  
# End of macro DMARK
4841					CALLMONITOR 
4841 cd 00 14			call break_point_state  
4844				endm  
# End of macro CALLMONITOR
4844				endif 
4844 fe 00				cp 0 
4846 20 03				jr nz, .skipopeneof 
4848					; have opened an empty file 
4848					 
4848 32 59 f8				ld (store_openext), a 
484b			 
484b			.skipopeneof: 
484b			 
484b 6f					ld l, a 
484c 26 00				ld h, 0 
484e cd 8d 19				call forth_push_numhl 
4851			 
4851			 
4851				       NEXTW 
4851 c3 7e 1b			jp macro_next 
4854				endm 
# End of macro NEXTW
4854			.READ: 
4854				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4854 6c				db WORD_SYS_CORE+88             
4855 9b 49			dw .EOF            
4857 05				db 4 + 1 
4858 .. 00			db "READ",0              
485d				endm 
# End of macro CWHEAD
485d			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
485d			; | | e.g. 
485d			; | | $01 OPEN $01 DO $01 READ . LOOP 
485d			 
485d					if DEBUG_FORTH_WORDS_KEY 
485d						DMARK "REA" 
485d f5				push af  
485e 3a 72 48			ld a, (.dmark)  
4861 32 77 fb			ld (debug_mark),a  
4864 3a 73 48			ld a, (.dmark+1)  
4867 32 78 fb			ld (debug_mark+1),a  
486a 3a 74 48			ld a, (.dmark+2)  
486d 32 79 fb			ld (debug_mark+2),a  
4870 18 03			jr .pastdmark  
4872 ..			.dmark: db "REA"  
4875 f1			.pastdmark: pop af  
4876			endm  
# End of macro DMARK
4876						CALLMONITOR 
4876 cd 00 14			call break_point_state  
4879				endm  
# End of macro CALLMONITOR
4879					endif 
4879					; store_openext use it. If zero it is EOF 
4879			 
4879					; read block from current stream id 
4879					; if the block does not contain zero term keep reading blocks until zero found 
4879					; push the block to stack 
4879					; save the block id to stream 
4879			 
4879			 
4879					FORTH_DSP_VALUEHL 
4879 cd 28 1a			call macro_dsp_valuehl 
487c				endm 
# End of macro FORTH_DSP_VALUEHL
487c			 
487c			;		push hl 
487c			 
487c				if DEBUG_STORESE 
487c					DMARK "REA" 
487c f5				push af  
487d 3a 91 48			ld a, (.dmark)  
4880 32 77 fb			ld (debug_mark),a  
4883 3a 92 48			ld a, (.dmark+1)  
4886 32 78 fb			ld (debug_mark+1),a  
4889 3a 93 48			ld a, (.dmark+2)  
488c 32 79 fb			ld (debug_mark+2),a  
488f 18 03			jr .pastdmark  
4891 ..			.dmark: db "REA"  
4894 f1			.pastdmark: pop af  
4895			endm  
# End of macro DMARK
4895					CALLMONITOR 
4895 cd 00 14			call break_point_state  
4898				endm  
# End of macro CALLMONITOR
4898				endif 
4898					FORTH_DSP_POP 
4898 cd c4 1a			call macro_forth_dsp_pop 
489b				endm 
# End of macro FORTH_DSP_POP
489b			 
489b			;		pop hl 
489b				 
489b 65					ld h,l 
489c			 
489c 3a 59 f8				ld a, (store_openext) 
489f 6f					ld l, a 
48a0					 
48a0 fe 00				cp 0 
48a2 ca 6d 49				jp z, .ateof     ; dont read past eof 
48a5			 
48a5			 
48a5 11 62 f8				ld de, store_page 
48a8				if DEBUG_STORESE 
48a8					DMARK "RE1" 
48a8 f5				push af  
48a9 3a bd 48			ld a, (.dmark)  
48ac 32 77 fb			ld (debug_mark),a  
48af 3a be 48			ld a, (.dmark+1)  
48b2 32 78 fb			ld (debug_mark+1),a  
48b5 3a bf 48			ld a, (.dmark+2)  
48b8 32 79 fb			ld (debug_mark+2),a  
48bb 18 03			jr .pastdmark  
48bd ..			.dmark: db "RE1"  
48c0 f1			.pastdmark: pop af  
48c1			endm  
# End of macro DMARK
48c1					CALLMONITOR 
48c1 cd 00 14			call break_point_state  
48c4				endm  
# End of macro CALLMONITOR
48c4				endif 
48c4 cd 46 08				call storage_read 
48c7			 
48c7				if DEBUG_STORESE 
48c7					DMARK "RE2" 
48c7 f5				push af  
48c8 3a dc 48			ld a, (.dmark)  
48cb 32 77 fb			ld (debug_mark),a  
48ce 3a dd 48			ld a, (.dmark+1)  
48d1 32 78 fb			ld (debug_mark+1),a  
48d4 3a de 48			ld a, (.dmark+2)  
48d7 32 79 fb			ld (debug_mark+2),a  
48da 18 03			jr .pastdmark  
48dc ..			.dmark: db "RE2"  
48df f1			.pastdmark: pop af  
48e0			endm  
# End of macro DMARK
48e0					CALLMONITOR 
48e0 cd 00 14			call break_point_state  
48e3				endm  
# End of macro CALLMONITOR
48e3				endif 
48e3 cd 3b 0c			call ishlzero 
48e6			;	ld a, l 
48e6			;	add h 
48e6			;	cp 0 
48e6 ca 73 49			jp z, .readeof 
48e9			 
48e9				; not eof so hl should point to data to push to stack 
48e9			 
48e9				if DEBUG_STORESE 
48e9					DMARK "RE3" 
48e9 f5				push af  
48ea 3a fe 48			ld a, (.dmark)  
48ed 32 77 fb			ld (debug_mark),a  
48f0 3a ff 48			ld a, (.dmark+1)  
48f3 32 78 fb			ld (debug_mark+1),a  
48f6 3a 00 49			ld a, (.dmark+2)  
48f9 32 79 fb			ld (debug_mark+2),a  
48fc 18 03			jr .pastdmark  
48fe ..			.dmark: db "RE3"  
4901 f1			.pastdmark: pop af  
4902			endm  
# End of macro DMARK
4902					CALLMONITOR 
4902 cd 00 14			call break_point_state  
4905				endm  
# End of macro CALLMONITOR
4905				endif 
4905 cd 9f 19			call forth_push_str 
4908			 
4908				if DEBUG_STORESE 
4908					DMARK "RE4" 
4908 f5				push af  
4909 3a 1d 49			ld a, (.dmark)  
490c 32 77 fb			ld (debug_mark),a  
490f 3a 1e 49			ld a, (.dmark+1)  
4912 32 78 fb			ld (debug_mark+1),a  
4915 3a 1f 49			ld a, (.dmark+2)  
4918 32 79 fb			ld (debug_mark+2),a  
491b 18 03			jr .pastdmark  
491d ..			.dmark: db "RE4"  
4920 f1			.pastdmark: pop af  
4921			endm  
# End of macro DMARK
4921					CALLMONITOR 
4921 cd 00 14			call break_point_state  
4924				endm  
# End of macro CALLMONITOR
4924				endif 
4924				; get next block  or mark as eof 
4924			 
4924 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4927 4f				ld c, a	 
4928 3a 59 f8			ld a, (store_openext) 
492b			 
492b				if DEBUG_STORESE 
492b					DMARK "RE5" 
492b f5				push af  
492c 3a 40 49			ld a, (.dmark)  
492f 32 77 fb			ld (debug_mark),a  
4932 3a 41 49			ld a, (.dmark+1)  
4935 32 78 fb			ld (debug_mark+1),a  
4938 3a 42 49			ld a, (.dmark+2)  
493b 32 79 fb			ld (debug_mark+2),a  
493e 18 03			jr .pastdmark  
4940 ..			.dmark: db "RE5"  
4943 f1			.pastdmark: pop af  
4944			endm  
# End of macro DMARK
4944					CALLMONITOR 
4944 cd 00 14			call break_point_state  
4947				endm  
# End of macro CALLMONITOR
4947				endif 
4947 b9				cp c 
4948 28 29			jr z, .readeof     ; at last extent 
494a			 
494a 3c					inc a 
494b 32 59 f8				ld (store_openext), a 
494e			 
494e				if DEBUG_STORESE 
494e					DMARK "RE6" 
494e f5				push af  
494f 3a 63 49			ld a, (.dmark)  
4952 32 77 fb			ld (debug_mark),a  
4955 3a 64 49			ld a, (.dmark+1)  
4958 32 78 fb			ld (debug_mark+1),a  
495b 3a 65 49			ld a, (.dmark+2)  
495e 32 79 fb			ld (debug_mark+2),a  
4961 18 03			jr .pastdmark  
4963 ..			.dmark: db "RE6"  
4966 f1			.pastdmark: pop af  
4967			endm  
# End of macro DMARK
4967					CALLMONITOR 
4967 cd 00 14			call break_point_state  
496a				endm  
# End of macro CALLMONITOR
496a				endif 
496a			 
496a			 
496a				       NEXTW 
496a c3 7e 1b			jp macro_next 
496d				endm 
# End of macro NEXTW
496d			.ateof: 
496d 21 97 49				ld hl, .showeof 
4970 cd 9f 19				call forth_push_str 
4973 3e 00		.readeof:	ld a, 0 
4975 32 59 f8				ld (store_openext), a 
4978			 
4978					 
4978				if DEBUG_STORESE 
4978					DMARK "REF" 
4978 f5				push af  
4979 3a 8d 49			ld a, (.dmark)  
497c 32 77 fb			ld (debug_mark),a  
497f 3a 8e 49			ld a, (.dmark+1)  
4982 32 78 fb			ld (debug_mark+1),a  
4985 3a 8f 49			ld a, (.dmark+2)  
4988 32 79 fb			ld (debug_mark+2),a  
498b 18 03			jr .pastdmark  
498d ..			.dmark: db "REF"  
4990 f1			.pastdmark: pop af  
4991			endm  
# End of macro DMARK
4991					CALLMONITOR 
4991 cd 00 14			call break_point_state  
4994				endm  
# End of macro CALLMONITOR
4994				endif 
4994				       NEXTW 
4994 c3 7e 1b			jp macro_next 
4997				endm 
# End of macro NEXTW
4997			 
4997 .. 00		.showeof:   db "eof", 0 
499b			 
499b			 
499b			.EOF: 
499b				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
499b 6d				db WORD_SYS_CORE+89             
499c dc 49			dw .FORMAT            
499e 04				db 3 + 1 
499f .. 00			db "EOF",0              
49a3				endm 
# End of macro CWHEAD
49a3			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
49a3			; | | e.g. 
49a3			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
49a3					; TODO if current block id for stream is zero then push true else false 
49a3			 
49a3					if DEBUG_FORTH_WORDS_KEY 
49a3						DMARK "EOF" 
49a3 f5				push af  
49a4 3a b8 49			ld a, (.dmark)  
49a7 32 77 fb			ld (debug_mark),a  
49aa 3a b9 49			ld a, (.dmark+1)  
49ad 32 78 fb			ld (debug_mark+1),a  
49b0 3a ba 49			ld a, (.dmark+2)  
49b3 32 79 fb			ld (debug_mark+2),a  
49b6 18 03			jr .pastdmark  
49b8 ..			.dmark: db "EOF"  
49bb f1			.pastdmark: pop af  
49bc			endm  
# End of macro DMARK
49bc						CALLMONITOR 
49bc cd 00 14			call break_point_state  
49bf				endm  
# End of macro CALLMONITOR
49bf					endif 
49bf			 
49bf					; TODO handlue multiple file streams 
49bf			 
49bf					FORTH_DSP_POP     ; for now just get rid of stream id 
49bf cd c4 1a			call macro_forth_dsp_pop 
49c2				endm 
# End of macro FORTH_DSP_POP
49c2			 
49c2 2e 01				ld l, 1 
49c4 3a 58 f8				ld a, (store_openmaxext) 
49c7 fe 00				cp 0 
49c9 28 09				jr  z, .eofdone   ; empty file 
49cb 3a 59 f8				ld a, (store_openext) 
49ce fe 00				cp 0 
49d0 28 02				jr  z, .eofdone 
49d2 2e 00				ld l, 0 
49d4 26 00		.eofdone:	ld h, 0 
49d6 cd 8d 19				call forth_push_numhl 
49d9			 
49d9			 
49d9				       NEXTW 
49d9 c3 7e 1b			jp macro_next 
49dc				endm 
# End of macro NEXTW
49dc			 
49dc			.FORMAT: 
49dc				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
49dc 6d				db WORD_SYS_CORE+89             
49dd 2d 4a			dw .LABEL            
49df 07				db 6 + 1 
49e0 .. 00			db "FORMAT",0              
49e7				endm 
# End of macro CWHEAD
49e7			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
49e7					; TODO if current block id for stream is zero then push true else false 
49e7				 
49e7				if DEBUG_STORESE 
49e7					DMARK "FOR" 
49e7 f5				push af  
49e8 3a fc 49			ld a, (.dmark)  
49eb 32 77 fb			ld (debug_mark),a  
49ee 3a fd 49			ld a, (.dmark+1)  
49f1 32 78 fb			ld (debug_mark+1),a  
49f4 3a fe 49			ld a, (.dmark+2)  
49f7 32 79 fb			ld (debug_mark+2),a  
49fa 18 03			jr .pastdmark  
49fc ..			.dmark: db "FOR"  
49ff f1			.pastdmark: pop af  
4a00			endm  
# End of macro DMARK
4a00					CALLMONITOR 
4a00 cd 00 14			call break_point_state  
4a03				endm  
# End of macro CALLMONITOR
4a03				endif 
4a03					; Wipes the bank check flags to cause a reformat on next block 0 read 
4a03			 
4a03 21 01 00				ld hl, 1 
4a06 3e 00				ld a, 0 
4a08 cd ea 01				call se_writebyte 
4a0b			 
4a0b				if DEBUG_STORESE 
4a0b					DMARK "FO0" 
4a0b f5				push af  
4a0c 3a 20 4a			ld a, (.dmark)  
4a0f 32 77 fb			ld (debug_mark),a  
4a12 3a 21 4a			ld a, (.dmark+1)  
4a15 32 78 fb			ld (debug_mark+1),a  
4a18 3a 22 4a			ld a, (.dmark+2)  
4a1b 32 79 fb			ld (debug_mark+2),a  
4a1e 18 03			jr .pastdmark  
4a20 ..			.dmark: db "FO0"  
4a23 f1			.pastdmark: pop af  
4a24			endm  
# End of macro DMARK
4a24					CALLMONITOR 
4a24 cd 00 14			call break_point_state  
4a27				endm  
# End of macro CALLMONITOR
4a27				endif 
4a27					; force bank init 
4a27			 
4a27 cd bd 03				call storage_get_block_0 
4a2a					 
4a2a				       NEXTW 
4a2a c3 7e 1b			jp macro_next 
4a2d				endm 
# End of macro NEXTW
4a2d			.LABEL: 
4a2d				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4a2d 6d				db WORD_SYS_CORE+89             
4a2e 7b 4a			dw .STOREPAGE            
4a30 06				db 5 + 1 
4a31 .. 00			db "LABEL",0              
4a37				endm 
# End of macro CWHEAD
4a37			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4a37					; TODO test to see if bank is selected 
4a37				 
4a37					if DEBUG_FORTH_WORDS_KEY 
4a37						DMARK "LBL" 
4a37 f5				push af  
4a38 3a 4c 4a			ld a, (.dmark)  
4a3b 32 77 fb			ld (debug_mark),a  
4a3e 3a 4d 4a			ld a, (.dmark+1)  
4a41 32 78 fb			ld (debug_mark+1),a  
4a44 3a 4e 4a			ld a, (.dmark+2)  
4a47 32 79 fb			ld (debug_mark+2),a  
4a4a 18 03			jr .pastdmark  
4a4c ..			.dmark: db "LBL"  
4a4f f1			.pastdmark: pop af  
4a50			endm  
# End of macro DMARK
4a50						CALLMONITOR 
4a50 cd 00 14			call break_point_state  
4a53				endm  
# End of macro CALLMONITOR
4a53					endif 
4a53			;	if DEBUG_STORESE 
4a53			;		DMARK "LBL" 
4a53			;		CALLMONITOR 
4a53			;	endif 
4a53					FORTH_DSP_VALUEHL 
4a53 cd 28 1a			call macro_dsp_valuehl 
4a56				endm 
# End of macro FORTH_DSP_VALUEHL
4a56					;v5FORTH_DSP_VALUE 
4a56					 
4a56			;		push hl 
4a56					FORTH_DSP_POP 
4a56 cd c4 1a			call macro_forth_dsp_pop 
4a59				endm 
# End of macro FORTH_DSP_POP
4a59			;		pop hl 
4a59			 
4a59			;v5		inc hl   ; move past the type marker 
4a59			 
4a59				if DEBUG_STORESE 
4a59					DMARK "LBl" 
4a59 f5				push af  
4a5a 3a 6e 4a			ld a, (.dmark)  
4a5d 32 77 fb			ld (debug_mark),a  
4a60 3a 6f 4a			ld a, (.dmark+1)  
4a63 32 78 fb			ld (debug_mark+1),a  
4a66 3a 70 4a			ld a, (.dmark+2)  
4a69 32 79 fb			ld (debug_mark+2),a  
4a6c 18 03			jr .pastdmark  
4a6e ..			.dmark: db "LBl"  
4a71 f1			.pastdmark: pop af  
4a72			endm  
# End of macro DMARK
4a72					CALLMONITOR 
4a72 cd 00 14			call break_point_state  
4a75				endm  
# End of macro CALLMONITOR
4a75				endif 
4a75 cd d6 04				call storage_label 
4a78			 
4a78				       NEXTW 
4a78 c3 7e 1b			jp macro_next 
4a7b				endm 
# End of macro NEXTW
4a7b			.STOREPAGE: 
4a7b				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4a7b 6d				db WORD_SYS_CORE+89             
4a7c ae 4a			dw .LABELS            
4a7e 0a				db 9 + 1 
4a7f .. 00			db "STOREPAGE",0              
4a89				endm 
# End of macro CWHEAD
4a89			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4a89					; TODO test to see if bank is selected 
4a89				 
4a89					if DEBUG_FORTH_WORDS_KEY 
4a89						DMARK "STP" 
4a89 f5				push af  
4a8a 3a 9e 4a			ld a, (.dmark)  
4a8d 32 77 fb			ld (debug_mark),a  
4a90 3a 9f 4a			ld a, (.dmark+1)  
4a93 32 78 fb			ld (debug_mark+1),a  
4a96 3a a0 4a			ld a, (.dmark+2)  
4a99 32 79 fb			ld (debug_mark+2),a  
4a9c 18 03			jr .pastdmark  
4a9e ..			.dmark: db "STP"  
4aa1 f1			.pastdmark: pop af  
4aa2			endm  
# End of macro DMARK
4aa2						CALLMONITOR 
4aa2 cd 00 14			call break_point_state  
4aa5				endm  
# End of macro CALLMONITOR
4aa5					endif 
4aa5			;	if DEBUG_STORESE 
4aa5			;		DMARK "STP" 
4aa5			;		CALLMONITOR 
4aa5			;	endif 
4aa5			 
4aa5 21 62 f8			ld hl, store_page 
4aa8 cd 8d 19			call forth_push_numhl 
4aab			 
4aab			 
4aab				       NEXTW 
4aab c3 7e 1b			jp macro_next 
4aae				endm 
# End of macro NEXTW
4aae			.LABELS: 
4aae				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4aae 6d				db WORD_SYS_CORE+89             
4aaf 38 4b			dw .ENDSTORAGE            
4ab1 07				db 6 + 1 
4ab2 .. 00			db "LABELS",0              
4ab9				endm 
# End of macro CWHEAD
4ab9			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4ab9					;  
4ab9			 
4ab9					; save the current device selected to restore afterwards 
4ab9				 
4ab9 3a 5c f8				ld a, (spi_device) 
4abc f5					push af 
4abd			 
4abd			 
4abd					; run through each of the banks 
4abd			 
4abd 21 01 00				ld hl, 1 
4ac0 cd 8d 19				call forth_push_numhl 
4ac3 3e ff				ld a, SPI_CE_HIGH 
4ac5 cb 87				res SPI_CE0, a 
4ac7 32 5c f8				ld (spi_device), a 
4aca cd bd 03				call storage_get_block_0 
4acd 21 65 f8				ld hl, store_page+3 
4ad0 cd 9f 19				call forth_push_str 
4ad3			 
4ad3					 
4ad3 21 02 00				ld hl, 2 
4ad6 cd 8d 19				call forth_push_numhl 
4ad9 3e ff				ld a, SPI_CE_HIGH 
4adb cb 8f				res SPI_CE1, a 
4add 32 5c f8				ld (spi_device), a 
4ae0 cd bd 03				call storage_get_block_0 
4ae3 21 65 f8				ld hl, store_page+3 
4ae6 cd 9f 19				call forth_push_str 
4ae9			 
4ae9					 
4ae9 21 03 00				ld hl, 3 
4aec cd 8d 19				call forth_push_numhl 
4aef 3e ff				ld a, SPI_CE_HIGH 
4af1 cb 97				res SPI_CE2, a 
4af3 32 5c f8				ld (spi_device), a 
4af6 cd bd 03				call storage_get_block_0 
4af9 21 65 f8				ld hl, store_page+3 
4afc cd 9f 19				call forth_push_str 
4aff			 
4aff			 
4aff 21 04 00				ld hl, 4 
4b02 cd 8d 19				call forth_push_numhl 
4b05 3e ff				ld a, SPI_CE_HIGH 
4b07 cb 9f				res SPI_CE3, a 
4b09 32 5c f8				ld (spi_device), a 
4b0c cd bd 03				call storage_get_block_0 
4b0f 21 65 f8				ld hl, store_page+3 
4b12 cd 9f 19				call forth_push_str 
4b15			 
4b15					 
4b15			 
4b15 21 05 00				ld hl, 5 
4b18 cd 8d 19				call forth_push_numhl 
4b1b 3e ff				ld a, SPI_CE_HIGH 
4b1d cb a7				res SPI_CE4, a 
4b1f 32 5c f8				ld (spi_device), a 
4b22 cd bd 03				call storage_get_block_0 
4b25 21 65 f8				ld hl, store_page+3 
4b28 cd 9f 19				call forth_push_str 
4b2b			 
4b2b					 
4b2b					; push fixed count of storage devices (on board) for now 
4b2b			 
4b2b 21 05 00				ld hl, 5 
4b2e cd 8d 19				call forth_push_numhl 
4b31			 
4b31					; restore selected device  
4b31				 
4b31 f1					pop af 
4b32 32 5c f8				ld (spi_device), a 
4b35			 
4b35				       NEXTW 
4b35 c3 7e 1b			jp macro_next 
4b38				endm 
# End of macro NEXTW
4b38			 
4b38			.ENDSTORAGE: 
4b38			; eof 
# End of file forth_words_storage.asm
4b38			endif 
4b38				include "forth_words_device.asm" 
4b38			; Device related words 
4b38			 
4b38			; | ## Device Words 
4b38			 
4b38			if SOUND_ENABLE 
4b38			.NOTE: 
4b38				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b38 33				db WORD_SYS_CORE+31             
4b39 60 4b			dw .AFTERSOUND            
4b3b 05				db 4 + 1 
4b3c .. 00			db "NOTE",0              
4b41				endm 
# End of macro CWHEAD
4b41			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4b41					if DEBUG_FORTH_WORDS_KEY 
4b41						DMARK "NTE" 
4b41 f5				push af  
4b42 3a 56 4b			ld a, (.dmark)  
4b45 32 77 fb			ld (debug_mark),a  
4b48 3a 57 4b			ld a, (.dmark+1)  
4b4b 32 78 fb			ld (debug_mark+1),a  
4b4e 3a 58 4b			ld a, (.dmark+2)  
4b51 32 79 fb			ld (debug_mark+2),a  
4b54 18 03			jr .pastdmark  
4b56 ..			.dmark: db "NTE"  
4b59 f1			.pastdmark: pop af  
4b5a			endm  
# End of macro DMARK
4b5a						CALLMONITOR 
4b5a cd 00 14			call break_point_state  
4b5d				endm  
# End of macro CALLMONITOR
4b5d					endif 
4b5d			 
4b5d				 
4b5d			 
4b5d					NEXTW 
4b5d c3 7e 1b			jp macro_next 
4b60				endm 
# End of macro NEXTW
4b60			.AFTERSOUND: 
4b60			endif 
4b60			 
4b60			 
4b60			USE_GPIO: equ 0 
4b60			 
4b60			if USE_GPIO 
4b60			.GP1: 
4b60				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b60			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4b60					NEXTW 
4b60			.GP2: 
4b60				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b60			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4b60			 
4b60					NEXTW 
4b60			 
4b60			.GP3: 
4b60				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b60			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4b60			 
4b60					NEXTW 
4b60			 
4b60			.GP4: 
4b60				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b60			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4b60			 
4b60					NEXTW 
4b60			.SIN: 
4b60			 
4b60			 
4b60			endif 
4b60			 
4b60			 
4b60				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b60 33				db WORD_SYS_CORE+31             
4b61 95 4b			dw .SOUT            
4b63 03				db 2 + 1 
4b64 .. 00			db "IN",0              
4b67				endm 
# End of macro CWHEAD
4b67			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b67					if DEBUG_FORTH_WORDS_KEY 
4b67						DMARK "IN." 
4b67 f5				push af  
4b68 3a 7c 4b			ld a, (.dmark)  
4b6b 32 77 fb			ld (debug_mark),a  
4b6e 3a 7d 4b			ld a, (.dmark+1)  
4b71 32 78 fb			ld (debug_mark+1),a  
4b74 3a 7e 4b			ld a, (.dmark+2)  
4b77 32 79 fb			ld (debug_mark+2),a  
4b7a 18 03			jr .pastdmark  
4b7c ..			.dmark: db "IN."  
4b7f f1			.pastdmark: pop af  
4b80			endm  
# End of macro DMARK
4b80						CALLMONITOR 
4b80 cd 00 14			call break_point_state  
4b83				endm  
# End of macro CALLMONITOR
4b83					endif 
4b83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b83 cd 28 1a			call macro_dsp_valuehl 
4b86				endm 
# End of macro FORTH_DSP_VALUEHL
4b86			 
4b86 e5					push hl 
4b87			 
4b87					; destroy value TOS 
4b87			 
4b87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b87 cd c4 1a			call macro_forth_dsp_pop 
4b8a				endm 
# End of macro FORTH_DSP_POP
4b8a			 
4b8a					; one value on hl get other one back 
4b8a			 
4b8a c1					pop bc 
4b8b			 
4b8b					; do the sub 
4b8b			;		ex de, hl 
4b8b			 
4b8b ed 68				in l,(c) 
4b8d			 
4b8d					; save it 
4b8d			 
4b8d 26 00				ld h,0 
4b8f			 
4b8f					; TODO push value back onto stack for another op etc 
4b8f			 
4b8f cd 8d 19				call forth_push_numhl 
4b92					NEXTW 
4b92 c3 7e 1b			jp macro_next 
4b95				endm 
# End of macro NEXTW
4b95			.SOUT: 
4b95				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4b95 34				db WORD_SYS_CORE+32             
4b96 e8 4b			dw .SPIO            
4b98 04				db 3 + 1 
4b99 .. 00			db "OUT",0              
4b9d				endm 
# End of macro CWHEAD
4b9d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b9d					if DEBUG_FORTH_WORDS_KEY 
4b9d						DMARK "OUT" 
4b9d f5				push af  
4b9e 3a b2 4b			ld a, (.dmark)  
4ba1 32 77 fb			ld (debug_mark),a  
4ba4 3a b3 4b			ld a, (.dmark+1)  
4ba7 32 78 fb			ld (debug_mark+1),a  
4baa 3a b4 4b			ld a, (.dmark+2)  
4bad 32 79 fb			ld (debug_mark+2),a  
4bb0 18 03			jr .pastdmark  
4bb2 ..			.dmark: db "OUT"  
4bb5 f1			.pastdmark: pop af  
4bb6			endm  
# End of macro DMARK
4bb6						CALLMONITOR 
4bb6 cd 00 14			call break_point_state  
4bb9				endm  
# End of macro CALLMONITOR
4bb9					endif 
4bb9			 
4bb9					; get port 
4bb9			 
4bb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bb9 cd 28 1a			call macro_dsp_valuehl 
4bbc				endm 
# End of macro FORTH_DSP_VALUEHL
4bbc			 
4bbc e5					push hl 
4bbd			 
4bbd					; destroy value TOS 
4bbd			 
4bbd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bbd cd c4 1a			call macro_forth_dsp_pop 
4bc0				endm 
# End of macro FORTH_DSP_POP
4bc0			 
4bc0					; get byte to send 
4bc0			 
4bc0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc0 cd 28 1a			call macro_dsp_valuehl 
4bc3				endm 
# End of macro FORTH_DSP_VALUEHL
4bc3			 
4bc3			;		push hl 
4bc3			 
4bc3					; destroy value TOS 
4bc3			 
4bc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc3 cd c4 1a			call macro_forth_dsp_pop 
4bc6				endm 
# End of macro FORTH_DSP_POP
4bc6			 
4bc6					; one value on hl get other one back 
4bc6			 
4bc6			;		pop hl 
4bc6			 
4bc6 c1					pop bc 
4bc7			 
4bc7					if DEBUG_FORTH_WORDS 
4bc7						DMARK "OUT" 
4bc7 f5				push af  
4bc8 3a dc 4b			ld a, (.dmark)  
4bcb 32 77 fb			ld (debug_mark),a  
4bce 3a dd 4b			ld a, (.dmark+1)  
4bd1 32 78 fb			ld (debug_mark+1),a  
4bd4 3a de 4b			ld a, (.dmark+2)  
4bd7 32 79 fb			ld (debug_mark+2),a  
4bda 18 03			jr .pastdmark  
4bdc ..			.dmark: db "OUT"  
4bdf f1			.pastdmark: pop af  
4be0			endm  
# End of macro DMARK
4be0						CALLMONITOR 
4be0 cd 00 14			call break_point_state  
4be3				endm  
# End of macro CALLMONITOR
4be3					endif 
4be3			 
4be3 ed 69				out (c), l 
4be5			 
4be5					NEXTW 
4be5 c3 7e 1b			jp macro_next 
4be8				endm 
# End of macro NEXTW
4be8			 
4be8			 
4be8			.SPIO: 
4be8			 
4be8			if STORAGE_SE 
4be8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4be8 51				db WORD_SYS_CORE+61             
4be9 f9 4b			dw .SPICEH            
4beb 07				db 6 + 1 
4bec .. 00			db "SPICEL",0              
4bf3				endm 
# End of macro CWHEAD
4bf3			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4bf3			 
4bf3 cd 98 01				call spi_ce_low 
4bf6			    NEXTW 
4bf6 c3 7e 1b			jp macro_next 
4bf9				endm 
# End of macro NEXTW
4bf9			 
4bf9			.SPICEH: 
4bf9				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4bf9 51				db WORD_SYS_CORE+61             
4bfa 0a 4c			dw .SPIOb            
4bfc 07				db 6 + 1 
4bfd .. 00			db "SPICEH",0              
4c04				endm 
# End of macro CWHEAD
4c04			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4c04			 
4c04 cd 87 01				call spi_ce_high 
4c07			    NEXTW 
4c07 c3 7e 1b			jp macro_next 
4c0a				endm 
# End of macro NEXTW
4c0a			 
4c0a			 
4c0a			.SPIOb: 
4c0a			 
4c0a				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4c0a 51				db WORD_SYS_CORE+61             
4c0b 20 4c			dw .SPII            
4c0d 05				db 4 + 1 
4c0e .. 00			db "SPIO",0              
4c13				endm 
# End of macro CWHEAD
4c13			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4c13			 
4c13					; get port 
4c13			 
4c13			 
4c13					; get byte to send 
4c13			 
4c13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c13 cd 28 1a			call macro_dsp_valuehl 
4c16				endm 
# End of macro FORTH_DSP_VALUEHL
4c16			 
4c16			;		push hl    ; u1  
4c16			 
4c16					; destroy value TOS 
4c16			 
4c16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c16 cd c4 1a			call macro_forth_dsp_pop 
4c19				endm 
# End of macro FORTH_DSP_POP
4c19			 
4c19					; one value on hl get other one back 
4c19			 
4c19			;		pop hl   ; u2 - addr 
4c19			 
4c19					; TODO Send SPI byte 
4c19			 
4c19 7d					ld a, l 
4c1a cd bc 00				call spi_send_byte 
4c1d			 
4c1d					NEXTW 
4c1d c3 7e 1b			jp macro_next 
4c20				endm 
# End of macro NEXTW
4c20			 
4c20			.SPII: 
4c20				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4c20 52				db WORD_SYS_CORE+62             
4c21 35 4c			dw .SESEL            
4c23 06				db 5 + 1 
4c24 .. 00			db "SPII",0              
4c29				endm 
# End of macro CWHEAD
4c29			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4c29			 
4c29					; TODO Get SPI byte 
4c29			 
4c29 cd dd 00				call spi_read_byte 
4c2c			 
4c2c 26 00				ld h, 0 
4c2e 6f					ld l, a 
4c2f cd 8d 19				call forth_push_numhl 
4c32			 
4c32					NEXTW 
4c32 c3 7e 1b			jp macro_next 
4c35				endm 
# End of macro NEXTW
4c35			 
4c35			 
4c35			 
4c35			.SESEL: 
4c35				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4c35 66				db WORD_SYS_CORE+82             
4c36 c9 4c			dw .CARTDEV            
4c38 05				db 4 + 1 
4c39 .. 00			db "BANK",0              
4c3e				endm 
# End of macro CWHEAD
4c3e			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4c3e					if DEBUG_FORTH_WORDS_KEY 
4c3e						DMARK "BNK" 
4c3e f5				push af  
4c3f 3a 53 4c			ld a, (.dmark)  
4c42 32 77 fb			ld (debug_mark),a  
4c45 3a 54 4c			ld a, (.dmark+1)  
4c48 32 78 fb			ld (debug_mark+1),a  
4c4b 3a 55 4c			ld a, (.dmark+2)  
4c4e 32 79 fb			ld (debug_mark+2),a  
4c51 18 03			jr .pastdmark  
4c53 ..			.dmark: db "BNK"  
4c56 f1			.pastdmark: pop af  
4c57			endm  
# End of macro DMARK
4c57						CALLMONITOR 
4c57 cd 00 14			call break_point_state  
4c5a				endm  
# End of macro CALLMONITOR
4c5a					endif 
4c5a			 
4c5a 3e ff				ld a, 255 
4c5c 32 5f f8				ld (spi_cartdev), a 
4c5f			 
4c5f					; get bank 
4c5f			 
4c5f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c5f cd 28 1a			call macro_dsp_valuehl 
4c62				endm 
# End of macro FORTH_DSP_VALUEHL
4c62			 
4c62			;		push hl 
4c62			 
4c62					; destroy value TOS 
4c62			 
4c62					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c62 cd c4 1a			call macro_forth_dsp_pop 
4c65				endm 
# End of macro FORTH_DSP_POP
4c65			 
4c65					; one value on hl get other one back 
4c65			 
4c65			;		pop hl 
4c65			 
4c65			 
4c65 0e ff				ld c, SPI_CE_HIGH 
4c67			 
4c67 7d					ld a, l 
4c68			 
4c68					if DEBUG_FORTH_WORDS 
4c68						DMARK "BNK" 
4c68 f5				push af  
4c69 3a 7d 4c			ld a, (.dmark)  
4c6c 32 77 fb			ld (debug_mark),a  
4c6f 3a 7e 4c			ld a, (.dmark+1)  
4c72 32 78 fb			ld (debug_mark+1),a  
4c75 3a 7f 4c			ld a, (.dmark+2)  
4c78 32 79 fb			ld (debug_mark+2),a  
4c7b 18 03			jr .pastdmark  
4c7d ..			.dmark: db "BNK"  
4c80 f1			.pastdmark: pop af  
4c81			endm  
# End of macro DMARK
4c81						CALLMONITOR 
4c81 cd 00 14			call break_point_state  
4c84				endm  
# End of macro CALLMONITOR
4c84					endif 
4c84			 
4c84					; active low 
4c84			 
4c84 fe 00				cp 0 
4c86 28 1e				jr z, .bset 
4c88 fe 01				cp 1 
4c8a 20 02				jr nz, .b2 
4c8c cb 81				res 0, c 
4c8e fe 02		.b2:		cp 2 
4c90 20 02				jr nz, .b3 
4c92 cb 89				res 1, c 
4c94 fe 03		.b3:		cp 3 
4c96 20 02				jr nz, .b4 
4c98 cb 91				res 2, c 
4c9a fe 04		.b4:		cp 4 
4c9c 20 02				jr nz, .b5 
4c9e cb 99				res 3, c 
4ca0 fe 05		.b5:		cp 5 
4ca2 20 02				jr nz, .bset 
4ca4 cb a1				res 4, c 
4ca6			 
4ca6			.bset: 
4ca6 79					ld a, c 
4ca7 32 5c f8				ld (spi_device),a 
4caa					if DEBUG_FORTH_WORDS 
4caa						DMARK "BN2" 
4caa f5				push af  
4cab 3a bf 4c			ld a, (.dmark)  
4cae 32 77 fb			ld (debug_mark),a  
4cb1 3a c0 4c			ld a, (.dmark+1)  
4cb4 32 78 fb			ld (debug_mark+1),a  
4cb7 3a c1 4c			ld a, (.dmark+2)  
4cba 32 79 fb			ld (debug_mark+2),a  
4cbd 18 03			jr .pastdmark  
4cbf ..			.dmark: db "BN2"  
4cc2 f1			.pastdmark: pop af  
4cc3			endm  
# End of macro DMARK
4cc3						CALLMONITOR 
4cc3 cd 00 14			call break_point_state  
4cc6				endm  
# End of macro CALLMONITOR
4cc6					endif 
4cc6			 
4cc6					NEXTW 
4cc6 c3 7e 1b			jp macro_next 
4cc9				endm 
# End of macro NEXTW
4cc9			 
4cc9			.CARTDEV: 
4cc9				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4cc9 66				db WORD_SYS_CORE+82             
4cca 72 4d			dw .ENDDEVICE            
4ccc 08				db 7 + 1 
4ccd .. 00			db "CARTDEV",0              
4cd5				endm 
# End of macro CWHEAD
4cd5			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4cd5					if DEBUG_FORTH_WORDS_KEY 
4cd5						DMARK "CDV" 
4cd5 f5				push af  
4cd6 3a ea 4c			ld a, (.dmark)  
4cd9 32 77 fb			ld (debug_mark),a  
4cdc 3a eb 4c			ld a, (.dmark+1)  
4cdf 32 78 fb			ld (debug_mark+1),a  
4ce2 3a ec 4c			ld a, (.dmark+2)  
4ce5 32 79 fb			ld (debug_mark+2),a  
4ce8 18 03			jr .pastdmark  
4cea ..			.dmark: db "CDV"  
4ced f1			.pastdmark: pop af  
4cee			endm  
# End of macro DMARK
4cee						CALLMONITOR 
4cee cd 00 14			call break_point_state  
4cf1				endm  
# End of macro CALLMONITOR
4cf1					endif 
4cf1			 
4cf1					; disable se storage bank selection 
4cf1			 
4cf1 3e ff				ld a, SPI_CE_HIGH		; ce high 
4cf3 32 5c f8				ld (spi_device), a 
4cf6			 
4cf6					; get bank 
4cf6			 
4cf6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cf6 cd 28 1a			call macro_dsp_valuehl 
4cf9				endm 
# End of macro FORTH_DSP_VALUEHL
4cf9			 
4cf9			;		push hl 
4cf9			 
4cf9					; destroy value TOS 
4cf9			 
4cf9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cf9 cd c4 1a			call macro_forth_dsp_pop 
4cfc				endm 
# End of macro FORTH_DSP_POP
4cfc			 
4cfc					; one value on hl get other one back 
4cfc			 
4cfc			;		pop hl 
4cfc			 
4cfc					; active low 
4cfc			 
4cfc 0e ff				ld c, 255 
4cfe			 
4cfe 7d					ld a, l 
4cff					if DEBUG_FORTH_WORDS 
4cff						DMARK "CDV" 
4cff f5				push af  
4d00 3a 14 4d			ld a, (.dmark)  
4d03 32 77 fb			ld (debug_mark),a  
4d06 3a 15 4d			ld a, (.dmark+1)  
4d09 32 78 fb			ld (debug_mark+1),a  
4d0c 3a 16 4d			ld a, (.dmark+2)  
4d0f 32 79 fb			ld (debug_mark+2),a  
4d12 18 03			jr .pastdmark  
4d14 ..			.dmark: db "CDV"  
4d17 f1			.pastdmark: pop af  
4d18			endm  
# End of macro DMARK
4d18						CALLMONITOR 
4d18 cd 00 14			call break_point_state  
4d1b				endm  
# End of macro CALLMONITOR
4d1b					endif 
4d1b fe 00				cp 0 
4d1d 28 30				jr z, .cset 
4d1f fe 01				cp 1 
4d21 20 02				jr nz, .c2 
4d23 cb 81				res 0, c 
4d25 fe 02		.c2:		cp 2 
4d27 20 02				jr nz, .c3 
4d29 cb 89				res 1, c 
4d2b fe 03		.c3:		cp 3 
4d2d 20 02				jr nz, .c4 
4d2f cb 91				res 2, c 
4d31 fe 04		.c4:		cp 4 
4d33 20 02				jr nz, .c5 
4d35 cb 99				res 3, c 
4d37 fe 05		.c5:		cp 5 
4d39 20 02				jr nz, .c6 
4d3b cb a1				res 4, c 
4d3d fe 06		.c6:		cp 6 
4d3f 20 02				jr nz, .c7 
4d41 cb a9				res 5, c 
4d43 fe 07		.c7:		cp 7 
4d45 20 02				jr nz, .c8 
4d47 cb b1				res 6, c 
4d49 fe 08		.c8:		cp 8 
4d4b 20 02				jr nz, .cset 
4d4d cb b9				res 7, c 
4d4f 79			.cset:		ld a, c 
4d50 32 5f f8				ld (spi_cartdev),a 
4d53			 
4d53					if DEBUG_FORTH_WORDS 
4d53						DMARK "CD2" 
4d53 f5				push af  
4d54 3a 68 4d			ld a, (.dmark)  
4d57 32 77 fb			ld (debug_mark),a  
4d5a 3a 69 4d			ld a, (.dmark+1)  
4d5d 32 78 fb			ld (debug_mark+1),a  
4d60 3a 6a 4d			ld a, (.dmark+2)  
4d63 32 79 fb			ld (debug_mark+2),a  
4d66 18 03			jr .pastdmark  
4d68 ..			.dmark: db "CD2"  
4d6b f1			.pastdmark: pop af  
4d6c			endm  
# End of macro DMARK
4d6c						CALLMONITOR 
4d6c cd 00 14			call break_point_state  
4d6f				endm  
# End of macro CALLMONITOR
4d6f					endif 
4d6f					NEXTW 
4d6f c3 7e 1b			jp macro_next 
4d72				endm 
# End of macro NEXTW
4d72			endif 
4d72			 
4d72			.ENDDEVICE: 
4d72			; eof 
4d72			 
# End of file forth_words_device.asm
4d72			 
4d72			; var handler 
4d72			 
4d72			 
4d72			.VARS: 
4d72				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4d72 78				db WORD_SYS_CORE+100             
4d73 8a 4d			dw .V0Q            
4d75 04				db 3 + 1 
4d76 .. 00			db "V0!",0              
4d7a				endm 
# End of macro CWHEAD
4d7a			;| V0! ( u1 -- )  Store value to v0  | DONE 
4d7a			 
4d7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d7a cd 28 1a			call macro_dsp_valuehl 
4d7d				endm 
# End of macro FORTH_DSP_VALUEHL
4d7d			 
4d7d 11 25 f8				ld de, cli_var_array 
4d80			 
4d80 eb					ex de, hl 
4d81 73					ld (hl), e 
4d82 23					inc hl 
4d83 72					ld (hl), d 
4d84			 
4d84					; destroy value TOS 
4d84			 
4d84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d84 cd c4 1a			call macro_forth_dsp_pop 
4d87				endm 
# End of macro FORTH_DSP_POP
4d87			 
4d87				       NEXTW 
4d87 c3 7e 1b			jp macro_next 
4d8a				endm 
# End of macro NEXTW
4d8a			.V0Q: 
4d8a				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4d8a 79				db WORD_SYS_CORE+101             
4d8b 9b 4d			dw .V1S            
4d8d 04				db 3 + 1 
4d8e .. 00			db "V0@",0              
4d92				endm 
# End of macro CWHEAD
4d92			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4d92 2a 25 f8				ld hl, (cli_var_array) 
4d95 cd 8d 19				call forth_push_numhl 
4d98			 
4d98				       NEXTW 
4d98 c3 7e 1b			jp macro_next 
4d9b				endm 
# End of macro NEXTW
4d9b			.V1S: 
4d9b				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4d9b 7a				db WORD_SYS_CORE+102             
4d9c b3 4d			dw .V1Q            
4d9e 04				db 3 + 1 
4d9f .. 00			db "V1!",0              
4da3				endm 
# End of macro CWHEAD
4da3			;| V1! ( u1 -- )  Store value to v1 | DONE 
4da3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4da3 cd 28 1a			call macro_dsp_valuehl 
4da6				endm 
# End of macro FORTH_DSP_VALUEHL
4da6			 
4da6 11 27 f8				ld de, cli_var_array+2 
4da9				 
4da9 eb					ex de, hl 
4daa 73					ld (hl), e 
4dab 23					inc hl 
4dac 72					ld (hl), d 
4dad			 
4dad					; destroy value TOS 
4dad			 
4dad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dad cd c4 1a			call macro_forth_dsp_pop 
4db0				endm 
# End of macro FORTH_DSP_POP
4db0				       NEXTW 
4db0 c3 7e 1b			jp macro_next 
4db3				endm 
# End of macro NEXTW
4db3			.V1Q: 
4db3				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4db3 7b				db WORD_SYS_CORE+103             
4db4 c4 4d			dw .V2S            
4db6 04				db 3 + 1 
4db7 .. 00			db "V1@",0              
4dbb				endm 
# End of macro CWHEAD
4dbb			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4dbb 2a 27 f8				ld hl, (cli_var_array+2) 
4dbe cd 8d 19				call forth_push_numhl 
4dc1				       NEXTW 
4dc1 c3 7e 1b			jp macro_next 
4dc4				endm 
# End of macro NEXTW
4dc4			.V2S: 
4dc4				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4dc4 7c				db WORD_SYS_CORE+104             
4dc5 dc 4d			dw .V2Q            
4dc7 04				db 3 + 1 
4dc8 .. 00			db "V2!",0              
4dcc				endm 
# End of macro CWHEAD
4dcc			;| V2! ( u1 -- )  Store value to v2 | DONE 
4dcc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dcc cd 28 1a			call macro_dsp_valuehl 
4dcf				endm 
# End of macro FORTH_DSP_VALUEHL
4dcf			 
4dcf 11 29 f8				ld de, cli_var_array+4 
4dd2				 
4dd2 eb					ex de, hl 
4dd3 73					ld (hl), e 
4dd4 23					inc hl 
4dd5 72					ld (hl), d 
4dd6			 
4dd6					; destroy value TOS 
4dd6			 
4dd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dd6 cd c4 1a			call macro_forth_dsp_pop 
4dd9				endm 
# End of macro FORTH_DSP_POP
4dd9				       NEXTW 
4dd9 c3 7e 1b			jp macro_next 
4ddc				endm 
# End of macro NEXTW
4ddc			.V2Q: 
4ddc				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4ddc 7d				db WORD_SYS_CORE+105             
4ddd ed 4d			dw .V3S            
4ddf 04				db 3 + 1 
4de0 .. 00			db "V2@",0              
4de4				endm 
# End of macro CWHEAD
4de4			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4de4 2a 29 f8				ld hl, (cli_var_array+4) 
4de7 cd 8d 19				call forth_push_numhl 
4dea				       NEXTW 
4dea c3 7e 1b			jp macro_next 
4ded				endm 
# End of macro NEXTW
4ded			.V3S: 
4ded				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4ded 7c				db WORD_SYS_CORE+104             
4dee 05 4e			dw .V3Q            
4df0 04				db 3 + 1 
4df1 .. 00			db "V3!",0              
4df5				endm 
# End of macro CWHEAD
4df5			;| V3! ( u1 -- )  Store value to v3 | DONE 
4df5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4df5 cd 28 1a			call macro_dsp_valuehl 
4df8				endm 
# End of macro FORTH_DSP_VALUEHL
4df8			 
4df8 11 2b f8				ld de, cli_var_array+6 
4dfb				 
4dfb eb					ex de, hl 
4dfc 73					ld (hl), e 
4dfd 23					inc hl 
4dfe 72					ld (hl), d 
4dff			 
4dff					; destroy value TOS 
4dff			 
4dff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dff cd c4 1a			call macro_forth_dsp_pop 
4e02				endm 
# End of macro FORTH_DSP_POP
4e02				       NEXTW 
4e02 c3 7e 1b			jp macro_next 
4e05				endm 
# End of macro NEXTW
4e05			.V3Q: 
4e05				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4e05 7d				db WORD_SYS_CORE+105             
4e06 16 4e			dw .END            
4e08 04				db 3 + 1 
4e09 .. 00			db "V3@",0              
4e0d				endm 
# End of macro CWHEAD
4e0d			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4e0d 2a 2b f8				ld hl, (cli_var_array+6) 
4e10 cd 8d 19				call forth_push_numhl 
4e13				       NEXTW 
4e13 c3 7e 1b			jp macro_next 
4e16				endm 
# End of macro NEXTW
4e16			 
4e16			 
4e16			 
4e16			 
4e16			 
4e16			; end of dict marker 
4e16			 
4e16 00			.END:    db WORD_SYS_END 
4e17 00 00			dw 0 
4e19 00				db 0 
4e1a			 
4e1a			; use to jp here for user dict words to save on macro expansion  
4e1a			 
4e1a			user_dict_next: 
4e1a				NEXTW 
4e1a c3 7e 1b			jp macro_next 
4e1d				endm 
# End of macro NEXTW
4e1d			 
4e1d			 
4e1d			user_exec: 
4e1d				;    ld hl, <word code> 
4e1d				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4e1d				;    call forthexec 
4e1d				;    jp user_dict_next   (NEXT) 
4e1d			        ;    <word code bytes> 
4e1d eb				ex de, hl 
4e1e 2a 33 f1			ld hl,(os_tok_ptr) 
4e21				 
4e21				FORTH_RSP_NEXT 
4e21 cd 34 19			call macro_forth_rsp_next 
4e24				endm 
# End of macro FORTH_RSP_NEXT
4e24			 
4e24			if DEBUG_FORTH_UWORD 
4e24						DMARK "UEX" 
4e24 f5				push af  
4e25 3a 39 4e			ld a, (.dmark)  
4e28 32 77 fb			ld (debug_mark),a  
4e2b 3a 3a 4e			ld a, (.dmark+1)  
4e2e 32 78 fb			ld (debug_mark+1),a  
4e31 3a 3b 4e			ld a, (.dmark+2)  
4e34 32 79 fb			ld (debug_mark+2),a  
4e37 18 03			jr .pastdmark  
4e39 ..			.dmark: db "UEX"  
4e3c f1			.pastdmark: pop af  
4e3d			endm  
# End of macro DMARK
4e3d				CALLMONITOR 
4e3d cd 00 14			call break_point_state  
4e40				endm  
# End of macro CALLMONITOR
4e40			endif 
4e40			 
4e40			 
4e40			 
4e40 eb				ex de, hl 
4e41 22 33 f1			ld (os_tok_ptr), hl 
4e44				 
4e44				; Don't use next - Skips the first word in uword. 
4e44			 
4e44 c3 0f 1c			jp exec1 
4e47			;	NEXT 
4e47			 
4e47			 
4e47			; eof 
# End of file forth_wordsv4.asm
4e47			endif 
4e47			;;;;;;;;;;;;;; Debug code 
4e47			 
4e47			 
4e47			;if DEBUG_FORTH_PARSE 
4e47 .. 00		.nowordfound: db "No match",0 
4e50 .. 00		.compword:	db "Comparing word ",0 
4e60 .. 00		.nextwordat:	db "Next word at",0 
4e6d .. 00		.charmatch:	db "Char match",0 
4e78			;endif 
4e78			if DEBUG_FORTH_JP 
4e78			.foundword:	db "Word match. Exec..",0 
4e78			endif 
4e78			;if DEBUG_FORTH_PUSH 
4e78 .. 00		.enddict:	db "Dict end. Push.",0 
4e88 .. 00		.push_str:	db "Pushing string",0 
4e97 .. 00		.push_num:	db "Pushing number",0 
4ea6 .. 00		.data_sp:	db "SP:",0 
4eaa .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ebc .. 00		.wordinde:	db "Word in DE (3/0):",0 
4ece .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4ee0			;endif 
4ee0			;if DEBUG_FORTH_MALLOC 
4ee0 .. 00		.push_malloc:	db "Malloc address",0 
4eef			;endif 
4eef			 
4eef			 
4eef			 
4eef			; display malloc address and current data stack pointer  
4eef			 
4eef			malloc_error: 
4eef d5				push de 
4ef0 f5				push af 
4ef1 e5				push hl 
4ef2 cd b9 0a			call clear_display 
4ef5 11 17 4f			ld de, .mallocerr 
4ef8 3e 00			ld a,0 
4efa			;	ld de,os_word_scratch 
4efa cd cc 0a			call str_at_display 
4efd 3e 11			ld a, display_row_1+17 
4eff 11 77 fb			ld de, debug_mark 
4f02 cd cc 0a			call str_at_display 
4f05 cd dc 0a			call update_display 
4f08				;call break_point_state 
4f08 cd e8 64			call cin_wait 
4f0b			 
4f0b 3e 20			ld a, ' ' 
4f0d 32 31 ee			ld (os_view_disable), a 
4f10 e1				pop hl 
4f11 f1				pop af 
4f12 d1				pop de	 
4f13				CALLMONITOR 
4f13 cd 00 14			call break_point_state  
4f16				endm  
# End of macro CALLMONITOR
4f16 c9				ret 
4f17			 
4f17 .. 00		.mallocerr: 	db "Malloc Error",0 
4f24			;if DEBUG_FORTH_PUSH 
4f24			display_data_sp: 
4f24 f5				push af 
4f25			 
4f25				; see if disabled 
4f25			 
4f25 3a 31 ee			ld a, (os_view_disable) 
4f28 fe 2a			cp '*' 
4f2a 28 67			jr z, .skipdsp 
4f2c			 
4f2c e5				push hl 
4f2d e5				push hl 
4f2e e5			push hl 
4f2f cd b9 0a			call clear_display 
4f32 e1			pop hl 
4f33 7c				ld a,h 
4f34 21 37 f1			ld hl, os_word_scratch 
4f37 cd 13 0f			call hexout 
4f3a e1				pop hl 
4f3b 7d				ld a,l 
4f3c 21 39 f1			ld hl, os_word_scratch+2 
4f3f cd 13 0f			call hexout 
4f42 21 3b f1			ld hl, os_word_scratch+4 
4f45 3e 00			ld a,0 
4f47 77				ld (hl),a 
4f48 11 37 f1			ld de,os_word_scratch 
4f4b 3e 28				ld a, display_row_2 
4f4d cd cc 0a				call str_at_display 
4f50 11 aa 4e			ld de, .wordinhl 
4f53 3e 00			ld a, display_row_1 
4f55			 
4f55 cd cc 0a				call str_at_display 
4f58 11 77 fb			ld de, debug_mark 
4f5b 3e 11			ld a, display_row_1+17 
4f5d			 
4f5d cd cc 0a				call str_at_display 
4f60			 
4f60				; display current data stack pointer 
4f60 11 a6 4e			ld de,.data_sp 
4f63 3e 30				ld a, display_row_2 + 8 
4f65 cd cc 0a				call str_at_display 
4f68			 
4f68 2a 1f f8			ld hl,(cli_data_sp) 
4f6b e5				push hl 
4f6c 7c				ld a,h 
4f6d 21 37 f1			ld hl, os_word_scratch 
4f70 cd 13 0f			call hexout 
4f73 e1				pop hl 
4f74 7d				ld a,l 
4f75 21 39 f1			ld hl, os_word_scratch+2 
4f78 cd 13 0f			call hexout 
4f7b 21 3b f1			ld hl, os_word_scratch+4 
4f7e 3e 00			ld a,0 
4f80 77				ld (hl),a 
4f81 11 37 f1			ld de,os_word_scratch 
4f84 3e 33				ld a, display_row_2 + 11 
4f86 cd cc 0a				call str_at_display 
4f89			 
4f89			 
4f89 cd dc 0a			call update_display 
4f8c cd 3d 0a			call delay1s 
4f8f cd 3d 0a			call delay1s 
4f92 e1				pop hl 
4f93			.skipdsp: 
4f93 f1				pop af 
4f94 c9				ret 
4f95			 
4f95			display_data_malloc: 
4f95			 
4f95 f5				push af 
4f96 e5				push hl 
4f97 e5				push hl 
4f98 e5			push hl 
4f99 cd b9 0a			call clear_display 
4f9c e1			pop hl 
4f9d 7c				ld a,h 
4f9e 21 37 f1			ld hl, os_word_scratch 
4fa1 cd 13 0f			call hexout 
4fa4 e1				pop hl 
4fa5 7d				ld a,l 
4fa6 21 39 f1			ld hl, os_word_scratch+2 
4fa9 cd 13 0f			call hexout 
4fac 21 3b f1			ld hl, os_word_scratch+4 
4faf 3e 00			ld a,0 
4fb1 77				ld (hl),a 
4fb2 11 37 f1			ld de,os_word_scratch 
4fb5 3e 28				ld a, display_row_2 
4fb7 cd cc 0a				call str_at_display 
4fba 11 e0 4e			ld de, .push_malloc 
4fbd 3e 00			ld a, display_row_1 
4fbf			 
4fbf cd cc 0a				call str_at_display 
4fc2			 
4fc2				; display current data stack pointer 
4fc2 11 a6 4e			ld de,.data_sp 
4fc5 3e 30				ld a, display_row_2 + 8 
4fc7 cd cc 0a				call str_at_display 
4fca			 
4fca 2a 1f f8			ld hl,(cli_data_sp) 
4fcd e5				push hl 
4fce 7c				ld a,h 
4fcf 21 37 f1			ld hl, os_word_scratch 
4fd2 cd 13 0f			call hexout 
4fd5 e1				pop hl 
4fd6 7d				ld a,l 
4fd7 21 39 f1			ld hl, os_word_scratch+2 
4fda cd 13 0f			call hexout 
4fdd 21 3b f1			ld hl, os_word_scratch+4 
4fe0 3e 00			ld a,0 
4fe2 77				ld (hl),a 
4fe3 11 37 f1			ld de,os_word_scratch 
4fe6 3e 33				ld a, display_row_2 + 11 
4fe8 cd cc 0a				call str_at_display 
4feb			 
4feb cd dc 0a			call update_display 
4fee cd 3d 0a			call delay1s 
4ff1 cd 3d 0a			call delay1s 
4ff4 e1				pop hl 
4ff5 f1				pop af 
4ff6 c9				ret 
4ff7			;endif 
4ff7			 
4ff7			include "forth_autostart.asm" 
4ff7			; list of commands to perform at system start up 
4ff7			 
4ff7			startcmds: 
4ff7			;	dw test11 
4ff7			;	dw test12 
4ff7			;	dw test13 
4ff7			;	dw test14 
4ff7			;	dw test15 
4ff7			;	dw test16 
4ff7			;	dw test17 
4ff7			;	dw ifthtest1 
4ff7			;	dw ifthtest2 
4ff7			;	dw ifthtest3 
4ff7			;	dw mmtest1 
4ff7			;	dw mmtest2 
4ff7			;	dw mmtest3 
4ff7			;	dw mmtest4 
4ff7			;	dw mmtest5 
4ff7			;	dw mmtest6 
4ff7			;	dw iftest1 
4ff7			;	dw iftest2 
4ff7			;	dw iftest3 
4ff7			;	dw looptest1 
4ff7			;	dw looptest2 
4ff7			;	dw test1 
4ff7			;	dw test2 
4ff7			;	dw test3 
4ff7			;	dw test4 
4ff7			;	dw game2r 
4ff7			;	dw game2b1 
4ff7			;	dw game2b2 
4ff7			 
4ff7				; start up words that are actually useful 
4ff7			 
4ff7 55 50			dw clrstack 
4ff9 88 50			dw type 
4ffb 49 52			dw stest 
4ffd ac 50			dw strncpy 
4fff ea 51			dw list 
5001 0d 51			dw start1 
5003 1f 51			dw start2 
5005			;	dw start3 
5005 32 51			dw start3b 
5007 8a 51			dw start3c 
5009			 
5009				; (unit) testing words 
5009			 
5009 c0 52			dw mtesta 
500b 75 53			dw mtestb 
500d 18 54			dw mtestc 
500f cd 54			dw mtestd 
5011 71 55			dw mteste 
5013			 
5013				; demo/game words 
5013			 
5013 7d 5c		        dw game3w 
5015 ab 5c		        dw game3p 
5017 c9 5c		        dw game3sc 
5019 fa 5c		        dw game3vsi 
501b 26 5d		        dw game3vs 
501d				 
501d 70 5a			dw game2b 
501f de 5a			dw game2bf 
5021 28 5b			dw game2mba 
5023 be 5b			dw game2mbas 
5025 00 5c			dw game2mb 
5027			 
5027 31 57			dw game1 
5029 42 57			dw game1a 
502b a4 57			dw game1b 
502d d9 57			dw game1c 
502f 0f 58			dw game1d 
5031 40 58			dw game1s 
5033 54 58			dw game1t 
5035 69 58			dw game1f 
5037 9d 58			dw game1z 
5039 e1 58			dw game1zz 
503b			 
503b 27 56			dw test5 
503d 5f 56			dw test6 
503f 97 56			dw test7 
5041 ab 56			dw test8 
5043 d7 56			dw test9 
5045 ed 56			dw test10 
5047				 
5047 b8 59		        dw ssv5 
5049 9c 59		        dw ssv4 
504b 80 59		        dw ssv3 
504d 4a 59		        dw ssv2 
504f d1 59		        dw ssv1 
5051 19 5a		        dw ssv1cpm 
5053			;	dw keyup 
5053			;	dw keydown 
5053			;	dw keyleft 
5053			;	dw keyright 
5053			;	dw 	keyf1 
5053			;	dw keyf2 
5053			;	dw keyf3 
5053			;	dw keyf4 
5053			;	dw keyf5 
5053			;	dw keyf6 
5053			;	dw keyf7 
5053			;	dw keyf8 
5053			;	dw keyf9 
5053			;	dw keyf10 
5053			;	dw keyf11 
5053			;	dw keyf12 
5053			;	dw keytab 
5053			;	dw keycr 
5053			;	dw keyhome 
5053			;	dw keyend 
5053			;	dw keybs 
5053 00 00			db 0, 0	 
5055			 
5055			 
5055			; clear stack  
5055			 
5055 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5088			 
5088			; type ( addr count - ) 
5088 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
50ac			 
50ac			; some direct memory words 
50ac			; strncpy ( len t f -- t ) 
50ac			 
50ac .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
510d			 
510d .. 00		start1:     	db ": bpon $0000 bp ;",0 
511f .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5132			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5132 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
518a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
51ea			 
51ea			 
51ea			; a handy word to list items on the stack 
51ea			 
51ea .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5249			 
5249			 
5249			; test stack  
5249			; rnd8 stest 
5249			 
5249 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
52c0			 
52c0			; random malloc and free cycles 
52c0			 
52c0 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5375			 
5375			; fixed malloc and free cycles 
5375			 
5375 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5418			 
5418			; fixed double string push and drop cycle  
5418			 
5418 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
54cd			 
54cd			; consistent fixed string push and drop cycle  
54cd			 
54cd .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5571			 
5571 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5627			 
5627			;test1:		db ": aa 1 2 3 ;", 0 
5627			;test2:     	db "111 aa 888 999",0 
5627			;test3:     	db ": bb 77 ;",0 
5627			;test4:     	db "$02 $01 do i . loop bb",0 
5627			 
5627 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
565f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5697 .. 00		test7:     	db ": box hline vline ;",0 
56ab .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
56d7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
56ed .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5712 .. 00		test11:     	db "hello create .",0 
5721 .. 00		test12:     	db "hello2 create .",0 
5731			 
5731			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5731			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5731			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5731			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5731			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5731			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5731			 
5731			;iftest1:     	db "$0001 IF cls .",0 
5731			;iftest2:     	db "$0000 IF cls .",0 
5731			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5731			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5731			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5731			 
5731			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5731			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5731			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5731			 
5731			 
5731			 
5731			; a small guess the number game 
5731			 
5731 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5742 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
57a4			 
57a4 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
57d9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
580f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5840 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5854 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5869 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
589d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
58e1			 
58e1			; Using 'ga' save a high score across multiple runs using external storage 
58e1			 
58e1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
594a			 
594a			 
594a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
594a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
594a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
594a			 
594a			; simple screen saver to test code memory reuse to destruction 
594a			 
594a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5980 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
599c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
59b8 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
59d1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a19 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5a70			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a70			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5a70			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5a70			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5a70			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5a70			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5a70			 
5a70			 
5a70			 
5a70			; minesweeper/battleship finding game 
5a70			; draws a game board of random ship/mine positions 
5a70			; user enters coords to see if it hits on 
5a70			; game ends when all are hit 
5a70			; when hit or miss says how many may be in the area 
5a70			 
5a70			; setup the game board and then hide it 
5a70 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5ade .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5b28			; prompt for where to target 
5b28 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5bbe .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5be3			; TODO see if the entered coords hits or misses pushes char hit of miss 
5be3 .. 00		game2mbht:      db ": mbckht nop ;",0 
5bf2 .. 00		game2mbms:      db ": mbcms nop ;",0 
5c00			; TODO how many might be near by 
5c00 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5c7d			 
5c7d			; Game 3 
5c7d			 
5c7d			; Vert scroller ski game - avoid the trees! 
5c7d			 
5c7d			; v0 score (ie turns) 
5c7d			; v1 player pos 
5c7d			; v2 left wall 
5c7d			; v3 right wall 
5c7d			 
5c7d			; Draw side walls randomly 
5c7d			 
5c7d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5cab			 
5cab			; Draw player 
5cab .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5cc9			 
5cc9			; TODO Get Key 
5cc9			 
5cc9			; TODO Move left right 
5cc9			 
5cc9			; scroll and move walls a bit 
5cc9			 
5cc9 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5cfa			 
5cfa			; main game loop 
5cfa			 
5cfa .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5d26 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5d65			 
5d65			; key board defs 
5d65			 
5d65 .. 00		keyup:       db ": keyup $05 ;",0 
5d73 .. 00		keydown:       db ": keydown $0a ;",0 
5d83 .. 00		keyleft:       db ": keyleft $0b ;",0 
5d93 .. 00		keyright:       db ": keyright $0c ;",0 
5da4 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5db2 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5dc0 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5dce .. 00		keyf4:       db ": keyf4 $13 ;",0 
5ddc .. 00		keyf5:       db ": keyf5 $14 ;",0 
5dea .. 00		keyf6:       db ": keyf6 $15 ;",0 
5df8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5e06 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5e14 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5e22 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5e31 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5e40 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5e4f			 
5e4f .. 00		keytab:       db ": keytab $09 ;",0 
5e5e .. 00		keycr:       db ": keycr $0d ;",0 
5e6c .. 00		keyhome:       db ": keyhome $0e ;",0 
5e7c .. 00		keyend:       db ": keyend $0f ;",0 
5e8b .. 00		keybs:       db ": keybs $08 ;",0 
5e99			 
5e99			   
5e99			 
5e99			 
5e99			 
5e99			; eof 
# End of file forth_autostart.asm
5e99			 
5e99 .. 00		sprompt1: db "Startup load...",0 
5ea9 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5ebf			 
5ebf			forth_startup: 
5ebf 21 f7 4f			ld hl, startcmds 
5ec2 3e 00			ld a, 0 
5ec4 32 58 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5ec7			 
5ec7 e5			.start1:	push hl 
5ec8 cd b9 0a			call clear_display 
5ecb 11 99 5e			ld de, sprompt1 
5ece 3e 00		        ld a, display_row_1 
5ed0 cd cc 0a			call str_at_display 
5ed3 11 a9 5e			ld de, sprompt2 
5ed6 3e 28		        ld a, display_row_2 
5ed8 cd cc 0a			call str_at_display 
5edb e1				pop hl 
5edc e5				push hl 
5edd 5e				ld e,(hl) 
5ede 23				inc hl 
5edf 56				ld d,(hl) 
5ee0 3e 50		        ld a, display_row_3 
5ee2 cd cc 0a			call str_at_display 
5ee5 cd dc 0a			call update_display 
5ee8			 
5ee8			 
5ee8 3a 58 f2			ld a, (os_last_cmd) 
5eeb fe 00			cp 0 
5eed 28 05			jr z, .startprompt 
5eef cd 31 0a			call delay250ms 
5ef2 18 24			jr .startdo 
5ef4				 
5ef4				 
5ef4			 
5ef4			.startprompt: 
5ef4			 
5ef4 3e 9f			ld a,display_row_4 + display_cols - 1 
5ef6 11 03 19		        ld de, endprg 
5ef9 cd cc 0a			call str_at_display 
5efc cd dc 0a			call update_display 
5eff cd 3d 0a			call delay1s 
5f02 cd e8 64			call cin_wait 
5f05						 
5f05 fe 2a			cp '*' 
5f07 28 5e			jr z, .startupend1 
5f09 fe 23			cp '#' 
5f0b 20 07			jr nz, .startno 
5f0d 3e 01			ld a, 1 
5f0f 32 58 f2			ld (os_last_cmd),a 
5f12 18 04			jr .startdo 
5f14 fe 31		.startno:	cp '1' 
5f16 28 3a			jr z,.startnxt  
5f18			 
5f18				; exec startup line 
5f18			.startdo:	 
5f18 e1				pop hl 
5f19 e5				push hl 
5f1a				 
5f1a 5e				ld e,(hl) 
5f1b 23				inc hl 
5f1c 56				ld d,(hl) 
5f1d eb				ex de,hl 
5f1e			 
5f1e e5				push hl 
5f1f			 
5f1f 3e 00			ld a, 0 
5f21				;ld a, FORTH_END_BUFFER 
5f21 cd 7b 10			call strlent 
5f24 23				inc hl   ; include zero term to copy 
5f25 06 00			ld b,0 
5f27 4d				ld c,l 
5f28 e1				pop hl 
5f29 11 32 ee			ld de, scratch 
5f2c ed b0			ldir 
5f2e			 
5f2e			 
5f2e 21 32 ee			ld hl, scratch 
5f31 cd cc 1b			call forthparse 
5f34 cd 0c 1c			call forthexec 
5f37 cd 23 1b			call forthexec_cleanup 
5f3a			 
5f3a 3e 78			ld a, display_row_4 
5f3c 11 a7 16			ld de, endprog 
5f3f			 
5f3f cd dc 0a			call update_display		 
5f42			 
5f42 3a 58 f2			ld a, (os_last_cmd) 
5f45 fe 00			cp 0 
5f47 20 09			jr nz, .startnxt 
5f49 cd 05 19			call next_page_prompt 
5f4c cd b9 0a		        call clear_display 
5f4f cd dc 0a			call update_display		 
5f52			 
5f52				; move onto next startup line? 
5f52			.startnxt: 
5f52			 
5f52 cd 31 0a			call delay250ms 
5f55 e1				pop hl 
5f56			 
5f56 23				inc hl 
5f57 23				inc hl 
5f58			 
5f58 e5				push hl 
5f59 5e				ld e, (hl) 
5f5a 23				inc hl 
5f5b 56				ld d, (hl) 
5f5c e1				pop hl 
5f5d				; TODO replace 0 test 
5f5d			 
5f5d eb				ex de, hl 
5f5e cd 3b 0c			call ishlzero 
5f61			;	ld a,e 
5f61			;	add d 
5f61			;	cp 0    ; any left to do? 
5f61 eb				ex de, hl 
5f62 c2 c7 5e			jp nz, .start1 
5f65 18 01			jr .startupend 
5f67			 
5f67 e1			.startupend1: pop hl 
5f68			.startupend: 
5f68			 
5f68 cd b9 0a			call clear_display 
5f6b cd dc 0a			call update_display 
5f6e c9				ret 
5f6f			 
5f6f			 
5f6f			; stack over and underflow checks 
5f6f			 
5f6f			; init the words to detect the under/overflow 
5f6f			 
5f6f			chk_stk_init: 
5f6f				; a vague random number to check so we dont get any "lucky" hits 
5f6f 3e 2d			ld a, 45 
5f71 6f				ld l, a 
5f72 00				nop 
5f73 3e 17			ld a, 23 
5f75 67				ld h, a 
5f76			 
5f76 22 27 ee			ld (chk_word), hl     ; the word we need to check against 
5f79			 
5f79			;	ld (chk_stund), hl	; stack points.... 
5f79 22 fd fb			ld (chk_stovr), hl 
5f7c 22 1d f8			ld (chk_ret_und), hl 
5f7f 22 9b f7			ld (chk_ret_ovr), hl 
5f82 22 99 f5			ld (chk_loop_ovr), hl 
5f85 22 97 f3			ld (chk_data_ovr), hl 
5f88 c9				ret 
5f89				 
5f89			check_stacks: 
5f89				; check all stack words 
5f89			 
5f89 e5				push hl 
5f8a d5				push de 
5f8b			 
5f8b			;	ld de,(chk_word) 
5f8b			;	ld hl, (chk_stund)	; stack points.... 
5f8b			;	if DEBUG_STK_FAULT 
5f8b			;		DMARK "FAa" 
5f8b			;		CALLMONITOR 
5f8b			;	endif 
5f8b			;	call cmp16 
5f8b			;	jp z, .chk_faulta 
5f8b			; 
5f8b			;	ld de, sfaultsu 
5f8b			;	jp .chk_fault 
5f8b			 
5f8b 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5f8e ed 5b 27 ee		ld de,(chk_word) 
5f92				if DEBUG_STK_FAULT 
5f92					DMARK "FAb" 
5f92					CALLMONITOR 
5f92				endif 
5f92 cd 30 0c			call cmp16 
5f95 28 06			jr z, .chk_fault1 
5f97 11 38 60			ld de, sfaultso 
5f9a c3 ec 5f			jp .chk_fault 
5f9d			.chk_fault1:  
5f9d 2a 1d f8			ld hl, (chk_ret_und) 
5fa0 ed 5b 27 ee		ld de,(chk_word) 
5fa4				if DEBUG_STK_FAULT 
5fa4					DMARK "FAU" 
5fa4					CALLMONITOR 
5fa4				endif 
5fa4 cd 30 0c			call cmp16 
5fa7 ca b0 5f			jp z, .chk_fault2 
5faa 11 48 60			ld de, sfaultru 
5fad c3 ec 5f			jp .chk_fault 
5fb0			.chk_fault2:  
5fb0 2a 9b f7			ld hl, (chk_ret_ovr) 
5fb3 ed 5b 27 ee		ld de,(chk_word) 
5fb7				if DEBUG_STK_FAULT 
5fb7					DMARK "FA1" 
5fb7					CALLMONITOR 
5fb7				endif 
5fb7 cd 30 0c			call cmp16 
5fba ca c3 5f			jp z, .chk_fault3 
5fbd 11 56 60			ld de, sfaultro 
5fc0 c3 ec 5f			jp .chk_fault 
5fc3			.chk_fault3:  
5fc3 2a 99 f5			ld hl, (chk_loop_ovr) 
5fc6 ed 5b 27 ee		ld de,(chk_word) 
5fca				if DEBUG_STK_FAULT 
5fca					DMARK "FA2" 
5fca					CALLMONITOR 
5fca				endif 
5fca cd 30 0c			call cmp16 
5fcd ca d6 5f			jp z, .chk_fault4 
5fd0 11 70 60			ld de, sfaultlo 
5fd3 c3 ec 5f			jp .chk_fault 
5fd6			.chk_fault4:  
5fd6 2a 97 f3			ld hl, (chk_data_ovr) 
5fd9 ed 5b 27 ee		ld de,(chk_word) 
5fdd				if DEBUG_STK_FAULT 
5fdd					DMARK "FA3" 
5fdd					CALLMONITOR 
5fdd				endif 
5fdd cd 30 0c			call cmp16 
5fe0 ca e9 5f			jp z, .chk_fault5 
5fe3 11 8a 60			ld de, sfaultdo 
5fe6 c3 ec 5f			jp .chk_fault 
5fe9			 
5fe9			 
5fe9			.chk_fault5:  
5fe9 d1				pop de 
5fea e1				pop hl 
5feb			 
5feb c9				ret 
5fec			 
5fec cd b9 0a		.chk_fault: 	call clear_display 
5fef 3e 28				ld a, display_row_2 
5ff1 cd cc 0a				call str_at_display 
5ff4 11 1a 60				   ld de, .stackfault 
5ff7 3e 00				ld a, display_row_1 
5ff9 cd cc 0a				call str_at_display 
5ffc 11 77 fb				    ld de, debug_mark 
5fff 3e 11				ld a, display_row_1+17 
6001 cd cc 0a				call str_at_display 
6004 cd dc 0a				call update_display 
6007			 
6007				; prompt before entering montior for investigating issue 
6007			 
6007 3e 78			ld a, display_row_4 
6009 11 a7 16			ld de, endprog 
600c			 
600c cd dc 0a			call update_display		 
600f			 
600f cd 05 19			call next_page_prompt 
6012			 
6012 d1				pop de 
6013 e1				pop hl 
6014 cd fb 16				call monitor 
6017 c3 f5 15				jp warmstart 
601a					;jp 0 
601a					;halt 
601a			 
601a			 
601a			 
601a .. 00		.stackfault: 	db "Stack fault:",0 
6027			 
6027 .. 00		sfaultsu: 	db	"Stack under flow",0 
6038 .. 00		sfaultso: 	db	"Stack over flow",0 
6048 .. 00		sfaultru:	db "RTS underflow",0 
6056 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6070 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
608a .. 00		sfaultdo:	db "DTS overflow", 0 
6097			 
6097			 
6097			fault_dsp_under: 
6097 11 a9 60			ld de, .dsp_under 
609a c3 59 61			jp .show_fault 
609d			 
609d			fault_rsp_under: 
609d 11 b7 60			ld de, .rsp_under 
60a0 c3 59 61			jp .show_fault 
60a3			fault_loop_under: 
60a3 11 c5 60			ld de, .loop_under 
60a6 c3 59 61			jp .show_fault 
60a9			 
60a9 .. 00		.dsp_under: db "DSP Underflow",0 
60b7 .. 00		.rsp_under: db "RSP Underflow",0 
60c5 .. 00		.loop_under: db "LOOP Underflow",0 
60d4			 
60d4			 
60d4 d5			type_faultn: 	push de 
60d5 e5					push hl 
60d6 cd b9 0a				call clear_display 
60d9 11 00 61				   ld de, .typefaultn 
60dc 3e 00				ld a, display_row_1 
60de cd cc 0a				call str_at_display 
60e1 11 77 fb				    ld de, debug_mark 
60e4 3e 11				ld a, display_row_1+17 
60e6 cd cc 0a				call str_at_display 
60e9 cd dc 0a				call update_display 
60ec			 
60ec				; prompt before entering montior for investigating issue 
60ec			 
60ec 3e 78			ld a, display_row_4 
60ee 11 a7 16			ld de, endprog 
60f1			 
60f1 cd dc 0a			call update_display		 
60f4			 
60f4 cd 05 19			call next_page_prompt 
60f7			 
60f7 e5					push hl 
60f8 d5					push de 
60f9 cd fb 16				call monitor 
60fc c3 f5 15				jp warmstart 
60ff 76					halt 
6100			 
6100			 
6100 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6117			 
6117 d5			type_faults: 	push de 
6118 e5					push hl 
6119 cd b9 0a				call clear_display 
611c 11 42 61				   ld de, .typefaults 
611f 3e 00				ld a, display_row_1 
6121 cd cc 0a				call str_at_display 
6124 11 77 fb				    ld de, debug_mark 
6127 3e 11				ld a, display_row_1+17 
6129 cd cc 0a				call str_at_display 
612c cd dc 0a				call update_display 
612f			 
612f				; prompt before entering montior for investigating issue 
612f			 
612f 3e 78			ld a, display_row_4 
6131 11 a7 16			ld de, endprog 
6134			 
6134 cd dc 0a			call update_display		 
6137			 
6137 cd 05 19			call next_page_prompt 
613a			 
613a e1					pop hl 
613b d1					pop de 
613c cd fb 16				call monitor 
613f c3 f5 15				jp warmstart 
6142			 
6142			 
6142 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6159			 
6159			.show_fault: 	 
6159 d5					push de 
615a cd b9 0a				call clear_display 
615d d1					pop de 
615e 3e 00				ld a, display_row_1 
6160 cd cc 0a				call str_at_display 
6163 11 77 fb				    ld de, debug_mark 
6166 3e 11				ld a, display_row_1+17 
6168 cd cc 0a				call str_at_display 
616b cd dc 0a				call update_display 
616e			 
616e				; prompt before entering montior for investigating issue 
616e			 
616e 3e 78			ld a, display_row_4 
6170 11 a7 16			ld de, endprog 
6173			 
6173 cd dc 0a			call update_display		 
6176			 
6176 cd 05 19			call next_page_prompt 
6179			 
6179 e1					pop hl 
617a d1					pop de 
617b cd fb 16				call monitor 
617e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
617e			; TODO Make optional fault restart to cli or warm boot? 
617e					;jp warmstart 
617e c3 4d 16				jp cli 
6181 76					halt 
6182			; eof 
# End of file forth_kernel.asm
6182			;include "nascombasic.asm" 
6182			 
6182			 
6182			; find out where the code ends if loaded into RAM (for SC114) 
6182			;endofcode:  
6182			;	nop 
6182			 
6182			 
6182			; eof 
6182			 
# End of file main.asm
6182			include "firmware_lcd_4x40.asm" 
6182			; **********************************************************************  
6182			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6182			; **********************************************************************  
6182			;  
6182			; **  Written as a Small Computer Monitor App  
6182			; **  www.scc.me.uk  
6182			;  
6182			; History  
6182			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6182			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6182			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6182			;  
6182			; **********************************************************************  
6182			;  
6182			; This program is an example of one of the methods of interfacing an   
6182			; alphanumeric LCD module.   
6182			;  
6182			; In this example the display is connected to either a Z80 PIO or a   
6182			; simple 8-bit output port.   
6182			;  
6182			; This interfacing method uses 4-bit data mode and uses time delays  
6182			; rather than polling the display's ready status. As a result the   
6182			; interface only requires 6 simple output lines:  
6182			;   Output bit 0 = not used  
6182			;   Output bit 1 = not used  
6182			;   Output bit 2 = RS         High = data, Low = instruction  
6182			;   Output bit 3 = E          Active high  
6182			;   Output bit 4 = DB4  
6182			;   Output bit 5 = DB5  
6182			;   Output bit 6 = DB6  
6182			;   Output bit 7 = DB7  
6182			; Display's R/W is connected to 0v so it is always in write mode  
6182			;  
6182			; This set up should work with any system supporting the RC2014 bus  
6182			  
6182			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6182			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6182			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6182			;  
6182			; **********************************************************************  
6182			  
6182			; Additonal for 4x40. E1 and E2 instead of just E   
6182			; TODO swipe vidout signal on port a to activate E2  
6182			  
6182			; **********************************************************************  
6182			; **  Constants  
6182			; **********************************************************************  
6182			; LCD constants required by LCD support module  
6182			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6182			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6182			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6182			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6182			; TODO Decide which E is being set  
6182			kLCDWidth:  EQU display_cols             ;Width in characters  
6182			  
6182			; **********************************************************************  
6182			; **  Code library usage  
6182			; **********************************************************************  
6182			  
6182			; send character to current cursor position  
6182			; wraps and/or scrolls screen automatically  
6182			  
6182			  
6182			  
6182			lcd_init:  
6182			  
6182			; SCMonAPI functions used  
6182			  
6182			; Alphanumeric LCD functions used  
6182			; no need to specify specific functions for this module  
6182			  
6182 3e cf		            LD   A, 11001111b  
6184 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6186 3e 00		            LD   A, 00000000b  
6188 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
618a			  
618a			; Initialise alphanumeric LCD module  
618a 3e 00				ld a, 0  
618c 32 d7 f8				ld (display_lcde1e2), a  
618f cd 10 62		            CALL fLCD_Init      ;Initialise LCD module  
6192 3e 01				ld a, 1  
6194 32 d7 f8				ld (display_lcde1e2), a  
6197 cd 10 62		            CALL fLCD_Init      ;Initialise LCD module  
619a			  
619a c9				ret  
619b			  
619b			;  
619b			;;  
619b			; lcd functions  
619b			;  
619b			;  
619b			  
619b			; what is at cursor position   
619b			  
619b			;get_cursor:	ld de, (cursor_row)   ;  row + col  
619b			;		call curptr  
619b			;		ret  
619b			  
619b			  
619b			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
619b			  
619b			curptr:  
619b c5				push bc  
619c 21 bd fa			ld hl, display_fb0  
619f			cpr:	  
619f				; loop for cursor whole row  
619f 0e 28			ld c, display_cols  
61a1 23			cpr1:	inc hl  
61a2 0d				dec c  
61a3 20 fc			jr nz, cpr1  
61a5 05				dec b  
61a6 20 f7			jr nz, cpr  
61a8			  
61a8				; add col	  
61a8			  
61a8 23			cpr2:	inc hl  
61a9 1d				dec e  
61aa 20 fc			jr nz, cpr2  
61ac			  
61ac c1				pop bc  
61ad c9				ret  
61ae				  
61ae			  
61ae			  
61ae			  
61ae			  
61ae			; write the frame buffer given in hl to hardware   
61ae 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
61b1 3e 00			ld a, kLCD_Line1  
61b3 cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61b6 06 28			ld b, display_cols  
61b8 ed 5b d5 f8		ld de, (display_write_tmp)  
61bc cd 08 62			call write_len_string  
61bf				  
61bf				  
61bf 2a d5 f8			ld hl, (display_write_tmp)  
61c2 11 28 00			ld de, display_cols  
61c5 19				add hl,de  
61c6 22 d5 f8			ld (display_write_tmp),hl  
61c9			  
61c9				  
61c9 3e 28			ld a, kLCD_Line2  
61cb cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61ce 06 28			ld b, display_cols  
61d0 ed 5b d5 f8		ld de, (display_write_tmp)  
61d4 cd 08 62			call write_len_string  
61d7				  
61d7 2a d5 f8			ld hl, (display_write_tmp)  
61da 11 28 00			ld de, display_cols  
61dd 19				add hl,de  
61de 22 d5 f8			ld (display_write_tmp),hl  
61e1			  
61e1				  
61e1 3e 50			ld a, kLCD_Line3  
61e3 cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61e6 06 28			ld b, display_cols  
61e8 ed 5b d5 f8		ld de, (display_write_tmp)  
61ec cd 08 62			call write_len_string  
61ef				  
61ef 2a d5 f8			ld hl, (display_write_tmp)  
61f2 11 28 00			ld de, display_cols  
61f5 19				add hl,de  
61f6 22 d5 f8			ld (display_write_tmp),hl  
61f9			  
61f9				  
61f9 3e 78			ld a, kLCD_Line4  
61fb cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61fe 06 28			ld b, display_cols  
6200 ed 5b d5 f8		ld de, (display_write_tmp)  
6204 cd 08 62			call write_len_string  
6207 c9					ret  
6208				  
6208				; write out a fixed length string given in b from de  
6208			  
6208 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6209 cd 75 62		            CALL fLCD_Data      ;Write character to display  
620c 13				inc de  
620d 10 f9			djnz write_len_string  
620f c9				ret  
6210			  
6210			; Some other things to do  
6210			;            LD   A, kLCD_Clear ;Display clear  
6210			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6210			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6210			;            LD   A, kLCD_On     ;Display on with no cursor  
6210			;            ;LD   A, kLCD_Off   ;Display off  
6210			;            CALL fLCD_Inst      ;Send instruction to display  
6210			;  
6210			;  
6210			;            halt  
6210			;  
6210			;  
6210			;MsgHello:   DB  "Hello World!",0  
6210			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6210			  
6210			; Custom characters 5 pixels wide by 8 pixels high  
6210			; Up to 8 custom characters can be defined  
6210			;BitMaps:      
6210			;; Character 0x00 = Battery icon  
6210			;            DB  01110b  
6210			;            DB  11011b  
6210			;            DB  10001b  
6210			;            DB  10001b  
6210			;            DB  11111b  
6210			;            DB  11111b  
6210			;            DB  11111b  
6210			;            DB  11111b  
6210			;; Character 0x01 = Bluetooth icon  
6210			;            DB  01100b  
6210			;            DB  01010b  
6210			;            DB  11100b  
6210			;            DB  01000b  
6210			;            DB  11100b  
6210			;            DB  01010b  
6210			;            DB  01100b  
6210			;            DB  00000b  
6210			;  
6210			  
6210			  
6210			; **********************************************************************  
6210			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6210			; **********************************************************************  
6210			;  
6210			; **  Written as a Small Computer Monitor App   
6210			; **  Version 0.1 SCC 2018-05-16  
6210			; **  www.scc.me.uk  
6210			;  
6210			; **********************************************************************  
6210			;  
6210			; This module provides support for alphanumeric LCD modules using with  
6210			; *  HD44780 (or compatible) controller  
6210			; *  5 x 7 pixel fonts  
6210			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6210			; *  Interface via six digital outputs to the display (see below)  
6210			;  
6210			; LCD module pinout:  
6210			;   1  Vss   0v supply  
6210			;   2  Vdd   5v supply  
6210			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6210			;   4  RS    High = data, Low = instruction  
6210			;   5  R/W   High = Read, Low = Write  
6210			;   6  E     Enable signal (active high)  
6210			;   7  DB0   Data bit 0  
6210			;   8  DB1   Data bit 1  
6210			;   9  DB2   Data bit 2  
6210			;  10  DB3   Data bit 3  
6210			;  11  DB4   Data bit 4  
6210			;  12  DB5   Data bit 5  
6210			;  13  DB6   Data bit 6  
6210			;  14  DB7   Data bit 7  
6210			;  15  A     Backlight anode (+)  
6210			;  16  K     Backlight cathode (-)  
6210			;  
6210			; This interfacing method uses 4-bit data mode and uses time delays  
6210			; rather than polling the display's ready status. As a result the   
6210			; interface only requires 6 simple output lines:  
6210			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6210			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6210			;   LCD DB4 = Microcomputer output port bit 4  
6210			;   LCD DB5 = Microcomputer output port bit 5  
6210			;   LCD DB6 = Microcomputer output port bit 6  
6210			;   LCD DB7 = Microcomputer output port bit 7  
6210			; Display's R/W is connected to 0v so it is always in write mode  
6210			; All 6 connections must be on the same port address <kLCDPrt>  
6210			; This method also allows a decent length of cable from micro to LCD  
6210			;  
6210			; **********************************************************************  
6210			;  
6210			; To include the code for any given function provided by this module,   
6210			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6210			; the parent source file.  
6210			; For example:  #REQUIRES   uHexPrefix  
6210			;  
6210			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6210			; in the parent source file.  
6210			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6210			;  
6210			; These are the function names provided by this module:  
6210			; fLCD_Init                     ;Initialise LCD  
6210			; fLCD_Inst                     ;Send instruction to LCD  
6210			; fLCD_Data                     ;Send data byte to LCD  
6210			; fLCD_Pos                      ;Position cursor  
6210			; fLCD_Str                      ;Display string  
6210			; fLCD_Def                      ;Define custom character  
6210			;  
6210			; **********************************************************************  
6210			;  
6210			; Requires SCMonAPI.asm to also be included in the project  
6210			;  
6210			  
6210			  
6210			; **********************************************************************  
6210			; **  Constants  
6210			; **********************************************************************  
6210			  
6210			; Constants that must be defined externally  
6210			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6210			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6210			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6210			;kLCDWidth: EQU 20             ;Width in characters  
6210			  
6210			; general line offsets in any frame buffer  
6210			  
6210			  
6210			display_row_1: equ 0  
6210			display_row_2: equ display_row_1+display_cols  
6210			display_row_3: equ display_row_2 + display_cols  
6210			display_row_4: equ display_row_3 + display_cols  
6210			;display_row_4_eol:   
6210			  
6210			  
6210			; Cursor position values for the start of each line  
6210			  
6210			; E  
6210			kLCD_Line1: EQU 0x00   
6210			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6210			; E1  
6210			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6210			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6210			  
6210			; Instructions to send as A register to fLCD_Inst  
6210			kLCD_Clear: EQU 00000001b     ;LCD clear  
6210			kLCD_Off:   EQU 00001000b     ;LCD off  
6210			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6210			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6210			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6210			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6210			  
6210			; Constants used by this code module  
6210			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6210			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6210			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6210			  
6210			  
6210			  
6210			; **********************************************************************  
6210			; **  LCD support functions  
6210			; **********************************************************************  
6210			  
6210			; Initialise alphanumeric LCD module  
6210			; LCD control register codes:  
6210			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6210			;   N    0 = 1-line mode       1 = 2-line mode  
6210			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6210			;   D    0 = Display off       1 = Display on  
6210			;   C    0 = Cursor off        1 = Cursor on  
6210			;   B    0 = Blinking off      1 = Blinking on  
6210			;   ID   0 = Decrement mode    1 = Increment mode  
6210			;   SH   0 = Entire shift off  1 = Entire shift on  
6210 3e 28		fLCD_Init:  LD   A, 40  
6212 cd 37 63		            CALL LCDDelay       ;Delay 40ms after power up  
6215			; For reliable reset set 8-bit mode - 3 times  
6215 cd 07 63		            CALL WrFn8bit       ;Function = 8-bit mode  
6218 cd 07 63		            CALL WrFn8bit       ;Function = 8-bit mode  
621b cd 07 63		            CALL WrFn8bit       ;Function = 8-bit mode  
621e			; Set 4-bit mode  
621e cd 03 63		            CALL WrFn4bit       ;Function = 4-bit mode  
6221 cd 35 63		            CALL LCDDelay1      ;Delay 37 us or more  
6224			; Function set  
6224 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6226 cd 39 62		            CALL fLCD_Inst      ;2 line, display on  
6229			; Display On/Off control  
6229 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
622b cd 39 62		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
622e			; Display Clear  
622e 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6230 cd 39 62		            CALL fLCD_Inst      ;Clear display  
6233			; Entry mode  
6233 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6235 cd 39 62		            CALL fLCD_Inst      ;Increment mode, shift off  
6238			; Display module now initialised  
6238 c9			            RET  
6239			; ok to here  
6239			  
6239			; Write instruction to LCD  
6239			;   On entry: A = Instruction byte to be written  
6239			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6239 f5			fLCD_Inst:  PUSH AF  
623a f5			            PUSH AF  
623b cd 4d 62		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
623e f1			            POP  AF  
623f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6240 17			            RLA  
6241 17			            RLA  
6242 17			            RLA  
6243 cd 4d 62		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6246 3e 02		            LD   A, 2  
6248 cd 37 63		            CALL LCDDelay       ;Delay 2 ms to complete   
624b f1			            POP  AF  
624c c9			            RET  
624d			Wr4bits:   
624d f5					push af  
624e 3a d7 f8				ld a, (display_lcde1e2)  
6251 fe 00				cp 0     ; e  
6253 20 10				jr nz, .wea2	  
6255 f1					pop af  
6256 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6258 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
625a cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
625c cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
625e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6260 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6262 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6264 c9			            RET  
6265 f1			.wea2:		pop af  
6266 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6268 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
626a cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
626c cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
626e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6270 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6272 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6274 c9			            RET  
6275			  
6275			  
6275			; Write data to LCD  
6275			;   On entry: A = Data byte to be written  
6275			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6275 f5			fLCD_Data:  PUSH AF  
6276 f5			            PUSH AF  
6277 cd 89 62		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
627a f1			            POP  AF  
627b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
627c 17			            RLA  
627d 17			            RLA  
627e 17			            RLA  
627f cd 89 62		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6282 3e 96		            LD   A, 150  
6284 3d			Wait:      DEC  A              ;Wait a while to allow data   
6285 20 fd		            JR   NZ, Wait      ;  write to complete  
6287 f1			            POP  AF  
6288 c9			            RET  
6289			Wr4bitsa:     
6289 f5					push af  
628a 3a d7 f8				ld a, (display_lcde1e2)  
628d fe 00				cp 0     ; e1  
628f 20 16				jr nz, .we2	  
6291 f1					pop af  
6292 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6294 cb d7		            SET  kLCDBitRS, A  
6296 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6298 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
629a cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
629c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
629e cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
62a0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62a2 cb 97		            RES  kLCDBitRS, A  
62a4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62a6 c9			            RET  
62a7 f1			.we2:		pop af  
62a8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62aa cb d7		            SET  kLCDBitRS, A  
62ac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62ae cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
62b0 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
62b2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
62b4 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
62b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62b8 cb 97		            RES  kLCDBitRS, A  
62ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62bc c9			            RET  
62bd			  
62bd			  
62bd			; Position cursor to specified location  
62bd			;   On entry: A = Cursor position  
62bd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
62bd f5			fLCD_Pos:   PUSH AF  
62be					; at this point set the E1 or E2 flag depending on position  
62be			  
62be c5					push bc  
62bf			;		push af  
62bf 06 00				ld b, 0  
62c1 4f					ld c, a  
62c2 3e 4f				ld a, kLCD_Line3-1  
62c4 b7			 		or a      ;clear carry flag  
62c5 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
62c6 38 04				jr c, .pe1  
62c8			  
62c8					; E selection  
62c8 cb 80				res 0, b         ; bit 0 unset e  
62ca			;		pop af    ; before line 3 so recover orig pos  
62ca			;		ld c, a    ; save for poking back  
62ca 18 06				jr .peset	          
62cc			.pe1:          	; E2 selection  
62cc cb c0				set 0, b         ; bit 0 set e1  
62ce 79					ld a, c  
62cf de 4f				sbc a, kLCD_Line3-1  
62d1 4f					ld c, a	         ; save caculated offset  
62d2			;		pop af     ; bin this original value now we have calculated form  
62d2			  
62d2			.peset:		; set bit  
62d2 78					ld a, b  
62d3 32 d7 f8				ld (display_lcde1e2), a 	  
62d6 79					ld a, c  
62d7 c1					pop bc  
62d8			  
62d8 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
62da cd 39 62		            CALL fLCD_Inst      ;Write instruction to LCD  
62dd f1			            POP  AF  
62de c9			            RET  
62df			  
62df			  
62df			; Output text string to LCD  
62df			;   On entry: DE = Pointer to null terminated text string  
62df			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
62df 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
62e0 b7			            OR   A              ;Null terminator?  
62e1 c8			            RET  Z              ;Yes, so finished  
62e2 cd 75 62		            CALL fLCD_Data      ;Write character to display  
62e5 13			            INC  DE             ;Point to next character  
62e6 18 f7		            JR   fLCD_Str       ;Repeat  
62e8 c9					ret  
62e9			  
62e9			; Define custom character  
62e9			;   On entry: A = Character number (0 to 7)  
62e9			;             DE = Pointer to character bitmap data  
62e9			;   On exit:  A = Next character number  
62e9			;             DE = Next location following bitmap  
62e9			;             BC HL IX IY I AF' BC' DE' HL' preserved  
62e9			; Character is   
62e9 c5			fLCD_Def:   PUSH BC  
62ea f5			            PUSH AF  
62eb 07			            RLCA                ;Calculate location  
62ec 07			            RLCA                ;  for bitmap data  
62ed 07			            RLCA                ;  = 8 x CharacterNumber  
62ee f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
62f0 cd 39 62		            CALL fLCD_Inst      ;Write instruction to LCD  
62f3 06 00		            LD   B, 0  
62f5 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
62f6 cd 75 62		            CALL fLCD_Data      ;Write byte to display  
62f9 13			            INC  DE             ;Point to next byte  
62fa 04			            INC  B              ;Count bytes  
62fb cb 58		            BIT  3, B           ;Finish all 8 bytes?  
62fd 28 f6		            JR   Z, Loop       ;No, so repeat  
62ff f1			            POP  AF  
6300 3c			            INC  A              ;Increment character number  
6301 c1			            POP  BC  
6302 c9			            RET  
6303			  
6303			  
6303			; **********************************************************************  
6303			; **  Private functions  
6303			; **********************************************************************  
6303			  
6303			; Write function to LCD  
6303			;   On entry: A = Function byte to be written  
6303			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6303 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6305 18 02		            JR   WrFunc  
6307 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6309 f5			WrFunc:     PUSH AF  
630a f5					push af  
630b 3a d7 f8				ld a, (display_lcde1e2)  
630e fe 00				cp 0     ; e1  
6310 20 0f				jr nz, .wfea2	  
6312 f1					pop af  
6313 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6315 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6317 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6319 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
631b cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
631d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
631f 18 0d			jr .wfskip  
6321 f1			.wfea2:		pop af  
6322 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6324 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6326 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6328 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
632a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
632c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
632e 3e 05		.wfskip:            LD  A, 5  
6330 cd 37 63		            CALL LCDDelay       ;Delay 5 ms to complete  
6333 f1			            POP  AF  
6334 c9			            RET  
6335			  
6335			  
6335			; Delay in milliseconds  
6335			;   On entry: A = Number of milliseconds delay  
6335			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6335 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6337 d5			LCDDelay:   PUSH DE  
6338 5f			            LD   E, A           ;Delay by 'A' ms  
6339 16 00		            LD   D, 0  
633b cd 22 0a		            CALL aDelayInMS  
633e d1			            POP  DE  
633f c9			            RET  
6340			  
6340			  
6340			testlcd:  
6340 3e 00			ld a, kLCD_Line1  
6342 cd bd 62			call fLCD_Pos  
6345 06 28			ld b, 40  
6347 11 75 63			ld de, .ttext1  
634a cd 08 62			call write_len_string  
634d			  
634d 3e 28			ld a, kLCD_Line2  
634f cd bd 62			call fLCD_Pos  
6352 06 28			ld b, 40  
6354 11 9e 63			ld de, .ttext2  
6357 cd 08 62			call write_len_string  
635a 3e 50			ld a, kLCD_Line3  
635c cd bd 62			call fLCD_Pos  
635f 06 28			ld b, 40  
6361 11 c7 63			ld de, .ttext3  
6364 cd 08 62			call write_len_string  
6367 3e 78			ld a, kLCD_Line4  
6369 cd bd 62			call fLCD_Pos  
636c 06 28			ld b, 40  
636e 11 f0 63			ld de, .ttext4  
6371 cd 08 62			call write_len_string  
6374			  
6374 76				halt  
6375			  
6375			  
6375 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
639e .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
63c7 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
63f0 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6419			   
6419			  
6419			  
6419			; eof  
6419			  
# End of file firmware_lcd_4x40.asm
6419			;include "firmware_lcd_4x20.asm" 
6419			include "firmware_key_5x10.asm" 
6419			; 5 x 10 decade counter scanner  
6419			  
6419			  
6419			; TODO do cursor shape change for shift keys  
6419			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6419			  
6419			  
6419			; bit mask for each scan column and row for teing the matrix  
6419			  
6419			  
6419			key_init:  
6419			  
6419			; SCMonAPI functions used  
6419			  
6419			; Alphanumeric LCD functions used  
6419			; no need to specify specific functions for this module  
6419			  
6419			  
6419 3e cf		            LD   A, 11001111b  
641b d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
641d			;            LD   A, 00000000b  
641d 3e 1f		            LD   A, 00011111b  
641f d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6421			  
6421			  
6421				; TODO Configure cursor shapes  
6421			  
6421				; Load cursor shapes   
6421 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6423 11 33 64		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6426 06 02		            LD   B, 2           ;Number of characters to define  
6428 cd e9 62		.DefLoop:   CALL fLCD_Def       ;Define custom character  
642b 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
642d			  
642d 3e 01				ld a, 1  
642f 32 d0 f8			ld (cursor_shape),a  
6432 c9				ret  
6433			  
6433			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6433			; Up to 8 custom characters can be defined  
6433			.cursor_shapes:      
6433			;; Character 0x00 = Normal  
6433 1f			            DB  11111b  
6434 1f			            DB  11111b  
6435 1f			            DB  11111b  
6436 1f			            DB  11111b  
6437 1f			            DB  11111b  
6438 1f			            DB  11111b  
6439 1f			            DB  11111b  
643a 1f			            DB  11111b  
643b			;; Character 0x01 = Modifier  
643b 1f			            DB  11111b  
643c 1b			            DB  11011b  
643d 1b			            DB  11011b  
643e 1b			            DB  11011b  
643f 1b			            DB  11011b  
6440 1f			            DB  11111b  
6441 1b			            DB  11011b  
6442 1f			            DB  11111b  
6443			  
6443			  
6443			  
6443			  
6443			; Display custom character 0  
6443			;            LD   A, kLCD_Line1+14  
6443			;            CALL fLCD_Pos       ;Position cursor to location in A  
6443			;            LD   A, 0  
6443			;            CALL fLCD_Data      ;Write character in A at cursor  
6443			  
6443			; Display custom character 1  
6443			;            LD   A, kLCD_Line2+14  
6443			;            CALL fLCD_Pos      ;Position cursor to location in A  
6443			;            LD   A, 1  
6443			;            CALL fLCD_Data     ;Write character in A at cursor  
6443			  
6443			; keyboard scanning   
6443			  
6443			; character in from keyboard  
6443			  
6443			; mapping for the pcb layout  
6443			  
6443			.matrix_to_char:  
6443 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
644e .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6459 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6464 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
646f .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
647a			.matrix_to_shift:  
647a			  
647a .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6485 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6490 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
649b 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
64a6 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
64b1			  
64b1			.matrix_to_symbolshift:  
64b1			  
64b1 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
64bc .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
64c7 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
64d2 7e .. 7e 00			db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
64dd .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
64e8			  
64e8			  
64e8			  
64e8			; mapping for a simple straight through breadboard layout  
64e8			  
64e8			;.matrix_to_char:  
64e8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
64e8			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
64e8			;		db "asdfghjkl",KEY_CR,0  
64e8			;		db "qwertyuiop",0  
64e8			;		 db "1234567890",0  
64e8			;.matrix_to_shift:  
64e8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
64e8			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
64e8			;		db "ASDFGHJKL",KEY_CR,0  
64e8			;		db "QWERTYUIOP",0  
64e8			;		 db "!",'"',"#$%^&*()",0  
64e8			;.matrix_to_symbolshift:  
64e8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
64e8			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
64e8			;		db "_?*fghjk=",KEY_CR,0  
64e8			;		db "-/+*[]{}@#",0  
64e8			;		 db "1234567890",0  
64e8			  
64e8			;.matrix_to_char: db "D#0*C987B654A321"  
64e8			  
64e8			  
64e8				  
64e8			  
64e8			; add cin and cin_wait  
64e8			  
64e8 cd f9 64		cin_wait: 	call cin  
64eb						if DEBUG_KEYCINWAIT  
64eb							push af  
64eb							  
64eb							ld hl,key_repeat_ct  
64eb							ld (hl),a  
64eb							inc hl  
64eb							call hexout  
64eb							ld hl,key_repeat_ct+3  
64eb							ld a,0  
64eb							ld (hl),a  
64eb			  
64eb							    LD   A, kLCD_Line1+11  
64eb							    CALL fLCD_Pos       ;Position cursor to location in A  
64eb							    LD   DE, key_repeat_ct  
64eb							    ;LD   DE, MsgHello  
64eb							    CALL fLCD_Str       ;Display string pointed to by DE  
64eb			  
64eb			  
64eb			  
64eb							pop af  
64eb						endif  
64eb fe 00			cp 0  
64ed 28 f9			jr z, cin_wait   ; block until key press  
64ef			  
64ef							if DEBUG_KEYCINWAIT  
64ef								push af  
64ef			  
64ef								ld a, 'A'	  
64ef								ld hl,key_repeat_ct  
64ef								ld (hl),a  
64ef								inc hl  
64ef								ld a,0  
64ef								ld (hl),a  
64ef			  
64ef								    LD   A, kLCD_Line2+11  
64ef								    CALL fLCD_Pos       ;Position cursor to location in A  
64ef								    LD   DE, key_repeat_ct  
64ef								    ;LD   DE, MsgHello  
64ef								    CALL fLCD_Str       ;Display string pointed to by DE  
64ef			  
64ef							call delay500ms  
64ef			  
64ef								pop af  
64ef							endif  
64ef f5				push af   ; save key pressed  
64f0			  
64f0			.cin_wait1:	  
64f0							if DEBUG_KEYCINWAIT  
64f0								push af  
64f0			  
64f0								ld a, 'b'	  
64f0								ld hl,key_repeat_ct  
64f0								ld (hl),a  
64f0								inc hl  
64f0								ld a,0  
64f0								ld (hl),a  
64f0			  
64f0								    LD   A, kLCD_Line2+11  
64f0								    CALL fLCD_Pos       ;Position cursor to location in A  
64f0								    LD   DE, key_repeat_ct  
64f0								    ;LD   DE, MsgHello  
64f0								    CALL fLCD_Str       ;Display string pointed to by DE  
64f0			  
64f0			  
64f0							call delay500ms  
64f0			  
64f0								pop af  
64f0							endif  
64f0			  
64f0 cd f9 64		call cin  
64f3 fe 00			cp 0  
64f5 20 f9			jr nz, .cin_wait1  	; wait for key release  
64f7			if DEBUG_KEYCINWAIT  
64f7				push af  
64f7			  
64f7				ld a, '3'	  
64f7				ld hl,key_repeat_ct  
64f7				ld (hl),a  
64f7				inc hl  
64f7				ld a,0  
64f7				ld (hl),a  
64f7			  
64f7			            LD   A, kLCD_Line2+11  
64f7			            CALL fLCD_Pos       ;Position cursor to location in A  
64f7			            LD   DE, key_repeat_ct  
64f7			            ;LD   DE, MsgHello  
64f7			            CALL fLCD_Str       ;Display string pointed to by DE  
64f7			  
64f7			  
64f7			call delay500ms  
64f7			  
64f7				pop af  
64f7			endif  
64f7			  
64f7 f1				pop af   ; get key  
64f8 c9				ret  
64f9			  
64f9			  
64f9 cd 0d 65		cin: 	call .mtoc  
64fc			  
64fc			if DEBUG_KEYCIN  
64fc				push af  
64fc				  
64fc				ld hl,key_repeat_ct  
64fc				ld (hl),a  
64fc				inc hl  
64fc				call hexout  
64fc				ld hl,key_repeat_ct+3  
64fc				ld a,0  
64fc				ld (hl),a  
64fc			  
64fc			            LD   A, kLCD_Line3+15  
64fc			            CALL fLCD_Pos       ;Position cursor to location in A  
64fc			            LD   DE, key_repeat_ct  
64fc			            ;LD   DE, MsgHello  
64fc			            CALL fLCD_Str       ;Display string pointed to by DE  
64fc			  
64fc			  
64fc			call delay500ms  
64fc			  
64fc				pop af  
64fc			endif  
64fc			  
64fc			  
64fc				; no key held  
64fc fe 00			cp 0  
64fe c8				ret z  
64ff			  
64ff			if DEBUG_KEYCIN  
64ff				push af  
64ff			  
64ff				ld a, '1'	  
64ff				ld hl,key_repeat_ct  
64ff				ld (hl),a  
64ff				inc hl  
64ff				ld a,0  
64ff				ld (hl),a  
64ff			  
64ff			            LD   A, kLCD_Line4+15  
64ff			            CALL fLCD_Pos       ;Position cursor to location in A  
64ff			            LD   DE, key_repeat_ct  
64ff			            ;LD   DE, MsgHello  
64ff			            CALL fLCD_Str       ;Display string pointed to by DE  
64ff			  
64ff			  
64ff			call delay500ms  
64ff			  
64ff				pop af  
64ff			endif  
64ff			  
64ff				; stop key bounce  
64ff			  
64ff 32 88 fb			ld (key_held),a		 ; save it  
6502 47				ld b, a  
6503			  
6503 c5			.cina1:	push bc  
6504			if DEBUG_KEYCIN  
6504				push af  
6504			  
6504				ld hl,key_repeat_ct  
6504				inc hl  
6504				call hexout  
6504				ld hl,key_repeat_ct+3  
6504				ld a,0  
6504				ld (hl),a  
6504				ld hl,key_repeat_ct  
6504				ld a, '2'	  
6504				ld (hl),a  
6504			  
6504			            LD   A, kLCD_Line4+15  
6504			            CALL fLCD_Pos       ;Position cursor to location in A  
6504			            LD   DE, key_repeat_ct  
6504			            ;LD   DE, MsgHello  
6504			            CALL fLCD_Str       ;Display string pointed to by DE  
6504			  
6504				pop af  
6504			endif  
6504 cd 0d 65			call .mtoc  
6507 c1				pop bc  
6508 b8				cp b  
6509 28 f8			jr z, .cina1  
650b 78				ld a,b		  
650c			if DEBUG_KEYCIN  
650c				push af  
650c			  
650c				ld hl,key_repeat_ct  
650c				inc hl  
650c				call hexout  
650c				ld hl,key_repeat_ct+3  
650c				ld a,0  
650c				ld (hl),a  
650c				ld hl,key_repeat_ct  
650c				ld a, '3'	  
650c				ld (hl),a  
650c			  
650c			            LD   A, kLCD_Line4+15  
650c			            CALL fLCD_Pos       ;Position cursor to location in A  
650c			            LD   DE, key_repeat_ct  
650c			            ;LD   DE, MsgHello  
650c			            CALL fLCD_Str       ;Display string pointed to by DE  
650c			  
650c				pop af  
650c			endif  
650c c9				ret  
650d			  
650d			; detect keyboard modifier key press and apply new overlay to the face key held  
650d			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
650d			  
650d			;.cin_map_modifier:   
650d			;	ld a, (hl)  
650d			;	and 255  
650d			;	ret NZ		; modifier key not flagged  
650d			;  
650d			;	; get key face  
650d			;  
650d			;	ld b,(key_face_held)  
650d			;  
650d			;	ld b, key_cols * key_rows  
650d			;  
650d			;	push de  
650d			;	pop hl  
650d			;  
650d			;.mmod1: ld a,(hl)   ; get map test  
650d			;	cp b  
650d			;	jr z, .mmod2  
650d			;  
650d			;  
650d			;  
650d			;.mmod2: inc hl    ;   
650d			;  
650d			;	  
650d			;  
650d			;	  
650d			;  
650d			;	ld hl,key_actual_pressed  
650d			;	ld (hl),a,  
650d			;	ret  
650d			  
650d			; map matrix key held to char on face of key  
650d			  
650d			.mtoc:  
650d			  
650d			; test decade counter strobes  
650d			  
650d			;.decadetest1:  
650d			  
650d			; reset counter  
650d			;ld a, 128  
650d			;out (portbdata),a  
650d			  
650d			  
650d			;ld b, 5  
650d			;.dec1:  
650d			;ld a, 0  
650d			;out (portbdata),a  
650d			;call delay1s  
650d			  
650d			;ld a, 32  
650d			;out (portbdata),a  
650d			;call delay1s  
650d			;call delay1s  
650d			;call delay1s  
650d			;  
650d			;ld a, 64+32  
650d			;out (portbdata),a  
650d			;call delay1s  
650d			;;djnz .dec1  
650d			;  
650d			;jp .decadetest1  
650d			  
650d			  
650d			  
650d			  
650d			  
650d			  
650d			  
650d			  
650d			  
650d			  
650d				; scan keyboard matrix and generate raw scan map  
650d cd a0 65			call matrix  
6510			  
6510				; reuse c bit 0 left modifer button - ie shift  
6510			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6510				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6510			  
6510 0e 00			ld c, 0  
6512			  
6512				; TODO set flags for modifer key presses   
6512				; TODO do a search for modifer key...  
6512			  
6512				;ld hl,keyscan_table_row4  
6512 21 e7 fb			ld hl,keyscan_table_row2  
6515			  
6515 7e				ld a, (hl)  
6516 fe 23			cp '#'  
6518 20 07			jr nz, .nextmodcheck  
651a cb c1			set 0, c  
651c 21 7a 64			ld hl, .matrix_to_shift  
651f 18 21			jr .dokeymap  
6521				; TODO for now igonre  
6521			.nextmodcheck:  
6521 21 dc fb			ld hl,keyscan_table_row3  
6524			  
6524 7e				ld a, (hl)  
6525 fe 23			cp '#'  
6527 20 07			jr nz, .nextmodcheck2  
6529 cb c9			set 1, c   
652b 21 b1 64			ld hl, .matrix_to_symbolshift  
652e 18 12			jr .dokeymap  
6530			.nextmodcheck2:  
6530 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6533			  
6533 7e				ld a, (hl)  
6534 fe 23			cp '#'  
6536 20 07			jr nz, .donemodcheck  
6538 cb c9			set 1, c   
653a 21 7a 64			ld hl, .matrix_to_shift  
653d 18 03			jr .dokeymap  
653f			  
653f				; no modifer found so just map to normal keys  
653f				; get mtoc map matrix to respective keys  
653f			;	ld hl, .matrix_to_char  
653f			;	ld hl, .matrix_to_char  
653f			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
653f			;	ld a, KEY_SHIFT  
653f			;	call findchar  
653f			;  
653f			;	; got offset to key modifer in b  
653f			;  
653f			;	ld hl,keyscan_table_row5  
653f			;  
653f			;	ld a,b  
653f			;	call addatohl  
653f			;	ld a,(hl)  
653f			;  
653f			;	cp '#'  
653f			;	jr nz, .nextmodcheck  
653f			;	set 0, c  
653f			;	ld hl, .matrix_to_char  
653f			;	jr .dokeymap  
653f			;	; TODO for now igonre  
653f			;.nextmodcheck:  
653f			;	ld hl, .matrix_to_symbolshift  
653f			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
653f			;	ld a, KEY_SYMBOLSHIFT  
653f			;	call findchar  
653f			;  
653f			;  
653f			;	; got offset to key modifer in b  
653f			;  
653f			;	ld hl,keyscan_table_row5  
653f			;  
653f			;	ld a,b  
653f			;	call addatohl  
653f			;	ld a,(hl)  
653f			;  
653f			;	cp '#'  
653f			;	jr nz, .donemodcheck  
653f			;	set 1, c   
653f			;	ld hl, .matrix_to_symbolshift  
653f			;	jr .dokeymap  
653f			  
653f			  
653f			  
653f			.donemodcheck:  
653f				; no modifer found so just map to normal keys  
653f				; get mtoc map matrix to respective keys  
653f 21 43 64			ld hl, .matrix_to_char  
6542			  
6542			.dokeymap:  
6542				;ld (key_fa), c   
6542 cd 5b 65			call .mapkeys  
6545			  
6545			  
6545			if DEBUG_KEY  
6545			  
6545			; Display text on first line  
6545			            LD   A, kLCD_Line1  
6545			            CALL fLCD_Pos       ;Position cursor to location in A  
6545			            LD   DE, keyscan_table_row1  
6545			            ;LD   DE, MsgHello  
6545			            CALL fLCD_Str       ;Display string pointed to by DE  
6545			  
6545			; Display text on second line  
6545			            LD   A, kLCD_Line2  
6545			            CALL fLCD_Pos       ;Position cursor to location in A  
6545			            LD   DE, keyscan_table_row2  
6545			            CALL fLCD_Str       ;Display string pointed to by DE  
6545			            LD   A, kLCD_Line3  
6545			            CALL fLCD_Pos       ;Position cursor to location in A  
6545			            LD   DE, keyscan_table_row3  
6545			            CALL fLCD_Str       ;Display string pointed to by DE  
6545			            LD   A, kLCD_Line4  
6545			            CALL fLCD_Pos       ;Position cursor to location in A  
6545			            LD   DE, keyscan_table_row4  
6545			            CALL fLCD_Str       ;Display string pointed to by DE  
6545			            LD   A, kLCD_Line1+10  
6545			            CALL fLCD_Pos       ;Position cursor to location in A  
6545			            LD   DE, keyscan_table_row5  
6545			            CALL fLCD_Str       ;Display string pointed to by DE  
6545			  
6545				;call delay250ms  
6545			endif  
6545			;	jp testkey  
6545			  
6545			; get first char reported  
6545			  
6545 21 c6 fb			ld hl,keyscan_table_row5  
6548			  
6548				;ld b, 46   ; 30 keys to remap + 8 nulls   
6548 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
654a			.findkey:  
654a 7e				ld a,(hl)  
654b fe 00			cp 0  
654d 28 04			jr z, .nextkey  
654f fe 7e			cp KEY_MATRIX_NO_PRESS  
6551 20 06			jr nz, .foundkey  
6553			.nextkey:  
6553 23				inc hl  
6554 10 f4			djnz .findkey  
6556 3e 00			ld a,0  
6558 c9				ret  
6559			.foundkey:  
6559 7e				ld a,(hl)  
655a c9				ret  
655b				  
655b			  
655b			; convert the raw key map given hl for destination key  
655b			.mapkeys:  
655b 11 c6 fb			ld de,keyscan_table_row5  
655e			  
655e 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6560			.remap:  
6560 1a				ld a,(de)  
6561 fe 23			cp '#'  
6563 20 02			jr nz, .remapnext  
6565				;CALLMONITOR  
6565 7e				ld a,(hl)  
6566 12				ld (de),a  
6567			  
6567			  
6567			  
6567			.remapnext:  
6567 23				inc hl  
6568 13				inc de  
6569 10 f5			djnz .remap  
656b				  
656b c9				ret  
656c			  
656c			  
656c			  
656c			.mtocold2:  
656c			  
656c			;	; flag if key D is held down and remove from reporting  
656c			;	ld bc, .key_map_fd    
656c			;	ld hl, keyscan_table  
656c			;	ld de, key_fd  
656c			;	call .key_shift_hold  
656c			;	cp 255  
656c			;	jr z, .cinmap  
656c			;	; flag if key C is held down and remove from reporting  
656c			;	ld bc, .key_map_fc    
656c			;	ld hl, keyscan_table+key_cols  
656c			;	ld de, key_fc  
656c			;	call .key_shift_hold  
656c			;	cp 255  
656c			;	jr z, .cinmap  
656c			;	; flag if key B is held down and remove from reporting  
656c			;	ld bc, .key_map_fb    
656c			;	ld hl, keyscan_table+(key_cols*2)  
656c			;	ld de, key_fb  
656c			;	call .key_shift_hold  
656c			;	cp 255  
656c			;	jr z, .cinmap  
656c			;	; flag if key A is held down and remove from reporting  
656c			;	ld bc, .key_map_fa    
656c			;	ld hl, keyscan_table+(key_cols*3)  
656c			;	ld de, key_fa  
656c			;	call .key_shift_hold  
656c			;	cp 255  
656c			;	jr z, .cinmap  
656c			  
656c 11 43 64			ld de, .matrix_to_char  
656f			  
656f			  
656f			.cinmap1:   
656f				if DEBUG_KEY  
656f			            LD   A, kLCD_Line4  
656f			            CALL fLCD_Pos       ;Position cursor to location in A  
656f					push de  
656f			            LD   DE, keyscan_table  
656f			            CALL fLCD_Str       ;Display string pointed to by DE  
656f					pop de  
656f				endif  
656f			  
656f				; scan key matrix table for any held key  
656f			  
656f				; de holds either the default matrix or one selected above  
656f			  
656f 21 93 fb			ld hl, keyscan_table  
6572 06 32			ld b,key_cols*key_rows  
6574			  
6574 7e			.cin11:	ld a,(hl)  
6575 fe 23			cp '#'  
6577 28 08			jr z, .cinhit1  
6579 23				inc hl  
657a 13				inc de  
657b 05				dec b  
657c 20 f6			jr nz, .cin11  
657e				; no key found held  
657e 3e 00			ld a,0  
6580 c9				ret  
6581 d5			.cinhit1: push de  
6582 e1				pop hl  
6583 7e				ld a,(hl)  
6584 c9				ret  
6585			  
6585			; flag a control key is held   
6585			; hl is key pin, de is flag indicator  
6585			  
6585			.key_shift_hold1:  
6585 c5				push bc  
6586 3e 01			ld a, 1  
6588 32 d0 f8			ld (cursor_shape),a  
658b 06 00			ld b, 0  
658d 7e				ld a, (hl)  
658e fe 2e			cp '.'  
6590 28 0a			jr z, .key_shift11  
6592 06 ff			ld b, 255  
6594 3e 2b			ld a, '+'    ; hide key from later scans  
6596 77				ld (hl),a  
6597 3e 02			ld a, 2  
6599 32 d0 f8			ld (cursor_shape),a  
659c			.key_shift11:  
659c				; write flag indicator  
659c 78				ld a,b  
659d 12				ld (de),a  
659e			  
659e d1				pop de    ; de now holds the key map ptr  
659f c9				ret  
65a0			  
65a0				  
65a0			  
65a0			; scans keyboard matrix and flags key press in memory array	  
65a0				  
65a0			matrix:  
65a0				;call matrix  
65a0				; TODO optimise the code....  
65a0			  
65a0			  
65a0			;ld hl, keyscan_table_row1  
65a0			;ld de, keyscan_table_row1+1  
65a0			;ld bc,46  
65a0			;ld a,KEY_MATRIX_NO_PRESS  
65a0			;ldir  
65a0			  
65a0			  
65a0			  
65a0			; reset counter  
65a0 3e 80		ld a, 128  
65a2 d3 c1		out (portbdata),a  
65a4			  
65a4 06 0a		ld b, 10  
65a6 0e 00		ld c, 0       ; current clock toggle  
65a8			  
65a8			.colscan:  
65a8			  
65a8			; set current column  
65a8			; disable clock enable and set clock low  
65a8			  
65a8			;ld a, 0  
65a8			;out (portbdata),a  
65a8			  
65a8			; For each column scan for switches  
65a8			  
65a8 c5			push bc  
65a9 21 89 fb		ld hl, keyscan_scancol  
65ac cd b5 66		call .rowscan  
65af c1			pop bc  
65b0			  
65b0			  
65b0			; get back current column  
65b0			  
65b0			; translate the row scan  
65b0			  
65b0			;   
65b0			; row 1  
65b0			  
65b0 78			ld a,b  
65b1			  
65b1 21 fc fb		LD   hl, keyscan_table_row1+10  
65b4			  
65b4 cd 24 0c		call subafromhl  
65b7			;call addatohl  
65b7			  
65b7 11 89 fb		ld de, keyscan_scancol  
65ba			  
65ba 1a			ld a,(de)  
65bb 77			ld (hl),a  
65bc			  
65bc			  
65bc			  
65bc			  
65bc			; row 2  
65bc			  
65bc 78			ld a,b  
65bd			  
65bd 21 f1 fb		LD   hl, keyscan_table_row2+10  
65c0			  
65c0			;call addatohl  
65c0 cd 24 0c		call subafromhl  
65c3			  
65c3			  
65c3 11 8a fb		ld de, keyscan_scancol+1  
65c6			  
65c6 1a			ld a,(de)  
65c7 77			ld (hl),a  
65c8			  
65c8			  
65c8			; row 3  
65c8			  
65c8 78			ld a,b  
65c9			  
65c9 21 e6 fb		LD   hl, keyscan_table_row3+10  
65cc			  
65cc			;call addatohl  
65cc cd 24 0c		call subafromhl  
65cf			  
65cf 11 8b fb		ld de, keyscan_scancol+2  
65d2			  
65d2 1a			ld a,(de)  
65d3 77			ld (hl),a  
65d4			  
65d4			  
65d4			  
65d4			; row 4  
65d4			  
65d4 78			ld a,b  
65d5			  
65d5 21 db fb		LD   hl, keyscan_table_row4+10  
65d8			  
65d8			;call addatohl  
65d8 cd 24 0c		call subafromhl  
65db			  
65db 11 8c fb		ld de, keyscan_scancol+3  
65de			  
65de 1a			ld a,(de)  
65df 77			ld (hl),a  
65e0			  
65e0			; row 5  
65e0			  
65e0 78			ld a,b  
65e1			  
65e1 21 d0 fb		LD   hl, keyscan_table_row5+10  
65e4			  
65e4			;call addatohl  
65e4 cd 24 0c		call subafromhl  
65e7			  
65e7 11 8d fb		ld de, keyscan_scancol+4  
65ea			  
65ea 1a			ld a,(de)  
65eb 77			ld (hl),a  
65ec			  
65ec			; handshake next column  
65ec			  
65ec			  
65ec 3e 40		ld a, 64  
65ee d3 c1		out (portbdata),a  
65f0			  
65f0 3e 00		ld a, 0  
65f2 d3 c1		out (portbdata),a  
65f4			  
65f4			; toggle clk and move to next column  
65f4			;ld a, 64  
65f4			;cp c  
65f4			;  
65f4			;jr z, .coltoglow  
65f4			;ld c, a  
65f4			;jr .coltog  
65f4			;.coltoglow:  
65f4			;ld c, 0  
65f4			;.coltog:  
65f4			;ld a, c  
65f4			;out (portbdata),a  
65f4			  
65f4 10 b2		djnz .colscan  
65f6			  
65f6 3e 0a		ld a,10  
65f8 21 f2 fb		LD   hl, keyscan_table_row1  
65fb cd 12 0c		call addatohl  
65fe 3e 00		ld a, 0  
6600 77			ld (hl), a  
6601			  
6601			  
6601 3e 0a		ld a,10  
6603 21 e7 fb		LD   hl, keyscan_table_row2  
6606 cd 12 0c		call addatohl  
6609 3e 00		ld a, 0  
660b 77			ld (hl), a  
660c			  
660c 3e 0a		ld a,10  
660e 21 dc fb		LD   hl, keyscan_table_row3  
6611 cd 12 0c		call addatohl  
6614 3e 00		ld a, 0  
6616 77			ld (hl), a  
6617			  
6617 3e 0a		ld a,10  
6619 21 d1 fb		LD   hl, keyscan_table_row4  
661c cd 12 0c		call addatohl  
661f 3e 00		ld a, 0  
6621 77			ld (hl), a  
6622			  
6622 3e 0a		ld a,10  
6624 21 c6 fb		LD   hl, keyscan_table_row5  
6627 cd 12 0c		call addatohl  
662a 3e 00		ld a, 0  
662c 77			ld (hl), a  
662d			  
662d			if DEBUG_KEY_MATRIX  
662d			  
662d			; Display text on first line  
662d			            LD   A, kLCD_Line1  
662d			            CALL fLCD_Pos       ;Position cursor to location in A  
662d			            LD   DE, keyscan_table_row1  
662d			            ;LD   DE, MsgHello  
662d			            CALL fLCD_Str       ;Display string pointed to by DE  
662d			  
662d			; Display text on second line  
662d			            LD   A, kLCD_Line2  
662d			            CALL fLCD_Pos       ;Position cursor to location in A  
662d			            LD   DE, keyscan_table_row2  
662d			            CALL fLCD_Str       ;Display string pointed to by DE  
662d			            LD   A, kLCD_Line3  
662d			            CALL fLCD_Pos       ;Position cursor to location in A  
662d			            LD   DE, keyscan_table_row3  
662d			            CALL fLCD_Str       ;Display string pointed to by DE  
662d			            LD   A, kLCD_Line4  
662d			            CALL fLCD_Pos       ;Position cursor to location in A  
662d			            LD   DE, keyscan_table_row4  
662d			            CALL fLCD_Str       ;Display string pointed to by DE  
662d			            LD   A, kLCD_Line4+10  
662d			            CALL fLCD_Pos       ;Position cursor to location in A  
662d			            LD   DE, keyscan_table_row5  
662d			            CALL fLCD_Str       ;Display string pointed to by DE  
662d			  
662d			;call delay250ms  
662d				jp matrix  
662d			endif  
662d c9			ret  
662e			  
662e			; using decade counter....  
662e			  
662e			  
662e			; TODO reset decade counter to start of scan  
662e			  
662e			; reset 15  
662e			; clock 14  
662e			; ce 13  
662e			  
662e			; 1 - q5  
662e			; 2 - q1  
662e			; 3 - q0  
662e			; 4 - q2  
662e			; 5 - q6  
662e			; 6 - q7  
662e			; 7 - q3  
662e			; 8 - vss  
662e			; 9 - q8  
662e			; 10 - q4  
662e			; 11 - q9  
662e			; 12 - cout  
662e			; 16 - vdd  
662e			  
662e			; clock      ce       reset     output  
662e			; 0          x        0         n  
662e			; x          1        0         n  
662e			; x          x        1         q0  
662e			; rising     0        0         n+1  
662e			; falling    x        0         n  
662e			; x          rising   0         n  
662e			; 1          falling  0         x+1  
662e			;  
662e			; x = dont care, if n < 5 carry = 1 otherwise 0  
662e			  
662e			;   
662e			; reset   
662e			; 13=0, 14=0, 15=1 .. 15=0  
662e			;  
662e			; handshake line  
662e			; 14=1.... read line 14=0  
662e			  
662e			  
662e			  
662e			  
662e			  
662e			; TODO hand shake clock for next column scan  
662e			; TODO detect each row  
662e			  
662e			  
662e			  
662e			  
662e			; reset 128  
662e			; clock 64  
662e			; ce 32  
662e			  
662e			  
662e			.cyclestart:  
662e			  
662e			; reset counter  
662e 3e 80		ld a, 128  
6630 d3 c1		out (portbdata),a  
6632			  
6632			; loop leds  
6632 06 0a		ld b,10  
6634			  
6634			.cycle1:  
6634 c5			push bc  
6635 3e 00		ld a, 0  
6637 d3 c1		out (portbdata),a  
6639 cd 31 0a		call delay250ms  
663c			  
663c 3e 40		ld a, 64  
663e d3 c1		out (portbdata),a  
6640 cd 31 0a		call delay250ms  
6643			  
6643 3e 00		ld a, 0  
6645 d3 c1		out (portbdata),a  
6647 cd 31 0a		call delay250ms  
664a			  
664a c1			pop bc  
664b 10 e7		djnz .cycle1  
664d			  
664d			  
664d 18 df		jr .cyclestart  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			; map matrix key held to char on face of key  
664f			  
664f			;.mtocold:  
664f			;  
664f			;  
664f			;; reset counter  
664f			;ld a, 128  
664f			;out (portbdata),a  
664f			;  
664f			;  
664f			;; scan keyboard row 1  
664f			;ld a, 0  
664f			;out (portbdata),a  
664f			;;ld a, 64  
664f			;;out (portbdata),a  
664f			;  
664f			;  
664f			;	ld a, 128  
664f			;	ld hl, keyscan_table  
664f			;	call .rowscan  
664f			;  
664f			;;ld a, 0  
664f			;;out (portbdata),a  
664f			;ld a, 64  
664f			;out (portbdata),a  
664f			;  
664f			;	ld a, 64  
664f			;	ld hl, keyscan_table+key_cols  
664f			;	call .rowscan  
664f			;  
664f			;ld a, 0  
664f			;out (portbdata),a  
664f			;;ld a, 64  
664f			;;out (portbdata),a  
664f			;	ld a, 32  
664f			;	ld hl, keyscan_table+(key_cols*2)  
664f			;	call .rowscan  
664f			;  
664f			;  
664f			;;ld a, 0  
664f			;;out (portbdata),a  
664f			;ld a, 64  
664f			;out (portbdata),a  
664f			;  
664f			;	ld a, 16  
664f			;	ld hl, keyscan_table+(key_cols*3)  
664f			;	call .rowscan  
664f			;  
664f			;  
664f			;	; flag if key D is held down and remove from reporting  
664f			;	ld bc, .key_map_fd    
664f			;	ld hl, keyscan_table  
664f			;	ld de, key_fd  
664f			;	call .key_shift_hold  
664f			;	cp 255  
664f			;	jr z, .cinmap  
664f			;	; flag if key C is held down and remove from reporting  
664f			;	ld bc, .key_map_fc    
664f			;	ld hl, keyscan_table+key_cols  
664f			;	ld de, key_fc  
664f			;	call .key_shift_hold  
664f			;	cp 255  
664f			;	jr z, .cinmap  
664f			;	; flag if key B is held down and remove from reporting  
664f			;	ld bc, .key_map_fb    
664f			;	ld hl, keyscan_table+(key_cols*2)  
664f			;	ld de, key_fb  
664f			;	call .key_shift_hold  
664f			;	cp 255  
664f			;	jr z, .cinmap  
664f			;	; flag if key A is held down and remove from reporting  
664f			;	ld bc, .key_map_fa    
664f			;	ld hl, keyscan_table+(key_cols*3)  
664f			;	ld de, key_fa  
664f			;	call .key_shift_hold  
664f			;	cp 255  
664f			;	jr z, .cinmap  
664f			;  
664f			;	ld de, .matrix_to_char  
664f			;  
664f			;  
664f			;.cinmap:   
664f			;	if DEBUG_KEY  
664f			;            LD   A, kLCD_Line4  
664f			;            CALL fLCD_Pos       ;Position cursor to location in A  
664f			;		push de  
664f			;            LD   DE, keyscan_table  
664f			;            CALL fLCD_Str       ;Display string pointed to by DE  
664f			;		pop de  
664f			;	endif  
664f			  
664f				; scan key matrix table for any held key  
664f			  
664f				; de holds either the default matrix or one selected above  
664f			  
664f			;	ld hl, keyscan_table  
664f			;	ld b,key_cols*key_rows  
664f			;  
664f			;.cin1:	ld a,(hl)  
664f			;	cp '#'  
664f			;	jr z, .cinhit  
664f			;	inc hl  
664f			;	inc de  
664f			;	dec b  
664f			;	jr nz, .cin1  
664f			;	; no key found held  
664f			;	ld a,0  
664f			;	ret  
664f			;.cinhit: push de  
664f			;	pop hl  
664f			;	ld a,(hl)  
664f			;	ret  
664f			  
664f			; flag a control key is held   
664f			; hl is key pin, de is flag indicator  
664f			  
664f			;.key_shift_hold:  
664f			;	push bc  
664f			;	ld a, 1  
664f			;	ld (cursor_shape),a  
664f			;	ld b, 0  
664f			;	ld a, (hl)  
664f			;	cp '.'  
664f			;	jr z, .key_shift1  
664f			;	ld b, 255  
664f			;	ld a, '+'    ; hide key from later scans  
664f			;	ld (hl),a  
664f			;	ld a, 2  
664f			;	ld (cursor_shape),a  
664f			;.key_shift1:  
664f			;	; write flag indicator  
664f			;	ld a,b  
664f			;	ld (de),a  
664f			;  
664f			;	pop de    ; de now holds the key map ptr  
664f			;	ret  
664f			  
664f				  
664f				  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			  
664f			;	push hl  
664f			;	push de  
664f			;	push bc  
664f			;	call keyscan  
664f			;	; map key matrix to ascii value of key face  
664f			;  
664f			;	ld hl, key_face_map  
664f			;	ld de, keyscan_table  
664f			;  
664f			;	; get how many keys to look at  
664f			;	ld b, keyscan_table_len  
664f			;	  
664f			;  
664f			;	; at this stage fall out on first key hit  
664f			;	; TODO handle multiple key press  
664f			;  
664f			;map1:	ld a,(hl)  
664f			;	cp '#'  
664f			;	jr z, keyhit  
664f			;	inc hl  
664f			;	inc de  
664f			;	dec b  
664f			;	jr nz, map1  
664f			;nohit:	ld a, 0  
664f			;	jr keydone  
664f			;keyhit: push de  
664f			;	pop hl  
664f			;	ld a,(hl)  
664f			;keydone:  
664f			;	push bc  
664f			;	push de  
664f			; 	push hl  
664f			;	ret   
664f			;  
664f			  
664f			  
664f			  
664f			  
664f			; scan physical key matrix  
664f			  
664f			  
664f			;keyscan:  
664f			;  
664f			;; for each key_row use keyscanr bit mask for out  
664f			;; then read in for keyscanc bitmask  
664f			;; save result of row scan to keyscantable  
664f			;  
664f			;; scan keyboard row 1  
664f			;  
664f			;	ld b, key_rows  
664f			;	ld hl, key_scanr  
664f			;	ld de, keyscan_table  
664f			;  
664f			;rowloop:  
664f			;  
664f			;	ld a,(hl)		; out bit mask to energise keyboard row  
664f			;	call rowscan  
664f			;	inc hl  
664f			;	dec b  
664f			;	jr nz, rowloop  
664f			;  
664f			;	ret  
664f			;  
664f			;  
664f			;; pass a out bitmask, b row number  
664f			;arowscan:   
664f			;	push bc  
664f			;  
664f			;	ld d, b  
664f			;  
664f			;	; calculate buffer location for this row  
664f			;  
664f			;	ld hl, keyscan_table	  
664f			;kbufr:  ld e, key_cols  
664f			;kbufc:	inc hl  
664f			;	dec e  
664f			;	jr nz, kbufc  
664f			;	dec d  
664f			;	jr nz, kbufr  
664f			;  
664f			;	; energise row and read columns  
664f			;  
664f			;	out (portbdata),a  
664f			;	in a,(portbdata)  
664f			;	ld c,a  
664f			;  
664f			;  
664f			;	; save buffer loc  
664f			;  
664f			;	ld (keybufptr), hl  
664f			;  
664f			;	ld hl, key_scanc  
664f			;	ld d, key_cols  
664f			;  
664f			;	; for each column check each bit mask  
664f			;  
664f			;colloop:  
664f			;	  
664f			;  
664f			;	; reset flags for the row   
664f			;  
664f			;	ld b,'.'  
664f			;	and (hl)  
664f			;	jr z, maskskip  
664f			;	ld b,'#'  
664f			;maskskip:  
664f			;	; save  key state  
664f			;	push hl  
664f			;	ld hl, (keybufptr)  
664f			;	ld (hl), b  
664f			;	inc hl  
664f			;	ld (keybufptr), hl  
664f			;  
664f			;	; move to next bit mask  
664f			;	pop hl  
664f			;	inc hl  
664f			;  
664f			;	dec d  
664f			;	jr nz, colloop  
664f			;  
664f			;	ret  
664f			;  
664f			;  
664f			;;  
664f			; lcd functions  
664f			;  
664f			;  
664f			  
664f			;if DEBUG_KEY_MATRIX  
664f			  
664f			; test function to display hardware view of matrix state  
664f			  
664f			matrixold:  
664f			  
664f			  
664f			  
664f			; reset counter  
664f 3e 80		ld a, 128  
6651 d3 c1		out (portbdata),a  
6653			; scan keyboard row 1  
6653 3e 00		ld a, 0  
6655 d3 c1		out (portbdata),a  
6657			;ld a, 64  
6657			;out (portbdata),a  
6657 3e 80			ld a, 128  
6659 21 f2 fb			ld hl, keyscan_table_row1  
665c cd b5 66			call .rowscan  
665f			  
665f			;ld a, 0  
665f			;out (portbdata),a  
665f 3e 40		ld a, 64  
6661 d3 c1		out (portbdata),a  
6663 3e 40			ld a, 64  
6665 21 e7 fb			ld hl, keyscan_table_row2  
6668 cd b5 66			call .rowscan  
666b			  
666b 3e 00		ld a, 0  
666d d3 c1		out (portbdata),a  
666f			;ld a, 64  
666f			;out (portbdata),a  
666f 3e 20			ld a, 32  
6671 21 dc fb			ld hl, keyscan_table_row3  
6674 cd b5 66			call .rowscan  
6677			  
6677			;ld a, 0  
6677			;out (portbdata),a  
6677 3e 40		ld a, 64  
6679 d3 c1		out (portbdata),a  
667b 3e 10			ld a, 16  
667d 21 d1 fb			ld hl, keyscan_table_row4  
6680 cd b5 66			call .rowscan  
6683			  
6683			; Display text on first line  
6683 3e 00		            LD   A, kLCD_Line1  
6685 cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6688 11 f2 fb		            LD   DE, keyscan_table_row1  
668b			            ;LD   DE, MsgHello  
668b cd df 62		            CALL fLCD_Str       ;Display string pointed to by DE  
668e			  
668e			; Display text on second line  
668e 3e 28		            LD   A, kLCD_Line2  
6690 cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6693 11 e7 fb		            LD   DE, keyscan_table_row2  
6696 cd df 62		            CALL fLCD_Str       ;Display string pointed to by DE  
6699 3e 50		            LD   A, kLCD_Line3  
669b cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
669e 11 dc fb		            LD   DE, keyscan_table_row3  
66a1 cd df 62		            CALL fLCD_Str       ;Display string pointed to by DE  
66a4 3e 78		            LD   A, kLCD_Line4  
66a6 cd bd 62		            CALL fLCD_Pos       ;Position cursor to location in A  
66a9 11 d1 fb		            LD   DE, keyscan_table_row4  
66ac cd df 62		            CALL fLCD_Str       ;Display string pointed to by DE  
66af			  
66af cd 31 0a			call delay250ms  
66b2 c3 a0 65			jp matrix  
66b5			  
66b5			; pass de as row display flags  
66b5			.rowscan:   
66b5			;	out (portbdata),a  
66b5 db c1			in a,(portbdata)  
66b7 4f				ld c,a  
66b8				; reset flags for the row   
66b8 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66ba e6 01			and 1  
66bc 28 02			jr z, .p1on  
66be 06 23			ld b,'#'  
66c0			.p1on:  
66c0 70				ld (hl), b  
66c1 23				inc hl  
66c2			  
66c2 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66c4 79				ld a,c  
66c5 e6 02			and 2  
66c7			;	bit 0,a  
66c7 28 02			jr z, .p2on  
66c9 06 23			ld b,'#'  
66cb			.p2on:  
66cb 70				ld (hl), b  
66cc 23				inc hl  
66cd			;  
66cd 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66cf 79				ld a,c  
66d0 e6 04			and 4  
66d2			;;	bit 0,a  
66d2 28 02			jr z, .p3on  
66d4 06 23			ld b,'#'  
66d6			.p3on:  
66d6 70				ld (hl), b  
66d7 23				inc hl  
66d8			;;  
66d8 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66da			;;	bit 0,a  
66da 79				ld a,c  
66db e6 08			and 8  
66dd 28 02			jr z, .p4on  
66df 06 23			ld b,'#'  
66e1			.p4on:  
66e1 70				ld (hl), b  
66e2 23				inc hl  
66e3			  
66e3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66e5			;;	bit 0,a  
66e5 79				ld a,c  
66e6 e6 10			and 16  
66e8 28 02			jr z, .p5on  
66ea 06 23			ld b,'#'  
66ec			.p5on:  
66ec 70				ld (hl), b  
66ed 23				inc hl  
66ee			; zero term  
66ee 06 00			ld b,0  
66f0 70				ld (hl), b  
66f1			  
66f1 c9			.rscandone: ret  
66f2			  
66f2			;addatohl:  
66f2			;  
66f2			 ;add   a, l    ; A = A+L  
66f2			  ;  ld    l, a    ; L = A+L  
66f2			   ; adc   a, h    ; A = A+L+H+carry  
66f2			   ; sub   l       ; A = H+carry  
66f2			   ; ld    h, a    ; H = H+carry  
66f2			  
66f2			;ret  
66f2			; eof  
# End of file firmware_key_5x10.asm
66f2			;include "firmware_key_4x10.asm" 
66f2			 
66f2			heap_size:    equ heap_end - heap_start 
66f2			;eof 
# End of file os_mega.asm
66f2
