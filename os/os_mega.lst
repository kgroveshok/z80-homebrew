# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 23 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-09 11:19' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 1d 6f			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			; cursor blink rate  
0068			CUR_BLINK_RATE: equ $09  
0068			;CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 2a 6f				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd c1 71			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd 86 13				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 13 1b			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 28 1b			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd 8e 12			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd 6d 13				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 40 13			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 52 23			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd 9b 1f			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 56 6f			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd a1 72		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd 90 72				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored and edited directly 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc			EDIT_V1: equ 0 
0ffc			EDIT_V2: equ 1 
0ffc			 
0ffc			 
0ffc			 
0ffc			if EDIT_V2 
0ffc			input_str: 
0ffc			 
0ffc 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
0fff			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fff 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1002			;		ld a, c 
1002			;		call addatohl 
1002			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1002 7a					ld a,d 
1003 32 a1 fd			        ld (input_size), a       ; save length of input area 
1006 79					ld a, c 
1007 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
100a 7b					ld a,e 
100b 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
100e			 
100e			 
100e					; add a trailing space to make screen refresh nicer 
100e			 
100e					;ld hl, (input_start) 
100e					;push hl 
100e					;ld a, 0 
100e					;call strlent 
100e					;ld a, l 
100e					;pop hl 
100e					;call addatohl 
100e					;dec hl 
100e					;ld a, ' ' 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld a, 0 
100e					;ld (hl), a 
100e			 
100e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
100e					; init cursor shape if not set by the cin routines 
100e 21 fc fa				ld hl, cursor_shape 
1011			if BASE_KEV 
1011 3e ff				ld a, 255 
1013			else 
1013					ld a, '#' 
1013			endif 
1013 77					ld (hl), a 
1014 23					inc hl 
1015 3e 00				ld a, 0 
1017 77					ld (hl), a 
1018			 
1018 3e 09				ld a, CUR_BLINK_RATE 
101a 32 9b fd				ld (input_cur_flash), a 
101d 3e 01				ld a, 1 
101f 32 9a fd				ld (input_cur_onoff),a 
1022			.inmain:	 
1022			 
1022 cd 4a 11				call input_disp_ref 
1025			 
1025					; save current length of string 
1025			 
1025 2a a2 fd				ld hl, (input_start) 
1028 3e 00				ld a, 0 
102a cd 40 13				call strlent 
102d 7d					ld a,l 
102e 32 95 fd				ld (input_len), a 
1031			 
1031					;call input_disp_oncur 
1031			 
1031					; display current state of input buffer 
1031			 
1031					; clean any backspace chars 
1031			 
1031 3e 20				ld a, " " 
1033 32 fc f0				ld (scratch),a 
1036 3e 00				ld a, 0 
1038 32 fd f0				ld (scratch+1),a 
103b 3a 9f fd				ld a,(input_at_pos) 
103e 85					add l 
103f 11 fc f0				ld de, scratch 
1042 cd ae 0d				call str_at_display 
1045			 
1045					; pause 1ms 
1045			 
1045 3e 01				ld a, 1 
1047 cd c3 0c				call aDelayInMS 
104a			 
104a			; display cursor if visible on this cycle 
104a			 
104a					; dec flash counter 
104a 3a 9b fd				ld a, (input_cur_flash) 
104d 3d					dec a 
104e 32 9b fd				ld (input_cur_flash), a 
1051 fe 00				cp 0 
1053 20 0d				jr nz, .inochgstate 
1055			 
1055			 
1055					; reset on change of state 
1055 3e 09				ld a, CUR_BLINK_RATE 
1057 32 9b fd				ld (input_cur_flash), a 
105a			 
105a					; change state 
105a 3a 9a fd				ld a,(input_cur_onoff) 
105d ed 44				neg 
105f 32 9a fd				ld (input_cur_onoff),a 
1062			 
1062			 
1062			 
1062			 
1062					; TODO is cursor visible? 
1062					; TODO if so then over write the char at curspos pos with the cursor shape 
1062			 
1062								 
1062			 
1062			.inochgstate: 
1062 3a 9a fd				ld a,(input_cur_onoff) 
1065 fe ff				cp 255 
1067 28 0e				jr z, .skipcursor 
1069 3a 9f fd				ld a, (input_at_pos) 
106c 47					ld b, a 
106d 3a 90 fd				ld a, (input_cursor) 
1070 80					add b 
1071 11 fc fa				ld de, cursor_shape 
1074					 
1074 cd ae 0d				call str_at_display 
1077			 
1077			.skipcursor: 
1077				if DEBUG_INPUTV2 
1077			 
1077					ld a,(input_at_pos) 
1077					ld hl, LFSRSeed 
1077					call hexout 
1077					ld a, (input_cursor) 
1077					ld hl, LFSRSeed+2 
1077					call hexout 
1077					ld a,(input_size) 
1077					ld hl, LFSRSeed+4 
1077					call hexout 
1077			 
1077					ld a,(input_cur_onoff) 
1077					ld hl, LFSRSeed+6 
1077					call hexout 
1077			 
1077					ld a,(input_cur_flash) 
1077					ld hl, LFSRSeed+8 
1077					call hexout 
1077			 
1077					ld a,(input_len) 
1077					ld hl, LFSRSeed+10 
1077					call hexout 
1077					ld hl, LFSRSeed+12 
1077					ld a, 0 
1077					ld (hl),a 
1077					ld a, display_row_4 
1077					ld de, LFSRSeed 
1077					call str_at_display 
1077				endif 
1077 cd be 0d				call update_display 
107a			 
107a					; TODO keyboard processing 
107a			 
107a			if BASE_CPM 
107a					call cin_wait 
107a			else 
107a cd a1 72				call cin    ; _wait 
107d			endif 
107d fe 00				cp 0 
107f ca 22 10				jp z, .inmain 
1082			 
1082 fe 0b				cp KEY_LEFT    ; cursor left 
1084 ca 3c 11				jp z, input_left 
1087				 
1087 fe 0c				cp KEY_RIGHT      ; cursor right 
1089 ca 43 11				jp z, input_right 
108c			 
108c fe 0d				cp KEY_CR 
108e c8					ret z 
108f			 
108f fe 08				cp KEY_BS 
1091 ca b1 11				jp z, input_delchar 
1094			 
1094 fe 06				cp KEY_NEXTWORD 
1096 ca bd 10				jp z, input_nxtword 
1099			 
1099 fe 07				cp KEY_PREVWORD 
109b ca e4 10				jp z, input_prvword 
109e			 
109e fe 0e				cp KEY_HOME    ; jump to start of line 
10a0 20 08				jr nz, .ikh 
10a2 3e 00				ld a, 0 
10a4 32 90 fd				ld (input_cursor), a 
10a7 ca 22 10				jp z, .inmain 
10aa			.ikh: 
10aa			 
10aa fe 0f				cp KEY_END     ; jump to end of line 
10ac 20 09				jr nz, .ike 
10ae 3a 95 fd				ld a, (input_len) 
10b1 32 90 fd				ld (input_cursor),a 
10b4 ca 22 10				jp z, .inmain 
10b7			.ike: 
10b7 fe 05			        cp KEY_UP      ; recall last command 
10b9 c8					ret z 
10ba			;jr nz, .irec 
10ba			; TODO next word 
10ba			; TODO prev word 
10ba			;  
10ba			; 
10ba			;	ld hl, scratch 
10ba			;	ld de, os_last_cmd 
10ba			;	call strcpy 
10ba			;		jp  .inmain 
10ba			.irec: 
10ba			;		jr .instr1 
10ba			 
10ba			 
10ba			 
10ba					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10ba			 
10ba			; TODO return if any special keys are given 
10ba			;		ld l, a 
10ba			;		ld a, 28 ; KEY_F12   ; 27 
10ba			;		sub l 
10ba			;		ret m 
10ba			;		ld a, l 
10ba					; if no special key then insert as a char 
10ba			 
10ba c3 83 11				jp input_inschr 
10bd			 
10bd				 
10bd			input_nxtword: 
10bd				; jump to start next word after the cursor 
10bd			 
10bd			.insknwn:	 
10bd cd 79 11				call input_curptr	 
10c0 7e					ld a,(hl)	 
10c1 fe 00				cp 0 
10c3 ca 22 10				jp z, .inmain    ; end of string 
10c6			 
10c6			; if we are on a word, then move off of it 
10c6			 
10c6 fe 20				cp ' ' 
10c8 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10ca 21 90 fd				ld hl, input_cursor 
10cd 34					inc (hl) 
10ce 18 ed				jr .insknwn 
10d0			 
10d0			.inspace: 
10d0			 
10d0 cd 79 11				call input_curptr	 
10d3 7e					ld a,(hl)	 
10d4 fe 00				cp 0 
10d6 ca 22 10				jp z, .inmain    ; end of string 
10d9			 
10d9			; if we are on a word, then move off of it 
10d9			 
10d9 fe 20				cp ' ' 
10db c2 22 10				jp nz, .inmain     ; we are on non space so at next word 
10de 21 90 fd				ld hl, input_cursor 
10e1 34					inc (hl) 
10e2 18 ec				jr .inspace 
10e4			 
10e4			 
10e4			 
10e4			 
10e4			input_prvword: 
10e4				; jump to the start of previous word before the cursor 
10e4			 
10e4			; where are we to start with currently? 
10e4			 
10e4 cd 79 11				call input_curptr	 
10e7 7e					ld a, (hl) 
10e8 fe 20				cp ' ' 
10ea 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10ec			 
10ec			 
10ec			 
10ec			.inskpwn:	 
10ec 3a 90 fd				ld a,(input_cursor) 
10ef fe 00				cp 0 
10f1 ca 22 10				jp z, .inmain    ; start of string 
10f4			 
10f4			;if we are on a word, then move off of it 
10f4			 
10f4 cd 79 11				call input_curptr	 
10f7 7e					ld a, (hl) 
10f8 fe 20				cp ' ' 
10fa 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
10fc					;jp z, .inmain    ; start of string 
10fc 21 90 fd				ld hl, input_cursor 
10ff 35					dec (hl) 
1100 18 ea				jr .inskpwn 
1102			.iwstart: 
1102 21 90 fd				ld hl, input_cursor 
1105 34					inc (hl) 
1106 c3 22 10				jp .inmain 
1109					 
1109			 
1109			.inspacep: 
1109			 
1109					;jp .inmain    ; start of string 
1109			 
1109			 
1109			 
1109 3a 90 fd				ld a,(input_cursor) 
110c fe 00				cp 0 
110e ca 22 10				jp z, .inmain    ; start of string 
1111			 
1111			; if we are on a word, then move off of it 
1111			 
1111 cd 79 11				call input_curptr	 
1114 7e					ld a, (hl) 
1115 fe 20				cp ' ' 
1117 c2 20 11				jp nz, .incharp     ; we are on non space so at end of prev word 
111a 21 90 fd				ld hl, input_cursor 
111d 35					dec (hl) 
111e 18 e9				jr .inspacep 
1120			 
1120			 
1120			.incharp:	 
1120					; eat the word to get to the start 
1120 3a 90 fd				ld a,(input_cursor) 
1123 fe 00				cp 0 
1125 ca 22 10				jp z, .inmain    ; start of string 
1128			 
1128			; if we are on a word, then move off of it 
1128			 
1128 cd 79 11				call input_curptr	 
112b 7e					ld a, (hl) 
112c fe 20				cp ' ' 
112e 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1130 21 90 fd				ld hl, input_cursor 
1133 35					dec (hl) 
1134 18 ea				jr .incharp 
1136			.ipwordst: 
1136					; at space before the prev word so reposition over it 
1136 21 90 fd				ld hl, input_cursor 
1139 34					inc (hl) 
113a 18 b0				jr .inskpwn 
113c					 
113c			 
113c			 
113c			input_left: 
113c				; move cursor left 
113c 21 90 fd			ld hl, input_cursor 
113f 35				dec (hl) 
1140			;	cp 0 
1140			;	jp z, .inmain    ; ignore left as at the start of the string 
1140 c3 22 10			jp .inmain 
1143			 
1143			input_right: 
1143				; move cursor right 
1143				 
1143				;ld a, (input_size) 
1143				;ld b, a 
1143 21 90 fd			ld hl, input_cursor 
1146 34				inc (hl) 
1147				;dec b 
1147				;cp 0 
1147				;jp z, .inmain   ; ignore as at end of the string buffer 
1147				;ld a, b 
1147				;inc a 
1147				;ld (input_cursor), a 
1147 c3 22 10			jp .inmain 
114a			 
114a			 
114a			 
114a			input_disp_ref: 
114a				; display the text from start of buffer (ie full refresh) 
114a 3a 9f fd			ld a, (input_at_pos) 
114d 2a a2 fd			ld hl,(input_start) 
1150 eb				ex de, hl 
1151 cd ae 0d			call str_at_display  
1154 c9				ret 
1155			input_disp_oncur: 
1155				; display the text from cursor position to end of buffer 
1155				; TODO position start of string at cursor position on screen 
1155				; TODO draw from that point on 
1155 3a 90 fd			ld a, (input_cursor) 
1158 47				ld b, a 
1159 3a 9f fd			ld a, (input_at_pos) 
115c 80				add b 
115d 48				ld c, b     ; save a 
115e 78				ld a, b     ; inc string start for cursor 
115f 2a a2 fd			ld hl,(input_start) 
1162 cd cf 0f			call addatohl 
1165 eb				ex de, hl 
1166 79				ld a, c 
1167 cd ae 0d			call str_at_display  
116a c9				ret 
116b			 
116b			input_nxtw: 
116b				; Find next word 
116b c9				ret 
116c			 
116c			input_prvw: 
116c				; Find previous word 
116c c9				ret 
116d			 
116d			input_lenrem:   
116d				; Calculate the length of string remaining from current cursor 
116d				; position to end of buffer (exc null term) 
116d				 
116d 3a 90 fd			ld a, (input_cursor) 
1170 4f				ld c, a 
1171 3a a1 fd			ld a, (input_size) 
1174 91				sub c 
1175 06 00			ld b, 0 
1177 0d				dec c 
1178 c9				ret	 
1179			 
1179			input_curptr: 
1179				; calc address of the character under the cursor 
1179				 
1179 2a a2 fd			ld hl, (input_start) 
117c 3a 90 fd			ld a, (input_cursor) 
117f cd cf 0f			call addatohl 
1182 c9				ret 
1183			 
1183			input_inschr: 
1183				; Insert char at cursor position 
1183 f5				push af   ; save char 
1184				;call input_lenrem    ; get bc length of remaining string 
1184			 
1184				 
1184 cd 79 11			call input_curptr 
1187			;	ld hl, (input_start) 
1187			;	ld a, (input_cursor) 
1187			;	call addatohl 
1187				;push hl   ; save to come back to 
1187			 
1187				; shift everything up one to end of buffer 
1187			 
1187				;push hl 
1187				;dec de 
1187				;inc de 
1187			;	ldir 
1187				 
1187				;pop hl 
1187			 
1187				; are we adding to the end of line? 
1187			 
1187 3a 90 fd			ld a, (input_cursor) 
118a 47				ld b, a 
118b 3a 95 fd			ld a, (input_len) 
118e b8				cp b 
118f 20 09			jr nz, .insmid   ; no, insert in middle of text 
1191			 
1191				; tack on the end of the line 
1191 f1				pop af 
1192 77				ld (hl), a   ; save new char 
1193 23				inc hl 
1194 3e 00			ld a, 0 
1196 77				ld (hl), a 
1197 c3 43 11			jp input_right 
119a				 
119a			.insmid: 
119a				; hl has insertion point so move everything up one to allow for insertion 
119a				;call input_shiftright 
119a f1				pop af 
119b			 
119b			.shufinsmid: 
119b 47				ld b, a     ; b contains new char, c prev char at this position  
119c 7e				ld a, (hl) 
119d			 
119d fe 00			cp 0    ; at end of string need to then dump new char and add term 
119f 28 07			jr z, .endinsmid 
11a1 4f				ld c, a 
11a2 78				ld a, b 
11a3 77				ld (hl), a 
11a4 23				inc hl 
11a5 79				ld a, c 
11a6 18 f3			jr .shufinsmid 
11a8				 
11a8			 
11a8			 
11a8			 
11a8			.endinsmid: 
11a8 78				ld a, b 
11a9 77				ld (hl), a 
11aa 23				inc hl 
11ab 3e 00			ld a, 0 
11ad 77				ld (hl), a 
11ae			 
11ae			 
11ae			;	ld (hl), a   ; save new char 
11ae			 
11ae c3 43 11			jp input_right 
11b1			 
11b1			;input_shiftright: 
11b1			;	; shift text right at cursor, hl has shift start 
11b1			;	push hl 
11b1			;	push de 
11b1			;	push bc 
11b1			; 
11b1			; 
11b1			;	; move to end of string past zero term 
11b1			;	ld hl,(input_start) 
11b1			;	ld a, (input_len) 
11b1			;	call addatohl 
11b1			;	inc hl 
11b1			;;	inc hl 
11b1			;;	inc hl 
11b1			;	ld a, 0 
11b1			;	ld (hl), a 
11b1			;;	dec hl 
11b1			;	 
11b1			;;	ld (hl), a 
11b1			;;	dec hl 
11b1			; 
11b1			;	push hl 
11b1			;	pop de 
11b1			;	inc de 
11b1			;	 
11b1			; 
11b1			;;	ld hl,(input_start) 
11b1			;;	ld a, (input_cursor) 
11b1			;;	call addatohl 
11b1			; 
11b1			; 
11b1			;	; calc how many bytes from cursor pos to end of string we need to shift 
11b1			;	call input_lenrem    ; get bc length of remaining string 
11b1			;	;ld a, (input_cursor) 
11b1			;	;ld c, a 
11b1			;	ld a, (input_len) 
11b1			;	cp 2 
11b1			;	jr z, .iskipzero	 
11b1			;	;sub c 
11b1			;	;inc a 
11b1			;	;ld c, a 
11b1			;	;ld b, 0 
11b1			;	inc c 
11b1			;	inc c 
11b1			;	; move data 
11b1			;	lddr 
11b1			;.iskipzero: 
11b1			; 
11b1			;	pop bc 
11b1			;	pop de 
11b1			;	pop hl 
11b1			;	ret	 
11b1			 
11b1			input_delchar: 
11b1				; Delete char at cursor position 
11b1 cd 6d 11			call input_lenrem    ; get bc length of remaining string 
11b4 2a a2 fd			ld hl, (input_start) 
11b7 3a 90 fd			ld a, (input_cursor) 
11ba cd cf 0f			call addatohl 
11bd			 
11bd e5				push hl 
11be d1				pop de 
11bf 1b				dec de 
11c0			 
11c0			.dl:	 
11c0 ed a0			ldi  
11c2 7e				ld a, (hl) 
11c3 fe 00			cp 0 
11c5 28 02			jr z, .dldone 
11c7 18 f7			jr .dl 
11c9			.dldone: 
11c9 ed a0			ldi 
11cb			 
11cb c3 3c 11			jp input_left 
11ce			 
11ce			 
11ce			endif 
11ce			 
11ce			 
11ce			 
11ce			if EDIT_V1 
11ce			input_str: 
11ce			 
11ce				    	ld (input_at_pos),a      ; save display position to start 
11ce					add c 
11ce					ld (input_at_cursor),a	; save draw pos of cursor 
11ce					ld (input_start), hl     ; save ptr to buffer 
11ce					ld a, c 
11ce					call addatohl 
11ce					ld (input_ptr), hl     ; save ptr to point under the cursor 
11ce					ld a,d 
11ce				        ld (input_size), a       ; save length of input area 
11ce					ld a, c 
11ce					ld (input_cursor),a      ; init cursor start position  
11ce					ld a,e 
11ce				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11ce					 
11ce					 
11ce			 
11ce			;		ld a,(input_ptr) 
11ce			;		ld (input_under_cursor),a 	; save what is under the cursor 
11ce			 
11ce			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11ce					; init cursor shape if not set by the cin routines 
11ce					ld hl, cursor_shape 
11ce			if BASE_KEV 
11ce					ld a, 255 
11ce			else 
11ce					ld a, '#' 
11ce			endif 
11ce					ld (hl), a 
11ce					inc hl 
11ce					ld a, 0 
11ce					ld (hl), a 
11ce			 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce					ld a, 1 
11ce					ld (input_cur_onoff),a 
11ce			 
11ce			;	if DEBUG_INPUT 
11ce			;		push af 
11ce			;		ld a, 'I' 
11ce			;		ld (debug_mark),a 
11ce			;		pop af 
11ce			;		CALLMONITOR 
11ce			;	endif 
11ce			.is1:		; main entry loop 
11ce			 
11ce			 
11ce			 
11ce					; pause 1ms 
11ce			 
11ce					ld a, 1 
11ce					call aDelayInMS 
11ce			 
11ce					; dec flash counter 
11ce					ld a, (input_cur_flash) 
11ce					dec a 
11ce					ld (input_cur_flash), a 
11ce					cp 0 
11ce					jr nz, .nochgstate 
11ce			 
11ce			 
11ce					; change state 
11ce					ld a,(input_cur_onoff) 
11ce					neg 
11ce					ld (input_cur_onoff),a 
11ce			 
11ce			 
11ce					; reset on change of state 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce			.nochgstate: 
11ce					 
11ce					 
11ce			 
11ce					; display cursor  
11ce			 
11ce			;		ld hl, (input_start) 
11ce			;		ld a, (input_cursor) 
11ce			;		call addatohl 
11ce			 
11ce					; get char under cursor and replace with cursor 
11ce			ld hl, (input_ptr) 
11ce			;		ld a, (hl) 
11ce			;		ld (input_under_cursor),a 
11ce			;		ld a, '_' 
11ce			;		ld (hl), a 
11ce			 
11ce					; display string 
11ce			 
11ce					ld de, (input_start) 
11ce					ld a, (input_at_pos) 
11ce					call str_at_display 
11ce			;	        call update_display 
11ce			 
11ce					; find place to put the cursor 
11ce			;		add h 
11ce			;		ld l, display_row_1 
11ce			;		sub l 
11ce			; (input_at_pos) 
11ce					;ld c, a 
11ce			;		ld a, (input_cursor) 
11ce			;		ld l, (input_at_pos) 
11ce			;		;ld b, h 
11ce			;		add l 
11ce			;		ld (input_at_cursor),a 
11ce					;ld l,h 
11ce			 
11ce			;		ld h, 0 
11ce			;		ld l,(input_at_pos) 
11ce			;		ld a, (input_cursor) 
11ce			;		call addatohl 
11ce			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11ce			;		call subafromhl 
11ce			;		ld a,l 
11ce			;		ld (input_at_cursor), a 
11ce			 
11ce				if DEBUG_INPUT 
11ce					ld a, (hardware_diag) 
11ce					cp 0 
11ce					jr z, .skip_input_diag 
11ce			 
11ce					ld a,(input_at_pos) 
11ce					ld hl, LFSRSeed 
11ce					call hexout 
11ce					ld a, (input_cursor) 
11ce					ld hl, LFSRSeed+2 
11ce					call hexout 
11ce					ld a,(input_at_cursor) 
11ce					ld hl, LFSRSeed+4 
11ce					call hexout 
11ce			 
11ce					ld a,(input_cur_onoff) 
11ce					ld hl, LFSRSeed+6 
11ce					call hexout 
11ce			 
11ce					ld a,(input_cur_flash) 
11ce					ld hl, LFSRSeed+8 
11ce					call hexout 
11ce			 
11ce					ld a,(input_len) 
11ce					ld hl, LFSRSeed+10 
11ce					call hexout 
11ce					ld hl, LFSRSeed+12 
11ce					ld a, 0 
11ce					ld (hl),a 
11ce					ld a, display_row_4 
11ce					ld de, LFSRSeed 
11ce					call str_at_display 
11ce					.skip_input_diag: 
11ce				endif 
11ce			 
11ce					; decide on if we are showing the cursor this time round 
11ce			 
11ce					ld a, (input_cur_onoff) 
11ce					cp 255 
11ce					jr z, .skipcur 
11ce			 
11ce			 
11ce					ld a,(input_at_cursor) 
11ce					ld de, cursor_shape 
11ce					call str_at_display 
11ce			 
11ce					; save length of current input string 
11ce					ld hl, (input_start) 
11ce					ld a, 0 
11ce					call strlent 
11ce					ld a,l 
11ce					ld (input_len),a 
11ce			 
11ce			.skipcur: 
11ce			 
11ce				        call update_display 
11ce					 
11ce			 
11ce			 
11ce					; wait 
11ce				 
11ce					; TODO loop without wait to flash the cursor and char under cursor	 
11ce					call cin    ; _wait 
11ce			 
11ce					cp 0 
11ce					jp z, .is1 
11ce			 
11ce					; get ptr to char to input into 
11ce			 
11ce					ld c,a 
11ce					ld hl, (input_start) 
11ce					ld a, (input_cursor) 
11ce					call addatohl 
11ce					ld (input_ptr), hl 
11ce					ld a,c 
11ce			 
11ce					; replace char under cursor 
11ce			 
11ce			;		ld hl, (input_ptr) 
11ce			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11ce			;		ld (hl), a 
11ce			 
11ce			;	if DEBUG_INPUT 
11ce			;		push af 
11ce			;		ld a, 'i' 
11ce			;		ld (debug_mark),a 
11ce			;		pop af 
11ce			;		CALLMONITOR 
11ce			;	endif 
11ce					cp KEY_HOME 
11ce					jr nz, .iske 
11ce			 
11ce					ld a, (input_at_pos) 
11ce					ld (input_at_cursor),a 
11ce					ld a, 0 
11ce					ld (input_cursor), a 
11ce					jp .is1 
11ce					 
11ce			.iske:		cp KEY_END 
11ce					jr nz, .isknw 
11ce					jp .is1 
11ce			 
11ce			.isknw:		cp KEY_NEXTWORD 
11ce					jr nz, .iskpw 
11ce			 
11ce			.isknwm:	ld hl, (input_ptr) 
11ce					ld a,(hl)	 
11ce					cp 0 
11ce					jp z, .is1    ; end of string 
11ce					cp ' ' 
11ce					jp z, .is1    ; end of word 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce					jr .isknwm 
11ce			 
11ce			.iskpw:		cp KEY_PREVWORD 
11ce					jr nz, .iskl 
11ce			.iskpwm:	 
11ce					ld hl, (input_ptr) 
11ce					ld a,(hl)	 
11ce					cp 0  
11ce					jp z, .is1    ; end of string 
11ce					cp ' ' 
11ce					jp z, .is1    ; end of word 
11ce					dec hl 
11ce					ld (input_ptr), hl 
11ce					ld a, (input_at_cursor) 
11ce					dec a 
11ce					ld (input_at_cursor), a 
11ce					jr .iskpwm 
11ce			 
11ce			 
11ce			.iskl:		cp KEY_LEFT 
11ce					jr nz, .isk1 
11ce			 
11ce					ld a, (input_cursor) 
11ce			 
11ce					cp 0 
11ce					jp z, .is1 		; at start of line to ignore  
11ce			 
11ce					dec  a 		; TODO check underflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					dec hl 
11ce					ld (input_ptr), hl 
11ce					 
11ce					ld a, (input_at_cursor) 
11ce					dec a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk1:		cp KEY_RIGHT 
11ce					jr nz, .isk2 
11ce			 
11ce					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11ce					ld e,a 
11ce					ld a, (input_cursor) 
11ce					cp e 
11ce					jp z, .is1		; at the end of string so dont go right 
11ce			 
11ce					inc  a 		; TODO check overflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce			 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk2:		cp KEY_UP 
11ce			 
11ce					jr nz, .isk3 
11ce			 
11ce					; swap last command with the current on 
11ce			 
11ce					; move cursor to start of string 
11ce					ld hl, (input_start) 
11ce					ld (input_ptr), hl 
11ce			 
11ce					ld a, (input_at_pos) 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld a, 0 
11ce					ld (input_cursor), a 
11ce					 
11ce					; swap input and last command buffers 
11ce			 
11ce					ld hl, os_cli_cmd 
11ce					ld de, os_last_cmd 
11ce					ld b, 255 
11ce			.swap1:		ld a, (hl) 
11ce					ld c,a 
11ce					ld a, (de) 
11ce					ld (hl), a 
11ce					ld a,c 
11ce					ld (de),a 
11ce					inc hl 
11ce					inc de 
11ce					djnz .swap1 
11ce			 
11ce			 
11ce			 
11ce			 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk3:		cp KEY_BS 
11ce					jr nz, .isk4 
11ce			 
11ce					ld a, (input_cursor) 
11ce			 
11ce					cp 0 
11ce					jp z, .is1 		; at start of line to ignore  
11ce			 
11ce					dec  a 		; TODO check underflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					; hl is source 
11ce					; de needs to be source - 1 
11ce			 
11ce			;		ld a, 0 
11ce			;		dec hl 
11ce			;		ld (hl), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					dec hl 
11ce					ld (input_ptr), hl 
11ce			 
11ce					; shift all data 
11ce			 
11ce					push hl 
11ce					inc hl 
11ce					pop de 
11ce					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11ce					ld c,a 
11ce					ld b,0 
11ce					ldir  
11ce			 
11ce			 
11ce			 
11ce			 
11ce					ld a, (input_at_cursor) 
11ce					dec a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce			 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce					; remove char 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld de,.iblank 
11ce					call str_at_display 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk4:		cp KEY_CR 
11ce					jr z, .endinput 
11ce			 
11ce					; else add the key press to the end 
11ce			 
11ce					ld c, a			; save key pressed 
11ce			 
11ce					ld a,(hl)		; get what is currently under char 
11ce			 
11ce					cp 0			; we are at the end of the string 
11ce					jr nz, .onchar 
11ce					 
11ce					; add a char to the end of the string 
11ce				 
11ce					ld (hl),c 
11ce					inc hl 
11ce			;		ld a,' ' 
11ce			;		ld (hl),a 
11ce			;		inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce					dec hl 
11ce			 
11ce					ld a, (input_cursor) 
11ce					inc a				; TODO check max string length and scroll  
11ce					ld (input_cursor), a		; inc cursor pos 
11ce							 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce			;	if DEBUG_INPUT 
11ce			;		push af 
11ce			;		ld a, '+' 
11ce			;		ld (debug_mark),a 
11ce			;		pop af 
11ce			;		CALLMONITOR 
11ce			;	endif 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce					jp .is1 
11ce					 
11ce			 
11ce			 
11ce					; if on a char then insert 
11ce			.onchar: 
11ce			 
11ce					; TODO over flow check: make sure insert does not blow out buffer 
11ce			 
11ce					; need to do some maths to use lddr 
11ce			 
11ce					push hl   ; save char pos 
11ce					push bc 
11ce			 
11ce					ld hl, (input_start) 
11ce					ld a, (input_len) 
11ce					call addatohl  		; end of string 
11ce					inc hl 
11ce					inc hl		; past zero term 
11ce					push hl 
11ce					inc hl 
11ce					push hl  
11ce			 
11ce								; start and end of lddr set, now how much to move? 
11ce			 
11ce							 
11ce					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11ce					ld b,a 
11ce					ld a,(input_len) 
11ce					ld e,a 
11ce					sub b 
11ce					inc a		;?? 
11ce					inc a		;?? 
11ce					inc a		;?? 
11ce			 
11ce					ld b,0 
11ce					ld c,a 
11ce			 
11ce				if DEBUG_INPUT 
11ce					push af 
11ce					ld a, 'i' 
11ce					ld (debug_mark),a 
11ce					pop af 
11ce			;		CALLMONITOR 
11ce				endif 
11ce					pop de 
11ce					pop hl 
11ce				if DEBUG_INPUT 
11ce					push af 
11ce					ld a, 'I' 
11ce					ld (debug_mark),a 
11ce					pop af 
11ce			;		CALLMONITOR 
11ce				endif 
11ce					lddr 
11ce				 
11ce			 
11ce			 
11ce					; TODO have a key for insert/overwrite mode???? 
11ce					pop bc 
11ce					pop hl 
11ce					ld (hl), c		; otherwise overwrite current char 
11ce					 
11ce			 
11ce			 
11ce			 
11ce					ld a, (input_cursor) 
11ce					inc  a 		; TODO check overflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.endinput:	; TODO look for end of string 
11ce			 
11ce					; add trailing space for end of token 
11ce			 
11ce					ld hl, (input_start) 
11ce					ld a,(input_len) 
11ce					call addatohl 
11ce					ld a, ' ' 
11ce					ld (hl),a 
11ce					; TODO eof of parse marker 
11ce			 
11ce					inc hl 
11ce					ld a, 0 
11ce					ld (hl),a 
11ce			 
11ce			 
11ce					ret 
11ce			 
11ce			.iblank: db " ",0 
11ce			 
11ce			 
11ce			input_str_prev:	ld (input_at_pos), a 
11ce					ld (input_start), hl 
11ce					ld a,1			; add cursor 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce					ld (input_ptr), hl 
11ce					ld a,d 
11ce					ld (input_size), a 
11ce					ld a,0 
11ce					ld (input_cursor),a 
11ce			.instr1:	 
11ce			 
11ce					; TODO do block cursor 
11ce					; TODO switch cursor depending on the modifer key 
11ce			 
11ce					; update cursor shape change on key hold 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					dec hl 
11ce					ld a,(cursor_shape) 
11ce					ld (hl), a 
11ce			 
11ce					; display entered text 
11ce					ld a,(input_at_pos) 
11ce			            	CALL fLCD_Pos       ;Position cursor to location in A 
11ce			            	LD   de, (input_start) 
11ce			            	CALL fLCD_Str       ;Display string pointed to by DE 
11ce			 
11ce					call cin 
11ce					cp 0 
11ce					jr z, .instr1 
11ce			 
11ce					; proecess keyboard controls first 
11ce			 
11ce					ld hl,(input_ptr) 
11ce			 
11ce					cp KEY_CR	 ; pressing enter ends input 
11ce					jr z, .instrcr 
11ce			 
11ce					cp KEY_BS 	; back space 
11ce					jr nz, .instr2 
11ce					; process back space 
11ce			 
11ce					; TODO stop back space if at start of string 
11ce					dec hl 
11ce					dec hl ; to over write cursor 
11ce					ld a,(cursor_shape) 
11ce					;ld a,0 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a," " 
11ce					ld (hl),a 
11ce					ld (input_ptr),hl 
11ce					 
11ce			 
11ce					jr .instr1 
11ce			 
11ce			.instr2:	cp KEY_LEFT    ; cursor left 
11ce					jr nz, .instr3 
11ce					dec hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce				 
11ce			.instr3:	cp KEY_RIGHT      ; cursor right 
11ce					jr nz, .instr4 
11ce					inc hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce			 
11ce			.instr4:	cp KEY_HOME    ; jump to start of line 
11ce					jr nz, .instr5 
11ce					dec hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce			 
11ce			.instr5:	cp KEY_END     ; jump to end of line 
11ce					jr nz, .instr6 
11ce					dec hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce			.instr6:        cp KEY_UP      ; recall last command 
11ce					jr nz, .instrnew 
11ce			 
11ce				ld hl, scratch 
11ce				ld de, os_last_cmd 
11ce				call strcpy 
11ce					jr .instr1 
11ce			 
11ce			 
11ce			.instrnew:	; no special key pressed to see if we have room to store it 
11ce			 
11ce					; TODO do string size test 
11ce			 
11ce					dec hl ; to over write cursor 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,(cursor_shape) 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce			 
11ce					ld (input_ptr),hl 
11ce					 
11ce					jr .instr1 
11ce			.instrcr:	dec hl		; remove cursor 
11ce					ld a,' '	; TODO add a trailing space for safety 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce			 
11ce			 
11ce					; if at end of line scroll up    
11ce					; TODO detecting only end of line 4 for scroll up  
11ce			 
11ce					;ld   
11ce			 
11ce					ret 
11ce			 
11ce			 
11ce			endif 
11ce			; strcpy hl = dest, de source 
11ce			 
11ce 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11cf b7			            OR   A              ;Null terminator? 
11d0 c8			            RET  Z              ;Yes, so finished 
11d1 1a					ld a,(de) 
11d2 77					ld (hl),a 
11d3 13			            INC  DE             ;Point to next character 
11d4 23					inc hl 
11d5 18 f7		            JR   strcpy       ;Repeat 
11d7 c9					ret 
11d8			 
11d8			 
11d8			; TODO string_at  
11d8			; pass string which starts with lcd offset address and then null term string 
11d8			 
11d8			; TODO string to dec 
11d8			; TODO string to hex 
11d8			; TODO byte to string hex 
11d8			; TODO byte to string dec 
11d8			 
11d8			 
11d8			 
11d8			; from z80uartmonitor 
11d8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11d8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11d8			; pass hl for where to put the text 
11d8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11d8 c5			hexout:	PUSH BC 
11d9 f5					PUSH AF 
11da 47					LD B, A 
11db					; Upper nybble 
11db cb 3f				SRL A 
11dd cb 3f				SRL A 
11df cb 3f				SRL A 
11e1 cb 3f				SRL A 
11e3 cd f3 11				CALL tohex 
11e6 77					ld (hl),a 
11e7 23					inc hl	 
11e8					 
11e8					; Lower nybble 
11e8 78					LD A, B 
11e9 e6 0f				AND 0FH 
11eb cd f3 11				CALL tohex 
11ee 77					ld (hl),a 
11ef 23					inc hl	 
11f0					 
11f0 f1					POP AF 
11f1 c1					POP BC 
11f2 c9					RET 
11f3					 
11f3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11f3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11f3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11f3			tohex: 
11f3 e5					PUSH HL 
11f4 d5					PUSH DE 
11f5 16 00				LD D, 0 
11f7 5f					LD E, A 
11f8 21 00 12				LD HL, .DATA 
11fb 19					ADD HL, DE 
11fc 7e					LD A, (HL) 
11fd d1					POP DE 
11fe e1					POP HL 
11ff c9					RET 
1200			 
1200			.DATA: 
1200 30					DEFB	30h	; 0 
1201 31					DEFB	31h	; 1 
1202 32					DEFB	32h	; 2 
1203 33					DEFB	33h	; 3 
1204 34					DEFB	34h	; 4 
1205 35					DEFB	35h	; 5 
1206 36					DEFB	36h	; 6 
1207 37					DEFB	37h	; 7 
1208 38					DEFB	38h	; 8 
1209 39					DEFB	39h	; 9 
120a 41					DEFB	41h	; A 
120b 42					DEFB	42h	; B 
120c 43					DEFB	43h	; C 
120d 44					DEFB	44h	; D 
120e 45					DEFB	45h	; E 
120f 46					DEFB	46h	; F 
1210			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1210			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1210			;;    subtract $30, if result > 9 then subtract $7 more 
1210			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1210			atohex: 
1210 d6 30				SUB $30 
1212 fe 0a				CP 10 
1214 f8					RET M		; If result negative it was 0-9 so we're done 
1215 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1217 c9					RET		 
1218			 
1218			 
1218			 
1218			 
1218			; Get 2 ASCII characters as hex byte from pointer in hl 
1218			 
1218			BYTERD: 
1218 16 00			LD	D,00h		;Set up 
121a cd 22 12			CALL	HEXCON		;Get byte and convert to hex 
121d 87				ADD	A,A		;First nibble so 
121e 87				ADD	A,A		;multiply by 16 
121f 87				ADD	A,A		; 
1220 87				ADD	A,A		; 
1221 57				LD	D,A		;Save hi nibble in D 
1222			HEXCON: 
1222 7e				ld a, (hl)		;Get next chr 
1223 23				inc hl 
1224 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1226 fe 0a			CP	00Ah		;Is it 0-9 ? 
1228 38 02			JR	C,NALPHA	;If so miss next bit 
122a d6 07			SUB	007h		;Else convert alpha 
122c			NALPHA: 
122c b2				OR	D		;Add hi nibble back 
122d c9				RET			; 
122e			 
122e			 
122e			; 
122e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
122e			; Since the routines get_byte and therefore get_nibble are called, only valid 
122e			; characters (0-9a-f) are accepted. 
122e			; 
122e			;get_word        push    af 
122e			;                call    get_byte        ; Get the upper byte 
122e			;                ld      h, a 
122e			;                call    get_byte        ; Get the lower byte 
122e			;                ld      l, a 
122e			;                pop     af 
122e			;                ret 
122e			; 
122e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
122e			; the routine get_nibble is used only valid characters are accepted - the  
122e			; input routine only accepts characters 0-9a-f. 
122e			; 
122e c5			get_byte:        push    bc              ; Save contents of B (and C) 
122f 7e					ld a,(hl) 
1230 23					inc hl 
1231 cd 56 12		                call    nibble2val      ; Get upper nibble 
1234 cb 07		                rlc     a 
1236 cb 07		                rlc     a 
1238 cb 07		                rlc     a 
123a cb 07		                rlc     a 
123c 47			                ld      b, a            ; Save upper four bits 
123d 7e					ld a,(hl) 
123e cd 56 12		                call    nibble2val      ; Get lower nibble 
1241 b0			                or      b               ; Combine both nibbles 
1242 c1			                pop     bc              ; Restore B (and C) 
1243 c9			                ret 
1244			; 
1244			; Get a hexadecimal digit from the serial line. This routine blocks until 
1244			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1244			; to the serial line interface. The lower 4 bits of A contain the value of  
1244			; that particular digit. 
1244			; 
1244			;get_nibble      ld a,(hl)           ; Read a character 
1244			;                call    to_upper        ; Convert to upper case 
1244			;                call    is_hex          ; Was it a hex digit? 
1244			;                jr      nc, get_nibble  ; No, get another character 
1244			 ;               call    nibble2val      ; Convert nibble to value 
1244			 ;               call    print_nibble 
1244			 ;               ret 
1244			; 
1244			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1244			; A valid hexadecimal digit is denoted by a set C flag. 
1244			; 
1244			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1244			;                ret     nc              ; Yes 
1244			;                cp      '0'             ; Less than '0'? 
1244			;                jr      nc, is_hex_1    ; No, continue 
1244			;                ccf                     ; Complement carry (i.e. clear it) 
1244			;                ret 
1244			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1244			;                ret     c               ; Yes 
1244			;                cp      'A'             ; Less than 'A'? 
1244			;                jr      nc, is_hex_2    ; No, continue 
1244			;                ccf                     ; Yes - clear carry and return 
1244			;                ret 
1244			;is_hex_2        scf                     ; Set carry 
1244			;                ret 
1244			; 
1244			; Convert a single character contained in A to upper case: 
1244			; 
1244 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1246 d8			                ret     c 
1247 fe 7b		                cp      'z' + 1         ; > 'z'? 
1249 d0			                ret     nc              ; Nothing to do, either 
124a e6 5f		                and     $5f             ; Convert to upper case 
124c c9			                ret 
124d			 
124d			 
124d			to_lower: 
124d			 
124d			   ; if char is in [A-Z] make it lower case 
124d			 
124d			   ; enter : a = char 
124d			   ; exit  : a = lower case char 
124d			   ; uses  : af 
124d			 
124d fe 41		   cp 'A' 
124f d8			   ret c 
1250			    
1250 fe 5b		   cp 'Z'+1 
1252 d0			   ret nc 
1253			    
1253 f6 20		   or $20 
1255 c9			   ret 
1256			 
1256			; 
1256			; Expects a hexadecimal digit (upper case!) in A and returns the 
1256			; corresponding value in A. 
1256			; 
1256 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1258 38 02		                jr      c, nibble2val_1 ; Yes 
125a d6 07		                sub     7               ; Adjust for A-F 
125c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
125e e6 0f		                and     $f              ; Only return lower 4 bits 
1260 c9			                ret 
1261			; 
1261			; Print_nibble prints a single hex nibble which is contained in the lower  
1261			; four bits of A: 
1261			; 
1261			;print_nibble    push    af              ; We won't destroy the contents of A 
1261			;                and     $f              ; Just in case... 
1261			;                add     a, '0'             ; If we have a digit we are done here. 
1261			;                cp      '9' + 1         ; Is the result > 9? 
1261			;                jr      c, print_nibble_1 
1261			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1261			;print_nibble_1  call    putc            ; Print the nibble and 
1261			;                pop     af              ; restore the original value of A 
1261			;                ret 
1261			;; 
1261			;; Send a CR/LF pair: 
1261			; 
1261			;crlf            push    af 
1261			;                ld      a, cr 
1261			;                call    putc 
1261			;                ld      a, lf 
1261			;                call    putc 
1261			;                pop     af 
1261			;                ret 
1261			; 
1261			; Print_word prints the four hex digits of a word to the serial line. The  
1261			; word is expected to be in HL. 
1261			; 
1261			;print_word      push    hl 
1261			;                push    af 
1261			;                ld      a, h 
1261			;                call    print_byte 
1261			;                ld      a, l 
1261			;                call    print_byte 
1261			;                pop     af 
1261			;                pop     hl 
1261			;                ret 
1261			; 
1261			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1261			; The byte to be printed is expected to be in A. 
1261			; 
1261			;print_byte      push    af              ; Save the contents of the registers 
1261			;                push    bc 
1261			;                ld      b, a 
1261			;                rrca 
1261			;                rrca 
1261			;                rrca 
1261			;                rrca 
1261			;                call    print_nibble    ; Print high nibble 
1261			;                ld      a, b 
1261			;                call    print_nibble    ; Print low nibble 
1261			;                pop     bc              ; Restore original register contents 
1261			;                pop     af 
1261			;                ret 
1261			 
1261			 
1261			 
1261			 
1261			 
1261			fourehexhl:  
1261 7e				ld a,(hl) 
1262 cd 10 12			call atohex 
1265 cb 3f				SRL A 
1267 cb 3f				SRL A 
1269 cb 3f				SRL A 
126b cb 3f				SRL A 
126d 47				ld b, a 
126e 23				inc hl 
126f 7e				ld a,(hl) 
1270 23				inc hl 
1271 cd 10 12			call atohex 
1274 80				add b 
1275 57				ld d,a 
1276 7e				ld a,(hl) 
1277 cd 10 12			call atohex 
127a cb 3f				SRL A 
127c cb 3f				SRL A 
127e cb 3f				SRL A 
1280 cb 3f				SRL A 
1282 47				ld b, a 
1283 23				inc hl 
1284 7e				ld a,(hl) 
1285 23				inc hl 
1286 cd 10 12			call atohex 
1289 80				add b 
128a 5f				ld e, a 
128b d5				push de 
128c e1				pop hl 
128d c9				ret 
128e			 
128e			; pass hl. returns z set if the byte at hl is a digit 
128e			;isdigithl:  
128e			;	push bc 
128e			;	ld a,(hl) 
128e			;	cp ':' 
128e			;	jr nc, .isdf 		; > 
128e			;	cp '0' 
128e			;	jr c, .isdf		; < 
128e			; 
128e			;	; TODO find a better way to set z 
128e			; 
128e			;	ld b,a 
128e			;	cp b 
128e			;	pop bc 
128e			;	ret 
128e			; 
128e			;.isdf:	; not digit so clear z 
128e			; 
128e			;	; TODO find a better way to unset z 
128e			; 
128e			;	ld b,a 
128e			;	inc b 
128e			;	cp b 
128e			; 
128e			;	pop bc 
128e			;	ret 
128e				 
128e				 
128e			 
128e			 
128e			; pass hl as the four byte address to load 
128e			 
128e			get_word_hl:  
128e e5				push hl 
128f cd 2e 12			call get_byte 
1292				 
1292 47				ld b, a 
1293			 
1293 e1				pop hl 
1294 23				inc hl 
1295 23				inc hl 
1296			 
1296			; TODO not able to handle a-f  
1296 7e				ld a,(hl) 
1297			;	;cp ':' 
1297			;	cp 'g' 
1297			;	jr nc, .single_byte_hl 		; > 
1297			;	cp 'G' 
1297			;	jr nc, .single_byte_hl 		; > 
1297			;	cp '0' 
1297			;	jr c, .single_byte_hl		; < 
1297			 
1297				;call isdigithl 
1297 fe 00			cp 0 
1299 28 06			jr z, .single_byte_hl 
129b			 
129b			.getwhln:   ; hex word so get next byte 
129b			 
129b cd 2e 12			call get_byte 
129e 6f				ld l, a 
129f 60				ld h,b 
12a0 c9				ret 
12a1 68			.single_byte_hl:   ld l,b 
12a2 26 00				ld h,0 
12a4 c9					ret 
12a5			 
12a5			 
12a5			 
12a5			 
12a5 21 12 1d			ld hl,asc+1 
12a8			;	ld a, (hl) 
12a8			;	call nibble2val 
12a8 cd 2e 12			call get_byte 
12ab			 
12ab			;	call fourehexhl 
12ab 32 30 f1			ld (scratch+52),a 
12ae				 
12ae 21 2e f1			ld hl,scratch+50 
12b1 22 1f f4			ld (os_cur_ptr),hl 
12b4			 
12b4 c9				ret 
12b5			 
12b5			 
12b5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12b5			 
12b5			; Decimal Unsigned Version 
12b5			 
12b5			;Number in a to decimal ASCII 
12b5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12b5			;Example: display a=56 as "056" 
12b5			;input: a = number 
12b5			;Output: a=0,value of a in the screen 
12b5			;destroys af,bc (don't know about hl and de) 
12b5			DispAToASCII: 
12b5 0e 9c			ld	c,-100 
12b7 cd c1 12			call	.Na1 
12ba 0e f6			ld	c,-10 
12bc cd c1 12			call	.Na1 
12bf 0e ff			ld	c,-1 
12c1 06 2f		.Na1:	ld	b,'0'-1 
12c3 04			.Na2:	inc	b 
12c4 81				add	a,c 
12c5 38 fc			jr	c,.Na2 
12c7 91				sub	c		;works as add 100/10/1 
12c8 f5				push af		;safer than ld c,a 
12c9 78				ld	a,b		;char is in b 
12ca			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12ca f1				pop af		;safer than ld a,c 
12cb c9				ret 
12cc			 
12cc			; Decimal Signed Version 
12cc			 
12cc			; DispA 
12cc			; -------------------------------------------------------------- 
12cc			; Converts a signed integer value to a zero-terminated ASCII 
12cc			; string representative of that value (using radix 10). 
12cc			; -------------------------------------------------------------- 
12cc			; INPUTS: 
12cc			;     HL     Value to convert (two's complement integer). 
12cc			;     DE     Base address of string destination. (pointer). 
12cc			; -------------------------------------------------------------- 
12cc			; OUTPUTS: 
12cc			;     None 
12cc			; -------------------------------------------------------------- 
12cc			; REGISTERS/MEMORY DESTROYED 
12cc			; AF HL 
12cc			; -------------------------------------------------------------- 
12cc			 
12cc			;DispHLToASCII: 
12cc			;   push    de 
12cc			;   push    bc 
12cc			; 
12cc			;; Detect sign of HL. 
12cc			;    bit    7, h 
12cc			;    jr     z, ._DoConvert 
12cc			; 
12cc			;; HL is negative. Output '-' to string and negate HL. 
12cc			;    ld     a, '-' 
12cc			;    ld     (de), a 
12cc			;    inc    de 
12cc			; 
12cc			;; Negate HL (using two's complement) 
12cc			;    xor    a 
12cc			;    sub    l 
12cc			;    ld     l, a 
12cc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12cc			;    sbc    a, h 
12cc			;    ld     h, a 
12cc			; 
12cc			;; Convert HL to digit characters 
12cc			;._DoConvert: 
12cc			;    ld     b, 0     ; B will count character length of number 
12cc			;-   ld     a, 10 
12cc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12cc			;    push   af 
12cc			;    inc    b 
12cc			;    ld     a, h 
12cc			;    or     l 
12cc			;    jr     nz, - 
12cc			; 
12cc			;; Retrieve digits from stack 
12cc			;-   pop    af 
12cc			;    or     $30 
12cc			;    ld     (de), a 
12cc			;    inc    de 
12cc			;    djnz   - 
12cc			; 
12cc			;; Terminate string with NULL 
12cc			;    xor    a 
12cc			;    ld     (de), a 
12cc			; 
12cc			;    pop    bc 
12cc			;    pop    de 
12cc			;    ret 
12cc			 
12cc			;Comments 
12cc			; 
12cc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12cc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12cc			;    Note that the output string will not be fixed-width. 
12cc			; 
12cc			;Example Usage 
12cc			; 
12cc			;    ld    hl, -1004 
12cc			;    ld    de, OP1 
12cc			;    call  DispA 
12cc			;    ld    hl, OP1 
12cc			;    syscall  PutS 
12cc			 
12cc			 
12cc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12cc			 
12cc			 
12cc			;Converts an ASCII string to an unsigned 16-bit integer 
12cc			;Quits when it reaches a non-decimal digit 
12cc			 
12cc			string_to_uint16: 
12cc			atoui_16: 
12cc			;Input: 
12cc			;     DE points to the string 
12cc			;Outputs: 
12cc			;     HL is the result 
12cc			;     A is the 8-bit value of the number 
12cc			;     DE points to the byte after the number 
12cc			;Destroys: 
12cc			;     BC 
12cc			;       if the string is non-empty, BC is HL/10 
12cc			;Size:  24 bytes 
12cc			;Speed: 42+d(104+{0,9}) 
12cc			;       d is the number of digits in the number 
12cc			;       max is 640 cycles for a 5 digit number 
12cc			;Assuming no leading zeros: 
12cc			;1 digit:  146cc 
12cc			;2 digit:  250cc 
12cc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12cc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12cc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12cc			;avg: 544.81158447265625cc (544+13297/16384) 
12cc			;=============================================================== 
12cc 21 00 00		  ld hl,0 
12cf			.u16a: 
12cf 1a			  ld a,(de) 
12d0 d6 30		  sub 30h 
12d2 fe 0a		  cp 10 
12d4 d0			  ret nc 
12d5 13			  inc de 
12d6 44			  ld b,h 
12d7 4d			  ld c,l 
12d8 29			  add hl,hl 
12d9 29			  add hl,hl 
12da 09			  add hl,bc 
12db 29			  add hl,hl 
12dc 85			  add a,l 
12dd 6f			  ld l,a 
12de 30 ef		  jr nc,.u16a 
12e0 24			  inc h 
12e1 c3 cf 12		  jp .u16a 
12e4			 
12e4			 
12e4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12e4			 
12e4			;written by Zeda 
12e4			;Converts a 16-bit unsigned integer to an ASCII string. 
12e4			 
12e4			uitoa_16: 
12e4			;Input: 
12e4			;   DE is the number to convert 
12e4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12e4			;Output: 
12e4			;   HL points to the null-terminated ASCII string 
12e4			;      NOTE: This isn't necessarily the same as the input HL. 
12e4 d5			  push de 
12e5 c5			  push bc 
12e6 f5			  push af 
12e7 eb			  ex de,hl 
12e8			 
12e8 01 f0 d8		  ld bc,-10000 
12eb 3e 2f		  ld a,'0'-1 
12ed 3c			  inc a 
12ee 09			  add hl,bc  
12ef 38 fc		   jr c,$-2 
12f1 12			  ld (de),a 
12f2 13			  inc de 
12f3			 
12f3 01 e8 03		  ld bc,1000 
12f6 3e 3a		  ld a,'9'+1 
12f8 3d			  dec a  
12f9 09			  add hl,bc  
12fa 30 fc		   jr nc,$-2 
12fc 12			  ld (de),a 
12fd 13			  inc de 
12fe			 
12fe 01 9c ff		  ld bc,-100 
1301 3e 2f		  ld a,'0'-1 
1303 3c			  inc a  
1304 09			  add hl,bc  
1305 38 fc		   jr c,$-2 
1307 12			  ld (de),a 
1308 13			  inc de 
1309			 
1309 7d			  ld a,l 
130a 26 3a		  ld h,'9'+1 
130c 25			  dec h  
130d c6 0a		  add a,10  
130f 30 fb		   jr nc,$-3 
1311 c6 30		  add a,'0' 
1313 eb			  ex de,hl 
1314 72			  ld (hl),d 
1315 23			  inc hl 
1316 77			  ld (hl),a 
1317 23			  inc hl 
1318 36 00		  ld (hl),0 
131a			 
131a			;Now strip the leading zeros 
131a 0e fa		  ld c,-6 
131c 09			  add hl,bc 
131d 3e 30		  ld a,'0' 
131f 23			  inc hl  
1320 be			  cp (hl)  
1321 28 fc		  jr z,$-2 
1323			 
1323			;Make sure that the string is non-empty! 
1323 7e			  ld a,(hl) 
1324 b7			  or a 
1325 20 01		  jr nz,.atoub 
1327 2b			  dec hl 
1328			.atoub: 
1328			 
1328 f1			  pop af 
1329 c1			  pop bc 
132a d1			  pop de 
132b c9			  ret 
132c			 
132c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
132c			 
132c			toUpper: 
132c			;A is the char. 
132c			;If A is a lowercase letter, this sets it to the matching uppercase 
132c			;18cc or 30cc or 41cc 
132c			;avg: 26.75cc 
132c fe 61		  cp 'a' 
132e d8			  ret c 
132f fe 7b		  cp 'z'+1 
1331 d0			  ret nc 
1332 d6 20		  sub 'a'-'A' 
1334 c9			  ret 
1335			 
1335			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1335			 
1335			; String Length 
1335			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1335			 
1335			; Get the length of the null-terminated string starting at $8000 hl 
1335			;    LD     HL, $8000 
1335			 
1335			strlenz: 
1335			 
1335 af			    XOR    A               ; Zero is the value we are looking for. 
1336 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1337 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1338			                           ; 65, 536 bytes (the entire addressable memory space). 
1338 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
133a			 
133a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
133a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
133b 6f			    LD     L, A             ; number of bytes 
133c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
133e 2b			    DEC    HL              ; Compensate for null. 
133f c9				ret 
1340			 
1340			; Get the length of the A terminated string starting at $8000 hl 
1340			;    LD     HL, $8000 
1340			 
1340			strlent: 
1340			 
1340			                  ; A is the value we are looking for. 
1340 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1342 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1344			                           ; 65, 536 bytes (the entire addressable memory space). 
1344 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1346			 
1346			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1346 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1348 2e 00		    LD     L, 0             ; number of bytes 
134a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134c 2b			    DEC    HL              ; Compensate for null. 
134d c9				ret 
134e			 
134e			 
134e			;Comparing Strings 
134e			 
134e			;IN    HL     Address of string1. 
134e			;      DE     Address of string2. 
134e			 
134e			; doc given but wrong??? 
134e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
134e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
134e			; tested 
134e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
134e			 
134e			strcmp_old: 
134e e5			    PUSH   HL 
134f d5			    PUSH   DE 
1350			 
1350 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1351 be			    CP     (HL)            ; (want to minimize work). 
1352 38 01		    JR     C, Str1IsBigger 
1354 7e			    LD     A, (HL) 
1355			 
1355			Str1IsBigger: 
1355 4f			    LD     C, A             ; Put length in BC 
1356 06 00		    LD     B, 0 
1358 13			    INC    DE              ; Increment pointers to meat of string. 
1359 23			    INC    HL 
135a			 
135a			CmpLoop: 
135a 1a			    LD     A, (DE)          ; Compare bytes. 
135b ed a1		    CPI 
135d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
135f 13			    INC    DE              ; Update pointer. 
1360 ea 5a 13		    JP     PE, CmpLoop 
1363			 
1363 d1			    POP    DE 
1364 e1			    POP    HL 
1365 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1366 be			    CP     (HL) 
1367 c9			    RET 
1368			 
1368			NoMatch: 
1368 2b			    DEC    HL 
1369 be			    CP     (HL)            ; Compare again to affect carry. 
136a d1			    POP    DE 
136b e1			    POP    HL 
136c c9			    RET 
136d			 
136d			;; test strmp 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str2 
136d			;call strcmp 
136d			;jr z, .z1 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "NZ1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.z1: 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "ZZ1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str1 
136d			;call strcmp 
136d			;jr z, .z2 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "NZ2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.z2: 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "ZZ2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str2 
136d			;call strcmp 
136d			;jr c, .c1 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "Nc1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.c1: 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "cc1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str1 
136d			;call strcmp 
136d			;jr c, .c2 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "Nc2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.c2: 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "cc2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;	NEXTW 
136d			;.str1:   db "string1",0 
136d			;.str2:   db "string2",0 
136d			 
136d			; only care about direct match or not 
136d			; hl and de strings 
136d			; zero set if the same 
136d			 
136d			strcmp: 
136d 1a				ld a, (de) 
136e be				cp (hl) 
136f 28 02			jr z, .ssame 
1371 b7				or a 
1372 c9				ret 
1373			 
1373			.ssame:  
1373 fe 00			cp 0 
1375 c8				ret z 
1376			 
1376 23				inc hl 
1377 13				inc de 
1378 18 f3			jr strcmp 
137a				 
137a				 
137a			 
137a			;Copyright (c) 2014, Luke Maurits 
137a			;All rights reserved. 
137a			; 
137a			;Redistribution and use in source and binary forms, with or without 
137a			;modification, are permitted provided that the following conditions are met: 
137a			; 
137a			;* Redistributions of source code must retain the above copyright notice, this 
137a			;  list of conditions and the following disclaimer. 
137a			; 
137a			;* Redistributions in binary form must reproduce the above copyright notice, 
137a			;  this list of conditions and the following disclaimer in the documentation 
137a			;  and/or other materials provided with the distribution. 
137a			; 
137a			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
137a			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
137a			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
137a			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
137a			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
137a			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
137a			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
137a			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
137a			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
137a			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
137a			 
137a			; https://github.com/lmaurits/lm512/blob/master/string.z80 
137a			 
137a			StrictStrCmp: 
137a				; Load next chars of each string 
137a 1a				ld a, (de) 
137b 47				ld b, a 
137c 7e				ld a, (hl) 
137d				; Compare 
137d b8				cp b 
137e				; Return non-zero if chars don't match 
137e c0				ret nz 
137f				; Check for end of both strings 
137f fe 00			cp "\0" 
1381				; Return if strings have ended 
1381 c8				ret z 
1382				; Otherwise, advance to next chars 
1382 23				inc hl 
1383 13				inc de 
1384 18 f4			jr StrictStrCmp 
1386			 
1386			;end 
1386			; eof 
1386			 
1386			 
1386			 
1386			 
1386			 
1386			 
# End of file firmware_strings.asm
1386			include "firmware_memory.asm"   ; malloc and free  
1386			 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			.mallocsize: db "Wants malloc >256",0 
1386			.mallocasize: db "MALLOC gives >256",0 
1386			.malloczero: db "MALLOC gives zero",0 
1386			 
1386			malloc_guard_zerolen: 
1386				push hl 
1386				push de 
1386				push af 
1386			 
1386				ld de, 0 
1386			        call cmp16 
1386				jr nz, .lowalloz 
1386			 
1386				push hl 
1386				push de 
1386					ld hl, display_fb0 
1386					ld (display_fb_active), hl 
1386				call clear_display 
1386				ld a, 0 
1386				ld de, .malloczero 
1386				call str_at_display 
1386				call update_display 
1386				call delay1s 
1386				call delay1s 
1386				call bp_on 
1386			;	ld a, 0 
1386			;	ld (os_view_disable), a 
1386			 
1386				pop de 
1386				pop hl 
1386			 
1386				 
1386			 
1386				CALLMONITOR 
1386			.lowalloz: 
1386			 
1386			 
1386				pop af 
1386				pop de 
1386				pop hl 
1386			ret 
1386			 
1386			malloc_guard_entry: 
1386				push hl 
1386				push de 
1386				push af 
1386			 
1386			 	or a      ;clear carry flag 
1386				push hl 
1386				ld de, 255 
1386				sbc hl, de 
1386				jr c, .lowalloc 
1386			 
1386				push de 
1386					ld hl, display_fb0 
1386					ld (display_fb_active), hl 
1386				call clear_display 
1386				ld a, 0 
1386				ld de, .mallocsize 
1386				call str_at_display 
1386				call update_display 
1386				call delay1s 
1386				call delay1s 
1386			;	ld a, 0 
1386			;	ld (os_view_disable), a 
1386				call bp_on 
1386			 
1386				pop de 
1386				pop hl 
1386			 
1386				 
1386			 
1386				CALLMONITOR 
1386				jr .lowdone 
1386			.lowalloc: 
1386			 
1386			 
1386				pop hl 
1386			.lowdone:	pop af 
1386				pop de 
1386				pop hl 
1386			ret 
1386			 
1386			malloc_guard_exit: 
1386				push hl 
1386				push de 
1386				push af 
1386			 
1386			 	or a      ;clear carry flag 
1386				push hl 
1386				ld de, 255 
1386				sbc hl, de 
1386				jr c, .lowallocx 
1386			 
1386				push de 
1386					ld hl, display_fb0 
1386					ld (display_fb_active), hl 
1386				call clear_display 
1386				ld a, 0 
1386				ld de, .mallocasize 
1386				call str_at_display 
1386				call update_display 
1386				call delay1s 
1386				call delay1s 
1386			;	ld a, 0 
1386			;	ld (os_view_disable), a 
1386				call bp_on 
1386				pop de 
1386				pop hl 
1386			 
1386				CALLMONITOR 
1386				jr .lowdonex 
1386			.lowallocx: 
1386			 
1386				pop hl 
1386			.lowdonex:	pop af 
1386				pop de 
1386				pop hl 
1386			ret 
1386			endif 
1386			 
1386			if MALLOC_2 
1386			; Z80 Malloc and Free Functions 
1386			 
1386			; Malloc Function: 
1386			; Input: 
1386			;   HL: Size of block to allocate 
1386			; Output: 
1386			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1386			 
1386			malloc: 
1386				 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			call malloc_guard_entry 
1386			endif 
1386			 
1386			 
1386			 
1386			 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "mal" 
1386						CALLMONITOR 
1386					endif 
1386			    push af            ; Save AF register 
1386			    ld a, l            ; Load low byte of size into A 
1386			    or h               ; Check if size is zero 
1386			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1386			 
1386			    ; Allocate memory 
1386			    ld hl, (heap_start) ; Load start of heap into HL 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "ma1" 
1386						CALLMONITOR 
1386					endif 
1386			    call malloc_internal ; Call internal malloc function 
1386			    pop af             ; Restore AF register 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret                ; Return 
1386			 
1386			; Free Function: 
1386			; Input: 
1386			;   HL: Pointer to memory block to free 
1386			; Output: 
1386			;   None 
1386			 
1386			free: 
1386			    push af            ; Save AF register 
1386			    ld a, l            ; Load low byte of pointer into A 
1386			    or h               ; Check if pointer is NULL 
1386			    jp z, free_exit    ; If pointer is NULL, exit 
1386			 
1386			    ; Free memory 
1386			    ld hl, (heap_start) ; Load start of heap into HL 
1386			    call free_internal  ; Call internal free function 
1386			    pop af             ; Restore AF register 
1386			    ret                ; Return 
1386			 
1386			; Internal Malloc Function: 
1386			; Input: 
1386			;   HL: Size of block to allocate 
1386			; Output: 
1386			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1386			 
1386			malloc_internal: 
1386			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1386			    add hl, bc         ; Add management overhead to requested size 
1386			    ex de, hl          ; Save total size in DE, and keep it in HL 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "ma2" 
1386						CALLMONITOR 
1386					endif 
1386			 
1386			    ; Search for free memory block 
1386			    ld de, (heap_end)  ; Load end of heap into DE 
1386			    ld bc, 0           ; Initialize counter 
1386			 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "ma2" 
1386						CALLMONITOR 
1386					endif 
1386			malloc_search_loop: 
1386			    ; Check if current block is free 
1386			    ld a, (hl)         ; Load current block's status (free or used) 
1386			    cp 0               ; Compare with zero (free) 
1386			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1386			 
1386			    ; Check if current block is large enough 
1386			    ld a, (hl+1)       ; Load high byte of block size 
1386			    cp l               ; Compare with low byte of requested size 
1386			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1386			 
1386			    ld a, (hl+2)       ; Load low byte of block size 
1386			    cp h               ; Compare with high byte of requested size 
1386			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1386			 
1386			    ; Mark block as used 
1386			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1386			 
1386			    ; Calculate remaining space in block 
1386			    ld bc, 0           ; Clear BC 
1386			    add hl, bc         ; Increment HL to point to start of data block 
1386			    add hl, de         ; HL = HL + DE (total size) 
1386			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1386			    add hl, bc         ; Add management overhead to start of data block 
1386			 
1386			    ; Save pointer to allocated block in HL 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386						DMARK "ma5" 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret 
1386			 
1386			malloc_skip_block_check: 
1386			    ; Move to the next block 
1386			    ld bc, 3           ; Size of management overhead 
1386			    add hl, bc         ; Move to the next block 
1386			    inc de             ; Increment counter 
1386			 
1386			    ; Check if we have reached the end of heap 
1386			    ld a, e            ; Load low byte of heap end address 
1386			    cp (hl)            ; Compare with low byte of current address 
1386			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1386			    ld a, d            ; Load high byte of heap end address 
1386			    cp 0               ; Check if it's zero (end of memory) 
1386			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1386			 
1386			    ; If we reached here, allocation failed 
1386			    xor a              ; Set result to NULL 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386						DMARK "ma6" 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret 
1386			malloc_exit: 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386						DMARK "ma7" 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret 
1386			 
1386			; Internal Free Function: 
1386			; Input: 
1386			;   HL: Pointer to memory block to free 
1386			; Output: 
1386			;   None 
1386			 
1386			free_internal: 
1386			    ld de, (heap_start) ; Load start of heap into DE 
1386			    ld bc, 0            ; Initialize counter 
1386			 
1386			free_search_loop: 
1386			    ; Check if current block contains the pointer 
1386			    ld a, l             ; Load low byte of pointer 
1386			    cp (hl+1)           ; Compare with high byte of current block's address 
1386			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1386			    ld a, h             ; Load high byte of pointer 
1386			    cp (hl+2)           ; Compare with low byte of current block's address 
1386			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1386			 
1386			    ; Mark block as free 
1386			    ld (hl), 0          ; Set status byte to indicate free block 
1386			    ret                 ; Return 
1386			 
1386			free_skip_block_check: 
1386			    ; Move to the next block 
1386			    ld bc, 3            ; Size of management overhead 
1386			    add hl, bc          ; Move to the next block 
1386			    inc de              ; Increment counter 
1386			 
1386			    ; Check if we have reached the end of heap 
1386			    ld a, e             ; Load low byte of heap end address 
1386			    cp (hl)             ; Compare with low byte of current address 
1386			    jr nz, free_search_loop  ; If not equal, continue searching 
1386			    ld a, d             ; Load high byte of heap end address 
1386			    cp 0                ; Check if it's zero (end of memory) 
1386			    jr nz, free_search_loop  ; If not zero, continue searching 
1386			 
1386			    ; If we reached here, pointer is not found in heap 
1386			    ret 
1386			 
1386			free_exit: 
1386			    ret                 ; Return 
1386			 
1386			; Define heap start and end addresses 
1386			;heap_start:    .dw 0xC000   ; Start of heap 
1386			;heap_end:      .dw 0xE000   ; End of heap 
1386			 
1386			endif 
1386			 
1386			 
1386			if MALLOC_1 
1386			 
1386			 
1386			 
1386			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1386			 
1386			;moved to firmware.asm 
1386			;heap_start        .equ  0x9000      ; Starting address of heap 
1386			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1386			 
1386			;      .org 0 
1386			;      jp    main 
1386			 
1386			 
1386			;      .org  0x100 
1386			;main: 
1386			;      ld    HL, 0x8100 
1386			;      ld    SP, HL 
1386			; 
1386			;      call  heap_init 
1386			; 
1386			;      ; Make some allocations 
1386			;      ld    HL, 12 
1386			;      call  malloc            ; Allocates 0x9004 
1386			; 
1386			;      ld    HL, 12 
1386			;      call  malloc            ; Allocates 0x9014 
1386			; 
1386			;      ld    HL, 12 
1386			;      call  malloc            ; Allocates 0x9024 
1386			; 
1386			;      ; Free some allocations 
1386			;      ld    HL, 0x9014 
1386			;      call  free 
1386			; 
1386			;      ld    HL, 0x9004 
1386			;      call  free 
1386			; 
1386			;      ld    HL, 0x9024 
1386			;      call  free 
1386			; 
1386			; 
1386			;      halt 
1386			 
1386			 
1386			;------------------------------------------------------------------------------ 
1386			;     heap_init                                                               : 
1386			;                                                                             : 
1386			; Description                                                                 : 
1386			;     Initialise the heap and make it ready for malloc and free operations.   : 
1386			;                                                                             : 
1386			;     The heap is maintained as a linked list, starting with an initial       : 
1386			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1386			;     the first free block in the heap. Each block then points to the next    : 
1386			;     free block within the heap, and the free list ends at the first block   : 
1386			;     with a null pointer to the next free block.                             : 
1386			;                                                                             : 
1386			; Parameters                                                                  : 
1386			;     Inputs are compile-time only. Two defines which specify the starting    : 
1386			;     address of the heap and its size are required, along with a memory      : 
1386			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1386			;     principally stores a pointer to the first free block in the heap.       : 
1386			;                                                                             : 
1386			; Returns                                                                     : 
1386			;     Nothing                                                                 : 
1386			;------------------------------------------------------------------------------ 
1386			heap_init: 
1386 e5			      push  HL 
1387			 
1387			      ; Initialise free list struct 
1387 21 0e 80		      ld    HL, heap_start 
138a 22 0a 80		      ld    (free_list), HL 
138d 21 00 00		      ld    HL, 0 
1390 22 0c 80		      ld    (free_list+2), HL 
1393			 
1393			      ; Insert first free block at bottom of heap, consumes entire heap 
1393 21 d3 f0		      ld    HL, heap_start+heap_size-4 
1396 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1399 21 c5 70		      ld    HL, heap_size-4 
139c 22 10 80		      ld    (heap_start+2), HL      ; Block size 
139f			 
139f			      ; Insert end of free list block at top of heap - two null words will 
139f			      ; terminate the free list 
139f 21 00 00		      ld    HL, 0 
13a2 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
13a5 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
13a8			 
13a8 e1			      pop   HL 
13a9			 
13a9 c9			      ret 
13aa			 
13aa			 
13aa			;------------------------------------------------------------------------------ 
13aa			;     malloc                                                                  : 
13aa			;                                                                             : 
13aa			; Description                                                                 : 
13aa			;     Allocates the wanted space from the heap and returns the address of the : 
13aa			;     first useable byte of the allocation.                                   : 
13aa			;                                                                             : 
13aa			;     Allocations can happen in one of two ways:                              : 
13aa			;                                                                             : 
13aa			;     1. A free block may be found which is the exact size wanted. In this    : 
13aa			;        case the block is removed from the free list and retuedn to the      : 
13aa			;        caller.                                                              : 
13aa			;     2. A free block may be found which is larger than the size wanted. In   : 
13aa			;        this case, the larger block is split into two. The first portion of  : 
13aa			;        this block will become the requested space by the malloc call and    : 
13aa			;        is returned to the caller. The second portion becomes a new free     : 
13aa			;        block, and the free list is adjusted to maintain continuity via this : 
13aa			;        newly created block.                                                 : 
13aa			;                                                                             : 
13aa			;     malloc does not set any initial value in the allocated space, the       : 
13aa			;     caller is required to do this as required.                              : 
13aa			;                                                                             : 
13aa			;     This implementation of malloc uses the stack exclusively, and is        : 
13aa			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13aa			;     advisable to disable interrupts before calling malloc, and recommended  : 
13aa			;     to avoid the use of malloc inside ISRs in general.                      : 
13aa			;                                                                             : 
13aa			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13aa			;                                                                             : 
13aa			; Parameters                                                                  : 
13aa			;     HL  Number of bytes wanted                                              : 
13aa			;                                                                             : 
13aa			; Returns                                                                     : 
13aa			;     HL  Address of the first useable byte of the allocation                 : 
13aa			;                                                                             : 
13aa			; Flags                                                                       : 
13aa			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13aa			;                                                                             : 
13aa			; Stack frame                                                                 : 
13aa			;       |             |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |     BC      |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |     DE      |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |     IX      |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |  prev_free  |                                                       : 
13aa			;   +4  +-------------+                                                       : 
13aa			;       |  this_free  |                                                       : 
13aa			;   +2  +-------------+                                                       : 
13aa			;       |  next_free  |                                                       : 
13aa			;   +0  +-------------+                                                       : 
13aa			;       |             |                                                       : 
13aa			;                                                                             : 
13aa			;------------------------------------------------------------------------------ 
13aa			 
13aa			 
13aa			;malloc: 
13aa			; 
13aa			;	SAVESP ON 1 
13aa			; 
13aa			;	call malloc_code 
13aa			; 
13aa			;	CHECKSP ON 1 
13aa			;	ret 
13aa			 
13aa			 
13aa			malloc: 
13aa c5			      push  BC 
13ab d5			      push  DE 
13ac dd e5		      push  IX 
13ae			if DEBUG_FORTH_MALLOC_HIGH 
13ae			call malloc_guard_entry 
13ae			endif 
13ae			 
13ae					if DEBUG_FORTH_MALLOC 
13ae						DMARK "mal" 
13ae						CALLMONITOR 
13ae					endif 
13ae 7c			      ld    A, H                    ; Exit if no space requested 
13af b5			      or    L 
13b0 ca 6f 14		      jp    Z, malloc_early_exit 
13b3			 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			; 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			 
13b3			 
13b3			 
13b3			 
13b3					if DEBUG_FORTH_MALLOC 
13b3						DMARK "maA" 
13b3						CALLMONITOR 
13b3					endif 
13b3			      ; Set up stack frame 
13b3 eb			      ex    DE, HL 
13b4 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13b7 39			      add   HL, SP 
13b8 f9			      ld    SP, HL 
13b9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13bd dd 39		      add   IX, SP 
13bf			 
13bf			      ; Setup initial state 
13bf 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13c2 19			      add   HL, DE 
13c3			 
13c3 44			      ld    B, H                    ; Move want to BC 
13c4 4d			      ld    C, L 
13c5			 
13c5 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13c8 dd 75 04		      ld    (IX+4), L 
13cb dd 74 05		      ld    (IX+5), H 
13ce			 
13ce 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13cf 23			      inc   HL 
13d0 56			      ld    D, (HL) 
13d1 dd 73 02		      ld    (IX+2), E 
13d4 dd 72 03		      ld    (IX+3), D 
13d7 eb			      ex    DE, HL                  ; this_free ptr into HL 
13d8			 
13d8					if DEBUG_FORTH_MALLOC 
13d8						DMARK "maB" 
13d8						CALLMONITOR 
13d8					endif 
13d8			      ; Loop through free block list to find some space 
13d8			malloc_find_space: 
13d8 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13d9 23			      inc   HL 
13da 56			      ld    D, (HL) 
13db			 
13db 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13dc b3			      or    E 
13dd ca 69 14		      jp    Z, malloc_no_space 
13e0			 
13e0 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13e3 dd 72 01		      ld    (IX+1), D 
13e6			 
13e6			      ; Does this block have enough space to make the allocation? 
13e6 23			      inc   HL                      ; Load free block size into DE 
13e7 5e			      ld    E, (HL) 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea eb			      ex    DE, HL                  ; Check size of block against want 
13eb b7			      or    A                       ; Ensure carry flag clear 
13ec ed 42		      sbc   HL, BC 
13ee e5			      push  HL                      ; Store the result for later (new block size) 
13ef			 
13ef ca 3e 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13f2 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13f4			 
13f4			      ; this_free block is not big enough, setup ptrs to test next free block 
13f4 e1			      pop   HL                      ; Discard previous result 
13f5			 
13f5 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13f8 dd 66 03		      ld    H, (IX+3) 
13fb dd 75 04		      ld    (IX+4), L 
13fe dd 74 05		      ld    (IX+5), H 
1401			 
1401 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1404 dd 66 01		      ld    H, (IX+1) 
1407 dd 75 02		      ld    (IX+2), L 
140a dd 74 03		      ld    (IX+3), H 
140d			 
140d					if DEBUG_FORTH_MALLOC 
140d						DMARK "MA>" 
140d						CALLMONITOR 
140d					endif 
140d 18 c9		      jr    malloc_find_space 
140f			 
140f			      ; split a bigger block into two - requested size and remaining size 
140f			malloc_alloc_split: 
140f					if DEBUG_FORTH_MALLOC 
140f						DMARK "MAs" 
140f						CALLMONITOR 
140f					endif 
140f eb			      ex    DE, HL                  ; Calculate address of new free block 
1410 2b			      dec   HL 
1411 2b			      dec   HL 
1412 2b			      dec   HL 
1413 09			      add   HL, BC 
1414			 
1414			      ; Create a new block and point it at next_free 
1414 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1417 dd 56 01		      ld    D, (IX+1) 
141a			 
141a 73			      ld    (HL), E                 ; Store next_free ptr into new block 
141b 23			      inc   HL 
141c 72			      ld    (HL), D 
141d			 
141d d1			      pop   DE                      ; Store size of new block into new block 
141e 23			      inc   HL 
141f 73			      ld    (HL), E 
1420 23			      inc   HL 
1421 72			      ld    (HL), D 
1422			 
1422			      ; Update this_free ptr to point to new block 
1422 2b			      dec   HL 
1423 2b			      dec   HL 
1424 2b			      dec   HL 
1425			 
1425 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1428 dd 56 03		      ld    D, (IX+3) 
142b			 
142b dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
142e dd 74 03		      ld    (IX+3), H 
1431			 
1431			      ; Modify this_free block to be allocation 
1431 eb			      ex    DE, HL 
1432 af			      xor   A                       ; Null the next block ptr of allocated block 
1433 77			      ld    (HL), A 
1434 23			      inc   HL 
1435 77			      ld    (HL), A 
1436			 
1436 23			      inc   HL                      ; Store want size into allocated block 
1437 71			      ld    (HL), C 
1438 23			      inc   HL 
1439 70			      ld    (HL), B 
143a 23			      inc   HL 
143b e5			      push  HL                      ; Address of allocation to return 
143c			 
143c 18 19		      jr    malloc_update_links 
143e			 
143e			malloc_alloc_fit: 
143e e1			      pop   HL                      ; Dont need new block size, want is exact fit 
143f			 
143f					if DEBUG_FORTH_MALLOC 
143f						DMARK "MAf" 
143f						CALLMONITOR 
143f					endif 
143f			      ; Modify this_free block to be allocation 
143f eb			      ex    DE, HL 
1440 2b			      dec   HL 
1441 2b			      dec   HL 
1442 2b			      dec   HL 
1443			 
1443 af			      xor   A                       ; Null the next block ptr of allocated block 
1444 77			      ld    (HL), A 
1445 23			      inc   HL 
1446 77			      ld    (HL), A 
1447			 
1447 23			      inc   HL                      ; Store address of allocation to return 
1448 23			      inc   HL 
1449 23			      inc   HL 
144a e5			      push  HL 
144b			 
144b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
144b dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
144e dd 66 01		      ld    H, (IX+1) 
1451			 
1451 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1454 dd 74 03		      ld    (IX+3), H 
1457			 
1457			 
1457			malloc_update_links: 
1457			      ; Update prev_free ptr to point to this_free 
1457 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
145a dd 66 05		      ld    H, (IX+5) 
145d			 
145d dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1460 dd 56 03		      ld    D, (IX+3) 
1463			 
1463 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1464 23			      inc   HL 
1465 72			      ld    (HL), D 
1466			 
1466					if DEBUG_FORTH_MALLOC 
1466						DMARK "Mul" 
1466						CALLMONITOR 
1466					endif 
1466			      ; Clear the Z flag to indicate successful allocation 
1466 7a			      ld    A, D 
1467 b3			      or    E 
1468			 
1468 d1			      pop   DE                      ; Address of allocation 
1469					if DEBUG_FORTH_MALLOC 
1469						DMARK "MAu" 
1469						CALLMONITOR 
1469					endif 
1469			 
1469			malloc_no_space: 
1469 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
146c 39			      add   HL, SP 
146d f9			      ld    SP, HL 
146e			 
146e eb			      ex    DE, HL                  ; Alloc addr into HL for return 
146f					if DEBUG_FORTH_MALLOC 
146f						DMARK "MAN" 
146f						CALLMONITOR 
146f					endif 
146f			 
146f			malloc_early_exit: 
146f					if DEBUG_FORTH_MALLOC 
146f						DMARK "MAx" 
146f						CALLMONITOR 
146f					endif 
146f dd e1		      pop   IX 
1471 d1			      pop   DE 
1472 c1			      pop   BC 
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473 c9			      ret 
1474			 
1474			 
1474			;------------------------------------------------------------------------------ 
1474			;     free                                                                    : 
1474			;                                                                             : 
1474			; Description                                                                 : 
1474			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1474			;     returned by malloc, otherwise the behaviour is undefined.               : 
1474			;                                                                             : 
1474			;     Where possible, directly adjacent free blocks will be merged together   : 
1474			;     into larger blocks to help ensure that the heap does not become         : 
1474			;     excessively fragmented.                                                 : 
1474			;                                                                             : 
1474			;     free does not clear or set any other value into the freed space, and    : 
1474			;     therefore its contents may be visible through subsequent malloc's. The  : 
1474			;     caller should clear the freed space as required.                        : 
1474			;                                                                             : 
1474			;     This implementation of free uses the stack exclusively, and is          : 
1474			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1474			;     advisable to disable interrupts before calling free, and recommended    : 
1474			;     to avoid the use of free inside ISRs in general.                        : 
1474			;                                                                             : 
1474			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1474			;                                                                             : 
1474			; Parameters                                                                  : 
1474			;     HL  Pointer to address of first byte of allocation to be freed          : 
1474			;                                                                             : 
1474			; Returns                                                                     : 
1474			;     Nothing                                                                 : 
1474			;                                                                             : 
1474			; Stack frame                                                                 : 
1474			;       |             |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |     BC      |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |     DE      |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |     IX      |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |  prev_free  |                                                       : 
1474			;   +2  +-------------+                                                       : 
1474			;       |  next_free  |                                                       : 
1474			;   +0  +-------------+                                                       : 
1474			;       |             |                                                       : 
1474			;                                                                             : 
1474			;------------------------------------------------------------------------------ 
1474			free: 
1474 c5			      push  BC 
1475 d5			      push  DE 
1476 dd e5		      push  IX 
1478			 
1478 7c			      ld    A, H                    ; Exit if ptr is null 
1479 b5			      or    L 
147a ca 3e 15		      jp    Z, free_early_exit 
147d			 
147d			      ; Set up stack frame 
147d eb			      ex    DE, HL 
147e 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1481 39			      add   HL, SP 
1482 f9			      ld    SP, HL 
1483 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1487 dd 39		      add   IX, SP 
1489			 
1489			      ; The address in HL points to the start of the useable allocated space, 
1489			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1489			      ; address of the block itself. 
1489 eb			      ex    DE, HL 
148a 11 fc ff		      ld    DE, -4 
148d 19			      add   HL, DE 
148e			 
148e			      ; An allocated block must have a null next block pointer in it 
148e 7e			      ld    A, (HL) 
148f 23			      inc   HL 
1490 b6			      or    (HL) 
1491 c2 39 15		      jp    NZ, free_done 
1494			 
1494 2b			      dec   HL 
1495			 
1495 44			      ld    B, H                    ; Copy HL to BC 
1496 4d			      ld    C, L 
1497			 
1497			      ; Loop through the free list to find the first block with an address 
1497			      ; higher than the block being freed 
1497 21 0a 80		      ld    HL, free_list 
149a			 
149a			free_find_higher_block: 
149a 5e			      ld    E, (HL)                 ; Load next ptr from free block 
149b 23			      inc   HL 
149c 56			      ld    D, (HL) 
149d 2b			      dec   HL 
149e			 
149e dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14a1 dd 72 01		      ld    (IX+1), D 
14a4 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14a7 dd 74 03		      ld    (IX+3), H 
14aa			 
14aa 78			      ld    A, B                    ; Check if DE is greater than BC 
14ab ba			      cp    D                       ; Compare MSB first 
14ac 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14ae 30 04		      jr    NC, free_find_higher_block_skip 
14b0 79			      ld    A, C 
14b1 bb			      cp    E                       ; Then compare LSB 
14b2 38 08		      jr    C, free_found_higher_block 
14b4			 
14b4			free_find_higher_block_skip: 
14b4 7a			      ld    A, D                    ; Reached the end of the free list? 
14b5 b3			      or    E 
14b6 ca 39 15		      jp    Z, free_done 
14b9			 
14b9 eb			      ex    DE, HL 
14ba			 
14ba 18 de		      jr    free_find_higher_block 
14bc			 
14bc			free_found_higher_block: 
14bc			      ; Insert freed block between prev and next free blocks 
14bc 71			      ld    (HL), C                 ; Point prev free block to freed block 
14bd 23			      inc   HL 
14be 70			      ld    (HL), B 
14bf			 
14bf 60			      ld    H, B                    ; Point freed block at next free block 
14c0 69			      ld    L, C 
14c1 73			      ld    (HL), E 
14c2 23			      inc   HL 
14c3 72			      ld    (HL), D 
14c4			 
14c4			      ; Check if the freed block is adjacent to the next free block 
14c4 23			      inc   HL                      ; Load size of freed block into HL 
14c5 5e			      ld    E, (HL) 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 09			      add   HL, BC                  ; Add addr of freed block and its size 
14ca			 
14ca dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14cd dd 56 01		      ld    D, (IX+1) 
14d0			 
14d0 b7			      or    A                       ; Clear the carry flag 
14d1 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14d3 20 22		      jr    NZ, free_check_adjacent_to_prev 
14d5			 
14d5			      ; Freed block is adjacent to next, merge into one bigger block 
14d5 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14d6 5e			      ld    E, (HL) 
14d7 23			      inc   HL 
14d8 56			      ld    D, (HL) 
14d9 e5			      push  HL                      ; Save ptr to next block for later 
14da			 
14da 60			      ld    H, B                    ; Store ptr from next block into freed block 
14db 69			      ld    L, C 
14dc 73			      ld    (HL), E 
14dd 23			      inc   HL 
14de 72			      ld    (HL), D 
14df			 
14df e1			      pop   HL                      ; Restore ptr to next block 
14e0 23			      inc   HL                      ; Load size of next block into DE 
14e1 5e			      ld    E, (HL) 
14e2 23			      inc   HL 
14e3 56			      ld    D, (HL) 
14e4 d5			      push  DE                      ; Save next block size for later 
14e5			 
14e5 60			      ld    H, B                    ; Load size of freed block into HL 
14e6 69			      ld    L, C 
14e7 23			      inc   HL 
14e8 23			      inc   HL 
14e9 5e			      ld    E, (HL) 
14ea 23			      inc   HL 
14eb 56			      ld    D, (HL) 
14ec eb			      ex    DE, HL 
14ed			 
14ed d1			      pop   DE                      ; Restore size of next block 
14ee 19			      add   HL, DE                  ; Add sizes of both blocks 
14ef eb			      ex    DE, HL 
14f0			 
14f0 60			      ld    H, B                    ; Store new bigger size into freed block 
14f1 69			      ld    L, C 
14f2 23			      inc   HL 
14f3 23			      inc   HL 
14f4 73			      ld    (HL), E 
14f5 23			      inc   HL 
14f6 72			      ld    (HL), D 
14f7			 
14f7			free_check_adjacent_to_prev: 
14f7			      ; Check if the freed block is adjacent to the prev free block 
14f7 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14fa dd 66 03		      ld    H, (IX+3) 
14fd			 
14fd 23			      inc   HL                      ; Size of prev free block into DE 
14fe 23			      inc   HL 
14ff 5e			      ld    E, (HL) 
1500 23			      inc   HL 
1501 56			      ld    D, (HL) 
1502 2b			      dec   HL 
1503 2b			      dec   HL 
1504 2b			      dec   HL 
1505			 
1505 19			      add   HL, DE                  ; Add prev block addr and size 
1506			 
1506 b7			      or    A                       ; Clear the carry flag 
1507 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1509 20 2e		      jr    NZ, free_done 
150b			 
150b			      ; Freed block is adjacent to prev, merge into one bigger block 
150b 60			      ld    H, B                    ; Load next ptr from freed block into DE 
150c 69			      ld    L, C 
150d 5e			      ld    E, (HL) 
150e 23			      inc   HL 
150f 56			      ld    D, (HL) 
1510 e5			      push  HL                      ; Save freed block ptr for later 
1511			 
1511 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1514 dd 66 03		      ld    H, (IX+3) 
1517 73			      ld    (HL), E 
1518 23			      inc   HL 
1519 72			      ld    (HL), D 
151a			 
151a e1			      pop   HL                      ; Restore freed block ptr 
151b 23			      inc   HL                      ; Load size of freed block into DE 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f d5			      push  DE                      ; Save freed block size for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1523 dd 66 03		      ld    H, (IX+3) 
1526 23			      inc   HL 
1527 23			      inc   HL 
1528 5e			      ld    E, (HL) 
1529 23			      inc   HL 
152a 56			      ld    D, (HL) 
152b			 
152b e1			      pop   HL                      ; Add sizes of both blocks 
152c 19			      add   HL, DE 
152d eb			      ex    DE, HL 
152e			 
152e dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1531 dd 66 03		      ld    H, (IX+3) 
1534 23			      inc   HL 
1535 23			      inc   HL 
1536 73			      ld    (HL), E 
1537 23			      inc   HL 
1538 72			      ld    (HL), D 
1539			 
1539			free_done: 
1539 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
153c 39			      add   HL, SP 
153d f9			      ld    SP, HL 
153e			 
153e			free_early_exit: 
153e dd e1		      pop   IX 
1540 d1			      pop   DE 
1541 c1			      pop   BC 
1542			 
1542 c9			      ret 
1543			 
1543			; moved to firmware.asm 
1543			; 
1543			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1543			;                  .dw   0 
1543			 
1543			 
1543			endif 
1543			 
1543			 
1543			if MALLOC_3 
1543			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1543			;heap_start        .equ  0x9000      ; Starting address of heap 
1543			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1543			; 
1543			 ;     .org 0 
1543			  ;    jp    main 
1543			; 
1543			; 
1543			 ;     .org  0x100 
1543			;main: 
1543			 ;     ld    HL, 0x8100 
1543			  ;    ld    SP, HL 
1543			; 
1543			;      call  heap_init 
1543			 
1543			      ; Make some allocations 
1543			;      ld    HL, 12 
1543			;      call  malloc            ; Allocates 0x9004 
1543			; 
1543			 ;     ld    HL, 12 
1543			;      call  malloc            ; Allocates 0x9014 
1543			 
1543			;      ld    HL, 12 
1543			;      call  malloc            ; Allocates 0x9024 
1543			 
1543			      ; Free some allocations 
1543			;      ld    HL, 0x9014 
1543			;      call  free 
1543			 
1543			;      ld    HL, 0x9004 
1543			;      call  free 
1543			; 
1543			;      ld    HL, 0x9024 
1543			;      call  free 
1543			 
1543			 
1543			 ;     halt 
1543			 
1543			 
1543			;------------------------------------------------------------------------------ 
1543			;     heap_init                                                               : 
1543			;                                                                             : 
1543			; Description                                                                 : 
1543			;     Initialise the heap and make it ready for malloc and free operations.   : 
1543			;                                                                             : 
1543			;     The heap is maintained as a linked list, starting with an initial       : 
1543			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1543			;     the first free block in the heap. Each block then points to the next    : 
1543			;     free block within the heap, and the free list ends at the first block   : 
1543			;     with a null pointer to the next free block.                             : 
1543			;                                                                             : 
1543			; Parameters                                                                  : 
1543			;     Inputs are compile-time only. Two defines which specify the starting    : 
1543			;     address of the heap and its size are required, along with a memory      : 
1543			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1543			;     principally stores a pointer to the first free block in the heap.       : 
1543			;                                                                             : 
1543			; Returns                                                                     : 
1543			;     Nothing                                                                 : 
1543			;------------------------------------------------------------------------------ 
1543			heap_init: 
1543			      push  HL 
1543			 
1543			      ; Initialise free list struct 
1543			      ld    HL, heap_start 
1543			      ld    (free_list), HL 
1543			      ld    HL, 0 
1543			      ld    (free_list+2), HL 
1543			 
1543			      ; Insert first free block at bottom of heap, consumes entire heap 
1543			      ld    HL, heap_start+heap_size-4 
1543			      ld    (heap_start), HL        ; Next block (end of free list) 
1543			      ld    HL, heap_size-4 
1543			      ld    (heap_start+2), HL      ; Block size 
1543			 
1543			      ; Insert end of free list block at top of heap - two null words will 
1543			      ; terminate the free list 
1543			      ld    HL, 0 
1543			      ld    (heap_start+heap_size-2), HL 
1543			      ld    (heap_start+heap_size-4), HL 
1543			 
1543			      pop   HL 
1543			 
1543			      ret 
1543			 
1543			 
1543			;------------------------------------------------------------------------------ 
1543			;     malloc                                                                  : 
1543			;                                                                             : 
1543			; Description                                                                 : 
1543			;     Allocates the wanted space from the heap and returns the address of the : 
1543			;     first useable byte of the allocation.                                   : 
1543			;                                                                             : 
1543			;     Allocations can happen in one of two ways:                              : 
1543			;                                                                             : 
1543			;     1. A free block may be found which is the exact size wanted. In this    : 
1543			;        case the block is removed from the free list and retuedn to the      : 
1543			;        caller.                                                              : 
1543			;     2. A free block may be found which is larger than the size wanted. In   : 
1543			;        this case, the larger block is split into two. The first portion of  : 
1543			;        this block will become the requested space by the malloc call and    : 
1543			;        is returned to the caller. The second portion becomes a new free     : 
1543			;        block, and the free list is adjusted to maintain continuity via this : 
1543			;        newly created block.                                                 : 
1543			;                                                                             : 
1543			;     malloc does not set any initial value in the allocated space, the       : 
1543			;     caller is required to do this as required.                              : 
1543			;                                                                             : 
1543			;     This implementation of malloc uses the stack exclusively, and is        : 
1543			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1543			;     advisable to disable interrupts before calling malloc, and recommended  : 
1543			;     to avoid the use of malloc inside ISRs in general.                      : 
1543			;                                                                             : 
1543			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1543			;                                                                             : 
1543			; Parameters                                                                  : 
1543			;     HL  Number of bytes wanted                                              : 
1543			;                                                                             : 
1543			; Returns                                                                     : 
1543			;     HL  Address of the first useable byte of the allocation                 : 
1543			;                                                                             : 
1543			; Flags                                                                       : 
1543			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1543			;                                                                             : 
1543			; Stack frame                                                                 : 
1543			;       |             |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     BC      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     DE      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     IX      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |  prev_free  |                                                       : 
1543			;   +4  +-------------+                                                       : 
1543			;       |  this_free  |                                                       : 
1543			;   +2  +-------------+                                                       : 
1543			;       |  next_free  |                                                       : 
1543			;   +0  +-------------+                                                       : 
1543			;       |             |                                                       : 
1543			;                                                                             : 
1543			;------------------------------------------------------------------------------ 
1543			malloc: 
1543			      push  BC 
1543			      push  DE 
1543			      push  IX 
1543			 
1543			      ld    A, H                    ; Exit if no space requested 
1543			      or    L 
1543			      jp    Z, malloc_early_exit 
1543			 
1543			      ; Set up stack frame 
1543			      ex    DE, HL 
1543			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			      ld    IX, 0                   ; Use IX as a frame pointer 
1543			      add   IX, SP 
1543			 
1543			      ; Setup initial state 
1543			      ld    HL, 4                   ; want must also include space used by block struct 
1543			      add   HL, DE 
1543			 
1543			      ld    B, H                    ; Move want to BC 
1543			      ld    C, L 
1543			 
1543			      ld    HL, free_list           ; Store prev_free ptr to stack 
1543			      ld    (IX+4), L 
1543			      ld    (IX+5), H 
1543			 
1543			      ld    E, (HL)                 ; Store this_free ptr to stack 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      ld    (IX+2), E 
1543			      ld    (IX+3), D 
1543			      ex    DE, HL                  ; this_free ptr into HL 
1543			 
1543			      ; Loop through free block list to find some space 
1543			malloc_find_space: 
1543			      ld    E, (HL)                 ; Load next_free ptr into DE 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			 
1543			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1543			      or    E 
1543			      jp    Z, malloc_no_space 
1543			 
1543			      ld    (IX+0), E               ; Store next_free ptr to stack 
1543			      ld    (IX+1), D 
1543			 
1543			      ; Does this block have enough space to make the allocation? 
1543			      inc   HL                      ; Load free block size into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			 
1543			      ex    DE, HL                  ; Check size of block against want 
1543			      or    A                       ; Ensure carry flag clear 
1543			      sbc   HL, BC 
1543			      push  HL                      ; Store the result for later (new block size) 
1543			 
1543			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1543			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1543			 
1543			      ; this_free block is not big enough, setup ptrs to test next free block 
1543			      pop   HL                      ; Discard previous result 
1543			 
1543			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1543			      ld    H, (IX+3) 
1543			      ld    (IX+4), L 
1543			      ld    (IX+5), H 
1543			 
1543			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1543			      ld    H, (IX+1) 
1543			      ld    (IX+2), L 
1543			      ld    (IX+3), H 
1543			 
1543			      jr    malloc_find_space 
1543			 
1543			      ; split a bigger block into two - requested size and remaining size 
1543			malloc_alloc_split: 
1543			      ex    DE, HL                  ; Calculate address of new free block 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			      add   HL, BC 
1543			 
1543			      ; Create a new block and point it at next_free 
1543			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1543			      ld    D, (IX+1) 
1543			 
1543			      ld    (HL), E                 ; Store next_free ptr into new block 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      pop   DE                      ; Store size of new block into new block 
1543			      inc   HL 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      ; Update this_free ptr to point to new block 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			 
1543			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1543			      ld    D, (IX+3) 
1543			 
1543			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1543			      ld    (IX+3), H 
1543			 
1543			      ; Modify this_free block to be allocation 
1543			      ex    DE, HL 
1543			      xor   A                       ; Null the next block ptr of allocated block 
1543			      ld    (HL), A 
1543			      inc   HL 
1543			      ld    (HL), A 
1543			 
1543			      inc   HL                      ; Store want size into allocated block 
1543			      ld    (HL), C 
1543			      inc   HL 
1543			      ld    (HL), B 
1543			      inc   HL 
1543			      push  HL                      ; Address of allocation to return 
1543			 
1543			      jr    malloc_update_links 
1543			 
1543			malloc_alloc_fit: 
1543			      pop   HL                      ; Dont need new block size, want is exact fit 
1543			 
1543			      ; Modify this_free block to be allocation 
1543			      ex    DE, HL 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			 
1543			      xor   A                       ; Null the next block ptr of allocated block 
1543			      ld    (HL), A 
1543			      inc   HL 
1543			      ld    (HL), A 
1543			 
1543			      inc   HL                      ; Store address of allocation to return 
1543			      inc   HL 
1543			      inc   HL 
1543			      push  HL 
1543			 
1543			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1543			      ld    L, (IX+0)               ; next_free to HL 
1543			      ld    H, (IX+1) 
1543			 
1543			      ld    (IX+2), L               ; HL to this_free 
1543			      ld    (IX+3), H 
1543			 
1543			 
1543			malloc_update_links: 
1543			      ; Update prev_free ptr to point to this_free 
1543			      ld    L, (IX+4)               ; prev_free ptr to HL 
1543			      ld    H, (IX+5) 
1543			 
1543			      ld    E, (IX+2)               ; this_free ptr to DE 
1543			      ld    D, (IX+3) 
1543			 
1543			      ld    (HL), E                 ; this_free ptr into prev_free 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      ; Clear the Z flag to indicate successful allocation 
1543			      ld    A, D 
1543			      or    E 
1543			 
1543			      pop   DE                      ; Address of allocation 
1543			 
1543			malloc_no_space: 
1543			      ld    HL, 6                   ; Clean up stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			 
1543			      ex    DE, HL                  ; Alloc addr into HL for return 
1543			 
1543			malloc_early_exit: 
1543			      pop   IX 
1543			      pop   DE 
1543			      pop   BC 
1543			 
1543			      ret 
1543			 
1543			 
1543			;------------------------------------------------------------------------------ 
1543			;     free                                                                    : 
1543			;                                                                             : 
1543			; Description                                                                 : 
1543			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1543			;     returned by malloc, otherwise the behaviour is undefined.               : 
1543			;                                                                             : 
1543			;     Where possible, directly adjacent free blocks will be merged together   : 
1543			;     into larger blocks to help ensure that the heap does not become         : 
1543			;     excessively fragmented.                                                 : 
1543			;                                                                             : 
1543			;     free does not clear or set any other value into the freed space, and    : 
1543			;     therefore its contents may be visible through subsequent malloc's. The  : 
1543			;     caller should clear the freed space as required.                        : 
1543			;                                                                             : 
1543			;     This implementation of free uses the stack exclusively, and is          : 
1543			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1543			;     advisable to disable interrupts before calling free, and recommended    : 
1543			;     to avoid the use of free inside ISRs in general.                        : 
1543			;                                                                             : 
1543			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1543			;                                                                             : 
1543			; Parameters                                                                  : 
1543			;     HL  Pointer to address of first byte of allocation to be freed          : 
1543			;                                                                             : 
1543			; Returns                                                                     : 
1543			;     Nothing                                                                 : 
1543			;                                                                             : 
1543			; Stack frame                                                                 : 
1543			;       |             |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     BC      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     DE      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     IX      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |  prev_free  |                                                       : 
1543			;   +2  +-------------+                                                       : 
1543			;       |  next_free  |                                                       : 
1543			;   +0  +-------------+                                                       : 
1543			;       |             |                                                       : 
1543			;                                                                             : 
1543			;------------------------------------------------------------------------------ 
1543			free: 
1543			      push  BC 
1543			      push  DE 
1543			      push  IX 
1543			 
1543			      ld    A, H                    ; Exit if ptr is null 
1543			      or    L 
1543			      jp    Z, free_early_exit 
1543			 
1543			      ; Set up stack frame 
1543			      ex    DE, HL 
1543			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			      ld    IX, 0                   ; Use IX as a frame pointer 
1543			      add   IX, SP 
1543			 
1543			      ; The address in HL points to the start of the useable allocated space, 
1543			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1543			      ; address of the block itself. 
1543			      ex    DE, HL 
1543			      ld    DE, -4 
1543			      add   HL, DE 
1543			 
1543			      ; An allocated block must have a null next block pointer in it 
1543			      ld    A, (HL) 
1543			      inc   HL 
1543			      or    (HL) 
1543			      jp    NZ, free_done 
1543			 
1543			      dec   HL 
1543			 
1543			      ld    B, H                    ; Copy HL to BC 
1543			      ld    C, L 
1543			 
1543			      ; Loop through the free list to find the first block with an address 
1543			      ; higher than the block being freed 
1543			      ld    HL, free_list 
1543			 
1543			free_find_higher_block: 
1543			      ld    E, (HL)                 ; Load next ptr from free block 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      dec   HL 
1543			 
1543			      ld    (IX+0), E               ; Save ptr to next free block 
1543			      ld    (IX+1), D 
1543			      ld    (IX+2), L               ; Save ptr to prev free block 
1543			      ld    (IX+3), H 
1543			 
1543			      ld    A, B                    ; Check if DE is greater than BC 
1543			      cp    D                       ; Compare MSB first 
1543			      jr    Z, $+4                  ; MSB the same, compare LSB 
1543			      jr    NC, free_find_higher_block_skip 
1543			      ld    A, C 
1543			      cp    E                       ; Then compare LSB 
1543			      jr    C, free_found_higher_block 
1543			 
1543			free_find_higher_block_skip: 
1543			      ld    A, D                    ; Reached the end of the free list? 
1543			      or    E 
1543			      jp    Z, free_done 
1543			 
1543			      ex    DE, HL 
1543			 
1543			      jr    free_find_higher_block 
1543			 
1543			free_found_higher_block: 
1543			      ; Insert freed block between prev and next free blocks 
1543			      ld    (HL), C                 ; Point prev free block to freed block 
1543			      inc   HL 
1543			      ld    (HL), B 
1543			 
1543			      ld    H, B                    ; Point freed block at next free block 
1543			      ld    L, C 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      ; Check if the freed block is adjacent to the next free block 
1543			      inc   HL                      ; Load size of freed block into HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      ex    DE, HL 
1543			 
1543			      add   HL, BC                  ; Add addr of freed block and its size 
1543			 
1543			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1543			      ld    D, (IX+1) 
1543			 
1543			      or    A                       ; Clear the carry flag 
1543			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1543			      jr    NZ, free_check_adjacent_to_prev 
1543			 
1543			      ; Freed block is adjacent to next, merge into one bigger block 
1543			      ex    DE, HL                  ; Load next ptr from next block into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  HL                      ; Save ptr to next block for later 
1543			 
1543			      ld    H, B                    ; Store ptr from next block into freed block 
1543			      ld    L, C 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      pop   HL                      ; Restore ptr to next block 
1543			      inc   HL                      ; Load size of next block into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  DE                      ; Save next block size for later 
1543			 
1543			      ld    H, B                    ; Load size of freed block into HL 
1543			      ld    L, C 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      ex    DE, HL 
1543			 
1543			      pop   DE                      ; Restore size of next block 
1543			      add   HL, DE                  ; Add sizes of both blocks 
1543			      ex    DE, HL 
1543			 
1543			      ld    H, B                    ; Store new bigger size into freed block 
1543			      ld    L, C 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			free_check_adjacent_to_prev: 
1543			      ; Check if the freed block is adjacent to the prev free block 
1543			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1543			      ld    H, (IX+3) 
1543			 
1543			      inc   HL                      ; Size of prev free block into DE 
1543			      inc   HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			 
1543			      add   HL, DE                  ; Add prev block addr and size 
1543			 
1543			      or    A                       ; Clear the carry flag 
1543			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1543			      jr    NZ, free_done 
1543			 
1543			      ; Freed block is adjacent to prev, merge into one bigger block 
1543			      ld    H, B                    ; Load next ptr from freed block into DE 
1543			      ld    L, C 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  HL                      ; Save freed block ptr for later 
1543			 
1543			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1543			      ld    H, (IX+3) 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      pop   HL                      ; Restore freed block ptr 
1543			      inc   HL                      ; Load size of freed block into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  DE                      ; Save freed block size for later 
1543			 
1543			      ld    L, (IX+2)               ; Load size of prev block into DE 
1543			      ld    H, (IX+3) 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			 
1543			      pop   HL                      ; Add sizes of both blocks 
1543			      add   HL, DE 
1543			      ex    DE, HL 
1543			 
1543			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1543			      ld    H, (IX+3) 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			free_done: 
1543			      ld    HL, 4                   ; Clean up stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			 
1543			free_early_exit: 
1543			      pop   IX 
1543			      pop   DE 
1543			      pop   BC 
1543			 
1543			      ret 
1543			 
1543			 
1543			;      .org 0x8000 
1543			; 
1543			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1543			 ;                 .dw   0 
1543			 
1543			endif 
1543			 
1543			 
1543			if MALLOC_4 
1543			 
1543			; My memory allocation code. Very very simple.... 
1543			; allocate space under 250 chars 
1543			 
1543			heap_init: 
1543				; init start of heap as zero 
1543				;  
1543			 
1543				ld hl, heap_start 
1543				ld a, 0 
1543				ld (hl), a      ; empty block 
1543				inc hl 
1543				ld a, 0 
1543				ld (hl), a      ; length of block 
1543				; write end of list 
1543				inc hl 
1543				ld a,(hl) 
1543				inc hl 
1543				ld a,(hl) 
1543				 
1543			 
1543				; init some malloc vars 
1543			 
1543				ld hl, 0 
1543				ld (free_list), hl       ; store last malloc location 
1543			 
1543				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1543				ld a, 0 
1543				ld (hl), a 
1543			 
1543			 
1543				ld hl, heap_start 
1543				;  
1543				  
1543				ret 
1543			 
1543			 
1543			;    free block marker 
1543			;    requested size  
1543			;    pointer to next block 
1543			;    .... 
1543			;    next block marker 
1543			 
1543			 
1543			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1543			; 
1543			 
1543			 
1543			malloc:  
1543				push de 
1543				push bc 
1543				push af 
1543			 
1543				; hl space required 
1543				 
1543				ld c, l    ; hold space   (TODO only a max of 255) 
1543			 
1543			;	inc c     ; TODO BUG need to fix memory leak on push str 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			 
1543			 
1543			 
1543				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1543			 
1543				ld a, (free_list+3) 
1543				cp 0 
1543				jr z, .contheap 
1543			 
1543				ld hl, (free_list)     ; get last alloc 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mrs" 
1543						CALLMONITOR 
1543					endif 
1543				jr .startalloc 
1543			 
1543			.contheap: 
1543				ld hl, heap_start 
1543			 
1543			.startalloc: 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mym" 
1543						CALLMONITOR 
1543					endif 
1543			.findblock: 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mmf" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543				ld a,(hl)  
1543				; if byte is zero then clear to use 
1543			 
1543				cp 0 
1543				jr z, .foundemptyblock 
1543			 
1543				; if byte is not clear 
1543				;     then byte is offset to next block 
1543			 
1543				inc hl 
1543				ld a, (hl) ; get size 
1543			.nextblock:	inc hl 
1543					ld e, (hl) 
1543					inc hl 
1543					ld d, (hl) 
1543					ex de, hl 
1543			;	inc hl  ; move past the store space 
1543			;	inc hl  ; move past zero index  
1543			 
1543				; TODO detect no more space 
1543			 
1543				push hl 
1543				ld de, heap_end 
1543				call cmp16 
1543				pop hl 
1543				jr nc, .nospace 
1543			 
1543				jr .findblock 
1543			 
1543			.nospace: ld hl, 0 
1543				jp .exit 
1543			 
1543			 
1543			.foundemptyblock:	 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mme" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			; TODO has block enough space if reusing??? 
1543			 
1543				;  
1543			 
1543			; see if this block has been previously used 
1543				inc hl 
1543				ld a, (hl) 
1543				dec hl 
1543				cp 0 
1543				jr z, .newblock 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "meR" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			; no reusing previously allocated block 
1543			 
1543			; is it smaller than previously used? 
1543				 
1543				inc hl    ; move to size 
1543				ld a, c 
1543				sub (hl)        ; we want c < (hl) 
1543				dec hl    ; move back to marker 
1543			        jr z, .findblock 
1543			 
1543				; update with the new size which should be lower 
1543			 
1543			        ;inc  hl   ; negate next move. move back to size  
1543			 
1543			.newblock: 
1543				; need to be at marker here 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "meN" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			 
1543				ld a, c 
1543			 
1543				ld (free_list+3), a	 ; flag resume from last malloc  
1543				ld (free_list), hl    ; save out last location 
1543			 
1543			 
1543				;inc a     ; space for length byte 
1543				ld (hl), a     ; save block in use marker 
1543			 
1543				inc hl   ; move to space marker 
1543				ld (hl), a    ; save new space 
1543			 
1543				inc hl   ; move to start of allocated area 
1543				 
1543			;	push hl     ; save where we are - 1  
1543			 
1543			;	inc hl  ; move past zero index  
1543				; skip space to set down new marker 
1543			 
1543				; provide some extra space for now 
1543			 
1543				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1543				inc a 
1543				inc a 
1543			 
1543				push hl   ; save where we are in the node block 
1543			 
1543				call addatohl 
1543			 
1543				; write linked list point 
1543			 
1543				pop de     ; get our node position 
1543				ex de, hl 
1543			 
1543				ld (hl), e 
1543				inc hl 
1543				ld (hl), d 
1543			 
1543				inc hl 
1543			 
1543				; now at start of allocated data so save pointer 
1543			 
1543				push hl 
1543			 
1543				; jump to position of next node and setup empty header in DE 
1543			 
1543				ex de, hl 
1543			 
1543			;	inc hl ; move past end of block 
1543			 
1543				ld a, 0 
1543				ld (hl), a   ; empty marker 
1543				inc hl 
1543				ld (hl), a   ; size 
1543				inc hl  
1543				ld (hl), a   ; ptr 
1543				inc hl 
1543				ld (hl), a   ; ptr 
1543			 
1543			 
1543				pop hl 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mmr" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			.exit: 
1543				pop af 
1543				pop bc 
1543				pop de  
1543				ret 
1543			 
1543			 
1543			 
1543			 
1543			free:  
1543				push hl 
1543				push af 
1543				; get address in hl 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "fre" 
1543						CALLMONITOR 
1543					endif 
1543				; data is at hl - move to block count 
1543				dec hl 
1543				dec hl    ; get past pointer 
1543				dec hl 
1543			 
1543				ld a, (hl)    ; need this for a validation check 
1543			 
1543				dec hl    ; move to block marker 
1543			 
1543				; now check that the block count and block marker are the same  
1543			        ; this checks that we are on a malloc node and not random memory 
1543			        ; OK a faint chance this could be a problem but rare - famous last words! 
1543			 
1543				ld c, a 
1543				ld a, (hl)    
1543			 
1543				cp c 
1543				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1543			 
1543				; yes good chance we are on a malloc node 
1543			 
1543				ld a, 0      
1543				ld (hl), a   ; mark as free 
1543			 
1543				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1543			 
1543			.freeignore:  
1543			 
1543				pop af 
1543				pop hl 
1543			 
1543				ret 
1543			 
1543			 
1543			 
1543			endif 
1543			 
1543			; eof 
# End of file firmware_memory.asm
1543			  
1543			; device C  
1543			; Now handled by SPI  
1543			;if SOUND_ENABLE  
1543			;	include "firmware_sound.asm"  
1543			;endif  
1543			  
1543			include "firmware_diags.asm"  
1543			; Hardware diags menu 
1543			 
1543			 
1543			config: 
1543			 
1543 3e 00			ld a, 0 
1545 21 6e 15			ld hl, .configmn 
1548 cd cc 0d			call menu 
154b			 
154b fe 00			cp 0 
154d c8				ret z 
154e			 
154e			;	cp 1 
154e			;	call z, .savetostore 
154e			 
154e fe 01			cp 1 
1550			if STARTUP_V1 
1550				call z, .selautoload 
1550			endif 
1550			 
1550			if STARTUP_V2 
1550 cc 7c 15			call z, .enautoload 
1553			endif 
1553 fe 02			cp 2 
1555 cc 93 15			call z, .disautoload 
1558			;	cp 3 
1558			;	call z, .selbank 
1558 fe 03			cp 3 
155a cc fc 17			call z, .debug_tog 
155d fe 04			cp 4 
155f cc 4a 19			call z, .bpsgo 
1562 fe 05			cp 5 
1564 cc 25 18			call z, hardware_diags 
1567			if STARTUP_V2 
1567 fe 06			cp 6 
1569 cc bf 15			call z, create_startup 
156c			endif 
156c 18 d5			jr config 
156e			 
156e			.configmn: 
156e			;	dw prom_c3 
156e 38 1b			dw prom_c2 
1570 4e 1b			dw prom_c2a 
1572			;	dw prom_c2b 
1572			;	dw prom_c4 
1572 c5 1b			dw prom_m4 
1574 e0 1b			dw prom_m4b 
1576 e8 1b			dw prom_c1 
1578			if STARTUP_V2 
1578 f7 1b			dw prom_c9 
157a			endif 
157a 00 00			dw 0 
157c				 
157c			 
157c			if STARTUP_V2 
157c			.enautoload: 
157c				if STORAGE_SE 
157c 3e fe			ld a, $fe      ; bit 0 clear 
157e 32 9b f9			ld (spi_device), a 
1581			 
1581 cd 16 05			call storage_get_block_0 
1584			 
1584 3e 01			ld a, 1 
1586 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1589			 
1589 21 00 00				ld hl, 0 
158c 11 b5 f9				ld de, store_page 
158f cd ca 04			call storage_write_block	 ; save update 
1592				else 
1592			 
1592				ld hl, prom_notav 
1592				ld de, prom_empty 
1592				call info_panel 
1592				endif 
1592			 
1592			 
1592 c9				ret 
1593			endif 
1593			 
1593			.disautoload: 
1593				if STORAGE_SE 
1593 3e fe			ld a, $fe      ; bit 0 clear 
1595 32 9b f9			ld (spi_device), a 
1598			 
1598 cd 16 05			call storage_get_block_0 
159b			 
159b 3e 00			ld a, 0 
159d 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
15a0			 
15a0 21 00 00				ld hl, 0 
15a3 11 b5 f9				ld de, store_page 
15a6 cd ca 04			call storage_write_block	 ; save update 
15a9				else 
15a9			 
15a9				ld hl, prom_notav 
15a9				ld de, prom_empty 
15a9				call info_panel 
15a9				endif 
15a9			 
15a9			 
15a9 c9				ret 
15aa			 
15aa			if STARTUP_V1 
15aa			 
15aa			; Select auto start 
15aa			 
15aa			.selautoload: 
15aa			 
15aa				 
15aa				if STORAGE_SE 
15aa			 
15aa					call config_dir 
15aa				        ld hl, scratch 
15aa					ld a, 0 
15aa					call menu 
15aa			 
15aa					cp 0 
15aa					ret z 
15aa			 
15aa					dec a 
15aa			 
15aa			 
15aa					; locate menu option 
15aa			 
15aa					ld hl, scratch 
15aa					call table_lookup 
15aa			 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "ALl" 
15aa						CALLMONITOR 
15aa					endif 
15aa					; with the pointer to the menu it, the byte following the zero term is the file id 
15aa			 
15aa					ld a, 0 
15aa					ld bc, 50   ; max of bytes to look at 
15aa					cpir  
15aa			 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "ALb" 
15aa						CALLMONITOR 
15aa					endif 
15aa					;inc hl 
15aa			 
15aa					ld a, (hl)   ; file id 
15aa					 
15aa				        ; save bank and file ids 
15aa			 
15aa					push af 
15aa			 
15aa			; TODO need to save to block 0 on bank 1	 
15aa			 
15aa					call storage_get_block_0 
15aa			 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "AL0" 
15aa						CALLMONITOR 
15aa					endif 
15aa					pop af 
15aa			 
15aa					ld (store_page+STORE_0_FILERUN),a 
15aa					 
15aa					; save bank id 
15aa			 
15aa					ld a,(spi_device) 
15aa					ld (store_page+STORE_0_BANKRUN),a 
15aa			 
15aa					; enable auto run of store file 
15aa			 
15aa					ld a, 1 
15aa					ld (store_page+STORE_0_AUTOFILE),a 
15aa			 
15aa					; save buffer 
15aa			 
15aa					ld hl, 0 
15aa					ld de, store_page 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "ALw" 
15aa						CALLMONITOR 
15aa					endif 
15aa				call storage_write_block	 ; save update 
15aa			  
15aa			 
15aa			 
15aa			 
15aa					ld hl, scratch 
15aa					call config_fdir 
15aa			 
15aa				else 
15aa			 
15aa				ld hl, prom_notav 
15aa				ld de, prom_empty 
15aa				call info_panel 
15aa			 
15aa				endif 
15aa				ret 
15aa			endif 
15aa			 
15aa			 
15aa			; Select storage bank 
15aa			 
15aa			.selbank: 
15aa			 
15aa			;	if STORAGE_SE 
15aa			;	else 
15aa			 
15aa 21 0c 1c			ld hl, prom_notav 
15ad 11 22 1c			ld de, prom_empty 
15b0 cd 2c 0d			call info_panel 
15b3			;	endif 
15b3				 
15b3 c9				ret 
15b4			 
15b4			if STORAGE_SE 
15b4			 
15b4			.config_ldir:   
15b4				; Load storage bank labels into menu array 
15b4			 
15b4				 
15b4			 
15b4			 
15b4 c9				ret 
15b5			 
15b5			 
15b5			endif 
15b5			 
15b5			 
15b5			; Save user words to storage 
15b5			 
15b5			.savetostore: 
15b5			 
15b5			;	if STORAGE_SE 
15b5			; 
15b5			;		call config_dir 
15b5			;	        ld hl, scratch 
15b5			;		ld a, 0 
15b5			;		call menu 
15b5			;		 
15b5			;		ld hl, scratch 
15b5			;		call config_fdir 
15b5			; 
15b5			;	else 
15b5			 
15b5 21 0c 1c			ld hl, prom_notav 
15b8 11 22 1c			ld de, prom_empty 
15bb cd 2c 0d			call info_panel 
15be			 
15be			;	endif 
15be			 
15be c9				ret 
15bf			 
15bf			if STARTUP_V2 
15bf			 
15bf			create_startup: 
15bf			 
15bf 3e 00			ld a, 0 
15c1 21 21 17			ld hl, .crstart 
15c4 cd cc 0d			call menu 
15c7			 
15c7 fe 00			cp 0 
15c9 c8				ret z 
15ca			 
15ca fe 01			cp 1 
15cc cc 08 16			call z, .genlsword 
15cf fe 02			cp 2 
15d1 cc 12 16			call z, .genedword 
15d4			 
15d4 fe 03			cp 3 
15d6 cc 1c 16			call z, .gendemword 
15d9			 
15d9 fe 04			cp 4 
15db cc 26 16			call z, .genutlword 
15de fe 05			cp 5 
15e0 cc 30 16			call z, .genspiword 
15e3 fe 06			cp 6 
15e5 cc 3a 16			call z, .genkeyword 
15e8 fe 07			cp 7 
15ea cc fe 15			call z, .gensoundword 
15ed fe 07			cp 7 
15ef cc f4 15			call z, .genhwword 
15f2 18 cb			jr create_startup 
15f4			 
15f4			.genhwword: 
15f4 21 af 1b			ld hl, crs_hw 
15f7 11 87 16			ld de, .hwworddef 
15fa cd 44 16			call .genfile 
15fd c9				ret 
15fe			.gensoundword: 
15fe 21 a3 1b			ld hl, crs_sound 
1601 11 95 16			ld de, .soundworddef 
1604 cd 44 16			call .genfile 
1607 c9				ret 
1608			.genlsword: 
1608 21 65 1b			ld hl, crs_s1 
160b 11 b9 16			ld de, .lsworddef 
160e cd 44 16			call .genfile 
1611 c9				ret 
1612			 
1612			.genedword: 
1612 11 bd 16			ld de, .edworddef 
1615 21 6e 1b			ld hl, crs_s2 
1618 cd 44 16			call .genfile 
161b c9				ret 
161c			 
161c			.gendemword: 
161c 11 c5 16			ld de, .demoworddef 
161f 21 77 1b			ld hl, crs_s3 
1622 cd 44 16			call .genfile 
1625 c9				ret 
1626			 
1626			.genutlword: 
1626 21 83 1b			ld hl, crs_s4 
1629 11 a9 16			ld de, .utilwordef 
162c cd 44 16			call .genfile 
162f c9				ret 
1630			.genspiword: 
1630 21 8a 1b			ld hl, crs_s5 
1633 11 e7 16			ld de, .spiworddef 
1636 cd 44 16			call .genfile 
1639 c9				ret 
163a			.genkeyword: 
163a 21 94 1b			ld hl, crs_s6 
163d 11 f5 16			ld de, .keyworddef 
1640 cd 44 16			call .genfile 
1643 c9				ret 
1644			 
1644			; hl - points to file name 
1644			; de - points to strings to add to file 
1644			 
1644			.genfile: 
1644 e5				push hl 
1645 d5				push de 
1646			 
1646 cd 9b 0d			call clear_display 
1649 3e 00			ld a, display_row_1 
164b 11 76 16			ld de, .genfiletxt 
164e cd ae 0d			call str_at_display 
1651 cd be 0d			call update_display 
1654			 
1654 d1				pop de 
1655 e1				pop hl 
1656			 
1656			 
1656 d5				push de 
1657 cd 68 08			call storage_create 
165a				; id in hl 
165a d1				pop de   ; table of strings to add 
165b			 
165b			.genloop: 
165b			 
165b e5				push hl ; save id for next time around 
165c d5				push de ; save de for next time around 
165d			 
165d eb				ex de, hl 
165e cd 52 23			call loadwordinhl 
1661 eb				ex de, hl 
1662			 
1662				; need hl to be the id 
1662				; need de to be the string ptr 
1662				 
1662 cd 55 0b			call storage_append 
1665			 
1665 d1				pop de 
1666 e1				pop hl 
1667			 
1667 13				inc de 
1668 13				inc de 
1669			 
1669 1a				ld a,(de) 
166a fe 00			cp 0 
166c 20 ed			jr nz, .genloop 
166e 13				inc de 
166f 1a				ld a, (de) 
1670 1b				dec de 
1671 fe 00			cp 0 
1673 20 e6			jr nz, .genloop	 
1675			 
1675 c9				ret 
1676			 
1676 .. 00		.genfiletxt:  db "Creating file...",0 
1687			 
1687			.hwworddef: 
1687 e9 64			dw test5 
1689 21 65			dw test6 
168b 59 65			dw test7 
168d 6d 65			dw test8 
168f 99 65			dw test9 
1691 af 65			dw test10 
1693 00 00			dw 0 
1695			 
1695			.soundworddef: 
1695 d4 65			dw sound1 
1697 f8 65			dw sound2 
1699 28 66			dw sound3 
169b 4d 66			dw sound4 
169d 5a 66			dw sound5 
169f 67 66			dw sound6 
16a1 74 66			dw sound7 
16a3 81 66			dw sound8 
16a5 99 66			dw sound9 
16a7 00 00			dw 0 
16a9			 
16a9			.utilwordef: 
16a9 22 63			dw strncpy 
16ab fd 62			dw type 
16ad c9 62			dw clrstack 
16af 82 62			dw longread 
16b1 83 63			dw start1 
16b3 93 63			dw start2 
16b5			; duplicated 
16b5			;	dw start3b 
16b5			;	dw start3c 
16b5 7f 64			dw list 
16b7 00 00			dw 0 
16b9			 
16b9			.lsworddef: 
16b9 a4 63			dw start3b 
16bb 00 00			dw 0 
16bd			 
16bd			.edworddef: 
16bd e1 5e			dw edit1 
16bf 02 5f			dw edit2 
16c1 37 5f			dw edit3 
16c3 00 00			dw 0 
16c5			 
16c5			.demoworddef: 
16c5 b0 66			dw game1 
16c7 c1 66			dw game1a 
16c9 23 67			dw game1b 
16cb 58 67			dw game1c 
16cd 8e 67			dw game1d 
16cf bf 67			dw game1s 
16d1 d3 67			dw game1t 
16d3 e8 67			dw game1f 
16d5 1c 68			dw game1z 
16d7 60 68			dw game1zz 
16d9 c9 68			dw ssv2 
16db ff 68			dw ssv3 
16dd 1b 69			dw ssv4 
16df 37 69			dw ssv5 
16e1 50 69			dw ssv1 
16e3 98 69			dw ssv1cpm	 
16e5			;	dw game2b 
16e5			;	dw game2bf 
16e5			;	dw game2mba 
16e5			;	dw game2mbas	 
16e5			;	dw game2mbht 
16e5			;	dw game2mbms 
16e5			;	dw game2mb 
16e5			;	dw game3w 
16e5			;	dw game3p 
16e5			;	dw game3sc 
16e5			;	dw game3vsi 
16e5			;	dw game3vs 
16e5 00 00			dw 0 
16e7			 
16e7			 
16e7			.spiworddef: 
16e7			 
16e7 6f 5f		    dw spi1 
16e9 c8 5f		    dw spi2 
16eb fc 5f		    dw spi2b 
16ed 80 60		    dw spi3 
16ef 2a 60		    dw spi4 
16f1 53 60		    dw spi5 
16f3			;    dw spi6 
16f3			;    dw spi7 
16f3			 
16f3			;    dw spi8 
16f3			;    dw spi9 
16f3			;    dw spi10 
16f3 00 00		    dw 0 
16f5			 
16f5			.keyworddef: 
16f5			 
16f5 ef 69			dw keyup 
16f7 fd 69			dw keydown 
16f9 0d 6a			dw keyleft 
16fb 1d 6a			dw keyright 
16fd 2e 6a			dw 	keyf1 
16ff 3c 6a			dw keyf2 
1701 4a 6a			dw keyf3 
1703 58 6a			dw keyf4 
1705 66 6a			dw keyf5 
1707 74 6a			dw keyf6 
1709 82 6a			dw keyf7 
170b 90 6a			dw keyf8 
170d 9e 6a			dw keyf9 
170f ac 6a			dw keyf10 
1711 bb 6a			dw keyf11 
1713 ca 6a			dw keyf12 
1715 d9 6a			dw keytab 
1717 e8 6a			dw keycr 
1719 f6 6a			dw keyhome 
171b 06 6b			dw keyend 
171d 15 6b			dw keybs 
171f 00 00			dw 0 
1721			 
1721			.crstart: 
1721 65 1b			dw crs_s1 
1723 6e 1b			dw crs_s2 
1725 77 1b			dw crs_s3 
1727 83 1b			dw crs_s4 
1729 8a 1b			dw crs_s5 
172b 94 1b			dw crs_s6 
172d a3 1b			dw crs_sound 
172f af 1b			dw crs_hw 
1731 00 00			dw 0 
1733			 
1733			endif 
1733			 
1733			 
1733			if STORAGE_SE 
1733			 
1733			config_fdir: 
1733				; using the scratch dir go through and release the memory allocated for each string 
1733				 
1733 21 fc f0			ld hl, scratch 
1736 5e			.cfdir:	ld e,(hl) 
1737 23				inc hl 
1738 56				ld d,(hl) 
1739 23				inc hl 
173a			 
173a eb				ex de, hl 
173b cd f8 0f			call ishlzero 
173e c8				ret z     ; return on null pointer 
173f cd 74 14			call free 
1742 eb				ex de, hl 
1743 18 f1			jr .cfdir 
1745			 
1745			 
1745 c9				ret 
1746			 
1746			 
1746			config_dir: 
1746			 
1746				; for the config menus that need to build a directory of storage call this routine 
1746				; it will construct a menu in scratch to pass to menu 
1746			 
1746				; open storage device 
1746			 
1746				; execute DIR to build a list of files and their ids into scratch in menu format 
1746				; once the menu has finished then will need to call config_fdir to release the strings 
1746				 
1746				; c = number items 
1746			 
1746				 
1746 cd 16 05			call storage_get_block_0 
1749			 
1749 21 b5 f9			ld hl, store_page     ; get current id count 
174c 46				ld b, (hl) 
174d 0e 00			ld c, 0    ; count of files   
174f			 
174f			 
174f 21 fc f0			ld hl, scratch 
1752 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
1755			 
1755				; check for empty drive 
1755			 
1755 3e 00			ld a, 0 
1757 b8				cp b 
1758 ca f2 17			jp z, .dirdone 
175b			 
175b				 
175b					if DEBUG_FORTH_WORDS 
175b						DMARK "Cdc" 
175b f5				push af  
175c 3a 70 17			ld a, (.dmark)  
175f 32 a6 fd			ld (debug_mark),a  
1762 3a 71 17			ld a, (.dmark+1)  
1765 32 a7 fd			ld (debug_mark+1),a  
1768 3a 72 17			ld a, (.dmark+2)  
176b 32 a8 fd			ld (debug_mark+2),a  
176e 18 03			jr .pastdmark  
1770 ..			.dmark: db "Cdc"  
1773 f1			.pastdmark: pop af  
1774			endm  
# End of macro DMARK
1774						CALLMONITOR 
1774 cd aa fd			call debug_vector  
1777				endm  
# End of macro CALLMONITOR
1777					endif 
1777			 
1777			 
1777			.diritem:	 
1777 c5				push bc 
1778				; for each of the current ids do a search for them and if found push to stack 
1778			 
1778 21 40 00				ld hl, STORE_BLOCK_PHY 
177b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
177d 58					ld e,b 
177e			 
177e cd 98 07				call storage_findnextid 
1781			 
1781			 
1781					; if found hl will be non zero 
1781			 
1781 cd f8 0f				call ishlzero 
1784 28 69				jr z, .dirnotfound 
1786			 
1786					; increase count 
1786			 
1786 c1					pop bc	 
1787 0c					inc c 
1788 c5					push bc 
1789					 
1789			 
1789					; get file header and push the file name 
1789			 
1789 11 b5 f9				ld de, store_page 
178c cd 65 04				call storage_read_block 
178f			 
178f					; push file id to stack 
178f				 
178f 3a b5 f9				ld a, (store_page) 
1792 26 00				ld h, 0 
1794 6f					ld l, a 
1795			 
1795					;call forth_push_numhl 
1795					; TODO store id 
1795			 
1795 e5					push hl 
1796			 
1796					; push extent count to stack  
1796				 
1796 21 b8 f9				ld hl, store_page+3 
1799			 
1799					; get file name length 
1799			 
1799 cd 35 13				call strlenz   
179c			 
179c 23					inc hl   ; cover zero term 
179d 23					inc hl  ; stick the id at the end of the area 
179e			 
179e e5					push hl 
179f c1					pop bc    ; move length to bc 
17a0			 
17a0 cd aa 13				call malloc 
17a3			 
17a3					; TODO save malloc area to scratch 
17a3			 
17a3 eb					ex de, hl 
17a4 2a ac f9				ld hl, (store_tmp2) 
17a7 73					ld (hl), e 
17a8 23					inc hl 
17a9 72					ld (hl), d 
17aa 23					inc hl 
17ab 22 ac f9				ld (store_tmp2), hl 
17ae			 
17ae					 
17ae			 
17ae					;pop hl   ; get source 
17ae			;		ex de, hl    ; swap aronund	 
17ae			 
17ae 21 b8 f9				ld hl, store_page+3 
17b1					if DEBUG_FORTH_WORDS 
17b1						DMARK "CFd" 
17b1 f5				push af  
17b2 3a c6 17			ld a, (.dmark)  
17b5 32 a6 fd			ld (debug_mark),a  
17b8 3a c7 17			ld a, (.dmark+1)  
17bb 32 a7 fd			ld (debug_mark+1),a  
17be 3a c8 17			ld a, (.dmark+2)  
17c1 32 a8 fd			ld (debug_mark+2),a  
17c4 18 03			jr .pastdmark  
17c6 ..			.dmark: db "CFd"  
17c9 f1			.pastdmark: pop af  
17ca			endm  
# End of macro DMARK
17ca						CALLMONITOR 
17ca cd aa fd			call debug_vector  
17cd				endm  
# End of macro CALLMONITOR
17cd					endif 
17cd ed b0				ldir 
17cf			 
17cf					; de is past string, move back one and store id 
17cf					 
17cf 1b					dec de 
17d0			 
17d0					; store file id 
17d0			 
17d0 e1					pop hl 
17d1 eb					ex de,hl 
17d2 73					ld (hl), e 
17d3			 
17d3					if DEBUG_FORTH_WORDS 
17d3						DMARK "Cdi" 
17d3 f5				push af  
17d4 3a e8 17			ld a, (.dmark)  
17d7 32 a6 fd			ld (debug_mark),a  
17da 3a e9 17			ld a, (.dmark+1)  
17dd 32 a7 fd			ld (debug_mark+1),a  
17e0 3a ea 17			ld a, (.dmark+2)  
17e3 32 a8 fd			ld (debug_mark+2),a  
17e6 18 03			jr .pastdmark  
17e8 ..			.dmark: db "Cdi"  
17eb f1			.pastdmark: pop af  
17ec			endm  
# End of macro DMARK
17ec						CALLMONITOR 
17ec cd aa fd			call debug_vector  
17ef				endm  
# End of macro CALLMONITOR
17ef					endif 
17ef					 
17ef			.dirnotfound: 
17ef c1					pop bc     
17f0 10 85				djnz .diritem 
17f2				 
17f2			.dirdone:	 
17f2			 
17f2 3e 00				ld a, 0 
17f4 2a ac f9				ld hl, (store_tmp2) 
17f7 77					ld (hl), a 
17f8 23					inc hl 
17f9 77					ld (hl), a 
17fa 23					inc hl 
17fb					; push a count of the dir items found 
17fb			 
17fb			;		ld h, 0 
17fb			;		ld l, c 
17fb			 
17fb c9				ret 
17fc			 
17fc			endif 
17fc			 
17fc			 
17fc			; Settings 
17fc			; Run  
17fc			 
17fc			 
17fc			 
17fc			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17fc			;;hd_menu2:   db "        2: Editor",0   
17fc			;hd_menu2:   db "        2: Editor       6: Menu",0   
17fc			;hd_menu3:   db "        3: Storage",0 
17fc			;hd_menu4:   db "0=quit  4: Debug",0 
17fc			;hd_don:     db "ON",0 
17fc			;hd_doff:     db "OFF",0 
17fc			; 
17fc			; 
17fc			; 
17fc			;hardware_diags_old:       
17fc			; 
17fc			;.diagmenu: 
17fc			;	call clear_display 
17fc			;	ld a, display_row_1 
17fc			;	ld de, hd_menu1 
17fc			;	call str_at_display 
17fc			; 
17fc			;	ld a, display_row_2 
17fc			;	ld de, hd_menu2 
17fc			;	call str_at_display 
17fc			; 
17fc			;	ld a, display_row_3 
17fc			;	ld de, hd_menu3 
17fc			;	call str_at_display 
17fc			; 
17fc			;	ld a,  display_row_4 
17fc			;	ld de, hd_menu4 
17fc			;	call str_at_display 
17fc			; 
17fc			;	; display debug state 
17fc			; 
17fc			;	ld de, hd_don 
17fc			;	ld a, (os_view_disable) 
17fc			;	cp 0 
17fc			;	jr z, .distog 
17fc			;	ld de, hd_doff 
17fc			;.distog: ld a, display_row_4+17 
17fc			;	call str_at_display 
17fc			; 
17fc			;	call update_display 
17fc			; 
17fc			;	call cin_wait 
17fc			; 
17fc			; 
17fc			; 
17fc			;	cp '4' 
17fc			;	jr nz, .diagn1 
17fc			; 
17fc			;	; debug toggle 
17fc			; 
17fc			;	ld a, (os_view_disable) 
17fc			;	ld b, '*' 
17fc			;	cp 0 
17fc			;	jr z, .debtog 
17fc			;	ld b, 0 
17fc			;.debtog:	 
17fc			;	ld a,b 
17fc			;	ld (os_view_disable),a 
17fc			; 
17fc			;.diagn1: cp '0' 
17fc			;	 ret z 
17fc			; 
17fc			;;	cp '1' 
17fc			;;       jp z, matrix	 
17fc			;;   TODO keyboard matrix test 
17fc			; 
17fc			;	cp '2' 
17fc			;	jp z, .diagedit 
17fc			; 
17fc			;;	cp '6' 
17fc			;;	jp z, .menutest 
17fc			;;if ENABLE_BASIC 
17fc			;;	cp '6' 
17fc			;;	jp z, basic 
17fc			;;endif 
17fc			 ; 
17fc			;	jp .diagmenu 
17fc			; 
17fc			; 
17fc			;	ret 
17fc			 
17fc			 
17fc			.debug_tog: 
17fc 21 46 18			ld hl, .menudebug 
17ff				 
17ff			;	ld a, (os_view_disable) 
17ff			;	cp '*' 
17ff 3a aa fd			ld a,(debug_vector) 
1802 fe c9			cp $C9   ; RET 
1804 20 04			jr nz,.tdon  
1806 3e 01			ld a, 1 
1808 18 02			jr .tog1 
180a 3e 00		.tdon: ld a, 0 
180c			 
180c			.tog1: 
180c cd cc 0d			call menu 
180f fe 00			cp 0 
1811 c8				ret z 
1812 fe 01			cp 1    ; disable debug 
1814 28 04			jr z, .dtog0 
1816 3e 2a			ld a, '*' 
1818 18 05			jr .dtogset 
181a			.dtog0:  
181a				;ld a, 0 
181a cd 38 19			call bp_on 
181d 18 dd			jr .debug_tog 
181f			.dtogset:  
181f				; ld (os_view_disable), a 
181f cd 44 19			call bp_off 
1822 c3 fc 17			jp .debug_tog 
1825			 
1825			 
1825			hardware_diags:       
1825			 
1825			.diagm: 
1825 21 38 18			ld hl, .menuitems 
1828 3e 00			ld a, 0 
182a cd cc 0d			call menu 
182d			 
182d fe 00		         cp 0 
182f c8				 ret z 
1830			 
1830 fe 02			cp 2 
1832 ca 91 18			jp z, .diagedit 
1835			 
1835			;	cp '6' 
1835			;	jp z, .menutest 
1835			;if ENABLE_BASIC 
1835			;	cp '6' 
1835			;	jp z, basic 
1835			;endif 
1835			  
1835 c3 25 18			jp .diagm 
1838			 
1838				 
1838 4c 18		.menuitems:   	dw .m1 
183a 57 18				dw .m2 
183c 5e 18				dw .m3 
183e 66 18				dw .m5 
1840 6c 18				dw .m5a 
1842 75 18				dw .m5b 
1844 00 00				dw 0 
1846			 
1846			.menudebug: 
1846 7e 18				dw .m6 
1848 87 18				dw .m7 
184a 00 00				dw 0 
184c			 
184c .. 00		.m1:   db "Key Matrix",0 
1857 .. 00		.m2:   db "Editor",0 
185e .. 00		.m3:   db "Storage",0 
1866 .. 00		.m5:   db "Sound",0 
186c .. 00		.m5a:  db "RAM Test",0 
1875 .. 00		.m5b:  db "LCD Test",0 
187e			 
187e .. 00		.m6:   db "Debug ON",0 
1887 .. 00		.m7:   db "Debug OFF",0 
1891			 
1891			; debug editor 
1891			 
1891			.diagedit: 
1891			 
1891 21 fc f0			ld hl, scratch 
1894			;	ld bc, 250 
1894			;	ldir 
1894				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1894 3e 00			ld a, 0 
1896 77				ld (hl), a 
1897 23				inc hl 
1898 77				ld (hl), a 
1899 23				inc hl 
189a 77				ld (hl), a 
189b			 
189b cd 9b 0d		        call clear_display 
189e cd be 0d			call update_display 
18a1				;ld a, 1 
18a1				;ld (hardware_diag), a 
18a1			.diloop: 
18a1 3e 00			ld a, display_row_1 
18a3 0e 00			ld c, 0 
18a5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18a7 1e 28			ld e, 40 
18a9			 
18a9 21 fc f0			ld hl, scratch	 
18ac cd fc 0f			call input_str 
18af			 
18af 3e 28			ld a, display_row_2 
18b1 11 fc f0			ld de, scratch 
18b4 cd ae 0d			call str_at_display 
18b7 cd be 0d			call update_display 
18ba			 
18ba c3 a1 18			jp .diloop 
18bd			 
18bd			 
18bd			; pass word in hl 
18bd			; a has display location 
18bd			display_word_at: 
18bd f5				push af 
18be e5				push hl 
18bf 7c				ld a,h 
18c0 21 01 f4			ld hl, os_word_scratch 
18c3 cd d8 11			call hexout 
18c6 e1				pop hl 
18c7 7d				ld a,l 
18c8 21 03 f4			ld hl, os_word_scratch+2 
18cb cd d8 11			call hexout 
18ce 21 05 f4			ld hl, os_word_scratch+4 
18d1 3e 00			ld a,0 
18d3 77				ld (hl),a 
18d4 11 01 f4			ld de,os_word_scratch 
18d7 f1				pop af 
18d8 cd ae 0d				call str_at_display 
18db c9				ret 
18dc			 
18dc			display_ptr_state: 
18dc			 
18dc				; to restore afterwards 
18dc			 
18dc d5				push de 
18dd c5				push bc 
18de e5				push hl 
18df f5				push af 
18e0			 
18e0				; for use in here 
18e0			 
18e0			;	push bc 
18e0			;	push de 
18e0			;	push hl 
18e0			;	push af 
18e0			 
18e0 cd 9b 0d			call clear_display 
18e3			 
18e3 11 bb 1a			ld de, .ptrstate 
18e6 3e 00			ld a, display_row_1 
18e8 cd ae 0d			call str_at_display 
18eb			 
18eb				; display debug step 
18eb			 
18eb			 
18eb 11 a6 fd			ld de, debug_mark 
18ee 3e 26			ld a, display_row_1+display_cols-2 
18f0 cd ae 0d			call str_at_display 
18f3			 
18f3				; display a 
18f3 11 c5 1a			ld de, .ptrcliptr 
18f6 3e 28			ld a, display_row_2 
18f8 cd ae 0d			call str_at_display 
18fb			 
18fb f1				pop af 
18fc 2a 7b f9			ld hl,(cli_ptr) 
18ff 3e 30			ld a, display_row_2+8 
1901 cd bd 18			call display_word_at 
1904			 
1904			 
1904				; display hl 
1904			 
1904			 
1904 11 cd 1a			ld de, .ptrclioptr 
1907 3e 32			ld a, display_row_2+10 
1909 cd ae 0d			call str_at_display 
190c			; 
190c			;	pop hl 
190c 3e 35			ld a, display_row_2+13 
190e 2a 79 f9			ld hl,(cli_origptr) 
1911 cd bd 18			call display_word_at 
1914			; 
1914			;	 
1914			;	; display de 
1914			 
1914			;	ld de, .regstatede 
1914			;	ld a, display_row_3 
1914			;	call str_at_display 
1914			 
1914			;	pop de 
1914			;	ld h,d 
1914			;	ld l, e 
1914			;	ld a, display_row_3+3 
1914			;	call display_word_at 
1914			 
1914			 
1914				; display bc 
1914			 
1914			;	ld de, .regstatebc 
1914			;	ld a, display_row_3+10 
1914			;	call str_at_display 
1914			 
1914			;	pop bc 
1914			;	ld h,b 
1914			;	ld l, c 
1914			;	ld a, display_row_3+13 
1914			;	call display_word_at 
1914			 
1914			 
1914				; display dsp 
1914			 
1914			;	ld de, .regstatedsp 
1914			;	ld a, display_row_4 
1914			;	call str_at_display 
1914			 
1914				 
1914			;	ld hl,(cli_data_sp) 
1914			;	ld a, display_row_4+4 
1914			;	call display_word_at 
1914			 
1914				; display rsp 
1914			 
1914 11 fc 1a			ld de, .regstatersp 
1917 3e 82			ld a, display_row_4+10 
1919 cd ae 0d			call str_at_display 
191c			 
191c				 
191c 2a 2d f9			ld hl,(cli_ret_sp) 
191f 3e 86			ld a, display_row_4+14 
1921 cd bd 18			call display_word_at 
1924			 
1924 cd be 0d			call update_display 
1927			 
1927 cd de 0c			call delay1s 
192a cd de 0c			call delay1s 
192d cd de 0c			call delay1s 
1930			 
1930			 
1930 cd 9b 1f			call next_page_prompt 
1933			 
1933				; restore  
1933			 
1933 f1				pop af 
1934 e1				pop hl 
1935 c1				pop bc 
1936 d1				pop de 
1937 c9				ret 
1938			 
1938			; Update the break point vector so that the user can hook a new routine 
1938			 
1938			bp_on: 
1938 3e c3			ld a, $c3    ; JP 
193a 32 aa fd			ld (debug_vector), a 
193d 21 4a 19			ld hl, break_point_state 
1940 22 ab fd			ld (debug_vector+1), hl 
1943 c9				ret 
1944			 
1944			bp_off: 
1944 3e c9			ld a, $c9    ; RET 
1946 32 aa fd			ld (debug_vector), a 
1949 c9				ret 
194a			 
194a			 
194a			break_point_state: 
194a			;	push af 
194a			; 
194a			;	; see if disabled 
194a			; 
194a			;	ld a, (os_view_disable) 
194a			;	cp '*' 
194a			;	jr nz, .bpsgo 
194a			;	pop af 
194a			;	ret 
194a			 
194a			.bpsgo: 
194a			;	pop af 
194a f5				push af 
194b 22 de f0			ld (os_view_hl), hl 
194e ed 53 dc f0		ld (os_view_de), de 
1952 ed 43 da f0		ld (os_view_bc), bc 
1956 e5				push hl 
1957 6f				ld l, a 
1958 26 00			ld h, 0 
195a 22 e0 f0			ld (os_view_af),hl 
195d			 
195d 21 ec fc				ld hl, display_fb0 
1960 22 07 fb				ld (display_fb_active), hl 
1963 e1				pop hl	 
1964			 
1964 3e 31			ld a, '1' 
1966 fe 2a		.bps1:  cp '*' 
1968 cc 44 19			call z, bp_off 
196b			;	jr nz, .bps1b 
196b			;	ld (os_view_disable),a 
196b fe 31		.bps1b:  cp '1' 
196d 20 14			jr nz, .bps2 
196f			 
196f				; display reg 
196f			 
196f				 
196f			 
196f 3a e0 f0			ld a, (os_view_af) 
1972 2a de f0			ld hl, (os_view_hl) 
1975 ed 5b dc f0		ld de, (os_view_de) 
1979 ed 4b da f0		ld bc, (os_view_bc) 
197d cd 17 1a			call display_reg_state 
1980 c3 03 1a			jp .bpschk 
1983			 
1983 fe 32		.bps2:  cp '2' 
1985 20 08			jr nz, .bps3 
1987				 
1987				; display hl 
1987 2a de f0			ld hl, (os_view_hl) 
198a cd 01 1b			call display_dump_at_hl 
198d			 
198d 18 74			jr .bpschk 
198f			 
198f fe 33		.bps3:  cp '3' 
1991 20 08			jr nz, .bps4 
1993			 
1993			        ; display de 
1993 2a dc f0			ld hl, (os_view_de) 
1996 cd 01 1b			call display_dump_at_hl 
1999			 
1999 18 68			jr .bpschk 
199b fe 34		.bps4:  cp '4' 
199d 20 08			jr nz, .bps5 
199f			 
199f			        ; display bc 
199f 2a da f0			ld hl, (os_view_bc) 
19a2 cd 01 1b			call display_dump_at_hl 
19a5			 
19a5 18 5c			jr .bpschk 
19a7 fe 35		.bps5:  cp '5' 
19a9 20 08		        jr nz, .bps7 
19ab			 
19ab				; display cur ptr 
19ab 2a 7b f9			ld hl, (cli_ptr) 
19ae cd 01 1b			call display_dump_at_hl 
19b1			 
19b1 18 50			jr .bpschk 
19b3 fe 36		.bps7:  cp '6' 
19b5 20 08			jr nz, .bps8b 
19b7				 
19b7				; display cur orig ptr 
19b7 2a 79 f9			ld hl, (cli_origptr) 
19ba cd 01 1b			call display_dump_at_hl 
19bd 18 44			jr .bpschk 
19bf fe 37		.bps8b:  cp '7' 
19c1 20 08			jr nz, .bps9 
19c3				 
19c3				; display dsp 
19c3 2a 29 f9			ld hl, (cli_data_sp) 
19c6 cd 01 1b			call display_dump_at_hl 
19c9			 
19c9 18 38			jr .bpschk 
19cb fe 39		.bps9:  cp '9' 
19cd 20 05			jr nz, .bps8c 
19cf				 
19cf				; display SP 
19cf			;	ld hl, sp 
19cf cd 01 1b			call display_dump_at_hl 
19d2			 
19d2 18 2f			jr .bpschk 
19d4 fe 38		.bps8c:  cp '8' 
19d6 20 08			jr nz, .bps8d 
19d8				 
19d8				; display rsp 
19d8 2a 2d f9			ld hl, (cli_ret_sp) 
19db cd 01 1b			call display_dump_at_hl 
19de			 
19de 18 23			jr .bpschk 
19e0 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19e2 20 05			jr nz, .bps8 
19e4 cd 69 1d			call monitor 
19e7			 
19e7 18 1a			jr .bpschk 
19e9 fe 30		.bps8:  cp '0' 
19eb 20 16			jr nz, .bpschk 
19ed			 
19ed 21 4b fc				ld hl, display_fb1 
19f0 22 07 fb				ld (display_fb_active), hl 
19f3 cd be 0d				call update_display 
19f6			 
19f6				;ld a, (os_view_af) 
19f6 2a de f0			ld hl, (os_view_hl) 
19f9 ed 5b dc f0		ld de, (os_view_de) 
19fd ed 4b da f0		ld bc, (os_view_bc) 
1a01 f1				pop af 
1a02 c9				ret 
1a03			 
1a03			.bpschk:   
1a03 cd de 0c			call delay1s 
1a06 3e 9f		ld a,display_row_4 + display_cols - 1 
1a08 11 99 1f		        ld de, endprg 
1a0b cd ae 0d			call str_at_display 
1a0e cd be 0d			call update_display 
1a11 cd 90 72			call cin_wait 
1a14			 
1a14 c3 66 19			jp .bps1 
1a17			 
1a17			 
1a17			display_reg_state: 
1a17			 
1a17				; to restore afterwards 
1a17			 
1a17 d5				push de 
1a18 c5				push bc 
1a19 e5				push hl 
1a1a f5				push af 
1a1b			 
1a1b				; for use in here 
1a1b			 
1a1b c5				push bc 
1a1c d5				push de 
1a1d e5				push hl 
1a1e f5				push af 
1a1f			 
1a1f cd 9b 0d			call clear_display 
1a22			 
1a22 11 d7 1a			ld de, .regstate 
1a25 3e 00			ld a, display_row_1 
1a27 cd ae 0d			call str_at_display 
1a2a			 
1a2a				; display debug step 
1a2a			 
1a2a			 
1a2a 11 a6 fd			ld de, debug_mark 
1a2d 3e 25			ld a, display_row_1+display_cols-3 
1a2f cd ae 0d			call str_at_display 
1a32			 
1a32				; display a 
1a32 11 f3 1a			ld de, .regstatea 
1a35 3e 28			ld a, display_row_2 
1a37 cd ae 0d			call str_at_display 
1a3a			 
1a3a e1				pop hl 
1a3b			;	ld h,0 
1a3b			;	ld l, a 
1a3b 3e 2b			ld a, display_row_2+3 
1a3d cd bd 18			call display_word_at 
1a40			 
1a40			 
1a40				; display hl 
1a40			 
1a40			 
1a40 11 e7 1a			ld de, .regstatehl 
1a43 3e 32			ld a, display_row_2+10 
1a45 cd ae 0d			call str_at_display 
1a48			 
1a48 e1				pop hl 
1a49 3e 35			ld a, display_row_2+13 
1a4b cd bd 18			call display_word_at 
1a4e			 
1a4e				 
1a4e				; display de 
1a4e			 
1a4e 11 eb 1a			ld de, .regstatede 
1a51 3e 50			ld a, display_row_3 
1a53 cd ae 0d			call str_at_display 
1a56			 
1a56 e1				pop hl 
1a57			;	ld h,d 
1a57			;	ld l, e 
1a57 3e 53			ld a, display_row_3+3 
1a59 cd bd 18			call display_word_at 
1a5c			 
1a5c			 
1a5c				; display bc 
1a5c			 
1a5c 11 ef 1a			ld de, .regstatebc 
1a5f 3e 5a			ld a, display_row_3+10 
1a61 cd ae 0d			call str_at_display 
1a64			 
1a64 e1				pop hl 
1a65			;	ld h,b 
1a65			;	ld l, c 
1a65 3e 5d			ld a, display_row_3+13 
1a67 cd bd 18			call display_word_at 
1a6a			 
1a6a			 
1a6a				; display dsp 
1a6a			 
1a6a 11 f7 1a			ld de, .regstatedsp 
1a6d 3e 78			ld a, display_row_4 
1a6f cd ae 0d			call str_at_display 
1a72			 
1a72				 
1a72 2a 29 f9			ld hl,(cli_data_sp) 
1a75 3e 7c			ld a, display_row_4+4 
1a77 cd bd 18			call display_word_at 
1a7a			 
1a7a				; display rsp 
1a7a			 
1a7a 11 fc 1a			ld de, .regstatersp 
1a7d 3e 82			ld a, display_row_4+10 
1a7f cd ae 0d			call str_at_display 
1a82			 
1a82				 
1a82 2a 2d f9			ld hl,(cli_ret_sp) 
1a85 3e 86			ld a, display_row_4+14 
1a87 cd bd 18			call display_word_at 
1a8a			 
1a8a cd be 0d			call update_display 
1a8d			 
1a8d			;	call delay1s 
1a8d			;	call delay1s 
1a8d			;	call delay1s 
1a8d			 
1a8d			 
1a8d			;	call next_page_prompt 
1a8d			 
1a8d				; restore  
1a8d			 
1a8d f1				pop af 
1a8e e1				pop hl 
1a8f c1				pop bc 
1a90 d1				pop de 
1a91 c9				ret 
1a92			 
1a92 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1aa6 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1abb .. 00		.ptrstate:	db "Ptr State",0 
1ac5 .. 00		.ptrcliptr:     db "cli_ptr",0 
1acd .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ad7 .. 00		.regstate:	db "Reg State (1/0)",0 
1ae7 .. 00		.regstatehl:	db "HL:",0 
1aeb .. 00		.regstatede:	db "DE:",0 
1aef .. 00		.regstatebc:	db "BC:",0 
1af3 .. 00		.regstatea:	db "A :",0 
1af7 .. 00		.regstatedsp:	db "DSP:",0 
1afc .. 00		.regstatersp:	db "RSP:",0 
1b01			 
1b01			display_dump_at_hl: 
1b01 e5				push hl 
1b02 d5				push de 
1b03 c5				push bc 
1b04 f5				push af 
1b05			 
1b05 22 1f f4			ld (os_cur_ptr),hl	 
1b08 cd 9b 0d			call clear_display 
1b0b cd a3 1e			call dumpcont 
1b0e			;	call delay1s 
1b0e			;	call next_page_prompt 
1b0e			 
1b0e			 
1b0e f1				pop af 
1b0f c1				pop bc 
1b10 d1				pop de 
1b11 e1				pop hl 
1b12 c9				ret 
1b13			 
1b13			;if ENABLE_BASIC 
1b13			;	include "nascombasic.asm" 
1b13			;	basic: 
1b13			;	include "forth/FORTH.ASM" 
1b13			;endif 
1b13			 
1b13			; eof 
1b13			 
1b13			 
# End of file firmware_diags.asm
1b13			  
1b13			include "firmware_prompts.asm"  
1b13			; Prompts  
1b13			 
1b13			; boot messages 
1b13			 
1b13 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b28 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b38			 
1b38			 
1b38			; config menus 
1b38			 
1b38			;prom_c3: db "Add Dictionary To File",0 
1b38			 
1b38			if STARTUP_V1 
1b38			prom_c2: db "Select Autoload File",0 
1b38			prom_c2a: db "Disable Autoload File", 0 
1b38			endif 
1b38			 
1b38			if STARTUP_V2 
1b38 .. 00		prom_c2: db "Enable Autoload Files",0 
1b4e .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b65			 
1b65 .. 00		crs_s1: db "*ls-word", 0 
1b6e .. 00		crs_s2: db "*ed-word", 0 
1b77 .. 00		crs_s3: db "*Demo-Games", 0 
1b83 .. 00		crs_s4: db "*Utils", 0 
1b8a .. 00		crs_s5: db "*SPI-Util", 0 
1b94 .. 00		crs_s6: db "*Key-Constants", 0 
1ba3 .. 00		crs_sound: db "*Sound-Util", 0 
1baf .. 00		crs_hw: db "*Hello-World",0 
1bbc			 
1bbc			 
1bbc			 
1bbc			endif 
1bbc			;prom_c2b: db "Select Storage Bank",0 
1bbc .. 00		prom_c4: db "Settings",0 
1bc5 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1be0 .. 00		prom_m4b:   db "Monitor",0 
1be8 .. 00		prom_c1: db "Hardware Diags",0 
1bf7			 
1bf7			 
1bf7			if STARTUP_V2 
1bf7 .. 00		prom_c9: db "Create Startup Files",0 
1c0c			endif 
1c0c			 
1c0c .. 00		prom_notav:    db "Feature not available",0 
1c22 .. 00		prom_empty:    db "",0 
1c23			 
1c23			; eof 
1c23			 
# End of file firmware_prompts.asm
1c23			  
1c23			  
1c23			; eof  
1c23			  
# End of file firmware.asm
1c23			 
1c23			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c23			;if BASE_KEV  
1c23			;baseram: equ 08000h 
1c23			;endif 
1c23			 
1c23			;if BASE_SC114 
1c23			;baseram:     equ    endofcode 
1c23			;endif 
1c23			 
1c23			 
1c23			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c23			 
1c23			; start system 
1c23			 
1c23			coldstart: 
1c23				; set sp 
1c23				; di/ei 
1c23			 
1c23 f3				di 
1c24 31 fd ff			ld sp, tos 
1c27 cd 17 6f			call init_nmi 
1c2a			;	ei 
1c2a			 
1c2a				; init spinner 
1c2a 3e 00			ld a,0 
1c2c 32 01 fb			ld (display_active), a 
1c2f			 
1c2f				; disable breakpoint by default 
1c2f			 
1c2f				;ld a,'*' 
1c2f			;	ld a,' ' 
1c2f			;	ld (os_view_disable),a 
1c2f			 
1c2f				; set break point vector as new break point on or off 
1c2f cd 44 19			call bp_off 
1c32			 
1c32				; init hardware 
1c32			 
1c32				; init keyboard and screen hardware 
1c32			 
1c32 cd 68 00			call hardware_init 
1c35			 
1c35			 
1c35 cd de 0c			call delay1s 
1c38 3e 58			ld a, display_row_3+8 
1c3a 11 03 00			ld de, buildtime 
1c3d cd ae 0d			call str_at_display 
1c40 cd be 0d			call update_display 
1c43			 
1c43 cd de 0c			call delay1s 
1c46 cd de 0c			call delay1s 
1c49 cd de 0c			call delay1s 
1c4c			 
1c4c				; detect if any keys are held down to enable breakpoints at start up 
1c4c			 
1c4c cd a1 72			call cin  
1c4f fe 00			cp 0 
1c51 28 03			jr z, .nokeys 
1c53			 
1c53				;call hardware_diags 
1c53 cd 43 15			call config 
1c56			 
1c56			;	ld de, .bpen 
1c56			;	ld a, display_row_4 
1c56			;	call str_at_display 
1c56			;	call update_display 
1c56			; 
1c56			;	ld a,0 
1c56			;	ld (os_view_disable),a 
1c56			; 
1c56			;.bpwait: 
1c56			;	call cin 
1c56			;	cp 0 
1c56			;	jr z, .bpwait 
1c56			;	jr .nokeys 
1c56			; 
1c56			; 
1c56			;.bpen:  db "Break points enabled!",0 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			.nokeys: 
1c56			 
1c56			 
1c56				 
1c56			 
1c56			;jp  testkey 
1c56			 
1c56			;call storage_get_block_0 
1c56			; 
1c56			;ld hl, 0 
1c56			;ld de, store_page 
1c56			;call storage_read_block 
1c56			 
1c56				 
1c56			;ld hl, 10 
1c56			;ld de, store_page 
1c56			;call storage_read_block 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			;stop:	nop 
1c56			;	jp stop 
1c56			 
1c56			 
1c56			 
1c56			main: 
1c56 cd 9b 0d			call clear_display 
1c59 cd be 0d			call update_display 
1c5c			 
1c5c			 
1c5c			 
1c5c			;	call testlcd 
1c5c			 
1c5c			 
1c5c			 
1c5c cd a0 23			call forth_init 
1c5f			 
1c5f			 
1c5f			warmstart: 
1c5f cd 76 23			call forth_warmstart 
1c62			 
1c62				; run startup word load 
1c62			        ; TODO prevent this running at warmstart after crash  
1c62			 
1c62				if STARTUP_ENABLE 
1c62			 
1c62					if STARTUP_V1 
1c62			 
1c62						if STORAGE_SE 
1c62							call forth_autoload 
1c62						endif 
1c62						call forth_startup 
1c62					endif 
1c62			 
1c62					if STARTUP_V2 
1c62			 
1c62						if STORAGE_SE 
1c62 cd 45 6d						call forth_autoload 
1c65						else 
1c65							call forth_startup 
1c65						endif 
1c65			 
1c65			 
1c65					endif 
1c65			 
1c65				endif 
1c65			 
1c65				; show free memory after boot 
1c65 11 04 1d			ld de, freeram 
1c68 3e 00			ld a, display_row_1 
1c6a cd ae 0d			call str_at_display 
1c6d			 
1c6d				; get current heap start after loading any uwords 
1c6d			 
1c6d				;ld de, (os_last_new_uword) 
1c6d				;ex de, hl 
1c6d			 
1c6d			; Or use heap_size word???? 
1c6d				;ld hl, heap_end 
1c6d				;ld hl, heap_size 
1c6d				;ld de, topusermem 
1c6d				;ld de, heap_start 
1c6d ed 5b 0a 80			ld de, (free_list )      
1c71 21 d7 f0				ld hl, heap_end 
1c74 ed 52			sbc hl, de 
1c76				;push hl 
1c76				;ld a,h	         	 
1c76				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c76				;call hexout 
1c76			   	;pop hl 
1c76			; 
1c76			;	ld a,l 
1c76			;	ld hl, os_word_scratch+2 
1c76			;	call hexout 
1c76			;	ld hl, os_word_scratch+4 
1c76			;	ld a, 0 
1c76			;	ld (hl),a 
1c76 eb				ex de, hl 
1c77 21 01 f4			ld hl, os_word_scratch 
1c7a cd e4 12			call uitoa_16 
1c7d			 
1c7d			 
1c7d 11 01 f4			ld de, os_word_scratch 
1c80 3e 0d			ld a, display_row_1 + 13 
1c82 cd ae 0d			call str_at_display 
1c85 cd be 0d			call update_display 
1c88			 
1c88			 
1c88				;call demo 
1c88			 
1c88			 
1c88				; init scratch input area for cli commands 
1c88			 
1c88 21 23 f4			ld hl, os_cli_cmd 
1c8b 3e 00			ld a,0 
1c8d 77				ld (hl),a 
1c8e 23				inc hl 
1c8f 77				ld (hl),a 
1c90			 
1c90 3e 00			ld a,0 
1c92 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c95			 
1c95 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c98 32 20 f4			ld (os_cur_ptr+1),a	 
1c9b			 
1c9b 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c9e 32 02 f4			ld (os_word_scratch+1),a	 
1ca1				 
1ca1			 
1ca1				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ca1 21 23 f4			ld hl, os_cli_cmd 
1ca4			 
1ca4 3e 00			ld a, 0		 ; init cli input 
1ca6 77				ld (hl), a 
1ca7 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ca9			cli: 
1ca9				; show cli prompt 
1ca9				;push af 
1ca9				;ld a, 0 
1ca9				;ld de, prompt 
1ca9				;call str_at_display 
1ca9			 
1ca9				;call update_display 
1ca9				;pop af 
1ca9				;inc a 
1ca9				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ca9			 
1ca9			.lastrecall: 
1ca9			 
1ca9 0e 00			ld c, 0 
1cab 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cad 1e 28			ld e, 40 
1caf			 
1caf 21 23 f4			ld hl, os_cli_cmd 
1cb2			 
1cb2				STACKFRAME OFF $fefe $9f9f 
1cb2				if DEBUG_STACK_IMB 
1cb2					if OFF 
1cb2						exx 
1cb2						ld de, $fefe 
1cb2						ld a, d 
1cb2						ld hl, curframe 
1cb2						call hexout 
1cb2						ld a, e 
1cb2						ld hl, curframe+2 
1cb2						call hexout 
1cb2						ld hl, $fefe 
1cb2						push hl 
1cb2						ld hl, $9f9f 
1cb2						push hl 
1cb2						exx 
1cb2					endif 
1cb2				endif 
1cb2			endm 
# End of macro STACKFRAME
1cb2			 
1cb2 cd fc 0f			call input_str 
1cb5			 
1cb5				STACKFRAMECHK OFF $fefe $9f9f 
1cb5				if DEBUG_STACK_IMB 
1cb5					if OFF 
1cb5						exx 
1cb5						ld hl, $9f9f 
1cb5						pop de   ; $9f9f 
1cb5						call cmp16 
1cb5						jr nz, .spnosame 
1cb5						ld hl, $fefe 
1cb5						pop de   ; $fefe 
1cb5						call cmp16 
1cb5						jr z, .spfrsame 
1cb5						.spnosame: call showsperror 
1cb5						.spfrsame: nop 
1cb5						exx 
1cb5					endif 
1cb5				endif 
1cb5			endm 
# End of macro STACKFRAMECHK
1cb5			 
1cb5			 
1cb5				; check to see if last line recall has been requested 
1cb5			 
1cb5			if EDIT_V2 
1cb5 fe 05			cp KEY_UP 
1cb7 20 0f			jr nz, .noexecline 
1cb9			 
1cb9 11 23 f4			ld de, os_cli_cmd 
1cbc 21 22 f5			ld hl, os_last_cmd 
1cbf 01 ff 00			ld bc, 255 
1cc2 ed b0			ldir 
1cc4 3e 00			ld a, 0 
1cc6 18 e1			jr .lastrecall 
1cc8			endif 
1cc8			 
1cc8			.noexecline: 
1cc8				; no so exec the line		 
1cc8			 
1cc8				; copy input to last command 
1cc8			 
1cc8 21 23 f4			ld hl, os_cli_cmd 
1ccb 11 22 f5			ld de, os_last_cmd 
1cce 01 ff 00			ld bc, 255 
1cd1 ed b0			ldir 
1cd3			 
1cd3				; wipe current buffer 
1cd3			 
1cd3			;	ld a, 0 
1cd3			;	ld hl, os_cli_cmd 
1cd3			;	ld de, os_cli_cmd+1 
1cd3			;	ld bc, 254 
1cd3			;	ldir 
1cd3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1cd3			;	call strcpy 
1cd3			;	ld a, 0 
1cd3			;	ld (hl), a 
1cd3			;	inc hl 
1cd3			;	ld (hl), a 
1cd3			;	inc hl 
1cd3			;	ld (hl), a 
1cd3			 
1cd3				; switch frame buffer to program  
1cd3			 
1cd3 21 4b fc				ld hl, display_fb1 
1cd6 22 07 fb				ld (display_fb_active), hl 
1cd9			 
1cd9			;	nop 
1cd9				STACKFRAME ON $fbfe $8f9f 
1cd9				if DEBUG_STACK_IMB 
1cd9					if ON 
1cd9						exx 
1cd9						ld de, $fbfe 
1cd9						ld a, d 
1cd9						ld hl, curframe 
1cd9						call hexout 
1cd9						ld a, e 
1cd9						ld hl, curframe+2 
1cd9						call hexout 
1cd9						ld hl, $fbfe 
1cd9						push hl 
1cd9						ld hl, $8f9f 
1cd9						push hl 
1cd9						exx 
1cd9					endif 
1cd9				endif 
1cd9			endm 
# End of macro STACKFRAME
1cd9				; first time into the parser so pass over the current scratch pad 
1cd9 21 23 f4			ld hl,os_cli_cmd 
1cdc				; tokenise the entered statement(s) in HL 
1cdc cd 1e 24			call forthparse 
1cdf			        ; exec forth statements in top of return stack 
1cdf cd 5e 24			call forthexec 
1ce2				;call forthexec_cleanup 
1ce2			;	call parsenext 
1ce2			 
1ce2				STACKFRAMECHK ON $fbfe $8f9f 
1ce2				if DEBUG_STACK_IMB 
1ce2					if ON 
1ce2						exx 
1ce2						ld hl, $8f9f 
1ce2						pop de   ; $8f9f 
1ce2						call cmp16 
1ce2						jr nz, .spnosame 
1ce2						ld hl, $fbfe 
1ce2						pop de   ; $fbfe 
1ce2						call cmp16 
1ce2						jr z, .spfrsame 
1ce2						.spnosame: call showsperror 
1ce2						.spfrsame: nop 
1ce2						exx 
1ce2					endif 
1ce2				endif 
1ce2			endm 
# End of macro STACKFRAMECHK
1ce2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1ce2			 
1ce2 3e 78			ld a, display_row_4 
1ce4 11 15 1d			ld de, endprog 
1ce7			 
1ce7 cd be 0d			call update_display		 
1cea			 
1cea cd 9b 1f			call next_page_prompt 
1ced			 
1ced				; switch frame buffer to cli 
1ced			 
1ced 21 ec fc				ld hl, display_fb0 
1cf0 22 07 fb				ld (display_fb_active), hl 
1cf3			 
1cf3			 
1cf3 cd 9b 0d		        call clear_display 
1cf6 cd be 0d			call update_display		 
1cf9			 
1cf9 21 23 f4			ld hl, os_cli_cmd 
1cfc			 
1cfc 3e 00			ld a, 0		 ; init cli input 
1cfe 77				ld (hl), a 
1cff			 
1cff				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1cff			 
1cff				; now on last line 
1cff			 
1cff				; TODO scroll screen up 
1cff			 
1cff				; TODO instead just clear screen and place at top of screen 
1cff			 
1cff			;	ld a, 0 
1cff			;	ld (f_cursor_ptr),a 
1cff			 
1cff				;call clear_display 
1cff				;call update_display 
1cff			 
1cff				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cff 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d01 c3 a9 1c			jp cli 
1d04			 
1d04 .. 00		freeram: db "Free bytes: ",0 
1d11 ..			asc: db "1A2F" 
1d15 .. 00		endprog: db "End prog...",0 
1d21			 
1d21			testenter2:   
1d21 21 2e f1			ld hl,scratch+50 
1d24 22 1f f4			ld (os_cur_ptr),hl 
1d27 c3 a9 1c			jp cli 
1d2a			 
1d2a			testenter:  
1d2a			 
1d2a 21 11 1d			ld hl,asc 
1d2d			;	ld a,(hl) 
1d2d			;	call nibble2val 
1d2d cd 2e 12			call get_byte 
1d30			 
1d30			 
1d30			;	ld a,(hl) 
1d30			;	call atohex 
1d30			 
1d30			;	call fourehexhl 
1d30 32 2e f1			ld (scratch+50),a 
1d33			 
1d33			 
1d33			 
1d33 21 13 1d			ld hl,asc+2 
1d36			;	ld a, (hl) 
1d36			;	call nibble2val 
1d36 cd 2e 12			call get_byte 
1d39			 
1d39			;	call fourehexhl 
1d39 32 30 f1			ld (scratch+52),a 
1d3c				 
1d3c 21 2e f1			ld hl,scratch+50 
1d3f 22 1f f4			ld (os_cur_ptr),hl 
1d42 c3 a9 1c			jp cli 
1d45			 
1d45			enter:	 
1d45 3a 00 f1			ld a,(scratch+4) 
1d48 fe 00			cp 0 
1d4a 28 0c			jr z, .entercont 
1d4c				; no, not a null term line so has an address to work out.... 
1d4c			 
1d4c 21 fe f0			ld hl,scratch+2 
1d4f cd 8e 12			call get_word_hl 
1d52			 
1d52 22 1f f4			ld (os_cur_ptr),hl	 
1d55 c3 a9 1c			jp cli 
1d58			 
1d58			 
1d58			.entercont:  
1d58			 
1d58 21 fe f0			ld hl, scratch+2 
1d5b cd 2e 12			call get_byte 
1d5e			 
1d5e 2a 1f f4		   	ld hl,(os_cur_ptr) 
1d61 77					ld (hl),a 
1d62 23					inc hl 
1d63 22 1f f4				ld (os_cur_ptr),hl 
1d66				 
1d66			; get byte  
1d66			 
1d66			 
1d66 c3 a9 1c			jp cli 
1d69			 
1d69			 
1d69			; basic monitor support 
1d69			 
1d69			monitor: 
1d69				;  
1d69 cd 9b 0d			call clear_display 
1d6c 3e 00			ld a, 0 
1d6e 11 bd 1d			ld de, .monprompt 
1d71 cd ae 0d			call str_at_display 
1d74 cd be 0d			call update_display 
1d77			 
1d77				; get a monitor command 
1d77			 
1d77 0e 00			ld c, 0     ; entry at top left 
1d79 16 64			ld d, 100   ; max buffer size 
1d7b 1e 0f			ld e, 15    ; input scroll area 
1d7d 3e 00			ld a, 0     ; init string 
1d7f 21 fa f2			ld hl, os_input 
1d82 77				ld (hl), a 
1d83 23				inc hl 
1d84 77				ld (hl), a 
1d85 21 fa f2			ld hl, os_input 
1d88 3e 01			ld a, 1     ; init string 
1d8a cd fc 0f			call input_str 
1d8d			 
1d8d cd 9b 0d		        call clear_display 
1d90 cd be 0d			call update_display		 
1d93			 
1d93 3a fa f2			ld a, (os_input) 
1d96 cd 2c 13			call toUpper 
1d99 fe 48		        cp 'H' 
1d9b ca 22 1e		        jp z, .monhelp 
1d9e fe 44			cp 'D'		; dump 
1da0 ca 55 1e			jp z, .mondump	 
1da3 fe 43			cp 'C'		; dump 
1da5 ca 6f 1e			jp z, .moncdump	 
1da8 fe 4d			cp 'M'		; dump 
1daa ca bf 1d			jp z, .moneditstart 
1dad fe 55			cp 'U'		; dump 
1daf ca cb 1d			jp z, .monedit	 
1db2 fe 47			cp 'G'		; dump 
1db4 ca 4b 1e			jp z, .monjump 
1db7 fe 51			cp 'Q'		; dump 
1db9 c8				ret z	 
1dba			 
1dba			 
1dba				; TODO "S" to access symbol by name and not need the address 
1dba				; TODO "F" to find a string in memory 
1dba			 
1dba c3 69 1d			jp monitor 
1dbd			 
1dbd .. 00		.monprompt: db ">", 0 
1dbf			 
1dbf			.moneditstart: 
1dbf				; get starting address 
1dbf			 
1dbf 21 fc f2			ld hl,os_input+2 
1dc2 cd 8e 12			call get_word_hl 
1dc5			 
1dc5 22 1f f4			ld (os_cur_ptr),hl	 
1dc8			 
1dc8 c3 69 1d			jp monitor 
1dcb			 
1dcb			.monedit: 
1dcb				; get byte to load 
1dcb			 
1dcb 21 fc f2			ld hl,os_input+2 
1dce cd 2e 12			call get_byte 
1dd1			 
1dd1				; get address to update 
1dd1 2a 1f f4			ld hl, (os_cur_ptr) 
1dd4			 
1dd4				; update byte 
1dd4			 
1dd4 77				ld (hl), a 
1dd5			 
1dd5				; move to next address and save it 
1dd5			 
1dd5 23				inc hl 
1dd6 22 1f f4			ld (os_cur_ptr),hl	 
1dd9			 
1dd9 c3 69 1d			jp monitor 
1ddc			 
1ddc			 
1ddc .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1df0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e0c .. 00		.monhelptext3:  db "G-Call address",0 
1e1b .. 00		.monhelptext4:  db "Q-Quit",0 
1e22			        
1e22			.monhelp: 
1e22 3e 00			ld a, display_row_1 
1e24 11 dc 1d		        ld de, .monhelptext1 
1e27			 
1e27 cd ae 0d			call str_at_display 
1e2a 3e 28			ld a, display_row_2 
1e2c 11 f0 1d		        ld de, .monhelptext2 
1e2f					 
1e2f cd ae 0d			call str_at_display 
1e32 3e 50			ld a, display_row_3 
1e34 11 0c 1e		        ld de, .monhelptext3 
1e37					 
1e37 cd ae 0d			call str_at_display 
1e3a 3e 78			ld a, display_row_4 
1e3c 11 1b 1e		        ld de, .monhelptext4 
1e3f cd ae 0d			call str_at_display 
1e42			 
1e42 cd be 0d			call update_display		 
1e45			 
1e45 cd 9b 1f			call next_page_prompt 
1e48 c3 69 1d			jp monitor 
1e4b			 
1e4b			.monjump:    
1e4b 21 fc f2			ld hl,os_input+2 
1e4e cd 8e 12			call get_word_hl 
1e51			 
1e51 e9				jp (hl) 
1e52 c3 69 1d			jp monitor 
1e55			 
1e55			.mondump:    
1e55 21 fc f2			ld hl,os_input+2 
1e58 cd 8e 12			call get_word_hl 
1e5b			 
1e5b 22 1f f4			ld (os_cur_ptr),hl	 
1e5e cd a3 1e			call dumpcont 
1e61 3e 78			ld a, display_row_4 
1e63 11 15 1d			ld de, endprog 
1e66			 
1e66 cd be 0d			call update_display		 
1e69			 
1e69 cd 9b 1f			call next_page_prompt 
1e6c c3 69 1d			jp monitor 
1e6f			.moncdump: 
1e6f cd a3 1e			call dumpcont 
1e72 3e 78			ld a, display_row_4 
1e74 11 15 1d			ld de, endprog 
1e77			 
1e77 cd be 0d			call update_display		 
1e7a			 
1e7a cd 9b 1f			call next_page_prompt 
1e7d c3 69 1d			jp monitor 
1e80			 
1e80			 
1e80			; TODO symbol access  
1e80			 
1e80			.symbols:     ;; A list of symbols that can be called up  
1e80 ec fc			dw display_fb0 
1e82 .. 00			db "fb0",0  
1e86 b5 f9		     	dw store_page 
1e88 .. 00			db "store_page",0 
1e93			 
1e93			 
1e93			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e93			 
1e93 3a fd f0			ld a,(scratch+1) 
1e96 fe 00			cp 0 
1e98 28 09			jr z, dumpcont 
1e9a			 
1e9a				; no, not a null term line so has an address to work out.... 
1e9a			 
1e9a 21 fe f0			ld hl,scratch+2 
1e9d cd 8e 12			call get_word_hl 
1ea0			 
1ea0 22 1f f4			ld (os_cur_ptr),hl	 
1ea3			 
1ea3			 
1ea3			 
1ea3			dumpcont: 
1ea3			 
1ea3				; dump bytes at ptr 
1ea3			 
1ea3			 
1ea3 3e 00			ld a, display_row_1 
1ea5 2a 07 fb			ld hl, (display_fb_active) 
1ea8 cd cf 0f			call addatohl 
1eab cd d3 1e			call .dumpbyterow 
1eae			 
1eae 3e 28			ld a, display_row_2 
1eb0 2a 07 fb			ld hl, (display_fb_active) 
1eb3 cd cf 0f			call addatohl 
1eb6 cd d3 1e			call .dumpbyterow 
1eb9			 
1eb9			 
1eb9 3e 50			ld a, display_row_3 
1ebb 2a 07 fb			ld hl, (display_fb_active) 
1ebe cd cf 0f			call addatohl 
1ec1 cd d3 1e			call .dumpbyterow 
1ec4			 
1ec4 3e 78			ld a, display_row_4 
1ec6 2a 07 fb			ld hl, (display_fb_active) 
1ec9 cd cf 0f			call addatohl 
1ecc cd d3 1e			call .dumpbyterow 
1ecf			 
1ecf cd be 0d			call update_display 
1ed2			;		jp cli 
1ed2 c9				ret 
1ed3			 
1ed3			.dumpbyterow: 
1ed3			 
1ed3				;push af 
1ed3			 
1ed3 e5				push hl 
1ed4			 
1ed4				; calc where to poke the ascii 
1ed4			if display_cols == 20 
1ed4				ld a, 16 
1ed4			else 
1ed4 3e 1f			ld a, 31 
1ed6			endif 
1ed6			 
1ed6 cd cf 0f			call addatohl 
1ed9 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
1edc			 
1edc			 
1edc			; display decoding address 
1edc 2a 1f f4		   	ld hl,(os_cur_ptr) 
1edf			 
1edf 7c				ld a,h 
1ee0 e1				pop hl 
1ee1 e5				push hl 
1ee2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ee2 cd d8 11			call hexout 
1ee5 2a 1f f4		   	ld hl,(os_cur_ptr) 
1ee8			 
1ee8 7d				ld a,l 
1ee9 e1				pop hl 
1eea 23				inc hl 
1eeb 23				inc hl 
1eec e5				push hl 
1eed			;	ld hl, os_word_scratch+2 
1eed cd d8 11			call hexout 
1ef0 e1				pop hl 
1ef1 23				inc hl 
1ef2 23				inc hl 
1ef3				;ld hl, os_word_scratch+4 
1ef3 3e 3a			ld a, ':' 
1ef5 77				ld (hl),a 
1ef6 23				inc hl 
1ef7				;ld a, 0 
1ef7				;ld (hl),a 
1ef7				;ld de, os_word_scratch 
1ef7				;pop af 
1ef7				;push af 
1ef7			;		ld a, display_row_2 
1ef7			;		call str_at_display 
1ef7			;		call update_display 
1ef7			 
1ef7			 
1ef7			;pop af 
1ef7			;	add 5 
1ef7			 
1ef7			if display_cols == 20 
1ef7				ld b, 4 
1ef7			else 
1ef7 06 08			ld b, 8 
1ef9			endif	 
1ef9			 
1ef9			.dumpbyte: 
1ef9 c5				push bc 
1efa e5				push hl 
1efb			 
1efb			 
1efb 2a 1f f4		   	ld hl,(os_cur_ptr) 
1efe 7e					ld a,(hl) 
1eff			 
1eff					; poke the ascii to display 
1eff 2a 01 f4				ld hl,(os_word_scratch) 
1f02 77					ld (hl),a 
1f03 23					inc hl 
1f04 22 01 f4				ld (os_word_scratch),hl 
1f07			 
1f07					 
1f07			 
1f07			 
1f07 e1					pop hl 
1f08 e5					push hl 
1f09			 
1f09 cd d8 11				call hexout 
1f0c			 
1f0c					 
1f0c 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f0f 23				inc hl 
1f10 22 1f f4		   	ld (os_cur_ptr),hl 
1f13			 
1f13 e1					pop hl 
1f14 23					inc hl 
1f15 23					inc hl 
1f16 23					inc hl 
1f17			 
1f17			 
1f17			 
1f17					;ld a,0 
1f17					;ld (os_word_scratch+2),a 
1f17					;pop af 
1f17					;push af 
1f17			 
1f17					;ld de, os_word_scratch 
1f17					;call str_at_display 
1f17			;		call update_display 
1f17			;		pop af 
1f17 c1					pop bc 
1f18 c6 03				add 3 
1f1a 10 dd			djnz .dumpbyte 
1f1c			 
1f1c				 
1f1c			 
1f1c c9				ret 
1f1d			 
1f1d			jump:	 
1f1d			 
1f1d 21 fe f0			ld hl,scratch+2 
1f20 cd 8e 12			call get_word_hl 
1f23				;ld hl,(scratch+2) 
1f23				;call fourehexhl 
1f23			 
1f23 22 1f f4			ld (os_cur_ptr),hl	 
1f26			 
1f26 e9				jp (hl) 
1f27			 
1f27			 
1f27			 
1f27			; TODO implement a basic monitor mode to start with 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			; testing and demo code during development 
1f27			 
1f27			 
1f27 .. 00		str1: db "Enter some text...",0 
1f3a .. 00		clear: db "                    ",0 
1f4f			 
1f4f			demo: 
1f4f			 
1f4f			 
1f4f			 
1f4f			;	call update_display 
1f4f			 
1f4f				; init scratch input area for testing 
1f4f 21 fc f0			ld hl, scratch	 
1f52 3e 00			ld a,0 
1f54 77				ld (hl),a 
1f55			 
1f55			 
1f55 3e 28		            LD   A, display_row_2 
1f57			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f57 11 27 1f		            LD   DE, str1 
1f5a cd ae 0d			call str_at_display 
1f5d			 
1f5d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f5d			cloop:	 
1f5d 3e 50		            LD   A, display_row_3 
1f5f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f5f 11 3a 1f		            LD   DE, clear 
1f62			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f62 cd ae 0d				call str_at_display 
1f65 3e 78			ld a, display_row_4 
1f67 11 97 1f			ld de, prompt 
1f6a			 
1f6a cd ae 0d				call str_at_display 
1f6d cd be 0d			call update_display 
1f70			 
1f70 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f72 16 0a			ld d, 10 
1f74 21 fc f0			ld hl, scratch	 
1f77 cd fc 0f			call input_str 
1f7a			 
1f7a			;	call clear_display 
1f7a			;'	call update_display 
1f7a			 
1f7a 3e 00		            LD   A, display_row_1 
1f7c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7c 11 3a 1f		            LD   DE, clear 
1f7f cd ae 0d				call str_at_display 
1f82			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f82 3e 00		            LD   A, display_row_1 
1f84			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f84 11 fc f0		            LD   DE, scratch 
1f87			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f87 cd ae 0d				call str_at_display 
1f8a cd be 0d			call update_display 
1f8d			 
1f8d 3e 00				ld a,0 
1f8f 21 fc f0			ld hl, scratch 
1f92 77				ld (hl),a 
1f93			 
1f93 00				nop 
1f94 c3 5d 1f			jp cloop 
1f97			 
1f97			 
1f97			 
1f97			; OS Prompt 
1f97			 
1f97 .. 00		prompt: db ">",0 
1f99 .. 00		endprg: db "?",0 
1f9b			 
1f9b			 
1f9b			; handy next page prompt 
1f9b			next_page_prompt: 
1f9b e5				push hl 
1f9c d5				push de 
1f9d f5				push af 
1f9e c5				push bc 
1f9f			 
1f9f 3e 9f			ld a,display_row_4 + display_cols - 1 
1fa1 11 99 1f		        ld de, endprg 
1fa4 cd ae 0d			call str_at_display 
1fa7 cd be 0d			call update_display 
1faa cd 90 72			call cin_wait 
1fad c1				pop bc 
1fae f1				pop af 
1faf d1				pop de 
1fb0 e1				pop hl 
1fb1			 
1fb1			 
1fb1 c9				ret 
1fb2			 
1fb2			 
1fb2			; forth parser 
1fb2			 
1fb2			; My forth kernel 
1fb2			include "forth_kernel.asm" 
1fb2			; 
1fb2			; kernel to the forth OS 
1fb2			 
1fb2			DS_TYPE_STR: equ 1     ; string type 
1fb2			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fb2			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fb2			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fb2			 
1fb2			FORTH_PARSEV1: equ 0 
1fb2			FORTH_PARSEV2: equ 0 
1fb2			FORTH_PARSEV3: equ 0 
1fb2			FORTH_PARSEV4: equ 0 
1fb2			FORTH_PARSEV5: equ 1 
1fb2			 
1fb2			;if FORTH_PARSEV5 
1fb2			;	FORTH_END_BUFFER: equ 0 
1fb2			;else 
1fb2			FORTH_END_BUFFER: equ 127 
1fb2			;endif 
1fb2			 
1fb2			FORTH_TRUE: equ 1 
1fb2			FORTH_FALSE: equ 0 
1fb2			 
1fb2			if FORTH_PARSEV4 
1fb2			include "forth_stackops.asm" 
1fb2			endif 
1fb2			 
1fb2			if FORTH_PARSEV5 
1fb2			include "forth_stackopsv5.asm" 
1fb2			 
1fb2			; Stack operations for v5 parser on wards 
1fb2			; * DATA stack 
1fb2			; * LOOP stack 
1fb2			; * RETURN stack 
1fb2			 
1fb2			 
1fb2			 
1fb2			FORTH_CHK_DSP_UNDER: macro 
1fb2				push hl 
1fb2				push de 
1fb2				ld hl,(cli_data_sp) 
1fb2				ld de, cli_data_stack 
1fb2				call cmp16 
1fb2				jp c, fault_dsp_under 
1fb2				pop de 
1fb2				pop hl 
1fb2				endm 
1fb2			 
1fb2			 
1fb2			FORTH_CHK_RSP_UNDER: macro 
1fb2				push hl 
1fb2				push de 
1fb2				ld hl,(cli_ret_sp) 
1fb2				ld de, cli_ret_stack 
1fb2				call cmp16 
1fb2				jp c, fault_rsp_under 
1fb2				pop de 
1fb2				pop hl 
1fb2				endm 
1fb2			 
1fb2			FORTH_CHK_LOOP_UNDER: macro 
1fb2				push hl 
1fb2				push de 
1fb2				ld hl,(cli_loop_sp) 
1fb2				ld de, cli_loop_stack 
1fb2				call cmp16 
1fb2				jp c, fault_loop_under 
1fb2				pop de 
1fb2				pop hl 
1fb2				endm 
1fb2			 
1fb2			FORTH_ERR_TOS_NOTSTR: macro 
1fb2				; TOSO might need more for checks when used 
1fb2				push af 
1fb2				ld a,(hl) 
1fb2				cp DS_TYPE_STR 
1fb2				jp nz, type_faultn   
1fb2				pop af 
1fb2				endm 
1fb2			 
1fb2			FORTH_ERR_TOS_NOTNUM: macro 
1fb2				push af 
1fb2				ld a,(hl) 
1fb2				cp DS_TYPE_INUM 
1fb2				jp nz, type_faultn   
1fb2				pop af 
1fb2				endm 
1fb2			 
1fb2			 
1fb2			; increase data stack pointer and save hl to it 
1fb2				 
1fb2			FORTH_DSP_NEXT: macro 
1fb2				call macro_forth_dsp_next 
1fb2				endm 
1fb2			 
1fb2			 
1fb2			macro_forth_dsp_next: 
1fb2				if DEBUG_FORTH_STACK_GUARD 
1fb2 cd 3d 6b				call check_stacks 
1fb5				endif 
1fb5 e5				push hl 
1fb6 d5				push de 
1fb7 eb				ex de,hl 
1fb8 2a 29 f9			ld hl,(cli_data_sp) 
1fbb 23				inc hl 
1fbc 23				inc hl 
1fbd			 
1fbd			; PARSEV5 
1fbd 23				inc hl 
1fbe 22 29 f9			ld (cli_data_sp),hl 
1fc1 73				ld (hl), e 
1fc2 23				inc hl 
1fc3 72				ld (hl), d 
1fc4 d1				pop de 
1fc5 e1				pop hl 
1fc6				if DEBUG_FORTH_STACK_GUARD 
1fc6 cd 3d 6b				call check_stacks 
1fc9				endif 
1fc9 c9				ret 
1fca			 
1fca			 
1fca			; increase ret stack pointer and save hl to it 
1fca				 
1fca			FORTH_RSP_NEXT: macro 
1fca				call macro_forth_rsp_next 
1fca				endm 
1fca			 
1fca			macro_forth_rsp_next: 
1fca				if DEBUG_FORTH_STACK_GUARD 
1fca cd 3d 6b				call check_stacks 
1fcd				endif 
1fcd e5				push hl 
1fce d5				push de 
1fcf eb				ex de,hl 
1fd0 2a 2d f9			ld hl,(cli_ret_sp) 
1fd3 23				inc hl 
1fd4 23				inc hl 
1fd5 22 2d f9			ld (cli_ret_sp),hl 
1fd8 73				ld (hl), e 
1fd9 23				inc hl 
1fda 72				ld (hl), d 
1fdb d1				pop de 
1fdc e1				pop hl 
1fdd				if DEBUG_FORTH_STACK_GUARD 
1fdd cd 3d 6b				call check_stacks 
1fe0				endif 
1fe0 c9				ret 
1fe1			 
1fe1			; get current ret stack pointer and save to hl  
1fe1				 
1fe1			FORTH_RSP_TOS: macro 
1fe1				call macro_forth_rsp_tos 
1fe1				endm 
1fe1			 
1fe1			macro_forth_rsp_tos: 
1fe1				;push de 
1fe1 2a 2d f9			ld hl,(cli_ret_sp) 
1fe4 cd 1c 20			call loadhlptrtohl 
1fe7				;ld e, (hl) 
1fe7				;inc hl 
1fe7				;ld d, (hl) 
1fe7				;ex de, hl 
1fe7					if DEBUG_FORTH_WORDS 
1fe7			;			DMARK "RST" 
1fe7						CALLMONITOR 
1fe7 cd aa fd			call debug_vector  
1fea				endm  
# End of macro CALLMONITOR
1fea					endif 
1fea				;pop de 
1fea c9				ret 
1feb			 
1feb			; pop ret stack pointer 
1feb				 
1feb			FORTH_RSP_POP: macro 
1feb				call macro_forth_rsp_pop 
1feb				endm 
1feb			 
1feb			 
1feb			macro_forth_rsp_pop: 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb			;		DMARK "RPP" 
1feb cd 3d 6b				call check_stacks 
1fee					FORTH_CHK_RSP_UNDER 
1fee e5				push hl 
1fef d5				push de 
1ff0 2a 2d f9			ld hl,(cli_ret_sp) 
1ff3 11 e7 f8			ld de, cli_ret_stack 
1ff6 cd ed 0f			call cmp16 
1ff9 da 51 6c			jp c, fault_rsp_under 
1ffc d1				pop de 
1ffd e1				pop hl 
1ffe				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ffe				endif 
1ffe e5				push hl 
1fff 2a 2d f9			ld hl,(cli_ret_sp) 
2002			 
2002			 
2002				if FORTH_ENABLE_FREE 
2002			 
2002					; get pointer 
2002			 
2002					push de 
2002					push hl 
2002			 
2002					ld e, (hl) 
2002					inc hl 
2002					ld d, (hl) 
2002			 
2002					ex de, hl 
2002					call free 
2002			 
2002					pop hl 
2002					pop de 
2002			 
2002			 
2002				endif 
2002			 
2002			 
2002 2b				dec hl 
2003 2b				dec hl 
2004 22 2d f9			ld (cli_ret_sp), hl 
2007				; do stack underflow checks 
2007 e1				pop hl 
2008				if DEBUG_FORTH_STACK_GUARD 
2008 cd 3d 6b				call check_stacks 
200b					FORTH_CHK_RSP_UNDER 
200b e5				push hl 
200c d5				push de 
200d 2a 2d f9			ld hl,(cli_ret_sp) 
2010 11 e7 f8			ld de, cli_ret_stack 
2013 cd ed 0f			call cmp16 
2016 da 51 6c			jp c, fault_rsp_under 
2019 d1				pop de 
201a e1				pop hl 
201b				endm 
# End of macro FORTH_CHK_RSP_UNDER
201b				endif 
201b c9				ret 
201c			 
201c			 
201c			 
201c			; routine to load word pointed to by hl into hl 
201c			 
201c			loadhlptrtohl: 
201c			 
201c d5				push de 
201d 5e				ld e, (hl) 
201e 23				inc hl 
201f 56				ld d, (hl) 
2020 eb				ex de, hl 
2021 d1				pop de 
2022			 
2022 c9				ret 
2023			 
2023			 
2023			 
2023			 
2023			 
2023			; push a number held in HL onto the data stack 
2023			; entry point for pushing a value when already in hl used in function above 
2023			 
2023			forth_push_numhl: 
2023			 
2023 e5				push hl    ; save value to push 
2024			 
2024			if DEBUG_FORTH_PUSH 
2024				; see if disabled 
2024			 
2024			 
2024 f5				push af 
2025 3a aa fd			ld a,(debug_vector) 
2028 fe c9			cp $c9   ; ret 
202a			;	ld a, (os_view_disable) 
202a			;	cp '*' 
202a 28 34			jr z, .pskip2 
202c e5				push hl 
202d e5			push hl 
202e cd 9b 0d			call clear_display 
2031 e1			pop hl 
2032 7c				ld a,h 
2033 21 01 f4			ld hl, os_word_scratch 
2036 cd d8 11			call hexout 
2039 e1				pop hl 
203a 7d				ld a,l 
203b 21 03 f4			ld hl, os_word_scratch+2 
203e cd d8 11			call hexout 
2041			 
2041 21 05 f4			ld hl, os_word_scratch+4 
2044 3e 00			ld a,0 
2046 77				ld (hl),a 
2047 11 01 f4			ld de,os_word_scratch 
204a 3e 28				ld a, display_row_2 
204c cd ae 0d				call str_at_display 
204f 11 4b 5d			ld de, .push_num 
2052 3e 00			ld a, display_row_1 
2054			 
2054 cd ae 0d				call str_at_display 
2057			 
2057			 
2057 cd be 0d			call update_display 
205a cd de 0c			call delay1s 
205d cd de 0c			call delay1s 
2060			.pskip2:  
2060			 
2060 f1				pop af 
2061			endif	 
2061			 
2061			 
2061				FORTH_DSP_NEXT 
2061 cd b2 1f			call macro_forth_dsp_next 
2064				endm 
# End of macro FORTH_DSP_NEXT
2064			 
2064 2a 29 f9			ld hl, (cli_data_sp) 
2067			 
2067				; save item type 
2067 3e 02			ld a,  DS_TYPE_INUM 
2069 77				ld (hl), a 
206a 23				inc hl 
206b			 
206b				; get word off stack 
206b d1				pop de 
206c 7b				ld a,e 
206d 77				ld (hl), a 
206e 23				inc hl 
206f 7a				ld a,d 
2070 77				ld (hl), a 
2071			 
2071			if DEBUG_FORTH_PUSH 
2071 2b				dec hl 
2072 2b				dec hl 
2073 2b				dec hl 
2074						DMARK "PH5" 
2074 f5				push af  
2075 3a 89 20			ld a, (.dmark)  
2078 32 a6 fd			ld (debug_mark),a  
207b 3a 8a 20			ld a, (.dmark+1)  
207e 32 a7 fd			ld (debug_mark+1),a  
2081 3a 8b 20			ld a, (.dmark+2)  
2084 32 a8 fd			ld (debug_mark+2),a  
2087 18 03			jr .pastdmark  
2089 ..			.dmark: db "PH5"  
208c f1			.pastdmark: pop af  
208d			endm  
# End of macro DMARK
208d				CALLMONITOR 
208d cd aa fd			call debug_vector  
2090				endm  
# End of macro CALLMONITOR
2090			endif	 
2090			 
2090 c9				ret 
2091			 
2091			 
2091			; Push a string to stack pointed to by hl 
2091			 
2091			forth_push_str: 
2091			 
2091			if DEBUG_FORTH_PUSH 
2091						DMARK "PSQ" 
2091 f5				push af  
2092 3a a6 20			ld a, (.dmark)  
2095 32 a6 fd			ld (debug_mark),a  
2098 3a a7 20			ld a, (.dmark+1)  
209b 32 a7 fd			ld (debug_mark+1),a  
209e 3a a8 20			ld a, (.dmark+2)  
20a1 32 a8 fd			ld (debug_mark+2),a  
20a4 18 03			jr .pastdmark  
20a6 ..			.dmark: db "PSQ"  
20a9 f1			.pastdmark: pop af  
20aa			endm  
# End of macro DMARK
20aa				CALLMONITOR 
20aa cd aa fd			call debug_vector  
20ad				endm  
# End of macro CALLMONITOR
20ad			endif	 
20ad			    
20ad e5				push hl 
20ae e5				push hl 
20af			 
20af			;	ld a, 0   ; find end of string 
20af cd 35 13			call strlenz 
20b2			if DEBUG_FORTH_PUSH 
20b2						DMARK "PQ2" 
20b2 f5				push af  
20b3 3a c7 20			ld a, (.dmark)  
20b6 32 a6 fd			ld (debug_mark),a  
20b9 3a c8 20			ld a, (.dmark+1)  
20bc 32 a7 fd			ld (debug_mark+1),a  
20bf 3a c9 20			ld a, (.dmark+2)  
20c2 32 a8 fd			ld (debug_mark+2),a  
20c5 18 03			jr .pastdmark  
20c7 ..			.dmark: db "PQ2"  
20ca f1			.pastdmark: pop af  
20cb			endm  
# End of macro DMARK
20cb				CALLMONITOR 
20cb cd aa fd			call debug_vector  
20ce				endm  
# End of macro CALLMONITOR
20ce			endif	 
20ce eb				ex de, hl 
20cf e1				pop hl   ; get ptr to start of string 
20d0			if DEBUG_FORTH_PUSH 
20d0						DMARK "PQ3" 
20d0 f5				push af  
20d1 3a e5 20			ld a, (.dmark)  
20d4 32 a6 fd			ld (debug_mark),a  
20d7 3a e6 20			ld a, (.dmark+1)  
20da 32 a7 fd			ld (debug_mark+1),a  
20dd 3a e7 20			ld a, (.dmark+2)  
20e0 32 a8 fd			ld (debug_mark+2),a  
20e3 18 03			jr .pastdmark  
20e5 ..			.dmark: db "PQ3"  
20e8 f1			.pastdmark: pop af  
20e9			endm  
# End of macro DMARK
20e9				CALLMONITOR 
20e9 cd aa fd			call debug_vector  
20ec				endm  
# End of macro CALLMONITOR
20ec			endif	 
20ec 19				add hl,de 
20ed			if DEBUG_FORTH_PUSH 
20ed						DMARK "PQE" 
20ed f5				push af  
20ee 3a 02 21			ld a, (.dmark)  
20f1 32 a6 fd			ld (debug_mark),a  
20f4 3a 03 21			ld a, (.dmark+1)  
20f7 32 a7 fd			ld (debug_mark+1),a  
20fa 3a 04 21			ld a, (.dmark+2)  
20fd 32 a8 fd			ld (debug_mark+2),a  
2100 18 03			jr .pastdmark  
2102 ..			.dmark: db "PQE"  
2105 f1			.pastdmark: pop af  
2106			endm  
# End of macro DMARK
2106				CALLMONITOR 
2106 cd aa fd			call debug_vector  
2109				endm  
# End of macro CALLMONITOR
2109			endif	 
2109			 
2109 2b				dec hl    ; see if there is an optional trailing double quote 
210a 7e				ld a,(hl) 
210b fe 22			cp '"' 
210d 20 03			jr nz, .strnoq 
210f 3e 00			ld a, 0      ; get rid of double quote 
2111 77				ld (hl), a 
2112 23			.strnoq: inc hl 
2113			 
2113 3e 00			ld a, 0 
2115 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2116			 
2116 13				inc de ; add one for the type string 
2117 13				inc de ; add one for null term??? 
2118			 
2118				; tos is get string pointer again 
2118				; de contains space to allocate 
2118				 
2118 d5				push de 
2119			 
2119 eb				ex de, hl 
211a			 
211a				;push af 
211a			 
211a			if DEBUG_FORTH_PUSH 
211a						DMARK "PHm" 
211a f5				push af  
211b 3a 2f 21			ld a, (.dmark)  
211e 32 a6 fd			ld (debug_mark),a  
2121 3a 30 21			ld a, (.dmark+1)  
2124 32 a7 fd			ld (debug_mark+1),a  
2127 3a 31 21			ld a, (.dmark+2)  
212a 32 a8 fd			ld (debug_mark+2),a  
212d 18 03			jr .pastdmark  
212f ..			.dmark: db "PHm"  
2132 f1			.pastdmark: pop af  
2133			endm  
# End of macro DMARK
2133				CALLMONITOR 
2133 cd aa fd			call debug_vector  
2136				endm  
# End of macro CALLMONITOR
2136			endif	 
2136 cd aa 13			call malloc	; on ret hl now contains allocated memory 
2139				if DEBUG_FORTH_MALLOC_GUARD 
2139 cc a3 5d				call z,malloc_error 
213c				endif 
213c			 
213c				 
213c c1				pop bc    ; get length 
213d d1				pop de   ;  get string start    
213e			 
213e				; hl has destination from malloc 
213e			 
213e eb				ex de, hl    ; prep for ldir 
213f			 
213f d5				push de   ; save malloc area for DSP later 
2140				;push hl   ; save malloc area for DSP later 
2140			 
2140			if DEBUG_FORTH_PUSH 
2140						DMARK "PHc" 
2140 f5				push af  
2141 3a 55 21			ld a, (.dmark)  
2144 32 a6 fd			ld (debug_mark),a  
2147 3a 56 21			ld a, (.dmark+1)  
214a 32 a7 fd			ld (debug_mark+1),a  
214d 3a 57 21			ld a, (.dmark+2)  
2150 32 a8 fd			ld (debug_mark+2),a  
2153 18 03			jr .pastdmark  
2155 ..			.dmark: db "PHc"  
2158 f1			.pastdmark: pop af  
2159			endm  
# End of macro DMARK
2159				CALLMONITOR 
2159 cd aa fd			call debug_vector  
215c				endm  
# End of macro CALLMONITOR
215c			endif	 
215c			 
215c			 
215c ed b0			ldir 
215e			 
215e			 
215e				; push malloc to data stack     macro?????  
215e			 
215e				FORTH_DSP_NEXT 
215e cd b2 1f			call macro_forth_dsp_next 
2161				endm 
# End of macro FORTH_DSP_NEXT
2161			 
2161				; save value and type 
2161			 
2161 2a 29 f9			ld hl, (cli_data_sp) 
2164			 
2164				; save item type 
2164 3e 01			ld a,  DS_TYPE_STR 
2166 77				ld (hl), a 
2167 23				inc hl 
2168			 
2168				; get malloc word off stack 
2168 d1				pop de 
2169 73				ld (hl), e 
216a 23				inc hl 
216b 72				ld (hl), d 
216c			 
216c			 
216c			 
216c			if DEBUG_FORTH_PUSH 
216c 2a 29 f9			ld hl, (cli_data_sp) 
216f						DMARK "PHS" 
216f f5				push af  
2170 3a 84 21			ld a, (.dmark)  
2173 32 a6 fd			ld (debug_mark),a  
2176 3a 85 21			ld a, (.dmark+1)  
2179 32 a7 fd			ld (debug_mark+1),a  
217c 3a 86 21			ld a, (.dmark+2)  
217f 32 a8 fd			ld (debug_mark+2),a  
2182 18 03			jr .pastdmark  
2184 ..			.dmark: db "PHS"  
2187 f1			.pastdmark: pop af  
2188			endm  
# End of macro DMARK
2188				CALLMONITOR 
2188 cd aa fd			call debug_vector  
218b				endm  
# End of macro CALLMONITOR
218b			;	ex de,hl 
218b			endif	 
218b				; in case of spaces, skip the ptr past the copied string 
218b				;pop af 
218b				;ld (cli_origptr),hl 
218b			 
218b c9				ret 
218c			 
218c			 
218c			 
218c			; TODO ascii push input onto stack given hl to start of input 
218c			 
218c			; identify type 
218c			; if starts with a " then a string 
218c			; otherwise it is a number 
218c			;  
218c			; if a string 
218c			;     scan for ending " to get length of string to malloc for + 1 
218c			;     malloc 
218c			;     put pointer to string on stack first byte flags as string 
218c			; 
218c			; else a number 
218c			;    look for number format identifier 
218c			;    $xx hex 
218c			;    %xxxxx bin 
218c			;    xxxxx decimal 
218c			;    convert number to 16bit word.  
218c			;    malloc word + 1 with flag to identiy as num 
218c			;    put pointer to number on stack 
218c			;   
218c			;  
218c			  
218c			forth_apush: 
218c				; kernel push 
218c			 
218c			if DEBUG_FORTH_PUSH 
218c						DMARK "PSH" 
218c f5				push af  
218d 3a a1 21			ld a, (.dmark)  
2190 32 a6 fd			ld (debug_mark),a  
2193 3a a2 21			ld a, (.dmark+1)  
2196 32 a7 fd			ld (debug_mark+1),a  
2199 3a a3 21			ld a, (.dmark+2)  
219c 32 a8 fd			ld (debug_mark+2),a  
219f 18 03			jr .pastdmark  
21a1 ..			.dmark: db "PSH"  
21a4 f1			.pastdmark: pop af  
21a5			endm  
# End of macro DMARK
21a5				CALLMONITOR 
21a5 cd aa fd			call debug_vector  
21a8				endm  
# End of macro CALLMONITOR
21a8			endif	 
21a8				; identify input type 
21a8			 
21a8 7e				ld a,(hl) 
21a9 fe 22			cp '"' 
21ab 28 0a			jr z, .fapstr 
21ad fe 24			cp '$' 
21af ca d7 21			jp z, .faphex 
21b2 fe 25			cp '%' 
21b4 ca bf 21			jp z, .fapbin 
21b7			;	cp 'b' 
21b7			;	jp z, .fabin 
21b7				; else decimal 
21b7			 
21b7				; TODO do decimal conversion 
21b7				; decimal is stored as a 16bit word 
21b7			 
21b7				; by default everything is a string if type is not detected 
21b7			.fapstr: ; 
21b7 fe 22			cp '"' 
21b9 20 01			jr nz, .strnoqu 
21bb 23				inc hl 
21bc			.strnoqu: 
21bc c3 91 20			jp forth_push_str 
21bf			 
21bf			 
21bf			 
21bf			.fapbin:    ; push a binary string.  
21bf 11 00 00			ld de, 0   ; hold a 16bit value 
21c2			 
21c2 23			.fapbinshift:	inc hl  
21c3 7e				ld a,(hl) 
21c4 fe 00			cp 0     ; done scanning  
21c6 28 0b			jr z, .fapbdone  	; got it in HL so push  
21c8			 
21c8				; left shift de 
21c8 eb				ex de, hl	 
21c9 29				add hl, hl 
21ca			 
21ca				; is 1 
21ca fe 31			cp '1' 
21cc 20 02			jr nz, .binzero 
21ce cb 4d			bit 1, l 
21d0			.binzero: 
21d0 eb				ex de, hl	 ; save current de 
21d1 18 ef			jr .fapbinshift 
21d3			 
21d3			.fapbdone: 
21d3 eb				ex de, hl 
21d4 c3 23 20			jp forth_push_numhl 
21d7			 
21d7			 
21d7			.faphex:   ; hex is always stored as a 16bit word 
21d7				; skip number prefix 
21d7 23				inc hl 
21d8				; turn ascii into number 
21d8 cd 8e 12			call get_word_hl	; ret 16bit word in hl 
21db			 
21db c3 23 20			jp forth_push_numhl 
21de			 
21de 00				 nop 
21df			 
21df			.fabin:   ; TODO bin conversion 
21df			 
21df			 
21df c9				ret 
21e0			 
21e0			 
21e0			; get either a string ptr or a 16bit word from the data stack 
21e0			 
21e0			FORTH_DSP: macro 
21e0				call macro_forth_dsp 
21e0				endm 
21e0			 
21e0			macro_forth_dsp: 
21e0				; data stack pointer points to current word on tos 
21e0			 
21e0 2a 29 f9			ld hl,(cli_data_sp) 
21e3			 
21e3				if DEBUG_FORTH_PUSH 
21e3						DMARK "DSP" 
21e3 f5				push af  
21e4 3a f8 21			ld a, (.dmark)  
21e7 32 a6 fd			ld (debug_mark),a  
21ea 3a f9 21			ld a, (.dmark+1)  
21ed 32 a7 fd			ld (debug_mark+1),a  
21f0 3a fa 21			ld a, (.dmark+2)  
21f3 32 a8 fd			ld (debug_mark+2),a  
21f6 18 03			jr .pastdmark  
21f8 ..			.dmark: db "DSP"  
21fb f1			.pastdmark: pop af  
21fc			endm  
# End of macro DMARK
21fc			 
21fc cd d6 5d				call display_data_sp 
21ff				;call break_point_state 
21ff				;rst 030h 
21ff				CALLMONITOR 
21ff cd aa fd			call debug_vector  
2202				endm  
# End of macro CALLMONITOR
2202				endif 
2202			 
2202 c9				ret 
2203			 
2203			; return hl to start of value on stack 
2203			 
2203			FORTH_DSP_VALUE: macro 
2203				call macro_forth_dsp_value 
2203				endm 
2203			 
2203			macro_forth_dsp_value: 
2203			 
2203				FORTH_DSP 
2203 cd e0 21			call macro_forth_dsp 
2206				endm 
# End of macro FORTH_DSP
2206			 
2206 d5				push de 
2207			 
2207 23				inc hl ; skip type 
2208			 
2208 5e				ld e, (hl) 
2209 23				inc hl 
220a 56				ld d, (hl) 
220b eb				ex de,hl  
220c			 
220c d1				pop de 
220d			 
220d c9				ret 
220e			 
220e			; return hl to start of value to second item on stack 
220e			 
220e			FORTH_DSP_VALUEM1: macro 
220e				call macro_forth_dsp_value_m1 
220e				endm 
220e			 
220e			macro_forth_dsp_value_m1: 
220e			 
220e				FORTH_DSP 
220e cd e0 21			call macro_forth_dsp 
2211				endm 
# End of macro FORTH_DSP
2211			 
2211 2b				dec hl 
2212 2b				dec hl 
2213			;	dec hl 
2213			 
2213 d5				push de 
2214			 
2214 5e				ld e, (hl) 
2215 23				inc hl 
2216 56				ld d, (hl) 
2217 eb				ex de,hl  
2218			 
2218 d1				pop de 
2219			 
2219 c9				ret 
221a			 
221a				 
221a			 
221a			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
221a			 
221a			FORTH_DSP_POP: macro 
221a				call macro_forth_dsp_pop 
221a				endm 
221a			 
221a			 
221a			; get the tos data type 
221a			 
221a			FORTH_DSP_TYPE:   macro 
221a			 
221a				;FORTH_DSP_VALUE 
221a				FORTH_DSP 
221a				 
221a				; hl points to value 
221a				; check type 
221a			 
221a				ld a,(hl) 
221a			 
221a				endm 
221a			 
221a			; load the tos value into hl 
221a			 
221a			 
221a			FORTH_DSP_VALUEHL:  macro 
221a				call macro_dsp_valuehl 
221a				endm 
221a			 
221a			 
221a			 
221a			macro_dsp_valuehl: 
221a				FORTH_DSP_VALUE 
221a cd 03 22			call macro_forth_dsp_value 
221d				endm 
# End of macro FORTH_DSP_VALUE
221d			 
221d				;FORTH_ERR_TOS_NOTNUM 
221d			 
221d				;inc hl   ; skip type id 
221d			 
221d			;	push de 
221d			; 
221d			;	ld e, (hl) 
221d			;	inc hl 
221d			;	ld d, (hl) 
221d			;	ex de,hl  
221d			 
221d			;	pop de 
221d			 
221d				if DEBUG_FORTH_PUSH 
221d						DMARK "DVL" 
221d f5				push af  
221e 3a 32 22			ld a, (.dmark)  
2221 32 a6 fd			ld (debug_mark),a  
2224 3a 33 22			ld a, (.dmark+1)  
2227 32 a7 fd			ld (debug_mark+1),a  
222a 3a 34 22			ld a, (.dmark+2)  
222d 32 a8 fd			ld (debug_mark+2),a  
2230 18 03			jr .pastdmark  
2232 ..			.dmark: db "DVL"  
2235 f1			.pastdmark: pop af  
2236			endm  
# End of macro DMARK
2236				CALLMONITOR 
2236 cd aa fd			call debug_vector  
2239				endm  
# End of macro CALLMONITOR
2239				endif 
2239 c9				ret 
223a			 
223a			forth_apushstrhl:      
223a				; push of string requires use of cli_origptr 
223a				; bodge use 
223a			 
223a				; get current cli_origptr, save, update with temp pointer  
223a ed 5b 79 f9		ld de, (cli_origptr) 
223e 22 79 f9			ld (cli_origptr), hl 
2241 d5				push de 
2242 cd 8c 21			call forth_apush 
2245 d1				pop de 
2246 ed 53 79 f9		ld (cli_origptr), de 
224a c9			        ret	 
224b			 
224b			 
224b			; increase loop stack pointer and save hl to it 
224b				 
224b			FORTH_LOOP_NEXT: macro 
224b				call macro_forth_loop_next 
224b				;nop 
224b				endm 
224b			 
224b			macro_forth_loop_next: 
224b				if DEBUG_FORTH_STACK_GUARD 
224b cd 3d 6b				call check_stacks 
224e				endif 
224e e5				push hl 
224f d5				push de 
2250 eb				ex de,hl 
2251 2a 2b f9			ld hl,(cli_loop_sp) 
2254 23				inc hl 
2255 23				inc hl 
2256					if DEBUG_FORTH_WORDS 
2256						DMARK "LNX" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 a6 fd			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 a7 fd			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 a8 fd			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db "LNX"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f						CALLMONITOR 
226f cd aa fd			call debug_vector  
2272				endm  
# End of macro CALLMONITOR
2272					endif 
2272 22 2b f9			ld (cli_loop_sp),hl 
2275 73				ld (hl), e 
2276 23				inc hl 
2277 72				ld (hl), d 
2278 d1				pop de    ; been reversed so save a swap on restore 
2279 e1				pop hl 
227a				if DEBUG_FORTH_STACK_GUARD 
227a cd 3d 6b				call check_stacks 
227d				endif 
227d c9				ret 
227e			 
227e			; get current ret stack pointer and save to hl  
227e				 
227e			FORTH_LOOP_TOS: macro 
227e				call macro_forth_loop_tos 
227e				endm 
227e			 
227e			macro_forth_loop_tos: 
227e d5				push de 
227f 2a 2b f9			ld hl,(cli_loop_sp) 
2282 5e				ld e, (hl) 
2283 23				inc hl 
2284 56				ld d, (hl) 
2285 eb				ex de, hl 
2286 d1				pop de 
2287 c9				ret 
2288			 
2288			; pop loop stack pointer 
2288				 
2288			FORTH_LOOP_POP: macro 
2288				call macro_forth_loop_pop 
2288				endm 
2288			 
2288			 
2288			macro_forth_loop_pop: 
2288				if DEBUG_FORTH_STACK_GUARD 
2288					DMARK "LPP" 
2288 f5				push af  
2289 3a 9d 22			ld a, (.dmark)  
228c 32 a6 fd			ld (debug_mark),a  
228f 3a 9e 22			ld a, (.dmark+1)  
2292 32 a7 fd			ld (debug_mark+1),a  
2295 3a 9f 22			ld a, (.dmark+2)  
2298 32 a8 fd			ld (debug_mark+2),a  
229b 18 03			jr .pastdmark  
229d ..			.dmark: db "LPP"  
22a0 f1			.pastdmark: pop af  
22a1			endm  
# End of macro DMARK
22a1 cd 3d 6b				call check_stacks 
22a4					FORTH_CHK_LOOP_UNDER 
22a4 e5				push hl 
22a5 d5				push de 
22a6 2a 2b f9			ld hl,(cli_loop_sp) 
22a9 11 65 f8			ld de, cli_loop_stack 
22ac cd ed 0f			call cmp16 
22af da 57 6c			jp c, fault_loop_under 
22b2 d1				pop de 
22b3 e1				pop hl 
22b4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22b4				endif 
22b4 e5				push hl 
22b5 2a 2b f9			ld hl,(cli_loop_sp) 
22b8 2b				dec hl 
22b9 2b				dec hl 
22ba 22 2b f9			ld (cli_loop_sp), hl 
22bd				; TODO do stack underflow checks 
22bd e1				pop hl 
22be				if DEBUG_FORTH_STACK_GUARD 
22be cd 3d 6b				call check_stacks 
22c1					FORTH_CHK_LOOP_UNDER 
22c1 e5				push hl 
22c2 d5				push de 
22c3 2a 2b f9			ld hl,(cli_loop_sp) 
22c6 11 65 f8			ld de, cli_loop_stack 
22c9 cd ed 0f			call cmp16 
22cc da 57 6c			jp c, fault_loop_under 
22cf d1				pop de 
22d0 e1				pop hl 
22d1				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22d1				endif 
22d1 c9				ret 
22d2			 
22d2			macro_forth_dsp_pop: 
22d2			 
22d2 e5				push hl 
22d3			 
22d3				; release malloc data 
22d3			 
22d3				if DEBUG_FORTH_STACK_GUARD 
22d3 cd 3d 6b				call check_stacks 
22d6					FORTH_CHK_DSP_UNDER 
22d6 e5				push hl 
22d7 d5				push de 
22d8 2a 29 f9			ld hl,(cli_data_sp) 
22db 11 63 f6			ld de, cli_data_stack 
22de cd ed 0f			call cmp16 
22e1 da 4b 6c			jp c, fault_dsp_under 
22e4 d1				pop de 
22e5 e1				pop hl 
22e6				endm 
# End of macro FORTH_CHK_DSP_UNDER
22e6				endif 
22e6				;ld hl,(cli_data_sp) 
22e6			if DEBUG_FORTH_DOT 
22e6				DMARK "DPP" 
22e6 f5				push af  
22e7 3a fb 22			ld a, (.dmark)  
22ea 32 a6 fd			ld (debug_mark),a  
22ed 3a fc 22			ld a, (.dmark+1)  
22f0 32 a7 fd			ld (debug_mark+1),a  
22f3 3a fd 22			ld a, (.dmark+2)  
22f6 32 a8 fd			ld (debug_mark+2),a  
22f9 18 03			jr .pastdmark  
22fb ..			.dmark: db "DPP"  
22fe f1			.pastdmark: pop af  
22ff			endm  
# End of macro DMARK
22ff				CALLMONITOR 
22ff cd aa fd			call debug_vector  
2302				endm  
# End of macro CALLMONITOR
2302			endif	 
2302			 
2302			 
2302			if FORTH_ENABLE_DSPPOPFREE 
2302			 
2302				FORTH_DSP 
2302 cd e0 21			call macro_forth_dsp 
2305				endm 
# End of macro FORTH_DSP
2305			 
2305 7e				ld a, (hl) 
2306 fe 01			cp DS_TYPE_STR 
2308 20 23			jr nz, .skippopfree 
230a			 
230a				FORTH_DSP_VALUEHL 
230a cd 1a 22			call macro_dsp_valuehl 
230d				endm 
# End of macro FORTH_DSP_VALUEHL
230d 00				nop 
230e			if DEBUG_FORTH_DOT 
230e				DMARK "DPf" 
230e f5				push af  
230f 3a 23 23			ld a, (.dmark)  
2312 32 a6 fd			ld (debug_mark),a  
2315 3a 24 23			ld a, (.dmark+1)  
2318 32 a7 fd			ld (debug_mark+1),a  
231b 3a 25 23			ld a, (.dmark+2)  
231e 32 a8 fd			ld (debug_mark+2),a  
2321 18 03			jr .pastdmark  
2323 ..			.dmark: db "DPf"  
2326 f1			.pastdmark: pop af  
2327			endm  
# End of macro DMARK
2327				CALLMONITOR 
2327 cd aa fd			call debug_vector  
232a				endm  
# End of macro CALLMONITOR
232a			endif	 
232a cd 74 14			call free 
232d			.skippopfree: 
232d				 
232d			 
232d			endif 
232d			 
232d			if DEBUG_FORTH_DOT_KEY 
232d				DMARK "DP2" 
232d				CALLMONITOR 
232d			endif	 
232d			 
232d				; move pointer down 
232d			 
232d 2a 29 f9			ld hl,(cli_data_sp) 
2330 2b				dec hl 
2331 2b				dec hl 
2332			; PARSEV5 
2332 2b				dec hl 
2333 22 29 f9			ld (cli_data_sp), hl 
2336			 
2336				if DEBUG_FORTH_STACK_GUARD 
2336 cd 3d 6b				call check_stacks 
2339					FORTH_CHK_DSP_UNDER 
2339 e5				push hl 
233a d5				push de 
233b 2a 29 f9			ld hl,(cli_data_sp) 
233e 11 63 f6			ld de, cli_data_stack 
2341 cd ed 0f			call cmp16 
2344 da 4b 6c			jp c, fault_dsp_under 
2347 d1				pop de 
2348 e1				pop hl 
2349				endm 
# End of macro FORTH_CHK_DSP_UNDER
2349				endif 
2349			 
2349 e1				pop hl 
234a			 
234a c9				ret 
234b			 
234b			getwordathl: 
234b				; hl points to an address 
234b				; load hl with the word at that address 
234b			 
234b d5				push de 
234c			 
234c 5e				ld e, (hl) 
234d 23				inc hl 
234e 56				ld d, (hl) 
234f eb				ex de, hl 
2350			 
2350 d1				pop de 
2351 c9				ret 
2352			 
2352			 
2352			 
2352			 
2352			 
2352			; eof 
2352			 
# End of file forth_stackopsv5.asm
2352			endif 
2352			 
2352			loadwordinhl:	 
2352			 
2352 d5				push de 
2353			 
2353 5e				ld e, (hl) 
2354 23				inc hl 
2355 56				ld d, (hl) 
2356 eb				ex de,hl  
2357			 
2357 d1				pop de 
2358			 
2358 c9				ret 
2359			 
2359			user_word_eol:  
2359				; hl contains the pointer to where to create a linked list item from the end 
2359				; of the user dict to continue on at the system word dict 
2359				 
2359				; poke the stub of the word list linked list to repoint to rom words 
2359			 
2359				; stub format 
2359				; db   word id 
2359				; dw    link to next word 
2359			        ; db char length of token 
2359				; db string + 0 term 
2359				; db exec code....  
2359			 
2359 3e 00			ld a, WORD_SYS_ROOT     ; root word 
235b 77				ld (hl), a		; word id 
235c 23				inc hl 
235d			 
235d 11 28 25			ld de, sysdict 
2360 73				ld (hl), e		; next word link ie system dict 
2361 23				inc hl 
2362 72				ld (hl), d		; next word link ie system dict 
2363 23				inc hl	 
2364			 
2364			;	ld (hl), sysdict		; next word link ie system dict 
2364			;	inc hl 
2364			;	inc hl 
2364			 
2364			;	inc hl 
2364			;	inc hl 
2364			 
2364 3e 02			ld a, 2			; word length is 0 
2366 77				ld (hl), a	 
2367 23				inc hl 
2368			 
2368 3e 7e			ld a, '~'			; word length is 0 
236a 77				ld (hl), a	 
236b 23				inc hl 
236c 3e 00			ld a, 0			; save empty word 
236e 77				ld (hl), a 
236f			 
236f c9				ret 
2370			 
2370				 
2370			 
2370			forthexec_cleanup: 
2370				FORTH_RSP_POP 
2370 cd eb 1f			call macro_forth_rsp_pop 
2373				endm 
# End of macro FORTH_RSP_POP
2373 c9				ret 
2374			 
2374			forth_call_hl: 
2374				; taking hl 
2374 e5				push hl 
2375 c9				ret 
2376			 
2376			; this is called to reset Forth system but keep existing uwords etc 
2376			 
2376			forth_warmstart: 
2376				; setup stack over/under flow checks 
2376				if DEBUG_FORTH_STACK_GUARD 
2376 cd 23 6b				call chk_stk_init 
2379				endif 
2379			 
2379				; init stack pointers  - * these stacks go upwards *  
2379 21 e7 f8			ld hl, cli_ret_stack 
237c 22 2d f9			ld (cli_ret_sp), hl	 
237f				; set bottom of stack 
237f 3e 00			ld a,0 
2381 77				ld (hl),a 
2382 23				inc hl 
2383 77				ld (hl),a 
2384			 
2384 21 63 f6			ld hl, cli_data_stack 
2387 22 29 f9			ld (cli_data_sp), hl	 
238a				; set bottom of stack 
238a 3e 00			ld a,0 
238c 77				ld (hl),a 
238d 23				inc hl 
238e 77				ld (hl),a 
238f			 
238f 21 65 f8			ld hl, cli_loop_stack 
2392 22 2b f9			ld (cli_loop_sp), hl	 
2395				; set bottom of stack 
2395 3e 00			ld a,0 
2397 77				ld (hl),a 
2398 23				inc hl 
2399 77				ld (hl),a 
239a			 
239a				; init extent of current open file 
239a			 
239a 3e 00			ld a, 0 
239c 32 a5 f9			ld (store_openext), a 
239f			 
239f c9				ret 
23a0			 
23a0			 
23a0			 
23a0			; Cold Start - this is called to setup the whole Forth system 
23a0			 
23a0			forth_init: 
23a0			 
23a0				; setup stack over/under flow checks 
23a0			 
23a0			;	if DEBUG_FORTH_STACK_GUARD 
23a0			;		call chk_stk_init 
23a0			;	endif 
23a0			 
23a0				; enable auto display updates (slow.....) 
23a0			 
23a0 3e 01			ld a, 1 
23a2 32 77 f9			ld (cli_autodisplay), a 
23a5			 
23a5				; if storage is in use disable long reads for now 
23a5 3e 00			ld a, 0 
23a7 32 b0 f9			ld (store_longread), a 
23aa			 
23aa			 
23aa				; show start up screen 
23aa			 
23aa cd 9b 0d			call clear_display 
23ad			 
23ad 3e 00			ld a,0 
23af 32 99 f9			ld (f_cursor_ptr), a 
23b2			 
23b2				; set start of word list in start of ram - for use when creating user words 
23b2			 
23b2 21 00 80			ld hl, baseram 
23b5 22 f9 f3			ld (os_last_new_uword), hl 
23b8 cd 59 23			call user_word_eol 
23bb				 
23bb			;		call display_data_sp 
23bb			;		call next_page_prompt 
23bb			 
23bb			 
23bb			 
23bb			 
23bb c9				ret 
23bc			 
23bc .. 00		.bootforth: db " Forth Kernel Init ",0 
23d0			 
23d0			; TODO push to stack 
23d0			 
23d0			;  
23d0			 
23d0			if FORTH_PARSEV2 
23d0			 
23d0			 
23d0				include "forth_parserv2.asm" 
23d0			 
23d0			endif 
23d0			 
23d0			 
23d0			; parse cli version 1 
23d0			 
23d0			if FORTH_PARSEV1 
23d0			 
23d0			 
23d0			 
23d0			      include "forth_parserv1.asm" 
23d0			endif 
23d0				 
23d0			if FORTH_PARSEV3 
23d0			 
23d0			 
23d0			 
23d0			      include "forth_parserv3.asm" 
23d0				include "forth_wordsv3.asm" 
23d0			endif 
23d0			 
23d0			if FORTH_PARSEV4 
23d0			 
23d0			 
23d0			 
23d0			      include "forth_parserv4.asm" 
23d0				include "forth_wordsv4.asm" 
23d0			endif 
23d0			 
23d0			if FORTH_PARSEV5 
23d0			 
23d0			 
23d0			 
23d0			      include "forth_parserv5.asm" 
23d0			 
23d0			 
23d0			; A better parser without using malloc and string copies all over the place.  
23d0			; Exec in situ should be faster 
23d0			 
23d0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23d0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23d0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23d0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23d0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23d0			WORD_SYS_END: equ 0   ; Opcode for all user words 
23d0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23d0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23d0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23d0			 
23d0			; Core word preamble macro 
23d0			 
23d0			CWHEAD:   macro nxtword opcode lit len opflags 
23d0				db WORD_SYS_CORE+opcode             
23d0				; internal op code number 
23d0				dw nxtword            
23d0				; link to next dict word block 
23d0				db len + 1 
23d0				; literal length of dict word inc zero term 
23d0				db lit,0              
23d0				; literal dict word 
23d0			        ; TODO db opflags        
23d0				endm 
23d0			 
23d0			 
23d0			NEXTW: macro  
23d0				jp macro_next 
23d0				endm 
23d0			 
23d0			macro_next: 
23d0			if DEBUG_FORTH_PARSE_KEY 
23d0				DMARK "NXT" 
23d0				CALLMONITOR 
23d0			endif	 
23d0			;	inc hl  ; skip token null term  
23d0 ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23d4 ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23d8 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23db			if DEBUG_FORTH_PARSE_KEY 
23db				DMARK "}AA" 
23db				CALLMONITOR 
23db			endif	 
23db c3 de 24			jp execnext 
23de				;jp exec1 
23de			       
23de			 
23de			 
23de			; Another go at the parser to compile  
23de			 
23de			 
23de			; TODO rework parser to change all of the string words to byte tokens 
23de			; TODO do a search for  
23de			 
23de			; TODO first run normal parser to zero term sections 
23de			; TODO for each word do a token look up to get the op code 
23de			; TODO need some means to flag to the exec that this is a byte code form    
23de			 
23de			 
23de			forthcompile: 
23de			 
23de			; 
23de			; line parse: 
23de			;       parse raw input buffer 
23de			;       tokenise the words 
23de			;       malloc new copy (for looping etc) 
23de			;       copy to malloc + current pc in line to start of string and add line term 
23de			;       save on new rsp 
23de			; 
23de			 
23de			; hl to point to the line to tokenise 
23de			 
23de			;	push hl 
23de 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
23e1			 
23e1			;	ld a,0		; string term on input 
23e1			;	call strlent 
23e1			 
23e1			;	ld (os_tok_len), hl	 ; save string length 
23e1			 
23e1			;if DEBUG_FORTH_TOK 
23e1			;	ex de,hl		 
23e1			;endif 
23e1			 
23e1			;	pop hl 		; get back string pointer 
23e1			 
23e1			if DEBUG_FORTH_TOK 
23e1						DMARK "TOc" 
23e1				CALLMONITOR 
23e1			endif 
23e1 7e			.cptoken2:    ld a,(hl) 
23e2 23				inc hl 
23e3 fe 7f			cp FORTH_END_BUFFER 
23e5 28 29			jr z, .cptokendone2 
23e7 fe 00			cp 0 
23e9 28 25			jr z, .cptokendone2 
23eb fe 22			cp '"' 
23ed 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
23ef fe 20			cp ' ' 
23f1 20 ee			jr nz,  .cptoken2 
23f3			 
23f3			; TODO consume comments held between ( and ) 
23f3			 
23f3				; we have a space so change to zero term for dict match later 
23f3 2b				dec hl 
23f4 3e 00			ld a,0 
23f6 77				ld (hl), a 
23f7 23				inc hl 
23f8 18 e7			jr .cptoken2 
23fa				 
23fa			 
23fa			.cptokenstr2: 
23fa				; skip all white space until either eol (because forgot to term) or end double quote 
23fa			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
23fa				;inc hl ; skip current double quote 
23fa 7e				ld a,(hl) 
23fb 23				inc hl 
23fc fe 22			cp '"' 
23fe 28 e1			jr z, .cptoken2 
2400 fe 7f			cp FORTH_END_BUFFER 
2402 28 0c			jr z, .cptokendone2 
2404 fe 00			cp 0 
2406 28 08			jr z, .cptokendone2 
2408 fe 20			cp ' ' 
240a 28 02			jr z, .cptmp2 
240c 18 ec			jr .cptokenstr2 
240e			 
240e			.cptmp2:	; we have a space so change to zero term for dict match later 
240e				;dec hl 
240e				;ld a,"-"	; TODO remove this when working 
240e				;ld (hl), a 
240e				;inc hl 
240e 18 ea			jr .cptokenstr2 
2410			 
2410			.cptokendone2: 
2410				;inc hl 
2410 3e 7f			ld a, FORTH_END_BUFFER 
2412 77				ld (hl),a 
2413 23				inc hl 
2414 3e 21			ld a, '!' 
2416 77				ld (hl),a 
2417			 
2417 2a fd f3			ld hl,(os_tok_ptr) 
241a			         
241a			if DEBUG_FORTH_TOK 
241a						DMARK "Tc1" 
241a				CALLMONITOR 
241a			endif 
241a			 
241a				; push exec string to top of return stack 
241a				FORTH_RSP_NEXT 
241a cd ca 1f			call macro_forth_rsp_next 
241d				endm 
# End of macro FORTH_RSP_NEXT
241d c9				ret 
241e			 
241e			; Another go at the parser need to simplify the process 
241e			 
241e			forthparse: 
241e			 
241e			; 
241e			; line parse: 
241e			;       parse raw input buffer 
241e			;       tokenise the words 
241e			;       malloc new copy (for looping etc) 
241e			;       copy to malloc + current pc in line to start of string and add line term 
241e			;       save on new rsp 
241e			; 
241e			 
241e			; hl to point to the line to tokenise 
241e			 
241e			;	push hl 
241e 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
2421			 
2421			;	ld a,0		; string term on input 
2421			;	call strlent 
2421			 
2421			;	ld (os_tok_len), hl	 ; save string length 
2421			 
2421			;if DEBUG_FORTH_TOK 
2421			;	ex de,hl		 
2421			;endif 
2421			 
2421			;	pop hl 		; get back string pointer 
2421			 
2421			if DEBUG_FORTH_TOK 
2421						DMARK "TOK" 
2421				CALLMONITOR 
2421			endif 
2421 7e			.ptoken2:    ld a,(hl) 
2422 23				inc hl 
2423 fe 7f			cp FORTH_END_BUFFER 
2425 28 29			jr z, .ptokendone2 
2427 fe 00			cp 0 
2429 28 25			jr z, .ptokendone2 
242b fe 22			cp '"' 
242d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
242f fe 20			cp ' ' 
2431 20 ee			jr nz,  .ptoken2 
2433			 
2433			; TODO consume comments held between ( and ) 
2433			 
2433				; we have a space so change to zero term for dict match later 
2433 2b				dec hl 
2434 3e 00			ld a,0 
2436 77				ld (hl), a 
2437 23				inc hl 
2438 18 e7			jr .ptoken2 
243a				 
243a			 
243a			.ptokenstr2: 
243a				; skip all white space until either eol (because forgot to term) or end double quote 
243a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
243a				;inc hl ; skip current double quote 
243a 7e				ld a,(hl) 
243b 23				inc hl 
243c fe 22			cp '"' 
243e 28 e1			jr z, .ptoken2 
2440 fe 7f			cp FORTH_END_BUFFER 
2442 28 0c			jr z, .ptokendone2 
2444 fe 00			cp 0 
2446 28 08			jr z, .ptokendone2 
2448 fe 20			cp ' ' 
244a 28 02			jr z, .ptmp2 
244c 18 ec			jr .ptokenstr2 
244e			 
244e			.ptmp2:	; we have a space so change to zero term for dict match later 
244e				;dec hl 
244e				;ld a,"-"	; TODO remove this when working 
244e				;ld (hl), a 
244e				;inc hl 
244e 18 ea			jr .ptokenstr2 
2450			 
2450			.ptokendone2: 
2450				;inc hl 
2450 3e 7f			ld a, FORTH_END_BUFFER 
2452 77				ld (hl),a 
2453 23				inc hl 
2454 3e 21			ld a, '!' 
2456 77				ld (hl),a 
2457			 
2457 2a fd f3			ld hl,(os_tok_ptr) 
245a			         
245a			if DEBUG_FORTH_TOK 
245a						DMARK "TK1" 
245a				CALLMONITOR 
245a			endif 
245a			 
245a				; push exec string to top of return stack 
245a				FORTH_RSP_NEXT 
245a cd ca 1f			call macro_forth_rsp_next 
245d				endm 
# End of macro FORTH_RSP_NEXT
245d c9				ret 
245e			 
245e			; 
245e			;	; malloc size + buffer pointer + if is loop flag 
245e			;	ld hl,(os_tok_len) 		 ; get string length 
245e			; 
245e			;	ld a,l 
245e			; 
245e			;	cp 0			; we dont want to use a null string 
245e			;	ret z 
245e			; 
245e			;;	add 3    ; prefix malloc with buffer for current word ptr 
245e			; 
245e			;	add 5     ; TODO when certain not over writing memory remove 
245e			; 
245e			;		 
245e			; 
245e			;if DEBUG_FORTH_TOK 
245e			;			DMARK "TKE" 
245e			;	CALLMONITOR 
245e			;endif 
245e			; 
245e			;	ld l,a 
245e			;	ld h,0 
245e			;;	push hl   ; save required space for the copy later 
245e			;	call malloc 
245e			;if DEBUG_FORTH_TOK 
245e			;			DMARK "TKM" 
245e			;	CALLMONITOR 
245e			;endif 
245e			;	if DEBUG_FORTH_MALLOC_GUARD 
245e			;		push af 
245e			;		call ishlzero 
245e			;;		ld a, l 
245e			;;		add h 
245e			;;		cp 0 
245e			;		pop af 
245e			;		 
245e			;		call z,malloc_error 
245e			;	endif 
245e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
245e			; 
245e			; 
245e			;if DEBUG_FORTH_TOK 
245e			;			DMARK "TKR" 
245e			;	CALLMONITOR 
245e			;endif 
245e			; 
245e			;	FORTH_RSP_NEXT 
245e			; 
245e			;	;inc hl	 ; go past current buffer pointer 
245e			;	;inc hl 
245e			;	;inc hl   ; and past if loop flag 
245e			;		; TODO Need to set flag  
245e			; 
245e			;	 
245e			;	 
245e			;	ex de,hl	; malloc is dest 
245e			;	ld hl, (os_tok_len) 
245e			;;	pop bc 
245e			;	ld c, l                
245e			;	ld b,0 
245e			;	ld hl, (os_tok_ptr) 
245e			; 
245e			;if DEBUG_FORTH_TOK 
245e			;			DMARK "TKT" 
245e			;	CALLMONITOR 
245e			;endif 
245e			; 
245e			;	; do str cpy 
245e			; 
245e			;	ldir      ; copy byte in hl to de 
245e			; 
245e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
245e			; 
245e			;if DEBUG_FORTH_TOK 
245e			; 
245e			;			DMARK "TKY" 
245e			;	CALLMONITOR 
245e			;endif 
245e			;	;ld a,0 
245e			;	;ld a,FORTH_END_BUFFER 
245e			;	ex de, hl 
245e			;	;dec hl			 ; go back over the space delim at the end of word 
245e			;	;ld (hl),a 
245e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
245e			;	ld a,FORTH_END_BUFFER 
245e			;	ld (hl),a 
245e			;	inc hl 
245e			;	ld a,FORTH_END_BUFFER 
245e			;	ld (hl),a 
245e			; 
245e			;	; init the malloc area data 
245e			;	; set pc for in current area 
245e			;	;ld hl, (os_tok_malloc) 
245e			;	;inc hl 
245e			;	;inc hl 
245e			;	;inc hl 
245e			;	;ex de,hl 
245e			;	;ld hl, (os_tok_malloc) 
245e			;	;ld (hl),e 
245e			;	;inc hl 
245e			;	;ld (hl),d 
245e			; 
245e			; 
245e			;	ld hl,(os_tok_malloc) 
245e			;if DEBUG_FORTH_PARSE_KEY 
245e			;			DMARK "TKU" 
245e			;	CALLMONITOR 
245e			;endif 
245e			; 
245e			;	ret 
245e			 
245e			forthexec: 
245e			 
245e			; line exec: 
245e			; forth parser 
245e			 
245e			; 
245e			;       get current exec line on rsp 
245e			 
245e				FORTH_RSP_TOS 
245e cd e1 1f			call macro_forth_rsp_tos 
2461				endm 
# End of macro FORTH_RSP_TOS
2461			 
2461			;       restore current pc - hl points to malloc of data 
2461			 
2461				;ld e, (hl) 
2461				;inc hl 
2461				;ld d, (hl) 
2461				;ex de,hl 
2461			 
2461			 
2461			exec1: 
2461 22 fd f3			ld (os_tok_ptr), hl 
2464			 
2464				; copy our PC to working vars  
2464 22 7b f9			ld (cli_ptr), hl 
2467 22 79 f9			ld (cli_origptr), hl 
246a			 
246a 7e				ld a,(hl) 
246b fe 7f			cp FORTH_END_BUFFER 
246d c8				ret z 
246e			 
246e				; skip any nulls 
246e			 
246e fe 00			cp 0 
2470 20 03			jr nz, .execword 
2472 23				inc hl 
2473 18 ec			jr exec1 
2475			 
2475			 
2475			.execword: 
2475			 
2475			 
2475			 
2475			if DEBUG_FORTH_PARSE_KEY 
2475						DMARK "KYQ" 
2475				CALLMONITOR 
2475			endif 
2475			;       while at start of word: 
2475			; get start of dict (in user area first) 
2475			 
2475 21 00 80		ld hl, baseram 
2478			;ld hl, sysdict 
2478 22 7d f9		ld (cli_nextword),hl 
247b			;           match word at pc 
247b			;           exec word 
247b			;           or push to dsp 
247b			;           forward to next token 
247b			;           if line term pop rsp and exit 
247b			;        
247b			 
247b			if DEBUG_FORTH_PARSE_KEY 
247b						DMARK "KYq" 
247b				CALLMONITOR 
247b			endif 
247b			 
247b			; 
247b			; word comp 
247b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
247b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
247b			;    move to start of word  
247b			;    compare word to cli_token 
247b			 
247b			.execpnword:	; HL at start of a word in the dictionary to check 
247b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
247b			;	ld (cli_ptr), hl 
247b			 
247b 2a 7d f9			ld hl,(cli_nextword) 
247e			 
247e cd 21 25			call forth_tok_next 
2481			; tok next start here 
2481			;	; TODO skip compiled symbol for now 
2481			;	inc hl 
2481			; 
2481			;	; save pointer to next word 
2481			; 
2481			;	; hl now points to the address of the next word pointer  
2481			;	ld e, (hl) 
2481			;	inc hl 
2481			;	ld d, (hl) 
2481			;	inc l 
2481			; 
2481			;	ex de,hl 
2481			;if DEBUG_FORTH_PARSE_NEXTWORD 
2481			;	push bc 
2481			;	ld bc, (cli_nextword) 
2481			;			DMARK "NXW" 
2481			;	CALLMONITOR 
2481			;	pop bc 
2481			;endif 
2481			; tok next end here 
2481 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2484 eb				ex de, hl 
2485			 
2485			 
2485				; save the pointer of the current token - 1 to check against 
2485				 
2485 22 81 f9			ld (cli_token), hl   
2488				; TODO maybe remove below save if no debug 
2488				; save token string ptr for any debug later 
2488 23				inc hl  
2489 22 83 f9			ld (cli_origtoken), hl 
248c 2b				dec hl 
248d				; save pointer to the start of the next dictionay word 
248d 7e				ld a,(hl)   ; get string length 
248e 47				ld b,a 
248f			.execpnwordinc:  
248f 23				inc hl 
2490 10 fd			djnz .execpnwordinc 
2492 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
2495			 
2495				; now check the word token against the string being parsed 
2495			 
2495 2a 81 f9			ld hl,(cli_token) 
2498 23				inc hl     ; skip string length (use zero term instead to end) 
2499 22 81 f9			ld (cli_token), hl 
249c			 
249c			if DEBUG_FORTH_PARSE_KEY 
249c						DMARK "KY2" 
249c			endif 
249c			if DEBUG_FORTH_PARSE_EXEC 
249c				; see if disabled 
249c			 
249c			;	ld a, (os_view_disable) 
249c			;	cp '*' 
249c				ld a, (debug_vector) 
249c				cp $c9   ; RET  
249c				jr z, .skip 
249c			 
249c				push hl 
249c				push hl 
249c				call clear_display 
249c				ld de, .compword 
249c				ld a, display_row_1 
249c				call str_at_display 
249c				pop de 
249c				ld a, display_row_2 
249c				call str_at_display 
249c				ld hl,(cli_ptr) 
249c				ld a,(hl) 
249c			        ld hl, os_word_scratch 
249c				ld (hl),a 
249c				ld a,0 
249c				inc hl 
249c				ld (hl),a 	 
249c				ld de, os_word_scratch 
249c				ld a, display_row_2+10 
249c				call str_at_display 
249c				call update_display 
249c				ld a, 100 
249c				call aDelayInMS 
249c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
249c				call delay250ms 
249c				endif 
249c				pop hl 
249c			.skip:  
249c			endif	 
249c			.execpnchar:    ; compare char between token and string to parse 
249c			 
249c			if DEBUG_FORTH_PARSE_KEY 
249c						DMARK "Ky3" 
249c			endif 
249c			if DEBUG_FORTH_PARSE_EXEC 
249c				; see if disabled 
249c			 
249c			;	ld a, (os_view_disable) 
249c			;	cp '*' 
249c				ld a, (debug_vector) 
249c				cp $C9  ; RET 
249c				jr z, .skip2 
249c			 
249c			;	call clear_display 
249c			ld hl,(cli_token) 
249c			ld a,(hl) 
249c			ld (os_word_scratch),a 
249c				ld hl,(cli_ptr) 
249c			ld a,(hl) 
249c				ld (os_word_scratch+1),a 
249c				ld a,0 
249c				ld (os_word_scratch+2),a 
249c				ld de,os_word_scratch 
249c				ld a,display_row_4 
249c				call str_at_display 
249c				call update_display 
249c			.skip2:  
249c			endif 
249c 2a 81 f9			ld hl,(cli_token) 
249f 7e				ld a, (hl)	 ; char in word token 
24a0 23				inc hl 		; move to next char 
24a1 22 81 f9			ld (cli_token), hl ; and save it 
24a4 47				ld b,a 
24a5			 
24a5 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
24a8 7e				ld a,(hl) 
24a9 23				inc hl 
24aa 22 7b f9			ld (cli_ptr), hl		; move to next char 
24ad cd 2c 13			call toUpper 		; make sure the input string matches case 
24b0			 
24b0			if DEBUG_FORTH_PARSE 
24b0			endif 
24b0			 
24b0				; input stream end of token is a space so get rid of it 
24b0			 
24b0			;	cp ' ' 
24b0			;	jr nz, .pnskipspace 
24b0			; 
24b0			;	ld a, 0		; make same term as word token term 
24b0			; 
24b0			;.pnskipspace: 
24b0			 
24b0			if DEBUG_FORTH_PARSE_KEY 
24b0						DMARK "KY7" 
24b0			endif 
24b0 b8				cp b 
24b1 c2 c7 24			jp nz, .execpnskipword	 ; no match so move to next word 
24b4				 
24b4			;    if same 
24b4			;       scan for string terms 0 for token and 32 for input 
24b4			 
24b4				 
24b4			if DEBUG_FORTH_PARSE_KEY 
24b4						DMARK "KY8" 
24b4			endif 
24b4			 
24b4 80				add b			 
24b5 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24b7							; TODO need to make sure last word in zero term string is accounted for 
24b7 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
24b9			 
24b9			 
24b9				; at end of both strings so both are exact match 
24b9			 
24b9			;       skip ptr for next word 
24b9			 
24b9 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
24bc 23				inc hl			 ; at next char 
24bd 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
24c0 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24c3				 
24c3				 
24c3			if DEBUG_FORTH_PARSE_KEY 
24c3						DMARK "KY3" 
24c3			endif 
24c3			 
24c3			 
24c3			 
24c3			;       exec code block 
24c3			if DEBUG_FORTH_JP 
24c3				call clear_display 
24c3				call update_display 
24c3				call delay1s 
24c3				ld hl, (cli_execword)     ; save for next check if no match on this word 
24c3				ld a,h 
24c3				ld hl, os_word_scratch 
24c3				call hexout 
24c3				ld hl, (cli_execword)     ; save for next check if no match on this word 
24c3				ld a,l 
24c3				ld hl, os_word_scratch+2 
24c3				call hexout 
24c3				ld hl, os_word_scratch+4 
24c3				ld a,0 
24c3				ld (hl),a 
24c3				ld de,os_word_scratch 
24c3				call str_at_display 
24c3					ld a, display_row_2 
24c3					call str_at_display 
24c3				ld de, (cli_origtoken) 
24c3				ld a, display_row_1+10 
24c3					call str_at_display 
24c3			 
24c3				ld a,display_row_1 
24c3				ld de, .foundword 
24c3				ld a, display_row_3 
24c3				call str_at_display 
24c3				call update_display 
24c3				call delay1s 
24c3				call delay1s 
24c3				call delay1s 
24c3			endif 
24c3			 
24c3			if DEBUG_FORTH_PARSE_KEY 
24c3						DMARK "KYj" 
24c3			endif 
24c3				; TODO save the word pointer in this exec 
24c3			 
24c3 2a 7f f9			ld hl,(cli_execword) 
24c6 e9				jp (hl) 
24c7			 
24c7			 
24c7			;    if not same 
24c7			;	scan for zero term 
24c7			;	get ptr for next word 
24c7			;	goto word comp 
24c7			 
24c7			.execpnskipword:	; get pointer to next word 
24c7 2a 7d f9			ld hl,(cli_nextword) 
24ca			 
24ca 7e				ld a,(hl) 
24cb fe 00			cp WORD_SYS_END 
24cd			;	cp 0 
24cd 28 09			jr z, .execendofdict			 ; at end of words 
24cf			 
24cf			if DEBUG_FORTH_PARSE_KEY 
24cf						DMARK "KY4" 
24cf			endif 
24cf			if DEBUG_FORTH_PARSE_EXEC 
24cf			 
24cf				; see if disabled 
24cf			 
24cf			;	ld a, (os_view_disable) 
24cf			;	cp '*' 
24cf				ld a,(debug_vector) 
24cf				cp $c9   ; RET 
24cf				jr z, .noskip 
24cf			 
24cf			 
24cf				ld de, .nowordfound 
24cf				ld a, display_row_3 
24cf				call str_at_display 
24cf				call update_display 
24cf				ld a, 100 
24cf				call aDelayInMS 
24cf				 
24cf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24cf					call delay250ms 
24cf				endif 
24cf			.noskip:  
24cf			 
24cf			endif	 
24cf			 
24cf 2a 79 f9			ld hl,(cli_origptr) 
24d2 22 7b f9			ld (cli_ptr),hl 
24d5			 
24d5			if DEBUG_FORTH_PARSE_KEY 
24d5						DMARK "KY5" 
24d5			endif 
24d5 c3 7b 24			jp .execpnword			; else go to next word 
24d8			 
24d8			.execendofdict:  
24d8			 
24d8			if DEBUG_FORTH_PARSE_KEY 
24d8						DMARK "KYe" 
24d8			endif 
24d8			if DEBUG_FORTH_PARSE_EXEC 
24d8				; see if disabled 
24d8			 
24d8			;	ld a, (os_view_disable) 
24d8			;	cp '*' 
24d8				ld a,(debug_vector) 
24d8				cp $c9   ; ret 
24d8				jr z, .ispskip 
24d8			 
24d8				call clear_display 
24d8				call update_display 
24d8				call delay1s 
24d8				ld de, (cli_origptr) 
24d8				ld a, display_row_1 
24d8				call str_at_display 
24d8				 
24d8				ld de, .enddict 
24d8				ld a, display_row_3 
24d8				call str_at_display 
24d8				call update_display 
24d8				ld a, 100 
24d8				call aDelayInMS 
24d8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24d8				call delay1s 
24d8				call delay1s 
24d8				call delay1s 
24d8				endif 
24d8			.ispskip:  
24d8				 
24d8			endif	 
24d8			 
24d8			 
24d8			 
24d8				; if the word is not a keyword then must be a literal so push it to stack 
24d8			 
24d8			; push token to stack to end of word 
24d8			 
24d8				STACKFRAME ON $1efe $2f9f 
24d8				if DEBUG_STACK_IMB 
24d8					if ON 
24d8						exx 
24d8						ld de, $1efe 
24d8						ld a, d 
24d8						ld hl, curframe 
24d8						call hexout 
24d8						ld a, e 
24d8						ld hl, curframe+2 
24d8						call hexout 
24d8						ld hl, $1efe 
24d8						push hl 
24d8						ld hl, $2f9f 
24d8						push hl 
24d8						exx 
24d8					endif 
24d8				endif 
24d8			endm 
# End of macro STACKFRAME
24d8			 
24d8 2a fd f3		ld hl,(os_tok_ptr) 
24db cd 8c 21		call forth_apush 
24de			 
24de				STACKFRAMECHK ON $1efe $2f9f 
24de				if DEBUG_STACK_IMB 
24de					if ON 
24de						exx 
24de						ld hl, $2f9f 
24de						pop de   ; $2f9f 
24de						call cmp16 
24de						jr nz, .spnosame 
24de						ld hl, $1efe 
24de						pop de   ; $1efe 
24de						call cmp16 
24de						jr z, .spfrsame 
24de						.spnosame: call showsperror 
24de						.spfrsame: nop 
24de						exx 
24de					endif 
24de				endif 
24de			endm 
# End of macro STACKFRAMECHK
24de			 
24de			execnext: 
24de			 
24de			if DEBUG_FORTH_PARSE_KEY 
24de						DMARK "KY>" 
24de			endif 
24de			; move past token to next word 
24de			 
24de 2a fd f3		ld hl, (os_tok_ptr) 
24e1 3e 00		ld a, 0 
24e3 01 ff 00		ld bc, 255     ; input buffer size 
24e6 ed b1		cpir 
24e8			 
24e8			if DEBUG_FORTH_PARSE_KEY 
24e8						DMARK "KY!" 
24e8				CALLMONITOR 
24e8			endif	 
24e8			; TODO this might place hl on the null, so will need to forward on??? 
24e8			;inc hl   ; see if this gets onto the next item 
24e8			 
24e8			 
24e8			; TODO pass a pointer to the buffer to push 
24e8			; TODO call function to push 
24e8			 
24e8			; look for end of input 
24e8			 
24e8			;inc hl 
24e8			;ld a,(hl) 
24e8			;cp FORTH_END_BUFFER 
24e8			;ret z 
24e8			 
24e8			 
24e8 c3 61 24		jp exec1 
24eb			 
24eb			 
24eb			 
24eb			 
24eb			 
24eb			 
24eb			 
24eb			 
24eb			 
24eb			findnexttok: 
24eb			 
24eb				; hl is pointer to move 
24eb				; de is the token to locate 
24eb			 
24eb					if DEBUG_FORTH 
24eb						DMARK "NTK" 
24eb						CALLMONITOR 
24eb					endif 
24eb d5				push de 
24ec			 
24ec			.fnt1:	 
24ec				; find first char of token to locate 
24ec			 
24ec 1a				ld a, (de) 
24ed 4f				ld c,a 
24ee 7e				ld a,(hl) 
24ef cd 2c 13			call toUpper 
24f2					if DEBUG_FORTH 
24f2						DMARK "NT1" 
24f2						CALLMONITOR 
24f2					endif 
24f2 b9				cp c 
24f3			 
24f3 28 03			jr z, .fnt2cmpmorefirst	 
24f5			 
24f5				; first char not found move to next char 
24f5			 
24f5 23				inc hl 
24f6 18 f4			jr .fnt1 
24f8			 
24f8			.fnt2cmpmorefirst:	 
24f8				; first char of token found.  
24f8			 
24f8 e5				push hl     ; save start of token just in case it is the right one 
24f9 d9				exx 
24fa e1				pop hl        ; save it to hl' 
24fb d9				exx 
24fc			 
24fc			 
24fc			.fnt2cmpmore:	 
24fc				; compare the rest 
24fc				 
24fc 23				inc hl 
24fd 13				inc de 
24fe				 
24fe 1a				ld a, (de) 
24ff 4f				ld c,a 
2500 7e				ld a,(hl) 
2501 cd 2c 13			call toUpper 
2504			 
2504					if DEBUG_FORTH 
2504						DMARK "NT2" 
2504						CALLMONITOR 
2504					endif 
2504				; c has the token to find char 
2504				; a has the mem to scan char 
2504			 
2504 b9				cp c 
2505 28 04			jr z,.fntmatch1 
2507			 
2507				; they are not the same 
2507			 
2507					if DEBUG_FORTH 
2507						DMARK "NT3" 
2507						CALLMONITOR 
2507					endif 
2507 d1				pop de	; reset de token to look for 
2508 d5				push de 
2509 18 e1			jr .fnt1 
250b				 
250b			.fntmatch1: 
250b			 
250b				; is the same char a null which means we might have a full hit? 
250b					if DEBUG_FORTH 
250b						DMARK "NT4" 
250b						CALLMONITOR 
250b					endif 
250b			 
250b fe 00			cp 0 
250d 28 0b			jr z, .fntmatchyes 
250f			 
250f				; are we at the end of the token to find? 
250f			 
250f					if DEBUG_FORTH 
250f						DMARK "NT5" 
250f						CALLMONITOR 
250f					endif 
250f 3e 00			ld a, 0 
2511 b9				cp c 
2512			 
2512 c2 fc 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2515			 
2515					if DEBUG_FORTH 
2515						DMARK "NT6" 
2515						CALLMONITOR 
2515					endif 
2515				; token to find is exhusted but no match to stream 
2515			 
2515				; restore tok pointer and continue on 
2515 d1				pop de 
2516 d5				push de 
2517 c3 ec 24			jp .fnt1 
251a			 
251a			 
251a			.fntmatchyes: 
251a			 
251a				; hl now contains the end of the found token 
251a			 
251a				; get rid of saved token pointer to find 
251a			 
251a d1				pop de 
251b			 
251b					if DEBUG_FORTH 
251b						DMARK "NT9" 
251b						CALLMONITOR 
251b					endif 
251b			 
251b				; hl will be on the null term so forward on 
251b			 
251b				; get back the saved start of the token 
251b			 
251b d9				exx 
251c e5				push hl     ; save start of token just in case it is the right one 
251d d9				exx 
251e e1				pop hl        ; save it to hl 
251f			 
251f c9				ret 
2520			 
2520			 
2520			; LIST needs to find a specific token   
2520			; FORGET needs to find a spefici token 
2520			 
2520			; SAVE needs to find all tokens by flag 
2520			; WORDS just needs to scan through all  by flag 
2520			; UWORDS needs to scan through all by flag 
2520			 
2520			 
2520			; given hl as pointer to start of dict look up string 
2520			; return hl as pointer to start of word block 
2520			; or 0 if not found 
2520			 
2520			forth_find_tok: 
2520 c9				ret 
2521			 
2521			; given hl as pointer to dict structure 
2521			; move to the next dict block structure 
2521			 
2521			forth_tok_next: 
2521				; hl now points to the address of the next word pointer  
2521				; TODO skip compiled symbol for now 
2521			;	push de 
2521 23				inc hl 
2522 5e				ld e, (hl) 
2523 23				inc hl 
2524 56				ld d, (hl) 
2525 23				inc hl 
2526			 
2526 eb				ex de,hl 
2527			if DEBUG_FORTH_PARSE_NEXTWORD 
2527				push bc 
2527				ld bc, (cli_nextword) 
2527						DMARK "NXW" 
2527				CALLMONITOR 
2527				pop bc 
2527			endif 
2527			;	pop de	 
2527 c9				ret 
2528			 
2528			 
2528			 
2528			; eof 
# End of file forth_parserv5.asm
2528				include "forth_wordsv4.asm" 
2528			 
2528			; the core word dictionary v4 
2528			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2528			 
2528			; this is a linked list for each of the system words used 
2528			; user defined words will follow the same format but will be in ram 
2528			 
2528			 
2528			; 
2528			; 
2528			; define linked list: 
2528			; 
2528			; 1. compiled byte op code 
2528			; 2. len of text word 
2528			; 3. text word 
2528			; 4. ptr to next dictionary word 
2528			; 5. asm, calls etc for the word 
2528			; 
2528			;  if 1 == 0 then last word in dict  
2528			;   
2528			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2528			;  
2528			;  
2528			; create basic standard set of words 
2528			; 
2528			;  
2528			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2528			; 2DUP 2DROP 2SWAP  
2528			; @ C@ - get byte  
2528			; ! C! - store byte 
2528			; 0< true if less than zero 
2528			; 0= true if zero 
2528			; < >  
2528			; = true if same 
2528			; variables 
2528			 
2528			 
2528			; Hardware specific words I may need 
2528			; 
2528			; IN OUT  
2528			; calls to key util functions 
2528			; calls to hardward abstraction stuff 
2528			; easy control of frame buffers and lcd i/o 
2528			; keyboard  
2528			 
2528			 
2528			;DICT: macro 
2528			; op_code, len, word, next 
2528			;    word: 
2528			;    db op_code 
2528			;    ds word zero term 
2528			;    dw next 
2528			;    endm 
2528			 
2528			 
2528			 
2528			 
2528			; op code 1 is a flag for user define words which are to be handled differently 
2528			 
2528			 
2528			; 
2528			; 
2528			;    TODO on entry to a word this should be the expected environment 
2528			;    hl - tos value if number then held, if string this is the ptr 
2528			;    de -  
2528			 
2528			 
2528			; opcode ranges 
2528			; 0 - end of word dict 
2528			; 255 - user define words 
2528			 
2528			sysdict: 
2528			include "forth_opcodes.asm" 
2528			; op codes for forth keywords 
2528			; free to use code 0  
2528				OPCODE_HEAP: equ  1 
2528				OPCODE_EXEC: equ 2 
2528				OPCODE_DUP: equ 3 
2528				OPCODE_SWAP: equ 4 
2528				OPCODE_COLN: equ 5 
2528				OPCODE_SCOLN: equ 6 
2528				OPCODE_DROP: equ 7 
2528				OPCODE_DUP2: equ 8 
2528				OPCODE_DROP2: equ 9 
2528				OPCODE_SWAP2: equ 10 
2528				OPCODE_AT: equ 11 
2528				OPCODE_CAT: equ 12 
2528				OPCODE_BANG: equ 13 
2528				OPCODE_CBANG: equ 14 
2528				OPCODE_SCALL: equ 15 
2528				OPCODE_DEPTH: equ 16 
2528				OPCODE_OVER: equ 17 
2528				OPCODE_PAUSE: equ 18 
2528				OPCODE_PAUSES: equ 19 
2528				OPCODE_ROT: equ 20 
2528			;free to reuse	OPCODE_WORDS: equ 21 
2528			        OPCODE_NOT: equ 21 
2528				OPCODE_UWORDS: equ 22 
2528				OPCODE_BP: equ 23 
2528				OPCODE_MONITOR: equ 24  
2528				OPCODE_MALLOC: equ 25 
2528				OPCODE_FREE: equ 26 
2528				OPCODE_LIST: equ 27 
2528				OPCODE_FORGET: equ 28 
2528				OPCODE_NOP: equ 29 
2528				OPCODE_COMO: equ 30 
2528				OPCODE_COMC: equ 31 
2528			;free to reuse	OPCODE_ENDCORE: equ 32 
2528				OPCODE_AFTERSOUND: equ 33 
2528				OPCODE_GP2: equ 34 
2528				OPCODE_GP3: equ 35 
2528				OPCODE_GP4: equ 36 
2528				OPCODE_SIN: equ 37 
2528				OPCODE_SOUT: equ 38 
2528				OPCODE_SPIO: equ 39 
2528				OPCODE_SPICEH: equ 40 
2528				OPCODE_SPIOb: equ 41 
2528				OPCODE_SPII: equ 42 
2528				OPCODE_SESEL: equ 43 
2528				OPCODE_CARTDEV: equ 44 
2528			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2528				OPCODE_FB: equ 46 
2528				OPCODE_EMIT: equ 47 
2528				OPCODE_DOTH: equ 48 
2528				OPCODE_DOTF: equ 49 
2528				OPCODE_DOT: equ 50 
2528				OPCODE_CLS: equ 51 
2528				OPCODE_DRAW: equ 52 
2528				OPCODE_DUMP: equ 53 
2528				OPCODE_CDUMP: equ 54 
2528				OPCODE_DAT: equ 55 
2528				OPCODE_HOME: equ 56 
2528				OPCODE_SPACE: equ 57 
2528				OPCODE_SPACES: equ 58 
2528				OPCODE_SCROLL: equ 59 
2528				OPCODE_ATQ: equ 60 
2528				OPCODE_AUTODSP: equ 61 
2528				OPCODE_MENU: equ 62 
2528			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2528				OPCODE_THEN: equ 64 
2528				OPCODE_ELSE: equ 65 
2528				OPCODE_DO: equ 66 
2528				OPCODE_LOOP: equ 67 
2528				OPCODE_I: equ 68 
2528				OPCODE_DLOOP: equ 69  
2528				OPCODE_REPEAT: equ 70  
2528				OPCODE_UNTIL: equ 71 
2528				OPCODE_ENDFLOW: equ 72 
2528				OPCODE_WAITK: equ 73 
2528				OPCODE_ACCEPT: equ 74 
2528				OPCODE_EDIT: equ 75 
2528			;free to reuse	OPCODE_ENDKEY: equ 76 
2528				OPCODE_LZERO: equ 77 
2528				OPCODE_TZERO: equ 78 
2528				OPCODE_LESS: equ 79 
2528				OPCODE_GT: equ 80 
2528				OPCODE_EQUAL: equ 81  
2528			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2528				OPCODE_NEG: equ 83 
2528				OPCODE_DIV: equ 84 
2528				OPCODE_MUL: equ 85 
2528				OPCODE_MIN: equ 86 
2528				OPCODE_MAX: equ 87 
2528				OPCODE_RND16: equ 88 
2528				OPCODE_RND8: equ 89 
2528				OPCODE_RND: equ 90 
2528			;free to reuse	OPCODE_ENDMATHS: equ 91  
2528				OPCODE_BYNAME: equ 92 
2528				OPCODE_DIR: equ 93 
2528				OPCODE_SAVE: equ 94 
2528				OPCODE_LOAD: equ 95 
2528				OPCODE_BSAVE: equ 96 
2528				OPCODE_BLOAD: equ 97 
2528				OPCODE_SEO: equ 98  
2528				OPCODE_SEI: equ 99 
2528				OPCODE_SFREE: equ 100 
2528				OPCODE_SIZE: equ 101 
2528				OPCODE_CREATE: equ 102 
2528				OPCODE_APPEND: equ 103 
2528				OPCODE_SDEL: equ 104 
2528				OPCODE_OPEN: equ 105 
2528				OPCODE_READ: equ 106 
2528				OPCODE_EOF: equ 106 
2528				OPCODE_FORMAT: equ 107 
2528				OPCODE_LABEL: equ 108 
2528				OPCODE_LABELS: equ 109 
2528			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2528				OPCODE_UPPER: equ 111 
2528				OPCODE_LOWER: equ 112 
2528				OPCODE_SUBSTR: equ 113 
2528				OPCODE_LEFT: equ 114 
2528				OPCODE_RIGHT: equ 115 
2528				OPCODE_STR2NUM: equ 116 
2528				OPCODE_NUM2STR: equ 117 
2528				OPCODE_CONCAT: equ 118 
2528				OPCODE_FIND: equ 119 
2528				OPCODE_LEN: equ 120 
2528				OPCODE_CHAR: equ 121 
2528			; free to reuse	OPCODE_STRLEN: equ 122 
2528			; free to reuse	OPCODE_ENDSTR: equ 123 
2528				OPCODE_V0S: equ 124 
2528				OPCODE_V0Q: equ 125 
2528				OPCODE_V1S: equ 126 
2528				OPCODE_V1Q: equ 127 
2528				OPCODE_V2S: equ 128 
2528				OPCODE_V2Q: equ 129 
2528				OPCODE_V3S: equ 130 
2528				OPCODE_V3Q: equ 131 
2528			;free to reuse	OPCODE_END: equ 132 
2528				OPCODE_ZDUP: equ 133 
2528			 
2528			; eof 
# End of file forth_opcodes.asm
2528			 
2528			include "forth_words_core.asm" 
2528			 
2528			; | ## Core Words 
2528			 
2528			;if MALLOC_4 
2528			 
2528			.HEAP: 
2528			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2528 15				db WORD_SYS_CORE+OPCODE_HEAP             
2529 67 25			dw .EXEC            
252b 05				db 4 + 1 
252c .. 00			db "HEAP",0              
2531				endm 
# End of macro CWHEAD
2531			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2531			; | | u1 - Current number of bytes in the heap 
2531			; | | u2 - Remaining bytes left on the heap 
2531			; | |  
2531			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2531			 
2531			 
2531				if DEBUG_FORTH_WORDS_KEY 
2531					DMARK "HEP" 
2531 f5				push af  
2532 3a 46 25			ld a, (.dmark)  
2535 32 a6 fd			ld (debug_mark),a  
2538 3a 47 25			ld a, (.dmark+1)  
253b 32 a7 fd			ld (debug_mark+1),a  
253e 3a 48 25			ld a, (.dmark+2)  
2541 32 a8 fd			ld (debug_mark+2),a  
2544 18 03			jr .pastdmark  
2546 ..			.dmark: db "HEP"  
2549 f1			.pastdmark: pop af  
254a			endm  
# End of macro DMARK
254a					CALLMONITOR 
254a cd aa fd			call debug_vector  
254d				endm  
# End of macro CALLMONITOR
254d				endif 
254d 2a 0a 80			ld hl, (free_list )      
2550 11 0e 80			ld de, heap_start 
2553			 
2553 ed 52			sbc hl, de  
2555			 
2555 cd 23 20			call forth_push_numhl 
2558			 
2558			 
2558 ed 5b 0a 80		ld de, (free_list )      
255c 21 d7 f0			ld hl, heap_end 
255f			 
255f ed 52			sbc hl, de 
2561			 
2561 cd 23 20			call forth_push_numhl 
2564				 
2564			 
2564				 
2564			 
2564			 
2564			 
2564				NEXTW 
2564 c3 d0 23			jp macro_next 
2567				endm 
# End of macro NEXTW
2567			;endif 
2567			 
2567			.EXEC: 
2567			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2567			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2567			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2567			;; > > 
2567			;; > >   
2567			;	STACKFRAME OFF $5efe $5f9f 
2567			; 
2567			;		if DEBUG_FORTH_WORDS_KEY 
2567			;			DMARK "EXE" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			; 
2567			;	FORTH_DSP_VALUEHL 
2567			; 
2567			;	FORTH_DSP_POP 
2567			; 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX1" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;;	ld e,(hl) 
2567			;;	inc hl 
2567			;;	ld d,(hl) 
2567			;;	ex de,hl 
2567			; 
2567			;;		if DEBUG_FORTH_WORDS 
2567			;;			DMARK "EX2" 
2567			;;			CALLMONITOR 
2567			;;		endif 
2567			;	push hl 
2567			; 
2567			;	;ld a, 0 
2567			;	;ld a, FORTH_END_BUFFER 
2567			;	call strlenz 
2567			;	inc hl   ; include zero term to copy 
2567			;	inc hl   ; include term 
2567			;	inc hl   ; include term 
2567			;	ld b,0 
2567			;	ld c,l 
2567			;	pop hl 
2567			;	ld de, execscratch 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX3" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	ldir 
2567			; 
2567			; 
2567			;	ld hl, execscratch 
2567			; 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EXe" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			; 
2567			;	call forthparse 
2567			;	call forthexec 
2567			;;	call forthexec_cleanup 
2567			;;	call forthparse 
2567			;;	call forthexec 
2567			; 
2567			;	STACKFRAMECHK OFF $5efe $5f9f 
2567			; 
2567			;	; an immediate word so no need to process any more words 
2567			;	ret 
2567			;	NEXTW 
2567			 
2567			; dead code - old version  
2567			;	FORTH_RSP_NEXT 
2567			 
2567			;  
2567			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2567			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2567			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2567			;	push hl 
2567			;	push de 
2567			;	push bc 
2567			; 
2567			; 
2567			;		if DEBUG_FORTH_WORDS_KEY 
2567			;			DMARK "EXR" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			; 
2567			; 
2567			; 
2567			;	;v5 FORTH_DSP_VALUE 
2567			;	FORTH_DSP_VALUEHL 
2567			; 
2567			;	; TODO do string type checks 
2567			; 
2567			;;v5	inc hl   ; skip type 
2567			; 
2567			;	push hl  ; source code  
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX1" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	ld a, 0 
2567			;	call strlent 
2567			; 
2567			;	inc hl 
2567			;	inc hl 
2567			;	inc hl 
2567			;	inc hl 
2567			; 
2567			;	push hl    ; size 
2567			; 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX2" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	call malloc 
2567			; 
2567			;	ex de, hl    ; de now contains malloc area 
2567			;	pop bc   	; get byte count 
2567			;	pop hl      ; get string to copy 
2567			; 
2567			;	push de     ; save malloc for free later 
2567			; 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX3" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	ldir       ; duplicate string 
2567			; 
2567			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2567			;	 
2567			;	; TODO fix the parse would be better than this...  
2567			;	ex de, hl 
2567			;	dec hl 
2567			;	ld a, 0 
2567			;	ld (hl), a 
2567			;	dec hl 
2567			;	ld a, ' ' 
2567			;	ld (hl), a 
2567			;	dec hl 
2567			;	ld (hl), a 
2567			; 
2567			;	dec hl 
2567			;	ld (hl), a 
2567			; 
2567			; 
2567			;	FORTH_DSP_POP  
2567			; 
2567			;	pop hl     
2567			;	push hl    ; save malloc area 
2567			; 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX4" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			; 
2567			;	call forthparse 
2567			;	call forthexec 
2567			;	 
2567			;	pop hl 
2567			;	if DEBUG_FORTH_WORDS 
2567			;		DMARK "EX5" 
2567			;		CALLMONITOR 
2567			;	endif 
2567			; 
2567			;	if FORTH_ENABLE_FREE 
2567			;	call free 
2567			;	endif 
2567			; 
2567			;	if DEBUG_FORTH_WORDS 
2567			;		DMARK "EX6" 
2567			;		CALLMONITOR 
2567			;	endif 
2567			; 
2567			;	pop bc 
2567			;	pop de 
2567			;	pop hl 
2567			;;	FORTH_RSP_POP	  
2567			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2567			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2567			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2567			; 
2567			;	if DEBUG_FORTH_WORDS 
2567			;		DMARK "EX7" 
2567			;		CALLMONITOR 
2567			;	endif 
2567			;	NEXTW 
2567			 
2567			;.STKEXEC: 
2567			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2567			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2567			; 
2567			; 
2567			;		if DEBUG_FORTH_WORDS_KEY 
2567			;			DMARK "STX" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			; 
2567			;	FORTH_DSP_VALUEHL 
2567			; 
2567			;	ld (store_tmp1), hl    ; count 
2567			; 
2567			;	FORTH_DSP_POP 
2567			;.stkexec1: 
2567			;	ld hl, (store_tmp1)   ; count 
2567			;	ld a, 0 
2567			;	cp l 
2567			;	ret z 
2567			; 
2567			;	dec hl 
2567			;	ld (store_tmp1), hl    ; count 
2567			;	 
2567			;	FORTH_DSP_VALUEHL 
2567			;	push hl 
2567			;	 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EXp" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	FORTH_DSP_POP 
2567			; 
2567			;	call strlenz 
2567			;	inc hl   ; include zero term to copy 
2567			;	inc hl   ; include zero term to copy 
2567			;	inc hl   ; include zero term to copy 
2567			;	ld b,0 
2567			;	ld c,l 
2567			;	pop hl 
2567			;	ld de, execscratch 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EX3" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	ldir 
2567			; 
2567			; 
2567			;	ld hl, execscratch 
2567			; 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EXP" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			; 
2567			;	call forthparse 
2567			;	ld hl, execscratch 
2567			;		if DEBUG_FORTH_WORDS 
2567			;			DMARK "EXx" 
2567			;			CALLMONITOR 
2567			;		endif 
2567			;	call forthexec 
2567			; 
2567			;	jp .stkexec1 
2567			; 
2567			;	ret 
2567			 
2567			 
2567			.DUP: 
2567			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2567 17				db WORD_SYS_CORE+OPCODE_DUP             
2568 dd 25			dw .ZDUP            
256a 04				db 3 + 1 
256b .. 00			db "DUP",0              
256f				endm 
# End of macro CWHEAD
256f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
256f			 
256f				if DEBUG_FORTH_WORDS_KEY 
256f					DMARK "DUP" 
256f f5				push af  
2570 3a 84 25			ld a, (.dmark)  
2573 32 a6 fd			ld (debug_mark),a  
2576 3a 85 25			ld a, (.dmark+1)  
2579 32 a7 fd			ld (debug_mark+1),a  
257c 3a 86 25			ld a, (.dmark+2)  
257f 32 a8 fd			ld (debug_mark+2),a  
2582 18 03			jr .pastdmark  
2584 ..			.dmark: db "DUP"  
2587 f1			.pastdmark: pop af  
2588			endm  
# End of macro DMARK
2588					CALLMONITOR 
2588 cd aa fd			call debug_vector  
258b				endm  
# End of macro CALLMONITOR
258b				endif 
258b			 
258b				FORTH_DSP 
258b cd e0 21			call macro_forth_dsp 
258e				endm 
# End of macro FORTH_DSP
258e			 
258e 7e				ld a, (HL) 
258f fe 01			cp DS_TYPE_STR 
2591 20 25			jr nz, .dupinum 
2593			 
2593				; push another string 
2593			 
2593				FORTH_DSP_VALUEHL     		 
2593 cd 1a 22			call macro_dsp_valuehl 
2596				endm 
# End of macro FORTH_DSP_VALUEHL
2596			 
2596			if DEBUG_FORTH_WORDS 
2596				DMARK "DUs" 
2596 f5				push af  
2597 3a ab 25			ld a, (.dmark)  
259a 32 a6 fd			ld (debug_mark),a  
259d 3a ac 25			ld a, (.dmark+1)  
25a0 32 a7 fd			ld (debug_mark+1),a  
25a3 3a ad 25			ld a, (.dmark+2)  
25a6 32 a8 fd			ld (debug_mark+2),a  
25a9 18 03			jr .pastdmark  
25ab ..			.dmark: db "DUs"  
25ae f1			.pastdmark: pop af  
25af			endm  
# End of macro DMARK
25af				CALLMONITOR 
25af cd aa fd			call debug_vector  
25b2				endm  
# End of macro CALLMONITOR
25b2			endif 
25b2 cd 91 20			call forth_push_str 
25b5			 
25b5				NEXTW 
25b5 c3 d0 23			jp macro_next 
25b8				endm 
# End of macro NEXTW
25b8			 
25b8			 
25b8			.dupinum: 
25b8				 
25b8			 
25b8			 
25b8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b8 cd 1a 22			call macro_dsp_valuehl 
25bb				endm 
# End of macro FORTH_DSP_VALUEHL
25bb			 
25bb			; TODO add floating point number detection 
25bb			 
25bb			if DEBUG_FORTH_WORDS 
25bb				DMARK "DUi" 
25bb f5				push af  
25bc 3a d0 25			ld a, (.dmark)  
25bf 32 a6 fd			ld (debug_mark),a  
25c2 3a d1 25			ld a, (.dmark+1)  
25c5 32 a7 fd			ld (debug_mark+1),a  
25c8 3a d2 25			ld a, (.dmark+2)  
25cb 32 a8 fd			ld (debug_mark+2),a  
25ce 18 03			jr .pastdmark  
25d0 ..			.dmark: db "DUi"  
25d3 f1			.pastdmark: pop af  
25d4			endm  
# End of macro DMARK
25d4				CALLMONITOR 
25d4 cd aa fd			call debug_vector  
25d7				endm  
# End of macro CALLMONITOR
25d7			endif 
25d7			 
25d7 cd 23 20			call forth_push_numhl 
25da				NEXTW 
25da c3 d0 23			jp macro_next 
25dd				endm 
# End of macro NEXTW
25dd			.ZDUP: 
25dd			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25dd 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25de 15 26			dw .SWAP            
25e0 05				db 4 + 1 
25e1 .. 00			db "?DUP",0              
25e6				endm 
# End of macro CWHEAD
25e6			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
25e6			 
25e6				if DEBUG_FORTH_WORDS_KEY 
25e6					DMARK "qDU" 
25e6 f5				push af  
25e7 3a fb 25			ld a, (.dmark)  
25ea 32 a6 fd			ld (debug_mark),a  
25ed 3a fc 25			ld a, (.dmark+1)  
25f0 32 a7 fd			ld (debug_mark+1),a  
25f3 3a fd 25			ld a, (.dmark+2)  
25f6 32 a8 fd			ld (debug_mark+2),a  
25f9 18 03			jr .pastdmark  
25fb ..			.dmark: db "qDU"  
25fe f1			.pastdmark: pop af  
25ff			endm  
# End of macro DMARK
25ff					CALLMONITOR 
25ff cd aa fd			call debug_vector  
2602				endm  
# End of macro CALLMONITOR
2602				endif 
2602				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2602 cd 1a 22			call macro_dsp_valuehl 
2605				endm 
# End of macro FORTH_DSP_VALUEHL
2605			 
2605 e5				push hl 
2606			 
2606				; is it a zero? 
2606			 
2606 3e 00			ld a, 0 
2608 84				add h 
2609 85				add l 
260a			 
260a e1				pop hl 
260b			 
260b fe 00			cp 0 
260d 28 03			jr z, .dup2orig 
260f			 
260f			 
260f cd 23 20			call forth_push_numhl 
2612			 
2612			 
2612			; TODO add floating point number detection 
2612			 
2612			.dup2orig: 
2612			 
2612				NEXTW 
2612 c3 d0 23			jp macro_next 
2615				endm 
# End of macro NEXTW
2615			.SWAP: 
2615			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2615 18				db WORD_SYS_CORE+OPCODE_SWAP             
2616 54 26			dw .COLN            
2618 05				db 4 + 1 
2619 .. 00			db "SWAP",0              
261e				endm 
# End of macro CWHEAD
261e			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
261e				if DEBUG_FORTH_WORDS_KEY 
261e					DMARK "SWP" 
261e f5				push af  
261f 3a 33 26			ld a, (.dmark)  
2622 32 a6 fd			ld (debug_mark),a  
2625 3a 34 26			ld a, (.dmark+1)  
2628 32 a7 fd			ld (debug_mark+1),a  
262b 3a 35 26			ld a, (.dmark+2)  
262e 32 a8 fd			ld (debug_mark+2),a  
2631 18 03			jr .pastdmark  
2633 ..			.dmark: db "SWP"  
2636 f1			.pastdmark: pop af  
2637			endm  
# End of macro DMARK
2637					CALLMONITOR 
2637 cd aa fd			call debug_vector  
263a				endm  
# End of macro CALLMONITOR
263a				endif 
263a			 
263a			; TODO Use os stack swap memory 
263a				FORTH_DSP_VALUEHL 
263a cd 1a 22			call macro_dsp_valuehl 
263d				endm 
# End of macro FORTH_DSP_VALUEHL
263d e5				push hl     ; w2 
263e			 
263e				FORTH_DSP_POP 
263e cd d2 22			call macro_forth_dsp_pop 
2641				endm 
# End of macro FORTH_DSP_POP
2641			 
2641				FORTH_DSP_VALUEHL 
2641 cd 1a 22			call macro_dsp_valuehl 
2644				endm 
# End of macro FORTH_DSP_VALUEHL
2644			 
2644				FORTH_DSP_POP 
2644 cd d2 22			call macro_forth_dsp_pop 
2647				endm 
# End of macro FORTH_DSP_POP
2647			 
2647 d1				pop de     ; w2	, hl = w1 
2648			 
2648 eb				ex de, hl 
2649 d5				push de 
264a			 
264a cd 23 20			call forth_push_numhl 
264d			 
264d e1				pop hl 
264e			 
264e cd 23 20			call forth_push_numhl 
2651				 
2651			 
2651				NEXTW 
2651 c3 d0 23			jp macro_next 
2654				endm 
# End of macro NEXTW
2654			.COLN: 
2654			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2654 19				db WORD_SYS_CORE+OPCODE_COLN             
2655 e0 27			dw .SCOLN            
2657 02				db 1 + 1 
2658 .. 00			db ":",0              
265a				endm 
# End of macro CWHEAD
265a			; | : ( -- )         Create new word | DONE 
265a			 
265a				if DEBUG_FORTH_WORDS_KEY 
265a					DMARK "CLN" 
265a f5				push af  
265b 3a 6f 26			ld a, (.dmark)  
265e 32 a6 fd			ld (debug_mark),a  
2661 3a 70 26			ld a, (.dmark+1)  
2664 32 a7 fd			ld (debug_mark+1),a  
2667 3a 71 26			ld a, (.dmark+2)  
266a 32 a8 fd			ld (debug_mark+2),a  
266d 18 03			jr .pastdmark  
266f ..			.dmark: db "CLN"  
2672 f1			.pastdmark: pop af  
2673			endm  
# End of macro DMARK
2673					CALLMONITOR 
2673 cd aa fd			call debug_vector  
2676				endm  
# End of macro CALLMONITOR
2676				endif 
2676			STACKFRAME OFF $8efe $989f 
2676				if DEBUG_STACK_IMB 
2676					if OFF 
2676						exx 
2676						ld de, $8efe 
2676						ld a, d 
2676						ld hl, curframe 
2676						call hexout 
2676						ld a, e 
2676						ld hl, curframe+2 
2676						call hexout 
2676						ld hl, $8efe 
2676						push hl 
2676						ld hl, $989f 
2676						push hl 
2676						exx 
2676					endif 
2676				endif 
2676			endm 
# End of macro STACKFRAME
2676			; get parser buffer length  of new word 
2676			 
2676			 
2676			 
2676				; move tok past this to start of name defintition 
2676				; TODO get word to define 
2676				; TODO Move past word token 
2676				; TODO get length of string up to the ';' 
2676			 
2676 2a fd f3		ld hl, (os_tok_ptr) 
2679 23			inc hl 
267a 23			inc hl 
267b			 
267b 3e 3b		ld a, ';' 
267d cd 40 13		call strlent 
2680			 
2680 7d			ld a,l 
2681 32 ec f0		ld (os_new_parse_len), a 
2684			 
2684			 
2684			if DEBUG_FORTH_UWORD 
2684 ed 5b fd f3	ld de, (os_tok_ptr) 
2688					DMARK ":01" 
2688 f5				push af  
2689 3a 9d 26			ld a, (.dmark)  
268c 32 a6 fd			ld (debug_mark),a  
268f 3a 9e 26			ld a, (.dmark+1)  
2692 32 a7 fd			ld (debug_mark+1),a  
2695 3a 9f 26			ld a, (.dmark+2)  
2698 32 a8 fd			ld (debug_mark+2),a  
269b 18 03			jr .pastdmark  
269d ..			.dmark: db ":01"  
26a0 f1			.pastdmark: pop af  
26a1			endm  
# End of macro DMARK
26a1			CALLMONITOR 
26a1 cd aa fd			call debug_vector  
26a4				endm  
# End of macro CALLMONITOR
26a4			endif 
26a4			 
26a4			; 
26a4			;  new word memory layout: 
26a4			;  
26a4			;    : adg 6666 ;  
26a4			; 
26a4			;    db   1     ; user defined word  
26a4 23			inc hl    
26a5			;    dw   sysdict 
26a5 23			inc hl 
26a6 23			inc hl 
26a7			;    db <word len>+1 (for null) 
26a7 23			inc hl 
26a8			;    db .... <word> 
26a8			; 
26a8			 
26a8 23			inc hl    ; some extras for the word preamble before the above 
26a9 23			inc hl 
26aa 23			inc hl 
26ab 23			inc hl 
26ac 23			inc hl 
26ad 23			inc hl 
26ae 23			inc hl  
26af 23			inc hl 
26b0 23			inc hl 
26b1 23			inc hl 
26b2 23			inc hl 
26b3 23			inc hl 
26b4 23			inc hl 
26b5 23			inc hl     ; TODO how many do we really need?     maybe only 6 
26b6			;       exec word buffer 
26b6			;	<ptr word>   
26b6 23			inc hl 
26b7 23			inc hl 
26b8			;       <word list><null term> 7F final term 
26b8			 
26b8			 
26b8			if DEBUG_FORTH_UWORD 
26b8					DMARK ":02" 
26b8 f5				push af  
26b9 3a cd 26			ld a, (.dmark)  
26bc 32 a6 fd			ld (debug_mark),a  
26bf 3a ce 26			ld a, (.dmark+1)  
26c2 32 a7 fd			ld (debug_mark+1),a  
26c5 3a cf 26			ld a, (.dmark+2)  
26c8 32 a8 fd			ld (debug_mark+2),a  
26cb 18 03			jr .pastdmark  
26cd ..			.dmark: db ":02"  
26d0 f1			.pastdmark: pop af  
26d1			endm  
# End of macro DMARK
26d1			CALLMONITOR 
26d1 cd aa fd			call debug_vector  
26d4				endm  
# End of macro CALLMONITOR
26d4			endif 
26d4			 
26d4			 
26d4				; malloc the size 
26d4			 
26d4 cd aa 13			call malloc 
26d7 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
26da			 
26da			;    db   1     ; user defined word  
26da 3e 01			ld a, WORD_SYS_UWORD  
26dc 77				ld (hl), a 
26dd			 
26dd 23			inc hl    
26de			;    dw   sysdict 
26de 11 28 25		ld de, sysdict       ; continue on with the scan to the system dict 
26e1 73			ld (hl), e 
26e2 23			inc hl 
26e3 72			ld (hl), d 
26e4 23			inc hl 
26e5			 
26e5			 
26e5			;    Setup dict word 
26e5			 
26e5 23			inc hl 
26e6 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
26e9			 
26e9			; 1. get length of dict word 
26e9			 
26e9			 
26e9 2a fd f3		ld hl, (os_tok_ptr) 
26ec 23			inc hl 
26ed 23			inc hl    ; position to start of dict word 
26ee 3e 00		ld a, 0 
26f0 cd 40 13		call strlent 
26f3			 
26f3			 
26f3 23			inc hl    ; to include null??? 
26f4			 
26f4			; write length of dict word 
26f4			 
26f4 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
26f8 1b			dec de 
26f9 eb			ex de, hl 
26fa 73			ld (hl), e 
26fb eb			ex de, hl 
26fc			 
26fc			 
26fc			 
26fc			; copy  
26fc 4d			ld c, l 
26fd 06 00		ld b, 0 
26ff ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2703 2a fd f3		ld hl, (os_tok_ptr) 
2706 23			inc hl 
2707 23			inc hl    ; position to start of dict word 
2708			 
2708			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2708			 
2708			; TODO need to convert word to upper case 
2708			 
2708			ucasetok:	 
2708 7e			ld a,(hl) 
2709 cd 2c 13		call toUpper 
270c 77			ld (hl),a 
270d ed a0		ldi 
270f f2 08 27		jp p, ucasetok 
2712			 
2712			 
2712			 
2712			; de now points to start of where the word body code should be placed 
2712 ed 53 e8 f0	ld (os_new_work_ptr), de 
2716			; hl now points to the words to throw at forthexec which needs to be copied 
2716 22 e6 f0		ld (os_new_src_ptr), hl 
2719			 
2719			; TODO add 'call to forthexec' 
2719			 
2719			if DEBUG_FORTH_UWORD 
2719 c5			push bc 
271a ed 4b ee f0	ld bc, (os_new_malloc) 
271e					DMARK ":0x" 
271e f5				push af  
271f 3a 33 27			ld a, (.dmark)  
2722 32 a6 fd			ld (debug_mark),a  
2725 3a 34 27			ld a, (.dmark+1)  
2728 32 a7 fd			ld (debug_mark+1),a  
272b 3a 35 27			ld a, (.dmark+2)  
272e 32 a8 fd			ld (debug_mark+2),a  
2731 18 03			jr .pastdmark  
2733 ..			.dmark: db ":0x"  
2736 f1			.pastdmark: pop af  
2737			endm  
# End of macro DMARK
2737			CALLMONITOR 
2737 cd aa fd			call debug_vector  
273a				endm  
# End of macro CALLMONITOR
273a c1			pop bc 
273b			endif 
273b			 
273b			 
273b			; create word preamble which should be: 
273b			 
273b			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
273b			 
273b			;    ld hl, <word code> 
273b			;    jp user_exec 
273b			;    <word code bytes> 
273b			 
273b			 
273b			;	inc de     ; TODO ??? or are we already past the word's null 
273b eb			ex de, hl 
273c			 
273c 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
273e			 
273e 23			inc hl 
273f 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2742 23			inc hl 
2743			 
2743 23			inc hl 
2744 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2746			 
2746 01 d1 5c		ld bc, user_exec 
2749 23			inc hl 
274a 71			ld (hl), c     ; poke address of user_exec 
274b 23			inc hl 
274c 70			ld (hl), b     
274d			; 
274d			;	inc hl 
274d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
274d			; 
274d			; 
274d			;	ld bc, macro_forth_rsp_next 
274d			;	inc hl 
274d			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
274d			;	inc hl 
274d			;	ld (hl), b     
274d			; 
274d			;	inc hl 
274d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
274d			; 
274d			; 
274d			;	inc hl 
274d			;	ld bc, forthexec 
274d			;	ld (hl), c     ; poke address of forthexec 
274d			;	inc hl 
274d			;	ld (hl), b      
274d			; 
274d			;	inc hl 
274d			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
274d			; 
274d			;	ld bc, user_dict_next 
274d			;	inc hl 
274d			;	ld (hl), c     ; poke address of forthexec 
274d			;	inc hl 
274d			;	ld (hl), b      
274d			 
274d			; hl is now where we need to copy the word byte data to save this 
274d			 
274d 23			inc hl 
274e 22 e4 f0		ld (os_new_exec), hl 
2751			 
2751			; copy definition 
2751			 
2751 eb			ex de, hl 
2752			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2752			;	inc de    ; skip the PC for this parse 
2752 3a ec f0		ld a, (os_new_parse_len) 
2755 4f			ld c, a 
2756 06 00		ld b, 0 
2758 ed b0		ldir		 ; copy defintion 
275a			 
275a			 
275a			; poke the address of where the new word bytes live for forthexec 
275a			 
275a 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
275d			 
275d ed 5b e4 f0	ld de, (os_new_exec)      
2761			 
2761 73			ld (hl), e 
2762 23			inc hl 
2763 72			ld (hl), d 
2764			 
2764				; TODO copy last user dict word next link to this word 
2764				; TODO update last user dict word to point to this word 
2764			; 
2764			; hl f923 de 812a ; bc 811a 
2764			 
2764			if DEBUG_FORTH_UWORD 
2764 c5			push bc 
2765 ed 4b ee f0	ld bc, (os_new_malloc) 
2769					DMARK ":0A" 
2769 f5				push af  
276a 3a 7e 27			ld a, (.dmark)  
276d 32 a6 fd			ld (debug_mark),a  
2770 3a 7f 27			ld a, (.dmark+1)  
2773 32 a7 fd			ld (debug_mark+1),a  
2776 3a 80 27			ld a, (.dmark+2)  
2779 32 a8 fd			ld (debug_mark+2),a  
277c 18 03			jr .pastdmark  
277e ..			.dmark: db ":0A"  
2781 f1			.pastdmark: pop af  
2782			endm  
# End of macro DMARK
2782			CALLMONITOR 
2782 cd aa fd			call debug_vector  
2785				endm  
# End of macro CALLMONITOR
2785 c1			pop bc 
2786			endif 
2786			if DEBUG_FORTH_UWORD 
2786 c5			push bc 
2787 ed 4b ee f0	ld bc, (os_new_malloc) 
278b 03			inc bc 
278c 03			inc bc 
278d 03			inc bc 
278e 03			inc bc 
278f 03			inc bc 
2790 03			inc bc 
2791 03			inc bc 
2792 03			inc bc 
2793			 
2793					DMARK ":0B" 
2793 f5				push af  
2794 3a a8 27			ld a, (.dmark)  
2797 32 a6 fd			ld (debug_mark),a  
279a 3a a9 27			ld a, (.dmark+1)  
279d 32 a7 fd			ld (debug_mark+1),a  
27a0 3a aa 27			ld a, (.dmark+2)  
27a3 32 a8 fd			ld (debug_mark+2),a  
27a6 18 03			jr .pastdmark  
27a8 ..			.dmark: db ":0B"  
27ab f1			.pastdmark: pop af  
27ac			endm  
# End of macro DMARK
27ac			CALLMONITOR 
27ac cd aa fd			call debug_vector  
27af				endm  
# End of macro CALLMONITOR
27af c1			pop bc 
27b0			endif 
27b0			 
27b0			; update word dict linked list for new word 
27b0			 
27b0			 
27b0 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27b3 23			inc hl     ; move to next work linked list ptr 
27b4			 
27b4 ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
27b8 73			ld (hl), e 
27b9 23			inc hl 
27ba 72			ld (hl), d 
27bb			 
27bb			if DEBUG_FORTH_UWORD 
27bb ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
27bf			endif 
27bf			 
27bf ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
27c3			 
27c3			 
27c3			if DEBUG_FORTH_UWORD 
27c3					DMARK ":0+" 
27c3 f5				push af  
27c4 3a d8 27			ld a, (.dmark)  
27c7 32 a6 fd			ld (debug_mark),a  
27ca 3a d9 27			ld a, (.dmark+1)  
27cd 32 a7 fd			ld (debug_mark+1),a  
27d0 3a da 27			ld a, (.dmark+2)  
27d3 32 a8 fd			ld (debug_mark+2),a  
27d6 18 03			jr .pastdmark  
27d8 ..			.dmark: db ":0+"  
27db f1			.pastdmark: pop af  
27dc			endm  
# End of macro DMARK
27dc			CALLMONITOR 
27dc cd aa fd			call debug_vector  
27df				endm  
# End of macro CALLMONITOR
27df			endif 
27df			 
27df			STACKFRAMECHK OFF $8efe $989f 
27df				if DEBUG_STACK_IMB 
27df					if OFF 
27df						exx 
27df						ld hl, $989f 
27df						pop de   ; $989f 
27df						call cmp16 
27df						jr nz, .spnosame 
27df						ld hl, $8efe 
27df						pop de   ; $8efe 
27df						call cmp16 
27df						jr z, .spfrsame 
27df						.spnosame: call showsperror 
27df						.spfrsame: nop 
27df						exx 
27df					endif 
27df				endif 
27df			endm 
# End of macro STACKFRAMECHK
27df			 
27df c9			ret    ; dont process any remaining parser tokens as they form new word 
27e0			 
27e0			 
27e0			 
27e0			 
27e0			;		NEXT 
27e0			.SCOLN: 
27e0			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
27e0 06			db OPCODE_SCOLN 
27e1 2c 28		dw .DROP 
27e3 02			db 2 
27e4 .. 00		db ";",0           
27e6			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
27e6				if DEBUG_FORTH_WORDS_KEY 
27e6					DMARK "SCN" 
27e6 f5				push af  
27e7 3a fb 27			ld a, (.dmark)  
27ea 32 a6 fd			ld (debug_mark),a  
27ed 3a fc 27			ld a, (.dmark+1)  
27f0 32 a7 fd			ld (debug_mark+1),a  
27f3 3a fd 27			ld a, (.dmark+2)  
27f6 32 a8 fd			ld (debug_mark+2),a  
27f9 18 03			jr .pastdmark  
27fb ..			.dmark: db "SCN"  
27fe f1			.pastdmark: pop af  
27ff			endm  
# End of macro DMARK
27ff					CALLMONITOR 
27ff cd aa fd			call debug_vector  
2802				endm  
# End of macro CALLMONITOR
2802				endif 
2802				FORTH_RSP_TOS 
2802 cd e1 1f			call macro_forth_rsp_tos 
2805				endm 
# End of macro FORTH_RSP_TOS
2805 e5				push hl 
2806				FORTH_RSP_POP 
2806 cd eb 1f			call macro_forth_rsp_pop 
2809				endm 
# End of macro FORTH_RSP_POP
2809 e1				pop hl 
280a			;		ex de,hl 
280a 22 fd f3			ld (os_tok_ptr),hl 
280d			 
280d			if DEBUG_FORTH_UWORD 
280d					DMARK "SCL" 
280d f5				push af  
280e 3a 22 28			ld a, (.dmark)  
2811 32 a6 fd			ld (debug_mark),a  
2814 3a 23 28			ld a, (.dmark+1)  
2817 32 a7 fd			ld (debug_mark+1),a  
281a 3a 24 28			ld a, (.dmark+2)  
281d 32 a8 fd			ld (debug_mark+2),a  
2820 18 03			jr .pastdmark  
2822 ..			.dmark: db "SCL"  
2825 f1			.pastdmark: pop af  
2826			endm  
# End of macro DMARK
2826			CALLMONITOR 
2826 cd aa fd			call debug_vector  
2829				endm  
# End of macro CALLMONITOR
2829			endif 
2829				NEXTW 
2829 c3 d0 23			jp macro_next 
282c				endm 
# End of macro NEXTW
282c			 
282c			.DROP: 
282c			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
282c 1b				db WORD_SYS_CORE+OPCODE_DROP             
282d 57 28			dw .DUP2            
282f 05				db 4 + 1 
2830 .. 00			db "DROP",0              
2835				endm 
# End of macro CWHEAD
2835			; | DROP ( w -- )   drop the TOS item   | DONE 
2835				if DEBUG_FORTH_WORDS_KEY 
2835					DMARK "DRP" 
2835 f5				push af  
2836 3a 4a 28			ld a, (.dmark)  
2839 32 a6 fd			ld (debug_mark),a  
283c 3a 4b 28			ld a, (.dmark+1)  
283f 32 a7 fd			ld (debug_mark+1),a  
2842 3a 4c 28			ld a, (.dmark+2)  
2845 32 a8 fd			ld (debug_mark+2),a  
2848 18 03			jr .pastdmark  
284a ..			.dmark: db "DRP"  
284d f1			.pastdmark: pop af  
284e			endm  
# End of macro DMARK
284e					CALLMONITOR 
284e cd aa fd			call debug_vector  
2851				endm  
# End of macro CALLMONITOR
2851				endif 
2851				FORTH_DSP_POP 
2851 cd d2 22			call macro_forth_dsp_pop 
2854				endm 
# End of macro FORTH_DSP_POP
2854				NEXTW 
2854 c3 d0 23			jp macro_next 
2857				endm 
# End of macro NEXTW
2857			.DUP2: 
2857			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2857 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2858 9c 28			dw .DROP2            
285a 05				db 4 + 1 
285b .. 00			db "2DUP",0              
2860				endm 
# End of macro CWHEAD
2860			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2860				if DEBUG_FORTH_WORDS_KEY 
2860					DMARK "2DU" 
2860 f5				push af  
2861 3a 75 28			ld a, (.dmark)  
2864 32 a6 fd			ld (debug_mark),a  
2867 3a 76 28			ld a, (.dmark+1)  
286a 32 a7 fd			ld (debug_mark+1),a  
286d 3a 77 28			ld a, (.dmark+2)  
2870 32 a8 fd			ld (debug_mark+2),a  
2873 18 03			jr .pastdmark  
2875 ..			.dmark: db "2DU"  
2878 f1			.pastdmark: pop af  
2879			endm  
# End of macro DMARK
2879					CALLMONITOR 
2879 cd aa fd			call debug_vector  
287c				endm  
# End of macro CALLMONITOR
287c				endif 
287c				FORTH_DSP_VALUEHL 
287c cd 1a 22			call macro_dsp_valuehl 
287f				endm 
# End of macro FORTH_DSP_VALUEHL
287f e5				push hl      ; 2 
2880			 
2880				FORTH_DSP_POP 
2880 cd d2 22			call macro_forth_dsp_pop 
2883				endm 
# End of macro FORTH_DSP_POP
2883				 
2883				FORTH_DSP_VALUEHL 
2883 cd 1a 22			call macro_dsp_valuehl 
2886				endm 
# End of macro FORTH_DSP_VALUEHL
2886			;		push hl      ; 1 
2886			 
2886				FORTH_DSP_POP 
2886 cd d2 22			call macro_forth_dsp_pop 
2889				endm 
# End of macro FORTH_DSP_POP
2889			 
2889			;		pop hl       ; 1 
2889 d1				pop de       ; 2 
288a			 
288a cd 23 20			call forth_push_numhl 
288d eb				ex de, hl 
288e cd 23 20			call forth_push_numhl 
2891			 
2891				 
2891 eb				ex de, hl 
2892			 
2892 cd 23 20			call forth_push_numhl 
2895 eb				ex de, hl 
2896 cd 23 20			call forth_push_numhl 
2899			 
2899			 
2899				NEXTW 
2899 c3 d0 23			jp macro_next 
289c				endm 
# End of macro NEXTW
289c			.DROP2: 
289c			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
289c 1d				db WORD_SYS_CORE+OPCODE_DROP2             
289d cb 28			dw .SWAP2            
289f 06				db 5 + 1 
28a0 .. 00			db "2DROP",0              
28a6				endm 
# End of macro CWHEAD
28a6			; | 2DROP ( w w -- )    Double drop | DONE 
28a6				if DEBUG_FORTH_WORDS_KEY 
28a6					DMARK "2DR" 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 a6 fd			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 a7 fd			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 a8 fd			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db "2DR"  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf					CALLMONITOR 
28bf cd aa fd			call debug_vector  
28c2				endm  
# End of macro CALLMONITOR
28c2				endif 
28c2				FORTH_DSP_POP 
28c2 cd d2 22			call macro_forth_dsp_pop 
28c5				endm 
# End of macro FORTH_DSP_POP
28c5				FORTH_DSP_POP 
28c5 cd d2 22			call macro_forth_dsp_pop 
28c8				endm 
# End of macro FORTH_DSP_POP
28c8				NEXTW 
28c8 c3 d0 23			jp macro_next 
28cb				endm 
# End of macro NEXTW
28cb			.SWAP2: 
28cb			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
28cb 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
28cc f4 28			dw .AT            
28ce 06				db 5 + 1 
28cf .. 00			db "2SWAP",0              
28d5				endm 
# End of macro CWHEAD
28d5			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
28d5				if DEBUG_FORTH_WORDS_KEY 
28d5					DMARK "2SW" 
28d5 f5				push af  
28d6 3a ea 28			ld a, (.dmark)  
28d9 32 a6 fd			ld (debug_mark),a  
28dc 3a eb 28			ld a, (.dmark+1)  
28df 32 a7 fd			ld (debug_mark+1),a  
28e2 3a ec 28			ld a, (.dmark+2)  
28e5 32 a8 fd			ld (debug_mark+2),a  
28e8 18 03			jr .pastdmark  
28ea ..			.dmark: db "2SW"  
28ed f1			.pastdmark: pop af  
28ee			endm  
# End of macro DMARK
28ee					CALLMONITOR 
28ee cd aa fd			call debug_vector  
28f1				endm  
# End of macro CALLMONITOR
28f1				endif 
28f1			; TODO Use os stack swap memory 
28f1				NEXTW 
28f1 c3 d0 23			jp macro_next 
28f4				endm 
# End of macro NEXTW
28f4			.AT: 
28f4			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
28f4 1f				db WORD_SYS_CORE+OPCODE_AT             
28f5 26 29			dw .CAT            
28f7 02				db 1 + 1 
28f8 .. 00			db "@",0              
28fa				endm 
# End of macro CWHEAD
28fa			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
28fa			 
28fa				if DEBUG_FORTH_WORDS_KEY 
28fa					DMARK "AT." 
28fa f5				push af  
28fb 3a 0f 29			ld a, (.dmark)  
28fe 32 a6 fd			ld (debug_mark),a  
2901 3a 10 29			ld a, (.dmark+1)  
2904 32 a7 fd			ld (debug_mark+1),a  
2907 3a 11 29			ld a, (.dmark+2)  
290a 32 a8 fd			ld (debug_mark+2),a  
290d 18 03			jr .pastdmark  
290f ..			.dmark: db "AT."  
2912 f1			.pastdmark: pop af  
2913			endm  
# End of macro DMARK
2913					CALLMONITOR 
2913 cd aa fd			call debug_vector  
2916				endm  
# End of macro CALLMONITOR
2916				endif 
2916			.getbyteat:	 
2916				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2916 cd 1a 22			call macro_dsp_valuehl 
2919				endm 
# End of macro FORTH_DSP_VALUEHL
2919				 
2919			;		push hl 
2919			 
2919				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2919 cd d2 22			call macro_forth_dsp_pop 
291c				endm 
# End of macro FORTH_DSP_POP
291c			 
291c			;		pop hl 
291c			 
291c 7e				ld a, (hl) 
291d			 
291d 6f				ld l, a 
291e 26 00			ld h, 0 
2920 cd 23 20			call forth_push_numhl 
2923			 
2923				NEXTW 
2923 c3 d0 23			jp macro_next 
2926				endm 
# End of macro NEXTW
2926			.CAT: 
2926			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2926 20				db WORD_SYS_CORE+OPCODE_CAT             
2927 4f 29			dw .BANG            
2929 03				db 2 + 1 
292a .. 00			db "C@",0              
292d				endm 
# End of macro CWHEAD
292d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
292d				if DEBUG_FORTH_WORDS_KEY 
292d					DMARK "CAA" 
292d f5				push af  
292e 3a 42 29			ld a, (.dmark)  
2931 32 a6 fd			ld (debug_mark),a  
2934 3a 43 29			ld a, (.dmark+1)  
2937 32 a7 fd			ld (debug_mark+1),a  
293a 3a 44 29			ld a, (.dmark+2)  
293d 32 a8 fd			ld (debug_mark+2),a  
2940 18 03			jr .pastdmark  
2942 ..			.dmark: db "CAA"  
2945 f1			.pastdmark: pop af  
2946			endm  
# End of macro DMARK
2946					CALLMONITOR 
2946 cd aa fd			call debug_vector  
2949				endm  
# End of macro CALLMONITOR
2949				endif 
2949 c3 16 29			jp .getbyteat 
294c				NEXTW 
294c c3 d0 23			jp macro_next 
294f				endm 
# End of macro NEXTW
294f			.BANG: 
294f			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
294f 21				db WORD_SYS_CORE+OPCODE_BANG             
2950 85 29			dw .CBANG            
2952 02				db 1 + 1 
2953 .. 00			db "!",0              
2955				endm 
# End of macro CWHEAD
2955			; | ! ( x w -- ) Store x at address w      | DONE 
2955				if DEBUG_FORTH_WORDS_KEY 
2955					DMARK "BNG" 
2955 f5				push af  
2956 3a 6a 29			ld a, (.dmark)  
2959 32 a6 fd			ld (debug_mark),a  
295c 3a 6b 29			ld a, (.dmark+1)  
295f 32 a7 fd			ld (debug_mark+1),a  
2962 3a 6c 29			ld a, (.dmark+2)  
2965 32 a8 fd			ld (debug_mark+2),a  
2968 18 03			jr .pastdmark  
296a ..			.dmark: db "BNG"  
296d f1			.pastdmark: pop af  
296e			endm  
# End of macro DMARK
296e					CALLMONITOR 
296e cd aa fd			call debug_vector  
2971				endm  
# End of macro CALLMONITOR
2971				endif 
2971			 
2971			.storebyteat:		 
2971				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2971 cd 1a 22			call macro_dsp_valuehl 
2974				endm 
# End of macro FORTH_DSP_VALUEHL
2974				 
2974 e5				push hl 
2975			 
2975				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2975 cd d2 22			call macro_forth_dsp_pop 
2978				endm 
# End of macro FORTH_DSP_POP
2978			 
2978				; get byte to poke 
2978			 
2978				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2978 cd 1a 22			call macro_dsp_valuehl 
297b				endm 
# End of macro FORTH_DSP_VALUEHL
297b e5				push hl 
297c			 
297c			 
297c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
297c cd d2 22			call macro_forth_dsp_pop 
297f				endm 
# End of macro FORTH_DSP_POP
297f			 
297f			 
297f d1				pop de 
2980 e1				pop hl 
2981			 
2981 73				ld (hl),e 
2982			 
2982			 
2982				NEXTW 
2982 c3 d0 23			jp macro_next 
2985				endm 
# End of macro NEXTW
2985			.CBANG: 
2985			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2985 22				db WORD_SYS_CORE+OPCODE_CBANG             
2986 ae 29			dw .SCALL            
2988 03				db 2 + 1 
2989 .. 00			db "C!",0              
298c				endm 
# End of macro CWHEAD
298c			; | C!  ( x w -- ) Store x at address w  | DONE 
298c				if DEBUG_FORTH_WORDS_KEY 
298c					DMARK "CBA" 
298c f5				push af  
298d 3a a1 29			ld a, (.dmark)  
2990 32 a6 fd			ld (debug_mark),a  
2993 3a a2 29			ld a, (.dmark+1)  
2996 32 a7 fd			ld (debug_mark+1),a  
2999 3a a3 29			ld a, (.dmark+2)  
299c 32 a8 fd			ld (debug_mark+2),a  
299f 18 03			jr .pastdmark  
29a1 ..			.dmark: db "CBA"  
29a4 f1			.pastdmark: pop af  
29a5			endm  
# End of macro DMARK
29a5					CALLMONITOR 
29a5 cd aa fd			call debug_vector  
29a8				endm  
# End of macro CALLMONITOR
29a8				endif 
29a8 c3 71 29			jp .storebyteat 
29ab				NEXTW 
29ab c3 d0 23			jp macro_next 
29ae				endm 
# End of macro NEXTW
29ae			.SCALL: 
29ae			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
29ae 23				db WORD_SYS_CORE+OPCODE_SCALL             
29af e2 29			dw .DEPTH            
29b1 05				db 4 + 1 
29b2 .. 00			db "CALL",0              
29b7				endm 
# End of macro CWHEAD
29b7			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
29b7				if DEBUG_FORTH_WORDS_KEY 
29b7					DMARK "CLL" 
29b7 f5				push af  
29b8 3a cc 29			ld a, (.dmark)  
29bb 32 a6 fd			ld (debug_mark),a  
29be 3a cd 29			ld a, (.dmark+1)  
29c1 32 a7 fd			ld (debug_mark+1),a  
29c4 3a ce 29			ld a, (.dmark+2)  
29c7 32 a8 fd			ld (debug_mark+2),a  
29ca 18 03			jr .pastdmark  
29cc ..			.dmark: db "CLL"  
29cf f1			.pastdmark: pop af  
29d0			endm  
# End of macro DMARK
29d0					CALLMONITOR 
29d0 cd aa fd			call debug_vector  
29d3				endm  
# End of macro CALLMONITOR
29d3				endif 
29d3			 
29d3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d3 cd 1a 22			call macro_dsp_valuehl 
29d6				endm 
# End of macro FORTH_DSP_VALUEHL
29d6			 
29d6			;		push hl 
29d6			 
29d6				; destroy value TOS 
29d6			 
29d6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d6 cd d2 22			call macro_forth_dsp_pop 
29d9				endm 
# End of macro FORTH_DSP_POP
29d9			 
29d9					 
29d9			;		pop hl 
29d9			 
29d9				; how to do a call with hl???? save SP? 
29d9 cd 74 23			call forth_call_hl 
29dc			 
29dc			 
29dc				; TODO push value back onto stack for another op etc 
29dc			 
29dc cd 23 20			call forth_push_numhl 
29df				NEXTW 
29df c3 d0 23			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			.DEPTH: 
29e2			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
29e2 24				db WORD_SYS_CORE+OPCODE_DEPTH             
29e3 1f 2a			dw .OVER            
29e5 06				db 5 + 1 
29e6 .. 00			db "DEPTH",0              
29ec				endm 
# End of macro CWHEAD
29ec			; | DEPTH ( -- u ) Push count of stack | DONE 
29ec				; take current TOS and remove from base value div by two to get count 
29ec				if DEBUG_FORTH_WORDS_KEY 
29ec					DMARK "DEP" 
29ec f5				push af  
29ed 3a 01 2a			ld a, (.dmark)  
29f0 32 a6 fd			ld (debug_mark),a  
29f3 3a 02 2a			ld a, (.dmark+1)  
29f6 32 a7 fd			ld (debug_mark+1),a  
29f9 3a 03 2a			ld a, (.dmark+2)  
29fc 32 a8 fd			ld (debug_mark+2),a  
29ff 18 03			jr .pastdmark  
2a01 ..			.dmark: db "DEP"  
2a04 f1			.pastdmark: pop af  
2a05			endm  
# End of macro DMARK
2a05					CALLMONITOR 
2a05 cd aa fd			call debug_vector  
2a08				endm  
# End of macro CALLMONITOR
2a08				endif 
2a08			 
2a08			 
2a08 2a 29 f9		ld hl, (cli_data_sp) 
2a0b 11 63 f6		ld de, cli_data_stack 
2a0e ed 52		sbc hl,de 
2a10			 
2a10			; div by size of stack item 
2a10			 
2a10 5d			ld e,l 
2a11 0e 03		ld c, 3 
2a13 cd 5f 0f		call Div8 
2a16			 
2a16 6f			ld l,a 
2a17 26 00		ld h,0 
2a19			 
2a19			;srl h 
2a19			;rr l 
2a19			 
2a19 cd 23 20			call forth_push_numhl 
2a1c				NEXTW 
2a1c c3 d0 23			jp macro_next 
2a1f				endm 
# End of macro NEXTW
2a1f			.OVER: 
2a1f			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a1f 42				db WORD_SYS_CORE+46             
2a20 66 2a			dw .PAUSE            
2a22 05				db 4 + 1 
2a23 .. 00			db "OVER",0              
2a28				endm 
# End of macro CWHEAD
2a28			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a28				if DEBUG_FORTH_WORDS_KEY 
2a28					DMARK "OVR" 
2a28 f5				push af  
2a29 3a 3d 2a			ld a, (.dmark)  
2a2c 32 a6 fd			ld (debug_mark),a  
2a2f 3a 3e 2a			ld a, (.dmark+1)  
2a32 32 a7 fd			ld (debug_mark+1),a  
2a35 3a 3f 2a			ld a, (.dmark+2)  
2a38 32 a8 fd			ld (debug_mark+2),a  
2a3b 18 03			jr .pastdmark  
2a3d ..			.dmark: db "OVR"  
2a40 f1			.pastdmark: pop af  
2a41			endm  
# End of macro DMARK
2a41					CALLMONITOR 
2a41 cd aa fd			call debug_vector  
2a44				endm  
# End of macro CALLMONITOR
2a44				endif 
2a44			 
2a44			; TODO Use os stack swap memory 
2a44				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a44 cd 1a 22			call macro_dsp_valuehl 
2a47				endm 
# End of macro FORTH_DSP_VALUEHL
2a47 e5				push hl    ; n2 
2a48				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a48 cd d2 22			call macro_forth_dsp_pop 
2a4b				endm 
# End of macro FORTH_DSP_POP
2a4b			 
2a4b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a4b cd 1a 22			call macro_dsp_valuehl 
2a4e				endm 
# End of macro FORTH_DSP_VALUEHL
2a4e e5				push hl    ; n1 
2a4f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a4f cd d2 22			call macro_forth_dsp_pop 
2a52				endm 
# End of macro FORTH_DSP_POP
2a52			 
2a52 d1				pop de     ; n1 
2a53 e1				pop hl     ; n2 
2a54			 
2a54 d5				push de 
2a55 e5				push hl 
2a56 d5				push de 
2a57			 
2a57				; push back  
2a57			 
2a57 e1				pop hl 
2a58 cd 23 20			call forth_push_numhl 
2a5b e1				pop hl 
2a5c cd 23 20			call forth_push_numhl 
2a5f e1				pop hl 
2a60 cd 23 20			call forth_push_numhl 
2a63				NEXTW 
2a63 c3 d0 23			jp macro_next 
2a66				endm 
# End of macro NEXTW
2a66			 
2a66			.PAUSE: 
2a66			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2a66 43				db WORD_SYS_CORE+47             
2a67 9b 2a			dw .PAUSES            
2a69 08				db 7 + 1 
2a6a .. 00			db "PAUSEMS",0              
2a72				endm 
# End of macro CWHEAD
2a72			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2a72				if DEBUG_FORTH_WORDS_KEY 
2a72					DMARK "PMS" 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 a6 fd			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 a7 fd			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 a8 fd			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "PMS"  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b					CALLMONITOR 
2a8b cd aa fd			call debug_vector  
2a8e				endm  
# End of macro CALLMONITOR
2a8e				endif 
2a8e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a8e cd 1a 22			call macro_dsp_valuehl 
2a91				endm 
# End of macro FORTH_DSP_VALUEHL
2a91			;		push hl    ; n2 
2a91				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a91 cd d2 22			call macro_forth_dsp_pop 
2a94				endm 
# End of macro FORTH_DSP_POP
2a94			;		pop hl 
2a94			 
2a94 7d				ld a, l 
2a95 cd c3 0c			call aDelayInMS 
2a98			       NEXTW 
2a98 c3 d0 23			jp macro_next 
2a9b				endm 
# End of macro NEXTW
2a9b			.PAUSES:  
2a9b			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2a9b 44				db WORD_SYS_CORE+48             
2a9c 0a 2b			dw .ROT            
2a9e 06				db 5 + 1 
2a9f .. 00			db "PAUSE",0              
2aa5				endm 
# End of macro CWHEAD
2aa5			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2aa5				if DEBUG_FORTH_WORDS_KEY 
2aa5					DMARK "PAU" 
2aa5 f5				push af  
2aa6 3a ba 2a			ld a, (.dmark)  
2aa9 32 a6 fd			ld (debug_mark),a  
2aac 3a bb 2a			ld a, (.dmark+1)  
2aaf 32 a7 fd			ld (debug_mark+1),a  
2ab2 3a bc 2a			ld a, (.dmark+2)  
2ab5 32 a8 fd			ld (debug_mark+2),a  
2ab8 18 03			jr .pastdmark  
2aba ..			.dmark: db "PAU"  
2abd f1			.pastdmark: pop af  
2abe			endm  
# End of macro DMARK
2abe					CALLMONITOR 
2abe cd aa fd			call debug_vector  
2ac1				endm  
# End of macro CALLMONITOR
2ac1				endif 
2ac1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac1 cd 1a 22			call macro_dsp_valuehl 
2ac4				endm 
# End of macro FORTH_DSP_VALUEHL
2ac4			;		push hl    ; n2 
2ac4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ac4 cd d2 22			call macro_forth_dsp_pop 
2ac7				endm 
# End of macro FORTH_DSP_POP
2ac7			;		pop hl 
2ac7 45				ld b, l 
2ac8				if DEBUG_FORTH_WORDS 
2ac8					DMARK "PAU" 
2ac8 f5				push af  
2ac9 3a dd 2a			ld a, (.dmark)  
2acc 32 a6 fd			ld (debug_mark),a  
2acf 3a de 2a			ld a, (.dmark+1)  
2ad2 32 a7 fd			ld (debug_mark+1),a  
2ad5 3a df 2a			ld a, (.dmark+2)  
2ad8 32 a8 fd			ld (debug_mark+2),a  
2adb 18 03			jr .pastdmark  
2add ..			.dmark: db "PAU"  
2ae0 f1			.pastdmark: pop af  
2ae1			endm  
# End of macro DMARK
2ae1					CALLMONITOR 
2ae1 cd aa fd			call debug_vector  
2ae4				endm  
# End of macro CALLMONITOR
2ae4				endif 
2ae4 c5			.pauses1:	push bc 
2ae5 cd de 0c			call delay1s 
2ae8 c1				pop bc 
2ae9				if DEBUG_FORTH_WORDS 
2ae9					DMARK "PA1" 
2ae9 f5				push af  
2aea 3a fe 2a			ld a, (.dmark)  
2aed 32 a6 fd			ld (debug_mark),a  
2af0 3a ff 2a			ld a, (.dmark+1)  
2af3 32 a7 fd			ld (debug_mark+1),a  
2af6 3a 00 2b			ld a, (.dmark+2)  
2af9 32 a8 fd			ld (debug_mark+2),a  
2afc 18 03			jr .pastdmark  
2afe ..			.dmark: db "PA1"  
2b01 f1			.pastdmark: pop af  
2b02			endm  
# End of macro DMARK
2b02					CALLMONITOR 
2b02 cd aa fd			call debug_vector  
2b05				endm  
# End of macro CALLMONITOR
2b05				endif 
2b05 10 dd			djnz .pauses1 
2b07			 
2b07			       NEXTW 
2b07 c3 d0 23			jp macro_next 
2b0a				endm 
# End of macro NEXTW
2b0a			.ROT: 
2b0a			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b0a 45				db WORD_SYS_CORE+49             
2b0b 58 2b			dw .UWORDS            
2b0d 04				db 3 + 1 
2b0e .. 00			db "ROT",0              
2b12				endm 
# End of macro CWHEAD
2b12			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b12				if DEBUG_FORTH_WORDS_KEY 
2b12					DMARK "ROT" 
2b12 f5				push af  
2b13 3a 27 2b			ld a, (.dmark)  
2b16 32 a6 fd			ld (debug_mark),a  
2b19 3a 28 2b			ld a, (.dmark+1)  
2b1c 32 a7 fd			ld (debug_mark+1),a  
2b1f 3a 29 2b			ld a, (.dmark+2)  
2b22 32 a8 fd			ld (debug_mark+2),a  
2b25 18 03			jr .pastdmark  
2b27 ..			.dmark: db "ROT"  
2b2a f1			.pastdmark: pop af  
2b2b			endm  
# End of macro DMARK
2b2b					CALLMONITOR 
2b2b cd aa fd			call debug_vector  
2b2e				endm  
# End of macro CALLMONITOR
2b2e				endif 
2b2e			 
2b2e			; TODO Use os stack swap memory 
2b2e				FORTH_DSP_VALUEHL 
2b2e cd 1a 22			call macro_dsp_valuehl 
2b31				endm 
# End of macro FORTH_DSP_VALUEHL
2b31 e5				push hl    ; u3  
2b32			 
2b32				FORTH_DSP_POP 
2b32 cd d2 22			call macro_forth_dsp_pop 
2b35				endm 
# End of macro FORTH_DSP_POP
2b35			 
2b35				FORTH_DSP_VALUEHL 
2b35 cd 1a 22			call macro_dsp_valuehl 
2b38				endm 
# End of macro FORTH_DSP_VALUEHL
2b38 e5				push hl     ; u2 
2b39			 
2b39				FORTH_DSP_POP 
2b39 cd d2 22			call macro_forth_dsp_pop 
2b3c				endm 
# End of macro FORTH_DSP_POP
2b3c			 
2b3c				FORTH_DSP_VALUEHL 
2b3c cd 1a 22			call macro_dsp_valuehl 
2b3f				endm 
# End of macro FORTH_DSP_VALUEHL
2b3f e5				push hl     ; u1 
2b40			 
2b40				FORTH_DSP_POP 
2b40 cd d2 22			call macro_forth_dsp_pop 
2b43				endm 
# End of macro FORTH_DSP_POP
2b43			 
2b43 c1				pop bc      ; u1 
2b44 e1				pop hl      ; u2 
2b45 d1				pop de      ; u3 
2b46			 
2b46			 
2b46 c5				push bc 
2b47 d5				push de 
2b48 e5				push hl 
2b49			 
2b49			 
2b49 e1				pop hl 
2b4a cd 23 20			call forth_push_numhl 
2b4d			 
2b4d e1				pop hl 
2b4e cd 23 20			call forth_push_numhl 
2b51			 
2b51 e1				pop hl 
2b52 cd 23 20			call forth_push_numhl 
2b55				 
2b55			 
2b55			 
2b55			 
2b55			 
2b55			 
2b55			       NEXTW 
2b55 c3 d0 23			jp macro_next 
2b58				endm 
# End of macro NEXTW
2b58			 
2b58			.UWORDS: 
2b58			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2b58 50				db WORD_SYS_CORE+60             
2b59 1a 2c			dw .BP            
2b5b 07				db 6 + 1 
2b5c .. 00			db "UWORDS",0              
2b63				endm 
# End of macro CWHEAD
2b63			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2b63			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2b63			; | | Following the count are the individual words. 
2b63			; | | 
2b63			; | | e.g. UWORDS 
2b63			; | | BOX DIRLIST 2 
2b63			; | |  
2b63			; | | Can be used to save the words to storage via: 
2b63			; | | UWORDS $01 DO $01 APPEND LOOP 
2b63			if DEBUG_FORTH_WORDS_KEY 
2b63				DMARK "UWR" 
2b63 f5				push af  
2b64 3a 78 2b			ld a, (.dmark)  
2b67 32 a6 fd			ld (debug_mark),a  
2b6a 3a 79 2b			ld a, (.dmark+1)  
2b6d 32 a7 fd			ld (debug_mark+1),a  
2b70 3a 7a 2b			ld a, (.dmark+2)  
2b73 32 a8 fd			ld (debug_mark+2),a  
2b76 18 03			jr .pastdmark  
2b78 ..			.dmark: db "UWR"  
2b7b f1			.pastdmark: pop af  
2b7c			endm  
# End of macro DMARK
2b7c				CALLMONITOR 
2b7c cd aa fd			call debug_vector  
2b7f				endm  
# End of macro CALLMONITOR
2b7f			endif 
2b7f 21 00 80			ld hl, baseram 
2b82				;ld hl, baseusermem 
2b82 01 00 00			ld bc, 0    ; start a counter 
2b85			 
2b85			; skip dict stub 
2b85			 
2b85 cd 21 25			call forth_tok_next 
2b88			 
2b88			 
2b88			; while we have words to look for 
2b88			 
2b88 7e			.douscan:	ld a, (hl)      
2b89			if DEBUG_FORTH_WORDS 
2b89				DMARK "UWs" 
2b89 f5				push af  
2b8a 3a 9e 2b			ld a, (.dmark)  
2b8d 32 a6 fd			ld (debug_mark),a  
2b90 3a 9f 2b			ld a, (.dmark+1)  
2b93 32 a7 fd			ld (debug_mark+1),a  
2b96 3a a0 2b			ld a, (.dmark+2)  
2b99 32 a8 fd			ld (debug_mark+2),a  
2b9c 18 03			jr .pastdmark  
2b9e ..			.dmark: db "UWs"  
2ba1 f1			.pastdmark: pop af  
2ba2			endm  
# End of macro DMARK
2ba2				CALLMONITOR 
2ba2 cd aa fd			call debug_vector  
2ba5				endm  
# End of macro CALLMONITOR
2ba5			endif 
2ba5 fe 00			cp WORD_SYS_END 
2ba7 28 4d			jr z, .udone 
2ba9 fe 01			cp WORD_SYS_UWORD 
2bab 20 44			jr nz, .nuword 
2bad			 
2bad			if DEBUG_FORTH_WORDS 
2bad				DMARK "UWu" 
2bad f5				push af  
2bae 3a c2 2b			ld a, (.dmark)  
2bb1 32 a6 fd			ld (debug_mark),a  
2bb4 3a c3 2b			ld a, (.dmark+1)  
2bb7 32 a7 fd			ld (debug_mark+1),a  
2bba 3a c4 2b			ld a, (.dmark+2)  
2bbd 32 a8 fd			ld (debug_mark+2),a  
2bc0 18 03			jr .pastdmark  
2bc2 ..			.dmark: db "UWu"  
2bc5 f1			.pastdmark: pop af  
2bc6			endm  
# End of macro DMARK
2bc6				CALLMONITOR 
2bc6 cd aa fd			call debug_vector  
2bc9				endm  
# End of macro CALLMONITOR
2bc9			endif 
2bc9				; we have a uword so push its name to the stack 
2bc9			 
2bc9 e5				push hl  ; save so we can move to next dict block 
2bca			 
2bca				; skip opcode 
2bca 23				inc hl  
2bcb				; skip next ptr 
2bcb 23				inc hl  
2bcc 23				inc hl 
2bcd				; skip len 
2bcd 23				inc hl 
2bce			if DEBUG_FORTH_WORDS 
2bce				DMARK "UWt" 
2bce f5				push af  
2bcf 3a e3 2b			ld a, (.dmark)  
2bd2 32 a6 fd			ld (debug_mark),a  
2bd5 3a e4 2b			ld a, (.dmark+1)  
2bd8 32 a7 fd			ld (debug_mark+1),a  
2bdb 3a e5 2b			ld a, (.dmark+2)  
2bde 32 a8 fd			ld (debug_mark+2),a  
2be1 18 03			jr .pastdmark  
2be3 ..			.dmark: db "UWt"  
2be6 f1			.pastdmark: pop af  
2be7			endm  
# End of macro DMARK
2be7				CALLMONITOR 
2be7 cd aa fd			call debug_vector  
2bea				endm  
# End of macro CALLMONITOR
2bea			endif 
2bea 03				inc bc 
2beb			 
2beb c5				push bc 
2bec cd 91 20			call forth_push_str 
2bef c1				pop bc 
2bf0			 
2bf0 e1				pop hl 	 
2bf1			 
2bf1 cd 21 25		.nuword:	call forth_tok_next 
2bf4 18 92			jr .douscan  
2bf6			 
2bf6			.udone:		 ; push count of uwords found 
2bf6 c5				push bc 
2bf7 e1				pop hl 
2bf8			 
2bf8			if DEBUG_FORTH_WORDS 
2bf8				DMARK "UWc" 
2bf8 f5				push af  
2bf9 3a 0d 2c			ld a, (.dmark)  
2bfc 32 a6 fd			ld (debug_mark),a  
2bff 3a 0e 2c			ld a, (.dmark+1)  
2c02 32 a7 fd			ld (debug_mark+1),a  
2c05 3a 0f 2c			ld a, (.dmark+2)  
2c08 32 a8 fd			ld (debug_mark+2),a  
2c0b 18 03			jr .pastdmark  
2c0d ..			.dmark: db "UWc"  
2c10 f1			.pastdmark: pop af  
2c11			endm  
# End of macro DMARK
2c11				CALLMONITOR 
2c11 cd aa fd			call debug_vector  
2c14				endm  
# End of macro CALLMONITOR
2c14			endif 
2c14 cd 23 20			call forth_push_numhl 
2c17			 
2c17			 
2c17			       NEXTW 
2c17 c3 d0 23			jp macro_next 
2c1a				endm 
# End of macro NEXTW
2c1a			 
2c1a			.BP: 
2c1a			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c1a 54				db WORD_SYS_CORE+64             
2c1b 54 2c			dw .MONITOR            
2c1d 03				db 2 + 1 
2c1e .. 00			db "BP",0              
2c21				endm 
# End of macro CWHEAD
2c21			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c21			; | | $00 Will enable the break points within specific code paths 
2c21			; | | $01 Will disable break points 
2c21			; | |  
2c21			; | | By default break points are off. Either the above can be used to enable them 
2c21			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c21			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2c21			; | | can disable break points. Exiting will then continue boot process. 
2c21				; get byte count 
2c21				if DEBUG_FORTH_WORDS_KEY 
2c21					DMARK "BP." 
2c21 f5				push af  
2c22 3a 36 2c			ld a, (.dmark)  
2c25 32 a6 fd			ld (debug_mark),a  
2c28 3a 37 2c			ld a, (.dmark+1)  
2c2b 32 a7 fd			ld (debug_mark+1),a  
2c2e 3a 38 2c			ld a, (.dmark+2)  
2c31 32 a8 fd			ld (debug_mark+2),a  
2c34 18 03			jr .pastdmark  
2c36 ..			.dmark: db "BP."  
2c39 f1			.pastdmark: pop af  
2c3a			endm  
# End of macro DMARK
2c3a					CALLMONITOR 
2c3a cd aa fd			call debug_vector  
2c3d				endm  
# End of macro CALLMONITOR
2c3d				endif 
2c3d			 
2c3d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c3d cd 1a 22			call macro_dsp_valuehl 
2c40				endm 
# End of macro FORTH_DSP_VALUEHL
2c40			 
2c40			;		push hl 
2c40			 
2c40				; destroy value TOS 
2c40			 
2c40				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c40 cd d2 22			call macro_forth_dsp_pop 
2c43				endm 
# End of macro FORTH_DSP_POP
2c43			 
2c43			;		pop hl 
2c43			 
2c43 3e 00			ld a,0 
2c45 bd				cp l 
2c46 28 06			jr z, .bpset 
2c48			;		ld a, '*' 
2c48 cd 44 19			call bp_off 
2c4b				NEXTW 
2c4b c3 d0 23			jp macro_next 
2c4e				endm 
# End of macro NEXTW
2c4e			 
2c4e			.bpset:	 
2c4e				;	ld (os_view_disable), a 
2c4e cd 38 19			call bp_on 
2c51			 
2c51			 
2c51				NEXTW 
2c51 c3 d0 23			jp macro_next 
2c54				endm 
# End of macro NEXTW
2c54			 
2c54			 
2c54			.MONITOR: 
2c54			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2c54 55				db WORD_SYS_CORE+65             
2c55 85 2c			dw .MALLOC            
2c57 08				db 7 + 1 
2c58 .. 00			db "MONITOR",0              
2c60				endm 
# End of macro CWHEAD
2c60			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2c60			; | | At start the current various registers will be displayed with contents. 
2c60			; | | Top right corner will show the most recent debug marker seen. 
2c60			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2c60			; | | and the return stack pointer (RSP). 
2c60			; | | Pressing: 
2c60			; | |    1 - Initial screen 
2c60			; | |    2 - Display a data dump of HL 
2c60			; | |    3 - Display a data dump of DE 
2c60			; | |    4 - Display a data dump of BC 
2c60			; | |    5 - Display a data dump of HL 
2c60			; | |    6 - Display a data dump of DSP 
2c60			; | |    7 - Display a data dump of RSP 
2c60			; | |    8 - Display a data dump of what is at DSP 
2c60			; | |    9 - Display a data dump of what is at RSP 
2c60			; | |    0 - Exit monitor and continue running. This will also enable break points 
2c60			; | |    * - Disable break points 
2c60			; | |    # - Enter traditional monitor mode 
2c60			; | | 
2c60			; | | Monitor Mode 
2c60			; | | ------------ 
2c60			; | | A prompt of '>' will be shown for various commands: 
2c60			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2c60			; | |    C - Continue display a data dump from the last set address 
2c60			; | |    M xxxx - Set start of memory edit at address xx 
2c60			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2c60			; | |    G xxxx - Exec code at specific address 
2c60			; | |    Q - Return to previous 
2c60				if DEBUG_FORTH_WORDS_KEY 
2c60					DMARK "MON" 
2c60 f5				push af  
2c61 3a 75 2c			ld a, (.dmark)  
2c64 32 a6 fd			ld (debug_mark),a  
2c67 3a 76 2c			ld a, (.dmark+1)  
2c6a 32 a7 fd			ld (debug_mark+1),a  
2c6d 3a 77 2c			ld a, (.dmark+2)  
2c70 32 a8 fd			ld (debug_mark+2),a  
2c73 18 03			jr .pastdmark  
2c75 ..			.dmark: db "MON"  
2c78 f1			.pastdmark: pop af  
2c79			endm  
# End of macro DMARK
2c79					CALLMONITOR 
2c79 cd aa fd			call debug_vector  
2c7c				endm  
# End of macro CALLMONITOR
2c7c				endif 
2c7c			;		ld a, 0 
2c7c			;		ld (os_view_disable), a 
2c7c cd 38 19			call bp_on 
2c7f			 
2c7f				CALLMONITOR 
2c7f cd aa fd			call debug_vector  
2c82				endm  
# End of macro CALLMONITOR
2c82			 
2c82			;	call monitor 
2c82			 
2c82				NEXTW 
2c82 c3 d0 23			jp macro_next 
2c85				endm 
# End of macro NEXTW
2c85			 
2c85			 
2c85			.MALLOC: 
2c85			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2c85 56				db WORD_SYS_CORE+66             
2c86 ae 2c			dw .MALLOC2            
2c88 06				db 5 + 1 
2c89 .. 00			db "ALLOT",0              
2c8f				endm 
# End of macro CWHEAD
2c8f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2c8f				if DEBUG_FORTH_WORDS_KEY 
2c8f					DMARK "ALL" 
2c8f f5				push af  
2c90 3a a4 2c			ld a, (.dmark)  
2c93 32 a6 fd			ld (debug_mark),a  
2c96 3a a5 2c			ld a, (.dmark+1)  
2c99 32 a7 fd			ld (debug_mark+1),a  
2c9c 3a a6 2c			ld a, (.dmark+2)  
2c9f 32 a8 fd			ld (debug_mark+2),a  
2ca2 18 03			jr .pastdmark  
2ca4 ..			.dmark: db "ALL"  
2ca7 f1			.pastdmark: pop af  
2ca8			endm  
# End of macro DMARK
2ca8					CALLMONITOR 
2ca8 cd aa fd			call debug_vector  
2cab				endm  
# End of macro CALLMONITOR
2cab				endif 
2cab c3 d5 2c			jp .mallocc 
2cae			.MALLOC2: 
2cae			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2cae 56				db WORD_SYS_CORE+66             
2caf ec 2c			dw .FREE            
2cb1 07				db 6 + 1 
2cb2 .. 00			db "MALLOC",0              
2cb9				endm 
# End of macro CWHEAD
2cb9			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cb9				; get byte count 
2cb9				if DEBUG_FORTH_WORDS_KEY 
2cb9					DMARK "MAL" 
2cb9 f5				push af  
2cba 3a ce 2c			ld a, (.dmark)  
2cbd 32 a6 fd			ld (debug_mark),a  
2cc0 3a cf 2c			ld a, (.dmark+1)  
2cc3 32 a7 fd			ld (debug_mark+1),a  
2cc6 3a d0 2c			ld a, (.dmark+2)  
2cc9 32 a8 fd			ld (debug_mark+2),a  
2ccc 18 03			jr .pastdmark  
2cce ..			.dmark: db "MAL"  
2cd1 f1			.pastdmark: pop af  
2cd2			endm  
# End of macro DMARK
2cd2					CALLMONITOR 
2cd2 cd aa fd			call debug_vector  
2cd5				endm  
# End of macro CALLMONITOR
2cd5				endif 
2cd5			.mallocc: 
2cd5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cd5 cd 1a 22			call macro_dsp_valuehl 
2cd8				endm 
# End of macro FORTH_DSP_VALUEHL
2cd8			 
2cd8			;		push hl 
2cd8			 
2cd8				; destroy value TOS 
2cd8			 
2cd8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cd8 cd d2 22			call macro_forth_dsp_pop 
2cdb				endm 
# End of macro FORTH_DSP_POP
2cdb			 
2cdb			;		pop hl 
2cdb cd aa 13			call malloc 
2cde			if DEBUG_FORTH_MALLOC_GUARD 
2cde f5				push af 
2cdf cd f8 0f			call ishlzero 
2ce2			;		ld a, l 
2ce2			;		add h 
2ce2			;		cp 0 
2ce2 f1				pop af 
2ce3				 
2ce3 cc a3 5d			call z,malloc_error 
2ce6			endif 
2ce6			 
2ce6 cd 23 20			call forth_push_numhl 
2ce9				NEXTW 
2ce9 c3 d0 23			jp macro_next 
2cec				endm 
# End of macro NEXTW
2cec			 
2cec			.FREE: 
2cec			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2cec 57				db WORD_SYS_CORE+67             
2ced 1d 2d			dw .LIST            
2cef 05				db 4 + 1 
2cf0 .. 00			db "FREE",0              
2cf5				endm 
# End of macro CWHEAD
2cf5			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2cf5				if DEBUG_FORTH_WORDS_KEY 
2cf5					DMARK "FRE" 
2cf5 f5				push af  
2cf6 3a 0a 2d			ld a, (.dmark)  
2cf9 32 a6 fd			ld (debug_mark),a  
2cfc 3a 0b 2d			ld a, (.dmark+1)  
2cff 32 a7 fd			ld (debug_mark+1),a  
2d02 3a 0c 2d			ld a, (.dmark+2)  
2d05 32 a8 fd			ld (debug_mark+2),a  
2d08 18 03			jr .pastdmark  
2d0a ..			.dmark: db "FRE"  
2d0d f1			.pastdmark: pop af  
2d0e			endm  
# End of macro DMARK
2d0e					CALLMONITOR 
2d0e cd aa fd			call debug_vector  
2d11				endm  
# End of macro CALLMONITOR
2d11				endif 
2d11				; get address 
2d11			 
2d11				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d11 cd 1a 22			call macro_dsp_valuehl 
2d14				endm 
# End of macro FORTH_DSP_VALUEHL
2d14			 
2d14			;		push hl 
2d14			 
2d14				; destroy value TOS 
2d14			 
2d14				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d14 cd d2 22			call macro_forth_dsp_pop 
2d17				endm 
# End of macro FORTH_DSP_POP
2d17			 
2d17			;		pop hl 
2d17			if FORTH_ENABLE_MALLOCFREE 
2d17 cd 74 14			call free 
2d1a			endif 
2d1a				NEXTW 
2d1a c3 d0 23			jp macro_next 
2d1d				endm 
# End of macro NEXTW
2d1d			.LIST: 
2d1d			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d1d 5c				db WORD_SYS_CORE+72             
2d1e 0d 2f			dw .FORGET            
2d20 05				db 4 + 1 
2d21 .. 00			db "LIST",0              
2d26				endm 
# End of macro CWHEAD
2d26			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d26			; | | The quoted word must be in upper case. 
2d26			if DEBUG_FORTH_WORDS_KEY 
2d26				DMARK "LST" 
2d26 f5				push af  
2d27 3a 3b 2d			ld a, (.dmark)  
2d2a 32 a6 fd			ld (debug_mark),a  
2d2d 3a 3c 2d			ld a, (.dmark+1)  
2d30 32 a7 fd			ld (debug_mark+1),a  
2d33 3a 3d 2d			ld a, (.dmark+2)  
2d36 32 a8 fd			ld (debug_mark+2),a  
2d39 18 03			jr .pastdmark  
2d3b ..			.dmark: db "LST"  
2d3e f1			.pastdmark: pop af  
2d3f			endm  
# End of macro DMARK
2d3f				CALLMONITOR 
2d3f cd aa fd			call debug_vector  
2d42				endm  
# End of macro CALLMONITOR
2d42			endif 
2d42			 
2d42				FORTH_DSP_VALUEHL 
2d42 cd 1a 22			call macro_dsp_valuehl 
2d45				endm 
# End of macro FORTH_DSP_VALUEHL
2d45			 
2d45 e5				push hl 
2d46				FORTH_DSP_POP 
2d46 cd d2 22			call macro_forth_dsp_pop 
2d49				endm 
# End of macro FORTH_DSP_POP
2d49 c1				pop bc 
2d4a			 
2d4a			; Start format of scratch string 
2d4a			 
2d4a 21 fc f0			ld hl, scratch 
2d4d			 
2d4d 3e 3a			ld a, ':' 
2d4f 77				ld (hl),a 
2d50 23				inc hl 
2d51 3e 20			ld a, ' ' 
2d53 77				ld (hl), a 
2d54			 
2d54				; Get ptr to the word we need to look up 
2d54			 
2d54			;		FORTH_DSP_VALUEHL 
2d54				;v5 FORTH_DSP_VALUE 
2d54			; TODO type check 
2d54			;		inc hl    ; Skip type check  
2d54			;		push hl 
2d54			;		ex de, hl    ; put into DE 
2d54			 
2d54			 
2d54 21 00 80			ld hl, baseram 
2d57				;ld hl, baseusermem 
2d57			 
2d57 e5			push hl   ; sacreifical push 
2d58			 
2d58			.ldouscanm: 
2d58 e1			pop hl 
2d59			.ldouscan: 
2d59			if DEBUG_FORTH_WORDS 
2d59				DMARK "LSs" 
2d59 f5				push af  
2d5a 3a 6e 2d			ld a, (.dmark)  
2d5d 32 a6 fd			ld (debug_mark),a  
2d60 3a 6f 2d			ld a, (.dmark+1)  
2d63 32 a7 fd			ld (debug_mark+1),a  
2d66 3a 70 2d			ld a, (.dmark+2)  
2d69 32 a8 fd			ld (debug_mark+2),a  
2d6c 18 03			jr .pastdmark  
2d6e ..			.dmark: db "LSs"  
2d71 f1			.pastdmark: pop af  
2d72			endm  
# End of macro DMARK
2d72				CALLMONITOR 
2d72 cd aa fd			call debug_vector  
2d75				endm  
# End of macro CALLMONITOR
2d75			endif 
2d75			; skip dict stub 
2d75 cd 21 25			call forth_tok_next 
2d78			 
2d78			 
2d78			; while we have words to look for 
2d78			 
2d78 7e			ld a, (hl)      
2d79			if DEBUG_FORTH_WORDS 
2d79				DMARK "LSk" 
2d79 f5				push af  
2d7a 3a 8e 2d			ld a, (.dmark)  
2d7d 32 a6 fd			ld (debug_mark),a  
2d80 3a 8f 2d			ld a, (.dmark+1)  
2d83 32 a7 fd			ld (debug_mark+1),a  
2d86 3a 90 2d			ld a, (.dmark+2)  
2d89 32 a8 fd			ld (debug_mark+2),a  
2d8c 18 03			jr .pastdmark  
2d8e ..			.dmark: db "LSk"  
2d91 f1			.pastdmark: pop af  
2d92			endm  
# End of macro DMARK
2d92				CALLMONITOR 
2d92 cd aa fd			call debug_vector  
2d95				endm  
# End of macro CALLMONITOR
2d95			endif 
2d95				;cp WORD_SYS_END 
2d95				;jp z, .lunotfound 
2d95			 
2d95					; if we hit non uwords then gone too far 
2d95 fe 01				cp WORD_SYS_UWORD 
2d97 c2 c9 2e				jp nz, .lunotfound 
2d9a			 
2d9a				if DEBUG_FORTH_WORDS 
2d9a					DMARK "LSu" 
2d9a f5				push af  
2d9b 3a af 2d			ld a, (.dmark)  
2d9e 32 a6 fd			ld (debug_mark),a  
2da1 3a b0 2d			ld a, (.dmark+1)  
2da4 32 a7 fd			ld (debug_mark+1),a  
2da7 3a b1 2d			ld a, (.dmark+2)  
2daa 32 a8 fd			ld (debug_mark+2),a  
2dad 18 03			jr .pastdmark  
2daf ..			.dmark: db "LSu"  
2db2 f1			.pastdmark: pop af  
2db3			endm  
# End of macro DMARK
2db3					CALLMONITOR 
2db3 cd aa fd			call debug_vector  
2db6				endm  
# End of macro CALLMONITOR
2db6				endif 
2db6			 
2db6					; found a uword but is it the one we want... 
2db6			 
2db6 c5					push bc     ; uword to find is on bc 
2db7 d1					pop de 
2db8			 
2db8 e5					push hl  ; to save the ptr 
2db9			 
2db9					; skip opcode 
2db9 23					inc hl  
2dba					; skip next ptr 
2dba 23					inc hl  
2dbb 23					inc hl 
2dbc					; skip len 
2dbc 23					inc hl 
2dbd			 
2dbd				if DEBUG_FORTH_WORDS 
2dbd					DMARK "LSc" 
2dbd f5				push af  
2dbe 3a d2 2d			ld a, (.dmark)  
2dc1 32 a6 fd			ld (debug_mark),a  
2dc4 3a d3 2d			ld a, (.dmark+1)  
2dc7 32 a7 fd			ld (debug_mark+1),a  
2dca 3a d4 2d			ld a, (.dmark+2)  
2dcd 32 a8 fd			ld (debug_mark+2),a  
2dd0 18 03			jr .pastdmark  
2dd2 ..			.dmark: db "LSc"  
2dd5 f1			.pastdmark: pop af  
2dd6			endm  
# End of macro DMARK
2dd6					CALLMONITOR 
2dd6 cd aa fd			call debug_vector  
2dd9				endm  
# End of macro CALLMONITOR
2dd9				endif 
2dd9			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2dd9			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2dd9			; Nope that has gone the other way. It needs to be exact not on first zero 
2dd9			;		call strcmp 
2dd9 c5					push bc 
2dda cd 7a 13				call StrictStrCmp 
2ddd c1					pop bc 
2dde c2 58 2d				jp nz, .ldouscanm 
2de1				 
2de1			 
2de1			 
2de1					; we have a uword so push its name to the stack 
2de1			 
2de1			;	   	push hl  ; save so we can move to next dict block 
2de1 e1			pop hl 
2de2			 
2de2				if DEBUG_FORTH_WORDS 
2de2					DMARK "LSm" 
2de2 f5				push af  
2de3 3a f7 2d			ld a, (.dmark)  
2de6 32 a6 fd			ld (debug_mark),a  
2de9 3a f8 2d			ld a, (.dmark+1)  
2dec 32 a7 fd			ld (debug_mark+1),a  
2def 3a f9 2d			ld a, (.dmark+2)  
2df2 32 a8 fd			ld (debug_mark+2),a  
2df5 18 03			jr .pastdmark  
2df7 ..			.dmark: db "LSm"  
2dfa f1			.pastdmark: pop af  
2dfb			endm  
# End of macro DMARK
2dfb					CALLMONITOR 
2dfb cd aa fd			call debug_vector  
2dfe				endm  
# End of macro CALLMONITOR
2dfe				endif 
2dfe			 
2dfe					; skip opcode 
2dfe 23					inc hl  
2dff					; skip next ptr 
2dff 23					inc hl  
2e00 23					inc hl 
2e01					; skip len 
2e01 7e					ld a, (hl)   ; save length to add 
2e02				if DEBUG_FORTH_WORDS 
2e02					DMARK "LS2" 
2e02 f5				push af  
2e03 3a 17 2e			ld a, (.dmark)  
2e06 32 a6 fd			ld (debug_mark),a  
2e09 3a 18 2e			ld a, (.dmark+1)  
2e0c 32 a7 fd			ld (debug_mark+1),a  
2e0f 3a 19 2e			ld a, (.dmark+2)  
2e12 32 a8 fd			ld (debug_mark+2),a  
2e15 18 03			jr .pastdmark  
2e17 ..			.dmark: db "LS2"  
2e1a f1			.pastdmark: pop af  
2e1b			endm  
# End of macro DMARK
2e1b					CALLMONITOR 
2e1b cd aa fd			call debug_vector  
2e1e				endm  
# End of macro CALLMONITOR
2e1e				endif 
2e1e			 
2e1e					; save this location 
2e1e				 
2e1e e5					push hl 
2e1f			 
2e1f 23					inc hl 
2e20 11 fe f0				ld de, scratch+2 
2e23 4f					ld c, a 
2e24 06 00				ld b, 0 
2e26			 
2e26				if DEBUG_FORTH_WORDS 
2e26					DMARK "LSn" 
2e26 f5				push af  
2e27 3a 3b 2e			ld a, (.dmark)  
2e2a 32 a6 fd			ld (debug_mark),a  
2e2d 3a 3c 2e			ld a, (.dmark+1)  
2e30 32 a7 fd			ld (debug_mark+1),a  
2e33 3a 3d 2e			ld a, (.dmark+2)  
2e36 32 a8 fd			ld (debug_mark+2),a  
2e39 18 03			jr .pastdmark  
2e3b ..			.dmark: db "LSn"  
2e3e f1			.pastdmark: pop af  
2e3f			endm  
# End of macro DMARK
2e3f					CALLMONITOR 
2e3f cd aa fd			call debug_vector  
2e42				endm  
# End of macro CALLMONITOR
2e42				endif 
2e42			 
2e42					; copy uword name to scratch 
2e42			 
2e42 ed b0				ldir 
2e44			 
2e44 1b					dec de 
2e45 3e 20				ld a, ' '    ; change null to space 
2e47 12					ld (de), a 
2e48			 
2e48 13					inc de 
2e49			 
2e49 d5					push de 
2e4a c1					pop bc     ; move scratch pointer to end of word name and save it 
2e4b			 
2e4b e1					pop hl 
2e4c 7e					ld a, (hl) 
2e4d					;inc hl 
2e4d					; skip word string 
2e4d cd cf 0f				call addatohl 
2e50			 
2e50 23					inc hl 
2e51			 
2e51				if DEBUG_FORTH_WORDS 
2e51					DMARK "LS3" 
2e51 f5				push af  
2e52 3a 66 2e			ld a, (.dmark)  
2e55 32 a6 fd			ld (debug_mark),a  
2e58 3a 67 2e			ld a, (.dmark+1)  
2e5b 32 a7 fd			ld (debug_mark+1),a  
2e5e 3a 68 2e			ld a, (.dmark+2)  
2e61 32 a8 fd			ld (debug_mark+2),a  
2e64 18 03			jr .pastdmark  
2e66 ..			.dmark: db "LS3"  
2e69 f1			.pastdmark: pop af  
2e6a			endm  
# End of macro DMARK
2e6a					CALLMONITOR 
2e6a cd aa fd			call debug_vector  
2e6d				endm  
# End of macro CALLMONITOR
2e6d				endif 
2e6d					; should now be at the start of the machine code to setup the eval of the uword 
2e6d					; now locate the ptr to the string defintion 
2e6d			 
2e6d					; skip ld hl, 
2e6d					; then load the ptr 
2e6d			; TODO use get from hl ptr 
2e6d 23					inc hl 
2e6e 5e					ld e, (hl) 
2e6f 23					inc hl 
2e70 56					ld d, (hl) 
2e71 eb					ex de, hl 
2e72			 
2e72			 
2e72				if DEBUG_FORTH_WORDS 
2e72					DMARK "LSt" 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 a6 fd			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 a7 fd			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 a8 fd			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db "LSt"  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b					CALLMONITOR 
2e8b cd aa fd			call debug_vector  
2e8e				endm  
# End of macro CALLMONITOR
2e8e				endif 
2e8e			 
2e8e			; cant push right now due to tokenised strings  
2e8e			 
2e8e			; get the destination of where to copy this definition to. 
2e8e			 
2e8e c5					push bc 
2e8f d1					pop de 
2e90			 
2e90 7e			.listl:         ld a,(hl) 
2e91 fe 00				cp 0 
2e93 28 09				jr z, .lreplsp     ; replace zero with space 
2e95					;cp FORTH_END_BUFFER 
2e95 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2e97 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2e99				 
2e99					; just copy this char as is then 
2e99			 
2e99 12					ld (de), a 
2e9a			 
2e9a 23			.listnxt:	inc hl 
2e9b 13					inc de 
2e9c 18 f2				jr .listl 
2e9e			 
2e9e 3e 20		.lreplsp:	ld a,' ' 
2ea0 12					ld (de), a 
2ea1 18 f7				jr .listnxt 
2ea3			 
2ea3			; close up uword def 
2ea3			 
2ea3			.listdone: 
2ea3 12					ld (de), a 
2ea4 13					inc de 
2ea5 3e 00				ld a, 0 
2ea7 12					ld (de), a 
2ea8			 
2ea8			; now have def so clean up and push to stack 
2ea8			 
2ea8 21 fc f0				ld hl, scratch 
2eab				if DEBUG_FORTH_WORDS 
2eab					DMARK "Ltp" 
2eab f5				push af  
2eac 3a c0 2e			ld a, (.dmark)  
2eaf 32 a6 fd			ld (debug_mark),a  
2eb2 3a c1 2e			ld a, (.dmark+1)  
2eb5 32 a7 fd			ld (debug_mark+1),a  
2eb8 3a c2 2e			ld a, (.dmark+2)  
2ebb 32 a8 fd			ld (debug_mark+2),a  
2ebe 18 03			jr .pastdmark  
2ec0 ..			.dmark: db "Ltp"  
2ec3 f1			.pastdmark: pop af  
2ec4			endm  
# End of macro DMARK
2ec4					CALLMONITOR 
2ec4 cd aa fd			call debug_vector  
2ec7				endm  
# End of macro CALLMONITOR
2ec7				endif 
2ec7			 
2ec7 18 1f			jr .listpush 
2ec9			 
2ec9			;.lnuword:	pop hl 
2ec9			;		call forth_tok_next 
2ec9			;		jp .ldouscan  
2ec9			 
2ec9			.lunotfound:		  
2ec9			 
2ec9				if DEBUG_FORTH_WORDS 
2ec9					DMARK "LSn" 
2ec9 f5				push af  
2eca 3a de 2e			ld a, (.dmark)  
2ecd 32 a6 fd			ld (debug_mark),a  
2ed0 3a df 2e			ld a, (.dmark+1)  
2ed3 32 a7 fd			ld (debug_mark+1),a  
2ed6 3a e0 2e			ld a, (.dmark+2)  
2ed9 32 a8 fd			ld (debug_mark+2),a  
2edc 18 03			jr .pastdmark  
2ede ..			.dmark: db "LSn"  
2ee1 f1			.pastdmark: pop af  
2ee2			endm  
# End of macro DMARK
2ee2					CALLMONITOR 
2ee2 cd aa fd			call debug_vector  
2ee5				endm  
# End of macro CALLMONITOR
2ee5				endif 
2ee5			 
2ee5					 
2ee5			;		FORTH_DSP_POP 
2ee5			;		ld hl, .luno 
2ee5			 
2ee5					NEXTW			 
2ee5 c3 d0 23			jp macro_next 
2ee8				endm 
# End of macro NEXTW
2ee8			 
2ee8			.listpush: 
2ee8				if DEBUG_FORTH_WORDS 
2ee8					DMARK "LS>" 
2ee8 f5				push af  
2ee9 3a fd 2e			ld a, (.dmark)  
2eec 32 a6 fd			ld (debug_mark),a  
2eef 3a fe 2e			ld a, (.dmark+1)  
2ef2 32 a7 fd			ld (debug_mark+1),a  
2ef5 3a ff 2e			ld a, (.dmark+2)  
2ef8 32 a8 fd			ld (debug_mark+2),a  
2efb 18 03			jr .pastdmark  
2efd ..			.dmark: db "LS>"  
2f00 f1			.pastdmark: pop af  
2f01			endm  
# End of macro DMARK
2f01					CALLMONITOR 
2f01 cd aa fd			call debug_vector  
2f04				endm  
# End of macro CALLMONITOR
2f04				endif 
2f04 cd 91 20				call forth_push_str 
2f07			 
2f07			 
2f07			 
2f07					NEXTW 
2f07 c3 d0 23			jp macro_next 
2f0a				endm 
# End of macro NEXTW
2f0a			 
2f0a			;.luno:    db "Word not found",0 
2f0a			 
2f0a			 
2f0a			 
2f0a			 
2f0a			 
2f0a			;		push hl   ; save pointer to start of uword def string 
2f0a			; 
2f0a			;; look for FORTH_EOL_LINE 
2f0a			;		ld a, FORTH_END_BUFFER 
2f0a			;		call strlent 
2f0a			; 
2f0a			;		inc hl		 ; space for coln def 
2f0a			;		inc hl 
2f0a			;		inc hl          ; space for terms 
2f0a			;		inc hl 
2f0a			; 
2f0a			;		ld a, 20   ; TODO get actual length 
2f0a			;		call addatohl    ; include a random amount of room for the uword name 
2f0a			; 
2f0a			;		 
2f0a			;	if DEBUG_FORTH_WORDS 
2f0a			;		DMARK "Lt1" 
2f0a			;		CALLMONITOR 
2f0a			;	endif 
2f0a			;		 
2f0a			; 
2f0a			;; malloc space for the string because we cant change it 
2f0a			; 
2f0a			;		call malloc 
2f0a			;	if DEBUG_FORTH_MALLOC_GUARD 
2f0a			;		push af 
2f0a			;		call ishlzero 
2f0a			;		pop af 
2f0a			;		 
2f0a			;		call z,malloc_error 
2f0a			;	endif 
2f0a			; 
2f0a			;	if DEBUG_FORTH_WORDS 
2f0a			;		DMARK "Lt2" 
2f0a			;		CALLMONITOR 
2f0a			;	endif 
2f0a			;		pop de 
2f0a			;		push hl    ; push the malloc to release later 
2f0a			;		push hl   ;  push back a copy for the later stack push 
2f0a			;		 
2f0a			;; copy the string swapping out the zero terms for spaces 
2f0a			; 
2f0a			;		; de has our source 
2f0a			;		; hl has our dest 
2f0a			; 
2f0a			;; add the coln def 
2f0a			; 
2f0a			;		ld a, ':' 
2f0a			;		ld (hl), a 
2f0a			;		inc hl 
2f0a			;		ld a, ' ' 
2f0a			;		ld (hl), a 
2f0a			;		inc hl 
2f0a			; 
2f0a			;; add the uname word 
2f0a			;		push de   ; save our string for now 
2f0a			;		ex de, hl 
2f0a			; 
2f0a			;		FORTH_DSP_VALUE 
2f0a			;		;v5 FORTH_DSP_VALUE 
2f0a			; 
2f0a			;		inc hl   ; skip type but we know by now this is OK 
2f0a			; 
2f0a			;.luword:	ld a,(hl) 
2f0a			;		cp 0 
2f0a			;		jr z, .luword2 
2f0a			;		ld (de), a 
2f0a			;		inc de 
2f0a			;		inc hl 
2f0a			;		jr .luword 
2f0a			; 
2f0a			;.luword2:	ld a, ' ' 
2f0a			;		ld (de), a 
2f0a			;;		inc hl 
2f0a			;;		inc de 
2f0a			;;		ld (de), a 
2f0a			;;		inc hl 
2f0a			;		inc de 
2f0a			; 
2f0a			;		ex de, hl 
2f0a			;		pop de 
2f0a			;		 
2f0a			;		 
2f0a			; 
2f0a			;; detoken that string and copy it 
2f0a			; 
2f0a			;	if DEBUG_FORTH_WORDS 
2f0a			;		DMARK "Lt2" 
2f0a			;		CALLMONITOR 
2f0a			;	endif 
2f0a			;.ldetok:	ld a, (de) 
2f0a			;		cp FORTH_END_BUFFER 
2f0a			;		jr z, .ldetokend 
2f0a			;		; swap out any zero term for space 
2f0a			;		cp 0 
2f0a			;		jr nz, .ldetoknext 
2f0a			;		ld a, ' ' 
2f0a			; 
2f0a			;	if DEBUG_FORTH_WORDS 
2f0a			;		DMARK "LtS" 
2f0a			;		CALLMONITOR 
2f0a			;	endif 
2f0a			;.ldetoknext:	ld (hl), a 
2f0a			;		inc de 
2f0a			;		inc hl 
2f0a			;		jr .ldetok 
2f0a			; 
2f0a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f0a			;		ld (hl), a  
2f0a			; 
2f0a			;; free that temp malloc 
2f0a			; 
2f0a			;		pop hl    
2f0a			; 
2f0a			;	if DEBUG_FORTH_WORDS 
2f0a			;		DMARK "Lt4" 
2f0a			;		CALLMONITOR 
2f0a			;	endif 
2f0a			;		call forth_apushstrhl 
2f0a			; 
2f0a			;		; get rid of temp malloc area 
2f0a			; 
2f0a			;		pop hl 
2f0a			;		call free 
2f0a			; 
2f0a			;		jr .ludone 
2f0a			; 
2f0a			;.lnuword:	pop hl 
2f0a			;		call forth_tok_next 
2f0a			;		jp .ldouscan  
2f0a			; 
2f0a			;.ludone:		 pop hl 
2f0a			; 
2f0a					NEXTW 
2f0a c3 d0 23			jp macro_next 
2f0d				endm 
# End of macro NEXTW
2f0d			 
2f0d			.FORGET: 
2f0d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f0d 5d				db WORD_SYS_CORE+73             
2f0e 86 2f			dw .NOP            
2f10 07				db 6 + 1 
2f11 .. 00			db "FORGET",0              
2f18				endm 
# End of macro CWHEAD
2f18			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f18			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2f18			; | |  
2f18			; | | e.g. "MORE" forget 
2f18					if DEBUG_FORTH_WORDS_KEY 
2f18						DMARK "FRG" 
2f18 f5				push af  
2f19 3a 2d 2f			ld a, (.dmark)  
2f1c 32 a6 fd			ld (debug_mark),a  
2f1f 3a 2e 2f			ld a, (.dmark+1)  
2f22 32 a7 fd			ld (debug_mark+1),a  
2f25 3a 2f 2f			ld a, (.dmark+2)  
2f28 32 a8 fd			ld (debug_mark+2),a  
2f2b 18 03			jr .pastdmark  
2f2d ..			.dmark: db "FRG"  
2f30 f1			.pastdmark: pop af  
2f31			endm  
# End of macro DMARK
2f31						CALLMONITOR 
2f31 cd aa fd			call debug_vector  
2f34				endm  
# End of macro CALLMONITOR
2f34					endif 
2f34			 
2f34				; find uword 
2f34			        ; update start of word with "_" 
2f34				; replace uword with deleted flag 
2f34			 
2f34			 
2f34			;	if DEBUG_FORTH_WORDS 
2f34			;		DMARK "FOG" 
2f34			;		CALLMONITOR 
2f34			;	endif 
2f34			 
2f34			 
2f34					; Get ptr to the word we need to look up 
2f34			 
2f34					FORTH_DSP_VALUEHL 
2f34 cd 1a 22			call macro_dsp_valuehl 
2f37				endm 
# End of macro FORTH_DSP_VALUEHL
2f37					;v5 FORTH_DSP_VALUE 
2f37				; TODO type check 
2f37			;		inc hl    ; Skip type check  
2f37 e5					push hl 
2f38 c1					pop bc 
2f39			;		ex de, hl    ; put into DE 
2f39			 
2f39			 
2f39 21 00 80				ld hl, baseram 
2f3c					;ld hl, baseusermem 
2f3c			 
2f3c				; skip dict stub 
2f3c			;	call forth_tok_next 
2f3c e5			push hl   ; sacreifical push 
2f3d			 
2f3d			.fldouscanm: 
2f3d e1				pop hl 
2f3e			.fldouscan: 
2f3e			;	if DEBUG_FORTH_WORDS 
2f3e			;		DMARK "LSs" 
2f3e			;		CALLMONITOR 
2f3e			;	endif 
2f3e				; skip dict stub 
2f3e cd 21 25				call forth_tok_next 
2f41			 
2f41			 
2f41			; while we have words to look for 
2f41			 
2f41 7e				ld a, (hl)      
2f42			;	if DEBUG_FORTH_WORDS 
2f42			;		DMARK "LSk" 
2f42			;		CALLMONITOR 
2f42			;	endif 
2f42 fe 00				cp WORD_SYS_END 
2f44 ca 80 2f				jp z, .flunotfound 
2f47 fe 01				cp WORD_SYS_UWORD 
2f49 c2 3e 2f				jp nz, .fldouscan 
2f4c			 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "LSu" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c			 
2f4c					; found a uword but is it the one we want... 
2f4c			 
2f4c c5					push bc     ; uword to find is on bc 
2f4d d1					pop de 
2f4e			 
2f4e e5					push hl  ; to save the ptr 
2f4f			 
2f4f					; skip opcode 
2f4f 23					inc hl  
2f50					; skip next ptr 
2f50 23					inc hl  
2f51 23					inc hl 
2f52					; skip len 
2f52 23					inc hl 
2f53			 
2f53			;	if DEBUG_FORTH_WORDS 
2f53			;		DMARK "LSc" 
2f53			;		CALLMONITOR 
2f53			;	endif 
2f53 cd 6d 13				call strcmp 
2f56 c2 3d 2f				jp nz, .fldouscanm 
2f59			; 
2f59			; 
2f59			;; while we have words to look for 
2f59			; 
2f59			;.fdouscan:	ld a, (hl)      
2f59			;	if DEBUG_FORTH_WORDS 
2f59			;		DMARK "LSs" 
2f59			;		CALLMONITOR 
2f59			;	endif 
2f59			;		cp WORD_SYS_END 
2f59			;		jp z, .fudone 
2f59			;		cp WORD_SYS_UWORD 
2f59			;		jp nz, .fnuword 
2f59			; 
2f59			;	if DEBUG_FORTH_WORDS 
2f59			;		DMARK "FGu" 
2f59			;		CALLMONITOR 
2f59			;	endif 
2f59			; 
2f59			;		; found a uword but is it the one we want... 
2f59			; 
2f59			; 
2f59			;	        pop de   ; get back the dsp name 
2f59			;		push de 
2f59			; 
2f59			;		push hl  ; to save the ptr 
2f59			; 
2f59			;		; skip opcode 
2f59			;		inc hl  
2f59			;		; skip next ptr 
2f59			;		inc hl  
2f59			;		inc hl 
2f59			;		; skip len 
2f59			;		inc hl 
2f59			; 
2f59			;	if DEBUG_FORTH_WORDS 
2f59			;		DMARK "FGc" 
2f59			;		CALLMONITOR 
2f59			;	endif 
2f59			;		call strcmp 
2f59			;		jp nz, .fnuword 
2f59			 
2f59			 
2f59 e1			pop hl 
2f5a			 
2f5a				 
2f5a				if DEBUG_FORTH_WORDS 
2f5a					DMARK "FGm" 
2f5a f5				push af  
2f5b 3a 6f 2f			ld a, (.dmark)  
2f5e 32 a6 fd			ld (debug_mark),a  
2f61 3a 70 2f			ld a, (.dmark+1)  
2f64 32 a7 fd			ld (debug_mark+1),a  
2f67 3a 71 2f			ld a, (.dmark+2)  
2f6a 32 a8 fd			ld (debug_mark+2),a  
2f6d 18 03			jr .pastdmark  
2f6f ..			.dmark: db "FGm"  
2f72 f1			.pastdmark: pop af  
2f73			endm  
# End of macro DMARK
2f73					CALLMONITOR 
2f73 cd aa fd			call debug_vector  
2f76				endm  
# End of macro CALLMONITOR
2f76				endif 
2f76			 
2f76			 
2f76			 
2f76					; we have a uword so push its name to the stack 
2f76			 
2f76			;	   	push hl  ; save so we can move to next dict block 
2f76			;pop hl 
2f76			 
2f76					; update opcode to deleted 
2f76 3e 03				ld a, WORD_SYS_DELETED 
2f78 77					ld (hl), a 
2f79			 
2f79 23					inc hl  
2f7a					; skip next ptr 
2f7a 23					inc hl  
2f7b 23					inc hl 
2f7c					; skip len 
2f7c 23					inc hl 
2f7d			 
2f7d					; TODO change parser to skip deleted words but for now mark it out 
2f7d 3e 5f				ld a, "_" 
2f7f 77					ld  (hl),a 
2f80			 
2f80			;		jr .fudone 
2f80			; 
2f80			;.fnuword:	pop hl 
2f80			;		call forth_tok_next 
2f80			;		jp .fdouscan  
2f80			 
2f80			.flunotfound:		  
2f80			 
2f80			 
2f80					 
2f80					FORTH_DSP_POP 
2f80 cd d2 22			call macro_forth_dsp_pop 
2f83				endm 
# End of macro FORTH_DSP_POP
2f83			;		ld hl, .luno 
2f83			;.fudone:		 pop hl 
2f83					NEXTW 
2f83 c3 d0 23			jp macro_next 
2f86				endm 
# End of macro NEXTW
2f86			.NOP: 
2f86				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2f86 61				db WORD_SYS_CORE+77             
2f87 ad 2f			dw .COMO            
2f89 04				db 3 + 1 
2f8a .. 00			db "NOP",0              
2f8e				endm 
# End of macro CWHEAD
2f8e			; | NOP (  --  ) Do nothing | DONE 
2f8e					if DEBUG_FORTH_WORDS_KEY 
2f8e						DMARK "NOP" 
2f8e f5				push af  
2f8f 3a a3 2f			ld a, (.dmark)  
2f92 32 a6 fd			ld (debug_mark),a  
2f95 3a a4 2f			ld a, (.dmark+1)  
2f98 32 a7 fd			ld (debug_mark+1),a  
2f9b 3a a5 2f			ld a, (.dmark+2)  
2f9e 32 a8 fd			ld (debug_mark+2),a  
2fa1 18 03			jr .pastdmark  
2fa3 ..			.dmark: db "NOP"  
2fa6 f1			.pastdmark: pop af  
2fa7			endm  
# End of macro DMARK
2fa7						CALLMONITOR 
2fa7 cd aa fd			call debug_vector  
2faa				endm  
# End of macro CALLMONITOR
2faa					endif 
2faa				       NEXTW 
2faa c3 d0 23			jp macro_next 
2fad				endm 
# End of macro NEXTW
2fad			.COMO: 
2fad				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2fad 6e				db WORD_SYS_CORE+90             
2fae ff 2f			dw .COMC            
2fb0 02				db 1 + 1 
2fb1 .. 00			db "(",0              
2fb3				endm 
# End of macro CWHEAD
2fb3			; | ( ( -- )  Start of comment | DONE 
2fb3			 
2fb3			 
2fb3 2a fd f3				ld hl, ( os_tok_ptr) 
2fb6 11 fa 2f			ld de, .closepar 
2fb9					 
2fb9					if DEBUG_FORTH_WORDS 
2fb9						DMARK ").." 
2fb9 f5				push af  
2fba 3a ce 2f			ld a, (.dmark)  
2fbd 32 a6 fd			ld (debug_mark),a  
2fc0 3a cf 2f			ld a, (.dmark+1)  
2fc3 32 a7 fd			ld (debug_mark+1),a  
2fc6 3a d0 2f			ld a, (.dmark+2)  
2fc9 32 a8 fd			ld (debug_mark+2),a  
2fcc 18 03			jr .pastdmark  
2fce ..			.dmark: db ").."  
2fd1 f1			.pastdmark: pop af  
2fd2			endm  
# End of macro DMARK
2fd2						CALLMONITOR 
2fd2 cd aa fd			call debug_vector  
2fd5				endm  
# End of macro CALLMONITOR
2fd5					endif 
2fd5 cd eb 24			call findnexttok  
2fd8			 
2fd8					if DEBUG_FORTH_WORDS 
2fd8						DMARK "IF5" 
2fd8 f5				push af  
2fd9 3a ed 2f			ld a, (.dmark)  
2fdc 32 a6 fd			ld (debug_mark),a  
2fdf 3a ee 2f			ld a, (.dmark+1)  
2fe2 32 a7 fd			ld (debug_mark+1),a  
2fe5 3a ef 2f			ld a, (.dmark+2)  
2fe8 32 a8 fd			ld (debug_mark+2),a  
2feb 18 03			jr .pastdmark  
2fed ..			.dmark: db "IF5"  
2ff0 f1			.pastdmark: pop af  
2ff1			endm  
# End of macro DMARK
2ff1						CALLMONITOR 
2ff1 cd aa fd			call debug_vector  
2ff4				endm  
# End of macro CALLMONITOR
2ff4					endif 
2ff4				; replace below with ) exec using tok_ptr 
2ff4 22 fd f3			ld (os_tok_ptr), hl 
2ff7 c3 61 24			jp exec1 
2ffa			 
2ffa .. 00			.closepar:   db ")",0 
2ffc			 
2ffc				       NEXTW 
2ffc c3 d0 23			jp macro_next 
2fff				endm 
# End of macro NEXTW
2fff			.COMC: 
2fff				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2fff 6f				db WORD_SYS_CORE+91             
3000 08 30			dw .SCRATCH            
3002 02				db 1 + 1 
3003 .. 00			db ")",0              
3005				endm 
# End of macro CWHEAD
3005			; | ) ( -- )  End of comment |  DONE  
3005				       NEXTW 
3005 c3 d0 23			jp macro_next 
3008				endm 
# End of macro NEXTW
3008			 
3008			.SCRATCH: 
3008				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3008 6f				db WORD_SYS_CORE+91             
3009 43 30			dw .INC            
300b 08				db 7 + 1 
300c .. 00			db "SCRATCH",0              
3014				endm 
# End of macro CWHEAD
3014			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3014			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3014			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3014			; | |  
3014			; | | e.g.    : score $00 scratch ; 
3014			; | |  
3014			; | | $00 score ! 
3014			; | | $01 score +! 
3014			; | |  
3014			; | | e.g.   : varword $0a scratch ;  
3014			; | | 
3014			; | | $8000 varword ! 
3014					if DEBUG_FORTH_WORDS_KEY 
3014						DMARK "SCR" 
3014 f5				push af  
3015 3a 29 30			ld a, (.dmark)  
3018 32 a6 fd			ld (debug_mark),a  
301b 3a 2a 30			ld a, (.dmark+1)  
301e 32 a7 fd			ld (debug_mark+1),a  
3021 3a 2b 30			ld a, (.dmark+2)  
3024 32 a8 fd			ld (debug_mark+2),a  
3027 18 03			jr .pastdmark  
3029 ..			.dmark: db "SCR"  
302c f1			.pastdmark: pop af  
302d			endm  
# End of macro DMARK
302d						CALLMONITOR 
302d cd aa fd			call debug_vector  
3030				endm  
# End of macro CALLMONITOR
3030					endif 
3030			 
3030					FORTH_DSP_VALUEHL 
3030 cd 1a 22			call macro_dsp_valuehl 
3033				endm 
# End of macro FORTH_DSP_VALUEHL
3033				 
3033					FORTH_DSP_POP 
3033 cd d2 22			call macro_forth_dsp_pop 
3036				endm 
# End of macro FORTH_DSP_POP
3036			 
3036 7d					ld a, l 
3037 21 21 f6				ld hl, os_var_array 
303a cd cf 0f				call addatohl 
303d			 
303d cd 23 20				call forth_push_numhl 
3040			 
3040				       NEXTW 
3040 c3 d0 23			jp macro_next 
3043				endm 
# End of macro NEXTW
3043			 
3043			.INC: 
3043				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3043 6f				db WORD_SYS_CORE+91             
3044 99 30			dw .DEC            
3046 03				db 2 + 1 
3047 .. 00			db "+!",0              
304a				endm 
# End of macro CWHEAD
304a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
304a					if DEBUG_FORTH_WORDS_KEY 
304a						DMARK "+s_" 
304a f5				push af  
304b 3a 5f 30			ld a, (.dmark)  
304e 32 a6 fd			ld (debug_mark),a  
3051 3a 60 30			ld a, (.dmark+1)  
3054 32 a7 fd			ld (debug_mark+1),a  
3057 3a 61 30			ld a, (.dmark+2)  
305a 32 a8 fd			ld (debug_mark+2),a  
305d 18 03			jr .pastdmark  
305f ..			.dmark: db "+s_"  
3062 f1			.pastdmark: pop af  
3063			endm  
# End of macro DMARK
3063						CALLMONITOR 
3063 cd aa fd			call debug_vector  
3066				endm  
# End of macro CALLMONITOR
3066					endif 
3066			 
3066					FORTH_DSP_VALUEHL 
3066 cd 1a 22			call macro_dsp_valuehl 
3069				endm 
# End of macro FORTH_DSP_VALUEHL
3069			 
3069 e5					push hl   ; save address 
306a			 
306a					FORTH_DSP_POP 
306a cd d2 22			call macro_forth_dsp_pop 
306d				endm 
# End of macro FORTH_DSP_POP
306d			 
306d					FORTH_DSP_VALUEHL 
306d cd 1a 22			call macro_dsp_valuehl 
3070				endm 
# End of macro FORTH_DSP_VALUEHL
3070			 
3070 e5					push hl 
3071					FORTH_DSP_POP 
3071 cd d2 22			call macro_forth_dsp_pop 
3074				endm 
# End of macro FORTH_DSP_POP
3074 e1					pop hl 
3075			 
3075					; hl contains value to add to byte at a 
3075				 
3075 eb					ex de, hl 
3076			 
3076 e1					pop hl 
3077			 
3077					if DEBUG_FORTH_WORDS 
3077						DMARK "INC" 
3077 f5				push af  
3078 3a 8c 30			ld a, (.dmark)  
307b 32 a6 fd			ld (debug_mark),a  
307e 3a 8d 30			ld a, (.dmark+1)  
3081 32 a7 fd			ld (debug_mark+1),a  
3084 3a 8e 30			ld a, (.dmark+2)  
3087 32 a8 fd			ld (debug_mark+2),a  
308a 18 03			jr .pastdmark  
308c ..			.dmark: db "INC"  
308f f1			.pastdmark: pop af  
3090			endm  
# End of macro DMARK
3090						CALLMONITOR 
3090 cd aa fd			call debug_vector  
3093				endm  
# End of macro CALLMONITOR
3093					endif 
3093			 
3093 7e					ld a,(hl) 
3094 83					add e 
3095 77					ld (hl),a 
3096			 
3096			 
3096			 
3096				       NEXTW 
3096 c3 d0 23			jp macro_next 
3099				endm 
# End of macro NEXTW
3099			 
3099			.DEC: 
3099				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3099 6f				db WORD_SYS_CORE+91             
309a ed 30			dw .INC2            
309c 03				db 2 + 1 
309d .. 00			db "-!",0              
30a0				endm 
# End of macro CWHEAD
30a0			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
30a0					if DEBUG_FORTH_WORDS_KEY 
30a0						DMARK "-s_" 
30a0 f5				push af  
30a1 3a b5 30			ld a, (.dmark)  
30a4 32 a6 fd			ld (debug_mark),a  
30a7 3a b6 30			ld a, (.dmark+1)  
30aa 32 a7 fd			ld (debug_mark+1),a  
30ad 3a b7 30			ld a, (.dmark+2)  
30b0 32 a8 fd			ld (debug_mark+2),a  
30b3 18 03			jr .pastdmark  
30b5 ..			.dmark: db "-s_"  
30b8 f1			.pastdmark: pop af  
30b9			endm  
# End of macro DMARK
30b9						CALLMONITOR 
30b9 cd aa fd			call debug_vector  
30bc				endm  
# End of macro CALLMONITOR
30bc					endif 
30bc			 
30bc					FORTH_DSP_VALUEHL 
30bc cd 1a 22			call macro_dsp_valuehl 
30bf				endm 
# End of macro FORTH_DSP_VALUEHL
30bf			 
30bf e5					push hl   ; save address 
30c0			 
30c0					FORTH_DSP_POP 
30c0 cd d2 22			call macro_forth_dsp_pop 
30c3				endm 
# End of macro FORTH_DSP_POP
30c3			 
30c3					FORTH_DSP_VALUEHL 
30c3 cd 1a 22			call macro_dsp_valuehl 
30c6				endm 
# End of macro FORTH_DSP_VALUEHL
30c6			 
30c6					; hl contains value to add to byte at a 
30c6				 
30c6 eb					ex de, hl 
30c7			 
30c7 e1					pop hl 
30c8			 
30c8					if DEBUG_FORTH_WORDS 
30c8						DMARK "DEC" 
30c8 f5				push af  
30c9 3a dd 30			ld a, (.dmark)  
30cc 32 a6 fd			ld (debug_mark),a  
30cf 3a de 30			ld a, (.dmark+1)  
30d2 32 a7 fd			ld (debug_mark+1),a  
30d5 3a df 30			ld a, (.dmark+2)  
30d8 32 a8 fd			ld (debug_mark+2),a  
30db 18 03			jr .pastdmark  
30dd ..			.dmark: db "DEC"  
30e0 f1			.pastdmark: pop af  
30e1			endm  
# End of macro DMARK
30e1						CALLMONITOR 
30e1 cd aa fd			call debug_vector  
30e4				endm  
# End of macro CALLMONITOR
30e4					endif 
30e4			 
30e4 7e					ld a,(hl) 
30e5 93					sub e 
30e6 77					ld (hl),a 
30e7			 
30e7			 
30e7					FORTH_DSP_POP 
30e7 cd d2 22			call macro_forth_dsp_pop 
30ea				endm 
# End of macro FORTH_DSP_POP
30ea			 
30ea				       NEXTW 
30ea c3 d0 23			jp macro_next 
30ed				endm 
# End of macro NEXTW
30ed			 
30ed			.INC2: 
30ed				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
30ed 6f				db WORD_SYS_CORE+91             
30ee 9a 31			dw .DEC2            
30f0 04				db 3 + 1 
30f1 .. 00			db "+2!",0              
30f5				endm 
# End of macro CWHEAD
30f5			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
30f5			 
30f5					if DEBUG_FORTH_WORDS_KEY 
30f5						DMARK "+2s" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 a6 fd			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 a7 fd			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 a8 fd			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "+2s"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd aa fd			call debug_vector  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111			 
3111					; Address 
3111			 
3111					FORTH_DSP_VALUEHL 
3111 cd 1a 22			call macro_dsp_valuehl 
3114				endm 
# End of macro FORTH_DSP_VALUEHL
3114			 
3114 e5					push hl    ; save address 
3115			 
3115					; load content into de 
3115			 
3115 5e					ld e,(hl) 
3116 23					inc hl 
3117 56					ld d, (hl) 
3118			 
3118					if DEBUG_FORTH_WORDS 
3118						DMARK "+2a" 
3118 f5				push af  
3119 3a 2d 31			ld a, (.dmark)  
311c 32 a6 fd			ld (debug_mark),a  
311f 3a 2e 31			ld a, (.dmark+1)  
3122 32 a7 fd			ld (debug_mark+1),a  
3125 3a 2f 31			ld a, (.dmark+2)  
3128 32 a8 fd			ld (debug_mark+2),a  
312b 18 03			jr .pastdmark  
312d ..			.dmark: db "+2a"  
3130 f1			.pastdmark: pop af  
3131			endm  
# End of macro DMARK
3131						CALLMONITOR 
3131 cd aa fd			call debug_vector  
3134				endm  
# End of macro CALLMONITOR
3134					endif 
3134			 
3134					FORTH_DSP_POP 
3134 cd d2 22			call macro_forth_dsp_pop 
3137				endm 
# End of macro FORTH_DSP_POP
3137			 
3137					; Get value to add 
3137			 
3137					FORTH_DSP_VALUE 
3137 cd 03 22			call macro_forth_dsp_value 
313a				endm 
# End of macro FORTH_DSP_VALUE
313a			 
313a					if DEBUG_FORTH_WORDS 
313a						DMARK "+2v" 
313a f5				push af  
313b 3a 4f 31			ld a, (.dmark)  
313e 32 a6 fd			ld (debug_mark),a  
3141 3a 50 31			ld a, (.dmark+1)  
3144 32 a7 fd			ld (debug_mark+1),a  
3147 3a 51 31			ld a, (.dmark+2)  
314a 32 a8 fd			ld (debug_mark+2),a  
314d 18 03			jr .pastdmark  
314f ..			.dmark: db "+2v"  
3152 f1			.pastdmark: pop af  
3153			endm  
# End of macro DMARK
3153						CALLMONITOR 
3153 cd aa fd			call debug_vector  
3156				endm  
# End of macro CALLMONITOR
3156					endif 
3156			 
3156 19					add hl, de 
3157			 
3157					if DEBUG_FORTH_WORDS 
3157						DMARK "+2+" 
3157 f5				push af  
3158 3a 6c 31			ld a, (.dmark)  
315b 32 a6 fd			ld (debug_mark),a  
315e 3a 6d 31			ld a, (.dmark+1)  
3161 32 a7 fd			ld (debug_mark+1),a  
3164 3a 6e 31			ld a, (.dmark+2)  
3167 32 a8 fd			ld (debug_mark+2),a  
316a 18 03			jr .pastdmark  
316c ..			.dmark: db "+2+"  
316f f1			.pastdmark: pop af  
3170			endm  
# End of macro DMARK
3170						CALLMONITOR 
3170 cd aa fd			call debug_vector  
3173				endm  
# End of macro CALLMONITOR
3173					endif 
3173			 
3173					; move result to de 
3173			 
3173 eb					ex de, hl 
3174			 
3174					; Address 
3174			 
3174 e1					pop hl 
3175			 
3175					; save it back 
3175			 
3175 73					ld (hl), e 
3176 23					inc hl 
3177 72					ld (hl), d 
3178			 
3178					if DEBUG_FORTH_WORDS 
3178						DMARK "+2e" 
3178 f5				push af  
3179 3a 8d 31			ld a, (.dmark)  
317c 32 a6 fd			ld (debug_mark),a  
317f 3a 8e 31			ld a, (.dmark+1)  
3182 32 a7 fd			ld (debug_mark+1),a  
3185 3a 8f 31			ld a, (.dmark+2)  
3188 32 a8 fd			ld (debug_mark+2),a  
318b 18 03			jr .pastdmark  
318d ..			.dmark: db "+2e"  
3190 f1			.pastdmark: pop af  
3191			endm  
# End of macro DMARK
3191						CALLMONITOR 
3191 cd aa fd			call debug_vector  
3194				endm  
# End of macro CALLMONITOR
3194					endif 
3194			 
3194			 
3194			 
3194					FORTH_DSP_POP 
3194 cd d2 22			call macro_forth_dsp_pop 
3197				endm 
# End of macro FORTH_DSP_POP
3197			 
3197			 
3197				       NEXTW 
3197 c3 d0 23			jp macro_next 
319a				endm 
# End of macro NEXTW
319a			 
319a			.DEC2: 
319a				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
319a 6f				db WORD_SYS_CORE+91             
319b 49 32			dw .GET2            
319d 04				db 3 + 1 
319e .. 00			db "-2!",0              
31a2				endm 
# End of macro CWHEAD
31a2			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
31a2			 
31a2			 
31a2					if DEBUG_FORTH_WORDS_KEY 
31a2						DMARK "-2s" 
31a2 f5				push af  
31a3 3a b7 31			ld a, (.dmark)  
31a6 32 a6 fd			ld (debug_mark),a  
31a9 3a b8 31			ld a, (.dmark+1)  
31ac 32 a7 fd			ld (debug_mark+1),a  
31af 3a b9 31			ld a, (.dmark+2)  
31b2 32 a8 fd			ld (debug_mark+2),a  
31b5 18 03			jr .pastdmark  
31b7 ..			.dmark: db "-2s"  
31ba f1			.pastdmark: pop af  
31bb			endm  
# End of macro DMARK
31bb						CALLMONITOR 
31bb cd aa fd			call debug_vector  
31be				endm  
# End of macro CALLMONITOR
31be					endif 
31be			 
31be					; Address 
31be			 
31be					FORTH_DSP_VALUEHL 
31be cd 1a 22			call macro_dsp_valuehl 
31c1				endm 
# End of macro FORTH_DSP_VALUEHL
31c1			 
31c1 e5					push hl    ; save address 
31c2			 
31c2					; load content into de 
31c2			 
31c2 5e					ld e,(hl) 
31c3 23					inc hl 
31c4 56					ld d, (hl) 
31c5			 
31c5					if DEBUG_FORTH_WORDS 
31c5						DMARK "-2a" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 a6 fd			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 a7 fd			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 a8 fd			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "-2a"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de						CALLMONITOR 
31de cd aa fd			call debug_vector  
31e1				endm  
# End of macro CALLMONITOR
31e1					endif 
31e1			 
31e1					FORTH_DSP_POP 
31e1 cd d2 22			call macro_forth_dsp_pop 
31e4				endm 
# End of macro FORTH_DSP_POP
31e4			 
31e4					; Get value to remove 
31e4			 
31e4					FORTH_DSP_VALUE 
31e4 cd 03 22			call macro_forth_dsp_value 
31e7				endm 
# End of macro FORTH_DSP_VALUE
31e7			 
31e7					if DEBUG_FORTH_WORDS 
31e7						DMARK "-2v" 
31e7 f5				push af  
31e8 3a fc 31			ld a, (.dmark)  
31eb 32 a6 fd			ld (debug_mark),a  
31ee 3a fd 31			ld a, (.dmark+1)  
31f1 32 a7 fd			ld (debug_mark+1),a  
31f4 3a fe 31			ld a, (.dmark+2)  
31f7 32 a8 fd			ld (debug_mark+2),a  
31fa 18 03			jr .pastdmark  
31fc ..			.dmark: db "-2v"  
31ff f1			.pastdmark: pop af  
3200			endm  
# End of macro DMARK
3200						CALLMONITOR 
3200 cd aa fd			call debug_vector  
3203				endm  
# End of macro CALLMONITOR
3203					endif 
3203			 
3203 eb					ex de, hl 
3204 ed 52				sbc hl, de 
3206			 
3206					if DEBUG_FORTH_WORDS 
3206						DMARK "-2d" 
3206 f5				push af  
3207 3a 1b 32			ld a, (.dmark)  
320a 32 a6 fd			ld (debug_mark),a  
320d 3a 1c 32			ld a, (.dmark+1)  
3210 32 a7 fd			ld (debug_mark+1),a  
3213 3a 1d 32			ld a, (.dmark+2)  
3216 32 a8 fd			ld (debug_mark+2),a  
3219 18 03			jr .pastdmark  
321b ..			.dmark: db "-2d"  
321e f1			.pastdmark: pop af  
321f			endm  
# End of macro DMARK
321f						CALLMONITOR 
321f cd aa fd			call debug_vector  
3222				endm  
# End of macro CALLMONITOR
3222					endif 
3222			 
3222					; move result to de 
3222			 
3222 eb					ex de, hl 
3223			 
3223					; Address 
3223			 
3223 e1					pop hl 
3224			 
3224					; save it back 
3224			 
3224 73					ld (hl), e 
3225 23					inc hl 
3226 72					ld (hl), d 
3227			 
3227					if DEBUG_FORTH_WORDS 
3227						DMARK "-2e" 
3227 f5				push af  
3228 3a 3c 32			ld a, (.dmark)  
322b 32 a6 fd			ld (debug_mark),a  
322e 3a 3d 32			ld a, (.dmark+1)  
3231 32 a7 fd			ld (debug_mark+1),a  
3234 3a 3e 32			ld a, (.dmark+2)  
3237 32 a8 fd			ld (debug_mark+2),a  
323a 18 03			jr .pastdmark  
323c ..			.dmark: db "-2e"  
323f f1			.pastdmark: pop af  
3240			endm  
# End of macro DMARK
3240						CALLMONITOR 
3240 cd aa fd			call debug_vector  
3243				endm  
# End of macro CALLMONITOR
3243					endif 
3243			 
3243			 
3243					FORTH_DSP_POP 
3243 cd d2 22			call macro_forth_dsp_pop 
3246				endm 
# End of macro FORTH_DSP_POP
3246			 
3246			 
3246			 
3246				       NEXTW 
3246 c3 d0 23			jp macro_next 
3249				endm 
# End of macro NEXTW
3249			.GET2: 
3249				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3249 6f				db WORD_SYS_CORE+91             
324a 7e 32			dw .BANG2            
324c 03				db 2 + 1 
324d .. 00			db "2@",0              
3250				endm 
# End of macro CWHEAD
3250			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3250					if DEBUG_FORTH_WORDS_KEY 
3250						DMARK "2A_" 
3250 f5				push af  
3251 3a 65 32			ld a, (.dmark)  
3254 32 a6 fd			ld (debug_mark),a  
3257 3a 66 32			ld a, (.dmark+1)  
325a 32 a7 fd			ld (debug_mark+1),a  
325d 3a 67 32			ld a, (.dmark+2)  
3260 32 a8 fd			ld (debug_mark+2),a  
3263 18 03			jr .pastdmark  
3265 ..			.dmark: db "2A_"  
3268 f1			.pastdmark: pop af  
3269			endm  
# End of macro DMARK
3269						CALLMONITOR 
3269 cd aa fd			call debug_vector  
326c				endm  
# End of macro CALLMONITOR
326c					endif 
326c			 
326c					FORTH_DSP_VALUEHL 
326c cd 1a 22			call macro_dsp_valuehl 
326f				endm 
# End of macro FORTH_DSP_VALUEHL
326f			 
326f e5					push hl   ; save address 
3270			 
3270					FORTH_DSP_POP 
3270 cd d2 22			call macro_forth_dsp_pop 
3273				endm 
# End of macro FORTH_DSP_POP
3273			 
3273 e1					pop hl 
3274			 
3274 5e					ld e, (hl) 
3275 23					inc hl 
3276 56					ld d, (hl) 
3277			 
3277 eb					ex de, hl 
3278			 
3278 cd 23 20				call forth_push_numhl 
327b			 
327b				       NEXTW 
327b c3 d0 23			jp macro_next 
327e				endm 
# End of macro NEXTW
327e			.BANG2: 
327e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
327e 6f				db WORD_SYS_CORE+91             
327f b6 32			dw .CONFIG            
3281 03				db 2 + 1 
3282 .. 00			db "2!",0              
3285				endm 
# End of macro CWHEAD
3285			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3285					if DEBUG_FORTH_WORDS_KEY 
3285						DMARK "2S_" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 a6 fd			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 a7 fd			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 a8 fd			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "2S_"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e						CALLMONITOR 
329e cd aa fd			call debug_vector  
32a1				endm  
# End of macro CALLMONITOR
32a1					endif 
32a1			 
32a1					FORTH_DSP_VALUEHL 
32a1 cd 1a 22			call macro_dsp_valuehl 
32a4				endm 
# End of macro FORTH_DSP_VALUEHL
32a4			 
32a4 e5					push hl   ; save address 
32a5			 
32a5			 
32a5					FORTH_DSP_POP 
32a5 cd d2 22			call macro_forth_dsp_pop 
32a8				endm 
# End of macro FORTH_DSP_POP
32a8			 
32a8					 
32a8					FORTH_DSP_VALUEHL 
32a8 cd 1a 22			call macro_dsp_valuehl 
32ab				endm 
# End of macro FORTH_DSP_VALUEHL
32ab			 
32ab					FORTH_DSP_POP 
32ab cd d2 22			call macro_forth_dsp_pop 
32ae				endm 
# End of macro FORTH_DSP_POP
32ae			 
32ae eb					ex de, hl    ; value now in de 
32af			 
32af e1					pop hl 
32b0			 
32b0 73					ld (hl), e 
32b1			 
32b1 23					inc hl 
32b2			 
32b2 72					ld (hl), d 
32b3			 
32b3			 
32b3				       NEXTW 
32b3 c3 d0 23			jp macro_next 
32b6				endm 
# End of macro NEXTW
32b6			.CONFIG: 
32b6				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
32b6 6f				db WORD_SYS_CORE+91             
32b7 c7 32			dw .ADTOS            
32b9 07				db 6 + 1 
32ba .. 00			db "CONFIG",0              
32c1				endm 
# End of macro CWHEAD
32c1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
32c1			 
32c1 cd 43 15				call config 
32c4					NEXTW 
32c4 c3 d0 23			jp macro_next 
32c7				endm 
# End of macro NEXTW
32c7			 
32c7			.ADTOS: 
32c7				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
32c7 6f				db WORD_SYS_CORE+91             
32c8 dd 32			dw .SBTOS            
32ca 03				db 2 + 1 
32cb .. 00			db "1+",0              
32ce				endm 
# End of macro CWHEAD
32ce			; | 1+ ( u -- u )  Increment value on TOS | DONE 
32ce			 
32ce					FORTH_DSP_VALUEHL 
32ce cd 1a 22			call macro_dsp_valuehl 
32d1				endm 
# End of macro FORTH_DSP_VALUEHL
32d1 e5					push hl 
32d2			 
32d2					FORTH_DSP_POP 
32d2 cd d2 22			call macro_forth_dsp_pop 
32d5				endm 
# End of macro FORTH_DSP_POP
32d5 e1					pop hl 
32d6			 
32d6 23					inc hl 
32d7 cd 23 20				call forth_push_numhl 
32da					 
32da					NEXTW 
32da c3 d0 23			jp macro_next 
32dd				endm 
# End of macro NEXTW
32dd			.SBTOS: 
32dd				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
32dd 6f				db WORD_SYS_CORE+91             
32de f3 32			dw .ADSTORE            
32e0 03				db 2 + 1 
32e1 .. 00			db "1-",0              
32e4				endm 
# End of macro CWHEAD
32e4			; | 1- ( u -- u )  Decrement value on TOS | DONE 
32e4			 
32e4					FORTH_DSP_VALUEHL 
32e4 cd 1a 22			call macro_dsp_valuehl 
32e7				endm 
# End of macro FORTH_DSP_VALUEHL
32e7 e5					push hl 
32e8			 
32e8					FORTH_DSP_POP 
32e8 cd d2 22			call macro_forth_dsp_pop 
32eb				endm 
# End of macro FORTH_DSP_POP
32eb e1					pop hl 
32ec			 
32ec 2b					dec hl 
32ed cd 23 20				call forth_push_numhl 
32f0					 
32f0					NEXTW 
32f0 c3 d0 23			jp macro_next 
32f3				endm 
# End of macro NEXTW
32f3			.ADSTORE: 
32f3				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
32f3 6f				db WORD_SYS_CORE+91             
32f4 09 33			dw .ADWSTORE            
32f6 04				db 3 + 1 
32f7 .. 00			db "1+!",0              
32fb				endm 
# End of macro CWHEAD
32fb			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
32fb			 
32fb					FORTH_DSP_VALUEHL 
32fb cd 1a 22			call macro_dsp_valuehl 
32fe				endm 
# End of macro FORTH_DSP_VALUEHL
32fe e5					push hl 
32ff			 
32ff					FORTH_DSP_POP 
32ff cd d2 22			call macro_forth_dsp_pop 
3302				endm 
# End of macro FORTH_DSP_POP
3302 e1					pop hl 
3303			 
3303 7e					ld a, (hl) 
3304 3c					inc a 
3305 77					ld (hl), a 
3306					 
3306					NEXTW 
3306 c3 d0 23			jp macro_next 
3309				endm 
# End of macro NEXTW
3309			.ADWSTORE: 
3309				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3309 6f				db WORD_SYS_CORE+91             
330a 27 33			dw .SBSTORE            
330c 05				db 4 + 1 
330d .. 00			db "1+2!",0              
3312				endm 
# End of macro CWHEAD
3312			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3312			 
3312					FORTH_DSP_VALUEHL 
3312 cd 1a 22			call macro_dsp_valuehl 
3315				endm 
# End of macro FORTH_DSP_VALUEHL
3315 e5					push hl 
3316			 
3316					FORTH_DSP_POP 
3316 cd d2 22			call macro_forth_dsp_pop 
3319				endm 
# End of macro FORTH_DSP_POP
3319 e1					pop hl 
331a			 
331a e5					push hl 
331b			 
331b cd 52 23				call loadwordinhl 
331e 23					inc hl 
331f			 
331f d1					pop de 
3320 eb					ex de, hl 
3321 73					ld (hl), e 
3322 23					inc hl 
3323 72					ld (hl), d 
3324					 
3324					NEXTW 
3324 c3 d0 23			jp macro_next 
3327				endm 
# End of macro NEXTW
3327			.SBSTORE: 
3327				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3327 6f				db WORD_SYS_CORE+91             
3328 3d 33			dw .SBWSTORE            
332a 04				db 3 + 1 
332b .. 00			db "1-!",0              
332f				endm 
# End of macro CWHEAD
332f			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
332f			 
332f					FORTH_DSP_VALUEHL 
332f cd 1a 22			call macro_dsp_valuehl 
3332				endm 
# End of macro FORTH_DSP_VALUEHL
3332 e5					push hl 
3333			 
3333					FORTH_DSP_POP 
3333 cd d2 22			call macro_forth_dsp_pop 
3336				endm 
# End of macro FORTH_DSP_POP
3336 e1					pop hl 
3337			 
3337 7e					ld a, (hl) 
3338 3d					dec a 
3339 77					ld (hl), a 
333a					 
333a					NEXTW 
333a c3 d0 23			jp macro_next 
333d				endm 
# End of macro NEXTW
333d			.SBWSTORE: 
333d				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
333d 6f				db WORD_SYS_CORE+91             
333e 5b 33			dw .ENDCORE            
3340 05				db 4 + 1 
3341 .. 00			db "1-2!",0              
3346				endm 
# End of macro CWHEAD
3346			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3346			 
3346					FORTH_DSP_VALUEHL 
3346 cd 1a 22			call macro_dsp_valuehl 
3349				endm 
# End of macro FORTH_DSP_VALUEHL
3349 e5					push hl 
334a			 
334a					FORTH_DSP_POP 
334a cd d2 22			call macro_forth_dsp_pop 
334d				endm 
# End of macro FORTH_DSP_POP
334d e1					pop hl 
334e			 
334e e5					push hl 
334f			 
334f cd 52 23				call loadwordinhl 
3352 2b					dec hl 
3353			 
3353 d1					pop de 
3354 eb					ex de, hl 
3355 73					ld (hl), e 
3356 23					inc hl 
3357 72					ld (hl), d 
3358					 
3358					NEXTW 
3358 c3 d0 23			jp macro_next 
335b				endm 
# End of macro NEXTW
335b			.ENDCORE: 
335b			 
335b			; eof 
335b			 
335b			 
# End of file forth_words_core.asm
335b			include "forth_words_flow.asm" 
335b			 
335b			; | ## Program Flow Words 
335b			 
335b			.IF: 
335b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
335b 1e				db WORD_SYS_CORE+10             
335c 50 34			dw .THEN            
335e 03				db 2 + 1 
335f .. 00			db "IF",0              
3362				endm 
# End of macro CWHEAD
3362			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3362			; 
3362					if DEBUG_FORTH_WORDS_KEY 
3362						DMARK "IF." 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 a6 fd			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 a7 fd			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 a8 fd			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "IF."  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b						CALLMONITOR 
337b cd aa fd			call debug_vector  
337e				endm  
# End of macro CALLMONITOR
337e					endif 
337e			; eval TOS 
337e			 
337e				FORTH_DSP_VALUEHL 
337e cd 1a 22			call macro_dsp_valuehl 
3381				endm 
# End of macro FORTH_DSP_VALUEHL
3381			 
3381			;	push hl 
3381				FORTH_DSP_POP 
3381 cd d2 22			call macro_forth_dsp_pop 
3384				endm 
# End of macro FORTH_DSP_POP
3384			;	pop hl 
3384			 
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "IF1" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 a6 fd			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 a7 fd			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 a8 fd			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "IF1"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd aa fd			call debug_vector  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0 b7				or a        ; clear carry flag 
33a1 11 00 00			ld de, 0 
33a4 eb				ex de,hl 
33a5 ed 52			sbc hl, de 
33a7 c2 31 34			jp nz, .iftrue 
33aa			 
33aa					if DEBUG_FORTH_WORDS 
33aa						DMARK "IF2" 
33aa f5				push af  
33ab 3a bf 33			ld a, (.dmark)  
33ae 32 a6 fd			ld (debug_mark),a  
33b1 3a c0 33			ld a, (.dmark+1)  
33b4 32 a7 fd			ld (debug_mark+1),a  
33b7 3a c1 33			ld a, (.dmark+2)  
33ba 32 a8 fd			ld (debug_mark+2),a  
33bd 18 03			jr .pastdmark  
33bf ..			.dmark: db "IF2"  
33c2 f1			.pastdmark: pop af  
33c3			endm  
# End of macro DMARK
33c3						CALLMONITOR 
33c3 cd aa fd			call debug_vector  
33c6				endm  
# End of macro CALLMONITOR
33c6					endif 
33c6			 
33c6			; if not true then skip to THEN 
33c6			 
33c6				; TODO get tok_ptr 
33c6				; TODO consume toks until we get to THEN 
33c6			 
33c6 2a fd f3			ld hl, (os_tok_ptr) 
33c9					if DEBUG_FORTH_WORDS 
33c9						DMARK "IF3" 
33c9 f5				push af  
33ca 3a de 33			ld a, (.dmark)  
33cd 32 a6 fd			ld (debug_mark),a  
33d0 3a df 33			ld a, (.dmark+1)  
33d3 32 a7 fd			ld (debug_mark+1),a  
33d6 3a e0 33			ld a, (.dmark+2)  
33d9 32 a8 fd			ld (debug_mark+2),a  
33dc 18 03			jr .pastdmark  
33de ..			.dmark: db "IF3"  
33e1 f1			.pastdmark: pop af  
33e2			endm  
# End of macro DMARK
33e2						CALLMONITOR 
33e2 cd aa fd			call debug_vector  
33e5				endm  
# End of macro CALLMONITOR
33e5						 
33e5					endif 
33e5 11 2c 34			ld de, .ifthen 
33e8					if DEBUG_FORTH_WORDS 
33e8						DMARK "IF4" 
33e8 f5				push af  
33e9 3a fd 33			ld a, (.dmark)  
33ec 32 a6 fd			ld (debug_mark),a  
33ef 3a fe 33			ld a, (.dmark+1)  
33f2 32 a7 fd			ld (debug_mark+1),a  
33f5 3a ff 33			ld a, (.dmark+2)  
33f8 32 a8 fd			ld (debug_mark+2),a  
33fb 18 03			jr .pastdmark  
33fd ..			.dmark: db "IF4"  
3400 f1			.pastdmark: pop af  
3401			endm  
# End of macro DMARK
3401						CALLMONITOR 
3401 cd aa fd			call debug_vector  
3404				endm  
# End of macro CALLMONITOR
3404					endif 
3404 cd eb 24			call findnexttok  
3407			 
3407					if DEBUG_FORTH_WORDS 
3407						DMARK "IF5" 
3407 f5				push af  
3408 3a 1c 34			ld a, (.dmark)  
340b 32 a6 fd			ld (debug_mark),a  
340e 3a 1d 34			ld a, (.dmark+1)  
3411 32 a7 fd			ld (debug_mark+1),a  
3414 3a 1e 34			ld a, (.dmark+2)  
3417 32 a8 fd			ld (debug_mark+2),a  
341a 18 03			jr .pastdmark  
341c ..			.dmark: db "IF5"  
341f f1			.pastdmark: pop af  
3420			endm  
# End of macro DMARK
3420						CALLMONITOR 
3420 cd aa fd			call debug_vector  
3423				endm  
# End of macro CALLMONITOR
3423					endif 
3423				; TODO replace below with ; exec using tok_ptr 
3423 22 fd f3			ld (os_tok_ptr), hl 
3426 c3 61 24			jp exec1 
3429				NEXTW 
3429 c3 d0 23			jp macro_next 
342c				endm 
# End of macro NEXTW
342c			 
342c .. 00		.ifthen:  db "THEN",0 
3431			 
3431			.iftrue:		 
3431				; Exec next words normally 
3431			 
3431				; if true then exec following IF as normal 
3431					if DEBUG_FORTH_WORDS 
3431						DMARK "IFT" 
3431 f5				push af  
3432 3a 46 34			ld a, (.dmark)  
3435 32 a6 fd			ld (debug_mark),a  
3438 3a 47 34			ld a, (.dmark+1)  
343b 32 a7 fd			ld (debug_mark+1),a  
343e 3a 48 34			ld a, (.dmark+2)  
3441 32 a8 fd			ld (debug_mark+2),a  
3444 18 03			jr .pastdmark  
3446 ..			.dmark: db "IFT"  
3449 f1			.pastdmark: pop af  
344a			endm  
# End of macro DMARK
344a						CALLMONITOR 
344a cd aa fd			call debug_vector  
344d				endm  
# End of macro CALLMONITOR
344d					endif 
344d			 
344d					NEXTW 
344d c3 d0 23			jp macro_next 
3450				endm 
# End of macro NEXTW
3450			.THEN: 
3450				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3450 1f				db WORD_SYS_CORE+11             
3451 78 34			dw .ELSE            
3453 05				db 4 + 1 
3454 .. 00			db "THEN",0              
3459				endm 
# End of macro CWHEAD
3459			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3459					if DEBUG_FORTH_WORDS_KEY 
3459						DMARK "THN" 
3459 f5				push af  
345a 3a 6e 34			ld a, (.dmark)  
345d 32 a6 fd			ld (debug_mark),a  
3460 3a 6f 34			ld a, (.dmark+1)  
3463 32 a7 fd			ld (debug_mark+1),a  
3466 3a 70 34			ld a, (.dmark+2)  
3469 32 a8 fd			ld (debug_mark+2),a  
346c 18 03			jr .pastdmark  
346e ..			.dmark: db "THN"  
3471 f1			.pastdmark: pop af  
3472			endm  
# End of macro DMARK
3472						CALLMONITOR 
3472 cd aa fd			call debug_vector  
3475				endm  
# End of macro CALLMONITOR
3475					endif 
3475					NEXTW 
3475 c3 d0 23			jp macro_next 
3478				endm 
# End of macro NEXTW
3478			.ELSE: 
3478				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3478 20				db WORD_SYS_CORE+12             
3479 a0 34			dw .DO            
347b 03				db 2 + 1 
347c .. 00			db "ELSE",0              
3481				endm 
# End of macro CWHEAD
3481			; | ELSE ( -- ) Not supported - does nothing | TODO 
3481			 
3481					if DEBUG_FORTH_WORDS_KEY 
3481						DMARK "ELS" 
3481 f5				push af  
3482 3a 96 34			ld a, (.dmark)  
3485 32 a6 fd			ld (debug_mark),a  
3488 3a 97 34			ld a, (.dmark+1)  
348b 32 a7 fd			ld (debug_mark+1),a  
348e 3a 98 34			ld a, (.dmark+2)  
3491 32 a8 fd			ld (debug_mark+2),a  
3494 18 03			jr .pastdmark  
3496 ..			.dmark: db "ELS"  
3499 f1			.pastdmark: pop af  
349a			endm  
# End of macro DMARK
349a						CALLMONITOR 
349a cd aa fd			call debug_vector  
349d				endm  
# End of macro CALLMONITOR
349d					endif 
349d			 
349d			 
349d					NEXTW 
349d c3 d0 23			jp macro_next 
34a0				endm 
# End of macro NEXTW
34a0			.DO: 
34a0				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34a0 21				db WORD_SYS_CORE+13             
34a1 c7 35			dw .LOOP            
34a3 03				db 2 + 1 
34a4 .. 00			db "DO",0              
34a7				endm 
# End of macro CWHEAD
34a7			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34a7			 
34a7					if DEBUG_FORTH_WORDS_KEY 
34a7						DMARK "DO." 
34a7 f5				push af  
34a8 3a bc 34			ld a, (.dmark)  
34ab 32 a6 fd			ld (debug_mark),a  
34ae 3a bd 34			ld a, (.dmark+1)  
34b1 32 a7 fd			ld (debug_mark+1),a  
34b4 3a be 34			ld a, (.dmark+2)  
34b7 32 a8 fd			ld (debug_mark+2),a  
34ba 18 03			jr .pastdmark  
34bc ..			.dmark: db "DO."  
34bf f1			.pastdmark: pop af  
34c0			endm  
# End of macro DMARK
34c0						CALLMONITOR 
34c0 cd aa fd			call debug_vector  
34c3				endm  
# End of macro CALLMONITOR
34c3					endif 
34c3			;  push pc to rsp stack past the DO 
34c3			 
34c3 2a fd f3				ld hl, (os_tok_ptr) 
34c6 23					inc hl   ; D 
34c7 23					inc hl  ; O 
34c8 23					inc hl   ; null 
34c9					if DEBUG_FORTH_WORDS 
34c9						DMARK "DO2" 
34c9 f5				push af  
34ca 3a de 34			ld a, (.dmark)  
34cd 32 a6 fd			ld (debug_mark),a  
34d0 3a df 34			ld a, (.dmark+1)  
34d3 32 a7 fd			ld (debug_mark+1),a  
34d6 3a e0 34			ld a, (.dmark+2)  
34d9 32 a8 fd			ld (debug_mark+2),a  
34dc 18 03			jr .pastdmark  
34de ..			.dmark: db "DO2"  
34e1 f1			.pastdmark: pop af  
34e2			endm  
# End of macro DMARK
34e2						CALLMONITOR 
34e2 cd aa fd			call debug_vector  
34e5				endm  
# End of macro CALLMONITOR
34e5					endif 
34e5					FORTH_RSP_NEXT 
34e5 cd ca 1f			call macro_forth_rsp_next 
34e8				endm 
# End of macro FORTH_RSP_NEXT
34e8					if DEBUG_FORTH_WORDS 
34e8						DMARK "DO3" 
34e8 f5				push af  
34e9 3a fd 34			ld a, (.dmark)  
34ec 32 a6 fd			ld (debug_mark),a  
34ef 3a fe 34			ld a, (.dmark+1)  
34f2 32 a7 fd			ld (debug_mark+1),a  
34f5 3a ff 34			ld a, (.dmark+2)  
34f8 32 a8 fd			ld (debug_mark+2),a  
34fb 18 03			jr .pastdmark  
34fd ..			.dmark: db "DO3"  
3500 f1			.pastdmark: pop af  
3501			endm  
# End of macro DMARK
3501						CALLMONITOR 
3501 cd aa fd			call debug_vector  
3504				endm  
# End of macro CALLMONITOR
3504					endif 
3504			 
3504					;if DEBUG_FORTH_WORDS 
3504				;		push hl 
3504			;		endif  
3504			 
3504			; get counters from data stack 
3504			 
3504			 
3504					FORTH_DSP_VALUEHL 
3504 cd 1a 22			call macro_dsp_valuehl 
3507				endm 
# End of macro FORTH_DSP_VALUEHL
3507 e5					push hl		 ; hl now has starting counter which needs to be tos 
3508			 
3508					if DEBUG_FORTH_WORDS 
3508						DMARK "DO4" 
3508 f5				push af  
3509 3a 1d 35			ld a, (.dmark)  
350c 32 a6 fd			ld (debug_mark),a  
350f 3a 1e 35			ld a, (.dmark+1)  
3512 32 a7 fd			ld (debug_mark+1),a  
3515 3a 1f 35			ld a, (.dmark+2)  
3518 32 a8 fd			ld (debug_mark+2),a  
351b 18 03			jr .pastdmark  
351d ..			.dmark: db "DO4"  
3520 f1			.pastdmark: pop af  
3521			endm  
# End of macro DMARK
3521						CALLMONITOR 
3521 cd aa fd			call debug_vector  
3524				endm  
# End of macro CALLMONITOR
3524					endif 
3524					FORTH_DSP_POP 
3524 cd d2 22			call macro_forth_dsp_pop 
3527				endm 
# End of macro FORTH_DSP_POP
3527			 
3527					if DEBUG_FORTH_WORDS 
3527						DMARK "DO5" 
3527 f5				push af  
3528 3a 3c 35			ld a, (.dmark)  
352b 32 a6 fd			ld (debug_mark),a  
352e 3a 3d 35			ld a, (.dmark+1)  
3531 32 a7 fd			ld (debug_mark+1),a  
3534 3a 3e 35			ld a, (.dmark+2)  
3537 32 a8 fd			ld (debug_mark+2),a  
353a 18 03			jr .pastdmark  
353c ..			.dmark: db "DO5"  
353f f1			.pastdmark: pop af  
3540			endm  
# End of macro DMARK
3540						CALLMONITOR 
3540 cd aa fd			call debug_vector  
3543				endm  
# End of macro CALLMONITOR
3543					endif 
3543			 
3543					FORTH_DSP_VALUEHL 
3543 cd 1a 22			call macro_dsp_valuehl 
3546				endm 
# End of macro FORTH_DSP_VALUEHL
3546			;		push hl		 ; hl now has starting limit counter 
3546			 
3546					if DEBUG_FORTH_WORDS 
3546						DMARK "DO6" 
3546 f5				push af  
3547 3a 5b 35			ld a, (.dmark)  
354a 32 a6 fd			ld (debug_mark),a  
354d 3a 5c 35			ld a, (.dmark+1)  
3550 32 a7 fd			ld (debug_mark+1),a  
3553 3a 5d 35			ld a, (.dmark+2)  
3556 32 a8 fd			ld (debug_mark+2),a  
3559 18 03			jr .pastdmark  
355b ..			.dmark: db "DO6"  
355e f1			.pastdmark: pop af  
355f			endm  
# End of macro DMARK
355f						CALLMONITOR 
355f cd aa fd			call debug_vector  
3562				endm  
# End of macro CALLMONITOR
3562					endif 
3562					FORTH_DSP_POP 
3562 cd d2 22			call macro_forth_dsp_pop 
3565				endm 
# End of macro FORTH_DSP_POP
3565			 
3565			; put counters on the loop stack 
3565			 
3565			;		pop hl			 ; limit counter 
3565 d1					pop de			; start counter 
3566			 
3566					; push limit counter 
3566			 
3566					if DEBUG_FORTH_WORDS 
3566						DMARK "DO7" 
3566 f5				push af  
3567 3a 7b 35			ld a, (.dmark)  
356a 32 a6 fd			ld (debug_mark),a  
356d 3a 7c 35			ld a, (.dmark+1)  
3570 32 a7 fd			ld (debug_mark+1),a  
3573 3a 7d 35			ld a, (.dmark+2)  
3576 32 a8 fd			ld (debug_mark+2),a  
3579 18 03			jr .pastdmark  
357b ..			.dmark: db "DO7"  
357e f1			.pastdmark: pop af  
357f			endm  
# End of macro DMARK
357f						CALLMONITOR 
357f cd aa fd			call debug_vector  
3582				endm  
# End of macro CALLMONITOR
3582					endif 
3582					FORTH_LOOP_NEXT 
3582 cd 4b 22			call macro_forth_loop_next 
3585				endm 
# End of macro FORTH_LOOP_NEXT
3585			 
3585					; push start counter 
3585			 
3585 eb					ex de, hl 
3586					if DEBUG_FORTH_WORDS 
3586						DMARK "DO7" 
3586 f5				push af  
3587 3a 9b 35			ld a, (.dmark)  
358a 32 a6 fd			ld (debug_mark),a  
358d 3a 9c 35			ld a, (.dmark+1)  
3590 32 a7 fd			ld (debug_mark+1),a  
3593 3a 9d 35			ld a, (.dmark+2)  
3596 32 a8 fd			ld (debug_mark+2),a  
3599 18 03			jr .pastdmark  
359b ..			.dmark: db "DO7"  
359e f1			.pastdmark: pop af  
359f			endm  
# End of macro DMARK
359f						CALLMONITOR 
359f cd aa fd			call debug_vector  
35a2				endm  
# End of macro CALLMONITOR
35a2					endif 
35a2					FORTH_LOOP_NEXT 
35a2 cd 4b 22			call macro_forth_loop_next 
35a5				endm 
# End of macro FORTH_LOOP_NEXT
35a5			 
35a5			 
35a5					; init first round of I counter 
35a5			 
35a5 22 21 f4				ld (os_current_i), hl 
35a8			 
35a8					if DEBUG_FORTH_WORDS 
35a8						DMARK "DO8" 
35a8 f5				push af  
35a9 3a bd 35			ld a, (.dmark)  
35ac 32 a6 fd			ld (debug_mark),a  
35af 3a be 35			ld a, (.dmark+1)  
35b2 32 a7 fd			ld (debug_mark+1),a  
35b5 3a bf 35			ld a, (.dmark+2)  
35b8 32 a8 fd			ld (debug_mark+2),a  
35bb 18 03			jr .pastdmark  
35bd ..			.dmark: db "DO8"  
35c0 f1			.pastdmark: pop af  
35c1			endm  
# End of macro DMARK
35c1						CALLMONITOR 
35c1 cd aa fd			call debug_vector  
35c4				endm  
# End of macro CALLMONITOR
35c4					endif 
35c4			 
35c4					NEXTW 
35c4 c3 d0 23			jp macro_next 
35c7				endm 
# End of macro NEXTW
35c7			.LOOP: 
35c7				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35c7 22				db WORD_SYS_CORE+14             
35c8 df 36			dw .I            
35ca 05				db 4 + 1 
35cb .. 00			db "LOOP",0              
35d0				endm 
# End of macro CWHEAD
35d0			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35d0			 
35d0				; pop tos as current loop count to hl 
35d0			 
35d0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35d0			 
35d0				FORTH_LOOP_TOS 
35d0 cd 7e 22			call macro_forth_loop_tos 
35d3				endm 
# End of macro FORTH_LOOP_TOS
35d3 e5				push hl 
35d4			 
35d4					if DEBUG_FORTH_WORDS_KEY 
35d4						DMARK "LOP" 
35d4 f5				push af  
35d5 3a e9 35			ld a, (.dmark)  
35d8 32 a6 fd			ld (debug_mark),a  
35db 3a ea 35			ld a, (.dmark+1)  
35de 32 a7 fd			ld (debug_mark+1),a  
35e1 3a eb 35			ld a, (.dmark+2)  
35e4 32 a8 fd			ld (debug_mark+2),a  
35e7 18 03			jr .pastdmark  
35e9 ..			.dmark: db "LOP"  
35ec f1			.pastdmark: pop af  
35ed			endm  
# End of macro DMARK
35ed						CALLMONITOR 
35ed cd aa fd			call debug_vector  
35f0				endm  
# End of macro CALLMONITOR
35f0					endif 
35f0				; next item on the stack is the limit. get it 
35f0			 
35f0			 
35f0				FORTH_LOOP_POP 
35f0 cd 88 22			call macro_forth_loop_pop 
35f3				endm 
# End of macro FORTH_LOOP_POP
35f3			 
35f3				FORTH_LOOP_TOS 
35f3 cd 7e 22			call macro_forth_loop_tos 
35f6				endm 
# End of macro FORTH_LOOP_TOS
35f6			 
35f6 d1				pop de		 ; de = i, hl = limit 
35f7			 
35f7					if DEBUG_FORTH_WORDS 
35f7						DMARK "LP1" 
35f7 f5				push af  
35f8 3a 0c 36			ld a, (.dmark)  
35fb 32 a6 fd			ld (debug_mark),a  
35fe 3a 0d 36			ld a, (.dmark+1)  
3601 32 a7 fd			ld (debug_mark+1),a  
3604 3a 0e 36			ld a, (.dmark+2)  
3607 32 a8 fd			ld (debug_mark+2),a  
360a 18 03			jr .pastdmark  
360c ..			.dmark: db "LP1"  
360f f1			.pastdmark: pop af  
3610			endm  
# End of macro DMARK
3610						CALLMONITOR 
3610 cd aa fd			call debug_vector  
3613				endm  
# End of macro CALLMONITOR
3613					endif 
3613			 
3613				; go back to previous word 
3613			 
3613 d5				push de    ; save I for inc later 
3614			 
3614			 
3614				; get limit 
3614				;  is I at limit? 
3614			 
3614			 
3614					if DEBUG_FORTH_WORDS 
3614						DMARK "LP1" 
3614 f5				push af  
3615 3a 29 36			ld a, (.dmark)  
3618 32 a6 fd			ld (debug_mark),a  
361b 3a 2a 36			ld a, (.dmark+1)  
361e 32 a7 fd			ld (debug_mark+1),a  
3621 3a 2b 36			ld a, (.dmark+2)  
3624 32 a8 fd			ld (debug_mark+2),a  
3627 18 03			jr .pastdmark  
3629 ..			.dmark: db "LP1"  
362c f1			.pastdmark: pop af  
362d			endm  
# End of macro DMARK
362d						CALLMONITOR 
362d cd aa fd			call debug_vector  
3630				endm  
# End of macro CALLMONITOR
3630					endif 
3630			 
3630 ed 52			sbc hl, de 
3632			 
3632			 
3632				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3632			 
3632 20 26				jr nz, .loopnotdone 
3634			 
3634 e1				pop hl   ; get rid of saved I 
3635				FORTH_LOOP_POP     ; get rid of limit 
3635 cd 88 22			call macro_forth_loop_pop 
3638				endm 
# End of macro FORTH_LOOP_POP
3638			 
3638				FORTH_RSP_POP     ; get rid of DO ptr 
3638 cd eb 1f			call macro_forth_rsp_pop 
363b				endm 
# End of macro FORTH_RSP_POP
363b			 
363b			if DEBUG_FORTH_WORDS 
363b						DMARK "LP>" 
363b f5				push af  
363c 3a 50 36			ld a, (.dmark)  
363f 32 a6 fd			ld (debug_mark),a  
3642 3a 51 36			ld a, (.dmark+1)  
3645 32 a7 fd			ld (debug_mark+1),a  
3648 3a 52 36			ld a, (.dmark+2)  
364b 32 a8 fd			ld (debug_mark+2),a  
364e 18 03			jr .pastdmark  
3650 ..			.dmark: db "LP>"  
3653 f1			.pastdmark: pop af  
3654			endm  
# End of macro DMARK
3654				CALLMONITOR 
3654 cd aa fd			call debug_vector  
3657				endm  
# End of macro CALLMONITOR
3657			endif 
3657			 
3657					NEXTW 
3657 c3 d0 23			jp macro_next 
365a				endm 
# End of macro NEXTW
365a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
365a			 
365a			.loopnotdone: 
365a			 
365a e1				pop hl    ; get I 
365b 23				inc hl 
365c			 
365c			   	; save new I 
365c			 
365c			 
365c					; set I counter 
365c			 
365c 22 21 f4				ld (os_current_i), hl 
365f			 
365f					if DEBUG_FORTH_WORDS 
365f						DMARK "LPN" 
365f f5				push af  
3660 3a 74 36			ld a, (.dmark)  
3663 32 a6 fd			ld (debug_mark),a  
3666 3a 75 36			ld a, (.dmark+1)  
3669 32 a7 fd			ld (debug_mark+1),a  
366c 3a 76 36			ld a, (.dmark+2)  
366f 32 a8 fd			ld (debug_mark+2),a  
3672 18 03			jr .pastdmark  
3674 ..			.dmark: db "LPN"  
3677 f1			.pastdmark: pop af  
3678			endm  
# End of macro DMARK
3678					CALLMONITOR 
3678 cd aa fd			call debug_vector  
367b				endm  
# End of macro CALLMONITOR
367b					endif 
367b					 
367b				FORTH_LOOP_NEXT 
367b cd 4b 22			call macro_forth_loop_next 
367e				endm 
# End of macro FORTH_LOOP_NEXT
367e			 
367e			 
367e					if DEBUG_FORTH_WORDS 
367e eb						ex de,hl 
367f					endif 
367f			 
367f			;	; get DO ptr 
367f			; 
367f					if DEBUG_FORTH_WORDS 
367f						DMARK "LP7" 
367f f5				push af  
3680 3a 94 36			ld a, (.dmark)  
3683 32 a6 fd			ld (debug_mark),a  
3686 3a 95 36			ld a, (.dmark+1)  
3689 32 a7 fd			ld (debug_mark+1),a  
368c 3a 96 36			ld a, (.dmark+2)  
368f 32 a8 fd			ld (debug_mark+2),a  
3692 18 03			jr .pastdmark  
3694 ..			.dmark: db "LP7"  
3697 f1			.pastdmark: pop af  
3698			endm  
# End of macro DMARK
3698					CALLMONITOR 
3698 cd aa fd			call debug_vector  
369b				endm  
# End of macro CALLMONITOR
369b					endif 
369b				FORTH_RSP_TOS 
369b cd e1 1f			call macro_forth_rsp_tos 
369e				endm 
# End of macro FORTH_RSP_TOS
369e			 
369e					if DEBUG_FORTH_WORDS 
369e						DMARK "LP8" 
369e f5				push af  
369f 3a b3 36			ld a, (.dmark)  
36a2 32 a6 fd			ld (debug_mark),a  
36a5 3a b4 36			ld a, (.dmark+1)  
36a8 32 a7 fd			ld (debug_mark+1),a  
36ab 3a b5 36			ld a, (.dmark+2)  
36ae 32 a8 fd			ld (debug_mark+2),a  
36b1 18 03			jr .pastdmark  
36b3 ..			.dmark: db "LP8"  
36b6 f1			.pastdmark: pop af  
36b7			endm  
# End of macro DMARK
36b7					CALLMONITOR 
36b7 cd aa fd			call debug_vector  
36ba				endm  
# End of macro CALLMONITOR
36ba					endif 
36ba				;push hl 
36ba			 
36ba				; not going to DO any more 
36ba				; get rid of the RSP pointer as DO will add it back in 
36ba				;FORTH_RSP_POP 
36ba				;pop hl 
36ba			 
36ba				;ld hl,(cli_ret_sp) 
36ba				;ld e, (hl) 
36ba				;inc hl 
36ba				;ld d, (hl) 
36ba				;ex de,hl 
36ba 22 fd f3			ld (os_tok_ptr), hl 
36bd					if DEBUG_FORTH_WORDS 
36bd						DMARK "LP<" 
36bd f5				push af  
36be 3a d2 36			ld a, (.dmark)  
36c1 32 a6 fd			ld (debug_mark),a  
36c4 3a d3 36			ld a, (.dmark+1)  
36c7 32 a7 fd			ld (debug_mark+1),a  
36ca 3a d4 36			ld a, (.dmark+2)  
36cd 32 a8 fd			ld (debug_mark+2),a  
36d0 18 03			jr .pastdmark  
36d2 ..			.dmark: db "LP<"  
36d5 f1			.pastdmark: pop af  
36d6			endm  
# End of macro DMARK
36d6					CALLMONITOR 
36d6 cd aa fd			call debug_vector  
36d9				endm  
# End of macro CALLMONITOR
36d9				endif 
36d9 c3 61 24			jp exec1 
36dc			 
36dc					 
36dc			 
36dc			 
36dc					NEXTW 
36dc c3 d0 23			jp macro_next 
36df				endm 
# End of macro NEXTW
36df			.I:  
36df			 
36df				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
36df 5e				db WORD_SYS_CORE+74             
36e0 0a 37			dw .DLOOP            
36e2 02				db 1 + 1 
36e3 .. 00			db "I",0              
36e5				endm 
# End of macro CWHEAD
36e5			; | I ( -- ) Current loop counter | DONE 
36e5					if DEBUG_FORTH_WORDS_KEY 
36e5						DMARK "I.." 
36e5 f5				push af  
36e6 3a fa 36			ld a, (.dmark)  
36e9 32 a6 fd			ld (debug_mark),a  
36ec 3a fb 36			ld a, (.dmark+1)  
36ef 32 a7 fd			ld (debug_mark+1),a  
36f2 3a fc 36			ld a, (.dmark+2)  
36f5 32 a8 fd			ld (debug_mark+2),a  
36f8 18 03			jr .pastdmark  
36fa ..			.dmark: db "I.."  
36fd f1			.pastdmark: pop af  
36fe			endm  
# End of macro DMARK
36fe						CALLMONITOR 
36fe cd aa fd			call debug_vector  
3701				endm  
# End of macro CALLMONITOR
3701					endif 
3701			 
3701 2a 21 f4				ld hl,(os_current_i) 
3704 cd 23 20				call forth_push_numhl 
3707			 
3707					NEXTW 
3707 c3 d0 23			jp macro_next 
370a				endm 
# End of macro NEXTW
370a			.DLOOP: 
370a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
370a 5f				db WORD_SYS_CORE+75             
370b eb 37			dw .REPEAT            
370d 06				db 5 + 1 
370e .. 00			db "-LOOP",0              
3714				endm 
# End of macro CWHEAD
3714			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3714				; pop tos as current loop count to hl 
3714					if DEBUG_FORTH_WORDS_KEY 
3714						DMARK "-LP" 
3714 f5				push af  
3715 3a 29 37			ld a, (.dmark)  
3718 32 a6 fd			ld (debug_mark),a  
371b 3a 2a 37			ld a, (.dmark+1)  
371e 32 a7 fd			ld (debug_mark+1),a  
3721 3a 2b 37			ld a, (.dmark+2)  
3724 32 a8 fd			ld (debug_mark+2),a  
3727 18 03			jr .pastdmark  
3729 ..			.dmark: db "-LP"  
372c f1			.pastdmark: pop af  
372d			endm  
# End of macro DMARK
372d						CALLMONITOR 
372d cd aa fd			call debug_vector  
3730				endm  
# End of macro CALLMONITOR
3730					endif 
3730			 
3730				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3730			 
3730				FORTH_LOOP_TOS 
3730 cd 7e 22			call macro_forth_loop_tos 
3733				endm 
# End of macro FORTH_LOOP_TOS
3733 e5				push hl 
3734			 
3734					if DEBUG_FORTH_WORDS 
3734						DMARK "-LP" 
3734 f5				push af  
3735 3a 49 37			ld a, (.dmark)  
3738 32 a6 fd			ld (debug_mark),a  
373b 3a 4a 37			ld a, (.dmark+1)  
373e 32 a7 fd			ld (debug_mark+1),a  
3741 3a 4b 37			ld a, (.dmark+2)  
3744 32 a8 fd			ld (debug_mark+2),a  
3747 18 03			jr .pastdmark  
3749 ..			.dmark: db "-LP"  
374c f1			.pastdmark: pop af  
374d			endm  
# End of macro DMARK
374d						CALLMONITOR 
374d cd aa fd			call debug_vector  
3750				endm  
# End of macro CALLMONITOR
3750					endif 
3750				; next item on the stack is the limit. get it 
3750			 
3750			 
3750				FORTH_LOOP_POP 
3750 cd 88 22			call macro_forth_loop_pop 
3753				endm 
# End of macro FORTH_LOOP_POP
3753			 
3753				FORTH_LOOP_TOS 
3753 cd 7e 22			call macro_forth_loop_tos 
3756				endm 
# End of macro FORTH_LOOP_TOS
3756			 
3756 d1				pop de		 ; de = i, hl = limit 
3757			 
3757					if DEBUG_FORTH_WORDS 
3757						DMARK "-L1" 
3757 f5				push af  
3758 3a 6c 37			ld a, (.dmark)  
375b 32 a6 fd			ld (debug_mark),a  
375e 3a 6d 37			ld a, (.dmark+1)  
3761 32 a7 fd			ld (debug_mark+1),a  
3764 3a 6e 37			ld a, (.dmark+2)  
3767 32 a8 fd			ld (debug_mark+2),a  
376a 18 03			jr .pastdmark  
376c ..			.dmark: db "-L1"  
376f f1			.pastdmark: pop af  
3770			endm  
# End of macro DMARK
3770						CALLMONITOR 
3770 cd aa fd			call debug_vector  
3773				endm  
# End of macro CALLMONITOR
3773					endif 
3773			 
3773				; go back to previous word 
3773			 
3773 d5				push de    ; save I for inc later 
3774			 
3774			 
3774				; get limit 
3774				;  is I at limit? 
3774			 
3774			 
3774					if DEBUG_FORTH_WORDS 
3774						DMARK "-L1" 
3774 f5				push af  
3775 3a 89 37			ld a, (.dmark)  
3778 32 a6 fd			ld (debug_mark),a  
377b 3a 8a 37			ld a, (.dmark+1)  
377e 32 a7 fd			ld (debug_mark+1),a  
3781 3a 8b 37			ld a, (.dmark+2)  
3784 32 a8 fd			ld (debug_mark+2),a  
3787 18 03			jr .pastdmark  
3789 ..			.dmark: db "-L1"  
378c f1			.pastdmark: pop af  
378d			endm  
# End of macro DMARK
378d						CALLMONITOR 
378d cd aa fd			call debug_vector  
3790				endm  
# End of macro CALLMONITOR
3790					endif 
3790			 
3790 ed 52			sbc hl, de 
3792			 
3792			 
3792				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3792			 
3792 20 26				jr nz, .mloopnotdone 
3794			 
3794 e1				pop hl   ; get rid of saved I 
3795				FORTH_LOOP_POP     ; get rid of limit 
3795 cd 88 22			call macro_forth_loop_pop 
3798				endm 
# End of macro FORTH_LOOP_POP
3798			 
3798				FORTH_RSP_POP     ; get rid of DO ptr 
3798 cd eb 1f			call macro_forth_rsp_pop 
379b				endm 
# End of macro FORTH_RSP_POP
379b			 
379b			if DEBUG_FORTH_WORDS 
379b						DMARK "-L>" 
379b f5				push af  
379c 3a b0 37			ld a, (.dmark)  
379f 32 a6 fd			ld (debug_mark),a  
37a2 3a b1 37			ld a, (.dmark+1)  
37a5 32 a7 fd			ld (debug_mark+1),a  
37a8 3a b2 37			ld a, (.dmark+2)  
37ab 32 a8 fd			ld (debug_mark+2),a  
37ae 18 03			jr .pastdmark  
37b0 ..			.dmark: db "-L>"  
37b3 f1			.pastdmark: pop af  
37b4			endm  
# End of macro DMARK
37b4				CALLMONITOR 
37b4 cd aa fd			call debug_vector  
37b7				endm  
# End of macro CALLMONITOR
37b7			endif 
37b7			 
37b7					NEXTW 
37b7 c3 d0 23			jp macro_next 
37ba				endm 
# End of macro NEXTW
37ba				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37ba			 
37ba			.mloopnotdone: 
37ba			 
37ba e1				pop hl    ; get I 
37bb 2b				dec hl 
37bc			 
37bc			   	; save new I 
37bc			 
37bc			 
37bc					; set I counter 
37bc			 
37bc 22 21 f4				ld (os_current_i), hl 
37bf			 
37bf					 
37bf				FORTH_LOOP_NEXT 
37bf cd 4b 22			call macro_forth_loop_next 
37c2				endm 
# End of macro FORTH_LOOP_NEXT
37c2			 
37c2			 
37c2					if DEBUG_FORTH_WORDS 
37c2 eb						ex de,hl 
37c3					endif 
37c3			 
37c3			;	; get DO ptr 
37c3			; 
37c3				FORTH_RSP_TOS 
37c3 cd e1 1f			call macro_forth_rsp_tos 
37c6				endm 
# End of macro FORTH_RSP_TOS
37c6			 
37c6				;push hl 
37c6			 
37c6				; not going to DO any more 
37c6				; get rid of the RSP pointer as DO will add it back in 
37c6				;FORTH_RSP_POP 
37c6				;pop hl 
37c6			 
37c6			 
37c6 22 fd f3			ld (os_tok_ptr), hl 
37c9					if DEBUG_FORTH_WORDS 
37c9						DMARK "-L<" 
37c9 f5				push af  
37ca 3a de 37			ld a, (.dmark)  
37cd 32 a6 fd			ld (debug_mark),a  
37d0 3a df 37			ld a, (.dmark+1)  
37d3 32 a7 fd			ld (debug_mark+1),a  
37d6 3a e0 37			ld a, (.dmark+2)  
37d9 32 a8 fd			ld (debug_mark+2),a  
37dc 18 03			jr .pastdmark  
37de ..			.dmark: db "-L<"  
37e1 f1			.pastdmark: pop af  
37e2			endm  
# End of macro DMARK
37e2					CALLMONITOR 
37e2 cd aa fd			call debug_vector  
37e5				endm  
# End of macro CALLMONITOR
37e5				endif 
37e5 c3 61 24			jp exec1 
37e8			 
37e8					 
37e8			 
37e8			 
37e8			 
37e8				NEXTW 
37e8 c3 d0 23			jp macro_next 
37eb				endm 
# End of macro NEXTW
37eb			 
37eb			 
37eb			 
37eb			 
37eb			.REPEAT: 
37eb				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
37eb 71				db WORD_SYS_CORE+93             
37ec 3e 38			dw .UNTIL            
37ee 06				db 5 + 1 
37ef .. 00			db "REPEAT",0              
37f6				endm 
# End of macro CWHEAD
37f6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
37f6			;  push pc to rsp stack past the REPEAT 
37f6					if DEBUG_FORTH_WORDS_KEY 
37f6						DMARK "REP" 
37f6 f5				push af  
37f7 3a 0b 38			ld a, (.dmark)  
37fa 32 a6 fd			ld (debug_mark),a  
37fd 3a 0c 38			ld a, (.dmark+1)  
3800 32 a7 fd			ld (debug_mark+1),a  
3803 3a 0d 38			ld a, (.dmark+2)  
3806 32 a8 fd			ld (debug_mark+2),a  
3809 18 03			jr .pastdmark  
380b ..			.dmark: db "REP"  
380e f1			.pastdmark: pop af  
380f			endm  
# End of macro DMARK
380f						CALLMONITOR 
380f cd aa fd			call debug_vector  
3812				endm  
# End of macro CALLMONITOR
3812					endif 
3812			 
3812 2a fd f3				ld hl, (os_tok_ptr) 
3815 23					inc hl   ; R 
3816 23					inc hl  ; E 
3817 23					inc hl   ; P 
3818 23					inc hl   ; E 
3819 23					inc hl   ; A 
381a 23					inc hl   ; T 
381b 23					inc hl   ; zero 
381c					FORTH_RSP_NEXT 
381c cd ca 1f			call macro_forth_rsp_next 
381f				endm 
# End of macro FORTH_RSP_NEXT
381f			 
381f			 
381f					if DEBUG_FORTH_WORDS 
381f						DMARK "REP" 
381f f5				push af  
3820 3a 34 38			ld a, (.dmark)  
3823 32 a6 fd			ld (debug_mark),a  
3826 3a 35 38			ld a, (.dmark+1)  
3829 32 a7 fd			ld (debug_mark+1),a  
382c 3a 36 38			ld a, (.dmark+2)  
382f 32 a8 fd			ld (debug_mark+2),a  
3832 18 03			jr .pastdmark  
3834 ..			.dmark: db "REP"  
3837 f1			.pastdmark: pop af  
3838			endm  
# End of macro DMARK
3838						;pop bc    ; TODO BUG ?????? what is this for???? 
3838						CALLMONITOR 
3838 cd aa fd			call debug_vector  
383b				endm  
# End of macro CALLMONITOR
383b					endif 
383b			 
383b					NEXTW 
383b c3 d0 23			jp macro_next 
383e				endm 
# End of macro NEXTW
383e			;	       NEXTW 
383e			 
383e			.UNTIL: 
383e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
383e 72				db WORD_SYS_CORE+94             
383f d5 38			dw .ENDFLOW            
3841 06				db 5 + 1 
3842 .. 00			db "UNTIL",0              
3848				endm 
# End of macro CWHEAD
3848			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3848			 
3848				; pop tos as check 
3848			 
3848				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3848			 
3848				FORTH_DSP_VALUEHL 
3848 cd 1a 22			call macro_dsp_valuehl 
384b				endm 
# End of macro FORTH_DSP_VALUEHL
384b			 
384b					if DEBUG_FORTH_WORDS_KEY 
384b						DMARK "UNT" 
384b f5				push af  
384c 3a 60 38			ld a, (.dmark)  
384f 32 a6 fd			ld (debug_mark),a  
3852 3a 61 38			ld a, (.dmark+1)  
3855 32 a7 fd			ld (debug_mark+1),a  
3858 3a 62 38			ld a, (.dmark+2)  
385b 32 a8 fd			ld (debug_mark+2),a  
385e 18 03			jr .pastdmark  
3860 ..			.dmark: db "UNT"  
3863 f1			.pastdmark: pop af  
3864			endm  
# End of macro DMARK
3864						CALLMONITOR 
3864 cd aa fd			call debug_vector  
3867				endm  
# End of macro CALLMONITOR
3867					endif 
3867			 
3867			;	push hl 
3867				FORTH_DSP_POP 
3867 cd d2 22			call macro_forth_dsp_pop 
386a				endm 
# End of macro FORTH_DSP_POP
386a			 
386a			;	pop hl 
386a			 
386a				; test if true 
386a			 
386a cd f8 0f			call ishlzero 
386d			;	ld a,l 
386d			;	add h 
386d			; 
386d			;	cp 0 
386d			 
386d 20 3e			jr nz, .untilnotdone 
386f			 
386f					if DEBUG_FORTH_WORDS 
386f						DMARK "UNf" 
386f f5				push af  
3870 3a 84 38			ld a, (.dmark)  
3873 32 a6 fd			ld (debug_mark),a  
3876 3a 85 38			ld a, (.dmark+1)  
3879 32 a7 fd			ld (debug_mark+1),a  
387c 3a 86 38			ld a, (.dmark+2)  
387f 32 a8 fd			ld (debug_mark+2),a  
3882 18 03			jr .pastdmark  
3884 ..			.dmark: db "UNf"  
3887 f1			.pastdmark: pop af  
3888			endm  
# End of macro DMARK
3888						CALLMONITOR 
3888 cd aa fd			call debug_vector  
388b				endm  
# End of macro CALLMONITOR
388b					endif 
388b			 
388b			 
388b			 
388b				FORTH_RSP_POP     ; get rid of DO ptr 
388b cd eb 1f			call macro_forth_rsp_pop 
388e				endm 
# End of macro FORTH_RSP_POP
388e			 
388e			if DEBUG_FORTH_WORDS 
388e						DMARK "UN>" 
388e f5				push af  
388f 3a a3 38			ld a, (.dmark)  
3892 32 a6 fd			ld (debug_mark),a  
3895 3a a4 38			ld a, (.dmark+1)  
3898 32 a7 fd			ld (debug_mark+1),a  
389b 3a a5 38			ld a, (.dmark+2)  
389e 32 a8 fd			ld (debug_mark+2),a  
38a1 18 03			jr .pastdmark  
38a3 ..			.dmark: db "UN>"  
38a6 f1			.pastdmark: pop af  
38a7			endm  
# End of macro DMARK
38a7				CALLMONITOR 
38a7 cd aa fd			call debug_vector  
38aa				endm  
# End of macro CALLMONITOR
38aa			endif 
38aa			 
38aa					NEXTW 
38aa c3 d0 23			jp macro_next 
38ad				endm 
# End of macro NEXTW
38ad				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38ad			 
38ad			.untilnotdone: 
38ad			 
38ad			 
38ad			;	; get DO ptr 
38ad			; 
38ad				FORTH_RSP_TOS 
38ad cd e1 1f			call macro_forth_rsp_tos 
38b0				endm 
# End of macro FORTH_RSP_TOS
38b0			 
38b0				;push hl 
38b0			 
38b0				; not going to DO any more 
38b0				; get rid of the RSP pointer as DO will add it back in 
38b0				;FORTH_RSP_POP 
38b0				;pop hl 
38b0			 
38b0			 
38b0 22 fd f3			ld (os_tok_ptr), hl 
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "UN<" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 a6 fd			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 a7 fd			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 a8 fd			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "UN<"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc					CALLMONITOR 
38cc cd aa fd			call debug_vector  
38cf				endm  
# End of macro CALLMONITOR
38cf				endif 
38cf c3 61 24			jp exec1 
38d2			 
38d2					 
38d2			 
38d2			 
38d2					NEXTW 
38d2 c3 d0 23			jp macro_next 
38d5				endm 
# End of macro NEXTW
38d5			 
38d5			 
38d5			.ENDFLOW: 
38d5			 
38d5			; eof 
38d5			 
# End of file forth_words_flow.asm
38d5			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38d5			include "forth_words_logic.asm" 
38d5			 
38d5			; | ## Logic Words 
38d5			 
38d5			.NOT: 
38d5				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38d5 2d				db WORD_SYS_CORE+25             
38d6 1d 39			dw .IS            
38d8 04				db 3 + 1 
38d9 .. 00			db "NOT",0              
38dd				endm 
# End of macro CWHEAD
38dd			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
38dd					if DEBUG_FORTH_WORDS_KEY 
38dd						DMARK "NOT" 
38dd f5				push af  
38de 3a f2 38			ld a, (.dmark)  
38e1 32 a6 fd			ld (debug_mark),a  
38e4 3a f3 38			ld a, (.dmark+1)  
38e7 32 a7 fd			ld (debug_mark+1),a  
38ea 3a f4 38			ld a, (.dmark+2)  
38ed 32 a8 fd			ld (debug_mark+2),a  
38f0 18 03			jr .pastdmark  
38f2 ..			.dmark: db "NOT"  
38f5 f1			.pastdmark: pop af  
38f6			endm  
# End of macro DMARK
38f6						CALLMONITOR 
38f6 cd aa fd			call debug_vector  
38f9				endm  
# End of macro CALLMONITOR
38f9					endif 
38f9					FORTH_DSP 
38f9 cd e0 21			call macro_forth_dsp 
38fc				endm 
# End of macro FORTH_DSP
38fc 7e					ld a,(hl)	; get type of value on TOS 
38fd fe 02				cp DS_TYPE_INUM  
38ff 28 03				jr z, .noti 
3901					NEXTW 
3901 c3 d0 23			jp macro_next 
3904				endm 
# End of macro NEXTW
3904			.noti:          FORTH_DSP_VALUEHL 
3904 cd 1a 22			call macro_dsp_valuehl 
3907				endm 
# End of macro FORTH_DSP_VALUEHL
3907			;		push hl 
3907					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3907 cd d2 22			call macro_forth_dsp_pop 
390a				endm 
# End of macro FORTH_DSP_POP
390a			;		pop hl 
390a 3e 00				ld a,0 
390c bd					cp l 
390d 28 04				jr z, .not2t 
390f 2e 00				ld l, 0 
3911 18 02				jr .notip 
3913			 
3913 2e ff		.not2t:		ld l, 255 
3915			 
3915 26 00		.notip:		ld h, 0	 
3917			 
3917 cd 23 20				call forth_push_numhl 
391a					NEXTW 
391a c3 d0 23			jp macro_next 
391d				endm 
# End of macro NEXTW
391d			 
391d			.IS: 
391d				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
391d 2d				db WORD_SYS_CORE+25             
391e 43 39			dw .LZERO            
3920 03				db 2 + 1 
3921 .. 00			db "IS",0              
3924				endm 
# End of macro CWHEAD
3924			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3924					if DEBUG_FORTH_WORDS_KEY 
3924						DMARK "IS." 
3924 f5				push af  
3925 3a 39 39			ld a, (.dmark)  
3928 32 a6 fd			ld (debug_mark),a  
392b 3a 3a 39			ld a, (.dmark+1)  
392e 32 a7 fd			ld (debug_mark+1),a  
3931 3a 3b 39			ld a, (.dmark+2)  
3934 32 a8 fd			ld (debug_mark+2),a  
3937 18 03			jr .pastdmark  
3939 ..			.dmark: db "IS."  
393c f1			.pastdmark: pop af  
393d			endm  
# End of macro DMARK
393d						CALLMONITOR 
393d cd aa fd			call debug_vector  
3940				endm  
# End of macro CALLMONITOR
3940					endif 
3940					NEXTW 
3940 c3 d0 23			jp macro_next 
3943				endm 
# End of macro NEXTW
3943			.LZERO: 
3943				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3943 2d				db WORD_SYS_CORE+25             
3944 4d 39			dw .TZERO            
3946 03				db 2 + 1 
3947 .. 00			db "0<",0              
394a				endm 
# End of macro CWHEAD
394a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
394a					NEXTW 
394a c3 d0 23			jp macro_next 
394d				endm 
# End of macro NEXTW
394d			.TZERO: 
394d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
394d 2e				db WORD_SYS_CORE+26             
394e 94 39			dw .LESS            
3950 03				db 2 + 1 
3951 .. 00			db "0=",0              
3954				endm 
# End of macro CWHEAD
3954			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3954				; TODO add floating point number detection 
3954					;v5 FORTH_DSP_VALUE 
3954					if DEBUG_FORTH_WORDS_KEY 
3954						DMARK "0=." 
3954 f5				push af  
3955 3a 69 39			ld a, (.dmark)  
3958 32 a6 fd			ld (debug_mark),a  
395b 3a 6a 39			ld a, (.dmark+1)  
395e 32 a7 fd			ld (debug_mark+1),a  
3961 3a 6b 39			ld a, (.dmark+2)  
3964 32 a8 fd			ld (debug_mark+2),a  
3967 18 03			jr .pastdmark  
3969 ..			.dmark: db "0=."  
396c f1			.pastdmark: pop af  
396d			endm  
# End of macro DMARK
396d						CALLMONITOR 
396d cd aa fd			call debug_vector  
3970				endm  
# End of macro CALLMONITOR
3970					endif 
3970					FORTH_DSP 
3970 cd e0 21			call macro_forth_dsp 
3973				endm 
# End of macro FORTH_DSP
3973 7e					ld a,(hl)	; get type of value on TOS 
3974 fe 02				cp DS_TYPE_INUM  
3976 28 00				jr z, .tz_inum 
3978			 
3978				if FORTH_ENABLE_FLOATMATH 
3978					jr .tz_done 
3978			 
3978				endif 
3978					 
3978			 
3978			.tz_inum: 
3978					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3978 cd 1a 22			call macro_dsp_valuehl 
397b				endm 
# End of macro FORTH_DSP_VALUEHL
397b			 
397b			;		push hl 
397b			 
397b					; destroy value TOS 
397b			 
397b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397b cd d2 22			call macro_forth_dsp_pop 
397e				endm 
# End of macro FORTH_DSP_POP
397e			 
397e			;		pop hl 
397e			 
397e 3e 00				ld a,0 
3980			 
3980 bd					cp l 
3981 20 08				jr nz, .tz_notzero 
3983			 
3983 bc					cp h 
3984			 
3984 20 05				jr nz, .tz_notzero 
3986			 
3986			 
3986 21 01 00				ld hl, FORTH_TRUE 
3989 18 03				jr .tz_done 
398b			 
398b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
398e			 
398e					; push value back onto stack for another op etc 
398e			 
398e			.tz_done: 
398e cd 23 20				call forth_push_numhl 
3991			 
3991					NEXTW 
3991 c3 d0 23			jp macro_next 
3994				endm 
# End of macro NEXTW
3994			.LESS: 
3994				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3994 2f				db WORD_SYS_CORE+27             
3995 fd 39			dw .GT            
3997 02				db 1 + 1 
3998 .. 00			db "<",0              
399a				endm 
# End of macro CWHEAD
399a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
399a				; TODO add floating point number detection 
399a					if DEBUG_FORTH_WORDS_KEY 
399a						DMARK "LES" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 a6 fd			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 a7 fd			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 a8 fd			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "LES"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3						CALLMONITOR 
39b3 cd aa fd			call debug_vector  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6					FORTH_DSP 
39b6 cd e0 21			call macro_forth_dsp 
39b9				endm 
# End of macro FORTH_DSP
39b9					;v5 FORTH_DSP_VALUE 
39b9 7e					ld a,(hl)	; get type of value on TOS 
39ba fe 02				cp DS_TYPE_INUM  
39bc 28 00				jr z, .less_inum 
39be			 
39be				if FORTH_ENABLE_FLOATMATH 
39be					jr .less_done 
39be			 
39be				endif 
39be					 
39be			 
39be			.less_inum: 
39be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39be cd 1a 22			call macro_dsp_valuehl 
39c1				endm 
# End of macro FORTH_DSP_VALUEHL
39c1			 
39c1 e5					push hl  ; u2 
39c2			 
39c2					; destroy value TOS 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd d2 22			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5			 
39c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c5 cd 1a 22			call macro_dsp_valuehl 
39c8				endm 
# End of macro FORTH_DSP_VALUEHL
39c8			 
39c8 e5					push hl    ; u1 
39c9			 
39c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c9 cd d2 22			call macro_forth_dsp_pop 
39cc				endm 
# End of macro FORTH_DSP_POP
39cc			 
39cc			 
39cc b7			 or a      ;clear carry flag 
39cd 01 00 00		 ld bc, FORTH_FALSE 
39d0 e1			  pop hl    ; u1 
39d1 d1			  pop de    ; u2 
39d2 ed 52		  sbc hl,de 
39d4 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39d6			 
39d6 01 01 00		 ld bc, FORTH_TRUE 
39d9			.lscont:  
39d9 c5					push bc 
39da e1					pop hl 
39db			 
39db					if DEBUG_FORTH_WORDS 
39db						DMARK "LT1" 
39db f5				push af  
39dc 3a f0 39			ld a, (.dmark)  
39df 32 a6 fd			ld (debug_mark),a  
39e2 3a f1 39			ld a, (.dmark+1)  
39e5 32 a7 fd			ld (debug_mark+1),a  
39e8 3a f2 39			ld a, (.dmark+2)  
39eb 32 a8 fd			ld (debug_mark+2),a  
39ee 18 03			jr .pastdmark  
39f0 ..			.dmark: db "LT1"  
39f3 f1			.pastdmark: pop af  
39f4			endm  
# End of macro DMARK
39f4						CALLMONITOR 
39f4 cd aa fd			call debug_vector  
39f7				endm  
# End of macro CALLMONITOR
39f7					endif 
39f7 cd 23 20				call forth_push_numhl 
39fa			 
39fa					NEXTW 
39fa c3 d0 23			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			.GT: 
39fd				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
39fd 30				db WORD_SYS_CORE+28             
39fe 66 3a			dw .EQUAL            
3a00 02				db 1 + 1 
3a01 .. 00			db ">",0              
3a03				endm 
# End of macro CWHEAD
3a03			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a03				; TODO add floating point number detection 
3a03					if DEBUG_FORTH_WORDS_KEY 
3a03						DMARK "GRT" 
3a03 f5				push af  
3a04 3a 18 3a			ld a, (.dmark)  
3a07 32 a6 fd			ld (debug_mark),a  
3a0a 3a 19 3a			ld a, (.dmark+1)  
3a0d 32 a7 fd			ld (debug_mark+1),a  
3a10 3a 1a 3a			ld a, (.dmark+2)  
3a13 32 a8 fd			ld (debug_mark+2),a  
3a16 18 03			jr .pastdmark  
3a18 ..			.dmark: db "GRT"  
3a1b f1			.pastdmark: pop af  
3a1c			endm  
# End of macro DMARK
3a1c						CALLMONITOR 
3a1c cd aa fd			call debug_vector  
3a1f				endm  
# End of macro CALLMONITOR
3a1f					endif 
3a1f					FORTH_DSP 
3a1f cd e0 21			call macro_forth_dsp 
3a22				endm 
# End of macro FORTH_DSP
3a22					;FORTH_DSP_VALUE 
3a22 7e					ld a,(hl)	; get type of value on TOS 
3a23 fe 02				cp DS_TYPE_INUM  
3a25 28 00				jr z, .gt_inum 
3a27			 
3a27				if FORTH_ENABLE_FLOATMATH 
3a27					jr .gt_done 
3a27			 
3a27				endif 
3a27					 
3a27			 
3a27			.gt_inum: 
3a27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a27 cd 1a 22			call macro_dsp_valuehl 
3a2a				endm 
# End of macro FORTH_DSP_VALUEHL
3a2a			 
3a2a e5					push hl  ; u2 
3a2b			 
3a2b					; destroy value TOS 
3a2b			 
3a2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a2b cd d2 22			call macro_forth_dsp_pop 
3a2e				endm 
# End of macro FORTH_DSP_POP
3a2e			 
3a2e			 
3a2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a2e cd 1a 22			call macro_dsp_valuehl 
3a31				endm 
# End of macro FORTH_DSP_VALUEHL
3a31			 
3a31 e5					push hl    ; u1 
3a32			 
3a32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a32 cd d2 22			call macro_forth_dsp_pop 
3a35				endm 
# End of macro FORTH_DSP_POP
3a35			 
3a35			 
3a35 b7			 or a      ;clear carry flag 
3a36 01 00 00		 ld bc, FORTH_FALSE 
3a39 e1			  pop hl    ; u1 
3a3a d1			  pop de    ; u2 
3a3b ed 52		  sbc hl,de 
3a3d 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a3f			 
3a3f 01 01 00		 ld bc, FORTH_TRUE 
3a42			.gtcont:  
3a42 c5					push bc 
3a43 e1					pop hl 
3a44			 
3a44					if DEBUG_FORTH_WORDS 
3a44						DMARK "GT1" 
3a44 f5				push af  
3a45 3a 59 3a			ld a, (.dmark)  
3a48 32 a6 fd			ld (debug_mark),a  
3a4b 3a 5a 3a			ld a, (.dmark+1)  
3a4e 32 a7 fd			ld (debug_mark+1),a  
3a51 3a 5b 3a			ld a, (.dmark+2)  
3a54 32 a8 fd			ld (debug_mark+2),a  
3a57 18 03			jr .pastdmark  
3a59 ..			.dmark: db "GT1"  
3a5c f1			.pastdmark: pop af  
3a5d			endm  
# End of macro DMARK
3a5d						CALLMONITOR 
3a5d cd aa fd			call debug_vector  
3a60				endm  
# End of macro CALLMONITOR
3a60					endif 
3a60 cd 23 20				call forth_push_numhl 
3a63			 
3a63					NEXTW 
3a63 c3 d0 23			jp macro_next 
3a66				endm 
# End of macro NEXTW
3a66			.EQUAL: 
3a66				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a66 31				db WORD_SYS_CORE+29             
3a67 d1 3a			dw .ENDLOGIC            
3a69 02				db 1 + 1 
3a6a .. 00			db "=",0              
3a6c				endm 
# End of macro CWHEAD
3a6c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a6c				; TODO add floating point number detection 
3a6c					if DEBUG_FORTH_WORDS_KEY 
3a6c						DMARK "EQ." 
3a6c f5				push af  
3a6d 3a 81 3a			ld a, (.dmark)  
3a70 32 a6 fd			ld (debug_mark),a  
3a73 3a 82 3a			ld a, (.dmark+1)  
3a76 32 a7 fd			ld (debug_mark+1),a  
3a79 3a 83 3a			ld a, (.dmark+2)  
3a7c 32 a8 fd			ld (debug_mark+2),a  
3a7f 18 03			jr .pastdmark  
3a81 ..			.dmark: db "EQ."  
3a84 f1			.pastdmark: pop af  
3a85			endm  
# End of macro DMARK
3a85						CALLMONITOR 
3a85 cd aa fd			call debug_vector  
3a88				endm  
# End of macro CALLMONITOR
3a88					endif 
3a88					FORTH_DSP 
3a88 cd e0 21			call macro_forth_dsp 
3a8b				endm 
# End of macro FORTH_DSP
3a8b					;v5 FORTH_DSP_VALUE 
3a8b 7e					ld a,(hl)	; get type of value on TOS 
3a8c fe 02				cp DS_TYPE_INUM  
3a8e 28 00				jr z, .eq_inum 
3a90			 
3a90				if FORTH_ENABLE_FLOATMATH 
3a90					jr .eq_done 
3a90			 
3a90				endif 
3a90					 
3a90			 
3a90			.eq_inum: 
3a90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a90 cd 1a 22			call macro_dsp_valuehl 
3a93				endm 
# End of macro FORTH_DSP_VALUEHL
3a93			 
3a93 e5					push hl 
3a94			 
3a94					; destroy value TOS 
3a94			 
3a94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a94 cd d2 22			call macro_forth_dsp_pop 
3a97				endm 
# End of macro FORTH_DSP_POP
3a97			 
3a97			 
3a97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a97 cd 1a 22			call macro_dsp_valuehl 
3a9a				endm 
# End of macro FORTH_DSP_VALUEHL
3a9a			 
3a9a					; one value on hl get other one back 
3a9a			 
3a9a e5					push hl 
3a9b			 
3a9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9b cd d2 22			call macro_forth_dsp_pop 
3a9e				endm 
# End of macro FORTH_DSP_POP
3a9e			 
3a9e 0e 00				ld c, FORTH_FALSE 
3aa0			 
3aa0 e1					pop hl 
3aa1 d1					pop de 
3aa2			 
3aa2 7b					ld a, e 
3aa3 bd					cp l 
3aa4			 
3aa4 20 06				jr nz, .eq_done 
3aa6			 
3aa6 7a					ld a, d 
3aa7 bc					cp h 
3aa8			 
3aa8 20 02				jr nz, .eq_done 
3aaa			 
3aaa 0e 01				ld c, FORTH_TRUE 
3aac					 
3aac			 
3aac			 
3aac			.eq_done: 
3aac			 
3aac					; TODO push value back onto stack for another op etc 
3aac			 
3aac 26 00				ld h, 0 
3aae 69					ld l, c 
3aaf					if DEBUG_FORTH_WORDS 
3aaf						DMARK "EQ1" 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 a6 fd			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 a7 fd			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 a8 fd			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "EQ1"  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8						CALLMONITOR 
3ac8 cd aa fd			call debug_vector  
3acb				endm  
# End of macro CALLMONITOR
3acb					endif 
3acb cd 23 20				call forth_push_numhl 
3ace			 
3ace					NEXTW 
3ace c3 d0 23			jp macro_next 
3ad1				endm 
# End of macro NEXTW
3ad1			 
3ad1			 
3ad1			.ENDLOGIC: 
3ad1			; eof 
3ad1			 
3ad1			 
# End of file forth_words_logic.asm
3ad1			include "forth_words_maths.asm" 
3ad1			 
3ad1			; | ## Maths Words 
3ad1			 
3ad1			.PLUS:	 
3ad1				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3ad1 15				db WORD_SYS_CORE+1             
3ad2 2f 3b			dw .NEG            
3ad4 02				db 1 + 1 
3ad5 .. 00			db "+",0              
3ad7				endm 
# End of macro CWHEAD
3ad7			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3ad7					if DEBUG_FORTH_WORDS_KEY 
3ad7						DMARK "PLU" 
3ad7 f5				push af  
3ad8 3a ec 3a			ld a, (.dmark)  
3adb 32 a6 fd			ld (debug_mark),a  
3ade 3a ed 3a			ld a, (.dmark+1)  
3ae1 32 a7 fd			ld (debug_mark+1),a  
3ae4 3a ee 3a			ld a, (.dmark+2)  
3ae7 32 a8 fd			ld (debug_mark+2),a  
3aea 18 03			jr .pastdmark  
3aec ..			.dmark: db "PLU"  
3aef f1			.pastdmark: pop af  
3af0			endm  
# End of macro DMARK
3af0						CALLMONITOR 
3af0 cd aa fd			call debug_vector  
3af3				endm  
# End of macro CALLMONITOR
3af3					endif 
3af3					; add top two values and push back result 
3af3			 
3af3					;for v5 FORTH_DSP_VALUE 
3af3					FORTH_DSP 
3af3 cd e0 21			call macro_forth_dsp 
3af6				endm 
# End of macro FORTH_DSP
3af6 7e					ld a,(hl)	; get type of value on TOS 
3af7 fe 02				cp DS_TYPE_INUM  
3af9 28 03				jr z, .dot_inum 
3afb			 
3afb					NEXTW 
3afb c3 d0 23			jp macro_next 
3afe				endm 
# End of macro NEXTW
3afe			 
3afe			; float maths 
3afe			 
3afe				if FORTH_ENABLE_FLOATMATH 
3afe						inc hl      ; now at start of numeric as string 
3afe			 
3afe					if DEBUG_FORTH_MATHS 
3afe						DMARK "ADD" 
3afe				CALLMONITOR 
3afe					endif 
3afe			 
3afe					;ld ix, hl 
3afe					call CON 
3afe			 
3afe			 
3afe					push hl 
3afe					 
3afe					 
3afe			 
3afe						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3afe			 
3afe					; get next number 
3afe			 
3afe						FORTH_DSP_VALUE 
3afe			 
3afe						inc hl      ; now at start of numeric as string 
3afe			 
3afe					;ld ix, hl 
3afe					call CON 
3afe			 
3afe					push hl 
3afe			 
3afe			 
3afe						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3afe			 
3afe						; TODO do add 
3afe			 
3afe						call IADD 
3afe			 
3afe						; TODO get result back as ascii 
3afe			 
3afe						; TODO push result  
3afe			 
3afe			 
3afe			 
3afe						jr .dot_done 
3afe				endif 
3afe			 
3afe			.dot_inum: 
3afe			 
3afe			 
3afe					if DEBUG_FORTH_DOT 
3afe						DMARK "+IT" 
3afe f5				push af  
3aff 3a 13 3b			ld a, (.dmark)  
3b02 32 a6 fd			ld (debug_mark),a  
3b05 3a 14 3b			ld a, (.dmark+1)  
3b08 32 a7 fd			ld (debug_mark+1),a  
3b0b 3a 15 3b			ld a, (.dmark+2)  
3b0e 32 a8 fd			ld (debug_mark+2),a  
3b11 18 03			jr .pastdmark  
3b13 ..			.dmark: db "+IT"  
3b16 f1			.pastdmark: pop af  
3b17			endm  
# End of macro DMARK
3b17				CALLMONITOR 
3b17 cd aa fd			call debug_vector  
3b1a				endm  
# End of macro CALLMONITOR
3b1a					endif 
3b1a			 
3b1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1a cd 1a 22			call macro_dsp_valuehl 
3b1d				endm 
# End of macro FORTH_DSP_VALUEHL
3b1d			 
3b1d				; TODO add floating point number detection 
3b1d			 
3b1d e5					push hl 
3b1e			 
3b1e					; destroy value TOS 
3b1e			 
3b1e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1e cd d2 22			call macro_forth_dsp_pop 
3b21				endm 
# End of macro FORTH_DSP_POP
3b21			 
3b21			 
3b21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b21 cd 1a 22			call macro_dsp_valuehl 
3b24				endm 
# End of macro FORTH_DSP_VALUEHL
3b24			 
3b24					; one value on hl get other one back 
3b24			 
3b24 d1					pop de 
3b25			 
3b25					; do the add 
3b25			 
3b25 19					add hl,de 
3b26			 
3b26					; save it 
3b26			 
3b26			;		push hl	 
3b26			 
3b26					; 
3b26			 
3b26					; destroy value TOS 
3b26			 
3b26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b26 cd d2 22			call macro_forth_dsp_pop 
3b29				endm 
# End of macro FORTH_DSP_POP
3b29			 
3b29					; TODO push value back onto stack for another op etc 
3b29			 
3b29			;		pop hl 
3b29			 
3b29			.dot_done: 
3b29 cd 23 20				call forth_push_numhl 
3b2c			 
3b2c					NEXTW 
3b2c c3 d0 23			jp macro_next 
3b2f				endm 
# End of macro NEXTW
3b2f			.NEG: 
3b2f			 
3b2f				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b2f 17				db WORD_SYS_CORE+3             
3b30 72 3b			dw .DIV            
3b32 02				db 1 + 1 
3b33 .. 00			db "-",0              
3b35				endm 
# End of macro CWHEAD
3b35			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b35					if DEBUG_FORTH_WORDS_KEY 
3b35						DMARK "SUB" 
3b35 f5				push af  
3b36 3a 4a 3b			ld a, (.dmark)  
3b39 32 a6 fd			ld (debug_mark),a  
3b3c 3a 4b 3b			ld a, (.dmark+1)  
3b3f 32 a7 fd			ld (debug_mark+1),a  
3b42 3a 4c 3b			ld a, (.dmark+2)  
3b45 32 a8 fd			ld (debug_mark+2),a  
3b48 18 03			jr .pastdmark  
3b4a ..			.dmark: db "SUB"  
3b4d f1			.pastdmark: pop af  
3b4e			endm  
# End of macro DMARK
3b4e						CALLMONITOR 
3b4e cd aa fd			call debug_vector  
3b51				endm  
# End of macro CALLMONITOR
3b51					endif 
3b51			 
3b51			 
3b51				; TODO add floating point number detection 
3b51					; v5 FORTH_DSP_VALUE 
3b51					FORTH_DSP 
3b51 cd e0 21			call macro_forth_dsp 
3b54				endm 
# End of macro FORTH_DSP
3b54 7e					ld a,(hl)	; get type of value on TOS 
3b55 fe 02				cp DS_TYPE_INUM  
3b57 28 03				jr z, .neg_inum 
3b59			 
3b59					NEXTW 
3b59 c3 d0 23			jp macro_next 
3b5c				endm 
# End of macro NEXTW
3b5c			 
3b5c			; float maths 
3b5c			 
3b5c				if FORTH_ENABLE_FLOATMATH 
3b5c					jr .neg_done 
3b5c			 
3b5c				endif 
3b5c					 
3b5c			 
3b5c			.neg_inum: 
3b5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5c cd 1a 22			call macro_dsp_valuehl 
3b5f				endm 
# End of macro FORTH_DSP_VALUEHL
3b5f			 
3b5f e5					push hl 
3b60			 
3b60					; destroy value TOS 
3b60			 
3b60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b60 cd d2 22			call macro_forth_dsp_pop 
3b63				endm 
# End of macro FORTH_DSP_POP
3b63			 
3b63			 
3b63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b63 cd 1a 22			call macro_dsp_valuehl 
3b66				endm 
# End of macro FORTH_DSP_VALUEHL
3b66			 
3b66					; one value on hl get other one back 
3b66			 
3b66 d1					pop de 
3b67			 
3b67					; do the sub 
3b67			;		ex de, hl 
3b67			 
3b67 ed 52				sbc hl,de 
3b69			 
3b69					; save it 
3b69			 
3b69			;		push hl	 
3b69			 
3b69					; 
3b69			 
3b69					; destroy value TOS 
3b69			 
3b69					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b69 cd d2 22			call macro_forth_dsp_pop 
3b6c				endm 
# End of macro FORTH_DSP_POP
3b6c			 
3b6c					; TODO push value back onto stack for another op etc 
3b6c			 
3b6c			;		pop hl 
3b6c			 
3b6c cd 23 20				call forth_push_numhl 
3b6f			.neg_done: 
3b6f			 
3b6f					NEXTW 
3b6f c3 d0 23			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			.DIV: 
3b72				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b72 18				db WORD_SYS_CORE+4             
3b73 bf 3b			dw .MUL            
3b75 02				db 1 + 1 
3b76 .. 00			db "/",0              
3b78				endm 
# End of macro CWHEAD
3b78			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b78					if DEBUG_FORTH_WORDS_KEY 
3b78						DMARK "DIV" 
3b78 f5				push af  
3b79 3a 8d 3b			ld a, (.dmark)  
3b7c 32 a6 fd			ld (debug_mark),a  
3b7f 3a 8e 3b			ld a, (.dmark+1)  
3b82 32 a7 fd			ld (debug_mark+1),a  
3b85 3a 8f 3b			ld a, (.dmark+2)  
3b88 32 a8 fd			ld (debug_mark+2),a  
3b8b 18 03			jr .pastdmark  
3b8d ..			.dmark: db "DIV"  
3b90 f1			.pastdmark: pop af  
3b91			endm  
# End of macro DMARK
3b91						CALLMONITOR 
3b91 cd aa fd			call debug_vector  
3b94				endm  
# End of macro CALLMONITOR
3b94					endif 
3b94				; TODO add floating point number detection 
3b94					; v5 FORTH_DSP_VALUE 
3b94					FORTH_DSP 
3b94 cd e0 21			call macro_forth_dsp 
3b97				endm 
# End of macro FORTH_DSP
3b97 7e					ld a,(hl)	; get type of value on TOS 
3b98 fe 02				cp DS_TYPE_INUM  
3b9a 28 03				jr z, .div_inum 
3b9c			 
3b9c				if FORTH_ENABLE_FLOATMATH 
3b9c					jr .div_done 
3b9c			 
3b9c				endif 
3b9c					NEXTW 
3b9c c3 d0 23			jp macro_next 
3b9f				endm 
# End of macro NEXTW
3b9f			.div_inum: 
3b9f			 
3b9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9f cd 1a 22			call macro_dsp_valuehl 
3ba2				endm 
# End of macro FORTH_DSP_VALUEHL
3ba2			 
3ba2 e5					push hl    ; to go to bc 
3ba3			 
3ba3					; destroy value TOS 
3ba3			 
3ba3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba3 cd d2 22			call macro_forth_dsp_pop 
3ba6				endm 
# End of macro FORTH_DSP_POP
3ba6			 
3ba6			 
3ba6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba6 cd 1a 22			call macro_dsp_valuehl 
3ba9				endm 
# End of macro FORTH_DSP_VALUEHL
3ba9			 
3ba9					; hl to go to de 
3ba9			 
3ba9 e5					push hl 
3baa			 
3baa c1					pop bc 
3bab d1					pop de		 
3bac			 
3bac			 
3bac					if DEBUG_FORTH_MATHS 
3bac						DMARK "DIV" 
3bac				CALLMONITOR 
3bac					endif 
3bac					; one value on hl but move to a get other one back 
3bac			 
3bac			        
3bac cd 2c 0f			call Div16 
3baf			 
3baf			;	push af	 
3baf e5				push hl 
3bb0 c5				push bc 
3bb1			 
3bb1					if DEBUG_FORTH_MATHS 
3bb1						DMARK "DI1" 
3bb1				CALLMONITOR 
3bb1					endif 
3bb1			 
3bb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb1 cd d2 22			call macro_forth_dsp_pop 
3bb4				endm 
# End of macro FORTH_DSP_POP
3bb4			 
3bb4			 
3bb4			 
3bb4 e1					pop hl    ; result 
3bb5			 
3bb5 cd 23 20				call forth_push_numhl 
3bb8			 
3bb8 e1					pop hl    ; reminder 
3bb9			;		ld h,0 
3bb9			;		ld l,d 
3bb9			 
3bb9 cd 23 20				call forth_push_numhl 
3bbc			.div_done: 
3bbc					NEXTW 
3bbc c3 d0 23			jp macro_next 
3bbf				endm 
# End of macro NEXTW
3bbf			.MUL: 
3bbf				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3bbf 19				db WORD_SYS_CORE+5             
3bc0 04 3c			dw .MIN            
3bc2 02				db 1 + 1 
3bc3 .. 00			db "*",0              
3bc5				endm 
# End of macro CWHEAD
3bc5			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bc5				; TODO add floating point number detection 
3bc5					if DEBUG_FORTH_WORDS_KEY 
3bc5						DMARK "MUL" 
3bc5 f5				push af  
3bc6 3a da 3b			ld a, (.dmark)  
3bc9 32 a6 fd			ld (debug_mark),a  
3bcc 3a db 3b			ld a, (.dmark+1)  
3bcf 32 a7 fd			ld (debug_mark+1),a  
3bd2 3a dc 3b			ld a, (.dmark+2)  
3bd5 32 a8 fd			ld (debug_mark+2),a  
3bd8 18 03			jr .pastdmark  
3bda ..			.dmark: db "MUL"  
3bdd f1			.pastdmark: pop af  
3bde			endm  
# End of macro DMARK
3bde						CALLMONITOR 
3bde cd aa fd			call debug_vector  
3be1				endm  
# End of macro CALLMONITOR
3be1					endif 
3be1					FORTH_DSP 
3be1 cd e0 21			call macro_forth_dsp 
3be4				endm 
# End of macro FORTH_DSP
3be4					; v5 FORTH_DSP_VALUE 
3be4 7e					ld a,(hl)	; get type of value on TOS 
3be5 fe 02				cp DS_TYPE_INUM  
3be7 28 03				jr z, .mul_inum 
3be9			 
3be9				if FORTH_ENABLE_FLOATMATH 
3be9					jr .mul_done 
3be9			 
3be9				endif 
3be9			 
3be9					NEXTW 
3be9 c3 d0 23			jp macro_next 
3bec				endm 
# End of macro NEXTW
3bec			.mul_inum:	 
3bec			 
3bec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bec cd 1a 22			call macro_dsp_valuehl 
3bef				endm 
# End of macro FORTH_DSP_VALUEHL
3bef			 
3bef e5					push hl 
3bf0			 
3bf0					; destroy value TOS 
3bf0			 
3bf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf0 cd d2 22			call macro_forth_dsp_pop 
3bf3				endm 
# End of macro FORTH_DSP_POP
3bf3			 
3bf3			 
3bf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf3 cd 1a 22			call macro_dsp_valuehl 
3bf6				endm 
# End of macro FORTH_DSP_VALUEHL
3bf6			 
3bf6					; one value on hl but move to a get other one back 
3bf6			 
3bf6 7d					ld a, l 
3bf7			 
3bf7 d1					pop de 
3bf8			 
3bf8					; do the mull 
3bf8			;		ex de, hl 
3bf8			 
3bf8 cd 52 0f				call Mult16 
3bfb					; save it 
3bfb			 
3bfb			;		push hl	 
3bfb			 
3bfb					; 
3bfb			 
3bfb					; destroy value TOS 
3bfb			 
3bfb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfb cd d2 22			call macro_forth_dsp_pop 
3bfe				endm 
# End of macro FORTH_DSP_POP
3bfe			 
3bfe					; TODO push value back onto stack for another op etc 
3bfe			 
3bfe			;		pop hl 
3bfe			 
3bfe cd 23 20				call forth_push_numhl 
3c01			 
3c01			.mul_done: 
3c01					NEXTW 
3c01 c3 d0 23			jp macro_next 
3c04				endm 
# End of macro NEXTW
3c04			 
3c04			 
3c04			 
3c04			 
3c04			.MIN: 
3c04				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c04 49				db WORD_SYS_CORE+53             
3c05 85 3c			dw .MAX            
3c07 04				db 3 + 1 
3c08 .. 00			db "MIN",0              
3c0c				endm 
# End of macro CWHEAD
3c0c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c0c					if DEBUG_FORTH_WORDS_KEY 
3c0c						DMARK "MIN" 
3c0c f5				push af  
3c0d 3a 21 3c			ld a, (.dmark)  
3c10 32 a6 fd			ld (debug_mark),a  
3c13 3a 22 3c			ld a, (.dmark+1)  
3c16 32 a7 fd			ld (debug_mark+1),a  
3c19 3a 23 3c			ld a, (.dmark+2)  
3c1c 32 a8 fd			ld (debug_mark+2),a  
3c1f 18 03			jr .pastdmark  
3c21 ..			.dmark: db "MIN"  
3c24 f1			.pastdmark: pop af  
3c25			endm  
# End of macro DMARK
3c25						CALLMONITOR 
3c25 cd aa fd			call debug_vector  
3c28				endm  
# End of macro CALLMONITOR
3c28					endif 
3c28					; get u2 
3c28			 
3c28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c28 cd 1a 22			call macro_dsp_valuehl 
3c2b				endm 
# End of macro FORTH_DSP_VALUEHL
3c2b			 
3c2b e5					push hl   ; u2 
3c2c			 
3c2c					; destroy value TOS 
3c2c			 
3c2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2c cd d2 22			call macro_forth_dsp_pop 
3c2f				endm 
# End of macro FORTH_DSP_POP
3c2f			 
3c2f					; get u1 
3c2f			 
3c2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c2f cd 1a 22			call macro_dsp_valuehl 
3c32				endm 
# End of macro FORTH_DSP_VALUEHL
3c32			 
3c32 e5					push hl  ; u1 
3c33			 
3c33					; destroy value TOS 
3c33			 
3c33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c33 cd d2 22			call macro_forth_dsp_pop 
3c36				endm 
# End of macro FORTH_DSP_POP
3c36			 
3c36 b7			 or a      ;clear carry flag 
3c37 e1			  pop hl    ; u1 
3c38 d1			  pop de    ; u2 
3c39 e5				push hl   ; saved in case hl is lowest 
3c3a ed 52		  sbc hl,de 
3c3c 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c3e			 
3c3e e1				pop hl 
3c3f					if DEBUG_FORTH_WORDS 
3c3f						DMARK "MIN" 
3c3f f5				push af  
3c40 3a 54 3c			ld a, (.dmark)  
3c43 32 a6 fd			ld (debug_mark),a  
3c46 3a 55 3c			ld a, (.dmark+1)  
3c49 32 a7 fd			ld (debug_mark+1),a  
3c4c 3a 56 3c			ld a, (.dmark+2)  
3c4f 32 a8 fd			ld (debug_mark+2),a  
3c52 18 03			jr .pastdmark  
3c54 ..			.dmark: db "MIN"  
3c57 f1			.pastdmark: pop af  
3c58			endm  
# End of macro DMARK
3c58						CALLMONITOR 
3c58 cd aa fd			call debug_vector  
3c5b				endm  
# End of macro CALLMONITOR
3c5b					endif 
3c5b cd 23 20				call forth_push_numhl 
3c5e			 
3c5e				       NEXTW 
3c5e c3 d0 23			jp macro_next 
3c61				endm 
# End of macro NEXTW
3c61			 
3c61			.mincont:  
3c61 c1				pop bc   ; tidy up 
3c62 eb				ex de , hl  
3c63					if DEBUG_FORTH_WORDS 
3c63						DMARK "MI1" 
3c63 f5				push af  
3c64 3a 78 3c			ld a, (.dmark)  
3c67 32 a6 fd			ld (debug_mark),a  
3c6a 3a 79 3c			ld a, (.dmark+1)  
3c6d 32 a7 fd			ld (debug_mark+1),a  
3c70 3a 7a 3c			ld a, (.dmark+2)  
3c73 32 a8 fd			ld (debug_mark+2),a  
3c76 18 03			jr .pastdmark  
3c78 ..			.dmark: db "MI1"  
3c7b f1			.pastdmark: pop af  
3c7c			endm  
# End of macro DMARK
3c7c						CALLMONITOR 
3c7c cd aa fd			call debug_vector  
3c7f				endm  
# End of macro CALLMONITOR
3c7f					endif 
3c7f cd 23 20				call forth_push_numhl 
3c82			 
3c82				       NEXTW 
3c82 c3 d0 23			jp macro_next 
3c85				endm 
# End of macro NEXTW
3c85			.MAX: 
3c85				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c85 4a				db WORD_SYS_CORE+54             
3c86 06 3d			dw .RND16            
3c88 04				db 3 + 1 
3c89 .. 00			db "MAX",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c8d					if DEBUG_FORTH_WORDS_KEY 
3c8d						DMARK "MAX" 
3c8d f5				push af  
3c8e 3a a2 3c			ld a, (.dmark)  
3c91 32 a6 fd			ld (debug_mark),a  
3c94 3a a3 3c			ld a, (.dmark+1)  
3c97 32 a7 fd			ld (debug_mark+1),a  
3c9a 3a a4 3c			ld a, (.dmark+2)  
3c9d 32 a8 fd			ld (debug_mark+2),a  
3ca0 18 03			jr .pastdmark  
3ca2 ..			.dmark: db "MAX"  
3ca5 f1			.pastdmark: pop af  
3ca6			endm  
# End of macro DMARK
3ca6						CALLMONITOR 
3ca6 cd aa fd			call debug_vector  
3ca9				endm  
# End of macro CALLMONITOR
3ca9					endif 
3ca9					; get u2 
3ca9			 
3ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca9 cd 1a 22			call macro_dsp_valuehl 
3cac				endm 
# End of macro FORTH_DSP_VALUEHL
3cac			 
3cac e5					push hl   ; u2 
3cad			 
3cad					; destroy value TOS 
3cad			 
3cad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cad cd d2 22			call macro_forth_dsp_pop 
3cb0				endm 
# End of macro FORTH_DSP_POP
3cb0			 
3cb0					; get u1 
3cb0			 
3cb0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb0 cd 1a 22			call macro_dsp_valuehl 
3cb3				endm 
# End of macro FORTH_DSP_VALUEHL
3cb3			 
3cb3 e5					push hl  ; u1 
3cb4			 
3cb4					; destroy value TOS 
3cb4			 
3cb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb4 cd d2 22			call macro_forth_dsp_pop 
3cb7				endm 
# End of macro FORTH_DSP_POP
3cb7			 
3cb7 b7			 or a      ;clear carry flag 
3cb8 e1			  pop hl    ; u1 
3cb9 d1			  pop de    ; u2 
3cba e5				push hl   ; saved in case hl is lowest 
3cbb ed 52		  sbc hl,de 
3cbd 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3cbf			 
3cbf e1				pop hl 
3cc0					if DEBUG_FORTH_WORDS 
3cc0						DMARK "MAX" 
3cc0 f5				push af  
3cc1 3a d5 3c			ld a, (.dmark)  
3cc4 32 a6 fd			ld (debug_mark),a  
3cc7 3a d6 3c			ld a, (.dmark+1)  
3cca 32 a7 fd			ld (debug_mark+1),a  
3ccd 3a d7 3c			ld a, (.dmark+2)  
3cd0 32 a8 fd			ld (debug_mark+2),a  
3cd3 18 03			jr .pastdmark  
3cd5 ..			.dmark: db "MAX"  
3cd8 f1			.pastdmark: pop af  
3cd9			endm  
# End of macro DMARK
3cd9						CALLMONITOR 
3cd9 cd aa fd			call debug_vector  
3cdc				endm  
# End of macro CALLMONITOR
3cdc					endif 
3cdc cd 23 20				call forth_push_numhl 
3cdf			 
3cdf				       NEXTW 
3cdf c3 d0 23			jp macro_next 
3ce2				endm 
# End of macro NEXTW
3ce2			 
3ce2			.maxcont:  
3ce2 c1				pop bc   ; tidy up 
3ce3 eb				ex de , hl  
3ce4					if DEBUG_FORTH_WORDS 
3ce4						DMARK "MA1" 
3ce4 f5				push af  
3ce5 3a f9 3c			ld a, (.dmark)  
3ce8 32 a6 fd			ld (debug_mark),a  
3ceb 3a fa 3c			ld a, (.dmark+1)  
3cee 32 a7 fd			ld (debug_mark+1),a  
3cf1 3a fb 3c			ld a, (.dmark+2)  
3cf4 32 a8 fd			ld (debug_mark+2),a  
3cf7 18 03			jr .pastdmark  
3cf9 ..			.dmark: db "MA1"  
3cfc f1			.pastdmark: pop af  
3cfd			endm  
# End of macro DMARK
3cfd						CALLMONITOR 
3cfd cd aa fd			call debug_vector  
3d00				endm  
# End of macro CALLMONITOR
3d00					endif 
3d00 cd 23 20				call forth_push_numhl 
3d03				       NEXTW 
3d03 c3 d0 23			jp macro_next 
3d06				endm 
# End of macro NEXTW
3d06			 
3d06			.RND16: 
3d06				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d06 4e				db WORD_SYS_CORE+58             
3d07 35 3d			dw .RND8            
3d09 06				db 5 + 1 
3d0a .. 00			db "RND16",0              
3d10				endm 
# End of macro CWHEAD
3d10			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d10					if DEBUG_FORTH_WORDS_KEY 
3d10						DMARK "R16" 
3d10 f5				push af  
3d11 3a 25 3d			ld a, (.dmark)  
3d14 32 a6 fd			ld (debug_mark),a  
3d17 3a 26 3d			ld a, (.dmark+1)  
3d1a 32 a7 fd			ld (debug_mark+1),a  
3d1d 3a 27 3d			ld a, (.dmark+2)  
3d20 32 a8 fd			ld (debug_mark+2),a  
3d23 18 03			jr .pastdmark  
3d25 ..			.dmark: db "R16"  
3d28 f1			.pastdmark: pop af  
3d29			endm  
# End of macro DMARK
3d29						CALLMONITOR 
3d29 cd aa fd			call debug_vector  
3d2c				endm  
# End of macro CALLMONITOR
3d2c					endif 
3d2c cd f6 0e				call prng16  
3d2f cd 23 20				call forth_push_numhl 
3d32				       NEXTW 
3d32 c3 d0 23			jp macro_next 
3d35				endm 
# End of macro NEXTW
3d35			.RND8: 
3d35				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d35 60				db WORD_SYS_CORE+76             
3d36 6a 3d			dw .RND            
3d38 05				db 4 + 1 
3d39 .. 00			db "RND8",0              
3d3e				endm 
# End of macro CWHEAD
3d3e			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d3e					if DEBUG_FORTH_WORDS_KEY 
3d3e						DMARK "RN8" 
3d3e f5				push af  
3d3f 3a 53 3d			ld a, (.dmark)  
3d42 32 a6 fd			ld (debug_mark),a  
3d45 3a 54 3d			ld a, (.dmark+1)  
3d48 32 a7 fd			ld (debug_mark+1),a  
3d4b 3a 55 3d			ld a, (.dmark+2)  
3d4e 32 a8 fd			ld (debug_mark+2),a  
3d51 18 03			jr .pastdmark  
3d53 ..			.dmark: db "RN8"  
3d56 f1			.pastdmark: pop af  
3d57			endm  
# End of macro DMARK
3d57						CALLMONITOR 
3d57 cd aa fd			call debug_vector  
3d5a				endm  
# End of macro CALLMONITOR
3d5a					endif 
3d5a 2a e4 fa				ld hl,(xrandc) 
3d5d 23					inc hl 
3d5e cd 10 0f				call xrnd 
3d61 6f					ld l,a	 
3d62 26 00				ld h,0 
3d64 cd 23 20				call forth_push_numhl 
3d67				       NEXTW 
3d67 c3 d0 23			jp macro_next 
3d6a				endm 
# End of macro NEXTW
3d6a			.RND: 
3d6a				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d6a 60				db WORD_SYS_CORE+76             
3d6b 70 3e			dw .ENDMATHS            
3d6d 04				db 3 + 1 
3d6e .. 00			db "RND",0              
3d72				endm 
# End of macro CWHEAD
3d72			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d72			 
3d72					if DEBUG_FORTH_WORDS_KEY 
3d72						DMARK "RND" 
3d72 f5				push af  
3d73 3a 87 3d			ld a, (.dmark)  
3d76 32 a6 fd			ld (debug_mark),a  
3d79 3a 88 3d			ld a, (.dmark+1)  
3d7c 32 a7 fd			ld (debug_mark+1),a  
3d7f 3a 89 3d			ld a, (.dmark+2)  
3d82 32 a8 fd			ld (debug_mark+2),a  
3d85 18 03			jr .pastdmark  
3d87 ..			.dmark: db "RND"  
3d8a f1			.pastdmark: pop af  
3d8b			endm  
# End of macro DMARK
3d8b						CALLMONITOR 
3d8b cd aa fd			call debug_vector  
3d8e				endm  
# End of macro CALLMONITOR
3d8e					endif 
3d8e					 
3d8e					FORTH_DSP_VALUEHL    ; upper range 
3d8e cd 1a 22			call macro_dsp_valuehl 
3d91				endm 
# End of macro FORTH_DSP_VALUEHL
3d91			 
3d91 22 e8 fa				ld (LFSRSeed), hl	 
3d94			 
3d94					if DEBUG_FORTH_WORDS 
3d94						DMARK "RN1" 
3d94 f5				push af  
3d95 3a a9 3d			ld a, (.dmark)  
3d98 32 a6 fd			ld (debug_mark),a  
3d9b 3a aa 3d			ld a, (.dmark+1)  
3d9e 32 a7 fd			ld (debug_mark+1),a  
3da1 3a ab 3d			ld a, (.dmark+2)  
3da4 32 a8 fd			ld (debug_mark+2),a  
3da7 18 03			jr .pastdmark  
3da9 ..			.dmark: db "RN1"  
3dac f1			.pastdmark: pop af  
3dad			endm  
# End of macro DMARK
3dad						CALLMONITOR 
3dad cd aa fd			call debug_vector  
3db0				endm  
# End of macro CALLMONITOR
3db0					endif 
3db0					FORTH_DSP_POP 
3db0 cd d2 22			call macro_forth_dsp_pop 
3db3				endm 
# End of macro FORTH_DSP_POP
3db3			 
3db3					FORTH_DSP_VALUEHL    ; low range 
3db3 cd 1a 22			call macro_dsp_valuehl 
3db6				endm 
# End of macro FORTH_DSP_VALUEHL
3db6			 
3db6					if DEBUG_FORTH_WORDS 
3db6						DMARK "RN2" 
3db6 f5				push af  
3db7 3a cb 3d			ld a, (.dmark)  
3dba 32 a6 fd			ld (debug_mark),a  
3dbd 3a cc 3d			ld a, (.dmark+1)  
3dc0 32 a7 fd			ld (debug_mark+1),a  
3dc3 3a cd 3d			ld a, (.dmark+2)  
3dc6 32 a8 fd			ld (debug_mark+2),a  
3dc9 18 03			jr .pastdmark  
3dcb ..			.dmark: db "RN2"  
3dce f1			.pastdmark: pop af  
3dcf			endm  
# End of macro DMARK
3dcf						CALLMONITOR 
3dcf cd aa fd			call debug_vector  
3dd2				endm  
# End of macro CALLMONITOR
3dd2					endif 
3dd2 22 ea fa				ld (LFSRSeed+2), hl 
3dd5			 
3dd5					FORTH_DSP_POP 
3dd5 cd d2 22			call macro_forth_dsp_pop 
3dd8				endm 
# End of macro FORTH_DSP_POP
3dd8			 
3dd8 e5					push hl 
3dd9			 
3dd9 e1			.inrange:	pop hl 
3dda cd f6 0e				call prng16  
3ddd					if DEBUG_FORTH_WORDS 
3ddd						DMARK "RN3" 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 a6 fd			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 a7 fd			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 a8 fd			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "RN3"  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd aa fd			call debug_vector  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9					 
3df9					; if the range is 8bit knock out the high byte 
3df9			 
3df9 ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
3dfd			 
3dfd 3e 00				ld a, 0 
3dff ba					cp d  
3e00 20 1e				jr nz, .hirange 
3e02 26 00				ld h, 0   ; knock it down to 8bit 
3e04			 
3e04					if DEBUG_FORTH_WORDS 
3e04						DMARK "RNk" 
3e04 f5				push af  
3e05 3a 19 3e			ld a, (.dmark)  
3e08 32 a6 fd			ld (debug_mark),a  
3e0b 3a 1a 3e			ld a, (.dmark+1)  
3e0e 32 a7 fd			ld (debug_mark+1),a  
3e11 3a 1b 3e			ld a, (.dmark+2)  
3e14 32 a8 fd			ld (debug_mark+2),a  
3e17 18 03			jr .pastdmark  
3e19 ..			.dmark: db "RNk"  
3e1c f1			.pastdmark: pop af  
3e1d			endm  
# End of macro DMARK
3e1d						CALLMONITOR 
3e1d cd aa fd			call debug_vector  
3e20				endm  
# End of macro CALLMONITOR
3e20					endif 
3e20			.hirange:   
3e20 e5					push hl  
3e21 b7					or a  
3e22 ed 52		                sbc hl, de 
3e24			 
3e24					;call cmp16 
3e24			 
3e24 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e26 e1					pop hl 
3e27 e5					push hl 
3e28			 
3e28					if DEBUG_FORTH_WORDS 
3e28						DMARK "RN4" 
3e28 f5				push af  
3e29 3a 3d 3e			ld a, (.dmark)  
3e2c 32 a6 fd			ld (debug_mark),a  
3e2f 3a 3e 3e			ld a, (.dmark+1)  
3e32 32 a7 fd			ld (debug_mark+1),a  
3e35 3a 3f 3e			ld a, (.dmark+2)  
3e38 32 a8 fd			ld (debug_mark+2),a  
3e3b 18 03			jr .pastdmark  
3e3d ..			.dmark: db "RN4"  
3e40 f1			.pastdmark: pop af  
3e41			endm  
# End of macro DMARK
3e41						CALLMONITOR 
3e41 cd aa fd			call debug_vector  
3e44				endm  
# End of macro CALLMONITOR
3e44					endif 
3e44 ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
3e48					;call cmp16 
3e48				 
3e48 b7					or a  
3e49 ed 52		                sbc hl, de 
3e4b 38 8c				jr c, .inrange 
3e4d			 
3e4d e1					pop hl 
3e4e					 
3e4e					if DEBUG_FORTH_WORDS 
3e4e						DMARK "RNd" 
3e4e f5				push af  
3e4f 3a 63 3e			ld a, (.dmark)  
3e52 32 a6 fd			ld (debug_mark),a  
3e55 3a 64 3e			ld a, (.dmark+1)  
3e58 32 a7 fd			ld (debug_mark+1),a  
3e5b 3a 65 3e			ld a, (.dmark+2)  
3e5e 32 a8 fd			ld (debug_mark+2),a  
3e61 18 03			jr .pastdmark  
3e63 ..			.dmark: db "RNd"  
3e66 f1			.pastdmark: pop af  
3e67			endm  
# End of macro DMARK
3e67						CALLMONITOR 
3e67 cd aa fd			call debug_vector  
3e6a				endm  
# End of macro CALLMONITOR
3e6a					endif 
3e6a			 
3e6a			 
3e6a cd 23 20				call forth_push_numhl 
3e6d				       NEXTW 
3e6d c3 d0 23			jp macro_next 
3e70				endm 
# End of macro NEXTW
3e70			 
3e70			.ENDMATHS: 
3e70			 
3e70			; eof 
3e70			 
# End of file forth_words_maths.asm
3e70			include "forth_words_display.asm" 
3e70			 
3e70			; | ## Display Words 
3e70			 
3e70			.ACT: 
3e70			 
3e70				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e70 62				db WORD_SYS_CORE+78             
3e71 bc 3e			dw .INFO            
3e73 07				db 6 + 1 
3e74 .. 00			db "ACTIVE",0              
3e7b				endm 
# End of macro CWHEAD
3e7b			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3e7b			;  
3e7b			; | | To display a pulsing activity indicator in a processing loop do this... 
3e7b			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3e7b			 
3e7b					if DEBUG_FORTH_WORDS_KEY 
3e7b						DMARK "ACT" 
3e7b f5				push af  
3e7c 3a 90 3e			ld a, (.dmark)  
3e7f 32 a6 fd			ld (debug_mark),a  
3e82 3a 91 3e			ld a, (.dmark+1)  
3e85 32 a7 fd			ld (debug_mark+1),a  
3e88 3a 92 3e			ld a, (.dmark+2)  
3e8b 32 a8 fd			ld (debug_mark+2),a  
3e8e 18 03			jr .pastdmark  
3e90 ..			.dmark: db "ACT"  
3e93 f1			.pastdmark: pop af  
3e94			endm  
# End of macro DMARK
3e94						CALLMONITOR 
3e94 cd aa fd			call debug_vector  
3e97				endm  
# End of macro CALLMONITOR
3e97					endif 
3e97 cd f2 0c				call active 
3e9a					if DEBUG_FORTH_WORDS 
3e9a						DMARK "ACp" 
3e9a f5				push af  
3e9b 3a af 3e			ld a, (.dmark)  
3e9e 32 a6 fd			ld (debug_mark),a  
3ea1 3a b0 3e			ld a, (.dmark+1)  
3ea4 32 a7 fd			ld (debug_mark+1),a  
3ea7 3a b1 3e			ld a, (.dmark+2)  
3eaa 32 a8 fd			ld (debug_mark+2),a  
3ead 18 03			jr .pastdmark  
3eaf ..			.dmark: db "ACp"  
3eb2 f1			.pastdmark: pop af  
3eb3			endm  
# End of macro DMARK
3eb3						CALLMONITOR 
3eb3 cd aa fd			call debug_vector  
3eb6				endm  
# End of macro CALLMONITOR
3eb6					endif 
3eb6 cd 91 20				call forth_push_str 
3eb9			 
3eb9					NEXTW 
3eb9 c3 d0 23			jp macro_next 
3ebc				endm 
# End of macro NEXTW
3ebc			.INFO: 
3ebc			 
3ebc				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3ebc 62				db WORD_SYS_CORE+78             
3ebd d9 3e			dw .ATP            
3ebf 05				db 4 + 1 
3ec0 .. 00			db "INFO",0              
3ec5				endm 
# End of macro CWHEAD
3ec5			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ec5					FORTH_DSP_VALUEHL 
3ec5 cd 1a 22			call macro_dsp_valuehl 
3ec8				endm 
# End of macro FORTH_DSP_VALUEHL
3ec8			 
3ec8					FORTH_DSP_POP 
3ec8 cd d2 22			call macro_forth_dsp_pop 
3ecb				endm 
# End of macro FORTH_DSP_POP
3ecb			 
3ecb e5					push hl 
3ecc			 
3ecc					FORTH_DSP_VALUEHL 
3ecc cd 1a 22			call macro_dsp_valuehl 
3ecf				endm 
# End of macro FORTH_DSP_VALUEHL
3ecf			 
3ecf					FORTH_DSP_POP 
3ecf cd d2 22			call macro_forth_dsp_pop 
3ed2				endm 
# End of macro FORTH_DSP_POP
3ed2			 
3ed2 d1					pop de 
3ed3			 
3ed3 cd 2c 0d				call info_panel 
3ed6			 
3ed6			 
3ed6					NEXTW 
3ed6 c3 d0 23			jp macro_next 
3ed9				endm 
# End of macro NEXTW
3ed9			.ATP: 
3ed9				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ed9 62				db WORD_SYS_CORE+78             
3eda 50 3f			dw .FB            
3edc 04				db 3 + 1 
3edd .. 00			db "AT?",0              
3ee1				endm 
# End of macro CWHEAD
3ee1			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ee1					if DEBUG_FORTH_WORDS_KEY 
3ee1						DMARK "AT?" 
3ee1 f5				push af  
3ee2 3a f6 3e			ld a, (.dmark)  
3ee5 32 a6 fd			ld (debug_mark),a  
3ee8 3a f7 3e			ld a, (.dmark+1)  
3eeb 32 a7 fd			ld (debug_mark+1),a  
3eee 3a f8 3e			ld a, (.dmark+2)  
3ef1 32 a8 fd			ld (debug_mark+2),a  
3ef4 18 03			jr .pastdmark  
3ef6 ..			.dmark: db "AT?"  
3ef9 f1			.pastdmark: pop af  
3efa			endm  
# End of macro DMARK
3efa						CALLMONITOR 
3efa cd aa fd			call debug_vector  
3efd				endm  
# End of macro CALLMONITOR
3efd					endif 
3efd 3a 99 f9				ld a, (f_cursor_ptr) 
3f00			 
3f00			if DEBUG_FORTH_WORDS 
3f00				DMARK "AT?" 
3f00 f5				push af  
3f01 3a 15 3f			ld a, (.dmark)  
3f04 32 a6 fd			ld (debug_mark),a  
3f07 3a 16 3f			ld a, (.dmark+1)  
3f0a 32 a7 fd			ld (debug_mark+1),a  
3f0d 3a 17 3f			ld a, (.dmark+2)  
3f10 32 a8 fd			ld (debug_mark+2),a  
3f13 18 03			jr .pastdmark  
3f15 ..			.dmark: db "AT?"  
3f18 f1			.pastdmark: pop af  
3f19			endm  
# End of macro DMARK
3f19				CALLMONITOR 
3f19 cd aa fd			call debug_vector  
3f1c				endm  
# End of macro CALLMONITOR
3f1c			endif	 
3f1c					; count the number of rows 
3f1c			 
3f1c 06 00				ld b, 0 
3f1e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f1f d6 28				sub display_cols 
3f21 f2 27 3f				jp p, .atprunder 
3f24 04					inc b 
3f25 18 f7				jr .atpr 
3f27			.atprunder:	 
3f27			if DEBUG_FORTH_WORDS 
3f27				DMARK "A?2" 
3f27 f5				push af  
3f28 3a 3c 3f			ld a, (.dmark)  
3f2b 32 a6 fd			ld (debug_mark),a  
3f2e 3a 3d 3f			ld a, (.dmark+1)  
3f31 32 a7 fd			ld (debug_mark+1),a  
3f34 3a 3e 3f			ld a, (.dmark+2)  
3f37 32 a8 fd			ld (debug_mark+2),a  
3f3a 18 03			jr .pastdmark  
3f3c ..			.dmark: db "A?2"  
3f3f f1			.pastdmark: pop af  
3f40			endm  
# End of macro DMARK
3f40				CALLMONITOR 
3f40 cd aa fd			call debug_vector  
3f43				endm  
# End of macro CALLMONITOR
3f43			endif	 
3f43 26 00				ld h, 0 
3f45 69					ld l, c 
3f46 cd 23 20				call forth_push_numhl 
3f49 68					ld l, b  
3f4a cd 23 20				call forth_push_numhl 
3f4d			 
3f4d			 
3f4d				NEXTW 
3f4d c3 d0 23			jp macro_next 
3f50				endm 
# End of macro NEXTW
3f50			 
3f50			.FB: 
3f50				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f50 1b				db WORD_SYS_CORE+7             
3f51 9e 3f			dw .EMIT            
3f53 03				db 2 + 1 
3f54 .. 00			db "FB",0              
3f57				endm 
# End of macro CWHEAD
3f57			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f57			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f57			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f57			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f57					if DEBUG_FORTH_WORDS_KEY 
3f57						DMARK "FB." 
3f57 f5				push af  
3f58 3a 6c 3f			ld a, (.dmark)  
3f5b 32 a6 fd			ld (debug_mark),a  
3f5e 3a 6d 3f			ld a, (.dmark+1)  
3f61 32 a7 fd			ld (debug_mark+1),a  
3f64 3a 6e 3f			ld a, (.dmark+2)  
3f67 32 a8 fd			ld (debug_mark+2),a  
3f6a 18 03			jr .pastdmark  
3f6c ..			.dmark: db "FB."  
3f6f f1			.pastdmark: pop af  
3f70			endm  
# End of macro DMARK
3f70						CALLMONITOR 
3f70 cd aa fd			call debug_vector  
3f73				endm  
# End of macro CALLMONITOR
3f73					endif 
3f73			 
3f73					FORTH_DSP_VALUEHL 
3f73 cd 1a 22			call macro_dsp_valuehl 
3f76				endm 
# End of macro FORTH_DSP_VALUEHL
3f76			 
3f76 7d					ld a, l 
3f77 fe 01				cp 1 
3f79 20 05				jr nz, .fbn1 
3f7b 21 4b fc				ld hl, display_fb1 
3f7e 18 15				jr .fbset 
3f80 fe 02		.fbn1:		cp 2 
3f82 20 05				jr nz, .fbn2 
3f84 21 09 fb				ld hl, display_fb2 
3f87 18 0c				jr .fbset 
3f89 fe 03		.fbn2:		cp 3 
3f8b 20 05				jr nz, .fbn3 
3f8d 21 aa fb				ld hl, display_fb3 
3f90 18 03				jr .fbset 
3f92			.fbn3:		 ; if invalid number select first 
3f92 21 4b fc				ld hl, display_fb1 
3f95 22 07 fb		.fbset:		ld (display_fb_active), hl 
3f98			 
3f98					FORTH_DSP_POP 
3f98 cd d2 22			call macro_forth_dsp_pop 
3f9b				endm 
# End of macro FORTH_DSP_POP
3f9b			 
3f9b					NEXTW 
3f9b c3 d0 23			jp macro_next 
3f9e				endm 
# End of macro NEXTW
3f9e			 
3f9e			 
3f9e			.EMIT: 
3f9e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3f9e 1b				db WORD_SYS_CORE+7             
3f9f ef 3f			dw .DOTH            
3fa1 05				db 4 + 1 
3fa2 .. 00			db "EMIT",0              
3fa7				endm 
# End of macro CWHEAD
3fa7			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fa7					; get value off TOS and display it 
3fa7			 
3fa7					if DEBUG_FORTH_WORDS_KEY 
3fa7						DMARK "EMT" 
3fa7 f5				push af  
3fa8 3a bc 3f			ld a, (.dmark)  
3fab 32 a6 fd			ld (debug_mark),a  
3fae 3a bd 3f			ld a, (.dmark+1)  
3fb1 32 a7 fd			ld (debug_mark+1),a  
3fb4 3a be 3f			ld a, (.dmark+2)  
3fb7 32 a8 fd			ld (debug_mark+2),a  
3fba 18 03			jr .pastdmark  
3fbc ..			.dmark: db "EMT"  
3fbf f1			.pastdmark: pop af  
3fc0			endm  
# End of macro DMARK
3fc0						CALLMONITOR 
3fc0 cd aa fd			call debug_vector  
3fc3				endm  
# End of macro CALLMONITOR
3fc3					endif 
3fc3			 
3fc3					FORTH_DSP_VALUEHL 
3fc3 cd 1a 22			call macro_dsp_valuehl 
3fc6				endm 
# End of macro FORTH_DSP_VALUEHL
3fc6			 
3fc6 7d					ld a,l 
3fc7			 
3fc7					; TODO write to display 
3fc7			 
3fc7 32 fa f2				ld (os_input), a 
3fca 3e 00				ld a, 0 
3fcc 32 fb f2				ld (os_input+1), a 
3fcf					 
3fcf 3a 99 f9				ld a, (f_cursor_ptr) 
3fd2 11 fa f2				ld de, os_input 
3fd5 cd ae 0d				call str_at_display 
3fd8			 
3fd8			 
3fd8 3a 77 f9				ld a,(cli_autodisplay) 
3fdb fe 00				cp 0 
3fdd 28 03				jr z, .enoupdate 
3fdf cd be 0d						call update_display 
3fe2					.enoupdate: 
3fe2			 
3fe2 3a 99 f9				ld a, (f_cursor_ptr) 
3fe5 3c					inc a 
3fe6 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
3fe9			 
3fe9			 
3fe9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe9 cd d2 22			call macro_forth_dsp_pop 
3fec				endm 
# End of macro FORTH_DSP_POP
3fec			  
3fec			 
3fec					NEXTW 
3fec c3 d0 23			jp macro_next 
3fef				endm 
# End of macro NEXTW
3fef			.DOTH: 
3fef				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3fef 1c				db WORD_SYS_CORE+8             
3ff0 1f 40			dw .DOTF            
3ff2 03				db 2 + 1 
3ff3 .. 00			db ".-",0              
3ff6				endm 
# End of macro CWHEAD
3ff6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3ff6					; get value off TOS and display it 
3ff6					if DEBUG_FORTH_WORDS_KEY 
3ff6						DMARK "DTD" 
3ff6 f5				push af  
3ff7 3a 0b 40			ld a, (.dmark)  
3ffa 32 a6 fd			ld (debug_mark),a  
3ffd 3a 0c 40			ld a, (.dmark+1)  
4000 32 a7 fd			ld (debug_mark+1),a  
4003 3a 0d 40			ld a, (.dmark+2)  
4006 32 a8 fd			ld (debug_mark+2),a  
4009 18 03			jr .pastdmark  
400b ..			.dmark: db "DTD"  
400e f1			.pastdmark: pop af  
400f			endm  
# End of macro DMARK
400f						CALLMONITOR 
400f cd aa fd			call debug_vector  
4012				endm  
# End of macro CALLMONITOR
4012					endif 
4012 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4014 3e 00			ld a, 0 
4016 32 78 f9			ld (cli_mvdot), a 
4019 c3 76 40			jp .dotgo 
401c				NEXTW 
401c c3 d0 23			jp macro_next 
401f				endm 
# End of macro NEXTW
401f			.DOTF: 
401f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
401f 1c				db WORD_SYS_CORE+8             
4020 4d 40			dw .DOT            
4022 03				db 2 + 1 
4023 .. 00			db ".>",0              
4026				endm 
# End of macro CWHEAD
4026			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4026					; get value off TOS and display it 
4026			        ; TODO BUG adds extra spaces 
4026			        ; TODO BUG handle numerics? 
4026					if DEBUG_FORTH_WORDS_KEY 
4026						DMARK "DTC" 
4026 f5				push af  
4027 3a 3b 40			ld a, (.dmark)  
402a 32 a6 fd			ld (debug_mark),a  
402d 3a 3c 40			ld a, (.dmark+1)  
4030 32 a7 fd			ld (debug_mark+1),a  
4033 3a 3d 40			ld a, (.dmark+2)  
4036 32 a8 fd			ld (debug_mark+2),a  
4039 18 03			jr .pastdmark  
403b ..			.dmark: db "DTC"  
403e f1			.pastdmark: pop af  
403f			endm  
# End of macro DMARK
403f						CALLMONITOR 
403f cd aa fd			call debug_vector  
4042				endm  
# End of macro CALLMONITOR
4042					endif 
4042 3e 01			ld a, 1 
4044 32 78 f9			ld (cli_mvdot), a 
4047 c3 76 40			jp .dotgo 
404a				NEXTW 
404a c3 d0 23			jp macro_next 
404d				endm 
# End of macro NEXTW
404d			 
404d			.DOT: 
404d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
404d 1c				db WORD_SYS_CORE+8             
404e 29 42			dw .CLS            
4050 02				db 1 + 1 
4051 .. 00			db ".",0              
4053				endm 
# End of macro CWHEAD
4053			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4053					; get value off TOS and display it 
4053			 
4053					if DEBUG_FORTH_WORDS_KEY 
4053						DMARK "DOT" 
4053 f5				push af  
4054 3a 68 40			ld a, (.dmark)  
4057 32 a6 fd			ld (debug_mark),a  
405a 3a 69 40			ld a, (.dmark+1)  
405d 32 a7 fd			ld (debug_mark+1),a  
4060 3a 6a 40			ld a, (.dmark+2)  
4063 32 a8 fd			ld (debug_mark+2),a  
4066 18 03			jr .pastdmark  
4068 ..			.dmark: db "DOT"  
406b f1			.pastdmark: pop af  
406c			endm  
# End of macro DMARK
406c						CALLMONITOR 
406c cd aa fd			call debug_vector  
406f				endm  
# End of macro CALLMONITOR
406f					endif 
406f 3e 00			ld a, 0 
4071 32 78 f9			ld (cli_mvdot), a 
4074 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4076				 
4076			 
4076			.dotgo: 
4076			 
4076			; move up type to on stack for parserv5 
4076					FORTH_DSP 
4076 cd e0 21			call macro_forth_dsp 
4079				endm 
# End of macro FORTH_DSP
4079				;FORTH_DSP_VALUE  
4079			 
4079			if DEBUG_FORTH_DOT 
4079				DMARK "DOT" 
4079 f5				push af  
407a 3a 8e 40			ld a, (.dmark)  
407d 32 a6 fd			ld (debug_mark),a  
4080 3a 8f 40			ld a, (.dmark+1)  
4083 32 a7 fd			ld (debug_mark+1),a  
4086 3a 90 40			ld a, (.dmark+2)  
4089 32 a8 fd			ld (debug_mark+2),a  
408c 18 03			jr .pastdmark  
408e ..			.dmark: db "DOT"  
4091 f1			.pastdmark: pop af  
4092			endm  
# End of macro DMARK
4092				CALLMONITOR 
4092 cd aa fd			call debug_vector  
4095				endm  
# End of macro CALLMONITOR
4095			endif	 
4095			;		.print: 
4095			 
4095 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4096 23				inc hl   ; position to the actual value 
4097 fe 01			cp DS_TYPE_STR 
4099 20 06			jr nz, .dotnum1  
409b			 
409b			; display string 
409b				FORTH_DSP_VALUE  
409b cd 03 22			call macro_forth_dsp_value 
409e				endm 
# End of macro FORTH_DSP_VALUE
409e eb				ex de,hl 
409f 18 49			jr .dotwrite 
40a1			 
40a1			.dotnum1: 
40a1 fe 02			cp DS_TYPE_INUM 
40a3 20 44			jr nz, .dotflot 
40a5			 
40a5			 
40a5			; display number 
40a5			 
40a5			;	push hl 
40a5			;	call clear_display 
40a5			;	pop hl 
40a5			 
40a5 5e				ld e, (hl) 
40a6 23				inc hl 
40a7 56				ld d, (hl) 
40a8 21 fc f0			ld hl, scratch 
40ab			if DEBUG_FORTH_DOT 
40ab				DMARK "DT1" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 a6 fd			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 a7 fd			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 a8 fd			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "DT1"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4				CALLMONITOR 
40c4 cd aa fd			call debug_vector  
40c7				endm  
# End of macro CALLMONITOR
40c7			endif	 
40c7			 
40c7 cd e4 12			call uitoa_16 
40ca eb				ex de,hl 
40cb			 
40cb			if DEBUG_FORTH_DOT 
40cb				DMARK "DT2" 
40cb f5				push af  
40cc 3a e0 40			ld a, (.dmark)  
40cf 32 a6 fd			ld (debug_mark),a  
40d2 3a e1 40			ld a, (.dmark+1)  
40d5 32 a7 fd			ld (debug_mark+1),a  
40d8 3a e2 40			ld a, (.dmark+2)  
40db 32 a8 fd			ld (debug_mark+2),a  
40de 18 03			jr .pastdmark  
40e0 ..			.dmark: db "DT2"  
40e3 f1			.pastdmark: pop af  
40e4			endm  
# End of macro DMARK
40e4				CALLMONITOR 
40e4 cd aa fd			call debug_vector  
40e7				endm  
# End of macro CALLMONITOR
40e7			endif	 
40e7			 
40e7			;	ld de, os_word_scratch 
40e7 18 01			jr .dotwrite 
40e9			 
40e9 00			.dotflot:   nop 
40ea			; TODO print floating point number 
40ea			 
40ea			.dotwrite:		 
40ea			 
40ea					; if c is set then set all '-' to spaces 
40ea					; need to also take into account .>  
40ea			 
40ea 3e 01				ld a, 1 
40ec b9					cp c 
40ed 20 67				jr nz, .nodashswap 
40ef			 
40ef					; DE has the string to write, working with HL 
40ef			 
40ef 06 ff				ld b, 255 
40f1 d5					push de 
40f2 e1					pop hl 
40f3			 
40f3			if DEBUG_FORTH_DOT 
40f3				DMARK "DT-" 
40f3 f5				push af  
40f4 3a 08 41			ld a, (.dmark)  
40f7 32 a6 fd			ld (debug_mark),a  
40fa 3a 09 41			ld a, (.dmark+1)  
40fd 32 a7 fd			ld (debug_mark+1),a  
4100 3a 0a 41			ld a, (.dmark+2)  
4103 32 a8 fd			ld (debug_mark+2),a  
4106 18 03			jr .pastdmark  
4108 ..			.dmark: db "DT-"  
410b f1			.pastdmark: pop af  
410c			endm  
# End of macro DMARK
410c				CALLMONITOR 
410c cd aa fd			call debug_vector  
410f				endm  
# End of macro CALLMONITOR
410f			endif	 
410f 7e			.dashscan:	ld a, (hl) 
4110 fe 00				cp 0 
4112 28 42				jr z, .nodashswap 
4114 fe 2d				cp '-' 
4116 20 03				jr nz, .dashskip 
4118 3e 20				ld a, ' ' 
411a 77					ld (hl), a 
411b 23			.dashskip:	inc hl 
411c			if DEBUG_FORTH_DOT 
411c				DMARK "D-2" 
411c f5				push af  
411d 3a 31 41			ld a, (.dmark)  
4120 32 a6 fd			ld (debug_mark),a  
4123 3a 32 41			ld a, (.dmark+1)  
4126 32 a7 fd			ld (debug_mark+1),a  
4129 3a 33 41			ld a, (.dmark+2)  
412c 32 a8 fd			ld (debug_mark+2),a  
412f 18 03			jr .pastdmark  
4131 ..			.dmark: db "D-2"  
4134 f1			.pastdmark: pop af  
4135			endm  
# End of macro DMARK
4135				CALLMONITOR 
4135 cd aa fd			call debug_vector  
4138				endm  
# End of macro CALLMONITOR
4138			endif	 
4138 10 d5				djnz .dashscan 
413a			 
413a			if DEBUG_FORTH_DOT 
413a				DMARK "D-1" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 a6 fd			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 a7 fd			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 a8 fd			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "D-1"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153				CALLMONITOR 
4153 cd aa fd			call debug_vector  
4156				endm  
# End of macro CALLMONITOR
4156			endif	 
4156			 
4156			.nodashswap: 
4156			 
4156			if DEBUG_FORTH_DOT 
4156				DMARK "D-o" 
4156 f5				push af  
4157 3a 6b 41			ld a, (.dmark)  
415a 32 a6 fd			ld (debug_mark),a  
415d 3a 6c 41			ld a, (.dmark+1)  
4160 32 a7 fd			ld (debug_mark+1),a  
4163 3a 6d 41			ld a, (.dmark+2)  
4166 32 a8 fd			ld (debug_mark+2),a  
4169 18 03			jr .pastdmark  
416b ..			.dmark: db "D-o"  
416e f1			.pastdmark: pop af  
416f			endm  
# End of macro DMARK
416f				CALLMONITOR 
416f cd aa fd			call debug_vector  
4172				endm  
# End of macro CALLMONITOR
4172			endif	 
4172			 
4172 d5					push de   ; save string start in case we need to advance print 
4173			 
4173 3a 99 f9				ld a, (f_cursor_ptr) 
4176 cd ae 0d				call str_at_display 
4179 3a 77 f9				ld a,(cli_autodisplay) 
417c fe 00				cp 0 
417e 28 03				jr z, .noupdate 
4180 cd be 0d						call update_display 
4183					.noupdate: 
4183			 
4183			 
4183					; see if we need to advance the print position 
4183			 
4183 e1					pop hl   ; get back string 
4184			;		ex de,hl 
4184			 
4184 3a 78 f9				ld a, (cli_mvdot) 
4187			if DEBUG_FORTH_DOT 
4187			;		ld e,a 
4187				DMARK "D>1" 
4187 f5				push af  
4188 3a 9c 41			ld a, (.dmark)  
418b 32 a6 fd			ld (debug_mark),a  
418e 3a 9d 41			ld a, (.dmark+1)  
4191 32 a7 fd			ld (debug_mark+1),a  
4194 3a 9e 41			ld a, (.dmark+2)  
4197 32 a8 fd			ld (debug_mark+2),a  
419a 18 03			jr .pastdmark  
419c ..			.dmark: db "D>1"  
419f f1			.pastdmark: pop af  
41a0			endm  
# End of macro DMARK
41a0				CALLMONITOR 
41a0 cd aa fd			call debug_vector  
41a3				endm  
# End of macro CALLMONITOR
41a3			endif	 
41a3 fe 00				cp 0 
41a5 28 44				jr z, .noadv 
41a7					; yes, lets advance the print position 
41a7 3e 00				ld a, 0 
41a9 cd 40 13				call strlent 
41ac			if DEBUG_FORTH_DOT 
41ac				DMARK "D-?" 
41ac f5				push af  
41ad 3a c1 41			ld a, (.dmark)  
41b0 32 a6 fd			ld (debug_mark),a  
41b3 3a c2 41			ld a, (.dmark+1)  
41b6 32 a7 fd			ld (debug_mark+1),a  
41b9 3a c3 41			ld a, (.dmark+2)  
41bc 32 a8 fd			ld (debug_mark+2),a  
41bf 18 03			jr .pastdmark  
41c1 ..			.dmark: db "D-?"  
41c4 f1			.pastdmark: pop af  
41c5			endm  
# End of macro DMARK
41c5				CALLMONITOR 
41c5 cd aa fd			call debug_vector  
41c8				endm  
# End of macro CALLMONITOR
41c8			endif	 
41c8 3a 99 f9				ld a, (f_cursor_ptr) 
41cb 85					add a,l 
41cc					;call addatohl 
41cc					;ld a, l 
41cc 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
41cf			 
41cf			if DEBUG_FORTH_DOT 
41cf				DMARK "D->" 
41cf f5				push af  
41d0 3a e4 41			ld a, (.dmark)  
41d3 32 a6 fd			ld (debug_mark),a  
41d6 3a e5 41			ld a, (.dmark+1)  
41d9 32 a7 fd			ld (debug_mark+1),a  
41dc 3a e6 41			ld a, (.dmark+2)  
41df 32 a8 fd			ld (debug_mark+2),a  
41e2 18 03			jr .pastdmark  
41e4 ..			.dmark: db "D->"  
41e7 f1			.pastdmark: pop af  
41e8			endm  
# End of macro DMARK
41e8				CALLMONITOR 
41e8 cd aa fd			call debug_vector  
41eb				endm  
# End of macro CALLMONITOR
41eb			endif	 
41eb			 
41eb			.noadv:	 
41eb			 
41eb					if DEBUG_FORTH_DOT_WAIT 
41eb							call next_page_prompt 
41eb					endif	 
41eb			; TODO this pop off the stack causes a crash. i dont know why 
41eb			 
41eb			 
41eb			if DEBUG_FORTH_DOT 
41eb				DMARK "DTh" 
41eb f5				push af  
41ec 3a 00 42			ld a, (.dmark)  
41ef 32 a6 fd			ld (debug_mark),a  
41f2 3a 01 42			ld a, (.dmark+1)  
41f5 32 a7 fd			ld (debug_mark+1),a  
41f8 3a 02 42			ld a, (.dmark+2)  
41fb 32 a8 fd			ld (debug_mark+2),a  
41fe 18 03			jr .pastdmark  
4200 ..			.dmark: db "DTh"  
4203 f1			.pastdmark: pop af  
4204			endm  
# End of macro DMARK
4204				CALLMONITOR 
4204 cd aa fd			call debug_vector  
4207				endm  
# End of macro CALLMONITOR
4207			endif	 
4207			 
4207					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4207 cd d2 22			call macro_forth_dsp_pop 
420a				endm 
# End of macro FORTH_DSP_POP
420a			 
420a			if DEBUG_FORTH_DOT 
420a				DMARK "DTi" 
420a f5				push af  
420b 3a 1f 42			ld a, (.dmark)  
420e 32 a6 fd			ld (debug_mark),a  
4211 3a 20 42			ld a, (.dmark+1)  
4214 32 a7 fd			ld (debug_mark+1),a  
4217 3a 21 42			ld a, (.dmark+2)  
421a 32 a8 fd			ld (debug_mark+2),a  
421d 18 03			jr .pastdmark  
421f ..			.dmark: db "DTi"  
4222 f1			.pastdmark: pop af  
4223			endm  
# End of macro DMARK
4223				CALLMONITOR 
4223 cd aa fd			call debug_vector  
4226				endm  
# End of macro CALLMONITOR
4226			endif	 
4226			 
4226			 
4226					NEXTW 
4226 c3 d0 23			jp macro_next 
4229				endm 
# End of macro NEXTW
4229			 
4229			.CLS: 
4229				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4229 35				db WORD_SYS_CORE+33             
422a 56 42			dw .DRAW            
422c 04				db 3 + 1 
422d .. 00			db "CLS",0              
4231				endm 
# End of macro CWHEAD
4231			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4231					if DEBUG_FORTH_WORDS_KEY 
4231						DMARK "CLS" 
4231 f5				push af  
4232 3a 46 42			ld a, (.dmark)  
4235 32 a6 fd			ld (debug_mark),a  
4238 3a 47 42			ld a, (.dmark+1)  
423b 32 a7 fd			ld (debug_mark+1),a  
423e 3a 48 42			ld a, (.dmark+2)  
4241 32 a8 fd			ld (debug_mark+2),a  
4244 18 03			jr .pastdmark  
4246 ..			.dmark: db "CLS"  
4249 f1			.pastdmark: pop af  
424a			endm  
# End of macro DMARK
424a						CALLMONITOR 
424a cd aa fd			call debug_vector  
424d				endm  
# End of macro CALLMONITOR
424d					endif 
424d cd 9b 0d				call clear_display 
4250 c3 64 43				jp .home		; and home cursor 
4253					NEXTW 
4253 c3 d0 23			jp macro_next 
4256				endm 
# End of macro NEXTW
4256			 
4256			.DRAW: 
4256				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4256 36				db WORD_SYS_CORE+34             
4257 81 42			dw .DUMP            
4259 05				db 4 + 1 
425a .. 00			db "DRAW",0              
425f				endm 
# End of macro CWHEAD
425f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
425f					if DEBUG_FORTH_WORDS_KEY 
425f						DMARK "DRW" 
425f f5				push af  
4260 3a 74 42			ld a, (.dmark)  
4263 32 a6 fd			ld (debug_mark),a  
4266 3a 75 42			ld a, (.dmark+1)  
4269 32 a7 fd			ld (debug_mark+1),a  
426c 3a 76 42			ld a, (.dmark+2)  
426f 32 a8 fd			ld (debug_mark+2),a  
4272 18 03			jr .pastdmark  
4274 ..			.dmark: db "DRW"  
4277 f1			.pastdmark: pop af  
4278			endm  
# End of macro DMARK
4278						CALLMONITOR 
4278 cd aa fd			call debug_vector  
427b				endm  
# End of macro CALLMONITOR
427b					endif 
427b cd be 0d				call update_display 
427e					NEXTW 
427e c3 d0 23			jp macro_next 
4281				endm 
# End of macro NEXTW
4281			 
4281			.DUMP: 
4281				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4281 37				db WORD_SYS_CORE+35             
4282 b9 42			dw .CDUMP            
4284 05				db 4 + 1 
4285 .. 00			db "DUMP",0              
428a				endm 
# End of macro CWHEAD
428a			; | DUMP ( x -- ) With address x display dump   | DONE 
428a			; TODO pop address to use off of the stack 
428a					if DEBUG_FORTH_WORDS_KEY 
428a						DMARK "DUM" 
428a f5				push af  
428b 3a 9f 42			ld a, (.dmark)  
428e 32 a6 fd			ld (debug_mark),a  
4291 3a a0 42			ld a, (.dmark+1)  
4294 32 a7 fd			ld (debug_mark+1),a  
4297 3a a1 42			ld a, (.dmark+2)  
429a 32 a8 fd			ld (debug_mark+2),a  
429d 18 03			jr .pastdmark  
429f ..			.dmark: db "DUM"  
42a2 f1			.pastdmark: pop af  
42a3			endm  
# End of macro DMARK
42a3						CALLMONITOR 
42a3 cd aa fd			call debug_vector  
42a6				endm  
# End of macro CALLMONITOR
42a6					endif 
42a6 cd 9b 0d				call clear_display 
42a9			 
42a9					; get address 
42a9			 
42a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42a9 cd 1a 22			call macro_dsp_valuehl 
42ac				endm 
# End of macro FORTH_DSP_VALUEHL
42ac				 
42ac					; save it for cdump 
42ac			 
42ac 22 1f f4				ld (os_cur_ptr),hl 
42af			 
42af					; destroy value TOS 
42af			 
42af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42af cd d2 22			call macro_forth_dsp_pop 
42b2				endm 
# End of macro FORTH_DSP_POP
42b2			 
42b2 cd a3 1e				call dumpcont	; skip old style of param parsing	 
42b5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42b6					NEXTW 
42b6 c3 d0 23			jp macro_next 
42b9				endm 
# End of macro NEXTW
42b9			.CDUMP: 
42b9				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42b9 38				db WORD_SYS_CORE+36             
42ba e9 42			dw .DAT            
42bc 06				db 5 + 1 
42bd .. 00			db "CDUMP",0              
42c3				endm 
# End of macro CWHEAD
42c3			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42c3					if DEBUG_FORTH_WORDS_KEY 
42c3						DMARK "CDP" 
42c3 f5				push af  
42c4 3a d8 42			ld a, (.dmark)  
42c7 32 a6 fd			ld (debug_mark),a  
42ca 3a d9 42			ld a, (.dmark+1)  
42cd 32 a7 fd			ld (debug_mark+1),a  
42d0 3a da 42			ld a, (.dmark+2)  
42d3 32 a8 fd			ld (debug_mark+2),a  
42d6 18 03			jr .pastdmark  
42d8 ..			.dmark: db "CDP"  
42db f1			.pastdmark: pop af  
42dc			endm  
# End of macro DMARK
42dc						CALLMONITOR 
42dc cd aa fd			call debug_vector  
42df				endm  
# End of macro CALLMONITOR
42df					endif 
42df cd 9b 0d				call clear_display 
42e2 cd a3 1e				call dumpcont	 
42e5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
42e6					NEXTW 
42e6 c3 d0 23			jp macro_next 
42e9				endm 
# End of macro NEXTW
42e9			 
42e9			 
42e9			 
42e9			 
42e9			.DAT: 
42e9				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
42e9 3d				db WORD_SYS_CORE+41             
42ea 3f 43			dw .HOME            
42ec 03				db 2 + 1 
42ed .. 00			db "AT",0              
42f0				endm 
# End of macro CWHEAD
42f0			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
42f0					if DEBUG_FORTH_WORDS_KEY 
42f0						DMARK "AT." 
42f0 f5				push af  
42f1 3a 05 43			ld a, (.dmark)  
42f4 32 a6 fd			ld (debug_mark),a  
42f7 3a 06 43			ld a, (.dmark+1)  
42fa 32 a7 fd			ld (debug_mark+1),a  
42fd 3a 07 43			ld a, (.dmark+2)  
4300 32 a8 fd			ld (debug_mark+2),a  
4303 18 03			jr .pastdmark  
4305 ..			.dmark: db "AT."  
4308 f1			.pastdmark: pop af  
4309			endm  
# End of macro DMARK
4309						CALLMONITOR 
4309 cd aa fd			call debug_vector  
430c				endm  
# End of macro CALLMONITOR
430c					endif 
430c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
430c cd 1a 22			call macro_dsp_valuehl 
430f				endm 
# End of macro FORTH_DSP_VALUEHL
430f			 
430f			 
430f					; TODO save cursor row 
430f 7d					ld a,l 
4310 fe 02				cp 2 
4312 20 04				jr nz, .crow3 
4314 3e 28				ld a, display_row_2 
4316 18 12				jr .ccol1 
4318 fe 03		.crow3:		cp 3 
431a 20 04				jr nz, .crow4 
431c 3e 50				ld a, display_row_3 
431e 18 0a				jr .ccol1 
4320 fe 04		.crow4:		cp 4 
4322 20 04				jr nz, .crow1 
4324 3e 78				ld a, display_row_4 
4326 18 02				jr .ccol1 
4328 3e 00		.crow1:		ld a,display_row_1 
432a f5			.ccol1:		push af			; got row offset 
432b 6f					ld l,a 
432c 26 00				ld h,0 
432e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
432e cd d2 22			call macro_forth_dsp_pop 
4331				endm 
# End of macro FORTH_DSP_POP
4331					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4331 cd 1a 22			call macro_dsp_valuehl 
4334				endm 
# End of macro FORTH_DSP_VALUEHL
4334					; TODO save cursor col 
4334 f1					pop af 
4335 85					add l		; add col offset 
4336 32 99 f9				ld (f_cursor_ptr), a 
4339					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4339 cd d2 22			call macro_forth_dsp_pop 
433c				endm 
# End of macro FORTH_DSP_POP
433c			 
433c					; calculate  
433c			 
433c					NEXTW 
433c c3 d0 23			jp macro_next 
433f				endm 
# End of macro NEXTW
433f			 
433f			 
433f			.HOME: 
433f				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
433f 41				db WORD_SYS_CORE+45             
4340 6c 43			dw .CR            
4342 05				db 4 + 1 
4343 .. 00			db "HOME",0              
4348				endm 
# End of macro CWHEAD
4348			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4348					if DEBUG_FORTH_WORDS_KEY 
4348						DMARK "HOM" 
4348 f5				push af  
4349 3a 5d 43			ld a, (.dmark)  
434c 32 a6 fd			ld (debug_mark),a  
434f 3a 5e 43			ld a, (.dmark+1)  
4352 32 a7 fd			ld (debug_mark+1),a  
4355 3a 5f 43			ld a, (.dmark+2)  
4358 32 a8 fd			ld (debug_mark+2),a  
435b 18 03			jr .pastdmark  
435d ..			.dmark: db "HOM"  
4360 f1			.pastdmark: pop af  
4361			endm  
# End of macro DMARK
4361						CALLMONITOR 
4361 cd aa fd			call debug_vector  
4364				endm  
# End of macro CALLMONITOR
4364					endif 
4364 3e 00		.home:		ld a, 0		; and home cursor 
4366 32 99 f9				ld (f_cursor_ptr), a 
4369					NEXTW 
4369 c3 d0 23			jp macro_next 
436c				endm 
# End of macro NEXTW
436c			 
436c			 
436c			.CR: 
436c				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
436c 46				db WORD_SYS_CORE+50             
436d a7 43			dw .SPACE            
436f 03				db 2 + 1 
4370 .. 00			db "CR",0              
4373				endm 
# End of macro CWHEAD
4373			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4373					if DEBUG_FORTH_WORDS_KEY 
4373						DMARK "CR." 
4373 f5				push af  
4374 3a 88 43			ld a, (.dmark)  
4377 32 a6 fd			ld (debug_mark),a  
437a 3a 89 43			ld a, (.dmark+1)  
437d 32 a7 fd			ld (debug_mark+1),a  
4380 3a 8a 43			ld a, (.dmark+2)  
4383 32 a8 fd			ld (debug_mark+2),a  
4386 18 03			jr .pastdmark  
4388 ..			.dmark: db "CR."  
438b f1			.pastdmark: pop af  
438c			endm  
# End of macro DMARK
438c						CALLMONITOR 
438c cd aa fd			call debug_vector  
438f				endm  
# End of macro CALLMONITOR
438f					endif 
438f 3e 0d				ld a, 13 
4391 32 fc f0				ld (scratch),a 
4394 3e 0a				ld a, 10 
4396 32 fd f0				ld (scratch+1),a 
4399 3e 00				ld a, 0 
439b 32 fe f0				ld (scratch+2),a 
439e 21 fc f0				ld hl, scratch 
43a1 cd 91 20				call forth_push_str 
43a4					 
43a4				       NEXTW 
43a4 c3 d0 23			jp macro_next 
43a7				endm 
# End of macro NEXTW
43a7			.SPACE: 
43a7				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
43a7 46				db WORD_SYS_CORE+50             
43a8 dd 43			dw .SPACES            
43aa 03				db 2 + 1 
43ab .. 00			db "BL",0              
43ae				endm 
# End of macro CWHEAD
43ae			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
43ae					if DEBUG_FORTH_WORDS_KEY 
43ae						DMARK "BL." 
43ae f5				push af  
43af 3a c3 43			ld a, (.dmark)  
43b2 32 a6 fd			ld (debug_mark),a  
43b5 3a c4 43			ld a, (.dmark+1)  
43b8 32 a7 fd			ld (debug_mark+1),a  
43bb 3a c5 43			ld a, (.dmark+2)  
43be 32 a8 fd			ld (debug_mark+2),a  
43c1 18 03			jr .pastdmark  
43c3 ..			.dmark: db "BL."  
43c6 f1			.pastdmark: pop af  
43c7			endm  
# End of macro DMARK
43c7						CALLMONITOR 
43c7 cd aa fd			call debug_vector  
43ca				endm  
# End of macro CALLMONITOR
43ca					endif 
43ca 3e 20				ld a, " " 
43cc 32 fc f0				ld (scratch),a 
43cf 3e 00				ld a, 0 
43d1 32 fd f0				ld (scratch+1),a 
43d4 21 fc f0				ld hl, scratch 
43d7 cd 91 20				call forth_push_str 
43da					 
43da				       NEXTW 
43da c3 d0 23			jp macro_next 
43dd				endm 
# End of macro NEXTW
43dd			 
43dd			;.blstr: db " ", 0 
43dd			 
43dd			.SPACES: 
43dd				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
43dd 47				db WORD_SYS_CORE+51             
43de 78 44			dw .SCROLL            
43e0 07				db 6 + 1 
43e1 .. 00			db "SPACES",0              
43e8				endm 
# End of macro CWHEAD
43e8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43e8					if DEBUG_FORTH_WORDS_KEY 
43e8						DMARK "SPS" 
43e8 f5				push af  
43e9 3a fd 43			ld a, (.dmark)  
43ec 32 a6 fd			ld (debug_mark),a  
43ef 3a fe 43			ld a, (.dmark+1)  
43f2 32 a7 fd			ld (debug_mark+1),a  
43f5 3a ff 43			ld a, (.dmark+2)  
43f8 32 a8 fd			ld (debug_mark+2),a  
43fb 18 03			jr .pastdmark  
43fd ..			.dmark: db "SPS"  
4400 f1			.pastdmark: pop af  
4401			endm  
# End of macro DMARK
4401						CALLMONITOR 
4401 cd aa fd			call debug_vector  
4404				endm  
# End of macro CALLMONITOR
4404					endif 
4404			 
4404			 
4404					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4404 cd 1a 22			call macro_dsp_valuehl 
4407				endm 
# End of macro FORTH_DSP_VALUEHL
4407			 
4407 e5					push hl    ; u 
4408					if DEBUG_FORTH_WORDS 
4408						DMARK "SPA" 
4408 f5				push af  
4409 3a 1d 44			ld a, (.dmark)  
440c 32 a6 fd			ld (debug_mark),a  
440f 3a 1e 44			ld a, (.dmark+1)  
4412 32 a7 fd			ld (debug_mark+1),a  
4415 3a 1f 44			ld a, (.dmark+2)  
4418 32 a8 fd			ld (debug_mark+2),a  
441b 18 03			jr .pastdmark  
441d ..			.dmark: db "SPA"  
4420 f1			.pastdmark: pop af  
4421			endm  
# End of macro DMARK
4421						CALLMONITOR 
4421 cd aa fd			call debug_vector  
4424				endm  
# End of macro CALLMONITOR
4424					endif 
4424			 
4424					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4424 cd d2 22			call macro_forth_dsp_pop 
4427				endm 
# End of macro FORTH_DSP_POP
4427 e1					pop hl 
4428 0e 00				ld c, 0 
442a 45					ld b, l 
442b 21 fc f0				ld hl, scratch  
442e			 
442e					if DEBUG_FORTH_WORDS 
442e						DMARK "SP2" 
442e f5				push af  
442f 3a 43 44			ld a, (.dmark)  
4432 32 a6 fd			ld (debug_mark),a  
4435 3a 44 44			ld a, (.dmark+1)  
4438 32 a7 fd			ld (debug_mark+1),a  
443b 3a 45 44			ld a, (.dmark+2)  
443e 32 a8 fd			ld (debug_mark+2),a  
4441 18 03			jr .pastdmark  
4443 ..			.dmark: db "SP2"  
4446 f1			.pastdmark: pop af  
4447			endm  
# End of macro DMARK
4447						CALLMONITOR 
4447 cd aa fd			call debug_vector  
444a				endm  
# End of macro CALLMONITOR
444a					endif 
444a 3e 20				ld a, ' ' 
444c			.spaces1:	 
444c 77					ld (hl),a 
444d 23					inc hl 
444e					 
444e 10 fc				djnz .spaces1 
4450 3e 00				ld a,0 
4452 77					ld (hl),a 
4453 21 fc f0				ld hl, scratch 
4456					if DEBUG_FORTH_WORDS 
4456						DMARK "SP3" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 a6 fd			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 a7 fd			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 a8 fd			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "SP3"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd aa fd			call debug_vector  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472 cd 91 20				call forth_push_str 
4475			 
4475				       NEXTW 
4475 c3 d0 23			jp macro_next 
4478				endm 
# End of macro NEXTW
4478			 
4478			 
4478			 
4478			.SCROLL: 
4478				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4478 53				db WORD_SYS_CORE+63             
4479 a5 44			dw .SCROLLD            
447b 07				db 6 + 1 
447c .. 00			db "SCROLL",0              
4483				endm 
# End of macro CWHEAD
4483			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4483					if DEBUG_FORTH_WORDS_KEY 
4483						DMARK "SCR" 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 a6 fd			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 a7 fd			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 a8 fd			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "SCR"  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c						CALLMONITOR 
449c cd aa fd			call debug_vector  
449f				endm  
# End of macro CALLMONITOR
449f					endif 
449f			 
449f cd 5d 0d			call scroll_up 
44a2			;	call update_display 
44a2			 
44a2					NEXTW 
44a2 c3 d0 23			jp macro_next 
44a5				endm 
# End of macro NEXTW
44a5			 
44a5			 
44a5			 
44a5			;		; get dir 
44a5			; 
44a5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44a5			; 
44a5			;		push hl 
44a5			; 
44a5			;		; destroy value TOS 
44a5			; 
44a5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44a5			; 
44a5			;		; get count 
44a5			; 
44a5			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44a5			; 
44a5			;		push hl 
44a5			; 
44a5			;		; destroy value TOS 
44a5			; 
44a5			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44a5			; 
44a5			;		; one value on hl get other one back 
44a5			; 
44a5			;		pop bc    ; count 
44a5			; 
44a5			;		pop de   ; dir 
44a5			; 
44a5			; 
44a5			;		ld b, c 
44a5			; 
44a5			;.scrolldir:     push bc 
44a5			;		push de 
44a5			; 
44a5			;		ld a, 0 
44a5			;		cp e 
44a5			;		jr z, .scrollup  
44a5			;		call scroll_down 
44a5			;		jr .scrollnext 
44a5			;.scrollup:	call scroll_up 
44a5			; 
44a5			;		 
44a5			;.scrollnext: 
44a5			;		pop de 
44a5			;		pop bc 
44a5			;		djnz .scrolldir 
44a5			; 
44a5			; 
44a5			; 
44a5			; 
44a5			; 
44a5			;		NEXTW 
44a5			 
44a5			.SCROLLD: 
44a5				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
44a5 53				db WORD_SYS_CORE+63             
44a6 d3 44			dw .ATQ            
44a8 08				db 7 + 1 
44a9 .. 00			db "SCROLLD",0              
44b1				endm 
# End of macro CWHEAD
44b1			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
44b1					if DEBUG_FORTH_WORDS_KEY 
44b1						DMARK "SCD" 
44b1 f5				push af  
44b2 3a c6 44			ld a, (.dmark)  
44b5 32 a6 fd			ld (debug_mark),a  
44b8 3a c7 44			ld a, (.dmark+1)  
44bb 32 a7 fd			ld (debug_mark+1),a  
44be 3a c8 44			ld a, (.dmark+2)  
44c1 32 a8 fd			ld (debug_mark+2),a  
44c4 18 03			jr .pastdmark  
44c6 ..			.dmark: db "SCD"  
44c9 f1			.pastdmark: pop af  
44ca			endm  
# End of macro DMARK
44ca						CALLMONITOR 
44ca cd aa fd			call debug_vector  
44cd				endm  
# End of macro CALLMONITOR
44cd					endif 
44cd			 
44cd cd 81 0d			call scroll_down 
44d0			;	call update_display 
44d0			 
44d0					NEXTW 
44d0 c3 d0 23			jp macro_next 
44d3				endm 
# End of macro NEXTW
44d3			 
44d3			 
44d3			.ATQ: 
44d3				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
44d3 62				db WORD_SYS_CORE+78             
44d4 31 45			dw .AUTODSP            
44d6 04				db 3 + 1 
44d7 .. 00			db "AT@",0              
44db				endm 
# End of macro CWHEAD
44db			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
44db					if DEBUG_FORTH_WORDS_KEY 
44db						DMARK "ATA" 
44db f5				push af  
44dc 3a f0 44			ld a, (.dmark)  
44df 32 a6 fd			ld (debug_mark),a  
44e2 3a f1 44			ld a, (.dmark+1)  
44e5 32 a7 fd			ld (debug_mark+1),a  
44e8 3a f2 44			ld a, (.dmark+2)  
44eb 32 a8 fd			ld (debug_mark+2),a  
44ee 18 03			jr .pastdmark  
44f0 ..			.dmark: db "ATA"  
44f3 f1			.pastdmark: pop af  
44f4			endm  
# End of macro DMARK
44f4						CALLMONITOR 
44f4 cd aa fd			call debug_vector  
44f7				endm  
# End of macro CALLMONITOR
44f7					endif 
44f7			 
44f7			 
44f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44f7 cd 1a 22			call macro_dsp_valuehl 
44fa				endm 
# End of macro FORTH_DSP_VALUEHL
44fa			 
44fa					; TODO save cursor row 
44fa 7d					ld a,l 
44fb fe 02				cp 2 
44fd 20 04				jr nz, .crow3aq 
44ff 3e 28				ld a, display_row_2 
4501 18 12				jr .ccol1aq 
4503 fe 03		.crow3aq:		cp 3 
4505 20 04				jr nz, .crow4aq 
4507 3e 50				ld a, display_row_3 
4509 18 0a				jr .ccol1aq 
450b fe 04		.crow4aq:		cp 4 
450d 20 04				jr nz, .crow1aq 
450f 3e 78				ld a, display_row_4 
4511 18 02				jr .ccol1aq 
4513 3e 00		.crow1aq:		ld a,display_row_1 
4515 f5			.ccol1aq:		push af			; got row offset 
4516 6f					ld l,a 
4517 26 00				ld h,0 
4519					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4519 cd d2 22			call macro_forth_dsp_pop 
451c				endm 
# End of macro FORTH_DSP_POP
451c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
451c cd 1a 22			call macro_dsp_valuehl 
451f				endm 
# End of macro FORTH_DSP_VALUEHL
451f					; TODO save cursor col 
451f f1					pop af 
4520 85					add l		; add col offset 
4521			 
4521					; add current frame buffer address 
4521 2a 07 fb				ld hl, (display_fb_active) 
4524 cd cf 0f				call addatohl 
4527			 
4527			 
4527			 
4527			 
4527					; get char frame buffer location offset in hl 
4527			 
4527 7e					ld a,(hl) 
4528 26 00				ld h, 0 
452a 6f					ld l, a 
452b			 
452b cd 23 20				call forth_push_numhl 
452e			 
452e			 
452e					NEXTW 
452e c3 d0 23			jp macro_next 
4531				endm 
# End of macro NEXTW
4531			 
4531			.AUTODSP: 
4531				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4531 63				db WORD_SYS_CORE+79             
4532 47 45			dw .MENU            
4534 05				db 4 + 1 
4535 .. 00			db "ADSP",0              
453a				endm 
# End of macro CWHEAD
453a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
453a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
453a			 
453a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
453a cd 1a 22			call macro_dsp_valuehl 
453d				endm 
# End of macro FORTH_DSP_VALUEHL
453d			 
453d			;		push hl 
453d			 
453d					; destroy value TOS 
453d			 
453d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
453d cd d2 22			call macro_forth_dsp_pop 
4540				endm 
# End of macro FORTH_DSP_POP
4540			 
4540			;		pop hl 
4540			 
4540 7d					ld a,l 
4541 32 77 f9				ld (cli_autodisplay), a 
4544				       NEXTW 
4544 c3 d0 23			jp macro_next 
4547				endm 
# End of macro NEXTW
4547			 
4547			.MENU: 
4547				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4547 70				db WORD_SYS_CORE+92             
4548 f0 45			dw .ENDDISPLAY            
454a 05				db 4 + 1 
454b .. 00			db "MENU",0              
4550				endm 
# End of macro CWHEAD
4550			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4550			 
4550			;		; get number of items on the stack 
4550			; 
4550				 
4550					FORTH_DSP_VALUEHL 
4550 cd 1a 22			call macro_dsp_valuehl 
4553				endm 
# End of macro FORTH_DSP_VALUEHL
4553				 
4553					if DEBUG_FORTH_WORDS_KEY 
4553						DMARK "MNU" 
4553 f5				push af  
4554 3a 68 45			ld a, (.dmark)  
4557 32 a6 fd			ld (debug_mark),a  
455a 3a 69 45			ld a, (.dmark+1)  
455d 32 a7 fd			ld (debug_mark+1),a  
4560 3a 6a 45			ld a, (.dmark+2)  
4563 32 a8 fd			ld (debug_mark+2),a  
4566 18 03			jr .pastdmark  
4568 ..			.dmark: db "MNU"  
456b f1			.pastdmark: pop af  
456c			endm  
# End of macro DMARK
456c						CALLMONITOR 
456c cd aa fd			call debug_vector  
456f				endm  
# End of macro CALLMONITOR
456f					endif 
456f			 
456f 45					ld b, l	 
4570 05					dec b 
4571			 
4571					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4571 cd d2 22			call macro_forth_dsp_pop 
4574				endm 
# End of macro FORTH_DSP_POP
4574			 
4574			 
4574					; go directly through the stack to pluck out the string pointers and build an array 
4574			 
4574			;		FORTH_DSP 
4574			 
4574					; hl contains top most stack item 
4574				 
4574 11 fc f0				ld de, scratch 
4577			 
4577			.mbuild: 
4577			 
4577					FORTH_DSP_VALUEHL 
4577 cd 1a 22			call macro_dsp_valuehl 
457a				endm 
# End of macro FORTH_DSP_VALUEHL
457a			 
457a					if DEBUG_FORTH_WORDS 
457a						DMARK "MN3" 
457a f5				push af  
457b 3a 8f 45			ld a, (.dmark)  
457e 32 a6 fd			ld (debug_mark),a  
4581 3a 90 45			ld a, (.dmark+1)  
4584 32 a7 fd			ld (debug_mark+1),a  
4587 3a 91 45			ld a, (.dmark+2)  
458a 32 a8 fd			ld (debug_mark+2),a  
458d 18 03			jr .pastdmark  
458f ..			.dmark: db "MN3"  
4592 f1			.pastdmark: pop af  
4593			endm  
# End of macro DMARK
4593						CALLMONITOR 
4593 cd aa fd			call debug_vector  
4596				endm  
# End of macro CALLMONITOR
4596					endif 
4596 eb					ex de, hl 
4597 73					ld (hl), e 
4598 23					inc hl 
4599 72					ld (hl), d 
459a 23					inc hl 
459b eb					ex de, hl 
459c			 
459c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
459c cd d2 22			call macro_forth_dsp_pop 
459f				endm 
# End of macro FORTH_DSP_POP
459f			 
459f 10 d6				djnz .mbuild 
45a1			 
45a1					; done add term 
45a1			 
45a1 eb					ex de, hl 
45a2 36 00				ld (hl), 0 
45a4 23					inc hl 
45a5 36 00				ld (hl), 0 
45a7			 
45a7				 
45a7					 
45a7 21 fc f0				ld hl, scratch 
45aa			 
45aa					if DEBUG_FORTH_WORDS 
45aa						DMARK "MNx" 
45aa f5				push af  
45ab 3a bf 45			ld a, (.dmark)  
45ae 32 a6 fd			ld (debug_mark),a  
45b1 3a c0 45			ld a, (.dmark+1)  
45b4 32 a7 fd			ld (debug_mark+1),a  
45b7 3a c1 45			ld a, (.dmark+2)  
45ba 32 a8 fd			ld (debug_mark+2),a  
45bd 18 03			jr .pastdmark  
45bf ..			.dmark: db "MNx"  
45c2 f1			.pastdmark: pop af  
45c3			endm  
# End of macro DMARK
45c3						CALLMONITOR 
45c3 cd aa fd			call debug_vector  
45c6				endm  
# End of macro CALLMONITOR
45c6					endif 
45c6			 
45c6			 
45c6			 
45c6 3e 00				ld a, 0 
45c8 cd cc 0d				call menu 
45cb			 
45cb			 
45cb 6f					ld l, a 
45cc 26 00				ld h, 0 
45ce			 
45ce					if DEBUG_FORTH_WORDS 
45ce						DMARK "MNr" 
45ce f5				push af  
45cf 3a e3 45			ld a, (.dmark)  
45d2 32 a6 fd			ld (debug_mark),a  
45d5 3a e4 45			ld a, (.dmark+1)  
45d8 32 a7 fd			ld (debug_mark+1),a  
45db 3a e5 45			ld a, (.dmark+2)  
45de 32 a8 fd			ld (debug_mark+2),a  
45e1 18 03			jr .pastdmark  
45e3 ..			.dmark: db "MNr"  
45e6 f1			.pastdmark: pop af  
45e7			endm  
# End of macro DMARK
45e7						CALLMONITOR 
45e7 cd aa fd			call debug_vector  
45ea				endm  
# End of macro CALLMONITOR
45ea					endif 
45ea			 
45ea cd 23 20				call forth_push_numhl 
45ed			 
45ed			 
45ed			 
45ed			 
45ed				       NEXTW 
45ed c3 d0 23			jp macro_next 
45f0				endm 
# End of macro NEXTW
45f0			 
45f0			 
45f0			.ENDDISPLAY: 
45f0			 
45f0			; eof 
# End of file forth_words_display.asm
45f0			include "forth_words_str.asm" 
45f0			 
45f0			; | ## String Words 
45f0			 
45f0			.PTR:   
45f0			 
45f0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45f0 48				db WORD_SYS_CORE+52             
45f1 1d 46			dw .STYPE            
45f3 04				db 3 + 1 
45f4 .. 00			db "PTR",0              
45f8				endm 
# End of macro CWHEAD
45f8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
45f8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
45f8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
45f8			 
45f8					if DEBUG_FORTH_WORDS_KEY 
45f8						DMARK "PTR" 
45f8 f5				push af  
45f9 3a 0d 46			ld a, (.dmark)  
45fc 32 a6 fd			ld (debug_mark),a  
45ff 3a 0e 46			ld a, (.dmark+1)  
4602 32 a7 fd			ld (debug_mark+1),a  
4605 3a 0f 46			ld a, (.dmark+2)  
4608 32 a8 fd			ld (debug_mark+2),a  
460b 18 03			jr .pastdmark  
460d ..			.dmark: db "PTR"  
4610 f1			.pastdmark: pop af  
4611			endm  
# End of macro DMARK
4611						CALLMONITOR 
4611 cd aa fd			call debug_vector  
4614				endm  
# End of macro CALLMONITOR
4614					endif 
4614					FORTH_DSP_VALUEHL 
4614 cd 1a 22			call macro_dsp_valuehl 
4617				endm 
# End of macro FORTH_DSP_VALUEHL
4617 cd 23 20				call forth_push_numhl 
461a			 
461a			 
461a					NEXTW 
461a c3 d0 23			jp macro_next 
461d				endm 
# End of macro NEXTW
461d			.STYPE: 
461d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
461d 48				db WORD_SYS_CORE+52             
461e 6c 46			dw .UPPER            
4620 06				db 5 + 1 
4621 .. 00			db "STYPE",0              
4627				endm 
# End of macro CWHEAD
4627			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4627					if DEBUG_FORTH_WORDS_KEY 
4627						DMARK "STY" 
4627 f5				push af  
4628 3a 3c 46			ld a, (.dmark)  
462b 32 a6 fd			ld (debug_mark),a  
462e 3a 3d 46			ld a, (.dmark+1)  
4631 32 a7 fd			ld (debug_mark+1),a  
4634 3a 3e 46			ld a, (.dmark+2)  
4637 32 a8 fd			ld (debug_mark+2),a  
463a 18 03			jr .pastdmark  
463c ..			.dmark: db "STY"  
463f f1			.pastdmark: pop af  
4640			endm  
# End of macro DMARK
4640						CALLMONITOR 
4640 cd aa fd			call debug_vector  
4643				endm  
# End of macro CALLMONITOR
4643					endif 
4643					FORTH_DSP 
4643 cd e0 21			call macro_forth_dsp 
4646				endm 
# End of macro FORTH_DSP
4646					;v5 FORTH_DSP_VALUE 
4646			 
4646 7e					ld a, (hl) 
4647			 
4647 f5					push af 
4648			 
4648			; Dont destroy TOS		FORTH_DSP_POP 
4648			 
4648 f1					pop af 
4649			 
4649 fe 01				cp DS_TYPE_STR 
464b 28 09				jr z, .typestr 
464d			 
464d fe 02				cp DS_TYPE_INUM 
464f 28 0a				jr z, .typeinum 
4651			 
4651 21 6a 46				ld hl, .tna 
4654 18 0a				jr .tpush 
4656			 
4656 21 66 46		.typestr:	ld hl, .tstr 
4659 18 05				jr .tpush 
465b 21 68 46		.typeinum:	ld hl, .tinum 
465e 18 00				jr .tpush 
4660			 
4660			.tpush: 
4660			 
4660 cd 91 20				call forth_push_str 
4663			 
4663					NEXTW 
4663 c3 d0 23			jp macro_next 
4666				endm 
# End of macro NEXTW
4666 .. 00		.tstr:	db "s",0 
4668 .. 00		.tinum:  db "i",0 
466a .. 00		.tna:   db "?", 0 
466c			 
466c			 
466c			.UPPER: 
466c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
466c 48				db WORD_SYS_CORE+52             
466d a7 46			dw .LOWER            
466f 06				db 5 + 1 
4670 .. 00			db "UPPER",0              
4676				endm 
# End of macro CWHEAD
4676			; | UPPER ( s -- s ) Upper case string s  | DONE 
4676					if DEBUG_FORTH_WORDS_KEY 
4676						DMARK "UPR" 
4676 f5				push af  
4677 3a 8b 46			ld a, (.dmark)  
467a 32 a6 fd			ld (debug_mark),a  
467d 3a 8c 46			ld a, (.dmark+1)  
4680 32 a7 fd			ld (debug_mark+1),a  
4683 3a 8d 46			ld a, (.dmark+2)  
4686 32 a8 fd			ld (debug_mark+2),a  
4689 18 03			jr .pastdmark  
468b ..			.dmark: db "UPR"  
468e f1			.pastdmark: pop af  
468f			endm  
# End of macro DMARK
468f						CALLMONITOR 
468f cd aa fd			call debug_vector  
4692				endm  
# End of macro CALLMONITOR
4692					endif 
4692			 
4692					FORTH_DSP 
4692 cd e0 21			call macro_forth_dsp 
4695				endm 
# End of macro FORTH_DSP
4695					 
4695			; TODO check is string type 
4695			 
4695					FORTH_DSP_VALUEHL 
4695 cd 1a 22			call macro_dsp_valuehl 
4698				endm 
# End of macro FORTH_DSP_VALUEHL
4698			; get pointer to string in hl 
4698			 
4698 7e			.toup:		ld a, (hl) 
4699 fe 00				cp 0 
469b 28 07				jr z, .toupdone 
469d			 
469d cd 44 12				call to_upper 
46a0			 
46a0 77					ld (hl), a 
46a1 23					inc hl 
46a2 18 f4				jr .toup 
46a4			 
46a4					 
46a4			 
46a4			 
46a4			; for each char convert to upper 
46a4					 
46a4			.toupdone: 
46a4			 
46a4			 
46a4					NEXTW 
46a4 c3 d0 23			jp macro_next 
46a7				endm 
# End of macro NEXTW
46a7			.LOWER: 
46a7				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
46a7 48				db WORD_SYS_CORE+52             
46a8 e2 46			dw .TCASE            
46aa 06				db 5 + 1 
46ab .. 00			db "LOWER",0              
46b1				endm 
# End of macro CWHEAD
46b1			; | LOWER ( s -- s ) Lower case string s  | DONE 
46b1					if DEBUG_FORTH_WORDS_KEY 
46b1						DMARK "LWR" 
46b1 f5				push af  
46b2 3a c6 46			ld a, (.dmark)  
46b5 32 a6 fd			ld (debug_mark),a  
46b8 3a c7 46			ld a, (.dmark+1)  
46bb 32 a7 fd			ld (debug_mark+1),a  
46be 3a c8 46			ld a, (.dmark+2)  
46c1 32 a8 fd			ld (debug_mark+2),a  
46c4 18 03			jr .pastdmark  
46c6 ..			.dmark: db "LWR"  
46c9 f1			.pastdmark: pop af  
46ca			endm  
# End of macro DMARK
46ca						CALLMONITOR 
46ca cd aa fd			call debug_vector  
46cd				endm  
# End of macro CALLMONITOR
46cd					endif 
46cd			 
46cd					FORTH_DSP 
46cd cd e0 21			call macro_forth_dsp 
46d0				endm 
# End of macro FORTH_DSP
46d0					 
46d0			; TODO check is string type 
46d0			 
46d0					FORTH_DSP_VALUEHL 
46d0 cd 1a 22			call macro_dsp_valuehl 
46d3				endm 
# End of macro FORTH_DSP_VALUEHL
46d3			; get pointer to string in hl 
46d3			 
46d3 7e			.tolow:		ld a, (hl) 
46d4 fe 00				cp 0 
46d6 28 07				jr z, .tolowdone 
46d8			 
46d8 cd 4d 12				call to_lower 
46db			 
46db 77					ld (hl), a 
46dc 23					inc hl 
46dd 18 f4				jr .tolow 
46df			 
46df					 
46df			 
46df			 
46df			; for each char convert to low 
46df					 
46df			.tolowdone: 
46df					NEXTW 
46df c3 d0 23			jp macro_next 
46e2				endm 
# End of macro NEXTW
46e2			.TCASE: 
46e2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46e2 48				db WORD_SYS_CORE+52             
46e3 18 48			dw .SUBSTR            
46e5 06				db 5 + 1 
46e6 .. 00			db "TCASE",0              
46ec				endm 
# End of macro CWHEAD
46ec			; | TCASE ( s -- s ) Title case string s  | DONE 
46ec					if DEBUG_FORTH_WORDS_KEY 
46ec						DMARK "TCS" 
46ec f5				push af  
46ed 3a 01 47			ld a, (.dmark)  
46f0 32 a6 fd			ld (debug_mark),a  
46f3 3a 02 47			ld a, (.dmark+1)  
46f6 32 a7 fd			ld (debug_mark+1),a  
46f9 3a 03 47			ld a, (.dmark+2)  
46fc 32 a8 fd			ld (debug_mark+2),a  
46ff 18 03			jr .pastdmark  
4701 ..			.dmark: db "TCS"  
4704 f1			.pastdmark: pop af  
4705			endm  
# End of macro DMARK
4705						CALLMONITOR 
4705 cd aa fd			call debug_vector  
4708				endm  
# End of macro CALLMONITOR
4708					endif 
4708			 
4708					FORTH_DSP 
4708 cd e0 21			call macro_forth_dsp 
470b				endm 
# End of macro FORTH_DSP
470b					 
470b			; TODO check is string type 
470b			 
470b					FORTH_DSP_VALUEHL 
470b cd 1a 22			call macro_dsp_valuehl 
470e				endm 
# End of macro FORTH_DSP_VALUEHL
470e			; get pointer to string in hl 
470e			 
470e					if DEBUG_FORTH_WORDS 
470e						DMARK "TC1" 
470e f5				push af  
470f 3a 23 47			ld a, (.dmark)  
4712 32 a6 fd			ld (debug_mark),a  
4715 3a 24 47			ld a, (.dmark+1)  
4718 32 a7 fd			ld (debug_mark+1),a  
471b 3a 25 47			ld a, (.dmark+2)  
471e 32 a8 fd			ld (debug_mark+2),a  
4721 18 03			jr .pastdmark  
4723 ..			.dmark: db "TC1"  
4726 f1			.pastdmark: pop af  
4727			endm  
# End of macro DMARK
4727						CALLMONITOR 
4727 cd aa fd			call debug_vector  
472a				endm  
# End of macro CALLMONITOR
472a					endif 
472a			 
472a					; first time in turn to upper case first char 
472a			 
472a 7e					ld a, (hl) 
472b c3 b5 47				jp .totsiptou 
472e			 
472e			 
472e 7e			.tot:		ld a, (hl) 
472f fe 00				cp 0 
4731 ca f9 47				jp z, .totdone 
4734			 
4734					if DEBUG_FORTH_WORDS 
4734						DMARK "TC2" 
4734 f5				push af  
4735 3a 49 47			ld a, (.dmark)  
4738 32 a6 fd			ld (debug_mark),a  
473b 3a 4a 47			ld a, (.dmark+1)  
473e 32 a7 fd			ld (debug_mark+1),a  
4741 3a 4b 47			ld a, (.dmark+2)  
4744 32 a8 fd			ld (debug_mark+2),a  
4747 18 03			jr .pastdmark  
4749 ..			.dmark: db "TC2"  
474c f1			.pastdmark: pop af  
474d			endm  
# End of macro DMARK
474d						CALLMONITOR 
474d cd aa fd			call debug_vector  
4750				endm  
# End of macro CALLMONITOR
4750					endif 
4750					; check to see if current char is a space 
4750			 
4750 fe 20				cp ' ' 
4752 28 21				jr z, .totsp 
4754 cd 4d 12				call to_lower 
4757					if DEBUG_FORTH_WORDS 
4757						DMARK "TC3" 
4757 f5				push af  
4758 3a 6c 47			ld a, (.dmark)  
475b 32 a6 fd			ld (debug_mark),a  
475e 3a 6d 47			ld a, (.dmark+1)  
4761 32 a7 fd			ld (debug_mark+1),a  
4764 3a 6e 47			ld a, (.dmark+2)  
4767 32 a8 fd			ld (debug_mark+2),a  
476a 18 03			jr .pastdmark  
476c ..			.dmark: db "TC3"  
476f f1			.pastdmark: pop af  
4770			endm  
# End of macro DMARK
4770						CALLMONITOR 
4770 cd aa fd			call debug_vector  
4773				endm  
# End of macro CALLMONITOR
4773					endif 
4773 18 63				jr .totnxt 
4775			 
4775			.totsp:         ; on a space, find next char which should be upper 
4775			 
4775					if DEBUG_FORTH_WORDS 
4775						DMARK "TC4" 
4775 f5				push af  
4776 3a 8a 47			ld a, (.dmark)  
4779 32 a6 fd			ld (debug_mark),a  
477c 3a 8b 47			ld a, (.dmark+1)  
477f 32 a7 fd			ld (debug_mark+1),a  
4782 3a 8c 47			ld a, (.dmark+2)  
4785 32 a8 fd			ld (debug_mark+2),a  
4788 18 03			jr .pastdmark  
478a ..			.dmark: db "TC4"  
478d f1			.pastdmark: pop af  
478e			endm  
# End of macro DMARK
478e						CALLMONITOR 
478e cd aa fd			call debug_vector  
4791				endm  
# End of macro CALLMONITOR
4791					endif 
4791					;; 
4791			 
4791 fe 20				cp ' ' 
4793 20 20				jr nz, .totsiptou 
4795 23					inc hl 
4796 7e					ld a, (hl) 
4797					if DEBUG_FORTH_WORDS 
4797						DMARK "TC5" 
4797 f5				push af  
4798 3a ac 47			ld a, (.dmark)  
479b 32 a6 fd			ld (debug_mark),a  
479e 3a ad 47			ld a, (.dmark+1)  
47a1 32 a7 fd			ld (debug_mark+1),a  
47a4 3a ae 47			ld a, (.dmark+2)  
47a7 32 a8 fd			ld (debug_mark+2),a  
47aa 18 03			jr .pastdmark  
47ac ..			.dmark: db "TC5"  
47af f1			.pastdmark: pop af  
47b0			endm  
# End of macro DMARK
47b0						CALLMONITOR 
47b0 cd aa fd			call debug_vector  
47b3				endm  
# End of macro CALLMONITOR
47b3					endif 
47b3 18 c0				jr .totsp 
47b5 fe 00		.totsiptou:    cp 0 
47b7 28 40				jr z, .totdone 
47b9					; not space and not zero term so upper case it 
47b9 cd 44 12				call to_upper 
47bc			 
47bc					if DEBUG_FORTH_WORDS 
47bc						DMARK "TC6" 
47bc f5				push af  
47bd 3a d1 47			ld a, (.dmark)  
47c0 32 a6 fd			ld (debug_mark),a  
47c3 3a d2 47			ld a, (.dmark+1)  
47c6 32 a7 fd			ld (debug_mark+1),a  
47c9 3a d3 47			ld a, (.dmark+2)  
47cc 32 a8 fd			ld (debug_mark+2),a  
47cf 18 03			jr .pastdmark  
47d1 ..			.dmark: db "TC6"  
47d4 f1			.pastdmark: pop af  
47d5			endm  
# End of macro DMARK
47d5						CALLMONITOR 
47d5 cd aa fd			call debug_vector  
47d8				endm  
# End of macro CALLMONITOR
47d8					endif 
47d8			 
47d8			 
47d8			.totnxt: 
47d8			 
47d8 77					ld (hl), a 
47d9 23					inc hl 
47da					if DEBUG_FORTH_WORDS 
47da						DMARK "TC7" 
47da f5				push af  
47db 3a ef 47			ld a, (.dmark)  
47de 32 a6 fd			ld (debug_mark),a  
47e1 3a f0 47			ld a, (.dmark+1)  
47e4 32 a7 fd			ld (debug_mark+1),a  
47e7 3a f1 47			ld a, (.dmark+2)  
47ea 32 a8 fd			ld (debug_mark+2),a  
47ed 18 03			jr .pastdmark  
47ef ..			.dmark: db "TC7"  
47f2 f1			.pastdmark: pop af  
47f3			endm  
# End of macro DMARK
47f3						CALLMONITOR 
47f3 cd aa fd			call debug_vector  
47f6				endm  
# End of macro CALLMONITOR
47f6					endif 
47f6 c3 2e 47				jp .tot 
47f9			 
47f9					 
47f9			 
47f9			 
47f9			; for each char convert to low 
47f9					 
47f9			.totdone: 
47f9					if DEBUG_FORTH_WORDS 
47f9						DMARK "TCd" 
47f9 f5				push af  
47fa 3a 0e 48			ld a, (.dmark)  
47fd 32 a6 fd			ld (debug_mark),a  
4800 3a 0f 48			ld a, (.dmark+1)  
4803 32 a7 fd			ld (debug_mark+1),a  
4806 3a 10 48			ld a, (.dmark+2)  
4809 32 a8 fd			ld (debug_mark+2),a  
480c 18 03			jr .pastdmark  
480e ..			.dmark: db "TCd"  
4811 f1			.pastdmark: pop af  
4812			endm  
# End of macro DMARK
4812						CALLMONITOR 
4812 cd aa fd			call debug_vector  
4815				endm  
# End of macro CALLMONITOR
4815					endif 
4815					NEXTW 
4815 c3 d0 23			jp macro_next 
4818				endm 
# End of macro NEXTW
4818			 
4818			.SUBSTR: 
4818				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4818 48				db WORD_SYS_CORE+52             
4819 76 48			dw .LEFT            
481b 07				db 6 + 1 
481c .. 00			db "SUBSTR",0              
4823				endm 
# End of macro CWHEAD
4823			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4823			 
4823					if DEBUG_FORTH_WORDS_KEY 
4823						DMARK "SST" 
4823 f5				push af  
4824 3a 38 48			ld a, (.dmark)  
4827 32 a6 fd			ld (debug_mark),a  
482a 3a 39 48			ld a, (.dmark+1)  
482d 32 a7 fd			ld (debug_mark+1),a  
4830 3a 3a 48			ld a, (.dmark+2)  
4833 32 a8 fd			ld (debug_mark+2),a  
4836 18 03			jr .pastdmark  
4838 ..			.dmark: db "SST"  
483b f1			.pastdmark: pop af  
483c			endm  
# End of macro DMARK
483c						CALLMONITOR 
483c cd aa fd			call debug_vector  
483f				endm  
# End of macro CALLMONITOR
483f					endif 
483f			; TODO check string type 
483f					FORTH_DSP_VALUEHL 
483f cd 1a 22			call macro_dsp_valuehl 
4842				endm 
# End of macro FORTH_DSP_VALUEHL
4842			 
4842 e5					push hl      ; string length 
4843			 
4843					FORTH_DSP_POP 
4843 cd d2 22			call macro_forth_dsp_pop 
4846				endm 
# End of macro FORTH_DSP_POP
4846			 
4846					FORTH_DSP_VALUEHL 
4846 cd 1a 22			call macro_dsp_valuehl 
4849				endm 
# End of macro FORTH_DSP_VALUEHL
4849			 
4849 e5					push hl     ; start char 
484a			 
484a					FORTH_DSP_POP 
484a cd d2 22			call macro_forth_dsp_pop 
484d				endm 
# End of macro FORTH_DSP_POP
484d			 
484d			 
484d					FORTH_DSP_VALUE 
484d cd 03 22			call macro_forth_dsp_value 
4850				endm 
# End of macro FORTH_DSP_VALUE
4850			 
4850 d1					pop de    ; get start post offset 
4851			 
4851 19					add hl, de    ; starting offset 
4852			 
4852 c1					pop bc 
4853 c5					push bc      ; grab size of string 
4854			 
4854 e5					push hl    ; save string start  
4855			 
4855 26 00				ld h, 0 
4857 69					ld l, c 
4858 23					inc hl 
4859 23					inc hl 
485a			 
485a cd aa 13				call malloc 
485d				if DEBUG_FORTH_MALLOC_GUARD 
485d cc a3 5d				call z,malloc_error 
4860				endif 
4860			 
4860 eb					ex de, hl      ; save malloc area for string copy 
4861 e1					pop hl    ; get back source 
4862 c1					pop bc    ; get length of string back 
4863			 
4863 d5					push de    ; save malloc area for after we push 
4864 ed b0				ldir     ; copy substr 
4866			 
4866			 
4866 eb					ex de, hl 
4867 3e 00				ld a, 0 
4869 77					ld (hl), a   ; term substr 
486a			 
486a					 
486a e1					pop hl    ; get malloc so we can push it 
486b e5					push hl   ; save so we can free it afterwards 
486c			 
486c cd 91 20				call forth_push_str 
486f			 
486f e1					pop hl 
4870 cd 74 14				call free 
4873			 
4873					 
4873					 
4873			 
4873			 
4873					NEXTW 
4873 c3 d0 23			jp macro_next 
4876				endm 
# End of macro NEXTW
4876			 
4876			.LEFT: 
4876				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4876 48				db WORD_SYS_CORE+52             
4877 9e 48			dw .RIGHT            
4879 05				db 4 + 1 
487a .. 00			db "LEFT",0              
487f				endm 
# End of macro CWHEAD
487f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
487f					if DEBUG_FORTH_WORDS_KEY 
487f						DMARK "LEF" 
487f f5				push af  
4880 3a 94 48			ld a, (.dmark)  
4883 32 a6 fd			ld (debug_mark),a  
4886 3a 95 48			ld a, (.dmark+1)  
4889 32 a7 fd			ld (debug_mark+1),a  
488c 3a 96 48			ld a, (.dmark+2)  
488f 32 a8 fd			ld (debug_mark+2),a  
4892 18 03			jr .pastdmark  
4894 ..			.dmark: db "LEF"  
4897 f1			.pastdmark: pop af  
4898			endm  
# End of macro DMARK
4898						CALLMONITOR 
4898 cd aa fd			call debug_vector  
489b				endm  
# End of macro CALLMONITOR
489b					endif 
489b			 
489b					NEXTW 
489b c3 d0 23			jp macro_next 
489e				endm 
# End of macro NEXTW
489e			.RIGHT: 
489e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
489e 48				db WORD_SYS_CORE+52             
489f c7 48			dw .STR2NUM            
48a1 06				db 5 + 1 
48a2 .. 00			db "RIGHT",0              
48a8				endm 
# End of macro CWHEAD
48a8			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
48a8					if DEBUG_FORTH_WORDS_KEY 
48a8						DMARK "RIG" 
48a8 f5				push af  
48a9 3a bd 48			ld a, (.dmark)  
48ac 32 a6 fd			ld (debug_mark),a  
48af 3a be 48			ld a, (.dmark+1)  
48b2 32 a7 fd			ld (debug_mark+1),a  
48b5 3a bf 48			ld a, (.dmark+2)  
48b8 32 a8 fd			ld (debug_mark+2),a  
48bb 18 03			jr .pastdmark  
48bd ..			.dmark: db "RIG"  
48c0 f1			.pastdmark: pop af  
48c1			endm  
# End of macro DMARK
48c1						CALLMONITOR 
48c1 cd aa fd			call debug_vector  
48c4				endm  
# End of macro CALLMONITOR
48c4					endif 
48c4			 
48c4					NEXTW 
48c4 c3 d0 23			jp macro_next 
48c7				endm 
# End of macro NEXTW
48c7			 
48c7			 
48c7			.STR2NUM: 
48c7				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48c7 48				db WORD_SYS_CORE+52             
48c8 53 49			dw .NUM2STR            
48ca 08				db 7 + 1 
48cb .. 00			db "STR2NUM",0              
48d3				endm 
# End of macro CWHEAD
48d3			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
48d3			 
48d3			 
48d3			; TODO STR type check to do 
48d3					if DEBUG_FORTH_WORDS_KEY 
48d3						DMARK "S2N" 
48d3 f5				push af  
48d4 3a e8 48			ld a, (.dmark)  
48d7 32 a6 fd			ld (debug_mark),a  
48da 3a e9 48			ld a, (.dmark+1)  
48dd 32 a7 fd			ld (debug_mark+1),a  
48e0 3a ea 48			ld a, (.dmark+2)  
48e3 32 a8 fd			ld (debug_mark+2),a  
48e6 18 03			jr .pastdmark  
48e8 ..			.dmark: db "S2N"  
48eb f1			.pastdmark: pop af  
48ec			endm  
# End of macro DMARK
48ec						CALLMONITOR 
48ec cd aa fd			call debug_vector  
48ef				endm  
# End of macro CALLMONITOR
48ef					endif 
48ef			 
48ef					;FORTH_DSP 
48ef					FORTH_DSP_VALUE 
48ef cd 03 22			call macro_forth_dsp_value 
48f2				endm 
# End of macro FORTH_DSP_VALUE
48f2					;inc hl 
48f2			 
48f2 eb					ex de, hl 
48f3					if DEBUG_FORTH_WORDS 
48f3						DMARK "S2a" 
48f3 f5				push af  
48f4 3a 08 49			ld a, (.dmark)  
48f7 32 a6 fd			ld (debug_mark),a  
48fa 3a 09 49			ld a, (.dmark+1)  
48fd 32 a7 fd			ld (debug_mark+1),a  
4900 3a 0a 49			ld a, (.dmark+2)  
4903 32 a8 fd			ld (debug_mark+2),a  
4906 18 03			jr .pastdmark  
4908 ..			.dmark: db "S2a"  
490b f1			.pastdmark: pop af  
490c			endm  
# End of macro DMARK
490c						CALLMONITOR 
490c cd aa fd			call debug_vector  
490f				endm  
# End of macro CALLMONITOR
490f					endif 
490f cd cc 12				call string_to_uint16 
4912			 
4912					if DEBUG_FORTH_WORDS 
4912						DMARK "S2b" 
4912 f5				push af  
4913 3a 27 49			ld a, (.dmark)  
4916 32 a6 fd			ld (debug_mark),a  
4919 3a 28 49			ld a, (.dmark+1)  
491c 32 a7 fd			ld (debug_mark+1),a  
491f 3a 29 49			ld a, (.dmark+2)  
4922 32 a8 fd			ld (debug_mark+2),a  
4925 18 03			jr .pastdmark  
4927 ..			.dmark: db "S2b"  
492a f1			.pastdmark: pop af  
492b			endm  
# End of macro DMARK
492b						CALLMONITOR 
492b cd aa fd			call debug_vector  
492e				endm  
# End of macro CALLMONITOR
492e					endif 
492e			;		push hl 
492e					FORTH_DSP_POP 
492e cd d2 22			call macro_forth_dsp_pop 
4931				endm 
# End of macro FORTH_DSP_POP
4931			;		pop hl 
4931					 
4931					if DEBUG_FORTH_WORDS 
4931						DMARK "S2b" 
4931 f5				push af  
4932 3a 46 49			ld a, (.dmark)  
4935 32 a6 fd			ld (debug_mark),a  
4938 3a 47 49			ld a, (.dmark+1)  
493b 32 a7 fd			ld (debug_mark+1),a  
493e 3a 48 49			ld a, (.dmark+2)  
4941 32 a8 fd			ld (debug_mark+2),a  
4944 18 03			jr .pastdmark  
4946 ..			.dmark: db "S2b"  
4949 f1			.pastdmark: pop af  
494a			endm  
# End of macro DMARK
494a						CALLMONITOR 
494a cd aa fd			call debug_vector  
494d				endm  
# End of macro CALLMONITOR
494d					endif 
494d cd 23 20				call forth_push_numhl	 
4950			 
4950				 
4950				       NEXTW 
4950 c3 d0 23			jp macro_next 
4953				endm 
# End of macro NEXTW
4953			.NUM2STR: 
4953				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4953 48				db WORD_SYS_CORE+52             
4954 62 49			dw .CONCAT            
4956 08				db 7 + 1 
4957 .. 00			db "NUM2STR",0              
495f				endm 
# End of macro CWHEAD
495f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
495f			 
495f			;		; malloc a string to target 
495f			;		ld hl, 10     ; TODO max string size should be fine 
495f			;		call malloc 
495f			;		push hl    ; save malloc location 
495f			; 
495f			; 
495f			;; TODO check int type 
495f			;		FORTH_DSP_VALUEHL 
495f			;		ld a, l 
495f			;		call DispAToASCII   
495f			;;TODO need to chage above call to dump into string 
495f			; 
495f			; 
495f			 
495f				       NEXTW 
495f c3 d0 23			jp macro_next 
4962				endm 
# End of macro NEXTW
4962			 
4962			.CONCAT: 
4962				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4962 48				db WORD_SYS_CORE+52             
4963 15 4a			dw .FIND            
4965 07				db 6 + 1 
4966 .. 00			db "CONCAT",0              
496d				endm 
# End of macro CWHEAD
496d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
496d			 
496d			; TODO check string type 
496d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
496d			 
496d					if DEBUG_FORTH_WORDS_KEY 
496d						DMARK "CON" 
496d f5				push af  
496e 3a 82 49			ld a, (.dmark)  
4971 32 a6 fd			ld (debug_mark),a  
4974 3a 83 49			ld a, (.dmark+1)  
4977 32 a7 fd			ld (debug_mark+1),a  
497a 3a 84 49			ld a, (.dmark+2)  
497d 32 a8 fd			ld (debug_mark+2),a  
4980 18 03			jr .pastdmark  
4982 ..			.dmark: db "CON"  
4985 f1			.pastdmark: pop af  
4986			endm  
# End of macro DMARK
4986						CALLMONITOR 
4986 cd aa fd			call debug_vector  
4989				endm  
# End of macro CALLMONITOR
4989					endif 
4989			 
4989			 
4989					FORTH_DSP_VALUE 
4989 cd 03 22			call macro_forth_dsp_value 
498c				endm 
# End of macro FORTH_DSP_VALUE
498c e5					push hl   ; s2 
498d			 
498d					FORTH_DSP_POP 
498d cd d2 22			call macro_forth_dsp_pop 
4990				endm 
# End of macro FORTH_DSP_POP
4990			 
4990					FORTH_DSP_VALUE 
4990 cd 03 22			call macro_forth_dsp_value 
4993				endm 
# End of macro FORTH_DSP_VALUE
4993			 
4993 e5					push hl   ; s1 
4994			 
4994					FORTH_DSP_POP 
4994 cd d2 22			call macro_forth_dsp_pop 
4997				endm 
# End of macro FORTH_DSP_POP
4997					 
4997			 
4997					; copy s1 
4997			 
4997				 
4997					; save ptr 
4997 e1					pop hl  
4998 e5					push hl 
4999 3e 00				ld a, 0 
499b cd 40 13				call strlent 
499e					;inc hl    ; zer0 
499e 06 00				ld b, 0 
49a0 4d					ld c, l 
49a1 e1					pop hl		 
49a2 11 fc f0				ld de, scratch	 
49a5					if DEBUG_FORTH_WORDS 
49a5						DMARK "CO1" 
49a5 f5				push af  
49a6 3a ba 49			ld a, (.dmark)  
49a9 32 a6 fd			ld (debug_mark),a  
49ac 3a bb 49			ld a, (.dmark+1)  
49af 32 a7 fd			ld (debug_mark+1),a  
49b2 3a bc 49			ld a, (.dmark+2)  
49b5 32 a8 fd			ld (debug_mark+2),a  
49b8 18 03			jr .pastdmark  
49ba ..			.dmark: db "CO1"  
49bd f1			.pastdmark: pop af  
49be			endm  
# End of macro DMARK
49be						CALLMONITOR 
49be cd aa fd			call debug_vector  
49c1				endm  
# End of macro CALLMONITOR
49c1					endif 
49c1 ed b0				ldir 
49c3			 
49c3 e1					pop hl 
49c4 e5					push hl 
49c5 d5					push de 
49c6			 
49c6			 
49c6 3e 00				ld a, 0 
49c8 cd 40 13				call strlent 
49cb 23					inc hl    ; zer0 
49cc 23					inc hl 
49cd 06 00				ld b, 0 
49cf 4d					ld c, l 
49d0 d1					pop de 
49d1 e1					pop hl		 
49d2					if DEBUG_FORTH_WORDS 
49d2						DMARK "CO2" 
49d2 f5				push af  
49d3 3a e7 49			ld a, (.dmark)  
49d6 32 a6 fd			ld (debug_mark),a  
49d9 3a e8 49			ld a, (.dmark+1)  
49dc 32 a7 fd			ld (debug_mark+1),a  
49df 3a e9 49			ld a, (.dmark+2)  
49e2 32 a8 fd			ld (debug_mark+2),a  
49e5 18 03			jr .pastdmark  
49e7 ..			.dmark: db "CO2"  
49ea f1			.pastdmark: pop af  
49eb			endm  
# End of macro DMARK
49eb						CALLMONITOR 
49eb cd aa fd			call debug_vector  
49ee				endm  
# End of macro CALLMONITOR
49ee					endif 
49ee ed b0				ldir 
49f0			 
49f0			 
49f0			 
49f0 21 fc f0				ld hl, scratch 
49f3					if DEBUG_FORTH_WORDS 
49f3						DMARK "CO5" 
49f3 f5				push af  
49f4 3a 08 4a			ld a, (.dmark)  
49f7 32 a6 fd			ld (debug_mark),a  
49fa 3a 09 4a			ld a, (.dmark+1)  
49fd 32 a7 fd			ld (debug_mark+1),a  
4a00 3a 0a 4a			ld a, (.dmark+2)  
4a03 32 a8 fd			ld (debug_mark+2),a  
4a06 18 03			jr .pastdmark  
4a08 ..			.dmark: db "CO5"  
4a0b f1			.pastdmark: pop af  
4a0c			endm  
# End of macro DMARK
4a0c						CALLMONITOR 
4a0c cd aa fd			call debug_vector  
4a0f				endm  
# End of macro CALLMONITOR
4a0f					endif 
4a0f			 
4a0f cd 91 20				call forth_push_str 
4a12			 
4a12			 
4a12			 
4a12			 
4a12				       NEXTW 
4a12 c3 d0 23			jp macro_next 
4a15				endm 
# End of macro NEXTW
4a15			 
4a15			 
4a15			.FIND: 
4a15				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a15 4b				db WORD_SYS_CORE+55             
4a16 d3 4a			dw .LEN            
4a18 05				db 4 + 1 
4a19 .. 00			db "FIND",0              
4a1e				endm 
# End of macro CWHEAD
4a1e			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a1e			 
4a1e					if DEBUG_FORTH_WORDS_KEY 
4a1e						DMARK "FND" 
4a1e f5				push af  
4a1f 3a 33 4a			ld a, (.dmark)  
4a22 32 a6 fd			ld (debug_mark),a  
4a25 3a 34 4a			ld a, (.dmark+1)  
4a28 32 a7 fd			ld (debug_mark+1),a  
4a2b 3a 35 4a			ld a, (.dmark+2)  
4a2e 32 a8 fd			ld (debug_mark+2),a  
4a31 18 03			jr .pastdmark  
4a33 ..			.dmark: db "FND"  
4a36 f1			.pastdmark: pop af  
4a37			endm  
# End of macro DMARK
4a37						CALLMONITOR 
4a37 cd aa fd			call debug_vector  
4a3a				endm  
# End of macro CALLMONITOR
4a3a					endif 
4a3a			 
4a3a			; TODO check string type 
4a3a					FORTH_DSP_VALUE 
4a3a cd 03 22			call macro_forth_dsp_value 
4a3d				endm 
# End of macro FORTH_DSP_VALUE
4a3d			 
4a3d e5					push hl    
4a3e 7e					ld a,(hl)    ; char to find   
4a3f			; TODO change char to substr 
4a3f			 
4a3f f5					push af 
4a40					 
4a40			 
4a40			 
4a40					if DEBUG_FORTH_WORDS 
4a40						DMARK "FN1" 
4a40 f5				push af  
4a41 3a 55 4a			ld a, (.dmark)  
4a44 32 a6 fd			ld (debug_mark),a  
4a47 3a 56 4a			ld a, (.dmark+1)  
4a4a 32 a7 fd			ld (debug_mark+1),a  
4a4d 3a 57 4a			ld a, (.dmark+2)  
4a50 32 a8 fd			ld (debug_mark+2),a  
4a53 18 03			jr .pastdmark  
4a55 ..			.dmark: db "FN1"  
4a58 f1			.pastdmark: pop af  
4a59			endm  
# End of macro DMARK
4a59						CALLMONITOR 
4a59 cd aa fd			call debug_vector  
4a5c				endm  
# End of macro CALLMONITOR
4a5c					endif 
4a5c			 
4a5c					FORTH_DSP_POP 
4a5c cd d2 22			call macro_forth_dsp_pop 
4a5f				endm 
# End of macro FORTH_DSP_POP
4a5f			 
4a5f					; string to search 
4a5f			 
4a5f					FORTH_DSP_VALUE 
4a5f cd 03 22			call macro_forth_dsp_value 
4a62				endm 
# End of macro FORTH_DSP_VALUE
4a62			 
4a62 d1					pop de  ; d is char to find  
4a63			 
4a63					if DEBUG_FORTH_WORDS 
4a63						DMARK "FN2" 
4a63 f5				push af  
4a64 3a 78 4a			ld a, (.dmark)  
4a67 32 a6 fd			ld (debug_mark),a  
4a6a 3a 79 4a			ld a, (.dmark+1)  
4a6d 32 a7 fd			ld (debug_mark+1),a  
4a70 3a 7a 4a			ld a, (.dmark+2)  
4a73 32 a8 fd			ld (debug_mark+2),a  
4a76 18 03			jr .pastdmark  
4a78 ..			.dmark: db "FN2"  
4a7b f1			.pastdmark: pop af  
4a7c			endm  
# End of macro DMARK
4a7c						CALLMONITOR 
4a7c cd aa fd			call debug_vector  
4a7f				endm  
# End of macro CALLMONITOR
4a7f					endif 
4a7f					 
4a7f 01 00 00				ld bc, 0 
4a82 7e			.findchar:      ld a,(hl) 
4a83 fe 00				cp 0   		 
4a85 28 27				jr z, .finddone     
4a87 ba					cp d 
4a88 28 20				jr z, .foundchar 
4a8a 03					inc bc 
4a8b 23					inc hl 
4a8c					if DEBUG_FORTH_WORDS 
4a8c						DMARK "FN3" 
4a8c f5				push af  
4a8d 3a a1 4a			ld a, (.dmark)  
4a90 32 a6 fd			ld (debug_mark),a  
4a93 3a a2 4a			ld a, (.dmark+1)  
4a96 32 a7 fd			ld (debug_mark+1),a  
4a99 3a a3 4a			ld a, (.dmark+2)  
4a9c 32 a8 fd			ld (debug_mark+2),a  
4a9f 18 03			jr .pastdmark  
4aa1 ..			.dmark: db "FN3"  
4aa4 f1			.pastdmark: pop af  
4aa5			endm  
# End of macro DMARK
4aa5						CALLMONITOR 
4aa5 cd aa fd			call debug_vector  
4aa8				endm  
# End of macro CALLMONITOR
4aa8					endif 
4aa8 18 d8				jr .findchar 
4aaa			 
4aaa			 
4aaa c5			.foundchar:	push bc 
4aab e1					pop hl 
4aac 18 03				jr .findexit 
4aae			 
4aae			 
4aae							 
4aae			 
4aae			.finddone:     ; got to end of string with no find 
4aae 21 00 00				ld hl, 0 
4ab1			.findexit: 
4ab1			 
4ab1					if DEBUG_FORTH_WORDS 
4ab1						DMARK "FNd" 
4ab1 f5				push af  
4ab2 3a c6 4a			ld a, (.dmark)  
4ab5 32 a6 fd			ld (debug_mark),a  
4ab8 3a c7 4a			ld a, (.dmark+1)  
4abb 32 a7 fd			ld (debug_mark+1),a  
4abe 3a c8 4a			ld a, (.dmark+2)  
4ac1 32 a8 fd			ld (debug_mark+2),a  
4ac4 18 03			jr .pastdmark  
4ac6 ..			.dmark: db "FNd"  
4ac9 f1			.pastdmark: pop af  
4aca			endm  
# End of macro DMARK
4aca						CALLMONITOR 
4aca cd aa fd			call debug_vector  
4acd				endm  
# End of macro CALLMONITOR
4acd					endif 
4acd cd 23 20			call forth_push_numhl 
4ad0			 
4ad0				       NEXTW 
4ad0 c3 d0 23			jp macro_next 
4ad3				endm 
# End of macro NEXTW
4ad3			 
4ad3			.LEN: 
4ad3				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ad3 4c				db WORD_SYS_CORE+56             
4ad4 3d 4b			dw .ASC            
4ad6 06				db 5 + 1 
4ad7 .. 00			db "COUNT",0              
4add				endm 
# End of macro CWHEAD
4add			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4add			 
4add					if DEBUG_FORTH_WORDS_KEY 
4add						DMARK "CNT" 
4add f5				push af  
4ade 3a f2 4a			ld a, (.dmark)  
4ae1 32 a6 fd			ld (debug_mark),a  
4ae4 3a f3 4a			ld a, (.dmark+1)  
4ae7 32 a7 fd			ld (debug_mark+1),a  
4aea 3a f4 4a			ld a, (.dmark+2)  
4aed 32 a8 fd			ld (debug_mark+2),a  
4af0 18 03			jr .pastdmark  
4af2 ..			.dmark: db "CNT"  
4af5 f1			.pastdmark: pop af  
4af6			endm  
# End of macro DMARK
4af6						CALLMONITOR 
4af6 cd aa fd			call debug_vector  
4af9				endm  
# End of macro CALLMONITOR
4af9					endif 
4af9			; TODO check string type 
4af9					FORTH_DSP_VALUE 
4af9 cd 03 22			call macro_forth_dsp_value 
4afc				endm 
# End of macro FORTH_DSP_VALUE
4afc			 
4afc			 
4afc					if DEBUG_FORTH_WORDS 
4afc						DMARK "CN?" 
4afc f5				push af  
4afd 3a 11 4b			ld a, (.dmark)  
4b00 32 a6 fd			ld (debug_mark),a  
4b03 3a 12 4b			ld a, (.dmark+1)  
4b06 32 a7 fd			ld (debug_mark+1),a  
4b09 3a 13 4b			ld a, (.dmark+2)  
4b0c 32 a8 fd			ld (debug_mark+2),a  
4b0f 18 03			jr .pastdmark  
4b11 ..			.dmark: db "CN?"  
4b14 f1			.pastdmark: pop af  
4b15			endm  
# End of macro DMARK
4b15						CALLMONITOR 
4b15 cd aa fd			call debug_vector  
4b18				endm  
# End of macro CALLMONITOR
4b18					endif 
4b18 cd 35 13				call strlenz 
4b1b					if DEBUG_FORTH_WORDS 
4b1b						DMARK "CNl" 
4b1b f5				push af  
4b1c 3a 30 4b			ld a, (.dmark)  
4b1f 32 a6 fd			ld (debug_mark),a  
4b22 3a 31 4b			ld a, (.dmark+1)  
4b25 32 a7 fd			ld (debug_mark+1),a  
4b28 3a 32 4b			ld a, (.dmark+2)  
4b2b 32 a8 fd			ld (debug_mark+2),a  
4b2e 18 03			jr .pastdmark  
4b30 ..			.dmark: db "CNl"  
4b33 f1			.pastdmark: pop af  
4b34			endm  
# End of macro DMARK
4b34						CALLMONITOR 
4b34 cd aa fd			call debug_vector  
4b37				endm  
# End of macro CALLMONITOR
4b37					endif 
4b37			 
4b37 cd 23 20				call forth_push_numhl 
4b3a			 
4b3a			 
4b3a			 
4b3a				       NEXTW 
4b3a c3 d0 23			jp macro_next 
4b3d				endm 
# End of macro NEXTW
4b3d			.ASC: 
4b3d				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b3d 4d				db WORD_SYS_CORE+57             
4b3e ab 4b			dw .CHR            
4b40 04				db 3 + 1 
4b41 .. 00			db "ASC",0              
4b45				endm 
# End of macro CWHEAD
4b45			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4b45					if DEBUG_FORTH_WORDS_KEY 
4b45						DMARK "ASC" 
4b45 f5				push af  
4b46 3a 5a 4b			ld a, (.dmark)  
4b49 32 a6 fd			ld (debug_mark),a  
4b4c 3a 5b 4b			ld a, (.dmark+1)  
4b4f 32 a7 fd			ld (debug_mark+1),a  
4b52 3a 5c 4b			ld a, (.dmark+2)  
4b55 32 a8 fd			ld (debug_mark+2),a  
4b58 18 03			jr .pastdmark  
4b5a ..			.dmark: db "ASC"  
4b5d f1			.pastdmark: pop af  
4b5e			endm  
# End of macro DMARK
4b5e						CALLMONITOR 
4b5e cd aa fd			call debug_vector  
4b61				endm  
# End of macro CALLMONITOR
4b61					endif 
4b61					FORTH_DSP_VALUE 
4b61 cd 03 22			call macro_forth_dsp_value 
4b64				endm 
# End of macro FORTH_DSP_VALUE
4b64					;v5 FORTH_DSP_VALUE 
4b64			;		inc hl      ; now at start of numeric as string 
4b64			 
4b64 e5					push hl 
4b65			 
4b65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b65 cd d2 22			call macro_forth_dsp_pop 
4b68				endm 
# End of macro FORTH_DSP_POP
4b68			 
4b68 e1					pop hl 
4b69			 
4b69					if DEBUG_FORTH_WORDS 
4b69						DMARK "AS1" 
4b69 f5				push af  
4b6a 3a 7e 4b			ld a, (.dmark)  
4b6d 32 a6 fd			ld (debug_mark),a  
4b70 3a 7f 4b			ld a, (.dmark+1)  
4b73 32 a7 fd			ld (debug_mark+1),a  
4b76 3a 80 4b			ld a, (.dmark+2)  
4b79 32 a8 fd			ld (debug_mark+2),a  
4b7c 18 03			jr .pastdmark  
4b7e ..			.dmark: db "AS1"  
4b81 f1			.pastdmark: pop af  
4b82			endm  
# End of macro DMARK
4b82						CALLMONITOR 
4b82 cd aa fd			call debug_vector  
4b85				endm  
# End of macro CALLMONITOR
4b85					endif 
4b85					; push the content of a onto the stack as a value 
4b85			 
4b85 7e					ld a,(hl)   ; get char 
4b86 26 00				ld h,0 
4b88 6f					ld l,a 
4b89					if DEBUG_FORTH_WORDS 
4b89						DMARK "AS2" 
4b89 f5				push af  
4b8a 3a 9e 4b			ld a, (.dmark)  
4b8d 32 a6 fd			ld (debug_mark),a  
4b90 3a 9f 4b			ld a, (.dmark+1)  
4b93 32 a7 fd			ld (debug_mark+1),a  
4b96 3a a0 4b			ld a, (.dmark+2)  
4b99 32 a8 fd			ld (debug_mark+2),a  
4b9c 18 03			jr .pastdmark  
4b9e ..			.dmark: db "AS2"  
4ba1 f1			.pastdmark: pop af  
4ba2			endm  
# End of macro DMARK
4ba2						CALLMONITOR 
4ba2 cd aa fd			call debug_vector  
4ba5				endm  
# End of macro CALLMONITOR
4ba5					endif 
4ba5 cd 23 20				call forth_push_numhl 
4ba8			 
4ba8				       NEXTW 
4ba8 c3 d0 23			jp macro_next 
4bab				endm 
# End of macro NEXTW
4bab			 
4bab			.CHR: 
4bab				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4bab 4d				db WORD_SYS_CORE+57             
4bac e7 4b			dw .ENDSTR            
4bae 04				db 3 + 1 
4baf .. 00			db "CHR",0              
4bb3				endm 
# End of macro CWHEAD
4bb3			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4bb3					if DEBUG_FORTH_WORDS_KEY 
4bb3						DMARK "CHR" 
4bb3 f5				push af  
4bb4 3a c8 4b			ld a, (.dmark)  
4bb7 32 a6 fd			ld (debug_mark),a  
4bba 3a c9 4b			ld a, (.dmark+1)  
4bbd 32 a7 fd			ld (debug_mark+1),a  
4bc0 3a ca 4b			ld a, (.dmark+2)  
4bc3 32 a8 fd			ld (debug_mark+2),a  
4bc6 18 03			jr .pastdmark  
4bc8 ..			.dmark: db "CHR"  
4bcb f1			.pastdmark: pop af  
4bcc			endm  
# End of macro DMARK
4bcc						CALLMONITOR 
4bcc cd aa fd			call debug_vector  
4bcf				endm  
# End of macro CALLMONITOR
4bcf					endif 
4bcf					FORTH_DSP_VALUEHL 
4bcf cd 1a 22			call macro_dsp_valuehl 
4bd2				endm 
# End of macro FORTH_DSP_VALUEHL
4bd2			 
4bd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd2 cd d2 22			call macro_forth_dsp_pop 
4bd5				endm 
# End of macro FORTH_DSP_POP
4bd5			 
4bd5					; save asci byte as a zero term string and push string 
4bd5			 
4bd5 7d					ld a,l 
4bd6 32 fc f0				ld (scratch), a 
4bd9			 
4bd9 3e 00				ld a, 0 
4bdb 32 fd f0				ld (scratch+1), a 
4bde			 
4bde 21 fc f0				ld hl, scratch 
4be1 cd 91 20				call forth_push_str 
4be4			 
4be4			 
4be4				       NEXTW 
4be4 c3 d0 23			jp macro_next 
4be7				endm 
# End of macro NEXTW
4be7			 
4be7			 
4be7			 
4be7			 
4be7			.ENDSTR: 
4be7			; eof 
4be7			 
# End of file forth_words_str.asm
4be7			include "forth_words_key.asm" 
4be7			 
4be7			; | ## Keyboard Words 
4be7			 
4be7			.KEY: 
4be7				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4be7 3e				db WORD_SYS_CORE+42             
4be8 17 4c			dw .WAITK            
4bea 04				db 3 + 1 
4beb .. 00			db "KEY",0              
4bef				endm 
# End of macro CWHEAD
4bef			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4bef			 
4bef					if DEBUG_FORTH_WORDS_KEY 
4bef						DMARK "KEY" 
4bef f5				push af  
4bf0 3a 04 4c			ld a, (.dmark)  
4bf3 32 a6 fd			ld (debug_mark),a  
4bf6 3a 05 4c			ld a, (.dmark+1)  
4bf9 32 a7 fd			ld (debug_mark+1),a  
4bfc 3a 06 4c			ld a, (.dmark+2)  
4bff 32 a8 fd			ld (debug_mark+2),a  
4c02 18 03			jr .pastdmark  
4c04 ..			.dmark: db "KEY"  
4c07 f1			.pastdmark: pop af  
4c08			endm  
# End of macro DMARK
4c08						CALLMONITOR 
4c08 cd aa fd			call debug_vector  
4c0b				endm  
# End of macro CALLMONITOR
4c0b					endif 
4c0b			; TODO currently waits 
4c0b cd a1 72				call cin 
4c0e					;call cin_wait 
4c0e 6f					ld l, a 
4c0f 26 00				ld h, 0 
4c11 cd 23 20				call forth_push_numhl 
4c14					NEXTW 
4c14 c3 d0 23			jp macro_next 
4c17				endm 
# End of macro NEXTW
4c17			.WAITK: 
4c17				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c17 3f				db WORD_SYS_CORE+43             
4c18 49 4c			dw .ACCEPT            
4c1a 06				db 5 + 1 
4c1b .. 00			db "WAITK",0              
4c21				endm 
# End of macro CWHEAD
4c21			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c21					if DEBUG_FORTH_WORDS_KEY 
4c21						DMARK "WAI" 
4c21 f5				push af  
4c22 3a 36 4c			ld a, (.dmark)  
4c25 32 a6 fd			ld (debug_mark),a  
4c28 3a 37 4c			ld a, (.dmark+1)  
4c2b 32 a7 fd			ld (debug_mark+1),a  
4c2e 3a 38 4c			ld a, (.dmark+2)  
4c31 32 a8 fd			ld (debug_mark+2),a  
4c34 18 03			jr .pastdmark  
4c36 ..			.dmark: db "WAI"  
4c39 f1			.pastdmark: pop af  
4c3a			endm  
# End of macro DMARK
4c3a						CALLMONITOR 
4c3a cd aa fd			call debug_vector  
4c3d				endm  
# End of macro CALLMONITOR
4c3d					endif 
4c3d cd 90 72				call cin_wait 
4c40 6f					ld l, a 
4c41 26 00				ld h, 0 
4c43 cd 23 20				call forth_push_numhl 
4c46					NEXTW 
4c46 c3 d0 23			jp macro_next 
4c49				endm 
# End of macro NEXTW
4c49			.ACCEPT: 
4c49				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c49 40				db WORD_SYS_CORE+44             
4c4a a7 4c			dw .EDIT            
4c4c 07				db 6 + 1 
4c4d .. 00			db "ACCEPT",0              
4c54				endm 
# End of macro CWHEAD
4c54			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c54					; TODO crashes on push 
4c54					if DEBUG_FORTH_WORDS_KEY 
4c54						DMARK "ACC" 
4c54 f5				push af  
4c55 3a 69 4c			ld a, (.dmark)  
4c58 32 a6 fd			ld (debug_mark),a  
4c5b 3a 6a 4c			ld a, (.dmark+1)  
4c5e 32 a7 fd			ld (debug_mark+1),a  
4c61 3a 6b 4c			ld a, (.dmark+2)  
4c64 32 a8 fd			ld (debug_mark+2),a  
4c67 18 03			jr .pastdmark  
4c69 ..			.dmark: db "ACC"  
4c6c f1			.pastdmark: pop af  
4c6d			endm  
# End of macro DMARK
4c6d						CALLMONITOR 
4c6d cd aa fd			call debug_vector  
4c70				endm  
# End of macro CALLMONITOR
4c70					endif 
4c70 21 fa f2				ld hl, os_input 
4c73 3e 00				ld a, 0 
4c75 77					ld (hl),a 
4c76 3a 99 f9				ld a,(f_cursor_ptr) 
4c79 16 64				ld d, 100 
4c7b 0e 00				ld c, 0 
4c7d 1e 28				ld e, 40 
4c7f cd fc 0f				call input_str 
4c82					; TODO perhaps do a type check and wrap in quotes if not a number 
4c82 21 fa f2				ld hl, os_input 
4c85					if DEBUG_FORTH_WORDS 
4c85						DMARK "AC1" 
4c85 f5				push af  
4c86 3a 9a 4c			ld a, (.dmark)  
4c89 32 a6 fd			ld (debug_mark),a  
4c8c 3a 9b 4c			ld a, (.dmark+1)  
4c8f 32 a7 fd			ld (debug_mark+1),a  
4c92 3a 9c 4c			ld a, (.dmark+2)  
4c95 32 a8 fd			ld (debug_mark+2),a  
4c98 18 03			jr .pastdmark  
4c9a ..			.dmark: db "AC1"  
4c9d f1			.pastdmark: pop af  
4c9e			endm  
# End of macro DMARK
4c9e						CALLMONITOR 
4c9e cd aa fd			call debug_vector  
4ca1				endm  
# End of macro CALLMONITOR
4ca1					endif 
4ca1 cd 91 20				call forth_push_str 
4ca4					NEXTW 
4ca4 c3 d0 23			jp macro_next 
4ca7				endm 
# End of macro NEXTW
4ca7			 
4ca7			.EDIT: 
4ca7				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4ca7 40				db WORD_SYS_CORE+44             
4ca8 49 4d			dw .DEDIT            
4caa 05				db 4 + 1 
4cab .. 00			db "EDIT",0              
4cb0				endm 
# End of macro CWHEAD
4cb0			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4cb0			 
4cb0					; TODO does not copy from stack 
4cb0					if DEBUG_FORTH_WORDS_KEY 
4cb0						DMARK "EDT" 
4cb0 f5				push af  
4cb1 3a c5 4c			ld a, (.dmark)  
4cb4 32 a6 fd			ld (debug_mark),a  
4cb7 3a c6 4c			ld a, (.dmark+1)  
4cba 32 a7 fd			ld (debug_mark+1),a  
4cbd 3a c7 4c			ld a, (.dmark+2)  
4cc0 32 a8 fd			ld (debug_mark+2),a  
4cc3 18 03			jr .pastdmark  
4cc5 ..			.dmark: db "EDT"  
4cc8 f1			.pastdmark: pop af  
4cc9			endm  
# End of macro DMARK
4cc9						CALLMONITOR 
4cc9 cd aa fd			call debug_vector  
4ccc				endm  
# End of macro CALLMONITOR
4ccc					endif 
4ccc			 
4ccc					;FORTH_DSP 
4ccc					FORTH_DSP_VALUEHL 
4ccc cd 1a 22			call macro_dsp_valuehl 
4ccf				endm 
# End of macro FORTH_DSP_VALUEHL
4ccf			;		inc hl    ; TODO do type check 
4ccf			 
4ccf			;		call get_word_hl 
4ccf e5					push hl 
4cd0					if DEBUG_FORTH_WORDS 
4cd0						DMARK "EDp" 
4cd0 f5				push af  
4cd1 3a e5 4c			ld a, (.dmark)  
4cd4 32 a6 fd			ld (debug_mark),a  
4cd7 3a e6 4c			ld a, (.dmark+1)  
4cda 32 a7 fd			ld (debug_mark+1),a  
4cdd 3a e7 4c			ld a, (.dmark+2)  
4ce0 32 a8 fd			ld (debug_mark+2),a  
4ce3 18 03			jr .pastdmark  
4ce5 ..			.dmark: db "EDp"  
4ce8 f1			.pastdmark: pop af  
4ce9			endm  
# End of macro DMARK
4ce9						CALLMONITOR 
4ce9 cd aa fd			call debug_vector  
4cec				endm  
# End of macro CALLMONITOR
4cec					endif 
4cec				;	ld a, 0 
4cec cd 35 13				call strlenz 
4cef 23					inc hl 
4cf0			 
4cf0 06 00				ld b, 0 
4cf2 4d					ld c, l 
4cf3			 
4cf3 e1					pop hl 
4cf4 11 fa f2				ld de, os_input 
4cf7					if DEBUG_FORTH_WORDS_KEY 
4cf7						DMARK "EDc" 
4cf7 f5				push af  
4cf8 3a 0c 4d			ld a, (.dmark)  
4cfb 32 a6 fd			ld (debug_mark),a  
4cfe 3a 0d 4d			ld a, (.dmark+1)  
4d01 32 a7 fd			ld (debug_mark+1),a  
4d04 3a 0e 4d			ld a, (.dmark+2)  
4d07 32 a8 fd			ld (debug_mark+2),a  
4d0a 18 03			jr .pastdmark  
4d0c ..			.dmark: db "EDc"  
4d0f f1			.pastdmark: pop af  
4d10			endm  
# End of macro DMARK
4d10						CALLMONITOR 
4d10 cd aa fd			call debug_vector  
4d13				endm  
# End of macro CALLMONITOR
4d13					endif 
4d13 ed b0				ldir 
4d15			 
4d15			 
4d15 21 fa f2				ld hl, os_input 
4d18					;ld a, 0 
4d18					;ld (hl),a 
4d18 3a 99 f9				ld a,(f_cursor_ptr) 
4d1b 16 64				ld d, 100 
4d1d 0e 00				ld c, 0 
4d1f 1e 28				ld e, 40 
4d21 cd fc 0f				call input_str 
4d24					; TODO perhaps do a type check and wrap in quotes if not a number 
4d24 21 fa f2				ld hl, os_input 
4d27					if DEBUG_FORTH_WORDS 
4d27						DMARK "ED1" 
4d27 f5				push af  
4d28 3a 3c 4d			ld a, (.dmark)  
4d2b 32 a6 fd			ld (debug_mark),a  
4d2e 3a 3d 4d			ld a, (.dmark+1)  
4d31 32 a7 fd			ld (debug_mark+1),a  
4d34 3a 3e 4d			ld a, (.dmark+2)  
4d37 32 a8 fd			ld (debug_mark+2),a  
4d3a 18 03			jr .pastdmark  
4d3c ..			.dmark: db "ED1"  
4d3f f1			.pastdmark: pop af  
4d40			endm  
# End of macro DMARK
4d40						CALLMONITOR 
4d40 cd aa fd			call debug_vector  
4d43				endm  
# End of macro CALLMONITOR
4d43					endif 
4d43 cd 91 20				call forth_push_str 
4d46					NEXTW 
4d46 c3 d0 23			jp macro_next 
4d49				endm 
# End of macro NEXTW
4d49			 
4d49			.DEDIT: 
4d49				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d49 40				db WORD_SYS_CORE+44             
4d4a ab 4d			dw .ENDKEY            
4d4c 06				db 5 + 1 
4d4d .. 00			db "DEDIT",0              
4d53				endm 
# End of macro CWHEAD
4d53			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d53			 
4d53					; TODO does not copy from stack 
4d53					if DEBUG_FORTH_WORDS_KEY 
4d53						DMARK "DED" 
4d53 f5				push af  
4d54 3a 68 4d			ld a, (.dmark)  
4d57 32 a6 fd			ld (debug_mark),a  
4d5a 3a 69 4d			ld a, (.dmark+1)  
4d5d 32 a7 fd			ld (debug_mark+1),a  
4d60 3a 6a 4d			ld a, (.dmark+2)  
4d63 32 a8 fd			ld (debug_mark+2),a  
4d66 18 03			jr .pastdmark  
4d68 ..			.dmark: db "DED"  
4d6b f1			.pastdmark: pop af  
4d6c			endm  
# End of macro DMARK
4d6c						CALLMONITOR 
4d6c cd aa fd			call debug_vector  
4d6f				endm  
# End of macro CALLMONITOR
4d6f					endif 
4d6f			 
4d6f					;FORTH_DSP 
4d6f					FORTH_DSP_VALUEHL 
4d6f cd 1a 22			call macro_dsp_valuehl 
4d72				endm 
# End of macro FORTH_DSP_VALUEHL
4d72			;		inc hl    ; TODO do type check 
4d72			 
4d72			;		call get_word_hl 
4d72 e5					push hl 
4d73 e5					push hl 
4d74					FORTH_DSP_POP 
4d74 cd d2 22			call macro_forth_dsp_pop 
4d77				endm 
# End of macro FORTH_DSP_POP
4d77 e1					pop hl 
4d78					if DEBUG_FORTH_WORDS 
4d78						DMARK "EDp" 
4d78 f5				push af  
4d79 3a 8d 4d			ld a, (.dmark)  
4d7c 32 a6 fd			ld (debug_mark),a  
4d7f 3a 8e 4d			ld a, (.dmark+1)  
4d82 32 a7 fd			ld (debug_mark+1),a  
4d85 3a 8f 4d			ld a, (.dmark+2)  
4d88 32 a8 fd			ld (debug_mark+2),a  
4d8b 18 03			jr .pastdmark  
4d8d ..			.dmark: db "EDp"  
4d90 f1			.pastdmark: pop af  
4d91			endm  
# End of macro DMARK
4d91						CALLMONITOR 
4d91 cd aa fd			call debug_vector  
4d94				endm  
# End of macro CALLMONITOR
4d94					endif 
4d94				;	ld a, 0 
4d94 cd 35 13				call strlenz 
4d97 23					inc hl 
4d98			 
4d98 06 00				ld b, 0 
4d9a 4d					ld c, l 
4d9b			 
4d9b e1					pop hl 
4d9c			 
4d9c					;ld a, 0 
4d9c					;ld (hl),a 
4d9c 3a 99 f9				ld a,(f_cursor_ptr) 
4d9f 16 64				ld d, 100 
4da1 0e 00				ld c, 0 
4da3 1e 28				ld e, 40 
4da5 cd fc 0f				call input_str 
4da8					; TODO perhaps do a type check and wrap in quotes if not a number 
4da8					NEXTW 
4da8 c3 d0 23			jp macro_next 
4dab				endm 
# End of macro NEXTW
4dab			 
4dab			 
4dab			.ENDKEY: 
4dab			; eof 
4dab			 
# End of file forth_words_key.asm
4dab			include "forth_words_const.asm" 
4dab			 
4dab			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4dab			 
4dab			 
4dab			.SPITIME: 
4dab				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4dab 77				db WORD_SYS_CORE+99             
4dac c0 4d			dw .VA            
4dae 08				db 7 + 1 
4daf .. 00			db "SPITIME",0              
4db7				endm 
# End of macro CWHEAD
4db7			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4db7			; 
4db7			; | | If using BANK devices then leave as is. 
4db7			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4db7			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4db7			 
4db7 21 9f f9				ld hl, spi_clktime  
4dba cd 23 20				call forth_push_numhl 
4dbd			 
4dbd					NEXTW 
4dbd c3 d0 23			jp macro_next 
4dc0				endm 
# End of macro NEXTW
4dc0			 
4dc0			 
4dc0			.VA: 
4dc0				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4dc0 77				db WORD_SYS_CORE+99             
4dc1 d0 4d			dw .SYMBOL            
4dc3 03				db 2 + 1 
4dc4 .. 00			db "VA",0              
4dc7				endm 
# End of macro CWHEAD
4dc7			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4dc7 21 63 f9				ld hl, cli_var_array 
4dca cd 23 20				call forth_push_numhl 
4dcd			 
4dcd					NEXTW 
4dcd c3 d0 23			jp macro_next 
4dd0				endm 
# End of macro NEXTW
4dd0			 
4dd0			.SYMBOL: 
4dd0				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4dd0 77				db WORD_SYS_CORE+99             
4dd1 da 4e			dw .ENDCONST            
4dd3 07				db 6 + 1 
4dd4 .. 00			db "SYMBOL",0              
4ddb				endm 
# End of macro CWHEAD
4ddb			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4ddb			; | 
4ddb			; | | The value is the number reference and the final address is pushed to stack 
4ddb			 
4ddb			; | | ``` 
4ddb			; | | dw sym_table 
4ddb			; | | dw nmi_vector 
4ddb			; | | dw cli_autodisplay 
4ddb			; | | dw cli_data_sp 
4ddb			; | | dw cli_data_stack 
4ddb			; | | dw cli_loop_sp 
4ddb			; | | dw cli_loop_stack 
4ddb			; | | dw cli_var_array 
4ddb			; | | dw cursor_col 
4ddb			; | | dw cursor_ptr 
4ddb			; | | ; 10 
4ddb			; | | dw cursor_row 
4ddb			; | | dw debug_mark 
4ddb			; | | dw display_fb0 
4ddb			; | | dw display_fb1 
4ddb			; | | dw display_fb2 
4ddb			; | | dw display_fb3 
4ddb			; | | dw display_fb_active 
4ddb			; | | dw execscratch 
4ddb			; | | dw f_cursor_ptr 
4ddb			; | | dw hardware_word 
4ddb			; | | ;20 
4ddb			; | | dw input_at_cursor 
4ddb			; | | dw input_at_pos 
4ddb			; | | dw input_cur_flash 
4ddb			; | | dw input_cur_onoff 
4ddb			; | | dw input_cursor 
4ddb			; | | dw input_display_size 
4ddb			; | | dw input_len 
4ddb			; | | dw input_ptr 
4ddb			; | | dw input_size 
4ddb			; | | dw input_start 
4ddb			; | | ; 30 
4ddb			; | | dw input_str 
4ddb			; | | dw input_under_cursor 
4ddb			; | | dw os_cli_cmd 
4ddb			; | | dw os_cur_ptr 
4ddb			; | | dw os_current_i 
4ddb			; | | dw os_input 
4ddb			; | | dw os_last_cmd 
4ddb			; | | dw os_last_new_uword 
4ddb			; | | dw debug_vector 
4ddb			; | | dw os_view_hl 
4ddb			; | | ;40 
4ddb			; | | dw os_word_scratch 
4ddb			; | | dw portbctl 
4ddb			; | | dw portbdata 
4ddb			; | | dw spi_cartdev 
4ddb			; | | dw spi_cartdev2 
4ddb			; | | dw spi_clktime 
4ddb			; | | dw spi_device 
4ddb			; | | dw spi_device_id 
4ddb			; | | dw spi_portbyte 
4ddb			; | | dw stackstore 
4ddb			; | | ; 50 
4ddb			; | | if STORAGE_SE 
4ddb			; | | dw storage_actl 
4ddb			; | | dw storage_adata 
4ddb			; | | else 
4ddb			; | | dw 0 
4ddb			; | | dw 0 
4ddb			; | | endif 
4ddb			; | | dw storage_append 
4ddb			; | | if STORAGE_SE 
4ddb			; | | dw storage_bctl 
4ddb			; | | else 
4ddb			; | | dw 0 
4ddb			; | | endif 
4ddb			; | | dw store_bank_active 
4ddb			; | | dw store_filecache 
4ddb			; | | dw store_longread 
4ddb			; | | dw store_openaddr 
4ddb			; | | dw store_openext 
4ddb			; | | dw store_openmaxext 
4ddb			; | | ; 60 
4ddb			; | | dw store_page 
4ddb			; | | dw store_readbuf 
4ddb			; | | dw store_readcont 
4ddb			; | | dw store_readptr 
4ddb			; | | dw store_tmpext 
4ddb			; | | dw store_tmpid 
4ddb			; | | dw store_tmppageid 
4ddb			; | | dw malloc 
4ddb			; | | dw free 
4ddb			; | | dw cin 
4ddb			; | | ; 70 
4ddb			; | | dw cin_wait 
4ddb			; | | dw forth_push_numhl 
4ddb			; | | dw forth_push_str 
4ddb			; | | ``` 
4ddb			 
4ddb					if DEBUG_FORTH_WORDS_KEY 
4ddb						DMARK "SYM" 
4ddb f5				push af  
4ddc 3a f0 4d			ld a, (.dmark)  
4ddf 32 a6 fd			ld (debug_mark),a  
4de2 3a f1 4d			ld a, (.dmark+1)  
4de5 32 a7 fd			ld (debug_mark+1),a  
4de8 3a f2 4d			ld a, (.dmark+2)  
4deb 32 a8 fd			ld (debug_mark+2),a  
4dee 18 03			jr .pastdmark  
4df0 ..			.dmark: db "SYM"  
4df3 f1			.pastdmark: pop af  
4df4			endm  
# End of macro DMARK
4df4						CALLMONITOR 
4df4 cd aa fd			call debug_vector  
4df7				endm  
# End of macro CALLMONITOR
4df7					endif 
4df7			 
4df7					FORTH_DSP_VALUEHL 
4df7 cd 1a 22			call macro_dsp_valuehl 
4dfa				endm 
# End of macro FORTH_DSP_VALUEHL
4dfa			 
4dfa 7d					ld a, l     
4dfb			 
4dfb			 
4dfb					if DEBUG_FORTH_WORDS 
4dfb						DMARK "SY1" 
4dfb f5				push af  
4dfc 3a 10 4e			ld a, (.dmark)  
4dff 32 a6 fd			ld (debug_mark),a  
4e02 3a 11 4e			ld a, (.dmark+1)  
4e05 32 a7 fd			ld (debug_mark+1),a  
4e08 3a 12 4e			ld a, (.dmark+2)  
4e0b 32 a8 fd			ld (debug_mark+2),a  
4e0e 18 03			jr .pastdmark  
4e10 ..			.dmark: db "SY1"  
4e13 f1			.pastdmark: pop af  
4e14			endm  
# End of macro DMARK
4e14						CALLMONITOR 
4e14 cd aa fd			call debug_vector  
4e17				endm  
# End of macro CALLMONITOR
4e17					endif 
4e17					 
4e17 f5					push af	 
4e18					FORTH_DSP_POP 
4e18 cd d2 22			call macro_forth_dsp_pop 
4e1b				endm 
# End of macro FORTH_DSP_POP
4e1b f1					pop af 
4e1c			 
4e1c cb 27				sla a  
4e1e				 
4e1e					 
4e1e					if DEBUG_FORTH_WORDS 
4e1e						DMARK "SY" 
4e1e f5				push af  
4e1f 3a 33 4e			ld a, (.dmark)  
4e22 32 a6 fd			ld (debug_mark),a  
4e25 3a 34 4e			ld a, (.dmark+1)  
4e28 32 a7 fd			ld (debug_mark+1),a  
4e2b 3a 35 4e			ld a, (.dmark+2)  
4e2e 32 a8 fd			ld (debug_mark+2),a  
4e31 18 02			jr .pastdmark  
4e33 ..			.dmark: db "SY"  
4e35 f1			.pastdmark: pop af  
4e36			endm  
# End of macro DMARK
4e36						CALLMONITOR 
4e36 cd aa fd			call debug_vector  
4e39				endm  
# End of macro CALLMONITOR
4e39					endif 
4e39			 
4e39 21 48 4e				ld hl, sym_table 
4e3c cd cf 0f				call addatohl 
4e3f cd 52 23				call loadwordinhl 
4e42 cd 23 20				call forth_push_numhl 
4e45			 
4e45			 
4e45				       NEXTW 
4e45 c3 d0 23			jp macro_next 
4e48				endm 
# End of macro NEXTW
4e48			 
4e48			sym_table: 
4e48			 
4e48			; 0 
4e48 48 4e		dw sym_table 
4e4a ad fd		dw nmi_vector 
4e4c 77 f9		dw cli_autodisplay 
4e4e 29 f9		dw cli_data_sp 
4e50 63 f6		dw cli_data_stack 
4e52 2b f9		dw cli_loop_sp 
4e54 65 f8		dw cli_loop_stack 
4e56 63 f9		dw cli_var_array 
4e58 00 fb		dw cursor_col 
4e5a fe fa		dw cursor_ptr 
4e5c			; 10 
4e5c ff fa		dw cursor_row 
4e5e a6 fd		dw debug_mark 
4e60 ec fc		dw display_fb0 
4e62 4b fc		dw display_fb1 
4e64 09 fb		dw display_fb2 
4e66 aa fb		dw display_fb3 
4e68 07 fb		dw display_fb_active 
4e6a fb f1		dw execscratch 
4e6c 99 f9		dw f_cursor_ptr 
4e6e b0 fd		dw hardware_word 
4e70			;20 
4e70 9d fd		dw input_at_cursor 
4e72 9f fd		dw input_at_pos 
4e74 9b fd		dw input_cur_flash 
4e76 9a fd		dw input_cur_onoff 
4e78 90 fd		dw input_cursor 
4e7a a0 fd		dw input_display_size 
4e7c 95 fd		dw input_len 
4e7e a4 fd		dw input_ptr 
4e80 a1 fd		dw input_size 
4e82 a2 fd		dw input_start 
4e84			; 30 
4e84 fc 0f		dw input_str 
4e86 9e fd		dw input_under_cursor 
4e88 23 f4		dw os_cli_cmd 
4e8a 1f f4		dw os_cur_ptr 
4e8c 21 f4		dw os_current_i 
4e8e fa f2		dw os_input 
4e90 22 f5		dw os_last_cmd 
4e92 f9 f3		dw os_last_new_uword 
4e94 aa fd		dw debug_vector 
4e96 de f0		dw os_view_hl 
4e98			;40 
4e98 01 f4		dw os_word_scratch 
4e9a c3 00		dw portbctl 
4e9c c1 00		dw portbdata 
4e9e 9e f9		dw spi_cartdev 
4ea0 9d f9		dw spi_cartdev2 
4ea2 9f f9		dw spi_clktime 
4ea4 9b f9		dw spi_device 
4ea6 9a f9		dw spi_device_id 
4ea8 9c f9		dw spi_portbyte 
4eaa e2 fa		dw stackstore 
4eac			; 50 
4eac			if STORAGE_SE 
4eac 82 00		dw storage_actl 
4eae 80 00		dw storage_adata 
4eb0			else 
4eb0			dw 0 
4eb0			dw 0 
4eb0			endif 
4eb0 55 0b		dw storage_append 
4eb2			if STORAGE_SE 
4eb2 83 00		dw storage_bctl 
4eb4			else 
4eb4			dw 0 
4eb4			endif 
4eb4 ce fa		dw store_bank_active 
4eb6 a2 f9		dw store_filecache 
4eb8 b0 f9		dw store_longread 
4eba a6 f9		dw store_openaddr 
4ebc a5 f9		dw store_openext 
4ebe a4 f9		dw store_openmaxext 
4ec0			; 60 
4ec0 b5 f9		dw store_page 
4ec2 b1 f9		dw store_readbuf 
4ec4 a8 f9		dw store_readcont 
4ec6 b3 f9		dw store_readptr 
4ec8 a8 f9		dw store_tmpext 
4eca a9 f9		dw store_tmpid 
4ecc a0 f9		dw store_tmppageid 
4ece aa 13		dw malloc 
4ed0 74 14		dw free 
4ed2 a1 72		dw cin 
4ed4			; 70 
4ed4 90 72		dw cin_wait 
4ed6 23 20		dw forth_push_numhl 
4ed8 91 20		dw forth_push_str 
4eda			 
4eda			 
4eda			.ENDCONST: 
4eda			 
4eda			; eof 
4eda			 
4eda			 
# End of file forth_words_const.asm
4eda			 
4eda			if STORAGE_SE 
4eda			   	include "forth_words_storage.asm" 
4eda			 
4eda			; | ## Fixed Storage Words 
4eda			 
4eda			.RENAME: 
4eda			  
4eda				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4eda 3a				db WORD_SYS_CORE+38             
4edb d0 4f			dw .RECORD            
4edd 07				db 6 + 1 
4ede .. 00			db "RENAME",0              
4ee5				endm 
# End of macro CWHEAD
4ee5			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4ee5			; | | > [!NOTE] 
4ee5			; | | > Compatible with PicoSPINet  
4ee5					if DEBUG_FORTH_WORDS_KEY 
4ee5						DMARK "REN" 
4ee5 f5				push af  
4ee6 3a fa 4e			ld a, (.dmark)  
4ee9 32 a6 fd			ld (debug_mark),a  
4eec 3a fb 4e			ld a, (.dmark+1)  
4eef 32 a7 fd			ld (debug_mark+1),a  
4ef2 3a fc 4e			ld a, (.dmark+2)  
4ef5 32 a8 fd			ld (debug_mark+2),a  
4ef8 18 03			jr .pastdmark  
4efa ..			.dmark: db "REN"  
4efd f1			.pastdmark: pop af  
4efe			endm  
# End of macro DMARK
4efe						CALLMONITOR 
4efe cd aa fd			call debug_vector  
4f01				endm  
# End of macro CALLMONITOR
4f01					endif 
4f01			 
4f01			 
4f01					; preserve some internal vars used by other file handing routines 
4f01			 
4f01 2a a6 f9				ld hl, (store_openaddr) 
4f04 e5					push hl 
4f05 3a a8 f9				ld a, (store_readcont) 
4f08 f5					push af 
4f09			 
4f09					FORTH_DSP_VALUEHL 
4f09 cd 1a 22			call macro_dsp_valuehl 
4f0c				endm 
# End of macro FORTH_DSP_VALUEHL
4f0c			 
4f0c					; move ext and id around for the file header 
4f0c			 
4f0c 65					ld h, l 
4f0d 2e 00				ld l, 0 
4f0f			 
4f0f e5					push hl    ; id 
4f10			 
4f10					FORTH_DSP_POP 
4f10 cd d2 22			call macro_forth_dsp_pop 
4f13				endm 
# End of macro FORTH_DSP_POP
4f13			 
4f13					; Locate the file header 
4f13			 
4f13 e1					pop hl 
4f14 e5					push hl 
4f15 11 b5 f9				ld de, store_page      ; get block zero of file 
4f18					if DEBUG_FORTH_WORDS 
4f18						DMARK "REr" 
4f18 f5				push af  
4f19 3a 2d 4f			ld a, (.dmark)  
4f1c 32 a6 fd			ld (debug_mark),a  
4f1f 3a 2e 4f			ld a, (.dmark+1)  
4f22 32 a7 fd			ld (debug_mark+1),a  
4f25 3a 2f 4f			ld a, (.dmark+2)  
4f28 32 a8 fd			ld (debug_mark+2),a  
4f2b 18 03			jr .pastdmark  
4f2d ..			.dmark: db "REr"  
4f30 f1			.pastdmark: pop af  
4f31			endm  
# End of macro DMARK
4f31						CALLMONITOR 
4f31 cd aa fd			call debug_vector  
4f34				endm  
# End of macro CALLMONITOR
4f34					endif 
4f34 cd be 09				call storage_read 
4f37			 
4f37 cd f8 0f			call ishlzero 
4f3a 20 05			jr nz, .rnfound 
4f3c			 
4f3c				; file does not exist so indicate with 255 extents in use 
4f3c			 
4f3c 3e ff			ld a, 255 
4f3e e1				pop hl ; clear dup hl 
4f3f 18 7b			jr .skiprneof 
4f41			 
4f41			 
4f41			.rnfound: 
4f41					; file found so rename 
4f41			 
4f41					FORTH_DSP_VALUEHL 
4f41 cd 1a 22			call macro_dsp_valuehl 
4f44				endm 
# End of macro FORTH_DSP_VALUEHL
4f44			 
4f44 e5				push hl 
4f45 3e 00			ld a, 0 
4f47 cd 40 13			call strlent 
4f4a 23				inc hl   ; cover zero term 
4f4b 06 00			ld b,0 
4f4d 4d				ld c,l 
4f4e e1				pop hl 
4f4f 11 b8 f9				ld de, store_page + 3 
4f52 ed b0				ldir 
4f54			 
4f54 11 b5 f9				ld de, store_page 
4f57					if DEBUG_FORTH_WORDS 
4f57						DMARK "RER" 
4f57 f5				push af  
4f58 3a 6c 4f			ld a, (.dmark)  
4f5b 32 a6 fd			ld (debug_mark),a  
4f5e 3a 6d 4f			ld a, (.dmark+1)  
4f61 32 a7 fd			ld (debug_mark+1),a  
4f64 3a 6e 4f			ld a, (.dmark+2)  
4f67 32 a8 fd			ld (debug_mark+2),a  
4f6a 18 03			jr .pastdmark  
4f6c ..			.dmark: db "RER"  
4f6f f1			.pastdmark: pop af  
4f70			endm  
# End of macro DMARK
4f70						CALLMONITOR 
4f70 cd aa fd			call debug_vector  
4f73				endm  
# End of macro CALLMONITOR
4f73					endif 
4f73			 
4f73 e1					pop hl    ; get orig file id and mangle it for find id 
4f74 55					ld d, l 
4f75 5c					ld e, h 
4f76			 
4f76 21 00 00				ld hl, 0 
4f79					if DEBUG_FORTH_WORDS 
4f79						DMARK "REf" 
4f79 f5				push af  
4f7a 3a 8e 4f			ld a, (.dmark)  
4f7d 32 a6 fd			ld (debug_mark),a  
4f80 3a 8f 4f			ld a, (.dmark+1)  
4f83 32 a7 fd			ld (debug_mark+1),a  
4f86 3a 90 4f			ld a, (.dmark+2)  
4f89 32 a8 fd			ld (debug_mark+2),a  
4f8c 18 03			jr .pastdmark  
4f8e ..			.dmark: db "REf"  
4f91 f1			.pastdmark: pop af  
4f92			endm  
# End of macro DMARK
4f92						CALLMONITOR 
4f92 cd aa fd			call debug_vector  
4f95				endm  
# End of macro CALLMONITOR
4f95					endif 
4f95 cd 98 07				call storage_findnextid 
4f98 11 b5 f9				ld de, store_page 
4f9b					if DEBUG_FORTH_WORDS 
4f9b						DMARK "REw" 
4f9b f5				push af  
4f9c 3a b0 4f			ld a, (.dmark)  
4f9f 32 a6 fd			ld (debug_mark),a  
4fa2 3a b1 4f			ld a, (.dmark+1)  
4fa5 32 a7 fd			ld (debug_mark+1),a  
4fa8 3a b2 4f			ld a, (.dmark+2)  
4fab 32 a8 fd			ld (debug_mark+2),a  
4fae 18 03			jr .pastdmark  
4fb0 ..			.dmark: db "REw"  
4fb3 f1			.pastdmark: pop af  
4fb4			endm  
# End of macro DMARK
4fb4						CALLMONITOR 
4fb4 cd aa fd			call debug_vector  
4fb7				endm  
# End of macro CALLMONITOR
4fb7					endif 
4fb7 cd ca 04				call storage_write_block 
4fba			 
4fba 3e 00				ld a, 0 
4fbc			.skiprneof: 
4fbc					; drop file name 
4fbc					FORTH_DSP_POP 
4fbc cd d2 22			call macro_forth_dsp_pop 
4fbf				endm 
# End of macro FORTH_DSP_POP
4fbf			 
4fbf 6f					ld l, a 
4fc0 26 00				ld h, 0 
4fc2 cd 23 20				call forth_push_numhl 
4fc5			 
4fc5			 
4fc5 f1					pop af 
4fc6 32 a8 f9				ld (store_readcont),a 
4fc9 e1					pop hl 
4fca 22 a6 f9				ld (store_openaddr), hl 
4fcd						 
4fcd				NEXTW 
4fcd c3 d0 23			jp macro_next 
4fd0				endm 
# End of macro NEXTW
4fd0			.RECORD: 
4fd0			  
4fd0				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4fd0 3a				db WORD_SYS_CORE+38             
4fd1 74 50			dw .BREAD            
4fd3 07				db 6 + 1 
4fd4 .. 00			db "RECORD",0              
4fdb				endm 
# End of macro CWHEAD
4fdb			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4fdb			; | | > [!NOTE] 
4fdb			; | | > Compatible with PicoSPINet  
4fdb			 
4fdb					if DEBUG_FORTH_WORDS_KEY 
4fdb						DMARK "REC" 
4fdb f5				push af  
4fdc 3a f0 4f			ld a, (.dmark)  
4fdf 32 a6 fd			ld (debug_mark),a  
4fe2 3a f1 4f			ld a, (.dmark+1)  
4fe5 32 a7 fd			ld (debug_mark+1),a  
4fe8 3a f2 4f			ld a, (.dmark+2)  
4feb 32 a8 fd			ld (debug_mark+2),a  
4fee 18 03			jr .pastdmark  
4ff0 ..			.dmark: db "REC"  
4ff3 f1			.pastdmark: pop af  
4ff4			endm  
# End of macro DMARK
4ff4						CALLMONITOR 
4ff4 cd aa fd			call debug_vector  
4ff7				endm  
# End of macro CALLMONITOR
4ff7					endif 
4ff7			 
4ff7					FORTH_DSP_VALUEHL 
4ff7 cd 1a 22			call macro_dsp_valuehl 
4ffa				endm 
# End of macro FORTH_DSP_VALUEHL
4ffa			 
4ffa e5					push hl    ; id 
4ffb			 
4ffb					FORTH_DSP_POP 
4ffb cd d2 22			call macro_forth_dsp_pop 
4ffe				endm 
# End of macro FORTH_DSP_POP
4ffe			 
4ffe					FORTH_DSP_VALUEHL 
4ffe cd 1a 22			call macro_dsp_valuehl 
5001				endm 
# End of macro FORTH_DSP_VALUEHL
5001			 
5001					FORTH_DSP_POP 
5001 cd d2 22			call macro_forth_dsp_pop 
5004				endm 
# End of macro FORTH_DSP_POP
5004			 
5004 d1					pop de     ; get file id 
5005			 
5005					; e = file id 
5005					; l = file extent 
5005			 
5005			 
5005					; construct request to access file extent 
5005			 
5005			;		ld a, e 
5005 63					ld h, e 
5006					 
5006					 
5006					 
5006			 
5006					; e has id 
5006			 
5006 11 b5 f9			ld de, store_page 
5009					if DEBUG_FORTH_WORDS 
5009						DMARK "REr" 
5009 f5				push af  
500a 3a 1e 50			ld a, (.dmark)  
500d 32 a6 fd			ld (debug_mark),a  
5010 3a 1f 50			ld a, (.dmark+1)  
5013 32 a7 fd			ld (debug_mark+1),a  
5016 3a 20 50			ld a, (.dmark+2)  
5019 32 a8 fd			ld (debug_mark+2),a  
501c 18 03			jr .pastdmark  
501e ..			.dmark: db "REr"  
5021 f1			.pastdmark: pop af  
5022			endm  
# End of macro DMARK
5022						CALLMONITOR 
5022 cd aa fd			call debug_vector  
5025				endm  
# End of macro CALLMONITOR
5025					endif 
5025 cd be 09				call storage_read 
5028 cd f8 0f			call ishlzero 
502b 28 22			jr z, .recnotfound 
502d			 
502d			 
502d					if DEBUG_FORTH_WORDS 
502d						DMARK "REe" 
502d f5				push af  
502e 3a 42 50			ld a, (.dmark)  
5031 32 a6 fd			ld (debug_mark),a  
5034 3a 43 50			ld a, (.dmark+1)  
5037 32 a7 fd			ld (debug_mark+1),a  
503a 3a 44 50			ld a, (.dmark+2)  
503d 32 a8 fd			ld (debug_mark+2),a  
5040 18 03			jr .pastdmark  
5042 ..			.dmark: db "REe"  
5045 f1			.pastdmark: pop af  
5046			endm  
# End of macro DMARK
5046						CALLMONITOR 
5046 cd aa fd			call debug_vector  
5049				endm  
# End of macro CALLMONITOR
5049					endif 
5049 cd 91 20			call forth_push_str 
504c			 
504c					NEXTW 
504c c3 d0 23			jp macro_next 
504f				endm 
# End of macro NEXTW
504f			 
504f			.recnotfound: 
504f					if DEBUG_FORTH_WORDS 
504f						DMARK "REf" 
504f f5				push af  
5050 3a 64 50			ld a, (.dmark)  
5053 32 a6 fd			ld (debug_mark),a  
5056 3a 65 50			ld a, (.dmark+1)  
5059 32 a7 fd			ld (debug_mark+1),a  
505c 3a 66 50			ld a, (.dmark+2)  
505f 32 a8 fd			ld (debug_mark+2),a  
5062 18 03			jr .pastdmark  
5064 ..			.dmark: db "REf"  
5067 f1			.pastdmark: pop af  
5068			endm  
# End of macro DMARK
5068						CALLMONITOR 
5068 cd aa fd			call debug_vector  
506b				endm  
# End of macro CALLMONITOR
506b					endif 
506b 21 ff 00			ld hl, 255 
506e cd 23 20			call forth_push_numhl 
5071				NEXTW 
5071 c3 d0 23			jp macro_next 
5074				endm 
# End of macro NEXTW
5074			 
5074			 
5074			.BREAD: 
5074			  
5074				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5074 3a				db WORD_SYS_CORE+38             
5075 f7 50			dw .BWRITE            
5077 06				db 5 + 1 
5078 .. 00			db "BREAD",0              
507e				endm 
# End of macro CWHEAD
507e			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
507e			; | | > [!NOTE] 
507e			; | | > Compatible with PicoSPINet  
507e				 
507e					if DEBUG_FORTH_WORDS_KEY 
507e						DMARK "BRD" 
507e f5				push af  
507f 3a 93 50			ld a, (.dmark)  
5082 32 a6 fd			ld (debug_mark),a  
5085 3a 94 50			ld a, (.dmark+1)  
5088 32 a7 fd			ld (debug_mark+1),a  
508b 3a 95 50			ld a, (.dmark+2)  
508e 32 a8 fd			ld (debug_mark+2),a  
5091 18 03			jr .pastdmark  
5093 ..			.dmark: db "BRD"  
5096 f1			.pastdmark: pop af  
5097			endm  
# End of macro DMARK
5097						CALLMONITOR 
5097 cd aa fd			call debug_vector  
509a				endm  
# End of macro CALLMONITOR
509a					endif 
509a			 
509a				FORTH_DSP_VALUEHL 
509a cd 1a 22			call macro_dsp_valuehl 
509d				endm 
# End of macro FORTH_DSP_VALUEHL
509d			 
509d				FORTH_DSP_POP 
509d cd d2 22			call macro_forth_dsp_pop 
50a0				endm 
# End of macro FORTH_DSP_POP
50a0			 
50a0				; calc block address 
50a0			 
50a0 eb				ex de, hl 
50a1 3e 40			ld a, STORE_BLOCK_PHY 
50a3 cd 52 0f			call Mult16 
50a6			 
50a6			 
50a6 11 b5 f9			ld de, store_page 
50a9			 
50a9					if DEBUG_FORTH_WORDS 
50a9						DMARK "BR1" 
50a9 f5				push af  
50aa 3a be 50			ld a, (.dmark)  
50ad 32 a6 fd			ld (debug_mark),a  
50b0 3a bf 50			ld a, (.dmark+1)  
50b3 32 a7 fd			ld (debug_mark+1),a  
50b6 3a c0 50			ld a, (.dmark+2)  
50b9 32 a8 fd			ld (debug_mark+2),a  
50bc 18 03			jr .pastdmark  
50be ..			.dmark: db "BR1"  
50c1 f1			.pastdmark: pop af  
50c2			endm  
# End of macro DMARK
50c2						CALLMONITOR 
50c2 cd aa fd			call debug_vector  
50c5				endm  
# End of macro CALLMONITOR
50c5					endif 
50c5			 
50c5 cd 65 04			call storage_read_block 
50c8			 
50c8 cd f8 0f			call ishlzero 
50cb 20 05			jr nz, .brfound 
50cd			 
50cd cd 23 20			call forth_push_numhl 
50d0 18 22			jr .brdone 
50d2			 
50d2			 
50d2			.brfound: 
50d2 21 b7 f9		        ld hl, store_page+2 
50d5			 
50d5					if DEBUG_FORTH_WORDS 
50d5						DMARK "BR2" 
50d5 f5				push af  
50d6 3a ea 50			ld a, (.dmark)  
50d9 32 a6 fd			ld (debug_mark),a  
50dc 3a eb 50			ld a, (.dmark+1)  
50df 32 a7 fd			ld (debug_mark+1),a  
50e2 3a ec 50			ld a, (.dmark+2)  
50e5 32 a8 fd			ld (debug_mark+2),a  
50e8 18 03			jr .pastdmark  
50ea ..			.dmark: db "BR2"  
50ed f1			.pastdmark: pop af  
50ee			endm  
# End of macro DMARK
50ee						CALLMONITOR 
50ee cd aa fd			call debug_vector  
50f1				endm  
# End of macro CALLMONITOR
50f1					endif 
50f1			 
50f1 cd 91 20			call forth_push_str 
50f4			 
50f4			 
50f4			.brdone: 
50f4			 
50f4					NEXTW 
50f4 c3 d0 23			jp macro_next 
50f7				endm 
# End of macro NEXTW
50f7			.BWRITE: 
50f7				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
50f7 3a				db WORD_SYS_CORE+38             
50f8 8c 51			dw .BUPD            
50fa 07				db 6 + 1 
50fb .. 00			db "BWRITE",0              
5102				endm 
# End of macro CWHEAD
5102			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5102			; | | > [!NOTE] 
5102			; | | > Compatible with PicoSPINet  
5102			 
5102					if DEBUG_FORTH_WORDS_KEY 
5102						DMARK "BWR" 
5102 f5				push af  
5103 3a 17 51			ld a, (.dmark)  
5106 32 a6 fd			ld (debug_mark),a  
5109 3a 18 51			ld a, (.dmark+1)  
510c 32 a7 fd			ld (debug_mark+1),a  
510f 3a 19 51			ld a, (.dmark+2)  
5112 32 a8 fd			ld (debug_mark+2),a  
5115 18 03			jr .pastdmark  
5117 ..			.dmark: db "BWR"  
511a f1			.pastdmark: pop af  
511b			endm  
# End of macro DMARK
511b						CALLMONITOR 
511b cd aa fd			call debug_vector  
511e				endm  
# End of macro CALLMONITOR
511e					endif 
511e			 
511e				FORTH_DSP_VALUEHL 
511e cd 1a 22			call macro_dsp_valuehl 
5121				endm 
# End of macro FORTH_DSP_VALUEHL
5121			 
5121				; calc block address 
5121			 
5121 eb				ex de, hl 
5122 3e 40			ld a, STORE_BLOCK_PHY 
5124 cd 52 0f			call Mult16 
5127			 
5127 e5				push hl         ; address 
5128			 
5128				FORTH_DSP_POP 
5128 cd d2 22			call macro_forth_dsp_pop 
512b				endm 
# End of macro FORTH_DSP_POP
512b			 
512b				FORTH_DSP_VALUEHL 
512b cd 1a 22			call macro_dsp_valuehl 
512e				endm 
# End of macro FORTH_DSP_VALUEHL
512e			 
512e				FORTH_DSP_POP 
512e cd d2 22			call macro_forth_dsp_pop 
5131				endm 
# End of macro FORTH_DSP_POP
5131			 
5131 cd a1 0c			call storage_clear_page 
5134			 
5134				; copy string to store page 
5134			 
5134 e5				push hl     ; save string address 
5135			 
5135 3e 00			ld a, 0 
5137 cd 40 13			call strlent 
513a			 
513a 23				inc hl 
513b			 
513b 4d				ld c, l 
513c 06 00			ld b, 0 
513e			 
513e e1				pop hl 
513f 11 b7 f9			ld de, store_page + 2 
5142					if DEBUG_FORTH_WORDS 
5142						DMARK "BW1" 
5142 f5				push af  
5143 3a 57 51			ld a, (.dmark)  
5146 32 a6 fd			ld (debug_mark),a  
5149 3a 58 51			ld a, (.dmark+1)  
514c 32 a7 fd			ld (debug_mark+1),a  
514f 3a 59 51			ld a, (.dmark+2)  
5152 32 a8 fd			ld (debug_mark+2),a  
5155 18 03			jr .pastdmark  
5157 ..			.dmark: db "BW1"  
515a f1			.pastdmark: pop af  
515b			endm  
# End of macro DMARK
515b						CALLMONITOR 
515b cd aa fd			call debug_vector  
515e				endm  
# End of macro CALLMONITOR
515e					endif 
515e ed b0			ldir 
5160			 
5160			 
5160				; poke the start of the block with flags to prevent high level file ops hitting the block 
5160			 
5160 21 ff ff			ld hl, $ffff 
5163			 
5163 22 b5 f9			ld (store_page), hl	 
5166				 
5166 e1				pop hl    ; get address 
5167 11 b5 f9			ld de, store_page 
516a			 
516a					if DEBUG_FORTH_WORDS 
516a						DMARK "BW2" 
516a f5				push af  
516b 3a 7f 51			ld a, (.dmark)  
516e 32 a6 fd			ld (debug_mark),a  
5171 3a 80 51			ld a, (.dmark+1)  
5174 32 a7 fd			ld (debug_mark+1),a  
5177 3a 81 51			ld a, (.dmark+2)  
517a 32 a8 fd			ld (debug_mark+2),a  
517d 18 03			jr .pastdmark  
517f ..			.dmark: db "BW2"  
5182 f1			.pastdmark: pop af  
5183			endm  
# End of macro DMARK
5183						CALLMONITOR 
5183 cd aa fd			call debug_vector  
5186				endm  
# End of macro CALLMONITOR
5186					endif 
5186			 
5186 cd ca 04			call storage_write_block 
5189			 
5189					NEXTW 
5189 c3 d0 23			jp macro_next 
518c				endm 
# End of macro NEXTW
518c			 
518c			.BUPD: 
518c				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
518c 3a				db WORD_SYS_CORE+38             
518d e2 51			dw .BYID            
518f 05				db 4 + 1 
5190 .. 00			db "BUPD",0              
5195				endm 
# End of macro CWHEAD
5195			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5195			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5195			; | | or completely different file system structure. 
5195			; | | > [!NOTE] 
5195			; | | > Compatible with PicoSPINet  
5195			 
5195					if DEBUG_FORTH_WORDS_KEY 
5195						DMARK "BUD" 
5195 f5				push af  
5196 3a aa 51			ld a, (.dmark)  
5199 32 a6 fd			ld (debug_mark),a  
519c 3a ab 51			ld a, (.dmark+1)  
519f 32 a7 fd			ld (debug_mark+1),a  
51a2 3a ac 51			ld a, (.dmark+2)  
51a5 32 a8 fd			ld (debug_mark+2),a  
51a8 18 03			jr .pastdmark  
51aa ..			.dmark: db "BUD"  
51ad f1			.pastdmark: pop af  
51ae			endm  
# End of macro DMARK
51ae						CALLMONITOR 
51ae cd aa fd			call debug_vector  
51b1				endm  
# End of macro CALLMONITOR
51b1					endif 
51b1			 
51b1				FORTH_DSP_VALUEHL 
51b1 cd 1a 22			call macro_dsp_valuehl 
51b4				endm 
# End of macro FORTH_DSP_VALUEHL
51b4			 
51b4				; calc block address 
51b4			 
51b4 eb				ex de, hl 
51b5 3e 40			ld a, STORE_BLOCK_PHY 
51b7 cd 52 0f			call Mult16 
51ba			 
51ba				FORTH_DSP_POP 
51ba cd d2 22			call macro_forth_dsp_pop 
51bd				endm 
# End of macro FORTH_DSP_POP
51bd			 
51bd			 
51bd 11 b5 f9			ld de, store_page 
51c0			 
51c0					if DEBUG_FORTH_WORDS 
51c0						DMARK "BUe" 
51c0 f5				push af  
51c1 3a d5 51			ld a, (.dmark)  
51c4 32 a6 fd			ld (debug_mark),a  
51c7 3a d6 51			ld a, (.dmark+1)  
51ca 32 a7 fd			ld (debug_mark+1),a  
51cd 3a d7 51			ld a, (.dmark+2)  
51d0 32 a8 fd			ld (debug_mark+2),a  
51d3 18 03			jr .pastdmark  
51d5 ..			.dmark: db "BUe"  
51d8 f1			.pastdmark: pop af  
51d9			endm  
# End of macro DMARK
51d9						CALLMONITOR 
51d9 cd aa fd			call debug_vector  
51dc				endm  
# End of macro CALLMONITOR
51dc					endif 
51dc			 
51dc cd ca 04			call storage_write_block 
51df			 
51df					NEXTW 
51df c3 d0 23			jp macro_next 
51e2				endm 
# End of macro NEXTW
51e2			 
51e2			.BYID: 
51e2			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51e2			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51e2			; 
51e2			;		 
51e2			;		if DEBUG_FORTH_WORDS_KEY 
51e2			;			DMARK "BYID" 
51e2			;			CALLMONITOR 
51e2			;		endif 
51e2			; 
51e2			;		; get direct address 
51e2			; 
51e2			;		FORTH_DSP_VALUEHL 
51e2			; 
51e2			;		FORTH_DSP_POP 
51e2			; 
51e2			;	; calc block address 
51e2			; 
51e2			;	ex de, hl 
51e2			;	ld a, STORE_BLOCK_PHY 
51e2			;	call Mult16 
51e2			;	;	do BREAD with number as param 
51e2			;	; push the file name	 
51e2			;	ld de, store_page 
51e2			;	call storage_read_block 
51e2			 ;       ld hl, store_page+2 
51e2			; 
51e2			; 
51e2			;		NEXTW 
51e2			;.BYNAME: 
51e2				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51e2 3a				db WORD_SYS_CORE+38             
51e3 fb 51			dw .DIR            
51e5 06				db 5 + 1 
51e6 .. 00			db "GETID",0              
51ec				endm 
# End of macro CWHEAD
51ec			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
51ec			; | | > [!NOTE] 
51ec			; | | > Compatible with PicoSPINet  
51ec			 
51ec					; get pointer to file name to seek 
51ec			 
51ec					FORTH_DSP_VALUEHL 
51ec cd 1a 22			call macro_dsp_valuehl 
51ef				endm 
# End of macro FORTH_DSP_VALUEHL
51ef			 
51ef			 
51ef cd 8c 03				call storage_getid  
51f2			 
51f2					FORTH_DSP_POP 
51f2 cd d2 22			call macro_forth_dsp_pop 
51f5				endm 
# End of macro FORTH_DSP_POP
51f5			 
51f5 cd 23 20				call forth_push_numhl 
51f8			 
51f8					NEXTW 
51f8 c3 d0 23			jp macro_next 
51fb				endm 
# End of macro NEXTW
51fb			; 
51fb			.DIR: 
51fb				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
51fb 3a				db WORD_SYS_CORE+38             
51fc ff 52			dw .SAVE            
51fe 04				db 3 + 1 
51ff .. 00			db "DIR",0              
5203				endm 
# End of macro CWHEAD
5203			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5203			; | | > [!NOTE] 
5203			; | | > Compatible with PicoSPINet  
5203			 
5203					if DEBUG_FORTH_WORDS_KEY 
5203						DMARK "DIR" 
5203 f5				push af  
5204 3a 18 52			ld a, (.dmark)  
5207 32 a6 fd			ld (debug_mark),a  
520a 3a 19 52			ld a, (.dmark+1)  
520d 32 a7 fd			ld (debug_mark+1),a  
5210 3a 1a 52			ld a, (.dmark+2)  
5213 32 a8 fd			ld (debug_mark+2),a  
5216 18 03			jr .pastdmark  
5218 ..			.dmark: db "DIR"  
521b f1			.pastdmark: pop af  
521c			endm  
# End of macro DMARK
521c						CALLMONITOR 
521c cd aa fd			call debug_vector  
521f				endm  
# End of macro CALLMONITOR
521f					endif 
521f cd 16 05			call storage_get_block_0 
5222			 
5222 21 b5 f9			ld hl, store_page     ; get current id count 
5225 46				ld b, (hl) 
5226 0e 00			ld c, 0    ; count of files   
5228					if DEBUG_FORTH_WORDS 
5228						DMARK "DI1" 
5228 f5				push af  
5229 3a 3d 52			ld a, (.dmark)  
522c 32 a6 fd			ld (debug_mark),a  
522f 3a 3e 52			ld a, (.dmark+1)  
5232 32 a7 fd			ld (debug_mark+1),a  
5235 3a 3f 52			ld a, (.dmark+2)  
5238 32 a8 fd			ld (debug_mark+2),a  
523b 18 03			jr .pastdmark  
523d ..			.dmark: db "DI1"  
5240 f1			.pastdmark: pop af  
5241			endm  
# End of macro DMARK
5241						CALLMONITOR 
5241 cd aa fd			call debug_vector  
5244				endm  
# End of macro CALLMONITOR
5244					endif 
5244			 
5244				; check for empty drive 
5244			 
5244 3e 00			ld a, 0 
5246 b8				cp b 
5247 ca b5 52			jp z, .dirdone 
524a			 
524a				; for each of the current ids do a search for them and if found push to stack 
524a			 
524a c5			.diritem:	push bc 
524b 21 40 00				ld hl, STORE_BLOCK_PHY 
524e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5250 58					ld e,b 
5251			 
5251			;		if DEBUG_FORTH_WORDS 
5251			;			DMARK "DI2" 
5251			;			CALLMONITOR 
5251			;		endif 
5251			 
5251 cd 98 07				call storage_findnextid 
5254			 
5254			;		if DEBUG_FORTH_WORDS 
5254			;			DMARK "DI3" 
5254			;			CALLMONITOR 
5254			;		endif 
5254			 
5254					; if found hl will be non zero 
5254			 
5254 cd f8 0f				call ishlzero 
5257			;		ld a, l 
5257			;		add h 
5257			; 
5257			;		cp 0 
5257 28 59				jr z, .dirnotfound 
5259			 
5259					; increase count 
5259			 
5259 c1					pop bc	 
525a 0c					inc c 
525b c5					push bc 
525c					 
525c			 
525c					; get file header and push the file name 
525c			 
525c 11 b5 f9				ld de, store_page 
525f cd 65 04				call storage_read_block 
5262			 
5262					; push file id to stack 
5262				 
5262 3a b5 f9				ld a, (store_page) 
5265 26 00				ld h, 0 
5267 6f					ld l, a 
5268 cd 23 20				call forth_push_numhl 
526b			 
526b					; push extent count to stack  
526b				 
526b 3a b7 f9				ld a, (store_page+2) 
526e 26 00				ld h, 0 
5270 6f					ld l, a 
5271 cd 23 20				call forth_push_numhl 
5274			 
5274					; push file name 
5274			 
5274 21 b8 f9				ld hl, store_page+3 
5277					if DEBUG_FORTH_WORDS 
5277						DMARK "DI5" 
5277 f5				push af  
5278 3a 8c 52			ld a, (.dmark)  
527b 32 a6 fd			ld (debug_mark),a  
527e 3a 8d 52			ld a, (.dmark+1)  
5281 32 a7 fd			ld (debug_mark+1),a  
5284 3a 8e 52			ld a, (.dmark+2)  
5287 32 a8 fd			ld (debug_mark+2),a  
528a 18 03			jr .pastdmark  
528c ..			.dmark: db "DI5"  
528f f1			.pastdmark: pop af  
5290			endm  
# End of macro DMARK
5290						CALLMONITOR 
5290 cd aa fd			call debug_vector  
5293				endm  
# End of macro CALLMONITOR
5293					endif 
5293 cd 91 20				call forth_push_str 
5296					if DEBUG_FORTH_WORDS 
5296						DMARK "DI6" 
5296 f5				push af  
5297 3a ab 52			ld a, (.dmark)  
529a 32 a6 fd			ld (debug_mark),a  
529d 3a ac 52			ld a, (.dmark+1)  
52a0 32 a7 fd			ld (debug_mark+1),a  
52a3 3a ad 52			ld a, (.dmark+2)  
52a6 32 a8 fd			ld (debug_mark+2),a  
52a9 18 03			jr .pastdmark  
52ab ..			.dmark: db "DI6"  
52ae f1			.pastdmark: pop af  
52af			endm  
# End of macro DMARK
52af						CALLMONITOR 
52af cd aa fd			call debug_vector  
52b2				endm  
# End of macro CALLMONITOR
52b2					endif 
52b2			.dirnotfound: 
52b2 c1					pop bc     
52b3 10 95				djnz .diritem 
52b5				 
52b5			.dirdone:	 
52b5					if DEBUG_FORTH_WORDS 
52b5						DMARK "DI7" 
52b5 f5				push af  
52b6 3a ca 52			ld a, (.dmark)  
52b9 32 a6 fd			ld (debug_mark),a  
52bc 3a cb 52			ld a, (.dmark+1)  
52bf 32 a7 fd			ld (debug_mark+1),a  
52c2 3a cc 52			ld a, (.dmark+2)  
52c5 32 a8 fd			ld (debug_mark+2),a  
52c8 18 03			jr .pastdmark  
52ca ..			.dmark: db "DI7"  
52cd f1			.pastdmark: pop af  
52ce			endm  
# End of macro DMARK
52ce						CALLMONITOR 
52ce cd aa fd			call debug_vector  
52d1				endm  
# End of macro CALLMONITOR
52d1					endif 
52d1			 
52d1					; push a count of the dir items found 
52d1			 
52d1 26 00				ld h, 0 
52d3 69					ld l, c 
52d4 cd 23 20				call forth_push_numhl 
52d7			 
52d7					; push the bank label 
52d7			 
52d7 cd 16 05				call storage_get_block_0 
52da			 
52da				 
52da 21 b8 f9		 		ld hl, store_page+3 
52dd			 
52dd					if DEBUG_FORTH_WORDS 
52dd						DMARK "DI8" 
52dd f5				push af  
52de 3a f2 52			ld a, (.dmark)  
52e1 32 a6 fd			ld (debug_mark),a  
52e4 3a f3 52			ld a, (.dmark+1)  
52e7 32 a7 fd			ld (debug_mark+1),a  
52ea 3a f4 52			ld a, (.dmark+2)  
52ed 32 a8 fd			ld (debug_mark+2),a  
52f0 18 03			jr .pastdmark  
52f2 ..			.dmark: db "DI8"  
52f5 f1			.pastdmark: pop af  
52f6			endm  
# End of macro DMARK
52f6						CALLMONITOR 
52f6 cd aa fd			call debug_vector  
52f9				endm  
# End of macro CALLMONITOR
52f9					endif 
52f9 cd 91 20				call forth_push_str 
52fc			 
52fc			 
52fc				 
52fc					NEXTW 
52fc c3 d0 23			jp macro_next 
52ff				endm 
# End of macro NEXTW
52ff			.SAVE: 
52ff			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
52ff			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
52ff			;		NEXTW 
52ff			;.LOAD: 
52ff			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
52ff			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
52ff			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
52ff			;; > > The LOAD command can not be used in any user words or compound lines. 
52ff			; 
52ff			;		; store_openext use it. If zero it is EOF 
52ff			; 
52ff			;		; read block from current stream id 
52ff			;		; if the block does not contain zero term keep reading blocks until zero found 
52ff			;		; push the block to stack 
52ff			;		; save the block id to stream 
52ff			; 
52ff			; 
52ff			;		FORTH_DSP_VALUEHL 
52ff			; 
52ff			;;		push hl 
52ff			; 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LOA" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;		FORTH_DSP_POP 
52ff			; 
52ff			;;		pop hl 
52ff			; 
52ff			;		ld h, l 
52ff			;		ld l, 0 
52ff			; 
52ff			;		push hl     ; stack holds current file id and extent to work with 
52ff			; 
52ff			; 
52ff			;		ld de, store_page      ; get block zero of file 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LO0" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;		call storage_read 
52ff			; 
52ff			;		ld a, (store_page+2)    ; max extents for this file 
52ff			;		ld  (store_openmaxext),a   ; get our limit 
52ff			; 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LOE" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			; 
52ff			;; TODO dont know why max extents are not present 
52ff			;;		cp 0 
52ff			;;		jp z, .loadeof     ; dont read past eof 
52ff			; 
52ff			;;		ld a, 1   ; start from the head of the file 
52ff			; 
52ff			;.loadline:	pop hl 
52ff			;		inc hl 
52ff			;		ld  a, (store_openmaxext)   ; get our limit 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LOx" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;		inc a 
52ff			;		cp l 
52ff			;		jp z, .loadeof 
52ff			;		push hl    ; save current extent 
52ff			; 
52ff			;		ld de, store_page 
52ff			; 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LO1" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;		call storage_read 
52ff			; 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LO2" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;	call ishlzero 
52ff			;	ld a, l 
52ff			;	add h 
52ff			;	cp 0 
52ff			;	jr z, .loadeof 
52ff			; 
52ff			;	; not eof so hl should point to data to exec 
52ff			; 
52ff			;	; will need to add the FORTH_END_BUFFER flag 
52ff			 ; 
52ff			;	ld hl, store_page+2 
52ff			;	ld bc, 255 
52ff			;	ld a, 0 
52ff			;	cpir 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LOt" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;	dec hl 
52ff			;	ld a, ' ' 
52ff			;	ld (hl), a 
52ff			;	inc hl 
52ff			;	ld (hl), a 
52ff			;	inc hl 
52ff			;	ld (hl), a 
52ff			;	inc hl 
52ff			;	ld a, FORTH_END_BUFFER 
52ff			;	ld (hl), a 
52ff			; 
52ff			;	; TODO handle more than a single block read 
52ff			; 
52ff			; 
52ff			;	ld hl, store_page+2 
52ff			; 
52ff			;	ld (os_tok_ptr), hl 
52ff			; 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LO3" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			; 
52ff			;	call forthparse 
52ff			;	call forthexec 
52ff			;	call forthexec_cleanup 
52ff			; 
52ff			;	; go to next extent 
52ff			; 
52ff			;	; get next block  or mark as eof 
52ff			;	jp .loadline 
52ff			; 
52ff			; 
52ff			; 
52ff			;	       NEXTW 
52ff			;.loadeof:	ld a, 0 
52ff			;		ld (store_openext), a 
52ff			; 
52ff			;	if DEBUG_STORESE 
52ff			;		DMARK "LOF" 
52ff			;		CALLMONITOR 
52ff			;	endif 
52ff			;		ret 
52ff			;		;NEXTW 
52ff			;.BSAVE:   
52ff			; 
52ff			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
52ff			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
52ff			;		NEXTW 
52ff			;.BLOAD: 
52ff			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
52ff			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
52ff			;		NEXTW 
52ff			;;;; counter gap 
52ff			 
52ff			 
52ff			.SEO: 
52ff				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
52ff 64				db WORD_SYS_CORE+80             
5300 1e 53			dw .SEI            
5302 04				db 3 + 1 
5303 .. 00			db "SEO",0              
5307				endm 
# End of macro CWHEAD
5307			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5307			 
5307					; get port 
5307			 
5307					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5307 cd 1a 22			call macro_dsp_valuehl 
530a				endm 
# End of macro FORTH_DSP_VALUEHL
530a			 
530a e5					push hl    ; u2 - byte 
530b			 
530b					; destroy value TOS 
530b			 
530b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
530b cd d2 22			call macro_forth_dsp_pop 
530e				endm 
# End of macro FORTH_DSP_POP
530e			 
530e					; get byte to send 
530e			 
530e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
530e cd 1a 22			call macro_dsp_valuehl 
5311				endm 
# End of macro FORTH_DSP_VALUEHL
5311			 
5311 e5					push hl    ; u1 - addr 
5312			 
5312					; destroy value TOS 
5312			 
5312					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5312 cd d2 22			call macro_forth_dsp_pop 
5315				endm 
# End of macro FORTH_DSP_POP
5315			 
5315					; one value on hl get other one back 
5315			 
5315 d1					pop de   ; u1 - byte 
5316			 
5316 e1					pop hl   ; u2 - addr 
5317			 
5317					; TODO Send SPI byte 
5317			 
5317			 
5317 7b					ld a, e 
5318 cd 6a 02				call se_writebyte 
531b			 
531b					 
531b			 
531b					NEXTW 
531b c3 d0 23			jp macro_next 
531e				endm 
# End of macro NEXTW
531e			 
531e			.SEI: 
531e				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
531e 65				db WORD_SYS_CORE+81             
531f 38 53			dw .SFREE            
5321 04				db 3 + 1 
5322 .. 00			db "SEI",0              
5326				endm 
# End of macro CWHEAD
5326			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5326			 
5326					; get port 
5326			 
5326					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5326 cd 1a 22			call macro_dsp_valuehl 
5329				endm 
# End of macro FORTH_DSP_VALUEHL
5329			 
5329			;		push hl 
5329			 
5329					; destroy value TOS 
5329			 
5329					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5329 cd d2 22			call macro_forth_dsp_pop 
532c				endm 
# End of macro FORTH_DSP_POP
532c			 
532c					; one value on hl get other one back 
532c			 
532c			;		pop hl 
532c			 
532c			 
532c					; TODO Get SPI byte 
532c			 
532c cd 0c 03				call se_readbyte 
532f			 
532f 26 00				ld h, 0 
5331 6f					ld l, a 
5332 cd 23 20				call forth_push_numhl 
5335			 
5335					NEXTW 
5335 c3 d0 23			jp macro_next 
5338				endm 
# End of macro NEXTW
5338			 
5338			.SFREE: 
5338				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5338 67				db WORD_SYS_CORE+83             
5339 67 53			dw .SIZE            
533b 06				db 5 + 1 
533c .. 00			db "FFREE",0              
5342				endm 
# End of macro CWHEAD
5342			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5342			; | | > [!NOTE] 
5342			; | | > Compatible with PicoSPINet  
5342					if DEBUG_FORTH_WORDS_KEY 
5342						DMARK "FFR" 
5342 f5				push af  
5343 3a 57 53			ld a, (.dmark)  
5346 32 a6 fd			ld (debug_mark),a  
5349 3a 58 53			ld a, (.dmark+1)  
534c 32 a7 fd			ld (debug_mark+1),a  
534f 3a 59 53			ld a, (.dmark+2)  
5352 32 a8 fd			ld (debug_mark+2),a  
5355 18 03			jr .pastdmark  
5357 ..			.dmark: db "FFR"  
535a f1			.pastdmark: pop af  
535b			endm  
# End of macro DMARK
535b						CALLMONITOR 
535b cd aa fd			call debug_vector  
535e				endm  
# End of macro CALLMONITOR
535e					endif 
535e			 
535e cd 32 08				call storage_freeblocks 
5361			 
5361 cd 23 20				call forth_push_numhl 
5364			 
5364				       NEXTW 
5364 c3 d0 23			jp macro_next 
5367				endm 
# End of macro NEXTW
5367			.SIZE: 
5367				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5367 67				db WORD_SYS_CORE+83             
5368 9b 53			dw .CREATE            
536a 05				db 4 + 1 
536b .. 00			db "SIZE",0              
5370				endm 
# End of macro CWHEAD
5370			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5370			; | | > [!NOTE] 
5370			; | | > Compatible with PicoSPINet  
5370					if DEBUG_FORTH_WORDS_KEY 
5370						DMARK "SIZ" 
5370 f5				push af  
5371 3a 85 53			ld a, (.dmark)  
5374 32 a6 fd			ld (debug_mark),a  
5377 3a 86 53			ld a, (.dmark+1)  
537a 32 a7 fd			ld (debug_mark+1),a  
537d 3a 87 53			ld a, (.dmark+2)  
5380 32 a8 fd			ld (debug_mark+2),a  
5383 18 03			jr .pastdmark  
5385 ..			.dmark: db "SIZ"  
5388 f1			.pastdmark: pop af  
5389			endm  
# End of macro DMARK
5389						CALLMONITOR 
5389 cd aa fd			call debug_vector  
538c				endm  
# End of macro CALLMONITOR
538c					endif 
538c			 
538c					FORTH_DSP_VALUEHL 
538c cd 1a 22			call macro_dsp_valuehl 
538f				endm 
# End of macro FORTH_DSP_VALUEHL
538f			;		push hl 
538f					FORTH_DSP_POP 
538f cd d2 22			call macro_forth_dsp_pop 
5392				endm 
# End of macro FORTH_DSP_POP
5392			;		pop hl 
5392 cd 94 04				call storage_file_size 
5395			 
5395 cd 23 20				call forth_push_numhl 
5398			  
5398			 
5398				       NEXTW 
5398 c3 d0 23			jp macro_next 
539b				endm 
# End of macro NEXTW
539b			 
539b			.CREATE: 
539b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
539b 68				db WORD_SYS_CORE+84             
539c 09 54			dw .APPEND            
539e 07				db 6 + 1 
539f .. 00			db "CREATE",0              
53a6				endm 
# End of macro CWHEAD
53a6			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
53a6			; | | e.g.  
53a6			; | | TestProgram CREATE 
53a6			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
53a6			; | |  
53a6			; | | Max file IDs are 255. 
53a6			; | |  
53a6			; | | > [!NOTE] 
53a6			; | | > Compatible with PicoSPINet  
53a6					 
53a6					if DEBUG_FORTH_WORDS_KEY 
53a6						DMARK "CRT" 
53a6 f5				push af  
53a7 3a bb 53			ld a, (.dmark)  
53aa 32 a6 fd			ld (debug_mark),a  
53ad 3a bc 53			ld a, (.dmark+1)  
53b0 32 a7 fd			ld (debug_mark+1),a  
53b3 3a bd 53			ld a, (.dmark+2)  
53b6 32 a8 fd			ld (debug_mark+2),a  
53b9 18 03			jr .pastdmark  
53bb ..			.dmark: db "CRT"  
53be f1			.pastdmark: pop af  
53bf			endm  
# End of macro DMARK
53bf						CALLMONITOR 
53bf cd aa fd			call debug_vector  
53c2				endm  
# End of macro CALLMONITOR
53c2					endif 
53c2			;		call storage_get_block_0 
53c2			 
53c2					; TODO pop hl 
53c2			 
53c2					;v5 FORTH_DSP_VALUE 
53c2					FORTH_DSP_VALUE 
53c2 cd 03 22			call macro_forth_dsp_value 
53c5				endm 
# End of macro FORTH_DSP_VALUE
53c5			 
53c5				if DEBUG_STORESE 
53c5					DMARK "CR1" 
53c5 f5				push af  
53c6 3a da 53			ld a, (.dmark)  
53c9 32 a6 fd			ld (debug_mark),a  
53cc 3a db 53			ld a, (.dmark+1)  
53cf 32 a7 fd			ld (debug_mark+1),a  
53d2 3a dc 53			ld a, (.dmark+2)  
53d5 32 a8 fd			ld (debug_mark+2),a  
53d8 18 03			jr .pastdmark  
53da ..			.dmark: db "CR1"  
53dd f1			.pastdmark: pop af  
53de			endm  
# End of macro DMARK
53de					CALLMONITOR 
53de cd aa fd			call debug_vector  
53e1				endm  
# End of macro CALLMONITOR
53e1				endif 
53e1			;		push hl 
53e1			;		FORTH_DSP_POP 
53e1			;		pop hl 
53e1			 
53e1			;		inc hl   ; move past the type marker 
53e1			 
53e1 cd 68 08				call storage_create 
53e4			 
53e4				if DEBUG_STORESE 
53e4					DMARK "CT1" 
53e4 f5				push af  
53e5 3a f9 53			ld a, (.dmark)  
53e8 32 a6 fd			ld (debug_mark),a  
53eb 3a fa 53			ld a, (.dmark+1)  
53ee 32 a7 fd			ld (debug_mark+1),a  
53f1 3a fb 53			ld a, (.dmark+2)  
53f4 32 a8 fd			ld (debug_mark+2),a  
53f7 18 03			jr .pastdmark  
53f9 ..			.dmark: db "CT1"  
53fc f1			.pastdmark: pop af  
53fd			endm  
# End of macro DMARK
53fd					CALLMONITOR 
53fd cd aa fd			call debug_vector  
5400				endm  
# End of macro CALLMONITOR
5400				endif 
5400			;		push hl 
5400					FORTH_DSP_POP 
5400 cd d2 22			call macro_forth_dsp_pop 
5403				endm 
# End of macro FORTH_DSP_POP
5403			;		pop hl 
5403					; push file id to stack 
5403 cd 23 20				call forth_push_numhl 
5406			 
5406			 
5406			 
5406				       NEXTW 
5406 c3 d0 23			jp macro_next 
5409				endm 
# End of macro NEXTW
5409			 
5409			.APPEND: 
5409				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5409 69				db WORD_SYS_CORE+85             
540a 9a 54			dw .SDEL            
540c 07				db 6 + 1 
540d .. 00			db "APPEND",0              
5414				endm 
# End of macro CWHEAD
5414			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5414			; | | e.g. 
5414			; | | Test CREATE      -> $01 
5414			; | | "A string to add to file" $01 APPEND 
5414			; | |  
5414			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5414			; | | > [!NOTE] 
5414			; | | > Compatible with PicoSPINet  
5414					if DEBUG_FORTH_WORDS_KEY 
5414						DMARK "APP" 
5414 f5				push af  
5415 3a 29 54			ld a, (.dmark)  
5418 32 a6 fd			ld (debug_mark),a  
541b 3a 2a 54			ld a, (.dmark+1)  
541e 32 a7 fd			ld (debug_mark+1),a  
5421 3a 2b 54			ld a, (.dmark+2)  
5424 32 a8 fd			ld (debug_mark+2),a  
5427 18 03			jr .pastdmark  
5429 ..			.dmark: db "APP"  
542c f1			.pastdmark: pop af  
542d			endm  
# End of macro DMARK
542d						CALLMONITOR 
542d cd aa fd			call debug_vector  
5430				endm  
# End of macro CALLMONITOR
5430					endif 
5430			 
5430					FORTH_DSP_VALUEHL 
5430 cd 1a 22			call macro_dsp_valuehl 
5433				endm 
# End of macro FORTH_DSP_VALUEHL
5433 e5					push hl 	; save file id 
5434			 
5434				if DEBUG_STORESE 
5434					DMARK "AP1" 
5434 f5				push af  
5435 3a 49 54			ld a, (.dmark)  
5438 32 a6 fd			ld (debug_mark),a  
543b 3a 4a 54			ld a, (.dmark+1)  
543e 32 a7 fd			ld (debug_mark+1),a  
5441 3a 4b 54			ld a, (.dmark+2)  
5444 32 a8 fd			ld (debug_mark+2),a  
5447 18 03			jr .pastdmark  
5449 ..			.dmark: db "AP1"  
544c f1			.pastdmark: pop af  
544d			endm  
# End of macro DMARK
544d					CALLMONITOR 
544d cd aa fd			call debug_vector  
5450				endm  
# End of macro CALLMONITOR
5450				endif 
5450					FORTH_DSP_POP 
5450 cd d2 22			call macro_forth_dsp_pop 
5453				endm 
# End of macro FORTH_DSP_POP
5453			 
5453					FORTH_DSP_VALUEHL 
5453 cd 1a 22			call macro_dsp_valuehl 
5456				endm 
# End of macro FORTH_DSP_VALUEHL
5456					;v5 FORTH_DSP_VALUE 
5456 e5					push hl 	; save ptr to string to save 
5457			 
5457				if DEBUG_STORESE 
5457					DMARK "AP1" 
5457 f5				push af  
5458 3a 6c 54			ld a, (.dmark)  
545b 32 a6 fd			ld (debug_mark),a  
545e 3a 6d 54			ld a, (.dmark+1)  
5461 32 a7 fd			ld (debug_mark+1),a  
5464 3a 6e 54			ld a, (.dmark+2)  
5467 32 a8 fd			ld (debug_mark+2),a  
546a 18 03			jr .pastdmark  
546c ..			.dmark: db "AP1"  
546f f1			.pastdmark: pop af  
5470			endm  
# End of macro DMARK
5470					CALLMONITOR 
5470 cd aa fd			call debug_vector  
5473				endm  
# End of macro CALLMONITOR
5473				endif 
5473					FORTH_DSP_POP 
5473 cd d2 22			call macro_forth_dsp_pop 
5476				endm 
# End of macro FORTH_DSP_POP
5476			 
5476 d1					pop de 
5477 e1					pop hl 
5478				if DEBUG_STORESE 
5478					DMARK "AP2" 
5478 f5				push af  
5479 3a 8d 54			ld a, (.dmark)  
547c 32 a6 fd			ld (debug_mark),a  
547f 3a 8e 54			ld a, (.dmark+1)  
5482 32 a7 fd			ld (debug_mark+1),a  
5485 3a 8f 54			ld a, (.dmark+2)  
5488 32 a8 fd			ld (debug_mark+2),a  
548b 18 03			jr .pastdmark  
548d ..			.dmark: db "AP2"  
5490 f1			.pastdmark: pop af  
5491			endm  
# End of macro DMARK
5491					CALLMONITOR 
5491 cd aa fd			call debug_vector  
5494				endm  
# End of macro CALLMONITOR
5494				endif 
5494					;inc de ; skip var type indicator 
5494			 
5494					; TODO how to append numerics???? 
5494			 
5494 cd 55 0b				call storage_append		 
5497			 
5497				       NEXTW 
5497 c3 d0 23			jp macro_next 
549a				endm 
# End of macro NEXTW
549a			.SDEL: 
549a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
549a 6a				db WORD_SYS_CORE+86             
549b e6 54			dw .OPEN            
549d 05				db 4 + 1 
549e .. 00			db "ERA",0              
54a2				endm 
# End of macro CWHEAD
54a2			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
54a2			; | | > [!NOTE] 
54a2			; | | > Compatible with PicoSPINet  
54a2					FORTH_DSP_VALUEHL 
54a2 cd 1a 22			call macro_dsp_valuehl 
54a5				endm 
# End of macro FORTH_DSP_VALUEHL
54a5			;		push hl 	; save file id 
54a5			 
54a5					if DEBUG_FORTH_WORDS_KEY 
54a5						DMARK "ERA" 
54a5 f5				push af  
54a6 3a ba 54			ld a, (.dmark)  
54a9 32 a6 fd			ld (debug_mark),a  
54ac 3a bb 54			ld a, (.dmark+1)  
54af 32 a7 fd			ld (debug_mark+1),a  
54b2 3a bc 54			ld a, (.dmark+2)  
54b5 32 a8 fd			ld (debug_mark+2),a  
54b8 18 03			jr .pastdmark  
54ba ..			.dmark: db "ERA"  
54bd f1			.pastdmark: pop af  
54be			endm  
# End of macro DMARK
54be						CALLMONITOR 
54be cd aa fd			call debug_vector  
54c1				endm  
# End of macro CALLMONITOR
54c1					endif 
54c1				if DEBUG_STORESE 
54c1					DMARK "ER1" 
54c1 f5				push af  
54c2 3a d6 54			ld a, (.dmark)  
54c5 32 a6 fd			ld (debug_mark),a  
54c8 3a d7 54			ld a, (.dmark+1)  
54cb 32 a7 fd			ld (debug_mark+1),a  
54ce 3a d8 54			ld a, (.dmark+2)  
54d1 32 a8 fd			ld (debug_mark+2),a  
54d4 18 03			jr .pastdmark  
54d6 ..			.dmark: db "ER1"  
54d9 f1			.pastdmark: pop af  
54da			endm  
# End of macro DMARK
54da					CALLMONITOR 
54da cd aa fd			call debug_vector  
54dd				endm  
# End of macro CALLMONITOR
54dd				endif 
54dd					FORTH_DSP_POP 
54dd cd d2 22			call macro_forth_dsp_pop 
54e0				endm 
# End of macro FORTH_DSP_POP
54e0			 
54e0			;		pop hl 
54e0			 
54e0 cd a7 06				call storage_erase 
54e3				       NEXTW 
54e3 c3 d0 23			jp macro_next 
54e6				endm 
# End of macro NEXTW
54e6			 
54e6			.OPEN: 
54e6				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
54e6 6b				db WORD_SYS_CORE+87             
54e7 7a 55			dw .READ            
54e9 05				db 4 + 1 
54ea .. 00			db "OPEN",0              
54ef				endm 
# End of macro CWHEAD
54ef			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
54ef			; | | e.g. 
54ef			; | | $01 OPEN $01 DO $01 READ . LOOP 
54ef			; | | 
54ef			; | | Will return with 255 blocks if the file does not exist 
54ef			; | | > [!NOTE] 
54ef			; | | > Compatible with PicoSPINet  
54ef			 
54ef					if DEBUG_FORTH_WORDS_KEY 
54ef						DMARK "OPN" 
54ef f5				push af  
54f0 3a 04 55			ld a, (.dmark)  
54f3 32 a6 fd			ld (debug_mark),a  
54f6 3a 05 55			ld a, (.dmark+1)  
54f9 32 a7 fd			ld (debug_mark+1),a  
54fc 3a 06 55			ld a, (.dmark+2)  
54ff 32 a8 fd			ld (debug_mark+2),a  
5502 18 03			jr .pastdmark  
5504 ..			.dmark: db "OPN"  
5507 f1			.pastdmark: pop af  
5508			endm  
# End of macro DMARK
5508						CALLMONITOR 
5508 cd aa fd			call debug_vector  
550b				endm  
# End of macro CALLMONITOR
550b					endif 
550b					; TODO handle multiple file opens 
550b			 
550b 3e 01			       	ld a, 1 
550d 32 a5 f9				ld (store_openext), a 
5510			 
5510					; get max extents for this file 
5510				 
5510								 
5510					FORTH_DSP_VALUEHL 
5510 cd 1a 22			call macro_dsp_valuehl 
5513				endm 
# End of macro FORTH_DSP_VALUEHL
5513			 
5513 65					ld h, l 
5514 2e 00				ld l, 0 
5516			 
5516					; store file id 
5516			 
5516 7c					ld a, h 
5517 32 a2 f9				ld (store_filecache), a 
551a			 
551a				if DEBUG_STORESE 
551a					DMARK "OPN" 
551a f5				push af  
551b 3a 2f 55			ld a, (.dmark)  
551e 32 a6 fd			ld (debug_mark),a  
5521 3a 30 55			ld a, (.dmark+1)  
5524 32 a7 fd			ld (debug_mark+1),a  
5527 3a 31 55			ld a, (.dmark+2)  
552a 32 a8 fd			ld (debug_mark+2),a  
552d 18 03			jr .pastdmark  
552f ..			.dmark: db "OPN"  
5532 f1			.pastdmark: pop af  
5533			endm  
# End of macro DMARK
5533					CALLMONITOR 
5533 cd aa fd			call debug_vector  
5536				endm  
# End of macro CALLMONITOR
5536				endif 
5536			;		push hl 
5536					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5536 cd d2 22			call macro_forth_dsp_pop 
5539				endm 
# End of macro FORTH_DSP_POP
5539			;		pop hl 
5539						 
5539 11 b5 f9				ld de, store_page      ; get block zero of file 
553c cd be 09				call storage_read 
553f cd f8 0f			call ishlzero 
5542 20 04			jr nz, .opfound 
5544			 
5544				; file does not exist so indicate with 255 extents in use 
5544			 
5544 3e ff			ld a, 255 
5546 18 29			jr .skipopeneof 
5548			 
5548			 
5548			.opfound: 
5548			 
5548			 
5548 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
554b 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
554e					 
554e				if DEBUG_STORESE 
554e					DMARK "OPx" 
554e f5				push af  
554f 3a 63 55			ld a, (.dmark)  
5552 32 a6 fd			ld (debug_mark),a  
5555 3a 64 55			ld a, (.dmark+1)  
5558 32 a7 fd			ld (debug_mark+1),a  
555b 3a 65 55			ld a, (.dmark+2)  
555e 32 a8 fd			ld (debug_mark+2),a  
5561 18 03			jr .pastdmark  
5563 ..			.dmark: db "OPx"  
5566 f1			.pastdmark: pop af  
5567			endm  
# End of macro DMARK
5567					CALLMONITOR 
5567 cd aa fd			call debug_vector  
556a				endm  
# End of macro CALLMONITOR
556a				endif 
556a fe 00				cp 0 
556c 20 03				jr nz, .skipopeneof 
556e					; have opened an empty file 
556e					 
556e 32 a5 f9				ld (store_openext), a 
5571			 
5571			.skipopeneof: 
5571			 
5571 6f					ld l, a 
5572 26 00				ld h, 0 
5574 cd 23 20				call forth_push_numhl 
5577			 
5577			 
5577				       NEXTW 
5577 c3 d0 23			jp macro_next 
557a				endm 
# End of macro NEXTW
557a			.READ: 
557a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
557a 6c				db WORD_SYS_CORE+88             
557b a4 56			dw .EOF            
557d 05				db 4 + 1 
557e .. 00			db "READ",0              
5583				endm 
# End of macro CWHEAD
5583			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5583			; | | e.g. 
5583			; | | $01 OPEN $01 DO READ . LOOP 
5583			; | | 
5583			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5583			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5583			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5583			; | | two bytes contain the file id and extent. 
5583			; | |  
5583			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5583			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5583			; | | > [!NOTE] 
5583			; | | > Compatible with PicoSPINet  
5583			 
5583					if DEBUG_FORTH_WORDS_KEY 
5583						DMARK "REA" 
5583 f5				push af  
5584 3a 98 55			ld a, (.dmark)  
5587 32 a6 fd			ld (debug_mark),a  
558a 3a 99 55			ld a, (.dmark+1)  
558d 32 a7 fd			ld (debug_mark+1),a  
5590 3a 9a 55			ld a, (.dmark+2)  
5593 32 a8 fd			ld (debug_mark+2),a  
5596 18 03			jr .pastdmark  
5598 ..			.dmark: db "REA"  
559b f1			.pastdmark: pop af  
559c			endm  
# End of macro DMARK
559c						CALLMONITOR 
559c cd aa fd			call debug_vector  
559f				endm  
# End of macro CALLMONITOR
559f					endif 
559f					; store_openext use it. If zero it is EOF 
559f			 
559f					; read block from current stream id 
559f					; if the block does not contain zero term keep reading blocks until zero found 
559f					; push the block to stack 
559f					; save the block id to stream 
559f			 
559f			 
559f cd d1 56				call .testeof 
55a2 3e 01				ld a, 1 
55a4 bd					cp l 
55a5 ca 80 56				jp z, .ateof 
55a8			 
55a8			 
55a8			;		FORTH_DSP_VALUEHL 
55a8			 
55a8			;		push hl 
55a8			 
55a8			;	if DEBUG_STORESE 
55a8			;		DMARK "REA" 
55a8			;		CALLMONITOR 
55a8			;	endif 
55a8			;		FORTH_DSP_POP 
55a8			 
55a8			;		pop hl 
55a8				 
55a8 3a a2 f9				ld a, (store_filecache) 
55ab 67					ld h,a 
55ac			 
55ac 3a a5 f9				ld a, (store_openext) 
55af 6f					ld l, a 
55b0					 
55b0 fe 00				cp 0 
55b2 ca 80 56				jp z, .ateof     ; dont read past eof 
55b5			 
55b5 cd a1 0c				call storage_clear_page 
55b8			 
55b8 11 b5 f9				ld de, store_page 
55bb				if DEBUG_STORESE 
55bb					DMARK "RE1" 
55bb f5				push af  
55bc 3a d0 55			ld a, (.dmark)  
55bf 32 a6 fd			ld (debug_mark),a  
55c2 3a d1 55			ld a, (.dmark+1)  
55c5 32 a7 fd			ld (debug_mark+1),a  
55c8 3a d2 55			ld a, (.dmark+2)  
55cb 32 a8 fd			ld (debug_mark+2),a  
55ce 18 03			jr .pastdmark  
55d0 ..			.dmark: db "RE1"  
55d3 f1			.pastdmark: pop af  
55d4			endm  
# End of macro DMARK
55d4					CALLMONITOR 
55d4 cd aa fd			call debug_vector  
55d7				endm  
# End of macro CALLMONITOR
55d7				endif 
55d7 cd be 09				call storage_read 
55da			 
55da				if DEBUG_STORESE 
55da					DMARK "RE2" 
55da f5				push af  
55db 3a ef 55			ld a, (.dmark)  
55de 32 a6 fd			ld (debug_mark),a  
55e1 3a f0 55			ld a, (.dmark+1)  
55e4 32 a7 fd			ld (debug_mark+1),a  
55e7 3a f1 55			ld a, (.dmark+2)  
55ea 32 a8 fd			ld (debug_mark+2),a  
55ed 18 03			jr .pastdmark  
55ef ..			.dmark: db "RE2"  
55f2 f1			.pastdmark: pop af  
55f3			endm  
# End of macro DMARK
55f3					CALLMONITOR 
55f3 cd aa fd			call debug_vector  
55f6				endm  
# End of macro CALLMONITOR
55f6				endif 
55f6 cd f8 0f			call ishlzero 
55f9			;	ld a, l 
55f9			;	add h 
55f9			;	cp 0 
55f9 ca 80 56			jp z, .readeof 
55fc			 
55fc				; not eof so hl should point to data to push to stack 
55fc			 
55fc				if DEBUG_STORESE 
55fc					DMARK "RE3" 
55fc f5				push af  
55fd 3a 11 56			ld a, (.dmark)  
5600 32 a6 fd			ld (debug_mark),a  
5603 3a 12 56			ld a, (.dmark+1)  
5606 32 a7 fd			ld (debug_mark+1),a  
5609 3a 13 56			ld a, (.dmark+2)  
560c 32 a8 fd			ld (debug_mark+2),a  
560f 18 03			jr .pastdmark  
5611 ..			.dmark: db "RE3"  
5614 f1			.pastdmark: pop af  
5615			endm  
# End of macro DMARK
5615					CALLMONITOR 
5615 cd aa fd			call debug_vector  
5618				endm  
# End of macro CALLMONITOR
5618				endif 
5618 cd 91 20			call forth_push_str 
561b			 
561b				if DEBUG_STORESE 
561b					DMARK "RE4" 
561b f5				push af  
561c 3a 30 56			ld a, (.dmark)  
561f 32 a6 fd			ld (debug_mark),a  
5622 3a 31 56			ld a, (.dmark+1)  
5625 32 a7 fd			ld (debug_mark+1),a  
5628 3a 32 56			ld a, (.dmark+2)  
562b 32 a8 fd			ld (debug_mark+2),a  
562e 18 03			jr .pastdmark  
5630 ..			.dmark: db "RE4"  
5633 f1			.pastdmark: pop af  
5634			endm  
# End of macro DMARK
5634					CALLMONITOR 
5634 cd aa fd			call debug_vector  
5637				endm  
# End of macro CALLMONITOR
5637				endif 
5637				; get next block  or mark as eof 
5637			 
5637 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
563a 4f				ld c, a	 
563b 3a a5 f9			ld a, (store_openext) 
563e			 
563e				if DEBUG_STORESE 
563e					DMARK "RE5" 
563e f5				push af  
563f 3a 53 56			ld a, (.dmark)  
5642 32 a6 fd			ld (debug_mark),a  
5645 3a 54 56			ld a, (.dmark+1)  
5648 32 a7 fd			ld (debug_mark+1),a  
564b 3a 55 56			ld a, (.dmark+2)  
564e 32 a8 fd			ld (debug_mark+2),a  
5651 18 03			jr .pastdmark  
5653 ..			.dmark: db "RE5"  
5656 f1			.pastdmark: pop af  
5657			endm  
# End of macro DMARK
5657					CALLMONITOR 
5657 cd aa fd			call debug_vector  
565a				endm  
# End of macro CALLMONITOR
565a				endif 
565a b9				cp c 
565b 28 23			jr z, .readeof     ; at last extent 
565d			 
565d 3c					inc a 
565e 32 a5 f9				ld (store_openext), a 
5661			 
5661				if DEBUG_STORESE 
5661					DMARK "RE6" 
5661 f5				push af  
5662 3a 76 56			ld a, (.dmark)  
5665 32 a6 fd			ld (debug_mark),a  
5668 3a 77 56			ld a, (.dmark+1)  
566b 32 a7 fd			ld (debug_mark+1),a  
566e 3a 78 56			ld a, (.dmark+2)  
5671 32 a8 fd			ld (debug_mark+2),a  
5674 18 03			jr .pastdmark  
5676 ..			.dmark: db "RE6"  
5679 f1			.pastdmark: pop af  
567a			endm  
# End of macro DMARK
567a					CALLMONITOR 
567a cd aa fd			call debug_vector  
567d				endm  
# End of macro CALLMONITOR
567d				endif 
567d			 
567d			 
567d				       NEXTW 
567d c3 d0 23			jp macro_next 
5680				endm 
# End of macro NEXTW
5680			.ateof: 
5680				;	ld hl, .showeof 
5680				;	call forth_push_str 
5680 3e 00		.readeof:	ld a, 0 
5682 32 a5 f9				ld (store_openext), a 
5685			 
5685					 
5685				if DEBUG_STORESE 
5685					DMARK "REF" 
5685 f5				push af  
5686 3a 9a 56			ld a, (.dmark)  
5689 32 a6 fd			ld (debug_mark),a  
568c 3a 9b 56			ld a, (.dmark+1)  
568f 32 a7 fd			ld (debug_mark+1),a  
5692 3a 9c 56			ld a, (.dmark+2)  
5695 32 a8 fd			ld (debug_mark+2),a  
5698 18 03			jr .pastdmark  
569a ..			.dmark: db "REF"  
569d f1			.pastdmark: pop af  
569e			endm  
# End of macro DMARK
569e					CALLMONITOR 
569e cd aa fd			call debug_vector  
56a1				endm  
# End of macro CALLMONITOR
56a1				endif 
56a1				       NEXTW 
56a1 c3 d0 23			jp macro_next 
56a4				endm 
# End of macro NEXTW
56a4			 
56a4			;.showeof:   db "eof", 0 
56a4			 
56a4			 
56a4			.EOF: 
56a4				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
56a4 6d				db WORD_SYS_CORE+89             
56a5 e6 56			dw .FORMAT            
56a7 04				db 3 + 1 
56a8 .. 00			db "EOF",0              
56ac				endm 
# End of macro CWHEAD
56ac			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56ac			; | | e.g. 
56ac			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56ac			; | | > [!NOTE] 
56ac			; | | > Compatible with PicoSPINet  
56ac					; TODO if current block id for stream is zero then push true else false 
56ac			 
56ac					if DEBUG_FORTH_WORDS_KEY 
56ac						DMARK "EOF" 
56ac f5				push af  
56ad 3a c1 56			ld a, (.dmark)  
56b0 32 a6 fd			ld (debug_mark),a  
56b3 3a c2 56			ld a, (.dmark+1)  
56b6 32 a7 fd			ld (debug_mark+1),a  
56b9 3a c3 56			ld a, (.dmark+2)  
56bc 32 a8 fd			ld (debug_mark+2),a  
56bf 18 03			jr .pastdmark  
56c1 ..			.dmark: db "EOF"  
56c4 f1			.pastdmark: pop af  
56c5			endm  
# End of macro DMARK
56c5						CALLMONITOR 
56c5 cd aa fd			call debug_vector  
56c8				endm  
# End of macro CALLMONITOR
56c8					endif 
56c8			 
56c8					; TODO handlue multiple file streams 
56c8			 
56c8			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56c8 cd d1 56				call .testeof 
56cb cd 23 20				call forth_push_numhl 
56ce			 
56ce			 
56ce				       NEXTW 
56ce c3 d0 23			jp macro_next 
56d1				endm 
# End of macro NEXTW
56d1			 
56d1			.testeof: 
56d1 2e 01				ld l, 1 
56d3 3a a4 f9				ld a, (store_openmaxext) 
56d6 fe 00				cp 0 
56d8 28 09				jr  z, .eofdone   ; empty file 
56da 3a a5 f9				ld a, (store_openext) 
56dd fe 00				cp 0 
56df 28 02				jr  z, .eofdone 
56e1 2e 00				ld l, 0 
56e3 26 00		.eofdone:	ld h, 0 
56e5 c9					ret 
56e6			 
56e6			 
56e6			 
56e6			 
56e6			.FORMAT: 
56e6				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
56e6 6d				db WORD_SYS_CORE+89             
56e7 37 57			dw .LABEL            
56e9 07				db 6 + 1 
56ea .. 00			db "FORMAT",0              
56f1				endm 
# End of macro CWHEAD
56f1			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
56f1			; | | > [!NOTE] 
56f1			; | | > Compatible with PicoSPINet  
56f1					; TODO if current block id for stream is zero then push true else false 
56f1				 
56f1				if DEBUG_STORESE 
56f1					DMARK "FOR" 
56f1 f5				push af  
56f2 3a 06 57			ld a, (.dmark)  
56f5 32 a6 fd			ld (debug_mark),a  
56f8 3a 07 57			ld a, (.dmark+1)  
56fb 32 a7 fd			ld (debug_mark+1),a  
56fe 3a 08 57			ld a, (.dmark+2)  
5701 32 a8 fd			ld (debug_mark+2),a  
5704 18 03			jr .pastdmark  
5706 ..			.dmark: db "FOR"  
5709 f1			.pastdmark: pop af  
570a			endm  
# End of macro DMARK
570a					CALLMONITOR 
570a cd aa fd			call debug_vector  
570d				endm  
# End of macro CALLMONITOR
570d				endif 
570d					; Wipes the bank check flags to cause a reformat on next block 0 read 
570d			 
570d 21 01 00				ld hl, 1 
5710 3e 00				ld a, 0 
5712 cd 6a 02				call se_writebyte 
5715			 
5715				if DEBUG_STORESE 
5715					DMARK "FO0" 
5715 f5				push af  
5716 3a 2a 57			ld a, (.dmark)  
5719 32 a6 fd			ld (debug_mark),a  
571c 3a 2b 57			ld a, (.dmark+1)  
571f 32 a7 fd			ld (debug_mark+1),a  
5722 3a 2c 57			ld a, (.dmark+2)  
5725 32 a8 fd			ld (debug_mark+2),a  
5728 18 03			jr .pastdmark  
572a ..			.dmark: db "FO0"  
572d f1			.pastdmark: pop af  
572e			endm  
# End of macro DMARK
572e					CALLMONITOR 
572e cd aa fd			call debug_vector  
5731				endm  
# End of macro CALLMONITOR
5731				endif 
5731					; force bank init 
5731			 
5731 cd 16 05				call storage_get_block_0 
5734					 
5734				       NEXTW 
5734 c3 d0 23			jp macro_next 
5737				endm 
# End of macro NEXTW
5737			.LABEL: 
5737				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5737 6d				db WORD_SYS_CORE+89             
5738 85 57			dw .STOREPAGE            
573a 06				db 5 + 1 
573b .. 00			db "LABEL",0              
5741				endm 
# End of macro CWHEAD
5741			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5741			; | | > [!NOTE] 
5741			; | | > Compatible with PicoSPINet  
5741					; TODO test to see if bank is selected 
5741				 
5741					if DEBUG_FORTH_WORDS_KEY 
5741						DMARK "LBL" 
5741 f5				push af  
5742 3a 56 57			ld a, (.dmark)  
5745 32 a6 fd			ld (debug_mark),a  
5748 3a 57 57			ld a, (.dmark+1)  
574b 32 a7 fd			ld (debug_mark+1),a  
574e 3a 58 57			ld a, (.dmark+2)  
5751 32 a8 fd			ld (debug_mark+2),a  
5754 18 03			jr .pastdmark  
5756 ..			.dmark: db "LBL"  
5759 f1			.pastdmark: pop af  
575a			endm  
# End of macro DMARK
575a						CALLMONITOR 
575a cd aa fd			call debug_vector  
575d				endm  
# End of macro CALLMONITOR
575d					endif 
575d			;	if DEBUG_STORESE 
575d			;		DMARK "LBL" 
575d			;		CALLMONITOR 
575d			;	endif 
575d					FORTH_DSP_VALUEHL 
575d cd 1a 22			call macro_dsp_valuehl 
5760				endm 
# End of macro FORTH_DSP_VALUEHL
5760					;v5FORTH_DSP_VALUE 
5760					 
5760			;		push hl 
5760					FORTH_DSP_POP 
5760 cd d2 22			call macro_forth_dsp_pop 
5763				endm 
# End of macro FORTH_DSP_POP
5763			;		pop hl 
5763			 
5763			;v5		inc hl   ; move past the type marker 
5763			 
5763				if DEBUG_STORESE 
5763					DMARK "LBl" 
5763 f5				push af  
5764 3a 78 57			ld a, (.dmark)  
5767 32 a6 fd			ld (debug_mark),a  
576a 3a 79 57			ld a, (.dmark+1)  
576d 32 a7 fd			ld (debug_mark+1),a  
5770 3a 7a 57			ld a, (.dmark+2)  
5773 32 a8 fd			ld (debug_mark+2),a  
5776 18 03			jr .pastdmark  
5778 ..			.dmark: db "LBl"  
577b f1			.pastdmark: pop af  
577c			endm  
# End of macro DMARK
577c					CALLMONITOR 
577c cd aa fd			call debug_vector  
577f				endm  
# End of macro CALLMONITOR
577f				endif 
577f cd 3a 06				call storage_label 
5782			 
5782				       NEXTW 
5782 c3 d0 23			jp macro_next 
5785				endm 
# End of macro NEXTW
5785			.STOREPAGE: 
5785				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5785 6d				db WORD_SYS_CORE+89             
5786 b8 57			dw .LABELS            
5788 0a				db 9 + 1 
5789 .. 00			db "STOREPAGE",0              
5793				endm 
# End of macro CWHEAD
5793			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5793			; | | > [!NOTE] 
5793			; | | > Compatible with PicoSPINet  
5793					; TODO test to see if bank is selected 
5793				 
5793					if DEBUG_FORTH_WORDS_KEY 
5793						DMARK "STP" 
5793 f5				push af  
5794 3a a8 57			ld a, (.dmark)  
5797 32 a6 fd			ld (debug_mark),a  
579a 3a a9 57			ld a, (.dmark+1)  
579d 32 a7 fd			ld (debug_mark+1),a  
57a0 3a aa 57			ld a, (.dmark+2)  
57a3 32 a8 fd			ld (debug_mark+2),a  
57a6 18 03			jr .pastdmark  
57a8 ..			.dmark: db "STP"  
57ab f1			.pastdmark: pop af  
57ac			endm  
# End of macro DMARK
57ac						CALLMONITOR 
57ac cd aa fd			call debug_vector  
57af				endm  
# End of macro CALLMONITOR
57af					endif 
57af			;	if DEBUG_STORESE 
57af			;		DMARK "STP" 
57af			;		CALLMONITOR 
57af			;	endif 
57af			 
57af 21 b5 f9			ld hl, store_page 
57b2 cd 23 20			call forth_push_numhl 
57b5			 
57b5			 
57b5				       NEXTW 
57b5 c3 d0 23			jp macro_next 
57b8				endm 
# End of macro NEXTW
57b8			.LABELS: 
57b8				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57b8 6d				db WORD_SYS_CORE+89             
57b9 42 58			dw .SCONST1            
57bb 07				db 6 + 1 
57bc .. 00			db "LABELS",0              
57c3				endm 
# End of macro CWHEAD
57c3			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
57c3			; | | > [!CAUTION] 
57c3			; | | > *NOT* Compatible with PicoSPINet  
57c3					;  
57c3			 
57c3					; save the current device selected to restore afterwards 
57c3				 
57c3 3a 9b f9				ld a, (spi_device) 
57c6 f5					push af 
57c7			 
57c7			 
57c7					; run through each of the banks 
57c7			 
57c7 21 01 00				ld hl, 1 
57ca cd 23 20				call forth_push_numhl 
57cd 3e ff				ld a, SPI_CE_HIGH 
57cf cb 87				res SPI_CE0, a 
57d1 32 9b f9				ld (spi_device), a 
57d4 cd 16 05				call storage_get_block_0 
57d7 21 b8 f9				ld hl, store_page+3 
57da cd 91 20				call forth_push_str 
57dd			 
57dd					 
57dd 21 02 00				ld hl, 2 
57e0 cd 23 20				call forth_push_numhl 
57e3 3e ff				ld a, SPI_CE_HIGH 
57e5 cb 8f				res SPI_CE1, a 
57e7 32 9b f9				ld (spi_device), a 
57ea cd 16 05				call storage_get_block_0 
57ed 21 b8 f9				ld hl, store_page+3 
57f0 cd 91 20				call forth_push_str 
57f3			 
57f3					 
57f3 21 03 00				ld hl, 3 
57f6 cd 23 20				call forth_push_numhl 
57f9 3e ff				ld a, SPI_CE_HIGH 
57fb cb 97				res SPI_CE2, a 
57fd 32 9b f9				ld (spi_device), a 
5800 cd 16 05				call storage_get_block_0 
5803 21 b8 f9				ld hl, store_page+3 
5806 cd 91 20				call forth_push_str 
5809			 
5809			 
5809 21 04 00				ld hl, 4 
580c cd 23 20				call forth_push_numhl 
580f 3e ff				ld a, SPI_CE_HIGH 
5811 cb 9f				res SPI_CE3, a 
5813 32 9b f9				ld (spi_device), a 
5816 cd 16 05				call storage_get_block_0 
5819 21 b8 f9				ld hl, store_page+3 
581c cd 91 20				call forth_push_str 
581f			 
581f					 
581f			 
581f 21 05 00				ld hl, 5 
5822 cd 23 20				call forth_push_numhl 
5825 3e ff				ld a, SPI_CE_HIGH 
5827 cb a7				res SPI_CE4, a 
5829 32 9b f9				ld (spi_device), a 
582c cd 16 05				call storage_get_block_0 
582f 21 b8 f9				ld hl, store_page+3 
5832 cd 91 20				call forth_push_str 
5835			 
5835					 
5835					; push fixed count of storage devices (on board) for now 
5835			 
5835 21 05 00				ld hl, 5 
5838 cd 23 20				call forth_push_numhl 
583b			 
583b					; restore selected device  
583b				 
583b f1					pop af 
583c 32 9b f9				ld (spi_device), a 
583f			 
583f				       NEXTW 
583f c3 d0 23			jp macro_next 
5842				endm 
# End of macro NEXTW
5842			 
5842			.SCONST1: 
5842				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5842 6d				db WORD_SYS_CORE+89             
5843 59 58			dw .SCONST2            
5845 07				db 6 + 1 
5846 .. 00			db "FILEID",0              
584d				endm 
# End of macro CWHEAD
584d			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
584d			; | | > [!NOTE] 
584d			; | | > Compatible with PicoSPINet  
584d 3a a2 f9				ld a, (store_filecache) 
5850 26 00				ld h, 0 
5852 6f					ld l, a 
5853 cd 23 20				call forth_push_numhl 
5856					NEXTW 
5856 c3 d0 23			jp macro_next 
5859				endm 
# End of macro NEXTW
5859			.SCONST2: 
5859				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5859 6d				db WORD_SYS_CORE+89             
585a 71 58			dw .SCONST3            
585c 08				db 7 + 1 
585d .. 00			db "FILEEXT",0              
5865				endm 
# End of macro CWHEAD
5865			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5865			; | | > [!NOTE] 
5865			; | | > Compatible with PicoSPINet  
5865 3a a5 f9				ld a, (store_openext) 
5868 26 00				ld h, 0 
586a 6f					ld l, a 
586b cd 23 20				call forth_push_numhl 
586e					NEXTW 
586e c3 d0 23			jp macro_next 
5871				endm 
# End of macro NEXTW
5871			.SCONST3: 
5871				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5871 6d				db WORD_SYS_CORE+89             
5872 89 58			dw .SCONST4            
5874 08				db 7 + 1 
5875 .. 00			db "FILEMAX",0              
587d				endm 
# End of macro CWHEAD
587d			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
587d			; | | > [!NOTE] 
587d			; | | > Compatible with PicoSPINet  
587d 3a a4 f9				ld a, (store_openmaxext) 
5880 26 00				ld h, 0 
5882 6f					ld l, a 
5883 cd 23 20				call forth_push_numhl 
5886					NEXTW 
5886 c3 d0 23			jp macro_next 
5889				endm 
# End of macro NEXTW
5889			.SCONST4: 
5889				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5889 6d				db WORD_SYS_CORE+89             
588a 9f 58			dw .SCONST5            
588c 09				db 8 + 1 
588d .. 00			db "FILEADDR",0              
5896				endm 
# End of macro CWHEAD
5896			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5896			; | | > [!NOTE] 
5896			; | | > Compatible with PicoSPINet  
5896 2a a6 f9				ld hl, (store_openaddr) 
5899 cd 23 20				call forth_push_numhl 
589c					NEXTW 
589c c3 d0 23			jp macro_next 
589f				endm 
# End of macro NEXTW
589f			.SCONST5: 
589f				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
589f 6d				db WORD_SYS_CORE+89             
58a0 c0 58			dw .SCONST6            
58a2 09				db 8 + 1 
58a3 .. 00			db "FILEPAGE",0              
58ac				endm 
# End of macro CWHEAD
58ac			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58ac			; | | > [!NOTE] 
58ac			; | | > Compatible with PicoSPINet  
58ac 2a a6 f9				ld hl, (store_openaddr) 
58af e5					push hl 
58b0 c1					pop bc 
58b1 16 00				ld d, 0 
58b3 1e 40				ld e, STORE_BLOCK_PHY 
58b5 cd 2c 0f				call Div16 
58b8 c5					push bc 
58b9 e1					pop hl 
58ba cd 23 20				call forth_push_numhl 
58bd					NEXTW 
58bd c3 d0 23			jp macro_next 
58c0				endm 
# End of macro NEXTW
58c0			.SCONST6: 
58c0				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58c0 6d				db WORD_SYS_CORE+89             
58c1 d9 58			dw .ENDSTORAGE            
58c3 09				db 8 + 1 
58c4 .. 00			db "READCONT",0              
58cd				endm 
# End of macro CWHEAD
58cd			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58cd			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58cd			; | | a further read should, if applicable, be CONCAT to the previous read. 
58cd			; | | > [!NOTE] 
58cd			; | | > Compatible with PicoSPINet  
58cd 3a a8 f9				ld a, (store_readcont) 
58d0 26 00				ld h, 0 
58d2 6f					ld l, a 
58d3 cd 23 20				call forth_push_numhl 
58d6					NEXTW 
58d6 c3 d0 23			jp macro_next 
58d9				endm 
# End of macro NEXTW
58d9			.ENDSTORAGE: 
58d9			; eof 
# End of file forth_words_storage.asm
58d9			endif 
58d9				include "forth_words_device.asm" 
58d9			; Device related words 
58d9			 
58d9			; | ## Device Words 
58d9			 
58d9			;if SOUND_ENABLE 
58d9			;.NOTE: 
58d9			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58d9			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
58d9			;		if DEBUG_FORTH_WORDS_KEY 
58d9			;			DMARK "NTE" 
58d9			;			CALLMONITOR 
58d9			;		endif 
58d9			; 
58d9			;	 
58d9			; 
58d9			;		NEXTW 
58d9			;.AFTERSOUND: 
58d9			;endif 
58d9			 
58d9			 
58d9			USE_GPIO: equ 0 
58d9			 
58d9			if USE_GPIO 
58d9			.GP1: 
58d9				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58d9			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
58d9					NEXTW 
58d9			.GP2: 
58d9				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58d9			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
58d9			 
58d9					NEXTW 
58d9			 
58d9			.GP3: 
58d9				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58d9			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
58d9			 
58d9					NEXTW 
58d9			 
58d9			.GP4: 
58d9				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58d9			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
58d9			 
58d9					NEXTW 
58d9			.SIN: 
58d9			 
58d9			 
58d9			endif 
58d9			 
58d9			 
58d9				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58d9 33				db WORD_SYS_CORE+31             
58da 0e 59			dw .SOUT            
58dc 03				db 2 + 1 
58dd .. 00			db "IN",0              
58e0				endm 
# End of macro CWHEAD
58e0			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58e0					if DEBUG_FORTH_WORDS_KEY 
58e0						DMARK "IN." 
58e0 f5				push af  
58e1 3a f5 58			ld a, (.dmark)  
58e4 32 a6 fd			ld (debug_mark),a  
58e7 3a f6 58			ld a, (.dmark+1)  
58ea 32 a7 fd			ld (debug_mark+1),a  
58ed 3a f7 58			ld a, (.dmark+2)  
58f0 32 a8 fd			ld (debug_mark+2),a  
58f3 18 03			jr .pastdmark  
58f5 ..			.dmark: db "IN."  
58f8 f1			.pastdmark: pop af  
58f9			endm  
# End of macro DMARK
58f9						CALLMONITOR 
58f9 cd aa fd			call debug_vector  
58fc				endm  
# End of macro CALLMONITOR
58fc					endif 
58fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58fc cd 1a 22			call macro_dsp_valuehl 
58ff				endm 
# End of macro FORTH_DSP_VALUEHL
58ff			 
58ff e5					push hl 
5900			 
5900					; destroy value TOS 
5900			 
5900					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5900 cd d2 22			call macro_forth_dsp_pop 
5903				endm 
# End of macro FORTH_DSP_POP
5903			 
5903					; one value on hl get other one back 
5903			 
5903 c1					pop bc 
5904			 
5904					; do the sub 
5904			;		ex de, hl 
5904			 
5904 ed 68				in l,(c) 
5906			 
5906					; save it 
5906			 
5906 26 00				ld h,0 
5908			 
5908					; TODO push value back onto stack for another op etc 
5908			 
5908 cd 23 20				call forth_push_numhl 
590b					NEXTW 
590b c3 d0 23			jp macro_next 
590e				endm 
# End of macro NEXTW
590e			.SOUT: 
590e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
590e 34				db WORD_SYS_CORE+32             
590f 61 59			dw .SPIO            
5911 04				db 3 + 1 
5912 .. 00			db "OUT",0              
5916				endm 
# End of macro CWHEAD
5916			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5916					if DEBUG_FORTH_WORDS_KEY 
5916						DMARK "OUT" 
5916 f5				push af  
5917 3a 2b 59			ld a, (.dmark)  
591a 32 a6 fd			ld (debug_mark),a  
591d 3a 2c 59			ld a, (.dmark+1)  
5920 32 a7 fd			ld (debug_mark+1),a  
5923 3a 2d 59			ld a, (.dmark+2)  
5926 32 a8 fd			ld (debug_mark+2),a  
5929 18 03			jr .pastdmark  
592b ..			.dmark: db "OUT"  
592e f1			.pastdmark: pop af  
592f			endm  
# End of macro DMARK
592f						CALLMONITOR 
592f cd aa fd			call debug_vector  
5932				endm  
# End of macro CALLMONITOR
5932					endif 
5932			 
5932					; get port 
5932			 
5932					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5932 cd 1a 22			call macro_dsp_valuehl 
5935				endm 
# End of macro FORTH_DSP_VALUEHL
5935			 
5935 e5					push hl 
5936			 
5936					; destroy value TOS 
5936			 
5936					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5936 cd d2 22			call macro_forth_dsp_pop 
5939				endm 
# End of macro FORTH_DSP_POP
5939			 
5939					; get byte to send 
5939			 
5939					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5939 cd 1a 22			call macro_dsp_valuehl 
593c				endm 
# End of macro FORTH_DSP_VALUEHL
593c			 
593c			;		push hl 
593c			 
593c					; destroy value TOS 
593c			 
593c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
593c cd d2 22			call macro_forth_dsp_pop 
593f				endm 
# End of macro FORTH_DSP_POP
593f			 
593f					; one value on hl get other one back 
593f			 
593f			;		pop hl 
593f			 
593f c1					pop bc 
5940			 
5940					if DEBUG_FORTH_WORDS 
5940						DMARK "OUT" 
5940 f5				push af  
5941 3a 55 59			ld a, (.dmark)  
5944 32 a6 fd			ld (debug_mark),a  
5947 3a 56 59			ld a, (.dmark+1)  
594a 32 a7 fd			ld (debug_mark+1),a  
594d 3a 57 59			ld a, (.dmark+2)  
5950 32 a8 fd			ld (debug_mark+2),a  
5953 18 03			jr .pastdmark  
5955 ..			.dmark: db "OUT"  
5958 f1			.pastdmark: pop af  
5959			endm  
# End of macro DMARK
5959						CALLMONITOR 
5959 cd aa fd			call debug_vector  
595c				endm  
# End of macro CALLMONITOR
595c					endif 
595c			 
595c ed 69				out (c), l 
595e			 
595e					NEXTW 
595e c3 d0 23			jp macro_next 
5961				endm 
# End of macro NEXTW
5961			 
5961			 
5961			.SPIO: 
5961			 
5961			if STORAGE_SE 
5961				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5961 51				db WORD_SYS_CORE+61             
5962 72 59			dw .SPICEH            
5964 07				db 6 + 1 
5965 .. 00			db "SPICEL",0              
596c				endm 
# End of macro CWHEAD
596c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
596c			 
596c cd 13 02				call spi_ce_low 
596f			    NEXTW 
596f c3 d0 23			jp macro_next 
5972				endm 
# End of macro NEXTW
5972			 
5972			.SPICEH: 
5972				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5972 51				db WORD_SYS_CORE+61             
5973 83 59			dw .SPIOb            
5975 07				db 6 + 1 
5976 .. 00			db "SPICEH",0              
597d				endm 
# End of macro CWHEAD
597d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
597d			 
597d cd 02 02				call spi_ce_high 
5980			    NEXTW 
5980 c3 d0 23			jp macro_next 
5983				endm 
# End of macro NEXTW
5983			 
5983			 
5983			.SPIOb: 
5983			 
5983				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5983 51				db WORD_SYS_CORE+61             
5984 b5 59			dw .SPII            
5986 05				db 4 + 1 
5987 .. 00			db "SPIO",0              
598c				endm 
# End of macro CWHEAD
598c			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
598c			 
598c					if DEBUG_FORTH_WORDS_KEY 
598c						DMARK "SPo" 
598c f5				push af  
598d 3a a1 59			ld a, (.dmark)  
5990 32 a6 fd			ld (debug_mark),a  
5993 3a a2 59			ld a, (.dmark+1)  
5996 32 a7 fd			ld (debug_mark+1),a  
5999 3a a3 59			ld a, (.dmark+2)  
599c 32 a8 fd			ld (debug_mark+2),a  
599f 18 03			jr .pastdmark  
59a1 ..			.dmark: db "SPo"  
59a4 f1			.pastdmark: pop af  
59a5			endm  
# End of macro DMARK
59a5						CALLMONITOR 
59a5 cd aa fd			call debug_vector  
59a8				endm  
# End of macro CALLMONITOR
59a8					endif 
59a8					; get port 
59a8			 
59a8			 
59a8					; get byte to send 
59a8			 
59a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59a8 cd 1a 22			call macro_dsp_valuehl 
59ab				endm 
# End of macro FORTH_DSP_VALUEHL
59ab			 
59ab			;		push hl    ; u1  
59ab			 
59ab					; destroy value TOS 
59ab			 
59ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59ab cd d2 22			call macro_forth_dsp_pop 
59ae				endm 
# End of macro FORTH_DSP_POP
59ae			 
59ae					; one value on hl get other one back 
59ae			 
59ae			;		pop hl   ; u2 - addr 
59ae			 
59ae					; TODO Send SPI byte 
59ae			 
59ae			;		push hl 
59ae			;		call spi_ce_low 
59ae			;		pop hl 
59ae 7d					ld a, l 
59af cd 01 01				call spi_send_byte 
59b2			;		call spi_ce_high 
59b2			 
59b2					NEXTW 
59b2 c3 d0 23			jp macro_next 
59b5				endm 
# End of macro NEXTW
59b5			 
59b5			.SPII: 
59b5				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59b5 52				db WORD_SYS_CORE+62             
59b6 1e 5a			dw .SESEL            
59b8 06				db 5 + 1 
59b9 .. 00			db "SPII",0              
59be				endm 
# End of macro CWHEAD
59be			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59be					if DEBUG_FORTH_WORDS_KEY 
59be						DMARK "SPi" 
59be f5				push af  
59bf 3a d3 59			ld a, (.dmark)  
59c2 32 a6 fd			ld (debug_mark),a  
59c5 3a d4 59			ld a, (.dmark+1)  
59c8 32 a7 fd			ld (debug_mark+1),a  
59cb 3a d5 59			ld a, (.dmark+2)  
59ce 32 a8 fd			ld (debug_mark+2),a  
59d1 18 03			jr .pastdmark  
59d3 ..			.dmark: db "SPi"  
59d6 f1			.pastdmark: pop af  
59d7			endm  
# End of macro DMARK
59d7						CALLMONITOR 
59d7 cd aa fd			call debug_vector  
59da				endm  
# End of macro CALLMONITOR
59da					endif 
59da			 
59da					; TODO Get SPI byte 
59da			 
59da cd 28 01				call spi_read_byte 
59dd			 
59dd					if DEBUG_FORTH_WORDS 
59dd						DMARK "Si2" 
59dd f5				push af  
59de 3a f2 59			ld a, (.dmark)  
59e1 32 a6 fd			ld (debug_mark),a  
59e4 3a f3 59			ld a, (.dmark+1)  
59e7 32 a7 fd			ld (debug_mark+1),a  
59ea 3a f4 59			ld a, (.dmark+2)  
59ed 32 a8 fd			ld (debug_mark+2),a  
59f0 18 03			jr .pastdmark  
59f2 ..			.dmark: db "Si2"  
59f5 f1			.pastdmark: pop af  
59f6			endm  
# End of macro DMARK
59f6						CALLMONITOR 
59f6 cd aa fd			call debug_vector  
59f9				endm  
# End of macro CALLMONITOR
59f9					endif 
59f9 26 00				ld h, 0 
59fb 6f					ld l, a 
59fc					if DEBUG_FORTH_WORDS 
59fc						DMARK "Si3" 
59fc f5				push af  
59fd 3a 11 5a			ld a, (.dmark)  
5a00 32 a6 fd			ld (debug_mark),a  
5a03 3a 12 5a			ld a, (.dmark+1)  
5a06 32 a7 fd			ld (debug_mark+1),a  
5a09 3a 13 5a			ld a, (.dmark+2)  
5a0c 32 a8 fd			ld (debug_mark+2),a  
5a0f 18 03			jr .pastdmark  
5a11 ..			.dmark: db "Si3"  
5a14 f1			.pastdmark: pop af  
5a15			endm  
# End of macro DMARK
5a15						CALLMONITOR 
5a15 cd aa fd			call debug_vector  
5a18				endm  
# End of macro CALLMONITOR
5a18					endif 
5a18 cd 23 20				call forth_push_numhl 
5a1b			 
5a1b					NEXTW 
5a1b c3 d0 23			jp macro_next 
5a1e				endm 
# End of macro NEXTW
5a1e			 
5a1e			 
5a1e			 
5a1e			.SESEL: 
5a1e				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a1e 66				db WORD_SYS_CORE+82             
5a1f c7 5a			dw .CARTDEV            
5a21 05				db 4 + 1 
5a22 .. 00			db "BANK",0              
5a27				endm 
# End of macro CWHEAD
5a27			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a27					if DEBUG_FORTH_WORDS_KEY 
5a27						DMARK "BNK" 
5a27 f5				push af  
5a28 3a 3c 5a			ld a, (.dmark)  
5a2b 32 a6 fd			ld (debug_mark),a  
5a2e 3a 3d 5a			ld a, (.dmark+1)  
5a31 32 a7 fd			ld (debug_mark+1),a  
5a34 3a 3e 5a			ld a, (.dmark+2)  
5a37 32 a8 fd			ld (debug_mark+2),a  
5a3a 18 03			jr .pastdmark  
5a3c ..			.dmark: db "BNK"  
5a3f f1			.pastdmark: pop af  
5a40			endm  
# End of macro DMARK
5a40						CALLMONITOR 
5a40 cd aa fd			call debug_vector  
5a43				endm  
# End of macro CALLMONITOR
5a43					endif 
5a43			 
5a43 3e ff				ld a, 255 
5a45 32 9e f9				ld (spi_cartdev), a 
5a48			 
5a48					; get bank 
5a48			 
5a48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a48 cd 1a 22			call macro_dsp_valuehl 
5a4b				endm 
# End of macro FORTH_DSP_VALUEHL
5a4b			 
5a4b			;		push hl 
5a4b			 
5a4b					; destroy value TOS 
5a4b			 
5a4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a4b cd d2 22			call macro_forth_dsp_pop 
5a4e				endm 
# End of macro FORTH_DSP_POP
5a4e			 
5a4e					; one value on hl get other one back 
5a4e			 
5a4e			;		pop hl 
5a4e			 
5a4e			 
5a4e 0e ff				ld c, SPI_CE_HIGH 
5a50 06 30				ld b, '0'    ; human readable bank number 
5a52			 
5a52 7d					ld a, l 
5a53			 
5a53					if DEBUG_FORTH_WORDS 
5a53						DMARK "BNK" 
5a53 f5				push af  
5a54 3a 68 5a			ld a, (.dmark)  
5a57 32 a6 fd			ld (debug_mark),a  
5a5a 3a 69 5a			ld a, (.dmark+1)  
5a5d 32 a7 fd			ld (debug_mark+1),a  
5a60 3a 6a 5a			ld a, (.dmark+2)  
5a63 32 a8 fd			ld (debug_mark+2),a  
5a66 18 03			jr .pastdmark  
5a68 ..			.dmark: db "BNK"  
5a6b f1			.pastdmark: pop af  
5a6c			endm  
# End of macro DMARK
5a6c						CALLMONITOR 
5a6c cd aa fd			call debug_vector  
5a6f				endm  
# End of macro CALLMONITOR
5a6f					endif 
5a6f			 
5a6f					; active low 
5a6f			 
5a6f fe 00				cp 0 
5a71 28 28				jr z, .bset 
5a73 fe 01				cp 1 
5a75 20 04				jr nz, .b2 
5a77 cb 81				res 0, c 
5a79 06 31				ld b, '1'    ; human readable bank number 
5a7b fe 02		.b2:		cp 2 
5a7d 20 04				jr nz, .b3 
5a7f cb 89				res 1, c 
5a81 06 32				ld b, '2'    ; human readable bank number 
5a83 fe 03		.b3:		cp 3 
5a85 20 04				jr nz, .b4 
5a87 cb 91				res 2, c 
5a89 06 33				ld b, '3'    ; human readable bank number 
5a8b fe 04		.b4:		cp 4 
5a8d 20 04				jr nz, .b5 
5a8f cb 99				res 3, c 
5a91 06 34				ld b, '4'    ; human readable bank number 
5a93 fe 05		.b5:		cp 5 
5a95 20 04				jr nz, .bset 
5a97 cb a1				res 4, c 
5a99 06 35				ld b, '5'    ; human readable bank number 
5a9b			 
5a9b			.bset: 
5a9b 79					ld a, c 
5a9c 32 9b f9				ld (spi_device),a 
5a9f 78					ld a, b 
5aa0 32 9a f9				ld (spi_device_id),a 
5aa3					if DEBUG_FORTH_WORDS 
5aa3						DMARK "BN2" 
5aa3 f5				push af  
5aa4 3a b8 5a			ld a, (.dmark)  
5aa7 32 a6 fd			ld (debug_mark),a  
5aaa 3a b9 5a			ld a, (.dmark+1)  
5aad 32 a7 fd			ld (debug_mark+1),a  
5ab0 3a ba 5a			ld a, (.dmark+2)  
5ab3 32 a8 fd			ld (debug_mark+2),a  
5ab6 18 03			jr .pastdmark  
5ab8 ..			.dmark: db "BN2"  
5abb f1			.pastdmark: pop af  
5abc			endm  
# End of macro DMARK
5abc						CALLMONITOR 
5abc cd aa fd			call debug_vector  
5abf				endm  
# End of macro CALLMONITOR
5abf					endif 
5abf			 
5abf					; set default SPI clk pulse time as disabled for BANK use 
5abf			 
5abf 3e 00				ld a, 0 
5ac1 32 9f f9				ld (spi_clktime), a 
5ac4			 
5ac4					NEXTW 
5ac4 c3 d0 23			jp macro_next 
5ac7				endm 
# End of macro NEXTW
5ac7			 
5ac7			.CARTDEV: 
5ac7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ac7 66				db WORD_SYS_CORE+82             
5ac8 75 5b			dw .ENDDEVICE            
5aca 08				db 7 + 1 
5acb .. 00			db "CARTDEV",0              
5ad3				endm 
# End of macro CWHEAD
5ad3			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5ad3					if DEBUG_FORTH_WORDS_KEY 
5ad3						DMARK "CDV" 
5ad3 f5				push af  
5ad4 3a e8 5a			ld a, (.dmark)  
5ad7 32 a6 fd			ld (debug_mark),a  
5ada 3a e9 5a			ld a, (.dmark+1)  
5add 32 a7 fd			ld (debug_mark+1),a  
5ae0 3a ea 5a			ld a, (.dmark+2)  
5ae3 32 a8 fd			ld (debug_mark+2),a  
5ae6 18 03			jr .pastdmark  
5ae8 ..			.dmark: db "CDV"  
5aeb f1			.pastdmark: pop af  
5aec			endm  
# End of macro DMARK
5aec						CALLMONITOR 
5aec cd aa fd			call debug_vector  
5aef				endm  
# End of macro CALLMONITOR
5aef					endif 
5aef			 
5aef					; disable se storage bank selection 
5aef			 
5aef 3e ff				ld a, SPI_CE_HIGH		; ce high 
5af1 32 9b f9				ld (spi_device), a 
5af4			 
5af4					; get bank 
5af4			 
5af4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5af4 cd 1a 22			call macro_dsp_valuehl 
5af7				endm 
# End of macro FORTH_DSP_VALUEHL
5af7			 
5af7			;		push hl 
5af7			 
5af7					; destroy value TOS 
5af7			 
5af7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5af7 cd d2 22			call macro_forth_dsp_pop 
5afa				endm 
# End of macro FORTH_DSP_POP
5afa			 
5afa					; one value on hl get other one back 
5afa			 
5afa			;		pop hl 
5afa			 
5afa					; active low 
5afa			 
5afa 0e ff				ld c, 255 
5afc			 
5afc 7d					ld a, l 
5afd					if DEBUG_FORTH_WORDS 
5afd						DMARK "CDV" 
5afd f5				push af  
5afe 3a 12 5b			ld a, (.dmark)  
5b01 32 a6 fd			ld (debug_mark),a  
5b04 3a 13 5b			ld a, (.dmark+1)  
5b07 32 a7 fd			ld (debug_mark+1),a  
5b0a 3a 14 5b			ld a, (.dmark+2)  
5b0d 32 a8 fd			ld (debug_mark+2),a  
5b10 18 03			jr .pastdmark  
5b12 ..			.dmark: db "CDV"  
5b15 f1			.pastdmark: pop af  
5b16			endm  
# End of macro DMARK
5b16						CALLMONITOR 
5b16 cd aa fd			call debug_vector  
5b19				endm  
# End of macro CALLMONITOR
5b19					endif 
5b19 fe 00				cp 0 
5b1b 28 30				jr z, .cset 
5b1d fe 01				cp 1 
5b1f 20 02				jr nz, .c2 
5b21 cb 81				res 0, c 
5b23 fe 02		.c2:		cp 2 
5b25 20 02				jr nz, .c3 
5b27 cb 89				res 1, c 
5b29 fe 03		.c3:		cp 3 
5b2b 20 02				jr nz, .c4 
5b2d cb 91				res 2, c 
5b2f fe 04		.c4:		cp 4 
5b31 20 02				jr nz, .c5 
5b33 cb 99				res 3, c 
5b35 fe 05		.c5:		cp 5 
5b37 20 02				jr nz, .c6 
5b39 cb a1				res 4, c 
5b3b fe 06		.c6:		cp 6 
5b3d 20 02				jr nz, .c7 
5b3f cb a9				res 5, c 
5b41 fe 07		.c7:		cp 7 
5b43 20 02				jr nz, .c8 
5b45 cb b1				res 6, c 
5b47 fe 08		.c8:		cp 8 
5b49 20 02				jr nz, .cset 
5b4b cb b9				res 7, c 
5b4d 79			.cset:		ld a, c 
5b4e 32 9e f9				ld (spi_cartdev),a 
5b51			 
5b51					if DEBUG_FORTH_WORDS 
5b51						DMARK "CD2" 
5b51 f5				push af  
5b52 3a 66 5b			ld a, (.dmark)  
5b55 32 a6 fd			ld (debug_mark),a  
5b58 3a 67 5b			ld a, (.dmark+1)  
5b5b 32 a7 fd			ld (debug_mark+1),a  
5b5e 3a 68 5b			ld a, (.dmark+2)  
5b61 32 a8 fd			ld (debug_mark+2),a  
5b64 18 03			jr .pastdmark  
5b66 ..			.dmark: db "CD2"  
5b69 f1			.pastdmark: pop af  
5b6a			endm  
# End of macro DMARK
5b6a						CALLMONITOR 
5b6a cd aa fd			call debug_vector  
5b6d				endm  
# End of macro CALLMONITOR
5b6d					endif 
5b6d			 
5b6d					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b6d			 
5b6d 3e 0a				ld a, $0a 
5b6f 32 9f f9				ld (spi_clktime), a 
5b72					NEXTW 
5b72 c3 d0 23			jp macro_next 
5b75				endm 
# End of macro NEXTW
5b75			endif 
5b75			 
5b75			.ENDDEVICE: 
5b75			; eof 
5b75			 
# End of file forth_words_device.asm
5b75			 
5b75			; var handler 
5b75			 
5b75			 
5b75			.VARS: 
5b75				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b75 77				db WORD_SYS_CORE+99             
5b76 26 5c			dw .V0            
5b78 04				db 3 + 1 
5b79 .. 00			db "VAR",0              
5b7d				endm 
# End of macro CWHEAD
5b7d			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b7d			;| 
5b7d			;| The variable name should consist of a single letter. e.g. "a" 
5b7d			;! If a full string is passed then only the first char is looked at 
5b7d			;| Any other char could exceed bounds checks!  
5b7d			 
5b7d					if DEBUG_FORTH_WORDS_KEY 
5b7d						DMARK "VAR" 
5b7d f5				push af  
5b7e 3a 92 5b			ld a, (.dmark)  
5b81 32 a6 fd			ld (debug_mark),a  
5b84 3a 93 5b			ld a, (.dmark+1)  
5b87 32 a7 fd			ld (debug_mark+1),a  
5b8a 3a 94 5b			ld a, (.dmark+2)  
5b8d 32 a8 fd			ld (debug_mark+2),a  
5b90 18 03			jr .pastdmark  
5b92 ..			.dmark: db "VAR"  
5b95 f1			.pastdmark: pop af  
5b96			endm  
# End of macro DMARK
5b96						CALLMONITOR 
5b96 cd aa fd			call debug_vector  
5b99				endm  
# End of macro CALLMONITOR
5b99					endif 
5b99			 
5b99					FORTH_DSP_VALUEHL 
5b99 cd 1a 22			call macro_dsp_valuehl 
5b9c				endm 
# End of macro FORTH_DSP_VALUEHL
5b9c			 
5b9c 7e					ld a, (hl)    ; get first char on of the string 
5b9d			 
5b9d			 
5b9d					if DEBUG_FORTH_WORDS 
5b9d						DMARK "VR1" 
5b9d f5				push af  
5b9e 3a b2 5b			ld a, (.dmark)  
5ba1 32 a6 fd			ld (debug_mark),a  
5ba4 3a b3 5b			ld a, (.dmark+1)  
5ba7 32 a7 fd			ld (debug_mark+1),a  
5baa 3a b4 5b			ld a, (.dmark+2)  
5bad 32 a8 fd			ld (debug_mark+2),a  
5bb0 18 03			jr .pastdmark  
5bb2 ..			.dmark: db "VR1"  
5bb5 f1			.pastdmark: pop af  
5bb6			endm  
# End of macro DMARK
5bb6						CALLMONITOR 
5bb6 cd aa fd			call debug_vector  
5bb9				endm  
# End of macro CALLMONITOR
5bb9					endif 
5bb9					 
5bb9 f5					push af	 
5bba					FORTH_DSP_POP 
5bba cd d2 22			call macro_forth_dsp_pop 
5bbd				endm 
# End of macro FORTH_DSP_POP
5bbd f1					pop af 
5bbe			 
5bbe					; convert to upper 
5bbe			 
5bbe cd 44 12				call to_upper 
5bc1					if DEBUG_FORTH_WORDS 
5bc1						DMARK "Vaa" 
5bc1 f5				push af  
5bc2 3a d6 5b			ld a, (.dmark)  
5bc5 32 a6 fd			ld (debug_mark),a  
5bc8 3a d7 5b			ld a, (.dmark+1)  
5bcb 32 a7 fd			ld (debug_mark+1),a  
5bce 3a d8 5b			ld a, (.dmark+2)  
5bd1 32 a8 fd			ld (debug_mark+2),a  
5bd4 18 03			jr .pastdmark  
5bd6 ..			.dmark: db "Vaa"  
5bd9 f1			.pastdmark: pop af  
5bda			endm  
# End of macro DMARK
5bda						CALLMONITOR 
5bda cd aa fd			call debug_vector  
5bdd				endm  
# End of macro CALLMONITOR
5bdd					endif 
5bdd 06 41				ld b, 'A' 
5bdf 90					sub b			; set offset 
5be0					if DEBUG_FORTH_WORDS 
5be0						DMARK "Vbb" 
5be0 f5				push af  
5be1 3a f5 5b			ld a, (.dmark)  
5be4 32 a6 fd			ld (debug_mark),a  
5be7 3a f6 5b			ld a, (.dmark+1)  
5bea 32 a7 fd			ld (debug_mark+1),a  
5bed 3a f7 5b			ld a, (.dmark+2)  
5bf0 32 a8 fd			ld (debug_mark+2),a  
5bf3 18 03			jr .pastdmark  
5bf5 ..			.dmark: db "Vbb"  
5bf8 f1			.pastdmark: pop af  
5bf9			endm  
# End of macro DMARK
5bf9						CALLMONITOR 
5bf9 cd aa fd			call debug_vector  
5bfc				endm  
# End of macro CALLMONITOR
5bfc					endif 
5bfc cb 27				sla a  
5bfe				 
5bfe					 
5bfe					if DEBUG_FORTH_WORDS 
5bfe						DMARK "VR2" 
5bfe f5				push af  
5bff 3a 13 5c			ld a, (.dmark)  
5c02 32 a6 fd			ld (debug_mark),a  
5c05 3a 14 5c			ld a, (.dmark+1)  
5c08 32 a7 fd			ld (debug_mark+1),a  
5c0b 3a 15 5c			ld a, (.dmark+2)  
5c0e 32 a8 fd			ld (debug_mark+2),a  
5c11 18 03			jr .pastdmark  
5c13 ..			.dmark: db "VR2"  
5c16 f1			.pastdmark: pop af  
5c17			endm  
# End of macro DMARK
5c17						CALLMONITOR 
5c17 cd aa fd			call debug_vector  
5c1a				endm  
# End of macro CALLMONITOR
5c1a					endif 
5c1a			 
5c1a 21 2f f9				ld hl, cli_var_array2 
5c1d cd cf 0f				call addatohl 
5c20 cd 23 20				call forth_push_numhl 
5c23			 
5c23			 
5c23				       NEXTW 
5c23 c3 d0 23			jp macro_next 
5c26				endm 
# End of macro NEXTW
5c26			.V0: 
5c26				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c26 78				db WORD_SYS_CORE+100             
5c27 3e 5c			dw .V0Q            
5c29 04				db 3 + 1 
5c2a .. 00			db "V0!",0              
5c2e				endm 
# End of macro CWHEAD
5c2e			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c2e			 
5c2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c2e cd 1a 22			call macro_dsp_valuehl 
5c31				endm 
# End of macro FORTH_DSP_VALUEHL
5c31			 
5c31 11 63 f9				ld de, cli_var_array 
5c34			 
5c34 eb					ex de, hl 
5c35 73					ld (hl), e 
5c36 23					inc hl 
5c37 72					ld (hl), d 
5c38			 
5c38					; destroy value TOS 
5c38			 
5c38					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c38 cd d2 22			call macro_forth_dsp_pop 
5c3b				endm 
# End of macro FORTH_DSP_POP
5c3b			 
5c3b				       NEXTW 
5c3b c3 d0 23			jp macro_next 
5c3e				endm 
# End of macro NEXTW
5c3e			.V0Q: 
5c3e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c3e 79				db WORD_SYS_CORE+101             
5c3f 4f 5c			dw .V1S            
5c41 04				db 3 + 1 
5c42 .. 00			db "V0@",0              
5c46				endm 
# End of macro CWHEAD
5c46			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c46 2a 63 f9				ld hl, (cli_var_array) 
5c49 cd 23 20				call forth_push_numhl 
5c4c			 
5c4c				       NEXTW 
5c4c c3 d0 23			jp macro_next 
5c4f				endm 
# End of macro NEXTW
5c4f			.V1S: 
5c4f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c4f 7a				db WORD_SYS_CORE+102             
5c50 67 5c			dw .V1Q            
5c52 04				db 3 + 1 
5c53 .. 00			db "V1!",0              
5c57				endm 
# End of macro CWHEAD
5c57			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c57 cd 1a 22			call macro_dsp_valuehl 
5c5a				endm 
# End of macro FORTH_DSP_VALUEHL
5c5a			 
5c5a 11 65 f9				ld de, cli_var_array+2 
5c5d				 
5c5d eb					ex de, hl 
5c5e 73					ld (hl), e 
5c5f 23					inc hl 
5c60 72					ld (hl), d 
5c61			 
5c61					; destroy value TOS 
5c61			 
5c61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c61 cd d2 22			call macro_forth_dsp_pop 
5c64				endm 
# End of macro FORTH_DSP_POP
5c64				       NEXTW 
5c64 c3 d0 23			jp macro_next 
5c67				endm 
# End of macro NEXTW
5c67			.V1Q: 
5c67				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c67 7b				db WORD_SYS_CORE+103             
5c68 78 5c			dw .V2S            
5c6a 04				db 3 + 1 
5c6b .. 00			db "V1@",0              
5c6f				endm 
# End of macro CWHEAD
5c6f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c6f 2a 65 f9				ld hl, (cli_var_array+2) 
5c72 cd 23 20				call forth_push_numhl 
5c75				       NEXTW 
5c75 c3 d0 23			jp macro_next 
5c78				endm 
# End of macro NEXTW
5c78			.V2S: 
5c78				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c78 7c				db WORD_SYS_CORE+104             
5c79 90 5c			dw .V2Q            
5c7b 04				db 3 + 1 
5c7c .. 00			db "V2!",0              
5c80				endm 
# End of macro CWHEAD
5c80			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c80 cd 1a 22			call macro_dsp_valuehl 
5c83				endm 
# End of macro FORTH_DSP_VALUEHL
5c83			 
5c83 11 67 f9				ld de, cli_var_array+4 
5c86				 
5c86 eb					ex de, hl 
5c87 73					ld (hl), e 
5c88 23					inc hl 
5c89 72					ld (hl), d 
5c8a			 
5c8a					; destroy value TOS 
5c8a			 
5c8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c8a cd d2 22			call macro_forth_dsp_pop 
5c8d				endm 
# End of macro FORTH_DSP_POP
5c8d				       NEXTW 
5c8d c3 d0 23			jp macro_next 
5c90				endm 
# End of macro NEXTW
5c90			.V2Q: 
5c90				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5c90 7d				db WORD_SYS_CORE+105             
5c91 a1 5c			dw .V3S            
5c93 04				db 3 + 1 
5c94 .. 00			db "V2@",0              
5c98				endm 
# End of macro CWHEAD
5c98			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5c98 2a 67 f9				ld hl, (cli_var_array+4) 
5c9b cd 23 20				call forth_push_numhl 
5c9e				       NEXTW 
5c9e c3 d0 23			jp macro_next 
5ca1				endm 
# End of macro NEXTW
5ca1			.V3S: 
5ca1				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5ca1 7c				db WORD_SYS_CORE+104             
5ca2 b9 5c			dw .V3Q            
5ca4 04				db 3 + 1 
5ca5 .. 00			db "V3!",0              
5ca9				endm 
# End of macro CWHEAD
5ca9			;| V3! ( u1 -- )  Store value to v3 | DONE 
5ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ca9 cd 1a 22			call macro_dsp_valuehl 
5cac				endm 
# End of macro FORTH_DSP_VALUEHL
5cac			 
5cac 11 69 f9				ld de, cli_var_array+6 
5caf				 
5caf eb					ex de, hl 
5cb0 73					ld (hl), e 
5cb1 23					inc hl 
5cb2 72					ld (hl), d 
5cb3			 
5cb3					; destroy value TOS 
5cb3			 
5cb3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cb3 cd d2 22			call macro_forth_dsp_pop 
5cb6				endm 
# End of macro FORTH_DSP_POP
5cb6				       NEXTW 
5cb6 c3 d0 23			jp macro_next 
5cb9				endm 
# End of macro NEXTW
5cb9			.V3Q: 
5cb9				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cb9 7d				db WORD_SYS_CORE+105             
5cba ca 5c			dw .END            
5cbc 04				db 3 + 1 
5cbd .. 00			db "V3@",0              
5cc1				endm 
# End of macro CWHEAD
5cc1			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cc1 2a 69 f9				ld hl, (cli_var_array+6) 
5cc4 cd 23 20				call forth_push_numhl 
5cc7				       NEXTW 
5cc7 c3 d0 23			jp macro_next 
5cca				endm 
# End of macro NEXTW
5cca			 
5cca			 
5cca			 
5cca			 
5cca			 
5cca			; end of dict marker 
5cca			 
5cca 00			.END:    db WORD_SYS_END 
5ccb 00 00			dw 0 
5ccd 00				db 0 
5cce			 
5cce			; use to jp here for user dict words to save on macro expansion  
5cce			 
5cce			user_dict_next: 
5cce				NEXTW 
5cce c3 d0 23			jp macro_next 
5cd1				endm 
# End of macro NEXTW
5cd1			 
5cd1			 
5cd1			user_exec: 
5cd1				;    ld hl, <word code> 
5cd1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cd1				;    call forthexec 
5cd1				;    jp user_dict_next   (NEXT) 
5cd1			        ;    <word code bytes> 
5cd1 eb				ex de, hl 
5cd2 2a fd f3			ld hl,(os_tok_ptr) 
5cd5				 
5cd5				FORTH_RSP_NEXT 
5cd5 cd ca 1f			call macro_forth_rsp_next 
5cd8				endm 
# End of macro FORTH_RSP_NEXT
5cd8			 
5cd8			if DEBUG_FORTH_UWORD 
5cd8						DMARK "UEX" 
5cd8 f5				push af  
5cd9 3a ed 5c			ld a, (.dmark)  
5cdc 32 a6 fd			ld (debug_mark),a  
5cdf 3a ee 5c			ld a, (.dmark+1)  
5ce2 32 a7 fd			ld (debug_mark+1),a  
5ce5 3a ef 5c			ld a, (.dmark+2)  
5ce8 32 a8 fd			ld (debug_mark+2),a  
5ceb 18 03			jr .pastdmark  
5ced ..			.dmark: db "UEX"  
5cf0 f1			.pastdmark: pop af  
5cf1			endm  
# End of macro DMARK
5cf1				CALLMONITOR 
5cf1 cd aa fd			call debug_vector  
5cf4				endm  
# End of macro CALLMONITOR
5cf4			endif 
5cf4			 
5cf4			 
5cf4			 
5cf4 eb				ex de, hl 
5cf5 22 fd f3			ld (os_tok_ptr), hl 
5cf8				 
5cf8				; Don't use next - Skips the first word in uword. 
5cf8			 
5cf8 c3 61 24			jp exec1 
5cfb			;	NEXT 
5cfb			 
5cfb			 
5cfb			; eof 
# End of file forth_wordsv4.asm
5cfb			endif 
5cfb			;;;;;;;;;;;;;; Debug code 
5cfb			 
5cfb			 
5cfb			;if DEBUG_FORTH_PARSE 
5cfb .. 00		.nowordfound: db "No match",0 
5d04 .. 00		.compword:	db "Comparing word ",0 
5d14 .. 00		.nextwordat:	db "Next word at",0 
5d21 .. 00		.charmatch:	db "Char match",0 
5d2c			;endif 
5d2c			if DEBUG_FORTH_JP 
5d2c			.foundword:	db "Word match. Exec..",0 
5d2c			endif 
5d2c			;if DEBUG_FORTH_PUSH 
5d2c .. 00		.enddict:	db "Dict end. Push.",0 
5d3c .. 00		.push_str:	db "Pushing string",0 
5d4b .. 00		.push_num:	db "Pushing number",0 
5d5a .. 00		.data_sp:	db "SP:",0 
5d5e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d70 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d82 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5d94			;endif 
5d94			;if DEBUG_FORTH_MALLOC 
5d94 .. 00		.push_malloc:	db "Malloc address",0 
5da3			;endif 
5da3			 
5da3			 
5da3			 
5da3			; display malloc address and current data stack pointer  
5da3			 
5da3			malloc_error: 
5da3 d5				push de 
5da4 f5				push af 
5da5 e5				push hl 
5da6 cd 9b 0d			call clear_display 
5da9 11 c9 5d			ld de, .mallocerr 
5dac 3e 00			ld a,0 
5dae			;	ld de,os_word_scratch 
5dae cd ae 0d			call str_at_display 
5db1 3e 11			ld a, display_row_1+17 
5db3 11 a6 fd			ld de, debug_mark 
5db6 cd ae 0d			call str_at_display 
5db9 cd be 0d			call update_display 
5dbc				;call break_point_state 
5dbc cd 90 72			call cin_wait 
5dbf			 
5dbf			;	ld a, ' ' 
5dbf			;	ld (os_view_disable), a 
5dbf cd 38 19			call bp_on 
5dc2 e1				pop hl 
5dc3 f1				pop af 
5dc4 d1				pop de	 
5dc5				CALLMONITOR 
5dc5 cd aa fd			call debug_vector  
5dc8				endm  
# End of macro CALLMONITOR
5dc8 c9				ret 
5dc9			 
5dc9 .. 00		.mallocerr: 	db "Malloc Error",0 
5dd6			;if DEBUG_FORTH_PUSH 
5dd6			display_data_sp: 
5dd6 f5				push af 
5dd7			 
5dd7				; see if disabled 
5dd7			 
5dd7			 
5dd7 3a aa fd			ld a, (debug_vector) 
5dda fe c9			cp $C9  ; RET 
5ddc				;ld a, (os_view_disable) 
5ddc				;cp '*' 
5ddc 28 67			jr z, .skipdsp 
5dde			 
5dde e5				push hl 
5ddf e5				push hl 
5de0 e5			push hl 
5de1 cd 9b 0d			call clear_display 
5de4 e1			pop hl 
5de5 7c				ld a,h 
5de6 21 01 f4			ld hl, os_word_scratch 
5de9 cd d8 11			call hexout 
5dec e1				pop hl 
5ded 7d				ld a,l 
5dee 21 03 f4			ld hl, os_word_scratch+2 
5df1 cd d8 11			call hexout 
5df4 21 05 f4			ld hl, os_word_scratch+4 
5df7 3e 00			ld a,0 
5df9 77				ld (hl),a 
5dfa 11 01 f4			ld de,os_word_scratch 
5dfd 3e 28				ld a, display_row_2 
5dff cd ae 0d				call str_at_display 
5e02 11 5e 5d			ld de, .wordinhl 
5e05 3e 00			ld a, display_row_1 
5e07			 
5e07 cd ae 0d				call str_at_display 
5e0a 11 a6 fd			ld de, debug_mark 
5e0d 3e 11			ld a, display_row_1+17 
5e0f			 
5e0f cd ae 0d				call str_at_display 
5e12			 
5e12				; display current data stack pointer 
5e12 11 5a 5d			ld de,.data_sp 
5e15 3e 30				ld a, display_row_2 + 8 
5e17 cd ae 0d				call str_at_display 
5e1a			 
5e1a 2a 29 f9			ld hl,(cli_data_sp) 
5e1d e5				push hl 
5e1e 7c				ld a,h 
5e1f 21 01 f4			ld hl, os_word_scratch 
5e22 cd d8 11			call hexout 
5e25 e1				pop hl 
5e26 7d				ld a,l 
5e27 21 03 f4			ld hl, os_word_scratch+2 
5e2a cd d8 11			call hexout 
5e2d 21 05 f4			ld hl, os_word_scratch+4 
5e30 3e 00			ld a,0 
5e32 77				ld (hl),a 
5e33 11 01 f4			ld de,os_word_scratch 
5e36 3e 33				ld a, display_row_2 + 11 
5e38 cd ae 0d				call str_at_display 
5e3b			 
5e3b			 
5e3b cd be 0d			call update_display 
5e3e cd de 0c			call delay1s 
5e41 cd de 0c			call delay1s 
5e44 e1				pop hl 
5e45			.skipdsp: 
5e45 f1				pop af 
5e46 c9				ret 
5e47			 
5e47			display_data_malloc: 
5e47			 
5e47 f5				push af 
5e48 e5				push hl 
5e49 e5				push hl 
5e4a e5			push hl 
5e4b cd 9b 0d			call clear_display 
5e4e e1			pop hl 
5e4f 7c				ld a,h 
5e50 21 01 f4			ld hl, os_word_scratch 
5e53 cd d8 11			call hexout 
5e56 e1				pop hl 
5e57 7d				ld a,l 
5e58 21 03 f4			ld hl, os_word_scratch+2 
5e5b cd d8 11			call hexout 
5e5e 21 05 f4			ld hl, os_word_scratch+4 
5e61 3e 00			ld a,0 
5e63 77				ld (hl),a 
5e64 11 01 f4			ld de,os_word_scratch 
5e67 3e 28				ld a, display_row_2 
5e69 cd ae 0d				call str_at_display 
5e6c 11 94 5d			ld de, .push_malloc 
5e6f 3e 00			ld a, display_row_1 
5e71			 
5e71 cd ae 0d				call str_at_display 
5e74			 
5e74				; display current data stack pointer 
5e74 11 5a 5d			ld de,.data_sp 
5e77 3e 30				ld a, display_row_2 + 8 
5e79 cd ae 0d				call str_at_display 
5e7c			 
5e7c 2a 29 f9			ld hl,(cli_data_sp) 
5e7f e5				push hl 
5e80 7c				ld a,h 
5e81 21 01 f4			ld hl, os_word_scratch 
5e84 cd d8 11			call hexout 
5e87 e1				pop hl 
5e88 7d				ld a,l 
5e89 21 03 f4			ld hl, os_word_scratch+2 
5e8c cd d8 11			call hexout 
5e8f 21 05 f4			ld hl, os_word_scratch+4 
5e92 3e 00			ld a,0 
5e94 77				ld (hl),a 
5e95 11 01 f4			ld de,os_word_scratch 
5e98 3e 33				ld a, display_row_2 + 11 
5e9a cd ae 0d				call str_at_display 
5e9d			 
5e9d cd be 0d			call update_display 
5ea0 cd de 0c			call delay1s 
5ea3 cd de 0c			call delay1s 
5ea6 e1				pop hl 
5ea7 f1				pop af 
5ea8 c9				ret 
5ea9			;endif 
5ea9			 
5ea9			include "forth_autostart.asm" 
5ea9			; list of commands to perform at system start up 
5ea9			 
5ea9			startcmds: 
5ea9			;	dw test11 
5ea9			;	dw test12 
5ea9			;	dw test13 
5ea9			;	dw test14 
5ea9			;	dw test15 
5ea9			;	dw test16 
5ea9			;	dw test17 
5ea9			;	dw ifthtest1 
5ea9			;	dw ifthtest2 
5ea9			;	dw ifthtest3 
5ea9			;	dw mmtest1 
5ea9			;	dw mmtest2 
5ea9			;	dw mmtest3 
5ea9			;	dw mmtest4 
5ea9			;	dw mmtest5 
5ea9			;	dw mmtest6 
5ea9			;	dw iftest1 
5ea9			;	dw iftest2 
5ea9			;	dw iftest3 
5ea9			;	dw looptest1 
5ea9			;	dw looptest2 
5ea9			;	dw test1 
5ea9			;	dw test2 
5ea9			;	dw test3 
5ea9			;	dw test4 
5ea9			;	dw game2r 
5ea9			;	dw game2b1 
5ea9			;	dw game2b2 
5ea9			 
5ea9				; start up words that are actually useful 
5ea9			 
5ea9			;    dw spi1 
5ea9			;    dw spi2 
5ea9			;    dw spi3 
5ea9			;    dw spi4 
5ea9			;    dw spi5 
5ea9			;    dw spi6 
5ea9			;    dw spi7 
5ea9			; 
5ea9			;    dw spi8 
5ea9			;    dw spi9 
5ea9			;    dw spi10 
5ea9			 
5ea9			; file editor 
5ea9			;	dw edit1 
5ea9			;	dw edit2 
5ea9			;	dw edit3 
5ea9			 
5ea9			;	dw longread 
5ea9 c9 62			dw clrstack 
5eab fd 62			dw type 
5ead			;	dw stest 
5ead 22 63			dw strncpy 
5eaf			;	dw list 
5eaf 83 63			dw start1 
5eb1 93 63			dw start2 
5eb3			;	dw start3 
5eb3			;	dw start3b 
5eb3			;	dw start3c 
5eb3			 
5eb3				; (unit) testing words 
5eb3			 
5eb3			;	dw mtesta 
5eb3			;	dw mtestb 
5eb3			;	dw mtestc 
5eb3			;	dw mtestd 
5eb3			;	dw mteste 
5eb3			 
5eb3				; demo/game words 
5eb3			 
5eb3			;        dw game3w 
5eb3			;        dw game3p 
5eb3			;        dw game3sc 
5eb3			;        dw game3vsi 
5eb3			;        dw game3vs 
5eb3				 
5eb3			;	dw game2b 
5eb3			;	dw game2bf 
5eb3			;	dw game2mba 
5eb3			;	dw game2mbas 
5eb3			;	dw game2mb 
5eb3			 
5eb3 b0 66			dw game1 
5eb5 c1 66			dw game1a 
5eb7 23 67			dw game1b 
5eb9 58 67			dw game1c 
5ebb 8e 67			dw game1d 
5ebd bf 67			dw game1s 
5ebf d3 67			dw game1t 
5ec1 e8 67			dw game1f 
5ec3 1c 68			dw game1z 
5ec5 60 68			dw game1zz 
5ec7			 
5ec7 e9 64			dw test5 
5ec9 21 65			dw test6 
5ecb 59 65			dw test7 
5ecd 6d 65			dw test8 
5ecf 99 65			dw test9 
5ed1 af 65			dw test10 
5ed3				 
5ed3 37 69		        dw ssv5 
5ed5 1b 69		        dw ssv4 
5ed7 ff 68		        dw ssv3 
5ed9 c9 68		        dw ssv2 
5edb 50 69		        dw ssv1 
5edd 98 69		        dw ssv1cpm 
5edf			;	dw keyup 
5edf			;	dw keydown 
5edf			;	dw keyleft 
5edf			;	dw keyright 
5edf			;	dw 	keyf1 
5edf			;	dw keyf2 
5edf			;	dw keyf3 
5edf			;	dw keyf4 
5edf			;	dw keyf5 
5edf			;	dw keyf6 
5edf			;	dw keyf7 
5edf			;	dw keyf8 
5edf			;	dw keyf9 
5edf			;	dw keyf10 
5edf			;	dw keyf11 
5edf			;	dw keyf12 
5edf			;	dw keytab 
5edf			;	dw keycr 
5edf			;	dw keyhome 
5edf			;	dw keyend 
5edf			;	dw keybs 
5edf 00 00			db 0, 0	 
5ee1			 
5ee1			 
5ee1			; File Editor 
5ee1			 
5ee1			; ( id - ) use 'e' to edit the displayed line 
5ee1 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f02 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f37			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f37 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f6f			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f6f			 
5f6f			; SPI Net support words 
5f6f			 
5f6f			; v0! = node to send to 
5f6f			; ( str count - ) 
5f6f .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5fc8			 
5fc8			; spiputc ( char node - ) 
5fc8 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
5ffc			; spiputc ( u node - ) 
5ffc .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
602a			 
602a			; spigetc ( - n ) 
602a .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6053			 
6053			; getnode ( - n ) 
6053 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6080			 
6080			; ( str node - )  
6080 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
60e6			; store string ( str i - ) 
60e6			 
60e6			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
60e6 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
613b			 
613b			; get string ( addr i -  )    TO FIX 
613b			 
613b .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6193			 
6193			 
6193			; NETCHAT (TODO) 
6193			; Program to allow two nodes to chat with eachother 
6193			; 
6193			; v0 - target node 
6193			;  
6193			; accept input at 0,0 
6193			; if input is string send spitype to target node 
6193			; starting at row 2,0 , while spigetchr is not zero ->  
6193			; 
6193			; 
6193			; TODO add paging of get request 
6193			 
6193			; ( node - ) 
6193 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61b2 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
620a .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6282			 
6282			 
6282			; Long read of currently open file 
6282 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62c9			 
62c9			; clear stack  
62c9			 
62c9 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
62fd			 
62fd			; type ( addr count - ) 
62fd .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6322			 
6322			; some direct memory words 
6322			; strncpy ( len t f -- t ) 
6322			 
6322 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6383			 
6383 .. 00		start1:     	db ": bpon $00 bp ;",0 
6393 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63a4 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
641f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
647f			 
647f			 
647f			; a handy word to list items on the stack 
647f			 
647f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
64e9			 
64e9			 
64e9			; test stack  
64e9			; rnd8 stest 
64e9			 
64e9			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
64e9			 
64e9			; random malloc and free cycles 
64e9			 
64e9			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
64e9			 
64e9			; fixed malloc and free cycles 
64e9			 
64e9			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
64e9			 
64e9			; fixed double string push and drop cycle  
64e9			 
64e9			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
64e9			 
64e9			; consistent fixed string push and drop cycle  
64e9			 
64e9			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
64e9			 
64e9			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
64e9			 
64e9			;test1:		db ": aa 1 2 3 ;", 0 
64e9			;test2:     	db "111 aa 888 999",0 
64e9			;test3:     	db ": bb 77 ;",0 
64e9			;test4:     	db "$02 $01 do i . loop bb",0 
64e9			 
64e9 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6521 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6559 .. 00		test7:     	db ": box hline vline ;",0 
656d .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6599 .. 00		test9:     	db ": sw $01 adsp world ;",0 
65af .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
65d4			;test11:     	db "hello create .",0 
65d4			;test12:     	db "hello2 create .",0 
65d4			 
65d4			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
65d4			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
65d4			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
65d4			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
65d4			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
65d4			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
65d4			 
65d4			;iftest1:     	db "$0001 IF cls .",0 
65d4			;iftest2:     	db "$0000 IF cls .",0 
65d4			;iftest3:     	db "$0002 $0003 - IF cls .",0 
65d4			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
65d4			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
65d4			 
65d4			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65d4			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65d4			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65d4			 
65d4			 
65d4 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
65f8 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6628 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
664d .. 00		sound4: db ": cha $00 ; ",0 
665a .. 00		sound5: db ": chb $20 ; ",0 
6667 .. 00		sound6: db ": chc $40 ; ",0 
6674 .. 00		sound7: db ": chd $60 ; ",0 
6681 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6699 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
66b0			 
66b0			 
66b0			 
66b0			 
66b0			; a small guess the number game 
66b0			 
66b0 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
66c1 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6723			 
6723 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6758 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
678e .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
67bf .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
67d3 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
67e8 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
681c .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6860			 
6860			; Using 'ga' save a high score across multiple runs using external storage 
6860			 
6860 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
68c9			 
68c9			 
68c9			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
68c9			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
68c9			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
68c9			 
68c9			; simple screen saver to test code memory reuse to destruction 
68c9			 
68c9 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
68ff .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
691b .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6937 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6950 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6998 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
69ef			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
69ef			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
69ef			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
69ef			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
69ef			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
69ef			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
69ef			 
69ef			 
69ef			 
69ef			; minesweeper/battleship finding game 
69ef			; draws a game board of random ship/mine positions 
69ef			; user enters coords to see if it hits on 
69ef			; game ends when all are hit 
69ef			; when hit or miss says how many may be in the area 
69ef			 
69ef			; setup the game board and then hide it 
69ef			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
69ef			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
69ef			;; prompt for where to target 
69ef			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
69ef			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
69ef			;; TODO see if the entered coords hits or misses pushes char hit of miss 
69ef			;game2mbht:      db ": mbckht nop ;",0 
69ef			;game2mbms:      db ": mbcms nop ;",0 
69ef			; TODO how many might be near by 
69ef			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
69ef			 
69ef			; Game 3 
69ef			 
69ef			; Vert scroller ski game - avoid the trees! 
69ef			 
69ef			; v0 score (ie turns) 
69ef			; v1 player pos 
69ef			; v2 left wall 
69ef			; v3 right wall 
69ef			 
69ef			; Draw side walls randomly 
69ef			 
69ef			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
69ef			 
69ef			; Draw player 
69ef			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
69ef			 
69ef			; TODO Get Key 
69ef			 
69ef			; TODO Move left right 
69ef			 
69ef			; scroll and move walls a bit 
69ef			 
69ef			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
69ef			 
69ef			; main game loop 
69ef			 
69ef			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
69ef			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
69ef			 
69ef			; key board defs 
69ef			 
69ef .. 00		keyup:       db ": keyup $05 ;",0 
69fd .. 00		keydown:       db ": keydown $0a ;",0 
6a0d .. 00		keyleft:       db ": keyleft $0b ;",0 
6a1d .. 00		keyright:       db ": keyright $0c ;",0 
6a2e .. 00		keyf1:       db ": keyf1 $10 ;",0 
6a3c .. 00		keyf2:       db ": keyf2 $11 ;",0 
6a4a .. 00		keyf3:       db ": keyf3 $12 ;",0 
6a58 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6a66 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6a74 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6a82 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6a90 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6a9e .. 00		keyf9:       db ": keyf9 $18 ;",0 
6aac .. 00		keyf10:       db ": keyf10 $19 ;",0 
6abb .. 00		keyf11:       db ": keyf11 $1a ;",0 
6aca .. 00		keyf12:       db ": keyf12 $1b ;",0 
6ad9			 
6ad9 .. 00		keytab:       db ": keytab $09 ;",0 
6ae8 .. 00		keycr:       db ": keycr $0d ;",0 
6af6 .. 00		keyhome:       db ": keyhome $0e ;",0 
6b06 .. 00		keyend:       db ": keyend $0f ;",0 
6b15 .. 00		keybs:       db ": keybs $08 ;",0 
6b23			 
6b23			   
6b23			 
6b23			 
6b23			 
6b23			; eof 
# End of file forth_autostart.asm
6b23			 
6b23			 
6b23			 
6b23			; stack over and underflow checks 
6b23			 
6b23			; init the words to detect the under/overflow 
6b23			 
6b23			chk_stk_init: 
6b23				; a vague random number to check so we dont get any "lucky" hits 
6b23 3e 2d			ld a, 45 
6b25 6f				ld l, a 
6b26 00				nop 
6b27 3e 17			ld a, 23 
6b29 67				ld h, a 
6b2a			 
6b2a 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
6b2d			 
6b2d			;	ld (chk_stund), hl	; stack points.... 
6b2d 22 3b fe			ld (chk_stovr), hl 
6b30 22 27 f9			ld (chk_ret_und), hl 
6b33 22 e5 f8			ld (chk_ret_ovr), hl 
6b36 22 63 f8			ld (chk_loop_ovr), hl 
6b39 22 61 f6			ld (chk_data_ovr), hl 
6b3c c9				ret 
6b3d				 
6b3d			check_stacks: 
6b3d				; check all stack words 
6b3d			 
6b3d e5				push hl 
6b3e d5				push de 
6b3f			 
6b3f			;	ld de,(chk_word) 
6b3f			;	ld hl, (chk_stund)	; stack points.... 
6b3f			;	if DEBUG_STK_FAULT 
6b3f			;		DMARK "FAa" 
6b3f			;		CALLMONITOR 
6b3f			;	endif 
6b3f			;	call cmp16 
6b3f			;	jp z, .chk_faulta 
6b3f			; 
6b3f			;	ld de, sfaultsu 
6b3f			;	jp .chk_fault 
6b3f			 
6b3f 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6b42 ed 5b d8 f0		ld de,(chk_word) 
6b46				if DEBUG_STK_FAULT 
6b46					DMARK "FAb" 
6b46					CALLMONITOR 
6b46				endif 
6b46 cd ed 0f			call cmp16 
6b49 28 06			jr z, .chk_fault1 
6b4b 11 ec 6b			ld de, sfaultso 
6b4e c3 a0 6b			jp .chk_fault 
6b51			.chk_fault1:  
6b51 2a 27 f9			ld hl, (chk_ret_und) 
6b54 ed 5b d8 f0		ld de,(chk_word) 
6b58				if DEBUG_STK_FAULT 
6b58					DMARK "FAU" 
6b58					CALLMONITOR 
6b58				endif 
6b58 cd ed 0f			call cmp16 
6b5b ca 64 6b			jp z, .chk_fault2 
6b5e 11 fc 6b			ld de, sfaultru 
6b61 c3 a0 6b			jp .chk_fault 
6b64			.chk_fault2:  
6b64 2a e5 f8			ld hl, (chk_ret_ovr) 
6b67 ed 5b d8 f0		ld de,(chk_word) 
6b6b				if DEBUG_STK_FAULT 
6b6b					DMARK "FA1" 
6b6b					CALLMONITOR 
6b6b				endif 
6b6b cd ed 0f			call cmp16 
6b6e ca 77 6b			jp z, .chk_fault3 
6b71 11 0a 6c			ld de, sfaultro 
6b74 c3 a0 6b			jp .chk_fault 
6b77			.chk_fault3:  
6b77 2a 63 f8			ld hl, (chk_loop_ovr) 
6b7a ed 5b d8 f0		ld de,(chk_word) 
6b7e				if DEBUG_STK_FAULT 
6b7e					DMARK "FA2" 
6b7e					CALLMONITOR 
6b7e				endif 
6b7e cd ed 0f			call cmp16 
6b81 ca 8a 6b			jp z, .chk_fault4 
6b84 11 24 6c			ld de, sfaultlo 
6b87 c3 a0 6b			jp .chk_fault 
6b8a			.chk_fault4:  
6b8a 2a 61 f6			ld hl, (chk_data_ovr) 
6b8d ed 5b d8 f0		ld de,(chk_word) 
6b91				if DEBUG_STK_FAULT 
6b91					DMARK "FA3" 
6b91					CALLMONITOR 
6b91				endif 
6b91 cd ed 0f			call cmp16 
6b94 ca 9d 6b			jp z, .chk_fault5 
6b97 11 3e 6c			ld de, sfaultdo 
6b9a c3 a0 6b			jp .chk_fault 
6b9d			 
6b9d			 
6b9d			.chk_fault5:  
6b9d d1				pop de 
6b9e e1				pop hl 
6b9f			 
6b9f c9				ret 
6ba0			 
6ba0 cd 9b 0d		.chk_fault: 	call clear_display 
6ba3 3e 28				ld a, display_row_2 
6ba5 cd ae 0d				call str_at_display 
6ba8 11 ce 6b				   ld de, .stackfault 
6bab 3e 00				ld a, display_row_1 
6bad cd ae 0d				call str_at_display 
6bb0 11 a6 fd				    ld de, debug_mark 
6bb3 3e 11				ld a, display_row_1+17 
6bb5 cd ae 0d				call str_at_display 
6bb8 cd be 0d				call update_display 
6bbb			 
6bbb				; prompt before entering montior for investigating issue 
6bbb			 
6bbb 3e 78			ld a, display_row_4 
6bbd 11 15 1d			ld de, endprog 
6bc0			 
6bc0 cd be 0d			call update_display		 
6bc3			 
6bc3 cd 9b 1f			call next_page_prompt 
6bc6			 
6bc6 d1				pop de 
6bc7 e1				pop hl 
6bc8 cd 69 1d				call monitor 
6bcb c3 5f 1c				jp warmstart 
6bce					;jp 0 
6bce					;halt 
6bce			 
6bce			 
6bce			 
6bce .. 00		.stackfault: 	db "Stack fault:",0 
6bdb			 
6bdb .. 00		sfaultsu: 	db	"Stack under flow",0 
6bec .. 00		sfaultso: 	db	"Stack over flow",0 
6bfc .. 00		sfaultru:	db "RTS underflow",0 
6c0a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6c24 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6c3e .. 00		sfaultdo:	db "DTS overflow", 0 
6c4b			 
6c4b			 
6c4b			fault_dsp_under: 
6c4b 11 5d 6c			ld de, .dsp_under 
6c4e c3 0d 6d			jp .show_fault 
6c51			 
6c51			fault_rsp_under: 
6c51 11 6b 6c			ld de, .rsp_under 
6c54 c3 0d 6d			jp .show_fault 
6c57			fault_loop_under: 
6c57 11 79 6c			ld de, .loop_under 
6c5a c3 0d 6d			jp .show_fault 
6c5d			 
6c5d .. 00		.dsp_under: db "DSP Underflow",0 
6c6b .. 00		.rsp_under: db "RSP Underflow",0 
6c79 .. 00		.loop_under: db "LOOP Underflow",0 
6c88			 
6c88			 
6c88 d5			type_faultn: 	push de 
6c89 e5					push hl 
6c8a cd 9b 0d				call clear_display 
6c8d 11 b4 6c				   ld de, .typefaultn 
6c90 3e 00				ld a, display_row_1 
6c92 cd ae 0d				call str_at_display 
6c95 11 a6 fd				    ld de, debug_mark 
6c98 3e 11				ld a, display_row_1+17 
6c9a cd ae 0d				call str_at_display 
6c9d cd be 0d				call update_display 
6ca0			 
6ca0				; prompt before entering montior for investigating issue 
6ca0			 
6ca0 3e 78			ld a, display_row_4 
6ca2 11 15 1d			ld de, endprog 
6ca5			 
6ca5 cd be 0d			call update_display		 
6ca8			 
6ca8 cd 9b 1f			call next_page_prompt 
6cab			 
6cab e5					push hl 
6cac d5					push de 
6cad cd 69 1d				call monitor 
6cb0 c3 5f 1c				jp warmstart 
6cb3 76					halt 
6cb4			 
6cb4			 
6cb4 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6ccb			 
6ccb d5			type_faults: 	push de 
6ccc e5					push hl 
6ccd cd 9b 0d				call clear_display 
6cd0 11 f6 6c				   ld de, .typefaults 
6cd3 3e 00				ld a, display_row_1 
6cd5 cd ae 0d				call str_at_display 
6cd8 11 a6 fd				    ld de, debug_mark 
6cdb 3e 11				ld a, display_row_1+17 
6cdd cd ae 0d				call str_at_display 
6ce0 cd be 0d				call update_display 
6ce3			 
6ce3				; prompt before entering montior for investigating issue 
6ce3			 
6ce3 3e 78			ld a, display_row_4 
6ce5 11 15 1d			ld de, endprog 
6ce8			 
6ce8 cd be 0d			call update_display		 
6ceb			 
6ceb cd 9b 1f			call next_page_prompt 
6cee			 
6cee e1					pop hl 
6cef d1					pop de 
6cf0 cd 69 1d				call monitor 
6cf3 c3 5f 1c				jp warmstart 
6cf6			 
6cf6			 
6cf6 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6d0d			 
6d0d			.show_fault: 	 
6d0d d5					push de 
6d0e cd 9b 0d				call clear_display 
6d11 d1					pop de 
6d12 3e 00				ld a, display_row_1 
6d14 cd ae 0d				call str_at_display 
6d17 11 a6 fd				    ld de, debug_mark 
6d1a 3e 11				ld a, display_row_1+17 
6d1c cd ae 0d				call str_at_display 
6d1f cd be 0d				call update_display 
6d22			 
6d22				; prompt before entering montior for investigating issue 
6d22			 
6d22 3e 78			ld a, display_row_4 
6d24 11 15 1d			ld de, endprog 
6d27			 
6d27 cd be 0d			call update_display		 
6d2a			 
6d2a cd 9b 1f			call next_page_prompt 
6d2d			 
6d2d e1					pop hl 
6d2e d1					pop de 
6d2f cd 69 1d				call monitor 
6d32			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6d32			; TODO Make optional fault restart to cli or warm boot? 
6d32					;jp warmstart 
6d32 c3 a9 1c				jp cli 
6d35 76					halt 
6d36			 
6d36			; handle the auto run of code from files in storage 
6d36			 
6d36			 
6d36			include "forth_startup.asm" 
6d36			; Which startup method to use? 
6d36			; 
6d36			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6d36			; followed by loading of a list of scripts in eeprom 
6d36			 
6d36			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6d36			; from eeprom 
6d36			 
6d36			; Select with define in main stubs 
6d36			 
6d36			if STARTUP_V1 
6d36				include "forth_startupv1.asm" 
6d36			endif 
6d36			if STARTUP_V2 
6d36				include "forth_startupv2.asm" 
6d36			; Version 2 of the startup  
6d36			;  
6d36			; Auto load any files in bank 1 that start with a '*' 
6d36			; If no se storage then revert to using eprom 
6d36			 
6d36			 
6d36			if STORAGE_SE = 0 
6d36			 
6d36			sprompt1: db "Startup load...",0 
6d36			sprompt2: db "Run? 1=No *=End #=All",0 
6d36			 
6d36			 
6d36			 
6d36			 
6d36			forth_startup: 
6d36				ld hl, startcmds 
6d36				ld a, 0 
6d36				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6d36			 
6d36			.start1:	push hl 
6d36				call clear_display 
6d36				ld de, sprompt1 
6d36			        ld a, display_row_1 
6d36				call str_at_display 
6d36				ld de, sprompt2 
6d36			        ld a, display_row_2 
6d36				call str_at_display 
6d36				pop hl 
6d36				push hl 
6d36				ld e,(hl) 
6d36				inc hl 
6d36				ld d,(hl) 
6d36			        ld a, display_row_3 
6d36				call str_at_display 
6d36				call update_display 
6d36			 
6d36			 
6d36				ld a, (os_last_cmd) 
6d36				cp 0 
6d36				jr z, .startprompt 
6d36				call delay250ms 
6d36				jr .startdo 
6d36				 
6d36				 
6d36			 
6d36			.startprompt: 
6d36			 
6d36				ld a,display_row_4 + display_cols - 1 
6d36			        ld de, endprg 
6d36				call str_at_display 
6d36				call update_display 
6d36				call delay1s 
6d36				call cin_wait 
6d36						 
6d36				cp '*' 
6d36				jr z, .startupend1 
6d36				cp '#' 
6d36				jr nz, .startno 
6d36				ld a, 1 
6d36				ld (os_last_cmd),a 
6d36				jr .startdo 
6d36			.startno:	cp '1' 
6d36				jr z,.startnxt  
6d36			 
6d36				; exec startup line 
6d36			.startdo:	 
6d36				pop hl 
6d36				push hl 
6d36				 
6d36				ld e,(hl) 
6d36				inc hl 
6d36				ld d,(hl) 
6d36				ex de,hl 
6d36			 
6d36				push hl 
6d36			 
6d36				ld a, 0 
6d36				;ld a, FORTH_END_BUFFER 
6d36				call strlent 
6d36				inc hl   ; include zero term to copy 
6d36				ld b,0 
6d36				ld c,l 
6d36				pop hl 
6d36				ld de, scratch 
6d36				ldir 
6d36			 
6d36			 
6d36				ld hl, scratch 
6d36				call forthparse 
6d36				call forthexec 
6d36				call forthexec_cleanup 
6d36			 
6d36				ld a, display_row_4 
6d36				ld de, endprog 
6d36			 
6d36				call update_display		 
6d36			 
6d36				ld a, (os_last_cmd) 
6d36				cp 0 
6d36				jr nz, .startnxt 
6d36				call next_page_prompt 
6d36			        call clear_display 
6d36				call update_display		 
6d36			 
6d36				; move onto next startup line? 
6d36			.startnxt: 
6d36			 
6d36				call delay250ms 
6d36				pop hl 
6d36			 
6d36				inc hl 
6d36				inc hl 
6d36			 
6d36				push hl 
6d36				ld e, (hl) 
6d36				inc hl 
6d36				ld d, (hl) 
6d36				pop hl 
6d36				; TODO replace 0 test 
6d36			 
6d36				ex de, hl 
6d36				call ishlzero 
6d36			;	ld a,e 
6d36			;	add d 
6d36			;	cp 0    ; any left to do? 
6d36				ex de, hl 
6d36				jp nz, .start1 
6d36				jr .startupend 
6d36			 
6d36			.startupend1: pop hl 
6d36			.startupend: 
6d36			 
6d36				call clear_display 
6d36				call update_display 
6d36				ret 
6d36			endif 
6d36			 
6d36			 
6d36			if STORAGE_SE 
6d36			 
6d36			;sprompt3: db "Loading from start-up file:",0 
6d36 .. 00		sprompt3: db "  Searching...",0 
6d45			;sprompt4: db "(Any key to stop)",0 
6d45			 
6d45			 
6d45			forth_autoload: 
6d45			 
6d45				; load block 0 of store 1 
6d45				 
6d45 3e fe			ld a, $fe      ; bit 0 clear 
6d47 32 9b f9			ld (spi_device), a 
6d4a			 
6d4a cd 16 05			call storage_get_block_0 
6d4d			 
6d4d 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
6d50			 
6d50 fe 00			cp 0 
6d52 c8				ret z     ; auto start not enabled 
6d53			 
6d53 cd 9b 0d			call clear_display 
6d56			 
6d56				; set bank 
6d56			 
6d56 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
6d59 32 9b f9				ld (spi_device), a 
6d5c			 
6d5c			 
6d5c				; generate a directory of bank 1 and search for flagged files 
6d5c			 
6d5c					if DEBUG_FORTH_WORDS_KEY 
6d5c						DMARK "DIR" 
6d5c f5				push af  
6d5d 3a 71 6d			ld a, (.dmark)  
6d60 32 a6 fd			ld (debug_mark),a  
6d63 3a 72 6d			ld a, (.dmark+1)  
6d66 32 a7 fd			ld (debug_mark+1),a  
6d69 3a 73 6d			ld a, (.dmark+2)  
6d6c 32 a8 fd			ld (debug_mark+2),a  
6d6f 18 03			jr .pastdmark  
6d71 ..			.dmark: db "DIR"  
6d74 f1			.pastdmark: pop af  
6d75			endm  
# End of macro DMARK
6d75						CALLMONITOR 
6d75 cd aa fd			call debug_vector  
6d78				endm  
# End of macro CALLMONITOR
6d78					endif 
6d78			 
6d78 cd 16 05			call storage_get_block_0 
6d7b			 
6d7b 21 b5 f9			ld hl, store_page     ; get current id count 
6d7e 46				ld b, (hl) 
6d7f 0e 00			ld c, 0    ; count of files   
6d81					if DEBUG_FORTH_WORDS 
6d81						DMARK "DI1" 
6d81 f5				push af  
6d82 3a 96 6d			ld a, (.dmark)  
6d85 32 a6 fd			ld (debug_mark),a  
6d88 3a 97 6d			ld a, (.dmark+1)  
6d8b 32 a7 fd			ld (debug_mark+1),a  
6d8e 3a 98 6d			ld a, (.dmark+2)  
6d91 32 a8 fd			ld (debug_mark+2),a  
6d94 18 03			jr .pastdmark  
6d96 ..			.dmark: db "DI1"  
6d99 f1			.pastdmark: pop af  
6d9a			endm  
# End of macro DMARK
6d9a						CALLMONITOR 
6d9a cd aa fd			call debug_vector  
6d9d				endm  
# End of macro CALLMONITOR
6d9d					endif 
6d9d			 
6d9d				; check for empty drive 
6d9d			 
6d9d 3e 00			ld a, 0 
6d9f b8				cp b 
6da0 ca ed 6d			jp z, .dirdone 
6da3			 
6da3				; for each of the current ids do a search for them and if found push to stack 
6da3			 
6da3 c5			.diritem:	push bc 
6da4 21 40 00				ld hl, STORE_BLOCK_PHY 
6da7 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
6da9 58					ld e,b 
6daa			 
6daa d5					push de 
6dab e5					push hl 
6dac cd 9b 0d			call clear_display 
6daf 3e 32			ld a, display_row_2 + 10 
6db1 11 36 6d			ld de, sprompt3 
6db4 cd ae 0d			call str_at_display 
6db7 cd f2 0c			call active 
6dba eb				ex de, hl 
6dbb 3e 2f			ld a, display_row_2 + 7 
6dbd cd ae 0d			call str_at_display 
6dc0 cd be 0d			call update_display 
6dc3 e1				pop hl 
6dc4 d1				pop de 
6dc5			 
6dc5			;		if DEBUG_FORTH_WORDS 
6dc5			;			DMARK "DI2" 
6dc5			;			CALLMONITOR 
6dc5			;		endif 
6dc5			 
6dc5 cd 98 07				call storage_findnextid 
6dc8			 
6dc8			;		if DEBUG_FORTH_WORDS 
6dc8			;			DMARK "DI3" 
6dc8			;			CALLMONITOR 
6dc8			;		endif 
6dc8			 
6dc8					; if found hl will be non zero 
6dc8			 
6dc8 cd f8 0f				call ishlzero 
6dcb			;		ld a, l 
6dcb			;		add h 
6dcb			; 
6dcb			;		cp 0 
6dcb 28 1d				jr z, .dirnotfound 
6dcd			 
6dcd					; increase count 
6dcd			 
6dcd c1					pop bc	 
6dce 0c					inc c 
6dcf c5					push bc 
6dd0					 
6dd0			 
6dd0					; get file header and push the file name 
6dd0			 
6dd0 11 b5 f9				ld de, store_page 
6dd3 cd 65 04				call storage_read_block 
6dd6			 
6dd6					; push file id to stack 
6dd6				 
6dd6			 
6dd6					; is this a file we want to run? 
6dd6			 
6dd6 21 b8 f9				ld hl, store_page+3 
6dd9 7e					ld a,(hl) 
6dda fe 2a				cp '*' 
6ddc 20 0c				jr nz,  .dirnotfound 
6dde					 
6dde			 
6dde			 
6dde 3a b5 f9				ld a, (store_page) 
6de1 d5					push de 
6de2 e5					push hl 
6de3 c5					push bc 
6de4 cd 10 6e				call .autorunf 
6de7 c1					pop bc 
6de8 e1					pop hl 
6de9 d1					pop de 
6dea			 
6dea			 
6dea			 
6dea				; save this extent 
6dea			 
6dea					; push file name 
6dea			;display file name to run 
6dea			 
6dea			;		ld hl, store_page+3 
6dea			;		if DEBUG_FORTH_WORDS 
6dea			;			DMARK "DI5" 
6dea			;			CALLMONITOR 
6dea			;		endif 
6dea			; 
6dea			;		 
6dea			; 
6dea			;		call forth_push_str 
6dea			;		if DEBUG_FORTH_WORDS 
6dea			;			DMARK "DI6" 
6dea			;			CALLMONITOR 
6dea			;		endif 
6dea			.dirnotfound: 
6dea c1					pop bc     
6deb 10 b6				djnz .diritem 
6ded				 
6ded			.dirdone:	 
6ded					if DEBUG_FORTH_WORDS 
6ded						DMARK "DI7" 
6ded f5				push af  
6dee 3a 02 6e			ld a, (.dmark)  
6df1 32 a6 fd			ld (debug_mark),a  
6df4 3a 03 6e			ld a, (.dmark+1)  
6df7 32 a7 fd			ld (debug_mark+1),a  
6dfa 3a 04 6e			ld a, (.dmark+2)  
6dfd 32 a8 fd			ld (debug_mark+2),a  
6e00 18 03			jr .pastdmark  
6e02 ..			.dmark: db "DI7"  
6e05 f1			.pastdmark: pop af  
6e06			endm  
# End of macro DMARK
6e06						CALLMONITOR 
6e06 cd aa fd			call debug_vector  
6e09				endm  
# End of macro CALLMONITOR
6e09					endif 
6e09			 
6e09 cd 9b 0d				call clear_display 
6e0c cd be 0d				call update_display 
6e0f			 
6e0f c9					ret 
6e10			 
6e10			 
6e10			 
6e10			 
6e10			 
6e10			.autorunf: 
6e10			 
6e10			 
6e10				; get file id to load from and get the file name to display 
6e10			 
6e10			;		ld a, (store_page+STORE_0_FILERUN) 
6e10			 
6e10 2e 00				ld l, 0 
6e12 67					ld h, a 
6e13 11 b5 f9				ld de, store_page 
6e16			 
6e16					if DEBUG_FORTH_WORDS 
6e16						DMARK "ASp" 
6e16 f5				push af  
6e17 3a 2b 6e			ld a, (.dmark)  
6e1a 32 a6 fd			ld (debug_mark),a  
6e1d 3a 2c 6e			ld a, (.dmark+1)  
6e20 32 a7 fd			ld (debug_mark+1),a  
6e23 3a 2d 6e			ld a, (.dmark+2)  
6e26 32 a8 fd			ld (debug_mark+2),a  
6e29 18 03			jr .pastdmark  
6e2b ..			.dmark: db "ASp"  
6e2e f1			.pastdmark: pop af  
6e2f			endm  
# End of macro DMARK
6e2f						CALLMONITOR 
6e2f cd aa fd			call debug_vector  
6e32				endm  
# End of macro CALLMONITOR
6e32					endif 
6e32 cd be 09				call storage_read 
6e35			 
6e35					if DEBUG_FORTH_WORDS 
6e35						DMARK "ASr" 
6e35 f5				push af  
6e36 3a 4a 6e			ld a, (.dmark)  
6e39 32 a6 fd			ld (debug_mark),a  
6e3c 3a 4b 6e			ld a, (.dmark+1)  
6e3f 32 a7 fd			ld (debug_mark+1),a  
6e42 3a 4c 6e			ld a, (.dmark+2)  
6e45 32 a8 fd			ld (debug_mark+2),a  
6e48 18 03			jr .pastdmark  
6e4a ..			.dmark: db "ASr"  
6e4d f1			.pastdmark: pop af  
6e4e			endm  
# End of macro DMARK
6e4e						CALLMONITOR 
6e4e cd aa fd			call debug_vector  
6e51				endm  
# End of macro CALLMONITOR
6e51					endif 
6e51			 
6e51 cd f8 0f				call ishlzero 
6e54 c8					ret z             ; file not found 
6e55			 
6e55					; display file name we are loading 
6e55			 
6e55 cd 9b 0d				call clear_display 
6e58			 
6e58 3e 32				ld a, display_row_2 + 10 
6e5a 11 b8 f9				ld de, store_page+3 
6e5d cd ae 0d				call str_at_display 
6e60				 
6e60			; 
6e60			 
6e60			;	ld a, display_row_1+5 
6e60			;	ld de, sprompt3 
6e60			;	call str_at_display 
6e60			;	ld a, display_row_2+7 
6e60			;	call active 
6e60			;	ex de, hl 
6e60			;;	ld de, sprompt4 
6e60			;	call str_at_display 
6e60			; 
6e60 cd be 0d			call update_display 
6e63			 
6e63			;	call cin_wait 
6e63			;	cp 'n' 
6e63			;	ret z 
6e63			;	cp 'N' 
6e63			;	ret z 
6e63			 
6e63			;	call delay1s 
6e63			 
6e63 3a b7 f9			ld a, (store_page+2) 
6e66 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
6e69 3e 01			ld a, 1  
6e6b 32 a5 f9			ld (store_openext), a    ; save count of ext 
6e6e			 
6e6e			.autof: 
6e6e				; begin to read a line from file 
6e6e			 
6e6e 21 23 f4			ld hl, os_cli_cmd 
6e71 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
6e74			  
6e74			.readext: 
6e74 3a a5 f9			ld a, (store_openext) 
6e77 6f				ld l , a 
6e78				 
6e78 3a b5 f9			ld a, (store_page) 
6e7b 67				ld h, a	 
6e7c 11 b5 f9			ld de, store_page 
6e7f					if DEBUG_FORTH_WORDS 
6e7f						DMARK "ASl" 
6e7f f5				push af  
6e80 3a 94 6e			ld a, (.dmark)  
6e83 32 a6 fd			ld (debug_mark),a  
6e86 3a 95 6e			ld a, (.dmark+1)  
6e89 32 a7 fd			ld (debug_mark+1),a  
6e8c 3a 96 6e			ld a, (.dmark+2)  
6e8f 32 a8 fd			ld (debug_mark+2),a  
6e92 18 03			jr .pastdmark  
6e94 ..			.dmark: db "ASl"  
6e97 f1			.pastdmark: pop af  
6e98			endm  
# End of macro DMARK
6e98						CALLMONITOR 
6e98 cd aa fd			call debug_vector  
6e9b				endm  
# End of macro CALLMONITOR
6e9b					endif 
6e9b cd be 09				call storage_read 
6e9e cd f8 0f			call ishlzero 
6ea1 c8				ret z 
6ea2			 
6ea2			; TODO copy to exec buffer 
6ea2			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6ea2			 
6ea2				; copy the record buffer to the cli buffer 
6ea2			 
6ea2 ed 5b 21 f6		ld de, (os_var_array) 
6ea6 21 b7 f9			ld hl, store_page+2 
6ea9			;	ex de, hl 
6ea9 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
6eac ed b0			ldir 
6eae ed 53 21 f6		ld (os_var_array), de 
6eb2				 
6eb2 3a a5 f9			ld a, (store_openext) 
6eb5 3c				inc a 
6eb6 32 a5 f9			ld (store_openext), a    ; save count of ext 
6eb9			 
6eb9			 
6eb9			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6eb9				 
6eb9 3a a8 f9			ld a, (store_readcont) 
6ebc fe 00			cp 0 
6ebe 20 b4			jr nz, .readext 
6ec0			 
6ec0			;	jr z, .autoend 
6ec0			 
6ec0					if DEBUG_FORTH_WORDS 
6ec0						DMARK "ASc" 
6ec0 f5				push af  
6ec1 3a d5 6e			ld a, (.dmark)  
6ec4 32 a6 fd			ld (debug_mark),a  
6ec7 3a d6 6e			ld a, (.dmark+1)  
6eca 32 a7 fd			ld (debug_mark+1),a  
6ecd 3a d7 6e			ld a, (.dmark+2)  
6ed0 32 a8 fd			ld (debug_mark+2),a  
6ed3 18 03			jr .pastdmark  
6ed5 ..			.dmark: db "ASc"  
6ed8 f1			.pastdmark: pop af  
6ed9			endm  
# End of macro DMARK
6ed9						CALLMONITOR 
6ed9 cd aa fd			call debug_vector  
6edc				endm  
# End of macro CALLMONITOR
6edc					endif 
6edc e5				push hl	 
6edd d5				push de 
6ede cd f2 0c			call active 
6ee1 eb				ex de, hl 
6ee2 3e 2f			ld a, display_row_2 + 7 
6ee4 cd ae 0d			call str_at_display 
6ee7			 
6ee7 cd be 0d			call update_display 
6eea d1				pop de  
6eeb e1				pop hl 
6eec			;	call delay250ms 
6eec			 
6eec			 
6eec			 
6eec			 
6eec			.autoexec: 
6eec			 
6eec			 
6eec 21 23 f4			ld hl, os_cli_cmd 
6eef					if DEBUG_FORTH_WORDS 
6eef						DMARK "ASx" 
6eef f5				push af  
6ef0 3a 04 6f			ld a, (.dmark)  
6ef3 32 a6 fd			ld (debug_mark),a  
6ef6 3a 05 6f			ld a, (.dmark+1)  
6ef9 32 a7 fd			ld (debug_mark+1),a  
6efc 3a 06 6f			ld a, (.dmark+2)  
6eff 32 a8 fd			ld (debug_mark+2),a  
6f02 18 03			jr .pastdmark  
6f04 ..			.dmark: db "ASx"  
6f07 f1			.pastdmark: pop af  
6f08			endm  
# End of macro DMARK
6f08						CALLMONITOR 
6f08 cd aa fd			call debug_vector  
6f0b				endm  
# End of macro CALLMONITOR
6f0b					endif 
6f0b cd 1e 24			call forthparse 
6f0e cd 5e 24			call forthexec 
6f11 cd 70 23			call forthexec_cleanup 
6f14			 
6f14			 
6f14			 
6f14 c3 6e 6e			jp .autof 
6f17			;.autofdone: 
6f17			; 
6f17			;		if DEBUG_FORTH_WORDS 
6f17			;			DMARK "ASx" 
6f17			;			CALLMONITOR 
6f17			;		endif 
6f17			;;	call clear_display 
6f17			;	ret 
6f17			 
6f17			 
6f17			 
6f17			endif 
# End of file forth_startupv2.asm
6f17			endif 
6f17			 
# End of file forth_startup.asm
6f17			 
6f17			; eof 
# End of file forth_kernel.asm
6f17			;include "nascombasic.asm" 
6f17			 
6f17			 
6f17			; find out where the code ends if loaded into RAM (for SC114) 
6f17			;endofcode:  
6f17			;	nop 
6f17			 
6f17			 
6f17			; jump to nmi vector 
6f17			 
6f17			init_nmi: 
6f17 3e c9			ld a, $c9   ; RET 
6f19 32 ad fd			ld (nmi_vector), a 
6f1c c9				ret 
6f1d			nmi: 
6f1d e5				push hl 
6f1e d5				push de 
6f1f c5				push bc 
6f20 f5				push af 
6f21 cd ad fd			call nmi_vector 
6f24 f5				push af 
6f25 c5				push bc 
6f26 d5				push de 
6f27 e5				push hl 
6f28 ed 4d			reti 
6f2a			 
6f2a			 
6f2a			; eof 
6f2a			 
# End of file main.asm
6f2a			include "firmware_lcd_4x40.asm" 
6f2a			; **********************************************************************  
6f2a			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6f2a			; **********************************************************************  
6f2a			;  
6f2a			; **  Written as a Small Computer Monitor App  
6f2a			; **  www.scc.me.uk  
6f2a			;  
6f2a			; History  
6f2a			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6f2a			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6f2a			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6f2a			;  
6f2a			; **********************************************************************  
6f2a			;  
6f2a			; This program is an example of one of the methods of interfacing an   
6f2a			; alphanumeric LCD module.   
6f2a			;  
6f2a			; In this example the display is connected to either a Z80 PIO or a   
6f2a			; simple 8-bit output port.   
6f2a			;  
6f2a			; This interfacing method uses 4-bit data mode and uses time delays  
6f2a			; rather than polling the display's ready status. As a result the   
6f2a			; interface only requires 6 simple output lines:  
6f2a			;   Output bit 0 = not used  
6f2a			;   Output bit 1 = not used  
6f2a			;   Output bit 2 = RS         High = data, Low = instruction  
6f2a			;   Output bit 3 = E          Active high  
6f2a			;   Output bit 4 = DB4  
6f2a			;   Output bit 5 = DB5  
6f2a			;   Output bit 6 = DB6  
6f2a			;   Output bit 7 = DB7  
6f2a			; Display's R/W is connected to 0v so it is always in write mode  
6f2a			;  
6f2a			; This set up should work with any system supporting the RC2014 bus  
6f2a			  
6f2a			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6f2a			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6f2a			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6f2a			;  
6f2a			; **********************************************************************  
6f2a			  
6f2a			; Additonal for 4x40. E1 and E2 instead of just E   
6f2a			; TODO swipe vidout signal on port a to activate E2  
6f2a			  
6f2a			; **********************************************************************  
6f2a			; **  Constants  
6f2a			; **********************************************************************  
6f2a			; LCD constants required by LCD support module  
6f2a			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6f2a			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6f2a			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6f2a			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6f2a			; TODO Decide which E is being set  
6f2a			kLCDWidth:  EQU display_cols             ;Width in characters  
6f2a			  
6f2a			; **********************************************************************  
6f2a			; **  Code library usage  
6f2a			; **********************************************************************  
6f2a			  
6f2a			; send character to current cursor position  
6f2a			; wraps and/or scrolls screen automatically  
6f2a			  
6f2a			  
6f2a			  
6f2a			lcd_init:  
6f2a			  
6f2a			; SCMonAPI functions used  
6f2a			  
6f2a			; Alphanumeric LCD functions used  
6f2a			; no need to specify specific functions for this module  
6f2a			  
6f2a 3e cf		            LD   A, 11001111b  
6f2c d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6f2e 3e 00		            LD   A, 00000000b  
6f30 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6f32			  
6f32			; Initialise alphanumeric LCD module  
6f32 3e 00				ld a, 0  
6f34 32 06 fb				ld (display_lcde1e2), a  
6f37 cd b8 6f		            CALL fLCD_Init      ;Initialise LCD module  
6f3a 3e 01				ld a, 1  
6f3c 32 06 fb				ld (display_lcde1e2), a  
6f3f cd b8 6f		            CALL fLCD_Init      ;Initialise LCD module  
6f42			  
6f42 c9				ret  
6f43			  
6f43			;  
6f43			;;  
6f43			; lcd functions  
6f43			;  
6f43			;  
6f43			  
6f43			; what is at cursor position   
6f43			  
6f43			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6f43			;		call curptr  
6f43			;		ret  
6f43			  
6f43			  
6f43			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6f43			  
6f43			curptr:  
6f43 c5				push bc  
6f44 21 ec fc			ld hl, display_fb0  
6f47			cpr:	  
6f47				; loop for cursor whole row  
6f47 0e 28			ld c, display_cols  
6f49 23			cpr1:	inc hl  
6f4a 0d				dec c  
6f4b 20 fc			jr nz, cpr1  
6f4d 05				dec b  
6f4e 20 f7			jr nz, cpr  
6f50			  
6f50				; add col	  
6f50			  
6f50 23			cpr2:	inc hl  
6f51 1d				dec e  
6f52 20 fc			jr nz, cpr2  
6f54			  
6f54 c1				pop bc  
6f55 c9				ret  
6f56				  
6f56			  
6f56			  
6f56			  
6f56			  
6f56			; write the frame buffer given in hl to hardware   
6f56 22 04 fb		write_display: ld (display_write_tmp), hl 	   
6f59 3e 00			ld a, kLCD_Line1  
6f5b cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f5e 06 28			ld b, display_cols  
6f60 ed 5b 04 fb		ld de, (display_write_tmp)  
6f64 cd b0 6f			call write_len_string  
6f67				  
6f67				  
6f67 2a 04 fb			ld hl, (display_write_tmp)  
6f6a 11 28 00			ld de, display_cols  
6f6d 19				add hl,de  
6f6e 22 04 fb			ld (display_write_tmp),hl  
6f71			  
6f71				  
6f71 3e 28			ld a, kLCD_Line2  
6f73 cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f76 06 28			ld b, display_cols  
6f78 ed 5b 04 fb		ld de, (display_write_tmp)  
6f7c cd b0 6f			call write_len_string  
6f7f				  
6f7f 2a 04 fb			ld hl, (display_write_tmp)  
6f82 11 28 00			ld de, display_cols  
6f85 19				add hl,de  
6f86 22 04 fb			ld (display_write_tmp),hl  
6f89			  
6f89				  
6f89 3e 50			ld a, kLCD_Line3  
6f8b cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f8e 06 28			ld b, display_cols  
6f90 ed 5b 04 fb		ld de, (display_write_tmp)  
6f94 cd b0 6f			call write_len_string  
6f97				  
6f97 2a 04 fb			ld hl, (display_write_tmp)  
6f9a 11 28 00			ld de, display_cols  
6f9d 19				add hl,de  
6f9e 22 04 fb			ld (display_write_tmp),hl  
6fa1			  
6fa1				  
6fa1 3e 78			ld a, kLCD_Line4  
6fa3 cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6fa6 06 28			ld b, display_cols  
6fa8 ed 5b 04 fb		ld de, (display_write_tmp)  
6fac cd b0 6f			call write_len_string  
6faf c9					ret  
6fb0				  
6fb0				; write out a fixed length string given in b from de  
6fb0			  
6fb0 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6fb1 cd 1d 70		            CALL fLCD_Data      ;Write character to display  
6fb4 13				inc de  
6fb5 10 f9			djnz write_len_string  
6fb7 c9				ret  
6fb8			  
6fb8			; Some other things to do  
6fb8			;            LD   A, kLCD_Clear ;Display clear  
6fb8			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6fb8			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6fb8			;            LD   A, kLCD_On     ;Display on with no cursor  
6fb8			;            ;LD   A, kLCD_Off   ;Display off  
6fb8			;            CALL fLCD_Inst      ;Send instruction to display  
6fb8			;  
6fb8			;  
6fb8			;            halt  
6fb8			;  
6fb8			;  
6fb8			;MsgHello:   DB  "Hello World!",0  
6fb8			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6fb8			  
6fb8			; Custom characters 5 pixels wide by 8 pixels high  
6fb8			; Up to 8 custom characters can be defined  
6fb8			;BitMaps:      
6fb8			;; Character 0x00 = Battery icon  
6fb8			;            DB  01110b  
6fb8			;            DB  11011b  
6fb8			;            DB  10001b  
6fb8			;            DB  10001b  
6fb8			;            DB  11111b  
6fb8			;            DB  11111b  
6fb8			;            DB  11111b  
6fb8			;            DB  11111b  
6fb8			;; Character 0x01 = Bluetooth icon  
6fb8			;            DB  01100b  
6fb8			;            DB  01010b  
6fb8			;            DB  11100b  
6fb8			;            DB  01000b  
6fb8			;            DB  11100b  
6fb8			;            DB  01010b  
6fb8			;            DB  01100b  
6fb8			;            DB  00000b  
6fb8			;  
6fb8			  
6fb8			  
6fb8			; **********************************************************************  
6fb8			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6fb8			; **********************************************************************  
6fb8			;  
6fb8			; **  Written as a Small Computer Monitor App   
6fb8			; **  Version 0.1 SCC 2018-05-16  
6fb8			; **  www.scc.me.uk  
6fb8			;  
6fb8			; **********************************************************************  
6fb8			;  
6fb8			; This module provides support for alphanumeric LCD modules using with  
6fb8			; *  HD44780 (or compatible) controller  
6fb8			; *  5 x 7 pixel fonts  
6fb8			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6fb8			; *  Interface via six digital outputs to the display (see below)  
6fb8			;  
6fb8			; LCD module pinout:  
6fb8			;   1  Vss   0v supply  
6fb8			;   2  Vdd   5v supply  
6fb8			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6fb8			;   4  RS    High = data, Low = instruction  
6fb8			;   5  R/W   High = Read, Low = Write  
6fb8			;   6  E     Enable signal (active high)  
6fb8			;   7  DB0   Data bit 0  
6fb8			;   8  DB1   Data bit 1  
6fb8			;   9  DB2   Data bit 2  
6fb8			;  10  DB3   Data bit 3  
6fb8			;  11  DB4   Data bit 4  
6fb8			;  12  DB5   Data bit 5  
6fb8			;  13  DB6   Data bit 6  
6fb8			;  14  DB7   Data bit 7  
6fb8			;  15  A     Backlight anode (+)  
6fb8			;  16  K     Backlight cathode (-)  
6fb8			;  
6fb8			; This interfacing method uses 4-bit data mode and uses time delays  
6fb8			; rather than polling the display's ready status. As a result the   
6fb8			; interface only requires 6 simple output lines:  
6fb8			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6fb8			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6fb8			;   LCD DB4 = Microcomputer output port bit 4  
6fb8			;   LCD DB5 = Microcomputer output port bit 5  
6fb8			;   LCD DB6 = Microcomputer output port bit 6  
6fb8			;   LCD DB7 = Microcomputer output port bit 7  
6fb8			; Display's R/W is connected to 0v so it is always in write mode  
6fb8			; All 6 connections must be on the same port address <kLCDPrt>  
6fb8			; This method also allows a decent length of cable from micro to LCD  
6fb8			;  
6fb8			; **********************************************************************  
6fb8			;  
6fb8			; To include the code for any given function provided by this module,   
6fb8			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6fb8			; the parent source file.  
6fb8			; For example:  #REQUIRES   uHexPrefix  
6fb8			;  
6fb8			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6fb8			; in the parent source file.  
6fb8			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6fb8			;  
6fb8			; These are the function names provided by this module:  
6fb8			; fLCD_Init                     ;Initialise LCD  
6fb8			; fLCD_Inst                     ;Send instruction to LCD  
6fb8			; fLCD_Data                     ;Send data byte to LCD  
6fb8			; fLCD_Pos                      ;Position cursor  
6fb8			; fLCD_Str                      ;Display string  
6fb8			; fLCD_Def                      ;Define custom character  
6fb8			;  
6fb8			; **********************************************************************  
6fb8			;  
6fb8			; Requires SCMonAPI.asm to also be included in the project  
6fb8			;  
6fb8			  
6fb8			  
6fb8			; **********************************************************************  
6fb8			; **  Constants  
6fb8			; **********************************************************************  
6fb8			  
6fb8			; Constants that must be defined externally  
6fb8			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6fb8			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6fb8			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6fb8			;kLCDWidth: EQU 20             ;Width in characters  
6fb8			  
6fb8			; general line offsets in any frame buffer  
6fb8			  
6fb8			  
6fb8			display_row_1: equ 0  
6fb8			display_row_2: equ display_row_1+display_cols  
6fb8			display_row_3: equ display_row_2 + display_cols  
6fb8			display_row_4: equ display_row_3 + display_cols  
6fb8			;display_row_4_eol:   
6fb8			  
6fb8			  
6fb8			; Cursor position values for the start of each line  
6fb8			  
6fb8			; E  
6fb8			kLCD_Line1: EQU 0x00   
6fb8			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6fb8			; E1  
6fb8			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6fb8			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6fb8			  
6fb8			; Instructions to send as A register to fLCD_Inst  
6fb8			kLCD_Clear: EQU 00000001b     ;LCD clear  
6fb8			kLCD_Off:   EQU 00001000b     ;LCD off  
6fb8			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6fb8			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6fb8			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6fb8			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6fb8			  
6fb8			; Constants used by this code module  
6fb8			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6fb8			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6fb8			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6fb8			  
6fb8			  
6fb8			  
6fb8			; **********************************************************************  
6fb8			; **  LCD support functions  
6fb8			; **********************************************************************  
6fb8			  
6fb8			; Initialise alphanumeric LCD module  
6fb8			; LCD control register codes:  
6fb8			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6fb8			;   N    0 = 1-line mode       1 = 2-line mode  
6fb8			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6fb8			;   D    0 = Display off       1 = Display on  
6fb8			;   C    0 = Cursor off        1 = Cursor on  
6fb8			;   B    0 = Blinking off      1 = Blinking on  
6fb8			;   ID   0 = Decrement mode    1 = Increment mode  
6fb8			;   SH   0 = Entire shift off  1 = Entire shift on  
6fb8 3e 28		fLCD_Init:  LD   A, 40  
6fba cd df 70		            CALL LCDDelay       ;Delay 40ms after power up  
6fbd			; For reliable reset set 8-bit mode - 3 times  
6fbd cd af 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fc0 cd af 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fc3 cd af 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fc6			; Set 4-bit mode  
6fc6 cd ab 70		            CALL WrFn4bit       ;Function = 4-bit mode  
6fc9 cd dd 70		            CALL LCDDelay1      ;Delay 37 us or more  
6fcc			; Function set  
6fcc 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6fce cd e1 6f		            CALL fLCD_Inst      ;2 line, display on  
6fd1			; Display On/Off control  
6fd1 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6fd3 cd e1 6f		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6fd6			; Display Clear  
6fd6 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6fd8 cd e1 6f		            CALL fLCD_Inst      ;Clear display  
6fdb			; Entry mode  
6fdb 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6fdd cd e1 6f		            CALL fLCD_Inst      ;Increment mode, shift off  
6fe0			; Display module now initialised  
6fe0 c9			            RET  
6fe1			; ok to here  
6fe1			  
6fe1			; Write instruction to LCD  
6fe1			;   On entry: A = Instruction byte to be written  
6fe1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6fe1 f5			fLCD_Inst:  PUSH AF  
6fe2 f5			            PUSH AF  
6fe3 cd f5 6f		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6fe6 f1			            POP  AF  
6fe7 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6fe8 17			            RLA  
6fe9 17			            RLA  
6fea 17			            RLA  
6feb cd f5 6f		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6fee 3e 02		            LD   A, 2  
6ff0 cd df 70		            CALL LCDDelay       ;Delay 2 ms to complete   
6ff3 f1			            POP  AF  
6ff4 c9			            RET  
6ff5			Wr4bits:   
6ff5 f5					push af  
6ff6 3a 06 fb				ld a, (display_lcde1e2)  
6ff9 fe 00				cp 0     ; e  
6ffb 20 10				jr nz, .wea2	  
6ffd f1					pop af  
6ffe e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7000 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7002 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7004 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7006 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7008 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
700a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
700c c9			            RET  
700d f1			.wea2:		pop af  
700e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7010 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7012 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7014 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7016 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7018 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
701a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
701c c9			            RET  
701d			  
701d			  
701d			; Write data to LCD  
701d			;   On entry: A = Data byte to be written  
701d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
701d f5			fLCD_Data:  PUSH AF  
701e f5			            PUSH AF  
701f cd 31 70		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7022 f1			            POP  AF  
7023 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7024 17			            RLA  
7025 17			            RLA  
7026 17			            RLA  
7027 cd 31 70		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
702a 3e 96		            LD   A, 150  
702c 3d			Wait:      DEC  A              ;Wait a while to allow data   
702d 20 fd		            JR   NZ, Wait      ;  write to complete  
702f f1			            POP  AF  
7030 c9			            RET  
7031			Wr4bitsa:     
7031 f5					push af  
7032 3a 06 fb				ld a, (display_lcde1e2)  
7035 fe 00				cp 0     ; e1  
7037 20 16				jr nz, .we2	  
7039 f1					pop af  
703a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
703c cb d7		            SET  kLCDBitRS, A  
703e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7040 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7042 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7044 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7046 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7048 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
704a cb 97		            RES  kLCDBitRS, A  
704c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
704e c9			            RET  
704f f1			.we2:		pop af  
7050 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7052 cb d7		            SET  kLCDBitRS, A  
7054 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7056 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7058 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
705a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
705c cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
705e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7060 cb 97		            RES  kLCDBitRS, A  
7062 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7064 c9			            RET  
7065			  
7065			  
7065			; Position cursor to specified location  
7065			;   On entry: A = Cursor position  
7065			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7065 f5			fLCD_Pos:   PUSH AF  
7066					; at this point set the E1 or E2 flag depending on position  
7066			  
7066 c5					push bc  
7067			;		push af  
7067 06 00				ld b, 0  
7069 4f					ld c, a  
706a 3e 4f				ld a, kLCD_Line3-1  
706c b7			 		or a      ;clear carry flag  
706d 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
706e 38 04				jr c, .pe1  
7070			  
7070					; E selection  
7070 cb 80				res 0, b         ; bit 0 unset e  
7072			;		pop af    ; before line 3 so recover orig pos  
7072			;		ld c, a    ; save for poking back  
7072 18 06				jr .peset	          
7074			.pe1:          	; E2 selection  
7074 cb c0				set 0, b         ; bit 0 set e1  
7076 79					ld a, c  
7077 de 4f				sbc a, kLCD_Line3-1  
7079 4f					ld c, a	         ; save caculated offset  
707a			;		pop af     ; bin this original value now we have calculated form  
707a			  
707a			.peset:		; set bit  
707a 78					ld a, b  
707b 32 06 fb				ld (display_lcde1e2), a 	  
707e 79					ld a, c  
707f c1					pop bc  
7080			  
7080 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7082 cd e1 6f		            CALL fLCD_Inst      ;Write instruction to LCD  
7085 f1			            POP  AF  
7086 c9			            RET  
7087			  
7087			  
7087			; Output text string to LCD  
7087			;   On entry: DE = Pointer to null terminated text string  
7087			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7087 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7088 b7			            OR   A              ;Null terminator?  
7089 c8			            RET  Z              ;Yes, so finished  
708a cd 1d 70		            CALL fLCD_Data      ;Write character to display  
708d 13			            INC  DE             ;Point to next character  
708e 18 f7		            JR   fLCD_Str       ;Repeat  
7090 c9					ret  
7091			  
7091			; Define custom character  
7091			;   On entry: A = Character number (0 to 7)  
7091			;             DE = Pointer to character bitmap data  
7091			;   On exit:  A = Next character number  
7091			;             DE = Next location following bitmap  
7091			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7091			; Character is   
7091 c5			fLCD_Def:   PUSH BC  
7092 f5			            PUSH AF  
7093 07			            RLCA                ;Calculate location  
7094 07			            RLCA                ;  for bitmap data  
7095 07			            RLCA                ;  = 8 x CharacterNumber  
7096 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7098 cd e1 6f		            CALL fLCD_Inst      ;Write instruction to LCD  
709b 06 00		            LD   B, 0  
709d 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
709e cd 1d 70		            CALL fLCD_Data      ;Write byte to display  
70a1 13			            INC  DE             ;Point to next byte  
70a2 04			            INC  B              ;Count bytes  
70a3 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
70a5 28 f6		            JR   Z, Loop       ;No, so repeat  
70a7 f1			            POP  AF  
70a8 3c			            INC  A              ;Increment character number  
70a9 c1			            POP  BC  
70aa c9			            RET  
70ab			  
70ab			  
70ab			; **********************************************************************  
70ab			; **  Private functions  
70ab			; **********************************************************************  
70ab			  
70ab			; Write function to LCD  
70ab			;   On entry: A = Function byte to be written  
70ab			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70ab 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
70ad 18 02		            JR   WrFunc  
70af 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
70b1 f5			WrFunc:     PUSH AF  
70b2 f5					push af  
70b3 3a 06 fb				ld a, (display_lcde1e2)  
70b6 fe 00				cp 0     ; e1  
70b8 20 0f				jr nz, .wfea2	  
70ba f1					pop af  
70bb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70bd cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
70bf cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
70c1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70c3 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
70c5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70c7 18 0d			jr .wfskip  
70c9 f1			.wfea2:		pop af  
70ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70cc cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
70ce cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
70d0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70d2 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
70d4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70d6 3e 05		.wfskip:            LD  A, 5  
70d8 cd df 70		            CALL LCDDelay       ;Delay 5 ms to complete  
70db f1			            POP  AF  
70dc c9			            RET  
70dd			  
70dd			  
70dd			; Delay in milliseconds  
70dd			;   On entry: A = Number of milliseconds delay  
70dd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70dd 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
70df d5			LCDDelay:   PUSH DE  
70e0 5f			            LD   E, A           ;Delay by 'A' ms  
70e1 16 00		            LD   D, 0  
70e3 cd c3 0c		            CALL aDelayInMS  
70e6 d1			            POP  DE  
70e7 c9			            RET  
70e8			  
70e8			  
70e8			testlcd:  
70e8 3e 00			ld a, kLCD_Line1  
70ea cd 65 70			call fLCD_Pos  
70ed 06 28			ld b, 40  
70ef 11 1d 71			ld de, .ttext1  
70f2 cd b0 6f			call write_len_string  
70f5			  
70f5 3e 28			ld a, kLCD_Line2  
70f7 cd 65 70			call fLCD_Pos  
70fa 06 28			ld b, 40  
70fc 11 46 71			ld de, .ttext2  
70ff cd b0 6f			call write_len_string  
7102 3e 50			ld a, kLCD_Line3  
7104 cd 65 70			call fLCD_Pos  
7107 06 28			ld b, 40  
7109 11 6f 71			ld de, .ttext3  
710c cd b0 6f			call write_len_string  
710f 3e 78			ld a, kLCD_Line4  
7111 cd 65 70			call fLCD_Pos  
7114 06 28			ld b, 40  
7116 11 98 71			ld de, .ttext4  
7119 cd b0 6f			call write_len_string  
711c			  
711c 76				halt  
711d			  
711d			  
711d .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7146 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
716f .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7198 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
71c1			   
71c1			  
71c1			  
71c1			; eof  
71c1			  
# End of file firmware_lcd_4x40.asm
71c1			;include "firmware_lcd_4x20.asm" 
71c1			include "firmware_key_5x10.asm" 
71c1			; 5 x 10 decade counter scanner  
71c1			  
71c1			  
71c1			; TODO do cursor shape change for shift keys  
71c1			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
71c1			  
71c1			  
71c1			; bit mask for each scan column and row for teing the matrix  
71c1			  
71c1			  
71c1			key_init:  
71c1			  
71c1			; SCMonAPI functions used  
71c1			  
71c1			; Alphanumeric LCD functions used  
71c1			; no need to specify specific functions for this module  
71c1			  
71c1			  
71c1 3e cf		            LD   A, 11001111b  
71c3 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
71c5			;            LD   A, 00000000b  
71c5 3e 1f		            LD   A, 00011111b  
71c7 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
71c9			  
71c9			  
71c9				; TODO Configure cursor shapes  
71c9			  
71c9				; Load cursor shapes   
71c9 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
71cb 11 db 71		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
71ce 06 02		            LD   B, 2           ;Number of characters to define  
71d0 cd 91 70		.DefLoop:   CALL fLCD_Def       ;Define custom character  
71d3 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
71d5			  
71d5 3e 01				ld a, 1  
71d7 32 fc fa			ld (cursor_shape),a  
71da c9				ret  
71db			  
71db			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
71db			; Up to 8 custom characters can be defined  
71db			.cursor_shapes:      
71db			;; Character 0x00 = Normal  
71db 1f			            DB  11111b  
71dc 1f			            DB  11111b  
71dd 1f			            DB  11111b  
71de 1f			            DB  11111b  
71df 1f			            DB  11111b  
71e0 1f			            DB  11111b  
71e1 1f			            DB  11111b  
71e2 1f			            DB  11111b  
71e3			;; Character 0x01 = Modifier  
71e3 1f			            DB  11111b  
71e4 1b			            DB  11011b  
71e5 1b			            DB  11011b  
71e6 1b			            DB  11011b  
71e7 1b			            DB  11011b  
71e8 1f			            DB  11111b  
71e9 1b			            DB  11011b  
71ea 1f			            DB  11111b  
71eb			  
71eb			  
71eb			  
71eb			  
71eb			; Display custom character 0  
71eb			;            LD   A, kLCD_Line1+14  
71eb			;            CALL fLCD_Pos       ;Position cursor to location in A  
71eb			;            LD   A, 0  
71eb			;            CALL fLCD_Data      ;Write character in A at cursor  
71eb			  
71eb			; Display custom character 1  
71eb			;            LD   A, kLCD_Line2+14  
71eb			;            CALL fLCD_Pos      ;Position cursor to location in A  
71eb			;            LD   A, 1  
71eb			;            CALL fLCD_Data     ;Write character in A at cursor  
71eb			  
71eb			; keyboard scanning   
71eb			  
71eb			; character in from keyboard  
71eb			  
71eb			; mapping for the pcb layout  
71eb			  
71eb			.matrix_to_char:  
71eb .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
71f6 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7201 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
720c 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7217 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7222			.matrix_to_shift:  
7222			  
7222 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
722d .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7238 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7243 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
724e .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7259			  
7259			.matrix_to_symbolshift:  
7259			  
7259 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7264 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
726f 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
727a			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
727a 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7285 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7290			  
7290			  
7290			  
7290			; mapping for a simple straight through breadboard layout  
7290			  
7290			;.matrix_to_char:  
7290			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7290			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7290			;		db "asdfghjkl",KEY_CR,0  
7290			;		db "qwertyuiop",0  
7290			;		 db "1234567890",0  
7290			;.matrix_to_shift:  
7290			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7290			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7290			;		db "ASDFGHJKL",KEY_CR,0  
7290			;		db "QWERTYUIOP",0  
7290			;		 db "!",'"',"#$%^&*()",0  
7290			;.matrix_to_symbolshift:  
7290			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7290			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7290			;		db "_?*fghjk=",KEY_CR,0  
7290			;		db "-/+*[]{}@#",0  
7290			;		 db "1234567890",0  
7290			  
7290			;.matrix_to_char: db "D#0*C987B654A321"  
7290			  
7290			  
7290				  
7290			  
7290			; add cin and cin_wait  
7290			  
7290 cd a1 72		cin_wait: 	call cin  
7293						if DEBUG_KEYCINWAIT  
7293							push af  
7293							  
7293							ld hl,key_repeat_ct  
7293							ld (hl),a  
7293							inc hl  
7293							call hexout  
7293							ld hl,key_repeat_ct+3  
7293							ld a,0  
7293							ld (hl),a  
7293			  
7293							    LD   A, kLCD_Line1+11  
7293							    CALL fLCD_Pos       ;Position cursor to location in A  
7293							    LD   DE, key_repeat_ct  
7293							    ;LD   DE, MsgHello  
7293							    CALL fLCD_Str       ;Display string pointed to by DE  
7293			  
7293			  
7293			  
7293							pop af  
7293						endif  
7293 fe 00			cp 0  
7295 28 f9			jr z, cin_wait   ; block until key press  
7297			  
7297							if DEBUG_KEYCINWAIT  
7297								push af  
7297			  
7297								ld a, 'A'	  
7297								ld hl,key_repeat_ct  
7297								ld (hl),a  
7297								inc hl  
7297								ld a,0  
7297								ld (hl),a  
7297			  
7297								    LD   A, kLCD_Line2+11  
7297								    CALL fLCD_Pos       ;Position cursor to location in A  
7297								    LD   DE, key_repeat_ct  
7297								    ;LD   DE, MsgHello  
7297								    CALL fLCD_Str       ;Display string pointed to by DE  
7297			  
7297							call delay500ms  
7297			  
7297								pop af  
7297							endif  
7297 f5				push af   ; save key pressed  
7298			  
7298			.cin_wait1:	  
7298							if DEBUG_KEYCINWAIT  
7298								push af  
7298			  
7298								ld a, 'b'	  
7298								ld hl,key_repeat_ct  
7298								ld (hl),a  
7298								inc hl  
7298								ld a,0  
7298								ld (hl),a  
7298			  
7298								    LD   A, kLCD_Line2+11  
7298								    CALL fLCD_Pos       ;Position cursor to location in A  
7298								    LD   DE, key_repeat_ct  
7298								    ;LD   DE, MsgHello  
7298								    CALL fLCD_Str       ;Display string pointed to by DE  
7298			  
7298			  
7298							call delay500ms  
7298			  
7298								pop af  
7298							endif  
7298			  
7298 cd a1 72		call cin  
729b fe 00			cp 0  
729d 20 f9			jr nz, .cin_wait1  	; wait for key release  
729f			if DEBUG_KEYCINWAIT  
729f				push af  
729f			  
729f				ld a, '3'	  
729f				ld hl,key_repeat_ct  
729f				ld (hl),a  
729f				inc hl  
729f				ld a,0  
729f				ld (hl),a  
729f			  
729f			            LD   A, kLCD_Line2+11  
729f			            CALL fLCD_Pos       ;Position cursor to location in A  
729f			            LD   DE, key_repeat_ct  
729f			            ;LD   DE, MsgHello  
729f			            CALL fLCD_Str       ;Display string pointed to by DE  
729f			  
729f			  
729f			call delay500ms  
729f			  
729f				pop af  
729f			endif  
729f			  
729f f1				pop af   ; get key  
72a0 c9				ret  
72a1			  
72a1			  
72a1 cd b5 72		cin: 	call .mtoc  
72a4			  
72a4			if DEBUG_KEYCIN  
72a4				push af  
72a4				  
72a4				ld hl,key_repeat_ct  
72a4				ld (hl),a  
72a4				inc hl  
72a4				call hexout  
72a4				ld hl,key_repeat_ct+3  
72a4				ld a,0  
72a4				ld (hl),a  
72a4			  
72a4			            LD   A, kLCD_Line3+15  
72a4			            CALL fLCD_Pos       ;Position cursor to location in A  
72a4			            LD   DE, key_repeat_ct  
72a4			            ;LD   DE, MsgHello  
72a4			            CALL fLCD_Str       ;Display string pointed to by DE  
72a4			  
72a4			  
72a4			call delay500ms  
72a4			  
72a4				pop af  
72a4			endif  
72a4			  
72a4			  
72a4				; no key held  
72a4 fe 00			cp 0  
72a6 c8				ret z  
72a7			  
72a7			if DEBUG_KEYCIN  
72a7				push af  
72a7			  
72a7				ld a, '1'	  
72a7				ld hl,key_repeat_ct  
72a7				ld (hl),a  
72a7				inc hl  
72a7				ld a,0  
72a7				ld (hl),a  
72a7			  
72a7			            LD   A, kLCD_Line4+15  
72a7			            CALL fLCD_Pos       ;Position cursor to location in A  
72a7			            LD   DE, key_repeat_ct  
72a7			            ;LD   DE, MsgHello  
72a7			            CALL fLCD_Str       ;Display string pointed to by DE  
72a7			  
72a7			  
72a7			call delay500ms  
72a7			  
72a7				pop af  
72a7			endif  
72a7			  
72a7				; stop key bounce  
72a7			  
72a7 32 c6 fd			ld (key_held),a		 ; save it  
72aa 47				ld b, a  
72ab			  
72ab c5			.cina1:	push bc  
72ac			if DEBUG_KEYCIN  
72ac				push af  
72ac			  
72ac				ld hl,key_repeat_ct  
72ac				inc hl  
72ac				call hexout  
72ac				ld hl,key_repeat_ct+3  
72ac				ld a,0  
72ac				ld (hl),a  
72ac				ld hl,key_repeat_ct  
72ac				ld a, '2'	  
72ac				ld (hl),a  
72ac			  
72ac			            LD   A, kLCD_Line4+15  
72ac			            CALL fLCD_Pos       ;Position cursor to location in A  
72ac			            LD   DE, key_repeat_ct  
72ac			            ;LD   DE, MsgHello  
72ac			            CALL fLCD_Str       ;Display string pointed to by DE  
72ac			  
72ac				pop af  
72ac			endif  
72ac cd b5 72			call .mtoc  
72af c1				pop bc  
72b0 b8				cp b  
72b1 28 f8			jr z, .cina1  
72b3 78				ld a,b		  
72b4			if DEBUG_KEYCIN  
72b4				push af  
72b4			  
72b4				ld hl,key_repeat_ct  
72b4				inc hl  
72b4				call hexout  
72b4				ld hl,key_repeat_ct+3  
72b4				ld a,0  
72b4				ld (hl),a  
72b4				ld hl,key_repeat_ct  
72b4				ld a, '3'	  
72b4				ld (hl),a  
72b4			  
72b4			            LD   A, kLCD_Line4+15  
72b4			            CALL fLCD_Pos       ;Position cursor to location in A  
72b4			            LD   DE, key_repeat_ct  
72b4			            ;LD   DE, MsgHello  
72b4			            CALL fLCD_Str       ;Display string pointed to by DE  
72b4			  
72b4				pop af  
72b4			endif  
72b4 c9				ret  
72b5			  
72b5			; detect keyboard modifier key press and apply new overlay to the face key held  
72b5			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
72b5			  
72b5			;.cin_map_modifier:   
72b5			;	ld a, (hl)  
72b5			;	and 255  
72b5			;	ret NZ		; modifier key not flagged  
72b5			;  
72b5			;	; get key face  
72b5			;  
72b5			;	ld b,(key_face_held)  
72b5			;  
72b5			;	ld b, key_cols * key_rows  
72b5			;  
72b5			;	push de  
72b5			;	pop hl  
72b5			;  
72b5			;.mmod1: ld a,(hl)   ; get map test  
72b5			;	cp b  
72b5			;	jr z, .mmod2  
72b5			;  
72b5			;  
72b5			;  
72b5			;.mmod2: inc hl    ;   
72b5			;  
72b5			;	  
72b5			;  
72b5			;	  
72b5			;  
72b5			;	ld hl,key_actual_pressed  
72b5			;	ld (hl),a,  
72b5			;	ret  
72b5			  
72b5			; map matrix key held to char on face of key  
72b5			  
72b5			.mtoc:  
72b5			  
72b5			; test decade counter strobes  
72b5			  
72b5			;.decadetest1:  
72b5			  
72b5			; reset counter  
72b5			;ld a, 128  
72b5			;out (portbdata),a  
72b5			  
72b5			  
72b5			;ld b, 5  
72b5			;.dec1:  
72b5			;ld a, 0  
72b5			;out (portbdata),a  
72b5			;call delay1s  
72b5			  
72b5			;ld a, 32  
72b5			;out (portbdata),a  
72b5			;call delay1s  
72b5			;call delay1s  
72b5			;call delay1s  
72b5			;  
72b5			;ld a, 64+32  
72b5			;out (portbdata),a  
72b5			;call delay1s  
72b5			;;djnz .dec1  
72b5			;  
72b5			;jp .decadetest1  
72b5			  
72b5			  
72b5			  
72b5			  
72b5			  
72b5			  
72b5			  
72b5			  
72b5			  
72b5			  
72b5				; scan keyboard matrix and generate raw scan map  
72b5 cd 48 73			call matrix  
72b8			  
72b8				; reuse c bit 0 left modifer button - ie shift  
72b8			        ; reuse c bit 1 for right modifer button - ie symbol shift  
72b8				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
72b8			  
72b8 0e 00			ld c, 0  
72ba			  
72ba				; TODO set flags for modifer key presses   
72ba				; TODO do a search for modifer key...  
72ba			  
72ba				;ld hl,keyscan_table_row4  
72ba 21 25 fe			ld hl,keyscan_table_row2  
72bd			  
72bd 7e				ld a, (hl)  
72be fe 23			cp '#'  
72c0 20 07			jr nz, .nextmodcheck  
72c2 cb c1			set 0, c  
72c4 21 22 72			ld hl, .matrix_to_shift  
72c7 18 21			jr .dokeymap  
72c9				; TODO for now igonre  
72c9			.nextmodcheck:  
72c9 21 1a fe			ld hl,keyscan_table_row3  
72cc			  
72cc 7e				ld a, (hl)  
72cd fe 23			cp '#'  
72cf 20 07			jr nz, .nextmodcheck2  
72d1 cb c9			set 1, c   
72d3 21 59 72			ld hl, .matrix_to_symbolshift  
72d6 18 12			jr .dokeymap  
72d8			.nextmodcheck2:  
72d8 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
72db			  
72db 7e				ld a, (hl)  
72dc fe 23			cp '#'  
72de 20 07			jr nz, .donemodcheck  
72e0 cb c9			set 1, c   
72e2 21 22 72			ld hl, .matrix_to_shift  
72e5 18 03			jr .dokeymap  
72e7			  
72e7				; no modifer found so just map to normal keys  
72e7				; get mtoc map matrix to respective keys  
72e7			;	ld hl, .matrix_to_char  
72e7			;	ld hl, .matrix_to_char  
72e7			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
72e7			;	ld a, KEY_SHIFT  
72e7			;	call findchar  
72e7			;  
72e7			;	; got offset to key modifer in b  
72e7			;  
72e7			;	ld hl,keyscan_table_row5  
72e7			;  
72e7			;	ld a,b  
72e7			;	call addatohl  
72e7			;	ld a,(hl)  
72e7			;  
72e7			;	cp '#'  
72e7			;	jr nz, .nextmodcheck  
72e7			;	set 0, c  
72e7			;	ld hl, .matrix_to_char  
72e7			;	jr .dokeymap  
72e7			;	; TODO for now igonre  
72e7			;.nextmodcheck:  
72e7			;	ld hl, .matrix_to_symbolshift  
72e7			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
72e7			;	ld a, KEY_SYMBOLSHIFT  
72e7			;	call findchar  
72e7			;  
72e7			;  
72e7			;	; got offset to key modifer in b  
72e7			;  
72e7			;	ld hl,keyscan_table_row5  
72e7			;  
72e7			;	ld a,b  
72e7			;	call addatohl  
72e7			;	ld a,(hl)  
72e7			;  
72e7			;	cp '#'  
72e7			;	jr nz, .donemodcheck  
72e7			;	set 1, c   
72e7			;	ld hl, .matrix_to_symbolshift  
72e7			;	jr .dokeymap  
72e7			  
72e7			  
72e7			  
72e7			.donemodcheck:  
72e7				; no modifer found so just map to normal keys  
72e7				; get mtoc map matrix to respective keys  
72e7 21 eb 71			ld hl, .matrix_to_char  
72ea			  
72ea			.dokeymap:  
72ea				;ld (key_fa), c   
72ea cd 03 73			call .mapkeys  
72ed			  
72ed			  
72ed			if DEBUG_KEY  
72ed			  
72ed			; Display text on first line  
72ed			            LD   A, kLCD_Line1  
72ed			            CALL fLCD_Pos       ;Position cursor to location in A  
72ed			            LD   DE, keyscan_table_row1  
72ed			            ;LD   DE, MsgHello  
72ed			            CALL fLCD_Str       ;Display string pointed to by DE  
72ed			  
72ed			; Display text on second line  
72ed			            LD   A, kLCD_Line2  
72ed			            CALL fLCD_Pos       ;Position cursor to location in A  
72ed			            LD   DE, keyscan_table_row2  
72ed			            CALL fLCD_Str       ;Display string pointed to by DE  
72ed			            LD   A, kLCD_Line3  
72ed			            CALL fLCD_Pos       ;Position cursor to location in A  
72ed			            LD   DE, keyscan_table_row3  
72ed			            CALL fLCD_Str       ;Display string pointed to by DE  
72ed			            LD   A, kLCD_Line4  
72ed			            CALL fLCD_Pos       ;Position cursor to location in A  
72ed			            LD   DE, keyscan_table_row4  
72ed			            CALL fLCD_Str       ;Display string pointed to by DE  
72ed			            LD   A, kLCD_Line1+10  
72ed			            CALL fLCD_Pos       ;Position cursor to location in A  
72ed			            LD   DE, keyscan_table_row5  
72ed			            CALL fLCD_Str       ;Display string pointed to by DE  
72ed			  
72ed				;call delay250ms  
72ed			endif  
72ed			;	jp testkey  
72ed			  
72ed			; get first char reported  
72ed			  
72ed 21 04 fe			ld hl,keyscan_table_row5  
72f0			  
72f0				;ld b, 46   ; 30 keys to remap + 8 nulls   
72f0 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
72f2			.findkey:  
72f2 7e				ld a,(hl)  
72f3 fe 00			cp 0  
72f5 28 04			jr z, .nextkey  
72f7 fe 7e			cp KEY_MATRIX_NO_PRESS  
72f9 20 06			jr nz, .foundkey  
72fb			.nextkey:  
72fb 23				inc hl  
72fc 10 f4			djnz .findkey  
72fe 3e 00			ld a,0  
7300 c9				ret  
7301			.foundkey:  
7301 7e				ld a,(hl)  
7302 c9				ret  
7303				  
7303			  
7303			; convert the raw key map given hl for destination key  
7303			.mapkeys:  
7303 11 04 fe			ld de,keyscan_table_row5  
7306			  
7306 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7308			.remap:  
7308 1a				ld a,(de)  
7309 fe 23			cp '#'  
730b 20 02			jr nz, .remapnext  
730d				;CALLMONITOR  
730d 7e				ld a,(hl)  
730e 12				ld (de),a  
730f			  
730f			  
730f			  
730f			.remapnext:  
730f 23				inc hl  
7310 13				inc de  
7311 10 f5			djnz .remap  
7313				  
7313 c9				ret  
7314			  
7314			  
7314			  
7314			.mtocold2:  
7314			  
7314			;	; flag if key D is held down and remove from reporting  
7314			;	ld bc, .key_map_fd    
7314			;	ld hl, keyscan_table  
7314			;	ld de, key_fd  
7314			;	call .key_shift_hold  
7314			;	cp 255  
7314			;	jr z, .cinmap  
7314			;	; flag if key C is held down and remove from reporting  
7314			;	ld bc, .key_map_fc    
7314			;	ld hl, keyscan_table+key_cols  
7314			;	ld de, key_fc  
7314			;	call .key_shift_hold  
7314			;	cp 255  
7314			;	jr z, .cinmap  
7314			;	; flag if key B is held down and remove from reporting  
7314			;	ld bc, .key_map_fb    
7314			;	ld hl, keyscan_table+(key_cols*2)  
7314			;	ld de, key_fb  
7314			;	call .key_shift_hold  
7314			;	cp 255  
7314			;	jr z, .cinmap  
7314			;	; flag if key A is held down and remove from reporting  
7314			;	ld bc, .key_map_fa    
7314			;	ld hl, keyscan_table+(key_cols*3)  
7314			;	ld de, key_fa  
7314			;	call .key_shift_hold  
7314			;	cp 255  
7314			;	jr z, .cinmap  
7314			  
7314 11 eb 71			ld de, .matrix_to_char  
7317			  
7317			  
7317			.cinmap1:   
7317				if DEBUG_KEY  
7317			            LD   A, kLCD_Line4  
7317			            CALL fLCD_Pos       ;Position cursor to location in A  
7317					push de  
7317			            LD   DE, keyscan_table  
7317			            CALL fLCD_Str       ;Display string pointed to by DE  
7317					pop de  
7317				endif  
7317			  
7317				; scan key matrix table for any held key  
7317			  
7317				; de holds either the default matrix or one selected above  
7317			  
7317 21 d1 fd			ld hl, keyscan_table  
731a 06 32			ld b,key_cols*key_rows  
731c			  
731c 7e			.cin11:	ld a,(hl)  
731d fe 23			cp '#'  
731f 28 08			jr z, .cinhit1  
7321 23				inc hl  
7322 13				inc de  
7323 05				dec b  
7324 20 f6			jr nz, .cin11  
7326				; no key found held  
7326 3e 00			ld a,0  
7328 c9				ret  
7329 d5			.cinhit1: push de  
732a e1				pop hl  
732b 7e				ld a,(hl)  
732c c9				ret  
732d			  
732d			; flag a control key is held   
732d			; hl is key pin, de is flag indicator  
732d			  
732d			.key_shift_hold1:  
732d c5				push bc  
732e 3e 01			ld a, 1  
7330 32 fc fa			ld (cursor_shape),a  
7333 06 00			ld b, 0  
7335 7e				ld a, (hl)  
7336 fe 2e			cp '.'  
7338 28 0a			jr z, .key_shift11  
733a 06 ff			ld b, 255  
733c 3e 2b			ld a, '+'    ; hide key from later scans  
733e 77				ld (hl),a  
733f 3e 02			ld a, 2  
7341 32 fc fa			ld (cursor_shape),a  
7344			.key_shift11:  
7344				; write flag indicator  
7344 78				ld a,b  
7345 12				ld (de),a  
7346			  
7346 d1				pop de    ; de now holds the key map ptr  
7347 c9				ret  
7348			  
7348				  
7348			  
7348			; scans keyboard matrix and flags key press in memory array	  
7348				  
7348			matrix:  
7348				;call matrix  
7348				; TODO optimise the code....  
7348			  
7348			  
7348			;ld hl, keyscan_table_row1  
7348			;ld de, keyscan_table_row1+1  
7348			;ld bc,46  
7348			;ld a,KEY_MATRIX_NO_PRESS  
7348			;ldir  
7348			  
7348			  
7348			  
7348			; reset counter  
7348 3e 80		ld a, 128  
734a d3 c1		out (portbdata),a  
734c			  
734c 06 0a		ld b, 10  
734e 0e 00		ld c, 0       ; current clock toggle  
7350			  
7350			.colscan:  
7350			  
7350			; set current column  
7350			; disable clock enable and set clock low  
7350			  
7350			;ld a, 0  
7350			;out (portbdata),a  
7350			  
7350			; For each column scan for switches  
7350			  
7350 c5			push bc  
7351 21 c7 fd		ld hl, keyscan_scancol  
7354 cd 5d 74		call .rowscan  
7357 c1			pop bc  
7358			  
7358			  
7358			; get back current column  
7358			  
7358			; translate the row scan  
7358			  
7358			;   
7358			; row 1  
7358			  
7358 78			ld a,b  
7359			  
7359 21 3a fe		LD   hl, keyscan_table_row1+10  
735c			  
735c cd e1 0f		call subafromhl  
735f			;call addatohl  
735f			  
735f 11 c7 fd		ld de, keyscan_scancol  
7362			  
7362 1a			ld a,(de)  
7363 77			ld (hl),a  
7364			  
7364			  
7364			  
7364			  
7364			; row 2  
7364			  
7364 78			ld a,b  
7365			  
7365 21 2f fe		LD   hl, keyscan_table_row2+10  
7368			  
7368			;call addatohl  
7368 cd e1 0f		call subafromhl  
736b			  
736b			  
736b 11 c8 fd		ld de, keyscan_scancol+1  
736e			  
736e 1a			ld a,(de)  
736f 77			ld (hl),a  
7370			  
7370			  
7370			; row 3  
7370			  
7370 78			ld a,b  
7371			  
7371 21 24 fe		LD   hl, keyscan_table_row3+10  
7374			  
7374			;call addatohl  
7374 cd e1 0f		call subafromhl  
7377			  
7377 11 c9 fd		ld de, keyscan_scancol+2  
737a			  
737a 1a			ld a,(de)  
737b 77			ld (hl),a  
737c			  
737c			  
737c			  
737c			; row 4  
737c			  
737c 78			ld a,b  
737d			  
737d 21 19 fe		LD   hl, keyscan_table_row4+10  
7380			  
7380			;call addatohl  
7380 cd e1 0f		call subafromhl  
7383			  
7383 11 ca fd		ld de, keyscan_scancol+3  
7386			  
7386 1a			ld a,(de)  
7387 77			ld (hl),a  
7388			  
7388			; row 5  
7388			  
7388 78			ld a,b  
7389			  
7389 21 0e fe		LD   hl, keyscan_table_row5+10  
738c			  
738c			;call addatohl  
738c cd e1 0f		call subafromhl  
738f			  
738f 11 cb fd		ld de, keyscan_scancol+4  
7392			  
7392 1a			ld a,(de)  
7393 77			ld (hl),a  
7394			  
7394			; handshake next column  
7394			  
7394			  
7394 3e 40		ld a, 64  
7396 d3 c1		out (portbdata),a  
7398			  
7398 3e 00		ld a, 0  
739a d3 c1		out (portbdata),a  
739c			  
739c			; toggle clk and move to next column  
739c			;ld a, 64  
739c			;cp c  
739c			;  
739c			;jr z, .coltoglow  
739c			;ld c, a  
739c			;jr .coltog  
739c			;.coltoglow:  
739c			;ld c, 0  
739c			;.coltog:  
739c			;ld a, c  
739c			;out (portbdata),a  
739c			  
739c 10 b2		djnz .colscan  
739e			  
739e 3e 0a		ld a,10  
73a0 21 30 fe		LD   hl, keyscan_table_row1  
73a3 cd cf 0f		call addatohl  
73a6 3e 00		ld a, 0  
73a8 77			ld (hl), a  
73a9			  
73a9			  
73a9 3e 0a		ld a,10  
73ab 21 25 fe		LD   hl, keyscan_table_row2  
73ae cd cf 0f		call addatohl  
73b1 3e 00		ld a, 0  
73b3 77			ld (hl), a  
73b4			  
73b4 3e 0a		ld a,10  
73b6 21 1a fe		LD   hl, keyscan_table_row3  
73b9 cd cf 0f		call addatohl  
73bc 3e 00		ld a, 0  
73be 77			ld (hl), a  
73bf			  
73bf 3e 0a		ld a,10  
73c1 21 0f fe		LD   hl, keyscan_table_row4  
73c4 cd cf 0f		call addatohl  
73c7 3e 00		ld a, 0  
73c9 77			ld (hl), a  
73ca			  
73ca 3e 0a		ld a,10  
73cc 21 04 fe		LD   hl, keyscan_table_row5  
73cf cd cf 0f		call addatohl  
73d2 3e 00		ld a, 0  
73d4 77			ld (hl), a  
73d5			  
73d5			if DEBUG_KEY_MATRIX  
73d5			  
73d5			; Display text on first line  
73d5			            LD   A, kLCD_Line1  
73d5			            CALL fLCD_Pos       ;Position cursor to location in A  
73d5			            LD   DE, keyscan_table_row1  
73d5			            ;LD   DE, MsgHello  
73d5			            CALL fLCD_Str       ;Display string pointed to by DE  
73d5			  
73d5			; Display text on second line  
73d5			            LD   A, kLCD_Line2  
73d5			            CALL fLCD_Pos       ;Position cursor to location in A  
73d5			            LD   DE, keyscan_table_row2  
73d5			            CALL fLCD_Str       ;Display string pointed to by DE  
73d5			            LD   A, kLCD_Line3  
73d5			            CALL fLCD_Pos       ;Position cursor to location in A  
73d5			            LD   DE, keyscan_table_row3  
73d5			            CALL fLCD_Str       ;Display string pointed to by DE  
73d5			            LD   A, kLCD_Line4  
73d5			            CALL fLCD_Pos       ;Position cursor to location in A  
73d5			            LD   DE, keyscan_table_row4  
73d5			            CALL fLCD_Str       ;Display string pointed to by DE  
73d5			            LD   A, kLCD_Line4+10  
73d5			            CALL fLCD_Pos       ;Position cursor to location in A  
73d5			            LD   DE, keyscan_table_row5  
73d5			            CALL fLCD_Str       ;Display string pointed to by DE  
73d5			  
73d5			;call delay250ms  
73d5				jp matrix  
73d5			endif  
73d5 c9			ret  
73d6			  
73d6			; using decade counter....  
73d6			  
73d6			  
73d6			; TODO reset decade counter to start of scan  
73d6			  
73d6			; reset 15  
73d6			; clock 14  
73d6			; ce 13  
73d6			  
73d6			; 1 - q5  
73d6			; 2 - q1  
73d6			; 3 - q0  
73d6			; 4 - q2  
73d6			; 5 - q6  
73d6			; 6 - q7  
73d6			; 7 - q3  
73d6			; 8 - vss  
73d6			; 9 - q8  
73d6			; 10 - q4  
73d6			; 11 - q9  
73d6			; 12 - cout  
73d6			; 16 - vdd  
73d6			  
73d6			; clock      ce       reset     output  
73d6			; 0          x        0         n  
73d6			; x          1        0         n  
73d6			; x          x        1         q0  
73d6			; rising     0        0         n+1  
73d6			; falling    x        0         n  
73d6			; x          rising   0         n  
73d6			; 1          falling  0         x+1  
73d6			;  
73d6			; x = dont care, if n < 5 carry = 1 otherwise 0  
73d6			  
73d6			;   
73d6			; reset   
73d6			; 13=0, 14=0, 15=1 .. 15=0  
73d6			;  
73d6			; handshake line  
73d6			; 14=1.... read line 14=0  
73d6			  
73d6			  
73d6			  
73d6			  
73d6			  
73d6			; TODO hand shake clock for next column scan  
73d6			; TODO detect each row  
73d6			  
73d6			  
73d6			  
73d6			  
73d6			; reset 128  
73d6			; clock 64  
73d6			; ce 32  
73d6			  
73d6			  
73d6			.cyclestart:  
73d6			  
73d6			; reset counter  
73d6 3e 80		ld a, 128  
73d8 d3 c1		out (portbdata),a  
73da			  
73da			; loop leds  
73da 06 0a		ld b,10  
73dc			  
73dc			.cycle1:  
73dc c5			push bc  
73dd 3e 00		ld a, 0  
73df d3 c1		out (portbdata),a  
73e1 cd d2 0c		call delay250ms  
73e4			  
73e4 3e 40		ld a, 64  
73e6 d3 c1		out (portbdata),a  
73e8 cd d2 0c		call delay250ms  
73eb			  
73eb 3e 00		ld a, 0  
73ed d3 c1		out (portbdata),a  
73ef cd d2 0c		call delay250ms  
73f2			  
73f2 c1			pop bc  
73f3 10 e7		djnz .cycle1  
73f5			  
73f5			  
73f5 18 df		jr .cyclestart  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			; map matrix key held to char on face of key  
73f7			  
73f7			;.mtocold:  
73f7			;  
73f7			;  
73f7			;; reset counter  
73f7			;ld a, 128  
73f7			;out (portbdata),a  
73f7			;  
73f7			;  
73f7			;; scan keyboard row 1  
73f7			;ld a, 0  
73f7			;out (portbdata),a  
73f7			;;ld a, 64  
73f7			;;out (portbdata),a  
73f7			;  
73f7			;  
73f7			;	ld a, 128  
73f7			;	ld hl, keyscan_table  
73f7			;	call .rowscan  
73f7			;  
73f7			;;ld a, 0  
73f7			;;out (portbdata),a  
73f7			;ld a, 64  
73f7			;out (portbdata),a  
73f7			;  
73f7			;	ld a, 64  
73f7			;	ld hl, keyscan_table+key_cols  
73f7			;	call .rowscan  
73f7			;  
73f7			;ld a, 0  
73f7			;out (portbdata),a  
73f7			;;ld a, 64  
73f7			;;out (portbdata),a  
73f7			;	ld a, 32  
73f7			;	ld hl, keyscan_table+(key_cols*2)  
73f7			;	call .rowscan  
73f7			;  
73f7			;  
73f7			;;ld a, 0  
73f7			;;out (portbdata),a  
73f7			;ld a, 64  
73f7			;out (portbdata),a  
73f7			;  
73f7			;	ld a, 16  
73f7			;	ld hl, keyscan_table+(key_cols*3)  
73f7			;	call .rowscan  
73f7			;  
73f7			;  
73f7			;	; flag if key D is held down and remove from reporting  
73f7			;	ld bc, .key_map_fd    
73f7			;	ld hl, keyscan_table  
73f7			;	ld de, key_fd  
73f7			;	call .key_shift_hold  
73f7			;	cp 255  
73f7			;	jr z, .cinmap  
73f7			;	; flag if key C is held down and remove from reporting  
73f7			;	ld bc, .key_map_fc    
73f7			;	ld hl, keyscan_table+key_cols  
73f7			;	ld de, key_fc  
73f7			;	call .key_shift_hold  
73f7			;	cp 255  
73f7			;	jr z, .cinmap  
73f7			;	; flag if key B is held down and remove from reporting  
73f7			;	ld bc, .key_map_fb    
73f7			;	ld hl, keyscan_table+(key_cols*2)  
73f7			;	ld de, key_fb  
73f7			;	call .key_shift_hold  
73f7			;	cp 255  
73f7			;	jr z, .cinmap  
73f7			;	; flag if key A is held down and remove from reporting  
73f7			;	ld bc, .key_map_fa    
73f7			;	ld hl, keyscan_table+(key_cols*3)  
73f7			;	ld de, key_fa  
73f7			;	call .key_shift_hold  
73f7			;	cp 255  
73f7			;	jr z, .cinmap  
73f7			;  
73f7			;	ld de, .matrix_to_char  
73f7			;  
73f7			;  
73f7			;.cinmap:   
73f7			;	if DEBUG_KEY  
73f7			;            LD   A, kLCD_Line4  
73f7			;            CALL fLCD_Pos       ;Position cursor to location in A  
73f7			;		push de  
73f7			;            LD   DE, keyscan_table  
73f7			;            CALL fLCD_Str       ;Display string pointed to by DE  
73f7			;		pop de  
73f7			;	endif  
73f7			  
73f7				; scan key matrix table for any held key  
73f7			  
73f7				; de holds either the default matrix or one selected above  
73f7			  
73f7			;	ld hl, keyscan_table  
73f7			;	ld b,key_cols*key_rows  
73f7			;  
73f7			;.cin1:	ld a,(hl)  
73f7			;	cp '#'  
73f7			;	jr z, .cinhit  
73f7			;	inc hl  
73f7			;	inc de  
73f7			;	dec b  
73f7			;	jr nz, .cin1  
73f7			;	; no key found held  
73f7			;	ld a,0  
73f7			;	ret  
73f7			;.cinhit: push de  
73f7			;	pop hl  
73f7			;	ld a,(hl)  
73f7			;	ret  
73f7			  
73f7			; flag a control key is held   
73f7			; hl is key pin, de is flag indicator  
73f7			  
73f7			;.key_shift_hold:  
73f7			;	push bc  
73f7			;	ld a, 1  
73f7			;	ld (cursor_shape),a  
73f7			;	ld b, 0  
73f7			;	ld a, (hl)  
73f7			;	cp '.'  
73f7			;	jr z, .key_shift1  
73f7			;	ld b, 255  
73f7			;	ld a, '+'    ; hide key from later scans  
73f7			;	ld (hl),a  
73f7			;	ld a, 2  
73f7			;	ld (cursor_shape),a  
73f7			;.key_shift1:  
73f7			;	; write flag indicator  
73f7			;	ld a,b  
73f7			;	ld (de),a  
73f7			;  
73f7			;	pop de    ; de now holds the key map ptr  
73f7			;	ret  
73f7			  
73f7				  
73f7				  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			;	push hl  
73f7			;	push de  
73f7			;	push bc  
73f7			;	call keyscan  
73f7			;	; map key matrix to ascii value of key face  
73f7			;  
73f7			;	ld hl, key_face_map  
73f7			;	ld de, keyscan_table  
73f7			;  
73f7			;	; get how many keys to look at  
73f7			;	ld b, keyscan_table_len  
73f7			;	  
73f7			;  
73f7			;	; at this stage fall out on first key hit  
73f7			;	; TODO handle multiple key press  
73f7			;  
73f7			;map1:	ld a,(hl)  
73f7			;	cp '#'  
73f7			;	jr z, keyhit  
73f7			;	inc hl  
73f7			;	inc de  
73f7			;	dec b  
73f7			;	jr nz, map1  
73f7			;nohit:	ld a, 0  
73f7			;	jr keydone  
73f7			;keyhit: push de  
73f7			;	pop hl  
73f7			;	ld a,(hl)  
73f7			;keydone:  
73f7			;	push bc  
73f7			;	push de  
73f7			; 	push hl  
73f7			;	ret   
73f7			;  
73f7			  
73f7			  
73f7			  
73f7			  
73f7			; scan physical key matrix  
73f7			  
73f7			  
73f7			;keyscan:  
73f7			;  
73f7			;; for each key_row use keyscanr bit mask for out  
73f7			;; then read in for keyscanc bitmask  
73f7			;; save result of row scan to keyscantable  
73f7			;  
73f7			;; scan keyboard row 1  
73f7			;  
73f7			;	ld b, key_rows  
73f7			;	ld hl, key_scanr  
73f7			;	ld de, keyscan_table  
73f7			;  
73f7			;rowloop:  
73f7			;  
73f7			;	ld a,(hl)		; out bit mask to energise keyboard row  
73f7			;	call rowscan  
73f7			;	inc hl  
73f7			;	dec b  
73f7			;	jr nz, rowloop  
73f7			;  
73f7			;	ret  
73f7			;  
73f7			;  
73f7			;; pass a out bitmask, b row number  
73f7			;arowscan:   
73f7			;	push bc  
73f7			;  
73f7			;	ld d, b  
73f7			;  
73f7			;	; calculate buffer location for this row  
73f7			;  
73f7			;	ld hl, keyscan_table	  
73f7			;kbufr:  ld e, key_cols  
73f7			;kbufc:	inc hl  
73f7			;	dec e  
73f7			;	jr nz, kbufc  
73f7			;	dec d  
73f7			;	jr nz, kbufr  
73f7			;  
73f7			;	; energise row and read columns  
73f7			;  
73f7			;	out (portbdata),a  
73f7			;	in a,(portbdata)  
73f7			;	ld c,a  
73f7			;  
73f7			;  
73f7			;	; save buffer loc  
73f7			;  
73f7			;	ld (keybufptr), hl  
73f7			;  
73f7			;	ld hl, key_scanc  
73f7			;	ld d, key_cols  
73f7			;  
73f7			;	; for each column check each bit mask  
73f7			;  
73f7			;colloop:  
73f7			;	  
73f7			;  
73f7			;	; reset flags for the row   
73f7			;  
73f7			;	ld b,'.'  
73f7			;	and (hl)  
73f7			;	jr z, maskskip  
73f7			;	ld b,'#'  
73f7			;maskskip:  
73f7			;	; save  key state  
73f7			;	push hl  
73f7			;	ld hl, (keybufptr)  
73f7			;	ld (hl), b  
73f7			;	inc hl  
73f7			;	ld (keybufptr), hl  
73f7			;  
73f7			;	; move to next bit mask  
73f7			;	pop hl  
73f7			;	inc hl  
73f7			;  
73f7			;	dec d  
73f7			;	jr nz, colloop  
73f7			;  
73f7			;	ret  
73f7			;  
73f7			;  
73f7			;;  
73f7			; lcd functions  
73f7			;  
73f7			;  
73f7			  
73f7			;if DEBUG_KEY_MATRIX  
73f7			  
73f7			; test function to display hardware view of matrix state  
73f7			  
73f7			matrixold:  
73f7			  
73f7			  
73f7			  
73f7			; reset counter  
73f7 3e 80		ld a, 128  
73f9 d3 c1		out (portbdata),a  
73fb			; scan keyboard row 1  
73fb 3e 00		ld a, 0  
73fd d3 c1		out (portbdata),a  
73ff			;ld a, 64  
73ff			;out (portbdata),a  
73ff 3e 80			ld a, 128  
7401 21 30 fe			ld hl, keyscan_table_row1  
7404 cd 5d 74			call .rowscan  
7407			  
7407			;ld a, 0  
7407			;out (portbdata),a  
7407 3e 40		ld a, 64  
7409 d3 c1		out (portbdata),a  
740b 3e 40			ld a, 64  
740d 21 25 fe			ld hl, keyscan_table_row2  
7410 cd 5d 74			call .rowscan  
7413			  
7413 3e 00		ld a, 0  
7415 d3 c1		out (portbdata),a  
7417			;ld a, 64  
7417			;out (portbdata),a  
7417 3e 20			ld a, 32  
7419 21 1a fe			ld hl, keyscan_table_row3  
741c cd 5d 74			call .rowscan  
741f			  
741f			;ld a, 0  
741f			;out (portbdata),a  
741f 3e 40		ld a, 64  
7421 d3 c1		out (portbdata),a  
7423 3e 10			ld a, 16  
7425 21 0f fe			ld hl, keyscan_table_row4  
7428 cd 5d 74			call .rowscan  
742b			  
742b			; Display text on first line  
742b 3e 00		            LD   A, kLCD_Line1  
742d cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7430 11 30 fe		            LD   DE, keyscan_table_row1  
7433			            ;LD   DE, MsgHello  
7433 cd 87 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7436			  
7436			; Display text on second line  
7436 3e 28		            LD   A, kLCD_Line2  
7438 cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
743b 11 25 fe		            LD   DE, keyscan_table_row2  
743e cd 87 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7441 3e 50		            LD   A, kLCD_Line3  
7443 cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7446 11 1a fe		            LD   DE, keyscan_table_row3  
7449 cd 87 70		            CALL fLCD_Str       ;Display string pointed to by DE  
744c 3e 78		            LD   A, kLCD_Line4  
744e cd 65 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7451 11 0f fe		            LD   DE, keyscan_table_row4  
7454 cd 87 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7457			  
7457 cd d2 0c			call delay250ms  
745a c3 48 73			jp matrix  
745d			  
745d			; pass de as row display flags  
745d			.rowscan:   
745d			;	out (portbdata),a  
745d db c1			in a,(portbdata)  
745f 4f				ld c,a  
7460				; reset flags for the row   
7460 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7462 e6 01			and 1  
7464 28 02			jr z, .p1on  
7466 06 23			ld b,'#'  
7468			.p1on:  
7468 70				ld (hl), b  
7469 23				inc hl  
746a			  
746a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
746c 79				ld a,c  
746d e6 02			and 2  
746f			;	bit 0,a  
746f 28 02			jr z, .p2on  
7471 06 23			ld b,'#'  
7473			.p2on:  
7473 70				ld (hl), b  
7474 23				inc hl  
7475			;  
7475 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7477 79				ld a,c  
7478 e6 04			and 4  
747a			;;	bit 0,a  
747a 28 02			jr z, .p3on  
747c 06 23			ld b,'#'  
747e			.p3on:  
747e 70				ld (hl), b  
747f 23				inc hl  
7480			;;  
7480 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7482			;;	bit 0,a  
7482 79				ld a,c  
7483 e6 08			and 8  
7485 28 02			jr z, .p4on  
7487 06 23			ld b,'#'  
7489			.p4on:  
7489 70				ld (hl), b  
748a 23				inc hl  
748b			  
748b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
748d			;;	bit 0,a  
748d 79				ld a,c  
748e e6 10			and 16  
7490 28 02			jr z, .p5on  
7492 06 23			ld b,'#'  
7494			.p5on:  
7494 70				ld (hl), b  
7495 23				inc hl  
7496			; zero term  
7496 06 00			ld b,0  
7498 70				ld (hl), b  
7499			  
7499 c9			.rscandone: ret  
749a			  
749a			;addatohl:  
749a			;  
749a			 ;add   a, l    ; A = A+L  
749a			  ;  ld    l, a    ; L = A+L  
749a			   ; adc   a, h    ; A = A+L+H+carry  
749a			   ; sub   l       ; A = H+carry  
749a			   ; ld    h, a    ; H = H+carry  
749a			  
749a			;ret  
749a			; eof  
# End of file firmware_key_5x10.asm
749a			;include "firmware_key_4x10.asm" 
749a			 
749a			heap_size:    equ heap_end - heap_start 
749a			;eof 
# End of file os_mega.asm
749a
