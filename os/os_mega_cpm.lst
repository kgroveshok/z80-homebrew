# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 0f 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 99 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 99 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 99 09				call clear_display  
0123			  
0123			  
0123 cd c8 57				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd b6 58			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 69 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd bc 09			call update_display  
0132 cd 0e 09			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 9e 09			call fill_display  
013a cd bc 09			call update_display  
013d cd 0e 09			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 9e 09			call fill_display  
0145 cd bc 09			call update_display  
0148 cd 0e 09			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 9e 09			call fill_display  
0150 cd bc 09			call update_display  
0153 cd 0e 09			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd ac 09			call str_at_display  
015e cd bc 09			call update_display  
0161			  
0161			  
0161 cd 0e 09			call delay1s  
0164 cd 0e 09			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd ac 09			call str_at_display  
016f cd bc 09			call update_display  
0172 cd 0e 09			call delay1s  
0175 cd 0e 09			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 39 14			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 39 14			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d6 04			call storage_findnextid 
0205			 
0205 cd ef 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 39 14			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 39 14			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 39 14			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 39 14			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 39 14			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd d1 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd 39 14			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 39 14			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd f3 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd f3 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd c6 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd f3 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd f3 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd c6 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 39 14			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd 39 14			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd 39 14			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd 39 14			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d6 04			call storage_findnextid 
0416 cd ef 0b			call ishlzero 
0419 c8				ret z 
041a			 
041a e5				push hl 
041b			 
041b				; TODO check file not found 
041b			 
041b 11 65 eb			ld de, store_page 
041e cd b1 01			call storage_read_block 
0421			 
0421					if DEBUG_FORTH_WORDS 
0421						DMARK "ER1" 
0421 f5				push af  
0422 3a 36 04			ld a, (.dmark)  
0425 32 7a ee			ld (debug_mark),a  
0428 3a 37 04			ld a, (.dmark+1)  
042b 32 7b ee			ld (debug_mark+1),a  
042e 3a 38 04			ld a, (.dmark+2)  
0431 32 7c ee			ld (debug_mark+2),a  
0434 18 03			jr .pastdmark  
0436 ..			.dmark: db "ER1"  
0439 f1			.pastdmark: pop af  
043a			endm  
# End of macro DMARK
043a						CALLMONITOR 
043a cd 39 14			call break_point_state  
043d				endm  
# End of macro CALLMONITOR
043d					endif 
043d 3a 65 eb			ld a, (store_page)	; get file id 
0440 32 5e eb			ld (store_tmpid), a 
0443			 
0443 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0446 32 5d eb			ld (store_tmpext), a 
0449			 
0449				; wipe file header 
0449			 
0449 e1				pop hl 
044a 3e 00			ld a, 0 
044c 32 65 eb			ld (store_page), a 
044f 32 66 eb			ld (store_page+1),a 
0452 11 65 eb			ld de, store_page 
0455					if DEBUG_FORTH_WORDS 
0455						DMARK "ER2" 
0455 f5				push af  
0456 3a 6a 04			ld a, (.dmark)  
0459 32 7a ee			ld (debug_mark),a  
045c 3a 6b 04			ld a, (.dmark+1)  
045f 32 7b ee			ld (debug_mark+1),a  
0462 3a 6c 04			ld a, (.dmark+2)  
0465 32 7c ee			ld (debug_mark+2),a  
0468 18 03			jr .pastdmark  
046a ..			.dmark: db "ER2"  
046d f1			.pastdmark: pop af  
046e			endm  
# End of macro DMARK
046e						CALLMONITOR 
046e cd 39 14			call break_point_state  
0471				endm  
# End of macro CALLMONITOR
0471					endif 
0471 cd 16 02			call storage_write_block 
0474			 
0474			 
0474				; wipe file extents 
0474			 
0474 3a 5d eb			ld a, (store_tmpext) 
0477 47				ld b, a 
0478			 
0478			.eraext:	  
0478 c5				push bc 
0479			 
0479 21 40 00			ld hl, STORE_BLOCK_PHY 
047c 3a 5e eb			ld a,(store_tmpid) 
047f 5f				ld e, a 
0480 50				ld d, b	 
0481					if DEBUG_FORTH_WORDS 
0481						DMARK "ER3" 
0481 f5				push af  
0482 3a 96 04			ld a, (.dmark)  
0485 32 7a ee			ld (debug_mark),a  
0488 3a 97 04			ld a, (.dmark+1)  
048b 32 7b ee			ld (debug_mark+1),a  
048e 3a 98 04			ld a, (.dmark+2)  
0491 32 7c ee			ld (debug_mark+2),a  
0494 18 03			jr .pastdmark  
0496 ..			.dmark: db "ER3"  
0499 f1			.pastdmark: pop af  
049a			endm  
# End of macro DMARK
049a						CALLMONITOR 
049a cd 39 14			call break_point_state  
049d				endm  
# End of macro CALLMONITOR
049d					endif 
049d cd d6 04			call storage_findnextid 
04a0			 
04a0 e5				push hl 
04a1 11 65 eb			ld de, store_page 
04a4 cd b1 01			call storage_read_block 
04a7			 
04a7				; free block	 
04a7			 
04a7 3e 00			ld a, 0 
04a9 32 65 eb			ld (store_page), a 
04ac 32 66 eb			ld (store_page+1),a 
04af 11 65 eb			ld de, store_page 
04b2 e1				pop hl 
04b3					if DEBUG_FORTH_WORDS 
04b3						DMARK "ER4" 
04b3 f5				push af  
04b4 3a c8 04			ld a, (.dmark)  
04b7 32 7a ee			ld (debug_mark),a  
04ba 3a c9 04			ld a, (.dmark+1)  
04bd 32 7b ee			ld (debug_mark+1),a  
04c0 3a ca 04			ld a, (.dmark+2)  
04c3 32 7c ee			ld (debug_mark+2),a  
04c6 18 03			jr .pastdmark  
04c8 ..			.dmark: db "ER4"  
04cb f1			.pastdmark: pop af  
04cc			endm  
# End of macro DMARK
04cc						CALLMONITOR 
04cc cd 39 14			call break_point_state  
04cf				endm  
# End of macro CALLMONITOR
04cf					endif 
04cf cd 16 02			call storage_write_block 
04d2			 
04d2 c1				pop bc 
04d3 10 a3			djnz .eraext 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			; Find Free Block 
04d6			; --------------- 
04d6			; 
04d6			; With current bank 
04d6			;  
04d6			; From given starting logical block 
04d6			;    Read block  
04d6			;    If no file id 
04d6			;         Return block id 
04d6			 
04d6			 
04d6			; hl starting page number 
04d6			; hl contains free page number or zero if no pages free 
04d6			; e contains the file id to locate 
04d6			; d contains the block number 
04d6			 
04d6			; TODO change to find file id and use zero for free block 
04d6			 
04d6			storage_findnextid: 
04d6			 
04d6				; now locate first 0 page to mark as a free block 
04d6			 
04d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d8			;	ld hl, STORE_BLOCK_PHY 
04d8			 
04d8					if DEBUG_FORTH_WORDS 
04d8					DMARK "FNI" 
04d8 f5				push af  
04d9 3a ed 04			ld a, (.dmark)  
04dc 32 7a ee			ld (debug_mark),a  
04df 3a ee 04			ld a, (.dmark+1)  
04e2 32 7b ee			ld (debug_mark+1),a  
04e5 3a ef 04			ld a, (.dmark+2)  
04e8 32 7c ee			ld (debug_mark+2),a  
04eb 18 03			jr .pastdmark  
04ed ..			.dmark: db "FNI"  
04f0 f1			.pastdmark: pop af  
04f1			endm  
# End of macro DMARK
04f1						CALLMONITOR 
04f1 cd 39 14			call break_point_state  
04f4				endm  
# End of macro CALLMONITOR
04f4					endif 
04f4			.ff1:   	 
04f4 e5					push hl 
04f5 c5					push bc 
04f6 d5					push de 
04f7 cd ae 01				call se_readbyte 
04fa 5f					ld e,a 
04fb 23					inc hl 
04fc cd ae 01				call se_readbyte 
04ff 57					ld d, a 
0500 e1					pop hl 
0501 e5					push hl 
0502 cd e4 0b				call cmp16 
0505 28 49				jr z, .fffound 
0507			 
0507 d1					pop de 
0508 c1					pop bc 
0509 e1					pop hl 
050a			 
050a					; is found? 
050a					;cp e 
050a					;ret z 
050a			 
050a 3e 40				ld a, STORE_BLOCK_PHY 
050c cd c6 0b				call addatohl 
050f 10 e3				djnz .ff1 
0511			 
0511 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0513			.ff2:   	 
0513			 
0513 e5					push hl 
0514 c5					push bc 
0515 d5					push de 
0516 cd ae 01				call se_readbyte 
0519 5f					ld e,a 
051a 23					inc hl 
051b cd ae 01				call se_readbyte 
051e 57					ld d, a 
051f			 
051f e1					pop hl 
0520 e5					push hl 
0521 cd e4 0b				call cmp16 
0524 28 2a				jr z, .fffound 
0526			 
0526 d1					pop de 
0527 c1					pop bc 
0528 e1					pop hl 
0529					; is found? 
0529					;cp e 
0529					;ret z 
0529			 
0529 3e 40				ld a, STORE_BLOCK_PHY 
052b cd c6 0b				call addatohl 
052e 10 e3				djnz .ff2 
0530			 
0530			 
0530					if DEBUG_FORTH_WORDS 
0530					DMARK "FN-" 
0530 f5				push af  
0531 3a 45 05			ld a, (.dmark)  
0534 32 7a ee			ld (debug_mark),a  
0537 3a 46 05			ld a, (.dmark+1)  
053a 32 7b ee			ld (debug_mark+1),a  
053d 3a 47 05			ld a, (.dmark+2)  
0540 32 7c ee			ld (debug_mark+2),a  
0543 18 03			jr .pastdmark  
0545 ..			.dmark: db "FN-"  
0548 f1			.pastdmark: pop af  
0549			endm  
# End of macro DMARK
0549					;	push af 
0549					;	ld a, 'n' 
0549					;	ld (debug_mark),a 
0549					;	pop af 
0549						CALLMONITOR 
0549 cd 39 14			call break_point_state  
054c				endm  
# End of macro CALLMONITOR
054c					endif 
054c				; no free marks! 
054c 21 00 00				ld hl, 0 
054f c9				ret 
0550			.fffound: 
0550				 
0550			 
0550 d1					pop de 
0551 c1					pop bc 
0552 e1					pop hl 
0553					if DEBUG_FORTH_WORDS 
0553					DMARK "FNF" 
0553 f5				push af  
0554 3a 68 05			ld a, (.dmark)  
0557 32 7a ee			ld (debug_mark),a  
055a 3a 69 05			ld a, (.dmark+1)  
055d 32 7b ee			ld (debug_mark+1),a  
0560 3a 6a 05			ld a, (.dmark+2)  
0563 32 7c ee			ld (debug_mark+2),a  
0566 18 03			jr .pastdmark  
0568 ..			.dmark: db "FNF"  
056b f1			.pastdmark: pop af  
056c			endm  
# End of macro DMARK
056c					;	push af 
056c					;	ld a, 'n' 
056c					;	ld (debug_mark),a 
056c					;	pop af 
056c						CALLMONITOR 
056c cd 39 14			call break_point_state  
056f				endm  
# End of macro CALLMONITOR
056f					endif 
056f c9				ret 
0570			 
0570			 
0570			 
0570			; Free Space 
0570			; ---------- 
0570			; 
0570			; With current bank 
0570			; 
0570			; Set block count to zero 
0570			; Starting with first logical block 
0570			;      Find free block  
0570			;      If block id given, increment block count 
0570			; 
0570			;  
0570			 
0570			 
0570			; hl contains count of free blocks 
0570			 
0570			storage_freeblocks: 
0570			 
0570				; now locate first 0 page to mark as a free block 
0570			 
0570 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0572 21 40 00			ld hl, STORE_BLOCK_PHY 
0575 11 00 00			ld de, 0 
0578			 
0578			.fb1:   	 
0578 e5					push hl 
0579 c5					push bc 
057a d5					push de 
057b cd ae 01				call se_readbyte 
057e d1					pop de 
057f c1					pop bc 
0580 e1					pop hl 
0581			 
0581					; is free? 
0581 fe 00				cp 0 
0583 20 01				jr nz, .ff1cont 
0585 13					inc de 
0586			 
0586			.ff1cont: 
0586			 
0586			 
0586 3e 40				ld a, STORE_BLOCK_PHY 
0588 cd c6 0b				call addatohl 
058b 10 eb				djnz .fb1 
058d			 
058d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058f			.fb2:   	 
058f e5					push hl 
0590 c5					push bc 
0591 d5					push de 
0592 cd ae 01				call se_readbyte 
0595 d1					pop de 
0596 c1					pop bc 
0597 e1					pop hl 
0598			 
0598					; is free? 
0598 fe 00				cp 0 
059a 20 01				jr nz, .ff2cont 
059c 13					inc de 
059d			 
059d			.ff2cont: 
059d			 
059d 3e 40				ld a, STORE_BLOCK_PHY 
059f cd c6 0b				call addatohl 
05a2 10 eb				djnz .fb2 
05a4			 
05a4 eb				ex de, hl 
05a5 c9				ret 
05a6			 
05a6			; Get File ID 
05a6			; ----------- 
05a6			; 
05a6			; With current bank 
05a6			;  
05a6			; Load Block 0 Config 
05a6			; Get max file id number 
05a6			; For each logical block 
05a6			;    Read block file id 
05a6			;      If first block of file and dont have file id 
05a6			;         if file get id and exit 
05a6			 
05a6			 
05a6			 
05a6			 
05a6			; Create File 
05a6			; ----------- 
05a6			; 
05a6			; With current bank  
05a6			; Load Block 0 Config 
05a6			; Get max file id number 
05a6			; Increment file id number 
05a6			; Save Config 
05a6			; Find free block 
05a6			; Set buffer with file name and file id 
05a6			; Write buffer to free block  
05a6			 
05a6			 
05a6			; hl point to file name 
05a6			; hl returns file id 
05a6			 
05a6			; file format: 
05a6			; byte 0 - file id 
05a6			; byte 1 - extent number 
05a6			; byte 2-> data 
05a6			 
05a6			; format for extent number 0: 
05a6			; 
05a6			; byte 0 - file id 
05a6			; byte 1 - extent 0 
05a6			; byte 2 - extent count 
05a6			; byte 3 -> file name and meta data 
05a6			 
05a6			 
05a6			storage_create: 
05a6				if DEBUG_STORESE 
05a6					DMARK "SCR" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 7a ee			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 7b ee			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 7c ee			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "SCR"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 39 14			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl		; save file name pointer 
05c3			 
05c3 cd 62 02			call storage_get_block_0 
05c6			 
05c6 3a 65 eb			ld a,(store_page)	; get current file id 
05c9 3c				inc a 
05ca 32 65 eb			ld (store_page),a 
05cd				 
05cd 32 5e eb			ld (store_tmpid),a			; save id 
05d0			 
05d0 21 00 00			ld hl, 0 
05d3 11 65 eb			ld de, store_page 
05d6				if DEBUG_STORESE 
05d6					DMARK "SCw" 
05d6 f5				push af  
05d7 3a eb 05			ld a, (.dmark)  
05da 32 7a ee			ld (debug_mark),a  
05dd 3a ec 05			ld a, (.dmark+1)  
05e0 32 7b ee			ld (debug_mark+1),a  
05e3 3a ed 05			ld a, (.dmark+2)  
05e6 32 7c ee			ld (debug_mark+2),a  
05e9 18 03			jr .pastdmark  
05eb ..			.dmark: db "SCw"  
05ee f1			.pastdmark: pop af  
05ef			endm  
# End of macro DMARK
05ef					CALLMONITOR 
05ef cd 39 14			call break_point_state  
05f2				endm  
# End of macro CALLMONITOR
05f2				endif 
05f2 cd 16 02			call storage_write_block	 ; save update 
05f5			 
05f5				if DEBUG_STORESE 
05f5 11 65 eb				ld de, store_page 
05f8					DMARK "SCC" 
05f8 f5				push af  
05f9 3a 0d 06			ld a, (.dmark)  
05fc 32 7a ee			ld (debug_mark),a  
05ff 3a 0e 06			ld a, (.dmark+1)  
0602 32 7b ee			ld (debug_mark+1),a  
0605 3a 0f 06			ld a, (.dmark+2)  
0608 32 7c ee			ld (debug_mark+2),a  
060b 18 03			jr .pastdmark  
060d ..			.dmark: db "SCC"  
0610 f1			.pastdmark: pop af  
0611			endm  
# End of macro DMARK
0611					CALLMONITOR 
0611 cd 39 14			call break_point_state  
0614				endm  
# End of macro CALLMONITOR
0614				endif 
0614				;  
0614				 
0614 21 40 00			ld hl, STORE_BLOCK_PHY 
0617 11 00 00			ld de, 0 
061a cd d6 04			call storage_findnextid 
061d			 
061d 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
0620			 
0620				; TODO detect 0 = no spare blocks 
0620			 
0620				; hl now contains the free page to use for the file header page 
0620			 
0620				if DEBUG_STORESE 
0620				DMARK "SCF" 
0620 f5				push af  
0621 3a 35 06			ld a, (.dmark)  
0624 32 7a ee			ld (debug_mark),a  
0627 3a 36 06			ld a, (.dmark+1)  
062a 32 7b ee			ld (debug_mark+1),a  
062d 3a 37 06			ld a, (.dmark+2)  
0630 32 7c ee			ld (debug_mark+2),a  
0633 18 03			jr .pastdmark  
0635 ..			.dmark: db "SCF"  
0638 f1			.pastdmark: pop af  
0639			endm  
# End of macro DMARK
0639					CALLMONITOR 
0639 cd 39 14			call break_point_state  
063c				endm  
# End of macro CALLMONITOR
063c				endif 
063c			 
063c 22 4f eb			ld (store_tmppageid), hl 
063f				 
063f 3a 5e eb			ld a,(store_tmpid)    ; get file id 
0642			;	ld a, (store_filecache)			; save to cache 
0642			 
0642 32 65 eb			ld (store_page),a    ; set page id 
0645 3e 00			ld a, 0			 ; extent 0 is file header 
0647 32 66 eb			ld (store_page+1), a   ; set file extent 
064a			 
064a 32 67 eb			ld (store_page+2), a   ; extent count for the file 
064d			 
064d			;	inc hl 		; init block 0 of file 
064d			;	inc hl   		; skip file and extent id 
064d			 ;       ld a, 0 
064d			;	ld (hl),a 
064d			;	ld a, (store_filecache+1)  	; save to cache 
064d			 
064d			;	inc hl    ; file name 
064d				 
064d				 
064d 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0650				if DEBUG_STORESE 
0650					DMARK "SCc" 
0650 f5				push af  
0651 3a 65 06			ld a, (.dmark)  
0654 32 7a ee			ld (debug_mark),a  
0657 3a 66 06			ld a, (.dmark+1)  
065a 32 7b ee			ld (debug_mark+1),a  
065d 3a 67 06			ld a, (.dmark+2)  
0660 32 7c ee			ld (debug_mark+2),a  
0663 18 03			jr .pastdmark  
0665 ..			.dmark: db "SCc"  
0668 f1			.pastdmark: pop af  
0669			endm  
# End of macro DMARK
0669					CALLMONITOR 
0669 cd 39 14			call break_point_state  
066c				endm  
# End of macro CALLMONITOR
066c				endif 
066c e1				pop hl    ; get zero term string 
066d e5				push hl 
066e 3e 00			ld a, 0 
0670 cd 2f 10			call strlent 
0673 23				inc hl   ; cover zero term 
0674 06 00			ld b,0 
0676 4d				ld c,l 
0677 e1				pop hl 
0678				;ex de, hl 
0678				if DEBUG_STORESE 
0678					DMARK "SCa" 
0678 f5				push af  
0679 3a 8d 06			ld a, (.dmark)  
067c 32 7a ee			ld (debug_mark),a  
067f 3a 8e 06			ld a, (.dmark+1)  
0682 32 7b ee			ld (debug_mark+1),a  
0685 3a 8f 06			ld a, (.dmark+2)  
0688 32 7c ee			ld (debug_mark+2),a  
068b 18 03			jr .pastdmark  
068d ..			.dmark: db "SCa"  
0690 f1			.pastdmark: pop af  
0691			endm  
# End of macro DMARK
0691					;push af 
0691					;ld a, 'a' 
0691					;ld (debug_mark),a 
0691					;pop af 
0691					CALLMONITOR 
0691 cd 39 14			call break_point_state  
0694				endm  
# End of macro CALLMONITOR
0694				endif 
0694 ed b0			ldir    ; copy zero term string 
0696				if DEBUG_STORESE 
0696					DMARK "SCA" 
0696 f5				push af  
0697 3a ab 06			ld a, (.dmark)  
069a 32 7a ee			ld (debug_mark),a  
069d 3a ac 06			ld a, (.dmark+1)  
06a0 32 7b ee			ld (debug_mark+1),a  
06a3 3a ad 06			ld a, (.dmark+2)  
06a6 32 7c ee			ld (debug_mark+2),a  
06a9 18 03			jr .pastdmark  
06ab ..			.dmark: db "SCA"  
06ae f1			.pastdmark: pop af  
06af			endm  
# End of macro DMARK
06af					CALLMONITOR 
06af cd 39 14			call break_point_state  
06b2				endm  
# End of macro CALLMONITOR
06b2				endif 
06b2			 
06b2				; write file header page 
06b2			 
06b2 2a 4f eb			ld hl,(store_tmppageid) 
06b5 11 65 eb			ld de, store_page 
06b8				if DEBUG_STORESE 
06b8					DMARK "SCb" 
06b8 f5				push af  
06b9 3a cd 06			ld a, (.dmark)  
06bc 32 7a ee			ld (debug_mark),a  
06bf 3a ce 06			ld a, (.dmark+1)  
06c2 32 7b ee			ld (debug_mark+1),a  
06c5 3a cf 06			ld a, (.dmark+2)  
06c8 32 7c ee			ld (debug_mark+2),a  
06cb 18 03			jr .pastdmark  
06cd ..			.dmark: db "SCb"  
06d0 f1			.pastdmark: pop af  
06d1			endm  
# End of macro DMARK
06d1					;push af 
06d1					;ld a, 'b' 
06d1					;ld (debug_mark),a 
06d1					;pop af 
06d1					CALLMONITOR 
06d1 cd 39 14			call break_point_state  
06d4				endm  
# End of macro CALLMONITOR
06d4				endif 
06d4 cd 16 02			call storage_write_block 
06d7			 
06d7 3a 5e eb			ld a, (store_tmpid) 
06da 6f				ld l, a 
06db 26 00			ld h,0 
06dd				if DEBUG_STORESE 
06dd					DMARK "SCz" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 7a ee			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 7b ee			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 7c ee			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "SCz"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6					CALLMONITOR 
06f6 cd 39 14			call break_point_state  
06f9				endm  
# End of macro CALLMONITOR
06f9				endif 
06f9 c9				ret 
06fa				 
06fa			 
06fa			 
06fa			; 
06fa			; Read File 
06fa			; 
06fa			; h - file id to locate 
06fa			; l - extent to locate 
06fa			; de - pointer to string to read into 
06fa			; 
06fa			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06fa			 
06fa			.sr_fail: 
06fa d1				pop de 
06fb c9				ret 
06fc			 
06fc			storage_read: 
06fc d5				push de 
06fd			 
06fd			; TODO BUG the above push is it popped before the RET Z? 
06fd			 
06fd			; TODO how to handle multiple part blocks 
06fd			 
06fd				; locate file extent to read 
06fd			 
06fd 5c				ld e, h 
06fe 55				ld d, l 
06ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0702				if DEBUG_STORESE 
0702					DMARK "SRE" 
0702 f5				push af  
0703 3a 17 07			ld a, (.dmark)  
0706 32 7a ee			ld (debug_mark),a  
0709 3a 18 07			ld a, (.dmark+1)  
070c 32 7b ee			ld (debug_mark+1),a  
070f 3a 19 07			ld a, (.dmark+2)  
0712 32 7c ee			ld (debug_mark+2),a  
0715 18 03			jr .pastdmark  
0717 ..			.dmark: db "SRE"  
071a f1			.pastdmark: pop af  
071b			endm  
# End of macro DMARK
071b					CALLMONITOR 
071b cd 39 14			call break_point_state  
071e				endm  
# End of macro CALLMONITOR
071e				endif 
071e cd d6 04			call storage_findnextid 
0721			 
0721				if DEBUG_STORESE 
0721					DMARK "SRf" 
0721 f5				push af  
0722 3a 36 07			ld a, (.dmark)  
0725 32 7a ee			ld (debug_mark),a  
0728 3a 37 07			ld a, (.dmark+1)  
072b 32 7b ee			ld (debug_mark+1),a  
072e 3a 38 07			ld a, (.dmark+2)  
0731 32 7c ee			ld (debug_mark+2),a  
0734 18 03			jr .pastdmark  
0736 ..			.dmark: db "SRf"  
0739 f1			.pastdmark: pop af  
073a			endm  
# End of macro DMARK
073a					CALLMONITOR 
073a cd 39 14			call break_point_state  
073d				endm  
# End of macro CALLMONITOR
073d				endif 
073d cd ef 0b			call ishlzero 
0740			;	ld a, l 
0740			;	add h 
0740			;	cp 0 
0740 28 b8			jr z,.sr_fail			; block not found so EOF 
0742			 
0742				; hl contains page number to load 
0742 d1				pop de   ; get storage 
0743 d5				push de 
0744				if DEBUG_STORESE 
0744					DMARK "SRg" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 7a ee			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 7b ee			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 7c ee			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SRg"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 39 14			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760 cd b1 01			call storage_read_block 
0763			 
0763			 
0763			; TODO if block has no zeros then need to read next block  
0763			 
0763			 
0763					 
0763 e1				pop hl 		 ; return start of data to show as not EOF 
0764 23				inc hl   ; past file id 
0765 23				inc hl   ; past ext 
0766				if DEBUG_STORESE 
0766					DMARK "SRe" 
0766 f5				push af  
0767 3a 7b 07			ld a, (.dmark)  
076a 32 7a ee			ld (debug_mark),a  
076d 3a 7c 07			ld a, (.dmark+1)  
0770 32 7b ee			ld (debug_mark+1),a  
0773 3a 7d 07			ld a, (.dmark+2)  
0776 32 7c ee			ld (debug_mark+2),a  
0779 18 03			jr .pastdmark  
077b ..			.dmark: db "SRe"  
077e f1			.pastdmark: pop af  
077f			endm  
# End of macro DMARK
077f					CALLMONITOR 
077f cd 39 14			call break_point_state  
0782				endm  
# End of macro CALLMONITOR
0782				endif 
0782 c9					ret 
0783			 
0783			 
0783			 
0783			; 
0783			; Append File 
0783			; 
0783			; hl - file id to locate 
0783			; de - pointer to (multi block) string to write 
0783			 
0783			.sa_notfound: 
0783 d1				pop de 
0784 c9				ret 
0785			 
0785			 
0785			storage_append: 
0785				; hl -  file id to append to 
0785				; de - string to append 
0785			 
0785 d5				push de 
0786				 
0786				if DEBUG_STORESE 
0786					DMARK "AP1" 
0786 f5				push af  
0787 3a 9b 07			ld a, (.dmark)  
078a 32 7a ee			ld (debug_mark),a  
078d 3a 9c 07			ld a, (.dmark+1)  
0790 32 7b ee			ld (debug_mark+1),a  
0793 3a 9d 07			ld a, (.dmark+2)  
0796 32 7c ee			ld (debug_mark+2),a  
0799 18 03			jr .pastdmark  
079b ..			.dmark: db "AP1"  
079e f1			.pastdmark: pop af  
079f			endm  
# End of macro DMARK
079f					CALLMONITOR 
079f cd 39 14			call break_point_state  
07a2				endm  
# End of macro CALLMONITOR
07a2				endif 
07a2			 
07a2 7d				ld a, l 
07a3 32 5e eb			ld (store_tmpid), a 
07a6			 
07a6				; get file header  
07a6			 
07a6 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07a8 3a 5e eb			ld a, (store_tmpid) 
07ab 5f				ld e, a 
07ac			 
07ac 21 40 00				ld hl, STORE_BLOCK_PHY 
07af cd d6 04				call storage_findnextid 
07b2			 
07b2 cd ef 0b			call ishlzero 
07b5 28 cc			jr z, .sa_notfound 
07b7			 
07b7 22 4f eb			ld (store_tmppageid), hl 
07ba			 
07ba				; TODO handle file id not found 
07ba			 
07ba				if DEBUG_STORESE 
07ba					DMARK "AP2" 
07ba f5				push af  
07bb 3a cf 07			ld a, (.dmark)  
07be 32 7a ee			ld (debug_mark),a  
07c1 3a d0 07			ld a, (.dmark+1)  
07c4 32 7b ee			ld (debug_mark+1),a  
07c7 3a d1 07			ld a, (.dmark+2)  
07ca 32 7c ee			ld (debug_mark+2),a  
07cd 18 03			jr .pastdmark  
07cf ..			.dmark: db "AP2"  
07d2 f1			.pastdmark: pop af  
07d3			endm  
# End of macro DMARK
07d3					CALLMONITOR 
07d3 cd 39 14			call break_point_state  
07d6				endm  
# End of macro CALLMONITOR
07d6				endif 
07d6			 
07d6				; update file extent count 
07d6			 
07d6 11 65 eb			ld de, store_page 
07d9			 
07d9 cd b1 01			call storage_read_block 
07dc			 
07dc				if DEBUG_STORESE 
07dc					DMARK "AP3" 
07dc f5				push af  
07dd 3a f1 07			ld a, (.dmark)  
07e0 32 7a ee			ld (debug_mark),a  
07e3 3a f2 07			ld a, (.dmark+1)  
07e6 32 7b ee			ld (debug_mark+1),a  
07e9 3a f3 07			ld a, (.dmark+2)  
07ec 32 7c ee			ld (debug_mark+2),a  
07ef 18 03			jr .pastdmark  
07f1 ..			.dmark: db "AP3"  
07f4 f1			.pastdmark: pop af  
07f5			endm  
# End of macro DMARK
07f5					CALLMONITOR 
07f5 cd 39 14			call break_point_state  
07f8				endm  
# End of macro CALLMONITOR
07f8				endif 
07f8			;	ld (store_tmppageid), hl 
07f8			 
07f8 3a 67 eb			ld a, (store_page+2) 
07fb 3c				inc a 
07fc 32 67 eb			ld (store_page+2), a 
07ff 32 5d eb			ld (store_tmpext), a 
0802				 
0802				if DEBUG_STORESE 
0802					DMARK "AP3" 
0802 f5				push af  
0803 3a 17 08			ld a, (.dmark)  
0806 32 7a ee			ld (debug_mark),a  
0809 3a 18 08			ld a, (.dmark+1)  
080c 32 7b ee			ld (debug_mark+1),a  
080f 3a 19 08			ld a, (.dmark+2)  
0812 32 7c ee			ld (debug_mark+2),a  
0815 18 03			jr .pastdmark  
0817 ..			.dmark: db "AP3"  
081a f1			.pastdmark: pop af  
081b			endm  
# End of macro DMARK
081b					CALLMONITOR 
081b cd 39 14			call break_point_state  
081e				endm  
# End of macro CALLMONITOR
081e				endif 
081e 2a 4f eb			ld hl, (store_tmppageid) 
0821 11 65 eb			ld de, store_page 
0824 cd 16 02			call storage_write_block 
0827			 
0827				; find free block 
0827			 
0827 11 00 00			ld de, 0			 ; file extent to locate 
082a			 
082a 21 40 00				ld hl, STORE_BLOCK_PHY 
082d cd d6 04				call storage_findnextid 
0830 cd ef 0b			call ishlzero 
0833 ca 83 07			jp z, .sa_notfound 
0836			 
0836					; TODO handle no space left 
0836					 
0836 22 4f eb				ld (store_tmppageid), hl 
0839			 
0839				if DEBUG_STORESE 
0839					DMARK "AP4" 
0839 f5				push af  
083a 3a 4e 08			ld a, (.dmark)  
083d 32 7a ee			ld (debug_mark),a  
0840 3a 4f 08			ld a, (.dmark+1)  
0843 32 7b ee			ld (debug_mark+1),a  
0846 3a 50 08			ld a, (.dmark+2)  
0849 32 7c ee			ld (debug_mark+2),a  
084c 18 03			jr .pastdmark  
084e ..			.dmark: db "AP4"  
0851 f1			.pastdmark: pop af  
0852			endm  
# End of macro DMARK
0852					CALLMONITOR 
0852 cd 39 14			call break_point_state  
0855				endm  
# End of macro CALLMONITOR
0855				endif 
0855					; init the buffer with zeros so we can id if the buffer is full or not 
0855			 
0855 e5					push hl 
0856 c5					push bc 
0857			 
0857 21 65 eb				ld hl, store_page 
085a 06 40				ld b, STORE_BLOCK_PHY 
085c 3e 00				ld a, 0 
085e 77			.zeroblock:	ld (hl), a 
085f 23					inc hl 
0860 10 fc				djnz .zeroblock 
0862			 
0862 c1					pop bc 
0863 e1					pop hl 
0864			 
0864					; construct block 
0864			 
0864 3a 5e eb				ld a, (store_tmpid) 
0867 32 65 eb				ld (store_page), a   ; file id 
086a 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
086d 32 66 eb				ld (store_page+1), a 
0870			 
0870 e1					pop hl    ; get string to write 
0871 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0873 11 67 eb				ld de, store_page+2 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "AP5" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 7a ee			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 7b ee			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 7c ee			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "AP5"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd 39 14			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892			 
0892			 
0892			 
0892					; fill buffer with data until end of string or full block 
0892			 
0892 7e			.appd:		ld a, (hl) 
0893 12					ld (de), a 
0894 fe 00				cp 0 
0896 28 04				jr z, .appdone 
0898 23					inc hl 
0899 13					inc de 
089a 10 f6				djnz .appd 
089c			 
089c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
089d f5					push af   		; save last byte dumped 
089e			 
089e			 
089e 2a 4f eb			ld hl, (store_tmppageid) 
08a1 11 65 eb			ld de, store_page 
08a4				if DEBUG_STORESE 
08a4					DMARK "AP6" 
08a4 f5				push af  
08a5 3a b9 08			ld a, (.dmark)  
08a8 32 7a ee			ld (debug_mark),a  
08ab 3a ba 08			ld a, (.dmark+1)  
08ae 32 7b ee			ld (debug_mark+1),a  
08b1 3a bb 08			ld a, (.dmark+2)  
08b4 32 7c ee			ld (debug_mark+2),a  
08b7 18 03			jr .pastdmark  
08b9 ..			.dmark: db "AP6"  
08bc f1			.pastdmark: pop af  
08bd			endm  
# End of macro DMARK
08bd					CALLMONITOR 
08bd cd 39 14			call break_point_state  
08c0				endm  
# End of macro CALLMONITOR
08c0				endif 
08c0 cd 16 02				call storage_write_block 
08c3			 
08c3			 
08c3				; was that a full block of data written? 
08c3				; any more to write out? 
08c3			 
08c3				; if yes then set vars and jump to start of function again 
08c3			 
08c3 f1					pop af 
08c4 d1					pop de 
08c5			 
08c5 fe 00				cp 0		 ; no, string was fully written 
08c7 c8					ret z 
08c8			 
08c8					; setup vars for next cycle 
08c8			 
08c8 3a 5e eb				ld a, (store_tmpid) 
08cb 6f					ld l, a 
08cc 26 00				ld h, 0 
08ce			 
08ce c3 85 07			 	jp storage_append	 ; yes, need to write out some more 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			 
08d1			if DEBUG_STORECF 
08d1			storageput:	 
08d1					ret 
08d1			storageread: 
08d1					ld hl, store_page 
08d1					ld b, 200 
08d1					ld a,0 
08d1			.src:		ld (hl),a 
08d1					inc hl 
08d1					djnz .src 
08d1					 
08d1			 
08d1					ld de, 0 
08d1					ld bc, 1 
08d1					ld hl, store_page 
08d1					call cfRead 
08d1			 
08d1				call cfGetError 
08d1				ld hl,scratch 
08d1				call hexout 
08d1				ld hl, scratch+2 
08d1				ld a, 0 
08d1				ld (hl),a 
08d1				ld de, scratch 
08d1				ld a,display_row_1 
08d1				call str_at_display 
08d1				call update_display 
08d1			 
08d1					ld hl, store_page 
08d1					ld (os_cur_ptr),hl 
08d1			 
08d1					ret 
08d1			endif 
08d1			 
08d1			 
08d1			; Clear out the main buffer store (used to remove junk before writing a new block) 
08d1			 
08d1			storage_clear_page: 
08d1 e5				push hl 
08d2 d5				push de 
08d3 c5				push bc 
08d4 21 65 eb			ld hl, store_page 
08d7 3e 00			ld a, 0 
08d9 77				ld (hl), a 
08da			 
08da 11 66 eb			ld de, store_page+1 
08dd 01 40 00			ld bc, STORE_BLOCK_PHY 
08e0			 
08e0 ed b0			ldir 
08e2				 
08e2 c1				pop bc 
08e3 d1				pop de 
08e4 e1				pop hl 
08e5 c9				ret 
08e6			 
08e6			; eof 
# End of file firmware_storage.asm
08e6			  
08e6			; support routines for above hardware abstraction layer  
08e6			  
08e6			include "firmware_general.asm"        ; general support functions  
08e6			 
08e6			; word look up 
08e6			 
08e6			; in 
08e6			; a is the index 
08e6			; hl is pointer start of array 
08e6			; 
08e6			; returns 
08e6			; hl to the word 
08e6			; 
08e6			 
08e6			table_lookup:  
08e6 d5					push de 
08e7 eb					ex de, hl 
08e8			 
08e8 6f					ld l, a 
08e9 26 00				ld h, 0 
08eb 29					add hl, hl 
08ec 19					add hl, de 
08ed 7e					ld a, (hl) 
08ee 23					inc hl 
08ef 66					ld h,(hl) 
08f0 6f					ld l, a 
08f1			 
08f1 d1					pop de 
08f2 c9					ret 
08f3			 
08f3			; Delay loops 
08f3			 
08f3			 
08f3			 
08f3			aDelayInMS: 
08f3 c5				push bc 
08f4 47				ld b,a 
08f5			msdelay: 
08f5 c5				push bc 
08f6				 
08f6			 
08f6 01 41 00			ld bc,041h 
08f9 cd 11 09			call delayloop 
08fc c1				pop bc 
08fd 05				dec b 
08fe 20 f5			jr nz,msdelay 
0900			 
0900			;if CPU_CLOCK_8MHZ 
0900			;msdelay8: 
0900			;	push bc 
0900			;	 
0900			; 
0900			;	ld bc,041h 
0900			;	call delayloop 
0900			;	pop bc 
0900			;	dec b 
0900			;	jr nz,msdelay8 
0900			;endif 
0900			 
0900			 
0900 c1				pop bc 
0901 c9				ret 
0902			 
0902			 
0902			delay250ms: 
0902				;push de 
0902 01 00 40			ld bc, 04000h 
0905 c3 11 09			jp delayloop 
0908			delay500ms: 
0908				;push de 
0908 01 00 80			ld bc, 08000h 
090b c3 11 09			jp delayloop 
090e			delay1s: 
090e				;push bc 
090e			   ; Clobbers A, d and e 
090e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0911			delayloop: 
0911 c5			    push bc 
0912			 
0912			if BASE_CPM 
0912 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0915			.cpmloop: 
0915 c5				push bc 
0916			 
0916			endif 
0916			 
0916			 
0916			 
0916			delayloopi: 
0916			;	push bc 
0916			;.dl: 
0916 cb 47		    bit     0,a    	; 8 
0918 cb 47		    bit     0,a    	; 8 
091a cb 47		    bit     0,a    	; 8 
091c e6 ff		    and     255  	; 7 
091e 0b			    dec     bc      	; 6 
091f 79			    ld      a,c     	; 4 
0920 b0			    or      b     	; 4 
0921 c2 16 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0924			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0924				;pop de 
0924			;pop bc 
0924			 
0924			if BASE_CPM 
0924 c1				pop bc 
0925				 
0925 0b			    dec     bc      	; 6 
0926 79			    ld      a,c     	; 4 
0927 b0			    or      b     	; 4 
0928 c2 15 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
092b				 
092b			 
092b			endif 
092b			;if CPU_CLOCK_8MHZ 
092b			;    pop bc 
092b			;    push bc 
092b			;.dl8: 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    and     255  	; 7 
092b			;    dec     bc      	; 6 
092b			;    ld      a,c     	; 4 
092b			;    or      b     	; 4 
092b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
092b			;endif 
092b			 
092b			;if CPU_CLOCK_10MHZ 
092b			;    pop bc 
092b			;    push bc 
092b			;.dl8: 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    bit     0,a    	; 8 
092b			;    and     255  	; 7 
092b			;    dec     bc      	; 6 
092b			;    ld      a,c     	; 4 
092b			;    or      b     	; 4 
092b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
092b			;endif 
092b c1			    pop bc 
092c			 
092c c9				ret 
092d			 
092d			 
092d			 
092d			; eof 
# End of file firmware_general.asm
092d			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
092d			; display routines that use the physical hardware abstraction layer 
092d			 
092d			 
092d			; information window 
092d			 
092d			; pass hl with 1st string to display 
092d			; pass de with 2nd string to display 
092d			 
092d			info_panel: 
092d e5				push hl 
092e			 
092e 2a db eb			ld hl, (display_fb_active) 
0931 e5				push hl    ; future de destination 
0932 21 c0 ed				ld hl, display_fb0 
0935 22 db eb				ld (display_fb_active), hl 
0938			 
0938 cd 99 09			call clear_display 
093b			 
093b			 
093b 3e 55			ld a, display_row_3 + 5 
093d cd ac 09			call str_at_display 
0940			 
0940 e1				pop hl 
0941 d1				pop de 
0942			 
0942 e5				push hl 
0943			 
0943			 
0943 3e 2d			ld a, display_row_2 + 5 
0945 cd ac 09			call str_at_display 
0948			 
0948			 
0948 cd bc 09			call update_display 
094b cd 3e 19			call next_page_prompt 
094e cd 99 09			call clear_display 
0951			 
0951				 
0951 21 1f ed				ld hl, display_fb1 
0954 22 db eb				ld (display_fb_active), hl 
0957 cd bc 09			call update_display 
095a			 
095a			 
095a c9				ret 
095b			 
095b			 
095b			 
095b			 
095b			; TODO windowing? 
095b			 
095b			; TODO scroll line up 
095b			 
095b			scroll_up: 
095b			 
095b e5				push hl 
095c d5				push de 
095d c5				push bc 
095e			 
095e				; get frame buffer  
095e			 
095e 2a db eb			ld hl, (display_fb_active) 
0961 e5				push hl    ; future de destination 
0962			 
0962 11 28 00			ld  de, display_cols 
0965 19				add hl, de 
0966			 
0966 d1				pop de 
0967			 
0967				;ex de, hl 
0967 01 9f 00			ld bc, display_fb_len -1  
096a			;if DEBUG_FORTH_WORDS 
096a			;	DMARK "SCL" 
096a			;	CALLMONITOR 
096a			;endif	 
096a ed b0			ldir 
096c			 
096c				; wipe bottom row 
096c			 
096c			 
096c 2a db eb			ld hl, (display_fb_active) 
096f 11 a0 00			ld de, display_cols*display_rows 
0972 19				add hl, de 
0973 06 28			ld b, display_cols 
0975 3e 20			ld a, ' ' 
0977			.scwipe: 
0977 77				ld (hl), a 
0978 2b				dec hl 
0979 10 fc			djnz .scwipe 
097b			 
097b				;pop hl 
097b			 
097b c1				pop bc 
097c d1				pop de 
097d e1				pop hl 
097e			 
097e c9				ret 
097f			 
097f			 
097f			;scroll_upo: 
097f			;	ld de, display_row_1 
097f			 ;	ld hl, display_row_2 
097f			;	ld bc, display_cols 
097f			;	ldir 
097f			;	ld de, display_row_2 
097f			 ;	ld hl, display_row_3 
097f			;	ld bc, display_cols 
097f			;	ldir 
097f			;	ld de, display_row_3 
097f			 ;	ld hl, display_row_4 
097f			;	ld bc, display_cols 
097f			;	ldir 
097f			 
097f			; TODO clear row 4 
097f			 
097f			;	ret 
097f			 
097f				 
097f			scroll_down: 
097f			 
097f e5				push hl 
0980 d5				push de 
0981 c5				push bc 
0982			 
0982				; get frame buffer  
0982			 
0982 2a db eb			ld hl, (display_fb_active) 
0985			 
0985 11 9f 00			ld de, display_fb_len - 1 
0988 19				add hl, de 
0989			 
0989 e5			push hl    ; future de destination 
098a			 
098a 11 28 00			ld  de, display_cols 
098d ed 52			sbc hl, de 
098f			 
098f			 
098f d1				pop de 
0990			 
0990			;	ex de, hl 
0990 01 9f 00			ld bc, display_fb_len -1  
0993			 
0993			 
0993				 
0993			 
0993 ed b0			ldir 
0995			 
0995				; wipe bottom row 
0995			 
0995			 
0995			;	ld hl, (display_fb_active) 
0995			;;	ld de, display_cols*display_rows 
0995			;;	add hl, de 
0995			;	ld b, display_cols 
0995			;	ld a, ' ' 
0995			;.scwiped: 
0995			;	ld (hl), a 
0995			;	dec hl 
0995			;	djnz .scwiped 
0995			 
0995				;pop hl 
0995			 
0995 c1				pop bc 
0996 d1				pop de 
0997 e1				pop hl 
0998			 
0998 c9				ret 
0999			;scroll_down: 
0999			;	ld de, display_row_4 
0999			;	ld hl, display_row_3 
0999			;	ld bc, display_cols 
0999			;	ldir 
0999			;	ld de, display_row_3 
0999			; 	ld hl, display_row_2 
0999			;	ld bc, display_cols 
0999			;	ldir 
0999			;	ld de, display_row_2 
0999			;	ld hl, display_row_1 
0999			;	ld bc, display_cols 
0999			;	ldir 
0999			;;; TODO clear row 1 
0999			;	ret 
0999			 
0999			 
0999			 
0999			 
0999			 
0999			; clear active frame buffer 
0999			 
0999			clear_display: 
0999 3e 20			ld a, ' ' 
099b c3 9e 09			jp fill_display 
099e			 
099e			; fill active frame buffer with a char in A 
099e			 
099e			fill_display: 
099e 06 a0			ld b,display_fb_len 
09a0 2a db eb			ld hl, (display_fb_active) 
09a3 77			.fd1:	ld (hl),a 
09a4 23				inc hl 
09a5 10 fc			djnz .fd1 
09a7 23				inc hl 
09a8 3e 00			ld a,0 
09aa 77				ld (hl),a 
09ab			 
09ab			 
09ab c9				ret 
09ac			; Write string (DE) at pos (A) to active frame buffer 
09ac			 
09ac 2a db eb		str_at_display:    ld hl,(display_fb_active) 
09af 06 00					ld b,0 
09b1 4f					ld c,a 
09b2 09					add hl,bc 
09b3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09b4 b7			            OR   A              ;Null terminator? 
09b5 c8			            RET  Z              ;Yes, so finished 
09b6 77					ld (hl),a 
09b7 23				inc hl 
09b8 13			            INC  DE             ;Point to next character 
09b9 18 f8		            JR   .sad1     ;Repeat 
09bb c9					ret 
09bc			 
09bc			; using current frame buffer write to physical display 
09bc			 
09bc			update_display: 
09bc e5				push hl 
09bd 2a db eb			ld hl, (display_fb_active) 
09c0 cd 05 58			call write_display 
09c3 e1				pop hl 
09c4 c9				ret 
09c5			 
09c5			; TODO scrolling 
09c5			 
09c5			 
09c5			; move cursor right one char 
09c5			cursor_right: 
09c5			 
09c5				; TODO shift right 
09c5				; TODO if beyond max col 
09c5				; TODO       cursor_next_line 
09c5			 
09c5 c9				ret 
09c6			 
09c6			 
09c6			cursor_next_line: 
09c6				; TODO first char 
09c6				; TODO line down 
09c6				; TODO if past last row 
09c6				; TODO    scroll up 
09c6			 
09c6 c9				ret 
09c7			 
09c7			cursor_left: 
09c7				; TODO shift left 
09c7				; TODO if beyond left  
09c7				; TODO     cursor prev line 
09c7				 
09c7 c9				ret 
09c8			 
09c8			cursor_prev_line: 
09c8				; TODO last char 
09c8				; TODO line up 
09c8				; TODO if past first row 
09c8				; TODO   scroll down 
09c8			 
09c8 c9				ret 
09c9			 
09c9			 
09c9			cout: 
09c9				; A - char 
09c9 c9				ret 
09ca			 
09ca			 
09ca			; Display a menu and allow item selection (optional toggle items) 
09ca			; 
09ca			; format: 
09ca			; hl pointer to word array with zero term for items 
09ca			; e.g.    db item1 
09ca			;         db .... 
09ca			;         db 0 
09ca			; 
09ca			; a = starting menu item  
09ca			; 
09ca			; de = pointer item toggle array   (todo) 
09ca			; 
09ca			; returns item selected in a 1-... 
09ca			; returns 0 if back button pressed 
09ca			; 
09ca			; NOTE: Uses system frame buffer to display 
09ca			; 
09ca			; LEFT, Q = go back 
09ca			; RIGHT, SPACE, CR = select 
09ca			; UP, A - Up 
09ca			; DOWN, Z - Down 
09ca			 
09ca			 
09ca			 
09ca			 
09ca			 
09ca			menu: 
09ca			 
09ca					; keep array pointer 
09ca			 
09ca 22 63 eb				ld (store_tmp1), hl 
09cd 32 61 eb				ld (store_tmp2), a 
09d0			 
09d0					; check for key bounce 
09d0			 
09d0			if BASE_KEV 
09d0			 
09d0			.mbounce:	call cin 
09d0					cp 0 
09d0					jr nz, .mbounce 
09d0			endif 
09d0					; for ease use ex 
09d0			 
09d0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09d0 21 c0 ed				ld hl, display_fb0 
09d3 22 db eb				ld (display_fb_active), hl 
09d6			 
09d6 cd 99 09		.mloop:		call clear_display 
09d9 cd bc 09				call update_display 
09dc			 
09dc					; draw selection id '>' at 1 
09dc			 
09dc					; init start of list display 
09dc			 
09dc 3e 05				ld a, 5 
09de 32 5f eb				ld (store_tmp3), a   ; display row count 
09e1 3a 61 eb				ld a,( store_tmp2) 
09e4 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09e7			 
09e7					 
09e7			.mitem:	 
09e7			 
09e7			 
09e7 3a 62 eb				ld a,(store_tmp2+1) 
09ea 6f					ld l, a 
09eb 26 00				ld h, 0 
09ed 29					add hl, hl 
09ee ed 5b 63 eb			ld de, (store_tmp1) 
09f2 19					add hl, de 
09f3 7e					ld a, (hl) 
09f4 23					inc hl 
09f5 66					ld h,(hl) 
09f6 6f					ld l, a 
09f7			 
09f7 cd ef 0b				call ishlzero 
09fa 28 1a				jr z, .mdone 
09fc			 
09fc eb					ex de, hl 
09fd 3a 5f eb				ld a, (store_tmp3) 
0a00 cd ac 09				call str_at_display 
0a03					 
0a03			 
0a03					; next item 
0a03 3a 62 eb				ld a, (store_tmp2+1) 
0a06 3c					inc a 
0a07 32 62 eb				ld (store_tmp2+1), a   ; display item count 
0a0a			 
0a0a			 		; next row 
0a0a			 
0a0a 3a 5f eb				ld a, (store_tmp3) 
0a0d c6 28				add display_cols 
0a0f 32 5f eb				ld (store_tmp3), a 
0a12			 
0a12					; at end of screen? 
0a12			 
0a12 fe 10				cp display_rows*4 
0a14 20 d1				jr nz, .mitem 
0a16			 
0a16			 
0a16			.mdone: 
0a16 cd ef 0b				call ishlzero 
0a19 28 08				jr z, .nodn 
0a1b			 
0a1b 3e 78				ld a, display_row_4 
0a1d 11 9c 0a				ld de, .mdown 
0a20 cd ac 09				call str_at_display 
0a23			 
0a23					; draw options to fill the screens with active item on line 1 
0a23					; if current option is 2 or more then display ^ in top 
0a23			 
0a23 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a26 fe 00				cp 0 
0a28 28 08				jr z, .noup 
0a2a			 
0a2a 3e 00				ld a, 0 
0a2c 11 9a 0a				ld de, .mup 
0a2f cd ac 09				call str_at_display 
0a32			 
0a32 3e 02		.noup:		ld a, 2 
0a34 11 98 0a				ld de, .msel 
0a37 cd ac 09				call str_at_display 
0a3a			 
0a3a					; if current option + 1 is not null then display V in bottom 
0a3a					; get key 
0a3a cd bc 09				call update_display 
0a3d			 
0a3d			 
0a3d					; handle key 
0a3d			 
0a3d cd b7 58				call cin_wait 
0a40			 
0a40 fe 05				cp KEY_UP 
0a42 28 2b				jr z, .mgoup 
0a44 fe 61				cp 'a' 
0a46 28 27				jr z, .mgoup 
0a48 fe 0a				cp KEY_DOWN 
0a4a 28 32				jr z, .mgod 
0a4c fe 7a				cp 'z' 
0a4e 28 2e				jr z, .mgod 
0a50 fe 20				cp ' ' 
0a52 28 34				jr z, .goend 
0a54 fe 0c				cp KEY_RIGHT 
0a56 28 30				jr z, .goend 
0a58 fe 0d				cp KEY_CR 
0a5a 28 2c				jr z, .goend 
0a5c fe 71				cp 'q' 
0a5e 28 0b				jr z, .goback 
0a60			 
0a60 fe 0b				cp KEY_LEFT 
0a62 28 07				jr z, .goback 
0a64 fe 08				cp KEY_BS 
0a66 28 03				jr z, .goback 
0a68 c3 d6 09				jp .mloop 
0a6b			 
0a6b			.goback: 
0a6b 3e 00			ld a, 0 
0a6d 18 1d			jr .goend2 
0a6f			 
0a6f				; move up one 
0a6f			.mgoup: 
0a6f 3a 61 eb				ld a, (store_tmp2) 
0a72 fe 00				cp 0 
0a74 ca d6 09				jp z, .mloop 
0a77 3d					dec a 
0a78 32 61 eb				ld (store_tmp2), a 
0a7b c3 d6 09				jp .mloop 
0a7e			 
0a7e				; move down one 
0a7e			.mgod: 
0a7e 3a 61 eb				ld a, (store_tmp2) 
0a81 3c					inc a 
0a82 32 61 eb				ld (store_tmp2), a 
0a85 c3 d6 09				jp .mloop 
0a88			 
0a88			 
0a88			.goend: 
0a88					; get selected item number 
0a88			 
0a88 3a 61 eb				ld a, (store_tmp2) 
0a8b 3c					inc a 
0a8c			 
0a8c			.goend2: 
0a8c f5					push af 
0a8d			 
0a8d					; restore active fb 
0a8d					; TODO BUG assumes fb1 
0a8d			 
0a8d 21 1f ed				ld hl, display_fb1 
0a90 22 db eb				ld (display_fb_active), hl 
0a93			 
0a93					; restore main regs 
0a93			 
0a93			 
0a93 cd bc 09				call update_display 
0a96			 
0a96 f1					pop af 
0a97			 
0a97 c9				ret 
0a98			 
0a98 .. 00		.msel:   db ">",0 
0a9a .. 00		.mup:   db "^",0 
0a9c .. 00		.mdown:   db "v",0 
0a9e			 
0a9e			 
0a9e			; eof 
0a9e			 
# End of file firmware_display.asm
0a9e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a9e			; random number generators 
0a9e			 
0a9e			 
0a9e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a9e			 
0a9e			 
0a9e			;-----> Generate a random number 
0a9e			; output a=answer 0<=a<=255 
0a9e			; all registers are preserved except: af 
0a9e			random: 
0a9e e5			        push    hl 
0a9f d5			        push    de 
0aa0 2a bd eb		        ld      hl,(randData) 
0aa3 ed 5f		        ld      a,r 
0aa5 57			        ld      d,a 
0aa6 5e			        ld      e,(hl) 
0aa7 19			        add     hl,de 
0aa8 85			        add     a,l 
0aa9 ac			        xor     h 
0aaa 22 bd eb		        ld      (randData),hl 
0aad d1			        pop     de 
0aae e1			        pop     hl 
0aaf c9			        ret 
0ab0			 
0ab0			 
0ab0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ab0			 
0ab0			 
0ab0			 
0ab0			;------LFSR------ 
0ab0			;James Montelongo 
0ab0			;optimized by Spencer Putt 
0ab0			;out: 
0ab0			; a = 8 bit random number 
0ab0			RandLFSR: 
0ab0 21 c3 eb		        ld hl,LFSRSeed+4 
0ab3 5e			        ld e,(hl) 
0ab4 23			        inc hl 
0ab5 56			        ld d,(hl) 
0ab6 23			        inc hl 
0ab7 4e			        ld c,(hl) 
0ab8 23			        inc hl 
0ab9 7e			        ld a,(hl) 
0aba 47			        ld b,a 
0abb cb 13		        rl e  
0abd cb 12			rl d 
0abf cb 11		        rl c  
0ac1 17				rla 
0ac2 cb 13		        rl e  
0ac4 cb 12			rl d 
0ac6 cb 11		        rl c  
0ac8 17				rla 
0ac9 cb 13		        rl e  
0acb cb 12			rl d 
0acd cb 11		        rl c  
0acf 17				rla 
0ad0 67			        ld h,a 
0ad1 cb 13		        rl e  
0ad3 cb 12			rl d 
0ad5 cb 11		        rl c  
0ad7 17				rla 
0ad8 a8			        xor b 
0ad9 cb 13		        rl e  
0adb cb 12			rl d 
0add ac			        xor h 
0ade a9			        xor c 
0adf aa			        xor d 
0ae0 21 c5 eb		        ld hl,LFSRSeed+6 
0ae3 11 c6 eb		        ld de,LFSRSeed+7 
0ae6 01 07 00		        ld bc,7 
0ae9 ed b8		        lddr 
0aeb 12			        ld (de),a 
0aec c9			        ret 
0aed			 
0aed			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0aed			 
0aed			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0aed			 
0aed			 
0aed			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0aed			 
0aed			prng16: 
0aed			;Inputs: 
0aed			;   (seed1) contains a 16-bit seed value 
0aed			;   (seed2) contains a NON-ZERO 16-bit seed value 
0aed			;Outputs: 
0aed			;   HL is the result 
0aed			;   BC is the result of the LCG, so not that great of quality 
0aed			;   DE is preserved 
0aed			;Destroys: 
0aed			;   AF 
0aed			;cycle: 4,294,901,760 (almost 4.3 billion) 
0aed			;160cc 
0aed			;26 bytes 
0aed 2a b7 eb		    ld hl,(seed1) 
0af0 44			    ld b,h 
0af1 4d			    ld c,l 
0af2 29			    add hl,hl 
0af3 29			    add hl,hl 
0af4 2c			    inc l 
0af5 09			    add hl,bc 
0af6 22 b7 eb		    ld (seed1),hl 
0af9 2a b5 eb		    ld hl,(seed2) 
0afc 29			    add hl,hl 
0afd 9f			    sbc a,a 
0afe e6 2d		    and %00101101 
0b00 ad			    xor l 
0b01 6f			    ld l,a 
0b02 22 b5 eb		    ld (seed2),hl 
0b05 09			    add hl,bc 
0b06 c9			    ret 
0b07			 
0b07			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b07			 
0b07			rand32: 
0b07			;Inputs: 
0b07			;   (seed1_0) holds the lower 16 bits of the first seed 
0b07			;   (seed1_1) holds the upper 16 bits of the first seed 
0b07			;   (seed2_0) holds the lower 16 bits of the second seed 
0b07			;   (seed2_1) holds the upper 16 bits of the second seed 
0b07			;   **NOTE: seed2 must be non-zero 
0b07			;Outputs: 
0b07			;   HL is the result 
0b07			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b07			;Destroys: 
0b07			;   AF 
0b07			;Tested and passes all CAcert tests 
0b07			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b07			;it has a period of 18,446,744,069,414,584,320 
0b07			;roughly 18.4 quintillion. 
0b07			;LFSR taps: 0,2,6,7  = 11000101 
0b07			;291cc 
0b07			;seed1_0=$+1 
0b07			;    ld hl,12345 
0b07			;seed1_1=$+1 
0b07			;    ld de,6789 
0b07			;    ld b,h 
0b07			;    ld c,l 
0b07			;    add hl,hl \ rl e \ rl d 
0b07			;    add hl,hl \ rl e \ rl d 
0b07			;    inc l 
0b07			;    add hl,bc 
0b07			;    ld (seed1_0),hl 
0b07			;    ld hl,(seed1_1) 
0b07			;    adc hl,de 
0b07			;    ld (seed1_1),hl 
0b07			;    ex de,hl 
0b07			;seed2_0=$+1 
0b07			;    ld hl,9876 
0b07			;seed2_1=$+1 
0b07			;    ld bc,54321 
0b07			;    add hl,hl \ rl c \ rl b 
0b07			;    ld (seed2_1),bc 
0b07			;    sbc a,a 
0b07			;    and %11000101 
0b07			;    xor l 
0b07			;    ld l,a 
0b07			;    ld (seed2_0),hl 
0b07			;    ex de,hl 
0b07			;    add hl,bc 
0b07			;    ret 
0b07			; 
0b07			 
0b07			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b07			; 20 bytes, 86 cycles (excluding ret) 
0b07			 
0b07			; returns   hl = pseudorandom number 
0b07			; corrupts   a 
0b07			 
0b07			; generates 16-bit pseudorandom numbers with a period of 65535 
0b07			; using the xorshift method: 
0b07			 
0b07			; hl ^= hl << 7 
0b07			; hl ^= hl >> 9 
0b07			; hl ^= hl << 8 
0b07			 
0b07			; some alternative shift triplets which also perform well are: 
0b07			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b07			 
0b07			;  org 32768 
0b07			 
0b07			xrnd: 
0b07 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0b0a 3e 00		  ld a,0 
0b0c bd			  cp l 
0b0d 20 02		  jr nz, .xrnd1 
0b0f 2e 01		  ld l, 1 
0b11			.xrnd1: 
0b11			 
0b11 7c			  ld a,h 
0b12 1f			  rra 
0b13 7d			  ld a,l 
0b14 1f			  rra 
0b15 ac			  xor h 
0b16 67			  ld h,a 
0b17 7d			  ld a,l 
0b18 1f			  rra 
0b19 7c			  ld a,h 
0b1a 1f			  rra 
0b1b ad			  xor l 
0b1c 6f			  ld l,a 
0b1d ac			  xor h 
0b1e 67			  ld h,a 
0b1f			 
0b1f 22 bb eb		  ld (xrandc),hl 
0b22			 
0b22 c9			  ret 
0b23			;  
0b23			 
0b23			 
0b23			;;;; int maths 
0b23			 
0b23			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b23			; Divide 16-bit values (with 16-bit result) 
0b23			; In: Divide BC by divider DE 
0b23			; Out: BC = result, HL = rest 
0b23			; 
0b23			Div16: 
0b23 21 00 00		    ld hl,0 
0b26 78			    ld a,b 
0b27 06 08		    ld b,8 
0b29			Div16_Loop1: 
0b29 17			    rla 
0b2a ed 6a		    adc hl,hl 
0b2c ed 52		    sbc hl,de 
0b2e 30 01		    jr nc,Div16_NoAdd1 
0b30 19			    add hl,de 
0b31			Div16_NoAdd1: 
0b31 10 f6		    djnz Div16_Loop1 
0b33 17			    rla 
0b34 2f			    cpl 
0b35 47			    ld b,a 
0b36 79			    ld a,c 
0b37 48			    ld c,b 
0b38 06 08		    ld b,8 
0b3a			Div16_Loop2: 
0b3a 17			    rla 
0b3b ed 6a		    adc hl,hl 
0b3d ed 52		    sbc hl,de 
0b3f 30 01		    jr nc,Div16_NoAdd2 
0b41 19			    add hl,de 
0b42			Div16_NoAdd2: 
0b42 10 f6		    djnz Div16_Loop2 
0b44 17			    rla 
0b45 2f			    cpl 
0b46 41			    ld b,c 
0b47 4f			    ld c,a 
0b48 c9			ret 
0b49			 
0b49			 
0b49			;http://z80-heaven.wikidot.com/math 
0b49			; 
0b49			;Inputs: 
0b49			;     DE and A are factors 
0b49			;Outputs: 
0b49			;     A is not changed 
0b49			;     B is 0 
0b49			;     C is not changed 
0b49			;     DE is not changed 
0b49			;     HL is the product 
0b49			;Time: 
0b49			;     342+6x 
0b49			; 
0b49			Mult16: 
0b49			 
0b49 06 08		     ld b,8          ;7           7 
0b4b 21 00 00		     ld hl,0         ;10         10 
0b4e 29			       add hl,hl     ;11*8       88 
0b4f 07			       rlca          ;4*8        32 
0b50 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b52 19			         add hl,de   ;--         -- 
0b53 10 f9		       djnz $-5      ;13*7+8     99 
0b55 c9			ret 
0b56			 
0b56			; 
0b56			; Square root of 16-bit value 
0b56			; In:  HL = value 
0b56			; Out:  D = result (rounded down) 
0b56			; 
0b56			;Sqr16: 
0b56			;    ld de,#0040 
0b56			;    ld a,l 
0b56			;    ld l,h 
0b56			;    ld h,d 
0b56			;    or a 
0b56			;    ld b,8 
0b56			;Sqr16_Loop: 
0b56			;    sbc hl,de 
0b56			;    jr nc,Sqr16_Skip 
0b56			;    add hl,de 
0b56			;Sqr16_Skip: 
0b56			;    ccf 
0b56			;    rl d 
0b56			;    add a,a 
0b56			;    adc hl,hl 
0b56			;    add a,a 
0b56			;    adc hl,hl 
0b56			;    djnz Sqr16_Loop 
0b56			;    ret 
0b56			; 
0b56			; 
0b56			; Divide 8-bit values 
0b56			; In: Divide E by divider C 
0b56			; Out: A = result, B = rest 
0b56			; 
0b56			Div8: 
0b56 af			    xor a 
0b57 06 08		    ld b,8 
0b59			Div8_Loop: 
0b59 cb 13		    rl e 
0b5b 17			    rla 
0b5c 91			    sub c 
0b5d 30 01		    jr nc,Div8_NoAdd 
0b5f 81			    add a,c 
0b60			Div8_NoAdd: 
0b60 10 f7		    djnz Div8_Loop 
0b62 47			    ld b,a 
0b63 7b			    ld a,e 
0b64 17			    rla 
0b65 2f			    cpl 
0b66 c9			    ret 
0b67			 
0b67			; 
0b67			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b67			; In: Multiply A with DE 
0b67			; Out: HL = result 
0b67			; 
0b67			Mult12U: 
0b67 2e 00		    ld l,0 
0b69 87			    add a,a 
0b6a 30 01		    jr nc,Mult12U_NoAdd0 
0b6c 19			    add hl,de 
0b6d			Mult12U_NoAdd0: 
0b6d 29			    add hl,hl 
0b6e 87			    add a,a 
0b6f 30 01		    jr nc,Mult12U_NoAdd1 
0b71 19			    add hl,de 
0b72			Mult12U_NoAdd1: 
0b72 29			    add hl,hl 
0b73 87			    add a,a 
0b74 30 01		    jr nc,Mult12U_NoAdd2 
0b76 19			    add hl,de 
0b77			Mult12U_NoAdd2: 
0b77 29			    add hl,hl 
0b78 87			    add a,a 
0b79 30 01		    jr nc,Mult12U_NoAdd3 
0b7b 19			    add hl,de 
0b7c			Mult12U_NoAdd3: 
0b7c 29			    add hl,hl 
0b7d 87			    add a,a 
0b7e 30 01		    jr nc,Mult12U_NoAdd4 
0b80 19			    add hl,de 
0b81			Mult12U_NoAdd4: 
0b81 29			    add hl,hl 
0b82 87			    add a,a 
0b83 30 01		    jr nc,Mult12U_NoAdd5 
0b85 19			    add hl,de 
0b86			Mult12U_NoAdd5: 
0b86 29			    add hl,hl 
0b87 87			    add a,a 
0b88 30 01		    jr nc,Mult12U_NoAdd6 
0b8a 19			    add hl,de 
0b8b			Mult12U_NoAdd6: 
0b8b 29			    add hl,hl 
0b8c 87			    add a,a 
0b8d d0			    ret nc 
0b8e 19			    add hl,de 
0b8f c9			    ret 
0b90			 
0b90			; 
0b90			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b90			; In: Multiply A with DE 
0b90			;      Put lowest value in A for most efficient calculation 
0b90			; Out: HL = result 
0b90			; 
0b90			Mult12R: 
0b90 21 00 00		    ld hl,0 
0b93			Mult12R_Loop: 
0b93 cb 3f		    srl a 
0b95 30 01		    jr nc,Mult12R_NoAdd 
0b97 19			    add hl,de 
0b98			Mult12R_NoAdd: 
0b98 cb 23		    sla e 
0b9a cb 12		    rl d 
0b9c b7			    or a 
0b9d c2 93 0b		    jp nz,Mult12R_Loop 
0ba0 c9			    ret 
0ba1			 
0ba1			; 
0ba1			; Multiply 16-bit values (with 32-bit result) 
0ba1			; In: Multiply BC with DE 
0ba1			; Out: BCHL = result 
0ba1			; 
0ba1			Mult32: 
0ba1 79			    ld a,c 
0ba2 48			    ld c,b 
0ba3 21 00 00		    ld hl,0 
0ba6 06 10		    ld b,16 
0ba8			Mult32_Loop: 
0ba8 29			    add hl,hl 
0ba9 17			    rla 
0baa cb 11		    rl c 
0bac 30 07		    jr nc,Mult32_NoAdd 
0bae 19			    add hl,de 
0baf ce 00		    adc a,0 
0bb1 d2 b5 0b		    jp nc,Mult32_NoAdd 
0bb4 0c			    inc c 
0bb5			Mult32_NoAdd: 
0bb5 10 f1		    djnz Mult32_Loop 
0bb7 41			    ld b,c 
0bb8 4f			    ld c,a 
0bb9 c9			    ret 
0bba			 
0bba			 
0bba			 
0bba			; 
0bba			; Multiply 8-bit values 
0bba			; In:  Multiply H with E 
0bba			; Out: HL = result 
0bba			; 
0bba			Mult8: 
0bba 16 00		    ld d,0 
0bbc 6a			    ld l,d 
0bbd 06 08		    ld b,8 
0bbf			Mult8_Loop: 
0bbf 29			    add hl,hl 
0bc0 30 01		    jr nc,Mult8_NoAdd 
0bc2 19			    add hl,de 
0bc3			Mult8_NoAdd: 
0bc3 10 fa		    djnz Mult8_Loop 
0bc5 c9			    ret 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			 
0bc6			;;http://z80-heaven.wikidot.com/math 
0bc6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bc6			; 
0bc6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bc6			;     ld a,16        ;7 
0bc6			;     ld hl,0        ;10 
0bc6			;     jp $+5         ;10 
0bc6			;.DivLoop: 
0bc6			;       add hl,bc    ;-- 
0bc6			;       dec a        ;64 
0bc6			;       jr z,.DivLoopEnd        ;86 
0bc6			; 
0bc6			;       sla e        ;128 
0bc6			;       rl d         ;128 
0bc6			;       adc hl,hl    ;240 
0bc6			;       sbc hl,bc    ;240 
0bc6			;       jr nc,.DivLoop ;23|21 
0bc6			;       inc e        ;-- 
0bc6			;       jp .DivLoop+1 
0bc6			; 
0bc6			;.DivLoopEnd: 
0bc6			 
0bc6			;HL_Div_C: 
0bc6			;Inputs: 
0bc6			;     HL is the numerator 
0bc6			;     C is the denominator 
0bc6			;Outputs: 
0bc6			;     A is the remainder 
0bc6			;     B is 0 
0bc6			;     C is not changed 
0bc6			;     DE is not changed 
0bc6			;     HL is the quotient 
0bc6			; 
0bc6			;       ld b,16 
0bc6			;       xor a 
0bc6			;         add hl,hl 
0bc6			;         rla 
0bc6			;         cp c 
0bc6			;         jr c,$+4 
0bc6			;           inc l 
0bc6			;           sub c 
0bc6			;         djnz $-7 
0bc6			 
0bc6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bc6			 
0bc6			addatohl: 
0bc6 85			    add   a, l    ; A = A+L 
0bc7 6f			    ld    l, a    ; L = A+L 
0bc8 8c			    adc   a, h    ; A = A+L+H+carry 
0bc9 95			    sub   l       ; A = H+carry 
0bca 67			    ld    h, a    ; H = H+carry 
0bcb c9			ret 
0bcc			 
0bcc			addatode: 
0bcc 83			    add   a, e    ; A = A+L 
0bcd 5f			    ld    e, a    ; L = A+L 
0bce 8a			    adc   a, d    ; A = A+L+H+carry 
0bcf 93			    sub   e       ; A = H+carry 
0bd0 57			    ld    d, a    ; H = H+carry 
0bd1 c9			ret 
0bd2			 
0bd2			 
0bd2			addatobc: 
0bd2 81			    add   a, c    ; A = A+L 
0bd3 4f			    ld    c, a    ; L = A+L 
0bd4 88			    adc   a, b    ; A = A+L+H+carry 
0bd5 91			    sub   c       ; A = H+carry 
0bd6 47			    ld    b, a    ; H = H+carry 
0bd7 c9			ret 
0bd8			 
0bd8			subafromhl: 
0bd8			   ; If A=0 do nothing 
0bd8			    ; Otherwise flip A's sign. Since 
0bd8			    ; the upper byte becomes -1, also 
0bd8			    ; substract 1 from H. 
0bd8 ed 44		    neg 
0bda ca e3 0b		    jp    z, Skip 
0bdd 25			    dec   h 
0bde			     
0bde			    ; Now add the low byte as usual 
0bde			    ; Two's complement takes care of 
0bde			    ; ensuring the result is correct 
0bde 85			    add   a, l 
0bdf 6f			    ld    l, a 
0be0 8c			    adc   a, h 
0be1 95			    sub   l 
0be2 67			    ld    h, a 
0be3			Skip: 
0be3 c9				ret 
0be4			 
0be4			 
0be4			; compare hl and de 
0be4			; returns:  
0be4			; if hl = de, z=1, s=0, c0=0 
0be4			; if hl > de, z=0, s=0, c=0 
0be4			; if hl < de, z=0, s=1, c=1 
0be4			cmp16:	 
0be4 b7				or a 
0be5 ed 52			sbc hl,de 
0be7 e0				ret po 
0be8 7c				ld a,h 
0be9 1f				rra 
0bea ee 40			xor 01000000B 
0bec 37				scf 
0bed 8f				adc a,a 
0bee c9				ret 
0bef			 
0bef			 
0bef			; test if hl contains zero   - A is destroyed 
0bef			 
0bef			ishlzero:    
0bef b7				or a     ; reset flags 
0bf0 7c				ld a, h 
0bf1 b5				or l        	 
0bf2			 
0bf2 c9				ret 
0bf3			 
0bf3			 
0bf3			 
0bf3			 
0bf3			if FORTH_ENABLE_FLOATMATH 
0bf3			;include "float/bbcmath.z80" 
0bf3			include "float/lpfpcalc.asm" 
0bf3			endif 
0bf3			 
0bf3			 
0bf3			; eof 
0bf3			 
# End of file firmware_maths.asm
0bf3			include "firmware_strings.asm"   ; string handling  
0bf3			 
0bf3			 
0bf3			; TODO string len 
0bf3			; input text string, end on cr with zero term 
0bf3			; a offset into frame buffer to start prompt 
0bf3			; d is max length 
0bf3			; e is display size TODO 
0bf3			; c is current cursor position 
0bf3			; hl is ptr to where string will be stored 
0bf3			 
0bf3			 
0bf3			; TODO check limit of buffer for new inserts 
0bf3			; TODO check insert does not push beyond buffer 
0bf3			; TODO scroll in a limited display area 
0bf3			; TODO scroll whole screen on page wrap 
0bf3			 
0bf3			 
0bf3			; TODO handle KEY_PREVWORD 
0bf3			; TODO handle KEY_NEXTWORD 
0bf3			; TODO handle KEY_HOME 
0bf3			; TODO handle KEY_END 
0bf3			; TODO use LCD cursor? 
0bf3			 
0bf3 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0bf6 81					add c 
0bf7 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0bfa 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0bfd 79					ld a, c 
0bfe cd c6 0b				call addatohl 
0c01 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c04 7a					ld a,d 
0c05 32 75 ee			        ld (input_size), a       ; save length of input area 
0c08 79					ld a, c 
0c09 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0c0c 7b					ld a,e 
0c0d 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c10					 
0c10					 
0c10			 
0c10			;		ld a,(input_ptr) 
0c10			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c10			 
0c10			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c10					; init cursor shape if not set by the cin routines 
0c10 21 d3 eb				ld hl, cursor_shape 
0c13 3e ff				ld a, 255 
0c15 77					ld (hl), a 
0c16 23					inc hl 
0c17 3e 00				ld a, 0 
0c19 77					ld (hl), a 
0c1a			 
0c1a 3e 0f				ld a, CUR_BLINK_RATE 
0c1c 32 6f ee				ld (input_cur_flash), a 
0c1f 3e 01				ld a, 1 
0c21 32 6e ee				ld (input_cur_onoff),a 
0c24			 
0c24			;	if DEBUG_INPUT 
0c24			;		push af 
0c24			;		ld a, 'I' 
0c24			;		ld (debug_mark),a 
0c24			;		pop af 
0c24			;		CALLMONITOR 
0c24			;	endif 
0c24			.is1:		; main entry loop 
0c24			 
0c24			 
0c24			 
0c24					; pause 1ms 
0c24			 
0c24 3e 01				ld a, 1 
0c26 cd f3 08				call aDelayInMS 
0c29			 
0c29					; dec flash counter 
0c29 3a 6f ee				ld a, (input_cur_flash) 
0c2c 3d					dec a 
0c2d 32 6f ee				ld (input_cur_flash), a 
0c30 fe 00				cp 0 
0c32 20 0d				jr nz, .nochgstate 
0c34			 
0c34			 
0c34					; change state 
0c34 3a 6e ee				ld a,(input_cur_onoff) 
0c37 ed 44				neg 
0c39 32 6e ee				ld (input_cur_onoff),a 
0c3c			 
0c3c			 
0c3c					; reset on change of state 
0c3c 3e 0f				ld a, CUR_BLINK_RATE 
0c3e 32 6f ee				ld (input_cur_flash), a 
0c41			 
0c41			.nochgstate: 
0c41					 
0c41					 
0c41			 
0c41					; display cursor  
0c41			 
0c41			;		ld hl, (input_start) 
0c41			;		ld a, (input_cursor) 
0c41			;		call addatohl 
0c41			 
0c41					; get char under cursor and replace with cursor 
0c41 2a 78 ee		ld hl, (input_ptr) 
0c44			;		ld a, (hl) 
0c44			;		ld (input_under_cursor),a 
0c44			;		ld a, '_' 
0c44			;		ld (hl), a 
0c44			 
0c44					; display string 
0c44			 
0c44 ed 5b 76 ee			ld de, (input_start) 
0c48 3a 73 ee				ld a, (input_at_pos) 
0c4b cd ac 09				call str_at_display 
0c4e			;	        call update_display 
0c4e			 
0c4e					; find place to put the cursor 
0c4e			;		add h 
0c4e			;		ld l, display_row_1 
0c4e			;		sub l 
0c4e			; (input_at_pos) 
0c4e					;ld c, a 
0c4e			;		ld a, (input_cursor) 
0c4e			;		ld l, (input_at_pos) 
0c4e			;		;ld b, h 
0c4e			;		add l 
0c4e			;		ld (input_at_cursor),a 
0c4e					;ld l,h 
0c4e			 
0c4e			;		ld h, 0 
0c4e			;		ld l,(input_at_pos) 
0c4e			;		ld a, (input_cursor) 
0c4e			;		call addatohl 
0c4e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c4e			;		call subafromhl 
0c4e			;		ld a,l 
0c4e			;		ld (input_at_cursor), a 
0c4e			 
0c4e				if DEBUG_INPUT 
0c4e					ld a, (hardware_diag) 
0c4e					cp 0 
0c4e					jr z, .skip_input_diag 
0c4e			 
0c4e					ld a,(input_at_pos) 
0c4e					ld hl, LFSRSeed 
0c4e					call hexout 
0c4e					ld a, (input_cursor) 
0c4e					ld hl, LFSRSeed+2 
0c4e					call hexout 
0c4e					ld a,(input_at_cursor) 
0c4e					ld hl, LFSRSeed+4 
0c4e					call hexout 
0c4e			 
0c4e					ld a,(input_cur_onoff) 
0c4e					ld hl, LFSRSeed+6 
0c4e					call hexout 
0c4e			 
0c4e					ld a,(input_cur_flash) 
0c4e					ld hl, LFSRSeed+8 
0c4e					call hexout 
0c4e			 
0c4e					ld a,(input_len) 
0c4e					ld hl, LFSRSeed+10 
0c4e					call hexout 
0c4e					ld hl, LFSRSeed+12 
0c4e					ld a, 0 
0c4e					ld (hl),a 
0c4e					ld a, display_row_4 
0c4e					ld de, LFSRSeed 
0c4e					call str_at_display 
0c4e					.skip_input_diag: 
0c4e				endif 
0c4e			 
0c4e					; decide on if we are showing the cursor this time round 
0c4e			 
0c4e 3a 6e ee				ld a, (input_cur_onoff) 
0c51 fe ff				cp 255 
0c53 28 13				jr z, .skipcur 
0c55			 
0c55			 
0c55 3a 71 ee				ld a,(input_at_cursor) 
0c58 11 d3 eb				ld de, cursor_shape 
0c5b cd ac 09				call str_at_display 
0c5e			 
0c5e					; save length of current input string 
0c5e 2a 76 ee				ld hl, (input_start) 
0c61 cd 24 10				call strlenz 
0c64 7d					ld a,l 
0c65 32 69 ee				ld (input_len),a 
0c68			 
0c68			.skipcur: 
0c68			 
0c68 cd bc 09			        call update_display 
0c6b					 
0c6b			 
0c6b			 
0c6b					; wait 
0c6b				 
0c6b					; TODO loop without wait to flash the cursor and char under cursor	 
0c6b cd bf 58				call cin    ; _wait 
0c6e			 
0c6e fe 00				cp 0 
0c70 ca 24 0c				jp z, .is1 
0c73			 
0c73					; get ptr to char to input into 
0c73			 
0c73 4f					ld c,a 
0c74 2a 76 ee				ld hl, (input_start) 
0c77 3a 64 ee				ld a, (input_cursor) 
0c7a cd c6 0b				call addatohl 
0c7d 22 78 ee				ld (input_ptr), hl 
0c80 79					ld a,c 
0c81			 
0c81					; replace char under cursor 
0c81			 
0c81			;		ld hl, (input_ptr) 
0c81			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c81			;		ld (hl), a 
0c81			 
0c81			;	if DEBUG_INPUT 
0c81			;		push af 
0c81			;		ld a, 'i' 
0c81			;		ld (debug_mark),a 
0c81			;		pop af 
0c81			;		CALLMONITOR 
0c81			;	endif 
0c81 fe 0e				cp KEY_HOME 
0c83 20 0e				jr nz, .iske 
0c85			 
0c85 3a 73 ee				ld a, (input_at_pos) 
0c88 32 71 ee				ld (input_at_cursor),a 
0c8b 3e 00				ld a, 0 
0c8d 32 64 ee				ld (input_cursor), a 
0c90 c3 24 0c				jp .is1 
0c93					 
0c93 fe 0f		.iske:		cp KEY_END 
0c95 20 03				jr nz, .isknw 
0c97 c3 24 0c				jp .is1 
0c9a			 
0c9a fe 06		.isknw:		cp KEY_NEXTWORD 
0c9c 20 1b				jr nz, .iskpw 
0c9e			 
0c9e 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0ca1 7e					ld a,(hl)	 
0ca2 fe 00				cp 0 
0ca4 ca 24 0c				jp z, .is1    ; end of string 
0ca7 fe 20				cp ' ' 
0ca9 ca 24 0c				jp z, .is1    ; end of word 
0cac 23					inc hl 
0cad 22 78 ee				ld (input_ptr), hl 
0cb0 3a 71 ee				ld a, (input_at_cursor) 
0cb3 3c					inc a 
0cb4 32 71 ee				ld (input_at_cursor), a 
0cb7 18 e5				jr .isknwm 
0cb9			 
0cb9 fe 07		.iskpw:		cp KEY_PREVWORD 
0cbb 20 1b				jr nz, .iskl 
0cbd			.iskpwm:	 
0cbd 2a 78 ee				ld hl, (input_ptr) 
0cc0 7e					ld a,(hl)	 
0cc1 fe 00				cp 0  
0cc3 ca 24 0c				jp z, .is1    ; end of string 
0cc6 fe 20				cp ' ' 
0cc8 ca 24 0c				jp z, .is1    ; end of word 
0ccb 2b					dec hl 
0ccc 22 78 ee				ld (input_ptr), hl 
0ccf 3a 71 ee				ld a, (input_at_cursor) 
0cd2 3d					dec a 
0cd3 32 71 ee				ld (input_at_cursor), a 
0cd6 18 e5				jr .iskpwm 
0cd8			 
0cd8			 
0cd8 fe 0b		.iskl:		cp KEY_LEFT 
0cda 20 27				jr nz, .isk1 
0cdc			 
0cdc 3a 64 ee				ld a, (input_cursor) 
0cdf			 
0cdf fe 00				cp 0 
0ce1 ca 24 0c				jp z, .is1 		; at start of line to ignore  
0ce4			 
0ce4 3d					dec  a 		; TODO check underflow 
0ce5 32 64 ee				ld (input_cursor), a 
0ce8			 
0ce8 2a 78 ee				ld hl, (input_ptr) 
0ceb 2b					dec hl 
0cec 22 78 ee				ld (input_ptr), hl 
0cef					 
0cef 3a 71 ee				ld a, (input_at_cursor) 
0cf2 3d					dec a 
0cf3 32 71 ee				ld (input_at_cursor), a 
0cf6			 
0cf6 3e 01				ld a, 1		; show cursor moving 
0cf8 32 6e ee				ld (input_cur_onoff),a 
0cfb 3e 0f				ld a, CUR_BLINK_RATE 
0cfd 32 6f ee				ld (input_cur_flash), a 
0d00			 
0d00 c3 24 0c				jp .is1 
0d03			 
0d03 fe 0c		.isk1:		cp KEY_RIGHT 
0d05 20 2a				jr nz, .isk2 
0d07			 
0d07 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d0a 5f					ld e,a 
0d0b 3a 64 ee				ld a, (input_cursor) 
0d0e bb					cp e 
0d0f ca 24 0c				jp z, .is1		; at the end of string so dont go right 
0d12			 
0d12 3c					inc  a 		; TODO check overflow 
0d13 32 64 ee				ld (input_cursor), a 
0d16			 
0d16 3a 71 ee				ld a, (input_at_cursor) 
0d19 3c					inc a 
0d1a 32 71 ee				ld (input_at_cursor), a 
0d1d			 
0d1d 2a 78 ee				ld hl, (input_ptr) 
0d20 23					inc hl 
0d21 22 78 ee				ld (input_ptr), hl 
0d24			 
0d24 3e 01				ld a, 1		; show cursor moving 
0d26 32 6e ee				ld (input_cur_onoff),a 
0d29 3e 0f				ld a, CUR_BLINK_RATE 
0d2b 32 6f ee				ld (input_cur_flash), a 
0d2e			 
0d2e c3 24 0c				jp .is1 
0d31			 
0d31 fe 05		.isk2:		cp KEY_UP 
0d33			 
0d33 20 26				jr nz, .isk3 
0d35			 
0d35					; swap last command with the current on 
0d35			 
0d35					; move cursor to start of string 
0d35 2a 76 ee				ld hl, (input_start) 
0d38 22 78 ee				ld (input_ptr), hl 
0d3b			 
0d3b 3a 73 ee				ld a, (input_at_pos) 
0d3e 32 71 ee				ld (input_at_cursor), a 
0d41			 
0d41 3e 00				ld a, 0 
0d43 32 64 ee				ld (input_cursor), a 
0d46					 
0d46					; swap input and last command buffers 
0d46			 
0d46 21 87 e6				ld hl, os_cli_cmd 
0d49 11 86 e7				ld de, os_last_cmd 
0d4c 06 ff				ld b, 255 
0d4e 7e			.swap1:		ld a, (hl) 
0d4f 4f					ld c,a 
0d50 1a					ld a, (de) 
0d51 77					ld (hl), a 
0d52 79					ld a,c 
0d53 12					ld (de),a 
0d54 23					inc hl 
0d55 13					inc de 
0d56 10 f6				djnz .swap1 
0d58			 
0d58			 
0d58			 
0d58			 
0d58			 
0d58 c3 24 0c				jp .is1 
0d5b			 
0d5b fe 08		.isk3:		cp KEY_BS 
0d5d 20 3c				jr nz, .isk4 
0d5f			 
0d5f 3a 64 ee				ld a, (input_cursor) 
0d62			 
0d62 fe 00				cp 0 
0d64 ca 24 0c				jp z, .is1 		; at start of line to ignore  
0d67			 
0d67 3d					dec  a 		; TODO check underflow 
0d68 32 64 ee				ld (input_cursor), a 
0d6b			 
0d6b					; hl is source 
0d6b					; de needs to be source - 1 
0d6b			 
0d6b			;		ld a, 0 
0d6b			;		dec hl 
0d6b			;		ld (hl), a 
0d6b			 
0d6b 2a 78 ee				ld hl, (input_ptr) 
0d6e 2b					dec hl 
0d6f 22 78 ee				ld (input_ptr), hl 
0d72			 
0d72					; shift all data 
0d72			 
0d72 e5					push hl 
0d73 23					inc hl 
0d74 d1					pop de 
0d75 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d78 4f					ld c,a 
0d79 06 00				ld b,0 
0d7b ed b0				ldir  
0d7d			 
0d7d			 
0d7d			 
0d7d			 
0d7d 3a 71 ee				ld a, (input_at_cursor) 
0d80 3d					dec a 
0d81 32 71 ee				ld (input_at_cursor), a 
0d84			 
0d84			 
0d84 3e 01				ld a, 1		; show cursor moving 
0d86 32 6e ee				ld (input_cur_onoff),a 
0d89 3e 0f				ld a, CUR_BLINK_RATE 
0d8b 32 6f ee				ld (input_cur_flash), a 
0d8e			 
0d8e					; remove char 
0d8e 3a 71 ee				ld a, (input_at_cursor) 
0d91 3c					inc a 
0d92 11 1c 0e				ld de,.iblank 
0d95 cd ac 09				call str_at_display 
0d98			 
0d98 c3 24 0c				jp .is1 
0d9b			 
0d9b fe 0d		.isk4:		cp KEY_CR 
0d9d 28 6c				jr z, .endinput 
0d9f			 
0d9f					; else add the key press to the end 
0d9f			 
0d9f 4f					ld c, a			; save key pressed 
0da0			 
0da0 7e					ld a,(hl)		; get what is currently under char 
0da1			 
0da1 fe 00				cp 0			; we are at the end of the string 
0da3 20 2f				jr nz, .onchar 
0da5					 
0da5					; add a char to the end of the string 
0da5				 
0da5 71					ld (hl),c 
0da6 23					inc hl 
0da7			;		ld a,' ' 
0da7			;		ld (hl),a 
0da7			;		inc hl 
0da7 3e 00				ld a,0 
0da9 77					ld (hl),a 
0daa 2b					dec hl 
0dab			 
0dab 3a 64 ee				ld a, (input_cursor) 
0dae 3c					inc a				; TODO check max string length and scroll  
0daf 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0db2							 
0db2 3a 71 ee				ld a, (input_at_cursor) 
0db5 3c					inc a 
0db6 32 71 ee				ld (input_at_cursor), a 
0db9			 
0db9 2a 78 ee				ld hl, (input_ptr) 
0dbc 23					inc hl 
0dbd 22 78 ee				ld (input_ptr), hl 
0dc0			 
0dc0 2a 78 ee				ld hl, (input_ptr) 
0dc3 23					inc hl 
0dc4 22 78 ee				ld (input_ptr), hl 
0dc7			;	if DEBUG_INPUT 
0dc7			;		push af 
0dc7			;		ld a, '+' 
0dc7			;		ld (debug_mark),a 
0dc7			;		pop af 
0dc7			;		CALLMONITOR 
0dc7			;	endif 
0dc7 3e 01				ld a, 1		; show cursor moving 
0dc9 32 6e ee				ld (input_cur_onoff),a 
0dcc 3e 0f				ld a, CUR_BLINK_RATE 
0dce 32 6f ee				ld (input_cur_flash), a 
0dd1 c3 24 0c				jp .is1 
0dd4					 
0dd4			 
0dd4			 
0dd4					; if on a char then insert 
0dd4			.onchar: 
0dd4			 
0dd4					; TODO over flow check: make sure insert does not blow out buffer 
0dd4			 
0dd4					; need to do some maths to use lddr 
0dd4			 
0dd4 e5					push hl   ; save char pos 
0dd5 c5					push bc 
0dd6			 
0dd6 2a 76 ee				ld hl, (input_start) 
0dd9 3a 69 ee				ld a, (input_len) 
0ddc cd c6 0b				call addatohl  		; end of string 
0ddf 23					inc hl 
0de0 23					inc hl		; past zero term 
0de1 e5					push hl 
0de2 23					inc hl 
0de3 e5					push hl  
0de4			 
0de4								; start and end of lddr set, now how much to move? 
0de4			 
0de4							 
0de4 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0de7 47					ld b,a 
0de8 3a 69 ee				ld a,(input_len) 
0deb 5f					ld e,a 
0dec 90					sub b 
0ded 3c					inc a		;?? 
0dee 3c					inc a		;?? 
0def 3c					inc a		;?? 
0df0			 
0df0 06 00				ld b,0 
0df2 4f					ld c,a 
0df3			 
0df3				if DEBUG_INPUT 
0df3					push af 
0df3					ld a, 'i' 
0df3					ld (debug_mark),a 
0df3					pop af 
0df3			;		CALLMONITOR 
0df3				endif 
0df3 d1					pop de 
0df4 e1					pop hl 
0df5				if DEBUG_INPUT 
0df5					push af 
0df5					ld a, 'I' 
0df5					ld (debug_mark),a 
0df5					pop af 
0df5			;		CALLMONITOR 
0df5				endif 
0df5 ed b8				lddr 
0df7				 
0df7			 
0df7			 
0df7					; TODO have a key for insert/overwrite mode???? 
0df7 c1					pop bc 
0df8 e1					pop hl 
0df9 71					ld (hl), c		; otherwise overwrite current char 
0dfa					 
0dfa			 
0dfa			 
0dfa			 
0dfa 3a 64 ee				ld a, (input_cursor) 
0dfd 3c					inc  a 		; TODO check overflow 
0dfe 32 64 ee				ld (input_cursor), a 
0e01			 
0e01 3a 71 ee				ld a, (input_at_cursor) 
0e04 3c					inc a 
0e05 32 71 ee				ld (input_at_cursor), a 
0e08			 
0e08 c3 24 0c				jp .is1 
0e0b			 
0e0b			.endinput:	; TODO look for end of string 
0e0b			 
0e0b					; add trailing space for end of token 
0e0b			 
0e0b 2a 76 ee				ld hl, (input_start) 
0e0e 3a 69 ee				ld a,(input_len) 
0e11 cd c6 0b				call addatohl 
0e14 3e 20				ld a, ' ' 
0e16 77					ld (hl),a 
0e17					; TODO eof of parse marker 
0e17			 
0e17 23					inc hl 
0e18 3e 00				ld a, 0 
0e1a 77					ld (hl),a 
0e1b			 
0e1b			 
0e1b c9					ret 
0e1c			 
0e1c .. 00		.iblank: db " ",0 
0e1e			 
0e1e			 
0e1e 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e21 22 76 ee				ld (input_start), hl 
0e24 3e 01				ld a,1			; add cursor 
0e26 77					ld (hl),a 
0e27 23					inc hl 
0e28 3e 00				ld a,0 
0e2a 77					ld (hl),a 
0e2b 22 78 ee				ld (input_ptr), hl 
0e2e 7a					ld a,d 
0e2f 32 75 ee				ld (input_size), a 
0e32 3e 00				ld a,0 
0e34 32 64 ee				ld (input_cursor),a 
0e37			.instr1:	 
0e37			 
0e37					; TODO do block cursor 
0e37					; TODO switch cursor depending on the modifer key 
0e37			 
0e37					; update cursor shape change on key hold 
0e37			 
0e37 2a 78 ee				ld hl, (input_ptr) 
0e3a 2b					dec hl 
0e3b 3a d3 eb				ld a,(cursor_shape) 
0e3e 77					ld (hl), a 
0e3f			 
0e3f					; display entered text 
0e3f 3a 73 ee				ld a,(input_at_pos) 
0e42 cd d4 57		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e45 ed 5b 76 ee	            	LD   de, (input_start) 
0e49 cd c9 57		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e4c			 
0e4c cd bf 58				call cin 
0e4f fe 00				cp 0 
0e51 28 e4				jr z, .instr1 
0e53			 
0e53					; proecess keyboard controls first 
0e53			 
0e53 2a 78 ee				ld hl,(input_ptr) 
0e56			 
0e56 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e58 28 5a				jr z, .instrcr 
0e5a			 
0e5a fe 08				cp KEY_BS 	; back space 
0e5c 20 0f				jr nz, .instr2 
0e5e					; process back space 
0e5e			 
0e5e					; TODO stop back space if at start of string 
0e5e 2b					dec hl 
0e5f 2b					dec hl ; to over write cursor 
0e60 3a d3 eb				ld a,(cursor_shape) 
0e63					;ld a,0 
0e63 77					ld (hl),a 
0e64 23					inc hl 
0e65 3e 20				ld a," " 
0e67 77					ld (hl),a 
0e68 22 78 ee				ld (input_ptr),hl 
0e6b					 
0e6b			 
0e6b 18 ca				jr .instr1 
0e6d			 
0e6d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e6f 20 06				jr nz, .instr3 
0e71 2b					dec hl 
0e72 22 78 ee				ld (input_ptr),hl 
0e75 18 c0				jr .instr1 
0e77				 
0e77 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e79 20 06				jr nz, .instr4 
0e7b 23					inc hl 
0e7c 22 78 ee				ld (input_ptr),hl 
0e7f 18 b6				jr .instr1 
0e81			 
0e81 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e83 20 06				jr nz, .instr5 
0e85 2b					dec hl 
0e86 22 78 ee				ld (input_ptr),hl 
0e89 18 ac				jr .instr1 
0e8b			 
0e8b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e8d 20 06				jr nz, .instr6 
0e8f 2b					dec hl 
0e90 22 78 ee				ld (input_ptr),hl 
0e93 18 a2				jr .instr1 
0e95 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e97 20 0b				jr nz, .instrnew 
0e99			 
0e99 21 60 e3			ld hl, scratch 
0e9c 11 86 e7			ld de, os_last_cmd 
0e9f cd bd 0e			call strcpy 
0ea2 18 93				jr .instr1 
0ea4			 
0ea4			 
0ea4			.instrnew:	; no special key pressed to see if we have room to store it 
0ea4			 
0ea4					; TODO do string size test 
0ea4			 
0ea4 2b					dec hl ; to over write cursor 
0ea5 77					ld (hl),a 
0ea6 23					inc hl 
0ea7 3a d3 eb				ld a,(cursor_shape) 
0eaa 77					ld (hl),a 
0eab 23					inc hl 
0eac 3e 00				ld a,0 
0eae 77					ld (hl),a 
0eaf			 
0eaf 22 78 ee				ld (input_ptr),hl 
0eb2					 
0eb2 18 83				jr .instr1 
0eb4 2b			.instrcr:	dec hl		; remove cursor 
0eb5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0eb7 77					ld (hl),a 
0eb8 23					inc hl 
0eb9 3e 00				ld a,0 
0ebb 77					ld (hl),a 
0ebc			 
0ebc			 
0ebc					; if at end of line scroll up    
0ebc					; TODO detecting only end of line 4 for scroll up  
0ebc			 
0ebc					;ld   
0ebc			 
0ebc c9					ret 
0ebd			 
0ebd			 
0ebd			; strcpy hl = dest, de source 
0ebd			 
0ebd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ebe b7			            OR   A              ;Null terminator? 
0ebf c8			            RET  Z              ;Yes, so finished 
0ec0 1a					ld a,(de) 
0ec1 77					ld (hl),a 
0ec2 13			            INC  DE             ;Point to next character 
0ec3 23					inc hl 
0ec4 18 f7		            JR   strcpy       ;Repeat 
0ec6 c9					ret 
0ec7			 
0ec7			 
0ec7			; TODO string_at  
0ec7			; pass string which starts with lcd offset address and then null term string 
0ec7			 
0ec7			; TODO string to dec 
0ec7			; TODO string to hex 
0ec7			; TODO byte to string hex 
0ec7			; TODO byte to string dec 
0ec7			 
0ec7			 
0ec7			 
0ec7			; from z80uartmonitor 
0ec7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ec7			; pass hl for where to put the text 
0ec7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec7 c5			hexout:	PUSH BC 
0ec8 f5					PUSH AF 
0ec9 47					LD B, A 
0eca					; Upper nybble 
0eca cb 3f				SRL A 
0ecc cb 3f				SRL A 
0ece cb 3f				SRL A 
0ed0 cb 3f				SRL A 
0ed2 cd e2 0e				CALL tohex 
0ed5 77					ld (hl),a 
0ed6 23					inc hl	 
0ed7					 
0ed7					; Lower nybble 
0ed7 78					LD A, B 
0ed8 e6 0f				AND 0FH 
0eda cd e2 0e				CALL tohex 
0edd 77					ld (hl),a 
0ede 23					inc hl	 
0edf					 
0edf f1					POP AF 
0ee0 c1					POP BC 
0ee1 c9					RET 
0ee2					 
0ee2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ee2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ee2			tohex: 
0ee2 e5					PUSH HL 
0ee3 d5					PUSH DE 
0ee4 16 00				LD D, 0 
0ee6 5f					LD E, A 
0ee7 21 ef 0e				LD HL, .DATA 
0eea 19					ADD HL, DE 
0eeb 7e					LD A, (HL) 
0eec d1					POP DE 
0eed e1					POP HL 
0eee c9					RET 
0eef			 
0eef			.DATA: 
0eef 30					DEFB	30h	; 0 
0ef0 31					DEFB	31h	; 1 
0ef1 32					DEFB	32h	; 2 
0ef2 33					DEFB	33h	; 3 
0ef3 34					DEFB	34h	; 4 
0ef4 35					DEFB	35h	; 5 
0ef5 36					DEFB	36h	; 6 
0ef6 37					DEFB	37h	; 7 
0ef7 38					DEFB	38h	; 8 
0ef8 39					DEFB	39h	; 9 
0ef9 41					DEFB	41h	; A 
0efa 42					DEFB	42h	; B 
0efb 43					DEFB	43h	; C 
0efc 44					DEFB	44h	; D 
0efd 45					DEFB	45h	; E 
0efe 46					DEFB	46h	; F 
0eff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eff			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0eff			;;    subtract $30, if result > 9 then subtract $7 more 
0eff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eff			atohex: 
0eff d6 30				SUB $30 
0f01 fe 0a				CP 10 
0f03 f8					RET M		; If result negative it was 0-9 so we're done 
0f04 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f06 c9					RET		 
0f07			 
0f07			 
0f07			 
0f07			 
0f07			; Get 2 ASCII characters as hex byte from pointer in hl 
0f07			 
0f07			BYTERD: 
0f07 16 00			LD	D,00h		;Set up 
0f09 cd 11 0f			CALL	HEXCON		;Get byte and convert to hex 
0f0c 87				ADD	A,A		;First nibble so 
0f0d 87				ADD	A,A		;multiply by 16 
0f0e 87				ADD	A,A		; 
0f0f 87				ADD	A,A		; 
0f10 57				LD	D,A		;Save hi nibble in D 
0f11			HEXCON: 
0f11 7e				ld a, (hl)		;Get next chr 
0f12 23				inc hl 
0f13 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f15 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f17 38 02			JR	C,NALPHA	;If so miss next bit 
0f19 d6 07			SUB	007h		;Else convert alpha 
0f1b			NALPHA: 
0f1b b2				OR	D		;Add hi nibble back 
0f1c c9				RET			; 
0f1d			 
0f1d			 
0f1d			; 
0f1d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f1d			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f1d			; characters (0-9a-f) are accepted. 
0f1d			; 
0f1d			;get_word        push    af 
0f1d			;                call    get_byte        ; Get the upper byte 
0f1d			;                ld      h, a 
0f1d			;                call    get_byte        ; Get the lower byte 
0f1d			;                ld      l, a 
0f1d			;                pop     af 
0f1d			;                ret 
0f1d			; 
0f1d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f1d			; the routine get_nibble is used only valid characters are accepted - the  
0f1d			; input routine only accepts characters 0-9a-f. 
0f1d			; 
0f1d c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f1e 7e					ld a,(hl) 
0f1f 23					inc hl 
0f20 cd 45 0f		                call    nibble2val      ; Get upper nibble 
0f23 cb 07		                rlc     a 
0f25 cb 07		                rlc     a 
0f27 cb 07		                rlc     a 
0f29 cb 07		                rlc     a 
0f2b 47			                ld      b, a            ; Save upper four bits 
0f2c 7e					ld a,(hl) 
0f2d cd 45 0f		                call    nibble2val      ; Get lower nibble 
0f30 b0			                or      b               ; Combine both nibbles 
0f31 c1			                pop     bc              ; Restore B (and C) 
0f32 c9			                ret 
0f33			; 
0f33			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f33			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f33			; to the serial line interface. The lower 4 bits of A contain the value of  
0f33			; that particular digit. 
0f33			; 
0f33			;get_nibble      ld a,(hl)           ; Read a character 
0f33			;                call    to_upper        ; Convert to upper case 
0f33			;                call    is_hex          ; Was it a hex digit? 
0f33			;                jr      nc, get_nibble  ; No, get another character 
0f33			 ;               call    nibble2val      ; Convert nibble to value 
0f33			 ;               call    print_nibble 
0f33			 ;               ret 
0f33			; 
0f33			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f33			; A valid hexadecimal digit is denoted by a set C flag. 
0f33			; 
0f33			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f33			;                ret     nc              ; Yes 
0f33			;                cp      '0'             ; Less than '0'? 
0f33			;                jr      nc, is_hex_1    ; No, continue 
0f33			;                ccf                     ; Complement carry (i.e. clear it) 
0f33			;                ret 
0f33			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f33			;                ret     c               ; Yes 
0f33			;                cp      'A'             ; Less than 'A'? 
0f33			;                jr      nc, is_hex_2    ; No, continue 
0f33			;                ccf                     ; Yes - clear carry and return 
0f33			;                ret 
0f33			;is_hex_2        scf                     ; Set carry 
0f33			;                ret 
0f33			; 
0f33			; Convert a single character contained in A to upper case: 
0f33			; 
0f33 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f35 d8			                ret     c 
0f36 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f38 d0			                ret     nc              ; Nothing to do, either 
0f39 e6 5f		                and     $5f             ; Convert to upper case 
0f3b c9			                ret 
0f3c			 
0f3c			 
0f3c			to_lower: 
0f3c			 
0f3c			   ; if char is in [A-Z] make it lower case 
0f3c			 
0f3c			   ; enter : a = char 
0f3c			   ; exit  : a = lower case char 
0f3c			   ; uses  : af 
0f3c			 
0f3c fe 41		   cp 'A' 
0f3e d8			   ret c 
0f3f			    
0f3f fe 5b		   cp 'Z'+1 
0f41 d0			   ret nc 
0f42			    
0f42 f6 20		   or $20 
0f44 c9			   ret 
0f45			 
0f45			; 
0f45			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f45			; corresponding value in A. 
0f45			; 
0f45 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f47 38 02		                jr      c, nibble2val_1 ; Yes 
0f49 d6 07		                sub     7               ; Adjust for A-F 
0f4b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f4d e6 0f		                and     $f              ; Only return lower 4 bits 
0f4f c9			                ret 
0f50			; 
0f50			; Print_nibble prints a single hex nibble which is contained in the lower  
0f50			; four bits of A: 
0f50			; 
0f50			;print_nibble    push    af              ; We won't destroy the contents of A 
0f50			;                and     $f              ; Just in case... 
0f50			;                add     a, '0'             ; If we have a digit we are done here. 
0f50			;                cp      '9' + 1         ; Is the result > 9? 
0f50			;                jr      c, print_nibble_1 
0f50			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f50			;print_nibble_1  call    putc            ; Print the nibble and 
0f50			;                pop     af              ; restore the original value of A 
0f50			;                ret 
0f50			;; 
0f50			;; Send a CR/LF pair: 
0f50			; 
0f50			;crlf            push    af 
0f50			;                ld      a, cr 
0f50			;                call    putc 
0f50			;                ld      a, lf 
0f50			;                call    putc 
0f50			;                pop     af 
0f50			;                ret 
0f50			; 
0f50			; Print_word prints the four hex digits of a word to the serial line. The  
0f50			; word is expected to be in HL. 
0f50			; 
0f50			;print_word      push    hl 
0f50			;                push    af 
0f50			;                ld      a, h 
0f50			;                call    print_byte 
0f50			;                ld      a, l 
0f50			;                call    print_byte 
0f50			;                pop     af 
0f50			;                pop     hl 
0f50			;                ret 
0f50			; 
0f50			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f50			; The byte to be printed is expected to be in A. 
0f50			; 
0f50			;print_byte      push    af              ; Save the contents of the registers 
0f50			;                push    bc 
0f50			;                ld      b, a 
0f50			;                rrca 
0f50			;                rrca 
0f50			;                rrca 
0f50			;                rrca 
0f50			;                call    print_nibble    ; Print high nibble 
0f50			;                ld      a, b 
0f50			;                call    print_nibble    ; Print low nibble 
0f50			;                pop     bc              ; Restore original register contents 
0f50			;                pop     af 
0f50			;                ret 
0f50			 
0f50			 
0f50			 
0f50			 
0f50			 
0f50			fourehexhl:  
0f50 7e				ld a,(hl) 
0f51 cd ff 0e			call atohex 
0f54 cb 3f				SRL A 
0f56 cb 3f				SRL A 
0f58 cb 3f				SRL A 
0f5a cb 3f				SRL A 
0f5c 47				ld b, a 
0f5d 23				inc hl 
0f5e 7e				ld a,(hl) 
0f5f 23				inc hl 
0f60 cd ff 0e			call atohex 
0f63 80				add b 
0f64 57				ld d,a 
0f65 7e				ld a,(hl) 
0f66 cd ff 0e			call atohex 
0f69 cb 3f				SRL A 
0f6b cb 3f				SRL A 
0f6d cb 3f				SRL A 
0f6f cb 3f				SRL A 
0f71 47				ld b, a 
0f72 23				inc hl 
0f73 7e				ld a,(hl) 
0f74 23				inc hl 
0f75 cd ff 0e			call atohex 
0f78 80				add b 
0f79 5f				ld e, a 
0f7a d5				push de 
0f7b e1				pop hl 
0f7c c9				ret 
0f7d			 
0f7d			; pass hl. returns z set if the byte at hl is a digit 
0f7d			;isdigithl:  
0f7d			;	push bc 
0f7d			;	ld a,(hl) 
0f7d			;	cp ':' 
0f7d			;	jr nc, .isdf 		; > 
0f7d			;	cp '0' 
0f7d			;	jr c, .isdf		; < 
0f7d			; 
0f7d			;	; TODO find a better way to set z 
0f7d			; 
0f7d			;	ld b,a 
0f7d			;	cp b 
0f7d			;	pop bc 
0f7d			;	ret 
0f7d			; 
0f7d			;.isdf:	; not digit so clear z 
0f7d			; 
0f7d			;	; TODO find a better way to unset z 
0f7d			; 
0f7d			;	ld b,a 
0f7d			;	inc b 
0f7d			;	cp b 
0f7d			; 
0f7d			;	pop bc 
0f7d			;	ret 
0f7d				 
0f7d				 
0f7d			 
0f7d			 
0f7d			; pass hl as the four byte address to load 
0f7d			 
0f7d			get_word_hl:  
0f7d e5				push hl 
0f7e cd 1d 0f			call get_byte 
0f81				 
0f81 47				ld b, a 
0f82			 
0f82 e1				pop hl 
0f83 23				inc hl 
0f84 23				inc hl 
0f85			 
0f85			; TODO not able to handle a-f  
0f85 7e				ld a,(hl) 
0f86			;	;cp ':' 
0f86			;	cp 'g' 
0f86			;	jr nc, .single_byte_hl 		; > 
0f86			;	cp 'G' 
0f86			;	jr nc, .single_byte_hl 		; > 
0f86			;	cp '0' 
0f86			;	jr c, .single_byte_hl		; < 
0f86			 
0f86				;call isdigithl 
0f86 fe 00			cp 0 
0f88 28 06			jr z, .single_byte_hl 
0f8a			 
0f8a			.getwhln:   ; hex word so get next byte 
0f8a			 
0f8a cd 1d 0f			call get_byte 
0f8d 6f				ld l, a 
0f8e 60				ld h,b 
0f8f c9				ret 
0f90 68			.single_byte_hl:   ld l,b 
0f91 26 00				ld h,0 
0f93 c9					ret 
0f94			 
0f94			 
0f94			 
0f94			 
0f94 21 dd 16			ld hl,asc+1 
0f97			;	ld a, (hl) 
0f97			;	call nibble2val 
0f97 cd 1d 0f			call get_byte 
0f9a			 
0f9a			;	call fourehexhl 
0f9a 32 94 e3			ld (scratch+52),a 
0f9d				 
0f9d 21 92 e3			ld hl,scratch+50 
0fa0 22 83 e6			ld (os_cur_ptr),hl 
0fa3			 
0fa3 c9				ret 
0fa4			 
0fa4			 
0fa4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0fa4			 
0fa4			; Decimal Unsigned Version 
0fa4			 
0fa4			;Number in a to decimal ASCII 
0fa4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0fa4			;Example: display a=56 as "056" 
0fa4			;input: a = number 
0fa4			;Output: a=0,value of a in the screen 
0fa4			;destroys af,bc (don't know about hl and de) 
0fa4			DispAToASCII: 
0fa4 0e 9c			ld	c,-100 
0fa6 cd b0 0f			call	.Na1 
0fa9 0e f6			ld	c,-10 
0fab cd b0 0f			call	.Na1 
0fae 0e ff			ld	c,-1 
0fb0 06 2f		.Na1:	ld	b,'0'-1 
0fb2 04			.Na2:	inc	b 
0fb3 81				add	a,c 
0fb4 38 fc			jr	c,.Na2 
0fb6 91				sub	c		;works as add 100/10/1 
0fb7 f5				push af		;safer than ld c,a 
0fb8 78				ld	a,b		;char is in b 
0fb9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fb9 f1				pop af		;safer than ld a,c 
0fba c9				ret 
0fbb			 
0fbb			; Decimal Signed Version 
0fbb			 
0fbb			; DispA 
0fbb			; -------------------------------------------------------------- 
0fbb			; Converts a signed integer value to a zero-terminated ASCII 
0fbb			; string representative of that value (using radix 10). 
0fbb			; -------------------------------------------------------------- 
0fbb			; INPUTS: 
0fbb			;     HL     Value to convert (two's complement integer). 
0fbb			;     DE     Base address of string destination. (pointer). 
0fbb			; -------------------------------------------------------------- 
0fbb			; OUTPUTS: 
0fbb			;     None 
0fbb			; -------------------------------------------------------------- 
0fbb			; REGISTERS/MEMORY DESTROYED 
0fbb			; AF HL 
0fbb			; -------------------------------------------------------------- 
0fbb			 
0fbb			;DispHLToASCII: 
0fbb			;   push    de 
0fbb			;   push    bc 
0fbb			; 
0fbb			;; Detect sign of HL. 
0fbb			;    bit    7, h 
0fbb			;    jr     z, ._DoConvert 
0fbb			; 
0fbb			;; HL is negative. Output '-' to string and negate HL. 
0fbb			;    ld     a, '-' 
0fbb			;    ld     (de), a 
0fbb			;    inc    de 
0fbb			; 
0fbb			;; Negate HL (using two's complement) 
0fbb			;    xor    a 
0fbb			;    sub    l 
0fbb			;    ld     l, a 
0fbb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fbb			;    sbc    a, h 
0fbb			;    ld     h, a 
0fbb			; 
0fbb			;; Convert HL to digit characters 
0fbb			;._DoConvert: 
0fbb			;    ld     b, 0     ; B will count character length of number 
0fbb			;-   ld     a, 10 
0fbb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fbb			;    push   af 
0fbb			;    inc    b 
0fbb			;    ld     a, h 
0fbb			;    or     l 
0fbb			;    jr     nz, - 
0fbb			; 
0fbb			;; Retrieve digits from stack 
0fbb			;-   pop    af 
0fbb			;    or     $30 
0fbb			;    ld     (de), a 
0fbb			;    inc    de 
0fbb			;    djnz   - 
0fbb			; 
0fbb			;; Terminate string with NULL 
0fbb			;    xor    a 
0fbb			;    ld     (de), a 
0fbb			; 
0fbb			;    pop    bc 
0fbb			;    pop    de 
0fbb			;    ret 
0fbb			 
0fbb			;Comments 
0fbb			; 
0fbb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fbb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fbb			;    Note that the output string will not be fixed-width. 
0fbb			; 
0fbb			;Example Usage 
0fbb			; 
0fbb			;    ld    hl, -1004 
0fbb			;    ld    de, OP1 
0fbb			;    call  DispA 
0fbb			;    ld    hl, OP1 
0fbb			;    syscall  PutS 
0fbb			 
0fbb			 
0fbb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fbb			 
0fbb			 
0fbb			;Converts an ASCII string to an unsigned 16-bit integer 
0fbb			;Quits when it reaches a non-decimal digit 
0fbb			 
0fbb			string_to_uint16: 
0fbb			atoui_16: 
0fbb			;Input: 
0fbb			;     DE points to the string 
0fbb			;Outputs: 
0fbb			;     HL is the result 
0fbb			;     A is the 8-bit value of the number 
0fbb			;     DE points to the byte after the number 
0fbb			;Destroys: 
0fbb			;     BC 
0fbb			;       if the string is non-empty, BC is HL/10 
0fbb			;Size:  24 bytes 
0fbb			;Speed: 42+d(104+{0,9}) 
0fbb			;       d is the number of digits in the number 
0fbb			;       max is 640 cycles for a 5 digit number 
0fbb			;Assuming no leading zeros: 
0fbb			;1 digit:  146cc 
0fbb			;2 digit:  250cc 
0fbb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fbb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fbb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fbb			;avg: 544.81158447265625cc (544+13297/16384) 
0fbb			;=============================================================== 
0fbb 21 00 00		  ld hl,0 
0fbe			.u16a: 
0fbe 1a			  ld a,(de) 
0fbf d6 30		  sub 30h 
0fc1 fe 0a		  cp 10 
0fc3 d0			  ret nc 
0fc4 13			  inc de 
0fc5 44			  ld b,h 
0fc6 4d			  ld c,l 
0fc7 29			  add hl,hl 
0fc8 29			  add hl,hl 
0fc9 09			  add hl,bc 
0fca 29			  add hl,hl 
0fcb 85			  add a,l 
0fcc 6f			  ld l,a 
0fcd 30 ef		  jr nc,.u16a 
0fcf 24			  inc h 
0fd0 c3 be 0f		  jp .u16a 
0fd3			 
0fd3			 
0fd3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fd3			 
0fd3			;written by Zeda 
0fd3			;Converts a 16-bit unsigned integer to an ASCII string. 
0fd3			 
0fd3			uitoa_16: 
0fd3			;Input: 
0fd3			;   DE is the number to convert 
0fd3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fd3			;Output: 
0fd3			;   HL points to the null-terminated ASCII string 
0fd3			;      NOTE: This isn't necessarily the same as the input HL. 
0fd3 d5			  push de 
0fd4 c5			  push bc 
0fd5 f5			  push af 
0fd6 eb			  ex de,hl 
0fd7			 
0fd7 01 f0 d8		  ld bc,-10000 
0fda 3e 2f		  ld a,'0'-1 
0fdc 3c			  inc a 
0fdd 09			  add hl,bc  
0fde 38 fc		   jr c,$-2 
0fe0 12			  ld (de),a 
0fe1 13			  inc de 
0fe2			 
0fe2 01 e8 03		  ld bc,1000 
0fe5 3e 3a		  ld a,'9'+1 
0fe7 3d			  dec a  
0fe8 09			  add hl,bc  
0fe9 30 fc		   jr nc,$-2 
0feb 12			  ld (de),a 
0fec 13			  inc de 
0fed			 
0fed 01 9c ff		  ld bc,-100 
0ff0 3e 2f		  ld a,'0'-1 
0ff2 3c			  inc a  
0ff3 09			  add hl,bc  
0ff4 38 fc		   jr c,$-2 
0ff6 12			  ld (de),a 
0ff7 13			  inc de 
0ff8			 
0ff8 7d			  ld a,l 
0ff9 26 3a		  ld h,'9'+1 
0ffb 25			  dec h  
0ffc c6 0a		  add a,10  
0ffe 30 fb		   jr nc,$-3 
1000 c6 30		  add a,'0' 
1002 eb			  ex de,hl 
1003 72			  ld (hl),d 
1004 23			  inc hl 
1005 77			  ld (hl),a 
1006 23			  inc hl 
1007 36 00		  ld (hl),0 
1009			 
1009			;Now strip the leading zeros 
1009 0e fa		  ld c,-6 
100b 09			  add hl,bc 
100c 3e 30		  ld a,'0' 
100e 23			  inc hl  
100f be			  cp (hl)  
1010 28 fc		  jr z,$-2 
1012			 
1012			;Make sure that the string is non-empty! 
1012 7e			  ld a,(hl) 
1013 b7			  or a 
1014 20 01		  jr nz,.atoub 
1016 2b			  dec hl 
1017			.atoub: 
1017			 
1017 f1			  pop af 
1018 c1			  pop bc 
1019 d1			  pop de 
101a c9			  ret 
101b			 
101b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
101b			 
101b			toUpper: 
101b			;A is the char. 
101b			;If A is a lowercase letter, this sets it to the matching uppercase 
101b			;18cc or 30cc or 41cc 
101b			;avg: 26.75cc 
101b fe 61		  cp 'a' 
101d d8			  ret c 
101e fe 7b		  cp 'z'+1 
1020 d0			  ret nc 
1021 d6 20		  sub 'a'-'A' 
1023 c9			  ret 
1024			 
1024			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1024			 
1024			; String Length 
1024			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1024			 
1024			; Get the length of the null-terminated string starting at $8000 hl 
1024			;    LD     HL, $8000 
1024			 
1024			strlenz: 
1024			 
1024 af			    XOR    A               ; Zero is the value we are looking for. 
1025 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1026 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1027			                           ; 65, 536 bytes (the entire addressable memory space). 
1027 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1029			 
1029			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1029 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
102a 6f			    LD     L, A             ; number of bytes 
102b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
102d 2b			    DEC    HL              ; Compensate for null. 
102e c9				ret 
102f			 
102f			; Get the length of the A terminated string starting at $8000 hl 
102f			;    LD     HL, $8000 
102f			 
102f			strlent: 
102f			 
102f			                  ; A is the value we are looking for. 
102f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1031 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1033			                           ; 65, 536 bytes (the entire addressable memory space). 
1033 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1035			 
1035			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1035 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1037 2e 00		    LD     L, 0             ; number of bytes 
1039 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
103b 2b			    DEC    HL              ; Compensate for null. 
103c c9				ret 
103d			 
103d			 
103d			;Comparing Strings 
103d			 
103d			;IN    HL     Address of string1. 
103d			;      DE     Address of string2. 
103d			 
103d			; doc given but wrong??? 
103d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
103d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
103d			; tested 
103d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
103d			 
103d			strcmp_old: 
103d e5			    PUSH   HL 
103e d5			    PUSH   DE 
103f			 
103f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1040 be			    CP     (HL)            ; (want to minimize work). 
1041 38 01		    JR     C, Str1IsBigger 
1043 7e			    LD     A, (HL) 
1044			 
1044			Str1IsBigger: 
1044 4f			    LD     C, A             ; Put length in BC 
1045 06 00		    LD     B, 0 
1047 13			    INC    DE              ; Increment pointers to meat of string. 
1048 23			    INC    HL 
1049			 
1049			CmpLoop: 
1049 1a			    LD     A, (DE)          ; Compare bytes. 
104a ed a1		    CPI 
104c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
104e 13			    INC    DE              ; Update pointer. 
104f ea 49 10		    JP     PE, CmpLoop 
1052			 
1052 d1			    POP    DE 
1053 e1			    POP    HL 
1054 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1055 be			    CP     (HL) 
1056 c9			    RET 
1057			 
1057			NoMatch: 
1057 2b			    DEC    HL 
1058 be			    CP     (HL)            ; Compare again to affect carry. 
1059 d1			    POP    DE 
105a e1			    POP    HL 
105b c9			    RET 
105c			 
105c			;; test strmp 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str2 
105c			;call strcmp 
105c			;jr z, .z1 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "NZ1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.z1: 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "ZZ1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str1 
105c			;call strcmp 
105c			;jr z, .z2 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "NZ2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.z2: 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "ZZ2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str2 
105c			;call strcmp 
105c			;jr c, .c1 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "Nc1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.c1: 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "cc1" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			; 
105c			;ld de, .str1 
105c			;ld hl, .str1 
105c			;call strcmp 
105c			;jr c, .c2 
105c			;;this 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "Nc2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;.c2: 
105c			; 
105c			;	if DEBUG_FORTH_WORDS 
105c			;		DMARK "cc2" 
105c			;		CALLMONITOR 
105c			;	endif 
105c			;	NEXTW 
105c			;.str1:   db "string1",0 
105c			;.str2:   db "string2",0 
105c			 
105c			; only care about direct match or not 
105c			; hl and de strings 
105c			; zero set if the same 
105c			 
105c			strcmp: 
105c 1a				ld a, (de) 
105d be				cp (hl) 
105e 28 02			jr z, .ssame 
1060 b7				or a 
1061 c9				ret 
1062			 
1062			.ssame:  
1062 fe 00			cp 0 
1064 c8				ret z 
1065			 
1065 23				inc hl 
1066 13				inc de 
1067 18 f3			jr strcmp 
1069				 
1069				 
1069			 
1069			 
1069			 
1069			 
1069			; eof 
1069			 
1069			 
1069			 
1069			 
1069			 
1069			 
# End of file firmware_strings.asm
1069			include "firmware_memory.asm"   ; malloc and free  
1069			 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069			.mallocsize: db "Wants malloc >256",0 
1069			.mallocasize: db "MALLOC gives >256",0 
1069			.malloczero: db "MALLOC gives zero",0 
1069			 
1069			malloc_guard_zerolen: 
1069				push hl 
1069				push de 
1069				push af 
1069			 
1069				ld de, 0 
1069			        call cmp16 
1069				jr nz, .lowalloz 
1069			 
1069				push hl 
1069				push de 
1069					ld hl, display_fb0 
1069					ld (display_fb_active), hl 
1069				call clear_display 
1069				ld a, 0 
1069				ld de, .malloczero 
1069				call str_at_display 
1069				call update_display 
1069				call delay1s 
1069				call delay1s 
1069				ld a, 0 
1069				ld (os_view_disable), a 
1069			 
1069				pop de 
1069				pop hl 
1069			 
1069				 
1069			 
1069				CALLMONITOR 
1069			.lowalloz: 
1069			 
1069			 
1069				pop af 
1069				pop de 
1069				pop hl 
1069			ret 
1069			 
1069			malloc_guard_entry: 
1069				push hl 
1069				push de 
1069				push af 
1069			 
1069			 	or a      ;clear carry flag 
1069				push hl 
1069				ld de, 255 
1069				sbc hl, de 
1069				jr c, .lowalloc 
1069			 
1069				push de 
1069					ld hl, display_fb0 
1069					ld (display_fb_active), hl 
1069				call clear_display 
1069				ld a, 0 
1069				ld de, .mallocsize 
1069				call str_at_display 
1069				call update_display 
1069				call delay1s 
1069				call delay1s 
1069				ld a, 0 
1069				ld (os_view_disable), a 
1069			 
1069				pop de 
1069				pop hl 
1069			 
1069				 
1069			 
1069				CALLMONITOR 
1069				jr .lowdone 
1069			.lowalloc: 
1069			 
1069			 
1069				pop hl 
1069			.lowdone:	pop af 
1069				pop de 
1069				pop hl 
1069			ret 
1069			 
1069			malloc_guard_exit: 
1069				push hl 
1069				push de 
1069				push af 
1069			 
1069			 	or a      ;clear carry flag 
1069				push hl 
1069				ld de, 255 
1069				sbc hl, de 
1069				jr c, .lowallocx 
1069			 
1069				push de 
1069					ld hl, display_fb0 
1069					ld (display_fb_active), hl 
1069				call clear_display 
1069				ld a, 0 
1069				ld de, .mallocasize 
1069				call str_at_display 
1069				call update_display 
1069				call delay1s 
1069				call delay1s 
1069				ld a, 0 
1069				ld (os_view_disable), a 
1069				pop de 
1069				pop hl 
1069			 
1069				CALLMONITOR 
1069				jr .lowdonex 
1069			.lowallocx: 
1069			 
1069				pop hl 
1069			.lowdonex:	pop af 
1069				pop de 
1069				pop hl 
1069			ret 
1069			endif 
1069			 
1069			if MALLOC_2 
1069			; Z80 Malloc and Free Functions 
1069			 
1069			; Malloc Function: 
1069			; Input: 
1069			;   HL: Size of block to allocate 
1069			; Output: 
1069			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1069			 
1069			malloc: 
1069				 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069			call malloc_guard_entry 
1069			endif 
1069			 
1069			 
1069			 
1069			 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "mal" 
1069						CALLMONITOR 
1069					endif 
1069			    push af            ; Save AF register 
1069			    ld a, l            ; Load low byte of size into A 
1069			    or h               ; Check if size is zero 
1069			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1069			 
1069			    ; Allocate memory 
1069			    ld hl, (heap_start) ; Load start of heap into HL 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "ma1" 
1069						CALLMONITOR 
1069					endif 
1069			    call malloc_internal ; Call internal malloc function 
1069			    pop af             ; Restore AF register 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret                ; Return 
1069			 
1069			; Free Function: 
1069			; Input: 
1069			;   HL: Pointer to memory block to free 
1069			; Output: 
1069			;   None 
1069			 
1069			free: 
1069			    push af            ; Save AF register 
1069			    ld a, l            ; Load low byte of pointer into A 
1069			    or h               ; Check if pointer is NULL 
1069			    jp z, free_exit    ; If pointer is NULL, exit 
1069			 
1069			    ; Free memory 
1069			    ld hl, (heap_start) ; Load start of heap into HL 
1069			    call free_internal  ; Call internal free function 
1069			    pop af             ; Restore AF register 
1069			    ret                ; Return 
1069			 
1069			; Internal Malloc Function: 
1069			; Input: 
1069			;   HL: Size of block to allocate 
1069			; Output: 
1069			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1069			 
1069			malloc_internal: 
1069			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1069			    add hl, bc         ; Add management overhead to requested size 
1069			    ex de, hl          ; Save total size in DE, and keep it in HL 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "ma2" 
1069						CALLMONITOR 
1069					endif 
1069			 
1069			    ; Search for free memory block 
1069			    ld de, (heap_end)  ; Load end of heap into DE 
1069			    ld bc, 0           ; Initialize counter 
1069			 
1069					if DEBUG_FORTH_MALLOC 
1069						DMARK "ma2" 
1069						CALLMONITOR 
1069					endif 
1069			malloc_search_loop: 
1069			    ; Check if current block is free 
1069			    ld a, (hl)         ; Load current block's status (free or used) 
1069			    cp 0               ; Compare with zero (free) 
1069			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1069			 
1069			    ; Check if current block is large enough 
1069			    ld a, (hl+1)       ; Load high byte of block size 
1069			    cp l               ; Compare with low byte of requested size 
1069			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1069			 
1069			    ld a, (hl+2)       ; Load low byte of block size 
1069			    cp h               ; Compare with high byte of requested size 
1069			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1069			 
1069			    ; Mark block as used 
1069			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1069			 
1069			    ; Calculate remaining space in block 
1069			    ld bc, 0           ; Clear BC 
1069			    add hl, bc         ; Increment HL to point to start of data block 
1069			    add hl, de         ; HL = HL + DE (total size) 
1069			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1069			    add hl, bc         ; Add management overhead to start of data block 
1069			 
1069			    ; Save pointer to allocated block in HL 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069						DMARK "ma5" 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret 
1069			 
1069			malloc_skip_block_check: 
1069			    ; Move to the next block 
1069			    ld bc, 3           ; Size of management overhead 
1069			    add hl, bc         ; Move to the next block 
1069			    inc de             ; Increment counter 
1069			 
1069			    ; Check if we have reached the end of heap 
1069			    ld a, e            ; Load low byte of heap end address 
1069			    cp (hl)            ; Compare with low byte of current address 
1069			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1069			    ld a, d            ; Load high byte of heap end address 
1069			    cp 0               ; Check if it's zero (end of memory) 
1069			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1069			 
1069			    ; If we reached here, allocation failed 
1069			    xor a              ; Set result to NULL 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069						DMARK "ma6" 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret 
1069			malloc_exit: 
1069			if DEBUG_FORTH_MALLOC_HIGH 
1069						DMARK "ma7" 
1069			call malloc_guard_exit 
1069			call malloc_guard_zerolen 
1069			endif 
1069			    ret 
1069			 
1069			; Internal Free Function: 
1069			; Input: 
1069			;   HL: Pointer to memory block to free 
1069			; Output: 
1069			;   None 
1069			 
1069			free_internal: 
1069			    ld de, (heap_start) ; Load start of heap into DE 
1069			    ld bc, 0            ; Initialize counter 
1069			 
1069			free_search_loop: 
1069			    ; Check if current block contains the pointer 
1069			    ld a, l             ; Load low byte of pointer 
1069			    cp (hl+1)           ; Compare with high byte of current block's address 
1069			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1069			    ld a, h             ; Load high byte of pointer 
1069			    cp (hl+2)           ; Compare with low byte of current block's address 
1069			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1069			 
1069			    ; Mark block as free 
1069			    ld (hl), 0          ; Set status byte to indicate free block 
1069			    ret                 ; Return 
1069			 
1069			free_skip_block_check: 
1069			    ; Move to the next block 
1069			    ld bc, 3            ; Size of management overhead 
1069			    add hl, bc          ; Move to the next block 
1069			    inc de              ; Increment counter 
1069			 
1069			    ; Check if we have reached the end of heap 
1069			    ld a, e             ; Load low byte of heap end address 
1069			    cp (hl)             ; Compare with low byte of current address 
1069			    jr nz, free_search_loop  ; If not equal, continue searching 
1069			    ld a, d             ; Load high byte of heap end address 
1069			    cp 0                ; Check if it's zero (end of memory) 
1069			    jr nz, free_search_loop  ; If not zero, continue searching 
1069			 
1069			    ; If we reached here, pointer is not found in heap 
1069			    ret 
1069			 
1069			free_exit: 
1069			    ret                 ; Return 
1069			 
1069			; Define heap start and end addresses 
1069			;heap_start:    .dw 0xC000   ; Start of heap 
1069			;heap_end:      .dw 0xE000   ; End of heap 
1069			 
1069			endif 
1069			 
1069			 
1069			if MALLOC_1 
1069			 
1069			 
1069			 
1069			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1069			 
1069			;moved to firmware.asm 
1069			;heap_start        .equ  0x9000      ; Starting address of heap 
1069			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1069			 
1069			;      .org 0 
1069			;      jp    main 
1069			 
1069			 
1069			;      .org  0x100 
1069			;main: 
1069			;      ld    HL, 0x8100 
1069			;      ld    SP, HL 
1069			; 
1069			;      call  heap_init 
1069			; 
1069			;      ; Make some allocations 
1069			;      ld    HL, 12 
1069			;      call  malloc            ; Allocates 0x9004 
1069			; 
1069			;      ld    HL, 12 
1069			;      call  malloc            ; Allocates 0x9014 
1069			; 
1069			;      ld    HL, 12 
1069			;      call  malloc            ; Allocates 0x9024 
1069			; 
1069			;      ; Free some allocations 
1069			;      ld    HL, 0x9014 
1069			;      call  free 
1069			; 
1069			;      ld    HL, 0x9004 
1069			;      call  free 
1069			; 
1069			;      ld    HL, 0x9024 
1069			;      call  free 
1069			; 
1069			; 
1069			;      halt 
1069			 
1069			 
1069			;------------------------------------------------------------------------------ 
1069			;     heap_init                                                               : 
1069			;                                                                             : 
1069			; Description                                                                 : 
1069			;     Initialise the heap and make it ready for malloc and free operations.   : 
1069			;                                                                             : 
1069			;     The heap is maintained as a linked list, starting with an initial       : 
1069			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1069			;     the first free block in the heap. Each block then points to the next    : 
1069			;     free block within the heap, and the free list ends at the first block   : 
1069			;     with a null pointer to the next free block.                             : 
1069			;                                                                             : 
1069			; Parameters                                                                  : 
1069			;     Inputs are compile-time only. Two defines which specify the starting    : 
1069			;     address of the heap and its size are required, along with a memory      : 
1069			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1069			;     principally stores a pointer to the first free block in the heap.       : 
1069			;                                                                             : 
1069			; Returns                                                                     : 
1069			;     Nothing                                                                 : 
1069			;------------------------------------------------------------------------------ 
1069			heap_init: 
1069 e5			      push  HL 
106a			 
106a			      ; Initialise free list struct 
106a 21 e7 58		      ld    HL, heap_start 
106d 22 e2 58		      ld    (free_list), HL 
1070 21 00 00		      ld    HL, 0 
1073 22 e4 58		      ld    (free_list+2), HL 
1076			 
1076			      ; Insert first free block at bottom of heap, consumes entire heap 
1076 21 42 e3		      ld    HL, heap_start+heap_size-4 
1079 22 e7 58		      ld    (heap_start), HL        ; Next block (end of free list) 
107c 21 5b 8a		      ld    HL, heap_size-4 
107f 22 e9 58		      ld    (heap_start+2), HL      ; Block size 
1082			 
1082			      ; Insert end of free list block at top of heap - two null words will 
1082			      ; terminate the free list 
1082 21 00 00		      ld    HL, 0 
1085 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1088 22 42 e3		      ld    (heap_start+heap_size-4), HL 
108b			 
108b e1			      pop   HL 
108c			 
108c c9			      ret 
108d			 
108d			 
108d			;------------------------------------------------------------------------------ 
108d			;     malloc                                                                  : 
108d			;                                                                             : 
108d			; Description                                                                 : 
108d			;     Allocates the wanted space from the heap and returns the address of the : 
108d			;     first useable byte of the allocation.                                   : 
108d			;                                                                             : 
108d			;     Allocations can happen in one of two ways:                              : 
108d			;                                                                             : 
108d			;     1. A free block may be found which is the exact size wanted. In this    : 
108d			;        case the block is removed from the free list and retuedn to the      : 
108d			;        caller.                                                              : 
108d			;     2. A free block may be found which is larger than the size wanted. In   : 
108d			;        this case, the larger block is split into two. The first portion of  : 
108d			;        this block will become the requested space by the malloc call and    : 
108d			;        is returned to the caller. The second portion becomes a new free     : 
108d			;        block, and the free list is adjusted to maintain continuity via this : 
108d			;        newly created block.                                                 : 
108d			;                                                                             : 
108d			;     malloc does not set any initial value in the allocated space, the       : 
108d			;     caller is required to do this as required.                              : 
108d			;                                                                             : 
108d			;     This implementation of malloc uses the stack exclusively, and is        : 
108d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
108d			;     advisable to disable interrupts before calling malloc, and recommended  : 
108d			;     to avoid the use of malloc inside ISRs in general.                      : 
108d			;                                                                             : 
108d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
108d			;                                                                             : 
108d			; Parameters                                                                  : 
108d			;     HL  Number of bytes wanted                                              : 
108d			;                                                                             : 
108d			; Returns                                                                     : 
108d			;     HL  Address of the first useable byte of the allocation                 : 
108d			;                                                                             : 
108d			; Flags                                                                       : 
108d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
108d			;                                                                             : 
108d			; Stack frame                                                                 : 
108d			;       |             |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |     BC      |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |     DE      |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |     IX      |                                                       : 
108d			;       +-------------+                                                       : 
108d			;       |  prev_free  |                                                       : 
108d			;   +4  +-------------+                                                       : 
108d			;       |  this_free  |                                                       : 
108d			;   +2  +-------------+                                                       : 
108d			;       |  next_free  |                                                       : 
108d			;   +0  +-------------+                                                       : 
108d			;       |             |                                                       : 
108d			;                                                                             : 
108d			;------------------------------------------------------------------------------ 
108d			 
108d			 
108d			;malloc: 
108d			; 
108d			;	SAVESP ON 1 
108d			; 
108d			;	call malloc_code 
108d			; 
108d			;	CHECKSP ON 1 
108d			;	ret 
108d			 
108d			 
108d			malloc: 
108d c5			      push  BC 
108e d5			      push  DE 
108f dd e5		      push  IX 
1091			if DEBUG_FORTH_MALLOC_HIGH 
1091			call malloc_guard_entry 
1091			endif 
1091			 
1091					if DEBUG_FORTH_MALLOC 
1091						DMARK "mal" 
1091						CALLMONITOR 
1091					endif 
1091 7c			      ld    A, H                    ; Exit if no space requested 
1092 b5			      or    L 
1093 ca 52 11		      jp    Z, malloc_early_exit 
1096			 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			; 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			;inc hl 
1096			 
1096			 
1096			 
1096			 
1096					if DEBUG_FORTH_MALLOC 
1096						DMARK "maA" 
1096						CALLMONITOR 
1096					endif 
1096			      ; Set up stack frame 
1096 eb			      ex    DE, HL 
1097 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
109a 39			      add   HL, SP 
109b f9			      ld    SP, HL 
109c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10a0 dd 39		      add   IX, SP 
10a2			 
10a2			      ; Setup initial state 
10a2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10a5 19			      add   HL, DE 
10a6			 
10a6 44			      ld    B, H                    ; Move want to BC 
10a7 4d			      ld    C, L 
10a8			 
10a8 21 e2 58		      ld    HL, free_list           ; Store prev_free ptr to stack 
10ab dd 75 04		      ld    (IX+4), L 
10ae dd 74 05		      ld    (IX+5), H 
10b1			 
10b1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10b2 23			      inc   HL 
10b3 56			      ld    D, (HL) 
10b4 dd 73 02		      ld    (IX+2), E 
10b7 dd 72 03		      ld    (IX+3), D 
10ba eb			      ex    DE, HL                  ; this_free ptr into HL 
10bb			 
10bb					if DEBUG_FORTH_MALLOC 
10bb						DMARK "maB" 
10bb						CALLMONITOR 
10bb					endif 
10bb			      ; Loop through free block list to find some space 
10bb			malloc_find_space: 
10bb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10bc 23			      inc   HL 
10bd 56			      ld    D, (HL) 
10be			 
10be 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10bf b3			      or    E 
10c0 ca 4c 11		      jp    Z, malloc_no_space 
10c3			 
10c3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10c6 dd 72 01		      ld    (IX+1), D 
10c9			 
10c9			      ; Does this block have enough space to make the allocation? 
10c9 23			      inc   HL                      ; Load free block size into DE 
10ca 5e			      ld    E, (HL) 
10cb 23			      inc   HL 
10cc 56			      ld    D, (HL) 
10cd			 
10cd eb			      ex    DE, HL                  ; Check size of block against want 
10ce b7			      or    A                       ; Ensure carry flag clear 
10cf ed 42		      sbc   HL, BC 
10d1 e5			      push  HL                      ; Store the result for later (new block size) 
10d2			 
10d2 ca 21 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10d5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10d7			 
10d7			      ; this_free block is not big enough, setup ptrs to test next free block 
10d7 e1			      pop   HL                      ; Discard previous result 
10d8			 
10d8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10db dd 66 03		      ld    H, (IX+3) 
10de dd 75 04		      ld    (IX+4), L 
10e1 dd 74 05		      ld    (IX+5), H 
10e4			 
10e4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10e7 dd 66 01		      ld    H, (IX+1) 
10ea dd 75 02		      ld    (IX+2), L 
10ed dd 74 03		      ld    (IX+3), H 
10f0			 
10f0					if DEBUG_FORTH_MALLOC 
10f0						DMARK "MA>" 
10f0						CALLMONITOR 
10f0					endif 
10f0 18 c9		      jr    malloc_find_space 
10f2			 
10f2			      ; split a bigger block into two - requested size and remaining size 
10f2			malloc_alloc_split: 
10f2					if DEBUG_FORTH_MALLOC 
10f2						DMARK "MAs" 
10f2						CALLMONITOR 
10f2					endif 
10f2 eb			      ex    DE, HL                  ; Calculate address of new free block 
10f3 2b			      dec   HL 
10f4 2b			      dec   HL 
10f5 2b			      dec   HL 
10f6 09			      add   HL, BC 
10f7			 
10f7			      ; Create a new block and point it at next_free 
10f7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10fa dd 56 01		      ld    D, (IX+1) 
10fd			 
10fd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10fe 23			      inc   HL 
10ff 72			      ld    (HL), D 
1100			 
1100 d1			      pop   DE                      ; Store size of new block into new block 
1101 23			      inc   HL 
1102 73			      ld    (HL), E 
1103 23			      inc   HL 
1104 72			      ld    (HL), D 
1105			 
1105			      ; Update this_free ptr to point to new block 
1105 2b			      dec   HL 
1106 2b			      dec   HL 
1107 2b			      dec   HL 
1108			 
1108 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
110b dd 56 03		      ld    D, (IX+3) 
110e			 
110e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1111 dd 74 03		      ld    (IX+3), H 
1114			 
1114			      ; Modify this_free block to be allocation 
1114 eb			      ex    DE, HL 
1115 af			      xor   A                       ; Null the next block ptr of allocated block 
1116 77			      ld    (HL), A 
1117 23			      inc   HL 
1118 77			      ld    (HL), A 
1119			 
1119 23			      inc   HL                      ; Store want size into allocated block 
111a 71			      ld    (HL), C 
111b 23			      inc   HL 
111c 70			      ld    (HL), B 
111d 23			      inc   HL 
111e e5			      push  HL                      ; Address of allocation to return 
111f			 
111f 18 19		      jr    malloc_update_links 
1121			 
1121			malloc_alloc_fit: 
1121 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1122			 
1122					if DEBUG_FORTH_MALLOC 
1122						DMARK "MAf" 
1122						CALLMONITOR 
1122					endif 
1122			      ; Modify this_free block to be allocation 
1122 eb			      ex    DE, HL 
1123 2b			      dec   HL 
1124 2b			      dec   HL 
1125 2b			      dec   HL 
1126			 
1126 af			      xor   A                       ; Null the next block ptr of allocated block 
1127 77			      ld    (HL), A 
1128 23			      inc   HL 
1129 77			      ld    (HL), A 
112a			 
112a 23			      inc   HL                      ; Store address of allocation to return 
112b 23			      inc   HL 
112c 23			      inc   HL 
112d e5			      push  HL 
112e			 
112e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
112e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1131 dd 66 01		      ld    H, (IX+1) 
1134			 
1134 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1137 dd 74 03		      ld    (IX+3), H 
113a			 
113a			 
113a			malloc_update_links: 
113a			      ; Update prev_free ptr to point to this_free 
113a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
113d dd 66 05		      ld    H, (IX+5) 
1140			 
1140 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1143 dd 56 03		      ld    D, (IX+3) 
1146			 
1146 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1147 23			      inc   HL 
1148 72			      ld    (HL), D 
1149			 
1149					if DEBUG_FORTH_MALLOC 
1149						DMARK "Mul" 
1149						CALLMONITOR 
1149					endif 
1149			      ; Clear the Z flag to indicate successful allocation 
1149 7a			      ld    A, D 
114a b3			      or    E 
114b			 
114b d1			      pop   DE                      ; Address of allocation 
114c					if DEBUG_FORTH_MALLOC 
114c						DMARK "MAu" 
114c						CALLMONITOR 
114c					endif 
114c			 
114c			malloc_no_space: 
114c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
114f 39			      add   HL, SP 
1150 f9			      ld    SP, HL 
1151			 
1151 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1152					if DEBUG_FORTH_MALLOC 
1152						DMARK "MAN" 
1152						CALLMONITOR 
1152					endif 
1152			 
1152			malloc_early_exit: 
1152					if DEBUG_FORTH_MALLOC 
1152						DMARK "MAx" 
1152						CALLMONITOR 
1152					endif 
1152 dd e1		      pop   IX 
1154 d1			      pop   DE 
1155 c1			      pop   BC 
1156			 
1156			if DEBUG_FORTH_MALLOC_HIGH 
1156			call malloc_guard_exit 
1156			call malloc_guard_zerolen 
1156			endif 
1156 c9			      ret 
1157			 
1157			 
1157			;------------------------------------------------------------------------------ 
1157			;     free                                                                    : 
1157			;                                                                             : 
1157			; Description                                                                 : 
1157			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1157			;     returned by malloc, otherwise the behaviour is undefined.               : 
1157			;                                                                             : 
1157			;     Where possible, directly adjacent free blocks will be merged together   : 
1157			;     into larger blocks to help ensure that the heap does not become         : 
1157			;     excessively fragmented.                                                 : 
1157			;                                                                             : 
1157			;     free does not clear or set any other value into the freed space, and    : 
1157			;     therefore its contents may be visible through subsequent malloc's. The  : 
1157			;     caller should clear the freed space as required.                        : 
1157			;                                                                             : 
1157			;     This implementation of free uses the stack exclusively, and is          : 
1157			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1157			;     advisable to disable interrupts before calling free, and recommended    : 
1157			;     to avoid the use of free inside ISRs in general.                        : 
1157			;                                                                             : 
1157			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1157			;                                                                             : 
1157			; Parameters                                                                  : 
1157			;     HL  Pointer to address of first byte of allocation to be freed          : 
1157			;                                                                             : 
1157			; Returns                                                                     : 
1157			;     Nothing                                                                 : 
1157			;                                                                             : 
1157			; Stack frame                                                                 : 
1157			;       |             |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |     BC      |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |     DE      |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |     IX      |                                                       : 
1157			;       +-------------+                                                       : 
1157			;       |  prev_free  |                                                       : 
1157			;   +2  +-------------+                                                       : 
1157			;       |  next_free  |                                                       : 
1157			;   +0  +-------------+                                                       : 
1157			;       |             |                                                       : 
1157			;                                                                             : 
1157			;------------------------------------------------------------------------------ 
1157			free: 
1157 c5			      push  BC 
1158 d5			      push  DE 
1159 dd e5		      push  IX 
115b			 
115b 7c			      ld    A, H                    ; Exit if ptr is null 
115c b5			      or    L 
115d ca 21 12		      jp    Z, free_early_exit 
1160			 
1160			      ; Set up stack frame 
1160 eb			      ex    DE, HL 
1161 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1164 39			      add   HL, SP 
1165 f9			      ld    SP, HL 
1166 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
116a dd 39		      add   IX, SP 
116c			 
116c			      ; The address in HL points to the start of the useable allocated space, 
116c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
116c			      ; address of the block itself. 
116c eb			      ex    DE, HL 
116d 11 fc ff		      ld    DE, -4 
1170 19			      add   HL, DE 
1171			 
1171			      ; An allocated block must have a null next block pointer in it 
1171 7e			      ld    A, (HL) 
1172 23			      inc   HL 
1173 b6			      or    (HL) 
1174 c2 1c 12		      jp    NZ, free_done 
1177			 
1177 2b			      dec   HL 
1178			 
1178 44			      ld    B, H                    ; Copy HL to BC 
1179 4d			      ld    C, L 
117a			 
117a			      ; Loop through the free list to find the first block with an address 
117a			      ; higher than the block being freed 
117a 21 e2 58		      ld    HL, free_list 
117d			 
117d			free_find_higher_block: 
117d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
117e 23			      inc   HL 
117f 56			      ld    D, (HL) 
1180 2b			      dec   HL 
1181			 
1181 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1184 dd 72 01		      ld    (IX+1), D 
1187 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
118a dd 74 03		      ld    (IX+3), H 
118d			 
118d 78			      ld    A, B                    ; Check if DE is greater than BC 
118e ba			      cp    D                       ; Compare MSB first 
118f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1191 30 04		      jr    NC, free_find_higher_block_skip 
1193 79			      ld    A, C 
1194 bb			      cp    E                       ; Then compare LSB 
1195 38 08		      jr    C, free_found_higher_block 
1197			 
1197			free_find_higher_block_skip: 
1197 7a			      ld    A, D                    ; Reached the end of the free list? 
1198 b3			      or    E 
1199 ca 1c 12		      jp    Z, free_done 
119c			 
119c eb			      ex    DE, HL 
119d			 
119d 18 de		      jr    free_find_higher_block 
119f			 
119f			free_found_higher_block: 
119f			      ; Insert freed block between prev and next free blocks 
119f 71			      ld    (HL), C                 ; Point prev free block to freed block 
11a0 23			      inc   HL 
11a1 70			      ld    (HL), B 
11a2			 
11a2 60			      ld    H, B                    ; Point freed block at next free block 
11a3 69			      ld    L, C 
11a4 73			      ld    (HL), E 
11a5 23			      inc   HL 
11a6 72			      ld    (HL), D 
11a7			 
11a7			      ; Check if the freed block is adjacent to the next free block 
11a7 23			      inc   HL                      ; Load size of freed block into HL 
11a8 5e			      ld    E, (HL) 
11a9 23			      inc   HL 
11aa 56			      ld    D, (HL) 
11ab eb			      ex    DE, HL 
11ac			 
11ac 09			      add   HL, BC                  ; Add addr of freed block and its size 
11ad			 
11ad dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11b0 dd 56 01		      ld    D, (IX+1) 
11b3			 
11b3 b7			      or    A                       ; Clear the carry flag 
11b4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11b6 20 22		      jr    NZ, free_check_adjacent_to_prev 
11b8			 
11b8			      ; Freed block is adjacent to next, merge into one bigger block 
11b8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11b9 5e			      ld    E, (HL) 
11ba 23			      inc   HL 
11bb 56			      ld    D, (HL) 
11bc e5			      push  HL                      ; Save ptr to next block for later 
11bd			 
11bd 60			      ld    H, B                    ; Store ptr from next block into freed block 
11be 69			      ld    L, C 
11bf 73			      ld    (HL), E 
11c0 23			      inc   HL 
11c1 72			      ld    (HL), D 
11c2			 
11c2 e1			      pop   HL                      ; Restore ptr to next block 
11c3 23			      inc   HL                      ; Load size of next block into DE 
11c4 5e			      ld    E, (HL) 
11c5 23			      inc   HL 
11c6 56			      ld    D, (HL) 
11c7 d5			      push  DE                      ; Save next block size for later 
11c8			 
11c8 60			      ld    H, B                    ; Load size of freed block into HL 
11c9 69			      ld    L, C 
11ca 23			      inc   HL 
11cb 23			      inc   HL 
11cc 5e			      ld    E, (HL) 
11cd 23			      inc   HL 
11ce 56			      ld    D, (HL) 
11cf eb			      ex    DE, HL 
11d0			 
11d0 d1			      pop   DE                      ; Restore size of next block 
11d1 19			      add   HL, DE                  ; Add sizes of both blocks 
11d2 eb			      ex    DE, HL 
11d3			 
11d3 60			      ld    H, B                    ; Store new bigger size into freed block 
11d4 69			      ld    L, C 
11d5 23			      inc   HL 
11d6 23			      inc   HL 
11d7 73			      ld    (HL), E 
11d8 23			      inc   HL 
11d9 72			      ld    (HL), D 
11da			 
11da			free_check_adjacent_to_prev: 
11da			      ; Check if the freed block is adjacent to the prev free block 
11da dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11dd dd 66 03		      ld    H, (IX+3) 
11e0			 
11e0 23			      inc   HL                      ; Size of prev free block into DE 
11e1 23			      inc   HL 
11e2 5e			      ld    E, (HL) 
11e3 23			      inc   HL 
11e4 56			      ld    D, (HL) 
11e5 2b			      dec   HL 
11e6 2b			      dec   HL 
11e7 2b			      dec   HL 
11e8			 
11e8 19			      add   HL, DE                  ; Add prev block addr and size 
11e9			 
11e9 b7			      or    A                       ; Clear the carry flag 
11ea ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11ec 20 2e		      jr    NZ, free_done 
11ee			 
11ee			      ; Freed block is adjacent to prev, merge into one bigger block 
11ee 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11ef 69			      ld    L, C 
11f0 5e			      ld    E, (HL) 
11f1 23			      inc   HL 
11f2 56			      ld    D, (HL) 
11f3 e5			      push  HL                      ; Save freed block ptr for later 
11f4			 
11f4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11f7 dd 66 03		      ld    H, (IX+3) 
11fa 73			      ld    (HL), E 
11fb 23			      inc   HL 
11fc 72			      ld    (HL), D 
11fd			 
11fd e1			      pop   HL                      ; Restore freed block ptr 
11fe 23			      inc   HL                      ; Load size of freed block into DE 
11ff 5e			      ld    E, (HL) 
1200 23			      inc   HL 
1201 56			      ld    D, (HL) 
1202 d5			      push  DE                      ; Save freed block size for later 
1203			 
1203 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1206 dd 66 03		      ld    H, (IX+3) 
1209 23			      inc   HL 
120a 23			      inc   HL 
120b 5e			      ld    E, (HL) 
120c 23			      inc   HL 
120d 56			      ld    D, (HL) 
120e			 
120e e1			      pop   HL                      ; Add sizes of both blocks 
120f 19			      add   HL, DE 
1210 eb			      ex    DE, HL 
1211			 
1211 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1214 dd 66 03		      ld    H, (IX+3) 
1217 23			      inc   HL 
1218 23			      inc   HL 
1219 73			      ld    (HL), E 
121a 23			      inc   HL 
121b 72			      ld    (HL), D 
121c			 
121c			free_done: 
121c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
121f 39			      add   HL, SP 
1220 f9			      ld    SP, HL 
1221			 
1221			free_early_exit: 
1221 dd e1		      pop   IX 
1223 d1			      pop   DE 
1224 c1			      pop   BC 
1225			 
1225 c9			      ret 
1226			 
1226			; moved to firmware.asm 
1226			; 
1226			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1226			;                  .dw   0 
1226			 
1226			 
1226			endif 
1226			 
1226			 
1226			if MALLOC_3 
1226			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1226			;heap_start        .equ  0x9000      ; Starting address of heap 
1226			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1226			; 
1226			 ;     .org 0 
1226			  ;    jp    main 
1226			; 
1226			; 
1226			 ;     .org  0x100 
1226			;main: 
1226			 ;     ld    HL, 0x8100 
1226			  ;    ld    SP, HL 
1226			; 
1226			;      call  heap_init 
1226			 
1226			      ; Make some allocations 
1226			;      ld    HL, 12 
1226			;      call  malloc            ; Allocates 0x9004 
1226			; 
1226			 ;     ld    HL, 12 
1226			;      call  malloc            ; Allocates 0x9014 
1226			 
1226			;      ld    HL, 12 
1226			;      call  malloc            ; Allocates 0x9024 
1226			 
1226			      ; Free some allocations 
1226			;      ld    HL, 0x9014 
1226			;      call  free 
1226			 
1226			;      ld    HL, 0x9004 
1226			;      call  free 
1226			; 
1226			;      ld    HL, 0x9024 
1226			;      call  free 
1226			 
1226			 
1226			 ;     halt 
1226			 
1226			 
1226			;------------------------------------------------------------------------------ 
1226			;     heap_init                                                               : 
1226			;                                                                             : 
1226			; Description                                                                 : 
1226			;     Initialise the heap and make it ready for malloc and free operations.   : 
1226			;                                                                             : 
1226			;     The heap is maintained as a linked list, starting with an initial       : 
1226			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1226			;     the first free block in the heap. Each block then points to the next    : 
1226			;     free block within the heap, and the free list ends at the first block   : 
1226			;     with a null pointer to the next free block.                             : 
1226			;                                                                             : 
1226			; Parameters                                                                  : 
1226			;     Inputs are compile-time only. Two defines which specify the starting    : 
1226			;     address of the heap and its size are required, along with a memory      : 
1226			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1226			;     principally stores a pointer to the first free block in the heap.       : 
1226			;                                                                             : 
1226			; Returns                                                                     : 
1226			;     Nothing                                                                 : 
1226			;------------------------------------------------------------------------------ 
1226			heap_init: 
1226			      push  HL 
1226			 
1226			      ; Initialise free list struct 
1226			      ld    HL, heap_start 
1226			      ld    (free_list), HL 
1226			      ld    HL, 0 
1226			      ld    (free_list+2), HL 
1226			 
1226			      ; Insert first free block at bottom of heap, consumes entire heap 
1226			      ld    HL, heap_start+heap_size-4 
1226			      ld    (heap_start), HL        ; Next block (end of free list) 
1226			      ld    HL, heap_size-4 
1226			      ld    (heap_start+2), HL      ; Block size 
1226			 
1226			      ; Insert end of free list block at top of heap - two null words will 
1226			      ; terminate the free list 
1226			      ld    HL, 0 
1226			      ld    (heap_start+heap_size-2), HL 
1226			      ld    (heap_start+heap_size-4), HL 
1226			 
1226			      pop   HL 
1226			 
1226			      ret 
1226			 
1226			 
1226			;------------------------------------------------------------------------------ 
1226			;     malloc                                                                  : 
1226			;                                                                             : 
1226			; Description                                                                 : 
1226			;     Allocates the wanted space from the heap and returns the address of the : 
1226			;     first useable byte of the allocation.                                   : 
1226			;                                                                             : 
1226			;     Allocations can happen in one of two ways:                              : 
1226			;                                                                             : 
1226			;     1. A free block may be found which is the exact size wanted. In this    : 
1226			;        case the block is removed from the free list and retuedn to the      : 
1226			;        caller.                                                              : 
1226			;     2. A free block may be found which is larger than the size wanted. In   : 
1226			;        this case, the larger block is split into two. The first portion of  : 
1226			;        this block will become the requested space by the malloc call and    : 
1226			;        is returned to the caller. The second portion becomes a new free     : 
1226			;        block, and the free list is adjusted to maintain continuity via this : 
1226			;        newly created block.                                                 : 
1226			;                                                                             : 
1226			;     malloc does not set any initial value in the allocated space, the       : 
1226			;     caller is required to do this as required.                              : 
1226			;                                                                             : 
1226			;     This implementation of malloc uses the stack exclusively, and is        : 
1226			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1226			;     advisable to disable interrupts before calling malloc, and recommended  : 
1226			;     to avoid the use of malloc inside ISRs in general.                      : 
1226			;                                                                             : 
1226			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1226			;                                                                             : 
1226			; Parameters                                                                  : 
1226			;     HL  Number of bytes wanted                                              : 
1226			;                                                                             : 
1226			; Returns                                                                     : 
1226			;     HL  Address of the first useable byte of the allocation                 : 
1226			;                                                                             : 
1226			; Flags                                                                       : 
1226			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1226			;                                                                             : 
1226			; Stack frame                                                                 : 
1226			;       |             |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     BC      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     DE      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     IX      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |  prev_free  |                                                       : 
1226			;   +4  +-------------+                                                       : 
1226			;       |  this_free  |                                                       : 
1226			;   +2  +-------------+                                                       : 
1226			;       |  next_free  |                                                       : 
1226			;   +0  +-------------+                                                       : 
1226			;       |             |                                                       : 
1226			;                                                                             : 
1226			;------------------------------------------------------------------------------ 
1226			malloc: 
1226			      push  BC 
1226			      push  DE 
1226			      push  IX 
1226			 
1226			      ld    A, H                    ; Exit if no space requested 
1226			      or    L 
1226			      jp    Z, malloc_early_exit 
1226			 
1226			      ; Set up stack frame 
1226			      ex    DE, HL 
1226			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			      ld    IX, 0                   ; Use IX as a frame pointer 
1226			      add   IX, SP 
1226			 
1226			      ; Setup initial state 
1226			      ld    HL, 4                   ; want must also include space used by block struct 
1226			      add   HL, DE 
1226			 
1226			      ld    B, H                    ; Move want to BC 
1226			      ld    C, L 
1226			 
1226			      ld    HL, free_list           ; Store prev_free ptr to stack 
1226			      ld    (IX+4), L 
1226			      ld    (IX+5), H 
1226			 
1226			      ld    E, (HL)                 ; Store this_free ptr to stack 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      ld    (IX+2), E 
1226			      ld    (IX+3), D 
1226			      ex    DE, HL                  ; this_free ptr into HL 
1226			 
1226			      ; Loop through free block list to find some space 
1226			malloc_find_space: 
1226			      ld    E, (HL)                 ; Load next_free ptr into DE 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			 
1226			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1226			      or    E 
1226			      jp    Z, malloc_no_space 
1226			 
1226			      ld    (IX+0), E               ; Store next_free ptr to stack 
1226			      ld    (IX+1), D 
1226			 
1226			      ; Does this block have enough space to make the allocation? 
1226			      inc   HL                      ; Load free block size into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			 
1226			      ex    DE, HL                  ; Check size of block against want 
1226			      or    A                       ; Ensure carry flag clear 
1226			      sbc   HL, BC 
1226			      push  HL                      ; Store the result for later (new block size) 
1226			 
1226			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1226			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1226			 
1226			      ; this_free block is not big enough, setup ptrs to test next free block 
1226			      pop   HL                      ; Discard previous result 
1226			 
1226			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1226			      ld    H, (IX+3) 
1226			      ld    (IX+4), L 
1226			      ld    (IX+5), H 
1226			 
1226			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1226			      ld    H, (IX+1) 
1226			      ld    (IX+2), L 
1226			      ld    (IX+3), H 
1226			 
1226			      jr    malloc_find_space 
1226			 
1226			      ; split a bigger block into two - requested size and remaining size 
1226			malloc_alloc_split: 
1226			      ex    DE, HL                  ; Calculate address of new free block 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			      add   HL, BC 
1226			 
1226			      ; Create a new block and point it at next_free 
1226			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1226			      ld    D, (IX+1) 
1226			 
1226			      ld    (HL), E                 ; Store next_free ptr into new block 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      pop   DE                      ; Store size of new block into new block 
1226			      inc   HL 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      ; Update this_free ptr to point to new block 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			 
1226			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1226			      ld    D, (IX+3) 
1226			 
1226			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1226			      ld    (IX+3), H 
1226			 
1226			      ; Modify this_free block to be allocation 
1226			      ex    DE, HL 
1226			      xor   A                       ; Null the next block ptr of allocated block 
1226			      ld    (HL), A 
1226			      inc   HL 
1226			      ld    (HL), A 
1226			 
1226			      inc   HL                      ; Store want size into allocated block 
1226			      ld    (HL), C 
1226			      inc   HL 
1226			      ld    (HL), B 
1226			      inc   HL 
1226			      push  HL                      ; Address of allocation to return 
1226			 
1226			      jr    malloc_update_links 
1226			 
1226			malloc_alloc_fit: 
1226			      pop   HL                      ; Dont need new block size, want is exact fit 
1226			 
1226			      ; Modify this_free block to be allocation 
1226			      ex    DE, HL 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			 
1226			      xor   A                       ; Null the next block ptr of allocated block 
1226			      ld    (HL), A 
1226			      inc   HL 
1226			      ld    (HL), A 
1226			 
1226			      inc   HL                      ; Store address of allocation to return 
1226			      inc   HL 
1226			      inc   HL 
1226			      push  HL 
1226			 
1226			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1226			      ld    L, (IX+0)               ; next_free to HL 
1226			      ld    H, (IX+1) 
1226			 
1226			      ld    (IX+2), L               ; HL to this_free 
1226			      ld    (IX+3), H 
1226			 
1226			 
1226			malloc_update_links: 
1226			      ; Update prev_free ptr to point to this_free 
1226			      ld    L, (IX+4)               ; prev_free ptr to HL 
1226			      ld    H, (IX+5) 
1226			 
1226			      ld    E, (IX+2)               ; this_free ptr to DE 
1226			      ld    D, (IX+3) 
1226			 
1226			      ld    (HL), E                 ; this_free ptr into prev_free 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      ; Clear the Z flag to indicate successful allocation 
1226			      ld    A, D 
1226			      or    E 
1226			 
1226			      pop   DE                      ; Address of allocation 
1226			 
1226			malloc_no_space: 
1226			      ld    HL, 6                   ; Clean up stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			 
1226			      ex    DE, HL                  ; Alloc addr into HL for return 
1226			 
1226			malloc_early_exit: 
1226			      pop   IX 
1226			      pop   DE 
1226			      pop   BC 
1226			 
1226			      ret 
1226			 
1226			 
1226			;------------------------------------------------------------------------------ 
1226			;     free                                                                    : 
1226			;                                                                             : 
1226			; Description                                                                 : 
1226			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1226			;     returned by malloc, otherwise the behaviour is undefined.               : 
1226			;                                                                             : 
1226			;     Where possible, directly adjacent free blocks will be merged together   : 
1226			;     into larger blocks to help ensure that the heap does not become         : 
1226			;     excessively fragmented.                                                 : 
1226			;                                                                             : 
1226			;     free does not clear or set any other value into the freed space, and    : 
1226			;     therefore its contents may be visible through subsequent malloc's. The  : 
1226			;     caller should clear the freed space as required.                        : 
1226			;                                                                             : 
1226			;     This implementation of free uses the stack exclusively, and is          : 
1226			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1226			;     advisable to disable interrupts before calling free, and recommended    : 
1226			;     to avoid the use of free inside ISRs in general.                        : 
1226			;                                                                             : 
1226			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1226			;                                                                             : 
1226			; Parameters                                                                  : 
1226			;     HL  Pointer to address of first byte of allocation to be freed          : 
1226			;                                                                             : 
1226			; Returns                                                                     : 
1226			;     Nothing                                                                 : 
1226			;                                                                             : 
1226			; Stack frame                                                                 : 
1226			;       |             |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     BC      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     DE      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |     IX      |                                                       : 
1226			;       +-------------+                                                       : 
1226			;       |  prev_free  |                                                       : 
1226			;   +2  +-------------+                                                       : 
1226			;       |  next_free  |                                                       : 
1226			;   +0  +-------------+                                                       : 
1226			;       |             |                                                       : 
1226			;                                                                             : 
1226			;------------------------------------------------------------------------------ 
1226			free: 
1226			      push  BC 
1226			      push  DE 
1226			      push  IX 
1226			 
1226			      ld    A, H                    ; Exit if ptr is null 
1226			      or    L 
1226			      jp    Z, free_early_exit 
1226			 
1226			      ; Set up stack frame 
1226			      ex    DE, HL 
1226			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			      ld    IX, 0                   ; Use IX as a frame pointer 
1226			      add   IX, SP 
1226			 
1226			      ; The address in HL points to the start of the useable allocated space, 
1226			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1226			      ; address of the block itself. 
1226			      ex    DE, HL 
1226			      ld    DE, -4 
1226			      add   HL, DE 
1226			 
1226			      ; An allocated block must have a null next block pointer in it 
1226			      ld    A, (HL) 
1226			      inc   HL 
1226			      or    (HL) 
1226			      jp    NZ, free_done 
1226			 
1226			      dec   HL 
1226			 
1226			      ld    B, H                    ; Copy HL to BC 
1226			      ld    C, L 
1226			 
1226			      ; Loop through the free list to find the first block with an address 
1226			      ; higher than the block being freed 
1226			      ld    HL, free_list 
1226			 
1226			free_find_higher_block: 
1226			      ld    E, (HL)                 ; Load next ptr from free block 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      dec   HL 
1226			 
1226			      ld    (IX+0), E               ; Save ptr to next free block 
1226			      ld    (IX+1), D 
1226			      ld    (IX+2), L               ; Save ptr to prev free block 
1226			      ld    (IX+3), H 
1226			 
1226			      ld    A, B                    ; Check if DE is greater than BC 
1226			      cp    D                       ; Compare MSB first 
1226			      jr    Z, $+4                  ; MSB the same, compare LSB 
1226			      jr    NC, free_find_higher_block_skip 
1226			      ld    A, C 
1226			      cp    E                       ; Then compare LSB 
1226			      jr    C, free_found_higher_block 
1226			 
1226			free_find_higher_block_skip: 
1226			      ld    A, D                    ; Reached the end of the free list? 
1226			      or    E 
1226			      jp    Z, free_done 
1226			 
1226			      ex    DE, HL 
1226			 
1226			      jr    free_find_higher_block 
1226			 
1226			free_found_higher_block: 
1226			      ; Insert freed block between prev and next free blocks 
1226			      ld    (HL), C                 ; Point prev free block to freed block 
1226			      inc   HL 
1226			      ld    (HL), B 
1226			 
1226			      ld    H, B                    ; Point freed block at next free block 
1226			      ld    L, C 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      ; Check if the freed block is adjacent to the next free block 
1226			      inc   HL                      ; Load size of freed block into HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      ex    DE, HL 
1226			 
1226			      add   HL, BC                  ; Add addr of freed block and its size 
1226			 
1226			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1226			      ld    D, (IX+1) 
1226			 
1226			      or    A                       ; Clear the carry flag 
1226			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1226			      jr    NZ, free_check_adjacent_to_prev 
1226			 
1226			      ; Freed block is adjacent to next, merge into one bigger block 
1226			      ex    DE, HL                  ; Load next ptr from next block into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  HL                      ; Save ptr to next block for later 
1226			 
1226			      ld    H, B                    ; Store ptr from next block into freed block 
1226			      ld    L, C 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      pop   HL                      ; Restore ptr to next block 
1226			      inc   HL                      ; Load size of next block into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  DE                      ; Save next block size for later 
1226			 
1226			      ld    H, B                    ; Load size of freed block into HL 
1226			      ld    L, C 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      ex    DE, HL 
1226			 
1226			      pop   DE                      ; Restore size of next block 
1226			      add   HL, DE                  ; Add sizes of both blocks 
1226			      ex    DE, HL 
1226			 
1226			      ld    H, B                    ; Store new bigger size into freed block 
1226			      ld    L, C 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			free_check_adjacent_to_prev: 
1226			      ; Check if the freed block is adjacent to the prev free block 
1226			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1226			      ld    H, (IX+3) 
1226			 
1226			      inc   HL                      ; Size of prev free block into DE 
1226			      inc   HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      dec   HL 
1226			      dec   HL 
1226			      dec   HL 
1226			 
1226			      add   HL, DE                  ; Add prev block addr and size 
1226			 
1226			      or    A                       ; Clear the carry flag 
1226			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1226			      jr    NZ, free_done 
1226			 
1226			      ; Freed block is adjacent to prev, merge into one bigger block 
1226			      ld    H, B                    ; Load next ptr from freed block into DE 
1226			      ld    L, C 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  HL                      ; Save freed block ptr for later 
1226			 
1226			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1226			      ld    H, (IX+3) 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			      pop   HL                      ; Restore freed block ptr 
1226			      inc   HL                      ; Load size of freed block into DE 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			      push  DE                      ; Save freed block size for later 
1226			 
1226			      ld    L, (IX+2)               ; Load size of prev block into DE 
1226			      ld    H, (IX+3) 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    E, (HL) 
1226			      inc   HL 
1226			      ld    D, (HL) 
1226			 
1226			      pop   HL                      ; Add sizes of both blocks 
1226			      add   HL, DE 
1226			      ex    DE, HL 
1226			 
1226			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1226			      ld    H, (IX+3) 
1226			      inc   HL 
1226			      inc   HL 
1226			      ld    (HL), E 
1226			      inc   HL 
1226			      ld    (HL), D 
1226			 
1226			free_done: 
1226			      ld    HL, 4                   ; Clean up stack frame 
1226			      add   HL, SP 
1226			      ld    SP, HL 
1226			 
1226			free_early_exit: 
1226			      pop   IX 
1226			      pop   DE 
1226			      pop   BC 
1226			 
1226			      ret 
1226			 
1226			 
1226			;      .org 0x8000 
1226			; 
1226			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1226			 ;                 .dw   0 
1226			 
1226			endif 
1226			 
1226			 
1226			if MALLOC_4 
1226			 
1226			; My memory allocation code. Very very simple.... 
1226			; allocate space under 250 chars 
1226			 
1226			heap_init: 
1226				; init start of heap as zero 
1226				;  
1226			 
1226				ld hl, heap_start 
1226				ld a, 0 
1226				ld (hl), a      ; empty block 
1226				inc hl 
1226				ld a, 0 
1226				ld (hl), a      ; length of block 
1226				; write end of list 
1226				inc hl 
1226				ld a,(hl) 
1226				inc hl 
1226				ld a,(hl) 
1226				 
1226			 
1226				; init some malloc vars 
1226			 
1226				ld hl, 0 
1226				ld (free_list), hl       ; store last malloc location 
1226			 
1226				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1226				ld a, 0 
1226				ld (hl), a 
1226			 
1226			 
1226				ld hl, heap_start 
1226				;  
1226				  
1226				ret 
1226			 
1226			 
1226			;    free block marker 
1226			;    requested size  
1226			;    pointer to next block 
1226			;    .... 
1226			;    next block marker 
1226			 
1226			 
1226			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1226			; 
1226			 
1226			 
1226			malloc:  
1226				push de 
1226				push bc 
1226				push af 
1226			 
1226				; hl space required 
1226				 
1226				ld c, l    ; hold space   (TODO only a max of 255) 
1226			 
1226			;	inc c     ; TODO BUG need to fix memory leak on push str 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			;	inc c 
1226			 
1226			 
1226			 
1226				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1226			 
1226				ld a, (free_list+3) 
1226				cp 0 
1226				jr z, .contheap 
1226			 
1226				ld hl, (free_list)     ; get last alloc 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mrs" 
1226						CALLMONITOR 
1226					endif 
1226				jr .startalloc 
1226			 
1226			.contheap: 
1226				ld hl, heap_start 
1226			 
1226			.startalloc: 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mym" 
1226						CALLMONITOR 
1226					endif 
1226			.findblock: 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mmf" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226				ld a,(hl)  
1226				; if byte is zero then clear to use 
1226			 
1226				cp 0 
1226				jr z, .foundemptyblock 
1226			 
1226				; if byte is not clear 
1226				;     then byte is offset to next block 
1226			 
1226				inc hl 
1226				ld a, (hl) ; get size 
1226			.nextblock:	inc hl 
1226					ld e, (hl) 
1226					inc hl 
1226					ld d, (hl) 
1226					ex de, hl 
1226			;	inc hl  ; move past the store space 
1226			;	inc hl  ; move past zero index  
1226			 
1226				; TODO detect no more space 
1226			 
1226				push hl 
1226				ld de, heap_end 
1226				call cmp16 
1226				pop hl 
1226				jr nc, .nospace 
1226			 
1226				jr .findblock 
1226			 
1226			.nospace: ld hl, 0 
1226				jp .exit 
1226			 
1226			 
1226			.foundemptyblock:	 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mme" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			; TODO has block enough space if reusing??? 
1226			 
1226				;  
1226			 
1226			; see if this block has been previously used 
1226				inc hl 
1226				ld a, (hl) 
1226				dec hl 
1226				cp 0 
1226				jr z, .newblock 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "meR" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			; no reusing previously allocated block 
1226			 
1226			; is it smaller than previously used? 
1226				 
1226				inc hl    ; move to size 
1226				ld a, c 
1226				sub (hl)        ; we want c < (hl) 
1226				dec hl    ; move back to marker 
1226			        jr z, .findblock 
1226			 
1226				; update with the new size which should be lower 
1226			 
1226			        ;inc  hl   ; negate next move. move back to size  
1226			 
1226			.newblock: 
1226				; need to be at marker here 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "meN" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			 
1226				ld a, c 
1226			 
1226				ld (free_list+3), a	 ; flag resume from last malloc  
1226				ld (free_list), hl    ; save out last location 
1226			 
1226			 
1226				;inc a     ; space for length byte 
1226				ld (hl), a     ; save block in use marker 
1226			 
1226				inc hl   ; move to space marker 
1226				ld (hl), a    ; save new space 
1226			 
1226				inc hl   ; move to start of allocated area 
1226				 
1226			;	push hl     ; save where we are - 1  
1226			 
1226			;	inc hl  ; move past zero index  
1226				; skip space to set down new marker 
1226			 
1226				; provide some extra space for now 
1226			 
1226				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1226				inc a 
1226				inc a 
1226			 
1226				push hl   ; save where we are in the node block 
1226			 
1226				call addatohl 
1226			 
1226				; write linked list point 
1226			 
1226				pop de     ; get our node position 
1226				ex de, hl 
1226			 
1226				ld (hl), e 
1226				inc hl 
1226				ld (hl), d 
1226			 
1226				inc hl 
1226			 
1226				; now at start of allocated data so save pointer 
1226			 
1226				push hl 
1226			 
1226				; jump to position of next node and setup empty header in DE 
1226			 
1226				ex de, hl 
1226			 
1226			;	inc hl ; move past end of block 
1226			 
1226				ld a, 0 
1226				ld (hl), a   ; empty marker 
1226				inc hl 
1226				ld (hl), a   ; size 
1226				inc hl  
1226				ld (hl), a   ; ptr 
1226				inc hl 
1226				ld (hl), a   ; ptr 
1226			 
1226			 
1226				pop hl 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "mmr" 
1226						CALLMONITOR 
1226					endif 
1226			 
1226			.exit: 
1226				pop af 
1226				pop bc 
1226				pop de  
1226				ret 
1226			 
1226			 
1226			 
1226			 
1226			free:  
1226				push hl 
1226				push af 
1226				; get address in hl 
1226			 
1226					if DEBUG_FORTH_MALLOC_INT 
1226						DMARK "fre" 
1226						CALLMONITOR 
1226					endif 
1226				; data is at hl - move to block count 
1226				dec hl 
1226				dec hl    ; get past pointer 
1226				dec hl 
1226			 
1226				ld a, (hl)    ; need this for a validation check 
1226			 
1226				dec hl    ; move to block marker 
1226			 
1226				; now check that the block count and block marker are the same  
1226			        ; this checks that we are on a malloc node and not random memory 
1226			        ; OK a faint chance this could be a problem but rare - famous last words! 
1226			 
1226				ld c, a 
1226				ld a, (hl)    
1226			 
1226				cp c 
1226				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1226			 
1226				; yes good chance we are on a malloc node 
1226			 
1226				ld a, 0      
1226				ld (hl), a   ; mark as free 
1226			 
1226				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1226			 
1226			.freeignore:  
1226			 
1226				pop af 
1226				pop hl 
1226			 
1226				ret 
1226			 
1226			 
1226			 
1226			endif 
1226			 
1226			; eof 
# End of file firmware_memory.asm
1226			  
1226			; device C  
1226			if SOUND_ENABLE  
1226				include "firmware_sound.asm"  
1226			endif  
1226			  
1226			include "firmware_diags.asm"  
1226			; Hardware diags menu 
1226			 
1226			 
1226			config: 
1226			 
1226 3e 00			ld a, 0 
1228 21 56 12			ld hl, .configmn 
122b cd ca 09			call menu 
122e			 
122e fe 00			cp 0 
1230 c8				ret z 
1231			 
1231 fe 01			cp 1 
1233 cc fa 12			call z, .savetostore 
1236			 
1236 fe 02			cp 2 
1238 cc f8 12			call z, .selautoload 
123b fe 03			cp 3 
123d cc f7 12			call z, .disautoload 
1240 fe 04			cp 4 
1242 cc f9 12			call z, .selbank 
1245 fe 05			cp 5 
1247 cc fb 12			call z, .debug_tog 
124a fe 06			cp 6 
124c cc 43 14			call z, .bpsgo 
124f fe 07			cp 7 
1251 cc 21 13			call z, hardware_diags 
1254			 
1254 18 d0			jr config 
1256			 
1256			.configmn: 
1256 66 12			dw .c3 
1258 7d 12			dw .c2 
125a 92 12			dw .c2a 
125c a8 12			dw .c2b 
125e			;	dw .c4 
125e c5 12			dw .m4 
1260 e0 12			dw .m4b 
1262 e8 12			dw .c1 
1264 00 00			dw 0 
1266				 
1266			 
1266 .. 00		.c3: db "Add Dictionary To File",0 
127d .. 00		.c2: db "Select Autoload File",0 
1292 .. 00		.c2a: db "Disable Autoload File", 0 
12a8 .. 00		.c2b: db "Select Storage Bank",0 
12bc .. 00		.c4: db "Settings",0 
12c5 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12e0 .. 00		.m4b:   db "Monitor",0 
12e8 .. 00		.c1: db "Hardware Diags",0 
12f7			 
12f7			 
12f7			.disautoload: 
12f7				if STORAGE_SE 
12f7				ld a, $fe      ; bit 0 clear 
12f7				ld (spi_device), a 
12f7			 
12f7				call storage_get_block_0 
12f7			 
12f7				ld a, 0 
12f7				ld (store_page+STORE_0_AUTOFILE), a 
12f7			 
12f7					ld hl, 0 
12f7					ld de, store_page 
12f7				call storage_write_block	 ; save update 
12f7				endif 
12f7			 
12f7			 
12f7 c9				ret 
12f8			 
12f8			 
12f8			 
12f8			; Select auto start 
12f8			 
12f8			.selautoload: 
12f8			 
12f8				 
12f8				if STORAGE_SE 
12f8			 
12f8					call config_dir 
12f8				        ld hl, scratch 
12f8					ld a, 0 
12f8					call menu 
12f8			 
12f8					cp 0 
12f8					ret z 
12f8			 
12f8					dec a 
12f8			 
12f8			 
12f8					; locate menu option 
12f8			 
12f8					ld hl, scratch 
12f8					call table_lookup 
12f8			 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "ALl" 
12f8						CALLMONITOR 
12f8					endif 
12f8					; with the pointer to the menu it, the byte following the zero term is the file id 
12f8			 
12f8					ld a, 0 
12f8					ld bc, 50   ; max of bytes to look at 
12f8					cpir  
12f8			 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "ALb" 
12f8						CALLMONITOR 
12f8					endif 
12f8					;inc hl 
12f8			 
12f8					ld a, (hl)   ; file id 
12f8					 
12f8				        ; save bank and file ids 
12f8			 
12f8					push af 
12f8			 
12f8			; TODO need to save to block 0 on bank 1	 
12f8			 
12f8					call storage_get_block_0 
12f8			 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "AL0" 
12f8						CALLMONITOR 
12f8					endif 
12f8					pop af 
12f8			 
12f8					ld (store_page+STORE_0_FILERUN),a 
12f8					 
12f8					; save bank id 
12f8			 
12f8					ld a,(spi_device) 
12f8					ld (store_page+STORE_0_BANKRUN),a 
12f8			 
12f8					; enable auto run of store file 
12f8			 
12f8					ld a, 1 
12f8					ld (store_page+STORE_0_AUTOFILE),a 
12f8			 
12f8					; save buffer 
12f8			 
12f8					ld hl, 0 
12f8					ld de, store_page 
12f8					if DEBUG_FORTH_WORDS 
12f8						DMARK "ALw" 
12f8						CALLMONITOR 
12f8					endif 
12f8				call storage_write_block	 ; save update 
12f8			  
12f8			 
12f8			 
12f8			 
12f8					ld hl, scratch 
12f8					call config_fdir 
12f8			 
12f8			 
12f8				endif 
12f8 c9				ret 
12f9			 
12f9			 
12f9			 
12f9			; Select storage bank 
12f9			 
12f9			.selbank: 
12f9			 
12f9				if STORAGE_SE 
12f9				endif 
12f9				 
12f9 c9				ret 
12fa			 
12fa			if STORAGE_SE 
12fa			 
12fa			.config_ldir:   
12fa				; Load storage bank labels into menu array 
12fa			 
12fa				 
12fa			 
12fa			 
12fa				ret 
12fa			 
12fa			 
12fa			endif 
12fa			 
12fa			 
12fa			; Save user words to storage 
12fa			 
12fa			.savetostore: 
12fa			 
12fa				if STORAGE_SE 
12fa			 
12fa					call config_dir 
12fa				        ld hl, scratch 
12fa					ld a, 0 
12fa					call menu 
12fa					 
12fa					ld hl, scratch 
12fa					call config_fdir 
12fa			 
12fa			 
12fa				endif 
12fa			 
12fa c9				ret 
12fb			 
12fb			 
12fb			 
12fb			if STORAGE_SE 
12fb			 
12fb			config_fdir: 
12fb				; using the scratch dir go through and release the memory allocated for each string 
12fb				 
12fb				ld hl, scratch 
12fb			.cfdir:	ld e,(hl) 
12fb				inc hl 
12fb				ld d,(hl) 
12fb				inc hl 
12fb			 
12fb				ex de, hl 
12fb				call ishlzero 
12fb				ret z     ; return on null pointer 
12fb				call free 
12fb				ex de, hl 
12fb				jr .cfdir 
12fb			 
12fb			 
12fb				ret 
12fb			 
12fb			 
12fb			config_dir: 
12fb			 
12fb				; for the config menus that need to build a directory of storage call this routine 
12fb				; it will construct a menu in scratch to pass to menu 
12fb			 
12fb				; open storage device 
12fb			 
12fb				; execute DIR to build a list of files and their ids into scratch in menu format 
12fb				; once the menu has finished then will need to call config_fdir to release the strings 
12fb				 
12fb				; c = number items 
12fb			 
12fb				 
12fb				call storage_get_block_0 
12fb			 
12fb				ld hl, store_page     ; get current id count 
12fb				ld b, (hl) 
12fb				ld c, 0    ; count of files   
12fb			 
12fb			 
12fb				ld hl, scratch 
12fb				ld (store_tmp2), hl    ; location to poke strings 
12fb			 
12fb				; check for empty drive 
12fb			 
12fb				ld a, 0 
12fb				cp b 
12fb				jp z, .dirdone 
12fb			 
12fb				 
12fb					if DEBUG_FORTH_WORDS 
12fb						DMARK "Cdc" 
12fb						CALLMONITOR 
12fb					endif 
12fb			 
12fb			 
12fb			.diritem:	 
12fb				push bc 
12fb				; for each of the current ids do a search for them and if found push to stack 
12fb			 
12fb					ld hl, STORE_BLOCK_PHY 
12fb					ld d, 0		 ; look for extent 0 of block id as this contains file name 
12fb					ld e,b 
12fb			 
12fb					call storage_findnextid 
12fb			 
12fb			 
12fb					; if found hl will be non zero 
12fb			 
12fb					call ishlzero 
12fb					jr z, .dirnotfound 
12fb			 
12fb					; increase count 
12fb			 
12fb					pop bc	 
12fb					inc c 
12fb					push bc 
12fb					 
12fb			 
12fb					; get file header and push the file name 
12fb			 
12fb					ld de, store_page 
12fb					call storage_read_block 
12fb			 
12fb					; push file id to stack 
12fb				 
12fb					ld a, (store_page) 
12fb					ld h, 0 
12fb					ld l, a 
12fb			 
12fb					;call forth_push_numhl 
12fb					; TODO store id 
12fb			 
12fb					push hl 
12fb			 
12fb					; push extent count to stack  
12fb				 
12fb					ld hl, store_page+3 
12fb			 
12fb					; get file name length 
12fb			 
12fb					call strlenz   
12fb			 
12fb					inc hl   ; cover zero term 
12fb					inc hl  ; stick the id at the end of the area 
12fb			 
12fb					push hl 
12fb					pop bc    ; move length to bc 
12fb			 
12fb					call malloc 
12fb			 
12fb					; TODO save malloc area to scratch 
12fb			 
12fb					ex de, hl 
12fb					ld hl, (store_tmp2) 
12fb					ld (hl), e 
12fb					inc hl 
12fb					ld (hl), d 
12fb					inc hl 
12fb					ld (store_tmp2), hl 
12fb			 
12fb					 
12fb			 
12fb					;pop hl   ; get source 
12fb			;		ex de, hl    ; swap aronund	 
12fb			 
12fb					ld hl, store_page+3 
12fb					if DEBUG_FORTH_WORDS 
12fb						DMARK "CFd" 
12fb						CALLMONITOR 
12fb					endif 
12fb					ldir 
12fb			 
12fb					; de is past string, move back one and store id 
12fb					 
12fb					dec de 
12fb			 
12fb					; store file id 
12fb			 
12fb					pop hl 
12fb					ex de,hl 
12fb					ld (hl), e 
12fb			 
12fb					if DEBUG_FORTH_WORDS 
12fb						DMARK "Cdi" 
12fb						CALLMONITOR 
12fb					endif 
12fb					 
12fb			.dirnotfound: 
12fb					pop bc     
12fb					djnz .diritem 
12fb				 
12fb			.dirdone:	 
12fb			 
12fb					ld a, 0 
12fb					ld hl, (store_tmp2) 
12fb					ld (hl), a 
12fb					inc hl 
12fb					ld (hl), a 
12fb					inc hl 
12fb					; push a count of the dir items found 
12fb			 
12fb			;		ld h, 0 
12fb			;		ld l, c 
12fb			 
12fb				ret 
12fb			 
12fb			endif 
12fb			 
12fb			 
12fb			; Settings 
12fb			; Run  
12fb			 
12fb			 
12fb			 
12fb			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12fb			;;hd_menu2:   db "        2: Editor",0   
12fb			;hd_menu2:   db "        2: Editor       6: Menu",0   
12fb			;hd_menu3:   db "        3: Storage",0 
12fb			;hd_menu4:   db "0=quit  4: Debug",0 
12fb			;hd_don:     db "ON",0 
12fb			;hd_doff:     db "OFF",0 
12fb			; 
12fb			; 
12fb			; 
12fb			;hardware_diags_old:       
12fb			; 
12fb			;.diagmenu: 
12fb			;	call clear_display 
12fb			;	ld a, display_row_1 
12fb			;	ld de, hd_menu1 
12fb			;	call str_at_display 
12fb			; 
12fb			;	ld a, display_row_2 
12fb			;	ld de, hd_menu2 
12fb			;	call str_at_display 
12fb			; 
12fb			;	ld a, display_row_3 
12fb			;	ld de, hd_menu3 
12fb			;	call str_at_display 
12fb			; 
12fb			;	ld a,  display_row_4 
12fb			;	ld de, hd_menu4 
12fb			;	call str_at_display 
12fb			; 
12fb			;	; display debug state 
12fb			; 
12fb			;	ld de, hd_don 
12fb			;	ld a, (os_view_disable) 
12fb			;	cp 0 
12fb			;	jr z, .distog 
12fb			;	ld de, hd_doff 
12fb			;.distog: ld a, display_row_4+17 
12fb			;	call str_at_display 
12fb			; 
12fb			;	call update_display 
12fb			; 
12fb			;	call cin_wait 
12fb			; 
12fb			; 
12fb			; 
12fb			;	cp '4' 
12fb			;	jr nz, .diagn1 
12fb			; 
12fb			;	; debug toggle 
12fb			; 
12fb			;	ld a, (os_view_disable) 
12fb			;	ld b, '*' 
12fb			;	cp 0 
12fb			;	jr z, .debtog 
12fb			;	ld b, 0 
12fb			;.debtog:	 
12fb			;	ld a,b 
12fb			;	ld (os_view_disable),a 
12fb			; 
12fb			;.diagn1: cp '0' 
12fb			;	 ret z 
12fb			; 
12fb			;;	cp '1' 
12fb			;;       jp z, matrix	 
12fb			;;   TODO keyboard matrix test 
12fb			; 
12fb			;	cp '2' 
12fb			;	jp z, .diagedit 
12fb			; 
12fb			;;	cp '6' 
12fb			;;	jp z, .menutest 
12fb			;;if ENABLE_BASIC 
12fb			;;	cp '6' 
12fb			;;	jp z, basic 
12fb			;;endif 
12fb			 ; 
12fb			;	jp .diagmenu 
12fb			; 
12fb			; 
12fb			;	ret 
12fb			 
12fb			 
12fb			.debug_tog: 
12fb 21 42 13			ld hl, .menudebug 
12fe				 
12fe 3a 51 e3			ld a, (os_view_disable) 
1301 fe 2a			cp '*' 
1303 20 04			jr nz,.tdon  
1305 3e 01			ld a, 1 
1307 18 02			jr .tog1 
1309 3e 00		.tdon: ld a, 0 
130b			 
130b			.tog1: 
130b cd ca 09			call menu 
130e fe 00			cp 0 
1310 c8				ret z 
1311 fe 01			cp 1    ; disable debug 
1313 28 04			jr z, .dtog0 
1315 3e 2a			ld a, '*' 
1317 18 02			jr .dtogset 
1319 3e 00		.dtog0: ld a, 0 
131b 32 51 e3		.dtogset:  ld (os_view_disable), a 
131e c3 fb 12			jp .debug_tog 
1321			 
1321			 
1321			hardware_diags:       
1321			 
1321			.diagm: 
1321 21 34 13			ld hl, .menuitems 
1324 3e 00			ld a, 0 
1326 cd ca 09			call menu 
1329			 
1329 fe 00		         cp 0 
132b c8				 ret z 
132c			 
132c fe 02			cp 2 
132e ca 8d 13			jp z, .diagedit 
1331			 
1331			;	cp '6' 
1331			;	jp z, .menutest 
1331			;if ENABLE_BASIC 
1331			;	cp '6' 
1331			;	jp z, basic 
1331			;endif 
1331			  
1331 c3 21 13			jp .diagm 
1334			 
1334				 
1334 48 13		.menuitems:   	dw .m1 
1336 53 13				dw .m2 
1338 5a 13				dw .m3 
133a 62 13				dw .m5 
133c 68 13				dw .m5a 
133e 71 13				dw .m5b 
1340 00 00				dw 0 
1342			 
1342			.menudebug: 
1342 7a 13				dw .m6 
1344 83 13				dw .m7 
1346 00 00				dw 0 
1348			 
1348 .. 00		.m1:   db "Key Matrix",0 
1353 .. 00		.m2:   db "Editor",0 
135a .. 00		.m3:   db "Storage",0 
1362 .. 00		.m5:   db "Sound",0 
1368 .. 00		.m5a:  db "RAM Test",0 
1371 .. 00		.m5b:  db "LCD Test",0 
137a			 
137a .. 00		.m6:   db "Debug ON",0 
1383 .. 00		.m7:   db "Debug OFF",0 
138d			 
138d			; debug editor 
138d			 
138d			.diagedit: 
138d			 
138d 21 60 e3			ld hl, scratch 
1390			;	ld bc, 250 
1390			;	ldir 
1390				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1390 3e 00			ld a, 0 
1392 77				ld (hl), a 
1393 23				inc hl 
1394 77				ld (hl), a 
1395 23				inc hl 
1396 77				ld (hl), a 
1397			 
1397 cd 99 09		        call clear_display 
139a cd bc 09			call update_display 
139d 3e 01			ld a, 1 
139f 32 80 ee			ld (hardware_diag), a 
13a2			.diloop: 
13a2 3e 00			ld a, display_row_1 
13a4 0e 00			ld c, 0 
13a6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13a8 1e 28			ld e, 40 
13aa			 
13aa 21 60 e3			ld hl, scratch	 
13ad cd f3 0b			call input_str 
13b0			 
13b0 3e 28			ld a, display_row_2 
13b2 11 60 e3			ld de, scratch 
13b5 cd ac 09			call str_at_display 
13b8 cd bc 09			call update_display 
13bb			 
13bb c3 a2 13			jp .diloop 
13be			 
13be			 
13be			; pass word in hl 
13be			; a has display location 
13be			display_word_at: 
13be f5				push af 
13bf e5				push hl 
13c0 7c				ld a,h 
13c1 21 65 e6			ld hl, os_word_scratch 
13c4 cd c7 0e			call hexout 
13c7 e1				pop hl 
13c8 7d				ld a,l 
13c9 21 67 e6			ld hl, os_word_scratch+2 
13cc cd c7 0e			call hexout 
13cf 21 69 e6			ld hl, os_word_scratch+4 
13d2 3e 00			ld a,0 
13d4 77				ld (hl),a 
13d5 11 65 e6			ld de,os_word_scratch 
13d8 f1				pop af 
13d9 cd ac 09				call str_at_display 
13dc c9				ret 
13dd			 
13dd			display_ptr_state: 
13dd			 
13dd				; to restore afterwards 
13dd			 
13dd d5				push de 
13de c5				push bc 
13df e5				push hl 
13e0 f5				push af 
13e1			 
13e1				; for use in here 
13e1			 
13e1			;	push bc 
13e1			;	push de 
13e1			;	push hl 
13e1			;	push af 
13e1			 
13e1 cd 99 09			call clear_display 
13e4			 
13e4 11 b7 15			ld de, .ptrstate 
13e7 3e 00			ld a, display_row_1 
13e9 cd ac 09			call str_at_display 
13ec			 
13ec				; display debug step 
13ec			 
13ec			 
13ec 11 7a ee			ld de, debug_mark 
13ef 3e 26			ld a, display_row_1+display_cols-2 
13f1 cd ac 09			call str_at_display 
13f4			 
13f4				; display a 
13f4 11 c1 15			ld de, .ptrcliptr 
13f7 3e 28			ld a, display_row_2 
13f9 cd ac 09			call str_at_display 
13fc			 
13fc f1				pop af 
13fd 2a 2b eb			ld hl,(cli_ptr) 
1400 3e 30			ld a, display_row_2+8 
1402 cd be 13			call display_word_at 
1405			 
1405			 
1405				; display hl 
1405			 
1405			 
1405 11 c9 15			ld de, .ptrclioptr 
1408 3e 32			ld a, display_row_2+10 
140a cd ac 09			call str_at_display 
140d			; 
140d			;	pop hl 
140d 3e 35			ld a, display_row_2+13 
140f 2a 29 eb			ld hl,(cli_origptr) 
1412 cd be 13			call display_word_at 
1415			; 
1415			;	 
1415			;	; display de 
1415			 
1415			;	ld de, .regstatede 
1415			;	ld a, display_row_3 
1415			;	call str_at_display 
1415			 
1415			;	pop de 
1415			;	ld h,d 
1415			;	ld l, e 
1415			;	ld a, display_row_3+3 
1415			;	call display_word_at 
1415			 
1415			 
1415				; display bc 
1415			 
1415			;	ld de, .regstatebc 
1415			;	ld a, display_row_3+10 
1415			;	call str_at_display 
1415			 
1415			;	pop bc 
1415			;	ld h,b 
1415			;	ld l, c 
1415			;	ld a, display_row_3+13 
1415			;	call display_word_at 
1415			 
1415			 
1415				; display dsp 
1415			 
1415			;	ld de, .regstatedsp 
1415			;	ld a, display_row_4 
1415			;	call str_at_display 
1415			 
1415				 
1415			;	ld hl,(cli_data_sp) 
1415			;	ld a, display_row_4+4 
1415			;	call display_word_at 
1415			 
1415				; display rsp 
1415			 
1415 11 f8 15			ld de, .regstatersp 
1418 3e 82			ld a, display_row_4+10 
141a cd ac 09			call str_at_display 
141d			 
141d				 
141d 2a 11 eb			ld hl,(cli_ret_sp) 
1420 3e 86			ld a, display_row_4+14 
1422 cd be 13			call display_word_at 
1425			 
1425 cd bc 09			call update_display 
1428			 
1428 cd 0e 09			call delay1s 
142b cd 0e 09			call delay1s 
142e cd 0e 09			call delay1s 
1431			 
1431			 
1431 cd 3e 19			call next_page_prompt 
1434			 
1434				; restore  
1434			 
1434 f1				pop af 
1435 e1				pop hl 
1436 c1				pop bc 
1437 d1				pop de 
1438 c9				ret 
1439			 
1439			break_point_state: 
1439 f5				push af 
143a			 
143a				; see if disabled 
143a			 
143a 3a 51 e3			ld a, (os_view_disable) 
143d fe 2a			cp '*' 
143f 20 02			jr nz, .bpsgo 
1441 f1				pop af 
1442 c9				ret 
1443			 
1443			.bpsgo: 
1443 f1				pop af 
1444 f5				push af 
1445 22 4d e3			ld (os_view_hl), hl 
1448 ed 53 4b e3		ld (os_view_de), de 
144c ed 43 49 e3		ld (os_view_bc), bc 
1450 e5				push hl 
1451 6f				ld l, a 
1452 26 00			ld h, 0 
1454 22 4f e3			ld (os_view_af),hl 
1457			 
1457 21 c0 ed				ld hl, display_fb0 
145a 22 db eb				ld (display_fb_active), hl 
145d e1				pop hl	 
145e			 
145e 3e 31			ld a, '1' 
1460 fe 2a		.bps1:  cp '*' 
1462 20 03			jr nz, .bps1b 
1464 32 51 e3			ld (os_view_disable),a 
1467 fe 31		.bps1b:  cp '1' 
1469 20 14			jr nz, .bps2 
146b			 
146b				; display reg 
146b			 
146b				 
146b			 
146b 3a 4f e3			ld a, (os_view_af) 
146e 2a 4d e3			ld hl, (os_view_hl) 
1471 ed 5b 4b e3		ld de, (os_view_de) 
1475 ed 4b 49 e3		ld bc, (os_view_bc) 
1479 cd 13 15			call display_reg_state 
147c c3 ff 14			jp .bpschk 
147f			 
147f fe 32		.bps2:  cp '2' 
1481 20 08			jr nz, .bps3 
1483				 
1483				; display hl 
1483 2a 4d e3			ld hl, (os_view_hl) 
1486 cd fd 15			call display_dump_at_hl 
1489			 
1489 18 74			jr .bpschk 
148b			 
148b fe 33		.bps3:  cp '3' 
148d 20 08			jr nz, .bps4 
148f			 
148f			        ; display de 
148f 2a 4b e3			ld hl, (os_view_de) 
1492 cd fd 15			call display_dump_at_hl 
1495			 
1495 18 68			jr .bpschk 
1497 fe 34		.bps4:  cp '4' 
1499 20 08			jr nz, .bps5 
149b			 
149b			        ; display bc 
149b 2a 49 e3			ld hl, (os_view_bc) 
149e cd fd 15			call display_dump_at_hl 
14a1			 
14a1 18 5c			jr .bpschk 
14a3 fe 35		.bps5:  cp '5' 
14a5 20 08		        jr nz, .bps7 
14a7			 
14a7				; display cur ptr 
14a7 2a 2b eb			ld hl, (cli_ptr) 
14aa cd fd 15			call display_dump_at_hl 
14ad			 
14ad 18 50			jr .bpschk 
14af fe 36		.bps7:  cp '6' 
14b1 20 08			jr nz, .bps8b 
14b3				 
14b3				; display cur orig ptr 
14b3 2a 29 eb			ld hl, (cli_origptr) 
14b6 cd fd 15			call display_dump_at_hl 
14b9 18 44			jr .bpschk 
14bb fe 37		.bps8b:  cp '7' 
14bd 20 08			jr nz, .bps9 
14bf				 
14bf				; display dsp 
14bf 2a 0d eb			ld hl, (cli_data_sp) 
14c2 cd fd 15			call display_dump_at_hl 
14c5			 
14c5 18 38			jr .bpschk 
14c7 fe 39		.bps9:  cp '9' 
14c9 20 05			jr nz, .bps8c 
14cb				 
14cb				; display SP 
14cb			;	ld hl, sp 
14cb cd fd 15			call display_dump_at_hl 
14ce			 
14ce 18 2f			jr .bpschk 
14d0 fe 38		.bps8c:  cp '8' 
14d2 20 08			jr nz, .bps8d 
14d4				 
14d4				; display rsp 
14d4 2a 11 eb			ld hl, (cli_ret_sp) 
14d7 cd fd 15			call display_dump_at_hl 
14da			 
14da 18 23			jr .bpschk 
14dc fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14de 20 05			jr nz, .bps8 
14e0 cd 34 17			call monitor 
14e3			 
14e3 18 1a			jr .bpschk 
14e5 fe 30		.bps8:  cp '0' 
14e7 20 16			jr nz, .bpschk 
14e9			 
14e9 21 1f ed				ld hl, display_fb1 
14ec 22 db eb				ld (display_fb_active), hl 
14ef cd bc 09				call update_display 
14f2			 
14f2				;ld a, (os_view_af) 
14f2 2a 4d e3			ld hl, (os_view_hl) 
14f5 ed 5b 4b e3		ld de, (os_view_de) 
14f9 ed 4b 49 e3		ld bc, (os_view_bc) 
14fd f1				pop af 
14fe c9				ret 
14ff			 
14ff			.bpschk:   
14ff cd 0e 09			call delay1s 
1502 3e 9f		ld a,display_row_4 + display_cols - 1 
1504 11 3c 19		        ld de, endprg 
1507 cd ac 09			call str_at_display 
150a cd bc 09			call update_display 
150d cd b7 58			call cin_wait 
1510			 
1510 c3 60 14			jp .bps1 
1513			 
1513			 
1513			display_reg_state: 
1513			 
1513				; to restore afterwards 
1513			 
1513 d5				push de 
1514 c5				push bc 
1515 e5				push hl 
1516 f5				push af 
1517			 
1517				; for use in here 
1517			 
1517 c5				push bc 
1518 d5				push de 
1519 e5				push hl 
151a f5				push af 
151b			 
151b cd 99 09			call clear_display 
151e			 
151e 11 d3 15			ld de, .regstate 
1521 3e 00			ld a, display_row_1 
1523 cd ac 09			call str_at_display 
1526			 
1526				; display debug step 
1526			 
1526			 
1526 11 7a ee			ld de, debug_mark 
1529 3e 25			ld a, display_row_1+display_cols-3 
152b cd ac 09			call str_at_display 
152e			 
152e				; display a 
152e 11 ef 15			ld de, .regstatea 
1531 3e 28			ld a, display_row_2 
1533 cd ac 09			call str_at_display 
1536			 
1536 e1				pop hl 
1537			;	ld h,0 
1537			;	ld l, a 
1537 3e 2b			ld a, display_row_2+3 
1539 cd be 13			call display_word_at 
153c			 
153c			 
153c				; display hl 
153c			 
153c			 
153c 11 e3 15			ld de, .regstatehl 
153f 3e 32			ld a, display_row_2+10 
1541 cd ac 09			call str_at_display 
1544			 
1544 e1				pop hl 
1545 3e 35			ld a, display_row_2+13 
1547 cd be 13			call display_word_at 
154a			 
154a				 
154a				; display de 
154a			 
154a 11 e7 15			ld de, .regstatede 
154d 3e 50			ld a, display_row_3 
154f cd ac 09			call str_at_display 
1552			 
1552 e1				pop hl 
1553			;	ld h,d 
1553			;	ld l, e 
1553 3e 53			ld a, display_row_3+3 
1555 cd be 13			call display_word_at 
1558			 
1558			 
1558				; display bc 
1558			 
1558 11 eb 15			ld de, .regstatebc 
155b 3e 5a			ld a, display_row_3+10 
155d cd ac 09			call str_at_display 
1560			 
1560 e1				pop hl 
1561			;	ld h,b 
1561			;	ld l, c 
1561 3e 5d			ld a, display_row_3+13 
1563 cd be 13			call display_word_at 
1566			 
1566			 
1566				; display dsp 
1566			 
1566 11 f3 15			ld de, .regstatedsp 
1569 3e 78			ld a, display_row_4 
156b cd ac 09			call str_at_display 
156e			 
156e				 
156e 2a 0d eb			ld hl,(cli_data_sp) 
1571 3e 7c			ld a, display_row_4+4 
1573 cd be 13			call display_word_at 
1576			 
1576				; display rsp 
1576			 
1576 11 f8 15			ld de, .regstatersp 
1579 3e 82			ld a, display_row_4+10 
157b cd ac 09			call str_at_display 
157e			 
157e				 
157e 2a 11 eb			ld hl,(cli_ret_sp) 
1581 3e 86			ld a, display_row_4+14 
1583 cd be 13			call display_word_at 
1586			 
1586 cd bc 09			call update_display 
1589			 
1589			;	call delay1s 
1589			;	call delay1s 
1589			;	call delay1s 
1589			 
1589			 
1589			;	call next_page_prompt 
1589			 
1589				; restore  
1589			 
1589 f1				pop af 
158a e1				pop hl 
158b c1				pop bc 
158c d1				pop de 
158d c9				ret 
158e			 
158e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15a2 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15b7 .. 00		.ptrstate:	db "Ptr State",0 
15c1 .. 00		.ptrcliptr:     db "cli_ptr",0 
15c9 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15d3 .. 00		.regstate:	db "Reg State (1/0)",0 
15e3 .. 00		.regstatehl:	db "HL:",0 
15e7 .. 00		.regstatede:	db "DE:",0 
15eb .. 00		.regstatebc:	db "BC:",0 
15ef .. 00		.regstatea:	db "A :",0 
15f3 .. 00		.regstatedsp:	db "DSP:",0 
15f8 .. 00		.regstatersp:	db "RSP:",0 
15fd			 
15fd			display_dump_at_hl: 
15fd e5				push hl 
15fe d5				push de 
15ff c5				push bc 
1600 f5				push af 
1601			 
1601 22 83 e6			ld (os_cur_ptr),hl	 
1604 cd 99 09			call clear_display 
1607 cd 46 18			call dumpcont 
160a			;	call delay1s 
160a			;	call next_page_prompt 
160a			 
160a			 
160a f1				pop af 
160b c1				pop bc 
160c d1				pop de 
160d e1				pop hl 
160e c9				ret 
160f			 
160f			;if ENABLE_BASIC 
160f			;	include "nascombasic.asm" 
160f			;	basic: 
160f			;	include "forth/FORTH.ASM" 
160f			;endif 
160f			 
160f			; eof 
160f			 
160f			 
# End of file firmware_diags.asm
160f			  
160f			  
160f			  
160f			  
160f			; eof  
160f			  
# End of file firmware.asm
160f			 
160f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
160f			;if BASE_KEV  
160f			;baseram: equ 08000h 
160f			;endif 
160f			 
160f			;if BASE_SC114 
160f			;baseram:     equ    endofcode 
160f			;endif 
160f			 
160f			 
160f			; start system 
160f			 
160f			coldstart: 
160f				; set sp 
160f				; di/ei 
160f			 
160f f3				di 
1610 31 00 f0			ld sp, tos 
1613			;	ei 
1613			 
1613			 
1613				; disable breakpoint by default 
1613			 
1613 3e 2a			ld a,'*' 
1615 32 51 e3			ld (os_view_disable),a 
1618			 
1618				; init hardware 
1618			 
1618				; init keyboard and screen hardware 
1618			 
1618 cd 03 01			call hardware_init 
161b			 
161b			 
161b				; detect if any keys are held down to enable breakpoints at start up 
161b			 
161b cd bf 58			call cin  
161e fe 00			cp 0 
1620 28 03			jr z, .nokeys 
1622			 
1622				;call hardware_diags 
1622 cd 26 12			call config 
1625			 
1625			;	ld de, .bpen 
1625			;	ld a, display_row_4 
1625			;	call str_at_display 
1625			;	call update_display 
1625			; 
1625			;	ld a,0 
1625			;	ld (os_view_disable),a 
1625			; 
1625			;.bpwait: 
1625			;	call cin 
1625			;	cp 0 
1625			;	jr z, .bpwait 
1625			;	jr .nokeys 
1625			; 
1625			; 
1625			;.bpen:  db "Break points enabled!",0 
1625			 
1625			 
1625			 
1625			 
1625			 
1625			 
1625			.nokeys: 
1625			 
1625			 
1625				 
1625			 
1625			;jp  testkey 
1625			 
1625			;call storage_get_block_0 
1625			; 
1625			;ld hl, 0 
1625			;ld de, store_page 
1625			;call storage_read_block 
1625			 
1625				 
1625			;ld hl, 10 
1625			;ld de, store_page 
1625			;call storage_read_block 
1625			 
1625			 
1625			 
1625			 
1625			 
1625			;stop:	nop 
1625			;	jp stop 
1625			 
1625			 
1625			 
1625			main: 
1625 cd 99 09			call clear_display 
1628 cd bc 09			call update_display 
162b			 
162b			 
162b			 
162b			;	call testlcd 
162b			 
162b			 
162b			 
162b cd 04 1d			call forth_init 
162e			 
162e			 
162e			warmstart: 
162e cd da 1c			call forth_warmstart 
1631			 
1631				; run startup word load 
1631			        ; TODO prevent this running at warmstart after crash  
1631			 
1631				if STARTUP_ENABLE 
1631					if STORAGE_SE 
1631						call forth_autoload 
1631					endif 
1631 cd 05 55				call forth_startup 
1634			 
1634			 
1634				endif 
1634			 
1634				; show free memory after boot 
1634 11 ce 16			ld de, freeram 
1637 3e 00			ld a, display_row_1 
1639 cd ac 09			call str_at_display 
163c			 
163c			; Or use heap_size word???? 
163c 21 46 e3			ld hl, heap_end 
163f 11 e7 58			ld de, heap_start 
1642 ed 52			sbc hl, de 
1644 e5				push hl 
1645 7c				ld a,h	         	 
1646 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1649 cd c7 0e			call hexout 
164c e1			   	pop hl 
164d			 
164d 7d				ld a,l 
164e 21 67 e6			ld hl, os_word_scratch+2 
1651 cd c7 0e			call hexout 
1654 21 69 e6			ld hl, os_word_scratch+4 
1657 3e 00			ld a, 0 
1659 77				ld (hl),a 
165a 11 65 e6			ld de, os_word_scratch 
165d 3e 0d			ld a, display_row_1 + 13 
165f cd ac 09			call str_at_display 
1662 cd bc 09			call update_display 
1665			 
1665			 
1665				;call demo 
1665			 
1665			 
1665				; init scratch input area for cli commands 
1665			 
1665 21 87 e6			ld hl, os_cli_cmd 
1668 3e 00			ld a,0 
166a 77				ld (hl),a 
166b 23				inc hl 
166c 77				ld (hl),a 
166d			 
166d 3e 00			ld a,0 
166f 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1672			 
1672 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1675 32 84 e6			ld (os_cur_ptr+1),a	 
1678			 
1678 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
167b 32 66 e6			ld (os_word_scratch+1),a	 
167e				 
167e			 
167e				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
167e 21 87 e6			ld hl, os_cli_cmd 
1681			 
1681 3e 00			ld a, 0		 ; init cli input 
1683 77				ld (hl), a 
1684 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1686			cli: 
1686				; show cli prompt 
1686				;push af 
1686				;ld a, 0 
1686				;ld de, prompt 
1686				;call str_at_display 
1686			 
1686				;call update_display 
1686				;pop af 
1686				;inc a 
1686				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1686 0e 00			ld c, 0 
1688 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
168a 1e 28			ld e, 40 
168c			 
168c 21 87 e6			ld hl, os_cli_cmd 
168f			 
168f				STACKFRAME OFF $fefe $9f9f 
168f				if DEBUG_STACK_IMB 
168f					if OFF 
168f						exx 
168f						ld de, $fefe 
168f						ld a, d 
168f						ld hl, curframe 
168f						call hexout 
168f						ld a, e 
168f						ld hl, curframe+2 
168f						call hexout 
168f						ld hl, $fefe 
168f						push hl 
168f						ld hl, $9f9f 
168f						push hl 
168f						exx 
168f					endif 
168f				endif 
168f			endm 
# End of macro STACKFRAME
168f			 
168f cd f3 0b			call input_str 
1692			 
1692				STACKFRAMECHK OFF $fefe $9f9f 
1692				if DEBUG_STACK_IMB 
1692					if OFF 
1692						exx 
1692						ld hl, $9f9f 
1692						pop de   ; $9f9f 
1692						call cmp16 
1692						jr nz, .spnosame 
1692						ld hl, $fefe 
1692						pop de   ; $fefe 
1692						call cmp16 
1692						jr z, .spfrsame 
1692						.spnosame: call showsperror 
1692						.spfrsame: nop 
1692						exx 
1692					endif 
1692				endif 
1692			endm 
# End of macro STACKFRAMECHK
1692			 
1692				; copy input to last command 
1692			 
1692 21 87 e6			ld hl, os_cli_cmd 
1695 11 86 e7			ld de, os_last_cmd 
1698 01 ff 00			ld bc, 255 
169b ed b0			ldir 
169d			 
169d				; wipe current buffer 
169d			 
169d			;	ld a, 0 
169d			;	ld hl, os_cli_cmd 
169d			;	ld de, os_cli_cmd+1 
169d			;	ld bc, 254 
169d			;	ldir 
169d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
169d			;	call strcpy 
169d			;	ld a, 0 
169d			;	ld (hl), a 
169d			;	inc hl 
169d			;	ld (hl), a 
169d			;	inc hl 
169d			;	ld (hl), a 
169d			 
169d				; switch frame buffer to program  
169d			 
169d 21 1f ed				ld hl, display_fb1 
16a0 22 db eb				ld (display_fb_active), hl 
16a3			 
16a3			;	nop 
16a3				STACKFRAME ON $fbfe $8f9f 
16a3				if DEBUG_STACK_IMB 
16a3					if ON 
16a3						exx 
16a3						ld de, $fbfe 
16a3						ld a, d 
16a3						ld hl, curframe 
16a3						call hexout 
16a3						ld a, e 
16a3						ld hl, curframe+2 
16a3						call hexout 
16a3						ld hl, $fbfe 
16a3						push hl 
16a3						ld hl, $8f9f 
16a3						push hl 
16a3						exx 
16a3					endif 
16a3				endif 
16a3			endm 
# End of macro STACKFRAME
16a3				; first time into the parser so pass over the current scratch pad 
16a3 21 87 e6			ld hl,os_cli_cmd 
16a6				; tokenise the entered statement(s) in HL 
16a6 cd 7d 1d			call forthparse 
16a9			        ; exec forth statements in top of return stack 
16a9 cd bd 1d			call forthexec 
16ac				;call forthexec_cleanup 
16ac			;	call parsenext 
16ac			 
16ac				STACKFRAMECHK ON $fbfe $8f9f 
16ac				if DEBUG_STACK_IMB 
16ac					if ON 
16ac						exx 
16ac						ld hl, $8f9f 
16ac						pop de   ; $8f9f 
16ac						call cmp16 
16ac						jr nz, .spnosame 
16ac						ld hl, $fbfe 
16ac						pop de   ; $fbfe 
16ac						call cmp16 
16ac						jr z, .spfrsame 
16ac						.spnosame: call showsperror 
16ac						.spfrsame: nop 
16ac						exx 
16ac					endif 
16ac				endif 
16ac			endm 
# End of macro STACKFRAMECHK
16ac				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
16ac			 
16ac 3e 78			ld a, display_row_4 
16ae 11 e0 16			ld de, endprog 
16b1			 
16b1 cd bc 09			call update_display		 
16b4			 
16b4 cd 3e 19			call next_page_prompt 
16b7			 
16b7				; switch frame buffer to cli 
16b7			 
16b7 21 c0 ed				ld hl, display_fb0 
16ba 22 db eb				ld (display_fb_active), hl 
16bd			 
16bd			 
16bd cd 99 09		        call clear_display 
16c0 cd bc 09			call update_display		 
16c3			 
16c3 21 87 e6			ld hl, os_cli_cmd 
16c6			 
16c6 3e 00			ld a, 0		 ; init cli input 
16c8 77				ld (hl), a 
16c9			 
16c9				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
16c9			 
16c9				; now on last line 
16c9			 
16c9				; TODO scroll screen up 
16c9			 
16c9				; TODO instead just clear screen and place at top of screen 
16c9			 
16c9			;	ld a, 0 
16c9			;	ld (f_cursor_ptr),a 
16c9			 
16c9				;call clear_display 
16c9				;call update_display 
16c9			 
16c9				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16c9 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16cb c3 86 16			jp cli 
16ce			 
16ce .. 00		freeram: db "Free bytes: $",0 
16dc ..			asc: db "1A2F" 
16e0 .. 00		endprog: db "End prog...",0 
16ec			 
16ec			testenter2:   
16ec 21 92 e3			ld hl,scratch+50 
16ef 22 83 e6			ld (os_cur_ptr),hl 
16f2 c3 86 16			jp cli 
16f5			 
16f5			testenter:  
16f5			 
16f5 21 dc 16			ld hl,asc 
16f8			;	ld a,(hl) 
16f8			;	call nibble2val 
16f8 cd 1d 0f			call get_byte 
16fb			 
16fb			 
16fb			;	ld a,(hl) 
16fb			;	call atohex 
16fb			 
16fb			;	call fourehexhl 
16fb 32 92 e3			ld (scratch+50),a 
16fe			 
16fe			 
16fe			 
16fe 21 de 16			ld hl,asc+2 
1701			;	ld a, (hl) 
1701			;	call nibble2val 
1701 cd 1d 0f			call get_byte 
1704			 
1704			;	call fourehexhl 
1704 32 94 e3			ld (scratch+52),a 
1707				 
1707 21 92 e3			ld hl,scratch+50 
170a 22 83 e6			ld (os_cur_ptr),hl 
170d c3 86 16			jp cli 
1710			 
1710			enter:	 
1710 3a 64 e3			ld a,(scratch+4) 
1713 fe 00			cp 0 
1715 28 0c			jr z, .entercont 
1717				; no, not a null term line so has an address to work out.... 
1717			 
1717 21 62 e3			ld hl,scratch+2 
171a cd 7d 0f			call get_word_hl 
171d			 
171d 22 83 e6			ld (os_cur_ptr),hl	 
1720 c3 86 16			jp cli 
1723			 
1723			 
1723			.entercont:  
1723			 
1723 21 62 e3			ld hl, scratch+2 
1726 cd 1d 0f			call get_byte 
1729			 
1729 2a 83 e6		   	ld hl,(os_cur_ptr) 
172c 77					ld (hl),a 
172d 23					inc hl 
172e 22 83 e6				ld (os_cur_ptr),hl 
1731				 
1731			; get byte  
1731			 
1731			 
1731 c3 86 16			jp cli 
1734			 
1734			 
1734			; basic monitor support 
1734			 
1734			monitor: 
1734				;  
1734 cd 99 09			call clear_display 
1737 3e 00			ld a, 0 
1739 11 81 17			ld de, .monprompt 
173c cd ac 09			call str_at_display 
173f cd bc 09			call update_display 
1742			 
1742				; get a monitor command 
1742			 
1742 0e 00			ld c, 0     ; entry at top left 
1744 16 64			ld d, 100   ; max buffer size 
1746 1e 0f			ld e, 15    ; input scroll area 
1748 3e 00			ld a, 0     ; init string 
174a 21 5e e5			ld hl, os_input 
174d 77				ld (hl), a 
174e 23				inc hl 
174f 77				ld (hl), a 
1750 21 5e e5			ld hl, os_input 
1753 3e 01			ld a, 1     ; init string 
1755 cd f3 0b			call input_str 
1758			 
1758 cd 99 09		        call clear_display 
175b cd bc 09			call update_display		 
175e			 
175e 3a 5e e5			ld a, (os_input) 
1761 cd 1b 10			call toUpper 
1764 fe 48		        cp 'H' 
1766 28 6f		        jr z, .monhelp 
1768 fe 44			cp 'D'		; dump 
176a ca f8 17			jp z, .mondump	 
176d fe 43			cp 'C'		; dump 
176f ca 12 18			jp z, .moncdump	 
1772 fe 4d			cp 'M'		; dump 
1774 ca 83 17			jp z, .moneditstart 
1777 fe 55			cp 'U'		; dump 
1779 28 14			jr z, .monedit	 
177b fe 51			cp 'Q'		; dump 
177d c8				ret z	 
177e			 
177e			 
177e				; TODO "S" to access symbol by name and not need the address 
177e				; TODO "F" to find a string in memory 
177e			 
177e c3 34 17			jp monitor 
1781			 
1781 .. 00		.monprompt: db ">", 0 
1783			 
1783			.moneditstart: 
1783				; get starting address 
1783			 
1783 21 60 e5			ld hl,os_input+2 
1786 cd 7d 0f			call get_word_hl 
1789			 
1789 22 83 e6			ld (os_cur_ptr),hl	 
178c			 
178c c3 34 17			jp monitor 
178f			 
178f			.monedit: 
178f				; get byte to load 
178f			 
178f 21 60 e5			ld hl,os_input+2 
1792 cd 1d 0f			call get_byte 
1795			 
1795				; get address to update 
1795 2a 83 e6			ld hl, (os_cur_ptr) 
1798			 
1798				; update byte 
1798			 
1798 77				ld (hl), a 
1799			 
1799				; move to next address and save it 
1799			 
1799 23				inc hl 
179a 22 83 e6			ld (os_cur_ptr),hl	 
179d			 
179d c3 34 17			jp monitor 
17a0			 
17a0			 
17a0 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17b4 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17d0 .. 00		.monhelptext3:  db "Q-Quit",0 
17d7			        
17d7			.monhelp: 
17d7 3e 00			ld a, display_row_1 
17d9 11 a0 17		        ld de, .monhelptext1 
17dc			 
17dc cd ac 09			call str_at_display 
17df 3e 28			ld a, display_row_2 
17e1 11 b4 17		        ld de, .monhelptext2 
17e4					 
17e4 cd ac 09			call str_at_display 
17e7 3e 50			ld a, display_row_3 
17e9 11 d0 17		        ld de, .monhelptext3 
17ec					 
17ec cd ac 09			call str_at_display 
17ef cd bc 09			call update_display		 
17f2			 
17f2 cd 3e 19			call next_page_prompt 
17f5 c3 34 17			jp monitor 
17f8			 
17f8			.mondump:    
17f8 21 60 e5			ld hl,os_input+2 
17fb cd 7d 0f			call get_word_hl 
17fe			 
17fe 22 83 e6			ld (os_cur_ptr),hl	 
1801 cd 46 18			call dumpcont 
1804 3e 78			ld a, display_row_4 
1806 11 e0 16			ld de, endprog 
1809			 
1809 cd bc 09			call update_display		 
180c			 
180c cd 3e 19			call next_page_prompt 
180f c3 34 17			jp monitor 
1812			.moncdump: 
1812 cd 46 18			call dumpcont 
1815 3e 78			ld a, display_row_4 
1817 11 e0 16			ld de, endprog 
181a			 
181a cd bc 09			call update_display		 
181d			 
181d cd 3e 19			call next_page_prompt 
1820 c3 34 17			jp monitor 
1823			 
1823			 
1823			; TODO symbol access  
1823			 
1823			.symbols:     ;; A list of symbols that can be called up  
1823 c0 ed			dw display_fb0 
1825 .. 00			db "fb0",0  
1829 65 eb		     	dw store_page 
182b .. 00			db "store_page",0 
1836			 
1836			 
1836			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1836			 
1836 3a 61 e3			ld a,(scratch+1) 
1839 fe 00			cp 0 
183b 28 09			jr z, dumpcont 
183d			 
183d				; no, not a null term line so has an address to work out.... 
183d			 
183d 21 62 e3			ld hl,scratch+2 
1840 cd 7d 0f			call get_word_hl 
1843			 
1843 22 83 e6			ld (os_cur_ptr),hl	 
1846			 
1846			 
1846			 
1846			dumpcont: 
1846			 
1846				; dump bytes at ptr 
1846			 
1846			 
1846 3e 00			ld a, display_row_1 
1848 2a db eb			ld hl, (display_fb_active) 
184b cd c6 0b			call addatohl 
184e cd 76 18			call .dumpbyterow 
1851			 
1851 3e 28			ld a, display_row_2 
1853 2a db eb			ld hl, (display_fb_active) 
1856 cd c6 0b			call addatohl 
1859 cd 76 18			call .dumpbyterow 
185c			 
185c			 
185c 3e 50			ld a, display_row_3 
185e 2a db eb			ld hl, (display_fb_active) 
1861 cd c6 0b			call addatohl 
1864 cd 76 18			call .dumpbyterow 
1867			 
1867 3e 78			ld a, display_row_4 
1869 2a db eb			ld hl, (display_fb_active) 
186c cd c6 0b			call addatohl 
186f cd 76 18			call .dumpbyterow 
1872			 
1872 cd bc 09			call update_display 
1875			;		jp cli 
1875 c9				ret 
1876			 
1876			.dumpbyterow: 
1876			 
1876				;push af 
1876			 
1876 e5				push hl 
1877			 
1877				; calc where to poke the ascii 
1877			if display_cols == 20 
1877				ld a, 16 
1877			else 
1877 3e 1f			ld a, 31 
1879			endif 
1879			 
1879 cd c6 0b			call addatohl 
187c 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
187f			 
187f			 
187f			; display decoding address 
187f 2a 83 e6		   	ld hl,(os_cur_ptr) 
1882			 
1882 7c				ld a,h 
1883 e1				pop hl 
1884 e5				push hl 
1885			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1885 cd c7 0e			call hexout 
1888 2a 83 e6		   	ld hl,(os_cur_ptr) 
188b			 
188b 7d				ld a,l 
188c e1				pop hl 
188d 23				inc hl 
188e 23				inc hl 
188f e5				push hl 
1890			;	ld hl, os_word_scratch+2 
1890 cd c7 0e			call hexout 
1893 e1				pop hl 
1894 23				inc hl 
1895 23				inc hl 
1896				;ld hl, os_word_scratch+4 
1896 3e 3a			ld a, ':' 
1898 77				ld (hl),a 
1899 23				inc hl 
189a				;ld a, 0 
189a				;ld (hl),a 
189a				;ld de, os_word_scratch 
189a				;pop af 
189a				;push af 
189a			;		ld a, display_row_2 
189a			;		call str_at_display 
189a			;		call update_display 
189a			 
189a			 
189a			;pop af 
189a			;	add 5 
189a			 
189a			if display_cols == 20 
189a				ld b, 4 
189a			else 
189a 06 08			ld b, 8 
189c			endif	 
189c			 
189c			.dumpbyte: 
189c c5				push bc 
189d e5				push hl 
189e			 
189e			 
189e 2a 83 e6		   	ld hl,(os_cur_ptr) 
18a1 7e					ld a,(hl) 
18a2			 
18a2					; poke the ascii to display 
18a2 2a 65 e6				ld hl,(os_word_scratch) 
18a5 77					ld (hl),a 
18a6 23					inc hl 
18a7 22 65 e6				ld (os_word_scratch),hl 
18aa			 
18aa					 
18aa			 
18aa			 
18aa e1					pop hl 
18ab e5					push hl 
18ac			 
18ac cd c7 0e				call hexout 
18af			 
18af					 
18af 2a 83 e6		   	ld hl,(os_cur_ptr) 
18b2 23				inc hl 
18b3 22 83 e6		   	ld (os_cur_ptr),hl 
18b6			 
18b6 e1					pop hl 
18b7 23					inc hl 
18b8 23					inc hl 
18b9 23					inc hl 
18ba			 
18ba			 
18ba			 
18ba					;ld a,0 
18ba					;ld (os_word_scratch+2),a 
18ba					;pop af 
18ba					;push af 
18ba			 
18ba					;ld de, os_word_scratch 
18ba					;call str_at_display 
18ba			;		call update_display 
18ba			;		pop af 
18ba c1					pop bc 
18bb c6 03				add 3 
18bd 10 dd			djnz .dumpbyte 
18bf			 
18bf				 
18bf			 
18bf c9				ret 
18c0			 
18c0			jump:	 
18c0			 
18c0 21 62 e3			ld hl,scratch+2 
18c3 cd 7d 0f			call get_word_hl 
18c6				;ld hl,(scratch+2) 
18c6				;call fourehexhl 
18c6			 
18c6 22 83 e6			ld (os_cur_ptr),hl	 
18c9			 
18c9 e9				jp (hl) 
18ca			 
18ca			 
18ca			 
18ca			; TODO implement a basic monitor mode to start with 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			 
18ca			; testing and demo code during development 
18ca			 
18ca			 
18ca .. 00		str1: db "Enter some text...",0 
18dd .. 00		clear: db "                    ",0 
18f2			 
18f2			demo: 
18f2			 
18f2			 
18f2			 
18f2			;	call update_display 
18f2			 
18f2				; init scratch input area for testing 
18f2 21 60 e3			ld hl, scratch	 
18f5 3e 00			ld a,0 
18f7 77				ld (hl),a 
18f8			 
18f8			 
18f8 3e 28		            LD   A, display_row_2 
18fa			;            CALL fLCD_Pos       ;Position cursor to location in A 
18fa 11 ca 18		            LD   DE, str1 
18fd cd ac 09			call str_at_display 
1900			 
1900			;            CALL fLCD_Str       ;Display string pointed to by DE 
1900			cloop:	 
1900 3e 50		            LD   A, display_row_3 
1902			;            CALL fLCD_Pos       ;Position cursor to location in A 
1902 11 dd 18		            LD   DE, clear 
1905			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1905 cd ac 09				call str_at_display 
1908 3e 78			ld a, display_row_4 
190a 11 3a 19			ld de, prompt 
190d			 
190d cd ac 09				call str_at_display 
1910 cd bc 09			call update_display 
1913			 
1913 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1915 16 0a			ld d, 10 
1917 21 60 e3			ld hl, scratch	 
191a cd f3 0b			call input_str 
191d			 
191d			;	call clear_display 
191d			;'	call update_display 
191d			 
191d 3e 00		            LD   A, display_row_1 
191f			;            CALL fLCD_Pos       ;Position cursor to location in A 
191f 11 dd 18		            LD   DE, clear 
1922 cd ac 09				call str_at_display 
1925			;            CALL fLCD_Str       ;Display string pointed to by DE 
1925 3e 00		            LD   A, display_row_1 
1927			;            CALL fLCD_Pos       ;Position cursor to location in A 
1927 11 60 e3		            LD   DE, scratch 
192a			;            CALL fLCD_Str       ;Display string pointed to by DE 
192a cd ac 09				call str_at_display 
192d cd bc 09			call update_display 
1930			 
1930 3e 00				ld a,0 
1932 21 60 e3			ld hl, scratch 
1935 77				ld (hl),a 
1936			 
1936 00				nop 
1937 c3 00 19			jp cloop 
193a			 
193a			 
193a			 
193a			; OS Prompt 
193a			 
193a .. 00		prompt: db ">",0 
193c .. 00		endprg: db "?",0 
193e			 
193e			 
193e			; handy next page prompt 
193e			next_page_prompt: 
193e e5				push hl 
193f d5				push de 
1940 f5				push af 
1941 c5				push bc 
1942			 
1942 3e 9f			ld a,display_row_4 + display_cols - 1 
1944 11 3c 19		        ld de, endprg 
1947 cd ac 09			call str_at_display 
194a cd bc 09			call update_display 
194d cd b7 58			call cin_wait 
1950 c1				pop bc 
1951 f1				pop af 
1952 d1				pop de 
1953 e1				pop hl 
1954			 
1954			 
1954 c9				ret 
1955			 
1955			 
1955			; forth parser 
1955			 
1955			; My forth kernel 
1955			include "forth_kernel.asm" 
1955			; 
1955			; kernel to the forth OS 
1955			 
1955			DS_TYPE_STR: equ 1     ; string type 
1955			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1955			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1955			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1955			 
1955			FORTH_PARSEV1: equ 0 
1955			FORTH_PARSEV2: equ 0 
1955			FORTH_PARSEV3: equ 0 
1955			FORTH_PARSEV4: equ 0 
1955			FORTH_PARSEV5: equ 1 
1955			 
1955			;if FORTH_PARSEV5 
1955			;	FORTH_END_BUFFER: equ 0 
1955			;else 
1955			FORTH_END_BUFFER: equ 127 
1955			;endif 
1955			 
1955			FORTH_TRUE: equ 1 
1955			FORTH_FALSE: equ 0 
1955			 
1955			if FORTH_PARSEV4 
1955			include "forth_stackops.asm" 
1955			endif 
1955			 
1955			if FORTH_PARSEV5 
1955			include "forth_stackopsv5.asm" 
1955			 
1955			; Stack operations for v5 parser on wards 
1955			; * DATA stack 
1955			; * LOOP stack 
1955			; * RETURN stack 
1955			 
1955			 
1955			 
1955			FORTH_CHK_DSP_UNDER: macro 
1955				push hl 
1955				push de 
1955				ld hl,(cli_data_sp) 
1955				ld de, cli_data_stack 
1955				call cmp16 
1955				jp c, fault_dsp_under 
1955				pop de 
1955				pop hl 
1955				endm 
1955			 
1955			 
1955			FORTH_CHK_RSP_UNDER: macro 
1955				push hl 
1955				push de 
1955				ld hl,(cli_ret_sp) 
1955				ld de, cli_ret_stack 
1955				call cmp16 
1955				jp c, fault_rsp_under 
1955				pop de 
1955				pop hl 
1955				endm 
1955			 
1955			FORTH_CHK_LOOP_UNDER: macro 
1955				push hl 
1955				push de 
1955				ld hl,(cli_loop_sp) 
1955				ld de, cli_loop_stack 
1955				call cmp16 
1955				jp c, fault_loop_under 
1955				pop de 
1955				pop hl 
1955				endm 
1955			 
1955			FORTH_ERR_TOS_NOTSTR: macro 
1955				; TOSO might need more for checks when used 
1955				push af 
1955				ld a,(hl) 
1955				cp DS_TYPE_STR 
1955				jp nz, type_faultn   
1955				pop af 
1955				endm 
1955			 
1955			FORTH_ERR_TOS_NOTNUM: macro 
1955				push af 
1955				ld a,(hl) 
1955				cp DS_TYPE_INUM 
1955				jp nz, type_faultn   
1955				pop af 
1955				endm 
1955			 
1955			 
1955			; increase data stack pointer and save hl to it 
1955				 
1955			FORTH_DSP_NEXT: macro 
1955				call macro_forth_dsp_next 
1955				endm 
1955			 
1955			 
1955			macro_forth_dsp_next: 
1955				if DEBUG_FORTH_STACK_GUARD 
1955 cd cf 55				call check_stacks 
1958				endif 
1958 e5				push hl 
1959 d5				push de 
195a eb				ex de,hl 
195b 2a 0d eb			ld hl,(cli_data_sp) 
195e 23				inc hl 
195f 23				inc hl 
1960			 
1960			; PARSEV5 
1960 23				inc hl 
1961 22 0d eb			ld (cli_data_sp),hl 
1964 73				ld (hl), e 
1965 23				inc hl 
1966 72				ld (hl), d 
1967 d1				pop de 
1968 e1				pop hl 
1969				if DEBUG_FORTH_STACK_GUARD 
1969 cd cf 55				call check_stacks 
196c				endif 
196c c9				ret 
196d			 
196d			 
196d			; increase ret stack pointer and save hl to it 
196d				 
196d			FORTH_RSP_NEXT: macro 
196d				call macro_forth_rsp_next 
196d				endm 
196d			 
196d			macro_forth_rsp_next: 
196d				if DEBUG_FORTH_STACK_GUARD 
196d cd cf 55				call check_stacks 
1970				endif 
1970 e5				push hl 
1971 d5				push de 
1972 eb				ex de,hl 
1973 2a 11 eb			ld hl,(cli_ret_sp) 
1976 23				inc hl 
1977 23				inc hl 
1978 22 11 eb			ld (cli_ret_sp),hl 
197b 73				ld (hl), e 
197c 23				inc hl 
197d 72				ld (hl), d 
197e d1				pop de 
197f e1				pop hl 
1980				if DEBUG_FORTH_STACK_GUARD 
1980 cd cf 55				call check_stacks 
1983				endif 
1983 c9				ret 
1984			 
1984			; get current ret stack pointer and save to hl  
1984				 
1984			FORTH_RSP_TOS: macro 
1984				call macro_forth_rsp_tos 
1984				endm 
1984			 
1984			macro_forth_rsp_tos: 
1984				;push de 
1984 2a 11 eb			ld hl,(cli_ret_sp) 
1987 cd bf 19			call loadhlptrtohl 
198a				;ld e, (hl) 
198a				;inc hl 
198a				;ld d, (hl) 
198a				;ex de, hl 
198a					if DEBUG_FORTH_WORDS 
198a			;			DMARK "RST" 
198a						CALLMONITOR 
198a cd 39 14			call break_point_state  
198d				endm  
# End of macro CALLMONITOR
198d					endif 
198d				;pop de 
198d c9				ret 
198e			 
198e			; pop ret stack pointer 
198e				 
198e			FORTH_RSP_POP: macro 
198e				call macro_forth_rsp_pop 
198e				endm 
198e			 
198e			 
198e			macro_forth_rsp_pop: 
198e				if DEBUG_FORTH_STACK_GUARD 
198e			;		DMARK "RPP" 
198e cd cf 55				call check_stacks 
1991					FORTH_CHK_RSP_UNDER 
1991 e5				push hl 
1992 d5				push de 
1993 2a 11 eb			ld hl,(cli_ret_sp) 
1996 11 cb ea			ld de, cli_ret_stack 
1999 cd e4 0b			call cmp16 
199c da e3 56			jp c, fault_rsp_under 
199f d1				pop de 
19a0 e1				pop hl 
19a1				endm 
# End of macro FORTH_CHK_RSP_UNDER
19a1				endif 
19a1 e5				push hl 
19a2 2a 11 eb			ld hl,(cli_ret_sp) 
19a5			 
19a5			 
19a5				if FORTH_ENABLE_FREE 
19a5			 
19a5					; get pointer 
19a5			 
19a5					push de 
19a5					push hl 
19a5			 
19a5					ld e, (hl) 
19a5					inc hl 
19a5					ld d, (hl) 
19a5			 
19a5					ex de, hl 
19a5					call free 
19a5			 
19a5					pop hl 
19a5					pop de 
19a5			 
19a5			 
19a5				endif 
19a5			 
19a5			 
19a5 2b				dec hl 
19a6 2b				dec hl 
19a7 22 11 eb			ld (cli_ret_sp), hl 
19aa				; do stack underflow checks 
19aa e1				pop hl 
19ab				if DEBUG_FORTH_STACK_GUARD 
19ab cd cf 55				call check_stacks 
19ae					FORTH_CHK_RSP_UNDER 
19ae e5				push hl 
19af d5				push de 
19b0 2a 11 eb			ld hl,(cli_ret_sp) 
19b3 11 cb ea			ld de, cli_ret_stack 
19b6 cd e4 0b			call cmp16 
19b9 da e3 56			jp c, fault_rsp_under 
19bc d1				pop de 
19bd e1				pop hl 
19be				endm 
# End of macro FORTH_CHK_RSP_UNDER
19be				endif 
19be c9				ret 
19bf			 
19bf			 
19bf			 
19bf			; routine to load word pointed to by hl into hl 
19bf			 
19bf			loadhlptrtohl: 
19bf			 
19bf d5				push de 
19c0 5e				ld e, (hl) 
19c1 23				inc hl 
19c2 56				ld d, (hl) 
19c3 eb				ex de, hl 
19c4 d1				pop de 
19c5			 
19c5 c9				ret 
19c6			 
19c6			 
19c6			 
19c6			 
19c6			 
19c6			; push a number held in HL onto the data stack 
19c6			; entry point for pushing a value when already in hl used in function above 
19c6			 
19c6			forth_push_numhl: 
19c6			 
19c6 e5				push hl    ; save value to push 
19c7			 
19c7			if DEBUG_FORTH_PUSH 
19c7				; see if disabled 
19c7			 
19c7			 
19c7 f5				push af 
19c8 3a 51 e3			ld a, (os_view_disable) 
19cb fe 2a			cp '*' 
19cd 28 34			jr z, .pskip2 
19cf e5				push hl 
19d0 e5			push hl 
19d1 cd 99 09			call clear_display 
19d4 e1			pop hl 
19d5 7c				ld a,h 
19d6 21 65 e6			ld hl, os_word_scratch 
19d9 cd c7 0e			call hexout 
19dc e1				pop hl 
19dd 7d				ld a,l 
19de 21 67 e6			ld hl, os_word_scratch+2 
19e1 cd c7 0e			call hexout 
19e4			 
19e4 21 69 e6			ld hl, os_word_scratch+4 
19e7 3e 00			ld a,0 
19e9 77				ld (hl),a 
19ea 11 65 e6			ld de,os_word_scratch 
19ed 3e 28				ld a, display_row_2 
19ef cd ac 09				call str_at_display 
19f2 11 dd 44			ld de, .push_num 
19f5 3e 00			ld a, display_row_1 
19f7			 
19f7 cd ac 09				call str_at_display 
19fa			 
19fa			 
19fa cd bc 09			call update_display 
19fd cd 0e 09			call delay1s 
1a00 cd 0e 09			call delay1s 
1a03			.pskip2:  
1a03			 
1a03 f1				pop af 
1a04			endif	 
1a04			 
1a04			 
1a04				FORTH_DSP_NEXT 
1a04 cd 55 19			call macro_forth_dsp_next 
1a07				endm 
# End of macro FORTH_DSP_NEXT
1a07			 
1a07 2a 0d eb			ld hl, (cli_data_sp) 
1a0a			 
1a0a				; save item type 
1a0a 3e 02			ld a,  DS_TYPE_INUM 
1a0c 77				ld (hl), a 
1a0d 23				inc hl 
1a0e			 
1a0e				; get word off stack 
1a0e d1				pop de 
1a0f 7b				ld a,e 
1a10 77				ld (hl), a 
1a11 23				inc hl 
1a12 7a				ld a,d 
1a13 77				ld (hl), a 
1a14			 
1a14			if DEBUG_FORTH_PUSH 
1a14 2b				dec hl 
1a15 2b				dec hl 
1a16 2b				dec hl 
1a17						DMARK "PH5" 
1a17 f5				push af  
1a18 3a 2c 1a			ld a, (.dmark)  
1a1b 32 7a ee			ld (debug_mark),a  
1a1e 3a 2d 1a			ld a, (.dmark+1)  
1a21 32 7b ee			ld (debug_mark+1),a  
1a24 3a 2e 1a			ld a, (.dmark+2)  
1a27 32 7c ee			ld (debug_mark+2),a  
1a2a 18 03			jr .pastdmark  
1a2c ..			.dmark: db "PH5"  
1a2f f1			.pastdmark: pop af  
1a30			endm  
# End of macro DMARK
1a30				CALLMONITOR 
1a30 cd 39 14			call break_point_state  
1a33				endm  
# End of macro CALLMONITOR
1a33			endif	 
1a33			 
1a33 c9				ret 
1a34			 
1a34			 
1a34			; Push a string to stack pointed to by hl 
1a34			 
1a34			forth_push_str: 
1a34			 
1a34			if DEBUG_FORTH_PUSH 
1a34						DMARK "PSQ" 
1a34 f5				push af  
1a35 3a 49 1a			ld a, (.dmark)  
1a38 32 7a ee			ld (debug_mark),a  
1a3b 3a 4a 1a			ld a, (.dmark+1)  
1a3e 32 7b ee			ld (debug_mark+1),a  
1a41 3a 4b 1a			ld a, (.dmark+2)  
1a44 32 7c ee			ld (debug_mark+2),a  
1a47 18 03			jr .pastdmark  
1a49 ..			.dmark: db "PSQ"  
1a4c f1			.pastdmark: pop af  
1a4d			endm  
# End of macro DMARK
1a4d				CALLMONITOR 
1a4d cd 39 14			call break_point_state  
1a50				endm  
# End of macro CALLMONITOR
1a50			endif	 
1a50			    
1a50 e5				push hl 
1a51 e5				push hl 
1a52			 
1a52			;	ld a, 0   ; find end of string 
1a52 cd 24 10			call strlenz 
1a55			if DEBUG_FORTH_PUSH 
1a55						DMARK "PQ2" 
1a55 f5				push af  
1a56 3a 6a 1a			ld a, (.dmark)  
1a59 32 7a ee			ld (debug_mark),a  
1a5c 3a 6b 1a			ld a, (.dmark+1)  
1a5f 32 7b ee			ld (debug_mark+1),a  
1a62 3a 6c 1a			ld a, (.dmark+2)  
1a65 32 7c ee			ld (debug_mark+2),a  
1a68 18 03			jr .pastdmark  
1a6a ..			.dmark: db "PQ2"  
1a6d f1			.pastdmark: pop af  
1a6e			endm  
# End of macro DMARK
1a6e				CALLMONITOR 
1a6e cd 39 14			call break_point_state  
1a71				endm  
# End of macro CALLMONITOR
1a71			endif	 
1a71 eb				ex de, hl 
1a72 e1				pop hl   ; get ptr to start of string 
1a73			if DEBUG_FORTH_PUSH 
1a73						DMARK "PQ3" 
1a73 f5				push af  
1a74 3a 88 1a			ld a, (.dmark)  
1a77 32 7a ee			ld (debug_mark),a  
1a7a 3a 89 1a			ld a, (.dmark+1)  
1a7d 32 7b ee			ld (debug_mark+1),a  
1a80 3a 8a 1a			ld a, (.dmark+2)  
1a83 32 7c ee			ld (debug_mark+2),a  
1a86 18 03			jr .pastdmark  
1a88 ..			.dmark: db "PQ3"  
1a8b f1			.pastdmark: pop af  
1a8c			endm  
# End of macro DMARK
1a8c				CALLMONITOR 
1a8c cd 39 14			call break_point_state  
1a8f				endm  
# End of macro CALLMONITOR
1a8f			endif	 
1a8f 19				add hl,de 
1a90			if DEBUG_FORTH_PUSH 
1a90						DMARK "PQE" 
1a90 f5				push af  
1a91 3a a5 1a			ld a, (.dmark)  
1a94 32 7a ee			ld (debug_mark),a  
1a97 3a a6 1a			ld a, (.dmark+1)  
1a9a 32 7b ee			ld (debug_mark+1),a  
1a9d 3a a7 1a			ld a, (.dmark+2)  
1aa0 32 7c ee			ld (debug_mark+2),a  
1aa3 18 03			jr .pastdmark  
1aa5 ..			.dmark: db "PQE"  
1aa8 f1			.pastdmark: pop af  
1aa9			endm  
# End of macro DMARK
1aa9				CALLMONITOR 
1aa9 cd 39 14			call break_point_state  
1aac				endm  
# End of macro CALLMONITOR
1aac			endif	 
1aac			 
1aac 2b				dec hl    ; see if there is an optional trailing double quote 
1aad 7e				ld a,(hl) 
1aae fe 22			cp '"' 
1ab0 20 03			jr nz, .strnoq 
1ab2 3e 00			ld a, 0      ; get rid of double quote 
1ab4 77				ld (hl), a 
1ab5 23			.strnoq: inc hl 
1ab6			 
1ab6 3e 00			ld a, 0 
1ab8 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ab9			 
1ab9 13				inc de ; add one for the type string 
1aba 13				inc de ; add one for null term??? 
1abb			 
1abb				; tos is get string pointer again 
1abb				; de contains space to allocate 
1abb				 
1abb d5				push de 
1abc			 
1abc eb				ex de, hl 
1abd			 
1abd				;push af 
1abd			 
1abd			if DEBUG_FORTH_PUSH 
1abd						DMARK "PHm" 
1abd f5				push af  
1abe 3a d2 1a			ld a, (.dmark)  
1ac1 32 7a ee			ld (debug_mark),a  
1ac4 3a d3 1a			ld a, (.dmark+1)  
1ac7 32 7b ee			ld (debug_mark+1),a  
1aca 3a d4 1a			ld a, (.dmark+2)  
1acd 32 7c ee			ld (debug_mark+2),a  
1ad0 18 03			jr .pastdmark  
1ad2 ..			.dmark: db "PHm"  
1ad5 f1			.pastdmark: pop af  
1ad6			endm  
# End of macro DMARK
1ad6				CALLMONITOR 
1ad6 cd 39 14			call break_point_state  
1ad9				endm  
# End of macro CALLMONITOR
1ad9			endif	 
1ad9 cd 8d 10			call malloc	; on ret hl now contains allocated memory 
1adc				if DEBUG_FORTH_MALLOC_GUARD 
1adc cc 35 45				call z,malloc_error 
1adf				endif 
1adf			 
1adf				 
1adf c1				pop bc    ; get length 
1ae0 d1				pop de   ;  get string start    
1ae1			 
1ae1				; hl has destination from malloc 
1ae1			 
1ae1 eb				ex de, hl    ; prep for ldir 
1ae2			 
1ae2 d5				push de   ; save malloc area for DSP later 
1ae3				;push hl   ; save malloc area for DSP later 
1ae3			 
1ae3			if DEBUG_FORTH_PUSH 
1ae3						DMARK "PHc" 
1ae3 f5				push af  
1ae4 3a f8 1a			ld a, (.dmark)  
1ae7 32 7a ee			ld (debug_mark),a  
1aea 3a f9 1a			ld a, (.dmark+1)  
1aed 32 7b ee			ld (debug_mark+1),a  
1af0 3a fa 1a			ld a, (.dmark+2)  
1af3 32 7c ee			ld (debug_mark+2),a  
1af6 18 03			jr .pastdmark  
1af8 ..			.dmark: db "PHc"  
1afb f1			.pastdmark: pop af  
1afc			endm  
# End of macro DMARK
1afc				CALLMONITOR 
1afc cd 39 14			call break_point_state  
1aff				endm  
# End of macro CALLMONITOR
1aff			endif	 
1aff			 
1aff			 
1aff ed b0			ldir 
1b01			 
1b01			 
1b01				; push malloc to data stack     macro?????  
1b01			 
1b01				FORTH_DSP_NEXT 
1b01 cd 55 19			call macro_forth_dsp_next 
1b04				endm 
# End of macro FORTH_DSP_NEXT
1b04			 
1b04				; save value and type 
1b04			 
1b04 2a 0d eb			ld hl, (cli_data_sp) 
1b07			 
1b07				; save item type 
1b07 3e 01			ld a,  DS_TYPE_STR 
1b09 77				ld (hl), a 
1b0a 23				inc hl 
1b0b			 
1b0b				; get malloc word off stack 
1b0b d1				pop de 
1b0c 73				ld (hl), e 
1b0d 23				inc hl 
1b0e 72				ld (hl), d 
1b0f			 
1b0f			 
1b0f			 
1b0f			if DEBUG_FORTH_PUSH 
1b0f 2a 0d eb			ld hl, (cli_data_sp) 
1b12						DMARK "PHS" 
1b12 f5				push af  
1b13 3a 27 1b			ld a, (.dmark)  
1b16 32 7a ee			ld (debug_mark),a  
1b19 3a 28 1b			ld a, (.dmark+1)  
1b1c 32 7b ee			ld (debug_mark+1),a  
1b1f 3a 29 1b			ld a, (.dmark+2)  
1b22 32 7c ee			ld (debug_mark+2),a  
1b25 18 03			jr .pastdmark  
1b27 ..			.dmark: db "PHS"  
1b2a f1			.pastdmark: pop af  
1b2b			endm  
# End of macro DMARK
1b2b				CALLMONITOR 
1b2b cd 39 14			call break_point_state  
1b2e				endm  
# End of macro CALLMONITOR
1b2e			;	ex de,hl 
1b2e			endif	 
1b2e				; in case of spaces, skip the ptr past the copied string 
1b2e				;pop af 
1b2e				;ld (cli_origptr),hl 
1b2e			 
1b2e c9				ret 
1b2f			 
1b2f			 
1b2f			 
1b2f			; TODO ascii push input onto stack given hl to start of input 
1b2f			 
1b2f			; identify type 
1b2f			; if starts with a " then a string 
1b2f			; otherwise it is a number 
1b2f			;  
1b2f			; if a string 
1b2f			;     scan for ending " to get length of string to malloc for + 1 
1b2f			;     malloc 
1b2f			;     put pointer to string on stack first byte flags as string 
1b2f			; 
1b2f			; else a number 
1b2f			;    look for number format identifier 
1b2f			;    $xx hex 
1b2f			;    %xxxxx bin 
1b2f			;    xxxxx decimal 
1b2f			;    convert number to 16bit word.  
1b2f			;    malloc word + 1 with flag to identiy as num 
1b2f			;    put pointer to number on stack 
1b2f			;   
1b2f			;  
1b2f			  
1b2f			forth_apush: 
1b2f				; kernel push 
1b2f			 
1b2f			if DEBUG_FORTH_PUSH 
1b2f						DMARK "PSH" 
1b2f f5				push af  
1b30 3a 44 1b			ld a, (.dmark)  
1b33 32 7a ee			ld (debug_mark),a  
1b36 3a 45 1b			ld a, (.dmark+1)  
1b39 32 7b ee			ld (debug_mark+1),a  
1b3c 3a 46 1b			ld a, (.dmark+2)  
1b3f 32 7c ee			ld (debug_mark+2),a  
1b42 18 03			jr .pastdmark  
1b44 ..			.dmark: db "PSH"  
1b47 f1			.pastdmark: pop af  
1b48			endm  
# End of macro DMARK
1b48				CALLMONITOR 
1b48 cd 39 14			call break_point_state  
1b4b				endm  
# End of macro CALLMONITOR
1b4b			endif	 
1b4b				; identify input type 
1b4b			 
1b4b 7e				ld a,(hl) 
1b4c fe 22			cp '"' 
1b4e 28 0a			jr z, .fapstr 
1b50 fe 24			cp '$' 
1b52 ca 7a 1b			jp z, .faphex 
1b55 fe 25			cp '%' 
1b57 ca 62 1b			jp z, .fapbin 
1b5a			;	cp 'b' 
1b5a			;	jp z, .fabin 
1b5a				; else decimal 
1b5a			 
1b5a				; TODO do decimal conversion 
1b5a				; decimal is stored as a 16bit word 
1b5a			 
1b5a				; by default everything is a string if type is not detected 
1b5a			.fapstr: ; 
1b5a fe 22			cp '"' 
1b5c 20 01			jr nz, .strnoqu 
1b5e 23				inc hl 
1b5f			.strnoqu: 
1b5f c3 34 1a			jp forth_push_str 
1b62			 
1b62			 
1b62			 
1b62			.fapbin:    ; push a binary string.  
1b62 11 00 00			ld de, 0   ; hold a 16bit value 
1b65			 
1b65 23			.fapbinshift:	inc hl  
1b66 7e				ld a,(hl) 
1b67 fe 00			cp 0     ; done scanning  
1b69 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b6b			 
1b6b				; left shift de 
1b6b eb				ex de, hl	 
1b6c 29				add hl, hl 
1b6d			 
1b6d				; is 1 
1b6d fe 31			cp '1' 
1b6f 20 02			jr nz, .binzero 
1b71 cb 4d			bit 1, l 
1b73			.binzero: 
1b73 eb				ex de, hl	 ; save current de 
1b74 18 ef			jr .fapbinshift 
1b76			 
1b76			.fapbdone: 
1b76 eb				ex de, hl 
1b77 c3 c6 19			jp forth_push_numhl 
1b7a			 
1b7a			 
1b7a			.faphex:   ; hex is always stored as a 16bit word 
1b7a				; skip number prefix 
1b7a 23				inc hl 
1b7b				; turn ascii into number 
1b7b cd 7d 0f			call get_word_hl	; ret 16bit word in hl 
1b7e			 
1b7e c3 c6 19			jp forth_push_numhl 
1b81			 
1b81 00				 nop 
1b82			 
1b82			.fabin:   ; TODO bin conversion 
1b82			 
1b82			 
1b82 c9				ret 
1b83			 
1b83			 
1b83			; get either a string ptr or a 16bit word from the data stack 
1b83			 
1b83			FORTH_DSP: macro 
1b83				call macro_forth_dsp 
1b83				endm 
1b83			 
1b83			macro_forth_dsp: 
1b83				; data stack pointer points to current word on tos 
1b83			 
1b83 2a 0d eb			ld hl,(cli_data_sp) 
1b86			 
1b86				if DEBUG_FORTH_PUSH 
1b86						DMARK "DSP" 
1b86 f5				push af  
1b87 3a 9b 1b			ld a, (.dmark)  
1b8a 32 7a ee			ld (debug_mark),a  
1b8d 3a 9c 1b			ld a, (.dmark+1)  
1b90 32 7b ee			ld (debug_mark+1),a  
1b93 3a 9d 1b			ld a, (.dmark+2)  
1b96 32 7c ee			ld (debug_mark+2),a  
1b99 18 03			jr .pastdmark  
1b9b ..			.dmark: db "DSP"  
1b9e f1			.pastdmark: pop af  
1b9f			endm  
# End of macro DMARK
1b9f			 
1b9f cd 6a 45				call display_data_sp 
1ba2				;call break_point_state 
1ba2				;rst 030h 
1ba2				CALLMONITOR 
1ba2 cd 39 14			call break_point_state  
1ba5				endm  
# End of macro CALLMONITOR
1ba5				endif 
1ba5			 
1ba5 c9				ret 
1ba6			 
1ba6			; return hl to start of value on stack 
1ba6			 
1ba6			FORTH_DSP_VALUE: macro 
1ba6				call macro_forth_dsp_value 
1ba6				endm 
1ba6			 
1ba6			macro_forth_dsp_value: 
1ba6			 
1ba6				FORTH_DSP 
1ba6 cd 83 1b			call macro_forth_dsp 
1ba9				endm 
# End of macro FORTH_DSP
1ba9			 
1ba9 d5				push de 
1baa			 
1baa 23				inc hl ; skip type 
1bab			 
1bab 5e				ld e, (hl) 
1bac 23				inc hl 
1bad 56				ld d, (hl) 
1bae eb				ex de,hl  
1baf			 
1baf d1				pop de 
1bb0			 
1bb0 c9				ret 
1bb1			 
1bb1			; return hl to start of value to second item on stack 
1bb1			 
1bb1			FORTH_DSP_VALUEM1: macro 
1bb1				call macro_forth_dsp_value_m1 
1bb1				endm 
1bb1			 
1bb1			macro_forth_dsp_value_m1: 
1bb1			 
1bb1				FORTH_DSP 
1bb1 cd 83 1b			call macro_forth_dsp 
1bb4				endm 
# End of macro FORTH_DSP
1bb4			 
1bb4 2b				dec hl 
1bb5 2b				dec hl 
1bb6			;	dec hl 
1bb6			 
1bb6 d5				push de 
1bb7			 
1bb7 5e				ld e, (hl) 
1bb8 23				inc hl 
1bb9 56				ld d, (hl) 
1bba eb				ex de,hl  
1bbb			 
1bbb d1				pop de 
1bbc			 
1bbc c9				ret 
1bbd			 
1bbd				 
1bbd			 
1bbd			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bbd			 
1bbd			FORTH_DSP_POP: macro 
1bbd				call macro_forth_dsp_pop 
1bbd				endm 
1bbd			 
1bbd			 
1bbd			; get the tos data type 
1bbd			 
1bbd			FORTH_DSP_TYPE:   macro 
1bbd			 
1bbd				;FORTH_DSP_VALUE 
1bbd				FORTH_DSP 
1bbd				 
1bbd				; hl points to value 
1bbd				; check type 
1bbd			 
1bbd				ld a,(hl) 
1bbd			 
1bbd				endm 
1bbd			 
1bbd			; load the tos value into hl 
1bbd			 
1bbd			 
1bbd			FORTH_DSP_VALUEHL:  macro 
1bbd				call macro_dsp_valuehl 
1bbd				endm 
1bbd			 
1bbd			 
1bbd			 
1bbd			macro_dsp_valuehl: 
1bbd				FORTH_DSP_VALUE 
1bbd cd a6 1b			call macro_forth_dsp_value 
1bc0				endm 
# End of macro FORTH_DSP_VALUE
1bc0			 
1bc0				;FORTH_ERR_TOS_NOTNUM 
1bc0			 
1bc0				;inc hl   ; skip type id 
1bc0			 
1bc0			;	push de 
1bc0			; 
1bc0			;	ld e, (hl) 
1bc0			;	inc hl 
1bc0			;	ld d, (hl) 
1bc0			;	ex de,hl  
1bc0			 
1bc0			;	pop de 
1bc0			 
1bc0				if DEBUG_FORTH_PUSH 
1bc0						DMARK "DVL" 
1bc0 f5				push af  
1bc1 3a d5 1b			ld a, (.dmark)  
1bc4 32 7a ee			ld (debug_mark),a  
1bc7 3a d6 1b			ld a, (.dmark+1)  
1bca 32 7b ee			ld (debug_mark+1),a  
1bcd 3a d7 1b			ld a, (.dmark+2)  
1bd0 32 7c ee			ld (debug_mark+2),a  
1bd3 18 03			jr .pastdmark  
1bd5 ..			.dmark: db "DVL"  
1bd8 f1			.pastdmark: pop af  
1bd9			endm  
# End of macro DMARK
1bd9				CALLMONITOR 
1bd9 cd 39 14			call break_point_state  
1bdc				endm  
# End of macro CALLMONITOR
1bdc				endif 
1bdc c9				ret 
1bdd			 
1bdd			forth_apushstrhl:      
1bdd				; push of string requires use of cli_origptr 
1bdd				; bodge use 
1bdd			 
1bdd				; get current cli_origptr, save, update with temp pointer  
1bdd ed 5b 29 eb		ld de, (cli_origptr) 
1be1 22 29 eb			ld (cli_origptr), hl 
1be4 d5				push de 
1be5 cd 2f 1b			call forth_apush 
1be8 d1				pop de 
1be9 ed 53 29 eb		ld (cli_origptr), de 
1bed c9			        ret	 
1bee			 
1bee			 
1bee			; increase loop stack pointer and save hl to it 
1bee				 
1bee			FORTH_LOOP_NEXT: macro 
1bee				call macro_forth_loop_next 
1bee				;nop 
1bee				endm 
1bee			 
1bee			macro_forth_loop_next: 
1bee				if DEBUG_FORTH_STACK_GUARD 
1bee cd cf 55				call check_stacks 
1bf1				endif 
1bf1 e5				push hl 
1bf2 d5				push de 
1bf3 eb				ex de,hl 
1bf4 2a 0f eb			ld hl,(cli_loop_sp) 
1bf7 23				inc hl 
1bf8 23				inc hl 
1bf9					if DEBUG_FORTH_WORDS 
1bf9						DMARK "LNX" 
1bf9 f5				push af  
1bfa 3a 0e 1c			ld a, (.dmark)  
1bfd 32 7a ee			ld (debug_mark),a  
1c00 3a 0f 1c			ld a, (.dmark+1)  
1c03 32 7b ee			ld (debug_mark+1),a  
1c06 3a 10 1c			ld a, (.dmark+2)  
1c09 32 7c ee			ld (debug_mark+2),a  
1c0c 18 03			jr .pastdmark  
1c0e ..			.dmark: db "LNX"  
1c11 f1			.pastdmark: pop af  
1c12			endm  
# End of macro DMARK
1c12						CALLMONITOR 
1c12 cd 39 14			call break_point_state  
1c15				endm  
# End of macro CALLMONITOR
1c15					endif 
1c15 22 0f eb			ld (cli_loop_sp),hl 
1c18 73				ld (hl), e 
1c19 23				inc hl 
1c1a 72				ld (hl), d 
1c1b d1				pop de    ; been reversed so save a swap on restore 
1c1c e1				pop hl 
1c1d				if DEBUG_FORTH_STACK_GUARD 
1c1d cd cf 55				call check_stacks 
1c20				endif 
1c20 c9				ret 
1c21			 
1c21			; get current ret stack pointer and save to hl  
1c21				 
1c21			FORTH_LOOP_TOS: macro 
1c21				call macro_forth_loop_tos 
1c21				endm 
1c21			 
1c21			macro_forth_loop_tos: 
1c21 d5				push de 
1c22 2a 0f eb			ld hl,(cli_loop_sp) 
1c25 5e				ld e, (hl) 
1c26 23				inc hl 
1c27 56				ld d, (hl) 
1c28 eb				ex de, hl 
1c29 d1				pop de 
1c2a c9				ret 
1c2b			 
1c2b			; pop loop stack pointer 
1c2b				 
1c2b			FORTH_LOOP_POP: macro 
1c2b				call macro_forth_loop_pop 
1c2b				endm 
1c2b			 
1c2b			 
1c2b			macro_forth_loop_pop: 
1c2b				if DEBUG_FORTH_STACK_GUARD 
1c2b					DMARK "LPP" 
1c2b f5				push af  
1c2c 3a 40 1c			ld a, (.dmark)  
1c2f 32 7a ee			ld (debug_mark),a  
1c32 3a 41 1c			ld a, (.dmark+1)  
1c35 32 7b ee			ld (debug_mark+1),a  
1c38 3a 42 1c			ld a, (.dmark+2)  
1c3b 32 7c ee			ld (debug_mark+2),a  
1c3e 18 03			jr .pastdmark  
1c40 ..			.dmark: db "LPP"  
1c43 f1			.pastdmark: pop af  
1c44			endm  
# End of macro DMARK
1c44 cd cf 55				call check_stacks 
1c47					FORTH_CHK_LOOP_UNDER 
1c47 e5				push hl 
1c48 d5				push de 
1c49 2a 0f eb			ld hl,(cli_loop_sp) 
1c4c 11 c9 e9			ld de, cli_loop_stack 
1c4f cd e4 0b			call cmp16 
1c52 da e9 56			jp c, fault_loop_under 
1c55 d1				pop de 
1c56 e1				pop hl 
1c57				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c57				endif 
1c57 e5				push hl 
1c58 2a 0f eb			ld hl,(cli_loop_sp) 
1c5b 2b				dec hl 
1c5c 2b				dec hl 
1c5d 22 0f eb			ld (cli_loop_sp), hl 
1c60				; TODO do stack underflow checks 
1c60 e1				pop hl 
1c61				if DEBUG_FORTH_STACK_GUARD 
1c61 cd cf 55				call check_stacks 
1c64					FORTH_CHK_LOOP_UNDER 
1c64 e5				push hl 
1c65 d5				push de 
1c66 2a 0f eb			ld hl,(cli_loop_sp) 
1c69 11 c9 e9			ld de, cli_loop_stack 
1c6c cd e4 0b			call cmp16 
1c6f da e9 56			jp c, fault_loop_under 
1c72 d1				pop de 
1c73 e1				pop hl 
1c74				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c74				endif 
1c74 c9				ret 
1c75			 
1c75			macro_forth_dsp_pop: 
1c75			 
1c75 e5				push hl 
1c76			 
1c76				; release malloc data 
1c76			 
1c76				if DEBUG_FORTH_STACK_GUARD 
1c76 cd cf 55				call check_stacks 
1c79					FORTH_CHK_DSP_UNDER 
1c79 e5				push hl 
1c7a d5				push de 
1c7b 2a 0d eb			ld hl,(cli_data_sp) 
1c7e 11 c7 e8			ld de, cli_data_stack 
1c81 cd e4 0b			call cmp16 
1c84 da dd 56			jp c, fault_dsp_under 
1c87 d1				pop de 
1c88 e1				pop hl 
1c89				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c89				endif 
1c89				;ld hl,(cli_data_sp) 
1c89			if DEBUG_FORTH_DOT 
1c89				DMARK "DPP" 
1c89				CALLMONITOR 
1c89			endif	 
1c89			 
1c89			 
1c89			if FORTH_ENABLE_DSPPOPFREE 
1c89			 
1c89				FORTH_DSP 
1c89 cd 83 1b			call macro_forth_dsp 
1c8c				endm 
# End of macro FORTH_DSP
1c8c			 
1c8c 7e				ld a, (hl) 
1c8d fe 01			cp DS_TYPE_STR 
1c8f 20 07			jr nz, .skippopfree 
1c91			 
1c91				FORTH_DSP_VALUEHL 
1c91 cd bd 1b			call macro_dsp_valuehl 
1c94				endm 
# End of macro FORTH_DSP_VALUEHL
1c94 00				nop 
1c95			if DEBUG_FORTH_DOT 
1c95				DMARK "DPf" 
1c95				CALLMONITOR 
1c95			endif	 
1c95 cd 57 11			call free 
1c98			.skippopfree: 
1c98				 
1c98			 
1c98			endif 
1c98			 
1c98			if DEBUG_FORTH_DOT_KEY 
1c98				DMARK "DP2" 
1c98				CALLMONITOR 
1c98			endif	 
1c98			 
1c98				; move pointer down 
1c98			 
1c98 2a 0d eb			ld hl,(cli_data_sp) 
1c9b 2b				dec hl 
1c9c 2b				dec hl 
1c9d			; PARSEV5 
1c9d 2b				dec hl 
1c9e 22 0d eb			ld (cli_data_sp), hl 
1ca1			 
1ca1				if DEBUG_FORTH_STACK_GUARD 
1ca1 cd cf 55				call check_stacks 
1ca4					FORTH_CHK_DSP_UNDER 
1ca4 e5				push hl 
1ca5 d5				push de 
1ca6 2a 0d eb			ld hl,(cli_data_sp) 
1ca9 11 c7 e8			ld de, cli_data_stack 
1cac cd e4 0b			call cmp16 
1caf da dd 56			jp c, fault_dsp_under 
1cb2 d1				pop de 
1cb3 e1				pop hl 
1cb4				endm 
# End of macro FORTH_CHK_DSP_UNDER
1cb4				endif 
1cb4			 
1cb4 e1				pop hl 
1cb5			 
1cb5 c9				ret 
1cb6			 
1cb6			getwordathl: 
1cb6				; hl points to an address 
1cb6				; load hl with the word at that address 
1cb6			 
1cb6 d5				push de 
1cb7			 
1cb7 5e				ld e, (hl) 
1cb8 23				inc hl 
1cb9 56				ld d, (hl) 
1cba eb				ex de, hl 
1cbb			 
1cbb d1				pop de 
1cbc c9				ret 
1cbd			 
1cbd			 
1cbd			 
1cbd			 
1cbd			 
1cbd			; eof 
1cbd			 
# End of file forth_stackopsv5.asm
1cbd			endif 
1cbd			 
1cbd			user_word_eol:  
1cbd				; hl contains the pointer to where to create a linked list item from the end 
1cbd				; of the user dict to continue on at the system word dict 
1cbd				 
1cbd				; poke the stub of the word list linked list to repoint to rom words 
1cbd			 
1cbd				; stub format 
1cbd				; db   word id 
1cbd				; dw    link to next word 
1cbd			        ; db char length of token 
1cbd				; db string + 0 term 
1cbd				; db exec code....  
1cbd			 
1cbd 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1cbf 77				ld (hl), a		; word id 
1cc0 23				inc hl 
1cc1			 
1cc1 11 87 1e			ld de, sysdict 
1cc4 73				ld (hl), e		; next word link ie system dict 
1cc5 23				inc hl 
1cc6 72				ld (hl), d		; next word link ie system dict 
1cc7 23				inc hl	 
1cc8			 
1cc8			;	ld (hl), sysdict		; next word link ie system dict 
1cc8			;	inc hl 
1cc8			;	inc hl 
1cc8			 
1cc8			;	inc hl 
1cc8			;	inc hl 
1cc8			 
1cc8 3e 02			ld a, 2			; word length is 0 
1cca 77				ld (hl), a	 
1ccb 23				inc hl 
1ccc			 
1ccc 3e 7e			ld a, '~'			; word length is 0 
1cce 77				ld (hl), a	 
1ccf 23				inc hl 
1cd0 3e 00			ld a, 0			; save empty word 
1cd2 77				ld (hl), a 
1cd3			 
1cd3 c9				ret 
1cd4			 
1cd4				 
1cd4			 
1cd4			forthexec_cleanup: 
1cd4				FORTH_RSP_POP 
1cd4 cd 8e 19			call macro_forth_rsp_pop 
1cd7				endm 
# End of macro FORTH_RSP_POP
1cd7 c9				ret 
1cd8			 
1cd8			forth_call_hl: 
1cd8				; taking hl 
1cd8 e5				push hl 
1cd9 c9				ret 
1cda			 
1cda			; this is called to reset Forth system but keep existing uwords etc 
1cda			 
1cda			forth_warmstart: 
1cda				; setup stack over/under flow checks 
1cda				if DEBUG_FORTH_STACK_GUARD 
1cda cd b5 55				call chk_stk_init 
1cdd				endif 
1cdd			 
1cdd				; init stack pointers  - * these stacks go upwards *  
1cdd 21 cb ea			ld hl, cli_ret_stack 
1ce0 22 11 eb			ld (cli_ret_sp), hl	 
1ce3				; set bottom of stack 
1ce3 3e 00			ld a,0 
1ce5 77				ld (hl),a 
1ce6 23				inc hl 
1ce7 77				ld (hl),a 
1ce8			 
1ce8 21 c7 e8			ld hl, cli_data_stack 
1ceb 22 0d eb			ld (cli_data_sp), hl	 
1cee				; set bottom of stack 
1cee 3e 00			ld a,0 
1cf0 77				ld (hl),a 
1cf1 23				inc hl 
1cf2 77				ld (hl),a 
1cf3			 
1cf3 21 c9 e9			ld hl, cli_loop_stack 
1cf6 22 0f eb			ld (cli_loop_sp), hl	 
1cf9				; set bottom of stack 
1cf9 3e 00			ld a,0 
1cfb 77				ld (hl),a 
1cfc 23				inc hl 
1cfd 77				ld (hl),a 
1cfe			 
1cfe				; init extent of current open file 
1cfe			 
1cfe 3e 00			ld a, 0 
1d00 32 5c eb			ld (store_openext), a 
1d03			 
1d03 c9				ret 
1d04			 
1d04			 
1d04			; Cold Start - this is called to setup the whole Forth system 
1d04			 
1d04			forth_init: 
1d04			 
1d04				; setup stack over/under flow checks 
1d04			 
1d04			;	if DEBUG_FORTH_STACK_GUARD 
1d04			;		call chk_stk_init 
1d04			;	endif 
1d04			 
1d04				; enable auto display updates (slow.....) 
1d04			 
1d04 3e 01			ld a, 1 
1d06 32 27 eb			ld (cli_autodisplay), a 
1d09			 
1d09			 
1d09			 
1d09				; show start up screen 
1d09			 
1d09 cd 99 09			call clear_display 
1d0c			 
1d0c 3e 00			ld a,0 
1d0e 32 49 eb			ld (f_cursor_ptr), a 
1d11			 
1d11				; set start of word list in start of ram - for use when creating user words 
1d11			 
1d11 21 d8 58			ld hl, baseram 
1d14 22 5d e6			ld (os_last_new_uword), hl 
1d17 cd bd 1c			call user_word_eol 
1d1a				 
1d1a			;		call display_data_sp 
1d1a			;		call next_page_prompt 
1d1a			 
1d1a			 
1d1a			 
1d1a			 
1d1a c9				ret 
1d1b			 
1d1b .. 00		.bootforth: db " Forth Kernel Init ",0 
1d2f			 
1d2f			; TODO push to stack 
1d2f			 
1d2f			;  
1d2f			 
1d2f			if FORTH_PARSEV2 
1d2f			 
1d2f			 
1d2f				include "forth_parserv2.asm" 
1d2f			 
1d2f			endif 
1d2f			 
1d2f			 
1d2f			; parse cli version 1 
1d2f			 
1d2f			if FORTH_PARSEV1 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv1.asm" 
1d2f			endif 
1d2f				 
1d2f			if FORTH_PARSEV3 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv3.asm" 
1d2f				include "forth_wordsv3.asm" 
1d2f			endif 
1d2f			 
1d2f			if FORTH_PARSEV4 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv4.asm" 
1d2f				include "forth_wordsv4.asm" 
1d2f			endif 
1d2f			 
1d2f			if FORTH_PARSEV5 
1d2f			 
1d2f			 
1d2f			 
1d2f			      include "forth_parserv5.asm" 
1d2f			 
1d2f			 
1d2f			; A better parser without using malloc and string copies all over the place.  
1d2f			; Exec in situ should be faster 
1d2f			 
1d2f			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d2f			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d2f			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d2f			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d2f			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d2f			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d2f			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d2f			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d2f			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d2f			 
1d2f			; Core word preamble macro 
1d2f			 
1d2f			CWHEAD:   macro nxtword opcode lit len opflags 
1d2f				db WORD_SYS_CORE+opcode             
1d2f				; internal op code number 
1d2f				dw nxtword            
1d2f				; link to next dict word block 
1d2f				db len + 1 
1d2f				; literal length of dict word inc zero term 
1d2f				db lit,0              
1d2f				; literal dict word 
1d2f			        ; TODO db opflags        
1d2f				endm 
1d2f			 
1d2f			 
1d2f			NEXTW: macro  
1d2f				jp macro_next 
1d2f				endm 
1d2f			 
1d2f			macro_next: 
1d2f			if DEBUG_FORTH_PARSE_KEY 
1d2f				DMARK "NXT" 
1d2f				CALLMONITOR 
1d2f			endif	 
1d2f			;	inc hl  ; skip token null term  
1d2f ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d33 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d37 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d3a			if DEBUG_FORTH_PARSE_KEY 
1d3a				DMARK "}AA" 
1d3a				CALLMONITOR 
1d3a			endif	 
1d3a c3 3d 1e			jp execnext 
1d3d				;jp exec1 
1d3d			       
1d3d			 
1d3d			 
1d3d			; Another go at the parser to compile  
1d3d			 
1d3d			 
1d3d			; TODO rework parser to change all of the string words to byte tokens 
1d3d			; TODO do a search for  
1d3d			 
1d3d			; TODO first run normal parser to zero term sections 
1d3d			; TODO for each word do a token look up to get the op code 
1d3d			; TODO need some means to flag to the exec that this is a byte code form    
1d3d			 
1d3d			 
1d3d			forthcompile: 
1d3d			 
1d3d			; 
1d3d			; line parse: 
1d3d			;       parse raw input buffer 
1d3d			;       tokenise the words 
1d3d			;       malloc new copy (for looping etc) 
1d3d			;       copy to malloc + current pc in line to start of string and add line term 
1d3d			;       save on new rsp 
1d3d			; 
1d3d			 
1d3d			; hl to point to the line to tokenise 
1d3d			 
1d3d			;	push hl 
1d3d 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d40			 
1d40			;	ld a,0		; string term on input 
1d40			;	call strlent 
1d40			 
1d40			;	ld (os_tok_len), hl	 ; save string length 
1d40			 
1d40			;if DEBUG_FORTH_TOK 
1d40			;	ex de,hl		 
1d40			;endif 
1d40			 
1d40			;	pop hl 		; get back string pointer 
1d40			 
1d40			if DEBUG_FORTH_TOK 
1d40						DMARK "TOc" 
1d40				CALLMONITOR 
1d40			endif 
1d40 7e			.cptoken2:    ld a,(hl) 
1d41 23				inc hl 
1d42 fe 7f			cp FORTH_END_BUFFER 
1d44 28 29			jr z, .cptokendone2 
1d46 fe 00			cp 0 
1d48 28 25			jr z, .cptokendone2 
1d4a fe 22			cp '"' 
1d4c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d4e fe 20			cp ' ' 
1d50 20 ee			jr nz,  .cptoken2 
1d52			 
1d52			; TODO consume comments held between ( and ) 
1d52			 
1d52				; we have a space so change to zero term for dict match later 
1d52 2b				dec hl 
1d53 3e 00			ld a,0 
1d55 77				ld (hl), a 
1d56 23				inc hl 
1d57 18 e7			jr .cptoken2 
1d59				 
1d59			 
1d59			.cptokenstr2: 
1d59				; skip all white space until either eol (because forgot to term) or end double quote 
1d59			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d59				;inc hl ; skip current double quote 
1d59 7e				ld a,(hl) 
1d5a 23				inc hl 
1d5b fe 22			cp '"' 
1d5d 28 e1			jr z, .cptoken2 
1d5f fe 7f			cp FORTH_END_BUFFER 
1d61 28 0c			jr z, .cptokendone2 
1d63 fe 00			cp 0 
1d65 28 08			jr z, .cptokendone2 
1d67 fe 20			cp ' ' 
1d69 28 02			jr z, .cptmp2 
1d6b 18 ec			jr .cptokenstr2 
1d6d			 
1d6d			.cptmp2:	; we have a space so change to zero term for dict match later 
1d6d				;dec hl 
1d6d				;ld a,"-"	; TODO remove this when working 
1d6d				;ld (hl), a 
1d6d				;inc hl 
1d6d 18 ea			jr .cptokenstr2 
1d6f			 
1d6f			.cptokendone2: 
1d6f				;inc hl 
1d6f 3e 7f			ld a, FORTH_END_BUFFER 
1d71 77				ld (hl),a 
1d72 23				inc hl 
1d73 3e 21			ld a, '!' 
1d75 77				ld (hl),a 
1d76			 
1d76 2a 61 e6			ld hl,(os_tok_ptr) 
1d79			         
1d79			if DEBUG_FORTH_TOK 
1d79						DMARK "Tc1" 
1d79				CALLMONITOR 
1d79			endif 
1d79			 
1d79				; push exec string to top of return stack 
1d79				FORTH_RSP_NEXT 
1d79 cd 6d 19			call macro_forth_rsp_next 
1d7c				endm 
# End of macro FORTH_RSP_NEXT
1d7c c9				ret 
1d7d			 
1d7d			; Another go at the parser need to simplify the process 
1d7d			 
1d7d			forthparse: 
1d7d			 
1d7d			; 
1d7d			; line parse: 
1d7d			;       parse raw input buffer 
1d7d			;       tokenise the words 
1d7d			;       malloc new copy (for looping etc) 
1d7d			;       copy to malloc + current pc in line to start of string and add line term 
1d7d			;       save on new rsp 
1d7d			; 
1d7d			 
1d7d			; hl to point to the line to tokenise 
1d7d			 
1d7d			;	push hl 
1d7d 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d80			 
1d80			;	ld a,0		; string term on input 
1d80			;	call strlent 
1d80			 
1d80			;	ld (os_tok_len), hl	 ; save string length 
1d80			 
1d80			;if DEBUG_FORTH_TOK 
1d80			;	ex de,hl		 
1d80			;endif 
1d80			 
1d80			;	pop hl 		; get back string pointer 
1d80			 
1d80			if DEBUG_FORTH_TOK 
1d80						DMARK "TOK" 
1d80				CALLMONITOR 
1d80			endif 
1d80 7e			.ptoken2:    ld a,(hl) 
1d81 23				inc hl 
1d82 fe 7f			cp FORTH_END_BUFFER 
1d84 28 29			jr z, .ptokendone2 
1d86 fe 00			cp 0 
1d88 28 25			jr z, .ptokendone2 
1d8a fe 22			cp '"' 
1d8c 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d8e fe 20			cp ' ' 
1d90 20 ee			jr nz,  .ptoken2 
1d92			 
1d92			; TODO consume comments held between ( and ) 
1d92			 
1d92				; we have a space so change to zero term for dict match later 
1d92 2b				dec hl 
1d93 3e 00			ld a,0 
1d95 77				ld (hl), a 
1d96 23				inc hl 
1d97 18 e7			jr .ptoken2 
1d99				 
1d99			 
1d99			.ptokenstr2: 
1d99				; skip all white space until either eol (because forgot to term) or end double quote 
1d99			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d99				;inc hl ; skip current double quote 
1d99 7e				ld a,(hl) 
1d9a 23				inc hl 
1d9b fe 22			cp '"' 
1d9d 28 e1			jr z, .ptoken2 
1d9f fe 7f			cp FORTH_END_BUFFER 
1da1 28 0c			jr z, .ptokendone2 
1da3 fe 00			cp 0 
1da5 28 08			jr z, .ptokendone2 
1da7 fe 20			cp ' ' 
1da9 28 02			jr z, .ptmp2 
1dab 18 ec			jr .ptokenstr2 
1dad			 
1dad			.ptmp2:	; we have a space so change to zero term for dict match later 
1dad				;dec hl 
1dad				;ld a,"-"	; TODO remove this when working 
1dad				;ld (hl), a 
1dad				;inc hl 
1dad 18 ea			jr .ptokenstr2 
1daf			 
1daf			.ptokendone2: 
1daf				;inc hl 
1daf 3e 7f			ld a, FORTH_END_BUFFER 
1db1 77				ld (hl),a 
1db2 23				inc hl 
1db3 3e 21			ld a, '!' 
1db5 77				ld (hl),a 
1db6			 
1db6 2a 61 e6			ld hl,(os_tok_ptr) 
1db9			         
1db9			if DEBUG_FORTH_TOK 
1db9						DMARK "TK1" 
1db9				CALLMONITOR 
1db9			endif 
1db9			 
1db9				; push exec string to top of return stack 
1db9				FORTH_RSP_NEXT 
1db9 cd 6d 19			call macro_forth_rsp_next 
1dbc				endm 
# End of macro FORTH_RSP_NEXT
1dbc c9				ret 
1dbd			 
1dbd			; 
1dbd			;	; malloc size + buffer pointer + if is loop flag 
1dbd			;	ld hl,(os_tok_len) 		 ; get string length 
1dbd			; 
1dbd			;	ld a,l 
1dbd			; 
1dbd			;	cp 0			; we dont want to use a null string 
1dbd			;	ret z 
1dbd			; 
1dbd			;;	add 3    ; prefix malloc with buffer for current word ptr 
1dbd			; 
1dbd			;	add 5     ; TODO when certain not over writing memory remove 
1dbd			; 
1dbd			;		 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKE" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	ld l,a 
1dbd			;	ld h,0 
1dbd			;;	push hl   ; save required space for the copy later 
1dbd			;	call malloc 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKM" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			;	if DEBUG_FORTH_MALLOC_GUARD 
1dbd			;		push af 
1dbd			;		call ishlzero 
1dbd			;;		ld a, l 
1dbd			;;		add h 
1dbd			;;		cp 0 
1dbd			;		pop af 
1dbd			;		 
1dbd			;		call z,malloc_error 
1dbd			;	endif 
1dbd			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1dbd			; 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKR" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	FORTH_RSP_NEXT 
1dbd			; 
1dbd			;	;inc hl	 ; go past current buffer pointer 
1dbd			;	;inc hl 
1dbd			;	;inc hl   ; and past if loop flag 
1dbd			;		; TODO Need to set flag  
1dbd			; 
1dbd			;	 
1dbd			;	 
1dbd			;	ex de,hl	; malloc is dest 
1dbd			;	ld hl, (os_tok_len) 
1dbd			;;	pop bc 
1dbd			;	ld c, l                
1dbd			;	ld b,0 
1dbd			;	ld hl, (os_tok_ptr) 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			;			DMARK "TKT" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	; do str cpy 
1dbd			; 
1dbd			;	ldir      ; copy byte in hl to de 
1dbd			; 
1dbd			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1dbd			; 
1dbd			;if DEBUG_FORTH_TOK 
1dbd			; 
1dbd			;			DMARK "TKY" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			;	;ld a,0 
1dbd			;	;ld a,FORTH_END_BUFFER 
1dbd			;	ex de, hl 
1dbd			;	;dec hl			 ; go back over the space delim at the end of word 
1dbd			;	;ld (hl),a 
1dbd			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1dbd			;	ld a,FORTH_END_BUFFER 
1dbd			;	ld (hl),a 
1dbd			;	inc hl 
1dbd			;	ld a,FORTH_END_BUFFER 
1dbd			;	ld (hl),a 
1dbd			; 
1dbd			;	; init the malloc area data 
1dbd			;	; set pc for in current area 
1dbd			;	;ld hl, (os_tok_malloc) 
1dbd			;	;inc hl 
1dbd			;	;inc hl 
1dbd			;	;inc hl 
1dbd			;	;ex de,hl 
1dbd			;	;ld hl, (os_tok_malloc) 
1dbd			;	;ld (hl),e 
1dbd			;	;inc hl 
1dbd			;	;ld (hl),d 
1dbd			; 
1dbd			; 
1dbd			;	ld hl,(os_tok_malloc) 
1dbd			;if DEBUG_FORTH_PARSE_KEY 
1dbd			;			DMARK "TKU" 
1dbd			;	CALLMONITOR 
1dbd			;endif 
1dbd			; 
1dbd			;	ret 
1dbd			 
1dbd			forthexec: 
1dbd			 
1dbd			; line exec: 
1dbd			; forth parser 
1dbd			 
1dbd			; 
1dbd			;       get current exec line on rsp 
1dbd			 
1dbd				FORTH_RSP_TOS 
1dbd cd 84 19			call macro_forth_rsp_tos 
1dc0				endm 
# End of macro FORTH_RSP_TOS
1dc0			 
1dc0			;       restore current pc - hl points to malloc of data 
1dc0			 
1dc0				;ld e, (hl) 
1dc0				;inc hl 
1dc0				;ld d, (hl) 
1dc0				;ex de,hl 
1dc0			 
1dc0			 
1dc0			exec1: 
1dc0 22 61 e6			ld (os_tok_ptr), hl 
1dc3			 
1dc3				; copy our PC to working vars  
1dc3 22 2b eb			ld (cli_ptr), hl 
1dc6 22 29 eb			ld (cli_origptr), hl 
1dc9			 
1dc9 7e				ld a,(hl) 
1dca fe 7f			cp FORTH_END_BUFFER 
1dcc c8				ret z 
1dcd			 
1dcd				; skip any nulls 
1dcd			 
1dcd fe 00			cp 0 
1dcf 20 03			jr nz, .execword 
1dd1 23				inc hl 
1dd2 18 ec			jr exec1 
1dd4			 
1dd4			 
1dd4			.execword: 
1dd4			 
1dd4			 
1dd4			 
1dd4			if DEBUG_FORTH_PARSE_KEY 
1dd4						DMARK "KYQ" 
1dd4				CALLMONITOR 
1dd4			endif 
1dd4			;       while at start of word: 
1dd4			; get start of dict (in user area first) 
1dd4			 
1dd4 21 d8 58		ld hl, baseram 
1dd7			;ld hl, sysdict 
1dd7 22 2d eb		ld (cli_nextword),hl 
1dda			;           match word at pc 
1dda			;           exec word 
1dda			;           or push to dsp 
1dda			;           forward to next token 
1dda			;           if line term pop rsp and exit 
1dda			;        
1dda			 
1dda			if DEBUG_FORTH_PARSE_KEY 
1dda						DMARK "KYq" 
1dda				CALLMONITOR 
1dda			endif 
1dda			 
1dda			; 
1dda			; word comp 
1dda			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1dda			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1dda			;    move to start of word  
1dda			;    compare word to cli_token 
1dda			 
1dda			.execpnword:	; HL at start of a word in the dictionary to check 
1dda			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1dda			;	ld (cli_ptr), hl 
1dda			 
1dda 2a 2d eb			ld hl,(cli_nextword) 
1ddd			 
1ddd cd 80 1e			call forth_tok_next 
1de0			; tok next start here 
1de0			;	; TODO skip compiled symbol for now 
1de0			;	inc hl 
1de0			; 
1de0			;	; save pointer to next word 
1de0			; 
1de0			;	; hl now points to the address of the next word pointer  
1de0			;	ld e, (hl) 
1de0			;	inc hl 
1de0			;	ld d, (hl) 
1de0			;	inc l 
1de0			; 
1de0			;	ex de,hl 
1de0			;if DEBUG_FORTH_PARSE_NEXTWORD 
1de0			;	push bc 
1de0			;	ld bc, (cli_nextword) 
1de0			;			DMARK "NXW" 
1de0			;	CALLMONITOR 
1de0			;	pop bc 
1de0			;endif 
1de0			; tok next end here 
1de0 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1de3 eb				ex de, hl 
1de4			 
1de4			 
1de4				; save the pointer of the current token - 1 to check against 
1de4				 
1de4 22 31 eb			ld (cli_token), hl   
1de7				; TODO maybe remove below save if no debug 
1de7				; save token string ptr for any debug later 
1de7 23				inc hl  
1de8 22 33 eb			ld (cli_origtoken), hl 
1deb 2b				dec hl 
1dec				; save pointer to the start of the next dictionay word 
1dec 7e				ld a,(hl)   ; get string length 
1ded 47				ld b,a 
1dee			.execpnwordinc:  
1dee 23				inc hl 
1def 10 fd			djnz .execpnwordinc 
1df1 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1df4			 
1df4				; now check the word token against the string being parsed 
1df4			 
1df4 2a 31 eb			ld hl,(cli_token) 
1df7 23				inc hl     ; skip string length (use zero term instead to end) 
1df8 22 31 eb			ld (cli_token), hl 
1dfb			 
1dfb			if DEBUG_FORTH_PARSE_KEY 
1dfb						DMARK "KY2" 
1dfb			endif 
1dfb			if DEBUG_FORTH_PARSE_EXEC 
1dfb				; see if disabled 
1dfb			 
1dfb				ld a, (os_view_disable) 
1dfb				cp '*' 
1dfb				jr z, .skip 
1dfb			 
1dfb				push hl 
1dfb				push hl 
1dfb				call clear_display 
1dfb				ld de, .compword 
1dfb				ld a, display_row_1 
1dfb				call str_at_display 
1dfb				pop de 
1dfb				ld a, display_row_2 
1dfb				call str_at_display 
1dfb				ld hl,(cli_ptr) 
1dfb				ld a,(hl) 
1dfb			        ld hl, os_word_scratch 
1dfb				ld (hl),a 
1dfb				ld a,0 
1dfb				inc hl 
1dfb				ld (hl),a 	 
1dfb				ld de, os_word_scratch 
1dfb				ld a, display_row_2+10 
1dfb				call str_at_display 
1dfb				call update_display 
1dfb				ld a, 100 
1dfb				call aDelayInMS 
1dfb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dfb				call delay250ms 
1dfb				endif 
1dfb				pop hl 
1dfb			.skip:  
1dfb			endif	 
1dfb			.execpnchar:    ; compare char between token and string to parse 
1dfb			 
1dfb			if DEBUG_FORTH_PARSE_KEY 
1dfb						DMARK "Ky3" 
1dfb			endif 
1dfb			if DEBUG_FORTH_PARSE_EXEC 
1dfb				; see if disabled 
1dfb			 
1dfb				ld a, (os_view_disable) 
1dfb				cp '*' 
1dfb				jr z, .skip2 
1dfb			 
1dfb			;	call clear_display 
1dfb			ld hl,(cli_token) 
1dfb			ld a,(hl) 
1dfb			ld (os_word_scratch),a 
1dfb				ld hl,(cli_ptr) 
1dfb			ld a,(hl) 
1dfb				ld (os_word_scratch+1),a 
1dfb				ld a,0 
1dfb				ld (os_word_scratch+2),a 
1dfb				ld de,os_word_scratch 
1dfb				ld a,display_row_4 
1dfb				call str_at_display 
1dfb				call update_display 
1dfb			.skip2:  
1dfb			endif 
1dfb 2a 31 eb			ld hl,(cli_token) 
1dfe 7e				ld a, (hl)	 ; char in word token 
1dff 23				inc hl 		; move to next char 
1e00 22 31 eb			ld (cli_token), hl ; and save it 
1e03 47				ld b,a 
1e04			 
1e04 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1e07 7e				ld a,(hl) 
1e08 23				inc hl 
1e09 22 2b eb			ld (cli_ptr), hl		; move to next char 
1e0c cd 1b 10			call toUpper 		; make sure the input string matches case 
1e0f			 
1e0f			if DEBUG_FORTH_PARSE 
1e0f			endif 
1e0f			 
1e0f				; input stream end of token is a space so get rid of it 
1e0f			 
1e0f			;	cp ' ' 
1e0f			;	jr nz, .pnskipspace 
1e0f			; 
1e0f			;	ld a, 0		; make same term as word token term 
1e0f			; 
1e0f			;.pnskipspace: 
1e0f			 
1e0f			if DEBUG_FORTH_PARSE_KEY 
1e0f						DMARK "KY7" 
1e0f			endif 
1e0f b8				cp b 
1e10 c2 26 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e13				 
1e13			;    if same 
1e13			;       scan for string terms 0 for token and 32 for input 
1e13			 
1e13				 
1e13			if DEBUG_FORTH_PARSE_KEY 
1e13						DMARK "KY8" 
1e13			endif 
1e13			 
1e13 80				add b			 
1e14 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e16							; TODO need to make sure last word in zero term string is accounted for 
1e16 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e18			 
1e18			 
1e18				; at end of both strings so both are exact match 
1e18			 
1e18			;       skip ptr for next word 
1e18			 
1e18 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1e1b 23				inc hl			 ; at next char 
1e1c 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e1f 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e22				 
1e22				 
1e22			if DEBUG_FORTH_PARSE_KEY 
1e22						DMARK "KY3" 
1e22			endif 
1e22			 
1e22			 
1e22			 
1e22			;       exec code block 
1e22			if DEBUG_FORTH_JP 
1e22				call clear_display 
1e22				call update_display 
1e22				call delay1s 
1e22				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e22				ld a,h 
1e22				ld hl, os_word_scratch 
1e22				call hexout 
1e22				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e22				ld a,l 
1e22				ld hl, os_word_scratch+2 
1e22				call hexout 
1e22				ld hl, os_word_scratch+4 
1e22				ld a,0 
1e22				ld (hl),a 
1e22				ld de,os_word_scratch 
1e22				call str_at_display 
1e22					ld a, display_row_2 
1e22					call str_at_display 
1e22				ld de, (cli_origtoken) 
1e22				ld a, display_row_1+10 
1e22					call str_at_display 
1e22			 
1e22				ld a,display_row_1 
1e22				ld de, .foundword 
1e22				ld a, display_row_3 
1e22				call str_at_display 
1e22				call update_display 
1e22				call delay1s 
1e22				call delay1s 
1e22				call delay1s 
1e22			endif 
1e22			 
1e22			if DEBUG_FORTH_PARSE_KEY 
1e22						DMARK "KYj" 
1e22			endif 
1e22				; TODO save the word pointer in this exec 
1e22			 
1e22 2a 2f eb			ld hl,(cli_execword) 
1e25 e9				jp (hl) 
1e26			 
1e26			 
1e26			;    if not same 
1e26			;	scan for zero term 
1e26			;	get ptr for next word 
1e26			;	goto word comp 
1e26			 
1e26			.execpnskipword:	; get pointer to next word 
1e26 2a 2d eb			ld hl,(cli_nextword) 
1e29			 
1e29 7e				ld a,(hl) 
1e2a fe 00			cp WORD_SYS_END 
1e2c			;	cp 0 
1e2c 28 09			jr z, .execendofdict			 ; at end of words 
1e2e			 
1e2e			if DEBUG_FORTH_PARSE_KEY 
1e2e						DMARK "KY4" 
1e2e			endif 
1e2e			if DEBUG_FORTH_PARSE_EXEC 
1e2e			 
1e2e				; see if disabled 
1e2e			 
1e2e				ld a, (os_view_disable) 
1e2e				cp '*' 
1e2e				jr z, .noskip 
1e2e			 
1e2e			 
1e2e				ld de, .nowordfound 
1e2e				ld a, display_row_3 
1e2e				call str_at_display 
1e2e				call update_display 
1e2e				ld a, 100 
1e2e				call aDelayInMS 
1e2e				 
1e2e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e2e					call delay250ms 
1e2e				endif 
1e2e			.noskip:  
1e2e			 
1e2e			endif	 
1e2e			 
1e2e 2a 29 eb			ld hl,(cli_origptr) 
1e31 22 2b eb			ld (cli_ptr),hl 
1e34			 
1e34			if DEBUG_FORTH_PARSE_KEY 
1e34						DMARK "KY5" 
1e34			endif 
1e34 c3 da 1d			jp .execpnword			; else go to next word 
1e37			 
1e37			.execendofdict:  
1e37			 
1e37			if DEBUG_FORTH_PARSE_KEY 
1e37						DMARK "KYe" 
1e37			endif 
1e37			if DEBUG_FORTH_PARSE_EXEC 
1e37				; see if disabled 
1e37			 
1e37				ld a, (os_view_disable) 
1e37				cp '*' 
1e37				jr z, .ispskip 
1e37			 
1e37				call clear_display 
1e37				call update_display 
1e37				call delay1s 
1e37				ld de, (cli_origptr) 
1e37				ld a, display_row_1 
1e37				call str_at_display 
1e37				 
1e37				ld de, .enddict 
1e37				ld a, display_row_3 
1e37				call str_at_display 
1e37				call update_display 
1e37				ld a, 100 
1e37				call aDelayInMS 
1e37				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e37				call delay1s 
1e37				call delay1s 
1e37				call delay1s 
1e37				endif 
1e37			.ispskip:  
1e37				 
1e37			endif	 
1e37			 
1e37			 
1e37			 
1e37				; if the word is not a keyword then must be a literal so push it to stack 
1e37			 
1e37			; push token to stack to end of word 
1e37			 
1e37				STACKFRAME ON $1efe $2f9f 
1e37				if DEBUG_STACK_IMB 
1e37					if ON 
1e37						exx 
1e37						ld de, $1efe 
1e37						ld a, d 
1e37						ld hl, curframe 
1e37						call hexout 
1e37						ld a, e 
1e37						ld hl, curframe+2 
1e37						call hexout 
1e37						ld hl, $1efe 
1e37						push hl 
1e37						ld hl, $2f9f 
1e37						push hl 
1e37						exx 
1e37					endif 
1e37				endif 
1e37			endm 
# End of macro STACKFRAME
1e37			 
1e37 2a 61 e6		ld hl,(os_tok_ptr) 
1e3a cd 2f 1b		call forth_apush 
1e3d			 
1e3d				STACKFRAMECHK ON $1efe $2f9f 
1e3d				if DEBUG_STACK_IMB 
1e3d					if ON 
1e3d						exx 
1e3d						ld hl, $2f9f 
1e3d						pop de   ; $2f9f 
1e3d						call cmp16 
1e3d						jr nz, .spnosame 
1e3d						ld hl, $1efe 
1e3d						pop de   ; $1efe 
1e3d						call cmp16 
1e3d						jr z, .spfrsame 
1e3d						.spnosame: call showsperror 
1e3d						.spfrsame: nop 
1e3d						exx 
1e3d					endif 
1e3d				endif 
1e3d			endm 
# End of macro STACKFRAMECHK
1e3d			 
1e3d			execnext: 
1e3d			 
1e3d			if DEBUG_FORTH_PARSE_KEY 
1e3d						DMARK "KY>" 
1e3d			endif 
1e3d			; move past token to next word 
1e3d			 
1e3d 2a 61 e6		ld hl, (os_tok_ptr) 
1e40 3e 00		ld a, 0 
1e42 01 ff 00		ld bc, 255     ; input buffer size 
1e45 ed b1		cpir 
1e47			 
1e47			if DEBUG_FORTH_PARSE_KEY 
1e47						DMARK "KY!" 
1e47				CALLMONITOR 
1e47			endif	 
1e47			; TODO this might place hl on the null, so will need to forward on??? 
1e47			;inc hl   ; see if this gets onto the next item 
1e47			 
1e47			 
1e47			; TODO pass a pointer to the buffer to push 
1e47			; TODO call function to push 
1e47			 
1e47			; look for end of input 
1e47			 
1e47			;inc hl 
1e47			;ld a,(hl) 
1e47			;cp FORTH_END_BUFFER 
1e47			;ret z 
1e47			 
1e47			 
1e47 c3 c0 1d		jp exec1 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			 
1e4a			findnexttok: 
1e4a			 
1e4a				; hl is pointer to move 
1e4a				; de is the token to locate 
1e4a			 
1e4a					if DEBUG_FORTH 
1e4a						DMARK "NTK" 
1e4a						CALLMONITOR 
1e4a					endif 
1e4a d5				push de 
1e4b			 
1e4b			.fnt1:	 
1e4b				; find first char of token to locate 
1e4b			 
1e4b 1a				ld a, (de) 
1e4c 4f				ld c,a 
1e4d 7e				ld a,(hl) 
1e4e cd 1b 10			call toUpper 
1e51					if DEBUG_FORTH 
1e51						DMARK "NT1" 
1e51						CALLMONITOR 
1e51					endif 
1e51 b9				cp c 
1e52			 
1e52 28 03			jr z, .fnt2cmpmorefirst	 
1e54			 
1e54				; first char not found move to next char 
1e54			 
1e54 23				inc hl 
1e55 18 f4			jr .fnt1 
1e57			 
1e57			.fnt2cmpmorefirst:	 
1e57				; first char of token found.  
1e57			 
1e57 e5				push hl     ; save start of token just in case it is the right one 
1e58 d9				exx 
1e59 e1				pop hl        ; save it to hl' 
1e5a d9				exx 
1e5b			 
1e5b			 
1e5b			.fnt2cmpmore:	 
1e5b				; compare the rest 
1e5b				 
1e5b 23				inc hl 
1e5c 13				inc de 
1e5d				 
1e5d 1a				ld a, (de) 
1e5e 4f				ld c,a 
1e5f 7e				ld a,(hl) 
1e60 cd 1b 10			call toUpper 
1e63			 
1e63					if DEBUG_FORTH 
1e63						DMARK "NT2" 
1e63						CALLMONITOR 
1e63					endif 
1e63				; c has the token to find char 
1e63				; a has the mem to scan char 
1e63			 
1e63 b9				cp c 
1e64 28 04			jr z,.fntmatch1 
1e66			 
1e66				; they are not the same 
1e66			 
1e66					if DEBUG_FORTH 
1e66						DMARK "NT3" 
1e66						CALLMONITOR 
1e66					endif 
1e66 d1				pop de	; reset de token to look for 
1e67 d5				push de 
1e68 18 e1			jr .fnt1 
1e6a				 
1e6a			.fntmatch1: 
1e6a			 
1e6a				; is the same char a null which means we might have a full hit? 
1e6a					if DEBUG_FORTH 
1e6a						DMARK "NT4" 
1e6a						CALLMONITOR 
1e6a					endif 
1e6a			 
1e6a fe 00			cp 0 
1e6c 28 0b			jr z, .fntmatchyes 
1e6e			 
1e6e				; are we at the end of the token to find? 
1e6e			 
1e6e					if DEBUG_FORTH 
1e6e						DMARK "NT5" 
1e6e						CALLMONITOR 
1e6e					endif 
1e6e 3e 00			ld a, 0 
1e70 b9				cp c 
1e71			 
1e71 c2 5b 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1e74			 
1e74					if DEBUG_FORTH 
1e74						DMARK "NT6" 
1e74						CALLMONITOR 
1e74					endif 
1e74				; token to find is exhusted but no match to stream 
1e74			 
1e74				; restore tok pointer and continue on 
1e74 d1				pop de 
1e75 d5				push de 
1e76 c3 4b 1e			jp .fnt1 
1e79			 
1e79			 
1e79			.fntmatchyes: 
1e79			 
1e79				; hl now contains the end of the found token 
1e79			 
1e79				; get rid of saved token pointer to find 
1e79			 
1e79 d1				pop de 
1e7a			 
1e7a					if DEBUG_FORTH 
1e7a						DMARK "NT9" 
1e7a						CALLMONITOR 
1e7a					endif 
1e7a			 
1e7a				; hl will be on the null term so forward on 
1e7a			 
1e7a				; get back the saved start of the token 
1e7a			 
1e7a d9				exx 
1e7b e5				push hl     ; save start of token just in case it is the right one 
1e7c d9				exx 
1e7d e1				pop hl        ; save it to hl 
1e7e			 
1e7e c9				ret 
1e7f			 
1e7f			 
1e7f			; LIST needs to find a specific token   
1e7f			; FORGET needs to find a spefici token 
1e7f			 
1e7f			; SAVE needs to find all tokens by flag 
1e7f			; WORDS just needs to scan through all  by flag 
1e7f			; UWORDS needs to scan through all by flag 
1e7f			 
1e7f			 
1e7f			; given hl as pointer to start of dict look up string 
1e7f			; return hl as pointer to start of word block 
1e7f			; or 0 if not found 
1e7f			 
1e7f			forth_find_tok: 
1e7f c9				ret 
1e80			 
1e80			; given hl as pointer to dict structure 
1e80			; move to the next dict block structure 
1e80			 
1e80			forth_tok_next: 
1e80				; hl now points to the address of the next word pointer  
1e80				; TODO skip compiled symbol for now 
1e80			;	push de 
1e80 23				inc hl 
1e81 5e				ld e, (hl) 
1e82 23				inc hl 
1e83 56				ld d, (hl) 
1e84 23				inc hl 
1e85			 
1e85 eb				ex de,hl 
1e86			if DEBUG_FORTH_PARSE_NEXTWORD 
1e86				push bc 
1e86				ld bc, (cli_nextword) 
1e86						DMARK "NXW" 
1e86				CALLMONITOR 
1e86				pop bc 
1e86			endif 
1e86			;	pop de	 
1e86 c9				ret 
1e87			 
1e87			 
1e87			 
1e87			; eof 
# End of file forth_parserv5.asm
1e87				include "forth_wordsv4.asm" 
1e87			 
1e87			; the core word dictionary v4 
1e87			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e87			 
1e87			; this is a linked list for each of the system words used 
1e87			; user defined words will follow the same format but will be in ram 
1e87			 
1e87			 
1e87			; 
1e87			; 
1e87			; define linked list: 
1e87			; 
1e87			; 1. compiled byte op code 
1e87			; 2. len of text word 
1e87			; 3. text word 
1e87			; 4. ptr to next dictionary word 
1e87			; 5. asm, calls etc for the word 
1e87			; 
1e87			;  if 1 == 0 then last word in dict  
1e87			;   
1e87			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e87			;  
1e87			;  
1e87			; create basic standard set of words 
1e87			; 
1e87			;  
1e87			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e87			; 2DUP 2DROP 2SWAP  
1e87			; @ C@ - get byte  
1e87			; ! C! - store byte 
1e87			; 0< true if less than zero 
1e87			; 0= true if zero 
1e87			; < >  
1e87			; = true if same 
1e87			; variables 
1e87			 
1e87			 
1e87			; Hardware specific words I may need 
1e87			; 
1e87			; IN OUT  
1e87			; calls to key util functions 
1e87			; calls to hardward abstraction stuff 
1e87			; easy control of frame buffers and lcd i/o 
1e87			; keyboard  
1e87			 
1e87			 
1e87			;DICT: macro 
1e87			; op_code, len, word, next 
1e87			;    word: 
1e87			;    db op_code 
1e87			;    ds word zero term 
1e87			;    dw next 
1e87			;    endm 
1e87			 
1e87			 
1e87			 
1e87			 
1e87			; op code 1 is a flag for user define words which are to be handled differently 
1e87			 
1e87			 
1e87			; 
1e87			; 
1e87			;    TODO on entry to a word this should be the expected environment 
1e87			;    hl - tos value if number then held, if string this is the ptr 
1e87			;    de -  
1e87			 
1e87			 
1e87			; opcode ranges 
1e87			; 0 - end of word dict 
1e87			; 255 - user define words 
1e87			 
1e87			sysdict: 
1e87			include "forth_opcodes.asm" 
1e87			; op codes for forth keywords 
1e87			; free to use code 0  
1e87				OPCODE_HEAP: equ  1 
1e87				OPCODE_EXEC: equ 2 
1e87				OPCODE_DUP: equ 3 
1e87				OPCODE_SWAP: equ 4 
1e87				OPCODE_COLN: equ 5 
1e87				OPCODE_SCOLN: equ 6 
1e87				OPCODE_DROP: equ 7 
1e87				OPCODE_DUP2: equ 8 
1e87				OPCODE_DROP2: equ 9 
1e87				OPCODE_SWAP2: equ 10 
1e87				OPCODE_AT: equ 11 
1e87				OPCODE_CAT: equ 12 
1e87				OPCODE_BANG: equ 13 
1e87				OPCODE_CBANG: equ 14 
1e87				OPCODE_SCALL: equ 15 
1e87				OPCODE_DEPTH: equ 16 
1e87				OPCODE_OVER: equ 17 
1e87				OPCODE_PAUSE: equ 18 
1e87				OPCODE_PAUSES: equ 19 
1e87				OPCODE_ROT: equ 20 
1e87			;free to reuse	OPCODE_WORDS: equ 21 
1e87			        OPCODE_NOT: equ 21 
1e87				OPCODE_UWORDS: equ 22 
1e87				OPCODE_BP: equ 23 
1e87				OPCODE_MONITOR: equ 24  
1e87				OPCODE_MALLOC: equ 25 
1e87				OPCODE_FREE: equ 26 
1e87				OPCODE_LIST: equ 27 
1e87				OPCODE_FORGET: equ 28 
1e87				OPCODE_NOP: equ 29 
1e87				OPCODE_COMO: equ 30 
1e87				OPCODE_COMC: equ 31 
1e87			;free to reuse	OPCODE_ENDCORE: equ 32 
1e87				OPCODE_AFTERSOUND: equ 33 
1e87				OPCODE_GP2: equ 34 
1e87				OPCODE_GP3: equ 35 
1e87				OPCODE_GP4: equ 36 
1e87				OPCODE_SIN: equ 37 
1e87				OPCODE_SOUT: equ 38 
1e87				OPCODE_SPIO: equ 39 
1e87				OPCODE_SPICEH: equ 40 
1e87				OPCODE_SPIOb: equ 41 
1e87				OPCODE_SPII: equ 42 
1e87				OPCODE_SESEL: equ 43 
1e87				OPCODE_CARTDEV: equ 44 
1e87			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e87				OPCODE_FB: equ 46 
1e87				OPCODE_EMIT: equ 47 
1e87				OPCODE_DOTH: equ 48 
1e87				OPCODE_DOTF: equ 49 
1e87				OPCODE_DOT: equ 50 
1e87				OPCODE_CLS: equ 51 
1e87				OPCODE_DRAW: equ 52 
1e87				OPCODE_DUMP: equ 53 
1e87				OPCODE_CDUMP: equ 54 
1e87				OPCODE_DAT: equ 55 
1e87				OPCODE_HOME: equ 56 
1e87				OPCODE_SPACE: equ 57 
1e87				OPCODE_SPACES: equ 58 
1e87				OPCODE_SCROLL: equ 59 
1e87				OPCODE_ATQ: equ 60 
1e87				OPCODE_AUTODSP: equ 61 
1e87				OPCODE_MENU: equ 62 
1e87			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e87				OPCODE_THEN: equ 64 
1e87				OPCODE_ELSE: equ 65 
1e87				OPCODE_DO: equ 66 
1e87				OPCODE_LOOP: equ 67 
1e87				OPCODE_I: equ 68 
1e87				OPCODE_DLOOP: equ 69  
1e87				OPCODE_REPEAT: equ 70  
1e87				OPCODE_UNTIL: equ 71 
1e87				OPCODE_ENDFLOW: equ 72 
1e87				OPCODE_WAITK: equ 73 
1e87				OPCODE_ACCEPT: equ 74 
1e87				OPCODE_EDIT: equ 75 
1e87			;free to reuse	OPCODE_ENDKEY: equ 76 
1e87				OPCODE_LZERO: equ 77 
1e87				OPCODE_TZERO: equ 78 
1e87				OPCODE_LESS: equ 79 
1e87				OPCODE_GT: equ 80 
1e87				OPCODE_EQUAL: equ 81  
1e87			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e87				OPCODE_NEG: equ 83 
1e87				OPCODE_DIV: equ 84 
1e87				OPCODE_MUL: equ 85 
1e87				OPCODE_MIN: equ 86 
1e87				OPCODE_MAX: equ 87 
1e87				OPCODE_RND16: equ 88 
1e87				OPCODE_RND8: equ 89 
1e87				OPCODE_RND: equ 90 
1e87			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e87				OPCODE_BYNAME: equ 92 
1e87				OPCODE_DIR: equ 93 
1e87				OPCODE_SAVE: equ 94 
1e87				OPCODE_LOAD: equ 95 
1e87				OPCODE_BSAVE: equ 96 
1e87				OPCODE_BLOAD: equ 97 
1e87				OPCODE_SEO: equ 98  
1e87				OPCODE_SEI: equ 99 
1e87				OPCODE_SFREE: equ 100 
1e87				OPCODE_SIZE: equ 101 
1e87				OPCODE_CREATE: equ 102 
1e87				OPCODE_APPEND: equ 103 
1e87				OPCODE_SDEL: equ 104 
1e87				OPCODE_OPEN: equ 105 
1e87				OPCODE_READ: equ 106 
1e87				OPCODE_EOF: equ 106 
1e87				OPCODE_FORMAT: equ 107 
1e87				OPCODE_LABEL: equ 108 
1e87				OPCODE_LABELS: equ 109 
1e87			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e87				OPCODE_UPPER: equ 111 
1e87				OPCODE_LOWER: equ 112 
1e87				OPCODE_SUBSTR: equ 113 
1e87				OPCODE_LEFT: equ 114 
1e87				OPCODE_RIGHT: equ 115 
1e87				OPCODE_STR2NUM: equ 116 
1e87				OPCODE_NUM2STR: equ 117 
1e87				OPCODE_CONCAT: equ 118 
1e87				OPCODE_FIND: equ 119 
1e87				OPCODE_LEN: equ 120 
1e87				OPCODE_CHAR: equ 121 
1e87			; free to reuse	OPCODE_STRLEN: equ 122 
1e87			; free to reuse	OPCODE_ENDSTR: equ 123 
1e87				OPCODE_V0S: equ 124 
1e87				OPCODE_V0Q: equ 125 
1e87				OPCODE_V1S: equ 126 
1e87				OPCODE_V1Q: equ 127 
1e87				OPCODE_V2S: equ 128 
1e87				OPCODE_V2Q: equ 129 
1e87				OPCODE_V3S: equ 130 
1e87				OPCODE_V3Q: equ 131 
1e87			;free to reuse	OPCODE_END: equ 132 
1e87				OPCODE_ZDUP: equ 133 
1e87			 
1e87			; eof 
# End of file forth_opcodes.asm
1e87			 
1e87			include "forth_words_core.asm" 
1e87			 
1e87			; | ## Core Words 
1e87			 
1e87			;if MALLOC_4 
1e87			 
1e87			.HEAP: 
1e87				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e87 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e88 c6 1e			dw .EXEC            
1e8a 05				db 4 + 1 
1e8b .. 00			db "HEAP",0              
1e90				endm 
# End of macro CWHEAD
1e90			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e90			; | | u1 - Current number of bytes in the heap 
1e90			; | | u2 - Remaining bytes left on the heap 
1e90			; | |  
1e90			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e90			 
1e90			 
1e90					if DEBUG_FORTH_WORDS_KEY 
1e90						DMARK "HEP" 
1e90 f5				push af  
1e91 3a a5 1e			ld a, (.dmark)  
1e94 32 7a ee			ld (debug_mark),a  
1e97 3a a6 1e			ld a, (.dmark+1)  
1e9a 32 7b ee			ld (debug_mark+1),a  
1e9d 3a a7 1e			ld a, (.dmark+2)  
1ea0 32 7c ee			ld (debug_mark+2),a  
1ea3 18 03			jr .pastdmark  
1ea5 ..			.dmark: db "HEP"  
1ea8 f1			.pastdmark: pop af  
1ea9			endm  
# End of macro DMARK
1ea9						CALLMONITOR 
1ea9 cd 39 14			call break_point_state  
1eac				endm  
# End of macro CALLMONITOR
1eac					endif 
1eac 2a e2 58				ld hl, (free_list )      
1eaf 11 e7 58				ld de, heap_start 
1eb2			 
1eb2 ed 52				sbc hl, de  
1eb4			 
1eb4 cd c6 19				call forth_push_numhl 
1eb7			 
1eb7			 
1eb7 ed 5b e2 58			ld de, (free_list )      
1ebb 21 46 e3				ld hl, heap_end 
1ebe			 
1ebe ed 52				sbc hl, de 
1ec0			 
1ec0 cd c6 19				call forth_push_numhl 
1ec3					 
1ec3			 
1ec3					 
1ec3			 
1ec3			 
1ec3			 
1ec3					NEXTW 
1ec3 c3 2f 1d			jp macro_next 
1ec6				endm 
# End of macro NEXTW
1ec6			;endif 
1ec6			 
1ec6			.EXEC: 
1ec6			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1ec6			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1ec6			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1ec6			;; > > 
1ec6			;; > >   
1ec6			;	STACKFRAME OFF $5efe $5f9f 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS_KEY 
1ec6			;			DMARK "EXE" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			; 
1ec6			;	FORTH_DSP_POP 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX1" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;;	ld e,(hl) 
1ec6			;;	inc hl 
1ec6			;;	ld d,(hl) 
1ec6			;;	ex de,hl 
1ec6			; 
1ec6			;;		if DEBUG_FORTH_WORDS 
1ec6			;;			DMARK "EX2" 
1ec6			;;			CALLMONITOR 
1ec6			;;		endif 
1ec6			;	push hl 
1ec6			; 
1ec6			;	;ld a, 0 
1ec6			;	;ld a, FORTH_END_BUFFER 
1ec6			;	call strlenz 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	inc hl   ; include term 
1ec6			;	inc hl   ; include term 
1ec6			;	ld b,0 
1ec6			;	ld c,l 
1ec6			;	pop hl 
1ec6			;	ld de, execscratch 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX3" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ldir 
1ec6			; 
1ec6			; 
1ec6			;	ld hl, execscratch 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXe" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	call forthparse 
1ec6			;	call forthexec 
1ec6			;;	call forthexec_cleanup 
1ec6			;;	call forthparse 
1ec6			;;	call forthexec 
1ec6			; 
1ec6			;	STACKFRAMECHK OFF $5efe $5f9f 
1ec6			; 
1ec6			;	; an immediate word so no need to process any more words 
1ec6			;	ret 
1ec6			;	NEXTW 
1ec6			 
1ec6			; dead code - old version  
1ec6			;	FORTH_RSP_NEXT 
1ec6			 
1ec6			;  
1ec6			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ec6			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ec6			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ec6			;	push hl 
1ec6			;	push de 
1ec6			;	push bc 
1ec6			; 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS_KEY 
1ec6			;			DMARK "EXR" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			; 
1ec6			; 
1ec6			;	;v5 FORTH_DSP_VALUE 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			; 
1ec6			;	; TODO do string type checks 
1ec6			; 
1ec6			;;v5	inc hl   ; skip type 
1ec6			; 
1ec6			;	push hl  ; source code  
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX1" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ld a, 0 
1ec6			;	call strlent 
1ec6			; 
1ec6			;	inc hl 
1ec6			;	inc hl 
1ec6			;	inc hl 
1ec6			;	inc hl 
1ec6			; 
1ec6			;	push hl    ; size 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX2" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	call malloc 
1ec6			; 
1ec6			;	ex de, hl    ; de now contains malloc area 
1ec6			;	pop bc   	; get byte count 
1ec6			;	pop hl      ; get string to copy 
1ec6			; 
1ec6			;	push de     ; save malloc for free later 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX3" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ldir       ; duplicate string 
1ec6			; 
1ec6			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1ec6			;	 
1ec6			;	; TODO fix the parse would be better than this...  
1ec6			;	ex de, hl 
1ec6			;	dec hl 
1ec6			;	ld a, 0 
1ec6			;	ld (hl), a 
1ec6			;	dec hl 
1ec6			;	ld a, ' ' 
1ec6			;	ld (hl), a 
1ec6			;	dec hl 
1ec6			;	ld (hl), a 
1ec6			; 
1ec6			;	dec hl 
1ec6			;	ld (hl), a 
1ec6			; 
1ec6			; 
1ec6			;	FORTH_DSP_POP  
1ec6			; 
1ec6			;	pop hl     
1ec6			;	push hl    ; save malloc area 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX4" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	call forthparse 
1ec6			;	call forthexec 
1ec6			;	 
1ec6			;	pop hl 
1ec6			;	if DEBUG_FORTH_WORDS 
1ec6			;		DMARK "EX5" 
1ec6			;		CALLMONITOR 
1ec6			;	endif 
1ec6			; 
1ec6			;	if FORTH_ENABLE_FREE 
1ec6			;	call free 
1ec6			;	endif 
1ec6			; 
1ec6			;	if DEBUG_FORTH_WORDS 
1ec6			;		DMARK "EX6" 
1ec6			;		CALLMONITOR 
1ec6			;	endif 
1ec6			; 
1ec6			;	pop bc 
1ec6			;	pop de 
1ec6			;	pop hl 
1ec6			;;	FORTH_RSP_POP	  
1ec6			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1ec6			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1ec6			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1ec6			; 
1ec6			;	if DEBUG_FORTH_WORDS 
1ec6			;		DMARK "EX7" 
1ec6			;		CALLMONITOR 
1ec6			;	endif 
1ec6			;	NEXTW 
1ec6			 
1ec6			;.STKEXEC: 
1ec6			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1ec6			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1ec6			; 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS_KEY 
1ec6			;			DMARK "STX" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			; 
1ec6			;	ld (store_tmp1), hl    ; count 
1ec6			; 
1ec6			;	FORTH_DSP_POP 
1ec6			;.stkexec1: 
1ec6			;	ld hl, (store_tmp1)   ; count 
1ec6			;	ld a, 0 
1ec6			;	cp l 
1ec6			;	ret z 
1ec6			; 
1ec6			;	dec hl 
1ec6			;	ld (store_tmp1), hl    ; count 
1ec6			;	 
1ec6			;	FORTH_DSP_VALUEHL 
1ec6			;	push hl 
1ec6			;	 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXp" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	FORTH_DSP_POP 
1ec6			; 
1ec6			;	call strlenz 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	inc hl   ; include zero term to copy 
1ec6			;	ld b,0 
1ec6			;	ld c,l 
1ec6			;	pop hl 
1ec6			;	ld de, execscratch 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EX3" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	ldir 
1ec6			; 
1ec6			; 
1ec6			;	ld hl, execscratch 
1ec6			; 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXP" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			; 
1ec6			;	call forthparse 
1ec6			;	ld hl, execscratch 
1ec6			;		if DEBUG_FORTH_WORDS 
1ec6			;			DMARK "EXx" 
1ec6			;			CALLMONITOR 
1ec6			;		endif 
1ec6			;	call forthexec 
1ec6			; 
1ec6			;	jp .stkexec1 
1ec6			; 
1ec6			;	ret 
1ec6			 
1ec6			 
1ec6			.DUP: 
1ec6				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1ec6 17				db WORD_SYS_CORE+OPCODE_DUP             
1ec7 3c 1f			dw .ZDUP            
1ec9 04				db 3 + 1 
1eca .. 00			db "DUP",0              
1ece				endm 
# End of macro CWHEAD
1ece			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1ece			 
1ece					if DEBUG_FORTH_WORDS_KEY 
1ece						DMARK "DUP" 
1ece f5				push af  
1ecf 3a e3 1e			ld a, (.dmark)  
1ed2 32 7a ee			ld (debug_mark),a  
1ed5 3a e4 1e			ld a, (.dmark+1)  
1ed8 32 7b ee			ld (debug_mark+1),a  
1edb 3a e5 1e			ld a, (.dmark+2)  
1ede 32 7c ee			ld (debug_mark+2),a  
1ee1 18 03			jr .pastdmark  
1ee3 ..			.dmark: db "DUP"  
1ee6 f1			.pastdmark: pop af  
1ee7			endm  
# End of macro DMARK
1ee7						CALLMONITOR 
1ee7 cd 39 14			call break_point_state  
1eea				endm  
# End of macro CALLMONITOR
1eea					endif 
1eea			 
1eea					FORTH_DSP 
1eea cd 83 1b			call macro_forth_dsp 
1eed				endm 
# End of macro FORTH_DSP
1eed			 
1eed 7e					ld a, (HL) 
1eee fe 01				cp DS_TYPE_STR 
1ef0 20 25				jr nz, .dupinum 
1ef2			 
1ef2					; push another string 
1ef2			 
1ef2					FORTH_DSP_VALUEHL     		 
1ef2 cd bd 1b			call macro_dsp_valuehl 
1ef5				endm 
# End of macro FORTH_DSP_VALUEHL
1ef5			 
1ef5				if DEBUG_FORTH_WORDS 
1ef5					DMARK "DUs" 
1ef5 f5				push af  
1ef6 3a 0a 1f			ld a, (.dmark)  
1ef9 32 7a ee			ld (debug_mark),a  
1efc 3a 0b 1f			ld a, (.dmark+1)  
1eff 32 7b ee			ld (debug_mark+1),a  
1f02 3a 0c 1f			ld a, (.dmark+2)  
1f05 32 7c ee			ld (debug_mark+2),a  
1f08 18 03			jr .pastdmark  
1f0a ..			.dmark: db "DUs"  
1f0d f1			.pastdmark: pop af  
1f0e			endm  
# End of macro DMARK
1f0e					CALLMONITOR 
1f0e cd 39 14			call break_point_state  
1f11				endm  
# End of macro CALLMONITOR
1f11				endif 
1f11 cd 34 1a				call forth_push_str 
1f14			 
1f14					NEXTW 
1f14 c3 2f 1d			jp macro_next 
1f17				endm 
# End of macro NEXTW
1f17			 
1f17			 
1f17			.dupinum: 
1f17					 
1f17			 
1f17			 
1f17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f17 cd bd 1b			call macro_dsp_valuehl 
1f1a				endm 
# End of macro FORTH_DSP_VALUEHL
1f1a			 
1f1a				; TODO add floating point number detection 
1f1a			 
1f1a				if DEBUG_FORTH_WORDS 
1f1a					DMARK "DUi" 
1f1a f5				push af  
1f1b 3a 2f 1f			ld a, (.dmark)  
1f1e 32 7a ee			ld (debug_mark),a  
1f21 3a 30 1f			ld a, (.dmark+1)  
1f24 32 7b ee			ld (debug_mark+1),a  
1f27 3a 31 1f			ld a, (.dmark+2)  
1f2a 32 7c ee			ld (debug_mark+2),a  
1f2d 18 03			jr .pastdmark  
1f2f ..			.dmark: db "DUi"  
1f32 f1			.pastdmark: pop af  
1f33			endm  
# End of macro DMARK
1f33					CALLMONITOR 
1f33 cd 39 14			call break_point_state  
1f36				endm  
# End of macro CALLMONITOR
1f36				endif 
1f36			 
1f36 cd c6 19				call forth_push_numhl 
1f39					NEXTW 
1f39 c3 2f 1d			jp macro_next 
1f3c				endm 
# End of macro NEXTW
1f3c			.ZDUP: 
1f3c				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f3c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f3d 74 1f			dw .SWAP            
1f3f 05				db 4 + 1 
1f40 .. 00			db "?DUP",0              
1f45				endm 
# End of macro CWHEAD
1f45			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f45			 
1f45					if DEBUG_FORTH_WORDS_KEY 
1f45						DMARK "qDU" 
1f45 f5				push af  
1f46 3a 5a 1f			ld a, (.dmark)  
1f49 32 7a ee			ld (debug_mark),a  
1f4c 3a 5b 1f			ld a, (.dmark+1)  
1f4f 32 7b ee			ld (debug_mark+1),a  
1f52 3a 5c 1f			ld a, (.dmark+2)  
1f55 32 7c ee			ld (debug_mark+2),a  
1f58 18 03			jr .pastdmark  
1f5a ..			.dmark: db "qDU"  
1f5d f1			.pastdmark: pop af  
1f5e			endm  
# End of macro DMARK
1f5e						CALLMONITOR 
1f5e cd 39 14			call break_point_state  
1f61				endm  
# End of macro CALLMONITOR
1f61					endif 
1f61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f61 cd bd 1b			call macro_dsp_valuehl 
1f64				endm 
# End of macro FORTH_DSP_VALUEHL
1f64			 
1f64 e5					push hl 
1f65			 
1f65					; is it a zero? 
1f65			 
1f65 3e 00				ld a, 0 
1f67 84					add h 
1f68 85					add l 
1f69			 
1f69 e1					pop hl 
1f6a			 
1f6a fe 00				cp 0 
1f6c 28 03				jr z, .dup2orig 
1f6e			 
1f6e			 
1f6e cd c6 19				call forth_push_numhl 
1f71			 
1f71			 
1f71				; TODO add floating point number detection 
1f71			 
1f71			.dup2orig: 
1f71			 
1f71					NEXTW 
1f71 c3 2f 1d			jp macro_next 
1f74				endm 
# End of macro NEXTW
1f74			.SWAP: 
1f74				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f74 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f75 b3 1f			dw .COLN            
1f77 05				db 4 + 1 
1f78 .. 00			db "SWAP",0              
1f7d				endm 
# End of macro CWHEAD
1f7d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f7d					if DEBUG_FORTH_WORDS_KEY 
1f7d						DMARK "SWP" 
1f7d f5				push af  
1f7e 3a 92 1f			ld a, (.dmark)  
1f81 32 7a ee			ld (debug_mark),a  
1f84 3a 93 1f			ld a, (.dmark+1)  
1f87 32 7b ee			ld (debug_mark+1),a  
1f8a 3a 94 1f			ld a, (.dmark+2)  
1f8d 32 7c ee			ld (debug_mark+2),a  
1f90 18 03			jr .pastdmark  
1f92 ..			.dmark: db "SWP"  
1f95 f1			.pastdmark: pop af  
1f96			endm  
# End of macro DMARK
1f96						CALLMONITOR 
1f96 cd 39 14			call break_point_state  
1f99				endm  
# End of macro CALLMONITOR
1f99					endif 
1f99			 
1f99					FORTH_DSP_VALUEHL 
1f99 cd bd 1b			call macro_dsp_valuehl 
1f9c				endm 
# End of macro FORTH_DSP_VALUEHL
1f9c e5					push hl     ; w2 
1f9d			 
1f9d					FORTH_DSP_POP 
1f9d cd 75 1c			call macro_forth_dsp_pop 
1fa0				endm 
# End of macro FORTH_DSP_POP
1fa0			 
1fa0					FORTH_DSP_VALUEHL 
1fa0 cd bd 1b			call macro_dsp_valuehl 
1fa3				endm 
# End of macro FORTH_DSP_VALUEHL
1fa3			 
1fa3					FORTH_DSP_POP 
1fa3 cd 75 1c			call macro_forth_dsp_pop 
1fa6				endm 
# End of macro FORTH_DSP_POP
1fa6			 
1fa6 d1					pop de     ; w2	, hl = w1 
1fa7			 
1fa7 eb					ex de, hl 
1fa8 d5					push de 
1fa9			 
1fa9 cd c6 19				call forth_push_numhl 
1fac			 
1fac e1					pop hl 
1fad			 
1fad cd c6 19				call forth_push_numhl 
1fb0					 
1fb0			 
1fb0					NEXTW 
1fb0 c3 2f 1d			jp macro_next 
1fb3				endm 
# End of macro NEXTW
1fb3			.COLN: 
1fb3				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1fb3 19				db WORD_SYS_CORE+OPCODE_COLN             
1fb4 3f 21			dw .SCOLN            
1fb6 02				db 1 + 1 
1fb7 .. 00			db ":",0              
1fb9				endm 
# End of macro CWHEAD
1fb9			; | : ( -- )         Create new word | DONE 
1fb9			 
1fb9					if DEBUG_FORTH_WORDS_KEY 
1fb9						DMARK "CLN" 
1fb9 f5				push af  
1fba 3a ce 1f			ld a, (.dmark)  
1fbd 32 7a ee			ld (debug_mark),a  
1fc0 3a cf 1f			ld a, (.dmark+1)  
1fc3 32 7b ee			ld (debug_mark+1),a  
1fc6 3a d0 1f			ld a, (.dmark+2)  
1fc9 32 7c ee			ld (debug_mark+2),a  
1fcc 18 03			jr .pastdmark  
1fce ..			.dmark: db "CLN"  
1fd1 f1			.pastdmark: pop af  
1fd2			endm  
# End of macro DMARK
1fd2						CALLMONITOR 
1fd2 cd 39 14			call break_point_state  
1fd5				endm  
# End of macro CALLMONITOR
1fd5					endif 
1fd5				STACKFRAME OFF $8efe $989f 
1fd5				if DEBUG_STACK_IMB 
1fd5					if OFF 
1fd5						exx 
1fd5						ld de, $8efe 
1fd5						ld a, d 
1fd5						ld hl, curframe 
1fd5						call hexout 
1fd5						ld a, e 
1fd5						ld hl, curframe+2 
1fd5						call hexout 
1fd5						ld hl, $8efe 
1fd5						push hl 
1fd5						ld hl, $989f 
1fd5						push hl 
1fd5						exx 
1fd5					endif 
1fd5				endif 
1fd5			endm 
# End of macro STACKFRAME
1fd5				; get parser buffer length  of new word 
1fd5			 
1fd5				 
1fd5			 
1fd5					; move tok past this to start of name defintition 
1fd5					; TODO get word to define 
1fd5					; TODO Move past word token 
1fd5					; TODO get length of string up to the ';' 
1fd5			 
1fd5 2a 61 e6			ld hl, (os_tok_ptr) 
1fd8 23				inc hl 
1fd9 23				inc hl 
1fda			 
1fda 3e 3b			ld a, ';' 
1fdc cd 2f 10			call strlent 
1fdf			 
1fdf 7d				ld a,l 
1fe0 32 5c e3			ld (os_new_parse_len), a 
1fe3			 
1fe3			 
1fe3			if DEBUG_FORTH_UWORD 
1fe3 ed 5b 61 e6		ld de, (os_tok_ptr) 
1fe7						DMARK ":01" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 7a ee			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 7b ee			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 7c ee			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db ":01"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000				CALLMONITOR 
2000 cd 39 14			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003			endif 
2003			 
2003			; 
2003			;  new word memory layout: 
2003			;  
2003			;    : adg 6666 ;  
2003			; 
2003			;    db   1     ; user defined word  
2003 23				inc hl    
2004			;    dw   sysdict 
2004 23				inc hl 
2005 23				inc hl 
2006			;    db <word len>+1 (for null) 
2006 23				inc hl 
2007			;    db .... <word> 
2007			; 
2007			 
2007 23				inc hl    ; some extras for the word preamble before the above 
2008 23				inc hl 
2009 23				inc hl 
200a 23				inc hl 
200b 23				inc hl 
200c 23				inc hl 
200d 23				inc hl  
200e 23				inc hl 
200f 23				inc hl 
2010 23				inc hl 
2011 23				inc hl 
2012 23				inc hl 
2013 23				inc hl 
2014 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2015			;       exec word buffer 
2015			;	<ptr word>   
2015 23				inc hl 
2016 23				inc hl 
2017			;       <word list><null term> 7F final term 
2017			 
2017			 
2017			if DEBUG_FORTH_UWORD 
2017						DMARK ":02" 
2017 f5				push af  
2018 3a 2c 20			ld a, (.dmark)  
201b 32 7a ee			ld (debug_mark),a  
201e 3a 2d 20			ld a, (.dmark+1)  
2021 32 7b ee			ld (debug_mark+1),a  
2024 3a 2e 20			ld a, (.dmark+2)  
2027 32 7c ee			ld (debug_mark+2),a  
202a 18 03			jr .pastdmark  
202c ..			.dmark: db ":02"  
202f f1			.pastdmark: pop af  
2030			endm  
# End of macro DMARK
2030				CALLMONITOR 
2030 cd 39 14			call break_point_state  
2033				endm  
# End of macro CALLMONITOR
2033			endif 
2033			 
2033				 
2033					; malloc the size 
2033			 
2033 cd 8d 10				call malloc 
2036 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
2039			 
2039			;    db   1     ; user defined word  
2039 3e 01				ld a, WORD_SYS_UWORD  
203b 77					ld (hl), a 
203c				 
203c 23				inc hl    
203d			;    dw   sysdict 
203d 11 87 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2040 73				ld (hl), e 
2041 23				inc hl 
2042 72				ld (hl), d 
2043 23				inc hl 
2044			 
2044			 
2044			;    Setup dict word 
2044			 
2044 23				inc hl 
2045 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
2048			 
2048				; 1. get length of dict word 
2048			 
2048			 
2048 2a 61 e6			ld hl, (os_tok_ptr) 
204b 23				inc hl 
204c 23				inc hl    ; position to start of dict word 
204d 3e 00			ld a, 0 
204f cd 2f 10			call strlent 
2052			 
2052			 
2052 23				inc hl    ; to include null??? 
2053			 
2053				; write length of dict word 
2053			 
2053 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2057 1b				dec de 
2058 eb				ex de, hl 
2059 73				ld (hl), e 
205a eb				ex de, hl 
205b			 
205b				 
205b			 
205b				; copy  
205b 4d				ld c, l 
205c 06 00			ld b, 0 
205e ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2062 2a 61 e6			ld hl, (os_tok_ptr) 
2065 23				inc hl 
2066 23				inc hl    ; position to start of dict word 
2067				 
2067			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2067				 
2067				; TODO need to convert word to upper case 
2067			 
2067			ucasetok:	 
2067 7e				ld a,(hl) 
2068 cd 1b 10			call toUpper 
206b 77				ld (hl),a 
206c ed a0			ldi 
206e f2 67 20		 	jp p, ucasetok 
2071			 
2071			 
2071			 
2071				; de now points to start of where the word body code should be placed 
2071 ed 53 58 e3		ld (os_new_work_ptr), de 
2075				; hl now points to the words to throw at forthexec which needs to be copied 
2075 22 56 e3			ld (os_new_src_ptr), hl 
2078			 
2078				; TODO add 'call to forthexec' 
2078			 
2078			if DEBUG_FORTH_UWORD 
2078 c5				push bc 
2079 ed 4b 5e e3		ld bc, (os_new_malloc) 
207d						DMARK ":0x" 
207d f5				push af  
207e 3a 92 20			ld a, (.dmark)  
2081 32 7a ee			ld (debug_mark),a  
2084 3a 93 20			ld a, (.dmark+1)  
2087 32 7b ee			ld (debug_mark+1),a  
208a 3a 94 20			ld a, (.dmark+2)  
208d 32 7c ee			ld (debug_mark+2),a  
2090 18 03			jr .pastdmark  
2092 ..			.dmark: db ":0x"  
2095 f1			.pastdmark: pop af  
2096			endm  
# End of macro DMARK
2096				CALLMONITOR 
2096 cd 39 14			call break_point_state  
2099				endm  
# End of macro CALLMONITOR
2099 c1				pop bc 
209a			endif 
209a			 
209a			 
209a				; create word preamble which should be: 
209a			 
209a			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
209a			 
209a				;    ld hl, <word code> 
209a				;    jp user_exec 
209a			        ;    <word code bytes> 
209a			 
209a			 
209a			;	inc de     ; TODO ??? or are we already past the word's null 
209a eb				ex de, hl 
209b			 
209b 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
209d			 
209d 23				inc hl 
209e 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
20a1 23				inc hl 
20a2			 
20a2 23				inc hl 
20a3 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
20a5			 
20a5 01 63 44			ld bc, user_exec 
20a8 23				inc hl 
20a9 71				ld (hl), c     ; poke address of user_exec 
20aa 23				inc hl 
20ab 70				ld (hl), b     
20ac			 ; 
20ac			;	inc hl 
20ac			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ac			; 
20ac			; 
20ac			;	ld bc, macro_forth_rsp_next 
20ac			;	inc hl 
20ac			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
20ac			;	inc hl 
20ac			;	ld (hl), b     
20ac			 ; 
20ac			;	inc hl 
20ac			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ac			; 
20ac			; 
20ac			;	inc hl 
20ac			;	ld bc, forthexec 
20ac			;	ld (hl), c     ; poke address of forthexec 
20ac			;	inc hl 
20ac			;	ld (hl), b      
20ac			; 
20ac			;	inc hl 
20ac			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
20ac			; 
20ac			;	ld bc, user_dict_next 
20ac			;	inc hl 
20ac			;	ld (hl), c     ; poke address of forthexec 
20ac			;	inc hl 
20ac			;	ld (hl), b      
20ac			 
20ac				; hl is now where we need to copy the word byte data to save this 
20ac			 
20ac 23				inc hl 
20ad 22 54 e3			ld (os_new_exec), hl 
20b0				 
20b0				; copy definition 
20b0			 
20b0 eb				ex de, hl 
20b1			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20b1			;	inc de    ; skip the PC for this parse 
20b1 3a 5c e3			ld a, (os_new_parse_len) 
20b4 4f				ld c, a 
20b5 06 00			ld b, 0 
20b7 ed b0			ldir		 ; copy defintion 
20b9			 
20b9			 
20b9				; poke the address of where the new word bytes live for forthexec 
20b9			 
20b9 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20bc			 
20bc ed 5b 54 e3		ld de, (os_new_exec)      
20c0				 
20c0 73				ld (hl), e 
20c1 23				inc hl 
20c2 72				ld (hl), d 
20c3			 
20c3					; TODO copy last user dict word next link to this word 
20c3					; TODO update last user dict word to point to this word 
20c3			; 
20c3			; hl f923 de 812a ; bc 811a 
20c3			 
20c3			if DEBUG_FORTH_UWORD 
20c3 c5				push bc 
20c4 ed 4b 5e e3		ld bc, (os_new_malloc) 
20c8						DMARK ":0A" 
20c8 f5				push af  
20c9 3a dd 20			ld a, (.dmark)  
20cc 32 7a ee			ld (debug_mark),a  
20cf 3a de 20			ld a, (.dmark+1)  
20d2 32 7b ee			ld (debug_mark+1),a  
20d5 3a df 20			ld a, (.dmark+2)  
20d8 32 7c ee			ld (debug_mark+2),a  
20db 18 03			jr .pastdmark  
20dd ..			.dmark: db ":0A"  
20e0 f1			.pastdmark: pop af  
20e1			endm  
# End of macro DMARK
20e1				CALLMONITOR 
20e1 cd 39 14			call break_point_state  
20e4				endm  
# End of macro CALLMONITOR
20e4 c1				pop bc 
20e5			endif 
20e5			if DEBUG_FORTH_UWORD 
20e5 c5				push bc 
20e6 ed 4b 5e e3		ld bc, (os_new_malloc) 
20ea 03				inc bc 
20eb 03				inc bc 
20ec 03				inc bc 
20ed 03				inc bc 
20ee 03				inc bc 
20ef 03				inc bc 
20f0 03				inc bc 
20f1 03				inc bc 
20f2			 
20f2						DMARK ":0B" 
20f2 f5				push af  
20f3 3a 07 21			ld a, (.dmark)  
20f6 32 7a ee			ld (debug_mark),a  
20f9 3a 08 21			ld a, (.dmark+1)  
20fc 32 7b ee			ld (debug_mark+1),a  
20ff 3a 09 21			ld a, (.dmark+2)  
2102 32 7c ee			ld (debug_mark+2),a  
2105 18 03			jr .pastdmark  
2107 ..			.dmark: db ":0B"  
210a f1			.pastdmark: pop af  
210b			endm  
# End of macro DMARK
210b				CALLMONITOR 
210b cd 39 14			call break_point_state  
210e				endm  
# End of macro CALLMONITOR
210e c1				pop bc 
210f			endif 
210f			 
210f			; update word dict linked list for new word 
210f			 
210f			 
210f 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2112 23			inc hl     ; move to next work linked list ptr 
2113			 
2113 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
2117 73			ld (hl), e 
2118 23			inc hl 
2119 72			ld (hl), d 
211a			 
211a			if DEBUG_FORTH_UWORD 
211a ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
211e			endif 
211e			 
211e ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2122			 
2122			 
2122			if DEBUG_FORTH_UWORD 
2122						DMARK ":0+" 
2122 f5				push af  
2123 3a 37 21			ld a, (.dmark)  
2126 32 7a ee			ld (debug_mark),a  
2129 3a 38 21			ld a, (.dmark+1)  
212c 32 7b ee			ld (debug_mark+1),a  
212f 3a 39 21			ld a, (.dmark+2)  
2132 32 7c ee			ld (debug_mark+2),a  
2135 18 03			jr .pastdmark  
2137 ..			.dmark: db ":0+"  
213a f1			.pastdmark: pop af  
213b			endm  
# End of macro DMARK
213b				CALLMONITOR 
213b cd 39 14			call break_point_state  
213e				endm  
# End of macro CALLMONITOR
213e			endif 
213e			 
213e				STACKFRAMECHK OFF $8efe $989f 
213e				if DEBUG_STACK_IMB 
213e					if OFF 
213e						exx 
213e						ld hl, $989f 
213e						pop de   ; $989f 
213e						call cmp16 
213e						jr nz, .spnosame 
213e						ld hl, $8efe 
213e						pop de   ; $8efe 
213e						call cmp16 
213e						jr z, .spfrsame 
213e						.spnosame: call showsperror 
213e						.spfrsame: nop 
213e						exx 
213e					endif 
213e				endif 
213e			endm 
# End of macro STACKFRAMECHK
213e			 
213e c9			ret    ; dont process any remaining parser tokens as they form new word 
213f			 
213f			 
213f			 
213f			 
213f			;		NEXT 
213f			.SCOLN: 
213f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
213f 06				db OPCODE_SCOLN 
2140 8b 21			dw .DROP 
2142 02				db 2 
2143 .. 00			db ";",0           
2145			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2145					if DEBUG_FORTH_WORDS_KEY 
2145						DMARK "SCN" 
2145 f5				push af  
2146 3a 5a 21			ld a, (.dmark)  
2149 32 7a ee			ld (debug_mark),a  
214c 3a 5b 21			ld a, (.dmark+1)  
214f 32 7b ee			ld (debug_mark+1),a  
2152 3a 5c 21			ld a, (.dmark+2)  
2155 32 7c ee			ld (debug_mark+2),a  
2158 18 03			jr .pastdmark  
215a ..			.dmark: db "SCN"  
215d f1			.pastdmark: pop af  
215e			endm  
# End of macro DMARK
215e						CALLMONITOR 
215e cd 39 14			call break_point_state  
2161				endm  
# End of macro CALLMONITOR
2161					endif 
2161					FORTH_RSP_TOS 
2161 cd 84 19			call macro_forth_rsp_tos 
2164				endm 
# End of macro FORTH_RSP_TOS
2164 e5					push hl 
2165					FORTH_RSP_POP 
2165 cd 8e 19			call macro_forth_rsp_pop 
2168				endm 
# End of macro FORTH_RSP_POP
2168 e1					pop hl 
2169			;		ex de,hl 
2169 22 61 e6				ld (os_tok_ptr),hl 
216c			 
216c			if DEBUG_FORTH_UWORD 
216c						DMARK "SCL" 
216c f5				push af  
216d 3a 81 21			ld a, (.dmark)  
2170 32 7a ee			ld (debug_mark),a  
2173 3a 82 21			ld a, (.dmark+1)  
2176 32 7b ee			ld (debug_mark+1),a  
2179 3a 83 21			ld a, (.dmark+2)  
217c 32 7c ee			ld (debug_mark+2),a  
217f 18 03			jr .pastdmark  
2181 ..			.dmark: db "SCL"  
2184 f1			.pastdmark: pop af  
2185			endm  
# End of macro DMARK
2185				CALLMONITOR 
2185 cd 39 14			call break_point_state  
2188				endm  
# End of macro CALLMONITOR
2188			endif 
2188					NEXTW 
2188 c3 2f 1d			jp macro_next 
218b				endm 
# End of macro NEXTW
218b			 
218b			.DROP: 
218b				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
218b 1b				db WORD_SYS_CORE+OPCODE_DROP             
218c b6 21			dw .DUP2            
218e 05				db 4 + 1 
218f .. 00			db "DROP",0              
2194				endm 
# End of macro CWHEAD
2194			; | DROP ( w -- )   drop the TOS item   | DONE 
2194					if DEBUG_FORTH_WORDS_KEY 
2194						DMARK "DRP" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 7a ee			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 7b ee			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 7c ee			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "DRP"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad						CALLMONITOR 
21ad cd 39 14			call break_point_state  
21b0				endm  
# End of macro CALLMONITOR
21b0					endif 
21b0					FORTH_DSP_POP 
21b0 cd 75 1c			call macro_forth_dsp_pop 
21b3				endm 
# End of macro FORTH_DSP_POP
21b3					NEXTW 
21b3 c3 2f 1d			jp macro_next 
21b6				endm 
# End of macro NEXTW
21b6			.DUP2: 
21b6				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21b6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21b7 fb 21			dw .DROP2            
21b9 05				db 4 + 1 
21ba .. 00			db "2DUP",0              
21bf				endm 
# End of macro CWHEAD
21bf			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
21bf					if DEBUG_FORTH_WORDS_KEY 
21bf						DMARK "2DU" 
21bf f5				push af  
21c0 3a d4 21			ld a, (.dmark)  
21c3 32 7a ee			ld (debug_mark),a  
21c6 3a d5 21			ld a, (.dmark+1)  
21c9 32 7b ee			ld (debug_mark+1),a  
21cc 3a d6 21			ld a, (.dmark+2)  
21cf 32 7c ee			ld (debug_mark+2),a  
21d2 18 03			jr .pastdmark  
21d4 ..			.dmark: db "2DU"  
21d7 f1			.pastdmark: pop af  
21d8			endm  
# End of macro DMARK
21d8						CALLMONITOR 
21d8 cd 39 14			call break_point_state  
21db				endm  
# End of macro CALLMONITOR
21db					endif 
21db					FORTH_DSP_VALUEHL 
21db cd bd 1b			call macro_dsp_valuehl 
21de				endm 
# End of macro FORTH_DSP_VALUEHL
21de e5					push hl      ; 2 
21df			 
21df					FORTH_DSP_POP 
21df cd 75 1c			call macro_forth_dsp_pop 
21e2				endm 
# End of macro FORTH_DSP_POP
21e2					 
21e2					FORTH_DSP_VALUEHL 
21e2 cd bd 1b			call macro_dsp_valuehl 
21e5				endm 
# End of macro FORTH_DSP_VALUEHL
21e5			;		push hl      ; 1 
21e5			 
21e5					FORTH_DSP_POP 
21e5 cd 75 1c			call macro_forth_dsp_pop 
21e8				endm 
# End of macro FORTH_DSP_POP
21e8			 
21e8			;		pop hl       ; 1 
21e8 d1					pop de       ; 2 
21e9			 
21e9 cd c6 19				call forth_push_numhl 
21ec eb					ex de, hl 
21ed cd c6 19				call forth_push_numhl 
21f0			 
21f0					 
21f0 eb					ex de, hl 
21f1			 
21f1 cd c6 19				call forth_push_numhl 
21f4 eb					ex de, hl 
21f5 cd c6 19				call forth_push_numhl 
21f8			 
21f8			 
21f8					NEXTW 
21f8 c3 2f 1d			jp macro_next 
21fb				endm 
# End of macro NEXTW
21fb			.DROP2: 
21fb				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21fb 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21fc 2a 22			dw .SWAP2            
21fe 06				db 5 + 1 
21ff .. 00			db "2DROP",0              
2205				endm 
# End of macro CWHEAD
2205			; | 2DROP ( w w -- )    Double drop | DONE 
2205					if DEBUG_FORTH_WORDS_KEY 
2205						DMARK "2DR" 
2205 f5				push af  
2206 3a 1a 22			ld a, (.dmark)  
2209 32 7a ee			ld (debug_mark),a  
220c 3a 1b 22			ld a, (.dmark+1)  
220f 32 7b ee			ld (debug_mark+1),a  
2212 3a 1c 22			ld a, (.dmark+2)  
2215 32 7c ee			ld (debug_mark+2),a  
2218 18 03			jr .pastdmark  
221a ..			.dmark: db "2DR"  
221d f1			.pastdmark: pop af  
221e			endm  
# End of macro DMARK
221e						CALLMONITOR 
221e cd 39 14			call break_point_state  
2221				endm  
# End of macro CALLMONITOR
2221					endif 
2221					FORTH_DSP_POP 
2221 cd 75 1c			call macro_forth_dsp_pop 
2224				endm 
# End of macro FORTH_DSP_POP
2224					FORTH_DSP_POP 
2224 cd 75 1c			call macro_forth_dsp_pop 
2227				endm 
# End of macro FORTH_DSP_POP
2227					NEXTW 
2227 c3 2f 1d			jp macro_next 
222a				endm 
# End of macro NEXTW
222a			.SWAP2: 
222a				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
222a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
222b 53 22			dw .AT            
222d 06				db 5 + 1 
222e .. 00			db "2SWAP",0              
2234				endm 
# End of macro CWHEAD
2234			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2234					if DEBUG_FORTH_WORDS_KEY 
2234						DMARK "2SW" 
2234 f5				push af  
2235 3a 49 22			ld a, (.dmark)  
2238 32 7a ee			ld (debug_mark),a  
223b 3a 4a 22			ld a, (.dmark+1)  
223e 32 7b ee			ld (debug_mark+1),a  
2241 3a 4b 22			ld a, (.dmark+2)  
2244 32 7c ee			ld (debug_mark+2),a  
2247 18 03			jr .pastdmark  
2249 ..			.dmark: db "2SW"  
224c f1			.pastdmark: pop af  
224d			endm  
# End of macro DMARK
224d						CALLMONITOR 
224d cd 39 14			call break_point_state  
2250				endm  
# End of macro CALLMONITOR
2250					endif 
2250					NEXTW 
2250 c3 2f 1d			jp macro_next 
2253				endm 
# End of macro NEXTW
2253			.AT: 
2253				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2253 1f				db WORD_SYS_CORE+OPCODE_AT             
2254 85 22			dw .CAT            
2256 02				db 1 + 1 
2257 .. 00			db "@",0              
2259				endm 
# End of macro CWHEAD
2259			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2259			 
2259					if DEBUG_FORTH_WORDS_KEY 
2259						DMARK "AT." 
2259 f5				push af  
225a 3a 6e 22			ld a, (.dmark)  
225d 32 7a ee			ld (debug_mark),a  
2260 3a 6f 22			ld a, (.dmark+1)  
2263 32 7b ee			ld (debug_mark+1),a  
2266 3a 70 22			ld a, (.dmark+2)  
2269 32 7c ee			ld (debug_mark+2),a  
226c 18 03			jr .pastdmark  
226e ..			.dmark: db "AT."  
2271 f1			.pastdmark: pop af  
2272			endm  
# End of macro DMARK
2272						CALLMONITOR 
2272 cd 39 14			call break_point_state  
2275				endm  
# End of macro CALLMONITOR
2275					endif 
2275			.getbyteat:	 
2275					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2275 cd bd 1b			call macro_dsp_valuehl 
2278				endm 
# End of macro FORTH_DSP_VALUEHL
2278					 
2278			;		push hl 
2278				 
2278					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2278 cd 75 1c			call macro_forth_dsp_pop 
227b				endm 
# End of macro FORTH_DSP_POP
227b			 
227b			;		pop hl 
227b			 
227b 7e					ld a, (hl) 
227c			 
227c 6f					ld l, a 
227d 26 00				ld h, 0 
227f cd c6 19				call forth_push_numhl 
2282			 
2282					NEXTW 
2282 c3 2f 1d			jp macro_next 
2285				endm 
# End of macro NEXTW
2285			.CAT: 
2285				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2285 20				db WORD_SYS_CORE+OPCODE_CAT             
2286 ae 22			dw .BANG            
2288 03				db 2 + 1 
2289 .. 00			db "C@",0              
228c				endm 
# End of macro CWHEAD
228c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
228c					if DEBUG_FORTH_WORDS_KEY 
228c						DMARK "CAA" 
228c f5				push af  
228d 3a a1 22			ld a, (.dmark)  
2290 32 7a ee			ld (debug_mark),a  
2293 3a a2 22			ld a, (.dmark+1)  
2296 32 7b ee			ld (debug_mark+1),a  
2299 3a a3 22			ld a, (.dmark+2)  
229c 32 7c ee			ld (debug_mark+2),a  
229f 18 03			jr .pastdmark  
22a1 ..			.dmark: db "CAA"  
22a4 f1			.pastdmark: pop af  
22a5			endm  
# End of macro DMARK
22a5						CALLMONITOR 
22a5 cd 39 14			call break_point_state  
22a8				endm  
# End of macro CALLMONITOR
22a8					endif 
22a8 c3 75 22				jp .getbyteat 
22ab					NEXTW 
22ab c3 2f 1d			jp macro_next 
22ae				endm 
# End of macro NEXTW
22ae			.BANG: 
22ae				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
22ae 21				db WORD_SYS_CORE+OPCODE_BANG             
22af e4 22			dw .CBANG            
22b1 02				db 1 + 1 
22b2 .. 00			db "!",0              
22b4				endm 
# End of macro CWHEAD
22b4			; | ! ( x w -- ) Store x at address w      | DONE 
22b4					if DEBUG_FORTH_WORDS_KEY 
22b4						DMARK "BNG" 
22b4 f5				push af  
22b5 3a c9 22			ld a, (.dmark)  
22b8 32 7a ee			ld (debug_mark),a  
22bb 3a ca 22			ld a, (.dmark+1)  
22be 32 7b ee			ld (debug_mark+1),a  
22c1 3a cb 22			ld a, (.dmark+2)  
22c4 32 7c ee			ld (debug_mark+2),a  
22c7 18 03			jr .pastdmark  
22c9 ..			.dmark: db "BNG"  
22cc f1			.pastdmark: pop af  
22cd			endm  
# End of macro DMARK
22cd						CALLMONITOR 
22cd cd 39 14			call break_point_state  
22d0				endm  
# End of macro CALLMONITOR
22d0					endif 
22d0			 
22d0			.storebyteat:		 
22d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22d0 cd bd 1b			call macro_dsp_valuehl 
22d3				endm 
# End of macro FORTH_DSP_VALUEHL
22d3					 
22d3 e5					push hl 
22d4				 
22d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22d4 cd 75 1c			call macro_forth_dsp_pop 
22d7				endm 
# End of macro FORTH_DSP_POP
22d7			 
22d7					; get byte to poke 
22d7			 
22d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22d7 cd bd 1b			call macro_dsp_valuehl 
22da				endm 
# End of macro FORTH_DSP_VALUEHL
22da e5					push hl 
22db			 
22db			 
22db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22db cd 75 1c			call macro_forth_dsp_pop 
22de				endm 
# End of macro FORTH_DSP_POP
22de			 
22de			 
22de d1					pop de 
22df e1					pop hl 
22e0			 
22e0 73					ld (hl),e 
22e1			 
22e1			 
22e1					NEXTW 
22e1 c3 2f 1d			jp macro_next 
22e4				endm 
# End of macro NEXTW
22e4			.CBANG: 
22e4				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22e4 22				db WORD_SYS_CORE+OPCODE_CBANG             
22e5 0d 23			dw .SCALL            
22e7 03				db 2 + 1 
22e8 .. 00			db "C!",0              
22eb				endm 
# End of macro CWHEAD
22eb			; | C!  ( x w -- ) Store x at address w  | DONE 
22eb					if DEBUG_FORTH_WORDS_KEY 
22eb						DMARK "CBA" 
22eb f5				push af  
22ec 3a 00 23			ld a, (.dmark)  
22ef 32 7a ee			ld (debug_mark),a  
22f2 3a 01 23			ld a, (.dmark+1)  
22f5 32 7b ee			ld (debug_mark+1),a  
22f8 3a 02 23			ld a, (.dmark+2)  
22fb 32 7c ee			ld (debug_mark+2),a  
22fe 18 03			jr .pastdmark  
2300 ..			.dmark: db "CBA"  
2303 f1			.pastdmark: pop af  
2304			endm  
# End of macro DMARK
2304						CALLMONITOR 
2304 cd 39 14			call break_point_state  
2307				endm  
# End of macro CALLMONITOR
2307					endif 
2307 c3 d0 22				jp .storebyteat 
230a					NEXTW 
230a c3 2f 1d			jp macro_next 
230d				endm 
# End of macro NEXTW
230d			.SCALL: 
230d				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
230d 23				db WORD_SYS_CORE+OPCODE_SCALL             
230e 41 23			dw .DEPTH            
2310 05				db 4 + 1 
2311 .. 00			db "CALL",0              
2316				endm 
# End of macro CWHEAD
2316			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2316					if DEBUG_FORTH_WORDS_KEY 
2316						DMARK "CLL" 
2316 f5				push af  
2317 3a 2b 23			ld a, (.dmark)  
231a 32 7a ee			ld (debug_mark),a  
231d 3a 2c 23			ld a, (.dmark+1)  
2320 32 7b ee			ld (debug_mark+1),a  
2323 3a 2d 23			ld a, (.dmark+2)  
2326 32 7c ee			ld (debug_mark+2),a  
2329 18 03			jr .pastdmark  
232b ..			.dmark: db "CLL"  
232e f1			.pastdmark: pop af  
232f			endm  
# End of macro DMARK
232f						CALLMONITOR 
232f cd 39 14			call break_point_state  
2332				endm  
# End of macro CALLMONITOR
2332					endif 
2332			 
2332					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2332 cd bd 1b			call macro_dsp_valuehl 
2335				endm 
# End of macro FORTH_DSP_VALUEHL
2335			 
2335			;		push hl 
2335			 
2335					; destroy value TOS 
2335			 
2335					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2335 cd 75 1c			call macro_forth_dsp_pop 
2338				endm 
# End of macro FORTH_DSP_POP
2338			 
2338						 
2338			;		pop hl 
2338			 
2338					; how to do a call with hl???? save SP? 
2338 cd d8 1c				call forth_call_hl 
233b			 
233b			 
233b					; TODO push value back onto stack for another op etc 
233b			 
233b cd c6 19				call forth_push_numhl 
233e					NEXTW 
233e c3 2f 1d			jp macro_next 
2341				endm 
# End of macro NEXTW
2341			.DEPTH: 
2341				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2341 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2342 7e 23			dw .OVER            
2344 06				db 5 + 1 
2345 .. 00			db "DEPTH",0              
234b				endm 
# End of macro CWHEAD
234b			; | DEPTH ( -- u ) Push count of stack | DONE 
234b					; take current TOS and remove from base value div by two to get count 
234b					if DEBUG_FORTH_WORDS_KEY 
234b						DMARK "DEP" 
234b f5				push af  
234c 3a 60 23			ld a, (.dmark)  
234f 32 7a ee			ld (debug_mark),a  
2352 3a 61 23			ld a, (.dmark+1)  
2355 32 7b ee			ld (debug_mark+1),a  
2358 3a 62 23			ld a, (.dmark+2)  
235b 32 7c ee			ld (debug_mark+2),a  
235e 18 03			jr .pastdmark  
2360 ..			.dmark: db "DEP"  
2363 f1			.pastdmark: pop af  
2364			endm  
# End of macro DMARK
2364						CALLMONITOR 
2364 cd 39 14			call break_point_state  
2367				endm  
# End of macro CALLMONITOR
2367					endif 
2367			 
2367			 
2367 2a 0d eb			ld hl, (cli_data_sp) 
236a 11 c7 e8			ld de, cli_data_stack 
236d ed 52			sbc hl,de 
236f				 
236f				; div by size of stack item 
236f			 
236f 5d				ld e,l 
2370 0e 03			ld c, 3 
2372 cd 56 0b			call Div8 
2375			 
2375 6f				ld l,a 
2376 26 00			ld h,0 
2378			 
2378				;srl h 
2378				;rr l 
2378			 
2378 cd c6 19				call forth_push_numhl 
237b					NEXTW 
237b c3 2f 1d			jp macro_next 
237e				endm 
# End of macro NEXTW
237e			.OVER: 
237e				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
237e 42				db WORD_SYS_CORE+46             
237f c5 23			dw .PAUSE            
2381 05				db 4 + 1 
2382 .. 00			db "OVER",0              
2387				endm 
# End of macro CWHEAD
2387			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2387					if DEBUG_FORTH_WORDS_KEY 
2387						DMARK "OVR" 
2387 f5				push af  
2388 3a 9c 23			ld a, (.dmark)  
238b 32 7a ee			ld (debug_mark),a  
238e 3a 9d 23			ld a, (.dmark+1)  
2391 32 7b ee			ld (debug_mark+1),a  
2394 3a 9e 23			ld a, (.dmark+2)  
2397 32 7c ee			ld (debug_mark+2),a  
239a 18 03			jr .pastdmark  
239c ..			.dmark: db "OVR"  
239f f1			.pastdmark: pop af  
23a0			endm  
# End of macro DMARK
23a0						CALLMONITOR 
23a0 cd 39 14			call break_point_state  
23a3				endm  
# End of macro CALLMONITOR
23a3					endif 
23a3			 
23a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23a3 cd bd 1b			call macro_dsp_valuehl 
23a6				endm 
# End of macro FORTH_DSP_VALUEHL
23a6 e5					push hl    ; n2 
23a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23a7 cd 75 1c			call macro_forth_dsp_pop 
23aa				endm 
# End of macro FORTH_DSP_POP
23aa			 
23aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23aa cd bd 1b			call macro_dsp_valuehl 
23ad				endm 
# End of macro FORTH_DSP_VALUEHL
23ad e5					push hl    ; n1 
23ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ae cd 75 1c			call macro_forth_dsp_pop 
23b1				endm 
# End of macro FORTH_DSP_POP
23b1			 
23b1 d1					pop de     ; n1 
23b2 e1					pop hl     ; n2 
23b3			 
23b3 d5					push de 
23b4 e5					push hl 
23b5 d5					push de 
23b6			 
23b6					; push back  
23b6			 
23b6 e1					pop hl 
23b7 cd c6 19				call forth_push_numhl 
23ba e1					pop hl 
23bb cd c6 19				call forth_push_numhl 
23be e1					pop hl 
23bf cd c6 19				call forth_push_numhl 
23c2					NEXTW 
23c2 c3 2f 1d			jp macro_next 
23c5				endm 
# End of macro NEXTW
23c5			 
23c5			.PAUSE: 
23c5				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
23c5 43				db WORD_SYS_CORE+47             
23c6 fa 23			dw .PAUSES            
23c8 08				db 7 + 1 
23c9 .. 00			db "PAUSEMS",0              
23d1				endm 
# End of macro CWHEAD
23d1			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
23d1					if DEBUG_FORTH_WORDS_KEY 
23d1						DMARK "PMS" 
23d1 f5				push af  
23d2 3a e6 23			ld a, (.dmark)  
23d5 32 7a ee			ld (debug_mark),a  
23d8 3a e7 23			ld a, (.dmark+1)  
23db 32 7b ee			ld (debug_mark+1),a  
23de 3a e8 23			ld a, (.dmark+2)  
23e1 32 7c ee			ld (debug_mark+2),a  
23e4 18 03			jr .pastdmark  
23e6 ..			.dmark: db "PMS"  
23e9 f1			.pastdmark: pop af  
23ea			endm  
# End of macro DMARK
23ea						CALLMONITOR 
23ea cd 39 14			call break_point_state  
23ed				endm  
# End of macro CALLMONITOR
23ed					endif 
23ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ed cd bd 1b			call macro_dsp_valuehl 
23f0				endm 
# End of macro FORTH_DSP_VALUEHL
23f0			;		push hl    ; n2 
23f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23f0 cd 75 1c			call macro_forth_dsp_pop 
23f3				endm 
# End of macro FORTH_DSP_POP
23f3			;		pop hl 
23f3			 
23f3 7d					ld a, l 
23f4 cd f3 08				call aDelayInMS 
23f7				       NEXTW 
23f7 c3 2f 1d			jp macro_next 
23fa				endm 
# End of macro NEXTW
23fa			.PAUSES:  
23fa				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23fa 44				db WORD_SYS_CORE+48             
23fb 69 24			dw .ROT            
23fd 06				db 5 + 1 
23fe .. 00			db "PAUSE",0              
2404				endm 
# End of macro CWHEAD
2404			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2404					if DEBUG_FORTH_WORDS_KEY 
2404						DMARK "PAU" 
2404 f5				push af  
2405 3a 19 24			ld a, (.dmark)  
2408 32 7a ee			ld (debug_mark),a  
240b 3a 1a 24			ld a, (.dmark+1)  
240e 32 7b ee			ld (debug_mark+1),a  
2411 3a 1b 24			ld a, (.dmark+2)  
2414 32 7c ee			ld (debug_mark+2),a  
2417 18 03			jr .pastdmark  
2419 ..			.dmark: db "PAU"  
241c f1			.pastdmark: pop af  
241d			endm  
# End of macro DMARK
241d						CALLMONITOR 
241d cd 39 14			call break_point_state  
2420				endm  
# End of macro CALLMONITOR
2420					endif 
2420					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2420 cd bd 1b			call macro_dsp_valuehl 
2423				endm 
# End of macro FORTH_DSP_VALUEHL
2423			;		push hl    ; n2 
2423					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2423 cd 75 1c			call macro_forth_dsp_pop 
2426				endm 
# End of macro FORTH_DSP_POP
2426			;		pop hl 
2426 45					ld b, l 
2427					if DEBUG_FORTH_WORDS 
2427						DMARK "PAU" 
2427 f5				push af  
2428 3a 3c 24			ld a, (.dmark)  
242b 32 7a ee			ld (debug_mark),a  
242e 3a 3d 24			ld a, (.dmark+1)  
2431 32 7b ee			ld (debug_mark+1),a  
2434 3a 3e 24			ld a, (.dmark+2)  
2437 32 7c ee			ld (debug_mark+2),a  
243a 18 03			jr .pastdmark  
243c ..			.dmark: db "PAU"  
243f f1			.pastdmark: pop af  
2440			endm  
# End of macro DMARK
2440						CALLMONITOR 
2440 cd 39 14			call break_point_state  
2443				endm  
# End of macro CALLMONITOR
2443					endif 
2443 c5			.pauses1:	push bc 
2444 cd 0e 09				call delay1s 
2447 c1					pop bc 
2448					if DEBUG_FORTH_WORDS 
2448						DMARK "PA1" 
2448 f5				push af  
2449 3a 5d 24			ld a, (.dmark)  
244c 32 7a ee			ld (debug_mark),a  
244f 3a 5e 24			ld a, (.dmark+1)  
2452 32 7b ee			ld (debug_mark+1),a  
2455 3a 5f 24			ld a, (.dmark+2)  
2458 32 7c ee			ld (debug_mark+2),a  
245b 18 03			jr .pastdmark  
245d ..			.dmark: db "PA1"  
2460 f1			.pastdmark: pop af  
2461			endm  
# End of macro DMARK
2461						CALLMONITOR 
2461 cd 39 14			call break_point_state  
2464				endm  
# End of macro CALLMONITOR
2464					endif 
2464 10 dd				djnz .pauses1 
2466			 
2466				       NEXTW 
2466 c3 2f 1d			jp macro_next 
2469				endm 
# End of macro NEXTW
2469			.ROT: 
2469				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2469 45				db WORD_SYS_CORE+49             
246a b7 24			dw .UWORDS            
246c 04				db 3 + 1 
246d .. 00			db "ROT",0              
2471				endm 
# End of macro CWHEAD
2471			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2471					if DEBUG_FORTH_WORDS_KEY 
2471						DMARK "ROT" 
2471 f5				push af  
2472 3a 86 24			ld a, (.dmark)  
2475 32 7a ee			ld (debug_mark),a  
2478 3a 87 24			ld a, (.dmark+1)  
247b 32 7b ee			ld (debug_mark+1),a  
247e 3a 88 24			ld a, (.dmark+2)  
2481 32 7c ee			ld (debug_mark+2),a  
2484 18 03			jr .pastdmark  
2486 ..			.dmark: db "ROT"  
2489 f1			.pastdmark: pop af  
248a			endm  
# End of macro DMARK
248a						CALLMONITOR 
248a cd 39 14			call break_point_state  
248d				endm  
# End of macro CALLMONITOR
248d					endif 
248d			 
248d					FORTH_DSP_VALUEHL 
248d cd bd 1b			call macro_dsp_valuehl 
2490				endm 
# End of macro FORTH_DSP_VALUEHL
2490 e5					push hl    ; u3  
2491			 
2491					FORTH_DSP_POP 
2491 cd 75 1c			call macro_forth_dsp_pop 
2494				endm 
# End of macro FORTH_DSP_POP
2494			   
2494					FORTH_DSP_VALUEHL 
2494 cd bd 1b			call macro_dsp_valuehl 
2497				endm 
# End of macro FORTH_DSP_VALUEHL
2497 e5					push hl     ; u2 
2498			 
2498					FORTH_DSP_POP 
2498 cd 75 1c			call macro_forth_dsp_pop 
249b				endm 
# End of macro FORTH_DSP_POP
249b			 
249b					FORTH_DSP_VALUEHL 
249b cd bd 1b			call macro_dsp_valuehl 
249e				endm 
# End of macro FORTH_DSP_VALUEHL
249e e5					push hl     ; u1 
249f			 
249f					FORTH_DSP_POP 
249f cd 75 1c			call macro_forth_dsp_pop 
24a2				endm 
# End of macro FORTH_DSP_POP
24a2			 
24a2 c1					pop bc      ; u1 
24a3 e1					pop hl      ; u2 
24a4 d1					pop de      ; u3 
24a5			 
24a5			 
24a5 c5					push bc 
24a6 d5					push de 
24a7 e5					push hl 
24a8			 
24a8			 
24a8 e1					pop hl 
24a9 cd c6 19				call forth_push_numhl 
24ac			 
24ac e1					pop hl 
24ad cd c6 19				call forth_push_numhl 
24b0			 
24b0 e1					pop hl 
24b1 cd c6 19				call forth_push_numhl 
24b4					 
24b4			 
24b4			 
24b4			 
24b4			 
24b4			 
24b4				       NEXTW 
24b4 c3 2f 1d			jp macro_next 
24b7				endm 
# End of macro NEXTW
24b7			 
24b7			.UWORDS: 
24b7				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24b7 50				db WORD_SYS_CORE+60             
24b8 79 25			dw .BP            
24ba 07				db 6 + 1 
24bb .. 00			db "UWORDS",0              
24c2				endm 
# End of macro CWHEAD
24c2			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
24c2			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
24c2			; | | Following the count are the individual words. 
24c2			; | | 
24c2			; | | e.g. UWORDS 
24c2			; | | BOX DIRLIST 2 
24c2			; | |  
24c2			; | | Can be used to save the words to storage via: 
24c2			; | | UWORDS $01 DO $01 APPEND LOOP 
24c2				if DEBUG_FORTH_WORDS_KEY 
24c2					DMARK "UWR" 
24c2 f5				push af  
24c3 3a d7 24			ld a, (.dmark)  
24c6 32 7a ee			ld (debug_mark),a  
24c9 3a d8 24			ld a, (.dmark+1)  
24cc 32 7b ee			ld (debug_mark+1),a  
24cf 3a d9 24			ld a, (.dmark+2)  
24d2 32 7c ee			ld (debug_mark+2),a  
24d5 18 03			jr .pastdmark  
24d7 ..			.dmark: db "UWR"  
24da f1			.pastdmark: pop af  
24db			endm  
# End of macro DMARK
24db					CALLMONITOR 
24db cd 39 14			call break_point_state  
24de				endm  
# End of macro CALLMONITOR
24de				endif 
24de 21 d8 58				ld hl, baseram 
24e1					;ld hl, baseusermem 
24e1 01 00 00				ld bc, 0    ; start a counter 
24e4			 
24e4				; skip dict stub 
24e4			 
24e4 cd 80 1e				call forth_tok_next 
24e7			 
24e7			 
24e7			; while we have words to look for 
24e7			 
24e7 7e			.douscan:	ld a, (hl)      
24e8				if DEBUG_FORTH_WORDS 
24e8					DMARK "UWs" 
24e8 f5				push af  
24e9 3a fd 24			ld a, (.dmark)  
24ec 32 7a ee			ld (debug_mark),a  
24ef 3a fe 24			ld a, (.dmark+1)  
24f2 32 7b ee			ld (debug_mark+1),a  
24f5 3a ff 24			ld a, (.dmark+2)  
24f8 32 7c ee			ld (debug_mark+2),a  
24fb 18 03			jr .pastdmark  
24fd ..			.dmark: db "UWs"  
2500 f1			.pastdmark: pop af  
2501			endm  
# End of macro DMARK
2501					CALLMONITOR 
2501 cd 39 14			call break_point_state  
2504				endm  
# End of macro CALLMONITOR
2504				endif 
2504 fe 00				cp WORD_SYS_END 
2506 28 4d				jr z, .udone 
2508 fe 01				cp WORD_SYS_UWORD 
250a 20 44				jr nz, .nuword 
250c			 
250c				if DEBUG_FORTH_WORDS 
250c					DMARK "UWu" 
250c f5				push af  
250d 3a 21 25			ld a, (.dmark)  
2510 32 7a ee			ld (debug_mark),a  
2513 3a 22 25			ld a, (.dmark+1)  
2516 32 7b ee			ld (debug_mark+1),a  
2519 3a 23 25			ld a, (.dmark+2)  
251c 32 7c ee			ld (debug_mark+2),a  
251f 18 03			jr .pastdmark  
2521 ..			.dmark: db "UWu"  
2524 f1			.pastdmark: pop af  
2525			endm  
# End of macro DMARK
2525					CALLMONITOR 
2525 cd 39 14			call break_point_state  
2528				endm  
# End of macro CALLMONITOR
2528				endif 
2528					; we have a uword so push its name to the stack 
2528			 
2528 e5				   	push hl  ; save so we can move to next dict block 
2529			 
2529					; skip opcode 
2529 23					inc hl  
252a					; skip next ptr 
252a 23					inc hl  
252b 23					inc hl 
252c					; skip len 
252c 23					inc hl 
252d				if DEBUG_FORTH_WORDS 
252d					DMARK "UWt" 
252d f5				push af  
252e 3a 42 25			ld a, (.dmark)  
2531 32 7a ee			ld (debug_mark),a  
2534 3a 43 25			ld a, (.dmark+1)  
2537 32 7b ee			ld (debug_mark+1),a  
253a 3a 44 25			ld a, (.dmark+2)  
253d 32 7c ee			ld (debug_mark+2),a  
2540 18 03			jr .pastdmark  
2542 ..			.dmark: db "UWt"  
2545 f1			.pastdmark: pop af  
2546			endm  
# End of macro DMARK
2546					CALLMONITOR 
2546 cd 39 14			call break_point_state  
2549				endm  
# End of macro CALLMONITOR
2549				endif 
2549 03					inc bc 
254a			 
254a c5					push bc 
254b cd 34 1a				call forth_push_str 
254e c1					pop bc 
254f			 
254f e1					pop hl 	 
2550			 
2550 cd 80 1e		.nuword:	call forth_tok_next 
2553 18 92				jr .douscan  
2555			 
2555			.udone:		 ; push count of uwords found 
2555 c5					push bc 
2556 e1					pop hl 
2557			 
2557				if DEBUG_FORTH_WORDS 
2557					DMARK "UWc" 
2557 f5				push af  
2558 3a 6c 25			ld a, (.dmark)  
255b 32 7a ee			ld (debug_mark),a  
255e 3a 6d 25			ld a, (.dmark+1)  
2561 32 7b ee			ld (debug_mark+1),a  
2564 3a 6e 25			ld a, (.dmark+2)  
2567 32 7c ee			ld (debug_mark+2),a  
256a 18 03			jr .pastdmark  
256c ..			.dmark: db "UWc"  
256f f1			.pastdmark: pop af  
2570			endm  
# End of macro DMARK
2570					CALLMONITOR 
2570 cd 39 14			call break_point_state  
2573				endm  
# End of macro CALLMONITOR
2573				endif 
2573 cd c6 19				call forth_push_numhl 
2576			 
2576			 
2576				       NEXTW 
2576 c3 2f 1d			jp macro_next 
2579				endm 
# End of macro NEXTW
2579			 
2579			.BP: 
2579				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2579 54				db WORD_SYS_CORE+64             
257a af 25			dw .MONITOR            
257c 03				db 2 + 1 
257d .. 00			db "BP",0              
2580				endm 
# End of macro CWHEAD
2580			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2580			; | | $00 Will enable the break points within specific code paths 
2580			; | | $01 Will disable break points 
2580			; | |  
2580			; | | By default break points are off. Either the above can be used to enable them 
2580			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2580			; | | and on release of the pressed key a message will be disaplayed to notify 
2580			; | | that break points are enabled. Pressing any key will then continue boot process. 
2580					; get byte count 
2580					if DEBUG_FORTH_WORDS_KEY 
2580						DMARK "BP." 
2580 f5				push af  
2581 3a 95 25			ld a, (.dmark)  
2584 32 7a ee			ld (debug_mark),a  
2587 3a 96 25			ld a, (.dmark+1)  
258a 32 7b ee			ld (debug_mark+1),a  
258d 3a 97 25			ld a, (.dmark+2)  
2590 32 7c ee			ld (debug_mark+2),a  
2593 18 03			jr .pastdmark  
2595 ..			.dmark: db "BP."  
2598 f1			.pastdmark: pop af  
2599			endm  
# End of macro DMARK
2599						CALLMONITOR 
2599 cd 39 14			call break_point_state  
259c				endm  
# End of macro CALLMONITOR
259c					endif 
259c			 
259c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259c cd bd 1b			call macro_dsp_valuehl 
259f				endm 
# End of macro FORTH_DSP_VALUEHL
259f			 
259f			;		push hl 
259f			 
259f					; destroy value TOS 
259f			 
259f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259f cd 75 1c			call macro_forth_dsp_pop 
25a2				endm 
# End of macro FORTH_DSP_POP
25a2			 
25a2			;		pop hl 
25a2			 
25a2 3e 00				ld a,0 
25a4 bd					cp l 
25a5 28 02				jr z, .bpset 
25a7 3e 2a				ld a, '*' 
25a9			 
25a9 32 51 e3		.bpset:		ld (os_view_disable), a 
25ac			 
25ac			 
25ac					NEXTW 
25ac c3 2f 1d			jp macro_next 
25af				endm 
# End of macro NEXTW
25af			 
25af			 
25af			.MONITOR: 
25af				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
25af 55				db WORD_SYS_CORE+65             
25b0 e2 25			dw .MALLOC            
25b2 08				db 7 + 1 
25b3 .. 00			db "MONITOR",0              
25bb				endm 
# End of macro CWHEAD
25bb			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25bb			; | | At start the current various registers will be displayed with contents. 
25bb			; | | Top right corner will show the most recent debug marker seen. 
25bb			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25bb			; | | and the return stack pointer (RSP). 
25bb			; | | Pressing: 
25bb			; | |    1 - Initial screen 
25bb			; | |    2 - Display a data dump of HL 
25bb			; | |    3 - Display a data dump of DE 
25bb			; | |    4 - Display a data dump of BC 
25bb			; | |    5 - Display a data dump of HL 
25bb			; | |    6 - Display a data dump of DSP 
25bb			; | |    7 - Display a data dump of RSP 
25bb			; | |    8 - Display a data dump of what is at DSP 
25bb			; | |    9 - Display a data dump of what is at RSP 
25bb			; | |    0 - Exit monitor and continue running. This will also enable break points 
25bb			; | |    * - Disable break points 
25bb			; | |    # - Enter traditional monitor mode 
25bb			; | | 
25bb			; | | Monitor Mode 
25bb			; | | ------------ 
25bb			; | | A prompt of '>' will be shown for various commands: 
25bb			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25bb			; | |    C - Continue display a data dump from the last set address 
25bb			; | |    M xxxx - Set start of memory edit at address xx 
25bb			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25bb			; | |    Q - Return to previous 
25bb					if DEBUG_FORTH_WORDS_KEY 
25bb						DMARK "MON" 
25bb f5				push af  
25bc 3a d0 25			ld a, (.dmark)  
25bf 32 7a ee			ld (debug_mark),a  
25c2 3a d1 25			ld a, (.dmark+1)  
25c5 32 7b ee			ld (debug_mark+1),a  
25c8 3a d2 25			ld a, (.dmark+2)  
25cb 32 7c ee			ld (debug_mark+2),a  
25ce 18 03			jr .pastdmark  
25d0 ..			.dmark: db "MON"  
25d3 f1			.pastdmark: pop af  
25d4			endm  
# End of macro DMARK
25d4						CALLMONITOR 
25d4 cd 39 14			call break_point_state  
25d7				endm  
# End of macro CALLMONITOR
25d7					endif 
25d7 3e 00				ld a, 0 
25d9 32 51 e3				ld (os_view_disable), a 
25dc			 
25dc					CALLMONITOR 
25dc cd 39 14			call break_point_state  
25df				endm  
# End of macro CALLMONITOR
25df			 
25df			;	call monitor 
25df			 
25df					NEXTW 
25df c3 2f 1d			jp macro_next 
25e2				endm 
# End of macro NEXTW
25e2			 
25e2			 
25e2			.MALLOC: 
25e2				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
25e2 56				db WORD_SYS_CORE+66             
25e3 0b 26			dw .MALLOC2            
25e5 06				db 5 + 1 
25e6 .. 00			db "ALLOT",0              
25ec				endm 
# End of macro CWHEAD
25ec			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25ec					if DEBUG_FORTH_WORDS_KEY 
25ec						DMARK "ALL" 
25ec f5				push af  
25ed 3a 01 26			ld a, (.dmark)  
25f0 32 7a ee			ld (debug_mark),a  
25f3 3a 02 26			ld a, (.dmark+1)  
25f6 32 7b ee			ld (debug_mark+1),a  
25f9 3a 03 26			ld a, (.dmark+2)  
25fc 32 7c ee			ld (debug_mark+2),a  
25ff 18 03			jr .pastdmark  
2601 ..			.dmark: db "ALL"  
2604 f1			.pastdmark: pop af  
2605			endm  
# End of macro DMARK
2605						CALLMONITOR 
2605 cd 39 14			call break_point_state  
2608				endm  
# End of macro CALLMONITOR
2608					endif 
2608 c3 32 26				jp .mallocc 
260b			.MALLOC2: 
260b				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
260b 56				db WORD_SYS_CORE+66             
260c 49 26			dw .FREE            
260e 07				db 6 + 1 
260f .. 00			db "MALLOC",0              
2616				endm 
# End of macro CWHEAD
2616			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2616					; get byte count 
2616					if DEBUG_FORTH_WORDS_KEY 
2616						DMARK "MAL" 
2616 f5				push af  
2617 3a 2b 26			ld a, (.dmark)  
261a 32 7a ee			ld (debug_mark),a  
261d 3a 2c 26			ld a, (.dmark+1)  
2620 32 7b ee			ld (debug_mark+1),a  
2623 3a 2d 26			ld a, (.dmark+2)  
2626 32 7c ee			ld (debug_mark+2),a  
2629 18 03			jr .pastdmark  
262b ..			.dmark: db "MAL"  
262e f1			.pastdmark: pop af  
262f			endm  
# End of macro DMARK
262f						CALLMONITOR 
262f cd 39 14			call break_point_state  
2632				endm  
# End of macro CALLMONITOR
2632					endif 
2632			.mallocc: 
2632					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2632 cd bd 1b			call macro_dsp_valuehl 
2635				endm 
# End of macro FORTH_DSP_VALUEHL
2635			 
2635			;		push hl 
2635			 
2635					; destroy value TOS 
2635			 
2635					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2635 cd 75 1c			call macro_forth_dsp_pop 
2638				endm 
# End of macro FORTH_DSP_POP
2638			 
2638			;		pop hl 
2638 cd 8d 10				call malloc 
263b				if DEBUG_FORTH_MALLOC_GUARD 
263b f5					push af 
263c cd ef 0b				call ishlzero 
263f			;		ld a, l 
263f			;		add h 
263f			;		cp 0 
263f f1					pop af 
2640					 
2640 cc 35 45				call z,malloc_error 
2643				endif 
2643			 
2643 cd c6 19				call forth_push_numhl 
2646					NEXTW 
2646 c3 2f 1d			jp macro_next 
2649				endm 
# End of macro NEXTW
2649			 
2649			.FREE: 
2649				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2649 57				db WORD_SYS_CORE+67             
264a 7a 26			dw .LIST            
264c 05				db 4 + 1 
264d .. 00			db "FREE",0              
2652				endm 
# End of macro CWHEAD
2652			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2652					if DEBUG_FORTH_WORDS_KEY 
2652						DMARK "FRE" 
2652 f5				push af  
2653 3a 67 26			ld a, (.dmark)  
2656 32 7a ee			ld (debug_mark),a  
2659 3a 68 26			ld a, (.dmark+1)  
265c 32 7b ee			ld (debug_mark+1),a  
265f 3a 69 26			ld a, (.dmark+2)  
2662 32 7c ee			ld (debug_mark+2),a  
2665 18 03			jr .pastdmark  
2667 ..			.dmark: db "FRE"  
266a f1			.pastdmark: pop af  
266b			endm  
# End of macro DMARK
266b						CALLMONITOR 
266b cd 39 14			call break_point_state  
266e				endm  
# End of macro CALLMONITOR
266e					endif 
266e					; get address 
266e			 
266e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266e cd bd 1b			call macro_dsp_valuehl 
2671				endm 
# End of macro FORTH_DSP_VALUEHL
2671			 
2671			;		push hl 
2671			 
2671					; destroy value TOS 
2671			 
2671					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2671 cd 75 1c			call macro_forth_dsp_pop 
2674				endm 
# End of macro FORTH_DSP_POP
2674			 
2674			;		pop hl 
2674			if FORTH_ENABLE_MALLOCFREE 
2674 cd 57 11				call free 
2677			endif 
2677					NEXTW 
2677 c3 2f 1d			jp macro_next 
267a				endm 
# End of macro NEXTW
267a			.LIST: 
267a				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
267a 5c				db WORD_SYS_CORE+72             
267b 59 28			dw .FORGET            
267d 05				db 4 + 1 
267e .. 00			db "LIST",0              
2683				endm 
# End of macro CWHEAD
2683			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2683			; | | The quoted word must be in upper case. 
2683				if DEBUG_FORTH_WORDS_KEY 
2683					DMARK "LST" 
2683 f5				push af  
2684 3a 98 26			ld a, (.dmark)  
2687 32 7a ee			ld (debug_mark),a  
268a 3a 99 26			ld a, (.dmark+1)  
268d 32 7b ee			ld (debug_mark+1),a  
2690 3a 9a 26			ld a, (.dmark+2)  
2693 32 7c ee			ld (debug_mark+2),a  
2696 18 03			jr .pastdmark  
2698 ..			.dmark: db "LST"  
269b f1			.pastdmark: pop af  
269c			endm  
# End of macro DMARK
269c					CALLMONITOR 
269c cd 39 14			call break_point_state  
269f				endm  
# End of macro CALLMONITOR
269f				endif 
269f			 
269f					FORTH_DSP_VALUEHL 
269f cd bd 1b			call macro_dsp_valuehl 
26a2				endm 
# End of macro FORTH_DSP_VALUEHL
26a2			 
26a2 e5					push hl 
26a3 c1					pop bc 
26a4			 
26a4			; Start format of scratch string 
26a4			 
26a4 21 60 e3				ld hl, scratch 
26a7			 
26a7 3e 3a				ld a, ':' 
26a9 77					ld (hl),a 
26aa 23					inc hl 
26ab 3e 20				ld a, ' ' 
26ad 77					ld (hl), a 
26ae			 
26ae					; Get ptr to the word we need to look up 
26ae			 
26ae			;		FORTH_DSP_VALUEHL 
26ae					;v5 FORTH_DSP_VALUE 
26ae				; TODO type check 
26ae			;		inc hl    ; Skip type check  
26ae			;		push hl 
26ae			;		ex de, hl    ; put into DE 
26ae			 
26ae			 
26ae 21 d8 58				ld hl, baseram 
26b1					;ld hl, baseusermem 
26b1			 
26b1 e5			push hl   ; sacreifical push 
26b2			 
26b2			.ldouscanm: 
26b2 e1				pop hl 
26b3			.ldouscan: 
26b3				if DEBUG_FORTH_WORDS 
26b3					DMARK "LSs" 
26b3 f5				push af  
26b4 3a c8 26			ld a, (.dmark)  
26b7 32 7a ee			ld (debug_mark),a  
26ba 3a c9 26			ld a, (.dmark+1)  
26bd 32 7b ee			ld (debug_mark+1),a  
26c0 3a ca 26			ld a, (.dmark+2)  
26c3 32 7c ee			ld (debug_mark+2),a  
26c6 18 03			jr .pastdmark  
26c8 ..			.dmark: db "LSs"  
26cb f1			.pastdmark: pop af  
26cc			endm  
# End of macro DMARK
26cc					CALLMONITOR 
26cc cd 39 14			call break_point_state  
26cf				endm  
# End of macro CALLMONITOR
26cf				endif 
26cf				; skip dict stub 
26cf cd 80 1e				call forth_tok_next 
26d2			 
26d2			 
26d2			; while we have words to look for 
26d2			 
26d2 7e				ld a, (hl)      
26d3				if DEBUG_FORTH_WORDS 
26d3					DMARK "LSk" 
26d3 f5				push af  
26d4 3a e8 26			ld a, (.dmark)  
26d7 32 7a ee			ld (debug_mark),a  
26da 3a e9 26			ld a, (.dmark+1)  
26dd 32 7b ee			ld (debug_mark+1),a  
26e0 3a ea 26			ld a, (.dmark+2)  
26e3 32 7c ee			ld (debug_mark+2),a  
26e6 18 03			jr .pastdmark  
26e8 ..			.dmark: db "LSk"  
26eb f1			.pastdmark: pop af  
26ec			endm  
# End of macro DMARK
26ec					CALLMONITOR 
26ec cd 39 14			call break_point_state  
26ef				endm  
# End of macro CALLMONITOR
26ef				endif 
26ef fe 00				cp WORD_SYS_END 
26f1 ca 24 28				jp z, .lunotfound 
26f4 fe 01				cp WORD_SYS_UWORD 
26f6 c2 b3 26				jp nz, .ldouscan 
26f9			 
26f9				if DEBUG_FORTH_WORDS 
26f9					DMARK "LSu" 
26f9 f5				push af  
26fa 3a 0e 27			ld a, (.dmark)  
26fd 32 7a ee			ld (debug_mark),a  
2700 3a 0f 27			ld a, (.dmark+1)  
2703 32 7b ee			ld (debug_mark+1),a  
2706 3a 10 27			ld a, (.dmark+2)  
2709 32 7c ee			ld (debug_mark+2),a  
270c 18 03			jr .pastdmark  
270e ..			.dmark: db "LSu"  
2711 f1			.pastdmark: pop af  
2712			endm  
# End of macro DMARK
2712					CALLMONITOR 
2712 cd 39 14			call break_point_state  
2715				endm  
# End of macro CALLMONITOR
2715				endif 
2715			 
2715					; found a uword but is it the one we want... 
2715			 
2715 c5					push bc     ; uword to find is on bc 
2716 d1					pop de 
2717			 
2717 e5					push hl  ; to save the ptr 
2718			 
2718					; skip opcode 
2718 23					inc hl  
2719					; skip next ptr 
2719 23					inc hl  
271a 23					inc hl 
271b					; skip len 
271b 23					inc hl 
271c			 
271c				if DEBUG_FORTH_WORDS 
271c					DMARK "LSc" 
271c f5				push af  
271d 3a 31 27			ld a, (.dmark)  
2720 32 7a ee			ld (debug_mark),a  
2723 3a 32 27			ld a, (.dmark+1)  
2726 32 7b ee			ld (debug_mark+1),a  
2729 3a 33 27			ld a, (.dmark+2)  
272c 32 7c ee			ld (debug_mark+2),a  
272f 18 03			jr .pastdmark  
2731 ..			.dmark: db "LSc"  
2734 f1			.pastdmark: pop af  
2735			endm  
# End of macro DMARK
2735					CALLMONITOR 
2735 cd 39 14			call break_point_state  
2738				endm  
# End of macro CALLMONITOR
2738				endif 
2738 cd 5c 10				call strcmp 
273b c2 b2 26				jp nz, .ldouscanm 
273e				 
273e			 
273e			 
273e					; we have a uword so push its name to the stack 
273e			 
273e			;	   	push hl  ; save so we can move to next dict block 
273e e1			pop hl 
273f			 
273f				if DEBUG_FORTH_WORDS 
273f					DMARK "LSm" 
273f f5				push af  
2740 3a 54 27			ld a, (.dmark)  
2743 32 7a ee			ld (debug_mark),a  
2746 3a 55 27			ld a, (.dmark+1)  
2749 32 7b ee			ld (debug_mark+1),a  
274c 3a 56 27			ld a, (.dmark+2)  
274f 32 7c ee			ld (debug_mark+2),a  
2752 18 03			jr .pastdmark  
2754 ..			.dmark: db "LSm"  
2757 f1			.pastdmark: pop af  
2758			endm  
# End of macro DMARK
2758					CALLMONITOR 
2758 cd 39 14			call break_point_state  
275b				endm  
# End of macro CALLMONITOR
275b				endif 
275b			 
275b					; skip opcode 
275b 23					inc hl  
275c					; skip next ptr 
275c 23					inc hl  
275d 23					inc hl 
275e					; skip len 
275e 7e					ld a, (hl)   ; save length to add 
275f				if DEBUG_FORTH_WORDS 
275f					DMARK "LS2" 
275f f5				push af  
2760 3a 74 27			ld a, (.dmark)  
2763 32 7a ee			ld (debug_mark),a  
2766 3a 75 27			ld a, (.dmark+1)  
2769 32 7b ee			ld (debug_mark+1),a  
276c 3a 76 27			ld a, (.dmark+2)  
276f 32 7c ee			ld (debug_mark+2),a  
2772 18 03			jr .pastdmark  
2774 ..			.dmark: db "LS2"  
2777 f1			.pastdmark: pop af  
2778			endm  
# End of macro DMARK
2778					CALLMONITOR 
2778 cd 39 14			call break_point_state  
277b				endm  
# End of macro CALLMONITOR
277b				endif 
277b			 
277b					; save this location 
277b				 
277b e5					push hl 
277c			 
277c 23					inc hl 
277d 11 62 e3				ld de, scratch+2 
2780 4f					ld c, a 
2781 06 00				ld b, 0 
2783			 
2783				if DEBUG_FORTH_WORDS 
2783					DMARK "LSn" 
2783 f5				push af  
2784 3a 98 27			ld a, (.dmark)  
2787 32 7a ee			ld (debug_mark),a  
278a 3a 99 27			ld a, (.dmark+1)  
278d 32 7b ee			ld (debug_mark+1),a  
2790 3a 9a 27			ld a, (.dmark+2)  
2793 32 7c ee			ld (debug_mark+2),a  
2796 18 03			jr .pastdmark  
2798 ..			.dmark: db "LSn"  
279b f1			.pastdmark: pop af  
279c			endm  
# End of macro DMARK
279c					CALLMONITOR 
279c cd 39 14			call break_point_state  
279f				endm  
# End of macro CALLMONITOR
279f				endif 
279f			 
279f					; copy uword name to scratch 
279f			 
279f ed b0				ldir 
27a1			 
27a1 1b					dec de 
27a2 3e 20				ld a, ' '    ; change null to space 
27a4 12					ld (de), a 
27a5			 
27a5 13					inc de 
27a6			 
27a6 d5					push de 
27a7 c1					pop bc     ; move scratch pointer to end of word name and save it 
27a8			 
27a8 e1					pop hl 
27a9 7e					ld a, (hl) 
27aa					;inc hl 
27aa					; skip word string 
27aa cd c6 0b				call addatohl 
27ad			 
27ad 23					inc hl 
27ae			 
27ae				if DEBUG_FORTH_WORDS 
27ae					DMARK "LS3" 
27ae f5				push af  
27af 3a c3 27			ld a, (.dmark)  
27b2 32 7a ee			ld (debug_mark),a  
27b5 3a c4 27			ld a, (.dmark+1)  
27b8 32 7b ee			ld (debug_mark+1),a  
27bb 3a c5 27			ld a, (.dmark+2)  
27be 32 7c ee			ld (debug_mark+2),a  
27c1 18 03			jr .pastdmark  
27c3 ..			.dmark: db "LS3"  
27c6 f1			.pastdmark: pop af  
27c7			endm  
# End of macro DMARK
27c7					CALLMONITOR 
27c7 cd 39 14			call break_point_state  
27ca				endm  
# End of macro CALLMONITOR
27ca				endif 
27ca					; should now be at the start of the machine code to setup the eval of the uword 
27ca					; now locate the ptr to the string defintion 
27ca			 
27ca					; skip ld hl, 
27ca					; then load the ptr 
27ca			 
27ca 23					inc hl 
27cb 5e					ld e, (hl) 
27cc 23					inc hl 
27cd 56					ld d, (hl) 
27ce eb					ex de, hl 
27cf			 
27cf			 
27cf				if DEBUG_FORTH_WORDS 
27cf					DMARK "LSt" 
27cf f5				push af  
27d0 3a e4 27			ld a, (.dmark)  
27d3 32 7a ee			ld (debug_mark),a  
27d6 3a e5 27			ld a, (.dmark+1)  
27d9 32 7b ee			ld (debug_mark+1),a  
27dc 3a e6 27			ld a, (.dmark+2)  
27df 32 7c ee			ld (debug_mark+2),a  
27e2 18 03			jr .pastdmark  
27e4 ..			.dmark: db "LSt"  
27e7 f1			.pastdmark: pop af  
27e8			endm  
# End of macro DMARK
27e8					CALLMONITOR 
27e8 cd 39 14			call break_point_state  
27eb				endm  
# End of macro CALLMONITOR
27eb				endif 
27eb			 
27eb			; cant push right now due to tokenised strings  
27eb			 
27eb			; get the destination of where to copy this definition to. 
27eb			 
27eb c5					push bc 
27ec d1					pop de 
27ed			 
27ed 7e			.listl:         ld a,(hl) 
27ee fe 00				cp 0 
27f0 28 09				jr z, .lreplsp     ; replace zero with space 
27f2 fe 7f				cp FORTH_END_BUFFER 
27f4 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27f6				 
27f6					; just copy this char as is then 
27f6			 
27f6 12					ld (de), a 
27f7			 
27f7 23			.listnxt:	inc hl 
27f8 13					inc de 
27f9 18 f2				jr .listl 
27fb			 
27fb 3e 20		.lreplsp:	ld a,' ' 
27fd 12					ld (de), a 
27fe 18 f7				jr .listnxt 
2800			 
2800			; close up uword def 
2800			 
2800			.listdone: 
2800 3e 00				ld a, 0 
2802 12					ld (de), a 
2803			 
2803			; now have def so clean up and push to stack 
2803			 
2803 21 60 e3				ld hl, scratch 
2806				if DEBUG_FORTH_WORDS 
2806					DMARK "Ltp" 
2806 f5				push af  
2807 3a 1b 28			ld a, (.dmark)  
280a 32 7a ee			ld (debug_mark),a  
280d 3a 1c 28			ld a, (.dmark+1)  
2810 32 7b ee			ld (debug_mark+1),a  
2813 3a 1d 28			ld a, (.dmark+2)  
2816 32 7c ee			ld (debug_mark+2),a  
2819 18 03			jr .pastdmark  
281b ..			.dmark: db "Ltp"  
281e f1			.pastdmark: pop af  
281f			endm  
# End of macro DMARK
281f					CALLMONITOR 
281f cd 39 14			call break_point_state  
2822				endm  
# End of macro CALLMONITOR
2822				endif 
2822			 
2822 18 22			jr .listpush 
2824			 
2824			;.lnuword:	pop hl 
2824			;		call forth_tok_next 
2824			;		jp .ldouscan  
2824			 
2824			.lunotfound:		  
2824			 
2824				if DEBUG_FORTH_WORDS 
2824					DMARK "LSn" 
2824 f5				push af  
2825 3a 39 28			ld a, (.dmark)  
2828 32 7a ee			ld (debug_mark),a  
282b 3a 3a 28			ld a, (.dmark+1)  
282e 32 7b ee			ld (debug_mark+1),a  
2831 3a 3b 28			ld a, (.dmark+2)  
2834 32 7c ee			ld (debug_mark+2),a  
2837 18 03			jr .pastdmark  
2839 ..			.dmark: db "LSn"  
283c f1			.pastdmark: pop af  
283d			endm  
# End of macro DMARK
283d					CALLMONITOR 
283d cd 39 14			call break_point_state  
2840				endm  
# End of macro CALLMONITOR
2840				endif 
2840			 
2840					 
2840					FORTH_DSP_POP 
2840 cd 75 1c			call macro_forth_dsp_pop 
2843				endm 
# End of macro FORTH_DSP_POP
2843 21 4c 28				ld hl, .luno 
2846						 
2846			 
2846			.listpush: 
2846 cd 34 1a				call forth_push_str 
2849			 
2849			 
2849			 
2849					NEXTW 
2849 c3 2f 1d			jp macro_next 
284c				endm 
# End of macro NEXTW
284c			 
284c .. 00		.luno:    db "Not found",0 
2856			 
2856			 
2856			 
2856			 
2856			 
2856			;		push hl   ; save pointer to start of uword def string 
2856			; 
2856			;; look for FORTH_EOL_LINE 
2856			;		ld a, FORTH_END_BUFFER 
2856			;		call strlent 
2856			; 
2856			;		inc hl		 ; space for coln def 
2856			;		inc hl 
2856			;		inc hl          ; space for terms 
2856			;		inc hl 
2856			; 
2856			;		ld a, 20   ; TODO get actual length 
2856			;		call addatohl    ; include a random amount of room for the uword name 
2856			; 
2856			;		 
2856			;	if DEBUG_FORTH_WORDS 
2856			;		DMARK "Lt1" 
2856			;		CALLMONITOR 
2856			;	endif 
2856			;		 
2856			; 
2856			;; malloc space for the string because we cant change it 
2856			; 
2856			;		call malloc 
2856			;	if DEBUG_FORTH_MALLOC_GUARD 
2856			;		push af 
2856			;		call ishlzero 
2856			;		pop af 
2856			;		 
2856			;		call z,malloc_error 
2856			;	endif 
2856			; 
2856			;	if DEBUG_FORTH_WORDS 
2856			;		DMARK "Lt2" 
2856			;		CALLMONITOR 
2856			;	endif 
2856			;		pop de 
2856			;		push hl    ; push the malloc to release later 
2856			;		push hl   ;  push back a copy for the later stack push 
2856			;		 
2856			;; copy the string swapping out the zero terms for spaces 
2856			; 
2856			;		; de has our source 
2856			;		; hl has our dest 
2856			; 
2856			;; add the coln def 
2856			; 
2856			;		ld a, ':' 
2856			;		ld (hl), a 
2856			;		inc hl 
2856			;		ld a, ' ' 
2856			;		ld (hl), a 
2856			;		inc hl 
2856			; 
2856			;; add the uname word 
2856			;		push de   ; save our string for now 
2856			;		ex de, hl 
2856			; 
2856			;		FORTH_DSP_VALUE 
2856			;		;v5 FORTH_DSP_VALUE 
2856			; 
2856			;		inc hl   ; skip type but we know by now this is OK 
2856			; 
2856			;.luword:	ld a,(hl) 
2856			;		cp 0 
2856			;		jr z, .luword2 
2856			;		ld (de), a 
2856			;		inc de 
2856			;		inc hl 
2856			;		jr .luword 
2856			; 
2856			;.luword2:	ld a, ' ' 
2856			;		ld (de), a 
2856			;;		inc hl 
2856			;;		inc de 
2856			;;		ld (de), a 
2856			;;		inc hl 
2856			;		inc de 
2856			; 
2856			;		ex de, hl 
2856			;		pop de 
2856			;		 
2856			;		 
2856			; 
2856			;; detoken that string and copy it 
2856			; 
2856			;	if DEBUG_FORTH_WORDS 
2856			;		DMARK "Lt2" 
2856			;		CALLMONITOR 
2856			;	endif 
2856			;.ldetok:	ld a, (de) 
2856			;		cp FORTH_END_BUFFER 
2856			;		jr z, .ldetokend 
2856			;		; swap out any zero term for space 
2856			;		cp 0 
2856			;		jr nz, .ldetoknext 
2856			;		ld a, ' ' 
2856			; 
2856			;	if DEBUG_FORTH_WORDS 
2856			;		DMARK "LtS" 
2856			;		CALLMONITOR 
2856			;	endif 
2856			;.ldetoknext:	ld (hl), a 
2856			;		inc de 
2856			;		inc hl 
2856			;		jr .ldetok 
2856			; 
2856			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2856			;		ld (hl), a  
2856			; 
2856			;; free that temp malloc 
2856			; 
2856			;		pop hl    
2856			; 
2856			;	if DEBUG_FORTH_WORDS 
2856			;		DMARK "Lt4" 
2856			;		CALLMONITOR 
2856			;	endif 
2856			;		call forth_apushstrhl 
2856			; 
2856			;		; get rid of temp malloc area 
2856			; 
2856			;		pop hl 
2856			;		call free 
2856			; 
2856			;		jr .ludone 
2856			; 
2856			;.lnuword:	pop hl 
2856			;		call forth_tok_next 
2856			;		jp .ldouscan  
2856			; 
2856			;.ludone:		 pop hl 
2856			; 
2856					NEXTW 
2856 c3 2f 1d			jp macro_next 
2859				endm 
# End of macro NEXTW
2859			 
2859			.FORGET: 
2859				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2859 5d				db WORD_SYS_CORE+73             
285a d2 28			dw .NOP            
285c 07				db 6 + 1 
285d .. 00			db "FORGET",0              
2864				endm 
# End of macro CWHEAD
2864			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2864			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2864			; | |  
2864			; | | e.g. "MORE" forget 
2864					if DEBUG_FORTH_WORDS_KEY 
2864						DMARK "FRG" 
2864 f5				push af  
2865 3a 79 28			ld a, (.dmark)  
2868 32 7a ee			ld (debug_mark),a  
286b 3a 7a 28			ld a, (.dmark+1)  
286e 32 7b ee			ld (debug_mark+1),a  
2871 3a 7b 28			ld a, (.dmark+2)  
2874 32 7c ee			ld (debug_mark+2),a  
2877 18 03			jr .pastdmark  
2879 ..			.dmark: db "FRG"  
287c f1			.pastdmark: pop af  
287d			endm  
# End of macro DMARK
287d						CALLMONITOR 
287d cd 39 14			call break_point_state  
2880				endm  
# End of macro CALLMONITOR
2880					endif 
2880			 
2880				; find uword 
2880			        ; update start of word with "_" 
2880				; replace uword with deleted flag 
2880			 
2880			 
2880			;	if DEBUG_FORTH_WORDS 
2880			;		DMARK "FOG" 
2880			;		CALLMONITOR 
2880			;	endif 
2880			 
2880			 
2880					; Get ptr to the word we need to look up 
2880			 
2880					FORTH_DSP_VALUEHL 
2880 cd bd 1b			call macro_dsp_valuehl 
2883				endm 
# End of macro FORTH_DSP_VALUEHL
2883					;v5 FORTH_DSP_VALUE 
2883				; TODO type check 
2883			;		inc hl    ; Skip type check  
2883 e5					push hl 
2884 c1					pop bc 
2885			;		ex de, hl    ; put into DE 
2885			 
2885			 
2885 21 d8 58				ld hl, baseram 
2888					;ld hl, baseusermem 
2888			 
2888				; skip dict stub 
2888			;	call forth_tok_next 
2888 e5			push hl   ; sacreifical push 
2889			 
2889			.fldouscanm: 
2889 e1				pop hl 
288a			.fldouscan: 
288a			;	if DEBUG_FORTH_WORDS 
288a			;		DMARK "LSs" 
288a			;		CALLMONITOR 
288a			;	endif 
288a				; skip dict stub 
288a cd 80 1e				call forth_tok_next 
288d			 
288d			 
288d			; while we have words to look for 
288d			 
288d 7e				ld a, (hl)      
288e			;	if DEBUG_FORTH_WORDS 
288e			;		DMARK "LSk" 
288e			;		CALLMONITOR 
288e			;	endif 
288e fe 00				cp WORD_SYS_END 
2890 ca cc 28				jp z, .flunotfound 
2893 fe 01				cp WORD_SYS_UWORD 
2895 c2 8a 28				jp nz, .fldouscan 
2898			 
2898			;	if DEBUG_FORTH_WORDS 
2898			;		DMARK "LSu" 
2898			;		CALLMONITOR 
2898			;	endif 
2898			 
2898					; found a uword but is it the one we want... 
2898			 
2898 c5					push bc     ; uword to find is on bc 
2899 d1					pop de 
289a			 
289a e5					push hl  ; to save the ptr 
289b			 
289b					; skip opcode 
289b 23					inc hl  
289c					; skip next ptr 
289c 23					inc hl  
289d 23					inc hl 
289e					; skip len 
289e 23					inc hl 
289f			 
289f			;	if DEBUG_FORTH_WORDS 
289f			;		DMARK "LSc" 
289f			;		CALLMONITOR 
289f			;	endif 
289f cd 5c 10				call strcmp 
28a2 c2 89 28				jp nz, .fldouscanm 
28a5			; 
28a5			; 
28a5			;; while we have words to look for 
28a5			; 
28a5			;.fdouscan:	ld a, (hl)      
28a5			;	if DEBUG_FORTH_WORDS 
28a5			;		DMARK "LSs" 
28a5			;		CALLMONITOR 
28a5			;	endif 
28a5			;		cp WORD_SYS_END 
28a5			;		jp z, .fudone 
28a5			;		cp WORD_SYS_UWORD 
28a5			;		jp nz, .fnuword 
28a5			; 
28a5			;	if DEBUG_FORTH_WORDS 
28a5			;		DMARK "FGu" 
28a5			;		CALLMONITOR 
28a5			;	endif 
28a5			; 
28a5			;		; found a uword but is it the one we want... 
28a5			; 
28a5			; 
28a5			;	        pop de   ; get back the dsp name 
28a5			;		push de 
28a5			; 
28a5			;		push hl  ; to save the ptr 
28a5			; 
28a5			;		; skip opcode 
28a5			;		inc hl  
28a5			;		; skip next ptr 
28a5			;		inc hl  
28a5			;		inc hl 
28a5			;		; skip len 
28a5			;		inc hl 
28a5			; 
28a5			;	if DEBUG_FORTH_WORDS 
28a5			;		DMARK "FGc" 
28a5			;		CALLMONITOR 
28a5			;	endif 
28a5			;		call strcmp 
28a5			;		jp nz, .fnuword 
28a5			 
28a5			 
28a5 e1			pop hl 
28a6			 
28a6				 
28a6				if DEBUG_FORTH_WORDS 
28a6					DMARK "FGm" 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 7a ee			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 7b ee			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 7c ee			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db "FGm"  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf					CALLMONITOR 
28bf cd 39 14			call break_point_state  
28c2				endm  
# End of macro CALLMONITOR
28c2				endif 
28c2			 
28c2			 
28c2			 
28c2					; we have a uword so push its name to the stack 
28c2			 
28c2			;	   	push hl  ; save so we can move to next dict block 
28c2			;pop hl 
28c2			 
28c2					; update opcode to deleted 
28c2 3e 03				ld a, WORD_SYS_DELETED 
28c4 77					ld (hl), a 
28c5			 
28c5 23					inc hl  
28c6					; skip next ptr 
28c6 23					inc hl  
28c7 23					inc hl 
28c8					; skip len 
28c8 23					inc hl 
28c9			 
28c9					; TODO change parser to skip deleted words but for now mark it out 
28c9 3e 5f				ld a, "_" 
28cb 77					ld  (hl),a 
28cc			 
28cc			;		jr .fudone 
28cc			; 
28cc			;.fnuword:	pop hl 
28cc			;		call forth_tok_next 
28cc			;		jp .fdouscan  
28cc			 
28cc			.flunotfound:		  
28cc			 
28cc			 
28cc					 
28cc					FORTH_DSP_POP 
28cc cd 75 1c			call macro_forth_dsp_pop 
28cf				endm 
# End of macro FORTH_DSP_POP
28cf			;		ld hl, .luno 
28cf			;.fudone:		 pop hl 
28cf					NEXTW 
28cf c3 2f 1d			jp macro_next 
28d2				endm 
# End of macro NEXTW
28d2			.NOP: 
28d2				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
28d2 61				db WORD_SYS_CORE+77             
28d3 f9 28			dw .COMO            
28d5 04				db 3 + 1 
28d6 .. 00			db "NOP",0              
28da				endm 
# End of macro CWHEAD
28da			; | NOP (  --  ) Do nothing | DONE 
28da					if DEBUG_FORTH_WORDS_KEY 
28da						DMARK "NOP" 
28da f5				push af  
28db 3a ef 28			ld a, (.dmark)  
28de 32 7a ee			ld (debug_mark),a  
28e1 3a f0 28			ld a, (.dmark+1)  
28e4 32 7b ee			ld (debug_mark+1),a  
28e7 3a f1 28			ld a, (.dmark+2)  
28ea 32 7c ee			ld (debug_mark+2),a  
28ed 18 03			jr .pastdmark  
28ef ..			.dmark: db "NOP"  
28f2 f1			.pastdmark: pop af  
28f3			endm  
# End of macro DMARK
28f3						CALLMONITOR 
28f3 cd 39 14			call break_point_state  
28f6				endm  
# End of macro CALLMONITOR
28f6					endif 
28f6				       NEXTW 
28f6 c3 2f 1d			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			.COMO: 
28f9				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
28f9 6e				db WORD_SYS_CORE+90             
28fa 4b 29			dw .COMC            
28fc 02				db 1 + 1 
28fd .. 00			db "(",0              
28ff				endm 
# End of macro CWHEAD
28ff			; | ( ( -- )  Start of comment | DONE 
28ff			 
28ff			 
28ff 2a 61 e6				ld hl, ( os_tok_ptr) 
2902 11 46 29			ld de, .closepar 
2905					 
2905					if DEBUG_FORTH_WORDS 
2905						DMARK ").." 
2905 f5				push af  
2906 3a 1a 29			ld a, (.dmark)  
2909 32 7a ee			ld (debug_mark),a  
290c 3a 1b 29			ld a, (.dmark+1)  
290f 32 7b ee			ld (debug_mark+1),a  
2912 3a 1c 29			ld a, (.dmark+2)  
2915 32 7c ee			ld (debug_mark+2),a  
2918 18 03			jr .pastdmark  
291a ..			.dmark: db ").."  
291d f1			.pastdmark: pop af  
291e			endm  
# End of macro DMARK
291e						CALLMONITOR 
291e cd 39 14			call break_point_state  
2921				endm  
# End of macro CALLMONITOR
2921					endif 
2921 cd 4a 1e			call findnexttok  
2924			 
2924					if DEBUG_FORTH_WORDS 
2924						DMARK "IF5" 
2924 f5				push af  
2925 3a 39 29			ld a, (.dmark)  
2928 32 7a ee			ld (debug_mark),a  
292b 3a 3a 29			ld a, (.dmark+1)  
292e 32 7b ee			ld (debug_mark+1),a  
2931 3a 3b 29			ld a, (.dmark+2)  
2934 32 7c ee			ld (debug_mark+2),a  
2937 18 03			jr .pastdmark  
2939 ..			.dmark: db "IF5"  
293c f1			.pastdmark: pop af  
293d			endm  
# End of macro DMARK
293d						CALLMONITOR 
293d cd 39 14			call break_point_state  
2940				endm  
# End of macro CALLMONITOR
2940					endif 
2940				; replace below with ) exec using tok_ptr 
2940 22 61 e6			ld (os_tok_ptr), hl 
2943 c3 c0 1d			jp exec1 
2946			 
2946 .. 00			.closepar:   db ")",0 
2948			 
2948				       NEXTW 
2948 c3 2f 1d			jp macro_next 
294b				endm 
# End of macro NEXTW
294b			.COMC: 
294b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
294b 6f				db WORD_SYS_CORE+91             
294c 54 29			dw .SCRATCH            
294e 02				db 1 + 1 
294f .. 00			db ")",0              
2951				endm 
# End of macro CWHEAD
2951			; | ) ( -- )  End of comment |  DONE  
2951				       NEXTW 
2951 c3 2f 1d			jp macro_next 
2954				endm 
# End of macro NEXTW
2954			 
2954			.SCRATCH: 
2954				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2954 6f				db WORD_SYS_CORE+91             
2955 8f 29			dw .INC            
2957 08				db 7 + 1 
2958 .. 00			db "SCRATCH",0              
2960				endm 
# End of macro CWHEAD
2960			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2960			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2960			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2960			; | |  
2960			; | | e.g.    : score $00 scratch ; 
2960			; | |  
2960			; | | $00 score ! 
2960			; | | $01 score +! 
2960			; | |  
2960			; | | e.g.   : varword $0a scratch ;  
2960			; | | 
2960			; | | $8000 varword ! 
2960					if DEBUG_FORTH_WORDS_KEY 
2960						DMARK "SCR" 
2960 f5				push af  
2961 3a 75 29			ld a, (.dmark)  
2964 32 7a ee			ld (debug_mark),a  
2967 3a 76 29			ld a, (.dmark+1)  
296a 32 7b ee			ld (debug_mark+1),a  
296d 3a 77 29			ld a, (.dmark+2)  
2970 32 7c ee			ld (debug_mark+2),a  
2973 18 03			jr .pastdmark  
2975 ..			.dmark: db "SCR"  
2978 f1			.pastdmark: pop af  
2979			endm  
# End of macro DMARK
2979						CALLMONITOR 
2979 cd 39 14			call break_point_state  
297c				endm  
# End of macro CALLMONITOR
297c					endif 
297c			 
297c					FORTH_DSP_VALUEHL 
297c cd bd 1b			call macro_dsp_valuehl 
297f				endm 
# End of macro FORTH_DSP_VALUEHL
297f				 
297f					FORTH_DSP_POP 
297f cd 75 1c			call macro_forth_dsp_pop 
2982				endm 
# End of macro FORTH_DSP_POP
2982			 
2982 7d					ld a, l 
2983 21 85 e8				ld hl, os_var_array 
2986 cd c6 0b				call addatohl 
2989			 
2989 cd c6 19				call forth_push_numhl 
298c			 
298c				       NEXTW 
298c c3 2f 1d			jp macro_next 
298f				endm 
# End of macro NEXTW
298f			 
298f			.INC: 
298f				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
298f 6f				db WORD_SYS_CORE+91             
2990 e3 29			dw .DEC            
2992 03				db 2 + 1 
2993 .. 00			db "+!",0              
2996				endm 
# End of macro CWHEAD
2996			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2996					if DEBUG_FORTH_WORDS_KEY 
2996						DMARK "+s_" 
2996 f5				push af  
2997 3a ab 29			ld a, (.dmark)  
299a 32 7a ee			ld (debug_mark),a  
299d 3a ac 29			ld a, (.dmark+1)  
29a0 32 7b ee			ld (debug_mark+1),a  
29a3 3a ad 29			ld a, (.dmark+2)  
29a6 32 7c ee			ld (debug_mark+2),a  
29a9 18 03			jr .pastdmark  
29ab ..			.dmark: db "+s_"  
29ae f1			.pastdmark: pop af  
29af			endm  
# End of macro DMARK
29af						CALLMONITOR 
29af cd 39 14			call break_point_state  
29b2				endm  
# End of macro CALLMONITOR
29b2					endif 
29b2			 
29b2					FORTH_DSP_VALUEHL 
29b2 cd bd 1b			call macro_dsp_valuehl 
29b5				endm 
# End of macro FORTH_DSP_VALUEHL
29b5			 
29b5 e5					push hl   ; save address 
29b6			 
29b6					FORTH_DSP_POP 
29b6 cd 75 1c			call macro_forth_dsp_pop 
29b9				endm 
# End of macro FORTH_DSP_POP
29b9			 
29b9					FORTH_DSP_VALUEHL 
29b9 cd bd 1b			call macro_dsp_valuehl 
29bc				endm 
# End of macro FORTH_DSP_VALUEHL
29bc			 
29bc					FORTH_DSP_POP 
29bc cd 75 1c			call macro_forth_dsp_pop 
29bf				endm 
# End of macro FORTH_DSP_POP
29bf			 
29bf					; hl contains value to add to byte at a 
29bf				 
29bf eb					ex de, hl 
29c0			 
29c0 e1					pop hl 
29c1			 
29c1					if DEBUG_FORTH_WORDS 
29c1						DMARK "INC" 
29c1 f5				push af  
29c2 3a d6 29			ld a, (.dmark)  
29c5 32 7a ee			ld (debug_mark),a  
29c8 3a d7 29			ld a, (.dmark+1)  
29cb 32 7b ee			ld (debug_mark+1),a  
29ce 3a d8 29			ld a, (.dmark+2)  
29d1 32 7c ee			ld (debug_mark+2),a  
29d4 18 03			jr .pastdmark  
29d6 ..			.dmark: db "INC"  
29d9 f1			.pastdmark: pop af  
29da			endm  
# End of macro DMARK
29da						CALLMONITOR 
29da cd 39 14			call break_point_state  
29dd				endm  
# End of macro CALLMONITOR
29dd					endif 
29dd			 
29dd 7e					ld a,(hl) 
29de 83					add e 
29df 77					ld (hl),a 
29e0			 
29e0			 
29e0			 
29e0				       NEXTW 
29e0 c3 2f 1d			jp macro_next 
29e3				endm 
# End of macro NEXTW
29e3			 
29e3			.DEC: 
29e3				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
29e3 6f				db WORD_SYS_CORE+91             
29e4 34 2a			dw .INC2            
29e6 03				db 2 + 1 
29e7 .. 00			db "-!",0              
29ea				endm 
# End of macro CWHEAD
29ea			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
29ea					if DEBUG_FORTH_WORDS_KEY 
29ea						DMARK "-s_" 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 7a ee			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 7b ee			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 7c ee			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "-s_"  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03						CALLMONITOR 
2a03 cd 39 14			call break_point_state  
2a06				endm  
# End of macro CALLMONITOR
2a06					endif 
2a06			 
2a06					FORTH_DSP_VALUEHL 
2a06 cd bd 1b			call macro_dsp_valuehl 
2a09				endm 
# End of macro FORTH_DSP_VALUEHL
2a09			 
2a09 e5					push hl   ; save address 
2a0a			 
2a0a					FORTH_DSP_POP 
2a0a cd 75 1c			call macro_forth_dsp_pop 
2a0d				endm 
# End of macro FORTH_DSP_POP
2a0d			 
2a0d					FORTH_DSP_VALUEHL 
2a0d cd bd 1b			call macro_dsp_valuehl 
2a10				endm 
# End of macro FORTH_DSP_VALUEHL
2a10			 
2a10					; hl contains value to add to byte at a 
2a10				 
2a10 eb					ex de, hl 
2a11			 
2a11 e1					pop hl 
2a12			 
2a12					if DEBUG_FORTH_WORDS 
2a12						DMARK "DEC" 
2a12 f5				push af  
2a13 3a 27 2a			ld a, (.dmark)  
2a16 32 7a ee			ld (debug_mark),a  
2a19 3a 28 2a			ld a, (.dmark+1)  
2a1c 32 7b ee			ld (debug_mark+1),a  
2a1f 3a 29 2a			ld a, (.dmark+2)  
2a22 32 7c ee			ld (debug_mark+2),a  
2a25 18 03			jr .pastdmark  
2a27 ..			.dmark: db "DEC"  
2a2a f1			.pastdmark: pop af  
2a2b			endm  
# End of macro DMARK
2a2b						CALLMONITOR 
2a2b cd 39 14			call break_point_state  
2a2e				endm  
# End of macro CALLMONITOR
2a2e					endif 
2a2e			 
2a2e 7e					ld a,(hl) 
2a2f 93					sub e 
2a30 77					ld (hl),a 
2a31			 
2a31			 
2a31			 
2a31				       NEXTW 
2a31 c3 2f 1d			jp macro_next 
2a34				endm 
# End of macro NEXTW
2a34			 
2a34			.INC2: 
2a34				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a34 6f				db WORD_SYS_CORE+91             
2a35 de 2a			dw .DEC2            
2a37 04				db 3 + 1 
2a38 .. 00			db "+2!",0              
2a3c				endm 
# End of macro CWHEAD
2a3c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a3c			 
2a3c					if DEBUG_FORTH_WORDS_KEY 
2a3c						DMARK "+2s" 
2a3c f5				push af  
2a3d 3a 51 2a			ld a, (.dmark)  
2a40 32 7a ee			ld (debug_mark),a  
2a43 3a 52 2a			ld a, (.dmark+1)  
2a46 32 7b ee			ld (debug_mark+1),a  
2a49 3a 53 2a			ld a, (.dmark+2)  
2a4c 32 7c ee			ld (debug_mark+2),a  
2a4f 18 03			jr .pastdmark  
2a51 ..			.dmark: db "+2s"  
2a54 f1			.pastdmark: pop af  
2a55			endm  
# End of macro DMARK
2a55						CALLMONITOR 
2a55 cd 39 14			call break_point_state  
2a58				endm  
# End of macro CALLMONITOR
2a58					endif 
2a58			 
2a58					; Address 
2a58			 
2a58					FORTH_DSP_VALUEHL 
2a58 cd bd 1b			call macro_dsp_valuehl 
2a5b				endm 
# End of macro FORTH_DSP_VALUEHL
2a5b			 
2a5b e5					push hl    ; save address 
2a5c			 
2a5c					; load content into de 
2a5c			 
2a5c 5e					ld e,(hl) 
2a5d 23					inc hl 
2a5e 56					ld d, (hl) 
2a5f			 
2a5f					if DEBUG_FORTH_WORDS 
2a5f						DMARK "+2a" 
2a5f f5				push af  
2a60 3a 74 2a			ld a, (.dmark)  
2a63 32 7a ee			ld (debug_mark),a  
2a66 3a 75 2a			ld a, (.dmark+1)  
2a69 32 7b ee			ld (debug_mark+1),a  
2a6c 3a 76 2a			ld a, (.dmark+2)  
2a6f 32 7c ee			ld (debug_mark+2),a  
2a72 18 03			jr .pastdmark  
2a74 ..			.dmark: db "+2a"  
2a77 f1			.pastdmark: pop af  
2a78			endm  
# End of macro DMARK
2a78						CALLMONITOR 
2a78 cd 39 14			call break_point_state  
2a7b				endm  
# End of macro CALLMONITOR
2a7b					endif 
2a7b			 
2a7b					FORTH_DSP_POP 
2a7b cd 75 1c			call macro_forth_dsp_pop 
2a7e				endm 
# End of macro FORTH_DSP_POP
2a7e			 
2a7e					; Get value to add 
2a7e			 
2a7e					FORTH_DSP_VALUE 
2a7e cd a6 1b			call macro_forth_dsp_value 
2a81				endm 
# End of macro FORTH_DSP_VALUE
2a81			 
2a81					if DEBUG_FORTH_WORDS 
2a81						DMARK "+2v" 
2a81 f5				push af  
2a82 3a 96 2a			ld a, (.dmark)  
2a85 32 7a ee			ld (debug_mark),a  
2a88 3a 97 2a			ld a, (.dmark+1)  
2a8b 32 7b ee			ld (debug_mark+1),a  
2a8e 3a 98 2a			ld a, (.dmark+2)  
2a91 32 7c ee			ld (debug_mark+2),a  
2a94 18 03			jr .pastdmark  
2a96 ..			.dmark: db "+2v"  
2a99 f1			.pastdmark: pop af  
2a9a			endm  
# End of macro DMARK
2a9a						CALLMONITOR 
2a9a cd 39 14			call break_point_state  
2a9d				endm  
# End of macro CALLMONITOR
2a9d					endif 
2a9d			 
2a9d 19					add hl, de 
2a9e			 
2a9e					if DEBUG_FORTH_WORDS 
2a9e						DMARK "+2+" 
2a9e f5				push af  
2a9f 3a b3 2a			ld a, (.dmark)  
2aa2 32 7a ee			ld (debug_mark),a  
2aa5 3a b4 2a			ld a, (.dmark+1)  
2aa8 32 7b ee			ld (debug_mark+1),a  
2aab 3a b5 2a			ld a, (.dmark+2)  
2aae 32 7c ee			ld (debug_mark+2),a  
2ab1 18 03			jr .pastdmark  
2ab3 ..			.dmark: db "+2+"  
2ab6 f1			.pastdmark: pop af  
2ab7			endm  
# End of macro DMARK
2ab7						CALLMONITOR 
2ab7 cd 39 14			call break_point_state  
2aba				endm  
# End of macro CALLMONITOR
2aba					endif 
2aba			 
2aba					; move result to de 
2aba			 
2aba eb					ex de, hl 
2abb			 
2abb					; Address 
2abb			 
2abb e1					pop hl 
2abc			 
2abc					; save it back 
2abc			 
2abc 73					ld (hl), e 
2abd 23					inc hl 
2abe 72					ld (hl), d 
2abf			 
2abf					if DEBUG_FORTH_WORDS 
2abf						DMARK "+2e" 
2abf f5				push af  
2ac0 3a d4 2a			ld a, (.dmark)  
2ac3 32 7a ee			ld (debug_mark),a  
2ac6 3a d5 2a			ld a, (.dmark+1)  
2ac9 32 7b ee			ld (debug_mark+1),a  
2acc 3a d6 2a			ld a, (.dmark+2)  
2acf 32 7c ee			ld (debug_mark+2),a  
2ad2 18 03			jr .pastdmark  
2ad4 ..			.dmark: db "+2e"  
2ad7 f1			.pastdmark: pop af  
2ad8			endm  
# End of macro DMARK
2ad8						CALLMONITOR 
2ad8 cd 39 14			call break_point_state  
2adb				endm  
# End of macro CALLMONITOR
2adb					endif 
2adb			 
2adb			 
2adb			 
2adb			 
2adb			 
2adb				       NEXTW 
2adb c3 2f 1d			jp macro_next 
2ade				endm 
# End of macro NEXTW
2ade			 
2ade			.DEC2: 
2ade				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2ade 6f				db WORD_SYS_CORE+91             
2adf 8a 2b			dw .GET2            
2ae1 04				db 3 + 1 
2ae2 .. 00			db "-2!",0              
2ae6				endm 
# End of macro CWHEAD
2ae6			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2ae6			 
2ae6			 
2ae6					if DEBUG_FORTH_WORDS_KEY 
2ae6						DMARK "-2s" 
2ae6 f5				push af  
2ae7 3a fb 2a			ld a, (.dmark)  
2aea 32 7a ee			ld (debug_mark),a  
2aed 3a fc 2a			ld a, (.dmark+1)  
2af0 32 7b ee			ld (debug_mark+1),a  
2af3 3a fd 2a			ld a, (.dmark+2)  
2af6 32 7c ee			ld (debug_mark+2),a  
2af9 18 03			jr .pastdmark  
2afb ..			.dmark: db "-2s"  
2afe f1			.pastdmark: pop af  
2aff			endm  
# End of macro DMARK
2aff						CALLMONITOR 
2aff cd 39 14			call break_point_state  
2b02				endm  
# End of macro CALLMONITOR
2b02					endif 
2b02			 
2b02					; Address 
2b02			 
2b02					FORTH_DSP_VALUEHL 
2b02 cd bd 1b			call macro_dsp_valuehl 
2b05				endm 
# End of macro FORTH_DSP_VALUEHL
2b05			 
2b05 e5					push hl    ; save address 
2b06			 
2b06					; load content into de 
2b06			 
2b06 5e					ld e,(hl) 
2b07 23					inc hl 
2b08 56					ld d, (hl) 
2b09			 
2b09					if DEBUG_FORTH_WORDS 
2b09						DMARK "-2a" 
2b09 f5				push af  
2b0a 3a 1e 2b			ld a, (.dmark)  
2b0d 32 7a ee			ld (debug_mark),a  
2b10 3a 1f 2b			ld a, (.dmark+1)  
2b13 32 7b ee			ld (debug_mark+1),a  
2b16 3a 20 2b			ld a, (.dmark+2)  
2b19 32 7c ee			ld (debug_mark+2),a  
2b1c 18 03			jr .pastdmark  
2b1e ..			.dmark: db "-2a"  
2b21 f1			.pastdmark: pop af  
2b22			endm  
# End of macro DMARK
2b22						CALLMONITOR 
2b22 cd 39 14			call break_point_state  
2b25				endm  
# End of macro CALLMONITOR
2b25					endif 
2b25			 
2b25					FORTH_DSP_POP 
2b25 cd 75 1c			call macro_forth_dsp_pop 
2b28				endm 
# End of macro FORTH_DSP_POP
2b28			 
2b28					; Get value to remove 
2b28			 
2b28					FORTH_DSP_VALUE 
2b28 cd a6 1b			call macro_forth_dsp_value 
2b2b				endm 
# End of macro FORTH_DSP_VALUE
2b2b			 
2b2b					if DEBUG_FORTH_WORDS 
2b2b						DMARK "-2v" 
2b2b f5				push af  
2b2c 3a 40 2b			ld a, (.dmark)  
2b2f 32 7a ee			ld (debug_mark),a  
2b32 3a 41 2b			ld a, (.dmark+1)  
2b35 32 7b ee			ld (debug_mark+1),a  
2b38 3a 42 2b			ld a, (.dmark+2)  
2b3b 32 7c ee			ld (debug_mark+2),a  
2b3e 18 03			jr .pastdmark  
2b40 ..			.dmark: db "-2v"  
2b43 f1			.pastdmark: pop af  
2b44			endm  
# End of macro DMARK
2b44						CALLMONITOR 
2b44 cd 39 14			call break_point_state  
2b47				endm  
# End of macro CALLMONITOR
2b47					endif 
2b47			 
2b47 eb					ex de, hl 
2b48 ed 52				sbc hl, de 
2b4a			 
2b4a					if DEBUG_FORTH_WORDS 
2b4a						DMARK "-2d" 
2b4a f5				push af  
2b4b 3a 5f 2b			ld a, (.dmark)  
2b4e 32 7a ee			ld (debug_mark),a  
2b51 3a 60 2b			ld a, (.dmark+1)  
2b54 32 7b ee			ld (debug_mark+1),a  
2b57 3a 61 2b			ld a, (.dmark+2)  
2b5a 32 7c ee			ld (debug_mark+2),a  
2b5d 18 03			jr .pastdmark  
2b5f ..			.dmark: db "-2d"  
2b62 f1			.pastdmark: pop af  
2b63			endm  
# End of macro DMARK
2b63						CALLMONITOR 
2b63 cd 39 14			call break_point_state  
2b66				endm  
# End of macro CALLMONITOR
2b66					endif 
2b66			 
2b66					; move result to de 
2b66			 
2b66 eb					ex de, hl 
2b67			 
2b67					; Address 
2b67			 
2b67 e1					pop hl 
2b68			 
2b68					; save it back 
2b68			 
2b68 73					ld (hl), e 
2b69 23					inc hl 
2b6a 72					ld (hl), d 
2b6b			 
2b6b					if DEBUG_FORTH_WORDS 
2b6b						DMARK "-2e" 
2b6b f5				push af  
2b6c 3a 80 2b			ld a, (.dmark)  
2b6f 32 7a ee			ld (debug_mark),a  
2b72 3a 81 2b			ld a, (.dmark+1)  
2b75 32 7b ee			ld (debug_mark+1),a  
2b78 3a 82 2b			ld a, (.dmark+2)  
2b7b 32 7c ee			ld (debug_mark+2),a  
2b7e 18 03			jr .pastdmark  
2b80 ..			.dmark: db "-2e"  
2b83 f1			.pastdmark: pop af  
2b84			endm  
# End of macro DMARK
2b84						CALLMONITOR 
2b84 cd 39 14			call break_point_state  
2b87				endm  
# End of macro CALLMONITOR
2b87					endif 
2b87			 
2b87			 
2b87			 
2b87			 
2b87			 
2b87				       NEXTW 
2b87 c3 2f 1d			jp macro_next 
2b8a				endm 
# End of macro NEXTW
2b8a			.GET2: 
2b8a				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b8a 6f				db WORD_SYS_CORE+91             
2b8b ba 2b			dw .BANG2            
2b8d 03				db 2 + 1 
2b8e .. 00			db "2@",0              
2b91				endm 
# End of macro CWHEAD
2b91			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b91					if DEBUG_FORTH_WORDS_KEY 
2b91						DMARK "2A_" 
2b91 f5				push af  
2b92 3a a6 2b			ld a, (.dmark)  
2b95 32 7a ee			ld (debug_mark),a  
2b98 3a a7 2b			ld a, (.dmark+1)  
2b9b 32 7b ee			ld (debug_mark+1),a  
2b9e 3a a8 2b			ld a, (.dmark+2)  
2ba1 32 7c ee			ld (debug_mark+2),a  
2ba4 18 03			jr .pastdmark  
2ba6 ..			.dmark: db "2A_"  
2ba9 f1			.pastdmark: pop af  
2baa			endm  
# End of macro DMARK
2baa						CALLMONITOR 
2baa cd 39 14			call break_point_state  
2bad				endm  
# End of macro CALLMONITOR
2bad					endif 
2bad			 
2bad					FORTH_DSP_VALUEHL 
2bad cd bd 1b			call macro_dsp_valuehl 
2bb0				endm 
# End of macro FORTH_DSP_VALUEHL
2bb0			 
2bb0 5e					ld e, (hl) 
2bb1 23					inc hl 
2bb2 56					ld d, (hl) 
2bb3			 
2bb3 eb					ex de, hl 
2bb4			 
2bb4 cd c6 19				call forth_push_numhl 
2bb7			 
2bb7				       NEXTW 
2bb7 c3 2f 1d			jp macro_next 
2bba				endm 
# End of macro NEXTW
2bba			.BANG2: 
2bba				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2bba 6f				db WORD_SYS_CORE+91             
2bbb f2 2b			dw .CONFIG            
2bbd 03				db 2 + 1 
2bbe .. 00			db "2!",0              
2bc1				endm 
# End of macro CWHEAD
2bc1			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2bc1					if DEBUG_FORTH_WORDS_KEY 
2bc1						DMARK "2S_" 
2bc1 f5				push af  
2bc2 3a d6 2b			ld a, (.dmark)  
2bc5 32 7a ee			ld (debug_mark),a  
2bc8 3a d7 2b			ld a, (.dmark+1)  
2bcb 32 7b ee			ld (debug_mark+1),a  
2bce 3a d8 2b			ld a, (.dmark+2)  
2bd1 32 7c ee			ld (debug_mark+2),a  
2bd4 18 03			jr .pastdmark  
2bd6 ..			.dmark: db "2S_"  
2bd9 f1			.pastdmark: pop af  
2bda			endm  
# End of macro DMARK
2bda						CALLMONITOR 
2bda cd 39 14			call break_point_state  
2bdd				endm  
# End of macro CALLMONITOR
2bdd					endif 
2bdd			 
2bdd					FORTH_DSP_VALUEHL 
2bdd cd bd 1b			call macro_dsp_valuehl 
2be0				endm 
# End of macro FORTH_DSP_VALUEHL
2be0			 
2be0 e5					push hl   ; save address 
2be1			 
2be1			 
2be1					FORTH_DSP_POP 
2be1 cd 75 1c			call macro_forth_dsp_pop 
2be4				endm 
# End of macro FORTH_DSP_POP
2be4			 
2be4					 
2be4					FORTH_DSP_VALUEHL 
2be4 cd bd 1b			call macro_dsp_valuehl 
2be7				endm 
# End of macro FORTH_DSP_VALUEHL
2be7			 
2be7					FORTH_DSP_POP 
2be7 cd 75 1c			call macro_forth_dsp_pop 
2bea				endm 
# End of macro FORTH_DSP_POP
2bea			 
2bea eb					ex de, hl    ; value now in de 
2beb			 
2beb e1					pop hl 
2bec			 
2bec 73					ld (hl), e 
2bed			 
2bed 23					inc hl 
2bee			 
2bee 72					ld (hl), d 
2bef			 
2bef			 
2bef				       NEXTW 
2bef c3 2f 1d			jp macro_next 
2bf2				endm 
# End of macro NEXTW
2bf2			.CONFIG: 
2bf2				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2bf2 6f				db WORD_SYS_CORE+91             
2bf3 03 2c			dw .ENDCORE            
2bf5 07				db 6 + 1 
2bf6 .. 00			db "CONFIG",0              
2bfd				endm 
# End of macro CWHEAD
2bfd			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2bfd			 
2bfd cd 26 12				call config 
2c00					NEXTW 
2c00 c3 2f 1d			jp macro_next 
2c03				endm 
# End of macro NEXTW
2c03			.ENDCORE: 
2c03			 
2c03			; eof 
2c03			 
2c03			 
# End of file forth_words_core.asm
2c03			include "forth_words_flow.asm" 
2c03			 
2c03			; | ## Program Flow Words 
2c03			 
2c03			.IF: 
2c03				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2c03 1e				db WORD_SYS_CORE+10             
2c04 f8 2c			dw .THEN            
2c06 03				db 2 + 1 
2c07 .. 00			db "IF",0              
2c0a				endm 
# End of macro CWHEAD
2c0a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2c0a			; 
2c0a					if DEBUG_FORTH_WORDS_KEY 
2c0a						DMARK "IF." 
2c0a f5				push af  
2c0b 3a 1f 2c			ld a, (.dmark)  
2c0e 32 7a ee			ld (debug_mark),a  
2c11 3a 20 2c			ld a, (.dmark+1)  
2c14 32 7b ee			ld (debug_mark+1),a  
2c17 3a 21 2c			ld a, (.dmark+2)  
2c1a 32 7c ee			ld (debug_mark+2),a  
2c1d 18 03			jr .pastdmark  
2c1f ..			.dmark: db "IF."  
2c22 f1			.pastdmark: pop af  
2c23			endm  
# End of macro DMARK
2c23						CALLMONITOR 
2c23 cd 39 14			call break_point_state  
2c26				endm  
# End of macro CALLMONITOR
2c26					endif 
2c26			; eval TOS 
2c26			 
2c26				FORTH_DSP_VALUEHL 
2c26 cd bd 1b			call macro_dsp_valuehl 
2c29				endm 
# End of macro FORTH_DSP_VALUEHL
2c29			 
2c29			;	push hl 
2c29				FORTH_DSP_POP 
2c29 cd 75 1c			call macro_forth_dsp_pop 
2c2c				endm 
# End of macro FORTH_DSP_POP
2c2c			;	pop hl 
2c2c			 
2c2c					if DEBUG_FORTH_WORDS 
2c2c						DMARK "IF1" 
2c2c f5				push af  
2c2d 3a 41 2c			ld a, (.dmark)  
2c30 32 7a ee			ld (debug_mark),a  
2c33 3a 42 2c			ld a, (.dmark+1)  
2c36 32 7b ee			ld (debug_mark+1),a  
2c39 3a 43 2c			ld a, (.dmark+2)  
2c3c 32 7c ee			ld (debug_mark+2),a  
2c3f 18 03			jr .pastdmark  
2c41 ..			.dmark: db "IF1"  
2c44 f1			.pastdmark: pop af  
2c45			endm  
# End of macro DMARK
2c45						CALLMONITOR 
2c45 cd 39 14			call break_point_state  
2c48				endm  
# End of macro CALLMONITOR
2c48					endif 
2c48 b7				or a        ; clear carry flag 
2c49 11 00 00			ld de, 0 
2c4c eb				ex de,hl 
2c4d ed 52			sbc hl, de 
2c4f c2 d9 2c			jp nz, .iftrue 
2c52			 
2c52					if DEBUG_FORTH_WORDS 
2c52						DMARK "IF2" 
2c52 f5				push af  
2c53 3a 67 2c			ld a, (.dmark)  
2c56 32 7a ee			ld (debug_mark),a  
2c59 3a 68 2c			ld a, (.dmark+1)  
2c5c 32 7b ee			ld (debug_mark+1),a  
2c5f 3a 69 2c			ld a, (.dmark+2)  
2c62 32 7c ee			ld (debug_mark+2),a  
2c65 18 03			jr .pastdmark  
2c67 ..			.dmark: db "IF2"  
2c6a f1			.pastdmark: pop af  
2c6b			endm  
# End of macro DMARK
2c6b						CALLMONITOR 
2c6b cd 39 14			call break_point_state  
2c6e				endm  
# End of macro CALLMONITOR
2c6e					endif 
2c6e			 
2c6e			; if not true then skip to THEN 
2c6e			 
2c6e				; TODO get tok_ptr 
2c6e				; TODO consume toks until we get to THEN 
2c6e			 
2c6e 2a 61 e6			ld hl, (os_tok_ptr) 
2c71					if DEBUG_FORTH_WORDS 
2c71						DMARK "IF3" 
2c71 f5				push af  
2c72 3a 86 2c			ld a, (.dmark)  
2c75 32 7a ee			ld (debug_mark),a  
2c78 3a 87 2c			ld a, (.dmark+1)  
2c7b 32 7b ee			ld (debug_mark+1),a  
2c7e 3a 88 2c			ld a, (.dmark+2)  
2c81 32 7c ee			ld (debug_mark+2),a  
2c84 18 03			jr .pastdmark  
2c86 ..			.dmark: db "IF3"  
2c89 f1			.pastdmark: pop af  
2c8a			endm  
# End of macro DMARK
2c8a						CALLMONITOR 
2c8a cd 39 14			call break_point_state  
2c8d				endm  
# End of macro CALLMONITOR
2c8d						 
2c8d					endif 
2c8d 11 d4 2c			ld de, .ifthen 
2c90					if DEBUG_FORTH_WORDS 
2c90						DMARK "IF4" 
2c90 f5				push af  
2c91 3a a5 2c			ld a, (.dmark)  
2c94 32 7a ee			ld (debug_mark),a  
2c97 3a a6 2c			ld a, (.dmark+1)  
2c9a 32 7b ee			ld (debug_mark+1),a  
2c9d 3a a7 2c			ld a, (.dmark+2)  
2ca0 32 7c ee			ld (debug_mark+2),a  
2ca3 18 03			jr .pastdmark  
2ca5 ..			.dmark: db "IF4"  
2ca8 f1			.pastdmark: pop af  
2ca9			endm  
# End of macro DMARK
2ca9						CALLMONITOR 
2ca9 cd 39 14			call break_point_state  
2cac				endm  
# End of macro CALLMONITOR
2cac					endif 
2cac cd 4a 1e			call findnexttok  
2caf			 
2caf					if DEBUG_FORTH_WORDS 
2caf						DMARK "IF5" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 7a ee			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 7b ee			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 7c ee			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "IF5"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8						CALLMONITOR 
2cc8 cd 39 14			call break_point_state  
2ccb				endm  
# End of macro CALLMONITOR
2ccb					endif 
2ccb				; TODO replace below with ; exec using tok_ptr 
2ccb 22 61 e6			ld (os_tok_ptr), hl 
2cce c3 c0 1d			jp exec1 
2cd1				NEXTW 
2cd1 c3 2f 1d			jp macro_next 
2cd4				endm 
# End of macro NEXTW
2cd4			 
2cd4 .. 00		.ifthen:  db "THEN",0 
2cd9			 
2cd9			.iftrue:		 
2cd9				; Exec next words normally 
2cd9			 
2cd9				; if true then exec following IF as normal 
2cd9					if DEBUG_FORTH_WORDS 
2cd9						DMARK "IFT" 
2cd9 f5				push af  
2cda 3a ee 2c			ld a, (.dmark)  
2cdd 32 7a ee			ld (debug_mark),a  
2ce0 3a ef 2c			ld a, (.dmark+1)  
2ce3 32 7b ee			ld (debug_mark+1),a  
2ce6 3a f0 2c			ld a, (.dmark+2)  
2ce9 32 7c ee			ld (debug_mark+2),a  
2cec 18 03			jr .pastdmark  
2cee ..			.dmark: db "IFT"  
2cf1 f1			.pastdmark: pop af  
2cf2			endm  
# End of macro DMARK
2cf2						CALLMONITOR 
2cf2 cd 39 14			call break_point_state  
2cf5				endm  
# End of macro CALLMONITOR
2cf5					endif 
2cf5			 
2cf5					NEXTW 
2cf5 c3 2f 1d			jp macro_next 
2cf8				endm 
# End of macro NEXTW
2cf8			.THEN: 
2cf8				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2cf8 1f				db WORD_SYS_CORE+11             
2cf9 20 2d			dw .ELSE            
2cfb 05				db 4 + 1 
2cfc .. 00			db "THEN",0              
2d01				endm 
# End of macro CWHEAD
2d01			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2d01					if DEBUG_FORTH_WORDS_KEY 
2d01						DMARK "THN" 
2d01 f5				push af  
2d02 3a 16 2d			ld a, (.dmark)  
2d05 32 7a ee			ld (debug_mark),a  
2d08 3a 17 2d			ld a, (.dmark+1)  
2d0b 32 7b ee			ld (debug_mark+1),a  
2d0e 3a 18 2d			ld a, (.dmark+2)  
2d11 32 7c ee			ld (debug_mark+2),a  
2d14 18 03			jr .pastdmark  
2d16 ..			.dmark: db "THN"  
2d19 f1			.pastdmark: pop af  
2d1a			endm  
# End of macro DMARK
2d1a						CALLMONITOR 
2d1a cd 39 14			call break_point_state  
2d1d				endm  
# End of macro CALLMONITOR
2d1d					endif 
2d1d					NEXTW 
2d1d c3 2f 1d			jp macro_next 
2d20				endm 
# End of macro NEXTW
2d20			.ELSE: 
2d20				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2d20 20				db WORD_SYS_CORE+12             
2d21 48 2d			dw .DO            
2d23 03				db 2 + 1 
2d24 .. 00			db "ELSE",0              
2d29				endm 
# End of macro CWHEAD
2d29			; | ELSE ( -- ) Not supported - does nothing | TODO 
2d29			 
2d29					if DEBUG_FORTH_WORDS_KEY 
2d29						DMARK "ELS" 
2d29 f5				push af  
2d2a 3a 3e 2d			ld a, (.dmark)  
2d2d 32 7a ee			ld (debug_mark),a  
2d30 3a 3f 2d			ld a, (.dmark+1)  
2d33 32 7b ee			ld (debug_mark+1),a  
2d36 3a 40 2d			ld a, (.dmark+2)  
2d39 32 7c ee			ld (debug_mark+2),a  
2d3c 18 03			jr .pastdmark  
2d3e ..			.dmark: db "ELS"  
2d41 f1			.pastdmark: pop af  
2d42			endm  
# End of macro DMARK
2d42						CALLMONITOR 
2d42 cd 39 14			call break_point_state  
2d45				endm  
# End of macro CALLMONITOR
2d45					endif 
2d45			 
2d45			 
2d45					NEXTW 
2d45 c3 2f 1d			jp macro_next 
2d48				endm 
# End of macro NEXTW
2d48			.DO: 
2d48				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d48 21				db WORD_SYS_CORE+13             
2d49 6f 2e			dw .LOOP            
2d4b 03				db 2 + 1 
2d4c .. 00			db "DO",0              
2d4f				endm 
# End of macro CWHEAD
2d4f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2d4f			 
2d4f					if DEBUG_FORTH_WORDS_KEY 
2d4f						DMARK "DO." 
2d4f f5				push af  
2d50 3a 64 2d			ld a, (.dmark)  
2d53 32 7a ee			ld (debug_mark),a  
2d56 3a 65 2d			ld a, (.dmark+1)  
2d59 32 7b ee			ld (debug_mark+1),a  
2d5c 3a 66 2d			ld a, (.dmark+2)  
2d5f 32 7c ee			ld (debug_mark+2),a  
2d62 18 03			jr .pastdmark  
2d64 ..			.dmark: db "DO."  
2d67 f1			.pastdmark: pop af  
2d68			endm  
# End of macro DMARK
2d68						CALLMONITOR 
2d68 cd 39 14			call break_point_state  
2d6b				endm  
# End of macro CALLMONITOR
2d6b					endif 
2d6b			;  push pc to rsp stack past the DO 
2d6b			 
2d6b 2a 61 e6				ld hl, (os_tok_ptr) 
2d6e 23					inc hl   ; D 
2d6f 23					inc hl  ; O 
2d70 23					inc hl   ; null 
2d71					if DEBUG_FORTH_WORDS 
2d71						DMARK "DO2" 
2d71 f5				push af  
2d72 3a 86 2d			ld a, (.dmark)  
2d75 32 7a ee			ld (debug_mark),a  
2d78 3a 87 2d			ld a, (.dmark+1)  
2d7b 32 7b ee			ld (debug_mark+1),a  
2d7e 3a 88 2d			ld a, (.dmark+2)  
2d81 32 7c ee			ld (debug_mark+2),a  
2d84 18 03			jr .pastdmark  
2d86 ..			.dmark: db "DO2"  
2d89 f1			.pastdmark: pop af  
2d8a			endm  
# End of macro DMARK
2d8a						CALLMONITOR 
2d8a cd 39 14			call break_point_state  
2d8d				endm  
# End of macro CALLMONITOR
2d8d					endif 
2d8d					FORTH_RSP_NEXT 
2d8d cd 6d 19			call macro_forth_rsp_next 
2d90				endm 
# End of macro FORTH_RSP_NEXT
2d90					if DEBUG_FORTH_WORDS 
2d90						DMARK "DO3" 
2d90 f5				push af  
2d91 3a a5 2d			ld a, (.dmark)  
2d94 32 7a ee			ld (debug_mark),a  
2d97 3a a6 2d			ld a, (.dmark+1)  
2d9a 32 7b ee			ld (debug_mark+1),a  
2d9d 3a a7 2d			ld a, (.dmark+2)  
2da0 32 7c ee			ld (debug_mark+2),a  
2da3 18 03			jr .pastdmark  
2da5 ..			.dmark: db "DO3"  
2da8 f1			.pastdmark: pop af  
2da9			endm  
# End of macro DMARK
2da9						CALLMONITOR 
2da9 cd 39 14			call break_point_state  
2dac				endm  
# End of macro CALLMONITOR
2dac					endif 
2dac			 
2dac					;if DEBUG_FORTH_WORDS 
2dac				;		push hl 
2dac			;		endif  
2dac			 
2dac			; get counters from data stack 
2dac			 
2dac			 
2dac					FORTH_DSP_VALUEHL 
2dac cd bd 1b			call macro_dsp_valuehl 
2daf				endm 
# End of macro FORTH_DSP_VALUEHL
2daf e5					push hl		 ; hl now has starting counter which needs to be tos 
2db0			 
2db0					if DEBUG_FORTH_WORDS 
2db0						DMARK "DO4" 
2db0 f5				push af  
2db1 3a c5 2d			ld a, (.dmark)  
2db4 32 7a ee			ld (debug_mark),a  
2db7 3a c6 2d			ld a, (.dmark+1)  
2dba 32 7b ee			ld (debug_mark+1),a  
2dbd 3a c7 2d			ld a, (.dmark+2)  
2dc0 32 7c ee			ld (debug_mark+2),a  
2dc3 18 03			jr .pastdmark  
2dc5 ..			.dmark: db "DO4"  
2dc8 f1			.pastdmark: pop af  
2dc9			endm  
# End of macro DMARK
2dc9						CALLMONITOR 
2dc9 cd 39 14			call break_point_state  
2dcc				endm  
# End of macro CALLMONITOR
2dcc					endif 
2dcc					FORTH_DSP_POP 
2dcc cd 75 1c			call macro_forth_dsp_pop 
2dcf				endm 
# End of macro FORTH_DSP_POP
2dcf			 
2dcf					if DEBUG_FORTH_WORDS 
2dcf						DMARK "DO5" 
2dcf f5				push af  
2dd0 3a e4 2d			ld a, (.dmark)  
2dd3 32 7a ee			ld (debug_mark),a  
2dd6 3a e5 2d			ld a, (.dmark+1)  
2dd9 32 7b ee			ld (debug_mark+1),a  
2ddc 3a e6 2d			ld a, (.dmark+2)  
2ddf 32 7c ee			ld (debug_mark+2),a  
2de2 18 03			jr .pastdmark  
2de4 ..			.dmark: db "DO5"  
2de7 f1			.pastdmark: pop af  
2de8			endm  
# End of macro DMARK
2de8						CALLMONITOR 
2de8 cd 39 14			call break_point_state  
2deb				endm  
# End of macro CALLMONITOR
2deb					endif 
2deb			 
2deb					FORTH_DSP_VALUEHL 
2deb cd bd 1b			call macro_dsp_valuehl 
2dee				endm 
# End of macro FORTH_DSP_VALUEHL
2dee			;		push hl		 ; hl now has starting limit counter 
2dee			 
2dee					if DEBUG_FORTH_WORDS 
2dee						DMARK "DO6" 
2dee f5				push af  
2def 3a 03 2e			ld a, (.dmark)  
2df2 32 7a ee			ld (debug_mark),a  
2df5 3a 04 2e			ld a, (.dmark+1)  
2df8 32 7b ee			ld (debug_mark+1),a  
2dfb 3a 05 2e			ld a, (.dmark+2)  
2dfe 32 7c ee			ld (debug_mark+2),a  
2e01 18 03			jr .pastdmark  
2e03 ..			.dmark: db "DO6"  
2e06 f1			.pastdmark: pop af  
2e07			endm  
# End of macro DMARK
2e07						CALLMONITOR 
2e07 cd 39 14			call break_point_state  
2e0a				endm  
# End of macro CALLMONITOR
2e0a					endif 
2e0a					FORTH_DSP_POP 
2e0a cd 75 1c			call macro_forth_dsp_pop 
2e0d				endm 
# End of macro FORTH_DSP_POP
2e0d			 
2e0d			; put counters on the loop stack 
2e0d			 
2e0d			;		pop hl			 ; limit counter 
2e0d d1					pop de			; start counter 
2e0e			 
2e0e					; push limit counter 
2e0e			 
2e0e					if DEBUG_FORTH_WORDS 
2e0e						DMARK "DO7" 
2e0e f5				push af  
2e0f 3a 23 2e			ld a, (.dmark)  
2e12 32 7a ee			ld (debug_mark),a  
2e15 3a 24 2e			ld a, (.dmark+1)  
2e18 32 7b ee			ld (debug_mark+1),a  
2e1b 3a 25 2e			ld a, (.dmark+2)  
2e1e 32 7c ee			ld (debug_mark+2),a  
2e21 18 03			jr .pastdmark  
2e23 ..			.dmark: db "DO7"  
2e26 f1			.pastdmark: pop af  
2e27			endm  
# End of macro DMARK
2e27						CALLMONITOR 
2e27 cd 39 14			call break_point_state  
2e2a				endm  
# End of macro CALLMONITOR
2e2a					endif 
2e2a					FORTH_LOOP_NEXT 
2e2a cd ee 1b			call macro_forth_loop_next 
2e2d				endm 
# End of macro FORTH_LOOP_NEXT
2e2d			 
2e2d					; push start counter 
2e2d			 
2e2d eb					ex de, hl 
2e2e					if DEBUG_FORTH_WORDS 
2e2e						DMARK "DO7" 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 7a ee			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 7b ee			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 7c ee			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db "DO7"  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47						CALLMONITOR 
2e47 cd 39 14			call break_point_state  
2e4a				endm  
# End of macro CALLMONITOR
2e4a					endif 
2e4a					FORTH_LOOP_NEXT 
2e4a cd ee 1b			call macro_forth_loop_next 
2e4d				endm 
# End of macro FORTH_LOOP_NEXT
2e4d			 
2e4d			 
2e4d					; init first round of I counter 
2e4d			 
2e4d 22 85 e6				ld (os_current_i), hl 
2e50			 
2e50					if DEBUG_FORTH_WORDS 
2e50						DMARK "DO8" 
2e50 f5				push af  
2e51 3a 65 2e			ld a, (.dmark)  
2e54 32 7a ee			ld (debug_mark),a  
2e57 3a 66 2e			ld a, (.dmark+1)  
2e5a 32 7b ee			ld (debug_mark+1),a  
2e5d 3a 67 2e			ld a, (.dmark+2)  
2e60 32 7c ee			ld (debug_mark+2),a  
2e63 18 03			jr .pastdmark  
2e65 ..			.dmark: db "DO8"  
2e68 f1			.pastdmark: pop af  
2e69			endm  
# End of macro DMARK
2e69						CALLMONITOR 
2e69 cd 39 14			call break_point_state  
2e6c				endm  
# End of macro CALLMONITOR
2e6c					endif 
2e6c			 
2e6c					NEXTW 
2e6c c3 2f 1d			jp macro_next 
2e6f				endm 
# End of macro NEXTW
2e6f			.LOOP: 
2e6f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2e6f 22				db WORD_SYS_CORE+14             
2e70 87 2f			dw .I            
2e72 05				db 4 + 1 
2e73 .. 00			db "LOOP",0              
2e78				endm 
# End of macro CWHEAD
2e78			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e78			 
2e78				; pop tos as current loop count to hl 
2e78			 
2e78				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e78			 
2e78				FORTH_LOOP_TOS 
2e78 cd 21 1c			call macro_forth_loop_tos 
2e7b				endm 
# End of macro FORTH_LOOP_TOS
2e7b e5				push hl 
2e7c			 
2e7c					if DEBUG_FORTH_WORDS_KEY 
2e7c						DMARK "LOP" 
2e7c f5				push af  
2e7d 3a 91 2e			ld a, (.dmark)  
2e80 32 7a ee			ld (debug_mark),a  
2e83 3a 92 2e			ld a, (.dmark+1)  
2e86 32 7b ee			ld (debug_mark+1),a  
2e89 3a 93 2e			ld a, (.dmark+2)  
2e8c 32 7c ee			ld (debug_mark+2),a  
2e8f 18 03			jr .pastdmark  
2e91 ..			.dmark: db "LOP"  
2e94 f1			.pastdmark: pop af  
2e95			endm  
# End of macro DMARK
2e95						CALLMONITOR 
2e95 cd 39 14			call break_point_state  
2e98				endm  
# End of macro CALLMONITOR
2e98					endif 
2e98				; next item on the stack is the limit. get it 
2e98			 
2e98			 
2e98				FORTH_LOOP_POP 
2e98 cd 2b 1c			call macro_forth_loop_pop 
2e9b				endm 
# End of macro FORTH_LOOP_POP
2e9b			 
2e9b				FORTH_LOOP_TOS 
2e9b cd 21 1c			call macro_forth_loop_tos 
2e9e				endm 
# End of macro FORTH_LOOP_TOS
2e9e			 
2e9e d1				pop de		 ; de = i, hl = limit 
2e9f			 
2e9f					if DEBUG_FORTH_WORDS 
2e9f						DMARK "LP1" 
2e9f f5				push af  
2ea0 3a b4 2e			ld a, (.dmark)  
2ea3 32 7a ee			ld (debug_mark),a  
2ea6 3a b5 2e			ld a, (.dmark+1)  
2ea9 32 7b ee			ld (debug_mark+1),a  
2eac 3a b6 2e			ld a, (.dmark+2)  
2eaf 32 7c ee			ld (debug_mark+2),a  
2eb2 18 03			jr .pastdmark  
2eb4 ..			.dmark: db "LP1"  
2eb7 f1			.pastdmark: pop af  
2eb8			endm  
# End of macro DMARK
2eb8						CALLMONITOR 
2eb8 cd 39 14			call break_point_state  
2ebb				endm  
# End of macro CALLMONITOR
2ebb					endif 
2ebb			 
2ebb				; go back to previous word 
2ebb			 
2ebb d5				push de    ; save I for inc later 
2ebc			 
2ebc			 
2ebc				; get limit 
2ebc				;  is I at limit? 
2ebc			 
2ebc			 
2ebc					if DEBUG_FORTH_WORDS 
2ebc						DMARK "LP1" 
2ebc f5				push af  
2ebd 3a d1 2e			ld a, (.dmark)  
2ec0 32 7a ee			ld (debug_mark),a  
2ec3 3a d2 2e			ld a, (.dmark+1)  
2ec6 32 7b ee			ld (debug_mark+1),a  
2ec9 3a d3 2e			ld a, (.dmark+2)  
2ecc 32 7c ee			ld (debug_mark+2),a  
2ecf 18 03			jr .pastdmark  
2ed1 ..			.dmark: db "LP1"  
2ed4 f1			.pastdmark: pop af  
2ed5			endm  
# End of macro DMARK
2ed5						CALLMONITOR 
2ed5 cd 39 14			call break_point_state  
2ed8				endm  
# End of macro CALLMONITOR
2ed8					endif 
2ed8			 
2ed8 ed 52			sbc hl, de 
2eda			 
2eda			 
2eda				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2eda			 
2eda 20 26				jr nz, .loopnotdone 
2edc			 
2edc e1				pop hl   ; get rid of saved I 
2edd				FORTH_LOOP_POP     ; get rid of limit 
2edd cd 2b 1c			call macro_forth_loop_pop 
2ee0				endm 
# End of macro FORTH_LOOP_POP
2ee0			 
2ee0				FORTH_RSP_POP     ; get rid of DO ptr 
2ee0 cd 8e 19			call macro_forth_rsp_pop 
2ee3				endm 
# End of macro FORTH_RSP_POP
2ee3			 
2ee3			if DEBUG_FORTH_WORDS 
2ee3						DMARK "LP>" 
2ee3 f5				push af  
2ee4 3a f8 2e			ld a, (.dmark)  
2ee7 32 7a ee			ld (debug_mark),a  
2eea 3a f9 2e			ld a, (.dmark+1)  
2eed 32 7b ee			ld (debug_mark+1),a  
2ef0 3a fa 2e			ld a, (.dmark+2)  
2ef3 32 7c ee			ld (debug_mark+2),a  
2ef6 18 03			jr .pastdmark  
2ef8 ..			.dmark: db "LP>"  
2efb f1			.pastdmark: pop af  
2efc			endm  
# End of macro DMARK
2efc				CALLMONITOR 
2efc cd 39 14			call break_point_state  
2eff				endm  
# End of macro CALLMONITOR
2eff			endif 
2eff			 
2eff					NEXTW 
2eff c3 2f 1d			jp macro_next 
2f02				endm 
# End of macro NEXTW
2f02				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f02			 
2f02			.loopnotdone: 
2f02			 
2f02 e1				pop hl    ; get I 
2f03 23				inc hl 
2f04			 
2f04			   	; save new I 
2f04			 
2f04			 
2f04					; set I counter 
2f04			 
2f04 22 85 e6				ld (os_current_i), hl 
2f07			 
2f07					if DEBUG_FORTH_WORDS 
2f07						DMARK "LPN" 
2f07 f5				push af  
2f08 3a 1c 2f			ld a, (.dmark)  
2f0b 32 7a ee			ld (debug_mark),a  
2f0e 3a 1d 2f			ld a, (.dmark+1)  
2f11 32 7b ee			ld (debug_mark+1),a  
2f14 3a 1e 2f			ld a, (.dmark+2)  
2f17 32 7c ee			ld (debug_mark+2),a  
2f1a 18 03			jr .pastdmark  
2f1c ..			.dmark: db "LPN"  
2f1f f1			.pastdmark: pop af  
2f20			endm  
# End of macro DMARK
2f20					CALLMONITOR 
2f20 cd 39 14			call break_point_state  
2f23				endm  
# End of macro CALLMONITOR
2f23					endif 
2f23					 
2f23				FORTH_LOOP_NEXT 
2f23 cd ee 1b			call macro_forth_loop_next 
2f26				endm 
# End of macro FORTH_LOOP_NEXT
2f26			 
2f26			 
2f26					if DEBUG_FORTH_WORDS 
2f26 eb						ex de,hl 
2f27					endif 
2f27			 
2f27			;	; get DO ptr 
2f27			; 
2f27					if DEBUG_FORTH_WORDS 
2f27						DMARK "LP7" 
2f27 f5				push af  
2f28 3a 3c 2f			ld a, (.dmark)  
2f2b 32 7a ee			ld (debug_mark),a  
2f2e 3a 3d 2f			ld a, (.dmark+1)  
2f31 32 7b ee			ld (debug_mark+1),a  
2f34 3a 3e 2f			ld a, (.dmark+2)  
2f37 32 7c ee			ld (debug_mark+2),a  
2f3a 18 03			jr .pastdmark  
2f3c ..			.dmark: db "LP7"  
2f3f f1			.pastdmark: pop af  
2f40			endm  
# End of macro DMARK
2f40					CALLMONITOR 
2f40 cd 39 14			call break_point_state  
2f43				endm  
# End of macro CALLMONITOR
2f43					endif 
2f43				FORTH_RSP_TOS 
2f43 cd 84 19			call macro_forth_rsp_tos 
2f46				endm 
# End of macro FORTH_RSP_TOS
2f46			 
2f46					if DEBUG_FORTH_WORDS 
2f46						DMARK "LP8" 
2f46 f5				push af  
2f47 3a 5b 2f			ld a, (.dmark)  
2f4a 32 7a ee			ld (debug_mark),a  
2f4d 3a 5c 2f			ld a, (.dmark+1)  
2f50 32 7b ee			ld (debug_mark+1),a  
2f53 3a 5d 2f			ld a, (.dmark+2)  
2f56 32 7c ee			ld (debug_mark+2),a  
2f59 18 03			jr .pastdmark  
2f5b ..			.dmark: db "LP8"  
2f5e f1			.pastdmark: pop af  
2f5f			endm  
# End of macro DMARK
2f5f					CALLMONITOR 
2f5f cd 39 14			call break_point_state  
2f62				endm  
# End of macro CALLMONITOR
2f62					endif 
2f62				;push hl 
2f62			 
2f62				; not going to DO any more 
2f62				; get rid of the RSP pointer as DO will add it back in 
2f62				;FORTH_RSP_POP 
2f62				;pop hl 
2f62			 
2f62				;ld hl,(cli_ret_sp) 
2f62				;ld e, (hl) 
2f62				;inc hl 
2f62				;ld d, (hl) 
2f62				;ex de,hl 
2f62 22 61 e6			ld (os_tok_ptr), hl 
2f65					if DEBUG_FORTH_WORDS 
2f65						DMARK "LP<" 
2f65 f5				push af  
2f66 3a 7a 2f			ld a, (.dmark)  
2f69 32 7a ee			ld (debug_mark),a  
2f6c 3a 7b 2f			ld a, (.dmark+1)  
2f6f 32 7b ee			ld (debug_mark+1),a  
2f72 3a 7c 2f			ld a, (.dmark+2)  
2f75 32 7c ee			ld (debug_mark+2),a  
2f78 18 03			jr .pastdmark  
2f7a ..			.dmark: db "LP<"  
2f7d f1			.pastdmark: pop af  
2f7e			endm  
# End of macro DMARK
2f7e					CALLMONITOR 
2f7e cd 39 14			call break_point_state  
2f81				endm  
# End of macro CALLMONITOR
2f81				endif 
2f81 c3 c0 1d			jp exec1 
2f84			 
2f84					 
2f84			 
2f84			 
2f84					NEXTW 
2f84 c3 2f 1d			jp macro_next 
2f87				endm 
# End of macro NEXTW
2f87			.I:  
2f87			 
2f87				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f87 5e				db WORD_SYS_CORE+74             
2f88 b2 2f			dw .DLOOP            
2f8a 02				db 1 + 1 
2f8b .. 00			db "I",0              
2f8d				endm 
# End of macro CWHEAD
2f8d			; | I ( -- ) Current loop counter | DONE 
2f8d					if DEBUG_FORTH_WORDS_KEY 
2f8d						DMARK "I.." 
2f8d f5				push af  
2f8e 3a a2 2f			ld a, (.dmark)  
2f91 32 7a ee			ld (debug_mark),a  
2f94 3a a3 2f			ld a, (.dmark+1)  
2f97 32 7b ee			ld (debug_mark+1),a  
2f9a 3a a4 2f			ld a, (.dmark+2)  
2f9d 32 7c ee			ld (debug_mark+2),a  
2fa0 18 03			jr .pastdmark  
2fa2 ..			.dmark: db "I.."  
2fa5 f1			.pastdmark: pop af  
2fa6			endm  
# End of macro DMARK
2fa6						CALLMONITOR 
2fa6 cd 39 14			call break_point_state  
2fa9				endm  
# End of macro CALLMONITOR
2fa9					endif 
2fa9			 
2fa9 2a 85 e6				ld hl,(os_current_i) 
2fac cd c6 19				call forth_push_numhl 
2faf			 
2faf					NEXTW 
2faf c3 2f 1d			jp macro_next 
2fb2				endm 
# End of macro NEXTW
2fb2			.DLOOP: 
2fb2				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2fb2 5f				db WORD_SYS_CORE+75             
2fb3 93 30			dw .REPEAT            
2fb5 06				db 5 + 1 
2fb6 .. 00			db "-LOOP",0              
2fbc				endm 
# End of macro CWHEAD
2fbc			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2fbc				; pop tos as current loop count to hl 
2fbc					if DEBUG_FORTH_WORDS_KEY 
2fbc						DMARK "-LP" 
2fbc f5				push af  
2fbd 3a d1 2f			ld a, (.dmark)  
2fc0 32 7a ee			ld (debug_mark),a  
2fc3 3a d2 2f			ld a, (.dmark+1)  
2fc6 32 7b ee			ld (debug_mark+1),a  
2fc9 3a d3 2f			ld a, (.dmark+2)  
2fcc 32 7c ee			ld (debug_mark+2),a  
2fcf 18 03			jr .pastdmark  
2fd1 ..			.dmark: db "-LP"  
2fd4 f1			.pastdmark: pop af  
2fd5			endm  
# End of macro DMARK
2fd5						CALLMONITOR 
2fd5 cd 39 14			call break_point_state  
2fd8				endm  
# End of macro CALLMONITOR
2fd8					endif 
2fd8			 
2fd8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2fd8			 
2fd8				FORTH_LOOP_TOS 
2fd8 cd 21 1c			call macro_forth_loop_tos 
2fdb				endm 
# End of macro FORTH_LOOP_TOS
2fdb e5				push hl 
2fdc			 
2fdc					if DEBUG_FORTH_WORDS 
2fdc						DMARK "-LP" 
2fdc f5				push af  
2fdd 3a f1 2f			ld a, (.dmark)  
2fe0 32 7a ee			ld (debug_mark),a  
2fe3 3a f2 2f			ld a, (.dmark+1)  
2fe6 32 7b ee			ld (debug_mark+1),a  
2fe9 3a f3 2f			ld a, (.dmark+2)  
2fec 32 7c ee			ld (debug_mark+2),a  
2fef 18 03			jr .pastdmark  
2ff1 ..			.dmark: db "-LP"  
2ff4 f1			.pastdmark: pop af  
2ff5			endm  
# End of macro DMARK
2ff5						CALLMONITOR 
2ff5 cd 39 14			call break_point_state  
2ff8				endm  
# End of macro CALLMONITOR
2ff8					endif 
2ff8				; next item on the stack is the limit. get it 
2ff8			 
2ff8			 
2ff8				FORTH_LOOP_POP 
2ff8 cd 2b 1c			call macro_forth_loop_pop 
2ffb				endm 
# End of macro FORTH_LOOP_POP
2ffb			 
2ffb				FORTH_LOOP_TOS 
2ffb cd 21 1c			call macro_forth_loop_tos 
2ffe				endm 
# End of macro FORTH_LOOP_TOS
2ffe			 
2ffe d1				pop de		 ; de = i, hl = limit 
2fff			 
2fff					if DEBUG_FORTH_WORDS 
2fff						DMARK "-L1" 
2fff f5				push af  
3000 3a 14 30			ld a, (.dmark)  
3003 32 7a ee			ld (debug_mark),a  
3006 3a 15 30			ld a, (.dmark+1)  
3009 32 7b ee			ld (debug_mark+1),a  
300c 3a 16 30			ld a, (.dmark+2)  
300f 32 7c ee			ld (debug_mark+2),a  
3012 18 03			jr .pastdmark  
3014 ..			.dmark: db "-L1"  
3017 f1			.pastdmark: pop af  
3018			endm  
# End of macro DMARK
3018						CALLMONITOR 
3018 cd 39 14			call break_point_state  
301b				endm  
# End of macro CALLMONITOR
301b					endif 
301b			 
301b				; go back to previous word 
301b			 
301b d5				push de    ; save I for inc later 
301c			 
301c			 
301c				; get limit 
301c				;  is I at limit? 
301c			 
301c			 
301c					if DEBUG_FORTH_WORDS 
301c						DMARK "-L1" 
301c f5				push af  
301d 3a 31 30			ld a, (.dmark)  
3020 32 7a ee			ld (debug_mark),a  
3023 3a 32 30			ld a, (.dmark+1)  
3026 32 7b ee			ld (debug_mark+1),a  
3029 3a 33 30			ld a, (.dmark+2)  
302c 32 7c ee			ld (debug_mark+2),a  
302f 18 03			jr .pastdmark  
3031 ..			.dmark: db "-L1"  
3034 f1			.pastdmark: pop af  
3035			endm  
# End of macro DMARK
3035						CALLMONITOR 
3035 cd 39 14			call break_point_state  
3038				endm  
# End of macro CALLMONITOR
3038					endif 
3038			 
3038 ed 52			sbc hl, de 
303a			 
303a			 
303a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
303a			 
303a 20 26				jr nz, .mloopnotdone 
303c			 
303c e1				pop hl   ; get rid of saved I 
303d				FORTH_LOOP_POP     ; get rid of limit 
303d cd 2b 1c			call macro_forth_loop_pop 
3040				endm 
# End of macro FORTH_LOOP_POP
3040			 
3040				FORTH_RSP_POP     ; get rid of DO ptr 
3040 cd 8e 19			call macro_forth_rsp_pop 
3043				endm 
# End of macro FORTH_RSP_POP
3043			 
3043			if DEBUG_FORTH_WORDS 
3043						DMARK "-L>" 
3043 f5				push af  
3044 3a 58 30			ld a, (.dmark)  
3047 32 7a ee			ld (debug_mark),a  
304a 3a 59 30			ld a, (.dmark+1)  
304d 32 7b ee			ld (debug_mark+1),a  
3050 3a 5a 30			ld a, (.dmark+2)  
3053 32 7c ee			ld (debug_mark+2),a  
3056 18 03			jr .pastdmark  
3058 ..			.dmark: db "-L>"  
305b f1			.pastdmark: pop af  
305c			endm  
# End of macro DMARK
305c				CALLMONITOR 
305c cd 39 14			call break_point_state  
305f				endm  
# End of macro CALLMONITOR
305f			endif 
305f			 
305f					NEXTW 
305f c3 2f 1d			jp macro_next 
3062				endm 
# End of macro NEXTW
3062				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3062			 
3062			.mloopnotdone: 
3062			 
3062 e1				pop hl    ; get I 
3063 2b				dec hl 
3064			 
3064			   	; save new I 
3064			 
3064			 
3064					; set I counter 
3064			 
3064 22 85 e6				ld (os_current_i), hl 
3067			 
3067					 
3067				FORTH_LOOP_NEXT 
3067 cd ee 1b			call macro_forth_loop_next 
306a				endm 
# End of macro FORTH_LOOP_NEXT
306a			 
306a			 
306a					if DEBUG_FORTH_WORDS 
306a eb						ex de,hl 
306b					endif 
306b			 
306b			;	; get DO ptr 
306b			; 
306b				FORTH_RSP_TOS 
306b cd 84 19			call macro_forth_rsp_tos 
306e				endm 
# End of macro FORTH_RSP_TOS
306e			 
306e				;push hl 
306e			 
306e				; not going to DO any more 
306e				; get rid of the RSP pointer as DO will add it back in 
306e				;FORTH_RSP_POP 
306e				;pop hl 
306e			 
306e			 
306e 22 61 e6			ld (os_tok_ptr), hl 
3071					if DEBUG_FORTH_WORDS 
3071						DMARK "-L<" 
3071 f5				push af  
3072 3a 86 30			ld a, (.dmark)  
3075 32 7a ee			ld (debug_mark),a  
3078 3a 87 30			ld a, (.dmark+1)  
307b 32 7b ee			ld (debug_mark+1),a  
307e 3a 88 30			ld a, (.dmark+2)  
3081 32 7c ee			ld (debug_mark+2),a  
3084 18 03			jr .pastdmark  
3086 ..			.dmark: db "-L<"  
3089 f1			.pastdmark: pop af  
308a			endm  
# End of macro DMARK
308a					CALLMONITOR 
308a cd 39 14			call break_point_state  
308d				endm  
# End of macro CALLMONITOR
308d				endif 
308d c3 c0 1d			jp exec1 
3090			 
3090					 
3090			 
3090			 
3090			 
3090				NEXTW 
3090 c3 2f 1d			jp macro_next 
3093				endm 
# End of macro NEXTW
3093			 
3093			 
3093			 
3093			 
3093			.REPEAT: 
3093				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3093 71				db WORD_SYS_CORE+93             
3094 e6 30			dw .UNTIL            
3096 06				db 5 + 1 
3097 .. 00			db "REPEAT",0              
309e				endm 
# End of macro CWHEAD
309e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
309e			;  push pc to rsp stack past the REPEAT 
309e					if DEBUG_FORTH_WORDS_KEY 
309e						DMARK "REP" 
309e f5				push af  
309f 3a b3 30			ld a, (.dmark)  
30a2 32 7a ee			ld (debug_mark),a  
30a5 3a b4 30			ld a, (.dmark+1)  
30a8 32 7b ee			ld (debug_mark+1),a  
30ab 3a b5 30			ld a, (.dmark+2)  
30ae 32 7c ee			ld (debug_mark+2),a  
30b1 18 03			jr .pastdmark  
30b3 ..			.dmark: db "REP"  
30b6 f1			.pastdmark: pop af  
30b7			endm  
# End of macro DMARK
30b7						CALLMONITOR 
30b7 cd 39 14			call break_point_state  
30ba				endm  
# End of macro CALLMONITOR
30ba					endif 
30ba			 
30ba 2a 61 e6				ld hl, (os_tok_ptr) 
30bd 23					inc hl   ; R 
30be 23					inc hl  ; E 
30bf 23					inc hl   ; P 
30c0 23					inc hl   ; E 
30c1 23					inc hl   ; A 
30c2 23					inc hl   ; T 
30c3 23					inc hl   ; zero 
30c4					FORTH_RSP_NEXT 
30c4 cd 6d 19			call macro_forth_rsp_next 
30c7				endm 
# End of macro FORTH_RSP_NEXT
30c7			 
30c7			 
30c7					if DEBUG_FORTH_WORDS 
30c7						DMARK "REP" 
30c7 f5				push af  
30c8 3a dc 30			ld a, (.dmark)  
30cb 32 7a ee			ld (debug_mark),a  
30ce 3a dd 30			ld a, (.dmark+1)  
30d1 32 7b ee			ld (debug_mark+1),a  
30d4 3a de 30			ld a, (.dmark+2)  
30d7 32 7c ee			ld (debug_mark+2),a  
30da 18 03			jr .pastdmark  
30dc ..			.dmark: db "REP"  
30df f1			.pastdmark: pop af  
30e0			endm  
# End of macro DMARK
30e0						;pop bc    ; TODO BUG ?????? what is this for???? 
30e0						CALLMONITOR 
30e0 cd 39 14			call break_point_state  
30e3				endm  
# End of macro CALLMONITOR
30e3					endif 
30e3			 
30e3					NEXTW 
30e3 c3 2f 1d			jp macro_next 
30e6				endm 
# End of macro NEXTW
30e6			;	       NEXTW 
30e6			 
30e6			.UNTIL: 
30e6				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
30e6 72				db WORD_SYS_CORE+94             
30e7 7d 31			dw .ENDFLOW            
30e9 06				db 5 + 1 
30ea .. 00			db "UNTIL",0              
30f0				endm 
# End of macro CWHEAD
30f0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
30f0			 
30f0				; pop tos as check 
30f0			 
30f0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30f0			 
30f0				FORTH_DSP_VALUEHL 
30f0 cd bd 1b			call macro_dsp_valuehl 
30f3				endm 
# End of macro FORTH_DSP_VALUEHL
30f3			 
30f3					if DEBUG_FORTH_WORDS_KEY 
30f3						DMARK "UNT" 
30f3 f5				push af  
30f4 3a 08 31			ld a, (.dmark)  
30f7 32 7a ee			ld (debug_mark),a  
30fa 3a 09 31			ld a, (.dmark+1)  
30fd 32 7b ee			ld (debug_mark+1),a  
3100 3a 0a 31			ld a, (.dmark+2)  
3103 32 7c ee			ld (debug_mark+2),a  
3106 18 03			jr .pastdmark  
3108 ..			.dmark: db "UNT"  
310b f1			.pastdmark: pop af  
310c			endm  
# End of macro DMARK
310c						CALLMONITOR 
310c cd 39 14			call break_point_state  
310f				endm  
# End of macro CALLMONITOR
310f					endif 
310f			 
310f			;	push hl 
310f				FORTH_DSP_POP 
310f cd 75 1c			call macro_forth_dsp_pop 
3112				endm 
# End of macro FORTH_DSP_POP
3112			 
3112			;	pop hl 
3112			 
3112				; test if true 
3112			 
3112 cd ef 0b			call ishlzero 
3115			;	ld a,l 
3115			;	add h 
3115			; 
3115			;	cp 0 
3115			 
3115 20 3e			jr nz, .untilnotdone 
3117			 
3117					if DEBUG_FORTH_WORDS 
3117						DMARK "UNf" 
3117 f5				push af  
3118 3a 2c 31			ld a, (.dmark)  
311b 32 7a ee			ld (debug_mark),a  
311e 3a 2d 31			ld a, (.dmark+1)  
3121 32 7b ee			ld (debug_mark+1),a  
3124 3a 2e 31			ld a, (.dmark+2)  
3127 32 7c ee			ld (debug_mark+2),a  
312a 18 03			jr .pastdmark  
312c ..			.dmark: db "UNf"  
312f f1			.pastdmark: pop af  
3130			endm  
# End of macro DMARK
3130						CALLMONITOR 
3130 cd 39 14			call break_point_state  
3133				endm  
# End of macro CALLMONITOR
3133					endif 
3133			 
3133			 
3133			 
3133				FORTH_RSP_POP     ; get rid of DO ptr 
3133 cd 8e 19			call macro_forth_rsp_pop 
3136				endm 
# End of macro FORTH_RSP_POP
3136			 
3136			if DEBUG_FORTH_WORDS 
3136						DMARK "UN>" 
3136 f5				push af  
3137 3a 4b 31			ld a, (.dmark)  
313a 32 7a ee			ld (debug_mark),a  
313d 3a 4c 31			ld a, (.dmark+1)  
3140 32 7b ee			ld (debug_mark+1),a  
3143 3a 4d 31			ld a, (.dmark+2)  
3146 32 7c ee			ld (debug_mark+2),a  
3149 18 03			jr .pastdmark  
314b ..			.dmark: db "UN>"  
314e f1			.pastdmark: pop af  
314f			endm  
# End of macro DMARK
314f				CALLMONITOR 
314f cd 39 14			call break_point_state  
3152				endm  
# End of macro CALLMONITOR
3152			endif 
3152			 
3152					NEXTW 
3152 c3 2f 1d			jp macro_next 
3155				endm 
# End of macro NEXTW
3155				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3155			 
3155			.untilnotdone: 
3155			 
3155			 
3155			;	; get DO ptr 
3155			; 
3155				FORTH_RSP_TOS 
3155 cd 84 19			call macro_forth_rsp_tos 
3158				endm 
# End of macro FORTH_RSP_TOS
3158			 
3158				;push hl 
3158			 
3158				; not going to DO any more 
3158				; get rid of the RSP pointer as DO will add it back in 
3158				;FORTH_RSP_POP 
3158				;pop hl 
3158			 
3158			 
3158 22 61 e6			ld (os_tok_ptr), hl 
315b					if DEBUG_FORTH_WORDS 
315b						DMARK "UN<" 
315b f5				push af  
315c 3a 70 31			ld a, (.dmark)  
315f 32 7a ee			ld (debug_mark),a  
3162 3a 71 31			ld a, (.dmark+1)  
3165 32 7b ee			ld (debug_mark+1),a  
3168 3a 72 31			ld a, (.dmark+2)  
316b 32 7c ee			ld (debug_mark+2),a  
316e 18 03			jr .pastdmark  
3170 ..			.dmark: db "UN<"  
3173 f1			.pastdmark: pop af  
3174			endm  
# End of macro DMARK
3174					CALLMONITOR 
3174 cd 39 14			call break_point_state  
3177				endm  
# End of macro CALLMONITOR
3177				endif 
3177 c3 c0 1d			jp exec1 
317a			 
317a					 
317a			 
317a			 
317a					NEXTW 
317a c3 2f 1d			jp macro_next 
317d				endm 
# End of macro NEXTW
317d			 
317d			 
317d			.ENDFLOW: 
317d			 
317d			; eof 
317d			 
# End of file forth_words_flow.asm
317d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
317d			include "forth_words_logic.asm" 
317d			 
317d			; | ## Logic Words 
317d			 
317d			.NOT: 
317d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
317d 2d				db WORD_SYS_CORE+25             
317e c5 31			dw .IS            
3180 04				db 3 + 1 
3181 .. 00			db "NOT",0              
3185				endm 
# End of macro CWHEAD
3185			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3185					if DEBUG_FORTH_WORDS_KEY 
3185						DMARK "NOT" 
3185 f5				push af  
3186 3a 9a 31			ld a, (.dmark)  
3189 32 7a ee			ld (debug_mark),a  
318c 3a 9b 31			ld a, (.dmark+1)  
318f 32 7b ee			ld (debug_mark+1),a  
3192 3a 9c 31			ld a, (.dmark+2)  
3195 32 7c ee			ld (debug_mark+2),a  
3198 18 03			jr .pastdmark  
319a ..			.dmark: db "NOT"  
319d f1			.pastdmark: pop af  
319e			endm  
# End of macro DMARK
319e						CALLMONITOR 
319e cd 39 14			call break_point_state  
31a1				endm  
# End of macro CALLMONITOR
31a1					endif 
31a1					FORTH_DSP 
31a1 cd 83 1b			call macro_forth_dsp 
31a4				endm 
# End of macro FORTH_DSP
31a4 7e					ld a,(hl)	; get type of value on TOS 
31a5 fe 02				cp DS_TYPE_INUM  
31a7 28 03				jr z, .noti 
31a9					NEXTW 
31a9 c3 2f 1d			jp macro_next 
31ac				endm 
# End of macro NEXTW
31ac			.noti:          FORTH_DSP_VALUEHL 
31ac cd bd 1b			call macro_dsp_valuehl 
31af				endm 
# End of macro FORTH_DSP_VALUEHL
31af			;		push hl 
31af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31af cd 75 1c			call macro_forth_dsp_pop 
31b2				endm 
# End of macro FORTH_DSP_POP
31b2			;		pop hl 
31b2 3e 00				ld a,0 
31b4 bd					cp l 
31b5 28 04				jr z, .not2t 
31b7 2e 00				ld l, 0 
31b9 18 02				jr .notip 
31bb			 
31bb 2e ff		.not2t:		ld l, 255 
31bd			 
31bd 26 00		.notip:		ld h, 0	 
31bf			 
31bf cd c6 19				call forth_push_numhl 
31c2					NEXTW 
31c2 c3 2f 1d			jp macro_next 
31c5				endm 
# End of macro NEXTW
31c5			 
31c5			.IS: 
31c5				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
31c5 2d				db WORD_SYS_CORE+25             
31c6 eb 31			dw .LZERO            
31c8 03				db 2 + 1 
31c9 .. 00			db "IS",0              
31cc				endm 
# End of macro CWHEAD
31cc			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
31cc					if DEBUG_FORTH_WORDS_KEY 
31cc						DMARK "IS." 
31cc f5				push af  
31cd 3a e1 31			ld a, (.dmark)  
31d0 32 7a ee			ld (debug_mark),a  
31d3 3a e2 31			ld a, (.dmark+1)  
31d6 32 7b ee			ld (debug_mark+1),a  
31d9 3a e3 31			ld a, (.dmark+2)  
31dc 32 7c ee			ld (debug_mark+2),a  
31df 18 03			jr .pastdmark  
31e1 ..			.dmark: db "IS."  
31e4 f1			.pastdmark: pop af  
31e5			endm  
# End of macro DMARK
31e5						CALLMONITOR 
31e5 cd 39 14			call break_point_state  
31e8				endm  
# End of macro CALLMONITOR
31e8					endif 
31e8					NEXTW 
31e8 c3 2f 1d			jp macro_next 
31eb				endm 
# End of macro NEXTW
31eb			.LZERO: 
31eb				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
31eb 2d				db WORD_SYS_CORE+25             
31ec f5 31			dw .TZERO            
31ee 03				db 2 + 1 
31ef .. 00			db "0<",0              
31f2				endm 
# End of macro CWHEAD
31f2			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
31f2					NEXTW 
31f2 c3 2f 1d			jp macro_next 
31f5				endm 
# End of macro NEXTW
31f5			.TZERO: 
31f5				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
31f5 2e				db WORD_SYS_CORE+26             
31f6 3c 32			dw .LESS            
31f8 03				db 2 + 1 
31f9 .. 00			db "0=",0              
31fc				endm 
# End of macro CWHEAD
31fc			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
31fc				; TODO add floating point number detection 
31fc					;v5 FORTH_DSP_VALUE 
31fc					if DEBUG_FORTH_WORDS_KEY 
31fc						DMARK "0=." 
31fc f5				push af  
31fd 3a 11 32			ld a, (.dmark)  
3200 32 7a ee			ld (debug_mark),a  
3203 3a 12 32			ld a, (.dmark+1)  
3206 32 7b ee			ld (debug_mark+1),a  
3209 3a 13 32			ld a, (.dmark+2)  
320c 32 7c ee			ld (debug_mark+2),a  
320f 18 03			jr .pastdmark  
3211 ..			.dmark: db "0=."  
3214 f1			.pastdmark: pop af  
3215			endm  
# End of macro DMARK
3215						CALLMONITOR 
3215 cd 39 14			call break_point_state  
3218				endm  
# End of macro CALLMONITOR
3218					endif 
3218					FORTH_DSP 
3218 cd 83 1b			call macro_forth_dsp 
321b				endm 
# End of macro FORTH_DSP
321b 7e					ld a,(hl)	; get type of value on TOS 
321c fe 02				cp DS_TYPE_INUM  
321e 28 00				jr z, .tz_inum 
3220			 
3220				if FORTH_ENABLE_FLOATMATH 
3220					jr .tz_done 
3220			 
3220				endif 
3220					 
3220			 
3220			.tz_inum: 
3220					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3220 cd bd 1b			call macro_dsp_valuehl 
3223				endm 
# End of macro FORTH_DSP_VALUEHL
3223			 
3223			;		push hl 
3223			 
3223					; destroy value TOS 
3223			 
3223					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3223 cd 75 1c			call macro_forth_dsp_pop 
3226				endm 
# End of macro FORTH_DSP_POP
3226			 
3226			;		pop hl 
3226			 
3226 3e 00				ld a,0 
3228			 
3228 bd					cp l 
3229 20 08				jr nz, .tz_notzero 
322b			 
322b bc					cp h 
322c			 
322c 20 05				jr nz, .tz_notzero 
322e			 
322e			 
322e 21 01 00				ld hl, FORTH_TRUE 
3231 18 03				jr .tz_done 
3233			 
3233 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3236			 
3236					; push value back onto stack for another op etc 
3236			 
3236			.tz_done: 
3236 cd c6 19				call forth_push_numhl 
3239			 
3239					NEXTW 
3239 c3 2f 1d			jp macro_next 
323c				endm 
# End of macro NEXTW
323c			.LESS: 
323c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
323c 2f				db WORD_SYS_CORE+27             
323d a5 32			dw .GT            
323f 02				db 1 + 1 
3240 .. 00			db "<",0              
3242				endm 
# End of macro CWHEAD
3242			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3242				; TODO add floating point number detection 
3242					if DEBUG_FORTH_WORDS_KEY 
3242						DMARK "LES" 
3242 f5				push af  
3243 3a 57 32			ld a, (.dmark)  
3246 32 7a ee			ld (debug_mark),a  
3249 3a 58 32			ld a, (.dmark+1)  
324c 32 7b ee			ld (debug_mark+1),a  
324f 3a 59 32			ld a, (.dmark+2)  
3252 32 7c ee			ld (debug_mark+2),a  
3255 18 03			jr .pastdmark  
3257 ..			.dmark: db "LES"  
325a f1			.pastdmark: pop af  
325b			endm  
# End of macro DMARK
325b						CALLMONITOR 
325b cd 39 14			call break_point_state  
325e				endm  
# End of macro CALLMONITOR
325e					endif 
325e					FORTH_DSP 
325e cd 83 1b			call macro_forth_dsp 
3261				endm 
# End of macro FORTH_DSP
3261					;v5 FORTH_DSP_VALUE 
3261 7e					ld a,(hl)	; get type of value on TOS 
3262 fe 02				cp DS_TYPE_INUM  
3264 28 00				jr z, .less_inum 
3266			 
3266				if FORTH_ENABLE_FLOATMATH 
3266					jr .less_done 
3266			 
3266				endif 
3266					 
3266			 
3266			.less_inum: 
3266					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3266 cd bd 1b			call macro_dsp_valuehl 
3269				endm 
# End of macro FORTH_DSP_VALUEHL
3269			 
3269 e5					push hl  ; u2 
326a			 
326a					; destroy value TOS 
326a			 
326a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
326a cd 75 1c			call macro_forth_dsp_pop 
326d				endm 
# End of macro FORTH_DSP_POP
326d			 
326d			 
326d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
326d cd bd 1b			call macro_dsp_valuehl 
3270				endm 
# End of macro FORTH_DSP_VALUEHL
3270			 
3270 e5					push hl    ; u1 
3271			 
3271					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3271 cd 75 1c			call macro_forth_dsp_pop 
3274				endm 
# End of macro FORTH_DSP_POP
3274			 
3274			 
3274 b7			 or a      ;clear carry flag 
3275 01 00 00		 ld bc, FORTH_FALSE 
3278 e1			  pop hl    ; u1 
3279 d1			  pop de    ; u2 
327a ed 52		  sbc hl,de 
327c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
327e			 
327e 01 01 00		 ld bc, FORTH_TRUE 
3281			.lscont:  
3281 c5					push bc 
3282 e1					pop hl 
3283			 
3283					if DEBUG_FORTH_WORDS 
3283						DMARK "LT1" 
3283 f5				push af  
3284 3a 98 32			ld a, (.dmark)  
3287 32 7a ee			ld (debug_mark),a  
328a 3a 99 32			ld a, (.dmark+1)  
328d 32 7b ee			ld (debug_mark+1),a  
3290 3a 9a 32			ld a, (.dmark+2)  
3293 32 7c ee			ld (debug_mark+2),a  
3296 18 03			jr .pastdmark  
3298 ..			.dmark: db "LT1"  
329b f1			.pastdmark: pop af  
329c			endm  
# End of macro DMARK
329c						CALLMONITOR 
329c cd 39 14			call break_point_state  
329f				endm  
# End of macro CALLMONITOR
329f					endif 
329f cd c6 19				call forth_push_numhl 
32a2			 
32a2					NEXTW 
32a2 c3 2f 1d			jp macro_next 
32a5				endm 
# End of macro NEXTW
32a5			.GT: 
32a5				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
32a5 30				db WORD_SYS_CORE+28             
32a6 0e 33			dw .EQUAL            
32a8 02				db 1 + 1 
32a9 .. 00			db ">",0              
32ab				endm 
# End of macro CWHEAD
32ab			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
32ab				; TODO add floating point number detection 
32ab					if DEBUG_FORTH_WORDS_KEY 
32ab						DMARK "GRT" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 7a ee			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 7b ee			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 7c ee			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "GRT"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd 39 14			call break_point_state  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7					FORTH_DSP 
32c7 cd 83 1b			call macro_forth_dsp 
32ca				endm 
# End of macro FORTH_DSP
32ca					;FORTH_DSP_VALUE 
32ca 7e					ld a,(hl)	; get type of value on TOS 
32cb fe 02				cp DS_TYPE_INUM  
32cd 28 00				jr z, .gt_inum 
32cf			 
32cf				if FORTH_ENABLE_FLOATMATH 
32cf					jr .gt_done 
32cf			 
32cf				endif 
32cf					 
32cf			 
32cf			.gt_inum: 
32cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32cf cd bd 1b			call macro_dsp_valuehl 
32d2				endm 
# End of macro FORTH_DSP_VALUEHL
32d2			 
32d2 e5					push hl  ; u2 
32d3			 
32d3					; destroy value TOS 
32d3			 
32d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d3 cd 75 1c			call macro_forth_dsp_pop 
32d6				endm 
# End of macro FORTH_DSP_POP
32d6			 
32d6			 
32d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32d6 cd bd 1b			call macro_dsp_valuehl 
32d9				endm 
# End of macro FORTH_DSP_VALUEHL
32d9			 
32d9 e5					push hl    ; u1 
32da			 
32da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32da cd 75 1c			call macro_forth_dsp_pop 
32dd				endm 
# End of macro FORTH_DSP_POP
32dd			 
32dd			 
32dd b7			 or a      ;clear carry flag 
32de 01 00 00		 ld bc, FORTH_FALSE 
32e1 e1			  pop hl    ; u1 
32e2 d1			  pop de    ; u2 
32e3 ed 52		  sbc hl,de 
32e5 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
32e7			 
32e7 01 01 00		 ld bc, FORTH_TRUE 
32ea			.gtcont:  
32ea c5					push bc 
32eb e1					pop hl 
32ec			 
32ec					if DEBUG_FORTH_WORDS 
32ec						DMARK "GT1" 
32ec f5				push af  
32ed 3a 01 33			ld a, (.dmark)  
32f0 32 7a ee			ld (debug_mark),a  
32f3 3a 02 33			ld a, (.dmark+1)  
32f6 32 7b ee			ld (debug_mark+1),a  
32f9 3a 03 33			ld a, (.dmark+2)  
32fc 32 7c ee			ld (debug_mark+2),a  
32ff 18 03			jr .pastdmark  
3301 ..			.dmark: db "GT1"  
3304 f1			.pastdmark: pop af  
3305			endm  
# End of macro DMARK
3305						CALLMONITOR 
3305 cd 39 14			call break_point_state  
3308				endm  
# End of macro CALLMONITOR
3308					endif 
3308 cd c6 19				call forth_push_numhl 
330b			 
330b					NEXTW 
330b c3 2f 1d			jp macro_next 
330e				endm 
# End of macro NEXTW
330e			.EQUAL: 
330e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
330e 31				db WORD_SYS_CORE+29             
330f 79 33			dw .ENDLOGIC            
3311 02				db 1 + 1 
3312 .. 00			db "=",0              
3314				endm 
# End of macro CWHEAD
3314			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3314				; TODO add floating point number detection 
3314					if DEBUG_FORTH_WORDS_KEY 
3314						DMARK "EQ." 
3314 f5				push af  
3315 3a 29 33			ld a, (.dmark)  
3318 32 7a ee			ld (debug_mark),a  
331b 3a 2a 33			ld a, (.dmark+1)  
331e 32 7b ee			ld (debug_mark+1),a  
3321 3a 2b 33			ld a, (.dmark+2)  
3324 32 7c ee			ld (debug_mark+2),a  
3327 18 03			jr .pastdmark  
3329 ..			.dmark: db "EQ."  
332c f1			.pastdmark: pop af  
332d			endm  
# End of macro DMARK
332d						CALLMONITOR 
332d cd 39 14			call break_point_state  
3330				endm  
# End of macro CALLMONITOR
3330					endif 
3330					FORTH_DSP 
3330 cd 83 1b			call macro_forth_dsp 
3333				endm 
# End of macro FORTH_DSP
3333					;v5 FORTH_DSP_VALUE 
3333 7e					ld a,(hl)	; get type of value on TOS 
3334 fe 02				cp DS_TYPE_INUM  
3336 28 00				jr z, .eq_inum 
3338			 
3338				if FORTH_ENABLE_FLOATMATH 
3338					jr .eq_done 
3338			 
3338				endif 
3338					 
3338			 
3338			.eq_inum: 
3338					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3338 cd bd 1b			call macro_dsp_valuehl 
333b				endm 
# End of macro FORTH_DSP_VALUEHL
333b			 
333b e5					push hl 
333c			 
333c					; destroy value TOS 
333c			 
333c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
333c cd 75 1c			call macro_forth_dsp_pop 
333f				endm 
# End of macro FORTH_DSP_POP
333f			 
333f			 
333f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
333f cd bd 1b			call macro_dsp_valuehl 
3342				endm 
# End of macro FORTH_DSP_VALUEHL
3342			 
3342					; one value on hl get other one back 
3342			 
3342 e5					push hl 
3343			 
3343					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3343 cd 75 1c			call macro_forth_dsp_pop 
3346				endm 
# End of macro FORTH_DSP_POP
3346			 
3346 0e 00				ld c, FORTH_FALSE 
3348			 
3348 e1					pop hl 
3349 d1					pop de 
334a			 
334a 7b					ld a, e 
334b bd					cp l 
334c			 
334c 20 06				jr nz, .eq_done 
334e			 
334e 7a					ld a, d 
334f bc					cp h 
3350			 
3350 20 02				jr nz, .eq_done 
3352			 
3352 0e 01				ld c, FORTH_TRUE 
3354					 
3354			 
3354			 
3354			.eq_done: 
3354			 
3354					; TODO push value back onto stack for another op etc 
3354			 
3354 26 00				ld h, 0 
3356 69					ld l, c 
3357					if DEBUG_FORTH_WORDS 
3357						DMARK "EQ1" 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 7a ee			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 7b ee			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 7c ee			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "EQ1"  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd 39 14			call break_point_state  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373 cd c6 19				call forth_push_numhl 
3376			 
3376					NEXTW 
3376 c3 2f 1d			jp macro_next 
3379				endm 
# End of macro NEXTW
3379			 
3379			 
3379			.ENDLOGIC: 
3379			; eof 
3379			 
3379			 
# End of file forth_words_logic.asm
3379			include "forth_words_maths.asm" 
3379			 
3379			; | ## Maths Words 
3379			 
3379			.PLUS:	 
3379				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3379 15				db WORD_SYS_CORE+1             
337a bb 33			dw .NEG            
337c 02				db 1 + 1 
337d .. 00			db "+",0              
337f				endm 
# End of macro CWHEAD
337f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
337f					if DEBUG_FORTH_WORDS_KEY 
337f						DMARK "PLU" 
337f f5				push af  
3380 3a 94 33			ld a, (.dmark)  
3383 32 7a ee			ld (debug_mark),a  
3386 3a 95 33			ld a, (.dmark+1)  
3389 32 7b ee			ld (debug_mark+1),a  
338c 3a 96 33			ld a, (.dmark+2)  
338f 32 7c ee			ld (debug_mark+2),a  
3392 18 03			jr .pastdmark  
3394 ..			.dmark: db "PLU"  
3397 f1			.pastdmark: pop af  
3398			endm  
# End of macro DMARK
3398						CALLMONITOR 
3398 cd 39 14			call break_point_state  
339b				endm  
# End of macro CALLMONITOR
339b					endif 
339b					; add top two values and push back result 
339b			 
339b					;for v5 FORTH_DSP_VALUE 
339b					FORTH_DSP 
339b cd 83 1b			call macro_forth_dsp 
339e				endm 
# End of macro FORTH_DSP
339e 7e					ld a,(hl)	; get type of value on TOS 
339f fe 02				cp DS_TYPE_INUM  
33a1 28 03				jr z, .dot_inum 
33a3			 
33a3					NEXTW 
33a3 c3 2f 1d			jp macro_next 
33a6				endm 
# End of macro NEXTW
33a6			 
33a6			; float maths 
33a6			 
33a6				if FORTH_ENABLE_FLOATMATH 
33a6						inc hl      ; now at start of numeric as string 
33a6			 
33a6					if DEBUG_FORTH_MATHS 
33a6						DMARK "ADD" 
33a6				CALLMONITOR 
33a6					endif 
33a6			 
33a6					;ld ix, hl 
33a6					call CON 
33a6			 
33a6			 
33a6					push hl 
33a6					 
33a6					 
33a6			 
33a6						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
33a6			 
33a6					; get next number 
33a6			 
33a6						FORTH_DSP_VALUE 
33a6			 
33a6						inc hl      ; now at start of numeric as string 
33a6			 
33a6					;ld ix, hl 
33a6					call CON 
33a6			 
33a6					push hl 
33a6			 
33a6			 
33a6						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33a6			 
33a6						; TODO do add 
33a6			 
33a6						call IADD 
33a6			 
33a6						; TODO get result back as ascii 
33a6			 
33a6						; TODO push result  
33a6			 
33a6			 
33a6			 
33a6						jr .dot_done 
33a6				endif 
33a6			 
33a6			.dot_inum: 
33a6			 
33a6			 
33a6					if DEBUG_FORTH_DOT 
33a6						DMARK "+IT" 
33a6				CALLMONITOR 
33a6					endif 
33a6			 
33a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33a6 cd bd 1b			call macro_dsp_valuehl 
33a9				endm 
# End of macro FORTH_DSP_VALUEHL
33a9			 
33a9				; TODO add floating point number detection 
33a9			 
33a9 e5					push hl 
33aa			 
33aa					; destroy value TOS 
33aa			 
33aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33aa cd 75 1c			call macro_forth_dsp_pop 
33ad				endm 
# End of macro FORTH_DSP_POP
33ad			 
33ad			 
33ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ad cd bd 1b			call macro_dsp_valuehl 
33b0				endm 
# End of macro FORTH_DSP_VALUEHL
33b0			 
33b0					; one value on hl get other one back 
33b0			 
33b0 d1					pop de 
33b1			 
33b1					; do the add 
33b1			 
33b1 19					add hl,de 
33b2			 
33b2					; save it 
33b2			 
33b2			;		push hl	 
33b2			 
33b2					; 
33b2			 
33b2					; destroy value TOS 
33b2			 
33b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33b2 cd 75 1c			call macro_forth_dsp_pop 
33b5				endm 
# End of macro FORTH_DSP_POP
33b5			 
33b5					; TODO push value back onto stack for another op etc 
33b5			 
33b5			;		pop hl 
33b5			 
33b5			.dot_done: 
33b5 cd c6 19				call forth_push_numhl 
33b8			 
33b8					NEXTW 
33b8 c3 2f 1d			jp macro_next 
33bb				endm 
# End of macro NEXTW
33bb			.NEG: 
33bb			 
33bb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
33bb 17				db WORD_SYS_CORE+3             
33bc fe 33			dw .DIV            
33be 02				db 1 + 1 
33bf .. 00			db "-",0              
33c1				endm 
# End of macro CWHEAD
33c1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
33c1					if DEBUG_FORTH_WORDS_KEY 
33c1						DMARK "SUB" 
33c1 f5				push af  
33c2 3a d6 33			ld a, (.dmark)  
33c5 32 7a ee			ld (debug_mark),a  
33c8 3a d7 33			ld a, (.dmark+1)  
33cb 32 7b ee			ld (debug_mark+1),a  
33ce 3a d8 33			ld a, (.dmark+2)  
33d1 32 7c ee			ld (debug_mark+2),a  
33d4 18 03			jr .pastdmark  
33d6 ..			.dmark: db "SUB"  
33d9 f1			.pastdmark: pop af  
33da			endm  
# End of macro DMARK
33da						CALLMONITOR 
33da cd 39 14			call break_point_state  
33dd				endm  
# End of macro CALLMONITOR
33dd					endif 
33dd			 
33dd			 
33dd				; TODO add floating point number detection 
33dd					; v5 FORTH_DSP_VALUE 
33dd					FORTH_DSP 
33dd cd 83 1b			call macro_forth_dsp 
33e0				endm 
# End of macro FORTH_DSP
33e0 7e					ld a,(hl)	; get type of value on TOS 
33e1 fe 02				cp DS_TYPE_INUM  
33e3 28 03				jr z, .neg_inum 
33e5			 
33e5					NEXTW 
33e5 c3 2f 1d			jp macro_next 
33e8				endm 
# End of macro NEXTW
33e8			 
33e8			; float maths 
33e8			 
33e8				if FORTH_ENABLE_FLOATMATH 
33e8					jr .neg_done 
33e8			 
33e8				endif 
33e8					 
33e8			 
33e8			.neg_inum: 
33e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33e8 cd bd 1b			call macro_dsp_valuehl 
33eb				endm 
# End of macro FORTH_DSP_VALUEHL
33eb			 
33eb e5					push hl 
33ec			 
33ec					; destroy value TOS 
33ec			 
33ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33ec cd 75 1c			call macro_forth_dsp_pop 
33ef				endm 
# End of macro FORTH_DSP_POP
33ef			 
33ef			 
33ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33ef cd bd 1b			call macro_dsp_valuehl 
33f2				endm 
# End of macro FORTH_DSP_VALUEHL
33f2			 
33f2					; one value on hl get other one back 
33f2			 
33f2 d1					pop de 
33f3			 
33f3					; do the sub 
33f3			;		ex de, hl 
33f3			 
33f3 ed 52				sbc hl,de 
33f5			 
33f5					; save it 
33f5			 
33f5			;		push hl	 
33f5			 
33f5					; 
33f5			 
33f5					; destroy value TOS 
33f5			 
33f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f5 cd 75 1c			call macro_forth_dsp_pop 
33f8				endm 
# End of macro FORTH_DSP_POP
33f8			 
33f8					; TODO push value back onto stack for another op etc 
33f8			 
33f8			;		pop hl 
33f8			 
33f8 cd c6 19				call forth_push_numhl 
33fb			.neg_done: 
33fb			 
33fb					NEXTW 
33fb c3 2f 1d			jp macro_next 
33fe				endm 
# End of macro NEXTW
33fe			.DIV: 
33fe				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
33fe 18				db WORD_SYS_CORE+4             
33ff 4b 34			dw .MUL            
3401 02				db 1 + 1 
3402 .. 00			db "/",0              
3404				endm 
# End of macro CWHEAD
3404			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3404					if DEBUG_FORTH_WORDS_KEY 
3404						DMARK "DIV" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 7a ee			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 7b ee			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 7c ee			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "DIV"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d						CALLMONITOR 
341d cd 39 14			call break_point_state  
3420				endm  
# End of macro CALLMONITOR
3420					endif 
3420				; TODO add floating point number detection 
3420					; v5 FORTH_DSP_VALUE 
3420					FORTH_DSP 
3420 cd 83 1b			call macro_forth_dsp 
3423				endm 
# End of macro FORTH_DSP
3423 7e					ld a,(hl)	; get type of value on TOS 
3424 fe 02				cp DS_TYPE_INUM  
3426 28 03				jr z, .div_inum 
3428			 
3428				if FORTH_ENABLE_FLOATMATH 
3428					jr .div_done 
3428			 
3428				endif 
3428					NEXTW 
3428 c3 2f 1d			jp macro_next 
342b				endm 
# End of macro NEXTW
342b			.div_inum: 
342b			 
342b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
342b cd bd 1b			call macro_dsp_valuehl 
342e				endm 
# End of macro FORTH_DSP_VALUEHL
342e			 
342e e5					push hl    ; to go to bc 
342f			 
342f					; destroy value TOS 
342f			 
342f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
342f cd 75 1c			call macro_forth_dsp_pop 
3432				endm 
# End of macro FORTH_DSP_POP
3432			 
3432			 
3432					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3432 cd bd 1b			call macro_dsp_valuehl 
3435				endm 
# End of macro FORTH_DSP_VALUEHL
3435			 
3435					; hl to go to de 
3435			 
3435 e5					push hl 
3436			 
3436 c1					pop bc 
3437 d1					pop de		 
3438			 
3438			 
3438					if DEBUG_FORTH_MATHS 
3438						DMARK "DIV" 
3438				CALLMONITOR 
3438					endif 
3438					; one value on hl but move to a get other one back 
3438			 
3438			        
3438 cd 23 0b			call Div16 
343b			 
343b			;	push af	 
343b e5				push hl 
343c c5				push bc 
343d			 
343d					if DEBUG_FORTH_MATHS 
343d						DMARK "DI1" 
343d				CALLMONITOR 
343d					endif 
343d			 
343d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
343d cd 75 1c			call macro_forth_dsp_pop 
3440				endm 
# End of macro FORTH_DSP_POP
3440			 
3440			 
3440			 
3440 e1					pop hl    ; result 
3441			 
3441 cd c6 19				call forth_push_numhl 
3444			 
3444 e1					pop hl    ; reminder 
3445			;		ld h,0 
3445			;		ld l,d 
3445			 
3445 cd c6 19				call forth_push_numhl 
3448			.div_done: 
3448					NEXTW 
3448 c3 2f 1d			jp macro_next 
344b				endm 
# End of macro NEXTW
344b			.MUL: 
344b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
344b 19				db WORD_SYS_CORE+5             
344c 90 34			dw .MIN            
344e 02				db 1 + 1 
344f .. 00			db "*",0              
3451				endm 
# End of macro CWHEAD
3451			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3451				; TODO add floating point number detection 
3451					if DEBUG_FORTH_WORDS_KEY 
3451						DMARK "MUL" 
3451 f5				push af  
3452 3a 66 34			ld a, (.dmark)  
3455 32 7a ee			ld (debug_mark),a  
3458 3a 67 34			ld a, (.dmark+1)  
345b 32 7b ee			ld (debug_mark+1),a  
345e 3a 68 34			ld a, (.dmark+2)  
3461 32 7c ee			ld (debug_mark+2),a  
3464 18 03			jr .pastdmark  
3466 ..			.dmark: db "MUL"  
3469 f1			.pastdmark: pop af  
346a			endm  
# End of macro DMARK
346a						CALLMONITOR 
346a cd 39 14			call break_point_state  
346d				endm  
# End of macro CALLMONITOR
346d					endif 
346d					FORTH_DSP 
346d cd 83 1b			call macro_forth_dsp 
3470				endm 
# End of macro FORTH_DSP
3470					; v5 FORTH_DSP_VALUE 
3470 7e					ld a,(hl)	; get type of value on TOS 
3471 fe 02				cp DS_TYPE_INUM  
3473 28 03				jr z, .mul_inum 
3475			 
3475				if FORTH_ENABLE_FLOATMATH 
3475					jr .mul_done 
3475			 
3475				endif 
3475			 
3475					NEXTW 
3475 c3 2f 1d			jp macro_next 
3478				endm 
# End of macro NEXTW
3478			.mul_inum:	 
3478			 
3478					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3478 cd bd 1b			call macro_dsp_valuehl 
347b				endm 
# End of macro FORTH_DSP_VALUEHL
347b			 
347b e5					push hl 
347c			 
347c					; destroy value TOS 
347c			 
347c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
347c cd 75 1c			call macro_forth_dsp_pop 
347f				endm 
# End of macro FORTH_DSP_POP
347f			 
347f			 
347f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
347f cd bd 1b			call macro_dsp_valuehl 
3482				endm 
# End of macro FORTH_DSP_VALUEHL
3482			 
3482					; one value on hl but move to a get other one back 
3482			 
3482 7d					ld a, l 
3483			 
3483 d1					pop de 
3484			 
3484					; do the mull 
3484			;		ex de, hl 
3484			 
3484 cd 49 0b				call Mult16 
3487					; save it 
3487			 
3487			;		push hl	 
3487			 
3487					; 
3487			 
3487					; destroy value TOS 
3487			 
3487					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3487 cd 75 1c			call macro_forth_dsp_pop 
348a				endm 
# End of macro FORTH_DSP_POP
348a			 
348a					; TODO push value back onto stack for another op etc 
348a			 
348a			;		pop hl 
348a			 
348a cd c6 19				call forth_push_numhl 
348d			 
348d			.mul_done: 
348d					NEXTW 
348d c3 2f 1d			jp macro_next 
3490				endm 
# End of macro NEXTW
3490			 
3490			 
3490			 
3490			 
3490			.MIN: 
3490				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3490 49				db WORD_SYS_CORE+53             
3491 11 35			dw .MAX            
3493 04				db 3 + 1 
3494 .. 00			db "MIN",0              
3498				endm 
# End of macro CWHEAD
3498			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3498					if DEBUG_FORTH_WORDS_KEY 
3498						DMARK "MIN" 
3498 f5				push af  
3499 3a ad 34			ld a, (.dmark)  
349c 32 7a ee			ld (debug_mark),a  
349f 3a ae 34			ld a, (.dmark+1)  
34a2 32 7b ee			ld (debug_mark+1),a  
34a5 3a af 34			ld a, (.dmark+2)  
34a8 32 7c ee			ld (debug_mark+2),a  
34ab 18 03			jr .pastdmark  
34ad ..			.dmark: db "MIN"  
34b0 f1			.pastdmark: pop af  
34b1			endm  
# End of macro DMARK
34b1						CALLMONITOR 
34b1 cd 39 14			call break_point_state  
34b4				endm  
# End of macro CALLMONITOR
34b4					endif 
34b4					; get u2 
34b4			 
34b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34b4 cd bd 1b			call macro_dsp_valuehl 
34b7				endm 
# End of macro FORTH_DSP_VALUEHL
34b7			 
34b7 e5					push hl   ; u2 
34b8			 
34b8					; destroy value TOS 
34b8			 
34b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34b8 cd 75 1c			call macro_forth_dsp_pop 
34bb				endm 
# End of macro FORTH_DSP_POP
34bb			 
34bb					; get u1 
34bb			 
34bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34bb cd bd 1b			call macro_dsp_valuehl 
34be				endm 
# End of macro FORTH_DSP_VALUEHL
34be			 
34be e5					push hl  ; u1 
34bf			 
34bf					; destroy value TOS 
34bf			 
34bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34bf cd 75 1c			call macro_forth_dsp_pop 
34c2				endm 
# End of macro FORTH_DSP_POP
34c2			 
34c2 b7			 or a      ;clear carry flag 
34c3 e1			  pop hl    ; u1 
34c4 d1			  pop de    ; u2 
34c5 e5				push hl   ; saved in case hl is lowest 
34c6 ed 52		  sbc hl,de 
34c8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
34ca			 
34ca e1				pop hl 
34cb					if DEBUG_FORTH_WORDS 
34cb						DMARK "MIN" 
34cb f5				push af  
34cc 3a e0 34			ld a, (.dmark)  
34cf 32 7a ee			ld (debug_mark),a  
34d2 3a e1 34			ld a, (.dmark+1)  
34d5 32 7b ee			ld (debug_mark+1),a  
34d8 3a e2 34			ld a, (.dmark+2)  
34db 32 7c ee			ld (debug_mark+2),a  
34de 18 03			jr .pastdmark  
34e0 ..			.dmark: db "MIN"  
34e3 f1			.pastdmark: pop af  
34e4			endm  
# End of macro DMARK
34e4						CALLMONITOR 
34e4 cd 39 14			call break_point_state  
34e7				endm  
# End of macro CALLMONITOR
34e7					endif 
34e7 cd c6 19				call forth_push_numhl 
34ea			 
34ea				       NEXTW 
34ea c3 2f 1d			jp macro_next 
34ed				endm 
# End of macro NEXTW
34ed			 
34ed			.mincont:  
34ed c1				pop bc   ; tidy up 
34ee eb				ex de , hl  
34ef					if DEBUG_FORTH_WORDS 
34ef						DMARK "MI1" 
34ef f5				push af  
34f0 3a 04 35			ld a, (.dmark)  
34f3 32 7a ee			ld (debug_mark),a  
34f6 3a 05 35			ld a, (.dmark+1)  
34f9 32 7b ee			ld (debug_mark+1),a  
34fc 3a 06 35			ld a, (.dmark+2)  
34ff 32 7c ee			ld (debug_mark+2),a  
3502 18 03			jr .pastdmark  
3504 ..			.dmark: db "MI1"  
3507 f1			.pastdmark: pop af  
3508			endm  
# End of macro DMARK
3508						CALLMONITOR 
3508 cd 39 14			call break_point_state  
350b				endm  
# End of macro CALLMONITOR
350b					endif 
350b cd c6 19				call forth_push_numhl 
350e			 
350e				       NEXTW 
350e c3 2f 1d			jp macro_next 
3511				endm 
# End of macro NEXTW
3511			.MAX: 
3511				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3511 4a				db WORD_SYS_CORE+54             
3512 92 35			dw .RND16            
3514 04				db 3 + 1 
3515 .. 00			db "MAX",0              
3519				endm 
# End of macro CWHEAD
3519			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3519					if DEBUG_FORTH_WORDS_KEY 
3519						DMARK "MAX" 
3519 f5				push af  
351a 3a 2e 35			ld a, (.dmark)  
351d 32 7a ee			ld (debug_mark),a  
3520 3a 2f 35			ld a, (.dmark+1)  
3523 32 7b ee			ld (debug_mark+1),a  
3526 3a 30 35			ld a, (.dmark+2)  
3529 32 7c ee			ld (debug_mark+2),a  
352c 18 03			jr .pastdmark  
352e ..			.dmark: db "MAX"  
3531 f1			.pastdmark: pop af  
3532			endm  
# End of macro DMARK
3532						CALLMONITOR 
3532 cd 39 14			call break_point_state  
3535				endm  
# End of macro CALLMONITOR
3535					endif 
3535					; get u2 
3535			 
3535					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3535 cd bd 1b			call macro_dsp_valuehl 
3538				endm 
# End of macro FORTH_DSP_VALUEHL
3538			 
3538 e5					push hl   ; u2 
3539			 
3539					; destroy value TOS 
3539			 
3539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3539 cd 75 1c			call macro_forth_dsp_pop 
353c				endm 
# End of macro FORTH_DSP_POP
353c			 
353c					; get u1 
353c			 
353c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
353c cd bd 1b			call macro_dsp_valuehl 
353f				endm 
# End of macro FORTH_DSP_VALUEHL
353f			 
353f e5					push hl  ; u1 
3540			 
3540					; destroy value TOS 
3540			 
3540					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3540 cd 75 1c			call macro_forth_dsp_pop 
3543				endm 
# End of macro FORTH_DSP_POP
3543			 
3543 b7			 or a      ;clear carry flag 
3544 e1			  pop hl    ; u1 
3545 d1			  pop de    ; u2 
3546 e5				push hl   ; saved in case hl is lowest 
3547 ed 52		  sbc hl,de 
3549 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
354b			 
354b e1				pop hl 
354c					if DEBUG_FORTH_WORDS 
354c						DMARK "MAX" 
354c f5				push af  
354d 3a 61 35			ld a, (.dmark)  
3550 32 7a ee			ld (debug_mark),a  
3553 3a 62 35			ld a, (.dmark+1)  
3556 32 7b ee			ld (debug_mark+1),a  
3559 3a 63 35			ld a, (.dmark+2)  
355c 32 7c ee			ld (debug_mark+2),a  
355f 18 03			jr .pastdmark  
3561 ..			.dmark: db "MAX"  
3564 f1			.pastdmark: pop af  
3565			endm  
# End of macro DMARK
3565						CALLMONITOR 
3565 cd 39 14			call break_point_state  
3568				endm  
# End of macro CALLMONITOR
3568					endif 
3568 cd c6 19				call forth_push_numhl 
356b			 
356b				       NEXTW 
356b c3 2f 1d			jp macro_next 
356e				endm 
# End of macro NEXTW
356e			 
356e			.maxcont:  
356e c1				pop bc   ; tidy up 
356f eb				ex de , hl  
3570					if DEBUG_FORTH_WORDS 
3570						DMARK "MA1" 
3570 f5				push af  
3571 3a 85 35			ld a, (.dmark)  
3574 32 7a ee			ld (debug_mark),a  
3577 3a 86 35			ld a, (.dmark+1)  
357a 32 7b ee			ld (debug_mark+1),a  
357d 3a 87 35			ld a, (.dmark+2)  
3580 32 7c ee			ld (debug_mark+2),a  
3583 18 03			jr .pastdmark  
3585 ..			.dmark: db "MA1"  
3588 f1			.pastdmark: pop af  
3589			endm  
# End of macro DMARK
3589						CALLMONITOR 
3589 cd 39 14			call break_point_state  
358c				endm  
# End of macro CALLMONITOR
358c					endif 
358c cd c6 19				call forth_push_numhl 
358f				       NEXTW 
358f c3 2f 1d			jp macro_next 
3592				endm 
# End of macro NEXTW
3592			 
3592			.RND16: 
3592				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3592 4e				db WORD_SYS_CORE+58             
3593 c1 35			dw .RND8            
3595 06				db 5 + 1 
3596 .. 00			db "RND16",0              
359c				endm 
# End of macro CWHEAD
359c			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
359c					if DEBUG_FORTH_WORDS_KEY 
359c						DMARK "R16" 
359c f5				push af  
359d 3a b1 35			ld a, (.dmark)  
35a0 32 7a ee			ld (debug_mark),a  
35a3 3a b2 35			ld a, (.dmark+1)  
35a6 32 7b ee			ld (debug_mark+1),a  
35a9 3a b3 35			ld a, (.dmark+2)  
35ac 32 7c ee			ld (debug_mark+2),a  
35af 18 03			jr .pastdmark  
35b1 ..			.dmark: db "R16"  
35b4 f1			.pastdmark: pop af  
35b5			endm  
# End of macro DMARK
35b5						CALLMONITOR 
35b5 cd 39 14			call break_point_state  
35b8				endm  
# End of macro CALLMONITOR
35b8					endif 
35b8 cd ed 0a				call prng16  
35bb cd c6 19				call forth_push_numhl 
35be				       NEXTW 
35be c3 2f 1d			jp macro_next 
35c1				endm 
# End of macro NEXTW
35c1			.RND8: 
35c1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
35c1 60				db WORD_SYS_CORE+76             
35c2 f6 35			dw .RND            
35c4 05				db 4 + 1 
35c5 .. 00			db "RND8",0              
35ca				endm 
# End of macro CWHEAD
35ca			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
35ca					if DEBUG_FORTH_WORDS_KEY 
35ca						DMARK "RN8" 
35ca f5				push af  
35cb 3a df 35			ld a, (.dmark)  
35ce 32 7a ee			ld (debug_mark),a  
35d1 3a e0 35			ld a, (.dmark+1)  
35d4 32 7b ee			ld (debug_mark+1),a  
35d7 3a e1 35			ld a, (.dmark+2)  
35da 32 7c ee			ld (debug_mark+2),a  
35dd 18 03			jr .pastdmark  
35df ..			.dmark: db "RN8"  
35e2 f1			.pastdmark: pop af  
35e3			endm  
# End of macro DMARK
35e3						CALLMONITOR 
35e3 cd 39 14			call break_point_state  
35e6				endm  
# End of macro CALLMONITOR
35e6					endif 
35e6 2a bb eb				ld hl,(xrandc) 
35e9 23					inc hl 
35ea cd 07 0b				call xrnd 
35ed 6f					ld l,a	 
35ee 26 00				ld h,0 
35f0 cd c6 19				call forth_push_numhl 
35f3				       NEXTW 
35f3 c3 2f 1d			jp macro_next 
35f6				endm 
# End of macro NEXTW
35f6			.RND: 
35f6				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
35f6 60				db WORD_SYS_CORE+76             
35f7 fc 36			dw .ENDMATHS            
35f9 04				db 3 + 1 
35fa .. 00			db "RND",0              
35fe				endm 
# End of macro CWHEAD
35fe			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
35fe			 
35fe					if DEBUG_FORTH_WORDS_KEY 
35fe						DMARK "RND" 
35fe f5				push af  
35ff 3a 13 36			ld a, (.dmark)  
3602 32 7a ee			ld (debug_mark),a  
3605 3a 14 36			ld a, (.dmark+1)  
3608 32 7b ee			ld (debug_mark+1),a  
360b 3a 15 36			ld a, (.dmark+2)  
360e 32 7c ee			ld (debug_mark+2),a  
3611 18 03			jr .pastdmark  
3613 ..			.dmark: db "RND"  
3616 f1			.pastdmark: pop af  
3617			endm  
# End of macro DMARK
3617						CALLMONITOR 
3617 cd 39 14			call break_point_state  
361a				endm  
# End of macro CALLMONITOR
361a					endif 
361a					 
361a					FORTH_DSP_VALUEHL    ; upper range 
361a cd bd 1b			call macro_dsp_valuehl 
361d				endm 
# End of macro FORTH_DSP_VALUEHL
361d			 
361d 22 bf eb				ld (LFSRSeed), hl	 
3620			 
3620					if DEBUG_FORTH_WORDS 
3620						DMARK "RN1" 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 7a ee			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 7b ee			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 7c ee			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "RN1"  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639						CALLMONITOR 
3639 cd 39 14			call break_point_state  
363c				endm  
# End of macro CALLMONITOR
363c					endif 
363c					FORTH_DSP_POP 
363c cd 75 1c			call macro_forth_dsp_pop 
363f				endm 
# End of macro FORTH_DSP_POP
363f			 
363f					FORTH_DSP_VALUEHL    ; low range 
363f cd bd 1b			call macro_dsp_valuehl 
3642				endm 
# End of macro FORTH_DSP_VALUEHL
3642			 
3642					if DEBUG_FORTH_WORDS 
3642						DMARK "RN2" 
3642 f5				push af  
3643 3a 57 36			ld a, (.dmark)  
3646 32 7a ee			ld (debug_mark),a  
3649 3a 58 36			ld a, (.dmark+1)  
364c 32 7b ee			ld (debug_mark+1),a  
364f 3a 59 36			ld a, (.dmark+2)  
3652 32 7c ee			ld (debug_mark+2),a  
3655 18 03			jr .pastdmark  
3657 ..			.dmark: db "RN2"  
365a f1			.pastdmark: pop af  
365b			endm  
# End of macro DMARK
365b						CALLMONITOR 
365b cd 39 14			call break_point_state  
365e				endm  
# End of macro CALLMONITOR
365e					endif 
365e 22 c1 eb				ld (LFSRSeed+2), hl 
3661			 
3661					FORTH_DSP_POP 
3661 cd 75 1c			call macro_forth_dsp_pop 
3664				endm 
# End of macro FORTH_DSP_POP
3664			 
3664 e5					push hl 
3665			 
3665 e1			.inrange:	pop hl 
3666 cd ed 0a				call prng16  
3669					if DEBUG_FORTH_WORDS 
3669						DMARK "RN3" 
3669 f5				push af  
366a 3a 7e 36			ld a, (.dmark)  
366d 32 7a ee			ld (debug_mark),a  
3670 3a 7f 36			ld a, (.dmark+1)  
3673 32 7b ee			ld (debug_mark+1),a  
3676 3a 80 36			ld a, (.dmark+2)  
3679 32 7c ee			ld (debug_mark+2),a  
367c 18 03			jr .pastdmark  
367e ..			.dmark: db "RN3"  
3681 f1			.pastdmark: pop af  
3682			endm  
# End of macro DMARK
3682						CALLMONITOR 
3682 cd 39 14			call break_point_state  
3685				endm  
# End of macro CALLMONITOR
3685					endif 
3685					 
3685					; if the range is 8bit knock out the high byte 
3685			 
3685 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
3689			 
3689 3e 00				ld a, 0 
368b ba					cp d  
368c 20 1e				jr nz, .hirange 
368e 26 00				ld h, 0   ; knock it down to 8bit 
3690			 
3690					if DEBUG_FORTH_WORDS 
3690						DMARK "RNk" 
3690 f5				push af  
3691 3a a5 36			ld a, (.dmark)  
3694 32 7a ee			ld (debug_mark),a  
3697 3a a6 36			ld a, (.dmark+1)  
369a 32 7b ee			ld (debug_mark+1),a  
369d 3a a7 36			ld a, (.dmark+2)  
36a0 32 7c ee			ld (debug_mark+2),a  
36a3 18 03			jr .pastdmark  
36a5 ..			.dmark: db "RNk"  
36a8 f1			.pastdmark: pop af  
36a9			endm  
# End of macro DMARK
36a9						CALLMONITOR 
36a9 cd 39 14			call break_point_state  
36ac				endm  
# End of macro CALLMONITOR
36ac					endif 
36ac			.hirange:   
36ac e5					push hl  
36ad b7					or a  
36ae ed 52		                sbc hl, de 
36b0			 
36b0					;call cmp16 
36b0			 
36b0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
36b2 e1					pop hl 
36b3 e5					push hl 
36b4			 
36b4					if DEBUG_FORTH_WORDS 
36b4						DMARK "RN4" 
36b4 f5				push af  
36b5 3a c9 36			ld a, (.dmark)  
36b8 32 7a ee			ld (debug_mark),a  
36bb 3a ca 36			ld a, (.dmark+1)  
36be 32 7b ee			ld (debug_mark+1),a  
36c1 3a cb 36			ld a, (.dmark+2)  
36c4 32 7c ee			ld (debug_mark+2),a  
36c7 18 03			jr .pastdmark  
36c9 ..			.dmark: db "RN4"  
36cc f1			.pastdmark: pop af  
36cd			endm  
# End of macro DMARK
36cd						CALLMONITOR 
36cd cd 39 14			call break_point_state  
36d0				endm  
# End of macro CALLMONITOR
36d0					endif 
36d0 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
36d4					;call cmp16 
36d4				 
36d4 b7					or a  
36d5 ed 52		                sbc hl, de 
36d7 38 8c				jr c, .inrange 
36d9			 
36d9 e1					pop hl 
36da					 
36da					if DEBUG_FORTH_WORDS 
36da						DMARK "RNd" 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 7a ee			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 7b ee			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 7c ee			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "RNd"  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3						CALLMONITOR 
36f3 cd 39 14			call break_point_state  
36f6				endm  
# End of macro CALLMONITOR
36f6					endif 
36f6			 
36f6			 
36f6 cd c6 19				call forth_push_numhl 
36f9				       NEXTW 
36f9 c3 2f 1d			jp macro_next 
36fc				endm 
# End of macro NEXTW
36fc			 
36fc			.ENDMATHS: 
36fc			 
36fc			; eof 
36fc			 
# End of file forth_words_maths.asm
36fc			include "forth_words_display.asm" 
36fc			 
36fc			; | ## Display Words 
36fc			 
36fc			.ATP: 
36fc				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
36fc 62				db WORD_SYS_CORE+78             
36fd 73 37			dw .FB            
36ff 04				db 3 + 1 
3700 .. 00			db "AT?",0              
3704				endm 
# End of macro CWHEAD
3704			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3704					if DEBUG_FORTH_WORDS_KEY 
3704						DMARK "AT?" 
3704 f5				push af  
3705 3a 19 37			ld a, (.dmark)  
3708 32 7a ee			ld (debug_mark),a  
370b 3a 1a 37			ld a, (.dmark+1)  
370e 32 7b ee			ld (debug_mark+1),a  
3711 3a 1b 37			ld a, (.dmark+2)  
3714 32 7c ee			ld (debug_mark+2),a  
3717 18 03			jr .pastdmark  
3719 ..			.dmark: db "AT?"  
371c f1			.pastdmark: pop af  
371d			endm  
# End of macro DMARK
371d						CALLMONITOR 
371d cd 39 14			call break_point_state  
3720				endm  
# End of macro CALLMONITOR
3720					endif 
3720 3a 49 eb				ld a, (f_cursor_ptr) 
3723			 
3723			if DEBUG_FORTH_WORDS 
3723				DMARK "AT?" 
3723 f5				push af  
3724 3a 38 37			ld a, (.dmark)  
3727 32 7a ee			ld (debug_mark),a  
372a 3a 39 37			ld a, (.dmark+1)  
372d 32 7b ee			ld (debug_mark+1),a  
3730 3a 3a 37			ld a, (.dmark+2)  
3733 32 7c ee			ld (debug_mark+2),a  
3736 18 03			jr .pastdmark  
3738 ..			.dmark: db "AT?"  
373b f1			.pastdmark: pop af  
373c			endm  
# End of macro DMARK
373c				CALLMONITOR 
373c cd 39 14			call break_point_state  
373f				endm  
# End of macro CALLMONITOR
373f			endif	 
373f					; count the number of rows 
373f			 
373f 06 00				ld b, 0 
3741 4f			.atpr:		ld c, a    ; save in case we go below zero 
3742 d6 28				sub display_cols 
3744 f2 4a 37				jp p, .atprunder 
3747 04					inc b 
3748 18 f7				jr .atpr 
374a			.atprunder:	 
374a			if DEBUG_FORTH_WORDS 
374a				DMARK "A?2" 
374a f5				push af  
374b 3a 5f 37			ld a, (.dmark)  
374e 32 7a ee			ld (debug_mark),a  
3751 3a 60 37			ld a, (.dmark+1)  
3754 32 7b ee			ld (debug_mark+1),a  
3757 3a 61 37			ld a, (.dmark+2)  
375a 32 7c ee			ld (debug_mark+2),a  
375d 18 03			jr .pastdmark  
375f ..			.dmark: db "A?2"  
3762 f1			.pastdmark: pop af  
3763			endm  
# End of macro DMARK
3763				CALLMONITOR 
3763 cd 39 14			call break_point_state  
3766				endm  
# End of macro CALLMONITOR
3766			endif	 
3766 26 00				ld h, 0 
3768 69					ld l, c 
3769 cd c6 19				call forth_push_numhl 
376c 68					ld l, b  
376d cd c6 19				call forth_push_numhl 
3770			 
3770			 
3770				NEXTW 
3770 c3 2f 1d			jp macro_next 
3773				endm 
# End of macro NEXTW
3773			 
3773			.FB: 
3773				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3773 1b				db WORD_SYS_CORE+7             
3774 c1 37			dw .EMIT            
3776 03				db 2 + 1 
3777 .. 00			db "FB",0              
377a				endm 
# End of macro CWHEAD
377a			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
377a			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
377a			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
377a			; | | If automatic display is off then updates will not be shown until DRAW is used. 
377a					if DEBUG_FORTH_WORDS_KEY 
377a						DMARK "FB." 
377a f5				push af  
377b 3a 8f 37			ld a, (.dmark)  
377e 32 7a ee			ld (debug_mark),a  
3781 3a 90 37			ld a, (.dmark+1)  
3784 32 7b ee			ld (debug_mark+1),a  
3787 3a 91 37			ld a, (.dmark+2)  
378a 32 7c ee			ld (debug_mark+2),a  
378d 18 03			jr .pastdmark  
378f ..			.dmark: db "FB."  
3792 f1			.pastdmark: pop af  
3793			endm  
# End of macro DMARK
3793						CALLMONITOR 
3793 cd 39 14			call break_point_state  
3796				endm  
# End of macro CALLMONITOR
3796					endif 
3796			 
3796					FORTH_DSP_VALUEHL 
3796 cd bd 1b			call macro_dsp_valuehl 
3799				endm 
# End of macro FORTH_DSP_VALUEHL
3799			 
3799 7d					ld a, l 
379a fe 01				cp 1 
379c 20 05				jr nz, .fbn1 
379e 21 1f ed				ld hl, display_fb1 
37a1 18 15				jr .fbset 
37a3 fe 02		.fbn1:		cp 2 
37a5 20 05				jr nz, .fbn2 
37a7 21 dd eb				ld hl, display_fb2 
37aa 18 0c				jr .fbset 
37ac fe 03		.fbn2:		cp 3 
37ae 20 05				jr nz, .fbn3 
37b0 21 7e ec				ld hl, display_fb3 
37b3 18 03				jr .fbset 
37b5			.fbn3:		 ; if invalid number select first 
37b5 21 1f ed				ld hl, display_fb1 
37b8 22 db eb		.fbset:		ld (display_fb_active), hl 
37bb			 
37bb					FORTH_DSP_POP 
37bb cd 75 1c			call macro_forth_dsp_pop 
37be				endm 
# End of macro FORTH_DSP_POP
37be			 
37be					NEXTW 
37be c3 2f 1d			jp macro_next 
37c1				endm 
# End of macro NEXTW
37c1			 
37c1			 
37c1			.EMIT: 
37c1				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
37c1 1b				db WORD_SYS_CORE+7             
37c2 12 38			dw .DOTH            
37c4 05				db 4 + 1 
37c5 .. 00			db "EMIT",0              
37ca				endm 
# End of macro CWHEAD
37ca			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
37ca					; get value off TOS and display it 
37ca			 
37ca					if DEBUG_FORTH_WORDS_KEY 
37ca						DMARK "EMT" 
37ca f5				push af  
37cb 3a df 37			ld a, (.dmark)  
37ce 32 7a ee			ld (debug_mark),a  
37d1 3a e0 37			ld a, (.dmark+1)  
37d4 32 7b ee			ld (debug_mark+1),a  
37d7 3a e1 37			ld a, (.dmark+2)  
37da 32 7c ee			ld (debug_mark+2),a  
37dd 18 03			jr .pastdmark  
37df ..			.dmark: db "EMT"  
37e2 f1			.pastdmark: pop af  
37e3			endm  
# End of macro DMARK
37e3						CALLMONITOR 
37e3 cd 39 14			call break_point_state  
37e6				endm  
# End of macro CALLMONITOR
37e6					endif 
37e6			 
37e6					FORTH_DSP_VALUEHL 
37e6 cd bd 1b			call macro_dsp_valuehl 
37e9				endm 
# End of macro FORTH_DSP_VALUEHL
37e9			 
37e9 7d					ld a,l 
37ea			 
37ea					; TODO write to display 
37ea			 
37ea 32 5e e5				ld (os_input), a 
37ed 3e 00				ld a, 0 
37ef 32 5f e5				ld (os_input+1), a 
37f2					 
37f2 3a 49 eb				ld a, (f_cursor_ptr) 
37f5 11 5e e5				ld de, os_input 
37f8 cd ac 09				call str_at_display 
37fb			 
37fb			 
37fb 3a 27 eb				ld a,(cli_autodisplay) 
37fe fe 00				cp 0 
3800 28 03				jr z, .enoupdate 
3802 cd bc 09						call update_display 
3805					.enoupdate: 
3805			 
3805 3a 49 eb				ld a, (f_cursor_ptr) 
3808 3c					inc a 
3809 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
380c			 
380c			 
380c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380c cd 75 1c			call macro_forth_dsp_pop 
380f				endm 
# End of macro FORTH_DSP_POP
380f			  
380f			 
380f					NEXTW 
380f c3 2f 1d			jp macro_next 
3812				endm 
# End of macro NEXTW
3812			.DOTH: 
3812				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3812 1c				db WORD_SYS_CORE+8             
3813 42 38			dw .DOTF            
3815 03				db 2 + 1 
3816 .. 00			db ".-",0              
3819				endm 
# End of macro CWHEAD
3819			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3819					; get value off TOS and display it 
3819					if DEBUG_FORTH_WORDS_KEY 
3819						DMARK "DTD" 
3819 f5				push af  
381a 3a 2e 38			ld a, (.dmark)  
381d 32 7a ee			ld (debug_mark),a  
3820 3a 2f 38			ld a, (.dmark+1)  
3823 32 7b ee			ld (debug_mark+1),a  
3826 3a 30 38			ld a, (.dmark+2)  
3829 32 7c ee			ld (debug_mark+2),a  
382c 18 03			jr .pastdmark  
382e ..			.dmark: db "DTD"  
3831 f1			.pastdmark: pop af  
3832			endm  
# End of macro DMARK
3832						CALLMONITOR 
3832 cd 39 14			call break_point_state  
3835				endm  
# End of macro CALLMONITOR
3835					endif 
3835 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3837 3e 00			ld a, 0 
3839 32 28 eb			ld (cli_mvdot), a 
383c c3 99 38			jp .dotgo 
383f				NEXTW 
383f c3 2f 1d			jp macro_next 
3842				endm 
# End of macro NEXTW
3842			.DOTF: 
3842				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3842 1c				db WORD_SYS_CORE+8             
3843 70 38			dw .DOT            
3845 03				db 2 + 1 
3846 .. 00			db ".>",0              
3849				endm 
# End of macro CWHEAD
3849			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3849					; get value off TOS and display it 
3849			        ; TODO BUG adds extra spaces 
3849			        ; TODO BUG handle numerics? 
3849					if DEBUG_FORTH_WORDS_KEY 
3849						DMARK "DTC" 
3849 f5				push af  
384a 3a 5e 38			ld a, (.dmark)  
384d 32 7a ee			ld (debug_mark),a  
3850 3a 5f 38			ld a, (.dmark+1)  
3853 32 7b ee			ld (debug_mark+1),a  
3856 3a 60 38			ld a, (.dmark+2)  
3859 32 7c ee			ld (debug_mark+2),a  
385c 18 03			jr .pastdmark  
385e ..			.dmark: db "DTC"  
3861 f1			.pastdmark: pop af  
3862			endm  
# End of macro DMARK
3862						CALLMONITOR 
3862 cd 39 14			call break_point_state  
3865				endm  
# End of macro CALLMONITOR
3865					endif 
3865 3e 01			ld a, 1 
3867 32 28 eb			ld (cli_mvdot), a 
386a c3 99 38			jp .dotgo 
386d				NEXTW 
386d c3 2f 1d			jp macro_next 
3870				endm 
# End of macro NEXTW
3870			 
3870			.DOT: 
3870				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3870 1c				db WORD_SYS_CORE+8             
3871 fc 38			dw .CLS            
3873 02				db 1 + 1 
3874 .. 00			db ".",0              
3876				endm 
# End of macro CWHEAD
3876			        ; | . ( u -- ) Display TOS | DONE 
3876					; get value off TOS and display it 
3876			 
3876					if DEBUG_FORTH_WORDS_KEY 
3876						DMARK "DOT" 
3876 f5				push af  
3877 3a 8b 38			ld a, (.dmark)  
387a 32 7a ee			ld (debug_mark),a  
387d 3a 8c 38			ld a, (.dmark+1)  
3880 32 7b ee			ld (debug_mark+1),a  
3883 3a 8d 38			ld a, (.dmark+2)  
3886 32 7c ee			ld (debug_mark+2),a  
3889 18 03			jr .pastdmark  
388b ..			.dmark: db "DOT"  
388e f1			.pastdmark: pop af  
388f			endm  
# End of macro DMARK
388f						CALLMONITOR 
388f cd 39 14			call break_point_state  
3892				endm  
# End of macro CALLMONITOR
3892					endif 
3892 3e 00			ld a, 0 
3894 32 28 eb			ld (cli_mvdot), a 
3897 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3899				 
3899			 
3899			.dotgo: 
3899			 
3899			; move up type to on stack for parserv5 
3899					FORTH_DSP 
3899 cd 83 1b			call macro_forth_dsp 
389c				endm 
# End of macro FORTH_DSP
389c				;FORTH_DSP_VALUE  
389c			 
389c			if DEBUG_FORTH_DOT 
389c				DMARK "DOT" 
389c				CALLMONITOR 
389c			endif	 
389c			;		.print: 
389c			 
389c 7e				ld a,(hl)  ; work out what type of value is on the TOS 
389d 23				inc hl   ; position to the actual value 
389e fe 01			cp DS_TYPE_STR 
38a0 20 06			jr nz, .dotnum1  
38a2			 
38a2			; display string 
38a2				FORTH_DSP_VALUE  
38a2 cd a6 1b			call macro_forth_dsp_value 
38a5				endm 
# End of macro FORTH_DSP_VALUE
38a5 eb				ex de,hl 
38a6 18 11			jr .dotwrite 
38a8			 
38a8			.dotnum1: 
38a8 fe 02			cp DS_TYPE_INUM 
38aa 20 0c			jr nz, .dotflot 
38ac			 
38ac			 
38ac			; display number 
38ac			 
38ac			;	push hl 
38ac			;	call clear_display 
38ac			;	pop hl 
38ac			 
38ac 5e				ld e, (hl) 
38ad 23				inc hl 
38ae 56				ld d, (hl) 
38af 21 60 e3			ld hl, scratch 
38b2			if DEBUG_FORTH_DOT 
38b2				DMARK "DT1" 
38b2				CALLMONITOR 
38b2			endif	 
38b2			 
38b2 cd d3 0f			call uitoa_16 
38b5 eb				ex de,hl 
38b6			 
38b6			if DEBUG_FORTH_DOT 
38b6				DMARK "DT2" 
38b6				CALLMONITOR 
38b6			endif	 
38b6			 
38b6			;	ld de, os_word_scratch 
38b6 18 01			jr .dotwrite 
38b8			 
38b8 00			.dotflot:   nop 
38b9			; TODO print floating point number 
38b9			 
38b9			.dotwrite:		 
38b9			 
38b9					; if c is set then set all '-' to spaces 
38b9					; need to also take into account .>  
38b9			 
38b9 3e 01				ld a, 1 
38bb b9					cp c 
38bc 20 13				jr nz, .nodashswap 
38be			 
38be					; DE has the string to write, working with HL 
38be			 
38be 06 ff				ld b, 255 
38c0 d5					push de 
38c1 e1					pop hl 
38c2			 
38c2			if DEBUG_FORTH_DOT 
38c2				DMARK "DT-" 
38c2				CALLMONITOR 
38c2			endif	 
38c2 7e			.dashscan:	ld a, (hl) 
38c3 fe 00				cp 0 
38c5 28 0a				jr z, .nodashswap 
38c7 fe 2d				cp '-' 
38c9 20 03				jr nz, .dashskip 
38cb 3e 20				ld a, ' ' 
38cd 77					ld (hl), a 
38ce 23			.dashskip:	inc hl 
38cf			if DEBUG_FORTH_DOT 
38cf				DMARK "D-2" 
38cf				CALLMONITOR 
38cf			endif	 
38cf 10 f1				djnz .dashscan 
38d1			 
38d1			if DEBUG_FORTH_DOT 
38d1				DMARK "D-1" 
38d1				CALLMONITOR 
38d1			endif	 
38d1			 
38d1			.nodashswap: 
38d1			 
38d1 e5					push hl   ; save string start in case we need to advance print 
38d2			 
38d2 3a 49 eb				ld a, (f_cursor_ptr) 
38d5 cd ac 09				call str_at_display 
38d8 3a 27 eb				ld a,(cli_autodisplay) 
38db fe 00				cp 0 
38dd 28 03				jr z, .noupdate 
38df cd bc 09						call update_display 
38e2					.noupdate: 
38e2			 
38e2			 
38e2					; see if we need to advance the print position 
38e2			 
38e2 e1					pop hl   ; get back string 
38e3			 
38e3 3a 28 eb				ld a, (cli_mvdot) 
38e6			if DEBUG_FORTH_DOT 
38e6					ld e,a 
38e6				DMARK "D>1" 
38e6				CALLMONITOR 
38e6			endif	 
38e6 fe 00				cp 0 
38e8 28 0c				jr z, .noadv 
38ea					; yes, lets advance the print position 
38ea 3e 00				ld a, 0 
38ec cd 2f 10				call strlent 
38ef 3a 49 eb				ld a, (f_cursor_ptr) 
38f2 85					add a,l 
38f3					;call addatohl 
38f3					;ld a, l 
38f3 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
38f6			 
38f6			if DEBUG_FORTH_DOT 
38f6				DMARK "D->" 
38f6				CALLMONITOR 
38f6			endif	 
38f6			 
38f6			.noadv:	 
38f6			 
38f6					if DEBUG_FORTH_DOT_WAIT 
38f6							call next_page_prompt 
38f6					endif	 
38f6			; TODO this pop off the stack causes a crash. i dont know why 
38f6			 
38f6			 
38f6			if DEBUG_FORTH_DOT 
38f6				DMARK "DTh" 
38f6				CALLMONITOR 
38f6			endif	 
38f6			 
38f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f6 cd 75 1c			call macro_forth_dsp_pop 
38f9				endm 
# End of macro FORTH_DSP_POP
38f9			 
38f9			if DEBUG_FORTH_DOT 
38f9				DMARK "DTi" 
38f9				CALLMONITOR 
38f9			endif	 
38f9			 
38f9			 
38f9					NEXTW 
38f9 c3 2f 1d			jp macro_next 
38fc				endm 
# End of macro NEXTW
38fc			 
38fc			.CLS: 
38fc				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
38fc 35				db WORD_SYS_CORE+33             
38fd 29 39			dw .DRAW            
38ff 04				db 3 + 1 
3900 .. 00			db "CLS",0              
3904				endm 
# End of macro CWHEAD
3904			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3904					if DEBUG_FORTH_WORDS_KEY 
3904						DMARK "CLS" 
3904 f5				push af  
3905 3a 19 39			ld a, (.dmark)  
3908 32 7a ee			ld (debug_mark),a  
390b 3a 1a 39			ld a, (.dmark+1)  
390e 32 7b ee			ld (debug_mark+1),a  
3911 3a 1b 39			ld a, (.dmark+2)  
3914 32 7c ee			ld (debug_mark+2),a  
3917 18 03			jr .pastdmark  
3919 ..			.dmark: db "CLS"  
391c f1			.pastdmark: pop af  
391d			endm  
# End of macro DMARK
391d						CALLMONITOR 
391d cd 39 14			call break_point_state  
3920				endm  
# End of macro CALLMONITOR
3920					endif 
3920 cd 99 09				call clear_display 
3923 c3 37 3a				jp .home		; and home cursor 
3926					NEXTW 
3926 c3 2f 1d			jp macro_next 
3929				endm 
# End of macro NEXTW
3929			 
3929			.DRAW: 
3929				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3929 36				db WORD_SYS_CORE+34             
392a 54 39			dw .DUMP            
392c 05				db 4 + 1 
392d .. 00			db "DRAW",0              
3932				endm 
# End of macro CWHEAD
3932			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3932					if DEBUG_FORTH_WORDS_KEY 
3932						DMARK "DRW" 
3932 f5				push af  
3933 3a 47 39			ld a, (.dmark)  
3936 32 7a ee			ld (debug_mark),a  
3939 3a 48 39			ld a, (.dmark+1)  
393c 32 7b ee			ld (debug_mark+1),a  
393f 3a 49 39			ld a, (.dmark+2)  
3942 32 7c ee			ld (debug_mark+2),a  
3945 18 03			jr .pastdmark  
3947 ..			.dmark: db "DRW"  
394a f1			.pastdmark: pop af  
394b			endm  
# End of macro DMARK
394b						CALLMONITOR 
394b cd 39 14			call break_point_state  
394e				endm  
# End of macro CALLMONITOR
394e					endif 
394e cd bc 09				call update_display 
3951					NEXTW 
3951 c3 2f 1d			jp macro_next 
3954				endm 
# End of macro NEXTW
3954			 
3954			.DUMP: 
3954				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3954 37				db WORD_SYS_CORE+35             
3955 8c 39			dw .CDUMP            
3957 05				db 4 + 1 
3958 .. 00			db "DUMP",0              
395d				endm 
# End of macro CWHEAD
395d			; | DUMP ( x -- ) With address x display dump   | DONE 
395d			; TODO pop address to use off of the stack 
395d					if DEBUG_FORTH_WORDS_KEY 
395d						DMARK "DUM" 
395d f5				push af  
395e 3a 72 39			ld a, (.dmark)  
3961 32 7a ee			ld (debug_mark),a  
3964 3a 73 39			ld a, (.dmark+1)  
3967 32 7b ee			ld (debug_mark+1),a  
396a 3a 74 39			ld a, (.dmark+2)  
396d 32 7c ee			ld (debug_mark+2),a  
3970 18 03			jr .pastdmark  
3972 ..			.dmark: db "DUM"  
3975 f1			.pastdmark: pop af  
3976			endm  
# End of macro DMARK
3976						CALLMONITOR 
3976 cd 39 14			call break_point_state  
3979				endm  
# End of macro CALLMONITOR
3979					endif 
3979 cd 99 09				call clear_display 
397c			 
397c					; get address 
397c			 
397c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
397c cd bd 1b			call macro_dsp_valuehl 
397f				endm 
# End of macro FORTH_DSP_VALUEHL
397f				 
397f					; save it for cdump 
397f			 
397f 22 83 e6				ld (os_cur_ptr),hl 
3982			 
3982					; destroy value TOS 
3982			 
3982					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3982 cd 75 1c			call macro_forth_dsp_pop 
3985				endm 
# End of macro FORTH_DSP_POP
3985			 
3985 cd 46 18				call dumpcont	; skip old style of param parsing	 
3988 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3989					NEXTW 
3989 c3 2f 1d			jp macro_next 
398c				endm 
# End of macro NEXTW
398c			.CDUMP: 
398c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
398c 38				db WORD_SYS_CORE+36             
398d bc 39			dw .DAT            
398f 06				db 5 + 1 
3990 .. 00			db "CDUMP",0              
3996				endm 
# End of macro CWHEAD
3996			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3996					if DEBUG_FORTH_WORDS_KEY 
3996						DMARK "CDP" 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 7a ee			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 7b ee			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 7c ee			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "CDP"  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af						CALLMONITOR 
39af cd 39 14			call break_point_state  
39b2				endm  
# End of macro CALLMONITOR
39b2					endif 
39b2 cd 99 09				call clear_display 
39b5 cd 46 18				call dumpcont	 
39b8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
39b9					NEXTW 
39b9 c3 2f 1d			jp macro_next 
39bc				endm 
# End of macro NEXTW
39bc			 
39bc			 
39bc			 
39bc			 
39bc			.DAT: 
39bc				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
39bc 3d				db WORD_SYS_CORE+41             
39bd 12 3a			dw .HOME            
39bf 03				db 2 + 1 
39c0 .. 00			db "AT",0              
39c3				endm 
# End of macro CWHEAD
39c3			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
39c3					if DEBUG_FORTH_WORDS_KEY 
39c3						DMARK "AT." 
39c3 f5				push af  
39c4 3a d8 39			ld a, (.dmark)  
39c7 32 7a ee			ld (debug_mark),a  
39ca 3a d9 39			ld a, (.dmark+1)  
39cd 32 7b ee			ld (debug_mark+1),a  
39d0 3a da 39			ld a, (.dmark+2)  
39d3 32 7c ee			ld (debug_mark+2),a  
39d6 18 03			jr .pastdmark  
39d8 ..			.dmark: db "AT."  
39db f1			.pastdmark: pop af  
39dc			endm  
# End of macro DMARK
39dc						CALLMONITOR 
39dc cd 39 14			call break_point_state  
39df				endm  
# End of macro CALLMONITOR
39df					endif 
39df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39df cd bd 1b			call macro_dsp_valuehl 
39e2				endm 
# End of macro FORTH_DSP_VALUEHL
39e2			 
39e2			 
39e2					; TODO save cursor row 
39e2 7d					ld a,l 
39e3 fe 02				cp 2 
39e5 20 04				jr nz, .crow3 
39e7 3e 28				ld a, display_row_2 
39e9 18 12				jr .ccol1 
39eb fe 03		.crow3:		cp 3 
39ed 20 04				jr nz, .crow4 
39ef 3e 50				ld a, display_row_3 
39f1 18 0a				jr .ccol1 
39f3 fe 04		.crow4:		cp 4 
39f5 20 04				jr nz, .crow1 
39f7 3e 78				ld a, display_row_4 
39f9 18 02				jr .ccol1 
39fb 3e 00		.crow1:		ld a,display_row_1 
39fd f5			.ccol1:		push af			; got row offset 
39fe 6f					ld l,a 
39ff 26 00				ld h,0 
3a01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a01 cd 75 1c			call macro_forth_dsp_pop 
3a04				endm 
# End of macro FORTH_DSP_POP
3a04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a04 cd bd 1b			call macro_dsp_valuehl 
3a07				endm 
# End of macro FORTH_DSP_VALUEHL
3a07					; TODO save cursor col 
3a07 f1					pop af 
3a08 85					add l		; add col offset 
3a09 32 49 eb				ld (f_cursor_ptr), a 
3a0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0c cd 75 1c			call macro_forth_dsp_pop 
3a0f				endm 
# End of macro FORTH_DSP_POP
3a0f			 
3a0f					; calculate  
3a0f			 
3a0f					NEXTW 
3a0f c3 2f 1d			jp macro_next 
3a12				endm 
# End of macro NEXTW
3a12			 
3a12			 
3a12			.HOME: 
3a12				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3a12 41				db WORD_SYS_CORE+45             
3a13 3f 3a			dw .SPACE            
3a15 05				db 4 + 1 
3a16 .. 00			db "HOME",0              
3a1b				endm 
# End of macro CWHEAD
3a1b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3a1b					if DEBUG_FORTH_WORDS_KEY 
3a1b						DMARK "HOM" 
3a1b f5				push af  
3a1c 3a 30 3a			ld a, (.dmark)  
3a1f 32 7a ee			ld (debug_mark),a  
3a22 3a 31 3a			ld a, (.dmark+1)  
3a25 32 7b ee			ld (debug_mark+1),a  
3a28 3a 32 3a			ld a, (.dmark+2)  
3a2b 32 7c ee			ld (debug_mark+2),a  
3a2e 18 03			jr .pastdmark  
3a30 ..			.dmark: db "HOM"  
3a33 f1			.pastdmark: pop af  
3a34			endm  
# End of macro DMARK
3a34						CALLMONITOR 
3a34 cd 39 14			call break_point_state  
3a37				endm  
# End of macro CALLMONITOR
3a37					endif 
3a37 3e 00		.home:		ld a, 0		; and home cursor 
3a39 32 49 eb				ld (f_cursor_ptr), a 
3a3c					NEXTW 
3a3c c3 2f 1d			jp macro_next 
3a3f				endm 
# End of macro NEXTW
3a3f			 
3a3f			 
3a3f			.SPACE: 
3a3f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3a3f 46				db WORD_SYS_CORE+50             
3a40 6d 3a			dw .SPACES            
3a42 03				db 2 + 1 
3a43 .. 00			db "BL",0              
3a46				endm 
# End of macro CWHEAD
3a46			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3a46					if DEBUG_FORTH_WORDS_KEY 
3a46						DMARK "BL." 
3a46 f5				push af  
3a47 3a 5b 3a			ld a, (.dmark)  
3a4a 32 7a ee			ld (debug_mark),a  
3a4d 3a 5c 3a			ld a, (.dmark+1)  
3a50 32 7b ee			ld (debug_mark+1),a  
3a53 3a 5d 3a			ld a, (.dmark+2)  
3a56 32 7c ee			ld (debug_mark+2),a  
3a59 18 03			jr .pastdmark  
3a5b ..			.dmark: db "BL."  
3a5e f1			.pastdmark: pop af  
3a5f			endm  
# End of macro DMARK
3a5f						CALLMONITOR 
3a5f cd 39 14			call break_point_state  
3a62				endm  
# End of macro CALLMONITOR
3a62					endif 
3a62 21 6b 3a				ld hl, .blstr 
3a65 cd 34 1a				call forth_push_str 
3a68					 
3a68				       NEXTW 
3a68 c3 2f 1d			jp macro_next 
3a6b				endm 
# End of macro NEXTW
3a6b			 
3a6b .. 00		.blstr: db " ", 0 
3a6d			 
3a6d			.SPACES: 
3a6d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3a6d 47				db WORD_SYS_CORE+51             
3a6e 08 3b			dw .SCROLL            
3a70 07				db 6 + 1 
3a71 .. 00			db "SPACES",0              
3a78				endm 
# End of macro CWHEAD
3a78			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a78					if DEBUG_FORTH_WORDS_KEY 
3a78						DMARK "SPS" 
3a78 f5				push af  
3a79 3a 8d 3a			ld a, (.dmark)  
3a7c 32 7a ee			ld (debug_mark),a  
3a7f 3a 8e 3a			ld a, (.dmark+1)  
3a82 32 7b ee			ld (debug_mark+1),a  
3a85 3a 8f 3a			ld a, (.dmark+2)  
3a88 32 7c ee			ld (debug_mark+2),a  
3a8b 18 03			jr .pastdmark  
3a8d ..			.dmark: db "SPS"  
3a90 f1			.pastdmark: pop af  
3a91			endm  
# End of macro DMARK
3a91						CALLMONITOR 
3a91 cd 39 14			call break_point_state  
3a94				endm  
# End of macro CALLMONITOR
3a94					endif 
3a94			 
3a94			 
3a94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a94 cd bd 1b			call macro_dsp_valuehl 
3a97				endm 
# End of macro FORTH_DSP_VALUEHL
3a97			 
3a97			;		push hl    ; u 
3a97					if DEBUG_FORTH_WORDS 
3a97						DMARK "SPA" 
3a97 f5				push af  
3a98 3a ac 3a			ld a, (.dmark)  
3a9b 32 7a ee			ld (debug_mark),a  
3a9e 3a ad 3a			ld a, (.dmark+1)  
3aa1 32 7b ee			ld (debug_mark+1),a  
3aa4 3a ae 3a			ld a, (.dmark+2)  
3aa7 32 7c ee			ld (debug_mark+2),a  
3aaa 18 03			jr .pastdmark  
3aac ..			.dmark: db "SPA"  
3aaf f1			.pastdmark: pop af  
3ab0			endm  
# End of macro DMARK
3ab0						CALLMONITOR 
3ab0 cd 39 14			call break_point_state  
3ab3				endm  
# End of macro CALLMONITOR
3ab3					endif 
3ab3			 
3ab3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ab3 cd 75 1c			call macro_forth_dsp_pop 
3ab6				endm 
# End of macro FORTH_DSP_POP
3ab6			;		pop hl 
3ab6 4d					ld c, l 
3ab7 06 00				ld b, 0 
3ab9 21 60 e3				ld hl, scratch  
3abc			 
3abc					if DEBUG_FORTH_WORDS 
3abc						DMARK "SP2" 
3abc f5				push af  
3abd 3a d1 3a			ld a, (.dmark)  
3ac0 32 7a ee			ld (debug_mark),a  
3ac3 3a d2 3a			ld a, (.dmark+1)  
3ac6 32 7b ee			ld (debug_mark+1),a  
3ac9 3a d3 3a			ld a, (.dmark+2)  
3acc 32 7c ee			ld (debug_mark+2),a  
3acf 18 03			jr .pastdmark  
3ad1 ..			.dmark: db "SP2"  
3ad4 f1			.pastdmark: pop af  
3ad5			endm  
# End of macro DMARK
3ad5						CALLMONITOR 
3ad5 cd 39 14			call break_point_state  
3ad8				endm  
# End of macro CALLMONITOR
3ad8					endif 
3ad8 3e 20				ld a, ' ' 
3ada c5			.spaces1:	push bc 
3adb 77					ld (hl),a 
3adc 23					inc hl 
3add c1					pop bc 
3ade 10 fa				djnz .spaces1 
3ae0 3e 00				ld a,0 
3ae2 77					ld (hl),a 
3ae3 21 60 e3				ld hl, scratch 
3ae6					if DEBUG_FORTH_WORDS 
3ae6						DMARK "SP3" 
3ae6 f5				push af  
3ae7 3a fb 3a			ld a, (.dmark)  
3aea 32 7a ee			ld (debug_mark),a  
3aed 3a fc 3a			ld a, (.dmark+1)  
3af0 32 7b ee			ld (debug_mark+1),a  
3af3 3a fd 3a			ld a, (.dmark+2)  
3af6 32 7c ee			ld (debug_mark+2),a  
3af9 18 03			jr .pastdmark  
3afb ..			.dmark: db "SP3"  
3afe f1			.pastdmark: pop af  
3aff			endm  
# End of macro DMARK
3aff						CALLMONITOR 
3aff cd 39 14			call break_point_state  
3b02				endm  
# End of macro CALLMONITOR
3b02					endif 
3b02 cd 2f 1b				call forth_apush 
3b05			 
3b05				       NEXTW 
3b05 c3 2f 1d			jp macro_next 
3b08				endm 
# End of macro NEXTW
3b08			 
3b08			 
3b08			 
3b08			.SCROLL: 
3b08				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3b08 53				db WORD_SYS_CORE+63             
3b09 35 3b			dw .SCROLLD            
3b0b 07				db 6 + 1 
3b0c .. 00			db "SCROLL",0              
3b13				endm 
# End of macro CWHEAD
3b13			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3b13					if DEBUG_FORTH_WORDS_KEY 
3b13						DMARK "SCR" 
3b13 f5				push af  
3b14 3a 28 3b			ld a, (.dmark)  
3b17 32 7a ee			ld (debug_mark),a  
3b1a 3a 29 3b			ld a, (.dmark+1)  
3b1d 32 7b ee			ld (debug_mark+1),a  
3b20 3a 2a 3b			ld a, (.dmark+2)  
3b23 32 7c ee			ld (debug_mark+2),a  
3b26 18 03			jr .pastdmark  
3b28 ..			.dmark: db "SCR"  
3b2b f1			.pastdmark: pop af  
3b2c			endm  
# End of macro DMARK
3b2c						CALLMONITOR 
3b2c cd 39 14			call break_point_state  
3b2f				endm  
# End of macro CALLMONITOR
3b2f					endif 
3b2f			 
3b2f cd 5b 09			call scroll_up 
3b32			;	call update_display 
3b32			 
3b32					NEXTW 
3b32 c3 2f 1d			jp macro_next 
3b35				endm 
# End of macro NEXTW
3b35			 
3b35			 
3b35			 
3b35			;		; get dir 
3b35			; 
3b35			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b35			; 
3b35			;		push hl 
3b35			; 
3b35			;		; destroy value TOS 
3b35			; 
3b35			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b35			; 
3b35			;		; get count 
3b35			; 
3b35			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b35			; 
3b35			;		push hl 
3b35			; 
3b35			;		; destroy value TOS 
3b35			; 
3b35			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b35			; 
3b35			;		; one value on hl get other one back 
3b35			; 
3b35			;		pop bc    ; count 
3b35			; 
3b35			;		pop de   ; dir 
3b35			; 
3b35			; 
3b35			;		ld b, c 
3b35			; 
3b35			;.scrolldir:     push bc 
3b35			;		push de 
3b35			; 
3b35			;		ld a, 0 
3b35			;		cp e 
3b35			;		jr z, .scrollup  
3b35			;		call scroll_down 
3b35			;		jr .scrollnext 
3b35			;.scrollup:	call scroll_up 
3b35			; 
3b35			;		 
3b35			;.scrollnext: 
3b35			;		pop de 
3b35			;		pop bc 
3b35			;		djnz .scrolldir 
3b35			; 
3b35			; 
3b35			; 
3b35			; 
3b35			; 
3b35			;		NEXTW 
3b35			 
3b35			.SCROLLD: 
3b35				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3b35 53				db WORD_SYS_CORE+63             
3b36 63 3b			dw .ATQ            
3b38 08				db 7 + 1 
3b39 .. 00			db "SCROLLD",0              
3b41				endm 
# End of macro CWHEAD
3b41			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3b41					if DEBUG_FORTH_WORDS_KEY 
3b41						DMARK "SCD" 
3b41 f5				push af  
3b42 3a 56 3b			ld a, (.dmark)  
3b45 32 7a ee			ld (debug_mark),a  
3b48 3a 57 3b			ld a, (.dmark+1)  
3b4b 32 7b ee			ld (debug_mark+1),a  
3b4e 3a 58 3b			ld a, (.dmark+2)  
3b51 32 7c ee			ld (debug_mark+2),a  
3b54 18 03			jr .pastdmark  
3b56 ..			.dmark: db "SCD"  
3b59 f1			.pastdmark: pop af  
3b5a			endm  
# End of macro DMARK
3b5a						CALLMONITOR 
3b5a cd 39 14			call break_point_state  
3b5d				endm  
# End of macro CALLMONITOR
3b5d					endif 
3b5d			 
3b5d cd 7f 09			call scroll_down 
3b60			;	call update_display 
3b60			 
3b60					NEXTW 
3b60 c3 2f 1d			jp macro_next 
3b63				endm 
# End of macro NEXTW
3b63			 
3b63			 
3b63			.ATQ: 
3b63				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3b63 62				db WORD_SYS_CORE+78             
3b64 c1 3b			dw .AUTODSP            
3b66 04				db 3 + 1 
3b67 .. 00			db "AT@",0              
3b6b				endm 
# End of macro CWHEAD
3b6b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3b6b					if DEBUG_FORTH_WORDS_KEY 
3b6b						DMARK "ATA" 
3b6b f5				push af  
3b6c 3a 80 3b			ld a, (.dmark)  
3b6f 32 7a ee			ld (debug_mark),a  
3b72 3a 81 3b			ld a, (.dmark+1)  
3b75 32 7b ee			ld (debug_mark+1),a  
3b78 3a 82 3b			ld a, (.dmark+2)  
3b7b 32 7c ee			ld (debug_mark+2),a  
3b7e 18 03			jr .pastdmark  
3b80 ..			.dmark: db "ATA"  
3b83 f1			.pastdmark: pop af  
3b84			endm  
# End of macro DMARK
3b84						CALLMONITOR 
3b84 cd 39 14			call break_point_state  
3b87				endm  
# End of macro CALLMONITOR
3b87					endif 
3b87			 
3b87			 
3b87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b87 cd bd 1b			call macro_dsp_valuehl 
3b8a				endm 
# End of macro FORTH_DSP_VALUEHL
3b8a			 
3b8a					; TODO save cursor row 
3b8a 7d					ld a,l 
3b8b fe 02				cp 2 
3b8d 20 04				jr nz, .crow3aq 
3b8f 3e 28				ld a, display_row_2 
3b91 18 12				jr .ccol1aq 
3b93 fe 03		.crow3aq:		cp 3 
3b95 20 04				jr nz, .crow4aq 
3b97 3e 50				ld a, display_row_3 
3b99 18 0a				jr .ccol1aq 
3b9b fe 04		.crow4aq:		cp 4 
3b9d 20 04				jr nz, .crow1aq 
3b9f 3e 78				ld a, display_row_4 
3ba1 18 02				jr .ccol1aq 
3ba3 3e 00		.crow1aq:		ld a,display_row_1 
3ba5 f5			.ccol1aq:		push af			; got row offset 
3ba6 6f					ld l,a 
3ba7 26 00				ld h,0 
3ba9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba9 cd 75 1c			call macro_forth_dsp_pop 
3bac				endm 
# End of macro FORTH_DSP_POP
3bac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bac cd bd 1b			call macro_dsp_valuehl 
3baf				endm 
# End of macro FORTH_DSP_VALUEHL
3baf					; TODO save cursor col 
3baf f1					pop af 
3bb0 85					add l		; add col offset 
3bb1			 
3bb1					; add current frame buffer address 
3bb1 2a db eb				ld hl, (display_fb_active) 
3bb4 cd c6 0b				call addatohl 
3bb7			 
3bb7			 
3bb7			 
3bb7			 
3bb7					; get char frame buffer location offset in hl 
3bb7			 
3bb7 7e					ld a,(hl) 
3bb8 26 00				ld h, 0 
3bba 6f					ld l, a 
3bbb			 
3bbb cd c6 19				call forth_push_numhl 
3bbe			 
3bbe			 
3bbe					NEXTW 
3bbe c3 2f 1d			jp macro_next 
3bc1				endm 
# End of macro NEXTW
3bc1			 
3bc1			.AUTODSP: 
3bc1				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3bc1 63				db WORD_SYS_CORE+79             
3bc2 d7 3b			dw .MENU            
3bc4 05				db 4 + 1 
3bc5 .. 00			db "ADSP",0              
3bca				endm 
# End of macro CWHEAD
3bca			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3bca			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3bca			 
3bca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bca cd bd 1b			call macro_dsp_valuehl 
3bcd				endm 
# End of macro FORTH_DSP_VALUEHL
3bcd			 
3bcd			;		push hl 
3bcd			 
3bcd					; destroy value TOS 
3bcd			 
3bcd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bcd cd 75 1c			call macro_forth_dsp_pop 
3bd0				endm 
# End of macro FORTH_DSP_POP
3bd0			 
3bd0			;		pop hl 
3bd0			 
3bd0 7d					ld a,l 
3bd1 32 27 eb				ld (cli_autodisplay), a 
3bd4				       NEXTW 
3bd4 c3 2f 1d			jp macro_next 
3bd7				endm 
# End of macro NEXTW
3bd7			 
3bd7			.MENU: 
3bd7				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3bd7 70				db WORD_SYS_CORE+92             
3bd8 80 3c			dw .ENDDISPLAY            
3bda 05				db 4 + 1 
3bdb .. 00			db "MENU",0              
3be0				endm 
# End of macro CWHEAD
3be0			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3be0			 
3be0			;		; get number of items on the stack 
3be0			; 
3be0				 
3be0					FORTH_DSP_VALUEHL 
3be0 cd bd 1b			call macro_dsp_valuehl 
3be3				endm 
# End of macro FORTH_DSP_VALUEHL
3be3				 
3be3					if DEBUG_FORTH_WORDS_KEY 
3be3						DMARK "MNU" 
3be3 f5				push af  
3be4 3a f8 3b			ld a, (.dmark)  
3be7 32 7a ee			ld (debug_mark),a  
3bea 3a f9 3b			ld a, (.dmark+1)  
3bed 32 7b ee			ld (debug_mark+1),a  
3bf0 3a fa 3b			ld a, (.dmark+2)  
3bf3 32 7c ee			ld (debug_mark+2),a  
3bf6 18 03			jr .pastdmark  
3bf8 ..			.dmark: db "MNU"  
3bfb f1			.pastdmark: pop af  
3bfc			endm  
# End of macro DMARK
3bfc						CALLMONITOR 
3bfc cd 39 14			call break_point_state  
3bff				endm  
# End of macro CALLMONITOR
3bff					endif 
3bff			 
3bff 45					ld b, l	 
3c00 05					dec b 
3c01			 
3c01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c01 cd 75 1c			call macro_forth_dsp_pop 
3c04				endm 
# End of macro FORTH_DSP_POP
3c04			 
3c04			 
3c04					; go directly through the stack to pluck out the string pointers and build an array 
3c04			 
3c04			;		FORTH_DSP 
3c04			 
3c04					; hl contains top most stack item 
3c04				 
3c04 11 60 e3				ld de, scratch 
3c07			 
3c07			.mbuild: 
3c07			 
3c07					FORTH_DSP_VALUEHL 
3c07 cd bd 1b			call macro_dsp_valuehl 
3c0a				endm 
# End of macro FORTH_DSP_VALUEHL
3c0a			 
3c0a					if DEBUG_FORTH_WORDS 
3c0a						DMARK "MN3" 
3c0a f5				push af  
3c0b 3a 1f 3c			ld a, (.dmark)  
3c0e 32 7a ee			ld (debug_mark),a  
3c11 3a 20 3c			ld a, (.dmark+1)  
3c14 32 7b ee			ld (debug_mark+1),a  
3c17 3a 21 3c			ld a, (.dmark+2)  
3c1a 32 7c ee			ld (debug_mark+2),a  
3c1d 18 03			jr .pastdmark  
3c1f ..			.dmark: db "MN3"  
3c22 f1			.pastdmark: pop af  
3c23			endm  
# End of macro DMARK
3c23						CALLMONITOR 
3c23 cd 39 14			call break_point_state  
3c26				endm  
# End of macro CALLMONITOR
3c26					endif 
3c26 eb					ex de, hl 
3c27 73					ld (hl), e 
3c28 23					inc hl 
3c29 72					ld (hl), d 
3c2a 23					inc hl 
3c2b eb					ex de, hl 
3c2c			 
3c2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2c cd 75 1c			call macro_forth_dsp_pop 
3c2f				endm 
# End of macro FORTH_DSP_POP
3c2f			 
3c2f 10 d6				djnz .mbuild 
3c31			 
3c31					; done add term 
3c31			 
3c31 eb					ex de, hl 
3c32 36 00				ld (hl), 0 
3c34 23					inc hl 
3c35 36 00				ld (hl), 0 
3c37			 
3c37				 
3c37					 
3c37 21 60 e3				ld hl, scratch 
3c3a			 
3c3a					if DEBUG_FORTH_WORDS 
3c3a						DMARK "MNx" 
3c3a f5				push af  
3c3b 3a 4f 3c			ld a, (.dmark)  
3c3e 32 7a ee			ld (debug_mark),a  
3c41 3a 50 3c			ld a, (.dmark+1)  
3c44 32 7b ee			ld (debug_mark+1),a  
3c47 3a 51 3c			ld a, (.dmark+2)  
3c4a 32 7c ee			ld (debug_mark+2),a  
3c4d 18 03			jr .pastdmark  
3c4f ..			.dmark: db "MNx"  
3c52 f1			.pastdmark: pop af  
3c53			endm  
# End of macro DMARK
3c53						CALLMONITOR 
3c53 cd 39 14			call break_point_state  
3c56				endm  
# End of macro CALLMONITOR
3c56					endif 
3c56			 
3c56			 
3c56			 
3c56 3e 00				ld a, 0 
3c58 cd ca 09				call menu 
3c5b			 
3c5b			 
3c5b 6f					ld l, a 
3c5c 26 00				ld h, 0 
3c5e			 
3c5e					if DEBUG_FORTH_WORDS 
3c5e						DMARK "MNr" 
3c5e f5				push af  
3c5f 3a 73 3c			ld a, (.dmark)  
3c62 32 7a ee			ld (debug_mark),a  
3c65 3a 74 3c			ld a, (.dmark+1)  
3c68 32 7b ee			ld (debug_mark+1),a  
3c6b 3a 75 3c			ld a, (.dmark+2)  
3c6e 32 7c ee			ld (debug_mark+2),a  
3c71 18 03			jr .pastdmark  
3c73 ..			.dmark: db "MNr"  
3c76 f1			.pastdmark: pop af  
3c77			endm  
# End of macro DMARK
3c77						CALLMONITOR 
3c77 cd 39 14			call break_point_state  
3c7a				endm  
# End of macro CALLMONITOR
3c7a					endif 
3c7a			 
3c7a cd c6 19				call forth_push_numhl 
3c7d			 
3c7d			 
3c7d			 
3c7d			 
3c7d				       NEXTW 
3c7d c3 2f 1d			jp macro_next 
3c80				endm 
# End of macro NEXTW
3c80			 
3c80			 
3c80			.ENDDISPLAY: 
3c80			 
3c80			; eof 
# End of file forth_words_display.asm
3c80			include "forth_words_str.asm" 
3c80			 
3c80			; | ## String Words 
3c80			 
3c80			.PTR:   
3c80			 
3c80				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3c80 48				db WORD_SYS_CORE+52             
3c81 ad 3c			dw .STYPE            
3c83 04				db 3 + 1 
3c84 .. 00			db "PTR",0              
3c88				endm 
# End of macro CWHEAD
3c88			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3c88			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3c88			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3c88			 
3c88					if DEBUG_FORTH_WORDS_KEY 
3c88						DMARK "PTR" 
3c88 f5				push af  
3c89 3a 9d 3c			ld a, (.dmark)  
3c8c 32 7a ee			ld (debug_mark),a  
3c8f 3a 9e 3c			ld a, (.dmark+1)  
3c92 32 7b ee			ld (debug_mark+1),a  
3c95 3a 9f 3c			ld a, (.dmark+2)  
3c98 32 7c ee			ld (debug_mark+2),a  
3c9b 18 03			jr .pastdmark  
3c9d ..			.dmark: db "PTR"  
3ca0 f1			.pastdmark: pop af  
3ca1			endm  
# End of macro DMARK
3ca1						CALLMONITOR 
3ca1 cd 39 14			call break_point_state  
3ca4				endm  
# End of macro CALLMONITOR
3ca4					endif 
3ca4					FORTH_DSP_VALUEHL 
3ca4 cd bd 1b			call macro_dsp_valuehl 
3ca7				endm 
# End of macro FORTH_DSP_VALUEHL
3ca7 cd c6 19				call forth_push_numhl 
3caa			 
3caa			 
3caa					NEXTW 
3caa c3 2f 1d			jp macro_next 
3cad				endm 
# End of macro NEXTW
3cad			.STYPE: 
3cad				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3cad 48				db WORD_SYS_CORE+52             
3cae fc 3c			dw .UPPER            
3cb0 06				db 5 + 1 
3cb1 .. 00			db "STYPE",0              
3cb7				endm 
# End of macro CWHEAD
3cb7			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3cb7					if DEBUG_FORTH_WORDS_KEY 
3cb7						DMARK "STY" 
3cb7 f5				push af  
3cb8 3a cc 3c			ld a, (.dmark)  
3cbb 32 7a ee			ld (debug_mark),a  
3cbe 3a cd 3c			ld a, (.dmark+1)  
3cc1 32 7b ee			ld (debug_mark+1),a  
3cc4 3a ce 3c			ld a, (.dmark+2)  
3cc7 32 7c ee			ld (debug_mark+2),a  
3cca 18 03			jr .pastdmark  
3ccc ..			.dmark: db "STY"  
3ccf f1			.pastdmark: pop af  
3cd0			endm  
# End of macro DMARK
3cd0						CALLMONITOR 
3cd0 cd 39 14			call break_point_state  
3cd3				endm  
# End of macro CALLMONITOR
3cd3					endif 
3cd3					FORTH_DSP 
3cd3 cd 83 1b			call macro_forth_dsp 
3cd6				endm 
# End of macro FORTH_DSP
3cd6					;v5 FORTH_DSP_VALUE 
3cd6			 
3cd6 7e					ld a, (hl) 
3cd7			 
3cd7 f5					push af 
3cd8			 
3cd8			; Dont destroy TOS		FORTH_DSP_POP 
3cd8			 
3cd8 f1					pop af 
3cd9			 
3cd9 fe 01				cp DS_TYPE_STR 
3cdb 28 09				jr z, .typestr 
3cdd			 
3cdd fe 02				cp DS_TYPE_INUM 
3cdf 28 0a				jr z, .typeinum 
3ce1			 
3ce1 21 fa 3c				ld hl, .tna 
3ce4 18 0a				jr .tpush 
3ce6			 
3ce6 21 f6 3c		.typestr:	ld hl, .tstr 
3ce9 18 05				jr .tpush 
3ceb 21 f8 3c		.typeinum:	ld hl, .tinum 
3cee 18 00				jr .tpush 
3cf0			 
3cf0			.tpush: 
3cf0			 
3cf0 cd 34 1a				call forth_push_str 
3cf3			 
3cf3					NEXTW 
3cf3 c3 2f 1d			jp macro_next 
3cf6				endm 
# End of macro NEXTW
3cf6 .. 00		.tstr:	db "s",0 
3cf8 .. 00		.tinum:  db "i",0 
3cfa .. 00		.tna:   db "?", 0 
3cfc			 
3cfc			 
3cfc			.UPPER: 
3cfc				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3cfc 48				db WORD_SYS_CORE+52             
3cfd 37 3d			dw .LOWER            
3cff 06				db 5 + 1 
3d00 .. 00			db "UPPER",0              
3d06				endm 
# End of macro CWHEAD
3d06			; | UPPER ( s -- s ) Upper case string s  | DONE 
3d06					if DEBUG_FORTH_WORDS_KEY 
3d06						DMARK "UPR" 
3d06 f5				push af  
3d07 3a 1b 3d			ld a, (.dmark)  
3d0a 32 7a ee			ld (debug_mark),a  
3d0d 3a 1c 3d			ld a, (.dmark+1)  
3d10 32 7b ee			ld (debug_mark+1),a  
3d13 3a 1d 3d			ld a, (.dmark+2)  
3d16 32 7c ee			ld (debug_mark+2),a  
3d19 18 03			jr .pastdmark  
3d1b ..			.dmark: db "UPR"  
3d1e f1			.pastdmark: pop af  
3d1f			endm  
# End of macro DMARK
3d1f						CALLMONITOR 
3d1f cd 39 14			call break_point_state  
3d22				endm  
# End of macro CALLMONITOR
3d22					endif 
3d22			 
3d22					FORTH_DSP 
3d22 cd 83 1b			call macro_forth_dsp 
3d25				endm 
# End of macro FORTH_DSP
3d25					 
3d25			; TODO check is string type 
3d25			 
3d25					FORTH_DSP_VALUEHL 
3d25 cd bd 1b			call macro_dsp_valuehl 
3d28				endm 
# End of macro FORTH_DSP_VALUEHL
3d28			; get pointer to string in hl 
3d28			 
3d28 7e			.toup:		ld a, (hl) 
3d29 fe 00				cp 0 
3d2b 28 07				jr z, .toupdone 
3d2d			 
3d2d cd 33 0f				call to_upper 
3d30			 
3d30 77					ld (hl), a 
3d31 23					inc hl 
3d32 18 f4				jr .toup 
3d34			 
3d34					 
3d34			 
3d34			 
3d34			; for each char convert to upper 
3d34					 
3d34			.toupdone: 
3d34			 
3d34			 
3d34					NEXTW 
3d34 c3 2f 1d			jp macro_next 
3d37				endm 
# End of macro NEXTW
3d37			.LOWER: 
3d37				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3d37 48				db WORD_SYS_CORE+52             
3d38 72 3d			dw .TCASE            
3d3a 06				db 5 + 1 
3d3b .. 00			db "LOWER",0              
3d41				endm 
# End of macro CWHEAD
3d41			; | LOWER ( s -- s ) Lower case string s  | DONE 
3d41					if DEBUG_FORTH_WORDS_KEY 
3d41						DMARK "LWR" 
3d41 f5				push af  
3d42 3a 56 3d			ld a, (.dmark)  
3d45 32 7a ee			ld (debug_mark),a  
3d48 3a 57 3d			ld a, (.dmark+1)  
3d4b 32 7b ee			ld (debug_mark+1),a  
3d4e 3a 58 3d			ld a, (.dmark+2)  
3d51 32 7c ee			ld (debug_mark+2),a  
3d54 18 03			jr .pastdmark  
3d56 ..			.dmark: db "LWR"  
3d59 f1			.pastdmark: pop af  
3d5a			endm  
# End of macro DMARK
3d5a						CALLMONITOR 
3d5a cd 39 14			call break_point_state  
3d5d				endm  
# End of macro CALLMONITOR
3d5d					endif 
3d5d			 
3d5d					FORTH_DSP 
3d5d cd 83 1b			call macro_forth_dsp 
3d60				endm 
# End of macro FORTH_DSP
3d60					 
3d60			; TODO check is string type 
3d60			 
3d60					FORTH_DSP_VALUEHL 
3d60 cd bd 1b			call macro_dsp_valuehl 
3d63				endm 
# End of macro FORTH_DSP_VALUEHL
3d63			; get pointer to string in hl 
3d63			 
3d63 7e			.tolow:		ld a, (hl) 
3d64 fe 00				cp 0 
3d66 28 07				jr z, .tolowdone 
3d68			 
3d68 cd 3c 0f				call to_lower 
3d6b			 
3d6b 77					ld (hl), a 
3d6c 23					inc hl 
3d6d 18 f4				jr .tolow 
3d6f			 
3d6f					 
3d6f			 
3d6f			 
3d6f			; for each char convert to low 
3d6f					 
3d6f			.tolowdone: 
3d6f					NEXTW 
3d6f c3 2f 1d			jp macro_next 
3d72				endm 
# End of macro NEXTW
3d72			.TCASE: 
3d72				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3d72 48				db WORD_SYS_CORE+52             
3d73 a8 3e			dw .SUBSTR            
3d75 06				db 5 + 1 
3d76 .. 00			db "TCASE",0              
3d7c				endm 
# End of macro CWHEAD
3d7c			; | TCASE ( s -- s ) Title case string s  | DONE 
3d7c					if DEBUG_FORTH_WORDS_KEY 
3d7c						DMARK "TCS" 
3d7c f5				push af  
3d7d 3a 91 3d			ld a, (.dmark)  
3d80 32 7a ee			ld (debug_mark),a  
3d83 3a 92 3d			ld a, (.dmark+1)  
3d86 32 7b ee			ld (debug_mark+1),a  
3d89 3a 93 3d			ld a, (.dmark+2)  
3d8c 32 7c ee			ld (debug_mark+2),a  
3d8f 18 03			jr .pastdmark  
3d91 ..			.dmark: db "TCS"  
3d94 f1			.pastdmark: pop af  
3d95			endm  
# End of macro DMARK
3d95						CALLMONITOR 
3d95 cd 39 14			call break_point_state  
3d98				endm  
# End of macro CALLMONITOR
3d98					endif 
3d98			 
3d98					FORTH_DSP 
3d98 cd 83 1b			call macro_forth_dsp 
3d9b				endm 
# End of macro FORTH_DSP
3d9b					 
3d9b			; TODO check is string type 
3d9b			 
3d9b					FORTH_DSP_VALUEHL 
3d9b cd bd 1b			call macro_dsp_valuehl 
3d9e				endm 
# End of macro FORTH_DSP_VALUEHL
3d9e			; get pointer to string in hl 
3d9e			 
3d9e					if DEBUG_FORTH_WORDS 
3d9e						DMARK "TC1" 
3d9e f5				push af  
3d9f 3a b3 3d			ld a, (.dmark)  
3da2 32 7a ee			ld (debug_mark),a  
3da5 3a b4 3d			ld a, (.dmark+1)  
3da8 32 7b ee			ld (debug_mark+1),a  
3dab 3a b5 3d			ld a, (.dmark+2)  
3dae 32 7c ee			ld (debug_mark+2),a  
3db1 18 03			jr .pastdmark  
3db3 ..			.dmark: db "TC1"  
3db6 f1			.pastdmark: pop af  
3db7			endm  
# End of macro DMARK
3db7						CALLMONITOR 
3db7 cd 39 14			call break_point_state  
3dba				endm  
# End of macro CALLMONITOR
3dba					endif 
3dba			 
3dba					; first time in turn to upper case first char 
3dba			 
3dba 7e					ld a, (hl) 
3dbb c3 45 3e				jp .totsiptou 
3dbe			 
3dbe			 
3dbe 7e			.tot:		ld a, (hl) 
3dbf fe 00				cp 0 
3dc1 ca 89 3e				jp z, .totdone 
3dc4			 
3dc4					if DEBUG_FORTH_WORDS 
3dc4						DMARK "TC2" 
3dc4 f5				push af  
3dc5 3a d9 3d			ld a, (.dmark)  
3dc8 32 7a ee			ld (debug_mark),a  
3dcb 3a da 3d			ld a, (.dmark+1)  
3dce 32 7b ee			ld (debug_mark+1),a  
3dd1 3a db 3d			ld a, (.dmark+2)  
3dd4 32 7c ee			ld (debug_mark+2),a  
3dd7 18 03			jr .pastdmark  
3dd9 ..			.dmark: db "TC2"  
3ddc f1			.pastdmark: pop af  
3ddd			endm  
# End of macro DMARK
3ddd						CALLMONITOR 
3ddd cd 39 14			call break_point_state  
3de0				endm  
# End of macro CALLMONITOR
3de0					endif 
3de0					; check to see if current char is a space 
3de0			 
3de0 fe 20				cp ' ' 
3de2 28 21				jr z, .totsp 
3de4 cd 3c 0f				call to_lower 
3de7					if DEBUG_FORTH_WORDS 
3de7						DMARK "TC3" 
3de7 f5				push af  
3de8 3a fc 3d			ld a, (.dmark)  
3deb 32 7a ee			ld (debug_mark),a  
3dee 3a fd 3d			ld a, (.dmark+1)  
3df1 32 7b ee			ld (debug_mark+1),a  
3df4 3a fe 3d			ld a, (.dmark+2)  
3df7 32 7c ee			ld (debug_mark+2),a  
3dfa 18 03			jr .pastdmark  
3dfc ..			.dmark: db "TC3"  
3dff f1			.pastdmark: pop af  
3e00			endm  
# End of macro DMARK
3e00						CALLMONITOR 
3e00 cd 39 14			call break_point_state  
3e03				endm  
# End of macro CALLMONITOR
3e03					endif 
3e03 18 63				jr .totnxt 
3e05			 
3e05			.totsp:         ; on a space, find next char which should be upper 
3e05			 
3e05					if DEBUG_FORTH_WORDS 
3e05						DMARK "TC4" 
3e05 f5				push af  
3e06 3a 1a 3e			ld a, (.dmark)  
3e09 32 7a ee			ld (debug_mark),a  
3e0c 3a 1b 3e			ld a, (.dmark+1)  
3e0f 32 7b ee			ld (debug_mark+1),a  
3e12 3a 1c 3e			ld a, (.dmark+2)  
3e15 32 7c ee			ld (debug_mark+2),a  
3e18 18 03			jr .pastdmark  
3e1a ..			.dmark: db "TC4"  
3e1d f1			.pastdmark: pop af  
3e1e			endm  
# End of macro DMARK
3e1e						CALLMONITOR 
3e1e cd 39 14			call break_point_state  
3e21				endm  
# End of macro CALLMONITOR
3e21					endif 
3e21					;; 
3e21			 
3e21 fe 20				cp ' ' 
3e23 20 20				jr nz, .totsiptou 
3e25 23					inc hl 
3e26 7e					ld a, (hl) 
3e27					if DEBUG_FORTH_WORDS 
3e27						DMARK "TC5" 
3e27 f5				push af  
3e28 3a 3c 3e			ld a, (.dmark)  
3e2b 32 7a ee			ld (debug_mark),a  
3e2e 3a 3d 3e			ld a, (.dmark+1)  
3e31 32 7b ee			ld (debug_mark+1),a  
3e34 3a 3e 3e			ld a, (.dmark+2)  
3e37 32 7c ee			ld (debug_mark+2),a  
3e3a 18 03			jr .pastdmark  
3e3c ..			.dmark: db "TC5"  
3e3f f1			.pastdmark: pop af  
3e40			endm  
# End of macro DMARK
3e40						CALLMONITOR 
3e40 cd 39 14			call break_point_state  
3e43				endm  
# End of macro CALLMONITOR
3e43					endif 
3e43 18 c0				jr .totsp 
3e45 fe 00		.totsiptou:    cp 0 
3e47 28 40				jr z, .totdone 
3e49					; not space and not zero term so upper case it 
3e49 cd 33 0f				call to_upper 
3e4c			 
3e4c					if DEBUG_FORTH_WORDS 
3e4c						DMARK "TC6" 
3e4c f5				push af  
3e4d 3a 61 3e			ld a, (.dmark)  
3e50 32 7a ee			ld (debug_mark),a  
3e53 3a 62 3e			ld a, (.dmark+1)  
3e56 32 7b ee			ld (debug_mark+1),a  
3e59 3a 63 3e			ld a, (.dmark+2)  
3e5c 32 7c ee			ld (debug_mark+2),a  
3e5f 18 03			jr .pastdmark  
3e61 ..			.dmark: db "TC6"  
3e64 f1			.pastdmark: pop af  
3e65			endm  
# End of macro DMARK
3e65						CALLMONITOR 
3e65 cd 39 14			call break_point_state  
3e68				endm  
# End of macro CALLMONITOR
3e68					endif 
3e68			 
3e68			 
3e68			.totnxt: 
3e68			 
3e68 77					ld (hl), a 
3e69 23					inc hl 
3e6a					if DEBUG_FORTH_WORDS 
3e6a						DMARK "TC7" 
3e6a f5				push af  
3e6b 3a 7f 3e			ld a, (.dmark)  
3e6e 32 7a ee			ld (debug_mark),a  
3e71 3a 80 3e			ld a, (.dmark+1)  
3e74 32 7b ee			ld (debug_mark+1),a  
3e77 3a 81 3e			ld a, (.dmark+2)  
3e7a 32 7c ee			ld (debug_mark+2),a  
3e7d 18 03			jr .pastdmark  
3e7f ..			.dmark: db "TC7"  
3e82 f1			.pastdmark: pop af  
3e83			endm  
# End of macro DMARK
3e83						CALLMONITOR 
3e83 cd 39 14			call break_point_state  
3e86				endm  
# End of macro CALLMONITOR
3e86					endif 
3e86 c3 be 3d				jp .tot 
3e89			 
3e89					 
3e89			 
3e89			 
3e89			; for each char convert to low 
3e89					 
3e89			.totdone: 
3e89					if DEBUG_FORTH_WORDS 
3e89						DMARK "TCd" 
3e89 f5				push af  
3e8a 3a 9e 3e			ld a, (.dmark)  
3e8d 32 7a ee			ld (debug_mark),a  
3e90 3a 9f 3e			ld a, (.dmark+1)  
3e93 32 7b ee			ld (debug_mark+1),a  
3e96 3a a0 3e			ld a, (.dmark+2)  
3e99 32 7c ee			ld (debug_mark+2),a  
3e9c 18 03			jr .pastdmark  
3e9e ..			.dmark: db "TCd"  
3ea1 f1			.pastdmark: pop af  
3ea2			endm  
# End of macro DMARK
3ea2						CALLMONITOR 
3ea2 cd 39 14			call break_point_state  
3ea5				endm  
# End of macro CALLMONITOR
3ea5					endif 
3ea5					NEXTW 
3ea5 c3 2f 1d			jp macro_next 
3ea8				endm 
# End of macro NEXTW
3ea8			 
3ea8			.SUBSTR: 
3ea8				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3ea8 48				db WORD_SYS_CORE+52             
3ea9 06 3f			dw .LEFT            
3eab 07				db 6 + 1 
3eac .. 00			db "SUBSTR",0              
3eb3				endm 
# End of macro CWHEAD
3eb3			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3eb3			 
3eb3					if DEBUG_FORTH_WORDS_KEY 
3eb3						DMARK "SST" 
3eb3 f5				push af  
3eb4 3a c8 3e			ld a, (.dmark)  
3eb7 32 7a ee			ld (debug_mark),a  
3eba 3a c9 3e			ld a, (.dmark+1)  
3ebd 32 7b ee			ld (debug_mark+1),a  
3ec0 3a ca 3e			ld a, (.dmark+2)  
3ec3 32 7c ee			ld (debug_mark+2),a  
3ec6 18 03			jr .pastdmark  
3ec8 ..			.dmark: db "SST"  
3ecb f1			.pastdmark: pop af  
3ecc			endm  
# End of macro DMARK
3ecc						CALLMONITOR 
3ecc cd 39 14			call break_point_state  
3ecf				endm  
# End of macro CALLMONITOR
3ecf					endif 
3ecf			; TODO check string type 
3ecf					FORTH_DSP_VALUEHL 
3ecf cd bd 1b			call macro_dsp_valuehl 
3ed2				endm 
# End of macro FORTH_DSP_VALUEHL
3ed2			 
3ed2 e5					push hl      ; string length 
3ed3			 
3ed3					FORTH_DSP_POP 
3ed3 cd 75 1c			call macro_forth_dsp_pop 
3ed6				endm 
# End of macro FORTH_DSP_POP
3ed6			 
3ed6					FORTH_DSP_VALUEHL 
3ed6 cd bd 1b			call macro_dsp_valuehl 
3ed9				endm 
# End of macro FORTH_DSP_VALUEHL
3ed9			 
3ed9 e5					push hl     ; start char 
3eda			 
3eda					FORTH_DSP_POP 
3eda cd 75 1c			call macro_forth_dsp_pop 
3edd				endm 
# End of macro FORTH_DSP_POP
3edd			 
3edd			 
3edd					FORTH_DSP_VALUE 
3edd cd a6 1b			call macro_forth_dsp_value 
3ee0				endm 
# End of macro FORTH_DSP_VALUE
3ee0			 
3ee0 d1					pop de    ; get start post offset 
3ee1			 
3ee1 19					add hl, de    ; starting offset 
3ee2			 
3ee2 c1					pop bc 
3ee3 c5					push bc      ; grab size of string 
3ee4			 
3ee4 e5					push hl    ; save string start  
3ee5			 
3ee5 26 00				ld h, 0 
3ee7 69					ld l, c 
3ee8 23					inc hl 
3ee9 23					inc hl 
3eea			 
3eea cd 8d 10				call malloc 
3eed				if DEBUG_FORTH_MALLOC_GUARD 
3eed cc 35 45				call z,malloc_error 
3ef0				endif 
3ef0			 
3ef0 eb					ex de, hl      ; save malloc area for string copy 
3ef1 e1					pop hl    ; get back source 
3ef2 c1					pop bc    ; get length of string back 
3ef3			 
3ef3 d5					push de    ; save malloc area for after we push 
3ef4 ed b0				ldir     ; copy substr 
3ef6			 
3ef6			 
3ef6 eb					ex de, hl 
3ef7 3e 00				ld a, 0 
3ef9 77					ld (hl), a   ; term substr 
3efa			 
3efa					 
3efa e1					pop hl    ; get malloc so we can push it 
3efb e5					push hl   ; save so we can free it afterwards 
3efc			 
3efc cd 34 1a				call forth_push_str 
3eff			 
3eff e1					pop hl 
3f00 cd 57 11				call free 
3f03			 
3f03					 
3f03					 
3f03			 
3f03			 
3f03					NEXTW 
3f03 c3 2f 1d			jp macro_next 
3f06				endm 
# End of macro NEXTW
3f06			 
3f06			.LEFT: 
3f06				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3f06 48				db WORD_SYS_CORE+52             
3f07 2e 3f			dw .RIGHT            
3f09 05				db 4 + 1 
3f0a .. 00			db "LEFT",0              
3f0f				endm 
# End of macro CWHEAD
3f0f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3f0f					if DEBUG_FORTH_WORDS_KEY 
3f0f						DMARK "LEF" 
3f0f f5				push af  
3f10 3a 24 3f			ld a, (.dmark)  
3f13 32 7a ee			ld (debug_mark),a  
3f16 3a 25 3f			ld a, (.dmark+1)  
3f19 32 7b ee			ld (debug_mark+1),a  
3f1c 3a 26 3f			ld a, (.dmark+2)  
3f1f 32 7c ee			ld (debug_mark+2),a  
3f22 18 03			jr .pastdmark  
3f24 ..			.dmark: db "LEF"  
3f27 f1			.pastdmark: pop af  
3f28			endm  
# End of macro DMARK
3f28						CALLMONITOR 
3f28 cd 39 14			call break_point_state  
3f2b				endm  
# End of macro CALLMONITOR
3f2b					endif 
3f2b			 
3f2b					NEXTW 
3f2b c3 2f 1d			jp macro_next 
3f2e				endm 
# End of macro NEXTW
3f2e			.RIGHT: 
3f2e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f2e 48				db WORD_SYS_CORE+52             
3f2f 57 3f			dw .STR2NUM            
3f31 06				db 5 + 1 
3f32 .. 00			db "RIGHT",0              
3f38				endm 
# End of macro CWHEAD
3f38			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3f38					if DEBUG_FORTH_WORDS_KEY 
3f38						DMARK "RIG" 
3f38 f5				push af  
3f39 3a 4d 3f			ld a, (.dmark)  
3f3c 32 7a ee			ld (debug_mark),a  
3f3f 3a 4e 3f			ld a, (.dmark+1)  
3f42 32 7b ee			ld (debug_mark+1),a  
3f45 3a 4f 3f			ld a, (.dmark+2)  
3f48 32 7c ee			ld (debug_mark+2),a  
3f4b 18 03			jr .pastdmark  
3f4d ..			.dmark: db "RIG"  
3f50 f1			.pastdmark: pop af  
3f51			endm  
# End of macro DMARK
3f51						CALLMONITOR 
3f51 cd 39 14			call break_point_state  
3f54				endm  
# End of macro CALLMONITOR
3f54					endif 
3f54			 
3f54					NEXTW 
3f54 c3 2f 1d			jp macro_next 
3f57				endm 
# End of macro NEXTW
3f57			 
3f57			 
3f57			.STR2NUM: 
3f57				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3f57 48				db WORD_SYS_CORE+52             
3f58 e3 3f			dw .NUM2STR            
3f5a 08				db 7 + 1 
3f5b .. 00			db "STR2NUM",0              
3f63				endm 
# End of macro CWHEAD
3f63			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3f63			 
3f63			 
3f63			; TODO STR type check to do 
3f63					if DEBUG_FORTH_WORDS_KEY 
3f63						DMARK "S2N" 
3f63 f5				push af  
3f64 3a 78 3f			ld a, (.dmark)  
3f67 32 7a ee			ld (debug_mark),a  
3f6a 3a 79 3f			ld a, (.dmark+1)  
3f6d 32 7b ee			ld (debug_mark+1),a  
3f70 3a 7a 3f			ld a, (.dmark+2)  
3f73 32 7c ee			ld (debug_mark+2),a  
3f76 18 03			jr .pastdmark  
3f78 ..			.dmark: db "S2N"  
3f7b f1			.pastdmark: pop af  
3f7c			endm  
# End of macro DMARK
3f7c						CALLMONITOR 
3f7c cd 39 14			call break_point_state  
3f7f				endm  
# End of macro CALLMONITOR
3f7f					endif 
3f7f			 
3f7f					;FORTH_DSP 
3f7f					FORTH_DSP_VALUE 
3f7f cd a6 1b			call macro_forth_dsp_value 
3f82				endm 
# End of macro FORTH_DSP_VALUE
3f82					;inc hl 
3f82			 
3f82 eb					ex de, hl 
3f83					if DEBUG_FORTH_WORDS 
3f83						DMARK "S2a" 
3f83 f5				push af  
3f84 3a 98 3f			ld a, (.dmark)  
3f87 32 7a ee			ld (debug_mark),a  
3f8a 3a 99 3f			ld a, (.dmark+1)  
3f8d 32 7b ee			ld (debug_mark+1),a  
3f90 3a 9a 3f			ld a, (.dmark+2)  
3f93 32 7c ee			ld (debug_mark+2),a  
3f96 18 03			jr .pastdmark  
3f98 ..			.dmark: db "S2a"  
3f9b f1			.pastdmark: pop af  
3f9c			endm  
# End of macro DMARK
3f9c						CALLMONITOR 
3f9c cd 39 14			call break_point_state  
3f9f				endm  
# End of macro CALLMONITOR
3f9f					endif 
3f9f cd bb 0f				call string_to_uint16 
3fa2			 
3fa2					if DEBUG_FORTH_WORDS 
3fa2						DMARK "S2b" 
3fa2 f5				push af  
3fa3 3a b7 3f			ld a, (.dmark)  
3fa6 32 7a ee			ld (debug_mark),a  
3fa9 3a b8 3f			ld a, (.dmark+1)  
3fac 32 7b ee			ld (debug_mark+1),a  
3faf 3a b9 3f			ld a, (.dmark+2)  
3fb2 32 7c ee			ld (debug_mark+2),a  
3fb5 18 03			jr .pastdmark  
3fb7 ..			.dmark: db "S2b"  
3fba f1			.pastdmark: pop af  
3fbb			endm  
# End of macro DMARK
3fbb						CALLMONITOR 
3fbb cd 39 14			call break_point_state  
3fbe				endm  
# End of macro CALLMONITOR
3fbe					endif 
3fbe			;		push hl 
3fbe					FORTH_DSP_POP 
3fbe cd 75 1c			call macro_forth_dsp_pop 
3fc1				endm 
# End of macro FORTH_DSP_POP
3fc1			;		pop hl 
3fc1					 
3fc1					if DEBUG_FORTH_WORDS 
3fc1						DMARK "S2b" 
3fc1 f5				push af  
3fc2 3a d6 3f			ld a, (.dmark)  
3fc5 32 7a ee			ld (debug_mark),a  
3fc8 3a d7 3f			ld a, (.dmark+1)  
3fcb 32 7b ee			ld (debug_mark+1),a  
3fce 3a d8 3f			ld a, (.dmark+2)  
3fd1 32 7c ee			ld (debug_mark+2),a  
3fd4 18 03			jr .pastdmark  
3fd6 ..			.dmark: db "S2b"  
3fd9 f1			.pastdmark: pop af  
3fda			endm  
# End of macro DMARK
3fda						CALLMONITOR 
3fda cd 39 14			call break_point_state  
3fdd				endm  
# End of macro CALLMONITOR
3fdd					endif 
3fdd cd c6 19				call forth_push_numhl	 
3fe0			 
3fe0				 
3fe0				       NEXTW 
3fe0 c3 2f 1d			jp macro_next 
3fe3				endm 
# End of macro NEXTW
3fe3			.NUM2STR: 
3fe3				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3fe3 48				db WORD_SYS_CORE+52             
3fe4 f2 3f			dw .CONCAT            
3fe6 08				db 7 + 1 
3fe7 .. 00			db "NUM2STR",0              
3fef				endm 
# End of macro CWHEAD
3fef			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3fef			 
3fef			;		; malloc a string to target 
3fef			;		ld hl, 10     ; TODO max string size should be fine 
3fef			;		call malloc 
3fef			;		push hl    ; save malloc location 
3fef			; 
3fef			; 
3fef			;; TODO check int type 
3fef			;		FORTH_DSP_VALUEHL 
3fef			;		ld a, l 
3fef			;		call DispAToASCII   
3fef			;;TODO need to chage above call to dump into string 
3fef			; 
3fef			; 
3fef			 
3fef				       NEXTW 
3fef c3 2f 1d			jp macro_next 
3ff2				endm 
# End of macro NEXTW
3ff2			 
3ff2			.CONCAT: 
3ff2				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3ff2 48				db WORD_SYS_CORE+52             
3ff3 a5 40			dw .FIND            
3ff5 07				db 6 + 1 
3ff6 .. 00			db "CONCAT",0              
3ffd				endm 
# End of macro CWHEAD
3ffd			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3ffd			 
3ffd			; TODO check string type 
3ffd			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3ffd			 
3ffd					if DEBUG_FORTH_WORDS_KEY 
3ffd						DMARK "CON" 
3ffd f5				push af  
3ffe 3a 12 40			ld a, (.dmark)  
4001 32 7a ee			ld (debug_mark),a  
4004 3a 13 40			ld a, (.dmark+1)  
4007 32 7b ee			ld (debug_mark+1),a  
400a 3a 14 40			ld a, (.dmark+2)  
400d 32 7c ee			ld (debug_mark+2),a  
4010 18 03			jr .pastdmark  
4012 ..			.dmark: db "CON"  
4015 f1			.pastdmark: pop af  
4016			endm  
# End of macro DMARK
4016						CALLMONITOR 
4016 cd 39 14			call break_point_state  
4019				endm  
# End of macro CALLMONITOR
4019					endif 
4019			 
4019			 
4019					FORTH_DSP_VALUE 
4019 cd a6 1b			call macro_forth_dsp_value 
401c				endm 
# End of macro FORTH_DSP_VALUE
401c e5					push hl   ; s2 
401d			 
401d					FORTH_DSP_POP 
401d cd 75 1c			call macro_forth_dsp_pop 
4020				endm 
# End of macro FORTH_DSP_POP
4020			 
4020					FORTH_DSP_VALUE 
4020 cd a6 1b			call macro_forth_dsp_value 
4023				endm 
# End of macro FORTH_DSP_VALUE
4023			 
4023 e5					push hl   ; s1 
4024			 
4024					FORTH_DSP_POP 
4024 cd 75 1c			call macro_forth_dsp_pop 
4027				endm 
# End of macro FORTH_DSP_POP
4027					 
4027			 
4027					; copy s1 
4027			 
4027				 
4027					; save ptr 
4027 e1					pop hl  
4028 e5					push hl 
4029 3e 00				ld a, 0 
402b cd 2f 10				call strlent 
402e					;inc hl    ; zer0 
402e 06 00				ld b, 0 
4030 4d					ld c, l 
4031 e1					pop hl		 
4032 11 60 e3				ld de, scratch	 
4035					if DEBUG_FORTH_WORDS 
4035						DMARK "CO1" 
4035 f5				push af  
4036 3a 4a 40			ld a, (.dmark)  
4039 32 7a ee			ld (debug_mark),a  
403c 3a 4b 40			ld a, (.dmark+1)  
403f 32 7b ee			ld (debug_mark+1),a  
4042 3a 4c 40			ld a, (.dmark+2)  
4045 32 7c ee			ld (debug_mark+2),a  
4048 18 03			jr .pastdmark  
404a ..			.dmark: db "CO1"  
404d f1			.pastdmark: pop af  
404e			endm  
# End of macro DMARK
404e						CALLMONITOR 
404e cd 39 14			call break_point_state  
4051				endm  
# End of macro CALLMONITOR
4051					endif 
4051 ed b0				ldir 
4053			 
4053 e1					pop hl 
4054 e5					push hl 
4055 d5					push de 
4056			 
4056			 
4056 3e 00				ld a, 0 
4058 cd 2f 10				call strlent 
405b 23					inc hl    ; zer0 
405c 23					inc hl 
405d 06 00				ld b, 0 
405f 4d					ld c, l 
4060 d1					pop de 
4061 e1					pop hl		 
4062					if DEBUG_FORTH_WORDS 
4062						DMARK "CO2" 
4062 f5				push af  
4063 3a 77 40			ld a, (.dmark)  
4066 32 7a ee			ld (debug_mark),a  
4069 3a 78 40			ld a, (.dmark+1)  
406c 32 7b ee			ld (debug_mark+1),a  
406f 3a 79 40			ld a, (.dmark+2)  
4072 32 7c ee			ld (debug_mark+2),a  
4075 18 03			jr .pastdmark  
4077 ..			.dmark: db "CO2"  
407a f1			.pastdmark: pop af  
407b			endm  
# End of macro DMARK
407b						CALLMONITOR 
407b cd 39 14			call break_point_state  
407e				endm  
# End of macro CALLMONITOR
407e					endif 
407e ed b0				ldir 
4080			 
4080			 
4080			 
4080 21 60 e3				ld hl, scratch 
4083					if DEBUG_FORTH_WORDS 
4083						DMARK "CO5" 
4083 f5				push af  
4084 3a 98 40			ld a, (.dmark)  
4087 32 7a ee			ld (debug_mark),a  
408a 3a 99 40			ld a, (.dmark+1)  
408d 32 7b ee			ld (debug_mark+1),a  
4090 3a 9a 40			ld a, (.dmark+2)  
4093 32 7c ee			ld (debug_mark+2),a  
4096 18 03			jr .pastdmark  
4098 ..			.dmark: db "CO5"  
409b f1			.pastdmark: pop af  
409c			endm  
# End of macro DMARK
409c						CALLMONITOR 
409c cd 39 14			call break_point_state  
409f				endm  
# End of macro CALLMONITOR
409f					endif 
409f			 
409f cd 34 1a				call forth_push_str 
40a2			 
40a2			 
40a2			 
40a2			 
40a2				       NEXTW 
40a2 c3 2f 1d			jp macro_next 
40a5				endm 
# End of macro NEXTW
40a5			 
40a5			 
40a5			.FIND: 
40a5				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
40a5 4b				db WORD_SYS_CORE+55             
40a6 63 41			dw .LEN            
40a8 05				db 4 + 1 
40a9 .. 00			db "FIND",0              
40ae				endm 
# End of macro CWHEAD
40ae			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
40ae			 
40ae					if DEBUG_FORTH_WORDS_KEY 
40ae						DMARK "FND" 
40ae f5				push af  
40af 3a c3 40			ld a, (.dmark)  
40b2 32 7a ee			ld (debug_mark),a  
40b5 3a c4 40			ld a, (.dmark+1)  
40b8 32 7b ee			ld (debug_mark+1),a  
40bb 3a c5 40			ld a, (.dmark+2)  
40be 32 7c ee			ld (debug_mark+2),a  
40c1 18 03			jr .pastdmark  
40c3 ..			.dmark: db "FND"  
40c6 f1			.pastdmark: pop af  
40c7			endm  
# End of macro DMARK
40c7						CALLMONITOR 
40c7 cd 39 14			call break_point_state  
40ca				endm  
# End of macro CALLMONITOR
40ca					endif 
40ca			 
40ca			; TODO check string type 
40ca					FORTH_DSP_VALUE 
40ca cd a6 1b			call macro_forth_dsp_value 
40cd				endm 
# End of macro FORTH_DSP_VALUE
40cd			 
40cd e5					push hl    
40ce 7e					ld a,(hl)    ; char to find   
40cf			; TODO change char to substr 
40cf			 
40cf f5					push af 
40d0					 
40d0			 
40d0			 
40d0					if DEBUG_FORTH_WORDS 
40d0						DMARK "FN1" 
40d0 f5				push af  
40d1 3a e5 40			ld a, (.dmark)  
40d4 32 7a ee			ld (debug_mark),a  
40d7 3a e6 40			ld a, (.dmark+1)  
40da 32 7b ee			ld (debug_mark+1),a  
40dd 3a e7 40			ld a, (.dmark+2)  
40e0 32 7c ee			ld (debug_mark+2),a  
40e3 18 03			jr .pastdmark  
40e5 ..			.dmark: db "FN1"  
40e8 f1			.pastdmark: pop af  
40e9			endm  
# End of macro DMARK
40e9						CALLMONITOR 
40e9 cd 39 14			call break_point_state  
40ec				endm  
# End of macro CALLMONITOR
40ec					endif 
40ec			 
40ec					FORTH_DSP_POP 
40ec cd 75 1c			call macro_forth_dsp_pop 
40ef				endm 
# End of macro FORTH_DSP_POP
40ef			 
40ef					; string to search 
40ef			 
40ef					FORTH_DSP_VALUE 
40ef cd a6 1b			call macro_forth_dsp_value 
40f2				endm 
# End of macro FORTH_DSP_VALUE
40f2			 
40f2 d1					pop de  ; d is char to find  
40f3			 
40f3					if DEBUG_FORTH_WORDS 
40f3						DMARK "FN2" 
40f3 f5				push af  
40f4 3a 08 41			ld a, (.dmark)  
40f7 32 7a ee			ld (debug_mark),a  
40fa 3a 09 41			ld a, (.dmark+1)  
40fd 32 7b ee			ld (debug_mark+1),a  
4100 3a 0a 41			ld a, (.dmark+2)  
4103 32 7c ee			ld (debug_mark+2),a  
4106 18 03			jr .pastdmark  
4108 ..			.dmark: db "FN2"  
410b f1			.pastdmark: pop af  
410c			endm  
# End of macro DMARK
410c						CALLMONITOR 
410c cd 39 14			call break_point_state  
410f				endm  
# End of macro CALLMONITOR
410f					endif 
410f					 
410f 01 00 00				ld bc, 0 
4112 7e			.findchar:      ld a,(hl) 
4113 fe 00				cp 0   		 
4115 28 27				jr z, .finddone     
4117 ba					cp d 
4118 28 20				jr z, .foundchar 
411a 03					inc bc 
411b 23					inc hl 
411c					if DEBUG_FORTH_WORDS 
411c						DMARK "FN3" 
411c f5				push af  
411d 3a 31 41			ld a, (.dmark)  
4120 32 7a ee			ld (debug_mark),a  
4123 3a 32 41			ld a, (.dmark+1)  
4126 32 7b ee			ld (debug_mark+1),a  
4129 3a 33 41			ld a, (.dmark+2)  
412c 32 7c ee			ld (debug_mark+2),a  
412f 18 03			jr .pastdmark  
4131 ..			.dmark: db "FN3"  
4134 f1			.pastdmark: pop af  
4135			endm  
# End of macro DMARK
4135						CALLMONITOR 
4135 cd 39 14			call break_point_state  
4138				endm  
# End of macro CALLMONITOR
4138					endif 
4138 18 d8				jr .findchar 
413a			 
413a			 
413a c5			.foundchar:	push bc 
413b e1					pop hl 
413c 18 03				jr .findexit 
413e			 
413e			 
413e							 
413e			 
413e			.finddone:     ; got to end of string with no find 
413e 21 00 00				ld hl, 0 
4141			.findexit: 
4141			 
4141					if DEBUG_FORTH_WORDS 
4141						DMARK "FNd" 
4141 f5				push af  
4142 3a 56 41			ld a, (.dmark)  
4145 32 7a ee			ld (debug_mark),a  
4148 3a 57 41			ld a, (.dmark+1)  
414b 32 7b ee			ld (debug_mark+1),a  
414e 3a 58 41			ld a, (.dmark+2)  
4151 32 7c ee			ld (debug_mark+2),a  
4154 18 03			jr .pastdmark  
4156 ..			.dmark: db "FNd"  
4159 f1			.pastdmark: pop af  
415a			endm  
# End of macro DMARK
415a						CALLMONITOR 
415a cd 39 14			call break_point_state  
415d				endm  
# End of macro CALLMONITOR
415d					endif 
415d cd c6 19			call forth_push_numhl 
4160			 
4160				       NEXTW 
4160 c3 2f 1d			jp macro_next 
4163				endm 
# End of macro NEXTW
4163			 
4163			.LEN: 
4163				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4163 4c				db WORD_SYS_CORE+56             
4164 98 41			dw .CHAR            
4166 06				db 5 + 1 
4167 .. 00			db "COUNT",0              
416d				endm 
# End of macro CWHEAD
416d			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
416d			 
416d					if DEBUG_FORTH_WORDS_KEY 
416d						DMARK "CNT" 
416d f5				push af  
416e 3a 82 41			ld a, (.dmark)  
4171 32 7a ee			ld (debug_mark),a  
4174 3a 83 41			ld a, (.dmark+1)  
4177 32 7b ee			ld (debug_mark+1),a  
417a 3a 84 41			ld a, (.dmark+2)  
417d 32 7c ee			ld (debug_mark+2),a  
4180 18 03			jr .pastdmark  
4182 ..			.dmark: db "CNT"  
4185 f1			.pastdmark: pop af  
4186			endm  
# End of macro DMARK
4186						CALLMONITOR 
4186 cd 39 14			call break_point_state  
4189				endm  
# End of macro CALLMONITOR
4189					endif 
4189			; TODO check string type 
4189					FORTH_DSP 
4189 cd 83 1b			call macro_forth_dsp 
418c				endm 
# End of macro FORTH_DSP
418c					;v5FORTH_DSP_VALUE 
418c			 
418c 23					inc hl 
418d			 
418d 3e 00				ld a, 0 
418f cd 2f 10				call strlent 
4192			 
4192 cd c6 19				call forth_push_numhl 
4195			 
4195			 
4195			 
4195				       NEXTW 
4195 c3 2f 1d			jp macro_next 
4198				endm 
# End of macro NEXTW
4198			.CHAR: 
4198				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4198 4d				db WORD_SYS_CORE+57             
4199 ce 41			dw .ENDSTR            
419b 05				db 4 + 1 
419c .. 00			db "CHAR",0              
41a1				endm 
# End of macro CWHEAD
41a1			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
41a1					if DEBUG_FORTH_WORDS_KEY 
41a1						DMARK "CHR" 
41a1 f5				push af  
41a2 3a b6 41			ld a, (.dmark)  
41a5 32 7a ee			ld (debug_mark),a  
41a8 3a b7 41			ld a, (.dmark+1)  
41ab 32 7b ee			ld (debug_mark+1),a  
41ae 3a b8 41			ld a, (.dmark+2)  
41b1 32 7c ee			ld (debug_mark+2),a  
41b4 18 03			jr .pastdmark  
41b6 ..			.dmark: db "CHR"  
41b9 f1			.pastdmark: pop af  
41ba			endm  
# End of macro DMARK
41ba						CALLMONITOR 
41ba cd 39 14			call break_point_state  
41bd				endm  
# End of macro CALLMONITOR
41bd					endif 
41bd					FORTH_DSP 
41bd cd 83 1b			call macro_forth_dsp 
41c0				endm 
# End of macro FORTH_DSP
41c0					;v5 FORTH_DSP_VALUE 
41c0 23					inc hl      ; now at start of numeric as string 
41c1			 
41c1			;		push hl 
41c1			 
41c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41c1 cd 75 1c			call macro_forth_dsp_pop 
41c4				endm 
# End of macro FORTH_DSP_POP
41c4			 
41c4			;		pop hl 
41c4			 
41c4					; push the content of a onto the stack as a value 
41c4			 
41c4 7e					ld a,(hl)   ; get char 
41c5 26 00				ld h,0 
41c7 6f					ld l,a 
41c8 cd c6 19				call forth_push_numhl 
41cb			 
41cb				       NEXTW 
41cb c3 2f 1d			jp macro_next 
41ce				endm 
# End of macro NEXTW
41ce			 
41ce			 
41ce			 
41ce			 
41ce			.ENDSTR: 
41ce			; eof 
41ce			 
# End of file forth_words_str.asm
41ce			include "forth_words_key.asm" 
41ce			 
41ce			; | ## Keyboard Words 
41ce			 
41ce			.KEY: 
41ce				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
41ce 3e				db WORD_SYS_CORE+42             
41cf fe 41			dw .WAITK            
41d1 04				db 3 + 1 
41d2 .. 00			db "KEY",0              
41d6				endm 
# End of macro CWHEAD
41d6			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
41d6			 
41d6					if DEBUG_FORTH_WORDS_KEY 
41d6						DMARK "KEY" 
41d6 f5				push af  
41d7 3a eb 41			ld a, (.dmark)  
41da 32 7a ee			ld (debug_mark),a  
41dd 3a ec 41			ld a, (.dmark+1)  
41e0 32 7b ee			ld (debug_mark+1),a  
41e3 3a ed 41			ld a, (.dmark+2)  
41e6 32 7c ee			ld (debug_mark+2),a  
41e9 18 03			jr .pastdmark  
41eb ..			.dmark: db "KEY"  
41ee f1			.pastdmark: pop af  
41ef			endm  
# End of macro DMARK
41ef						CALLMONITOR 
41ef cd 39 14			call break_point_state  
41f2				endm  
# End of macro CALLMONITOR
41f2					endif 
41f2			; TODO currently waits 
41f2 cd bf 58				call cin 
41f5					;call cin_wait 
41f5 6f					ld l, a 
41f6 26 00				ld h, 0 
41f8 cd c6 19				call forth_push_numhl 
41fb					NEXTW 
41fb c3 2f 1d			jp macro_next 
41fe				endm 
# End of macro NEXTW
41fe			.WAITK: 
41fe				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
41fe 3f				db WORD_SYS_CORE+43             
41ff 30 42			dw .ACCEPT            
4201 06				db 5 + 1 
4202 .. 00			db "WAITK",0              
4208				endm 
# End of macro CWHEAD
4208			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4208					if DEBUG_FORTH_WORDS_KEY 
4208						DMARK "WAI" 
4208 f5				push af  
4209 3a 1d 42			ld a, (.dmark)  
420c 32 7a ee			ld (debug_mark),a  
420f 3a 1e 42			ld a, (.dmark+1)  
4212 32 7b ee			ld (debug_mark+1),a  
4215 3a 1f 42			ld a, (.dmark+2)  
4218 32 7c ee			ld (debug_mark+2),a  
421b 18 03			jr .pastdmark  
421d ..			.dmark: db "WAI"  
4220 f1			.pastdmark: pop af  
4221			endm  
# End of macro DMARK
4221						CALLMONITOR 
4221 cd 39 14			call break_point_state  
4224				endm  
# End of macro CALLMONITOR
4224					endif 
4224 cd b7 58				call cin_wait 
4227 6f					ld l, a 
4228 26 00				ld h, 0 
422a cd c6 19				call forth_push_numhl 
422d					NEXTW 
422d c3 2f 1d			jp macro_next 
4230				endm 
# End of macro NEXTW
4230			.ACCEPT: 
4230				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4230 40				db WORD_SYS_CORE+44             
4231 8e 42			dw .EDIT            
4233 07				db 6 + 1 
4234 .. 00			db "ACCEPT",0              
423b				endm 
# End of macro CWHEAD
423b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
423b					; TODO crashes on push 
423b					if DEBUG_FORTH_WORDS_KEY 
423b						DMARK "ACC" 
423b f5				push af  
423c 3a 50 42			ld a, (.dmark)  
423f 32 7a ee			ld (debug_mark),a  
4242 3a 51 42			ld a, (.dmark+1)  
4245 32 7b ee			ld (debug_mark+1),a  
4248 3a 52 42			ld a, (.dmark+2)  
424b 32 7c ee			ld (debug_mark+2),a  
424e 18 03			jr .pastdmark  
4250 ..			.dmark: db "ACC"  
4253 f1			.pastdmark: pop af  
4254			endm  
# End of macro DMARK
4254						CALLMONITOR 
4254 cd 39 14			call break_point_state  
4257				endm  
# End of macro CALLMONITOR
4257					endif 
4257 21 5e e5				ld hl, os_input 
425a 3e 00				ld a, 0 
425c 77					ld (hl),a 
425d 3a 49 eb				ld a,(f_cursor_ptr) 
4260 16 64				ld d, 100 
4262 0e 00				ld c, 0 
4264 1e 28				ld e, 40 
4266 cd f3 0b				call input_str 
4269					; TODO perhaps do a type check and wrap in quotes if not a number 
4269 21 5e e5				ld hl, os_input 
426c					if DEBUG_FORTH_WORDS 
426c						DMARK "AC1" 
426c f5				push af  
426d 3a 81 42			ld a, (.dmark)  
4270 32 7a ee			ld (debug_mark),a  
4273 3a 82 42			ld a, (.dmark+1)  
4276 32 7b ee			ld (debug_mark+1),a  
4279 3a 83 42			ld a, (.dmark+2)  
427c 32 7c ee			ld (debug_mark+2),a  
427f 18 03			jr .pastdmark  
4281 ..			.dmark: db "AC1"  
4284 f1			.pastdmark: pop af  
4285			endm  
# End of macro DMARK
4285						CALLMONITOR 
4285 cd 39 14			call break_point_state  
4288				endm  
# End of macro CALLMONITOR
4288					endif 
4288 cd 34 1a				call forth_push_str 
428b					NEXTW 
428b c3 2f 1d			jp macro_next 
428e				endm 
# End of macro NEXTW
428e			 
428e			.EDIT: 
428e				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
428e 40				db WORD_SYS_CORE+44             
428f 30 43			dw .ENDKEY            
4291 05				db 4 + 1 
4292 .. 00			db "EDIT",0              
4297				endm 
# End of macro CWHEAD
4297			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4297			 
4297					; TODO does not copy from stack 
4297					if DEBUG_FORTH_WORDS_KEY 
4297						DMARK "EDT" 
4297 f5				push af  
4298 3a ac 42			ld a, (.dmark)  
429b 32 7a ee			ld (debug_mark),a  
429e 3a ad 42			ld a, (.dmark+1)  
42a1 32 7b ee			ld (debug_mark+1),a  
42a4 3a ae 42			ld a, (.dmark+2)  
42a7 32 7c ee			ld (debug_mark+2),a  
42aa 18 03			jr .pastdmark  
42ac ..			.dmark: db "EDT"  
42af f1			.pastdmark: pop af  
42b0			endm  
# End of macro DMARK
42b0						CALLMONITOR 
42b0 cd 39 14			call break_point_state  
42b3				endm  
# End of macro CALLMONITOR
42b3					endif 
42b3			 
42b3					;FORTH_DSP 
42b3					FORTH_DSP_VALUEHL 
42b3 cd bd 1b			call macro_dsp_valuehl 
42b6				endm 
# End of macro FORTH_DSP_VALUEHL
42b6			;		inc hl    ; TODO do type check 
42b6			 
42b6			;		call get_word_hl 
42b6 e5					push hl 
42b7					if DEBUG_FORTH_WORDS 
42b7						DMARK "EDp" 
42b7 f5				push af  
42b8 3a cc 42			ld a, (.dmark)  
42bb 32 7a ee			ld (debug_mark),a  
42be 3a cd 42			ld a, (.dmark+1)  
42c1 32 7b ee			ld (debug_mark+1),a  
42c4 3a ce 42			ld a, (.dmark+2)  
42c7 32 7c ee			ld (debug_mark+2),a  
42ca 18 03			jr .pastdmark  
42cc ..			.dmark: db "EDp"  
42cf f1			.pastdmark: pop af  
42d0			endm  
# End of macro DMARK
42d0						CALLMONITOR 
42d0 cd 39 14			call break_point_state  
42d3				endm  
# End of macro CALLMONITOR
42d3					endif 
42d3				;	ld a, 0 
42d3 cd 24 10				call strlenz 
42d6 23					inc hl 
42d7			 
42d7 06 00				ld b, 0 
42d9 4d					ld c, l 
42da			 
42da e1					pop hl 
42db 11 5e e5				ld de, os_input 
42de					if DEBUG_FORTH_WORDS_KEY 
42de						DMARK "EDc" 
42de f5				push af  
42df 3a f3 42			ld a, (.dmark)  
42e2 32 7a ee			ld (debug_mark),a  
42e5 3a f4 42			ld a, (.dmark+1)  
42e8 32 7b ee			ld (debug_mark+1),a  
42eb 3a f5 42			ld a, (.dmark+2)  
42ee 32 7c ee			ld (debug_mark+2),a  
42f1 18 03			jr .pastdmark  
42f3 ..			.dmark: db "EDc"  
42f6 f1			.pastdmark: pop af  
42f7			endm  
# End of macro DMARK
42f7						CALLMONITOR 
42f7 cd 39 14			call break_point_state  
42fa				endm  
# End of macro CALLMONITOR
42fa					endif 
42fa ed b0				ldir 
42fc			 
42fc			 
42fc 21 5e e5				ld hl, os_input 
42ff					;ld a, 0 
42ff					;ld (hl),a 
42ff 3a 49 eb				ld a,(f_cursor_ptr) 
4302 16 64				ld d, 100 
4304 0e 00				ld c, 0 
4306 1e 28				ld e, 40 
4308 cd f3 0b				call input_str 
430b					; TODO perhaps do a type check and wrap in quotes if not a number 
430b 21 5e e5				ld hl, os_input 
430e					if DEBUG_FORTH_WORDS 
430e						DMARK "ED1" 
430e f5				push af  
430f 3a 23 43			ld a, (.dmark)  
4312 32 7a ee			ld (debug_mark),a  
4315 3a 24 43			ld a, (.dmark+1)  
4318 32 7b ee			ld (debug_mark+1),a  
431b 3a 25 43			ld a, (.dmark+2)  
431e 32 7c ee			ld (debug_mark+2),a  
4321 18 03			jr .pastdmark  
4323 ..			.dmark: db "ED1"  
4326 f1			.pastdmark: pop af  
4327			endm  
# End of macro DMARK
4327						CALLMONITOR 
4327 cd 39 14			call break_point_state  
432a				endm  
# End of macro CALLMONITOR
432a					endif 
432a cd 34 1a				call forth_push_str 
432d					NEXTW 
432d c3 2f 1d			jp macro_next 
4330				endm 
# End of macro NEXTW
4330			 
4330			 
4330			 
4330			.ENDKEY: 
4330			; eof 
4330			 
# End of file forth_words_key.asm
4330			 
4330			if STORAGE_SE 
4330			   	include "forth_words_storage.asm" 
4330			endif 
4330				include "forth_words_device.asm" 
4330			; Device related words 
4330			 
4330			; | ## Device Words 
4330			 
4330			if SOUND_ENABLE 
4330			.NOTE: 
4330				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4330			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4330					if DEBUG_FORTH_WORDS_KEY 
4330						DMARK "NTE" 
4330						CALLMONITOR 
4330					endif 
4330			 
4330				 
4330			 
4330					NEXTW 
4330			.AFTERSOUND: 
4330			endif 
4330			 
4330			 
4330			USE_GPIO: equ 0 
4330			 
4330			if USE_GPIO 
4330			.GP1: 
4330				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4330			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4330					NEXTW 
4330			.GP2: 
4330				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4330			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4330			 
4330					NEXTW 
4330			 
4330			.GP3: 
4330				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4330			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4330			 
4330					NEXTW 
4330			 
4330			.GP4: 
4330				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4330			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4330			 
4330					NEXTW 
4330			.SIN: 
4330			 
4330			 
4330			endif 
4330			 
4330			 
4330				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4330 33				db WORD_SYS_CORE+31             
4331 65 43			dw .SOUT            
4333 03				db 2 + 1 
4334 .. 00			db "IN",0              
4337				endm 
# End of macro CWHEAD
4337			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4337					if DEBUG_FORTH_WORDS_KEY 
4337						DMARK "IN." 
4337 f5				push af  
4338 3a 4c 43			ld a, (.dmark)  
433b 32 7a ee			ld (debug_mark),a  
433e 3a 4d 43			ld a, (.dmark+1)  
4341 32 7b ee			ld (debug_mark+1),a  
4344 3a 4e 43			ld a, (.dmark+2)  
4347 32 7c ee			ld (debug_mark+2),a  
434a 18 03			jr .pastdmark  
434c ..			.dmark: db "IN."  
434f f1			.pastdmark: pop af  
4350			endm  
# End of macro DMARK
4350						CALLMONITOR 
4350 cd 39 14			call break_point_state  
4353				endm  
# End of macro CALLMONITOR
4353					endif 
4353					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4353 cd bd 1b			call macro_dsp_valuehl 
4356				endm 
# End of macro FORTH_DSP_VALUEHL
4356			 
4356 e5					push hl 
4357			 
4357					; destroy value TOS 
4357			 
4357					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4357 cd 75 1c			call macro_forth_dsp_pop 
435a				endm 
# End of macro FORTH_DSP_POP
435a			 
435a					; one value on hl get other one back 
435a			 
435a c1					pop bc 
435b			 
435b					; do the sub 
435b			;		ex de, hl 
435b			 
435b ed 68				in l,(c) 
435d			 
435d					; save it 
435d			 
435d 26 00				ld h,0 
435f			 
435f					; TODO push value back onto stack for another op etc 
435f			 
435f cd c6 19				call forth_push_numhl 
4362					NEXTW 
4362 c3 2f 1d			jp macro_next 
4365				endm 
# End of macro NEXTW
4365			.SOUT: 
4365				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4365 34				db WORD_SYS_CORE+32             
4366 b8 43			dw .SPIO            
4368 04				db 3 + 1 
4369 .. 00			db "OUT",0              
436d				endm 
# End of macro CWHEAD
436d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
436d					if DEBUG_FORTH_WORDS_KEY 
436d						DMARK "OUT" 
436d f5				push af  
436e 3a 82 43			ld a, (.dmark)  
4371 32 7a ee			ld (debug_mark),a  
4374 3a 83 43			ld a, (.dmark+1)  
4377 32 7b ee			ld (debug_mark+1),a  
437a 3a 84 43			ld a, (.dmark+2)  
437d 32 7c ee			ld (debug_mark+2),a  
4380 18 03			jr .pastdmark  
4382 ..			.dmark: db "OUT"  
4385 f1			.pastdmark: pop af  
4386			endm  
# End of macro DMARK
4386						CALLMONITOR 
4386 cd 39 14			call break_point_state  
4389				endm  
# End of macro CALLMONITOR
4389					endif 
4389			 
4389					; get port 
4389			 
4389					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4389 cd bd 1b			call macro_dsp_valuehl 
438c				endm 
# End of macro FORTH_DSP_VALUEHL
438c			 
438c e5					push hl 
438d			 
438d					; destroy value TOS 
438d			 
438d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
438d cd 75 1c			call macro_forth_dsp_pop 
4390				endm 
# End of macro FORTH_DSP_POP
4390			 
4390					; get byte to send 
4390			 
4390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4390 cd bd 1b			call macro_dsp_valuehl 
4393				endm 
# End of macro FORTH_DSP_VALUEHL
4393			 
4393			;		push hl 
4393			 
4393					; destroy value TOS 
4393			 
4393					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4393 cd 75 1c			call macro_forth_dsp_pop 
4396				endm 
# End of macro FORTH_DSP_POP
4396			 
4396					; one value on hl get other one back 
4396			 
4396			;		pop hl 
4396			 
4396 c1					pop bc 
4397			 
4397					if DEBUG_FORTH_WORDS 
4397						DMARK "OUT" 
4397 f5				push af  
4398 3a ac 43			ld a, (.dmark)  
439b 32 7a ee			ld (debug_mark),a  
439e 3a ad 43			ld a, (.dmark+1)  
43a1 32 7b ee			ld (debug_mark+1),a  
43a4 3a ae 43			ld a, (.dmark+2)  
43a7 32 7c ee			ld (debug_mark+2),a  
43aa 18 03			jr .pastdmark  
43ac ..			.dmark: db "OUT"  
43af f1			.pastdmark: pop af  
43b0			endm  
# End of macro DMARK
43b0						CALLMONITOR 
43b0 cd 39 14			call break_point_state  
43b3				endm  
# End of macro CALLMONITOR
43b3					endif 
43b3			 
43b3 ed 69				out (c), l 
43b5			 
43b5					NEXTW 
43b5 c3 2f 1d			jp macro_next 
43b8				endm 
# End of macro NEXTW
43b8			 
43b8			 
43b8			.SPIO: 
43b8			 
43b8			if STORAGE_SE 
43b8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
43b8			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
43b8			 
43b8					call spi_ce_low 
43b8			    NEXTW 
43b8			 
43b8			.SPICEH: 
43b8				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
43b8			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
43b8			 
43b8					call spi_ce_high 
43b8			    NEXTW 
43b8			 
43b8			 
43b8			.SPIOb: 
43b8			 
43b8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
43b8			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
43b8			 
43b8					; get port 
43b8			 
43b8			 
43b8					; get byte to send 
43b8			 
43b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43b8			 
43b8			;		push hl    ; u1  
43b8			 
43b8					; destroy value TOS 
43b8			 
43b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b8			 
43b8					; one value on hl get other one back 
43b8			 
43b8			;		pop hl   ; u2 - addr 
43b8			 
43b8					; TODO Send SPI byte 
43b8			 
43b8					ld a, l 
43b8					call spi_send_byte 
43b8			 
43b8					NEXTW 
43b8			 
43b8			.SPII: 
43b8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
43b8			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
43b8			 
43b8					; TODO Get SPI byte 
43b8			 
43b8					call spi_read_byte 
43b8			 
43b8					ld h, 0 
43b8					ld l, a 
43b8					call forth_push_numhl 
43b8			 
43b8					NEXTW 
43b8			 
43b8			 
43b8			 
43b8			.SESEL: 
43b8				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
43b8			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
43b8					if DEBUG_FORTH_WORDS_KEY 
43b8						DMARK "BNK" 
43b8						CALLMONITOR 
43b8					endif 
43b8			 
43b8					ld a, 255 
43b8					ld (spi_cartdev), a 
43b8			 
43b8					; get bank 
43b8			 
43b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43b8			 
43b8			;		push hl 
43b8			 
43b8					; destroy value TOS 
43b8			 
43b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b8			 
43b8					; one value on hl get other one back 
43b8			 
43b8			;		pop hl 
43b8			 
43b8			 
43b8					ld c, SPI_CE_HIGH 
43b8					ld b, '0'    ; human readable bank number 
43b8			 
43b8					ld a, l 
43b8			 
43b8					if DEBUG_FORTH_WORDS 
43b8						DMARK "BNK" 
43b8						CALLMONITOR 
43b8					endif 
43b8			 
43b8					; active low 
43b8			 
43b8					cp 0 
43b8					jr z, .bset 
43b8					cp 1 
43b8					jr nz, .b2 
43b8					res 0, c 
43b8					ld b, '1'    ; human readable bank number 
43b8			.b2:		cp 2 
43b8					jr nz, .b3 
43b8					res 1, c 
43b8					ld b, '2'    ; human readable bank number 
43b8			.b3:		cp 3 
43b8					jr nz, .b4 
43b8					res 2, c 
43b8					ld b, '3'    ; human readable bank number 
43b8			.b4:		cp 4 
43b8					jr nz, .b5 
43b8					res 3, c 
43b8					ld b, '4'    ; human readable bank number 
43b8			.b5:		cp 5 
43b8					jr nz, .bset 
43b8					res 4, c 
43b8					ld b, '5'    ; human readable bank number 
43b8			 
43b8			.bset: 
43b8					ld a, c 
43b8					ld (spi_device),a 
43b8					ld a, b 
43b8					ld (spi_device_id),a 
43b8					if DEBUG_FORTH_WORDS 
43b8						DMARK "BN2" 
43b8						CALLMONITOR 
43b8					endif 
43b8			 
43b8					NEXTW 
43b8			 
43b8			.CARTDEV: 
43b8				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
43b8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
43b8					if DEBUG_FORTH_WORDS_KEY 
43b8						DMARK "CDV" 
43b8						CALLMONITOR 
43b8					endif 
43b8			 
43b8					; disable se storage bank selection 
43b8			 
43b8					ld a, SPI_CE_HIGH		; ce high 
43b8					ld (spi_device), a 
43b8			 
43b8					; get bank 
43b8			 
43b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43b8			 
43b8			;		push hl 
43b8			 
43b8					; destroy value TOS 
43b8			 
43b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b8			 
43b8					; one value on hl get other one back 
43b8			 
43b8			;		pop hl 
43b8			 
43b8					; active low 
43b8			 
43b8					ld c, 255 
43b8			 
43b8					ld a, l 
43b8					if DEBUG_FORTH_WORDS 
43b8						DMARK "CDV" 
43b8						CALLMONITOR 
43b8					endif 
43b8					cp 0 
43b8					jr z, .cset 
43b8					cp 1 
43b8					jr nz, .c2 
43b8					res 0, c 
43b8			.c2:		cp 2 
43b8					jr nz, .c3 
43b8					res 1, c 
43b8			.c3:		cp 3 
43b8					jr nz, .c4 
43b8					res 2, c 
43b8			.c4:		cp 4 
43b8					jr nz, .c5 
43b8					res 3, c 
43b8			.c5:		cp 5 
43b8					jr nz, .c6 
43b8					res 4, c 
43b8			.c6:		cp 6 
43b8					jr nz, .c7 
43b8					res 5, c 
43b8			.c7:		cp 7 
43b8					jr nz, .c8 
43b8					res 6, c 
43b8			.c8:		cp 8 
43b8					jr nz, .cset 
43b8					res 7, c 
43b8			.cset:		ld a, c 
43b8					ld (spi_cartdev),a 
43b8			 
43b8					if DEBUG_FORTH_WORDS 
43b8						DMARK "CD2" 
43b8						CALLMONITOR 
43b8					endif 
43b8					NEXTW 
43b8			endif 
43b8			 
43b8			.ENDDEVICE: 
43b8			; eof 
43b8			 
# End of file forth_words_device.asm
43b8			 
43b8			; var handler 
43b8			 
43b8			 
43b8			.VARS: 
43b8				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
43b8 78				db WORD_SYS_CORE+100             
43b9 d0 43			dw .V0Q            
43bb 04				db 3 + 1 
43bc .. 00			db "V0!",0              
43c0				endm 
# End of macro CWHEAD
43c0			;| V0! ( u1 -- )  Store value to v0  | DONE 
43c0			 
43c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c0 cd bd 1b			call macro_dsp_valuehl 
43c3				endm 
# End of macro FORTH_DSP_VALUEHL
43c3			 
43c3 11 13 eb				ld de, cli_var_array 
43c6			 
43c6 eb					ex de, hl 
43c7 73					ld (hl), e 
43c8 23					inc hl 
43c9 72					ld (hl), d 
43ca			 
43ca					; destroy value TOS 
43ca			 
43ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43ca cd 75 1c			call macro_forth_dsp_pop 
43cd				endm 
# End of macro FORTH_DSP_POP
43cd			 
43cd				       NEXTW 
43cd c3 2f 1d			jp macro_next 
43d0				endm 
# End of macro NEXTW
43d0			.V0Q: 
43d0				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
43d0 79				db WORD_SYS_CORE+101             
43d1 e1 43			dw .V1S            
43d3 04				db 3 + 1 
43d4 .. 00			db "V0@",0              
43d8				endm 
# End of macro CWHEAD
43d8			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
43d8 2a 13 eb				ld hl, (cli_var_array) 
43db cd c6 19				call forth_push_numhl 
43de			 
43de				       NEXTW 
43de c3 2f 1d			jp macro_next 
43e1				endm 
# End of macro NEXTW
43e1			.V1S: 
43e1				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
43e1 7a				db WORD_SYS_CORE+102             
43e2 f9 43			dw .V1Q            
43e4 04				db 3 + 1 
43e5 .. 00			db "V1!",0              
43e9				endm 
# End of macro CWHEAD
43e9			;| V1! ( u1 -- )  Store value to v1 | DONE 
43e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43e9 cd bd 1b			call macro_dsp_valuehl 
43ec				endm 
# End of macro FORTH_DSP_VALUEHL
43ec			 
43ec 11 15 eb				ld de, cli_var_array+2 
43ef				 
43ef eb					ex de, hl 
43f0 73					ld (hl), e 
43f1 23					inc hl 
43f2 72					ld (hl), d 
43f3			 
43f3					; destroy value TOS 
43f3			 
43f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43f3 cd 75 1c			call macro_forth_dsp_pop 
43f6				endm 
# End of macro FORTH_DSP_POP
43f6				       NEXTW 
43f6 c3 2f 1d			jp macro_next 
43f9				endm 
# End of macro NEXTW
43f9			.V1Q: 
43f9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
43f9 7b				db WORD_SYS_CORE+103             
43fa 0a 44			dw .V2S            
43fc 04				db 3 + 1 
43fd .. 00			db "V1@",0              
4401				endm 
# End of macro CWHEAD
4401			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4401 2a 15 eb				ld hl, (cli_var_array+2) 
4404 cd c6 19				call forth_push_numhl 
4407				       NEXTW 
4407 c3 2f 1d			jp macro_next 
440a				endm 
# End of macro NEXTW
440a			.V2S: 
440a				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
440a 7c				db WORD_SYS_CORE+104             
440b 22 44			dw .V2Q            
440d 04				db 3 + 1 
440e .. 00			db "V2!",0              
4412				endm 
# End of macro CWHEAD
4412			;| V2! ( u1 -- )  Store value to v2 | DONE 
4412					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4412 cd bd 1b			call macro_dsp_valuehl 
4415				endm 
# End of macro FORTH_DSP_VALUEHL
4415			 
4415 11 17 eb				ld de, cli_var_array+4 
4418				 
4418 eb					ex de, hl 
4419 73					ld (hl), e 
441a 23					inc hl 
441b 72					ld (hl), d 
441c			 
441c					; destroy value TOS 
441c			 
441c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
441c cd 75 1c			call macro_forth_dsp_pop 
441f				endm 
# End of macro FORTH_DSP_POP
441f				       NEXTW 
441f c3 2f 1d			jp macro_next 
4422				endm 
# End of macro NEXTW
4422			.V2Q: 
4422				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4422 7d				db WORD_SYS_CORE+105             
4423 33 44			dw .V3S            
4425 04				db 3 + 1 
4426 .. 00			db "V2@",0              
442a				endm 
# End of macro CWHEAD
442a			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
442a 2a 17 eb				ld hl, (cli_var_array+4) 
442d cd c6 19				call forth_push_numhl 
4430				       NEXTW 
4430 c3 2f 1d			jp macro_next 
4433				endm 
# End of macro NEXTW
4433			.V3S: 
4433				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4433 7c				db WORD_SYS_CORE+104             
4434 4b 44			dw .V3Q            
4436 04				db 3 + 1 
4437 .. 00			db "V3!",0              
443b				endm 
# End of macro CWHEAD
443b			;| V3! ( u1 -- )  Store value to v3 | DONE 
443b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
443b cd bd 1b			call macro_dsp_valuehl 
443e				endm 
# End of macro FORTH_DSP_VALUEHL
443e			 
443e 11 19 eb				ld de, cli_var_array+6 
4441				 
4441 eb					ex de, hl 
4442 73					ld (hl), e 
4443 23					inc hl 
4444 72					ld (hl), d 
4445			 
4445					; destroy value TOS 
4445			 
4445					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4445 cd 75 1c			call macro_forth_dsp_pop 
4448				endm 
# End of macro FORTH_DSP_POP
4448				       NEXTW 
4448 c3 2f 1d			jp macro_next 
444b				endm 
# End of macro NEXTW
444b			.V3Q: 
444b				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
444b 7d				db WORD_SYS_CORE+105             
444c 5c 44			dw .END            
444e 04				db 3 + 1 
444f .. 00			db "V3@",0              
4453				endm 
# End of macro CWHEAD
4453			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4453 2a 19 eb				ld hl, (cli_var_array+6) 
4456 cd c6 19				call forth_push_numhl 
4459				       NEXTW 
4459 c3 2f 1d			jp macro_next 
445c				endm 
# End of macro NEXTW
445c			 
445c			 
445c			 
445c			 
445c			 
445c			; end of dict marker 
445c			 
445c 00			.END:    db WORD_SYS_END 
445d 00 00			dw 0 
445f 00				db 0 
4460			 
4460			; use to jp here for user dict words to save on macro expansion  
4460			 
4460			user_dict_next: 
4460				NEXTW 
4460 c3 2f 1d			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			 
4463			 
4463			user_exec: 
4463				;    ld hl, <word code> 
4463				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4463				;    call forthexec 
4463				;    jp user_dict_next   (NEXT) 
4463			        ;    <word code bytes> 
4463 eb				ex de, hl 
4464 2a 61 e6			ld hl,(os_tok_ptr) 
4467				 
4467				FORTH_RSP_NEXT 
4467 cd 6d 19			call macro_forth_rsp_next 
446a				endm 
# End of macro FORTH_RSP_NEXT
446a			 
446a			if DEBUG_FORTH_UWORD 
446a						DMARK "UEX" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 7a ee			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 7b ee			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 7c ee			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "UEX"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483				CALLMONITOR 
4483 cd 39 14			call break_point_state  
4486				endm  
# End of macro CALLMONITOR
4486			endif 
4486			 
4486			 
4486			 
4486 eb				ex de, hl 
4487 22 61 e6			ld (os_tok_ptr), hl 
448a				 
448a				; Don't use next - Skips the first word in uword. 
448a			 
448a c3 c0 1d			jp exec1 
448d			;	NEXT 
448d			 
448d			 
448d			; eof 
# End of file forth_wordsv4.asm
448d			endif 
448d			;;;;;;;;;;;;;; Debug code 
448d			 
448d			 
448d			;if DEBUG_FORTH_PARSE 
448d .. 00		.nowordfound: db "No match",0 
4496 .. 00		.compword:	db "Comparing word ",0 
44a6 .. 00		.nextwordat:	db "Next word at",0 
44b3 .. 00		.charmatch:	db "Char match",0 
44be			;endif 
44be			if DEBUG_FORTH_JP 
44be			.foundword:	db "Word match. Exec..",0 
44be			endif 
44be			;if DEBUG_FORTH_PUSH 
44be .. 00		.enddict:	db "Dict end. Push.",0 
44ce .. 00		.push_str:	db "Pushing string",0 
44dd .. 00		.push_num:	db "Pushing number",0 
44ec .. 00		.data_sp:	db "SP:",0 
44f0 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4502 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4514 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4526			;endif 
4526			;if DEBUG_FORTH_MALLOC 
4526 .. 00		.push_malloc:	db "Malloc address",0 
4535			;endif 
4535			 
4535			 
4535			 
4535			; display malloc address and current data stack pointer  
4535			 
4535			malloc_error: 
4535 d5				push de 
4536 f5				push af 
4537 e5				push hl 
4538 cd 99 09			call clear_display 
453b 11 5d 45			ld de, .mallocerr 
453e 3e 00			ld a,0 
4540			;	ld de,os_word_scratch 
4540 cd ac 09			call str_at_display 
4543 3e 11			ld a, display_row_1+17 
4545 11 7a ee			ld de, debug_mark 
4548 cd ac 09			call str_at_display 
454b cd bc 09			call update_display 
454e				;call break_point_state 
454e cd b7 58			call cin_wait 
4551			 
4551 3e 20			ld a, ' ' 
4553 32 51 e3			ld (os_view_disable), a 
4556 e1				pop hl 
4557 f1				pop af 
4558 d1				pop de	 
4559				CALLMONITOR 
4559 cd 39 14			call break_point_state  
455c				endm  
# End of macro CALLMONITOR
455c c9				ret 
455d			 
455d .. 00		.mallocerr: 	db "Malloc Error",0 
456a			;if DEBUG_FORTH_PUSH 
456a			display_data_sp: 
456a f5				push af 
456b			 
456b				; see if disabled 
456b			 
456b 3a 51 e3			ld a, (os_view_disable) 
456e fe 2a			cp '*' 
4570 28 67			jr z, .skipdsp 
4572			 
4572 e5				push hl 
4573 e5				push hl 
4574 e5			push hl 
4575 cd 99 09			call clear_display 
4578 e1			pop hl 
4579 7c				ld a,h 
457a 21 65 e6			ld hl, os_word_scratch 
457d cd c7 0e			call hexout 
4580 e1				pop hl 
4581 7d				ld a,l 
4582 21 67 e6			ld hl, os_word_scratch+2 
4585 cd c7 0e			call hexout 
4588 21 69 e6			ld hl, os_word_scratch+4 
458b 3e 00			ld a,0 
458d 77				ld (hl),a 
458e 11 65 e6			ld de,os_word_scratch 
4591 3e 28				ld a, display_row_2 
4593 cd ac 09				call str_at_display 
4596 11 f0 44			ld de, .wordinhl 
4599 3e 00			ld a, display_row_1 
459b			 
459b cd ac 09				call str_at_display 
459e 11 7a ee			ld de, debug_mark 
45a1 3e 11			ld a, display_row_1+17 
45a3			 
45a3 cd ac 09				call str_at_display 
45a6			 
45a6				; display current data stack pointer 
45a6 11 ec 44			ld de,.data_sp 
45a9 3e 30				ld a, display_row_2 + 8 
45ab cd ac 09				call str_at_display 
45ae			 
45ae 2a 0d eb			ld hl,(cli_data_sp) 
45b1 e5				push hl 
45b2 7c				ld a,h 
45b3 21 65 e6			ld hl, os_word_scratch 
45b6 cd c7 0e			call hexout 
45b9 e1				pop hl 
45ba 7d				ld a,l 
45bb 21 67 e6			ld hl, os_word_scratch+2 
45be cd c7 0e			call hexout 
45c1 21 69 e6			ld hl, os_word_scratch+4 
45c4 3e 00			ld a,0 
45c6 77				ld (hl),a 
45c7 11 65 e6			ld de,os_word_scratch 
45ca 3e 33				ld a, display_row_2 + 11 
45cc cd ac 09				call str_at_display 
45cf			 
45cf			 
45cf cd bc 09			call update_display 
45d2 cd 0e 09			call delay1s 
45d5 cd 0e 09			call delay1s 
45d8 e1				pop hl 
45d9			.skipdsp: 
45d9 f1				pop af 
45da c9				ret 
45db			 
45db			display_data_malloc: 
45db			 
45db f5				push af 
45dc e5				push hl 
45dd e5				push hl 
45de e5			push hl 
45df cd 99 09			call clear_display 
45e2 e1			pop hl 
45e3 7c				ld a,h 
45e4 21 65 e6			ld hl, os_word_scratch 
45e7 cd c7 0e			call hexout 
45ea e1				pop hl 
45eb 7d				ld a,l 
45ec 21 67 e6			ld hl, os_word_scratch+2 
45ef cd c7 0e			call hexout 
45f2 21 69 e6			ld hl, os_word_scratch+4 
45f5 3e 00			ld a,0 
45f7 77				ld (hl),a 
45f8 11 65 e6			ld de,os_word_scratch 
45fb 3e 28				ld a, display_row_2 
45fd cd ac 09				call str_at_display 
4600 11 26 45			ld de, .push_malloc 
4603 3e 00			ld a, display_row_1 
4605			 
4605 cd ac 09				call str_at_display 
4608			 
4608				; display current data stack pointer 
4608 11 ec 44			ld de,.data_sp 
460b 3e 30				ld a, display_row_2 + 8 
460d cd ac 09				call str_at_display 
4610			 
4610 2a 0d eb			ld hl,(cli_data_sp) 
4613 e5				push hl 
4614 7c				ld a,h 
4615 21 65 e6			ld hl, os_word_scratch 
4618 cd c7 0e			call hexout 
461b e1				pop hl 
461c 7d				ld a,l 
461d 21 67 e6			ld hl, os_word_scratch+2 
4620 cd c7 0e			call hexout 
4623 21 69 e6			ld hl, os_word_scratch+4 
4626 3e 00			ld a,0 
4628 77				ld (hl),a 
4629 11 65 e6			ld de,os_word_scratch 
462c 3e 33				ld a, display_row_2 + 11 
462e cd ac 09				call str_at_display 
4631			 
4631 cd bc 09			call update_display 
4634 cd 0e 09			call delay1s 
4637 cd 0e 09			call delay1s 
463a e1				pop hl 
463b f1				pop af 
463c c9				ret 
463d			;endif 
463d			 
463d			include "forth_autostart.asm" 
463d			; list of commands to perform at system start up 
463d			 
463d			startcmds: 
463d			;	dw test11 
463d			;	dw test12 
463d			;	dw test13 
463d			;	dw test14 
463d			;	dw test15 
463d			;	dw test16 
463d			;	dw test17 
463d			;	dw ifthtest1 
463d			;	dw ifthtest2 
463d			;	dw ifthtest3 
463d			;	dw mmtest1 
463d			;	dw mmtest2 
463d			;	dw mmtest3 
463d			;	dw mmtest4 
463d			;	dw mmtest5 
463d			;	dw mmtest6 
463d			;	dw iftest1 
463d			;	dw iftest2 
463d			;	dw iftest3 
463d			;	dw looptest1 
463d			;	dw looptest2 
463d			;	dw test1 
463d			;	dw test2 
463d			;	dw test3 
463d			;	dw test4 
463d			;	dw game2r 
463d			;	dw game2b1 
463d			;	dw game2b2 
463d			 
463d				; start up words that are actually useful 
463d			 
463d 9b 46			dw clrstack 
463f ce 46			dw type 
4641 8f 48			dw stest 
4643 f2 46			dw strncpy 
4645 30 48			dw list 
4647 53 47			dw start1 
4649 65 47			dw start2 
464b			;	dw start3 
464b 78 47			dw start3b 
464d d0 47			dw start3c 
464f			 
464f				; (unit) testing words 
464f			 
464f 06 49			dw mtesta 
4651 bb 49			dw mtestb 
4653 5e 4a			dw mtestc 
4655 13 4b			dw mtestd 
4657 b7 4b			dw mteste 
4659			 
4659				; demo/game words 
4659			 
4659 c3 52		        dw game3w 
465b f1 52		        dw game3p 
465d 0f 53		        dw game3sc 
465f 40 53		        dw game3vsi 
4661 6c 53		        dw game3vs 
4663				 
4663 b6 50			dw game2b 
4665 24 51			dw game2bf 
4667 6e 51			dw game2mba 
4669 04 52			dw game2mbas 
466b 46 52			dw game2mb 
466d			 
466d 77 4d			dw game1 
466f 88 4d			dw game1a 
4671 ea 4d			dw game1b 
4673 1f 4e			dw game1c 
4675 55 4e			dw game1d 
4677 86 4e			dw game1s 
4679 9a 4e			dw game1t 
467b af 4e			dw game1f 
467d e3 4e			dw game1z 
467f 27 4f			dw game1zz 
4681			 
4681 6d 4c			dw test5 
4683 a5 4c			dw test6 
4685 dd 4c			dw test7 
4687 f1 4c			dw test8 
4689 1d 4d			dw test9 
468b 33 4d			dw test10 
468d				 
468d fe 4f		        dw ssv5 
468f e2 4f		        dw ssv4 
4691 c6 4f		        dw ssv3 
4693 90 4f		        dw ssv2 
4695 17 50		        dw ssv1 
4697 5f 50		        dw ssv1cpm 
4699			;	dw keyup 
4699			;	dw keydown 
4699			;	dw keyleft 
4699			;	dw keyright 
4699			;	dw 	keyf1 
4699			;	dw keyf2 
4699			;	dw keyf3 
4699			;	dw keyf4 
4699			;	dw keyf5 
4699			;	dw keyf6 
4699			;	dw keyf7 
4699			;	dw keyf8 
4699			;	dw keyf9 
4699			;	dw keyf10 
4699			;	dw keyf11 
4699			;	dw keyf12 
4699			;	dw keytab 
4699			;	dw keycr 
4699			;	dw keyhome 
4699			;	dw keyend 
4699			;	dw keybs 
4699 00 00			db 0, 0	 
469b			 
469b			 
469b			; clear stack  
469b			 
469b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
46ce			 
46ce			; type ( addr count - ) 
46ce .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
46f2			 
46f2			; some direct memory words 
46f2			; strncpy ( len t f -- t ) 
46f2			 
46f2 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4753			 
4753 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4765 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4778			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4778 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
47d0 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4830			 
4830			 
4830			; a handy word to list items on the stack 
4830			 
4830 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
488f			 
488f			 
488f			; test stack  
488f			; rnd8 stest 
488f			 
488f .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4906			 
4906			; random malloc and free cycles 
4906			 
4906 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
49bb			 
49bb			; fixed malloc and free cycles 
49bb			 
49bb .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a5e			 
4a5e			; fixed double string push and drop cycle  
4a5e			 
4a5e .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4b13			 
4b13			; consistent fixed string push and drop cycle  
4b13			 
4b13 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4bb7			 
4bb7 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c6d			 
4c6d			;test1:		db ": aa 1 2 3 ;", 0 
4c6d			;test2:     	db "111 aa 888 999",0 
4c6d			;test3:     	db ": bb 77 ;",0 
4c6d			;test4:     	db "$02 $01 do i . loop bb",0 
4c6d			 
4c6d .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4ca5 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4cdd .. 00		test7:     	db ": box hline vline ;",0 
4cf1 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4d1d .. 00		test9:     	db ": sw $01 adsp world ;",0 
4d33 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4d58 .. 00		test11:     	db "hello create .",0 
4d67 .. 00		test12:     	db "hello2 create .",0 
4d77			 
4d77			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4d77			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4d77			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4d77			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4d77			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4d77			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4d77			 
4d77			;iftest1:     	db "$0001 IF cls .",0 
4d77			;iftest2:     	db "$0000 IF cls .",0 
4d77			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4d77			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4d77			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4d77			 
4d77			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d77			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d77			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d77			 
4d77			 
4d77			 
4d77			; a small guess the number game 
4d77			 
4d77 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4d88 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4dea			 
4dea .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4e1f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4e55 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4e86 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4e9a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4eaf .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4ee3 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4f27			 
4f27			; Using 'ga' save a high score across multiple runs using external storage 
4f27			 
4f27 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4f90			 
4f90			 
4f90			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4f90			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f90			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f90			 
4f90			; simple screen saver to test code memory reuse to destruction 
4f90			 
4f90 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4fc6 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4fe2 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4ffe .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5017 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
505f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
50b6			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
50b6			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
50b6			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
50b6			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
50b6			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
50b6			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
50b6			 
50b6			 
50b6			 
50b6			; minesweeper/battleship finding game 
50b6			; draws a game board of random ship/mine positions 
50b6			; user enters coords to see if it hits on 
50b6			; game ends when all are hit 
50b6			; when hit or miss says how many may be in the area 
50b6			 
50b6			; setup the game board and then hide it 
50b6 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5124 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
516e			; prompt for where to target 
516e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5204 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5229			; TODO see if the entered coords hits or misses pushes char hit of miss 
5229 .. 00		game2mbht:      db ": mbckht nop ;",0 
5238 .. 00		game2mbms:      db ": mbcms nop ;",0 
5246			; TODO how many might be near by 
5246 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
52c3			 
52c3			; Game 3 
52c3			 
52c3			; Vert scroller ski game - avoid the trees! 
52c3			 
52c3			; v0 score (ie turns) 
52c3			; v1 player pos 
52c3			; v2 left wall 
52c3			; v3 right wall 
52c3			 
52c3			; Draw side walls randomly 
52c3			 
52c3 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
52f1			 
52f1			; Draw player 
52f1 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
530f			 
530f			; TODO Get Key 
530f			 
530f			; TODO Move left right 
530f			 
530f			; scroll and move walls a bit 
530f			 
530f .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5340			 
5340			; main game loop 
5340			 
5340 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
536c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
53ab			 
53ab			; key board defs 
53ab			 
53ab .. 00		keyup:       db ": keyup $05 ;",0 
53b9 .. 00		keydown:       db ": keydown $0a ;",0 
53c9 .. 00		keyleft:       db ": keyleft $0b ;",0 
53d9 .. 00		keyright:       db ": keyright $0c ;",0 
53ea .. 00		keyf1:       db ": keyf1 $10 ;",0 
53f8 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5406 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5414 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5422 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5430 .. 00		keyf6:       db ": keyf6 $15 ;",0 
543e .. 00		keyf7:       db ": keyf7 $16 ;",0 
544c .. 00		keyf8:       db ": keyf8 $17 ;",0 
545a .. 00		keyf9:       db ": keyf9 $18 ;",0 
5468 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5477 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5486 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5495			 
5495 .. 00		keytab:       db ": keytab $09 ;",0 
54a4 .. 00		keycr:       db ": keycr $0d ;",0 
54b2 .. 00		keyhome:       db ": keyhome $0e ;",0 
54c2 .. 00		keyend:       db ": keyend $0f ;",0 
54d1 .. 00		keybs:       db ": keybs $08 ;",0 
54df			 
54df			   
54df			 
54df			 
54df			 
54df			; eof 
# End of file forth_autostart.asm
54df			 
54df .. 00		sprompt1: db "Startup load...",0 
54ef .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5505			 
5505			 
5505			 
5505			 
5505			forth_startup: 
5505 21 3d 46			ld hl, startcmds 
5508 3e 00			ld a, 0 
550a 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
550d			 
550d e5			.start1:	push hl 
550e cd 99 09			call clear_display 
5511 11 df 54			ld de, sprompt1 
5514 3e 00		        ld a, display_row_1 
5516 cd ac 09			call str_at_display 
5519 11 ef 54			ld de, sprompt2 
551c 3e 28		        ld a, display_row_2 
551e cd ac 09			call str_at_display 
5521 e1				pop hl 
5522 e5				push hl 
5523 5e				ld e,(hl) 
5524 23				inc hl 
5525 56				ld d,(hl) 
5526 3e 50		        ld a, display_row_3 
5528 cd ac 09			call str_at_display 
552b cd bc 09			call update_display 
552e			 
552e			 
552e 3a 86 e7			ld a, (os_last_cmd) 
5531 fe 00			cp 0 
5533 28 05			jr z, .startprompt 
5535 cd 02 09			call delay250ms 
5538 18 24			jr .startdo 
553a				 
553a				 
553a			 
553a			.startprompt: 
553a			 
553a 3e 9f			ld a,display_row_4 + display_cols - 1 
553c 11 3c 19		        ld de, endprg 
553f cd ac 09			call str_at_display 
5542 cd bc 09			call update_display 
5545 cd 0e 09			call delay1s 
5548 cd b7 58			call cin_wait 
554b						 
554b fe 2a			cp '*' 
554d 28 5e			jr z, .startupend1 
554f fe 23			cp '#' 
5551 20 07			jr nz, .startno 
5553 3e 01			ld a, 1 
5555 32 86 e7			ld (os_last_cmd),a 
5558 18 04			jr .startdo 
555a fe 31		.startno:	cp '1' 
555c 28 3a			jr z,.startnxt  
555e			 
555e				; exec startup line 
555e			.startdo:	 
555e e1				pop hl 
555f e5				push hl 
5560				 
5560 5e				ld e,(hl) 
5561 23				inc hl 
5562 56				ld d,(hl) 
5563 eb				ex de,hl 
5564			 
5564 e5				push hl 
5565			 
5565 3e 00			ld a, 0 
5567				;ld a, FORTH_END_BUFFER 
5567 cd 2f 10			call strlent 
556a 23				inc hl   ; include zero term to copy 
556b 06 00			ld b,0 
556d 4d				ld c,l 
556e e1				pop hl 
556f 11 60 e3			ld de, scratch 
5572 ed b0			ldir 
5574			 
5574			 
5574 21 60 e3			ld hl, scratch 
5577 cd 7d 1d			call forthparse 
557a cd bd 1d			call forthexec 
557d cd d4 1c			call forthexec_cleanup 
5580			 
5580 3e 78			ld a, display_row_4 
5582 11 e0 16			ld de, endprog 
5585			 
5585 cd bc 09			call update_display		 
5588			 
5588 3a 86 e7			ld a, (os_last_cmd) 
558b fe 00			cp 0 
558d 20 09			jr nz, .startnxt 
558f cd 3e 19			call next_page_prompt 
5592 cd 99 09		        call clear_display 
5595 cd bc 09			call update_display		 
5598			 
5598				; move onto next startup line? 
5598			.startnxt: 
5598			 
5598 cd 02 09			call delay250ms 
559b e1				pop hl 
559c			 
559c 23				inc hl 
559d 23				inc hl 
559e			 
559e e5				push hl 
559f 5e				ld e, (hl) 
55a0 23				inc hl 
55a1 56				ld d, (hl) 
55a2 e1				pop hl 
55a3				; TODO replace 0 test 
55a3			 
55a3 eb				ex de, hl 
55a4 cd ef 0b			call ishlzero 
55a7			;	ld a,e 
55a7			;	add d 
55a7			;	cp 0    ; any left to do? 
55a7 eb				ex de, hl 
55a8 c2 0d 55			jp nz, .start1 
55ab 18 01			jr .startupend 
55ad			 
55ad e1			.startupend1: pop hl 
55ae			.startupend: 
55ae			 
55ae cd 99 09			call clear_display 
55b1 cd bc 09			call update_display 
55b4 c9				ret 
55b5			 
55b5			 
55b5			; stack over and underflow checks 
55b5			 
55b5			; init the words to detect the under/overflow 
55b5			 
55b5			chk_stk_init: 
55b5				; a vague random number to check so we dont get any "lucky" hits 
55b5 3e 2d			ld a, 45 
55b7 6f				ld l, a 
55b8 00				nop 
55b9 3e 17			ld a, 23 
55bb 67				ld h, a 
55bc			 
55bc 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
55bf			 
55bf			;	ld (chk_stund), hl	; stack points.... 
55bf 22 00 ef			ld (chk_stovr), hl 
55c2 22 0b eb			ld (chk_ret_und), hl 
55c5 22 c9 ea			ld (chk_ret_ovr), hl 
55c8 22 c7 e9			ld (chk_loop_ovr), hl 
55cb 22 c5 e8			ld (chk_data_ovr), hl 
55ce c9				ret 
55cf				 
55cf			check_stacks: 
55cf				; check all stack words 
55cf			 
55cf e5				push hl 
55d0 d5				push de 
55d1			 
55d1			;	ld de,(chk_word) 
55d1			;	ld hl, (chk_stund)	; stack points.... 
55d1			;	if DEBUG_STK_FAULT 
55d1			;		DMARK "FAa" 
55d1			;		CALLMONITOR 
55d1			;	endif 
55d1			;	call cmp16 
55d1			;	jp z, .chk_faulta 
55d1			; 
55d1			;	ld de, sfaultsu 
55d1			;	jp .chk_fault 
55d1			 
55d1 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
55d4 ed 5b 47 e3		ld de,(chk_word) 
55d8				if DEBUG_STK_FAULT 
55d8					DMARK "FAb" 
55d8					CALLMONITOR 
55d8				endif 
55d8 cd e4 0b			call cmp16 
55db 28 06			jr z, .chk_fault1 
55dd 11 7e 56			ld de, sfaultso 
55e0 c3 32 56			jp .chk_fault 
55e3			.chk_fault1:  
55e3 2a 0b eb			ld hl, (chk_ret_und) 
55e6 ed 5b 47 e3		ld de,(chk_word) 
55ea				if DEBUG_STK_FAULT 
55ea					DMARK "FAU" 
55ea					CALLMONITOR 
55ea				endif 
55ea cd e4 0b			call cmp16 
55ed ca f6 55			jp z, .chk_fault2 
55f0 11 8e 56			ld de, sfaultru 
55f3 c3 32 56			jp .chk_fault 
55f6			.chk_fault2:  
55f6 2a c9 ea			ld hl, (chk_ret_ovr) 
55f9 ed 5b 47 e3		ld de,(chk_word) 
55fd				if DEBUG_STK_FAULT 
55fd					DMARK "FA1" 
55fd					CALLMONITOR 
55fd				endif 
55fd cd e4 0b			call cmp16 
5600 ca 09 56			jp z, .chk_fault3 
5603 11 9c 56			ld de, sfaultro 
5606 c3 32 56			jp .chk_fault 
5609			.chk_fault3:  
5609 2a c7 e9			ld hl, (chk_loop_ovr) 
560c ed 5b 47 e3		ld de,(chk_word) 
5610				if DEBUG_STK_FAULT 
5610					DMARK "FA2" 
5610					CALLMONITOR 
5610				endif 
5610 cd e4 0b			call cmp16 
5613 ca 1c 56			jp z, .chk_fault4 
5616 11 b6 56			ld de, sfaultlo 
5619 c3 32 56			jp .chk_fault 
561c			.chk_fault4:  
561c 2a c5 e8			ld hl, (chk_data_ovr) 
561f ed 5b 47 e3		ld de,(chk_word) 
5623				if DEBUG_STK_FAULT 
5623					DMARK "FA3" 
5623					CALLMONITOR 
5623				endif 
5623 cd e4 0b			call cmp16 
5626 ca 2f 56			jp z, .chk_fault5 
5629 11 d0 56			ld de, sfaultdo 
562c c3 32 56			jp .chk_fault 
562f			 
562f			 
562f			.chk_fault5:  
562f d1				pop de 
5630 e1				pop hl 
5631			 
5631 c9				ret 
5632			 
5632 cd 99 09		.chk_fault: 	call clear_display 
5635 3e 28				ld a, display_row_2 
5637 cd ac 09				call str_at_display 
563a 11 60 56				   ld de, .stackfault 
563d 3e 00				ld a, display_row_1 
563f cd ac 09				call str_at_display 
5642 11 7a ee				    ld de, debug_mark 
5645 3e 11				ld a, display_row_1+17 
5647 cd ac 09				call str_at_display 
564a cd bc 09				call update_display 
564d			 
564d				; prompt before entering montior for investigating issue 
564d			 
564d 3e 78			ld a, display_row_4 
564f 11 e0 16			ld de, endprog 
5652			 
5652 cd bc 09			call update_display		 
5655			 
5655 cd 3e 19			call next_page_prompt 
5658			 
5658 d1				pop de 
5659 e1				pop hl 
565a cd 34 17				call monitor 
565d c3 2e 16				jp warmstart 
5660					;jp 0 
5660					;halt 
5660			 
5660			 
5660			 
5660 .. 00		.stackfault: 	db "Stack fault:",0 
566d			 
566d .. 00		sfaultsu: 	db	"Stack under flow",0 
567e .. 00		sfaultso: 	db	"Stack over flow",0 
568e .. 00		sfaultru:	db "RTS underflow",0 
569c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
56b6 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
56d0 .. 00		sfaultdo:	db "DTS overflow", 0 
56dd			 
56dd			 
56dd			fault_dsp_under: 
56dd 11 ef 56			ld de, .dsp_under 
56e0 c3 9f 57			jp .show_fault 
56e3			 
56e3			fault_rsp_under: 
56e3 11 fd 56			ld de, .rsp_under 
56e6 c3 9f 57			jp .show_fault 
56e9			fault_loop_under: 
56e9 11 0b 57			ld de, .loop_under 
56ec c3 9f 57			jp .show_fault 
56ef			 
56ef .. 00		.dsp_under: db "DSP Underflow",0 
56fd .. 00		.rsp_under: db "RSP Underflow",0 
570b .. 00		.loop_under: db "LOOP Underflow",0 
571a			 
571a			 
571a d5			type_faultn: 	push de 
571b e5					push hl 
571c cd 99 09				call clear_display 
571f 11 46 57				   ld de, .typefaultn 
5722 3e 00				ld a, display_row_1 
5724 cd ac 09				call str_at_display 
5727 11 7a ee				    ld de, debug_mark 
572a 3e 11				ld a, display_row_1+17 
572c cd ac 09				call str_at_display 
572f cd bc 09				call update_display 
5732			 
5732				; prompt before entering montior for investigating issue 
5732			 
5732 3e 78			ld a, display_row_4 
5734 11 e0 16			ld de, endprog 
5737			 
5737 cd bc 09			call update_display		 
573a			 
573a cd 3e 19			call next_page_prompt 
573d			 
573d e5					push hl 
573e d5					push de 
573f cd 34 17				call monitor 
5742 c3 2e 16				jp warmstart 
5745 76					halt 
5746			 
5746			 
5746 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
575d			 
575d d5			type_faults: 	push de 
575e e5					push hl 
575f cd 99 09				call clear_display 
5762 11 88 57				   ld de, .typefaults 
5765 3e 00				ld a, display_row_1 
5767 cd ac 09				call str_at_display 
576a 11 7a ee				    ld de, debug_mark 
576d 3e 11				ld a, display_row_1+17 
576f cd ac 09				call str_at_display 
5772 cd bc 09				call update_display 
5775			 
5775				; prompt before entering montior for investigating issue 
5775			 
5775 3e 78			ld a, display_row_4 
5777 11 e0 16			ld de, endprog 
577a			 
577a cd bc 09			call update_display		 
577d			 
577d cd 3e 19			call next_page_prompt 
5780			 
5780 e1					pop hl 
5781 d1					pop de 
5782 cd 34 17				call monitor 
5785 c3 2e 16				jp warmstart 
5788			 
5788			 
5788 .. 00		.typefaults: db "STR Type Expected TOS!",0 
579f			 
579f			.show_fault: 	 
579f d5					push de 
57a0 cd 99 09				call clear_display 
57a3 d1					pop de 
57a4 3e 00				ld a, display_row_1 
57a6 cd ac 09				call str_at_display 
57a9 11 7a ee				    ld de, debug_mark 
57ac 3e 11				ld a, display_row_1+17 
57ae cd ac 09				call str_at_display 
57b1 cd bc 09				call update_display 
57b4			 
57b4				; prompt before entering montior for investigating issue 
57b4			 
57b4 3e 78			ld a, display_row_4 
57b6 11 e0 16			ld de, endprog 
57b9			 
57b9 cd bc 09			call update_display		 
57bc			 
57bc cd 3e 19			call next_page_prompt 
57bf			 
57bf e1					pop hl 
57c0 d1					pop de 
57c1 cd 34 17				call monitor 
57c4			; do a dump to cli and not warmstart so we preserve all of the uwords.  
57c4			; TODO Make optional fault restart to cli or warm boot? 
57c4					;jp warmstart 
57c4 c3 86 16				jp cli 
57c7 76					halt 
57c8			 
57c8			; handle the auto run of code from files in storage 
57c8			 
57c8			 
57c8			if STORAGE_SE 
57c8			 
57c8			sprompt3: db "Loading from start-up file?:",0 
57c8			sprompt4: db "(Y=Any key/N=No)",0 
57c8			 
57c8			 
57c8			forth_autoload: 
57c8			 
57c8				; load block 0 of store 1 
57c8				 
57c8				ld a, $fe      ; bit 0 clear 
57c8				ld (spi_device), a 
57c8			 
57c8				call storage_get_block_0 
57c8			 
57c8				ld a, (store_page+STORE_0_AUTOFILE) 
57c8			 
57c8				cp 0 
57c8				ret z     ; auto start not enabled 
57c8			 
57c8				call clear_display 
57c8			 
57c8				; set bank 
57c8			 
57c8					ld a, (store_page+STORE_0_BANKRUN) 
57c8					ld (spi_device), a 
57c8			 
57c8				; get file id to load from and get the file name to display 
57c8			 
57c8					ld a, (store_page+STORE_0_FILERUN) 
57c8			 
57c8					ld l, 0 
57c8					ld h, a 
57c8					ld de, store_page 
57c8			 
57c8					if DEBUG_FORTH_WORDS 
57c8						DMARK "ASp" 
57c8						CALLMONITOR 
57c8					endif 
57c8					call storage_read 
57c8			 
57c8					if DEBUG_FORTH_WORDS 
57c8						DMARK "ASr" 
57c8						CALLMONITOR 
57c8					endif 
57c8			 
57c8					call ishlzero 
57c8					ret z             ; file not found 
57c8			 
57c8					ld a, display_row_2 + 10 
57c8					ld de, store_page+3 
57c8					call str_at_display 
57c8				 
57c8			; 
57c8			 
57c8				ld a, display_row_1+5 
57c8				ld de, sprompt3 
57c8				call str_at_display 
57c8				ld a, display_row_3+15 
57c8				ld de, sprompt4 
57c8				call str_at_display 
57c8			 
57c8				call update_display 
57c8			 
57c8				call cin_wait 
57c8				cp 'n' 
57c8				ret z 
57c8				cp 'N' 
57c8				ret z 
57c8			 
57c8				call delay1s 
57c8			 
57c8				ld a, (store_page+2) 
57c8				ld (store_openmaxext), a    ; save count of ext 
57c8				ld a, 1  
57c8				ld (store_openext), a    ; save count of ext 
57c8			 
57c8			.autof:  
57c8				ld l , a 
57c8				 
57c8				ld a, (store_page) 
57c8				ld h, a	 
57c8				ld de, store_page 
57c8					if DEBUG_FORTH_WORDS 
57c8						DMARK "ASl" 
57c8						CALLMONITOR 
57c8					endif 
57c8					call storage_read 
57c8				call ishlzero 
57c8				ret z 
57c8			;	jr z, .autoend 
57c8			 
57c8					if DEBUG_FORTH_WORDS 
57c8						DMARK "ASc" 
57c8						CALLMONITOR 
57c8					endif 
57c8				ld de, store_page+2 
57c8				ld a, display_row_4 
57c8				call str_at_display 
57c8			 
57c8				call update_display 
57c8				call delay250ms 
57c8			 
57c8			 
57c8			 
57c8				ld hl, store_page+2 
57c8				call forthparse 
57c8				call forthexec 
57c8				call forthexec_cleanup 
57c8			 
57c8				 
57c8				ld a, (store_openext) 
57c8				inc a 
57c8				ld (store_openext), a    ; save count of ext 
57c8			 
57c8				jr .autof 
57c8			;.autofdone: 
57c8			; 
57c8			;		if DEBUG_FORTH_WORDS 
57c8			;			DMARK "ASx" 
57c8			;			CALLMONITOR 
57c8			;		endif 
57c8			;;	call clear_display 
57c8			;	ret 
57c8			 
57c8			 
57c8			 
57c8			endif 
57c8			 
57c8			 
57c8			; eof 
# End of file forth_kernel.asm
57c8			;include "nascombasic.asm" 
57c8			 
57c8			 
57c8			; find out where the code ends if loaded into RAM (for SC114) 
57c8			;endofcode:  
57c8			;	nop 
57c8			 
57c8			 
57c8			; eof 
57c8			 
# End of file main.asm
57c8			;include "firmware_lcd_4x40.asm" 
57c8			;;include "firmware_lcd_4x20.asm" 
57c8			include "firmware_cpm_display.asm" 
57c8			 
57c8			; Serial display interface for SC114 
57c8			 
57c8			 
57c8			display_row_1: equ 0 
57c8			display_row_2: equ display_row_1+display_cols 
57c8			display_row_3: equ display_row_2 + display_cols 
57c8			display_row_4: equ display_row_3 + display_cols 
57c8			 
57c8			kLCDWidth:  EQU display_cols             ;Width in characters 
57c8			kLCD_Line1: EQU 0x00  
57c8			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
57c8			; E1 
57c8			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
57c8			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
57c8			 
57c8			lcd_init: 
57c8				; no init as handled by the SCM bios 
57c8 c9				ret 
57c9			 
57c9			 
57c9			; low level functions for direct screen writes 
57c9			 
57c9			; output char at pos? 
57c9			fLCD_Str: 
57c9			        ;out (SC114_SIO_1_OUT),a 
57c9 c5				push bc 
57ca d5				push de 
57cb 5f				ld e, a 
57cc			; TODO Replace with CP/M BIOS call 
57cc 0e 02			ld c, $02 
57ce cd 05 00			call 5 
57d1 d1				pop de 
57d2 c1				pop bc 
57d3 c9				ret 
57d4			 
57d4			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
57d4			fLCD_Pos: 
57d4				; use ASCII escape to position 
57d4			        ;out (SC114_SIO_1_OUT),a 
57d4 c5				push bc 
57d5 d5				push de 
57d6 5f				ld e, a 
57d7 0e 02			ld c, $02 
57d9			; TODO Replace with CP/M BIOS call 
57d9 cd 05 00			call 5 
57dc d1				pop de 
57dd c1				pop bc 
57de			 
57de c9				ret 
57df			 
57df			; output char at pos 
57df			fLCD_Data: 
57df			      ;  out (SC114_SIO_1_OUT),a 
57df c5				push bc 
57e0 d5				push de 
57e1 0e 02			ld c, $02 
57e3 5f				ld e, a 
57e4			; TODO Replace with CP/M BIOS call 
57e4 cd 05 00			call 5 
57e7 d1				pop de 
57e8 c1				pop bc 
57e9			 
57e9 c9				ret 
57ea			 
57ea			; ascii cls  
57ea			 
57ea 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
57ee			 
57ee 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5805			;.clscpm: db 3, $3c,"$" 
5805			 
5805			; write the frame buffer given in hl to hardware  
5805			write_display: 
5805			 
5805			API: equ 0 
5805			 
5805			if API 
5805				push bc 
5805				ld b, 4 
5805			 
5805			        ld (display_write_tmp), hl 	  
5805			 
5805				; clear and home cursor 
5805			 
5805				ld c, 9 
5805				ld de, .cls 
5805			; TODO Replace with CP/M BIOS call 
5805				call 5 
5805			 
5805			 
5805			.writeln: 
5805			 
5805				ld de, (display_write_tmp) 
5805				ld c, 6 
5805			; TODO Replace with CP/M BIOS call 
5805				rst $30 
5805				ld c, 7 
5805				rst $30 
5805			 
5805				ld hl, (display_write_tmp) 
5805				ld de, display_cols 
5805				add hl,de 
5805				ld (display_write_tmp),hl 
5805			 
5805				djnz  .writeln 
5805			 
5805				pop bc 
5805			 
5805			 
5805				ret 
5805			endif 
5805 e5				push hl 
5806 c5				push bc 
5807 d5				push de 
5808			 
5808			;	ld c, 2 
5808			;	;ld de, .cls 
5808			;	ld a, 27 
5808			;	rst $30 
5808			;	ld c, 2 
5808			;	;ld de, .cls 
5808			;	ld a, '[' 
5808			;	rst $30 
5808			; 
5808			;	ld c, 2 
5808			;	;ld de, .cls 
5808			;	ld a, 'H' 
5808			;	rst $30 
5808			; 
5808			 
5808			 
5808			; lots of CR/LF 
5808			;	ld c, 9 
5808			;	ld de, .clscpm 
5808			;	call 5 
5808			 
5808			; xterm cls 
5808 0e 02			ld c, 2 
580a 1e 1b			ld e, 27 
580c cd 05 00			call 5 
580f			; cls causes too much flicker 
580f			;	ld c, 2 
580f			;	ld e, 'c' 
580f			;	call 5 
580f			 
580f			; use xterm home instead 
580f 0e 02			ld c, 2 
5811 1e 5b			ld e, '[' 
5813 cd 05 00			call 5 
5816 0e 02			ld c, 2 
5818 1e 48			ld e, 'H' 
581a cd 05 00			call 5 
581d			LLL: equ 0 
581d			 
581d			if LLL 
581d			 
581d				ld c, 2 
581d				;ld de, .cls 
581d				ld e, 27 
581d			; TODO Replace with CP/M BIOS call 
581d				call 5 
581d			 
581d			 
581d				ld c, 2 
581d				;ld de, .cls 
581d				ld e, '[' 
581d			; TODO Replace with CP/M BIOS call 
581d				call 5 
581d				ld c, 2 
581d				;ld de, .cls 
581d				ld e, '2' 
581d			; TODO Replace with CP/M BIOS call 
581d				call 5 
581d				ld c, 2 
581d				;ld de, .cls 
581d				ld e, 'J' 
581d			; TODO Replace with CP/M BIOS call 
581d				call 5 
581d			 
581d			endif 
581d			 
581d d1				pop de 
581e c1				pop bc 
581f e1				pop hl 
5820			 
5820			 
5820 22 d8 eb		        ld (display_write_tmp), hl 	  
5823 3e 00			ld a, kLCD_Line1 
5825			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5825 06 28			ld b, display_cols 
5827 ed 5b d8 eb		ld de, (display_write_tmp) 
582b cd ae 58			call write_len_string 
582e				 
582e			 
582e e5			push hl 
582f d5			push de 
5830 c5			push bc 
5831 0e 02			ld c, 2 
5833 1e 0a			ld e, 10 
5835 cd 05 00			call 5 
5838 0e 02			ld c, 2 
583a 1e 0d			ld e, 13 
583c cd 05 00			call 5 
583f			; TODO Replace with CP/M BIOS call 
583f				;rst $30 
583f c1			pop bc 
5840 d1			pop de 
5841 e1			pop hl 
5842			 
5842				 
5842 2a d8 eb			ld hl, (display_write_tmp) 
5845 11 28 00			ld de, display_cols 
5848 19				add hl,de 
5849 22 d8 eb			ld (display_write_tmp),hl 
584c			 
584c				 
584c 3e 28			ld a, kLCD_Line2 
584e			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
584e 06 28			ld b, display_cols 
5850 ed 5b d8 eb		ld de, (display_write_tmp) 
5854 cd ae 58			call write_len_string 
5857				 
5857 2a d8 eb			ld hl, (display_write_tmp) 
585a 11 28 00			ld de, display_cols 
585d 19				add hl,de 
585e 22 d8 eb			ld (display_write_tmp),hl 
5861			 
5861 e5			push hl 
5862 d5			push de 
5863 c5			push bc 
5864 0e 07			ld c, 7 
5866			; TODO Replace with CP/M BIOS call 
5866				;rst $30 
5866 0e 02			ld c, 2 
5868 1e 0a			ld e, 10 
586a cd 05 00			call 5 
586d 0e 02			ld c, 2 
586f 1e 0d			ld e, 13 
5871 cd 05 00			call 5 
5874 c1			pop bc 
5875 d1			pop de 
5876 e1			pop hl 
5877			 
5877				 
5877 3e 50			ld a, kLCD_Line3 
5879			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5879 06 28			ld b, display_cols 
587b ed 5b d8 eb		ld de, (display_write_tmp) 
587f cd ae 58			call write_len_string 
5882				 
5882 2a d8 eb			ld hl, (display_write_tmp) 
5885 11 28 00			ld de, display_cols 
5888 19				add hl,de 
5889 22 d8 eb			ld (display_write_tmp),hl 
588c			 
588c e5			push hl 
588d d5			push de 
588e c5			push bc 
588f 0e 07			ld c, 7 
5891			; TODO Replace with CP/M BIOS call 
5891				;rst $30 
5891 0e 02			ld c, 2 
5893 1e 0a			ld e, 10 
5895 cd 05 00			call 5 
5898 0e 02			ld c, 2 
589a 1e 0d			ld e, 13 
589c cd 05 00			call 5 
589f c1			pop bc 
58a0 d1			pop de 
58a1 e1			pop hl 
58a2			 
58a2				 
58a2 3e 78			ld a, kLCD_Line4 
58a4			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
58a4 06 28			ld b, display_cols 
58a6 ed 5b d8 eb		ld de, (display_write_tmp) 
58aa cd ae 58			call write_len_string 
58ad c9					ret 
58ae			 
58ae			 
58ae				; write out a fixed length string given in b from de 
58ae			 
58ae 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
58af cd df 57		            CALL fLCD_Data      ;Write character to display 
58b2 13				inc de 
58b3 10 f9			djnz write_len_string 
58b5 c9				ret 
58b6			 
58b6			 
58b6			; eof 
# End of file firmware_cpm_display.asm
58b6			;include "firmware_key_5x10.asm" 
58b6			;;include "firmware_key_4x10.asm" 
58b6			include "firmware_key_cpm.asm" 
58b6			; Serial keyboard interface for SC114 
58b6			 
58b6			 
58b6			key_init: 
58b6				; no init as handled by the SCM bios 
58b6 c9				ret 
58b7			 
58b7			 
58b7			cin_wait: 
58b7			;	ld a, 0 
58b7			;	ret 
58b7			 
58b7				;in a,(SC114_SIO_1_IN) 
58b7			        ; Use SCM API to get from whatever console device we are using 
58b7			 
58b7			; TODO Replace with CP/M BIOS call 
58b7 c5				push bc 
58b8 0e 01			ld c, $01 
58ba cd 05 00			call 5 
58bd c1				pop bc 
58be c9				ret 
58bf			 
58bf			cin: 
58bf			 
58bf			 
58bf c5				push bc 
58c0			 
58c0				; any key waiting to process? 
58c0			; TODO Replace with CP/M BIOS call 
58c0 0e 06			ld c, $06 
58c2 cd 05 00			call 5 
58c5 28 0d			jr z, .cin_skip 
58c7			 
58c7				; yep, get it 
58c7			 
58c7 0e 01			ld c, $01 
58c9			; TODO Replace with CP/M BIOS call 
58c9 cd 05 00			call 5 
58cc			 
58cc fe 7f			cp $7f     ; back space 
58ce 20 02			jr nz, .skipbs 
58d0 3e 08			ld a, KEY_BS 
58d2			.skipbs: 
58d2			 
58d2 c1				pop bc 
58d3 c9				ret 
58d4			.cin_skip: 
58d4 3e 00			ld a, 0 
58d6 c1				pop bc 
58d7 c9				ret 
58d8			 
58d8			 
58d8			 
58d8			 
# End of file firmware_key_cpm.asm
58d8			endofcode:  
58d8			baseram:  
58d8 00				nop 
58d9			 
58d9			heap_start: equ baseram+15  ; Starting address of heap 
58d9			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
58d9			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
58d9			;VDU:  EQU     endofcode           ; BASIC Work space 
58d9			; eof 
58d9			 
# End of file os_mega_cpm.asm
58d9
